{"files":[{"patch":"@@ -33,0 +33,1 @@\n+import jdk.internal.crac.Core;\n@@ -34,1 +35,0 @@\n-import jdk.internal.crac.JDKResource.Priority;\n@@ -139,1 +139,1 @@\n-        jdk.internal.crac.Core.getJDKContext().register(this);\n+        Core.Priority.EPOLLSELECTOR.getContext().register(this);\n@@ -415,5 +415,0 @@\n-\n-    @Override\n-    public Priority getPriority() {\n-        return Priority.EPOLLSELECTOR;\n-    }\n","filename":"src\/java.base\/linux\/classes\/sun\/nio\/ch\/EPollSelectorImpl.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.net.InetSocketAddress;\n@@ -68,2 +67,0 @@\n-            JDKContext jdkContext = Core.getJDKContext();\n-            jdkContext.register(this);\n@@ -79,0 +76,1 @@\n+            Core.Priority.FILE_DESCRIPTORS.getContext().register(this);\n@@ -93,5 +91,0 @@\n-        @Override\n-        public Priority getPriority() {\n-            return Priority.FILE_DESCRIPTORS;\n-        }\n-\n@@ -114,6 +107,1 @@\n-        Core.getJDKContext().register(checkpointListener = new JDKResource() {\n-            @Override\n-            public Priority getPriority() {\n-                return Priority.NORMAL;\n-            }\n-\n+        JDKResource resource = new JDKResource() {\n@@ -122,1 +110,1 @@\n-                JDKContext ctx = (JDKContext) context;\n+                JDKContext ctx = Core.getJDKContext();\n@@ -131,1 +119,3 @@\n-        });\n+        };\n+        checkpointListener = resource;\n+        Core.Priority.NORMAL.getContext().register(resource);\n","filename":"src\/java.base\/share\/classes\/java\/io\/FileDescriptor.java","additions":6,"deletions":16,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-            Core.getJDKContext().register(this);\n+            Core.Priority.PRE_FILE_DESRIPTORS.getContext().register(this);\n@@ -117,4 +117,0 @@\n-        @Override\n-        public Priority getPriority() {\n-            return Priority.PRE_FILE_DESRIPTORS;\n-        }\n","filename":"src\/java.base\/share\/classes\/java\/io\/RandomAccessFile.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import jdk.internal.crac.JDKResource;\n@@ -32,1 +31,0 @@\n-import jdk.internal.ref.CleanerImpl;\n@@ -36,1 +34,0 @@\n-import java.lang.ref.Cleaner;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleNatives.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import jdk.internal.crac.JDKResource;\n+import jdk.internal.crac.Core;\n@@ -221,1 +221,1 @@\n-        return new CleanerImpl.PhantomCleanableRef(obj, this, action, JDKResource.Priority.CLEANERS);\n+        return new CleanerImpl.PhantomCleanableRef(obj, this, action, Core.Priority.CLEANERS);\n@@ -225,1 +225,1 @@\n-     * Register an object and action and also register the underlying Reference with a CRaC priority.\n+     * Register an object and object and also register the underlying Reference with a CRaC priority.\n@@ -227,1 +227,1 @@\n-    \/*non-public*\/ Cleanable register(Object obj, Runnable action, JDKResource.Priority priority) {\n+    \/*non-public*\/ Cleanable register(Object obj, Runnable action, Core.Priority priority) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/Cleaner.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.crac.Core;\n@@ -336,1 +337,1 @@\n-            public java.lang.ref.Cleaner.Cleanable cleanerRegisterWithPriority(java.lang.ref.Cleaner cleaner, Object obj, Runnable action, JDKResource.Priority priority) {\n+            public java.lang.ref.Cleaner.Cleanable cleanerRegisterWithPriority(java.lang.ref.Cleaner cleaner, Object obj, Runnable action, Core.Priority priority) {\n@@ -342,5 +343,0 @@\n-            @Override\n-            public Priority getPriority() {\n-                return Priority.REFERENCE_HANDLER;\n-            }\n-\n@@ -358,1 +354,1 @@\n-        jdk.internal.crac.Core.getJDKContext().register(referenceHandlerResource);\n+        Core.Priority.REFERENCE_HANDLER.getContext().register(referenceHandlerResource);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/Reference.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -51,1 +51,0 @@\n-import jdk.internal.crac.Core;\n@@ -54,0 +53,1 @@\n+import jdk.internal.crac.Core;\n@@ -354,5 +354,0 @@\n-            @Override\n-            public Priority getPriority() {\n-                return Priority.NORMAL;\n-            }\n-\n@@ -369,1 +364,1 @@\n-        Core.getJDKContext().register(checkpointListener);\n+        Core.Priority.NORMAL.getContext().register(checkpointListener);\n","filename":"src\/java.base\/share\/classes\/java\/net\/InetAddress.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-    private static final Context<Resource> globalContext = new ContextWrapper(new OrderedContext<>(\"Global Context (javax)\"));\n+    private static final Context<Resource> globalContext = new ContextWrapper(new OrderedContext<>());\n","filename":"src\/java.base\/share\/classes\/javax\/crac\/Core.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import jdk.internal.crac.JDKResource;\n@@ -34,0 +35,1 @@\n+import sun.security.action.GetPropertyAction;\n@@ -73,5 +75,1 @@\n-    private static final Context<Resource> globalContext = new OrderedContext<>(\"GlobalContext\");\n-    static {\n-        \/\/ force JDK context initialization\n-        jdk.internal.crac.Core.getJDKContext();\n-    }\n+    private static final Context<Resource> globalContext = new OrderedContext<>();\n@@ -126,0 +124,1 @@\n+            jdk.internal.crac.Core.getJDKContext().beforeCheckpoint(null);\n@@ -199,0 +198,1 @@\n+            jdk.internal.crac.Core.getJDKContext().afterRestore(null);\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/Core.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2019, 2023, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.crac.impl;\n+\n+import jdk.crac.*;\n+import jdk.internal.crac.LoggerContainer;\n+\n+import java.util.List;\n+\n+\/**\n+ * An abstract context with few utilities.\n+ * @param <R> Type of Resource managed by the context.\n+ *\/\n+public abstract class AbstractContext<R extends Resource> extends Context<R> {\n+    protected abstract List<R> checkpointSnapshot();\n+    protected abstract List<R> restoreSnapshot();\n+\n+    protected void invokeBeforeCheckpoint(Resource resource) throws Exception {\n+        LoggerContainer.debug(\"beforeCheckpoint {0}\", resource);\n+        resource.beforeCheckpoint(this);\n+    }\n+\n+    protected void invokeAfterRestore(Resource resource) throws Exception {\n+        LoggerContainer.debug(\"afterRestore {0}\", resource);\n+        resource.afterRestore(this);\n+    }\n+\n+    @Override\n+    public void beforeCheckpoint(Context<? extends Resource> context) throws CheckpointException {\n+        ExceptionHolder<CheckpointException> checkpointException =\n+            new ExceptionHolder<>(CheckpointException::new);\n+        List<R> resources = checkpointSnapshot();\n+        for (R r : resources) {\n+            try {\n+                invokeBeforeCheckpoint(r);\n+            } catch (Exception e) {\n+                checkpointException.handle(e);\n+            }\n+        }\n+        checkpointException.throwIfAny();\n+    }\n+\n+    @Override\n+    public void afterRestore(Context<? extends Resource> context) throws RestoreException {\n+        ExceptionHolder<RestoreException> restoreException =\n+            new ExceptionHolder<>(RestoreException::new);\n+        List<R> resources = restoreSnapshot();\n+        for (R r : resources) {\n+            try {\n+                invokeAfterRestore(r);\n+            } catch (Exception e) {\n+                restoreException.handle(e);\n+            }\n+        }\n+        restoreException.throwIfAny();\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/impl\/AbstractContext.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -1,164 +0,0 @@\n-\/\/ Copyright 2019-2020 Azul Systems, Inc.\n-\/\/\n-\/\/ Redistribution and use in source and binary forms, with or without\n-\/\/ modification, are permitted provided that the following conditions are met:\n-\/\/\n-\/\/ 1. Redistributions of source code must retain the above copyright notice,\n-\/\/ this list of conditions and the following disclaimer.\n-\/\/\n-\/\/ 2. Redistributions in binary form must reproduce the above copyright notice,\n-\/\/ this list of conditions and the following disclaimer in the documentation\n-\/\/ and\/or other materials provided with the distribution.\n-\/\/\n-\/\/ IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n-\/\/ ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n-\/\/ LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n-\/\/ CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n-\/\/ SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n-\/\/ INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n-\/\/ CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n-\/\/ ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n-\/\/ POSSIBILITY OF SUCH DAMAGE.\n-\n-package jdk.crac.impl;\n-\n-import jdk.crac.*;\n-import jdk.internal.crac.LoggerContainer;\n-\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.List;\n-\n-public abstract class AbstractContextImpl<R extends Resource> extends Context<R> {\n-    private List<Resource> restoreQ = null;\n-    private CheckpointException checkpointException = null;\n-    private RestoreException restoreException = null;\n-\n-    protected void invokeBeforeCheckpoint(Resource resource) {\n-        LoggerContainer.debug(\"beforeCheckpoint {0}\", resource);\n-        recordResource(resource);\n-        try {\n-            resource.beforeCheckpoint(this);\n-        } catch (CheckpointException e) {\n-            handleCheckpointException(e);\n-        } catch (Exception e) {\n-            if (e instanceof InterruptedException) {\n-                Thread.currentThread().interrupt();\n-            }\n-            ensureCheckpointException().addSuppressed(e);\n-        }\n-    }\n-\n-    protected void handleCheckpointException(CheckpointException e) {\n-        CheckpointException ce = ensureCheckpointException();\n-        for (Throwable t : e.getSuppressed()) {\n-            ce.addSuppressed(t);\n-        }\n-        if (e.getMessage() != null) {\n-            ce.addSuppressed(e);\n-        }\n-    }\n-\n-    protected CheckpointException ensureCheckpointException() {\n-        if (checkpointException == null) {\n-            checkpointException = new CheckpointException();\n-        }\n-        return checkpointException;\n-    }\n-\n-    protected void recordResource(Resource resource) {\n-        \/\/ Resource.afterRestore is invoked even if Resource.beforeCheckpoint fails\n-        restoreQ.add(resource);\n-    }\n-\n-    @Override\n-    public void beforeCheckpoint(Context<? extends Resource> context) throws CheckpointException {\n-        \/\/ We won't synchronize access to restoreQ because methods\n-        \/\/ beforeCheckpoint and afterRestore should be invoked only\n-        \/\/ by the single thread performing the C\/R and other threads should\n-        \/\/ not touch that.\n-        restoreQ = new ArrayList<>();\n-        runBeforeCheckpoint();\n-        Collections.reverse(restoreQ);\n-        if (checkpointException != null) {\n-            CheckpointException ce = checkpointException;\n-            checkpointException = null;\n-            throw ce;\n-        }\n-    }\n-\n-    \/\/ This method has particularly verbose name to stick out in thread dumps\n-    \/\/ when the registration leads to a deadlock.\n-    protected void waitWhileCheckpointIsInProgress(R resource) {\n-        if (Thread.currentThread().isInterrupted()) {\n-            LoggerContainer.debug(Thread.currentThread().getName() + \" not waiting in \" + this +\n-                    \" to register \" + resource + \"; the thread has already been interrupted.\");\n-            \/\/ We won't cause IllegalStateException because this is not an unexpected state\n-            \/\/ from the point of CRaC - it probably tried to register some code before.\n-            throw new RuntimeException(\"Interrupted thread tried to block in registration of \" + resource + \" in \" + this);\n-        }\n-        LoggerContainer.debug(Thread.currentThread().getName() + \" waiting in \" + this + \" to register \" + resource);\n-        try {\n-            wait();\n-        } catch (InterruptedException e) {\n-            Thread.currentThread().interrupt();\n-            LoggerContainer.debug(Thread.currentThread().getName() + \" interrupted waiting in \" + this +\n-                    \" to register \" + resource);\n-            throw new RuntimeException(\"Interrupted while trying to register \" + resource + \" in \" + this, e);\n-        }\n-    }\n-\n-    protected abstract void runBeforeCheckpoint();\n-\n-    @Override\n-    public void afterRestore(Context<? extends Resource> context) throws RestoreException {\n-        List<Resource> queue = restoreQ;\n-        if (queue == null) {\n-            return;\n-        }\n-        restoreQ = null;\n-        for (Resource r : queue) {\n-            invokeAfterRestore(r);\n-        }\n-        if (restoreException != null) {\n-            RestoreException re = restoreException;\n-            restoreException = null;\n-            throw re;\n-        }\n-    }\n-\n-    protected void invokeAfterRestore(Resource resource) {\n-        LoggerContainer.debug(\"afterRestore {0}\", resource);\n-        try {\n-            resource.afterRestore(this);\n-        } catch (RestoreException e) {\n-            \/\/ Print error early in case the restore process gets stuck\n-            LoggerContainer.error(e, \"Failed to restore \" + resource);\n-            handleRestoreException(e);\n-        } catch (Exception e) {\n-            if (e instanceof InterruptedException) {\n-                Thread.currentThread().interrupt();\n-            }\n-            LoggerContainer.error(e, \"Failed to restore \" + resource);\n-            ensureRestoreException().addSuppressed(e);\n-        }\n-    }\n-\n-    protected void handleRestoreException(RestoreException e) {\n-        RestoreException re = ensureRestoreException();\n-        for (Throwable t : e.getSuppressed()) {\n-            re.addSuppressed(t);\n-        }\n-        if (e.getMessage() != null) {\n-            re.addSuppressed(e);\n-        }\n-    }\n-\n-    protected RestoreException ensureRestoreException() {\n-        if (restoreException == null) {\n-            restoreException = new RestoreException();\n-        }\n-        return restoreException;\n-    }\n-\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/impl\/AbstractContextImpl.java","additions":0,"deletions":164,"binary":false,"changes":164,"status":"deleted"},{"patch":"@@ -0,0 +1,62 @@\n+package jdk.crac.impl;\n+\n+import jdk.crac.CheckpointException;\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import jdk.crac.RestoreException;\n+import jdk.internal.crac.LoggerContainer;\n+\n+public class BlockingOrderedContext<R extends Resource> extends OrderedContext<R> {\n+    private boolean checkpointing = false;\n+\n+    \/\/ This method has particularly verbose name to stick out in thread dumps\n+    \/\/ when the registration leads to a deadlock.\n+    private void waitWhileCheckpointIsInProgress(R resource) {\n+        if (Thread.currentThread().isInterrupted()) {\n+            \/\/ FIXME this block effectively translates interrupted status to RuntimeException\n+            LoggerContainer.debug(Thread.currentThread().getName() + \" not waiting in \" + this +\n+                \" to register \" + resource + \"; the thread has already been interrupted.\");\n+            \/\/ We won't cause IllegalStateException because this is not an unexpected state\n+            \/\/ from the point of CRaC - it probably tried to register some code before.\n+            throw new RuntimeException(\"Interrupted thread tried to block in registration of \" + resource + \" in \" + this);\n+        }\n+        LoggerContainer.debug(Thread.currentThread().getName() + \" waiting in \" + this + \" to register \" + resource);\n+        try {\n+            wait();\n+        } catch (InterruptedException e) {\n+            \/\/ FIXME there should be no interrupt once we've got interrupted\n+            Thread.currentThread().interrupt();\n+            LoggerContainer.debug(Thread.currentThread().getName() + \" interrupted waiting in \" + this +\n+                \" to register \" + resource);\n+            throw new RuntimeException(\"Interrupted while trying to register \" + resource + \" in \" + this, e);\n+        }\n+    }\n+\n+    @Override\n+    public void beforeCheckpoint(Context<? extends Resource> context) throws CheckpointException {\n+        synchronized (this) {\n+            checkpointing = true;\n+        }\n+        super.beforeCheckpoint(context);\n+    }\n+\n+    @Override\n+    public void afterRestore(Context<? extends Resource> context) throws RestoreException {\n+        \/\/ unblock all registrations before running afterRestore()'s\n+        synchronized (this) {\n+            checkpointing = false;\n+            notifyAll();\n+        }\n+        super.afterRestore(context);\n+    }\n+\n+    @Override\n+    public void register(R resource) {\n+        synchronized (this) {\n+            while (checkpointing) {\n+                waitWhileCheckpointIsInProgress(resource);\n+            }\n+            super.register(resource);\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/impl\/BlockingOrderedContext.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,90 @@\n+package jdk.crac.impl;\n+\n+import jdk.crac.CheckpointException;\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import jdk.crac.RestoreException;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.WeakHashMap;\n+\n+\/**\n+ * Context performing Checkpoint notification in unspecified order.\n+ * Concurrent registration along beforeCheckpoint notification triggers\n+ * immediate notification on being registered resource.\n+ * @param <R>\n+ *\/\n+public class CriticalUnorderedContext<R extends Resource> extends AbstractContext<R> {\n+    private final WeakHashMap<R, Void> resources = new WeakHashMap<>();\n+    private ExceptionHolder<CheckpointException> concurrentCheckpointException = null;\n+\n+    private synchronized List<R> snapshot() {\n+        return this.resources.entrySet().stream()\n+            .map(Map.Entry::getKey)\n+            .toList();\n+    }\n+\n+    @Override\n+    protected List<R> checkpointSnapshot() {\n+        return snapshot();\n+    }\n+\n+    @Override\n+    protected List<R> restoreSnapshot() {\n+        \/\/ return updated set, as registration has called beforeCheckpoint()\n+        return snapshot();\n+    }\n+\n+    @Override\n+    public void beforeCheckpoint(Context<? extends Resource> context) throws CheckpointException {\n+        synchronized (this) {\n+            concurrentCheckpointException = new ExceptionHolder<>(CheckpointException::new);\n+        }\n+\n+        try {\n+            super.beforeCheckpoint(context);\n+        } catch (CheckpointException e) {\n+            synchronized (this) {\n+                concurrentCheckpointException.handle(e);\n+            }\n+        }\n+        synchronized (this) {\n+            ExceptionHolder<CheckpointException> e = concurrentCheckpointException;\n+            concurrentCheckpointException = new ExceptionHolder<>(CheckpointException::new);\n+            e.throwIfAny();\n+        }\n+    }\n+\n+    @Override\n+    public void afterRestore(Context<? extends Resource> context) throws RestoreException {\n+        CheckpointException racedException;\n+        synchronized (this) {\n+            racedException = concurrentCheckpointException.getIfAny();\n+            concurrentCheckpointException = null;\n+        }\n+\n+        ExceptionHolder<RestoreException> restoreException = new ExceptionHolder<>(RestoreException::new);\n+        restoreException.handle(racedException);\n+\n+        restoreException.runWithHandler(() -> {\n+            super.afterRestore(context);\n+        });\n+\n+        restoreException.throwIfAny();\n+    }\n+\n+    @Override\n+    public void register(R resource) {\n+        synchronized (this) {\n+            resources.put(resource, null);\n+            if (concurrentCheckpointException != null) {\n+                try {\n+                    invokeBeforeCheckpoint(resource);\n+                } catch (Exception e) {\n+                    concurrentCheckpointException.handle(e);\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/impl\/CriticalUnorderedContext.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+package jdk.crac.impl;\n+\n+import java.util.function.Supplier;\n+\n+public class ExceptionHolder<E extends Exception> {\n+    E exception = null;\n+    final Supplier<E> constructor;\n+\n+    public ExceptionHolder(Supplier<E> constructor) {\n+        this.constructor = constructor;\n+    }\n+\n+    public E get() {\n+        if (exception == null) {\n+            exception = constructor.get();\n+        }\n+        return exception;\n+    }\n+\n+    public void throwIfAny() throws E {\n+        if (exception != null) {\n+            throw exception;\n+        }\n+    }\n+\n+    public void handle(Exception e) throws RuntimeException {\n+        if (e == null) {\n+            return;\n+        }\n+\n+        E exception = get();\n+        if (exception.getClass() == e.getClass()) {\n+            if (e.getMessage() != null) {\n+                exception.addSuppressed(e); \/\/ FIXME avoid message \/ preserve it via a distinct Exception\n+            }\n+            for (Throwable t : e.getSuppressed()) {\n+                exception.addSuppressed(t);\n+            }\n+        } else {\n+            if (e instanceof InterruptedException) {\n+                \/\/ FIXME interrupt re-set should be up to the Context implementation, as\n+                \/\/ some implementations may prefer to continue beforeCheckpoint\/afterRestore\n+                \/\/ notification, rather than exiting as soon as possible.\n+                Thread.currentThread().interrupt();\n+            }\n+            exception.addSuppressed(e);\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/impl\/ExceptionHolder.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -31,4 +31,1 @@\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.WeakHashMap;\n+import java.util.*;\n@@ -36,5 +33,9 @@\n-public class OrderedContext<R extends Resource> extends AbstractContextImpl<R> {\n-    private final String name;\n-    private boolean checkpointing = false;\n-    protected long order = 0;\n-    protected final WeakHashMap<R, Long> resources = new WeakHashMap<>();\n+\/**\n+ * Context performing Checkpoint notification in reverse order of registration.\n+ * Concurrent registration along notification is silently ignored.\n+ * @param <R>\n+ *\/\n+public class OrderedContext<R extends Resource> extends AbstractContext<R> {\n+    private final WeakHashMap<R, Long> resources = new WeakHashMap<>();\n+    private long order = 0;\n+    private List<R> restoreSnapshot = null;\n@@ -42,2 +43,11 @@\n-    public OrderedContext(String name) {\n-        this.name = name;\n+    protected List<R> checkpointSnapshot() {\n+        List<R> snapshot;\n+        synchronized (this) {\n+            snapshot = this.resources.entrySet().stream()\n+                .sorted(Collections.reverseOrder(Map.Entry.comparingByValue()))\n+                .map(Map.Entry::getKey)\n+                .toList();\n+        }\n+        restoreSnapshot = new ArrayList<>(snapshot);\n+        Collections.reverse(restoreSnapshot);\n+        return snapshot;\n@@ -46,3 +56,8 @@\n-    @Override\n-    public String toString() {\n-        return name != null ? name : super.toString();\n+    \/\/ We won't synchronize access to restoreSnapshot because methods\n+    \/\/ beforeCheckpoint and afterRestore should be invoked only\n+    \/\/ by the single thread performing the C\/R and other threads should\n+    \/\/ not touch that.\n+    protected List<R> restoreSnapshot() {\n+        List<R> snapshot = restoreSnapshot;\n+        restoreSnapshot = null;\n+        return snapshot;\n@@ -53,3 +68,0 @@\n-        while (checkpointing) {\n-            waitWhileCheckpointIsInProgress(resource);\n-        }\n@@ -58,24 +70,0 @@\n-\n-    @Override\n-    protected void runBeforeCheckpoint() {\n-        List<R> resources;\n-        synchronized (this) {\n-            checkpointing = true;\n-            resources = this.resources.entrySet().stream()\n-                    .sorted(Collections.reverseOrder(Map.Entry.comparingByValue()))\n-                    .map(Map.Entry::getKey)\n-                    .toList();\n-        }\n-        for (R r : resources) {\n-            invokeBeforeCheckpoint(r);\n-        }\n-    }\n-\n-    @Override\n-    public void afterRestore(Context<? extends Resource> context) throws RestoreException {\n-        synchronized (this) {\n-            checkpointing = false;\n-            notifyAll();\n-        }\n-        super.afterRestore(context);\n-    }\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/impl\/OrderedContext.java","additions":29,"deletions":41,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -1,138 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.crac.impl;\n-\n-import jdk.crac.*;\n-import jdk.internal.crac.LoggerContainer;\n-\n-import java.util.*;\n-\n-public abstract class PriorityContext<P, R extends Resource> extends AbstractContextImpl<R> {\n-    private final TreeMap<P, SubContext> categories;\n-    private final Comparator<P> comparator;\n-    private P lastPriority = null;\n-\n-    protected PriorityContext(Comparator<P> comparator) {\n-        this.categories = new TreeMap<>(comparator);\n-        this.comparator = comparator;\n-    }\n-\n-    protected synchronized void register(R resource, P priority) {\n-        while (lastPriority != null && comparator.compare(lastPriority, priority) >= 0) {\n-            waitWhileCheckpointIsInProgress(resource);\n-        }\n-        \/\/ computeIfAbsent does not work well here with lambda\n-        SubContext category = categories.get(priority);\n-        if (category == null) {\n-            category = new SubContext(getClass().getSimpleName() + \"[\" + priority + \"]\");\n-            categories.put(priority, category);\n-        }\n-        category.registerInSub(resource);\n-    }\n-\n-    @Override\n-    protected void runBeforeCheckpoint() {\n-        Map.Entry<P, SubContext> entry;\n-        \/\/ We will use fine-grained synchronization to allow registration for higher category\n-        \/\/ in another thread.\n-        synchronized (this) {\n-            if (categories.isEmpty()) {\n-                return;\n-            }\n-            \/\/ This type of iteration should be O(N*log(N)), same as sorting, and does not suffer\n-            \/\/ from concurrent modifications. We'll track modifications for lower priorities in register()\n-            entry = categories.firstEntry();\n-            lastPriority = entry.getKey();\n-        }\n-        for (;;) {\n-            invokeBeforeCheckpoint(entry.getValue());\n-            synchronized (this) {\n-                entry = categories.higherEntry(entry.getKey());\n-                if (entry != null) {\n-                    lastPriority = entry.getKey();\n-                } else {\n-                    return;\n-                }\n-            }\n-        }\n-    }\n-\n-    @Override\n-    public void afterRestore(Context<? extends Resource> context) throws RestoreException {\n-        synchronized (this) {\n-            lastPriority = null;\n-            notifyAll();\n-        }\n-        super.afterRestore(context);\n-    }\n-\n-    public class SubContext extends OrderedContext<R> {\n-        public SubContext(String name) {\n-            super(name);\n-        }\n-\n-        synchronized void registerInSub(R r) {\n-            resources.put(r, order++);\n-        }\n-\n-        \/\/ This method differs from the super method only by the\n-        \/\/ parameter to the beforeCheckpoint method\n-        @Override\n-        protected void invokeBeforeCheckpoint(Resource resource) {\n-            LoggerContainer.debug(\"beforeCheckpoint {0}\", resource);\n-            recordResource(resource);\n-            try {\n-                resource.beforeCheckpoint(PriorityContext.this);\n-            } catch (CheckpointException e) {\n-                handleCheckpointException(e);\n-            } catch (Exception e) {\n-                if (e instanceof InterruptedException) {\n-                    Thread.currentThread().interrupt();\n-                }\n-                ensureCheckpointException().addSuppressed(e);\n-            }\n-        }\n-\n-        \/\/ This method differs from the super method only by the\n-        \/\/ parameter to the afterRestore method\n-        @Override\n-        protected void invokeAfterRestore(Resource resource) {\n-            LoggerContainer.debug(\"afterRestore {0}\", resource);\n-            try {\n-                resource.afterRestore(PriorityContext.this);\n-            } catch (RestoreException e) {\n-                \/\/ Print error early in case the restore process gets stuck\n-                LoggerContainer.error(e, \"Failed to restore \" + resource);\n-                handleRestoreException(e);\n-            } catch (Exception e) {\n-                if (e instanceof InterruptedException) {\n-                    Thread.currentThread().interrupt();\n-                }\n-                LoggerContainer.error(e, \"Failed to restore \" + resource);\n-                ensureRestoreException().addSuppressed(e);\n-            }\n-        }\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/impl\/PriorityContext.java","additions":0,"deletions":138,"binary":false,"changes":138,"status":"deleted"},{"patch":"@@ -28,2 +28,0 @@\n-import jdk.internal.crac.JDKResource;\n-\n@@ -32,0 +30,2 @@\n+import jdk.internal.crac.Core;\n+\n@@ -52,1 +52,1 @@\n-     * Calls package-private {@link Cleaner#register(Object, Runnable, JDKResource.Priority)}.\n+     * Calls package-private {@link Cleaner#register(Object, Runnable, Core.Priority)}.\n@@ -54,1 +54,1 @@\n-    Cleaner.Cleanable cleanerRegisterWithPriority(Cleaner cleaner, Object obj, Runnable action, JDKResource.Priority priority);\n+    Cleaner.Cleanable cleanerRegisterWithPriority(Cleaner cleaner, Object obj, Runnable action, Core.Priority priority);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangRefAccess.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -29,0 +29,4 @@\n+import jdk.crac.Context;\n+import jdk.crac.impl.BlockingOrderedContext;\n+import jdk.crac.impl.CriticalUnorderedContext;\n+\n@@ -30,1 +34,1 @@\n-    private static JDKContext JDKContext;\n+    private static JDKContext jdkContext = new JDKContext();;\n@@ -32,3 +36,2 @@\n-    static {\n-        JDKContext = new JDKContext();\n-        jdk.crac.Core.getGlobalContext().register(JDKContext);\n+    public static JDKContext getJDKContext() {\n+        return jdkContext;\n@@ -37,2 +40,30 @@\n-    public static JDKContext getJDKContext() {\n-        return JDKContext;\n+\n+    \/**\n+     * Priorities are defined in the order of registration to the global context.\n+     * Checkpoint notification will be processed in the order from the bottom to the top of the list.\n+     * Restore will be done in reverse order: from the top to the bottom.\n+     *\n+     * Resources of the same priority will be handled according the context supplied to the priority.\n+     *\n+     * Most resources should use priority NORMAL (the lowest priority).\n+     *\/\n+    public enum Priority {\n+        FILE_DESCRIPTORS(new BlockingOrderedContext<>()),\n+        PRE_FILE_DESRIPTORS(new BlockingOrderedContext<>()),\n+        CLEANERS(new BlockingOrderedContext<>()),\n+        REFERENCE_HANDLER(new BlockingOrderedContext<>()),\n+        SEEDER_HOLDER(new BlockingOrderedContext<>()),\n+        SECURE_RANDOM(new BlockingOrderedContext<>()),\n+        NATIVE_PRNG(new BlockingOrderedContext<>()),\n+        EPOLLSELECTOR(new BlockingOrderedContext<>()),\n+        NORMAL(new BlockingOrderedContext<>());\n+\n+        private final Context<JDKResource> context;\n+        Priority(Context<JDKResource> context) {\n+            jdk.crac.Core.getGlobalContext().register(context);\n+            this.context = context;\n+        }\n+\n+        public Context<JDKResource> getContext() {\n+            return context;\n+        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/Core.java","additions":37,"deletions":6,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import jdk.crac.impl.PriorityContext;\n@@ -43,1 +42,0 @@\n-import java.util.Comparator;\n@@ -48,1 +46,1 @@\n-public class JDKContext extends PriorityContext<JDKResource.Priority, JDKResource> {\n+public class JDKContext implements JDKResource {\n@@ -52,8 +50,0 @@\n-    \/\/ We cannot use method references\/lambdas when the context is created\n-    private static final Comparator<JDKResource.Priority> PRIORITY_COMPARATOR = new Comparator<>() {\n-        @Override\n-        public int compare(JDKResource.Priority p1, JDKResource.Priority p2) {\n-            return p1.compareTo(p2);\n-        }\n-    };\n-\n@@ -68,4 +58,0 @@\n-    JDKContext() {\n-        super(PRIORITY_COMPARATOR);\n-    }\n-\n@@ -97,1 +83,0 @@\n-        super.beforeCheckpoint(context);\n@@ -102,1 +87,0 @@\n-        super.afterRestore(context);\n@@ -106,5 +90,0 @@\n-    @Override\n-    public void register(JDKResource resource) {\n-        register(resource, resource.getPriority());\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/JDKContext.java","additions":1,"deletions":22,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.crac.Context;\n@@ -32,60 +33,0 @@\n-    \/**\n-     * JDK Resource priorities.\n-     * Priorities are defined in the order from lowest to highest.\n-     * Most resources should use priority NORMAL (the lowest priority).\n-     * Other priorities define sequence of checkpoint notification\n-     * for dependent resources.\n-     * Checkpoint notification will be processed in the order from the lowest\n-     * to the highest priorities.\n-     * Restore notification will be processed in the revers order:\n-     * from the highest to the lowest priorities.\n-     * JDK resources with the same priority will be notified about checkpoint\n-     * in the reverse order of registration.\n-     * JDK resources with the same priority will be notified about restore\n-     * in the direct order of registration.\n-     *\/\n-    enum Priority {\n-        \/**\n-         * Most resources should use this option.\n-         *\/\n-        NORMAL,\n-        \/**\n-         * Priority of the\n-         * sun.nio.ch.EPollSelectorImpl resource\n-         *\/\n-        EPOLLSELECTOR,\n-        \/**\n-         * Priority of the\n-         * sun.security.provider.NativePRNG resource\n-         *\/\n-        NATIVE_PRNG,\n-        \/**\n-         * Priority of the\n-         * sun.security.provider.SecureRandom resource\n-         *\/\n-        SECURE_RANDOM,\n-        \/**\n-         * Priority of the\n-         * sun.security.provider.SecureRandom.SeederHolder resource\n-         *\/\n-        SEEDER_HOLDER,\n-\n-        \/* Keep next priorities last to ensure handling of pending References\n-         * appeared on earlier priorities. *\/\n-\n-        \/**\n-         * Priority of the\n-         * java.lan.ref.Reference static resource\n-         *\/\n-        REFERENCE_HANDLER,\n-        \/**\n-         * Priority of the\n-         * jdk.internal.ref.CleanerImpl resources\n-         *\/\n-        CLEANERS,\n-\n-        PRE_FILE_DESRIPTORS,\n-        FILE_DESCRIPTORS,\n-    };\n-\n-    Priority getPriority();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/JDKResource.java","additions":1,"deletions":60,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -31,2 +31,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -37,1 +35,0 @@\n-import jdk.crac.CheckpointException;\n@@ -40,0 +37,1 @@\n+import jdk.internal.crac.Core;\n@@ -160,1 +158,0 @@\n-        private final JDKResource.Priority priority;\n@@ -169,1 +166,1 @@\n-        public PhantomCleanableRef(Object obj, Cleaner cleaner, Runnable action, JDKResource.Priority priority) {\n+        public PhantomCleanableRef(Object obj, Cleaner cleaner, Runnable action, Core.Priority priority) {\n@@ -172,1 +169,0 @@\n-            this.priority = priority;\n@@ -174,1 +170,1 @@\n-                jdk.internal.crac.Core.getJDKContext().register(this);\n+                priority.getContext().register(this);\n@@ -184,1 +180,0 @@\n-            this.priority = Priority.CLEANERS;\n@@ -213,6 +208,1 @@\n-        public Priority getPriority() {\n-            return priority;\n-        }\n-\n-        @Override\n-        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+        public void beforeCheckpoint(Context<? extends Resource> context) {\n@@ -225,1 +215,1 @@\n-        public void afterRestore(Context<? extends Resource> context) throws Exception {\n+        public void afterRestore(Context<? extends Resource> context) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/ref\/CleanerImpl.java","additions":5,"deletions":15,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.crac.Core;\n@@ -32,1 +33,0 @@\n-import jdk.internal.crac.Core;\n@@ -43,1 +43,1 @@\n-        Core.getJDKContext().register(this);\n+        Core.Priority.NORMAL.getContext().register(this);\n@@ -56,5 +56,0 @@\n-\n-    @Override\n-    public Priority getPriority() {\n-        return Priority.NORMAL;\n-    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/jar\/PersistentJarFile.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import jdk.internal.crac.JDKContext;\n@@ -154,1 +153,1 @@\n-            Core.getJDKContext().register(this);\n+            Core.Priority.NORMAL.getContext().register(this);\n@@ -168,1 +167,1 @@\n-            ((JDKContext)context).claimFd(((FileInputStream)in).getFD(), this);\n+            Core.getJDKContext().claimFd(((FileInputStream)in).getFD(), this);\n@@ -175,5 +174,0 @@\n-\n-        @Override\n-        public Priority getPriority() {\n-            return Priority.NORMAL;\n-        }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/FileInputStreamPool.java","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.crac.Core;\n@@ -129,1 +130,1 @@\n-        jdk.internal.crac.Core.getJDKContext().register(this);\n+        Core.Priority.SECURE_RANDOM.getContext().register(this);\n@@ -241,5 +242,0 @@\n-    @Override\n-    public Priority getPriority() {\n-        return Priority.SECURE_RANDOM;\n-    }\n-\n@@ -265,1 +261,1 @@\n-            jdk.internal.crac.Core.getJDKContext().register(this);\n+            Core.Priority.SEEDER_HOLDER.getContext().register(this);\n@@ -283,5 +279,0 @@\n-\n-        @Override\n-        public Priority getPriority() {\n-            return Priority.SEEDER_HOLDER;\n-        }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/SecureRandom.java","additions":3,"deletions":12,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+import jdk.internal.crac.Core;\n@@ -61,1 +62,0 @@\n-import java.io.*;\n@@ -70,0 +70,4 @@\n+        CracSubscriber() {\n+            Core.Priority.NORMAL.getContext().register(this);\n+        }\n+\n@@ -78,5 +82,0 @@\n-\n-        @Override\n-        public Priority getPriority() {\n-            return Priority.NORMAL;\n-        }\n@@ -106,1 +105,0 @@\n-        jdk.internal.crac.Core.getJDKContext().register(theCracSubscriber);\n","filename":"src\/java.base\/unix\/classes\/java\/lang\/ProcessEnvironment.java","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import jdk.internal.crac.JDKResource.Priority;\n@@ -53,5 +52,0 @@\n-\n-        @Override\n-        public Priority getPriority() {\n-            return Priority.NORMAL;\n-        }\n@@ -68,1 +62,1 @@\n-        Core.getJDKContext().register(resourceProxy);\n+        Core.Priority.NORMAL.getContext().register(resourceProxy);\n","filename":"src\/java.base\/unix\/classes\/java\/net\/PlainSocketImpl.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import java.util.Map;\n@@ -38,0 +37,1 @@\n+import jdk.internal.crac.Core;\n@@ -58,2 +58,2 @@\n-    static {\n-        jdk.internal.crac.Core.getJDKContext().register(instance);\n+    private JarFileFactory() {\n+        Core.Priority.NORMAL.getContext().register(this);\n@@ -62,2 +62,0 @@\n-    private JarFileFactory() { }\n-\n@@ -249,5 +247,0 @@\n-    @Override\n-    public Priority getPriority() {\n-        return Priority.NORMAL;\n-    }\n-\n","filename":"src\/java.base\/unix\/classes\/sun\/net\/www\/protocol\/jar\/JarFileFactory.java","additions":3,"deletions":10,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -50,5 +50,0 @@\n-\n-        @Override\n-        public Priority getPriority() {\n-            return Priority.NORMAL;\n-        }\n@@ -66,1 +61,1 @@\n-        Core.getJDKContext().register(resourceProxy);\n+        Core.Priority.NORMAL.getContext().register(resourceProxy);\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/ch\/FileDispatcherImpl.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import jdk.internal.crac.JDKContext;\n@@ -403,1 +402,1 @@\n-            Core.getJDKContext().register(this);\n+            Core.Priority.NATIVE_PRNG.getContext().register(this);\n@@ -617,5 +616,0 @@\n-\n-        @Override\n-        public Priority getPriority() {\n-            return Priority.NATIVE_PRNG;\n-        }\n","filename":"src\/java.base\/unix\/classes\/sun\/security\/provider\/NativePRNG.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -25,0 +25,2 @@\n+import jdk.crac.impl.BlockingOrderedContext;\n+import jdk.crac.impl.CriticalUnorderedContext;\n@@ -29,3 +31,2 @@\n-import java.util.ArrayList;\n-import java.util.LinkedList;\n-import java.util.List;\n+import java.lang.reflect.Method;\n+import java.util.*;\n@@ -37,1 +38,1 @@\n-import static jdk.internal.crac.JDKResource.Priority.*;\n+import static jdk.internal.crac.Core.Priority.*;\n@@ -45,1 +46,5 @@\n- * @run main\/othervm -ea -XX:CREngine=simengine -XX:CRaCCheckpointTo=ignored ContextOrderTest\n+ * @run main\/othervm -ea -XX:CREngine=simengine -XX:CRaCCheckpointTo=ignored ContextOrderTest testOrder\n+ * @run main\/othervm -ea -XX:CREngine=simengine -XX:CRaCCheckpointTo=ignored ContextOrderTest testRegisterBlocks\n+ * @run main\/othervm -ea -XX:CREngine=simengine -XX:CRaCCheckpointTo=ignored ContextOrderTest testThrowing\n+ * @run main\/othervm -ea -XX:CREngine=simengine -XX:CRaCCheckpointTo=ignored ContextOrderTest testRegisterToCompleted\n+ * @run main\/othervm -ea -XX:CREngine=simengine -XX:CRaCCheckpointTo=ignored ContextOrderTest testRegisterFromOtherThread\n@@ -54,5 +59,2 @@\n-        testOrder();\n-        testRegisterBlocks();\n-        testThrowing();\n-        testRegisterToCompleted();\n-        testRegisterFromOtherThread();\n+        Method m = ContextOrderTest.class.getDeclaredMethod(args[0]);\n+        m.invoke(null);\n@@ -63,4 +65,4 @@\n-        getGlobalContext().register(new MockResource(recorder, null, \"regular1\"));\n-        getJDKContext().register(new MockResource(recorder, NORMAL, \"jdk-normal\"));\n-        getJDKContext().register(new MockResource(recorder, SECURE_RANDOM, \"jdk-later\"));\n-        getGlobalContext().register(new CreatingResource<>(recorder, null, \"regular2\", getJDKContext(), NORMAL));\n+        getGlobalContext().register(new MockResource(recorder, \"regular1\"));\n+        NORMAL.getContext().register(new MockResource(recorder, \"jdk-normal\"));\n+        SECURE_RANDOM.getContext().register(new MockResource(recorder, \"jdk-later\"));\n+        getGlobalContext().register(new CreatingResource<>(recorder, \"regular2\", NORMAL.getContext()));\n@@ -68,1 +70,1 @@\n-        getJDKContext().register(new CreatingResource<>(recorder, NORMAL, \"jdk-create\", getJDKContext(), SEEDER_HOLDER));\n+        NORMAL.getContext().register(new CreatingResource<>(recorder, \"jdk-create\", SEEDER_HOLDER.getContext()));\n@@ -97,3 +99,0 @@\n-\n-        rememberMe.clear();\n-        System.gc();\n@@ -104,0 +103,2 @@\n+        BlockingOrderedContext<Resource> blockingCtx = new BlockingOrderedContext();\n+        getGlobalContext().register(blockingCtx);\n@@ -105,2 +106,1 @@\n-        getGlobalContext().register(new CreatingResource<>(recorder, null, \"regular\",\n-                getGlobalContext(), null));\n+        blockingCtx.register(new CreatingResource<>(recorder, \"regular\", blockingCtx));\n@@ -109,3 +109,6 @@\n-        \/\/ blocks registering with lower priority\n-        getJDKContext().register(new CreatingResource<>(recorder, SECURE_RANDOM, \"jdk-lower\",\n-                getJDKContext(), NORMAL));\n+        BlockingOrderedContext<Resource> blockingCtx1 = new BlockingOrderedContext();\n+        getGlobalContext().register(blockingCtx1);\n+        BlockingOrderedContext<Resource> blockingCtx2 = new BlockingOrderedContext();\n+        getGlobalContext().register(blockingCtx2);\n+        \/\/ blocks registering to the context done notifications\n+        blockingCtx1.register(new CreatingResource<>(recorder, \"jdk-lower\", blockingCtx2));\n@@ -115,2 +118,1 @@\n-        getJDKContext().register(new CreatingResource<>(recorder, NORMAL, \"jdk-same\",\n-                getJDKContext(), NORMAL));\n+        NORMAL.getContext().register(new CreatingResource<>(recorder, \"jdk-same\", NORMAL.getContext()));\n@@ -126,1 +128,0 @@\n-                assertTrue(Thread.currentThread().isInterrupted());\n@@ -129,1 +130,1 @@\n-        }, \"AbstractContextImpl\", \"waitWhileCheckpointIsInProgress\");\n+        }, null, \"waitWhileCheckpointIsInProgress\");\n@@ -132,2 +133,0 @@\n-        rememberMe.clear();\n-        System.gc();\n@@ -149,0 +148,6 @@\n+                        System.out.println(thread.getState() + \" \" + thread.isAlive());\n+                        if (thread.getState() == Thread.State.WAITING) {\n+                            for (var ste2 : thread.getStackTrace()) {\n+                                System.out.println(ste2);\n+                            }\n+                        }\n@@ -167,6 +172,6 @@\n-        getGlobalContext().register(new MockResource(recorder, null, \"regular1\"));\n-        getGlobalContext().register(new ThrowingResource(recorder, null, \"throwing1\"));\n-        getGlobalContext().register(new MockResource(recorder, null, \"regular2\"));\n-        getJDKContext().register(new MockResource(recorder, NORMAL, \"jdk1\"));\n-        getJDKContext().register(new ThrowingResource(recorder, JDKResource.Priority.EPOLLSELECTOR, \"throwing2\"));\n-        getJDKContext().register(new MockResource(recorder, SECURE_RANDOM, \"jdk2\"));\n+        getGlobalContext().register(new MockResource(recorder, \"regular1\"));\n+        getGlobalContext().register(new ThrowingResource(recorder, \"throwing1\"));\n+        getGlobalContext().register(new MockResource(recorder, \"regular2\"));\n+        NORMAL.getContext().register(new MockResource(recorder, \"jdk1\"));\n+        EPOLLSELECTOR.getContext().register(new ThrowingResource(recorder, \"throwing2\"));\n+        SECURE_RANDOM.getContext().register(new MockResource(recorder, \"jdk2\"));\n@@ -194,0 +199,1 @@\n+    }\n@@ -195,2 +201,5 @@\n-        rememberMe.clear();\n-        System.gc();\n+    static class NamedOrderedContext<R extends Resource> extends BlockingOrderedContext {\n+        private final String name;\n+        NamedOrderedContext(String name) {\n+            this.name = name;\n+        }\n@@ -204,2 +213,2 @@\n-        OrderedContext<Resource> c1 = new OrderedContext<>(\"C1\");\n-        OrderedContext<Resource> c2 = new OrderedContext<>(\"C2\");\n+        OrderedContext<Resource> c1 = new NamedOrderedContext<>(\"C1\");\n+        OrderedContext<Resource> c2 = new NamedOrderedContext<>(\"C2\");\n@@ -208,1 +217,1 @@\n-        c2.register(new MockResource(recorder, null, \"first\"));\n+        c2.register(new MockResource(recorder, \"first\"));\n@@ -212,1 +221,1 @@\n-        c1.register(new CreatingResource<>(recorder, null, \"second\", c2, null));\n+        c1.register(new CreatingResource<>(recorder, \"second\", c2));\n@@ -227,1 +236,1 @@\n-        getJDKContext().register(new MockResource(recorder, NORMAL, \"normal\") {\n+        NORMAL.getContext().register(new MockResource(recorder, \"normal\") {\n@@ -232,1 +241,1 @@\n-                    getJDKContext().register(new MockResource(recorder, CLEANERS, \"child\"));\n+                    CLEANERS.getContext().register(new MockResource(recorder, \"child\"));\n@@ -248,1 +257,0 @@\n-        protected final Priority priority;\n@@ -251,1 +259,1 @@\n-        private MockResource(List<String> recorder, Priority priority, String id) {\n+        private MockResource(List<String> recorder, String id) {\n@@ -254,1 +262,0 @@\n-            this.priority = priority;\n@@ -258,5 +265,0 @@\n-        @Override\n-        public Priority getPriority() {\n-            return priority;\n-        }\n-\n@@ -265,1 +267,0 @@\n-            ensureJDKContext(context);\n@@ -271,1 +272,0 @@\n-            ensureJDKContext(context);\n@@ -275,6 +275,0 @@\n-        private void ensureJDKContext(Context<? extends Resource> context) {\n-            if (priority != null && context != getJDKContext()) {\n-                throw new AssertionError(id + \"expecting JDKContext, got \" + context.toString());\n-            }\n-        }\n-\n@@ -293,1 +287,0 @@\n-        private final Priority childPriority;\n@@ -297,2 +290,2 @@\n-        private CreatingResource(List<String> recorder, Priority priority, String id, Context<R> childContext, Priority childPriority) {\n-            super(recorder, priority, id);\n+        private CreatingResource(List<String> recorder, String id, Context<R> childContext) {\n+            super(recorder, id);\n@@ -300,1 +293,0 @@\n-            this.childPriority = childPriority;\n@@ -308,1 +300,1 @@\n-                childContext.register((R) new MockResource(recorder, childPriority, id + \"-child1\"));\n+                childContext.register((R) new MockResource(recorder, id + \"-child1\"));\n@@ -317,1 +309,1 @@\n-                childContext.register((R) new MockResource(recorder, childPriority, id + \"-child2\"));\n+                childContext.register((R) new MockResource(recorder, id + \"-child2\"));\n@@ -324,2 +316,2 @@\n-        private ThrowingResource(List<String> recorder, Priority priority, String id) {\n-            super(recorder, priority, id);\n+        private ThrowingResource(List<String> recorder, String id) {\n+            super(recorder, id);\n","filename":"test\/jdk\/jdk\/crac\/ContextOrderTest.java","additions":59,"deletions":67,"binary":false,"changes":126,"status":"modified"}]}