{"files":[{"patch":"@@ -1,90 +0,0 @@\n-package jdk.crac.impl;\n-\n-import jdk.crac.CheckpointException;\n-import jdk.crac.Context;\n-import jdk.crac.Resource;\n-import jdk.crac.RestoreException;\n-\n-import java.util.List;\n-import java.util.Map;\n-import java.util.WeakHashMap;\n-\n-\/**\n- * Context performing Checkpoint notification in unspecified order.\n- * Concurrent registration along beforeCheckpoint notification triggers\n- * immediate notification on being registered resource.\n- * @param <R>\n- *\/\n-public class CriticalUnorderedContext<R extends Resource> extends AbstractContext<R> {\n-    private final WeakHashMap<R, Void> resources = new WeakHashMap<>();\n-    private ExceptionHolder<CheckpointException> concurrentCheckpointException = null;\n-\n-    private synchronized List<R> snapshot() {\n-        return this.resources.entrySet().stream()\n-            .map(Map.Entry::getKey)\n-            .toList();\n-    }\n-\n-    @Override\n-    protected List<R> checkpointSnapshot() {\n-        return snapshot();\n-    }\n-\n-    @Override\n-    protected List<R> restoreSnapshot() {\n-        \/\/ return updated set, as registration has called beforeCheckpoint()\n-        return snapshot();\n-    }\n-\n-    @Override\n-    public void beforeCheckpoint(Context<? extends Resource> context) throws CheckpointException {\n-        synchronized (this) {\n-            concurrentCheckpointException = new ExceptionHolder<>(CheckpointException::new);\n-        }\n-\n-        try {\n-            super.beforeCheckpoint(context);\n-        } catch (CheckpointException e) {\n-            synchronized (this) {\n-                concurrentCheckpointException.handle(e);\n-            }\n-        }\n-        synchronized (this) {\n-            ExceptionHolder<CheckpointException> e = concurrentCheckpointException;\n-            concurrentCheckpointException = new ExceptionHolder<>(CheckpointException::new);\n-            e.throwIfAny();\n-        }\n-    }\n-\n-    @Override\n-    public void afterRestore(Context<? extends Resource> context) throws RestoreException {\n-        CheckpointException racedException;\n-        synchronized (this) {\n-            racedException = concurrentCheckpointException.getIfAny();\n-            concurrentCheckpointException = null;\n-        }\n-\n-        ExceptionHolder<RestoreException> restoreException = new ExceptionHolder<>(RestoreException::new);\n-        restoreException.handle(racedException);\n-\n-        restoreException.runWithHandler(() -> {\n-            super.afterRestore(context);\n-        });\n-\n-        restoreException.throwIfAny();\n-    }\n-\n-    @Override\n-    public void register(R resource) {\n-        synchronized (this) {\n-            resources.put(resource, null);\n-            if (concurrentCheckpointException != null) {\n-                try {\n-                    invokeBeforeCheckpoint(resource);\n-                } catch (Exception e) {\n-                    concurrentCheckpointException.handle(e);\n-                }\n-            }\n-        }\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/impl\/CriticalUnorderedContext.java","additions":0,"deletions":90,"binary":false,"changes":90,"status":"deleted"},{"patch":"@@ -31,1 +31,0 @@\n-import jdk.crac.impl.CriticalUnorderedContext;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/Core.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}