{"files":[{"patch":"@@ -28,3 +28,0 @@\n-import jdk.crac.Context;\n-import jdk.crac.Resource;\n-import jdk.internal.crac.JDKResource;\n@@ -251,2 +248,0 @@\n-    private static JDKResource referenceHandlerResource;\n-\n@@ -334,7 +329,0 @@\n-        });\n-\n-        referenceHandlerResource = new JDKResource() {\n-            @Override\n-            public Priority getPriority() {\n-                return Priority.REFERENCE_HANDLER;\n-            }\n@@ -343,8 +331,6 @@\n-            public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n-                System.gc();\n-                \/\/ TODO ensure GC done processing all References\n-                while (waitForReferenceProcessing());\n-            }\n-\n-            @Override\n-            public void afterRestore(Context<? extends Resource> context) throws Exception {\n+            public boolean waitForQueueProcessed(ReferenceQueue<?> queue,\n+                                                 int nThreads,\n+                                                 long timeout)\n+                throws InterruptedException\n+            {\n+                return queue.waitForQueueProcessed(nThreads, timeout);\n@@ -352,2 +338,1 @@\n-        };\n-        jdk.internal.crac.Core.getJDKContext().register(referenceHandlerResource);\n+        });\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/Reference.java","additions":7,"deletions":22,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -29,0 +29,3 @@\n+\n+import jdk.internal.access.JavaLangRefAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -59,1 +62,1 @@\n-    private int nWaiters = 0;\n+    private int nBlocked = 0;\n@@ -156,1 +159,1 @@\n-                ++nWaiters;\n+                ++nBlocked;\n@@ -159,1 +162,1 @@\n-                --nWaiters;\n+                --nBlocked;\n@@ -213,3 +216,1 @@\n-     * Blocks calling thread until the specified number of threads are blocked with no reference available.\n-     * @param nWaiters number of threads to wait\n-     * @throws InterruptedException If the wait is interrupted\n+     * See {@link jdk.crac.Misc#waitForQueueProcessed(ReferenceQueue, int, long)}.\n@@ -217,1 +218,35 @@\n-    public void waitForWaiters(int nWaiters) throws InterruptedException {\n+    boolean waitForQueueProcessed(int nThreads, long timeout)\n+        throws InterruptedException\n+    {\n+        JavaLangRefAccess refAccess = SharedSecrets.getJavaLangRefAccess();\n+        long start = (timeout > 0) ? System.nanoTime() : 0;\n+\n+        \/\/ Back-to-back calls of this function are not optimized\n+        \/\/ intentionally.  It's possible to check if the previous call\n+        \/\/ has queued no reference and conclude that there is no need\n+        \/\/ to call GC and wait for reference processing.  But with such\n+        \/\/ optimization we may lose references that were queued because\n+        \/\/ some other code, beside another reference queue processing,\n+        \/\/ caused a referent be unreachable.\n+\n+        System.gc();\n+        \/\/ TODO ensure GC done processing all References\n+\n+        \/\/ should wait for the completion, otherwise the queue may appear\n+        \/\/ empty, although a ref to be about to be enqueued.\n+        while (refAccess.waitForReferenceProcessing());\n+\n+        if (timeout > 0) {\n+            timeout -= (System.nanoTime() - start) \/ 1_000_000;\n+            if (timeout <= 0) {\n+                \/\/ give a chance to detect blocked threads\n+                timeout = -1;\n+            }\n+        }\n+\n+        if (timeout < 0) {\n+            synchronized (lock) {\n+                return head == null && nThreads <= nBlocked;\n+            }\n+        }\n+\n@@ -219,2 +254,9 @@\n-            while (head != null || this.nWaiters < nWaiters) {\n-                lock.wait();\n+            while (head != null || nBlocked < nThreads) {\n+                lock.wait(timeout);\n+                if (timeout != 0) {\n+                    long end = System.nanoTime();\n+                    timeout -= (end - start) \/ 1000_000;\n+                    if (timeout <= 0)\n+                        return false;\n+                    start = end;\n+                }\n@@ -223,0 +265,1 @@\n+        return true;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/ReferenceQueue.java","additions":52,"deletions":9,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -0,0 +1,41 @@\n+package jdk.crac;\n+\n+import jdk.internal.access.SharedSecrets;\n+\n+import java.lang.ref.ReferenceQueue;\n+\n+\/**\n+ * Additional utilities.\n+ *\/\n+public class Misc {\n+\n+    private Misc() {\n+    }\n+\n+    \/**\n+     * Blocks calling thread until there are no references in the queue and\n+     * the specified number of threads are blocked without a reference to\n+     * process.\n+     * <p>\n+     * Note that {@code timeout} specifies the timeout for threads to block,\n+     * while the total time of this function to complete may be much larger\n+     * that the specified timeout.\n+     *\n+     * @param queue the queue to wait\n+     * @param nThreads number of threads to wait\n+     * @param timeout milliseconds to wait for threads to block, if positive,\n+     *                wait indefinitely, if zero,\n+     *                and, otherwise, just check the condition\n+     * @throws InterruptedException If the wait is interrupted\n+     * @return true if condition was true during the timeout period,\n+     *         otherwise false\n+     *\/\n+    public static boolean waitForQueueProcessed(ReferenceQueue<?> queue,\n+                                                int nThreads,\n+                                                long timeout)\n+        throws InterruptedException\n+    {\n+        return SharedSecrets.getJavaLangRefAccess().\n+            waitForQueueProcessed(queue, nThreads, timeout);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/Misc.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -28,0 +28,2 @@\n+import java.lang.ref.ReferenceQueue;\n+\n@@ -46,0 +48,8 @@\n+\n+    \/**\n+     * See {@link jdk.crac.Misc#waitForQueueProcessed(ReferenceQueue, int, long)}.\n+     *\/\n+    boolean waitForQueueProcessed(ReferenceQueue<?> queue,\n+                                  int nThreads,\n+                                  long timeout)\n+        throws InterruptedException;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangRefAccess.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -76,5 +76,0 @@\n-        \/**\n-         * Priority of the\n-         * java.lan.ref.Reference static resource\n-         *\/\n-        REFERENCE_HANDLER,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/JDKResource.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -31,2 +31,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -161,2 +159,11 @@\n-    public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n-        queue.waitForWaiters(1);\n+    public void beforeCheckpoint(Context<? extends Resource> context)\n+        throws Exception\n+    {\n+        final long timeout = 1_000; \/\/ reasonable for ref.clean() to finish\n+        while (!phantomCleanableList.isListEmpty() &&\n+               !jdk.crac.Misc.waitForQueueProcessed(queue, 1, timeout)) {\n+            \/\/ This loop reflects the loop in the cleaner handler thread,\n+            \/\/ that allows a race between reference clearing from the list\n+            \/\/ and waiting for the queue. So we need to wait for the queue\n+            \/\/ to be processed with the timeout as well.\n+        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/ref\/CleanerImpl.java","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -26,0 +26,3 @@\n+import java.lang.ref.Reference;\n+import java.lang.ref.ReferenceQueue;\n+import java.lang.ref.WeakReference;\n@@ -36,0 +39,36 @@\n+    static class Tuple {\n+        private Object object = new Object();\n+        private ReferenceQueue<WeakReference> queue = new ReferenceQueue<>();\n+        private Reference ref = new WeakReference(object, queue);\n+        private Thread thread;\n+\n+        Tuple(Runnable r) {\n+            thread = new Thread(() -> {\n+                while (true) {\n+                    try {\n+                        queue.remove();\n+                        if (r != null) {\n+                            r.run();\n+                        }\n+                    } catch (InterruptedException e) {\n+                        e.printStackTrace();\n+                    }\n+                }\n+            });\n+            thread.setDaemon(true);\n+            thread.start();\n+        }\n+\n+        Object getObject() {\n+            return object;\n+        }\n+\n+        void clearObject() {\n+            object = null;\n+        }\n+\n+        void waitProcessed() throws InterruptedException {\n+            Misc.waitForQueueProcessed(queue, 1, 0);\n+        }\n+    }\n+\n@@ -43,2 +82,15 @@\n-        \/\/ the cleaner would be able to run right away\n-        cleaner.register(new Object(), () -> {\n+        Tuple[] tuples = new Tuple[10];\n+        for (int i = 0; i < tuples.length - 1; ++i) {\n+            int ii = i;\n+            tuples[i] = new Tuple(() -> {\n+                System.out.println(\"WOKE \" + ii);\n+                tuples[ii + 1].clearObject();\n+            });\n+        }\n+        tuples[tuples.length - 1] = new Tuple(() -> {\n+            System.out.println(\"WOKE \" + (tuples.length - 1));\n+        });\n+\n+        \/\/ the cleaner should run only after user reference processing complete\n+        cleaner.register(tuples[tuples.length - 1].getObject(), () -> {\n+            System.out.println(\"CLEANER\");\n@@ -52,0 +104,28 @@\n+        Resource testResource = new Resource() {\n+            @Override\n+            public void beforeCheckpoint(Context<? extends Resource> context)\n+                throws Exception\n+            {\n+                tuples[0].clearObject();\n+\n+                \/\/ should return quickly: no references yet. But the\n+                \/\/ call is valid.\n+                System.out.println(\"ATTEMPT 1\");\n+                tuples[tuples.length - 1].waitProcessed();\n+\n+                \/\/ Now make sure that all necessary processing has happened.\n+                \/\/ We do this in a way that is specific to this app.\n+                System.out.println(\"ATTEMPT \" + tuples.length);\n+                for (int i = 0; i < tuples.length; ++i) {\n+                    tuples[i].waitProcessed();\n+                }\n+                System.out.println(\"ATTEMPT done\");\n+            }\n+\n+            @Override\n+            public void afterRestore(Context<? extends Resource> context) throws Exception {\n+\n+            }\n+        };\n+        jdk.crac.Core.getGlobalContext().register(testResource);\n+\n","filename":"test\/jdk\/jdk\/crac\/RefQueueTest.java","additions":82,"deletions":2,"binary":false,"changes":84,"status":"modified"}]}