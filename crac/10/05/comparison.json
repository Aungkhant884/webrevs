{"files":[{"patch":"@@ -32,0 +32,1 @@\n+#include \"services\/linuxAttachOperation.hpp\"\n@@ -61,1 +62,1 @@\n-class LinuxAttachOperation;\n+\/\/class LinuxAttachOperation;\n@@ -78,0 +79,1 @@\n+  static AttachOperation* _currentOperation;\n@@ -111,16 +113,0 @@\n-class LinuxAttachOperation: public AttachOperation {\n- private:\n-  \/\/ the connection to the client\n-  int _socket;\n-\n- public:\n-  void complete(jint res, bufferedStream* st);\n-\n-  void set_socket(int s)                                { _socket = s; }\n-  int socket() const                                    { return _socket; }\n-\n-  LinuxAttachOperation(char* name) : AttachOperation(name) {\n-    set_socket(-1);\n-  }\n-};\n-\n@@ -132,0 +118,1 @@\n+AttachOperation* LinuxAttachListener::_currentOperation = NULL;\n@@ -400,0 +387,11 @@\n+\/\/ An operation completion is splitted into two parts.\n+\/\/ For proper handling the jcmd connection at CRaC checkpoint action.\n+\/\/ An effectively_complete is called in checkpoint processing, before criu engine calls, for properly closing the socket.\n+\/\/ The complete() gets called after restore for proper deletion the leftover object.\n+\n+void LinuxAttachOperation::complete(jint result, bufferedStream* st) {\n+  LinuxAttachOperation::effectively_complete(result, st);\n+  AttachListener::set_CurrentOperation(NULL);\n+  delete this;\n+}\n+\n@@ -408,1 +406,6 @@\n-void LinuxAttachOperation::complete(jint result, bufferedStream* st) {\n+void LinuxAttachOperation::effectively_complete(jint result, bufferedStream* st) {\n+\n+  if (_effectively_completed) {\n+    return;\n+  }\n+\n@@ -425,0 +428,1 @@\n+  _effectively_completed = true;\n@@ -426,1 +430,0 @@\n-  delete this;\n@@ -432,0 +435,10 @@\n+AttachOperation* AttachListener::get_CurrentOperation() {\n+  return Atomic::load(&LinuxAttachListener::_currentOperation);\n+}\n+\n+void AttachListener::set_CurrentOperation(AttachOperation* s) {\n+  const char assertion_listener_thread[] = \"Attach Listener\";\n+  assert(strcmp(assertion_listener_thread, Thread::current()->name()) == 0, \"should gets called from Attach Listener thread\");\n+  Atomic::store(&LinuxAttachListener::_currentOperation, s);\n+}\n+\n@@ -437,1 +450,1 @@\n-\n+  AttachListener::set_CurrentOperation(op);\n","filename":"src\/hotspot\/os\/linux\/attachListener_linux.cpp","additions":33,"deletions":20,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -74,0 +74,1 @@\n+#include \"services\/linuxAttachOperation.hpp\"\n@@ -411,0 +412,1 @@\n+  outputStream* ostream;\n@@ -5709,2 +5711,2 @@\n-static void trace_cr(const char* msg, ...) {\n-  if (CRTrace) {\n+static void trace_cr(outputStream * ostream, const char* msg, ... ) {\n+  if ((CRTrace) && (ostream != NULL)){\n@@ -5713,2 +5715,11 @@\n-    tty->print(\"CR: \");\n-    tty->vprint_cr(msg, ap);\n+    ostream->print(\"CR: \");\n+    ostream->vprint_cr(msg, ap);\n+    va_end(ap);\n+  }\n+}\n+\n+static void print_resources(outputStream * ostream, const char* msg, ... ) {\n+  if ((CRPrintResourcesOnCheckpoint) && (ostream != NULL)) {\n+    va_list ap;\n+    va_start(ap, msg);\n+    ostream->vprint_cr(msg, ap);\n@@ -5996,7 +6007,0 @@\n-  if (CRAllowToSkipCheckpoint) {\n-    trace_cr(\"Skip Checkpoint\");\n-    return JVM_CHECKPOINT_OK;\n-  }\n-\n-  trace_cr(\"Checkpoint ...\");\n-\n@@ -6024,1 +6028,1 @@\n-    tty->print_cr(\"JVM: invalid info for restore provided (may be failed checkpoint)\");\n+    tty->print_cr(\"JVM: invalid info for restore provided (may be failed checkpoint) si_code %d si_int %d\", info.si_code,  info.si_int);\n@@ -6167,0 +6171,1 @@\n+  LinuxAttachOperation * op = (LinuxAttachOperation* )AttachListener::get_CurrentOperation();\n@@ -6176,4 +6181,3 @@\n-    if (CRPrintResourcesOnCheckpoint) {\n-      tty->print(\"JVM: FD fd=%d type=%s: details1=\\\"%s\\\" \",\n-          i, stat2strtype(fds.get_stat(i)->st_mode), details);\n-    }\n+    print_resources(ostream, \"JVM: FD fd=%d type=%s: details1=\\\"%s\\\" \",\n+        i, stat2strtype(fds.get_stat(i)->st_mode), details);\n+\n@@ -6182,3 +6186,1 @@\n-      if (CRPrintResourcesOnCheckpoint) {\n-        tty->print_cr(\"OK: inherited from process env\");\n-      }\n+      print_resources(ostream, \"OK: inherited from process env\");\n@@ -6193,3 +6195,1 @@\n-        if (CRPrintResourcesOnCheckpoint) {\n-          tty->print_cr(\"OK: always available, random or urandom\");\n-        }\n+        print_resources(ostream, \"OK: always available, random or urandom\");\n@@ -6201,3 +6201,1 @@\n-      if (CRPrintResourcesOnCheckpoint) {\n-        tty->print_cr(\"OK: in classpath\");\n-      }\n+      print_resources(ostream, \"OK: in classpath\");\n@@ -6208,3 +6206,1 @@\n-      if (CRPrintResourcesOnCheckpoint) {\n-        tty->print_cr(\"OK: assured persistent\");\n-      }\n+      print_resources(ostream, \"OK: assured persistent\");\n@@ -6214,4 +6210,0 @@\n-    if (CRPrintResourcesOnCheckpoint) {\n-      tty->print(\"BAD: opened by application\");\n-    }\n-    ok = false;\n@@ -6221,2 +6213,8 @@\n-      if (CRPrintResourcesOnCheckpoint) {\n-        tty->print(\" details2=\\\"%s\\\" \", details);\n+      print_resources(ostream, \"issock, details2=\\\"%s\\\" \", details);\n+\n+      \/\/ and sock fd from listener\n+      int sock_fd = op->socket();\n+      if ( i == sock_fd){\n+        print_resources(ostream, \"OK: jcmd socket\");\n+        ok = true;\n+        continue;\n@@ -6226,3 +6224,3 @@\n-    if (CRPrintResourcesOnCheckpoint) {\n-      tty->cr();\n-    }\n+    print_resources(ostream, \"BAD: opened by application\");\n+    ok = false;\n+\n@@ -6234,0 +6232,6 @@\n+  if (!ok) {\n+    trace_cr(ostream, \"Checkpoint aborted: resources opened by application\");\n+    return;\n+  }\n+\n+\n@@ -6246,1 +6250,0 @@\n-\n@@ -6248,4 +6251,12 @@\n-  int ret = checkpoint_restore(&shmid);\n-  if (ret == JVM_CHECKPOINT_ERROR) {\n-    PerfMemoryLinux::restore();\n-    return;\n+  if (CRAllowToSkipCheckpoint) {\n+    trace_cr(ostream, \"Skip Checkpoint\");\n+  } else {\n+    trace_cr(ostream, \"Checkpoint ...\");\n+    bufferedStream * buf = static_cast<bufferedStream*>(ostream);\n+    \/\/ Send a result to jcmd\n+    op->effectively_complete(JNI_OK, buf);\n+    int ret = checkpoint_restore(&shmid);\n+    if (ret == JVM_CHECKPOINT_ERROR) {\n+      PerfMemoryLinux::restore();\n+      return;\n+    }\n@@ -6253,1 +6264,0 @@\n-\n@@ -6348,1 +6358,1 @@\n-Handle os::Linux::checkpoint(bool dry_run, TRAPS) {\n+Handle os::Linux::checkpoint(bool dry_run, jlong stream, TRAPS) {\n@@ -6364,0 +6374,1 @@\n+    cr.ostream = (outputStream*) stream;\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":55,"deletions":44,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -176,1 +176,1 @@\n-  static Handle checkpoint(bool dry_run, TRAPS);\n+  static Handle checkpoint(bool dry_run, jlong st, TRAPS);\n","filename":"src\/hotspot\/os\/linux\/os_linux.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -710,0 +710,1 @@\n+  template(checkpointRestereInternal_signature,    \"(J)Ljava\/lang\/String;\")                                       \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1146,1 +1146,1 @@\n-JVM_Checkpoint(JNIEnv *env, jboolean dry_run);\n+JVM_Checkpoint(JNIEnv *env, jboolean dry_run, jlong stream);\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3852,2 +3852,2 @@\n-JVM_ENTRY(jobjectArray, JVM_Checkpoint(JNIEnv *env, jboolean dry_run))\n-  Handle ret = os::Linux::checkpoint(dry_run, CHECK_NULL);\n+JVM_ENTRY(jobjectArray, JVM_Checkpoint(JNIEnv *env, jboolean dry_run, jlong stream))\n+  Handle ret = os::Linux::checkpoint(dry_run, stream, CHECK_NULL);\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -108,0 +108,6 @@\n+\n+  \/\/ save jcmd operation for proper Checkpoint\n+  static AttachOperation* get_CurrentOperation();\n+  static void set_CurrentOperation(AttachOperation* op);\n+\n+\n@@ -191,0 +197,1 @@\n+\n","filename":"src\/hotspot\/share\/services\/attachListener.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1043,1 +1043,4 @@\n-  JavaValue result(T_VOID);\n+  JavaValue result(T_OBJECT);\n+  output()->print_cr(\"JDK.checkpoint command start processing\");\n+  JavaCallArguments args;\n+  args.push_long((jlong )output());\n@@ -1046,1 +1049,11 @@\n-                         vmSymbols::void_method_signature(), CHECK);\n+                         vmSymbols::checkpointRestereInternal_signature(), &args, CHECK);\n+  jvalue* jv = (jvalue*) result.get_value_addr();\n+  oop str = cast_to_oop(jv->l);\n+  if (str != NULL) {\n+      char* out = java_lang_String::as_utf8_string(str);\n+      if (out) {\n+          output()->print_cr(\"An exception durinng checkpoint operation: \");\n+          output()->print_cr(\"%s\", out);\n+      }\n+  }\n+  output()->print_cr(\"JDK.checkpoint command processing finished\");\n@@ -1048,1 +1061,0 @@\n-\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":15,"deletions":3,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -0,0 +1,18 @@\n+class LinuxAttachOperation: public AttachOperation {\n+ private:\n+  \/\/ the connection to the client\n+  int _socket;\n+  bool _effectively_completed;\n+\n+ public:\n+  void complete(jint res, bufferedStream* st);\n+  void effectively_complete(jint res, bufferedStream* st);\n+\n+  void set_socket(int s)                                { _socket = s; }\n+  int socket() const                                    { return _socket; }\n+\n+  LinuxAttachOperation(char* name) : AttachOperation(name) {\n+    set_socket(-1);\n+    _effectively_completed = false;\n+  }\n+};\n","filename":"src\/hotspot\/share\/services\/linuxAttachOperation.hpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"added"},{"patch":"@@ -33,0 +33,2 @@\n+import java.io.StringWriter;\n+import java.io.PrintWriter;\n@@ -56,2 +58,1 @@\n-    private static native Object[] checkpointRestore0(boolean dryRun);\n-\n+    private static native Object[] checkpointRestore0(boolean dryRun, long stream);\n@@ -111,1 +112,1 @@\n-    private static void checkpointRestore1() throws\n+    private static void checkpointRestore1(long... outputStream_p) throws\n@@ -125,1 +126,1 @@\n-        final Object[] bundle = checkpointRestore0(checkpointException != null);\n+        final Object[] bundle = checkpointRestore0(checkpointException != null, outputStream_p[0]);\n@@ -225,1 +226,1 @@\n-    public static void checkpointRestore() throws\n+    public static void checkpointRestore(long ...outputStream_p) throws\n@@ -237,1 +238,1 @@\n-                    checkpointRestore1();\n+                    checkpointRestore1(outputStream_p);\n@@ -251,13 +252,8 @@\n-    private static void checkpointRestoreInternal() {\n-        Thread thread = new Thread(() -> {\n-            try {\n-                Thread.sleep(100);\n-            } catch (InterruptedException e) {\n-            }\n-\n-            try {\n-                checkpointRestore();\n-            } catch (CheckpointException | RestoreException e) {\n-                for (Throwable t : e.getSuppressed()) {\n-                    t.printStackTrace();\n-                }\n+    private static String checkpointRestoreInternal(long outputStream_p){\n+        StringWriter sw = new StringWriter();\n+        PrintWriter pw = new PrintWriter(sw);\n+        try {\n+            checkpointRestore(outputStream_p);\n+        } catch (CheckpointException | RestoreException e) {\n+            for (Throwable t : e.getSuppressed()) {\n+                t.printStackTrace(pw);\n@@ -265,3 +261,2 @@\n-        });\n-        thread.setDaemon(true);\n-        thread.start();\n+        }\n+        return sw.toString();\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/Core.java","additions":17,"deletions":22,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-Java_jdk_crac_Core_checkpointRestore0(JNIEnv *env, jclass ignore, jboolean dry_run)\n+Java_jdk_crac_Core_checkpointRestore0(JNIEnv *env, jclass ignore, jboolean dry_run, jlong stream)\n@@ -41,1 +41,1 @@\n-    return JVM_Checkpoint(env, dry_run);\n+    return JVM_Checkpoint(env, dry_run, stream);\n","filename":"src\/java.base\/share\/native\/libjava\/CracCore.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}