{"files":[{"patch":"@@ -115,0 +115,1 @@\n+  bool _effectively_completed;\n@@ -118,0 +119,1 @@\n+  void effectivley_complete(jint res, bufferedStream* st);\n@@ -400,0 +402,10 @@\n+\/\/ An operation completeon is splitted on two parts.\n+\/\/ For proper handling the jcmd connection at CRaC checkpoint action.\n+\/\/ An effectively_complete is called in checkpoint processing, before criu engine calls, for properly closing the socket.\n+\/\/ The complete() gets called after restore for proper deletion the leftover object.\n+\n+void LinuxAttachOperation::complete(jint result, bufferedStream* st) {\n+  LinuxAttachOperation::effectivley_complete(result, st);\n+  delete this;\n+}\n+\n@@ -408,1 +420,6 @@\n-void LinuxAttachOperation::complete(jint result, bufferedStream* st) {\n+void LinuxAttachOperation::effectivley_complete(jint result, bufferedStream* st) {\n+  \n+  if (_effectively_completed) {\n+    return;\n+  }\n+\n@@ -425,0 +442,1 @@\n+  _effectively_completed = true;\n@@ -426,1 +444,0 @@\n-  delete this;\n","filename":"src\/hotspot\/os\/linux\/attachListener_linux.cpp","additions":19,"deletions":2,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -120,0 +120,2 @@\n+#include <typeinfo>\n+#include <sys\/socket.h>\n@@ -298,0 +300,1 @@\n+  outputStream* ostream;\n@@ -5594,1 +5597,1 @@\n-static void trace_cr(const char* msg, ...) {\n+static void trace_cr(outputStream * ostream, const char* msg, ... ) {\n@@ -5598,2 +5601,2 @@\n-    tty->print(\"CR: \");\n-    tty->vprint_cr(msg, ap);\n+    ostream->print(\"CR: \");\n+    ostream->vprint_cr(msg, ap);\n@@ -5838,7 +5841,0 @@\n-  if (CRAllowToSkipCheckpoint) {\n-    trace_cr(\"Skip Checkpoint\");\n-    return JVM_CHECKPOINT_OK;\n-  }\n-\n-  trace_cr(\"Checkpoint ...\");\n-\n@@ -5866,1 +5862,1 @@\n-    tty->print_cr(\"JVM: invalid info for restore provided (may be failed checkpoint)\");\n+    tty->print_cr(\"JVM: invalid info for restore provided (may be failed checkpoint) si_code %d si_int %d\", info.si_code,  info.si_int);\n@@ -5972,0 +5968,139 @@\n+#define PATH_PROC     \"\/proc\"\n+#define PATH_NET_UNIX_SUFF  \"net\/unix\"\n+#define PATH_PROC_X_NET_UNIX PATH_PROC \"\/%s\/\" PATH_NET_UNIX_SUFF\n+#define PATH_CMDLINE  \"cmdline\"\n+#define PATH_CMDLINEl       strlen(PATH_CMDLINE)\n+\n+#define PRG_INODE   \"inode\"\n+#define PRG_SOCKET_PFX    \"socket:[\"\n+#define PRG_SOCKET_PFXl (strlen(PRG_SOCKET_PFX))\n+#define PRG_SOCKET_PFX2   \"[0000]:\"\n+#define PRG_SOCKET_PFX2l  (strlen(PRG_SOCKET_PFX2))\n+\n+static int is_process_jcmd(char * fd) {\n+  char link[128];\n+  char str1[] = \"\/jcmd\";\n+  char * p;\n+  char fdpath[64];\n+  size_t len = sizeof(link);\n+  int d = atoi(fd);\n+  snprintf(fdpath, sizeof(fdpath), \"\/proc\/%d\/exe\", d);\n+  int ret = readlink(fdpath, link, len);\n+  if (ret == -1) {\n+    return 0;\n+  }\n+  link[(unsigned)ret < len ? ret : len - 1] = '\\0';\n+  p = strrchr(link, '\/');\n+  if (!strcmp(str1, p))\n+    return 1;\n+  else\n+    return 0;\n+}\n+\n+static int extract_type_1_socket_inode(const char lname[], unsigned long * inode_p) {\n+\n+    \/* If lname is of the form \"socket:[12345]\", extract the \"12345\"\n+       as *inode_p.  Otherwise, return -1 as *inode_p.\n+       *\/\n+\n+    if (strlen(lname) < PRG_SOCKET_PFXl+3) return(-1);\n+\n+    if (memcmp(lname, PRG_SOCKET_PFX, PRG_SOCKET_PFXl)) return(-1);\n+    if (lname[strlen(lname)-1] != ']') return(-1);\n+\n+    {\n+        char inode_str[strlen(lname + 1)];  \/* e.g. \"12345\" *\/\n+        const int inode_str_len = strlen(lname) - PRG_SOCKET_PFXl - 1;\n+        char *serr;\n+\n+        strncpy(inode_str, lname+PRG_SOCKET_PFXl, inode_str_len);\n+        inode_str[inode_str_len] = '\\0';\n+        *inode_p = strtol(inode_str,&serr,0);\n+        if (!serr || *serr )\n+            return(-1);\n+    }\n+    return(0);\n+}\n+\n+static int extract_type_2_socket_inode(const char lname[], unsigned long * inode_p) {\n+\n+    \/* If lname is of the form \"[0000]:12345\", extract the \"12345\"\n+       as *inode_p.  Otherwise, return -1 as *inode_p.\n+       *\/\n+\n+    if (strlen(lname) < PRG_SOCKET_PFX2l+1) return(-1);\n+    if (memcmp(lname, PRG_SOCKET_PFX2, PRG_SOCKET_PFX2l)) return(-1);\n+\n+    {\n+        char *serr;\n+        *inode_p=strtol(lname + PRG_SOCKET_PFX2l,&serr,0);\n+        if (!serr || *serr )\n+            return(-1);\n+    }\n+    return(0);\n+}\n+\n+static int is_socket_from_jcmd(unsigned long parm_inode){\n+\n+  char line[4096];\n+  char *token_word;\n+  char *eptr;\n+  ssize_t rread;\n+  int procfdlen;\n+  size_t len = 0;\n+  unsigned long inode;\n+  const char *cs;\n+  char *pline;\n+  FILE * fp;\n+  DIR *dirproc=NULL;\n+  struct dirent *direproc;\n+  int rc;\n+  if (!(dirproc=opendir(PATH_PROC)))\n+    return 1;\n+\n+  while (errno=0,direproc=readdir(dirproc)) {\n+    for (cs=direproc->d_name;*cs;cs++)\n+      if (!isdigit(*cs))\n+        break;\n+    if (*cs)\n+      continue;\n+\n+    if (!is_process_jcmd(direproc->d_name))\n+      continue;\n+\n+    \/\/ this is preparing the filelist, dont need for regular proc\n+    procfdlen=snprintf(line, sizeof(line), PATH_PROC_X_NET_UNIX, direproc->d_name);\n+    if (procfdlen<=0 || procfdlen>=(int)sizeof(line)-5)\n+      continue;\n+    errno=0;\n+\n+    fp = fopen(line, \"r\");\n+    if (fp == NULL){\n+      tty->print(\"is_socket_from_jcmd read errno: %d %s \\n\", errno, os::strerror(errno));\n+      closedir(dirproc);\n+      fclose(fp);\n+      return 0;\n+    }\n+\n+    while ((rread = getline(&pline, &len, fp)) != -1) {\n+      int count =0;\n+      token_word = strtok(pline, \" \");\n+      while(token_word != NULL){\n+        if (count == 6){\n+          inode = atoi(token_word);\n+          if (inode == parm_inode){\n+            closedir(dirproc);\n+            fclose(fp);\n+            return 1;\n+          }\n+        }\n+        token_word = strtok(NULL,\" \");\n+        count++;\n+      }\n+    }\n+  }\n+  closedir(dirproc);\n+  fclose(fp);\n+  return 0;\n+}\n+\n@@ -5977,0 +6112,1 @@\n+  int unixsockdf;\n@@ -5992,1 +6128,1 @@\n-      tty->print(\"JVM: FD fd=%d type=%s: details1=\\\"%s\\\" \",\n+      ostream->print(\"JVM: FD fd=%d type=%s: details1=\\\"%s\\\" \",\n@@ -5998,1 +6134,1 @@\n-        tty->print_cr(\"OK: inherited from process env\");\n+        ostream->print_cr(\"OK: inherited from process env\");\n@@ -6009,1 +6145,1 @@\n-          tty->print_cr(\"OK: always available, random or urandom\");\n+          ostream->print_cr(\"OK: always available, random or urandom\");\n@@ -6017,1 +6153,1 @@\n-        tty->print_cr(\"OK: in classpath\");\n+        ostream->print_cr(\"OK: in classpath\");\n@@ -6024,1 +6160,1 @@\n-        tty->print_cr(\"OK: assured persistent\");\n+        ostream->print_cr(\"OK: assured persistent\");\n@@ -6029,4 +6165,0 @@\n-    if (CRPrintResourcesOnCheckpoint) {\n-      tty->print(\"BAD: opened by application\");\n-    }\n-    ok = false;\n@@ -6036,2 +6168,35 @@\n-      if (CRPrintResourcesOnCheckpoint) {\n-        tty->print(\" details2=\\\"%s\\\" \", details);\n+      if (CRPrintResourcesOnCheckpoint)\n+        ostream->print(\"issock, details2=\\\"%s\\\" \", details);\n+\n+      typedef union {\n+          struct sockaddr     sa;\n+          struct sockaddr_in  sa4;\n+          struct sockaddr_in6 sa6;\n+      } SOCKETADDRESS;\n+\n+      SOCKETADDRESS sa;\n+      socklen_t len = sizeof(SOCKETADDRESS);\n+      int sock_family;\n+      if (getsockname(i, &sa.sa, &len) == 0) {\n+        sock_family = sa.sa.sa_family;\n+      } else {\n+        if (CRPrintResourcesOnCheckpoint)\n+          ostream->print(\"getsockname  errno: %d %s \\n\", errno, os::strerror(errno));\n+      }\n+\n+      \/\/ socket should be 'unix' type, it's mean this is pipe\n+      if (sock_family != AF_UNIX)\n+        ok = false;\n+\n+      unsigned long inod;\n+      if (extract_type_1_socket_inode(details, &inod) < 0){\n+        if (extract_type_2_socket_inode(details, &inod) < 0)\n+          ok = false;\n+      }\n+\n+      if (ok){\n+        if (is_socket_from_jcmd(inod)){\n+          ostream->print_cr(\"OK: jcmd socket\");\n+          unixsockdf = i;\n+          continue;\n+        }\n@@ -6042,1 +6207,1 @@\n-      tty->cr();\n+      ostream->print_cr(\"BAD: opened by application\");\n@@ -6044,0 +6209,2 @@\n+      ok = false;\n+\n@@ -6049,0 +6216,6 @@\n+  if (!ok){\n+    trace_cr(ostream, \"Checkpoint aborted: resources opened by application\");\n+    return;\n+  }\n+\n+\n@@ -6061,4 +6234,13 @@\n-  int ret = checkpoint_restore(&fds);\n-  if (ret == JVM_CHECKPOINT_ERROR) {\n-    PerfMemoryLinux::checkpoint_fail();\n-    return;\n+  if (CRAllowToSkipCheckpoint) {\n+    trace_cr(ostream, \"Skip Checkpoint\");\n+  } else {\n+    trace_cr(ostream, \"Checkpoint ...\");\n+    bufferedStream * buf = static_cast<bufferedStream*>(ostream);\n+    AttachOperation * op = AttachListener::get_CurrentOperation();\n+    \/\/ Send a result to jcmd\n+    op->effectivley_complete(JNI_OK, buf);\n+    int ret = checkpoint_restore(&fds);\n+    if (ret == JVM_CHECKPOINT_ERROR) {\n+      PerfMemoryLinux::checkpoint_fail();\n+      return;\n+    }\n@@ -6162,1 +6344,1 @@\n-Handle os::Linux::checkpoint(TRAPS) {\n+Handle os::Linux::checkpoint(TRAPS, jlong stream) {\n@@ -6178,0 +6360,1 @@\n+    cr.ostream = (outputStream*) stream;\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":211,"deletions":28,"binary":false,"changes":239,"status":"modified"},{"patch":"@@ -176,1 +176,1 @@\n-  static Handle checkpoint(TRAPS);\n+  static Handle checkpoint(TRAPS, jlong st);\n","filename":"src\/hotspot\/os\/linux\/os_linux.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -710,0 +710,1 @@\n+  template(checkpointRestereInternal_signature,    \"(J)Ljava\/lang\/String;\")                                       \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1146,1 +1146,1 @@\n-JVM_Checkpoint(JNIEnv *env);\n+JVM_Checkpoint(JNIEnv *env, jlong stream);\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3852,2 +3852,2 @@\n-JVM_ENTRY(jobjectArray, JVM_Checkpoint(JNIEnv *env))\n-  Handle ret = os::Linux::checkpoint(CHECK_NULL);\n+JVM_ENTRY(jobjectArray, JVM_Checkpoint(JNIEnv *env, jlong stream))\n+  Handle ret = os::Linux::checkpoint(THREAD, stream);\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-\n+AttachOperation* AttachListener::_currentOperation = NULL;\n@@ -408,0 +408,1 @@\n+      AttachListener::set_CurrentOperation(op);\n","filename":"src\/hotspot\/share\/services\/attachListener.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -83,0 +83,1 @@\n+\n@@ -85,0 +86,1 @@\n+  static AttachOperation* _currentOperation;\n@@ -95,0 +97,7 @@\n+  static AttachOperation* get_CurrentOperation() {\n+    return Atomic::load(&AttachListener::_currentOperation);\n+  }\n+  static void set_CurrentOperation(AttachOperation* s) {\n+    Atomic::store(&AttachListener::_currentOperation, s); \n+  }\n+\n@@ -191,0 +200,2 @@\n+  virtual void effectivley_complete(jint result, bufferedStream* result_stream) = 0;\n+\n","filename":"src\/hotspot\/share\/services\/attachListener.hpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1043,1 +1043,4 @@\n-  JavaValue result(T_VOID);\n+  JavaValue result(T_OBJECT);\n+  output()->print_cr(\"JDK.checkpoint command start processing\");\n+  JavaCallArguments args;\n+  args.push_long((jlong )output());\n@@ -1046,3 +1049,12 @@\n-                         vmSymbols::void_method_signature(), CHECK);\n-}\n-\n+                         vmSymbols::checkpointRestereInternal_signature(), &args, CHECK);\n+  jvalue* jv = (jvalue*) result.get_value_addr();\n+  oop str = cast_to_oop(jv->l);\n+  if (str != NULL) {\n+      char* out = java_lang_String::as_utf8_string(str);\n+      if (out) {\n+          output()->print_cr(\"An exception durinng checkpoint operation: \");\n+          output()->print_cr(\"%s\", out);\n+      }\n+  }\n+  output()->print_cr(\"JDK.checkpoint command processing finished\");\n+}\n\\ No newline at end of file\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":16,"deletions":4,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+import java.io.StringWriter;\n+import java.io.PrintWriter;\n@@ -49,1 +51,2 @@\n-    private static native Object[] checkpointRestore0();\n+    private static native Object[] checkpointRestore0(long stream);\n+    private static long outputStream_p;\n@@ -128,2 +131,1 @@\n-\n-        final Object[] bundle = checkpointRestore0();\n+        final Object[] bundle = checkpointRestore0(outputStream_p);\n@@ -191,13 +193,9 @@\n-    private static void checkpointRestoreInternal() {\n-        Thread thread = new Thread(() -> {\n-            try {\n-                Thread.sleep(100);\n-            } catch (InterruptedException e) {\n-            }\n-\n-            try {\n-                checkpointRestore();\n-            } catch (CheckpointException | RestoreException e) {\n-                for (Throwable t : e.getSuppressed()) {\n-                    t.printStackTrace();\n-                }\n+    private static String checkpointRestoreInternal(long st){\n+        outputStream_p = st;\n+        StringWriter sw = new StringWriter();\n+        PrintWriter pw = new PrintWriter(sw);\n+        try {\n+            checkpointRestore();\n+        } catch (CheckpointException | RestoreException e) {\n+            for (Throwable t : e.getSuppressed()) {\n+                t.printStackTrace(pw);\n@@ -205,3 +203,2 @@\n-        });\n-        thread.setDaemon(true);\n-        thread.start();\n+        }\n+        return sw.toString();\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/Core.java","additions":16,"deletions":19,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-Java_jdk_crac_Core_checkpointRestore0(JNIEnv *env, jclass ignore)\n+Java_jdk_crac_Core_checkpointRestore0(JNIEnv *env, jclass ignore, jlong stream)\n@@ -40,1 +40,1 @@\n-    return JVM_Checkpoint(env);\n+    return JVM_Checkpoint(env, stream);\n","filename":"src\/java.base\/share\/native\/libjava\/CracCore.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}