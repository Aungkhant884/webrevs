{"files":[{"patch":"@@ -31,0 +31,1 @@\n+#include \"attachListener_linux.hpp\"\n@@ -32,1 +33,1 @@\n-#include \"services\/linuxAttachOperation.hpp\"\n+#include \"linuxAttachOperation.hpp\"\n@@ -41,3 +42,1 @@\n-#ifndef UNIX_PATH_MAX\n-#define UNIX_PATH_MAX   sizeof(((struct sockaddr_un *)0)->sun_path)\n-#endif\n+\n@@ -62,42 +61,0 @@\n-class LinuxAttachListener: AllStatic {\n- private:\n-  \/\/ the path to which we bind the UNIX domain socket\n-  static char _path[UNIX_PATH_MAX];\n-  static bool _has_path;\n-\n-  \/\/ the file descriptor for the listening socket\n-  static volatile int _listener;\n-\n-  static bool _atexit_registered;\n-\n-  \/\/ reads a request from the given connected socket\n-  static LinuxAttachOperation* read_request(int s);\n-\n- public:\n-  static AttachOperation* _jcmdOperation;\n-  enum {\n-    ATTACH_PROTOCOL_VER = 1                     \/\/ protocol version\n-  };\n-  enum {\n-    ATTACH_ERROR_BADVERSION     = 101           \/\/ error codes\n-  };\n-\n-  static void set_path(char* path) {\n-    if (path == NULL) {\n-      _path[0] = '\\0';\n-      _has_path = false;\n-    } else {\n-      strncpy(_path, path, UNIX_PATH_MAX);\n-      _path[UNIX_PATH_MAX-1] = '\\0';\n-      _has_path = true;\n-    }\n-  }\n-\n-  static void set_listener(int s)               { _listener = s; }\n-\n-  \/\/ initialize the listener, returns 0 if okay\n-  static int init();\n-\n-  static char* path()                   { return _path; }\n-  static bool has_path()                { return _has_path; }\n-  static int listener()                 { return _listener; }\n@@ -105,5 +62,0 @@\n-  \/\/ write the given buffer to a socket\n-  static int write_fully(int s, char* buf, int len);\n-\n-  static LinuxAttachOperation* dequeue();\n-};\n@@ -392,1 +344,1 @@\n-  AttachListener::set_jcmdOperation(NULL);\n+  LinuxAttachListener::set_jcmdOperation(NULL);\n@@ -430,4 +382,1 @@\n-\n-\/\/ AttachListener functions\n-\n-AttachOperation* AttachListener::get_jcmdOperation() {\n+AttachOperation* LinuxAttachListener::get_jcmdOperation() {\n@@ -439,1 +388,1 @@\n-void AttachListener::set_jcmdOperation(AttachOperation* s) {\n+void LinuxAttachListener::set_jcmdOperation(AttachOperation* s) {\n@@ -445,0 +394,2 @@\n+\/\/ AttachListener functions\n+\n@@ -450,1 +401,1 @@\n-  AttachListener::set_jcmdOperation(op);\n+  LinuxAttachListener::set_jcmdOperation(op);\n","filename":"src\/hotspot\/os\/linux\/attachListener_linux.cpp","additions":9,"deletions":58,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_SERVICES_ATTACHLISTENERLINUX_HPP\n+#define SHARE_SERVICES_ATTACHLISTENERLINUX_HPP\n+\n+#include \"linuxAttachOperation.hpp\"\n+#include \"services\/attachListener.hpp\"\n+\n+#include <sys\/un.h>\n+\n+#ifndef UNIX_PATH_MAX\n+#define UNIX_PATH_MAX   sizeof(((struct sockaddr_un *)0)->sun_path)\n+#endif\n+\n+class LinuxAttachListener: AllStatic {\n+ private:\n+  \/\/ the path to which we bind the UNIX domain socket\n+  static char _path[UNIX_PATH_MAX];\n+  static bool _has_path;\n+\n+  \/\/ the file descriptor for the listening socket\n+  static volatile int _listener;\n+\n+  static bool _atexit_registered;\n+\n+  static AttachOperation* _jcmdOperation;\n+\n+  \/\/ reads a request from the given connected socket\n+  static LinuxAttachOperation* read_request(int s);\n+\n+ public:\n+  \n+  enum {\n+    ATTACH_PROTOCOL_VER = 1                     \/\/ protocol version\n+  };\n+  enum {\n+    ATTACH_ERROR_BADVERSION     = 101           \/\/ error codes\n+  };\n+\n+  static void set_path(char* path) {\n+    if (path == NULL) {\n+      _path[0] = '\\0';\n+      _has_path = false;\n+    } else {\n+      strncpy(_path, path, UNIX_PATH_MAX);\n+      _path[UNIX_PATH_MAX-1] = '\\0';\n+      _has_path = true;\n+    }\n+  }\n+\n+  static void set_listener(int s)               { _listener = s; }\n+\n+  \/\/ initialize the listener, returns 0 if okay\n+  static int init();\n+\n+  static char* path()                   { return _path; }\n+  static bool has_path()                { return _has_path; }\n+  static int listener()                 { return _listener; }\n+\n+  \/\/ write the given buffer to a socket\n+  static int write_fully(int s, char* buf, int len);\n+\n+  static LinuxAttachOperation* dequeue();\n+  static void set_jcmdOperation(AttachOperation* s);\n+  static AttachOperation* get_jcmdOperation();\n+};\n+\n+#endif \/\/ SHARE_SERVICES_ATTACHLISTENERLINUX_HPP\n\\ No newline at end of file\n","filename":"src\/hotspot\/os\/linux\/attachListener_linux.hpp","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"services\/attachListener.hpp\"\n","filename":"src\/hotspot\/os\/linux\/linuxAttachOperation.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"previous_filename":"src\/hotspot\/share\/services\/linuxAttachOperation.hpp","status":"renamed"},{"patch":"@@ -74,1 +74,1 @@\n-#include \"services\/linuxAttachOperation.hpp\"\n+#include \"linuxAttachOperation.hpp\"\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -109,3 +109,0 @@\n-  \/\/ save jcmd operation, and use it further on checkpoint reporting\n-  static AttachOperation* get_jcmdOperation();\n-  static void set_jcmdOperation(AttachOperation* op);\n","filename":"src\/hotspot\/share\/services\/attachListener.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-#include \"services\/attachListener.hpp\"\n+#include \"attachListener_linux.hpp\"\n@@ -1047,1 +1047,1 @@\n-  args.push_long((jlong )AttachListener::get_jcmdOperation());\n+  args.push_long((jlong )LinuxAttachListener::get_jcmdOperation());\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}