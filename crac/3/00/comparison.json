{"files":[{"patch":"@@ -93,4 +93,4 @@\n-  $(eval $(call SetupJdkExecutable, BUILD_RESTORE_SCRIPT, \\\n-      NAME := action-script, \\\n-      SRC := $(TOPDIR)\/src\/$(MODULE)\/unix\/native\/action-script, \\\n-      INCLUDE_FILES := action-script.c, \\\n+  $(eval $(call SetupJdkExecutable, BUILD_CRIUENGINE, \\\n+      NAME := criuengine, \\\n+      SRC := $(TOPDIR)\/src\/$(MODULE)\/unix\/native\/criuengine, \\\n+      INCLUDE_FILES := criuengine.c, \\\n@@ -102,1 +102,1 @@\n-  TARGETS += $(BUILD_RESTORE_SCRIPT)\n+  TARGETS += $(BUILD_CRIUENGINE)\n@@ -104,4 +104,4 @@\n-  $(eval $(call SetupJdkExecutable, BUILD_WAIT, \\\n-      NAME := wait, \\\n-      SRC := $(TOPDIR)\/src\/$(MODULE)\/unix\/native\/wait, \\\n-      INCLUDE_FILES := wait.c, \\\n+  $(eval $(call SetupJdkExecutable, BUILD_PAUSEENGINE, \\\n+      NAME := pauseengine, \\\n+      SRC := $(TOPDIR)\/src\/$(MODULE)\/unix\/native\/pauseengine, \\\n+      INCLUDE_FILES := pauseengine.c, \\\n@@ -113,1 +113,1 @@\n-  TARGETS += $(BUILD_WAIT)\n+  TARGETS += $(BUILD_PAUSEENGINE)\n@@ -115,4 +115,4 @@\n-  $(eval $(call SetupJdkExecutable, BUILD_CRIU_WRAPPER, \\\n-      NAME := criu, \\\n-      SRC := $(TOPDIR)\/src\/$(MODULE)\/unix\/native\/criu, \\\n-      INCLUDE_FILES := criu.c, \\\n+  $(eval $(call SetupJdkExecutable, BUILD_SIMENGINE, \\\n+      NAME := simengine, \\\n+      SRC := $(TOPDIR)\/src\/$(MODULE)\/unix\/native\/simengine, \\\n+      INCLUDE_FILES := simengine.c, \\\n@@ -124,1 +124,1 @@\n-  TARGETS += $(BUILD_CRIU_WRAPPER)\n+  TARGETS += $(BUILD_SIMENGINE)\n@@ -126,10 +126,0 @@\n-  $(eval $(call SetupJdkExecutable, BUILD_JAVA_TIME, \\\n-      NAME := javatime, \\\n-      SRC := $(TOPDIR)\/src\/$(MODULE)\/unix\/native\/javatime, \\\n-      INCLUDE_FILES := javatime.c, \\\n-      OPTIMIZATION := LOW, \\\n-      CFLAGS := $(CFLAGS_JDKEXE), \\\n-      LDFLAGS := $(LDFLAGS_JDKEXE), \\\n-      OUTPUT_DIR := $(SUPPORT_OUTPUTDIR)\/modules_libs\/$(MODULE), \\\n-  ))\n-  TARGETS += $(BUILD_JAVA_TIME)\n","filename":"make\/modules\/java.base\/Launcher.gmk","additions":15,"deletions":25,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -327,1 +327,1 @@\n-static const char* _criu = NULL;\n+static const char* _crengine = NULL;\n@@ -5790,1 +5790,1 @@\n-static void cr_util_path(char* path, int len) {\n+static int cr_util_path(char* path, int len) {\n@@ -5793,0 +5793,1 @@\n+  char *after_elem;\n@@ -5794,1 +5795,1 @@\n-    char *after_elem = strrchr(path, '\/');\n+    after_elem = strrchr(path, '\/');\n@@ -5797,0 +5798,1 @@\n+  return after_elem - path;\n@@ -5799,3 +5801,3 @@\n-static const char* compute_criu(const char *util_path) {\n-  if (_criu) {\n-    return _criu;\n+static bool compute_crengine() {\n+  if (!CREngine) {\n+    return true;\n@@ -5804,16 +5806,3 @@\n-#define SUF \"criu\"\n-  const size_t criulen = strlen(util_path) + 1 + sizeof(SUF);\n-  char *criu = NEW_C_HEAP_ARRAY(char, criulen, mtInternal);\n-  assert(criu != NULL, \"JVM should fail\");\n-  int r = jio_snprintf(criu, criulen, \"%s\/\" SUF, util_path);\n-#undef SUF\n-  assert(r < (int)criulen, \"len miscalc\");\n-\n-  struct stat dummy;\n-  if (0 == stat(criu, &dummy)) {\n-    _criu = criu;\n-  } else {\n-    FREE_C_HEAP_ARRAY(char, criu);\n-    warning(\"Could not find %s: %s\", criu, strerror(errno));\n-    \/\/ use system one\n-    _criu = \"criu\";\n+  if (CREngine[0] == '\/') {\n+    _crengine = CREngine;\n+    return true;\n@@ -5821,6 +5810,0 @@\n-  return _criu;\n-}\n-\n-static int call_criu() {\n-  char util_path[JVM_MAXPATHLEN];\n-  cr_util_path(util_path, sizeof(util_path));\n@@ -5828,1 +5811,4 @@\n-  const char* criu = compute_criu(util_path);\n+  char path[JVM_MAXPATHLEN];\n+  int pathlen = cr_util_path(path, sizeof(path));\n+  strcat(path + pathlen, \"\/\");\n+  strcat(path + pathlen, CREngine);\n@@ -5830,19 +5816,4 @@\n-  pid_t jvm = getpid();\n-\n-  char cmd[3 * JVM_MAXPATHLEN];\n-  if ((int)sizeof(cmd) <= snprintf(cmd, sizeof(cmd),\n-        \"%s dump\"\n-        \" -t %d\"\n-        \" -D %s\"\n-        \" --action-script %s\/action-script\"\n-        \" --shell-job\"\n-        \" -v4 -o dump4.log\", \/\/ -D without -W makes criu cd to image dir for logs\n-        criu, jvm, CRaCCheckpointTo, util_path)) {\n-    trace_cr(\"can't fit CRIU cmd\");\n-    return -1;\n-  }\n-\n-  if (fork()) {\n-    \/\/ main JVM\n-    ::wait(NULL);\n-    return 0;\n+  struct stat st;\n+  if (0 != stat(path, &st)) {\n+    warning(\"Could not find %s: %s\", path, strerror(errno));\n+    return false;\n@@ -5851,13 +5822,3 @@\n-  pid_t parent_before = getpid();\n-\n-  \/\/ child\n-  if (fork()) {\n-    exit(0);\n-  }\n-  \/\/ grand-child\n-  pid_t parent = getppid();\n-  int tries = 300;\n-  while (parent != 1 && 0 < tries--) {\n-    ::usleep(10);\n-    parent = getppid();\n-  }\n+  _crengine = os::strdup(path);\n+  return true;\n+}\n@@ -5865,5 +5826,5 @@\n-  if (parent == parent_before) {\n-    trace_cr(\"can't move out of JVM process hierarchy\");\n-    union sigval sv = { .sival_int = -1 };\n-    sigqueue(jvm, RESTORE_SIGNAL, sv);\n-    exit(0);\n+static int call_crengine() {\n+  if (_crengine && !fork()) {\n+    execl(_crengine, _crengine, \"checkpoint\", CRaCCheckpointTo, NULL);\n+    perror(\"execl\");\n+    exit(1);\n@@ -5872,8 +5833,1 @@\n-  int cmdres = system(cmd);\n-  if (cmdres < 0 || !WIFEXITED(cmdres) || WEXITSTATUS(cmdres)) {\n-    trace_cr(\"%s call failed\", criu);\n-    union sigval sv = { .sival_int = -1 };\n-    sigqueue(jvm, RESTORE_SIGNAL, sv);\n-    exit(0);\n-  }\n-  exit(0);\n+  return 0;\n@@ -5891,2 +5845,2 @@\n-  int criu_res = call_criu();\n-  if (criu_res < 0) {\n+  int cres = call_crengine();\n+  if (cres < 0) {\n@@ -6184,0 +6138,4 @@\n+  if (!compute_crengine()) {\n+    return false;\n+  }\n+\n@@ -6244,14 +6202,0 @@\n-static char* add_arg(char** begin_p, char* end, const char *fmt, ...) {\n-  char* begin = *begin_p;\n-\n-  va_list va;\n-  va_start(va, fmt);\n-\n-  int len = vsnprintf(begin, end - begin, fmt, va);\n-  if (end <= begin + len) {\n-    return NULL;\n-  }\n-  *begin_p = begin + len + 1;\n-  return begin;\n-}\n-\n@@ -6261,4 +6205,1 @@\n-  char util_path[JVM_MAXPATHLEN];\n-  cr_util_path(util_path, sizeof(util_path));\n-\n-  const char *criu = compute_criu(util_path);\n+  compute_crengine();\n@@ -6266,17 +6207,3 @@\n-  char tempbuf[4 * JVM_MAXPATHLEN];\n-  char* end = tempbuf + sizeof(tempbuf);\n-  char* bufp = tempbuf;\n-\n-  snprintf(bufp, end - bufp, \"%s\/cppath\", CRaCRestoreFrom);\n-  int fd_cppath = ::open(bufp, O_RDONLY);\n-  if (fd_cppath < 0) {\n-    trace_cr(\"no valid image to restore: %s\", CRaCRestoreFrom);\n-    return;\n-  }\n-  int cppathlen = read(fd_cppath, bufp, end - bufp);\n-  close(fd_cppath);\n-\n-  char *cppath = bufp;\n-  if (cppathlen < 0) {\n-    warning(\"cannot read image: %s\", strerror(errno));\n-    return;\n+  if (_crengine) {\n+    execl(_crengine, _crengine, \"restore\", CRaCRestoreFrom, NULL);\n+    warning(\"cannot execute \\\"%s restore ...\\\" (%s)\", _crengine, strerror(errno));\n@@ -6284,57 +6211,0 @@\n-  if (cppathlen == end - bufp) {\n-    warning(\"invalid image: content too long\");\n-    return;\n-  }\n-  bufp[cppathlen] = '\\0';\n-  bufp += cppathlen + 1;\n-\n-  char* restore_script = add_arg(&bufp, end, \"%s\/action-script\", util_path);\n-  if (!restore_script) {\n-    warning(\"cannot format restore_script path\");\n-    return;\n-  }\n-\n-  char* wait = add_arg(&bufp, end, \"%s\/wait\", util_path);\n-  if (!wait) {\n-    warning(\"cannot format action-script path\");\n-    return;\n-  }\n-\n-  snprintf(bufp, end - bufp, \"%s\/%s\", CRaCRestoreFrom, PerfMemoryLinux::perfdata_name());\n-  int fd_perfdata = ::open(bufp, O_RDWR);\n-  char* inherit_perfdata = NULL;\n-  if (0 < fd_perfdata) {\n-    inherit_perfdata = add_arg(&bufp, end, \"fd[%d]:%s\/%s\",\n-        fd_perfdata,\n-        cppath[0] == '\/' ? cppath + 1 : cppath,\n-        PerfMemoryLinux::perfdata_name());\n-  }\n-\n-  if (CRTraceStartupTime) {\n-    tty->print_cr(\"STARTUPTIME \" JLONG_FORMAT \" criu-call\", os::javaTimeNanos());\n-  }\n-\n-  const char* args[32];\n-  const char** argp = args;\n-  *argp++ = criu;\n-  *argp++ = \"restore\";\n-  *argp++ = \"-W\";\n-  *argp++ = \".\";\n-  if (inherit_perfdata) {\n-    *argp++ = \"--inherit-fd\";\n-    *argp++ = inherit_perfdata;\n-  }\n-  *argp++ = \"--shell-job\";\n-  *argp++ = \"--action-script\";\n-  *argp++ = restore_script;\n-  *argp++ = \"-D\";\n-  *argp++ = CRaCRestoreFrom;\n-  *argp++ = \"-v1\";\n-  *argp++ = \"--exec-cmd\";\n-  *argp++ = \"--\";\n-  *argp++ = wait;\n-  *argp++ = NULL;\n-  guarantee(argp - args < (int)ARRAY_SIZE(args), \"args overflow\");\n-\n-  execvp(criu, (char**)args);\n-  warning(\"cannot execute \\\"%s restore ...\\\" (%s)\", criu, strerror(errno));\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":38,"deletions":168,"binary":false,"changes":206,"status":"modified"},{"patch":"@@ -1371,0 +1371,2 @@\n+  remove_file(backing_store_file_name);\n+\n","filename":"src\/hotspot\/os\/posix\/perfMemory_posix.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2096,0 +2096,3 @@\n+  product(ccstr, CREngine, \"criuengine\", \"Path or name of a program \"       \\\n+      \"implementing checkpoint\/restore\")                                    \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,113 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2021, Azul Systems, Inc. All rights reserved.\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <string.h>\n-#include <stdio.h>\n-#include <limits.h>\n-#include <stdlib.h>\n-#include <errno.h>\n-#include <unistd.h>\n-#include <signal.h>\n-#include <sys\/stat.h>\n-#include <fcntl.h>\n-\n-#define RESTORE_SIGNAL   (SIGRTMIN + 2)\n-\n-#define MSGPREFIX \"action-script: \"\n-\n-static int post_resume(void) {\n-    char *pidstr = getenv(\"CRTOOLS_INIT_PID\");\n-    if (!pidstr) {\n-        fprintf(stderr, MSGPREFIX \"cannot find CRTOOLS_INIT_PID env\\n\");\n-        return 1;\n-    }\n-    int pid = atoi(pidstr);\n-\n-    union sigval sv = { .sival_int = 0 };\n-    if (-1 == sigqueue(pid, RESTORE_SIGNAL, sv)) {\n-        perror(MSGPREFIX \"sigqueue\");\n-        return 1;\n-    }\n-\n-    return 0;\n-}\n-\n-static int post_dump(void) {\n-    char realdir[PATH_MAX];\n-\n-    char *imgdir = getenv(\"CRTOOLS_IMAGE_DIR\");\n-    if (!imgdir) {\n-        fprintf(stderr, MSGPREFIX \"cannot find CRTOOLS_IMAGE_DIR env\\n\");\n-        return 1;\n-    }\n-\n-    if (!realpath(imgdir, realdir)) {\n-        fprintf(stderr, MSGPREFIX \"cannot canonicalize %s: %s\\n\", imgdir, strerror(errno));\n-        return 1;\n-    }\n-\n-    int dirfd = open(realdir, O_DIRECTORY);\n-    if (dirfd < 0) {\n-        fprintf(stderr, MSGPREFIX \"can not open image dir %s: %s\\n\", realdir, strerror(errno));\n-        return 1;\n-    }\n-\n-    int fd = openat(dirfd, \"cppath\", O_CREAT | O_WRONLY | O_TRUNC, 0644);\n-    if (fd < 0) {\n-        fprintf(stderr, MSGPREFIX \"can not open file %s\/cppath: %s\\n\", realdir, strerror(errno));\n-        return 1;\n-    }\n-\n-    if (write(fd, realdir, strlen(realdir)) < 0) {\n-        fprintf(stderr, MSGPREFIX \"can not write %s\/cppath: %s\\n\", realdir, strerror(errno));\n-        return 1;\n-    }\n-    return 0;\n-}\n-\n-\/** Kicks VM after restore.\n- * Started by CRIU on certain phases of restore process. Does nothing after all\n- * phases except \"post-resume\" which is issued after complete restore. Then\n- * send signal via with ID attached to restored process. \\ref launcher should\n- * pass the ID via ZE_CR_NEW_ARGS_ID env variable.\n- *\/\n-int main(int argc, char *argv[]) {\n-    char *action = getenv(\"CRTOOLS_SCRIPT_ACTION\");\n-    if (!action) {\n-        fprintf(stderr, MSGPREFIX \"can not find CRTOOLS_SCRIPT_ACTION env\\n\");\n-        return 1;\n-    }\n-\n-    if (!strcmp(action, \"post-resume\")) {\n-        return post_resume();\n-    }\n-\n-    if (!strcmp(action, \"post-dump\")) {\n-        return post_dump();\n-    }\n-\n-    return 0;\n-}\n","filename":"src\/java.base\/unix\/native\/action-script\/action-script.c","additions":0,"deletions":113,"binary":false,"changes":113,"status":"deleted"},{"patch":"@@ -1,40 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2021, Azul Systems, Inc. All rights reserved.\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <string.h>\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <unistd.h>\n-\n-int main(int argc, char *argv[]) {\n-    char** newargv = malloc((argc + 2) * sizeof(char*));\n-    newargv[0] = \"sudo\";\n-    newargv[1] = \"criu\";\n-    memcpy(newargv + 2, argv + 1, argc * sizeof(char*));\n-    execvp(\"\/usr\/bin\/sudo\", newargv);\n-    perror(\"sudo criu\");\n-    return 1;\n-}\n","filename":"src\/java.base\/unix\/native\/criu\/criu.c","additions":0,"deletions":40,"binary":false,"changes":40,"status":"deleted"},{"patch":"@@ -0,0 +1,328 @@\n+\/*\n+ * Copyright (c) 2017, 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <assert.h>\n+#include <string.h>\n+#include <stdio.h>\n+#include <libgen.h>\n+#include <limits.h>\n+#include <stdlib.h>\n+#include <errno.h>\n+#include <unistd.h>\n+#include <fcntl.h>\n+#include <signal.h>\n+#include <sys\/wait.h>\n+#include <sys\/stat.h>\n+\n+#define RESTORE_SIGNAL   (SIGRTMIN + 2)\n+\n+#define PERFDATA_NAME \"perfdata\"\n+\n+#define ARRAY_SIZE(x) (sizeof(x) \/ sizeof(x[0]))\n+\n+static int create_cppath(const char *imagedir);\n+\n+static int g_pid;\n+\n+static int kickjvm(pid_t jvm, int code) {\n+    union sigval sv = { .sival_int = code };\n+    if (-1 == sigqueue(jvm, RESTORE_SIGNAL, sv)) {\n+        perror(\"sigqueue\");\n+        return 1;\n+    }\n+    return 0;\n+}\n+\n+static int checkpoint(pid_t jvm,\n+        const char *basedir,\n+        const char *self,\n+        const char *criu,\n+        const char *imagedir) {\n+\n+    if (fork()) {\n+        \/\/ main process\n+        wait(NULL);\n+        return 0;\n+    }\n+\n+    pid_t parent_before = getpid();\n+\n+    \/\/ child\n+    if (fork()) {\n+        exit(0);\n+    }\n+\n+    \/\/ grand-child\n+    pid_t parent = getppid();\n+    int tries = 300;\n+    while (parent != 1 && 0 < tries--) {\n+        usleep(10);\n+        parent = getppid();\n+    }\n+\n+    if (parent == parent_before) {\n+        fprintf(stderr, \"can't move out of JVM process hierarchy\");\n+        kickjvm(jvm, -1);\n+        exit(0);\n+    }\n+\n+\n+    char jvmpidchar[32];\n+    snprintf(jvmpidchar, sizeof(jvmpidchar), \"%d\", jvm);\n+\n+    pid_t child = fork();\n+    if (!child) {\n+        const char* args[] = {\n+            criu,\n+            \"dump\",\n+            \"-t\", jvmpidchar,\n+            \"-D\", imagedir,\n+            \"--shell-job\",\n+            \"-v4\", \"-o\", \"dump4.log\", \/\/ -D without -W makes criu cd to image dir for logs\n+            NULL\n+        };\n+        execv(criu, (char**)args);\n+        perror(\"criu dump\");\n+        exit(1);\n+    }\n+\n+    int status;\n+    if (child != wait(&status) || !WIFEXITED(status) || WEXITSTATUS(status)) {\n+        kickjvm(jvm, -1);\n+    }\n+\n+    create_cppath(imagedir);\n+    exit(0);\n+}\n+\n+static int restore(const char *basedir,\n+        const char *self,\n+        const char *criu,\n+        const char *imagedir) {\n+    char *cppathpath;\n+    if (-1 == asprintf(&cppathpath, \"%s\/cppath\", imagedir)) {\n+        return 1;\n+    }\n+\n+    char cppath[PATH_MAX];\n+    cppath[0] = '\\0';\n+    FILE *cppathfile = fopen(cppathpath, \"r\");\n+    if (!cppathfile) {\n+        perror(\"open cppath\");\n+        return 1;\n+    }\n+\n+    if (!fgets(cppath, sizeof(cppath), cppathfile)) {\n+        fprintf(stderr, \"fgets error\\n\");\n+        return 1;\n+    }\n+    fclose(cppathfile);\n+\n+    char *inherit_perfdata = NULL;\n+    char *perfdatapath;\n+    if (-1 == asprintf(&perfdatapath, \"%s\/\" PERFDATA_NAME, imagedir)) {\n+        return 1;\n+    }\n+    int perfdatafd = open(perfdatapath, O_RDWR);\n+    if (0 < perfdatafd) {\n+        if (-1 == asprintf(&inherit_perfdata, \"fd[%d]:%s\/\" PERFDATA_NAME,\n+                    perfdatafd,\n+                    cppath[0] == '\/' ? cppath + 1 : cppath)) {\n+            return 1;\n+        }\n+    }\n+\n+    const char* args[32] = { criu, \"restore\" };\n+    const char** arg = args + 2;\n+    if (inherit_perfdata) {\n+        *arg++ = \"--inherit-fd\";\n+        *arg++ = inherit_perfdata;\n+    }\n+    const char* tail[] = {\n+        \"-W\", \".\",\n+        \"--shell-job\",\n+        \"--action-script\", self,\n+        \"-D\", imagedir,\n+        \"-v1\",\n+        \"--exec-cmd\", \"--\", self, \"restorewait\",\n+        NULL\n+    };\n+    static_assert(ARRAY_SIZE(args) >= 2 + ARRAY_SIZE(tail),\n+            \"all possible arguments should fit\");\n+\n+    memcpy(arg, tail, sizeof(tail));\n+\n+    execv(criu, (char**)args);\n+    perror(\"exec criu\");\n+    return 1;\n+}\n+\n+#define MSGPREFIX \"\"\n+\n+static int post_resume(void) {\n+    char *pidstr = getenv(\"CRTOOLS_INIT_PID\");\n+    if (!pidstr) {\n+        fprintf(stderr, MSGPREFIX \"cannot find CRTOOLS_INIT_PID env\\n\");\n+        return 1;\n+    }\n+    int pid = atoi(pidstr);\n+\n+    union sigval sv = { .sival_int = 0 };\n+    if (-1 == sigqueue(pid, RESTORE_SIGNAL, sv)) {\n+        perror(MSGPREFIX \"sigqueue\");\n+        return 1;\n+    }\n+\n+    return 0;\n+}\n+\n+static int create_cppath(const char *imagedir) {\n+    char realdir[PATH_MAX];\n+\n+    if (!realpath(imagedir, realdir)) {\n+        fprintf(stderr, MSGPREFIX \"cannot canonicalize %s: %s\\n\", imagedir, strerror(errno));\n+        return 1;\n+    }\n+\n+    int dirfd = open(realdir, O_DIRECTORY);\n+    if (dirfd < 0) {\n+        fprintf(stderr, MSGPREFIX \"can not open image dir %s: %s\\n\", realdir, strerror(errno));\n+        return 1;\n+    }\n+\n+    int fd = openat(dirfd, \"cppath\", O_CREAT | O_WRONLY | O_TRUNC, 0644);\n+    if (fd < 0) {\n+        fprintf(stderr, MSGPREFIX \"can not open file %s\/cppath: %s\\n\", realdir, strerror(errno));\n+        return 1;\n+    }\n+\n+    if (write(fd, realdir, strlen(realdir)) < 0) {\n+        fprintf(stderr, MSGPREFIX \"can not write %s\/cppath: %s\\n\", realdir, strerror(errno));\n+        return 1;\n+    }\n+    return 0;\n+}\n+\n+static void sighandler(int sig, siginfo_t *info, void *uc) {\n+    if (0 <= g_pid) {\n+        kill(g_pid, sig);\n+    }\n+}\n+\n+static int restorewait(void) {\n+    char *pidstr = getenv(\"CRTOOLS_INIT_PID\");\n+    if (!pidstr) {\n+        fprintf(stderr, MSGPREFIX \"no CRTOOLS_INIT_PID: signals may not be delivered\\n\");\n+    }\n+    g_pid = pidstr ? atoi(pidstr) : -1;\n+\n+    struct sigaction sigact;\n+    sigfillset(&sigact.sa_mask);\n+    sigact.sa_flags = SA_SIGINFO;\n+    sigact.sa_sigaction = sighandler;\n+\n+    int sig;\n+    for (sig = 1; sig <= 31; ++sig) {\n+        if (sig == SIGKILL || sig == SIGSTOP) {\n+            continue;\n+        }\n+        if (-1 == sigaction(sig, &sigact, NULL)) {\n+            perror(\"sigaction\");\n+        }\n+    }\n+\n+    sigset_t allset;\n+    sigfillset(&allset);\n+    if (-1 == sigprocmask(SIG_UNBLOCK, &allset, NULL)) {\n+        perror(MSGPREFIX \"sigprocmask\");\n+    }\n+\n+    int status;\n+    int ret;\n+    do {\n+        ret = waitpid(g_pid, &status, 0);\n+    } while (ret == -1 && errno == EINTR);\n+\n+    if (ret == -1) {\n+        perror(MSGPREFIX \"waitpid\");\n+        return 1;\n+    }\n+\n+    if (WIFEXITED(status)) {\n+        return WEXITSTATUS(status);\n+    }\n+\n+    return 1;\n+}\n+\n+int main(int argc, char *argv[]) {\n+    char* action;\n+    if ((action = argv[1])) {\n+        char* imagedir = argv[2];\n+\n+        char *basedir = dirname(strdup(argv[0]));\n+\n+        char *criu = getenv(\"CRAC_CRIU_PATH\");\n+        if (!criu) {\n+            if (-1 == asprintf(&criu, \"%s\/criu\", basedir)) {\n+                return 1;\n+            }\n+            struct stat st;\n+            if (stat(criu, &st)) {\n+                \/* some problem with the bundled criu *\/\n+                criu = \"\/usr\/sbin\/criu\";\n+                if (stat(criu, &st)) {\n+                    fprintf(stderr, \"cannot find CRIU to use\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+\n+\n+        if (!strcmp(action, \"checkpoint\")) {\n+            pid_t jvm = getppid();\n+            return checkpoint(jvm, basedir, argv[0], criu, imagedir);\n+        } else if (!strcmp(action, \"restore\")) {\n+            return restore(basedir, argv[0], criu, imagedir);\n+        } else if (!strcmp(action, \"restorewait\")) { \/\/ called by CRIU --exec-cmd\n+            return restorewait();\n+        } else {\n+            fprintf(stderr, \"unknown command-line action: %s\\n\", action);\n+            return 1;\n+        }\n+    } else if ((action = getenv(\"CRTOOLS_SCRIPT_ACTION\"))) { \/\/ called by CRIU --action-script\n+        if (!strcmp(action, \"post-resume\")) {\n+            return post_resume();\n+        } else {\n+            \/\/ ignore other notifications\n+            return 0;\n+        }\n+    } else {\n+        fprintf(stderr, \"unknown context\\n\");\n+    }\n+\n+    return 1;\n+}\n","filename":"src\/java.base\/unix\/native\/criuengine\/criuengine.c","additions":328,"deletions":0,"binary":false,"changes":328,"status":"added"},{"patch":"@@ -1,73 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2021, Azul Systems, Inc. All rights reserved.\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <stdlib.h>\n-#include <unistd.h>\n-#include <stdio.h>\n-#include <string.h>\n-#include <inttypes.h>\n-#include <time.h>\n-#include <sys\/time.h>\n-\n-uint64_t nanos(void) {\n-  struct timespec tp;\n-  if (0 != clock_gettime(CLOCK_MONOTONIC, &tp)) {\n-    perror(\"clock_gettime\");\n-    exit(1);\n-  }\n-  return ((uint64_t)tp.tv_sec) * (1000 * 1000 * 1000) + (uint64_t)tp.tv_nsec;\n-}\n-\n-uint64_t millis(void) {\n-  struct timeval time;\n-  if (0 != gettimeofday(&time, NULL)) {\n-    perror(\"gettimeofday\");\n-    exit(1);\n-  }\n-  return ((uint64_t)time.tv_sec) * 1000 + ((uint64_t)time.tv_usec)\/1000;\n-}\n-\n-int main(int argc, char *argv[]) {\n-  int opt;\n-  uint64_t (*fn)(void) = nanos;\n-  while ((opt = getopt(argc, argv, \"mn\")) != -1) {\n-  switch (opt) {\n-    case 'n':\n-      fn = nanos;\n-      break;\n-    case 'm':\n-      fn = millis;\n-      break;\n-    default:\n-      break;\n-    }\n-  }\n-\n-  uint64_t time = fn();\n-  char *msg = optind < argc ? argv[optind] : \"prestart\";\n-  printf(\"STARTUPTIME %\" PRIu64 \" %s\\n\", time, msg);\n-  return 0;\n-}\n","filename":"src\/java.base\/unix\/native\/javatime\/javatime.c","additions":0,"deletions":73,"binary":false,"changes":73,"status":"deleted"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <string.h>\n+#include <stdio.h>\n+#include <unistd.h>\n+#include <signal.h>\n+\n+#define RESTORE_SIGNAL   (SIGRTMIN + 2)\n+\n+static int kickjvm(pid_t jvm, int code) {\n+    union sigval sv = { .sival_int = code };\n+    if (-1 == sigqueue(jvm, RESTORE_SIGNAL, sv)) {\n+        perror(\"sigqueue\");\n+        return 1;\n+    }\n+    return 0;\n+}\n+\n+int main(int argc, char *argv[]) {\n+    char* action = argv[1];\n+    char* imagedir = argv[2];\n+\n+    char *pidpath;\n+    if (-1 == asprintf(&pidpath, \"%s\/pid\", imagedir)) {\n+        return 1;\n+    }\n+\n+    if (!strcmp(action, \"checkpoint\")) {\n+        pid_t jvm = getppid();\n+\n+        FILE *pidfile = fopen(pidpath, \"w\");\n+        if (!pidfile) {\n+            perror(\"fopen pidfile\");\n+            kickjvm(jvm, -1);\n+            return 1;\n+        }\n+\n+        fprintf(pidfile, \"%d\\n\", jvm);\n+\n+    } else if (!strcmp(action, \"restore\")) {\n+        FILE *pidfile = fopen(pidpath, \"r\");\n+        if (!pidfile) {\n+            perror(\"fopen pidfile\");\n+            return 1;\n+        }\n+\n+        pid_t jvm;\n+        if (1 != fscanf(pidfile, \"%d\", &jvm)) {\n+            fprintf(stderr, \"cannot read pid\\n\");\n+            return 1;\n+        }\n+\n+        if (kickjvm(jvm, 0)) {\n+            return 1;\n+        }\n+\n+    } else {\n+        fprintf(stderr, \"unknown action: %s\\n\", action);\n+        return 1;\n+    }\n+\n+    return 0;\n+}\n","filename":"src\/java.base\/unix\/native\/pauseengine\/pauseengine.c","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <string.h>\n+#include <stdio.h>\n+#include <unistd.h>\n+#include <signal.h>\n+\n+#define RESTORE_SIGNAL   (SIGRTMIN + 2)\n+\n+static int kickjvm(pid_t jvm, int code) {\n+    union sigval sv = { .sival_int = code };\n+    if (-1 == sigqueue(jvm, RESTORE_SIGNAL, sv)) {\n+        perror(\"sigqueue\");\n+        return 1;\n+    }\n+    return 0;\n+}\n+\n+int main(int argc, char *argv[]) {\n+    char* action = argv[1];\n+\n+    if (!strcmp(action, \"checkpoint\")) {\n+        pid_t jvm = getppid();\n+        kickjvm(jvm, 0);\n+    } else if (!strcmp(action, \"restore\")) {\n+        \/* should not be called and nothing to do *\/\n+    } else {\n+        fprintf(stderr, \"unknown action: %s\\n\", action);\n+        return 1;\n+    }\n+\n+    return 0;\n+}\n","filename":"src\/java.base\/unix\/native\/simengine\/simengine.c","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -1,87 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2021, Azul Systems, Inc. All rights reserved.\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <errno.h>\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <signal.h>\n-#include <sys\/wait.h>\n-\n-#define MSGPREFIX \"wait: \"\n-\n-static int g_pid;\n-\n-static void sighandler(int sig, siginfo_t *info, void *uc) {\n-    if (0 <= g_pid) {\n-        kill(g_pid, sig);\n-    }\n-}\n-\n-int main(int argc, char *argv[]) {\n-    char *pidstr = getenv(\"CRTOOLS_INIT_PID\");\n-    if (!pidstr) {\n-        fprintf(stderr, MSGPREFIX \"no CRTOOLS_INIT_PID: signals may not be delivered\\n\");\n-    }\n-    g_pid = pidstr ? atoi(pidstr) : -1;\n-\n-    struct sigaction sigact;\n-    sigfillset(&sigact.sa_mask);\n-    sigact.sa_flags = SA_SIGINFO;\n-    sigact.sa_sigaction = sighandler;\n-\n-    int sig;\n-    for (sig = 1; sig <= 31; ++sig) {\n-        if (sig == SIGKILL || sig == SIGSTOP) {\n-            continue;\n-        }\n-        if (-1 == sigaction(sig, &sigact, NULL)) {\n-            perror(\"sigaction\");\n-        }\n-    }\n-\n-    sigset_t allset;\n-    sigfillset(&allset);\n-    if (-1 == sigprocmask(SIG_UNBLOCK, &allset, NULL)) {\n-        perror(MSGPREFIX \"sigprocmask\");\n-    }\n-\n-    int status;\n-    int ret;\n-    do {\n-        ret = waitpid(g_pid, &status, 0);\n-    } while (ret == -1 && errno == EINTR);\n-\n-    if (ret == -1) {\n-        perror(MSGPREFIX \"waitpid\");\n-        return 1;\n-    }\n-\n-    if (WIFEXITED(status)) {\n-        return WEXITSTATUS(status);\n-    }\n-\n-    return 1;\n-}\n","filename":"src\/java.base\/unix\/native\/wait\/wait.c","additions":0,"deletions":87,"binary":false,"changes":87,"status":"deleted"},{"patch":"@@ -205,4 +205,3 @@\n-                            || fileName.equals(\"action-script\")\n-                            || fileName.equals(\"wait\")\n-                            || fileName.equals(\"criu\")\n-                            || fileName.equals(\"javatime\");\n+                            || fileName.equals(\"criuengine\")\n+                            || fileName.equals(\"pauseengine\")\n+                            || fileName.equals(\"simengine\");\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/builder\/DefaultImageBuilder.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"}]}