{"files":[{"patch":"@@ -6119,13 +6119,11 @@\n-static void wakeup_threads_in_timedwait() {\n-  SafeThreadsListPtr listPtr(Thread::current(), true);\n-  ThreadsList *list = listPtr.list();\n-  assert(list != NULL, \"Thread list is null\");\n-  for (uint i = 0; i < list->length(); ++i) {\n-    JavaThread* t = list->thread_at(i);\n-    assert(t != NULL, \"Thread is null\");\n-    ThreadState state = t->osthread()->get_state();\n-    \/\/ ThreadState::SLEEPING is not used\n-    if (state == ThreadState::CONDVAR_WAIT || state == ThreadState::OBJECT_WAIT) {\n-      \/\/ We want to cause a wakeup but not interrupted exception\n-      t->interrupt();\n-      t->osthread()->set_interrupted(false);\n+class WakeupClosure: public ThreadClosure {\n+  void do_thread(Thread* thread) {\n+    if (thread->is_Java_thread()) {\n+      ThreadState state = thread->osthread()->get_state();\n+      \/\/ ThreadState::SLEEPING is not used\n+      if (state == ThreadState::CONDVAR_WAIT || state == ThreadState::OBJECT_WAIT) {\n+        JavaThread *jt = (JavaThread *) thread;\n+        \/\/ We want to cause a wakeup but not interrupted exception\n+        jt->interrupt();\n+        jt->osthread()->set_interrupted(false);\n+      }\n@@ -6134,0 +6132,5 @@\n+};\n+\n+static void wakeup_threads_in_timedwait() {\n+  WakeupClosure wc;\n+  Threads::java_threads_do(&wc);\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":16,"deletions":13,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.io.IOException;\n@@ -98,0 +99,1 @@\n+                    System.err.print(restore.outputAnalyzer().getStderr());\n@@ -110,0 +112,23 @@\n+    private interface Task {\n+        void run() throws InterruptedException;\n+    }\n+\n+    private static void timedWait(Task task, List<Throwable> exceptions, boolean canReturnEarly) {\n+        try {\n+            long before = System.currentTimeMillis();\n+            task.run();\n+            long after = System.currentTimeMillis();\n+            if (after - before < WAIT_TIME_MILLIS) {\n+                if (canReturnEarly) {\n+                    \/\/ Non-critical\n+                    System.err.println(Thread.currentThread().getName() + \" took: \" + (after - before) + \" ms\");\n+                } else {\n+                    exceptions.add(new IllegalStateException(\n+                            Thread.currentThread().getName() + \" was too short: \" + (after - before) + \" ms\"));\n+                }\n+            }\n+        } catch (InterruptedException e) {\n+            exceptions.add(unexpectedInterrupt(e));\n+        }\n+    }\n+\n@@ -117,5 +142,1 @@\n-            try {\n-                Thread.sleep(WAIT_TIME_MILLIS);\n-            } catch (InterruptedException e) {\n-                exceptions.add(unexpectedInterrupt(e));\n-            }\n+            timedWait(() -> Thread.sleep(WAIT_TIME_MILLIS), exceptions, false);\n@@ -134,5 +155,1 @@\n-            try {\n-                daemon.join(WAIT_TIME_MILLIS);\n-            } catch (InterruptedException e) {\n-                exceptions.add(unexpectedInterrupt(e));\n-            }\n+            timedWait(() -> daemon.join(WAIT_TIME_MILLIS), exceptions, false);\n@@ -143,5 +160,1 @@\n-                try {\n-                    this.wait(WAIT_TIME_MILLIS);\n-                } catch (InterruptedException e) {\n-                    exceptions.add(unexpectedInterrupt(e));\n-                }\n+                timedWait(() -> this.wait(WAIT_TIME_MILLIS), exceptions, true);\n@@ -154,1 +167,1 @@\n-            try {\n+            timedWait(() -> {\n@@ -158,3 +171,1 @@\n-            } catch (InterruptedException e) {\n-                exceptions.add(unexpectedInterrupt(e));\n-            }\n+            }, exceptions, false);\n@@ -167,8 +178,2 @@\n-            try {\n-                \/\/ We don't mind whether the call finishes after waiting\n-                \/\/ those 1000 millis or spuriously before\n-                \/\/noinspection ResultOfMethodCallIgnored\n-                condition.await(WAIT_TIME_MILLIS, TimeUnit.MILLISECONDS);\n-            } catch (InterruptedException e) {\n-                exceptions.add(unexpectedInterrupt(e));\n-            }\n+            \/\/noinspection ResultOfMethodCallIgnored\n+            timedWait(() -> condition.await(WAIT_TIME_MILLIS, TimeUnit.MILLISECONDS), exceptions, true);\n@@ -178,1 +183,2 @@\n-            LockSupport.parkUntil(System.currentTimeMillis() + WAIT_TIME_MILLIS);\n+            timedWait(() -> LockSupport.parkUntil(System.currentTimeMillis() + WAIT_TIME_MILLIS),\n+                    exceptions, true);\n","filename":"test\/jdk\/jdk\/crac\/java\/lang\/System\/TimedWaitingTest.java","additions":34,"deletions":28,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -82,0 +82,9 @@\n+        if (exitValue != 0 && builder.captureOutput) {\n+            try {\n+                OutputAnalyzer oa = outputAnalyzer();\n+                System.err.print(oa.getStderr());\n+                System.out.print(oa.getStdout());\n+            } catch (IOException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n","filename":"test\/lib\/jdk\/test\/lib\/crac\/CracProcess.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"}]}