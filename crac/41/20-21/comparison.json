{"files":[{"patch":"@@ -774,1 +774,4 @@\n-void VM_Version::glibc_not_using(uint64_t excessive_CPU, uint64_t excessive_GLIBC) {\n+const char VM_Version::glibc_prefix[] = \":glibc.cpu.hwcaps=\";\n+const size_t VM_Version::glibc_prefix_len = strlen(glibc_prefix);\n+\n+bool VM_Version::glibc_env_set(char *disable_str) {\n@@ -776,1 +779,118 @@\n-#if INCLUDE_CPU_FEATURE_ACTIVE || INCLUDE_LD_SO_LIST_DIAGNOSTICS\n+  char *env_val = disable_str;\n+  const char *env = getenv(TUNABLES_NAME);\n+  if (env && strcmp(env, env_val) == 0) {\n+#if !INCLUDE_CPU_FEATURE_ACTIVE && !INCLUDE_LD_SO_LIST_DIAGNOSTICS\n+    if (ShowCPUFeatures) {\n+      tty->print_cr(\"Environment variable already set, both glibc CPU_FEATURE_ACTIVE and ld.so --list-diagnostics are unavailable - re-exec suppressed: \" TUNABLES_NAME \"=%s\", env);\n+    }\n+    return true;\n+#endif\n+  }\n+  char env_buf[strlen(disable_str) + (!env ? 0 : strlen(env) + 100)];\n+  if (env) {\n+    if (ShowCPUFeatures) {\n+      tty->print_cr(\"Original environment variable: \" TUNABLES_NAME \"=%s\", env);\n+    }\n+    const char *hwcaps = strstr(env, glibc_prefix + 1 \/* skip ':' *\/);\n+    if (!hwcaps) {\n+      strcpy(env_buf, env);\n+      strcat(env_buf, disable_str);\n+    } else {\n+      const char *colon = strchr(hwcaps, ':');\n+      if (!colon) {\n+        strcpy(env_buf, env);\n+        strcat(env_buf, disable_str + glibc_prefix_len);\n+      } else {\n+        int err = jio_snprintf(env_buf, sizeof(env_buf), \"%.*s%s%s\", (int)(colon - env), env, disable_str + glibc_prefix_len, colon);\n+        assert(err >= 0 && (unsigned)err < sizeof(env_buf), \"internal error: \" TUNABLES_NAME \" buffer overflow\");\n+      }\n+    }\n+    env_val = env_buf;\n+  }\n+  if (ShowCPUFeatures) {\n+    tty->print_cr(\"Re-exec of java with new environment variable: \" TUNABLES_NAME \"=%s\", env_val);\n+  }\n+  char errbuf[512];\n+  int err = setenv(TUNABLES_NAME, env_val, 1);\n+  if (err) {\n+    jio_snprintf(errbuf, sizeof(errbuf), \"setenv \" TUNABLES_NAME \" error: %m\");\n+    vm_exit_during_initialization(errbuf);\n+  }\n+\n+#define REEXEC_NAME \"HOTSPOT_GLIBC_TUNABLES_REEXEC\"\n+  if (getenv(REEXEC_NAME)) {\n+    jio_snprintf(errbuf, sizeof(errbuf), \"internal error: \" TUNABLES_NAME \"=%s failed and \" REEXEC_NAME \" is set\", disable_str);\n+    vm_exit_during_initialization(errbuf);\n+  }\n+  if (setenv(REEXEC_NAME, \"1\", 1)) {\n+    jio_snprintf(errbuf, sizeof(errbuf), \"setenv \" REEXEC_NAME \" error: %m\");\n+    vm_exit_during_initialization(errbuf);\n+  }\n+#undef REEXEC_NAME\n+#undef TUNABLES_NAME\n+  return false;\n+}\n+\n+void VM_Version::glibc_reexec() {\n+  char *buf = NULL;\n+  size_t buf_allocated = 0;\n+  size_t buf_used = 0;\n+#define CMDLINE \"\/proc\/self\/cmdline\"\n+  char errbuf[512];\n+  int fd = open(CMDLINE, O_RDONLY);\n+  if (fd == -1) {\n+    jio_snprintf(errbuf, sizeof(errbuf), \"Cannot open \" CMDLINE \": %m\");\n+    vm_exit_during_initialization(errbuf);\n+  }\n+  ssize_t got;\n+  do {\n+    if (buf_used == buf_allocated) {\n+      buf_allocated = MAX2(size_t(4096), 2 * buf_allocated);\n+      buf = (char *)os::realloc(buf, buf_allocated, mtOther);\n+      if (buf == NULL) {\n+        jio_snprintf(errbuf, sizeof(errbuf), CMDLINE \" reading failed allocating %zu bytes\", buf_allocated);\n+        vm_exit_during_initialization(errbuf);\n+      }\n+    }\n+    got = read(fd, buf + buf_used, buf_allocated - buf_used);\n+    if (got == -1) {\n+      jio_snprintf(errbuf, sizeof(errbuf), \"Cannot read \" CMDLINE \": %m\");\n+      vm_exit_during_initialization(errbuf);\n+    }\n+    buf_used += got;\n+  } while (got);\n+  if (close(fd)) {\n+    jio_snprintf(errbuf, sizeof(errbuf), \"Cannot close \" CMDLINE \": %m\");\n+    vm_exit_during_initialization(errbuf);\n+  }\n+  char **argv = NULL;\n+  size_t argv_allocated = 0;\n+  size_t argv_used = 0;\n+  char *s = buf;\n+  while (s <= buf + buf_used) {\n+    if (argv_used == argv_allocated) {\n+      argv_allocated = MAX2(size_t(256), 2 * argv_allocated);\n+      argv = (char **)os::realloc(argv, argv_allocated * sizeof(*argv), mtOther);\n+      if (argv == NULL) {\n+        jio_snprintf(errbuf, sizeof(errbuf), CMDLINE \" reading failed allocating %zu pointers\", argv_allocated);\n+        vm_exit_during_initialization(errbuf);\n+      }\n+    }\n+    if (s == buf + buf_used) {\n+      break;\n+    }\n+    argv[argv_used++] = s;\n+    s += strnlen(s, buf + buf_used - s);\n+    if (s == buf + buf_used)\n+      vm_exit_during_initialization(\"Missing end of string zero while parsing \" CMDLINE);\n+    ++s;\n+  }\n+  argv[argv_used] = NULL;\n+#undef CMDLINE\n+\n+#define EXEC \"\/proc\/self\/exe\"\n+  execv(EXEC, argv);\n+  jio_snprintf(errbuf, sizeof(errbuf), \"Cannot re-execute \" EXEC \": %m\");\n+  vm_exit_during_initialization(errbuf);\n+#undef EXEC\n+}\n@@ -778,0 +898,1 @@\n+void VM_Version::glibc_not_using(uint64_t excessive_CPU, uint64_t excessive_GLIBC) {\n@@ -945,2 +1066,1 @@\n-#endif\n-#if INCLUDE_LD_SO_LIST_DIAGNOSTICS\n+#elif INCLUDE_LD_SO_LIST_DIAGNOSTICS\n@@ -952,0 +1072,2 @@\n+#else\n+# define FEATURE_ACTIVE(glibc, hotspot_field, hotspot_union, glibc_index, glibc_reg) true\n@@ -999,6 +1121,3 @@\n-#define PREFIX \":glibc.cpu.hwcaps=\"\n-  const char prefix[] = PREFIX;\n-  const size_t prefix_len = sizeof(prefix) - 1;\n-  char disable_str[64 * (10 + 3) + 1] = PREFIX;\n-#undef PREFIX\n-  char *disable_end = disable_str + prefix_len;\n+  char disable_str[64 * (10 + 3) + 1];\n+  strcpy(disable_str, glibc_prefix);\n+  char *disable_end = disable_str + glibc_prefix_len;\n@@ -1108,1 +1227,1 @@\n-  if (disable_end == disable_str + prefix_len)\n+  if (disable_end == disable_str + glibc_prefix_len)\n@@ -1110,111 +1229,3 @@\n-\n-  char *env_val = disable_str;\n-  const char *env = getenv(TUNABLES_NAME);\n-  char env_buf[strlen(disable_str) + (!env ? 0 : strlen(env) + 100)];\n-  if (env) {\n-    if (ShowCPUFeatures) {\n-      tty->print_cr(\"Original environment variable: \" TUNABLES_NAME \"=%s\", env);\n-    }\n-    const char *hwcaps = strstr(env, prefix + 1 \/* skip ':' *\/);\n-    if (!hwcaps) {\n-      strcpy(env_buf, env);\n-      strcat(env_buf, disable_str);\n-    } else {\n-      const char *colon = strchr(hwcaps, ':');\n-      if (!colon) {\n-        strcpy(env_buf, env);\n-        strcat(env_buf, disable_str + prefix_len);\n-      } else {\n-        int err = jio_snprintf(env_buf, sizeof(env_buf), \"%.*s%s%s\", (int)(colon - env), env, disable_str + prefix_len, colon);\n-        assert(err >= 0 && (unsigned)err < sizeof(env_buf), \"internal error: \" TUNABLES_NAME \" buffer overflow\");\n-      }\n-    }\n-    env_val = env_buf;\n-  }\n-  if (ShowCPUFeatures) {\n-    tty->print_cr(\"Re-exec of java with new environment variable: \" TUNABLES_NAME \"=%s\", env_val);\n-  }\n-  int err = setenv(TUNABLES_NAME, env_val, 1);\n-  if (err) {\n-    jio_snprintf(errbuf, sizeof(errbuf), \"setenv \" TUNABLES_NAME \" error: %m\");\n-    vm_exit_during_initialization(errbuf);\n-  }\n-\n-#define REEXEC_NAME \"HOTSPOT_GLIBC_TUNABLES_REEXEC\"\n-  if (getenv(REEXEC_NAME)) {\n-    jio_snprintf(errbuf, sizeof(errbuf), \"internal error: \" TUNABLES_NAME \"=%s failed and \" REEXEC_NAME \" is set\", disable_str);\n-    vm_exit_during_initialization(errbuf);\n-  }\n-  if (setenv(REEXEC_NAME, \"1\", 1)) {\n-    jio_snprintf(errbuf, sizeof(errbuf), \"setenv \" REEXEC_NAME \" error: %m\");\n-    vm_exit_during_initialization(errbuf);\n-  }\n-#undef REEXEC_NAME\n-\n-  char *buf = NULL;\n-  size_t buf_allocated = 0;\n-  size_t buf_used = 0;\n-#define CMDLINE \"\/proc\/self\/cmdline\"\n-  int fd = open(CMDLINE, O_RDONLY);\n-  if (fd == -1) {\n-    jio_snprintf(errbuf, sizeof(errbuf), \"Cannot open \" CMDLINE \": %m\");\n-    vm_exit_during_initialization(errbuf);\n-  }\n-  ssize_t got;\n-  do {\n-    if (buf_used == buf_allocated) {\n-      buf_allocated = MAX2(size_t(4096), 2 * buf_allocated);\n-      buf = (char *)os::realloc(buf, buf_allocated, mtOther);\n-      if (buf == NULL) {\n-        jio_snprintf(errbuf, sizeof(errbuf), CMDLINE \" reading failed allocating %zu bytes\", buf_allocated);\n-        vm_exit_during_initialization(errbuf);\n-      }\n-    }\n-    got = read(fd, buf + buf_used, buf_allocated - buf_used);\n-    if (got == -1) {\n-      jio_snprintf(errbuf, sizeof(errbuf), \"Cannot read \" CMDLINE \": %m\");\n-      vm_exit_during_initialization(errbuf);\n-    }\n-    buf_used += got;\n-  } while (got);\n-  if (close(fd)) {\n-    jio_snprintf(errbuf, sizeof(errbuf), \"Cannot close \" CMDLINE \": %m\");\n-    vm_exit_during_initialization(errbuf);\n-  }\n-  char **argv = NULL;\n-  size_t argv_allocated = 0;\n-  size_t argv_used = 0;\n-  char *s = buf;\n-  while (s <= buf + buf_used) {\n-    if (argv_used == argv_allocated) {\n-      argv_allocated = MAX2(size_t(256), 2 * argv_allocated);\n-      argv = (char **)os::realloc(argv, argv_allocated * sizeof(*argv), mtOther);\n-      if (argv == NULL) {\n-        jio_snprintf(errbuf, sizeof(errbuf), CMDLINE \" reading failed allocating %zu pointers\", argv_allocated);\n-        vm_exit_during_initialization(errbuf);\n-      }\n-    }\n-    if (s == buf + buf_used) {\n-      break;\n-    }\n-    argv[argv_used++] = s;\n-    s += strnlen(s, buf + buf_used - s);\n-    if (s == buf + buf_used)\n-      vm_exit_during_initialization(\"Missing end of string zero while parsing \" CMDLINE);\n-    ++s;\n-  }\n-  argv[argv_used] = NULL;\n-#undef CMDLINE\n-\n-#define EXEC \"\/proc\/self\/exe\"\n-  execv(EXEC, argv);\n-  jio_snprintf(errbuf, sizeof(errbuf), \"Cannot re-execute \" EXEC \": %m\");\n-  vm_exit_during_initialization(errbuf);\n-#undef EXEC\n-\n-#else \/\/ !INCLUDE_CPU_FEATURE_ACTIVE && !INCLUDE_LD_SO_LIST_DIAGNOSTICS\n-  if (ShowCPUFeatures) {\n-    tty->print_cr(\"-XX:CPUFeatures glibc setting \" TUNABLES_NAME \" is not supported in this Java build\");\n-  }\n-#endif \/\/ !INCLUDE_CPU_FEATURE_ACTIVE && !INCLUDE_LD_SO_LIST_DIAGNOSTICS\n-#undef TUNABLES_NAME\n+  if (glibc_env_set(disable_str))\n+    return;\n+  glibc_reexec();\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":133,"deletions":122,"binary":false,"changes":255,"status":"modified"},{"patch":"@@ -771,0 +771,5 @@\n+  static bool glibc_env_set(char *disable_str);\n+  \/*[[noreturn]]*\/ static void glibc_reexec();\n+  \/\/ C++17: Make glibc_prefix and glibc_prefix_len constexpr.\n+  static const char glibc_prefix[];\n+  static const size_t glibc_prefix_len;\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"}]}