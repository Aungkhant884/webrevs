{"files":[{"patch":"@@ -123,0 +123,1 @@\n+# include <execinfo.h>\n@@ -6048,3 +6049,3 @@\n-        unsigned long l = strtoul(name, &endptr, 10);\n-        pid_t ent_tid = l;\n-        if (l >= LONG_MAX || ent_tid != (long) l) {\n+        unsigned long ul = strtoul(name, &endptr, 10);\n+        pid_t ent_tid = ul;\n+        if (ul >= LONG_MAX || ent_tid != (long) ul) {\n@@ -6072,3 +6073,4 @@\n-  static pthread_mutex_t signalled_mutex;\n-  static pthread_cond_t signalled_cond;\n-  static size_t signalled;\n+  static pthread_mutex_t signaled_mutex;\n+  static pthread_cond_t signaled_cond;\n+  \/\/ FIXME: 'in_handler' should be atomic.\n+  static size_t signaled, in_handler;\n@@ -6076,0 +6078,29 @@\n+#ifdef __x86_64__\n+  __attribute__((noinline, noclone)) static bool caller_is_unsafe() {\n+    \/\/ [0] is ourselves, [1] is handler(), [2] is signal frame, [3] is a signal-interrupted code.\n+    const size_t bt_size = 4;\n+    void *bt[bt_size];\n+    if (backtrace(bt, bt_size) != bt_size) {\n+      tty->print_cr(\"JVM: Freeze: TID %d backtrace(%zu) failed\\n\", (int)gettid(), bt_size);\n+      return false;\n+    }\n+    const void *code = bt[bt_size - 1];\n+    Dl_info info;\n+    if (!dladdr(code, &info)) {\n+      \/\/ Signal-interrupted code is not in a shared library.\n+      return false;\n+    }\n+    const char *cs = strrchr(info.dli_fname, '\/');\n+    if (!cs || strcmp(cs + 1, \"libc.so.6\") != 0) {\n+      \/\/ Signal-interrupted code is not in glibc.\n+      return false;\n+    }\n+    const uint16_t *syscall = ((const uint16_t *)code) - 1;\n+    \/\/ The check is not absolutely safe as we cannot disasemble backwards.\n+    if (*syscall == 0x050f) {\n+      \/\/ Signal-interrupted code is waiting in syscall.\n+      return false;\n+    }\n+    return true;\n+  }\n+#endif \/\/ __x86_64__\n@@ -6079,1 +6110,1 @@\n-    err = pthread_mutex_lock(&signalled_mutex);\n+    err = pthread_mutex_lock(&signaled_mutex);\n@@ -6081,2 +6112,3 @@\n-    ++signalled;\n-    err = pthread_mutex_unlock(&signalled_mutex);\n+    ++signaled;\n+    ++in_handler;\n+    err = pthread_mutex_unlock(&signaled_mutex);\n@@ -6084,1 +6116,1 @@\n-    err = pthread_cond_signal(&signalled_cond);\n+    err = pthread_cond_signal(&signaled_cond);\n@@ -6086,0 +6118,7 @@\n+#ifdef __x86_64__\n+    if (caller_is_unsafe()) {\n+      frozen = false;\n+      --in_handler;\n+      return;\n+    }\n+#endif \/\/ __x86_64__\n@@ -6092,0 +6131,1 @@\n+    --in_handler;\n@@ -6093,1 +6133,4 @@\n-  bool frozen;\n+  static bool frozen;\n+#ifdef ASSERT\n+  static bool singleton;\n+#endif\n@@ -6097,1 +6140,1 @@\n-    frozen = false;\n+    assert(!frozen, \"double freeze?\");\n@@ -6106,3 +6149,4 @@\n-    signalled_mutex = PTHREAD_MUTEX_INITIALIZER;\n-    signalled_cond = PTHREAD_COND_INITIALIZER;\n-    signalled = 0;\n+    signaled_mutex = PTHREAD_MUTEX_INITIALIZER;\n+    signaled_cond = PTHREAD_COND_INITIALIZER;\n+    signaled = 0;\n+    in_handler = 0;\n@@ -6111,0 +6155,1 @@\n+    frozen = true;\n@@ -6119,1 +6164,1 @@\n-    err = pthread_mutex_lock(&signalled_mutex);\n+    err = pthread_mutex_lock(&signaled_mutex);\n@@ -6121,2 +6166,2 @@\n-    while (signalled < count) {\n-      err = pthread_cond_wait(&signalled_cond, &signalled_mutex);\n+    while (signaled < count) {\n+      err = pthread_cond_wait(&signaled_cond, &signaled_mutex);\n@@ -6125,3 +6170,2 @@\n-    assert(signalled == count, \"JVM: Freeze: signalled == count\");\n-    frozen = true;\n-    err = pthread_mutex_unlock(&signalled_mutex);\n+    assert(signaled == count, \"JVM: Freeze: signaled == count\");\n+    err = pthread_mutex_unlock(&signaled_mutex);\n@@ -6133,1 +6177,14 @@\n-    return true;\n+    return frozen;\n+  }\n+  bool freeze_retried() {\n+    for (int retry = 0; retry < 100; ++retry) {\n+      freeze();\n+      if (frozen)\n+\treturn frozen;\n+      thaw();\n+      if (retry == 0)\n+\ttty->print_cr(\"JVM: Freeze: Some tasks are unsafe to freeze (in glibc), retrying\");\n+      usleep(1000000\/2 + random() % 1000000\/2);\n+    }\n+    tty->print_cr(\"JVM: Freeze: Some tasks failed to freeze (in glibc)\");\n+    return frozen;\n@@ -6136,2 +6193,15 @@\n-    if (!frozen)\n-      return;\n+    while (in_handler) {\n+      int err;\n+      err = pthread_cond_broadcast(&resume_cond);\n+      assert(!err, \"pthread error\");\n+#ifdef _POSIX_PRIORITY_SCHEDULING\n+      err = sched_yield();\n+      assert(!err, \"sched_yield error\");\n+#endif\n+    }\n+  }\n+  Freeze() {\n+#ifdef ASSERT\n+    assert(!singleton, \"singleton safety\");\n+    singleton = true;\n+#endif\n@@ -6139,3 +6209,0 @@\n-    int err;\n-    err = pthread_cond_broadcast(&resume_cond);\n-    assert(!err, \"pthread error\");\n@@ -6144,1 +6211,6 @@\n-    thaw();\n+    if (frozen)\n+      thaw();\n+#ifdef ASSERT\n+    assert(singleton, \"singleton safety\");\n+    singleton = false;\n+#endif\n@@ -6147,3 +6219,3 @@\n-pthread_mutex_t Freeze::signalled_mutex;\n-pthread_cond_t Freeze::signalled_cond;\n-size_t Freeze::signalled;\n+pthread_mutex_t Freeze::signaled_mutex;\n+pthread_cond_t Freeze::signaled_cond;\n+size_t Freeze::signaled, Freeze::in_handler;\n@@ -6151,0 +6223,4 @@\n+bool Freeze::frozen;\n+#ifdef ASSERT\n+bool Freeze::singleton = false;\n+#endif\n@@ -6158,1 +6234,1 @@\n-  if (!freeze.freeze()) {\n+  if (!freeze.freeze_retried()) {\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":108,"deletions":32,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -663,0 +663,2 @@\n+  if (*unsigned_p == ul)\n+    return;\n","filename":"src\/hotspot\/os\/linux\/os_linux_ifunc.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}