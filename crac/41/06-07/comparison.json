{"files":[{"patch":"@@ -646,1 +646,1 @@\n-void os::Linux::initialize_system_info() {\n+void os::Linux::initialize_processor_count() {\n@@ -648,0 +648,5 @@\n+  assert(processor_count() > 0, \"linux error\");\n+}\n+\n+void os::Linux::initialize_system_info() {\n+  initialize_processor_count();\n@@ -660,1 +665,0 @@\n-  assert(processor_count() > 0, \"linux error\");\n@@ -6025,1 +6029,220 @@\n-static int checkpoint_restore(int *shmid) {\n+class Freeze {\n+  static const int signo = SIGUSR1;\n+  struct sigaction act_old;\n+\n+  template<class Callback> bool all_threads(Callback callback) const {\n+    const char dirname[] = \"\/proc\/self\/task\";\n+    GrowableArray<pid_t> done;\n+    bool retry;\n+    do {\n+      retry = false;\n+      DIR *dir = opendir(dirname);\n+      if (dir == NULL) {\n+        tty->print_cr(\"JVM: Error opening %s: %m\", dirname);\n+        return false;\n+      }\n+      pid_t tid = gettid();\n+      struct dirent *ent;\n+      while (errno = 0, ent = readdir(dir)) {\n+        const char *name = ent->d_name;\n+        if (strcmp(name, \".\") == 0)\n+          continue;\n+        if (strcmp(name, \"..\") == 0)\n+          continue;\n+        char *endptr;\n+        unsigned long ul = strtoul(name, &endptr, 10);\n+        pid_t ent_tid = ul;\n+        if (ul >= LONG_MAX || ent_tid != (long) ul) {\n+          tty->print_cr(\"JVM: Error parsing %s entry \\\"%s\\\"\", dirname, name);\n+          return false;\n+        }\n+        if (ent_tid == tid)\n+          continue;\n+        if (!done.append_if_missing(ent_tid))\n+          continue;\n+        retry = true;\n+        callback(ent_tid);\n+      }\n+      if (errno) {\n+        tty->print_cr(\"JVM: Error reading %s: %m\", dirname);\n+        return false;\n+      }\n+      if (closedir(dir)) {\n+        tty->print_cr(\"JVM: Error closing %s: %m\", dirname);\n+        return false;\n+      }\n+    } while (retry);\n+    return true;\n+  }\n+  static pthread_mutex_t signaled_and_in_handler_mutex; \/\/ protect both 'signaled' and 'in_handler'\n+  static pthread_cond_t signaled_cond;\n+  static size_t signaled, in_handler;\n+  static pthread_cond_t resume_cond;\n+#ifdef __x86_64__\n+  __attribute__((noinline, noclone)) static bool caller_is_unsafe() {\n+    \/\/ [0] is ourselves, [1] is handler(), [2] is signal frame, [3] is a signal-interrupted code.\n+    const size_t bt_size = 4;\n+    void *bt[bt_size];\n+    if (backtrace(bt, bt_size) != bt_size) {\n+      tty->print_cr(\"JVM: Freeze: TID %d backtrace(%zu) failed\\n\", (int)gettid(), bt_size);\n+      return false;\n+    }\n+    const void *code = bt[bt_size - 1];\n+    Dl_info info;\n+    if (!dladdr(code, &info)) {\n+      \/\/ Signal-interrupted code is not in a shared library.\n+      return false;\n+    }\n+    const char *cs = strrchr(info.dli_fname, '\/');\n+    if (!cs || strcmp(cs + 1, \"libc.so.6\") != 0) {\n+      \/\/ Signal-interrupted code is not in glibc.\n+      return false;\n+    }\n+    const uint16_t *syscall = ((const uint16_t *)code) - 1;\n+    \/\/ The check is not absolutely safe as we cannot disasemble backwards.\n+    if (*syscall == 0x050f) {\n+      \/\/ Signal-interrupted code is waiting in syscall.\n+      return false;\n+    }\n+    return true;\n+  }\n+#endif \/\/ __x86_64__\n+  static void handler(int handler_signo) {\n+    assert(handler_signo == signo, \"handler signo\");\n+    int err;\n+    err = pthread_mutex_lock(&signaled_and_in_handler_mutex);\n+    assert(!err, \"pthread error\");\n+    ++signaled;\n+    ++in_handler;\n+    err = pthread_mutex_unlock(&signaled_and_in_handler_mutex);\n+    assert(!err, \"pthread error\");\n+    err = pthread_cond_signal(&signaled_cond);\n+    assert(!err, \"pthread error\");\n+#ifdef __x86_64__\n+    if (caller_is_unsafe()) {\n+      frozen = false;\n+      err = pthread_mutex_lock(&signaled_and_in_handler_mutex);\n+      assert(!err, \"pthread error\");\n+      --in_handler;\n+      err = pthread_mutex_unlock(&signaled_and_in_handler_mutex);\n+      assert(!err, \"pthread error\");\n+      return;\n+    }\n+#endif \/\/ __x86_64__\n+    \/\/ Just wait until thaw() is called. No mutex is needed for that.\n+    pthread_mutex_t unused_mutex = PTHREAD_MUTEX_INITIALIZER;\n+    err = pthread_mutex_lock(&unused_mutex);\n+    assert(!err, \"pthread error\");\n+    err = pthread_cond_wait(&resume_cond, &unused_mutex);\n+    assert(!err, \"pthread error\");\n+    err = pthread_mutex_lock(&signaled_and_in_handler_mutex);\n+    assert(!err, \"pthread error\");\n+    --in_handler;\n+    err = pthread_mutex_unlock(&signaled_and_in_handler_mutex);\n+    assert(!err, \"pthread error\");\n+  }\n+  static bool frozen;\n+#ifdef ASSERT\n+  static bool singleton;\n+#endif\n+\n+public:\n+  bool freeze() {\n+    assert(!frozen, \"double freeze?\");\n+    struct sigaction act;\n+    memset(&act, 0, sizeof(act));\n+    act.sa_handler = handler;\n+    if (sigaction(signo, &act, &act_old)) {\n+      tty->print_cr(\"JVM: Freeze::freeze sigaction(%d): %m\", signo);\n+      return false;\n+    }\n+    assert(act_old.sa_handler == SIG_DFL, \"SIG_DFL for signo\");\n+    signaled_and_in_handler_mutex = PTHREAD_MUTEX_INITIALIZER;\n+    signaled_cond = PTHREAD_COND_INITIALIZER;\n+    signaled = 0;\n+    in_handler = 0;\n+    resume_cond = PTHREAD_COND_INITIALIZER;\n+    size_t count = 0;\n+    frozen = true;\n+    all_threads([&](pid_t ent_tid) {\n+      if (!tgkill(getpid(), ent_tid, signo)) {\n+        ++count;\n+      } else {\n+        tty->print_cr(\"JVM: Error sending signal %d to TID %ld\", signo, (long)ent_tid);\n+      }\n+    });\n+    int err;\n+    err = pthread_mutex_lock(&signaled_and_in_handler_mutex);\n+    assert(!err, \"pthread error\");\n+    while (signaled < count) {\n+      err = pthread_cond_wait(&signaled_cond, &signaled_and_in_handler_mutex);\n+      assert(!err, \"pthread error\");\n+    }\n+    assert(signaled == count, \"JVM: Freeze: signaled == count\");\n+    err = pthread_mutex_unlock(&signaled_and_in_handler_mutex);\n+    assert(!err, \"pthread error\");\n+    if (sigaction(signo, &act_old, NULL)) {\n+      tty->print_cr(\"JVM: Freeze::thaw sigaction(%d): %m\", signo);\n+      return false;\n+    }\n+    return frozen;\n+  }\n+  bool freeze_retried() {\n+    for (int retry = 0; retry < 100; ++retry) {\n+      freeze();\n+      if (frozen)\n+\treturn frozen;\n+      thaw();\n+      if (retry == 0)\n+\ttty->print_cr(\"JVM: Freeze: Some tasks are unsafe to freeze (in glibc), retrying\");\n+      usleep(1000000\/2 + random() % 1000000\/2);\n+    }\n+    tty->print_cr(\"JVM: Freeze: Some tasks failed to freeze (in glibc)\");\n+    return frozen;\n+  }\n+  size_t in_handler_get_locked() {\n+    int err;\n+    err = pthread_mutex_lock(&signaled_and_in_handler_mutex);\n+    assert(!err, \"pthread error\");\n+    size_t retval = in_handler;\n+    err = pthread_mutex_unlock(&signaled_and_in_handler_mutex);\n+    assert(!err, \"pthread error\");\n+    return retval;\n+  }\n+  void thaw() {\n+    while (in_handler_get_locked()) {\n+      int err;\n+      err = pthread_cond_broadcast(&resume_cond);\n+      assert(!err, \"pthread error\");\n+#ifdef _POSIX_PRIORITY_SCHEDULING\n+      err = sched_yield();\n+      assert(!err, \"sched_yield error\");\n+#endif\n+    }\n+  }\n+  Freeze() {\n+#ifdef ASSERT\n+    assert(!singleton, \"singleton safety\");\n+    singleton = true;\n+#endif\n+    frozen = false;\n+  }\n+  ~Freeze() {\n+    if (frozen)\n+      thaw();\n+#ifdef ASSERT\n+    assert(singleton, \"singleton safety\");\n+    singleton = false;\n+#endif\n+  }\n+};\n+pthread_mutex_t Freeze::signaled_and_in_handler_mutex;\n+pthread_cond_t Freeze::signaled_cond;\n+size_t Freeze::signaled, Freeze::in_handler;\n+pthread_cond_t Freeze::resume_cond;\n+bool Freeze::frozen;\n+#ifdef ASSERT\n+bool Freeze::singleton = false;\n+#endif\n+\n+int os::Linux::checkpoint_restore(int *shmid) {\n@@ -6030,0 +6253,5 @@\n+  Freeze freeze;\n+  if (!freeze.freeze_retried()) {\n+    return JVM_CHECKPOINT_ERROR;\n+  }\n+\n@@ -6048,0 +6276,6 @@\n+  initialize_processor_count();\n+  if (_cpu_to_node != NULL)\n+    rebuild_cpu_to_node_map();\n+\n+  freeze.thaw();\n+\n@@ -6331,1 +6565,1 @@\n-    int ret = checkpoint_restore(&shmid);\n+    int ret = os::Linux::checkpoint_restore(&shmid);\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":238,"deletions":4,"binary":false,"changes":242,"status":"modified"},{"patch":"@@ -67,0 +67,1 @@\n+  static void initialize_processor_count();\n@@ -188,0 +189,2 @@\n+  static int checkpoint_restore(int *shmid);\n+\n","filename":"src\/hotspot\/os\/linux\/os_linux.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2329,0 +2329,9 @@\n+.B \\f[CB]\\-XX:CPUFeatures=\\f[R]\\f[I]0xnumber\\f[R]\n+CPU feature set, use -XX:CPUFeatures=0xnumber with -XX:CRaCCheckpointTo when\n+you get an error during -XX:CRaCRestoreFrom on a different machine.\n+\\f[CB]\\-XX:CPUFeatures=native\\f[R] is the default.\n+\\f[CB]\\-XX:CPUFeatures=generic\\f[R] is compatible with any CPU but not as slow\n+as \\f[CB]\\-XX:CPUFeatures=0\\f[R].\n+.RS\n+.RE\n+.TP\n@@ -2610,0 +2619,6 @@\n+.B \\f[CB]\\-XX:+ShowCPUFeatures\\f[R]\n+Show features of this CPU to be possibly used for the\n+\\f[CB]\\-XX:CPUFeatures=0xnumber\\f[R] option.\n+.RS\n+.RE\n+.TP\n","filename":"src\/java.base\/share\/man\/java.1","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"}]}