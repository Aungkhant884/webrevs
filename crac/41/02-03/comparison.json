{"files":[{"patch":"@@ -6025,203 +6025,0 @@\n-class Freeze {\n-  static const int signo = SIGUSR1;\n-  struct sigaction act_old;\n-\n-  template<class Callback> bool all_threads(Callback callback) const {\n-    const char dirname[] = \"\/proc\/self\/task\";\n-    GrowableArray<pid_t> done;\n-    bool retry;\n-    do {\n-      retry = false;\n-      DIR *dir = opendir(dirname);\n-      if (dir == NULL) {\n-        tty->print_cr(\"JVM: Error opening %s: %m\", dirname);\n-        return false;\n-      }\n-      pid_t tid = gettid();\n-      struct dirent *ent;\n-      while (errno = 0, ent = readdir(dir)) {\n-        const char *name = ent->d_name;\n-        if (strcmp(name, \".\") == 0)\n-          continue;\n-        if (strcmp(name, \"..\") == 0)\n-          continue;\n-        char *endptr;\n-        unsigned long ul = strtoul(name, &endptr, 10);\n-        pid_t ent_tid = ul;\n-        if (ul >= LONG_MAX || ent_tid != (long) ul) {\n-          tty->print_cr(\"JVM: Error parsing %s entry \\\"%s\\\"\", dirname, name);\n-          return false;\n-        }\n-        if (ent_tid == tid)\n-          continue;\n-        if (!done.append_if_missing(ent_tid))\n-          continue;\n-        retry = true;\n-        callback(ent_tid);\n-      }\n-      if (errno) {\n-        tty->print_cr(\"JVM: Error reading %s: %m\", dirname);\n-        return false;\n-      }\n-      if (closedir(dir)) {\n-        tty->print_cr(\"JVM: Error closing %s: %m\", dirname);\n-        return false;\n-      }\n-    } while (retry);\n-    return true;\n-  }\n-  static pthread_mutex_t signaled_mutex;\n-  static pthread_cond_t signaled_cond;\n-  \/\/ FIXME: 'in_handler' should be atomic.\n-  static size_t signaled, in_handler;\n-  static pthread_cond_t resume_cond;\n-#ifdef __x86_64__\n-  __attribute__((noinline, noclone)) static bool caller_is_unsafe() {\n-    \/\/ [0] is ourselves, [1] is handler(), [2] is signal frame, [3] is a signal-interrupted code.\n-    const size_t bt_size = 4;\n-    void *bt[bt_size];\n-    if (backtrace(bt, bt_size) != bt_size) {\n-      tty->print_cr(\"JVM: Freeze: TID %d backtrace(%zu) failed\\n\", (int)gettid(), bt_size);\n-      return false;\n-    }\n-    const void *code = bt[bt_size - 1];\n-    Dl_info info;\n-    if (!dladdr(code, &info)) {\n-      \/\/ Signal-interrupted code is not in a shared library.\n-      return false;\n-    }\n-    const char *cs = strrchr(info.dli_fname, '\/');\n-    if (!cs || strcmp(cs + 1, \"libc.so.6\") != 0) {\n-      \/\/ Signal-interrupted code is not in glibc.\n-      return false;\n-    }\n-    const uint16_t *syscall = ((const uint16_t *)code) - 1;\n-    \/\/ The check is not absolutely safe as we cannot disasemble backwards.\n-    if (*syscall == 0x050f) {\n-      \/\/ Signal-interrupted code is waiting in syscall.\n-      return false;\n-    }\n-    return true;\n-  }\n-#endif \/\/ __x86_64__\n-  static void handler(int handler_signo) {\n-    assert(handler_signo == signo, \"handler signo\");\n-    int err;\n-    err = pthread_mutex_lock(&signaled_mutex);\n-    assert(!err, \"pthread error\");\n-    ++signaled;\n-    ++in_handler;\n-    err = pthread_mutex_unlock(&signaled_mutex);\n-    assert(!err, \"pthread error\");\n-    err = pthread_cond_signal(&signaled_cond);\n-    assert(!err, \"pthread error\");\n-#ifdef __x86_64__\n-    if (caller_is_unsafe()) {\n-      frozen = false;\n-      --in_handler;\n-      return;\n-    }\n-#endif \/\/ __x86_64__\n-    \/\/ Just wait until thaw() is called. No mutex is needed for that.\n-    pthread_mutex_t unused_mutex = PTHREAD_MUTEX_INITIALIZER;\n-    err = pthread_mutex_lock(&unused_mutex);\n-    assert(!err, \"pthread error\");\n-    err = pthread_cond_wait(&resume_cond, &unused_mutex);\n-    assert(!err, \"pthread error\");\n-    --in_handler;\n-  }\n-  static bool frozen;\n-#ifdef ASSERT\n-  static bool singleton;\n-#endif\n-\n-public:\n-  bool freeze() {\n-    assert(!frozen, \"double freeze?\");\n-    struct sigaction act;\n-    memset(&act, 0, sizeof(act));\n-    act.sa_handler = handler;\n-    if (sigaction(signo, &act, &act_old)) {\n-      tty->print_cr(\"JVM: Freeze::freeze sigaction(%d): %m\", signo);\n-      return false;\n-    }\n-    assert(act_old.sa_handler == SIG_DFL, \"SIG_DFL for signo\");\n-    signaled_mutex = PTHREAD_MUTEX_INITIALIZER;\n-    signaled_cond = PTHREAD_COND_INITIALIZER;\n-    signaled = 0;\n-    in_handler = 0;\n-    resume_cond = PTHREAD_COND_INITIALIZER;\n-    size_t count = 0;\n-    frozen = true;\n-    all_threads([&](pid_t ent_tid) {\n-      if (!tgkill(getpid(), ent_tid, signo)) {\n-        ++count;\n-      } else {\n-        tty->print_cr(\"JVM: Error sending signal %d to TID %ld\", signo, (long)ent_tid);\n-      }\n-    });\n-    int err;\n-    err = pthread_mutex_lock(&signaled_mutex);\n-    assert(!err, \"pthread error\");\n-    while (signaled < count) {\n-      err = pthread_cond_wait(&signaled_cond, &signaled_mutex);\n-      assert(!err, \"pthread error\");\n-    }\n-    assert(signaled == count, \"JVM: Freeze: signaled == count\");\n-    err = pthread_mutex_unlock(&signaled_mutex);\n-    assert(!err, \"pthread error\");\n-    if (sigaction(signo, &act_old, NULL)) {\n-      tty->print_cr(\"JVM: Freeze::thaw sigaction(%d): %m\", signo);\n-      return false;\n-    }\n-    return frozen;\n-  }\n-  bool freeze_retried() {\n-    for (int retry = 0; retry < 100; ++retry) {\n-      freeze();\n-      if (frozen)\n-\treturn frozen;\n-      thaw();\n-      if (retry == 0)\n-\ttty->print_cr(\"JVM: Freeze: Some tasks are unsafe to freeze (in glibc), retrying\");\n-      usleep(1000000\/2 + random() % 1000000\/2);\n-    }\n-    tty->print_cr(\"JVM: Freeze: Some tasks failed to freeze (in glibc)\");\n-    return frozen;\n-  }\n-  void thaw() {\n-    while (in_handler) {\n-      int err;\n-      err = pthread_cond_broadcast(&resume_cond);\n-      assert(!err, \"pthread error\");\n-#ifdef _POSIX_PRIORITY_SCHEDULING\n-      err = sched_yield();\n-      assert(!err, \"sched_yield error\");\n-#endif\n-    }\n-  }\n-  Freeze() {\n-#ifdef ASSERT\n-    assert(!singleton, \"singleton safety\");\n-    singleton = true;\n-#endif\n-    frozen = false;\n-  }\n-  ~Freeze() {\n-    if (frozen)\n-      thaw();\n-#ifdef ASSERT\n-    assert(singleton, \"singleton safety\");\n-    singleton = false;\n-#endif\n-  }\n-};\n-pthread_mutex_t Freeze::signaled_mutex;\n-pthread_cond_t Freeze::signaled_cond;\n-size_t Freeze::signaled, Freeze::in_handler;\n-pthread_cond_t Freeze::resume_cond;\n-bool Freeze::frozen;\n-#ifdef ASSERT\n-bool Freeze::singleton = false;\n-#endif\n-\n@@ -6233,5 +6030,0 @@\n-  Freeze freeze;\n-  if (!freeze.freeze_retried()) {\n-    return JVM_CHECKPOINT_ERROR;\n-  }\n-\n@@ -6256,2 +6048,0 @@\n-  freeze.thaw();\n-\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":0,"deletions":210,"binary":false,"changes":210,"status":"modified"}]}