{"files":[{"patch":"@@ -50,0 +50,1 @@\n+    cpu_feature_active ld_so_list_diagnostics \\\n@@ -383,0 +384,136 @@\n+###############################################################################\n+# Check if glibc CPU_FEATURE_ACTIVE is available on this platform.\n+#\n+AC_DEFUN_ONCE([JVM_FEATURES_CHECK_CPU_FEATURE_ACTIVE],\n+[\n+  JVM_FEATURES_CHECK_AVAILABILITY(cpu_feature_active, [\n+    AC_MSG_CHECKING([if glibc CPU_FEATURE_ACTIVE is supported])\n+    AC_COMPILE_IFELSE(\n+      [AC_LANG_PROGRAM([[#include <sys\/platform\/x86.h>]],\n+        [[int x = CPU_FEATURE_ACTIVE(SSE2);]])\n+      ],\n+      [\n+        AC_MSG_RESULT([yes])\n+      ],\n+      [\n+        AC_MSG_RESULT([no])\n+        AVAILABLE=false\n+      ]\n+    )\n+  ])\n+])\n+\n+###############################################################################\n+# Check if glibc ld.so --list-diagnostics is available on this platform.\n+#\n+AC_DEFUN_ONCE([JVM_FEATURES_CHECK_LD_SO_LIST_DIAGNOSTICS],\n+[\n+  JVM_FEATURES_CHECK_AVAILABILITY(ld_so_list_diagnostics, [\n+    AC_MSG_CHECKING([if glibc ld.so --list-diagnostics is supported])\n+    AC_RUN_IFELSE(\n+      [AC_LANG_SOURCE([[\n+#define _GNU_SOURCE 1\n+#include <link.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <stddef.h>\n+#include <string.h>\n+#include <limits.h>\n+static int ld_so_name_iterate_phdr(struct dl_phdr_info *info, size_t size, void *data_voidp) {\n+  const char **retval_return = (const char **)data_voidp;\n+  if (size < offsetof(struct dl_phdr_info, dlpi_adds)) {\n+    fputs(\"missing PHDRs\\n\", stderr);\n+    exit(1);\n+  }\n+  if (strcmp(info->dlpi_name, \"\") != 0) {\n+    fprintf(stderr, \"Unexpected name of first dl_phdr_info: %s\\n\", info->dlpi_name);\n+    exit(1);\n+  }\n+  for (size_t phdr_ix = 0; phdr_ix < info->dlpi_phnum; ++phdr_ix) {\n+    const Elf64_Phdr *phdr = info->dlpi_phdr + phdr_ix;\n+    if (phdr->p_type == PT_INTERP) {\n+      *retval_return = (const char *)(phdr->p_vaddr + info->dlpi_addr);\n+      return 42;\n+    }\n+  }\n+  exit(1);\n+}\n+static const char *ld_so_name() {\n+  const char *retval;\n+  int err = dl_iterate_phdr(ld_so_name_iterate_phdr, &retval);\n+  if (err != 42)\n+    exit(1);\n+  return retval;\n+}\n+int main(void) {\n+  char cmd[PATH_MAX + 100];\n+  int got = snprintf(cmd, sizeof(cmd), \"%s --list-diagnostics\", ld_so_name());\n+  if (got < 0) {\n+    fprintf(stderr, \"snprintf error: %m\\n\");\n+  }\n+  if ((unsigned) got == sizeof(cmd)) {\n+    fputs(\"internal error - buffer overflow\\n\", stderr);\n+    exit(1);\n+  }\n+  FILE *f = popen(cmd, \"r\");\n+  if (!f) {\n+    fprintf(stderr, \"popen('%s'): %m\\n\", cmd);\n+    exit(1);\n+  }\n+  char line[LINE_MAX];\n+  int found = 0;\n+  const char prefix[] = \"x86.cpu_features.features\";\n+  for (;;) {\n+    char *s = fgets(line, sizeof(line), f);\n+    if (!s) break;\n+    if (s != line) {\n+      fprintf(stderr, \"fgets(popen('%s')) did not return buffer address\\n\", cmd);\n+      exit(1);\n+    }\n+    if (strstr(line, prefix))\n+      found = 1;\n+  }\n+  if (ferror(f)) {\n+    fprintf(stderr, \"ferror(popen('%s'))\\n\", cmd);\n+    exit(1);\n+  }\n+  if (!feof(f)) {\n+    fprintf(stderr, \"!feof(popen('%s'))\\n\", cmd);\n+    exit(1);\n+  }\n+  int wstatus = pclose(f);\n+  if (wstatus == -1) {\n+    fprintf(stderr, \"pclose('%s'): %m\\n\", cmd);\n+    exit(1);\n+  }\n+  if (!WIFEXITED(wstatus)) {\n+    fprintf(stderr, \"Child command '%s' did not properly exit (WIFEXITED): wstatus = %d\\n\", cmd, wstatus);\n+    exit(1);\n+  }\n+  if (WEXITSTATUS(wstatus) != 0) {\n+    fprintf(stderr, \"Child command '%s' did exit with an error: exit code = %d\\n\", cmd, WEXITSTATUS(wstatus));\n+    exit(1);\n+  }\n+  if (!found) {\n+    fprintf(stderr, \"Not found in '%s' output: %s\\n\", cmd, prefix);\n+    exit(1);\n+  }\n+  return 0;\n+}\n+\t]])\n+      ],\n+      [\n+        AC_MSG_RESULT([yes])\n+      ],\n+      [\n+        AC_MSG_RESULT([no])\n+        AVAILABLE=false\n+      ],\n+      [\n+        AC_MSG_RESULT([assumed no - cross compiling])\n+        AVAILABLE=false\n+      ]\n+    )\n+  ])\n+])\n+\n@@ -400,0 +537,2 @@\n+  JVM_FEATURES_CHECK_CPU_FEATURE_ACTIVE\n+  JVM_FEATURES_CHECK_LD_SO_LIST_DIAGNOSTICS\n","filename":"make\/autoconf\/jvm-features.m4","additions":139,"deletions":0,"binary":false,"changes":139,"status":"modified"},{"patch":"@@ -157,0 +157,7 @@\n+ifneq ($(call check-jvm-feature, cpu_feature_active), true)\n+  JVM_CFLAGS_FEATURES += -DINCLUDE_CPU_FEATURE_ACTIVE=0\n+endif\n+ifneq ($(call check-jvm-feature, ld_so_list_diagnostics), true)\n+  JVM_CFLAGS_FEATURES += -DINCLUDE_LD_SO_LIST_DIAGNOSTICS=0\n+endif\n+\n","filename":"make\/hotspot\/lib\/JvmFeatures.gmk","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -149,0 +149,3 @@\n+\n+  \/\/ No _features_names[] available on this CPU.\n+  static void insert_features_names(char* buf, size_t buflen, uint64_t features = _features) {}\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -132,0 +132,3 @@\n+  \/\/ No _features_names[] available on this CPU.\n+  static void insert_features_names(char* buf, size_t buflen, uint64_t features = _features) {}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/vm_version_ppc.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -536,0 +536,3 @@\n+\n+  \/\/ No _features_names[] available on this CPU.\n+  static void insert_features_names(char* buf, size_t buflen, uint64_t features = _features) {}\n","filename":"src\/hotspot\/cpu\/s390\/vm_version_s390.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -223,1 +223,10 @@\n-             \"mitigations for the Intel JCC erratum\")\n+             \"mitigations for the Intel JCC erratum\")                       \\\n+                                                                            \\\n+  product(ccstr, CPUFeatures, NULL, \"CPU feature set, \"                     \\\n+      \"use -XX:CPUFeatures=0xnumber with -XX:CRaCCheckpointTo when you \"    \\\n+      \"get an error during -XX:CRaCRestoreFrom on a different machine; \"    \\\n+      \"-XX:CPUFeatures=native is the default; \"                             \\\n+      \"-XX:CPUFeatures=generic is compatible but not as slow as 0\")         \\\n+                                                                            \\\n+  product(bool, ShowCPUFeatures, false, \"Show features of this CPU \"        \\\n+      \"to be possibly used for the -XX:CPUFeatures=0xnumber option\")\n","filename":"src\/hotspot\/cpu\/x86\/globals_x86.hpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -40,0 +40,7 @@\n+#if INCLUDE_CPU_FEATURE_ACTIVE\n+# include <sys\/platform\/x86.h>\n+#endif\n+#if INCLUDE_LD_SO_LIST_DIAGNOSTICS\n+# include <link.h>\n+# include <sys\/wait.h>\n+#endif\n@@ -48,0 +55,1 @@\n+uint64_t VM_Version::_glibc_features;\n@@ -50,1 +58,2 @@\n-const char* VM_Version::_features_names[] = { CPU_FEATURE_FLAGS(DECLARE_CPU_FEATURE_NAME)};\n+const char* VM_Version::      _features_names[] = {   CPU_FEATURE_FLAGS(DECLARE_CPU_FEATURE_NAME)};\n+const char* VM_Version::_glibc_features_names[] = { GLIBC_FEATURE_FLAGS(DECLARE_CPU_FEATURE_NAME)};\n@@ -618,0 +627,596 @@\n+uint64_t VM_Version::CPUFeatures_parse(const char *ccstr, uint64_t &glibc_features) {\n+  assert(ccstr, \"CPUFeatures_parse NULL\");\n+  glibc_features = 0;\n+  if (strcmp(ccstr, \"native\") == 0) {\n+    return Abstract_VM_Version::features();\n+  }\n+  if (strcmp(ccstr, \"generic\") == 0) {\n+    \/\/ 32-bit x86 cannot rely on anything.\n+    return 0\n+#ifdef AMD64\n+      \/\/ The following options are all in \/proc\/cpuinfo of one of the first 64-bit CPUs - Atom D2700 (and Opteron 1352): https:\/\/superuser.com\/q\/1572306\/1015048\n+      | CPU_SSE \/\/ enabled in 'gcc -Q --help=target', used by OpenJDK\n+      | CPU_SSE2 \/\/ enabled in 'gcc -Q --help=target', required by OpenJDK\n+      | CPU_FXSR \/\/ enabled in 'gcc -Q --help=target', not used by OpenJDK\n+      | CPU_MMX \/\/ enabled in 'gcc -Q --help=target', used only by 32-bit x86 OpenJDK\n+      | CPU_TSC \/\/ not used by gcc, used by OpenJDK\n+      | CPU_CX8 \/\/ gcc detects it to set cpu \"pentium\" (=32-bit only), used by OpenJDK\n+      | CPU_CMOV \/\/ gcc detects it to set cpu \"pentiumpro\" (=32-bit only), used by OpenJDK\n+      | CPU_FLUSH \/\/ =\"clflush\" in cpuinfo, not used by gcc, required by OpenJDK\n+      \/\/ GLIBC_MOVBE is disabled in 'gcc -Q --help=target' and some CPUs do not support it: https:\/\/stackoverflow.com\/a\/5246553\/2995591\n+      \/\/ GLIBC_LAHFSAHF is disabled in 'gcc -Q --help=target' and \"Early Intel Pentium 4 CPUs with Intel 64 support ... lacked the LAHF and SAHF instructions\"\n+#endif\n+    ;\n+  }\n+  char *endptr;\n+  errno = 0;\n+  uint64_t retval;\n+  unsigned long long ull = strtoull(ccstr, &endptr, 0);\n+  retval = ull;\n+  if (!errno && *endptr == ',' && retval == ull) {\n+    ull = strtoull(endptr + 1, &endptr, 0);\n+    glibc_features = ull;\n+    if (!errno && !*endptr && glibc_features == ull) {\n+      return retval;\n+    }\n+  }\n+  char buf[512];\n+  int res = jio_snprintf(\n+              buf, sizeof(buf),\n+              \"VM option 'CPUFeatures=%s' must be of the form: 0xnum,0xnum\", ccstr);\n+  assert(res > 0, \"not enough temporary space allocated\");\n+  vm_exit_during_initialization(buf);\n+  return -1;\n+}\n+\n+#if INCLUDE_LD_SO_LIST_DIAGNOSTICS\n+\n+static int ld_so_name_iterate_phdr(struct dl_phdr_info *info, size_t size, void *data_voidp) {\n+  const char **retval_return = (const char **)data_voidp;\n+  assert(size >= offsetof(struct dl_phdr_info, dlpi_adds), \"missing PHDRs for the java executable\");\n+  if (strcmp(info->dlpi_name, \"\") != 0) {\n+    char errbuf[512];\n+    jio_snprintf(errbuf, sizeof(errbuf), \"Unexpected name of first dl_phdr_info: %s\", info->dlpi_name);\n+    vm_exit_during_initialization(errbuf);\n+  }\n+  for (size_t phdr_ix = 0; phdr_ix < info->dlpi_phnum; ++phdr_ix) {\n+    const Elf64_Phdr *phdr = info->dlpi_phdr + phdr_ix;\n+    if (phdr->p_type == PT_INTERP) {\n+      *retval_return = (const char *)(phdr->p_vaddr + info->dlpi_addr);\n+      return 42;\n+    }\n+  }\n+  vm_exit_during_initialization(\"PT_INTERP not found for the java executable\");\n+  return -1;\n+}\n+\n+static const char *ld_so_name() {\n+  const char *retval;\n+  int err = dl_iterate_phdr(ld_so_name_iterate_phdr, &retval);\n+  assert(err == 42, \"internal error 42\");\n+  return retval;\n+}\n+\n+#define ARG1 \"--list-diagnostics\"\n+\n+static FILE *popen_r(const char *arg0, pid_t *pid_return) {\n+  char errbuf[512];\n+  union {\n+    int fds[2];\n+    struct {\n+      int readfd, writefd;\n+    };\n+  } fds;\n+  if (pipe(fds.fds)) {\n+    jio_snprintf(errbuf, sizeof(errbuf), \"Error creating pipe: %m\");\n+    vm_exit_during_initialization(errbuf);\n+  }\n+  pid_t child = fork();\n+  switch (child) {\n+    case -1:\n+      jio_snprintf(errbuf, sizeof(errbuf), \"Error fork-ing: %m\");\n+      vm_exit_during_initialization(errbuf);\n+    case 0:\n+      if (close(fds.readfd)) {\n+        jio_snprintf(errbuf, sizeof(errbuf), \"Error closing read pipe in child: %m\");\n+        vm_exit_during_initialization(errbuf);\n+      }\n+      if (dup2(fds.writefd, STDOUT_FILENO) != STDOUT_FILENO) {\n+        jio_snprintf(errbuf, sizeof(errbuf), \"Error closing preparing write pipe in child: %m\");\n+        vm_exit_during_initialization(errbuf);\n+      }\n+      if (close(fds.writefd)) {\n+        jio_snprintf(errbuf, sizeof(errbuf), \"Error closing write pipe in child: %m\");\n+        vm_exit_during_initialization(errbuf);\n+      }\n+      execl(arg0, arg0, ARG1, NULL);\n+      jio_snprintf(errbuf, sizeof(errbuf), \"Error exec-ing %s \" ARG1 \": %m\", arg0);\n+      \/\/ FIXME: Double vm_exit*()?\n+      vm_exit_during_initialization(errbuf);\n+  }\n+  if (close(fds.writefd)) {\n+    jio_snprintf(errbuf, sizeof(errbuf), \"Error closing write pipe in parent: %m\");\n+    vm_exit_during_initialization(errbuf);\n+  }\n+  FILE *f = fdopen(fds.readfd, \"r\");\n+  if (f == NULL) {\n+    jio_snprintf(errbuf, sizeof(errbuf), \"Error converting pipe fd to FILE * in parent for %s \" ARG1 \": %m\", arg0);\n+    vm_exit_during_initialization(errbuf);\n+  }\n+  *pid_return = child;\n+  return f;\n+}\n+\n+static void pclose_r(const char *arg0, FILE *f, pid_t pid) {\n+  char errbuf[512];\n+  if (fclose(f)) {\n+    jio_snprintf(errbuf, sizeof(errbuf), \"Error closing fdopen-ed %s \" ARG1 \": %m\", arg0);\n+    vm_exit_during_initialization(errbuf);\n+  }\n+  int wstatus;\n+  pid_t waiterr = waitpid(pid, &wstatus, 0);\n+  if (waiterr != pid) {\n+    jio_snprintf(errbuf, sizeof(errbuf), \"Error waiting on %s \" ARG1 \": %m\", arg0);\n+    vm_exit_during_initialization(errbuf);\n+  }\n+  if (!WIFEXITED(wstatus)) {\n+    jio_snprintf(errbuf, sizeof(errbuf), \"Child command %s \" ARG1 \" did not properly exit (WIFEXITED): wstatus = %d\", arg0, wstatus);\n+    vm_exit_during_initialization(errbuf);\n+  }\n+  if (WEXITSTATUS(wstatus) != 0) {\n+    jio_snprintf(errbuf, sizeof(errbuf), \"Child command %s \" ARG1 \" did exit with an error: exit code = %d\", arg0, WEXITSTATUS(wstatus));\n+    vm_exit_during_initialization(errbuf);\n+  }\n+}\n+\n+#endif \/\/ !INCLUDE_LD_SO_LIST_DIAGNOSTICS\n+\n+void VM_Version::glibc_not_using(uint64_t excessive_CPU, uint64_t excessive_GLIBC) {\n+#define TUNABLES_NAME \"GLIBC_TUNABLES\"\n+#if INCLUDE_CPU_FEATURE_ACTIVE || INCLUDE_LD_SO_LIST_DIAGNOSTICS\n+\n+#ifndef ASSERT\n+  if (!excessive_CPU && !excessive_GLIBC)\n+    return;\n+#endif\n+  char errbuf[512];\n+#if INCLUDE_LD_SO_LIST_DIAGNOSTICS\n+  \/\/ sysdeps\/x86\/include\/cpu-features.h CPUID_INDEX_14_ECX_0 == 8\n+  const int CPUID_INDEX_CEIL = 8;\n+  \/\/ \/usr\/include\/bits\/platform\/x86.h\n+  enum\n+  {\n+    CPUID_INDEX_1 = 0,\n+    CPUID_INDEX_7,\n+    CPUID_INDEX_80000001,\n+    CPUID_INDEX_D_ECX_1,\n+    CPUID_INDEX_80000007,\n+    CPUID_INDEX_80000008,\n+    CPUID_INDEX_7_ECX_1,\n+    CPUID_INDEX_19,\n+    CPUID_INDEX_14_ECX_0\n+  };\n+  const int index_max = CPUID_INDEX_CEIL + 1;\n+  enum { eax = 0, ebx, ecx, edx, reg_max };\n+  unsigned active[index_max][reg_max] = { 0 };\n+  const char *arg0 = ld_so_name();\n+  pid_t f_child;\n+  FILE *f = popen_r(arg0, &f_child);\n+  if (!f) {\n+    jio_snprintf(errbuf, sizeof(errbuf), \"Cannot popen %s \" ARG1 \": %m\", arg0);\n+    vm_exit_during_initialization(errbuf);\n+  }\n+  for (;;) {\n+    char line[LINE_MAX];\n+    char *s = fgets(line, sizeof(line), f);\n+    if (!s)\n+      break;\n+    s = line;\n+    \/\/ x86.cpu_features.features[0x0].active[0x2]=0x7ed83203\n+    const char prefix[] = \"x86.cpu_features.features[\";\n+    if (strncmp(s, prefix, sizeof(prefix) - 1) != 0)\n+      continue;\n+    s += sizeof(prefix) - 1;\n+    unsigned long index = strtoul(s, &s, 0);\n+    if (index >= index_max)\n+      continue;\n+    const char mid[] = \"].active[\";\n+    if (strncmp(s, mid, sizeof(mid) - 1) != 0)\n+      continue;\n+    s += sizeof(mid) - 1;\n+    unsigned long reg = strtoul(s, &s, 0);\n+    if (reg >= reg_max)\n+      continue;\n+    if (s[0] != ']' || s[1] != '=')\n+      continue;\n+    s += 2;\n+    unsigned long val = strtoul(s, &s, 0);\n+    if (val > UINT_MAX)\n+      continue;\n+    if (s[0] != '\\n' || s[1] != 0)\n+      continue;\n+    active[index][reg] = val;\n+  }\n+  if (ferror(f)) {\n+    jio_snprintf(errbuf, sizeof(errbuf), \"Error reading popen-ed %s \" ARG1 \": %m\", arg0);\n+    vm_exit_during_initialization(errbuf);\n+  }\n+  if (!feof(f)) {\n+    jio_snprintf(errbuf, sizeof(errbuf), \"EOF not reached on popen-ed %s \" ARG1, arg0);\n+    vm_exit_during_initialization(errbuf);\n+  }\n+  pclose_r(arg0, f, f_child);\n+#undef ARG1\n+#endif \/\/ INCLUDE_LD_SO_LIST_DIAGNOSTICS\n+\n+  \/\/ glibc: sysdeps\/x86\/get-isa-level.h:\n+  \/\/ glibc: if (CPU_FEATURE_USABLE_P (cpu_features, CMOV)\n+  \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, CX8)\n+  \/\/ glibc:     && CPU_FEATURE_CPU_P (cpu_features, FPU)\n+  \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, FXSR)\n+  \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, MMX)\n+  \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, SSE)\n+  \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, SSE2))\n+  \/\/ glibc:     isa_level = GNU_PROPERTY_X86_ISA_1_BASELINE;\n+  if ((_features & CPU_CMOV) &&\n+      (_features & CPU_CX8) &&\n+      \/\/ FPU is always present on i686+: (_features & CPU_FPU) &&\n+      (_features & CPU_SSE2))\n+    \/\/ These cannot be disabled by GLIBC_TUNABLES.\n+    if (excessive_CPU & (CPU_FXSR | CPU_MMX | CPU_SSE)) {\n+      assert(!(excessive_CPU & CPU_SSE2), \"CPU_SSE2 in both _features and excessive_CPU cannot happen\");\n+      \/\/ FIXME: The choice should be based on glibc impact, not the feature age.\n+      \/\/ CX8 is i586+, CMOV is i686+ 1995+, SSE2 is 2000+\n+      excessive_CPU |= CPU_SSE2;\n+    }\n+    if ((_features & CPU_FXSR) &&\n+        (_features & CPU_MMX) &&\n+        (_features & CPU_SSE)) {\n+      \/\/ glibc: if (CPU_FEATURE_USABLE_P (cpu_features, CMPXCHG16B)\n+      \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, LAHF64_SAHF64)\n+      \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, POPCNT)\n+      \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, SSE3)\n+      \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, SSSE3)\n+      \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, SSE4_1)\n+      \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, SSE4_2))\n+      \/\/ glibc:     isa_level |= GNU_PROPERTY_X86_ISA_1_V2;\n+      if ((_features & CPU_POPCNT) &&\n+          (_features & CPU_SSSE3) &&\n+          (_features & CPU_SSE4_1) &&\n+          (_features & CPU_SSE4_2)) {\n+        if ((excessive_CPU & CPU_SSE3) ||\n+            (excessive_GLIBC & (GLIBC_CMPXCHG16 | GLIBC_LAHFSAHF))) {\n+          assert(!(excessive_CPU & CPU_SSE4_2), \"CPU_SSE4_2 in both _features and excessive_CPU cannot happen\");\n+          \/\/ POPCNT is 2007+, SSSE3 is 2006+, SSE4_1 is 2007+, SSE4_2 is 2008+.\n+          excessive_CPU |= CPU_SSE4_2;\n+        }\n+        if ((_features & CPU_SSE3) &&\n+            (_glibc_features & GLIBC_CMPXCHG16) &&\n+            (_glibc_features & GLIBC_LAHFSAHF)) {\n+          \/\/ glibc: if (CPU_FEATURE_USABLE_P (cpu_features, AVX)\n+          \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, AVX2)\n+          \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, BMI1)\n+          \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, BMI2)\n+          \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, F16C)\n+          \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, FMA)\n+          \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, LZCNT)\n+          \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, MOVBE))\n+          \/\/ glibc:     isa_level |= GNU_PROPERTY_X86_ISA_1_V3;\n+          if ((_features & CPU_AVX) &&\n+              (_features & CPU_AVX2) &&\n+              (_features & CPU_BMI1) &&\n+              (_features & CPU_BMI2) &&\n+              (_features & CPU_FMA) &&\n+              (_features & CPU_LZCNT) &&\n+              (_glibc_features & GLIBC_MOVBE)) {\n+          if (excessive_GLIBC & GLIBC_F16C) {\n+            assert(!(excessive_GLIBC & GLIBC_MOVBE), \"GLIBC_MOVBE in both _glibc_features and excessive_GLIBC cannot happen\");\n+            \/\/ FMA is 2012+, AVX2+BMI1+BMI2+LZCNT are 2013+, MOVBE is 2015+\n+            excessive_GLIBC |= GLIBC_MOVBE;\n+          }\n+          if (_glibc_features & GLIBC_F16C) {\n+            \/\/ glibc: if (CPU_FEATURE_USABLE_P (cpu_features, AVX512F)\n+            \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, AVX512BW)\n+            \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, AVX512CD)\n+            \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, AVX512DQ)\n+            \/\/ glibc:     && CPU_FEATURE_USABLE_P (cpu_features, AVX512VL))\n+            \/\/ glibc:   isa_level |= GNU_PROPERTY_X86_ISA_1_V4;\n+            \/\/ All these flags are supported by GLIBC_DISABLE below.\n+          }\n+        }\n+      }\n+    }\n+  }\n+  uint64_t disable_CPU   = 0;\n+  uint64_t disable_GLIBC = 0;\n+#define PASTE_TOKENS3(x, y, z) PASTE_TOKENS(x, PASTE_TOKENS(y, z))\n+#ifdef ASSERT\n+  uint64_t excessive_handled_CPU   = 0;\n+  uint64_t excessive_handled_GLIBC = 0;\n+  uint64_t disable_handled_CPU   = 0;\n+  uint64_t disable_handled_GLIBC = 0;\n+#endif\n+#define EXCESSIVE_HANDLED(kind, hotspot) do {                                                                                         \\\n+    assert(!(PASTE_TOKENS(excessive_handled_, kind) & PASTE_TOKENS3(kind, _, hotspot)), \"already used \" STR(kind) \"_\" STR(hotspot) ); \\\n+    DEBUG_ONLY(PASTE_TOKENS(excessive_handled_, kind) |= PASTE_TOKENS3(kind, _, hotspot));                                            \\\n+  } while (0)\n+#if INCLUDE_CPU_FEATURE_ACTIVE\n+# define FEATURE_ACTIVE(glibc, hotspot_field, hotspot_union, glibc_index, glibc_reg) CPU_FEATURE_ACTIVE(glibc)\n+#endif\n+#if INCLUDE_LD_SO_LIST_DIAGNOSTICS\n+# define FEATURE_ACTIVE(glibc, hotspot_field, hotspot_union, glibc_index, glibc_reg) ({ \\\n+    hotspot_union u;                                      \\\n+    u.value = active[glibc_index][glibc_reg];             \\\n+    u.bits.hotspot_field != 0;                            \\\n+  })\n+#endif\n+#define EXCESSIVE7(kind, hotspot, glibc, hotspot_field, hotspot_union, glibc_index, glibc_reg) do {                                                        \\\n+    EXCESSIVE_HANDLED(kind, hotspot);                                                                                                                      \\\n+    if (PASTE_TOKENS(excessive_, kind) & PASTE_TOKENS3(kind, _, hotspot) && FEATURE_ACTIVE(glibc, hotspot_field, hotspot_union, glibc_index, glibc_reg)) { \\\n+      PASTE_TOKENS(disable_, kind) |= PASTE_TOKENS3(kind, _, hotspot);                                                                                     \\\n+    }                                                                                                                                                      \\\n+  } while (0)\n+#define EXCESSIVE5(kind, hotspot, glibc, hotspot_field, def...) EXCESSIVE7(kind, hotspot, glibc, hotspot_field, def)\n+#define EXCESSIVE(kind, hotspotglibc, hotspot_union, def...) EXCESSIVE5(kind, hotspotglibc, hotspotglibc, hotspot_union, def)\n+#define DEF_ExtCpuid1Ecx ExtCpuid1Ecx, CPUID_INDEX_80000001, ecx\n+#define DEF_SefCpuid7Ebx SefCpuid7Ebx, CPUID_INDEX_7       , ebx\n+#define DEF_SefCpuid7Ecx SefCpuid7Ecx, CPUID_INDEX_7       , ecx\n+#define DEF_SefCpuid7Edx SefCpuid7Edx, CPUID_INDEX_7       , edx\n+#define DEF_StdCpuid1Ecx StdCpuid1Ecx, CPUID_INDEX_1       , ecx\n+#define DEF_StdCpuid1Edx StdCpuid1Edx, CPUID_INDEX_1       , edx\n+  EXCESSIVE(CPU  , AVX     , avx     , DEF_StdCpuid1Ecx);\n+  EXCESSIVE(CPU  , CX8     , cmpxchg8, DEF_StdCpuid1Edx);\n+  EXCESSIVE(CPU  , FMA     , fma     , DEF_StdCpuid1Ecx);\n+  EXCESSIVE5(CPU , HT, HTT , ht      , DEF_StdCpuid1Edx);\n+  EXCESSIVE(CPU  , RTM     , rtm     , DEF_SefCpuid7Ebx);\n+  EXCESSIVE(CPU  , AVX2    , avx2    , DEF_SefCpuid7Ebx);\n+  EXCESSIVE(CPU  , BMI1    , bmi1    , DEF_SefCpuid7Ebx);\n+  EXCESSIVE(CPU  , BMI2    , bmi2    , DEF_SefCpuid7Ebx);\n+  EXCESSIVE(CPU  , CMOV    , cmov    , DEF_StdCpuid1Edx);\n+  EXCESSIVE(CPU  , ERMS    , erms    , DEF_SefCpuid7Ebx);\n+  EXCESSIVE(CPU  , SSE2    , sse2    , DEF_StdCpuid1Edx);\n+  EXCESSIVE(CPU  , LZCNT   , fma4    , DEF_ExtCpuid1Ecx);\n+  EXCESSIVE(CPU  , SSSE3   , ssse3   , DEF_StdCpuid1Ecx);\n+  EXCESSIVE(CPU  , POPCNT  , popcnt  , DEF_StdCpuid1Ecx);\n+  EXCESSIVE(CPU  , SSE4_1  , sse4_1  , DEF_StdCpuid1Ecx);\n+  EXCESSIVE(CPU  , SSE4_2  , sse4_2  , DEF_StdCpuid1Ecx);\n+  EXCESSIVE(CPU  , AVX512F , avx512f , DEF_SefCpuid7Ebx);\n+  EXCESSIVE(CPU  , AVX512CD, avx512cd, DEF_SefCpuid7Ebx);\n+  EXCESSIVE(CPU  , AVX512BW, avx512bw, DEF_SefCpuid7Ebx);\n+  EXCESSIVE(CPU  , AVX512DQ, avx512dq, DEF_SefCpuid7Ebx);\n+  EXCESSIVE(CPU  , AVX512ER, avx512er, DEF_SefCpuid7Ebx);\n+  EXCESSIVE(CPU  , AVX512PF, avx512pf, DEF_SefCpuid7Ebx);\n+  EXCESSIVE(CPU  , AVX512VL, avx512vl, DEF_SefCpuid7Ebx);\n+  EXCESSIVE(GLIBC, IBT     , ibt     , DEF_SefCpuid7Edx);\n+  EXCESSIVE(GLIBC, FMA4    , fma4    , DEF_ExtCpuid1Ecx);\n+  EXCESSIVE(GLIBC, MOVBE   , movbe   , DEF_StdCpuid1Ecx);\n+  EXCESSIVE(GLIBC, SHSTK   , shstk   , DEF_SefCpuid7Ecx);\n+  EXCESSIVE(GLIBC, XSAVE   , xsave   , DEF_StdCpuid1Ecx);\n+  EXCESSIVE(GLIBC, OSXSAVE , osxsave , DEF_StdCpuid1Ecx);\n+#undef EXCESSIVE\n+#undef EXCESSIVE5\n+\n+#define PREFIX \":glibc.cpu.hwcaps=\"\n+  const char prefix[] = PREFIX;\n+  const size_t prefix_len = sizeof(prefix) - 1;\n+  char disable_str[64 * (10 + 3) + 1] = PREFIX;\n+#undef PREFIX\n+  char *disable_end = disable_str + prefix_len;\n+#define GLIBC_DISABLE2(kind, hotspot, libc) do {                                                                                    \\\n+    assert(!(PASTE_TOKENS(disable_handled_, kind) & PASTE_TOKENS3(kind, _, hotspot)), \"already used \" STR(kind) \"_\" STR(hotspot) ); \\\n+    DEBUG_ONLY(PASTE_TOKENS(disable_handled_, kind) |= PASTE_TOKENS3(kind, _, hotspot));                                            \\\n+    if (PASTE_TOKENS(disable_, kind) & PASTE_TOKENS3(kind, _, hotspot)) {                                                           \\\n+      const char str[] = \",-\" STR(libc);                                                                                            \\\n+      size_t remains = disable_str + sizeof(disable_str) - disable_end;                                                             \\\n+      strncpy(disable_end, str, remains);                                                                                           \\\n+      size_t len = strnlen(disable_end, remains);                                                                                   \\\n+      remains -= len;                                                                                                               \\\n+      assert(remains > 0, \"internal error: disable_str overflow\");                                                                  \\\n+      disable_end += len;                                                                                                           \\\n+    }                                                                                                                               \\\n+  } while (0);\n+#define GLIBC_DISABLE(kind, name) GLIBC_DISABLE2(kind, name, name)\n+  GLIBC_DISABLE2(CPU , HT, HTT)\n+  GLIBC_DISABLE(CPU  , AVX)\n+  GLIBC_DISABLE(CPU  , CX8)\n+  GLIBC_DISABLE(CPU  , FMA)\n+  GLIBC_DISABLE(CPU  , RTM)\n+  GLIBC_DISABLE(CPU  , AVX2)\n+  GLIBC_DISABLE(CPU  , BMI1)\n+  GLIBC_DISABLE(CPU  , BMI2)\n+  GLIBC_DISABLE(CPU  , CMOV)\n+  GLIBC_DISABLE(CPU  , ERMS)\n+  GLIBC_DISABLE(CPU  , SSE2)\n+  GLIBC_DISABLE(CPU  , LZCNT)\n+  GLIBC_DISABLE(CPU  , SSSE3)\n+  GLIBC_DISABLE(CPU  , POPCNT)\n+  GLIBC_DISABLE(CPU  , SSE4_1)\n+  GLIBC_DISABLE(CPU  , SSE4_2)\n+  GLIBC_DISABLE(CPU  , AVX512F)\n+  GLIBC_DISABLE(CPU  , AVX512CD)\n+  GLIBC_DISABLE(CPU  , AVX512BW)\n+  GLIBC_DISABLE(CPU  , AVX512DQ)\n+  GLIBC_DISABLE(CPU  , AVX512ER)\n+  GLIBC_DISABLE(CPU  , AVX512PF)\n+  GLIBC_DISABLE(CPU  , AVX512VL)\n+  GLIBC_DISABLE(GLIBC, IBT)\n+  GLIBC_DISABLE(GLIBC, FMA4)\n+  GLIBC_DISABLE(GLIBC, MOVBE)\n+  GLIBC_DISABLE(GLIBC, SHSTK)\n+  GLIBC_DISABLE(GLIBC, XSAVE)\n+  GLIBC_DISABLE(GLIBC, OSXSAVE)\n+#undef GLIBC_DISABLE\n+#undef GLIBC_DISABLE2\n+  *disable_end = 0;\n+\n+#ifdef ASSERT\n+#define CHECK_KIND(kind) do {                                                                                   \\\n+    if (PASTE_TOKENS(disable_handled_, kind) != PASTE_TOKENS(excessive_handled_, kind)) {                       \\\n+      jio_snprintf(errbuf, sizeof(errbuf),                                                                      \\\n+                   \"internal error: Unsupported disabling of \" STR(kind) \"_* 0x%\" PRIx64 \" != used 0x%\" PRIx64, \\\n+                   PASTE_TOKENS(disable_handled_, kind), PASTE_TOKENS(excessive_handled_, kind));               \\\n+      vm_exit_during_initialization(errbuf);                                                                    \\\n+    }                                                                                                           \\\n+  } while (0)\n+  CHECK_KIND(CPU  );\n+  CHECK_KIND(GLIBC);\n+#undef CHECK_KIND\n+\n+  \/\/ These cannot be disabled by GLIBC_TUNABLES interface.\n+#define GLIBC_UNSUPPORTED(kind, hotspot) EXCESSIVE_HANDLED(kind, hotspot)\n+  GLIBC_UNSUPPORTED(CPU  , 3DNOW_PREFETCH   );\n+  GLIBC_UNSUPPORTED(CPU  , SSE4A            );\n+  GLIBC_UNSUPPORTED(CPU  , TSC              );\n+  GLIBC_UNSUPPORTED(CPU  , TSCINV_BIT       );\n+  GLIBC_UNSUPPORTED(CPU  , TSCINV           );\n+  GLIBC_UNSUPPORTED(CPU  , AES              );\n+  GLIBC_UNSUPPORTED(CPU  , CLMUL            );\n+  GLIBC_UNSUPPORTED(CPU  , ADX              );\n+  GLIBC_UNSUPPORTED(CPU  , SHA              );\n+  GLIBC_UNSUPPORTED(CPU  , VZEROUPPER       );\n+  GLIBC_UNSUPPORTED(CPU  , AVX512_VPOPCNTDQ );\n+  GLIBC_UNSUPPORTED(CPU  , AVX512_VPCLMULQDQ);\n+  GLIBC_UNSUPPORTED(CPU  , AVX512_VAES      );\n+  GLIBC_UNSUPPORTED(CPU  , AVX512_VNNI      );\n+  GLIBC_UNSUPPORTED(CPU  , FLUSH            );\n+  GLIBC_UNSUPPORTED(CPU  , FLUSHOPT         );\n+  GLIBC_UNSUPPORTED(CPU  , CLWB             );\n+  GLIBC_UNSUPPORTED(CPU  , AVX512_VBMI2     );\n+  GLIBC_UNSUPPORTED(CPU  , AVX512_VBMI      );\n+  GLIBC_UNSUPPORTED(CPU  , HV               );\n+  GLIBC_UNSUPPORTED(CPU  , SSE3             );\n+  \/\/ These are handled as an exception above.\n+  GLIBC_UNSUPPORTED(CPU  , FXSR             );\n+  GLIBC_UNSUPPORTED(CPU  , MMX              );\n+  GLIBC_UNSUPPORTED(CPU  , SSE              );\n+  GLIBC_UNSUPPORTED(GLIBC, CMPXCHG16        );\n+  GLIBC_UNSUPPORTED(GLIBC, LAHFSAHF         );\n+  GLIBC_UNSUPPORTED(GLIBC, F16C             );\n+#undef GLIBC_UNSUPPORTED\n+#define CHECK_KIND(kind) do {                                                                                                                                              \\\n+    if (PASTE_TOKENS(excessive_handled_, kind) != PASTE_TOKENS(kind, _MAX) - 1) {                                                                                          \\\n+      jio_snprintf(errbuf, sizeof(errbuf),                                                                                                                                 \\\n+                   \"internal error: Unsupported disabling of some \" STR(kind) \"_* 0x%\" PRIx64 \" != full 0x%\" PRIx64, PASTE_TOKENS(excessive_handled_, kind), CPU_MAX - 1); \\\n+      vm_exit_during_initialization(errbuf);                                                                                                                               \\\n+    }                                                                                                                                                                      \\\n+  } while (0)\n+  CHECK_KIND(CPU  );\n+  CHECK_KIND(GLIBC);\n+#undef CHECK_KIND\n+#endif \/\/ ASSERT\n+\n+  if (disable_end == disable_str + prefix_len)\n+    return;\n+\n+  char *env_val = disable_str;\n+  const char *env = getenv(TUNABLES_NAME);\n+  char env_buf[strlen(disable_str) + (!env ? 0 : strlen(env) + 100)];\n+  if (env) {\n+    if (ShowCPUFeatures) {\n+      tty->print_cr(\"Original environment variable: \" TUNABLES_NAME \"=%s\", env);\n+    }\n+    const char *hwcaps = strstr(env, prefix + 1 \/* skip ':' *\/);\n+    if (!hwcaps) {\n+      strcpy(env_buf, env);\n+      strcat(env_buf, disable_str);\n+    } else {\n+      const char *colon = strchr(hwcaps, ':');\n+      if (!colon) {\n+        strcpy(env_buf, env);\n+        strcat(env_buf, disable_str + prefix_len);\n+      } else {\n+        int err = jio_snprintf(env_buf, sizeof(env_buf), \"%.*s%s%s\", (int)(colon - env), env, disable_str + prefix_len, colon);\n+        assert(err >= 0 && (unsigned)err < sizeof(env_buf), \"internal error: \" TUNABLES_NAME \" buffer overflow\");\n+      }\n+    }\n+    env_val = env_buf;\n+  }\n+  if (ShowCPUFeatures) {\n+    tty->print_cr(\"Re-exec of java with new environment variable: \" TUNABLES_NAME \"=%s\", env_val);\n+  }\n+  int err = setenv(TUNABLES_NAME, env_val, 1);\n+  if (err) {\n+    jio_snprintf(errbuf, sizeof(errbuf), \"setenv \" TUNABLES_NAME \" error: %m\");\n+    vm_exit_during_initialization(errbuf);\n+  }\n+\n+#define REEXEC_NAME \"HOTSPOT_GLIBC_TUNABLES_REEXEC\"\n+  if (getenv(REEXEC_NAME)) {\n+    jio_snprintf(errbuf, sizeof(errbuf), \"internal error: \" TUNABLES_NAME \"=%s failed and \" REEXEC_NAME \" is set\", disable_str);\n+    vm_exit_during_initialization(errbuf);\n+  }\n+  if (setenv(REEXEC_NAME, \"1\", 1)) {\n+    jio_snprintf(errbuf, sizeof(errbuf), \"setenv \" REEXEC_NAME \" error: %m\");\n+    vm_exit_during_initialization(errbuf);\n+  }\n+#undef REEXEC_NAME\n+\n+  char *buf = NULL;\n+  size_t buf_allocated = 0;\n+  size_t buf_used = 0;\n+#define CMDLINE \"\/proc\/self\/cmdline\"\n+  int fd = open(CMDLINE, O_RDONLY);\n+  if (fd == -1) {\n+    jio_snprintf(errbuf, sizeof(errbuf), \"Cannot open \" CMDLINE \": %m\");\n+    vm_exit_during_initialization(errbuf);\n+  }\n+  ssize_t got;\n+  do {\n+    if (buf_used == buf_allocated) {\n+      buf_allocated = MAX2(size_t(4096), 2 * buf_allocated);\n+      buf = (char *)os::realloc(buf, buf_allocated, mtOther);\n+      if (buf == NULL) {\n+        jio_snprintf(errbuf, sizeof(errbuf), CMDLINE \" reading failed allocating %zu bytes\", buf_allocated);\n+        vm_exit_during_initialization(errbuf);\n+      }\n+    }\n+    got = read(fd, buf + buf_used, buf_allocated - buf_used);\n+    if (got == -1) {\n+      jio_snprintf(errbuf, sizeof(errbuf), \"Cannot read \" CMDLINE \": %m\");\n+      vm_exit_during_initialization(errbuf);\n+    }\n+    buf_used += got;\n+  } while (got);\n+  if (close(fd)) {\n+    jio_snprintf(errbuf, sizeof(errbuf), \"Cannot close \" CMDLINE \": %m\");\n+    vm_exit_during_initialization(errbuf);\n+  }\n+  char **argv = NULL;\n+  size_t argv_allocated = 0;\n+  size_t argv_used = 0;\n+  char *s = buf;\n+  while (s <= buf + buf_used) {\n+    if (argv_used == argv_allocated) {\n+      argv_allocated = MAX2(size_t(256), 2 * argv_allocated);\n+      argv = (char **)os::realloc(argv, argv_allocated * sizeof(*argv), mtOther);\n+      if (argv == NULL) {\n+        jio_snprintf(errbuf, sizeof(errbuf), CMDLINE \" reading failed allocating %zu pointers\", argv_allocated);\n+        vm_exit_during_initialization(errbuf);\n+      }\n+    }\n+    if (s == buf + buf_used) {\n+      break;\n+    }\n+    argv[argv_used++] = s;\n+    s += strnlen(s, buf + buf_used - s);\n+    if (s == buf + buf_used)\n+      vm_exit_during_initialization(\"Missing end of string zero while parsing \" CMDLINE);\n+    ++s;\n+  }\n+  argv[argv_used] = NULL;\n+#undef CMDLINE\n+\n+#define EXEC \"\/proc\/self\/exe\"\n+  execv(EXEC, argv);\n+  jio_snprintf(errbuf, sizeof(errbuf), \"Cannot re-execute \" EXEC \": %m\");\n+  vm_exit_during_initialization(errbuf);\n+#undef EXEC\n+\n+#else \/\/ !INCLUDE_CPU_FEATURE_ACTIVE && !INCLUDE_LD_SO_LIST_DIAGNOSTICS\n+  if (ShowCPUFeatures) {\n+    tty->print_cr(\"-XX:CPUFeatures glibc setting \" TUNABLES_NAME \" is not supported in this Java build\");\n+  }\n+#endif \/\/ !INCLUDE_CPU_FEATURE_ACTIVE && !INCLUDE_LD_SO_LIST_DIAGNOSTICS\n+#undef TUNABLES_NAME\n+}\n+\n@@ -639,0 +1244,1 @@\n+    _glibc_features = glibc_flags();\n@@ -645,0 +1251,37 @@\n+  if (ShowCPUFeatures) {\n+    tty->print_cr(\"This machine's CPU features are: -XX:CPUFeatures=0x\" UINT64_FORMAT_X \",0x\" UINT64_FORMAT_X, _features, _glibc_features);\n+  }\n+\n+  assert(!CPUFeatures == FLAG_IS_DEFAULT(CPUFeatures), \"CPUFeatures parsing\");\n+  if (CPUFeatures) {\n+    uint64_t GLIBCFeatures_x64;\n+    uint64_t   CPUFeatures_x64 = CPUFeatures_parse(CPUFeatures, GLIBCFeatures_x64);\n+    uint64_t       features_missing =   CPUFeatures_x64 & ~      _features;\n+    uint64_t glibc_features_missing = GLIBCFeatures_x64 & ~_glibc_features;\n+    if (features_missing || glibc_features_missing) {\n+      char buf[512];\n+      int res = jio_snprintf(\n+                  buf, sizeof(buf),\n+                  \"Specified -XX:CPUFeatures=0x\" UINT64_FORMAT_X \",0x\" UINT64_FORMAT_X\n+                  \"; this machine's CPU features are 0x\" UINT64_FORMAT_X \",0x\" UINT64_FORMAT_X\n+                  \"; missing features of this CPU are 0x\" UINT64_FORMAT_X \",0x\" UINT64_FORMAT_X \" \",\n+                  CPUFeatures_x64, GLIBCFeatures_x64,\n+                  _features, _glibc_features,\n+                  features_missing, glibc_features_missing);\n+      assert(res > 0, \"not enough temporary space allocated\");\n+      \/\/ insert_features_names() does crash for undefined too high-numbered features.\n+      insert_features_names(buf + res , sizeof(buf) - res ,       features_missing & (  CPU_MAX - 1));\n+      int res2 = res + strlen(buf + res);\n+      insert_features_names(buf + res2, sizeof(buf) - res2, glibc_features_missing & (GLIBC_MAX - 1));\n+      if (buf[res]) {\n+        assert(buf[res] == ',', \"unexpeced VM_Version::insert_features_names separator instead of ','\");\n+        buf[res] = '=';\n+      }\n+      vm_exit_during_initialization(buf);\n+    }\n+          _features =   CPUFeatures_x64;\n+    _glibc_features = GLIBCFeatures_x64;\n+  }\n+\n+  glibc_not_using((CPU_MAX - 1) & ~_features, (GLIBC_MAX - 1) & ~_glibc_features);\n+\n@@ -655,0 +1298,5 @@\n+    if (!FLAG_IS_DEFAULT(CPUFeatures)) {\n+      char errbuf[512];\n+      jio_snprintf(errbuf, sizeof(errbuf), \"-XX:CPUFeatures option requires SSE2 flag to be set: 0x%\" PRIx64, CPU_SSE2);\n+      vm_exit_during_initialization(errbuf);\n+    }\n@@ -797,1 +1445,1 @@\n-  insert_features_names(buf + res, sizeof(buf) - res, _features_names);\n+  insert_features_names(buf + res, sizeof(buf) - res);\n@@ -1888,1 +2536,1 @@\n-void VM_Version::initialize() {\n+void VM_Version::initialize_features() {\n@@ -1904,0 +2552,4 @@\n+}\n+\n+void VM_Version::initialize() {\n+  initialize_features();\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":655,"deletions":3,"binary":false,"changes":658,"status":"modified"},{"patch":"@@ -31,0 +31,3 @@\n+#include \"runtime\/java.hpp\"\n+#include \"runtime\/globals_extension.hpp\"\n+#include \"jvm_io.h\"\n@@ -85,1 +88,2 @@\n-                        : 2,\n+                        : 1,\n+               movbe    : 1,\n@@ -89,1 +93,1 @@\n-                        : 1,\n+               xsave    : 1,\n@@ -92,1 +96,2 @@\n-                        : 2,\n+               f16c     : 1,\n+                        : 1,\n@@ -156,1 +161,3 @@\n-                            : 22;\n+                            : 7,\n+               fma4         : 1,\n+                            : 14;\n@@ -246,1 +253,1 @@\n-                           : 1,\n+                     shstk : 1,\n@@ -264,1 +271,3 @@\n-                           : 28;\n+                           : 16,\n+             ibt           : 1,\n+                           : 11;\n@@ -362,1 +371,3 @@\n-    decl(HV,                \"hv\",                46) \/* Hypervisor instructions *\/\n+    decl(HV,                \"hv\",                46) \/* Hypervisor instructions *\/ \\\n+                                                     \\\n+    decl(MAX,               \"max\",               47) \/* Maximum - this feature must never be used *\/\n@@ -369,0 +380,22 @@\n+  \/* Tracking of a CPU feature for glibc *\/ \\\n+  enum Glibc_Feature_Flag : uint64_t {\n+#define GLIBC_FEATURE_FLAGS(decl) \\\n+    decl(FMA4,              \"fma4\",              0) \\\n+    decl(MOVBE,             \"movbe\",             1) \\\n+    decl(OSXSAVE,           \"osxsave\",           2) \\\n+    decl(IBT,               \"ibt\",               3) \\\n+    decl(SHSTK,             \"shstk\",             4) \/* Also known as cet_ss *\/ \\\n+    decl(XSAVE,             \"xsave\",             5) \\\n+    decl(CMPXCHG16,         \"cmpxchg16\",         6) \/* Also known in cpuinfo as cx16 and in glibc as cmpxchg16b *\/ \\\n+    decl(LAHFSAHF,          \"lahfsahf\",          7) \/* Also known in cpuinfo as lahf_lm and in glibc as lahf64_sahf64 *\/ \\\n+    decl(F16C,              \"f16c\",              8) \\\n+                                                    \\\n+    decl(MAX,               \"max\",               9) \/* Maximum - this feature must never be used *\/\n+#define DECLARE_GLIBC_FEATURE_FLAG(id, name, bit) GLIBC_##id = (1ULL << bit),\n+    GLIBC_FEATURE_FLAGS(DECLARE_GLIBC_FEATURE_FLAG)\n+#undef DECLARE_GLIBC_FEATURE_FLAG\n+  };\n+\n+  \/\/ glibc feature flags.\n+  static uint64_t _glibc_features;\n+\n@@ -370,0 +403,1 @@\n+  static const char* _glibc_features_names[];\n@@ -671,0 +705,23 @@\n+  static uint64_t glibc_flags() {\n+    uint64_t result = 0;\n+    if (_cpuid_info.std_cpuid1_ecx.bits.movbe != 0)\n+      result |= GLIBC_MOVBE;\n+    if (_cpuid_info.std_cpuid1_ecx.bits.osxsave != 0)\n+      result |= GLIBC_OSXSAVE;\n+    if (_cpuid_info.std_cpuid1_ecx.bits.xsave != 0)\n+      result |= GLIBC_XSAVE;\n+    if (_cpuid_info.std_cpuid1_ecx.bits.cmpxchg16 != 0)\n+      result |= GLIBC_CMPXCHG16;\n+    if (_cpuid_info.std_cpuid1_ecx.bits.f16c != 0)\n+      result |= GLIBC_F16C;\n+    if (_cpuid_info.sef_cpuid7_ecx.bits.shstk != 0)\n+      result |= GLIBC_SHSTK;\n+    if (_cpuid_info.sef_cpuid7_edx.bits.ibt != 0)\n+      result |= GLIBC_IBT;\n+    if (_cpuid_info.ext_cpuid1_ecx.bits.fma4 != 0)\n+      result |= GLIBC_FMA4;\n+    if (_cpuid_info.ext_cpuid1_ecx.bits.LahfSahf != 0)\n+      result |= GLIBC_LAHFSAHF;\n+    return result;\n+  }\n+\n@@ -712,0 +769,3 @@\n+  static uint64_t CPUFeatures_parse(const char *ccstr, uint64_t &glibc_features);\n+  static void glibc_not_using(uint64_t excessive_CPU, uint64_t excessive_GLIBC);\n+\n@@ -743,0 +803,7 @@\n+  static void insert_features_names(char* buf, size_t buflen, uint64_t features = _features) {\n+    Abstract_VM_Version::insert_features_names(buf, buflen, _features_names, features);\n+  }\n+  static void insert_glibc_features_names(char* buf, size_t buflen, uint64_t glibc_features) {\n+    Abstract_VM_Version::insert_features_names(buf, buflen, _glibc_features_names, glibc_features);\n+  }\n+\n@@ -746,0 +813,1 @@\n+  static void initialize_features();\n@@ -1043,2 +1111,13 @@\n-    assert ((!Universe::is_fully_initialized() || (_features & CPU_FLUSH) != 0), \"clflush should be available\");\n-    return true;\n+    if (!Universe::is_fully_initialized()) {\n+      return true;\n+    }\n+    if ((_features & CPU_FLUSH) != 0) {\n+      return true;\n+    }\n+    if (FLAG_IS_DEFAULT(CPUFeatures)) {\n+      vm_exit_during_initialization(\"clflush should be available\");\n+    }\n+    char errbuf[512];\n+    jio_snprintf(errbuf, sizeof(errbuf), \"-XX:CPUFeatures option requires FLUSH flag to be set: 0x%\" PRIx64, CPU_FLUSH);\n+    vm_exit_during_initialization(errbuf);\n+    return false;\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.hpp","additions":88,"deletions":9,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -35,0 +35,3 @@\n+\n+  \/\/ No _features_names[] available on this CPU.\n+  static void insert_features_names(char* buf, size_t buflen, uint64_t features = _features) {}\n","filename":"src\/hotspot\/cpu\/zero\/vm_version_zero.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -404,0 +404,1 @@\n+  static void verify_cpu_compatibility();\n@@ -630,1 +631,1 @@\n-void os::Linux::initialize_system_info() {\n+void os::Linux::initialize_processor_count() {\n@@ -632,0 +633,5 @@\n+  assert(processor_count() > 0, \"linux error\");\n+}\n+\n+void os::Linux::initialize_system_info() {\n+  initialize_processor_count();\n@@ -644,1 +650,0 @@\n-  assert(processor_count() > 0, \"linux error\");\n@@ -5937,1 +5942,1 @@\n-static int checkpoint_restore(int *shmid) {\n+int os::Linux::checkpoint_restore(int *shmid) {\n@@ -5955,0 +5960,4 @@\n+  initialize_processor_count();\n+  if (_cpu_to_node != NULL)\n+    rebuild_cpu_to_node_map();\n+\n@@ -6036,0 +6045,52 @@\n+void VM_Crac::verify_cpu_compatibility() {\n+  uint64_t features_saved = Abstract_VM_Version::features();\n+#define SUPPORTS_SET \\\n+    SUPPORTS(supports_cx8) \\\n+    SUPPORTS(supports_atomic_getset4) \\\n+    SUPPORTS(supports_atomic_getset8) \\\n+    SUPPORTS(supports_atomic_getadd4) \\\n+    SUPPORTS(supports_atomic_getadd8) \\\n+    \/**\/\n+#define SUPPORTS(x) bool x##_saved = Abstract_VM_Version::x();\n+  SUPPORTS_SET\n+#undef SUPPORTS\n+\n+  \/\/ FIXME: x86 only\n+  StubCodeDesc::thaw();\n+  VM_Version::initialize_features();\n+\n+  \/\/ Abstract_VM_Version::features() may be less than current CPU's features as they have been already masked by the CPUFeatures argument (if it is present).\n+  uint64_t features_missing = features_saved & ~Abstract_VM_Version::features();\n+  if (features_missing) {\n+    char buf[512];\n+    int res = jio_snprintf(\n+                buf, sizeof(buf),\n+                \"You have to specify -XX:CPUFeatures=0x\" UINT64_FORMAT_X \" during -XX:CRaCCheckpointTo making of the checkpoint\"\n+                \"; specified -XX:CRaCRestoreFrom file contains CPU features 0x\" UINT64_FORMAT_X\n+                \"; missing features of this CPU are 0x\" UINT64_FORMAT_X \" \",\n+                Abstract_VM_Version::features() & features_saved,\n+                features_saved, features_missing);\n+    assert(res > 0, \"not enough temporary space allocated\");\n+    VM_Version::insert_features_names(buf + res, sizeof(buf) - res, features_missing);\n+    assert(buf[res] == ',', \"unexpeced VM_Version::insert_features_names separator instead of ','\");\n+    buf[res] = '=';\n+    vm_exit_during_initialization(buf);\n+  }\n+  auto supports_exit = [&](const char *supports, bool file, bool this_cpu) {\n+    char buf[512];\n+    int res = jio_snprintf(\n+                buf, sizeof(buf),\n+                \"Specified -XX:CRaCRestoreFrom file contains feature \\\"%s\\\" value %d while this CPU has value %d\",\n+                supports, file, this_cpu);\n+    assert(res > 0, \"not enough temporary space allocated\");\n+    vm_exit_during_initialization(buf);\n+  };\n+#define SUPPORTS(x)                                           \\\n+  if (x##_saved != Abstract_VM_Version::x()) {                \\\n+    supports_exit( #x , Abstract_VM_Version::x(), x##_saved); \\\n+  }\n+  SUPPORTS_SET\n+#undef SUPPORTS\n+#undef SUPPORTS_SET\n+}\n+\n@@ -6114,1 +6175,1 @@\n-    int ret = checkpoint_restore(&shmid);\n+    int ret = os::Linux::checkpoint_restore(&shmid);\n@@ -6121,0 +6182,2 @@\n+  verify_cpu_compatibility();\n+\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":67,"deletions":4,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -67,0 +67,1 @@\n+  static void initialize_processor_count();\n@@ -187,0 +188,2 @@\n+  static int checkpoint_restore(int *shmid);\n+\n","filename":"src\/hotspot\/os\/linux\/os_linux.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -218,0 +218,7 @@\n+  if (info != NULL && uc != NULL && thread == NULL && sig == SIGSEGV) {\n+    pc = (address) os::Posix::ucontext_get_pc(uc);\n+    if ((sig == SIGSEGV) && VM_Version::is_cpuinfo_segv_addr(pc)) {\n+      \/\/ Verify that OS save\/restore AVX registers.\n+      stub = VM_Version::cpuinfo_cont_addr();\n+    }\n+  } else\n","filename":"src\/hotspot\/os_cpu\/linux_x86\/os_linux_x86.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -301,2 +301,1 @@\n-void Abstract_VM_Version::insert_features_names(char* buf, size_t buflen, const char* features_names[]) {\n-  uint64_t features = _features;\n+void Abstract_VM_Version::insert_features_names(char* buf, size_t buflen, const char* features_names[], uint64_t features) {\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -76,0 +76,2 @@\n+  static void insert_features_names(char* buf, size_t buflen, const char* features_names[], uint64_t features = _features);\n+\n@@ -124,1 +126,0 @@\n-  static void insert_features_names(char* buf, size_t buflen, const char* features_names[]);\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -60,0 +60,5 @@\n+void StubCodeDesc::thaw() {\n+  assert(_frozen, \"repeated thaw operation\");\n+  _frozen = false;\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/stubCodeGenerator.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -83,0 +83,1 @@\n+  static void thaw();\n","filename":"src\/hotspot\/share\/runtime\/stubCodeGenerator.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -242,0 +242,13 @@\n+#ifndef INCLUDE_CPU_FEATURE_ACTIVE\n+#define INCLUDE_CPU_FEATURE_ACTIVE 1\n+#endif \/\/ INCLUDE_CPU_FEATURE_ACTIVE\n+\n+#ifndef INCLUDE_LD_SO_LIST_DIAGNOSTICS\n+#define INCLUDE_LD_SO_LIST_DIAGNOSTICS 1\n+#endif \/\/ INCLUDE_LD_SO_LIST_DIAGNOSTICS\n+\n+#if INCLUDE_CPU_FEATURE_ACTIVE && INCLUDE_LD_SO_LIST_DIAGNOSTICS\n+#undef  INCLUDE_LD_SO_LIST_DIAGNOSTICS\n+#define INCLUDE_LD_SO_LIST_DIAGNOSTICS 0\n+#endif\n+\n","filename":"src\/hotspot\/share\/utilities\/macros.hpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2346,0 +2346,9 @@\n+.B \\f[CB]\\-XX:CPUFeatures=\\f[R]\\f[I]0xnumber\\f[R]\n+CPU feature set, use -XX:CPUFeatures=0xnumber with -XX:CRaCCheckpointTo when\n+you get an error during -XX:CRaCRestoreFrom on a different machine.\n+\\f[CB]\\-XX:CPUFeatures=native\\f[R] is the default.\n+\\f[CB]\\-XX:CPUFeatures=generic\\f[R] is compatible with any CPU but not as slow\n+as \\f[CB]\\-XX:CPUFeatures=0\\f[R].\n+.RS\n+.RE\n+.TP\n@@ -2627,0 +2636,6 @@\n+.B \\f[CB]\\-XX:+ShowCPUFeatures\\f[R]\n+Show features of this CPU to be possibly used for the\n+\\f[CB]\\-XX:CPUFeatures=0xnumber\\f[R] option.\n+.RS\n+.RE\n+.TP\n","filename":"src\/java.base\/share\/man\/java.1","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -71,2 +71,0 @@\n-static char* altstack = NULL;\n-\n@@ -74,8 +72,1 @@\n-  if (altstack == NULL) {\n-    \/\/ Dynamically allocated in case SIGSTKSZ is not constant\n-    altstack = malloc(SIGSTKSZ);\n-    if (altstack == NULL) {\n-      fprintf(stderr, \"Test ERROR. Unable to malloc altstack space\\n\");\n-      exit(7);\n-    }\n-  }\n+  static char altstack[SIGSTKSZ];\n","filename":"test\/hotspot\/jtreg\/runtime\/StackGuardPages\/exeinvoke.c","additions":2,"deletions":11,"binary":false,"changes":13,"status":"modified"}]}