{"files":[{"patch":"@@ -49,0 +49,3 @@\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import jdk.internal.crac.Core;\n@@ -51,0 +54,1 @@\n+import jdk.internal.crac.JDKResource;\n@@ -304,0 +308,3 @@\n+    \/* Resource registration uses weak references; we need to keep it locally. *\/\n+    private static final JDKResource checkpointListener;\n+\n@@ -344,0 +351,19 @@\n+        \/\/ DNS cache is cleared before the checkpoint; application restored at a later point\n+        \/\/ or in a different environment should query DNS again.\n+        checkpointListener = new JDKResource() {\n+            @Override\n+            public Priority getPriority() {\n+                return Priority.NORMAL;\n+            }\n+\n+            @Override\n+            public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+                cache.clear();\n+                expirySet.clear();\n+            }\n+\n+            @Override\n+            public void afterRestore(Context<? extends Resource> context) throws Exception {\n+            }\n+        };\n+        Core.getJDKContext().register(checkpointListener);\n","filename":"src\/java.base\/share\/classes\/java\/net\/InetAddress.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+public class ResolveInetAddress {\n+    public static void main(String[] args) {\n+        if (args.length < 2) {\n+            System.err.println(\"Args: <ip address> <check file path>\");\n+            return;\n+        }\n+        printAddress(args[0]);\n+        while (!Files.exists(Path.of(args[1]))) {\n+            try {\n+                \/\/noinspection BusyWait\n+                Thread.sleep(100);\n+            } catch (InterruptedException e) {\n+                System.err.println(\"Interrupted!\");\n+                return;\n+            }\n+        }\n+        printAddress(args[0]);\n+    }\n+\n+    private static void printAddress(String hostname) {\n+        try {\n+            InetAddress address = InetAddress.getByName(hostname);\n+            \/\/ we will assume IPv4 address\n+            byte[] bytes = address.getAddress();\n+            System.out.print(bytes[0] & 0xFF);\n+            for (int i = 1; i < bytes.length; ++i) {\n+                System.out.print('.');\n+                System.out.print(bytes[i] & 0xFF);\n+            }\n+            System.out.println();\n+        } catch (UnknownHostException e) {\n+            System.out.println();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/java\/net\/InetAddress\/ResolveInetAddress.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,163 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.Container;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.containers.docker.Common;\n+import jdk.test.lib.containers.docker.DockerRunOptions;\n+import jdk.test.lib.containers.docker.DockerTestUtils;\n+import jdk.test.lib.process.StreamPumper;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.*;\n+import java.util.function.Consumer;\n+\n+\/*\n+ * @test\n+ * @summary Test if InetAddress cache is flushed after checkpoint\/restore\n+ * @requires docker.support\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.crac\n+ * @build ResolveInetAddress\n+ * @run main\/timeout=360 TestInetAddress\n+ *\/\n+public class ResolveTest {\n+    private static final String imageName = Common.imageName(\"inet-address\");\n+    public static final String TEST_HOSTNAME = \"some.test.hostname.example.com\";\n+    public static final String CONTAINER_NAME = \"test-inet-address\";\n+    public static final String CRAC_CRIU_PATH;\n+\n+    static {\n+        String path = System.getenv(\"CRAC_CRIU_PATH\");\n+        if (path == null) {\n+            path = Utils.TEST_JDK + \"\/lib\/criu\";\n+        }\n+        CRAC_CRIU_PATH = path;\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        if (!DockerTestUtils.canTestDocker()) {\n+            return;\n+        }\n+        if (!Files.exists(Path.of(CRAC_CRIU_PATH))) {\n+            throw new RuntimeException(\"criu cannot be found in \" + CRAC_CRIU_PATH);\n+        }\n+        DockerTestUtils.buildJdkDockerImage(imageName, \"Dockerfile-is-ignored\", \"jdk-docker\");\n+        try {\n+            Future<?> completed = startTestProcess();\n+            checkpointTestProcess();\n+            completed.get(5, TimeUnit.SECONDS);\n+            startRestoredProcess();\n+        } finally {\n+            ensureContainerDead();\n+            DockerTestUtils.removeDockerImage(imageName);\n+        }\n+    }\n+\n+    private static Future<?> startTestProcess() throws Exception {\n+        ensureContainerDead();\n+\n+        List<String> cmd = new ArrayList<>();\n+        cmd.add(Container.ENGINE_COMMAND);\n+        cmd.addAll(Arrays.asList(\"run\", \"--rm\", \"--add-host\", TEST_HOSTNAME + \":192.168.12.34\"));\n+        cmd.addAll(Arrays.asList(\"--volume\", Utils.TEST_CLASSES + \":\/test-classes\/\"));\n+        cmd.addAll(Arrays.asList(\"--volume\", \"cr:\/cr\"));\n+        cmd.addAll(Arrays.asList(\"--volume\", CRAC_CRIU_PATH + \":\/criu\"));\n+        cmd.addAll(Arrays.asList(\"--env\", \"CRAC_CRIU_PATH=\/criu\"));\n+        cmd.addAll(Arrays.asList(\"--entrypoint\", \"bash\"));\n+        \/\/ checkpoint-restore does not work without this: TODO fine-grained --cap-add\n+        cmd.add(\"--privileged\");\n+        cmd.addAll(Arrays.asList(\"--name\", CONTAINER_NAME));\n+        cmd.add(imageName);\n+        \/\/ Checkpointing does not work for PID 1, therefore we add an intermediary bash process\n+        List<String> javaCmd = new ArrayList<>();\n+        javaCmd.addAll(Arrays.asList(\"\/jdk\/bin\/java\", \"-cp \/test-classes\/\", \"-XX:CRaCCheckpointTo=\/cr\"));\n+        javaCmd.addAll(Arrays.asList(Utils.getTestJavaOpts()));\n+        javaCmd.addAll(Arrays.asList(\"ResolveInetAddress\", TEST_HOSTNAME, \"\/second-run\"));\n+        cmd.addAll(Arrays.asList(\"-c\", String.join(\" \", javaCmd) + \"; echo i-am-here-to-force-child-process\"));\n+\n+        System.err.println(\"Running: \" + String.join(\" \", cmd));\n+\n+        CompletableFuture<?> firstOutputFuture = new CompletableFuture<Void>();\n+        Future<?> completed = executeWatching(cmd, line -> {\n+            System.out.println(\"OUTPUT: \" + line);\n+            if (line.equals(\"192.168.12.34\")) {\n+                firstOutputFuture.complete(null);\n+            }\n+        }, error -> {\n+            System.err.println(\"ERROR: \" + error);\n+            firstOutputFuture.cancel(false);\n+        });\n+        firstOutputFuture.get(10, TimeUnit.SECONDS);\n+        return completed;\n+    }\n+\n+    private static void ensureContainerDead() throws Exception {\n+        \/\/ ensure the container is not running, ignore if not present\n+        DockerTestUtils.execute(\"docker\", \"kill\", CONTAINER_NAME).getExitValue();\n+    }\n+\n+    private static void checkpointTestProcess() throws Exception {\n+        DockerTestUtils.execute(\"docker\", \"exec\", CONTAINER_NAME,\n+                        \"\/jdk\/bin\/jcmd\", ResolveInetAddress.class.getName(), \"JDK.checkpoint\")\n+                .shouldHaveExitValue(0);\n+    }\n+\n+    private static Future<Void> executeWatching(List<String> command, Consumer<String> outputConsumer, Consumer<String> errorConsumer) throws IOException, ExecutionException, InterruptedException, TimeoutException {\n+        ProcessBuilder pb = new ProcessBuilder(command);\n+        Process p = pb.start();\n+        Future<Void> outputPumper = pump(p.getInputStream(), outputConsumer);\n+        Future<Void> errorPumper = pump(p.getErrorStream(), errorConsumer);\n+        return outputPumper;\n+    }\n+\n+    private static Future<Void> pump(InputStream stream, Consumer<String> consumer) {\n+        return new StreamPumper(stream).addPump(new StreamPumper.LinePump() {\n+            @Override\n+            protected void processLine(String line) {\n+                consumer.accept(line);\n+            }\n+        }).process();\n+    }\n+\n+    private static void startRestoredProcess() throws Exception {\n+        DockerRunOptions opts = new DockerRunOptions(imageName, \"\/jdk\/bin\/java\", \"ResolveInetAddress\");\n+        opts.addDockerOpts(\"--volume\", Utils.TEST_CLASSES + \":\/test-classes\/\");\n+        opts.addDockerOpts(\"--volume\", \"cr:\/cr\");\n+        opts.addDockerOpts(\"--volume\", Utils.TEST_CLASSES + \":\/second-run\"); \/\/ any file suffices\n+        opts.addDockerOpts(\"--volume\", CRAC_CRIU_PATH + \":\/criu\");\n+        opts.addDockerOpts(\"--env\", \"CRAC_CRIU_PATH=\/criu\");\n+        opts.addDockerOpts(\"--add-host\", TEST_HOSTNAME + \":192.168.56.78\");\n+        opts.addDockerOpts(\"--privileged\");\n+        opts.addJavaOpts(\"-XX:CRaCRestoreFrom=\/cr\");\n+        DockerTestUtils.dockerRunJava(opts)\n+                .shouldHaveExitValue(0)\n+                .shouldContain(\"192.168.56.78\");\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/java\/net\/InetAddress\/ResolveTest.java","additions":163,"deletions":0,"binary":false,"changes":163,"status":"added"}]}