{"files":[{"patch":"@@ -61,1 +61,11 @@\n-        NATIVE_PRNG\n+        NATIVE_PRNG,\n+        \/**\n+         * Priority of the\n+         * sun.security.provider.SecureRandom resource\n+         *\/\n+        SECURE_RANDOM,\n+        \/**\n+         * Priority of the\n+         * sun.security.provider.SecureRandom.SeederHolder resource\n+         *\/\n+        SEEDER_HOLDER\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/JDKResource.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -28,0 +28,3 @@\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+\n@@ -33,0 +36,2 @@\n+import java.util.Arrays;\n+import java.util.concurrent.locks.ReentrantLock;\n@@ -56,1 +61,1 @@\n-implements java.io.Serializable {\n+implements java.io.Serializable, jdk.internal.crac.JDKResource {\n@@ -66,0 +71,2 @@\n+    private boolean clearStateOnCheckpoint = true;\n+    private ReentrantLock objLock = new ReentrantLock();\n@@ -122,0 +129,1 @@\n+        jdk.internal.crac.Core.getJDKContext().register(this);\n@@ -157,1 +165,14 @@\n-    public synchronized void engineSetSeed(byte[] seed) {\n+    public void engineSetSeed(byte[] seed) {\n+        objLock.lock();\n+        try {\n+            \/\/ check if objLock has not been already acquired in beforeCheckpoint\n+            if(objLock.getHoldCount() > 1) {\n+                throw new IllegalStateException(\"SHA1PRNG object is invalidated\");\n+            }\n+            setSeedImpl(seed);\n+        } finally {\n+            objLock.unlock();\n+        }\n+    }\n+\n+    private void setSeedImpl(byte[] seed) {\n@@ -166,0 +187,1 @@\n+        clearStateOnCheckpoint = false;\n@@ -193,0 +215,31 @@\n+    private void invalidate() {\n+        assert objLock.isHeldByCurrentThread();\n+        if (state != null) {\n+            Arrays.fill(state, (byte)0);\n+        }\n+        state = null;\n+        if (remainder != null) {\n+            Arrays.fill(remainder, (byte)0);\n+        }\n+        remainder = null;\n+        remCount = 0;\n+    }\n+\n+    @Override\n+    public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+        objLock.lock();\n+        if (clearStateOnCheckpoint) {\n+            invalidate();\n+        }\n+    }\n+\n+    @Override\n+    public void afterRestore(Context<? extends Resource> context) throws Exception {\n+        objLock.unlock();\n+    }\n+\n+    @Override\n+    public Priority getPriority() {\n+        return Priority.SECURE_RANDOM;\n+    }\n+\n@@ -199,3 +252,3 @@\n-    private static class SeederHolder {\n-\n-        private static final SecureRandom seeder;\n+    private static class SeederHolder implements jdk.internal.crac.JDKResource {\n+        private static final SeederHolder seederHolder = new SeederHolder();\n+        private final SecureRandom seeder;\n@@ -203,1 +256,1 @@\n-        static {\n+        private SeederHolder() {\n@@ -209,1 +262,1 @@\n-            byte [] b = new byte[DIGEST_SIZE];\n+            byte[] b = new byte[DIGEST_SIZE];\n@@ -212,0 +265,22 @@\n+            jdk.internal.crac.Core.getJDKContext().register(this);\n+        }\n+\n+        public static SecureRandom getSeeder() {\n+            return seederHolder.seeder;\n+        }\n+\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+            seeder.invalidate();\n+        }\n+\n+        @Override\n+        public void afterRestore(Context<? extends Resource> context) throws Exception {\n+            byte[] b = new byte[DIGEST_SIZE];\n+            SeedGenerator.generateSeed(b);\n+            seeder.setSeedImpl(b);\n+        }\n+\n+        @Override\n+        public Priority getPriority() {\n+            return Priority.SEEDER_HOLDER;\n@@ -221,10 +296,10 @@\n-    public synchronized void engineNextBytes(byte[] result) {\n-        int index = 0;\n-        int todo;\n-        byte[] output = remainder;\n-\n-        if (state == null) {\n-            byte[] seed = new byte[DIGEST_SIZE];\n-            SeederHolder.seeder.engineNextBytes(seed);\n-            state = digest.digest(seed);\n-        }\n+    public void engineNextBytes(byte[] result) {\n+        objLock.lock();\n+        try {\n+            \/\/ verify if objLock is already acquired in beforeCheckpoint\n+            if(objLock.getHoldCount() > 1) {\n+                throw new IllegalStateException(\"SHA1PRNG object is invalidated\");\n+            }\n+            int index = 0;\n+            int todo;\n+            byte[] output = remainder;\n@@ -232,5 +307,10 @@\n-        \/\/ Use remainder from last time\n-        int r = remCount;\n-        if (r > 0) {\n-            \/\/ How many bytes?\n-            todo = (result.length - index) < (DIGEST_SIZE - r) ?\n+            if (state == null) {\n+                byte[] seed = new byte[DIGEST_SIZE];\n+                SeederHolder.getSeeder().engineNextBytes(seed);\n+                state = digest.digest(seed);\n+            }\n+            \/\/ Use remainder from last time\n+            int r = remCount;\n+            if (r > 0) {\n+                \/\/ How many bytes?\n+                todo = (result.length - index) < (DIGEST_SIZE - r) ?\n@@ -238,4 +318,7 @@\n-            \/\/ Copy the bytes, zero the buffer\n-            for (int i = 0; i < todo; i++) {\n-                result[i] = output[r];\n-                output[r++] = 0;\n+                \/\/ Copy the bytes, zero the buffer\n+                for (int i = 0; i < todo; i++) {\n+                    result[i] = output[r];\n+                    output[r++] = 0;\n+                }\n+                remCount += todo;\n+                index += todo;\n@@ -243,3 +326,0 @@\n-            remCount += todo;\n-            index += todo;\n-        }\n@@ -247,14 +327,15 @@\n-        \/\/ If we need more bytes, make them.\n-        while (index < result.length) {\n-            \/\/ Step the state\n-            digest.update(state);\n-            output = digest.digest();\n-            updateState(state, output);\n-\n-            \/\/ How many bytes?\n-            todo = (result.length - index) > DIGEST_SIZE ?\n-                DIGEST_SIZE : result.length - index;\n-            \/\/ Copy the bytes, zero the buffer\n-            for (int i = 0; i < todo; i++) {\n-                result[index++] = output[i];\n-                output[i] = 0;\n+            \/\/ If we need more bytes, make them.\n+            while (index < result.length) {\n+                \/\/ Step the state\n+                digest.update(state);\n+                output = digest.digest();\n+                updateState(state, output);\n+                \/\/ How many bytes?\n+                todo = (result.length - index) > DIGEST_SIZE ?\n+                        DIGEST_SIZE : result.length - index;\n+                \/\/ Copy the bytes, zero the buffer\n+                for (int i = 0; i < todo; i++) {\n+                    result[index++] = output[i];\n+                    output[i] = 0;\n+                }\n+                remCount += todo;\n@@ -262,2 +343,0 @@\n-            remCount += todo;\n-        }\n@@ -265,3 +344,6 @@\n-        \/\/ Store remainder for next time\n-        remainder = output;\n-        remCount %= DIGEST_SIZE;\n+            \/\/ Store remainder for next time\n+            remainder = output;\n+            remCount %= DIGEST_SIZE;\n+        } finally {\n+            objLock.unlock();\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/SecureRandom.java","additions":130,"deletions":48,"binary":false,"changes":178,"status":"modified"},{"patch":"@@ -0,0 +1,48 @@\n+\/\/ Copyright 2019-2021 Azul Systems, Inc.  All Rights Reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it under\n+\/\/ the terms of the GNU General Public License version 2 only, as published by\n+\/\/ the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n+\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n+\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n+\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version 2\n+\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n+\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n+\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n+\/\/ have any questions.\n+\n+\n+import jdk.crac.*;\n+import java.security.SecureRandom;\n+\n+public class Test1 {\n+\n+    private static SecureRandom sr;\n+\n+    public static void main(String args[]) throws Exception {\n+        SecureRandom sr = SecureRandom.getInstance(\"SHA1PRNG\");\n+        if (\"1\".equalsIgnoreCase(args[0])) {\n+            sr.setSeed(sr.generateSeed(10));\n+        }\n+        sr.nextInt();\n+\n+        try {\n+            jdk.crac.Core.checkpointRestore();\n+        } catch (CheckpointException e) {\n+            e.printStackTrace(System.out);\n+            throw new RuntimeException(\"Checkpoint ERROR \" + e);\n+        } catch (RestoreException e) {\n+            throw new RuntimeException(\"Restore ERROR \" + e);\n+        }\n+\n+        int r = sr.nextInt(255);\n+        System.exit(r);\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/SecureRandom\/Test1.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+#!\/bin\/sh\n+\n+# Copyright 2019-2021 Azul Systems, Inc.  All Rights Reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it under\n+# the terms of the GNU General Public License version 2 only, as published by\n+# the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT ANY\n+# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n+# A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n+# details (a copy is included in the LICENSE file that accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version 2\n+# along with this work; if not, write to the Free Software Foundation, Inc.,\n+# 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n+# CA 94089 USA or visit www.azul.com if you need additional information or\n+# have any questions.\n+\n+\n+##\n+## @test Test1.sh\n+## @summary verify that SHA1PRNG secure random is reseeded after restore if\n+##  initialized with default seed\n+## @compile Test1.java\n+## @run shell\/timeout=60 Test.sh\n+##\n+\n+set -x\n+\n+export TESTJAVA=\/home\/parallels\/Work\/CRAC\/jdk\n+export TESTCLASSPATH=.\n+\n+set +e\n+for test in `seq 0 1`\n+do\n+\n+    ${TESTJAVA}\/bin\/java -cp ${TESTCLASSPATH} -XX:CRaCCheckpointTo=cr Test1 $test\n+    e=$?\n+\n+    [ $e -eq 137 ]\n+\n+    ${TESTJAVA}\/bin\/java -cp ${TESTCLASSPATH} -XX:CRaCRestoreFrom=cr Test1 $test\n+    e1=$?\n+\n+    ${TESTJAVA}\/bin\/java -cp ${TESTCLASSPATH} -XX:CRaCRestoreFrom=cr Test1 $test\n+    e2=$?\n+\n+    if [ $test == \"0\" ]; then\n+        if [ $e1 == $e2 ]; then\n+            echo FAILED\n+            exit 1\n+        fi\n+    else \n+        if [ $e1 != $e2 ]; then\n+            echo FAILED\n+            exit 1\n+        fi\n+    fi\n+done\n+echo PASSED\n","filename":"test\/jdk\/jdk\/crac\/SecureRandom\/Test1.sh","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"}]}