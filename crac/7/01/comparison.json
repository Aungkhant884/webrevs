{"files":[{"patch":"@@ -28,0 +28,3 @@\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+\n@@ -33,0 +36,2 @@\n+import java.util.Arrays;\n+import java.util.concurrent.locks.ReentrantLock;\n@@ -56,1 +61,1 @@\n-implements java.io.Serializable {\n+implements java.io.Serializable, jdk.internal.crac.JDKResource {\n@@ -66,0 +71,2 @@\n+    private boolean clearStateOnCheckpoint = true;\n+    private ReentrantLock objLock = new ReentrantLock();\n@@ -122,0 +129,1 @@\n+        jdk.internal.crac.Core.getJDKContext().register(this);\n@@ -157,5 +165,8 @@\n-    public synchronized void engineSetSeed(byte[] seed) {\n-        if (state != null) {\n-            digest.update(state);\n-            for (int i = 0; i < state.length; i++) {\n-                state[i] = 0;\n+    public void engineSetSeed(byte[] seed) {\n+        objLock.lock();\n+        try {\n+            if (state != null) {\n+                digest.update(state);\n+                for (int i = 0; i < state.length; i++) {\n+                    state[i] = 0;\n+                }\n@@ -163,0 +174,5 @@\n+            state = digest.digest(seed);\n+            remCount = 0;\n+            clearStateOnCheckpoint = false;\n+        } finally {\n+            objLock.unlock();\n@@ -164,2 +180,0 @@\n-        state = digest.digest(seed);\n-        remCount = 0;\n@@ -193,0 +207,30 @@\n+    private void invalidate() {\n+        if (state != null) {\n+            Arrays.fill(state, (byte)0);\n+        }\n+        state = null;\n+        if (remainder != null) {\n+            Arrays.fill(remainder, (byte)0);\n+        }\n+        remainder = null;\n+        remCount = 0;\n+    }\n+\n+    @Override\n+    public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+        objLock.lock();\n+        if (clearStateOnCheckpoint) {\n+            invalidate();\n+        }\n+    }\n+\n+    @Override\n+    public void afterRestore(Context<? extends Resource> context) throws Exception {\n+        objLock.unlock();\n+    }\n+\n+    @Override\n+    public int getPriority() {\n+        return -11;\n+    }\n+\n@@ -199,2 +243,1 @@\n-    private static class SeederHolder {\n-\n+    private static class SeederHolder implements jdk.internal.crac.JDKResource {\n@@ -202,0 +245,1 @@\n+        private ReentrantLock objLock = new ReentrantLock();\n@@ -209,1 +253,1 @@\n-            byte [] b = new byte[DIGEST_SIZE];\n+            byte[] b = new byte[DIGEST_SIZE];\n@@ -212,0 +256,23 @@\n+            jdk.internal.crac.Core.getJDKContext().register(new SeederHolder());\n+        }\n+\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+            objLock.lock();\n+            seeder.invalidate();\n+        }\n+\n+        @Override\n+        public void afterRestore(Context<? extends Resource> context) throws Exception {\n+            try {\n+                byte[] b = new byte[DIGEST_SIZE];\n+                SeedGenerator.generateSeed(b);\n+                seeder.engineSetSeed(b);\n+            } finally {\n+                objLock.unlock();\n+            }\n+        }\n+\n+        @Override\n+        public int getPriority() {\n+            return -12;\n@@ -221,10 +288,6 @@\n-    public synchronized void engineNextBytes(byte[] result) {\n-        int index = 0;\n-        int todo;\n-        byte[] output = remainder;\n-\n-        if (state == null) {\n-            byte[] seed = new byte[DIGEST_SIZE];\n-            SeederHolder.seeder.engineNextBytes(seed);\n-            state = digest.digest(seed);\n-        }\n+    public void engineNextBytes(byte[] result) {\n+        objLock.lock();\n+        try {\n+            int index = 0;\n+            int todo;\n+            byte[] output = remainder;\n@@ -232,5 +295,10 @@\n-        \/\/ Use remainder from last time\n-        int r = remCount;\n-        if (r > 0) {\n-            \/\/ How many bytes?\n-            todo = (result.length - index) < (DIGEST_SIZE - r) ?\n+            if (state == null) {\n+                byte[] seed = new byte[DIGEST_SIZE];\n+                SeederHolder.seeder.engineNextBytes(seed);\n+                state = digest.digest(seed);\n+            }\n+            \/\/ Use remainder from last time\n+            int r = remCount;\n+            if (r > 0) {\n+                \/\/ How many bytes?\n+                todo = (result.length - index) < (DIGEST_SIZE - r) ?\n@@ -238,4 +306,7 @@\n-            \/\/ Copy the bytes, zero the buffer\n-            for (int i = 0; i < todo; i++) {\n-                result[i] = output[r];\n-                output[r++] = 0;\n+                \/\/ Copy the bytes, zero the buffer\n+                for (int i = 0; i < todo; i++) {\n+                    result[i] = output[r];\n+                    output[r++] = 0;\n+                }\n+                remCount += todo;\n+                index += todo;\n@@ -243,10 +314,0 @@\n-            remCount += todo;\n-            index += todo;\n-        }\n-\n-        \/\/ If we need more bytes, make them.\n-        while (index < result.length) {\n-            \/\/ Step the state\n-            digest.update(state);\n-            output = digest.digest();\n-            updateState(state, output);\n@@ -254,7 +315,15 @@\n-            \/\/ How many bytes?\n-            todo = (result.length - index) > DIGEST_SIZE ?\n-                DIGEST_SIZE : result.length - index;\n-            \/\/ Copy the bytes, zero the buffer\n-            for (int i = 0; i < todo; i++) {\n-                result[index++] = output[i];\n-                output[i] = 0;\n+            \/\/ If we need more bytes, make them.\n+            while (index < result.length) {\n+                \/\/ Step the state\n+                digest.update(state);\n+                output = digest.digest();\n+                updateState(state, output);\n+                \/\/ How many bytes?\n+                todo = (result.length - index) > DIGEST_SIZE ?\n+                        DIGEST_SIZE : result.length - index;\n+                \/\/ Copy the bytes, zero the buffer\n+                for (int i = 0; i < todo; i++) {\n+                    result[index++] = output[i];\n+                    output[i] = 0;\n+                }\n+                remCount += todo;\n@@ -262,2 +331,0 @@\n-            remCount += todo;\n-        }\n@@ -265,3 +332,6 @@\n-        \/\/ Store remainder for next time\n-        remainder = output;\n-        remCount %= DIGEST_SIZE;\n+            \/\/ Store remainder for next time\n+            remainder = output;\n+            remCount %= DIGEST_SIZE;\n+        } finally {\n+            objLock.unlock();\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/SecureRandom.java","additions":122,"deletions":52,"binary":false,"changes":174,"status":"modified"},{"patch":"@@ -0,0 +1,157 @@\n+\/\/ Copyright 2019-2021 Azul Systems, Inc.  All Rights Reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it under\n+\/\/ the terms of the GNU General Public License version 2 only, as published by\n+\/\/ the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n+\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n+\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n+\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version 2\n+\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n+\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n+\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n+\/\/ have any questions.\n+\n+\n+import jdk.crac.*;\n+import java.util.Random;\n+import java.security.SecureRandom;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+public class Test implements Resource {\n+\n+    private static final AtomicLong counter = new AtomicLong(0);\n+    private static boolean stop = false;\n+    private static final long MIN_TIMEOUT = 100;\n+    private static final long MAX_TIMEOUT = 1000;\n+    private static SecureRandom sr;\n+\n+    private static class TestThread1 extends Thread {\n+        private long timeout;\n+\n+        TestThread1(long timeout) {\n+            this.timeout = timeout;\n+        }\n+\n+        @Override\n+        public void run() {\n+            while (!stop) {\n+                Test.set();\n+            }\n+        }\n+    };\n+\n+    private static class TestThread2 extends Thread implements Resource {\n+        private long timeout;\n+        private SecureRandom sr;\n+\n+        synchronized void set() {\n+            sr.nextInt();\n+        }\n+        synchronized void clean() {\n+            sr.nextInt();\n+        }\n+\n+        TestThread2(long timeout) throws Exception {\n+            this.timeout = timeout;\n+            sr = SecureRandom.getInstance(\"SHA1PRNG\");\n+            Core.getGlobalContext().register(this);\n+        }\n+\n+        @Override\n+        public void run() {\n+            while (!stop) {\n+                set();\n+            }\n+        }\n+\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+            clean();\n+        }\n+\n+        @Override\n+        public void afterRestore(Context<? extends Resource> context) throws Exception {\n+            set();\n+        }\n+    };\n+\n+    synchronized static void clean() {\n+        sr.nextInt();\n+    }\n+\n+    synchronized static void set() {\n+        sr.nextInt();\n+    }\n+\n+    @Override\n+    public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+        try {\n+            clean();\n+        } catch(Exception e) {\n+            e.printStackTrace(System.out);\n+        };\n+    }\n+\n+    @Override\n+    public void afterRestore(Context<? extends Resource> context) throws Exception {\n+        set();\n+        stop = true;\n+    }\n+\n+    public static void main(String args[]) throws Exception {\n+        if (args.length < 1) { throw new RuntimeException(\"number of threads is missing\"); }\n+        int numThreads;\n+        try{\n+            numThreads = Integer.parseInt(args[0]);\n+        } catch (NumberFormatException ex){\n+            throw new RuntimeException(\"invalid number of threads\");\n+        }\n+        Test test = new Test();\n+        test.sr = SecureRandom.getInstance(\"SHA1PRNG\");\n+        Core.getGlobalContext().register(test);\n+\n+        Random random = new Random();\n+        Thread[] threads = new Thread[numThreads];\n+        for(int i=0; i<numThreads; i++) {\n+            threads[i] = (i%2==0)?\n+                    new TestThread1(random.nextLong(MAX_TIMEOUT - MIN_TIMEOUT) + MIN_TIMEOUT):\n+                    new TestThread2(random.nextLong(MAX_TIMEOUT - MIN_TIMEOUT) + MIN_TIMEOUT);\n+            threads[i].start();\n+        };\n+        Thread.currentThread().sleep(MIN_TIMEOUT);\n+        set();\n+        Thread.currentThread().sleep(MIN_TIMEOUT);\n+\n+        Object checkpointLock = new Object();\n+        Thread checkpointThread = new Thread(\"checkpointThread\") {\n+            public void run() {\n+                synchronized (checkpointLock) {\n+                    try {\n+                        jdk.crac.Core.checkpointRestore();\n+                    } catch (CheckpointException e) {\n+                        throw new RuntimeException(\"Checkpoint ERROR \" + e);\n+                    } catch (RestoreException e) {\n+                        throw new RuntimeException(\"Restore ERROR \" + e);\n+                    }\n+                    checkpointLock.notify();\n+                }\n+            }\n+        };\n+        synchronized (checkpointLock) {\n+            try {\n+                checkpointThread.start();\n+                checkpointLock.wait(MAX_TIMEOUT * 2);\n+            } catch(Exception e){\n+                throw new RuntimeException(\"Checkpoint\/Restore ERROR \" + e);\n+            }\n+        }\n+        Thread.currentThread().sleep(MAX_TIMEOUT);\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/SecureRandom\/Test.java","additions":157,"deletions":0,"binary":false,"changes":157,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+#!\/bin\/sh\n+\n+# Copyright 2019-2021 Azul Systems, Inc.  All Rights Reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it under\n+# the terms of the GNU General Public License version 2 only, as published by\n+# the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT ANY\n+# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n+# A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n+# details (a copy is included in the LICENSE file that accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version 2\n+# along with this work; if not, write to the Free Software Foundation, Inc.,\n+# 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n+# CA 94089 USA or visit www.azul.com if you need additional information or\n+# have any questions.\n+\n+\n+##\n+## @test Test.sh\n+## @summary verify that secure random is not interlocked during checkpoint\/restore\n+## @compile Test.java\n+## @run shell\/timeout=60 Test.sh\n+##\n+\n+set -x\n+\n+set +e\n+${TESTJAVA}\/bin\/java -cp ${TESTCLASSPATH} -XX:CRaCCheckpointTo=cr Test 100\n+e=$?\n+\n+set -e\n+[ $e -eq 137 ]\n+\n+${TESTJAVA}\/bin\/java -cp ${TESTCLASSPATH} -XX:CRaCRestoreFrom=cr Test 100\n+\n+echo PASSED\n","filename":"test\/jdk\/jdk\/crac\/SecureRandom\/Test.sh","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+\/\/ Copyright 2019-2021 Azul Systems, Inc.  All Rights Reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it under\n+\/\/ the terms of the GNU General Public License version 2 only, as published by\n+\/\/ the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n+\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n+\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n+\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version 2\n+\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n+\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n+\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n+\/\/ have any questions.\n+\n+\n+import jdk.crac.*;\n+import java.security.SecureRandom;\n+\n+public class Test1 {\n+\n+    private static SecureRandom sr;\n+\n+    public static void main(String args[]) throws Exception {\n+        SecureRandom sr = SecureRandom.getInstance(\"SHA1PRNG\");\n+        if (\"1\".equalsIgnoreCase(args[0])) {\n+            sr.setSeed(sr.generateSeed(10));\n+        }\n+        sr.nextInt();\n+\n+        try {\n+            jdk.crac.Core.checkpointRestore();\n+        } catch (CheckpointException e) {\n+            e.printStackTrace(System.out);\n+            throw new RuntimeException(\"Checkpoint ERROR \" + e);\n+        } catch (RestoreException e) {\n+            throw new RuntimeException(\"Restore ERROR \" + e);\n+        }\n+\n+        int r = sr.nextInt(255);\n+        System.exit(r);\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/SecureRandom\/Test1.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+#!\/bin\/sh\n+\n+# Copyright 2019-2021 Azul Systems, Inc.  All Rights Reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it under\n+# the terms of the GNU General Public License version 2 only, as published by\n+# the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT ANY\n+# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n+# A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n+# details (a copy is included in the LICENSE file that accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version 2\n+# along with this work; if not, write to the Free Software Foundation, Inc.,\n+# 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n+# CA 94089 USA or visit www.azul.com if you need additional information or\n+# have any questions.\n+\n+\n+##\n+## @test Test1.sh\n+## @summary verify that SHA1PRNG secure random is reseeded after restore if\n+##  initialized with default seed\n+## @compile Test1.java\n+## @run shell\/timeout=60 Test.sh\n+##\n+\n+set -x\n+\n+export TESTJAVA=\/home\/parallels\/Work\/CRAC\/jdk\n+export TESTCLASSPATH=.\n+\n+set +e\n+for test in `seq 0 1`\n+do\n+\n+    ${TESTJAVA}\/bin\/java -cp ${TESTCLASSPATH} -XX:CRaCCheckpointTo=cr Test1 $test\n+    e=$?\n+\n+    [ $e -eq 137 ]\n+\n+    ${TESTJAVA}\/bin\/java -cp ${TESTCLASSPATH} -XX:CRaCRestoreFrom=cr Test1 $test\n+    e1=$?\n+\n+    ${TESTJAVA}\/bin\/java -cp ${TESTCLASSPATH} -XX:CRaCRestoreFrom=cr Test1 $test\n+    e2=$?\n+\n+    if [ $test == \"0\" ]; then\n+        if [ $e1 == $e2 ]; then\n+            echo FAILED\n+            exit 1\n+        fi\n+    else \n+        if [ $e1 != $e2 ]; then\n+            echo FAILED\n+            exit 1\n+        fi\n+    fi\n+done\n+echo PASSED\n","filename":"test\/jdk\/jdk\/crac\/SecureRandom\/Test1.sh","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"}]}