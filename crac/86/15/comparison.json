{"files":[{"patch":"@@ -2100,0 +2100,4 @@\n+  product(uint, CRaCMinPid, 128,                                            \\\n+      \"Mininal PID value for checkpoint'ed process\")                        \\\n+      range(1, UINT_MAX)                                                    \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1328,0 +1328,5 @@\n+.B \\f[CB]\\-XX:CRaCMinPid=\\f[R]value\\f[R]\n+A desired minimal PID value for checkpoint'ed process. Ignored on restore.\n+.RS\n+.RE\n+.TP\n","filename":"src\/java.base\/share\/man\/java.1","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -37,0 +37,7 @@\n+#ifndef WIN32\n+#include <errno.h>\n+#endif\n+#ifdef LINUX\n+#include <syscall.h>\n+#endif\n+\n@@ -100,0 +107,3 @@\n+static const int crac_min_pid_default = 128;\n+static int crac_min_pid = 0;\n+static int is_min_pid_set = 0;\n@@ -109,0 +119,8 @@\n+    if (!is_min_pid_set) {\n+        const char *checkpoint_arg = \"-XX:CRaCMinPid=\";\n+        const int len = strlen(checkpoint_arg);\n+        if (0 == strncmp(arg, checkpoint_arg, len)) {\n+            crac_min_pid = atoi(arg + len);\n+            is_min_pid_set = 1;\n+        }\n+    }\n@@ -170,0 +188,55 @@\n+static int set_last_pid(int pid) {\n+#ifdef LINUX\n+    char buf[11]; \/\/ enough for int32\n+    const int len = snprintf(buf, sizeof(buf), \"%d\", pid);\n+    if (0 > len || sizeof(buf) < (size_t)len) {\n+        return EINVAL;\n+    }\n+    const char *last_pid_filename = \"\/proc\/sys\/kernel\/ns_last_pid\";\n+    const int last_pid_file = open(last_pid_filename, O_WRONLY|O_TRUNC, 0666);\n+    if (0 > last_pid_file) {\n+        return errno;\n+    }\n+    int res = 0;\n+    if (len > write(last_pid_file, buf, len)) {\n+        res = errno;\n+    }\n+    close(last_pid_file);\n+    return res;\n+#else\n+    return EPERM;\n+#endif\n+}\n+\n+static void spin_last_pid(int pid) {\n+    const int MaxSpinCount = pid < 1000 ? 1000 : pid;\n+    int cnt = MaxSpinCount;\n+    int child = 0;\n+    int prev = 0;\n+    do {\n+        child = fork();\n+        if (0 > child) {\n+            perror(\"spin_last_pid clone\");\n+            exit(1);\n+        }\n+        if (0 == child) {\n+            exit(0);\n+        }\n+        if (child < prev) {\n+            fprintf(stderr, \"%s: Invalid argument (%d)\\n\", __FUNCTION__, pid);\n+            exit(1);\n+        }\n+        if (0 >= cnt) {\n+            fprintf(stderr, \"%s: Can't reach pid %d, out of try count. Current pid=%d\\n\", __FUNCTION__, pid, child);\n+            exit(1);\n+        }\n+        prev = child;\n+        int status;\n+        if (0 > waitpid(child, &status, 0)) {\n+            perror(\"spin_last_pid waitpid\");\n+            exit(1);\n+        }\n+        --cnt;\n+    } while (child < pid);\n+}\n+\n@@ -281,3 +354,20 @@\n-    \/\/ Avoid unexpected process completion when checkpointing under docker container run\n-    \/\/ by creating the main process waiting for children before exit.\n-    if (is_checkpoint && 1 == getpid()) {\n+    const int is_init = 1 == getpid();\n+    if (is_init && !is_min_pid_set) {\n+        crac_min_pid = crac_min_pid_default;\n+    }\n+    const int needs_pid_adjust = getpid() < crac_min_pid;\n+    if (is_checkpoint && (is_init || needs_pid_adjust)) {\n+        \/\/ Move PID value for new processes to a desired value\n+        \/\/ to avoid PID conflicts on restore.\n+        if (needs_pid_adjust) {\n+            const int res = set_last_pid(crac_min_pid);\n+            if (EPERM == res || EACCES == res || EROFS == res) {\n+                spin_last_pid(crac_min_pid);\n+            } else if (0 != res) {\n+                fprintf(stderr, \"set_last_pid: %s\\n\", strerror(res));\n+                exit(1);\n+            }\n+        }\n+\n+        \/\/ Avoid unexpected process completion when checkpointing under docker container run\n+        \/\/ by creating the main process waiting for children before exit.\n@@ -285,0 +375,11 @@\n+        if (0 == g_child_pid && needs_pid_adjust && getpid() < crac_min_pid) {\n+            if (is_min_pid_set) {\n+                fprintf(stderr, \"Error: Can't adjust PID to min PID %d, current PID %d\\n\", crac_min_pid, (int)getpid());\n+                exit(1);\n+            } else {\n+                fprintf(stderr,\n+                        \"Warning: Can't adjust PID to min PID %d, current PID %d.\\n\"\n+                        \"This message can be suppressed by '-XX:CRaCMinPid=1' option\\n\",\n+                        crac_min_pid, (int)getpid());\n+            }\n+        }\n","filename":"src\/java.base\/share\/native\/launcher\/main.c","additions":104,"deletions":3,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -0,0 +1,125 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale\n+ * CA 94089 USA or visit www.azul.com if you need additional information or\n+ * have any questions.\n+ *\/\n+\n+import jdk.test.lib.containers.docker.DockerTestUtils;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracProcess;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+import static jdk.test.lib.Asserts.assertLessThan;\n+\n+import java.util.Arrays;\n+\n+\/*\n+ * @test ContainerPidAdjustmentTest\n+ * @summary The test checks that process PID is adjusted with the specified value, when checkpointing in a container. Default min PID value is 128.\n+ * @requires (os.family == \"linux\")\n+ * @library \/test\/lib\n+ * @build ContainerPidAdjustmentTest\n+ * @run driver\/timeout=60 jdk.test.lib.crac.CracTest  true   false  INF     true   128\n+ * @run driver\/timeout=60 jdk.test.lib.crac.CracTest  true   true   1       false  1\n+ * @run driver\/timeout=60 jdk.test.lib.crac.CracTest  true   true   100     true   100\n+ * @run driver\/timeout=60 jdk.test.lib.crac.CracTest  false  false  INF     false  1\n+ * @run driver\/timeout=60 jdk.test.lib.crac.CracTest  false  true   1       false  1\n+ * @run driver\/timeout=60 jdk.test.lib.crac.CracTest  false  true   1       true   1\n+ * @run driver\/timeout=60 jdk.test.lib.crac.CracTest  false  true   200     true   200\n+ * @run driver\/timeout=60 jdk.test.lib.crac.CracTest  false  true   1000    false  1000\n+ * @run driver\/timeout=60 jdk.test.lib.crac.CracTest  false  true   2000    true   2000   1000\n+ * @run driver\/timeout=60 jdk.test.lib.crac.CracTest  false  true   0       true   -1\n+ * @run driver\/timeout=60 jdk.test.lib.crac.CracTest  false  true   -10     true   -1\n+ * @run driver\/timeout=60 jdk.test.lib.crac.CracTest  false  true   blabla  true   -1\n+ * @run driver\/timeout=60 jdk.test.lib.crac.CracTest  false  true   5000000 true   -1\n+ * @run driver\/timeout=60 jdk.test.lib.crac.CracTest  false  true   5000000 true   -1     4194200\n+ * @run driver\/timeout=60 jdk.test.lib.crac.CracTest  false  true   4194303 true   -1\n+\n+ *\/\n+public class ContainerPidAdjustmentTest implements CracTest {\n+    @CracTestArg(0)\n+    boolean runDirectly;\n+\n+    @CracTestArg(1)\n+    boolean needSetMinPid;\n+\n+    @CracTestArg(2)\n+    String lastPid;\n+\n+    @CracTestArg(3)\n+    boolean usePrivilegedContainer;\n+\n+    @CracTestArg(4)\n+    long expectedLastPid;\n+\n+    @CracTestArg(value = 5, optional = true)\n+    String lastPidSetup;\n+\n+    final private String CURRENT_PID_MESSAGE = \"Current PID = \";\n+\n+    @Override\n+    public void test() throws Exception {\n+        if (!DockerTestUtils.canTestDocker()) {\n+            return;\n+        }\n+        CracBuilder builder = new CracBuilder()\n+            .inDockerImage(\"pid-adjustment\")\n+            .runContainerDirectly(runDirectly)\n+            .containerUsePrivileged(usePrivilegedContainer);\n+        if (needSetMinPid) {\n+            builder.vmOption(\"-XX:CRaCMinPid=\" + lastPid);\n+        }\n+        if (0 > expectedLastPid) {\n+            builder.captureOutput(true);\n+        }\n+        if (null != lastPidSetup) {\n+            \/\/ Set up the initial last pid,\n+            \/\/ create a non-privileged user,\n+            \/\/ and force spinning the last pid running checkpoint under the user.\n+            builder\n+                .containerSetup(Arrays.asList(\"bash\", \"-c\", \"useradd the_user && echo \" + lastPidSetup + \" >\/proc\/sys\/kernel\/ns_last_pid\"))\n+                .dockerCheckpointOptions(Arrays.asList(\"-u\", \"the_user\"));\n+        }\n+\n+        if (0 < expectedLastPid) {\n+            builder.startCheckpoint().waitForSuccess();\n+        } else {\n+            final int expectedExitValue = (int)java.lang.Math.abs(expectedLastPid);\n+            CracProcess process = builder.startCheckpoint();\n+            final int exitValue = process.waitFor();\n+            assertEquals(expectedExitValue, exitValue, \"Process returned unexpected exit code: \" + exitValue);\n+            OutputAnalyzer oa = process.outputAnalyzer();\n+            oa.shouldNotContain(CURRENT_PID_MESSAGE);\n+            if (null != lastPidSetup) {\n+                oa.shouldContain(\"spin_last_pid: Invalid argument (\" + lastPid + \")\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        System.out.println(CURRENT_PID_MESSAGE + ProcessHandle.current().pid());\n+        assertLessThan((long)0, expectedLastPid, \"Shouldn't happen\");\n+        assertLessThan(expectedLastPid, ProcessHandle.current().pid());\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/ContainerPidAdjustmentTest.java","additions":125,"deletions":0,"binary":false,"changes":125,"status":"added"},{"patch":"@@ -68,0 +68,1 @@\n+            builder.vmOption(\"-XX:CRaCMinPid=100\");\n@@ -81,0 +82,1 @@\n+            builder.clearVmOptions();\n","filename":"test\/jdk\/jdk\/crac\/java\/net\/InetAddress\/ResolveTest.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,0 +49,4 @@\n+    private List<String> dockerCheckpointOptions;\n+    boolean containerUsePrivileged = true;\n+    private List<String> containerSetupCommand;\n+    boolean runContainerDirectly = false;\n@@ -86,0 +90,4 @@\n+        other.dockerCheckpointOptions = dockerCheckpointOptions;\n+        other.containerUsePrivileged = containerUsePrivileged;\n+        other.containerSetupCommand = containerSetupCommand;\n+        other.runContainerDirectly = runContainerDirectly;\n@@ -99,0 +107,20 @@\n+    public CracBuilder dockerCheckpointOptions(List<String> options) {\n+        this.dockerCheckpointOptions = options;\n+        return this;\n+    }\n+\n+    public CracBuilder containerSetup(List<String> cmd) {\n+        this.containerSetupCommand = cmd;\n+        return this;\n+    }\n+\n+    public CracBuilder containerUsePrivileged(boolean usePrivileged) {\n+        this.containerUsePrivileged = usePrivileged;\n+        return this;\n+    }\n+\n+    public CracBuilder runContainerDirectly(boolean runDirectly) {\n+        this.runContainerDirectly = runDirectly;\n+        return this;\n+    }\n+\n@@ -200,1 +228,5 @@\n-        ensureContainerStarted();\n+        if (runContainerDirectly) {\n+            prepareContainer();\n+        } else {\n+            ensureContainerStarted();\n+        }\n@@ -228,5 +260,1 @@\n-            ensureContainerKilled();\n-            buildDockerImage();\n-            FileUtils.deleteFileTreeWithRetry(Path.of(\".\", \"jdk-docker\"));\n-            \/\/ Make sure we start with a clean image directory\n-            DockerTestUtils.execute(Container.ENGINE_COMMAND, \"volume\", \"rm\", \"cr\");\n+            prepareContainer();\n@@ -236,0 +264,1 @@\n+            containerSetup();\n@@ -240,0 +269,21 @@\n+    private void prepareContainer() throws Exception {\n+        if (runContainerDirectly && null != containerSetupCommand) {\n+            fail(\"runContainerDirectly and containerSetupCommand cannot be used together.\");\n+        }\n+        ensureContainerKilled();\n+        buildDockerImage();\n+        FileUtils.deleteFileTreeWithRetry(Path.of(\".\", \"jdk-docker\"));\n+        \/\/ Make sure we start with a clean image directory\n+        DockerTestUtils.execute(Container.ENGINE_COMMAND, \"volume\", \"rm\", \"cr\");\n+    }\n+\n+    private void containerSetup() throws Exception {\n+        if (null != containerSetupCommand && 0 < containerSetupCommand.size()) {\n+            List<String> cmd = new ArrayList<>();\n+            cmd.addAll(Arrays.asList(Container.ENGINE_COMMAND, \"exec\", CONTAINER_NAME));\n+            cmd.addAll(containerSetupCommand);\n+            log(\"Container set up:\\n\" + String.join(\" \", cmd));\n+            DockerTestUtils.execute(cmd).shouldHaveExitValue(0);\n+        }\n+    }\n+\n@@ -267,1 +317,1 @@\n-    private List<String> prepareContainerCommand(String imageName, String[] options) {\n+    private List<String> prepareContainerCommandBase(String imageName, String[] options) {\n@@ -270,3 +320,8 @@\n-        cmd.addAll(Arrays.asList(\"run\", \"--rm\", \"-d\"));\n-        cmd.add(\"--privileged\"); \/\/ required to give CRIU sufficient permissions\n-        cmd.add(\"--init\"); \/\/ otherwise the checkpointed process would not be reaped (by sleep with PID 1)\n+        cmd.addAll(Arrays.asList(\"run\", \"--rm\"));\n+        if (!runContainerDirectly) {\n+            cmd.add(\"-d\");\n+            cmd.add(\"--init\"); \/\/ otherwise the checkpointed process would not be reaped (by sleep with PID 1)\n+        }\n+        if (containerUsePrivileged) {\n+            cmd.add(\"--privileged\"); \/\/ required to give CRIU sufficient permissions\n+        }\n@@ -288,0 +343,5 @@\n+        return cmd;\n+    }\n+\n+    private List<String> prepareContainerCommand(String imageName, String[] options) {\n+        List<String> cmd = prepareContainerCommandBase(imageName, options);\n@@ -299,2 +359,0 @@\n-        String minPid = DockerTestUtils.execute(Container.ENGINE_COMMAND, \"exec\", CONTAINER_NAME,\n-                \"cat\", \"\/proc\/sys\/kernel\/ns_last_pid\").getStdout().trim();\n@@ -305,6 +363,0 @@\n-        \/\/ We need to cycle PIDs; had we tried to restore right away the exec would get the\n-        \/\/ same PIDs and restore would fail.\n-        log(\"Cycling PIDs until %s%n\", minPid);\n-        DockerTestUtils.execute(Container.ENGINE_COMMAND, \"exec\",\n-                CONTAINER_NAME, \"bash\", \"-c\",\n-                \"while [ $(cat \/proc\/sys\/kernel\/ns_last_pid) -le \" + minPid + \" ]; do cat \/dev\/null; done\");\n@@ -372,1 +424,10 @@\n-            cmd.addAll(Arrays.asList(Container.ENGINE_COMMAND, \"exec\", CONTAINER_NAME));\n+            if (runContainerDirectly) {\n+                cmd = prepareContainerCommandBase(dockerImageName, dockerOptions);\n+            } else {\n+                cmd.add(Container.ENGINE_COMMAND);\n+                cmd.add(\"exec\");\n+                if (null != dockerCheckpointOptions) {\n+                    cmd.addAll(dockerCheckpointOptions);\n+                }\n+                cmd.add(CONTAINER_NAME);\n+            }\n","filename":"test\/lib\/jdk\/test\/lib\/crac\/CracBuilder.java","additions":80,"deletions":19,"binary":false,"changes":99,"status":"modified"}]}