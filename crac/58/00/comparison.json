{"files":[{"patch":"@@ -38,0 +38,5 @@\n+JVM_ThreadListAllocate\n+JVM_ThreadListDestroy\n+JVM_ThreadListRemoveSelf\n+JVM_ThreadListLength\n+JVM_RCU_SynchronizeThreads\n\\ No newline at end of file\n","filename":"make\/data\/hotspot-symbols\/symbols-shared","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1154,0 +1154,15 @@\n+JNIEXPORT void* JNICALL\n+JVM_ThreadListAllocate();\n+\n+JNIEXPORT void JNICALL\n+JVM_ThreadListDestroy(void *addr);\n+\n+JNIEXPORT void JNICALL\n+JVM_ThreadListRemoveSelf(void *addr);\n+\n+JNIEXPORT jint JNICALL\n+JVM_ThreadListLength(const void *addr);\n+\n+JNIEXPORT void JNICALL\n+JVM_RCU_SynchronizeThreads(void *addr, const char **methods);\n+\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -3864,0 +3864,85 @@\n+\n+typedef GrowableArrayCHeap<JavaThread *, mtSynchronizer>* ThreadList;\n+\n+JVM_LEAF(void *, JVM_ThreadListAllocate())\n+  return new GrowableArrayCHeap<JavaThread *, mtSynchronizer>(16);\n+JVM_END\n+\n+JVM_LEAF(void, JVM_ThreadListDestroy(void *addr))\n+  delete ((ThreadList) addr);\n+JVM_END\n+\n+JVM_LEAF(void, JVM_ThreadListRemoveSelf(void *addr))\n+  ThreadList list = ((ThreadList) addr);\n+  Thread *self = Thread::current();\n+  \/\/ We can't use remove_if_existing because the signature won't match\n+  for (int i = 0; i < list->length(); ++i) {\n+    if (list->at(i) == self) {\n+      list->delete_at(i);\n+      return;\n+    }\n+  }\n+JVM_END\n+\n+JVM_LEAF(jint, JVM_ThreadListLength(const void *addr))\n+  ThreadList list = (ThreadList) addr;\n+  return list->length();\n+JVM_END\n+\n+class VM_RCU_Synchronize: public VM_Operation {\n+  ThreadList _reader_threads;\n+  const char **_method_list;\n+public:\n+  VM_RCU_Synchronize(ThreadList reader_threads, const char **method_list):\n+    _reader_threads(reader_threads),\n+    _method_list(method_list)\n+  {\n+    assert(reader_threads != NULL, \"Reader threads not allocated\");\n+    assert(method_list != NULL, \"No methods?\");\n+  }\n+\n+  VMOp_Type type() const { return VMOp_VM_RCU_Synchronize; }\n+  void doit();\n+};\n+\n+JVM_ENTRY_NO_ENV(void, JVM_RCU_SynchronizeThreads(void *addr, const char **methods))\n+  VM_RCU_Synchronize sync((ThreadList) addr, methods);\n+  VMThread::execute(&sync);\n+JVM_END\n+\n+void VM_RCU_Synchronize::doit() {\n+  SafeThreadsListPtr listPtr(Thread::current(), true);\n+  ThreadsList *list = listPtr.list();\n+  assert(list != NULL, \"Thread list is null\");\n+  for (uint i = 0; i < list->length(); ++i) {\n+    JavaThread* t = list->thread_at(i);\n+    assert(t != NULL, \"Thread is null\");\n+    if (t->has_last_Java_frame()) {\n+      RegisterMap reg_map(t);\n+      vframe* start_vf = t->last_java_vframe(&reg_map);\n+      bool match = false;\n+      for (vframe* f = start_vf; f != NULL && !match; f = f->sender() ) {\n+        if (f->is_java_frame()) {\n+          javaVFrame* jvf = javaVFrame::cast(f);\n+          ResourceMark rm;\n+          const char *method = jvf->method()->name_and_sig_as_C_string();\n+          \/\/ TODO: let's assume the list is sorted and use binary search\n+          for (const char **m = _method_list; *m != NULL; ++m) {\n+            if (strcmp(*m, method) == 0) {\n+#ifndef PROD\n+              for (int j = 0; j < _reader_threads->length(); ++j) {\n+                assert(t != _reader_threads->at(j), \"Thread already in the list\");\n+              }\n+#endif \/\/PROD\n+              _reader_threads->append(t);\n+              match = true;\n+              break;\n+            }\n+          }\n+        }\n+      }\n+    }\n+  }\n+}\n+\n+\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":85,"deletions":0,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -113,1 +113,2 @@\n-  template(VM_Crac)\n+  template(VM_Crac)                               \\\n+  template(VM_RCU_Synchronize)\n","filename":"src\/hotspot\/share\/runtime\/vmOperation.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,255 @@\n+package jdk.crac;\n+\n+import jdk.internal.ref.CleanerFactory;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+import java.lang.invoke.*;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.concurrent.locks.Condition;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+\n+\/**\n+ * This class represents a RW-lock with extremely lightweight read-locking\n+ * and heavyweight write locking.\n+ * <p>\n+ * Readers should use the {@link #readLock()} and {@link #readUnlock()}; when\n+ * the writer lock is not locked these are similar to calling no-op methods.\n+ * The lock needs a declaration of all read-critical (top-level) methods;\n+ * contrary to the regular synchronization pattern we need to\n+ * <strong>acquire<\/strong> the read-lock <strong>inside<\/strong> the critical\n+ * section (at the beginning) and <strong>release<\/strong> it <strong>outside<\/strong>,\n+ * preferrably in the <code>finally<\/code> block.\n+ * Therefore, the code should be normally separated into wrapper and implementation method:\n+ * <hr><blockquote><pre>\n+ *   public void wrapper() {\n+ *       try {\n+ *           implementation();\n+ *       } finally {\n+ *           lock.readUnlock();\n+ *       }\n+ *   }\n+ *\n+ *   &#64;RCULock.Critical\n+ *   public void implementation() {\n+ *       lock.readLock();\n+ *       \/\/ critical code ...\n+ *   }\n+ * <\/pre><\/blockquote><hr>\n+ * In the example above the {@link RCULock.Critical} annotation would be used\n+ * in the {@link #forClasses(Class[])} factory method; alternatively you can\n+ * declare the methods (or their signatures) using one of the constructors.\n+ * <p>\n+ * There should be at most one writer invoking the {@link #synchronizeBegin()}\n+ * and {@link #synchronizeEnd()} pair. This operation requires all Java threads\n+ * to block in safepoint to inspect their stack; if the stack contains one of\n+ * the read-critical methods the thread acquires read-ownership even if\n+ * the actual <code>readLock()<\/code> invocation was a no-op.\n+ *\/\n+public class RCULock {\n+    private final ReentrantLock lock = new ReentrantLock(true);\n+    private final Condition beginCondition = lock.newCondition();\n+    private final Condition endCondition = lock.newCondition();\n+    private boolean synchronize;\n+    @SuppressWarnings(\"unused\") \/\/ used in native code\n+    private long readerThreadsList;\n+    @SuppressWarnings(\"unused\") \/\/ used in native code\n+    private long readCriticalMethods;\n+    private SwitchPoint lockSwitchPoint = new SwitchPoint();\n+    private SwitchPoint unlockSwitchPoint = new SwitchPoint();\n+    private volatile MethodHandle lockImpl;\n+    private volatile MethodHandle unlockImpl;\n+\n+    static {\n+        initFieldOffsets();\n+    }\n+\n+    private static native void initFieldOffsets();\n+\n+    \/**\n+     * Inspect the classes for all methods (including private ones) marked with\n+     * the {@link RCULock.Critical} annotation and create a lock that can protect\n+     * these methods with read lock.\n+     *\n+     * @param classes List of classes to be inspected.\n+     * @return New lock instance.\n+     *\/\n+    public static RCULock forClasses(Class<?>... classes) {\n+        ArrayList<Method> methods = new ArrayList<>();\n+        for (Class<?> cls : classes) {\n+            while (cls != null && cls != Object.class) {\n+                for (Method m : cls.getDeclaredMethods()) {\n+                    if (m.isAnnotationPresent(Critical.class)) {\n+                        methods.add(m);\n+                    }\n+                }\n+                cls = cls.getSuperclass();\n+            }\n+        }\n+        return new RCULock(methods);\n+    }\n+\n+    \/**\n+     * Create a lock that can protect selected methods with read-locking.\n+     *\n+     * @param readCriticalMethods List of methods with the read-critical section.\n+     *\/\n+    public RCULock(Iterable<Method> readCriticalMethods) {\n+        this(StreamSupport.stream(readCriticalMethods.spliterator(), false)\n+                .map(m -> m.getDeclaringClass().getName() + \".\" + m.getName() + \"(\" +\n+                Arrays.stream(m.getParameterTypes())\n+                        .map(Class::descriptorString).collect(Collectors.joining())\n+                + \")\" + m.getReturnType().descriptorString()).toArray(String[]::new));\n+    }\n+\n+    \/**\n+     * Create a lock that can protect selected methods with read-locking.\n+     * <p>\n+     * The signatures follow the form\n+     * <pre>my.package.MyClass.foobar(another\/package\/SomeClass;Z)V<\/pre>\n+     *\n+     * @param readCriticalMethods List of signatures for methods invoked in the read-critical section.\n+     *\/\n+    public RCULock(String[] readCriticalMethods) {\n+        initSwitchPoints();\n+        \/\/noinspection CapturingCleaner\n+        CleanerFactory.cleaner().register(this, this::destroy);\n+        Arrays.sort(readCriticalMethods);\n+        init(readCriticalMethods);\n+    }\n+\n+    private native void init(String[] readCriticalMethods);\n+\n+    private native void destroy();\n+\n+    private void initSwitchPoints() {\n+        try {\n+            MethodType voidType = MethodType.methodType(void.class);\n+            MethodHandle noop = MethodHandles.lookup().findSpecial(RCULock.class, \"noop\", voidType, RCULock.class);\n+            MethodHandle readLockImpl = MethodHandles.lookup().findSpecial(RCULock.class, \"readLockImpl\", voidType, RCULock.class);\n+            MethodHandle readUnlockImpl = MethodHandles.lookup().findSpecial(RCULock.class, \"readUnlockImpl\", voidType, RCULock.class);\n+            lockSwitchPoint = new SwitchPoint();\n+            lockImpl = lockSwitchPoint.guardWithTest(noop, readLockImpl);\n+            unlockSwitchPoint = new SwitchPoint();\n+            unlockImpl = lockSwitchPoint.guardWithTest(noop, readUnlockImpl);\n+        } catch (NoSuchMethodException | IllegalAccessException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private void noop() {\n+    }\n+\n+    \/**\n+     * Acquire the read-lock. This method <strong>must<\/strong> be called from\n+     * within the read-critical method declared when this lock is created.\n+     *\n+     * @implNote It is not possible to guarantee that the thread would jump into\n+     * the critical section right after <code>readLock()<\/code> without being spotted\n+     * in-between; therefore the implementation works even if <code>readLock()<\/code>\n+     * is called after the synchronizer thread finds it in the critical section.\n+     *\/\n+    public void readLock() {\n+        try {\n+            lockImpl.invokeExact(this);\n+        } catch (Throwable e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private void readLockImpl() {\n+        lock.lock();\n+        try {\n+            \/\/ In case that we have been caught in the critical section\n+            \/\/ before calling readLock() this thread was added to the list\n+            \/\/ but won't be removed as we will block.\n+            \/\/ After continuing in the critical section any subsequent\n+            \/\/ synchronizeBegin will catch us in again, so we don't need to\n+            \/\/ do anything.\n+            removeThread();\n+            \/\/ The lock is released as we are waiting for beginCondition\n+            while (synchronize) {\n+                endCondition.awaitUninterruptibly();\n+            }\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    \/**\n+     * Release the read-lock. This method must be called <strong>outside<\/strong>\n+     * the critical section, preferably in a <code>finally<\/code> block.\n+     *\/\n+    public void readUnlock() {\n+        try {\n+            unlockImpl.invokeExact(this);\n+        } catch (Throwable e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private void readUnlockImpl() {\n+        lock.lock();\n+        try {\n+            removeThread();\n+            beginCondition.signal();\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    private native void removeThread();\n+\n+    \/**\n+     * Acquire write-lock. It is illegal to call this method concurrently,\n+     * if you require to arbitrate the synchronizer thread use an external lock.\n+     * The lock should be later released using {@link #synchronizeEnd()}.\n+     *\/\n+    public void synchronizeBegin() {\n+        lock.lock();\n+        if (synchronize) {\n+            lock.unlock();\n+            throw new IllegalMonitorStateException(\"Concurrent synchronization or bug?\");\n+        }\n+        synchronize = true;\n+        SwitchPoint.invalidateAll(new SwitchPoint[]{ lockSwitchPoint, unlockSwitchPoint });\n+        synchronizeThreads();\n+        while (hasReaderThreads()) {\n+            beginCondition.awaitUninterruptibly();\n+        }\n+        \/\/ No unlocking here\n+    }\n+\n+    public native boolean hasReaderThreads();\n+\n+    public native void synchronizeThreads();\n+\n+    \/**\n+     * Release write-lock. This method can be called only by the thread that previously\n+     * successfully called {@link #synchronizeBegin()}.\n+     *\/\n+    public void synchronizeEnd() {\n+        if (!lock.isHeldByCurrentThread()) {\n+            throw new IllegalMonitorStateException(\"The lock is not held by \");\n+        }\n+        initSwitchPoints();\n+        synchronize = false;\n+        endCondition.signalAll();\n+        lock.unlock();\n+    }\n+\n+    \/**\n+     * Marks read-critical methods. This is used in combination with\n+     * the {@link #forClasses(Class[])} factory method.\n+     *\/\n+    @Target(ElementType.METHOD)\n+    @Retention(RetentionPolicy.RUNTIME)\n+    public @interface Critical {\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/RCULock.java","additions":255,"deletions":0,"binary":false,"changes":255,"status":"added"},{"patch":"@@ -0,0 +1,148 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/** \\file *\/\n+\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include \"jni.h\"\n+#include \"jvm.h\"\n+#include \"jni_util.h\"\n+#include \"jdk_crac_RCULock.h\"\n+\n+static jfieldID readerThreadsListField = NULL;\n+static jfieldID readCriticalMethodsField = NULL;\n+\n+JNIEXPORT void JNICALL\n+Java_jdk_crac_RCULock_initFieldOffsets(JNIEnv *env, jclass cls)\n+{\n+    readerThreadsListField = (*env)->GetFieldID(env, cls, \"readerThreadsList\", \"J\");\n+    readCriticalMethodsField = (*env)->GetFieldID(env, cls, \"readCriticalMethods\", \"J\");\n+}\n+\n+static void free_up_to(char **mem, uint limit) {\n+    for (uint i = 0; i < limit; ++i) {\n+        free(*(mem + i));\n+    }\n+    free(mem);\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_jdk_crac_RCULock_init(JNIEnv *env, jobject rcuLock, jobjectArray methods)\n+{\n+    void *threads = JVM_ThreadListAllocate();\n+    if (threads == NULL) {\n+        JNU_ThrowOutOfMemoryError(env, NULL);\n+        return;\n+    }\n+    (*env)->SetLongField(env, rcuLock, readerThreadsListField, (jlong) threads);\n+\n+    jsize num = (*env)->GetArrayLength(env, methods);\n+    char **c_methods = malloc(sizeof(char *) * (num + 1));\n+    if (c_methods == NULL) {\n+        JNU_ThrowOutOfMemoryError(env, NULL);\n+        return;\n+    }\n+    for (int i = 0; i < num; ++i) {\n+        jobject el = (*env)->GetObjectArrayElement(env, methods, i);\n+        if (el == NULL) {\n+            free_up_to(c_methods, i);\n+            JNU_ThrowNullPointerException(env, \"null signature\");\n+            return;\n+        }\n+        jsize len = (*env)->GetStringLength(env, el);\n+        const char *sig = (*env)->GetStringUTFChars(env, el, NULL);\n+        if (sig == NULL) {\n+            free_up_to(c_methods, i);\n+            JNU_ThrowNullPointerException(env, \"null signature\");\n+            return;\n+        }\n+        char *copy = malloc((len + 1) * sizeof(char));\n+        if (copy == NULL) {\n+            (*env)->ReleaseStringUTFChars(env, el, sig);\n+            free_up_to(c_methods, i);\n+            JNU_ThrowOutOfMemoryError(env, NULL);\n+            return;\n+        }\n+        strncpy(copy, sig, len + 1);\n+        (*env)->ReleaseStringUTFChars(env, el, sig);\n+        c_methods[i] = copy;\n+    }\n+    c_methods[num] = NULL;\n+#ifndef PROD\n+    \/\/ TODO: assert methods are sorted - note that we should mind UTF-8 format\n+#endif \/\/ !PROD\n+    (*env)->SetLongField(env, rcuLock, readCriticalMethodsField, (jlong) (void *) c_methods);\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_jdk_crac_RCULock_destroy(JNIEnv *env, jobject rcuLock)\n+{\n+    jlong threads = (*env)->GetLongField(env, rcuLock, readerThreadsListField);\n+    if (threads != 0) {\n+        JVM_ThreadListDestroy((void *) threads);\n+        (*env)->SetLongField(env, rcuLock, readerThreadsListField, 0);\n+    }\n+\n+    jlong methods = (*env)->GetLongField(env, rcuLock, readCriticalMethodsField);\n+    if (methods != 0) {\n+        char **m = (char **) (void *) methods;\n+        while (*m != NULL) {\n+            free(*m);\n+            ++m;\n+        }\n+        free(m);\n+        (*env)->SetLongField(env, rcuLock, readCriticalMethodsField, 0);\n+    }\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_jdk_crac_RCULock_removeThread(JNIEnv *env, jobject rcuLock)\n+{\n+    jlong addr = (*env)->GetLongField(env, rcuLock, readerThreadsListField);\n+    if (addr != 0) {\n+        JVM_ThreadListRemoveSelf((void *) addr);\n+    }\n+}\n+\n+JNIEXPORT jboolean JNICALL\n+Java_jdk_crac_RCULock_hasReaderThreads(JNIEnv *env, jobject rcuLock)\n+{\n+    jlong addr = (*env)->GetLongField(env, rcuLock, readerThreadsListField);\n+    if (addr != 0) {\n+        return JVM_ThreadListLength((void *) addr) != 0;\n+    } else {\n+        return 0;\n+    }\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_jdk_crac_RCULock_synchronizeThreads(JNIEnv *env, jobject rcuLock)\n+{\n+    jlong threads = (*env)->GetLongField(env, rcuLock, readerThreadsListField);\n+    jlong methods = (*env)->GetLongField(env, rcuLock, readCriticalMethodsField);\n+    JVM_RCU_SynchronizeThreads((void *) threads, (const char **) (void *) methods);\n+}\n","filename":"src\/java.base\/share\/native\/libjava\/RCULock.c","additions":148,"deletions":0,"binary":false,"changes":148,"status":"added"},{"patch":"@@ -0,0 +1,113 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.RCULock;\n+\n+import java.util.concurrent.*;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import static jdk.test.lib.Asserts.*;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @run main\/timeout=20 RCULockTest\n+ *\/\n+public class RCULockTest {\n+    public static final int NUM_READERS = 50;\n+    private final RCULock lock = RCULock.forClasses(RCULockTest.class);\n+    private final AtomicBoolean stop = new AtomicBoolean();\n+    private final AtomicInteger readersIn = new AtomicInteger();\n+    private final AtomicReference<Throwable> exception = new AtomicReference<>();\n+    private final CountDownLatch exLatch = new CountDownLatch(1);\n+    private final CyclicBarrier completion = new CyclicBarrier(2 + NUM_READERS);\n+\n+    public static void main(String[] args) throws Exception {\n+        new RCULockTest().run();\n+    }\n+\n+    private void run() throws Exception {\n+        new Thread(this::synchronizer, \"synchronizer\").start();\n+        for (int i = 0; i < NUM_READERS; ++i) {\n+            new Thread(this::reader, \"reader-\" + i).start();\n+        }\n+        exLatch.await(10, TimeUnit.SECONDS);\n+        Throwable ex = exception.get();\n+        if (ex != null) {\n+            throw new AssertionError(ex);\n+        }\n+        stop.set(true);\n+        completion.await(10, TimeUnit.SECONDS);\n+    }\n+\n+    private void reader() {\n+        try {\n+            while (!stop.get()) {\n+                try {\n+                    readerCritical();\n+                } finally {\n+                    lock.readUnlock();\n+                }\n+                Thread.sleep(1);\n+            }\n+            completion.await();\n+        } catch (Throwable t) {\n+            t.printStackTrace();\n+            exception.set(t);\n+            exLatch.countDown();\n+        }\n+    }\n+\n+    @RCULock.Critical\n+    private void readerCritical() throws InterruptedException {\n+        lock.readLock();\n+        readersIn.incrementAndGet();\n+        Thread.sleep(ThreadLocalRandom.current().nextInt(10));\n+        readersIn.decrementAndGet();\n+    }\n+\n+    private void synchronizer() {\n+        try {\n+            while (!stop.get()) {\n+                lock.synchronizeBegin();\n+                try {\n+                    assertEquals(0, readersIn.get());\n+                    Thread.sleep(ThreadLocalRandom.current().nextInt(10));\n+                    assertEquals(0, readersIn.get());\n+                } finally {\n+                    lock.synchronizeEnd();\n+                }\n+                Thread.sleep(ThreadLocalRandom.current().nextInt(10));\n+            }\n+            completion.await();\n+        } catch (Throwable t) {\n+            t.printStackTrace();\n+            exception.set(t);\n+            exLatch.countDown();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/RCULockTest.java","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"}]}