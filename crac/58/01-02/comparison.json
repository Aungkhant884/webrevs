{"files":[{"patch":"@@ -3909,0 +3909,4 @@\n+  \/\/ If there are no methods to check there's no point in executing the VM op\n+  if (*methods == NULL) {\n+    return;\n+  }\n@@ -3914,0 +3918,5 @@\n+  const char **m = _method_list;\n+  while (*m != NULL) m++;\n+  const size_t num = m - _method_list;\n+  assert(num > 0, \"No methods\");\n+\n@@ -3929,3 +3938,6 @@\n-          \/\/ TODO: let's assume the list is sorted and use binary search\n-          for (const char **m = _method_list; *m != NULL; ++m) {\n-            if (strcmp(*m, method) == 0) {\n+          \/\/ binary search in sorted array\n+          size_t low = 0, high = num - 1;\n+          while (low <= high) {\n+            size_t mid = low + ((high - low) >> 1);\n+            int comp = strcmp(method, _method_list[mid]);\n+            if (comp == 0) {\n@@ -3940,0 +3952,6 @@\n+            } else if (comp > 0) {\n+              low = mid + 1;\n+            } else if (mid != 0) {\n+              high = mid - 1;\n+            } else {\n+              break;\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":21,"deletions":3,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -35,0 +35,3 @@\n+\n+import jdk.internal.crac.JDKContext;\n+import jdk.internal.crac.JDKResource;\n@@ -69,0 +72,24 @@\n+    private static class LockHolder {\n+        public static RCULock DEFAULT_LOCK = new RCULock(new String[0]);\n+        private static JDKResource DEFAULT_LOCK_SYNC = new JDKResource() {\n+            @Override\n+            public JDKResource.Priority getPriority() {\n+                return JDKResource.Priority.NORMAL;\n+            }\n+\n+            @Override\n+            public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+                jdk.crac.Core.defaultLock().synchronizeBegin();\n+            }\n+\n+            @Override\n+            public void afterRestore(Context<? extends Resource> context) throws Exception {\n+                jdk.crac.Core.defaultLock().synchronizeEnd();\n+            }\n+        };\n+\n+        static {\n+            jdk.internal.crac.Core.getJDKContext().register(DEFAULT_LOCK_SYNC);\n+        }\n+    }\n+\n@@ -79,0 +106,4 @@\n+    public static RCULock defaultLock() {\n+        return LockHolder.DEFAULT_LOCK;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/Core.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -10,0 +10,1 @@\n+import java.lang.reflect.Field;\n@@ -13,0 +14,2 @@\n+import java.util.List;\n+import java.util.TreeSet;\n@@ -15,0 +18,1 @@\n+import java.util.function.Function;\n@@ -64,0 +68,1 @@\n+    private final TreeSet<String> methodsCopy;\n@@ -70,1 +75,7 @@\n-        initFieldOffsets();\n+        try {\n+            Field readerThreadsList = RCULock.class.getDeclaredField(\"readerThreadsList\");\n+            Field readCriticalMethods = RCULock.class.getDeclaredField(\"readCriticalMethods\");\n+            initFieldOffsets(readerThreadsList, readCriticalMethods);\n+        } catch (NoSuchFieldException e) {\n+            throw new ExceptionInInitializerError(e);\n+        }\n@@ -73,1 +84,1 @@\n-    private static native void initFieldOffsets();\n+    private static native void initFieldOffsets(Field readerThreadsList, Field readCriticalMethods);\n@@ -84,1 +95,5 @@\n-        ArrayList<Method> methods = new ArrayList<>();\n+        return new RCULock(findAnnotated(classes));\n+    }\n+\n+    private static List<Method> findAnnotated(Class<?>[] classes) {\n+        List<Method> methods = new ArrayList<>();\n@@ -95,1 +110,1 @@\n-        return new RCULock(methods);\n+        return methods;\n@@ -105,1 +120,5 @@\n-                .map(m -> m.getDeclaringClass().getName() + \".\" + m.getName() + \"(\" +\n+                .map(RCULock::signature).toArray(String[]::new));\n+    }\n+\n+    private static String signature(Method m) {\n+        return m.getDeclaringClass().getName() + \".\" + m.getName() + \"(\" +\n@@ -108,1 +127,1 @@\n-                + \")\" + m.getReturnType().descriptorString()).toArray(String[]::new));\n+                + \")\" + m.getReturnType().descriptorString();\n@@ -116,0 +135,3 @@\n+     * \n+     * @apiNote This constructor does not use var-args argument to prevent\n+     * accidentally creating a RCULock without declaring any critical methods.\n@@ -121,0 +143,1 @@\n+        methodsCopy = new TreeSet<>(Arrays.asList(readCriticalMethods));\n@@ -131,0 +154,45 @@\n+    \/**\n+     * Inspect the classes for all methods (including private ones) marked with\n+     * the {@link RCULock.Critical} annotation and add these to the list\n+     * of read-critical methods.\n+     *\n+     * @param classes Classes to be inspected.\n+     *\/\n+    public void amendClasses(Class<?>... classes) {\n+        amendCriticalMethods(findAnnotated(classes));\n+    }\n+\n+    \/**\n+     * Add read-critical methods.\n+     * \n+     * @param methods List of read-critical methods.\n+     *                \n+     * @see RCULock#RCULock(Iterable)\n+     *\/\n+    public void amendCriticalMethods(Iterable<Method> methods) {\n+        amendCriticalMethods(StreamSupport.stream(methods.spliterator(), false)\n+                .map(RCULock::signature).toArray(String[]::new));\n+    }\n+\n+    \/**\n+     * Add read-critical methods using signatures.\n+     * \n+     * @param methods List of method signatures.\n+     *                \n+     * @see RCULock#RCULock(String[])\n+     *\/\n+    public void amendCriticalMethods(String... methods) {\n+        lock.lock();\n+        try {\n+            if (synchronize) {\n+                throw new IllegalMonitorStateException(\"Already synchronizing\");\n+            }\n+            methodsCopy.addAll(Arrays.asList(methods));\n+            updateMethods(methodsCopy.toArray(new String[0]));\n+        } finally {\n+            lock.unlock();\n+        }\n+    }\n+\n+    private native void updateMethods(String[] methods);\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/RCULock.java","additions":74,"deletions":6,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include <assert.h>\n@@ -40,1 +41,2 @@\n-Java_jdk_crac_RCULock_initFieldOffsets(JNIEnv *env, jclass cls)\n+Java_jdk_crac_RCULock_initFieldOffsets(JNIEnv *env, jclass cls,\n+        jobject readerThreadsList, jobject readCriticalMethods)\n@@ -42,2 +44,2 @@\n-    readerThreadsListField = (*env)->GetFieldID(env, cls, \"readerThreadsList\", \"J\");\n-    readCriticalMethodsField = (*env)->GetFieldID(env, cls, \"readCriticalMethods\", \"J\");\n+    readerThreadsListField = (*env)->FromReflectedField(env, readerThreadsList);\n+    readCriticalMethodsField = (*env)->FromReflectedField(env, readCriticalMethods);\n@@ -47,2 +49,2 @@\n-    for (uint i = 0; i < limit; ++i) {\n-        free(*(mem + i));\n+    for (uint i = 0; i < limit && mem[i] != NULL; ++i) {\n+        free(mem[i]);\n@@ -53,10 +55,1 @@\n-JNIEXPORT void JNICALL\n-Java_jdk_crac_RCULock_init(JNIEnv *env, jobject rcuLock, jobjectArray methods)\n-{\n-    void *threads = JVM_ThreadListAllocate();\n-    if (threads == NULL) {\n-        JNU_ThrowOutOfMemoryError(env, NULL);\n-        return;\n-    }\n-    (*env)->SetLongField(env, rcuLock, readerThreadsListField, (jlong) threads);\n-\n+static char **copy_signatures(JNIEnv *env, jobjectArray methods) {\n@@ -67,1 +60,1 @@\n-        return;\n+        return NULL;\n@@ -71,1 +64,5 @@\n-        if (el == NULL) {\n+        if ((*env)->ExceptionOccurred(env)) {\n+            free_up_to(c_methods, i);\n+            \/\/ exception already pending\n+            return NULL;\n+        } else if (el == NULL) {\n@@ -74,1 +71,1 @@\n-            return;\n+            return NULL;\n@@ -81,1 +78,1 @@\n-            return;\n+            return NULL;\n@@ -88,1 +85,1 @@\n-            return;\n+            return NULL;\n@@ -96,1 +93,5 @@\n-    \/\/ TODO: assert methods are sorted - note that we should mind UTF-8 format\n+    \/\/ Note: strcmp can be used for UTF-8 strings but I am not sure if\n+    \/\/ the sort in Java matches comparison through strcmp.\n+    for (int i = 1; i < num; ++i) {\n+        assert(strcmp(c_methods[i - 1], c_methods[i]) < 0);\n+    }\n@@ -98,1 +99,17 @@\n-    (*env)->SetLongField(env, rcuLock, readCriticalMethodsField, (jlong) (void *) c_methods);\n+    return c_methods;\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_jdk_crac_RCULock_init(JNIEnv *env, jobject rcuLock, jobjectArray methods)\n+{\n+    void *threads = JVM_ThreadListAllocate();\n+    if (threads == NULL) {\n+        JNU_ThrowOutOfMemoryError(env, NULL);\n+        return;\n+    }\n+    (*env)->SetLongField(env, rcuLock, readerThreadsListField, (jlong) threads);\n+\n+    char **c_methods = copy_signatures(env, methods);\n+    if (c_methods != NULL) {\n+        (*env)->SetLongField(env, rcuLock, readCriticalMethodsField, (jlong) (void *) c_methods);\n+    }\n@@ -122,0 +139,15 @@\n+JNIEXPORT void JNICALL\n+Java_jdk_crac_RCULock_updateMethods(JNIEnv *env, jobject rcuLock, jobjectArray methods)\n+{\n+    jlong old_methods = (*env)->GetLongField(env, rcuLock, readCriticalMethodsField);\n+    if (old_methods == 0) {\n+        JNU_ThrowNullPointerException(env, \"Is this lock destroyed?\");\n+        return;\n+    }\n+    free_up_to((char **) (void *) old_methods, INT32_MAX);\n+    char **c_methods = copy_signatures(env, methods);\n+    if (c_methods != NULL) {\n+        (*env)->SetLongField(env, rcuLock, readCriticalMethodsField, (jlong) (void *) c_methods);\n+    }\n+}\n+\n","filename":"src\/java.base\/share\/native\/libjava\/RCULock.c","additions":54,"deletions":22,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -54,0 +54,2 @@\n+        \/\/ just add some other methods to test that code path\n+        lock.amendCriticalMethods(\"foo.Bar(I)I\");\n","filename":"test\/jdk\/jdk\/crac\/RCULockTest.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}