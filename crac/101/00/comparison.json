{"files":[{"patch":"@@ -2260,1 +2260,1 @@\n-bool Arguments::parse_options_for_restore(const JavaVMInitArgs* args) {\n+bool Arguments::parse_options_for_restore(const JavaVMInitArgs* args, JavaMainArgs** main_args) {\n@@ -2286,1 +2286,5 @@\n-      } else {\n+      }\n+      else if (strcmp(key, \"jdk.internal.crac.mainArgs\") == 0) {\n+        *main_args = (JavaMainArgs*)(option->extraInfo);\n+      }\n+      else {\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -151,0 +151,9 @@\n+\/\/ Arguments passed from JavaMain via the property jdk.internal.crac.mainArgs\n+typedef struct {\n+    int    argc;\n+    char **argv;\n+    int    mode;\n+    char  *what;\n+    \/\/ InvocationFunctions ifn;\n+} JavaMainArgs;\n+\n@@ -540,1 +549,1 @@\n-  static bool parse_options_for_restore(const JavaVMInitArgs* args);\n+  static bool parse_options_for_restore(const JavaVMInitArgs* args, JavaMainArgs** main_args);\n","filename":"src\/hotspot\/share\/runtime\/arguments.hpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -267,1 +267,5 @@\n-  bool ret = _restore_parameters.read_from(shmfd);\n+  \/\/ deserialize parameters from shared memory\n+  bool ret = _restore_parameters.deserialize(shmfd);\n+  if (!ret) {\n+    fprintf(stderr, \"CracRestoreParameters: deserialization failed!\\n\");\n+  }\n@@ -269,0 +273,54 @@\n+\n+  \/\/ set _restore_start_time and _restore_start_nanos from restored parameters\n+  ::_restore_start_time = _restore_parameters.restore_time;\n+  ::_restore_start_nanos = _restore_parameters.restore_nanos;\n+\n+  \/\/ update JVM flags from restored parameters\n+  for (const char* flag : _restore_parameters.flags) {\n+    FormatBuffer<80> err_msg(\"%s\", \"\");\n+    JVMFlag::Error result;\n+    if (*flag == '+' || *flag == '-') {\n+      result = WriteableFlags::set_flag(\n+        flag + 1,\n+        *flag == '+' ? \"true\" : \"false\",\n+        JVMFlagOrigin::CRAC_RESTORE,\n+        err_msg\n+      );\n+      guarantee(\n+        result == JVMFlag::Error::SUCCESS,\n+        \"VM Option '%s' cannot be changed: %d\",\n+        flag + 1,\n+        result\n+      );\n+    } else {\n+      \/\/ copy flag to a mutable buffer\n+      char buf[4096];\n+      strncpy(buf, flag, sizeof(buf));\n+      buf[4095] = '\\0';\n+      \/\/ replace '=' with '\\0' if found\n+      char* eq = strchr(buf, '=');\n+      if (eq == NULL) {\n+        result = JVMFlag::Error::MISSING_VALUE;\n+      } else {\n+        *eq = '\\0';\n+        char* name = buf;\n+        char* value = eq + 1;\n+        result = WriteableFlags::set_flag(name, value, JVMFlagOrigin::CRAC_RESTORE, err_msg);\n+      }\n+      guarantee(\n+        result == JVMFlag::Error::SUCCESS,\n+        \"VM Option '%s' cannot be changed: %d\",\n+        buf,\n+        result\n+      );\n+    }\n+  }\n+\n+  \/\/ update environment variables from restored parameters\n+  for (const char* env : _restore_parameters.envs) {\n+    \/\/ putenv() expects char*, but doesn't actually modify its argument,\n+    \/\/ therefore using const_cast is fine.\n+    \/\/ setenv() might be safer though.\n+    putenv(const_cast<char*>(env));\n+  }\n+\n@@ -417,3 +475,7 @@\n-    oop new_args = NULL;\n-    if (cr.new_args()) {\n-      new_args = java_lang_String::create_oop_from_str(cr.new_args(), CHECK_NH);\n+    GrowableArray<const char *>* new_args = cr.new_args();\n+    objArrayOop argsObj = oopFactory::new_objArray(vmClasses::String_klass(), new_args->length(), CHECK_NH);\n+    objArrayHandle args(THREAD, argsObj);\n+\n+    for (int i = 0; i < new_args->length(); i++) {\n+      oop argObj = java_lang_String::create_oop_from_str(new_args->at(i), CHECK_NH);\n+      args->obj_at_put(i, argObj);\n@@ -421,0 +483,1 @@\n+\n@@ -429,1 +492,1 @@\n-    return ret_cr(JVM_CHECKPOINT_OK, Handle(THREAD, new_args), props, Handle(), Handle(), THREAD);\n+    return ret_cr(JVM_CHECKPOINT_OK, args, props, Handle(), Handle(), THREAD);\n@@ -449,1 +512,121 @@\n-void crac::restore() {\n+\/\/ Write a jlong to fd.\n+\/\/ On error, return false.\n+static bool write_jlong(int fd, jlong value) {\n+  const size_t JLONG_SIZE = sizeof(jlong);\n+\n+  \/\/ serialize jlong with reinterpret_cast\n+  int ret = write(fd, reinterpret_cast<char*>(&value), JLONG_SIZE);\n+  if (ret != JLONG_SIZE) {\n+    if (ret < 0) {\n+      perror(\"write_jlong error\");\n+    } else {\n+      fprintf(stderr, \"write_jlong truncated\");\n+    }\n+    return false;\n+  }\n+  return true;\n+}\n+\n+\/\/ Read a jlong from fd into value, which should not be NULL.\n+\/\/ On error, return false.\n+static bool read_jlong(int fd, jlong* value) {\n+  const size_t JLONG_SIZE = sizeof(jlong);\n+  guarantee(value != NULL, \"read_jlong: value is NULL\");\n+\n+  \/\/ deserialize jlong with reinterpret_cast\n+  int ret = read(fd, reinterpret_cast<char*>(value), JLONG_SIZE);\n+  if (ret != JLONG_SIZE) {\n+    if (ret < 0) {\n+      perror(\"read_jlong error\");\n+    } else {\n+      fprintf(stderr, \"read_jlong truncated\");\n+    }\n+    return false;\n+  }\n+  return true;\n+}\n+\n+\/\/ Write a GrowableArray to fd.\n+\/\/ On error, return false.\n+static bool write_growable_array(int fd, const GrowableArray<const char *>* array) {\n+  const size_t JLONG_SIZE = sizeof(jlong);\n+  guarantee(array != NULL, \"write_growable_array: array is NULL\");\n+\n+  \/\/ write array length as jlong\n+  if (!write_jlong(fd, array->length())) {\n+    return false;\n+  }\n+\n+  \/\/ write the content (including trailing NULL bytes)\n+  for (auto s : *array) {\n+    ssize_t len = strlen(s);\n+    if (write(fd, s, len + 1) != len + 1) {\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n+\/\/ Append a GrowableArray from fd to array, which should be initialized.\n+\/\/ On error, return false.\n+static bool read_growable_array(int fd, GrowableArray<const char *>* array) {\n+  const size_t JLONG_SIZE = sizeof(jlong);\n+  guarantee(array != NULL, \"read_growable_array: array is NULL\");\n+\n+  \/\/ read array length as jlong\n+  jlong len = 0;\n+  if (!read_jlong(fd, &len)) {\n+    return false;\n+  }\n+\n+  \/\/ read the content\n+  for (int i = 0; i < len; i++) {\n+    \/\/ read the string byte-at-a-time, because we don't know where the NULL byte is\n+    \/\/ calling read() in a loop like this may impact performance\n+    char buf[4096] = { 0 };\n+    for (int j = 0; j < 4096; j++) {\n+      if (read(fd, &buf[j], 1) != 1) {\n+        return false;\n+      }\n+      if (buf[j] == '\\0') {\n+        break;\n+      }\n+    }\n+    \/\/ copy the string onto the heap\n+    size_t size = strlen(buf) + 1;\n+    char* heap_buf = NEW_C_HEAP_ARRAY(char, size, mtArguments);\n+    strncpy(heap_buf, buf, size);\n+    array->append(heap_buf);\n+  }\n+  return true;\n+}\n+\n+CracRestoreParameters::CracRestoreParameters() :\n+  restore_time(0),\n+  restore_nanos(0),\n+  flags(GrowableArray<const char *>(0, mtInternal)),\n+  properties(GrowableArray<const char *>(0, mtInternal)),\n+  args(GrowableArray<const char *>(0, mtInternal)),\n+  envs(GrowableArray<const char *>(0, mtInternal)) {}\n+\n+bool CracRestoreParameters::serialize(int fd) const {\n+  if (!write_jlong(fd, restore_time)) return false;\n+  if (!write_jlong(fd, restore_nanos)) return false;\n+  if (!write_growable_array(fd, &flags)) return false;\n+  if (!write_growable_array(fd, &properties)) return false;\n+  if (!write_growable_array(fd, &args)) return false;\n+  if (!write_growable_array(fd, &envs)) return false;\n+  return true;\n+}\n+\n+bool CracRestoreParameters::deserialize(int fd) {\n+  if (!read_jlong(fd, &restore_time)) return false;\n+  if (!read_jlong(fd, &restore_nanos)) return false;\n+  if (!read_growable_array(fd, &flags)) return false;\n+  if (!read_growable_array(fd, &properties)) return false;\n+  if (!read_growable_array(fd, &args)) return false;\n+  if (!read_growable_array(fd, &envs)) return false;\n+  return true;\n+}\n+\n+void crac::restore(JavaMainArgs* main_args) {\n@@ -460,7 +643,37 @@\n-    if (CracRestoreParameters::write_to(\n-          shmfd,\n-          Arguments::jvm_flags_array(), Arguments::num_jvm_flags(),\n-          Arguments::system_properties(),\n-          Arguments::java_command() ? Arguments::java_command() : \"\",\n-          restore_time,\n-          restore_nanos)) {\n+    \/\/ passes the context to VM via shared memory as a serialized data structure\n+    CracRestoreParameters params;\n+\n+    \/\/ record current time\n+    params.restore_time = restore_time;\n+    params.restore_nanos = restore_nanos;\n+\n+    \/\/ record JVM flags\n+    for (int i = 0; i < Arguments::num_jvm_flags(); i++) {\n+      params.flags.append(Arguments::jvm_flags_array()[i]);\n+    }\n+\n+    \/\/ record JVM properties\n+    for (auto p = Arguments::system_properties(); p != NULL; p = p->next()) {\n+      \/\/ allocate memory to store properties on the heap\n+      \/\/ the memory will be freed when the process exits\n+      size_t len = strlen(p->key()) + strlen(p->value()) + 1;\n+      char* buf = NEW_C_HEAP_ARRAY(char, len, mtArguments);\n+      snprintf(buf, len, \"%s=%s\", p->key(), p->value());\n+      params.properties.append(buf);\n+    }\n+\n+    \/\/ record command line arguments (if any)\n+    if (main_args->what != NULL) {\n+      params.args.append(main_args->what);\n+      for (int i = 0; i < main_args->argc; i++) {\n+        params.args.append(main_args->argv[i]);\n+      }\n+    }\n+\n+    \/\/ record environment variables\n+    for (char** env = os::get_environ(); *env != NULL; ++env) {\n+      params.envs.append(*env);\n+    }\n+\n+    \/\/ serialize parameters into shared memory\n+    if (params.serialize(shmfd)) {\n@@ -470,0 +683,2 @@\n+    } else {\n+      fprintf(stderr, \"CracRestoreParameters: serialization failed!\\n\");\n@@ -482,71 +697,0 @@\n-bool CracRestoreParameters::read_from(int fd) {\n-  struct stat st;\n-  if (fstat(fd, &st)) {\n-    perror(\"fstat (ignoring restore parameters)\");\n-    return false;\n-  }\n-\n-  char *contents = NEW_C_HEAP_ARRAY(char, st.st_size, mtInternal);\n-  if (read(fd, contents, st.st_size) < 0) {\n-    perror(\"read (ignoring restore parameters)\");\n-    FREE_C_HEAP_ARRAY(char, contents);\n-    return false;\n-  }\n-\n-  _raw_content = contents;\n-\n-  \/\/ parse the contents to read new system properties and arguments\n-  header* hdr = (header*)_raw_content;\n-  char* cursor = _raw_content + sizeof(header);\n-\n-  ::_restore_start_time = hdr->_restore_time;\n-  ::_restore_start_nanos = hdr->_restore_nanos;\n-\n-  for (int i = 0; i < hdr->_nflags; i++) {\n-    FormatBuffer<80> err_msg(\"%s\", \"\");\n-    JVMFlag::Error result;\n-    const char *name = cursor;\n-    if (*cursor == '+' || *cursor == '-') {\n-      name = cursor + 1;\n-      result = WriteableFlags::set_flag(name, *cursor == '+' ? \"true\" : \"false\",\n-        JVMFlagOrigin::CRAC_RESTORE, err_msg);\n-      cursor += strlen(cursor) + 1;\n-    } else {\n-      char* eq = strchrnul(cursor, '=');\n-      if (*eq == '\\0') {\n-        result = JVMFlag::Error::MISSING_VALUE;\n-        cursor = eq + 1;\n-      } else {\n-        *eq = '\\0';\n-        char* value = eq + 1;\n-        result = WriteableFlags::set_flag(cursor, value, JVMFlagOrigin::CRAC_RESTORE, err_msg);\n-        cursor = value + strlen(value) + 1;\n-      }\n-    }\n-    guarantee(result == JVMFlag::Error::SUCCESS, \"VM Option '%s' cannot be changed: %d\",\n-        name, result);\n-  }\n-\n-  for (int i = 0; i < hdr->_nprops; i++) {\n-    assert((cursor + strlen(cursor) <= contents + st.st_size), \"property length exceeds shared memory size\");\n-    int idx = _properties->append(cursor);\n-    size_t prop_len = strlen(cursor) + 1;\n-    cursor = cursor + prop_len;\n-  }\n-\n-  char* env_mem = NEW_C_HEAP_ARRAY(char, hdr->_env_memory_size, mtArguments); \/\/ left this pointer unowned, it is freed when process dies\n-  memcpy(env_mem, cursor, hdr->_env_memory_size);\n-\n-  const char* env_end = env_mem + hdr->_env_memory_size;\n-  while (env_mem < env_end) {\n-    const size_t s = strlen(env_mem) + 1;\n-    assert(env_mem + s <= env_end, \"env vars exceed memory buffer, maybe ending 0 is lost\");\n-    putenv(env_mem);\n-    env_mem += s;\n-  }\n-  cursor += hdr->_env_memory_size;\n-\n-  _args = cursor;\n-  return true;\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/crac.cpp","additions":228,"deletions":84,"binary":false,"changes":312,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"arguments.hpp\"\n@@ -39,1 +40,1 @@\n-  static void restore();\n+  static void restore(JavaMainArgs* main_args);\n","filename":"src\/hotspot\/share\/runtime\/crac.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -52,107 +52,17 @@\n-class CracRestoreParameters : public CHeapObj<mtInternal> {\n-  char* _raw_content;\n-  GrowableArray<const char *>* _properties;\n-  const char* _args;\n-\n-  struct header {\n-    jlong _restore_time;\n-    jlong _restore_nanos;\n-    int _nflags;\n-    int _nprops;\n-    int _env_memory_size;\n-  };\n-\n-  static bool write_check_error(int fd, const void *buf, int count) {\n-    int wret = write(fd, buf, count);\n-    if (wret != count) {\n-      if (wret < 0) {\n-        perror(\"shm error\");\n-      } else {\n-        fprintf(stderr, \"write shm truncated\");\n-      }\n-      return false;\n-    }\n-    return true;\n-  }\n-\n-  static int system_props_length(const SystemProperty* props) {\n-    int len = 0;\n-    while (props != NULL) {\n-      ++len;\n-      props = props->next();\n-    }\n-    return len;\n-  }\n-\n-  static int env_vars_size(const char* const * env) {\n-    int len = 0;\n-    for (; *env; ++env) {\n-      len += (int)strlen(*env) + 1;\n-    }\n-    return len;\n-  }\n-\n- public:\n-  const char *args() const { return _args; }\n-  GrowableArray<const char *>* properties() const { return _properties; }\n-\n-  CracRestoreParameters() :\n-    _raw_content(NULL),\n-    _properties(new (mtInternal) GrowableArray<const char *>(0, mtInternal)),\n-    _args(NULL)\n-  {}\n-\n-  ~CracRestoreParameters() {\n-    if (_raw_content) {\n-      FREE_C_HEAP_ARRAY(char, _raw_content);\n-    }\n-    delete _properties;\n-  }\n-\n-  static bool write_to(int fd,\n-      const char* const* flags, int num_flags,\n-      const SystemProperty* props,\n-      const char *args,\n-      jlong restore_time,\n-      jlong restore_nanos) {\n-    header hdr = {\n-      restore_time,\n-      restore_nanos,\n-      num_flags,\n-      system_props_length(props),\n-      env_vars_size(os::get_environ())\n-    };\n-\n-    if (!write_check_error(fd, (void *)&hdr, sizeof(header))) {\n-      return false;\n-    }\n-\n-    for (int i = 0; i < num_flags; ++i) {\n-      if (!write_check_error(fd, flags[i], (int)strlen(flags[i]) + 1)) {\n-        return false;\n-      }\n-    }\n-\n-    const SystemProperty* p = props;\n-    while (p != NULL) {\n-      char prop[4096];\n-      int len = snprintf(prop, sizeof(prop), \"%s=%s\", p->key(), p->value());\n-      guarantee((0 < len) && ((unsigned)len < sizeof(prop)), \"property does not fit temp buffer\");\n-      if (!write_check_error(fd, prop, len+1)) {\n-        return false;\n-      }\n-      p = p->next();\n-    }\n-\n-    \/\/ Write env vars\n-    for (char** env = os::get_environ(); *env; ++env) {\n-      if (!write_check_error(fd, *env, (int)strlen(*env) + 1)) {\n-        return false;\n-      }\n-    }\n-\n-    return write_check_error(fd, args, (int)strlen(args)+1); \/\/ +1 for null char\n-  }\n-\n-  bool read_from(int fd);\n-\n+struct CracRestoreParameters : public StackObj {\n+  jlong restore_time;\n+  jlong restore_nanos;\n+  GrowableArray<const char *> flags;\n+  GrowableArray<const char *> properties;\n+  GrowableArray<const char *> args;\n+  GrowableArray<const char *> envs;\n+\n+  CracRestoreParameters();\n+\n+  \/\/ Write parameters into fd.\n+  \/\/ Return true if successful.\n+  bool serialize(int fd) const;\n+\n+  \/\/ Read parameters from fd.\n+  \/\/ Return true if successful.\n+  bool deserialize(int fd);\n@@ -191,2 +101,2 @@\n-  const char* new_args() { return _restore_parameters.args(); }\n-  GrowableArray<const char *>* new_properties() { return _restore_parameters.properties(); }\n+  GrowableArray<const char *>* new_args() { return &_restore_parameters.args; }\n+  GrowableArray<const char *>* new_properties() { return &_restore_parameters.properties; }\n","filename":"src\/hotspot\/share\/runtime\/crac_structs.hpp","additions":19,"deletions":109,"binary":false,"changes":128,"status":"modified"},{"patch":"@@ -412,1 +412,2 @@\n-    if (!Arguments::parse_options_for_restore(args)) {\n+    JavaMainArgs* main_args;\n+    if (!Arguments::parse_options_for_restore(args, &main_args)) {\n@@ -415,1 +416,1 @@\n-    crac::restore();\n+    crac::restore(main_args);\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -181,1 +181,1 @@\n-        final String newArguments = (null == bundle) ? null : (String)bundle[1];\n+        final String[] newArguments = (null == bundle) ? null : (String[])bundle[1];\n@@ -231,24 +231,21 @@\n-        if (newArguments != null && newArguments.length() > 0) {\n-            String[] args = newArguments.split(\" \");\n-            if (args.length > 0) {\n-                try {\n-                    Method newMain = AccessController.doPrivileged(new PrivilegedExceptionAction<Method>() {\n-                       @Override\n-                       public Method run() throws Exception {\n-                           Class < ?> newMainClass = Class.forName(args[0], false,\n-                               ClassLoader.getSystemClassLoader());\n-                           Method newMain = newMainClass.getDeclaredMethod(\"main\",\n-                               String[].class);\n-                           newMain.setAccessible(true);\n-                           return newMain;\n-                       }\n-                    });\n-                    newMain.invoke(null,\n-                        (Object)Arrays.copyOfRange(args, 1, args.length));\n-                } catch (PrivilegedActionException |\n-                         InvocationTargetException |\n-                         IllegalAccessException e) {\n-                    assert !checkpointException.hasException() :\n-                        \"should not have new arguments\";\n-                    restoreException.handle(e);\n-                }\n+        if (newArguments != null && newArguments.length > 0) {\n+            try {\n+                Method newMain = AccessController.doPrivileged(new PrivilegedExceptionAction<Method>() {\n+                    @Override\n+                    public Method run() throws Exception {\n+                        Class < ?> newMainClass = Class.forName(newArguments[0], false,\n+                            ClassLoader.getSystemClassLoader());\n+                        Method newMain = newMainClass.getDeclaredMethod(\"main\",\n+                            String[].class);\n+                        newMain.setAccessible(true);\n+                        return newMain;\n+                    }\n+                });\n+                newMain.invoke(null,\n+                    (Object)Arrays.copyOfRange(newArguments, 1, newArguments.length));\n+            } catch (PrivilegedActionException |\n+                        InvocationTargetException |\n+                        IllegalAccessException e) {\n+                assert !checkpointException.hasException() :\n+                    \"should not have new arguments\";\n+                restoreException.handle(e);\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/Core.java","additions":22,"deletions":25,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -413,0 +413,4 @@\n+    \/\/ set the -Djdk.internal.crac.mainArgs pseudo property\n+    \/\/ this is used by CRaC to supply the restored VM with new args\n+    AddOption(\"-Djdk.internal.crac.mainArgs\", args);\n+\n","filename":"src\/java.base\/share\/native\/libjli\/java.c","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"}]}