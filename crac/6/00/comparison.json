{"files":[{"patch":"@@ -41,0 +41,10 @@\n+\n+    \/**\n+     * Constructs a {@code CheckpointException} with the specified\n+     * detail message.\n+     *\n+     * @param message the detail message.\n+     *\/\n+    public CheckpointException(String message) {\n+        super(message);\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/CheckpointException.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -52,0 +52,3 @@\n+    private static final Object checkpointRestoreLock = new Object();\n+    private static boolean checkpointInProgress = false;\n+\n@@ -181,5 +184,18 @@\n-        try {\n-            checkpointRestore1();\n-        } finally {\n-            if (traceStartupTime) {\n-                System.out.println(\"STARTUPTIME \" + System.nanoTime() + \" restore-finish\");\n+        \/\/ checkpointRestore protects against the simultaneous\n+        \/\/ call of checkpointRestore from different threads.\n+        synchronized (checkpointRestoreLock) {\n+            \/\/ checkpointInProgress protects against recursive\n+            \/\/ checkpointRestore from resource's\n+            \/\/ beforeCheckpoint\/afterRestore methods\n+            if (!checkpointInProgress) {\n+                try {\n+                    checkpointInProgress = true;\n+                    checkpointRestore1();\n+                } finally {\n+                    if (traceStartupTime) {\n+                        System.out.println(\"STARTUPTIME \" + System.nanoTime() + \" restore-finish\");\n+                    }\n+                    checkpointInProgress = false;\n+                }\n+            } else {\n+                throw new CheckpointException(\"Recursive checkpoint is not allowed\");\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/Core.java","additions":21,"deletions":5,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -41,0 +41,10 @@\n+\n+    \/**\n+     * Constructs a {@code RestoreException} with the specified\n+     * detail message.\n+     *\n+     * @param message the detail message.\n+     *\/\n+    public RestoreException(String message) {\n+        super(message);\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/RestoreException.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,127 @@\n+\/\/ Copyright 2019-2021 Azul Systems, Inc.  All Rights Reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it under\n+\/\/ the terms of the GNU General Public License version 2 only, as published by\n+\/\/ the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n+\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n+\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n+\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version 2\n+\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n+\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n+\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n+\/\/ have any questions.\n+\n+\n+import jdk.crac.*;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+\n+public class Test implements Resource {\n+\n+    private static final AtomicInteger counter = new AtomicInteger(0);\n+    private static Exception exception = null;\n+\n+    private static class TestThread extends Thread {\n+\n+        @Override\n+        public void run() {\n+            try {\n+                jdk.crac.Core.checkpointRestore();\n+            } catch (CheckpointException e) {\n+                if (exception == null)\n+                    exception = new RuntimeException(\"Checkpoint in thread ERROR \" + e);\n+            } catch (RestoreException e) {\n+                if (exception == null)\n+                    exception = new RuntimeException(\"Restore in thread ERROR \" + e);\n+            }\n+        }\n+    };\n+\n+    @Override\n+    public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+        try {\n+            int c = counter.incrementAndGet();\n+            if (c > 1) {\n+                if (exception == null)\n+                    exception = new RuntimeException(\"Parallel checkpoint\");\n+            }\n+            Thread.sleep(100);\n+            jdk.crac.Core.checkpointRestore();\n+            if (exception != null)\n+                exception = new RuntimeException(\"Checkpoint Exception should be thrown\");\n+        } catch (CheckpointException e) {\n+            \/\/ Expected Exception\n+        } catch (RestoreException e) {\n+            if (exception == null)\n+                exception = new RuntimeException(\"Restore ERROR \" + e);\n+        }\n+    }\n+\n+    @Override\n+    public void afterRestore(Context<? extends Resource> context) throws Exception {\n+        try {\n+            int c = counter.get();\n+            if (c > 1) {\n+                if (exception == null)\n+                    exception = new RuntimeException(\"Parallel checkpoint\");\n+            }\n+            Thread.sleep(100);\n+            jdk.crac.Core.checkpointRestore();\n+            if (exception == null)\n+                exception = new RuntimeException(\"Checkpoint Exception should be thrown\");\n+        } catch (CheckpointException e) {\n+            \/\/ Expected Exception\n+        } catch (RestoreException e) {\n+            if (exception == null)\n+                exception = new RuntimeException(\"Restore ERROR \" + e);\n+        } finally {\n+            counter.decrementAndGet();\n+        }\n+    }\n+\n+    public static void main(String args[]) throws Exception {\n+        if (args.length < 1) { throw new RuntimeException(\"number of threads is missing\"); }\n+        int numThreads;\n+        try{\n+            numThreads = Integer.parseInt(args[0]);\n+        } catch (NumberFormatException ex){\n+            throw new RuntimeException(\"invalid number of threads\");\n+        }\n+\n+        Core.getGlobalContext().register(new Test());\n+\n+        TestThread[] threads = new TestThread[numThreads];\n+        for(int i=0; i<numThreads; i++) {\n+            threads[i] = new TestThread();\n+            threads[i].start();\n+        };\n+\n+        Thread.currentThread().sleep(100);\n+        try {\n+            jdk.crac.Core.checkpointRestore();\n+        } catch (CheckpointException e) {\n+            throw new RuntimeException(\"Checkpoint ERROR \" + e);\n+        } catch (RestoreException e) {\n+            throw new RuntimeException(\"Restore ERROR \" + e);\n+        }\n+\n+        for(int i=0; i<numThreads; i++) {\n+            threads[i].join();\n+        };\n+\n+        long ccounter = counter.get();\n+        if (ccounter != 0)\n+            throw new RuntimeException(\"Incorrect counter after restore: \" + ccounter + \" instead of 0\");\n+        if (exception != null) {\n+            throw exception;\n+        }\n+        System.out.println(\"PASSED\");\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/recursiveCheckpoint\/Test.java","additions":127,"deletions":0,"binary":false,"changes":127,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+#!\/bin\/sh\n+\n+# Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it under\n+# the terms of the GNU General Public License version 2 only, as published by\n+# the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT ANY\n+# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n+# A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n+# details (a copy is included in the LICENSE file that accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version 2\n+# along with this work; if not, write to the Free Software Foundation, Inc.,\n+# 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n+# CA 94089 USA or visit www.azul.com if you need additional information or\n+# have any questions.\n+\n+\n+##\n+## @test Test.sh\n+## @summary check that the recursive checkpoint is not allowed\n+## @compile Test.java\n+## @run shell\/timeout=120 Test.sh Test0.sh\n+##\n+\n+set -x\n+\n+    IMGDIR=\"cr\"\n+\n+    set +e\n+    ${TESTJAVA}\/bin\/java -cp ${TESTCLASSPATH} -XX:CRaCCheckpointTo=$IMGDIR -XX:CREngine=pauseengine Test $test 10\n+    e=$?\n+    for run in {1..11}; do\n+        set -e\n+        [ $e -eq 137 ]\n+\n+        ${TESTJAVA}\/bin\/java -XX:CRaCRestoreFrom=$IMGDIR  -XX:CREngine=pauseengine Test 10\n+    done\n+    echo \"PASSED $test\"\n+\n","filename":"test\/jdk\/jdk\/crac\/recursiveCheckpoint\/Test.sh","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"}]}