{"files":[{"patch":"@@ -0,0 +1,60 @@\n+name: Build\n+\n+on:\n+  push:\n+    branches:\n+      - '*'\n+\n+jobs:\n+  build:\n+    runs-on: ubuntu-latest\n+    steps:\n+\n+    - name: Start build container\n+      run: echo ${GITHUB_TOKEN} | docker login -u ${GITHUB_ACTOR} --password-stdin docker.pkg.github.com;\n+        docker run -d --name build\n+        -w $PWD\n+        -v \/home\/runner:\/home\/runner\n+        -u $(id -u):$(id -g)\n+        --entrypoint tail\n+        docker.pkg.github.com\/crac\/docker-build\/image:latest\n+        -f \/dev\/null\n+      env:\n+        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n+\n+    - uses: actions\/checkout@v2\n+\n+    - run: bash .\/configure\n+        --disable-warnings-as-errors\n+        --with-version-pre=crac\n+        --with-native-debug-symbols=none\n+      shell: docker exec build bash -e {0}\n+\n+    - run: |\n+        make images docs\n+        mv build\/linux-x86_64-server-release\/images\/jdk jdk14-crac\n+        mv build\/linux-x86_64-server-release\/images\/docs .\n+      shell: docker exec build bash -e {0}\n+\n+    - name: Bundle CRIU\n+      run: |\n+        id=$(curl https:\/\/api.github.com\/repos\/crac\/criu\/releases\/tags\/release-crac | jq .assets[0].id)\n+        curl https:\/\/api.github.com\/repos\/crac\/criu\/releases\/assets\/$id -LJOH 'Accept: application\/octet-stream'\n+        tar axf criu-dist.tar.gz\n+        cp criu-dist\/sbin\/criu jdk14-crac\/lib\/criu\n+        sudo chown root:root jdk14-crac\/lib\/criu\n+        sudo chmod u+s jdk14-crac\/lib\/criu\n+        tar -zcf jdk14-crac.tar.gz jdk14-crac\n+\n+    - uses: actions\/upload-artifact@v2\n+      with:\n+        name: jdk\n+        path: jdk14-crac.tar.gz\n+\n+    - name: Compress docs\n+      run: tar -zcf docs.tar.gz docs\n+\n+    - uses: actions\/upload-artifact@v2\n+      with:\n+        name: docs\n+        path: docs.tar.gz\n","filename":".github\/workflows\/ccpp.yml","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -1,2 +1,6 @@\n-project=jdk\n-bugids=dup\n+[general]\n+project=crac\n+jbs=JDK\n+\n+[checks]\n+error=whitespace\n","filename":".jcheck\/conf","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,22 @@\n+# CRaC JDK\n+\n+## Build\n+\n+CRaC JDK have extended build procedure.\n+\n+1. Build JDK as usual\n+```\n+bash configure\n+make images\n+mv build\/linux-x86_64-server-release\/images\/jdk\/ .\n+```\n+2. Download a build of [modified CRIU](https:\/\/github.com\/org-crac\/criu\/releases\/tag\/release-crac)\n+3. Extract and copy `criu` binary over a same named file in the JDK\n+```\n+cp criu-dist\/sbin\/criu jdk\/lib\/criu\n+```\n+Grant permissions to allow regular user to run it\n+```\n+sudo chown root:root jdk\/lib\/criu\n+sudo chmod u+s jdk\/lib\/criu\n+```\n","filename":"README.md","additions":22,"deletions":0,"binary":false,"changes":22,"status":"added"},{"patch":"@@ -528,1 +528,2 @@\n-        $(eval -include $(call DependOnVariableFileName, $1, $2)) \\\n+        $(eval $1_filename := $(call DependOnVariableFileName, $1, $2)) \\\n+        $(if $(wildcard $($1_filename)), $(eval include $($1_filename))) \\\n@@ -530,1 +531,1 @@\n-          $(call MakeDir, $(dir $(call DependOnVariableFileName, $1, $2))) \\\n+          $(call MakeDir, $(dir $($1_filename))) \\\n@@ -535,2 +536,2 @@\n-              $(call DependOnVariableFileName, $1, $2))) \\\n-        $(call DependOnVariableFileName, $1, $2) \\\n+              $($1_filename))) \\\n+        $($1_filename) \\\n","filename":"make\/common\/MakeBase.gmk","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -35,0 +35,3 @@\n+JVM_Checkpoint\n+JVM_RegisterPersistent\n+JVM_DeregisterPersistent\n","filename":"make\/hotspot\/symbols\/symbols-shared","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -103,0 +103,48 @@\n+\n+ifeq ($(OPENJDK_TARGET_OS), linux)\n+  $(eval $(call SetupJdkExecutable, BUILD_RESTORE_SCRIPT, \\\n+      NAME := action-script, \\\n+      SRC := $(TOPDIR)\/src\/$(MODULE)\/unix\/native\/action-script, \\\n+      INCLUDE_FILES := action-script.c, \\\n+      OPTIMIZATION := HIGH, \\\n+      CFLAGS := $(CFLAGS_JDKEXE), \\\n+      LDFLAGS := $(LDFLAGS_JDKEXE), \\\n+      OUTPUT_DIR := $(SUPPORT_OUTPUTDIR)\/modules_libs\/$(MODULE), \\\n+  ))\n+  TARGETS += $(BUILD_RESTORE_SCRIPT)\n+\n+  $(eval $(call SetupJdkExecutable, BUILD_WAIT, \\\n+      NAME := wait, \\\n+      SRC := $(TOPDIR)\/src\/$(MODULE)\/unix\/native\/wait, \\\n+      INCLUDE_FILES := wait.c, \\\n+      OPTIMIZATION := LOW, \\\n+      CFLAGS := $(CFLAGS_JDKEXE), \\\n+      LDFLAGS := $(LDFLAGS_JDKEXE), \\\n+      OUTPUT_DIR := $(SUPPORT_OUTPUTDIR)\/modules_libs\/$(MODULE), \\\n+  ))\n+  TARGETS += $(BUILD_WAIT)\n+\n+  $(eval $(call SetupJdkExecutable, BUILD_CRIU_WRAPPER, \\\n+      NAME := criu, \\\n+      SRC := $(TOPDIR)\/src\/$(MODULE)\/unix\/native\/criu, \\\n+      INCLUDE_FILES := criu.c, \\\n+      OPTIMIZATION := LOW, \\\n+      CFLAGS := $(CFLAGS_JDKEXE), \\\n+      LDFLAGS := $(LDFLAGS_JDKEXE), \\\n+      OUTPUT_DIR := $(SUPPORT_OUTPUTDIR)\/modules_libs\/$(MODULE), \\\n+  ))\n+  TARGETS += $(BUILD_CRIU_WRAPPER)\n+\n+  $(eval $(call SetupJdkExecutable, BUILD_JAVA_TIME, \\\n+      NAME := javatime, \\\n+      SRC := $(TOPDIR)\/src\/$(MODULE)\/unix\/native\/javatime, \\\n+      INCLUDE_FILES := javatime.c, \\\n+      OPTIMIZATION := LOW, \\\n+      CFLAGS := $(CFLAGS_JDKEXE), \\\n+      LDFLAGS := $(LDFLAGS_JDKEXE), \\\n+      OUTPUT_DIR := $(SUPPORT_OUTPUTDIR)\/modules_libs\/$(MODULE), \\\n+  ))\n+  TARGETS += $(BUILD_JAVA_TIME)\n+endif\n+\n+################################################################################\n","filename":"make\/launcher\/Launcher-java.base.gmk","additions":48,"deletions":0,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2017, 2020, Azul Systems, Inc. All rights reserved.\n@@ -39,0 +40,1 @@\n+#include \"memory\/oopFactory.hpp\"\n@@ -40,0 +42,1 @@\n+#include \"oops\/typeArrayOop.inline.hpp\"\n@@ -44,0 +47,1 @@\n+#include \"perfMemory_linux.hpp\"\n@@ -68,0 +72,1 @@\n+#include \"services\/heapDumper.hpp\"\n@@ -80,0 +85,1 @@\n+# include <arpa\/inet.h>\n@@ -84,0 +90,1 @@\n+# include <sys\/sysmacros.h>\n@@ -112,0 +119,1 @@\n+# include <libgen.h>\n@@ -141,0 +149,143 @@\n+class FdsInfo {\n+public:\n+\n+  enum state_t {\n+    INVALID = -3,\n+    CLOSED = -2,\n+    ROOT = -1,\n+    DUP_OF_0 = 0,\n+    \/\/ ...\n+  };\n+\n+  enum mark_t {\n+    M_ZIP_CACHE    = 1 << 0,\n+    M_CANT_RESTORE = 1 << 1,\n+    M_CLASSPATH    = 1 << 2,\n+    M_PERSISTENT   = 1 << 3,\n+  };\n+\n+private:\n+  struct fdinfo {\n+    struct stat stat;\n+    state_t state;\n+    unsigned mark;\n+\n+    int flags;\n+  };\n+\n+  bool same_fd(int fd1, int fd2);\n+\n+  fdinfo *_fdinfos;\n+  int _len;\n+\n+  void assert_mark(int i) {\n+    assert(inited(), \"\");\n+    assert(i < len(), \"\");\n+    assert(_fdinfos[i].state != CLOSED, \"\");\n+  }\n+\n+public:\n+  void initialize();\n+\n+  bool inited() { return _fdinfos != NULL; }\n+  int len() { return _len; }\n+\n+  state_t get_state(int i, state_t orstate = INVALID) {\n+    assert(inited(), \"\");\n+    if (i < len()) {\n+      return _fdinfos[i].state;\n+    }\n+    guarantee(orstate != INVALID, \"can't use default orstate\");\n+    return orstate;\n+  }\n+\n+  void set_state(int i, state_t newst) {\n+    assert(inited(), \"\");\n+    assert(i < len(), \"\");\n+    _fdinfos[i].state = newst;\n+  }\n+\n+  void mark(int i, mark_t m) {\n+    assert_mark(i);\n+    _fdinfos[i].mark |= (unsigned)m;\n+  }\n+  void clear(int i, mark_t m) {\n+    assert_mark(i);\n+    _fdinfos[i].mark &= ~(unsigned)m;\n+  }\n+  bool check(int i, mark_t m) {\n+    assert_mark(i);\n+    return 0 != (_fdinfos[i].mark & (unsigned)m);\n+  }\n+\n+  struct stat* get_stat(int i) {\n+    assert(inited(), \"\");\n+    assert(i < len(), \"\");\n+    return &_fdinfos[i].stat;\n+  }\n+\n+  FdsInfo(bool do_init = true) :\n+    _fdinfos(NULL),\n+    _len(-1)\n+  {\n+    if (do_init) {\n+      initialize();\n+    }\n+  }\n+\n+  ~FdsInfo() {\n+    if (_fdinfos) {\n+      FREE_C_HEAP_ARRAY(fdinfo, _fdinfos);\n+    }\n+  }\n+};\n+\n+struct PersistentResourceDesc {\n+  int _fd;\n+  dev_t _st_dev;\n+  ino_t _st_ino;\n+  PersistentResourceDesc(int fd, int st_dev, int st_ino) :\n+    _fd(fd),\n+    _st_dev((dev_t)st_dev),\n+    _st_ino((ino_t)st_ino)\n+  {}\n+\n+  PersistentResourceDesc() :\n+    _fd(INT_MAX)\n+  {}\n+};\n+\n+struct CracFailDep {\n+  int _type;\n+  char* _msg;\n+  CracFailDep(int type, char* msg) :\n+    _type(type),\n+    _msg(msg)\n+  { }\n+  CracFailDep() :\n+    _type(JVM_CR_FAIL),\n+    _msg(NULL)\n+  { }\n+};\n+\n+class VM_Crac: public VM_Operation {\n+  bool _ok;\n+  GrowableArray<CracFailDep>* _failures;\n+ public:\n+  VM_Crac() :\n+    _ok(false),\n+    _failures(new (ResourceObj::C_HEAP, mtInternal) GrowableArray<CracFailDep>(0, true\/*C_heap*\/))\n+  { }\n+\n+  ~VM_Crac() {\n+    delete _failures;\n+  }\n+\n+  GrowableArray<CracFailDep>* failures() { return _failures; }\n+\n+  bool ok() { return _ok; }\n+  virtual bool allow_nested_vm_operations() const  { return true; }\n+  VMOp_Type type() const { return VMOp_VM_Crac; }\n+  void doit();\n+};\n+\n@@ -156,0 +307,2 @@\n+static const char* _criu = NULL;\n+\n@@ -177,0 +330,4 @@\n+FdsInfo _vm_inited_fds(false);\n+\n+static GrowableArray<PersistentResourceDesc>* _persistent_resources = NULL;\n+\n@@ -512,1 +669,1 @@\n-static sigset_t unblocked_sigs, vm_sigs;\n+static sigset_t unblocked_sigs, blocked_sigs, vm_sigs;\n@@ -556,0 +713,4 @@\n+\n+  sigemptyset(&blocked_sigs);\n+  sigaddset(&blocked_sigs, RESTORE_SIGNAL);\n+\n@@ -584,0 +745,1 @@\n+  pthread_sigmask(SIG_BLOCK, &blocked_sigs, NULL);\n@@ -6161,0 +6323,749 @@\n+static void trace_cr(const char* msg, ...) {\n+  if (CRTrace) {\n+    va_list ap;\n+    va_start(ap, msg);\n+    tty->print(\"CR: \");\n+    tty->vprint_cr(msg, ap);\n+    va_end(ap);\n+  }\n+}\n+\n+void os::Linux::vm_create_start() {\n+  if (!CRaCCheckpointTo) {\n+    return;\n+  }\n+  _vm_inited_fds.initialize();\n+}\n+\n+\/* taken from criu, that took this from kernel *\/\n+#define NFS_PREF \".nfs\"\n+#define NFS_PREF_LEN ((unsigned)sizeof(NFS_PREF) - 1)\n+#define NFS_FILEID_LEN ((unsigned)sizeof(uint64_t) << 1)\n+#define NFS_COUNTER_LEN ((unsigned)sizeof(unsigned int) << 1)\n+#define NFS_LEN (NFS_PREF_LEN + NFS_FILEID_LEN + NFS_COUNTER_LEN)\n+static bool nfs_silly_rename(char* path) {\n+  char *sep = strrchr(path, '\/');\n+  char *base = sep ? sep + 1 : path;\n+  if (strncmp(base, NFS_PREF, NFS_PREF_LEN)) {\n+    return false;\n+  }\n+  for (unsigned i = NFS_PREF_LEN; i < NFS_LEN; ++i) {\n+    if (!isxdigit(base[i])) {\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n+static int readfdlink(int fd, char *link, size_t len) {\n+  char fdpath[64];\n+  snprintf(fdpath, sizeof(fdpath), \"\/proc\/self\/fd\/%d\", fd);\n+  int ret = readlink(fdpath, link, len);\n+  if (ret == -1) {\n+    return ret;\n+  }\n+  link[(unsigned)ret < len ? ret : len - 1] = '\\0';\n+  return ret;\n+}\n+\n+static bool same_stat(struct stat* st1, struct stat* st2) {\n+  return st1->st_dev == st2->st_dev &&\n+         st1->st_ino == st2->st_ino;\n+}\n+\n+bool FdsInfo::same_fd(int fd1, int fd2) {\n+  if (!same_stat(get_stat(fd1), get_stat(fd2))) {\n+    return false;\n+  }\n+\n+  int flags1 = fcntl(fd1, F_GETFL);\n+  int flags2 = fcntl(fd2, F_GETFL);\n+  if (flags1 != flags2) {\n+    return false;\n+  }\n+\n+  const int test_flag = O_NONBLOCK;\n+  const int new_flags1 = flags1 ^ test_flag;\n+  fcntl(fd1, F_SETFL, new_flags1);\n+  if (fcntl(fd1, F_GETFL) != new_flags1) {\n+    \/\/ flag write ignored or handled differently,\n+    \/\/ don't know what to do\n+    return false;\n+  }\n+\n+  const int new_flags2 = fcntl(fd2, F_GETFL);\n+  const bool are_same = new_flags1 == new_flags2;\n+\n+  fcntl(fd1, flags1);\n+\n+  return are_same;\n+}\n+\n+void FdsInfo::initialize() {\n+  assert(!inited(), \"should be called only once\");\n+\n+  const int max_fd = sysconf(_SC_OPEN_MAX);\n+  _fdinfos = NEW_C_HEAP_ARRAY(fdinfo, max_fd, mtInternal);\n+  int last_fd = -1;\n+\n+  for (int i = 0; i < max_fd; ++i) {\n+    fdinfo* info = _fdinfos + i;\n+    int r = fstat(i, &info->stat);\n+    if (r == -1) {\n+      info->state = CLOSED;\n+      continue;\n+    }\n+    info->state = ROOT; \/\/ can be changed to DUP_OF_0 + N below\n+    info->mark = 0;\n+    last_fd = i;\n+  }\n+  _len = last_fd + 1;\n+  _fdinfos = REALLOC_C_HEAP_ARRAY(fdinfo, _fdinfos, _len, mtInternal);\n+\n+  for (int i = 0; i < _len; ++i) {\n+    for (int j = 0; j < i; ++j) {\n+      if (get_state(j) == ROOT && same_fd(i, j)) {\n+        _fdinfos[i].state = (state_t)(DUP_OF_0 + j);\n+        break;\n+      }\n+    }\n+\n+    if (get_state(i) == ROOT) {\n+      char fdpath[PATH_MAX];\n+      int r = readfdlink(i, fdpath, sizeof(fdpath));\n+      guarantee(-1 != r, \"can't stat fd\");\n+      if (get_stat(i)->st_nlink == 0 ||\n+          strstr(fdpath, \"(deleted)\") ||\n+          nfs_silly_rename(fdpath)) {\n+        mark(i, FdsInfo::M_CANT_RESTORE);\n+      }\n+    }\n+  }\n+}\n+\n+static void mark_classpath_entry(FdsInfo *fds, char* cp) {\n+  struct stat st;\n+  if (-1 == stat(cp, &st)) {\n+    return;\n+  }\n+  for (int i = 0; i < fds->len(); ++i) {\n+    if (same_stat(&st, fds->get_stat(i))) {\n+      fds->mark(i, FdsInfo::M_CLASSPATH);\n+    }\n+  }\n+}\n+\n+static void do_classpaths(void (*fn)(FdsInfo*, char*), FdsInfo *fds, char* classpath) {\n+  assert(SafepointSynchronize::is_at_safepoint(),\n+      \"can't do nasty things with sysclasspath\");\n+  char *cp = classpath;\n+  char *n;\n+  while ((n = strchr(cp, ':'))) {\n+    *n = '\\0';\n+    fn(fds, cp);\n+    *n = ':';\n+    cp = n + 1;\n+  }\n+  mark_classpath_entry(fds, cp);\n+}\n+\n+\n+static void mark_all_in(FdsInfo *fds, char* dirpath) {\n+  DIR *dir = os::opendir(dirpath);\n+  if (!dir) {\n+    return;\n+  }\n+\n+  struct dirent* dent;\n+  while ((dent = os::readdir(dir))) {\n+    for (int i = 0; i < fds->len(); ++i) {\n+      if (fds->get_state(i) != FdsInfo::ROOT) {\n+        continue;\n+      }\n+      struct stat* fstat = fds->get_stat(i);\n+      if (dent->d_ino == fstat->st_ino) {\n+        fds->mark(i, FdsInfo::M_CLASSPATH);\n+      }\n+    }\n+  }\n+\n+  os::closedir(dir);\n+}\n+\n+static void mark_persistent(FdsInfo *fds) {\n+  if (!_persistent_resources) {\n+    return;\n+  }\n+\n+  for (int i = 0; i < _persistent_resources->length(); ++i) {\n+    PersistentResourceDesc* pr = _persistent_resources->adr_at(i);\n+    int fd = pr->_fd;\n+    if (fds->len() <= fd) {\n+      break;\n+    }\n+    if (fds->get_state(fd) != FdsInfo::ROOT) {\n+      continue;\n+    }\n+    struct stat* st = fds->get_stat(fd);\n+    if (st->st_dev == pr->_st_dev && st->st_ino == pr->_st_ino) {\n+      fds->mark(fd, FdsInfo::M_PERSISTENT);\n+    }\n+  }\n+\n+  delete _persistent_resources;\n+  _persistent_resources = NULL;\n+}\n+\n+static void cr_util_path(char* path, int len) {\n+  os::jvm_path(path, len);\n+  \/\/ path is \"...\/lib\/server\/libjvm.so\"\n+  for (int i = 0; i < 2; ++i) {\n+    char *after_elem = strrchr(path, '\/');\n+    *after_elem = '\\0';\n+  }\n+}\n+\n+static const char* compute_criu(const char *util_path) {\n+  if (_criu) {\n+    return _criu;\n+  }\n+\n+#define SUF \"criu\"\n+  const size_t criulen = strlen(util_path) + 1 + sizeof(SUF);\n+  char *criu = NEW_C_HEAP_ARRAY(char, criulen, mtInternal);\n+  assert(criu != NULL, \"JVM should fail\");\n+  int r = jio_snprintf(criu, criulen, \"%s\/\" SUF, util_path);\n+#undef SUF\n+  assert(r < (int)criulen, \"len miscalc\");\n+\n+  struct stat dummy;\n+  if (0 == stat(criu, &dummy)) {\n+    _criu = criu;\n+  } else {\n+    FREE_C_HEAP_ARRAY(char, criu);\n+    warning(\"Could not find %s: %s\", criu, strerror(errno));\n+    \/\/ use system one\n+    _criu = \"criu\";\n+  }\n+  return _criu;\n+}\n+\n+static int call_criu() {\n+  char util_path[JVM_MAXPATHLEN];\n+  cr_util_path(util_path, sizeof(util_path));\n+\n+  const char* criu = compute_criu(util_path);\n+\n+  pid_t jvm = getpid();\n+\n+  char cmd[3 * JVM_MAXPATHLEN];\n+  if ((int)sizeof(cmd) <= snprintf(cmd, sizeof(cmd),\n+        \"%s dump\"\n+        \" -t %d\"\n+        \" -D %s\"\n+        \" --action-script %s\/action-script\"\n+        \" --shell-job\"\n+        \" -v4 -o dump4.log\", \/\/ -D without -W makes criu cd to image dir for logs\n+        criu, jvm, CRaCCheckpointTo, util_path)) {\n+    trace_cr(\"can't fit CRIU cmd\");\n+    return -1;\n+  }\n+\n+  if (fork()) {\n+    \/\/ main JVM\n+    wait(NULL);\n+    return 0;\n+  }\n+\n+  pid_t parent_before = getpid();\n+\n+  \/\/ child\n+  if (fork()) {\n+    exit(0);\n+  }\n+  \/\/ grand-child\n+  pid_t parent = getppid();\n+  int tries = 300;\n+  while (parent != 1 && 0 < tries--) {\n+    ::usleep(10);\n+    parent = getppid();\n+  }\n+\n+  if (parent == parent_before) {\n+    trace_cr(\"can't move out of JVM process hierarchy\");\n+    union sigval sv = { .sival_int = -1 };\n+    sigqueue(jvm, RESTORE_SIGNAL, sv);\n+    exit(0);\n+  }\n+\n+  int cmdres = system(cmd);\n+  if (cmdres < 0 || !WIFEXITED(cmdres) || WEXITSTATUS(cmdres)) {\n+    trace_cr(\"%s call failed\", criu);\n+    union sigval sv = { .sival_int = -1 };\n+    sigqueue(jvm, RESTORE_SIGNAL, sv);\n+    exit(0);\n+  }\n+  exit(0);\n+}\n+\n+static int checkpoint_restore(FdsInfo* fds) {\n+\n+  if (CRAllowToSkipCheckpoint) {\n+    trace_cr(\"Skip Checkpoint\");\n+    return JVM_CHECKPOINT_OK;\n+  }\n+\n+  trace_cr(\"Checkpoint ...\");\n+\n+  int criu_res = call_criu();\n+  if (criu_res < 0) {\n+    return JVM_CHECKPOINT_ERROR;\n+  }\n+\n+  sigset_t waitmask;\n+  sigemptyset(&waitmask);\n+  sigaddset(&waitmask, RESTORE_SIGNAL);\n+\n+  siginfo_t info;\n+  int sig;\n+  do {\n+    sig = sigwaitinfo(&waitmask, &info);\n+  } while (sig == -1 && errno == EINTR);\n+  assert(sig == RESTORE_SIGNAL, \"got what requested\");\n+\n+  if (CRTraceStartupTime) {\n+    tty->print_cr(\"STARTUPTIME \" JLONG_FORMAT \" restore-native\", os::javaTimeNanos());\n+  }\n+\n+  if (info.si_code != SI_QUEUE || info.si_int < 0) {\n+    tty->print_cr(\"JVM: invalid info for restore provided (may be failed checkpoint)\");\n+    return JVM_CHECKPOINT_ERROR;\n+  }\n+\n+  return info.si_int;\n+}\n+\n+static const char* stat2strtype(mode_t mode) {\n+  switch (mode & S_IFMT) {\n+  case S_IFSOCK: return \"socket\";\n+  case S_IFLNK:  return \"symlink\";\n+  case S_IFREG:  return \"regular\";\n+  case S_IFBLK:  return \"block\";\n+  case S_IFDIR:  return \"directory\";\n+  case S_IFCHR:  return \"character\";\n+  case S_IFIFO:  return \"fifo\";\n+  default:       break;\n+  }\n+  return \"unknown\";\n+}\n+\n+static int stat2stfail(mode_t mode) {\n+  switch (mode & S_IFMT) {\n+  case S_IFSOCK:\n+    return JVM_CR_FAIL_SOCK;\n+  case S_IFLNK:\n+  case S_IFREG:\n+  case S_IFBLK:\n+  case S_IFDIR:\n+  case S_IFCHR:\n+    return JVM_CR_FAIL_FILE;\n+  case S_IFIFO:\n+    return JVM_CR_FAIL_PIPE;\n+  default:\n+    break;\n+  }\n+  return JVM_CR_FAIL;\n+}\n+\n+static bool find_sock_details(int sockino, const char* base, bool v6, char* buf, size_t sz) {\n+  char filename[16];\n+  snprintf(filename, sizeof(filename), \"\/proc\/net\/%s\", base);\n+  FILE* f = fopen(filename, \"r\");\n+  if (!f) {\n+    return false;\n+  }\n+  int r = fscanf(f, \"%*[^\\n]\");\n+  if (r) {} \/\/ suppress warn unused gcc diagnostic\n+\n+  char la[33], ra[33];\n+  int lp, rp;\n+  int ino;\n+  \/\/   sl  local_address         remote_address        st   tx_queue rx_queue tr tm->when retrnsmt   uid  timeout inode\n+  \/\/    0: 0100007F:08AE         00000000:0000         0A   00000000:00000000 00:00000000 00000000  1000        0 2988639\n+  \/\/  %4d: %08X%08X%08X%08X:%04X %08X%08X%08X%08X:%04X %02X %08X:%08X         %02X:%08lX  %08X       %5u      %8d %d\n+  bool eof;\n+  do {\n+    eof = EOF == fscanf(f, \"%*d: %[^:]:%X %[^:]:%X %*X %*X:%*X %*X:%*X %*X %*d %*d %d%*[^\\n]\\n\",\n+        la, &lp, ra, &rp, &ino);\n+  } while (ino != sockino && !eof);\n+  fclose(f);\n+\n+  if (ino != sockino) {\n+    return false;\n+  }\n+\n+  struct in6_addr a6l, a6r;\n+  struct in_addr a4l, a4r;\n+  if (v6) {\n+    for (int i = 0; i < 4; ++i) {\n+      sscanf(la + i * 8, \"%8\" PRIX32, a6l.s6_addr32 + i);\n+      sscanf(ra + i * 8, \"%8\" PRIX32, a6r.s6_addr32 + i);\n+    }\n+  } else {\n+    sscanf(la, \"%\" PRIX32, &a4l.s_addr);\n+    sscanf(ra, \"%\" PRIX32, &a4r.s_addr);\n+  }\n+\n+  int const af = v6 ? AF_INET6 : AF_INET;\n+  void* const laddr = v6 ? (void*)&a6l : (void*)&a4l;\n+  void* const raddr = v6 ? (void*)&a6r : (void*)&a4r;\n+  char lstrb[48], rstrb[48];\n+  const char* const lstr = ::inet_ntop(af, laddr, lstrb, sizeof(lstrb)) ? lstrb : \"NONE\";\n+  const char* const rstr = ::inet_ntop(af, raddr, rstrb, sizeof(rstrb)) ? rstrb : \"NONE\";\n+  int msgsz = snprintf(buf, sz, \"%s localAddr %s localPort %d remoteAddr %s remotePort %d\",\n+        base, lstr, lp, rstr, rp);\n+  return msgsz < (int)sz;\n+}\n+\n+static const char* sock_details(const char* details, char* buf, size_t sz) {\n+  int sockino;\n+  if (sscanf(details, \"socket:[%d]\", &sockino) <= 0) {\n+    return details;\n+  }\n+\n+  const char* bases[] = { \"tcp\", \"udp\", \"tcp6\", \"udp6\", NULL };\n+  for (const char** b = bases; *b; ++b) {\n+    if (find_sock_details(sockino, *b, 2 <= b - bases, buf, sz)) {\n+      return buf;\n+    }\n+  }\n+\n+  return details;\n+}\n+\n+\n+void VM_Crac::doit() {\n+\n+  AttachListener::abort();\n+\n+  FdsInfo fds;\n+  do_classpaths(mark_classpath_entry, &fds, Arguments::get_sysclasspath());\n+  do_classpaths(mark_classpath_entry, &fds, Arguments::get_appclasspath());\n+  do_classpaths(mark_all_in, &fds, Arguments::get_ext_dirs());\n+  mark_persistent(&fds);\n+\n+  bool ok = true;\n+  for (int i = 0; i < fds.len(); ++i) {\n+    if (fds.get_state(i) == FdsInfo::CLOSED) {\n+      continue;\n+    }\n+\n+    char detailsbuf[128];\n+    int linkret = readfdlink(i, detailsbuf, sizeof(detailsbuf));\n+    const char* details = 0 < linkret ? detailsbuf : \"\";\n+    if (CRPrintResourcesOnCheckpoint) {\n+      tty->print(\"JVM: FD fd=%d type=%s: details1=\\\"%s\\\" \",\n+          i, stat2strtype(fds.get_stat(i)->st_mode), details);\n+    }\n+\n+    if (_vm_inited_fds.get_state(i, FdsInfo::CLOSED) != FdsInfo::CLOSED) {\n+      if (CRPrintResourcesOnCheckpoint) {\n+        tty->print_cr(\"OK: inherited from process env\");\n+      }\n+      continue;\n+    }\n+\n+    struct stat* st = fds.get_stat(i);\n+    if (S_ISCHR(st->st_mode)) {\n+      const int mjr = major(st->st_rdev);\n+      const int mnr = minor(st->st_rdev);\n+      if (mjr == 1 && (mnr == 8 || mnr == 9)) {\n+        if (CRPrintResourcesOnCheckpoint) {\n+          tty->print_cr(\"OK: always available, random or urandom\");\n+        }\n+        continue;\n+      }\n+    }\n+\n+    if (fds.check(i, FdsInfo::M_CLASSPATH) && !fds.check(i, FdsInfo::M_CANT_RESTORE)) {\n+      if (CRPrintResourcesOnCheckpoint) {\n+        tty->print_cr(\"OK: in classpath\");\n+      }\n+      continue;\n+    }\n+\n+    if (fds.check(i, FdsInfo::M_PERSISTENT)) {\n+      if (CRPrintResourcesOnCheckpoint) {\n+        tty->print_cr(\"OK: assured persistent\");\n+      }\n+      continue;\n+    }\n+\n+    if (CRPrintResourcesOnCheckpoint) {\n+      tty->print(\"BAD: opened by application\");\n+    }\n+    ok = false;\n+\n+    if (S_ISSOCK(st->st_mode)) {\n+      details = sock_details(details, detailsbuf, sizeof(detailsbuf));\n+      if (CRPrintResourcesOnCheckpoint) {\n+        tty->print(\" details2=\\\"%s\\\" \", details);\n+      }\n+    }\n+\n+    if (CRPrintResourcesOnCheckpoint) {\n+      tty->cr();\n+    }\n+    char* msg = NEW_C_HEAP_ARRAY(char, strlen(details) + 1, mtInternal);\n+    strcpy(msg, details);\n+    _failures->append(CracFailDep(stat2stfail(st->st_mode & S_IFMT), msg));\n+  }\n+\n+  if (!ok && CRHeapDumpOnCheckpointException) {\n+    HeapDumper::dump_heap();\n+  }\n+\n+  if (!ok && CRDoThrowCheckpointException) {\n+    return;\n+  }\n+\n+  if (!PerfMemoryLinux::checkpoint(CRaCCheckpointTo)) {\n+    return;\n+  }\n+\n+  int ret = checkpoint_restore(&fds);\n+  if (ret == JVM_CHECKPOINT_ERROR) {\n+    PerfMemoryLinux::checkpoint_fail();\n+    return;\n+  }\n+\n+  PerfMemoryLinux::restore();\n+\n+  _ok = true;\n+}\n+\n+void os::Linux::register_persistent_fd(int fd, int st_dev, int st_ino) {\n+  if (!CRaCCheckpointTo) {\n+    return;\n+  }\n+  if (!_persistent_resources) {\n+    _persistent_resources = new (ResourceObj::C_HEAP, mtInternal)\n+      GrowableArray<PersistentResourceDesc>(0, true\/*C_heap*\/);\n+  }\n+  int dup = -1;\n+  int i = 0;\n+  while (i < _persistent_resources->length()) {\n+    int pfd = _persistent_resources->adr_at(i)->_fd;\n+    if (pfd == fd) {\n+      dup = i;\n+      break;\n+    } else if (fd < pfd) {\n+      break;\n+    }\n+    ++i;\n+  }\n+\n+  if (0 <= dup) {\n+    _persistent_resources->at_put(dup, PersistentResourceDesc(fd, st_dev, st_ino));\n+  } else {\n+    _persistent_resources->insert_before(i, PersistentResourceDesc(fd, st_dev, st_ino));\n+  }\n+}\n+\n+void os::Linux::deregister_persistent_fd(int fd, int st_dev, int st_ino) {\n+  if (!CRaCCheckpointTo) {\n+    return;\n+  }\n+  if (!_persistent_resources) {\n+    return;\n+  }\n+  int i = 0;\n+  while (i < _persistent_resources->length()) {\n+    PersistentResourceDesc* pr = _persistent_resources->adr_at(i);\n+    if (pr->_fd == fd && pr->_st_dev == (dev_t)st_dev && pr->_st_ino == (ino_t)st_ino) {\n+      break;\n+    }\n+  }\n+  if (i < _persistent_resources->length()) {\n+    _persistent_resources->remove_at(i);\n+  }\n+}\n+\n+bool os::Linux::prepare_checkpoint() {\n+  struct stat st;\n+\n+  if (0 == stat(CRaCCheckpointTo, &st)) {\n+    if ((st.st_mode & S_IFMT) != S_IFDIR) {\n+      warning(\"%s: not a directory\", CRaCCheckpointTo);\n+      return false;\n+    }\n+  } else {\n+    if (-1 == mkdir(CRaCCheckpointTo, 0700)) {\n+      warning(\"cannot create %s: %s\", CRaCCheckpointTo, strerror(errno));\n+      return false;\n+    }\n+    if (-1 == rmdir(CRaCCheckpointTo)) {\n+      warning(\"cannot cleanup after check: %s\", strerror(errno));\n+      \/\/ not fatal\n+    }\n+  }\n+\n+  return true;\n+}\n+\n+static Handle ret_cr(int ret, Handle codes, Handle msgs, TRAPS) {\n+  objArrayOop bundleObj = oopFactory::new_objectArray(3, CHECK_NH);\n+  objArrayHandle bundle(THREAD, bundleObj);\n+  jvalue jval = { .i = ret };\n+  oop retObj = java_lang_boxing_object::create(T_INT, &jval, CHECK_NH);\n+  bundle->obj_at_put(0, retObj);\n+  bundle->obj_at_put(1, codes());\n+  bundle->obj_at_put(2, msgs());\n+  return bundle;\n+}\n+\n+static Handle ret_cr(int ret, TRAPS) {\n+  return ret_cr(ret, Handle(), Handle(), THREAD);\n+}\n+\n+\/** Checkpoint main entry.\n+ *\/\n+Handle os::Linux::checkpoint(TRAPS) {\n+  if (!CRaCCheckpointTo) {\n+    return ret_cr(JVM_CHECKPOINT_NONE, THREAD);\n+  }\n+\n+  if (-1 == mkdir(CRaCCheckpointTo, 0700) && errno != EEXIST) {\n+    warning(\"cannot create %s: %s\", CRaCCheckpointTo, strerror(errno));\n+    return ret_cr(JVM_CHECKPOINT_NONE, THREAD);\n+  }\n+\n+  Universe::heap()->set_cleanup_unused(true);\n+  Universe::heap()->collect(GCCause::_full_gc_alot);\n+  Universe::heap()->set_cleanup_unused(false);\n+\n+  VM_Crac cr;\n+  {\n+    MutexLocker ml(Heap_lock);\n+    VMThread::execute(&cr);\n+  }\n+  if (cr.ok()) {\n+    return ret_cr(JVM_CHECKPOINT_OK, THREAD);\n+  }\n+\n+  GrowableArray<CracFailDep>* failures = cr.failures();\n+\n+  typeArrayOop codesObj = oopFactory::new_intArray(failures->length(), CHECK_NH);\n+  typeArrayHandle codes(THREAD, codesObj);\n+  objArrayOop msgsObj = oopFactory::new_objArray(SystemDictionary::String_klass(), failures->length(), CHECK_NH);\n+  objArrayHandle msgs(THREAD, msgsObj);\n+\n+  for (int i = 0; i < failures->length(); ++i) {\n+    codes->int_at_put(i, failures->at(i)._type);\n+    oop msgObj = java_lang_String::create_oop_from_str(failures->at(i)._msg, CHECK_NH);\n+    FREE_C_HEAP_ARRAY(char, failures->at(i)._msg);\n+    msgs->obj_at_put(i, msgObj);\n+  }\n+\n+  return ret_cr(JVM_CHECKPOINT_ERROR, codes, msgs, THREAD);\n+}\n+\n+static char* add_arg(char** begin_p, char* end, const char *fmt, ...) {\n+  char* begin = *begin_p;\n+\n+  va_list va;\n+  va_start(va, fmt);\n+\n+  int len = vsnprintf(begin, end - begin, fmt, va);\n+  if (end <= begin + len) {\n+    return NULL;\n+  }\n+  *begin_p = begin + len + 1;\n+  return begin;\n+}\n+\n+void os::Linux::restore() {\n+  struct stat st;\n+\n+  char util_path[JVM_MAXPATHLEN];\n+  cr_util_path(util_path, sizeof(util_path));\n+\n+  const char *criu = compute_criu(util_path);\n+\n+  char tempbuf[4 * JVM_MAXPATHLEN];\n+  char* end = tempbuf + sizeof(tempbuf);\n+  char* bufp = tempbuf;\n+\n+  snprintf(bufp, end - bufp, \"%s\/cppath\", CRaCRestoreFrom);\n+  int fd_cppath = ::open(bufp, O_RDONLY);\n+  if (fd_cppath < 0) {\n+    trace_cr(\"no valid image to restore: %s\", CRaCRestoreFrom);\n+    return;\n+  }\n+  int cppathlen = read(fd_cppath, bufp, end - bufp);\n+  close(fd_cppath);\n+\n+  char *cppath = bufp;\n+  if (cppathlen < 0) {\n+    warning(\"cannot read image: %s\", strerror(errno));\n+    return;\n+  }\n+  if (cppathlen == end - bufp) {\n+    warning(\"invalid image: content too long\");\n+    return;\n+  }\n+  bufp[cppathlen] = '\\0';\n+  bufp += cppathlen + 1;\n+\n+  char* restore_script = add_arg(&bufp, end, \"%s\/action-script\", util_path);\n+  if (!restore_script) {\n+    warning(\"cannot format restore_script path\");\n+    return;\n+  }\n+\n+  char* wait = add_arg(&bufp, end, \"%s\/wait\", util_path);\n+  if (!wait) {\n+    warning(\"cannot format action-script path\");\n+    return;\n+  }\n+\n+  snprintf(bufp, end - bufp, \"%s\/%s\", CRaCRestoreFrom, PerfMemoryLinux::perfdata_name());\n+  int fd_perfdata = ::open(bufp, O_RDWR);\n+  char* inherit_perfdata = NULL;\n+  if (0 < fd_perfdata) {\n+    inherit_perfdata = add_arg(&bufp, end, \"fd[%d]:%s\/%s\",\n+        fd_perfdata,\n+        cppath[0] == '\/' ? cppath + 1 : cppath,\n+        PerfMemoryLinux::perfdata_name());\n+  }\n+\n+  if (CRTraceStartupTime) {\n+    tty->print_cr(\"STARTUPTIME \" JLONG_FORMAT \" criu-call\", os::javaTimeNanos());\n+  }\n+\n+  const char* args[32];\n+  const char** argp = args;\n+  *argp++ = criu;\n+  *argp++ = \"restore\";\n+  *argp++ = \"-W\";\n+  *argp++ = \".\";\n+  if (inherit_perfdata) {\n+    *argp++ = \"--inherit-fd\";\n+    *argp++ = inherit_perfdata;\n+  }\n+  *argp++ = \"--shell-job\";\n+  *argp++ = \"--action-script\";\n+  *argp++ = restore_script;\n+  *argp++ = \"-D\";\n+  *argp++ = CRaCRestoreFrom;\n+  *argp++ = \"-v1\";\n+  *argp++ = \"--exec-cmd\";\n+  *argp++ = \"--\";\n+  *argp++ = wait;\n+  *argp++ = NULL;\n+  guarantee(argp - args < (int)ARRAY_SIZE(args), \"args overflow\");\n+\n+  execvp(criu, (char**)args);\n+  warning(\"cannot execute \\\"%s restore ...\\\" (%s)\", criu, strerror(errno));\n+}\n+\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":912,"deletions":1,"binary":false,"changes":913,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2017, 2020, Azul Systems, Inc. All rights reserved.\n@@ -202,0 +203,7 @@\n+  static void vm_create_start();\n+  static bool prepare_checkpoint();\n+  static Handle checkpoint(TRAPS);\n+  static void restore();\n+  static void register_persistent_fd(int fd, int st_dev, int st_ino);\n+  static void deregister_persistent_fd(int fd, int st_dev, int st_ino);\n+\n","filename":"src\/hotspot\/os\/linux\/os_linux.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2020, Azul Systems, Inc. All rights reserved.\n@@ -32,0 +33,1 @@\n+#include \"perfMemory_linux.hpp\"\n@@ -50,0 +52,1 @@\n+static int checkpoint_fd = -1;\n@@ -1349,0 +1352,119 @@\n+\n+bool PerfMemoryLinux::checkpoint(const char* checkpoint_path) {\n+  assert(checkpoint_path, \"should be set\");\n+\n+  if (!backing_store_file_name) {\n+    return true;\n+  }\n+\n+  char path[JVM_MAXPATHLEN];\n+  int pathlen = snprintf(path, sizeof(path),\"%s\/%s\", checkpoint_path, perfdata_name());\n+\n+  RESTARTABLE(::open(path, O_RDWR|O_CREAT|O_NOFOLLOW, S_IRUSR|S_IWUSR), checkpoint_fd);\n+  if (checkpoint_fd < 0) {\n+    tty->print_cr(\"cannot open checkpoint perfdata: %s\", os::strerror(errno));\n+    return false;\n+  }\n+\n+  char* p = PerfMemory::start();\n+  size_t len = PerfMemory::capacity();\n+  do {\n+    int result;\n+    RESTARTABLE(::write(checkpoint_fd, p, len), result);\n+    if (result == OS_ERR) {\n+      tty->print_cr(\"cannot write data to checkpoint perfdata file: %s\", os::strerror(errno));\n+      ::close(checkpoint_fd);\n+      checkpoint_fd = -1;\n+      return false;\n+    }\n+    p += result;\n+    len -= (size_t)result;\n+  } while (0 < len);\n+\n+  void* mmapret = ::mmap(PerfMemory::start(), PerfMemory::capacity(),\n+      PROT_READ|PROT_WRITE, MAP_FIXED|MAP_SHARED, checkpoint_fd, 0);\n+  if (MAP_FAILED == mmapret) {\n+    tty->print_cr(\"cannot mmap checkpoint perfdata file: %s\", os::strerror(errno));\n+    ::close(checkpoint_fd);\n+    checkpoint_fd = -1;\n+    return false;\n+  }\n+\n+  return true;\n+}\n+\n+bool PerfMemoryLinux::checkpoint_fail() {\n+  if (checkpoint_fd < 0) {\n+    return true;\n+  }\n+\n+  int fd;\n+  RESTARTABLE(::open(backing_store_file_name, O_RDWR|O_CREAT|O_NOFOLLOW, S_IRUSR|S_IWUSR), fd);\n+  if (fd == OS_ERR) {\n+    tty->print_cr(\"cannot open original perfdata file: %s\", os::strerror(errno));\n+    return false;\n+  }\n+\n+  void* mmapret = ::mmap(PerfMemory::start(), PerfMemory::capacity(),\n+      PROT_READ|PROT_WRITE, MAP_FIXED|MAP_SHARED, fd, 0);\n+  if (MAP_FAILED == mmapret) {\n+    tty->print_cr(\"cannot mmap old perfdata file: %s\", os::strerror(errno));\n+    ::close(fd);\n+    return false;\n+  }\n+\n+  return true;\n+}\n+\n+bool PerfMemoryLinux::restore() {\n+  if (checkpoint_fd < 0) {\n+    return true;\n+  }\n+\n+  int vmid = os::current_process_id();\n+  char* user_name = get_user_name(geteuid());\n+  char* dirname = get_user_tmp_dir(user_name, vmid, -1);\n+  if (!make_user_tmp_dir(dirname)) {\n+    return false;\n+  }\n+\n+  int fd;\n+  RESTARTABLE(::open(backing_store_file_name, O_RDWR|O_CREAT|O_NOFOLLOW, S_IRUSR|S_IWUSR), fd);\n+  if (fd == OS_ERR) {\n+    tty->print_cr(\"cannot open restore perfdata file: %s\", os::strerror(errno));\n+\n+    void* mmapret = ::mmap(PerfMemory::start(), PerfMemory::capacity(),\n+        PROT_READ|PROT_WRITE, MAP_FIXED|MAP_PRIVATE, checkpoint_fd, 0);\n+    if (MAP_FAILED == mmapret) {\n+      tty->print_cr(\"cannot remap checkpoint perfdata file: %s\", os::strerror(errno));\n+    }\n+    return false;\n+  }\n+\n+  char* p = PerfMemory::start();\n+  size_t len = PerfMemory::capacity();\n+  do {\n+    int result;\n+    RESTARTABLE(::write(fd, p, len), result);\n+    if (result == OS_ERR) {\n+      tty->print_cr(\"cannot write data to restore perfdata file: %s\", os::strerror(errno));\n+      ::close(fd);\n+      return false;\n+    }\n+    p += result;\n+    len -= (size_t)result;\n+  } while (0 < len);\n+\n+  void* mmapret = ::mmap(PerfMemory::start(), PerfMemory::capacity(),\n+      PROT_READ|PROT_WRITE, MAP_FIXED|MAP_SHARED, fd, 0);\n+  if (MAP_FAILED == mmapret) {\n+    tty->print_cr(\"cannot mmap restore perfdata file: %s\", os::strerror(errno));\n+    ::close(fd);\n+    return false;\n+  }\n+\n+  ::close(fd);\n+  ::close(checkpoint_fd);\n+  checkpoint_fd = -1;\n+  return true;\n+}\n","filename":"src\/hotspot\/os\/linux\/perfMemory_linux.cpp","additions":122,"deletions":0,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2020, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_LINUX_PERFMEMORY_LINUX_HPP\n+#define OS_LINUX_PERFMEMORY_LINUX_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+\n+class PerfMemoryLinux : AllStatic {\n+\n+public:\n+  static inline const char* perfdata_name() {\n+    return \"perfdata\";\n+  }\n+\n+  static bool checkpoint(const char* checkpoint_path);\n+  static bool checkpoint_fail();\n+  static bool restore();\n+};\n+\n+#endif \/\/ OS_LINUX_PERFMEMORY_LINUX_HPP\n+\n","filename":"src\/hotspot\/os\/linux\/perfMemory_linux.hpp","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -97,0 +97,4 @@\n+#ifdef LINUX\n+#define RESTORE_SIGNAL   (SIGRTMIN + 2)\n+#endif\n+\n","filename":"src\/hotspot\/os\/posix\/include\/jvm_md.h","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -675,0 +675,3 @@\n+  template(jdk_crac_Core,                          \"jdk\/crac\/Core\")                                               \\\n+  template(checkpointRestoreInternal_name,         \"checkpointRestoreInternal\")                                   \\\n+                                                                                                                  \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2019, Azul Systems, Inc. All rights reserved.\n@@ -1222,0 +1223,6 @@\n+  if (Universe::heap()->do_cleanup_unused()) {\n+    \/\/ HeapRegionManager::shrink_by do not allow remove all regions.\n+    \/\/ Make sure at least one is there.\n+    maximum_desired_capacity = HeapRegion::GrainBytes;\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2019, Azul Systems, Inc. All rights reserved.\n@@ -119,0 +120,7 @@\n+static void zero_cap(MutableSpace* ms) {\n+  os::cleanup_memory((char*)ms->top(), (char*)ms->end() - (char*)ms->top());\n+}\n+static void zero_all(MutableSpace* ms) {\n+  os::cleanup_memory((char*)ms->bottom(), (char*)ms->end() - (char*)ms->bottom());\n+}\n+\n@@ -334,0 +342,7 @@\n+    if (heap->do_cleanup_unused()) {\n+      zero_cap(young_gen->eden_space());\n+      zero_cap(young_gen->from_space());\n+      zero_all(young_gen->to_space());\n+      zero_cap(old_gen->object_space());\n+    }\n+\n","filename":"src\/hotspot\/share\/gc\/parallel\/psMarkSweep.cpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2019, Azul Systems, Inc. All rights reserved.\n@@ -1742,0 +1743,7 @@\n+static void zero_cap(MutableSpace* ms) {\n+  os::cleanup_memory((char*)ms->top(), (char*)ms->end() - (char*)ms->top());\n+}\n+static void zero_all(MutableSpace* ms) {\n+  os::cleanup_memory((char*)ms->bottom(), (char*)ms->end() - (char*)ms->bottom());\n+}\n+\n@@ -1911,0 +1919,7 @@\n+    if (heap->do_cleanup_unused()) {\n+      zero_cap(young_gen->eden_space());\n+      zero_cap(young_gen->from_space());\n+      zero_all(young_gen->to_space());\n+      zero_cap(old_gen->object_space());\n+    }\n+\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2019, Azul Systems, Inc. All rights reserved.\n@@ -365,0 +366,6 @@\n+  if (Universe::heap()->do_cleanup_unused()) {\n+    os::cleanup_memory((char*)eden()->top(), (char*)eden()->end() - (char*)eden()->top());\n+    os::cleanup_memory((char*)from()->top(), (char*)from()->end() - (char*)from()->top());\n+    os::cleanup_memory((char*)to()->top(), (char*)to()->end() - (char*)to()->top());\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2019, Azul Systems, Inc. All rights reserved.\n@@ -299,0 +300,3 @@\n+  if (Universe::heap()->do_cleanup_unused()) {\n+    shrink_bytes = capacity_after_gc - used_after_gc;\n+  }\n","filename":"src\/hotspot\/share\/gc\/shared\/cardGeneration.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -197,0 +197,1 @@\n+  _cleanup_unused(false),\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -114,0 +114,2 @@\n+  bool _cleanup_unused;\n+\n@@ -365,0 +367,3 @@\n+  void set_cleanup_unused(bool value) { _cleanup_unused = value; }\n+  bool do_cleanup_unused() const { return _cleanup_unused; }\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1219,0 +1219,21 @@\n+enum {\n+  JVM_CHECKPOINT_OK,\n+  JVM_CHECKPOINT_ERROR,\n+  JVM_CHECKPOINT_NONE,\n+};\n+\n+enum cr_fail_type {\n+  JVM_CR_FAIL      = 0,\n+  JVM_CR_FAIL_FILE = 1,\n+  JVM_CR_FAIL_SOCK = 2,\n+  JVM_CR_FAIL_PIPE = 3,\n+};\n+\n+JNIEXPORT jobjectArray JNICALL\n+JVM_Checkpoint(JNIEnv *env);\n+\n+JNIEXPORT void JNICALL\n+JVM_RegisterPersistent(int fd, int st_dev, int st_ino);\n+\n+JNIEXPORT void JNICALL\n+JVM_DeregisterPersistent(int fd, int st_dev, int st_ino);\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -3680,0 +3680,13 @@\n+\n+JVM_ENTRY(jobjectArray, JVM_Checkpoint(JNIEnv *env))\n+  Handle ret = os::Linux::checkpoint(CHECK_NULL);\n+  return (jobjectArray) JNIHandles::make_local(env, ret());\n+JVM_END\n+\n+JVM_LEAF(void, JVM_RegisterPersistent(int fd, int st_dev, int st_ino))\n+  os::Linux::register_persistent_fd(fd, st_dev, st_ino);\n+JVM_END\n+\n+JVM_LEAF(void, JVM_DeregisterPersistent(int fd, int st_dev, int st_ino))\n+  os::Linux::deregister_persistent_fd(fd, st_dev, st_ino);\n+JVM_END\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2017, 2020, Azul Systems, Inc. All rights reserved.\n@@ -3281,0 +3282,13 @@\n+  if (CRaCRestoreFrom) {\n+    os::Linux::restore();\n+    if (!CRaCIgnoreRestoreIfUnavailable) {\n+      \/\/ FIXME switch to unified hotspot logging\n+      warning(\"cannot restore\");\n+      return JNI_ERR;\n+    }\n+  }\n+\n+  if (CRaCCheckpointTo && !os::Linux::prepare_checkpoint()) {\n+    return JNI_ERR;\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2513,1 +2513,26 @@\n-          \"Use platform unstable time where supported for timestamps only\")\n+          \"Use platform unstable time where supported for timestamps only\") \\\n+                                                                            \\\n+  product(ccstr, CRaCCheckpointTo, NULL, \"Path to checkpoint image\")        \\\n+                                                                            \\\n+  product(ccstr, CRaCRestoreFrom, NULL, \"Path to image for restore, \"       \\\n+      \"replaces the initializing VM on success\")                            \\\n+                                                                            \\\n+  product(bool, CRaCIgnoreRestoreIfUnavailable, false, \"Ignore \"            \\\n+      \"-XX:CRaCRestoreFrom and continue initialization if restore is \"      \\\n+      \"unavailable\")                                                        \\\n+                                                                            \\\n+  diagnostic(bool, CRAllowToSkipCheckpoint, false,                          \\\n+          \"Allow implementation to not call Checkpoint if helper not found\")\\\n+                                                                            \\\n+  diagnostic(bool, CRHeapDumpOnCheckpointException, false, \"Dump heap on \"  \\\n+      \"CheckpointException thrown because of C\/RaC precondition failed\")    \\\n+                                                                            \\\n+  diagnostic(bool, CRPrintResourcesOnCheckpoint, false, \"Print resources \"  \\\n+      \"to decide CheckpointException\")                                      \\\n+                                                                            \\\n+  diagnostic(bool, CRTraceStartupTime, false, \"Trace startup time\")         \\\n+                                                                            \\\n+  experimental(bool, CRDoThrowCheckpointException, true, \"Throw \"           \\\n+      \"CheckpointException if uncheckpointable resource handle found\")      \\\n+                                                                            \\\n+  product(bool, CRTrace, true, \"Minimal C\/R tracing\")\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":26,"deletions":1,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -1763,0 +1763,7 @@\n+void os::cleanup_memory(char* addr, size_t bytes) {\n+  char* start = (char*)align_up(addr, os::vm_page_size());\n+  char* end = (char*)align_down(addr + bytes, os::vm_page_size());\n+  os::uncommit_memory(start, end - start);\n+  os::commit_memory(start, end - start, false);\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -334,0 +334,2 @@\n+  static void   cleanup_memory(char* addr, size_t bytes);\n+\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3812,0 +3812,2 @@\n+  os::Linux::vm_create_start();\n+\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -130,0 +130,1 @@\n+  template(VM_Crac)                               \\\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -121,0 +121,2 @@\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<CheckpointDCmd>(full_export, true,false));\n+\n@@ -1140,0 +1142,10 @@\n+\n+void CheckpointDCmd::execute(DCmdSource source, TRAPS) {\n+  Klass* k = SystemDictionary::resolve_or_fail(vmSymbols::jdk_crac_Core(),\n+                                                 true, CHECK);\n+  JavaValue result(T_VOID);\n+  JavaCalls::call_static(&result, k,\n+                         vmSymbols::checkpointRestoreInternal_name(),\n+                         vmSymbols::void_method_signature(), CHECK);\n+}\n+\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -915,0 +915,14 @@\n+class CheckpointDCmd : public DCmd {\n+public:\n+  CheckpointDCmd(outputStream* output, bool heap) : DCmd(output, heap) { }\n+    static const char* name() { return \"JDK.checkpoint\"; }\n+    static const char* description() {\n+      return \"Checkpoint via jdk.crac.checkpointRestore().\";\n+    }\n+    static const char* impact() {\n+      return \"High: JVM terminates\";\n+    }\n+    static int num_arguments() { return 0; }\n+    virtual void execute(DCmdSource source, TRAPS);\n+};\n+\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2020, Azul Systems, Inc. All rights reserved.\n@@ -28,0 +29,4 @@\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import jdk.internal.crac.JDKResource;\n+\n@@ -30,0 +35,1 @@\n+import java.nio.channels.IllegalSelectorException;\n@@ -50,1 +56,1 @@\n-class EPollSelectorImpl extends SelectorImpl {\n+class EPollSelectorImpl extends SelectorImpl implements JDKResource {\n@@ -55,0 +61,24 @@\n+    private enum CheckpointRestoreState {\n+        NORMAL_OPERATION,\n+        CHECKPOINT_TRANSITION,\n+        CHECKPOINTED,\n+        CHECKPOINT_ERROR,\n+        RESTORE_TRANSITION,\n+    }\n+\n+    private static class MoveToCheckpointThread extends Thread {\n+        private Selector selector;\n+\n+        MoveToCheckpointThread(Selector selector) {\n+            this.selector = selector;\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                selector.select(1);\n+            } catch (IOException e) {\n+            }\n+        }\n+    }\n+\n@@ -56,1 +86,1 @@\n-    private final int epfd;\n+    private int epfd;\n@@ -59,1 +89,1 @@\n-    private final long pollArrayAddress;\n+    private long pollArrayAddress;\n@@ -62,2 +92,2 @@\n-    private final int fd0;\n-    private final int fd1;\n+    private int fd0;\n+    private int fd1;\n@@ -76,2 +106,1 @@\n-    EPollSelectorImpl(SelectorProvider sp) throws IOException {\n-        super(sp);\n+    private volatile CheckpointRestoreState checkpointState = CheckpointRestoreState.NORMAL_OPERATION;;\n@@ -79,2 +108,2 @@\n-        this.epfd = EPoll.create();\n-        this.pollArrayAddress = EPoll.allocatePollArray(NUM_EPOLLEVENTS);\n+    private void initFDs() throws IOException {\n+        epfd = EPoll.create();\n@@ -84,2 +113,2 @@\n-            this.fd0 = (int) (fds >>> 32);\n-            this.fd1 = (int) fds;\n+            fd0 = (int) (fds >>> 32);\n+            fd1 = (int) fds;\n@@ -96,0 +125,9 @@\n+    EPollSelectorImpl(SelectorProvider sp) throws IOException {\n+        super(sp);\n+        pollArrayAddress = EPoll.allocatePollArray(NUM_EPOLLEVENTS);\n+        initFDs();\n+        \/\/ trigger FileDispatcherImpl initialization\n+        new FileDispatcherImpl();\n+        jdk.internal.crac.Core.getJDKContext().register(this);\n+    }\n+\n@@ -101,0 +139,48 @@\n+    private boolean processCheckpointRestore() throws IOException {\n+        assert Thread.holdsLock(this);\n+\n+        if (checkpointState != CheckpointRestoreState.CHECKPOINT_TRANSITION) {\n+            return false;\n+        }\n+\n+        synchronized (interruptLock) {\n+            IOUtil.drain(fd0);\n+\n+            CheckpointRestoreState thisState;\n+            if (fdToKey.size() == 0) {\n+                FileDispatcherImpl.closeIntFD(epfd);\n+                FileDispatcherImpl.closeIntFD(fd0);\n+                FileDispatcherImpl.closeIntFD(fd1);\n+                thisState = CheckpointRestoreState.CHECKPOINTED;\n+            } else {\n+                thisState = CheckpointRestoreState.CHECKPOINT_ERROR;\n+            }\n+\n+            checkpointState = thisState;\n+            interruptLock.notifyAll();\n+            while (checkpointState == thisState) {\n+                try {\n+                    interruptLock.wait();\n+                } catch (InterruptedException e) {\n+                }\n+            }\n+\n+            assert checkpointState == CheckpointRestoreState.RESTORE_TRANSITION;\n+            if (thisState == CheckpointRestoreState.CHECKPOINTED) {\n+                initFDs();\n+            }\n+            checkpointState = CheckpointRestoreState.NORMAL_OPERATION;\n+            interruptLock.notifyAll();\n+\n+            if (interruptTriggered) {\n+                try {\n+                    IOUtil.write1(fd1, (byte)0);\n+                } catch (IOException ioe) {\n+                    throw new InternalError(ioe);\n+                }\n+            }\n+        }\n+\n+        return true;\n+    }\n+\n@@ -120,1 +206,3 @@\n-                numEntries = EPoll.wait(epfd, pollArrayAddress, NUM_EPOLLEVENTS, to);\n+                do {\n+                    numEntries = EPoll.wait(epfd, pollArrayAddress, NUM_EPOLLEVENTS, to);\n+                } while (processCheckpointRestore());\n@@ -202,1 +290,1 @@\n-        if (interrupted) {\n+        if (interrupted && !(Thread.currentThread() instanceof MoveToCheckpointThread)) {\n@@ -270,0 +358,56 @@\n+\n+    @Override\n+    public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+        if (!isOpen()) {\n+            return;\n+        }\n+\n+        synchronized (interruptLock) {\n+            checkpointState = CheckpointRestoreState.CHECKPOINT_TRANSITION;\n+            IOUtil.write1(fd1, (byte)0);\n+            int tries = 5;\n+            while (checkpointState == CheckpointRestoreState.CHECKPOINT_TRANSITION && 0 < tries--) {\n+                try {\n+                    interruptLock.wait(5);\n+                } catch (InterruptedException e) {\n+                }\n+            }\n+            if (checkpointState == CheckpointRestoreState.CHECKPOINT_TRANSITION) {\n+                Thread thr = new MoveToCheckpointThread(this);\n+                thr.setDaemon(true);\n+                thr.start();\n+            }\n+            while (checkpointState == CheckpointRestoreState.CHECKPOINT_TRANSITION) {\n+                try {\n+                    interruptLock.wait();\n+                } catch (InterruptedException e) {\n+                }\n+            }\n+            if (checkpointState == CheckpointRestoreState.CHECKPOINT_ERROR) {\n+                throw new IllegalSelectorException();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void afterRestore(Context<? extends Resource> context) throws Exception {\n+        if (!isOpen()) {\n+            return;\n+        }\n+\n+        synchronized (interruptLock) {\n+            checkpointState = CheckpointRestoreState.RESTORE_TRANSITION;\n+            interruptLock.notifyAll();\n+            while (checkpointState == CheckpointRestoreState.RESTORE_TRANSITION) {\n+                try {\n+                    interruptLock.wait();\n+                } catch (InterruptedException e) {\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public int getPriority() {\n+        return -1;\n+    }\n","filename":"src\/java.base\/linux\/classes\/sun\/nio\/ch\/EPollSelectorImpl.java","additions":157,"deletions":13,"binary":false,"changes":170,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.io.FileDescriptor;\n@@ -63,0 +64,1 @@\n+import jdk.internal.crac.Core;\n@@ -819,0 +821,3 @@\n+        public Source getSource() {\n+            return zsrc;\n+        }\n@@ -1051,0 +1056,14 @@\n+    private synchronized void beforeCheckpoint() {\n+        RandomAccessFile f = res.getSource().getFile();\n+        synchronized (f) {\n+            FileDescriptor fd = null;\n+            try {\n+                fd = f.getFD();\n+            } catch (IOException e) {\n+            }\n+            if (fd != null) {\n+                Core.registerPersistent(fd);\n+            }\n+        }\n+    }\n+\n@@ -1117,1 +1136,1 @@\n-        \/\/ {@code hash}, {@code next and {@code \"pos for each entry. The entry can then be\n+        \/\/ {@code hash}, {@code next} and {@code \"pos\"} for each entry. The entry can then be\n@@ -1574,0 +1593,4 @@\n+\n+        public RandomAccessFile getFile() {\n+            return zfile;\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipFile.java","additions":24,"deletions":1,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2017, 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javax.crac;\n+\n+\/**\n+ * Suppresses exceptions thrown during checkpoint notification.\n+ *\/\n+public class CheckpointException extends Exception {\n+    private static final long serialVersionUID = 6859967688386143096L;\n+\n+    \/**\n+     * Creates a {@code CheckpointException}.\n+     *\/\n+    public CheckpointException() {\n+        super();\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/javax\/crac\/CheckpointException.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javax.crac;\n+\n+\/**\n+ * A {@code Resource} that allows other {@code Resource}s to be registered with it.\n+ *\n+ * <p>{@code Context} implementation overrides {@code beforeCheckpoint} and {@code afterRestore}, defining how the notification about checkpoint and restore will be distributed by the {@code Context} hierarchy.\n+ *\n+ * <p>A {@code Context} implementor is encouraged to respect properties of the global {@code Context}.\n+ *\/\n+public abstract class Context<R extends Resource> implements Resource {\n+\n+    \/** Creates a {@code Context}.\n+     *\/\n+    protected Context() {\n+    }\n+\n+    @Override\n+    public abstract void beforeCheckpoint(Context<? extends Resource> context)\n+            throws CheckpointException;\n+\n+    @Override\n+    public abstract void afterRestore(Context<? extends Resource> context)\n+            throws RestoreException;\n+\n+    \/**\n+     * Registers a {@code Resource} with this {@code Context}.\n+     *\n+     * @param resource {@code Resource} to be registered.\n+     * @throws NullPointerException if {@code resource} is {@code null}\n+     *\/\n+    public abstract void register(R resource);\n+}\n","filename":"src\/java.base\/share\/classes\/javax\/crac\/Context.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javax.crac;\n+\n+class ContextWrapper extends Context<Resource> {\n+    private final jdk.crac.Context<jdk.crac.Resource> context;\n+\n+    public ContextWrapper(jdk.crac.Context<jdk.crac.Resource> context) {\n+        this.context = context;\n+    }\n+\n+    private static jdk.crac.Context<? extends jdk.crac.Resource> convertContext(\n+            Context<? extends Resource> context) {\n+        return context instanceof ContextWrapper ?\n+                ((ContextWrapper)context).context :\n+                null;\n+    }\n+\n+    @Override\n+    public void beforeCheckpoint(Context<? extends Resource> context)\n+            throws CheckpointException {\n+        try {\n+            this.context.beforeCheckpoint(convertContext(context));\n+        } catch (jdk.crac.CheckpointException e) {\n+            CheckpointException newException = new CheckpointException();\n+            for (Throwable t : e.getSuppressed()) {\n+                newException.addSuppressed(t);\n+            }\n+            throw newException;\n+        }\n+    }\n+\n+    @Override\n+    public void afterRestore(Context<? extends Resource> context)\n+            throws RestoreException {\n+        try {\n+            this.context.afterRestore(convertContext(context));\n+        } catch (jdk.crac.RestoreException e) {\n+            RestoreException newException = new RestoreException();\n+            for (Throwable t : e.getSuppressed()) {\n+                newException.addSuppressed(t);\n+            }\n+            throw newException;\n+        }\n+    }\n+\n+    @Override\n+    public void register(Resource r) {\n+        ResourceWrapper wrapper = new ResourceWrapper(this, r);\n+        context.register(wrapper);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"ContextWrapper[\" + context.toString() + \"]\";\n+    }\n+}\n+\n","filename":"src\/java.base\/share\/classes\/javax\/crac\/ContextWrapper.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2017, 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javax.crac;\n+\n+import jdk.crac.impl.OrderedContext;\n+\n+\/**\n+ * The coordination service.\n+ *\/\n+public class Core {\n+\n+    \/** This class is not instantiable. *\/\n+    private Core() {\n+    }\n+\n+    private static final Context<Resource> globalContext = new ContextWrapper(new OrderedContext());\n+    static {\n+        jdk.crac.Core.getGlobalContext().register(new ResourceWrapper(null, globalContext));\n+    }\n+\n+    \/**\n+     * Gets the global {@code Context} for checkpoint\/restore notifications.\n+     *\n+     * @return the global {@code Context}\n+     *\/\n+    public static Context<Resource> getGlobalContext() {\n+        return globalContext;\n+    }\n+\n+    \/**\n+     * Requests checkpoint and returns upon a successful restore.\n+     * May throw an exception if the checkpoint or restore are unsuccessful.\n+     *\n+     * @throws CheckpointException if an exception occured during checkpoint\n+     * notification and the execution continues in the original Java instance.\n+     * @throws RestoreException if an exception occured during restore\n+     * notification and execution continues in a new Java instance.\n+     * @throws UnsupportedOperationException if checkpoint\/restore is not\n+     * supported, no notification performed and the execution continues in\n+     * the original Java instance.\n+     *\/\n+    public static void checkpointRestore() throws\n+            CheckpointException,\n+            RestoreException {\n+        try {\n+            jdk.crac.Core.checkpointRestore();\n+        } catch (jdk.crac.CheckpointException e) {\n+            CheckpointException newException = new CheckpointException();\n+            for (Throwable t : e.getSuppressed()) {\n+                newException.addSuppressed(t);\n+            }\n+            throw newException;\n+        } catch (jdk.crac.RestoreException e) {\n+            RestoreException newException = new RestoreException();\n+            for (Throwable t : e.getSuppressed()) {\n+                newException.addSuppressed(t);\n+            }\n+            throw newException;\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/javax\/crac\/Core.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2017, 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javax.crac;\n+\n+\/**\n+ * An interface for receiving checkpoint\/restore notifications.\n+ *\n+ * <p>The class that is interested in receiving a checkpoint\/restore notification\n+ * implements this interface, and the object created with that class is\n+ * registered with a {@code Context}, using {@code register} method.\n+ *\/\n+public interface Resource {\n+\n+    \/**\n+     * Invoked by a {@code Context} as a notification about checkpoint.\n+     *\n+     * @param context {@code Context} providing notification\n+     * @throws Exception if the method have failed\n+     *\/\n+    void beforeCheckpoint(Context<? extends Resource> context) throws Exception;\n+\n+    \/**\n+     * Invoked by a {@code Context} as a notification about restore.\n+     *\n+     * @param context {@code Context} providing notification\n+     * @throws Exception if the method have failed\n+     *\/\n+    void afterRestore(Context<? extends Resource> context) throws Exception;\n+}\n","filename":"src\/java.base\/share\/classes\/javax\/crac\/Resource.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javax.crac;\n+\n+import java.lang.ref.WeakReference;\n+import java.util.WeakHashMap;\n+\n+class ResourceWrapper extends WeakReference<Resource> implements jdk.crac.Resource {\n+    private static WeakHashMap<Resource, ResourceWrapper> weakMap = new WeakHashMap<>();\n+\n+    \/\/ Create strong reference to avoid losing the Resource.\n+    \/\/ It's set unconditionally in beforeCheckpoint and cleaned in afterRestore\n+    \/\/ (latter is called regardless of beforeCheckpoint result).\n+    private Resource strongRef;\n+\n+    private final Context<Resource> context;\n+\n+    public ResourceWrapper(Context<Resource> context, Resource resource) {\n+        super(resource);\n+        weakMap.put(resource, this);\n+        strongRef = null;\n+        this.context = context;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"ResourceWrapper[\" + get().toString() + \"]\";\n+    }\n+\n+    @Override\n+    public void beforeCheckpoint(jdk.crac.Context<? extends jdk.crac.Resource> context)\n+            throws Exception {\n+        Resource r = get();\n+        strongRef = r;\n+        if (r != null) {\n+            try {\n+                r.beforeCheckpoint(this.context);\n+            } catch (CheckpointException e) {\n+                Exception newException = new jdk.crac.CheckpointException();\n+                for (Throwable t : e.getSuppressed()) {\n+                    newException.addSuppressed(t);\n+                }\n+                throw newException;\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void afterRestore(jdk.crac.Context<? extends jdk.crac.Resource> context) throws Exception {\n+        Resource r = get();\n+        strongRef = null;\n+        if (r != null) {\n+            try {\n+                r.afterRestore(this.context);\n+            } catch (RestoreException e) {\n+                Exception newException = new jdk.crac.RestoreException();\n+                for (Throwable t : e.getSuppressed()) {\n+                    newException.addSuppressed(t);\n+                }\n+                throw newException;\n+            }\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/javax\/crac\/ResourceWrapper.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2017, 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javax.crac;\n+\n+\/**\n+ * Suppresses exceptions thrown during restore notification.\n+ *\/\n+public class RestoreException extends Exception {\n+    private static final long serialVersionUID = -4091592505524280559L;\n+\n+    \/**\n+     * Creates a {@code RestoreException}.\n+     *\/\n+    public RestoreException() {\n+        super();\n+    }\n+}\n+\n+\n","filename":"src\/java.base\/share\/classes\/javax\/crac\/RestoreException.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * Provides explicit coordination with a checkpoint\/restore mechanism.\n+ * A checkpoint\/restore implementation may capture process or application state images for later continuation.\n+ * Coordination allows application code to prepare for a checkpoint and to adapt to changes in the execution environment after a restore.\n+ * <p>\n+ * Successful checkpointing and restoration may require that no checkpointed state exist that might not be validly reproducible when\n+restoring instances from the image.\n+ * Coordination enables application to proactively discard problematic state ahead of checkpointing, and to reestablish needed state upon restoration.\n+ * A Java implementation may provide detection of some subsets of state that are known to prevent successful checkpoints.\n+ * <p>\n+ * For example, a state of opened file descriptors or socket may be impossible to store in the image.\n+ * The implementation may detect such resources and then prevent checkpoint.\n+ * The application must then close file descriptors and sockets to be successfully checkpointed.\n+ * Files and sockets may be opened back after restore, then the application is responsible for processing possible exceptions.\n+ * <p>\n+ * {@link Resource} is an interface for receiving checkpoint\/restore notifications.\n+ * In order to be notified, {@code Resource} needs to be registered in a {@link Context}.\n+ * {@link Core} is a core interface for coordination. It provides the global {@code Context} which can be used as default choice.\n+ * The global {@code Context} have properties listed below, one can define a custom {@code Context} and register it with the global one.\n+ * {@code Core} has also a method to request checkpoint.\n+ * <p>\n+ * Methods of {@code Resource} are invoked as a notification of checkpoint and restore.\n+ * If a {@code Resource} is incapable to process notification, corresponding method throws an exception.\n+ * The global {@code Context} ensures that exceptions are propagated to a requester of checkpoint\/restore.\n+ * <p>\n+ * {@code Context} is a {@code Resource}, that allows other {@code Resource}s to be registered with it.\n+ * {@code Context} defines how {@code Resource}s are notified and may provide different guarantees compared to the global {@code Context}, such as order of notification.\n+ * A class may extend {@code Context} and define custom rules of notification processing by overriding {@code Resource} method.\n+ * Since a {@code Context} may be registered with other {@code Context}, they form a {@code Context} hierarchy.\n+ * <p>\n+ * Checkpoint can requested by {@code Core.checkpointRestore} or by some other way.\n+ * Then checkpoint notification of the global {@code Context} is performed.\n+ * If the global {@code Context} have not thrown {@code CheckpointException}, the current Java instance is used to create the image in a platform dependent way.\n+ * The current instance is terminated.\n+ * Later, a new instance is created by some means, for example via Java launcher in a special mode.\n+ * The new instance is started at the point where the image was created, it is followed by the restore notification.\n+ * Exceptions from restore notification are provided as suppressed ones by a {@code RestoreException} (in a sense of {@link Throwable#addSuppressed}).\n+ * <p>\n+ * If the global {@code Context} throws an exception during checkpoint notification then restore notificaion starts immediately without the image creation.\n+ * In this case, exceptions from checkpoint and restore notifications are provided as suppressed ones by {@code CheckpointException}.\n+ * <p>\n+ * {@code UnsupportedOperationException} is thrown if the service is not supported.\n+ * No notification is performed in this case.\n+ * <h2>Global Context Properties<\/h2>\n+ * Java Runtime maintains the global {@code Context} with following properties.\n+ * An implementor is encouraged to define {@code Context} with the properties of the global {@code Context}.\n+ * <ul>\n+ * <li>The {@code Context} maintains a weak reference to registered {@code Resource}.\n+ * <\/li>\n+ * <li>Order of checkpoint notification is the reverse order of registration.\n+ * Restore notification order is the reverse of checkpoint one, that is, forward order of registration.\n+ * <\/li>\n+ * <li>For single {@code Resource} registered in this {@code Context}:\n+ * <ul>\n+ *   <li>{@code Resource} is always notified of checkpoint, regardless of other {@code Resource} notifications have thrown an exception or not,\n+ *   <\/li>\n+ *   <li>{@code Resource} is always notified of restore, regardless of its checkpoint or others' restore notification have thrown an exception or not.\n+ *   <\/li>\n+ *   <li>When an exception is thrown during notificaion, it is caught by the {@code Context} and is suppressed by a {@code CheckpointException} or {@code RestoreException}, depends on the throwing method.\n+ *   <\/li>\n+ *   <li>When the {@code Resource} is a {@code Context} and it throws {@code CheckpointException} or {@code RestoreException}, exceptions suppressed by the original exception are suppressed by another {@code CheckpointException} or {@code RestoreException}, depends on the throwing method.\n+ *   <\/li>\n+ * <\/ul>\n+ * <li>All exceptions thrown by {@code Resource} are suppressed by {@code CheckpointException} or {@code RestoreException} thrown by the {@code Context}.\n+ * <\/li>\n+ * <\/ul>\n+ *\n+ * @since TBD\n+ *\/\n+\n+package javax.crac;\n+\n","filename":"src\/java.base\/share\/classes\/javax\/crac\/package-info.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2017, 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.crac;\n+\n+\/**\n+ * Suppresses exceptions thrown during checkpoint notification.\n+ *\/\n+public class CheckpointException extends Exception {\n+    private static final long serialVersionUID = 8879167591426115859L;\n+\n+    \/**\n+     * Creates a {@code CheckpointException}.\n+     *\/\n+    public CheckpointException() {\n+        super();\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/CheckpointException.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.crac;\n+\n+\/**\n+ * A {@code Resource} that allows other {@code Resource}s to be registered with it.\n+ *\n+ * <p>{@code Context} implementation overrides {@code beforeCheckpoint} and {@code afterRestore}, defining how the notification about checkpoint and restore will be distributed by the {@code Context} hierarchy.\n+ *\n+ * <p>A {@code Context} implementor is encouraged to respect properties of the global {@code Context}.\n+ *\/\n+public abstract class Context<R extends Resource> implements Resource {\n+\n+    \/** Creates a {@code Context}.\n+     *\/\n+    protected Context() {\n+    }\n+\n+    @Override\n+    public abstract void beforeCheckpoint(Context<? extends Resource> context)\n+            throws CheckpointException;\n+\n+    @Override\n+    public abstract void afterRestore(Context<? extends Resource> context)\n+            throws RestoreException;\n+\n+    \/**\n+     * Registers a {@code Resource} with this {@code Context}.\n+     *\n+     * @param resource {@code Resource} to be registered.\n+     * @throws NullPointerException if {@code resource} is {@code null}\n+     *\/\n+    public abstract void register(R resource);\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/Context.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,206 @@\n+\/*\n+ * Copyright (c) 2017, 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.crac;\n+\n+import jdk.crac.impl.CheckpointOpenFileException;\n+import jdk.crac.impl.CheckpointOpenResourceException;\n+import jdk.crac.impl.CheckpointOpenSocketException;\n+import jdk.crac.impl.OrderedContext;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+\n+\/**\n+ * The coordination service.\n+ *\/\n+public class Core {\n+    private static final int JVM_CHECKPOINT_OK    = 0;\n+    private static final int JVM_CHECKPOINT_ERROR = 1;\n+    private static final int JVM_CHECKPOINT_NONE  = 2;\n+\n+    private static final int JVM_CR_FAIL = 0;\n+    private static final int JVM_CR_FAIL_FILE = 1;\n+    private static final int JVM_CR_FAIL_SOCK = 2;\n+    private static final int JVM_CR_FAIL_PIPE = 3;\n+\n+    private static native Object[] checkpointRestore0();\n+\n+    private static boolean traceStartupTime;\n+\n+    private static final Context<Resource> globalContext = new OrderedContext();\n+    static {\n+        \/\/ force JDK context initialization\n+        jdk.internal.crac.Core.getJDKContext();\n+\n+        traceStartupTime = AccessController.doPrivileged(\n+                new PrivilegedAction<Boolean>() {\n+                    public Boolean run() {\n+                        return Boolean.parseBoolean(\n+                                System.getProperty(\"jdk.crac.trace-startup-time\"));\n+                    }});\n+    }\n+\n+    \/** This class is not instantiable. *\/\n+    private Core() {\n+    }\n+\n+    private static void translateJVMExceptions(int[] codes, String[] messages,\n+                                               CheckpointException newException) {\n+        assert codes.length == messages.length;\n+        final int length = codes.length;\n+\n+        for (int i = 0; i < length; ++i) {\n+            switch(codes[i]) {\n+                case JVM_CR_FAIL_FILE:\n+                    newException.addSuppressed(\n+                            new CheckpointOpenFileException(messages[i]));\n+                    break;\n+                case JVM_CR_FAIL_SOCK:\n+                    newException.addSuppressed(\n+                            new CheckpointOpenSocketException(messages[i]));\n+                    break;\n+                case JVM_CR_FAIL_PIPE:\n+                    \/\/ FALLTHROUGH\n+                default:\n+                    newException.addSuppressed(\n+                            new CheckpointOpenResourceException(messages[i]));\n+                    break;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Gets the global {@code Context} for checkpoint\/restore notifications.\n+     *\n+     * @return the global {@code Context}\n+     *\/\n+    public static Context<Resource> getGlobalContext() {\n+        return globalContext;\n+    }\n+\n+    private static void checkpointRestore1() throws\n+            CheckpointException,\n+            RestoreException {\n+        try {\n+            globalContext.beforeCheckpoint(null);\n+        } catch (CheckpointException ce) {\n+            \/\/ TODO make dry-run\n+            try {\n+                globalContext.afterRestore(null);\n+            } catch (RestoreException re) {\n+                CheckpointException newException = new CheckpointException();\n+                for (Throwable t : ce.getSuppressed()) {\n+                    newException.addSuppressed(t);\n+                }\n+                for (Throwable t : re.getSuppressed()) {\n+                    newException.addSuppressed(t);\n+                }\n+                throw newException;\n+            }\n+            throw ce;\n+        }\n+\n+        final Object[] bundle = checkpointRestore0();\n+        final int retCode = (Integer)bundle[0];\n+        final int[] codes = (int[])bundle[1];\n+        final String[] messages = (String[])bundle[2];\n+\n+        if (traceStartupTime) {\n+            System.out.println(\"STARTUPTIME \" + System.nanoTime() + \" restore\");\n+        }\n+\n+        if (retCode != JVM_CHECKPOINT_OK) {\n+            CheckpointException newException = new CheckpointException();\n+            switch (retCode) {\n+                case JVM_CHECKPOINT_ERROR:\n+                    translateJVMExceptions(codes, messages, newException);\n+                    break;\n+                case JVM_CHECKPOINT_NONE:\n+                    newException.addSuppressed(\n+                            new RuntimeException(\"C\/R is not configured\"));\n+                    break;\n+                default:\n+                    newException.addSuppressed(\n+                            new RuntimeException(\"Unknown C\/R result: \" + retCode));\n+            }\n+\n+            try {\n+                globalContext.afterRestore(null);\n+            } catch (RestoreException re) {\n+                for (Throwable t : re.getSuppressed()) {\n+                    newException.addSuppressed(t);\n+                }\n+            }\n+            throw newException;\n+        }\n+\n+        globalContext.afterRestore(null);\n+    }\n+\n+    \/**\n+     * Requests checkpoint and returns upon a successful restore.\n+     * May throw an exception if the checkpoint or restore are unsuccessful.\n+     *\n+     * @throws CheckpointException if an exception occured during checkpoint\n+     * notification and the execution continues in the original Java instance.\n+     * @throws RestoreException if an exception occured during restore\n+     * notification and execution continues in a new Java instance.\n+     * @throws UnsupportedOperationException if checkpoint\/restore is not\n+     * supported, no notification performed and the execution continues in\n+     * the original Java instance.\n+     *\/\n+    public static void checkpointRestore() throws\n+            CheckpointException,\n+            RestoreException {\n+        try {\n+            checkpointRestore1();\n+        } finally {\n+            if (traceStartupTime) {\n+                System.out.println(\"STARTUPTIME \" + System.nanoTime() + \" restore-finish\");\n+            }\n+        }\n+    }\n+\n+    \/* called by VM *\/\n+    private static void checkpointRestoreInternal() {\n+        Thread thread = new Thread(() -> {\n+            try {\n+                Thread.sleep(100);\n+            } catch (InterruptedException e) {\n+            }\n+\n+            try {\n+                checkpointRestore();\n+            } catch (CheckpointException | RestoreException e) {\n+                for (Throwable t : e.getSuppressed()) {\n+                    t.printStackTrace();\n+                }\n+            }\n+        });\n+        thread.setDaemon(true);\n+        thread.start();\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/Core.java","additions":206,"deletions":0,"binary":false,"changes":206,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2017, 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.crac;\n+\n+\/**\n+ * An interface for receiving checkpoint\/restore notifications.\n+ *\n+ * <p>The class that is interested in receiving a checkpoint\/restore notification\n+ * implements this interface, and the object created with that class is\n+ * registered with a {@code Context}, using {@code register} method.\n+ *\/\n+public interface Resource {\n+\n+    \/**\n+     * Invoked by a {@code Context} as a notification about checkpoint.\n+     *\n+     * @param context {@code Context} providing notification\n+     * @throws Exception if the method have failed\n+     *\/\n+    void beforeCheckpoint(Context<? extends Resource> context) throws Exception;\n+\n+    \/**\n+     * Invoked by a {@code Context} as a notification about restore.\n+     *\n+     * @param context {@code Context} providing notification\n+     * @throws Exception if the method have failed\n+     *\/\n+    void afterRestore(Context<? extends Resource> context) throws Exception;\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/Resource.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2017, 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.crac;\n+\n+\/**\n+ * Suppresses exceptions thrown during restore notification.\n+ *\/\n+public class RestoreException extends Exception {\n+    private static final long serialVersionUID = 5235124335683732665L;\n+\n+    \/**\n+     * Creates a {@code RestoreException}.\n+     *\/\n+    public RestoreException() {\n+        super();\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/RestoreException.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,109 @@\n+\/\/ Copyright 2019-2020 Azul Systems, Inc.\n+\/\/\n+\/\/ Redistribution and use in source and binary forms, with or without\n+\/\/ modification, are permitted provided that the following conditions are met:\n+\/\/\n+\/\/ 1. Redistributions of source code must retain the above copyright notice,\n+\/\/ this list of conditions and the following disclaimer.\n+\/\/\n+\/\/ 2. Redistributions in binary form must reproduce the above copyright notice,\n+\/\/ this list of conditions and the following disclaimer in the documentation\n+\/\/ and\/or other materials provided with the distribution.\n+\/\/\n+\/\/ IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+\/\/ ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n+\/\/ LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+\/\/ CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+\/\/ SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+\/\/ INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+\/\/ CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+\/\/ ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+\/\/ POSSIBILITY OF SUCH DAMAGE.\n+\n+package jdk.crac.impl;\n+\n+import jdk.crac.CheckpointException;\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import jdk.crac.RestoreException;\n+\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+public abstract class AbstractContextImpl<R extends Resource, P> extends Context<R> {\n+    private static final boolean DEBUG = AccessController.doPrivileged(\n+            new PrivilegedAction<Boolean>() {\n+                public Boolean run() {\n+                    return Boolean.parseBoolean(\n+                            System.getProperty(\"jdk.crac.debug\"));\n+                }});\n+\n+    private WeakHashMap<R, P> checkpointQ = new WeakHashMap<>();\n+    private List<R> restoreQ = null;\n+    private Comparator<Map.Entry<R, P>> comparator;\n+\n+    protected AbstractContextImpl(Comparator<Map.Entry<R, P>> comparator) {\n+        this.comparator = comparator;\n+    }\n+\n+    protected synchronized void register(R resource, P payload) {\n+        checkpointQ.put(resource, payload);\n+    }\n+\n+    @Override\n+    public synchronized void beforeCheckpoint(Context<? extends Resource> context) throws CheckpointException {\n+        List<R> resources = checkpointQ.entrySet().stream()\n+            .sorted(comparator)\n+            .map(Map.Entry::getKey)\n+            .collect(Collectors.toList());\n+\n+        CheckpointException exception = new CheckpointException();\n+        for (Resource r : resources) {\n+            if (DEBUG) {\n+                System.err.println(\"jdk.crac beforeCheckpoint \" + r.toString());\n+            }\n+            try {\n+                r.beforeCheckpoint(this);\n+            } catch (CheckpointException e) {\n+                for (Throwable t : e.getSuppressed()) {\n+                    exception.addSuppressed(t);\n+                }\n+            } catch (Exception e) {\n+                exception.addSuppressed(e);\n+            }\n+        }\n+\n+        Collections.reverse(resources);\n+        restoreQ = resources;\n+\n+        if (0 < exception.getSuppressed().length) {\n+            throw exception;\n+        }\n+    }\n+\n+    @Override\n+    public synchronized void afterRestore(Context<? extends Resource> context) throws RestoreException {\n+        RestoreException exception = new RestoreException();\n+        for (Resource r : restoreQ) {\n+            if (DEBUG) {\n+                System.err.println(\"jdk.crac afterRestore \" + r.toString());\n+            }\n+            try {\n+                r.afterRestore(this);\n+            } catch (RestoreException e) {\n+                for (Throwable t : e.getSuppressed()) {\n+                    exception.addSuppressed(t);\n+                }\n+            } catch (Exception e) {\n+                exception.addSuppressed(e);\n+            }\n+        }\n+        restoreQ = null;\n+\n+        if (0 < exception.getSuppressed().length) {\n+            throw exception;\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/impl\/AbstractContextImpl.java","additions":109,"deletions":0,"binary":false,"changes":109,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2017, 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.crac.impl;\n+\n+public class CheckpointOpenFileException extends\n+        CheckpointOpenResourceException {\n+    private static final long serialVersionUID = 4696394478625532246L;\n+\n+    public CheckpointOpenFileException(String details) {\n+        super(details);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/impl\/CheckpointOpenFileException.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2017, 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.crac.impl;\n+\n+public class CheckpointOpenResourceException extends Exception {\n+    private static final long serialVersionUID = -3858375642480846931L;\n+\n+    public CheckpointOpenResourceException(String details) {\n+        super(details);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/impl\/CheckpointOpenResourceException.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2017, 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.crac.impl;\n+\n+public class CheckpointOpenSocketException extends\n+        CheckpointOpenResourceException {\n+    private static final long serialVersionUID = 4778540502218641776L;\n+\n+    public CheckpointOpenSocketException(String details) {\n+        super(details);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/impl\/CheckpointOpenSocketException.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.crac.impl;\n+\n+import jdk.crac.Resource;\n+import jdk.crac.impl.AbstractContextImpl;\n+\n+import java.util.Comparator;\n+import java.util.Map;\n+\n+public class OrderedContext extends AbstractContextImpl<Resource, Long> {\n+    private long order;\n+\n+    static class ContextComparator implements Comparator<Map.Entry<Resource, Long>> {\n+        @Override\n+        public int compare(Map.Entry<Resource, Long> o1, Map.Entry<Resource, Long> o2) {\n+            return (int)(o2.getValue() - o1.getValue());\n+        }\n+    }\n+\n+    public OrderedContext() {\n+        super(new ContextComparator());\n+    }\n+\n+    @Override\n+    public synchronized void register(Resource r) {\n+        register(r, order++);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/impl\/OrderedContext.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * Provides explicit coordination with a checkpoint\/restore mechanism.\n+ * A checkpoint\/restore implementation may capture process or application state images for later continuation.\n+ * Coordination allows application code to prepare for a checkpoint and to adapt to changes in the execution environment after a restore.\n+ * <p>\n+ * Successful checkpointing and restoration may require that no checkpointed state exist that might not be validly reproducible when\n+restoring instances from the image.\n+ * Coordination enables application to proactively discard problematic state ahead of checkpointing, and to reestablish needed state upon restoration.\n+ * A Java implementation may provide detection of some subsets of state that are known to prevent successful checkpoints.\n+ * <p>\n+ * For example, a state of opened file descriptors or socket may be impossible to store in the image.\n+ * The implementation may detect such resources and then prevent checkpoint.\n+ * The application must then close file descriptors and sockets to be successfully checkpointed.\n+ * Files and sockets may be opened back after restore, then the application is responsible for processing possible exceptions.\n+ * <p>\n+ * {@link Resource} is an interface for receiving checkpoint\/restore notifications.\n+ * In order to be notified, {@code Resource} needs to be registered in a {@link Context}.\n+ * {@link Core} is a core interface for coordination. It provides the global {@code Context} which can be used as default choice.\n+ * The global {@code Context} have properties listed below, one can define a custom {@code Context} and register it with the global one.\n+ * {@code Core} has also a method to request checkpoint.\n+ * <p>\n+ * Methods of {@code Resource} are invoked as a notification of checkpoint and restore.\n+ * If a {@code Resource} is incapable to process notification, corresponding method throws an exception.\n+ * The global {@code Context} ensures that exceptions are propagated to a requester of checkpoint\/restore.\n+ * <p>\n+ * {@code Context} is a {@code Resource}, that allows other {@code Resource}s to be registered with it.\n+ * {@code Context} defines how {@code Resource}s are notified and may provide different guarantees compared to the global {@code Context}, such as order of notification.\n+ * A class may extend {@code Context} and define custom rules of notification processing by overriding {@code Resource} method.\n+ * Since a {@code Context} may be registered with other {@code Context}, they form a {@code Context} hierarchy.\n+ * <p>\n+ * Checkpoint can requested by {@code Core.checkpointRestore} or by some other way.\n+ * Then checkpoint notification of the global {@code Context} is performed.\n+ * If the global {@code Context} have not thrown {@code CheckpointException}, the current Java instance is used to create the image in a platform dependent way.\n+ * The current instance is terminated.\n+ * Later, a new instance is created by some means, for example via Java launcher in a special mode.\n+ * The new instance is started at the point where the image was created, it is followed by the restore notification.\n+ * Exceptions from restore notification are provided as suppressed ones by a {@code RestoreException} (in a sense of {@link Throwable#addSuppressed}).\n+ * <p>\n+ * If the global {@code Context} throws an exception during checkpoint notification then restore notificaion starts immediately without the image creation.\n+ * In this case, exceptions from checkpoint and restore notifications are provided as suppressed ones by {@code CheckpointException}.\n+ * <p>\n+ * {@code UnsupportedOperationException} is thrown if the service is not supported.\n+ * No notification is performed in this case.\n+ * <h2>Global Context Properties<\/h2>\n+ * Java Runtime maintains the global {@code Context} with following properties.\n+ * An implementor is encouraged to define {@code Context} with the properties of the global {@code Context}.\n+ * <ul>\n+ * <li>The {@code Context} maintains a weak reference to registered {@code Resource}.\n+ * <\/li>\n+ * <li>Order of checkpoint notification is the reverse order of registration.\n+ * Restore notification order is the reverse of checkpoint one, that is, forward order of registration.\n+ * <\/li>\n+ * <li>For single {@code Resource} registered in this {@code Context}:\n+ * <ul>\n+ *   <li>{@code Resource} is always notified of checkpoint, regardless of other {@code Resource} notifications have thrown an exception or not,\n+ *   <\/li>\n+ *   <li>{@code Resource} is always notified of restore, regardless of its checkpoint or others' restore notification have thrown an exception or not.\n+ *   <\/li>\n+ *   <li>When an exception is thrown during notificaion, it is caught by the {@code Context} and is suppressed by a {@code CheckpointException} or {@code RestoreException}, depends on the throwing method.\n+ *   <\/li>\n+ *   <li>When the {@code Resource} is a {@code Context} and it throws {@code CheckpointException} or {@code RestoreException}, exceptions suppressed by the original exception are suppressed by another {@code CheckpointException} or {@code RestoreException}, depends on the throwing method.\n+ *   <\/li>\n+ * <\/ul>\n+ * <li>All exceptions thrown by {@code Resource} are suppressed by {@code CheckpointException} or {@code RestoreException} thrown by the {@code Context}.\n+ * <\/li>\n+ * <\/ul>\n+ *\n+ * @since TBD\n+ *\/\n+\n+package jdk.crac;\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/package-info.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.crac;\n+\n+import java.io.FileDescriptor;\n+\n+public class Core {\n+    private static JDKContext JDKContext;\n+\n+    private static native void registerPersistent0(FileDescriptor fd);\n+\n+    static {\n+        JDKContext = new JDKContext();\n+        jdk.crac.Core.getGlobalContext().register(JDKContext);\n+    }\n+\n+    public static JDKContext getJDKContext() {\n+        return JDKContext;\n+    }\n+\n+    public static void registerPersistent(FileDescriptor fd) {\n+        registerPersistent0(fd);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/Core.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.crac;\n+\n+import jdk.crac.impl.AbstractContextImpl;\n+\n+import java.util.Comparator;\n+import java.util.Map;\n+\n+public class JDKContext extends AbstractContextImpl<JDKResource, Void> {\n+    static class ContextComparator implements Comparator<Map.Entry<JDKResource, Void>> {\n+        @Override\n+        public int compare(Map.Entry<JDKResource, Void> o1, Map.Entry<JDKResource, Void> o2) {\n+            return o2.getKey().getPriority() - o1.getKey().getPriority();\n+        }\n+    }\n+\n+    JDKContext() {\n+        super(new ContextComparator());\n+    }\n+\n+    @Override\n+    public void register(JDKResource resource) {\n+        register(resource, null);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/JDKContext.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.crac;\n+\n+import jdk.crac.Resource;\n+\n+public interface JDKResource extends Resource {\n+    int getPriority();\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/JDKResource.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -28,0 +28,1 @@\n+import java.lang.reflect.Method;\n@@ -47,0 +48,1 @@\n+import java.security.PrivilegedAction;\n@@ -71,0 +73,1 @@\n+import jdk.crac.Context;\n@@ -74,0 +77,2 @@\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKResource;\n@@ -808,0 +813,31 @@\n+        static class ClassLoaderJarFile extends JarFile implements JDKResource {\n+            public ClassLoaderJarFile (File file, boolean verify, int mode, Runtime.Version version) throws IOException {\n+                super(file, verify, mode, version);\n+            }\n+\n+            @Override\n+            public void beforeCheckpoint(Context<? extends jdk.crac.Resource> context) {\n+                try {\n+                    Method zipBeforeCheckpoint = ZipFile.class.getDeclaredMethod(\"beforeCheckpoint\");\n+                    AccessController.doPrivileged(new PrivilegedAction<Void>() {\n+                        public Void run() {\n+                            zipBeforeCheckpoint.setAccessible(true);\n+                            return null;\n+                        }});\n+                    zipBeforeCheckpoint.invoke(this);\n+                } catch (Throwable e) {\n+                    e.printStackTrace();\n+                }\n+            }\n+\n+            @Override\n+            public void afterRestore(Context<? extends jdk.crac.Resource> context) {\n+                \/\/ do nothing, no fixup required\n+            }\n+\n+            @Override\n+            public int getPriority() {\n+                return 0;\n+            }\n+        }\n+\n@@ -815,2 +851,4 @@\n-                return checkJar(new JarFile(new File(p.getPath()), true, ZipFile.OPEN_READ,\n-                        JarFile.runtimeVersion()));\n+                ClassLoaderJarFile clJarFile = new ClassLoaderJarFile(new File(p.getPath()), true, ZipFile.OPEN_READ,\n+                        JarFile.runtimeVersion());\n+                Core.getJDKContext().register(clJarFile);\n+                return checkJar(clJarFile);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/loader\/URLClassPath.java","additions":40,"deletions":2,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -131,0 +131,1 @@\n+    exports javax.crac;\n@@ -132,0 +133,1 @@\n+    exports jdk.crac;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2017, 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/** \\file *\/\n+\n+#include \"jni.h\"\n+#include \"jvm.h\"\n+#include \"jni_util.h\"\n+#include \"io_util.h\"\n+#include \"io_util_md.h\"\n+\n+#include \"jdk_internal_crac_Core.h\"\n+\n+JNIEXPORT jobjectArray JNICALL\n+Java_jdk_crac_Core_checkpointRestore0(JNIEnv *env, jclass ignore)\n+{\n+    return JVM_Checkpoint(env);\n+}\n+\n+JNIEXPORT void JNICALL Java_jdk_internal_crac_Core_registerPersistent0\n+  (JNIEnv *env, jclass ignore, jobject fileDesc)\n+{\n+    jint fd = THIS_FD(fileDesc);\n+\n+    struct stat st;\n+    if (-1 == fstat(fd, &st)) {\n+        return;\n+    }\n+\n+    JVM_RegisterPersistent(fd, st.st_dev, st.st_ino);\n+}\n","filename":"src\/java.base\/share\/native\/libjava\/CracCore.c","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -28,3 +28,5 @@\n-import java.util.Set;\n-import java.util.HashSet;\n-import sun.net.ext.ExtendedSocketOptions;\n+\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKResource;\n@@ -40,0 +42,23 @@\n+    static class ResourceProxy implements JDKResource {\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+            PlainSocketImpl.beforeCheckpoint();\n+        }\n+\n+        @Override\n+        public void afterRestore(Context<? extends Resource> context) throws Exception {\n+            PlainSocketImpl.afterRestore();\n+        }\n+\n+        @Override\n+        public int getPriority() {\n+            return 0;\n+        }\n+    }\n+\n+    static Object closeLock = new Object();\n+    static boolean forceNonDeferedClose;\n+    static int closeCnt;\n+\n+    static JDKResource resourceProxy = new ResourceProxy();\n+\n@@ -42,0 +67,1 @@\n+        Core.getJDKContext().register(resourceProxy);\n@@ -64,0 +90,44 @@\n+    @Override\n+    void socketClose0(boolean useDeferredClose) throws IOException {\n+        if (useDeferredClose) {\n+            synchronized (closeLock) {\n+                if (forceNonDeferedClose) {\n+                    useDeferredClose = false;\n+                }\n+                if (useDeferredClose) {\n+                    ++closeCnt;\n+                }\n+            }\n+        }\n+\n+        try {\n+            socketClose1(useDeferredClose);\n+        } finally {\n+            if (useDeferredClose) {\n+                synchronized (closeLock) {\n+                    --closeCnt;\n+                    if (forceNonDeferedClose && closeCnt == 0) {\n+                        closeLock.notifyAll();\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    static void beforeCheckpoint() throws InterruptedException {\n+        synchronized (closeLock) {\n+            forceNonDeferedClose = true;\n+            while (closeCnt != 0) {\n+                closeLock.wait();\n+            }\n+            beforeCheckpoint0();\n+        }\n+    }\n+\n+    static void afterRestore() {\n+        synchronized (closeLock) {\n+            afterRestore0();\n+            forceNonDeferedClose = false;\n+        }\n+    }\n+\n@@ -82,1 +152,1 @@\n-    native void socketClose0(boolean useDeferredClose) throws IOException;\n+    native void socketClose1(boolean useDeferredClose) throws IOException;\n@@ -94,0 +164,4 @@\n+\n+    static native void beforeCheckpoint0();\n+\n+    static native void afterRestore0();\n","filename":"src\/java.base\/unix\/classes\/java\/net\/PlainSocketImpl.java","additions":78,"deletions":4,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n@@ -33,0 +35,2 @@\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKResource;\n@@ -35,0 +39,23 @@\n+    static class ResourceProxy implements JDKResource {\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+            FileDispatcherImpl.beforeCheckpoint();\n+        }\n+\n+        @Override\n+        public void afterRestore(Context<? extends Resource> context)\n+                throws IOException {\n+            FileDispatcherImpl.afterRestore();\n+        }\n+\n+        @Override\n+        public int getPriority() {\n+            return 0;\n+        }\n+    }\n+\n+    static Object closeLock = new Object();\n+    static boolean forceNonDeferedClose;\n+    static int closeCnt;\n+\n+    static ResourceProxy resourceProxy = new ResourceProxy();\n@@ -39,0 +66,1 @@\n+        Core.getJDKContext().register(resourceProxy);\n@@ -108,1 +136,24 @@\n-        preClose0(fd);\n+        boolean doPreclose = true;\n+        synchronized (closeLock) {\n+            if (forceNonDeferedClose) {\n+                doPreclose = false;\n+            }\n+            if (doPreclose) {\n+                ++closeCnt;\n+            }\n+        }\n+\n+        if (!doPreclose) {\n+            return;\n+        }\n+\n+        try {\n+            preClose0(fd);\n+        } finally {\n+            synchronized (closeLock) {\n+                closeCnt--;\n+                if (forceNonDeferedClose && closeCnt == 0) {\n+                    closeLock.notifyAll();\n+                }\n+            }\n+        }\n@@ -140,0 +191,17 @@\n+    static void beforeCheckpoint() throws InterruptedException {\n+        synchronized (closeLock) {\n+            forceNonDeferedClose = true;\n+            while (closeCnt != 0) {\n+                closeLock.wait();\n+            }\n+            beforeCheckpoint0();\n+        }\n+    }\n+\n+    static void afterRestore() throws IOException {\n+        synchronized (closeLock) {\n+            afterRestore0();\n+            forceNonDeferedClose = false;\n+        }\n+    }\n+\n@@ -191,0 +259,3 @@\n+    static native void beforeCheckpoint0();\n+\n+    static native void afterRestore0() throws IOException;\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/ch\/FileDispatcherImpl.java","additions":72,"deletions":1,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -0,0 +1,113 @@\n+\/*\n+ * Copyright (c) 2017, 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <string.h>\n+#include <stdio.h>\n+#include <limits.h>\n+#include <stdlib.h>\n+#include <errno.h>\n+#include <unistd.h>\n+#include <signal.h>\n+#include <sys\/stat.h>\n+#include <fcntl.h>\n+\n+#define RESTORE_SIGNAL   (SIGRTMIN + 2)\n+\n+#define MSGPREFIX \"action-script: \"\n+\n+static int post_resume(void) {\n+    char *pidstr = getenv(\"CRTOOLS_INIT_PID\");\n+    if (!pidstr) {\n+        fprintf(stderr, MSGPREFIX \"cannot find CRTOOLS_INIT_PID env\\n\");\n+        return 1;\n+    }\n+    int pid = atoi(pidstr);\n+\n+    union sigval sv = { .sival_int = 0 };\n+    if (-1 == sigqueue(pid, RESTORE_SIGNAL, sv)) {\n+        perror(MSGPREFIX \"sigqueue\");\n+        return 1;\n+    }\n+\n+    return 0;\n+}\n+\n+static int post_dump(void) {\n+    char realdir[PATH_MAX];\n+\n+    char *imgdir = getenv(\"CRTOOLS_IMAGE_DIR\");\n+    if (!imgdir) {\n+        fprintf(stderr, MSGPREFIX \"cannot find CRTOOLS_IMAGE_DIR env\\n\");\n+        return 1;\n+    }\n+\n+    if (!realpath(imgdir, realdir)) {\n+        fprintf(stderr, MSGPREFIX \"cannot canonicalize %s: %s\\n\", imgdir, strerror(errno));\n+        return 1;\n+    }\n+\n+    int dirfd = open(realdir, O_DIRECTORY);\n+    if (dirfd < 0) {\n+        fprintf(stderr, MSGPREFIX \"can not open image dir %s: %s\\n\", realdir, strerror(errno));\n+        return 1;\n+    }\n+\n+    int fd = openat(dirfd, \"cppath\", O_CREAT | O_WRONLY | O_TRUNC, 0644);\n+    if (fd < 0) {\n+        fprintf(stderr, MSGPREFIX \"can not open file %s\/cppath: %s\\n\", realdir, strerror(errno));\n+        return 1;\n+    }\n+\n+    if (write(fd, realdir, strlen(realdir)) < 0) {\n+        fprintf(stderr, MSGPREFIX \"can not write %s\/cppath: %s\\n\", realdir, strerror(errno));\n+        return 1;\n+    }\n+    return 0;\n+}\n+\n+\/** Kicks VM after restore.\n+ * Started by CRIU on certain phases of restore process. Does nothing after all\n+ * phases except \"post-resume\" which is issued after complete restore. Then\n+ * send signal via with ID attached to restored process. \\ref launcher should\n+ * pass the ID via ZE_CR_NEW_ARGS_ID env variable.\n+ *\/\n+int main(int argc, char *argv[]) {\n+    char *action = getenv(\"CRTOOLS_SCRIPT_ACTION\");\n+    if (!action) {\n+        fprintf(stderr, MSGPREFIX \"can not find CRTOOLS_SCRIPT_ACTION env\\n\");\n+        return 1;\n+    }\n+\n+    if (!strcmp(action, \"post-resume\")) {\n+        return post_resume();\n+    }\n+\n+    if (!strcmp(action, \"post-dump\")) {\n+        return post_dump();\n+    }\n+\n+    return 0;\n+}\n","filename":"src\/java.base\/unix\/native\/action-script\/action-script.c","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 2017, 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <string.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <unistd.h>\n+\n+int main(int argc, char *argv[]) {\n+    char** newargv = malloc((argc + 2) * sizeof(char*));\n+    newargv[0] = \"sudo\";\n+    newargv[1] = \"criu\";\n+    memcpy(newargv + 2, argv + 1, argc * sizeof(char*));\n+    execvp(\"\/usr\/bin\/sudo\", newargv);\n+    perror(\"sudo criu\");\n+    return 1;\n+}\n","filename":"src\/java.base\/unix\/native\/criu\/criu.c","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2017, 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdlib.h>\n+#include <unistd.h>\n+#include <stdio.h>\n+#include <string.h>\n+#include <inttypes.h>\n+#include <time.h>\n+#include <sys\/time.h>\n+\n+uint64_t nanos(void) {\n+  struct timespec tp;\n+  if (0 != clock_gettime(CLOCK_MONOTONIC, &tp)) {\n+    perror(\"clock_gettime\");\n+    exit(1);\n+  }\n+  return ((uint64_t)tp.tv_sec) * (1000 * 1000 * 1000) + (uint64_t)tp.tv_nsec;\n+}\n+\n+uint64_t millis(void) {\n+  struct timeval time;\n+  if (0 != gettimeofday(&time, NULL)) {\n+    perror(\"gettimeofday\");\n+    exit(1);\n+  }\n+  return ((uint64_t)time.tv_sec) * 1000 + ((uint64_t)time.tv_usec)\/1000;\n+}\n+\n+int main(int argc, char *argv[]) {\n+  int opt;\n+  uint64_t (*fn)(void) = nanos;\n+  while ((opt = getopt(argc, argv, \"mn\")) != -1) {\n+  switch (opt) {\n+    case 'n':\n+      fn = nanos;\n+      break;\n+    case 'm':\n+      fn = millis;\n+      break;\n+    default:\n+      break;\n+    }\n+  }\n+\n+  uint64_t time = fn();\n+  char *msg = optind < argc ? argv[optind] : \"prestart\";\n+  printf(\"STARTUPTIME %\" PRIu64 \" %s\\n\", time, msg);\n+  return 0;\n+}\n","filename":"src\/java.base\/unix\/native\/javatime\/javatime.c","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+const char * const *parentPathv;\n","filename":"src\/java.base\/unix\/native\/libjava\/childproc.c","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -129,1 +129,1 @@\n-const char * const *parentPathv;\n+extern const char * const *parentPathv;\n","filename":"src\/java.base\/unix\/native\/libjava\/childproc.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -749,0 +749,9 @@\n+    {\n+      const int restore_signal = SIGRTMIN + 2;\n+      \/\/ block restore_signal in launcher thread to allow JVM handle it\n+      sigset_t block_sig;\n+      sigemptyset(&block_sig);\n+      sigaddset(&block_sig, restore_signal);\n+      pthread_sigmask(SIG_BLOCK, &block_sig, NULL);\n+    }\n+\n","filename":"src\/java.base\/unix\/native\/libjli\/java_md_solinux.c","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -143,0 +143,13 @@\n+JNIEXPORT void JNICALL\n+Java_java_net_PlainSocketImpl_beforeCheckpoint0(JNIEnv *env, jclass cls) {\n+    \/* synchronized by closeLock *\/\n+    close(marker_fd);\n+    marker_fd = -1;\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_java_net_PlainSocketImpl_afterRestore0(JNIEnv *env, jclass cls) {\n+    \/* synchronized by closeLock *\/\n+    marker_fd = getMarkerFD();\n+}\n+\n@@ -764,1 +777,1 @@\n-Java_java_net_PlainSocketImpl_socketClose0(JNIEnv *env, jobject this,\n+Java_java_net_PlainSocketImpl_socketClose1(JNIEnv *env, jobject this,\n","filename":"src\/java.base\/unix\/native\/libnet\/PlainSocketImpl.c","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -78,0 +78,21 @@\n+JNIEXPORT void JNICALL\n+Java_sun_nio_ch_FileDispatcherImpl_beforeCheckpoint0(JNIEnv *env, jclass cl)\n+{\n+    \/* synchronized by closeLock *\/\n+    close(preCloseFD);\n+    preCloseFD = -1;\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_sun_nio_ch_FileDispatcherImpl_afterRestore0(JNIEnv *env, jclass cl)\n+{\n+    \/* synchronized by closeLock *\/\n+    int sp[2];\n+    if (socketpair(PF_UNIX, SOCK_STREAM, 0, sp) < 0) {\n+        JNU_ThrowIOExceptionWithLastError(env, \"socketpair failed\");\n+        return;\n+    }\n+    preCloseFD = sp[0];\n+    close(sp[1]);\n+}\n+\n","filename":"src\/java.base\/unix\/native\/libnio\/ch\/FileDispatcherImpl.c","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2017, 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <errno.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <signal.h>\n+#include <sys\/wait.h>\n+\n+#define MSGPREFIX \"wait: \"\n+\n+static int g_pid;\n+\n+static void sighandler(int sig, siginfo_t *info, void *uc) {\n+    if (0 <= g_pid) {\n+        kill(g_pid, sig);\n+    }\n+}\n+\n+int main(int argc, char *argv[]) {\n+    char *pidstr = getenv(\"CRTOOLS_INIT_PID\");\n+    if (!pidstr) {\n+        fprintf(stderr, MSGPREFIX \"no CRTOOLS_INIT_PID: signals may not be delivered\\n\");\n+    }\n+    g_pid = pidstr ? atoi(pidstr) : -1;\n+\n+    struct sigaction sigact;\n+    sigfillset(&sigact.sa_mask);\n+    sigact.sa_flags = SA_SIGINFO;\n+    sigact.sa_sigaction = sighandler;\n+\n+    int sig;\n+    for (sig = 1; sig <= 31; ++sig) {\n+        if (sig == SIGKILL || sig == SIGSTOP) {\n+            continue;\n+        }\n+        if (-1 == sigaction(sig, &sigact, NULL)) {\n+            perror(\"sigaction\");\n+        }\n+    }\n+\n+    sigset_t allset;\n+    sigfillset(&allset);\n+    if (-1 == sigprocmask(SIG_UNBLOCK, &allset, NULL)) {\n+        perror(MSGPREFIX \"sigprocmask\");\n+    }\n+\n+    int status;\n+    int ret;\n+    do {\n+        ret = waitpid(g_pid, &status, 0);\n+    } while (ret == -1 && errno == EINTR);\n+\n+    if (ret == -1) {\n+        perror(MSGPREFIX \"waitpid\");\n+        return 1;\n+    }\n+\n+    if (WIFEXITED(status)) {\n+        return WEXITSTATUS(status);\n+    }\n+\n+    return 1;\n+}\n","filename":"src\/java.base\/unix\/native\/wait\/wait.c","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,3 @@\n+\/* global GSS function table *\/\n+GSS_FUNCTION_TABLE_PTR ftab;\n+\n","filename":"src\/java.security.jgss\/share\/native\/libj2gss\/NativeFunc.c","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -280,1 +280,1 @@\n-GSS_FUNCTION_TABLE_PTR ftab;\n+extern GSS_FUNCTION_TABLE_PTR ftab;\n","filename":"src\/java.security.jgss\/share\/native\/libj2gss\/NativeFunc.h","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -203,2 +203,7 @@\n-                        return path.getFileName().toString().equals(\"jspawnhelper\")\n-                                || path.getFileName().toString().equals(\"jexec\");\n+                        String fileName = path.getFileName().toString();\n+                        return fileName.equals(\"jspawnhelper\")\n+                            || fileName.equals(\"jexec\")\n+                            || fileName.equals(\"action-script\")\n+                            || fileName.equals(\"wait\")\n+                            || fileName.equals(\"criu\")\n+                            || fileName.equals(\"javatime\");\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/builder\/DefaultImageBuilder.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -325,6 +325,6 @@\n-sctp_getladdrs_func* nio_sctp_getladdrs;\n-sctp_freeladdrs_func* nio_sctp_freeladdrs;\n-sctp_getpaddrs_func* nio_sctp_getpaddrs;\n-sctp_freepaddrs_func* nio_sctp_freepaddrs;\n-sctp_bindx_func* nio_sctp_bindx;\n-sctp_peeloff_func* nio_sctp_peeloff;\n+extern sctp_getladdrs_func* nio_sctp_getladdrs;\n+extern sctp_freeladdrs_func* nio_sctp_freeladdrs;\n+extern sctp_getpaddrs_func* nio_sctp_getpaddrs;\n+extern sctp_freepaddrs_func* nio_sctp_freepaddrs;\n+extern sctp_bindx_func* nio_sctp_bindx;\n+extern sctp_peeloff_func* nio_sctp_peeloff;\n","filename":"src\/jdk.sctp\/unix\/native\/libsctp\/Sctp.h","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,0 +46,7 @@\n+sctp_getladdrs_func* nio_sctp_getladdrs;\n+sctp_freeladdrs_func* nio_sctp_freeladdrs;\n+sctp_getpaddrs_func* nio_sctp_getpaddrs;\n+sctp_freepaddrs_func* nio_sctp_freepaddrs;\n+sctp_bindx_func* nio_sctp_bindx;\n+sctp_peeloff_func* nio_sctp_peeloff;\n+\n","filename":"src\/jdk.sctp\/unix\/native\/libsctp\/SctpNet.c","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,114 @@\n+\/\/ Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it under\n+\/\/ the terms of the GNU General Public License version 2 only, as published by\n+\/\/ the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n+\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n+\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n+\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version 2\n+\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n+\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n+\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n+\/\/ have any questions.\n+\n+package jdk.test.jdk.crac;\n+\n+import jdk.crac.*;\n+\n+\/**\n+ * @test\n+ * @compile ResourceTest.java\n+ *\/\n+public class ResourceTest {\n+    static class CRResource implements Resource {\n+        String id;\n+        boolean[] throwCond;\n+        int nCalls = 0;\n+        CRResource(String id, boolean... throwCond) {\n+            this.id = id;\n+            this.throwCond = throwCond;\n+        }\n+\n+        void maybeException(String callId) throws Exception {\n+            boolean t = nCalls < throwCond.length ? throwCond[nCalls] : throwCond[throwCond.length - 1];\n+            System.out.println(id + \" \" + callId + \"(\" + nCalls + \") throw? \" + t);\n+            ++nCalls;\n+            if (t) {\n+                throw new RuntimeException(id);\n+            }\n+        }\n+\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+            maybeException(\"beforeCheckpoint\");\n+        }\n+\n+        @Override\n+        public void afterRestore(Context<? extends Resource> context) throws Exception {\n+            maybeException(\"afterRestore\");\n+        }\n+    }\n+\n+    static class SingleContext extends Context<Resource> {\n+        private Resource r;\n+\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws CheckpointException {\n+            try {\n+                r.beforeCheckpoint(this);\n+            } catch (Exception e) {\n+                CheckpointException newException = new CheckpointException();\n+                newException.addSuppressed(e);\n+                throw newException;\n+            }\n+        }\n+\n+        @Override\n+        public void afterRestore(Context<? extends Resource> context) throws RestoreException {\n+            try {\n+                r.afterRestore(this);\n+            } catch (Exception e) {\n+                RestoreException newException = new RestoreException();\n+                newException.addSuppressed(e);\n+                throw newException;\n+            }\n+\n+        }\n+\n+        @Override\n+        public void register(Resource r) {\n+            this.r = r;\n+        }\n+\n+        public SingleContext(Resource r) {\n+            register(r);\n+        }\n+    }\n+\n+    static public void main(String[] args) throws Exception {\n+        Core.getGlobalContext().register(\n+            new CRResource(\"One\", true, false));\n+        Core.getGlobalContext().register(\n+            new SingleContext(\n+                new CRResource(\"Two\", false, true, false, true)));\n+        \/\/System.gc();\n+        int tries = 2;\n+        for (int i = 0; i < 2; ++i) {\n+            try {\n+                jdk.crac.Core.checkpointRestore();\n+            } catch (CheckpointException e) {\n+                e.printStackTrace();\n+            } catch (RestoreException e) {\n+                e.printStackTrace();\n+            }\n+        }\n+        System.out.println(\"DONE\");\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/ResourceTest.java","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"},{"patch":"@@ -0,0 +1,137 @@\n+\/\/ Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it under\n+\/\/ the terms of the GNU General Public License version 2 only, as published by\n+\/\/ the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n+\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n+\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n+\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version 2\n+\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n+\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n+\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n+\/\/ have any questions.\n+\n+\n+import java.nio.channels.*;\n+import java.io.IOException;\n+\n+class ChannelResource implements jdk.crac.Resource {\n+\n+    public enum SelectionType {SELECT, SELECT_TIMEOUT, SELECT_NOW};\n+\n+    private SocketChannel channel;\n+    private SelectionKey  key;\n+    private Selector      selector;\n+\n+    private final SelectionType selType;\n+\n+    public ChannelResource(SelectionType selType) {\n+        this.selType = selType;\n+        jdk.crac.Core.getGlobalContext().register(this);\n+    }\n+\n+    public void open() throws IOException {\n+        channel = SocketChannel.open();\n+        channel.configureBlocking(false);\n+    }\n+\n+    public void register(Selector selector) throws IOException {\n+        key = channel.register(selector, SelectionKey.OP_READ);\n+        this.selector = selector;\n+    }\n+\n+    @Override\n+    public void beforeCheckpoint() throws IOException {\n+\n+        channel.socket().close();\n+\n+        \/\/ causes the channel deregistration\n+        if (selType == SelectionType.SELECT_NOW) {\n+            selector.selectNow();\n+        } else if (selType == SelectionType.SELECT_TIMEOUT) {\n+            selector.select(500);\n+        } else {\n+            new Thread(new Runnable() {\n+                @Override\n+                public void run() {\n+                    try {\n+                        Thread.sleep(1000);\n+                        selector.wakeup();\n+                    } catch (InterruptedException ie) { throw new RuntimeException(ie); }\n+                }\n+            }).start();\n+\n+            selector.select();\n+        }\n+    }\n+\n+    @Override\n+    public void afterRestore() {}\n+}\n+\n+\n+public class Test {\n+\n+    private static void Test(ChannelResource.SelectionType selType, boolean openSelectorAtFirst) throws Exception {\n+\n+        if (openSelectorAtFirst) {\n+\n+            Selector selector = Selector.open();\n+            ChannelResource ch = new ChannelResource(selType);\n+            ch.open();\n+            ch.register(selector);\n+\n+            jdk.crac.Core.checkpointRestore();\n+\n+            selector.close();\n+\n+        } else { \/\/ try in other order (see ZE-970)\n+\n+            ChannelResource ch = new ChannelResource(selType);\n+            ch.open();\n+            Selector selector = Selector.open();\n+            ch.register(selector);\n+\n+            jdk.crac.Core.checkpointRestore();\n+\n+            selector.close();\n+        }\n+    }\n+\n+\n+    public static void main(String args[]) throws Exception {\n+\n+        if (args.length < 1) { throw new RuntimeException(\"test number is missing\"); }\n+\n+        switch (args[0]) { \/\/ 1, 2: ZE-970\n+            case \"1\":\n+                Test(ChannelResource.SelectionType.SELECT_NOW, true);\n+                break;\n+            case \"2\":\n+                Test(ChannelResource.SelectionType.SELECT_NOW, false);\n+                break;\n+            case \"3\":\n+                Test(ChannelResource.SelectionType.SELECT, true);\n+                break;\n+            case \"4\":\n+                Test(ChannelResource.SelectionType.SELECT, false);\n+                break;\n+            case \"5\":\n+                Test(ChannelResource.SelectionType.SELECT_TIMEOUT, true);\n+                break;\n+            case \"6\":\n+                Test(ChannelResource.SelectionType.SELECT_TIMEOUT, false);\n+                break;\n+            default:\n+                throw new RuntimeException(\"invalid test number\");\n+        }\n+\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/Selector\/Test970\/Test.java","additions":137,"deletions":0,"binary":false,"changes":137,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+#!\/bin\/sh\n+\n+# Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it under\n+# the terms of the GNU General Public License version 2 only, as published by\n+# the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT ANY\n+# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n+# A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n+# details (a copy is included in the LICENSE file that accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version 2\n+# along with this work; if not, write to the Free Software Foundation, Inc.,\n+# 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n+# CA 94089 USA or visit www.azul.com if you need additional information or\n+# have any questions.\n+\n+\n+##\n+## @test Test.sh\n+## @summary a regression test for ZE-970 (\"a channel deregistration\n+##          is locked depending on mutual order of selector and channel creation\")\n+## @compile Test.java\n+## @run shell\/timeout=120 Test.sh\n+##\n+\n+set -x\n+\n+for test in `seq 1 6`\n+do\n+\n+    IMGDIR=\"cr$test\"\n+\n+    set +e\n+    ${TESTJAVA}\/bin\/java -cp ${TESTCLASSPATH} -XX:CRaCCheckpointTo=$IMGDIR Test $test\n+    e=$?\n+\n+    set -e\n+    [ $e -eq 137 ]\n+\n+    ${TESTJAVA}\/bin\/java -XX:CRaCRestoreFrom=$IMGDIR Test\n+\n+    echo \"PASSED $test\"\n+\n+done\n","filename":"test\/jdk\/jdk\/crac\/Selector\/Test970\/Test.sh","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,102 @@\n+\/\/ Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it under\n+\/\/ the terms of the GNU General Public License version 2 only, as published by\n+\/\/ the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n+\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n+\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n+\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version 2\n+\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n+\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n+\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n+\/\/ have any questions.\n+\n+\n+import java.nio.channels.Selector;\n+import java.io.IOException;\n+\n+public class Test {\n+\n+    \/\/ select(): interrupt before the checkpoint\n+    private static void test(boolean setTimeout, boolean interruptBeforeCheckpoint, boolean skipCR) throws Exception {\n+\n+        Selector selector = Selector.open();\n+        Runnable r = new Runnable() {\n+            @Override\n+            public void run() {  try {\n+                if (setTimeout) { selector.select(3600_000); }\n+                else { selector.select(); }\n+            } catch (IOException e) { throw new RuntimeException(e); }   }\n+        };\n+        Thread t = new Thread(r);\n+        t.start();\n+\n+        Thread.sleep(1000);\n+\n+        if (interruptBeforeCheckpoint) {\n+            t.interrupt();\n+            t.join();\n+            System.out.println(\">> interrupt before checkpoint\");\n+        }\n+\n+        if (!skipCR) {\n+            jdk.crac.Core.checkpointRestore();\n+        }\n+\n+        Thread.sleep(1000);\n+\n+        if (!interruptBeforeCheckpoint) {\n+            t.interrupt();\n+            t.join();\n+            System.out.println(\">>> interrupt after restore\");\n+        }\n+\n+        \/\/ just in case, check that the selector works as expected\n+\n+        if (!selector.isOpen()) { throw new RuntimeException(\"the selector must be open\"); }\n+\n+        selector.wakeup();\n+        selector.select();\n+\n+        selector.selectNow();\n+        selector.select(200);\n+        selector.close();\n+    }\n+\n+\n+    public static void main(String args[]) throws Exception {\n+\n+        if (args.length < 1) { throw new RuntimeException(\"test number is missing\"); }\n+\n+        switch (args[0]) {\n+            case \"1\":\n+                test(true, true, false);\n+                break;\n+            case \"2\":\n+                test(true, false, false);\n+                break;\n+            case \"3\":\n+                test(false, true, false);\n+                break;\n+            case \"4\":\n+                test(false, false, false);\n+                break;\n+            \/\/ 5, 6: skip C\/R\n+            case \"5\":\n+                test(true, true, true);\n+                break;\n+            case \"6\":\n+                test(false, true, true);\n+                break;\n+            default:\n+                throw new RuntimeException(\"invalid test number\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/Selector\/interruptedSelection\/Test.java","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+#!\/bin\/sh\n+\n+# Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it under\n+# the terms of the GNU General Public License version 2 only, as published by\n+# the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT ANY\n+# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n+# A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n+# details (a copy is included in the LICENSE file that accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version 2\n+# along with this work; if not, write to the Free Software Foundation, Inc.,\n+# 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n+# CA 94089 USA or visit www.azul.com if you need additional information or\n+# have any questions.\n+\n+\n+##\n+## @test Test.sh\n+## @summary check that the thread blocked by Selector.select() could be properly woken up by an interruption\n+## @compile Test.java\n+## @run shell\/timeout=120 Test.sh\n+##\n+\n+set -x\n+\n+for test in `seq 1 4`\n+do\n+\n+    IMGDIR=\"cr$test\"\n+\n+    set +e\n+    ${TESTJAVA}\/bin\/java -cp ${TESTCLASSPATH} -XX:CRaCCheckpointTo=$IMGDIR Test $test\n+    e=$?\n+\n+    set -e\n+    [ $e -eq 137 ]\n+\n+    ${TESTJAVA}\/bin\/java -XX:CRaCRestoreFrom=$IMGDIR Test\n+\n+    echo \"PASSED $test\"\n+\n+done\n+\n+\n+\n+${TESTJAVA}\/bin\/java -cp ${TESTCLASSPATH} Test 5\n+echo \"PASSED 5\"\n+\n+${TESTJAVA}\/bin\/java -cp ${TESTCLASSPATH} Test 6\n+echo \"PASSED 6\"\n","filename":"test\/jdk\/jdk\/crac\/Selector\/interruptedSelection\/Test.sh","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,192 @@\n+\/\/ Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it under\n+\/\/ the terms of the GNU General Public License version 2 only, as published by\n+\/\/ the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n+\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n+\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n+\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version 2\n+\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n+\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n+\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n+\/\/ have any questions.\n+\n+\n+import java.nio.channels.*;\n+import java.io.IOException;\n+\n+class ChannelResource implements jdk.crac.Resource {\n+\n+    private SocketChannel channel;\n+    private SelectionKey  key;\n+    private Selector      selector;\n+\n+    private Object        att = new Integer(123);\n+\n+    public ChannelResource() { jdk.crac.Core.getGlobalContext().register(this); }\n+\n+    public void open() throws IOException {\n+        channel = SocketChannel.open();\n+        channel.configureBlocking(false);\n+    }\n+\n+    public void register(Selector selector) throws IOException {\n+        key = channel.register(selector, SelectionKey.OP_CONNECT);\n+        key.attach(att);\n+        this.selector = selector;\n+    }\n+\n+    @Override\n+    public void beforeCheckpoint() throws IOException {\n+\n+        channel.socket().close(); \/\/ close the channel => cancel the key\n+        check(!channel.isOpen(), \"the channel should not be open\");\n+        selector.select(100); \/\/ causes the channel deregistration\n+    }\n+\n+    @Override\n+    public void afterRestore() {\n+\n+        check(key.selector().equals(selector), \"invalid key.selector()\");\n+        check(key.channel().equals(channel), \"invalid key.channel()\");\n+\n+        \/\/ the key is cancelled\n+        check(!key.isValid(), \"expected: key.isValid() == false\");\n+\n+        boolean caught = false;\n+        try { key.readyOps(); }\n+        catch (CancelledKeyException e) { caught = true; }\n+        check(caught, \"expected CancelledKeyException is missing\");\n+\n+        caught = false;\n+        try { key.interestOps(); }\n+        catch (CancelledKeyException e) { caught = true; }\n+        check(caught, \"expected CancelledKeyException is missing\");\n+\n+        caught = false;\n+        try { key.interestOps(SelectionKey.OP_CONNECT); }\n+        catch (CancelledKeyException e) { caught = true; }\n+        check(caught, \"expected CancelledKeyException is missing\");\n+\n+        caught = false;\n+        try { key.readyOps(); }\n+        catch (CancelledKeyException e) { caught = true; }\n+        check(caught, \"expected CancelledKeyException is missing\");\n+\n+        caught = false;\n+        try { key.isReadable(); }\n+        catch (CancelledKeyException e) { caught = true; }\n+        check(caught, \"expected CancelledKeyException is missing\");\n+\n+        caught = false;\n+        try { key.isWritable(); }\n+        catch (CancelledKeyException e) { caught = true; }\n+        check(caught, \"expected CancelledKeyException is missing\");\n+\n+        caught = false;\n+        try { key.isConnectable(); }\n+        catch (CancelledKeyException e) { caught = true; }\n+        check(caught, \"expected CancelledKeyException is missing\");\n+\n+        caught = false;\n+        try { key.isAcceptable(); }\n+        catch (CancelledKeyException e) { caught = true; }\n+        check(caught, \"expected CancelledKeyException is missing\");\n+\n+        check(att.equals(key.attachment()), \"invalid key.attachment()\");\n+\n+        key.cancel(); \/\/ try just in case\n+\n+        \/\/ register again\n+        try {\n+            channel = SocketChannel.open();\n+            channel.configureBlocking(false);\n+            key = channel.register(selector, SelectionKey.OP_READ);\n+        }\n+        catch (Exception e) { throw new RuntimeException(e); }\n+    }\n+\n+    \/\/ to check after restore\n+    public void checkKey() {\n+\n+        check(key.isValid(), \"key must be valid\");\n+\n+        check(key.selector().equals(selector), \"invalid key.selector()\");\n+        check(key.channel().equals(channel), \"invalid key.channel()\");\n+\n+        key.isReadable(); \/\/ just call, cannot set \"ready\" state manually\n+        check( !key.isWritable()   , \"invalid key.isWritable()\"   );\n+        check( !key.isConnectable(), \"invalid key.isConnectable()\");\n+        check( !key.isAcceptable() , \"invalid key.isAcceptable()\" );\n+\n+        check(key.interestOps() == SelectionKey.OP_READ, \"invalid key.interestOps()\");\n+\n+        System.out.println(\">> ready >> \" + key.readyOps());\n+\n+        check(key.attachment() == null, \"key.attachment() expected to be null\");\n+\n+        key.cancel(); \/\/ try just in case\n+    }\n+\n+    private void check(boolean b, String msg) { if (!b) { throw new RuntimeException(msg); } }\n+}\n+\n+\n+public class Test {\n+\n+    private static void test(boolean openSelectorAtFirst) throws Exception {\n+\n+        ChannelResource ch;\n+        Selector selector = null;\n+\n+        \/\/ check various order (see ZE-970)\n+        if (openSelectorAtFirst) { selector = Selector.open(); }\n+\n+        ch = new ChannelResource();\n+        ch.open();\n+\n+        if (!openSelectorAtFirst) { selector = Selector.open(); }\n+\n+        ch.register(selector);\n+\n+        try {\n+            jdk.crac.Core.checkpointRestore();\n+        } catch (jdk.crac.CheckpointException e) {\n+            e.printExceptions(System.out);\n+            throw e;\n+        } catch (jdk.crac.RestoreException e) {\n+            e.printExceptions(System.out);\n+            throw e;\n+        }\n+\n+        Thread.sleep(200);\n+\n+        ch.checkKey();\n+\n+        selector.close();\n+    }\n+\n+    public static void main(String args[]) throws Exception {\n+\n+        if (args.length < 1) { throw new RuntimeException(\"test number is missing\"); }\n+\n+        switch (args[0]) {\n+            case \"1\":\n+                test(true);\n+                break;\n+            case \"2\":\n+                test(false);\n+                break;\n+            default:\n+                throw new RuntimeException(\"invalid test number\");\n+        }\n+\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/Selector\/keyAfterRestore\/Test.java","additions":192,"deletions":0,"binary":false,"changes":192,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+#!\/bin\/sh\n+\n+# Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it under\n+# the terms of the GNU General Public License version 2 only, as published by\n+# the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT ANY\n+# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n+# A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n+# details (a copy is included in the LICENSE file that accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version 2\n+# along with this work; if not, write to the Free Software Foundation, Inc.,\n+# 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n+# CA 94089 USA or visit www.azul.com if you need additional information or\n+# have any questions.\n+\n+\n+##\n+## @test Test.sh\n+## @summary a trivial test for SelectionKey's state after restore\n+## @compile Test.java\n+## @run shell\/timeout=60 Test.sh\n+##\n+\n+set -x\n+\n+for test in `seq 1 2`\n+do\n+\n+    IMGDIR=\"cr$test\"\n+\n+    set +e\n+    ${TESTJAVA}\/bin\/java -cp ${TESTCLASSPATH} -XX:CRaCCheckpointTo=$IMGDIR Test $test\n+    e=$?\n+\n+    set -e\n+    [ $e -eq 137 ]\n+\n+    ${TESTJAVA}\/bin\/java -XX:CRaCRestoreFrom=$IMGDIR Test\n+\n+    echo \"PASSED $test\"\n+\n+done\n","filename":"test\/jdk\/jdk\/crac\/Selector\/keyAfterRestore\/Test.sh","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,172 @@\n+\/\/ Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it under\n+\/\/ the terms of the GNU General Public License version 2 only, as published by\n+\/\/ the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n+\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n+\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n+\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version 2\n+\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n+\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n+\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n+\/\/ have any questions.\n+\n+\n+import java.nio.channels.Selector;\n+import java.io.IOException;\n+import java.util.Random;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+\n+public class Test {\n+\n+    private final static Random RND = new Random();\n+\n+    private final static long LONG_TIMEOUT = 3600_000;\n+    private final static long SHORT_TIMEOUT = 3_000;\n+\n+    public enum testType {\n+        NO_TIMEOUTS,    \/\/ test only select(), wakeup\n+        ONLY_TIMEOUTS,  \/\/ test only select(timeout), do not call wakeup()\n+        MIXED};\n+\n+    private static void test(testType type, boolean skipCR) throws Exception {\n+\n+        long dt = (type == testType.ONLY_TIMEOUTS) ? SHORT_TIMEOUT : LONG_TIMEOUT;\n+\n+        int nThreads = (type == testType.ONLY_TIMEOUTS) ? 5 : 20;\n+\n+        AtomicInteger nSelected = new AtomicInteger(0);\n+\n+        Selector selector = Selector.open();\n+\n+        Thread selectThreads[] = new Thread[nThreads];\n+\n+        boolean setTimeout[] = new boolean[nThreads];\n+        for (int i = 0; i < nThreads; ++i) {\n+            boolean t = false; \/\/ NO_TIMEOUTS\n+            if (type == testType.ONLY_TIMEOUTS) { t = true; }\n+            else if (type == testType.MIXED) { t = RND.nextBoolean(); }\n+            setTimeout[i] = t;\n+        }\n+\n+        Runnable rStart = new Runnable() {\n+            @Override\n+            public void run() {\n+\n+                for (int i = 0; i < nThreads; ++i) {\n+\n+                    boolean timeout = setTimeout[i];\n+\n+                    selectThreads[i] = new Thread(new Runnable() {\n+                        @Override\n+                        public void run() {\n+                            try {\n+                                int n = nSelected.incrementAndGet();\n+                                System.out.println(\">> select\" + (timeout ? \" (t)\" : \"\") + \" \" + n);\n+                                if (timeout) { selector.select(dt); }\n+                                else { selector.select(); }\n+                                nSelected.decrementAndGet();\n+                                System.out.println(\">> done\" + (timeout ? \" (t)\" : \"\") + \" \" + n);\n+                            } catch (IOException e) {\n+                                throw new RuntimeException(e);\n+                            }\n+                        }\n+                    });\n+                    selectThreads[i].start();\n+                    try { Thread.sleep(200); } catch (InterruptedException ie) {}\n+                }\n+            }\n+        };\n+        Thread t = new Thread(rStart);\n+        t.start();\n+        Thread.sleep(500);\n+\n+        if (!skipCR) {\n+            jdk.crac.Core.checkpointRestore();\n+        }\n+\n+        t.join();\n+        Thread.sleep(1000);\n+\n+        if (type == testType.ONLY_TIMEOUTS) { \/\/ do not wake threads up, the timeouts must work\n+\n+            while (nSelected.get() > 0) { Thread.sleep(1000); }\n+\n+        } else {\n+\n+            int nWakeups = 0;\n+            while (true) {\n+\n+                int nBefore = nSelected.get();\n+                if (nBefore == 0) { break; }\n+\n+                System.out.println(\">> wakeup() #\" + (nWakeups + 1));\n+                ++nWakeups;\n+\n+                selector.wakeup();\n+                while (nSelected.get() == nBefore) { \/\/ wait until any select() would be woken up\n+                    Thread.sleep(500);\n+                }\n+            }\n+\n+            if (nWakeups > nThreads) {\n+                selector.close();\n+                throw new RuntimeException(\"invalid number of wakeups\");\n+            }\n+        }\n+\n+        \/\/ just in case...\n+        for (Thread st: selectThreads) { st.join(); }\n+\n+        \/\/ === check that the selector works as expected ===\n+        if (!selector.isOpen()) { throw new RuntimeException(\"the selector must be open\"); }\n+\n+        selector.wakeup();\n+        selector.select();\n+\n+        selector.selectNow();\n+        selector.select(200);\n+\n+        selector.close();\n+    }\n+\n+\n+\n+    public static void main(String args[]) throws Exception {\n+\n+        if (args.length < 1) { throw new RuntimeException(\"test number is missing\"); }\n+\n+        switch (args[0]) {\n+            case \"1\":\n+                test(testType.ONLY_TIMEOUTS, false);\n+                break;\n+            case \"2\":\n+                test(testType.NO_TIMEOUTS, false);\n+                break;\n+            case \"3\":\n+                test(testType.MIXED, false);\n+                break;\n+            \/\/ 4-6: no C\/R\n+            case \"4\":\n+                test(testType.ONLY_TIMEOUTS, true);\n+                break;\n+            case \"5\":\n+                test(testType.NO_TIMEOUTS, true);\n+                break;\n+            case \"6\":\n+                test(testType.MIXED, true);\n+                break;\n+            default:\n+                throw new RuntimeException(\"invalid test number\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/Selector\/multipleSelect\/Test.java","additions":172,"deletions":0,"binary":false,"changes":172,"status":"added"},{"patch":"@@ -0,0 +1,60 @@\n+#!\/bin\/sh\n+\n+# Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it under\n+# the terms of the GNU General Public License version 2 only, as published by\n+# the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT ANY\n+# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n+# A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n+# details (a copy is included in the LICENSE file that accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version 2\n+# along with this work; if not, write to the Free Software Foundation, Inc.,\n+# 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n+# CA 94089 USA or visit www.azul.com if you need additional information or\n+# have any questions.\n+\n+\n+##\n+## @test Test.sh\n+## @summary check work of multiple select() + wakeup() + C\/R\n+## @compile Test.java\n+## @run shell\/timeout=240 Test.sh\n+##\n+\n+set -x\n+\n+for test in `seq 1 3`\n+do\n+\n+    IMGDIR=\"cr$test\"\n+\n+    set +e\n+    ${TESTJAVA}\/bin\/java -cp ${TESTCLASSPATH}:$CPAPPEND -XX:CRaCCheckpointTo=$IMGDIR Test $test\n+    e=$?\n+\n+    set -e\n+    [ $e -eq 137 ]\n+\n+    ${TESTJAVA}\/bin\/java -XX:CRaCRestoreFrom=$IMGDIR Test\n+\n+    echo \"PASSED $test\"\n+\n+done\n+\n+# check conformity (no C\/R)\n+\n+set -e\n+for test in `seq 4 6`\n+do\n+\n+    ${TESTJAVA}\/bin\/java -cp ${TESTCLASSPATH} Test $test\n+    echo \"PASSED $test\"\n+\n+done\n","filename":"test\/jdk\/jdk\/crac\/Selector\/multipleSelect\/Test.sh","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -0,0 +1,106 @@\n+\/\/ Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it under\n+\/\/ the terms of the GNU General Public License version 2 only, as published by\n+\/\/ the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n+\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n+\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n+\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version 2\n+\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n+\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n+\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n+\/\/ have any questions.\n+\n+\n+import java.nio.channels.Selector;\n+import java.io.IOException;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+\n+public class Test {\n+\n+    private static void test(boolean skipCR) throws Exception {\n+\n+        AtomicInteger nSelected = new AtomicInteger(0);\n+\n+        Selector selector = Selector.open();\n+\n+        int nThreads = skipCR ? 30 : 150; \/\/ some selectNow() calls should occur at the same time with C\/R\n+        Thread threads[] = new Thread[nThreads];\n+\n+        Runnable rStart = new Runnable() {\n+            @Override\n+            public void run() {\n+\n+                for (int i = 0; i < threads.length; ++i) {\n+\n+                    threads[i] = new Thread(new Runnable() {\n+                        @Override\n+                        public void run() {\n+                            try {\n+                                System.out.println(\"selectNow\");\n+                                nSelected.incrementAndGet();\n+                                selector.selectNow();\n+                                System.out.println(\"done\");\n+                                nSelected.decrementAndGet();\n+                            } catch (IOException e) {\n+                                throw new RuntimeException(e);\n+                            }\n+                        }\n+                    });\n+                    threads[i].start();\n+                    try { Thread.sleep(5); } catch (InterruptedException ie) {}\n+                }\n+            }\n+        };\n+        Thread tStart = new Thread(rStart);\n+        tStart.start();\n+        Thread.sleep(500);\n+\n+        if (!skipCR) {\n+            jdk.crac.Core.checkpointRestore();\n+        }\n+\n+        tStart.join();\n+\n+        do { Thread.sleep(2000); } while (nSelected.get() > 0);\n+        for (Thread t: threads) { t.join(); } \/\/ just in case...\n+\n+        \/\/ === check that the selector works as expected ===\n+        if (!selector.isOpen()) { throw new RuntimeException(\"the selector must be open\"); }\n+\n+        selector.wakeup();\n+        selector.select();\n+\n+        selector.selectNow();\n+        selector.select(200);\n+\n+        selector.close();\n+    }\n+\n+\n+\n+    public static void main(String args[]) throws Exception {\n+\n+        if (args.length < 1) { throw new RuntimeException(\"test number is missing\"); }\n+\n+        switch (args[0]) {\n+            case \"1\":\n+                test(false);\n+                break;\n+            case \"2\":\n+                test(true);\n+                break;\n+            default:\n+                throw new RuntimeException(\"invalid test number\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/Selector\/multipleSelectNow\/Test.java","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+#!\/bin\/sh\n+\n+# Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it under\n+# the terms of the GNU General Public License version 2 only, as published by\n+# the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT ANY\n+# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n+# A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n+# details (a copy is included in the LICENSE file that accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version 2\n+# along with this work; if not, write to the Free Software Foundation, Inc.,\n+# 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n+# CA 94089 USA or visit www.azul.com if you need additional information or\n+# have any questions.\n+\n+\n+##\n+## @test Test.sh\n+## @summary check work of multiple selectNow() + C\/R peaceful coexistence\n+## @compile Test.java\n+## @run shell\/timeout=120 Test.sh\n+##\n+\n+set -x\n+\n+set +e\n+${TESTJAVA}\/bin\/java -cp ${TESTCLASSPATH} -XX:CRaCCheckpointTo=cr Test 1\n+e=$?\n+\n+set -e\n+[ $e -eq 137 ]\n+\n+${TESTJAVA}\/bin\/java -XX:CRaCRestoreFrom=cr Test\n+echo \"PASSED 1\"\n+\n+\n+# check conformity (no C\/R)\n+\n+${TESTJAVA}\/bin\/java -cp ${TESTCLASSPATH} Test 2\n+echo \"PASSED 2\"\n+\n","filename":"test\/jdk\/jdk\/crac\/Selector\/multipleSelectNow\/Test.sh","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,122 @@\n+\/\/ Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it under\n+\/\/ the terms of the GNU General Public License version 2 only, as published by\n+\/\/ the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n+\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n+\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n+\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version 2\n+\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n+\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n+\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n+\/\/ have any questions.\n+\n+\n+import java.nio.channels.Selector;\n+import java.nio.channels.ClosedSelectorException;\n+import java.io.IOException;\n+import java.util.Random;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+\n+public class Test {\n+\n+    private final static Random RND = new Random();\n+\n+    private static void test(boolean skipCR, boolean closeBeforeCheckpoint) throws Exception {\n+\n+        int nThreads = 20;\n+\n+        AtomicInteger nSelected = new AtomicInteger(0);\n+\n+        Selector selector = Selector.open();\n+\n+        Thread selectThreads[] = new Thread[nThreads];\n+\n+        Runnable rStart = new Runnable() {\n+            @Override\n+            public void run() {\n+\n+                for (int i = 0; i < nThreads; ++i) {\n+\n+                    selectThreads[i] = new Thread(new Runnable() {\n+                        @Override\n+                        public void run() {\n+                            try {\n+                                boolean timeout = RND.nextBoolean();\n+                                int n = nSelected.incrementAndGet();\n+                                System.out.println(\">> select\" + (timeout ? \" (t)\" : \"\") + \" \" + n);\n+                                if (timeout) { selector.select(10 + RND.nextInt(7_000)); }\n+                                else { selector.select(); }\n+                                nSelected.decrementAndGet();\n+                                System.out.println(\">> done\" + (timeout ? \" (t)\" : \"\") + \" \" + n);\n+                            } catch (ClosedSelectorException e) {\n+                                System.out.println(\">> ClosedSelectorException\"); \/\/ expected when the selector is closed\n+                                nSelected.decrementAndGet();\n+                            } catch (IOException e) {\n+                                throw new RuntimeException(e);\n+                            }\n+                        }\n+                    });\n+                    selectThreads[i].start();\n+                    try { Thread.sleep(50); } catch (InterruptedException ie) {}\n+                }\n+            }\n+        };\n+        Thread tStart = new Thread(rStart);\n+        tStart.start();\n+        Thread.sleep(500);\n+\n+        if (closeBeforeCheckpoint) {\n+            tStart.join();\n+            Thread.sleep(1000);\n+            selector.close();\n+        }\n+\n+        if (!skipCR) {\n+            jdk.crac.Core.checkpointRestore();\n+        }\n+\n+        if (!closeBeforeCheckpoint) {\n+            tStart.join();\n+            Thread.sleep(1000);\n+            selector.close();\n+        }\n+\n+        do { Thread.sleep(2000); } while (nSelected.get() > 0);\n+\n+        if (nSelected.get() < 0) { throw new RuntimeException(\"negative nSelected??\"); }\n+\n+        \/\/ just in case...\n+        for (Thread t: selectThreads) { t.join(); }\n+    }\n+\n+\n+\n+    public static void main(String args[]) throws Exception {\n+\n+        if (args.length < 1) { throw new RuntimeException(\"test number is missing\"); }\n+\n+        switch (args[0]) {\n+            case \"1\":\n+                test(false, false);\n+                break;\n+            case \"2\":\n+                test(false, true);\n+                break;\n+            case \"3\":\n+                test(true, true);\n+                break;\n+            default:\n+                throw new RuntimeException(\"invalid test number\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/Selector\/multipleSelectSingleClose\/Test.java","additions":122,"deletions":0,"binary":false,"changes":122,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+#!\/bin\/sh\n+\n+# Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it under\n+# the terms of the GNU General Public License version 2 only, as published by\n+# the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT ANY\n+# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n+# A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n+# details (a copy is included in the LICENSE file that accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version 2\n+# along with this work; if not, write to the Free Software Foundation, Inc.,\n+# 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n+# CA 94089 USA or visit www.azul.com if you need additional information or\n+# have any questions.\n+\n+\n+##\n+## @test Test.sh\n+## @summary check a coexistence of multiple select() + C\/R in case when the selector is finally closed\n+## @compile Test.java\n+## @run shell\/timeout=120 Test.sh\n+##\n+\n+set -x\n+\n+for test in `seq 1 2`\n+do\n+\n+    IMGDIR=\"cr$test\"\n+\n+    set +e\n+    ${TESTJAVA}\/bin\/java -cp ${TESTCLASSPATH} -XX:CRaCCheckpointTo=$IMGDIR Test $test\n+    e=$?\n+\n+    set -e\n+    [ $e -eq 137 ]\n+\n+    ${TESTJAVA}\/bin\/java -XX:CRaCRestoreFrom=$IMGDIR Test\n+\n+    echo \"PASSED $test\"\n+\n+done\n+\n+\n+# check conformity (no C\/R)\n+\n+set -e\n+\n+${TESTJAVA}\/bin\/java -cp ${TESTCLASSPATH} Test 3\n+echo \"PASSED 3\"\n","filename":"test\/jdk\/jdk\/crac\/Selector\/multipleSelectSingleClose\/Test.sh","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,80 @@\n+\/\/ Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it under\n+\/\/ the terms of the GNU General Public License version 2 only, as published by\n+\/\/ the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n+\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n+\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n+\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version 2\n+\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n+\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n+\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n+\/\/ have any questions.\n+\n+\n+import java.nio.channels.Selector;\n+\n+\n+public class Test {\n+\n+    private static void test(boolean wakeupBeforeCheckpoint,\n+                             boolean wakeupAfterRestore,\n+                             boolean setSelectTimeout) throws Exception {\n+\n+        Selector selector = Selector.open();\n+\n+        \/\/ do this just in case\n+        selector.wakeup();\n+        selector.select();\n+\n+        if (wakeupBeforeCheckpoint) {\n+            selector.wakeup();\n+        }\n+\n+        jdk.crac.Core.checkpointRestore();\n+\n+        if (wakeupAfterRestore) {\n+            selector.wakeup();\n+        }\n+        if (setSelectTimeout) { selector.select(3600_000); }\n+        else { selector.select(); }\n+\n+        selector.close();\n+    }\n+\n+    public static void main(String args[]) throws Exception {\n+\n+        if (args.length < 1) { throw new RuntimeException(\"test number is missing\"); }\n+\n+        switch (args[0]) {\n+            case \"1\":\n+                test(true, false, false); \/\/ ZE-983\n+                break;\n+            case \"2\":\n+                test(true, false, true);\n+                break;\n+            case \"3\":\n+                test(true, true, false); \/\/ ZE-983\n+                break;\n+            case \"4\":\n+                test(true, true, true);\n+                break;\n+            case \"5\":\n+                test(false, true, false);\n+                break;\n+            case \"6\":\n+                test(false, true, true);\n+                break;\n+\n+            default:\n+                throw new RuntimeException(\"invalid test number\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/Selector\/selectAfterWakeup\/Test.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+#!\/bin\/sh\n+\n+# Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it under\n+# the terms of the GNU General Public License version 2 only, as published by\n+# the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT ANY\n+# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n+# A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n+# details (a copy is included in the LICENSE file that accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version 2\n+# along with this work; if not, write to the Free Software Foundation, Inc.,\n+# 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n+# CA 94089 USA or visit www.azul.com if you need additional information or\n+# have any questions.\n+\n+\n+##\n+## @test Test.sh\n+## @summary check that the Selector's wakeup() makes the subsequent select() call to return immediately\n+##          (see also jdk\/test\/java\/nio\/channels\/Selector\/WakeupSpeed.java);\n+##          covers ZE-983\n+## @compile Test.java\n+## @run shell\/timeout=120 Test.sh\n+##\n+\n+set -x\n+\n+for test in `seq 1 6`\n+do\n+\n+    IMGDIR=\"cr$test\"\n+\n+    set +e\n+    ${TESTJAVA}\/bin\/java -cp ${TESTCLASSPATH} -XX:CRaCCheckpointTo=$IMGDIR Test $test\n+    e=$?\n+\n+    set -e\n+    [ $e -eq 137 ]\n+\n+    ${TESTJAVA}\/bin\/java -XX:CRaCRestoreFrom=$IMGDIR Test\n+\n+    echo \"PASSED $test\"\n+\n+done\n","filename":"test\/jdk\/jdk\/crac\/Selector\/selectAfterWakeup\/Test.sh","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/\/ Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it under\n+\/\/ the terms of the GNU General Public License version 2 only, as published by\n+\/\/ the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n+\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n+\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n+\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version 2\n+\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n+\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n+\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n+\/\/ have any questions.\n+\n+\n+import java.nio.channels.Selector;\n+\n+public class Test {\n+\n+    private static void selectAndWakeup(Selector selector) throws java.io.IOException {\n+\n+        new Thread(new Runnable() {\n+            @Override\n+            public void run() {\n+                try {\n+                    Thread.sleep(7000);\n+                    System.out.println(\">> waking up\");\n+                    selector.wakeup();\n+                } catch (InterruptedException ie) { throw new RuntimeException(ie); }\n+            }\n+        }).start();\n+\n+        System.out.println(\">> selecting\");\n+        selector.select();\n+    }\n+\n+    public static void main(String args[]) throws Exception {\n+\n+        Selector selector = Selector.open();\n+\n+        selectAndWakeup(selector); \/\/ just in case\n+\n+        jdk.crac.Core.checkpointRestore();\n+\n+        selectAndWakeup(selector);\n+\n+        selector.close();\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/Selector\/selectAndWakeupAfterRestore\/Test.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+#!\/bin\/sh\n+\n+# Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it under\n+# the terms of the GNU General Public License version 2 only, as published by\n+# the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT ANY\n+# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n+# A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n+# details (a copy is included in the LICENSE file that accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version 2\n+# along with this work; if not, write to the Free Software Foundation, Inc.,\n+# 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n+# CA 94089 USA or visit www.azul.com if you need additional information or\n+# have any questions.\n+\n+\n+##\n+## @test Test.sh\n+## @summary a trivial check that Selector.wakeup() after restore behaves as expected\n+## @compile Test.java\n+## @run shell\/timeout=60 Test.sh\n+##\n+\n+set -x\n+\n+set +e\n+${TESTJAVA}\/bin\/java -cp ${TESTCLASSPATH} -XX:CRaCCheckpointTo=cr Test\n+e=$?\n+\n+set -e\n+[ $e -eq 137 ]\n+\n+${TESTJAVA}\/bin\/java -XX:CRaCRestoreFrom=cr Test\n+\n+echo PASSED\n","filename":"test\/jdk\/jdk\/crac\/Selector\/selectAndWakeupAfterRestore\/Test.sh","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,89 @@\n+\/\/ Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it under\n+\/\/ the terms of the GNU General Public License version 2 only, as published by\n+\/\/ the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n+\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n+\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n+\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version 2\n+\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n+\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n+\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n+\/\/ have any questions.\n+\n+\n+import java.nio.channels.Selector;\n+import java.io.IOException;\n+\n+public class Test {\n+\n+    private final static long TIMEOUT = 3600_000; \/\/ looong timeout\n+\n+    static boolean awakened;\n+\n+    private static void test(boolean setTimeout) throws Exception {\n+\n+        Selector selector = Selector.open();\n+        Runnable r = new Runnable() {\n+            @Override\n+            public void run() {\n+                System.out.println(\">> select, setTimeout = \" + setTimeout);\n+                try {\n+                    awakened = false;\n+                    if (setTimeout) { selector.select(TIMEOUT); }\n+                    else { selector.select(); }\n+                    awakened = true;\n+                } catch (IOException e) { throw new RuntimeException(e); }\n+            }\n+        };\n+        Thread t = new Thread(r);\n+        t.start();\n+        Thread.sleep(1000);\n+\n+        jdk.crac.Core.checkpointRestore();\n+\n+        System.out.print(\">> waking up: \");\n+        selector.wakeup();\n+        t.join();\n+        System.out.println(\"done\");\n+\n+        if (!awakened) { throw new RuntimeException(\"not awakened!\"); }\n+\n+        \/\/ check that the selector works as expected\n+\n+        if (!selector.isOpen()) { throw new RuntimeException(\"the selector must be open\"); }\n+\n+        selector.wakeup();\n+        selector.select();\n+\n+        selector.selectNow();\n+        selector.select(200);\n+        selector.close();\n+    }\n+\n+\n+\n+\n+    public static void main(String args[]) throws Exception {\n+\n+        if (args.length < 1) { throw new RuntimeException(\"test number is missing\"); }\n+\n+        switch (args[0]) {\n+            case \"1\":\n+                test(true);\n+                break;\n+            case \"2\":\n+                test(false);\n+                break;\n+            default:\n+                throw new RuntimeException(\"invalid test number\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/Selector\/wakeupAfterRestore\/Test.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+#!\/bin\/sh\n+\n+# Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it under\n+# the terms of the GNU General Public License version 2 only, as published by\n+# the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT ANY\n+# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n+# A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n+# details (a copy is included in the LICENSE file that accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version 2\n+# along with this work; if not, write to the Free Software Foundation, Inc.,\n+# 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n+# CA 94089 USA or visit www.azul.com if you need additional information or\n+# have any questions.\n+\n+\n+##\n+## @test Test.sh\n+## @summary check that the thread blocked by Selector.select() on checkpoint could be properly woken up after restore\n+## @compile Test.java\n+## @run shell\/timeout=120 Test.sh\n+##\n+\n+set -x\n+\n+for test in `seq 1 2`\n+do\n+\n+    IMGDIR=\"cr$test\"\n+\n+    set +e\n+    ${TESTJAVA}\/bin\/java -cp ${TESTCLASSPATH} -XX:CRaCCheckpointTo=$IMGDIR Test $test\n+    e=$?\n+\n+    set -e\n+    [ $e -eq 137 ]\n+\n+    ${TESTJAVA}\/bin\/java -XX:CRaCRestoreFrom=$IMGDIR Test\n+\n+    echo \"PASSED $test\"\n+\n+done\n","filename":"test\/jdk\/jdk\/crac\/Selector\/wakeupAfterRestore\/Test.sh","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,99 @@\n+\/\/ Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it under\n+\/\/ the terms of the GNU General Public License version 2 only, as published by\n+\/\/ the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n+\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n+\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n+\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version 2\n+\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n+\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n+\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n+\/\/ have any questions.\n+\n+\n+import java.nio.channels.Selector;\n+import java.io.IOException;\n+\n+public class Test {\n+\n+    static boolean awakened, closed;\n+\n+    private static void test(boolean setTimeout, boolean skipCR) throws Exception {\n+\n+        Selector selector = Selector.open();\n+\n+        Thread tSelect = new Thread(new Runnable() {\n+                @Override\n+                public void run() {\n+                    try {\n+                        awakened = false;\n+                        if (setTimeout) { selector.select(3600_000); }\n+                        else { selector.select(); }\n+                        awakened = true;\n+                    } catch (IOException e) { throw new RuntimeException(e); }\n+                }\n+            });\n+        tSelect.start();\n+\n+        Thread.sleep(3000);\n+\n+        if (!skipCR) { jdk.crac.Core.checkpointRestore(); }\n+\n+        \/\/ close() must wakeup the selector\n+        Thread tClose = new Thread(new Runnable() {\n+\n+                @Override\n+                public void run() {\n+                    try {\n+                        closed = false;\n+                        selector.close();\n+                        closed = true;\n+                    } catch (IOException e) { throw new RuntimeException(e); }\n+                }\n+            });\n+        tClose.start();\n+        tClose.join();\n+        tSelect.join();\n+\n+        if (!awakened) {\n+            selector.wakeup();\n+            throw new RuntimeException(\"selector did not wake up\");\n+        }\n+\n+        if (!closed) {\n+            selector.close();\n+            throw new RuntimeException(\"selector did not close\");\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+\n+       if (args.length < 1) { throw new RuntimeException(\"test number is missing\"); }\n+\n+        switch (args[0]) {\n+            case \"1\":\n+                test(true, false);\n+                break;\n+            case \"2\":\n+                test(false, false);\n+                break;\n+            \/\/ 3, 4: skip C\/R\n+            case \"3\":\n+                test(true, true);\n+                break;\n+            case \"4\":\n+                test(false, true);\n+                break;\n+            default:\n+                throw new RuntimeException(\"invalid test number\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/Selector\/wakeupByClose\/Test.java","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+#!\/bin\/sh\n+\n+# Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it under\n+# the terms of the GNU General Public License version 2 only, as published by\n+# the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT ANY\n+# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n+# A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n+# details (a copy is included in the LICENSE file that accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version 2\n+# along with this work; if not, write to the Free Software Foundation, Inc.,\n+# 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n+# CA 94089 USA or visit www.azul.com if you need additional information or\n+# have any questions.\n+\n+\n+##\n+## @test Test.sh\n+## @summary check that the Selector's close() wakes it up after restore\n+## @compile Test.java\n+## @run shell\/timeout=60 Test.sh\n+##\n+\n+\n+set -x\n+\n+for test in `seq 1 2`\n+do\n+\n+    IMGDIR=\"cr$test\"\n+\n+    set +e\n+    ${TESTJAVA}\/bin\/java -cp ${TESTCLASSPATH} -XX:CRaCCheckpointTo=$IMGDIR Test $test\n+    e=$?\n+\n+    set -e\n+    [ $e -eq 137 ]\n+\n+    ${TESTJAVA}\/bin\/java -XX:CRaCRestoreFrom=$IMGDIR Test\n+\n+    echo \"PASSED $test\"\n+\n+done\n+\n+\n+${TESTJAVA}\/bin\/java -cp ${TESTCLASSPATH} Test 3\n+echo \"PASSED 3\"\n+\n+${TESTJAVA}\/bin\/java -cp ${TESTCLASSPATH} Test 4\n+echo \"PASSED 4\"\n","filename":"test\/jdk\/jdk\/crac\/Selector\/wakeupByClose\/Test.sh","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/\/ Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it under\n+\/\/ the terms of the GNU General Public License version 2 only, as published by\n+\/\/ the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n+\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n+\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n+\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version 2\n+\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n+\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n+\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n+\/\/ have any questions.\n+\n+\n+import java.nio.channels.Selector;\n+import java.io.IOException;\n+\n+public class Test {\n+\n+    private final static long TIMEOUT = 40_000; \/\/ 40 seconds\n+\n+    static boolean awakened = false;\n+\n+    public static void main(String args[]) throws Exception {\n+\n+        Selector selector = Selector.open();\n+        Runnable r = new Runnable() {\n+            @Override\n+            public void run() {\n+                try {\n+                    selector.select(TIMEOUT);\n+                    awakened = true;\n+                } catch (IOException e) { throw new RuntimeException(e); }\n+            }\n+        };\n+        Thread t = new Thread(r);\n+        t.start();\n+        Thread.sleep(1000);\n+\n+        jdk.crac.Core.checkpointRestore();\n+\n+        t.join();\n+        if (!awakened) { throw new RuntimeException(\"not awakened!\"); }\n+\n+        \/\/ check that the selector works as expected\n+\n+        if (!selector.isOpen()) { throw new RuntimeException(\"the selector must be open\"); }\n+\n+        selector.wakeup();\n+        selector.select();\n+\n+        selector.selectNow();\n+        selector.select(200);\n+        selector.close();\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/Selector\/wakeupByTimeoutAfterRestore\/Test.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+#!\/bin\/sh\n+\n+# Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it under\n+# the terms of the GNU General Public License version 2 only, as published by\n+# the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT ANY\n+# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n+# A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n+# details (a copy is included in the LICENSE file that accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version 2\n+# along with this work; if not, write to the Free Software Foundation, Inc.,\n+# 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n+# CA 94089 USA or visit www.azul.com if you need additional information or\n+# have any questions.\n+\n+\n+##\n+## @test Test.sh\n+## @summary check that the Selector selected before the checkpoint,\n+##          will wake up by timeout after the restore\n+## @compile Test.java\n+## @run shell\/timeout=120 Test.sh\n+##\n+\n+set -x\n+\n+set +e\n+${TESTJAVA}\/bin\/java -cp ${TESTCLASSPATH} -XX:CRaCCheckpointTo=cr Test\n+e=$?\n+\n+set -e\n+[ $e -eq 137 ]\n+\n+${TESTJAVA}\/bin\/java -XX:CRaCRestoreFrom=cr Test\n+\n+echo PASSED\n","filename":"test\/jdk\/jdk\/crac\/Selector\/wakeupByTimeoutAfterRestore\/Test.sh","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"}]}