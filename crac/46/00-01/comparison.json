{"files":[{"patch":"@@ -117,2 +117,2 @@\n-        if (!status) {\n-            status = st;\n+        if (!status && 0 < pid && WIFEXITED(st)) {\n+            status = WEXITSTATUS(st);\n@@ -120,1 +120,1 @@\n-    } while (!(-1 == pid && ECHILD == errno));\n+    } while (-1 != pid || ECHILD != errno);\n@@ -124,0 +124,30 @@\n+static pid_t g_child_pid = -1;\n+\n+static void sighandler(int sig, siginfo_t *info, void *param) {\n+    if (0 < g_child_pid) {\n+        kill(g_child_pid, sig);\n+    }\n+}\n+\n+static void setup_sighandler() {\n+    struct sigaction sigact;\n+    sigfillset(&sigact.sa_mask);\n+    sigact.sa_flags = SA_SIGINFO;\n+    sigact.sa_sigaction = sighandler;\n+\n+    for (int sig = 1; sig < __SIGRTMIN; ++sig) {\n+        if (sig == SIGKILL || sig == SIGSTOP) {\n+            continue;\n+        }\n+        if (-1 == sigaction(sig, &sigact, NULL)) {\n+            perror(\"sigaction\");\n+        }\n+    }\n+\n+    sigset_t allset;\n+    sigfillset(&allset);\n+    if (-1 == sigprocmask(SIG_UNBLOCK, &allset, NULL)) {\n+        perror(\"sigprocmask\");\n+    }\n+}\n+\n@@ -235,0 +265,2 @@\n+    \/\/ Avoid unexpected process completion when checkpointing under docker container run\n+    \/\/ by creating the main process waiting for children before exit.\n@@ -236,1 +268,4 @@\n-        if (0 < fork()) {\n+        g_child_pid = fork();\n+        if (0 < g_child_pid) {\n+            \/\/ The main process should forward signals to the child.\n+            setup_sighandler();\n","filename":"src\/java.base\/share\/native\/launcher\/main.c","additions":39,"deletions":4,"binary":false,"changes":43,"status":"modified"}]}