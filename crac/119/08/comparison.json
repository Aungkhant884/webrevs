{"files":[{"patch":"@@ -344,1 +344,1 @@\n-  return PerfMemoryLinux::checkpoint(CRaCCheckpointTo);\n+  return PerfMemoryLinux::checkpoint();\n","filename":"src\/hotspot\/os\/linux\/crac_linux.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,5 +33,1 @@\n-  static inline const char* perfdata_name() {\n-    return \"perfdata\";\n-  }\n-\n-  static bool checkpoint(const char* checkpoint_path);\n+  static bool checkpoint();\n","filename":"src\/hotspot\/os\/linux\/perfMemory_linux.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -66,1 +66,0 @@\n-static int checkpoint_fd = -1;\n@@ -1352,3 +1351,1 @@\n-bool PerfMemoryLinux::checkpoint(const char* checkpoint_path) {\n-  assert(checkpoint_path, \"should be set\");\n-\n+bool PerfMemoryLinux::checkpoint() {\n@@ -1359,6 +1356,3 @@\n-  char path[JVM_MAXPATHLEN];\n-  int pathlen = snprintf(path, sizeof(path),\"%s\/%s\", checkpoint_path, perfdata_name());\n-\n-  RESTARTABLE(::open(path, O_RDWR|O_CREAT|O_NOFOLLOW, S_IRUSR|S_IWUSR), checkpoint_fd);\n-  if (checkpoint_fd < 0) {\n-    tty->print_cr(\"cannot open checkpoint perfdata: %s\", os::strerror(errno));\n+  void *anon = ::mmap(nullptr, PerfMemory::capacity(), PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n+  if (anon == MAP_FAILED) {\n+    tty->print_cr(\"Cannot allocate new memory for perfdata: %s\", os::strerror(errno));\n@@ -1367,11 +1361,7 @@\n-\n-  char* p = PerfMemory::start();\n-  size_t len = PerfMemory::capacity();\n-  do {\n-    int result;\n-    RESTARTABLE(::write(checkpoint_fd, p, len), result);\n-    if (result == OS_ERR) {\n-      tty->print_cr(\"cannot write data to checkpoint perfdata file: %s\", os::strerror(errno));\n-      ::close(checkpoint_fd);\n-      checkpoint_fd = -1;\n-      return false;\n+  \/\/ Note: we might be losing updates that happen between this copy and mremap\n+  \/\/ TODO: consider acquiring PeriodicTask_lock around this\n+  memcpy(anon, PerfMemory::start(), PerfMemory::used());\n+  if (mremap(anon, PerfMemory::capacity(), PerfMemory::capacity(), MREMAP_FIXED | MREMAP_MAYMOVE, PerfMemory::start()) == MAP_FAILED) {\n+    tty->print_cr(\"Cannot remap perfdata memory as anonymous: %s\", os::strerror(errno));\n+    if (munmap(anon, PerfMemory::capacity())) {\n+      tty->print_cr(\"Cannot unmap unused private perfdata memory: %s\", os::strerror(errno));\n@@ -1379,10 +1369,0 @@\n-    p += result;\n-    len -= (size_t)result;\n-  } while (0 < len);\n-\n-  void* mmapret = ::mmap(PerfMemory::start(), PerfMemory::capacity(),\n-      PROT_READ|PROT_WRITE, MAP_FIXED|MAP_SHARED, checkpoint_fd, 0);\n-  if (MAP_FAILED == mmapret) {\n-    tty->print_cr(\"cannot mmap checkpoint perfdata file: %s\", os::strerror(errno));\n-    ::close(checkpoint_fd);\n-    checkpoint_fd = -1;\n@@ -1398,4 +1378,0 @@\n-  if (checkpoint_fd < 0) {\n-    return true;\n-  }\n-\n@@ -1412,7 +1388,1 @@\n-    tty->print_cr(\"cannot open restore perfdata file: %s\", os::strerror(errno));\n-\n-    void* mmapret = ::mmap(PerfMemory::start(), PerfMemory::capacity(),\n-        PROT_READ|PROT_WRITE, MAP_FIXED|MAP_PRIVATE, checkpoint_fd, 0);\n-    if (MAP_FAILED == mmapret) {\n-      tty->print_cr(\"cannot remap checkpoint perfdata file: %s\", os::strerror(errno));\n-    }\n+    tty->print_cr(\"Cannot open shared perfdata file: %s\", os::strerror(errno));\n@@ -1422,18 +1392,2 @@\n-  char* p = PerfMemory::start();\n-  size_t len = PerfMemory::capacity();\n-  do {\n-    int result;\n-    RESTARTABLE(::write(fd, p, len), result);\n-    if (result == OS_ERR) {\n-      tty->print_cr(\"cannot write data to restore perfdata file: %s\", os::strerror(errno));\n-      ::close(fd);\n-      return false;\n-    }\n-    p += result;\n-    len -= (size_t)result;\n-  } while (0 < len);\n-\n-  void* mmapret = ::mmap(PerfMemory::start(), PerfMemory::capacity(),\n-      PROT_READ|PROT_WRITE, MAP_FIXED|MAP_SHARED, fd, 0);\n-  if (MAP_FAILED == mmapret) {\n-    tty->print_cr(\"cannot mmap restore perfdata file: %s\", os::strerror(errno));\n+  if (::ftruncate(fd, PerfMemory::capacity())) {\n+    tty->print_cr(\"Cannot restore (ftruncate) perfdata file size: %s\", os::strerror(errno));\n@@ -1444,0 +1398,6 @@\n+  void* shared = ::mmap(nullptr, PerfMemory::capacity(), PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);\n+  if (MAP_FAILED == shared) {\n+    tty->print_cr(\"cannot mmap shared perfdata file: %s\", os::strerror(errno));\n+    ::close(fd);\n+    return false;\n+  }\n@@ -1445,2 +1405,11 @@\n-  ::close(checkpoint_fd);\n-  checkpoint_fd = -1;\n+\n+  \/\/ Here is another place where we might lose the update\n+  memcpy(shared, PerfMemory::start(), PerfMemory::used());\n+  if (::mremap(shared, PerfMemory::capacity(), PerfMemory::capacity(), MREMAP_FIXED | MREMAP_MAYMOVE, PerfMemory::start()) == MAP_FAILED) {\n+    tty->print_cr(\"Cannot remap shared perfdata: %s\", os::strerror(errno));\n+    if (munmap(shared, PerfMemory::capacity())) {\n+      tty->print_cr(\"Cannot unmap the shared memory: %s\", os::strerror(errno));\n+    }\n+    return false;\n+  }\n+\n","filename":"src\/hotspot\/os\/posix\/perfMemory_posix.cpp","additions":31,"deletions":62,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -50,2 +50,0 @@\n-static int create_cppath(const char *imagedir);\n-\n@@ -221,1 +219,0 @@\n-    create_cppath(imagedir);\n@@ -229,42 +226,0 @@\n-    char *cppathpath;\n-    if (-1 == asprintf(&cppathpath, \"%s\/cppath\", imagedir)) {\n-        return 1;\n-    }\n-\n-    int fd = open(cppathpath, O_RDONLY);\n-    if (fd < 0) {\n-        fprintf(stderr, \"CRaC restore - cannot open cppath file \\\"%s\\\": %s\\n\", path_abs(cppathpath), strerror(errno));\n-        return 1;\n-    }\n-\n-    char cppath[PATH_MAX];\n-    int cppathlen = 0;\n-    int r;\n-    while ((r = read(fd, cppath + cppathlen, sizeof(cppath) - cppathlen - 1)) != 0) {\n-        if (r < 0 && errno == EINTR) {\n-            continue;\n-        }\n-        if (r < 0) {\n-            perror(\"read cppath\");\n-            return 1;\n-        }\n-        cppathlen += r;\n-    }\n-    cppath[cppathlen] = '\\0';\n-\n-    close(fd);\n-\n-    char *inherit_perfdata = NULL;\n-    char *perfdatapath;\n-    if (-1 == asprintf(&perfdatapath, \"%s\/\" PERFDATA_NAME, imagedir)) {\n-        return 1;\n-    }\n-    int perfdatafd = open(perfdatapath, O_RDWR);\n-    if (0 < perfdatafd) {\n-        if (-1 == asprintf(&inherit_perfdata, \"fd[%d]:%s\/\" PERFDATA_NAME,\n-                    perfdatafd,\n-                    cppath[0] == '\/' ? cppath + 1 : cppath)) {\n-            return 1;\n-        }\n-    }\n-\n@@ -287,4 +242,0 @@\n-    if (inherit_perfdata) {\n-        *arg++ = \"--inherit-fd\";\n-        *arg++ = inherit_perfdata;\n-    }\n@@ -332,27 +283,0 @@\n-static int create_cppath(const char *imagedir) {\n-    char realdir[PATH_MAX];\n-\n-    if (!realpath(imagedir, realdir)) {\n-        fprintf(stderr, MSGPREFIX \"cannot canonicalize %s: %s\\n\", imagedir, strerror(errno));\n-        return 1;\n-    }\n-\n-    int dirfd = open(realdir, O_DIRECTORY);\n-    if (dirfd < 0) {\n-        fprintf(stderr, MSGPREFIX \"can not open image dir %s: %s\\n\", realdir, strerror(errno));\n-        return 1;\n-    }\n-\n-    int fd = openat(dirfd, \"cppath\", O_CREAT | O_WRONLY | O_TRUNC, 0644);\n-    if (fd < 0) {\n-        fprintf(stderr, MSGPREFIX \"can not open file %s\/cppath: %s\\n\", realdir, strerror(errno));\n-        return 1;\n-    }\n-\n-    if (write(fd, realdir, strlen(realdir)) < 0) {\n-        fprintf(stderr, MSGPREFIX \"can not write %s\/cppath: %s\\n\", realdir, strerror(errno));\n-        return 1;\n-    }\n-    return 0;\n-}\n-\n","filename":"src\/java.base\/unix\/native\/criuengine\/criuengine.c","additions":0,"deletions":76,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -0,0 +1,102 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.*;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracProcess;\n+import jdk.test.lib.crac.CracTest;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.concurrent.TimeUnit;\n+\n+import static jdk.test.lib.Asserts.*;\n+\n+\/**\n+ * @test ContextOrderTest\n+ * @requires os.family == \"linux\"\n+ * @library \/test\/lib\n+ * @build PerfMemoryRestoreTest\n+ * @run driver\/timeout=30 jdk.test.lib.crac.CracTest\n+ *\/\n+\n+public class PerfMemoryRestoreTest implements CracTest {\n+    @Override\n+    public void test() throws Exception {\n+        CracBuilder builder = new CracBuilder();\n+        CracProcess checkpoint = builder.startCheckpoint();\n+        String pid = String.valueOf(checkpoint.pid());\n+        \/\/ This test is run only on Linux where the path is hardcoded\n+        \/\/ in os::get_temp_directory() to \/tmp rather than using System.getProperty(\"java.io.tmpdir\")\n+        Path perfdata = Path.of(\"\/tmp\", \"hsperfdata_\" + System.getProperty(\"user.name\"), pid);\n+        long start = System.nanoTime();\n+        while (!perfdata.toFile().exists()) {\n+            if (System.nanoTime() - start > TimeUnit.SECONDS.toNanos(10)) {\n+                throw new IllegalStateException(\"Perf data file did not appear within time limit in the checkpointed process: \" + perfdata);\n+            }\n+            \/\/noinspection BusyWait\n+            Thread.sleep(10);\n+        }\n+        checkMapped(pid, perfdata.toString());\n+\n+        checkpoint.input().write('\\n');\n+        checkpoint.input().flush();\n+        checkpoint.waitForCheckpointed();\n+        assertFalse(perfdata.toFile().exists());\n+\n+        CracProcess restored = builder.startRestore();\n+        start = System.nanoTime();\n+        while (!perfdata.toFile().exists()) {\n+            if (System.nanoTime() - start > TimeUnit.SECONDS.toNanos(10)) {\n+                throw new IllegalStateException(\"Perf data file did not appear within time limit in the restored process: \" + perfdata);\n+            }\n+            \/\/noinspection BusyWait\n+            Thread.sleep(10);\n+        }\n+        \/\/ Note: we need to check the checkpoint.pid(), which should be restored (when using CRIU),\n+        \/\/ as restored.pid() would be the criuengine restorewait process\n+        String pidString = String.valueOf(checkpoint.pid());\n+        checkMapped(pidString, perfdata.toString());\n+        builder.runJcmd(pidString, \"PerfCounter.print\")\n+                .shouldHaveExitValue(0)\n+                .shouldContain(\"sun.perfdata.size=\");\n+        restored.input().write('\\n');\n+        restored.input().flush();\n+        restored.waitForSuccess();\n+    }\n+\n+    private static void checkMapped(String pid, String perfdata) throws IOException {\n+        String perfdataLine = Files.readAllLines(Path.of(\"\/proc\", pid, \"maps\")).stream()\n+                .filter(line -> line.contains(perfdata))\n+                .findFirst().orElseThrow(() -> new AssertionError(\"Missing \" + perfdata + \" in process maps\"));\n+        assertTrue(perfdataLine.contains(\"rw-s 00000000\"), perfdataLine);\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        assertEquals(System.in.read(), (int) '\\n');\n+        Core.checkpointRestore();\n+        assertEquals(System.in.read(), (int) '\\n');\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/PerfMemoryRestoreTest.java","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"},{"patch":"@@ -7,0 +7,1 @@\n+import jdk.test.lib.process.OutputAnalyzer;\n@@ -484,0 +485,4 @@\n+        runJcmd(main().getName(), \"JDK.checkpoint\").shouldHaveExitValue(0);\n+    }\n+\n+    public OutputAnalyzer runJcmd(String id, String... command) throws Exception {\n@@ -490,1 +495,2 @@\n-        cmd.addAll(Arrays.asList(main().getName(), \"JDK.checkpoint\"));\n+        cmd.add(id);\n+        cmd.addAll(Arrays.asList(command));\n@@ -492,1 +498,1 @@\n-        DockerTestUtils.execute(cmd).shouldHaveExitValue(0);\n+        return DockerTestUtils.execute(cmd);\n","filename":"test\/lib\/jdk\/test\/lib\/crac\/CracBuilder.java","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -8,0 +8,1 @@\n+import java.io.OutputStream;\n@@ -23,1 +24,1 @@\n-        ProcessBuilder pb = new ProcessBuilder().inheritIO();\n+        ProcessBuilder pb = new ProcessBuilder().inheritIO().redirectInput(ProcessBuilder.Redirect.PIPE);\n@@ -131,0 +132,8 @@\n+\n+    public long pid() {\n+        return process.pid();\n+    }\n+\n+    public OutputStream input() {\n+        return process.getOutputStream();\n+    }\n","filename":"test\/lib\/jdk\/test\/lib\/crac\/CracProcess.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"}]}