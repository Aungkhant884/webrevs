{"files":[{"patch":"@@ -36,2 +36,0 @@\n-JVM_RegisterPersistent\n-JVM_DeregisterPersistent\n","filename":"make\/data\/hotspot-symbols\/symbols-shared","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,0 +57,2 @@\n+#include \"runtime\/jniHandles.hpp\"\n+#include \"runtime\/jniHandles.inline.hpp\"\n@@ -178,4 +180,1 @@\n-    M_ZIP_CACHE    = 1 << 0,\n-    M_CANT_RESTORE = 1 << 1,\n-    M_CLASSPATH    = 1 << 2,\n-    M_PERSISTENT   = 1 << 3,\n+    M_CANT_RESTORE = 1 << 0,\n@@ -260,15 +259,0 @@\n-struct PersistentResourceDesc {\n-  int _fd;\n-  dev_t _st_dev;\n-  ino_t _st_ino;\n-  PersistentResourceDesc(int fd, int st_dev, int st_ino) :\n-    _fd(fd),\n-    _st_dev((dev_t)st_dev),\n-    _st_ino((ino_t)st_ino)\n-  {}\n-\n-  PersistentResourceDesc() :\n-    _fd(INT_MAX)\n-  {}\n-};\n-\n@@ -389,0 +373,1 @@\n+  jarray _fd_arr;\n@@ -397,1 +382,2 @@\n-  VM_Crac(bool dry_run, bufferedStream* jcmd_stream) :\n+  VM_Crac(jarray fd_arr, jobjectArray obj_arr, bool dry_run, bufferedStream* jcmd_stream) :\n+    _fd_arr(fd_arr),\n@@ -420,0 +406,1 @@\n+  bool is_claimed_fd(int fd);\n@@ -456,1 +443,0 @@\n-static GrowableArray<PersistentResourceDesc>* _persistent_resources = NULL;\n@@ -5864,73 +5850,0 @@\n-static void mark_classpath_entry(FdsInfo *fds, char* cp) {\n-  struct stat st;\n-  if (-1 == stat(cp, &st)) {\n-    return;\n-  }\n-  for (int i = 0; i < fds->len(); ++i) {\n-    if (same_stat(&st, fds->get_stat(i))) {\n-      fds->mark(i, FdsInfo::M_CLASSPATH);\n-    }\n-  }\n-}\n-\n-static void do_classpaths(void (*fn)(FdsInfo*, char*), FdsInfo *fds, char* classpath) {\n-  assert(SafepointSynchronize::is_at_safepoint(),\n-      \"can't do nasty things with sysclasspath\");\n-  char *cp = classpath;\n-  char *n;\n-  while ((n = strchr(cp, ':'))) {\n-    *n = '\\0';\n-    fn(fds, cp);\n-    *n = ':';\n-    cp = n + 1;\n-  }\n-  mark_classpath_entry(fds, cp);\n-}\n-\n-\n-static void mark_all_in(FdsInfo *fds, char* dirpath) {\n-  DIR *dir = os::opendir(dirpath);\n-  if (!dir) {\n-    return;\n-  }\n-\n-  struct dirent* dent;\n-  while ((dent = os::readdir(dir))) {\n-    for (int i = 0; i < fds->len(); ++i) {\n-      if (fds->get_state(i) != FdsInfo::ROOT) {\n-        continue;\n-      }\n-      struct stat* fstat = fds->get_stat(i);\n-      if (dent->d_ino == fstat->st_ino) {\n-        fds->mark(i, FdsInfo::M_CLASSPATH);\n-      }\n-    }\n-  }\n-\n-  os::closedir(dir);\n-}\n-\n-static void mark_persistent(FdsInfo *fds) {\n-  if (!_persistent_resources) {\n-    return;\n-  }\n-\n-  for (int i = 0; i < _persistent_resources->length(); ++i) {\n-    PersistentResourceDesc* pr = _persistent_resources->adr_at(i);\n-    int fd = pr->_fd;\n-    if (fds->len() <= fd) {\n-      break;\n-    }\n-    if (fds->get_state(fd) != FdsInfo::ROOT) {\n-      continue;\n-    }\n-    struct stat* st = fds->get_stat(fd);\n-    if (st->st_dev == pr->_st_dev && st->st_ino == pr->_st_ino) {\n-      fds->mark(fd, FdsInfo::M_PERSISTENT);\n-    }\n-  }\n-\n-  delete _persistent_resources;\n-  _persistent_resources = NULL;\n-}\n-\n@@ -6094,66 +6007,0 @@\n-static bool find_sock_details(int sockino, const char* base, bool v6, char* buf, size_t sz) {\n-  char filename[16];\n-  snprintf(filename, sizeof(filename), \"\/proc\/net\/%s\", base);\n-  FILE* f = fopen(filename, \"r\");\n-  if (!f) {\n-    return false;\n-  }\n-  int r = fscanf(f, \"%*[^\\n]\");\n-  if (r) {} \/\/ suppress warn unused gcc diagnostic\n-\n-  char la[33], ra[33];\n-  int lp, rp;\n-  int ino;\n-  \/\/   sl  local_address         remote_address        st   tx_queue rx_queue tr tm->when retrnsmt   uid  timeout inode\n-  \/\/    0: 0100007F:08AE         00000000:0000         0A   00000000:00000000 00:00000000 00000000  1000        0 2988639\n-  \/\/  %4d: %08X%08X%08X%08X:%04X %08X%08X%08X%08X:%04X %02X %08X:%08X         %02X:%08lX  %08X       %5u      %8d %d\n-  bool eof;\n-  do {\n-    eof = EOF == fscanf(f, \"%*d: %[^:]:%X %[^:]:%X %*X %*X:%*X %*X:%*X %*X %*d %*d %d%*[^\\n]\\n\",\n-        la, &lp, ra, &rp, &ino);\n-  } while (ino != sockino && !eof);\n-  fclose(f);\n-\n-  if (ino != sockino) {\n-    return false;\n-  }\n-\n-  struct in6_addr a6l, a6r;\n-  struct in_addr a4l, a4r;\n-  if (v6) {\n-    for (int i = 0; i < 4; ++i) {\n-      sscanf(la + i * 8, \"%8\" PRIX32, a6l.s6_addr32 + i);\n-      sscanf(ra + i * 8, \"%8\" PRIX32, a6r.s6_addr32 + i);\n-    }\n-  } else {\n-    sscanf(la, \"%\" PRIX32, &a4l.s_addr);\n-    sscanf(ra, \"%\" PRIX32, &a4r.s_addr);\n-  }\n-\n-  int const af = v6 ? AF_INET6 : AF_INET;\n-  void* const laddr = v6 ? (void*)&a6l : (void*)&a4l;\n-  void* const raddr = v6 ? (void*)&a6r : (void*)&a4r;\n-  char lstrb[48], rstrb[48];\n-  const char* const lstr = ::inet_ntop(af, laddr, lstrb, sizeof(lstrb)) ? lstrb : \"NONE\";\n-  const char* const rstr = ::inet_ntop(af, raddr, rstrb, sizeof(rstrb)) ? rstrb : \"NONE\";\n-  int msgsz = snprintf(buf, sz, \"%s localAddr %s localPort %d remoteAddr %s remotePort %d\",\n-        base, lstr, lp, rstr, rp);\n-  return msgsz < (int)sz;\n-}\n-\n-static const char* sock_details(const char* details, char* buf, size_t sz) {\n-  int sockino;\n-  if (sscanf(details, \"socket:[%d]\", &sockino) <= 0) {\n-    return details;\n-  }\n-\n-  const char* bases[] = { \"tcp\", \"udp\", \"tcp6\", \"udp6\", NULL };\n-  for (const char** b = bases; *b; ++b) {\n-    if (find_sock_details(sockino, *b, 2 <= b - bases, buf, sz)) {\n-      return buf;\n-    }\n-  }\n-\n-  return details;\n-}\n-\n@@ -6189,0 +6036,11 @@\n+bool VM_Crac::is_claimed_fd(int fd) {\n+  typeArrayOop claimed_fds = typeArrayOop(JNIHandles::resolve_non_null(_fd_arr));\n+  for (int j = 0; j < claimed_fds->length(); ++j) {\n+    jint cfd = claimed_fds->int_at(j);\n+    if (fd == cfd) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n@@ -6194,4 +6052,0 @@\n-  do_classpaths(mark_classpath_entry, &fds, Arguments::get_sysclasspath());\n-  do_classpaths(mark_classpath_entry, &fds, Arguments::get_appclasspath());\n-  do_classpaths(mark_all_in, &fds, Arguments::get_ext_dirs());\n-  mark_persistent(&fds);\n@@ -6208,0 +6062,1 @@\n+    const char* type = stat2strtype(fds.get_stat(i)->st_mode);\n@@ -6210,17 +6065,1 @@\n-    print_resources(\"JVM: FD fd=%d type=%s: details1=\\\"%s\\\" \",\n-        i, stat2strtype(fds.get_stat(i)->st_mode), details);\n-\n-    if (_vm_inited_fds.get_state(i, FdsInfo::CLOSED) != FdsInfo::CLOSED) {\n-      print_resources(\"OK: inherited from process env\\n\");\n-      continue;\n-    }\n-\n-    struct stat* st = fds.get_stat(i);\n-    if (S_ISCHR(st->st_mode)) {\n-      const int mjr = major(st->st_rdev);\n-      const int mnr = minor(st->st_rdev);\n-      if (mjr == 1 && (mnr == 8 || mnr == 9)) {\n-        print_resources(\"OK: always available, random or urandom\\n\");\n-        continue;\n-      }\n-    }\n+    print_resources(\"JVM: FD fd=%d type=%s path=\\\"%s\\\"\", i, type, details);\n@@ -6228,2 +6067,2 @@\n-    if (fds.check(i, FdsInfo::M_CLASSPATH) && !fds.check(i, FdsInfo::M_CANT_RESTORE)) {\n-      print_resources(\"OK: in classpath\\n\");\n+    if (is_claimed_fd(i)) {\n+      print_resources(\"OK: claimed by java code\\n\");\n@@ -6233,2 +6072,2 @@\n-    if (fds.check(i, FdsInfo::M_PERSISTENT)) {\n-      print_resources(\"OK: assured persistent\\n\");\n+    if (_vm_inited_fds.get_state(i, FdsInfo::CLOSED) != FdsInfo::CLOSED) {\n+      print_resources(\"OK: inherited from process env\\n\");\n@@ -6238,0 +6077,1 @@\n+    struct stat* st = fds.get_stat(i);\n@@ -6243,2 +6083,0 @@\n-      details = sock_details(details, detailsbuf, sizeof(detailsbuf));\n-      print_resources(\" details2=\\\"%s\\\" \", details);\n@@ -6250,2 +6088,5 @@\n-    char* msg = NEW_C_HEAP_ARRAY(char, strlen(details) + 1, mtInternal);\n-    strcpy(msg, details);\n+    const int maxinfo = 64;\n+    size_t buflen = strlen(details) + maxinfo;\n+    char* msg = NEW_C_HEAP_ARRAY(char, buflen, mtInternal);\n+    int len = snprintf(msg, buflen, \"FD fd=%d type=%s path=%s\", i, type, detailsbuf);\n+    msg[len < 0 ? 0 : ((size_t) len >= buflen ? buflen - 1 : len)] = '\\0';\n@@ -6289,47 +6130,0 @@\n-void os::Linux::register_persistent_fd(int fd, int st_dev, int st_ino) {\n-  if (!CRaCCheckpointTo) {\n-    return;\n-  }\n-  if (!_persistent_resources) {\n-    _persistent_resources = new (ResourceObj::C_HEAP, mtInternal)\n-      GrowableArray<PersistentResourceDesc>(0, mtInternal);\n-  }\n-  int dup = -1;\n-  int i = 0;\n-  while (i < _persistent_resources->length()) {\n-    int pfd = _persistent_resources->adr_at(i)->_fd;\n-    if (pfd == fd) {\n-      dup = i;\n-      break;\n-    } else if (fd < pfd) {\n-      break;\n-    }\n-    ++i;\n-  }\n-\n-  if (0 <= dup) {\n-    _persistent_resources->at_put(dup, PersistentResourceDesc(fd, st_dev, st_ino));\n-  } else {\n-    _persistent_resources->insert_before(i, PersistentResourceDesc(fd, st_dev, st_ino));\n-  }\n-}\n-\n-void os::Linux::deregister_persistent_fd(int fd, int st_dev, int st_ino) {\n-  if (!CRaCCheckpointTo) {\n-    return;\n-  }\n-  if (!_persistent_resources) {\n-    return;\n-  }\n-  int i = 0;\n-  while (i < _persistent_resources->length()) {\n-    PersistentResourceDesc* pr = _persistent_resources->adr_at(i);\n-    if (pr->_fd == fd && pr->_st_dev == (dev_t)st_dev && pr->_st_ino == (ino_t)st_ino) {\n-      break;\n-    }\n-  }\n-  if (i < _persistent_resources->length()) {\n-    _persistent_resources->remove_at(i);\n-  }\n-}\n-\n@@ -6377,1 +6171,1 @@\n-Handle os::Linux::checkpoint(bool dry_run, jlong jcmd_stream, TRAPS) {\n+Handle os::Linux::checkpoint(jarray fd_arr, jobjectArray obj_arr, bool dry_run, jlong jcmd_stream, TRAPS) {\n@@ -6391,1 +6185,1 @@\n-  VM_Crac cr(dry_run, (bufferedStream*)jcmd_stream);\n+  VM_Crac cr(fd_arr, obj_arr, dry_run, (bufferedStream*)jcmd_stream);\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":32,"deletions":238,"binary":false,"changes":270,"status":"modified"},{"patch":"@@ -176,1 +176,1 @@\n-  static Handle checkpoint(bool dry_run, jlong jcmd_stream, TRAPS);\n+  static Handle checkpoint(jarray fd_arr, jobjectArray obj_arr, bool dry_run, jlong jcmd_stream, TRAPS);\n@@ -179,2 +179,0 @@\n-  static void register_persistent_fd(int fd, int st_dev, int st_ino);\n-  static void deregister_persistent_fd(int fd, int st_dev, int st_ino);\n","filename":"src\/hotspot\/os\/linux\/os_linux.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1146,7 +1146,1 @@\n-JVM_Checkpoint(JNIEnv *env, jboolean dry_run, jlong jcmd_stream);\n-\n-JNIEXPORT void JNICALL\n-JVM_RegisterPersistent(int fd, int st_dev, int st_ino);\n-\n-JNIEXPORT void JNICALL\n-JVM_DeregisterPersistent(int fd, int st_dev, int st_ino);\n+JVM_Checkpoint(JNIEnv *env, jarray fd_arr, jobjectArray obj_arr, jboolean dry_run, jlong jcmd_stream);\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3852,2 +3852,2 @@\n-JVM_ENTRY(jobjectArray, JVM_Checkpoint(JNIEnv *env, jboolean dry_run, jlong jcmd_stream))\n-  Handle ret = os::Linux::checkpoint(dry_run, jcmd_stream, CHECK_NULL);\n+JVM_ENTRY(jobjectArray, JVM_Checkpoint(JNIEnv *env, jarray fd_arr, jobjectArray obj_arr, jboolean dry_run, jlong jcmd_stream))\n+  Handle ret = os::Linux::checkpoint(fd_arr, obj_arr, dry_run, jcmd_stream, CHECK_NULL);\n@@ -3856,8 +3856,0 @@\n-\n-JVM_LEAF(void, JVM_RegisterPersistent(int fd, int st_dev, int st_ino))\n-  os::Linux::register_persistent_fd(fd, st_dev, st_ino);\n-JVM_END\n-\n-JVM_LEAF(void, JVM_DeregisterPersistent(int fd, int st_dev, int st_ino))\n-  os::Linux::deregister_persistent_fd(fd, st_dev, st_ino);\n-JVM_END\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+import jdk.internal.access.JavaIOFileDescriptorAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -34,0 +36,1 @@\n+import java.io.FileDescriptor;\n@@ -62,0 +65,3 @@\n+    private static final JavaIOFileDescriptorAccess fdAccess\n+            = SharedSecrets.getJavaIOFileDescriptorAccess();\n+\n@@ -113,1 +119,4 @@\n-            IOUtil.configureBlocking(IOUtil.newFD(eventfd.efd()), false);\n+            FileDescriptor fd = IOUtil.newFD(eventfd.efd());\n+            \/\/ This FileDescriptor is a one-time use, the actual FD will be closed from EventFD\n+            fdAccess.markClosed(fd);\n+            IOUtil.configureBlocking(fd, false);\n","filename":"src\/java.base\/linux\/classes\/sun\/nio\/ch\/EPollSelectorImpl.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -28,3 +28,3 @@\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Objects;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.util.*;\n@@ -32,0 +32,2 @@\n+import jdk.crac.Context;\n+import jdk.crac.impl.CheckpointOpenFileException;\n@@ -34,0 +36,3 @@\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKContext;\n+import jdk.internal.crac.JDKResource;\n@@ -58,0 +63,43 @@\n+    class Resource implements jdk.internal.crac.JDKResource {\n+        private boolean closedByNIO;\n+        final Exception stackTraceHolder;\n+\n+        Resource() {\n+            JDKContext jdkContext = Core.getJDKContext();\n+            jdkContext.register(this);\n+            if (JDKContext.Properties.COLLECT_FD_STACKTRACES) {\n+                \/\/ About the timestamp: we cannot format it nicely since this\n+                \/\/ exception is sometimes created too early in the VM lifecycle\n+                \/\/ (but it's hard to detect when it would be safe to do).\n+                stackTraceHolder = new Exception(\"This file descriptor was created by \"\n+                        + Thread.currentThread().getName() + \" at epoch:\" + System.currentTimeMillis() + \" here\");\n+            } else {\n+                stackTraceHolder = null;\n+            }\n+        }\n+\n+        @Override\n+        public void beforeCheckpoint(Context<? extends jdk.crac.Resource> context) throws Exception {\n+            if (!closedByNIO) {\n+                FileDescriptor.this.beforeCheckpoint();\n+            }\n+        }\n+\n+        @Override\n+        public void afterRestore(Context<? extends jdk.crac.Resource> context) throws Exception {\n+            FileDescriptor.this.afterRestore();\n+        }\n+\n+        @Override\n+        public Priority getPriority() {\n+            return Priority.FILE_DESCRIPTORS;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return getClass().getName() + \"(FD \" + fd + \")\";\n+        }\n+    }\n+\n+    Resource resource = new Resource();\n+\n@@ -65,0 +113,19 @@\n+\n+        Core.getJDKContext().register(checkpointListener = new JDKResource() {\n+            @Override\n+            public Priority getPriority() {\n+                return Priority.NORMAL;\n+            }\n+\n+            @Override\n+            public void beforeCheckpoint(Context<? extends jdk.crac.Resource> context) {\n+                JDKContext ctx = (JDKContext) context;\n+                ctx.claimFd(in, \"System.in\");\n+                ctx.claimFd(out, \"System.out\");\n+                ctx.claimFd(err, \"System.err\");\n+            }\n+\n+            @Override\n+            public void afterRestore(Context<? extends jdk.crac.Resource> context) {\n+            }\n+        });\n@@ -91,0 +158,5 @@\n+                    @Override\n+                    public void markClosed(FileDescriptor fdo) {\n+                        fdo.resource.closedByNIO = true;\n+                    }\n+\n@@ -180,0 +252,3 @@\n+    private static final JDKResource checkpointListener;\n+\n+\n@@ -300,0 +375,28 @@\n+    private synchronized void beforeCheckpoint() throws CheckpointOpenFileException {\n+        if (valid()) {\n+            JDKContext ctx = jdk.internal.crac.Core.getJDKContext();\n+            if (ctx.claimFdWeak(this, this)) {\n+                String path = getPath();\n+                String type = getType();\n+                String info;\n+                if (\"socket\".equals(type)) {\n+                    info = Socket.getDescription(this);\n+                } else {\n+                    info = (path != null ? path : \"unknown path\") + \" (\" + (type != null ? type : \"unknown\") + \")\";\n+                }\n+                String msg = \"FileDescriptor \" + this.fd + \" left open: \" + info + \" \";\n+                if (!JDKContext.Properties.COLLECT_FD_STACKTRACES) {\n+                    msg += JDKContext.COLLECT_FD_STACKTRACES_HINT;\n+                }\n+                throw new CheckpointOpenFileException(msg, resource.stackTraceHolder);\n+            }\n+        }\n+    }\n+\n+    private native String getPath();\n+\n+    private native String getType();\n+\n+    private synchronized void afterRestore() {\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/io\/FileDescriptor.java","additions":106,"deletions":3,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -30,0 +30,3 @@\n+import jdk.crac.Context;\n+import jdk.crac.impl.CheckpointOpenFileException;\n+import jdk.internal.access.JavaIOFileDescriptorAccess;\n@@ -32,0 +35,3 @@\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKContext;\n+import jdk.internal.crac.JDKResource;\n@@ -83,0 +89,36 @@\n+    private class Resource implements JDKResource {\n+        private static final JavaIOFileDescriptorAccess fdAccess = SharedSecrets.getJavaIOFileDescriptorAccess();\n+\n+        Resource() {\n+            Core.getJDKContext().register(this);\n+        }\n+\n+        @Override\n+        public void beforeCheckpoint(Context<? extends jdk.crac.Resource> context) throws Exception {\n+            if (Core.getJDKContext().claimFdWeak(fd, this)) {\n+                if (Core.getJDKContext().matchClasspath(path)) {\n+                    \/\/ Files on the classpath are considered persistent, exception is not thrown\n+                    return;\n+                }\n+                int fdNum = fdAccess.get(fd);\n+                String msg = \"RandomAccessFile \" + path + \" left open (file descriptor \" + fdNum + \"). \";\n+                if (!JDKContext.Properties.COLLECT_FD_STACKTRACES) {\n+                    msg += JDKContext.COLLECT_FD_STACKTRACES_HINT;\n+                }\n+                throw new CheckpointOpenFileException(msg, fd.resource.stackTraceHolder);\n+            }\n+        }\n+\n+        @Override\n+        public void afterRestore(Context<? extends jdk.crac.Resource> context) throws Exception {\n+\n+        }\n+\n+        @Override\n+        public Priority getPriority() {\n+            return Priority.PRE_FILE_DESRIPTORS;\n+        }\n+    }\n+\n+    Resource resource = new Resource();\n+\n","filename":"src\/java.base\/share\/classes\/java\/io\/RandomAccessFile.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.access.SharedSecrets;\n@@ -30,0 +31,1 @@\n+import java.io.FileDescriptor;\n@@ -129,0 +131,1 @@\n+        initNative();\n@@ -131,0 +134,2 @@\n+    private static native int initNative();\n+\n@@ -1918,0 +1923,44 @@\n+\n+    \/*\n+     * Returns a pair of [ localAddr, remoteAddr ] used by socket with given descriptor.\n+     * When the socket is not bound given element is <code>null<\/code>. When this does not\n+     * represent an IPv4\/IPv6 socket this method returns <code>null<\/code>.\n+     *\/\n+    private static native InetSocketAddress[] getAddresses(int fd);\n+\n+    \/*\n+     * Returns the type of the socket represented by this file descriptor. The most common\n+     * values are <code>tcp<\/code>, <code>tcp6<\/code>, <code>udp<\/code> or <code>udp6<\/code>.\n+     *\/\n+    private static native String getType(int fd);\n+\n+    \/**\n+     * Returns a textual description of socket using this file descriptor.\n+     *\n+     * @param fileDescriptor Valid file descriptor instance.\n+     * @return String describing the socket.\n+     *\/\n+    public static String getDescription(FileDescriptor fileDescriptor) {\n+        int fd = SharedSecrets.getJavaIOFileDescriptorAccess().get(fileDescriptor);\n+        if (fd < 0) {\n+            throw new IllegalArgumentException();\n+        }\n+\n+        InetSocketAddress[] addresses = Socket.getAddresses(fd);\n+        StringBuilder sb = new StringBuilder(Socket.getType(fd));\n+        if (addresses == null) {\n+            sb.append(\"not IPv4\/IPv6\");\n+        } else {\n+            if (addresses[0] != null) {\n+                sb.append(\" local \").append(addresses[0]);\n+            } else {\n+                sb.append(\" local not bound\");\n+            }\n+            if (addresses[1] != null) {\n+                sb.append(\" remote \").append(addresses[1]);\n+            } else {\n+                sb.append(\" remote not bound\");\n+            }\n+        }\n+        return sb.toString();\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/net\/Socket.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import java.nio.charset.CharacterCodingException;\n@@ -69,0 +68,1 @@\n+import jdk.internal.crac.JDKContext;\n@@ -1804,1 +1804,1 @@\n-                    Core.registerPersistent(fd);\n+                    Core.getJDKContext().claimFd(fd, this);\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipFile.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,2 +33,3 @@\n-import java.io.StringWriter;\n-import java.io.PrintWriter;\n+import jdk.internal.crac.JDKContext;\n+import jdk.internal.crac.LoggerContainer;\n+\n@@ -37,0 +38,2 @@\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n@@ -44,0 +47,2 @@\n+import java.util.List;\n+import java.util.Map;\n@@ -59,2 +64,1 @@\n-\n-    private static native Object[] checkpointRestore0(boolean dryRun, long jcmdStream);\n+    private static native Object[] checkpointRestore0(int[] fdArr, Object[] objArr, boolean dryRun, long jcmdStream);\n@@ -65,0 +69,1 @@\n+        private FlagsHolder() {}\n@@ -88,1 +93,1 @@\n-                            new CheckpointOpenFileException(messages[i]));\n+                            new CheckpointOpenFileException(messages[i], null));\n@@ -98,1 +103,1 @@\n-                            new CheckpointOpenResourceException(messages[i]));\n+                            new CheckpointOpenResourceException(messages[i], null));\n@@ -118,0 +123,2 @@\n+        \/\/ This log is here to initialize call sites in logger formatters.\n+        LoggerContainer.debug(\"Starting checkpoint at epoch:{0}\", System.currentTimeMillis());\n@@ -128,1 +135,12 @@\n-        final Object[] bundle = checkpointRestore0(checkpointException != null, jcmdStream);\n+        JDKContext jdkContext = jdk.internal.crac.Core.getJDKContext();\n+        List<Map.Entry<Integer, Object>> claimedPairs = jdkContext.getClaimedFds().entrySet().stream().toList();\n+        int[] fdArr = new int[claimedPairs.size()];\n+        Object[] objArr = new Object[claimedPairs.size()];\n+        LoggerContainer.debug(\"Claimed open file descriptors:\");\n+        for (int i = 0; i < claimedPairs.size(); ++i) {\n+            fdArr[i] = claimedPairs.get(i).getKey();\n+            objArr[i] = claimedPairs.get(i).getValue();\n+            LoggerContainer.debug( \"\\t{0} {1}\", fdArr[i], objArr[i]);\n+        }\n+\n+        final Object[] bundle = checkpointRestore0(fdArr, objArr, checkpointException != null, jcmdStream);\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/Core.java","additions":25,"deletions":7,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -33,2 +33,2 @@\n-    public CheckpointOpenFileException(String details) {\n-        super(details);\n+    public CheckpointOpenFileException(String details, Throwable cause) {\n+        super(details, cause);\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/impl\/CheckpointOpenFileException.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,2 +32,2 @@\n-    public CheckpointOpenResourceException(String details) {\n-        super(details);\n+    public CheckpointOpenResourceException(String details, Throwable cause) {\n+        super(details, cause);\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/impl\/CheckpointOpenResourceException.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-        super(details);\n+        super(details, null);\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/impl\/CheckpointOpenSocketException.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+    public void markClosed(FileDescriptor fdo);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaIOFileDescriptorAccess.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,2 +29,0 @@\n-import java.io.FileDescriptor;\n-\n@@ -34,2 +32,0 @@\n-    private static native void registerPersistent0(FileDescriptor fd);\n-\n@@ -44,4 +40,0 @@\n-\n-    public static void registerPersistent(FileDescriptor fd) {\n-        registerPersistent0(fd);\n-    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/Core.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -29,0 +29,4 @@\n+import jdk.crac.CheckpointException;\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import jdk.crac.RestoreException;\n@@ -30,0 +34,3 @@\n+import jdk.internal.access.JavaIOFileDescriptorAccess;\n+import jdk.internal.access.SharedSecrets;\n+import sun.security.action.GetBooleanAction;\n@@ -31,0 +38,5 @@\n+import java.io.File;\n+import java.io.FileDescriptor;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n@@ -32,0 +44,3 @@\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.WeakHashMap;\n@@ -34,0 +49,3 @@\n+    public static final String COLLECT_FD_STACKTRACES_PROPERTY = \"jdk.crac.collect-fd-stacktraces\";\n+    public static final String COLLECT_FD_STACKTRACES_HINT = \"Use -D\" + COLLECT_FD_STACKTRACES_PROPERTY + \"=true to find the source.\";\n+\n@@ -42,0 +60,8 @@\n+    \/\/ JDKContext by itself is initialized too early when system properties are not set yet\n+    public static class Properties {\n+        public static final boolean COLLECT_FD_STACKTRACES =\n+                GetBooleanAction.privilegedGetProperty(JDKContext.COLLECT_FD_STACKTRACES_PROPERTY);\n+    }\n+\n+    private WeakHashMap<FileDescriptor, Object> claimedFds;\n+\n@@ -46,0 +72,34 @@\n+    public boolean matchClasspath(String path) {\n+        Path p = Path.of(path);\n+        String classpath = System.getProperty(\"java.class.path\");\n+        int index = 0;\n+        do {\n+            int end = classpath.indexOf(File.pathSeparatorChar, index);\n+            if (end < 0) {\n+                end = classpath.length();\n+            }\n+            try {\n+                if (Files.isSameFile(p, Path.of(classpath.substring(index, end)))) {\n+                    return true;\n+                }\n+            } catch (IOException e) {\n+                \/\/ ignore exception\n+                return false;\n+            }\n+            index = end + 1;\n+        } while (index < classpath.length());\n+        return false;\n+    }\n+\n+    @Override\n+    public void beforeCheckpoint(Context<? extends Resource> context) throws CheckpointException {\n+        claimedFds = new WeakHashMap<>();\n+        super.beforeCheckpoint(context);\n+    }\n+\n+    @Override\n+    public void afterRestore(Context<? extends Resource> context) throws RestoreException {\n+        super.afterRestore(context);\n+        claimedFds = null;\n+    }\n+\n@@ -50,0 +110,29 @@\n+\n+    public Map<Integer, Object> getClaimedFds() {\n+        JavaIOFileDescriptorAccess fileDescriptorAccess = SharedSecrets.getJavaIOFileDescriptorAccess();\n+        \/\/ Using streams+lambdas here would create a new Cleaner, therefore registering a resource\n+        Map<Integer, Object> map = new HashMap<>();\n+        for (Map.Entry<FileDescriptor, Object> entry : claimedFds.entrySet()) {\n+            if (map.put(fileDescriptorAccess.get(entry.getKey()), entry.getValue()) != null) {\n+                throw new IllegalStateException(\"Duplicate key\");\n+            }\n+        }\n+        return map;\n+    }\n+\n+    public void claimFd(FileDescriptor fd, Object obj) {\n+        if (!fd.valid()) {\n+            return;\n+        }\n+        Object e = claimedFds.put(fd, obj);\n+        if (e != null) {\n+            throw new AssertionError(fd + \" was already claimed by \" + e);\n+        }\n+    }\n+\n+    public boolean claimFdWeak(FileDescriptor fd, Object obj) {\n+        if (!fd.valid()) {\n+            return false;\n+        }\n+        return claimedFds.putIfAbsent(fd, obj) == null;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/JDKContext.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -86,0 +86,3 @@\n+\n+        PRE_FILE_DESRIPTORS,\n+        FILE_DESCRIPTORS,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/JDKResource.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -222,0 +222,5 @@\n+\n+        @Override\n+        public String toString() {\n+            return \"PhantomCleanableRef:\"  + action;\n+        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/ref\/CleanerImpl.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+\n@@ -47,1 +48,1 @@\n-        LoggerContainer.logger.log(System.Logger.Level.INFO, this.getName() + \" is recorded as always available on restore\");\n+        LoggerContainer.info(this.getName() + \" is recorded as always available on restore\");\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/jar\/PersistentJarFile.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,0 +28,6 @@\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKContext;\n+import jdk.internal.crac.JDKResource;\n+\n@@ -145,2 +151,2 @@\n-    private static final class UnclosableInputStream extends FilterInputStream {\n-        UnclosableInputStream(InputStream in) {\n+    private static final class UnclosableInputStream extends FilterInputStream implements JDKResource {\n+        UnclosableInputStream(FileInputStream in) {\n@@ -148,0 +154,1 @@\n+            Core.getJDKContext().register(this);\n@@ -158,0 +165,15 @@\n+\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+            ((JDKContext)context).claimFd(((FileInputStream)in).getFD(), this);\n+        }\n+\n+        @Override\n+        public void afterRestore(Context<? extends Resource> context) throws Exception {\n+\n+        }\n+\n+        @Override\n+        public Priority getPriority() {\n+            return Priority.NORMAL;\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/FileInputStreamPool.java","additions":24,"deletions":2,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-#include \"jdk_internal_crac_Core.h\"\n@@ -39,16 +38,2 @@\n-Java_jdk_crac_Core_checkpointRestore0(JNIEnv *env, jclass ignore, jboolean dry_run, jlong jcmd_stream)\n-{\n-    return JVM_Checkpoint(env, dry_run, jcmd_stream);\n-}\n-\n-JNIEXPORT void JNICALL Java_jdk_internal_crac_Core_registerPersistent0\n-  (JNIEnv *env, jclass ignore, jobject fileDesc)\n-{\n-    jint fd = THIS_FD(fileDesc);\n-\n-    struct stat st;\n-    if (-1 == fstat(fd, &st)) {\n-        return;\n-    }\n-\n-    JVM_RegisterPersistent(fd, st.st_dev, st.st_ino);\n+Java_jdk_crac_Core_checkpointRestore0(JNIEnv *env, jclass ignore, jarray fdArr, jobjectArray objArr, jboolean dry_run, jlong jcmd_stream) {\n+    return JVM_Checkpoint(env, fdArr, objArr, dry_run, jcmd_stream);\n","filename":"src\/java.base\/share\/native\/libjava\/CracCore.c","additions":2,"deletions":17,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-        FileDispatcherImpl.close0(fd);\n+        FileDispatcherImpl.closeAndMark(fd);\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/ch\/DatagramDispatcher.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import jdk.internal.crac.JDKResource.Priority;\n@@ -209,0 +208,7 @@\n+    \/\/ Shared with SocketDispatcher and DatagramDispatcher but\n+    \/\/ NOT used by FileDispatcherImpl\n+    static void closeAndMark(FileDescriptor fd) throws IOException {\n+        fdAccess.markClosed(fd);\n+        close0(fd);\n+    }\n+\n@@ -246,3 +252,1 @@\n-    \/\/ Shared with SocketDispatcher and DatagramDispatcher but\n-    \/\/ NOT used by FileDispatcherImpl\n-    static native void close0(FileDescriptor fd) throws IOException;\n+    private static native void close0(FileDescriptor fd) throws IOException;\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/ch\/FileDispatcherImpl.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-        FileDispatcherImpl.close0(fd);\n+        FileDispatcherImpl.closeAndMark(fd);\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/ch\/SocketDispatcher.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKContext;\n@@ -400,0 +402,2 @@\n+\n+            Core.getJDKContext().register(this);\n@@ -596,0 +600,6 @@\n+            synchronized (LOCK_SET_SEED) {\n+                if (seedOut != null) {\n+                    Core.getJDKContext().claimFdWeak(((FileOutputStream)seedOut).getFD(), this);\n+                }\n+            }\n+\n@@ -612,1 +622,0 @@\n-\n","filename":"src\/java.base\/unix\/classes\/sun\/security\/provider\/NativePRNG.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -25,2 +25,0 @@\n-\n-#include <unistd.h>\n@@ -28,0 +26,3 @@\n+#include <inttypes.h>\n+#include <stdbool.h>\n+#include <unistd.h>\n@@ -78,0 +79,40 @@\n+static const char* stat2strtype(mode_t mode) {\n+    switch (mode & S_IFMT) {\n+        case S_IFSOCK: return \"socket\";\n+        case S_IFLNK:  return \"symlink\";\n+        case S_IFREG:  return \"regular\";\n+        case S_IFBLK:  return \"block\";\n+        case S_IFDIR:  return \"directory\";\n+        case S_IFCHR:  return \"character\";\n+        case S_IFIFO:  return \"fifo\";\n+        default:       break;\n+    }\n+    return \"unknown\";\n+}\n+\n+JNIEXPORT jstring JNICALL\n+Java_java_io_FileDescriptor_getPath(JNIEnv *env, jobject obj) {\n+    int fd = (*env)->GetIntField(env, obj, IO_fd_fdID);\n+    char fdpath[64];\n+    snprintf(fdpath, sizeof(fdpath), \"\/proc\/self\/fd\/%d\", fd);\n+    char link[PATH_MAX];\n+    int ret = readlink(fdpath, link, PATH_MAX);\n+    if (ret >= 0) {\n+        link[(unsigned)ret < PATH_MAX ? ret : PATH_MAX - 1] = '\\0';\n+        return (*env)->NewStringUTF(env, link);\n+    }\n+    return NULL;\n+}\n+\n+\n+JNIEXPORT jstring JNICALL\n+Java_java_io_FileDescriptor_getType(JNIEnv *env, jobject obj) {\n+    int fd = (*env)->GetIntField(env, obj, IO_fd_fdID);\n+    struct stat st;\n+    if (fstat(fd, &st) == 0) {\n+        return (*env)->NewStringUTF(env, stat2strtype(st.st_mode));\n+    } else {\n+        return NULL;\n+    }\n+}\n+\n","filename":"src\/java.base\/unix\/native\/libjava\/FileDescriptor_md.c","additions":43,"deletions":2,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"net_util_md.h\"\n@@ -61,0 +62,109 @@\n+static jclass isa_class = NULL;\n+static jmethodID isa_ctor = NULL;\n+\n+JNIEXPORT void JNICALL\n+Java_java_net_Socket_initNative(JNIEnv *env, jclass c1)\n+{\n+    jclass isa_class_local = (*env)->FindClass(env, \"java\/net\/InetSocketAddress\");\n+    if (isa_class_local == NULL) {\n+        JNU_ThrowClassNotFoundException(env, \"java.net.InetSocketAddress\");\n+        return;\n+    }\n+    isa_class = (*env)->NewGlobalRef(env, isa_class_local);\n+    isa_ctor = (*env)->GetMethodID(env, isa_class, \"<init>\", \"(Ljava\/net\/InetAddress;I)V\");\n+    if (isa_ctor == NULL) {\n+        JNU_ThrowByName(env, \"java\/lang\/NoSuchMethodError\", \"InetSocketAddress.<init>(java.net.InetAddress, int)\");\n+    }\n+}\n+\n+static jobject create_isa(JNIEnv *env, jclass isa_class, jmethodID isa_ctor, SOCKETADDRESS *addr) {\n+    jint port;\n+    jobject inetAddr = NET_SockaddrToInetAddress(env, addr, &port);\n+    return (*env)->NewObject(env, isa_class, isa_ctor, inetAddr, port);\n+}\n+\n+JNIEXPORT jobjectArray JNICALL\n+Java_java_net_Socket_getAddresses(JNIEnv *env, jclass cl, jint fd) {\n+    int family;\n+    socklen_t famlen = sizeof(int);\n+    if (getsockopt(fd, SOL_SOCKET, SO_DOMAIN, &family, &famlen) != 0) {\n+        JNU_ThrowByName(env, \"java\/net\/SocketException\", \"Cannot find socket family\");\n+        return NULL;\n+    } else if (family != AF_INET && family != AF_INET6) {\n+        return NULL;\n+    }\n+\n+    jobjectArray arr = (*env)->NewObjectArray(env, 2, isa_class, NULL);\n+    if (arr == NULL) {\n+        JNU_ThrowOutOfMemoryError(env, \"java.net.InetSocketAddres[2]\");\n+        return NULL;\n+    }\n+\n+    SOCKETADDRESS local;\n+    socklen_t llen = sizeof(SOCKETADDRESS);\n+    if (getsockname(fd, &local.sa, &llen) != 0) {\n+        JNU_ThrowIllegalArgumentException(env, strerror(errno));\n+        return NULL;\n+    }\n+    jobject localAddr = create_isa(env, isa_class, isa_ctor, &local);\n+    if (localAddr == NULL) {\n+        JNU_ThrowOutOfMemoryError(env, \"java.net.InetSocketAddres\");\n+        return NULL;\n+    }\n+\n+    jobject remoteAddr;\n+    SOCKETADDRESS remote;\n+    socklen_t rlen = sizeof(SOCKETADDRESS);\n+    if (getpeername(fd, &remote.sa, &rlen) != 0) {\n+        if (errno == ENOTCONN) {\n+            remoteAddr = NULL;\n+        } else {\n+            JNU_ThrowIllegalArgumentException(env, strerror(errno));\n+            return NULL;\n+        }\n+    } else {\n+        remoteAddr = create_isa(env, isa_class, isa_ctor, &remote);\n+        if (remoteAddr == NULL) {\n+           JNU_ThrowOutOfMemoryError(env, \"java.net.InetSocketAddres\");\n+           return NULL;\n+        }\n+    }\n+\n+    (*env)->SetObjectArrayElement(env, arr, 0, localAddr);\n+    (*env)->SetObjectArrayElement(env, arr, 1, remoteAddr);\n+    return arr;\n+}\n+\n+JNIEXPORT jstring JNICALL\n+Java_java_net_Socket_getType(JNIEnv *env, jclass cl, jint fd) {\n+    int socktype, family;\n+    socklen_t typelen = sizeof(int), famlen = sizeof(int);\n+    const char *type;\n+    if (getsockopt(fd, SOL_SOCKET, SO_DOMAIN, &family, &famlen) != 0) {\n+        JNU_ThrowByName(env, \"java\/net\/SocketException\", \"Cannot find socket family\");\n+        return NULL;\n+    } else if (family == AF_UNIX) {\n+        type = \"unix socket\";\n+    } else if (family != AF_INET && family != AF_INET6) {\n+        type = \"unknown socket family\";\n+    } else {\n+        if (getsockopt(fd, SOL_SOCKET, SO_TYPE, &socktype, &typelen) != 0) {\n+            JNU_ThrowByName(env, \"java\/net\/SocketException\", \"Cannot find socket type\");\n+            return NULL;\n+        }\n+        switch(socktype) {\n+            case SOCK_STREAM:\n+                type = family == AF_INET ? \"tcp\" : \"tcp6\";\n+                break;\n+            case SOCK_DGRAM:\n+                type = family == AF_INET ? \"udp\" : \"udp6\";\n+                break;\n+            case SOCK_RAW:\n+                type = family == AF_INET ? \"raw\" : \"raw6\";\n+                break;\n+            default:\n+                type = family == AF_INET ? \"unknown IPv4\" : \"unknown IPv6\";\n+        }\n+    }\n+    return (*env)->NewStringUTF(env, type);\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/unix\/native\/libnet\/SocketImpl.c","additions":110,"deletions":0,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -71,0 +71,2 @@\n+static char* altstack = NULL;\n+\n@@ -72,1 +74,8 @@\n-  static char altstack[SIGSTKSZ];\n+  if (altstack == NULL) {\n+    \/\/ Dynamically allocated in case SIGSTKSZ is not constant\n+    altstack = malloc(SIGSTKSZ);\n+    if (altstack == NULL) {\n+      fprintf(stderr, \"Test ERROR. Unable to malloc altstack space\\n\");\n+      exit(7);\n+    }\n+  }\n","filename":"test\/hotspot\/jtreg\/runtime\/StackGuardPages\/exeinvoke.c","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -56,0 +56,4 @@\n+            \/\/ FIXME: This test can still spuriously fail when this starts running\n+            \/\/ before C\/R, voiding the PhantomCleanableRef.beforeCheckpoint, but\n+            \/\/ does not finish the close before FileDescriptor finds itself not closed\n+            \/\/ and rightfully throws CheckpointOpenFileException.\n","filename":"test\/jdk\/jdk\/crac\/RefQueueTest.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.Core;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracProcess;\n+import jdk.test.lib.crac.CracTest;\n+\n+import java.io.FileReader;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @build OpenFileDetectionTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class OpenFileDetectionTest implements CracTest {\n+    @Override\n+    public void test() throws Exception {\n+        CracProcess cp = new CracBuilder().captureOutput(true)\n+                .javaOption(\"jdk.crac.collect-fd-stacktraces\", \"true\")\n+                .startCheckpoint();\n+        cp.outputAnalyzer()\n+                .shouldHaveExitValue(1)\n+                .shouldContain(\"\/etc\/passwd\")\n+                .shouldContain(\"This file descriptor was created by \"); \/\/ <thread> at <time> here\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        try (var reader = new FileReader(\"\/etc\/passwd\")) {\n+            Core.checkpointRestore();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/OpenFileDetectionTest.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.Core;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracProcess;\n+import jdk.test.lib.crac.CracTest;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.util.concurrent.CountDownLatch;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @build OpenSocketDetectionTest\n+ * @run driver\/timeout=10 jdk.test.lib.crac.CracTest\n+ *\/\n+public class OpenSocketDetectionTest implements CracTest {\n+    @Override\n+    public void test() throws Exception {\n+        CracProcess cp = new CracBuilder().captureOutput(true)\n+                .startCheckpoint();\n+        cp.outputAnalyzer()\n+                .shouldHaveExitValue(1)\n+                .shouldMatch(\"left open: tcp6? local [\/0-9a-f:.]+:[0-9]+ remote [\/0-9a-f:.]+:[0-9]+\");\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        ServerSocket serverSocket = new ServerSocket(0, 50, InetAddress.getLoopbackAddress());\n+        CountDownLatch latch = new CountDownLatch(1);\n+        Thread serverThread = new Thread(() -> {\n+            try {\n+                Socket socket = serverSocket.accept();\n+                latch.countDown();\n+            } catch (IOException e) {\n+                e.printStackTrace();\n+            }\n+        });\n+        serverThread.setDaemon(true);\n+        serverThread.start();\n+        Socket clientSocket = new Socket(InetAddress.getLoopbackAddress(), serverSocket.getLocalPort());\n+        latch.await();\n+        Core.checkpointRestore();\n+    }\n+\n+}\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/OpenSocketDetectionTest.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -34,0 +34,1 @@\n+    final Map<String, String> javaOptions = new HashMap<>();\n@@ -102,0 +103,5 @@\n+    public CracBuilder javaOption(String name, String value) {\n+        javaOptions.put(name, value);\n+        return this;\n+    }\n+\n@@ -310,0 +316,3 @@\n+        for (var entry : javaOptions.entrySet()) {\n+            cmd.add(\"-D\" + entry.getKey() + \"=\" + entry.getValue());\n+        }\n","filename":"test\/lib\/jdk\/test\/lib\/crac\/CracBuilder.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"}]}