{"files":[{"patch":"@@ -6006,66 +6006,0 @@\n-static bool find_sock_details(int sockino, const char* base, bool v6, char* buf, size_t sz) {\n-  char filename[16];\n-  snprintf(filename, sizeof(filename), \"\/proc\/net\/%s\", base);\n-  FILE* f = fopen(filename, \"r\");\n-  if (!f) {\n-    return false;\n-  }\n-  int r = fscanf(f, \"%*[^\\n]\");\n-  if (r) {} \/\/ suppress warn unused gcc diagnostic\n-\n-  char la[33], ra[33];\n-  int lp, rp;\n-  int ino;\n-  \/\/   sl  local_address         remote_address        st   tx_queue rx_queue tr tm->when retrnsmt   uid  timeout inode\n-  \/\/    0: 0100007F:08AE         00000000:0000         0A   00000000:00000000 00:00000000 00000000  1000        0 2988639\n-  \/\/  %4d: %08X%08X%08X%08X:%04X %08X%08X%08X%08X:%04X %02X %08X:%08X         %02X:%08lX  %08X       %5u      %8d %d\n-  bool eof;\n-  do {\n-    eof = EOF == fscanf(f, \"%*d: %[^:]:%X %[^:]:%X %*X %*X:%*X %*X:%*X %*X %*d %*d %d%*[^\\n]\\n\",\n-        la, &lp, ra, &rp, &ino);\n-  } while (ino != sockino && !eof);\n-  fclose(f);\n-\n-  if (ino != sockino) {\n-    return false;\n-  }\n-\n-  struct in6_addr a6l, a6r;\n-  struct in_addr a4l, a4r;\n-  if (v6) {\n-    for (int i = 0; i < 4; ++i) {\n-      sscanf(la + i * 8, \"%8\" PRIX32, a6l.s6_addr32 + i);\n-      sscanf(ra + i * 8, \"%8\" PRIX32, a6r.s6_addr32 + i);\n-    }\n-  } else {\n-    sscanf(la, \"%\" PRIX32, &a4l.s_addr);\n-    sscanf(ra, \"%\" PRIX32, &a4r.s_addr);\n-  }\n-\n-  int const af = v6 ? AF_INET6 : AF_INET;\n-  void* const laddr = v6 ? (void*)&a6l : (void*)&a4l;\n-  void* const raddr = v6 ? (void*)&a6r : (void*)&a4r;\n-  char lstrb[48], rstrb[48];\n-  const char* const lstr = ::inet_ntop(af, laddr, lstrb, sizeof(lstrb)) ? lstrb : \"NONE\";\n-  const char* const rstr = ::inet_ntop(af, raddr, rstrb, sizeof(rstrb)) ? rstrb : \"NONE\";\n-  int msgsz = snprintf(buf, sz, \"%s localAddr %s localPort %d remoteAddr %s remotePort %d\",\n-        base, lstr, lp, rstr, rp);\n-  return msgsz < (int)sz;\n-}\n-\n-static const char* sock_details(const char* details, char* buf, size_t sz) {\n-  int sockino;\n-  if (sscanf(details, \"socket:[%d]\", &sockino) <= 0) {\n-    return details;\n-  }\n-\n-  const char* bases[] = { \"tcp\", \"udp\", \"tcp6\", \"udp6\", NULL };\n-  for (const char** b = bases; *b; ++b) {\n-    if (find_sock_details(sockino, *b, 2 <= b - bases, buf, sz)) {\n-      return buf;\n-    }\n-  }\n-\n-  return details;\n-}\n-\n@@ -6127,0 +6061,1 @@\n+    const char* type = stat2strtype(fds.get_stat(i)->st_mode);\n@@ -6129,2 +6064,1 @@\n-    print_resources(\"JVM: FD fd=%d type=%s: details1=\\\"%s\\\" \",\n-        i, stat2strtype(fds.get_stat(i)->st_mode), details);\n+    print_resources(\"JVM: FD fd=%d type=%s path=\\\"%s\\\"\", i, type, details);\n@@ -6148,2 +6082,0 @@\n-      details = sock_details(details, detailsbuf, sizeof(detailsbuf));\n-      print_resources(\" details2=\\\"%s\\\" \", details);\n@@ -6155,2 +6087,6 @@\n-    char* msg = NEW_C_HEAP_ARRAY(char, strlen(details) + 1, mtInternal);\n-    strcpy(msg, details);\n+    const int maxinfo = 64;\n+    size_t buflen = strlen(details) + maxinfo;\n+    char* msg = NEW_C_HEAP_ARRAY(char, buflen, mtInternal);\n+    int ilen = snprintf(msg, maxinfo, \"FD fd=%d type=%s path=\", i, type);\n+    ilen = ilen > maxinfo ? maxinfo : ilen;\n+    strncpy(msg + ilen, detailsbuf, buflen - ilen);\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":8,"deletions":72,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n@@ -375,1 +377,25 @@\n-                String msg = \"FileDescriptor \" + this.fd + \" left open. \";\n+                String path = getPath();\n+                String type = getType();\n+                String info;\n+                if (\"socket\".equals(type)) {\n+                    InetSocketAddress[] addresses = Socket.getAddresses(fd);\n+                    StringBuilder sb = new StringBuilder(Socket.getType(fd));\n+                    if (addresses == null) {\n+                        sb.append(\"not IPv4\/IPv6\");\n+                    } else {\n+                        if (addresses[0] != null) {\n+                            sb.append(\" local \").append(addresses[0]);\n+                        } else {\n+                            sb.append(\" local not bound\");\n+                        }\n+                        if (addresses[1] != null) {\n+                            sb.append(\" remote \").append(addresses[1]);\n+                        } else {\n+                            sb.append(\" remote not bound\");\n+                        }\n+                    }\n+                    info = sb.toString();\n+                } else {\n+                    info = (path != null ? path : \"unknown path\") + \" (\" + (type != null ? type : \"unknown\") + \")\";\n+                }\n+                String msg = \"FileDescriptor \" + this.fd + \" left open: \" + info + \" \";\n@@ -384,1 +410,1 @@\n-    private synchronized void afterRestore() {\n+    private native String getPath();\n@@ -386,1 +412,1 @@\n-    }\n+    private native String getType();\n@@ -388,0 +414,2 @@\n+    private synchronized void afterRestore() {\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/io\/FileDescriptor.java","additions":31,"deletions":3,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -129,0 +129,1 @@\n+        initNative();\n@@ -131,0 +132,2 @@\n+    private static native int initNative();\n+\n@@ -1918,0 +1921,19 @@\n+\n+    \/**\n+     * Returns a pair of [ localAddr, remoteAddr ] used by socket with given descriptor.\n+     * When the socket is not bound given element is <code>null<\/code>. When this does not\n+     * represent an IPv4\/IPv6 socket this method returns <code>null<\/code>.\n+     *\n+     * @param fd File descriptor number.\n+     * @return Null or an array with length 2.\n+     *\/\n+    public static native InetSocketAddress[] getAddresses(int fd);\n+\n+    \/**\n+     * Returns the type of the socket represented by this file descriptor. The most common\n+     * values are <code>tcp<\/code>, <code>tcp6<\/code>, <code>udp<\/code> or <code>udp6<\/code>.\n+     *\n+     * @param fd File descriptor number.\n+     * @return Textual representation of the type.\n+     *\/\n+    public static native String getType(int fd);\n","filename":"src\/java.base\/share\/classes\/java\/net\/Socket.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -25,2 +25,0 @@\n-\n-#include <unistd.h>\n@@ -28,0 +26,3 @@\n+#include <inttypes.h>\n+#include <stdbool.h>\n+#include <unistd.h>\n@@ -78,0 +79,40 @@\n+static const char* stat2strtype(mode_t mode) {\n+    switch (mode & S_IFMT) {\n+        case S_IFSOCK: return \"socket\";\n+        case S_IFLNK:  return \"symlink\";\n+        case S_IFREG:  return \"regular\";\n+        case S_IFBLK:  return \"block\";\n+        case S_IFDIR:  return \"directory\";\n+        case S_IFCHR:  return \"character\";\n+        case S_IFIFO:  return \"fifo\";\n+        default:       break;\n+    }\n+    return \"unknown\";\n+}\n+\n+JNIEXPORT jstring JNICALL\n+Java_java_io_FileDescriptor_getPath(JNIEnv *env, jobject obj) {\n+    int fd = (*env)->GetIntField(env, obj, IO_fd_fdID);\n+    char fdpath[64];\n+    snprintf(fdpath, sizeof(fdpath), \"\/proc\/self\/fd\/%d\", fd);\n+    char link[PATH_MAX];\n+    int ret = readlink(fdpath, link, PATH_MAX);\n+    if (ret >= 0) {\n+        link[(unsigned)ret < PATH_MAX ? ret : PATH_MAX - 1] = '\\0';\n+        return (*env)->NewStringUTF(env, link);\n+    }\n+    return NULL;\n+}\n+\n+\n+JNIEXPORT jstring JNICALL\n+Java_java_io_FileDescriptor_getType(JNIEnv *env, jobject obj) {\n+    int fd = (*env)->GetIntField(env, obj, IO_fd_fdID);\n+    struct stat st;\n+    if (fstat(fd, &st) == 0) {\n+        return (*env)->NewStringUTF(env, stat2strtype(st.st_mode));\n+    } else {\n+        return NULL;\n+    }\n+}\n+\n","filename":"src\/java.base\/unix\/native\/libjava\/FileDescriptor_md.c","additions":43,"deletions":2,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"net_util_md.h\"\n@@ -61,0 +62,111 @@\n+static jclass isa_class = NULL;\n+static jmethodID isa_ctor = NULL;\n+\n+JNIEXPORT void JNICALL\n+Java_java_net_Socket_initNative(JNIEnv *env, jclass c1)\n+{\n+    jclass isa_class_local = (*env)->FindClass(env, \"java\/net\/InetSocketAddress\");\n+    if (isa_class_local == NULL) {\n+        JNU_ThrowClassNotFoundException(env, \"java.net.InetSocketAddress\");\n+        return;\n+    }\n+    isa_class = (*env)->NewGlobalRef(env, isa_class_local);\n+    isa_ctor = (*env)->GetMethodID(env, isa_class, \"<init>\", \"(Ljava\/net\/InetAddress;I)V\");\n+    if (isa_ctor == NULL) {\n+        JNU_ThrowByName(env, \"java\/lang\/NoSuchMethodError\", \"InetSocketAddress.<init>(java.net.InetAddress, int)\");\n+    }\n+}\n+\n+static jobject create_isa(JNIEnv *env, jclass isa_class, jmethodID isa_ctor, SOCKETADDRESS *addr) {\n+    jint port;\n+    jobject inetAddr = NET_SockaddrToInetAddress(env, addr, &port);\n+    return (*env)->NewObject(env, isa_class, isa_ctor, inetAddr, port);\n+}\n+\n+JNIEXPORT jobjectArray JNICALL\n+Java_java_net_Socket_getAddresses(JNIEnv *env, jclass cl, jint fd) {\n+    int family;\n+    socklen_t famlen = sizeof(int);\n+    if (getsockopt(fd, SOL_SOCKET, SO_DOMAIN, &family, &famlen) != 0) {\n+        JNU_ThrowByName(env, \"java\/net\/SocketException\", \"Cannot find socket family\");\n+        return NULL;\n+    } else if (family != AF_INET && family != AF_INET6) {\n+        return NULL;\n+    }\n+\n+    jobjectArray arr = (*env)->NewObjectArray(env, 2, isa_class, NULL);\n+    if (arr == NULL) {\n+        JNU_ThrowOutOfMemoryError(env, \"java.net.InetSocketAddres[2]\");\n+        return NULL;\n+    }\n+\n+    jobject localAddr;\n+    SOCKETADDRESS local;\n+    socklen_t llen = sizeof(SOCKETADDRESS);\n+    if (getsockname(fd, &local.sa, &llen) != 0) {\n+        JNU_ThrowIllegalArgumentException(env, strerror(errno));\n+        return NULL;\n+    } else {\n+        localAddr = create_isa(env, isa_class, isa_ctor, &local);\n+        if (localAddr == NULL) {\n+           JNU_ThrowOutOfMemoryError(env, \"java.net.InetSocketAddres\");\n+           return NULL;\n+        }\n+    }\n+\n+    jobject remoteAddr;\n+    SOCKETADDRESS remote;\n+    socklen_t rlen = sizeof(SOCKETADDRESS);\n+    if (getpeername(fd, &remote.sa, &rlen) != 0) {\n+        if (errno == ENOTCONN) {\n+            remoteAddr = NULL;\n+        } else {\n+            JNU_ThrowIllegalArgumentException(env, strerror(errno));\n+            return NULL;\n+        }\n+    } else {\n+        remoteAddr = create_isa(env, isa_class, isa_ctor, &remote);\n+        if (remoteAddr == NULL) {\n+           JNU_ThrowOutOfMemoryError(env, \"java.net.InetSocketAddres\");\n+           return NULL;\n+        }\n+    }\n+\n+    (*env)->SetObjectArrayElement(env, arr, 0, localAddr);\n+    (*env)->SetObjectArrayElement(env, arr, 1, remoteAddr);\n+    return arr;\n+}\n+\n+JNIEXPORT jstring JNICALL\n+Java_java_net_Socket_getType(JNIEnv *env, jclass cl, jint fd) {\n+    int socktype, family;\n+    socklen_t typelen = sizeof(int), famlen = sizeof(int);\n+    const char *type;\n+    if (getsockopt(fd, SOL_SOCKET, SO_DOMAIN, &family, &famlen) != 0) {\n+        JNU_ThrowByName(env, \"java\/net\/SocketException\", \"Cannot find socket family\");\n+        return NULL;\n+    } else if (family == AF_UNIX) {\n+        type = \"unix socket\";\n+    } else if (family != AF_INET && family != AF_INET6) {\n+        type = \"unknown socket family\";\n+    } else {\n+        if (getsockopt(fd, SOL_SOCKET, SO_TYPE, &socktype, &typelen) != 0) {\n+            JNU_ThrowByName(env, \"java\/net\/SocketException\", \"Cannot find socket type\");\n+            return NULL;\n+        }\n+        switch(socktype) {\n+            case SOCK_STREAM:\n+                type = family == AF_INET ? \"tcp\" : \"tcp6\";\n+                break;\n+            case SOCK_DGRAM:\n+                type = family == AF_INET ? \"udp\" : \"udp6\";\n+                break;\n+            case SOCK_RAW:\n+                type = family == AF_INET ? \"raw\" : \"raw6\";\n+                break;\n+            default:\n+                type = family == AF_INET ? \"unknown IPv4\" : \"unknown IPv6\";\n+        }\n+    }\n+    return (*env)->NewStringUTF(env, type);\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/unix\/native\/libnet\/SocketImpl.c","additions":112,"deletions":0,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -40,2 +40,1 @@\n-        CracBuilder builder = new CracBuilder();\n-        CracProcess cp = builder.captureOutput(true)\n+        CracProcess cp = new CracBuilder().captureOutput(true)\n@@ -46,0 +45,1 @@\n+                .shouldContain(\"\/etc\/passwd\")\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/OpenFileDetectionTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.Core;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracProcess;\n+import jdk.test.lib.crac.CracTest;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.util.concurrent.CountDownLatch;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @build OpenSocketDetectionTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class OpenSocketDetectionTest implements CracTest {\n+    @Override\n+    public void test() throws Exception {\n+        CracProcess cp = new CracBuilder()\n+                .startCheckpoint();\n+        cp.outputAnalyzer()\n+                .shouldHaveExitValue(1)\n+                .shouldMatch(\"left open: tcp6? local [\/0-9a-f:.]+:[0-9]+ remote [\/0-9a-f:.]+:[0-9]+\");\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        ServerSocket serverSocket = new ServerSocket(0, 50, InetAddress.getLoopbackAddress());\n+        CountDownLatch latch = new CountDownLatch(1);\n+        Thread serverThread = new Thread(() -> {\n+            try {\n+                Socket socket = serverSocket.accept();\n+                latch.countDown();\n+            } catch (IOException e) {\n+                e.printStackTrace();\n+            }\n+        });\n+        serverThread.setDaemon(true);\n+        serverThread.start();\n+        Socket clientSocket = new Socket(InetAddress.getLoopbackAddress(), serverSocket.getLocalPort());\n+        latch.await();\n+        Core.checkpointRestore();\n+    }\n+\n+}\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/OpenSocketDetectionTest.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"}]}