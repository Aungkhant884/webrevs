{"files":[{"patch":"@@ -93,2 +93,5 @@\n-            new CleanerImpl.PhantomCleanableRef(cs, CleanerFactory.cleaner(),\n-                    newContext, JDKResource.Priority.CALL_SITES);\n+            \/\/ This PhantomCleanableRef is not registered in any Context as\n+            \/\/ registration caused by the core CRaC code leads to deadlock.\n+            \/\/ The drawback is native structures may end up in the checkpoint\n+            \/\/ image and be cleaned shortly after restore, which is neglectable.\n+            SharedSecrets.getJavaLangRefAccess().register(CleanerFactory.cleaner(), cs, newContext, null);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleNatives.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -224,0 +224,9 @@\n+    \/**\n+     * Register an object and object and also register the underlying Reference with a CRaC priority.\n+     *\/\n+    \/*non-public*\/ Cleanable register(Object obj, Runnable action, JDKResource.Priority priority) {\n+        Objects.requireNonNull(obj, \"obj\");\n+        Objects.requireNonNull(action, \"action\");\n+        return new CleanerImpl.PhantomCleanableRef(obj, this, action, priority);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/Cleaner.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -334,0 +334,5 @@\n+\n+            @Override\n+            public java.lang.ref.Cleaner.Cleanable register(java.lang.ref.Cleaner cleaner, Object obj, Runnable action, JDKResource.Priority priority) {\n+                return cleaner.register(obj, action, priority);\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/Reference.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,0 +28,4 @@\n+import jdk.internal.crac.JDKResource;\n+\n+import java.lang.ref.Cleaner;\n+\n@@ -46,0 +50,5 @@\n+\n+    \/**\n+     * Registers an object and an action in a cleaner, with action synhronized with a CRaC priority.\n+     *\/\n+    Cleaner.Cleanable register(Cleaner cleaner, Object obj, Runnable action, JDKResource.Priority priority);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangRefAccess.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -89,8 +89,0 @@\n-\n-        \/**\n-         * Cleaners for CallSites cannot be registered with regular CLEANERS\n-         * priority as this would hang\/throw exceptions any time a lambda\n-         * or method reference is used during or after processing this resource\n-         * priority class; therefore we postpone as the last priority.\n-         *\/\n-        CALL_SITES,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/JDKResource.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -173,1 +173,3 @@\n-            jdk.internal.crac.Core.getJDKContext().register(this);\n+            if (priority != null) {\n+                jdk.internal.crac.Core.getJDKContext().register(this);\n+            }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/ref\/CleanerImpl.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"}]}