{"files":[{"patch":"@@ -31,0 +31,5 @@\n+\n+import jdk.crac.CheckpointException;\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import jdk.internal.crac.JDKResource;\n@@ -54,24 +59,1 @@\n-        \/\/ initialize inotify\n-        int ifd = - 1;\n-        try {\n-            ifd = inotifyInit();\n-        } catch (UnixException x) {\n-            String msg = (x.errno() == EMFILE) ?\n-                \"User limit of inotify instances reached or too many open files\" :\n-                x.errorString();\n-            throw new IOException(msg);\n-        }\n-\n-        \/\/ configure inotify to be non-blocking\n-        \/\/ create socketpair used in the close mechanism\n-        int sp[] = new int[2];\n-        try {\n-            configureBlocking(ifd, false);\n-            socketpair(sp);\n-            configureBlocking(sp[0], false);\n-        } catch (UnixException x) {\n-            UnixNativeDispatcher.close(ifd);\n-            throw new IOException(x.errorString());\n-        }\n-\n-        this.poller = new Poller(fs, this, ifd, sp);\n+        this.poller = new Poller(fs, this);\n@@ -144,1 +126,1 @@\n-    private static class Poller extends AbstractPoller {\n+    private static class Poller extends AbstractPoller implements JDKResource {\n@@ -174,0 +156,8 @@\n+        private enum CheckpointRestoreState {\n+            NORMAL_OPERATION,\n+            CHECKPOINT_TRANSITION,\n+            CHECKPOINTED,\n+            CHECKPOINT_ERROR,\n+            RESTORE_TRANSITION,\n+        }\n+\n@@ -178,1 +168,1 @@\n-        private final int ifd;\n+        private int ifd;\n@@ -180,1 +170,1 @@\n-        private final int socketpair[];\n+        private int socketpair[];\n@@ -185,0 +175,2 @@\n+        private volatile CheckpointRestoreState checkpointState = CheckpointRestoreState.NORMAL_OPERATION;\n+\n@@ -186,1 +178,3 @@\n-        Poller(UnixFileSystem fs, LinuxWatchService watcher, int ifd, int[] sp) {\n+        Poller(UnixFileSystem fs, LinuxWatchService watcher) throws IOException {\n+            this.socketpair = new int[2];\n+            initFDs();\n@@ -189,2 +183,0 @@\n-            this.ifd = ifd;\n-            this.socketpair = sp;\n@@ -193,0 +185,59 @@\n+            jdk.internal.crac.Core.getJDKContext().register(this);\n+        }\n+\n+        private void initFDs() throws IOException {\n+            \/\/ initialize inotify\n+            try {\n+                this.ifd = inotifyInit();\n+            } catch (UnixException x) {\n+                String msg = (x.errno() == EMFILE) ?\n+                        \"User limit of inotify instances reached or too many open files\" :\n+                        x.errorString();\n+                throw new IOException(msg);\n+            }\n+\n+            \/\/ configure inotify to be non-blocking\n+            \/\/ create socketpair used in the close mechanism\n+            try {\n+                configureBlocking(ifd, false);\n+                socketpair(this.socketpair);\n+                configureBlocking(this.socketpair[0], false);\n+            } catch (UnixException x) {\n+                UnixNativeDispatcher.close(ifd);\n+                throw new IOException(x.errorString());\n+            }\n+        }\n+\n+        private boolean processCheckpointRestore() throws IOException {\n+            if (checkpointState != CheckpointRestoreState.CHECKPOINT_TRANSITION) {\n+                return false;\n+            }\n+\n+            synchronized (this) {\n+                CheckpointRestoreState thisState;\n+                if (wdToKey.size() == 0) {\n+                    unsafe.freeMemory(address);\n+                    UnixNativeDispatcher.close(socketpair[0]);\n+                    UnixNativeDispatcher.close(socketpair[1]);\n+                    UnixNativeDispatcher.close(ifd);\n+                    thisState = CheckpointRestoreState.CHECKPOINTED;\n+                } else {\n+                    thisState = CheckpointRestoreState.CHECKPOINT_ERROR;\n+                }\n+\n+                checkpointState = thisState;\n+                this.notifyAll();\n+                while (checkpointState == thisState) {\n+                    try {\n+                        this.wait();\n+                    } catch (InterruptedException e) {\n+                    }\n+                }\n+                assert checkpointState == CheckpointRestoreState.RESTORE_TRANSITION;\n+                if (thisState == CheckpointRestoreState.CHECKPOINTED) {\n+                    initFDs();\n+                }\n+                checkpointState = CheckpointRestoreState.NORMAL_OPERATION;\n+                this.notifyAll();\n+            }\n+            return true;\n@@ -314,1 +365,7 @@\n-                    nReady = poll(ifd, socketpair[0]);\n+                    try {\n+                        do {\n+                            nReady = poll(ifd, socketpair[0]);\n+                        } while (processCheckpointRestore());\n+                    } catch (IOException e) {\n+                        throw new Error(\"IOException in inotify processCheckpointRestore\", e);\n+                    }\n@@ -434,0 +491,50 @@\n+\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+            if (!watcher.isOpen()) {\n+                return;\n+            }\n+\n+            synchronized (this) {\n+                checkpointState = CheckpointRestoreState.CHECKPOINT_TRANSITION;\n+                wakeup();\n+                while (checkpointState == CheckpointRestoreState.CHECKPOINT_TRANSITION) {\n+                    try {\n+                        this.wait();\n+                    } catch (InterruptedException e) {\n+                        checkpointState = CheckpointRestoreState.CHECKPOINT_ERROR;\n+                        throw e;\n+                    }\n+                }\n+                if (checkpointState == CheckpointRestoreState.CHECKPOINT_ERROR) {\n+                    throw new CheckpointException(\"LinuxWatchService.processCheckpointRestore with keys\");\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public void afterRestore(Context<? extends Resource> context) throws Exception {\n+            if (!watcher.isOpen()) {\n+                return;\n+            }\n+            synchronized (this) {\n+                checkpointState = CheckpointRestoreState.RESTORE_TRANSITION;\n+                this.notifyAll();\n+                while (checkpointState == CheckpointRestoreState.RESTORE_TRANSITION) {\n+                    try {\n+                        this.wait();\n+                    } catch (InterruptedException e) {\n+                        checkpointState = CheckpointRestoreState.CHECKPOINT_ERROR;\n+                        throw e;\n+                    }\n+                }\n+                if (checkpointState != CheckpointRestoreState.NORMAL_OPERATION) {\n+                    throw new CheckpointException(\"LinuxWatchService restore exception\");\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public Priority getPriority() {\n+            return Priority.NORMAL;\n+        }\n","filename":"src\/java.base\/linux\/classes\/sun\/nio\/fs\/LinuxWatchService.java","additions":138,"deletions":31,"binary":false,"changes":169,"status":"modified"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.Core;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.*;\n+import java.util.Objects;\n+import java.util.concurrent.TimeUnit;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @build FileWatcherAfterRestoreTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class FileWatcherAfterRestoreTest implements CracTest {\n+    @Override\n+    public void test() throws Exception {\n+        CracBuilder builder = new CracBuilder();\n+        builder.doCheckpoint();\n+        Path checkPath = Paths.get(System.getProperty(\"user.dir\"), \"workdir\");\n+        for (File f : Objects.requireNonNull(checkPath.toFile().listFiles())) {\n+            f.delete();\n+        }\n+        Files.delete(checkPath);\n+        builder.doRestore();\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        WatchService watchService = FileSystems.getDefault().newWatchService();\n+        Path directory;\n+        WatchKey key;\n+\n+        directory = Paths.get(System.getProperty(\"user.dir\"), \"workdir\");\n+        directory.toFile().mkdir();\n+        Asserts.assertTrue(isMatchFound(watchService, directory));\n+\n+        Core.checkpointRestore();\n+\n+        directory = Paths.get(System.getProperty(\"user.dir\"), \"workdir\");\n+        \/\/ fix monitor dir after restore\n+        if (!directory.toFile().exists()) {\n+            directory = Paths.get(\"\/tmp\");\n+        }\n+\n+        Asserts.assertTrue(isMatchFound(watchService, directory));\n+        watchService.close();\n+    }\n+\n+    private boolean isMatchFound(WatchService watchService, Path directory) throws IOException, InterruptedException {\n+        WatchKey key;\n+        boolean matchFound;\n+        WatchKey watchKey = directory.register(watchService, StandardWatchEventKinds.ENTRY_CREATE);\n+        Files.createTempFile(directory, \"temp\", \".txt\");\n+        matchFound = false;\n+        while ((key = watchService.poll(1, TimeUnit.SECONDS)) != null) {\n+            for (WatchEvent<?> event : key.pollEvents()) {\n+                if (event.kind() == StandardWatchEventKinds.ENTRY_CREATE) {\n+                    Object context = event.context();\n+                    if (context instanceof Path filePath) {\n+                        String fileName = filePath.getFileName().toString();\n+                        if (fileName.matches(\"^temp\\\\d*\\\\.txt$\")) {\n+                            matchFound = true;\n+                            break;\n+                        }\n+                    }\n+                }\n+            }\n+            key.reset();\n+            if (matchFound) {\n+                break;\n+            }\n+        }\n+        watchKey.cancel();\n+        return matchFound;\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/FileWatcherAfterRestoreTest.java","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.Core;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracProcess;\n+import jdk.test.lib.crac.CracTest;\n+\n+import java.nio.file.*;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @build FileWatcherWithOpenKeysTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class FileWatcherWithOpenKeysTest implements CracTest {\n+\n+    @Override\n+    public void test() throws Exception {\n+        CracProcess cp = new CracBuilder().captureOutput(true)\n+                .startCheckpoint();\n+        cp.outputAnalyzer()\n+                .shouldHaveExitValue(1)\n+                .shouldContain(\"CheckpointOpenSocketException\");\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        WatchService watchService = FileSystems.getDefault().newWatchService();\n+        Path directory = Paths.get(System.getProperty(\"user.dir\"));\n+        directory.register(watchService, StandardWatchEventKinds.ENTRY_MODIFY);\n+        Core.checkpointRestore();\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/FileWatcherWithOpenKeysTest.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"}]}