{"files":[{"patch":"@@ -77,0 +77,1 @@\n+    -tag crac:cmopt:'CRaC:' \\\n","filename":"make\/Docs.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -58,0 +58,3 @@\n+ *\n+ * @crac The file descriptor(s) used internally by this class are automatically\n+ * closed before checkpointing the process and opened after the restore.\n@@ -59,1 +62,0 @@\n-\n","filename":"src\/java.base\/linux\/classes\/sun\/nio\/ch\/EPollSelectorImpl.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -546,0 +546,5 @@\n+     * @crac When the process is restored on another machine or if the machine\n+     * rebooted the value is updated based on wall-clock time difference,\n+     * resulting in a loss of accuracy when comparing timestamps obtained\n+     * before and after checkpoint.\n+     *\n@@ -782,0 +787,7 @@\n+     * @crac While the API note above discourages from changing system properties during\n+     * runtime it is actually quite common after restore from a checkpoint. The application\n+     * can {@link javax.crac.Context#register(javax.crac.Resource) register}\n+     * a resource and reload system properties in the\n+     * {@link javax.crac.Resource#afterRestore(javax.crac.Context) afterRestore method},\n+     * updating the application.\n+     *\n@@ -896,0 +908,4 @@\n+     * @crac While the API note above discourages from changing system properties during\n+     * runtime it is actually quite common after restore from a checkpoint.\n+     * See {@linkplain #getProperties getProperties} for details.\n+     *\n@@ -932,0 +948,4 @@\n+     * @crac While traditionally it is discouraged to change system properties during\n+     * runtime it is actually quite common after restore from a checkpoint.\n+     * See {@linkplain #getProperties getProperties} for details.\n+     *\n@@ -1086,0 +1106,7 @@\n+     * @crac While environment variables are typically constant through\n+     * the lifetime of a process these can change after restore from\n+     * a checkpoint. The application can {@link javax.crac.Context#register(javax.crac.Resource) register}\n+     * a resource and reload environment variables in the\n+     * {@link javax.crac.Resource#afterRestore(javax.crac.Context) afterRestore method},\n+     * updating the application.\n+     *\n@@ -1139,0 +1166,7 @@\n+     * @crac While environment variables are typically constant through\n+     * the lifetime of a process these can change after restore from\n+     * a checkpoint. The application can {@link javax.crac.Context#register(javax.crac.Resource) register}\n+     * a resource and reload the environment variables in the\n+     * {@link javax.crac.Resource#afterRestore(javax.crac.Context) afterRestore method},\n+     * updating the application.\n+     *\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -195,0 +195,6 @@\n+ * @crac This class holds a cache of resolved hostname-address pairs;\n+ * this cache is wiped out before checkpoint. Therefore, lookups after restore\n+ * will cause name address resolution.\n+ * This ensures that the addresses are up-to-date in the environment where\n+ * the process is restored.\n+ *\n","filename":"src\/java.base\/share\/classes\/java\/net\/InetAddress.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -217,0 +217,4 @@\n+     *\n+     * @crac Instances created by this constructor are automatically reseeded\n+     * after restore from a checkpoint.\n+     * See {@link sun.security.provider.SecureRandom} for details.\n@@ -259,0 +263,4 @@\n+     * @crac Instances created by this constructor are <strong>not<\/strong>\n+     * reseeded after restore from a checkpoint.\n+     * See {@link sun.security.provider.SecureRandom} for details.\n+     *\n@@ -358,0 +366,2 @@\n+     * @crac The checkpoint\/restore behaviour depends on security provider implementation.\n+     *\n@@ -405,0 +415,2 @@\n+     * @crac The checkpoint\/restore behaviour depends on security provider implementation.\n+     *\n@@ -449,0 +461,2 @@\n+     * @crac The checkpoint\/restore behaviour depends on security provider implementation.\n+     *\n@@ -496,0 +510,2 @@\n+     * @crac The checkpoint\/restore behaviour depends on security provider implementation.\n+     *\n@@ -553,0 +569,2 @@\n+     * @crac The checkpoint\/restore behaviour depends on security provider implementation.\n+     *\n@@ -606,0 +624,2 @@\n+     * @crac The checkpoint\/restore behaviour depends on security provider implementation.\n+     *\n","filename":"src\/java.base\/share\/classes\/java\/security\/SecureRandom.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -325,0 +325,5 @@\n+     * @crac Since the execution is suspended after a checkpoint the timer\n+     * could execute many times after a restore, catching up for all the\n+     * delayed executions. If this is not desirable the application can cancel\n+     * the task before checkpoint and schedule it again after restore.\n+     *\n@@ -369,0 +374,5 @@\n+     * @crac Since the execution is suspended after a checkpoint the timer\n+     * could execute many times after a restore, catching up for all the\n+     * delayed executions. If this is not desirable the application can cancel\n+     * the task before checkpoint and schedule it again after restore.\n+     *\n","filename":"src\/java.base\/share\/classes\/java\/util\/Timer.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -150,0 +150,5 @@\n+     * @crac Since the execution is suspended after a checkpoint the timer\n+     * could execute many times after a restore, catching up for all the\n+     * delayed executions. If this is not desirable the application can cancel\n+     * the task before checkpoint and schedule it again after restore.\n+     *\n@@ -189,0 +194,5 @@\n+     * @crac Since the execution is suspended after a checkpoint the timer\n+     * could execute many times after a restore, catching up for all the\n+     * delayed executions. If this is not desirable the application can cancel\n+     * the task before checkpoint and schedule it again after restore.\n+     *\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ScheduledExecutorService.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -39,0 +39,6 @@\n+\/**\n+ * @crac It is assumed that JAR files opened through this class that are open\n+ * during checkpoint will be present on same path in the filesystem after\n+ * restore. Therefore, application does <strong>not<\/strong> have to close\n+ * these files before a checkpoint.\n+ *\/\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/jar\/PersistentJarFile.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -56,0 +56,10 @@\n+ * @crac If this class is created using the {@link #SecureRandom() no-arg constructor}\n+ * and never {@link #engineSetSeed(byte[]) reseeded} it is automatically reseeded\n+ * after restore from a checkpoint. Therefore, after restore the sequences produced\n+ * during different runs should differ (and the application will consume system entropy).\n+ * If a seed was provided externally the application might depend on the sequence\n+ * produced by this generator, therefore it is not reseeded.\n+ * If this behaviour is not desired the application should {@link javax.crac.Context#register(javax.crac.Resource) register}\n+ * a resource and in the {@link javax.crac.Resource#afterRestore(javax.crac.Context) afterRestore method}\n+ * reseed it using the {@link #engineSetSeed(byte[])}.\n+ *\n@@ -91,0 +101,4 @@\n+     *\n+     * @crac Instances created using this constructor are automatically\n+     * reseeded upon restore from a checkpoint.\n+     * See {@link SecureRandom} for details.\n@@ -100,0 +114,4 @@\n+     * @crac Instances created using this constructor are <strong>not<\/strong>\n+     * reseeded upon restore from a checkpoint.\n+     * See {@link SecureRandom} for details.\n+     *\n@@ -163,0 +181,4 @@\n+     * @crac After this method is called the instance is <strong>not<\/strong>\n+     * reseeded upon restore from a checkpoint.\n+     * See {@link SecureRandom} for details.\n+     *\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/SecureRandom.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -37,0 +37,3 @@\n+ * @crac The socket is automatically closed before checkpoint and reopened\n+ * after restore; there is no handling needed from the application side.\n+ *\n","filename":"src\/java.base\/unix\/classes\/java\/net\/PlainSocketImpl.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -45,0 +45,3 @@\n+ * @crac All JarFile instances that are not referenced from elsewhere are\n+ * removed from the cache before a checkpoint.\n+ *\n","filename":"src\/java.base\/unix\/classes\/sun\/net\/www\/protocol\/jar\/JarFileFactory.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -78,0 +78,5 @@\n+ * @crac Before checkpoint the underlying random number generator is discarded\n+ * and after restore a new {@link sun.security.provider.SecureRandom} is\n+ * created, therefore this produces different sequences when restored multiple\n+ * times.\n+ *\n","filename":"src\/java.base\/unix\/classes\/sun\/security\/provider\/NativePRNG.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"}]}