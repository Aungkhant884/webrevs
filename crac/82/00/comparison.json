{"files":[{"patch":"@@ -25,2 +25,2 @@\n-      platform_windows_x64: ${{ false && steps.check_platforms.outputs.platform_windows_x64 }}\n-      platform_macos_x64: ${{ false && steps.check_platforms.outputs.platform_macos_x64 }}\n+      platform_windows_x64: ${{ steps.check_platforms.outputs.platform_windows_x64 }}\n+      platform_macos_x64: ${{ steps.check_platforms.outputs.platform_macos_x64 }}\n","filename":".github\/workflows\/submit.yml","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -104,0 +104,3 @@\n+endif\n+\n+ifeq ($(call isTargetOs, macosx linux), true)\n@@ -128,0 +131,27 @@\n+ifeq ($(OPENJDK_TARGET_OS), windows)\n+  $(eval $(call SetupJdkExecutable, BUILD_PAUSEENGINE, \\\n+      NAME := pauseengine, \\\n+      SRC := $(TOPDIR)\/src\/$(MODULE)\/windows\/native\/pauseengine, \\\n+      INCLUDE_FILES := pauseengine.c, \\\n+      OPTIMIZATION := LOW, \\\n+      CFLAGS := $(CFLAGS_JDKEXE), \\\n+      LDFLAGS := $(LDFLAGS_JDKEXE), \\\n+      OUTPUT_DIR := $(SUPPORT_OUTPUTDIR)\/modules_cmds\/$(MODULE), \\\n+  ))\n+  TARGETS += $(BUILD_PAUSEENGINE)\n+\n+  $(eval $(call SetupJdkExecutable, BUILD_SIMENGINE, \\\n+      NAME := simengine, \\\n+      SRC := $(TOPDIR)\/src\/$(MODULE)\/windows\/native\/simengine, \\\n+      INCLUDE_FILES := simengine.c, \\\n+      OPTIMIZATION := LOW, \\\n+      CFLAGS := $(CFLAGS_JDKEXE), \\\n+      LDFLAGS := $(LDFLAGS_JDKEXE), \\\n+      LIBS := advapi32.lib version.lib user32.lib, \\\n+      OUTPUT_DIR := $(SUPPORT_OUTPUTDIR)\/modules_cmds\/$(MODULE), \\\n+  ))\n+\n+  TARGETS += $(BUILD_SIMENGINE)\n+\n+endif\n+\n","filename":"make\/modules\/java.base\/Launcher.gmk","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-#include \"memory\/oopFactory.hpp\"\n@@ -51,0 +50,1 @@\n+#include \"runtime\/crac.hpp\"\n@@ -57,2 +57,0 @@\n-#include \"runtime\/jniHandles.hpp\"\n-#include \"runtime\/jniHandles.inline.hpp\"\n@@ -74,1 +72,0 @@\n-#include \"services\/heapDumper.hpp\"\n@@ -77,1 +74,0 @@\n-#include \"services\/writeableFlags.hpp\"\n@@ -249,163 +245,0 @@\n-struct CracFailDep {\n-  int _type;\n-  char* _msg;\n-  CracFailDep(int type, char* msg) :\n-    _type(type),\n-    _msg(msg)\n-  { }\n-  CracFailDep() :\n-    _type(JVM_CR_FAIL),\n-    _msg(NULL)\n-  { }\n-};\n-\n-class CracRestoreParameters : public CHeapObj<mtInternal> {\n-  char* _raw_content;\n-  GrowableArray<const char *>* _properties;\n-  const char* _args;\n-\n-  struct header {\n-    jlong _restore_time;\n-    jlong _restore_counter;\n-    int _nflags;\n-    int _nprops;\n-    int _env_memory_size;\n-  };\n-\n-  static bool write_check_error(int fd, const void *buf, int count) {\n-    int wret = write(fd, buf, count);\n-    if (wret != count) {\n-      if (wret < 0) {\n-        perror(\"shm error\");\n-      } else {\n-        fprintf(stderr, \"write shm truncated\");\n-      }\n-      return false;\n-    }\n-    return true;\n-  }\n-\n-  static int system_props_length(const SystemProperty* props) {\n-    int len = 0;\n-    while (props != NULL) {\n-      ++len;\n-      props = props->next();\n-    }\n-    return len;\n-  }\n-\n-  static int env_vars_size(const char* const * env) {\n-    int len = 0;\n-    for (; *env; ++env) {\n-      len += strlen(*env) + 1;\n-    }\n-    return len;\n-  }\n-\n- public:\n-  const char *args() const { return _args; }\n-  GrowableArray<const char *>* properties() const { return _properties; }\n-\n-  CracRestoreParameters() :\n-    _raw_content(NULL),\n-    _properties(new (ResourceObj::C_HEAP, mtInternal) GrowableArray<const char *>(0, mtInternal)),\n-    _args(NULL)\n-  {}\n-\n-  ~CracRestoreParameters() {\n-    if (_raw_content) {\n-      FREE_C_HEAP_ARRAY(char, _raw_content);\n-    }\n-    delete _properties;\n-  }\n-\n-  static bool write_to(int fd,\n-      const char* const* flags, int num_flags,\n-      const SystemProperty* props,\n-      const char *args,\n-      jlong restore_time,\n-      jlong restore_counter) {\n-    header hdr = {\n-      restore_time,\n-      restore_counter,\n-      num_flags,\n-      system_props_length(props),\n-      env_vars_size(environ)\n-    };\n-\n-    if (!write_check_error(fd, (void *)&hdr, sizeof(header))) {\n-      return false;\n-    }\n-\n-    for (int i = 0; i < num_flags; ++i) {\n-      if (!write_check_error(fd, flags[i], strlen(flags[i]) + 1)) {\n-        return false;\n-      }\n-    }\n-\n-    const SystemProperty* p = props;\n-    while (p != NULL) {\n-      char prop[4096];\n-      int len = snprintf(prop, sizeof(prop), \"%s=%s\", p->key(), p->value());\n-      guarantee((0 < len) && ((unsigned)len < sizeof(prop)), \"property does not fit temp buffer\");\n-      if (!write_check_error(fd, prop, len+1)) {\n-        return false;\n-      }\n-      p = p->next();\n-    }\n-\n-    \/\/ Write env vars\n-    for (char** env = environ; *env; ++env) {\n-      if (!write_check_error(fd, *env, strlen(*env) + 1)) {\n-        return false;\n-      }\n-    }\n-\n-    return write_check_error(fd, args, strlen(args)+1); \/\/ +1 for null char\n-  }\n-\n-  bool read_from(int fd);\n-\n-};\n-\n-class VM_Crac: public VM_Operation {\n-  jarray _fd_arr;\n-  const bool _dry_run;\n-  bool _ok;\n-  GrowableArray<CracFailDep>* _failures;\n-  CracRestoreParameters _restore_parameters;\n-  outputStream* _ostream;\n-  LinuxAttachOperation* _attach_op;\n-\n-public:\n-  VM_Crac(jarray fd_arr, jobjectArray obj_arr, bool dry_run, bufferedStream* jcmd_stream) :\n-    _fd_arr(fd_arr),\n-    _dry_run(dry_run),\n-    _ok(false),\n-    _failures(new (ResourceObj::C_HEAP, mtInternal) GrowableArray<CracFailDep>(0, mtInternal)),\n-    _restore_parameters(),\n-    _ostream(jcmd_stream ? jcmd_stream : tty),\n-    _attach_op(jcmd_stream ? LinuxAttachListener::get_current_op() : NULL)\n-  { }\n-\n-  ~VM_Crac() {\n-    delete _failures;\n-  }\n-\n-  GrowableArray<CracFailDep>* failures() { return _failures; }\n-  bool ok() { return _ok; }\n-  const char* new_args() { return _restore_parameters.args(); }\n-  GrowableArray<const char *>* new_properties() { return _restore_parameters.properties(); }\n-  virtual bool allow_nested_vm_operations() const  { return true; }\n-  VMOp_Type type() const { return VMOp_VM_Crac; }\n-  void doit();\n-  bool read_shm(int shmid);\n-\n-private:\n-  bool is_claimed_fd(int fd);\n-  bool is_socket_from_jcmd(int sock_fd);\n-  void report_ok_to_jcmd_if_any();\n-  void print_resources(const char* msg, ...);\n-  void trace_cr(const char* msg, ...);\n-};\n-\n@@ -438,6 +271,0 @@\n-static const char* _crengine = NULL;\n-static char* _crengine_arg_str = NULL;\n-static unsigned int _crengine_argc = 0;\n-static const char* _crengine_args[32];\n-static jlong _restore_start_time;\n-static jlong _restore_start_counter;\n@@ -5705,34 +5532,1 @@\n-jlong os::Linux::restore_start_time() {\n-  if (!_restore_start_time) {\n-    return -1;\n-  }\n-  return _restore_start_time;\n-}\n-\n-jlong os::Linux::uptime_since_restore() {\n-  if (!_restore_start_counter) {\n-    return -1;\n-  }\n-  return javaTimeNanos() - _restore_start_counter;\n-}\n-\n-void VM_Crac::trace_cr(const char* msg, ...) {\n-  if (CRTrace) {\n-    va_list ap;\n-    va_start(ap, msg);\n-    _ostream->print(\"CR: \");\n-    _ostream->vprint_cr(msg, ap);\n-    va_end(ap);\n-  }\n-}\n-\n-void VM_Crac::print_resources(const char* msg, ...) {\n-  if (CRPrintResourcesOnCheckpoint) {\n-    va_list ap;\n-    va_start(ap, msg);\n-    _ostream->vprint(msg, ap);\n-    va_end(ap);\n-  }\n-}\n-\n-void os::Linux::vm_create_start() {\n+void os::vm_create_start() {\n@@ -5742,1 +5536,1 @@\n-  close_extra_descriptors();\n+  os::Linux::close_extra_descriptors();\n@@ -5866,178 +5660,0 @@\n-static int cr_util_path(char* path, int len) {\n-  os::jvm_path(path, len);\n-  \/\/ path is \"...\/lib\/server\/libjvm.so\"\n-  char *after_elem = NULL;\n-  for (int i = 0; i < 2; ++i) {\n-    after_elem = strrchr(path, '\/');\n-    *after_elem = '\\0';\n-  }\n-  return after_elem - path;\n-}\n-\n-static bool compute_crengine() {\n-  \/\/ release possible old copies\n-  os::free((char *) _crengine); \/\/ NULL is allowed\n-  _crengine = NULL;\n-  os::free((char *) _crengine_arg_str);\n-  _crengine_arg_str = NULL;\n-\n-  if (!CREngine) {\n-    return true;\n-  }\n-  char *exec = os::strdup_check_oom(CREngine);\n-  char *comma = strchr(exec, ',');\n-  if (comma != NULL) {\n-    *comma = '\\0';\n-    _crengine_arg_str = os::strdup_check_oom(comma + 1);\n-  }\n-  if (exec[0] == '\/') {\n-    _crengine = exec;\n-  } else {\n-    char path[JVM_MAXPATHLEN];\n-    int pathlen = cr_util_path(path, sizeof(path));\n-    strcat(path + pathlen, \"\/\");\n-    strcat(path + pathlen, exec);\n-\n-    struct stat st;\n-    if (0 != stat(path, &st)) {\n-      warning(\"Could not find %s: %s\", path, strerror(errno));\n-      return false;\n-    }\n-    _crengine = os::strdup_check_oom(path);\n-    \/\/ we have read and duplicated args from exec, now we can release\n-    os::free(exec);\n-  }\n-  _crengine_args[0] = _crengine;\n-  _crengine_argc = 2;\n-\n-  if (_crengine_arg_str != NULL) {\n-    char *arg = _crengine_arg_str;\n-    char *target = _crengine_arg_str;\n-    bool escaped = false;\n-    for (char *c = arg; *c != '\\0'; ++c) {\n-      if (_crengine_argc >= ARRAY_SIZE(_crengine_args) - 2) {\n-        warning(\"Too many options to CREngine; cannot proceed with these: %s\", arg);\n-        return false;\n-      }\n-      if (!escaped) {\n-        switch(*c) {\n-        case '\\\\':\n-          escaped = true;\n-          continue; \/\/ for\n-        case ',':\n-          *target++ = '\\0';\n-          _crengine_args[_crengine_argc++] = arg;\n-          arg = target;\n-          continue; \/\/ for\n-        }\n-      }\n-      escaped = false;\n-      *target++ = *c;\n-    }\n-    *target = '\\0';\n-    _crengine_args[_crengine_argc++] = arg;\n-    _crengine_args[_crengine_argc] = NULL;\n-  }\n-  return true;\n-}\n-\n-static void add_crengine_arg(const char *arg) {\n-  if (_crengine_argc >= ARRAY_SIZE(_crengine_args) - 1) {\n-      warning(\"Too many options to CREngine; cannot add %s\", arg);\n-      return;\n-  }\n-  _crengine_args[_crengine_argc++] = arg;\n-  _crengine_args[_crengine_argc] = NULL;\n-}\n-\n-static int call_crengine() {\n-  if (!_crengine) {\n-    return -1;\n-  }\n-\n-  pid_t pid = fork();\n-  if (pid == -1) {\n-    perror(\"cannot fork for crengine\");\n-    return -1;\n-  }\n-  if (pid == 0) {\n-    _crengine_args[1] = \"checkpoint\";\n-    add_crengine_arg(CRaCCheckpointTo);\n-    execv(_crengine, (char * const*)_crengine_args);\n-    perror(\"execv CREngine checkpoint\");\n-    exit(1);\n-  }\n-\n-  int status;\n-  int ret;\n-  do {\n-    ret = waitpid(pid, &status, 0);\n-  } while (ret == -1 && errno == EINTR);\n-\n-  if (ret == -1 || !WIFEXITED(status)) {\n-    return -1;\n-  }\n-  return WEXITSTATUS(status) == 0 ? 0 : -1;\n-}\n-\n-class CracSHM {\n-  char _path[128];\n-public:\n-  CracSHM(int id) {\n-    int shmpathlen = snprintf(_path, sizeof(_path), \"\/crac_%d\", id);\n-    if (shmpathlen < 0 || sizeof(_path) <= (size_t)shmpathlen) {\n-      fprintf(stderr, \"shmpath is too long: %d\\n\", shmpathlen);\n-    }\n-  }\n-\n-  int open(int mode) {\n-    int shmfd = shm_open(_path, mode, 0600);\n-    if (-1 == shmfd) {\n-      perror(\"shm_open\");\n-    }\n-    return shmfd;\n-  }\n-\n-  void unlink() {\n-    shm_unlink(_path);\n-  }\n-};\n-\n-static int checkpoint_restore(int *shmid) {\n-\n-  int cres = call_crengine();\n-  if (cres < 0) {\n-    return JVM_CHECKPOINT_ERROR;\n-  }\n-\n-  sigset_t waitmask;\n-  sigemptyset(&waitmask);\n-  sigaddset(&waitmask, RESTORE_SIGNAL);\n-\n-  siginfo_t info;\n-  int sig;\n-  do {\n-    sig = sigwaitinfo(&waitmask, &info);\n-  } while (sig == -1 && errno == EINTR);\n-  assert(sig == RESTORE_SIGNAL, \"got what requested\");\n-\n-  if (CRTraceStartupTime) {\n-    tty->print_cr(\"STARTUPTIME \" JLONG_FORMAT \" restore-native\", os::javaTimeNanos());\n-  }\n-\n-  if (info.si_code != SI_QUEUE || info.si_int < 0) {\n-    tty->print(\"JVM: invalid info for restore provided: %s\", info.si_code == SI_QUEUE ? \"queued\" : \"not queued\");\n-    if (info.si_code == SI_QUEUE) {\n-      tty->print(\" code %d\", info.si_int);\n-    }\n-    tty->cr();\n-    return JVM_CHECKPOINT_ERROR;\n-  }\n-\n-  if (0 < info.si_int) {\n-    *shmid = info.si_int;\n-  }\n-\n-  return JVM_CHECKPOINT_OK;\n-}\n-\n@@ -6076,12 +5692,0 @@\n-bool VM_Crac::read_shm(int shmid) {\n-  CracSHM shm(shmid);\n-  int shmfd = shm.open(O_RDONLY);\n-  shm.unlink();\n-  if (shmfd < 0) {\n-    return false;\n-  }\n-  bool ret = _restore_parameters.read_from(shmfd);\n-  close(shmfd);\n-  return ret;\n-}\n-\n@@ -6105,12 +5709,1 @@\n-bool VM_Crac::is_claimed_fd(int fd) {\n-  typeArrayOop claimed_fds = typeArrayOop(JNIHandles::resolve_non_null(_fd_arr));\n-  for (int j = 0; j < claimed_fds->length(); ++j) {\n-    jint cfd = claimed_fds->int_at(j);\n-    if (fd == cfd) {\n-      return true;\n-    }\n-  }\n-  return false;\n-}\n-\n-void VM_Crac::doit() {\n+bool VM_Crac::check_fds() {\n@@ -6165,61 +5758,1 @@\n-  if ((!ok || _dry_run) && CRHeapDumpOnCheckpointException) {\n-    HeapDumper::dump_heap();\n-  }\n-\n-  if (!ok && CRDoThrowCheckpointException) {\n-    return;\n-  } else if (_dry_run) {\n-    _ok = ok;\n-    return;\n-  }\n-\n-  if (!PerfMemoryLinux::checkpoint(CRaCCheckpointTo)) {\n-    return;\n-  }\n-\n-  int shmid = 0;\n-  if (CRAllowToSkipCheckpoint) {\n-    trace_cr(\"Skip Checkpoint\");\n-  } else {\n-    trace_cr(\"Checkpoint ...\");\n-    report_ok_to_jcmd_if_any();\n-    int ret = checkpoint_restore(&shmid);\n-    if (ret == JVM_CHECKPOINT_ERROR) {\n-      PerfMemoryLinux::restore();\n-      return;\n-    }\n-  }\n-\n-  if (shmid <= 0 || !VM_Crac::read_shm(shmid)) {\n-    _restore_start_time = os::javaTimeMillis();\n-    _restore_start_counter = os::javaTimeNanos();\n-  }\n-  PerfMemoryLinux::restore();\n-\n-  _ok = true;\n-}\n-\n-bool os::Linux::prepare_checkpoint() {\n-  struct stat st;\n-\n-  if (0 == stat(CRaCCheckpointTo, &st)) {\n-    if ((st.st_mode & S_IFMT) != S_IFDIR) {\n-      warning(\"%s: not a directory\", CRaCCheckpointTo);\n-      return false;\n-    }\n-  } else {\n-    if (-1 == mkdir(CRaCCheckpointTo, 0700)) {\n-      warning(\"cannot create %s: %s\", CRaCCheckpointTo, strerror(errno));\n-      return false;\n-    }\n-    if (-1 == rmdir(CRaCCheckpointTo)) {\n-      warning(\"cannot cleanup after check: %s\", strerror(errno));\n-      \/\/ not fatal\n-    }\n-  }\n-\n-  if (!compute_crengine()) {\n-    return false;\n-  }\n-\n-  return true;\n+  return ok;\n@@ -6228,11 +5761,2 @@\n-static Handle ret_cr(int ret, Handle new_args, Handle new_props, Handle err_codes, Handle err_msgs, TRAPS) {\n-  objArrayOop bundleObj = oopFactory::new_objectArray(5, CHECK_NH);\n-  objArrayHandle bundle(THREAD, bundleObj);\n-  jvalue jval = { .i = ret };\n-  oop retObj = java_lang_boxing_object::create(T_INT, &jval, CHECK_NH);\n-  bundle->obj_at_put(0, retObj);\n-  bundle->obj_at_put(1, new_args());\n-  bundle->obj_at_put(2, new_props());\n-  bundle->obj_at_put(3, err_codes());\n-  bundle->obj_at_put(4, err_msgs());\n-  return bundle;\n+bool VM_Crac::memory_checkpoint() {\n+  return PerfMemoryLinux::checkpoint(CRaCCheckpointTo);\n@@ -6241,87 +5765,2 @@\n-\/** Checkpoint main entry.\n- *\/\n-Handle os::Linux::checkpoint(jarray fd_arr, jobjectArray obj_arr, bool dry_run, jlong jcmd_stream, TRAPS) {\n-  if (!CRaCCheckpointTo) {\n-    return ret_cr(JVM_CHECKPOINT_NONE, Handle(), Handle(), Handle(), Handle(), THREAD);\n-  }\n-\n-  if (-1 == mkdir(CRaCCheckpointTo, 0700) && errno != EEXIST) {\n-    warning(\"cannot create %s: %s\", CRaCCheckpointTo, strerror(errno));\n-    return ret_cr(JVM_CHECKPOINT_NONE, Handle(), Handle(), Handle(), Handle(), THREAD);\n-  }\n-\n-  Universe::heap()->set_cleanup_unused(true);\n-  Universe::heap()->collect(GCCause::_full_gc_alot);\n-  Universe::heap()->set_cleanup_unused(false);\n-\n-  VM_Crac cr(fd_arr, obj_arr, dry_run, (bufferedStream*)jcmd_stream);\n-  {\n-    MutexLocker ml(Heap_lock);\n-    VMThread::execute(&cr);\n-  }\n-  if (cr.ok()) {\n-    oop new_args = NULL;\n-    if (cr.new_args()) {\n-      new_args = java_lang_String::create_oop_from_str(cr.new_args(), CHECK_NH);\n-    }\n-    GrowableArray<const char *>* new_properties = cr.new_properties();\n-    objArrayOop propsObj = oopFactory::new_objArray(vmClasses::String_klass(), new_properties->length(), CHECK_NH);\n-    objArrayHandle props(THREAD, propsObj);\n-\n-    for (int i = 0; i < new_properties->length(); i++) {\n-      oop propObj = java_lang_String::create_oop_from_str(new_properties->at(i), CHECK_NH);\n-      props->obj_at_put(i, propObj);\n-    }\n-    return ret_cr(JVM_CHECKPOINT_OK, Handle(THREAD, new_args), props, Handle(), Handle(), THREAD);\n-  }\n-\n-  GrowableArray<CracFailDep>* failures = cr.failures();\n-\n-  typeArrayOop codesObj = oopFactory::new_intArray(failures->length(), CHECK_NH);\n-  typeArrayHandle codes(THREAD, codesObj);\n-  objArrayOop msgsObj = oopFactory::new_objArray(vmClasses::String_klass(), failures->length(), CHECK_NH);\n-  objArrayHandle msgs(THREAD, msgsObj);\n-\n-  for (int i = 0; i < failures->length(); ++i) {\n-    codes->int_at_put(i, failures->at(i)._type);\n-    oop msgObj = java_lang_String::create_oop_from_str(failures->at(i)._msg, CHECK_NH);\n-    FREE_C_HEAP_ARRAY(char, failures->at(i)._msg);\n-    msgs->obj_at_put(i, msgObj);\n-  }\n-\n-  return ret_cr(JVM_CHECKPOINT_ERROR, Handle(), Handle(), codes, msgs, THREAD);\n-}\n-\n-void os::Linux::restore() {\n-  struct stat st;\n-\n-  jlong restore_time = javaTimeMillis();\n-  jlong restore_counter = javaTimeNanos();\n-\n-  compute_crengine();\n-\n-  int id = getpid();\n-  CracSHM shm(id);\n-  int shmfd = shm.open(O_RDWR | O_CREAT);\n-  if (0 <= shmfd) {\n-    if (CracRestoreParameters::write_to(\n-          shmfd,\n-          Arguments::jvm_flags_array(), Arguments::num_jvm_flags(),\n-          Arguments::system_properties(),\n-          Arguments::java_command() ? Arguments::java_command() : \"\",\n-          restore_time,\n-          restore_counter)) {\n-      char strid[32];\n-      snprintf(strid, sizeof(strid), \"%d\", id);\n-      setenv(\"CRAC_NEW_ARGS_ID\", strid, true);\n-    }\n-    close(shmfd);\n-  }\n-\n-\n-  if (_crengine) {\n-    _crengine_args[1] = \"restore\";\n-    add_crengine_arg(CRaCRestoreFrom);\n-    execv(_crengine, (char * const*) _crengine_args);\n-    warning(\"cannot execute \\\"%s restore ...\\\" (%s)\", _crengine, strerror(errno));\n-  }\n+void VM_Crac::memory_restore() {\n+  PerfMemoryLinux::restore();\n@@ -6394,72 +5833,0 @@\n-bool CracRestoreParameters::read_from(int fd) {\n-  struct stat st;\n-  if (fstat(fd, &st)) {\n-    perror(\"fstat (ignoring restore parameters)\");\n-    return false;\n-  }\n-\n-  char *contents = NEW_C_HEAP_ARRAY(char, st.st_size, mtInternal);\n-  if (read(fd, contents, st.st_size) < 0) {\n-    perror(\"read (ignoring restore parameters)\");\n-    FREE_C_HEAP_ARRAY(char, contents);\n-    return false;\n-  }\n-\n-  _raw_content = contents;\n-\n-  \/\/ parse the contents to read new system properties and arguments\n-  header* hdr = (header*)_raw_content;\n-  char* cursor = _raw_content + sizeof(header);\n-\n-  ::_restore_start_time = hdr->_restore_time;\n-  ::_restore_start_counter = hdr->_restore_counter;\n-\n-  for (int i = 0; i < hdr->_nflags; i++) {\n-    FormatBuffer<80> err_msg(\"%s\", \"\");\n-    JVMFlag::Error result;\n-    const char *name = cursor;\n-    if (*cursor == '+' || *cursor == '-') {\n-      name = cursor + 1;\n-      result = WriteableFlags::set_flag(name, *cursor == '+' ? \"true\" : \"false\",\n-        JVMFlagOrigin::CRAC_RESTORE, err_msg);\n-      cursor += strlen(cursor) + 1;\n-    } else {\n-      char* eq = strchrnul(cursor, '=');\n-      if (*eq == '\\0') {\n-        result = JVMFlag::Error::MISSING_VALUE;\n-        cursor = eq + 1;\n-      } else {\n-        *eq = '\\0';\n-        char* value = eq + 1;\n-        result = WriteableFlags::set_flag(cursor, value, JVMFlagOrigin::CRAC_RESTORE, err_msg);\n-        cursor = value + strlen(value) + 1;\n-      }\n-    }\n-    guarantee(result == JVMFlag::Error::SUCCESS, \"VM Option '%s' cannot be changed: %s\",\n-        name, JVMFlag::flag_error_str(result));\n-  }\n-\n-  for (int i = 0; i < hdr->_nprops; i++) {\n-    assert((cursor + strlen(cursor) <= contents + st.st_size), \"property length exceeds shared memory size\");\n-    int idx = _properties->append(cursor);\n-    int prop_len = strlen(cursor) + 1;\n-    cursor = cursor + prop_len;\n-  }\n-\n-  char* env_mem = NEW_C_HEAP_ARRAY(char, hdr->_env_memory_size, mtArguments); \/\/ left this pointer unowned, it is freed when process dies\n-  memcpy(env_mem, cursor, hdr->_env_memory_size);\n-\n-  const char* env_end = env_mem + hdr->_env_memory_size;\n-  while (env_mem < env_end) {\n-    const size_t s = strlen(env_mem) + 1;\n-    assert(env_mem + s <= env_end, \"env vars exceed memory buffer, maybe ending 0 is lost\");\n-    putenv(env_mem);\n-    env_mem += s;\n-  }\n-  cursor += hdr->_env_memory_size;\n-\n-  _args = cursor;\n-  return true;\n-}\n-\n-\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":9,"deletions":642,"binary":false,"changes":651,"status":"modified"},{"patch":"@@ -174,4 +174,0 @@\n-  static void vm_create_start();\n-  static bool prepare_checkpoint();\n-  static Handle checkpoint(jarray fd_arr, jobjectArray obj_arr, bool dry_run, jlong jcmd_stream, TRAPS);\n-  static void restore();\n@@ -180,3 +176,0 @@\n-  static jlong restore_start_time();\n-  static jlong uptime_since_restore();\n-\n","filename":"src\/hotspot\/os\/linux\/os_linux.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -94,1 +94,1 @@\n-#ifdef LINUX\n+#if defined(LINUX)\n@@ -96,0 +96,2 @@\n+#elif defined(__APPLE__)\n+#define RESTORE_SIGNAL   SIGUSR2\n","filename":"src\/hotspot\/os\/posix\/include\/jvm_md.h","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"runtime\/crac.hpp\"\n@@ -656,0 +657,4 @@\n+bool os::is_path_absolute(const char *path) {\n+  return (path && '\/' == path[0]);\n+}\n+\n@@ -682,0 +687,8 @@\n+int os::mkdir(const char *path) {\n+  return ::mkdir(path, 0700);\n+}\n+\n+int os::rmdir(const char *path) {\n+  return ::rmdir(path);\n+}\n+\n@@ -1935,0 +1948,26 @@\n+int os::exec_child_process_and_wait(const char *path, const char *argv[]) {\n+  char** env = os::get_environ();\n+\n+  pid_t pid = fork();\n+  if (pid == -1) {\n+    perror(\"cannot fork for crengine\");\n+    return -1;\n+  }\n+  if (pid == 0) {\n+    execve(path, (char* const*)argv, env);\n+    perror(\"execve\");\n+    exit(1);\n+  }\n+\n+  int status;\n+  int ret;\n+  do {\n+    ret = waitpid(pid, &status, 0);\n+  } while (ret == -1 && errno == EINTR);\n+\n+  if (ret == -1 || !WIFEXITED(status)) {\n+    return -1;\n+  }\n+  return WEXITSTATUS(status) == 0 ? 0 : -1;\n+}\n+\n@@ -1987,0 +2026,31 @@\n+\n+int CracSHM::open(int mode) {\n+  int shmfd = shm_open(_path, mode, 0600);\n+  if (-1 == shmfd) {\n+    perror(\"shm_open\");\n+  }\n+  return shmfd;\n+}\n+\n+void CracSHM::unlink() {\n+  shm_unlink(_path);\n+}\n+\n+#ifndef LINUX\n+void os::vm_create_start() {\n+}\n+\n+void VM_Crac::report_ok_to_jcmd_if_any() {\n+}\n+\n+bool VM_Crac::check_fds() {\n+  return true;\n+}\n+\n+bool VM_Crac::memory_checkpoint() {\n+  return true;\n+}\n+\n+void VM_Crac::memory_restore() {\n+}\n+#endif\n\\ No newline at end of file\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":70,"deletions":0,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-#include \"perfMemory_linux.hpp\"\n@@ -43,0 +42,4 @@\n+#ifdef LINUX\n+#include \"perfMemory_linux.hpp\"\n+#endif \/\/LINUX\n+\n@@ -1331,0 +1334,1 @@\n+#ifdef LINUX\n@@ -1428,0 +1432,1 @@\n+#endif \/\/LINUX\n","filename":"src\/hotspot\/os\/posix\/perfMemory_posix.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+#include \"runtime\/crac.hpp\"\n@@ -1329,0 +1330,27 @@\n+\/\/ NOTE: is_path_absolute() function implementation is mostly a copy from FileSystemSupport_md.c\n+\/\/ WinAPI has PathIsRelative() function for this purpose, however it causes linkage to Shlwapi.dll.\n+static int prefixLength(const char* path) {\n+    assert(1 == strlen(os::file_separator()), \"the file separator must be a single-char, not a string\");\n+    char c0, c1;\n+\n+    int n = (int)strlen(path);\n+    if (n == 0) return 0;\n+    c0 = path[0];\n+    c1 = (n > 1) ? path[1] : 0;\n+    if (c0 == *os::file_separator()) {\n+        if (c1 == *os::file_separator()) return 2;      \/* Absolute UNC pathname \"\\\\\\\\foo\" *\/\n+        return 1;                       \/* Drive-relative \"\\\\foo\" *\/\n+    }\n+    if (::isalpha(c0) && (c1 == ':')) {\n+        if ((n > 2) && (path[2] == *os::file_separator()))\n+            return 3;           \/* Absolute local pathname \"z:\\\\foo\" *\/\n+        return 2;                       \/* Directory-relative \"z:foo\" *\/\n+    }\n+    return 0;                   \/* Completely relative *\/\n+}\n+\n+bool os::is_path_absolute(const char *path) {\n+  int pl = prefixLength(path);\n+  return (((pl == 2) && (path[0] == *os::file_separator())) || (pl == 3));\n+}\n+\n@@ -4459,0 +4487,25 @@\n+int os::mkdir(const char *path) {\n+  errno_t err;\n+  wchar_t* wide_path = wide_abs_unc_path(path, err);\n+  if (wide_path == NULL) {\n+    errno = err;\n+    return -1;\n+  }\n+  int res = _wmkdir(wide_path);\n+  os::free(wide_path);\n+  return res;\n+}\n+\n+int os::rmdir(const char *path) {\n+  errno_t err;\n+  wchar_t* wide_path = wide_abs_unc_path(path, err);\n+  if (wide_path == NULL) {\n+    errno = err;\n+    return -1;\n+  }\n+  int res = _wrmdir(wide_path);\n+  os::free(wide_path);\n+  return res;\n+}\n+\n+\n@@ -5601,0 +5654,5 @@\n+int os::exec_child_process_and_wait(const char *path, const char *argv[]) {\n+  const int status = _spawnv(_P_WAIT, path, argv); \/\/ env is inherited by a child process\n+  return 0 == status ? 0 : -1;\n+}\n+\n@@ -6104,0 +6162,24 @@\n+\n+void os::vm_create_start() {\n+}\n+\n+void VM_Crac::report_ok_to_jcmd_if_any() {\n+}\n+\n+bool VM_Crac::check_fds() {\n+  return true;\n+}\n+\n+bool VM_Crac::memory_checkpoint() {\n+  return true;\n+}\n+\n+void VM_Crac::memory_restore() {\n+}\n+\n+int CracSHM::open(int mode) {\n+  return -1;\n+}\n+\n+void CracSHM::unlink() {\n+}\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":82,"deletions":0,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -3853,1 +3853,1 @@\n-  Handle ret = os::Linux::checkpoint(fd_arr, obj_arr, dry_run, jcmd_stream, CHECK_NULL);\n+  Handle ret = os::checkpoint(fd_arr, obj_arr, dry_run, jcmd_stream, CHECK_NULL);\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3235,1 +3235,1 @@\n-  if (CRaCCheckpointTo && !os::Linux::prepare_checkpoint()) {\n+  if (CRaCCheckpointTo && !os::prepare_checkpoint()) {\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,222 @@\n+\/*\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_RUNTIME_CRAC_HPP\n+#define SHARE_RUNTIME_CRAC_HPP\n+\n+#include \"arguments.hpp\"\n+#include \"jvm.h\"\n+#include \"utilities\/growableArray.hpp\"\n+#include \"vmOperation.hpp\"\n+\n+#ifdef LINUX\n+#include \"attachListener_linux.hpp\"\n+#include \"linuxAttachOperation.hpp\"\n+#endif \/\/LINUX\n+\n+class CracRestoreParameters : public CHeapObj<mtInternal> {\n+  char* _raw_content;\n+  GrowableArray<const char *>* _properties;\n+  const char* _args;\n+\n+  struct header {\n+    jlong _restore_time;\n+    jlong _restore_counter;\n+    int _nflags;\n+    int _nprops;\n+    int _env_memory_size;\n+  };\n+\n+  static bool write_check_error(int fd, const void *buf, int count) {\n+    int wret = write(fd, buf, count);\n+    if (wret != count) {\n+      if (wret < 0) {\n+        perror(\"shm error\");\n+      } else {\n+        fprintf(stderr, \"write shm truncated\");\n+      }\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  static int system_props_length(const SystemProperty* props) {\n+    int len = 0;\n+    while (props != NULL) {\n+      ++len;\n+      props = props->next();\n+    }\n+    return len;\n+  }\n+\n+  static int env_vars_size(const char* const * env) {\n+    int len = 0;\n+    for (; *env; ++env) {\n+      len += (int)strlen(*env) + 1;\n+    }\n+    return len;\n+  }\n+\n+ public:\n+  const char *args() const { return _args; }\n+  GrowableArray<const char *>* properties() const { return _properties; }\n+\n+  CracRestoreParameters() :\n+    _raw_content(NULL),\n+    _properties(new (ResourceObj::C_HEAP, mtInternal) GrowableArray<const char *>(0, mtInternal)),\n+    _args(NULL)\n+  {}\n+\n+  ~CracRestoreParameters() {\n+    if (_raw_content) {\n+      FREE_C_HEAP_ARRAY(char, _raw_content);\n+    }\n+    delete _properties;\n+  }\n+\n+  static bool write_to(int fd,\n+      const char* const* flags, int num_flags,\n+      const SystemProperty* props,\n+      const char *args,\n+      jlong restore_time,\n+      jlong restore_counter) {\n+    header hdr = {\n+      restore_time,\n+      restore_counter,\n+      num_flags,\n+      system_props_length(props),\n+      env_vars_size(os::get_environ())\n+    };\n+\n+    if (!write_check_error(fd, (void *)&hdr, sizeof(header))) {\n+      return false;\n+    }\n+\n+    for (int i = 0; i < num_flags; ++i) {\n+      if (!write_check_error(fd, flags[i], (int)strlen(flags[i]) + 1)) {\n+        return false;\n+      }\n+    }\n+\n+    const SystemProperty* p = props;\n+    while (p != NULL) {\n+      char prop[4096];\n+      int len = snprintf(prop, sizeof(prop), \"%s=%s\", p->key(), p->value());\n+      guarantee((0 < len) && ((unsigned)len < sizeof(prop)), \"property does not fit temp buffer\");\n+      if (!write_check_error(fd, prop, len+1)) {\n+        return false;\n+      }\n+      p = p->next();\n+    }\n+\n+    \/\/ Write env vars\n+    for (char** env = os::get_environ(); *env; ++env) {\n+      if (!write_check_error(fd, *env, (int)strlen(*env) + 1)) {\n+        return false;\n+      }\n+    }\n+\n+    return write_check_error(fd, args, (int)strlen(args)+1); \/\/ +1 for null char\n+  }\n+\n+  bool read_from(int fd);\n+\n+};\n+\n+struct CracFailDep {\n+  int _type;\n+  char* _msg;\n+  CracFailDep(int type, char* msg) :\n+    _type(type),\n+    _msg(msg)\n+  { }\n+  CracFailDep() :\n+    _type(JVM_CR_FAIL),\n+    _msg(NULL)\n+  { }\n+};\n+\n+class CracSHM {\n+  char _path[128];\n+public:\n+  CracSHM(int id) {\n+    int shmpathlen = snprintf(_path, sizeof(_path), \"\/crac_%d\", id);\n+    if (shmpathlen < 0 || sizeof(_path) <= (size_t)shmpathlen) {\n+      fprintf(stderr, \"shmpath is too long: %d\\n\", shmpathlen);\n+    }\n+  }\n+\n+  int open(int mode);\n+  void unlink();\n+};\n+\n+class VM_Crac: public VM_Operation {\n+  jarray _fd_arr;\n+  const bool _dry_run;\n+  bool _ok;\n+  GrowableArray<CracFailDep>* _failures;\n+  CracRestoreParameters _restore_parameters;\n+  outputStream* _ostream;\n+#ifdef LINUX\n+  LinuxAttachOperation* _attach_op;\n+#endif \/\/LINUX\n+\n+public:\n+  VM_Crac(jarray fd_arr, jobjectArray obj_arr, bool dry_run, bufferedStream* jcmd_stream) :\n+    _fd_arr(fd_arr),\n+    _dry_run(dry_run),\n+    _ok(false),\n+    _failures(new (ResourceObj::C_HEAP, mtInternal) GrowableArray<CracFailDep>(0, mtInternal)),\n+    _restore_parameters(),\n+    _ostream(jcmd_stream ? jcmd_stream : tty)\n+#ifdef LINUX\n+    , _attach_op(jcmd_stream ? LinuxAttachListener::get_current_op() : NULL)\n+#endif \/\/LINUX\n+  { }\n+\n+  ~VM_Crac() {\n+    delete _failures;\n+  }\n+\n+  GrowableArray<CracFailDep>* failures() { return _failures; }\n+  bool ok() { return _ok; }\n+  const char* new_args() { return _restore_parameters.args(); }\n+  GrowableArray<const char *>* new_properties() { return _restore_parameters.properties(); }\n+  virtual bool allow_nested_vm_operations() const  { return true; }\n+  VMOp_Type type() const { return VMOp_VM_Crac; }\n+  void doit();\n+  bool read_shm(int shmid);\n+\n+private:\n+  bool is_claimed_fd(int fd);\n+  bool is_socket_from_jcmd(int sock_fd);\n+  void report_ok_to_jcmd_if_any();\n+  void print_resources(const char* msg, ...);\n+  void trace_cr(const char* msg, ...);\n+  bool check_fds();\n+  bool memory_checkpoint();\n+  void memory_restore();\n+};\n+\n+#endif \/\/ SHARE_RUNTIME_CRAC_HPP\n","filename":"src\/hotspot\/share\/runtime\/crac.hpp","additions":222,"deletions":0,"binary":false,"changes":222,"status":"added"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"crac.hpp\"\n@@ -42,0 +43,1 @@\n+#include \"memory\/oopFactory.hpp\"\n@@ -55,0 +57,1 @@\n+#include \"runtime\/jniHandles.inline.hpp\"\n@@ -65,0 +68,1 @@\n+#include \"services\/heapDumper.hpp\"\n@@ -69,0 +73,1 @@\n+#include \"services\/writeableFlags.hpp\"\n@@ -78,0 +83,4 @@\n+#ifdef _WINDOWS\n+#include <process.h>\n+#endif \/\/LINUX\n+\n@@ -94,0 +103,5 @@\n+\/\/ CRaC\n+static const char* _crengine = NULL;\n+static jlong _restore_start_time;\n+static jlong _restore_start_counter;\n+\n@@ -2026,0 +2040,426 @@\n+\n+#if defined(__APPLE__) || defined(_WINDOWS)\n+static char * strchrnul(char * str, char c) {\n+  for (; *str && c != *str; ++str) {}\n+  return str;\n+}\n+#endif \/\/__APPLE__ || _WINDOWS\n+\n+static size_t cr_util_path(char* path, int len) {\n+  os::jvm_path(path, len);\n+  \/\/ path is \"...\/lib\/server\/libjvm.so\", or \"...\\bin\\server\\libjvm.dll\"\n+  assert(1 == strlen(os::file_separator()), \"file separator must be a single-char, not a string\");\n+  char *after_elem = NULL;\n+  for (int i = 0; i < 2; ++i) {\n+    after_elem = strrchr(path, *os::file_separator());\n+    *after_elem = '\\0';\n+  }\n+  return after_elem - path;\n+}\n+\n+static bool compute_crengine() {\n+  if (!CREngine) {\n+    return true;\n+  }\n+\n+  if (os::is_path_absolute(CREngine)) {\n+    _crengine = CREngine;\n+    return true;\n+  }\n+\n+  char path[JVM_MAXPATHLEN];\n+  size_t pathlen = cr_util_path(path, sizeof(path));\n+  strcat(path + pathlen, os::file_separator());\n+  strcat(path + pathlen, CREngine);\n+#ifdef _WINDOWS\n+  {\n+    \/\/ Add \".exe\" if needed\n+    const char * const exe_suffix = \".exe\";\n+    const size_t exe_suffix_len = strlen(exe_suffix);\n+    pathlen = strlen(path);\n+    if (exe_suffix_len < pathlen) {\n+      if (0 != strncmp(path + pathlen - exe_suffix_len, exe_suffix, exe_suffix_len)) {\n+        strcat(path + pathlen, exe_suffix);\n+      }\n+    }\n+  }\n+#endif\n+\n+  struct stat st;\n+  if (0 != os::stat(path, &st)) {\n+    warning(\"Could not find %s: %s\", path, strerror(errno));\n+    return false;\n+  }\n+\n+  _crengine = os::strdup(path);\n+  return true;\n+}\n+\n+static int call_crengine() {\n+  if (!_crengine) {\n+    return -1;\n+  }\n+  const char *argv[4] = {_crengine, \"checkpoint\", CRaCCheckpointTo, NULL};\n+  return os::exec_child_process_and_wait(_crengine, argv);\n+}\n+\n+bool os::prepare_checkpoint() {\n+  struct stat st;\n+\n+  if (0 == os::stat(CRaCCheckpointTo, &st)) {\n+    if ((st.st_mode & S_IFMT) != S_IFDIR) {\n+      warning(\"%s: not a directory\", CRaCCheckpointTo);\n+      return false;\n+    }\n+  } else {\n+    if (-1 == os::mkdir(CRaCCheckpointTo)) {\n+      warning(\"cannot create %s: %s\", CRaCCheckpointTo, strerror(errno));\n+      return false;\n+    }\n+    if (-1 == os::rmdir(CRaCCheckpointTo)) {\n+      warning(\"cannot cleanup after check: %s\", strerror(errno));\n+      \/\/ not fatal\n+    }\n+  }\n+\n+  if (!compute_crengine()) {\n+    return false;\n+  }\n+\n+  return true;\n+}\n+\n+static int checkpoint_restore(int *shmid) {\n+\n+  int cres = call_crengine();\n+  if (cres < 0) {\n+    return JVM_CHECKPOINT_ERROR;\n+  }\n+\n+#ifdef LINUX\n+  sigset_t waitmask;\n+  sigemptyset(&waitmask);\n+  sigaddset(&waitmask, RESTORE_SIGNAL);\n+\n+  siginfo_t info;\n+  int sig;\n+  do {\n+    sig = sigwaitinfo(&waitmask, &info);\n+  } while (sig == -1 && errno == EINTR);\n+  assert(sig == RESTORE_SIGNAL, \"got what requested\");\n+#else\n+  \/\/ TODO add sync processing\n+#endif \/\/LINUX\n+\n+  if (CRTraceStartupTime) {\n+    tty->print_cr(\"STARTUPTIME \" JLONG_FORMAT \" restore-native\", os::javaTimeNanos());\n+  }\n+\n+#ifdef LINUX\n+  if (info.si_code != SI_QUEUE || info.si_int < 0) {\n+    tty->print(\"JVM: invalid info for restore provided: %s\", info.si_code == SI_QUEUE ? \"queued\" : \"not queued\");\n+    if (info.si_code == SI_QUEUE) {\n+      tty->print(\" code %d\", info.si_int);\n+    }\n+    tty->cr();\n+    return JVM_CHECKPOINT_ERROR;\n+  }\n+\n+  if (0 < info.si_int) {\n+    *shmid = info.si_int;\n+  }\n+#else\n+  *shmid = 0;\n+#endif \/\/LINUX\n+  return JVM_CHECKPOINT_OK;\n+}\n+\n+bool VM_Crac::is_claimed_fd(int fd) {\n+  typeArrayOop claimed_fds = typeArrayOop(JNIHandles::resolve_non_null(_fd_arr));\n+  for (int j = 0; j < claimed_fds->length(); ++j) {\n+    jint cfd = claimed_fds->int_at(j);\n+    if (fd == cfd) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+void VM_Crac::doit() {\n+  \/\/ dry-run fails checkpoint\n+  bool ok = true;\n+\n+  if (!check_fds()) {\n+    ok = false;\n+  }\n+\n+  if ((!ok || _dry_run) && CRHeapDumpOnCheckpointException) {\n+    HeapDumper::dump_heap();\n+  }\n+\n+  if (!ok && CRDoThrowCheckpointException) {\n+    return;\n+  } else if (_dry_run) {\n+    _ok = ok;\n+    return;\n+  }\n+\n+  if (!memory_checkpoint()) {\n+    return;\n+  }\n+\n+  int shmid = 0;\n+  if (CRAllowToSkipCheckpoint) {\n+    trace_cr(\"Skip Checkpoint\");\n+  } else {\n+    trace_cr(\"Checkpoint ...\");\n+    report_ok_to_jcmd_if_any();\n+    int ret = checkpoint_restore(&shmid);\n+    if (ret == JVM_CHECKPOINT_ERROR) {\n+      memory_restore();\n+      return;\n+    }\n+  }\n+\n+  if (shmid <= 0 || !VM_Crac::read_shm(shmid)) {\n+    _restore_start_time = os::javaTimeMillis();\n+    _restore_start_counter = os::javaTimeNanos();\n+  }\n+  memory_restore();\n+\n+  _ok = true;\n+}\n+\n+bool VM_Crac::read_shm(int shmid) {\n+  CracSHM shm(shmid);\n+  int shmfd = shm.open(O_RDONLY);\n+  shm.unlink();\n+  if (shmfd < 0) {\n+    return false;\n+  }\n+  bool ret = _restore_parameters.read_from(shmfd);\n+  close(shmfd);\n+  return ret;\n+}\n+\n+void VM_Crac::trace_cr(const char* msg, ...) {\n+  if (CRTrace) {\n+    va_list ap;\n+    va_start(ap, msg);\n+    _ostream->print(\"CR: \");\n+#ifdef __clang__\n+#pragma clang diagnostic push\n+#pragma clang diagnostic ignored \"-Wformat-nonliteral\"\n+#endif\n+    _ostream->vprint_cr(msg, ap);\n+#ifdef __clang__\n+#pragma clang diagnostic pop\n+#endif\n+    va_end(ap);\n+  }\n+}\n+\n+void VM_Crac::print_resources(const char* msg, ...) {\n+  if (CRPrintResourcesOnCheckpoint) {\n+    va_list ap;\n+    va_start(ap, msg);\n+#ifdef __clang__\n+#pragma clang diagnostic push\n+#pragma clang diagnostic ignored \"-Wformat-nonliteral\"\n+#endif\n+    _ostream->vprint(msg, ap);\n+#ifdef __clang__\n+#pragma clang diagnostic pop\n+#endif\n+    va_end(ap);\n+  }\n+}\n+\n+static Handle ret_cr(int ret, Handle new_args, Handle new_props, Handle err_codes, Handle err_msgs, TRAPS) {\n+  objArrayOop bundleObj = oopFactory::new_objectArray(5, CHECK_NH);\n+  objArrayHandle bundle(THREAD, bundleObj);\n+  jvalue jval;\n+  jval.i = ret;\n+  oop retObj = java_lang_boxing_object::create(T_INT, &jval, CHECK_NH);\n+  bundle->obj_at_put(0, retObj);\n+  bundle->obj_at_put(1, new_args());\n+  bundle->obj_at_put(2, new_props());\n+  bundle->obj_at_put(3, err_codes());\n+  bundle->obj_at_put(4, err_msgs());\n+  return bundle;\n+}\n+\n+\/** Checkpoint main entry.\n+ *\/\n+Handle os::checkpoint(jarray fd_arr, jobjectArray obj_arr, bool dry_run, jlong jcmd_stream, TRAPS) {\n+  if (!CRaCCheckpointTo) {\n+    return ret_cr(JVM_CHECKPOINT_NONE, Handle(), Handle(), Handle(), Handle(), THREAD);\n+  }\n+\n+  if (-1 == os::mkdir(CRaCCheckpointTo) && errno != EEXIST) {\n+    warning(\"cannot create %s: %s\", CRaCCheckpointTo, strerror(errno));\n+    return ret_cr(JVM_CHECKPOINT_NONE, Handle(), Handle(), Handle(), Handle(), THREAD);\n+  }\n+\n+  Universe::heap()->set_cleanup_unused(true);\n+  Universe::heap()->collect(GCCause::_full_gc_alot);\n+  Universe::heap()->set_cleanup_unused(false);\n+\n+  VM_Crac cr(fd_arr, obj_arr, dry_run, (bufferedStream*)jcmd_stream);\n+  {\n+    MutexLocker ml(Heap_lock);\n+    VMThread::execute(&cr);\n+  }\n+  if (cr.ok()) {\n+    oop new_args = NULL;\n+    if (cr.new_args()) {\n+      new_args = java_lang_String::create_oop_from_str(cr.new_args(), CHECK_NH);\n+    }\n+    GrowableArray<const char *>* new_properties = cr.new_properties();\n+    objArrayOop propsObj = oopFactory::new_objArray(vmClasses::String_klass(), new_properties->length(), CHECK_NH);\n+    objArrayHandle props(THREAD, propsObj);\n+\n+    for (int i = 0; i < new_properties->length(); i++) {\n+      oop propObj = java_lang_String::create_oop_from_str(new_properties->at(i), CHECK_NH);\n+      props->obj_at_put(i, propObj);\n+    }\n+    return ret_cr(JVM_CHECKPOINT_OK, Handle(THREAD, new_args), props, Handle(), Handle(), THREAD);\n+  }\n+\n+  GrowableArray<CracFailDep>* failures = cr.failures();\n+\n+  typeArrayOop codesObj = oopFactory::new_intArray(failures->length(), CHECK_NH);\n+  typeArrayHandle codes(THREAD, codesObj);\n+  objArrayOop msgsObj = oopFactory::new_objArray(vmClasses::String_klass(), failures->length(), CHECK_NH);\n+  objArrayHandle msgs(THREAD, msgsObj);\n+\n+  for (int i = 0; i < failures->length(); ++i) {\n+    codes->int_at_put(i, failures->at(i)._type);\n+    oop msgObj = java_lang_String::create_oop_from_str(failures->at(i)._msg, CHECK_NH);\n+    FREE_C_HEAP_ARRAY(char, failures->at(i)._msg);\n+    msgs->obj_at_put(i, msgObj);\n+  }\n+\n+  return ret_cr(JVM_CHECKPOINT_ERROR, Handle(), Handle(), codes, msgs, THREAD);\n+}\n+\n+void os::restore() {\n+  jlong restore_time = javaTimeMillis();\n+  jlong restore_counter = javaTimeNanos();\n+\n+  compute_crengine();\n+\n+  const int id = os::current_process_id();\n+\n+  CracSHM shm(id);\n+  int shmfd = shm.open(O_RDWR | O_CREAT);\n+  if (0 <= shmfd) {\n+    if (CracRestoreParameters::write_to(\n+          shmfd,\n+          Arguments::jvm_flags_array(), Arguments::num_jvm_flags(),\n+          Arguments::system_properties(),\n+          Arguments::java_command() ? Arguments::java_command() : \"\",\n+          restore_time,\n+          restore_counter)) {\n+      char strid[32];\n+      snprintf(strid, sizeof(strid), \"%d\", id);\n+      LINUX_ONLY(setenv(\"CRAC_NEW_ARGS_ID\", strid, true));\n+    }\n+    close(shmfd);\n+  }\n+\n+\n+  if (_crengine) {\n+#ifdef _WINDOWS\n+    _execl(_crengine, _crengine, \"restore\", CRaCRestoreFrom, NULL);\n+#else\n+    execl(_crengine, _crengine, \"restore\", CRaCRestoreFrom, NULL);\n+#endif \/\/LINUX\n+    warning(\"cannot execute \\\"%s restore ...\\\" (%s)\", _crengine, strerror(errno));\n+  }\n+}\n+\n+jlong os::restore_start_time() {\n+  if (!_restore_start_time) {\n+    return -1;\n+  }\n+  return _restore_start_time;\n+}\n+\n+jlong os::uptime_since_restore() {\n+  if (!_restore_start_counter) {\n+    return -1;\n+  }\n+  return javaTimeNanos() - _restore_start_counter;\n+}\n+\n+bool CracRestoreParameters::read_from(int fd) {\n+  struct stat st;\n+  if (fstat(fd, &st)) {\n+    perror(\"fstat (ignoring restore parameters)\");\n+    return false;\n+  }\n+\n+  char *contents = NEW_C_HEAP_ARRAY(char, st.st_size, mtInternal);\n+  if (read(fd, contents, st.st_size) < 0) {\n+    perror(\"read (ignoring restore parameters)\");\n+    FREE_C_HEAP_ARRAY(char, contents);\n+    return false;\n+  }\n+\n+  _raw_content = contents;\n+\n+  \/\/ parse the contents to read new system properties and arguments\n+  header* hdr = (header*)_raw_content;\n+  char* cursor = _raw_content + sizeof(header);\n+\n+  ::_restore_start_time = hdr->_restore_time;\n+  ::_restore_start_counter = hdr->_restore_counter;\n+\n+  for (int i = 0; i < hdr->_nflags; i++) {\n+    FormatBuffer<80> err_msg(\"%s\", \"\");\n+    JVMFlag::Error result;\n+    const char *name = cursor;\n+    if (*cursor == '+' || *cursor == '-') {\n+      name = cursor + 1;\n+      result = WriteableFlags::set_flag(name, *cursor == '+' ? \"true\" : \"false\",\n+        JVMFlagOrigin::CRAC_RESTORE, err_msg);\n+      cursor += strlen(cursor) + 1;\n+    } else {\n+      char* eq = strchrnul(cursor, '=');\n+      if (*eq == '\\0') {\n+        result = JVMFlag::Error::MISSING_VALUE;\n+        cursor = eq + 1;\n+      } else {\n+        *eq = '\\0';\n+        char* value = eq + 1;\n+        result = WriteableFlags::set_flag(cursor, value, JVMFlagOrigin::CRAC_RESTORE, err_msg);\n+        cursor = value + strlen(value) + 1;\n+      }\n+    }\n+    guarantee(result == JVMFlag::Error::SUCCESS, \"VM Option '%s' cannot be changed: %s\",\n+        name, JVMFlag::flag_error_str(result));\n+  }\n+\n+  for (int i = 0; i < hdr->_nprops; i++) {\n+    assert((cursor + strlen(cursor) <= contents + st.st_size), \"property length exceeds shared memory size\");\n+    int idx = _properties->append(cursor);\n+    size_t prop_len = strlen(cursor) + 1;\n+    cursor = cursor + prop_len;\n+  }\n+\n+  char* env_mem = NEW_C_HEAP_ARRAY(char, hdr->_env_memory_size, mtArguments); \/\/ left this pointer unowned, it is freed when process dies\n+  memcpy(env_mem, cursor, hdr->_env_memory_size);\n+\n+  const char* env_end = env_mem + hdr->_env_memory_size;\n+  while (env_mem < env_end) {\n+    const size_t s = strlen(env_mem) + 1;\n+    assert(env_mem + s <= env_end, \"env vars exceed memory buffer, maybe ending 0 is lost\");\n+    putenv(env_mem);\n+    env_mem += s;\n+  }\n+  cursor += hdr->_env_memory_size;\n+\n+  _args = cursor;\n+  return true;\n+}\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":440,"deletions":0,"binary":false,"changes":440,"status":"modified"},{"patch":"@@ -532,0 +532,2 @@\n+  static int exec_child_process_and_wait(const char *path, const char *argv[]);\n+\n@@ -582,0 +584,3 @@\n+  static int mkdir(const char *pathname);\n+  static int rmdir(const char *pathname);\n+\n@@ -588,0 +593,2 @@\n+  static bool is_path_absolute(const char *path);\n+\n@@ -1028,0 +1035,9 @@\n+  static void vm_create_start();\n+\n+  static Handle checkpoint(jarray fd_arr, jobjectArray obj_arr, bool dry_run, jlong jcmd_stream, TRAPS);\n+  static bool prepare_checkpoint();\n+  static void restore();\n+\n+  static jlong restore_start_time();\n+  static jlong uptime_since_restore();\n+\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2712,1 +2712,1 @@\n-    os::Linux::restore();\n+    os::restore();\n@@ -2788,1 +2788,1 @@\n-  os::Linux::vm_create_start();\n+  os::vm_create_start();\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+#ifdef LINUX\n@@ -59,0 +60,1 @@\n+#endif \/\/LINUX\n@@ -1048,1 +1050,0 @@\n-  LinuxAttachOperation* current_op;\n@@ -1056,2 +1057,2 @@\n-      current_op = LinuxAttachListener::get_current_op();\n-      outputStream* stream = current_op->is_effectively_completed() ? tty : output();\n+      outputStream* stream = output();\n+      LINUX_ONLY(if (LinuxAttachListener::get_current_op() && LinuxAttachListener::get_current_op()->is_effectively_completed()) { stream = tty; })\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -957,1 +957,1 @@\n-    return os::Linux::restore_start_time();\n+    return os::restore_start_time();\n@@ -961,1 +961,1 @@\n-      jlong ticks = os::Linux::uptime_since_restore();\n+      jlong ticks = os::uptime_since_restore();\n","filename":"src\/hotspot\/share\/services\/management.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -146,5 +146,5 @@\n-        final int retCode = (Integer)bundle[0];\n-        final String newArguments = (String)bundle[1];\n-        final String[] newProperties = (String[])bundle[2];\n-        final int[] codes = (int[])bundle[3];\n-        final String[] messages = (String[])bundle[4];\n+        final int retCode = (null == bundle) ? JVM_CHECKPOINT_NONE : (Integer)bundle[0];\n+        final String newArguments = (null == bundle) ? null : (String)bundle[1];\n+        final String[] newProperties = (null == bundle) ? null : (String[])bundle[2];\n+        final int[] codes = (null == bundle) ? null : (int[])bundle[3];\n+        final String[] messages = (null == bundle) ? null : (String[])bundle[4];\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/Core.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -97,0 +97,1 @@\n+#ifndef _WIN32\n@@ -154,1 +155,1 @@\n-    for (int sig = 1; sig < __SIGRTMIN; ++sig) {\n+    for (int sig = 1; sig <= 31; ++sig) {\n@@ -169,0 +170,1 @@\n+#endif \/\/ _WIN32\n","filename":"src\/java.base\/share\/native\/launcher\/main.c","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#ifdef LINUX\n@@ -41,0 +42,1 @@\n+#endif \/\/LINUX\n","filename":"src\/java.base\/unix\/native\/pauseengine\/pauseengine.c","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#ifdef LINUX\n@@ -41,0 +42,1 @@\n+#endif \/\/LINUX\n","filename":"src\/java.base\/unix\/native\/simengine\/simengine.c","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <string.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+\/\/ #include <unistd.h>\n+#include <signal.h>\n+#include <windows.h>\n+\n+typedef int pid_t;\n+\n+#define RESTORE_SIGNAL   (SIGRTMIN + 2)\n+\n+static int kickjvm(pid_t jvm, int code) {\n+    \/\/ union sigval sv = { .sival_int = code };\n+    \/\/ if (-1 == sigqueue(jvm, RESTORE_SIGNAL, sv)) {\n+    \/\/     perror(\"sigqueue\");\n+    \/\/     return 1;\n+    \/\/ }\n+    return 0;\n+}\n+\n+int main(int argc, char *argv[]) {\n+    char* action = argv[1];\n+    char* imagedir = argv[2];\n+\n+    char pidpath[MAX_PATH];\n+    if (-1 == sprintf(pidpath, \"%s\/pid\", imagedir)) {\n+        return 1;\n+    }\n+\n+    if (!strcmp(action, \"checkpoint\")) {\n+        pid_t jvm = -1; \/\/getppid();\n+\n+        FILE *pidfile = fopen(pidpath, \"w\");\n+        if (!pidfile) {\n+            perror(\"fopen pidfile\");\n+            kickjvm(jvm, -1);\n+            return 1;\n+        }\n+\n+        fprintf(pidfile, \"%d\\n\", jvm);\n+        fclose(pidfile);\n+\n+    } else if (!strcmp(action, \"restore\")) {\n+        FILE *pidfile = fopen(pidpath, \"r\");\n+        if (!pidfile) {\n+            perror(\"fopen pidfile\");\n+            return 1;\n+        }\n+\n+        pid_t jvm;\n+        if (1 != fscanf(pidfile, \"%d\", &jvm)) {\n+            fclose(pidfile);\n+            fprintf(stderr, \"cannot read pid\\n\");\n+            return 1;\n+        }\n+        fclose(pidfile);\n+\n+        char *strid = getenv(\"CRAC_NEW_ARGS_ID\");\n+        if (kickjvm(jvm, strid ? atoi(strid) : 0)) {\n+            return 1;\n+        }\n+\n+    } else {\n+        fprintf(stderr, \"unknown action: %s\\n\", action);\n+        return 1;\n+    }\n+\n+    return 0;\n+}\n","filename":"src\/java.base\/windows\/native\/pauseengine\/pauseengine.c","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <string.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+\n+\/\/ #define RESTORE_SIGNAL   (SIGRTMIN + 2)\n+\n+static int kickjvm(int jvm, int code) {\n+\/\/     union sigval sv = { .sival_int = code };\n+\/\/     if (-1 == sigqueue(jvm, RESTORE_SIGNAL, sv)) {\n+\/\/         perror(\"sigqueue\");\n+\/\/         return 1;\n+\/\/     }\n+\n+    return 0;\n+}\n+\n+int main(int argc, char *argv[]) {\n+    char* action = argv[1];\n+\n+    if (!strcmp(action, \"checkpoint\")) {\n+        const char* argsidstr = getenv(\"SIM_CRAC_NEW_ARGS_ID\");\n+        int argsid = argsidstr ? atoi(argsidstr) : 0;\n+        int jvm = -1;\/\/getppid();\n+        kickjvm(jvm, argsid);\n+    } else if (!strcmp(action, \"restore\")) {\n+        char *strid = getenv(\"CRAC_NEW_ARGS_ID\");\n+        printf(\"SIM_CRAC_NEW_ARGS_ID=%s\\n\", strid ? strid : \"0\");\n+    } else {\n+        fprintf(stderr, \"unknown action: %s\\n\", action);\n+        return 1;\n+    }\n+\n+    return 0;\n+}\n","filename":"src\/java.base\/windows\/native\/simengine\/simengine.c","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -36,0 +36,1 @@\n+ * @requires (os.family == \"linux\")\n","filename":"test\/jdk\/jdk\/crac\/LeaveRunning.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+ * @requires (os.family == \"linux\")\n","filename":"test\/jdk\/jdk\/crac\/RestoreEnvironmentTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @requires (os.family == \"linux\")\n","filename":"test\/jdk\/jdk\/crac\/SecureRandom\/InterlockTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+ * @requires (os.family == \"linux\")\n","filename":"test\/jdk\/jdk\/crac\/SecureRandom\/ReseedTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @requires (os.family == \"linux\")\n","filename":"test\/jdk\/jdk\/crac\/Selector\/Test970\/Test.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ * @requires (os.family == \"linux\")\n","filename":"test\/jdk\/jdk\/crac\/Selector\/interruptedSelection\/Test.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ * @requires (os.family == \"linux\")\n","filename":"test\/jdk\/jdk\/crac\/Selector\/keyAfterRestore\/Test.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+ * @requires (os.family == \"linux\")\n","filename":"test\/jdk\/jdk\/crac\/Selector\/multipleSelect\/Test.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+ * @requires (os.family == \"linux\")\n","filename":"test\/jdk\/jdk\/crac\/Selector\/multipleSelectNow\/Test.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+ * @requires (os.family == \"linux\")\n","filename":"test\/jdk\/jdk\/crac\/Selector\/multipleSelectSingleClose\/Test.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+ * @requires (os.family == \"linux\")\n","filename":"test\/jdk\/jdk\/crac\/Selector\/selectAfterWakeup\/Test.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @requires (os.family == \"linux\")\n","filename":"test\/jdk\/jdk\/crac\/Selector\/selectAndWakeupAfterRestore\/Test.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ * @requires (os.family == \"linux\")\n","filename":"test\/jdk\/jdk\/crac\/Selector\/wakeupAfterRestore\/Test.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ * @requires (os.family == \"linux\")\n","filename":"test\/jdk\/jdk\/crac\/Selector\/wakeupByClose\/Test.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ * @requires (os.family == \"linux\")\n","filename":"test\/jdk\/jdk\/crac\/Selector\/wakeupByTimeoutAfterRestore\/Test.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+ * @requires (os.family == \"linux\")\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/CheckpointWithOpenFdsTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+ * @requires (os.family == \"linux\")\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/IgnoredFileDescriptorsTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+ * @requires (os.family == \"linux\")\n","filename":"test\/jdk\/jdk\/crac\/java\/net\/InetAddress\/ResolveTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -10,0 +10,1 @@\n+import java.nio.file.Files;\n@@ -218,1 +219,3 @@\n-            FileUtils.deleteFileTreeWithRetry(Path.of(\".\", \"jdk-docker\"));\n+            Path jdkDockerPath = Path.of(\".\", \"jdk-docker\");\n+            if (Files.exists(jdkDockerPath))\n+                FileUtils.deleteFileTreeWithRetry(jdkDockerPath);\n","filename":"test\/lib\/jdk\/test\/lib\/crac\/CracBuilder.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -9,0 +9,1 @@\n+import java.util.concurrent.TimeUnit;\n@@ -46,0 +47,4 @@\n+\n+        \/\/ (at least on Windows) we need to wait to avoid os::prepare_checkpoint() interference with mkdir\/rmdir calls\n+        Thread.sleep(500);\n+\n@@ -63,0 +68,1 @@\n+            int timeoutCounter = 10;\n@@ -64,1 +70,10 @@\n-                WatchKey key2 = watcher.take();\n+                WatchKey key2 = watcher.poll(1, TimeUnit.SECONDS);\n+                if (null == key2) {\n+                    if (!process.isAlive() && 0 < --timeoutCounter) {\n+                        \/\/ At least on macOS, it seems like WatchService's event may be delayed up to 10 secs,\n+                        \/\/ so we need to keep waiting some time for the event, even the process is completed.\n+                        continue;\n+                    }\n+                    assertTrue(process.isAlive(), \"Process should exist\");\n+                    continue;\n+                }\n","filename":"test\/lib\/jdk\/test\/lib\/crac\/CracProcess.java","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"}]}