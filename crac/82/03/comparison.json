{"files":[{"patch":"@@ -25,2 +25,2 @@\n-      platform_windows_x64: ${{ false && steps.check_platforms.outputs.platform_windows_x64 }}\n-      platform_macos_x64: ${{ false && steps.check_platforms.outputs.platform_macos_x64 }}\n+      platform_windows_x64: ${{ steps.check_platforms.outputs.platform_windows_x64 }}\n+      platform_macos_x64: ${{ steps.check_platforms.outputs.platform_macos_x64 }}\n","filename":".github\/workflows\/submit.yml","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -104,0 +104,3 @@\n+endif\n+\n+ifeq ($(call isTargetOs, macosx linux), true)\n@@ -128,0 +131,27 @@\n+ifeq ($(OPENJDK_TARGET_OS), windows)\n+  $(eval $(call SetupJdkExecutable, BUILD_PAUSEENGINE, \\\n+      NAME := pauseengine, \\\n+      SRC := $(TOPDIR)\/src\/$(MODULE)\/windows\/native\/pauseengine, \\\n+      INCLUDE_FILES := pauseengine.c, \\\n+      OPTIMIZATION := LOW, \\\n+      CFLAGS := $(CFLAGS_JDKEXE), \\\n+      LDFLAGS := $(LDFLAGS_JDKEXE), \\\n+      OUTPUT_DIR := $(SUPPORT_OUTPUTDIR)\/modules_cmds\/$(MODULE), \\\n+  ))\n+  TARGETS += $(BUILD_PAUSEENGINE)\n+\n+  $(eval $(call SetupJdkExecutable, BUILD_SIMENGINE, \\\n+      NAME := simengine, \\\n+      SRC := $(TOPDIR)\/src\/$(MODULE)\/windows\/native\/simengine, \\\n+      INCLUDE_FILES := simengine.c, \\\n+      OPTIMIZATION := LOW, \\\n+      CFLAGS := $(CFLAGS_JDKEXE), \\\n+      LDFLAGS := $(LDFLAGS_JDKEXE), \\\n+      LIBS := advapi32.lib version.lib user32.lib, \\\n+      OUTPUT_DIR := $(SUPPORT_OUTPUTDIR)\/modules_cmds\/$(MODULE), \\\n+  ))\n+\n+  TARGETS += $(BUILD_SIMENGINE)\n+\n+endif\n+\n","filename":"make\/modules\/java.base\/Launcher.gmk","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -0,0 +1,453 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ no precompiled headers\n+#include \"jvm.h\"\n+#include \"perfMemory_linux.hpp\"\n+#include \"runtime\/crac_structs.hpp\"\n+#include \"runtime\/crac.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"classfile\/classLoader.hpp\"\n+\n+class FdsInfo {\n+public:\n+\n+  enum state_t {\n+    INVALID = -3,\n+    CLOSED = -2,\n+    ROOT = -1,\n+    DUP_OF_0 = 0,\n+    \/\/ ...\n+  };\n+\n+  enum mark_t {\n+    M_CANT_RESTORE = 1 << 0,\n+  };\n+\n+private:\n+  struct fdinfo {\n+    int fd;\n+    struct stat stat;\n+    state_t state;\n+    unsigned mark;\n+\n+    int flags;\n+  };\n+\n+  \/\/ params are indices into _fdinfos\n+  bool same_fd(int i1, int i2);\n+\n+  bool _inited;\n+  GrowableArray<fdinfo> _fdinfos;\n+\n+  void assert_mark(int i) {\n+    assert(_inited, \"\");\n+    assert(i < _fdinfos.length(), \"\");\n+    assert(_fdinfos.at(i).state != CLOSED, \"\");\n+  }\n+\n+public:\n+  void initialize();\n+\n+  int len() { return _fdinfos.length(); }\n+\n+  state_t get_state(int i) {\n+    assert(_inited, \"\");\n+    assert(i < _fdinfos.length(), \"\");\n+    return _fdinfos.at(i).state;\n+  }\n+\n+  state_t find_state(int fd, state_t orstate) {\n+    for (int i = 0; i < _fdinfos.length(); ++i) {\n+      fdinfo *info = _fdinfos.adr_at(i);\n+      if (info->fd == fd) {\n+        return info->state;\n+      }\n+    }\n+    return orstate;\n+  }\n+\n+  int get_fd(int i) {\n+    assert(_inited, \"\");\n+    assert(i < _fdinfos.length(), \"\");\n+    return _fdinfos.at(i).fd;\n+  }\n+\n+  struct stat* get_stat(int i) {\n+    assert(_inited, \"\");\n+    assert(i < _fdinfos.length(), \"\");\n+    return &_fdinfos.at(i).stat;\n+  }\n+\n+  FdsInfo(bool do_init = true) :\n+    _inited(false),\n+    _fdinfos(16, mtInternal)\n+  {\n+    if (do_init) {\n+      initialize();\n+    }\n+  }\n+};\n+\n+static FdsInfo _vm_inited_fds(false);\n+\n+\/* taken from criu, that took this from kernel *\/\n+#define NFS_PREF \".nfs\"\n+#define NFS_PREF_LEN ((unsigned)sizeof(NFS_PREF) - 1)\n+#define NFS_FILEID_LEN ((unsigned)sizeof(uint64_t) << 1)\n+#define NFS_COUNTER_LEN ((unsigned)sizeof(unsigned int) << 1)\n+#define NFS_LEN (NFS_PREF_LEN + NFS_FILEID_LEN + NFS_COUNTER_LEN)\n+static bool nfs_silly_rename(char* path) {\n+  char *sep = strrchr(path, '\/');\n+  char *base = sep ? sep + 1 : path;\n+  if (strncmp(base, NFS_PREF, NFS_PREF_LEN)) {\n+    return false;\n+  }\n+  for (unsigned i = NFS_PREF_LEN; i < NFS_LEN; ++i) {\n+    if (!isxdigit(base[i])) {\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n+static int readfdlink(int fd, char *link, size_t len) {\n+  char fdpath[64];\n+  snprintf(fdpath, sizeof(fdpath), \"\/proc\/self\/fd\/%d\", fd);\n+  int ret = readlink(fdpath, link, len);\n+  if (ret == -1) {\n+    return ret;\n+  }\n+  link[(unsigned)ret < len ? ret : len - 1] = '\\0';\n+  return ret;\n+}\n+\n+static bool same_stat(struct stat* st1, struct stat* st2) {\n+  return st1->st_dev == st2->st_dev &&\n+         st1->st_ino == st2->st_ino;\n+}\n+\n+bool FdsInfo::same_fd(int i1, int i2) {\n+  assert(i1 < _fdinfos.length(), \"\");\n+  assert(i2 < _fdinfos.length(), \"\");\n+  fdinfo *fi1 = _fdinfos.adr_at(i1);\n+  fdinfo *fi2 = _fdinfos.adr_at(i2);\n+  if (!same_stat(&fi1->stat, &fi2->stat)) {\n+    return false;\n+  }\n+\n+  int flags1 = fcntl(fi1->fd, F_GETFL);\n+  int flags2 = fcntl(fi2->fd, F_GETFL);\n+  if (flags1 != flags2) {\n+    return false;\n+  }\n+\n+  const int test_flag = O_NONBLOCK;\n+  const int new_flags1 = flags1 ^ test_flag;\n+  fcntl(fi1->fd, F_SETFL, new_flags1);\n+  if (fcntl(fi1->fd, F_GETFL) != new_flags1) {\n+    \/\/ flag write ignored or handled differently,\n+    \/\/ don't know what to do\n+    return false;\n+  }\n+\n+  const int new_flags2 = fcntl(fi2->fd, F_GETFL);\n+  const bool are_same = new_flags1 == new_flags2;\n+\n+  fcntl(fi2->fd, flags1);\n+\n+  return are_same;\n+}\n+\n+void FdsInfo::initialize() {\n+  assert(!_inited, \"should be called only once\");\n+\n+  char path[PATH_MAX];\n+  struct dirent *dp;\n+\n+  DIR *dir = opendir(\"\/proc\/self\/fd\");\n+  int dfd = dirfd(dir);\n+  while (dp = readdir(dir)) {\n+    if (dp->d_name[0] == '.') {\n+      \/\/ skip \".\" and \"..\"\n+      continue;\n+    }\n+    fdinfo info;\n+    info.fd = atoi(dp->d_name);\n+    if (info.fd == dfd) {\n+      continue;\n+    }\n+    int r = fstat(info.fd, &info.stat);\n+    if (r == -1) {\n+      info.state = CLOSED;\n+      continue;\n+    }\n+    info.state = ROOT; \/\/ can be changed to DUP_OF_0 + N below\n+    info.mark = 0;\n+    _fdinfos.append(info);\n+  }\n+  closedir(dir);\n+  _inited = true;\n+\n+  for (int i = 0; i < _fdinfos.length(); ++i) {\n+    fdinfo *info = _fdinfos.adr_at(i);\n+    for (int j = 0; j < i; ++j) {\n+      if (get_state(j) == ROOT && same_fd(i, j)) {\n+        info->state = (state_t)(DUP_OF_0 + j);\n+        break;\n+      }\n+    }\n+\n+    if (info->state == ROOT) {\n+      char fdpath[PATH_MAX];\n+      int r = readfdlink(info->fd, fdpath, sizeof(fdpath));\n+      guarantee(-1 != r, \"can't stat fd\");\n+      if (info->stat.st_nlink == 0 ||\n+          strstr(fdpath, \"(deleted)\") ||\n+          nfs_silly_rename(fdpath)) {\n+        info->mark |= FdsInfo::M_CANT_RESTORE;\n+      }\n+    }\n+  }\n+}\n+\n+static const char* stat2strtype(mode_t mode) {\n+  switch (mode & S_IFMT) {\n+  case S_IFSOCK: return \"socket\";\n+  case S_IFLNK:  return \"symlink\";\n+  case S_IFREG:  return \"regular\";\n+  case S_IFBLK:  return \"block\";\n+  case S_IFDIR:  return \"directory\";\n+  case S_IFCHR:  return \"character\";\n+  case S_IFIFO:  return \"fifo\";\n+  default:       break;\n+  }\n+  return \"unknown\";\n+}\n+\n+static int stat2stfail(mode_t mode) {\n+  switch (mode & S_IFMT) {\n+  case S_IFSOCK:\n+    return JVM_CR_FAIL_SOCK;\n+  case S_IFLNK:\n+  case S_IFREG:\n+  case S_IFBLK:\n+  case S_IFDIR:\n+  case S_IFCHR:\n+    return JVM_CR_FAIL_FILE;\n+  case S_IFIFO:\n+    return JVM_CR_FAIL_PIPE;\n+  default:\n+    break;\n+  }\n+  return JVM_CR_FAIL;\n+}\n+\n+\/\/ If checkpoint is called throught the API, jcmd operation and jcmd output doesn't exist.\n+bool VM_Crac::is_socket_from_jcmd(int sock) {\n+  if (_attach_op == NULL)\n+    return false;\n+  int sock_fd = _attach_op->socket();\n+  return sock == sock_fd;\n+}\n+\n+void VM_Crac::report_ok_to_jcmd_if_any() {\n+  if (_attach_op == NULL)\n+    return;\n+  bufferedStream* buf = static_cast<bufferedStream*>(_ostream);\n+  _attach_op->effectively_complete_raw(JNI_OK, buf);\n+  \/\/ redirect any further output to console\n+  _ostream = tty;\n+}\n+\n+bool VM_Crac::check_fds() {\n+\n+  AttachListener::abort();\n+\n+  FdsInfo fds;\n+\n+  bool ok = true;\n+\n+  for (int i = 0; i < fds.len(); ++i) {\n+    if (fds.get_state(i) == FdsInfo::CLOSED) {\n+      continue;\n+    }\n+    int fd = fds.get_fd(i);\n+\n+    char detailsbuf[PATH_MAX];\n+    struct stat* st = fds.get_stat(i);\n+    const char* type = stat2strtype(st->st_mode);\n+    int linkret = readfdlink(fd, detailsbuf, sizeof(detailsbuf));\n+    const char* details = 0 < linkret ? detailsbuf : \"\";\n+    print_resources(\"JVM: FD fd=%d type=%s path=\\\"%s\\\" \", fd, type, details);\n+\n+    if (is_claimed_fd(fd)) {\n+      print_resources(\"OK: claimed by java code\\n\");\n+      continue;\n+    }\n+\n+    if (_vm_inited_fds.find_state(fd, FdsInfo::CLOSED) != FdsInfo::CLOSED) {\n+      print_resources(\"OK: inherited from process env\\n\");\n+      continue;\n+    }\n+\n+    if (S_ISSOCK(st->st_mode)) {\n+      if (is_socket_from_jcmd(fd)){\n+        print_resources(\"OK: jcmd socket\\n\");\n+        continue;\n+      }\n+    }\n+\n+    print_resources(\"BAD: opened by application\\n\");\n+    ok = false;\n+\n+    const int maxinfo = 64;\n+    size_t buflen = strlen(details) + maxinfo;\n+    char* msg = NEW_C_HEAP_ARRAY(char, buflen, mtInternal);\n+    int len = snprintf(msg, buflen, \"FD fd=%d type=%s path=%s\", fd, type, detailsbuf);\n+    msg[len < 0 ? 0 : ((size_t) len >= buflen ? buflen - 1 : len)] = '\\0';\n+    _failures->append(CracFailDep(stat2stfail(st->st_mode & S_IFMT), msg));\n+  }\n+\n+  return ok;\n+}\n+\n+bool VM_Crac::memory_checkpoint() {\n+  return PerfMemoryLinux::checkpoint(CRaCCheckpointTo);\n+}\n+\n+void VM_Crac::memory_restore() {\n+  PerfMemoryLinux::restore();\n+}\n+\n+static char modules_path[JVM_MAXPATHLEN] = { '\\0' };\n+\n+static bool is_fd_ignored(int fd, const char *path) {\n+  const char *list = CRaCIgnoredFileDescriptors;\n+  while (list && *list) {\n+    const char *end = strchr(list, ',');\n+    if (!end) {\n+      end = list + strlen(list);\n+    }\n+    char *invalid;\n+    int ignored_fd = strtol(list, &invalid, 10);\n+    if (invalid == end) { \/\/ entry was integer -> file descriptor\n+      if (fd == ignored_fd) {\n+        log_trace(os)(\"CRaC not closing file descriptor %d (%s) as it is marked as ignored.\", fd, path);\n+        return true;\n+      }\n+    } else { \/\/ interpret entry as path\n+      int path_len = path ? strlen(path) : -1;\n+      if (path_len != -1 && path_len == end - list && !strncmp(path, list, end - list)) {\n+        log_trace(os)(\"CRaC not closing file descriptor %d (%s) as it is marked as ignored.\", fd, path);\n+        return true;\n+      }\n+    }\n+    if (*end) {\n+      list = end + 1;\n+    } else {\n+      break;\n+    }\n+  }\n+\n+  if (os::same_files(modules_path, path)) {\n+    \/\/ Path to the modules directory is opened early when JVM is booted up and won't be closed.\n+    \/\/ We can ignore this for purposes of CRaC.\n+    return true;\n+  }\n+\n+  return false;\n+}\n+\n+static void close_extra_descriptors() {\n+  \/\/ Path to the modules directory is opened early when JVM is booted up and won't be closed.\n+  \/\/ We can ignore this for purposes of CRaC.\n+  if (modules_path[0] == '\\0') {\n+    const char* fileSep = os::file_separator();\n+    jio_snprintf(modules_path, JVM_MAXPATHLEN, \"%s%slib%s\" MODULES_IMAGE_NAME, Arguments::get_java_home(), fileSep, fileSep);\n+  }\n+\n+  char path[PATH_MAX];\n+  struct dirent *dp;\n+\n+  DIR *dir = opendir(\"\/proc\/self\/fd\");\n+  while (dp = readdir(dir)) {\n+    int fd = atoi(dp->d_name);\n+    if (fd > 2 && fd != dirfd(dir)) {\n+      int r = readfdlink(fd, path, sizeof(path));\n+      if (!is_fd_ignored(fd, r != -1 ? path : nullptr)) {\n+        log_warning(os)(\"CRaC closing file descriptor %d: %s\", fd, path);\n+        close(fd);\n+      }\n+    }\n+  }\n+  closedir(dir);\n+}\n+\n+void crac::vm_create_start() {\n+  if (!CRaCCheckpointTo) {\n+    return;\n+  }\n+  close_extra_descriptors();\n+  _vm_inited_fds.initialize();\n+}\n+\n+static bool read_all(int fd, char *dest, size_t n) {\n+  size_t rd = 0;\n+  do {\n+    ssize_t r = ::read(fd, dest + rd, n - rd);\n+    if (r == 0) {\n+      return false;\n+    } else if (r < 0) {\n+      if (errno == EINTR) {\n+        continue;\n+      }\n+      return false;\n+    }\n+    rd += r;\n+  } while (rd < n);\n+  return true;\n+}\n+\n+bool crac::read_bootid(char *dest) {\n+  int fd = ::open(\"\/proc\/sys\/kernel\/random\/boot_id\", O_RDONLY);\n+  if (fd < 0 || !read_all(fd, dest, UUID_LENGTH)) {\n+    perror(\"CRaC: Cannot read system boot ID\");\n+    return false;\n+  }\n+  char c;\n+  if (!read_all(fd, &c, 1) || c != '\\n') {\n+    perror(\"CRaC: system boot ID does not end with newline\");\n+    return false;\n+  }\n+  if (::read(fd, &c, 1) != 0) {\n+    perror(\"CRaC: Unexpected data\/error reading system boot ID\");\n+    return false;\n+  }\n+  if (::close(fd) != 0) {\n+    perror(\"CRaC: Cannot close system boot ID file\");\n+  }\n+  return true;\n+}\n","filename":"src\/hotspot\/os\/linux\/crac_linux.cpp","additions":453,"deletions":0,"binary":false,"changes":453,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ no precompiled headers\n+#include \"jvm.h\"\n+#include \"runtime\/crac_structs.hpp\"\n+\n+#include <sys\/mman.h>\n+\n+int CracSHM::open(int mode) {\n+  int shmfd = shm_open(_path, mode, 0600);\n+  if (-1 == shmfd) {\n+    perror(\"shm_open\");\n+  }\n+  return shmfd;\n+}\n+\n+void CracSHM::unlink() {\n+  shm_unlink(_path);\n+}\n+\n+#ifndef LINUX\n+void crac::vm_create_start() {\n+}\n+\n+void VM_Crac::report_ok_to_jcmd_if_any() {\n+}\n+\n+bool VM_Crac::check_fds() {\n+  return true;\n+}\n+\n+bool VM_Crac::memory_checkpoint() {\n+  return true;\n+}\n+\n+void VM_Crac::memory_restore() {\n+}\n+\n+bool crac::read_bootid(char *dest) {\n+  return true;\n+}\n+#endif\n\\ No newline at end of file\n","filename":"src\/hotspot\/os\/posix\/crac_posix.cpp","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -94,1 +94,1 @@\n-#ifdef LINUX\n+#if defined(LINUX)\n@@ -96,0 +96,2 @@\n+#elif defined(__APPLE__)\n+#define RESTORE_SIGNAL   SIGUSR2\n","filename":"src\/hotspot\/os\/posix\/include\/jvm_md.h","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"runtime\/crac.hpp\"\n@@ -657,0 +658,4 @@\n+bool os::is_path_absolute(const char *path) {\n+  return (path && '\/' == path[0]);\n+}\n+\n@@ -683,0 +688,8 @@\n+int os::mkdir(const char *path) {\n+  return ::mkdir(path, 0700);\n+}\n+\n+int os::rmdir(const char *path) {\n+  return ::rmdir(path);\n+}\n+\n@@ -1936,0 +1949,26 @@\n+int os::exec_child_process_and_wait(const char *path, const char *argv[]) {\n+  char** env = os::get_environ();\n+\n+  pid_t pid = fork();\n+  if (pid == -1) {\n+    perror(\"cannot fork for crengine\");\n+    return -1;\n+  }\n+  if (pid == 0) {\n+    execve(path, (char* const*)argv, env);\n+    perror(\"execve\");\n+    exit(1);\n+  }\n+\n+  int status;\n+  int ret;\n+  do {\n+    ret = waitpid(pid, &status, 0);\n+  } while (ret == -1 && errno == EINTR);\n+\n+  if (ret == -1 || !WIFEXITED(status)) {\n+    return -1;\n+  }\n+  return WEXITSTATUS(status) == 0 ? 0 : -1;\n+}\n+\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":39,"deletions":0,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-#include \"perfMemory_linux.hpp\"\n@@ -43,0 +42,4 @@\n+#ifdef LINUX\n+#include \"perfMemory_linux.hpp\"\n+#endif \/\/LINUX\n+\n@@ -1331,0 +1334,1 @@\n+#ifdef LINUX\n@@ -1428,0 +1432,1 @@\n+#endif \/\/LINUX\n","filename":"src\/hotspot\/os\/posix\/perfMemory_posix.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"jvm.h\"\n+#include \"runtime\/crac_structs.hpp\"\n+\n+void crac::vm_create_start() {\n+}\n+\n+void VM_Crac::report_ok_to_jcmd_if_any() {\n+}\n+\n+bool VM_Crac::check_fds() {\n+  return true;\n+}\n+\n+bool VM_Crac::memory_checkpoint() {\n+  return true;\n+}\n+\n+void VM_Crac::memory_restore() {\n+}\n+\n+int CracSHM::open(int mode) {\n+  return -1;\n+}\n+\n+void CracSHM::unlink() {\n+}\n+\n+bool crac::read_bootid(char *dest) {\n+  return true;\n+}\n","filename":"src\/hotspot\/os\/windows\/crac_windows.cpp","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -49,0 +49,1 @@\n+#include \"runtime\/crac.hpp\"\n@@ -1329,0 +1330,27 @@\n+\/\/ NOTE: is_path_absolute() function implementation is mostly a copy from FileSystemSupport_md.c\n+\/\/ WinAPI has PathIsRelative() function for this purpose, however it causes linkage to Shlwapi.dll.\n+static int prefixLength(const char* path) {\n+    assert(1 == strlen(os::file_separator()), \"the file separator must be a single-char, not a string\");\n+    char c0, c1;\n+\n+    int n = (int)strlen(path);\n+    if (n == 0) return 0;\n+    c0 = path[0];\n+    c1 = (n > 1) ? path[1] : 0;\n+    if (c0 == *os::file_separator()) {\n+        if (c1 == *os::file_separator()) return 2;      \/* Absolute UNC pathname \"\\\\\\\\foo\" *\/\n+        return 1;                       \/* Drive-relative \"\\\\foo\" *\/\n+    }\n+    if (::isalpha(c0) && (c1 == ':')) {\n+        if ((n > 2) && (path[2] == *os::file_separator()))\n+            return 3;           \/* Absolute local pathname \"z:\\\\foo\" *\/\n+        return 2;                       \/* Directory-relative \"z:foo\" *\/\n+    }\n+    return 0;                   \/* Completely relative *\/\n+}\n+\n+bool os::is_path_absolute(const char *path) {\n+  int pl = prefixLength(path);\n+  return (((pl == 2) && (path[0] == *os::file_separator())) || (pl == 3));\n+}\n+\n@@ -4459,0 +4487,25 @@\n+int os::mkdir(const char *path) {\n+  errno_t err;\n+  wchar_t* wide_path = wide_abs_unc_path(path, err);\n+  if (wide_path == NULL) {\n+    errno = err;\n+    return -1;\n+  }\n+  int res = _wmkdir(wide_path);\n+  os::free(wide_path);\n+  return res;\n+}\n+\n+int os::rmdir(const char *path) {\n+  errno_t err;\n+  wchar_t* wide_path = wide_abs_unc_path(path, err);\n+  if (wide_path == NULL) {\n+    errno = err;\n+    return -1;\n+  }\n+  int res = _wrmdir(wide_path);\n+  os::free(wide_path);\n+  return res;\n+}\n+\n+\n@@ -5601,0 +5654,5 @@\n+int os::exec_child_process_and_wait(const char *path, const char *argv[]) {\n+  const int status = _spawnv(_P_WAIT, path, argv); \/\/ env is inherited by a child process\n+  return 0 == status ? 0 : -1;\n+}\n+\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":58,"deletions":0,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -24,2 +24,2 @@\n-\/\/ no precompiled headers\n-#include \"attachListener_linux.hpp\"\n+#include \"precompiled.hpp\"\n+\n@@ -28,1 +28,0 @@\n-#include \"linuxAttachOperation.hpp\"\n@@ -31,2 +30,1 @@\n-#include \"perfMemory_linux.hpp\"\n-#include \"runtime\/arguments.hpp\"\n+#include \"runtime\/crac_structs.hpp\"\n@@ -38,1 +36,0 @@\n-#include \"runtime\/vmOperation.hpp\"\n@@ -40,1 +37,0 @@\n-#include \"services\/attachListener.hpp\"\n@@ -43,205 +39,0 @@\n-#include \"utilities\/growableArray.hpp\"\n-\n-#include <fcntl.h>\n-#include <sys\/mman.h>\n-#include <sys\/stat.h>\n-#include <sys\/wait.h>\n-#include <unistd.h>\n-\n-class FdsInfo {\n-public:\n-\n-  enum state_t {\n-    INVALID = -3,\n-    CLOSED = -2,\n-    ROOT = -1,\n-    DUP_OF_0 = 0,\n-    \/\/ ...\n-  };\n-\n-  enum mark_t {\n-    M_CANT_RESTORE = 1 << 0,\n-  };\n-\n-private:\n-  struct fdinfo {\n-    int fd;\n-    struct stat stat;\n-    state_t state;\n-    unsigned mark;\n-\n-    int flags;\n-  };\n-\n-  \/\/ params are indices into _fdinfos\n-  bool same_fd(int i1, int i2);\n-\n-  bool _inited;\n-  GrowableArray<fdinfo> _fdinfos;\n-\n-  void assert_mark(int i) {\n-    assert(_inited, \"\");\n-    assert(i < _fdinfos.length(), \"\");\n-    assert(_fdinfos.at(i).state != CLOSED, \"\");\n-  }\n-\n-public:\n-  void initialize();\n-\n-  int len() { return _fdinfos.length(); }\n-\n-  state_t get_state(int i) {\n-    assert(_inited, \"\");\n-    assert(i < _fdinfos.length(), \"\");\n-    return _fdinfos.at(i).state;\n-  }\n-\n-  state_t find_state(int fd, state_t orstate) {\n-    for (int i = 0; i < _fdinfos.length(); ++i) {\n-      fdinfo *info = _fdinfos.adr_at(i);\n-      if (info->fd == fd) {\n-        return info->state;\n-      }\n-    }\n-    return orstate;\n-  }\n-\n-  int get_fd(int i) {\n-    assert(_inited, \"\");\n-    assert(i < _fdinfos.length(), \"\");\n-    return _fdinfos.at(i).fd;\n-  }\n-\n-  struct stat* get_stat(int i) {\n-    assert(_inited, \"\");\n-    assert(i < _fdinfos.length(), \"\");\n-    return &_fdinfos.at(i).stat;\n-  }\n-\n-  FdsInfo(bool do_init = true) :\n-    _inited(false),\n-    _fdinfos(16, mtInternal)\n-  {\n-    if (do_init) {\n-      initialize();\n-    }\n-  }\n-};\n-\n-struct CracFailDep {\n-  int _type;\n-  char* _msg;\n-  CracFailDep(int type, char* msg) :\n-    _type(type),\n-    _msg(msg)\n-  { }\n-  CracFailDep() :\n-    _type(JVM_CR_FAIL),\n-    _msg(NULL)\n-  { }\n-};\n-\n-class CracRestoreParameters : public CHeapObj<mtInternal> {\n-  char* _raw_content;\n-  GrowableArray<const char *>* _properties;\n-  const char* _args;\n-\n-  struct header {\n-    jlong _restore_time;\n-    jlong _restore_nanos;\n-    int _nflags;\n-    int _nprops;\n-    int _env_memory_size;\n-  };\n-\n-  static bool write_check_error(int fd, const void *buf, int count) {\n-    int wret = write(fd, buf, count);\n-    if (wret != count) {\n-      if (wret < 0) {\n-        perror(\"shm error\");\n-      } else {\n-        fprintf(stderr, \"write shm truncated\");\n-      }\n-      return false;\n-    }\n-    return true;\n-  }\n-\n-  static int system_props_length(const SystemProperty* props) {\n-    int len = 0;\n-    while (props != NULL) {\n-      ++len;\n-      props = props->next();\n-    }\n-    return len;\n-  }\n-\n-  static int env_vars_size(const char* const * env) {\n-    int len = 0;\n-    for (; *env; ++env) {\n-      len += strlen(*env) + 1;\n-    }\n-    return len;\n-  }\n-\n- public:\n-  const char *args() const { return _args; }\n-  GrowableArray<const char *>* properties() const { return _properties; }\n-\n-  CracRestoreParameters() :\n-    _raw_content(NULL),\n-    _properties(new (ResourceObj::C_HEAP, mtInternal) GrowableArray<const char *>(0, mtInternal)),\n-    _args(NULL)\n-  {}\n-\n-  ~CracRestoreParameters() {\n-    if (_raw_content) {\n-      FREE_C_HEAP_ARRAY(char, _raw_content);\n-    }\n-    delete _properties;\n-  }\n-\n-  static bool write_to(int fd,\n-      const char* const* flags, int num_flags,\n-      const SystemProperty* props,\n-      const char *args,\n-      jlong restore_time,\n-      jlong restore_nanos) {\n-    header hdr = {\n-      restore_time,\n-      restore_nanos,\n-      num_flags,\n-      system_props_length(props),\n-      env_vars_size(environ)\n-    };\n-\n-    if (!write_check_error(fd, (void *)&hdr, sizeof(header))) {\n-      return false;\n-    }\n-\n-    for (int i = 0; i < num_flags; ++i) {\n-      if (!write_check_error(fd, flags[i], strlen(flags[i]) + 1)) {\n-        return false;\n-      }\n-    }\n-\n-    const SystemProperty* p = props;\n-    while (p != NULL) {\n-      char prop[4096];\n-      int len = snprintf(prop, sizeof(prop), \"%s=%s\", p->key(), p->value());\n-      guarantee((0 < len) && ((unsigned)len < sizeof(prop)), \"property does not fit temp buffer\");\n-      if (!write_check_error(fd, prop, len+1)) {\n-        return false;\n-      }\n-      p = p->next();\n-    }\n-\n-    \/\/ Write env vars\n-    for (char** env = environ; *env; ++env) {\n-      if (!write_check_error(fd, *env, strlen(*env) + 1)) {\n-        return false;\n-      }\n-    }\n-\n-    return write_check_error(fd, args, strlen(args)+1); \/\/ +1 for null char\n-  }\n@@ -249,44 +40,3 @@\n-  bool read_from(int fd);\n-\n-};\n-\n-class VM_Crac: public VM_Operation {\n-  jarray _fd_arr;\n-  const bool _dry_run;\n-  bool _ok;\n-  GrowableArray<CracFailDep>* _failures;\n-  CracRestoreParameters _restore_parameters;\n-  outputStream* _ostream;\n-  LinuxAttachOperation* _attach_op;\n-\n-public:\n-  VM_Crac(jarray fd_arr, jobjectArray obj_arr, bool dry_run, bufferedStream* jcmd_stream) :\n-    _fd_arr(fd_arr),\n-    _dry_run(dry_run),\n-    _ok(false),\n-    _failures(new (ResourceObj::C_HEAP, mtInternal) GrowableArray<CracFailDep>(0, mtInternal)),\n-    _restore_parameters(),\n-    _ostream(jcmd_stream ? jcmd_stream : tty),\n-    _attach_op(jcmd_stream ? LinuxAttachListener::get_current_op() : NULL)\n-  { }\n-\n-  ~VM_Crac() {\n-    delete _failures;\n-  }\n-\n-  GrowableArray<CracFailDep>* failures() { return _failures; }\n-  bool ok() { return _ok; }\n-  const char* new_args() { return _restore_parameters.args(); }\n-  GrowableArray<const char *>* new_properties() { return _restore_parameters.properties(); }\n-  virtual bool allow_nested_vm_operations() const  { return true; }\n-  VMOp_Type type() const { return VMOp_VM_Crac; }\n-  void doit();\n-  bool read_shm(int shmid);\n-\n-private:\n-  bool is_claimed_fd(int fd);\n-  bool is_socket_from_jcmd(int sock_fd);\n-  void report_ok_to_jcmd_if_any();\n-  void print_resources(const char* msg, ...);\n-  void trace_cr(const char* msg, ...);\n-};\n+#ifdef _WINDOWS\n+#include <process.h>\n+#endif\n@@ -300,1 +50,0 @@\n-static FdsInfo _vm_inited_fds(false);\n@@ -329,0 +78,4 @@\n+#ifdef __clang__\n+#pragma clang diagnostic push\n+#pragma clang diagnostic ignored \"-Wformat-nonliteral\"\n+#endif\n@@ -330,0 +83,3 @@\n+#ifdef __clang__\n+#pragma clang diagnostic pop\n+#endif\n@@ -338,0 +94,4 @@\n+#ifdef __clang__\n+#pragma clang diagnostic push\n+#pragma clang diagnostic ignored \"-Wformat-nonliteral\"\n+#endif\n@@ -339,0 +99,3 @@\n+#ifdef __clang__\n+#pragma clang diagnostic pop\n+#endif\n@@ -343,26 +106,4 @@\n-void crac::vm_create_start() {\n-  if (!CRaCCheckpointTo) {\n-    return;\n-  }\n-  close_extra_descriptors();\n-  _vm_inited_fds.initialize();\n-}\n-\n-\/* taken from criu, that took this from kernel *\/\n-#define NFS_PREF \".nfs\"\n-#define NFS_PREF_LEN ((unsigned)sizeof(NFS_PREF) - 1)\n-#define NFS_FILEID_LEN ((unsigned)sizeof(uint64_t) << 1)\n-#define NFS_COUNTER_LEN ((unsigned)sizeof(unsigned int) << 1)\n-#define NFS_LEN (NFS_PREF_LEN + NFS_FILEID_LEN + NFS_COUNTER_LEN)\n-static bool nfs_silly_rename(char* path) {\n-  char *sep = strrchr(path, '\/');\n-  char *base = sep ? sep + 1 : path;\n-  if (strncmp(base, NFS_PREF, NFS_PREF_LEN)) {\n-    return false;\n-  }\n-  for (unsigned i = NFS_PREF_LEN; i < NFS_LEN; ++i) {\n-    if (!isxdigit(base[i])) {\n-      return false;\n-    }\n-  }\n-  return true;\n+#if defined(__APPLE__) || defined(_WINDOWS)\n+static char * strchrnul(char * str, char c) {\n+  for (; *str && c != *str; ++str) {}\n+  return str;\n@@ -370,0 +111,1 @@\n+#endif \/\/__APPLE__ || _WINDOWS\n@@ -371,101 +113,1 @@\n-static int readfdlink(int fd, char *link, size_t len) {\n-  char fdpath[64];\n-  snprintf(fdpath, sizeof(fdpath), \"\/proc\/self\/fd\/%d\", fd);\n-  int ret = readlink(fdpath, link, len);\n-  if (ret == -1) {\n-    return ret;\n-  }\n-  link[(unsigned)ret < len ? ret : len - 1] = '\\0';\n-  return ret;\n-}\n-\n-static bool same_stat(struct stat* st1, struct stat* st2) {\n-  return st1->st_dev == st2->st_dev &&\n-         st1->st_ino == st2->st_ino;\n-}\n-\n-bool FdsInfo::same_fd(int i1, int i2) {\n-  assert(i1 < _fdinfos.length(), \"\");\n-  assert(i2 < _fdinfos.length(), \"\");\n-  fdinfo *fi1 = _fdinfos.adr_at(i1);\n-  fdinfo *fi2 = _fdinfos.adr_at(i2);\n-  if (!same_stat(&fi1->stat, &fi2->stat)) {\n-    return false;\n-  }\n-\n-  int flags1 = fcntl(fi1->fd, F_GETFL);\n-  int flags2 = fcntl(fi2->fd, F_GETFL);\n-  if (flags1 != flags2) {\n-    return false;\n-  }\n-\n-  const int test_flag = O_NONBLOCK;\n-  const int new_flags1 = flags1 ^ test_flag;\n-  fcntl(fi1->fd, F_SETFL, new_flags1);\n-  if (fcntl(fi1->fd, F_GETFL) != new_flags1) {\n-    \/\/ flag write ignored or handled differently,\n-    \/\/ don't know what to do\n-    return false;\n-  }\n-\n-  const int new_flags2 = fcntl(fi2->fd, F_GETFL);\n-  const bool are_same = new_flags1 == new_flags2;\n-\n-  fcntl(fi2->fd, flags1);\n-\n-  return are_same;\n-}\n-\n-void FdsInfo::initialize() {\n-  assert(!_inited, \"should be called only once\");\n-\n-  char path[PATH_MAX];\n-  struct dirent *dp;\n-\n-  DIR *dir = opendir(\"\/proc\/self\/fd\");\n-  int dfd = dirfd(dir);\n-  while (dp = readdir(dir)) {\n-    if (dp->d_name[0] == '.') {\n-      \/\/ skip \".\" and \"..\"\n-      continue;\n-    }\n-    fdinfo info;\n-    info.fd = atoi(dp->d_name);\n-    if (info.fd == dfd) {\n-      continue;\n-    }\n-    int r = fstat(info.fd, &info.stat);\n-    if (r == -1) {\n-      info.state = CLOSED;\n-      continue;\n-    }\n-    info.state = ROOT; \/\/ can be changed to DUP_OF_0 + N below\n-    info.mark = 0;\n-    _fdinfos.append(info);\n-  }\n-  closedir(dir);\n-  _inited = true;\n-\n-  for (int i = 0; i < _fdinfos.length(); ++i) {\n-    fdinfo *info = _fdinfos.adr_at(i);\n-    for (int j = 0; j < i; ++j) {\n-      if (get_state(j) == ROOT && same_fd(i, j)) {\n-        info->state = (state_t)(DUP_OF_0 + j);\n-        break;\n-      }\n-    }\n-\n-    if (info->state == ROOT) {\n-      char fdpath[PATH_MAX];\n-      int r = readfdlink(info->fd, fdpath, sizeof(fdpath));\n-      guarantee(-1 != r, \"can't stat fd\");\n-      if (info->stat.st_nlink == 0 ||\n-          strstr(fdpath, \"(deleted)\") ||\n-          nfs_silly_rename(fdpath)) {\n-        info->mark |= FdsInfo::M_CANT_RESTORE;\n-      }\n-    }\n-  }\n-}\n-\n-static int cr_util_path(char* path, int len) {\n+static size_t cr_util_path(char* path, int len) {\n@@ -473,1 +115,2 @@\n-  \/\/ path is \"...\/lib\/server\/libjvm.so\"\n+  \/\/ path is \"...\/lib\/server\/libjvm.so\", or \"...\\bin\\server\\libjvm.dll\"\n+  assert(1 == strlen(os::file_separator()), \"file separator must be a single-char, not a string\");\n@@ -476,1 +119,1 @@\n-    after_elem = strrchr(path, '\/');\n+    after_elem = strrchr(path, *os::file_separator());\n@@ -498,1 +141,1 @@\n-  if (exec[0] == '\/') {\n+  if (os::is_path_absolute(exec)) {\n@@ -502,2 +145,2 @@\n-    int pathlen = cr_util_path(path, sizeof(path));\n-    strcat(path + pathlen, \"\/\");\n+    size_t pathlen = cr_util_path(path, sizeof(path));\n+    strcat(path + pathlen, os::file_separator());\n@@ -505,0 +148,13 @@\n+#ifdef _WINDOWS\n+    {\n+      \/\/ Add \".exe\" if needed\n+      const char * const exe_suffix = \".exe\";\n+      const size_t exe_suffix_len = strlen(exe_suffix);\n+      pathlen = strlen(path);\n+      if (exe_suffix_len < pathlen) {\n+        if (0 != strncmp(path + pathlen - exe_suffix_len, exe_suffix, exe_suffix_len)) {\n+          strcat(path + pathlen, exe_suffix);\n+        }\n+      }\n+    }\n+#endif\n@@ -507,1 +163,1 @@\n-    if (0 != stat(path, &st)) {\n+    if (0 != os::stat(path, &st)) {\n@@ -562,24 +218,3 @@\n-\n-  pid_t pid = fork();\n-  if (pid == -1) {\n-    perror(\"cannot fork for crengine\");\n-    return -1;\n-  }\n-  if (pid == 0) {\n-    _crengine_args[1] = \"checkpoint\";\n-    add_crengine_arg(CRaCCheckpointTo);\n-    execv(_crengine, (char * const*)_crengine_args);\n-    perror(\"execv CREngine checkpoint\");\n-    exit(1);\n-  }\n-\n-  int status;\n-  int ret;\n-  do {\n-    ret = waitpid(pid, &status, 0);\n-  } while (ret == -1 && errno == EINTR);\n-\n-  if (ret == -1 || !WIFEXITED(status)) {\n-    return -1;\n-  }\n-  return WEXITSTATUS(status) == 0 ? 0 : -1;\n+  _crengine_args[1] = \"checkpoint\";\n+  add_crengine_arg(CRaCCheckpointTo);\n+  return os::exec_child_process_and_wait(_crengine, _crengine_args);\n@@ -588,23 +223,0 @@\n-class CracSHM {\n-  char _path[128];\n-public:\n-  CracSHM(int id) {\n-    int shmpathlen = snprintf(_path, sizeof(_path), \"\/crac_%d\", id);\n-    if (shmpathlen < 0 || sizeof(_path) <= (size_t)shmpathlen) {\n-      fprintf(stderr, \"shmpath is too long: %d\\n\", shmpathlen);\n-    }\n-  }\n-\n-  int open(int mode) {\n-    int shmfd = shm_open(_path, mode, 0600);\n-    if (-1 == shmfd) {\n-      perror(\"shm_open\");\n-    }\n-    return shmfd;\n-  }\n-\n-  void unlink() {\n-    shm_unlink(_path);\n-  }\n-};\n-\n@@ -619,0 +231,1 @@\n+#ifdef LINUX\n@@ -633,0 +246,3 @@\n+#else\n+  \/\/ TODO add sync processing\n+#endif \/\/LINUX\n@@ -640,0 +256,1 @@\n+#ifdef LINUX\n@@ -652,1 +269,3 @@\n-\n+#else\n+  *shmid = 0;\n+#endif \/\/LINUX\n@@ -656,32 +275,0 @@\n-static const char* stat2strtype(mode_t mode) {\n-  switch (mode & S_IFMT) {\n-  case S_IFSOCK: return \"socket\";\n-  case S_IFLNK:  return \"symlink\";\n-  case S_IFREG:  return \"regular\";\n-  case S_IFBLK:  return \"block\";\n-  case S_IFDIR:  return \"directory\";\n-  case S_IFCHR:  return \"character\";\n-  case S_IFIFO:  return \"fifo\";\n-  default:       break;\n-  }\n-  return \"unknown\";\n-}\n-\n-static int stat2stfail(mode_t mode) {\n-  switch (mode & S_IFMT) {\n-  case S_IFSOCK:\n-    return JVM_CR_FAIL_SOCK;\n-  case S_IFLNK:\n-  case S_IFREG:\n-  case S_IFBLK:\n-  case S_IFDIR:\n-  case S_IFCHR:\n-    return JVM_CR_FAIL_FILE;\n-  case S_IFIFO:\n-    return JVM_CR_FAIL_PIPE;\n-  default:\n-    break;\n-  }\n-  return JVM_CR_FAIL;\n-}\n-\n@@ -700,17 +287,0 @@\n-\/\/ If checkpoint is called throught the API, jcmd operation and jcmd output doesn't exist.\n-bool VM_Crac::is_socket_from_jcmd(int sock) {\n-  if (_attach_op == NULL)\n-    return false;\n-  int sock_fd = _attach_op->socket();\n-  return sock == sock_fd;\n-}\n-\n-void VM_Crac::report_ok_to_jcmd_if_any() {\n-  if (_attach_op == NULL)\n-    return;\n-  bufferedStream* buf = static_cast<bufferedStream*>(_ostream);\n-  _attach_op->effectively_complete_raw(JNI_OK, buf);\n-  \/\/ redirect any further output to console\n-  _ostream = tty;\n-}\n-\n@@ -746,5 +316,1 @@\n-\n-  AttachListener::abort();\n-\n-  FdsInfo fds;\n-\n+  \/\/ dry-run fails checkpoint\n@@ -753,31 +319,1 @@\n-  for (int i = 0; i < fds.len(); ++i) {\n-    if (fds.get_state(i) == FdsInfo::CLOSED) {\n-      continue;\n-    }\n-    int fd = fds.get_fd(i);\n-\n-    char detailsbuf[PATH_MAX];\n-    struct stat* st = fds.get_stat(i);\n-    const char* type = stat2strtype(st->st_mode);\n-    int linkret = readfdlink(fd, detailsbuf, sizeof(detailsbuf));\n-    const char* details = 0 < linkret ? detailsbuf : \"\";\n-    print_resources(\"JVM: FD fd=%d type=%s path=\\\"%s\\\" \", fd, type, details);\n-\n-    if (is_claimed_fd(fd)) {\n-      print_resources(\"OK: claimed by java code\\n\");\n-      continue;\n-    }\n-\n-    if (_vm_inited_fds.find_state(fd, FdsInfo::CLOSED) != FdsInfo::CLOSED) {\n-      print_resources(\"OK: inherited from process env\\n\");\n-      continue;\n-    }\n-\n-    if (S_ISSOCK(st->st_mode)) {\n-      if (is_socket_from_jcmd(fd)){\n-        print_resources(\"OK: jcmd socket\\n\");\n-        continue;\n-      }\n-    }\n-\n-    print_resources(\"BAD: opened by application\\n\");\n+  if (!check_fds()) {\n@@ -785,7 +321,0 @@\n-\n-    const int maxinfo = 64;\n-    size_t buflen = strlen(details) + maxinfo;\n-    char* msg = NEW_C_HEAP_ARRAY(char, buflen, mtInternal);\n-    int len = snprintf(msg, buflen, \"FD fd=%d type=%s path=%s\", fd, type, detailsbuf);\n-    msg[len < 0 ? 0 : ((size_t) len >= buflen ? buflen - 1 : len)] = '\\0';\n-    _failures->append(CracFailDep(stat2stfail(st->st_mode & S_IFMT), msg));\n@@ -805,1 +334,1 @@\n-  if (!PerfMemoryLinux::checkpoint(CRaCCheckpointTo)) {\n+  if (!memory_checkpoint()) {\n@@ -817,1 +346,1 @@\n-      PerfMemoryLinux::restore();\n+      memory_restore();\n@@ -830,1 +359,1 @@\n-  PerfMemoryLinux::restore();\n+  memory_restore();\n@@ -840,1 +369,1 @@\n-  if (0 == stat(CRaCCheckpointTo, &st)) {\n+  if (0 == os::stat(CRaCCheckpointTo, &st)) {\n@@ -846,1 +375,1 @@\n-    if (-1 == mkdir(CRaCCheckpointTo, 0700)) {\n+    if (-1 == os::mkdir(CRaCCheckpointTo)) {\n@@ -850,1 +379,1 @@\n-    if (-1 == rmdir(CRaCCheckpointTo)) {\n+    if (-1 == os::rmdir(CRaCCheckpointTo)) {\n@@ -866,1 +395,2 @@\n-  jvalue jval = { .i = ret };\n+  jvalue jval;\n+  jval.i = ret;\n@@ -883,1 +413,1 @@\n-  if (-1 == mkdir(CRaCCheckpointTo, 0700) && errno != EEXIST) {\n+  if (-1 == os::mkdir(CRaCCheckpointTo) && errno != EEXIST) {\n@@ -931,2 +461,0 @@\n-  struct stat st;\n-\n@@ -938,1 +466,2 @@\n-  int id = getpid();\n+  const int id = os::current_process_id();\n+\n@@ -951,1 +480,1 @@\n-      setenv(\"CRAC_NEW_ARGS_ID\", strid, true);\n+      LINUX_ONLY(setenv(\"CRAC_NEW_ARGS_ID\", strid, true));\n@@ -960,0 +489,3 @@\n+#ifdef _WINDOWS\n+    _execv(_crengine, _crengine_args);\n+#else\n@@ -961,0 +493,1 @@\n+#endif \/\/_WINDOWS\n@@ -965,64 +498,0 @@\n-static char modules_path[JVM_MAXPATHLEN] = { '\\0' };\n-\n-static bool is_fd_ignored(int fd, const char *path) {\n-  const char *list = CRaCIgnoredFileDescriptors;\n-  while (list && *list) {\n-    const char *end = strchr(list, ',');\n-    if (!end) {\n-      end = list + strlen(list);\n-    }\n-    char *invalid;\n-    int ignored_fd = strtol(list, &invalid, 10);\n-    if (invalid == end) { \/\/ entry was integer -> file descriptor\n-      if (fd == ignored_fd) {\n-        log_trace(os)(\"CRaC not closing file descriptor %d (%s) as it is marked as ignored.\", fd, path);\n-        return true;\n-      }\n-    } else { \/\/ interpret entry as path\n-      int path_len = path ? strlen(path) : -1;\n-      if (path_len != -1 && path_len == end - list && !strncmp(path, list, end - list)) {\n-        log_trace(os)(\"CRaC not closing file descriptor %d (%s) as it is marked as ignored.\", fd, path);\n-        return true;\n-      }\n-    }\n-    if (*end) {\n-      list = end + 1;\n-    } else {\n-      break;\n-    }\n-  }\n-\n-  if (os::same_files(modules_path, path)) {\n-    \/\/ Path to the modules directory is opened early when JVM is booted up and won't be closed.\n-    \/\/ We can ignore this for purposes of CRaC.\n-    return true;\n-  }\n-\n-  return false;\n-}\n-\n-void crac::close_extra_descriptors() {\n-  \/\/ Path to the modules directory is opened early when JVM is booted up and won't be closed.\n-  \/\/ We can ignore this for purposes of CRaC.\n-  if (modules_path[0] == '\\0') {\n-    const char* fileSep = os::file_separator();\n-    jio_snprintf(modules_path, JVM_MAXPATHLEN, \"%s%slib%s\" MODULES_IMAGE_NAME, Arguments::get_java_home(), fileSep, fileSep);\n-  }\n-\n-  char path[PATH_MAX];\n-  struct dirent *dp;\n-\n-  DIR *dir = opendir(\"\/proc\/self\/fd\");\n-  while (dp = readdir(dir)) {\n-    int fd = atoi(dp->d_name);\n-    if (fd > 2 && fd != dirfd(dir)) {\n-      int r = readfdlink(fd, path, sizeof(path));\n-      if (!is_fd_ignored(fd, r != -1 ? path : nullptr)) {\n-        log_warning(os)(\"CRaC closing file descriptor %d: %s\", fd, path);\n-        close(fd);\n-      }\n-    }\n-  }\n-  closedir(dir);\n-}\n-\n@@ -1080,1 +549,1 @@\n-    int prop_len = strlen(cursor) + 1;\n+    size_t prop_len = strlen(cursor) + 1;\n@@ -1135,38 +604,0 @@\n-\n-static bool read_all(int fd, char *dest, size_t n) {\n-  size_t rd = 0;\n-  do {\n-    ssize_t r = ::read(fd, dest + rd, n - rd);\n-    if (r == 0) {\n-      return false;\n-    } else if (r < 0) {\n-      if (errno == EINTR) {\n-        continue;\n-      }\n-      return false;\n-    }\n-    rd += r;\n-  } while (rd < n);\n-  return true;\n-}\n-\n-bool crac::read_bootid(char *dest) {\n-  int fd = ::open(\"\/proc\/sys\/kernel\/random\/boot_id\", O_RDONLY);\n-  if (fd < 0 || !read_all(fd, dest, UUID_LENGTH)) {\n-    perror(\"CRaC: Cannot read system boot ID\");\n-    return false;\n-  }\n-  char c;\n-  if (!read_all(fd, &c, 1) || c != '\\n') {\n-    perror(\"CRaC: system boot ID does not end with newline\");\n-    return false;\n-  }\n-  if (::read(fd, &c, 1) != 0) {\n-    perror(\"CRaC: Unexpected data\/error reading system boot ID\");\n-    return false;\n-  }\n-  if (::close(fd) != 0) {\n-    perror(\"CRaC: Cannot close system boot ID file\");\n-  }\n-  return true;\n-}\n","filename":"src\/hotspot\/share\/runtime\/crac.cpp","additions":76,"deletions":645,"binary":false,"changes":721,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-  static void close_extra_descriptors();\n","filename":"src\/hotspot\/share\/runtime\/crac.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,223 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef SHARE_RUNTIME_CRAC_STRUCTS_HPP\n+#define SHARE_RUNTIME_CRAC_STRUCTS_HPP\n+\n+#include \"jvm.h\"\n+#include \"runtime\/arguments.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+#include \"utilities\/macros.hpp\"\n+#include \"runtime\/vmOperation.hpp\"\n+\n+#ifdef LINUX\n+#include \"attachListener_linux.hpp\"\n+#include \"linuxAttachOperation.hpp\"\n+#include \"services\/attachListener.hpp\"\n+#endif\n+\n+struct CracFailDep {\n+  int _type;\n+  char* _msg;\n+  CracFailDep(int type, char* msg) :\n+    _type(type),\n+    _msg(msg)\n+  { }\n+  CracFailDep() :\n+    _type(JVM_CR_FAIL),\n+    _msg(NULL)\n+  { }\n+};\n+\n+class CracRestoreParameters : public CHeapObj<mtInternal> {\n+  char* _raw_content;\n+  GrowableArray<const char *>* _properties;\n+  const char* _args;\n+\n+  struct header {\n+    jlong _restore_time;\n+    jlong _restore_nanos;\n+    int _nflags;\n+    int _nprops;\n+    int _env_memory_size;\n+  };\n+\n+  static bool write_check_error(int fd, const void *buf, int count) {\n+    int wret = write(fd, buf, count);\n+    if (wret != count) {\n+      if (wret < 0) {\n+        perror(\"shm error\");\n+      } else {\n+        fprintf(stderr, \"write shm truncated\");\n+      }\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  static int system_props_length(const SystemProperty* props) {\n+    int len = 0;\n+    while (props != NULL) {\n+      ++len;\n+      props = props->next();\n+    }\n+    return len;\n+  }\n+\n+  static int env_vars_size(const char* const * env) {\n+    int len = 0;\n+    for (; *env; ++env) {\n+      len += (int)strlen(*env) + 1;\n+    }\n+    return len;\n+  }\n+\n+ public:\n+  const char *args() const { return _args; }\n+  GrowableArray<const char *>* properties() const { return _properties; }\n+\n+  CracRestoreParameters() :\n+    _raw_content(NULL),\n+    _properties(new (ResourceObj::C_HEAP, mtInternal) GrowableArray<const char *>(0, mtInternal)),\n+    _args(NULL)\n+  {}\n+\n+  ~CracRestoreParameters() {\n+    if (_raw_content) {\n+      FREE_C_HEAP_ARRAY(char, _raw_content);\n+    }\n+    delete _properties;\n+  }\n+\n+  static bool write_to(int fd,\n+      const char* const* flags, int num_flags,\n+      const SystemProperty* props,\n+      const char *args,\n+      jlong restore_time,\n+      jlong restore_nanos) {\n+    header hdr = {\n+      restore_time,\n+      restore_nanos,\n+      num_flags,\n+      system_props_length(props),\n+      env_vars_size(os::get_environ())\n+    };\n+\n+    if (!write_check_error(fd, (void *)&hdr, sizeof(header))) {\n+      return false;\n+    }\n+\n+    for (int i = 0; i < num_flags; ++i) {\n+      if (!write_check_error(fd, flags[i], (int)strlen(flags[i]) + 1)) {\n+        return false;\n+      }\n+    }\n+\n+    const SystemProperty* p = props;\n+    while (p != NULL) {\n+      char prop[4096];\n+      int len = snprintf(prop, sizeof(prop), \"%s=%s\", p->key(), p->value());\n+      guarantee((0 < len) && ((unsigned)len < sizeof(prop)), \"property does not fit temp buffer\");\n+      if (!write_check_error(fd, prop, len+1)) {\n+        return false;\n+      }\n+      p = p->next();\n+    }\n+\n+    \/\/ Write env vars\n+    for (char** env = os::get_environ(); *env; ++env) {\n+      if (!write_check_error(fd, *env, (int)strlen(*env) + 1)) {\n+        return false;\n+      }\n+    }\n+\n+    return write_check_error(fd, args, (int)strlen(args)+1); \/\/ +1 for null char\n+  }\n+\n+  bool read_from(int fd);\n+\n+};\n+\n+class VM_Crac: public VM_Operation {\n+  jarray _fd_arr;\n+  const bool _dry_run;\n+  bool _ok;\n+  GrowableArray<CracFailDep>* _failures;\n+  CracRestoreParameters _restore_parameters;\n+  outputStream* _ostream;\n+#ifdef LINUX\n+  LinuxAttachOperation* _attach_op;\n+#endif \/\/LINUX\n+\n+public:\n+  VM_Crac(jarray fd_arr, jobjectArray obj_arr, bool dry_run, bufferedStream* jcmd_stream) :\n+    _fd_arr(fd_arr),\n+    _dry_run(dry_run),\n+    _ok(false),\n+    _failures(new (ResourceObj::C_HEAP, mtInternal) GrowableArray<CracFailDep>(0, mtInternal)),\n+    _restore_parameters(),\n+    _ostream(jcmd_stream ? jcmd_stream : tty)\n+#ifdef LINUX\n+    , _attach_op(jcmd_stream ? LinuxAttachListener::get_current_op() : NULL)\n+#endif \/\/LINUX\n+  { }\n+\n+  ~VM_Crac() {\n+    delete _failures;\n+  }\n+\n+  GrowableArray<CracFailDep>* failures() { return _failures; }\n+  bool ok() { return _ok; }\n+  const char* new_args() { return _restore_parameters.args(); }\n+  GrowableArray<const char *>* new_properties() { return _restore_parameters.properties(); }\n+  virtual bool allow_nested_vm_operations() const  { return true; }\n+  VMOp_Type type() const { return VMOp_VM_Crac; }\n+  void doit();\n+  bool read_shm(int shmid);\n+\n+private:\n+  bool is_claimed_fd(int fd);\n+  bool is_socket_from_jcmd(int sock_fd);\n+  void report_ok_to_jcmd_if_any();\n+  void print_resources(const char* msg, ...);\n+  void trace_cr(const char* msg, ...);\n+  bool check_fds();\n+  bool memory_checkpoint();\n+  void memory_restore();\n+};\n+\n+class CracSHM {\n+  char _path[128];\n+public:\n+  CracSHM(int id) {\n+    int shmpathlen = snprintf(_path, sizeof(_path), \"\/crac_%d\", id);\n+    if (shmpathlen < 0 || sizeof(_path) <= (size_t)shmpathlen) {\n+      fprintf(stderr, \"shmpath is too long: %d\\n\", shmpathlen);\n+    }\n+  }\n+\n+  int open(int mode);\n+  void unlink();\n+};\n+\n+#endif \/\/SHARE_RUNTIME_CRAC_STRUCTS_HPP\n","filename":"src\/hotspot\/share\/runtime\/crac_structs.hpp","additions":223,"deletions":0,"binary":false,"changes":223,"status":"added"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"crac.hpp\"\n@@ -42,0 +43,1 @@\n+#include \"memory\/oopFactory.hpp\"\n@@ -55,0 +57,1 @@\n+#include \"runtime\/jniHandles.inline.hpp\"\n@@ -65,0 +68,1 @@\n+#include \"services\/heapDumper.hpp\"\n@@ -69,0 +73,1 @@\n+#include \"services\/writeableFlags.hpp\"\n@@ -78,0 +83,4 @@\n+#ifdef _WINDOWS\n+#include <process.h>\n+#endif \/\/LINUX\n+\n@@ -94,0 +103,5 @@\n+\/\/ CRaC\n+static const char* _crengine = NULL;\n+static jlong _restore_start_time;\n+static jlong _restore_start_counter;\n+\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -532,0 +532,2 @@\n+  static int exec_child_process_and_wait(const char *path, const char *argv[]);\n+\n@@ -582,0 +584,3 @@\n+  static int mkdir(const char *pathname);\n+  static int rmdir(const char *pathname);\n+\n@@ -588,0 +593,2 @@\n+  static bool is_path_absolute(const char *path);\n+\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+#ifdef LINUX\n@@ -59,0 +60,1 @@\n+#endif \/\/LINUX\n@@ -1048,1 +1050,0 @@\n-  LinuxAttachOperation* current_op;\n@@ -1056,2 +1057,2 @@\n-      current_op = LinuxAttachListener::get_current_op();\n-      outputStream* stream = current_op->is_effectively_completed() ? tty : output();\n+      outputStream* stream = output();\n+      LINUX_ONLY(if (LinuxAttachListener::get_current_op() && LinuxAttachListener::get_current_op()->is_effectively_completed()) { stream = tty; })\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -146,5 +146,5 @@\n-        final int retCode = (Integer)bundle[0];\n-        final String newArguments = (String)bundle[1];\n-        final String[] newProperties = (String[])bundle[2];\n-        final int[] codes = (int[])bundle[3];\n-        final String[] messages = (String[])bundle[4];\n+        final int retCode = (null == bundle) ? JVM_CHECKPOINT_NONE : (Integer)bundle[0];\n+        final String newArguments = (null == bundle) ? null : (String)bundle[1];\n+        final String[] newProperties = (null == bundle) ? null : (String[])bundle[2];\n+        final int[] codes = (null == bundle) ? null : (int[])bundle[3];\n+        final String[] messages = (null == bundle) ? null : (String[])bundle[4];\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/Core.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -104,0 +104,1 @@\n+#ifndef _WIN32\n@@ -172,1 +173,2 @@\n-    for (int sig = 1; sig < __SIGRTMIN; ++sig) {\n+    const int MaxSignalValue = 31;\n+    for (int sig = 1; sig <= MaxSignalValue; ++sig) {\n@@ -187,0 +189,1 @@\n+#endif \/\/ _WIN32\n","filename":"src\/java.base\/share\/native\/launcher\/main.c","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#ifdef LINUX\n@@ -41,0 +42,1 @@\n+#endif \/\/LINUX\n","filename":"src\/java.base\/unix\/native\/pauseengine\/pauseengine.c","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#ifdef LINUX\n@@ -41,0 +42,1 @@\n+#endif \/\/LINUX\n","filename":"src\/java.base\/unix\/native\/simengine\/simengine.c","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <string.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+\/\/ #include <unistd.h>\n+#include <signal.h>\n+#include <windows.h>\n+\n+typedef int pid_t;\n+\n+static int kickjvm(pid_t jvm, int code) {\n+    return 0;\n+}\n+\n+int main(int argc, char *argv[]) {\n+    char* action = argv[1];\n+    char* imagedir = argv[2];\n+\n+    char pidpath[MAX_PATH];\n+    if (-1 == sprintf(pidpath, \"%s\/pid\", imagedir)) {\n+        return 1;\n+    }\n+\n+    if (!strcmp(action, \"checkpoint\")) {\n+        pid_t jvm = -1; \/\/getppid();\n+\n+        FILE *pidfile = fopen(pidpath, \"w\");\n+        if (!pidfile) {\n+            perror(\"fopen pidfile\");\n+            kickjvm(jvm, -1);\n+            return 1;\n+        }\n+\n+        fprintf(pidfile, \"%d\\n\", jvm);\n+        fclose(pidfile);\n+\n+    } else if (!strcmp(action, \"restore\")) {\n+        FILE *pidfile = fopen(pidpath, \"r\");\n+        if (!pidfile) {\n+            perror(\"fopen pidfile\");\n+            return 1;\n+        }\n+\n+        pid_t jvm;\n+        if (1 != fscanf(pidfile, \"%d\", &jvm)) {\n+            fclose(pidfile);\n+            fprintf(stderr, \"cannot read pid\\n\");\n+            return 1;\n+        }\n+        fclose(pidfile);\n+\n+        char *strid = getenv(\"CRAC_NEW_ARGS_ID\");\n+        if (kickjvm(jvm, strid ? atoi(strid) : 0)) {\n+            return 1;\n+        }\n+\n+    } else {\n+        fprintf(stderr, \"unknown action: %s\\n\", action);\n+        return 1;\n+    }\n+\n+    return 0;\n+}\n","filename":"src\/java.base\/windows\/native\/pauseengine\/pauseengine.c","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <string.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+\n+static int kickjvm(int jvm, int code) {\n+    return 0;\n+}\n+\n+int main(int argc, char *argv[]) {\n+    char* action = argv[1];\n+\n+    if (!strcmp(action, \"checkpoint\")) {\n+        const char* argsidstr = getenv(\"SIM_CRAC_NEW_ARGS_ID\");\n+        int argsid = argsidstr ? atoi(argsidstr) : 0;\n+        int jvm = -1;\/\/getppid();\n+        kickjvm(jvm, argsid);\n+    } else if (!strcmp(action, \"restore\")) {\n+        char *strid = getenv(\"CRAC_NEW_ARGS_ID\");\n+        printf(\"SIM_CRAC_NEW_ARGS_ID=%s\\n\", strid ? strid : \"0\");\n+    } else {\n+        fprintf(stderr, \"unknown action: %s\\n\", action);\n+        return 1;\n+    }\n+\n+    return 0;\n+}\n","filename":"src\/java.base\/windows\/native\/simengine\/simengine.c","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -36,0 +36,1 @@\n+ * @requires (os.family == \"linux\")\n","filename":"test\/jdk\/jdk\/crac\/LeaveRunning.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+ * @requires (os.family == \"linux\")\n","filename":"test\/jdk\/jdk\/crac\/RestoreEnvironmentTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @requires (os.family == \"linux\")\n","filename":"test\/jdk\/jdk\/crac\/SecureRandom\/InterlockTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+ * @requires (os.family == \"linux\")\n","filename":"test\/jdk\/jdk\/crac\/SecureRandom\/ReseedTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @requires (os.family == \"linux\")\n","filename":"test\/jdk\/jdk\/crac\/Selector\/Test970\/Test.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ * @requires (os.family == \"linux\")\n","filename":"test\/jdk\/jdk\/crac\/Selector\/interruptedSelection\/Test.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ * @requires (os.family == \"linux\")\n","filename":"test\/jdk\/jdk\/crac\/Selector\/keyAfterRestore\/Test.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+ * @requires (os.family == \"linux\")\n","filename":"test\/jdk\/jdk\/crac\/Selector\/multipleSelect\/Test.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+ * @requires (os.family == \"linux\")\n","filename":"test\/jdk\/jdk\/crac\/Selector\/multipleSelectNow\/Test.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+ * @requires (os.family == \"linux\")\n","filename":"test\/jdk\/jdk\/crac\/Selector\/multipleSelectSingleClose\/Test.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+ * @requires (os.family == \"linux\")\n","filename":"test\/jdk\/jdk\/crac\/Selector\/selectAfterWakeup\/Test.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @requires (os.family == \"linux\")\n","filename":"test\/jdk\/jdk\/crac\/Selector\/selectAndWakeupAfterRestore\/Test.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ * @requires (os.family == \"linux\")\n","filename":"test\/jdk\/jdk\/crac\/Selector\/wakeupAfterRestore\/Test.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ * @requires (os.family == \"linux\")\n","filename":"test\/jdk\/jdk\/crac\/Selector\/wakeupByClose\/Test.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ * @requires (os.family == \"linux\")\n","filename":"test\/jdk\/jdk\/crac\/Selector\/wakeupByTimeoutAfterRestore\/Test.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+ * @requires (os.family == \"linux\")\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/CheckpointWithOpenFdsTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+ * @requires (os.family == \"linux\")\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/IgnoredFileDescriptorsTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+ * @requires (os.family == \"linux\")\n","filename":"test\/jdk\/jdk\/crac\/java\/net\/InetAddress\/ResolveTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -11,0 +11,1 @@\n+import java.nio.file.Files;\n","filename":"test\/lib\/jdk\/test\/lib\/crac\/CracBuilder.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -9,0 +9,1 @@\n+import java.util.concurrent.TimeUnit;\n@@ -46,0 +47,4 @@\n+\n+        \/\/ (at least on Windows) we need to wait to avoid os::prepare_checkpoint() interference with mkdir\/rmdir calls\n+        Thread.sleep(500);\n+\n@@ -63,0 +68,1 @@\n+            int timeoutCounter = 10;\n@@ -64,1 +70,10 @@\n-                WatchKey key2 = watcher.take();\n+                WatchKey key2 = watcher.poll(1, TimeUnit.SECONDS);\n+                if (null == key2) {\n+                    if (!process.isAlive() && 0 < --timeoutCounter) {\n+                        \/\/ At least on macOS, it seems like WatchService's event may be delayed up to 10 secs,\n+                        \/\/ so we need to keep waiting some time for the event, even the process is completed.\n+                        continue;\n+                    }\n+                    assertTrue(process.isAlive(), \"Process should exist\");\n+                    continue;\n+                }\n","filename":"test\/lib\/jdk\/test\/lib\/crac\/CracProcess.java","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"}]}