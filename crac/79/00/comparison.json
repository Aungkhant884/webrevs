{"files":[{"patch":"@@ -6080,1 +6080,2 @@\n-    print_resources(\"JVM: FD fd=%d type=%s path=\\\"%s\\\"\", fd, type, details);\n+\n+    print_resources(\"JVM: FD fd=%d type=%s details=\\\"%s\\\" \", fd, type, details);\n@@ -6105,1 +6106,1 @@\n-    int len = snprintf(msg, buflen, \"FD fd=%d type=%s path=%s\", i, type, detailsbuf);\n+    int len = snprintf(msg, buflen, \"FD fd=%d type=%s details=%s\", fd, type, detailsbuf);\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.net.Socket;\n@@ -32,1 +31,1 @@\n-import jdk.crac.impl.CheckpointOpenFileException;\n+import jdk.crac.impl.CheckpointOpenResourceException;\n@@ -36,2 +35,2 @@\n-import jdk.internal.crac.JDKContext;\n-import jdk.internal.crac.JDKResource;\n+import jdk.internal.crac.ClaimedFDs;\n+import jdk.internal.crac.JDKFdResource;\n@@ -62,1 +61,1 @@\n-    class Resource implements jdk.internal.crac.JDKResource {\n+    class Resource extends JDKFdResource {\n@@ -64,14 +63,0 @@\n-        final Exception stackTraceHolder;\n-\n-        Resource() {\n-            if (JDKContext.Properties.COLLECT_FD_STACKTRACES) {\n-                \/\/ About the timestamp: we cannot format it nicely since this\n-                \/\/ exception is sometimes created too early in the VM lifecycle\n-                \/\/ (but it's hard to detect when it would be safe to do).\n-                stackTraceHolder = new Exception(\"This file descriptor was created by \"\n-                        + Thread.currentThread().getName() + \" at epoch:\" + System.currentTimeMillis() + \" here\");\n-            } else {\n-                stackTraceHolder = null;\n-            }\n-            Core.Priority.FILE_DESCRIPTORS.getContext().register(this);\n-        }\n@@ -81,4 +66,3 @@\n-            if (!closedByNIO) {\n-                FileDescriptor.this.beforeCheckpoint();\n-            }\n-        }\n+            if (!closedByNIO && valid()) {\n+                ClaimedFDs ctx = Core.getClaimedFDs();\n+                FileDescriptor self = FileDescriptor.this;\n@@ -86,3 +70,9 @@\n-        @Override\n-        public void afterRestore(Context<? extends jdk.crac.Resource> context) throws Exception {\n-            FileDescriptor.this.afterRestore();\n+                ctx.claimFd(self, self, () ->  {\n+                    if (self == in || self == out || self == err) {\n+                        return null;\n+                    }\n+                    return new CheckpointOpenResourceException(\n+                        FileDescriptor.class.getSimpleName() + \" \" + fd + \": \" + nativeDescription0(),\n+                        getStackTraceHolder());\n+                });\n+            }\n@@ -106,16 +96,0 @@\n-\n-        JDKResource resource = new JDKResource() {\n-            @Override\n-            public void beforeCheckpoint(Context<? extends jdk.crac.Resource> context) {\n-                JDKContext ctx = Core.getJDKContext();\n-                ctx.claimFd(in, \"System.in\");\n-                ctx.claimFd(out, \"System.out\");\n-                ctx.claimFd(err, \"System.err\");\n-            }\n-\n-            @Override\n-            public void afterRestore(Context<? extends jdk.crac.Resource> context) {\n-            }\n-        };\n-        checkpointListener = resource;\n-        Core.Priority.NORMAL.getContext().register(resource);\n@@ -242,3 +216,0 @@\n-    private static final JDKResource checkpointListener;\n-\n-\n@@ -365,27 +336,1 @@\n-    private synchronized void beforeCheckpoint() throws CheckpointOpenFileException {\n-        if (valid()) {\n-            JDKContext ctx = jdk.internal.crac.Core.getJDKContext();\n-            if (ctx.claimFdWeak(this, this)) {\n-                String path = getPath();\n-                String type = getType();\n-                String info;\n-                if (\"socket\".equals(type)) {\n-                    info = Socket.getDescription(this);\n-                } else {\n-                    info = (path != null ? path : \"unknown path\") + \" (\" + (type != null ? type : \"unknown\") + \")\";\n-                }\n-                String msg = \"FileDescriptor \" + this.fd + \" left open: \" + info + \" \";\n-                if (!JDKContext.Properties.COLLECT_FD_STACKTRACES) {\n-                    msg += JDKContext.COLLECT_FD_STACKTRACES_HINT;\n-                }\n-                throw new CheckpointOpenFileException(msg, resource.stackTraceHolder);\n-            }\n-        }\n-    }\n-\n-    private native String getPath();\n-\n-    private native String getType();\n-\n-    private synchronized void afterRestore() {\n-    }\n+    private native String nativeDescription0();\n","filename":"src\/java.base\/share\/classes\/java\/io\/FileDescriptor.java","additions":17,"deletions":72,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import jdk.internal.crac.JDKFileResource;\n@@ -458,0 +459,12 @@\n+\n+    JDKFileResource resource = new JDKFileResource() {\n+        @Override\n+        protected FileDescriptor getFD() {\n+            return fd;\n+        }\n+\n+        @Override\n+        protected String getPath() {\n+            return path;\n+        }\n+    };\n","filename":"src\/java.base\/share\/classes\/java\/io\/FileOutputStream.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -30,3 +30,0 @@\n-import jdk.crac.Context;\n-import jdk.crac.impl.CheckpointOpenFileException;\n-import jdk.internal.access.JavaIOFileDescriptorAccess;\n@@ -35,3 +32,1 @@\n-import jdk.internal.crac.Core;\n-import jdk.internal.crac.JDKContext;\n-import jdk.internal.crac.JDKResource;\n+import jdk.internal.crac.JDKFileResource;\n@@ -89,7 +84,1 @@\n-    private class Resource implements JDKResource {\n-        private static final JavaIOFileDescriptorAccess fdAccess = SharedSecrets.getJavaIOFileDescriptorAccess();\n-\n-        Resource() {\n-            Core.Priority.PRE_FILE_DESRIPTORS.getContext().register(this);\n-        }\n-\n+    JDKFileResource resource = new JDKFileResource() {\n@@ -97,13 +86,2 @@\n-        public void beforeCheckpoint(Context<? extends jdk.crac.Resource> context) throws Exception {\n-            if (Core.getJDKContext().claimFdWeak(fd, this)) {\n-                if (Core.getJDKContext().matchClasspath(path)) {\n-                    \/\/ Files on the classpath are considered persistent, exception is not thrown\n-                    return;\n-                }\n-                int fdNum = fdAccess.get(fd);\n-                String msg = \"RandomAccessFile \" + path + \" left open (file descriptor \" + fdNum + \"). \";\n-                if (!JDKContext.Properties.COLLECT_FD_STACKTRACES) {\n-                    msg += JDKContext.COLLECT_FD_STACKTRACES_HINT;\n-                }\n-                throw new CheckpointOpenFileException(msg, fd.resource.stackTraceHolder);\n-            }\n+        protected FileDescriptor getFD() {\n+            return fd;\n@@ -113,2 +91,2 @@\n-        public void afterRestore(Context<? extends jdk.crac.Resource> context) throws Exception {\n-\n+        protected String getPath() {\n+            return path;\n@@ -116,4 +94,1 @@\n-\n-    }\n-\n-    Resource resource = new Resource();\n+    };\n","filename":"src\/java.base\/share\/classes\/java\/io\/RandomAccessFile.java","additions":7,"deletions":32,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -131,1 +131,0 @@\n-        initNative();\n@@ -134,2 +133,0 @@\n-    private static native int initNative();\n-\n@@ -1923,44 +1920,0 @@\n-\n-    \/*\n-     * Returns a pair of [ localAddr, remoteAddr ] used by socket with given descriptor.\n-     * When the socket is not bound given element is <code>null<\/code>. When this does not\n-     * represent an IPv4\/IPv6 socket this method returns <code>null<\/code>.\n-     *\/\n-    private static native InetSocketAddress[] getAddresses(int fd);\n-\n-    \/*\n-     * Returns the type of the socket represented by this file descriptor. The most common\n-     * values are <code>tcp<\/code>, <code>tcp6<\/code>, <code>udp<\/code> or <code>udp6<\/code>.\n-     *\/\n-    private static native String getType(int fd);\n-\n-    \/**\n-     * Returns a textual description of socket using this file descriptor.\n-     *\n-     * @param fileDescriptor Valid file descriptor instance.\n-     * @return String describing the socket.\n-     *\/\n-    public static String getDescription(FileDescriptor fileDescriptor) {\n-        int fd = SharedSecrets.getJavaIOFileDescriptorAccess().get(fileDescriptor);\n-        if (fd < 0) {\n-            throw new IllegalArgumentException();\n-        }\n-\n-        InetSocketAddress[] addresses = Socket.getAddresses(fd);\n-        StringBuilder sb = new StringBuilder(Socket.getType(fd));\n-        if (addresses == null) {\n-            sb.append(\"not IPv4\/IPv6\");\n-        } else {\n-            if (addresses[0] != null) {\n-                sb.append(\" local \").append(addresses[0]);\n-            } else {\n-                sb.append(\" local not bound\");\n-            }\n-            if (addresses[1] != null) {\n-                sb.append(\" remote \").append(addresses[1]);\n-            } else {\n-                sb.append(\" remote not bound\");\n-            }\n-        }\n-        return sb.toString();\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/net\/Socket.java","additions":0,"deletions":47,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -37,0 +37,6 @@\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import jdk.crac.impl.CheckpointOpenSocketException;\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.ClaimedFDs;\n+import jdk.internal.crac.JDKFdResource;\n@@ -107,0 +113,17 @@\n+    private class SocketResource extends JDKFdResource {\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+            ClaimedFDs ctx = Core.getClaimedFDs();\n+            SocketImpl socket = SocketImpl.this;\n+            ctx.claimFd(\n+                fd,\n+                socket,\n+                () -> new CheckpointOpenSocketException(\n+                    socket.toString(),\n+                    getStackTraceHolder()),\n+                fd);\n+        }\n+    };\n+\n+    private final SocketResource socketResource = new SocketResource();\n+\n","filename":"src\/java.base\/share\/classes\/java\/net\/SocketImpl.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -68,1 +68,0 @@\n-import jdk.internal.crac.JDKContext;\n@@ -1804,1 +1803,1 @@\n-                    Core.getJDKContext().claimFd(fd, this);\n+                    Core.getClaimedFDs().claimFd(fd, this, () -> null, fd);\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipFile.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,2 +30,1 @@\n-import jdk.internal.crac.JDKContext;\n-import jdk.internal.crac.JDKResource;\n+import jdk.internal.crac.ClaimedFDs;\n@@ -33,1 +32,0 @@\n-\n@@ -35,1 +33,0 @@\n-import sun.security.action.GetPropertyAction;\n@@ -50,0 +47,1 @@\n+import java.util.function.Supplier;\n@@ -82,1 +80,1 @@\n-                                               CheckpointException exception) {\n+                                               ExceptionHolder<CheckpointException> exception) {\n@@ -87,16 +85,7 @@\n-            switch(codes[i]) {\n-                case JVM_CR_FAIL_FILE:\n-                    exception.addSuppressed(\n-                            new CheckpointOpenFileException(messages[i], null));\n-                    break;\n-                case JVM_CR_FAIL_SOCK:\n-                    exception.addSuppressed(\n-                            new CheckpointOpenSocketException(messages[i]));\n-                    break;\n-                case JVM_CR_FAIL_PIPE:\n-                    \/\/ FALLTHROUGH\n-                default:\n-                    exception.addSuppressed(\n-                            new CheckpointOpenResourceException(messages[i], null));\n-                    break;\n-            }\n+            Exception ex = switch (codes[i]) {\n+                case JVM_CR_FAIL_FILE -> new CheckpointOpenFileException(messages[i], null);\n+                case JVM_CR_FAIL_SOCK -> new CheckpointOpenSocketException(messages[i], null);\n+                case JVM_CR_FAIL_PIPE -> new CheckpointOpenResourceException(messages[i], null);\n+                default -> new CheckpointOpenResourceException(messages[i], null);\n+            };\n+            exception.handle(ex);\n@@ -119,3 +108,7 @@\n-        CheckpointException checkpointException = null;\n-        \/\/ This log is here to initialize call sites in logger formatters.\n-        LoggerContainer.debug(\"Starting checkpoint at epoch:{0}\", System.currentTimeMillis());\n+        final ExceptionHolder<CheckpointException> checkpointException = new ExceptionHolder<>(CheckpointException::new);\n+\n+        \/\/ FIXME: log something to complete logger initialization:\n+        \/\/ - call sites in logger formatters.\n+        \/\/ - FileDescriptors for resources (sun.util.calendar.ZoneInfoFile)\n+        LoggerContainer.info(\"Starting checkpoint\");\n+        LoggerContainer.debug(\"at epoch:{0}\", System.currentTimeMillis());\n@@ -123,0 +116,3 @@\n+        ClaimedFDs claimedFDs = new ClaimedFDs();\n+\n+        jdk.internal.crac.Core.setClaimedFDs(claimedFDs);\n@@ -124,1 +120,0 @@\n-            jdk.internal.crac.Core.getJDKContext().beforeCheckpoint(null);\n@@ -127,4 +122,1 @@\n-            checkpointException = new CheckpointException();\n-            for (Throwable t : ce.getSuppressed()) {\n-                checkpointException.addSuppressed(t);\n-            }\n+            checkpointException.handle(ce);\n@@ -132,0 +124,1 @@\n+        jdk.internal.crac.Core.setClaimedFDs(null);\n@@ -133,2 +126,8 @@\n-        JDKContext jdkContext = jdk.internal.crac.Core.getJDKContext();\n-        List<Map.Entry<Integer, Object>> claimedPairs = jdkContext.getClaimedFds().entrySet().stream().toList();\n+        claimedFDs.getClaimedFds().forEach((integer, exceptionSupplier) -> {\n+            if (exceptionSupplier != null) {\n+                Exception e = exceptionSupplier.second().get();\n+                checkpointException.handle(e);\n+            }\n+        });\n+\n+        List<Map.Entry<Integer, ClaimedFDs.Tuple<Object, Supplier<Exception>>>> claimedPairs = claimedFDs.getClaimedFds().entrySet().stream().toList();\n@@ -136,1 +135,0 @@\n-        Object[] objArr = new Object[claimedPairs.size()];\n@@ -140,2 +138,1 @@\n-            objArr[i] = claimedPairs.get(i).getValue();\n-            LoggerContainer.debug( \"\\t{0} {1}\", fdArr[i], objArr[i]);\n+            LoggerContainer.debug(\"\\t{0} {1}\", fdArr[i], claimedPairs.get(i).getValue().first());\n@@ -144,1 +141,1 @@\n-        final Object[] bundle = checkpointRestore0(fdArr, objArr, checkpointException != null, jcmdStream);\n+        final Object[] bundle = checkpointRestore0(fdArr, null, checkpointException.hasException(), jcmdStream);\n@@ -156,3 +153,0 @@\n-            if (checkpointException == null) {\n-                checkpointException = new CheckpointException();\n-            }\n@@ -160,10 +154,3 @@\n-                case JVM_CHECKPOINT_ERROR:\n-                    translateJVMExceptions(codes, messages, checkpointException);\n-                    break;\n-                case JVM_CHECKPOINT_NONE:\n-                    checkpointException.addSuppressed(\n-                            new RuntimeException(\"C\/R is not configured\"));\n-                    break;\n-                default:\n-                    checkpointException.addSuppressed(\n-                            new RuntimeException(\"Unknown C\/R result: \" + retCode));\n+                case JVM_CHECKPOINT_ERROR -> translateJVMExceptions(codes, messages, checkpointException);\n+                case JVM_CHECKPOINT_NONE -> checkpointException.handle(new RuntimeException(\"C\/R is not configured\"));\n+                default ->                  checkpointException.handle(new RuntimeException(\"Unknown C\/R result: \" + retCode));\n@@ -195,1 +182,1 @@\n-        RestoreException restoreException = null;\n+        ExceptionHolder<RestoreException> restoreException = new ExceptionHolder<>(RestoreException::new);\n@@ -198,1 +185,0 @@\n-            jdk.internal.crac.Core.getJDKContext().afterRestore(null);\n@@ -200,2 +186,2 @@\n-            if (checkpointException == null) {\n-                restoreException = re;\n+            if (checkpointException.hasException()) {\n+                checkpointException.reSuppress(re);\n@@ -203,3 +189,1 @@\n-                for (Throwable t : re.getSuppressed()) {\n-                    checkpointException.addSuppressed(t);\n-                }\n+                restoreException.handle(re);\n@@ -229,1 +213,1 @@\n-                    assert checkpointException == null :\n+                    assert !checkpointException.hasException() :\n@@ -231,4 +215,1 @@\n-                    if (restoreException == null) {\n-                        restoreException = new RestoreException();\n-                    }\n-                    restoreException.addSuppressed(e);\n+                    restoreException.handle(e);\n@@ -239,6 +220,3 @@\n-        assert checkpointException == null || restoreException == null;\n-        if (checkpointException != null) {\n-            throw checkpointException;\n-        } else if (restoreException != null) {\n-            throw restoreException;\n-        }\n+        assert !checkpointException.hasException() || !restoreException.hasException();\n+        checkpointException.throwIfAny();\n+        restoreException.throwIfAny();\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/Core.java","additions":44,"deletions":66,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -33,2 +33,2 @@\n-    public CheckpointOpenSocketException(String details) {\n-        super(details, null);\n+    public CheckpointOpenSocketException(String details, Throwable cause) {\n+        super(details, cause);\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/impl\/CheckpointOpenSocketException.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,0 +26,11 @@\n+    public boolean hasException() {\n+        return exception != null;\n+    }\n+\n+    public void reSuppress(Exception e) {\n+        E exception = get();\n+        for (Throwable t : e.getSuppressed()) {\n+            exception.addSuppressed(t);\n+        }\n+    }\n+\n@@ -36,3 +47,1 @@\n-            for (Throwable t : e.getSuppressed()) {\n-                exception.addSuppressed(t);\n-            }\n+            reSuppress(e);\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/impl\/ExceptionHolder.java","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.crac;\n+\n+import jdk.internal.access.JavaIOFileDescriptorAccess;\n+import jdk.internal.access.SharedSecrets;\n+\n+import java.io.FileDescriptor;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.WeakHashMap;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+public class ClaimedFDs {\n+    private final WeakHashMap<FileDescriptor, Tuple<Object, Supplier<Exception>>> fds = new WeakHashMap<>();\n+\n+    public Map<Integer, Tuple<Object, Supplier<Exception>>> getClaimedFds() {\n+        JavaIOFileDescriptorAccess fileDescriptorAccess = SharedSecrets.getJavaIOFileDescriptorAccess();\n+        return fds.entrySet().stream()\n+            .filter((var e) -> e.getKey().valid())\n+            .collect(Collectors.toMap(entry -> fileDescriptorAccess.get(entry.getKey()), Map.Entry::getValue));\n+    }\n+\n+    public static class Tuple<T1, T2> {\n+        private final T1 o1;\n+        private final T2 o2;\n+\n+        public Tuple(T1 o1, T2 o2) {\n+            this.o1 = o1;\n+            this.o2 = o2;\n+        }\n+        public T1 first() { return o1; }\n+        public T2 second() { return o2; }\n+    }\n+\n+    public void claimFd(FileDescriptor fd, Object claimer, Supplier<Exception> supplier, Object... suppressedClaimers) {\n+        Objects.requireNonNull(supplier);\n+\n+        if (fd == null) {\n+            return;\n+        }\n+\n+        Tuple<Object, Supplier<Exception>> record = fds.get(fd);\n+        LoggerContainer.debug(\"ClaimFD: fd {0} claimer {1} existing {2}\",\n+            fd, claimer, record != null ? record.first() : \"NONE\");\n+        if (record == null ||\n+                Stream.of(suppressedClaimers).anyMatch((supressed) -> supressed == record.first())) {\n+            fds.put(fd, new Tuple<>(claimer, supplier));\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/ClaimedFDs.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -33,1 +33,1 @@\n-    private static JDKContext jdkContext = new JDKContext();\n+    private static ClaimedFDs claimedFDs;\n@@ -35,2 +35,6 @@\n-    public static JDKContext getJDKContext() {\n-        return jdkContext;\n+    \/**\n+     * Called by JDK FD resources\n+     * @return\n+     *\/\n+    public static ClaimedFDs getClaimedFDs() {\n+        return claimedFDs;\n@@ -39,0 +43,6 @@\n+    \/**\n+     * Called by jdk.crac.Core to publish current ClaimedFDs\n+     *\/\n+    public static void setClaimedFDs(ClaimedFDs fds) {\n+        claimedFDs = fds;\n+    }\n@@ -51,1 +61,0 @@\n-        PRE_FILE_DESRIPTORS(new BlockingOrderedContext<>()),\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/Core.java","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,43 @@\n+package jdk.internal.crac;\n+\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import sun.security.action.GetBooleanAction;\n+\n+public abstract class JDKFdResource implements JDKResource {\n+    private static final String COLLECT_FD_STACKTRACES_PROPERTY = \"jdk.crac.collect-fd-stacktraces\";\n+    private static final String COLLECT_FD_STACKTRACES_HINT =\n+        \"Use -D\" + COLLECT_FD_STACKTRACES_PROPERTY + \"=true to find the source.\";\n+\n+    private static final boolean COLLECT_FD_STACKTRACES =\n+        GetBooleanAction.privilegedGetProperty(COLLECT_FD_STACKTRACES_PROPERTY);\n+\n+    final Exception stackTraceHolder;\n+\n+    static volatile boolean hintPrinted = false;\n+\n+    public JDKFdResource() {\n+        stackTraceHolder = COLLECT_FD_STACKTRACES ?\n+            \/\/ About the timestamp: we cannot format it nicely since this\n+            \/\/ exception is sometimes created too early in the VM lifecycle\n+            \/\/ (but it's hard to detect when it would be safe to do).\n+            new Exception(\"This file descriptor was created by \" + Thread.currentThread().getName()\n+                + \" at epoch:\" + System.currentTimeMillis() + \" here\") :\n+            null;\n+\n+        Core.Priority.FILE_DESCRIPTORS.getContext().register(this);\n+    }\n+\n+    protected Exception getStackTraceHolder() {\n+        if (!hintPrinted && stackTraceHolder == null) {\n+            hintPrinted = true;\n+            LoggerContainer.info(COLLECT_FD_STACKTRACES_HINT);\n+        }\n+        return stackTraceHolder;\n+    }\n+\n+    @Override\n+    public void afterRestore(Context<? extends Resource> context) throws Exception {\n+\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/JDKFdResource.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+package jdk.internal.crac;\n+\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import jdk.crac.impl.CheckpointOpenFileException;\n+import sun.security.action.GetPropertyAction;\n+\n+import java.io.File;\n+import java.io.FileDescriptor;\n+\n+public abstract class JDKFileResource extends JDKFdResource {\n+    private static final String[] CLASSPATH_ENTRIES =\n+        GetPropertyAction.privilegedGetProperty(\"java.class.path\")\n+            .split(File.pathSeparator);\n+\n+    protected abstract FileDescriptor getFD();\n+    protected abstract String getPath();\n+\n+    private boolean matchClasspath(String path) {\n+        for (String cp : CLASSPATH_ENTRIES) {\n+            if (cp.equals(path)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+        String path = getPath();\n+        if (path == null) {\n+            \/\/ let FileDescriptor claim everything\n+            return;\n+        }\n+\n+        if (matchClasspath(path)) {\n+            \/\/ Files on the classpath are considered persistent, exception is not thrown\n+            return;\n+        }\n+\n+        FileDescriptor fd = getFD();\n+        Core.getClaimedFDs().claimFd(fd, this, () -> new CheckpointOpenFileException(path, getStackTraceHolder()), fd);\n+    }\n+\n+    @Override\n+    public void afterRestore(Context<? extends Resource> context) throws Exception {\n+\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/JDKFileResource.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -29,2 +29,0 @@\n-import jdk.internal.crac.Core;\n-import jdk.internal.crac.LoggerContainer;\n@@ -33,0 +31,2 @@\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.LoggerContainer;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/jar\/PersistentJarFile.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -53,0 +54,6 @@\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import jdk.crac.impl.CheckpointOpenSocketException;\n+import jdk.internal.crac.ClaimedFDs;\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKFdResource;\n@@ -1199,1 +1206,1 @@\n-    private static Runnable closerFor(FileDescriptor fd, boolean stream) {\n+    private static Runnable closerFor0(FileDescriptor fd, boolean stream) {\n@@ -1222,0 +1229,14 @@\n+    private static Runnable closerFor(FileDescriptor fd, boolean stream) {\n+\n+        \/\/ FIXME ensure FileDispatcherImpl's Resource is registered before the closer is used,\n+        \/\/ otherwise the closer during beforeCheckpoint may be the first one to access\n+        \/\/ FileDescriptor, and then Dispatcher Resource will be blocked for registration.\n+        try {\n+            MethodHandles.lookup().ensureInitialized(FileDispatcherImpl.class);\n+        } catch (IllegalAccessException e) {\n+            throw new RuntimeException(e);\n+        }\n+\n+        return closerFor0(fd, stream);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/NioSocketImpl.java","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -167,1 +167,2 @@\n-            Core.getJDKContext().claimFd(((FileInputStream)in).getFD(), this);\n+            FileDescriptor fd = ((FileInputStream)in).getFD();\n+            Core.getClaimedFDs().claimFd(fd, this, () -> null, fd);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/FileInputStreamPool.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -401,1 +401,0 @@\n-\n@@ -601,1 +600,2 @@\n-                    Core.getJDKContext().claimFdWeak(((FileOutputStream)seedOut).getFD(), this);\n+                    FileDescriptor fd = ((FileOutputStream)seedOut).getFD();\n+                    Core.getClaimedFDs().claimFd(fd, this, () -> null, fd);\n","filename":"src\/java.base\/unix\/classes\/sun\/security\/provider\/NativePRNG.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,0 +37,9 @@\n+#include <sys\/socket.h>\n+#include <netinet\/in.h>\n+\n+typedef union {\n+    struct sockaddr     sa;\n+    struct sockaddr_in  sa4;\n+    struct sockaddr_in6 sa6;\n+} socketaddress;\n+\n@@ -79,0 +88,15 @@\n+\/\/ instance method close0 for FileDescriptor\n+JNIEXPORT void JNICALL\n+Java_java_io_FileDescriptor_close0(JNIEnv *env, jobject this) {\n+    fileDescriptorClose(env, this);\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_java_io_FileCleanable_cleanupClose0(JNIEnv *env, jclass fdClass, jint fd, jlong unused) {\n+    if (fd != -1) {\n+        if (close(fd) == -1) {\n+            JNU_ThrowIOExceptionWithLastError(env, \"close failed\");\n+        }\n+    }\n+}\n+\n@@ -93,0 +117,43 @@\n+static const char* family2str(int family) {\n+    switch (family) {\n+        case AF_UNIX: return \"AF_UNIX\";\n+        case AF_INET: return \"AF_INET\";\n+        case AF_INET6: return \"AF_INET6\";\n+        default: break;\n+    }\n+    return \"UNKNOWN\";\n+}\n+\n+static const char* socktype2str(int socktype) {\n+    switch (socktype) {\n+        case SOCK_STREAM: return \"SOCK_STREAM\";\n+        case SOCK_DGRAM: return \"SOCK_DGRAM\";\n+        case SOCK_RAW: return \"SOCK_RAW\";\n+        default: break;\n+    }\n+    return \"SOCK_RAW\";\n+}\n+\n+static char* fmtaddr(char *buf, const char *end, unsigned char* addr, int len) {\n+    while (buf + 2 < end && 0 < len) {\n+        sprintf(buf, \"%02x\", *addr);\n+        buf += 2;\n+        len -= 1;\n+        addr += 1;\n+    }\n+    return buf;\n+}\n+\n+static jstring format_string(JNIEnv *env, struct stat *st, const char *fmt, ...) {\n+    char details[PATH_MAX];\n+    va_list va;\n+\n+    va_start(va, fmt);\n+    int len = vsnprintf(details, sizeof(details), fmt, va);\n+    va_end(va);\n+\n+    \/\/ ensure terminated string\n+    details[sizeof(details) - 1] = '\\0';\n+    return (*env)->NewStringUTF(env, details);\n+}\n+\n@@ -94,2 +161,3 @@\n-Java_java_io_FileDescriptor_getPath(JNIEnv *env, jobject obj) {\n-    int fd = (*env)->GetIntField(env, obj, IO_fd_fdID);\n+Java_java_io_FileDescriptor_nativeDescription0(JNIEnv *env, jobject this) {\n+    FD fd = (*env)->GetIntField(env, this, IO_fd_fdID);\n+\n@@ -99,3 +167,8 @@\n-    int ret = readlink(fdpath, link, PATH_MAX);\n-    if (ret >= 0) {\n-        link[(unsigned)ret < PATH_MAX ? ret : PATH_MAX - 1] = '\\0';\n+    int linklen = readlink(fdpath, link, PATH_MAX);\n+    if (linklen >= 0) {\n+        link[(unsigned)linklen < PATH_MAX ? linklen : PATH_MAX - 1] = '\\0';\n+    }\n+\n+    struct stat st;\n+    if (fstat(fd, &st) != 0) {\n+        \/\/ return just link value\n@@ -104,2 +177,0 @@\n-    return NULL;\n-}\n@@ -107,0 +178,3 @@\n+    if ((st.st_mode & S_IFMT) != S_IFSOCK) {\n+        return format_string(env, &st, \"%s: %s\", stat2strtype(st.st_mode), link);\n+    }\n@@ -108,8 +182,4 @@\n-JNIEXPORT jstring JNICALL\n-Java_java_io_FileDescriptor_getType(JNIEnv *env, jobject obj) {\n-    int fd = (*env)->GetIntField(env, obj, IO_fd_fdID);\n-    struct stat st;\n-    if (fstat(fd, &st) == 0) {\n-        return (*env)->NewStringUTF(env, stat2strtype(st.st_mode));\n-    } else {\n-        return NULL;\n+    int family;\n+    socklen_t famlen = sizeof(int);\n+    if (getsockopt(fd, SOL_SOCKET, SO_DOMAIN, &family, &famlen) != 0) {\n+        return format_string(env, &st, \"socket: %s\", link);\n@@ -117,1 +187,0 @@\n-}\n@@ -119,5 +188,5 @@\n-\/\/ instance method close0 for FileDescriptor\n-JNIEXPORT void JNICALL\n-Java_java_io_FileDescriptor_close0(JNIEnv *env, jobject this) {\n-    fileDescriptorClose(env, this);\n-}\n+    int socktype;\n+    socklen_t typelen = sizeof(int);\n+    if (getsockopt(fd, SOL_SOCKET, SO_TYPE, &socktype, &typelen) != 0) {\n+        return format_string(env, &st, \"socket: family=%s\", family2str(family));\n+    }\n@@ -125,6 +194,4 @@\n-JNIEXPORT void JNICALL\n-Java_java_io_FileCleanable_cleanupClose0(JNIEnv *env, jclass fdClass, jint fd, jlong unused) {\n-    if (fd != -1) {\n-        if (close(fd) == -1) {\n-            JNU_ThrowIOExceptionWithLastError(env, \"close failed\");\n-        }\n+    socketaddress local;\n+    socklen_t llen = sizeof(socketaddress);\n+    if (getsockname(fd, &local.sa, &llen) != 0) {\n+        llen = 0;\n@@ -132,0 +199,16 @@\n+\n+    socketaddress remote;\n+    socklen_t rlen = sizeof(socketaddress);\n+    if (getpeername(fd, &remote.sa, &rlen) != 0) {\n+        rlen = 0;\n+    }\n+\n+    char details[PATH_MAX];\n+    int len = snprintf(details, sizeof(details),\n+            \"socket: family=%s type=%s localaddr=\", family2str(family), socktype2str(socktype));\n+    char *end = fmtaddr(details + len, details + sizeof(details), (unsigned char*)&local, llen);\n+    end += snprintf(end, details + sizeof(details) - end, \" remoteaddr=\");\n+    end = fmtaddr(end, details + sizeof(details), (unsigned char*)&remote, rlen);\n+    \/\/ ensure terminated string\n+    details[sizeof(details) - 1] = '\\0';\n+    return (*env)->NewStringUTF(env, details);\n","filename":"src\/java.base\/unix\/native\/libjava\/FileDescriptor_md.c","additions":110,"deletions":27,"binary":false,"changes":137,"status":"modified"},{"patch":"@@ -61,110 +61,0 @@\n-\n-static jclass isa_class = NULL;\n-static jmethodID isa_ctor = NULL;\n-\n-JNIEXPORT void JNICALL\n-Java_java_net_Socket_initNative(JNIEnv *env, jclass c1)\n-{\n-    jclass isa_class_local = (*env)->FindClass(env, \"java\/net\/InetSocketAddress\");\n-    if (isa_class_local == NULL) {\n-        JNU_ThrowClassNotFoundException(env, \"java.net.InetSocketAddress\");\n-        return;\n-    }\n-    isa_class = (*env)->NewGlobalRef(env, isa_class_local);\n-    isa_ctor = (*env)->GetMethodID(env, isa_class, \"<init>\", \"(Ljava\/net\/InetAddress;I)V\");\n-    if (isa_ctor == NULL) {\n-        JNU_ThrowByName(env, \"java\/lang\/NoSuchMethodError\", \"InetSocketAddress.<init>(java.net.InetAddress, int)\");\n-    }\n-}\n-\n-static jobject create_isa(JNIEnv *env, jclass isa_class, jmethodID isa_ctor, SOCKETADDRESS *addr) {\n-    jint port;\n-    jobject inetAddr = NET_SockaddrToInetAddress(env, addr, &port);\n-    return (*env)->NewObject(env, isa_class, isa_ctor, inetAddr, port);\n-}\n-\n-JNIEXPORT jobjectArray JNICALL\n-Java_java_net_Socket_getAddresses(JNIEnv *env, jclass cl, jint fd) {\n-    int family;\n-    socklen_t famlen = sizeof(int);\n-    if (getsockopt(fd, SOL_SOCKET, SO_DOMAIN, &family, &famlen) != 0) {\n-        JNU_ThrowByName(env, \"java\/net\/SocketException\", \"Cannot find socket family\");\n-        return NULL;\n-    } else if (family != AF_INET && family != AF_INET6) {\n-        return NULL;\n-    }\n-\n-    jobjectArray arr = (*env)->NewObjectArray(env, 2, isa_class, NULL);\n-    if (arr == NULL) {\n-        JNU_ThrowOutOfMemoryError(env, \"java.net.InetSocketAddres[2]\");\n-        return NULL;\n-    }\n-\n-    SOCKETADDRESS local;\n-    socklen_t llen = sizeof(SOCKETADDRESS);\n-    if (getsockname(fd, &local.sa, &llen) != 0) {\n-        JNU_ThrowIllegalArgumentException(env, strerror(errno));\n-        return NULL;\n-    }\n-    jobject localAddr = create_isa(env, isa_class, isa_ctor, &local);\n-    if (localAddr == NULL) {\n-        JNU_ThrowOutOfMemoryError(env, \"java.net.InetSocketAddres\");\n-        return NULL;\n-    }\n-\n-    jobject remoteAddr;\n-    SOCKETADDRESS remote;\n-    socklen_t rlen = sizeof(SOCKETADDRESS);\n-    if (getpeername(fd, &remote.sa, &rlen) != 0) {\n-        if (errno == ENOTCONN) {\n-            remoteAddr = NULL;\n-        } else {\n-            JNU_ThrowIllegalArgumentException(env, strerror(errno));\n-            return NULL;\n-        }\n-    } else {\n-        remoteAddr = create_isa(env, isa_class, isa_ctor, &remote);\n-        if (remoteAddr == NULL) {\n-           JNU_ThrowOutOfMemoryError(env, \"java.net.InetSocketAddres\");\n-           return NULL;\n-        }\n-    }\n-\n-    (*env)->SetObjectArrayElement(env, arr, 0, localAddr);\n-    (*env)->SetObjectArrayElement(env, arr, 1, remoteAddr);\n-    return arr;\n-}\n-\n-JNIEXPORT jstring JNICALL\n-Java_java_net_Socket_getType(JNIEnv *env, jclass cl, jint fd) {\n-    int socktype, family;\n-    socklen_t typelen = sizeof(int), famlen = sizeof(int);\n-    const char *type;\n-    if (getsockopt(fd, SOL_SOCKET, SO_DOMAIN, &family, &famlen) != 0) {\n-        JNU_ThrowByName(env, \"java\/net\/SocketException\", \"Cannot find socket family\");\n-        return NULL;\n-    } else if (family == AF_UNIX) {\n-        type = \"unix socket\";\n-    } else if (family != AF_INET && family != AF_INET6) {\n-        type = \"unknown socket family\";\n-    } else {\n-        if (getsockopt(fd, SOL_SOCKET, SO_TYPE, &socktype, &typelen) != 0) {\n-            JNU_ThrowByName(env, \"java\/net\/SocketException\", \"Cannot find socket type\");\n-            return NULL;\n-        }\n-        switch(socktype) {\n-            case SOCK_STREAM:\n-                type = family == AF_INET ? \"tcp\" : \"tcp6\";\n-                break;\n-            case SOCK_DGRAM:\n-                type = family == AF_INET ? \"udp\" : \"udp6\";\n-                break;\n-            case SOCK_RAW:\n-                type = family == AF_INET ? \"raw\" : \"raw6\";\n-                break;\n-            default:\n-                type = family == AF_INET ? \"unknown IPv4\" : \"unknown IPv6\";\n-        }\n-    }\n-    return (*env)->NewStringUTF(env, type);\n-}\n\\ No newline at end of file\n","filename":"src\/java.base\/unix\/native\/libnet\/SocketImpl.c","additions":0,"deletions":110,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import java.io.FileReader;\n+import java.io.RandomAccessFile;\n@@ -45,1 +45,1 @@\n-                .shouldContain(\"\/etc\/passwd\")\n+                .shouldMatch(\"CheckpointOpenFileException: \/etc\/passwd\")\n@@ -51,1 +51,1 @@\n-        try (var reader = new FileReader(\"\/etc\/passwd\")) {\n+        try (var file = new RandomAccessFile(\"\/etc\/passwd\", \"r\")) {\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/OpenFileDetectionTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-                .shouldMatch(\"left open: tcp6? local [\/0-9a-f:.]+:[0-9]+ remote [\/0-9a-f:.]+:[0-9]+\");\n+                .shouldMatch(\"CheckpointOpenSocketException: [A-Za-z0-9.$]+\\\\[addr=[A-Za-z0-9\/:.]+,port=[0-9]+,localport=[0-9]+\\\\]\");\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/OpenSocketDetectionTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}