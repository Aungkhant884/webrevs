{"files":[{"patch":"@@ -1401,0 +1401,1 @@\n+  \/\/ We are running still before crac_restore_finalize() so we cannot use string functions.\n@@ -1402,1 +1403,2 @@\n-    tty->print_cr(\"CPU features are being kept intact as requested by -XX:CPUFeatures=ignore\");\n+    static const char msg[] = \"CPU features are being kept intact as requested by -XX:CPUFeatures=ignore\";\n+    tty->print_raw(msg, sizeof(msg) - 1);\n@@ -1404,1 +1406,3 @@\n-    tty->print_cr(\"CPU features being used are: -XX:CPUFeatures=\" UINT64_FORMAT_X \",\" UINT64_FORMAT_X, _features, _glibc_features);\n+    static const char prefix[] = \"CPU features being used are: -XX:CPUFeatures=\";\n+    tty->print_raw(prefix, sizeof(prefix) - 1);\n+    nonlibc_tty_print_uint64_comma_uint64(_features, _glibc_features);\n@@ -1406,0 +1410,1 @@\n+  tty->cr();\n@@ -2771,0 +2776,1 @@\n+\/\/ This function may be called twice.\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -32,0 +32,2 @@\n+const char CracSHM::_prefix[] = \"\/tmp\/cracshm.\";\n+\n@@ -33,1 +35,2 @@\n-  int shmfd = shm_open(_path, mode, 0600);\n+  \/\/ shm_open() is using glibc string functions, therefore it cannot be used before calling crac_restore_finalize().\n+  int shmfd = ::open(_path, mode, 0600);\n@@ -41,1 +44,1 @@\n-  shm_unlink(_path);\n+  ::unlink(_path);\n@@ -69,1 +72,1 @@\n-#endif\n\\ No newline at end of file\n+#endif\n","filename":"src\/hotspot\/os\/posix\/crac_posix.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -46,0 +46,2 @@\n+const char CracSHM::_prefix[] = \"\";\n+\n","filename":"src\/hotspot\/os\/windows\/crac_windows.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -354,0 +354,2 @@\n+    VM_Version::crac_restore_finalize();\n+\n@@ -357,0 +359,1 @@\n+    \/\/ VM_Version::crac_restore_finalize() has been already called by VM_Crac::read_shm().\n@@ -364,3 +367,0 @@\n-  \/\/ VM_Crac::read_shm needs to be already called to read RESTORE_SETTABLE parameters.\n-  VM_Version::crac_restore_finalize();\n-\n@@ -518,0 +518,12 @@\n+  \/\/ crac_restore_finalize() may terminate the process if we run on (older) CPU where glibc string functions may crash.\n+  \/\/ The header is read first as all the code of this function below is difficult to implement without the string functions.\n+  header hdr;\n+  \/\/ FIXME: Fix incomplete reads.\n+  if (read(fd, &hdr, sizeof(hdr)) != sizeof(hdr)) {\n+    perror(\"read (ignoring restore parameters)\");\n+    return false;\n+  }\n+  if (hdr._ignore_cpu_features)\n+    IgnoreCPUFeatures = hdr._ignore_cpu_features == '+';\n+  VM_Version::crac_restore_finalize();\n+\n@@ -519,1 +531,1 @@\n-  if (fstat(fd, &st)) {\n+  if (fstat(fd, &st) || st.st_size < (ssize_t)sizeof(hdr)) {\n@@ -524,2 +536,3 @@\n-  char *contents = NEW_C_HEAP_ARRAY(char, st.st_size, mtInternal);\n-  if (read(fd, contents, st.st_size) < 0) {\n+  size_t contents_size = st.st_size - sizeof(hdr);\n+  char *contents = NEW_C_HEAP_ARRAY(char, contents_size, mtInternal);\n+  if (read(fd, contents, contents_size) < 0) {\n@@ -534,2 +547,1 @@\n-  header* hdr = (header*)_raw_content;\n-  char* cursor = _raw_content + sizeof(header);\n+  char* cursor = contents;\n@@ -537,2 +549,2 @@\n-  ::_restore_start_time = hdr->_restore_time;\n-  ::_restore_start_nanos = hdr->_restore_nanos;\n+  ::_restore_start_time = hdr._restore_time;\n+  ::_restore_start_nanos = hdr._restore_nanos;\n@@ -540,1 +552,1 @@\n-  for (int i = 0; i < hdr->_nflags; i++) {\n+  for (int i = 0; i < hdr._nflags; i++) {\n@@ -565,2 +577,2 @@\n-  for (int i = 0; i < hdr->_nprops; i++) {\n-    assert((cursor + strlen(cursor) <= contents + st.st_size), \"property length exceeds shared memory size\");\n+  for (int i = 0; i < hdr._nprops; i++) {\n+    assert((cursor + strlen(cursor) <= contents + contents_size), \"property length exceeds shared memory size\");\n@@ -572,2 +584,2 @@\n-  char* env_mem = NEW_C_HEAP_ARRAY(char, hdr->_env_memory_size, mtArguments); \/\/ left this pointer unowned, it is freed when process dies\n-  memcpy(env_mem, cursor, hdr->_env_memory_size);\n+  char* env_mem = NEW_C_HEAP_ARRAY(char, hdr._env_memory_size, mtArguments); \/\/ left this pointer unowned, it is freed when process dies\n+  memcpy(env_mem, cursor, hdr._env_memory_size);\n@@ -575,1 +587,1 @@\n-  const char* env_end = env_mem + hdr->_env_memory_size;\n+  const char* env_end = env_mem + hdr._env_memory_size;\n@@ -582,1 +594,1 @@\n-  cursor += hdr->_env_memory_size;\n+  cursor += hdr._env_memory_size;\n","filename":"src\/hotspot\/share\/runtime\/crac.cpp","additions":29,"deletions":17,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+    char _ignore_cpu_features; \/\/ IgnoreCPUFeatures: 0 to keep the checkpointed value, '+' for true, '-' for false\n@@ -123,1 +124,2 @@\n-      env_vars_size(os::get_environ())\n+      env_vars_size(os::get_environ()),\n+      0 \/\/ _ignore_cpu_features\n@@ -126,0 +128,6 @@\n+    for (int i = 0; i < num_flags; ++i) {\n+      if ((flags[i][0] == '+' || flags[i][0] == '-') && strcmp(flags[i] + 1, \"IgnoreCPUFeatures\") == 0) {\n+        hdr._ignore_cpu_features = flags[i][0];\n+      }\n+    }\n+\n@@ -211,0 +219,7 @@\n+  static void write_dec(char *&d, int id) {\n+    if (!id)\n+      return;\n+    write_dec(d, id \/ 10);\n+    *d++ = '0' + id % 10;\n+  }\n+  static const char _prefix[];\n@@ -213,3 +228,5 @@\n-    int shmpathlen = snprintf(_path, sizeof(_path), \"\/crac_%d\", id);\n-    if (shmpathlen < 0 || sizeof(_path) <= (size_t)shmpathlen) {\n-      fprintf(stderr, \"shmpath is too long: %d\\n\", shmpathlen);\n+    assert(id > 0, \"id is expected to be a PID and therefore > 0\");\n+    char *d = _path;\n+    const char *cs = _prefix;\n+    while (*cs) {\n+      *d++ = *cs++;\n@@ -217,0 +234,2 @@\n+    write_dec(d, id);\n+    *d = 0;\n","filename":"src\/hotspot\/share\/runtime\/crac_structs.hpp","additions":23,"deletions":4,"binary":false,"changes":27,"status":"modified"}]}