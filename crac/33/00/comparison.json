{"files":[{"patch":"@@ -31,0 +31,1 @@\n+#include \"attachListener_linux.hpp\"\n@@ -32,0 +33,1 @@\n+#include \"linuxAttachOperation.hpp\"\n@@ -40,3 +42,1 @@\n-#ifndef UNIX_PATH_MAX\n-#define UNIX_PATH_MAX   sizeof(((struct sockaddr_un *)0)->sun_path)\n-#endif\n+\n@@ -60,58 +60,0 @@\n-\/\/ forward reference\n-class LinuxAttachOperation;\n-\n-class LinuxAttachListener: AllStatic {\n- private:\n-  \/\/ the path to which we bind the UNIX domain socket\n-  static char _path[UNIX_PATH_MAX];\n-  static bool _has_path;\n-\n-  \/\/ the file descriptor for the listening socket\n-  static volatile int _listener;\n-\n-  static bool _atexit_registered;\n-\n-  \/\/ reads a request from the given connected socket\n-  static LinuxAttachOperation* read_request(int s);\n-\n- public:\n-  enum {\n-    ATTACH_PROTOCOL_VER = 1                     \/\/ protocol version\n-  };\n-  enum {\n-    ATTACH_ERROR_BADVERSION     = 101           \/\/ error codes\n-  };\n-\n-  static void set_path(char* path) {\n-    if (path == NULL) {\n-      _path[0] = '\\0';\n-      _has_path = false;\n-    } else {\n-      strncpy(_path, path, UNIX_PATH_MAX);\n-      _path[UNIX_PATH_MAX-1] = '\\0';\n-      _has_path = true;\n-    }\n-  }\n-\n-  static void set_listener(int s)               { _listener = s; }\n-\n-  \/\/ initialize the listener, returns 0 if okay\n-  static int init();\n-\n-  static char* path()                   { return _path; }\n-  static bool has_path()                { return _has_path; }\n-  static int listener()                 { return _listener; }\n-\n-  \/\/ write the given buffer to a socket\n-  static int write_fully(int s, char* buf, int len);\n-\n-  static LinuxAttachOperation* dequeue();\n-};\n-\n-class LinuxAttachOperation: public AttachOperation {\n- private:\n-  \/\/ the connection to the client\n-  int _socket;\n-\n- public:\n-  void complete(jint res, bufferedStream* st);\n@@ -119,2 +61,0 @@\n-  void set_socket(int s)                                { _socket = s; }\n-  int socket() const                                    { return _socket; }\n@@ -122,4 +62,0 @@\n-  LinuxAttachOperation(char* name) : AttachOperation(name) {\n-    set_socket(-1);\n-  }\n-};\n@@ -132,0 +68,1 @@\n+LinuxAttachOperation* LinuxAttachListener::_current_op = NULL;\n@@ -380,0 +317,1 @@\n+      _current_op = op;\n@@ -400,0 +338,12 @@\n+\/\/ An operation completion is splitted into two parts.\n+\/\/ For proper handling the jcmd connection at CRaC checkpoint action.\n+\/\/ An effectively_complete_raw is called in checkpoint processing, before criu engine calls, for properly closing the socket.\n+\/\/ The complete() gets called after restore for proper deletion the leftover object.\n+\n+void LinuxAttachOperation::complete(jint result, bufferedStream* st) {\n+  LinuxAttachOperation::effectively_complete_raw(result, st);\n+  \/\/ reset the current op as late as possible, this happens on attach listener thread.\n+  LinuxAttachListener::reset_current_op();\n+  delete this;\n+}\n+\n@@ -408,3 +358,16 @@\n-void LinuxAttachOperation::complete(jint result, bufferedStream* st) {\n-  JavaThread* thread = JavaThread::current();\n-  ThreadBlockInVM tbivm(thread);\n+void LinuxAttachOperation::effectively_complete_raw(jint result, bufferedStream* st) {\n+\n+  if (_effectively_completed) {\n+    assert(st->size() == 0, \"no lost output\");\n+    return;\n+  }\n+\n+  Thread* thread = Thread::current();\n+  if (thread->is_Java_thread()) {\n+    ThreadBlockInVM((JavaThread* )thread);\n+    write_operation_result(result, st);\n+  } else {\n+    write_operation_result(result, st);\n+  }\n+  _effectively_completed = true;\n+}\n@@ -412,1 +375,1 @@\n-  \/\/ write operation result\n+void LinuxAttachOperation::write_operation_result(jint result, bufferedStream* st) {\n@@ -425,0 +388,2 @@\n+  st->reset();\n+}\n@@ -426,1 +391,5 @@\n-  delete this;\n+static void assert_listener_thread() {\n+#ifdef ASSERT\n+  ResourceMark rm; \/\/ For retrieving the thread names\n+  assert(strcmp(\"Attach Listener\", Thread::current()->name()) == 0, \"should gets called from Attach Listener thread\");\n+#endif\n@@ -429,0 +398,9 @@\n+LinuxAttachOperation* LinuxAttachListener::get_current_op() {\n+  assert_listener_thread();\n+  return LinuxAttachListener::_current_op;\n+}\n+\n+void LinuxAttachListener::reset_current_op() {\n+  assert_listener_thread();\n+  LinuxAttachListener::_current_op = NULL;\n+}\n@@ -437,1 +415,0 @@\n-\n","filename":"src\/hotspot\/os\/linux\/attachListener_linux.cpp","additions":50,"deletions":73,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_LINUX_ATTACHLISTENER_LINUX_HPP\n+#define OS_LINUX_ATTACHLISTENER_LINUX_HPP\n+\n+#include \"linuxAttachOperation.hpp\"\n+#include \"services\/attachListener.hpp\"\n+\n+#include <sys\/un.h>\n+\n+#ifndef UNIX_PATH_MAX\n+#define UNIX_PATH_MAX   sizeof(((struct sockaddr_un *)0)->sun_path)\n+#endif\n+\n+class LinuxAttachListener: AllStatic {\n+ private:\n+  \/\/ the path to which we bind the UNIX domain socket\n+  static char _path[UNIX_PATH_MAX];\n+  static bool _has_path;\n+\n+  \/\/ the file descriptor for the listening socket\n+  static volatile int _listener;\n+\n+  static bool _atexit_registered;\n+\n+  \/\/ this is for proper reporting JDK.Chekpoint processing to jcmd peer\n+  static LinuxAttachOperation* _current_op;\n+\n+  \/\/ reads a request from the given connected socket\n+  static LinuxAttachOperation* read_request(int s);\n+\n+ public:\n+\n+  enum {\n+    ATTACH_PROTOCOL_VER = 1                     \/\/ protocol version\n+  };\n+  enum {\n+    ATTACH_ERROR_BADVERSION     = 101           \/\/ error codes\n+  };\n+\n+  static void set_path(char* path) {\n+    if (path == NULL) {\n+      _path[0] = '\\0';\n+      _has_path = false;\n+    } else {\n+      strncpy(_path, path, UNIX_PATH_MAX);\n+      _path[UNIX_PATH_MAX-1] = '\\0';\n+      _has_path = true;\n+    }\n+  }\n+\n+  static void set_listener(int s)               { _listener = s; }\n+\n+  \/\/ initialize the listener, returns 0 if okay\n+  static int init();\n+\n+  static char* path()                   { return _path; }\n+  static bool has_path()                { return _has_path; }\n+  static int listener()                 { return _listener; }\n+\n+  \/\/ write the given buffer to a socket\n+  static int write_fully(int s, char* buf, int len);\n+\n+  static LinuxAttachOperation* dequeue();\n+  static LinuxAttachOperation* get_current_op();\n+  static void reset_current_op();\n+};\n+\n+#endif \/\/ OS_LINUX_ATTACHLISTENERLINUX_HPP\n","filename":"src\/hotspot\/os\/linux\/attachListener_linux.hpp","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+#ifndef OS_LINUX_LINUXATTACHOPERATION_HPP\n+#define OS_LINUX_LINUXATTACHOPERATION_HPP\n+#include \"services\/attachListener.hpp\"\n+\n+class LinuxAttachOperation: public AttachOperation {\n+ private:\n+  \/\/ the connection to the client\n+  int _socket;\n+  bool _effectively_completed;\n+  void write_operation_result(jint result, bufferedStream* st);\n+\n+ public:\n+  void complete(jint res, bufferedStream* st);\n+  void effectively_complete_raw(jint res, bufferedStream* st);\n+\n+  void set_socket(int s)                                { _socket = s; }\n+  int socket() const                                    { return _socket; }\n+\n+  LinuxAttachOperation(char* name) : AttachOperation(name) {\n+    set_socket(-1);\n+    _effectively_completed = false;\n+  }\n+};\n+#endif \/\/ OS_LINUX_LINUXATTACHOPERATION_HPP\n","filename":"src\/hotspot\/os\/linux\/linuxAttachOperation.hpp","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -74,0 +74,1 @@\n+#include \"linuxAttachOperation.hpp\"\n@@ -83,0 +84,1 @@\n+#include \"attachListener_linux.hpp\"\n@@ -390,2 +392,5 @@\n- public:\n-  VM_Crac(bool dry_run) :\n+  outputStream* _ostream;\n+  LinuxAttachOperation* _attach_op;\n+\n+public:\n+  VM_Crac(bool dry_run, bufferedStream* jcmd_stream) :\n@@ -395,1 +400,3 @@\n-    _restore_parameters()\n+    _restore_parameters(),\n+    _ostream(jcmd_stream ? jcmd_stream : tty),\n+    _attach_op(jcmd_stream ? LinuxAttachListener::get_current_op() : NULL)\n@@ -410,0 +417,6 @@\n+\n+private:\n+  bool is_socket_from_jcmd(int sock_fd);\n+  void report_ok_to_jcmd_if_any();\n+  void print_resources(const char* msg, ...);\n+  void trace_cr(const char* msg, ...);\n@@ -5717,1 +5730,1 @@\n-static void trace_cr(const char* msg, ...) {\n+void VM_Crac::trace_cr(const char* msg, ...) {\n@@ -5721,2 +5734,11 @@\n-    tty->print(\"CR: \");\n-    tty->vprint_cr(msg, ap);\n+    _ostream->print(\"CR: \");\n+    _ostream->vprint_cr(msg, ap);\n+    va_end(ap);\n+  }\n+}\n+\n+void VM_Crac::print_resources(const char* msg, ...) {\n+  if (CRPrintResourcesOnCheckpoint) {\n+    va_list ap;\n+    va_start(ap, msg);\n+    _ostream->vprint(msg, ap);\n@@ -6002,7 +6024,0 @@\n-  if (CRAllowToSkipCheckpoint) {\n-    trace_cr(\"Skip Checkpoint\");\n-    return JVM_CHECKPOINT_OK;\n-  }\n-\n-  trace_cr(\"Checkpoint ...\");\n-\n@@ -6030,1 +6045,5 @@\n-    tty->print_cr(\"JVM: invalid info for restore provided (may be failed checkpoint)\");\n+    tty->print(\"JVM: invalid info for restore provided: %s\", info.si_code == SI_QUEUE ? \"queued\" : \"not queued\");\n+    if (info.si_code == SI_QUEUE) {\n+      tty->print(\" code %d\", info.si_int);\n+    }\n+    tty->cr();\n@@ -6151,0 +6170,17 @@\n+\/\/ If checkpoint is called throught the API, jcmd operation and jcmd output doesn't exist.\n+bool VM_Crac::is_socket_from_jcmd(int sock) {\n+  if (_attach_op == NULL)\n+    return false;\n+  int sock_fd = _attach_op->socket();\n+  return sock == sock_fd;\n+}\n+\n+void VM_Crac::report_ok_to_jcmd_if_any() {\n+  if (_attach_op == NULL)\n+    return;\n+  bufferedStream* buf = static_cast<bufferedStream*>(_ostream);\n+  _attach_op->effectively_complete_raw(JNI_OK, buf);\n+  \/\/ redirect any further output to console\n+  _ostream = tty;\n+}\n+\n@@ -6172,4 +6208,2 @@\n-    if (CRPrintResourcesOnCheckpoint) {\n-      tty->print(\"JVM: FD fd=%d type=%s: details1=\\\"%s\\\" \",\n-          i, stat2strtype(fds.get_stat(i)->st_mode), details);\n-    }\n+    print_resources(\"JVM: FD fd=%d type=%s: details1=\\\"%s\\\" \",\n+        i, stat2strtype(fds.get_stat(i)->st_mode), details);\n@@ -6178,3 +6212,1 @@\n-      if (CRPrintResourcesOnCheckpoint) {\n-        tty->print_cr(\"OK: inherited from process env\");\n-      }\n+      print_resources(\"OK: inherited from process env\\n\");\n@@ -6189,3 +6221,1 @@\n-        if (CRPrintResourcesOnCheckpoint) {\n-          tty->print_cr(\"OK: always available, random or urandom\");\n-        }\n+        print_resources(\"OK: always available, random or urandom\\n\");\n@@ -6197,3 +6227,1 @@\n-      if (CRPrintResourcesOnCheckpoint) {\n-        tty->print_cr(\"OK: in classpath\");\n-      }\n+      print_resources(\"OK: in classpath\\n\");\n@@ -6204,3 +6232,1 @@\n-      if (CRPrintResourcesOnCheckpoint) {\n-        tty->print_cr(\"OK: assured persistent\");\n-      }\n+      print_resources(\"OK: assured persistent\\n\");\n@@ -6210,5 +6236,0 @@\n-    if (CRPrintResourcesOnCheckpoint) {\n-      tty->print(\"BAD: opened by application\");\n-    }\n-    ok = false;\n-\n@@ -6216,3 +6237,3 @@\n-      details = sock_details(details, detailsbuf, sizeof(detailsbuf));\n-      if (CRPrintResourcesOnCheckpoint) {\n-        tty->print(\" details2=\\\"%s\\\" \", details);\n+      if (is_socket_from_jcmd(i)){\n+        print_resources(\"OK: jcmd socket\\n\");\n+        continue;\n@@ -6220,0 +6241,2 @@\n+      details = sock_details(details, detailsbuf, sizeof(detailsbuf));\n+      print_resources(\" details2=\\\"%s\\\" \", details);\n@@ -6222,3 +6245,3 @@\n-    if (CRPrintResourcesOnCheckpoint) {\n-      tty->cr();\n-    }\n+    print_resources(\"BAD: opened by application\\n\");\n+    ok = false;\n+\n@@ -6242,1 +6265,0 @@\n-\n@@ -6244,4 +6266,10 @@\n-  int ret = checkpoint_restore(&shmid);\n-  if (ret == JVM_CHECKPOINT_ERROR) {\n-    PerfMemoryLinux::restore();\n-    return;\n+  if (CRAllowToSkipCheckpoint) {\n+    trace_cr(\"Skip Checkpoint\");\n+  } else {\n+    trace_cr(\"Checkpoint ...\");\n+    report_ok_to_jcmd_if_any();\n+    int ret = checkpoint_restore(&shmid);\n+    if (ret == JVM_CHECKPOINT_ERROR) {\n+      PerfMemoryLinux::restore();\n+      return;\n+    }\n@@ -6347,1 +6375,1 @@\n-Handle os::Linux::checkpoint(bool dry_run, TRAPS) {\n+Handle os::Linux::checkpoint(bool dry_run, jlong jcmd_stream, TRAPS) {\n@@ -6361,1 +6389,1 @@\n-  VM_Crac cr(dry_run);\n+  VM_Crac cr(dry_run, (bufferedStream*)jcmd_stream);\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":76,"deletions":48,"binary":false,"changes":124,"status":"modified"},{"patch":"@@ -176,1 +176,1 @@\n-  static Handle checkpoint(bool dry_run, TRAPS);\n+  static Handle checkpoint(bool dry_run, jlong jcmd_stream, TRAPS);\n","filename":"src\/hotspot\/os\/linux\/os_linux.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -710,0 +710,1 @@\n+  template(checkpointRestereInternal_signature,    \"(J)Ljava\/lang\/String;\")                                       \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1146,1 +1146,1 @@\n-JVM_Checkpoint(JNIEnv *env, jboolean dry_run);\n+JVM_Checkpoint(JNIEnv *env, jboolean dry_run, jlong jcmd_stream);\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3852,2 +3852,2 @@\n-JVM_ENTRY(jobjectArray, JVM_Checkpoint(JNIEnv *env, jboolean dry_run))\n-  Handle ret = os::Linux::checkpoint(dry_run, CHECK_NULL);\n+JVM_ENTRY(jobjectArray, JVM_Checkpoint(JNIEnv *env, jboolean dry_run, jlong jcmd_stream))\n+  Handle ret = os::Linux::checkpoint(dry_run, jcmd_stream, CHECK_NULL);\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+#include \"attachListener_linux.hpp\"\n@@ -794,1 +795,1 @@\n-  jvalue* jv = (jvalue*) result.get_value_addr();\n+  jvalue* jv = (jvalue*)result.get_value_addr();\n@@ -1043,1 +1044,3 @@\n-  JavaValue result(T_VOID);\n+  JavaValue result(T_OBJECT);\n+  JavaCallArguments args;\n+  args.push_long((jlong)output());\n@@ -1046,1 +1049,9 @@\n-                         vmSymbols::void_method_signature(), CHECK);\n+                         vmSymbols::checkpointRestereInternal_signature(), &args, CHECK);\n+  oop str = result.get_oop();\n+  if (str != NULL) {\n+    char* out = java_lang_String::as_utf8_string(str);\n+    if (out[0] != '\\0') {\n+      output()->print_cr(\"An exception during a checkpoint operation: \");\n+      output()->print(\"%s\", out);\n+    }\n+  }\n@@ -1048,1 +1059,0 @@\n-\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+import java.io.StringWriter;\n+import java.io.PrintWriter;\n@@ -56,1 +58,1 @@\n-    private static native Object[] checkpointRestore0(boolean dryRun);\n+    private static final long JCMD_STREAM_NULL = 0;\n@@ -58,0 +60,1 @@\n+    private static native Object[] checkpointRestore0(boolean dryRun, long jcmdStream);\n@@ -111,1 +114,1 @@\n-    private static void checkpointRestore1() throws\n+    private static void checkpointRestore1(long jcmdStream) throws\n@@ -125,1 +128,1 @@\n-        final Object[] bundle = checkpointRestore0(checkpointException != null);\n+        final Object[] bundle = checkpointRestore0(checkpointException != null, jcmdStream);\n@@ -228,1 +231,7 @@\n-        \/\/ checkpointRestore protects against the simultaneous\n+        checkpointRestore(JCMD_STREAM_NULL);\n+    }\n+\n+    private static void checkpointRestore(long jcmdStream) throws\n+            CheckpointException,\n+            RestoreException {\n+        \/\/ checkpointRestoreLock protects against the simultaneous\n@@ -235,0 +244,1 @@\n+                checkpointInProgress = true;\n@@ -236,2 +246,1 @@\n-                    checkpointInProgress = true;\n-                    checkpointRestore1();\n+                    checkpointRestore1(jcmdStream);\n@@ -251,17 +260,13 @@\n-    private static void checkpointRestoreInternal() {\n-        Thread thread = new Thread(() -> {\n-            try {\n-                Thread.sleep(100);\n-            } catch (InterruptedException e) {\n-            }\n-\n-            try {\n-                checkpointRestore();\n-            } catch (CheckpointException | RestoreException e) {\n-                for (Throwable t : e.getSuppressed()) {\n-                    t.printStackTrace();\n-                }\n-            }\n-        });\n-        thread.setDaemon(true);\n-        thread.start();\n+    private static String checkpointRestoreInternal(long jcmdStream) {\n+        try {\n+            checkpointRestore(jcmdStream);\n+        } catch (CheckpointException e) {\n+            StringWriter sw = new StringWriter();\n+            PrintWriter pw = new PrintWriter(sw);\n+            e.printStackTrace(pw);\n+            return sw.toString();\n+        } catch (RestoreException e) {\n+            e.printStackTrace();\n+            return null;\n+        }\n+        return null;\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/Core.java","additions":28,"deletions":23,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-Java_jdk_crac_Core_checkpointRestore0(JNIEnv *env, jclass ignore, jboolean dry_run)\n+Java_jdk_crac_Core_checkpointRestore0(JNIEnv *env, jclass ignore, jboolean dry_run, jlong jcmd_stream)\n@@ -41,1 +41,1 @@\n-    return JVM_Checkpoint(env, dry_run);\n+    return JVM_Checkpoint(env, dry_run, jcmd_stream);\n","filename":"src\/java.base\/share\/native\/libjava\/CracCore.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}