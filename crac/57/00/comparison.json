{"files":[{"patch":"@@ -81,0 +81,1 @@\n+#include \"utilities\/hashtable.hpp\"\n@@ -291,0 +292,1 @@\n+  const char* _next_checkpoint_to;\n@@ -332,0 +334,1 @@\n+  const char *next_checkpoint_to() const { return _next_checkpoint_to; }\n@@ -336,1 +339,2 @@\n-    _args(NULL)\n+    _args(NULL),\n+    _next_checkpoint_to(NULL)\n@@ -340,1 +344,1 @@\n-    if (_raw_content) {\n+    if (_raw_content != NULL) {\n@@ -380,1 +384,9 @@\n-    return write_check_error(fd, args, strlen(args)+1); \/\/ +1 for null char\n+    if (!write_check_error(fd, args, strlen(args)+1)) { \/\/ +1 for null char\n+      return false;\n+    }\n+\n+    const char* next_checkpoint = CRaCCheckpointTo;\n+    if (next_checkpoint == NULL) {\n+      next_checkpoint = \"\";\n+    }\n+    return write_check_error(fd, next_checkpoint, strlen(next_checkpoint) + 1);\n@@ -423,0 +435,1 @@\n+  void remap_old_imagedir();\n@@ -6168,0 +6181,11 @@\n+  if (ret) {\n+    const char* next = _restore_parameters.next_checkpoint_to();\n+    if (next != NULL) {\n+      static bool checkpoint_to_allocated = false;\n+      if (CRaCCheckpointTo != NULL && checkpoint_to_allocated) {\n+        FREE_C_HEAP_ARRAY(char, CRaCCheckpointTo);\n+      }\n+      CRaCCheckpointTo = next;\n+      checkpoint_to_allocated = true;\n+    }\n+  }\n@@ -6188,0 +6212,158 @@\n+static char *old_imagedir = NULL;\n+static pthread_mutex_t remapper_mutex = PTHREAD_MUTEX_INITIALIZER;\n+\n+static void retry_after_remap(int sig, siginfo_t *info, void *ucontext) {\n+  \/\/ We will block this thread until remapper is done.\n+  \/\/ We could validate that the address is one of the remapped ones\n+  \/\/ but since JavaThreads are blocked now nobody should just cause SIGSEGV\n+  pthread_mutex_lock(&remapper_mutex);\n+  pthread_mutex_unlock(&remapper_mutex);\n+}\n+\n+static void *remapper_thread(void *unused) {\n+  struct sigaction sa, old;\n+  memset(&sa, 0, sizeof(struct sigaction));\n+  sigemptyset(&sa.sa_mask);\n+\n+  sa.sa_flags     = SA_NODEFER | SA_SIGINFO;\n+  sa.sa_sigaction = retry_after_remap;\n+\n+  sigaction(SIGSEGV, &sa, &old);\n+\n+  FILE *maps = fopen(\"\/proc\/self\/maps\", \"r\");\n+  if (maps == NULL) {\n+    fprintf(stderr, \"Can't open \/proc\/self\/maps\\n\");\n+    return NULL;\n+  }\n+\n+  size_t imagedir_len = strlen(old_imagedir);\n+\n+  char buf[PATH_MAX];\n+  while (fgets(buf, PATH_MAX, maps)) {\n+    const char* fields[6];\n+    int nfields = 1;\n+    fields[0] = buf;\n+    for (int i = 0; i < PATH_MAX && buf[i] != 0; ++i) {\n+      if (buf[i] == ' ') {\n+        while (i < PATH_MAX && buf[i] == ' ') {\n+          buf[i++] = '\\0';\n+        }\n+        fields[nfields++] = buf + i;\n+        if (nfields >= 6) break;\n+      }\n+    }\n+    if (nfields >= 6 && strncmp(old_imagedir, fields[5], imagedir_len) == 0) {\n+      long start = 0, end = 0;\n+      if (sscanf(fields[0], \"%lx-%lx\", &start, &end) == 2) {\n+        size_t length = end - start;\n+        void *copy = mmap(NULL, length, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n+        if (copy == MAP_FAILED) {\n+          perror(\"Failed to mmap anonymous memory to replace file mapping\");\n+          continue;\n+        }\n+        if (mprotect((void *) start, length, PROT_READ | PROT_EXEC) != 0) {\n+          perror(\"Failed to protect memory against modifications while copying\");\n+          if (munmap(copy, length) != 0) {\n+            perror(\"Cannot unmap the anonymous copy\");\n+          }\n+          continue;\n+        }\n+        memcpy(copy, (void *) start, length);\n+        if (mremap(copy, length, length, MREMAP_FIXED | MREMAP_MAYMOVE, start) == MAP_FAILED) {\n+          perror(\"Failed to remap anonymous memory into file mapping\");\n+          fprintf(stderr, \"\\tRemapping %p(+%lx) into %lx-%lx\\n\", copy, length, start, end);\n+          if (munmap(copy, length) != 0) {\n+            perror(\"Cannot unmap the anonymous copy\");\n+          }\n+        }\n+      }\n+    }\n+  }\n+\n+  fclose(maps);\n+  sigaction(SIGSEGV, &old, NULL);\n+\n+  return NULL;\n+}\n+\n+void VM_Crac::remap_old_imagedir() {\n+  if (old_imagedir != NULL) {\n+    \/\/ This VM_Operation is executed when all threads are already at safepoint, so it's\n+    \/\/ safe to copy and remap their threads. We will do the remapping itself in a new\n+    \/\/ thread that does not have stack mapped to any of the mmaped files.\n+    \/\/ If any of the non-java threads start mutating its stack it will trigger SIGSEGV\n+    \/\/ as we've made it read-only using mprotect.\n+    pthread_attr_t attr;\n+    if (pthread_attr_init(&attr) != 0) {\n+      perror(\"Cannot initialize thread attributes\");\n+      return;\n+    }\n+    size_t stacksize;\n+    if (pthread_attr_getstacksize(&attr, &stacksize) != 0) {\n+      perror(\"Cannot find proper stack size\");\n+      return;\n+    }\n+    \/\/ We need to guarantee that new thread stack won't be mapped to a file\n+    \/\/ (this can happen even for a new thread)\n+    void *stackaddr = mmap(NULL, stacksize, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n+    if (stackaddr == MAP_FAILED) {\n+      perror(\"Cannot mmap anonymous memory for the remapper thread\");\n+      return;\n+    }\n+    if (pthread_attr_setstack(&attr, stackaddr, stacksize) != 0) {\n+      perror(\"Cannot set remapper thread stack address\");\n+      if (munmap(stackaddr, stacksize) != 0) {\n+        perror(\"Cannot release mmapped memory\");\n+      }\n+      return;\n+    }\n+    pthread_mutex_lock(&remapper_mutex);\n+    pthread_t remapper_tid;\n+    int ret = pthread_create(&remapper_tid, &attr, remapper_thread, NULL);\n+    if (ret != 0) {\n+      perror(\"Failed to create remapper thread\");\n+    } else {\n+      pthread_join(remapper_tid, NULL);\n+    }\n+    pthread_mutex_unlock(&remapper_mutex);\n+    remapper_tid = 0;\n+    if (munmap(stackaddr, stacksize) != 0) {\n+      perror(\"Cannot release mmapped memory\");\n+    }\n+\n+    FREE_C_HEAP_ARRAY(char, old_imagedir);\n+    old_imagedir = NULL;\n+  }\n+  if (CRaCCheckpointTo != NULL) {\n+    size_t len = strlen(CRaCCheckpointTo);\n+    char cwd[PATH_MAX];\n+    size_t cwd_len = 0;\n+    if (len == 0 || CRaCCheckpointTo[0] != '\/') {\n+      \/\/ use absolute path\n+      if (getcwd(cwd, PATH_MAX) == NULL) {\n+        perror(\"Cannot fetch current directory\");\n+        return;\n+      }\n+      cwd_len = strlen(cwd);\n+      if (cwd_len == 0 || cwd[cwd_len - 1] != '\/') {\n+        cwd[cwd_len] = '\/';\n+        cwd_len++;\n+      }\n+    }\n+    bool add_slash = false;\n+    if (len == 0 || CRaCCheckpointTo[len - 1] != '\/') {\n+      ++len; \/\/ add \/\n+      add_slash = true;\n+    }\n+    old_imagedir = NEW_C_HEAP_ARRAY(char, cwd_len + len + 1, mtArguments);\n+    if (cwd_len > 0) {\n+      strncpy(old_imagedir, cwd, cwd_len);\n+    }\n+    strncpy(old_imagedir + cwd_len, CRaCCheckpointTo, len);\n+    if (add_slash) {\n+      old_imagedir[cwd_len + len - 1] = '\/';\n+    }\n+    old_imagedir[cwd_len + len] = '\\0';\n+  }\n+}\n+\n@@ -6201,0 +6383,2 @@\n+  remap_old_imagedir();\n+\n@@ -6270,1 +6454,1 @@\n-    trace_cr(\"Checkpoint ...\");\n+    trace_cr(\"Checkpoint to %s ...\", CRaCCheckpointTo);\n@@ -6523,0 +6707,5 @@\n+\/\/ Since putenv does not do its own copy of the strings we need to keep\n+\/\/ them around and release memory properly.\n+typedef KVHashtable<const char *, const char *, mtInternal> C_Str_Hashtable;\n+static C_Str_Hashtable env_holder(93);\n+\n@@ -6553,9 +6742,25 @@\n-  char* env_mem = NEW_C_HEAP_ARRAY(char, hdr->_env_memory_size, mtArguments); \/\/ left this pointer unowned, it is freed when process dies\n-  memcpy(env_mem, cursor, hdr->_env_memory_size);\n-\n-  const char* env_end = env_mem + hdr->_env_memory_size;\n-  while (env_mem < env_end) {\n-    const size_t s = strlen(env_mem) + 1;\n-    assert(env_mem + s <= env_end, \"env vars exceed memory buffer, maybe ending 0 is lost\");\n-    putenv(env_mem);\n-    env_mem += s;\n+  const char* env_end = cursor + hdr->_env_memory_size;\n+  while (cursor < env_end) {\n+    const size_t s = strlen(cursor) + 1;\n+    assert(cursor + s <= env_end, \"env vars exceed memory buffer, maybe ending 0 is lost\");\n+    char* eq = strchr(cursor, '=');\n+    if (eq != NULL) {\n+      *eq = '\\0';\n+      C_Str_Hashtable::KVHashtableEntry *old = env_holder.lookup_entry(cursor);\n+      *eq = '=';\n+      char* value = NEW_C_HEAP_ARRAY(char, s, mtInternal);\n+      strncpy(value, cursor, s);\n+      putenv(value);\n+      if (old == NULL) {\n+        char* key = NEW_C_HEAP_ARRAY(char, eq - cursor + 1, mtInternal);\n+        strncpy(key, cursor, eq - cursor);\n+        key[eq - cursor] = '\\0';\n+        env_holder.add(key, value);\n+      } else {\n+        FREE_C_HEAP_ARRAY(char, old->_value);\n+        old->_value = value;\n+      }\n+    } else {\n+      assert(false, \"no '=' in env vars?\");\n+    }\n+    cursor += s;\n@@ -6563,1 +6768,0 @@\n-  cursor += hdr->_env_memory_size;\n@@ -6566,0 +6770,10 @@\n+  cursor += strlen(_args) + 1;\n+\n+  char* buf = NULL;\n+  if (*cursor != '\\0') {\n+    size_t len = strlen(cursor) + 1;\n+    buf = NEW_C_HEAP_ARRAY(char, len, mtArguments);\n+    strncpy(buf, cursor, len);\n+    buf[len - 1] = '\\0';\n+  }\n+  _next_checkpoint_to = buf;\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":228,"deletions":14,"binary":false,"changes":242,"status":"modified"},{"patch":"@@ -1212,0 +1212,11 @@\n+template<ccstr> unsigned primitive_hash(const ccstr& k) {\n+  unsigned h = 0;\n+  for (ccstr c = k; *c != 0; ++c) {\n+    h = 31 * h + (*c & 0xff);\n+  }\n+  return h;\n+}\n+\n+template<ccstr> bool primitive_equals(const ccstr& k0, const ccstr& k1) {\n+  return strcmp(k0, k1) == 0;\n+}\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -231,0 +231,1 @@\n+public:\n@@ -273,0 +274,11 @@\n+  KVHashtableEntry* lookup_entry(K key) const {\n+    unsigned int hash = HASH(key);\n+    int index = BasicHashtable<F>::hash_to_index(hash);\n+    for (KVHashtableEntry* e = bucket(index); e != NULL; e = e->next()) {\n+      if (e->hash() == hash && EQUALS(e->_key, key)) {\n+        return e;\n+      }\n+    }\n+    return NULL;\n+  }\n+\n","filename":"src\/hotspot\/share\/utilities\/hashtable.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+    private static boolean jsigLoaded;\n@@ -240,0 +241,6 @@\n+            if (!jsigLoaded) {\n+                \/\/ Signal handlers chaining is necessary for remapping memory\n+                \/\/ with repeated checkpoint-restores\n+                System.loadLibrary(\"jsig\");\n+                jsigLoaded = true;\n+            }\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/Core.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -304,0 +304,4 @@\n+    } else if (WIFSIGNALED(status)) {\n+        return 128 + WTERMSIG(status);\n+    } else if (WIFSTOPPED(status)) {\n+        return 128 + WSTOPSIG(status);\n","filename":"src\/java.base\/unix\/native\/criuengine\/criuengine.c","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2022, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.Core;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @build RepeatedCheckpointRestoreTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class RepeatedCheckpointRestoreTest implements CracTest {\n+    @Override\n+    public void test() throws Exception {\n+        CracBuilder builder = new CracBuilder();\n+        builder.doCheckpoint();\n+        builder.captureOutput(true)\n+                .startRestore().waitForCheckpointed()\n+                .outputAnalyzer().stdoutShouldContain(\"First\");\n+        builder\n+                .startRestoreAndCheckpointTo(\"cr2\").waitForCheckpointed()\n+                .outputAnalyzer().stdoutShouldContain(\"Second\");\n+        builder.imageDir(\"cr2\").doRestore()\n+                .outputAnalyzer().stdoutShouldContain(\"Third\");\n+        \/\/ Let's try to run again last one\n+        builder.doRestore().outputAnalyzer().stdoutShouldContain(\"Third\");\n+        \/\/ Now test in the old directory\n+        new CracBuilder().captureOutput(true)\n+                .startRestore().waitForCheckpointed()\n+                .outputAnalyzer().stdoutShouldContain(\"Second\");\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        Core.checkpointRestore();\n+        System.out.println(\"First\");\n+        Core.checkpointRestore();\n+        System.out.println(\"Second\");\n+        Core.checkpointRestore();\n+        System.out.println(\"Third\");\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/RepeatedCheckpointRestoreTest.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -27,2 +27,0 @@\n-import java.io.IOException;\n-\n@@ -40,0 +38,1 @@\n+    static final String AFTER_SECOND_RESTORE = \"AfterSecondRestore\";\n@@ -41,1 +40,2 @@\n-    public static final String PREFIX = \"(after restore) \";\n+    public static final String PREFIX1 = \"(after restore) \";\n+    public static final String PREFIX2 = \"(after second restore) \";\n@@ -51,0 +51,6 @@\n+        builder.startRestore().waitForCheckpointed().outputAnalyzer()\n+                .shouldContain(PREFIX1 + TEST_VAR_NAME + \"0=\" + BEFORE_CHECKPOINT)\n+                .shouldContain(PREFIX1 + TEST_VAR_NAME + \"1=\" + AFTER_RESTORE)\n+                .shouldContain(PREFIX1 + TEST_VAR_NAME + \"2=\" + NEW_VALUE);\n+        builder.env(TEST_VAR_NAME + 0, AFTER_SECOND_RESTORE);\n+        builder.env(TEST_VAR_NAME + 1, AFTER_SECOND_RESTORE);\n@@ -52,3 +58,3 @@\n-                .shouldContain(PREFIX + TEST_VAR_NAME + \"0=\" + BEFORE_CHECKPOINT)\n-                .shouldContain(PREFIX + TEST_VAR_NAME + \"1=\" + AFTER_RESTORE)\n-                .shouldContain(PREFIX + TEST_VAR_NAME + \"2=\" + NEW_VALUE);\n+                .shouldContain(PREFIX2 + TEST_VAR_NAME + \"0=\" + AFTER_SECOND_RESTORE)\n+                .shouldContain(PREFIX2 + TEST_VAR_NAME + \"1=\" + AFTER_SECOND_RESTORE)\n+                .shouldContain(PREFIX2 + TEST_VAR_NAME + \"2=\" + NEW_VALUE);\n@@ -59,5 +65,3 @@\n-        for (int i = 0; i < 3; ++i) {\n-            var testVar = java.lang.System.getenv(TEST_VAR_NAME + i);\n-            System.out.println(\"(before checkpoint) \" + TEST_VAR_NAME + i + \"=\" + testVar);\n-        }\n-\n+        printVars(\"(before checkpoint) \");\n+        jdk.crac.Core.checkpointRestore();\n+        printVars(PREFIX1);\n@@ -65,0 +69,2 @@\n+        printVars(PREFIX2);\n+    }\n@@ -66,0 +72,1 @@\n+    private static void printVars(String prefix) {\n@@ -67,2 +74,2 @@\n-            var testVar = java.lang.System.getenv(TEST_VAR_NAME + i);\n-            System.out.println(PREFIX + TEST_VAR_NAME + i + \"=\" + testVar + \"\");\n+            var testVar = System.getenv(TEST_VAR_NAME + i);\n+            System.out.println(prefix + TEST_VAR_NAME + i + \"=\" + testVar);\n","filename":"test\/jdk\/jdk\/crac\/RestoreEnvironmentTest.java","additions":20,"deletions":13,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -139,2 +139,2 @@\n-    public void doCheckpoint() throws Exception {\n-        startCheckpoint().waitForCheckpointed();\n+    public CracProcess doCheckpoint() throws Exception {\n+        return startCheckpoint().waitForCheckpointed();\n@@ -154,1 +154,0 @@\n-        log(String.join(\" \", cmd));\n@@ -246,1 +245,9 @@\n-        log(String.join(\" \", cmd));\n+        return new CracProcess(this, cmd);\n+    }\n+\n+    public CracProcess startRestoreAndCheckpointTo(String newImageDir) throws Exception {\n+        ensureContainerStarted();\n+        List<String> cmd = prepareCommand(null);\n+        cmd.add(\"-XX:CRaCRestoreFrom=\" + imageDir);\n+        cmd.add(\"-XX:CRaCCheckpointTo=\" + newImageDir);\n+        log(\"Starting restored process for checkpoint:\");\n@@ -265,1 +272,0 @@\n-        log(String.join(\" \", cmd));\n@@ -287,9 +293,1 @@\n-        List<String> cmd = new ArrayList<>();\n-        if (javaPrefix != null) {\n-            cmd.addAll(javaPrefix);\n-        } else if (dockerImageName != null) {\n-            cmd.addAll(Arrays.asList(Container.ENGINE_COMMAND, \"exec\", CONTAINER_NAME));\n-            cmd.add(DOCKER_JAVA);\n-        } else {\n-            cmd.add(JAVA);\n-        }\n+        List<String> cmd = getJavaPrefix(javaPrefix);\n@@ -313,0 +311,13 @@\n+    private List<String> getJavaPrefix(List<String> override) {\n+        List<String> cmd = new ArrayList<>();\n+        if (override != null) {\n+            cmd.addAll(override);\n+        } else if (dockerImageName != null) {\n+            cmd.addAll(Arrays.asList(Container.ENGINE_COMMAND, \"exec\", CONTAINER_NAME));\n+            cmd.add(DOCKER_JAVA);\n+        } else {\n+            cmd.add(JAVA);\n+        }\n+        return cmd;\n+    }\n+\n","filename":"test\/lib\/jdk\/test\/lib\/crac\/CracBuilder.java","additions":25,"deletions":14,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -21,0 +21,1 @@\n+        builder.log(String.join(\" \", cmd));\n@@ -35,1 +36,1 @@\n-    public void waitForCheckpointed() throws InterruptedException {\n+    public CracProcess waitForCheckpointed() throws InterruptedException {\n@@ -42,0 +43,1 @@\n+        return this;\n","filename":"test\/lib\/jdk\/test\/lib\/crac\/CracProcess.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"}]}