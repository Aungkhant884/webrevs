{"files":[{"patch":"@@ -28,1 +28,0 @@\n-import java.net.InetSocketAddress;\n@@ -33,0 +32,2 @@\n+import jdk.crac.RestoreException;\n+import jdk.crac.impl.OpenFDPolicies;\n@@ -36,3 +37,1 @@\n-import jdk.internal.crac.Core;\n-import jdk.internal.crac.JDKContext;\n-import jdk.internal.crac.JDKResource;\n+import jdk.internal.crac.*;\n@@ -64,0 +63,5 @@\n+        private int originalFd = -1;\n+        private String originalType;\n+        private String originalPath;\n+        private int originalFlags;\n+        private long originalOffset;\n@@ -114,6 +118,1 @@\n-        Core.getJDKContext().register(checkpointListener = new JDKResource() {\n-            @Override\n-            public Priority getPriority() {\n-                return Priority.NORMAL;\n-            }\n-\n+        Core.getJDKContext().register(checkpointListener = new JDKResourceStub(JDKResource.Priority.NORMAL) {\n@@ -127,4 +126,0 @@\n-\n-            @Override\n-            public void afterRestore(Context<? extends jdk.crac.Resource> context) {\n-            }\n@@ -132,0 +127,1 @@\n+        OpenFDPolicies.ensureRegistered();\n@@ -375,0 +371,1 @@\n+    @SuppressWarnings(\"fallthrough\")\n@@ -378,14 +375,42 @@\n-            if (ctx.claimFdWeak(this, this)) {\n-                String path = getPath();\n-                String type = getType();\n-                String info;\n-                if (\"socket\".equals(type)) {\n-                    info = Socket.getDescription(this);\n-                } else {\n-                    info = (path != null ? path : \"unknown path\") + \" (\" + (type != null ? type : \"unknown\") + \")\";\n-                }\n-                String msg = \"FileDescriptor \" + this.fd + \" left open: \" + info + \" \";\n-                if (!JDKContext.Properties.COLLECT_FD_STACKTRACES) {\n-                    msg += JDKContext.COLLECT_FD_STACKTRACES_HINT;\n-                }\n-                throw new CheckpointOpenFileException(msg, resource.stackTraceHolder);\n+            String path = getPath();\n+            String type = getType();\n+            OpenFDPolicies.BeforeCheckpoint policy = OpenFDPolicies.CHECKPOINT.get(fd, type, path);\n+            switch (policy) {\n+                case ERROR:\n+                    if (ctx.claimFdWeak(this, this)) {\n+                        String info;\n+                        if (\"socket\".equals(type)) {\n+                            info = Socket.getDescription(this);\n+                        } else {\n+                            info = (path != null ? path : \"unknown path\") + \" (\" + (type != null ? type : \"unknown\") + \")\";\n+                        }\n+                        String msg = \"FileDescriptor \" + this.fd + \" left open: \" + info + \" \";\n+                        if (!JDKContext.Properties.COLLECT_FD_STACKTRACES) {\n+                            msg += JDKContext.COLLECT_FD_STACKTRACES_HINT;\n+                        }\n+                        throw new CheckpointOpenFileException(msg, resource.stackTraceHolder);\n+                    }\n+                    break;\n+                case WARN_CLOSE:\n+                    LoggerContainer.warn(\"CRaC: File descriptor {0} ({1}) was not closed by the application!\", fd, path);\n+                    \/\/ intentional fallthrough\n+                case CLOSE:\n+                    resource.originalFd = fd;\n+                    resource.originalType = type;\n+                    resource.originalPath = path;\n+                    resource.originalFlags = getFlags();\n+                    resource.originalOffset = getOffset();\n+                    if (resource.originalOffset < 0) {\n+                        throw new CheckpointOpenFileException(\"Cannot find current offset of descriptor \" + fd + \"(\" + path + \")\", null);\n+                    }\n+                    try {\n+                        close0(); \/\/ do not unregister any handlers\n+                    } catch (IOException e) {\n+                        throw new CheckpointOpenFileException(\"Cannot close file descriptor \" + fd + \" (\" + path + \") before checkpoint\", e);\n+                    }\n+                    LoggerContainer.debug(\"Closed FD {0} ({1}, offset {2} with flags 0x{3}%n\",\n+                            resource.originalFd, resource.originalPath, resource.originalOffset,\n+                            Integer.toHexString(resource.originalFlags).toUpperCase());\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unknown policy \" + policy);\n@@ -400,1 +425,50 @@\n-    private synchronized void afterRestore() {\n+    private native int getFlags();\n+\n+    private native long getOffset();\n+\n+    private synchronized void afterRestore() throws RestoreException {\n+        if (!valid() && resource.originalFd >= 0) {\n+            OpenFDPolicies.AfterRestorePolicy policy =\n+                    OpenFDPolicies.RESTORE.get(resource.originalFd, resource.originalType, resource.originalPath);\n+            if (policy.type == OpenFDPolicies.AfterRestore.KEEP_CLOSED) {\n+                LoggerContainer.debug(\"FD %d (%s) is not reopened per policy%n\",\n+                            resource.originalFd, resource.originalPath);\n+                resource.originalPath = null;\n+                resource.originalType = null;\n+                return;\n+            }\n+            String path;\n+            if (policy.type == OpenFDPolicies.AfterRestore.OPEN_OTHER) {\n+                path = policy.param;\n+            } else {\n+                if (resource.originalPath == null) {\n+                    throw new RestoreException(\"Cannot reopen file descriptor \" +\n+                            resource.originalFd + \": invalid path: \" + resource.originalPath);\n+                } else if (resource.originalType.equals(\"socket\")) {\n+                    throw new RestoreException(\"Cannot reopen file descriptor \" +\n+                            resource.originalFd + \": cannot restore socket\");\n+                }\n+                path = resource.originalPath;\n+            }\n+            \/\/ We will attempt to open at the original offset even if the path changed;\n+            \/\/ this is used probably as the file moved on the filesystem but the contents\n+            \/\/ are the same.\n+            if (!reopen(resource.originalFd, path, resource.originalFlags, resource.originalOffset)) {\n+                if (policy.type == OpenFDPolicies.AfterRestore.REOPEN_OR_NULL) {\n+                    if (!reopenNull(resource.originalFd)) {\n+                        throw new RestoreException(\"Cannot reopen file descriptor \" +\n+                                resource.originalFd + \" to null device\");\n+                    }\n+                } else {\n+                    throw new RestoreException(\"Cannot reopen file descriptor \" +\n+                            resource.originalFd + \" to \" + path);\n+                }\n+            } else {\n+                LoggerContainer.debug(\"Reopened FD %d (%s, offset %d) with flags 0x%08X%n\",\n+                        resource.originalFd, resource.originalPath, resource.originalOffset, resource.originalFlags);\n+            }\n+            this.fd = resource.originalFd;\n+        }\n+        \/\/ let GC collect the path and type\n+        resource.originalPath = null;\n+        resource.originalType = null;\n@@ -403,0 +477,4 @@\n+    private native boolean reopen(int fd, String path, int flags, long offset);\n+\n+    private native boolean reopenNull(int fd);\n+\n","filename":"src\/java.base\/share\/classes\/java\/io\/FileDescriptor.java","additions":107,"deletions":29,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -123,2 +123,0 @@\n-        \/\/ This log is here to initialize call sites in logger formatters.\n-        LoggerContainer.debug(\"Starting checkpoint at epoch:{0}\", System.currentTimeMillis());\n@@ -175,2 +173,3 @@\n-        if (newProperties != null && newProperties.length > 0) {\n-            Arrays.stream(newProperties).map(propStr -> propStr.split(\"=\", 2)).forEach(pair -> {\n+        if (newProperties != null) {\n+            for (String propStr : newProperties) {\n+                String[] pair = propStr.split(\"=\", 2);\n@@ -178,3 +177,7 @@\n-                    (PrivilegedAction<String>)() ->\n-                        System.setProperty(pair[0], pair.length == 2 ? pair[1] : \"\"));\n-            });\n+                        new PrivilegedAction<String>() {\n+                            @Override\n+                            public String run() {\n+                                return System.setProperty(pair[0], pair.length == 2 ? pair[1] : \"\");\n+                            }\n+                        });\n+            }\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/Core.java","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,307 @@\n+package jdk.crac.impl;\n+\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKResource;\n+import jdk.internal.crac.JDKResourceStub;\n+import jdk.internal.crac.LoggerContainer;\n+import sun.security.action.GetPropertyAction;\n+\n+import java.io.*;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Path;\n+import java.nio.file.PathMatcher;\n+import java.util.*;\n+import java.util.regex.Pattern;\n+\n+import static jdk.crac.impl.OpenFDPolicies.AfterRestore.OPEN_OTHER;\n+\n+public class OpenFDPolicies<P> {\n+    public static final String CHECKPOINT_PROPERTY = \"jdk.crac.fd-policy.checkpoint\";\n+    public static final String RESTORE_PROPERTY = \"jdk.crac.fd-policy.restore\";\n+    public static final String FIFO = \"FIFO\";\n+    public static final String SOCKET = \"SOCKET\";\n+\n+    public static final OpenFDPolicies<BeforeCheckpoint> CHECKPOINT =\n+            new OpenFDPolicies<>(BeforeCheckpoint.ERROR);\n+    public static final OpenFDPolicies<AfterRestorePolicy> RESTORE =\n+            new OpenFDPolicies<>(new AfterRestorePolicy(AfterRestore.REOPEN_OR_ERROR, null));\n+\n+    private static Pattern NUMERIC;\n+    private static final JDKResource resource = new JDKResourceStub(JDKResource.Priority.NORMAL) {\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) {\n+            CHECKPOINT.clear();\n+            \/\/ We need to s\n+            loadCheckpointPolicies();\n+            RESTORE.clear();\n+        }\n+    };\n+\n+    private final P defaultPolicy;\n+    private boolean loaded;\n+    private P fifoPolicy;\n+    private P socketPolicy;\n+    private final Map<Integer, P> numericPolicies = new HashMap<>();\n+    private final List<Map.Entry<PathMatcher, P>> pathPolicies = new ArrayList<>();\n+\n+    static {\n+        \/\/ This static ctor runs too early to invoke loadCheckpointPolicies directly\n+        Core.getJDKContext().register(resource);\n+    }\n+\n+    private synchronized static void loadCheckpointPolicies() {\n+        \/\/ We cannot initialize this in static constructor as this is invoked too early\n+        if (NUMERIC == null) {\n+            NUMERIC = Pattern.compile(\"[0-9]+\");\n+        }\n+        loadProperties(\"checkpoint\", CHECKPOINT_PROPERTY).forEach((key, value) -> {\n+            BeforeCheckpoint policy;\n+            try {\n+                policy = BeforeCheckpoint.valueOf(value.toString());\n+            } catch (IllegalArgumentException e) {\n+                LoggerContainer.error(\"Invalid value of policy '{0}' for target {1}; valid values are: {2}\",\n+                        value, key, Arrays.toString(BeforeCheckpoint.values()));\n+                return;\n+            }\n+            CHECKPOINT.setPolicy(key, value, policy);\n+        });\n+        CHECKPOINT.loaded = true;\n+    }\n+\n+    private synchronized static void loadRestorePolicies() {\n+        AfterRestore[] policies = AfterRestore.values();\n+        loadProperties(\"restore\", RESTORE_PROPERTY).forEach((key, value) -> {\n+            String pstr = value.toString();\n+            AfterRestorePolicy policy = null;\n+            for (var p : policies) {\n+                if (pstr.startsWith(p.name())) {\n+                    if (p == OPEN_OTHER) {\n+                        \/\/ we add + 2 because we need the equal sign and at least one character for the path\n+                        if (pstr.length() < OPEN_OTHER.name().length() + 2 || pstr.charAt(OPEN_OTHER.name().length()) != '=') {\n+                            LoggerContainer.error(\"Invalid specification for policy '{0}' for target {1}: \" +\n+                                    \"Policy name should be followed by an equal sign '=' and then the path.\", OPEN_OTHER, key);\n+                            return;\n+                        } else {\n+                            policy = new AfterRestorePolicy(OPEN_OTHER,\n+                                    unescape(pstr, OPEN_OTHER.name().length() + 1, pstr.length()));\n+                        }\n+                    } else if (pstr.length() == p.name().length()) {\n+                        policy = new AfterRestorePolicy(p, null);\n+                    }\n+                }\n+            }\n+            if (policy == null) {\n+                LoggerContainer.error(\"Invalid value of restore policy '{0}' for target {1}; valid values are: {2}\",\n+                        value, key, Arrays.toString(AfterRestore.values()));\n+            } else {\n+                RESTORE.setPolicy(key, value, policy);\n+            }\n+        });\n+        RESTORE.loaded = true;\n+    }\n+\n+    public OpenFDPolicies(P defaultPolicy) {\n+        this.defaultPolicy = defaultPolicy;\n+        this.fifoPolicy = defaultPolicy;\n+        this.socketPolicy = defaultPolicy;\n+    }\n+\n+    private void clear() {\n+        this.fifoPolicy = defaultPolicy;\n+        this.socketPolicy = defaultPolicy;\n+        this.numericPolicies.clear();\n+        this.pathPolicies.clear();\n+        this.loaded = false;\n+    }\n+\n+    private static Properties loadProperties(String type, String systemProperty) {\n+        Properties properties = new Properties();\n+        String file = GetPropertyAction.privilegedGetProperty(systemProperty + \".file\");\n+        if (file != null) {\n+            try {\n+                if (file.length() >= 4 && file.substring(file.length() - 4).equalsIgnoreCase(\".xml\")) {\n+                    try (var fis = new FileInputStream(file)) {\n+                        properties.loadFromXML(fis);\n+                    }\n+                } else {\n+                    try (var fr = new FileReader(file, StandardCharsets.UTF_8)) {\n+                        properties.load(fr);\n+                    }\n+                }\n+            } catch (IOException e) {\n+                LoggerContainer.error(\"Failed to read {0} file descriptor policies from {1}: {2}\", type, file, e.getMessage());\n+            }\n+        }\n+        String property = GetPropertyAction.privilegedGetProperty(systemProperty);\n+        if (property != null) {\n+            for (var item : property.split(File.pathSeparator)) {\n+                int eqIndex = findNonEscapedEq(item, 0);\n+                if (eqIndex < 0) {\n+                    LoggerContainer.error(\"Invalid specification for {0} file descriptor policy: {1}\", type, item);\n+                } else {\n+                    properties.put(unescape(item, 0, eqIndex), item.substring(eqIndex + 1));\n+                }\n+            }\n+        }\n+        return properties;\n+    }\n+\n+    private static String unescape(String str, int fromIndex, int toIndex) {\n+        boolean escaped = false;\n+        StringBuilder sb = new StringBuilder(str.length() - fromIndex);\n+        for (int i = fromIndex; i < toIndex; ++i) {\n+            char c = str.charAt(i);\n+            if (!escaped && c == '\\\\') {\n+                escaped = true;\n+            } else {\n+                sb.append(c);\n+                escaped = false;\n+            }\n+        }\n+        return sb.toString();\n+    }\n+\n+    private static int findNonEscapedEq(String str, int fromIndex) {\n+        boolean escaped = false;\n+        for (int i = fromIndex; i < str.length(); ++i) {\n+            char c = str.charAt(i);\n+            if (c == '\\\\') {\n+                escaped = !escaped;\n+            } else if (c == '=' && !escaped) {\n+                return i;\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    public static void ensureRegistered() {\n+        \/\/ Noop - this method is invoked to ensure that static constructor was invoked\n+    }\n+\n+    private void setPolicy(Object key, Object value, P policy) {\n+        if (FIFO.equals(key)) {\n+            fifoPolicy = policy;\n+        } else if (SOCKET.equals(key)) {\n+            socketPolicy = policy;\n+        } else if (NUMERIC.matcher(key.toString()).matches()) {\n+            int fd = Integer.parseInt(key.toString());\n+            P prev = numericPolicies.putIfAbsent(fd, policy);\n+            if (prev != null) {\n+                LoggerContainer.error(\"Duplicate policy for file descriptor {0}; policy {1} will be ignored.\", fd, value);\n+            }\n+        } else {\n+            pathPolicies.add(Map.entry(\n+                    FileSystems.getDefault().getPathMatcher(\"glob:\" + key), policy));\n+        }\n+    }\n+\n+    public P get(int fd, String type, String path) {\n+        synchronized (OpenFDPolicies.this) {\n+            if (!loaded) {\n+                \/\/ We could use a Runnable but method references don't work\n+                \/\/ when the static ctor is invoked\n+                if (this == CHECKPOINT) {\n+                    loadCheckpointPolicies();\n+                } else {\n+                    loadRestorePolicies();\n+                }\n+            }\n+        }\n+        P policy = numericPolicies.get(fd);\n+        if (policy != null) {\n+            return policy;\n+        }\n+        if (path != null) {\n+            Path p = Path.of(path);\n+            for (var entry : pathPolicies) {\n+                if (entry.getKey().matches(p)) {\n+                    return entry.getValue();\n+                }\n+            }\n+        }\n+        if (type.equals(\"fifo\") && fd > 2) {\n+            return fifoPolicy;\n+        } else if (type.equals(\"socket\")) {\n+            return socketPolicy;\n+        }\n+        return defaultPolicy;\n+    }\n+\n+    \/**\n+     * Defines a treatment of file descriptor found open during checkpoint.\n+     *\/\n+    public enum BeforeCheckpoint {\n+        \/**\n+         * The checkpoint fails with an appropriate error message. This is the\n+         * default as it is safer to force applications handle the checkpoint,\n+         * the options below are meant as workarounds when this is not feasible.\n+         *\/\n+        ERROR,\n+        \/**\n+         * The file descriptor will be silently closed. The original path will\n+         * be recorded and after restore this will be subject to treatment based\n+         * on the {@link AfterRestore} policy.\n+         *\/\n+        CLOSE,\n+        \/**\n+         * The behaviour is identical to {@link #CLOSE} but the application\n+         * will print out a warning message to the standard error.\n+         *\/\n+        WARN_CLOSE,\n+        \/\/ TODO: for no-downtime replication (scaling up) a strategy that would\n+        \/\/  keep the descriptor open when the checkpointed process is left\n+        \/\/  running might be useful.\n+    }\n+\n+    \/**\n+     * Defines what to do with file descriptors closed by the\n+     * {@link BeforeCheckpoint} policy after restore from a checkpoint.\n+     *\/\n+    public enum AfterRestore {\n+        \/**\n+         * The file descriptor is reopened. If it cannot be opened (e.g.\n+         * the file is not on the filesystem anymore or the process has\n+         * insufficient permissions) an error is printed and the restored\n+         * process is terminated.\n+         * If the file descriptor had no matching file (it is a pipe or\n+         * socket) this is treated as an error.\n+         * This is the default behaviour.\n+         *\/\n+        REOPEN_OR_ERROR,\n+        \/**\n+         * The file descriptor is reopened. If it cannot be opened (e.g.\n+         * the file is missing, it was a pipe or socket or the process has\n+         * insufficient permissions) a \/dev\/null device is opened instead\n+         * (allowing the process to write any data but not providing anything\n+         * for reading).\n+         *\/\n+        REOPEN_OR_NULL,\n+        \/**\n+         * After restore another file specified as part of the policy\n+         * declaration (usually the policy name is followed by\n+         * an equal sign '=' character and then the path) is opened instead.\n+         * If the other file cannot be open an error is printed and the process\n+         * is terminated.\n+         *\/\n+        OPEN_OTHER,\n+        \/**\n+         * Do not do anything with the closed descriptor; this will probably result\n+         * in runtime errors if the resource is used.\n+         *\/\n+        KEEP_CLOSED\n+    }\n+\n+    public static class AfterRestorePolicy {\n+        public final AfterRestore type;\n+        public final String param;\n+\n+        private AfterRestorePolicy(AfterRestore type, String param) {\n+            this.type = type;\n+            this.param = param;\n+        }\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/impl\/OpenFDPolicies.java","additions":307,"deletions":0,"binary":false,"changes":307,"status":"added"},{"patch":"@@ -0,0 +1,25 @@\n+package jdk.internal.crac;\n+\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+\n+public class JDKResourceStub implements JDKResource {\n+    private final JDKResource.Priority priority;\n+\n+    protected JDKResourceStub(Priority priority) {\n+        this.priority = priority;\n+    }\n+\n+    @Override\n+    public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+    }\n+\n+    @Override\n+    public void afterRestore(Context<? extends Resource> context) throws Exception {\n+    }\n+\n+    @Override\n+    public Priority getPriority() {\n+        return priority;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/JDKResourceStub.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"added"},{"patch":"@@ -22,0 +22,4 @@\n+    public static void warn(String fmt, Object... params) {\n+        logger.log(System.Logger.Level.WARNING, fmt, params);\n+    }\n+\n@@ -26,0 +30,4 @@\n+    public static void error(String fmt, Object... params) {\n+        logger.log(System.Logger.Level.ERROR, fmt, params);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/LoggerContainer.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.text.MessageFormat;\n@@ -58,0 +59,10 @@\n+    static {\n+        \/\/ It is possible that CRaC would print first logging message after\n+        \/\/ JDKContext completes. Registering a CallSite as resource at this\n+        \/\/ point would hang the checkpoint, therefore we perform all the\n+        \/\/ initialization eagerly.\n+        new SimpleConsoleLogger(null, false).getCallerInfo();\n+        String.format(\"%tc\",ZonedDateTime.now());\n+        MessageFormat.format(\"{0} {1}\", 0, \"1\");\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/logger\/SimpleConsoleLogger.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -131,0 +131,5 @@\n+    static {\n+        \/\/ Force initialization before checkpoint starts\n+        new FileDispatcherImpl();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/NioSocketImpl.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+\n@@ -27,0 +28,1 @@\n+#include <limits.h>\n@@ -28,0 +30,1 @@\n+#include <string.h>\n@@ -107,1 +110,0 @@\n-\n@@ -119,0 +121,76 @@\n+JNIEXPORT jlong JNICALL\n+Java_java_io_FileDescriptor_getOffset(JNIEnv *env, jobject obj) {\n+    int fd = (*env)->GetIntField(env, obj, IO_fd_fdID);\n+    jlong offset = lseek(fd, 0, SEEK_CUR);\n+    if (offset < 0) {\n+        if (errno == ESPIPE) {\n+            return 0;\n+        } else {\n+            perror(\"CRaC: cannot find file descriptor offset\");\n+            return offset;\n+        }\n+    }\n+    return offset;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_java_io_FileDescriptor_getFlags(JNIEnv *env, jobject obj) {\n+    int fd = (*env)->GetIntField(env, obj, IO_fd_fdID);\n+    return fcntl(fd, F_GETFL);\n+}\n+\n+JNIEXPORT jboolean JNICALL\n+Java_java_io_FileDescriptor_reopen(JNIEnv *env, jobject obj, jint fd, jstring path, jint flags, jlong offset) {\n+    if (fcntl(fd, F_GETFD) != -1) {\n+        JNU_ThrowByName(env, \"jdk\/crac\/impl\/CheckpointOpenFileException\", \"File descriptor is already open\");\n+    }\n+    \/\/ assert errno is EBADF?\n+    jboolean copy;\n+    const char *cpath = (*env)->GetStringUTFChars(env, path, &copy);\n+    int firstFd = open(cpath, flags);\n+    (*env)->ReleaseStringUTFChars(env, path, cpath);\n+    jboolean result = JNI_TRUE;\n+    if (firstFd < 0) {\n+        perror(\"CRaC: Failed to reopen file descriptor\");\n+        return JNI_FALSE;\n+    } else if (firstFd != fd) {\n+        if (dup2(firstFd, fd) < 0) {\n+            perror(\"CRaC: Failed to dup2 new file descriptor to original one\");\n+            result = JNI_FALSE;\n+        }\n+        if (close(firstFd) < 0) {\n+            perror(\"CRaC: failed to close opened file descriptor\");\n+        }\n+    }\n+    if (result && offset != 0 && lseek(fd, offset, SEEK_SET) < 0) {\n+        perror(\"CRaC: Failed to lseek reopened file descriptor\");\n+        close(fd);\n+        return JNI_FALSE;\n+    }\n+    return result;\n+}\n+\n+JNIEXPORT jboolean JNICALL\n+Java_java_io_FileDescriptor_reopenNull(JNIEnv *env, jobject obj, jint fd) {\n+    if (fcntl(fd, F_GETFD) != -1) {\n+        JNU_ThrowByName(env, \"jdk\/crac\/impl\/CheckpointOpenFileException\", \"File descriptor is already open\");\n+    }\n+    \/\/ assert errno is EBADF?\n+    int firstFd = open(\"\/dev\/null\", O_WRONLY);\n+    if (firstFd < 0) {\n+        perror(\"CRaC: Failed to reopen file descriptor using \/dev\/null\");\n+        return JNI_FALSE;\n+    } else if (firstFd == fd) {\n+        return JNI_TRUE;\n+    }\n+    jboolean result = JNI_TRUE;\n+    if (dup2(firstFd, fd) < 0) {\n+        perror(\"CRaC: Failed to dup2 new file descriptor to original one\");\n+        result = JNI_FALSE;\n+    }\n+    if (close(firstFd) < 0) {\n+        perror(\"CRaC: failed to close opened file descriptor\");\n+    }\n+    return result;\n+}\n+\n","filename":"src\/java.base\/unix\/native\/libjava\/FileDescriptor_md.c","additions":79,"deletions":1,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -81,0 +81,30 @@\n+JNIEXPORT jstring JNICALL\n+Java_java_io_FileDescriptor_getPath(JNIEnv *env, jobject obj) {\n+    return NULL;\n+}\n+\n+JNIEXPORT jstring JNICALL\n+Java_java_io_FileDescriptor_getType(JNIEnv *env, jobject obj) {\n+    return NULL;\n+}\n+\n+JNIEXPORT jlong JNICALL\n+Java_java_io_FileDescriptor_getOffset(JNIEnv *env, jobject obj) {\n+    return -1;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_java_io_FileDescriptor_getFlags(JNIEnv *env, jobject obj) {\n+    return -1;\n+}\n+\n+JNIEXPORT jboolean JNICALL\n+Java_java_io_FileDescriptor_reopen(JNIEnv *env, jobject obj, jint fd, jstring path, jint flags, jlong offset) {\n+    return JNI_FALSE;\n+}\n+\n+JNIEXPORT jboolean JNICALL\n+Java_java_io_FileDescriptor_reopenNull(JNIEnv *env, jobject obj, jint fd) {\n+    return JNI_FALSE;\n+}\n+\n","filename":"src\/java.base\/windows\/native\/libjava\/FileDescriptor_md.c","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.Core;\n+import jdk.crac.impl.OpenFDPolicies;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.util.concurrent.CountDownLatch;\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.crac.impl:+open\n+ * @build FDPolicyTestBase\n+ * @build CloseSocketTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class CloseSocketTest extends FDPolicyTestBase implements CracTest {\n+    @Override\n+    public void test() throws Exception {\n+        String checkpointPolicies = \"SOCKET=\" + OpenFDPolicies.BeforeCheckpoint.CLOSE;\n+        new CracBuilder()\n+                .javaOption(OpenFDPolicies.CHECKPOINT_PROPERTY, checkpointPolicies)\n+                .javaOption(OpenFDPolicies.RESTORE_PROPERTY, \"SOCKET=\" + OpenFDPolicies.AfterRestore.KEEP_CLOSED)\n+                .doCheckpointAndRestore();\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        ServerSocket serverSocket = new ServerSocket(0, 50, InetAddress.getLoopbackAddress());\n+        CountDownLatch latch = new CountDownLatch(1);\n+        Thread serverThread = new Thread(() -> {\n+            try {\n+                Socket socket = serverSocket.accept();\n+                latch.countDown();\n+            } catch (IOException e) {\n+                e.printStackTrace();\n+            }\n+        });\n+        serverThread.setDaemon(true);\n+        serverThread.start();\n+        Socket clientSocket = new Socket(InetAddress.getLoopbackAddress(), serverSocket.getLocalPort());\n+        latch.await();\n+        Core.checkpointRestore();\n+        System.out.println(\"Not much to do here\");\n+    }\n+\n+}\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/CloseSocketTest.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+import static jdk.test.lib.Asserts.assertGreaterThan;\n+\n+public abstract class FDPolicyTestBase {\n+\n+    protected void writeBigFile(Path path, String prefix, String suffix) throws IOException {\n+        StringBuilder sb = new StringBuilder().append(prefix);\n+        \/\/ Let's use 8+ MB file to avoid hidden buffering in FileInputStream or native parts\n+        for (int i = 0; i < 1024 * 1024; ++i) {\n+            sb.append(String.format(\"%08X\", 8 * i));\n+        }\n+        sb.append(suffix);\n+        Files.writeString(path, sb.toString());\n+    }\n+\n+    protected void readContents(FileReader reader) throws IOException {\n+        char[] bigbuf = new char[1024 * 1024];\n+        for (int count = 0; count < 8 * 1024 * 1024; ) {\n+            int r = reader.read(bigbuf);\n+            assertGreaterThan(r, 8);\n+            assertEquals(String.format(\"%08X\", count), new String(bigbuf, 0, 8));\n+            count += r;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/FDPolicyTestBase.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.Core;\n+import jdk.crac.impl.OpenFDPolicies;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+\n+import java.io.FileWriter;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.crac.impl:+open\n+ * @build ReopenAppendingTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class ReopenAppendingTest implements CracTest {\n+    @CracTestArg(optional = true)\n+    String tempFile;\n+\n+    @Override\n+    public void test() throws Exception {\n+        tempFile = Files.createTempFile(ReopenAppendingTest.class.getName(), \".txt\").toString();\n+        Path tempPath = Path.of(tempFile);\n+        try {\n+            String checkpointPolicies = tempFile + '=' + OpenFDPolicies.BeforeCheckpoint.CLOSE;\n+            CracBuilder builder = new CracBuilder();\n+            builder\n+                    .javaOption(OpenFDPolicies.CHECKPOINT_PROPERTY, checkpointPolicies)\n+                    .args(CracTest.args(tempFile));\n+            builder.doCheckpoint();\n+            assertEquals(\"Hello \", Files.readString(tempPath));\n+            builder.doRestore();\n+            assertEquals(\"Hello world!\", Files.readString(tempPath));\n+        } finally {\n+            Files.deleteIfExists(tempPath);\n+        }\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        try (var writer = new FileWriter(tempFile)) {\n+            writer.write(\"Hello \");\n+            writer.flush();\n+            Core.checkpointRestore();\n+            writer.write(\"world!\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/ReopenAppendingTest.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"},{"patch":"@@ -0,0 +1,99 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.Core;\n+import jdk.crac.impl.OpenFDPolicies;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracProcess;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.FileWriter;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.concurrent.CountDownLatch;\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.crac.impl:+open\n+ * @requires (os.family == \"linux\")\n+ * @build ReopenFifoTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class ReopenFifoTest implements CracTest {\n+    @CracTestArg(optional = true)\n+    String fifo;\n+\n+    @Override\n+    public void test() throws Exception {\n+        Path tempDirectory = Files.createTempDirectory(ReopenFifoTest.class.getName());\n+        Path pipePath = tempDirectory.resolve(\"pipe\");\n+        fifo = pipePath.toString();\n+        assertEquals(0, new ProcessBuilder().inheritIO().command(\"mkfifo\", fifo).start().waitFor());\n+\n+        \/\/ The socket part is here just to test parsing\n+        String checkpointPolicies = \"FIFO=\" + OpenFDPolicies.BeforeCheckpoint.CLOSE + File.pathSeparator + \"SOCKET=\" + OpenFDPolicies.BeforeCheckpoint.ERROR;\n+        CracBuilder builder = new CracBuilder()\n+                .javaOption(OpenFDPolicies.CHECKPOINT_PROPERTY, checkpointPolicies)\n+                .args(CracTest.args(fifo));\n+        CracProcess cp = builder.startCheckpoint();\n+\n+        try (var writer = new FileWriter(fifo)) {\n+            writer.write(\"Hello \");\n+            writer.flush();\n+            cp.waitForCheckpointed();\n+            CracProcess rp = builder.captureOutput(true).startRestore();\n+            CountDownLatch latch = new CountDownLatch(1);\n+            rp.watch(output -> {\n+                if (output.contains(\"RESTORED\")) {\n+                    latch.countDown();\n+                }\n+            }, error -> {});\n+            latch.await();\n+            writer.write(\"world!\");\n+            writer.flush();\n+            rp.waitForSuccess();\n+        } finally {\n+            Files.deleteIfExists(pipePath);\n+            Files.deleteIfExists(tempDirectory);\n+        }\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        try (var reader = new FileReader(fifo)) {\n+            char[] buf = new char[6];\n+            assertEquals(buf.length, reader.read(buf));\n+            assertEquals(\"Hello \", new String(buf));\n+            Core.checkpointRestore();\n+            System.out.println(\"RESTORED\");\n+            assertEquals(buf.length, reader.read(buf));\n+            assertEquals(\"world!\", new String(buf));\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/ReopenFifoTest.java","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.Core;\n+import jdk.crac.impl.OpenFDPolicies;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+\n+import java.io.FileReader;\n+import java.io.FileWriter;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.crac.impl:+open\n+ * @build FDPolicyTestBase\n+ * @build ReopenFileTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class ReopenFileTest extends FDPolicyTestBase implements CracTest {\n+    @CracTestArg(optional = true)\n+    String tempFile;\n+\n+    @Override\n+    public void test() throws Exception {\n+        tempFile = Files.createTempFile(ReopenFileTest.class.getName(), \".txt\").toString();\n+        String configFile = Files.createTempFile(ReopenFifoTest.class.getName(), \".cfg\").toString();\n+        try (var writer = new FileWriter(configFile)) {\n+            writer.write(\"\/some\/other\/file=ERROR\\n\");\n+            writer.write(tempFile + '=' + OpenFDPolicies.BeforeCheckpoint.CLOSE + \"\\n\");\n+            writer.write(\"**\/*.globpattern.test=CLOSE\");\n+        }\n+        Path tempPath = Path.of(tempFile);\n+        try {\n+            writeBigFile(tempPath, \"Hello \", \"world!\");\n+            new CracBuilder()\n+                    .javaOption(OpenFDPolicies.CHECKPOINT_PROPERTY + \".file\", configFile)\n+                    .args(CracTest.args(tempFile)).doCheckpointAndRestore();\n+        } finally {\n+            Files.deleteIfExists(tempPath);\n+            Files.deleteIfExists(Path.of(configFile));\n+        }\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        try (var reader = new FileReader(tempFile)) {\n+            char[] buf = new char[6];\n+            assertEquals(buf.length, reader.read(buf));\n+            assertEquals(\"Hello \", new String(buf));\n+            Core.checkpointRestore();\n+            readContents(reader);\n+            assertEquals(buf.length, reader.read(buf));\n+            assertEquals(\"world!\", new String(buf));\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/ReopenFileTest.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.Core;\n+import jdk.crac.impl.OpenFDPolicies;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracProcess;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+\n+import java.io.FileReader;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.crac.impl:+open\n+ * @build FDPolicyTestBase\n+ * @build ReopenOtherTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class ReopenOtherTest extends FDPolicyTestBase implements CracTest {\n+    @CracTestArg(value = 0, optional = true)\n+    String helloWorld;\n+\n+    @CracTestArg(value = 1, optional = true)\n+    String nazdarSvete;\n+\n+    @Override\n+    public void test() throws Exception {\n+        helloWorld = Files.createTempFile(ReopenOtherTest.class.getName(), \".txt\").toString();\n+        nazdarSvete = Files.createTempFile(ReopenOtherTest.class.getName(), \".txt\").toString();\n+        Path hwPath = Path.of(helloWorld);\n+        Path nsPath = Path.of(nazdarSvete);\n+        try {\n+            writeBigFile(hwPath, \"Hello \", \"world!\");\n+            writeBigFile(nsPath, \"Nazdar\", \"svete!\");\n+            String checkpointPolicies = helloWorld + '=' + OpenFDPolicies.BeforeCheckpoint.WARN_CLOSE;\n+            String restorePolicies = helloWorld + '=' + OpenFDPolicies.AfterRestore.OPEN_OTHER + '=' + nazdarSvete;\n+            CracBuilder builder = new CracBuilder()\n+                    .captureOutput(true)\n+                    .javaOption(OpenFDPolicies.CHECKPOINT_PROPERTY, checkpointPolicies)\n+                    .javaOption(OpenFDPolicies.RESTORE_PROPERTY, restorePolicies)\n+                    .args(CracTest.args(helloWorld));\n+            CracProcess cp = builder.startCheckpoint();\n+            cp.waitForCheckpointed();\n+            cp.outputAnalyzer().stderrShouldContain(\"was not closed by the application\");\n+            builder.captureOutput(false).doRestore();\n+        } finally {\n+            Files.deleteIfExists(hwPath);\n+            Files.deleteIfExists(nsPath);\n+        }\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        try (var reader = new FileReader(helloWorld)) {\n+            char[] buf = new char[6];\n+            assertEquals(buf.length, reader.read(buf));\n+            assertEquals(\"Hello \", new String(buf));\n+            Core.checkpointRestore();\n+            readContents(reader);\n+            assertEquals(buf.length, reader.read(buf));\n+            assertEquals(\"svete!\", new String(buf));\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/ReopenOtherTest.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"}]}