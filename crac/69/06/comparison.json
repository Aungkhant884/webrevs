{"files":[{"patch":"@@ -6113,0 +6113,4 @@\n+  if (!ok && CRPauseOnCheckpointError) {\n+    os::message_box(\"Checkpoint failed\", \"Errors were found during checkpoint.\");\n+  }\n+\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2133,0 +2133,4 @@\n+                                                                            \\\n+  product(bool, CRPauseOnCheckpointError, false, DIAGNOSTIC,                \\\n+      \"Pauses the checkpoint when a problem is found on VM level.\")\n+\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,0 +32,2 @@\n+import jdk.crac.impl.OpenFilePolicies;\n+import jdk.crac.impl.OpenSocketPolicies;\n@@ -70,8 +72,9 @@\n-                claimedFDs.claimFd(self, self, () ->  {\n-                    if (self == in || self == out || self == err) {\n-                        return null;\n-                    }\n-                    return new CheckpointOpenResourceException(\n-                        FileDescriptor.class.getSimpleName() + \" \" + fd + \": \" + nativeDescription0(),\n-                        getStackTraceHolder());\n-                });\n+                \/\/ Normally the claiming should be overridden by FileInputStream\/FileOutputStream\n+                \/\/ but in case these are collected we handle FDs 0..2 here as well.\n+                if (self == in || self == out || self == err) {\n+                    claimedFDs.claimFd(self, self, null);\n+                }\n+\n+                claimedFDs.claimFd(self, self, () -> new CheckpointOpenResourceException(\n+                    FileDescriptor.class.getSimpleName() + \" \" + fd + \": \" + nativeDescription0(),\n+                    getStackTraceHolder()));\n@@ -96,0 +99,1 @@\n+        OpenFilePolicies.ensureRegistered();\n@@ -127,0 +131,5 @@\n+                    @Override\n+                    public void closeNoCleanup(FileDescriptor fdo) throws IOException {\n+                        fdo.close0();\n+                    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/io\/FileDescriptor.java","additions":17,"deletions":8,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -30,0 +30,3 @@\n+import java.util.function.Supplier;\n+\n+import jdk.internal.crac.JDKFileResource;\n@@ -519,0 +522,17 @@\n+    @SuppressWarnings(\"unused\")\n+    private final JDKFileResource resource = new JDKFileResource(this) {\n+        @Override\n+        protected FileDescriptor getFD() {\n+            return fd;\n+        }\n+\n+        @Override\n+        protected Supplier<Exception> claimException(FileDescriptor fd, String path) {\n+            if (fd == FileDescriptor.in) {\n+                return null;\n+            } else {\n+                return super.claimException(fd, path);\n+            }\n+        }\n+    };\n+\n","filename":"src\/java.base\/share\/classes\/java\/io\/FileInputStream.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import java.util.function.Supplier;\n+\n@@ -460,1 +462,2 @@\n-    JDKFileResource resource = new JDKFileResource() {\n+    @SuppressWarnings(\"unused\")\n+    private final JDKFileResource resource = new JDKFileResource(this) {\n@@ -467,2 +470,6 @@\n-        protected String getPath() {\n-            return path;\n+        protected Supplier<Exception> claimException(FileDescriptor fd, String path) {\n+            if (fd == FileDescriptor.out || fd == FileDescriptor.err) {\n+                return null;\n+            } else {\n+                return super.claimException(fd, path);\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/io\/FileOutputStream.java","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-    JDKFileResource resource = new JDKFileResource() {\n+    private final JDKFileResource resource = new JDKFileResource(this) {\n@@ -89,5 +89,0 @@\n-\n-        @Override\n-        protected String getPath() {\n-            return path;\n-        }\n","filename":"src\/java.base\/share\/classes\/java\/io\/RandomAccessFile.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -38,0 +38,2 @@\n+\n+import jdk.internal.crac.JDKFileResource;\n@@ -712,0 +714,7 @@\n+        @SuppressWarnings(\"unused\")\n+        final JDKFileResource resource = new JDKFileResource(this) {\n+            @Override\n+            protected FileDescriptor getFD() {\n+                return fd;\n+            }\n+        };\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ProcessBuilder.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -35,0 +35,2 @@\n+\n+import jdk.crac.impl.OpenSocketPolicies;\n@@ -1450,0 +1452,3 @@\n+    static {\n+        OpenSocketPolicies.ensureRegistered();\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/net\/DatagramSocket.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import jdk.internal.crac.JDKSocketResource;\n+\n@@ -75,0 +77,4 @@\n+    \/\/ We don't know the protocol family when this socket is created and FD allocated, but it's not UNIX\n+    @SuppressWarnings(\"unused\")\n+    private final JDKSocketResource resource = new JDKSocketResource(this, StandardProtocolFamily.INET, () -> fd);\n+\n","filename":"src\/java.base\/share\/classes\/java\/net\/DatagramSocketImpl.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.crac.impl.OpenSocketPolicies;\n@@ -131,0 +132,1 @@\n+        OpenSocketPolicies.ensureRegistered();\n","filename":"src\/java.base\/share\/classes\/java\/net\/Socket.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,6 +37,1 @@\n-import jdk.crac.Context;\n-import jdk.crac.Resource;\n-import jdk.crac.impl.CheckpointOpenSocketException;\n-import jdk.internal.crac.Core;\n-import jdk.internal.crac.ClaimedFDs;\n-import jdk.internal.crac.JDKFdResource;\n+import jdk.internal.crac.JDKSocketResource;\n@@ -113,16 +108,2 @@\n-    private class SocketResource extends JDKFdResource {\n-        @Override\n-        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n-            ClaimedFDs claimedFDs = Core.getClaimedFDs();\n-            SocketImpl socket = SocketImpl.this;\n-            claimedFDs.claimFd(\n-                fd,\n-                socket,\n-                () -> new CheckpointOpenSocketException(\n-                    socket.toString(),\n-                    getStackTraceHolder()),\n-                fd);\n-        }\n-    };\n-\n-    private final SocketResource socketResource = new SocketResource();\n+    @SuppressWarnings(\"unused\")\n+    private final JDKSocketResource resource = new JDKSocketResource(this, StandardProtocolFamily.INET, () -> fd);\n","filename":"src\/java.base\/share\/classes\/java\/net\/SocketImpl.java","additions":3,"deletions":22,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import jdk.crac.impl.OpenSocketPolicies;\n+\n@@ -395,0 +397,4 @@\n+\n+    static {\n+        OpenSocketPolicies.ensureRegistered();\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/ServerSocketChannel.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import jdk.crac.impl.OpenSocketPolicies;\n+\n@@ -672,0 +674,4 @@\n+\n+    static {\n+        OpenSocketPolicies.ensureRegistered();\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/SocketChannel.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,239 @@\n+package jdk.crac.impl;\n+\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKResource;\n+import jdk.internal.crac.LoggerContainer;\n+\n+import java.nio.file.FileSystems;\n+import java.nio.file.Path;\n+import java.nio.file.PathMatcher;\n+import java.util.*;\n+\n+public class OpenFilePolicies<P> {\n+    public static final String CHECKPOINT_PROPERTY = \"jdk.crac.file-policy.checkpoint\";\n+    public static final String RESTORE_PROPERTY = \"jdk.crac.file-policy.restore\";\n+    public static final String FIFO = \"FIFO\";\n+\n+    public static final OpenFilePolicies<BeforeCheckpoint> CHECKPOINT =\n+            new OpenFilePolicies<>(BeforeCheckpoint.ERROR);\n+    public static final OpenFilePolicies<AfterRestorePolicy> RESTORE =\n+            new OpenFilePolicies<>(new AfterRestorePolicy(AfterRestore.REOPEN_OR_ERROR, null));\n+\n+    private static final JDKResource resource = new JDKResource() {\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) {\n+            CHECKPOINT.clear();\n+            loadCheckpointPolicies();\n+            RESTORE.clear();\n+        }\n+\n+        @Override\n+        public void afterRestore(Context<? extends Resource> context) {\n+        }\n+    };\n+\n+    private final P defaultPolicy;\n+    private boolean loaded;\n+    private final Map<Integer, P> numericPolicies = new HashMap<>();\n+    private final List<Map.Entry<PathMatcher, P>> pathPolicies = new ArrayList<>();\n+    private P fifoPolicy;\n+\n+    static {\n+        \/\/ This static ctor runs too early to invoke loadCheckpointPolicies directly\n+        Core.Priority.NORMAL.getContext().register(resource);\n+    }\n+\n+    private synchronized static void loadCheckpointPolicies() {\n+        PolicyUtils.loadProperties(\"checkpoint\", CHECKPOINT_PROPERTY).forEach((key, value) -> {\n+            BeforeCheckpoint policy;\n+            try {\n+                policy = BeforeCheckpoint.valueOf(value.toString());\n+            } catch (IllegalArgumentException e) {\n+                throw new IllegalArgumentException(String.format(\n+                        \"Invalid value of policy %s for target %s; valid values are: %s\",\n+                        value, key, Arrays.toString(BeforeCheckpoint.values())));\n+            }\n+            CHECKPOINT.setPolicy(key.toString(), value, policy);\n+        });\n+        CHECKPOINT.loaded = true;\n+    }\n+\n+    private synchronized static void loadRestorePolicies() {\n+        AfterRestore[] policies = AfterRestore.values();\n+        PolicyUtils.loadProperties(\"restore\", RESTORE_PROPERTY).forEach((key, value) -> {\n+            String pstr = value.toString();\n+            int eqIndex = pstr.indexOf('=');\n+            String policyName = eqIndex < 0 ? pstr : pstr.substring(0, eqIndex);\n+            AfterRestore type = Arrays.stream(policies).filter(p -> policyName.equals(p.name())).findAny().orElse(null);\n+            if (type == null) {\n+                throw new IllegalArgumentException(String.format(\n+                        \"Invalid value of restore policy %s for target %s; valid values are: %s\",\n+                        value, key, Arrays.toString(AfterRestore.values())));\n+            }\n+            AfterRestorePolicy policy;\n+            switch (type) {\n+                case OPEN_OTHER:\n+                    \/\/ we add + 2 because we need the equal sign and at least one character for the path\n+                    if (pstr.length() < type.name().length() + 2) {\n+                        throw new IllegalArgumentException(String.format(\n+                                \"Invalid specification for policy %s for target %s: \" +\n+                                \"Policy name should be followed by an equal sign '=' and then the path.\", type, key));\n+                    } else {\n+                        policy = new AfterRestorePolicy(type, PolicyUtils.unescape(pstr, type.name().length() + 1, pstr.length()));\n+                    }\n+                    break;\n+                default:\n+                    policy = new AfterRestorePolicy(type, null);\n+            }\n+            RESTORE.setPolicy(key.toString(), value, policy);\n+        });\n+        RESTORE.loaded = true;\n+    }\n+\n+    public OpenFilePolicies(P defaultPolicy) {\n+        this.defaultPolicy = defaultPolicy;\n+        this.fifoPolicy = defaultPolicy;\n+    }\n+\n+    private void clear() {\n+        this.numericPolicies.clear();\n+        this.pathPolicies.clear();\n+        this.loaded = false;\n+        this.fifoPolicy = defaultPolicy;\n+    }\n+\n+    public static void ensureRegistered() {\n+        \/\/ Noop - this method is invoked to ensure that static constructor was invoked\n+    }\n+\n+    private void setPolicy(String key, Object value, P policy) {\n+        if (FIFO.equals(key)) {\n+            fifoPolicy = policy;\n+        } else if (PolicyUtils.NUMERIC.matcher(key).matches()) {\n+            int fd = Integer.parseInt(key);\n+            P prev = numericPolicies.putIfAbsent(fd, policy);\n+            if (prev != null) {\n+                LoggerContainer.error(\"Duplicate policy for file descriptor {0}; policy {1} will be ignored.\", fd, value);\n+            }\n+        } else {\n+            pathPolicies.add(Map.entry(\n+                    FileSystems.getDefault().getPathMatcher(\"glob:\" + key), policy));\n+        }\n+    }\n+\n+    public P get(int fd, String path, String type) {\n+        synchronized (OpenFilePolicies.this) {\n+            if (!loaded) {\n+                \/\/ We could use a Runnable but method references don't work\n+                \/\/ when the static ctor is invoked\n+                if (this == CHECKPOINT) {\n+                    loadCheckpointPolicies();\n+                } else {\n+                    loadRestorePolicies();\n+                }\n+            }\n+        }\n+        P policy = numericPolicies.get(fd);\n+        if (policy != null) {\n+            return policy;\n+        }\n+        if (path != null) {\n+            Path p = Path.of(path);\n+            for (var entry : pathPolicies) {\n+                if (entry.getKey().matches(p)) {\n+                    return entry.getValue();\n+                }\n+            }\n+        }\n+        if (\"fifo\".equals(type) && fd > 2) {\n+            return fifoPolicy;\n+        }\n+        return defaultPolicy;\n+    }\n+\n+    \/**\n+     * Defines a treatment of file found open during checkpoint.\n+     *\/\n+    public enum BeforeCheckpoint {\n+        \/**\n+         * The checkpoint fails with an appropriate error message. This is the\n+         * default as it is safer to force applications handle the checkpoint,\n+         * the options below are meant as workarounds when this is not feasible.\n+         *\/\n+        ERROR,\n+        \/**\n+         * The file will be silently closed. The original path will\n+         * be recorded and after restore this will be subject to treatment based\n+         * on the {@link AfterRestore} policy.\n+         *\/\n+        CLOSE,\n+        \/**\n+         * The behaviour is identical to {@link #CLOSE} but the application\n+         * will print out a warning message to the standard error.\n+         *\/\n+        WARN_CLOSE,\n+        \/\/ TODO: for no-downtime replication (scaling up) a strategy that would\n+        \/\/  keep the descriptor open when the checkpointed process is left\n+        \/\/  running might be useful.\n+    }\n+\n+    \/**\n+     * Defines what to do with file descriptors closed by the\n+     * {@link BeforeCheckpoint} policy after restore from a checkpoint.\n+     *\/\n+    public enum AfterRestore {\n+        \/**\n+         * The file is reopened; if the file was opened in append mode it is\n+         * opened at the end, otherwise it is opened at the original position.\n+         * If it cannot be opened (e.g. the file is not on the filesystem\n+         * anymore or the process has insufficient permissions) an error is\n+         * printed and the checkpoint throws an exception.\n+         * When the file does not exist this is treated as an error even if\n+         * it was previously opened with flags supporting creation.\n+         * This is the default behaviour.\n+         *\/\n+        REOPEN_OR_ERROR,\n+        \/**\n+         * The file is reopened. If it cannot be opened (e.g. the file\n+         * is missing or the process has insufficient permissions) a \/dev\/null\n+         * device is opened instead (allowing the process to write any data and\n+         * immediately returning EOF when reading).\n+         *\/\n+        REOPEN_OR_NULL,\n+        \/**\n+         * After restore another file specified as part of the policy\n+         * declaration is opened instead; the policy name should be followed\n+         * by an equal sign '=' and the new path.\n+         * If the file was opened in append mode the new file is opened at the end;\n+         * otherwise it is opened at the same position.\n+         * The file must be present; a non-existent file is treated as an error.\n+         * If the other file cannot be open the checkpoint throws an exception.\n+         *\/\n+        OPEN_OTHER,\n+        \/**\n+         * Do not do anything with the closed file; this will probably result\n+         * in runtime errors if the resource is used.\n+         *\/\n+        KEEP_CLOSED\n+    }\n+\n+    public static class AfterRestorePolicy {\n+        public final AfterRestore type;\n+        public final String param;\n+\n+        private AfterRestorePolicy(AfterRestore type, String param) {\n+            this.type = type;\n+            this.param = param;\n+        }\n+    }\n+\n+    public static class RestoreFileDescriptorException extends Exception {\n+        public static final long serialVersionUID = -8790346029973354266L;\n+\n+        public RestoreFileDescriptorException(String message) {\n+            super(message);\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/impl\/OpenFilePolicies.java","additions":239,"deletions":0,"binary":false,"changes":239,"status":"added"},{"patch":"@@ -0,0 +1,351 @@\n+package jdk.crac.impl;\n+\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKResource;\n+import jdk.internal.crac.LoggerContainer;\n+\n+import java.net.*;\n+import java.util.*;\n+import java.util.regex.Pattern;\n+\n+import static jdk.crac.impl.PolicyUtils.unescape;\n+\n+public class OpenSocketPolicies<P> {\n+    public static final String CHECKPOINT_PROPERTY = \"jdk.crac.socket-policy.checkpoint\";\n+    public static final String RESTORE_PROPERTY = \"jdk.crac.socket-policy.restore\";\n+\n+    public static final OpenSocketPolicies<BeforeCheckpoint> CHECKPOINT =\n+            new OpenSocketPolicies<>(BeforeCheckpoint.ERROR);\n+    public static final OpenSocketPolicies<AfterRestorePolicy> RESTORE =\n+            new OpenSocketPolicies<>(new AfterRestorePolicy(AfterRestore.REOPEN_OR_ERROR, null, null));\n+\n+    private static Pattern NUMERIC;\n+    private static final JDKResource resource = new JDKResource() {\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) {\n+            CHECKPOINT.clear();\n+            \/\/ We need to s\n+            loadCheckpointPolicies();\n+            RESTORE.clear();\n+        }\n+\n+        @Override\n+        public void afterRestore(Context<? extends Resource> context) {\n+        }\n+    };\n+\n+    private final P defaultPolicy;\n+    private boolean loaded;\n+    private final Map<Integer, P> numericPolicies = new HashMap<>();\n+    private final List<AddressPolicy<P>> addressPolicies = new ArrayList<>();\n+\n+    static {\n+        \/\/ This static ctor runs too early to invoke loadCheckpointPolicies directly\n+        Core.Priority.NORMAL.getContext().register(resource);\n+    }\n+\n+    private synchronized static void loadCheckpointPolicies() {\n+        \/\/ We cannot initialize this in static constructor as this is invoked too early\n+        if (NUMERIC == null) {\n+            NUMERIC = Pattern.compile(\"[0-9]+\");\n+        }\n+        PolicyUtils.loadProperties(\"checkpoint\", CHECKPOINT_PROPERTY).forEach((key, value) -> {\n+            BeforeCheckpoint policy;\n+            try {\n+                policy = BeforeCheckpoint.valueOf(value.toString());\n+            } catch (IllegalArgumentException e) {\n+                LoggerContainer.error(\"Invalid value of policy '{0}' for target {1}; valid values are: {2}\",\n+                        value, key, Arrays.toString(BeforeCheckpoint.values()));\n+                return;\n+            }\n+            CHECKPOINT.setPolicy(key.toString(), value, policy);\n+        });\n+        CHECKPOINT.addressPolicies.sort(Comparator.comparing(AddressPolicy::priority));\n+        CHECKPOINT.loaded = true;\n+    }\n+\n+    private synchronized static void loadRestorePolicies() {\n+        AfterRestore[] policies = AfterRestore.values();\n+        PolicyUtils.loadProperties(\"restore\", RESTORE_PROPERTY).forEach((key, value) -> {\n+            String pstr = value.toString();\n+            int eqIndex = pstr.indexOf('=');\n+            String policyName = eqIndex < 0 ? pstr : pstr.substring(0, eqIndex);\n+            AfterRestore type = Arrays.stream(policies).filter(p -> policyName.equals(p.name())).findAny().orElse(null);\n+            if (type == null) {\n+                throw new IllegalArgumentException(String.format(\n+                        \"Invalid value of restore policy %s for target %s; valid values are: %s\",\n+                        value, key, Arrays.toString(AfterRestore.values())));\n+            }\n+            AfterRestorePolicy policy;\n+            if (type == AfterRestore.OPEN_OTHER) {\n+                \/\/ we add + 2 because we need the equal sign and at least one character for the path\n+                if (pstr.length() < type.name().length() + 2) {\n+                    throw new IllegalArgumentException(String.format(\n+                            \"Invalid specification for policy %s for target %s: \" +\n+                            \"Policy name should be followed by an equal sign '=' and then the local,remote addresses.\",\n+                            type, key));\n+                } else {\n+                    \/\/ The address in key (for matching) got unescaped in loadProperties, so in general\n+                    \/\/ the addresses must not contain comma anyway, but we'll try anyway.\n+                    int begin = type.name().length() + 1;\n+                    int comma = PolicyUtils.findNonEscaped(pstr, begin, ',');\n+                    SocketAddress local, remote = null;\n+                    if (comma < 0) {\n+                        local = parseAddress(unescape(pstr, begin, pstr.length()));\n+                    } else {\n+                        local = parseAddress(unescape(pstr, begin, comma));\n+                        remote = parseAddress(unescape(pstr, comma + 1, pstr.length()));\n+                    }\n+                    policy = new AfterRestorePolicy(type, local, remote);\n+                }\n+            } else {\n+                policy = new AfterRestorePolicy(type, null, null);\n+            }\n+            RESTORE.setPolicy(key.toString(), value, policy);\n+        });\n+        RESTORE.loaded = true;\n+    }\n+\n+    public OpenSocketPolicies(P defaultPolicy) {\n+        this.defaultPolicy = defaultPolicy;\n+    }\n+\n+    private void clear() {\n+        this.numericPolicies.clear();\n+        this.addressPolicies.clear();\n+        this.loaded = false;\n+    }\n+\n+    public static void ensureRegistered() {\n+        \/\/ Noop - this method is invoked to ensure that static constructor was invoked\n+    }\n+\n+    private void setPolicy(String key, Object value, P policy) {\n+        if (NUMERIC.matcher(key).matches()) {\n+            int fd = Integer.parseInt(key);\n+            P prev = numericPolicies.putIfAbsent(fd, policy);\n+            if (prev != null) {\n+                LoggerContainer.error(\"Duplicate policy for file descriptor {0}; policy {1} will be ignored.\", fd, value);\n+            }\n+        } else {\n+            int comma = key.indexOf(',');\n+            String localStr = key, remoteStr = null;\n+            if (comma >= 0) {\n+                localStr = key.substring(0, comma);\n+                remoteStr = key.substring(comma + 1);\n+            }\n+            SocketAddress local = parseAddress(localStr);\n+            SocketAddress remote = parseAddress(remoteStr);\n+            addressPolicies.add(new AddressPolicy<>(local, remote, policy));\n+        }\n+    }\n+\n+    \/\/ This will return UnixDomainSocketAddress when we can't parse it\n+    \/\/ which will result in no match later on\n+    private static SocketAddress parseAddress(String str) {\n+        if (str == null || str.isBlank()) {\n+            return null;\n+        }\n+        str = str.trim();\n+        if (\"*\".equals(str)) {\n+            return null;\n+        }\n+        int colonIndex = str.lastIndexOf(':');\n+        if (colonIndex < 0) {\n+            \/\/ unix path or only IP (wildcard port)\n+            try {\n+                return new InetSocketAddress(InetAddress.getByName(str), 0);\n+            } catch (UnknownHostException e) {\n+                return UnixDomainSocketAddress.of(str);\n+            }\n+        } else {\n+            try {\n+                String portPart = str.substring(colonIndex + 1).trim();\n+                int port;\n+                if (portPart.isEmpty() || \"*\".equals(portPart)) {\n+                    port = 0;\n+                } else {\n+                    port = Integer.parseInt(portPart);\n+                    if (port < 0 || port > 0xFFFF) {\n+                        \/\/ probably malformed address?\n+                        return UnixDomainSocketAddress.of(str);\n+                    }\n+                }\n+                String addressPart = str.substring(0, colonIndex).trim();\n+                if (addressPart.isEmpty() || \"*\".equals(addressPart)) {\n+                    if (port == 0) {\n+                        return null;\n+                    } else {\n+                        return new WildcardInetAddress(port);\n+                    }\n+                }\n+                return new InetSocketAddress(InetAddress.getByName(addressPart), port);\n+            } catch (NumberFormatException ignored) {\n+                \/\/ doesn't look like a port -> unix domain socket to C:\\ or something like that?\n+            } catch (UnknownHostException e) {\n+                \/\/ address cannot be resolved\n+            }\n+        }\n+        return UnixDomainSocketAddress.of(str);\n+    }\n+\n+    public P get(int fd, SocketAddress local, SocketAddress remote) {\n+        synchronized (OpenSocketPolicies.this) {\n+            if (!loaded) {\n+                \/\/ We could use a Runnable but method references don't work\n+                \/\/ when the static ctor is invoked\n+                if (this == CHECKPOINT) {\n+                    loadCheckpointPolicies();\n+                } else {\n+                    loadRestorePolicies();\n+                }\n+            }\n+        }\n+        P policy = numericPolicies.get(fd);\n+        if (policy != null) {\n+            return policy;\n+        }\n+        for (var addressPolicy : addressPolicies) {\n+            LoggerContainer.error(\"test {0} = {1} && {2} = {3}\", addressPolicy.local, local, addressPolicy.remote, remote);\n+            if (matches(addressPolicy.local, local) && matches(addressPolicy.remote, remote)) {\n+                return addressPolicy.policy;\n+            }\n+        }\n+        return defaultPolicy;\n+    }\n+\n+    private boolean matches(SocketAddress config, SocketAddress actual) {\n+        \/\/ Note: null local address as parameter (unbound) does match only to wildcard (null)\n+        if (config == null || config.equals(actual)) {\n+            return true;\n+        }\n+        if (config instanceof InetSocketAddress && actual instanceof InetSocketAddress) {\n+            InetAddress cfgAddress = ((InetSocketAddress) config).getAddress();\n+            return ((InetSocketAddress) config).getPort() == 0 && cfgAddress.equals(((InetSocketAddress) actual).getAddress());\n+        } else if (config instanceof WildcardInetAddress && actual instanceof InetSocketAddress) {\n+            return ((WildcardInetAddress) config).port == ((InetSocketAddress) actual).getPort();\n+        }\n+        return false;\n+    }\n+\n+    \/**\n+     * Defines a treatment of socket found open during checkpoint.\n+     *\/\n+    public enum BeforeCheckpoint {\n+        \/**\n+         * The checkpoint fails with an appropriate error message. This is the\n+         * default as it is safer to force applications handle the checkpoint,\n+         * the options below are meant as workarounds when this is not feasible.\n+         *\/\n+        ERROR,\n+        \/**\n+         * The socket will be silently closed. After restore this socket will\n+         * be subject to treatment based on the {@link AfterRestore} policy.\n+         *\/\n+        CLOSE,\n+        \/**\n+         * The behaviour is identical to {@link #CLOSE} but the application\n+         * will print out a warning message to the standard error.\n+         *\/\n+        WARN_CLOSE,\n+        \/\/ TODO: for no-downtime replication (scaling up) a strategy that would\n+        \/\/  keep the socket open when the checkpointed process is left\n+        \/\/  running might be useful.\n+    }\n+\n+    \/**\n+     * Defines what to do with the sockets closed by the\n+     * {@link BeforeCheckpoint} policy after restore from a checkpoint.\n+     *\/\n+    public enum AfterRestore {\n+        \/**\n+         * The socket is reopened. If it cannot be opened (e.g. it was not\n+         * a connection-less socket or the IP it was bound to is not present)\n+         * an error is printed and the checkpoint throws an exception.\n+         * This is the default behaviour.\n+         *\/\n+        REOPEN_OR_ERROR,\n+        \/**\n+         * After restore the socket is reopened but both the local and remote\n+         * address can be changed. These are specified as part of the policy\n+         * declaration: the policy name should be followed by an equal sign '=',\n+         * new local address, comma, and new remote address. The remote address\n+         * (and preceding comma) are optional.\n+         *\/\n+        OPEN_OTHER,\n+        \/**\n+         * Do not do anything with the closed socket; this will probably result\n+         * in runtime errors if the resource is used.\n+         *\/\n+        KEEP_CLOSED\n+    }\n+\n+    public static class AfterRestorePolicy {\n+        public final AfterRestore type;\n+        public final SocketAddress local;\n+        public final SocketAddress remote;\n+\n+        private AfterRestorePolicy(AfterRestore type, SocketAddress local, SocketAddress remote) {\n+            this.type = type;\n+            this.local = local;\n+            this.remote = remote;\n+        }\n+    }\n+\n+    public static class RestoreFileDescriptorException extends Exception {\n+        public static final long serialVersionUID = -8790346029973354266L;\n+\n+        public RestoreFileDescriptorException(String message) {\n+            super(message);\n+        }\n+    }\n+\n+    private static class AddressPolicy<P> {\n+        final SocketAddress local;\n+        final SocketAddress remote;\n+        final P policy;\n+\n+        public AddressPolicy(SocketAddress local, SocketAddress remote, P policy) {\n+            this.local = local;\n+            this.remote = remote;\n+            this.policy = policy;\n+        }\n+\n+        \/\/ for sorting from the most specific to the least specific\n+        public int priority() {\n+            if (local != null && remote != null) {\n+                if (!hasWildcardPort(local) && !hasWildcardPort(remote)) {\n+                    return 0;\n+                } else if (!hasWildcardPort(remote)) {\n+                    return 1;\n+                } else if (!hasWildcardPort(local)) {\n+                    return 2;\n+                } else {\n+                    return 3;\n+                }\n+            } else if (remote != null) {\n+                return hasWildcardPort(remote) ? 5 : 4;\n+            } else if (local != null) {\n+                return hasWildcardPort(local) ? 7 : 6;\n+            } else {\n+                return 8;\n+            }\n+        }\n+    }\n+\n+    private static boolean hasWildcardPort(SocketAddress addr) {\n+        return addr instanceof InetSocketAddress && ((InetSocketAddress) addr).getPort() == 0;\n+    }\n+\n+    private static class WildcardInetAddress extends SocketAddress {\n+        public static final long serialVersionUID = 8541345859974104981L;\n+\n+        final int port;\n+\n+        private WildcardInetAddress(int port) {\n+            this.port = port;\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/impl\/OpenSocketPolicies.java","additions":351,"deletions":0,"binary":false,"changes":351,"status":"added"},{"patch":"@@ -0,0 +1,78 @@\n+package jdk.crac.impl;\n+\n+import sun.security.action.GetPropertyAction;\n+\n+import java.io.FileInputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Properties;\n+import java.util.regex.Pattern;\n+\n+final class PolicyUtils {\n+    static Pattern NUMERIC = Pattern.compile(\"[0-9]+\");\n+\n+    private PolicyUtils() {}\n+\n+    static Properties loadProperties(String type, String systemProperty) {\n+        Properties properties = new Properties();\n+        String file = GetPropertyAction.privilegedGetProperty(systemProperty + \".file\");\n+        if (file != null) {\n+            try {\n+                if (file.length() >= 4 && file.substring(file.length() - 4).equalsIgnoreCase(\".xml\")) {\n+                    try (var fis = new FileInputStream(file)) {\n+                        properties.loadFromXML(fis);\n+                    }\n+                } else {\n+                    try (var fr = new FileReader(file, StandardCharsets.UTF_8)) {\n+                        properties.load(fr);\n+                    }\n+                }\n+            } catch (IOException e) {\n+                throw new RuntimeException(String.format(\n+                        \"Failed to read %s policies from %s: %s\", type, file, e.getMessage()));\n+            }\n+        }\n+        String property = GetPropertyAction.privilegedGetProperty(systemProperty);\n+        if (property != null) {\n+            for (var item : property.split(\";\")) {\n+                int eqIndex = findNonEscaped(item, 0, '=');\n+                if (eqIndex < 0) {\n+                    throw new IllegalArgumentException(String.format(\n+                            \"Invalid specification for %s policy: %s\", type, item));\n+                } else {\n+                    properties.put(unescape(item, 0, eqIndex), item.substring(eqIndex + 1));\n+                }\n+            }\n+        }\n+        return properties;\n+    }\n+\n+    static String unescape(String str, int fromIndex, int toIndex) {\n+        boolean escaped = false;\n+        StringBuilder sb = new StringBuilder(str.length() - fromIndex);\n+        for (int i = fromIndex; i < toIndex; ++i) {\n+            char c = str.charAt(i);\n+            if (!escaped && c == '\\\\') {\n+                escaped = true;\n+            } else {\n+                sb.append(c);\n+                escaped = false;\n+            }\n+        }\n+        return sb.toString();\n+    }\n+\n+    static int findNonEscaped(String str, int fromIndex, char character) {\n+        boolean escaped = false;\n+        for (int i = fromIndex; i < str.length(); ++i) {\n+            char c = str.charAt(i);\n+            if (c == '\\\\') {\n+                escaped = !escaped;\n+            } else if (c == character && !escaped) {\n+                return i;\n+            }\n+        }\n+        return -1;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/impl\/PolicyUtils.java","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -43,0 +43,1 @@\n+    public void closeNoCleanup(FileDescriptor fileDescriptor) throws IOException;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaIOFileDescriptorAccess.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -74,0 +74,5 @@\n+\n+        @Override\n+        public String toString() {\n+            return \"{fd=\" + fd + \", claimer=\" + claimer + '}';\n+        }\n@@ -91,2 +96,0 @@\n-        Objects.requireNonNull(supplier);\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/ClaimedFDs.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -6,0 +6,3 @@\n+import jdk.crac.impl.OpenFilePolicies;\n+import jdk.internal.access.JavaIOFileDescriptorAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -10,0 +13,1 @@\n+import java.io.IOException;\n@@ -13,0 +17,3 @@\n+    private static final JavaIOFileDescriptorAccess fdAccess =\n+            SharedSecrets.getJavaIOFileDescriptorAccess();\n+\n@@ -17,0 +24,11 @@\n+    private final Object owner;\n+    private int originalFd = -1;\n+    private String originalPath;\n+    private String originalType;\n+    private int originalFlags;\n+    private long originalOffset;\n+\n+    protected JDKFileResource(Object owner) {\n+        this.owner = owner;\n+    }\n+\n@@ -18,1 +36,0 @@\n-    protected abstract String getPath();\n@@ -31,4 +48,43 @@\n-        String path = getPath();\n-        if (path == null) {\n-            \/\/ let FileDescriptor claim everything\n-            return;\n+        FileDescriptor fileDescriptor = getFD();\n+        synchronized (fileDescriptor) {\n+            if (fileDescriptor.valid()) {\n+                applyCheckpointPolicy(fileDescriptor);\n+            }\n+        }\n+    }\n+\n+    @SuppressWarnings(\"fallthrough\")\n+    private void applyCheckpointPolicy(FileDescriptor fileDescriptor) throws CheckpointOpenFileException {\n+        int fd = fdAccess.get(fileDescriptor);\n+        String path = getPath(fileDescriptor);\n+        String type = getType(fileDescriptor);\n+        OpenFilePolicies.BeforeCheckpoint policy = OpenFilePolicies.CHECKPOINT.get(fd, path, type);\n+        switch (policy) {\n+            case ERROR:\n+                Supplier<Exception> exceptionSupplier = claimException(fileDescriptor, path);\n+                Core.getClaimedFDs().claimFd(fileDescriptor, owner, exceptionSupplier, fileDescriptor);\n+                break;\n+            case WARN_CLOSE:\n+                LoggerContainer.warn(\"CRaC: File {0} (FD {1}) was not closed by the application!\", path, fd);\n+                \/\/ intentional fallthrough\n+            case CLOSE:\n+                originalFd = fd;\n+                originalPath = path;\n+                originalType = type;\n+                originalFlags = getFlags(fileDescriptor);\n+                originalOffset = getOffset(fileDescriptor);\n+                if (originalOffset < 0) {\n+                    throw new CheckpointOpenFileException(\"Cannot find current offset of descriptor \" + fd + \"(\" + path + \")\", null);\n+                }\n+                try {\n+                    \/\/ do not unregister any handlers\n+                    fdAccess.closeNoCleanup(fileDescriptor);\n+                } catch (IOException e) {\n+                    throw new CheckpointOpenFileException(\"Cannot close file descriptor \" + fd + \" (\" + path + \") before checkpoint\", e);\n+                }\n+                LoggerContainer.debug(\"Closed FD {0} ({1}, offset {2} with flags 0x{3}%n\",\n+                        originalFd, originalPath, originalOffset,\n+                        Integer.toHexString(originalFlags).toUpperCase());\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Unknown policy \" + policy);\n@@ -36,0 +92,1 @@\n+    }\n@@ -37,0 +94,2 @@\n+    protected Supplier<Exception> claimException(FileDescriptor fd, String path) {\n+        int fdVal = fdAccess.get(fd);\n@@ -40,1 +99,1 @@\n-            exceptionSupplier = () -> null;\n+            exceptionSupplier = null;\n@@ -42,1 +101,1 @@\n-            exceptionSupplier = () -> new CheckpointOpenFileException(path, getStackTraceHolder());\n+            exceptionSupplier = () -> new CheckpointOpenFileException(path + \" (FD \" + fdVal + \")\", getStackTraceHolder());\n@@ -44,3 +103,1 @@\n-\n-        FileDescriptor fd = getFD();\n-        Core.getClaimedFDs().claimFd(fd, this, exceptionSupplier, fd);\n+        return exceptionSupplier;\n@@ -50,1 +107,10 @@\n-    public void afterRestore(Context<? extends Resource> context) throws Exception {\n+    public void afterRestore(Context<? extends jdk.crac.Resource> context) throws Exception {\n+        FileDescriptor fileDescriptor = getFD();\n+        synchronized (fileDescriptor) {\n+            if (!fileDescriptor.valid() && originalFd >= 0) {\n+                applyRestorePolicy(fileDescriptor);\n+            }\n+            \/\/ let GC collect the path and type\n+            originalPath = null;\n+        }\n+    }\n@@ -52,0 +118,38 @@\n+    private void applyRestorePolicy(FileDescriptor fileDescriptor) throws OpenFilePolicies.RestoreFileDescriptorException {\n+        OpenFilePolicies.AfterRestorePolicy policy =\n+                OpenFilePolicies.RESTORE.get(originalFd, originalPath, originalType);\n+        if (policy.type == OpenFilePolicies.AfterRestore.KEEP_CLOSED) {\n+            LoggerContainer.debug(\"FD %d (%s) is not reopened per policy%n\",\n+                    originalFd, originalPath);\n+            originalPath = null;\n+            return;\n+        }\n+        String path;\n+        if (policy.type == OpenFilePolicies.AfterRestore.OPEN_OTHER) {\n+            path = policy.param;\n+        } else {\n+            if (originalPath == null) {\n+                throw new OpenFilePolicies.RestoreFileDescriptorException(\"Cannot reopen file descriptor \" +\n+                        originalFd + \": no path\");\n+            }\n+            path = originalPath;\n+        }\n+        \/\/ We will attempt to open at the original offset even if the path changed;\n+        \/\/ this is used probably as the file moved on the filesystem but the contents\n+        \/\/ are the same.\n+        long offset = originalOffset;\n+        if (!reopen(originalFd, path, originalFlags, offset)) {\n+            if (policy.type == OpenFilePolicies.AfterRestore.REOPEN_OR_NULL) {\n+                if (!reopenNull(originalFd)) {\n+                    throw new OpenFilePolicies.RestoreFileDescriptorException(\"Cannot reopen file descriptor \" +\n+                            originalFd + \" to null device\");\n+                }\n+            } else {\n+                throw new OpenFilePolicies.RestoreFileDescriptorException(\"Cannot reopen file descriptor \" +\n+                        originalFd + \" to \" + path);\n+            }\n+        } else {\n+            LoggerContainer.debug(\"Reopened FD %d (%s, offset %d) with flags 0x%08X%n\",\n+                    originalFd, originalPath, originalOffset, originalFlags);\n+        }\n+        fdAccess.set(fileDescriptor, originalFd);\n@@ -53,0 +157,17 @@\n+\n+    @Override\n+    public String toString() {\n+        return owner + \".Resource(FD=\" + fdAccess.get(getFD()) + \")\";\n+    }\n+\n+    private static native String getPath(FileDescriptor fd);\n+\n+    private static native String getType(FileDescriptor fd);\n+\n+    private static native int getFlags(FileDescriptor fd);\n+\n+    private static native long getOffset(FileDescriptor fd);\n+\n+    private static native boolean reopen(int fd, String path, int flags, long offset);\n+\n+    private static native boolean reopenNull(int fd);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/JDKFileResource.java","additions":132,"deletions":11,"binary":false,"changes":143,"status":"modified"},{"patch":"@@ -0,0 +1,143 @@\n+package jdk.internal.crac;\n+\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import jdk.crac.impl.CheckpointOpenFileException;\n+import jdk.crac.impl.CheckpointOpenSocketException;\n+import jdk.crac.impl.OpenSocketPolicies;\n+import jdk.internal.access.JavaIOFileDescriptorAccess;\n+import jdk.internal.access.SharedSecrets;\n+import sun.nio.ch.Net;\n+\n+import java.io.FileDescriptor;\n+import java.io.IOException;\n+import java.net.*;\n+import java.util.function.Supplier;\n+\n+public class JDKSocketResource extends JDKFdResource {\n+    private static final JavaIOFileDescriptorAccess fdAccess =\n+            SharedSecrets.getJavaIOFileDescriptorAccess();\n+\n+    private final Object owner;\n+    private final ProtocolFamily family;\n+    private final Supplier<FileDescriptor> fdSupplier;\n+\n+    private int originalFd = -1;\n+    private SocketAddress local;\n+    private SocketAddress remote;\n+    private boolean error;\n+\n+    public JDKSocketResource(Object owner, ProtocolFamily family, FileDescriptor fd) {\n+        this.owner = owner;\n+        this.family = family;\n+        this.fdSupplier = () -> fd;\n+    }\n+\n+    public JDKSocketResource(Object owner, ProtocolFamily family, Supplier<FileDescriptor> fdSupplier) {\n+        this.owner = owner;\n+        this.family = family;\n+        this.fdSupplier = fdSupplier;\n+    }\n+\n+    @SuppressWarnings(\"fallthrough\")\n+    @Override\n+    public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+        FileDescriptor fd = fdSupplier.get();\n+        if (fd == null) {\n+            return;\n+        }\n+        synchronized (fd) {\n+            if (!fd.valid()) {\n+                return;\n+            }\n+            originalFd = fdAccess.get(fd);\n+            try {\n+                if (family == StandardProtocolFamily.INET || family == StandardProtocolFamily.INET6) {\n+                    local = Net.localAddress(fd);\n+                    remote = inetRemoteAddress(fd);\n+                } else if (family == StandardProtocolFamily.UNIX) {\n+                    local = unixDomainLocalAddress(fd);\n+                    remote = unixDomainRemoteAddress(fd);\n+                } else {\n+                    LoggerContainer.warn(\"CRaC: Unknown socket family \" + family + \" for FD \" + originalFd);\n+                }\n+            } catch (Exception e) {\n+                LoggerContainer.error(e,\"Error reading local\/remote address for FD \" + originalFd);\n+            }\n+            OpenSocketPolicies.BeforeCheckpoint policy = OpenSocketPolicies.CHECKPOINT.get(originalFd, local, remote);\n+            switch (policy) {\n+                case ERROR:\n+                    error = true;\n+                    Core.getClaimedFDs().claimFd(fd, owner, () -> new CheckpointOpenSocketException(owner.toString() + \"(FD \" + originalFd + \")\", getStackTraceHolder()), fd);\n+                    break;\n+                case WARN_CLOSE:\n+                    LoggerContainer.warn(\"CRaC: Socket {0} (FD {1}) was not closed by the application!\", owner, originalFd);\n+                    \/\/ intentional fallthrough\n+                case CLOSE:\n+                    try {\n+                        \/\/ do not unregister any handlers\n+                        fdAccess.closeNoCleanup(fd);\n+                    } catch (IOException e) {\n+                        throw new CheckpointOpenFileException(\"Cannot close file descriptor \" + fd + \" (\" + owner + \") before checkpoint\", e);\n+                    }\n+                    break;\n+            }\n+        }\n+    }\n+\n+    @SuppressWarnings(\"fallthrough\")\n+    @Override\n+    public void afterRestore(Context<? extends Resource> context) throws Exception {\n+        if (originalFd < 0) {\n+            return;\n+        }\n+        FileDescriptor fd = fdSupplier.get();\n+        if (fd == null) {\n+            return;\n+        }\n+        synchronized (fd) {\n+            OpenSocketPolicies.AfterRestorePolicy policy = OpenSocketPolicies.RESTORE.get(originalFd, local, remote);\n+            try {\n+                switch (policy.type) {\n+                    \/\/ FIXME: implement\n+                    case REOPEN_OR_ERROR:\n+                    case OPEN_OTHER:\n+                        \/\/ Don't throw another error when we've already failed once\n+                        if (!error) {\n+                            throw new UnsupportedOperationException(\"Policy \" + policy.type + \" not implemented (FD \" + originalFd + \")\");\n+                        }\n+                        break;\n+                    case KEEP_CLOSED:\n+                        \/\/ nothing to do\n+                        break;\n+                }\n+            } finally {\n+                \/\/ Allow garbage collection\n+                local = null;\n+                remote = null;\n+            }\n+        }\n+    }\n+\n+    private static UnixDomainSocketAddress unixDomainLocalAddress(FileDescriptor fd) {\n+        byte[] bytes = unixDomainLocalAddress0(fd);\n+        if (bytes == null || bytes.length == 0) {\n+            return null;\n+        }\n+        String path = new String(bytes);\n+        return UnixDomainSocketAddress.of(path);\n+    }\n+\n+    private static UnixDomainSocketAddress unixDomainRemoteAddress(FileDescriptor fd) {\n+        byte[] bytes = unixDomainRemoteAddress0(fd);\n+        if (bytes == null || bytes.length == 0) {\n+            return null;\n+        }\n+        String path = new String(bytes);\n+        return UnixDomainSocketAddress.of(path);\n+    }\n+\n+    private static native byte[] unixDomainLocalAddress0(FileDescriptor fd);\n+    private static native byte[] unixDomainRemoteAddress0(FileDescriptor fd);\n+    private static native InetSocketAddress inetRemoteAddress(FileDescriptor fd);\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/JDKSocketResource.java","additions":143,"deletions":0,"binary":false,"changes":143,"status":"added"},{"patch":"@@ -22,0 +22,4 @@\n+    public static void warn(String fmt, Object... params) {\n+        logger.log(System.Logger.Level.WARNING, fmt, params);\n+    }\n+\n@@ -26,0 +30,4 @@\n+    public static void error(String fmt, Object... params) {\n+        logger.log(System.Logger.Level.ERROR, fmt, params);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/LoggerContainer.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.text.MessageFormat;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/logger\/SimpleConsoleLogger.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -162,0 +162,2 @@\n+    exports jdk.internal.crac to\n+        jdk.sctp;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import jdk.internal.crac.JDKFileResource;\n+\n@@ -49,0 +51,6 @@\n+    private final JDKFileResource resource = new JDKFileResource(this) {\n+        @Override\n+        protected FileDescriptor getFD() {\n+            return fdObj;\n+        }\n+    };\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/AsynchronousFileChannelImpl.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.net.*;\n@@ -29,4 +30,0 @@\n-import java.net.SocketAddress;\n-import java.net.SocketOption;\n-import java.net.StandardSocketOptions;\n-import java.net.InetSocketAddress;\n@@ -41,0 +38,2 @@\n+\n+import jdk.internal.crac.JDKSocketResource;\n@@ -53,0 +52,1 @@\n+    private final JDKSocketResource resource;\n@@ -73,0 +73,1 @@\n+        this.resource = new JDKSocketResource(this, StandardProtocolFamily.INET, fd);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/AsynchronousServerSocketChannelImpl.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.net.*;\n@@ -30,4 +31,0 @@\n-import java.net.SocketOption;\n-import java.net.StandardSocketOptions;\n-import java.net.SocketAddress;\n-import java.net.InetSocketAddress;\n@@ -41,0 +38,2 @@\n+\n+import jdk.internal.crac.JDKSocketResource;\n@@ -53,0 +52,2 @@\n+    @SuppressWarnings(\"unused\")\n+    private final JDKSocketResource resource;\n@@ -91,0 +92,1 @@\n+        this.resource = new JDKSocketResource(this, StandardProtocolFamily.INET, fd);\n@@ -102,0 +104,1 @@\n+        this.resource = new JDKSocketResource(this, StandardProtocolFamily.INET, fd);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/AsynchronousSocketChannelImpl.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -72,0 +72,1 @@\n+import jdk.internal.crac.JDKSocketResource;\n@@ -97,0 +98,1 @@\n+    private final JDKSocketResource resource;\n@@ -196,0 +198,1 @@\n+            this.resource = new JDKSocketResource(this, family, fd);\n@@ -236,0 +239,1 @@\n+            this.resource = new JDKSocketResource(this, family, fd);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/DatagramChannelImpl.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+import jdk.internal.crac.JDKFileResource;\n@@ -73,0 +74,6 @@\n+    private final JDKFileResource resource = new JDKFileResource(this) {\n+        @Override\n+        protected FileDescriptor getFD() {\n+            return fd;\n+        }\n+    };\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/FileChannelImpl.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -54,6 +54,0 @@\n-import jdk.crac.Context;\n-import jdk.crac.Resource;\n-import jdk.crac.impl.CheckpointOpenSocketException;\n-import jdk.internal.crac.ClaimedFDs;\n-import jdk.internal.crac.Core;\n-import jdk.internal.crac.JDKFdResource;\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/NioSocketImpl.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+import jdk.internal.crac.JDKSocketResource;\n@@ -78,0 +79,1 @@\n+    private JDKSocketResource resource;\n@@ -131,0 +133,1 @@\n+        this.resource = new JDKSocketResource(this, family, fd);\n@@ -405,1 +408,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/ServerSocketChannelImpl.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+import jdk.internal.crac.JDKSocketResource;\n@@ -84,0 +85,1 @@\n+    private final JDKSocketResource resource;\n@@ -149,0 +151,1 @@\n+        this.resource = new JDKSocketResource(this, family, fd);\n@@ -163,0 +166,1 @@\n+        this.resource = new JDKSocketResource(this, family, fd);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/SocketChannelImpl.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -206,2 +206,4 @@\n-        fdAccess.markClosed(fd);\n-        close0(fd);\n+        \/\/ Originally this used fdAccess.markClosed() and close0() but leaving\n+        \/\/ the FD value set breaks JDKSocketResource (we don't want the extra\n+        \/\/ test if the FD resource has been marked).\n+        fdAccess.closeNoCleanup(fd);\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/ch\/FileDispatcherImpl.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import jdk.internal.crac.JDKFileResource;\n+\n@@ -50,0 +52,6 @@\n+    private final JDKFileResource resource = new JDKFileResource(this) {\n+        @Override\n+        protected FileDescriptor getFD() {\n+            return fd;\n+        }\n+    };\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/ch\/SinkChannelImpl.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import jdk.internal.crac.JDKFileResource;\n+\n@@ -50,0 +52,6 @@\n+    private final JDKFileResource resource = new JDKFileResource(this) {\n+        @Override\n+        protected FileDescriptor getFD() {\n+            return fd;\n+        }\n+    };\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/ch\/SourceChannelImpl.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include <limits.h>\n@@ -28,0 +29,1 @@\n+#include <string.h>\n@@ -216,0 +218,107 @@\n+\n+JNIEXPORT jstring JNICALL\n+Java_jdk_internal_crac_JDKFileResource_getPath(JNIEnv *env, jclass clazz, jobject obj) {\n+    int fd = (*env)->GetIntField(env, obj, IO_fd_fdID);\n+    char fdpath[64];\n+    snprintf(fdpath, sizeof(fdpath), \"\/proc\/self\/fd\/%d\", fd);\n+    char link[PATH_MAX];\n+    int ret = readlink(fdpath, link, PATH_MAX);\n+    if (ret >= 0) {\n+        link[(unsigned)ret < PATH_MAX ? ret : PATH_MAX - 1] = '\\0';\n+        return (*env)->NewStringUTF(env, link);\n+    }\n+    return NULL;\n+}\n+\n+JNIEXPORT jstring JNICALL\n+Java_jdk_internal_crac_JDKFileResource_getType(JNIEnv *env, jclass clazz, jobject obj) {\n+    int fd = (*env)->GetIntField(env, obj, IO_fd_fdID);\n+    struct stat st;\n+    if (fstat(fd, &st) == 0) {\n+        return (*env)->NewStringUTF(env, stat2strtype(st.st_mode));\n+    } else {\n+        return NULL;\n+    }\n+}\n+\n+JNIEXPORT jlong JNICALL\n+Java_jdk_internal_crac_JDKFileResource_getOffset(JNIEnv *env, jclass clazz, jobject obj) {\n+    int fd = (*env)->GetIntField(env, obj, IO_fd_fdID);\n+    jlong offset = lseek(fd, 0, SEEK_CUR);\n+    if (offset < 0) {\n+        if (errno == ESPIPE) {\n+            return 0;\n+        } else {\n+            perror(\"CRaC: cannot find file descriptor offset\");\n+            return offset;\n+        }\n+    }\n+    return offset;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_jdk_internal_crac_JDKFileResource_getFlags(JNIEnv *env, jclass clazz, jobject obj) {\n+    int fd = (*env)->GetIntField(env, obj, IO_fd_fdID);\n+    return fcntl(fd, F_GETFL);\n+}\n+\n+JNIEXPORT jboolean JNICALL\n+Java_jdk_internal_crac_JDKFileResource_reopen(JNIEnv *env, jclass clazz, jint fd, jstring path, jint flags, jlong offset) {\n+    CHECK_NULL_THROW_NPE_RETURN(env, path, \"Path cannot be null!\", false);\n+    if (fcntl(fd, F_GETFD) != -1) {\n+        JNU_ThrowByName(env, \"jdk\/crac\/impl\/CheckpointOpenFileException\", \"File descriptor is already open\");\n+    }\n+    if (flags & O_APPEND) {\n+        \/\/ If the file was opened in append mode ignore offset and always open at the end\n+        offset = 0;\n+    }\n+    jboolean copy;\n+    const char *cpath = (*env)->GetStringUTFChars(env, path, &copy);\n+    int firstFd = open(cpath, flags & ~(O_CREAT | O_EXCL));\n+    jboolean result = JNI_TRUE;\n+    if (firstFd < 0) {\n+        fprintf(stderr, \"CRaC: Failed to reopen file descriptor %s: %s\\n\", cpath, strerror(errno));\n+        result = JNI_FALSE;\n+    } else if (firstFd != fd) {\n+        if (dup2(firstFd, fd) < 0) {\n+            perror(\"CRaC: Failed to dup2 new file descriptor to original one\");\n+            result = JNI_FALSE;\n+        }\n+        if (close(firstFd) < 0) {\n+            perror(\"CRaC: failed to close opened file descriptor\");\n+        }\n+    }\n+    (*env)->ReleaseStringUTFChars(env, path, cpath);\n+    if (result) {\n+        if ((offset > 0 && lseek(fd, offset, SEEK_SET) < 0)) {\n+            perror(\"CRaC: Failed to lseek reopened file descriptor\");\n+            close(fd);\n+            return JNI_FALSE;\n+        }\n+    }\n+    return result;\n+}\n+\n+JNIEXPORT jboolean JNICALL\n+Java_jdk_internal_crac_JDKFileResource_reopenNull(JNIEnv *env, jclass clazz, jint fd) {\n+    if (fcntl(fd, F_GETFD) != -1) {\n+        JNU_ThrowByName(env, \"jdk\/crac\/impl\/CheckpointOpenFileException\", \"File descriptor is already open\");\n+    }\n+    \/\/ assert errno is EBADF?\n+    int firstFd = open(\"\/dev\/null\", O_RDWR);\n+    if (firstFd < 0) {\n+        perror(\"CRaC: Failed to reopen file descriptor using \/dev\/null\");\n+        return JNI_FALSE;\n+    } else if (firstFd == fd) {\n+        return JNI_TRUE;\n+    }\n+    jboolean result = JNI_TRUE;\n+    if (dup2(firstFd, fd) < 0) {\n+        perror(\"CRaC: Failed to dup2 new file descriptor to original one\");\n+        result = JNI_FALSE;\n+    }\n+    if (close(firstFd) < 0) {\n+        perror(\"CRaC: failed to close opened file descriptor\");\n+    }\n+    return result;\n+}\n","filename":"src\/java.base\/unix\/native\/libjava\/FileDescriptor_md.c","additions":109,"deletions":0,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -476,0 +476,21 @@\n+JNIEXPORT jobject JNICALL\n+Java_jdk_internal_crac_JDKSocketResource_inetRemoteAddress(JNIEnv *env, jclass clazz, jobject fdo)\n+{\n+    SOCKETADDRESS sa;\n+    socklen_t sa_len = sizeof(sa);\n+    int port;\n+\n+    if (getpeername(fdval(env, fdo), &sa.sa, &sa_len) < 0) {\n+        if (errno == ENOTCONN) {\n+            return NULL;\n+        }\n+        handleSocketError(env, errno);\n+        return NULL;\n+    }\n+    jobject remote_ia = NET_SockaddrToInetAddress(env, &sa, &port);\n+    jint remote_port = NET_GetPortFromSockaddr(&sa);\n+    jobject isa = (*env)->NewObject(env, isa_class, isa_ctorID, remote_ia, remote_port);\n+    CHECK_NULL_RETURN(isa, NULL);\n+    return isa;\n+}\n+\n","filename":"src\/java.base\/unix\/native\/libnio\/ch\/Net.c","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -195,0 +195,22 @@\n+\n+JNIEXPORT jbyteArray JNICALL\n+Java_jdk_internal_crac_JDKSocketResource_unixDomainLocalAddress0(JNIEnv *env, jclass clazz, jobject fdo)\n+{\n+    return Java_sun_nio_ch_UnixDomainSockets_localAddress0(env, NULL, fdo);\n+}\n+\n+JNIEXPORT jbyteArray JNICALL\n+Java_jdk_internal_crac_JDKSocketResource_unixDomainRemoteAddress0(JNIEnv *env, jclass clazz, jobject fdo)\n+{\n+    struct sockaddr_un sa;\n+    socklen_t sa_len = sizeof(struct sockaddr_un);\n+    int port;\n+    if (getpeername(fdval(env, fdo), (struct sockaddr *)&sa, &sa_len) < 0) {\n+        if (errno == ENOTCONN) {\n+            return NULL;\n+        }\n+        handleSocketError(env, errno);\n+        return NULL;\n+    }\n+    return sockaddrToUnixAddressBytes(env, &sa, sa_len);\n+}\n","filename":"src\/java.base\/unix\/native\/libnio\/ch\/UnixDomainSockets.c","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -27,4 +27,1 @@\n-import java.net.InetAddress;\n-import java.net.SocketAddress;\n-import java.net.SocketException;\n-import java.net.InetSocketAddress;\n+import java.net.*;\n@@ -56,0 +53,1 @@\n+import jdk.internal.crac.JDKSocketResource;\n@@ -79,1 +77,0 @@\n-\n@@ -81,0 +78,1 @@\n+    private final JDKSocketResource resource;\n@@ -141,0 +139,1 @@\n+        this.resource = new JDKSocketResource(this, StandardProtocolFamily.INET, fd);\n@@ -162,0 +161,1 @@\n+        this.resource = new JDKSocketResource(this, StandardProtocolFamily.INET, fd);\n","filename":"src\/jdk.sctp\/unix\/classes\/sun\/nio\/ch\/sctp\/SctpChannelImpl.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -27,4 +27,1 @@\n-import java.net.InetAddress;\n-import java.net.SocketAddress;\n-import java.net.SocketException;\n-import java.net.InetSocketAddress;\n+import java.net.*;\n@@ -56,0 +53,1 @@\n+import jdk.internal.crac.JDKSocketResource;\n@@ -75,1 +73,0 @@\n-\n@@ -77,0 +74,1 @@\n+    private final JDKSocketResource resource;\n@@ -138,0 +136,1 @@\n+        this.resource = new JDKSocketResource(this, StandardProtocolFamily.INET, fd);\n","filename":"src\/jdk.sctp\/unix\/classes\/sun\/nio\/ch\/sctp\/SctpMultiChannelImpl.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.net.StandardProtocolFamily;\n@@ -44,1 +45,1 @@\n-import sun.nio.ch.DirectBuffer;\n+import jdk.internal.crac.JDKSocketResource;\n@@ -51,1 +52,0 @@\n-import sun.nio.ch.Util;\n@@ -60,1 +60,0 @@\n-\n@@ -62,0 +61,1 @@\n+    private final JDKSocketResource resource;\n@@ -99,0 +99,1 @@\n+        this.resource = new JDKSocketResource(this, StandardProtocolFamily.INET, fd);\n","filename":"src\/jdk.sctp\/unix\/classes\/sun\/nio\/ch\/sctp\/SctpServerChannelImpl.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.Core;\n+import jdk.crac.impl.OpenFilePolicies;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+import static jdk.test.lib.Asserts.assertGreaterThan;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.crac.impl:+open\n+ * @requires (os.family == \"linux\")\n+ * @build CloseProcessPipeTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class CloseProcessPipeTest implements CracTest {\n+    @Override\n+    public void test() throws Exception {\n+        String checkpointPolicies = \"FIFO=\" + OpenFilePolicies.BeforeCheckpoint.CLOSE;\n+        String restorePolicies = \"FIFO=\" + OpenFilePolicies.AfterRestore.OPEN_OTHER + \"=\/dev\/null\";\n+        CracBuilder builder = new CracBuilder()\n+                .javaOption(OpenFilePolicies.CHECKPOINT_PROPERTY, checkpointPolicies)\n+                .javaOption(OpenFilePolicies.RESTORE_PROPERTY, restorePolicies);\n+        builder.doCheckpointAndRestore();\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        Process process = new ProcessBuilder().command(\"cat\", \"\/dev\/zero\").start();\n+        byte[] buffer = new byte[1024];\n+        int read1 = process.getInputStream().read(buffer);\n+        assertGreaterThan(read1, 0);\n+        Core.checkpointRestore();\n+        int read2, total = read1;\n+        \/\/ Some data got buffered from \/dev\/zero, we will still read those.\n+        \/\/ Had we used KEEP_CLOSED policy the read would return IOException: Stream Closed\n+        \/\/ in native code when we try to read from FD -1.\n+        while ((read2 = process.getInputStream().read(buffer)) >= 0) {\n+            total += read2;\n+        }\n+        System.err.printf(\"Read total %d bytes%n\", total);\n+        \/\/ The process will end with SIGPIPE\n+        assertEquals(141, process.waitFor());\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/CloseProcessPipeTest.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.Core;\n+import jdk.crac.impl.OpenSocketPolicies;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.util.concurrent.CountDownLatch;\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.crac.impl:+open\n+ * @build FDPolicyTestBase\n+ * @build CloseTcpSocketTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class CloseTcpSocketTest extends FDPolicyTestBase implements CracTest {\n+    @Override\n+    public void test() throws Exception {\n+        String loopback = InetAddress.getLoopbackAddress().getHostAddress();\n+        String checkpointPolicies = \"*=\" + OpenSocketPolicies.BeforeCheckpoint.CLOSE;\n+        String restorePolicies = loopback + \":*,*:*=\" + OpenSocketPolicies.AfterRestore.KEEP_CLOSED;\n+        new CracBuilder()\n+                .javaOption(OpenSocketPolicies.CHECKPOINT_PROPERTY, checkpointPolicies)\n+                .javaOption(OpenSocketPolicies.RESTORE_PROPERTY, restorePolicies)\n+                .doCheckpointAndRestore();\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        ServerSocket serverSocket = new ServerSocket(0, 50, InetAddress.getLoopbackAddress());\n+        CountDownLatch latch = new CountDownLatch(1);\n+        Thread serverThread = new Thread(() -> {\n+            try {\n+                Socket socket = serverSocket.accept();\n+                latch.countDown();\n+                \/\/ the socket leaks in here but for some reason it does not leave the FD open\n+            } catch (IOException e) {\n+                e.printStackTrace();\n+            }\n+        });\n+        serverThread.setDaemon(true);\n+        serverThread.start();\n+        Socket clientSocket = new Socket(InetAddress.getLoopbackAddress(), serverSocket.getLocalPort());\n+        latch.await();\n+        Core.checkpointRestore();\n+    }\n+\n+}\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/CloseTcpSocketTest.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -0,0 +1,78 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.Core;\n+import jdk.crac.impl.OpenSocketPolicies;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+\n+import java.io.IOException;\n+import java.net.*;\n+import java.util.concurrent.CountDownLatch;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.crac.impl:+open\n+ * @build FDPolicyTestBase\n+ * @build CloseUdpSocketTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class CloseUdpSocketTest extends FDPolicyTestBase implements CracTest {\n+    @Override\n+    public void test() throws Exception {\n+        String loopback = InetAddress.getLoopbackAddress().getHostAddress();\n+        String checkpointPolicies = loopback + \":0,*:*=\" + OpenSocketPolicies.BeforeCheckpoint.CLOSE;\n+        String restorePolicies = \"*=\" + OpenSocketPolicies.AfterRestore.KEEP_CLOSED;\n+        new CracBuilder()\n+                .javaOption(OpenSocketPolicies.CHECKPOINT_PROPERTY, checkpointPolicies)\n+                .javaOption(OpenSocketPolicies.RESTORE_PROPERTY, restorePolicies)\n+                .doCheckpointAndRestore();\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        try (DatagramSocket serverSocket = new DatagramSocket(0, InetAddress.getLoopbackAddress())) {\n+            CountDownLatch latch = new CountDownLatch(1);\n+            Thread serverThread = new Thread(() -> {\n+                try {\n+                    byte[] buf = new byte[1024];\n+                    DatagramPacket packet = new DatagramPacket(buf, buf.length);\n+                    serverSocket.receive(packet);\n+                    latch.countDown();\n+                } catch (IOException e) {\n+                    e.printStackTrace();\n+                }\n+            });\n+            serverThread.setDaemon(true);\n+            serverThread.start();\n+            try (DatagramSocket clientSocket = new DatagramSocket()) {\n+                clientSocket.connect(InetAddress.getLoopbackAddress(), serverSocket.getLocalPort());\n+                byte[] buf = \"Hello\".getBytes();\n+                clientSocket.send(new DatagramPacket(buf, buf.length));\n+                latch.await();\n+                Core.checkpointRestore();\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/CloseUdpSocketTest.java","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.Core;\n+import jdk.crac.impl.OpenSocketPolicies;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+\n+import java.io.IOException;\n+import java.net.*;\n+import java.nio.channels.ServerSocketChannel;\n+import java.nio.channels.SocketChannel;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.concurrent.CountDownLatch;\n+\n+import static jdk.test.lib.Asserts.assertTrue;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.crac.impl:+open\n+ * @build FDPolicyTestBase\n+ * @build CloseUnixSocketTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class CloseUnixSocketTest extends FDPolicyTestBase implements CracTest {\n+    @Override\n+    public void test() throws Exception {\n+        String checkpointPolicies = \"*=\" + OpenSocketPolicies.BeforeCheckpoint.CLOSE;\n+        String restorePolicies = \"*,*=\" + OpenSocketPolicies.AfterRestore.KEEP_CLOSED;\n+        new CracBuilder()\n+                .javaOption(OpenSocketPolicies.CHECKPOINT_PROPERTY, checkpointPolicies)\n+                .javaOption(OpenSocketPolicies.RESTORE_PROPERTY, restorePolicies)\n+                .doCheckpointAndRestore();\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        Path socketFile = Files.createTempFile(CloseUnixSocketTest.class.getSimpleName(), \".socket\");\n+        Files.deleteIfExists(socketFile);\n+        UnixDomainSocketAddress address = UnixDomainSocketAddress.of(socketFile);\n+\n+        ServerSocketChannel serverChannel = ServerSocketChannel.open(StandardProtocolFamily.UNIX);\n+        serverChannel.bind(address);\n+        CountDownLatch latch1 = new CountDownLatch(1);\n+        CountDownLatch latch2 = new CountDownLatch(1);\n+        Thread serverThread = new Thread(() -> {\n+            try {\n+                SocketChannel socket = serverChannel.accept();\n+                latch1.countDown();\n+                \/\/ We need to prevent SocketChannel getting out of scope and being\n+                \/\/ garbage collected. When this happens the file descriptor leaks.\n+                \/\/ It is not up to CRaC to handle leaked descriptors.\n+                latch2.await();\n+            } catch (IOException | InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+        });\n+        serverThread.setDaemon(true);\n+        serverThread.start();\n+        SocketChannel clientChannel = SocketChannel.open(StandardProtocolFamily.UNIX);\n+        assertTrue(clientChannel.connect(address));\n+        latch1.await();\n+        Core.checkpointRestore();\n+        latch2.countDown();\n+    }\n+\n+}\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/CloseUnixSocketTest.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+import static jdk.test.lib.Asserts.assertGreaterThan;\n+\n+public abstract class FDPolicyTestBase {\n+\n+    protected void writeBigFile(Path path, String prefix, String suffix) throws IOException {\n+        StringBuilder sb = new StringBuilder().append(prefix);\n+        \/\/ Let's use 8+ MB file to avoid hidden buffering in FileInputStream or native parts\n+        for (int i = 0; i < 1024 * 1024; ++i) {\n+            sb.append(String.format(\"%08X\", 8 * i));\n+        }\n+        sb.append(suffix);\n+        Files.writeString(path, sb.toString());\n+    }\n+\n+    protected void readContents(FileReader reader) throws IOException {\n+        char[] bigbuf = new char[1024 * 1024];\n+        for (int count = 0; count < 8 * 1024 * 1024; ) {\n+            int r = reader.read(bigbuf);\n+            assertGreaterThan(r, 8);\n+            assertEquals(String.format(\"%08X\", count), new String(bigbuf, 0, 8));\n+            count += r;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/FDPolicyTestBase.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.Core;\n+import jdk.crac.RestoreException;\n+import jdk.crac.impl.OpenFilePolicies;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+\n+import java.io.FileWriter;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Collections;\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+import static jdk.test.lib.Asserts.fail;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.crac.impl:+open\n+ * @build FDPolicyTestBase\n+ * @build ReopenFailureTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class ReopenFailureTest extends FDPolicyTestBase implements CracTest {\n+    @CracTestArg(value = 0, optional = true)\n+    String log1;\n+\n+    @CracTestArg(value = 1, optional = true)\n+    String log2;\n+\n+    @Override\n+    public void test() throws Exception {\n+        log1 = Files.createTempFile(ReopenFailureTest.class.getName(), \".txt\").toString();\n+        log2 = Files.createTempFile(ReopenFailureTest.class.getName(), \".txt\").toString();\n+        try {\n+            String checkpointPolicies = \"\/**\/*=\" + OpenFilePolicies.BeforeCheckpoint.CLOSE;\n+            CracBuilder builder = new CracBuilder()\n+                    .javaOption(OpenFilePolicies.CHECKPOINT_PROPERTY, checkpointPolicies)\n+                    .args(CracTest.args(log1, log2));\n+            builder.doCheckpoint();\n+            Files.delete(Path.of(log1));\n+            Files.setPosixFilePermissions(Path.of(log2), Collections.emptySet());\n+            builder.doRestore();\n+        } finally {\n+            Files.deleteIfExists(Path.of(log1));\n+            Files.deleteIfExists(Path.of(log2));\n+        }\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        try (var writer1 = new FileWriter(log1);\n+             var writer2 = new FileWriter(log2, true)) {\n+            writer1.write(\"Hello!\");\n+            writer1.flush();\n+            writer2.write(\"Hello!\");\n+            writer2.flush();\n+            try {\n+                Core.checkpointRestore();\n+                fail(\"Should throw\");\n+            } catch (RestoreException ex) {\n+                assertEquals(2, ex.getSuppressed().length);\n+            }\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/ReopenFailureTest.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.Core;\n+import jdk.crac.impl.OpenFilePolicies;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+\n+import java.io.FileReader;\n+import java.io.FileWriter;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.crac.impl:+open\n+ * @build FDPolicyTestBase\n+ * @build ReopenFileReadingTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class ReopenFileReadingTest extends FDPolicyTestBase implements CracTest {\n+    @CracTestArg(optional = true)\n+    String tempFile;\n+\n+    @Override\n+    public void test() throws Exception {\n+        tempFile = Files.createTempFile(ReopenFileReadingTest.class.getName(), \".txt\").toString();\n+        String configFile = Files.createTempFile(ReopenNamedFifoTest.class.getName(), \".cfg\").toString();\n+        try (var writer = new FileWriter(configFile)) {\n+            writer.write(\"\/some\/other\/file=ERROR\\n\");\n+            writer.write(tempFile + '=' + OpenFilePolicies.BeforeCheckpoint.CLOSE + \"\\n\");\n+            writer.write(\"**\/*.globpattern.test=CLOSE\");\n+        }\n+        Path tempPath = Path.of(tempFile);\n+        try {\n+            writeBigFile(tempPath, \"Hello \", \"world!\");\n+            new CracBuilder()\n+                    .javaOption(OpenFilePolicies.CHECKPOINT_PROPERTY + \".file\", configFile)\n+                    .args(CracTest.args(tempFile)).doCheckpointAndRestore();\n+        } finally {\n+            Files.deleteIfExists(tempPath);\n+            Files.deleteIfExists(Path.of(configFile));\n+        }\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        try (var reader = new FileReader(tempFile)) {\n+            char[] buf = new char[6];\n+            assertEquals(buf.length, reader.read(buf));\n+            assertEquals(\"Hello \", new String(buf));\n+            Core.checkpointRestore();\n+            readContents(reader);\n+            assertEquals(buf.length, reader.read(buf));\n+            assertEquals(\"world!\", new String(buf));\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/ReopenFileReadingTest.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -0,0 +1,120 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.Core;\n+import jdk.crac.impl.OpenFilePolicies;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.stream.Stream;\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.crac.impl:+open\n+ * @build ReopenFileWritingTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class ReopenFileWritingTest implements CracTest {\n+    @CracTestArg(value = 0, optional = true)\n+    String fileNoAppend;\n+\n+    @CracTestArg(value = 1, optional = true)\n+    String fileAppend;\n+\n+    @CracTestArg(value = 2, optional = true)\n+    String fileAppendExtended;\n+\n+    @CracTestArg(value = 3, optional = true)\n+    String fileAppendTruncated;\n+\n+    @Override\n+    public void test() throws Exception {\n+        fileNoAppend = Files.createTempFile(ReopenFileWritingTest.class.getName(), \".txt\").toString();\n+        fileAppend = Files.createTempFile(ReopenFileWritingTest.class.getName(), \".txt\").toString();\n+        fileAppendExtended = Files.createTempFile(ReopenFileWritingTest.class.getName(), \".txt\").toString();\n+        fileAppendTruncated = Files.createTempFile(ReopenFileWritingTest.class.getName(), \".txt\").toString();\n+        Path noAppendPath = Path.of(fileNoAppend);\n+        Path appendPath = Path.of(fileAppend);\n+        Path appendExtendedPath = Path.of(fileAppendExtended);\n+        Path appendTruncatedPath = Path.of(fileAppendTruncated);\n+        try {\n+            String checkpointPolicies = noAppendPath.getParent().resolve(\"*\").toString() + '=' + OpenFilePolicies.BeforeCheckpoint.CLOSE;\n+            CracBuilder builder = new CracBuilder();\n+            builder\n+                    .javaOption(OpenFilePolicies.CHECKPOINT_PROPERTY, checkpointPolicies)\n+                    .args(CracTest.args(fileNoAppend, fileAppend, fileAppendExtended, fileAppendTruncated));\n+            builder.doCheckpoint();\n+            assertEquals(\"Hello \", Files.readString(noAppendPath));\n+            assertEquals(\"Hello \", Files.readString(appendPath));\n+            assertEquals(\"Hello \", Files.readString(appendExtendedPath));\n+            assertEquals(\"Hello \", Files.readString(appendTruncatedPath));\n+            Files.writeString(noAppendPath, \"1234567890\");\n+            Files.writeString(appendPath, \"123456\");\n+            Files.writeString(appendExtendedPath, \"1234567890\");\n+            Files.writeString(appendTruncatedPath, \"\");\n+            builder.doRestore();\n+            assertEquals(\"123456world!\", Files.readString(noAppendPath));\n+            assertEquals(\"123456world!\", Files.readString(appendPath));\n+            assertEquals(\"1234567890world!\", Files.readString(appendExtendedPath));\n+            assertEquals(\"world!\", Files.readString(appendTruncatedPath));\n+        } finally {\n+            Files.deleteIfExists(noAppendPath);\n+            Files.deleteIfExists(appendPath);\n+            Files.deleteIfExists(appendExtendedPath);\n+            Files.deleteIfExists(appendTruncatedPath);\n+        }\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        try (var w1 = new FileWriter(fileNoAppend);\n+             var w2 = new FileWriter(fileAppend, true);\n+             var w3 = new FileWriter(fileAppendExtended, true);\n+             var w4 = new FileWriter(fileAppendTruncated, true)) {\n+            Stream.of(w1, w2, w3, w4).forEach(w -> {\n+                try {\n+                    w.write(\"Hello \");\n+                    w.flush();\n+                } catch (IOException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            });\n+            Core.checkpointRestore();\n+            Stream.of(w1, w2, w3, w4).forEach(w -> {\n+                try {\n+                    w.write(\"world!\");\n+                } catch (IOException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            });\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/ReopenFileWritingTest.java","additions":120,"deletions":0,"binary":false,"changes":120,"status":"added"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.Core;\n+import jdk.crac.impl.OpenFilePolicies;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracProcess;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.FileWriter;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.concurrent.CountDownLatch;\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.crac.impl:+open\n+ * @requires (os.family == \"linux\")\n+ * @build ReopenNamedFifoTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class ReopenNamedFifoTest implements CracTest {\n+    @CracTestArg(optional = true)\n+    String fifo;\n+\n+    @Override\n+    public void test() throws Exception {\n+        Path tempDirectory = Files.createTempDirectory(ReopenNamedFifoTest.class.getName());\n+        Path pipePath = tempDirectory.resolve(\"pipe\");\n+        fifo = pipePath.toString();\n+        assertEquals(0, new ProcessBuilder().inheritIO().command(\"mkfifo\", fifo).start().waitFor());\n+\n+        String checkpointPolicies = \"FIFO=\" + OpenFilePolicies.BeforeCheckpoint.CLOSE;\n+        CracBuilder builder = new CracBuilder()\n+                .javaOption(OpenFilePolicies.CHECKPOINT_PROPERTY, checkpointPolicies)\n+                .args(CracTest.args(fifo));\n+        CracProcess cp = builder.startCheckpoint();\n+\n+        try (var writer = new FileWriter(fifo)) {\n+            writer.write(\"Hello \");\n+            writer.flush();\n+            cp.waitForCheckpointed();\n+            CracProcess rp = builder.captureOutput(true).startRestore();\n+            CountDownLatch latch = new CountDownLatch(1);\n+            rp.watch(output -> {\n+                if (output.contains(\"RESTORED\")) {\n+                    latch.countDown();\n+                }\n+            }, error -> {});\n+            latch.await();\n+            writer.write(\"world!\");\n+            writer.flush();\n+            rp.waitForSuccess();\n+        } finally {\n+            Files.deleteIfExists(pipePath);\n+            Files.deleteIfExists(tempDirectory);\n+        }\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        try (var reader = new FileReader(fifo)) {\n+            char[] buf = new char[6];\n+            assertEquals(buf.length, reader.read(buf));\n+            assertEquals(\"Hello \", new String(buf));\n+            Core.checkpointRestore();\n+            System.out.println(\"RESTORED\");\n+            assertEquals(buf.length, reader.read(buf));\n+            assertEquals(\"world!\", new String(buf));\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/ReopenNamedFifoTest.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.Core;\n+import jdk.crac.impl.OpenFDPolicies;\n+import jdk.crac.impl.OpenFilePolicies;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracProcess;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+\n+import java.io.FileReader;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.crac.impl:+open\n+ * @build FDPolicyTestBase\n+ * @build ReopenOtherTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class ReopenOtherTest extends FDPolicyTestBase implements CracTest {\n+    @CracTestArg(value = 0, optional = true)\n+    String helloWorld;\n+\n+    @CracTestArg(value = 1, optional = true)\n+    String nazdarSvete;\n+\n+    @Override\n+    public void test() throws Exception {\n+        helloWorld = Files.createTempFile(ReopenOtherTest.class.getName(), \".txt\").toString();\n+        nazdarSvete = Files.createTempFile(ReopenOtherTest.class.getName(), \".txt\").toString();\n+        Path hwPath = Path.of(helloWorld);\n+        Path nsPath = Path.of(nazdarSvete);\n+        try {\n+            writeBigFile(hwPath, \"Hello \", \"world!\");\n+            writeBigFile(nsPath, \"Nazdar\", \"svete!\");\n+            String checkpointPolicies = helloWorld + '=' + OpenFilePolicies.BeforeCheckpoint.WARN_CLOSE;\n+            String restorePolicies = helloWorld + '=' + OpenFilePolicies.AfterRestore.OPEN_OTHER + '=' + nazdarSvete;\n+            CracBuilder builder = new CracBuilder()\n+                    .captureOutput(true)\n+                    .javaOption(OpenFilePolicies.CHECKPOINT_PROPERTY, checkpointPolicies)\n+                    .javaOption(OpenFilePolicies.RESTORE_PROPERTY, restorePolicies)\n+                    .args(CracTest.args(helloWorld));\n+            CracProcess cp = builder.startCheckpoint();\n+            cp.waitForCheckpointed();\n+            cp.outputAnalyzer().stderrShouldContain(\"was not closed by the application\");\n+            builder.captureOutput(false).doRestore();\n+        } finally {\n+            Files.deleteIfExists(hwPath);\n+            Files.deleteIfExists(nsPath);\n+        }\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        try (var reader = new FileReader(helloWorld)) {\n+            char[] buf = new char[6];\n+            assertEquals(buf.length, reader.read(buf));\n+            assertEquals(\"Hello \", new String(buf));\n+            Core.checkpointRestore();\n+            readContents(reader);\n+            assertEquals(buf.length, reader.read(buf));\n+            assertEquals(\"svete!\", new String(buf));\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/ReopenOtherTest.java","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"}]}