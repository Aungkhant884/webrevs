{"files":[{"patch":"@@ -32,1 +32,0 @@\n-import jdk.internal.crac.Core;\n@@ -531,1 +530,1 @@\n-        protected Supplier<Exception> claimException(int fdNum, String path) {\n+        protected Supplier<Exception> claimException(FileDescriptor fd, String path) {\n@@ -535,1 +534,1 @@\n-                return super.claimException(fdNum, path);\n+                return super.claimException(fd, path);\n","filename":"src\/java.base\/share\/classes\/java\/io\/FileInputStream.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -470,1 +470,1 @@\n-        protected Supplier<Exception> claimException(int fdNum, String path) {\n+        protected Supplier<Exception> claimException(FileDescriptor fd, String path) {\n@@ -474,1 +474,1 @@\n-                return super.claimException(fdNum, path);\n+                return super.claimException(fd, path);\n","filename":"src\/java.base\/share\/classes\/java\/io\/FileOutputStream.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -78,1 +78,0 @@\n-                case OPEN_OTHER_AT_END:\n@@ -189,4 +188,7 @@\n-         * The file is reopened. If it cannot be opened (e.g. the file is not\n-         * on the filesystem anymore or the process has insufficient\n-         * permissions) an error is printed and the checkpoint throws\n-         * an exception.\n+         * The file is reopened; if the file was opened in append mode it is\n+         * opened at the end, otherwise it is opened at the original position.\n+         * If it cannot be opened (e.g. the file is not on the filesystem\n+         * anymore or the process has insufficient permissions) an error is\n+         * printed and the checkpoint throws an exception.\n+         * When the file does not exist this is treated as an error even if\n+         * it was previously opened with flags supporting creation.\n@@ -203,6 +205,0 @@\n-        \/**\n-         * The file is reopened, ignoring the last offset and using the end\n-         * of file instead. This is particularly useful for append-only logs.\n-         * If it cannot be reopened the behaviour is identical to {@link #REOPEN_OR_ERROR}.\n-         *\/\n-        REOPEN_AT_END,\n@@ -213,0 +209,3 @@\n+         * If the file was opened in append mode the new file is opened at the end;\n+         * otherwise it is opened at the same position.\n+         * The file must be present; a non-existent file is treated as an error.\n@@ -216,5 +215,0 @@\n-        \/**\n-         * Similar to {@link #OPEN_OTHER} but ignored the previous offset\n-         * and opens the file at the end.\n-         *\/\n-        OPEN_OTHER_AT_END,\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/impl\/OpenFilePolicies.java","additions":10,"deletions":16,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-                Supplier<Exception> exceptionSupplier = claimException(fd, path);\n+                Supplier<Exception> exceptionSupplier = claimException(fileDescriptor, path);\n@@ -94,1 +94,2 @@\n-    protected Supplier<Exception> claimException(int fd, String path) {\n+    protected Supplier<Exception> claimException(FileDescriptor fd, String path) {\n+        int fdVal = fdAccess.get(fd);\n@@ -100,1 +101,1 @@\n-            exceptionSupplier = () -> new CheckpointOpenFileException(path + \" (FD \" + fd + \")\", getStackTraceHolder());\n+            exceptionSupplier = () -> new CheckpointOpenFileException(path + \" (FD \" + fdVal + \")\", getStackTraceHolder());\n@@ -127,2 +128,1 @@\n-        if (policy.type == OpenFilePolicies.AfterRestore.OPEN_OTHER ||\n-                policy.type == OpenFilePolicies.AfterRestore.OPEN_OTHER_AT_END) {\n+        if (policy.type == OpenFilePolicies.AfterRestore.OPEN_OTHER) {\n@@ -137,10 +137,4 @@\n-        long offset;\n-        if (policy.type == OpenFilePolicies.AfterRestore.REOPEN_AT_END ||\n-                policy.type == OpenFilePolicies.AfterRestore.OPEN_OTHER_AT_END) {\n-            offset = -1;\n-        } else {\n-            \/\/ We will attempt to open at the original offset even if the path changed;\n-            \/\/ this is used probably as the file moved on the filesystem but the contents\n-            \/\/ are the same.\n-            offset = originalOffset;\n-        }\n+        \/\/ We will attempt to open at the original offset even if the path changed;\n+        \/\/ this is used probably as the file moved on the filesystem but the contents\n+        \/\/ are the same.\n+        long offset = originalOffset;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/JDKFileResource.java","additions":9,"deletions":15,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -271,1 +271,4 @@\n-    \/\/ assert errno is EBADF?\n+    if (flags & O_APPEND) {\n+        \/\/ If the file was opened in append mode ignore offset and always open at the end\n+        offset = 0;\n+    }\n@@ -274,1 +277,1 @@\n-    int firstFd = open(cpath, flags);\n+    int firstFd = open(cpath, flags & ~(O_CREAT | O_EXCL));\n@@ -290,2 +293,1 @@\n-        if ((offset > 0 && lseek(fd, offset, SEEK_SET) < 0) ||\n-            (offset < 0 && lseek(fd, 0, SEEK_END) < 0)) {\n+        if ((offset > 0 && lseek(fd, offset, SEEK_SET) < 0)) {\n@@ -306,1 +308,1 @@\n-    int firstFd = open(\"\/dev\/null\", O_WRONLY);\n+    int firstFd = open(\"\/dev\/null\", O_RDWR);\n","filename":"src\/java.base\/unix\/native\/libjava\/FileDescriptor_md.c","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1,76 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import jdk.crac.Core;\n-import jdk.crac.impl.OpenFDPolicies;\n-import jdk.crac.impl.OpenFilePolicies;\n-import jdk.test.lib.crac.CracBuilder;\n-import jdk.test.lib.crac.CracTest;\n-import jdk.test.lib.crac.CracTestArg;\n-\n-import java.io.FileWriter;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-\n-import static jdk.test.lib.Asserts.assertEquals;\n-\n-\/**\n- * @test\n- * @library \/test\/lib\n- * @modules java.base\/jdk.crac.impl:+open\n- * @build ReopenAppendingTest\n- * @run driver jdk.test.lib.crac.CracTest\n- *\/\n-public class ReopenAppendingTest implements CracTest {\n-    @CracTestArg(optional = true)\n-    String tempFile;\n-\n-    @Override\n-    public void test() throws Exception {\n-        tempFile = Files.createTempFile(ReopenAppendingTest.class.getName(), \".txt\").toString();\n-        Path tempPath = Path.of(tempFile);\n-        try {\n-            String checkpointPolicies = tempFile + '=' + OpenFilePolicies.BeforeCheckpoint.CLOSE;\n-            CracBuilder builder = new CracBuilder();\n-            builder\n-                    .javaOption(OpenFilePolicies.CHECKPOINT_PROPERTY, checkpointPolicies)\n-                    .args(CracTest.args(tempFile));\n-            builder.doCheckpoint();\n-            assertEquals(\"Hello \", Files.readString(tempPath));\n-            builder.doRestore();\n-            assertEquals(\"Hello world!\", Files.readString(tempPath));\n-        } finally {\n-            Files.deleteIfExists(tempPath);\n-        }\n-    }\n-\n-    @Override\n-    public void exec() throws Exception {\n-        try (var writer = new FileWriter(tempFile)) {\n-            writer.write(\"Hello \");\n-            writer.flush();\n-            Core.checkpointRestore();\n-            writer.write(\"world!\");\n-        }\n-    }\n-}\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/ReopenAppendingTest.java","additions":0,"deletions":76,"binary":false,"changes":76,"status":"deleted"},{"patch":"@@ -1,99 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import jdk.crac.Core;\n-import jdk.crac.impl.OpenFDPolicies;\n-import jdk.crac.impl.OpenFilePolicies;\n-import jdk.test.lib.crac.CracBuilder;\n-import jdk.test.lib.crac.CracProcess;\n-import jdk.test.lib.crac.CracTest;\n-import jdk.test.lib.crac.CracTestArg;\n-\n-import java.io.File;\n-import java.io.FileReader;\n-import java.io.FileWriter;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.StandardOpenOption;\n-\n-import static jdk.test.lib.Asserts.assertEquals;\n-\n-\/**\n- * @test\n- * @library \/test\/lib\n- * @modules java.base\/jdk.crac.impl:+open\n- * @build FDPolicyTestBase\n- * @build ReopenAtEndTest\n- * @run driver jdk.test.lib.crac.CracTest\n- *\/\n-public class ReopenAtEndTest extends FDPolicyTestBase implements CracTest {\n-    @CracTestArg(value = 0, optional = true)\n-    String log1;\n-\n-    @CracTestArg(value = 1, optional = true)\n-    String log2;\n-\n-    @CracTestArg(value = 2, optional = true)\n-    String log3;\n-\n-    @Override\n-    public void test() throws Exception {\n-        log1 = Files.createTempFile(ReopenAtEndTest.class.getName(), \".txt\").toString();\n-        log2 = Files.createTempFile(ReopenAtEndTest.class.getName(), \".txt\").toString();\n-        log3 = Files.createTempFile(ReopenAtEndTest.class.getName(), \".txt\").toString();\n-        try {\n-            Files.writeString(Path.of(log3), \"333\");\n-            String checkpointPolicies = \"\/**\/*=\" + OpenFilePolicies.BeforeCheckpoint.CLOSE;\n-            String restorePolicies = log1 + '=' + OpenFilePolicies.AfterRestore.REOPEN_AT_END + ';' +\n-                    log2 + '=' + OpenFilePolicies.AfterRestore.OPEN_OTHER_AT_END + '=' + log3;\n-            CracBuilder builder = new CracBuilder()\n-                    .javaOption(OpenFilePolicies.CHECKPOINT_PROPERTY, checkpointPolicies)\n-                    .javaOption(OpenFilePolicies.RESTORE_PROPERTY, restorePolicies)\n-                    .args(CracTest.args(log1, log2, log3));\n-            builder.doCheckpoint();\n-            Files.writeString(Path.of(log1), \"ZZZ\", StandardOpenOption.APPEND);\n-            builder.doRestore();\n-            assertEquals(\"1ZZZX\", Files.readString(Path.of(log1)));\n-            assertEquals(\"22\", Files.readString(Path.of(log2)));\n-            assertEquals(\"333Y\", Files.readString(Path.of(log3)));\n-        } finally {\n-            Files.deleteIfExists(Path.of(log1));\n-            Files.deleteIfExists(Path.of(log2));\n-            Files.deleteIfExists(Path.of(log3));\n-        }\n-    }\n-\n-    @Override\n-    public void exec() throws Exception {\n-        try (var reader1 = new FileWriter(log1); var reader2 = new FileWriter(log2)) {\n-            reader1.write(\"1\");\n-            reader1.flush();\n-            reader2.write(\"22\");\n-            reader2.flush();\n-            Core.checkpointRestore();\n-            reader1.write(\"X\");\n-            reader2.write(\"Y\");\n-        }\n-    }\n-}\n-\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/ReopenAtEndTest.java","additions":0,"deletions":99,"binary":false,"changes":99,"status":"deleted"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.Core;\n+import jdk.crac.RestoreException;\n+import jdk.crac.impl.OpenFilePolicies;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+\n+import java.io.FileWriter;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Collections;\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+import static jdk.test.lib.Asserts.fail;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.crac.impl:+open\n+ * @build FDPolicyTestBase\n+ * @build ReopenFailureTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class ReopenFailureTest extends FDPolicyTestBase implements CracTest {\n+    @CracTestArg(value = 0, optional = true)\n+    String log1;\n+\n+    @CracTestArg(value = 1, optional = true)\n+    String log2;\n+\n+    @Override\n+    public void test() throws Exception {\n+        log1 = Files.createTempFile(ReopenFailureTest.class.getName(), \".txt\").toString();\n+        log2 = Files.createTempFile(ReopenFailureTest.class.getName(), \".txt\").toString();\n+        try {\n+            String checkpointPolicies = \"\/**\/*=\" + OpenFilePolicies.BeforeCheckpoint.CLOSE;\n+            CracBuilder builder = new CracBuilder()\n+                    .javaOption(OpenFilePolicies.CHECKPOINT_PROPERTY, checkpointPolicies)\n+                    .args(CracTest.args(log1, log2));\n+            builder.doCheckpoint();\n+            Files.delete(Path.of(log1));\n+            Files.setPosixFilePermissions(Path.of(log2), Collections.emptySet());\n+            builder.doRestore();\n+        } finally {\n+            Files.deleteIfExists(Path.of(log1));\n+            Files.deleteIfExists(Path.of(log2));\n+        }\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        try (var writer1 = new FileWriter(log1);\n+             var writer2 = new FileWriter(log2, true)) {\n+            writer1.write(\"Hello!\");\n+            writer1.flush();\n+            writer2.write(\"Hello!\");\n+            writer2.flush();\n+            try {\n+                Core.checkpointRestore();\n+                fail(\"Should throw\");\n+            } catch (RestoreException ex) {\n+                assertEquals(2, ex.getSuppressed().length);\n+            }\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/ReopenFailureTest.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -42,1 +42,1 @@\n- * @build ReopenFileTest\n+ * @build ReopenFileReadingTest\n@@ -45,1 +45,1 @@\n-public class ReopenFileTest extends FDPolicyTestBase implements CracTest {\n+public class ReopenFileReadingTest extends FDPolicyTestBase implements CracTest {\n@@ -51,1 +51,1 @@\n-        tempFile = Files.createTempFile(ReopenFileTest.class.getName(), \".txt\").toString();\n+        tempFile = Files.createTempFile(ReopenFileReadingTest.class.getName(), \".txt\").toString();\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/ReopenFileReadingTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"previous_filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/ReopenFileTest.java","status":"renamed"},{"patch":"@@ -0,0 +1,120 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.Core;\n+import jdk.crac.impl.OpenFilePolicies;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.stream.Stream;\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.crac.impl:+open\n+ * @build ReopenFileWritingTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class ReopenFileWritingTest implements CracTest {\n+    @CracTestArg(value = 0, optional = true)\n+    String fileNoAppend;\n+\n+    @CracTestArg(value = 1, optional = true)\n+    String fileAppend;\n+\n+    @CracTestArg(value = 2, optional = true)\n+    String fileAppendExtended;\n+\n+    @CracTestArg(value = 3, optional = true)\n+    String fileAppendTruncated;\n+\n+    @Override\n+    public void test() throws Exception {\n+        fileNoAppend = Files.createTempFile(ReopenFileWritingTest.class.getName(), \".txt\").toString();\n+        fileAppend = Files.createTempFile(ReopenFileWritingTest.class.getName(), \".txt\").toString();\n+        fileAppendExtended = Files.createTempFile(ReopenFileWritingTest.class.getName(), \".txt\").toString();\n+        fileAppendTruncated = Files.createTempFile(ReopenFileWritingTest.class.getName(), \".txt\").toString();\n+        Path noAppendPath = Path.of(fileNoAppend);\n+        Path appendPath = Path.of(fileAppend);\n+        Path appendExtendedPath = Path.of(fileAppendExtended);\n+        Path appendTruncatedPath = Path.of(fileAppendTruncated);\n+        try {\n+            String checkpointPolicies = noAppendPath.getParent().resolve(\"*\").toString() + '=' + OpenFilePolicies.BeforeCheckpoint.CLOSE;\n+            CracBuilder builder = new CracBuilder();\n+            builder\n+                    .javaOption(OpenFilePolicies.CHECKPOINT_PROPERTY, checkpointPolicies)\n+                    .args(CracTest.args(fileNoAppend, fileAppend, fileAppendExtended, fileAppendTruncated));\n+            builder.doCheckpoint();\n+            assertEquals(\"Hello \", Files.readString(noAppendPath));\n+            assertEquals(\"Hello \", Files.readString(appendPath));\n+            assertEquals(\"Hello \", Files.readString(appendExtendedPath));\n+            assertEquals(\"Hello \", Files.readString(appendTruncatedPath));\n+            Files.writeString(noAppendPath, \"1234567890\");\n+            Files.writeString(appendPath, \"123456\");\n+            Files.writeString(appendExtendedPath, \"1234567890\");\n+            Files.writeString(appendTruncatedPath, \"\");\n+            builder.doRestore();\n+            assertEquals(\"123456world!\", Files.readString(noAppendPath));\n+            assertEquals(\"123456world!\", Files.readString(appendPath));\n+            assertEquals(\"1234567890world!\", Files.readString(appendExtendedPath));\n+            assertEquals(\"world!\", Files.readString(appendTruncatedPath));\n+        } finally {\n+            Files.deleteIfExists(noAppendPath);\n+            Files.deleteIfExists(appendPath);\n+            Files.deleteIfExists(appendExtendedPath);\n+            Files.deleteIfExists(appendTruncatedPath);\n+        }\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        try (var w1 = new FileWriter(fileNoAppend);\n+             var w2 = new FileWriter(fileAppend, true);\n+             var w3 = new FileWriter(fileAppendExtended, true);\n+             var w4 = new FileWriter(fileAppendTruncated, true)) {\n+            Stream.of(w1, w2, w3, w4).forEach(w -> {\n+                try {\n+                    w.write(\"Hello \");\n+                    w.flush();\n+                } catch (IOException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            });\n+            Core.checkpointRestore();\n+            Stream.of(w1, w2, w3, w4).forEach(w -> {\n+                try {\n+                    w.write(\"world!\");\n+                } catch (IOException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            });\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/ReopenFileWritingTest.java","additions":120,"deletions":0,"binary":false,"changes":120,"status":"added"}]}