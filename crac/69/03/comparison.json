{"files":[{"patch":"@@ -28,1 +28,0 @@\n-import java.net.Socket;\n@@ -32,1 +31,1 @@\n-import jdk.crac.impl.CheckpointOpenFileException;\n+import jdk.crac.impl.OpenFDPolicies;\n@@ -35,3 +34,1 @@\n-import jdk.internal.crac.Core;\n-import jdk.internal.crac.JDKContext;\n-import jdk.internal.crac.JDKResource;\n+import jdk.internal.crac.*;\n@@ -62,36 +59,1 @@\n-    class Resource implements jdk.internal.crac.JDKResource {\n-        private boolean closedByNIO;\n-        final Exception stackTraceHolder;\n-\n-        Resource() {\n-            if (JDKContext.Properties.COLLECT_FD_STACKTRACES) {\n-                \/\/ About the timestamp: we cannot format it nicely since this\n-                \/\/ exception is sometimes created too early in the VM lifecycle\n-                \/\/ (but it's hard to detect when it would be safe to do).\n-                stackTraceHolder = new Exception(\"This file descriptor was created by \"\n-                        + Thread.currentThread().getName() + \" at epoch:\" + System.currentTimeMillis() + \" here\");\n-            } else {\n-                stackTraceHolder = null;\n-            }\n-            Core.Priority.FILE_DESCRIPTORS.getContext().register(this);\n-        }\n-\n-        @Override\n-        public void beforeCheckpoint(Context<? extends jdk.crac.Resource> context) throws Exception {\n-            if (!closedByNIO) {\n-                FileDescriptor.this.beforeCheckpoint();\n-            }\n-        }\n-\n-        @Override\n-        public void afterRestore(Context<? extends jdk.crac.Resource> context) throws Exception {\n-            FileDescriptor.this.afterRestore();\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return getClass().getName() + \"(FD \" + fd + \")\";\n-        }\n-    }\n-\n-    Resource resource = new Resource();\n+    FileDescriptorResource resource = new FileDescriptorResource(this);\n@@ -122,0 +84,1 @@\n+        OpenFDPolicies.ensureRegistered();\n@@ -150,1 +113,6 @@\n-                        fdo.resource.closedByNIO = true;\n+                        fdo.resource.markClosedByNio();\n+                    }\n+\n+                    @Override\n+                    public void closeNoCleanup(FileDescriptor fdo) throws IOException {\n+                        fdo.close0();\n@@ -365,28 +333,0 @@\n-    private synchronized void beforeCheckpoint() throws CheckpointOpenFileException {\n-        if (valid()) {\n-            JDKContext ctx = jdk.internal.crac.Core.getJDKContext();\n-            if (ctx.claimFdWeak(this, this)) {\n-                String path = getPath();\n-                String type = getType();\n-                String info;\n-                if (\"socket\".equals(type)) {\n-                    info = Socket.getDescription(this);\n-                } else {\n-                    info = (path != null ? path : \"unknown path\") + \" (\" + (type != null ? type : \"unknown\") + \")\";\n-                }\n-                String msg = \"FileDescriptor \" + this.fd + \" left open: \" + info + \" \";\n-                if (!JDKContext.Properties.COLLECT_FD_STACKTRACES) {\n-                    msg += JDKContext.COLLECT_FD_STACKTRACES_HINT;\n-                }\n-                throw new CheckpointOpenFileException(msg, resource.stackTraceHolder);\n-            }\n-        }\n-    }\n-\n-    private native String getPath();\n-\n-    private native String getType();\n-\n-    private synchronized void afterRestore() {\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/io\/FileDescriptor.java","additions":10,"deletions":70,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -0,0 +1,185 @@\n+package java.io;\n+\n+import jdk.crac.Context;\n+import jdk.crac.impl.CheckpointOpenFileException;\n+import jdk.crac.impl.OpenFDPolicies;\n+import jdk.internal.access.JavaIOFileDescriptorAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKContext;\n+import jdk.internal.crac.LoggerContainer;\n+\n+import java.net.Socket;\n+\n+class FileDescriptorResource implements jdk.internal.crac.JDKResource {\n+    private static final JavaIOFileDescriptorAccess fdAccess =\n+            SharedSecrets.getJavaIOFileDescriptorAccess();\n+\n+    private final FileDescriptor fileDescriptor;\n+    private int originalFd = -1;\n+    private String originalType;\n+    private String originalPath;\n+    private int originalFlags;\n+    private long originalOffset;\n+    private boolean closedByNIO;\n+    final Exception stackTraceHolder;\n+\n+    FileDescriptorResource(FileDescriptor fileDescriptor) {\n+        this.fileDescriptor = fileDescriptor;\n+        if (JDKContext.Properties.COLLECT_FD_STACKTRACES) {\n+            \/\/ About the timestamp: we cannot format it nicely since this\n+            \/\/ exception is sometimes created too early in the VM lifecycle\n+            \/\/ (but it's hard to detect when it would be safe to do).\n+            stackTraceHolder = new Exception(\"This file descriptor was created by \"\n+                    + Thread.currentThread().getName() + \" at epoch:\" + System.currentTimeMillis() + \" here\");\n+        } else {\n+            stackTraceHolder = null;\n+        }\n+        Core.Priority.FILE_DESCRIPTORS.getContext().register(this);\n+    }\n+\n+    void markClosedByNio() {\n+        closedByNIO = true;\n+    }\n+\n+    @Override\n+    public void beforeCheckpoint(Context<? extends jdk.crac.Resource> context) throws Exception {\n+        if (!closedByNIO) {\n+            synchronized (fileDescriptor) {\n+                if (fileDescriptor.valid()) {\n+                    applyCheckpointPolicy();\n+                }\n+            }\n+        }\n+    }\n+\n+    @SuppressWarnings(\"fallthrough\")\n+    private void applyCheckpointPolicy() throws CheckpointOpenFileException {\n+        JDKContext ctx = Core.getJDKContext();\n+        int fd = fdAccess.get(fileDescriptor);\n+        String path = getPath(fileDescriptor);\n+        String type = getType(fileDescriptor);\n+        OpenFDPolicies.BeforeCheckpoint policy = OpenFDPolicies.CHECKPOINT.get(fd, type, path);\n+        switch (policy) {\n+            case ERROR:\n+                if (ctx.claimFdWeak(fileDescriptor, fileDescriptor)) {\n+                    String info;\n+                    if (\"socket\".equals(type)) {\n+                        info = Socket.getDescription(fileDescriptor);\n+                    } else {\n+                        info = (path != null ? path : \"unknown path\") + \" (\" + (type != null ? type : \"unknown\") + \")\";\n+                    }\n+                    String msg = \"FileDescriptor \" + fd + \" left open: \" + info + \" \";\n+                    if (!JDKContext.Properties.COLLECT_FD_STACKTRACES) {\n+                        msg += JDKContext.COLLECT_FD_STACKTRACES_HINT;\n+                    }\n+                    throw new CheckpointOpenFileException(msg, fileDescriptor.resource.stackTraceHolder);\n+                }\n+                break;\n+            case WARN_CLOSE:\n+                LoggerContainer.warn(\"CRaC: File descriptor {0} ({1}) was not closed by the application!\", fd, path);\n+                \/\/ intentional fallthrough\n+            case CLOSE:\n+                fileDescriptor.resource.originalFd = fd;\n+                fileDescriptor.resource.originalType = type;\n+                fileDescriptor.resource.originalPath = path;\n+                fileDescriptor.resource.originalFlags = getFlags(fileDescriptor);\n+                fileDescriptor.resource.originalOffset = getOffset(fileDescriptor);\n+                if (fileDescriptor.resource.originalOffset < 0) {\n+                    throw new CheckpointOpenFileException(\"Cannot find current offset of descriptor \" + fd + \"(\" + path + \")\", null);\n+                }\n+                try {\n+                    \/\/ do not unregister any handlers\n+                    fdAccess.closeNoCleanup(fileDescriptor);\n+                } catch (IOException e) {\n+                    throw new CheckpointOpenFileException(\"Cannot close file descriptor \" + fd + \" (\" + path + \") before checkpoint\", e);\n+                }\n+                LoggerContainer.debug(\"Closed FD {0} ({1}, offset {2} with flags 0x{3}%n\",\n+                        fileDescriptor.resource.originalFd, fileDescriptor.resource.originalPath, fileDescriptor.resource.originalOffset,\n+                        Integer.toHexString(fileDescriptor.resource.originalFlags).toUpperCase());\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Unknown policy \" + policy);\n+        }\n+    }\n+\n+    @Override\n+    public void afterRestore(Context<? extends jdk.crac.Resource> context) throws Exception {\n+        synchronized (fileDescriptor) {\n+            if (!fileDescriptor.valid() && originalFd >= 0) {\n+                applyRestorePolicy();\n+            }\n+            \/\/ let GC collect the path and type\n+            originalPath = null;\n+            originalType = null;\n+        }\n+    }\n+\n+    private void applyRestorePolicy() throws OpenFDPolicies.RestoreFileDescriptorException {\n+        OpenFDPolicies.AfterRestorePolicy policy =\n+                OpenFDPolicies.RESTORE.get(originalFd, originalType, originalPath);\n+        if (policy.type == OpenFDPolicies.AfterRestore.KEEP_CLOSED) {\n+            LoggerContainer.debug(\"FD %d (%s) is not reopened per policy%n\",\n+                    originalFd, originalPath);\n+            originalPath = null;\n+            originalType = null;\n+            return;\n+        }\n+        String path;\n+        if (policy.type == OpenFDPolicies.AfterRestore.OPEN_OTHER ||\n+                policy.type == OpenFDPolicies.AfterRestore.OPEN_OTHER_AT_END) {\n+            path = policy.param;\n+        } else {\n+            if (originalPath == null) {\n+                throw new OpenFDPolicies.RestoreFileDescriptorException(\"Cannot reopen file descriptor \" +\n+                        originalFd + \": invalid path: \" + originalPath);\n+            } else if (originalType.equals(\"socket\")) {\n+                throw new OpenFDPolicies.RestoreFileDescriptorException(\"Cannot reopen file descriptor \" +\n+                        originalFd + \": cannot restore socket\");\n+            }\n+            path = originalPath;\n+        }\n+        long offset;\n+        if (policy.type == OpenFDPolicies.AfterRestore.REOPEN_AT_END ||\n+                policy.type == OpenFDPolicies.AfterRestore.OPEN_OTHER_AT_END) {\n+            offset = -1;\n+        } else {\n+            \/\/ We will attempt to open at the original offset even if the path changed;\n+            \/\/ this is used probably as the file moved on the filesystem but the contents\n+            \/\/ are the same.\n+            offset = originalOffset;\n+        }\n+        if (!reopen(originalFd, path, originalFlags, offset)) {\n+            if (policy.type == OpenFDPolicies.AfterRestore.REOPEN_OR_NULL) {\n+                if (!reopenNull(originalFd)) {\n+                    throw new OpenFDPolicies.RestoreFileDescriptorException(\"Cannot reopen file descriptor \" +\n+                            originalFd + \" to null device\");\n+                }\n+            } else {\n+                throw new OpenFDPolicies.RestoreFileDescriptorException(\"Cannot reopen file descriptor \" +\n+                        originalFd + \" to \" + path);\n+            }\n+        } else {\n+            LoggerContainer.debug(\"Reopened FD %d (%s, offset %d) with flags 0x%08X%n\",\n+                    originalFd, originalPath, originalOffset, originalFlags);\n+        }\n+        fdAccess.set(fileDescriptor, originalFd);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return getClass().getName() + \"(FD \" + fdAccess.get(fileDescriptor) + \")\";\n+    }\n+\n+    private static native String getPath(FileDescriptor fd);\n+\n+    private static native String getType(FileDescriptor fd);\n+\n+    private static native int getFlags(FileDescriptor fd);\n+\n+    private static native long getOffset(FileDescriptor fd);\n+\n+    private static native boolean reopen(int fd, String path, int flags, long offset);\n+\n+    private static native boolean reopenNull(int fd);\n+}\n","filename":"src\/java.base\/share\/classes\/java\/io\/FileDescriptorResource.java","additions":185,"deletions":0,"binary":false,"changes":185,"status":"added"},{"patch":"@@ -115,2 +115,0 @@\n-        \/\/ This log is here to initialize call sites in logger formatters.\n-        LoggerContainer.debug(\"Starting checkpoint at epoch:{0}\", System.currentTimeMillis());\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/Core.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,327 @@\n+package jdk.crac.impl;\n+\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKResource;\n+import jdk.internal.crac.LoggerContainer;\n+import sun.security.action.GetPropertyAction;\n+\n+import java.io.*;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Path;\n+import java.nio.file.PathMatcher;\n+import java.util.*;\n+import java.util.regex.Pattern;\n+\n+public class OpenFDPolicies<P> {\n+    public static final String CHECKPOINT_PROPERTY = \"jdk.crac.fd-policy.checkpoint\";\n+    public static final String RESTORE_PROPERTY = \"jdk.crac.fd-policy.restore\";\n+    public static final String FIFO = \"FIFO\";\n+    public static final String SOCKET = \"SOCKET\";\n+\n+    public static final OpenFDPolicies<BeforeCheckpoint> CHECKPOINT =\n+            new OpenFDPolicies<>(BeforeCheckpoint.ERROR);\n+    public static final OpenFDPolicies<AfterRestorePolicy> RESTORE =\n+            new OpenFDPolicies<>(new AfterRestorePolicy(AfterRestore.REOPEN_OR_ERROR, null));\n+\n+    private static Pattern NUMERIC;\n+    private static final JDKResource resource = new JDKResource() {\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) {\n+            CHECKPOINT.clear();\n+            \/\/ We need to s\n+            loadCheckpointPolicies();\n+            RESTORE.clear();\n+        }\n+\n+        @Override\n+        public void afterRestore(Context<? extends Resource> context) throws Exception {\n+        }\n+    };\n+\n+    private final P defaultPolicy;\n+    private boolean loaded;\n+    private P fifoPolicy;\n+    private P socketPolicy;\n+    private final Map<Integer, P> numericPolicies = new HashMap<>();\n+    private final List<Map.Entry<PathMatcher, P>> pathPolicies = new ArrayList<>();\n+\n+    static {\n+        \/\/ This static ctor runs too early to invoke loadCheckpointPolicies directly\n+        Core.Priority.NORMAL.getContext().register(resource);\n+    }\n+\n+    private synchronized static void loadCheckpointPolicies() {\n+        \/\/ We cannot initialize this in static constructor as this is invoked too early\n+        if (NUMERIC == null) {\n+            NUMERIC = Pattern.compile(\"[0-9]+\");\n+        }\n+        loadProperties(\"checkpoint\", CHECKPOINT_PROPERTY).forEach((key, value) -> {\n+            BeforeCheckpoint policy;\n+            try {\n+                policy = BeforeCheckpoint.valueOf(value.toString());\n+            } catch (IllegalArgumentException e) {\n+                LoggerContainer.error(\"Invalid value of policy '{0}' for target {1}; valid values are: {2}\",\n+                        value, key, Arrays.toString(BeforeCheckpoint.values()));\n+                return;\n+            }\n+            CHECKPOINT.setPolicy(key, value, policy);\n+        });\n+        CHECKPOINT.loaded = true;\n+    }\n+\n+    private synchronized static void loadRestorePolicies() {\n+        AfterRestore[] policies = AfterRestore.values();\n+        loadProperties(\"restore\", RESTORE_PROPERTY).forEach((key, value) -> {\n+            String pstr = value.toString();\n+            int eqIndex = pstr.indexOf('=');\n+            String policyName = eqIndex < 0 ? pstr : pstr.substring(0, eqIndex);\n+            AfterRestore type = Arrays.stream(policies).filter(p -> policyName.equals(p.name())).findAny().orElse(null);\n+            if (type == null) {\n+                throw new IllegalArgumentException(\"Invalid value of restore policy \" + value +\n+                        \" for target \" + key + \"; valid values are: \" + Arrays.toString(AfterRestore.values()));\n+            }\n+            AfterRestorePolicy policy;\n+            switch (type) {\n+                case OPEN_OTHER:\n+                case OPEN_OTHER_AT_END:\n+                    \/\/ we add + 2 because we need the equal sign and at least one character for the path\n+                    if (pstr.length() < type.name().length() + 2) {\n+                        throw new IllegalArgumentException(\"Invalid specification for policy \" + type +\n+                                \" for target \" + key +\n+                                \": Policy name should be followed by an equal sign '=' and then the path.\");\n+                    } else {\n+                        policy = new AfterRestorePolicy(type, unescape(pstr, type.name().length() + 1, pstr.length()));\n+                    }\n+                    break;\n+                default:\n+                    policy = new AfterRestorePolicy(type, null);\n+            }\n+            RESTORE.setPolicy(key, value, policy);\n+        });\n+        RESTORE.loaded = true;\n+    }\n+\n+    public OpenFDPolicies(P defaultPolicy) {\n+        this.defaultPolicy = defaultPolicy;\n+        this.fifoPolicy = defaultPolicy;\n+        this.socketPolicy = defaultPolicy;\n+    }\n+\n+    private void clear() {\n+        this.fifoPolicy = defaultPolicy;\n+        this.socketPolicy = defaultPolicy;\n+        this.numericPolicies.clear();\n+        this.pathPolicies.clear();\n+        this.loaded = false;\n+    }\n+\n+    private static Properties loadProperties(String type, String systemProperty) {\n+        Properties properties = new Properties();\n+        String file = GetPropertyAction.privilegedGetProperty(systemProperty + \".file\");\n+        if (file != null) {\n+            try {\n+                if (file.length() >= 4 && file.substring(file.length() - 4).equalsIgnoreCase(\".xml\")) {\n+                    try (var fis = new FileInputStream(file)) {\n+                        properties.loadFromXML(fis);\n+                    }\n+                } else {\n+                    try (var fr = new FileReader(file, StandardCharsets.UTF_8)) {\n+                        properties.load(fr);\n+                    }\n+                }\n+            } catch (IOException e) {\n+                LoggerContainer.error(\"Failed to read {0} file descriptor policies from {1}: {2}\", type, file, e.getMessage());\n+            }\n+        }\n+        String property = GetPropertyAction.privilegedGetProperty(systemProperty);\n+        if (property != null) {\n+            for (var item : property.split(File.pathSeparator)) {\n+                int eqIndex = findNonEscapedEq(item, 0);\n+                if (eqIndex < 0) {\n+                    LoggerContainer.error(\"Invalid specification for {0} file descriptor policy: {1}\", type, item);\n+                } else {\n+                    properties.put(unescape(item, 0, eqIndex), item.substring(eqIndex + 1));\n+                }\n+            }\n+        }\n+        return properties;\n+    }\n+\n+    private static String unescape(String str, int fromIndex, int toIndex) {\n+        boolean escaped = false;\n+        StringBuilder sb = new StringBuilder(str.length() - fromIndex);\n+        for (int i = fromIndex; i < toIndex; ++i) {\n+            char c = str.charAt(i);\n+            if (!escaped && c == '\\\\') {\n+                escaped = true;\n+            } else {\n+                sb.append(c);\n+                escaped = false;\n+            }\n+        }\n+        return sb.toString();\n+    }\n+\n+    private static int findNonEscapedEq(String str, int fromIndex) {\n+        boolean escaped = false;\n+        for (int i = fromIndex; i < str.length(); ++i) {\n+            char c = str.charAt(i);\n+            if (c == '\\\\') {\n+                escaped = !escaped;\n+            } else if (c == '=' && !escaped) {\n+                return i;\n+            }\n+        }\n+        return -1;\n+    }\n+\n+    public static void ensureRegistered() {\n+        \/\/ Noop - this method is invoked to ensure that static constructor was invoked\n+    }\n+\n+    private void setPolicy(Object key, Object value, P policy) {\n+        if (FIFO.equals(key)) {\n+            fifoPolicy = policy;\n+        } else if (SOCKET.equals(key)) {\n+            socketPolicy = policy;\n+        } else if (NUMERIC.matcher(key.toString()).matches()) {\n+            int fd = Integer.parseInt(key.toString());\n+            P prev = numericPolicies.putIfAbsent(fd, policy);\n+            if (prev != null) {\n+                LoggerContainer.error(\"Duplicate policy for file descriptor {0}; policy {1} will be ignored.\", fd, value);\n+            }\n+        } else {\n+            pathPolicies.add(Map.entry(\n+                    FileSystems.getDefault().getPathMatcher(\"glob:\" + key), policy));\n+        }\n+    }\n+\n+    public P get(int fd, String type, String path) {\n+        synchronized (OpenFDPolicies.this) {\n+            if (!loaded) {\n+                \/\/ We could use a Runnable but method references don't work\n+                \/\/ when the static ctor is invoked\n+                if (this == CHECKPOINT) {\n+                    loadCheckpointPolicies();\n+                } else {\n+                    loadRestorePolicies();\n+                }\n+            }\n+        }\n+        P policy = numericPolicies.get(fd);\n+        if (policy != null) {\n+            return policy;\n+        }\n+        if (path != null) {\n+            Path p = Path.of(path);\n+            for (var entry : pathPolicies) {\n+                if (entry.getKey().matches(p)) {\n+                    return entry.getValue();\n+                }\n+            }\n+        }\n+        if (type.equals(\"fifo\") && fd > 2) {\n+            return fifoPolicy;\n+        } else if (type.equals(\"socket\")) {\n+            return socketPolicy;\n+        }\n+        return defaultPolicy;\n+    }\n+\n+    \/**\n+     * Defines a treatment of file descriptor found open during checkpoint.\n+     *\/\n+    public enum BeforeCheckpoint {\n+        \/**\n+         * The checkpoint fails with an appropriate error message. This is the\n+         * default as it is safer to force applications handle the checkpoint,\n+         * the options below are meant as workarounds when this is not feasible.\n+         *\/\n+        ERROR,\n+        \/**\n+         * The file descriptor will be silently closed. The original path will\n+         * be recorded and after restore this will be subject to treatment based\n+         * on the {@link AfterRestore} policy.\n+         *\/\n+        CLOSE,\n+        \/**\n+         * The behaviour is identical to {@link #CLOSE} but the application\n+         * will print out a warning message to the standard error.\n+         *\/\n+        WARN_CLOSE,\n+        \/\/ TODO: for no-downtime replication (scaling up) a strategy that would\n+        \/\/  keep the descriptor open when the checkpointed process is left\n+        \/\/  running might be useful.\n+    }\n+\n+    \/**\n+     * Defines what to do with file descriptors closed by the\n+     * {@link BeforeCheckpoint} policy after restore from a checkpoint.\n+     *\/\n+    public enum AfterRestore {\n+        \/**\n+         * The file descriptor is reopened. If it cannot be opened (e.g.\n+         * the file is not on the filesystem anymore or the process has\n+         * insufficient permissions) an error is printed and the restored\n+         * process is terminated.\n+         * If the file descriptor had no matching file (it is a pipe or\n+         * socket) this is treated as an error.\n+         * This is the default behaviour.\n+         *\/\n+        REOPEN_OR_ERROR,\n+        \/**\n+         * The file descriptor is reopened. If it cannot be opened (e.g.\n+         * the file is missing, it was a pipe or socket or the process has\n+         * insufficient permissions) a \/dev\/null device is opened instead\n+         * (allowing the process to write any data but not providing anything\n+         * for reading).\n+         *\/\n+        REOPEN_OR_NULL,\n+        \/**\n+         * The file descriptor is reopened, ignoring the last offset and using\n+         * the end of file instead. This is particularly useful for append-only\n+         * logs.\n+         * If it cannot be reopened the behaviour is identical to {@link #REOPEN_OR_ERROR}.\n+         *\/\n+        REOPEN_AT_END,\n+        \/**\n+         * After restore another file specified as part of the policy\n+         * declaration (usually the policy name is followed by\n+         * an equal sign '=' character and then the path) is opened instead.\n+         * If the other file cannot be open an error is printed and the process\n+         * is terminated.\n+         *\/\n+        OPEN_OTHER,\n+        \/**\n+         * Similar to {@link #OPEN_OTHER} but ignored the previous offset\n+         * and opens the file at the end.\n+         *\/\n+        OPEN_OTHER_AT_END,\n+        \/**\n+         * Do not do anything with the closed descriptor; this will probably result\n+         * in runtime errors if the resource is used.\n+         *\/\n+        KEEP_CLOSED\n+    }\n+\n+    public static class AfterRestorePolicy {\n+        public final AfterRestore type;\n+        public final String param;\n+\n+        private AfterRestorePolicy(AfterRestore type, String param) {\n+            this.type = type;\n+            this.param = param;\n+        }\n+    }\n+\n+    public static class RestoreFileDescriptorException extends Exception {\n+        public static final long serialVersionUID = -8790346029973354266L;\n+\n+        public RestoreFileDescriptorException(String message) {\n+            super(message);\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/impl\/OpenFDPolicies.java","additions":327,"deletions":0,"binary":false,"changes":327,"status":"added"},{"patch":"@@ -43,0 +43,1 @@\n+    public void closeNoCleanup(FileDescriptor fileDescriptor) throws IOException;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaIOFileDescriptorAccess.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -22,0 +22,4 @@\n+    public static void warn(String fmt, Object... params) {\n+        logger.log(System.Logger.Level.WARNING, fmt, params);\n+    }\n+\n@@ -26,0 +30,4 @@\n+    public static void error(String fmt, Object... params) {\n+        logger.log(System.Logger.Level.ERROR, fmt, params);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/LoggerContainer.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.text.MessageFormat;\n@@ -58,0 +59,10 @@\n+    static {\n+        \/\/ It is possible that CRaC would print first logging message after\n+        \/\/ JDKContext completes. Registering a CallSite as resource at this\n+        \/\/ point would hang the checkpoint, therefore we perform all the\n+        \/\/ initialization eagerly.\n+        new SimpleConsoleLogger(null, false).getCallerInfo();\n+        String.format(\"%tc\",ZonedDateTime.now());\n+        MessageFormat.format(\"{0} {1}\", 0, \"1\");\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/logger\/SimpleConsoleLogger.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+\n@@ -27,0 +28,1 @@\n+#include <limits.h>\n@@ -28,0 +30,1 @@\n+#include <string.h>\n@@ -94,1 +97,1 @@\n-Java_java_io_FileDescriptor_getPath(JNIEnv *env, jobject obj) {\n+Java_java_io_FileDescriptorResource_getPath(JNIEnv *env, jclass clazz, jobject obj) {\n@@ -107,1 +110,0 @@\n-\n@@ -109,1 +111,1 @@\n-Java_java_io_FileDescriptor_getType(JNIEnv *env, jobject obj) {\n+Java_java_io_FileDescriptorResource_getType(JNIEnv *env, jclass clazz, jobject obj) {\n@@ -119,0 +121,79 @@\n+JNIEXPORT jlong JNICALL\n+Java_java_io_FileDescriptorResource_getOffset(JNIEnv *env, jclass clazz, jobject obj) {\n+    int fd = (*env)->GetIntField(env, obj, IO_fd_fdID);\n+    jlong offset = lseek(fd, 0, SEEK_CUR);\n+    if (offset < 0) {\n+        if (errno == ESPIPE) {\n+            return 0;\n+        } else {\n+            perror(\"CRaC: cannot find file descriptor offset\");\n+            return offset;\n+        }\n+    }\n+    return offset;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_java_io_FileDescriptorResource_getFlags(JNIEnv *env, jclass clazz, jobject obj) {\n+    int fd = (*env)->GetIntField(env, obj, IO_fd_fdID);\n+    return fcntl(fd, F_GETFL);\n+}\n+\n+JNIEXPORT jboolean JNICALL\n+Java_java_io_FileDescriptorResource_reopen(JNIEnv *env, jclass clazz, jint fd, jstring path, jint flags, jlong offset) {\n+    if (fcntl(fd, F_GETFD) != -1) {\n+        JNU_ThrowByName(env, \"jdk\/crac\/impl\/CheckpointOpenFileException\", \"File descriptor is already open\");\n+    }\n+    \/\/ assert errno is EBADF?\n+    jboolean copy;\n+    const char *cpath = (*env)->GetStringUTFChars(env, path, &copy);\n+    int firstFd = open(cpath, flags);\n+    (*env)->ReleaseStringUTFChars(env, path, cpath);\n+    jboolean result = JNI_TRUE;\n+    if (firstFd < 0) {\n+        perror(\"CRaC: Failed to reopen file descriptor\");\n+        return JNI_FALSE;\n+    } else if (firstFd != fd) {\n+        if (dup2(firstFd, fd) < 0) {\n+            perror(\"CRaC: Failed to dup2 new file descriptor to original one\");\n+            result = JNI_FALSE;\n+        }\n+        if (close(firstFd) < 0) {\n+            perror(\"CRaC: failed to close opened file descriptor\");\n+        }\n+    }\n+    if (result) {\n+        if ((offset > 0 && lseek(fd, offset, SEEK_SET) < 0) ||\n+            (offset < 0 && lseek(fd, 0, SEEK_END) < 0)) {\n+            perror(\"CRaC: Failed to lseek reopened file descriptor\");\n+            close(fd);\n+            return JNI_FALSE;\n+        }\n+    }\n+    return result;\n+}\n+\n+JNIEXPORT jboolean JNICALL\n+Java_java_io_FileDescriptorResource_reopenNull(JNIEnv *env, jclass clazz, jint fd) {\n+    if (fcntl(fd, F_GETFD) != -1) {\n+        JNU_ThrowByName(env, \"jdk\/crac\/impl\/CheckpointOpenFileException\", \"File descriptor is already open\");\n+    }\n+    \/\/ assert errno is EBADF?\n+    int firstFd = open(\"\/dev\/null\", O_WRONLY);\n+    if (firstFd < 0) {\n+        perror(\"CRaC: Failed to reopen file descriptor using \/dev\/null\");\n+        return JNI_FALSE;\n+    } else if (firstFd == fd) {\n+        return JNI_TRUE;\n+    }\n+    jboolean result = JNI_TRUE;\n+    if (dup2(firstFd, fd) < 0) {\n+        perror(\"CRaC: Failed to dup2 new file descriptor to original one\");\n+        result = JNI_FALSE;\n+    }\n+    if (close(firstFd) < 0) {\n+        perror(\"CRaC: failed to close opened file descriptor\");\n+    }\n+    return result;\n+}\n+\n","filename":"src\/java.base\/unix\/native\/libjava\/FileDescriptor_md.c","additions":84,"deletions":3,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -81,0 +81,30 @@\n+JNIEXPORT jstring JNICALL\n+Java_java_io_FileDescriptor_getPath(JNIEnv *env, jobject obj) {\n+    return NULL;\n+}\n+\n+JNIEXPORT jstring JNICALL\n+Java_java_io_FileDescriptor_getType(JNIEnv *env, jobject obj) {\n+    return NULL;\n+}\n+\n+JNIEXPORT jlong JNICALL\n+Java_java_io_FileDescriptor_getOffset(JNIEnv *env, jobject obj) {\n+    return -1;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_java_io_FileDescriptor_getFlags(JNIEnv *env, jobject obj) {\n+    return -1;\n+}\n+\n+JNIEXPORT jboolean JNICALL\n+Java_java_io_FileDescriptor_reopen(JNIEnv *env, jobject obj, jint fd, jstring path, jint flags, jlong offset) {\n+    return JNI_FALSE;\n+}\n+\n+JNIEXPORT jboolean JNICALL\n+Java_java_io_FileDescriptor_reopenNull(JNIEnv *env, jobject obj, jint fd) {\n+    return JNI_FALSE;\n+}\n+\n","filename":"src\/java.base\/windows\/native\/libjava\/FileDescriptor_md.c","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.Core;\n+import jdk.crac.impl.OpenFDPolicies;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.util.concurrent.CountDownLatch;\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.crac.impl:+open\n+ * @build FDPolicyTestBase\n+ * @build CloseSocketTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class CloseSocketTest extends FDPolicyTestBase implements CracTest {\n+    @Override\n+    public void test() throws Exception {\n+        String checkpointPolicies = \"SOCKET=\" + OpenFDPolicies.BeforeCheckpoint.CLOSE;\n+        new CracBuilder()\n+                .javaOption(OpenFDPolicies.CHECKPOINT_PROPERTY, checkpointPolicies)\n+                .javaOption(OpenFDPolicies.RESTORE_PROPERTY, \"SOCKET=\" + OpenFDPolicies.AfterRestore.KEEP_CLOSED)\n+                .doCheckpointAndRestore();\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        ServerSocket serverSocket = new ServerSocket(0, 50, InetAddress.getLoopbackAddress());\n+        CountDownLatch latch = new CountDownLatch(1);\n+        Thread serverThread = new Thread(() -> {\n+            try {\n+                Socket socket = serverSocket.accept();\n+                latch.countDown();\n+            } catch (IOException e) {\n+                e.printStackTrace();\n+            }\n+        });\n+        serverThread.setDaemon(true);\n+        serverThread.start();\n+        Socket clientSocket = new Socket(InetAddress.getLoopbackAddress(), serverSocket.getLocalPort());\n+        latch.await();\n+        Core.checkpointRestore();\n+        System.out.println(\"Not much to do here\");\n+    }\n+\n+}\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/CloseSocketTest.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+import static jdk.test.lib.Asserts.assertGreaterThan;\n+\n+public abstract class FDPolicyTestBase {\n+\n+    protected void writeBigFile(Path path, String prefix, String suffix) throws IOException {\n+        StringBuilder sb = new StringBuilder().append(prefix);\n+        \/\/ Let's use 8+ MB file to avoid hidden buffering in FileInputStream or native parts\n+        for (int i = 0; i < 1024 * 1024; ++i) {\n+            sb.append(String.format(\"%08X\", 8 * i));\n+        }\n+        sb.append(suffix);\n+        Files.writeString(path, sb.toString());\n+    }\n+\n+    protected void readContents(FileReader reader) throws IOException {\n+        char[] bigbuf = new char[1024 * 1024];\n+        for (int count = 0; count < 8 * 1024 * 1024; ) {\n+            int r = reader.read(bigbuf);\n+            assertGreaterThan(r, 8);\n+            assertEquals(String.format(\"%08X\", count), new String(bigbuf, 0, 8));\n+            count += r;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/FDPolicyTestBase.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.Core;\n+import jdk.crac.impl.OpenFDPolicies;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+\n+import java.io.FileWriter;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.crac.impl:+open\n+ * @build ReopenAppendingTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class ReopenAppendingTest implements CracTest {\n+    @CracTestArg(optional = true)\n+    String tempFile;\n+\n+    @Override\n+    public void test() throws Exception {\n+        tempFile = Files.createTempFile(ReopenAppendingTest.class.getName(), \".txt\").toString();\n+        Path tempPath = Path.of(tempFile);\n+        try {\n+            String checkpointPolicies = tempFile + '=' + OpenFDPolicies.BeforeCheckpoint.CLOSE;\n+            CracBuilder builder = new CracBuilder();\n+            builder\n+                    .javaOption(OpenFDPolicies.CHECKPOINT_PROPERTY, checkpointPolicies)\n+                    .args(CracTest.args(tempFile));\n+            builder.doCheckpoint();\n+            assertEquals(\"Hello \", Files.readString(tempPath));\n+            builder.doRestore();\n+            assertEquals(\"Hello world!\", Files.readString(tempPath));\n+        } finally {\n+            Files.deleteIfExists(tempPath);\n+        }\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        try (var writer = new FileWriter(tempFile)) {\n+            writer.write(\"Hello \");\n+            writer.flush();\n+            Core.checkpointRestore();\n+            writer.write(\"world!\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/ReopenAppendingTest.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.Core;\n+import jdk.crac.impl.OpenFDPolicies;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracProcess;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.FileWriter;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.crac.impl:+open\n+ * @build FDPolicyTestBase\n+ * @build ReopenAtEndTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class ReopenAtEndTest extends FDPolicyTestBase implements CracTest {\n+    @CracTestArg(value = 0, optional = true)\n+    String log1;\n+\n+    @CracTestArg(value = 1, optional = true)\n+    String log2;\n+\n+    @CracTestArg(value = 2, optional = true)\n+    String log3;\n+\n+    @Override\n+    public void test() throws Exception {\n+        log1 = Files.createTempFile(ReopenAtEndTest.class.getName(), \".txt\").toString();\n+        log2 = Files.createTempFile(ReopenAtEndTest.class.getName(), \".txt\").toString();\n+        log3 = Files.createTempFile(ReopenAtEndTest.class.getName(), \".txt\").toString();\n+        try {\n+            Files.writeString(Path.of(log3), \"333\");\n+            String checkpointPolicies = \"\/**\/*=\" + OpenFDPolicies.BeforeCheckpoint.CLOSE;\n+            String restorePolicies = log1 + '=' + OpenFDPolicies.AfterRestore.REOPEN_AT_END + File.pathSeparatorChar +\n+                    log2 + '=' + OpenFDPolicies.AfterRestore.OPEN_OTHER_AT_END + '=' + log3;\n+            CracBuilder builder = new CracBuilder()\n+                    .javaOption(OpenFDPolicies.CHECKPOINT_PROPERTY, checkpointPolicies)\n+                    .javaOption(OpenFDPolicies.RESTORE_PROPERTY, restorePolicies)\n+                    .args(CracTest.args(log1, log2, log3));\n+            builder.doCheckpoint();\n+            Files.writeString(Path.of(log1), \"ZZZ\", StandardOpenOption.APPEND);\n+            builder.doRestore();\n+            assertEquals(\"1ZZZX\", Files.readString(Path.of(log1)));\n+            assertEquals(\"22\", Files.readString(Path.of(log2)));\n+            assertEquals(\"333Y\", Files.readString(Path.of(log3)));\n+        } finally {\n+            Files.deleteIfExists(Path.of(log1));\n+            Files.deleteIfExists(Path.of(log2));\n+            Files.deleteIfExists(Path.of(log3));\n+        }\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        try (var reader1 = new FileWriter(log1); var reader2 = new FileWriter(log2)) {\n+            reader1.write(\"1\");\n+            reader1.flush();\n+            reader2.write(\"22\");\n+            reader2.flush();\n+            Core.checkpointRestore();\n+            reader1.write(\"X\");\n+            reader2.write(\"Y\");\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/ReopenAtEndTest.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -0,0 +1,99 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.Core;\n+import jdk.crac.impl.OpenFDPolicies;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracProcess;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.FileWriter;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.concurrent.CountDownLatch;\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.crac.impl:+open\n+ * @requires (os.family == \"linux\")\n+ * @build ReopenFifoTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class ReopenFifoTest implements CracTest {\n+    @CracTestArg(optional = true)\n+    String fifo;\n+\n+    @Override\n+    public void test() throws Exception {\n+        Path tempDirectory = Files.createTempDirectory(ReopenFifoTest.class.getName());\n+        Path pipePath = tempDirectory.resolve(\"pipe\");\n+        fifo = pipePath.toString();\n+        assertEquals(0, new ProcessBuilder().inheritIO().command(\"mkfifo\", fifo).start().waitFor());\n+\n+        \/\/ The socket part is here just to test parsing\n+        String checkpointPolicies = \"FIFO=\" + OpenFDPolicies.BeforeCheckpoint.CLOSE + File.pathSeparator + \"SOCKET=\" + OpenFDPolicies.BeforeCheckpoint.ERROR;\n+        CracBuilder builder = new CracBuilder()\n+                .javaOption(OpenFDPolicies.CHECKPOINT_PROPERTY, checkpointPolicies)\n+                .args(CracTest.args(fifo));\n+        CracProcess cp = builder.startCheckpoint();\n+\n+        try (var writer = new FileWriter(fifo)) {\n+            writer.write(\"Hello \");\n+            writer.flush();\n+            cp.waitForCheckpointed();\n+            CracProcess rp = builder.captureOutput(true).startRestore();\n+            CountDownLatch latch = new CountDownLatch(1);\n+            rp.watch(output -> {\n+                if (output.contains(\"RESTORED\")) {\n+                    latch.countDown();\n+                }\n+            }, error -> {});\n+            latch.await();\n+            writer.write(\"world!\");\n+            writer.flush();\n+            rp.waitForSuccess();\n+        } finally {\n+            Files.deleteIfExists(pipePath);\n+            Files.deleteIfExists(tempDirectory);\n+        }\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        try (var reader = new FileReader(fifo)) {\n+            char[] buf = new char[6];\n+            assertEquals(buf.length, reader.read(buf));\n+            assertEquals(\"Hello \", new String(buf));\n+            Core.checkpointRestore();\n+            System.out.println(\"RESTORED\");\n+            assertEquals(buf.length, reader.read(buf));\n+            assertEquals(\"world!\", new String(buf));\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/ReopenFifoTest.java","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.Core;\n+import jdk.crac.impl.OpenFDPolicies;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+\n+import java.io.FileReader;\n+import java.io.FileWriter;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.crac.impl:+open\n+ * @build FDPolicyTestBase\n+ * @build ReopenFileTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class ReopenFileTest extends FDPolicyTestBase implements CracTest {\n+    @CracTestArg(optional = true)\n+    String tempFile;\n+\n+    @Override\n+    public void test() throws Exception {\n+        tempFile = Files.createTempFile(ReopenFileTest.class.getName(), \".txt\").toString();\n+        String configFile = Files.createTempFile(ReopenFifoTest.class.getName(), \".cfg\").toString();\n+        try (var writer = new FileWriter(configFile)) {\n+            writer.write(\"\/some\/other\/file=ERROR\\n\");\n+            writer.write(tempFile + '=' + OpenFDPolicies.BeforeCheckpoint.CLOSE + \"\\n\");\n+            writer.write(\"**\/*.globpattern.test=CLOSE\");\n+        }\n+        Path tempPath = Path.of(tempFile);\n+        try {\n+            writeBigFile(tempPath, \"Hello \", \"world!\");\n+            new CracBuilder()\n+                    .javaOption(OpenFDPolicies.CHECKPOINT_PROPERTY + \".file\", configFile)\n+                    .args(CracTest.args(tempFile)).doCheckpointAndRestore();\n+        } finally {\n+            Files.deleteIfExists(tempPath);\n+            Files.deleteIfExists(Path.of(configFile));\n+        }\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        try (var reader = new FileReader(tempFile)) {\n+            char[] buf = new char[6];\n+            assertEquals(buf.length, reader.read(buf));\n+            assertEquals(\"Hello \", new String(buf));\n+            Core.checkpointRestore();\n+            readContents(reader);\n+            assertEquals(buf.length, reader.read(buf));\n+            assertEquals(\"world!\", new String(buf));\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/ReopenFileTest.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.Core;\n+import jdk.crac.impl.OpenFDPolicies;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracProcess;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+\n+import java.io.FileReader;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.crac.impl:+open\n+ * @build FDPolicyTestBase\n+ * @build ReopenOtherTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class ReopenOtherTest extends FDPolicyTestBase implements CracTest {\n+    @CracTestArg(value = 0, optional = true)\n+    String helloWorld;\n+\n+    @CracTestArg(value = 1, optional = true)\n+    String nazdarSvete;\n+\n+    @Override\n+    public void test() throws Exception {\n+        helloWorld = Files.createTempFile(ReopenOtherTest.class.getName(), \".txt\").toString();\n+        nazdarSvete = Files.createTempFile(ReopenOtherTest.class.getName(), \".txt\").toString();\n+        Path hwPath = Path.of(helloWorld);\n+        Path nsPath = Path.of(nazdarSvete);\n+        try {\n+            writeBigFile(hwPath, \"Hello \", \"world!\");\n+            writeBigFile(nsPath, \"Nazdar\", \"svete!\");\n+            String checkpointPolicies = helloWorld + '=' + OpenFDPolicies.BeforeCheckpoint.WARN_CLOSE;\n+            String restorePolicies = helloWorld + '=' + OpenFDPolicies.AfterRestore.OPEN_OTHER + '=' + nazdarSvete;\n+            CracBuilder builder = new CracBuilder()\n+                    .captureOutput(true)\n+                    .javaOption(OpenFDPolicies.CHECKPOINT_PROPERTY, checkpointPolicies)\n+                    .javaOption(OpenFDPolicies.RESTORE_PROPERTY, restorePolicies)\n+                    .args(CracTest.args(helloWorld));\n+            CracProcess cp = builder.startCheckpoint();\n+            cp.waitForCheckpointed();\n+            cp.outputAnalyzer().stderrShouldContain(\"was not closed by the application\");\n+            builder.captureOutput(false).doRestore();\n+        } finally {\n+            Files.deleteIfExists(hwPath);\n+            Files.deleteIfExists(nsPath);\n+        }\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        try (var reader = new FileReader(helloWorld)) {\n+            char[] buf = new char[6];\n+            assertEquals(buf.length, reader.read(buf));\n+            assertEquals(\"Hello \", new String(buf));\n+            Core.checkpointRestore();\n+            readContents(reader);\n+            assertEquals(buf.length, reader.read(buf));\n+            assertEquals(\"svete!\", new String(buf));\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/ReopenOtherTest.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"}]}