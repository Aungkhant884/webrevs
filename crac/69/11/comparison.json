{"files":[{"patch":"@@ -310,0 +310,4 @@\n+  if (!ok && CRPauseOnCheckpointError) {\n+    os::message_box(\"Checkpoint failed\", \"Errors were found during checkpoint.\");\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/crac.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2138,0 +2138,4 @@\n+                                                                            \\\n+  product(bool, CRPauseOnCheckpointError, false, DIAGNOSTIC,                \\\n+      \"Pauses the checkpoint when a problem is found on VM level.\")\n+\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import java.util.function.Supplier;\n+import java.util.regex.Pattern;\n@@ -34,3 +36,1 @@\n-import jdk.internal.crac.Core;\n-import jdk.internal.crac.ClaimedFDs;\n-import jdk.internal.crac.JDKFdResource;\n+import jdk.internal.crac.*;\n@@ -64,0 +64,1 @@\n+        @SuppressWarnings(\"fallthrough\")\n@@ -69,0 +70,31 @@\n+                String nativeDescription = nativeDescription0();\n+\n+                OpenResourcePolicies.Policy policy = findPolicy(nativeDescription);\n+                String action = \"error\";\n+                String warn = \"false\";\n+                Supplier<Exception> supplier = null;\n+                \/\/ Normally the claiming should be overridden by FileInputStream\/FileOutputStream\n+                \/\/ but in case these are collected we handle FDs 0..2 here as well.\n+                if (policy != null) {\n+                    action = policy.action;\n+                    warn = policy.params.getOrDefault(\"warn\", \"true\");\n+                } else if (self == in || self == out || self == err) {\n+                    action = \"ignore\";\n+                }\n+                supplier = switch (action.toLowerCase()) {\n+                    case \"error\":\n+                        yield () -> new CheckpointOpenResourceException(\n+                            FileDescriptor.class.getSimpleName() + \" \" + fd + \": \" + nativeDescription,\n+                            getStackTraceHolder());\n+                    case \"close\":\n+                        close();\n+                    case \"ignore\":\n+                        if (Boolean.parseBoolean(warn)) {\n+                            LoggerContainer.warn(\"File descriptor {0} was not closed by the application. Use 'warn: false' in the policy to suppress this message.\", fd);\n+                        }\n+                        yield NO_EXCEPTION;\n+                    default: throw new IllegalArgumentException(\"Unknown policy action for file descriptor \" + fd + \": \" + action);\n+                };\n+                claimedFDs.claimFd(self, self, supplier);\n+            }\n+        }\n@@ -70,3 +102,11 @@\n-                claimedFDs.claimFd(self, self, () ->  {\n-                    if (self == in || self == out || self == err) {\n-                        return null;\n+        private OpenResourcePolicies.Policy findPolicy(String nativeDescription) {\n+            return OpenResourcePolicies.find(false, \"filedescriptor\", params -> {\n+                String value = params.get(\"value\");\n+                if (value != null) {\n+                    try {\n+                        int expected = Integer.parseInt(value);\n+                        if (expected != fd) {\n+                            return false;\n+                        }\n+                    } catch (NumberFormatException e) {\n+                        throw new IllegalArgumentException(\"Cannot parse file descriptor value '\" + value + \"'\");\n@@ -74,5 +114,7 @@\n-                    return new CheckpointOpenResourceException(\n-                        FileDescriptor.class.getSimpleName() + \" \" + fd + \": \" + nativeDescription0(),\n-                        getStackTraceHolder());\n-                });\n-            }\n+                }\n+                String regex = params.get(\"regex\");\n+                if (regex != null) {\n+                    return Pattern.compile(regex).matcher(nativeDescription).matches();\n+                }\n+                return true;\n+            });\n","filename":"src\/java.base\/share\/classes\/java\/io\/FileDescriptor.java","additions":53,"deletions":11,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -30,0 +30,7 @@\n+\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import jdk.internal.crac.LoggerContainer;\n+import jdk.internal.crac.OpenResourcePolicies;\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKFileResource;\n@@ -519,0 +526,65 @@\n+    @SuppressWarnings(\"unused\")\n+    private final JDKFileResource resource = new JDKFileResource() {\n+        private long offset;\n+\n+        @Override\n+        protected FileDescriptor getFD() {\n+            return fd;\n+        }\n+\n+        @Override\n+        protected String getPath() {\n+            return path;\n+        }\n+\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+            if (fd == FileDescriptor.in) {\n+                Core.getClaimedFDs().claimFd(fd, FileInputStream.this, NO_EXCEPTION, fd);\n+            } else {\n+                \/\/ When the stream is opened with file descriptor we don't have any extra\n+                \/\/ information we could use for policy (this is most often a pipe, but could\n+                \/\/ be a socket as well). Such cases need to be handled on a higher level.\n+                super.beforeCheckpoint(context);\n+            }\n+        }\n+\n+        @Override\n+        protected void closeBeforeCheckpoint(OpenResourcePolicies.Policy policy) throws IOException {\n+            try {\n+                offset = position();\n+            } catch (IOException e) {\n+                \/\/ We might get IOException from native code when lseeking a named pipe.\n+                offset = 0;\n+            }\n+            \/\/ Calling close method means that the channel would be closed as well,\n+            \/\/ but we cannot reopen it and this is exposed (so we cannot recycle it).\n+            \/\/ Therefore, if the application uses it before this is reopened it might\n+            \/\/ face exceptions due to invalid FD; since closing must be explicitly\n+            \/\/ requested via policy this is acceptable.\n+            synchronized (closeLock) {\n+                if (closed) {\n+                    return;\n+                }\n+                closed = true;\n+            }\n+            fd.closeAll(new Closeable() {\n+                public void close() throws IOException {\n+                    fd.close();\n+                }\n+            });\n+        }\n+\n+        @Override\n+        protected void reopenAfterRestore(OpenResourcePolicies.Policy policy) throws IOException {\n+            synchronized (closeLock) {\n+                open(path);\n+                if (offset > 0) {\n+                    skip(offset);\n+                }\n+                FileInputStream.this.closed = false;\n+                FileCleanable.register(fd);\n+            }\n+        }\n+    };\n+\n","filename":"src\/java.base\/share\/classes\/java\/io\/FileInputStream.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -29,0 +29,8 @@\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKResource;\n+import jdk.internal.crac.OpenResourcePolicies;\n@@ -98,0 +106,10 @@\n+    \/**\n+     * When the file is opened in non-append mode we need to check position\n+     * through the {@link #channel} when handling the file descriptor policy;\n+     * this needs to be independent of the regular resource as we need to\n+     * ensure initialization of the channel before FD priority class.\n+     * This field being <code>null<\/code> means that the file is opened in\n+     * append-only mode and does not need to track the position.\n+     *\/\n+    private final EnsureChannelResource channelResource;\n+\n@@ -235,0 +253,5 @@\n+        if (append) {\n+            channelResource = null;\n+        } else {\n+            channelResource = new EnsureChannelResource();\n+        }\n@@ -274,0 +297,2 @@\n+        \/\/ We don't have path information and won't reopen the file\n+        this.channelResource = null;\n@@ -283,1 +308,1 @@\n-    private native void open0(String name, boolean append)\n+    private native void open0(String name, boolean append, boolean truncate)\n@@ -294,1 +319,1 @@\n-        open0(name, append);\n+        open0(name, append, !append);\n@@ -460,1 +485,2 @@\n-    JDKFileResource resource = new JDKFileResource() {\n+    @SuppressWarnings(\"unused\")\n+    private final JDKFileResource resource = new JDKFileResource() {\n@@ -470,0 +496,44 @@\n+\n+        @Override\n+        protected void closeBeforeCheckpoint(OpenResourcePolicies.Policy policy) throws IOException {\n+            if (channelResource != null) {\n+                FileChannel channel = getChannel();\n+                channelResource.position = channel.isOpen() ? channel.position() : -1;\n+            }\n+            \/\/ Calling close method means that the channel would be closed as well,\n+            \/\/ but we cannot reopen it and this is exposed (so we cannot recycle it).\n+            \/\/ Therefore, if the application uses it before this is reopened it might\n+            \/\/ face exceptions due to invalid FD; since closing must be explicitly\n+            \/\/ requested via policy this is acceptable.\n+            synchronized (closeLock) {\n+                if (closed) {\n+                    return;\n+                }\n+                closed = true;\n+            }\n+            fd.closeAll(new Closeable() {\n+                public void close() throws IOException {\n+                    fd.close();\n+                }\n+            });\n+        }\n+\n+        @Override\n+        protected void reopenAfterRestore(OpenResourcePolicies.Policy policy) throws IOException {\n+            assert path != null; \/\/ won't be reopened if it was not closed, and won't be closed without path\n+            synchronized (closeLock) {\n+                \/\/ We have been writing to a file, but it disappeared during checkpoint\n+                if (!Files.exists(Path.of(path))) {\n+                    throw new IOException(\"File \" + path + \" is not present during restore\");\n+                }\n+                if (channelResource == null) {\n+                    open(path, true);\n+                } else {\n+                    open0(path, false, false);\n+                    \/\/noinspection resource\n+                    getChannel().position(channelResource.position);\n+                }\n+                FileOutputStream.this.closed = false;\n+                FileCleanable.register(fd);\n+            }\n+        }\n@@ -471,0 +541,18 @@\n+\n+    private class EnsureChannelResource implements JDKResource {\n+        public long position;\n+\n+        EnsureChannelResource() {\n+            Core.Priority.PRE_FILE_DESCRIPTORS.getContext().register(this);\n+        }\n+\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+            \/\/ the channel is not used but we ensure its existence\n+            getChannel();\n+        }\n+\n+        @Override\n+        public void afterRestore(Context<? extends Resource> context) throws Exception {\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/io\/FileOutputStream.java","additions":91,"deletions":3,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.crac.OpenResourcePolicies;\n@@ -67,0 +68,1 @@\n+    private final int imode;\n@@ -84,1 +86,3 @@\n-    JDKFileResource resource = new JDKFileResource() {\n+    private final JDKFileResource resource = new JDKFileResource() {\n+        private long offset;\n+\n@@ -94,0 +98,17 @@\n+\n+        @Override\n+        protected void closeBeforeCheckpoint(OpenResourcePolicies.Policy policy) throws IOException {\n+            \/\/ We cannot synchronize this without making every other method call synchronized\n+            offset = getFilePointer();\n+            close();\n+        }\n+\n+        @Override\n+        protected void reopenAfterRestore(OpenResourcePolicies.Policy policy) throws IOException {\n+            synchronized (closeLock) {\n+                open(path, imode);\n+                seek(offset);\n+                RandomAccessFile.this.closed = false;\n+                FileCleanable.register(fd);\n+            }\n+        }\n@@ -272,0 +293,1 @@\n+        this.imode = imode;\n","filename":"src\/java.base\/share\/classes\/java\/io\/RandomAccessFile.java","additions":23,"deletions":1,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -28,0 +28,7 @@\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import jdk.crac.impl.CheckpointOpenResourceException;\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKFdResource;\n+import jdk.internal.crac.LoggerContainer;\n+import jdk.internal.crac.OpenResourcePolicies;\n@@ -38,0 +45,1 @@\n+import java.util.function.Supplier;\n@@ -816,0 +824,1 @@\n+        private final JDKFdResource resource;\n@@ -819,0 +828,1 @@\n+            resource = new PipeResource(this, fd);\n@@ -844,0 +854,33 @@\n+    static class PipeResource extends JDKFdResource {\n+        private final Closeable owner;\n+        private final FileDescriptor fd;\n+\n+        PipeResource(Closeable owner, FileDescriptor fd) {\n+            this.owner = owner;\n+            this.fd = fd;\n+        }\n+\n+        @SuppressWarnings(\"fallthrough\")\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+            OpenResourcePolicies.Policy policy = OpenResourcePolicies.find(false, OpenResourcePolicies.PIPE, null);\n+            String action = policy != null ? policy.action.toLowerCase() : \"error\";\n+            Supplier<Exception> exceptionSupplier = switch (action) {\n+                case \"error\":\n+                    yield  () -> new CheckpointOpenResourceException(owner.toString(), getStackTraceHolder());\n+                case \"close\":\n+                    owner.close();\n+                    \/\/ intentional fallthrough\n+                case \"ignore\":\n+                    if (Boolean.parseBoolean(policy.params.getOrDefault(\"warn\", \"true\"))) {\n+                        LoggerContainer.warn(\"{0} was not closed by the application. Use 'warn: false' in the policy to suppress this message.\", this);\n+                    }\n+                    yield NO_EXCEPTION;\n+                default:\n+                    throw new IllegalStateException(\"Unknown policy action \" + action + \" for \" + owner, null);\n+            };\n+            \/\/ FileInputStream does not claim when path is null\n+            Core.getClaimedFDs().claimFd(fd, this, exceptionSupplier, fd);\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Process.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -33,5 +33,8 @@\n-import java.util.Arrays;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.StringJoiner;\n+import java.util.*;\n+\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import jdk.internal.access.JavaIOFileDescriptorAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKResource;\n@@ -714,0 +717,2 @@\n+            \/\/ This creates a file descriptor but does not need own resource,\n+            \/\/ see PipelineResource.\n@@ -1275,11 +1280,18 @@\n-        try {\n-            Redirect prevOutput = null;\n-            for (int index = 0; index < builders.size(); index++) {\n-                ProcessBuilder builder = builders.get(index);\n-                Redirect[] redirects = builder.redirects();\n-                if (index > 0) {\n-                    \/\/ check the current Builder to see if it can take input from the previous\n-                    if (builder.redirectInput() != Redirect.PIPE) {\n-                        throw new IllegalArgumentException(\"builder redirectInput()\" +\n-                                \" must be PIPE except for the first builder: \"\n-                                + builder.redirectInput());\n+        \/\/ This resource helps us block the checkpoint until all subprocesses\n+        \/\/ are created; after that we won't need the FileDescriptors and can safely\n+        \/\/ close these.\n+        PipelineResource pipelineResource = new PipelineResource();\n+        synchronized (pipelineResource) {\n+            try (pipelineResource) {\n+                Redirect prevOutput = null;\n+                for (int index = 0; index < builders.size(); index++) {\n+                    ProcessBuilder builder = builders.get(index);\n+                    Redirect[] redirects = builder.redirects();\n+                    if (index > 0) {\n+                        \/\/ check the current Builder to see if it can take input from the previous\n+                        if (builder.redirectInput() != Redirect.PIPE) {\n+                            throw new IllegalArgumentException(\"builder redirectInput()\" +\n+                                    \" must be PIPE except for the first builder: \"\n+                                    + builder.redirectInput());\n+                        }\n+                        redirects[0] = prevOutput;\n@@ -1287,8 +1299,10 @@\n-                    redirects[0] = prevOutput;\n-                }\n-                if (index < numBuilders - 1) {\n-                    \/\/ check all but the last stage has output = PIPE\n-                    if (builder.redirectOutput() != Redirect.PIPE) {\n-                        throw new IllegalArgumentException(\"builder redirectOutput()\" +\n-                                \" must be PIPE except for the last builder: \"\n-                                + builder.redirectOutput());\n+                    if (index < numBuilders - 1) {\n+                        \/\/ check all but the last stage has output = PIPE\n+                        if (builder.redirectOutput() != Redirect.PIPE) {\n+                            throw new IllegalArgumentException(\"builder redirectOutput()\" +\n+                                    \" must be PIPE except for the last builder: \"\n+                                    + builder.redirectOutput());\n+                        }\n+                        RedirectPipeImpl redirectPipe = new RedirectPipeImpl();\n+                        redirects[1] = redirectPipe;  \/\/ placeholder for new output\n+                        pipelineResource.addRedirect(redirectPipe);\n@@ -1296,1 +1310,2 @@\n-                    redirects[1] = new RedirectPipeImpl();  \/\/ placeholder for new output\n+                    processes.add(builder.start(redirects));\n+                    prevOutput = redirects[1];\n@@ -1298,2 +1313,12 @@\n-                processes.add(builder.start(redirects));\n-                prevOutput = redirects[1];\n+            } catch (Exception ex) {\n+                \/\/ Cleanup processes already started\n+                processes.forEach(Process::destroyForcibly);\n+                processes.forEach(p -> {\n+                    try {\n+                        p.waitFor();        \/\/ Wait for it to exit\n+                    } catch (InterruptedException ie) {\n+                        \/\/ If interrupted; continue with next Process\n+                        Thread.currentThread().interrupt();\n+                    }\n+                });\n+                throw ex;\n@@ -1301,12 +1326,0 @@\n-        } catch (Exception ex) {\n-            \/\/ Cleanup processes already started\n-            processes.forEach(Process::destroyForcibly);\n-            processes.forEach(p -> {\n-                try {\n-                    p.waitFor();        \/\/ Wait for it to exit\n-                } catch (InterruptedException ie) {\n-                    \/\/ If interrupted; continue with next Process\n-                    Thread.currentThread().interrupt();\n-                }\n-            });\n-            throw ex;\n@@ -1316,0 +1329,32 @@\n+\n+    private static class PipelineResource implements JDKResource, AutoCloseable {\n+        private static final JavaIOFileDescriptorAccess fdAccess = SharedSecrets.getJavaIOFileDescriptorAccess();\n+        private final List<RedirectPipeImpl> redirects = new ArrayList<>();\n+\n+        public PipelineResource() {\n+            Core.Priority.FILE_DESCRIPTORS.getContext().register(this);\n+        }\n+\n+        @Override\n+        public synchronized void beforeCheckpoint(Context<? extends Resource> context) {\n+            \/\/ Noop, but this method is synchronized\n+            assert redirects.isEmpty();\n+        }\n+\n+        @Override\n+        public void afterRestore(Context<? extends Resource> context) {\n+        }\n+\n+        public void addRedirect(RedirectPipeImpl redirect) {\n+            this.redirects.add(redirect);\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+            \/\/ The file descriptors won't be used by this process\n+            for (RedirectPipeImpl r : redirects) {\n+                fdAccess.close(r.getFd());\n+            }\n+            redirects.clear();\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ProcessBuilder.java","additions":84,"deletions":39,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -28,0 +28,3 @@\n+import jdk.internal.crac.JDKSocketResource;\n+import sun.nio.ch.Net;\n+\n@@ -75,0 +78,23 @@\n+    @SuppressWarnings(\"unused\")\n+    private final JDKSocketResource resource = new JDKSocketResource(this) {\n+        @Override\n+        protected FileDescriptor getFD() {\n+            return fd;\n+        }\n+\n+        @Override\n+        protected SocketAddress localAddress() throws IOException {\n+            return Net.localAddress(fd);\n+        }\n+\n+        @Override\n+        protected SocketAddress remoteAddress() {\n+            return null;\n+        }\n+\n+        @Override\n+        protected void closeBeforeCheckpoint() {\n+            disconnect();\n+        }\n+    };\n+\n","filename":"src\/java.base\/share\/classes\/java\/net\/DatagramSocketImpl.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -37,6 +37,1 @@\n-import jdk.crac.Context;\n-import jdk.crac.Resource;\n-import jdk.crac.impl.CheckpointOpenSocketException;\n-import jdk.internal.crac.Core;\n-import jdk.internal.crac.ClaimedFDs;\n-import jdk.internal.crac.JDKFdResource;\n+import jdk.internal.crac.JDKSocketResource;\n@@ -45,0 +40,1 @@\n+import sun.nio.ch.Net;\n@@ -113,1 +109,2 @@\n-    private class SocketResource extends JDKFdResource {\n+    @SuppressWarnings(\"unused\")\n+    private final JDKSocketResource resource = new JDKSocketResource(this) {\n@@ -115,10 +112,12 @@\n-        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n-            ClaimedFDs claimedFDs = Core.getClaimedFDs();\n-            SocketImpl socket = SocketImpl.this;\n-            claimedFDs.claimFd(\n-                fd,\n-                socket,\n-                () -> new CheckpointOpenSocketException(\n-                    socket.toString(),\n-                    getStackTraceHolder()),\n-                fd);\n+        protected FileDescriptor getFD() {\n+            return fd;\n+        }\n+\n+        @Override\n+        protected SocketAddress localAddress() throws IOException {\n+            return Net.localAddress(fd);\n+        }\n+\n+        @Override\n+        protected SocketAddress remoteAddress() {\n+            return new InetSocketAddress(address, port);\n@@ -126,1 +125,0 @@\n-    };\n@@ -128,1 +126,5 @@\n-    private final SocketResource socketResource = new SocketResource();\n+        @Override\n+        protected void closeBeforeCheckpoint() throws IOException {\n+            close();\n+        }\n+    };\n","filename":"src\/java.base\/share\/classes\/java\/net\/SocketImpl.java","additions":21,"deletions":19,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -74,0 +74,5 @@\n+\n+        @Override\n+        public String toString() {\n+            return \"{fd=\" + fd + \", claimer=\" + claimer + '}';\n+        }\n@@ -91,2 +96,0 @@\n-        Objects.requireNonNull(supplier);\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/ClaimedFDs.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+        PRE_FILE_DESCRIPTORS(new BlockingOrderedContext<>()),\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/Core.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -7,0 +7,2 @@\n+import java.util.function.Supplier;\n+\n@@ -8,1 +10,1 @@\n-    private static final String COLLECT_FD_STACKTRACES_PROPERTY = \"jdk.crac.collect-fd-stacktraces\";\n+    public static final String COLLECT_FD_STACKTRACES_PROPERTY = \"jdk.crac.collect-fd-stacktraces\";\n@@ -15,0 +17,8 @@\n+    \/\/ No lambdas during clinit...\n+    protected static Supplier<Exception> NO_EXCEPTION = new Supplier<Exception>() {\n+        @Override\n+        public Exception get() {\n+            return null;\n+        }\n+    };\n+\n@@ -29,0 +39,1 @@\n+        OpenResourcePolicies.ensureRegistered();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/JDKFdResource.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -6,0 +6,1 @@\n+import jdk.crac.impl.CheckpointOpenResourceException;\n@@ -10,0 +11,3 @@\n+import java.io.IOException;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Path;\n@@ -17,0 +21,16 @@\n+    boolean closed;\n+    boolean error;\n+\n+    public static OpenResourcePolicies.Policy findPolicy(boolean isRestore, String pathStr) {\n+        Path path = Path.of(pathStr);\n+        return OpenResourcePolicies.find(isRestore,\n+                OpenResourcePolicies.FILE, props -> {\n+                    String policyPath = props.get(\"path\");\n+                    if (policyPath == null) {\n+                        return true; \/\/ missing path matches all files\n+                    } else {\n+                        return FileSystems.getDefault().getPathMatcher(\"glob:\" + policyPath).matches(path);\n+                    }\n+                });\n+    }\n+\n@@ -19,0 +39,2 @@\n+    protected abstract void closeBeforeCheckpoint(OpenResourcePolicies.Policy policy) throws IOException;\n+    protected abstract void reopenAfterRestore(OpenResourcePolicies.Policy policy) throws IOException;\n@@ -20,1 +42,1 @@\n-    private boolean matchClasspath(String path) {\n+    protected boolean matchClasspath(String path) {\n@@ -29,0 +51,1 @@\n+    @SuppressWarnings(\"fallthrough\")\n@@ -37,2 +60,7 @@\n-        Supplier<Exception> exceptionSupplier;\n-        if (matchClasspath(path)) {\n+        OpenResourcePolicies.Policy policy = findPolicy(false, path);\n+        String action = \"error\";\n+        String warn = \"false\";\n+        if (policy != null) {\n+            action = policy.action.toLowerCase();\n+            warn = policy.params.getOrDefault(\"warn\", \"true\");\n+        } else if (matchClasspath(path)) {\n@@ -40,3 +68,1 @@\n-            exceptionSupplier = () -> null;\n-        } else {\n-            exceptionSupplier = () -> new CheckpointOpenFileException(path, getStackTraceHolder());\n+            action = \"ignore\";\n@@ -44,1 +70,21 @@\n-\n+        Supplier<Exception> exceptionSupplier = switch (action) {\n+            case \"error\":\n+                error = true;\n+                yield () -> new CheckpointOpenFileException(path, getStackTraceHolder());\n+            case \"close\", \"reopen\":\n+                \/\/ Here we assume that the stream is idle; any concurrent access\n+                \/\/ will end with exceptions as the file-descriptors is invalidated\n+                try {\n+                    closeBeforeCheckpoint(policy);\n+                } catch (IOException e) {\n+                    throw new CheckpointOpenResourceException(\"Cannot close \" + path, e);\n+                }\n+                closed = true;\n+            case \"ignore\":\n+                if (Boolean.parseBoolean(warn)) {\n+                    LoggerContainer.warn(\"File {0} was not closed by the application. Use 'warn: false' in the policy to suppress this message.\", path);\n+                }\n+                yield NO_EXCEPTION;\n+            default:\n+                throw new IllegalStateException(\"Unknown policy action for path \" + path + \": \" + policy.action);\n+        };\n@@ -51,1 +97,8 @@\n-\n+        if (!closed || error) {\n+            return;\n+        }\n+        OpenResourcePolicies.Policy policy = findPolicy(true, getPath());\n+        if (policy != null && \"reopen\".equalsIgnoreCase(policy.action)) {\n+            reopenAfterRestore(policy);\n+            closed = false;\n+        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/JDKFileResource.java","additions":61,"deletions":8,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -0,0 +1,46 @@\n+package jdk.internal.crac;\n+\n+import jdk.crac.impl.CheckpointOpenSocketException;\n+\n+import java.io.IOException;\n+import java.net.*;\n+\n+public abstract class JDKSocketResource extends JDKSocketResourceBase {\n+\n+    private SocketAddress local;\n+    private SocketAddress remote;\n+\n+    public JDKSocketResource(Object owner) {\n+        super(owner);\n+    }\n+\n+    protected abstract SocketAddress localAddress() throws IOException;\n+    protected abstract SocketAddress remoteAddress() throws IOException;\n+\n+    @Override\n+    protected OpenResourcePolicies.Policy findPolicy(boolean isRestore) throws CheckpointOpenSocketException {\n+        if (!isRestore) {\n+            try {\n+                local = localAddress();\n+            } catch (IOException e) {\n+                throw new CheckpointOpenSocketException(\"Cannot find local address for \" + owner, e);\n+            }\n+            try {\n+                remote = remoteAddress();\n+            } catch (IOException e) {\n+                throw new CheckpointOpenSocketException(\"Cannot find remote address for \" + owner, e);\n+            }\n+        }\n+        var localMatcher = getMatcher(local, \"localAddress\", \"localPort\", \"localPath\");\n+        var remoteMatcher = getMatcher(remote, \"remoteAddress\", \"remotePort\", \"remotePath\");\n+        return OpenResourcePolicies.find(isRestore, OpenResourcePolicies.SOCKET,\n+                params -> localMatcher.test(params) && remoteMatcher.test(params));\n+    }\n+\n+    @Override\n+    protected void reset() {\n+        \/\/ Allow garbage collection\n+        local = null;\n+        remote = null;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/JDKSocketResource.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -0,0 +1,154 @@\n+package jdk.internal.crac;\n+\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import jdk.crac.impl.CheckpointOpenSocketException;\n+\n+import java.io.FileDescriptor;\n+import java.io.IOException;\n+import java.net.*;\n+import java.nio.file.FileSystems;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+import java.util.function.Supplier;\n+\n+public abstract class JDKSocketResourceBase extends JDKFdResource {\n+    protected final Object owner;\n+    private boolean valid;\n+    private boolean error;\n+\n+    public JDKSocketResourceBase(Object owner) {\n+        this.owner = owner;\n+    }\n+\n+    protected abstract FileDescriptor getFD();\n+    protected abstract void closeBeforeCheckpoint() throws IOException;\n+    protected abstract OpenResourcePolicies.Policy findPolicy(boolean isRestore) throws CheckpointOpenSocketException;\n+\n+    @SuppressWarnings(\"fallthrough\")\n+    @Override\n+    public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+        FileDescriptor fd = getFD();\n+        if (fd == null) {\n+            return;\n+        }\n+        synchronized (fd) {\n+            if (!(valid = fd.valid())) {\n+                return;\n+            }\n+            OpenResourcePolicies.Policy policy = findPolicy(false);\n+            String action = policy == null ? \"error\" : policy.action.toLowerCase();\n+            Supplier<Exception> exceptionSupplier = switch (action) {\n+                case \"error\":\n+                    error = true;\n+                    yield () -> new CheckpointOpenSocketException(owner.toString(), getStackTraceHolder());\n+                case \"close\", \"reopen\":\n+                    try {\n+                        closeBeforeCheckpoint();\n+                    } catch (IOException e) {\n+                        throw new CheckpointOpenSocketException(\"Cannot close \" + owner, e);\n+                    }\n+                    \/\/ intentional fallthrough\n+                case \"ignore\":\n+                    if (Boolean.parseBoolean(policy.params.getOrDefault(\"warn\", \"true\"))) {\n+                        LoggerContainer.warn(\"Socket {0} was not closed by the application. Use 'warn: false' in the policy to suppress this message.\", owner);\n+                    }\n+                    yield NO_EXCEPTION;\n+                default:\n+                    throw new IllegalStateException(\"Unknown policy action \" + action + \" for \" + owner, null);\n+            };\n+            Core.getClaimedFDs().claimFd(fd, owner, exceptionSupplier, fd);\n+        }\n+    }\n+\n+    protected Predicate<Map<String, String>> getMatcher(SocketAddress addr, String addressKey, String portKey, String pathKey) {\n+        return params -> {\n+            String family = params.get(\"family\");\n+            if (family != null && addr != null) {\n+                switch (family.toLowerCase()) {\n+                    case \"ipv6\", \"inet6\" -> {\n+                        if (!(addr instanceof InetSocketAddress inetAddr)) {\n+                            return false;\n+                        } else if (!(inetAddr.getAddress() instanceof Inet6Address)) {\n+                            return false;\n+                        }\n+                    }\n+                    case \"ipv4\", \"inet4\" -> {\n+                        if (!(addr instanceof InetSocketAddress inetAddr)) {\n+                            return false;\n+                        } else if (!(inetAddr.getAddress() instanceof Inet4Address)) {\n+                            return false;\n+                        }\n+                    }\n+                    case \"ip\", \"inet\" -> {\n+                        if (!(addr instanceof InetSocketAddress inetAddr)) {\n+                            return false;\n+                        }\n+                    }\n+                    case \"unix\" -> {\n+                        if (!(addr instanceof UnixDomainSocketAddress)) {\n+                            return false;\n+                        }\n+                    }\n+                    default -> throw new IllegalArgumentException(\"Unknown family: \" + family);\n+                }\n+            }\n+            String cfgAddress = params.get(addressKey);\n+            String cfgPort = params.get(portKey);\n+            String cfgPath = params.get(pathKey);\n+            if (cfgAddress != null || cfgPort != null) {\n+                if (!(addr instanceof InetSocketAddress inetAddr)) {\n+                    return false;\n+                }\n+                if (cfgAddress != null && !\"*\".equals(cfgAddress)) {\n+                    try {\n+                        if (!InetAddress.getByName(cfgAddress).equals(inetAddr.getAddress())) {\n+                            return false;\n+                        }\n+                    } catch (UnknownHostException e) {\n+                        return false;\n+                    }\n+                }\n+                if (cfgPort != null && !\"*\".equals(cfgPort)) {\n+                    return Integer.parseInt(cfgPort) == inetAddr.getPort();\n+                }\n+                return true;\n+            } else if (cfgPath != null) {\n+                if (!(addr instanceof UnixDomainSocketAddress unixAddr)) {\n+                    return false;\n+                }\n+                return FileSystems.getDefault().getPathMatcher(\"glob:\" + cfgPath)\n+                        .matches(unixAddr.getPath());\n+            } else {\n+                return true;\n+            }\n+        };\n+    }\n+\n+    @SuppressWarnings(\"fallthrough\")\n+    @Override\n+    public void afterRestore(Context<? extends Resource> context) throws Exception {\n+        \/\/ Don't do anything when we've already failed\n+        if (!valid || error) {\n+            return;\n+        }\n+        FileDescriptor fd = getFD();\n+        if (fd == null) {\n+            return;\n+        }\n+        synchronized (fd) {\n+            OpenResourcePolicies.Policy policy = findPolicy(true);\n+            String action = policy == null ? \"error\" : policy.action;\n+            try {\n+                \/\/ FIXME: implement\n+                if (action.equals(\"reopen\")) {\n+                    throw new UnsupportedOperationException(\"Policy \" + policy.type + \" not implemented\");\n+                }\n+            } finally {\n+                reset();\n+            }\n+        }\n+    }\n+\n+    protected abstract void reset();\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/JDKSocketResourceBase.java","additions":154,"deletions":0,"binary":false,"changes":154,"status":"added"},{"patch":"@@ -22,0 +22,4 @@\n+    public static void warn(String fmt, Object... params) {\n+        logger.log(System.Logger.Level.WARNING, fmt, params);\n+    }\n+\n@@ -26,0 +30,4 @@\n+    public static void error(String fmt, Object... params) {\n+        logger.log(System.Logger.Level.ERROR, fmt, params);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/LoggerContainer.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,178 @@\n+package jdk.internal.crac;\n+\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import sun.security.action.GetPropertyAction;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.util.*;\n+import java.util.function.Predicate;\n+\n+public class OpenResourcePolicies {\n+    public static final String PROPERTY = \"jdk.crac.resource-policies\";\n+    public static final String FILE = \"file\";\n+    public static final String PIPE = \"pipe\";\n+    public static final String SOCKET = \"socket\";\n+\n+    private enum State {\n+        NOT_LOADED,\n+        LOADED_FOR_CHECKPOINT,\n+        LOADED_FOR_RESTORE\n+    }\n+\n+    private static final Map<String, List<Policy>> policies = new HashMap<>();\n+    private static State state = State.NOT_LOADED;\n+\n+    private static final JDKResource resource = new JDKResource() {\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+            \/\/ We cannot lazily wait until the FILE_DESCRIPTORS priority\n+            \/\/ because we need to open a file, too.\n+            loadPolicies(false);\n+        }\n+\n+        @Override\n+        public void afterRestore(Context<? extends Resource> context) {\n+            policies.clear();\n+            state = State.NOT_LOADED;\n+        }\n+    };\n+\n+    static {\n+        Core.Priority.NORMAL.getContext().register(resource);\n+    }\n+\n+    static void ensureRegistered() {\n+        \/\/ noop\n+    }\n+\n+    private static synchronized void loadPolicies(boolean isRestore) {\n+        if (state == State.LOADED_FOR_RESTORE || (!isRestore && state == State.LOADED_FOR_CHECKPOINT)) {\n+            return;\n+        }\n+        \/\/ prevent loading recursively\n+        state = isRestore ? State.LOADED_FOR_RESTORE : State.LOADED_FOR_CHECKPOINT;\n+\n+        String file = GetPropertyAction.privilegedGetProperty(PROPERTY);\n+        if (file == null) {\n+            return;\n+        }\n+        \/\/ The newer policies have more priority; we'll copy the old ones and\n+        \/\/ append them later on\n+        Map<String, List<Policy>> old = Map.copyOf(policies);\n+        policies.clear();\n+\n+        File f = new File(file);\n+        if (!f.exists()) {\n+            throw new ConfigurationException(\"File \" + file + \" used in property \" + PROPERTY + \" does not exist\");\n+        } else if (!f.isFile() || !f.canRead()) {\n+            throw new ConfigurationException(\"File \" + file + \" used in property \" + PROPERTY + \" is not a regular file or cannot be read.\");\n+        }\n+        String type = null, action = null;\n+        Map<String, String> params = new HashMap<>();\n+        int currentLine = 1, policyStart = 1;\n+        try {\n+            for (String line : Files.readAllLines(f.toPath())) {\n+                line = line.trim();\n+                if (line.startsWith(\"#\")) {\n+                    continue;\n+                } else if (\"---\".equals(line)) {\n+                    if (type == null && action == null && params.isEmpty()) {\n+                        \/\/ ignore empty policies\n+                        policyStart = currentLine + 1;\n+                        continue;\n+                    }\n+                    addPolicy(type, action, params, file, policyStart, currentLine);\n+                    type = null;\n+                    action = null;\n+                    params = new HashMap<>();\n+                    policyStart = currentLine + 1;\n+                    continue;\n+                }\n+                int index = line.indexOf(\": \");\n+                if (index < 0) {\n+                    throw new ConfigurationException(invalid(file, policyStart, currentLine, \"cannot parse line \" + currentLine + \": \" + line));\n+                }\n+                String key = line.substring(0, index).trim();\n+                String value = line.substring(index + 2).trim();\n+                switch (key.toLowerCase()) {\n+                    case \"type\" -> type = value;\n+                    case \"action\" -> action = value;\n+                    default -> params.put(key, value);\n+                }\n+                ++currentLine;\n+            }\n+            if (type != null || action != null || !params.isEmpty()) {\n+                addPolicy(type, action, params, file, policyStart, currentLine);\n+            }\n+        } catch (IOException e) {\n+            throw new ConfigurationException(\"Cannot read file \" + file + \" used in property \" + PROPERTY, e);\n+        }\n+\n+        \/\/ Add the old policies after the newly loaded ones\n+        for (var entry : old.entrySet()) {\n+            List<Policy> newList = policies.get(entry.getKey());\n+            if (newList == null) {\n+                policies.put(entry.getKey(), entry.getValue());\n+            } else {\n+                newList.addAll(entry.getValue());\n+            }\n+        }\n+    }\n+\n+    private static void addPolicy(String type, String action, Map<String, String> params, String file, int from, int to) {\n+        if (type == null) {\n+            throw new ConfigurationException(invalid(file, from, to, \"no 'type'\"));\n+        } else if (action == null) {\n+            throw new ConfigurationException(invalid(file, from, to, \"no 'action'\"));\n+        }\n+        type = type.trim().toLowerCase();\n+        action = action.trim();\n+        policies.computeIfAbsent(type, t -> new ArrayList<>()).add(new Policy(type, action, params));\n+    }\n+\n+    private static String invalid(String file, int from, int to, String why) {\n+        return \"Invalid rule in policies file \" + file + \" on lines \" + from + \"-\" + to + \": \" + why;\n+    }\n+\n+    public static Policy find(boolean isRestore, String type, Predicate<Map<String, String>> filter) {\n+        loadPolicies(isRestore);\n+        List<Policy> list = policies.get(type);\n+        if (list == null) {\n+            return null;\n+        }\n+        if (filter == null) {\n+            return list.get(0);\n+        }\n+        return list.stream().filter(p -> filter.test(p.params)).findFirst().orElse(null);\n+    }\n+\n+    public static class Policy {\n+        \/\/ file, socket, pipe...\n+        public final String type;\n+        \/\/ The policy action\n+        public final String action;\n+        \/\/ Both filtering and action customization\n+        public final Map<String, String> params;\n+\n+        public Policy(String type, String action, Map<String, String> params) {\n+            this.type = type;\n+            this.action = action;\n+            this.params = Collections.unmodifiableMap(params);\n+        }\n+    }\n+\n+    private static class ConfigurationException extends RuntimeException {\n+        private static final long serialVersionUID = 6833568262773571378L;\n+\n+        public ConfigurationException(String message) {\n+            super(message);\n+        }\n+\n+        public ConfigurationException(String message, Throwable cause) {\n+            super(message, cause);\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/OpenResourcePolicies.java","additions":178,"deletions":0,"binary":false,"changes":178,"status":"added"},{"patch":"@@ -162,0 +162,2 @@\n+    exports jdk.internal.crac to\n+        jdk.sctp;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,5 @@\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import jdk.internal.crac.OpenResourcePolicies;\n+import jdk.internal.crac.JDKFileResource;\n+\n@@ -49,0 +54,29 @@\n+    private final JDKFileResource resource = new JDKFileResource() {\n+        @Override\n+        protected FileDescriptor getFD() {\n+            return fdObj;\n+        }\n+\n+        @Override\n+        protected String getPath() {\n+            \/\/ TODO: we don't have information about the path without introspecting FD\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+            if (isOpen()) {\n+                super.beforeCheckpoint(context);\n+            }\n+        }\n+\n+        @Override\n+        protected void closeBeforeCheckpoint(OpenResourcePolicies.Policy policy) throws IOException {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        protected void reopenAfterRestore(OpenResourcePolicies.Policy policy) throws IOException {\n+            throw new UnsupportedOperationException();\n+        }\n+    };\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/AsynchronousFileChannelImpl.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -41,0 +41,2 @@\n+\n+import jdk.internal.crac.JDKSocketResource;\n@@ -53,0 +55,1 @@\n+    private final JDKSocketResource resource;\n@@ -73,0 +76,21 @@\n+        this.resource = new JDKSocketResource(this) {\n+            @Override\n+            protected FileDescriptor getFD() {\n+                return fd;\n+            }\n+\n+            @Override\n+            protected SocketAddress localAddress() {\n+                return localAddress;\n+            }\n+\n+            @Override\n+            protected SocketAddress remoteAddress() {\n+                return null;\n+            }\n+\n+            @Override\n+            protected void closeBeforeCheckpoint() throws IOException {\n+                close();\n+            }\n+        };\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/AsynchronousServerSocketChannelImpl.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -41,0 +41,2 @@\n+\n+import jdk.internal.crac.JDKSocketResource;\n@@ -53,0 +55,2 @@\n+    @SuppressWarnings(\"unused\")\n+    private final JDKSocketResource resource = new Resource();\n@@ -607,0 +611,26 @@\n+\n+    private class Resource extends JDKSocketResource {\n+        public Resource() {\n+            super(AsynchronousSocketChannelImpl.this);\n+        }\n+\n+        @Override\n+        protected FileDescriptor getFD() {\n+            return fd;\n+        }\n+\n+        @Override\n+        protected SocketAddress localAddress() {\n+            return localAddress;\n+        }\n+\n+        @Override\n+        protected SocketAddress remoteAddress() {\n+            return remoteAddress;\n+        }\n+\n+        @Override\n+        protected void closeBeforeCheckpoint() throws IOException {\n+            close();\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/AsynchronousSocketChannelImpl.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -72,0 +72,1 @@\n+import jdk.internal.crac.JDKSocketResource;\n@@ -97,0 +98,1 @@\n+    private final JDKSocketResource resource = new Resource();\n@@ -1891,0 +1893,26 @@\n+\n+    private class Resource extends JDKSocketResource {\n+        public Resource() {\n+            super(DatagramChannelImpl.this);\n+        }\n+\n+        @Override\n+        protected FileDescriptor getFD() {\n+            return fd;\n+        }\n+\n+        @Override\n+        protected SocketAddress localAddress() {\n+            return localAddress;\n+        }\n+\n+        @Override\n+        protected SocketAddress remoteAddress() {\n+            return remoteAddress;\n+        }\n+\n+        @Override\n+        protected void closeBeforeCheckpoint() throws IOException {\n+            close();\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/DatagramChannelImpl.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -47,0 +47,3 @@\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import jdk.internal.crac.OpenResourcePolicies;\n@@ -49,0 +52,1 @@\n+import jdk.internal.crac.JDKFileResource;\n@@ -73,0 +77,34 @@\n+    private final JDKFileResource resource = new JDKFileResource() {\n+        @Override\n+        protected FileDescriptor getFD() {\n+            return fd;\n+        }\n+\n+        @Override\n+        protected String getPath() {\n+            return path;\n+        }\n+\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+            if (!isOpen() || path == null) {\n+                return;\n+            } else if (parent != null) {\n+                \/\/ This FileChannel is managed by a higher level object that\n+                \/\/ will handle the provided file descriptor on its own.\n+                return;\n+            }\n+            super.beforeCheckpoint(context);\n+        }\n+\n+        @Override\n+        protected void closeBeforeCheckpoint(OpenResourcePolicies.Policy policy) throws IOException {\n+            close();\n+        }\n+\n+        @Override\n+        protected void reopenAfterRestore(OpenResourcePolicies.Policy policy) throws IOException {\n+            \/\/ implementation is possible but non-trivial\n+            throw new UnsupportedOperationException();\n+        }\n+    };\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/FileChannelImpl.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -54,6 +54,0 @@\n-import jdk.crac.Context;\n-import jdk.crac.Resource;\n-import jdk.crac.impl.CheckpointOpenSocketException;\n-import jdk.internal.crac.ClaimedFDs;\n-import jdk.internal.crac.Core;\n-import jdk.internal.crac.JDKFdResource;\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/NioSocketImpl.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+import jdk.internal.crac.JDKSocketResource;\n@@ -78,0 +79,1 @@\n+    private final Resource resource = new Resource();\n@@ -405,1 +407,0 @@\n-\n@@ -730,0 +731,26 @@\n+\n+    private class Resource extends JDKSocketResource {\n+        public Resource() {\n+            super(ServerSocketChannelImpl.this);\n+        }\n+\n+        @Override\n+        protected FileDescriptor getFD() {\n+            return fd;\n+        }\n+\n+        @Override\n+        protected SocketAddress localAddress() {\n+            return localAddress;\n+        }\n+\n+        @Override\n+        protected SocketAddress remoteAddress() {\n+            return null;\n+        }\n+\n+        @Override\n+        protected void closeBeforeCheckpoint() throws IOException {\n+            close();\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/ServerSocketChannelImpl.java","additions":28,"deletions":1,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+import jdk.internal.crac.JDKSocketResource;\n@@ -84,0 +85,1 @@\n+    private final Resource resource = new Resource();\n@@ -1489,0 +1491,26 @@\n+\n+    private class Resource extends JDKSocketResource {\n+        public Resource() {\n+            super(SocketChannelImpl.this);\n+        }\n+\n+        @Override\n+        protected FileDescriptor getFD() {\n+            return fd;\n+        }\n+\n+        @Override\n+        protected SocketAddress localAddress() {\n+            return localAddress;\n+        }\n+\n+        @Override\n+        protected SocketAddress remoteAddress() {\n+            return remoteAddress;\n+        }\n+\n+        @Override\n+        protected void closeBeforeCheckpoint() throws IOException {\n+            close();\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/SocketChannelImpl.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n-import java.util.Properties;\n@@ -51,0 +50,1 @@\n+import jdk.internal.crac.JDKFdResource;\n@@ -625,0 +625,2 @@\n+        private final JDKFdResource resource;\n+\n@@ -626,1 +628,6 @@\n-            super(new FileOutputStream(newFileDescriptor(fd)));\n+            this(newFileDescriptor(fd));\n+        }\n+\n+        private ProcessPipeOutputStream(FileDescriptor fd) {\n+            super(new FileOutputStream(fd));\n+            resource = new PipeResource(this, fd);\n","filename":"src\/java.base\/unix\/classes\/java\/lang\/ProcessImpl.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -61,1 +61,4 @@\n-        Core.Priority.NORMAL.getContext().register(resourceProxy);\n+        \/\/ We cannot register using normal priority because other JDK resources\n+        \/\/ might read configuration files with this or later priority.\n+        \/\/ It's difficult to trigger static initialization outside the package.\n+        Core.Priority.PRE_FILE_DESCRIPTORS.getContext().register(resourceProxy);\n@@ -206,2 +209,4 @@\n-        fdAccess.markClosed(fd);\n-        close0(fd);\n+        \/\/ Originally this used fdAccess.markClosed() and close0() but leaving\n+        \/\/ the FD value set breaks JDKSocketResource (we don't want the extra\n+        \/\/ test if the FD resource has been marked).\n+        fdAccess.close(fd);\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/ch\/FileDispatcherImpl.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -28,0 +28,8 @@\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import jdk.crac.impl.CheckpointOpenResourceException;\n+import jdk.internal.crac.OpenResourcePolicies;\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKFdResource;\n+import jdk.internal.crac.LoggerContainer;\n+\n@@ -31,1 +39,2 @@\n-\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Supplier;\n@@ -38,2 +47,37 @@\n-    private final SourceChannel source;\n-    private final SinkChannel sink;\n+    private final SourceChannelImpl source;\n+    private final SinkChannelImpl sink;\n+    private final JDKFdResource resource = new JDKFdResource() {\n+        @SuppressWarnings(\"fallthrough\")\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+            OpenResourcePolicies.Policy policy = OpenResourcePolicies.find(false, OpenResourcePolicies.PIPE, null);\n+            String action = policy != null ? policy.action.toLowerCase() : \"error\";\n+            switch (action) {\n+                case \"error\":\n+                    \/\/ We will report the error only once\n+                    AtomicBoolean reported = new AtomicBoolean();\n+                    Supplier<Exception> supplier = () -> reported.getAndSet(true) ? null :\n+                            new CheckpointOpenResourceException(toString(), getStackTraceHolder());\n+                    Core.getClaimedFDs().claimFd(source.getFD(), this, supplier, source.getFD());\n+                    Core.getClaimedFDs().claimFd(sink.getFD(), this, supplier, sink.getFD());\n+                    break;\n+                case \"close\":\n+                    source.close();\n+                    sink.close();\n+                    \/\/ intentional fallthrough\n+                case \"ignore\":\n+                    if (Boolean.parseBoolean(policy.params.getOrDefault(\"warn\", \"true\"))) {\n+                        LoggerContainer.warn(\"{0} was not closed by the application. Use 'warn: false' in the policy to suppress this message.\", this);\n+                    }\n+                    Core.getClaimedFDs().claimFd(source.getFD(), this, NO_EXCEPTION, source.getFD());\n+                    Core.getClaimedFDs().claimFd(sink.getFD(), this, NO_EXCEPTION, sink.getFD());\n+                default:\n+                    throw new IllegalStateException(\"Unknown policy action \" + action + \" for \" + PipeImpl.this, null);\n+            }\n+        }\n+    };\n+\n+    @Override\n+    public String toString() {\n+        return \"Pipe \" + source.getFDVal() + \" -> \" + sink.getFDVal();\n+    }\n@@ -60,1 +104,0 @@\n-\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/ch\/PipeImpl.java","additions":47,"deletions":4,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-                                    jstring path, jboolean append) {\n+                                    jstring path, jboolean append, jboolean truncate) {\n@@ -59,1 +59,1 @@\n-             O_WRONLY | O_CREAT | (append ? O_APPEND : O_TRUNC));\n+             O_WRONLY | O_CREAT | (append ? O_APPEND : 0) | (truncate ? O_TRUNC : 0));\n","filename":"src\/java.base\/unix\/native\/libjava\/FileOutputStream_md.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -194,1 +194,0 @@\n-\n","filename":"src\/java.base\/unix\/native\/libnio\/ch\/UnixDomainSockets.c","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-                                    jstring path, jboolean append) {\n+                                    jstring path, jboolean append, jboolean truncate) {\n@@ -60,1 +60,1 @@\n-             O_WRONLY | O_CREAT | (append ? O_APPEND : O_TRUNC));\n+             O_WRONLY | O_CREAT | (append ? O_APPEND : 0) | (truncate ? O_TRUNC : 0));\n","filename":"src\/java.base\/windows\/native\/libjava\/FileOutputStream_md.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -81,0 +81,25 @@\n+    private final SctpResource resource = new SctpResource(this) {\n+        @Override\n+        protected FileDescriptor getFD() {\n+            return fd;\n+        }\n+\n+        @Override\n+        protected void closeBeforeCheckpoint() throws IOException {\n+            close();\n+        }\n+\n+        @Override\n+        protected Set<SocketAddress> getRemoteAddresses() {\n+            synchronized (stateLock) {\n+                return new HashSet<>(remoteAddresses);\n+            }\n+        }\n+\n+        @Override\n+        protected HashSet<InetSocketAddress> getLocalAddresses() {\n+            synchronized (stateLock) {\n+                return new HashSet<>(localAddresses);\n+            }\n+        }\n+    };\n","filename":"src\/jdk.sctp\/unix\/classes\/sun\/nio\/ch\/sctp\/SctpChannelImpl.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -44,0 +44,2 @@\n+import java.util.stream.Collectors;\n+\n@@ -77,0 +79,34 @@\n+    private final SctpResource resource = new SctpResource(this) {\n+        @Override\n+        protected Set<SocketAddress> getRemoteAddresses() {\n+            synchronized (stateLock) {\n+                if (!isOpen() || !isBound()) {\n+                    return Collections.emptySet();\n+                }\n+                return associationMap.keySet().stream().flatMap(a -> {\n+                    try {\n+                        return SctpMultiChannelImpl.this.getRemoteAddresses(a).stream();\n+                    } catch (IOException e) {\n+                        throw new RuntimeException(e);\n+                    }\n+                }).collect(Collectors.toSet());\n+            }\n+        }\n+\n+        @Override\n+        protected HashSet<InetSocketAddress> getLocalAddresses() {\n+            synchronized (stateLock) {\n+                return new HashSet<>(localAddresses);\n+            }\n+        }\n+\n+        @Override\n+        protected FileDescriptor getFD() {\n+            return fd;\n+        }\n+\n+        @Override\n+        protected void closeBeforeCheckpoint() throws IOException {\n+            close();\n+        }\n+    };\n","filename":"src\/jdk.sctp\/unix\/classes\/sun\/nio\/ch\/sctp\/SctpMultiChannelImpl.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -0,0 +1,51 @@\n+package sun.nio.ch.sctp;\n+\n+import jdk.internal.crac.OpenResourcePolicies;\n+import jdk.internal.crac.JDKSocketResourceBase;\n+\n+import java.io.IOException;\n+import java.net.InetSocketAddress;\n+import java.net.SocketAddress;\n+import java.nio.channels.spi.AbstractSelectableChannel;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+\n+abstract class SctpResource extends JDKSocketResourceBase {\n+    private Set<InetSocketAddress> localCopy;\n+    private Set<SocketAddress> remoteCopy;\n+\n+    public SctpResource(AbstractSelectableChannel sctpChannel) {\n+        super(sctpChannel);\n+    }\n+\n+    @Override\n+    protected OpenResourcePolicies.Policy findPolicy(boolean isRestore) {\n+        if (!isRestore) {\n+            localCopy = Set.copyOf(getLocalAddresses());\n+            remoteCopy = Set.copyOf(getRemoteAddresses());\n+        }\n+        List<Predicate<Map<String, String>>> localMatchers = localCopy.stream()\n+                .map(addr -> getMatcher(addr, \"localAddress\", \"localPort\", null)).toList();\n+        List<Predicate<Map<String, String>>> remoteMatchers = remoteCopy.stream()\n+                .map(addr -> getMatcher(addr, \"remoteAddress\", \"remotePort\", null)).toList();\n+        return OpenResourcePolicies.find(false, OpenResourcePolicies.SOCKET,\n+                params -> localMatchers.stream().anyMatch(matcher -> matcher.test(params)) &&\n+                        remoteMatchers.stream().anyMatch(matcher -> matcher.test(params)));\n+    }\n+\n+    @Override\n+    protected void reset() {\n+        localCopy = null;\n+        remoteCopy = null;\n+    }\n+\n+    @Override\n+    protected abstract void closeBeforeCheckpoint() throws IOException;\n+\n+    protected abstract Set<SocketAddress> getRemoteAddresses();\n+\n+    protected abstract HashSet<InetSocketAddress> getLocalAddresses();\n+}\n","filename":"src\/jdk.sctp\/unix\/classes\/sun\/nio\/ch\/sctp\/SctpResource.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -32,0 +32,1 @@\n+import java.net.StandardProtocolFamily;\n@@ -44,1 +45,1 @@\n-import sun.nio.ch.DirectBuffer;\n+import jdk.internal.crac.JDKSocketResource;\n@@ -51,1 +52,0 @@\n-import sun.nio.ch.Util;\n@@ -60,1 +60,0 @@\n-\n@@ -62,0 +61,23 @@\n+    private final SctpResource resource = new SctpResource(this) {\n+        @Override\n+        protected Set<SocketAddress> getRemoteAddresses() {\n+            return Collections.emptySet();\n+        }\n+\n+        @Override\n+        protected HashSet<InetSocketAddress> getLocalAddresses() {\n+            synchronized (stateLock) {\n+                return new HashSet<>(localAddresses);\n+            }\n+        }\n+\n+        @Override\n+        protected FileDescriptor getFD() {\n+            return fd;\n+        }\n+\n+        @Override\n+        protected void closeBeforeCheckpoint() throws IOException {\n+            close();\n+        }\n+    };\n","filename":"src\/jdk.sctp\/unix\/classes\/sun\/nio\/ch\/sctp\/SctpServerChannelImpl.java","additions":25,"deletions":3,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.Core;\n+import jdk.internal.crac.JDKFdResource;\n+import jdk.internal.crac.OpenResourcePolicies;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+import static jdk.test.lib.Asserts.*;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.crac:+open\n+ * @requires (os.family == \"linux\")\n+ * @build FDPolicyTestBase\n+ * @build CloseProcessPipeTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class CloseProcessPipeTest extends FDPolicyTestBase implements CracTest {\n+    @Override\n+    public void test() throws Exception {\n+        Path config = writeConfig(\"\"\"\n+                type: pipe\n+                action: close\n+                \"\"\");\n+        try {\n+            CracBuilder builder = new CracBuilder()\n+                    .javaOption(JDKFdResource.COLLECT_FD_STACKTRACES_PROPERTY, \"true\")\n+                    .javaOption(OpenResourcePolicies.PROPERTY, config.toString());\n+            builder.doCheckpointAndRestore();\n+        } finally {\n+            Files.deleteIfExists(config);\n+        }\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        Process process = new ProcessBuilder().command(\"cat\", \"\/dev\/zero\").start();\n+        byte[] buffer = new byte[1024];\n+        int read1 = process.getInputStream().read(buffer);\n+        assertGreaterThan(read1, 0);\n+        Core.checkpointRestore();\n+        int read2, total = read1;\n+        \/\/ Some data might got buffered from \/dev\/zero, we will still read those.\n+        try {\n+            while ((read2 = process.getInputStream().read(buffer)) >= 0) {\n+                total += read2;\n+            }\n+            fail(\"Should have failed\");\n+        } catch (IOException e) {\n+            \/\/ the exception comes from native method\n+        }\n+        System.err.printf(\"Read total %d bytes%n\", total);\n+        \/\/ The process will end with SIGPIPE\n+        assertEquals(141, process.waitFor());\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/CloseProcessPipeTest.java","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.Core;\n+import jdk.internal.crac.OpenResourcePolicies;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.concurrent.CountDownLatch;\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.crac:+open\n+ * @build FDPolicyTestBase\n+ * @build CloseTcpSocketTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class CloseTcpSocketTest extends FDPolicyTestBase implements CracTest {\n+    @Override\n+    public void test() throws Exception {\n+        String loopback = InetAddress.getLoopbackAddress().getHostAddress();\n+        Path config = writeConfig(\"\"\"\n+                type: SOCKET\n+                family: ip\n+                localAddress: $loopback\n+                action: close\n+                \"\"\".replace(\"$loopback\", loopback));\n+        try {\n+            new CracBuilder()\n+                    .javaOption(OpenResourcePolicies.PROPERTY, config.toString())\n+                    .doCheckpointAndRestore();\n+        } finally {\n+            Files.deleteIfExists(config);\n+        }\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        ServerSocket serverSocket = new ServerSocket(0, 50, InetAddress.getLoopbackAddress());\n+        CountDownLatch latch = new CountDownLatch(1);\n+        Thread serverThread = new Thread(() -> {\n+            try {\n+                Socket socket = serverSocket.accept();\n+                latch.countDown();\n+                \/\/ the socket leaks in here but for some reason it does not leave the FD open\n+            } catch (IOException e) {\n+                e.printStackTrace();\n+            }\n+        });\n+        serverThread.setDaemon(true);\n+        serverThread.start();\n+        Socket clientSocket = new Socket(InetAddress.getLoopbackAddress(), serverSocket.getLocalPort());\n+        latch.await();\n+        Core.checkpointRestore();\n+    }\n+\n+}\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/CloseTcpSocketTest.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.Core;\n+import jdk.internal.crac.OpenResourcePolicies;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+\n+import java.io.IOException;\n+import java.net.*;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.concurrent.CountDownLatch;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.crac:+open\n+ * @build FDPolicyTestBase\n+ * @build CloseUdpSocketTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class CloseUdpSocketTest extends FDPolicyTestBase implements CracTest {\n+    @Override\n+    public void test() throws Exception {\n+        String loopback = InetAddress.getLoopbackAddress().getHostAddress();\n+        Path config = writeConfig(\"\"\"\n+                type: socket\n+                localAddress: $loopback\n+                action: close\n+                \"\"\".replace(\"$loopback\", loopback));\n+        try {\n+            new CracBuilder()\n+                    .javaOption(OpenResourcePolicies.PROPERTY, config.toString())\n+                    .doCheckpointAndRestore();\n+        } finally {\n+            Files.deleteIfExists(config);\n+        }\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        try (DatagramSocket serverSocket = new DatagramSocket(0, InetAddress.getLoopbackAddress())) {\n+            CountDownLatch latch = new CountDownLatch(1);\n+            Thread serverThread = new Thread(() -> {\n+                try {\n+                    byte[] buf = new byte[1024];\n+                    DatagramPacket packet = new DatagramPacket(buf, buf.length);\n+                    serverSocket.receive(packet);\n+                    latch.countDown();\n+                } catch (IOException e) {\n+                    e.printStackTrace();\n+                }\n+            });\n+            serverThread.setDaemon(true);\n+            serverThread.start();\n+            try (DatagramSocket clientSocket = new DatagramSocket()) {\n+                clientSocket.connect(InetAddress.getLoopbackAddress(), serverSocket.getLocalPort());\n+                byte[] buf = \"Hello\".getBytes();\n+                clientSocket.send(new DatagramPacket(buf, buf.length));\n+                latch.await();\n+                Core.checkpointRestore();\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/CloseUdpSocketTest.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.Core;\n+import jdk.internal.crac.JDKFdResource;\n+import jdk.internal.crac.OpenResourcePolicies;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+\n+import java.io.IOException;\n+import java.net.*;\n+import java.nio.channels.ServerSocketChannel;\n+import java.nio.channels.SocketChannel;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.concurrent.CountDownLatch;\n+\n+import static jdk.test.lib.Asserts.assertTrue;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.crac:+open\n+ * @build FDPolicyTestBase\n+ * @build CloseUnixSocketTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class CloseUnixSocketTest extends FDPolicyTestBase implements CracTest {\n+    @Override\n+    public void test() throws Exception {\n+        Path config = writeConfig(\"\"\"\n+                type: SoCkEt\n+                action: close\n+                family: unix\n+                \"\"\");\n+        try {\n+            new CracBuilder()\n+                    .javaOption(JDKFdResource.COLLECT_FD_STACKTRACES_PROPERTY, \"true\")\n+                    .javaOption(OpenResourcePolicies.PROPERTY, config.toString())\n+                    .doCheckpointAndRestore();\n+        } finally {\n+            Files.deleteIfExists(config);\n+        }\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        Path socketFile = Files.createTempFile(CloseUnixSocketTest.class.getSimpleName(), \".socket\");\n+        Files.deleteIfExists(socketFile);\n+        UnixDomainSocketAddress address = UnixDomainSocketAddress.of(socketFile);\n+\n+        ServerSocketChannel serverChannel = ServerSocketChannel.open(StandardProtocolFamily.UNIX);\n+        serverChannel.bind(address);\n+        CountDownLatch latch1 = new CountDownLatch(1);\n+        CountDownLatch latch2 = new CountDownLatch(1);\n+        Thread serverThread = new Thread(() -> {\n+            try {\n+                SocketChannel socket = serverChannel.accept();\n+                latch1.countDown();\n+                \/\/ We need to prevent SocketChannel getting out of scope and being\n+                \/\/ garbage collected. When this happens the file descriptor leaks.\n+                \/\/ It is not up to CRaC to handle leaked descriptors.\n+                latch2.await();\n+            } catch (IOException | InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+        });\n+        serverThread.setDaemon(true);\n+        serverThread.start();\n+        SocketChannel clientChannel = SocketChannel.open(StandardProtocolFamily.UNIX);\n+        assertTrue(clientChannel.connect(address));\n+        latch1.await();\n+        Core.checkpointRestore();\n+        latch2.countDown();\n+    }\n+\n+}\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/CloseUnixSocketTest.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+import static jdk.test.lib.Asserts.assertGreaterThan;\n+\n+public abstract class FDPolicyTestBase {\n+\n+    protected void writeBigFile(Path path, String prefix, String suffix) throws IOException {\n+        StringBuilder sb = new StringBuilder().append(prefix);\n+        \/\/ Let's use 8+ MB file to avoid hidden buffering in FileInputStream or native parts\n+        for (int i = 0; i < 1024 * 1024; ++i) {\n+            sb.append(String.format(\"%08X\", 8 * i));\n+        }\n+        sb.append(suffix);\n+        Files.writeString(path, sb.toString());\n+    }\n+\n+    protected void readContents(FileReader reader) throws IOException {\n+        char[] bigbuf = new char[1024 * 1024];\n+        for (int count = 0; count < 8 * 1024 * 1024; ) {\n+            int r = reader.read(bigbuf);\n+            assertGreaterThan(r, 8);\n+            assertEquals(String.format(\"%08X\", count), new String(bigbuf, 0, 8));\n+            count += r;\n+        }\n+    }\n+\n+    protected Path writeConfig(String content) throws IOException {\n+        Path config = Files.createTempFile(getClass().getName(), \".yaml\");\n+        Files.writeString(config, content);\n+        return config;\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/FDPolicyTestBase.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.CheckpointException;\n+import jdk.crac.Core;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+\n+import java.io.BufferedReader;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.util.List;\n+import java.util.stream.IntStream;\n+\n+import static jdk.test.lib.Asserts.*;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.crac:+open\n+ * @requires (os.family == \"linux\")\n+ * @build ProcessPipelineTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class ProcessPipelineTest implements CracTest {\n+    @Override\n+    public void test() throws Exception {\n+        new CracBuilder().doCheckpointAndRestore();\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        List<ProcessBuilder> pipeline = IntStream.range(0, 3)\n+                .mapToObj(ignored -> new ProcessBuilder().command(\"cat\")\n+                        .redirectError(ProcessBuilder.Redirect.DISCARD)).toList();\n+        \/\/ The pipeline creates several FDs to connect the subprocesses,\n+        \/\/ but all of them should be closed (in this process) when the method returns.\n+        List<Process> processes = ProcessBuilder.startPipeline(pipeline);\n+        try (\n+                var writer = new OutputStreamWriter(processes.get(0).getOutputStream());\n+                var reader = new BufferedReader(new InputStreamReader(processes.get(2).getInputStream()))\n+        ) {\n+            writer.write(\"Hello world\\n\");\n+            writer.flush();\n+            assertEquals(\"Hello world\", reader.readLine());\n+            try {\n+                Core.checkpointRestore();\n+                fail(\"Should have failed\");\n+            } catch (CheckpointException e) {\n+                \/\/ One for pipe to the first process, another for pipe from the last\n+                assertEquals(2, e.getSuppressed().length);\n+            }\n+        }\n+        \/\/ This time it should succeed\n+        Core.checkpointRestore();\n+        assertEquals(0, processes.get(0).waitFor());\n+        assertEquals(0, processes.get(1).waitFor());\n+        assertEquals(0, processes.get(2).waitFor());\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/ProcessPipelineTest.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.Core;\n+import jdk.crac.RestoreException;\n+import jdk.internal.crac.OpenResourcePolicies;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+\n+import java.io.FileWriter;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Collections;\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+import static jdk.test.lib.Asserts.fail;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.crac:+open\n+ * @build FDPolicyTestBase\n+ * @build ReopenFailureTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class ReopenFailureTest extends FDPolicyTestBase implements CracTest {\n+    @CracTestArg(value = 0, optional = true)\n+    String log1;\n+\n+    @CracTestArg(value = 1, optional = true)\n+    String log2;\n+\n+    @Override\n+    public void test() throws Exception {\n+        Path config = writeConfig(\"\"\"\n+                type: file\n+                action: reopen\n+                \"\"\");\n+        Path path1 = Files.createTempFile(getClass().getName(), \".txt\");\n+        Path path2 = Files.createTempFile(getClass().getName(), \".txt\");\n+        log1 = path1.toString();\n+        log2 = path2.toString();\n+        try {\n+            CracBuilder builder = new CracBuilder()\n+                    .javaOption(OpenResourcePolicies.PROPERTY, config.toString())\n+                    .args(CracTest.args(log1, log2));\n+            builder.doCheckpoint();\n+            Files.delete(path1);\n+            Files.setPosixFilePermissions(path2, Collections.emptySet());\n+            builder.doRestore();\n+        } finally {\n+            Files.deleteIfExists(path1);\n+            Files.deleteIfExists(path2);\n+            Files.deleteIfExists(config);\n+        }\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        try (var writer1 = new FileWriter(log1);\n+             var writer2 = new FileWriter(log2, true)) {\n+            writer1.write(\"Hello!\");\n+            writer1.flush();\n+            writer2.write(\"Hello!\");\n+            writer2.flush();\n+            try {\n+                Core.checkpointRestore();\n+                fail(\"Should throw\");\n+            } catch (RestoreException ex) {\n+                assertEquals(2, ex.getSuppressed().length);\n+            }\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/ReopenFailureTest.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.Core;\n+import jdk.internal.crac.OpenResourcePolicies;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+\n+import java.io.FileInputStream;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.crac:+open\n+ * @build FDPolicyTestBase\n+ * @build ReopenFileReadingTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class ReopenFileReadingTest extends FDPolicyTestBase implements CracTest {\n+    @CracTestArg(optional = true)\n+    String tempFile;\n+\n+    @Override\n+    public void test() throws Exception {\n+        tempFile = Files.createTempFile(getClass().getName(), \".txt\").toString();\n+        Path configFile = writeConfig(\"\"\"\n+                # These first two rules are just to test parsing\n+                type: FILE\n+                path: \/some\/other\/file\n+                action: error\n+                ---\n+                type: FILE\n+                path: **\/*.globpattern.test\n+                action: CLOSE\n+                ---\n+                type: FILE\n+                path: $tempFile\n+                # action is case-insensitive\n+                action: ReOpeN\n+                ---\n+                \"\"\".replace(\"$tempFile\", tempFile));\n+        Path tempPath = Path.of(tempFile);\n+        try {\n+            writeBigFile(tempPath, \"Hello \", \"world!\");\n+            new CracBuilder()\n+                    .javaOption(OpenResourcePolicies.PROPERTY, configFile.toString())\n+                    .args(CracTest.args(tempFile)).doCheckpointAndRestore();\n+        } finally {\n+            Files.deleteIfExists(tempPath);\n+            Files.deleteIfExists(configFile);\n+        }\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        try (var reader = new FileReader(tempFile);\n+             var fis = new FileInputStream(tempFile)) {\n+            char[] buf = new char[6];\n+            assertEquals(buf.length, reader.read(buf));\n+            assertEquals(\"Hello \", new String(buf));\n+\n+            FileChannel channel = fis.getChannel();\n+            byte[] buf2 = new byte[3];\n+            ByteBuffer byteBuffer = ByteBuffer.wrap(buf2);\n+            readFully(channel, byteBuffer);\n+            assertEquals(\"Hel\", new String(buf2, StandardCharsets.UTF_8));\n+\n+            Core.checkpointRestore();\n+            readContents(reader);\n+            assertEquals(buf.length, reader.read(buf));\n+            assertEquals(\"world!\", new String(buf));\n+\n+            readFully(channel, byteBuffer);\n+            assertEquals(\"lo \", new String(buf2, StandardCharsets.UTF_8));\n+\n+            channel.position(8 * 1024 * 1024 + 6);\n+            readFully(channel, byteBuffer);\n+            assertEquals(\"wor\", new String(buf2, StandardCharsets.UTF_8));\n+        }\n+    }\n+\n+    private static void readFully(FileChannel channel, ByteBuffer byteBuffer) throws IOException {\n+        byteBuffer.clear();\n+        while (byteBuffer.position() < byteBuffer.capacity()) {\n+            channel.read(byteBuffer);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/ReopenFileReadingTest.java","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -0,0 +1,144 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.Core;\n+import jdk.internal.crac.OpenResourcePolicies;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+\n+import java.io.FileOutputStream;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.stream.Stream;\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.crac:+open\n+ * @build FDPolicyTestBase\n+ * @build ReopenFileWritingTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class ReopenFileWritingTest extends FDPolicyTestBase implements CracTest {\n+    @CracTestArg(value = 0, optional = true)\n+    String fileNoAppend;\n+\n+    @CracTestArg(value = 1, optional = true)\n+    String fileAppend;\n+\n+    @CracTestArg(value = 2, optional = true)\n+    String fileAppendExtended;\n+\n+    @CracTestArg(value = 3, optional = true)\n+    String fileAppendTruncated;\n+\n+    @CracTestArg(value = 4, optional = true)\n+    String fileUseChannel;\n+\n+\n+    @Override\n+    public void test() throws Exception {\n+        Path noAppendPath = Files.createTempFile(getClass().getName(), \".txt\");\n+        Path appendPath = Files.createTempFile(getClass().getName(), \".txt\");\n+        Path appendExtendedPath = Files.createTempFile(getClass().getName(), \".txt\");\n+        Path appendTruncatedPath = Files.createTempFile(getClass().getName(), \".txt\");\n+        Path useChannelPath = Files.createTempFile(getClass().getName(), \".txt\");\n+        fileNoAppend = noAppendPath.toString();\n+        fileAppend = appendPath.toString();\n+        fileAppendExtended = appendExtendedPath.toString();\n+        fileAppendTruncated = appendTruncatedPath.toString();\n+        fileUseChannel = useChannelPath.toString();\n+        Path config = writeConfig(\"\"\"\n+                type: FILE\n+                action: reopen\n+                \"\"\");\n+        try {\n+            CracBuilder builder = new CracBuilder();\n+            builder\n+                    .javaOption(OpenResourcePolicies.PROPERTY, config.toString())\n+                    .args(CracTest.args(fileNoAppend, fileAppend, fileAppendExtended, fileAppendTruncated, fileUseChannel));\n+            builder.doCheckpoint();\n+            assertEquals(\"Hello \", Files.readString(noAppendPath));\n+            assertEquals(\"Hello \", Files.readString(appendPath));\n+            assertEquals(\"Hello \", Files.readString(appendExtendedPath));\n+            assertEquals(\"Hello \", Files.readString(appendTruncatedPath));\n+            assertEquals(\"Hello \", Files.readString(useChannelPath));\n+            Files.writeString(noAppendPath, \"1234567890\");\n+            Files.writeString(appendPath, \"123456\");\n+            Files.writeString(appendExtendedPath, \"1234567890\");\n+            Files.writeString(appendTruncatedPath, \"\");\n+            Files.writeString(useChannelPath, \"123456\");\n+            builder.doRestore();\n+            assertEquals(\"123456world!\", Files.readString(noAppendPath));\n+            assertEquals(\"123456world!\", Files.readString(appendPath));\n+            assertEquals(\"1234567890world!\", Files.readString(appendExtendedPath));\n+            assertEquals(\"world!\", Files.readString(appendTruncatedPath));\n+            assertEquals(\"123world!\", Files.readString(useChannelPath));\n+        } finally {\n+            Files.deleteIfExists(noAppendPath);\n+            Files.deleteIfExists(appendPath);\n+            Files.deleteIfExists(appendExtendedPath);\n+            Files.deleteIfExists(appendTruncatedPath);\n+            Files.deleteIfExists(useChannelPath);\n+            Files.deleteIfExists(config);\n+        }\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        try (var w1 = new FileWriter(fileNoAppend);\n+             var w2 = new FileWriter(fileAppend, true);\n+             var w3 = new FileWriter(fileAppendExtended, true);\n+             var w4 = new FileWriter(fileAppendTruncated, true);\n+             var fos5 = new FileOutputStream(fileUseChannel)) {\n+            Stream.of(w1, w2, w3, w4).forEach(w -> {\n+                try {\n+                    w.write(\"Hello \");\n+                    w.flush();\n+                } catch (IOException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            });\n+            FileChannel ch5 = fos5.getChannel();\n+            ch5.write(ByteBuffer.wrap(\"Hello \".getBytes(StandardCharsets.UTF_8)));\n+            Core.checkpointRestore();\n+            Stream.of(w1, w2, w3, w4).forEach(w -> {\n+                try {\n+                    w.write(\"world!\");\n+                } catch (IOException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            });\n+            ch5.position(3);\n+            ch5.write(ByteBuffer.wrap(\"world!\".getBytes(StandardCharsets.UTF_8)));\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/ReopenFileWritingTest.java","additions":144,"deletions":0,"binary":false,"changes":144,"status":"added"},{"patch":"@@ -0,0 +1,106 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.Core;\n+import jdk.internal.crac.OpenResourcePolicies;\n+import jdk.test.lib.crac.CracBuilder;\n+import jdk.test.lib.crac.CracProcess;\n+import jdk.test.lib.crac.CracTest;\n+import jdk.test.lib.crac.CracTestArg;\n+\n+import java.io.File;\n+import java.io.FileReader;\n+import java.io.FileWriter;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.concurrent.CountDownLatch;\n+\n+import static jdk.test.lib.Asserts.assertEquals;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.crac:+open\n+ * @requires (os.family == \"linux\")\n+ * @build FDPolicyTestBase\n+ * @build ReopenNamedFifoTest\n+ * @run driver jdk.test.lib.crac.CracTest\n+ *\/\n+public class ReopenNamedFifoTest extends FDPolicyTestBase implements CracTest {\n+    @CracTestArg(optional = true)\n+    String fifo;\n+\n+    @Override\n+    public void test() throws Exception {\n+        Path tempDirectory = Files.createTempDirectory(getClass().getName());\n+        Path pipePath = tempDirectory.resolve(\"pipe\");\n+        fifo = pipePath.toString();\n+        assertEquals(0, new ProcessBuilder().inheritIO().command(\"mkfifo\", fifo).start().waitFor());\n+        \/\/ From Java POV this has a path, therefore is treated as a file and not as a named pipe\n+        Path config = writeConfig(\"\"\"\n+                type: file\n+                action: reopen\n+                \"\"\");\n+        CracBuilder builder = new CracBuilder()\n+                .javaOption(OpenResourcePolicies.PROPERTY, config.toString())\n+                .args(CracTest.args(fifo));\n+        CracProcess cp = builder.startCheckpoint();\n+\n+        try (var writer = new FileWriter(fifo)) {\n+            writer.write(\"Hello \");\n+            writer.flush();\n+            cp.waitForCheckpointed();\n+            CracProcess rp = builder.captureOutput(true).startRestore();\n+            CountDownLatch latch = new CountDownLatch(1);\n+            rp.watch(output -> {\n+                if (output.contains(\"RESTORED\")) {\n+                    latch.countDown();\n+                }\n+            }, error -> {\n+                System.err.println(error);\n+                latch.countDown();\n+            });\n+            latch.await();\n+            writer.write(\"world!\");\n+            writer.flush();\n+            rp.waitForSuccess();\n+        } finally {\n+            Files.deleteIfExists(pipePath);\n+            Files.deleteIfExists(tempDirectory);\n+            Files.deleteIfExists(config);\n+        }\n+    }\n+\n+    @Override\n+    public void exec() throws Exception {\n+        try (var reader = new FileReader(fifo)) {\n+            char[] buf = new char[6];\n+            assertEquals(buf.length, reader.read(buf));\n+            assertEquals(\"Hello \", new String(buf));\n+            Core.checkpointRestore();\n+            System.out.println(\"RESTORED\");\n+            assertEquals(buf.length, reader.read(buf));\n+            assertEquals(\"world!\", new String(buf));\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/fileDescriptors\/ReopenNamedFifoTest.java","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"}]}