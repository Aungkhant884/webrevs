{"files":[{"patch":"@@ -96,1 +96,1 @@\n-      INCLUDE_FILES := criuengine.cpp, \\\n+      INCLUDE_FILES := criuengine.c, \\\n@@ -98,1 +98,1 @@\n-      CXXFLAGS := $(CXXFLAGS_JDKEXE), \\\n+      CFLAGS := $(CFLAGS_JDKEXE), \\\n@@ -100,1 +100,0 @@\n-      LD := $(LDCXX), \\\n","filename":"make\/modules\/java.base\/Launcher.gmk","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,510 @@\n+\/*\n+ * Copyright (c) 2017, 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <assert.h>\n+#include <string.h>\n+#include <stdio.h>\n+#include <stdbool.h>\n+#include <libgen.h>\n+#include <limits.h>\n+#include <stdlib.h>\n+#include <errno.h>\n+#include <unistd.h>\n+#include <fcntl.h>\n+#include <getopt.h>\n+#include <signal.h>\n+#include <sys\/wait.h>\n+#include <sys\/stat.h>\n+\n+#define RESTORE_SIGNAL   (SIGRTMIN + 2)\n+\n+#define PERFDATA_NAME \"perfdata\"\n+\n+#define ARRAY_SIZE(x) (sizeof(x) \/ sizeof(x[0]))\n+\n+#define SUPPRESS_ERROR_IN_PARENT 77\n+\n+static int create_cppath(const char *imagedir);\n+\n+static int g_pid;\n+\n+static char *verbosity = NULL; \/\/ default differs for checkpoint and restore\n+static char *log_file = NULL;\n+\n+static int kickjvm(pid_t jvm, int code) {\n+    union sigval sv = { .sival_int = code };\n+    if (-1 == sigqueue(jvm, RESTORE_SIGNAL, sv)) {\n+        perror(\"sigqueue\");\n+        return 1;\n+    }\n+    return 0;\n+}\n+\n+static void print_args_to_stderr(const char **args) {\n+    for (const char **argp = args; *argp != NULL; ++argp) {\n+        const char *s = *argp;\n+        if (argp != args) {\n+            fputc(' ', stderr);\n+        }\n+        \/\/ https:\/\/unix.stackexchange.com\/a\/357932\/296319\n+        if (!strpbrk(s, \" \\t\\n!\\\"#$&'()*,;<=>?[\\\\]^`{|}~\")) {\n+            fputs(s, stderr);\n+            continue;\n+        }\n+        fputc('\\'', stderr);\n+        for (; *s; ++s) {\n+            if (*s != '\\'') {\n+                fputc(*s, stderr);\n+            } else {\n+                fputs(\"'\\\\''\", stderr);\n+            }\n+        }\n+        fputc('\\'', stderr);\n+    }\n+}\n+\n+static void print_command_args_to_stderr(const char **args) {\n+  fprintf(stderr, \"Command: \");\n+  print_args_to_stderr(args);\n+  fputc('\\n', stderr);\n+}\n+\n+static const char *join_path(const char *path1, const char *path2) {\n+    char *retval = malloc(strlen(path1) + 1 + strlen(path2) + 1);\n+    if (!retval) {\n+        perror(\"malloc\");\n+        exit(1);\n+    }\n+    char *d = retval;\n+    d = stpcpy(d, path1);\n+    *d++ = '\/';\n+    d = stpcpy(d, path2);\n+    *d++ = 0;\n+    return retval;\n+}\n+\n+static const char *path_abs(const char *rel) {\n+    if (rel[0] == '\/') {\n+        return rel;\n+    }\n+    char *cwd = get_current_dir_name();\n+    if (!cwd) {\n+        perror(\"get_current_dir_name\");\n+        exit(1);\n+    }\n+    return join_path(cwd, rel);\n+}\n+\n+static const char *path_abs2(const char *rel1, const char *rel2) {\n+    if (rel2[0] == '\/') {\n+        return rel2;\n+    }\n+    return join_path(path_abs(rel1), rel2);\n+}\n+\n+static int checkpoint(pid_t jvm,\n+        const char *basedir,\n+        const char *self,\n+        const char *criu,\n+        const char *imagedir) {\n+\n+    if (fork()) {\n+        \/\/ main process\n+        wait(NULL);\n+        return 0;\n+    }\n+\n+    pid_t parent_before = getpid();\n+\n+    \/\/ child\n+    if (fork()) {\n+        exit(0);\n+    }\n+\n+    \/\/ grand-child\n+    pid_t parent = getppid();\n+    int tries = 300;\n+    while (parent != 1 && 0 < tries--) {\n+        usleep(10);\n+        parent = getppid();\n+    }\n+\n+    if (parent == parent_before) {\n+        fprintf(stderr, \"can't move out of JVM process hierarchy\");\n+        kickjvm(jvm, -1);\n+        exit(0);\n+    }\n+\n+    char* leave_running = getenv(\"CRAC_CRIU_LEAVE_RUNNING\");\n+\n+    char jvmpidchar[32];\n+    snprintf(jvmpidchar, sizeof(jvmpidchar), \"%d\", jvm);\n+\n+    const char* args[32] = {\n+        criu,\n+        \"dump\",\n+        \"-t\", jvmpidchar,\n+        \"-D\", imagedir,\n+        \"--shell-job\",\n+    };\n+    const char** arg = args + 7;\n+\n+    *arg++ = verbosity != NULL ? verbosity : \"-v4\";\n+    *arg++ = \"-o\";\n+    \/\/ -D without -W makes criu cd to image dir for logs\n+    const char *log_local = log_file != NULL ? log_file : \"dump4.log\";\n+    *arg++ = log_local;\n+\n+    if (leave_running) {\n+        *arg++ = \"-R\";\n+    }\n+\n+    char *criuopts = getenv(\"CRAC_CRIU_OPTS\");\n+    if (criuopts) {\n+        char* criuopt = strtok(criuopts, \" \");\n+        while (criuopt && ARRAY_SIZE(args) >= (size_t)(arg - args) + 1\/* account for trailing NULL *\/) {\n+            *arg++ = criuopt;\n+            criuopt = strtok(NULL, \" \");\n+        }\n+        if (criuopt) {\n+            fprintf(stderr, \"Warning: too many arguments in CRAC_CRIU_OPTS (dropped from '%s')\\n\", criuopt);\n+        }\n+    }\n+    *arg++ = NULL;\n+\n+    pid_t child = fork();\n+    if (!child) {\n+        execv(criu, (char**)args);\n+        fprintf(stderr, \"Cannot execute CRIU \\\"\");\n+        print_args_to_stderr(args);\n+        fprintf(stderr, \"\\\": %s\\n\", strerror(errno));\n+        exit(SUPPRESS_ERROR_IN_PARENT);\n+    }\n+\n+    int status;\n+    if (child != wait(&status)) {\n+        fprintf(stderr, \"Error waiting for CRIU: %s\\n\", strerror(errno));\n+        print_command_args_to_stderr(args);\n+        kickjvm(jvm, -1);\n+    } else if (!WIFEXITED(status)) {\n+        fprintf(stderr, \"CRIU has not properly exited, waitpid status was %d - check %s\\n\", status, path_abs2(imagedir, log_local));\n+        print_command_args_to_stderr(args);\n+        kickjvm(jvm, -1);\n+    } else if (WEXITSTATUS(status)) {\n+        if (WEXITSTATUS(status) != SUPPRESS_ERROR_IN_PARENT) {\n+            fprintf(stderr, \"CRIU failed with exit code %d - check %s\\n\", WEXITSTATUS(status), path_abs2(imagedir, log_local));\n+            print_command_args_to_stderr(args);\n+        }\n+        kickjvm(jvm, -1);\n+    } else if (leave_running) {\n+        kickjvm(jvm, 0);\n+    }\n+\n+    create_cppath(imagedir);\n+    exit(0);\n+}\n+\n+static int restore(const char *basedir,\n+        const char *self,\n+        const char *criu,\n+        const char *imagedir) {\n+    char *cppathpath;\n+    if (-1 == asprintf(&cppathpath, \"%s\/cppath\", imagedir)) {\n+        return 1;\n+    }\n+\n+    int fd = open(cppathpath, O_RDONLY);\n+    if (fd < 0) {\n+        fprintf(stderr, \"CRaC restore - cannot open cppath file \\\"%s\\\": %s\\n\", path_abs(cppathpath), strerror(errno));\n+        return 1;\n+    }\n+\n+    char cppath[PATH_MAX];\n+    int cppathlen = 0;\n+    int r;\n+    while ((r = read(fd, cppath + cppathlen, sizeof(cppath) - cppathlen - 1)) != 0) {\n+        if (r < 0 && errno == EINTR) {\n+            continue;\n+        }\n+        if (r < 0) {\n+            perror(\"read cppath\");\n+            return 1;\n+        }\n+        cppathlen += r;\n+    }\n+    cppath[cppathlen] = '\\0';\n+\n+    close(fd);\n+\n+    char *inherit_perfdata = NULL;\n+    char *perfdatapath;\n+    if (-1 == asprintf(&perfdatapath, \"%s\/\" PERFDATA_NAME, imagedir)) {\n+        return 1;\n+    }\n+    int perfdatafd = open(perfdatapath, O_RDWR);\n+    if (0 < perfdatafd) {\n+        if (-1 == asprintf(&inherit_perfdata, \"fd[%d]:%s\/\" PERFDATA_NAME,\n+                    perfdatafd,\n+                    cppath[0] == '\/' ? cppath + 1 : cppath)) {\n+            return 1;\n+        }\n+    }\n+\n+    const char* args[32] = {\n+        criu,\n+        \"restore\",\n+        \"-W\", \".\",\n+        \"--shell-job\",\n+        \"--action-script\", self,\n+        \"-D\", imagedir,\n+    };\n+    const char** arg = args + 9;\n+\n+    *arg++ = verbosity != NULL ? verbosity : \"-v1\";\n+    if (log_file != NULL) {\n+        *arg++ = \"-o\";\n+        *arg++ = log_file;\n+    }\n+\n+    if (inherit_perfdata) {\n+        *arg++ = \"--inherit-fd\";\n+        *arg++ = inherit_perfdata;\n+    }\n+    const char* tail[] = {\n+        \"--exec-cmd\", \"--\", self, \"restorewait\",\n+        NULL\n+    };\n+    char *criuopts = getenv(\"CRAC_CRIU_OPTS\");\n+    if (criuopts) {\n+        char* criuopt = strtok(criuopts, \" \");\n+        while (criuopt && ARRAY_SIZE(args) >= (size_t)(arg - args + ARRAY_SIZE(tail))) {\n+            *arg++ = criuopt;\n+            criuopt = strtok(NULL, \" \");\n+        }\n+        if (criuopt) {\n+            fprintf(stderr, \"Warning: too many arguments in CRAC_CRIU_OPTS (dropped from '%s')\\n\", criuopt);\n+        }\n+    }\n+\n+    memcpy(arg, tail, sizeof(tail));\n+\n+    fflush(stderr);\n+\n+    execv(criu, (char**)args);\n+    fprintf(stderr, \"Cannot execute CRIU \\\"\");\n+    print_args_to_stderr(args);\n+    fprintf(stderr, \"\\\": %s\\n\", strerror(errno));\n+    return 1;\n+}\n+\n+#define MSGPREFIX \"\"\n+\n+static int post_resume(void) {\n+    char *pidstr = getenv(\"CRTOOLS_INIT_PID\");\n+    if (!pidstr) {\n+        fprintf(stderr, MSGPREFIX \"cannot find CRTOOLS_INIT_PID env\\n\");\n+        return 1;\n+    }\n+    int pid = atoi(pidstr);\n+\n+    char *strid = getenv(\"CRAC_NEW_ARGS_ID\");\n+    return kickjvm(pid, strid ? atoi(strid) : 0);\n+}\n+\n+static int create_cppath(const char *imagedir) {\n+    char realdir[PATH_MAX];\n+\n+    if (!realpath(imagedir, realdir)) {\n+        fprintf(stderr, MSGPREFIX \"cannot canonicalize %s: %s\\n\", imagedir, strerror(errno));\n+        return 1;\n+    }\n+\n+    int dirfd = open(realdir, O_DIRECTORY);\n+    if (dirfd < 0) {\n+        fprintf(stderr, MSGPREFIX \"can not open image dir %s: %s\\n\", realdir, strerror(errno));\n+        return 1;\n+    }\n+\n+    int fd = openat(dirfd, \"cppath\", O_CREAT | O_WRONLY | O_TRUNC, 0644);\n+    if (fd < 0) {\n+        fprintf(stderr, MSGPREFIX \"can not open file %s\/cppath: %s\\n\", realdir, strerror(errno));\n+        return 1;\n+    }\n+\n+    if (write(fd, realdir, strlen(realdir)) < 0) {\n+        fprintf(stderr, MSGPREFIX \"can not write %s\/cppath: %s\\n\", realdir, strerror(errno));\n+        return 1;\n+    }\n+    return 0;\n+}\n+\n+static void sighandler(int sig, siginfo_t *info, void *uc) {\n+    if (0 <= g_pid) {\n+        kill(g_pid, sig);\n+    }\n+}\n+\n+static int restorewait(void) {\n+    char *pidstr = getenv(\"CRTOOLS_INIT_PID\");\n+    if (!pidstr) {\n+        fprintf(stderr, MSGPREFIX \"no CRTOOLS_INIT_PID: signals may not be delivered\\n\");\n+    }\n+    g_pid = pidstr ? atoi(pidstr) : -1;\n+\n+    struct sigaction sigact;\n+    sigfillset(&sigact.sa_mask);\n+    sigact.sa_flags = SA_SIGINFO;\n+    sigact.sa_sigaction = sighandler;\n+\n+    int sig;\n+    for (sig = 1; sig <= 31; ++sig) {\n+        if (sig == SIGKILL || sig == SIGSTOP) {\n+            continue;\n+        }\n+        if (-1 == sigaction(sig, &sigact, NULL)) {\n+            perror(\"sigaction\");\n+        }\n+    }\n+\n+    sigset_t allset;\n+    sigfillset(&allset);\n+    if (-1 == sigprocmask(SIG_UNBLOCK, &allset, NULL)) {\n+        perror(MSGPREFIX \"sigprocmask\");\n+    }\n+\n+    int status;\n+    int ret;\n+    do {\n+        ret = waitpid(g_pid, &status, 0);\n+    } while (ret == -1 && errno == EINTR);\n+\n+    if (ret == -1) {\n+        perror(MSGPREFIX \"waitpid\");\n+        return 1;\n+    }\n+\n+    if (WIFEXITED(status)) {\n+        return WEXITSTATUS(status);\n+    }\n+\n+    if (WIFSIGNALED(status)) {\n+        \/\/ Try to terminate the current process with the same signal\n+        \/\/ as the child process was terminated\n+        const int sig = WTERMSIG(status);\n+        signal(sig, SIG_DFL);\n+        raise(sig);\n+        \/\/ Signal was ignored, return 128+n as bash does\n+        \/\/ see https:\/\/linux.die.net\/man\/1\/bash\n+        return 128+sig;\n+    }\n+\n+    return 1;\n+}\n+\n+\/\/ return value is one argument after options\n+static char *parse_options(int argc, char *argv[]) {\n+    optind = 2; \/\/ starting after action\n+    struct option opts[] = {{\n+        .name = \"verbosity\",\n+        .has_arg = 1,\n+        .flag = NULL,\n+        .val = 'v'\n+    }, {\n+        .name = \"log-file\",\n+        .has_arg = 1,\n+        .flag = NULL,\n+        .val = 'o',\n+    }, { NULL, 0, NULL, 0} };\n+    bool processing = true;\n+    do {\n+        switch (getopt_long(argc, argv, \"v:o:\", opts, NULL)) {\n+            case -1:\n+            case '?':\n+                processing = false;\n+                break;\n+            case 'v':\n+                if (asprintf(&verbosity, \"--verbosity=%s\", optarg) < 0) {\n+                    fprintf(stderr, \"Cannot set verbosity level\\n\");\n+                    verbosity = NULL;\n+                }\n+                break;\n+            case 'o':\n+                log_file = optarg;\n+                break;\n+        }\n+    } while (processing);\n+    return optind < argc ? argv[optind] : NULL;\n+}\n+\n+int main(int argc, char *argv[]) {\n+    char* action;\n+    if (argc >= 2 && (action = argv[1])) {\n+\n+        char* imagedir = parse_options(argc, argv);\n+\n+        char *basedir = dirname(strdup(argv[0]));\n+\n+        char *criu = getenv(\"CRAC_CRIU_PATH\");\n+        if (!criu) {\n+            if (-1 == asprintf(&criu, \"%s\/criu\", basedir)) {\n+                return 1;\n+            }\n+            struct stat st;\n+            if (stat(criu, &st)) {\n+                \/* some problem with the bundled criu *\/\n+                criu = \"\/usr\/sbin\/criu\";\n+                if (stat(criu, &st)) {\n+                    fprintf(stderr, \"cannot find CRIU to use\\n\");\n+                    return 1;\n+                }\n+            }\n+        }\n+\n+\n+        if (!strcmp(action, \"checkpoint\")) {\n+            pid_t jvm = getppid();\n+            return checkpoint(jvm, basedir, argv[0], criu, imagedir);\n+        } else if (!strcmp(action, \"restore\")) {\n+            return restore(basedir, argv[0], criu, imagedir);\n+        } else if (!strcmp(action, \"restorewait\")) { \/\/ called by CRIU --exec-cmd\n+            return restorewait();\n+        } else {\n+            fprintf(stderr, \"unknown command-line action: %s\\n\", action);\n+            return 1;\n+        }\n+    } else if ((action = getenv(\"CRTOOLS_SCRIPT_ACTION\"))) { \/\/ called by CRIU --action-script\n+        if (!strcmp(action, \"post-resume\")) {\n+            return post_resume();\n+        } else {\n+            \/\/ ignore other notifications\n+            return 0;\n+        }\n+    } else {\n+        fprintf(stderr, \"unknown context\\n\");\n+    }\n+\n+    return 1;\n+}\n","filename":"src\/java.base\/unix\/native\/criuengine\/criuengine.c","additions":510,"deletions":0,"binary":false,"changes":510,"status":"added"},{"patch":"@@ -1,477 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2021, Azul Systems, Inc. All rights reserved.\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <assert.h>\n-#include <string.h>\n-#include <stdio.h>\n-#include <stdbool.h>\n-#include <libgen.h>\n-#include <limits.h>\n-#include <stdlib.h>\n-#include <errno.h>\n-#include <unistd.h>\n-#include <fcntl.h>\n-#include <getopt.h>\n-#include <signal.h>\n-#include <sys\/wait.h>\n-#include <sys\/stat.h>\n-#include <string>\n-#include <vector>\n-#include <iostream>\n-\n-#define RESTORE_SIGNAL   (SIGRTMIN + 2)\n-\n-#define PERFDATA_NAME \"perfdata\"\n-\n-#define ARRAY_SIZE(x) (sizeof(x) \/ sizeof(x[0]))\n-\n-#define SUPPRESS_ERROR_IN_PARENT 77\n-\n-static int create_cppath(const char *imagedir);\n-\n-static int g_pid;\n-\n-static char *verbosity = NULL; \/\/ default differs for checkpoint and restore\n-static char *log_file = NULL;\n-\n-static int kickjvm(pid_t jvm, int code) {\n-    union sigval sv = { .sival_int = code };\n-    if (-1 == sigqueue(jvm, RESTORE_SIGNAL, sv)) {\n-        perror(\"sigqueue\");\n-        return 1;\n-    }\n-    return 0;\n-}\n-\n-static std::string join_args(const std::vector<const char *> &args) {\n-    std::string retval;\n-    for (const char *s : args) {\n-        if (!s) {\n-            continue;\n-        }\n-        if (!retval.empty()) {\n-            retval += ' ';\n-        }\n-        \/\/ https:\/\/unix.stackexchange.com\/a\/357932\/296319\n-        if (!strpbrk(s, \" \\t\\n!\\\"#$&'()*,;<=>?[\\\\]^`{|}~\")) {\n-            retval += s;\n-            continue;\n-        }\n-        retval += '\\'';\n-        for (; *s; ++s) {\n-            if (*s != '\\'') {\n-                retval += *s;\n-            } else {\n-                retval += \"'\\\\''\";\n-            }\n-        }\n-        retval += '\\'';\n-    }\n-    return retval;\n-}\n-\n-static std::string path_abs(std::string rel) {\n-    if (rel[0] == '\/') {\n-        return rel;\n-    }\n-    char *cwd_s = get_current_dir_name();\n-    if (!cwd_s) {\n-        perror(\"get_current_dir_name\");\n-        exit(1);\n-    }\n-    std::string cwd = cwd_s;\n-    free(cwd_s);\n-    return cwd + \"\/\" + rel;\n-}\n-\n-static std::string path_abs(std::string rel1, std::string rel2) {\n-    if (rel2[0] == '\/') {\n-        return rel2;\n-    }\n-    return path_abs(rel1) + \"\/\" + rel2;\n-}\n-\n-static int checkpoint(pid_t jvm,\n-        const char *basedir,\n-        const char *self,\n-        const char *criu,\n-        const char *imagedir) {\n-\n-    if (fork()) {\n-        \/\/ main process\n-        wait(NULL);\n-        return 0;\n-    }\n-\n-    pid_t parent_before = getpid();\n-\n-    \/\/ child\n-    if (fork()) {\n-        exit(0);\n-    }\n-\n-    \/\/ grand-child\n-    pid_t parent = getppid();\n-    int tries = 300;\n-    while (parent != 1 && 0 < tries--) {\n-        usleep(10);\n-        parent = getppid();\n-    }\n-\n-    if (parent == parent_before) {\n-        fprintf(stderr, \"can't move out of JVM process hierarchy\");\n-        kickjvm(jvm, -1);\n-        exit(0);\n-    }\n-\n-    char* leave_running = getenv(\"CRAC_CRIU_LEAVE_RUNNING\");\n-\n-    char jvmpidchar[32];\n-    snprintf(jvmpidchar, sizeof(jvmpidchar), \"%d\", jvm);\n-\n-    std::vector<const char *> args = {\n-        criu,\n-        \"dump\",\n-        \"-t\", jvmpidchar,\n-        \"-D\", imagedir,\n-        \"--shell-job\",\n-    };\n-\n-    args.push_back(verbosity != NULL ? verbosity : \"-v4\");\n-    args.push_back(\"-o\");\n-    \/\/ -D without -W makes criu cd to image dir for logs\n-    const char *log_local = log_file != NULL ? log_file : \"dump4.log\";\n-    args.push_back(log_local);\n-\n-    if (leave_running) {\n-        args.push_back(\"-R\");\n-    }\n-\n-    char *criuopts = getenv(\"CRAC_CRIU_OPTS\");\n-    if (criuopts) {\n-        char* criuopt = strtok(criuopts, \" \");\n-        while (criuopt) {\n-            args.push_back(criuopt);\n-            criuopt = strtok(NULL, \" \");\n-        }\n-    }\n-    args.push_back(NULL);\n-\n-    pid_t child = fork();\n-    if (!child) {\n-        execv(criu, const_cast<char **>(args.data()));\n-        std::cerr << \"Cannot execute CRIU \\\"\" << join_args(args) << \"\\\": \" << strerror(errno) << std::endl;\n-        exit(SUPPRESS_ERROR_IN_PARENT);\n-    }\n-\n-    int status;\n-    if (child != wait(&status)) {\n-        std::cerr << \"Error waiting for CRIU: \" << strerror(errno) << std::endl\n-            << \"Command: \" << join_args(args) << std::endl;\n-        kickjvm(jvm, -1);\n-    } else if (!WIFEXITED(status)) {\n-        std::cerr << \"CRIU has not properly exited, waitpid status was %d - check \" << path_abs(imagedir, log_local) << std::endl\n-            << \"Command: \" << join_args(args) << std::endl;\n-        kickjvm(jvm, -1);\n-    } else if (WEXITSTATUS(status)) {\n-        if (WEXITSTATUS(status) != SUPPRESS_ERROR_IN_PARENT) {\n-            std::cerr << \"CRIU failed with exit code \" << WEXITSTATUS(status) << \" - check \" << path_abs(imagedir, log_local) << std::endl\n-                << \"Command: \" << join_args(args) << std::endl;\n-        }\n-        kickjvm(jvm, -1);\n-    } else if (leave_running) {\n-        kickjvm(jvm, 0);\n-    }\n-\n-    create_cppath(imagedir);\n-    exit(0);\n-}\n-\n-static int restore(const char *basedir,\n-        const char *self,\n-        const char *criu,\n-        const char *imagedir) {\n-    std::string cppathpath = std::string(imagedir) + \"\/cppath\";\n-\n-    int fd = open(cppathpath.c_str(), O_RDONLY);\n-    if (fd < 0) {\n-        std::cerr << \"CRaC restore - cannot open cppath file \\\"\" << path_abs(cppathpath) << \"\\\": \" << strerror(errno) << std::endl;\n-        return 1;\n-    }\n-\n-    char cppath[PATH_MAX];\n-    int cppathlen = 0;\n-    int r;\n-    while ((r = read(fd, cppath + cppathlen, sizeof(cppath) - cppathlen - 1)) != 0) {\n-        if (r < 0 && errno == EINTR) {\n-            continue;\n-        }\n-        if (r < 0) {\n-            perror(\"read cppath\");\n-            return 1;\n-        }\n-        cppathlen += r;\n-    }\n-    cppath[cppathlen] = '\\0';\n-\n-    close(fd);\n-\n-    std::string inherit_perfdata;\n-    std::string perfdatapath = std::string(imagedir) + \"\/\" PERFDATA_NAME;\n-    int perfdatafd = open(perfdatapath.c_str(), O_RDWR);\n-    if (0 < perfdatafd) {\n-        inherit_perfdata = \"fd[\" + std::to_string(perfdatafd) + \"]:\" + std::string(cppath[0] == '\/' ? cppath + 1 : cppath) + \"\/\" PERFDATA_NAME;\n-    }\n-\n-    std::vector<const char *> args = {\n-        criu,\n-        \"restore\",\n-        \"-W\", \".\",\n-        \"--shell-job\",\n-        \"--action-script\", self,\n-        \"-D\", imagedir,\n-    };\n-\n-    args.push_back(verbosity != NULL ? verbosity : \"-v1\");\n-    if (log_file != NULL) {\n-        args.push_back(\"-o\");\n-        args.push_back(log_file);\n-    }\n-\n-    if (!inherit_perfdata.empty()) {\n-        args.push_back(\"--inherit-fd\");\n-        args.push_back(inherit_perfdata.c_str());\n-    }\n-    char *criuopts = getenv(\"CRAC_CRIU_OPTS\");\n-    if (criuopts) {\n-        char* criuopt = strtok(criuopts, \" \");\n-        while (criuopt) {\n-            args.push_back(criuopt);\n-            criuopt = strtok(NULL, \" \");\n-        }\n-    }\n-\n-    const std::vector<const char *> tail = {\n-        \"--exec-cmd\", \"--\", self, \"restorewait\", NULL,\n-    };\n-    args.insert(args.end(), tail.begin(), tail.end());\n-\n-    fflush(stderr);\n-\n-    execv(criu, const_cast<char **>(args.data()));\n-    std::cerr << \"Cannot execute CRIU \\\"\" << join_args(args) << \"\\\": \" << strerror(errno) << std::endl;\n-    return 1;\n-}\n-\n-#define MSGPREFIX \"\"\n-\n-static int post_resume(void) {\n-    char *pidstr = getenv(\"CRTOOLS_INIT_PID\");\n-    if (!pidstr) {\n-        fprintf(stderr, MSGPREFIX \"cannot find CRTOOLS_INIT_PID env\\n\");\n-        return 1;\n-    }\n-    int pid = atoi(pidstr);\n-\n-    char *strid = getenv(\"CRAC_NEW_ARGS_ID\");\n-    return kickjvm(pid, strid ? atoi(strid) : 0);\n-}\n-\n-static int create_cppath(const char *imagedir) {\n-    char realdir[PATH_MAX];\n-\n-    if (!realpath(imagedir, realdir)) {\n-        fprintf(stderr, MSGPREFIX \"cannot canonicalize %s: %s\\n\", imagedir, strerror(errno));\n-        return 1;\n-    }\n-\n-    int dirfd = open(realdir, O_DIRECTORY);\n-    if (dirfd < 0) {\n-        fprintf(stderr, MSGPREFIX \"can not open image dir %s: %s\\n\", realdir, strerror(errno));\n-        return 1;\n-    }\n-\n-    int fd = openat(dirfd, \"cppath\", O_CREAT | O_WRONLY | O_TRUNC, 0644);\n-    if (fd < 0) {\n-        fprintf(stderr, MSGPREFIX \"can not open file %s\/cppath: %s\\n\", realdir, strerror(errno));\n-        return 1;\n-    }\n-\n-    if (write(fd, realdir, strlen(realdir)) < 0) {\n-        fprintf(stderr, MSGPREFIX \"can not write %s\/cppath: %s\\n\", realdir, strerror(errno));\n-        return 1;\n-    }\n-    return 0;\n-}\n-\n-static void sighandler(int sig, siginfo_t *info, void *uc) {\n-    if (0 <= g_pid) {\n-        kill(g_pid, sig);\n-    }\n-}\n-\n-static int restorewait(void) {\n-    char *pidstr = getenv(\"CRTOOLS_INIT_PID\");\n-    if (!pidstr) {\n-        fprintf(stderr, MSGPREFIX \"no CRTOOLS_INIT_PID: signals may not be delivered\\n\");\n-    }\n-    g_pid = pidstr ? atoi(pidstr) : -1;\n-\n-    struct sigaction sigact;\n-    sigfillset(&sigact.sa_mask);\n-    sigact.sa_flags = SA_SIGINFO;\n-    sigact.sa_sigaction = sighandler;\n-\n-    int sig;\n-    for (sig = 1; sig <= 31; ++sig) {\n-        if (sig == SIGKILL || sig == SIGSTOP) {\n-            continue;\n-        }\n-        if (-1 == sigaction(sig, &sigact, NULL)) {\n-            perror(\"sigaction\");\n-        }\n-    }\n-\n-    sigset_t allset;\n-    sigfillset(&allset);\n-    if (-1 == sigprocmask(SIG_UNBLOCK, &allset, NULL)) {\n-        perror(MSGPREFIX \"sigprocmask\");\n-    }\n-\n-    int status;\n-    int ret;\n-    do {\n-        ret = waitpid(g_pid, &status, 0);\n-    } while (ret == -1 && errno == EINTR);\n-\n-    if (ret == -1) {\n-        perror(MSGPREFIX \"waitpid\");\n-        return 1;\n-    }\n-\n-    if (WIFEXITED(status)) {\n-        return WEXITSTATUS(status);\n-    }\n-\n-    if (WIFSIGNALED(status)) {\n-        \/\/ Try to terminate the current process with the same signal\n-        \/\/ as the child process was terminated\n-        const int sig = WTERMSIG(status);\n-        signal(sig, SIG_DFL);\n-        raise(sig);\n-        \/\/ Signal was ignored, return 128+n as bash does\n-        \/\/ see https:\/\/linux.die.net\/man\/1\/bash\n-        return 128+sig;\n-    }\n-\n-    return 1;\n-}\n-\n-\/\/ return value is one argument after options\n-static char *parse_options(int argc, char *argv[]) {\n-    optind = 2; \/\/ starting after action\n-    struct option opts[] = {{\n-        .name = \"verbosity\",\n-        .has_arg = 1,\n-        .flag = NULL,\n-        .val = 'v'\n-    }, {\n-        .name = \"log-file\",\n-        .has_arg = 1,\n-        .flag = NULL,\n-        .val = 'o',\n-    }, { NULL, 0, NULL, 0} };\n-    bool processing = true;\n-    do {\n-        switch (getopt_long(argc, argv, \"v:o:\", opts, NULL)) {\n-            case -1:\n-            case '?':\n-                processing = false;\n-                break;\n-            case 'v':\n-                if (asprintf(&verbosity, \"--verbosity=%s\", optarg) < 0) {\n-                    fprintf(stderr, \"Cannot set verbosity level\\n\");\n-                    verbosity = NULL;\n-                }\n-                break;\n-            case 'o':\n-                log_file = optarg;\n-                break;\n-        }\n-    } while (processing);\n-    return optind < argc ? argv[optind] : NULL;\n-}\n-\n-int main(int argc, char *argv[]) {\n-    char* action;\n-    if (argc >= 2 && (action = argv[1])) {\n-\n-        char* imagedir = parse_options(argc, argv);\n-\n-        char *basedir = dirname(strdup(argv[0]));\n-\n-        std::string criu;\n-        const char *criu_s = getenv(\"CRAC_CRIU_PATH\");\n-        if (criu_s) {\n-          criu = criu_s;\n-        } else {\n-            criu = std::string(basedir) + \"\/criu\";\n-            struct stat st;\n-            if (stat(criu.c_str(), &st)) {\n-                \/* some problem with the bundled criu *\/\n-                criu = \"\/usr\/sbin\/criu\";\n-                if (stat(criu.c_str(), &st)) {\n-                    fprintf(stderr, \"cannot find CRIU to use\\n\");\n-                    return 1;\n-                }\n-            }\n-        }\n-\n-\n-        if (!strcmp(action, \"checkpoint\")) {\n-            pid_t jvm = getppid();\n-            return checkpoint(jvm, basedir, argv[0], criu.c_str(), imagedir);\n-        } else if (!strcmp(action, \"restore\")) {\n-            return restore(basedir, argv[0], criu.c_str(), imagedir);\n-        } else if (!strcmp(action, \"restorewait\")) { \/\/ called by CRIU --exec-cmd\n-            return restorewait();\n-        } else {\n-            fprintf(stderr, \"unknown command-line action: %s\\n\", action);\n-            return 1;\n-        }\n-    } else if ((action = getenv(\"CRTOOLS_SCRIPT_ACTION\"))) { \/\/ called by CRIU --action-script\n-        if (!strcmp(action, \"post-resume\")) {\n-            return post_resume();\n-        } else {\n-            \/\/ ignore other notifications\n-            return 0;\n-        }\n-    } else {\n-        fprintf(stderr, \"unknown context\\n\");\n-    }\n-\n-    return 1;\n-}\n","filename":"src\/java.base\/unix\/native\/criuengine\/criuengine.cpp","additions":0,"deletions":477,"binary":false,"changes":477,"status":"deleted"}]}