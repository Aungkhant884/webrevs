{"files":[{"patch":"@@ -0,0 +1,202 @@\n+\/*\n+ * Copyright (c) 2022, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test JoinSleepWaitOnCRPauseTest.java\n+ * @requires (os.family == \"linux\")\n+ * @library \/test\/lib\n+ * @summary check if Thread.join(timeout), Thread.sleep(timeout)\n+ *          and Object.wait(timeout)\n+ *          will be completed on restore immediately\n+ *          if their end time fell on the CRaC pause period\n+ *          (i.e. between the checkpoint and restore)\n+ *\n+ * @run main\/othervm JoinSleepWaitOnCRPauseTest join_ms\n+ * @run main\/othervm JoinSleepWaitOnCRPauseTest join_ns\n+ * @run main\/othervm JoinSleepWaitOnCRPauseTest sleep_ms\n+ * @run main\/othervm JoinSleepWaitOnCRPauseTest sleep_ns\n+ * @run main\/othervm JoinSleepWaitOnCRPauseTest wait_ms\n+ * @run main\/othervm JoinSleepWaitOnCRPauseTest wait_ns\n+ *\/\n+\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import java.util.concurrent.CountDownLatch;\n+\n+\n+public class JoinSleepWaitOnCRPauseTest {\n+\n+    private static enum TestType {\n+        join_ms, join_ns, sleep_ms, sleep_ns, wait_ms, wait_ns};\n+    private final TestType testType;\n+\n+    private final static long EPS_NS = Long.parseLong(System.getProperty(\n+        \"test.jdk.jdk.crac.java.lang.Thread.crac.JoinSleepWaitOnCRPauseTest.eps\",\n+        \"100000000\")); \/\/ default: 0.1s\n+\n+    private static final long CRPAUSE_MS = 4000;\n+\n+    private static final long T_MS = CRPAUSE_MS \/ 2;\n+    private static final  int T_NS = 100;\n+\n+    private volatile long tDone = -1;\n+\n+    private final CountDownLatch checkpointLatch = new CountDownLatch(1);\n+\n+\n+    private JoinSleepWaitOnCRPauseTest(TestType testType) {\n+        this.testType = testType;\n+    }\n+\n+    private void runTest() throws Exception {\n+\n+        String op = testType.name();\n+        op = op.substring(0, op.length() - 3); \/\/ remove suffix\n+\n+        Thread mainThread = Thread.currentThread();\n+\n+        Runnable r = () -> {\n+\n+            try {\n+\n+                checkpointLatch.countDown();\n+\n+                switch (testType) {\n+\n+                    case join_ms:\n+                        mainThread.join(T_MS);\n+                        break;\n+\n+                    case join_ns:\n+                        mainThread.join(T_MS, T_NS);\n+                        break;\n+\n+                    case sleep_ms:\n+                        Thread.sleep(T_MS);\n+                        break;\n+\n+                    case sleep_ns:\n+                        Thread.sleep(T_MS, T_NS);\n+                        break;\n+\n+                    case wait_ms:\n+                        synchronized(this) { wait(T_MS);  }\n+                        break;\n+\n+                    case wait_ns:\n+                        synchronized(this) { wait(T_MS, T_NS);  }\n+                        break;\n+\n+                    default:\n+                        throw new IllegalArgumentException(\"unknown test type\");\n+                }\n+\n+            } catch (InterruptedException ie) {\n+                throw new RuntimeException(ie);\n+            }\n+\n+            tDone = System.nanoTime();\n+        };\n+\n+        Thread t = new Thread(r);\n+        t.start();\n+\n+        \/\/ this additional synchronization is probably redundant;\n+        \/\/ adding it to ensure we get the expected TIMED_WAITING state\n+        \/\/ from \"our\" join or sleep\n+        checkpointLatch.await();\n+\n+        \/\/ it is expected that EPS_NS is enough to complete the join\/sleep\n+        \/\/ on restore => expecting that 5 * EPS_NS is enough to enter them\n+        long dt = 5 * EPS_NS;\n+        Thread.sleep(dt \/ 1_000_000);\n+\n+        if (t.getState() != Thread.State.TIMED_WAITING) {\n+            throw new AssertionError(\"was not able to enter \" + op\n+                + \" in \" + dt + \" ns\");\n+        }\n+\n+        long tBeforeCheckpoint = System.nanoTime();\n+\n+        jdk.crac.Core.checkpointRestore();\n+\n+        long tAfterRestore = System.nanoTime();\n+\n+        t.join();\n+\n+        long pause = tAfterRestore - tBeforeCheckpoint;\n+        if (pause < 1_000_000 * CRPAUSE_MS - EPS_NS) {\n+            throw new AssertionError(\n+                \"the CR pause was less than \" + CRPAUSE_MS + \" ms\");\n+        }\n+\n+        if (tDone < tBeforeCheckpoint + EPS_NS) {\n+            throw new AssertionError(\n+                op + \" has finished before the checkpoint\");\n+        }\n+\n+        long eps = Math.abs(tAfterRestore - tDone);\n+\n+        if (eps > EPS_NS) {\n+            throw new RuntimeException(\n+                \"the \" + op + \"ing thread has finished in \" + eps + \" ns \"\n+                + \"after the restore (expected: \" + EPS_NS + \" ns)\");\n+        }\n+    }\n+\n+\n+    public static void main(String args[]) throws Exception {\n+\n+        if (args.length > 1) {\n+\n+            new JoinSleepWaitOnCRPauseTest(\n+                    TestType.valueOf(args[0])).runTest();\n+\n+        } else if (args.length > 0) {\n+\n+            String crImg = \"cr_\" + args[0];\n+\n+            ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n+                \"-XX:CRaCCheckpointTo=\" + crImg, \"JoinSleepWaitOnCRPauseTest\",\n+                args[0], \"runTest\");\n+            OutputAnalyzer out = new OutputAnalyzer(pb.start());\n+            out.shouldContain(\"CR: Checkpoint\");\n+            out.shouldHaveExitValue(137);\n+\n+            \/\/ sleep a few seconds to ensure the task execution time\n+            \/\/ falls within this pause period\n+            Thread.sleep(CRPAUSE_MS);\n+\n+            pb = ProcessTools.createJavaProcessBuilder(\n+                \"-XX:CRaCRestoreFrom=\" + crImg, \"JoinSleepWaitOnCRPauseTest\");\n+            out = new OutputAnalyzer(pb.start());\n+            out.shouldHaveExitValue(0);\n+\n+        } else {\n+\n+            throw new IllegalArgumentException(\"please provide a test type\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/java\/lang\/Thread\/JoinSleepWaitOnCRPauseTest.java","additions":202,"deletions":0,"binary":false,"changes":202,"status":"added"}]}