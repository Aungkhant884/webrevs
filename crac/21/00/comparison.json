{"files":[{"patch":"@@ -120,0 +120,1 @@\n+JVM_GetModifiableProperties\n","filename":"make\/data\/hotspot-symbols\/symbols-unix","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -5844,5 +5844,11 @@\n-static int set_new_args(int id, const char *args) {\n-    char shmpath[128];\n-    int shmpathlen = snprintf(shmpath, sizeof(shmpath), \"\/crac_%d\", id);\n-    if (shmpathlen < 0 || sizeof(shmpath) <= (size_t)shmpathlen) {\n-      fprintf(stderr, \"shmpath is too long: %d\\n\", shmpathlen);\n+static int set_new_args(int id, const int props_count, const SystemProperty *props, const char *args) {\n+  char shmpath[128];\n+  int shmpathlen = snprintf(shmpath, sizeof(shmpath), \"\/crac_%d\", id);\n+  if (shmpathlen < 0 || sizeof(shmpath) <= (size_t)shmpathlen) {\n+    fprintf(stderr, \"shmpath is too long: %d\\n\", shmpathlen);\n+    return -1;\n+  }\n+\n+  int shmfd = shm_open(shmpath, O_RDWR | O_CREAT, 0600);\n+  if (-1 == shmfd) {\n+      perror(\"shm_open\");\n@@ -5850,1 +5856,1 @@\n-    }\n+  }\n@@ -5852,4 +5858,11 @@\n-    int shmfd = shm_open(shmpath, O_RDWR | O_CREAT, 0600);\n-    if (-1 == shmfd) {\n-        perror(\"shm_open\");\n-        return -1;\n+  write(shmfd, (void *)&props_count, sizeof(props_count));\n+  if (props != NULL) {\n+    const SystemProperty *p = props;\n+    while (p != NULL) {\n+      const char *key_value_seperator = \"=\";\n+      const char *key = p->key();\n+      const char *value = p->value();\n+      write(shmfd, key, strlen(key));\n+      write(shmfd, key_value_seperator, strlen(key_value_seperator));\n+      write(shmfd, value, strlen(value)+1); \/\/ +1 for the null character\n+      p = p->next();\n@@ -5857,0 +5870,1 @@\n+  }\n@@ -5858,11 +5872,7 @@\n-    int argslen = strlen(args);\n-    int wret = write(shmfd, args, argslen);\n-    if (argslen != wret) {\n-        if (wret < 0) {\n-            perror(\"write shm\");\n-        } else {\n-            fprintf(stderr, \"write shm truncated\");\n-        }\n-        close(shmfd);\n-        shm_unlink(shmpath);\n-        return -1;\n+  int argslen = strlen(args) + 1; \/\/ +1 for the null character\n+  int wret = write(shmfd, args, argslen);\n+  if (argslen != wret) {\n+    if (wret < 0) {\n+      perror(\"write shm\");\n+    } else {\n+      fprintf(stderr, \"write shm truncated\");\n@@ -5870,1 +5880,0 @@\n-\n@@ -5872,1 +5881,7 @@\n-    return 0;\n+    shm_unlink(shmpath);\n+    return -1;\n+  }\n+\n+  close(shmfd);\n+\n+  return 0;\n@@ -5894,2 +5909,2 @@\n-    char *args = NEW_C_HEAP_ARRAY(char, st.st_size + 1, mtInternal);\n-    if (read(shmfd, args, st.st_size) < 0) {\n+    char *contents = NEW_C_HEAP_ARRAY(char, st.st_size, mtInternal);\n+    if (read(shmfd, contents, st.st_size) < 0) {\n@@ -5898,1 +5913,1 @@\n-      FREE_C_HEAP_ARRAY(char, args);\n+      FREE_C_HEAP_ARRAY(char, contents);\n@@ -5902,1 +5917,14 @@\n-    args[st.st_size] = '\\0';\n+    \/\/ parse the contents to read new system properties and arguments\n+    int num_props = *(int *)contents;\n+\n+    char *props = contents + sizeof(num_props);\n+    while (num_props > 0) {\n+      assert((props + strlen(props) <= contents + st.st_size), \"property length exceeds shared memory size\");\n+      Arguments::add_or_modify_property(props);\n+      num_props -= 1;\n+      props = props + strlen(props) + 1;\n+    }\n+\n+    char *args = NEW_C_HEAP_ARRAY(char, strlen(props) + 1, mtInternal);\n+    memcpy(args, props, strlen(props) + 1);\n+    FREE_C_HEAP_ARRAY(char, contents);\n@@ -6285,0 +6313,2 @@\n+  SystemProperty* props = Arguments::system_properties_for_restore();\n+  int props_count = Arguments::PropertyList_count(props);\n@@ -6286,1 +6316,1 @@\n-  if (set_new_args(id, args)) {\n+  if (set_new_args(id, props_count, props, args)) {\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":58,"deletions":28,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -103,0 +103,6 @@\n+\/*\n+ * Return an array of all modifiable properties as alternating name and value pairs.\n+ *\/\n+JNIEXPORT jobjectArray JNICALL\n+JVM_GetModifiableProperties(JNIEnv *env);\n+\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -318,0 +318,34 @@\n+\/*\n+ * Return all of the system properties in a Java String array with alternating\n+ * names and values from the jvm SystemProperty which are modifiable on restore.\n+ *\/\n+JVM_ENTRY(jobjectArray, JVM_GetModifiableProperties(JNIEnv *env))\n+  ResourceMark rm(THREAD);\n+  HandleMark hm(THREAD);\n+  int ndx = 0;\n+\n+  SystemProperty* p = Arguments::system_properties();\n+  int count = Arguments::PropertyList_modifiable_count(p);\n+\n+  \/\/ Allocate result String array\n+  InstanceKlass* ik = vmClasses::String_klass();\n+  objArrayOop r = oopFactory::new_objArray(ik, count * 2, CHECK_NULL);\n+  objArrayHandle result_h(THREAD, r);\n+\n+  while (p != NULL) {\n+    const char * key = p->key();\n+    if (p->modifiable_on_restore() &&\n+       (strcmp(key, \"sun.nio.MaxDirectMemorySize\") != 0)) {\n+        const char * value = p->value();\n+        Handle key_str    = java_lang_String::create_from_platform_dependent_str(key, CHECK_NULL);\n+        Handle value_str  = java_lang_String::create_from_platform_dependent_str((value != NULL ? value : \"\"), CHECK_NULL);\n+        result_h->obj_at_put(ndx * 2,  key_str());\n+        result_h->obj_at_put(ndx * 2 + 1, value_str());\n+        ndx++;\n+    }\n+    p = p->next();\n+  }\n+\n+  return (jobjectArray) JNIHandles::make_local(THREAD, result_h());\n+JVM_END\n+\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":34,"deletions":0,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -76,0 +76,1 @@\n+SystemProperty* Arguments::_system_properties_for_restore = NULL;\n@@ -195,1 +196,1 @@\n-SystemProperty::SystemProperty(const char* key, const char* value, bool writeable, bool internal) : PathString(value) {\n+SystemProperty::SystemProperty(const char* key, const char* value, bool writeable, bool internal, bool modifiable_on_restore) : PathString(value) {\n@@ -205,0 +206,1 @@\n+  _modifiable_on_restore = modifiable_on_restore;\n@@ -1310,1 +1312,3 @@\n-bool Arguments::add_property(const char* prop, PropertyWriteable writeable, PropertyInternal internal) {\n+void Arguments::get_key_value(const char* prop, const char** key, const char** value) {\n+  assert(key != NULL, \"key should not be NULL\");\n+  assert(value != NULL, \"value should not be NULL\");\n@@ -1312,2 +1316,0 @@\n-  const char* key;\n-  const char* value = \"\";\n@@ -1317,1 +1319,2 @@\n-    key = prop;\n+    *key = prop;\n+    *value = \"\";\n@@ -1325,1 +1328,1 @@\n-    key = tmp_key;\n+    *key = tmp_key;\n@@ -1327,1 +1330,1 @@\n-    value = &prop[key_len + 1];\n+    *value = &prop[key_len + 1];\n@@ -1329,0 +1332,44 @@\n+}\n+\n+bool Arguments::add_property_for_restore(const char* prop, PropertyWriteable writeable, PropertyInternal internal) {\n+  const char* key = NULL;\n+  const char* value = NULL;\n+\n+  get_key_value(prop, &key, &value);\n+\n+  \/* Only interested in key and value pair, other property attributes don't matter.\n+   * These properties are only used for passing on to the JVM being restored.\n+   *\/\n+  PropertyList_unique_add(&_system_properties_for_restore, key, value, AddProperty, writeable, internal, ModifiableProperty);\n+\n+  if (key != prop) {\n+    \/\/ SystemProperty copy passed value, thus free previously allocated\n+    \/\/ memory\n+    FreeHeap((void *)key);\n+  }\n+\n+  return true;\n+}\n+\n+bool Arguments::add_or_modify_property(const char* prop) {\n+  const char* key = NULL;\n+  const char* value = NULL;\n+\n+  get_key_value(prop, &key, &value);\n+\n+  PropertyList_modifiable_add(&_system_properties, key, value);\n+\n+  if (key != prop) {\n+    \/\/ SystemProperty copy passed value, thus free previously allocated\n+    \/\/ memory\n+    FreeHeap((void *)key);\n+  }\n+\n+  return true;\n+}\n+\n+bool Arguments::add_property(const char* prop, PropertyModifiableOnRestore modifiable_on_restore, PropertyWriteable writeable, PropertyInternal internal) {\n+  const char* key = NULL;\n+  const char* value = NULL;\n+\n+  get_key_value(prop, &key, &value);\n@@ -1354,1 +1401,1 @@\n-                            WriteableProperty, ExternalProperty);\n+                            WriteableProperty, ExternalProperty, UnmodifiableProperty);\n@@ -1362,0 +1409,1 @@\n+      modifiable_on_restore = UnmodifiableProperty;\n@@ -1375,0 +1423,3 @@\n+      modifiable_on_restore = UnmodifiableProperty;\n+    } else if (strcmp(key, \"sun.java.launcher\") == 0) {\n+      modifiable_on_restore = UnmodifiableProperty;\n@@ -1378,1 +1429,1 @@\n-    PropertyList_unique_add(&_system_properties, key, value, AddProperty, writeable, internal);\n+    PropertyList_unique_add(&_system_properties, key, value, AddProperty, writeable, internal, modifiable_on_restore);\n@@ -1455,1 +1506,1 @@\n-                          VM_Version::vm_info_string(), AddProperty, UnwriteableProperty, ExternalProperty);\n+                          VM_Version::vm_info_string(), AddProperty, UnwriteableProperty, ExternalProperty, UnmodifiableProperty);\n@@ -1929,1 +1980,1 @@\n-    if (!add_property(buffer)) {\n+    if (!add_property(buffer, UnmodifiableProperty)) {\n@@ -2004,1 +2055,1 @@\n-        AddProperty, UnwriteableProperty, InternalProperty);\n+        AddProperty, UnwriteableProperty, InternalProperty, UnmodifiableProperty);\n@@ -2081,1 +2132,1 @@\n-  bool added = add_property(property, WriteableProperty, internal);\n+  bool added = add_property(property, UnmodifiableProperty, WriteableProperty, internal);\n@@ -2102,1 +2153,1 @@\n-    bool added = add_property(property, UnwriteableProperty, InternalProperty);\n+    bool added = add_property(property, UnmodifiableProperty, UnwriteableProperty, InternalProperty);\n@@ -2309,0 +2360,12 @@\n+bool Arguments::is_restore_option_set(const JavaVMInitArgs* args) {\n+  const char* tail;\n+  \/\/ iterate over arguments\n+  for (int index = 0; index < args->nOptions; index++) {\n+    const JavaVMOption* option = args->options + index;\n+    if (match_option(option, \"-XX:CRaCRestoreFrom\", &tail)) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n@@ -2312,0 +2375,1 @@\n+  bool is_restoring = false;\n@@ -2652,2 +2716,7 @@\n-      if (!add_property(tail)) {\n-        return JNI_ENOMEM;\n+      is_restoring = (is_restoring || is_restore_option_set(args));\n+      if (is_restoring) {\n+        add_property_for_restore(tail);\n+      } else {\n+        if (!add_property(tail)) {\n+          return JNI_ENOMEM;\n+        }\n@@ -2937,0 +3006,3 @@\n+        if (!strncmp(tail, \"CRaCRestoreFrom\", strlen(\"CRaCRestoreFrom\"))) {\n+          is_restoring = true;\n+        }\n@@ -4157,0 +4229,12 @@\n+\/\/ Return the number of modifiable properties.\n+int Arguments::PropertyList_modifiable_count(SystemProperty* pl) {\n+  int count = 0;\n+  while(pl != NULL) {\n+    if (pl->modifiable_on_restore()) {\n+      count++;\n+    }\n+    pl = pl->next();\n+  }\n+  return count;\n+}\n+\n@@ -4244,1 +4328,1 @@\n-                                 bool writeable, bool internal) {\n+                                 bool writeable, bool internal, bool modifiable_on_restore) {\n@@ -4248,1 +4332,1 @@\n-  SystemProperty* new_p = new SystemProperty(k, v, writeable, internal);\n+  SystemProperty* new_p = new SystemProperty(k, v, writeable, internal, modifiable_on_restore);\n@@ -4259,1 +4343,1 @@\n-                                        PropertyInternal internal) {\n+                                        PropertyInternal internal, PropertyModifiableOnRestore modifiable_on_restore) {\n@@ -4277,1 +4361,21 @@\n-  PropertyList_add(plist, k, v, writeable == WriteableProperty, internal == InternalProperty);\n+  PropertyList_add(plist, k, v, writeable == WriteableProperty, internal == InternalProperty, modifiable_on_restore == ModifiableProperty);\n+}\n+\n+void Arguments::PropertyList_modifiable_add(SystemProperty** plist, const char* k, const char* v) {\n+  if (plist == NULL)\n+    return;\n+\n+  \/\/ If property key exists and is modifiable, then update with the new value.\n+  \/\/ If property key does not exist, add it to the list.\n+  \/\/ If property key exists and is not modifiable, it is silently ignored.\n+  SystemProperty* prop;\n+  for (prop = *plist; prop != NULL; prop = prop->next()) {\n+    if (strcmp(k, prop->key()) == 0) {\n+      if (prop->modifiable_on_restore()) {\n+        prop->set_value(v);\n+      }\n+      return;\n+    }\n+  }\n+\n+  PropertyList_add(plist, k, v, true, false, true);\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":124,"deletions":20,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -96,0 +96,1 @@\n+  bool            _modifiable_on_restore;\n@@ -103,0 +104,1 @@\n+  bool modifiable_on_restore()        { return _modifiable_on_restore; }\n@@ -130,1 +132,1 @@\n-  SystemProperty(const char* key, const char* value, bool writeable, bool internal = false);\n+  SystemProperty(const char* key, const char* value, bool writeable, bool internal = false, bool modifiable = false);\n@@ -264,0 +266,5 @@\n+  enum PropertyModifiableOnRestore {\n+    ModifiableProperty,\n+    UnmodifiableProperty\n+  };\n+\n@@ -280,0 +287,3 @@\n+  \/\/ Property list when restoring from checkpoint\n+  static SystemProperty* _system_properties_for_restore;\n+\n@@ -379,3 +389,3 @@\n-  \/\/ System properties\n-  static bool add_property(const char* prop, PropertyWriteable writeable=WriteableProperty,\n-                           PropertyInternal internal=ExternalProperty);\n+  \/\/ prop points to a string of the form key=value\n+  \/\/ Parse the string to extract key and the value\n+  static void get_key_value(const char* prop, const char** key, const char** value);\n@@ -471,0 +481,6 @@\n+  \/\/ restore feature\n+  static bool add_property_for_restore(const char* prop,\n+                                       PropertyWriteable writeable=WriteableProperty,\n+                                       PropertyInternal internal=ExternalProperty);\n+  static bool is_restore_option_set(const JavaVMInitArgs* args);\n+\n@@ -524,0 +540,8 @@\n+  \/\/ System properties\n+  static bool add_property(const char* prop,\n+                           PropertyModifiableOnRestore modifiable_on_restore=ModifiableProperty,\n+                           PropertyWriteable writeable=WriteableProperty,\n+                           PropertyInternal internal=ExternalProperty);\n+\n+  static bool add_or_modify_property(const char* prop);\n+\n@@ -570,1 +594,1 @@\n-  static void PropertyList_add(SystemProperty** plist, const char* k, const char* v, bool writeable, bool internal);\n+  static void PropertyList_add(SystemProperty** plist, const char* k, const char* v, bool writeable, bool internal, bool modifiable_on_restore);\n@@ -574,1 +598,2 @@\n-                                      PropertyInternal internal);\n+                                      PropertyInternal internal, PropertyModifiableOnRestore modifiable);\n+  static void PropertyList_modifiable_add(SystemProperty** plist, const char* k, const char* v);\n@@ -578,0 +603,1 @@\n+  static int  PropertyList_modifiable_count(SystemProperty* pl);\n@@ -627,0 +653,3 @@\n+  \/\/ restore feature\n+  static SystemProperty* system_properties_for_restore() { return _system_properties_for_restore; }\n+\n","filename":"src\/hotspot\/share\/runtime\/arguments.hpp","additions":35,"deletions":6,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -69,0 +69,3 @@\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import jdk.internal.crac.JDKResource;\n@@ -116,0 +119,4 @@\n+    private static final String CHECKPOINT_ARG = \"-XX:CRaCCheckpointTo\";\n+\n+    private static boolean canCheckpoint = false;\n+\n@@ -2076,0 +2083,30 @@\n+    static class CRaCResource implements JDKResource {\n+        public void beforeCheckpoint(Context<? extends Resource> context) {\n+            \/* Nothing to do here *\/\n+        }\n+\n+        public void afterRestore(Context<? extends Resource> context) {\n+            Map<String, String> propMap = SystemProps.getPropertiesOnRestore();\n+            \/\/ Should VM::savedProps be updated as well?\n+            \/\/ It can be avoided as it is mainly used to get JVMCI or jdk specific properties\n+            \/\/ which are mostly likely \"unmodifiable\" on restore.\n+            \/\/ If this changes, then deal with updating VM::savedProps here.\n+\n+            \/\/ call createProperties to mask out system properties not for public access\n+            Properties tempProps = createProperties(propMap);\n+            if (props != null) {\n+                props.putAll(tempProps);\n+            } else {\n+                props = tempProps;\n+            }\n+        }\n+\n+        public Priority getPriority() {\n+            return Priority.JLSYSTEM;\n+        }\n+    }\n+\n+    private static void registerCRaCResource() {\n+        jdk.internal.crac.Core.getJDKContext().register(new CRaCResource());\n+    }\n+\n@@ -2134,0 +2171,11 @@\n+        \/\/ Check runtime args for the checkpoint argument\n+        String[] vmArgs = VM.getRuntimeArguments();\n+        if (vmArgs != null) {\n+            for (String arg : vmArgs) {\n+                if (arg != null && arg.contains(CHECKPOINT_ARG)) {\n+                    canCheckpoint = true;\n+                    break;\n+                }\n+            }\n+        }\n+\n@@ -2251,0 +2299,4 @@\n+        if (canCheckpoint) {\n+            registerCRaCResource();\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -86,0 +86,8 @@\n+\n+        \/**\n+         * Priority of the\n+         * java.lang.System resources\n+         * Keep this at the last as the j.l.System resources should be the first\n+         * to be handled on restore.\n+         *\/\n+        JLSYSTEM,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/JDKResource.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -116,0 +116,5 @@\n+    public static Map<String, String> getPropertiesOnRestore() {\n+        return new Raw().cmdPropertiesOnRestore();\n+    }\n+\n+\n@@ -246,9 +251,1 @@\n-        \/**\n-         * Return a Properties instance of the command line and VM options\n-         * defined by name and value.\n-         * The Properties instance is sized to include the fixed properties.\n-         *\n-         * @return return a Properties instance of the command line and VM options\n-         *\/\n-        private HashMap<String, String> cmdProperties() {\n-            String[] vmProps = vmProperties();\n+        private HashMap<String, String> convertToMap(String[] props) {\n@@ -258,3 +255,3 @@\n-            var cmdProps = new HashMap<String, String>((vmProps.length \/ 2) + Raw.FIXED_LENGTH);\n-            for (int i = 0; i < vmProps.length;) {\n-                String k = vmProps[i++];\n+            var cmdProps = new HashMap<String, String>((props.length \/ 2) + Raw.FIXED_LENGTH);\n+            for (int i = 0; i < props.length;) {\n+                String k = props[i++];\n@@ -262,1 +259,1 @@\n-                    String v = vmProps[i++];\n+                    String v = props[i++];\n@@ -272,0 +269,27 @@\n+        \/**\n+         * Return a Properties instance of the command line and VM options\n+         * defined by name and value.\n+         * The Properties instance is sized to include the fixed properties.\n+         *\n+         * @return return a Properties instance of the command line and VM options\n+         *\/\n+        private HashMap<String, String> cmdProperties() {\n+            String[] vmProps = vmProperties();\n+            return convertToMap(vmProps);\n+        }\n+\n+        \/**\n+         * Return a HashMap instance of the new command line and VM options\n+         * defined by name and value on restore.\n+         * If no new properties are available, returns an empty map.\n+         *\n+         * @return return a HashMap instance of the command line and VM options\n+         *\/\n+        private HashMap<String, String> cmdPropertiesOnRestore() {\n+            String[] vmProps = vmPropertiesOnRestore();\/\/vmPropertiesOnRestore();\n+            if (vmProps != null && vmProps.length > 0) {\n+                return convertToMap(vmProps);\n+            }\n+            return new HashMap<String, String>();\n+        }\n+\n@@ -283,0 +307,2 @@\n+        private static native String[] vmPropertiesOnRestore();\/\/ { return null; }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/SystemProps.java","additions":39,"deletions":13,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -229,0 +229,19 @@\n+\/*\n+ * Gather the modifiable VM and command line properties and return as a String[].\n+ * The array indices are alternating key\/value pairs\n+ * supplied by the VM including those defined on the command line\n+ * using -Dkey=value that may override the platform defined value.\n+ *\n+ * Note: The platform encoding must have been set.\n+ *\n+ * Class:     jdk_internal_util_SystemProps_Raw\n+ * Method:    vmPropertiesOnRestore\n+ * Signature: ()[Ljava\/lang\/String;\n+ *\/\n+JNIEXPORT jobjectArray JNICALL\n+Java_jdk_internal_util_SystemProps_00024Raw_vmPropertiesOnRestore(JNIEnv *env, jclass cla)\n+{\n+    jobjectArray cmdProps = JVM_GetModifiableProperties(env);\n+    return cmdProps;\n+}\n+\n","filename":"src\/java.base\/share\/native\/libjava\/System.c","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"}]}