{"files":[{"patch":"@@ -285,0 +285,108 @@\n+class VM_CracRestoreParameters : public CHeapObj<mtInternal> {\n+ private:\n+  int _nprops;\n+  GrowableArray<const char *>* _properties;\n+  const char* _args;\n+\n+  int write_check_error(int fd, const void *buf, int count) {\n+    int wret = write(fd, buf, count);\n+    if (wret != count) {\n+      if (wret < 0) {\n+        perror(\"shm error\");\n+      } else {\n+        fprintf(stderr, \"write shm truncated\");\n+      }\n+      return wret;\n+    }\n+    return 0;\n+  }\n+\n+ public:\n+  VM_CracRestoreParameters(const SystemProperty* props, const char *args) :\n+    _nprops(0),\n+    _properties(new (ResourceObj::C_HEAP, mtInternal) GrowableArray<const char *>(0, mtInternal)),\n+    _args(args)\n+  {\n+    const SystemProperty *p = props;\n+    while (p != NULL) {\n+      const char *eq = \"=\";\n+      int prop_len = strlen(p->key()) + strlen(p->value()) + strlen(eq) + 1; \/\/ +1 for null char\n+      char *prop = NEW_C_HEAP_ARRAY(char, prop_len, mtInternal);\n+      strcpy(prop, p->key());\n+      strcat(prop, eq);\n+      strcat(prop, p->value());\n+      _properties->append(prop);\n+      p = p->next();\n+      _nprops += 1;\n+    }\n+  }\n+\n+  VM_CracRestoreParameters(int nprops, GrowableArray<const char *>* properties, char *args) :\n+    _nprops(nprops),\n+    _properties(properties),\n+    _args(args)\n+  {}\n+\n+  const char *args() const { return _args; }\n+  GrowableArray<const char *>* properties() const { return _properties; }\n+\n+  ~VM_CracRestoreParameters() {\n+    for (int i = 0; i < _properties->length(); i++) {\n+      FREE_C_HEAP_ARRAY(char, _properties->at(i));\n+    }\n+    if (_args) {\n+      FREE_C_HEAP_ARRAY(char, _args);\n+    }\n+    delete _properties;\n+  }\n+\n+  int write_to(int fd) {\n+    int wret = write_check_error(fd, (void *)&_nprops, sizeof(_nprops));\n+\n+    for (int i = 0; i < _properties->length(); i++) {\n+      const char *prop = _properties->at(i);\n+      write_check_error(fd, prop, strlen(prop)+1);\n+    }\n+\n+    wret |= write_check_error(fd, _args, strlen(_args) + 1); \/\/ +1 for null char\n+    return wret;\n+  }\n+\n+  static VM_CracRestoreParameters* read_from(int fd) {\n+    struct stat st;\n+    if (fstat(fd, &st)) {\n+      perror(\"fstat (ignoring restore parameters)\");\n+      return NULL;\n+    }\n+\n+    char *contents = NEW_C_HEAP_ARRAY(char, st.st_size, mtInternal);\n+    if (read(fd, contents, st.st_size) < 0) {\n+      perror(\"read (ignoring restore parameters)\");\n+      FREE_C_HEAP_ARRAY(char, contents);\n+      return NULL;\n+    }\n+\n+    \/\/ parse the contents to read new system properties and arguments\n+    int nprops = *(int *)contents;\n+    GrowableArray<const char *>* properties = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<const char *>(nprops, mtInternal);\n+\n+    char *cursor = contents + sizeof(_nprops);\n+    for (int i = 0; i < nprops; i++) {\n+      assert((cursor + strlen(cursor) <= contents + st.st_size), \"property length exceeds shared memory size\");\n+\n+      int prop_len = strlen(cursor) + 1;\n+      char *prop = NEW_C_HEAP_ARRAY(char, prop_len, mtInternal);\n+      strncpy(prop, cursor, prop_len);\n+\n+      properties->append(prop);\n+      cursor = cursor + prop_len;\n+    }\n+\n+    int argslen = strlen(cursor) + 1;\n+    char *args = NEW_C_HEAP_ARRAY(char, argslen, mtInternal);\n+    strncpy(args, cursor, argslen);\n+    FREE_C_HEAP_ARRAY(char, contents);\n+    return new VM_CracRestoreParameters(nprops, properties, args);\n+  }\n+};\n+\n@@ -289,1 +397,1 @@\n-  char* _new_args;\n+  VM_CracRestoreParameters *_restore_parameters;\n@@ -295,1 +403,1 @@\n-    _new_args(NULL)\n+    _restore_parameters(NULL)\n@@ -300,2 +408,2 @@\n-    if (_new_args) {\n-      FREE_C_HEAP_ARRAY(char, _new_args);\n+    if (_restore_parameters) {\n+      delete _restore_parameters;\n@@ -307,2 +415,2 @@\n-  char* new_args() { return _new_args; }\n-\n+  const char* new_args() { return _restore_parameters->args(); }\n+  GrowableArray<const char *>* new_properties() { return _restore_parameters->properties(); }\n@@ -312,0 +420,1 @@\n+  void read_shm(int shmid);\n@@ -5844,40 +5953,7 @@\n-static int set_new_args(int id, const char *args) {\n-    char shmpath[128];\n-    int shmpathlen = snprintf(shmpath, sizeof(shmpath), \"\/crac_%d\", id);\n-    if (shmpathlen < 0 || sizeof(shmpath) <= (size_t)shmpathlen) {\n-      fprintf(stderr, \"shmpath is too long: %d\\n\", shmpathlen);\n-      return -1;\n-    }\n-\n-    int shmfd = shm_open(shmpath, O_RDWR | O_CREAT, 0600);\n-    if (-1 == shmfd) {\n-        perror(\"shm_open\");\n-        return -1;\n-    }\n-\n-    int argslen = strlen(args);\n-    int wret = write(shmfd, args, argslen);\n-    if (argslen != wret) {\n-        if (wret < 0) {\n-            perror(\"write shm\");\n-        } else {\n-            fprintf(stderr, \"write shm truncated\");\n-        }\n-        close(shmfd);\n-        shm_unlink(shmpath);\n-        return -1;\n-    }\n-\n-    close(shmfd);\n-    return 0;\n-}\n-\n-static char* get_new_args(int id) {\n-    char shmpath[128];\n-    snprintf(shmpath, sizeof(shmpath), \"\/crac_%d\", id);\n-\n-    int shmfd = shm_open(shmpath, O_RDONLY, 0600);\n-    if (-1 == shmfd) {\n-      perror(\"shm_open (ignoring new args)\");\n-      return NULL;\n-    }\n+static int setup_shared_memory(int id, VM_CracRestoreParameters& parameters) {\n+  char shmpath[128];\n+  int shmpathlen = snprintf(shmpath, sizeof(shmpath), \"\/crac_%d\", id);\n+  if (shmpathlen < 0 || sizeof(shmpath) <= (size_t)shmpathlen) {\n+    fprintf(stderr, \"shmpath is too long: %d\\n\", shmpathlen);\n+    return -1;\n+  }\n@@ -5885,1 +5961,5 @@\n-    shm_unlink(shmpath);\n+  int shmfd = shm_open(shmpath, O_RDWR | O_CREAT, 0600);\n+  if (-1 == shmfd) {\n+      perror(\"shm_open\");\n+      return -1;\n+  }\n@@ -5887,6 +5967,2 @@\n-    struct stat st;\n-    if (fstat(shmfd, &st)) {\n-      perror(\"shm_open (ignoring new args)\");\n-      close(shmfd);\n-      return NULL;\n-    }\n+  int rc = parameters.write_to(shmfd);\n+  close(shmfd);\n@@ -5894,7 +5970,4 @@\n-    char *args = NEW_C_HEAP_ARRAY(char, st.st_size + 1, mtInternal);\n-    if (read(shmfd, args, st.st_size) < 0) {\n-      perror(\"read (ignoring new args)\");\n-      close(shmfd);\n-      FREE_C_HEAP_ARRAY(char, args);\n-      return NULL;\n-    }\n+  if (rc != 0) {\n+    fprintf(stderr, \"write to shared memory failed\");\n+    return -1;\n+  }\n@@ -5902,2 +5975,1 @@\n-    args[st.st_size] = '\\0';\n-    return args;\n+  return 0;\n@@ -5906,1 +5978,1 @@\n-static int checkpoint_restore(char** argp) {\n+static int checkpoint_restore(int *shmid) {\n@@ -5941,1 +6013,1 @@\n-    *argp = get_new_args(info.si_int);\n+    *shmid = info.si_int;\n@@ -6045,0 +6117,17 @@\n+void VM_Crac::read_shm(int shmid) {\n+    char shmpath[128];\n+    snprintf(shmpath, sizeof(shmpath), \"\/crac_%d\", shmid);\n+\n+    int shmfd = shm_open(shmpath, O_RDONLY, 0600);\n+    if (-1 == shmfd) {\n+      perror(\"shm_open (ignoring new args)\");\n+      return;\n+    }\n+\n+    shm_unlink(shmpath);\n+\n+    _restore_parameters = VM_CracRestoreParameters::read_from(shmfd);\n+\n+    close(shmfd);\n+    return;\n+}\n@@ -6137,1 +6226,3 @@\n-  int ret = checkpoint_restore(&_new_args);\n+\n+  int shmid = 0;\n+  int ret = checkpoint_restore(&shmid);\n@@ -6143,0 +6234,1 @@\n+  read_shm(shmid);\n@@ -6221,2 +6313,2 @@\n-static Handle ret_cr(int ret, Handle new_args, Handle err_codes, Handle err_msgs, TRAPS) {\n-  objArrayOop bundleObj = oopFactory::new_objectArray(4, CHECK_NH);\n+static Handle ret_cr(int ret, Handle new_args, Handle new_props, Handle err_codes, Handle err_msgs, TRAPS) {\n+  objArrayOop bundleObj = oopFactory::new_objectArray(5, CHECK_NH);\n@@ -6228,2 +6320,3 @@\n-  bundle->obj_at_put(2, err_codes());\n-  bundle->obj_at_put(3, err_msgs());\n+  bundle->obj_at_put(2, new_props());\n+  bundle->obj_at_put(3, err_codes());\n+  bundle->obj_at_put(4, err_msgs());\n@@ -6237,1 +6330,1 @@\n-    return ret_cr(JVM_CHECKPOINT_NONE, Handle(), Handle(), Handle(), THREAD);\n+    return ret_cr(JVM_CHECKPOINT_NONE, Handle(), Handle(), Handle(), Handle(), THREAD);\n@@ -6242,1 +6335,1 @@\n-    return ret_cr(JVM_CHECKPOINT_NONE, Handle(), Handle(), Handle(), THREAD);\n+    return ret_cr(JVM_CHECKPOINT_NONE, Handle(), Handle(), Handle(), Handle(), THREAD);\n@@ -6259,1 +6352,9 @@\n-    return ret_cr(JVM_CHECKPOINT_OK, Handle(THREAD, new_args), Handle(), Handle(), THREAD);\n+    GrowableArray<const char *>* new_properties = cr.new_properties();\n+    objArrayOop propsObj = oopFactory::new_objArray(vmClasses::String_klass(), new_properties->length(), CHECK_NH);\n+    objArrayHandle props(THREAD, propsObj);\n+\n+    for (int i = 0; i < new_properties->length(); i++) {\n+      oop propObj = java_lang_String::create_oop_from_str(new_properties->at(i), CHECK_NH);\n+      props->obj_at_put(i, propObj);\n+    }\n+    return ret_cr(JVM_CHECKPOINT_OK, Handle(THREAD, new_args), props, Handle(), Handle(), THREAD);\n@@ -6276,1 +6377,1 @@\n-  return ret_cr(JVM_CHECKPOINT_ERROR, Handle(), codes, msgs, THREAD);\n+  return ret_cr(JVM_CHECKPOINT_ERROR, Handle(), Handle(), codes, msgs, THREAD);\n@@ -6285,0 +6386,1 @@\n+  SystemProperty* props = Arguments::system_properties();\n@@ -6286,1 +6388,2 @@\n-  if (set_new_args(id, args)) {\n+  VM_CracRestoreParameters restore_parameters(props, args);\n+  if (setup_shared_memory(id, restore_parameters)) {\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":177,"deletions":74,"binary":false,"changes":251,"status":"modified"},{"patch":"@@ -76,0 +76,1 @@\n+SystemProperty* Arguments::_system_properties_for_restore = NULL;\n@@ -1310,1 +1311,3 @@\n-bool Arguments::add_property(const char* prop, PropertyWriteable writeable, PropertyInternal internal) {\n+void Arguments::get_key_value(const char* prop, const char** key, const char** value) {\n+  assert(key != NULL, \"key should not be NULL\");\n+  assert(value != NULL, \"value should not be NULL\");\n@@ -1312,2 +1315,0 @@\n-  const char* key;\n-  const char* value = \"\";\n@@ -1317,1 +1318,2 @@\n-    key = prop;\n+    *key = prop;\n+    *value = \"\";\n@@ -1325,1 +1327,1 @@\n-    key = tmp_key;\n+    *key = tmp_key;\n@@ -1327,1 +1329,1 @@\n-    value = &prop[key_len + 1];\n+    *value = &prop[key_len + 1];\n@@ -1329,0 +1331,7 @@\n+}\n+\n+bool Arguments::add_property(const char* prop, PropertyWriteable writeable, PropertyInternal internal) {\n+  const char* key = NULL;\n+  const char* value = NULL;\n+\n+  get_key_value(prop, &key, &value);\n@@ -2309,0 +2318,50 @@\n+bool Arguments::is_restoring(const JavaVMInitArgs* args) {\n+  const char* tail;\n+  \/\/ iterate over arguments\n+  for (int index = 0; index < args->nOptions; index++) {\n+    const JavaVMOption* option = args->options + index;\n+    if (match_option(option, \"-XX:CRaCRestoreFrom\", &tail)) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+bool Arguments::parse_options_for_restore(const JavaVMInitArgs* args) {\n+  const char *tail = NULL;\n+\n+  \/\/ iterate over arguments\n+  for (int index = 0; index < args->nOptions; index++) {\n+    bool is_absolute_path = false;  \/\/ for -agentpath vs -agentlib\n+\n+    const JavaVMOption* option = args->options + index;\n+\n+    if (!match_option(option, \"-Djava.class.path\", &tail) &&\n+        !match_option(option, \"-Dsun.java.launcher\", &tail)) {\n+      if (match_option(option, \"-D\", &tail)) {\n+        const char* key = NULL;\n+        const char* value = NULL;\n+\n+        get_key_value(tail, &key, &value);\n+\n+        if (strcmp(key, \"sun.java.command\") == 0) {\n+          char *old_java_command = _java_command;\n+          _java_command = os::strdup_check_oom(value, mtArguments);\n+          if (old_java_command != NULL) {\n+            os::free(old_java_command);\n+          }\n+        } else {\n+          add_property(tail);\n+        }\n+      } else if (match_option(option, \"-XX:\", &tail)) { \/\/ -XX:xxxx\n+        \/\/ Skip -XX:Flags= and -XX:VMOptionsFile= since those cases have\n+        \/\/ already been handled\n+        if (!process_argument(tail, args->ignoreUnrecognized, JVMFlagOrigin::COMMAND_LINE)) {\n+          return false;\n+        }\n+      }\n+    }\n+  }\n+  return true;\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":65,"deletions":6,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -280,0 +280,3 @@\n+  \/\/ Property list when restoring from checkpoint\n+  static SystemProperty* _system_properties_for_restore;\n+\n@@ -379,3 +382,3 @@\n-  \/\/ System properties\n-  static bool add_property(const char* prop, PropertyWriteable writeable=WriteableProperty,\n-                           PropertyInternal internal=ExternalProperty);\n+  \/\/ prop points to a string of the form key=value\n+  \/\/ Parse the string to extract key and the value\n+  static void get_key_value(const char* prop, const char** key, const char** value);\n@@ -471,0 +474,4 @@\n+  \/\/ restore feature\n+  static bool add_property_for_restore(const char* prop,\n+                                       PropertyWriteable writeable=WriteableProperty,\n+                                       PropertyInternal internal=ExternalProperty);\n@@ -524,0 +531,5 @@\n+  \/\/ System properties\n+  static bool add_property(const char* prop,\n+                           PropertyWriteable writeable=WriteableProperty,\n+                           PropertyInternal internal=ExternalProperty);\n+\n@@ -627,0 +639,3 @@\n+  \/\/ restore feature\n+  static SystemProperty* system_properties_for_restore() { return _system_properties_for_restore; }\n+\n@@ -644,0 +659,4 @@\n+  static bool is_restoring(const JavaVMInitArgs* args);\n+\n+  static bool parse_options_for_restore(const JavaVMInitArgs* args);\n+\n","filename":"src\/hotspot\/share\/runtime\/arguments.hpp","additions":22,"deletions":3,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2707,0 +2707,13 @@\n+jint Threads::check_for_restore(JavaVMInitArgs* args) {\n+  if (Arguments::is_restoring(args)) {\n+    Arguments::parse_options_for_restore(args);\n+    os::Linux::restore();\n+    if (!CRaCIgnoreRestoreIfUnavailable) {\n+      \/\/ FIXME switch to unified hotspot logging\n+      warning(\"cannot restore\");\n+      return JNI_ERR;\n+    }\n+  }\n+  return JNI_OK;\n+}\n+\n@@ -2710,0 +2723,2 @@\n+  if (check_for_restore(args) != JNI_OK) return JNI_ERR;\n+\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1641,0 +1641,2 @@\n+  static jint check_for_restore(JavaVMInitArgs* args);\n+\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import java.security.PrivilegedAction;\n@@ -127,2 +128,3 @@\n-        final int[] codes = (int[])bundle[2];\n-        final String[] messages = (String[])bundle[3];\n+        final String[] newProperties = (String[])bundle[2];\n+        final int[] codes = (int[])bundle[3];\n+        final String[] messages = (String[])bundle[4];\n@@ -165,0 +167,17 @@\n+        if (newProperties != null && newProperties.length > 0) {\n+            for (String str: newProperties) {\n+\t        System.out.println(\"property: \" + str);\n+\t    }\n+        } else {\n+            System.out.println(\"No new properties specified\");\n+\t}\n+\n+        if (newProperties != null && newProperties.length > 0) {\n+            Arrays.stream(newProperties).forEach(System.out::println);\n+            Arrays.stream(newProperties).map(propStr -> propStr.split(\"=\", 2)).forEach(pair -> {\n+\t\tAccessController.doPrivileged(\n+                    (PrivilegedAction<String>)() ->\n+                        System.setProperty(pair[0], pair.length == 2 ? pair[1] : \"\"));\n+            });\n+        }\n+\n@@ -166,0 +185,1 @@\n+            System.out.println(\"new arguments: \" + newArguments);\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/Core.java","additions":22,"deletions":2,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -246,7 +246,0 @@\n-        \/**\n-         * Return a Properties instance of the command line and VM options\n-         * defined by name and value.\n-         * The Properties instance is sized to include the fixed properties.\n-         *\n-         * @return return a Properties instance of the command line and VM options\n-         *\/\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/SystemProps.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"}]}