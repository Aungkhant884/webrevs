{"files":[{"patch":"@@ -381,11 +381,1 @@\n-      if (Arguments::add_or_modify_property(prop)) {\n-        properties->append(prop);\n-      } else {\n-        char *eq = strchr(prop, '=');\n-\tif (eq != NULL) {\n-          *eq = '\\0';\n-\t}\n-        tty->print_cr(\"Property %s is not modifiable, it will be ignored\", prop);\n-\t*eq = '=';\n-\tFREE_C_HEAP_ARRAY(char, prop);\n-      }\n+      properties->append(prop);\n@@ -6396,1 +6386,1 @@\n-  SystemProperty* props = Arguments::system_properties_for_restore();\n+  SystemProperty* props = Arguments::system_properties();\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":2,"deletions":12,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -196,1 +196,1 @@\n-SystemProperty::SystemProperty(const char* key, const char* value, bool writeable, bool internal, bool modifiable_on_restore) : PathString(value) {\n+SystemProperty::SystemProperty(const char* key, const char* value, bool writeable, bool internal) : PathString(value) {\n@@ -206,1 +206,0 @@\n-  _modifiable_on_restore = modifiable_on_restore;\n@@ -1334,37 +1333,1 @@\n-bool Arguments::add_property_for_restore(const char* prop, PropertyWriteable writeable, PropertyInternal internal) {\n-  const char* key = NULL;\n-  const char* value = NULL;\n-\n-  get_key_value(prop, &key, &value);\n-\n-  \/* Only interested in key and value pair, other property attributes don't matter.\n-   * These properties are only used for passing on to the JVM being restored.\n-   *\/\n-  PropertyList_unique_add(&_system_properties_for_restore, key, value, AddProperty, writeable, internal, ModifiableProperty);\n-\n-  if (key != prop) {\n-    \/\/ SystemProperty copy passed value, thus free previously allocated\n-    \/\/ memory\n-    FreeHeap((void *)key);\n-  }\n-\n-  return true;\n-}\n-\n-bool Arguments::add_or_modify_property(const char* prop) {\n-  const char* key = NULL;\n-  const char* value = NULL;\n-\n-  get_key_value(prop, &key, &value);\n-\n-  bool rc = PropertyList_modifiable_add(&_system_properties, key, value);\n-\n-  if (key != prop) {\n-    \/\/ SystemProperty copy passed value, thus free previously allocated\n-    \/\/ memory\n-    FreeHeap((void *)key);\n-  }\n-  return rc;\n-}\n-\n-bool Arguments::add_property(const char* prop, PropertyModifiableOnRestore modifiable_on_restore, PropertyWriteable writeable, PropertyInternal internal) {\n+bool Arguments::add_property(const char* prop, PropertyWriteable writeable, PropertyInternal internal) {\n@@ -1400,1 +1363,1 @@\n-                            WriteableProperty, ExternalProperty, UnmodifiableProperty);\n+                            WriteableProperty, ExternalProperty);\n@@ -1408,1 +1371,0 @@\n-      modifiable_on_restore = UnmodifiableProperty;\n@@ -1422,3 +1384,0 @@\n-      modifiable_on_restore = UnmodifiableProperty;\n-    } else if (strcmp(key, \"sun.java.launcher\") == 0) {\n-      modifiable_on_restore = UnmodifiableProperty;\n@@ -1428,1 +1387,1 @@\n-    PropertyList_unique_add(&_system_properties, key, value, AddProperty, writeable, internal, modifiable_on_restore);\n+    PropertyList_unique_add(&_system_properties, key, value, AddProperty, writeable, internal);\n@@ -1505,1 +1464,1 @@\n-                          VM_Version::vm_info_string(), AddProperty, UnwriteableProperty, ExternalProperty, UnmodifiableProperty);\n+                          VM_Version::vm_info_string(), AddProperty, UnwriteableProperty, ExternalProperty);\n@@ -1979,1 +1938,1 @@\n-    if (!add_property(buffer, UnmodifiableProperty)) {\n+    if (!add_property(buffer)) {\n@@ -2054,1 +2013,1 @@\n-        AddProperty, UnwriteableProperty, InternalProperty, UnmodifiableProperty);\n+        AddProperty, UnwriteableProperty, InternalProperty);\n@@ -2131,1 +2090,1 @@\n-  bool added = add_property(property, UnmodifiableProperty, WriteableProperty, internal);\n+  bool added = add_property(property, WriteableProperty, internal);\n@@ -2152,1 +2111,1 @@\n-    bool added = add_property(property, UnmodifiableProperty, UnwriteableProperty, InternalProperty);\n+    bool added = add_property(property, UnwriteableProperty, InternalProperty);\n@@ -2359,1 +2318,1 @@\n-bool Arguments::is_restore_option_set(const JavaVMInitArgs* args) {\n+bool Arguments::is_restoring(const JavaVMInitArgs* args) {\n@@ -2371,0 +2330,38 @@\n+bool Arguments::parse_options_for_restore(const JavaVMInitArgs* args) {\n+  const char *tail = NULL;\n+\n+  \/\/ iterate over arguments\n+  for (int index = 0; index < args->nOptions; index++) {\n+    bool is_absolute_path = false;  \/\/ for -agentpath vs -agentlib\n+\n+    const JavaVMOption* option = args->options + index;\n+\n+    if (!match_option(option, \"-Djava.class.path\", &tail) &&\n+        !match_option(option, \"-Dsun.java.launcher\", &tail)) {\n+      if (match_option(option, \"-D\", &tail)) {\n+        const char* key = NULL;\n+        const char* value = NULL;\n+\n+        get_key_value(tail, &key, &value);\n+\n+        if (strcmp(key, \"sun.java.command\") == 0) {\n+          char *old_java_command = _java_command;\n+          _java_command = os::strdup_check_oom(value, mtArguments);\n+          if (old_java_command != NULL) {\n+            os::free(old_java_command);\n+          }\n+        } else {\n+          add_property(tail);\n+        }\n+      } else if (match_option(option, \"-XX:\", &tail)) { \/\/ -XX:xxxx\n+        \/\/ Skip -XX:Flags= and -XX:VMOptionsFile= since those cases have\n+        \/\/ already been handled\n+        if (!process_argument(tail, args->ignoreUnrecognized, JVMFlagOrigin::COMMAND_LINE)) {\n+          return false;\n+        }\n+      }\n+    }\n+  }\n+  return true;\n+}\n+\n@@ -2374,1 +2371,0 @@\n-  bool is_restoring = false;\n@@ -2715,7 +2711,2 @@\n-      is_restoring = (is_restoring || is_restore_option_set(args));\n-      if (is_restoring) {\n-        add_property_for_restore(tail);\n-      } else {\n-        if (!add_property(tail)) {\n-          return JNI_ENOMEM;\n-        }\n+      if (!add_property(tail)) {\n+        return JNI_ENOMEM;\n@@ -3005,3 +2996,0 @@\n-        if (!strncmp(tail, \"CRaCRestoreFrom\", strlen(\"CRaCRestoreFrom\"))) {\n-          is_restoring = true;\n-        }\n@@ -4228,12 +4216,0 @@\n-\/\/ Return the number of modifiable properties.\n-int Arguments::PropertyList_modifiable_count(SystemProperty* pl) {\n-  int count = 0;\n-  while(pl != NULL) {\n-    if (pl->modifiable_on_restore()) {\n-      count++;\n-    }\n-    pl = pl->next();\n-  }\n-  return count;\n-}\n-\n@@ -4327,1 +4303,1 @@\n-                                 bool writeable, bool internal, bool modifiable_on_restore) {\n+                                 bool writeable, bool internal) {\n@@ -4331,1 +4307,1 @@\n-  SystemProperty* new_p = new SystemProperty(k, v, writeable, internal, modifiable_on_restore);\n+  SystemProperty* new_p = new SystemProperty(k, v, writeable, internal);\n@@ -4342,1 +4318,1 @@\n-                                        PropertyInternal internal, PropertyModifiableOnRestore modifiable_on_restore) {\n+                                        PropertyInternal internal) {\n@@ -4360,23 +4336,1 @@\n-  PropertyList_add(plist, k, v, writeable == WriteableProperty, internal == InternalProperty, modifiable_on_restore == ModifiableProperty);\n-}\n-\n-bool Arguments::PropertyList_modifiable_add(SystemProperty** plist, const char* k, const char* v) {\n-  if (plist == NULL)\n-    return false;\n-\n-  \/\/ If property key exists and is modifiable, then update with the new value.\n-  \/\/ If property key does not exist, add it to the list.\n-  \/\/ If property key exists and is not modifiable, it is silently ignored.\n-  SystemProperty* prop;\n-  for (prop = *plist; prop != NULL; prop = prop->next()) {\n-    if (strcmp(k, prop->key()) == 0) {\n-      if (prop->modifiable_on_restore()) {\n-        prop->set_value(v);\n-\treturn true;\n-      }\n-      return false;\n-    }\n-  }\n-\n-  PropertyList_add(plist, k, v, true, false, true);\n-  return true;\n+  PropertyList_add(plist, k, v, writeable == WriteableProperty, internal == InternalProperty);\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":54,"deletions":100,"binary":false,"changes":154,"status":"modified"},{"patch":"@@ -96,1 +96,0 @@\n-  bool            _modifiable_on_restore;\n@@ -104,1 +103,0 @@\n-  bool modifiable_on_restore()        { return _modifiable_on_restore; }\n@@ -132,1 +130,1 @@\n-  SystemProperty(const char* key, const char* value, bool writeable, bool internal = false, bool modifiable = false);\n+  SystemProperty(const char* key, const char* value, bool writeable, bool internal = false);\n@@ -266,5 +264,0 @@\n-  enum PropertyModifiableOnRestore {\n-    ModifiableProperty,\n-    UnmodifiableProperty\n-  };\n-\n@@ -485,2 +478,0 @@\n-  static bool is_restore_option_set(const JavaVMInitArgs* args);\n-\n@@ -542,1 +533,0 @@\n-                           PropertyModifiableOnRestore modifiable_on_restore=ModifiableProperty,\n@@ -546,2 +536,0 @@\n-  static bool add_or_modify_property(const char* prop);\n-\n@@ -594,1 +582,1 @@\n-  static void PropertyList_add(SystemProperty** plist, const char* k, const char* v, bool writeable, bool internal, bool modifiable_on_restore);\n+  static void PropertyList_add(SystemProperty** plist, const char* k, const char* v, bool writeable, bool internal);\n@@ -598,2 +586,1 @@\n-                                      PropertyInternal internal, PropertyModifiableOnRestore modifiable);\n-  static bool PropertyList_modifiable_add(SystemProperty** plist, const char* k, const char* v);\n+                                      PropertyInternal internal);\n@@ -603,1 +590,0 @@\n-  static int  PropertyList_modifiable_count(SystemProperty* pl);\n@@ -673,0 +659,4 @@\n+  static bool is_restoring(const JavaVMInitArgs* args);\n+\n+  static bool parse_options_for_restore(const JavaVMInitArgs* args);\n+\n","filename":"src\/hotspot\/share\/runtime\/arguments.hpp","additions":7,"deletions":17,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2707,0 +2707,13 @@\n+jint Threads::check_for_restore(JavaVMInitArgs* args) {\n+  if (Arguments::is_restoring(args)) {\n+    Arguments::parse_options_for_restore(args);\n+    os::Linux::restore();\n+    if (!CRaCIgnoreRestoreIfUnavailable) {\n+      \/\/ FIXME switch to unified hotspot logging\n+      warning(\"cannot restore\");\n+      return JNI_ERR;\n+    }\n+  }\n+  return JNI_OK;\n+}\n+\n@@ -2710,0 +2723,2 @@\n+  if (check_for_restore(args) != JNI_OK) return JNI_ERR;\n+\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1641,0 +1641,2 @@\n+  static jint check_for_restore(JavaVMInitArgs* args);\n+\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -167,0 +167,17 @@\n+        if (newProperties != null && newProperties.length > 0) {\n+            for (String str: newProperties) {\n+\t        System.out.println(\"property: \" + str);\n+\t    }\n+        } else {\n+            System.out.println(\"No new properties specified\");\n+\t}\n+\n+        if (newProperties != null && newProperties.length > 0) {\n+            Arrays.stream(newProperties).forEach(System.out::println);\n+            Arrays.stream(newProperties).map(propStr -> propStr.split(\"=\", 2)).forEach(pair -> {\n+\t\tAccessController.doPrivileged(\n+                    (PrivilegedAction<String>)() ->\n+                        System.setProperty(pair[0], pair.length == 2 ? pair[1] : \"\"));\n+            });\n+        }\n+\n@@ -168,0 +185,1 @@\n+            System.out.println(\"new arguments: \" + newArguments);\n@@ -197,8 +215,0 @@\n-        if (newProperties != null && newProperties.length > 0) {\n-            Arrays.stream(newProperties).map(propStr -> propStr.split(\"=\")).forEach(pair -> {\n-\t\tAccessController.doPrivileged(\n-                    (PrivilegedAction<String>)() ->\n-                        System.setProperty(pair[0], pair.length == 2 ? pair[1] : \"\"));\n-            });\n-        }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/Core.java","additions":18,"deletions":8,"binary":false,"changes":26,"status":"modified"}]}