{"files":[{"patch":"@@ -285,0 +285,118 @@\n+class VM_CracRestoreParameters : public CHeapObj<mtInternal> {\n+ private:\n+  int _nprops;\n+  GrowableArray<const char *>* _properties;\n+  const char* _args;\n+\n+  int write_check_error(int fd, const void *buf, int count) {\n+    int wret = write(fd, buf, count);\n+    if (wret != count) {\n+      if (wret < 0) {\n+        perror(\"shm error\");\n+      } else {\n+        fprintf(stderr, \"write shm truncated\");\n+      }\n+      return wret;\n+    }\n+    return 0;\n+  }\n+\n+ public:\n+  VM_CracRestoreParameters(const SystemProperty* props, const char *args) :\n+    _nprops(0),\n+    _properties(new (ResourceObj::C_HEAP, mtInternal) GrowableArray<const char *>(0, mtInternal)),\n+    _args(args)\n+  {\n+    const SystemProperty *p = props;\n+    while (p != NULL) {\n+      const char *eq = \"=\";\n+      int prop_len = strlen(p->key()) + strlen(p->value()) + strlen(eq) + 1; \/\/ +1 for null char\n+      char *prop = NEW_C_HEAP_ARRAY(char, prop_len, mtInternal);\n+      strcpy(prop, p->key());\n+      strcat(prop, eq);\n+      strcat(prop, p->value());\n+      _properties->append(prop);\n+      p = p->next();\n+      _nprops += 1;\n+    }\n+  }\n+\n+  VM_CracRestoreParameters(int nprops, GrowableArray<const char *>* properties, char *args) :\n+    _nprops(nprops),\n+    _properties(properties),\n+    _args(args)\n+  {}\n+\n+  const char *args() const { return _args; }\n+  GrowableArray<const char *>* properties() const { return _properties; }\n+\n+  ~VM_CracRestoreParameters() {\n+    for (int i = 0; i < _properties->length(); i++) {\n+      FREE_C_HEAP_ARRAY(char, _properties->at(i));\n+    }\n+    if (_args) {\n+      FREE_C_HEAP_ARRAY(char, _args);\n+    }\n+    delete _properties;\n+  }\n+\n+  int write_to(int fd) {\n+    int wret = write_check_error(fd, (void *)&_nprops, sizeof(_nprops));\n+\n+    for (int i = 0; i < _properties->length(); i++) {\n+      const char *prop = _properties->at(i);\n+      write_check_error(fd, prop, strlen(prop)+1);\n+    }\n+\n+    wret |= write_check_error(fd, _args, strlen(_args) + 1); \/\/ +1 for null char\n+    return wret;\n+  }\n+\n+  static VM_CracRestoreParameters* read_from(int fd) {\n+    struct stat st;\n+    if (fstat(fd, &st)) {\n+      perror(\"fstat (ignoring restore parameters)\");\n+      return NULL;\n+    }\n+\n+    char *contents = NEW_C_HEAP_ARRAY(char, st.st_size, mtInternal);\n+    if (read(fd, contents, st.st_size) < 0) {\n+      perror(\"read (ignoring restore parameters)\");\n+      FREE_C_HEAP_ARRAY(char, contents);\n+      return NULL;\n+    }\n+\n+    \/\/ parse the contents to read new system properties and arguments\n+    int nprops = *(int *)contents;\n+    GrowableArray<const char *>* properties = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<const char *>(nprops, mtInternal);\n+\n+    char *cursor = contents + sizeof(_nprops);\n+    for (int i = 0; i < nprops; i++) {\n+      assert((cursor + strlen(cursor) <= contents + st.st_size), \"property length exceeds shared memory size\");\n+\n+      int prop_len = strlen(cursor) + 1;\n+      char *prop = NEW_C_HEAP_ARRAY(char, prop_len, mtInternal);\n+      strncpy(prop, cursor, prop_len);\n+\n+      if (Arguments::add_or_modify_property(prop)) {\n+        properties->append(prop);\n+      } else {\n+        char *eq = strchr(prop, '=');\n+\tif (eq != NULL) {\n+          *eq = '\\0';\n+\t}\n+        tty->print_cr(\"Property %s is not modifiable, it will be ignored\", prop);\n+\t*eq = '=';\n+\tFREE_C_HEAP_ARRAY(char, prop);\n+      }\n+      cursor = cursor + prop_len;\n+    }\n+\n+    int argslen = strlen(cursor) + 1;\n+    char *args = NEW_C_HEAP_ARRAY(char, argslen, mtInternal);\n+    strncpy(args, cursor, argslen);\n+    FREE_C_HEAP_ARRAY(char, contents);\n+    return new VM_CracRestoreParameters(nprops, properties, args);\n+  }\n+};\n+\n@@ -289,1 +407,1 @@\n-  char* _new_args;\n+  VM_CracRestoreParameters *_restore_parameters;\n@@ -295,1 +413,1 @@\n-    _new_args(NULL)\n+    _restore_parameters(NULL)\n@@ -300,2 +418,2 @@\n-    if (_new_args) {\n-      FREE_C_HEAP_ARRAY(char, _new_args);\n+    if (_restore_parameters) {\n+      delete _restore_parameters;\n@@ -307,2 +425,2 @@\n-  char* new_args() { return _new_args; }\n-\n+  const char* new_args() { return _restore_parameters->args(); }\n+  GrowableArray<const char *>* new_properties() { return _restore_parameters->properties(); }\n@@ -312,0 +430,1 @@\n+  void read_shm(int shmid);\n@@ -5844,34 +5963,7 @@\n-static int set_new_args(int id, const char *args) {\n-    char shmpath[128];\n-    int shmpathlen = snprintf(shmpath, sizeof(shmpath), \"\/crac_%d\", id);\n-    if (shmpathlen < 0 || sizeof(shmpath) <= (size_t)shmpathlen) {\n-      fprintf(stderr, \"shmpath is too long: %d\\n\", shmpathlen);\n-      return -1;\n-    }\n-\n-    int shmfd = shm_open(shmpath, O_RDWR | O_CREAT, 0600);\n-    if (-1 == shmfd) {\n-        perror(\"shm_open\");\n-        return -1;\n-    }\n-\n-    int argslen = strlen(args);\n-    int wret = write(shmfd, args, argslen);\n-    if (argslen != wret) {\n-        if (wret < 0) {\n-            perror(\"write shm\");\n-        } else {\n-            fprintf(stderr, \"write shm truncated\");\n-        }\n-        close(shmfd);\n-        shm_unlink(shmpath);\n-        return -1;\n-    }\n-\n-    close(shmfd);\n-    return 0;\n-}\n-\n-static char* get_new_args(int id) {\n-    char shmpath[128];\n-    snprintf(shmpath, sizeof(shmpath), \"\/crac_%d\", id);\n+static int setup_shared_memory(int id, VM_CracRestoreParameters& parameters) {\n+  char shmpath[128];\n+  int shmpathlen = snprintf(shmpath, sizeof(shmpath), \"\/crac_%d\", id);\n+  if (shmpathlen < 0 || sizeof(shmpath) <= (size_t)shmpathlen) {\n+    fprintf(stderr, \"shmpath is too long: %d\\n\", shmpathlen);\n+    return -1;\n+  }\n@@ -5879,5 +5971,5 @@\n-    int shmfd = shm_open(shmpath, O_RDONLY, 0600);\n-    if (-1 == shmfd) {\n-      perror(\"shm_open (ignoring new args)\");\n-      return NULL;\n-    }\n+  int shmfd = shm_open(shmpath, O_RDWR | O_CREAT, 0600);\n+  if (-1 == shmfd) {\n+      perror(\"shm_open\");\n+      return -1;\n+  }\n@@ -5885,1 +5977,2 @@\n-    shm_unlink(shmpath);\n+  int rc = parameters.write_to(shmfd);\n+  close(shmfd);\n@@ -5887,14 +5980,4 @@\n-    struct stat st;\n-    if (fstat(shmfd, &st)) {\n-      perror(\"shm_open (ignoring new args)\");\n-      close(shmfd);\n-      return NULL;\n-    }\n-\n-    char *args = NEW_C_HEAP_ARRAY(char, st.st_size + 1, mtInternal);\n-    if (read(shmfd, args, st.st_size) < 0) {\n-      perror(\"read (ignoring new args)\");\n-      close(shmfd);\n-      FREE_C_HEAP_ARRAY(char, args);\n-      return NULL;\n-    }\n+  if (rc != 0) {\n+    fprintf(stderr, \"write to shared memory failed\");\n+    return -1;\n+  }\n@@ -5902,2 +5985,1 @@\n-    args[st.st_size] = '\\0';\n-    return args;\n+  return 0;\n@@ -5906,1 +5988,1 @@\n-static int checkpoint_restore(char** argp) {\n+static int checkpoint_restore(int *shmid) {\n@@ -5941,1 +6023,1 @@\n-    *argp = get_new_args(info.si_int);\n+    *shmid = info.si_int;\n@@ -6045,0 +6127,17 @@\n+void VM_Crac::read_shm(int shmid) {\n+    char shmpath[128];\n+    snprintf(shmpath, sizeof(shmpath), \"\/crac_%d\", shmid);\n+\n+    int shmfd = shm_open(shmpath, O_RDONLY, 0600);\n+    if (-1 == shmfd) {\n+      perror(\"shm_open (ignoring new args)\");\n+      return;\n+    }\n+\n+    shm_unlink(shmpath);\n+\n+    _restore_parameters = VM_CracRestoreParameters::read_from(shmfd);\n+\n+    close(shmfd);\n+    return;\n+}\n@@ -6137,1 +6236,3 @@\n-  int ret = checkpoint_restore(&_new_args);\n+\n+  int shmid = 0;\n+  int ret = checkpoint_restore(&shmid);\n@@ -6143,0 +6244,1 @@\n+  read_shm(shmid);\n@@ -6221,2 +6323,2 @@\n-static Handle ret_cr(int ret, Handle new_args, Handle err_codes, Handle err_msgs, TRAPS) {\n-  objArrayOop bundleObj = oopFactory::new_objectArray(4, CHECK_NH);\n+static Handle ret_cr(int ret, Handle new_args, Handle new_props, Handle err_codes, Handle err_msgs, TRAPS) {\n+  objArrayOop bundleObj = oopFactory::new_objectArray(5, CHECK_NH);\n@@ -6228,2 +6330,3 @@\n-  bundle->obj_at_put(2, err_codes());\n-  bundle->obj_at_put(3, err_msgs());\n+  bundle->obj_at_put(2, new_props());\n+  bundle->obj_at_put(3, err_codes());\n+  bundle->obj_at_put(4, err_msgs());\n@@ -6237,1 +6340,1 @@\n-    return ret_cr(JVM_CHECKPOINT_NONE, Handle(), Handle(), Handle(), THREAD);\n+    return ret_cr(JVM_CHECKPOINT_NONE, Handle(), Handle(), Handle(), Handle(), THREAD);\n@@ -6242,1 +6345,1 @@\n-    return ret_cr(JVM_CHECKPOINT_NONE, Handle(), Handle(), Handle(), THREAD);\n+    return ret_cr(JVM_CHECKPOINT_NONE, Handle(), Handle(), Handle(), Handle(), THREAD);\n@@ -6259,1 +6362,9 @@\n-    return ret_cr(JVM_CHECKPOINT_OK, Handle(THREAD, new_args), Handle(), Handle(), THREAD);\n+    GrowableArray<const char *>* new_properties = cr.new_properties();\n+    objArrayOop propsObj = oopFactory::new_objArray(vmClasses::String_klass(), new_properties->length(), CHECK_NH);\n+    objArrayHandle props(THREAD, propsObj);\n+\n+    for (int i = 0; i < new_properties->length(); i++) {\n+      oop propObj = java_lang_String::create_oop_from_str(new_properties->at(i), CHECK_NH);\n+      props->obj_at_put(i, propObj);\n+    }\n+    return ret_cr(JVM_CHECKPOINT_OK, Handle(THREAD, new_args), props, Handle(), Handle(), THREAD);\n@@ -6276,1 +6387,1 @@\n-  return ret_cr(JVM_CHECKPOINT_ERROR, Handle(), codes, msgs, THREAD);\n+  return ret_cr(JVM_CHECKPOINT_ERROR, Handle(), Handle(), codes, msgs, THREAD);\n@@ -6285,0 +6396,1 @@\n+  SystemProperty* props = Arguments::system_properties_for_restore();\n@@ -6286,1 +6398,2 @@\n-  if (set_new_args(id, args)) {\n+  VM_CracRestoreParameters restore_parameters(props, args);\n+  if (setup_shared_memory(id, restore_parameters)) {\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":187,"deletions":74,"binary":false,"changes":261,"status":"modified"},{"patch":"@@ -76,0 +76,1 @@\n+SystemProperty* Arguments::_system_properties_for_restore = NULL;\n@@ -195,1 +196,1 @@\n-SystemProperty::SystemProperty(const char* key, const char* value, bool writeable, bool internal) : PathString(value) {\n+SystemProperty::SystemProperty(const char* key, const char* value, bool writeable, bool internal, bool modifiable_on_restore) : PathString(value) {\n@@ -205,0 +206,1 @@\n+  _modifiable_on_restore = modifiable_on_restore;\n@@ -1310,1 +1312,3 @@\n-bool Arguments::add_property(const char* prop, PropertyWriteable writeable, PropertyInternal internal) {\n+void Arguments::get_key_value(const char* prop, const char** key, const char** value) {\n+  assert(key != NULL, \"key should not be NULL\");\n+  assert(value != NULL, \"value should not be NULL\");\n@@ -1312,2 +1316,0 @@\n-  const char* key;\n-  const char* value = \"\";\n@@ -1317,1 +1319,2 @@\n-    key = prop;\n+    *key = prop;\n+    *value = \"\";\n@@ -1325,1 +1328,1 @@\n-    key = tmp_key;\n+    *key = tmp_key;\n@@ -1327,1 +1330,1 @@\n-    value = &prop[key_len + 1];\n+    *value = &prop[key_len + 1];\n@@ -1329,0 +1332,43 @@\n+}\n+\n+bool Arguments::add_property_for_restore(const char* prop, PropertyWriteable writeable, PropertyInternal internal) {\n+  const char* key = NULL;\n+  const char* value = NULL;\n+\n+  get_key_value(prop, &key, &value);\n+\n+  \/* Only interested in key and value pair, other property attributes don't matter.\n+   * These properties are only used for passing on to the JVM being restored.\n+   *\/\n+  PropertyList_unique_add(&_system_properties_for_restore, key, value, AddProperty, writeable, internal, ModifiableProperty);\n+\n+  if (key != prop) {\n+    \/\/ SystemProperty copy passed value, thus free previously allocated\n+    \/\/ memory\n+    FreeHeap((void *)key);\n+  }\n+\n+  return true;\n+}\n+\n+bool Arguments::add_or_modify_property(const char* prop) {\n+  const char* key = NULL;\n+  const char* value = NULL;\n+\n+  get_key_value(prop, &key, &value);\n+\n+  bool rc = PropertyList_modifiable_add(&_system_properties, key, value);\n+\n+  if (key != prop) {\n+    \/\/ SystemProperty copy passed value, thus free previously allocated\n+    \/\/ memory\n+    FreeHeap((void *)key);\n+  }\n+  return rc;\n+}\n+\n+bool Arguments::add_property(const char* prop, PropertyModifiableOnRestore modifiable_on_restore, PropertyWriteable writeable, PropertyInternal internal) {\n+  const char* key = NULL;\n+  const char* value = NULL;\n+\n+  get_key_value(prop, &key, &value);\n@@ -1354,1 +1400,1 @@\n-                            WriteableProperty, ExternalProperty);\n+                            WriteableProperty, ExternalProperty, UnmodifiableProperty);\n@@ -1362,0 +1408,1 @@\n+      modifiable_on_restore = UnmodifiableProperty;\n@@ -1375,0 +1422,3 @@\n+      modifiable_on_restore = UnmodifiableProperty;\n+    } else if (strcmp(key, \"sun.java.launcher\") == 0) {\n+      modifiable_on_restore = UnmodifiableProperty;\n@@ -1378,1 +1428,1 @@\n-    PropertyList_unique_add(&_system_properties, key, value, AddProperty, writeable, internal);\n+    PropertyList_unique_add(&_system_properties, key, value, AddProperty, writeable, internal, modifiable_on_restore);\n@@ -1455,1 +1505,1 @@\n-                          VM_Version::vm_info_string(), AddProperty, UnwriteableProperty, ExternalProperty);\n+                          VM_Version::vm_info_string(), AddProperty, UnwriteableProperty, ExternalProperty, UnmodifiableProperty);\n@@ -1929,1 +1979,1 @@\n-    if (!add_property(buffer)) {\n+    if (!add_property(buffer, UnmodifiableProperty)) {\n@@ -2004,1 +2054,1 @@\n-        AddProperty, UnwriteableProperty, InternalProperty);\n+        AddProperty, UnwriteableProperty, InternalProperty, UnmodifiableProperty);\n@@ -2081,1 +2131,1 @@\n-  bool added = add_property(property, WriteableProperty, internal);\n+  bool added = add_property(property, UnmodifiableProperty, WriteableProperty, internal);\n@@ -2102,1 +2152,1 @@\n-    bool added = add_property(property, UnwriteableProperty, InternalProperty);\n+    bool added = add_property(property, UnmodifiableProperty, UnwriteableProperty, InternalProperty);\n@@ -2309,0 +2359,12 @@\n+bool Arguments::is_restore_option_set(const JavaVMInitArgs* args) {\n+  const char* tail;\n+  \/\/ iterate over arguments\n+  for (int index = 0; index < args->nOptions; index++) {\n+    const JavaVMOption* option = args->options + index;\n+    if (match_option(option, \"-XX:CRaCRestoreFrom\", &tail)) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n@@ -2312,0 +2374,1 @@\n+  bool is_restoring = false;\n@@ -2652,2 +2715,7 @@\n-      if (!add_property(tail)) {\n-        return JNI_ENOMEM;\n+      is_restoring = (is_restoring || is_restore_option_set(args));\n+      if (is_restoring) {\n+        add_property_for_restore(tail);\n+      } else {\n+        if (!add_property(tail)) {\n+          return JNI_ENOMEM;\n+        }\n@@ -2937,0 +3005,3 @@\n+        if (!strncmp(tail, \"CRaCRestoreFrom\", strlen(\"CRaCRestoreFrom\"))) {\n+          is_restoring = true;\n+        }\n@@ -4157,0 +4228,12 @@\n+\/\/ Return the number of modifiable properties.\n+int Arguments::PropertyList_modifiable_count(SystemProperty* pl) {\n+  int count = 0;\n+  while(pl != NULL) {\n+    if (pl->modifiable_on_restore()) {\n+      count++;\n+    }\n+    pl = pl->next();\n+  }\n+  return count;\n+}\n+\n@@ -4244,1 +4327,1 @@\n-                                 bool writeable, bool internal) {\n+                                 bool writeable, bool internal, bool modifiable_on_restore) {\n@@ -4248,1 +4331,1 @@\n-  SystemProperty* new_p = new SystemProperty(k, v, writeable, internal);\n+  SystemProperty* new_p = new SystemProperty(k, v, writeable, internal, modifiable_on_restore);\n@@ -4259,1 +4342,1 @@\n-                                        PropertyInternal internal) {\n+                                        PropertyInternal internal, PropertyModifiableOnRestore modifiable_on_restore) {\n@@ -4277,1 +4360,23 @@\n-  PropertyList_add(plist, k, v, writeable == WriteableProperty, internal == InternalProperty);\n+  PropertyList_add(plist, k, v, writeable == WriteableProperty, internal == InternalProperty, modifiable_on_restore == ModifiableProperty);\n+}\n+\n+bool Arguments::PropertyList_modifiable_add(SystemProperty** plist, const char* k, const char* v) {\n+  if (plist == NULL)\n+    return false;\n+\n+  \/\/ If property key exists and is modifiable, then update with the new value.\n+  \/\/ If property key does not exist, add it to the list.\n+  \/\/ If property key exists and is not modifiable, it is silently ignored.\n+  SystemProperty* prop;\n+  for (prop = *plist; prop != NULL; prop = prop->next()) {\n+    if (strcmp(k, prop->key()) == 0) {\n+      if (prop->modifiable_on_restore()) {\n+        prop->set_value(v);\n+\treturn true;\n+      }\n+      return false;\n+    }\n+  }\n+\n+  PropertyList_add(plist, k, v, true, false, true);\n+  return true;\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":125,"deletions":20,"binary":false,"changes":145,"status":"modified"},{"patch":"@@ -96,0 +96,1 @@\n+  bool            _modifiable_on_restore;\n@@ -103,0 +104,1 @@\n+  bool modifiable_on_restore()        { return _modifiable_on_restore; }\n@@ -130,1 +132,1 @@\n-  SystemProperty(const char* key, const char* value, bool writeable, bool internal = false);\n+  SystemProperty(const char* key, const char* value, bool writeable, bool internal = false, bool modifiable = false);\n@@ -264,0 +266,5 @@\n+  enum PropertyModifiableOnRestore {\n+    ModifiableProperty,\n+    UnmodifiableProperty\n+  };\n+\n@@ -280,0 +287,3 @@\n+  \/\/ Property list when restoring from checkpoint\n+  static SystemProperty* _system_properties_for_restore;\n+\n@@ -379,3 +389,3 @@\n-  \/\/ System properties\n-  static bool add_property(const char* prop, PropertyWriteable writeable=WriteableProperty,\n-                           PropertyInternal internal=ExternalProperty);\n+  \/\/ prop points to a string of the form key=value\n+  \/\/ Parse the string to extract key and the value\n+  static void get_key_value(const char* prop, const char** key, const char** value);\n@@ -471,0 +481,6 @@\n+  \/\/ restore feature\n+  static bool add_property_for_restore(const char* prop,\n+                                       PropertyWriteable writeable=WriteableProperty,\n+                                       PropertyInternal internal=ExternalProperty);\n+  static bool is_restore_option_set(const JavaVMInitArgs* args);\n+\n@@ -524,0 +540,8 @@\n+  \/\/ System properties\n+  static bool add_property(const char* prop,\n+                           PropertyModifiableOnRestore modifiable_on_restore=ModifiableProperty,\n+                           PropertyWriteable writeable=WriteableProperty,\n+                           PropertyInternal internal=ExternalProperty);\n+\n+  static bool add_or_modify_property(const char* prop);\n+\n@@ -570,1 +594,1 @@\n-  static void PropertyList_add(SystemProperty** plist, const char* k, const char* v, bool writeable, bool internal);\n+  static void PropertyList_add(SystemProperty** plist, const char* k, const char* v, bool writeable, bool internal, bool modifiable_on_restore);\n@@ -574,1 +598,2 @@\n-                                      PropertyInternal internal);\n+                                      PropertyInternal internal, PropertyModifiableOnRestore modifiable);\n+  static bool PropertyList_modifiable_add(SystemProperty** plist, const char* k, const char* v);\n@@ -578,0 +603,1 @@\n+  static int  PropertyList_modifiable_count(SystemProperty* pl);\n@@ -627,0 +653,3 @@\n+  \/\/ restore feature\n+  static SystemProperty* system_properties_for_restore() { return _system_properties_for_restore; }\n+\n","filename":"src\/hotspot\/share\/runtime\/arguments.hpp","additions":35,"deletions":6,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import java.security.PrivilegedAction;\n@@ -127,2 +128,3 @@\n-        final int[] codes = (int[])bundle[2];\n-        final String[] messages = (String[])bundle[3];\n+        final String[] newProperties = (String[])bundle[2];\n+        final int[] codes = (int[])bundle[3];\n+        final String[] messages = (String[])bundle[4];\n@@ -195,0 +197,8 @@\n+        if (newProperties != null && newProperties.length > 0) {\n+            Arrays.stream(newProperties).map(propStr -> propStr.split(\"=\")).forEach(pair -> {\n+\t\tAccessController.doPrivileged(\n+                    (PrivilegedAction<String>)() ->\n+                        System.setProperty(pair[0], pair.length == 2 ? pair[1] : \"\"));\n+            });\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/Core.java","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -246,7 +246,0 @@\n-        \/**\n-         * Return a Properties instance of the command line and VM options\n-         * defined by name and value.\n-         * The Properties instance is sized to include the fixed properties.\n-         *\n-         * @return return a Properties instance of the command line and VM options\n-         *\/\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/SystemProps.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"}]}