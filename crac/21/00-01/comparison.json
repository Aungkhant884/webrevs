{"files":[{"patch":"@@ -285,0 +285,118 @@\n+class VM_CracRestoreParameters : public CHeapObj<mtInternal> {\n+ private:\n+  int _nprops;\n+  GrowableArray<const char *>* _properties;\n+  const char* _args;\n+\n+  int write_check_error(int fd, const void *buf, int count) {\n+    int wret = write(fd, buf, count);\n+    if (wret != count) {\n+      if (wret < 0) {\n+        perror(\"shm error\");\n+      } else {\n+        fprintf(stderr, \"write shm truncated\");\n+      }\n+      return wret;\n+    }\n+    return 0;\n+  }\n+\n+ public:\n+  VM_CracRestoreParameters(const SystemProperty* props, const char *args) :\n+    _nprops(0),\n+    _properties(new (ResourceObj::C_HEAP, mtInternal) GrowableArray<const char *>(0, mtInternal)),\n+    _args(args)\n+  {\n+    const SystemProperty *p = props;\n+    while (p != NULL) {\n+      const char *eq = \"=\";\n+      int prop_len = strlen(p->key()) + strlen(p->value()) + strlen(eq) + 1; \/\/ +1 for null char\n+      char *prop = NEW_C_HEAP_ARRAY(char, prop_len, mtInternal);\n+      strcpy(prop, p->key());\n+      strcat(prop, eq);\n+      strcat(prop, p->value());\n+      _properties->append(prop);\n+      p = p->next();\n+      _nprops += 1;\n+    }\n+  }\n+\n+  VM_CracRestoreParameters(int nprops, GrowableArray<const char *>* properties, char *args) :\n+    _nprops(nprops),\n+    _properties(properties),\n+    _args(args)\n+  {}\n+\n+  const char *args() const { return _args; }\n+  GrowableArray<const char *>* properties() const { return _properties; }\n+\n+  ~VM_CracRestoreParameters() {\n+    for (int i = 0; i < _properties->length(); i++) {\n+      FREE_C_HEAP_ARRAY(char, _properties->at(i));\n+    }\n+    if (_args) {\n+      FREE_C_HEAP_ARRAY(char, _args);\n+    }\n+    delete _properties;\n+  }\n+\n+  int write_to(int fd) {\n+    int wret = write_check_error(fd, (void *)&_nprops, sizeof(_nprops));\n+\n+    for (int i = 0; i < _properties->length(); i++) {\n+      const char *prop = _properties->at(i);\n+      write_check_error(fd, prop, strlen(prop)+1);\n+    }\n+\n+    wret |= write_check_error(fd, _args, strlen(_args) + 1); \/\/ +1 for null char\n+    return wret;\n+  }\n+\n+  static VM_CracRestoreParameters* read_from(int fd) {\n+    struct stat st;\n+    if (fstat(fd, &st)) {\n+      perror(\"fstat (ignoring restore parameters)\");\n+      return NULL;\n+    }\n+\n+    char *contents = NEW_C_HEAP_ARRAY(char, st.st_size, mtInternal);\n+    if (read(fd, contents, st.st_size) < 0) {\n+      perror(\"read (ignoring restore parameters)\");\n+      FREE_C_HEAP_ARRAY(char, contents);\n+      return NULL;\n+    }\n+\n+    \/\/ parse the contents to read new system properties and arguments\n+    int nprops = *(int *)contents;\n+    GrowableArray<const char *>* properties = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<const char *>(nprops, mtInternal);\n+\n+    char *cursor = contents + sizeof(_nprops);\n+    for (int i = 0; i < nprops; i++) {\n+      assert((cursor + strlen(cursor) <= contents + st.st_size), \"property length exceeds shared memory size\");\n+\n+      int prop_len = strlen(cursor) + 1;\n+      char *prop = NEW_C_HEAP_ARRAY(char, prop_len, mtInternal);\n+      strncpy(prop, cursor, prop_len);\n+\n+      if (Arguments::add_or_modify_property(prop)) {\n+        properties->append(prop);\n+      } else {\n+        char *eq = strchr(prop, '=');\n+\tif (eq != NULL) {\n+          *eq = '\\0';\n+\t}\n+        tty->print_cr(\"Property %s is not modifiable, it will be ignored\", prop);\n+\t*eq = '=';\n+\tFREE_C_HEAP_ARRAY(char, prop);\n+      }\n+      cursor = cursor + prop_len;\n+    }\n+\n+    int argslen = strlen(cursor) + 1;\n+    char *args = NEW_C_HEAP_ARRAY(char, argslen, mtInternal);\n+    strncpy(args, cursor, argslen);\n+    FREE_C_HEAP_ARRAY(char, contents);\n+    return new VM_CracRestoreParameters(nprops, properties, args);\n+  }\n+};\n+\n@@ -289,1 +407,1 @@\n-  char* _new_args;\n+  VM_CracRestoreParameters *_restore_parameters;\n@@ -295,1 +413,1 @@\n-    _new_args(NULL)\n+    _restore_parameters(NULL)\n@@ -300,2 +418,2 @@\n-    if (_new_args) {\n-      FREE_C_HEAP_ARRAY(char, _new_args);\n+    if (_restore_parameters) {\n+      delete _restore_parameters;\n@@ -307,2 +425,2 @@\n-  char* new_args() { return _new_args; }\n-\n+  const char* new_args() { return _restore_parameters->args(); }\n+  GrowableArray<const char *>* new_properties() { return _restore_parameters->properties(); }\n@@ -312,0 +430,1 @@\n+  void read_shm(int shmid);\n@@ -5844,1 +5963,1 @@\n-static int set_new_args(int id, const int props_count, const SystemProperty *props, const char *args) {\n+static int setup_shared_memory(int id, VM_CracRestoreParameters& parameters) {\n@@ -5858,13 +5977,2 @@\n-  write(shmfd, (void *)&props_count, sizeof(props_count));\n-  if (props != NULL) {\n-    const SystemProperty *p = props;\n-    while (p != NULL) {\n-      const char *key_value_seperator = \"=\";\n-      const char *key = p->key();\n-      const char *value = p->value();\n-      write(shmfd, key, strlen(key));\n-      write(shmfd, key_value_seperator, strlen(key_value_seperator));\n-      write(shmfd, value, strlen(value)+1); \/\/ +1 for the null character\n-      p = p->next();\n-    }\n-  }\n+  int rc = parameters.write_to(shmfd);\n+  close(shmfd);\n@@ -5872,10 +5980,2 @@\n-  int argslen = strlen(args) + 1; \/\/ +1 for the null character\n-  int wret = write(shmfd, args, argslen);\n-  if (argslen != wret) {\n-    if (wret < 0) {\n-      perror(\"write shm\");\n-    } else {\n-      fprintf(stderr, \"write shm truncated\");\n-    }\n-    close(shmfd);\n-    shm_unlink(shmpath);\n+  if (rc != 0) {\n+    fprintf(stderr, \"write to shared memory failed\");\n@@ -5885,2 +5985,0 @@\n-  close(shmfd);\n-\n@@ -5890,45 +5988,1 @@\n-static char* get_new_args(int id) {\n-    char shmpath[128];\n-    snprintf(shmpath, sizeof(shmpath), \"\/crac_%d\", id);\n-\n-    int shmfd = shm_open(shmpath, O_RDONLY, 0600);\n-    if (-1 == shmfd) {\n-      perror(\"shm_open (ignoring new args)\");\n-      return NULL;\n-    }\n-\n-    shm_unlink(shmpath);\n-\n-    struct stat st;\n-    if (fstat(shmfd, &st)) {\n-      perror(\"shm_open (ignoring new args)\");\n-      close(shmfd);\n-      return NULL;\n-    }\n-\n-    char *contents = NEW_C_HEAP_ARRAY(char, st.st_size, mtInternal);\n-    if (read(shmfd, contents, st.st_size) < 0) {\n-      perror(\"read (ignoring new args)\");\n-      close(shmfd);\n-      FREE_C_HEAP_ARRAY(char, contents);\n-      return NULL;\n-    }\n-\n-    \/\/ parse the contents to read new system properties and arguments\n-    int num_props = *(int *)contents;\n-\n-    char *props = contents + sizeof(num_props);\n-    while (num_props > 0) {\n-      assert((props + strlen(props) <= contents + st.st_size), \"property length exceeds shared memory size\");\n-      Arguments::add_or_modify_property(props);\n-      num_props -= 1;\n-      props = props + strlen(props) + 1;\n-    }\n-\n-    char *args = NEW_C_HEAP_ARRAY(char, strlen(props) + 1, mtInternal);\n-    memcpy(args, props, strlen(props) + 1);\n-    FREE_C_HEAP_ARRAY(char, contents);\n-    return args;\n-}\n-\n-static int checkpoint_restore(char** argp) {\n+static int checkpoint_restore(int *shmid) {\n@@ -5969,1 +6023,1 @@\n-    *argp = get_new_args(info.si_int);\n+    *shmid = info.si_int;\n@@ -6073,0 +6127,17 @@\n+void VM_Crac::read_shm(int shmid) {\n+    char shmpath[128];\n+    snprintf(shmpath, sizeof(shmpath), \"\/crac_%d\", shmid);\n+\n+    int shmfd = shm_open(shmpath, O_RDONLY, 0600);\n+    if (-1 == shmfd) {\n+      perror(\"shm_open (ignoring new args)\");\n+      return;\n+    }\n+\n+    shm_unlink(shmpath);\n+\n+    _restore_parameters = VM_CracRestoreParameters::read_from(shmfd);\n+\n+    close(shmfd);\n+    return;\n+}\n@@ -6165,1 +6236,3 @@\n-  int ret = checkpoint_restore(&_new_args);\n+\n+  int shmid = 0;\n+  int ret = checkpoint_restore(&shmid);\n@@ -6171,0 +6244,1 @@\n+  read_shm(shmid);\n@@ -6249,2 +6323,2 @@\n-static Handle ret_cr(int ret, Handle new_args, Handle err_codes, Handle err_msgs, TRAPS) {\n-  objArrayOop bundleObj = oopFactory::new_objectArray(4, CHECK_NH);\n+static Handle ret_cr(int ret, Handle new_args, Handle new_props, Handle err_codes, Handle err_msgs, TRAPS) {\n+  objArrayOop bundleObj = oopFactory::new_objectArray(5, CHECK_NH);\n@@ -6256,2 +6330,3 @@\n-  bundle->obj_at_put(2, err_codes());\n-  bundle->obj_at_put(3, err_msgs());\n+  bundle->obj_at_put(2, new_props());\n+  bundle->obj_at_put(3, err_codes());\n+  bundle->obj_at_put(4, err_msgs());\n@@ -6265,1 +6340,1 @@\n-    return ret_cr(JVM_CHECKPOINT_NONE, Handle(), Handle(), Handle(), THREAD);\n+    return ret_cr(JVM_CHECKPOINT_NONE, Handle(), Handle(), Handle(), Handle(), THREAD);\n@@ -6270,1 +6345,1 @@\n-    return ret_cr(JVM_CHECKPOINT_NONE, Handle(), Handle(), Handle(), THREAD);\n+    return ret_cr(JVM_CHECKPOINT_NONE, Handle(), Handle(), Handle(), Handle(), THREAD);\n@@ -6287,1 +6362,9 @@\n-    return ret_cr(JVM_CHECKPOINT_OK, Handle(THREAD, new_args), Handle(), Handle(), THREAD);\n+    GrowableArray<const char *>* new_properties = cr.new_properties();\n+    objArrayOop propsObj = oopFactory::new_objArray(vmClasses::String_klass(), new_properties->length(), CHECK_NH);\n+    objArrayHandle props(THREAD, propsObj);\n+\n+    for (int i = 0; i < new_properties->length(); i++) {\n+      oop propObj = java_lang_String::create_oop_from_str(new_properties->at(i), CHECK_NH);\n+      props->obj_at_put(i, propObj);\n+    }\n+    return ret_cr(JVM_CHECKPOINT_OK, Handle(THREAD, new_args), props, Handle(), Handle(), THREAD);\n@@ -6304,1 +6387,1 @@\n-  return ret_cr(JVM_CHECKPOINT_ERROR, Handle(), codes, msgs, THREAD);\n+  return ret_cr(JVM_CHECKPOINT_ERROR, Handle(), Handle(), codes, msgs, THREAD);\n@@ -6314,1 +6397,0 @@\n-  int props_count = Arguments::PropertyList_count(props);\n@@ -6316,1 +6398,2 @@\n-  if (set_new_args(id, props_count, props, args)) {\n+  VM_CracRestoreParameters restore_parameters(props, args);\n+  if (setup_shared_memory(id, restore_parameters)) {\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":172,"deletions":89,"binary":false,"changes":261,"status":"modified"},{"patch":"@@ -1360,1 +1360,1 @@\n-  PropertyList_modifiable_add(&_system_properties, key, value);\n+  bool rc = PropertyList_modifiable_add(&_system_properties, key, value);\n@@ -1367,2 +1367,1 @@\n-\n-  return true;\n+  return rc;\n@@ -4364,1 +4363,1 @@\n-void Arguments::PropertyList_modifiable_add(SystemProperty** plist, const char* k, const char* v) {\n+bool Arguments::PropertyList_modifiable_add(SystemProperty** plist, const char* k, const char* v) {\n@@ -4366,1 +4365,1 @@\n-    return;\n+    return false;\n@@ -4376,0 +4375,1 @@\n+\treturn true;\n@@ -4377,1 +4377,1 @@\n-      return;\n+      return false;\n@@ -4382,0 +4382,1 @@\n+  return true;\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -599,1 +599,1 @@\n-  static void PropertyList_modifiable_add(SystemProperty** plist, const char* k, const char* v);\n+  static bool PropertyList_modifiable_add(SystemProperty** plist, const char* k, const char* v);\n","filename":"src\/hotspot\/share\/runtime\/arguments.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -69,3 +69,0 @@\n-import jdk.crac.Context;\n-import jdk.crac.Resource;\n-import jdk.internal.crac.JDKResource;\n@@ -119,4 +116,0 @@\n-    private static final String CHECKPOINT_ARG = \"-XX:CRaCCheckpointTo\";\n-\n-    private static boolean canCheckpoint = false;\n-\n@@ -2083,30 +2076,0 @@\n-    static class CRaCResource implements JDKResource {\n-        public void beforeCheckpoint(Context<? extends Resource> context) {\n-            \/* Nothing to do here *\/\n-        }\n-\n-        public void afterRestore(Context<? extends Resource> context) {\n-            Map<String, String> propMap = SystemProps.getPropertiesOnRestore();\n-            \/\/ Should VM::savedProps be updated as well?\n-            \/\/ It can be avoided as it is mainly used to get JVMCI or jdk specific properties\n-            \/\/ which are mostly likely \"unmodifiable\" on restore.\n-            \/\/ If this changes, then deal with updating VM::savedProps here.\n-\n-            \/\/ call createProperties to mask out system properties not for public access\n-            Properties tempProps = createProperties(propMap);\n-            if (props != null) {\n-                props.putAll(tempProps);\n-            } else {\n-                props = tempProps;\n-            }\n-        }\n-\n-        public Priority getPriority() {\n-            return Priority.JLSYSTEM;\n-        }\n-    }\n-\n-    private static void registerCRaCResource() {\n-        jdk.internal.crac.Core.getJDKContext().register(new CRaCResource());\n-    }\n-\n@@ -2171,11 +2134,0 @@\n-        \/\/ Check runtime args for the checkpoint argument\n-        String[] vmArgs = VM.getRuntimeArguments();\n-        if (vmArgs != null) {\n-            for (String arg : vmArgs) {\n-                if (arg != null && arg.contains(CHECKPOINT_ARG)) {\n-                    canCheckpoint = true;\n-                    break;\n-                }\n-            }\n-        }\n-\n@@ -2299,4 +2251,0 @@\n-        if (canCheckpoint) {\n-            registerCRaCResource();\n-        }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":0,"deletions":52,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import java.security.PrivilegedAction;\n@@ -127,2 +128,3 @@\n-        final int[] codes = (int[])bundle[2];\n-        final String[] messages = (String[])bundle[3];\n+        final String[] newProperties = (String[])bundle[2];\n+        final int[] codes = (int[])bundle[3];\n+        final String[] messages = (String[])bundle[4];\n@@ -195,0 +197,8 @@\n+        if (newProperties != null && newProperties.length > 0) {\n+            Arrays.stream(newProperties).map(propStr -> propStr.split(\"=\")).forEach(pair -> {\n+\t\tAccessController.doPrivileged(\n+                    (PrivilegedAction<String>)() ->\n+                        System.setProperty(pair[0], pair.length == 2 ? pair[1] : \"\"));\n+            });\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/Core.java","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -86,8 +86,0 @@\n-\n-        \/**\n-         * Priority of the\n-         * java.lang.System resources\n-         * Keep this at the last as the j.l.System resources should be the first\n-         * to be handled on restore.\n-         *\/\n-        JLSYSTEM,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/JDKResource.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -116,5 +116,0 @@\n-    public static Map<String, String> getPropertiesOnRestore() {\n-        return new Raw().cmdPropertiesOnRestore();\n-    }\n-\n-\n@@ -251,1 +246,2 @@\n-        private HashMap<String, String> convertToMap(String[] props) {\n+        private HashMap<String, String> cmdProperties() {\n+            String[] vmProps = vmProperties();\n@@ -255,3 +251,3 @@\n-            var cmdProps = new HashMap<String, String>((props.length \/ 2) + Raw.FIXED_LENGTH);\n-            for (int i = 0; i < props.length;) {\n-                String k = props[i++];\n+            var cmdProps = new HashMap<String, String>((vmProps.length \/ 2) + Raw.FIXED_LENGTH);\n+            for (int i = 0; i < vmProps.length;) {\n+                String k = vmProps[i++];\n@@ -259,1 +255,1 @@\n-                    String v = props[i++];\n+                    String v = vmProps[i++];\n@@ -269,27 +265,0 @@\n-        \/**\n-         * Return a Properties instance of the command line and VM options\n-         * defined by name and value.\n-         * The Properties instance is sized to include the fixed properties.\n-         *\n-         * @return return a Properties instance of the command line and VM options\n-         *\/\n-        private HashMap<String, String> cmdProperties() {\n-            String[] vmProps = vmProperties();\n-            return convertToMap(vmProps);\n-        }\n-\n-        \/**\n-         * Return a HashMap instance of the new command line and VM options\n-         * defined by name and value on restore.\n-         * If no new properties are available, returns an empty map.\n-         *\n-         * @return return a HashMap instance of the command line and VM options\n-         *\/\n-        private HashMap<String, String> cmdPropertiesOnRestore() {\n-            String[] vmProps = vmPropertiesOnRestore();\/\/vmPropertiesOnRestore();\n-            if (vmProps != null && vmProps.length > 0) {\n-                return convertToMap(vmProps);\n-            }\n-            return new HashMap<String, String>();\n-        }\n-\n@@ -307,2 +276,0 @@\n-        private static native String[] vmPropertiesOnRestore();\/\/ { return null; }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/SystemProps.java","additions":6,"deletions":39,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -229,19 +229,0 @@\n-\/*\n- * Gather the modifiable VM and command line properties and return as a String[].\n- * The array indices are alternating key\/value pairs\n- * supplied by the VM including those defined on the command line\n- * using -Dkey=value that may override the platform defined value.\n- *\n- * Note: The platform encoding must have been set.\n- *\n- * Class:     jdk_internal_util_SystemProps_Raw\n- * Method:    vmPropertiesOnRestore\n- * Signature: ()[Ljava\/lang\/String;\n- *\/\n-JNIEXPORT jobjectArray JNICALL\n-Java_jdk_internal_util_SystemProps_00024Raw_vmPropertiesOnRestore(JNIEnv *env, jclass cla)\n-{\n-    jobjectArray cmdProps = JVM_GetModifiableProperties(env);\n-    return cmdProps;\n-}\n-\n","filename":"src\/java.base\/share\/native\/libjava\/System.c","additions":0,"deletions":19,"binary":false,"changes":19,"status":"modified"}]}