{"files":[{"patch":"","filename":"make\/data\/hotspot-symbols\/symbols-shared","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"make\/hotspot\/symbols\/symbols-shared","status":"renamed"},{"patch":"@@ -0,0 +1,138 @@\n+#\n+# Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+include LauncherCommon.gmk\n+\n+# Hook to include the corresponding custom file, if present.\n+$(eval $(call IncludeCustomExtension, modules\/java.base\/Launcher.gmk))\n+\n+JAVA_VERSION_INFO_RESOURCE := $(TOPDIR)\/src\/java.base\/windows\/native\/launcher\/java.rc\n+\n+JAVA_RCFLAGS ?= -I$(TOPDIR)\/src\/java.base\/windows\/native\/launcher\/icons\n+\n+################################################################################\n+\n+$(eval $(call SetupBuildLauncher, java, \\\n+    CFLAGS := -DEXPAND_CLASSPATH_WILDCARDS -DENABLE_ARG_FILES, \\\n+    EXTRA_RCFLAGS := $(JAVA_RCFLAGS), \\\n+    VERSION_INFO_RESOURCE := $(JAVA_VERSION_INFO_RESOURCE), \\\n+    OPTIMIZATION := HIGH, \\\n+))\n+\n+ifeq ($(call isTargetOs, windows), true)\n+  $(eval $(call SetupBuildLauncher, javaw, \\\n+      CFLAGS := -DJAVAW -DEXPAND_CLASSPATH_WILDCARDS -DENABLE_ARG_FILES, \\\n+      EXTRA_RCFLAGS := $(JAVA_RCFLAGS), \\\n+      VERSION_INFO_RESOURCE := $(JAVA_VERSION_INFO_RESOURCE), \\\n+  ))\n+endif\n+\n+$(eval $(call SetupBuildLauncher, keytool, \\\n+    MAIN_CLASS := sun.security.tools.keytool.Main, \\\n+))\n+\n+################################################################################\n+\n+ifeq ($(call isTargetOs, linux), true)\n+  $(eval $(call SetupJdkExecutable, BUILD_JEXEC, \\\n+      NAME := jexec, \\\n+      SRC := $(TOPDIR)\/src\/$(MODULE)\/unix\/native\/launcher, \\\n+      INCLUDE_FILES := jexec.c, \\\n+      OPTIMIZATION := LOW, \\\n+      CFLAGS := $(CFLAGS_JDKEXE) \\\n+          -I$(TOPDIR)\/src\/$(MODULE)\/share\/native\/libjli, \\\n+      CFLAGS_linux := -fPIC, \\\n+      LDFLAGS := $(LDFLAGS_JDKEXE), \\\n+      OUTPUT_DIR := $(SUPPORT_OUTPUTDIR)\/modules_libs\/$(MODULE), \\\n+  ))\n+\n+  TARGETS += $(BUILD_JEXEC)\n+endif\n+\n+################################################################################\n+\n+ifeq ($(call isTargetOs, macosx aix linux), true)\n+  $(eval $(call SetupJdkExecutable, BUILD_JSPAWNHELPER, \\\n+      NAME := jspawnhelper, \\\n+      SRC := $(TOPDIR)\/src\/$(MODULE)\/unix\/native\/jspawnhelper, \\\n+      OPTIMIZATION := LOW, \\\n+      CFLAGS := $(CFLAGS_JDKEXE) -I$(TOPDIR)\/src\/$(MODULE)\/unix\/native\/libjava, \\\n+      EXTRA_OBJECT_FILES := $(SUPPORT_OUTPUTDIR)\/native\/$(MODULE)\/libjava\/childproc.o, \\\n+      LDFLAGS := $(LDFLAGS_JDKEXE), \\\n+      OUTPUT_DIR := $(SUPPORT_OUTPUTDIR)\/modules_libs\/$(MODULE), \\\n+  ))\n+\n+  TARGETS += $(BUILD_JSPAWNHELPER)\n+endif\n+\n+################################################################################\n+\n+ifeq ($(OPENJDK_TARGET_OS), linux)\n+  $(eval $(call SetupJdkExecutable, BUILD_RESTORE_SCRIPT, \\\n+      NAME := action-script, \\\n+      SRC := $(TOPDIR)\/src\/$(MODULE)\/unix\/native\/action-script, \\\n+      INCLUDE_FILES := action-script.c, \\\n+      OPTIMIZATION := HIGH, \\\n+      CFLAGS := $(CFLAGS_JDKEXE), \\\n+      LDFLAGS := $(LDFLAGS_JDKEXE), \\\n+      OUTPUT_DIR := $(SUPPORT_OUTPUTDIR)\/modules_libs\/$(MODULE), \\\n+  ))\n+  TARGETS += $(BUILD_RESTORE_SCRIPT)\n+\n+  $(eval $(call SetupJdkExecutable, BUILD_WAIT, \\\n+      NAME := wait, \\\n+      SRC := $(TOPDIR)\/src\/$(MODULE)\/unix\/native\/wait, \\\n+      INCLUDE_FILES := wait.c, \\\n+      OPTIMIZATION := LOW, \\\n+      CFLAGS := $(CFLAGS_JDKEXE), \\\n+      LDFLAGS := $(LDFLAGS_JDKEXE), \\\n+      OUTPUT_DIR := $(SUPPORT_OUTPUTDIR)\/modules_libs\/$(MODULE), \\\n+  ))\n+  TARGETS += $(BUILD_WAIT)\n+\n+  $(eval $(call SetupJdkExecutable, BUILD_CRIU_WRAPPER, \\\n+      NAME := criu, \\\n+      SRC := $(TOPDIR)\/src\/$(MODULE)\/unix\/native\/criu, \\\n+      INCLUDE_FILES := criu.c, \\\n+      OPTIMIZATION := LOW, \\\n+      CFLAGS := $(CFLAGS_JDKEXE), \\\n+      LDFLAGS := $(LDFLAGS_JDKEXE), \\\n+      OUTPUT_DIR := $(SUPPORT_OUTPUTDIR)\/modules_libs\/$(MODULE), \\\n+  ))\n+  TARGETS += $(BUILD_CRIU_WRAPPER)\n+\n+  $(eval $(call SetupJdkExecutable, BUILD_JAVA_TIME, \\\n+      NAME := javatime, \\\n+      SRC := $(TOPDIR)\/src\/$(MODULE)\/unix\/native\/javatime, \\\n+      INCLUDE_FILES := javatime.c, \\\n+      OPTIMIZATION := LOW, \\\n+      CFLAGS := $(CFLAGS_JDKEXE), \\\n+      LDFLAGS := $(LDFLAGS_JDKEXE), \\\n+      OUTPUT_DIR := $(SUPPORT_OUTPUTDIR)\/modules_libs\/$(MODULE), \\\n+  ))\n+  TARGETS += $(BUILD_JAVA_TIME)\n+endif\n+\n+################################################################################\n","filename":"make\/modules\/java.base\/Launcher.gmk","additions":138,"deletions":0,"binary":false,"changes":138,"status":"added"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2017, 2020, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Azul Systems, Inc. All rights reserved.\n@@ -28,2 +28,0 @@\n-#include \"classfile\/classLoader.hpp\"\n-#include \"classfile\/systemDictionary.hpp\"\n@@ -36,0 +34,1 @@\n+#include \"jvmtifiles\/jvmti.h\"\n@@ -39,1 +38,0 @@\n-#include \"memory\/filemap.hpp\"\n@@ -52,1 +50,1 @@\n-#include \"runtime\/extendedPC.hpp\"\n+#include \"runtime\/globals_extension.hpp\"\n@@ -70,0 +68,1 @@\n+#include \"signals_posix.hpp\"\n@@ -82,0 +81,1 @@\n+#include \"utilities\/powerOfTwo.hpp\"\n@@ -91,0 +91,1 @@\n+# include <sys\/wait.h>\n@@ -105,1 +106,0 @@\n-# include <sys\/wait.h>\n@@ -112,1 +112,0 @@\n-# include <gnu\/libc-version.h>\n@@ -120,0 +119,4 @@\n+# include <linux\/elf-em.h>\n+#ifdef __GLIBC__\n+# include <malloc.h>\n+#endif\n@@ -142,0 +145,11 @@\n+#ifdef MUSL_LIBC\n+\/\/ dlvsym is not a part of POSIX\n+\/\/ and musl libc doesn't implement it.\n+static void *dlvsym(void *handle,\n+                    const char *symbol,\n+                    const char *version) {\n+   \/\/ load the latest version of symbol\n+   return dlsym(handle, symbol);\n+}\n+#endif\n+\n@@ -277,1 +291,1 @@\n-    _failures(new (ResourceObj::C_HEAP, mtInternal) GrowableArray<CracFailDep>(0, true\/*C_heap*\/))\n+    _failures(new (ResourceObj::C_HEAP, mtInternal) GrowableArray<CracFailDep>(0, mtInternal))\n@@ -304,1 +318,1 @@\n-const char * os::Linux::_glibc_version = NULL;\n+const char * os::Linux::_libc_version = NULL;\n@@ -306,0 +320,6 @@\n+size_t os::Linux::_default_large_page_size = 0;\n+\n+#ifdef __GLIBC__\n+os::Linux::mallinfo_func_t os::Linux::_mallinfo = NULL;\n+os::Linux::mallinfo2_func_t os::Linux::_mallinfo2 = NULL;\n+#endif \/\/ __GLIBC__\n@@ -320,9 +340,1 @@\n-\/\/ For diagnostics to print a message once. see run_periodic_checks\n-static sigset_t check_signal_done;\n-static bool check_signals = true;\n-\n-\/\/ Signal number used to suspend\/resume a thread\n-\n-\/\/ do not use any signal number less than SIGSEGV, see 4355769\n-static int SR_signum = SIGUSR2;\n-sigset_t SR_sigset;\n+\/\/ utility functions\n@@ -334,4 +346,0 @@\n-\/\/ utility functions\n-\n-static int SR_initialize();\n-\n@@ -476,1 +484,1 @@\n-\/\/ i386: 224, ia64: 1105, amd64: 186, sparc 143\n+\/\/ i386: 224, ia64: 1105, amd64: 186, sparc: 143\n@@ -566,1 +574,1 @@\n-  #if defined(AMD64) || (defined(_LP64) && defined(SPARC)) || defined(PPC64) || defined(S390)\n+  #if defined(_LP64)\n@@ -665,93 +673,0 @@\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\/\/ signal support\n-\n-debug_only(static bool signal_sets_initialized = false);\n-static sigset_t unblocked_sigs, blocked_sigs, vm_sigs;\n-\n-void os::Linux::signal_sets_init() {\n-  \/\/ Should also have an assertion stating we are still single-threaded.\n-  assert(!signal_sets_initialized, \"Already initialized\");\n-  \/\/ Fill in signals that are necessarily unblocked for all threads in\n-  \/\/ the VM. Currently, we unblock the following signals:\n-  \/\/ SHUTDOWN{1,2,3}_SIGNAL: for shutdown hooks support (unless over-ridden\n-  \/\/                         by -Xrs (=ReduceSignalUsage));\n-  \/\/ BREAK_SIGNAL which is unblocked only by the VM thread and blocked by all\n-  \/\/ other threads. The \"ReduceSignalUsage\" boolean tells us not to alter\n-  \/\/ the dispositions or masks wrt these signals.\n-  \/\/ Programs embedding the VM that want to use the above signals for their\n-  \/\/ own purposes must, at this time, use the \"-Xrs\" option to prevent\n-  \/\/ interference with shutdown hooks and BREAK_SIGNAL thread dumping.\n-  \/\/ (See bug 4345157, and other related bugs).\n-  \/\/ In reality, though, unblocking these signals is really a nop, since\n-  \/\/ these signals are not blocked by default.\n-  sigemptyset(&unblocked_sigs);\n-  sigaddset(&unblocked_sigs, SIGILL);\n-  sigaddset(&unblocked_sigs, SIGSEGV);\n-  sigaddset(&unblocked_sigs, SIGBUS);\n-  sigaddset(&unblocked_sigs, SIGFPE);\n-#if defined(PPC64)\n-  sigaddset(&unblocked_sigs, SIGTRAP);\n-#endif\n-  sigaddset(&unblocked_sigs, SR_signum);\n-\n-  if (!ReduceSignalUsage) {\n-    if (!os::Posix::is_sig_ignored(SHUTDOWN1_SIGNAL)) {\n-      sigaddset(&unblocked_sigs, SHUTDOWN1_SIGNAL);\n-    }\n-    if (!os::Posix::is_sig_ignored(SHUTDOWN2_SIGNAL)) {\n-      sigaddset(&unblocked_sigs, SHUTDOWN2_SIGNAL);\n-    }\n-    if (!os::Posix::is_sig_ignored(SHUTDOWN3_SIGNAL)) {\n-      sigaddset(&unblocked_sigs, SHUTDOWN3_SIGNAL);\n-    }\n-  }\n-  \/\/ Fill in signals that are blocked by all but the VM thread.\n-  sigemptyset(&vm_sigs);\n-  if (!ReduceSignalUsage) {\n-    sigaddset(&vm_sigs, BREAK_SIGNAL);\n-  }\n-\n-  sigemptyset(&blocked_sigs);\n-  sigaddset(&blocked_sigs, RESTORE_SIGNAL);\n-\n-  debug_only(signal_sets_initialized = true);\n-\n-}\n-\n-\/\/ These are signals that are unblocked while a thread is running Java.\n-\/\/ (For some reason, they get blocked by default.)\n-sigset_t* os::Linux::unblocked_signals() {\n-  assert(signal_sets_initialized, \"Not initialized\");\n-  return &unblocked_sigs;\n-}\n-\n-\/\/ These are the signals that are blocked while a (non-VM) thread is\n-\/\/ running Java. Only the VM thread handles these signals.\n-sigset_t* os::Linux::vm_signals() {\n-  assert(signal_sets_initialized, \"Not initialized\");\n-  return &vm_sigs;\n-}\n-\n-void os::Linux::hotspot_sigmask(Thread* thread) {\n-\n-  \/\/Save caller's signal mask before setting VM signal mask\n-  sigset_t caller_sigmask;\n-  pthread_sigmask(SIG_BLOCK, NULL, &caller_sigmask);\n-\n-  OSThread* osthread = thread->osthread();\n-  osthread->set_caller_sigmask(caller_sigmask);\n-\n-  pthread_sigmask(SIG_UNBLOCK, os::Linux::unblocked_signals(), NULL);\n-  pthread_sigmask(SIG_BLOCK, &blocked_sigs, NULL);\n-\n-  if (!ReduceSignalUsage) {\n-    if (thread->is_VM_thread()) {\n-      \/\/ Only the VM thread handles BREAK_SIGNAL ...\n-      pthread_sigmask(SIG_UNBLOCK, vm_signals(), NULL);\n-    } else {\n-      \/\/ ... all other threads block BREAK_SIGNAL\n-      pthread_sigmask(SIG_BLOCK, vm_signals(), NULL);\n-    }\n-  }\n-}\n-\n@@ -768,0 +683,6 @@\n+#ifdef MUSL_LIBC\n+  \/\/ confstr() from musl libc returns EINVAL for\n+  \/\/ _CS_GNU_LIBC_VERSION and _CS_GNU_LIBPTHREAD_VERSION\n+  os::Linux::set_libc_version(\"musl - unknown\");\n+  os::Linux::set_libpthread_version(\"musl - unknown\");\n+#else\n@@ -772,1 +693,1 @@\n-  os::Linux::set_glibc_version(str);\n+  os::Linux::set_libc_version(str);\n@@ -779,0 +700,1 @@\n+#endif\n@@ -882,2 +804,1 @@\n-  assert(t->stack_base() != NULL, \"stack_base was not initialized\");\n-  if (addr <  t->stack_base() && addr >= t->stack_reserved_zone_base()) {\n+  if (t->is_in_usable_stack(addr)) {\n@@ -903,0 +824,1 @@\n+#ifndef __GLIBC__\n@@ -908,0 +830,2 @@\n+  \/\/ This code is not needed anymore in glibc because it has MULTI_PAGE_ALIASING\n+  \/\/ and we did not see any degradation in performance without `alloca()`.\n@@ -910,1 +834,5 @@\n-  alloca(((pid ^ counter++) & 7) * 128);\n+  int random = ((pid ^ counter++) & 7) * 128;\n+  void *stackmem = alloca(random != 0 ? random : 1); \/\/ ensure we allocate > 0\n+  \/\/ Ensure the alloca result is used in a way that prevents the compiler from eliding it.\n+  *(char *)stackmem = 1;\n+#endif\n@@ -919,3 +847,0 @@\n-  log_info(os, thread)(\"Thread is alive (tid: \" UINTX_FORMAT \", pthread id: \" UINTX_FORMAT \").\",\n-    os::current_thread_id(), (uintx) pthread_self());\n-\n@@ -929,1 +854,1 @@\n-  os::Linux::hotspot_sigmask(thread);\n+  PosixSignals::hotspot_sigmask(thread);\n@@ -948,0 +873,3 @@\n+  log_info(os, thread)(\"Thread is alive (tid: \" UINTX_FORMAT \", pthread id: \" UINTX_FORMAT \").\",\n+    os::current_thread_id(), (uintx) pthread_self());\n+\n@@ -1082,1 +1010,11 @@\n-  assert_status(status == 0, status, \"pthread_attr_setstacksize\");\n+  if (status != 0) {\n+    \/\/ pthread_attr_setstacksize() function can fail\n+    \/\/ if the stack size exceeds a system-imposed limit.\n+    assert_status(status == EINVAL, status, \"pthread_attr_setstacksize\");\n+    log_warning(os, thread)(\"The %sthread stack size specified is invalid: \" SIZE_FORMAT \"k\",\n+                            (thr_type == compiler_thread) ? \"compiler \" : ((thr_type == java_thread) ? \"\" : \"VM \"),\n+                            stack_size \/ K);\n+    thread->set_osthread(NULL);\n+    delete osthread;\n+    return false;\n+  }\n@@ -1128,7 +1066,0 @@\n-  \/\/ Aborted due to thread limit being reached\n-  if (state == ZOMBIE) {\n-    thread->set_osthread(NULL);\n-    delete osthread;\n-    return false;\n-  }\n-\n@@ -1191,2 +1122,2 @@\n-    JavaThread *jt = (JavaThread *)thread;\n-    address addr = jt->stack_reserved_zone_base();\n+    StackOverflow* overflow_state = thread->stack_overflow_state();\n+    address addr = overflow_state->stack_reserved_zone_base();\n@@ -1194,1 +1125,1 @@\n-    assert(jt->stack_available(addr) > 0, \"stack guard should not be enabled\");\n+    assert(overflow_state->stack_available(addr) > 0, \"stack guard should not be enabled\");\n@@ -1197,1 +1128,1 @@\n-    os::Linux::manually_expand_stack(jt, addr);\n+    os::Linux::manually_expand_stack(thread, addr);\n@@ -1203,1 +1134,1 @@\n-  os::Linux::hotspot_sigmask(thread);\n+  PosixSignals::hotspot_sigmask(thread);\n@@ -1232,1 +1163,1 @@\n-  assert(!sigismember(&current, SR_signum), \"SR signal should not be blocked!\");\n+  assert(!sigismember(&current, PosixSignals::SR_signum), \"SR signal should not be blocked!\");\n@@ -1506,6 +1437,0 @@\n-#ifndef SUPPORTS_CLOCK_MONOTONIC\n-#error \"Build platform doesn't support clock_gettime and related functionality\"\n-#endif\n-\n-\/\/ Used by VMSelfDestructTimer and the MemProfiler.\n-\n@@ -1538,15 +1463,0 @@\n-jlong os::javaTimeMillis() {\n-  timeval time;\n-  int status = gettimeofday(&time, NULL);\n-  assert(status != -1, \"linux error\");\n-  return jlong(time.tv_sec) * 1000  +  jlong(time.tv_usec \/ 1000);\n-}\n-\n-void os::javaTimeSystemUTC(jlong &seconds, jlong &nanos) {\n-  timeval time;\n-  int status = gettimeofday(&time, NULL);\n-  assert(status != -1, \"linux error\");\n-  seconds = jlong(time.tv_sec);\n-  nanos = jlong(time.tv_usec) * 1000;\n-}\n-\n@@ -1573,1 +1483,1 @@\n-      os::Posix::clock_getres(clockid, &tp) == 0 && tp.tv_sec == 0) {\n+      clock_getres(clockid, &tp) == 0 && tp.tv_sec == 0) {\n@@ -1579,35 +1489,0 @@\n-jlong os::javaTimeNanos() {\n-  if (os::supports_monotonic_clock()) {\n-    struct timespec tp;\n-    int status = os::Posix::clock_gettime(CLOCK_MONOTONIC, &tp);\n-    assert(status == 0, \"gettime error\");\n-    jlong result = jlong(tp.tv_sec) * (1000 * 1000 * 1000) + jlong(tp.tv_nsec);\n-    return result;\n-  } else {\n-    timeval time;\n-    int status = gettimeofday(&time, NULL);\n-    assert(status != -1, \"linux error\");\n-    jlong usecs = jlong(time.tv_sec) * (1000 * 1000) + jlong(time.tv_usec);\n-    return 1000 * usecs;\n-  }\n-}\n-\n-void os::javaTimeNanos_info(jvmtiTimerInfo *info_ptr) {\n-  if (os::supports_monotonic_clock()) {\n-    info_ptr->max_value = ALL_64_BITS;\n-\n-    \/\/ CLOCK_MONOTONIC - amount of time since some arbitrary point in the past\n-    info_ptr->may_skip_backward = false;      \/\/ not subject to resetting or drifting\n-    info_ptr->may_skip_forward = false;       \/\/ not subject to resetting or drifting\n-  } else {\n-    \/\/ gettimeofday - based on time in seconds since the Epoch thus does not wrap\n-    info_ptr->max_value = ALL_64_BITS;\n-\n-    \/\/ gettimeofday is a real time clock so it skips\n-    info_ptr->may_skip_backward = true;\n-    info_ptr->may_skip_forward = true;\n-  }\n-\n-  info_ptr->kind = JVMTI_TIMER_ELAPSED;                \/\/ elapsed not CPU time\n-}\n-\n@@ -1650,60 +1525,0 @@\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\/\/ runtime exit support\n-\n-\/\/ Note: os::shutdown() might be called very early during initialization, or\n-\/\/ called from signal handler. Before adding something to os::shutdown(), make\n-\/\/ sure it is async-safe and can handle partially initialized VM.\n-void os::shutdown() {\n-\n-  \/\/ allow PerfMemory to attempt cleanup of any persistent resources\n-  perfMemory_exit();\n-\n-  \/\/ needs to remove object in file system\n-  AttachListener::abort();\n-\n-  \/\/ flush buffered output, finish log files\n-  ostream_abort();\n-\n-  \/\/ Check for abort hook\n-  abort_hook_t abort_hook = Arguments::abort_hook();\n-  if (abort_hook != NULL) {\n-    abort_hook();\n-  }\n-\n-}\n-\n-\/\/ Note: os::abort() might be called very early during initialization, or\n-\/\/ called from signal handler. Before adding something to os::abort(), make\n-\/\/ sure it is async-safe and can handle partially initialized VM.\n-void os::abort(bool dump_core, void* siginfo, const void* context) {\n-  os::shutdown();\n-  if (dump_core) {\n-    if (DumpPrivateMappingsInCore) {\n-      ClassLoader::close_jrt_image();\n-    }\n-#ifndef PRODUCT\n-    fdStream out(defaultStream::output_fd());\n-    out.print_raw(\"Current thread is \");\n-    char buf[16];\n-    jio_snprintf(buf, sizeof(buf), UINTX_FORMAT, os::current_thread_id());\n-    out.print_raw_cr(buf);\n-    out.print_raw_cr(\"Dumping core ...\");\n-#endif\n-    ::abort(); \/\/ dump core\n-  }\n-\n-  ::exit(1);\n-}\n-\n-\/\/ Die immediately, no exit hook, no abort hook, no cleanup.\n-\/\/ Dump a core file, if possible, for debugging.\n-void os::die() {\n-  if (TestUnresponsiveErrorHandler && !CreateCoredumpOnCrash) {\n-    \/\/ For TimeoutInErrorHandlingTest.java, we just kill the VM\n-    \/\/ and don't take the time to generate a core file.\n-    os::signal_raise(SIGKILL);\n-  } else {\n-    ::abort();\n-  }\n-}\n-\n@@ -1923,1 +1738,0 @@\n-        assert(Thread::current()->is_Java_thread(), \"must be Java thread\");\n@@ -2010,3 +1824,0 @@\n-#ifndef EM_486\n-  #define EM_486          6               \/* Intel 80486 *\/\n-#endif\n@@ -2016,0 +1827,3 @@\n+#ifndef EM_RISCV\n+  #define EM_RISCV      243               \/* RISC-V *\/\n+#endif\n@@ -2042,0 +1856,1 @@\n+    {EM_RISCV,       EM_RISCV,   ELFCLASS64, ELFDATA2LSB, (char*)\"RISC-V\"},\n@@ -2076,0 +1891,2 @@\n+#elif  (defined RISCV)\n+  static  Elf32_Half running_arch_code=EM_RISCV;\n@@ -2078,1 +1895,1 @@\n-        AARCH64, ALPHA, ARM, AMD64, IA32, IA64, M68K, MIPS, MIPSEL, PARISC, __powerpc__, __powerpc64__, S390, SH, __sparc\n+        AARCH64, ALPHA, ARM, AMD64, IA32, IA64, M68K, MIPS, MIPSEL, PARISC, __powerpc__, __powerpc64__, RISCV, S390, SH, __sparc\n@@ -2177,3 +1994,4 @@\n-      if (!jt->stack_guard_zone_unused() &&     \/\/ Stack not yet fully initialized\n-          jt->stack_guards_enabled()) {         \/\/ No pending stack overflow exceptions\n-        if (!os::guard_memory((char *)jt->stack_end(), jt->stack_guard_zone_size())) {\n+      StackOverflow* overflow_state = jt->stack_overflow_state();\n+      if (!overflow_state->stack_guard_zone_unused() &&     \/\/ Stack not yet fully initialized\n+          overflow_state->stack_guards_enabled()) {         \/\/ No pending stack overflow exceptions\n+        if (!os::guard_memory((char *)jt->stack_end(), StackOverflow::stack_guard_zone_size())) {\n@@ -2220,0 +2038,7 @@\n+static void _print_ascii_file_h(const char* header, const char* filename, outputStream* st, bool same_line = true) {\n+  st->print(\"%s:%c\", header, same_line ? ' ' : '\\n');\n+  if (!_print_ascii_file(filename, st)) {\n+    st->print_cr(\"<Not Available>\");\n+  }\n+}\n+\n@@ -2229,1 +2054,1 @@\n-    st->print(\"Can not get library information for pid = %d\\n\", pid);\n+    st->print_cr(\"Can not get library information for pid = %d\", pid);\n@@ -2233,31 +2058,26 @@\n-int os::get_loaded_modules_info(os::LoadedModulesCallbackFunc callback, void *param) {\n-  FILE *procmapsFile = NULL;\n-\n-  \/\/ Open the procfs maps file for the current process\n-  if ((procmapsFile = fopen(\"\/proc\/self\/maps\", \"r\")) != NULL) {\n-    \/\/ Allocate PATH_MAX for file name plus a reasonable size for other fields.\n-    char line[PATH_MAX + 100];\n-\n-    \/\/ Read line by line from 'file'\n-    while (fgets(line, sizeof(line), procmapsFile) != NULL) {\n-      u8 base, top, offset, inode;\n-      char permissions[5];\n-      char device[6];\n-      char name[sizeof(line)];\n-\n-      \/\/ Parse fields from line\n-      int matches = sscanf(line, UINT64_FORMAT_X \"-\" UINT64_FORMAT_X \" %4s \" UINT64_FORMAT_X \" %5s \" INT64_FORMAT \" %s\",\n-             &base, &top, permissions, &offset, device, &inode, name);\n-      \/\/ the last entry 'name' is empty for some entries, so we might have 6 matches instead of 7 for some lines\n-      if (matches < 6) continue;\n-      if (matches == 6) name[0] = '\\0';\n-\n-      \/\/ Filter by device id '00:00' so that we only get file system mapped files.\n-      if (strcmp(device, \"00:00\") != 0) {\n-\n-        \/\/ Call callback with the fields of interest\n-        if(callback(name, (address)base, (address)top, param)) {\n-          \/\/ Oops abort, callback aborted\n-          fclose(procmapsFile);\n-          return 1;\n-        }\n+struct loaded_modules_info_param {\n+  os::LoadedModulesCallbackFunc callback;\n+  void *param;\n+};\n+\n+static int dl_iterate_callback(struct dl_phdr_info *info, size_t size, void *data) {\n+  if ((info->dlpi_name == NULL) || (*info->dlpi_name == '\\0')) {\n+    return 0;\n+  }\n+\n+  struct loaded_modules_info_param *callback_param = reinterpret_cast<struct loaded_modules_info_param *>(data);\n+  address base = NULL;\n+  address top = NULL;\n+  for (int idx = 0; idx < info->dlpi_phnum; idx++) {\n+    const ElfW(Phdr) *phdr = info->dlpi_phdr + idx;\n+    if (phdr->p_type == PT_LOAD) {\n+      address raw_phdr_base = reinterpret_cast<address>(info->dlpi_addr + phdr->p_vaddr);\n+\n+      address phdr_base = align_down(raw_phdr_base, phdr->p_align);\n+      if ((base == NULL) || (base > phdr_base)) {\n+        base = phdr_base;\n+      }\n+\n+      address phdr_top = align_up(raw_phdr_base + phdr->p_memsz, phdr->p_align);\n+      if ((top == NULL) || (top < phdr_top)) {\n+        top = phdr_top;\n@@ -2266,2 +2086,7 @@\n-    fclose(procmapsFile);\n-  return 0;\n+\n+  return callback_param->callback(info->dlpi_name, base, top, callback_param->param);\n+}\n+\n+int os::get_loaded_modules_info(os::LoadedModulesCallbackFunc callback, void *param) {\n+  struct loaded_modules_info_param callback_param = {callback, param};\n+  return dl_iterate_phdr(&dl_iterate_callback, &callback_param);\n@@ -2281,1 +2106,1 @@\n-  st->print(\"OS:\");\n+  st->print_cr(\"OS:\");\n@@ -2291,2 +2116,1 @@\n-    st->print(\"WARNING!! \");\n-    st->print_cr(\"%s\", unstable_chroot_error);\n+    st->print_cr(\"WARNING!! %s\", unstable_chroot_error);\n@@ -2300,0 +2124,1 @@\n+  st->cr();\n@@ -2301,1 +2126,5 @@\n-  os::Linux::print_full_memory_info(st);\n+  os::Linux::print_system_memory_info(st);\n+  st->cr();\n+\n+  os::Linux::print_process_memory_info(st);\n+  st->cr();\n@@ -2304,0 +2133,1 @@\n+  st->cr();\n@@ -2305,1 +2135,3 @@\n-  os::Linux::print_ld_preload_file(st);\n+  if (os::Linux::print_ld_preload_file(st)) {\n+    st->cr();\n+  }\n@@ -2307,1 +2139,3 @@\n-  os::Linux::print_container_info(st);\n+  if (os::Linux::print_container_info(st)) {\n+    st->cr();\n+  }\n@@ -2368,1 +2202,1 @@\n-    st->print(\"Linux\");\n+    st->print_cr(\"Linux\");\n@@ -2370,1 +2204,0 @@\n-  st->cr();\n@@ -2439,2 +2272,2 @@\n-  st->print(\"libc:\");\n-  st->print(\"%s \", os::Linux::glibc_version());\n+  st->print(\"libc: \");\n+  st->print(\"%s \", os::Linux::libc_version());\n@@ -2446,5 +2279,7 @@\n-  st->cr();\n-  st->print_cr(\"\/proc\/sys\/kernel\/threads-max (system-wide limit on the number of threads):\");\n-  _print_ascii_file(\"\/proc\/sys\/kernel\/threads-max\", st);\n-  st->cr();\n-  st->cr();\n+  _print_ascii_file_h(\"\/proc\/sys\/kernel\/threads-max (system-wide limit on the number of threads)\",\n+                      \"\/proc\/sys\/kernel\/threads-max\", st);\n+  _print_ascii_file_h(\"\/proc\/sys\/vm\/max_map_count (maximum number of memory map areas a process may have)\",\n+                      \"\/proc\/sys\/vm\/max_map_count\", st);\n+  _print_ascii_file_h(\"\/proc\/sys\/kernel\/pid_max (system-wide limit on number of process identifiers)\",\n+                      \"\/proc\/sys\/kernel\/pid_max\", st);\n+}\n@@ -2452,3 +2287,2 @@\n-  st->print_cr(\"\/proc\/sys\/vm\/max_map_count (maximum number of memory map areas a process may have):\");\n-  _print_ascii_file(\"\/proc\/sys\/vm\/max_map_count\", st);\n-  st->cr();\n+void os::Linux::print_system_memory_info(outputStream* st) {\n+  _print_ascii_file_h(\"\/proc\/meminfo\", \"\/proc\/meminfo\", st, false);\n@@ -2457,4 +2291,6 @@\n-  st->print_cr(\"\/proc\/sys\/kernel\/pid_max (system-wide limit on number of process identifiers):\");\n-  _print_ascii_file(\"\/proc\/sys\/kernel\/pid_max\", st);\n-  st->cr();\n-  st->cr();\n+  \/\/ some information regarding THPs; for details see\n+  \/\/ https:\/\/www.kernel.org\/doc\/Documentation\/vm\/transhuge.txt\n+  _print_ascii_file_h(\"\/sys\/kernel\/mm\/transparent_hugepage\/enabled\",\n+                      \"\/sys\/kernel\/mm\/transparent_hugepage\/enabled\", st);\n+  _print_ascii_file_h(\"\/sys\/kernel\/mm\/transparent_hugepage\/defrag (defrag\/compaction efforts parameter)\",\n+                      \"\/sys\/kernel\/mm\/transparent_hugepage\/defrag\", st);\n@@ -2463,4 +2299,67 @@\n-void os::Linux::print_full_memory_info(outputStream* st) {\n-  st->print(\"\\n\/proc\/meminfo:\\n\");\n-  _print_ascii_file(\"\/proc\/meminfo\", st);\n-  st->cr();\n+void os::Linux::print_process_memory_info(outputStream* st) {\n+\n+  st->print_cr(\"Process Memory:\");\n+\n+  \/\/ Print virtual and resident set size; peak values; swap; and for\n+  \/\/  rss its components if the kernel is recent enough.\n+  ssize_t vmsize = -1, vmpeak = -1, vmswap = -1,\n+      vmrss = -1, vmhwm = -1, rssanon = -1, rssfile = -1, rssshmem = -1;\n+  const int num_values = 8;\n+  int num_found = 0;\n+  FILE* f = ::fopen(\"\/proc\/self\/status\", \"r\");\n+  char buf[256];\n+  if (f != NULL) {\n+    while (::fgets(buf, sizeof(buf), f) != NULL && num_found < num_values) {\n+      if ( (vmsize == -1    && sscanf(buf, \"VmSize: \" SSIZE_FORMAT \" kB\", &vmsize) == 1) ||\n+           (vmpeak == -1    && sscanf(buf, \"VmPeak: \" SSIZE_FORMAT \" kB\", &vmpeak) == 1) ||\n+           (vmswap == -1    && sscanf(buf, \"VmSwap: \" SSIZE_FORMAT \" kB\", &vmswap) == 1) ||\n+           (vmhwm == -1     && sscanf(buf, \"VmHWM: \" SSIZE_FORMAT \" kB\", &vmhwm) == 1) ||\n+           (vmrss == -1     && sscanf(buf, \"VmRSS: \" SSIZE_FORMAT \" kB\", &vmrss) == 1) ||\n+           (rssanon == -1   && sscanf(buf, \"RssAnon: \" SSIZE_FORMAT \" kB\", &rssanon) == 1) ||\n+           (rssfile == -1   && sscanf(buf, \"RssFile: \" SSIZE_FORMAT \" kB\", &rssfile) == 1) ||\n+           (rssshmem == -1  && sscanf(buf, \"RssShmem: \" SSIZE_FORMAT \" kB\", &rssshmem) == 1)\n+           )\n+      {\n+        num_found ++;\n+      }\n+    }\n+    fclose(f);\n+\n+    st->print_cr(\"Virtual Size: \" SSIZE_FORMAT \"K (peak: \" SSIZE_FORMAT \"K)\", vmsize, vmpeak);\n+    st->print(\"Resident Set Size: \" SSIZE_FORMAT \"K (peak: \" SSIZE_FORMAT \"K)\", vmrss, vmhwm);\n+    if (rssanon != -1) { \/\/ requires kernel >= 4.5\n+      st->print(\" (anon: \" SSIZE_FORMAT \"K, file: \" SSIZE_FORMAT \"K, shmem: \" SSIZE_FORMAT \"K)\",\n+                  rssanon, rssfile, rssshmem);\n+    }\n+    st->cr();\n+    if (vmswap != -1) { \/\/ requires kernel >= 2.6.34\n+      st->print_cr(\"Swapped out: \" SSIZE_FORMAT \"K\", vmswap);\n+    }\n+  } else {\n+    st->print_cr(\"Could not open \/proc\/self\/status to get process memory related information\");\n+  }\n+\n+  \/\/ Print glibc outstanding allocations.\n+  \/\/ (note: there is no implementation of mallinfo for muslc)\n+#ifdef __GLIBC__\n+  size_t total_allocated = 0;\n+  bool might_have_wrapped = false;\n+  if (_mallinfo2 != NULL) {\n+    struct glibc_mallinfo2 mi = _mallinfo2();\n+    total_allocated = mi.uordblks;\n+  } else if (_mallinfo != NULL) {\n+    \/\/ mallinfo is an old API. Member names mean next to nothing and, beyond that, are int.\n+    \/\/ So values may have wrapped around. Still useful enough to see how much glibc thinks\n+    \/\/ we allocated.\n+    struct glibc_mallinfo mi = _mallinfo();\n+    total_allocated = (size_t)(unsigned)mi.uordblks;\n+    \/\/ Since mallinfo members are int, glibc values may have wrapped. Warn about this.\n+    might_have_wrapped = (vmrss * K) > UINT_MAX && (vmrss * K) > (total_allocated + UINT_MAX);\n+  }\n+  if (_mallinfo2 != NULL || _mallinfo != NULL) {\n+    st->print_cr(\"C-Heap outstanding allocations: \" SIZE_FORMAT \"K%s\",\n+                 total_allocated \/ K,\n+                 might_have_wrapped ? \" (may have wrapped)\" : \"\");\n+  }\n+#endif \/\/ __GLIBC__\n+\n@@ -2469,3 +2368,2 @@\n-void os::Linux::print_ld_preload_file(outputStream* st) {\n-  _print_ascii_file(\"\/etc\/ld.so.preload\", st, \"\\n\/etc\/ld.so.preload:\");\n-  st->cr();\n+bool os::Linux::print_ld_preload_file(outputStream* st) {\n+  return _print_ascii_file(\"\/etc\/ld.so.preload\", st, \"\/etc\/ld.so.preload:\");\n@@ -2482,2 +2380,1 @@\n-\n-void os::Linux::print_container_info(outputStream* st) {\n+bool os::Linux::print_container_info(outputStream* st) {\n@@ -2485,1 +2382,1 @@\n-    return;\n+    return false;\n@@ -2488,1 +2385,1 @@\n-  st->print(\"container (cgroup) information:\\n\");\n+  st->print_cr(\"container (cgroup) information:\");\n@@ -2491,1 +2388,1 @@\n-  st->print(\"container_type: %s\\n\", p_ct != NULL ? p_ct : \"not supported\");\n+  st->print_cr(\"container_type: %s\", p_ct != NULL ? p_ct : \"not supported\");\n@@ -2494,1 +2391,1 @@\n-  st->print(\"cpu_cpuset_cpus: %s\\n\", p != NULL ? p : \"not supported\");\n+  st->print_cr(\"cpu_cpuset_cpus: %s\", p != NULL ? p : \"not supported\");\n@@ -2498,1 +2395,1 @@\n-  st->print(\"cpu_memory_nodes: %s\\n\", p != NULL ? p : \"not supported\");\n+  st->print_cr(\"cpu_memory_nodes: %s\", p != NULL ? p : \"not supported\");\n@@ -2504,1 +2401,1 @@\n-    st->print(\"%d\\n\", i);\n+    st->print_cr(\"%d\", i);\n@@ -2506,1 +2403,1 @@\n-    st->print(\"not supported\\n\");\n+    st->print_cr(\"not supported\");\n@@ -2512,1 +2409,1 @@\n-    st->print(\"%d\\n\", i);\n+    st->print_cr(\"%d\", i);\n@@ -2514,1 +2411,1 @@\n-    st->print(\"%s\\n\", i == OSCONTAINER_ERROR ? \"not supported\" : \"no quota\");\n+    st->print_cr(\"%s\", i == OSCONTAINER_ERROR ? \"not supported\" : \"no quota\");\n@@ -2520,1 +2417,1 @@\n-    st->print(\"%d\\n\", i);\n+    st->print_cr(\"%d\", i);\n@@ -2522,1 +2419,1 @@\n-    st->print(\"%s\\n\", i == OSCONTAINER_ERROR ? \"not supported\" : \"no period\");\n+    st->print_cr(\"%s\", i == OSCONTAINER_ERROR ? \"not supported\" : \"no period\");\n@@ -2528,1 +2425,1 @@\n-    st->print(\"%d\\n\", i);\n+    st->print_cr(\"%d\", i);\n@@ -2530,1 +2427,1 @@\n-    st->print(\"%s\\n\", i == OSCONTAINER_ERROR ? \"not supported\" : \"no shares\");\n+    st->print_cr(\"%s\", i == OSCONTAINER_ERROR ? \"not supported\" : \"no shares\");\n@@ -2536,1 +2433,1 @@\n-    st->print(JLONG_FORMAT \"\\n\", j);\n+    st->print_cr(JLONG_FORMAT, j);\n@@ -2538,1 +2435,1 @@\n-    st->print(\"%s\\n\", j == OSCONTAINER_ERROR ? \"not supported\" : \"unlimited\");\n+    st->print_cr(\"%s\", j == OSCONTAINER_ERROR ? \"not supported\" : \"unlimited\");\n@@ -2544,1 +2441,1 @@\n-    st->print(JLONG_FORMAT \"\\n\", j);\n+    st->print_cr(JLONG_FORMAT, j);\n@@ -2546,1 +2443,1 @@\n-    st->print(\"%s\\n\", j == OSCONTAINER_ERROR ? \"not supported\" : \"unlimited\");\n+    st->print_cr(\"%s\", j == OSCONTAINER_ERROR ? \"not supported\" : \"unlimited\");\n@@ -2552,1 +2449,1 @@\n-    st->print(JLONG_FORMAT \"\\n\", j);\n+    st->print_cr(JLONG_FORMAT, j);\n@@ -2554,1 +2451,1 @@\n-    st->print(\"%s\\n\", j == OSCONTAINER_ERROR ? \"not supported\" : \"unlimited\");\n+    st->print_cr(\"%s\", j == OSCONTAINER_ERROR ? \"not supported\" : \"unlimited\");\n@@ -2560,1 +2457,1 @@\n-    st->print(JLONG_FORMAT \"\\n\", j);\n+    st->print_cr(JLONG_FORMAT, j);\n@@ -2562,1 +2459,1 @@\n-    st->print(\"%s\\n\", j == OSCONTAINER_ERROR ? \"not supported\" : \"unlimited\");\n+    st->print_cr(\"%s\", j == OSCONTAINER_ERROR ? \"not supported\" : \"unlimited\");\n@@ -2568,1 +2465,1 @@\n-    st->print(JLONG_FORMAT \"\\n\", j);\n+    st->print_cr(JLONG_FORMAT, j);\n@@ -2570,1 +2467,1 @@\n-    st->print(\"%s\\n\", j == OSCONTAINER_ERROR ? \"not supported\" : \"unlimited\");\n+    st->print_cr(\"%s\", j == OSCONTAINER_ERROR ? \"not supported\" : \"unlimited\");\n@@ -2572,1 +2469,2 @@\n-  st->cr();\n+\n+  return true;\n@@ -2611,0 +2509,3 @@\n+  st->print(\"Page Sizes: \");\n+  _page_sizes.print_on(st);\n+  st->cr();\n@@ -2622,0 +2523,1 @@\n+    bool model_name_printed = false;\n@@ -2625,1 +2527,0 @@\n-        bool model_name_printed = false;\n@@ -2651,0 +2552,48 @@\n+\/\/ additional information about CPU e.g. available frequency ranges\n+static void print_sys_devices_cpu_info(outputStream* st, char* buf, size_t buflen) {\n+  _print_ascii_file_h(\"Online cpus\", \"\/sys\/devices\/system\/cpu\/online\", st);\n+  _print_ascii_file_h(\"Offline cpus\", \"\/sys\/devices\/system\/cpu\/offline\", st);\n+\n+  if (ExtensiveErrorReports) {\n+    \/\/ cache related info (cpu 0, should be similar for other CPUs)\n+    for (unsigned int i=0; i < 10; i++) { \/\/ handle max. 10 cache entries\n+      char hbuf_level[60];\n+      char hbuf_type[60];\n+      char hbuf_size[60];\n+      char hbuf_coherency_line_size[80];\n+      snprintf(hbuf_level, 60, \"\/sys\/devices\/system\/cpu\/cpu0\/cache\/index%u\/level\", i);\n+      snprintf(hbuf_type, 60, \"\/sys\/devices\/system\/cpu\/cpu0\/cache\/index%u\/type\", i);\n+      snprintf(hbuf_size, 60, \"\/sys\/devices\/system\/cpu\/cpu0\/cache\/index%u\/size\", i);\n+      snprintf(hbuf_coherency_line_size, 80, \"\/sys\/devices\/system\/cpu\/cpu0\/cache\/index%u\/coherency_line_size\", i);\n+      if (file_exists(hbuf_level)) {\n+        _print_ascii_file_h(\"cache level\", hbuf_level, st);\n+        _print_ascii_file_h(\"cache type\", hbuf_type, st);\n+        _print_ascii_file_h(\"cache size\", hbuf_size, st);\n+        _print_ascii_file_h(\"cache coherency line size\", hbuf_coherency_line_size, st);\n+      }\n+    }\n+  }\n+\n+  \/\/ we miss the cpufreq entries on Power and s390x\n+#if defined(IA32) || defined(AMD64)\n+  _print_ascii_file_h(\"BIOS frequency limitation\", \"\/sys\/devices\/system\/cpu\/cpu0\/cpufreq\/bios_limit\", st);\n+  _print_ascii_file_h(\"Frequency switch latency (ns)\", \"\/sys\/devices\/system\/cpu\/cpu0\/cpufreq\/cpuinfo_transition_latency\", st);\n+  _print_ascii_file_h(\"Available cpu frequencies\", \"\/sys\/devices\/system\/cpu\/cpu0\/cpufreq\/scaling_available_frequencies\", st);\n+  \/\/ min and max should be in the Available range but still print them (not all info might be available for all kernels)\n+  if (ExtensiveErrorReports) {\n+    _print_ascii_file_h(\"Maximum cpu frequency\", \"\/sys\/devices\/system\/cpu\/cpu0\/cpufreq\/cpuinfo_max_freq\", st);\n+    _print_ascii_file_h(\"Minimum cpu frequency\", \"\/sys\/devices\/system\/cpu\/cpu0\/cpufreq\/cpuinfo_min_freq\", st);\n+    _print_ascii_file_h(\"Current cpu frequency\", \"\/sys\/devices\/system\/cpu\/cpu0\/cpufreq\/scaling_cur_freq\", st);\n+  }\n+  \/\/ governors are power schemes, see https:\/\/wiki.archlinux.org\/index.php\/CPU_frequency_scaling\n+  if (ExtensiveErrorReports) {\n+    _print_ascii_file_h(\"Available governors\", \"\/sys\/devices\/system\/cpu\/cpu0\/cpufreq\/scaling_available_governors\", st);\n+  }\n+  _print_ascii_file_h(\"Current governor\", \"\/sys\/devices\/system\/cpu\/cpu0\/cpufreq\/scaling_governor\", st);\n+  \/\/ Core performance boost, see https:\/\/www.kernel.org\/doc\/Documentation\/cpu-freq\/boost.txt\n+  \/\/ Raise operating frequency of some cores in a multi-core package if certain conditions apply, e.g.\n+  \/\/ whole chip is not fully utilized\n+  _print_ascii_file_h(\"Core performance\/turbo boost\", \"\/sys\/devices\/system\/cpu\/cpufreq\/boost\", st);\n+#endif\n+}\n+\n@@ -2654,4 +2603,1 @@\n-    st->print(\"\\n\/proc\/cpuinfo:\\n\");\n-    if (!_print_ascii_file(\"\/proc\/cpuinfo\", st)) {\n-      st->print_cr(\"  <Not Available>\");\n-    }\n+    _print_ascii_file_h(\"\/proc\/cpuinfo\", \"\/proc\/cpuinfo\", st, false);\n@@ -2659,0 +2605,2 @@\n+  st->cr();\n+  print_sys_devices_cpu_info(st, buf, buflen);\n@@ -2731,21 +2679,0 @@\n-static void print_signal_handler(outputStream* st, int sig,\n-                                 char* buf, size_t buflen);\n-\n-void os::print_signal_handlers(outputStream* st, char* buf, size_t buflen) {\n-  st->print_cr(\"Signal Handlers:\");\n-  print_signal_handler(st, SIGSEGV, buf, buflen);\n-  print_signal_handler(st, SIGBUS , buf, buflen);\n-  print_signal_handler(st, SIGFPE , buf, buflen);\n-  print_signal_handler(st, SIGPIPE, buf, buflen);\n-  print_signal_handler(st, SIGXFSZ, buf, buflen);\n-  print_signal_handler(st, SIGILL , buf, buflen);\n-  print_signal_handler(st, SR_signum, buf, buflen);\n-  print_signal_handler(st, SHUTDOWN1_SIGNAL, buf, buflen);\n-  print_signal_handler(st, SHUTDOWN2_SIGNAL , buf, buflen);\n-  print_signal_handler(st, SHUTDOWN3_SIGNAL , buf, buflen);\n-  print_signal_handler(st, BREAK_SIGNAL, buf, buflen);\n-#if defined(PPC64)\n-  print_signal_handler(st, SIGTRAP, buf, buflen);\n-#endif\n-}\n-\n@@ -2769,0 +2696,1 @@\n+  dli_fname[0] = '\\0';\n@@ -2851,111 +2779,0 @@\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\/\/ sun.misc.Signal support\n-\n-static void UserHandler(int sig, void *siginfo, void *context) {\n-  \/\/ Ctrl-C is pressed during error reporting, likely because the error\n-  \/\/ handler fails to abort. Let VM die immediately.\n-  if (sig == SIGINT && VMError::is_error_reported()) {\n-    os::die();\n-  }\n-\n-  os::signal_notify(sig);\n-}\n-\n-void* os::user_handler() {\n-  return CAST_FROM_FN_PTR(void*, UserHandler);\n-}\n-\n-extern \"C\" {\n-  typedef void (*sa_handler_t)(int);\n-  typedef void (*sa_sigaction_t)(int, siginfo_t *, void *);\n-}\n-\n-void* os::signal(int signal_number, void* handler) {\n-  struct sigaction sigAct, oldSigAct;\n-\n-  sigfillset(&(sigAct.sa_mask));\n-  sigAct.sa_flags   = SA_RESTART|SA_SIGINFO;\n-  sigAct.sa_handler = CAST_TO_FN_PTR(sa_handler_t, handler);\n-\n-  if (sigaction(signal_number, &sigAct, &oldSigAct)) {\n-    \/\/ -1 means registration failed\n-    return (void *)-1;\n-  }\n-\n-  return CAST_FROM_FN_PTR(void*, oldSigAct.sa_handler);\n-}\n-\n-void os::signal_raise(int signal_number) {\n-  ::raise(signal_number);\n-}\n-\n-\/\/ The following code is moved from os.cpp for making this\n-\/\/ code platform specific, which it is by its very nature.\n-\n-\/\/ Will be modified when max signal is changed to be dynamic\n-int os::sigexitnum_pd() {\n-  return NSIG;\n-}\n-\n-\/\/ a counter for each possible signal value\n-static volatile jint pending_signals[NSIG+1] = { 0 };\n-\n-\/\/ Linux(POSIX) specific hand shaking semaphore.\n-static Semaphore* sig_sem = NULL;\n-static PosixSemaphore sr_semaphore;\n-\n-static void jdk_misc_signal_init() {\n-  \/\/ Initialize signal structures\n-  ::memset((void*)pending_signals, 0, sizeof(pending_signals));\n-\n-  \/\/ Initialize signal semaphore\n-  sig_sem = new Semaphore();\n-}\n-\n-void os::signal_notify(int sig) {\n-  if (sig_sem != NULL) {\n-    Atomic::inc(&pending_signals[sig]);\n-    sig_sem->signal();\n-  } else {\n-    \/\/ Signal thread is not created with ReduceSignalUsage and jdk_misc_signal_init\n-    \/\/ initialization isn't called.\n-    assert(ReduceSignalUsage, \"signal semaphore should be created\");\n-  }\n-}\n-\n-static int check_pending_signals() {\n-  for (;;) {\n-    for (int i = 0; i < NSIG + 1; i++) {\n-      jint n = pending_signals[i];\n-      if (n > 0 && n == Atomic::cmpxchg(&pending_signals[i], n, n - 1)) {\n-        return i;\n-      }\n-    }\n-    JavaThread *thread = JavaThread::current();\n-    ThreadBlockInVM tbivm(thread);\n-\n-    bool threadIsSuspended;\n-    do {\n-      thread->set_suspend_equivalent();\n-      \/\/ cleared by handle_special_suspend_equivalent_condition() or java_suspend_self()\n-      sig_sem->wait();\n-\n-      \/\/ were we externally suspended while we were waiting?\n-      threadIsSuspended = thread->handle_special_suspend_equivalent_condition();\n-      if (threadIsSuspended) {\n-        \/\/ The semaphore has been incremented, but while we were waiting\n-        \/\/ another thread suspended us. We don't want to continue running\n-        \/\/ while suspended because that would surprise the thread that\n-        \/\/ suspended us.\n-        sig_sem->signal();\n-\n-        thread->java_suspend_self();\n-      }\n-    } while (threadIsSuspended);\n-  }\n-}\n-\n-int os::signal_wait() {\n-  return check_pending_signals();\n-}\n-\n@@ -3096,0 +2913,9 @@\n+\/\/ If mmap flags are set with MAP_HUGETLB and the system supports multiple\n+\/\/ huge page sizes, flag bits [26:31] can be used to encode the log2 of the\n+\/\/ desired huge page size. Otherwise, the system's default huge page size will be used.\n+\/\/ See mmap(2) man page for more info (since Linux 3.8).\n+\/\/ https:\/\/lwn.net\/Articles\/533499\/\n+#ifndef MAP_HUGE_SHIFT\n+  #define MAP_HUGE_SHIFT 26\n+#endif\n+\n@@ -3298,0 +3124,17 @@\n+\/\/ Check numa dependent syscalls\n+static bool numa_syscall_check() {\n+  \/\/ NUMA APIs depend on several syscalls. E.g., get_mempolicy is required for numa_get_membind and\n+  \/\/ numa_get_interleave_mask. But these dependent syscalls can be unsupported for various reasons.\n+  \/\/ Especially in dockers, get_mempolicy is not allowed with the default configuration. So it's necessary\n+  \/\/ to check whether the syscalls are available. Currently, only get_mempolicy is checked since checking\n+  \/\/ others like mbind would cause unexpected side effects.\n+#ifdef SYS_get_mempolicy\n+  int dummy = 0;\n+  if (syscall(SYS_get_mempolicy, &dummy, NULL, 0, (void*)&dummy, 3) == -1) {\n+    return false;\n+  }\n+#endif\n+\n+  return true;\n+}\n+\n@@ -3299,1 +3142,2 @@\n-  if (sched_getcpu() != -1) { \/\/ Requires sched_getcpu() support\n+  \/\/ Requires sched_getcpu() and numa dependent syscalls support\n+  if ((sched_getcpu() != -1) && numa_syscall_check()) {\n@@ -3304,0 +3148,2 @@\n+      set_numa_node_to_cpus_v2(CAST_TO_FN_PTR(numa_node_to_cpus_v2_func_t,\n+                                              libnuma_v2_dlsym(handle, \"numa_node_to_cpus\")));\n@@ -3328,0 +3174,2 @@\n+      set_numa_set_preferred(CAST_TO_FN_PTR(numa_set_preferred_func_t,\n+                                            libnuma_dlsym(handle, \"numa_set_preferred\")));\n@@ -3336,1 +3184,1 @@\n-        _nindex_to_node = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<int>(0, true);\n+        _nindex_to_node = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<int>(0, mtInternal);\n@@ -3339,1 +3187,1 @@\n-        _cpu_to_node = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<int>(0, true);\n+        _cpu_to_node = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<int>(0, mtInternal);\n@@ -3430,1 +3278,11 @@\n-              cpu_to_node()->at_put(j * BitsPerCLong + k, closest_node);\n+              int cpu_index = j * BitsPerCLong + k;\n+\n+#ifndef PRODUCT\n+              if (UseDebuggerErgo1 && cpu_index >= (int)cpu_num) {\n+                \/\/ Some debuggers limit the processor count without\n+                \/\/ intercepting the NUMA APIs. Just fake the values.\n+                cpu_index = 0;\n+              }\n+#endif\n+\n+              cpu_to_node()->at_put(cpu_index, closest_node);\n@@ -3440,0 +3298,20 @@\n+int os::Linux::numa_node_to_cpus(int node, unsigned long *buffer, int bufferlen) {\n+  \/\/ use the latest version of numa_node_to_cpus if available\n+  if (_numa_node_to_cpus_v2 != NULL) {\n+\n+    \/\/ libnuma bitmask struct\n+    struct bitmask {\n+      unsigned long size; \/* number of bits in the map *\/\n+      unsigned long *maskp;\n+    };\n+\n+    struct bitmask mask;\n+    mask.maskp = (unsigned long *)buffer;\n+    mask.size = bufferlen * 8;\n+    return _numa_node_to_cpus_v2(node, &mask);\n+  } else if (_numa_node_to_cpus != NULL) {\n+    return _numa_node_to_cpus(node, buffer, bufferlen);\n+  }\n+  return -1;\n+}\n+\n@@ -3451,0 +3329,1 @@\n+os::Linux::numa_node_to_cpus_v2_func_t os::Linux::_numa_node_to_cpus_v2;\n@@ -3463,0 +3342,1 @@\n+os::Linux::numa_set_preferred_func_t os::Linux::_numa_set_preferred;\n@@ -3470,1 +3350,1 @@\n-bool os::pd_uncommit_memory(char* addr, size_t size) {\n+bool os::pd_uncommit_memory(char* addr, size_t size, bool exec) {\n@@ -3658,3 +3538,0 @@\n-\/\/ If 'fixed' is true, anon_mmap() will attempt to reserve anonymous memory\n-\/\/ at 'requested_addr'. If there are existing memory mappings at the same\n-\/\/ location, however, they will be overwritten. If 'fixed' is false,\n@@ -3664,9 +3541,3 @@\n-static char* anon_mmap(char* requested_addr, size_t bytes, bool fixed) {\n-  char * addr;\n-  int flags;\n-\n-  flags = MAP_PRIVATE | MAP_NORESERVE | MAP_ANONYMOUS;\n-  if (fixed) {\n-    assert((uintptr_t)requested_addr % os::Linux::page_size() == 0, \"unaligned address\");\n-    flags |= MAP_FIXED;\n-  }\n+static char* anon_mmap(char* requested_addr, size_t bytes) {\n+  \/\/ MAP_FIXED is intentionally left out, to leave existing mappings intact.\n+  const int flags = MAP_PRIVATE | MAP_NORESERVE | MAP_ANONYMOUS;\n@@ -3677,2 +3548,1 @@\n-  addr = (char*)::mmap(requested_addr, bytes, PROT_NONE,\n-                       flags, -1, 0);\n+  char* addr = (char*)::mmap(requested_addr, bytes, PROT_NONE, flags, -1, 0);\n@@ -3691,2 +3561,1 @@\n-static char* anon_mmap_aligned(size_t bytes, size_t alignment, char* req_addr) {\n-\n+static char* anon_mmap_aligned(char* req_addr, size_t bytes, size_t alignment) {\n@@ -3698,6 +3567,2 @@\n-  char* start = (char*) ::mmap(req_addr, extra_size, PROT_NONE,\n-    MAP_PRIVATE|MAP_ANONYMOUS|MAP_NORESERVE,\n-    -1, 0);\n-  if (start == MAP_FAILED) {\n-    start = NULL;\n-  } else {\n+  char* start = anon_mmap(req_addr, extra_size);\n+  if (start != NULL) {\n@@ -3729,3 +3594,2 @@\n-char* os::pd_reserve_memory(size_t bytes, char* requested_addr,\n-                            size_t alignment_hint) {\n-  return anon_mmap(requested_addr, bytes, (requested_addr != NULL));\n+char* os::pd_reserve_memory(size_t bytes, bool exec) {\n+  return anon_mmap(NULL, bytes);\n@@ -3738,0 +3602,4 @@\n+#ifdef CAN_SHOW_REGISTERS_ON_ASSERT\n+extern char* g_assert_poison; \/\/ assertion poison page address\n+#endif\n+\n@@ -3750,0 +3618,5 @@\n+  \/\/ Don't log anything if we're executing in the poison page signal handling\n+  \/\/ context. It can lead to reentrant use of other parts of the VM code.\n+#ifdef CAN_SHOW_REGISTERS_ON_ASSERT\n+  if (addr != g_assert_poison)\n+#endif\n@@ -3799,0 +3672,7 @@\n+int os::Linux::hugetlbfs_page_size_flag(size_t page_size) {\n+  if (page_size != default_large_page_size()) {\n+    return (exact_log2(page_size) << MAP_HUGE_SHIFT);\n+  }\n+  return 0;\n+}\n+\n@@ -3800,4 +3680,3 @@\n-  bool result = false;\n-  void *p = mmap(NULL, page_size, PROT_READ|PROT_WRITE,\n-                 MAP_ANONYMOUS|MAP_PRIVATE|MAP_HUGETLB,\n-                 -1, 0);\n+  \/\/ Include the page size flag to ensure we sanity check the correct page size.\n+  int flags = MAP_ANONYMOUS | MAP_PRIVATE | MAP_HUGETLB | hugetlbfs_page_size_flag(page_size);\n+  void *p = mmap(NULL, page_size, PROT_READ|PROT_WRITE, flags, -1, 0);\n@@ -3806,14 +3685,20 @@\n-    \/\/ We don't know if this really is a huge page or not.\n-    FILE *fp = fopen(\"\/proc\/self\/maps\", \"r\");\n-    if (fp) {\n-      while (!feof(fp)) {\n-        char chars[257];\n-        long x = 0;\n-        if (fgets(chars, sizeof(chars), fp)) {\n-          if (sscanf(chars, \"%lx-%*x\", &x) == 1\n-              && x == (long)p) {\n-            if (strstr (chars, \"hugepage\")) {\n-              result = true;\n-              break;\n-            }\n-          }\n+    \/\/ Mapping succeeded, sanity check passed.\n+    munmap(p, page_size);\n+    return true;\n+  } else {\n+      log_info(pagesize)(\"Large page size (\" SIZE_FORMAT \"%s) failed sanity check, \"\n+                         \"checking if smaller large page sizes are usable\",\n+                         byte_size_in_exact_unit(page_size),\n+                         exact_unit_for_byte_size(page_size));\n+      for (size_t page_size_ = _page_sizes.next_smaller(page_size);\n+          page_size_ != (size_t)os::vm_page_size();\n+          page_size_ = _page_sizes.next_smaller(page_size_)) {\n+        flags = MAP_ANONYMOUS | MAP_PRIVATE | MAP_HUGETLB | hugetlbfs_page_size_flag(page_size_);\n+        p = mmap(NULL, page_size_, PROT_READ|PROT_WRITE, flags, -1, 0);\n+        if (p != MAP_FAILED) {\n+          \/\/ Mapping succeeded, sanity check passed.\n+          munmap(p, page_size_);\n+          log_info(pagesize)(\"Large page size (\" SIZE_FORMAT \"%s) passed sanity check\",\n+                             byte_size_in_exact_unit(page_size_),\n+                             exact_unit_for_byte_size(page_size_));\n+          return true;\n@@ -3822,3 +3707,0 @@\n-      fclose(fp);\n-    }\n-    munmap(p, page_size);\n@@ -3827,2 +3709,2 @@\n-  if (warn && !result) {\n-    warning(\"HugeTLBFS is not supported by the operating system.\");\n+  if (warn) {\n+    warning(\"HugeTLBFS is not configured or not supported by the operating system.\");\n@@ -3831,1 +3713,25 @@\n-  return result;\n+  return false;\n+}\n+\n+bool os::Linux::shm_hugetlbfs_sanity_check(bool warn, size_t page_size) {\n+  \/\/ Try to create a large shared memory segment.\n+  int shmid = shmget(IPC_PRIVATE, page_size, SHM_HUGETLB|IPC_CREAT|SHM_R|SHM_W);\n+  if (shmid == -1) {\n+    \/\/ Possible reasons for shmget failure:\n+    \/\/ 1. shmmax is too small for the request.\n+    \/\/    > check shmmax value: cat \/proc\/sys\/kernel\/shmmax\n+    \/\/    > increase shmmax value: echo \"new_value\" > \/proc\/sys\/kernel\/shmmax\n+    \/\/ 2. not enough large page memory.\n+    \/\/    > check available large pages: cat \/proc\/meminfo\n+    \/\/    > increase amount of large pages:\n+    \/\/          sysctl -w vm.nr_hugepages=new_value\n+    \/\/    > For more information regarding large pages please refer to:\n+    \/\/      https:\/\/www.kernel.org\/doc\/Documentation\/vm\/hugetlbpage.txt\n+    if (warn) {\n+      warning(\"Large pages using UseSHM are not configured on this system.\");\n+    }\n+    return false;\n+  }\n+  \/\/ Managed to create a segment, now delete it.\n+  shmctl(shmid, IPC_RMID, NULL);\n+  return true;\n@@ -3875,2 +3781,2 @@\n-size_t os::Linux::find_large_page_size() {\n-  size_t large_page_size = 0;\n+static size_t scan_default_large_page_size() {\n+  size_t default_large_page_size = 0;\n@@ -3881,1 +3787,1 @@\n-  \/\/ page as large as 256M.\n+  \/\/ page as large as 1G.\n@@ -3888,14 +3794,1 @@\n-  \/\/ format has been changed), we'll use the largest page size supported by\n-  \/\/ the processor.\n-\n-#ifndef ZERO\n-  large_page_size =\n-    AARCH64_ONLY(2 * M)\n-    AMD64_ONLY(2 * M)\n-    ARM32_ONLY(2 * M)\n-    IA32_ONLY(4 * M)\n-    IA64_ONLY(256 * M)\n-    PPC_ONLY(4 * M)\n-    S390_ONLY(1 * M)\n-    SPARC_ONLY(4 * M);\n-#endif \/\/ ZERO\n+  \/\/ format has been changed), we'll set largest page size to 0\n@@ -3910,1 +3803,1 @@\n-          large_page_size = x * K;\n+          default_large_page_size = x * K;\n@@ -3924,4 +3817,28 @@\n-  if (!FLAG_IS_DEFAULT(LargePageSizeInBytes) && LargePageSizeInBytes != large_page_size) {\n-    warning(\"Setting LargePageSizeInBytes has no effect on this OS. Large page size is \"\n-            SIZE_FORMAT \"%s.\", byte_size_in_proper_unit(large_page_size),\n-            proper_unit_for_byte_size(large_page_size));\n+  return default_large_page_size;\n+}\n+\n+static os::PageSizes scan_multiple_page_support() {\n+  \/\/ Scan \/sys\/kernel\/mm\/hugepages\n+  \/\/ to discover the available page sizes\n+  const char* sys_hugepages = \"\/sys\/kernel\/mm\/hugepages\";\n+  os::PageSizes page_sizes;\n+\n+  DIR *dir = opendir(sys_hugepages);\n+\n+  struct dirent *entry;\n+  size_t page_size;\n+  while ((entry = readdir(dir)) != NULL) {\n+    if (entry->d_type == DT_DIR &&\n+        sscanf(entry->d_name, \"hugepages-%zukB\", &page_size) == 1) {\n+      \/\/ The kernel is using kB, hotspot uses bytes\n+      \/\/ Add each found Large Page Size to page_sizes\n+      page_sizes.add(page_size * K);\n+    }\n+  }\n+  closedir(dir);\n+\n+  LogTarget(Debug, pagesize) lt;\n+  if (lt.is_enabled()) {\n+    LogStream ls(lt);\n+    ls.print(\"Large Page sizes: \");\n+    page_sizes.print_on(&ls);\n@@ -3930,1 +3847,1 @@\n-  return large_page_size;\n+  return page_sizes;\n@@ -3933,8 +3850,3 @@\n-size_t os::Linux::setup_large_page_size() {\n-  _large_page_size = Linux::find_large_page_size();\n-  const size_t default_page_size = (size_t)Linux::page_size();\n-  if (_large_page_size > default_page_size) {\n-    _page_sizes[0] = _large_page_size;\n-    _page_sizes[1] = default_page_size;\n-    _page_sizes[2] = 0;\n-  }\n+size_t os::Linux::default_large_page_size() {\n+  return _default_large_page_size;\n+}\n@@ -3942,1 +3854,4 @@\n-  return _large_page_size;\n+void warn_no_large_pages_configured() {\n+  if (!FLAG_IS_DEFAULT(UseLargePages)) {\n+    log_warning(pagesize)(\"UseLargePages disabled, no large pages configured and available on the system.\");\n+  }\n@@ -3979,1 +3894,10 @@\n-  return UseSHM;\n+  if (UseSHM) {\n+    bool warn_on_failure = !FLAG_IS_DEFAULT(UseSHM);\n+    if (shm_hugetlbfs_sanity_check(warn_on_failure, page_size)) {\n+      return true;\n+    }\n+    UseSHM = false;\n+  }\n+\n+  warn_no_large_pages_configured();\n+  return false;\n@@ -3983,0 +3907,2 @@\n+  \/\/ 1) Handle the case where we do not want to use huge pages and hence\n+  \/\/    there is no need to scan the OS for related info\n@@ -4000,2 +3926,67 @@\n-  size_t large_page_size = Linux::setup_large_page_size();\n-  UseLargePages          = Linux::setup_large_page_type(large_page_size);\n+  \/\/ 2) Scan OS info\n+  size_t default_large_page_size = scan_default_large_page_size();\n+  os::Linux::_default_large_page_size = default_large_page_size;\n+  if (default_large_page_size == 0) {\n+    \/\/ No large pages configured, return.\n+    warn_no_large_pages_configured();\n+    UseLargePages = false;\n+    UseTransparentHugePages = false;\n+    UseHugeTLBFS = false;\n+    UseSHM = false;\n+    return;\n+  }\n+  os::PageSizes all_large_pages = scan_multiple_page_support();\n+\n+  \/\/ 3) Consistency check and post-processing\n+\n+  \/\/ It is unclear if \/sys\/kernel\/mm\/hugepages\/ and \/proc\/meminfo could disagree. Manually\n+  \/\/ re-add the default page size to the list of page sizes to be sure.\n+  all_large_pages.add(default_large_page_size);\n+\n+  \/\/ Check LargePageSizeInBytes matches an available page size and if so set _large_page_size\n+  \/\/ using LargePageSizeInBytes as the maximum allowed large page size. If LargePageSizeInBytes\n+  \/\/ doesn't match an available page size set _large_page_size to default_large_page_size\n+  \/\/ and use it as the maximum.\n+ if (FLAG_IS_DEFAULT(LargePageSizeInBytes) ||\n+      LargePageSizeInBytes == 0 ||\n+      LargePageSizeInBytes == default_large_page_size) {\n+    _large_page_size = default_large_page_size;\n+    log_info(pagesize)(\"Using the default large page size: \" SIZE_FORMAT \"%s\",\n+                       byte_size_in_exact_unit(_large_page_size),\n+                       exact_unit_for_byte_size(_large_page_size));\n+  } else {\n+    if (all_large_pages.contains(LargePageSizeInBytes)) {\n+      _large_page_size = LargePageSizeInBytes;\n+      log_info(pagesize)(\"Overriding default large page size (\" SIZE_FORMAT \"%s) \"\n+                         \"using LargePageSizeInBytes: \" SIZE_FORMAT \"%s\",\n+                         byte_size_in_exact_unit(default_large_page_size),\n+                         exact_unit_for_byte_size(default_large_page_size),\n+                         byte_size_in_exact_unit(_large_page_size),\n+                         exact_unit_for_byte_size(_large_page_size));\n+    } else {\n+      _large_page_size = default_large_page_size;\n+      log_info(pagesize)(\"LargePageSizeInBytes is not a valid large page size (\" SIZE_FORMAT \"%s) \"\n+                         \"using the default large page size: \" SIZE_FORMAT \"%s\",\n+                         byte_size_in_exact_unit(LargePageSizeInBytes),\n+                         exact_unit_for_byte_size(LargePageSizeInBytes),\n+                         byte_size_in_exact_unit(_large_page_size),\n+                         exact_unit_for_byte_size(_large_page_size));\n+    }\n+  }\n+\n+  \/\/ Populate _page_sizes with large page sizes less than or equal to\n+  \/\/ _large_page_size.\n+  for (size_t page_size = _large_page_size; page_size != 0;\n+         page_size = all_large_pages.next_smaller(page_size)) {\n+    _page_sizes.add(page_size);\n+  }\n+\n+  LogTarget(Info, pagesize) lt;\n+  if (lt.is_enabled()) {\n+    LogStream ls(lt);\n+    ls.print(\"Usable page sizes: \");\n+    _page_sizes.print_on(&ls);\n+  }\n+\n+  \/\/ Now determine the type of large pages to use:\n+  UseLargePages = os::Linux::setup_large_page_type(_large_page_size);\n@@ -4039,1 +4030,1 @@\n-  char* pre_reserved_addr = anon_mmap_aligned(bytes, alignment, NULL);\n+  char* pre_reserved_addr = anon_mmap_aligned(NULL \/* req_addr *\/, bytes, alignment);\n@@ -4119,1 +4110,1 @@\n-    \/\/ 1. shmmax is too small for Java heap.\n+    \/\/ 1. shmmax is too small for the request.\n@@ -4121,1 +4112,1 @@\n-    \/\/    > increase shmmax value: echo \"0xffffffff\" > \/proc\/sys\/kernel\/shmmax\n+    \/\/    > increase shmmax value: echo \"new_value\" > \/proc\/sys\/kernel\/shmmax\n@@ -4125,1 +4116,3 @@\n-    \/\/          echo new_value > \/proc\/sys\/vm\/nr_hugepages\n+    \/\/          sysctl -w vm.nr_hugepages=new_value\n+    \/\/    > For more information regarding large pages please refer to:\n+    \/\/      https:\/\/www.kernel.org\/doc\/Documentation\/vm\/hugetlbpage.txt\n@@ -4148,2 +4141,2 @@\n-static void warn_on_large_pages_failure(char* req_addr, size_t bytes,\n-                                        int error) {\n+static void warn_on_commit_special_failure(char* req_addr, size_t bytes,\n+                                           size_t page_size, int error) {\n@@ -4159,2 +4152,4 @@\n-    jio_snprintf(msg, sizeof(msg), \"Failed to reserve large pages memory req_addr: \"\n-                 PTR_FORMAT \" bytes: \" SIZE_FORMAT \" (errno = %d).\", req_addr, bytes, error);\n+    jio_snprintf(msg, sizeof(msg), \"Failed to reserve and commit memory. req_addr: \"\n+                                   PTR_FORMAT \" bytes: \" SIZE_FORMAT \" page size: \"\n+                                   SIZE_FORMAT \" (errno = %d).\",\n+                                   req_addr, bytes, page_size, error);\n@@ -4165,6 +4160,8 @@\n-char* os::Linux::reserve_memory_special_huge_tlbfs_only(size_t bytes,\n-                                                        char* req_addr,\n-                                                        bool exec) {\n-  assert(UseLargePages && UseHugeTLBFS, \"only for Huge TLBFS large pages\");\n-  assert(is_aligned(bytes, os::large_page_size()), \"Unaligned size\");\n-  assert(is_aligned(req_addr, os::large_page_size()), \"Unaligned address\");\n+bool os::Linux::commit_memory_special(size_t bytes,\n+                                      size_t page_size,\n+                                      char* req_addr,\n+                                      bool exec) {\n+  assert(UseLargePages && UseHugeTLBFS, \"Should only get here when HugeTLBFS large pages are used\");\n+  assert(is_aligned(bytes, page_size), \"Unaligned size\");\n+  assert(is_aligned(req_addr, page_size), \"Unaligned address\");\n+  assert(req_addr != NULL, \"Must have a requested address for special mappings\");\n@@ -4173,3 +4170,1 @@\n-  char* addr = (char*)::mmap(req_addr, bytes, prot,\n-                             MAP_PRIVATE|MAP_ANONYMOUS|MAP_HUGETLB,\n-                             -1, 0);\n+  int flags = MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED;\n@@ -4177,3 +4172,3 @@\n-  if (addr == MAP_FAILED) {\n-    warn_on_large_pages_failure(req_addr, bytes, errno);\n-    return NULL;\n+  \/\/ For large pages additional flags are required.\n+  if (page_size > (size_t) os::vm_page_size()) {\n+    flags |= MAP_HUGETLB | hugetlbfs_page_size_flag(page_size);\n@@ -4181,0 +4176,1 @@\n+  char* addr = (char*)::mmap(req_addr, bytes, prot, flags, -1, 0);\n@@ -4182,1 +4178,4 @@\n-  assert(is_aligned(addr, os::large_page_size()), \"Must be\");\n+  if (addr == MAP_FAILED) {\n+    warn_on_commit_special_failure(req_addr, bytes, page_size, errno);\n+    return false;\n+  }\n@@ -4184,1 +4183,8 @@\n-  return addr;\n+  log_debug(pagesize)(\"Commit special mapping: \" PTR_FORMAT \", size=\" SIZE_FORMAT \"%s, page size=\"\n+                      SIZE_FORMAT \"%s\",\n+                      p2i(addr), byte_size_in_exact_unit(bytes),\n+                      exact_unit_for_byte_size(bytes),\n+                      byte_size_in_exact_unit(page_size),\n+                      exact_unit_for_byte_size(page_size));\n+  assert(is_aligned(addr, page_size), \"Must be\");\n+  return true;\n@@ -4187,14 +4193,6 @@\n-\/\/ Reserve memory using mmap(MAP_HUGETLB).\n-\/\/  - bytes shall be a multiple of alignment.\n-\/\/  - req_addr can be NULL. If not NULL, it must be a multiple of alignment.\n-\/\/  - alignment sets the alignment at which memory shall be allocated.\n-\/\/     It must be a multiple of allocation granularity.\n-\/\/ Returns address of memory or NULL. If req_addr was not NULL, will only return\n-\/\/  req_addr or NULL.\n-char* os::Linux::reserve_memory_special_huge_tlbfs_mixed(size_t bytes,\n-                                                         size_t alignment,\n-                                                         char* req_addr,\n-                                                         bool exec) {\n-  size_t large_page_size = os::large_page_size();\n-  assert(bytes >= large_page_size, \"Shouldn't allocate large pages for small sizes\");\n-\n+char* os::Linux::reserve_memory_special_huge_tlbfs(size_t bytes,\n+                                                   size_t alignment,\n+                                                   size_t page_size,\n+                                                   char* req_addr,\n+                                                   bool exec) {\n+  assert(UseLargePages && UseHugeTLBFS, \"only for Huge TLBFS large pages\");\n@@ -4202,25 +4200,17 @@\n-  assert(is_aligned(bytes, alignment), \"Must be\");\n-\n-  \/\/ First reserve - but not commit - the address range in small pages.\n-  char* const start = anon_mmap_aligned(bytes, alignment, req_addr);\n-\n-  if (start == NULL) {\n-    return NULL;\n-  }\n-\n-  assert(is_aligned(start, alignment), \"Must be\");\n-\n-  char* end = start + bytes;\n-\n-  \/\/ Find the regions of the allocated chunk that can be promoted to large pages.\n-  char* lp_start = align_up(start, large_page_size);\n-  char* lp_end   = align_down(end, large_page_size);\n-\n-  size_t lp_bytes = lp_end - lp_start;\n-\n-  assert(is_aligned(lp_bytes, large_page_size), \"Must be\");\n-\n-  if (lp_bytes == 0) {\n-    \/\/ The mapped region doesn't even span the start and the end of a large page.\n-    \/\/ Fall back to allocate a non-special area.\n-    ::munmap(start, end - start);\n+  assert(is_aligned(req_addr, page_size), \"Must be\");\n+  assert(is_aligned(alignment, os::vm_allocation_granularity()), \"Must be\");\n+  assert(_page_sizes.contains(page_size), \"Must be a valid page size\");\n+  assert(page_size > (size_t)os::vm_page_size(), \"Must be a large page size\");\n+  assert(bytes >= page_size, \"Shouldn't allocate large pages for small sizes\");\n+\n+  \/\/ We only end up here when at least 1 large page can be used.\n+  \/\/ If the size is not a multiple of the large page size, we\n+  \/\/ will mix the type of pages used, but in a decending order.\n+  \/\/ Start off by reserving a range of the given size that is\n+  \/\/ properly aligned. At this point no pages are committed. If\n+  \/\/ a requested address is given it will be used and it must be\n+  \/\/ aligned to both the large page size and the given alignment.\n+  \/\/ The larger of the two will be used.\n+  size_t required_alignment = MAX(page_size, alignment);\n+  char* const aligned_start = anon_mmap_aligned(req_addr, bytes, required_alignment);\n+  if (aligned_start == NULL) {\n@@ -4230,3 +4220,3 @@\n-  int prot = exec ? PROT_READ|PROT_WRITE|PROT_EXEC : PROT_READ|PROT_WRITE;\n-\n-  void* result;\n+  \/\/ First commit using large pages.\n+  size_t large_bytes = align_down(bytes, page_size);\n+  bool large_committed = commit_memory_special(large_bytes, page_size, aligned_start, exec);\n@@ -4234,9 +4224,4 @@\n-  \/\/ Commit small-paged leading area.\n-  if (start != lp_start) {\n-    result = ::mmap(start, lp_start - start, prot,\n-                    MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED,\n-                    -1, 0);\n-    if (result == MAP_FAILED) {\n-      ::munmap(lp_start, end - lp_start);\n-      return NULL;\n-    }\n+  if (large_committed && bytes == large_bytes) {\n+    \/\/ The size was large page aligned so no additional work is\n+    \/\/ needed even if the commit failed.\n+    return aligned_start;\n@@ -4245,15 +4230,7 @@\n-  \/\/ Commit large-paged area.\n-  result = ::mmap(lp_start, lp_bytes, prot,\n-                  MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED|MAP_HUGETLB,\n-                  -1, 0);\n-  if (result == MAP_FAILED) {\n-    warn_on_large_pages_failure(lp_start, lp_bytes, errno);\n-    \/\/ If the mmap above fails, the large pages region will be unmapped and we\n-    \/\/ have regions before and after with small pages. Release these regions.\n-    \/\/\n-    \/\/ |  mapped  |  unmapped  |  mapped  |\n-    \/\/ ^          ^            ^          ^\n-    \/\/ start      lp_start     lp_end     end\n-    \/\/\n-    ::munmap(start, lp_start - start);\n-    ::munmap(lp_end, end - lp_end);\n+  \/\/ The requested size requires some small pages as well.\n+  char* small_start = aligned_start + large_bytes;\n+  size_t small_size = bytes - large_bytes;\n+  if (!large_committed) {\n+    \/\/ Failed to commit large pages, so we need to unmap the\n+    \/\/ reminder of the orinal reservation.\n+    ::munmap(small_start, small_size);\n@@ -4263,28 +4240,7 @@\n-  \/\/ Commit small-paged trailing area.\n-  if (lp_end != end) {\n-    result = ::mmap(lp_end, end - lp_end, prot,\n-                    MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED,\n-                    -1, 0);\n-    if (result == MAP_FAILED) {\n-      ::munmap(start, lp_end - start);\n-      return NULL;\n-    }\n-  }\n-\n-  return start;\n-}\n-\n-char* os::Linux::reserve_memory_special_huge_tlbfs(size_t bytes,\n-                                                   size_t alignment,\n-                                                   char* req_addr,\n-                                                   bool exec) {\n-  assert(UseLargePages && UseHugeTLBFS, \"only for Huge TLBFS large pages\");\n-  assert(is_aligned(req_addr, alignment), \"Must be\");\n-  assert(is_aligned(alignment, os::vm_allocation_granularity()), \"Must be\");\n-  assert(is_power_of_2(os::large_page_size()), \"Must be\");\n-  assert(bytes >= os::large_page_size(), \"Shouldn't allocate large pages for small sizes\");\n-\n-  if (is_aligned(bytes, os::large_page_size()) && alignment <= os::large_page_size()) {\n-    return reserve_memory_special_huge_tlbfs_only(bytes, req_addr, exec);\n-  } else {\n-    return reserve_memory_special_huge_tlbfs_mixed(bytes, alignment, req_addr, exec);\n+  \/\/ Commit the remaining bytes using small pages.\n+  bool small_committed = commit_memory_special(small_size, os::vm_page_size(), small_start, exec);\n+  if (!small_committed) {\n+    \/\/ Failed to commit the remaining size, need to unmap\n+    \/\/ the large pages part of the reservation.\n+    ::munmap(aligned_start, large_bytes);\n+    return NULL;\n@@ -4292,0 +4248,1 @@\n+  return aligned_start;\n@@ -4294,2 +4251,2 @@\n-char* os::reserve_memory_special(size_t bytes, size_t alignment,\n-                                 char* req_addr, bool exec) {\n+char* os::pd_reserve_memory_special(size_t bytes, size_t alignment, size_t page_size,\n+                                    char* req_addr, bool exec) {\n@@ -4300,0 +4257,1 @@\n+    \/\/ No support for using specific page sizes with SHM.\n@@ -4303,1 +4261,1 @@\n-    addr = os::Linux::reserve_memory_special_huge_tlbfs(bytes, alignment, req_addr, exec);\n+    addr = os::Linux::reserve_memory_special_huge_tlbfs(bytes, alignment, page_size, req_addr, exec);\n@@ -4310,3 +4268,0 @@\n-\n-    \/\/ The memory is committed\n-    MemTracker::record_virtual_memory_reserve_and_commit((address)addr, bytes, CALLER_PC);\n@@ -4327,16 +4282,1 @@\n-bool os::release_memory_special(char* base, size_t bytes) {\n-  bool res;\n-  if (MemTracker::tracking_level() > NMT_minimal) {\n-    Tracker tkr(Tracker::release);\n-    res = os::Linux::release_memory_special_impl(base, bytes);\n-    if (res) {\n-      tkr.record((address)base, bytes);\n-    }\n-\n-  } else {\n-    res = os::Linux::release_memory_special_impl(base, bytes);\n-  }\n-  return res;\n-}\n-\n-bool os::Linux::release_memory_special_impl(char* base, size_t bytes) {\n+bool os::pd_release_memory_special(char* base, size_t bytes) {\n@@ -4374,1 +4314,1 @@\n-char* os::pd_attempt_reserve_memory_at(size_t bytes, char* requested_addr, int file_desc) {\n+char* os::pd_attempt_map_memory_to_file_at(char* requested_addr, size_t bytes, int file_desc) {\n@@ -4376,1 +4316,1 @@\n-  char* result = pd_attempt_reserve_memory_at(bytes, requested_addr);\n+  char* result = pd_attempt_reserve_memory_at(requested_addr, bytes, !ExecMem);\n@@ -4388,1 +4328,1 @@\n-char* os::pd_attempt_reserve_memory_at(size_t bytes, char* requested_addr) {\n+char* os::pd_attempt_reserve_memory_at(char* requested_addr, size_t bytes, bool exec) {\n@@ -4401,1 +4341,1 @@\n-  char * addr = anon_mmap(requested_addr, bytes, false);\n+  char * addr = anon_mmap(requested_addr, bytes);\n@@ -4481,1 +4421,1 @@\n-      if (!FLAG_IS_DEFAULT(ThreadPriorityPolicy)) {\n+      if (!FLAG_IS_DEFAULT(ThreadPriorityPolicy) && !FLAG_IS_JIMAGE_RESOURCE(ThreadPriorityPolicy)) {\n@@ -4513,481 +4453,0 @@\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\/\/ suspend\/resume support\n-\n-\/\/  The low-level signal-based suspend\/resume support is a remnant from the\n-\/\/  old VM-suspension that used to be for java-suspension, safepoints etc,\n-\/\/  within hotspot. Currently used by JFR's OSThreadSampler\n-\/\/\n-\/\/  The remaining code is greatly simplified from the more general suspension\n-\/\/  code that used to be used.\n-\/\/\n-\/\/  The protocol is quite simple:\n-\/\/  - suspend:\n-\/\/      - sends a signal to the target thread\n-\/\/      - polls the suspend state of the osthread using a yield loop\n-\/\/      - target thread signal handler (SR_handler) sets suspend state\n-\/\/        and blocks in sigsuspend until continued\n-\/\/  - resume:\n-\/\/      - sets target osthread state to continue\n-\/\/      - sends signal to end the sigsuspend loop in the SR_handler\n-\/\/\n-\/\/  Note that the SR_lock plays no role in this suspend\/resume protocol,\n-\/\/  but is checked for NULL in SR_handler as a thread termination indicator.\n-\/\/  The SR_lock is, however, used by JavaThread::java_suspend()\/java_resume() APIs.\n-\/\/\n-\/\/  Note that resume_clear_context() and suspend_save_context() are needed\n-\/\/  by SR_handler(), so that fetch_frame_from_ucontext() works,\n-\/\/  which in part is used by:\n-\/\/    - Forte Analyzer: AsyncGetCallTrace()\n-\/\/    - StackBanging: get_frame_at_stack_banging_point()\n-\n-static void resume_clear_context(OSThread *osthread) {\n-  osthread->set_ucontext(NULL);\n-  osthread->set_siginfo(NULL);\n-}\n-\n-static void suspend_save_context(OSThread *osthread, siginfo_t* siginfo,\n-                                 ucontext_t* context) {\n-  osthread->set_ucontext(context);\n-  osthread->set_siginfo(siginfo);\n-}\n-\n-\/\/ Handler function invoked when a thread's execution is suspended or\n-\/\/ resumed. We have to be careful that only async-safe functions are\n-\/\/ called here (Note: most pthread functions are not async safe and\n-\/\/ should be avoided.)\n-\/\/\n-\/\/ Note: sigwait() is a more natural fit than sigsuspend() from an\n-\/\/ interface point of view, but sigwait() prevents the signal hander\n-\/\/ from being run. libpthread would get very confused by not having\n-\/\/ its signal handlers run and prevents sigwait()'s use with the\n-\/\/ mutex granting granting signal.\n-\/\/\n-\/\/ Currently only ever called on the VMThread and JavaThreads (PC sampling)\n-\/\/\n-static void SR_handler(int sig, siginfo_t* siginfo, ucontext_t* context) {\n-  \/\/ Save and restore errno to avoid confusing native code with EINTR\n-  \/\/ after sigsuspend.\n-  int old_errno = errno;\n-\n-  Thread* thread = Thread::current_or_null_safe();\n-  assert(thread != NULL, \"Missing current thread in SR_handler\");\n-\n-  \/\/ On some systems we have seen signal delivery get \"stuck\" until the signal\n-  \/\/ mask is changed as part of thread termination. Check that the current thread\n-  \/\/ has not already terminated (via SR_lock()) - else the following assertion\n-  \/\/ will fail because the thread is no longer a JavaThread as the ~JavaThread\n-  \/\/ destructor has completed.\n-\n-  if (thread->SR_lock() == NULL) {\n-    return;\n-  }\n-\n-  assert(thread->is_VM_thread() || thread->is_Java_thread(), \"Must be VMThread or JavaThread\");\n-\n-  OSThread* osthread = thread->osthread();\n-\n-  os::SuspendResume::State current = osthread->sr.state();\n-  if (current == os::SuspendResume::SR_SUSPEND_REQUEST) {\n-    suspend_save_context(osthread, siginfo, context);\n-\n-    \/\/ attempt to switch the state, we assume we had a SUSPEND_REQUEST\n-    os::SuspendResume::State state = osthread->sr.suspended();\n-    if (state == os::SuspendResume::SR_SUSPENDED) {\n-      sigset_t suspend_set;  \/\/ signals for sigsuspend()\n-      sigemptyset(&suspend_set);\n-      \/\/ get current set of blocked signals and unblock resume signal\n-      pthread_sigmask(SIG_BLOCK, NULL, &suspend_set);\n-      sigdelset(&suspend_set, SR_signum);\n-\n-      sr_semaphore.signal();\n-      \/\/ wait here until we are resumed\n-      while (1) {\n-        sigsuspend(&suspend_set);\n-\n-        os::SuspendResume::State result = osthread->sr.running();\n-        if (result == os::SuspendResume::SR_RUNNING) {\n-          sr_semaphore.signal();\n-          break;\n-        }\n-      }\n-\n-    } else if (state == os::SuspendResume::SR_RUNNING) {\n-      \/\/ request was cancelled, continue\n-    } else {\n-      ShouldNotReachHere();\n-    }\n-\n-    resume_clear_context(osthread);\n-  } else if (current == os::SuspendResume::SR_RUNNING) {\n-    \/\/ request was cancelled, continue\n-  } else if (current == os::SuspendResume::SR_WAKEUP_REQUEST) {\n-    \/\/ ignore\n-  } else {\n-    \/\/ ignore\n-  }\n-\n-  errno = old_errno;\n-}\n-\n-static int SR_initialize() {\n-  struct sigaction act;\n-  char *s;\n-\n-  \/\/ Get signal number to use for suspend\/resume\n-  if ((s = ::getenv(\"_JAVA_SR_SIGNUM\")) != 0) {\n-    int sig = ::strtol(s, 0, 10);\n-    if (sig > MAX2(SIGSEGV, SIGBUS) &&  \/\/ See 4355769.\n-        sig < NSIG) {                   \/\/ Must be legal signal and fit into sigflags[].\n-      SR_signum = sig;\n-    } else {\n-      warning(\"You set _JAVA_SR_SIGNUM=%d. It must be in range [%d, %d]. Using %d instead.\",\n-              sig, MAX2(SIGSEGV, SIGBUS)+1, NSIG-1, SR_signum);\n-    }\n-  }\n-\n-  assert(SR_signum > SIGSEGV && SR_signum > SIGBUS,\n-         \"SR_signum must be greater than max(SIGSEGV, SIGBUS), see 4355769\");\n-\n-  sigemptyset(&SR_sigset);\n-  sigaddset(&SR_sigset, SR_signum);\n-\n-  \/\/ Set up signal handler for suspend\/resume\n-  act.sa_flags = SA_RESTART|SA_SIGINFO;\n-  act.sa_handler = (void (*)(int)) SR_handler;\n-\n-  \/\/ SR_signum is blocked by default.\n-  \/\/ 4528190 - We also need to block pthread restart signal (32 on all\n-  \/\/ supported Linux platforms). Note that LinuxThreads need to block\n-  \/\/ this signal for all threads to work properly. So we don't have\n-  \/\/ to use hard-coded signal number when setting up the mask.\n-  pthread_sigmask(SIG_BLOCK, NULL, &act.sa_mask);\n-\n-  if (sigaction(SR_signum, &act, 0) == -1) {\n-    return -1;\n-  }\n-\n-  \/\/ Save signal flag\n-  os::Linux::set_our_sigflags(SR_signum, act.sa_flags);\n-  return 0;\n-}\n-\n-static int sr_notify(OSThread* osthread) {\n-  int status = pthread_kill(osthread->pthread_id(), SR_signum);\n-  assert_status(status == 0, status, \"pthread_kill\");\n-  return status;\n-}\n-\n-\/\/ \"Randomly\" selected value for how long we want to spin\n-\/\/ before bailing out on suspending a thread, also how often\n-\/\/ we send a signal to a thread we want to resume\n-static const int RANDOMLY_LARGE_INTEGER = 1000000;\n-static const int RANDOMLY_LARGE_INTEGER2 = 100;\n-\n-\/\/ returns true on success and false on error - really an error is fatal\n-\/\/ but this seems the normal response to library errors\n-static bool do_suspend(OSThread* osthread) {\n-  assert(osthread->sr.is_running(), \"thread should be running\");\n-  assert(!sr_semaphore.trywait(), \"semaphore has invalid state\");\n-\n-  \/\/ mark as suspended and send signal\n-  if (osthread->sr.request_suspend() != os::SuspendResume::SR_SUSPEND_REQUEST) {\n-    \/\/ failed to switch, state wasn't running?\n-    ShouldNotReachHere();\n-    return false;\n-  }\n-\n-  if (sr_notify(osthread) != 0) {\n-    ShouldNotReachHere();\n-  }\n-\n-  \/\/ managed to send the signal and switch to SUSPEND_REQUEST, now wait for SUSPENDED\n-  while (true) {\n-    if (sr_semaphore.timedwait(2)) {\n-      break;\n-    } else {\n-      \/\/ timeout\n-      os::SuspendResume::State cancelled = osthread->sr.cancel_suspend();\n-      if (cancelled == os::SuspendResume::SR_RUNNING) {\n-        return false;\n-      } else if (cancelled == os::SuspendResume::SR_SUSPENDED) {\n-        \/\/ make sure that we consume the signal on the semaphore as well\n-        sr_semaphore.wait();\n-        break;\n-      } else {\n-        ShouldNotReachHere();\n-        return false;\n-      }\n-    }\n-  }\n-\n-  guarantee(osthread->sr.is_suspended(), \"Must be suspended\");\n-  return true;\n-}\n-\n-static void do_resume(OSThread* osthread) {\n-  assert(osthread->sr.is_suspended(), \"thread should be suspended\");\n-  assert(!sr_semaphore.trywait(), \"invalid semaphore state\");\n-\n-  if (osthread->sr.request_wakeup() != os::SuspendResume::SR_WAKEUP_REQUEST) {\n-    \/\/ failed to switch to WAKEUP_REQUEST\n-    ShouldNotReachHere();\n-    return;\n-  }\n-\n-  while (true) {\n-    if (sr_notify(osthread) == 0) {\n-      if (sr_semaphore.timedwait(2)) {\n-        if (osthread->sr.is_running()) {\n-          return;\n-        }\n-      }\n-    } else {\n-      ShouldNotReachHere();\n-    }\n-  }\n-\n-  guarantee(osthread->sr.is_running(), \"Must be running!\");\n-}\n-\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\/\/ signal handling (except suspend\/resume)\n-\n-\/\/ This routine may be used by user applications as a \"hook\" to catch signals.\n-\/\/ The user-defined signal handler must pass unrecognized signals to this\n-\/\/ routine, and if it returns true (non-zero), then the signal handler must\n-\/\/ return immediately.  If the flag \"abort_if_unrecognized\" is true, then this\n-\/\/ routine will never retun false (zero), but instead will execute a VM panic\n-\/\/ routine kill the process.\n-\/\/\n-\/\/ If this routine returns false, it is OK to call it again.  This allows\n-\/\/ the user-defined signal handler to perform checks either before or after\n-\/\/ the VM performs its own checks.  Naturally, the user code would be making\n-\/\/ a serious error if it tried to handle an exception (such as a null check\n-\/\/ or breakpoint) that the VM was generating for its own correct operation.\n-\/\/\n-\/\/ This routine may recognize any of the following kinds of signals:\n-\/\/    SIGBUS, SIGSEGV, SIGILL, SIGFPE, SIGQUIT, SIGPIPE, SIGXFSZ, SIGUSR1.\n-\/\/ It should be consulted by handlers for any of those signals.\n-\/\/\n-\/\/ The caller of this routine must pass in the three arguments supplied\n-\/\/ to the function referred to in the \"sa_sigaction\" (not the \"sa_handler\")\n-\/\/ field of the structure passed to sigaction().  This routine assumes that\n-\/\/ the sa_flags field passed to sigaction() includes SA_SIGINFO and SA_RESTART.\n-\/\/\n-\/\/ Note that the VM will print warnings if it detects conflicting signal\n-\/\/ handlers, unless invoked with the option \"-XX:+AllowUserSignalHandlers\".\n-\/\/\n-extern \"C\" JNIEXPORT int JVM_handle_linux_signal(int signo,\n-                                                 siginfo_t* siginfo,\n-                                                 void* ucontext,\n-                                                 int abort_if_unrecognized);\n-\n-static void signalHandler(int sig, siginfo_t* info, void* uc) {\n-  assert(info != NULL && uc != NULL, \"it must be old kernel\");\n-  int orig_errno = errno;  \/\/ Preserve errno value over signal handler.\n-  JVM_handle_linux_signal(sig, info, uc, true);\n-  errno = orig_errno;\n-}\n-\n-\n-\/\/ This boolean allows users to forward their own non-matching signals\n-\/\/ to JVM_handle_linux_signal, harmlessly.\n-bool os::Linux::signal_handlers_are_installed = false;\n-\n-\/\/ For signal-chaining\n-bool os::Linux::libjsig_is_loaded = false;\n-typedef struct sigaction *(*get_signal_t)(int);\n-get_signal_t os::Linux::get_signal_action = NULL;\n-\n-struct sigaction* os::Linux::get_chained_signal_action(int sig) {\n-  struct sigaction *actp = NULL;\n-\n-  if (libjsig_is_loaded) {\n-    \/\/ Retrieve the old signal handler from libjsig\n-    actp = (*get_signal_action)(sig);\n-  }\n-  if (actp == NULL) {\n-    \/\/ Retrieve the preinstalled signal handler from jvm\n-    actp = os::Posix::get_preinstalled_handler(sig);\n-  }\n-\n-  return actp;\n-}\n-\n-static bool call_chained_handler(struct sigaction *actp, int sig,\n-                                 siginfo_t *siginfo, void *context) {\n-  \/\/ Call the old signal handler\n-  if (actp->sa_handler == SIG_DFL) {\n-    \/\/ It's more reasonable to let jvm treat it as an unexpected exception\n-    \/\/ instead of taking the default action.\n-    return false;\n-  } else if (actp->sa_handler != SIG_IGN) {\n-    if ((actp->sa_flags & SA_NODEFER) == 0) {\n-      \/\/ automaticlly block the signal\n-      sigaddset(&(actp->sa_mask), sig);\n-    }\n-\n-    sa_handler_t hand = NULL;\n-    sa_sigaction_t sa = NULL;\n-    bool siginfo_flag_set = (actp->sa_flags & SA_SIGINFO) != 0;\n-    \/\/ retrieve the chained handler\n-    if (siginfo_flag_set) {\n-      sa = actp->sa_sigaction;\n-    } else {\n-      hand = actp->sa_handler;\n-    }\n-\n-    if ((actp->sa_flags & SA_RESETHAND) != 0) {\n-      actp->sa_handler = SIG_DFL;\n-    }\n-\n-    \/\/ try to honor the signal mask\n-    sigset_t oset;\n-    sigemptyset(&oset);\n-    pthread_sigmask(SIG_SETMASK, &(actp->sa_mask), &oset);\n-\n-    \/\/ call into the chained handler\n-    if (siginfo_flag_set) {\n-      (*sa)(sig, siginfo, context);\n-    } else {\n-      (*hand)(sig);\n-    }\n-\n-    \/\/ restore the signal mask\n-    pthread_sigmask(SIG_SETMASK, &oset, NULL);\n-  }\n-  \/\/ Tell jvm's signal handler the signal is taken care of.\n-  return true;\n-}\n-\n-bool os::Linux::chained_handler(int sig, siginfo_t* siginfo, void* context) {\n-  bool chained = false;\n-  \/\/ signal-chaining\n-  if (UseSignalChaining) {\n-    struct sigaction *actp = get_chained_signal_action(sig);\n-    if (actp != NULL) {\n-      chained = call_chained_handler(actp, sig, siginfo, context);\n-    }\n-  }\n-  return chained;\n-}\n-\n-\/\/ for diagnostic\n-int sigflags[NSIG];\n-\n-int os::Linux::get_our_sigflags(int sig) {\n-  assert(sig > 0 && sig < NSIG, \"vm signal out of expected range\");\n-  return sigflags[sig];\n-}\n-\n-void os::Linux::set_our_sigflags(int sig, int flags) {\n-  assert(sig > 0 && sig < NSIG, \"vm signal out of expected range\");\n-  if (sig > 0 && sig < NSIG) {\n-    sigflags[sig] = flags;\n-  }\n-}\n-\n-void os::Linux::set_signal_handler(int sig, bool set_installed) {\n-  \/\/ Check for overwrite.\n-  struct sigaction oldAct;\n-  sigaction(sig, (struct sigaction*)NULL, &oldAct);\n-\n-  void* oldhand = oldAct.sa_sigaction\n-                ? CAST_FROM_FN_PTR(void*,  oldAct.sa_sigaction)\n-                : CAST_FROM_FN_PTR(void*,  oldAct.sa_handler);\n-  if (oldhand != CAST_FROM_FN_PTR(void*, SIG_DFL) &&\n-      oldhand != CAST_FROM_FN_PTR(void*, SIG_IGN) &&\n-      oldhand != CAST_FROM_FN_PTR(void*, (sa_sigaction_t)signalHandler)) {\n-    if (AllowUserSignalHandlers || !set_installed) {\n-      \/\/ Do not overwrite; user takes responsibility to forward to us.\n-      return;\n-    } else if (UseSignalChaining) {\n-      \/\/ save the old handler in jvm\n-      os::Posix::save_preinstalled_handler(sig, oldAct);\n-      \/\/ libjsig also interposes the sigaction() call below and saves the\n-      \/\/ old sigaction on it own.\n-    } else {\n-      fatal(\"Encountered unexpected pre-existing sigaction handler \"\n-            \"%#lx for signal %d.\", (long)oldhand, sig);\n-    }\n-  }\n-\n-  struct sigaction sigAct;\n-  sigfillset(&(sigAct.sa_mask));\n-  sigAct.sa_handler = SIG_DFL;\n-  if (!set_installed) {\n-    sigAct.sa_flags = SA_SIGINFO|SA_RESTART;\n-  } else {\n-    sigAct.sa_sigaction = signalHandler;\n-    sigAct.sa_flags = SA_SIGINFO|SA_RESTART;\n-  }\n-  \/\/ Save flags, which are set by ours\n-  assert(sig > 0 && sig < NSIG, \"vm signal out of expected range\");\n-  sigflags[sig] = sigAct.sa_flags;\n-\n-  int ret = sigaction(sig, &sigAct, &oldAct);\n-  assert(ret == 0, \"check\");\n-\n-  void* oldhand2  = oldAct.sa_sigaction\n-                  ? CAST_FROM_FN_PTR(void*, oldAct.sa_sigaction)\n-                  : CAST_FROM_FN_PTR(void*, oldAct.sa_handler);\n-  assert(oldhand2 == oldhand, \"no concurrent signal handler installation\");\n-}\n-\n-\/\/ install signal handlers for signals that HotSpot needs to\n-\/\/ handle in order to support Java-level exception handling.\n-\n-void os::Linux::install_signal_handlers() {\n-  if (!signal_handlers_are_installed) {\n-    signal_handlers_are_installed = true;\n-\n-    \/\/ signal-chaining\n-    typedef void (*signal_setting_t)();\n-    signal_setting_t begin_signal_setting = NULL;\n-    signal_setting_t end_signal_setting = NULL;\n-    begin_signal_setting = CAST_TO_FN_PTR(signal_setting_t,\n-                                          dlsym(RTLD_DEFAULT, \"JVM_begin_signal_setting\"));\n-    if (begin_signal_setting != NULL) {\n-      end_signal_setting = CAST_TO_FN_PTR(signal_setting_t,\n-                                          dlsym(RTLD_DEFAULT, \"JVM_end_signal_setting\"));\n-      get_signal_action = CAST_TO_FN_PTR(get_signal_t,\n-                                         dlsym(RTLD_DEFAULT, \"JVM_get_signal_action\"));\n-      libjsig_is_loaded = true;\n-      assert(UseSignalChaining, \"should enable signal-chaining\");\n-    }\n-    if (libjsig_is_loaded) {\n-      \/\/ Tell libjsig jvm is setting signal handlers\n-      (*begin_signal_setting)();\n-    }\n-\n-    set_signal_handler(SIGSEGV, true);\n-    set_signal_handler(SIGPIPE, true);\n-    set_signal_handler(SIGBUS, true);\n-    set_signal_handler(SIGILL, true);\n-    set_signal_handler(SIGFPE, true);\n-#if defined(PPC64)\n-    set_signal_handler(SIGTRAP, true);\n-#endif\n-    set_signal_handler(SIGXFSZ, true);\n-\n-    if (libjsig_is_loaded) {\n-      \/\/ Tell libjsig jvm finishes setting signal handlers\n-      (*end_signal_setting)();\n-    }\n-\n-    \/\/ We don't activate signal checker if libjsig is in place, we trust ourselves\n-    \/\/ and if UserSignalHandler is installed all bets are off.\n-    \/\/ Log that signal checking is off only if -verbose:jni is specified.\n-    if (CheckJNICalls) {\n-      if (libjsig_is_loaded) {\n-        log_debug(jni, resolve)(\"Info: libjsig is activated, all active signal checking is disabled\");\n-        check_signals = false;\n-      }\n-      if (AllowUserSignalHandlers) {\n-        log_debug(jni, resolve)(\"Info: AllowUserSignalHandlers is activated, all active signal checking is disabled\");\n-        check_signals = false;\n-      }\n-    }\n-  }\n-}\n-\n@@ -5003,3 +4462,2 @@\n-  int rc = os::Posix::clock_gettime(clockid, &tp);\n-  assert(rc == 0, \"clock_gettime is expected to return 0 code\");\n-\n+  int status = clock_gettime(clockid, &tp);\n+  assert(status == 0, \"clock_gettime error: %s\", os::strerror(errno));\n@@ -5009,42 +4467,5 @@\n-\/\/\/\/\/\n-\/\/ glibc on Linux platform uses non-documented flag\n-\/\/ to indicate, that some special sort of signal\n-\/\/ trampoline is used.\n-\/\/ We will never set this flag, and we should\n-\/\/ ignore this flag in our diagnostic\n-#ifdef SIGNIFICANT_SIGNAL_MASK\n-  #undef SIGNIFICANT_SIGNAL_MASK\n-#endif\n-#define SIGNIFICANT_SIGNAL_MASK (~0x04000000)\n-\n-static const char* get_signal_handler_name(address handler,\n-                                           char* buf, int buflen) {\n-  int offset = 0;\n-  bool found = os::dll_address_to_library_name(handler, buf, buflen, &offset);\n-  if (found) {\n-    \/\/ skip directory names\n-    const char *p1, *p2;\n-    p1 = buf;\n-    size_t len = strlen(os::file_separator());\n-    while ((p2 = strstr(p1, os::file_separator())) != NULL) p1 = p2 + len;\n-    jio_snprintf(buf, buflen, \"%s+0x%x\", p1, offset);\n-  } else {\n-    jio_snprintf(buf, buflen, PTR_FORMAT, handler);\n-  }\n-  return buf;\n-}\n-\n-static void print_signal_handler(outputStream* st, int sig,\n-                                 char* buf, size_t buflen) {\n-  struct sigaction sa;\n-\n-  sigaction(sig, NULL, &sa);\n-\n-  \/\/ See comment for SIGNIFICANT_SIGNAL_MASK define\n-  sa.sa_flags &= SIGNIFICANT_SIGNAL_MASK;\n-\n-  st->print(\"%s: \", os::exception_name(sig, buf, buflen));\n-\n-  address handler = (sa.sa_flags & SA_SIGINFO)\n-    ? CAST_FROM_FN_PTR(address, sa.sa_sigaction)\n-    : CAST_FROM_FN_PTR(address, sa.sa_handler);\n+\/\/ Determine if the vmid is the parent pid for a child in a PID namespace.\n+\/\/ Return the namespace pid if so, otherwise -1.\n+int os::Linux::get_namespace_pid(int vmid) {\n+  char fname[24];\n+  int retpid = -1;\n@@ -5052,7 +4473,2 @@\n-  if (handler == CAST_FROM_FN_PTR(address, SIG_DFL)) {\n-    st->print(\"SIG_DFL\");\n-  } else if (handler == CAST_FROM_FN_PTR(address, SIG_IGN)) {\n-    st->print(\"SIG_IGN\");\n-  } else {\n-    st->print(\"[%s]\", get_signal_handler_name(handler, buf, buflen));\n-  }\n+  snprintf(fname, sizeof(fname), \"\/proc\/%d\/status\", vmid);\n+  FILE *fp = fopen(fname, \"r\");\n@@ -5060,22 +4476,16 @@\n-  st->print(\", sa_mask[0]=\");\n-  os::Posix::print_signal_set_short(st, &sa.sa_mask);\n-\n-  address rh = VMError::get_resetted_sighandler(sig);\n-  \/\/ May be, handler was resetted by VMError?\n-  if (rh != NULL) {\n-    handler = rh;\n-    sa.sa_flags = VMError::get_resetted_sigflags(sig) & SIGNIFICANT_SIGNAL_MASK;\n-  }\n-\n-  st->print(\", sa_flags=\");\n-  os::Posix::print_sa_flags(st, sa.sa_flags);\n-\n-  \/\/ Check: is it our handler?\n-  if (handler == CAST_FROM_FN_PTR(address, (sa_sigaction_t)signalHandler) ||\n-      handler == CAST_FROM_FN_PTR(address, (sa_sigaction_t)SR_handler)) {\n-    \/\/ It is our signal handler\n-    \/\/ check for flags, reset system-used one!\n-    if ((int)sa.sa_flags != os::Linux::get_our_sigflags(sig)) {\n-      st->print(\n-                \", flags was changed from \" PTR32_FORMAT \", consider using jsig library\",\n-                os::Linux::get_our_sigflags(sig));\n+  if (fp) {\n+    int pid, nspid;\n+    int ret;\n+    while (!feof(fp) && !ferror(fp)) {\n+      ret = fscanf(fp, \"NSpid: %d %d\", &pid, &nspid);\n+      if (ret == 1) {\n+        break;\n+      }\n+      if (ret == 2) {\n+        retpid = nspid;\n+        break;\n+      }\n+      for (;;) {\n+        int ch = fgetc(fp);\n+        if (ch == EOF || ch == (int)'\\n') break;\n+      }\n@@ -5083,0 +4493,1 @@\n+    fclose(fp);\n@@ -5084,41 +4495,1 @@\n-  st->cr();\n-}\n-\n-\n-#define DO_SIGNAL_CHECK(sig)                      \\\n-  do {                                            \\\n-    if (!sigismember(&check_signal_done, sig)) {  \\\n-      os::Linux::check_signal_handler(sig);       \\\n-    }                                             \\\n-  } while (0)\n-\n-\/\/ This method is a periodic task to check for misbehaving JNI applications\n-\/\/ under CheckJNI, we can add any periodic checks here\n-\n-void os::run_periodic_checks() {\n-  if (check_signals == false) return;\n-\n-  \/\/ SEGV and BUS if overridden could potentially prevent\n-  \/\/ generation of hs*.log in the event of a crash, debugging\n-  \/\/ such a case can be very challenging, so we absolutely\n-  \/\/ check the following for a good measure:\n-  DO_SIGNAL_CHECK(SIGSEGV);\n-  DO_SIGNAL_CHECK(SIGILL);\n-  DO_SIGNAL_CHECK(SIGFPE);\n-  DO_SIGNAL_CHECK(SIGBUS);\n-  DO_SIGNAL_CHECK(SIGPIPE);\n-  DO_SIGNAL_CHECK(SIGXFSZ);\n-#if defined(PPC64)\n-  DO_SIGNAL_CHECK(SIGTRAP);\n-#endif\n-\n-  \/\/ ReduceSignalUsage allows the user to override these handlers\n-  \/\/ see comments at the very top and jvm_md.h\n-  if (!ReduceSignalUsage) {\n-    DO_SIGNAL_CHECK(SHUTDOWN1_SIGNAL);\n-    DO_SIGNAL_CHECK(SHUTDOWN2_SIGNAL);\n-    DO_SIGNAL_CHECK(SHUTDOWN3_SIGNAL);\n-    DO_SIGNAL_CHECK(BREAK_SIGNAL);\n-  }\n-\n-  DO_SIGNAL_CHECK(SR_signum);\n+  return retpid;\n@@ -5127,35 +4498,2 @@\n-typedef int (*os_sigaction_t)(int, const struct sigaction *, struct sigaction *);\n-\n-static os_sigaction_t os_sigaction = NULL;\n-\n-void os::Linux::check_signal_handler(int sig) {\n-  char buf[O_BUFLEN];\n-  address jvmHandler = NULL;\n-\n-\n-  struct sigaction act;\n-  if (os_sigaction == NULL) {\n-    \/\/ only trust the default sigaction, in case it has been interposed\n-    os_sigaction = (os_sigaction_t)dlsym(RTLD_DEFAULT, \"sigaction\");\n-    if (os_sigaction == NULL) return;\n-  }\n-\n-  os_sigaction(sig, (struct sigaction*)NULL, &act);\n-\n-\n-  act.sa_flags &= SIGNIFICANT_SIGNAL_MASK;\n-\n-  address thisHandler = (act.sa_flags & SA_SIGINFO)\n-    ? CAST_FROM_FN_PTR(address, act.sa_sigaction)\n-    : CAST_FROM_FN_PTR(address, act.sa_handler);\n-\n-\n-  switch (sig) {\n-  case SIGSEGV:\n-  case SIGBUS:\n-  case SIGFPE:\n-  case SIGPIPE:\n-  case SIGILL:\n-  case SIGXFSZ:\n-    jvmHandler = CAST_FROM_FN_PTR(address, (sa_sigaction_t)signalHandler);\n-    break;\n+extern void report_error(char* file_name, int line_no, char* title,\n+                         char* format, ...);\n@@ -5163,6 +4501,16 @@\n-  case SHUTDOWN1_SIGNAL:\n-  case SHUTDOWN2_SIGNAL:\n-  case SHUTDOWN3_SIGNAL:\n-  case BREAK_SIGNAL:\n-    jvmHandler = (address)user_handler();\n-    break;\n+\/\/ Some linux distributions (notably: Alpine Linux) include the\n+\/\/ grsecurity in the kernel. Of particular interest from a JVM perspective\n+\/\/ is PaX (https:\/\/pax.grsecurity.net\/), which adds some security features\n+\/\/ related to page attributes. Specifically, the MPROTECT PaX functionality\n+\/\/ (https:\/\/pax.grsecurity.net\/docs\/mprotect.txt) prevents dynamic\n+\/\/ code generation by disallowing a (previously) writable page to be\n+\/\/ marked as executable. This is, of course, exactly what HotSpot does\n+\/\/ for both JIT compiled method, as well as for stubs, adapters, etc.\n+\/\/\n+\/\/ Instead of crashing \"lazily\" when trying to make a page executable,\n+\/\/ this code probes for the presence of PaX and reports the failure\n+\/\/ eagerly.\n+static void check_pax(void) {\n+  \/\/ Zero doesn't generate code dynamically, so no need to perform the PaX check\n+#ifndef ZERO\n+  size_t size = os::Linux::page_size();\n@@ -5170,7 +4518,4 @@\n-  default:\n-    if (sig == SR_signum) {\n-      jvmHandler = CAST_FROM_FN_PTR(address, (sa_sigaction_t)SR_handler);\n-    } else {\n-      return;\n-    }\n-    break;\n+  void* p = ::mmap(NULL, size, PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);\n+  if (p == MAP_FAILED) {\n+    log_debug(os)(\"os_linux.cpp: check_pax: mmap failed (%s)\" , os::strerror(errno));\n+    vm_exit_out_of_memory(size, OOM_MMAP_ERROR, \"failed to allocate memory for PaX check.\");\n@@ -5179,21 +4524,5 @@\n-  if (thisHandler != jvmHandler) {\n-    tty->print(\"Warning: %s handler \", exception_name(sig, buf, O_BUFLEN));\n-    tty->print(\"expected:%s\", get_signal_handler_name(jvmHandler, buf, O_BUFLEN));\n-    tty->print_cr(\"  found:%s\", get_signal_handler_name(thisHandler, buf, O_BUFLEN));\n-    \/\/ No need to check this sig any longer\n-    sigaddset(&check_signal_done, sig);\n-    \/\/ Running under non-interactive shell, SHUTDOWN2_SIGNAL will be reassigned SIG_IGN\n-    if (sig == SHUTDOWN2_SIGNAL && !isatty(fileno(stdin))) {\n-      tty->print_cr(\"Running in non-interactive shell, %s handler is replaced by shell\",\n-                    exception_name(sig, buf, O_BUFLEN));\n-    }\n-  } else if(os::Linux::get_our_sigflags(sig) != 0 && (int)act.sa_flags != os::Linux::get_our_sigflags(sig)) {\n-    tty->print(\"Warning: %s handler flags \", exception_name(sig, buf, O_BUFLEN));\n-    tty->print(\"expected:\");\n-    os::Posix::print_sa_flags(tty, os::Linux::get_our_sigflags(sig));\n-    tty->cr();\n-    tty->print(\"  found:\");\n-    os::Posix::print_sa_flags(tty, act.sa_flags);\n-    tty->cr();\n-    \/\/ No need to check this sig any longer\n-    sigaddset(&check_signal_done, sig);\n+  int res = ::mprotect(p, size, PROT_WRITE|PROT_EXEC);\n+  if (res == -1) {\n+    log_debug(os)(\"os_linux.cpp: check_pax: mprotect failed (%s)\" , os::strerror(errno));\n+    vm_exit_during_initialization(\n+      \"Failed to mark memory page as executable - check if grsecurity\/PaX is enabled\");\n@@ -5202,4 +4531,2 @@\n-  \/\/ Dump all the signal\n-  if (sigismember(&check_signal_done, sig)) {\n-    print_signal_handlers(tty, buf, O_BUFLEN);\n-  }\n+  ::munmap(p, size);\n+#endif\n@@ -5208,3 +4535,0 @@\n-extern void report_error(char* file_name, int line_no, char* title,\n-                         char* format, ...);\n-\n@@ -5217,2 +4541,0 @@\n-  init_random(1234567);\n-\n@@ -5224,1 +4546,1 @@\n-  init_page_sizes((size_t) Linux::page_size());\n+  _page_sizes.add(Linux::page_size());\n@@ -5228,0 +4550,5 @@\n+#ifdef __GLIBC__\n+  Linux::_mallinfo = CAST_TO_FN_PTR(Linux::mallinfo_func_t, dlsym(RTLD_DEFAULT, \"mallinfo\"));\n+  Linux::_mallinfo2 = CAST_TO_FN_PTR(Linux::mallinfo2_func_t, dlsym(RTLD_DEFAULT, \"mallinfo2\"));\n+#endif \/\/ __GLIBC__\n+\n@@ -5244,0 +4571,2 @@\n+  check_pax();\n+\n@@ -5247,6 +4576,0 @@\n-\n-  \/\/ Always warn if no monotonic clock available\n-  if (!os::Posix::supports_monotonic_clock()) {\n-    warning(\"No monotonic clock was available - timed services may \"    \\\n-            \"be adversely affected if the time-of-day clock changes\");\n-  }\n@@ -5284,1 +4607,2 @@\n-    UseNUMA = false;\n+    FLAG_SET_ERGO(UseNUMA, false);\n+    FLAG_SET_ERGO(UseNUMAInterleaving, false); \/\/ Also depends on libnuma.\n@@ -5288,1 +4612,1 @@\n-      \/\/ is bound explicitly to a single node using membind, disable NUMA.\n+      \/\/ is bound explicitly to a single node using membind, disable NUMA\n@@ -5291,1 +4615,0 @@\n-\n@@ -5316,0 +4639,5 @@\n+  \/\/ When NUMA requested, not-NUMA-aware allocations default to interleaving.\n+  if (UseNUMA && !UseNUMAInterleaving) {\n+    FLAG_SET_ERGO_IF_DEFAULT(UseNUMAInterleaving, true);\n+  }\n+\n@@ -5328,4 +4656,0 @@\n-\n-  if (!UseNUMA && ForceNUMA) {\n-    UseNUMA = true;\n-  }\n@@ -5345,3 +4669,1 @@\n-  \/\/ initialize suspend\/resume support - must do this before signal_sets_init()\n-  if (SR_initialize() != 0) {\n-    perror(\"SR_initialize failed\");\n+  if (PosixSignals::init() == JNI_ERR) {\n@@ -5351,7 +4673,0 @@\n-  Linux::signal_sets_init();\n-  Linux::install_signal_handlers();\n-  \/\/ Initialize data for jdk.internal.misc.Signal\n-  if (!ReduceSignalUsage) {\n-    jdk_misc_signal_init();\n-  }\n-\n@@ -5367,1 +4682,1 @@\n-#if defined(IA32)\n+#if defined(IA32) && !defined(ZERO)\n@@ -5382,1 +4697,1 @@\n-               Linux::glibc_version(), Linux::libpthread_version());\n+               Linux::libc_version(), Linux::libpthread_version());\n@@ -5384,1 +4699,1 @@\n-  if (UseNUMA) {\n+  if (UseNUMA || UseNUMAInterleaving) {\n@@ -5426,1 +4741,1 @@\n-  if (!FLAG_IS_DEFAULT(AllocateHeapAt) || !FLAG_IS_DEFAULT(AllocateOldGenAt)) {\n+  if (!FLAG_IS_DEFAULT(AllocateHeapAt)) {\n@@ -5438,7 +4753,4 @@\n-  return JNI_OK;\n-}\n-\n-\/\/ Mark the polling page as unreadable\n-void os::make_polling_page_unreadable(void) {\n-  if (!guard_memory((char*)_polling_page, Linux::page_size())) {\n-    fatal(\"Could not disable polling page\");\n+  if (DumpPerfMapAtExit && FLAG_IS_DEFAULT(UseCodeCacheFlushing)) {\n+    \/\/ Disable code cache flushing to ensure the map file written at\n+    \/\/ exit contains all nmethods generated during execution.\n+    FLAG_SET_DEFAULT(UseCodeCacheFlushing, false);\n@@ -5446,6 +4758,1 @@\n-}\n-\/\/ Mark the polling page as readable\n-void os::make_polling_page_readable(void) {\n-  if (!linux_mprotect((char *)_polling_page, Linux::page_size(), PROT_READ)) {\n-    fatal(\"Could not enable polling page\");\n-  }\n+  return JNI_OK;\n@@ -5587,0 +4894,17 @@\n+static bool should_warn_invalid_processor_id() {\n+  if (os::processor_count() == 1) {\n+    \/\/ Don't warn if we only have one processor\n+    return false;\n+  }\n+\n+  static volatile int warn_once = 1;\n+\n+  if (Atomic::load(&warn_once) == 0 ||\n+      Atomic::xchg(&warn_once, 0) == 0) {\n+    \/\/ Don't warn more than once\n+    return false;\n+  }\n+\n+  return true;\n+}\n+\n@@ -5589,2 +4913,21 @@\n-  assert(id >= 0 && id < _processor_count, \"Invalid processor id\");\n-  return (uint)id;\n+\n+  if (id < processor_count()) {\n+    return (uint)id;\n+  }\n+\n+  \/\/ Some environments (e.g. openvz containers and the rr debugger) incorrectly\n+  \/\/ report a processor id that is higher than the number of processors available.\n+  \/\/ This is problematic, for example, when implementing CPU-local data structures,\n+  \/\/ where the processor id is used to index into an array of length processor_count().\n+  \/\/ If this happens we return 0 here. This is is safe since we always have at least\n+  \/\/ one processor, but it's not optimal for performance if we're actually executing\n+  \/\/ in an environment with more than one processor.\n+  if (should_warn_invalid_processor_id()) {\n+    log_warning(os)(\"Invalid processor id reported by the operating system \"\n+                    \"(got processor id %d, valid processor id range is 0-%d)\",\n+                    id, processor_count() - 1);\n+    log_warning(os)(\"Falling back to assuming processor id is 0. \"\n+                    \"This could have a negative impact on performance.\");\n+  }\n+\n+  return 0;\n@@ -5609,10 +4952,0 @@\n-\/\/\/\n-\n-void os::SuspendedThreadTask::internal_do_task() {\n-  if (do_suspend(_thread->osthread())) {\n-    SuspendedThreadTaskContext context(_thread, _thread->osthread()->ucontext());\n-    do_task(context);\n-    do_resume(_thread->osthread());\n-  }\n-}\n-\n@@ -5670,1 +5003,1 @@\n-                         JavaCallArguments* args, Thread* thread) {\n+                         JavaCallArguments* args, JavaThread* thread) {\n@@ -6035,62 +5368,0 @@\n-extern char** environ;\n-\n-\/\/ Run the specified command in a separate process. Return its exit value,\n-\/\/ or -1 on failure (e.g. can't fork a new process).\n-\/\/ Unlike system(), this function can be called from signal handler. It\n-\/\/ doesn't block SIGINT et al.\n-int os::fork_and_exec(char* cmd, bool use_vfork_if_available) {\n-  const char * argv[4] = {\"sh\", \"-c\", cmd, NULL};\n-\n-  pid_t pid ;\n-\n-  if (use_vfork_if_available) {\n-    pid = vfork();\n-  } else {\n-    pid = fork();\n-  }\n-\n-  if (pid < 0) {\n-    \/\/ fork failed\n-    return -1;\n-\n-  } else if (pid == 0) {\n-    \/\/ child process\n-\n-    execve(\"\/bin\/sh\", (char* const*)argv, environ);\n-\n-    \/\/ execve failed\n-    _exit(-1);\n-\n-  } else  {\n-    \/\/ copied from J2SE ..._waitForProcessExit() in UNIXProcess_md.c; we don't\n-    \/\/ care about the actual exit code, for now.\n-\n-    int status;\n-\n-    \/\/ Wait for the child process to exit.  This returns immediately if\n-    \/\/ the child has already exited. *\/\n-    while (waitpid(pid, &status, 0) < 0) {\n-      switch (errno) {\n-      case ECHILD: return 0;\n-      case EINTR: break;\n-      default: return -1;\n-      }\n-    }\n-\n-    if (WIFEXITED(status)) {\n-      \/\/ The child exited normally; get its exit code.\n-      return WEXITSTATUS(status);\n-    } else if (WIFSIGNALED(status)) {\n-      \/\/ The child exited because of a signal\n-      \/\/ The best value to return is 0x80 + signal number,\n-      \/\/ because that is what all Unix shells do, and because\n-      \/\/ it allows callers to distinguish between process exit and\n-      \/\/ process death by signal.\n-      return 0x80 + WTERMSIG(status);\n-    } else {\n-      \/\/ Unknown exit code; pass it through\n-      return status;\n-    }\n-  }\n-}\n-\n@@ -6219,1 +5490,1 @@\n-\/\/    +------------------------+ JavaThread::stack_reserved_zone_base()\n+\/\/    +------------------------+ StackOverflow::stack_reserved_zone_base()\n@@ -6576,1 +5847,1 @@\n-    wait(NULL);\n+    ::wait(NULL);\n@@ -6853,1 +6124,1 @@\n-      GrowableArray<PersistentResourceDesc>(0, true\/*C_heap*\/);\n+      GrowableArray<PersistentResourceDesc>(0, mtInternal);\n@@ -6960,1 +6231,1 @@\n-  objArrayOop msgsObj = oopFactory::new_objArray(SystemDictionary::String_klass(), failures->length(), CHECK_NH);\n+  objArrayOop msgsObj = oopFactory::new_objArray(vmClasses::String_klass(), failures->length(), CHECK_NH);\n@@ -7072,86 +6343,18 @@\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/ Unit tests \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-#ifndef PRODUCT\n-\n-class TestReserveMemorySpecial : AllStatic {\n- public:\n-  static void small_page_write(void* addr, size_t size) {\n-    size_t page_size = os::vm_page_size();\n-\n-    char* end = (char*)addr + size;\n-    for (char* p = (char*)addr; p < end; p += page_size) {\n-      *p = 1;\n-    }\n-  }\n-\n-  static void test_reserve_memory_special_huge_tlbfs_only(size_t size) {\n-    if (!UseHugeTLBFS) {\n-      return;\n-    }\n-\n-    char* addr = os::Linux::reserve_memory_special_huge_tlbfs_only(size, NULL, false);\n-\n-    if (addr != NULL) {\n-      small_page_write(addr, size);\n-\n-      os::Linux::release_memory_special_huge_tlbfs(addr, size);\n-    }\n-  }\n-\n-  static void test_reserve_memory_special_huge_tlbfs_only() {\n-    if (!UseHugeTLBFS) {\n-      return;\n-    }\n-\n-    size_t lp = os::large_page_size();\n-\n-    for (size_t size = lp; size <= lp * 10; size += lp) {\n-      test_reserve_memory_special_huge_tlbfs_only(size);\n-    }\n-  }\n-\n-  static void test_reserve_memory_special_huge_tlbfs_mixed() {\n-    size_t lp = os::large_page_size();\n-    size_t ag = os::vm_allocation_granularity();\n-\n-    \/\/ sizes to test\n-    const size_t sizes[] = {\n-      lp, lp + ag, lp + lp \/ 2, lp * 2,\n-      lp * 2 + ag, lp * 2 - ag, lp * 2 + lp \/ 2,\n-      lp * 10, lp * 10 + lp \/ 2\n-    };\n-    const int num_sizes = sizeof(sizes) \/ sizeof(size_t);\n-\n-    \/\/ For each size\/alignment combination, we test three scenarios:\n-    \/\/ 1) with req_addr == NULL\n-    \/\/ 2) with a non-null req_addr at which we expect to successfully allocate\n-    \/\/ 3) with a non-null req_addr which contains a pre-existing mapping, at which we\n-    \/\/    expect the allocation to either fail or to ignore req_addr\n-\n-    \/\/ Pre-allocate two areas; they shall be as large as the largest allocation\n-    \/\/  and aligned to the largest alignment we will be testing.\n-    const size_t mapping_size = sizes[num_sizes - 1] * 2;\n-    char* const mapping1 = (char*) ::mmap(NULL, mapping_size,\n-      PROT_NONE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_NORESERVE,\n-      -1, 0);\n-    assert(mapping1 != MAP_FAILED, \"should work\");\n-\n-    char* const mapping2 = (char*) ::mmap(NULL, mapping_size,\n-      PROT_NONE, MAP_PRIVATE|MAP_ANONYMOUS|MAP_NORESERVE,\n-      -1, 0);\n-    assert(mapping2 != MAP_FAILED, \"should work\");\n-\n-    \/\/ Unmap the first mapping, but leave the second mapping intact: the first\n-    \/\/ mapping will serve as a value for a \"good\" req_addr (case 2). The second\n-    \/\/ mapping, still intact, as \"bad\" req_addr (case 3).\n-    ::munmap(mapping1, mapping_size);\n-\n-    \/\/ Case 1\n-    for (int i = 0; i < num_sizes; i++) {\n-      const size_t size = sizes[i];\n-      for (size_t alignment = ag; is_aligned(size, alignment); alignment *= 2) {\n-        char* p = os::Linux::reserve_memory_special_huge_tlbfs_mixed(size, alignment, NULL, false);\n-        if (p != NULL) {\n-          assert(is_aligned(p, alignment), \"must be\");\n-          small_page_write(p, size);\n-          os::Linux::release_memory_special_huge_tlbfs(p, size);\n+void os::print_memory_mappings(char* addr, size_t bytes, outputStream* st) {\n+  unsigned long long start = (unsigned long long)addr;\n+  unsigned long long end = start + bytes;\n+  FILE* f = ::fopen(\"\/proc\/self\/maps\", \"r\");\n+  int num_found = 0;\n+  if (f != NULL) {\n+    st->print(\"Range [%llx-%llx) contains: \", start, end);\n+    char line[512];\n+    while(fgets(line, sizeof(line), f) == line) {\n+      unsigned long long a1 = 0;\n+      unsigned long long a2 = 0;\n+      if (::sscanf(line, \"%llx-%llx\", &a1, &a2) == 2) {\n+        \/\/ Lets print out every range which touches ours.\n+        if ((a1 >= start && a1 < end) || \/\/ left leg in\n+            (a2 >= start && a2 < end) || \/\/ right leg in\n+            (a1 < start && a2 >= end)) { \/\/ superimposition\n+          num_found ++;\n+          st->print(\"%s\", line); \/\/ line includes \\n\n@@ -7161,13 +6364,3 @@\n-\n-    \/\/ Case 2\n-    for (int i = 0; i < num_sizes; i++) {\n-      const size_t size = sizes[i];\n-      for (size_t alignment = ag; is_aligned(size, alignment); alignment *= 2) {\n-        char* const req_addr = align_up(mapping1, alignment);\n-        char* p = os::Linux::reserve_memory_special_huge_tlbfs_mixed(size, alignment, req_addr, false);\n-        if (p != NULL) {\n-          assert(p == req_addr, \"must be\");\n-          small_page_write(p, size);\n-          os::Linux::release_memory_special_huge_tlbfs(p, size);\n-        }\n-      }\n+    ::fclose(f);\n+    if (num_found == 0) {\n+      st->print(\"nothing.\");\n@@ -7175,57 +6368,1 @@\n-\n-    \/\/ Case 3\n-    for (int i = 0; i < num_sizes; i++) {\n-      const size_t size = sizes[i];\n-      for (size_t alignment = ag; is_aligned(size, alignment); alignment *= 2) {\n-        char* const req_addr = align_up(mapping2, alignment);\n-        char* p = os::Linux::reserve_memory_special_huge_tlbfs_mixed(size, alignment, req_addr, false);\n-        \/\/ as the area around req_addr contains already existing mappings, the API should always\n-        \/\/ return NULL (as per contract, it cannot return another address)\n-        assert(p == NULL, \"must be\");\n-      }\n-    }\n-\n-    ::munmap(mapping2, mapping_size);\n-\n-  }\n-\n-  static void test_reserve_memory_special_huge_tlbfs() {\n-    if (!UseHugeTLBFS) {\n-      return;\n-    }\n-\n-    test_reserve_memory_special_huge_tlbfs_only();\n-    test_reserve_memory_special_huge_tlbfs_mixed();\n-  }\n-\n-  static void test_reserve_memory_special_shm(size_t size, size_t alignment) {\n-    if (!UseSHM) {\n-      return;\n-    }\n-\n-    char* addr = os::Linux::reserve_memory_special_shm(size, alignment, NULL, false);\n-\n-    if (addr != NULL) {\n-      assert(is_aligned(addr, alignment), \"Check\");\n-      assert(is_aligned(addr, os::large_page_size()), \"Check\");\n-\n-      small_page_write(addr, size);\n-\n-      os::Linux::release_memory_special_shm(addr, size);\n-    }\n-  }\n-\n-  static void test_reserve_memory_special_shm() {\n-    size_t lp = os::large_page_size();\n-    size_t ag = os::vm_allocation_granularity();\n-\n-    for (size_t size = ag; size < lp * 3; size += ag) {\n-      for (size_t alignment = ag; is_aligned(size, alignment); alignment *= 2) {\n-        test_reserve_memory_special_shm(size, alignment);\n-      }\n-    }\n-  }\n-\n-  static void test() {\n-    test_reserve_memory_special_huge_tlbfs();\n-    test_reserve_memory_special_shm();\n+    st->cr();\n@@ -7233,6 +6370,0 @@\n-};\n-\n-void TestReserveMemorySpecial_test() {\n-  TestReserveMemorySpecial::test();\n-\n-#endif\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":810,"deletions":1679,"binary":false,"changes":2489,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2017, 2020, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Azul Systems, Inc. All rights reserved.\n@@ -35,0 +35,1 @@\n+  friend class CgroupSubsystem;\n@@ -39,6 +40,0 @@\n-  static bool libjsig_is_loaded;        \/\/ libjsig that interposes sigaction(),\n-                                        \/\/ __sigaction(), signal() is loaded\n-  static struct sigaction *(*get_signal_action)(int);\n-\n-  static void check_signal_handler(int sig);\n-\n@@ -51,1 +46,1 @@\n-  static const char *_glibc_version;\n+  static const char *_libc_version;\n@@ -59,0 +54,2 @@\n+  static size_t _default_large_page_size;\n+\n@@ -76,1 +73,1 @@\n-  static void set_glibc_version(const char *s)      { _glibc_version = s; }\n+  static void set_libc_version(const char *s)       { _libc_version = s; }\n@@ -84,2 +81,3 @@\n-  static size_t find_large_page_size();\n-  static size_t setup_large_page_size();\n+  static size_t default_large_page_size();\n+  static size_t scan_default_large_page_size();\n+  static os::PageSizes scan_multiple_page_support();\n@@ -90,0 +88,3 @@\n+  static bool shm_hugetlbfs_sanity_check(bool warn, size_t page_size);\n+\n+  static int hugetlbfs_page_size_flag(size_t page_size);\n@@ -92,3 +93,2 @@\n-  static char* reserve_memory_special_huge_tlbfs(size_t bytes, size_t alignment, char* req_addr, bool exec);\n-  static char* reserve_memory_special_huge_tlbfs_only(size_t bytes, char* req_addr, bool exec);\n-  static char* reserve_memory_special_huge_tlbfs_mixed(size_t bytes, size_t alignment, char* req_addr, bool exec);\n+  static char* reserve_memory_special_huge_tlbfs(size_t bytes, size_t alignment, size_t page_size, char* req_addr, bool exec);\n+  static bool commit_memory_special(size_t bytes, size_t page_size, char* req_addr, bool exec);\n@@ -100,2 +100,3 @@\n-  static void print_full_memory_info(outputStream* st);\n-  static void print_container_info(outputStream* st);\n+  static void print_process_memory_info(outputStream* st);\n+  static void print_system_memory_info(outputStream* st);\n+  static bool print_container_info(outputStream* st);\n@@ -106,1 +107,1 @@\n-  static void print_ld_preload_file(outputStream* st);\n+  static bool print_ld_preload_file(outputStream* st);\n@@ -131,1 +132,0 @@\n-  static void hotspot_sigmask(Thread* thread);\n@@ -139,2 +139,0 @@\n-  static address   ucontext_get_pc(const ucontext_t* uc);\n-  static void ucontext_set_pc(ucontext_t* uc, address pc);\n@@ -144,28 +142,1 @@\n-  \/\/ For Analyzer Forte AsyncGetCallTrace profiling support:\n-  \/\/\n-  \/\/ This interface should be declared in os_linux_i486.hpp, but\n-  \/\/ that file provides extensions to the os class and not the\n-  \/\/ Linux class.\n-  static ExtendedPC fetch_frame_from_ucontext(Thread* thread, const ucontext_t* uc,\n-                                              intptr_t** ret_sp, intptr_t** ret_fp);\n-\n-  static bool get_frame_at_stack_banging_point(JavaThread* thread, ucontext_t* uc, frame* fr);\n-\n-  \/\/ This boolean allows users to forward their own non-matching signals\n-  \/\/ to JVM_handle_linux_signal, harmlessly.\n-  static bool signal_handlers_are_installed;\n-\n-  static int get_our_sigflags(int);\n-  static void set_our_sigflags(int, int);\n-  static void signal_sets_init();\n-  static void install_signal_handlers();\n-  static void set_signal_handler(int, bool);\n-\n-  static sigset_t* unblocked_signals();\n-  static sigset_t* vm_signals();\n-\n-  \/\/ For signal-chaining\n-  static struct sigaction *get_chained_signal_action(int sig);\n-  static bool chained_handler(int sig, siginfo_t* siginfo, void* context);\n-\n-  static const char *glibc_version()          { return _glibc_version; }\n+  static const char *libc_version()           { return _libc_version; }\n@@ -210,0 +181,4 @@\n+  \/\/ Determine if the vmid is the parent pid for a child in a PID namespace.\n+  \/\/ Return the namespace pid if so, otherwise -1.\n+  static int get_namespace_pid(int vmid);\n+\n@@ -220,0 +195,1 @@\n+  typedef int (*numa_node_to_cpus_v2_func_t)(int node, void *mask);\n@@ -229,1 +205,1 @@\n-\n+  typedef void (*numa_set_preferred_func_t)(int node);\n@@ -236,0 +212,1 @@\n+  static numa_node_to_cpus_v2_func_t _numa_node_to_cpus_v2;\n@@ -248,0 +225,1 @@\n+  static numa_set_preferred_func_t _numa_set_preferred;\n@@ -256,0 +234,1 @@\n+  static void set_numa_node_to_cpus_v2(numa_node_to_cpus_v2_func_t func) { _numa_node_to_cpus_v2 = func; }\n@@ -268,0 +247,1 @@\n+  static void set_numa_set_preferred(numa_set_preferred_func_t func) { _numa_set_preferred = func; }\n@@ -282,0 +262,34 @@\n+#ifdef __GLIBC__\n+  struct glibc_mallinfo {\n+    int arena;\n+    int ordblks;\n+    int smblks;\n+    int hblks;\n+    int hblkhd;\n+    int usmblks;\n+    int fsmblks;\n+    int uordblks;\n+    int fordblks;\n+    int keepcost;\n+  };\n+\n+  struct glibc_mallinfo2 {\n+    size_t arena;\n+    size_t ordblks;\n+    size_t smblks;\n+    size_t hblks;\n+    size_t hblkhd;\n+    size_t usmblks;\n+    size_t fsmblks;\n+    size_t uordblks;\n+    size_t fordblks;\n+    size_t keepcost;\n+  };\n+\n+  typedef struct glibc_mallinfo (*mallinfo_func_t)(void);\n+  typedef struct glibc_mallinfo2 (*mallinfo2_func_t)(void);\n+\n+  static mallinfo_func_t _mallinfo;\n+  static mallinfo2_func_t _mallinfo2;\n+#endif\n+\n@@ -284,3 +298,1 @@\n-  static int numa_node_to_cpus(int node, unsigned long *buffer, int bufferlen) {\n-    return _numa_node_to_cpus != NULL ? _numa_node_to_cpus(node, buffer, bufferlen) : -1;\n-  }\n+  static int numa_node_to_cpus(int node, unsigned long *buffer, int bufferlen);\n@@ -325,0 +337,5 @@\n+  static void numa_set_preferred(int node) {\n+    if (_numa_set_preferred != NULL) {\n+      _numa_set_preferred(node);\n+    }\n+  }\n@@ -379,1 +396,0 @@\n-    struct bitmask* bmp = NULL;\n@@ -383,2 +399,1 @@\n-    if (_numa_get_membind != NULL && _numa_max_node != NULL && _numa_bitmask_isbitset != NULL) {\n-      bmp = _numa_get_membind();\n+    if (_numa_membind_bitmask != NULL && _numa_max_node != NULL && _numa_bitmask_isbitset != NULL) {\n@@ -391,1 +406,1 @@\n-      if (_numa_bitmask_isbitset(bmp, node)) {\n+      if (_numa_bitmask_isbitset(_numa_membind_bitmask, node)) {\n@@ -402,0 +417,4 @@\n+\n+  static const GrowableArray<int>* numa_nindex_to_node() {\n+    return _nindex_to_node;\n+  }\n","filename":"src\/hotspot\/os\/linux\/os_linux.hpp","additions":76,"deletions":57,"binary":false,"changes":133,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,1 @@\n-#if defined(AIX) || defined(SOLARIS)\n+#if defined(AIX)\n@@ -90,3 +90,0 @@\n-#ifdef SOLARIS\n-#define ASYNC_SIGNAL     SIGJVM2           \/* Event-based suspend\/resume support *\/\n-#endif \/\/ SOLARIS\n@@ -101,3 +98,0 @@\n-\/* With 1.4.1 libjsig added versioning: used in os_solaris.cpp and jsig.c *\/\n-#define JSIG_VERSION_1_4_1   0x30140100\n-\n","filename":"src\/hotspot\/os\/posix\/include\/jvm_md.h","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,1448 @@\n+\/*\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021 SAP SE. All rights reserved.\n+ * Copyright (c) 2020, 2021, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"jvm_io.h\"\n+#include \"classfile\/vmSymbols.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"memory\/allocation.inline.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n+\/\/#include \"os_linux.inline.hpp\"\n+#include \"perfMemory_linux.hpp\"\n+#include \"os_posix.inline.hpp\"\n+#include \"runtime\/handles.inline.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"runtime\/perfMemory.hpp\"\n+#include \"services\/memTracker.hpp\"\n+#include \"utilities\/exceptions.hpp\"\n+\n+\/\/ put OS-includes here\n+# include <sys\/types.h>\n+# include <sys\/mman.h>\n+# include <errno.h>\n+# include <stdio.h>\n+# include <unistd.h>\n+# include <sys\/stat.h>\n+# include <signal.h>\n+# include <pwd.h>\n+\n+static char* backing_store_file_name = NULL;  \/\/ name of the backing store\n+                                              \/\/ file, if successfully created.\n+static int checkpoint_fd = -1;\n+\n+\/\/ Standard Memory Implementation Details\n+\n+\/\/ create the PerfData memory region in standard memory.\n+\/\/\n+static char* create_standard_memory(size_t size) {\n+\n+  \/\/ allocate an aligned chuck of memory\n+  char* mapAddress = os::reserve_memory(size);\n+\n+  if (mapAddress == NULL) {\n+    return NULL;\n+  }\n+\n+  \/\/ commit memory\n+  if (!os::commit_memory(mapAddress, size, !ExecMem)) {\n+    if (PrintMiscellaneous && Verbose) {\n+      warning(\"Could not commit PerfData memory\\n\");\n+    }\n+    os::release_memory(mapAddress, size);\n+    return NULL;\n+  }\n+\n+  return mapAddress;\n+}\n+\n+\/\/ delete the PerfData memory region\n+\/\/\n+static void delete_standard_memory(char* addr, size_t size) {\n+\n+  \/\/ there are no persistent external resources to cleanup for standard\n+  \/\/ memory. since DestroyJavaVM does not support unloading of the JVM,\n+  \/\/ cleanup of the memory resource is not performed. The memory will be\n+  \/\/ reclaimed by the OS upon termination of the process.\n+  \/\/\n+  return;\n+}\n+\n+\/\/ save the specified memory region to the given file\n+\/\/\n+\/\/ Note: this function might be called from signal handler (by os::abort()),\n+\/\/ don't allocate heap memory.\n+\/\/\n+static void save_memory_to_file(char* addr, size_t size) {\n+\n+  const char* destfile = PerfMemory::get_perfdata_file_path();\n+  assert(destfile[0] != '\\0', \"invalid PerfData file path\");\n+\n+  int result;\n+\n+  RESTARTABLE(os::open(destfile, O_CREAT|O_WRONLY|O_TRUNC, S_IRUSR|S_IWUSR),\n+              result);\n+  if (result == OS_ERR) {\n+    if (PrintMiscellaneous && Verbose) {\n+      warning(\"Could not create Perfdata save file: %s: %s\\n\",\n+              destfile, os::strerror(errno));\n+    }\n+  } else {\n+    int fd = result;\n+\n+    for (size_t remaining = size; remaining > 0;) {\n+\n+      RESTARTABLE(::write(fd, addr, remaining), result);\n+      if (result == OS_ERR) {\n+        if (PrintMiscellaneous && Verbose) {\n+          warning(\"Could not write Perfdata save file: %s: %s\\n\",\n+                  destfile, os::strerror(errno));\n+        }\n+        break;\n+      }\n+\n+      remaining -= (size_t)result;\n+      addr += result;\n+    }\n+\n+    result = ::close(fd);\n+    if (PrintMiscellaneous && Verbose) {\n+      if (result == OS_ERR) {\n+        warning(\"Could not close %s: %s\\n\", destfile, os::strerror(errno));\n+      }\n+    }\n+  }\n+  FREE_C_HEAP_ARRAY(char, destfile);\n+}\n+\n+\n+\/\/ Shared Memory Implementation Details\n+\n+\/\/ Note: the Posix shared memory implementation uses the mmap\n+\/\/ interface with a backing store file to implement named shared memory.\n+\/\/ Using the file system as the name space for shared memory allows a\n+\/\/ common name space to be supported across a variety of platforms. It\n+\/\/ also provides a name space that Java applications can deal with through\n+\/\/ simple file apis.\n+\/\/\n+\n+\/\/ return the user specific temporary directory name.\n+\/\/ the caller is expected to free the allocated memory.\n+\/\/\n+#define TMP_BUFFER_LEN (4+22)\n+static char* get_user_tmp_dir(const char* user, int vmid, int nspid) {\n+  char* tmpdir = (char *)os::get_temp_directory();\n+#if defined(LINUX)\n+  \/\/ On linux, if containerized process, get dirname of\n+  \/\/ \/proc\/{vmid}\/root\/tmp\/{PERFDATA_NAME_user}\n+  \/\/ otherwise \/tmp\/{PERFDATA_NAME_user}\n+  char buffer[TMP_BUFFER_LEN];\n+  assert(strlen(tmpdir) == 4, \"No longer using \/tmp - update buffer size\");\n+\n+  if (nspid != -1) {\n+    jio_snprintf(buffer, TMP_BUFFER_LEN, \"\/proc\/%d\/root%s\", vmid, tmpdir);\n+    tmpdir = buffer;\n+  }\n+#endif\n+  const char* perfdir = PERFDATA_NAME;\n+  size_t nbytes = strlen(tmpdir) + strlen(perfdir) + strlen(user) + 3;\n+  char* dirname = NEW_C_HEAP_ARRAY(char, nbytes, mtInternal);\n+\n+  \/\/ construct the path name to user specific tmp directory\n+  snprintf(dirname, nbytes, \"%s\/%s_%s\", tmpdir, perfdir, user);\n+\n+  return dirname;\n+}\n+\n+\/\/ convert the given file name into a process id. if the file\n+\/\/ does not meet the file naming constraints, return 0.\n+\/\/\n+static pid_t filename_to_pid(const char* filename) {\n+\n+  \/\/ a filename that doesn't begin with a digit is not a\n+  \/\/ candidate for conversion.\n+  \/\/\n+  if (!isdigit(*filename)) {\n+    return 0;\n+  }\n+\n+  \/\/ check if file name can be converted to an integer without\n+  \/\/ any leftover characters.\n+  \/\/\n+  char* remainder = NULL;\n+  errno = 0;\n+  pid_t pid = (pid_t)strtol(filename, &remainder, 10);\n+\n+  if (errno != 0) {\n+    return 0;\n+  }\n+\n+  \/\/ check for left over characters. If any, then the filename is\n+  \/\/ not a candidate for conversion.\n+  \/\/\n+  if (remainder != NULL && *remainder != '\\0') {\n+    return 0;\n+  }\n+\n+  \/\/ successful conversion, return the pid\n+  return pid;\n+}\n+\n+\n+\/\/ Check if the given statbuf is considered a secure directory for\n+\/\/ the backing store files. Returns true if the directory is considered\n+\/\/ a secure location. Returns false if the statbuf is a symbolic link or\n+\/\/ if an error occurred.\n+\/\/\n+static bool is_statbuf_secure(struct stat *statp) {\n+  if (S_ISLNK(statp->st_mode) || !S_ISDIR(statp->st_mode)) {\n+    \/\/ The path represents a link or some non-directory file type,\n+    \/\/ which is not what we expected. Declare it insecure.\n+    \/\/\n+    return false;\n+  }\n+  \/\/ We have an existing directory, check if the permissions are safe.\n+  \/\/\n+  if ((statp->st_mode & (S_IWGRP|S_IWOTH)) != 0) {\n+    \/\/ The directory is open for writing and could be subjected\n+    \/\/ to a symlink or a hard link attack. Declare it insecure.\n+    \/\/\n+    return false;\n+  }\n+  \/\/ If user is not root then see if the uid of the directory matches the effective uid of the process.\n+  uid_t euid = geteuid();\n+  if ((euid != 0) && (statp->st_uid != euid)) {\n+    \/\/ The directory was not created by this user, declare it insecure.\n+    \/\/\n+    return false;\n+  }\n+  return true;\n+}\n+\n+\n+\/\/ Check if the given path is considered a secure directory for\n+\/\/ the backing store files. Returns true if the directory exists\n+\/\/ and is considered a secure location. Returns false if the path\n+\/\/ is a symbolic link or if an error occurred.\n+\/\/\n+static bool is_directory_secure(const char* path) {\n+  struct stat statbuf;\n+  int result = 0;\n+\n+  RESTARTABLE(::lstat(path, &statbuf), result);\n+  if (result == OS_ERR) {\n+    return false;\n+  }\n+\n+  \/\/ The path exists, see if it is secure.\n+  return is_statbuf_secure(&statbuf);\n+}\n+\n+\n+\/\/ Check if the given directory file descriptor is considered a secure\n+\/\/ directory for the backing store files. Returns true if the directory\n+\/\/ exists and is considered a secure location. Returns false if the path\n+\/\/ is a symbolic link or if an error occurred.\n+\/\/\n+static bool is_dirfd_secure(int dir_fd) {\n+  struct stat statbuf;\n+  int result = 0;\n+\n+  RESTARTABLE(::fstat(dir_fd, &statbuf), result);\n+  if (result == OS_ERR) {\n+    return false;\n+  }\n+\n+  \/\/ The path exists, now check its mode.\n+  return is_statbuf_secure(&statbuf);\n+}\n+\n+\n+\/\/ Check to make sure fd1 and fd2 are referencing the same file system object.\n+\/\/\n+static bool is_same_fsobject(int fd1, int fd2) {\n+  struct stat statbuf1;\n+  struct stat statbuf2;\n+  int result = 0;\n+\n+  RESTARTABLE(::fstat(fd1, &statbuf1), result);\n+  if (result == OS_ERR) {\n+    return false;\n+  }\n+  RESTARTABLE(::fstat(fd2, &statbuf2), result);\n+  if (result == OS_ERR) {\n+    return false;\n+  }\n+\n+  if ((statbuf1.st_ino == statbuf2.st_ino) &&\n+      (statbuf1.st_dev == statbuf2.st_dev)) {\n+    return true;\n+  } else {\n+    return false;\n+  }\n+}\n+\n+\n+\/\/ Open the directory of the given path and validate it.\n+\/\/ Return a DIR * of the open directory.\n+\/\/\n+static DIR *open_directory_secure(const char* dirname) {\n+  \/\/ Open the directory using open() so that it can be verified\n+  \/\/ to be secure by calling is_dirfd_secure(), opendir() and then check\n+  \/\/ to see if they are the same file system object.  This method does not\n+  \/\/ introduce a window of opportunity for the directory to be attacked that\n+  \/\/ calling opendir() and is_directory_secure() does.\n+  int result;\n+  DIR *dirp = NULL;\n+  RESTARTABLE(::open(dirname, O_RDONLY|O_NOFOLLOW), result);\n+  if (result == OS_ERR) {\n+    \/\/ Directory doesn't exist or is a symlink, so there is nothing to cleanup.\n+    if (PrintMiscellaneous && Verbose) {\n+      if (errno == ELOOP) {\n+        warning(\"directory %s is a symlink and is not secure\\n\", dirname);\n+      } else {\n+        warning(\"could not open directory %s: %s\\n\", dirname, os::strerror(errno));\n+      }\n+    }\n+    return dirp;\n+  }\n+  int fd = result;\n+\n+  \/\/ Determine if the open directory is secure.\n+  if (!is_dirfd_secure(fd)) {\n+    \/\/ The directory is not a secure directory.\n+    os::close(fd);\n+    return dirp;\n+  }\n+\n+  \/\/ Open the directory.\n+  dirp = ::opendir(dirname);\n+  if (dirp == NULL) {\n+    \/\/ The directory doesn't exist, close fd and return.\n+    os::close(fd);\n+    return dirp;\n+  }\n+\n+  \/\/ Check to make sure fd and dirp are referencing the same file system object.\n+  if (!is_same_fsobject(fd, AIX_ONLY(dirp->dd_fd) NOT_AIX(dirfd(dirp)))) {\n+    \/\/ The directory is not secure.\n+    os::close(fd);\n+    os::closedir(dirp);\n+    dirp = NULL;\n+    return dirp;\n+  }\n+\n+  \/\/ Close initial open now that we know directory is secure\n+  os::close(fd);\n+\n+  return dirp;\n+}\n+\n+\/\/ NOTE: The code below uses fchdir(), open() and unlink() because\n+\/\/ fdopendir(), openat() and unlinkat() are not supported on all\n+\/\/ versions.  Once the support for fdopendir(), openat() and unlinkat()\n+\/\/ is available on all supported versions the code can be changed\n+\/\/ to use these functions.\n+\n+\/\/ Open the directory of the given path, validate it and set the\n+\/\/ current working directory to it.\n+\/\/ Return a DIR * of the open directory and the saved cwd fd.\n+\/\/\n+static DIR *open_directory_secure_cwd(const char* dirname, int *saved_cwd_fd) {\n+\n+  \/\/ Open the directory.\n+  DIR* dirp = open_directory_secure(dirname);\n+  if (dirp == NULL) {\n+    \/\/ Directory doesn't exist or is insecure, so there is nothing to cleanup.\n+    return dirp;\n+  }\n+  int fd = AIX_ONLY(dirp->dd_fd) NOT_AIX(dirfd(dirp));\n+\n+  \/\/ Open a fd to the cwd and save it off.\n+  int result;\n+  RESTARTABLE(::open(\".\", O_RDONLY), result);\n+  if (result == OS_ERR) {\n+    *saved_cwd_fd = -1;\n+  } else {\n+    *saved_cwd_fd = result;\n+  }\n+\n+  \/\/ Set the current directory to dirname by using the fd of the directory and\n+  \/\/ handle errors, otherwise shared memory files will be created in cwd.\n+  result = fchdir(fd);\n+  if (result == OS_ERR) {\n+    if (PrintMiscellaneous && Verbose) {\n+      warning(\"could not change to directory %s\", dirname);\n+    }\n+    if (*saved_cwd_fd != -1) {\n+      ::close(*saved_cwd_fd);\n+      *saved_cwd_fd = -1;\n+    }\n+    \/\/ Close the directory.\n+    os::closedir(dirp);\n+    return NULL;\n+  } else {\n+    return dirp;\n+  }\n+}\n+\n+\/\/ Close the directory and restore the current working directory.\n+\/\/\n+static void close_directory_secure_cwd(DIR* dirp, int saved_cwd_fd) {\n+\n+  int result;\n+  \/\/ If we have a saved cwd change back to it and close the fd.\n+  if (saved_cwd_fd != -1) {\n+    result = fchdir(saved_cwd_fd);\n+    ::close(saved_cwd_fd);\n+  }\n+\n+  \/\/ Close the directory.\n+  os::closedir(dirp);\n+}\n+\n+\/\/ Check if the given file descriptor is considered a secure.\n+\/\/\n+static bool is_file_secure(int fd, const char *filename) {\n+\n+  int result;\n+  struct stat statbuf;\n+\n+  \/\/ Determine if the file is secure.\n+  RESTARTABLE(::fstat(fd, &statbuf), result);\n+  if (result == OS_ERR) {\n+    if (PrintMiscellaneous && Verbose) {\n+      warning(\"fstat failed on %s: %s\\n\", filename, os::strerror(errno));\n+    }\n+    return false;\n+  }\n+  if (statbuf.st_nlink > 1) {\n+    \/\/ A file with multiple links is not expected.\n+    if (PrintMiscellaneous && Verbose) {\n+      warning(\"file %s has multiple links\\n\", filename);\n+    }\n+    return false;\n+  }\n+  return true;\n+}\n+\n+\n+\/\/ return the user name for the given user id\n+\/\/\n+\/\/ the caller is expected to free the allocated memory.\n+\/\/\n+static char* get_user_name(uid_t uid) {\n+\n+  struct passwd pwent;\n+\n+  \/\/ Determine the max pwbuf size from sysconf, and hardcode\n+  \/\/ a default if this not available through sysconf.\n+  long bufsize = sysconf(_SC_GETPW_R_SIZE_MAX);\n+  if (bufsize == -1)\n+    bufsize = 1024;\n+\n+  char* pwbuf = NEW_C_HEAP_ARRAY(char, bufsize, mtInternal);\n+\n+  struct passwd* p = NULL;\n+  int result = getpwuid_r(uid, &pwent, pwbuf, (size_t)bufsize, &p);\n+\n+  if (result != 0 || p == NULL || p->pw_name == NULL || *(p->pw_name) == '\\0') {\n+    if (PrintMiscellaneous && Verbose) {\n+      if (result != 0) {\n+        warning(\"Could not retrieve passwd entry: %s\\n\",\n+                os::strerror(result));\n+      }\n+      else if (p == NULL) {\n+        \/\/ this check is added to protect against an observed problem\n+        \/\/ with getpwuid_r() on RedHat 9 where getpwuid_r returns 0,\n+        \/\/ indicating success, but has p == NULL. This was observed when\n+        \/\/ inserting a file descriptor exhaustion fault prior to the call\n+        \/\/ getpwuid_r() call. In this case, error is set to the appropriate\n+        \/\/ error condition, but this is undocumented behavior. This check\n+        \/\/ is safe under any condition, but the use of errno in the output\n+        \/\/ message may result in an erroneous message.\n+        \/\/ Bug Id 89052 was opened with RedHat.\n+        \/\/\n+        warning(\"Could not retrieve passwd entry: %s\\n\",\n+                os::strerror(errno));\n+      }\n+      else {\n+        warning(\"Could not determine user name: %s\\n\",\n+                p->pw_name == NULL ? \"pw_name = NULL\" :\n+                                     \"pw_name zero length\");\n+      }\n+    }\n+    FREE_C_HEAP_ARRAY(char, pwbuf);\n+    return NULL;\n+  }\n+\n+  char* user_name = NEW_C_HEAP_ARRAY(char, strlen(p->pw_name) + 1, mtInternal);\n+  strcpy(user_name, p->pw_name);\n+\n+  FREE_C_HEAP_ARRAY(char, pwbuf);\n+  return user_name;\n+}\n+\n+\/\/ return the name of the user that owns the process identified by vmid.\n+\/\/\n+\/\/ This method uses a slow directory search algorithm to find the backing\n+\/\/ store file for the specified vmid and returns the user name, as determined\n+\/\/ by the user name suffix of the hsperfdata_<username> directory name.\n+\/\/\n+\/\/ the caller is expected to free the allocated memory.\n+\/\/\n+\/\/\n+static char* get_user_name_slow(int vmid, int nspid, TRAPS) {\n+\n+  \/\/ short circuit the directory search if the process doesn't even exist.\n+  if (kill(vmid, 0) == OS_ERR) {\n+    if (errno == ESRCH) {\n+      THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),\n+                  \"Process not found\");\n+    }\n+    else \/* EPERM *\/ {\n+      THROW_MSG_0(vmSymbols::java_io_IOException(), os::strerror(errno));\n+    }\n+  }\n+\n+  \/\/ directory search\n+  char* oldest_user = NULL;\n+  time_t oldest_ctime = 0;\n+  int searchpid;\n+  char* tmpdirname = (char *)os::get_temp_directory();\n+#if defined(LINUX)\n+  char buffer[MAXPATHLEN + 1];\n+  assert(strlen(tmpdirname) == 4, \"No longer using \/tmp - update buffer size\");\n+\n+  \/\/ On Linux, if nspid != -1, look in \/proc\/{vmid}\/root\/tmp for directories\n+  \/\/ containing nspid, otherwise just look for vmid in \/tmp.\n+  if (nspid == -1) {\n+    searchpid = vmid;\n+  } else {\n+    jio_snprintf(buffer, MAXPATHLEN, \"\/proc\/%d\/root%s\", vmid, tmpdirname);\n+    tmpdirname = buffer;\n+    searchpid = nspid;\n+  }\n+#else\n+  searchpid = vmid;\n+#endif\n+\n+  \/\/ open the temp directory\n+  DIR* tmpdirp = os::opendir(tmpdirname);\n+\n+  if (tmpdirp == NULL) {\n+    \/\/ Cannot open the directory to get the user name, return.\n+    return NULL;\n+  }\n+\n+  \/\/ for each entry in the directory that matches the pattern hsperfdata_*,\n+  \/\/ open the directory and check if the file for the given vmid (or nspid) exists.\n+  \/\/ The file with the expected name and the latest creation date is used\n+  \/\/ to determine the user name for the process id.\n+  \/\/\n+  struct dirent* dentry;\n+  errno = 0;\n+  while ((dentry = os::readdir(tmpdirp)) != NULL) {\n+\n+    \/\/ check if the directory entry is a hsperfdata file\n+    if (strncmp(dentry->d_name, PERFDATA_NAME, strlen(PERFDATA_NAME)) != 0) {\n+      continue;\n+    }\n+\n+    char* usrdir_name = NEW_C_HEAP_ARRAY(char,\n+                                         strlen(tmpdirname) + strlen(dentry->d_name) + 2,\n+                                         mtInternal);\n+    strcpy(usrdir_name, tmpdirname);\n+    strcat(usrdir_name, \"\/\");\n+    strcat(usrdir_name, dentry->d_name);\n+\n+    \/\/ open the user directory\n+    DIR* subdirp = open_directory_secure(usrdir_name);\n+\n+    if (subdirp == NULL) {\n+      FREE_C_HEAP_ARRAY(char, usrdir_name);\n+      continue;\n+    }\n+\n+    \/\/ Since we don't create the backing store files in directories\n+    \/\/ pointed to by symbolic links, we also don't follow them when\n+    \/\/ looking for the files. We check for a symbolic link after the\n+    \/\/ call to opendir in order to eliminate a small window where the\n+    \/\/ symlink can be exploited.\n+    \/\/\n+    if (!is_directory_secure(usrdir_name)) {\n+      FREE_C_HEAP_ARRAY(char, usrdir_name);\n+      os::closedir(subdirp);\n+      continue;\n+    }\n+\n+    struct dirent* udentry;\n+    errno = 0;\n+    while ((udentry = os::readdir(subdirp)) != NULL) {\n+\n+      if (filename_to_pid(udentry->d_name) == searchpid) {\n+        struct stat statbuf;\n+        int result;\n+\n+        char* filename = NEW_C_HEAP_ARRAY(char,\n+                                          strlen(usrdir_name) + strlen(udentry->d_name) + 2,\n+                                          mtInternal);\n+\n+        strcpy(filename, usrdir_name);\n+        strcat(filename, \"\/\");\n+        strcat(filename, udentry->d_name);\n+\n+        \/\/ don't follow symbolic links for the file\n+        RESTARTABLE(::lstat(filename, &statbuf), result);\n+        if (result == OS_ERR) {\n+           FREE_C_HEAP_ARRAY(char, filename);\n+           continue;\n+        }\n+\n+        \/\/ skip over files that are not regular files.\n+        if (!S_ISREG(statbuf.st_mode)) {\n+          FREE_C_HEAP_ARRAY(char, filename);\n+          continue;\n+        }\n+\n+        \/\/ compare and save filename with latest creation time\n+        if (statbuf.st_size > 0 && statbuf.st_ctime > oldest_ctime) {\n+\n+          if (statbuf.st_ctime > oldest_ctime) {\n+            char* user = strchr(dentry->d_name, '_') + 1;\n+\n+            FREE_C_HEAP_ARRAY(char, oldest_user);\n+            oldest_user = NEW_C_HEAP_ARRAY(char, strlen(user)+1, mtInternal);\n+\n+            strcpy(oldest_user, user);\n+            oldest_ctime = statbuf.st_ctime;\n+          }\n+        }\n+\n+        FREE_C_HEAP_ARRAY(char, filename);\n+      }\n+    }\n+    os::closedir(subdirp);\n+    FREE_C_HEAP_ARRAY(char, usrdir_name);\n+  }\n+  os::closedir(tmpdirp);\n+\n+  return(oldest_user);\n+}\n+\n+\/\/ return the name of the user that owns the JVM indicated by the given vmid.\n+\/\/\n+static char* get_user_name(int vmid, int *nspid, TRAPS) {\n+  char *result = get_user_name_slow(vmid, *nspid, THREAD);\n+\n+#if defined(LINUX)\n+  \/\/ If we are examining a container process without PID namespaces enabled\n+  \/\/ we need to use \/proc\/{pid}\/root\/tmp to find hsperfdata files.\n+  if (result == NULL) {\n+    result = get_user_name_slow(vmid, vmid, THREAD);\n+    \/\/ Enable nspid logic going forward\n+    if (result != NULL) *nspid = vmid;\n+  }\n+#endif\n+  return result;\n+}\n+\n+\/\/ return the file name of the backing store file for the named\n+\/\/ shared memory region for the given user name and vmid.\n+\/\/\n+\/\/ the caller is expected to free the allocated memory.\n+\/\/\n+static char* get_sharedmem_filename(const char* dirname, int vmid, int nspid) {\n+\n+  int pid = LINUX_ONLY((nspid == -1) ? vmid : nspid) NOT_LINUX(vmid);\n+\n+  \/\/ add 2 for the file separator and a null terminator.\n+  size_t nbytes = strlen(dirname) + UINT_CHARS + 2;\n+\n+  char* name = NEW_C_HEAP_ARRAY(char, nbytes, mtInternal);\n+  snprintf(name, nbytes, \"%s\/%d\", dirname, pid);\n+\n+  return name;\n+}\n+\n+\n+\/\/ remove file\n+\/\/\n+\/\/ this method removes the file specified by the given path\n+\/\/\n+static void remove_file(const char* path) {\n+\n+  int result;\n+\n+  \/\/ if the file is a directory, the following unlink will fail. since\n+  \/\/ we don't expect to find directories in the user temp directory, we\n+  \/\/ won't try to handle this situation. even if accidentially or\n+  \/\/ maliciously planted, the directory's presence won't hurt anything.\n+  \/\/\n+  RESTARTABLE(::unlink(path), result);\n+  if (PrintMiscellaneous && Verbose && result == OS_ERR) {\n+    if (errno != ENOENT) {\n+      warning(\"Could not unlink shared memory backing\"\n+              \" store file %s : %s\\n\", path, os::strerror(errno));\n+    }\n+  }\n+}\n+\n+\n+\/\/ cleanup stale shared memory resources\n+\/\/\n+\/\/ This method attempts to remove all stale shared memory files in\n+\/\/ the named user temporary directory. It scans the named directory\n+\/\/ for files matching the pattern ^$[0-9]*$. For each file found, the\n+\/\/ process id is extracted from the file name and a test is run to\n+\/\/ determine if the process is alive. If the process is not alive,\n+\/\/ any stale file resources are removed.\n+\/\/\n+static void cleanup_sharedmem_resources(const char* dirname) {\n+\n+  int saved_cwd_fd;\n+  \/\/ open the directory and set the current working directory to it\n+  DIR* dirp = open_directory_secure_cwd(dirname, &saved_cwd_fd);\n+  if (dirp == NULL) {\n+    \/\/ directory doesn't exist or is insecure, so there is nothing to cleanup\n+    return;\n+  }\n+\n+  \/\/ for each entry in the directory that matches the expected file\n+  \/\/ name pattern, determine if the file resources are stale and if\n+  \/\/ so, remove the file resources. Note, instrumented HotSpot processes\n+  \/\/ for this user may start and\/or terminate during this search and\n+  \/\/ remove or create new files in this directory. The behavior of this\n+  \/\/ loop under these conditions is dependent upon the implementation of\n+  \/\/ opendir\/readdir.\n+  \/\/\n+  struct dirent* entry;\n+  errno = 0;\n+  while ((entry = os::readdir(dirp)) != NULL) {\n+\n+    pid_t pid = filename_to_pid(entry->d_name);\n+\n+    if (pid == 0) {\n+\n+      if (strcmp(entry->d_name, \".\") != 0 && strcmp(entry->d_name, \"..\") != 0) {\n+        \/\/ attempt to remove all unexpected files, except \".\" and \"..\"\n+        unlink(entry->d_name);\n+      }\n+\n+      errno = 0;\n+      continue;\n+    }\n+\n+    \/\/ we now have a file name that converts to a valid integer\n+    \/\/ that could represent a process id . if this process id\n+    \/\/ matches the current process id or the process is not running,\n+    \/\/ then remove the stale file resources.\n+    \/\/\n+    \/\/ process liveness is detected by sending signal number 0 to\n+    \/\/ the process id (see kill(2)). if kill determines that the\n+    \/\/ process does not exist, then the file resources are removed.\n+    \/\/ if kill determines that that we don't have permission to\n+    \/\/ signal the process, then the file resources are assumed to\n+    \/\/ be stale and are removed because the resources for such a\n+    \/\/ process should be in a different user specific directory.\n+    \/\/\n+    if ((pid == os::current_process_id()) ||\n+        (kill(pid, 0) == OS_ERR && (errno == ESRCH || errno == EPERM))) {\n+        unlink(entry->d_name);\n+    }\n+    errno = 0;\n+  }\n+\n+  \/\/ close the directory and reset the current working directory\n+  close_directory_secure_cwd(dirp, saved_cwd_fd);\n+}\n+\n+\/\/ make the user specific temporary directory. Returns true if\n+\/\/ the directory exists and is secure upon return. Returns false\n+\/\/ if the directory exists but is either a symlink, is otherwise\n+\/\/ insecure, or if an error occurred.\n+\/\/\n+static bool make_user_tmp_dir(const char* dirname) {\n+\n+  \/\/ create the directory with 0755 permissions. note that the directory\n+  \/\/ will be owned by euid::egid, which may not be the same as uid::gid.\n+  \/\/\n+  if (mkdir(dirname, S_IRWXU|S_IRGRP|S_IXGRP|S_IROTH|S_IXOTH) == OS_ERR) {\n+    if (errno == EEXIST) {\n+      \/\/ The directory already exists and was probably created by another\n+      \/\/ JVM instance. However, this could also be the result of a\n+      \/\/ deliberate symlink. Verify that the existing directory is safe.\n+      \/\/\n+      if (!is_directory_secure(dirname)) {\n+        \/\/ directory is not secure\n+        if (PrintMiscellaneous && Verbose) {\n+          warning(\"%s directory is insecure\\n\", dirname);\n+        }\n+        return false;\n+      }\n+    }\n+    else {\n+      \/\/ we encountered some other failure while attempting\n+      \/\/ to create the directory\n+      \/\/\n+      if (PrintMiscellaneous && Verbose) {\n+        warning(\"could not create directory %s: %s\\n\",\n+                dirname, os::strerror(errno));\n+      }\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n+\/\/ create the shared memory file resources\n+\/\/\n+\/\/ This method creates the shared memory file with the given size\n+\/\/ This method also creates the user specific temporary directory, if\n+\/\/ it does not yet exist.\n+\/\/\n+static int create_sharedmem_resources(const char* dirname, const char* filename, size_t size) {\n+\n+  \/\/ make the user temporary directory\n+  if (!make_user_tmp_dir(dirname)) {\n+    \/\/ could not make\/find the directory or the found directory\n+    \/\/ was not secure\n+    return -1;\n+  }\n+\n+  int saved_cwd_fd;\n+  \/\/ open the directory and set the current working directory to it\n+  DIR* dirp = open_directory_secure_cwd(dirname, &saved_cwd_fd);\n+  if (dirp == NULL) {\n+    \/\/ Directory doesn't exist or is insecure, so cannot create shared\n+    \/\/ memory file.\n+    return -1;\n+  }\n+\n+  \/\/ Open the filename in the current directory.\n+  \/\/ Cannot use O_TRUNC here; truncation of an existing file has to happen\n+  \/\/ after the is_file_secure() check below.\n+  int result;\n+  RESTARTABLE(os::open(filename, O_RDWR|O_CREAT|O_NOFOLLOW, S_IRUSR|S_IWUSR), result);\n+  if (result == OS_ERR) {\n+    if (PrintMiscellaneous && Verbose) {\n+      if (errno == ELOOP) {\n+        warning(\"file %s is a symlink and is not secure\\n\", filename);\n+      } else {\n+        warning(\"could not create file %s: %s\\n\", filename, os::strerror(errno));\n+      }\n+    }\n+    \/\/ close the directory and reset the current working directory\n+    close_directory_secure_cwd(dirp, saved_cwd_fd);\n+\n+    return -1;\n+  }\n+  \/\/ close the directory and reset the current working directory\n+  close_directory_secure_cwd(dirp, saved_cwd_fd);\n+\n+  \/\/ save the file descriptor\n+  int fd = result;\n+\n+  \/\/ check to see if the file is secure\n+  if (!is_file_secure(fd, filename)) {\n+    ::close(fd);\n+    return -1;\n+  }\n+\n+  \/\/ truncate the file to get rid of any existing data\n+  RESTARTABLE(::ftruncate(fd, (off_t)0), result);\n+  if (result == OS_ERR) {\n+    if (PrintMiscellaneous && Verbose) {\n+      warning(\"could not truncate shared memory file: %s\\n\", os::strerror(errno));\n+    }\n+    ::close(fd);\n+    return -1;\n+  }\n+  \/\/ set the file size\n+  RESTARTABLE(::ftruncate(fd, (off_t)size), result);\n+  if (result == OS_ERR) {\n+    if (PrintMiscellaneous && Verbose) {\n+      warning(\"could not set shared memory file size: %s\\n\", os::strerror(errno));\n+    }\n+    ::close(fd);\n+    return -1;\n+  }\n+\n+  \/\/ Verify that we have enough disk space for this file.\n+  \/\/ We'll get random SIGBUS crashes on memory accesses if\n+  \/\/ we don't.\n+  for (size_t seekpos = 0; seekpos < size; seekpos += os::vm_page_size()) {\n+    int zero_int = 0;\n+    result = (int)os::seek_to_file_offset(fd, (jlong)(seekpos));\n+    if (result == -1 ) break;\n+    RESTARTABLE(::write(fd, &zero_int, 1), result);\n+    if (result != 1) {\n+      if (errno == ENOSPC) {\n+        warning(\"Insufficient space for shared memory file:\\n   %s\\nTry using the -Djava.io.tmpdir= option to select an alternate temp location.\\n\", filename);\n+      }\n+      break;\n+    }\n+  }\n+\n+  if (result != -1) {\n+    return fd;\n+  } else {\n+    ::close(fd);\n+    return -1;\n+  }\n+}\n+\n+\/\/ open the shared memory file for the given user and vmid. returns\n+\/\/ the file descriptor for the open file or -1 if the file could not\n+\/\/ be opened.\n+\/\/\n+static int open_sharedmem_file(const char* filename, int oflags, TRAPS) {\n+\n+  \/\/ open the file\n+  int result;\n+  RESTARTABLE(os::open(filename, oflags, 0), result);\n+  if (result == OS_ERR) {\n+    if (errno == ENOENT) {\n+      THROW_MSG_(vmSymbols::java_lang_IllegalArgumentException(),\n+                 \"Process not found\", OS_ERR);\n+    }\n+    else if (errno == EACCES) {\n+      THROW_MSG_(vmSymbols::java_lang_IllegalArgumentException(),\n+                 \"Permission denied\", OS_ERR);\n+    }\n+    else {\n+      THROW_MSG_(vmSymbols::java_io_IOException(),\n+                 os::strerror(errno), OS_ERR);\n+    }\n+  }\n+  int fd = result;\n+\n+  \/\/ check to see if the file is secure\n+  if (!is_file_secure(fd, filename)) {\n+    ::close(fd);\n+    return -1;\n+  }\n+\n+  return fd;\n+}\n+\n+\/\/ create a named shared memory region. returns the address of the\n+\/\/ memory region on success or NULL on failure. A return value of\n+\/\/ NULL will ultimately disable the shared memory feature.\n+\/\/\n+\/\/ The name space for shared memory objects is the file system name space.\n+\/\/\n+\/\/ A monitoring application attaching to a JVM does not need to know\n+\/\/ the file system name of the shared memory object. However, it may\n+\/\/ be convenient for applications to discover the existence of newly\n+\/\/ created and terminating JVMs by watching the file system name space\n+\/\/ for files being created or removed.\n+\/\/\n+static char* mmap_create_shared(size_t size) {\n+\n+  int result;\n+  int fd;\n+  char* mapAddress;\n+\n+  int vmid = os::current_process_id();\n+\n+  char* user_name = get_user_name(geteuid());\n+\n+  if (user_name == NULL)\n+    return NULL;\n+\n+  char* dirname = get_user_tmp_dir(user_name, vmid, -1);\n+  char* filename = get_sharedmem_filename(dirname, vmid, -1);\n+\n+  \/\/ get the short filename\n+  char* short_filename = strrchr(filename, '\/');\n+  if (short_filename == NULL) {\n+    short_filename = filename;\n+  } else {\n+    short_filename++;\n+  }\n+\n+  \/\/ cleanup any stale shared memory files\n+  cleanup_sharedmem_resources(dirname);\n+\n+  assert(((size > 0) && (size % os::vm_page_size() == 0)),\n+         \"unexpected PerfMemory region size\");\n+\n+  fd = create_sharedmem_resources(dirname, short_filename, size);\n+\n+  FREE_C_HEAP_ARRAY(char, user_name);\n+  FREE_C_HEAP_ARRAY(char, dirname);\n+\n+  if (fd == -1) {\n+    FREE_C_HEAP_ARRAY(char, filename);\n+    return NULL;\n+  }\n+\n+  mapAddress = (char*)::mmap((char*)0, size, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);\n+\n+  result = ::close(fd);\n+  assert(result != OS_ERR, \"could not close file\");\n+\n+  if (mapAddress == MAP_FAILED) {\n+    if (PrintMiscellaneous && Verbose) {\n+      warning(\"mmap failed -  %s\\n\", os::strerror(errno));\n+    }\n+    remove_file(filename);\n+    FREE_C_HEAP_ARRAY(char, filename);\n+    return NULL;\n+  }\n+\n+  \/\/ save the file name for use in delete_shared_memory()\n+  backing_store_file_name = filename;\n+\n+  \/\/ clear the shared memory region\n+  (void)::memset((void*) mapAddress, 0, size);\n+\n+  \/\/ it does not go through os api, the operation has to record from here\n+  MemTracker::record_virtual_memory_reserve_and_commit((address)mapAddress, size, CURRENT_PC, mtInternal);\n+\n+  return mapAddress;\n+}\n+\n+\/\/ release a named shared memory region\n+\/\/\n+static void unmap_shared(char* addr, size_t bytes) {\n+#if defined(_AIX)\n+  \/\/ Do not rely on os::reserve_memory\/os::release_memory to use mmap.\n+  \/\/ Use os::reserve_memory\/os::release_memory for PerfDisableSharedMem=1, mmap\/munmap for PerfDisableSharedMem=0\n+  if (::munmap(addr, bytes) == -1) {\n+    warning(\"perfmemory: munmap failed (%d)\\n\", errno);\n+  }\n+#else\n+  os::release_memory(addr, bytes);\n+#endif\n+}\n+\n+\/\/ create the PerfData memory region in shared memory.\n+\/\/\n+static char* create_shared_memory(size_t size) {\n+\n+  \/\/ create the shared memory region.\n+  return mmap_create_shared(size);\n+}\n+\n+\/\/ delete the shared PerfData memory region\n+\/\/\n+static void delete_shared_memory(char* addr, size_t size) {\n+\n+  \/\/ cleanup the persistent shared memory resources. since DestroyJavaVM does\n+  \/\/ not support unloading of the JVM, unmapping of the memory resource is\n+  \/\/ not performed. The memory will be reclaimed by the OS upon termination of\n+  \/\/ the process. The backing store file is deleted from the file system.\n+\n+  assert(!PerfDisableSharedMem, \"shouldn't be here\");\n+\n+  if (backing_store_file_name != NULL) {\n+    remove_file(backing_store_file_name);\n+    \/\/ Don't.. Free heap memory could deadlock os::abort() if it is called\n+    \/\/ from signal handler. OS will reclaim the heap memory.\n+    \/\/ FREE_C_HEAP_ARRAY(char, backing_store_file_name);\n+    backing_store_file_name = NULL;\n+  }\n+}\n+\n+\/\/ return the size of the file for the given file descriptor\n+\/\/ or 0 if it is not a valid size for a shared memory file\n+\/\/\n+static size_t sharedmem_filesize(int fd, TRAPS) {\n+\n+  struct stat statbuf;\n+  int result;\n+\n+  RESTARTABLE(::fstat(fd, &statbuf), result);\n+  if (result == OS_ERR) {\n+    if (PrintMiscellaneous && Verbose) {\n+      warning(\"fstat failed: %s\\n\", os::strerror(errno));\n+    }\n+    THROW_MSG_0(vmSymbols::java_io_IOException(),\n+                \"Could not determine PerfMemory size\");\n+  }\n+\n+  if ((statbuf.st_size == 0) ||\n+     ((size_t)statbuf.st_size % os::vm_page_size() != 0)) {\n+    THROW_MSG_0(vmSymbols::java_io_IOException(),\n+                \"Invalid PerfMemory size\");\n+  }\n+\n+  return (size_t)statbuf.st_size;\n+}\n+\n+\/\/ attach to a named shared memory region.\n+\/\/\n+static void mmap_attach_shared(const char* user, int vmid, PerfMemory::PerfMemoryMode mode, char** addr, size_t* sizep, TRAPS) {\n+\n+  char* mapAddress;\n+  int result;\n+  int fd;\n+  size_t size = 0;\n+  const char* luser = NULL;\n+\n+  int mmap_prot;\n+  int file_flags;\n+\n+  ResourceMark rm;\n+\n+  \/\/ map the high level access mode to the appropriate permission\n+  \/\/ constructs for the file and the shared memory mapping.\n+  if (mode == PerfMemory::PERF_MODE_RO) {\n+    mmap_prot = PROT_READ;\n+    file_flags = O_RDONLY | O_NOFOLLOW;\n+  }\n+  else if (mode == PerfMemory::PERF_MODE_RW) {\n+#ifdef LATER\n+    mmap_prot = PROT_READ | PROT_WRITE;\n+    file_flags = O_RDWR | O_NOFOLLOW;\n+#else\n+    THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),\n+              \"Unsupported access mode\");\n+#endif\n+  }\n+  else {\n+    THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),\n+              \"Illegal access mode\");\n+  }\n+\n+  \/\/ for linux, determine if vmid is for a containerized process\n+  int nspid = LINUX_ONLY(os::Linux::get_namespace_pid(vmid)) NOT_LINUX(-1);\n+\n+  if (user == NULL || strlen(user) == 0) {\n+    luser = get_user_name(vmid, &nspid, CHECK);\n+  }\n+  else {\n+    luser = user;\n+  }\n+\n+  if (luser == NULL) {\n+    THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),\n+              \"Could not map vmid to user Name\");\n+  }\n+\n+  char* dirname = get_user_tmp_dir(luser, vmid, nspid);\n+\n+  \/\/ since we don't follow symbolic links when creating the backing\n+  \/\/ store file, we don't follow them when attaching either.\n+  \/\/\n+  if (!is_directory_secure(dirname)) {\n+    FREE_C_HEAP_ARRAY(char, dirname);\n+    if (luser != user) {\n+      FREE_C_HEAP_ARRAY(char, luser);\n+    }\n+    THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),\n+              \"Process not found\");\n+  }\n+\n+  char* filename = get_sharedmem_filename(dirname, vmid, nspid);\n+\n+  \/\/ copy heap memory to resource memory. the open_sharedmem_file\n+  \/\/ method below need to use the filename, but could throw an\n+  \/\/ exception. using a resource array prevents the leak that\n+  \/\/ would otherwise occur.\n+  char* rfilename = NEW_RESOURCE_ARRAY(char, strlen(filename) + 1);\n+  strcpy(rfilename, filename);\n+\n+  \/\/ free the c heap resources that are no longer needed\n+  if (luser != user) FREE_C_HEAP_ARRAY(char, luser);\n+  FREE_C_HEAP_ARRAY(char, dirname);\n+  FREE_C_HEAP_ARRAY(char, filename);\n+\n+  \/\/ open the shared memory file for the give vmid\n+  fd = open_sharedmem_file(rfilename, file_flags, THREAD);\n+\n+  if (fd == OS_ERR) {\n+    return;\n+  }\n+\n+  if (HAS_PENDING_EXCEPTION) {\n+    ::close(fd);\n+    return;\n+  }\n+\n+  if (*sizep == 0) {\n+    size = sharedmem_filesize(fd, CHECK);\n+  } else {\n+    size = *sizep;\n+  }\n+\n+  assert(size > 0, \"unexpected size <= 0\");\n+\n+  mapAddress = (char*)::mmap((char*)0, size, mmap_prot, MAP_SHARED, fd, 0);\n+\n+  result = ::close(fd);\n+  assert(result != OS_ERR, \"could not close file\");\n+\n+  if (mapAddress == MAP_FAILED) {\n+    if (PrintMiscellaneous && Verbose) {\n+      warning(\"mmap failed: %s\\n\", os::strerror(errno));\n+    }\n+    THROW_MSG(vmSymbols::java_lang_OutOfMemoryError(),\n+              \"Could not map PerfMemory\");\n+  }\n+\n+  \/\/ it does not go through os api, the operation has to record from here\n+  MemTracker::record_virtual_memory_reserve_and_commit((address)mapAddress, size, CURRENT_PC, mtInternal);\n+\n+  *addr = mapAddress;\n+  *sizep = size;\n+\n+  log_debug(perf, memops)(\"mapped \" SIZE_FORMAT \" bytes for vmid %d at \"\n+                          INTPTR_FORMAT, size, vmid, p2i((void*)mapAddress));\n+}\n+\n+\/\/ create the PerfData memory region\n+\/\/\n+\/\/ This method creates the memory region used to store performance\n+\/\/ data for the JVM. The memory may be created in standard or\n+\/\/ shared memory.\n+\/\/\n+void PerfMemory::create_memory_region(size_t size) {\n+\n+  if (PerfDisableSharedMem) {\n+    \/\/ do not share the memory for the performance data.\n+    _start = create_standard_memory(size);\n+  }\n+  else {\n+    _start = create_shared_memory(size);\n+    if (_start == NULL) {\n+\n+      \/\/ creation of the shared memory region failed, attempt\n+      \/\/ to create a contiguous, non-shared memory region instead.\n+      \/\/\n+      if (PrintMiscellaneous && Verbose) {\n+        warning(\"Reverting to non-shared PerfMemory region.\\n\");\n+      }\n+      PerfDisableSharedMem = true;\n+      _start = create_standard_memory(size);\n+    }\n+  }\n+\n+  if (_start != NULL) _capacity = size;\n+\n+}\n+\n+\/\/ delete the PerfData memory region\n+\/\/\n+\/\/ This method deletes the memory region used to store performance\n+\/\/ data for the JVM. The memory region indicated by the <address, size>\n+\/\/ tuple will be inaccessible after a call to this method.\n+\/\/\n+void PerfMemory::delete_memory_region() {\n+\n+  assert((start() != NULL && capacity() > 0), \"verify proper state\");\n+\n+  \/\/ If user specifies PerfDataSaveFile, it will save the performance data\n+  \/\/ to the specified file name no matter whether PerfDataSaveToFile is specified\n+  \/\/ or not. In other word, -XX:PerfDataSaveFile=.. overrides flag\n+  \/\/ -XX:+PerfDataSaveToFile.\n+  if (PerfDataSaveToFile || PerfDataSaveFile != NULL) {\n+    save_memory_to_file(start(), capacity());\n+  }\n+\n+  if (PerfDisableSharedMem) {\n+    delete_standard_memory(start(), capacity());\n+  }\n+  else {\n+    delete_shared_memory(start(), capacity());\n+  }\n+}\n+\n+\/\/ attach to the PerfData memory region for another JVM\n+\/\/\n+\/\/ This method returns an <address, size> tuple that points to\n+\/\/ a memory buffer that is kept reasonably synchronized with\n+\/\/ the PerfData memory region for the indicated JVM. This\n+\/\/ buffer may be kept in synchronization via shared memory\n+\/\/ or some other mechanism that keeps the buffer updated.\n+\/\/\n+\/\/ If the JVM chooses not to support the attachability feature,\n+\/\/ this method should throw an UnsupportedOperation exception.\n+\/\/\n+\/\/ This implementation utilizes named shared memory to map\n+\/\/ the indicated process's PerfData memory region into this JVMs\n+\/\/ address space.\n+\/\/\n+void PerfMemory::attach(const char* user, int vmid, PerfMemoryMode mode, char** addrp, size_t* sizep, TRAPS) {\n+\n+  if (vmid == 0 || vmid == os::current_process_id()) {\n+     *addrp = start();\n+     *sizep = capacity();\n+     return;\n+  }\n+\n+  mmap_attach_shared(user, vmid, mode, addrp, sizep, CHECK);\n+}\n+\n+\/\/ detach from the PerfData memory region of another JVM\n+\/\/\n+\/\/ This method detaches the PerfData memory region of another\n+\/\/ JVM, specified as an <address, size> tuple of a buffer\n+\/\/ in this process's address space. This method may perform\n+\/\/ arbitrary actions to accomplish the detachment. The memory\n+\/\/ region specified by <address, size> will be inaccessible after\n+\/\/ a call to this method.\n+\/\/\n+\/\/ If the JVM chooses not to support the attachability feature,\n+\/\/ this method should throw an UnsupportedOperation exception.\n+\/\/\n+\/\/ This implementation utilizes named shared memory to detach\n+\/\/ the indicated process's PerfData memory region from this\n+\/\/ process's address space.\n+\/\/\n+void PerfMemory::detach(char* addr, size_t bytes) {\n+\n+  assert(addr != 0, \"address sanity check\");\n+  assert(bytes > 0, \"capacity sanity check\");\n+\n+  if (PerfMemory::contains(addr) || PerfMemory::contains(addr + bytes - 1)) {\n+    \/\/ prevent accidental detachment of this process's PerfMemory region\n+    return;\n+  }\n+\n+  unmap_shared(addr, bytes);\n+}\n+\n+bool PerfMemoryLinux::checkpoint(const char* checkpoint_path) {\n+  assert(checkpoint_path, \"should be set\");\n+\n+  if (!backing_store_file_name) {\n+    return true;\n+  }\n+\n+  char path[JVM_MAXPATHLEN];\n+  int pathlen = snprintf(path, sizeof(path),\"%s\/%s\", checkpoint_path, perfdata_name());\n+\n+  RESTARTABLE(::open(path, O_RDWR|O_CREAT|O_NOFOLLOW, S_IRUSR|S_IWUSR), checkpoint_fd);\n+  if (checkpoint_fd < 0) {\n+    tty->print_cr(\"cannot open checkpoint perfdata: %s\", os::strerror(errno));\n+    return false;\n+  }\n+\n+  char* p = PerfMemory::start();\n+  size_t len = PerfMemory::capacity();\n+  do {\n+    int result;\n+    RESTARTABLE(::write(checkpoint_fd, p, len), result);\n+    if (result == OS_ERR) {\n+      tty->print_cr(\"cannot write data to checkpoint perfdata file: %s\", os::strerror(errno));\n+      ::close(checkpoint_fd);\n+      checkpoint_fd = -1;\n+      return false;\n+    }\n+    p += result;\n+    len -= (size_t)result;\n+  } while (0 < len);\n+\n+  void* mmapret = ::mmap(PerfMemory::start(), PerfMemory::capacity(),\n+      PROT_READ|PROT_WRITE, MAP_FIXED|MAP_SHARED, checkpoint_fd, 0);\n+  if (MAP_FAILED == mmapret) {\n+    tty->print_cr(\"cannot mmap checkpoint perfdata file: %s\", os::strerror(errno));\n+    ::close(checkpoint_fd);\n+    checkpoint_fd = -1;\n+    return false;\n+  }\n+\n+  return true;\n+}\n+\n+bool PerfMemoryLinux::checkpoint_fail() {\n+  if (checkpoint_fd < 0) {\n+    return true;\n+  }\n+\n+  int fd;\n+  RESTARTABLE(::open(backing_store_file_name, O_RDWR|O_CREAT|O_NOFOLLOW, S_IRUSR|S_IWUSR), fd);\n+  if (fd == OS_ERR) {\n+    tty->print_cr(\"cannot open original perfdata file: %s\", os::strerror(errno));\n+    return false;\n+  }\n+\n+  void* mmapret = ::mmap(PerfMemory::start(), PerfMemory::capacity(),\n+      PROT_READ|PROT_WRITE, MAP_FIXED|MAP_SHARED, fd, 0);\n+  if (MAP_FAILED == mmapret) {\n+    tty->print_cr(\"cannot mmap old perfdata file: %s\", os::strerror(errno));\n+    ::close(fd);\n+    return false;\n+  }\n+\n+  return true;\n+}\n+\n+bool PerfMemoryLinux::restore() {\n+  if (checkpoint_fd < 0) {\n+    return true;\n+  }\n+\n+  int vmid = os::current_process_id();\n+  char* user_name = get_user_name(geteuid());\n+  char* dirname = get_user_tmp_dir(user_name, vmid, -1);\n+  if (!make_user_tmp_dir(dirname)) {\n+    return false;\n+  }\n+\n+  int fd;\n+  RESTARTABLE(::open(backing_store_file_name, O_RDWR|O_CREAT|O_NOFOLLOW, S_IRUSR|S_IWUSR), fd);\n+  if (fd == OS_ERR) {\n+    tty->print_cr(\"cannot open restore perfdata file: %s\", os::strerror(errno));\n+\n+    void* mmapret = ::mmap(PerfMemory::start(), PerfMemory::capacity(),\n+        PROT_READ|PROT_WRITE, MAP_FIXED|MAP_PRIVATE, checkpoint_fd, 0);\n+    if (MAP_FAILED == mmapret) {\n+      tty->print_cr(\"cannot remap checkpoint perfdata file: %s\", os::strerror(errno));\n+    }\n+    return false;\n+  }\n+\n+  char* p = PerfMemory::start();\n+  size_t len = PerfMemory::capacity();\n+  do {\n+    int result;\n+    RESTARTABLE(::write(fd, p, len), result);\n+    if (result == OS_ERR) {\n+      tty->print_cr(\"cannot write data to restore perfdata file: %s\", os::strerror(errno));\n+      ::close(fd);\n+      return false;\n+    }\n+    p += result;\n+    len -= (size_t)result;\n+  } while (0 < len);\n+\n+  void* mmapret = ::mmap(PerfMemory::start(), PerfMemory::capacity(),\n+      PROT_READ|PROT_WRITE, MAP_FIXED|MAP_SHARED, fd, 0);\n+  if (MAP_FAILED == mmapret) {\n+    tty->print_cr(\"cannot mmap restore perfdata file: %s\", os::strerror(errno));\n+    ::close(fd);\n+    return false;\n+  }\n+\n+  ::close(fd);\n+  ::close(checkpoint_fd);\n+  checkpoint_fd = -1;\n+  return true;\n+}\n","filename":"src\/hotspot\/os\/posix\/perfMemory_posix.cpp","additions":1448,"deletions":0,"binary":false,"changes":1448,"status":"added"},{"patch":"@@ -0,0 +1,1785 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"jvm.h\"\n+#include \"logging\/log.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/globals.hpp\"\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n+#include \"runtime\/java.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"runtime\/osThread.hpp\"\n+#include \"runtime\/semaphore.inline.hpp\"\n+#include \"runtime\/stubRoutines.hpp\"\n+#include \"runtime\/thread.hpp\"\n+#include \"signals_posix.hpp\"\n+#include \"utilities\/events.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+#include \"utilities\/vmError.hpp\"\n+\n+#ifdef ZERO\n+\/\/ See stubGenerator_zero.cpp\n+#include <setjmp.h>\n+extern sigjmp_buf* get_jmp_buf_for_continuation();\n+#endif\n+\n+#include <signal.h>\n+\n+\n+static const char* get_signal_name(int sig, char* out, size_t outlen);\n+\n+\/\/ Returns address of a handler associated with the given sigaction\n+static address get_signal_handler(const struct sigaction* action);\n+\n+#define HANDLER_IS(handler, address)    ((handler) == CAST_FROM_FN_PTR(void*, (address)))\n+#define HANDLER_IS_IGN(handler)         (HANDLER_IS(handler, SIG_IGN))\n+#define HANDLER_IS_DFL(handler)         (HANDLER_IS(handler, SIG_DFL))\n+#define HANDLER_IS_IGN_OR_DFL(handler)  (HANDLER_IS_IGN(handler) || HANDLER_IS_DFL(handler))\n+\n+\/\/ Various signal related mechanism are laid out in the following order:\n+\/\/\n+\/\/ sun.misc.Signal\n+\/\/ signal chaining\n+\/\/ signal handling (except suspend\/resume)\n+\/\/ suspend\/resume\n+\n+\/\/ Helper function to strip any flags from a sigaction sa_flag\n+\/\/ which are not needed for semantic comparison (see remarks below\n+\/\/ about SA_RESTORER on Linux).\n+\/\/ Also to work around the fact that not all platforms define sa_flags\n+\/\/ as signed int (looking at you, zlinux).\n+static int get_sanitized_sa_flags(const struct sigaction* sa) {\n+  int f = (int) sa->sa_flags;\n+#ifdef LINUX\n+  \/\/ Glibc on Linux uses the SA_RESTORER flag to indicate\n+  \/\/ the use of a \"signal trampoline\". We have no interest\n+  \/\/ in this flag and need to ignore it when checking our\n+  \/\/ own flag settings.\n+  \/\/ Note: SA_RESTORER is not exposed through signal.h so we\n+  \/\/ have to hardcode its 0x04000000 value here.\n+  const int sa_restorer_flag = 0x04000000;\n+  f &= ~sa_restorer_flag;\n+#endif \/\/ LINUX\n+  return f;\n+}\n+\n+\/\/ Todo: provide a os::get_max_process_id() or similar. Number of processes\n+\/\/ may have been configured, can be read more accurately from proc fs etc.\n+#ifndef MAX_PID\n+  #define MAX_PID INT_MAX\n+#endif\n+#define IS_VALID_PID(p) (p > 0 && p < MAX_PID)\n+\n+#define NUM_IMPORTANT_SIGS 32\n+\n+extern \"C\" {\n+  typedef void (*sa_handler_t)(int);\n+  typedef void (*sa_sigaction_t)(int, siginfo_t *, void *);\n+}\n+\n+\/\/ At various places we store handler information for each installed handler.\n+\/\/  SavedSignalHandlers is a helper class for those cases, keeping an array of sigaction\n+\/\/  structures.\n+class SavedSignalHandlers {\n+  \/\/ Note: NSIG can be largish, depending on platform, and this array is expected\n+  \/\/ to be sparsely populated. To save space the contained structures are\n+  \/\/ C-heap allocated. Since they only get added outside of signal handling\n+  \/\/ this is no problem.\n+  struct sigaction* _sa[NSIG];\n+\n+  bool check_signal_number(int sig) const {\n+    assert(sig > 0 && sig < NSIG, \"invalid signal number %d\", sig);\n+    return sig > 0 && sig < NSIG;\n+  }\n+\n+public:\n+\n+  SavedSignalHandlers() {\n+    ::memset(_sa, 0, sizeof(_sa));\n+  }\n+\n+  ~SavedSignalHandlers() {\n+    for (int i = 0; i < NSIG; i ++) {\n+      FREE_C_HEAP_OBJ(_sa[i]);\n+    }\n+  }\n+\n+  void set(int sig, const struct sigaction* act) {\n+    if (check_signal_number(sig)) {\n+      assert(_sa[sig] == NULL, \"Overwriting signal handler?\");\n+      _sa[sig] = NEW_C_HEAP_OBJ(struct sigaction, mtInternal);\n+      *_sa[sig] = *act;\n+    }\n+  }\n+\n+  const struct sigaction* get(int sig) const {\n+    if (check_signal_number(sig)) {\n+      return _sa[sig];\n+    }\n+    return NULL;\n+  }\n+};\n+\n+\n+debug_only(static bool signal_sets_initialized = false);\n+static sigset_t unblocked_sigs, blocked_sigs, vm_sigs, preinstalled_sigs;\n+\n+\/\/ Our own signal handlers should never ever get replaced by a third party one.\n+\/\/  To check that, and to aid with diagnostics, store a copy of the handler setup\n+\/\/  and compare it periodically against reality (see os::run_periodic_checks()).\n+static bool check_signals = true;\n+static SavedSignalHandlers vm_handlers;\n+static bool do_check_signal_periodically[NSIG] = { 0 };\n+\n+\/\/ For signal-chaining:\n+\/\/  if chaining is active, chained_handlers contains all handlers which we\n+\/\/  replaced with our own and to which we must delegate.\n+static SavedSignalHandlers chained_handlers;\n+static bool libjsig_is_loaded = false;\n+typedef struct sigaction *(*get_signal_t)(int);\n+static get_signal_t get_signal_action = NULL;\n+\n+\/\/ suspend\/resume support\n+#if defined(__APPLE__)\n+  static OSXSemaphore sr_semaphore;\n+#else\n+  static PosixSemaphore sr_semaphore;\n+#endif\n+\n+\/\/ Signal number used to suspend\/resume a thread\n+\/\/ do not use any signal number less than SIGSEGV, see 4355769\n+int PosixSignals::SR_signum = SIGUSR2;\n+\n+\/\/ sun.misc.Signal support\n+static Semaphore* sig_semaphore = NULL;\n+\/\/ a counter for each possible signal value\n+static volatile jint pending_signals[NSIG+1] = { 0 };\n+\n+static const struct {\n+  int sig; const char* name;\n+} g_signal_info[] = {\n+  {  SIGABRT,     \"SIGABRT\" },\n+#ifdef SIGAIO\n+  {  SIGAIO,      \"SIGAIO\" },\n+#endif\n+  {  SIGALRM,     \"SIGALRM\" },\n+#ifdef SIGALRM1\n+  {  SIGALRM1,    \"SIGALRM1\" },\n+#endif\n+  {  SIGBUS,      \"SIGBUS\" },\n+#ifdef SIGCANCEL\n+  {  SIGCANCEL,   \"SIGCANCEL\" },\n+#endif\n+  {  SIGCHLD,     \"SIGCHLD\" },\n+#ifdef SIGCLD\n+  {  SIGCLD,      \"SIGCLD\" },\n+#endif\n+  {  SIGCONT,     \"SIGCONT\" },\n+#ifdef SIGCPUFAIL\n+  {  SIGCPUFAIL,  \"SIGCPUFAIL\" },\n+#endif\n+#ifdef SIGDANGER\n+  {  SIGDANGER,   \"SIGDANGER\" },\n+#endif\n+#ifdef SIGDIL\n+  {  SIGDIL,      \"SIGDIL\" },\n+#endif\n+#ifdef SIGEMT\n+  {  SIGEMT,      \"SIGEMT\" },\n+#endif\n+  {  SIGFPE,      \"SIGFPE\" },\n+#ifdef SIGFREEZE\n+  {  SIGFREEZE,   \"SIGFREEZE\" },\n+#endif\n+#ifdef SIGGFAULT\n+  {  SIGGFAULT,   \"SIGGFAULT\" },\n+#endif\n+#ifdef SIGGRANT\n+  {  SIGGRANT,    \"SIGGRANT\" },\n+#endif\n+  {  SIGHUP,      \"SIGHUP\" },\n+  {  SIGILL,      \"SIGILL\" },\n+#ifdef SIGINFO\n+  {  SIGINFO,     \"SIGINFO\" },\n+#endif\n+  {  SIGINT,      \"SIGINT\" },\n+#ifdef SIGIO\n+  {  SIGIO,       \"SIGIO\" },\n+#endif\n+#ifdef SIGIOINT\n+  {  SIGIOINT,    \"SIGIOINT\" },\n+#endif\n+#ifdef SIGIOT\n+\/\/ SIGIOT is there for BSD compatibility, but on most Unices just a\n+\/\/ synonym for SIGABRT. The result should be \"SIGABRT\", not\n+\/\/ \"SIGIOT\".\n+#if (SIGIOT != SIGABRT )\n+  {  SIGIOT,      \"SIGIOT\" },\n+#endif\n+#endif\n+#ifdef SIGKAP\n+  {  SIGKAP,      \"SIGKAP\" },\n+#endif\n+  {  SIGKILL,     \"SIGKILL\" },\n+#ifdef SIGLOST\n+  {  SIGLOST,     \"SIGLOST\" },\n+#endif\n+#ifdef SIGLWP\n+  {  SIGLWP,      \"SIGLWP\" },\n+#endif\n+#ifdef SIGLWPTIMER\n+  {  SIGLWPTIMER, \"SIGLWPTIMER\" },\n+#endif\n+#ifdef SIGMIGRATE\n+  {  SIGMIGRATE,  \"SIGMIGRATE\" },\n+#endif\n+#ifdef SIGMSG\n+  {  SIGMSG,      \"SIGMSG\" },\n+#endif\n+  {  SIGPIPE,     \"SIGPIPE\" },\n+#ifdef SIGPOLL\n+  {  SIGPOLL,     \"SIGPOLL\" },\n+#endif\n+#ifdef SIGPRE\n+  {  SIGPRE,      \"SIGPRE\" },\n+#endif\n+  {  SIGPROF,     \"SIGPROF\" },\n+#ifdef SIGPTY\n+  {  SIGPTY,      \"SIGPTY\" },\n+#endif\n+#ifdef SIGPWR\n+  {  SIGPWR,      \"SIGPWR\" },\n+#endif\n+  {  SIGQUIT,     \"SIGQUIT\" },\n+#ifdef SIGRECONFIG\n+  {  SIGRECONFIG, \"SIGRECONFIG\" },\n+#endif\n+#ifdef SIGRECOVERY\n+  {  SIGRECOVERY, \"SIGRECOVERY\" },\n+#endif\n+#ifdef SIGRESERVE\n+  {  SIGRESERVE,  \"SIGRESERVE\" },\n+#endif\n+#ifdef SIGRETRACT\n+  {  SIGRETRACT,  \"SIGRETRACT\" },\n+#endif\n+#ifdef SIGSAK\n+  {  SIGSAK,      \"SIGSAK\" },\n+#endif\n+  {  SIGSEGV,     \"SIGSEGV\" },\n+#ifdef SIGSOUND\n+  {  SIGSOUND,    \"SIGSOUND\" },\n+#endif\n+#ifdef SIGSTKFLT\n+  {  SIGSTKFLT,    \"SIGSTKFLT\" },\n+#endif\n+  {  SIGSTOP,     \"SIGSTOP\" },\n+  {  SIGSYS,      \"SIGSYS\" },\n+#ifdef SIGSYSERROR\n+  {  SIGSYSERROR, \"SIGSYSERROR\" },\n+#endif\n+#ifdef SIGTALRM\n+  {  SIGTALRM,    \"SIGTALRM\" },\n+#endif\n+  {  SIGTERM,     \"SIGTERM\" },\n+#ifdef SIGTHAW\n+  {  SIGTHAW,     \"SIGTHAW\" },\n+#endif\n+  {  SIGTRAP,     \"SIGTRAP\" },\n+#ifdef SIGTSTP\n+  {  SIGTSTP,     \"SIGTSTP\" },\n+#endif\n+  {  SIGTTIN,     \"SIGTTIN\" },\n+  {  SIGTTOU,     \"SIGTTOU\" },\n+#ifdef SIGURG\n+  {  SIGURG,      \"SIGURG\" },\n+#endif\n+  {  SIGUSR1,     \"SIGUSR1\" },\n+  {  SIGUSR2,     \"SIGUSR2\" },\n+#ifdef SIGVIRT\n+  {  SIGVIRT,     \"SIGVIRT\" },\n+#endif\n+  {  SIGVTALRM,   \"SIGVTALRM\" },\n+#ifdef SIGWAITING\n+  {  SIGWAITING,  \"SIGWAITING\" },\n+#endif\n+#ifdef SIGWINCH\n+  {  SIGWINCH,    \"SIGWINCH\" },\n+#endif\n+#ifdef SIGWINDOW\n+  {  SIGWINDOW,   \"SIGWINDOW\" },\n+#endif\n+  {  SIGXCPU,     \"SIGXCPU\" },\n+  {  SIGXFSZ,     \"SIGXFSZ\" },\n+#ifdef SIGXRES\n+  {  SIGXRES,     \"SIGXRES\" },\n+#endif\n+  { -1, NULL }\n+};\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/ sun.misc.Signal support\n+\n+void jdk_misc_signal_init() {\n+  \/\/ Initialize signal structures\n+  ::memset((void*)pending_signals, 0, sizeof(pending_signals));\n+\n+  \/\/ Initialize signal semaphore\n+  sig_semaphore = new Semaphore();\n+}\n+\n+void os::signal_notify(int sig) {\n+  if (sig_semaphore != NULL) {\n+    Atomic::inc(&pending_signals[sig]);\n+    sig_semaphore->signal();\n+  } else {\n+    \/\/ Signal thread is not created with ReduceSignalUsage and jdk_misc_signal_init\n+    \/\/ initialization isn't called.\n+    assert(ReduceSignalUsage, \"signal semaphore should be created\");\n+  }\n+}\n+\n+static int check_pending_signals() {\n+  for (;;) {\n+    for (int i = 0; i < NSIG + 1; i++) {\n+      jint n = pending_signals[i];\n+      if (n > 0 && n == Atomic::cmpxchg(&pending_signals[i], n, n - 1)) {\n+        return i;\n+      }\n+    }\n+    sig_semaphore->wait_with_safepoint_check(JavaThread::current());\n+  }\n+  ShouldNotReachHere();\n+  return 0; \/\/ Satisfy compiler\n+}\n+\n+int os::signal_wait() {\n+  return check_pending_signals();\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/ signal chaining support\n+\n+struct sigaction* get_chained_signal_action(int sig) {\n+  struct sigaction *actp = NULL;\n+\n+  if (libjsig_is_loaded) {\n+    \/\/ Retrieve the old signal handler from libjsig\n+    actp = (*get_signal_action)(sig);\n+  }\n+  if (actp == NULL) {\n+    \/\/ Retrieve the preinstalled signal handler from jvm\n+    actp = const_cast<struct sigaction*>(chained_handlers.get(sig));\n+  }\n+\n+  return actp;\n+}\n+\n+static bool call_chained_handler(struct sigaction *actp, int sig,\n+                                 siginfo_t *siginfo, void *context) {\n+  \/\/ Call the old signal handler\n+  if (actp->sa_handler == SIG_DFL) {\n+    \/\/ It's more reasonable to let jvm treat it as an unexpected exception\n+    \/\/ instead of taking the default action.\n+    return false;\n+  } else if (actp->sa_handler != SIG_IGN) {\n+    if ((actp->sa_flags & SA_NODEFER) == 0) {\n+      \/\/ automaticlly block the signal\n+      sigaddset(&(actp->sa_mask), sig);\n+    }\n+\n+    sa_handler_t hand = NULL;\n+    sa_sigaction_t sa = NULL;\n+    bool siginfo_flag_set = (actp->sa_flags & SA_SIGINFO) != 0;\n+    \/\/ retrieve the chained handler\n+    if (siginfo_flag_set) {\n+      sa = actp->sa_sigaction;\n+    } else {\n+      hand = actp->sa_handler;\n+    }\n+\n+    if ((actp->sa_flags & SA_RESETHAND) != 0) {\n+      actp->sa_handler = SIG_DFL;\n+    }\n+\n+    \/\/ try to honor the signal mask\n+    sigset_t oset;\n+    sigemptyset(&oset);\n+    pthread_sigmask(SIG_SETMASK, &(actp->sa_mask), &oset);\n+\n+    \/\/ call into the chained handler\n+    if (siginfo_flag_set) {\n+      (*sa)(sig, siginfo, context);\n+    } else {\n+      (*hand)(sig);\n+    }\n+\n+    \/\/ restore the signal mask\n+    pthread_sigmask(SIG_SETMASK, &oset, NULL);\n+  }\n+  \/\/ Tell jvm's signal handler the signal is taken care of.\n+  return true;\n+}\n+\n+bool PosixSignals::chained_handler(int sig, siginfo_t* siginfo, void* context) {\n+  bool chained = false;\n+  \/\/ signal-chaining\n+  if (UseSignalChaining) {\n+    struct sigaction *actp = get_chained_signal_action(sig);\n+    if (actp != NULL) {\n+      chained = call_chained_handler(actp, sig, siginfo, context);\n+    }\n+  }\n+  return chained;\n+}\n+\n+\/\/\/\/\/ Synchronous (non-deferrable) error signals (ILL, SEGV, FPE, BUS, TRAP):\n+\n+\/\/ These signals are special because they cannot be deferred and, if they\n+\/\/ happen while delivery is blocked for the receiving thread, will cause UB\n+\/\/ (in practice typically resulting in sudden process deaths or hangs, see\n+\/\/ JDK-8252533). So we must take care never to block them when we cannot be\n+\/\/ absolutely sure they won't happen. In practice, this is always.\n+\/\/\n+\/\/ Relevant Posix quote:\n+\/\/ \"The behavior of a process is undefined after it ignores a SIGFPE, SIGILL,\n+\/\/  SIGSEGV, or SIGBUS signal that was not generated by kill(), sigqueue(), or\n+\/\/  raise().\"\n+\/\/\n+\/\/ We also include SIGTRAP in that list of never-to-block-signals. While not\n+\/\/ mentioned by the Posix documentation, in our (SAPs) experience blocking it\n+\/\/ causes similar problems. Beside, during normal operation - outside of error\n+\/\/ handling - SIGTRAP may be used for implicit NULL checking, so it makes sense\n+\/\/ to never block it.\n+\/\/\n+\/\/ We deal with those signals in two ways:\n+\/\/ - we just never explicitly block them, which includes not accidentally blocking\n+\/\/   them via sa_mask when establishing signal handlers.\n+\/\/ - as an additional safety measure, at the entrance of a signal handler, we\n+\/\/   unblock them explicitly.\n+\n+static void add_error_signals_to_set(sigset_t* set) {\n+  sigaddset(set, SIGILL);\n+  sigaddset(set, SIGBUS);\n+  sigaddset(set, SIGFPE);\n+  sigaddset(set, SIGSEGV);\n+  sigaddset(set, SIGTRAP);\n+}\n+\n+static void remove_error_signals_from_set(sigset_t* set) {\n+  sigdelset(set, SIGILL);\n+  sigdelset(set, SIGBUS);\n+  sigdelset(set, SIGFPE);\n+  sigdelset(set, SIGSEGV);\n+  sigdelset(set, SIGTRAP);\n+}\n+\n+\/\/ Unblock all signals whose delivery cannot be deferred and which, if they happen\n+\/\/  while delivery is blocked, would cause crashes or hangs (JDK-8252533).\n+void PosixSignals::unblock_error_signals() {\n+  sigset_t set;\n+  sigemptyset(&set);\n+  add_error_signals_to_set(&set);\n+  ::pthread_sigmask(SIG_UNBLOCK, &set, NULL);\n+}\n+\n+class ErrnoPreserver: public StackObj {\n+  const int _saved;\n+public:\n+  ErrnoPreserver() : _saved(errno) {}\n+  ~ErrnoPreserver() { errno = _saved; }\n+};\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/ JVM_handle_(linux|aix|bsd)_signal()\n+\n+\/\/ This routine is the shared part of the central hotspot signal handler. It can\n+\/\/ also be called by a user application, if a user application prefers to do\n+\/\/ signal handling itself - in that case it needs to pass signals the VM\n+\/\/ internally uses on to the VM first.\n+\/\/\n+\/\/ The user-defined signal handler must pass unrecognized signals to this\n+\/\/ routine, and if it returns true (non-zero), then the signal handler must\n+\/\/ return immediately.  If the flag \"abort_if_unrecognized\" is true, then this\n+\/\/ routine will never return false (zero), but instead will execute a VM panic\n+\/\/ routine to kill the process.\n+\/\/\n+\/\/ If this routine returns false, it is OK to call it again.  This allows\n+\/\/ the user-defined signal handler to perform checks either before or after\n+\/\/ the VM performs its own checks.  Naturally, the user code would be making\n+\/\/ a serious error if it tried to handle an exception (such as a null check\n+\/\/ or breakpoint) that the VM was generating for its own correct operation.\n+\/\/\n+\/\/ This routine may recognize any of the following kinds of signals:\n+\/\/    SIGBUS, SIGSEGV, SIGILL, SIGFPE, SIGQUIT, SIGPIPE, SIGXFSZ, SIGUSR1.\n+\/\/ It should be consulted by handlers for any of those signals.\n+\/\/\n+\/\/ The caller of this routine must pass in the three arguments supplied\n+\/\/ to the function referred to in the \"sa_sigaction\" (not the \"sa_handler\")\n+\/\/ field of the structure passed to sigaction().  This routine assumes that\n+\/\/ the sa_flags field passed to sigaction() includes SA_SIGINFO and SA_RESTART.\n+\/\/\n+\/\/ Note that the VM will print warnings if it detects conflicting signal\n+\/\/ handlers, unless invoked with the option \"-XX:+AllowUserSignalHandlers\".\n+\/\/\n+\n+#if defined(BSD)\n+#define JVM_HANDLE_XXX_SIGNAL JVM_handle_bsd_signal\n+#elif defined(AIX)\n+#define JVM_HANDLE_XXX_SIGNAL JVM_handle_aix_signal\n+#elif defined(LINUX)\n+#define JVM_HANDLE_XXX_SIGNAL JVM_handle_linux_signal\n+#else\n+#error who are you?\n+#endif\n+\n+extern \"C\" JNIEXPORT\n+int JVM_HANDLE_XXX_SIGNAL(int sig, siginfo_t* info,\n+                          void* ucVoid, int abort_if_unrecognized)\n+{\n+  assert(info != NULL && ucVoid != NULL, \"sanity\");\n+\n+  \/\/ Note: it's not uncommon that JNI code uses signal\/sigset to install,\n+  \/\/ then restore certain signal handler (e.g. to temporarily block SIGPIPE,\n+  \/\/ or have a SIGILL handler when detecting CPU type). When that happens,\n+  \/\/ this handler might be invoked with junk info\/ucVoid. To avoid unnecessary\n+  \/\/ crash when libjsig is not preloaded, try handle signals that do not require\n+  \/\/ siginfo\/ucontext first.\n+\n+  \/\/ Preserve errno value over signal handler.\n+  \/\/  (note: RAII ok here, even with JFR thread crash protection, see below).\n+  ErrnoPreserver ep;\n+\n+  \/\/ Unblock all synchronous error signals (see JDK-8252533)\n+  PosixSignals::unblock_error_signals();\n+\n+  ucontext_t* const uc = (ucontext_t*) ucVoid;\n+  Thread* const t = Thread::current_or_null_safe();\n+\n+  \/\/ Handle JFR thread crash protection.\n+  \/\/  Note: this may cause us to longjmp away. Do not use any code before this\n+  \/\/  point which really needs any form of epilogue code running, eg RAII objects.\n+  os::ThreadCrashProtection::check_crash_protection(sig, t);\n+\n+  bool signal_was_handled = false;\n+\n+  \/\/ Handle assertion poison page accesses.\n+#ifdef CAN_SHOW_REGISTERS_ON_ASSERT\n+  if (!signal_was_handled &&\n+      ((sig == SIGSEGV || sig == SIGBUS) && info != NULL && info->si_addr == g_assert_poison)) {\n+    signal_was_handled = handle_assert_poison_fault(ucVoid, info->si_addr);\n+  }\n+#endif\n+\n+  if (!signal_was_handled) {\n+    \/\/ Handle SafeFetch access.\n+#ifndef ZERO\n+    if (uc != NULL) {\n+      address pc = os::Posix::ucontext_get_pc(uc);\n+      if (StubRoutines::is_safefetch_fault(pc)) {\n+        os::Posix::ucontext_set_pc(uc, StubRoutines::continuation_for_safefetch_fault(pc));\n+        signal_was_handled = true;\n+      }\n+    }\n+#else\n+    \/\/ See JDK-8076185\n+    if (sig == SIGSEGV || sig == SIGBUS) {\n+      sigjmp_buf* const pjb = get_jmp_buf_for_continuation();\n+      if (pjb) {\n+        siglongjmp(*pjb, 1);\n+      }\n+    }\n+#endif \/\/ ZERO\n+  }\n+\n+  \/\/ Ignore SIGPIPE and SIGXFSZ (4229104, 6499219).\n+  if (!signal_was_handled &&\n+      (sig == SIGPIPE || sig == SIGXFSZ)) {\n+    PosixSignals::chained_handler(sig, info, ucVoid);\n+    signal_was_handled = true; \/\/ unconditionally.\n+  }\n+\n+  \/\/ Call platform dependent signal handler.\n+  if (!signal_was_handled) {\n+    JavaThread* const jt = (t != NULL && t->is_Java_thread()) ? (JavaThread*) t : NULL;\n+    signal_was_handled = PosixSignals::pd_hotspot_signal_handler(sig, info, uc, jt);\n+  }\n+\n+  \/\/ From here on, if the signal had not been handled, it is a fatal error.\n+\n+  \/\/ Give the chained signal handler - should it exist - a shot.\n+  if (!signal_was_handled) {\n+    signal_was_handled = PosixSignals::chained_handler(sig, info, ucVoid);\n+  }\n+\n+  \/\/ Invoke fatal error handling.\n+  if (!signal_was_handled && abort_if_unrecognized) {\n+    \/\/ Extract pc from context for the error handler to display.\n+    address pc = NULL;\n+    if (uc != NULL) {\n+      \/\/ prepare fault pc address for error reporting.\n+      if (S390_ONLY(sig == SIGILL || sig == SIGFPE) NOT_S390(false)) {\n+        pc = (address)info->si_addr;\n+      } else if (ZERO_ONLY(true) NOT_ZERO(false)) {\n+        \/\/ Non-arch-specific Zero code does not really know the pc.\n+        \/\/ This can be alleviated by making arch-specific os::Posix::ucontext_get_pc\n+        \/\/ available for Zero for known architectures. But for generic Zero\n+        \/\/ code, it would still remain unknown.\n+        pc = NULL;\n+      } else {\n+        pc = os::Posix::ucontext_get_pc(uc);\n+      }\n+    }\n+    \/\/ For Zero, we ignore the crash context, because:\n+    \/\/  a) The crash would be in C++ interpreter code, so context is not really relevant;\n+    \/\/  b) Generic Zero code would not be able to parse it, so when generic error\n+    \/\/     reporting code asks e.g. about frames on stack, Zero would experience\n+    \/\/     a secondary ShouldNotCallThis() crash.\n+    VMError::report_and_die(t, sig, pc, info, NOT_ZERO(ucVoid) ZERO_ONLY(NULL));\n+    \/\/ VMError should not return.\n+    ShouldNotReachHere();\n+  }\n+  return signal_was_handled;\n+}\n+\n+\/\/ Entry point for the hotspot signal handler.\n+static void javaSignalHandler(int sig, siginfo_t* info, void* ucVoid) {\n+  \/\/ Do not add any code here!\n+  \/\/ Only add code to either JVM_HANDLE_XXX_SIGNAL or PosixSignals::pd_hotspot_signal_handler.\n+  (void)JVM_HANDLE_XXX_SIGNAL(sig, info, ucVoid, true);\n+}\n+\n+static void UserHandler(int sig, void *siginfo, void *context) {\n+\n+  PosixSignals::unblock_error_signals();\n+\n+  \/\/ Ctrl-C is pressed during error reporting, likely because the error\n+  \/\/ handler fails to abort. Let VM die immediately.\n+  if (sig == SIGINT && VMError::is_error_reported()) {\n+    os::die();\n+  }\n+\n+  os::signal_notify(sig);\n+}\n+\n+static void print_signal_handler_name(outputStream* os, address handler, char* buf, size_t buflen) {\n+  \/\/ We demangle, but omit arguments - signal handlers should have always the same prototype.\n+  os::print_function_and_library_name(os, handler, buf, buflen,\n+                                       true, \/\/ shorten_path\n+                                       true, \/\/ demangle\n+                                       true  \/\/ omit arguments\n+                                       );\n+}\n+\n+\/\/ Writes one-line description of a combination of sigaction.sa_flags into a user\n+\/\/ provided buffer. Returns that buffer.\n+static const char* describe_sa_flags(int flags, char* buffer, size_t size) {\n+  char* p = buffer;\n+  size_t remaining = size;\n+  bool first = true;\n+  int idx = 0;\n+\n+  assert(buffer, \"invalid argument\");\n+\n+  if (size == 0) {\n+    return buffer;\n+  }\n+\n+  strncpy(buffer, \"none\", size);\n+\n+  const unsigned int unknown_flag = ~(SA_NOCLDSTOP |\n+                                      SA_ONSTACK   |\n+                                      SA_NOCLDSTOP |\n+                                      SA_RESTART   |\n+                                      SA_SIGINFO   |\n+                                      SA_NOCLDWAIT |\n+                                      SA_NODEFER\n+                                      AIX_ONLY(| SA_OLDSTYLE)\n+                                      );\n+\n+  const struct {\n+    \/\/ NB: i is an unsigned int here because SA_RESETHAND is on some\n+    \/\/ systems 0x80000000, which is implicitly unsigned.  Assigning\n+    \/\/ it to an int field would be an overflow in unsigned-to-signed\n+    \/\/ conversion.\n+    unsigned int i;\n+    const char* s;\n+  } flaginfo [] = {\n+    { SA_NOCLDSTOP, \"SA_NOCLDSTOP\" },\n+    { SA_ONSTACK,   \"SA_ONSTACK\"   },\n+    { SA_RESETHAND, \"SA_RESETHAND\" },\n+    { SA_RESTART,   \"SA_RESTART\"   },\n+    { SA_SIGINFO,   \"SA_SIGINFO\"   },\n+    { SA_NOCLDWAIT, \"SA_NOCLDWAIT\" },\n+    { SA_NODEFER,   \"SA_NODEFER\"   },\n+#if defined(AIX)\n+    { SA_OLDSTYLE,  \"SA_OLDSTYLE\"  },\n+#endif\n+    { unknown_flag, \"NOT USED\"     }\n+  };\n+\n+  for (idx = 0; flaginfo[idx].i != unknown_flag && remaining > 1; idx++) {\n+    if (flags & flaginfo[idx].i) {\n+      if (first) {\n+        jio_snprintf(p, remaining, \"%s\", flaginfo[idx].s);\n+        first = false;\n+      } else {\n+        jio_snprintf(p, remaining, \"|%s\", flaginfo[idx].s);\n+      }\n+      const size_t len = strlen(p);\n+      p += len;\n+      remaining -= len;\n+    }\n+  }\n+  unsigned int unknowns = flags & unknown_flag;\n+  if (unknowns != 0) {\n+    jio_snprintf(p, remaining, \"|Unknown_flags:%x\", unknowns);\n+  }\n+\n+  buffer[size - 1] = '\\0';\n+\n+  return buffer;\n+}\n+\n+\/\/ Prints one-line description of a combination of sigaction.sa_flags.\n+static void print_sa_flags(outputStream* st, int flags) {\n+  char buffer[0x100];\n+  describe_sa_flags(flags, buffer, sizeof(buffer));\n+  st->print(\"%s\", buffer);\n+}\n+\n+\/\/ Implementation may use the same storage for both the sa_sigaction field and the sa_handler field,\n+\/\/ so check for \"sigAct.sa_flags == SA_SIGINFO\"\n+static address get_signal_handler(const struct sigaction* action) {\n+  bool siginfo_flag_set = (action->sa_flags & SA_SIGINFO) != 0;\n+  if (siginfo_flag_set) {\n+    return CAST_FROM_FN_PTR(address, action->sa_sigaction);\n+  } else {\n+    return CAST_FROM_FN_PTR(address, action->sa_handler);\n+  }\n+}\n+\n+typedef int (*os_sigaction_t)(int, const struct sigaction *, struct sigaction *);\n+\n+static void SR_handler(int sig, siginfo_t* siginfo, ucontext_t* context);\n+\n+\/\/ Semantically compare two sigaction structures. Return true if they are referring to\n+\/\/ the same handler, using the same flags.\n+static bool are_handlers_equal(const struct sigaction* sa,\n+                               const struct sigaction* expected_sa) {\n+  address this_handler = get_signal_handler(sa);\n+  address expected_handler = get_signal_handler(expected_sa);\n+  const int this_flags = get_sanitized_sa_flags(sa);\n+  const int expected_flags = get_sanitized_sa_flags(expected_sa);\n+  return (this_handler == expected_handler) &&\n+         (this_flags == expected_flags);\n+}\n+\n+\/\/ If we installed one of our signal handlers for sig, check that the current\n+\/\/  setup matches what we originally installed.\n+static void check_signal_handler(int sig) {\n+  char buf[O_BUFLEN];\n+  bool mismatch = false;\n+\n+  if (!do_check_signal_periodically[sig]) {\n+    return;\n+  }\n+\n+  const struct sigaction* expected_act = vm_handlers.get(sig);\n+  assert(expected_act != NULL, \"Sanity\");\n+\n+  \/\/ Retrieve current signal setup.\n+  struct sigaction act;\n+  static os_sigaction_t os_sigaction = NULL;\n+  if (os_sigaction == NULL) {\n+    \/\/ only trust the default sigaction, in case it has been interposed\n+    os_sigaction = (os_sigaction_t)dlsym(RTLD_DEFAULT, \"sigaction\");\n+    if (os_sigaction == NULL) return;\n+  }\n+\n+  os_sigaction(sig, (struct sigaction*)NULL, &act);\n+\n+  \/\/ Compare both sigaction structures (intelligently; only the members we care about).\n+  if (!are_handlers_equal(&act, expected_act)) {\n+    tty->print_cr(\"Warning: %s handler modified!\", os::exception_name(sig, buf, sizeof(buf)));\n+    \/\/ If we had a mismatch:\n+    \/\/ - print all signal handlers. As part of that printout, details will be printed\n+    \/\/   about any modified handlers.\n+    \/\/ - Disable any further checks for this signal - we do not want to flood stdout. Though\n+    \/\/   depending on which signal had been overwritten, we may die very soon anyway.\n+    os::print_signal_handlers(tty, buf, O_BUFLEN);\n+    do_check_signal_periodically[sig] = false;\n+    tty->print_cr(\"Consider using jsig library.\");\n+    \/\/ Running under non-interactive shell, SHUTDOWN2_SIGNAL will be reassigned SIG_IGN\n+    if (sig == SHUTDOWN2_SIGNAL && !isatty(fileno(stdin))) {\n+      tty->print_cr(\"Note: Running in non-interactive shell, %s handler is replaced by shell\",\n+                    os::exception_name(sig, buf, O_BUFLEN));\n+    }\n+  }\n+}\n+\n+void* os::user_handler() {\n+  return CAST_FROM_FN_PTR(void*, UserHandler);\n+}\n+\n+void* os::signal(int signal_number, void* handler) {\n+  struct sigaction sigAct, oldSigAct;\n+\n+  sigfillset(&(sigAct.sa_mask));\n+  remove_error_signals_from_set(&(sigAct.sa_mask));\n+\n+  sigAct.sa_flags   = SA_RESTART|SA_SIGINFO;\n+  sigAct.sa_handler = CAST_TO_FN_PTR(sa_handler_t, handler);\n+\n+  if (sigaction(signal_number, &sigAct, &oldSigAct)) {\n+    \/\/ -1 means registration failed\n+    return (void *)-1;\n+  }\n+\n+  return get_signal_handler(&oldSigAct);\n+}\n+\n+void os::signal_raise(int signal_number) {\n+  ::raise(signal_number);\n+}\n+\n+\/\/ Will be modified when max signal is changed to be dynamic\n+int os::sigexitnum_pd() {\n+  return NSIG;\n+}\n+\n+\/\/ This method is a periodic task to check for misbehaving JNI applications\n+\/\/ under CheckJNI, we can add any periodic checks here\n+void os::run_periodic_checks() {\n+\n+  if (check_signals == false) return;\n+\n+  \/\/ SEGV and BUS if overridden could potentially prevent\n+  \/\/ generation of hs*.log in the event of a crash, debugging\n+  \/\/ such a case can be very challenging, so we absolutely\n+  \/\/ check the following for a good measure:\n+  check_signal_handler(SIGSEGV);\n+  check_signal_handler(SIGILL);\n+  check_signal_handler(SIGFPE);\n+  check_signal_handler(SIGBUS);\n+  check_signal_handler(SIGPIPE);\n+  check_signal_handler(SIGXFSZ);\n+  PPC64_ONLY(check_signal_handler(SIGTRAP);)\n+\n+  \/\/ ReduceSignalUsage allows the user to override these handlers\n+  \/\/ see comments at the very top and jvm_md.h\n+  if (!ReduceSignalUsage) {\n+    check_signal_handler(SHUTDOWN1_SIGNAL);\n+    check_signal_handler(SHUTDOWN2_SIGNAL);\n+    check_signal_handler(SHUTDOWN3_SIGNAL);\n+    check_signal_handler(BREAK_SIGNAL);\n+  }\n+\n+  check_signal_handler(PosixSignals::SR_signum);\n+}\n+\n+\/\/ Helper function for PosixSignals::print_siginfo_...():\n+\/\/ return a textual description for signal code.\n+struct enum_sigcode_desc_t {\n+  const char* s_name;\n+  const char* s_desc;\n+};\n+\n+static bool get_signal_code_description(const siginfo_t* si, enum_sigcode_desc_t* out) {\n+\n+  const struct {\n+    int sig; int code; const char* s_code; const char* s_desc;\n+  } t1 [] = {\n+    { SIGILL,  ILL_ILLOPC,   \"ILL_ILLOPC\",   \"Illegal opcode.\" },\n+    { SIGILL,  ILL_ILLOPN,   \"ILL_ILLOPN\",   \"Illegal operand.\" },\n+    { SIGILL,  ILL_ILLADR,   \"ILL_ILLADR\",   \"Illegal addressing mode.\" },\n+    { SIGILL,  ILL_ILLTRP,   \"ILL_ILLTRP\",   \"Illegal trap.\" },\n+    { SIGILL,  ILL_PRVOPC,   \"ILL_PRVOPC\",   \"Privileged opcode.\" },\n+    { SIGILL,  ILL_PRVREG,   \"ILL_PRVREG\",   \"Privileged register.\" },\n+    { SIGILL,  ILL_COPROC,   \"ILL_COPROC\",   \"Coprocessor error.\" },\n+    { SIGILL,  ILL_BADSTK,   \"ILL_BADSTK\",   \"Internal stack error.\" },\n+#if defined(IA64) && defined(LINUX)\n+    { SIGILL,  ILL_BADIADDR, \"ILL_BADIADDR\", \"Unimplemented instruction address\" },\n+    { SIGILL,  ILL_BREAK,    \"ILL_BREAK\",    \"Application Break instruction\" },\n+#endif\n+    { SIGFPE,  FPE_INTDIV,   \"FPE_INTDIV\",   \"Integer divide by zero.\" },\n+    { SIGFPE,  FPE_INTOVF,   \"FPE_INTOVF\",   \"Integer overflow.\" },\n+    { SIGFPE,  FPE_FLTDIV,   \"FPE_FLTDIV\",   \"Floating-point divide by zero.\" },\n+    { SIGFPE,  FPE_FLTOVF,   \"FPE_FLTOVF\",   \"Floating-point overflow.\" },\n+    { SIGFPE,  FPE_FLTUND,   \"FPE_FLTUND\",   \"Floating-point underflow.\" },\n+    { SIGFPE,  FPE_FLTRES,   \"FPE_FLTRES\",   \"Floating-point inexact result.\" },\n+    { SIGFPE,  FPE_FLTINV,   \"FPE_FLTINV\",   \"Invalid floating-point operation.\" },\n+    { SIGFPE,  FPE_FLTSUB,   \"FPE_FLTSUB\",   \"Subscript out of range.\" },\n+    { SIGSEGV, SEGV_MAPERR,  \"SEGV_MAPERR\",  \"Address not mapped to object.\" },\n+    { SIGSEGV, SEGV_ACCERR,  \"SEGV_ACCERR\",  \"Invalid permissions for mapped object.\" },\n+#if defined(AIX)\n+    \/\/ no explanation found what keyerr would be\n+    { SIGSEGV, SEGV_KEYERR,  \"SEGV_KEYERR\",  \"key error\" },\n+#endif\n+#if defined(IA64) && !defined(AIX)\n+    { SIGSEGV, SEGV_PSTKOVF, \"SEGV_PSTKOVF\", \"Paragraph stack overflow\" },\n+#endif\n+    { SIGBUS,  BUS_ADRALN,   \"BUS_ADRALN\",   \"Invalid address alignment.\" },\n+    { SIGBUS,  BUS_ADRERR,   \"BUS_ADRERR\",   \"Nonexistent physical address.\" },\n+    { SIGBUS,  BUS_OBJERR,   \"BUS_OBJERR\",   \"Object-specific hardware error.\" },\n+    { SIGTRAP, TRAP_BRKPT,   \"TRAP_BRKPT\",   \"Process breakpoint.\" },\n+    { SIGTRAP, TRAP_TRACE,   \"TRAP_TRACE\",   \"Process trace trap.\" },\n+    { SIGCHLD, CLD_EXITED,   \"CLD_EXITED\",   \"Child has exited.\" },\n+    { SIGCHLD, CLD_KILLED,   \"CLD_KILLED\",   \"Child has terminated abnormally and did not create a core file.\" },\n+    { SIGCHLD, CLD_DUMPED,   \"CLD_DUMPED\",   \"Child has terminated abnormally and created a core file.\" },\n+    { SIGCHLD, CLD_TRAPPED,  \"CLD_TRAPPED\",  \"Traced child has trapped.\" },\n+    { SIGCHLD, CLD_STOPPED,  \"CLD_STOPPED\",  \"Child has stopped.\" },\n+    { SIGCHLD, CLD_CONTINUED,\"CLD_CONTINUED\",\"Stopped child has continued.\" },\n+#ifdef SIGPOLL\n+    { SIGPOLL, POLL_OUT,     \"POLL_OUT\",     \"Output buffers available.\" },\n+    { SIGPOLL, POLL_MSG,     \"POLL_MSG\",     \"Input message available.\" },\n+    { SIGPOLL, POLL_ERR,     \"POLL_ERR\",     \"I\/O error.\" },\n+    { SIGPOLL, POLL_PRI,     \"POLL_PRI\",     \"High priority input available.\" },\n+    { SIGPOLL, POLL_HUP,     \"POLL_HUP\",     \"Device disconnected. [Option End]\" },\n+#endif\n+    { -1, -1, NULL, NULL }\n+  };\n+\n+  \/\/ Codes valid in any signal context.\n+  const struct {\n+    int code; const char* s_code; const char* s_desc;\n+  } t2 [] = {\n+    { SI_USER,      \"SI_USER\",     \"Signal sent by kill().\" },\n+    { SI_QUEUE,     \"SI_QUEUE\",    \"Signal sent by the sigqueue().\" },\n+    { SI_TIMER,     \"SI_TIMER\",    \"Signal generated by expiration of a timer set by timer_settime().\" },\n+    { SI_ASYNCIO,   \"SI_ASYNCIO\",  \"Signal generated by completion of an asynchronous I\/O request.\" },\n+    { SI_MESGQ,     \"SI_MESGQ\",    \"Signal generated by arrival of a message on an empty message queue.\" },\n+    \/\/ Linux specific\n+#ifdef SI_TKILL\n+    { SI_TKILL,     \"SI_TKILL\",    \"Signal sent by tkill (pthread_kill)\" },\n+#endif\n+#ifdef SI_DETHREAD\n+    { SI_DETHREAD,  \"SI_DETHREAD\", \"Signal sent by execve() killing subsidiary threads\" },\n+#endif\n+#ifdef SI_KERNEL\n+    { SI_KERNEL,    \"SI_KERNEL\",   \"Signal sent by kernel.\" },\n+#endif\n+#ifdef SI_SIGIO\n+    { SI_SIGIO,     \"SI_SIGIO\",    \"Signal sent by queued SIGIO\" },\n+#endif\n+\n+#if defined(AIX)\n+    { SI_UNDEFINED, \"SI_UNDEFINED\",\"siginfo contains partial information\" },\n+    { SI_EMPTY,     \"SI_EMPTY\",    \"siginfo contains no useful information\" },\n+#endif\n+\n+    { -1, NULL, NULL }\n+  };\n+\n+  const char* s_code = NULL;\n+  const char* s_desc = NULL;\n+\n+  for (int i = 0; t1[i].sig != -1; i ++) {\n+    if (t1[i].sig == si->si_signo && t1[i].code == si->si_code) {\n+      s_code = t1[i].s_code;\n+      s_desc = t1[i].s_desc;\n+      break;\n+    }\n+  }\n+\n+  if (s_code == NULL) {\n+    for (int i = 0; t2[i].s_code != NULL; i ++) {\n+      if (t2[i].code == si->si_code) {\n+        s_code = t2[i].s_code;\n+        s_desc = t2[i].s_desc;\n+      }\n+    }\n+  }\n+\n+  if (s_code == NULL) {\n+    out->s_name = \"unknown\";\n+    out->s_desc = \"unknown\";\n+    return false;\n+  }\n+\n+  out->s_name = s_code;\n+  out->s_desc = s_desc;\n+\n+  return true;\n+}\n+\n+bool os::signal_sent_by_kill(const void* siginfo) {\n+  const siginfo_t* const si = (const siginfo_t*)siginfo;\n+  return si->si_code == SI_USER || si->si_code == SI_QUEUE\n+#ifdef SI_TKILL\n+         || si->si_code == SI_TKILL\n+#endif\n+  ;\n+}\n+\n+\/\/ Returns true if signal number is valid.\n+static bool is_valid_signal(int sig) {\n+  \/\/ MacOS not really POSIX compliant: sigaddset does not return\n+  \/\/ an error for invalid signal numbers. However, MacOS does not\n+  \/\/ support real time signals and simply seems to have just 33\n+  \/\/ signals with no holes in the signal range.\n+#if defined(__APPLE__)\n+  return sig >= 1 && sig < NSIG;\n+#else\n+  \/\/ Use sigaddset to check for signal validity.\n+  sigset_t set;\n+  sigemptyset(&set);\n+  if (sigaddset(&set, sig) == -1 && errno == EINVAL) {\n+    return false;\n+  }\n+  return true;\n+#endif\n+}\n+\n+static const char* get_signal_name(int sig, char* out, size_t outlen) {\n+\n+  const char* ret = NULL;\n+\n+#ifdef SIGRTMIN\n+  if (sig >= SIGRTMIN && sig <= SIGRTMAX) {\n+    if (sig == SIGRTMIN) {\n+      ret = \"SIGRTMIN\";\n+    } else if (sig == SIGRTMAX) {\n+      ret = \"SIGRTMAX\";\n+    } else {\n+      jio_snprintf(out, outlen, \"SIGRTMIN+%d\", sig - SIGRTMIN);\n+      return out;\n+    }\n+  }\n+#endif\n+\n+  if (sig > 0) {\n+    for (int idx = 0; g_signal_info[idx].sig != -1; idx ++) {\n+      if (g_signal_info[idx].sig == sig) {\n+        ret = g_signal_info[idx].name;\n+        break;\n+      }\n+    }\n+  }\n+\n+  if (!ret) {\n+    if (!is_valid_signal(sig)) {\n+      ret = \"INVALID\";\n+    } else {\n+      ret = \"UNKNOWN\";\n+    }\n+  }\n+\n+  if (out && outlen > 0) {\n+    strncpy(out, ret, outlen);\n+    out[outlen - 1] = '\\0';\n+  }\n+  return out;\n+}\n+\n+void os::print_siginfo(outputStream* os, const void* si0) {\n+\n+  const siginfo_t* const si = (const siginfo_t*) si0;\n+\n+  char buf[20];\n+  os->print(\"siginfo:\");\n+\n+  if (!si) {\n+    os->print(\" <null>\");\n+    return;\n+  }\n+\n+  const int sig = si->si_signo;\n+\n+  os->print(\" si_signo: %d (%s)\", sig, get_signal_name(sig, buf, sizeof(buf)));\n+\n+  enum_sigcode_desc_t ed;\n+  get_signal_code_description(si, &ed);\n+  os->print(\", si_code: %d (%s)\", si->si_code, ed.s_name);\n+\n+  if (si->si_errno) {\n+    os->print(\", si_errno: %d\", si->si_errno);\n+  }\n+\n+  \/\/ Output additional information depending on the signal code.\n+\n+  \/\/ Note: Many implementations lump si_addr, si_pid, si_uid etc. together as unions,\n+  \/\/ so it depends on the context which member to use. For synchronous error signals,\n+  \/\/ we print si_addr, unless the signal was sent by another process or thread, in\n+  \/\/ which case we print out pid or tid of the sender.\n+  if (os::signal_sent_by_kill(si)) {\n+    const pid_t pid = si->si_pid;\n+    os->print(\", si_pid: %ld\", (long) pid);\n+    if (IS_VALID_PID(pid)) {\n+      const pid_t me = getpid();\n+      if (me == pid) {\n+        os->print(\" (current process)\");\n+      }\n+    } else {\n+      os->print(\" (invalid)\");\n+    }\n+    os->print(\", si_uid: %ld\", (long) si->si_uid);\n+    if (sig == SIGCHLD) {\n+      os->print(\", si_status: %d\", si->si_status);\n+    }\n+  } else if (sig == SIGSEGV || sig == SIGBUS || sig == SIGILL ||\n+             sig == SIGTRAP || sig == SIGFPE) {\n+    os->print(\", si_addr: \" PTR_FORMAT, p2i(si->si_addr));\n+#ifdef SIGPOLL\n+  } else if (sig == SIGPOLL) {\n+    os->print(\", si_band: %ld\", si->si_band);\n+#endif\n+  }\n+}\n+\n+bool os::signal_thread(Thread* thread, int sig, const char* reason) {\n+  OSThread* osthread = thread->osthread();\n+  if (osthread) {\n+    int status = pthread_kill(osthread->pthread_id(), sig);\n+    if (status == 0) {\n+      Events::log(Thread::current(), \"sent signal %d to Thread \" INTPTR_FORMAT \" because %s.\",\n+                  sig, p2i(thread), reason);\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+\/\/ Returns:\n+\/\/ NULL for an invalid signal number\n+\/\/ \"SIG<num>\" for a valid but unknown signal number\n+\/\/ signal name otherwise.\n+const char* os::exception_name(int sig, char* buf, size_t size) {\n+  if (!is_valid_signal(sig)) {\n+    return NULL;\n+  }\n+  const char* const name = get_signal_name(sig, buf, size);\n+  if (strcmp(name, \"UNKNOWN\") == 0) {\n+    jio_snprintf(buf, size, \"SIG%d\", sig);\n+  }\n+  return buf;\n+}\n+\n+int os::get_signal_number(const char* signal_name) {\n+  char tmp[30];\n+  const char* s = signal_name;\n+  if (s[0] != 'S' || s[1] != 'I' || s[2] != 'G') {\n+    jio_snprintf(tmp, sizeof(tmp), \"SIG%s\", signal_name);\n+    s = tmp;\n+  }\n+  for (int idx = 0; g_signal_info[idx].sig != -1; idx ++) {\n+    if (strcmp(g_signal_info[idx].name, s) == 0) {\n+      return g_signal_info[idx].sig;\n+    }\n+  }\n+  return -1;\n+}\n+\n+void set_signal_handler(int sig) {\n+  \/\/ Check for overwrite.\n+  struct sigaction oldAct;\n+  sigaction(sig, (struct sigaction*)NULL, &oldAct);\n+\n+  \/\/ Query the current signal handler. Needs to be a separate operation\n+  \/\/ from installing a new handler since we need to honor AllowUserSignalHandlers.\n+  void* oldhand = get_signal_handler(&oldAct);\n+  if (!HANDLER_IS_IGN_OR_DFL(oldhand) &&\n+      !HANDLER_IS(oldhand, javaSignalHandler)) {\n+    if (AllowUserSignalHandlers) {\n+      \/\/ Do not overwrite; user takes responsibility to forward to us.\n+      return;\n+    } else if (UseSignalChaining) {\n+      \/\/ save the old handler in jvm\n+      chained_handlers.set(sig, &oldAct);\n+      \/\/ libjsig also interposes the sigaction() call below and saves the\n+      \/\/ old sigaction on it own.\n+    } else {\n+      fatal(\"Encountered unexpected pre-existing sigaction handler \"\n+            \"%#lx for signal %d.\", (long)oldhand, sig);\n+    }\n+  }\n+\n+  struct sigaction sigAct;\n+  sigfillset(&(sigAct.sa_mask));\n+  remove_error_signals_from_set(&(sigAct.sa_mask));\n+  sigAct.sa_sigaction = javaSignalHandler;\n+  sigAct.sa_flags = SA_SIGINFO|SA_RESTART;\n+#if defined(__APPLE__)\n+  \/\/ Needed for main thread as XNU (Mac OS X kernel) will only deliver SIGSEGV\n+  \/\/ (which starts as SIGBUS) on main thread with faulting address inside \"stack+guard pages\"\n+  \/\/ if the signal handler declares it will handle it on alternate stack.\n+  \/\/ Notice we only declare we will handle it on alt stack, but we are not\n+  \/\/ actually going to use real alt stack - this is just a workaround.\n+  \/\/ Please see ux_exception.c, method catch_mach_exception_raise for details\n+  \/\/ link http:\/\/www.opensource.apple.com\/source\/xnu\/xnu-2050.18.24\/bsd\/uxkern\/ux_exception.c\n+  if (sig == SIGSEGV) {\n+    sigAct.sa_flags |= SA_ONSTACK;\n+  }\n+#endif\n+\n+  \/\/ Save handler setup for later checking\n+  vm_handlers.set(sig, &sigAct);\n+  do_check_signal_periodically[sig] = true;\n+\n+  int ret = sigaction(sig, &sigAct, &oldAct);\n+  assert(ret == 0, \"check\");\n+\n+  void* oldhand2  = get_signal_handler(&oldAct);\n+  assert(oldhand2 == oldhand, \"no concurrent signal handler installation\");\n+}\n+\n+\/\/ install signal handlers for signals that HotSpot needs to\n+\/\/ handle in order to support Java-level exception handling.\n+void install_signal_handlers() {\n+  \/\/ signal-chaining\n+  typedef void (*signal_setting_t)();\n+  signal_setting_t begin_signal_setting = NULL;\n+  signal_setting_t end_signal_setting = NULL;\n+  begin_signal_setting = CAST_TO_FN_PTR(signal_setting_t,\n+                                        dlsym(RTLD_DEFAULT, \"JVM_begin_signal_setting\"));\n+  if (begin_signal_setting != NULL) {\n+    end_signal_setting = CAST_TO_FN_PTR(signal_setting_t,\n+                                        dlsym(RTLD_DEFAULT, \"JVM_end_signal_setting\"));\n+    get_signal_action = CAST_TO_FN_PTR(get_signal_t,\n+                                       dlsym(RTLD_DEFAULT, \"JVM_get_signal_action\"));\n+    libjsig_is_loaded = true;\n+    assert(UseSignalChaining, \"should enable signal-chaining\");\n+  }\n+  if (libjsig_is_loaded) {\n+    \/\/ Tell libjsig jvm is setting signal handlers\n+    (*begin_signal_setting)();\n+  }\n+\n+  set_signal_handler(SIGSEGV);\n+  set_signal_handler(SIGPIPE);\n+  set_signal_handler(SIGBUS);\n+  set_signal_handler(SIGILL);\n+  set_signal_handler(SIGFPE);\n+  PPC64_ONLY(set_signal_handler(SIGTRAP);)\n+  set_signal_handler(SIGXFSZ);\n+\n+#if defined(__APPLE__)\n+  \/\/ lldb (gdb) installs both standard BSD signal handlers, and mach exception\n+  \/\/ handlers. By replacing the existing task exception handler, we disable lldb's mach\n+  \/\/ exception handling, while leaving the standard BSD signal handlers functional.\n+  \/\/\n+  \/\/ EXC_MASK_BAD_ACCESS needed by all architectures for NULL ptr checking\n+  \/\/ EXC_MASK_ARITHMETIC needed by all architectures for div by 0 checking\n+  \/\/ EXC_MASK_BAD_INSTRUCTION needed by aarch64 to initiate deoptimization\n+  kern_return_t kr;\n+  kr = task_set_exception_ports(mach_task_self(),\n+                                EXC_MASK_BAD_ACCESS | EXC_MASK_ARITHMETIC\n+                                  AARCH64_ONLY(| EXC_MASK_BAD_INSTRUCTION),\n+                                MACH_PORT_NULL,\n+                                EXCEPTION_STATE_IDENTITY,\n+                                MACHINE_THREAD_STATE);\n+\n+  assert(kr == KERN_SUCCESS, \"could not set mach task signal handler\");\n+#endif\n+\n+  if (libjsig_is_loaded) {\n+    \/\/ Tell libjsig jvm finishes setting signal handlers\n+    (*end_signal_setting)();\n+  }\n+\n+  \/\/ We don't activate signal checker if libjsig is in place, we trust ourselves\n+  \/\/ and if UserSignalHandler is installed all bets are off.\n+  \/\/ Log that signal checking is off only if -verbose:jni is specified.\n+  if (CheckJNICalls) {\n+    if (libjsig_is_loaded) {\n+      log_debug(jni, resolve)(\"Info: libjsig is activated, all active signal checking is disabled\");\n+      check_signals = false;\n+    }\n+    if (AllowUserSignalHandlers) {\n+      log_debug(jni, resolve)(\"Info: AllowUserSignalHandlers is activated, all active signal checking is disabled\");\n+      check_signals = false;\n+    }\n+  }\n+}\n+\n+\/\/ Returns one-line short description of a signal set in a user provided buffer.\n+static const char* describe_signal_set_short(const sigset_t* set, char* buffer, size_t buf_size) {\n+  assert(buf_size == (NUM_IMPORTANT_SIGS + 1), \"wrong buffer size\");\n+  \/\/ Note: for shortness, just print out the first 32. That should\n+  \/\/ cover most of the useful ones, apart from realtime signals.\n+  for (int sig = 1; sig <= NUM_IMPORTANT_SIGS; sig++) {\n+    const int rc = sigismember(set, sig);\n+    if (rc == -1 && errno == EINVAL) {\n+      buffer[sig-1] = '?';\n+    } else {\n+      buffer[sig-1] = rc == 0 ? '0' : '1';\n+    }\n+  }\n+  buffer[NUM_IMPORTANT_SIGS] = 0;\n+  return buffer;\n+}\n+\n+\/\/ Prints one-line description of a signal set.\n+static void print_signal_set_short(outputStream* st, const sigset_t* set) {\n+  char buf[NUM_IMPORTANT_SIGS + 1];\n+  describe_signal_set_short(set, buf, sizeof(buf));\n+  st->print(\"%s\", buf);\n+}\n+\n+static void print_single_signal_handler(outputStream* st,\n+                                        const struct sigaction* act,\n+                                        char* buf, size_t buflen) {\n+\n+  address handler = get_signal_handler(act);\n+  if (HANDLER_IS_DFL(handler)) {\n+    st->print(\"SIG_DFL\");\n+  } else if (HANDLER_IS_IGN(handler)) {\n+    st->print(\"SIG_IGN\");\n+  } else {\n+    print_signal_handler_name(st, handler, buf, buflen);\n+  }\n+\n+  st->print(\", mask=\");\n+  print_signal_set_short(st, &(act->sa_mask));\n+\n+  st->print(\", flags=\");\n+  int flags = get_sanitized_sa_flags(act);\n+  print_sa_flags(st, flags);\n+\n+}\n+\n+\/\/ Print established signal handler for this signal.\n+\/\/ - if this signal handler was installed by us and is chained to a pre-established user handler\n+\/\/    it replaced, print that one too.\n+\/\/ - otherwise, if this signal handler was installed by us and replaced another handler to which we\n+\/\/    are not chained (e.g. if chaining is off), print that one too.\n+void PosixSignals::print_signal_handler(outputStream* st, int sig,\n+                                        char* buf, size_t buflen) {\n+\n+  st->print(\"%10s: \", os::exception_name(sig, buf, buflen));\n+\n+  struct sigaction current_act;\n+  sigaction(sig, NULL, &current_act);\n+\n+  print_single_signal_handler(st, &current_act, buf, buflen);\n+  st->cr();\n+\n+  \/\/ If we expected to see our own hotspot signal handler but found a different one,\n+  \/\/  print a warning (unless the handler replacing it is our own crash handler, which can\n+  \/\/  happen if this function is called during error reporting).\n+  const struct sigaction* expected_act = vm_handlers.get(sig);\n+  if (expected_act != NULL) {\n+    const address current_handler = get_signal_handler(&current_act);\n+    if (!(HANDLER_IS(current_handler, VMError::crash_handler_address))) {\n+      if (!are_handlers_equal(&current_act, expected_act)) {\n+        st->print_cr(\"  *** Handler was modified!\");\n+        st->print   (\"  *** Expected: \");\n+        print_single_signal_handler(st, expected_act, buf, buflen);\n+        st->cr();\n+      }\n+    }\n+  }\n+\n+  \/\/ If there is a chained handler waiting behind the current one, print it too.\n+  const struct sigaction* chained_act = get_chained_signal_action(sig);\n+  if (chained_act != NULL) {\n+    st->print(\"  chained to: \");\n+    print_single_signal_handler(st, &current_act, buf, buflen);\n+    st->cr();\n+  }\n+}\n+\n+void os::print_signal_handlers(outputStream* st, char* buf, size_t buflen) {\n+  st->print_cr(\"Signal Handlers:\");\n+  PosixSignals::print_signal_handler(st, SIGSEGV, buf, buflen);\n+  PosixSignals::print_signal_handler(st, SIGBUS , buf, buflen);\n+  PosixSignals::print_signal_handler(st, SIGFPE , buf, buflen);\n+  PosixSignals::print_signal_handler(st, SIGPIPE, buf, buflen);\n+  PosixSignals::print_signal_handler(st, SIGXFSZ, buf, buflen);\n+  PosixSignals::print_signal_handler(st, SIGILL , buf, buflen);\n+  PosixSignals::print_signal_handler(st, PosixSignals::SR_signum, buf, buflen);\n+  PosixSignals::print_signal_handler(st, SHUTDOWN1_SIGNAL, buf, buflen);\n+  PosixSignals::print_signal_handler(st, SHUTDOWN2_SIGNAL , buf, buflen);\n+  PosixSignals::print_signal_handler(st, SHUTDOWN3_SIGNAL , buf, buflen);\n+  PosixSignals::print_signal_handler(st, BREAK_SIGNAL, buf, buflen);\n+#if defined(SIGDANGER)\n+  \/\/ We also want to know if someone else adds a SIGDANGER handler because\n+  \/\/ that will interfere with OOM killling.\n+  PosixSignals::print_signal_handler(st, SIGDANGER, buf, buflen);\n+#endif\n+#if defined(SIGTRAP)\n+  PosixSignals::print_signal_handler(st, SIGTRAP, buf, buflen);\n+#endif\n+}\n+\n+bool PosixSignals::is_sig_ignored(int sig) {\n+  struct sigaction oact;\n+  sigaction(sig, (struct sigaction*)NULL, &oact);\n+  if (HANDLER_IS_IGN(get_signal_handler(&oact))) {\n+    return true;\n+  } else {\n+    return false;\n+  }\n+}\n+\n+static void signal_sets_init() {\n+  sigemptyset(&preinstalled_sigs);\n+\n+  \/\/ Should also have an assertion stating we are still single-threaded.\n+  assert(!signal_sets_initialized, \"Already initialized\");\n+  \/\/ Fill in signals that are necessarily unblocked for all threads in\n+  \/\/ the VM. Currently, we unblock the following signals:\n+  \/\/ SHUTDOWN{1,2,3}_SIGNAL: for shutdown hooks support (unless over-ridden\n+  \/\/                         by -Xrs (=ReduceSignalUsage));\n+  \/\/ BREAK_SIGNAL which is unblocked only by the VM thread and blocked by all\n+  \/\/ other threads. The \"ReduceSignalUsage\" boolean tells us not to alter\n+  \/\/ the dispositions or masks wrt these signals.\n+  \/\/ Programs embedding the VM that want to use the above signals for their\n+  \/\/ own purposes must, at this time, use the \"-Xrs\" option to prevent\n+  \/\/ interference with shutdown hooks and BREAK_SIGNAL thread dumping.\n+  \/\/ (See bug 4345157, and other related bugs).\n+  \/\/ In reality, though, unblocking these signals is really a nop, since\n+  \/\/ these signals are not blocked by default.\n+  sigemptyset(&unblocked_sigs);\n+  sigaddset(&unblocked_sigs, SIGILL);\n+  sigaddset(&unblocked_sigs, SIGSEGV);\n+  sigaddset(&unblocked_sigs, SIGBUS);\n+  sigaddset(&unblocked_sigs, SIGFPE);\n+  PPC64_ONLY(sigaddset(&unblocked_sigs, SIGTRAP);)\n+  sigaddset(&unblocked_sigs, PosixSignals::SR_signum);\n+\n+  if (!ReduceSignalUsage) {\n+    if (!PosixSignals::is_sig_ignored(SHUTDOWN1_SIGNAL)) {\n+      sigaddset(&unblocked_sigs, SHUTDOWN1_SIGNAL);\n+    }\n+    if (!PosixSignals::is_sig_ignored(SHUTDOWN2_SIGNAL)) {\n+      sigaddset(&unblocked_sigs, SHUTDOWN2_SIGNAL);\n+    }\n+    if (!PosixSignals::is_sig_ignored(SHUTDOWN3_SIGNAL)) {\n+      sigaddset(&unblocked_sigs, SHUTDOWN3_SIGNAL);\n+    }\n+  }\n+  \/\/ Fill in signals that are blocked by all but the VM thread.\n+  sigemptyset(&vm_sigs);\n+  if (!ReduceSignalUsage) {\n+    sigaddset(&vm_sigs, BREAK_SIGNAL);\n+  }\n+\n+  sigemptyset(&blocked_sigs);\n+  sigaddset(&blocked_sigs, RESTORE_SIGNAL);\n+\n+  debug_only(signal_sets_initialized = true);\n+}\n+\n+\/\/ These are signals that are unblocked while a thread is running Java.\n+\/\/ (For some reason, they get blocked by default.)\n+static sigset_t* unblocked_signals() {\n+  assert(signal_sets_initialized, \"Not initialized\");\n+  return &unblocked_sigs;\n+}\n+\n+\/\/ These are the signals that are blocked while a (non-VM) thread is\n+\/\/ running Java. Only the VM thread handles these signals.\n+static sigset_t* vm_signals() {\n+  assert(signal_sets_initialized, \"Not initialized\");\n+  return &vm_sigs;\n+}\n+\n+void PosixSignals::hotspot_sigmask(Thread* thread) {\n+\n+  \/\/Save caller's signal mask before setting VM signal mask\n+  sigset_t caller_sigmask;\n+  pthread_sigmask(SIG_BLOCK, NULL, &caller_sigmask);\n+\n+  OSThread* osthread = thread->osthread();\n+  osthread->set_caller_sigmask(caller_sigmask);\n+\n+  pthread_sigmask(SIG_UNBLOCK, unblocked_signals(), NULL);\n+\n+  if (!ReduceSignalUsage) {\n+    if (thread->is_VM_thread()) {\n+      \/\/ Only the VM thread handles BREAK_SIGNAL ...\n+      pthread_sigmask(SIG_UNBLOCK, vm_signals(), NULL);\n+    } else {\n+      \/\/ ... all other threads block BREAK_SIGNAL\n+      pthread_sigmask(SIG_BLOCK, vm_signals(), NULL);\n+    }\n+  }\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/ suspend\/resume support\n+\n+\/\/  The low-level signal-based suspend\/resume support is a remnant from the\n+\/\/  old VM-suspension that used to be for java-suspension, safepoints etc,\n+\/\/  within hotspot. Currently used by JFR's OSThreadSampler\n+\/\/\n+\/\/  The remaining code is greatly simplified from the more general suspension\n+\/\/  code that used to be used.\n+\/\/\n+\/\/  The protocol is quite simple:\n+\/\/  - suspend:\n+\/\/      - sends a signal to the target thread\n+\/\/      - polls the suspend state of the osthread using a yield loop\n+\/\/      - target thread signal handler (SR_handler) sets suspend state\n+\/\/        and blocks in sigsuspend until continued\n+\/\/  - resume:\n+\/\/      - sets target osthread state to continue\n+\/\/      - sends signal to end the sigsuspend loop in the SR_handler\n+\/\/\n+\/\/  Note that resume_clear_context() and suspend_save_context() are needed\n+\/\/  by SR_handler(), so that fetch_frame_from_context() works,\n+\/\/  which in part is used by:\n+\/\/    - Forte Analyzer: AsyncGetCallTrace()\n+\/\/    - StackBanging: get_frame_at_stack_banging_point()\n+\n+sigset_t SR_sigset;\n+\n+static void resume_clear_context(OSThread *osthread) {\n+  osthread->set_ucontext(NULL);\n+  osthread->set_siginfo(NULL);\n+}\n+\n+static void suspend_save_context(OSThread *osthread, siginfo_t* siginfo, ucontext_t* context) {\n+  osthread->set_ucontext(context);\n+  osthread->set_siginfo(siginfo);\n+}\n+\n+\/\/ Handler function invoked when a thread's execution is suspended or\n+\/\/ resumed. We have to be careful that only async-safe functions are\n+\/\/ called here (Note: most pthread functions are not async safe and\n+\/\/ should be avoided.)\n+\/\/\n+\/\/ Note: sigwait() is a more natural fit than sigsuspend() from an\n+\/\/ interface point of view, but sigwait() prevents the signal handler\n+\/\/ from being run. libpthread would get very confused by not having\n+\/\/ its signal handlers run and prevents sigwait()'s use with the\n+\/\/ mutex granting signal.\n+\/\/\n+\/\/ Currently only ever called on the VMThread and JavaThreads (PC sampling)\n+\/\/\n+static void SR_handler(int sig, siginfo_t* siginfo, ucontext_t* context) {\n+\n+  \/\/ Save and restore errno to avoid confusing native code with EINTR\n+  \/\/ after sigsuspend.\n+  int old_errno = errno;\n+\n+  PosixSignals::unblock_error_signals();\n+\n+  Thread* thread = Thread::current_or_null_safe();\n+  assert(thread != NULL, \"Missing current thread in SR_handler\");\n+\n+  \/\/ On some systems we have seen signal delivery get \"stuck\" until the signal\n+  \/\/ mask is changed as part of thread termination. Check that the current thread\n+  \/\/ has not already terminated - else the following assertion\n+  \/\/ will fail because the thread is no longer a JavaThread as the ~JavaThread\n+  \/\/ destructor has completed.\n+\n+  if (thread->has_terminated()) {\n+    return;\n+  }\n+\n+  assert(thread->is_VM_thread() || thread->is_Java_thread(), \"Must be VMThread or JavaThread\");\n+\n+  OSThread* osthread = thread->osthread();\n+\n+  os::SuspendResume::State current = osthread->sr.state();\n+\n+  if (current == os::SuspendResume::SR_SUSPEND_REQUEST) {\n+    suspend_save_context(osthread, siginfo, context);\n+\n+    \/\/ attempt to switch the state, we assume we had a SUSPEND_REQUEST\n+    os::SuspendResume::State state = osthread->sr.suspended();\n+    if (state == os::SuspendResume::SR_SUSPENDED) {\n+      sigset_t suspend_set;  \/\/ signals for sigsuspend()\n+      sigemptyset(&suspend_set);\n+\n+      \/\/ get current set of blocked signals and unblock resume signal\n+      pthread_sigmask(SIG_BLOCK, NULL, &suspend_set);\n+      sigdelset(&suspend_set, PosixSignals::SR_signum);\n+\n+      sr_semaphore.signal();\n+\n+      \/\/ wait here until we are resumed\n+      while (1) {\n+        sigsuspend(&suspend_set);\n+\n+        os::SuspendResume::State result = osthread->sr.running();\n+        if (result == os::SuspendResume::SR_RUNNING) {\n+          \/\/ double check AIX doesn't need this!\n+          sr_semaphore.signal();\n+          break;\n+        } else if (result != os::SuspendResume::SR_SUSPENDED) {\n+          ShouldNotReachHere();\n+        }\n+      }\n+\n+    } else if (state == os::SuspendResume::SR_RUNNING) {\n+      \/\/ request was cancelled, continue\n+    } else {\n+      ShouldNotReachHere();\n+    }\n+\n+    resume_clear_context(osthread);\n+  } else if (current == os::SuspendResume::SR_RUNNING) {\n+    \/\/ request was cancelled, continue\n+  } else if (current == os::SuspendResume::SR_WAKEUP_REQUEST) {\n+    \/\/ ignore\n+  } else {\n+    \/\/ ignore\n+  }\n+\n+  errno = old_errno;\n+}\n+\n+int SR_initialize() {\n+  struct sigaction act;\n+  char *s;\n+  \/\/ Get signal number to use for suspend\/resume\n+  if ((s = ::getenv(\"_JAVA_SR_SIGNUM\")) != 0) {\n+    int sig = ::strtol(s, 0, 10);\n+    if (sig > MAX2(SIGSEGV, SIGBUS) &&  \/\/ See 4355769.\n+        sig < NSIG) {                   \/\/ Must be legal signal and fit into sigflags[].\n+      PosixSignals::SR_signum = sig;\n+    } else {\n+      warning(\"You set _JAVA_SR_SIGNUM=%d. It must be in range [%d, %d]. Using %d instead.\",\n+              sig, MAX2(SIGSEGV, SIGBUS)+1, NSIG-1, PosixSignals::SR_signum);\n+    }\n+  }\n+\n+  assert(PosixSignals::SR_signum > SIGSEGV && PosixSignals::SR_signum > SIGBUS,\n+         \"SR_signum must be greater than max(SIGSEGV, SIGBUS), see 4355769\");\n+\n+  sigemptyset(&SR_sigset);\n+  sigaddset(&SR_sigset, PosixSignals::SR_signum);\n+\n+  \/\/ Set up signal handler for suspend\/resume\n+  act.sa_flags = SA_RESTART|SA_SIGINFO;\n+  act.sa_handler = (void (*)(int)) SR_handler;\n+\n+  \/\/ SR_signum is blocked by default.\n+  pthread_sigmask(SIG_BLOCK, NULL, &act.sa_mask);\n+  remove_error_signals_from_set(&(act.sa_mask));\n+\n+  if (sigaction(PosixSignals::SR_signum, &act, 0) == -1) {\n+    return -1;\n+  }\n+\n+  \/\/ Save signal setup information for later checking.\n+  vm_handlers.set(PosixSignals::SR_signum, &act);\n+  do_check_signal_periodically[PosixSignals::SR_signum] = true;\n+\n+  return 0;\n+}\n+\n+static int sr_notify(OSThread* osthread) {\n+  int status = pthread_kill(osthread->pthread_id(), PosixSignals::SR_signum);\n+  assert_status(status == 0, status, \"pthread_kill\");\n+  return status;\n+}\n+\n+\/\/ returns true on success and false on error - really an error is fatal\n+\/\/ but this seems the normal response to library errors\n+bool PosixSignals::do_suspend(OSThread* osthread) {\n+  assert(osthread->sr.is_running(), \"thread should be running\");\n+  assert(!sr_semaphore.trywait(), \"semaphore has invalid state\");\n+\n+  \/\/ mark as suspended and send signal\n+  if (osthread->sr.request_suspend() != os::SuspendResume::SR_SUSPEND_REQUEST) {\n+    \/\/ failed to switch, state wasn't running?\n+    ShouldNotReachHere();\n+    return false;\n+  }\n+\n+  if (sr_notify(osthread) != 0) {\n+    ShouldNotReachHere();\n+  }\n+\n+  \/\/ managed to send the signal and switch to SUSPEND_REQUEST, now wait for SUSPENDED\n+  while (true) {\n+    if (sr_semaphore.timedwait(2)) {\n+      break;\n+    } else {\n+      \/\/ timeout\n+      os::SuspendResume::State cancelled = osthread->sr.cancel_suspend();\n+      if (cancelled == os::SuspendResume::SR_RUNNING) {\n+        return false;\n+      } else if (cancelled == os::SuspendResume::SR_SUSPENDED) {\n+        \/\/ make sure that we consume the signal on the semaphore as well\n+        sr_semaphore.wait();\n+        break;\n+      } else {\n+        ShouldNotReachHere();\n+        return false;\n+      }\n+    }\n+  }\n+\n+  guarantee(osthread->sr.is_suspended(), \"Must be suspended\");\n+  return true;\n+}\n+\n+void PosixSignals::do_resume(OSThread* osthread) {\n+  assert(osthread->sr.is_suspended(), \"thread should be suspended\");\n+  assert(!sr_semaphore.trywait(), \"invalid semaphore state\");\n+\n+  if (osthread->sr.request_wakeup() != os::SuspendResume::SR_WAKEUP_REQUEST) {\n+    \/\/ failed to switch to WAKEUP_REQUEST\n+    ShouldNotReachHere();\n+    return;\n+  }\n+\n+  while (true) {\n+    if (sr_notify(osthread) == 0) {\n+      if (sr_semaphore.timedwait(2)) {\n+        if (osthread->sr.is_running()) {\n+          return;\n+        }\n+      }\n+    } else {\n+      ShouldNotReachHere();\n+    }\n+  }\n+\n+  guarantee(osthread->sr.is_running(), \"Must be running!\");\n+}\n+\n+void os::SuspendedThreadTask::internal_do_task() {\n+  if (PosixSignals::do_suspend(_thread->osthread())) {\n+    os::SuspendedThreadTaskContext context(_thread, _thread->osthread()->ucontext());\n+    do_task(context);\n+    PosixSignals::do_resume(_thread->osthread());\n+  }\n+}\n+\n+int PosixSignals::init() {\n+  \/\/ initialize suspend\/resume support - must do this before signal_sets_init()\n+  if (SR_initialize() != 0) {\n+    vm_exit_during_initialization(\"SR_initialize failed\");\n+    return JNI_ERR;\n+  }\n+\n+  signal_sets_init();\n+\n+  install_signal_handlers();\n+\n+  \/\/ Initialize data for jdk.internal.misc.Signal\n+  if (!ReduceSignalUsage) {\n+    jdk_misc_signal_init();\n+  }\n+\n+  return JNI_OK;\n+}\n","filename":"src\/hotspot\/os\/posix\/signals_posix.cpp","additions":1785,"deletions":0,"binary":false,"changes":1785,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-#include \"jfr\/support\/jfrIntrinsics.hpp\"\n+#include \"classfile\/vmIntrinsics.hpp\"\n@@ -33,1 +33,1 @@\n-\n+#include \"utilities\/enumIterator.hpp\"\n@@ -45,1 +45,2 @@\n-#define VM_SYMBOL_ENUM_NAME(name)    name##_enum\n+#define VM_SYMBOL_ENUM_NAME_(name)    name##_enum\n+#define VM_SYMBOL_ENUM_NAME(name)    vmSymbolID::VM_SYMBOL_ENUM_NAME_(name)\n@@ -68,1 +69,0 @@\n-  template(java_lang_ClassLoader_NativeLibrary,       \"java\/lang\/ClassLoader\\x024NativeLibrary\")  \\\n@@ -84,0 +84,10 @@\n+                                                                                                  \\\n+  template(jdk_internal_vm_vector_VectorSupport,      \"jdk\/internal\/vm\/vector\/VectorSupport\")               \\\n+  template(jdk_internal_vm_vector_VectorPayload,      \"jdk\/internal\/vm\/vector\/VectorSupport$VectorPayload\") \\\n+  template(jdk_internal_vm_vector_Vector,             \"jdk\/internal\/vm\/vector\/VectorSupport$Vector\")        \\\n+  template(jdk_internal_vm_vector_VectorMask,         \"jdk\/internal\/vm\/vector\/VectorSupport$VectorMask\")    \\\n+  template(jdk_internal_vm_vector_VectorShuffle,      \"jdk\/internal\/vm\/vector\/VectorSupport$VectorShuffle\") \\\n+  template(payload_name,                              \"payload\")                                            \\\n+  template(ETYPE_name,                                \"ETYPE\")                                              \\\n+  template(VLENGTH_name,                              \"VLENGTH\")                                            \\\n+                                                                                                  \\\n@@ -131,1 +141,2 @@\n-  template(java_lang_Record,                          \"java\/lang\/Record\")                       \\\n+  template(java_lang_Record,                          \"java\/lang\/Record\")                         \\\n+  template(sun_instrument_InstrumentationImpl,        \"sun\/instrument\/InstrumentationImpl\")       \\\n@@ -133,0 +144,2 @@\n+  template(jdk_internal_loader_NativeLibraries,       \"jdk\/internal\/loader\/NativeLibraries\")      \\\n+  template(jdk_internal_loader_BuiltinClassLoader,    \"jdk\/internal\/loader\/BuiltinClassLoader\")   \\\n@@ -138,0 +151,1 @@\n+  template(java_version_name,                         \"java_version\")                             \\\n@@ -176,0 +190,1 @@\n+  template(tag_permitted_subclasses,                  \"PermittedSubclasses\")                      \\\n@@ -237,0 +252,1 @@\n+  template(jdk_internal_ValueBased_signature,                                \"Ljdk\/internal\/ValueBased;\") \\\n@@ -261,0 +277,1 @@\n+  template(linkToNative_name,                         \"linkToNative\")                             \\\n@@ -268,0 +285,2 @@\n+  template(trusted_final_name,                        \"trustedFinal\")                             \\\n+  template(blackhole_name,                            \"<blackhole>\")  \/*fake name*\/               \\\n@@ -283,1 +302,0 @@\n-  template(jdk_internal_HotSpotIntrinsicCandidate_signature, \"Ljdk\/internal\/HotSpotIntrinsicCandidate;\") \\\n@@ -287,0 +305,2 @@\n+  template(jdk_internal_misc_Scoped_signature,               \"Ljdk\/internal\/misc\/ScopedMemoryAccess$Scoped;\") \\\n+  template(jdk_internal_vm_annotation_IntrinsicCandidate_signature, \"Ljdk\/internal\/vm\/annotation\/IntrinsicCandidate;\") \\\n@@ -288,1 +308,0 @@\n-                                                                                                  \\\n@@ -330,2 +349,6 @@\n-                                                                                                                                      \\\n-  \/* Support for JVMCI *\/                                                                                                             \\\n+  \/* Foreign API Support *\/                                                                                          \\\n+  template(jdk_internal_invoke_NativeEntryPoint,                 \"jdk\/internal\/invoke\/NativeEntryPoint\")           \\\n+  template(jdk_internal_invoke_NativeEntryPoint_signature,       \"Ljdk\/internal\/invoke\/NativeEntryPoint;\")         \\\n+  template(jdk_incubator_foreign_MemoryAccess,       \"jdk\/incubator\/foreign\/MemoryAccess\")        \\\n+                                                                                                  \\\n+  \/* Support for JVMCI *\/                                                                         \\\n@@ -373,0 +396,1 @@\n+  template(refersTo0_name,                            \"refersTo0\")                                \\\n@@ -439,2 +463,0 @@\n-  template(definePackage_name,                        \"definePackage\")                            \\\n-  template(definePackage_signature,                   \"(Ljava\/lang\/String;Ljava\/lang\/Module;)Ljava\/lang\/Package;\") \\\n@@ -462,0 +484,1 @@\n+  template(during_unsafe_access_name,                 \"during_unsafe_access\")                     \\\n@@ -504,0 +527,1 @@\n+  template(long_array_signature,                      \"[J\")                                       \\\n@@ -506,0 +530,1 @@\n+  template(long_object_long_signature,                \"(JLjava\/lang\/Object;)J\")                   \\\n@@ -510,0 +535,1 @@\n+  template(throwable_signature,                       \"Ljava\/lang\/Throwable;\")                    \\\n@@ -512,1 +538,0 @@\n-  template(throwable_throwable_signature,             \"(Ljava\/lang\/Throwable;)Ljava\/lang\/Throwable;\")             \\\n@@ -517,0 +542,1 @@\n+  template(throwable_throwable_signature,             \"(Ljava\/lang\/Throwable;)Ljava\/lang\/Throwable;\")             \\\n@@ -557,0 +583,1 @@\n+  template(referencequeue_signature,                  \"Ljava\/lang\/ref\/ReferenceQueue;\")                           \\\n@@ -568,0 +595,1 @@\n+  template(big_integer_shift_worker_signature,        \"([I[IIII)V\")                                               \\\n@@ -600,6 +628,0 @@\n-  template(createMemoryPoolMBean_name,                 \"createMemoryPoolMBean\")                                   \\\n-  template(createMemoryManagerMBean_name,              \"createMemoryManagerMBean\")                                \\\n-  template(createGarbageCollectorMBean_name,           \"createGarbageCollectorMBean\")                             \\\n-  template(createMemoryPoolMBean_signature,            \"(Ljava\/lang\/String;ZJJ)Ljava\/lang\/management\/MemoryPoolMBean;\") \\\n-  template(createMemoryManagerMBean_signature,         \"(Ljava\/lang\/String;)Ljava\/lang\/management\/MemoryManagerMBean;\") \\\n-  template(createGarbageCollectorMBean_signature,      \"(Ljava\/lang\/String;Ljava\/lang\/String;)Ljava\/lang\/management\/GarbageCollectorMBean;\") \\\n@@ -669,5 +691,16 @@\n-  \/* cds *\/                                                                                                       \\\n-  template(jdk_internal_loader_ClassLoaders,       \"jdk\/internal\/loader\/ClassLoaders\")                            \\\n-  template(toFileURL_name,                         \"toFileURL\")                                                   \\\n-  template(toFileURL_signature,                    \"(Ljava\/lang\/String;)Ljava\/net\/URL;\")                          \\\n-  template(url_void_signature,                     \"(Ljava\/net\/URL;)V\")                                           \\\n+  \/* CDS *\/                                                                                                       \\\n+  template(dumpSharedArchive,                               \"dumpSharedArchive\")                                  \\\n+  template(dumpSharedArchive_signature,                     \"(ZLjava\/lang\/String;)V\")                             \\\n+  template(generateLambdaFormHolderClasses,                 \"generateLambdaFormHolderClasses\")                    \\\n+  template(generateLambdaFormHolderClasses_signature,       \"([Ljava\/lang\/String;)[Ljava\/lang\/Object;\")           \\\n+  template(java_lang_invoke_Invokers_Holder,                \"java\/lang\/invoke\/Invokers$Holder\")                   \\\n+  template(java_lang_invoke_DirectMethodHandle_Holder,      \"java\/lang\/invoke\/DirectMethodHandle$Holder\")         \\\n+  template(java_lang_invoke_LambdaForm_Holder,              \"java\/lang\/invoke\/LambdaForm$Holder\")                 \\\n+  template(java_lang_invoke_DelegatingMethodHandle_Holder,  \"java\/lang\/invoke\/DelegatingMethodHandle$Holder\")     \\\n+  template(jdk_internal_loader_ClassLoaders,                \"jdk\/internal\/loader\/ClassLoaders\")                   \\\n+  template(jdk_internal_misc_CDS,                           \"jdk\/internal\/misc\/CDS\")                              \\\n+  template(java_util_concurrent_ConcurrentHashMap,          \"java\/util\/concurrent\/ConcurrentHashMap\")             \\\n+  template(java_util_ArrayList,                             \"java\/util\/ArrayList\")                                \\\n+  template(toFileURL_name,                                  \"toFileURL\")                                          \\\n+  template(toFileURL_signature,                             \"(Ljava\/lang\/String;)Ljava\/net\/URL;\")                 \\\n+  template(url_void_signature,                              \"(Ljava\/net\/URL;)V\")                                  \\\n@@ -680,824 +713,6 @@\n-\/\/ Here are all the intrinsics known to the runtime and the CI.\n-\/\/ Each intrinsic consists of a public enum name (like _hashCode),\n-\/\/ followed by a specification of its klass, name, and signature:\n-\/\/    template(<id>,  <klass>,  <name>, <sig>, <FCODE>)\n-\/\/\n-\/\/ If you add an intrinsic here, you must also define its name\n-\/\/ and signature as members of the VM symbols.  The VM symbols for\n-\/\/ the intrinsic name and signature may be defined above.\n-\/\/\n-\/\/ Because the VM_SYMBOLS_DO macro makes reference to VM_INTRINSICS_DO,\n-\/\/ you can also define an intrinsic's name and\/or signature locally to the\n-\/\/ intrinsic, if this makes sense.  (It often does make sense.)\n-\/\/\n-\/\/ For example:\n-\/\/    do_intrinsic(_foo,  java_lang_Object,  foo_name, foo_signature, F_xx)\n-\/\/     do_name(     foo_name, \"foo\")\n-\/\/     do_signature(foo_signature, \"()F\")\n-\/\/ klass      = vmSymbols::java_lang_Object()\n-\/\/ name       = vmSymbols::foo_name()\n-\/\/ signature  = vmSymbols::foo_signature()\n-\/\/\n-\/\/ The name and\/or signature might be a \"well known\" symbol\n-\/\/ like \"equal\" or \"()I\", in which case there will be no local\n-\/\/ re-definition of the symbol.\n-\/\/\n-\/\/ The do_class, do_name, and do_signature calls are all used for the\n-\/\/ same purpose:  Define yet another VM symbol.  They could all be merged\n-\/\/ into a common 'do_symbol' call, but it seems useful to record our\n-\/\/ intentions here about kinds of symbols (class vs. name vs. signature).\n-\/\/\n-\/\/ The F_xx is one of the Flags enum; see below.\n-\/\/\n-\/\/ for Emacs: (let ((c-backslash-column 120) (c-backslash-max-column 120)) (c-backslash-region (point) (point-max) nil t))\n-\/\/\n-\/\/\n-\/\/ There are two types of intrinsic methods: (1) Library intrinsics and (2) bytecode intrinsics.\n-\/\/\n-\/\/ (1) A library intrinsic method may be replaced with hand-crafted assembly code,\n-\/\/ with hand-crafted compiler IR, or with a combination of the two. The semantics\n-\/\/ of the replacement code may differ from the semantics of the replaced code.\n-\/\/\n-\/\/ (2) Bytecode intrinsic methods are not replaced by special code, but they are\n-\/\/ treated in some other special way by the compiler. For example, the compiler\n-\/\/ may delay inlining for some String-related intrinsic methods (e.g., some methods\n-\/\/ defined in the StringBuilder and StringBuffer classes, see\n-\/\/ Compile::should_delay_string_inlining() for more details).\n-\/\/\n-\/\/ Due to the difference between the semantics of an intrinsic method as defined\n-\/\/ in the (Java) source code and the semantics of the method as defined\n-\/\/ by the code in the VM, intrinsic methods must be explicitly marked.\n-\/\/\n-\/\/ Intrinsic methods are marked by the jdk.internal.HotSpotIntrinsicCandidate\n-\/\/ annotation. If CheckIntrinsics is enabled, the VM performs the following\n-\/\/ checks when a class C is loaded: (1) all intrinsics defined by the VM for\n-\/\/ class C are present in the loaded class file and are marked;\n-\/\/ (2) an intrinsic is defined by the VM for all marked methods of class C;\n-\/\/ (3) check for orphan methods in class C (i.e., methods for which the VM\n-\/\/ declares an intrinsic but that are not declared for the loaded class C.\n-\/\/ Check (3) is available only in debug builds.\n-\/\/\n-\/\/ If a mismatch is detected for a method, the VM behaves differently depending\n-\/\/ on the type of build. A fastdebug build exits and reports an error on a mismatch.\n-\/\/ A product build will not replace an unmarked library intrinsic method with\n-\/\/ hand-crafted code, that is, unmarked library intrinsics are treated as ordinary\n-\/\/ methods in a product build. The special treatment of a bytecode intrinsic method\n-\/\/ persists even if the method not marked.\n-\/\/\n-\/\/ When adding an intrinsic for a method, please make sure to appropriately\n-\/\/ annotate the method in the source code. The list below contains all\n-\/\/ library intrinsics followed by bytecode intrinsics. Please also make sure to\n-\/\/ add the declaration of the intrinsic to the approriate section of the list.\n-#define VM_INTRINSICS_DO(do_intrinsic, do_class, do_name, do_signature, do_alias)                                       \\\n-  \/* (1) Library intrinsics                                                                        *\/                   \\\n-  do_intrinsic(_hashCode,                 java_lang_Object,       hashCode_name, void_int_signature,             F_R)   \\\n-   do_name(     hashCode_name,                                   \"hashCode\")                                            \\\n-  do_intrinsic(_getClass,                 java_lang_Object,       getClass_name, void_class_signature,           F_R)   \\\n-   do_name(     getClass_name,                                   \"getClass\")                                            \\\n-  do_intrinsic(_clone,                    java_lang_Object,       clone_name, void_object_signature,             F_R)   \\\n-   do_name(     clone_name,                                      \"clone\")                                               \\\n-  do_intrinsic(_notify,                   java_lang_Object,       notify_name, void_method_signature,            F_R)   \\\n-   do_name(     notify_name,                                     \"notify\")                                              \\\n-  do_intrinsic(_notifyAll,                java_lang_Object,       notifyAll_name, void_method_signature,         F_R)   \\\n-   do_name(     notifyAll_name,                                  \"notifyAll\")                                           \\\n-                                                                                                                        \\\n-  \/* Math & StrictMath intrinsics are defined in terms of just a few signatures: *\/                                     \\\n-  do_class(java_lang_Math,                \"java\/lang\/Math\")                                                             \\\n-  do_class(java_lang_StrictMath,          \"java\/lang\/StrictMath\")                                                       \\\n-  do_signature(double2_double_signature,  \"(DD)D\")                                                                      \\\n-  do_signature(double3_double_signature,  \"(DDD)D\")                                                                     \\\n-  do_signature(float2_float_signature,    \"(FF)F\")                                                                      \\\n-  do_signature(float3_float_signature,    \"(FFF)F\")                                                                     \\\n-  do_signature(int2_int_signature,        \"(II)I\")                                                                      \\\n-  do_signature(long2_long_signature,      \"(JJ)J\")                                                                      \\\n-                                                                                                                        \\\n-  \/* here are the math names, all together: *\/                                                                          \\\n-  do_name(abs_name,\"abs\")       do_name(sin_name,\"sin\")         do_name(cos_name,\"cos\")                                 \\\n-  do_name(tan_name,\"tan\")       do_name(atan2_name,\"atan2\")     do_name(sqrt_name,\"sqrt\")                               \\\n-  do_name(log_name,\"log\")       do_name(log10_name,\"log10\")     do_name(pow_name,\"pow\")                                 \\\n-  do_name(exp_name,\"exp\")       do_name(min_name,\"min\")         do_name(max_name,\"max\")                                 \\\n-  do_name(floor_name, \"floor\")  do_name(ceil_name, \"ceil\")      do_name(rint_name, \"rint\")                              \\\n-                                                                                                                        \\\n-  do_name(addExact_name,\"addExact\")                                                                                     \\\n-  do_name(decrementExact_name,\"decrementExact\")                                                                         \\\n-  do_name(incrementExact_name,\"incrementExact\")                                                                         \\\n-  do_name(multiplyExact_name,\"multiplyExact\")                                                                           \\\n-  do_name(multiplyHigh_name,\"multiplyHigh\")                                                                             \\\n-  do_name(negateExact_name,\"negateExact\")                                                                               \\\n-  do_name(subtractExact_name,\"subtractExact\")                                                                           \\\n-  do_name(fma_name, \"fma\")                                                                                              \\\n-                                                                                                                        \\\n-  do_intrinsic(_dabs,                     java_lang_Math,         abs_name,   double_double_signature,           F_S)   \\\n-  do_intrinsic(_fabs,                     java_lang_Math,         abs_name,   float_float_signature,           F_S)   \\\n-  do_intrinsic(_iabs,                     java_lang_Math,         abs_name,   int_int_signature,           F_S)   \\\n-  do_intrinsic(_labs,                     java_lang_Math,         abs_name,   long_long_signature,           F_S)   \\\n-  do_intrinsic(_dsin,                     java_lang_Math,         sin_name,   double_double_signature,           F_S)   \\\n-  do_intrinsic(_floor,                    java_lang_Math,         floor_name, double_double_signature,           F_S)   \\\n-  do_intrinsic(_ceil,                     java_lang_Math,         ceil_name,  double_double_signature,           F_S)   \\\n-  do_intrinsic(_rint,                     java_lang_Math,         rint_name,  double_double_signature,           F_S)   \\\n-  do_intrinsic(_dcos,                     java_lang_Math,         cos_name,   double_double_signature,           F_S)   \\\n-  do_intrinsic(_dtan,                     java_lang_Math,         tan_name,   double_double_signature,           F_S)   \\\n-  do_intrinsic(_datan2,                   java_lang_Math,         atan2_name, double2_double_signature,          F_S)   \\\n-  do_intrinsic(_dsqrt,                    java_lang_Math,         sqrt_name,  double_double_signature,           F_S)   \\\n-  do_intrinsic(_dlog,                     java_lang_Math,         log_name,   double_double_signature,           F_S)   \\\n-  do_intrinsic(_dlog10,                   java_lang_Math,         log10_name, double_double_signature,           F_S)   \\\n-  do_intrinsic(_dpow,                     java_lang_Math,         pow_name,   double2_double_signature,          F_S)   \\\n-  do_intrinsic(_dexp,                     java_lang_Math,         exp_name,   double_double_signature,           F_S)   \\\n-  do_intrinsic(_min,                      java_lang_Math,         min_name,   int2_int_signature,                F_S)   \\\n-  do_intrinsic(_max,                      java_lang_Math,         max_name,   int2_int_signature,                F_S)   \\\n-  do_intrinsic(_addExactI,                java_lang_Math,         addExact_name, int2_int_signature,             F_S)   \\\n-  do_intrinsic(_addExactL,                java_lang_Math,         addExact_name, long2_long_signature,           F_S)   \\\n-  do_intrinsic(_decrementExactI,          java_lang_Math,         decrementExact_name, int_int_signature,        F_S)   \\\n-  do_intrinsic(_decrementExactL,          java_lang_Math,         decrementExact_name, long_long_signature,      F_S)   \\\n-  do_intrinsic(_incrementExactI,          java_lang_Math,         incrementExact_name, int_int_signature,        F_S)   \\\n-  do_intrinsic(_incrementExactL,          java_lang_Math,         incrementExact_name, long_long_signature,      F_S)   \\\n-  do_intrinsic(_multiplyExactI,           java_lang_Math,         multiplyExact_name, int2_int_signature,        F_S)   \\\n-  do_intrinsic(_multiplyExactL,           java_lang_Math,         multiplyExact_name, long2_long_signature,      F_S)   \\\n-  do_intrinsic(_multiplyHigh,             java_lang_Math,         multiplyHigh_name, long2_long_signature,       F_S)   \\\n-  do_intrinsic(_negateExactI,             java_lang_Math,         negateExact_name, int_int_signature,           F_S)   \\\n-  do_intrinsic(_negateExactL,             java_lang_Math,         negateExact_name, long_long_signature,         F_S)   \\\n-  do_intrinsic(_subtractExactI,           java_lang_Math,         subtractExact_name, int2_int_signature,        F_S)   \\\n-  do_intrinsic(_subtractExactL,           java_lang_Math,         subtractExact_name, long2_long_signature,      F_S)   \\\n-  do_intrinsic(_fmaD,                     java_lang_Math,         fma_name,           double3_double_signature,  F_S)   \\\n-  do_intrinsic(_fmaF,                     java_lang_Math,         fma_name,           float3_float_signature,    F_S)   \\\n-  do_intrinsic(_maxF,                     java_lang_Math,         max_name,           float2_float_signature,    F_S)   \\\n-  do_intrinsic(_minF,                     java_lang_Math,         min_name,           float2_float_signature,    F_S)   \\\n-  do_intrinsic(_maxD,                     java_lang_Math,         max_name,           double2_double_signature,  F_S)   \\\n-  do_intrinsic(_minD,                     java_lang_Math,         min_name,           double2_double_signature,  F_S)   \\\n-                                                                                                                        \\\n-  do_intrinsic(_floatToRawIntBits,        java_lang_Float,        floatToRawIntBits_name,   float_int_signature, F_S)   \\\n-   do_name(     floatToRawIntBits_name,                          \"floatToRawIntBits\")                                   \\\n-  do_intrinsic(_floatToIntBits,           java_lang_Float,        floatToIntBits_name,      float_int_signature, F_S)   \\\n-   do_name(     floatToIntBits_name,                             \"floatToIntBits\")                                      \\\n-  do_intrinsic(_intBitsToFloat,           java_lang_Float,        intBitsToFloat_name,      int_float_signature, F_S)   \\\n-   do_name(     intBitsToFloat_name,                             \"intBitsToFloat\")                                      \\\n-  do_intrinsic(_doubleToRawLongBits,      java_lang_Double,       doubleToRawLongBits_name, double_long_signature, F_S) \\\n-   do_name(     doubleToRawLongBits_name,                        \"doubleToRawLongBits\")                                 \\\n-  do_intrinsic(_doubleToLongBits,         java_lang_Double,       doubleToLongBits_name,    double_long_signature, F_S) \\\n-   do_name(     doubleToLongBits_name,                           \"doubleToLongBits\")                                    \\\n-  do_intrinsic(_longBitsToDouble,         java_lang_Double,       longBitsToDouble_name,    long_double_signature, F_S) \\\n-   do_name(     longBitsToDouble_name,                           \"longBitsToDouble\")                                    \\\n-                                                                                                                        \\\n-  do_intrinsic(_numberOfLeadingZeros_i,   java_lang_Integer,      numberOfLeadingZeros_name,int_int_signature,   F_S)   \\\n-  do_intrinsic(_numberOfLeadingZeros_l,   java_lang_Long,         numberOfLeadingZeros_name,long_int_signature,  F_S)   \\\n-                                                                                                                        \\\n-  do_intrinsic(_numberOfTrailingZeros_i,  java_lang_Integer,      numberOfTrailingZeros_name,int_int_signature,  F_S)   \\\n-  do_intrinsic(_numberOfTrailingZeros_l,  java_lang_Long,         numberOfTrailingZeros_name,long_int_signature, F_S)   \\\n-                                                                                                                        \\\n-  do_intrinsic(_bitCount_i,               java_lang_Integer,      bitCount_name,            int_int_signature,   F_S)   \\\n-  do_intrinsic(_bitCount_l,               java_lang_Long,         bitCount_name,            long_int_signature,  F_S)   \\\n-                                                                                                                        \\\n-  do_intrinsic(_reverseBytes_i,           java_lang_Integer,      reverseBytes_name,        int_int_signature,   F_S)   \\\n-   do_name(     reverseBytes_name,                               \"reverseBytes\")                                        \\\n-  do_intrinsic(_reverseBytes_l,           java_lang_Long,         reverseBytes_name,        long_long_signature, F_S)   \\\n-    \/*  (symbol reverseBytes_name defined above) *\/                                                                     \\\n-  do_intrinsic(_reverseBytes_c,           java_lang_Character,    reverseBytes_name,        char_char_signature, F_S)   \\\n-    \/*  (symbol reverseBytes_name defined above) *\/                                                                     \\\n-  do_intrinsic(_reverseBytes_s,           java_lang_Short,        reverseBytes_name,        short_short_signature, F_S) \\\n-    \/*  (symbol reverseBytes_name defined above) *\/                                                                     \\\n-                                                                                                                        \\\n-  do_intrinsic(_identityHashCode,         java_lang_System,       identityHashCode_name, object_int_signature,   F_S)   \\\n-   do_name(     identityHashCode_name,                           \"identityHashCode\")                                    \\\n-  do_intrinsic(_currentTimeMillis,        java_lang_System,       currentTimeMillis_name, void_long_signature,   F_S)   \\\n-                                                                                                                        \\\n-   do_name(     currentTimeMillis_name,                          \"currentTimeMillis\")                                   \\\n-  do_intrinsic(_nanoTime,                 java_lang_System,       nanoTime_name,          void_long_signature,   F_S)   \\\n-   do_name(     nanoTime_name,                                   \"nanoTime\")                                            \\\n-                                                                                                                        \\\n-  JFR_INTRINSICS(do_intrinsic, do_class, do_name, do_signature, do_alias)                                               \\\n-                                                                                                                        \\\n-  do_intrinsic(_arraycopy,                java_lang_System,       arraycopy_name, arraycopy_signature,           F_S)   \\\n-   do_name(     arraycopy_name,                                  \"arraycopy\")                                           \\\n-   do_signature(arraycopy_signature,                             \"(Ljava\/lang\/Object;ILjava\/lang\/Object;II)V\")          \\\n-  do_intrinsic(_currentThread,            java_lang_Thread,       currentThread_name, currentThread_signature,   F_S)   \\\n-   do_name(     currentThread_name,                              \"currentThread\")                                       \\\n-   do_signature(currentThread_signature,                         \"()Ljava\/lang\/Thread;\")                                \\\n-                                                                                                                        \\\n-  \/* reflective intrinsics, for java\/lang\/Class, etc. *\/                                                                \\\n-  do_intrinsic(_isAssignableFrom,         java_lang_Class,        isAssignableFrom_name, class_boolean_signature, F_RN) \\\n-   do_name(     isAssignableFrom_name,                           \"isAssignableFrom\")                                    \\\n-  do_intrinsic(_isInstance,               java_lang_Class,        isInstance_name, object_boolean_signature,     F_RN)  \\\n-   do_name(     isInstance_name,                                 \"isInstance\")                                          \\\n-  do_intrinsic(_getModifiers,             java_lang_Class,        getModifiers_name, void_int_signature,         F_RN)  \\\n-   do_name(     getModifiers_name,                               \"getModifiers\")                                        \\\n-  do_intrinsic(_isInterface,              java_lang_Class,        isInterface_name, void_boolean_signature,      F_RN)  \\\n-   do_name(     isInterface_name,                                \"isInterface\")                                         \\\n-  do_intrinsic(_isArray,                  java_lang_Class,        isArray_name, void_boolean_signature,          F_RN)  \\\n-   do_name(     isArray_name,                                    \"isArray\")                                             \\\n-  do_intrinsic(_isPrimitive,              java_lang_Class,        isPrimitive_name, void_boolean_signature,      F_RN)  \\\n-   do_name(     isPrimitive_name,                                \"isPrimitive\")                                         \\\n-  do_intrinsic(_getSuperclass,            java_lang_Class,        getSuperclass_name, void_class_signature,      F_RN)  \\\n-   do_name(     getSuperclass_name,                              \"getSuperclass\")                                       \\\n-  do_intrinsic(_Class_cast,               java_lang_Class,        Class_cast_name, object_object_signature,      F_R)   \\\n-   do_name(     Class_cast_name,                                 \"cast\")                                                \\\n-                                                                                                                        \\\n-  do_intrinsic(_getClassAccessFlags,      reflect_Reflection,     getClassAccessFlags_name, class_int_signature, F_SN)  \\\n-   do_name(     getClassAccessFlags_name,                        \"getClassAccessFlags\")                                 \\\n-  do_intrinsic(_getLength,                java_lang_reflect_Array, getLength_name, object_int_signature,         F_SN)  \\\n-   do_name(     getLength_name,                                   \"getLength\")                                          \\\n-                                                                                                                        \\\n-  do_intrinsic(_getCallerClass,           reflect_Reflection,     getCallerClass_name, void_class_signature,     F_SN)  \\\n-   do_name(     getCallerClass_name,                             \"getCallerClass\")                                      \\\n-                                                                                                                        \\\n-  do_intrinsic(_newArray,                 java_lang_reflect_Array, newArray_name, newArray_signature,            F_SN)  \\\n-   do_name(     newArray_name,                                    \"newArray\")                                           \\\n-   do_signature(newArray_signature,                               \"(Ljava\/lang\/Class;I)Ljava\/lang\/Object;\")             \\\n-                                                                                                                        \\\n-  do_intrinsic(_onSpinWait,               java_lang_Thread,       onSpinWait_name, onSpinWait_signature,         F_S)   \\\n-   do_name(     onSpinWait_name,                                  \"onSpinWait\")                                         \\\n-   do_alias(    onSpinWait_signature,                             void_method_signature)                                \\\n-                                                                                                                        \\\n-  do_intrinsic(_copyOf,                   java_util_Arrays,       copyOf_name, copyOf_signature,                 F_S)   \\\n-   do_name(     copyOf_name,                                     \"copyOf\")                                              \\\n-   do_signature(copyOf_signature,             \"([Ljava\/lang\/Object;ILjava\/lang\/Class;)[Ljava\/lang\/Object;\")             \\\n-                                                                                                                        \\\n-  do_intrinsic(_copyOfRange,              java_util_Arrays,       copyOfRange_name, copyOfRange_signature,       F_S)   \\\n-   do_name(     copyOfRange_name,                                \"copyOfRange\")                                         \\\n-   do_signature(copyOfRange_signature,        \"([Ljava\/lang\/Object;IILjava\/lang\/Class;)[Ljava\/lang\/Object;\")            \\\n-                                                                                                                        \\\n-  do_intrinsic(_equalsC,                  java_util_Arrays,       equals_name,    equalsC_signature,             F_S)   \\\n-   do_signature(equalsC_signature,                               \"([C[C)Z\")                                             \\\n-  do_intrinsic(_equalsB,                  java_util_Arrays,       equals_name,    equalsB_signature,             F_S)   \\\n-   do_signature(equalsB_signature,                               \"([B[B)Z\")                                             \\\n-                                                                                                                        \\\n-  do_intrinsic(_compressStringC,          java_lang_StringUTF16,  compress_name, encodeISOArray_signature,       F_S)   \\\n-   do_name(     compress_name,                                   \"compress\")                                            \\\n-  do_intrinsic(_compressStringB,          java_lang_StringUTF16,  compress_name, indexOfI_signature,             F_S)   \\\n-  do_intrinsic(_inflateStringC,           java_lang_StringLatin1, inflate_name, inflateC_signature,              F_S)   \\\n-   do_name(     inflate_name,                                    \"inflate\")                                             \\\n-   do_signature(inflateC_signature,                              \"([BI[CII)V\")                                          \\\n-  do_intrinsic(_inflateStringB,           java_lang_StringLatin1, inflate_name, inflateB_signature,              F_S)   \\\n-   do_signature(inflateB_signature,                              \"([BI[BII)V\")                                          \\\n-  do_intrinsic(_toBytesStringU,           java_lang_StringUTF16, toBytes_name, toBytesU_signature,               F_S)   \\\n-   do_name(     toBytes_name,                                    \"toBytes\")                                             \\\n-   do_signature(toBytesU_signature,                              \"([CII)[B\")                                            \\\n-  do_intrinsic(_getCharsStringU,          java_lang_StringUTF16, getCharsU_name, getCharsU_signature,            F_S)   \\\n-   do_name(     getCharsU_name,                                  \"getChars\")                                            \\\n-   do_signature(getCharsU_signature,                             \"([BII[CI)V\")                                          \\\n-  do_intrinsic(_getCharStringU,           java_lang_StringUTF16, getChar_name, getCharStringU_signature,         F_S)   \\\n-   do_signature(getCharStringU_signature,                        \"([BI)C\")                                              \\\n-  do_intrinsic(_putCharStringU,           java_lang_StringUTF16, putChar_name, putCharStringU_signature,         F_S)   \\\n-   do_signature(putCharStringU_signature,                        \"([BII)V\")                                             \\\n-  do_intrinsic(_compareToL,               java_lang_StringLatin1,compareTo_name, compareTo_indexOf_signature,    F_S)   \\\n-  do_intrinsic(_compareToU,               java_lang_StringUTF16, compareTo_name, compareTo_indexOf_signature,    F_S)   \\\n-  do_intrinsic(_compareToLU,              java_lang_StringLatin1,compareToLU_name, compareTo_indexOf_signature,  F_S)   \\\n-  do_intrinsic(_compareToUL,              java_lang_StringUTF16, compareToUL_name, compareTo_indexOf_signature,  F_S)   \\\n-   do_signature(compareTo_indexOf_signature,                     \"([B[B)I\")                                             \\\n-   do_name(     compareTo_name,                                  \"compareTo\")                                           \\\n-   do_name(     compareToLU_name,                                \"compareToUTF16\")                                      \\\n-   do_name(     compareToUL_name,                                \"compareToLatin1\")                                     \\\n-  do_intrinsic(_indexOfL,                 java_lang_StringLatin1,indexOf_name, compareTo_indexOf_signature,      F_S)   \\\n-  do_intrinsic(_indexOfU,                 java_lang_StringUTF16, indexOf_name, compareTo_indexOf_signature,      F_S)   \\\n-  do_intrinsic(_indexOfUL,                java_lang_StringUTF16, indexOfUL_name, compareTo_indexOf_signature,    F_S)   \\\n-  do_intrinsic(_indexOfIL,                java_lang_StringLatin1,indexOf_name, indexOfI_signature,               F_S)   \\\n-  do_intrinsic(_indexOfIU,                java_lang_StringUTF16, indexOf_name, indexOfI_signature,               F_S)   \\\n-  do_intrinsic(_indexOfIUL,               java_lang_StringUTF16, indexOfUL_name, indexOfI_signature,             F_S)   \\\n-  do_intrinsic(_indexOfU_char,            java_lang_StringUTF16, indexOfChar_name, indexOfChar_signature,        F_S)   \\\n-   do_name(     indexOf_name,                                    \"indexOf\")                                             \\\n-   do_name(     indexOfChar_name,                                \"indexOfChar\")                                         \\\n-   do_name(     indexOfUL_name,                                  \"indexOfLatin1\")                                       \\\n-   do_signature(indexOfI_signature,                              \"([BI[BII)I\")                                          \\\n-   do_signature(indexOfChar_signature,                           \"([BIII)I\")                                            \\\n-  do_intrinsic(_equalsL,                  java_lang_StringLatin1,equals_name, equalsB_signature,                 F_S)   \\\n-  do_intrinsic(_equalsU,                  java_lang_StringUTF16, equals_name, equalsB_signature,                 F_S)   \\\n-                                                                                                                        \\\n-  do_intrinsic(_isDigit,                  java_lang_CharacterDataLatin1, isDigit_name,      int_bool_signature,  F_R)   \\\n-   do_name(     isDigit_name,                                           \"isDigit\")                                      \\\n-  do_intrinsic(_isLowerCase,              java_lang_CharacterDataLatin1, isLowerCase_name,  int_bool_signature,  F_R)   \\\n-   do_name(     isLowerCase_name,                                       \"isLowerCase\")                                  \\\n-  do_intrinsic(_isUpperCase,              java_lang_CharacterDataLatin1, isUpperCase_name,  int_bool_signature,  F_R)   \\\n-   do_name(     isUpperCase_name,                                       \"isUpperCase\")                                  \\\n-  do_intrinsic(_isWhitespace,             java_lang_CharacterDataLatin1, isWhitespace_name, int_bool_signature,  F_R)   \\\n-   do_name(     isWhitespace_name,                                      \"isWhitespace\")                                 \\\n-                                                                                                                        \\\n-  do_intrinsic(_Preconditions_checkIndex, jdk_internal_util_Preconditions, checkIndex_name, Preconditions_checkIndex_signature, F_S)   \\\n-   do_signature(Preconditions_checkIndex_signature,              \"(IILjava\/util\/function\/BiFunction;)I\")                \\\n-                                                                                                                        \\\n-  do_class(java_nio_Buffer,               \"java\/nio\/Buffer\")                                                            \\\n-  do_intrinsic(_checkIndex,               java_nio_Buffer,        checkIndex_name, int_int_signature,            F_R)   \\\n-   do_name(     checkIndex_name,                                 \"checkIndex\")                                          \\\n-                                                                                                                        \\\n-  do_class(java_lang_StringCoding,        \"java\/lang\/StringCoding\")                                                     \\\n-  do_intrinsic(_hasNegatives,             java_lang_StringCoding, hasNegatives_name, hasNegatives_signature,     F_S)   \\\n-   do_name(     hasNegatives_name,                               \"hasNegatives\")                                        \\\n-   do_signature(hasNegatives_signature,                          \"([BII)Z\")                                             \\\n-                                                                                                                        \\\n-  do_class(sun_nio_cs_iso8859_1_Encoder,  \"sun\/nio\/cs\/ISO_8859_1$Encoder\")                                              \\\n-  do_intrinsic(_encodeISOArray,     sun_nio_cs_iso8859_1_Encoder, encodeISOArray_name, encodeISOArray_signature, F_S)   \\\n-   do_name(     encodeISOArray_name,                             \"implEncodeISOArray\")                                  \\\n-   do_signature(encodeISOArray_signature,                        \"([CI[BII)I\")                                          \\\n-                                                                                                                        \\\n-  do_intrinsic(_encodeByteISOArray,     java_lang_StringCoding, encodeISOArray_name, indexOfI_signature,         F_S)   \\\n-                                                                                                                        \\\n-  do_class(java_math_BigInteger,                      \"java\/math\/BigInteger\")                                           \\\n-  do_intrinsic(_multiplyToLen,      java_math_BigInteger, multiplyToLen_name, multiplyToLen_signature, F_S)             \\\n-   do_name(     multiplyToLen_name,                             \"implMultiplyToLen\")                                    \\\n-   do_signature(multiplyToLen_signature,                        \"([II[II[I)[I\")                                         \\\n-                                                                                                                        \\\n-  do_intrinsic(_squareToLen, java_math_BigInteger, squareToLen_name, squareToLen_signature, F_S)                        \\\n-   do_name(     squareToLen_name,                             \"implSquareToLen\")                                        \\\n-   do_signature(squareToLen_signature,                        \"([II[II)[I\")                                             \\\n-                                                                                                                        \\\n-  do_intrinsic(_mulAdd, java_math_BigInteger, mulAdd_name, mulAdd_signature, F_S)                                       \\\n-   do_name(     mulAdd_name,                                  \"implMulAdd\")                                             \\\n-   do_signature(mulAdd_signature,                             \"([I[IIII)I\")                                             \\\n-                                                                                                                        \\\n-  do_intrinsic(_montgomeryMultiply,      java_math_BigInteger, montgomeryMultiply_name, montgomeryMultiply_signature, F_S) \\\n-   do_name(     montgomeryMultiply_name,                             \"implMontgomeryMultiply\")                          \\\n-   do_signature(montgomeryMultiply_signature,                        \"([I[I[IIJ[I)[I\")                                  \\\n-                                                                                                                        \\\n-  do_intrinsic(_montgomerySquare,      java_math_BigInteger, montgomerySquare_name, montgomerySquare_signature, F_S)    \\\n-   do_name(     montgomerySquare_name,                             \"implMontgomerySquare\")                              \\\n-   do_signature(montgomerySquare_signature,                        \"([I[IIJ[I)[I\")                                      \\\n-                                                                                                                        \\\n-  do_class(jdk_internal_util_ArraysSupport, \"jdk\/internal\/util\/ArraysSupport\")                                                          \\\n-  do_intrinsic(_vectorizedMismatch, jdk_internal_util_ArraysSupport, vectorizedMismatch_name, vectorizedMismatch_signature, F_S)\\\n-   do_name(vectorizedMismatch_name, \"vectorizedMismatch\")                                                               \\\n-   do_signature(vectorizedMismatch_signature, \"(Ljava\/lang\/Object;JLjava\/lang\/Object;JII)I\")                            \\\n-                                                                                                                        \\\n-  \/* java\/lang\/ref\/Reference *\/                                                                                         \\\n-  do_intrinsic(_Reference_get,            java_lang_ref_Reference, get_name,    void_object_signature, F_R)             \\\n-                                                                                                                        \\\n-  \/* support for com.sun.crypto.provider.AESCrypt and some of its callers *\/                                            \\\n-  do_class(com_sun_crypto_provider_aescrypt,      \"com\/sun\/crypto\/provider\/AESCrypt\")                                   \\\n-  do_intrinsic(_aescrypt_encryptBlock, com_sun_crypto_provider_aescrypt, encryptBlock_name, byteArray_int_byteArray_int_signature, F_R)   \\\n-  do_intrinsic(_aescrypt_decryptBlock, com_sun_crypto_provider_aescrypt, decryptBlock_name, byteArray_int_byteArray_int_signature, F_R)   \\\n-   do_name(     encryptBlock_name,                                 \"implEncryptBlock\")                                  \\\n-   do_name(     decryptBlock_name,                                 \"implDecryptBlock\")                                  \\\n-   do_signature(byteArray_int_byteArray_int_signature,             \"([BI[BI)V\")                                         \\\n-                                                                                                                        \\\n-  do_class(com_sun_crypto_provider_cipherBlockChaining,            \"com\/sun\/crypto\/provider\/CipherBlockChaining\")       \\\n-   do_intrinsic(_cipherBlockChaining_encryptAESCrypt, com_sun_crypto_provider_cipherBlockChaining, encrypt_name, byteArray_int_int_byteArray_int_signature, F_R)   \\\n-   do_intrinsic(_cipherBlockChaining_decryptAESCrypt, com_sun_crypto_provider_cipherBlockChaining, decrypt_name, byteArray_int_int_byteArray_int_signature, F_R)   \\\n-   do_name(     encrypt_name,                                      \"implEncrypt\")                                       \\\n-   do_name(     decrypt_name,                                      \"implDecrypt\")                                       \\\n-   do_signature(byteArray_int_int_byteArray_int_signature,         \"([BII[BI)I\")                                        \\\n-                                                                                                                        \\\n-  do_class(com_sun_crypto_provider_electronicCodeBook, \"com\/sun\/crypto\/provider\/ElectronicCodeBook\")                    \\\n-   do_intrinsic(_electronicCodeBook_encryptAESCrypt, com_sun_crypto_provider_electronicCodeBook, ecb_encrypt_name, byteArray_int_int_byteArray_int_signature, F_R)  \\\n-   do_intrinsic(_electronicCodeBook_decryptAESCrypt, com_sun_crypto_provider_electronicCodeBook, ecb_decrypt_name, byteArray_int_int_byteArray_int_signature, F_R)  \\\n-   do_name(ecb_encrypt_name, \"implECBEncrypt\")                                                                          \\\n-   do_name(ecb_decrypt_name, \"implECBDecrypt\")                                                                          \\\n-                                                                                                                        \\\n-  do_class(com_sun_crypto_provider_counterMode,      \"com\/sun\/crypto\/provider\/CounterMode\")                             \\\n-   do_intrinsic(_counterMode_AESCrypt, com_sun_crypto_provider_counterMode, crypt_name, byteArray_int_int_byteArray_int_signature, F_R)   \\\n-   do_name(     crypt_name,                                 \"implCrypt\")                                                    \\\n-                                                                                                                        \\\n-  \/* support for sun.security.provider.SHA *\/                                                                           \\\n-  do_class(sun_security_provider_sha,                              \"sun\/security\/provider\/SHA\")                         \\\n-  do_intrinsic(_sha_implCompress, sun_security_provider_sha, implCompress_name, implCompress_signature, F_R)            \\\n-   do_name(     implCompress_name,                                 \"implCompress0\")                                     \\\n-   do_signature(implCompress_signature,                            \"([BI)V\")                                            \\\n-                                                                                                                        \\\n-  \/* support for sun.security.provider.SHA2 *\/                                                                          \\\n-  do_class(sun_security_provider_sha2,                             \"sun\/security\/provider\/SHA2\")                        \\\n-  do_intrinsic(_sha2_implCompress, sun_security_provider_sha2, implCompress_name, implCompress_signature, F_R)          \\\n-                                                                                                                        \\\n-  \/* support for sun.security.provider.SHA5 *\/                                                                          \\\n-  do_class(sun_security_provider_sha5,                             \"sun\/security\/provider\/SHA5\")                        \\\n-  do_intrinsic(_sha5_implCompress, sun_security_provider_sha5, implCompress_name, implCompress_signature, F_R)          \\\n-                                                                                                                        \\\n-  \/* support for sun.security.provider.DigestBase *\/                                                                    \\\n-  do_class(sun_security_provider_digestbase,                       \"sun\/security\/provider\/DigestBase\")                  \\\n-  do_intrinsic(_digestBase_implCompressMB, sun_security_provider_digestbase, implCompressMB_name, implCompressMB_signature, F_R)   \\\n-   do_name(     implCompressMB_name,                               \"implCompressMultiBlock0\")                           \\\n-   do_signature(implCompressMB_signature,                          \"([BII)I\")                                           \\\n-                                                                                                                        \\\n-   \/* support for java.util.Base64.Encoder*\/                                                                            \\\n-  do_class(java_util_Base64_Encoder, \"java\/util\/Base64$Encoder\")                                                        \\\n-  do_intrinsic(_base64_encodeBlock, java_util_Base64_Encoder, encodeBlock_name, encodeBlock_signature, F_R)             \\\n-  do_name(encodeBlock_name, \"encodeBlock\")                                                                              \\\n-  do_signature(encodeBlock_signature, \"([BII[BIZ)V\")                                                                    \\\n-                                                                                                                        \\\n-  \/* support for com.sun.crypto.provider.GHASH *\/                                                                       \\\n-  do_class(com_sun_crypto_provider_ghash, \"com\/sun\/crypto\/provider\/GHASH\")                                              \\\n-  do_intrinsic(_ghash_processBlocks, com_sun_crypto_provider_ghash, processBlocks_name, ghash_processBlocks_signature, F_S) \\\n-   do_name(processBlocks_name, \"processBlocks\")                                                                         \\\n-   do_signature(ghash_processBlocks_signature, \"([BII[J[J)V\")                                                           \\\n-                                                                                                                        \\\n-  \/* support for java.util.zip *\/                                                                                       \\\n-  do_class(java_util_zip_CRC32,           \"java\/util\/zip\/CRC32\")                                                        \\\n-  do_intrinsic(_updateCRC32,               java_util_zip_CRC32,   update_name, int2_int_signature,               F_SN)  \\\n-   do_name(     update_name,                                      \"update\")                                             \\\n-  do_intrinsic(_updateBytesCRC32,          java_util_zip_CRC32,   updateBytes_name, updateBytes_signature,       F_SN)  \\\n-   do_name(     updateBytes_name,                                \"updateBytes0\")                                        \\\n-   do_signature(updateBytes_signature,                           \"(I[BII)I\")                                            \\\n-  do_intrinsic(_updateByteBufferCRC32,     java_util_zip_CRC32,   updateByteBuffer_name, updateByteBuffer_signature, F_SN) \\\n-   do_name(     updateByteBuffer_name,                           \"updateByteBuffer0\")                                   \\\n-   do_signature(updateByteBuffer_signature,                      \"(IJII)I\")                                             \\\n-                                                                                                                        \\\n-  \/* support for java.util.zip.CRC32C *\/                                                                                \\\n-  do_class(java_util_zip_CRC32C,          \"java\/util\/zip\/CRC32C\")                                                       \\\n-  do_intrinsic(_updateBytesCRC32C,         java_util_zip_CRC32C,  updateBytes_C_name, updateBytes_signature,       F_S) \\\n-   do_name(     updateBytes_C_name,                               \"updateBytes\")                                        \\\n-  do_intrinsic(_updateDirectByteBufferCRC32C, java_util_zip_CRC32C, updateDirectByteBuffer_C_name, updateByteBuffer_signature, F_S) \\\n-   do_name(    updateDirectByteBuffer_C_name,                     \"updateDirectByteBuffer\")                             \\\n-                                                                                                                        \\\n-   \/* support for java.util.zip.Adler32 *\/                                                                              \\\n-  do_class(java_util_zip_Adler32,        \"java\/util\/zip\/Adler32\")                                                       \\\n-  do_intrinsic(_updateBytesAdler32,       java_util_zip_Adler32,  updateBytes_C_name,  updateBytes_signature,  F_SN)    \\\n-  do_intrinsic(_updateByteBufferAdler32,  java_util_zip_Adler32,  updateByteBuffer_A_name,  updateByteBuffer_signature,  F_SN) \\\n-   do_name(     updateByteBuffer_A_name,                          \"updateByteBuffer\")                                   \\\n-                                                                                                                        \\\n-  \/* support for UnsafeConstants *\/                                                                                     \\\n-  do_class(jdk_internal_misc_UnsafeConstants,      \"jdk\/internal\/misc\/UnsafeConstants\")                                 \\\n-                                                                                                                        \\\n-  \/* support for Unsafe *\/                                                                                              \\\n-  do_class(jdk_internal_misc_Unsafe,               \"jdk\/internal\/misc\/Unsafe\")                                          \\\n-  do_class(sun_misc_Unsafe,                        \"sun\/misc\/Unsafe\")                                                   \\\n-                                                                                                                        \\\n-  do_intrinsic(_writeback0,               jdk_internal_misc_Unsafe,     writeback0_name, long_void_signature , F_RN)             \\\n-   do_name(     writeback0_name,                                        \"writeback0\")                                            \\\n-  do_intrinsic(_writebackPreSync0,        jdk_internal_misc_Unsafe,     writebackPreSync0_name, void_method_signature , F_RN)    \\\n-   do_name(     writebackPreSync0_name,                                 \"writebackPreSync0\")                                     \\\n-  do_intrinsic(_writebackPostSync0,       jdk_internal_misc_Unsafe,    writebackPostSync0_name, void_method_signature , F_RN)    \\\n-   do_name(     writebackPostSync0_name,                                \"writebackPostSync0\")                                    \\\n-  do_intrinsic(_allocateInstance,         jdk_internal_misc_Unsafe,     allocateInstance_name, allocateInstance_signature, F_RN) \\\n-   do_name(     allocateInstance_name,                                  \"allocateInstance\")                                      \\\n-   do_signature(allocateInstance_signature,                             \"(Ljava\/lang\/Class;)Ljava\/lang\/Object;\")                 \\\n-  do_intrinsic(_allocateUninitializedArray, jdk_internal_misc_Unsafe,   allocateUninitializedArray_name, newArray_signature,  F_R) \\\n-   do_name(     allocateUninitializedArray_name,                        \"allocateUninitializedArray0\")                           \\\n-  do_intrinsic(_copyMemory,               jdk_internal_misc_Unsafe,     copyMemory_name, copyMemory_signature,         F_RN)     \\\n-   do_name(     copyMemory_name,                                        \"copyMemory0\")                                           \\\n-   do_signature(copyMemory_signature,                                   \"(Ljava\/lang\/Object;JLjava\/lang\/Object;JJ)V\")            \\\n-  do_intrinsic(_loadFence,                jdk_internal_misc_Unsafe,     loadFence_name, loadFence_signature,           F_RN)     \\\n-   do_name(     loadFence_name,                                         \"loadFence\")                                             \\\n-   do_alias(    loadFence_signature,                                    void_method_signature)                                   \\\n-  do_intrinsic(_storeFence,               jdk_internal_misc_Unsafe,     storeFence_name, storeFence_signature,         F_RN)     \\\n-   do_name(     storeFence_name,                                        \"storeFence\")                                            \\\n-   do_alias(    storeFence_signature,                                   void_method_signature)                                   \\\n-  do_intrinsic(_fullFence,                jdk_internal_misc_Unsafe,     fullFence_name, fullFence_signature,           F_RN)     \\\n-   do_name(     fullFence_name,                                         \"fullFence\")                                             \\\n-   do_alias(    fullFence_signature,                                    void_method_signature)                                   \\\n-                                                                                                                        \\\n-  \/* Custom branch frequencies profiling support for JSR292 *\/                                                          \\\n-  do_class(java_lang_invoke_MethodHandleImpl,               \"java\/lang\/invoke\/MethodHandleImpl\")                        \\\n-  do_intrinsic(_profileBoolean, java_lang_invoke_MethodHandleImpl, profileBoolean_name, profileBoolean_signature, F_S)  \\\n-   do_name(     profileBoolean_name,                             \"profileBoolean\")                                      \\\n-   do_signature(profileBoolean_signature,                        \"(Z[I)Z\")                                              \\\n-  do_intrinsic(_isCompileConstant, java_lang_invoke_MethodHandleImpl, isCompileConstant_name, isCompileConstant_signature, F_S) \\\n-   do_name(     isCompileConstant_name,                          \"isCompileConstant\")                                   \\\n-   do_alias(    isCompileConstant_signature,                      object_boolean_signature)                             \\\n-                                                                                                                        \\\n-  \/* unsafe memory references (there are a lot of them...) *\/                                                           \\\n-  do_signature(getReference_signature,    \"(Ljava\/lang\/Object;J)Ljava\/lang\/Object;\")                                    \\\n-  do_signature(putReference_signature,    \"(Ljava\/lang\/Object;JLjava\/lang\/Object;)V\")                                   \\\n-  do_signature(getBoolean_signature,      \"(Ljava\/lang\/Object;J)Z\")                                                     \\\n-  do_signature(putBoolean_signature,      \"(Ljava\/lang\/Object;JZ)V\")                                                    \\\n-  do_signature(getByte_signature,         \"(Ljava\/lang\/Object;J)B\")                                                     \\\n-  do_signature(putByte_signature,         \"(Ljava\/lang\/Object;JB)V\")                                                    \\\n-  do_signature(getShort_signature,        \"(Ljava\/lang\/Object;J)S\")                                                     \\\n-  do_signature(putShort_signature,        \"(Ljava\/lang\/Object;JS)V\")                                                    \\\n-  do_signature(getChar_signature,         \"(Ljava\/lang\/Object;J)C\")                                                     \\\n-  do_signature(putChar_signature,         \"(Ljava\/lang\/Object;JC)V\")                                                    \\\n-  do_signature(getInt_signature,          \"(Ljava\/lang\/Object;J)I\")                                                     \\\n-  do_signature(putInt_signature,          \"(Ljava\/lang\/Object;JI)V\")                                                    \\\n-  do_signature(getLong_signature,         \"(Ljava\/lang\/Object;J)J\")                                                     \\\n-  do_signature(putLong_signature,         \"(Ljava\/lang\/Object;JJ)V\")                                                    \\\n-  do_signature(getFloat_signature,        \"(Ljava\/lang\/Object;J)F\")                                                     \\\n-  do_signature(putFloat_signature,        \"(Ljava\/lang\/Object;JF)V\")                                                    \\\n-  do_signature(getDouble_signature,       \"(Ljava\/lang\/Object;J)D\")                                                     \\\n-  do_signature(putDouble_signature,       \"(Ljava\/lang\/Object;JD)V\")                                                    \\\n-                                                                                                                        \\\n-  do_name(getReference_name,\"getReference\")     do_name(putReference_name,\"putReference\")                               \\\n-  do_name(getBoolean_name,\"getBoolean\")         do_name(putBoolean_name,\"putBoolean\")                                   \\\n-  do_name(getByte_name,\"getByte\")               do_name(putByte_name,\"putByte\")                                         \\\n-  do_name(getShort_name,\"getShort\")             do_name(putShort_name,\"putShort\")                                       \\\n-  do_name(getChar_name,\"getChar\")               do_name(putChar_name,\"putChar\")                                         \\\n-  do_name(getInt_name,\"getInt\")                 do_name(putInt_name,\"putInt\")                                           \\\n-  do_name(getLong_name,\"getLong\")               do_name(putLong_name,\"putLong\")                                         \\\n-  do_name(getFloat_name,\"getFloat\")             do_name(putFloat_name,\"putFloat\")                                       \\\n-  do_name(getDouble_name,\"getDouble\")           do_name(putDouble_name,\"putDouble\")                                     \\\n-                                                                                                                        \\\n-  do_intrinsic(_getReference,       jdk_internal_misc_Unsafe,     getReference_name, getReference_signature,     F_RN)  \\\n-  do_intrinsic(_getBoolean,         jdk_internal_misc_Unsafe,     getBoolean_name, getBoolean_signature,         F_RN)  \\\n-  do_intrinsic(_getByte,            jdk_internal_misc_Unsafe,     getByte_name, getByte_signature,               F_RN)  \\\n-  do_intrinsic(_getShort,           jdk_internal_misc_Unsafe,     getShort_name, getShort_signature,             F_RN)  \\\n-  do_intrinsic(_getChar,            jdk_internal_misc_Unsafe,     getChar_name, getChar_signature,               F_RN)  \\\n-  do_intrinsic(_getInt,             jdk_internal_misc_Unsafe,     getInt_name, getInt_signature,                 F_RN)  \\\n-  do_intrinsic(_getLong,            jdk_internal_misc_Unsafe,     getLong_name, getLong_signature,               F_RN)  \\\n-  do_intrinsic(_getFloat,           jdk_internal_misc_Unsafe,     getFloat_name, getFloat_signature,             F_RN)  \\\n-  do_intrinsic(_getDouble,          jdk_internal_misc_Unsafe,     getDouble_name, getDouble_signature,           F_RN)  \\\n-  do_intrinsic(_putReference,       jdk_internal_misc_Unsafe,     putReference_name, putReference_signature,     F_RN)  \\\n-  do_intrinsic(_putBoolean,         jdk_internal_misc_Unsafe,     putBoolean_name, putBoolean_signature,         F_RN)  \\\n-  do_intrinsic(_putByte,            jdk_internal_misc_Unsafe,     putByte_name, putByte_signature,               F_RN)  \\\n-  do_intrinsic(_putShort,           jdk_internal_misc_Unsafe,     putShort_name, putShort_signature,             F_RN)  \\\n-  do_intrinsic(_putChar,            jdk_internal_misc_Unsafe,     putChar_name, putChar_signature,               F_RN)  \\\n-  do_intrinsic(_putInt,             jdk_internal_misc_Unsafe,     putInt_name, putInt_signature,                 F_RN)  \\\n-  do_intrinsic(_putLong,            jdk_internal_misc_Unsafe,     putLong_name, putLong_signature,               F_RN)  \\\n-  do_intrinsic(_putFloat,           jdk_internal_misc_Unsafe,     putFloat_name, putFloat_signature,             F_RN)  \\\n-  do_intrinsic(_putDouble,          jdk_internal_misc_Unsafe,     putDouble_name, putDouble_signature,           F_RN)  \\\n-                                                                                                                        \\\n-  do_name(getReferenceVolatile_name,\"getReferenceVolatile\")   do_name(putReferenceVolatile_name,\"putReferenceVolatile\") \\\n-  do_name(getBooleanVolatile_name,\"getBooleanVolatile\")       do_name(putBooleanVolatile_name,\"putBooleanVolatile\")     \\\n-  do_name(getByteVolatile_name,\"getByteVolatile\")             do_name(putByteVolatile_name,\"putByteVolatile\")           \\\n-  do_name(getShortVolatile_name,\"getShortVolatile\")           do_name(putShortVolatile_name,\"putShortVolatile\")         \\\n-  do_name(getCharVolatile_name,\"getCharVolatile\")             do_name(putCharVolatile_name,\"putCharVolatile\")           \\\n-  do_name(getIntVolatile_name,\"getIntVolatile\")               do_name(putIntVolatile_name,\"putIntVolatile\")             \\\n-  do_name(getLongVolatile_name,\"getLongVolatile\")             do_name(putLongVolatile_name,\"putLongVolatile\")           \\\n-  do_name(getFloatVolatile_name,\"getFloatVolatile\")           do_name(putFloatVolatile_name,\"putFloatVolatile\")         \\\n-  do_name(getDoubleVolatile_name,\"getDoubleVolatile\")         do_name(putDoubleVolatile_name,\"putDoubleVolatile\")       \\\n-                                                                                                                        \\\n-  do_intrinsic(_getReferenceVolatile,     jdk_internal_misc_Unsafe,     getReferenceVolatile_name, getReference_signature, F_RN)  \\\n-  do_intrinsic(_getBooleanVolatile,       jdk_internal_misc_Unsafe,     getBooleanVolatile_name, getBoolean_signature,     F_RN)  \\\n-  do_intrinsic(_getByteVolatile,          jdk_internal_misc_Unsafe,     getByteVolatile_name, getByte_signature,           F_RN)  \\\n-  do_intrinsic(_getShortVolatile,         jdk_internal_misc_Unsafe,     getShortVolatile_name, getShort_signature,         F_RN)  \\\n-  do_intrinsic(_getCharVolatile,          jdk_internal_misc_Unsafe,     getCharVolatile_name, getChar_signature,           F_RN)  \\\n-  do_intrinsic(_getIntVolatile,           jdk_internal_misc_Unsafe,     getIntVolatile_name, getInt_signature,             F_RN)  \\\n-  do_intrinsic(_getLongVolatile,          jdk_internal_misc_Unsafe,     getLongVolatile_name, getLong_signature,           F_RN)  \\\n-  do_intrinsic(_getFloatVolatile,         jdk_internal_misc_Unsafe,     getFloatVolatile_name, getFloat_signature,         F_RN)  \\\n-  do_intrinsic(_getDoubleVolatile,        jdk_internal_misc_Unsafe,     getDoubleVolatile_name, getDouble_signature,       F_RN)  \\\n-  do_intrinsic(_putReferenceVolatile,     jdk_internal_misc_Unsafe,     putReferenceVolatile_name, putReference_signature, F_RN)  \\\n-  do_intrinsic(_putBooleanVolatile,       jdk_internal_misc_Unsafe,     putBooleanVolatile_name, putBoolean_signature,     F_RN)  \\\n-  do_intrinsic(_putByteVolatile,          jdk_internal_misc_Unsafe,     putByteVolatile_name, putByte_signature,           F_RN)  \\\n-  do_intrinsic(_putShortVolatile,         jdk_internal_misc_Unsafe,     putShortVolatile_name, putShort_signature,         F_RN)  \\\n-  do_intrinsic(_putCharVolatile,          jdk_internal_misc_Unsafe,     putCharVolatile_name, putChar_signature,           F_RN)  \\\n-  do_intrinsic(_putIntVolatile,           jdk_internal_misc_Unsafe,     putIntVolatile_name, putInt_signature,             F_RN)  \\\n-  do_intrinsic(_putLongVolatile,          jdk_internal_misc_Unsafe,     putLongVolatile_name, putLong_signature,           F_RN)  \\\n-  do_intrinsic(_putFloatVolatile,         jdk_internal_misc_Unsafe,     putFloatVolatile_name, putFloat_signature,         F_RN)  \\\n-  do_intrinsic(_putDoubleVolatile,        jdk_internal_misc_Unsafe,     putDoubleVolatile_name, putDouble_signature,       F_RN)  \\\n-                                                                                                                        \\\n-  do_name(getReferenceOpaque_name,\"getReferenceOpaque\") do_name(putReferenceOpaque_name,\"putReferenceOpaque\")           \\\n-  do_name(getBooleanOpaque_name,\"getBooleanOpaque\")     do_name(putBooleanOpaque_name,\"putBooleanOpaque\")               \\\n-  do_name(getByteOpaque_name,\"getByteOpaque\")           do_name(putByteOpaque_name,\"putByteOpaque\")                     \\\n-  do_name(getShortOpaque_name,\"getShortOpaque\")         do_name(putShortOpaque_name,\"putShortOpaque\")                   \\\n-  do_name(getCharOpaque_name,\"getCharOpaque\")           do_name(putCharOpaque_name,\"putCharOpaque\")                     \\\n-  do_name(getIntOpaque_name,\"getIntOpaque\")             do_name(putIntOpaque_name,\"putIntOpaque\")                       \\\n-  do_name(getLongOpaque_name,\"getLongOpaque\")           do_name(putLongOpaque_name,\"putLongOpaque\")                     \\\n-  do_name(getFloatOpaque_name,\"getFloatOpaque\")         do_name(putFloatOpaque_name,\"putFloatOpaque\")                   \\\n-  do_name(getDoubleOpaque_name,\"getDoubleOpaque\")       do_name(putDoubleOpaque_name,\"putDoubleOpaque\")                 \\\n-                                                                                                                        \\\n-  do_intrinsic(_getReferenceOpaque,       jdk_internal_misc_Unsafe,        getReferenceOpaque_name, getReference_signature, F_R)  \\\n-  do_intrinsic(_getBooleanOpaque,         jdk_internal_misc_Unsafe,        getBooleanOpaque_name, getBoolean_signature,     F_R)  \\\n-  do_intrinsic(_getByteOpaque,            jdk_internal_misc_Unsafe,        getByteOpaque_name, getByte_signature,           F_R)  \\\n-  do_intrinsic(_getShortOpaque,           jdk_internal_misc_Unsafe,        getShortOpaque_name, getShort_signature,         F_R)  \\\n-  do_intrinsic(_getCharOpaque,            jdk_internal_misc_Unsafe,        getCharOpaque_name, getChar_signature,           F_R)  \\\n-  do_intrinsic(_getIntOpaque,             jdk_internal_misc_Unsafe,        getIntOpaque_name, getInt_signature,             F_R)  \\\n-  do_intrinsic(_getLongOpaque,            jdk_internal_misc_Unsafe,        getLongOpaque_name, getLong_signature,           F_R)  \\\n-  do_intrinsic(_getFloatOpaque,           jdk_internal_misc_Unsafe,        getFloatOpaque_name, getFloat_signature,         F_R)  \\\n-  do_intrinsic(_getDoubleOpaque,          jdk_internal_misc_Unsafe,        getDoubleOpaque_name, getDouble_signature,       F_R)  \\\n-  do_intrinsic(_putReferenceOpaque,       jdk_internal_misc_Unsafe,        putReferenceOpaque_name, putReference_signature, F_R)  \\\n-  do_intrinsic(_putBooleanOpaque,         jdk_internal_misc_Unsafe,        putBooleanOpaque_name, putBoolean_signature,     F_R)  \\\n-  do_intrinsic(_putByteOpaque,            jdk_internal_misc_Unsafe,        putByteOpaque_name, putByte_signature,           F_R)  \\\n-  do_intrinsic(_putShortOpaque,           jdk_internal_misc_Unsafe,        putShortOpaque_name, putShort_signature,         F_R)  \\\n-  do_intrinsic(_putCharOpaque,            jdk_internal_misc_Unsafe,        putCharOpaque_name, putChar_signature,           F_R)  \\\n-  do_intrinsic(_putIntOpaque,             jdk_internal_misc_Unsafe,        putIntOpaque_name, putInt_signature,             F_R)  \\\n-  do_intrinsic(_putLongOpaque,            jdk_internal_misc_Unsafe,        putLongOpaque_name, putLong_signature,           F_R)  \\\n-  do_intrinsic(_putFloatOpaque,           jdk_internal_misc_Unsafe,        putFloatOpaque_name, putFloat_signature,         F_R)  \\\n-  do_intrinsic(_putDoubleOpaque,          jdk_internal_misc_Unsafe,        putDoubleOpaque_name, putDouble_signature,       F_R)  \\\n-                                                                                                                        \\\n-  do_name(getReferenceAcquire_name,  \"getReferenceAcquire\") do_name(putReferenceRelease_name,  \"putReferenceRelease\")   \\\n-  do_name(getBooleanAcquire_name, \"getBooleanAcquire\")      do_name(putBooleanRelease_name, \"putBooleanRelease\")        \\\n-  do_name(getByteAcquire_name,    \"getByteAcquire\")         do_name(putByteRelease_name,    \"putByteRelease\")           \\\n-  do_name(getShortAcquire_name,   \"getShortAcquire\")        do_name(putShortRelease_name,   \"putShortRelease\")          \\\n-  do_name(getCharAcquire_name,    \"getCharAcquire\")         do_name(putCharRelease_name,    \"putCharRelease\")           \\\n-  do_name(getIntAcquire_name,     \"getIntAcquire\")          do_name(putIntRelease_name,     \"putIntRelease\")            \\\n-  do_name(getLongAcquire_name,    \"getLongAcquire\")         do_name(putLongRelease_name,    \"putLongRelease\")           \\\n-  do_name(getFloatAcquire_name,   \"getFloatAcquire\")        do_name(putFloatRelease_name,   \"putFloatRelease\")          \\\n-  do_name(getDoubleAcquire_name,  \"getDoubleAcquire\")       do_name(putDoubleRelease_name,  \"putDoubleRelease\")         \\\n-                                                                                                                        \\\n-  do_intrinsic(_getReferenceAcquire,     jdk_internal_misc_Unsafe,        getReferenceAcquire_name, getReference_signature, F_R)  \\\n-  do_intrinsic(_getBooleanAcquire,       jdk_internal_misc_Unsafe,        getBooleanAcquire_name, getBoolean_signature,     F_R)  \\\n-  do_intrinsic(_getByteAcquire,          jdk_internal_misc_Unsafe,        getByteAcquire_name, getByte_signature,           F_R)  \\\n-  do_intrinsic(_getShortAcquire,         jdk_internal_misc_Unsafe,        getShortAcquire_name, getShort_signature,         F_R)  \\\n-  do_intrinsic(_getCharAcquire,          jdk_internal_misc_Unsafe,        getCharAcquire_name, getChar_signature,           F_R)  \\\n-  do_intrinsic(_getIntAcquire,           jdk_internal_misc_Unsafe,        getIntAcquire_name, getInt_signature,             F_R)  \\\n-  do_intrinsic(_getLongAcquire,          jdk_internal_misc_Unsafe,        getLongAcquire_name, getLong_signature,           F_R)  \\\n-  do_intrinsic(_getFloatAcquire,         jdk_internal_misc_Unsafe,        getFloatAcquire_name, getFloat_signature,         F_R)  \\\n-  do_intrinsic(_getDoubleAcquire,        jdk_internal_misc_Unsafe,        getDoubleAcquire_name, getDouble_signature,       F_R)  \\\n-  do_intrinsic(_putReferenceRelease,     jdk_internal_misc_Unsafe,        putReferenceRelease_name, putReference_signature, F_R)  \\\n-  do_intrinsic(_putBooleanRelease,       jdk_internal_misc_Unsafe,        putBooleanRelease_name, putBoolean_signature,     F_R)  \\\n-  do_intrinsic(_putByteRelease,          jdk_internal_misc_Unsafe,        putByteRelease_name, putByte_signature,           F_R)  \\\n-  do_intrinsic(_putShortRelease,         jdk_internal_misc_Unsafe,        putShortRelease_name, putShort_signature,         F_R)  \\\n-  do_intrinsic(_putCharRelease,          jdk_internal_misc_Unsafe,        putCharRelease_name, putChar_signature,           F_R)  \\\n-  do_intrinsic(_putIntRelease,           jdk_internal_misc_Unsafe,        putIntRelease_name, putInt_signature,             F_R)  \\\n-  do_intrinsic(_putLongRelease,          jdk_internal_misc_Unsafe,        putLongRelease_name, putLong_signature,           F_R)  \\\n-  do_intrinsic(_putFloatRelease,         jdk_internal_misc_Unsafe,        putFloatRelease_name, putFloat_signature,         F_R)  \\\n-  do_intrinsic(_putDoubleRelease,        jdk_internal_misc_Unsafe,        putDoubleRelease_name, putDouble_signature,       F_R)  \\\n-                                                                                                                        \\\n-  do_name(getShortUnaligned_name,\"getShortUnaligned\")     do_name(putShortUnaligned_name,\"putShortUnaligned\")           \\\n-  do_name(getCharUnaligned_name,\"getCharUnaligned\")       do_name(putCharUnaligned_name,\"putCharUnaligned\")             \\\n-  do_name(getIntUnaligned_name,\"getIntUnaligned\")         do_name(putIntUnaligned_name,\"putIntUnaligned\")               \\\n-  do_name(getLongUnaligned_name,\"getLongUnaligned\")       do_name(putLongUnaligned_name,\"putLongUnaligned\")             \\\n-                                                                                                                        \\\n-  do_intrinsic(_getShortUnaligned,         jdk_internal_misc_Unsafe,    getShortUnaligned_name, getShort_signature,     F_R)  \\\n-  do_intrinsic(_getCharUnaligned,          jdk_internal_misc_Unsafe,    getCharUnaligned_name, getChar_signature,       F_R)  \\\n-  do_intrinsic(_getIntUnaligned,           jdk_internal_misc_Unsafe,    getIntUnaligned_name, getInt_signature,         F_R)  \\\n-  do_intrinsic(_getLongUnaligned,          jdk_internal_misc_Unsafe,    getLongUnaligned_name, getLong_signature,       F_R)  \\\n-  do_intrinsic(_putShortUnaligned,         jdk_internal_misc_Unsafe,    putShortUnaligned_name, putShort_signature,     F_R)  \\\n-  do_intrinsic(_putCharUnaligned,          jdk_internal_misc_Unsafe,    putCharUnaligned_name, putChar_signature,       F_R)  \\\n-  do_intrinsic(_putIntUnaligned,           jdk_internal_misc_Unsafe,    putIntUnaligned_name, putInt_signature,         F_R)  \\\n-  do_intrinsic(_putLongUnaligned,          jdk_internal_misc_Unsafe,    putLongUnaligned_name, putLong_signature,       F_R)  \\\n-                                                                                                                        \\\n-  do_signature(compareAndSetReference_signature,      \"(Ljava\/lang\/Object;JLjava\/lang\/Object;Ljava\/lang\/Object;)Z\")        \\\n-  do_signature(compareAndExchangeReference_signature, \"(Ljava\/lang\/Object;JLjava\/lang\/Object;Ljava\/lang\/Object;)Ljava\/lang\/Object;\") \\\n-  do_signature(compareAndSetLong_signature,        \"(Ljava\/lang\/Object;JJJ)Z\")                                          \\\n-  do_signature(compareAndExchangeLong_signature,   \"(Ljava\/lang\/Object;JJJ)J\")                                          \\\n-  do_signature(compareAndSetInt_signature,         \"(Ljava\/lang\/Object;JII)Z\")                                          \\\n-  do_signature(compareAndExchangeInt_signature,    \"(Ljava\/lang\/Object;JII)I\")                                          \\\n-  do_signature(compareAndSetByte_signature,        \"(Ljava\/lang\/Object;JBB)Z\")                                          \\\n-  do_signature(compareAndExchangeByte_signature,   \"(Ljava\/lang\/Object;JBB)B\")                                          \\\n-  do_signature(compareAndSetShort_signature,       \"(Ljava\/lang\/Object;JSS)Z\")                                          \\\n-  do_signature(compareAndExchangeShort_signature,  \"(Ljava\/lang\/Object;JSS)S\")                                          \\\n-                                                                                                                        \\\n-  do_name(compareAndSetReference_name,              \"compareAndSetReference\")                                           \\\n-  do_name(compareAndExchangeReference_name,         \"compareAndExchangeReference\")                                      \\\n-  do_name(compareAndExchangeReferenceAcquire_name,  \"compareAndExchangeReferenceAcquire\")                               \\\n-  do_name(compareAndExchangeReferenceRelease_name,  \"compareAndExchangeReferenceRelease\")                               \\\n-  do_name(compareAndSetLong_name,                   \"compareAndSetLong\")                                                \\\n-  do_name(compareAndExchangeLong_name,              \"compareAndExchangeLong\")                                           \\\n-  do_name(compareAndExchangeLongAcquire_name,       \"compareAndExchangeLongAcquire\")                                    \\\n-  do_name(compareAndExchangeLongRelease_name,       \"compareAndExchangeLongRelease\")                                    \\\n-  do_name(compareAndSetInt_name,                    \"compareAndSetInt\")                                                 \\\n-  do_name(compareAndExchangeInt_name,               \"compareAndExchangeInt\")                                            \\\n-  do_name(compareAndExchangeIntAcquire_name,        \"compareAndExchangeIntAcquire\")                                     \\\n-  do_name(compareAndExchangeIntRelease_name,        \"compareAndExchangeIntRelease\")                                     \\\n-  do_name(compareAndSetByte_name,                   \"compareAndSetByte\")                                                \\\n-  do_name(compareAndExchangeByte_name,              \"compareAndExchangeByte\")                                           \\\n-  do_name(compareAndExchangeByteAcquire_name,       \"compareAndExchangeByteAcquire\")                                    \\\n-  do_name(compareAndExchangeByteRelease_name,       \"compareAndExchangeByteRelease\")                                    \\\n-  do_name(compareAndSetShort_name,                  \"compareAndSetShort\")                                               \\\n-  do_name(compareAndExchangeShort_name,             \"compareAndExchangeShort\")                                          \\\n-  do_name(compareAndExchangeShortAcquire_name,      \"compareAndExchangeShortAcquire\")                                   \\\n-  do_name(compareAndExchangeShortRelease_name,      \"compareAndExchangeShortRelease\")                                   \\\n-                                                                                                                        \\\n-  do_name(weakCompareAndSetReferencePlain_name,     \"weakCompareAndSetReferencePlain\")                                  \\\n-  do_name(weakCompareAndSetReferenceAcquire_name,   \"weakCompareAndSetReferenceAcquire\")                                \\\n-  do_name(weakCompareAndSetReferenceRelease_name,   \"weakCompareAndSetReferenceRelease\")                                \\\n-  do_name(weakCompareAndSetReference_name,          \"weakCompareAndSetReference\")                                       \\\n-  do_name(weakCompareAndSetLongPlain_name,          \"weakCompareAndSetLongPlain\")                                       \\\n-  do_name(weakCompareAndSetLongAcquire_name,        \"weakCompareAndSetLongAcquire\")                                     \\\n-  do_name(weakCompareAndSetLongRelease_name,        \"weakCompareAndSetLongRelease\")                                     \\\n-  do_name(weakCompareAndSetLong_name,               \"weakCompareAndSetLong\")                                            \\\n-  do_name(weakCompareAndSetIntPlain_name,           \"weakCompareAndSetIntPlain\")                                        \\\n-  do_name(weakCompareAndSetIntAcquire_name,         \"weakCompareAndSetIntAcquire\")                                      \\\n-  do_name(weakCompareAndSetIntRelease_name,         \"weakCompareAndSetIntRelease\")                                      \\\n-  do_name(weakCompareAndSetInt_name,                \"weakCompareAndSetInt\")                                             \\\n-  do_name(weakCompareAndSetBytePlain_name,          \"weakCompareAndSetBytePlain\")                                       \\\n-  do_name(weakCompareAndSetByteAcquire_name,        \"weakCompareAndSetByteAcquire\")                                     \\\n-  do_name(weakCompareAndSetByteRelease_name,        \"weakCompareAndSetByteRelease\")                                     \\\n-  do_name(weakCompareAndSetByte_name,               \"weakCompareAndSetByte\")                                            \\\n-  do_name(weakCompareAndSetShortPlain_name,         \"weakCompareAndSetShortPlain\")                                      \\\n-  do_name(weakCompareAndSetShortAcquire_name,       \"weakCompareAndSetShortAcquire\")                                    \\\n-  do_name(weakCompareAndSetShortRelease_name,       \"weakCompareAndSetShortRelease\")                                    \\\n-  do_name(weakCompareAndSetShort_name,              \"weakCompareAndSetShort\")                                           \\\n-                                                                                                                        \\\n-  do_intrinsic(_compareAndSetReference,              jdk_internal_misc_Unsafe,  compareAndSetReference_name,              compareAndSetReference_signature,      F_RN) \\\n-  do_intrinsic(_compareAndExchangeReference,         jdk_internal_misc_Unsafe,  compareAndExchangeReference_name,         compareAndExchangeReference_signature, F_RN) \\\n-  do_intrinsic(_compareAndExchangeReferenceAcquire,  jdk_internal_misc_Unsafe,  compareAndExchangeReferenceAcquire_name,  compareAndExchangeReference_signature, F_R)  \\\n-  do_intrinsic(_compareAndExchangeReferenceRelease,  jdk_internal_misc_Unsafe,  compareAndExchangeReferenceRelease_name,  compareAndExchangeReference_signature, F_R)  \\\n-  do_intrinsic(_compareAndSetLong,                jdk_internal_misc_Unsafe,  compareAndSetLong_name,                compareAndSetLong_signature,        F_RN) \\\n-  do_intrinsic(_compareAndExchangeLong,           jdk_internal_misc_Unsafe,  compareAndExchangeLong_name,           compareAndExchangeLong_signature,   F_RN) \\\n-  do_intrinsic(_compareAndExchangeLongAcquire,    jdk_internal_misc_Unsafe,  compareAndExchangeLongAcquire_name,    compareAndExchangeLong_signature,   F_R)  \\\n-  do_intrinsic(_compareAndExchangeLongRelease,    jdk_internal_misc_Unsafe,  compareAndExchangeLongRelease_name,    compareAndExchangeLong_signature,   F_R)  \\\n-  do_intrinsic(_compareAndSetInt,                 jdk_internal_misc_Unsafe,  compareAndSetInt_name,                 compareAndSetInt_signature,         F_RN) \\\n-  do_intrinsic(_compareAndExchangeInt,            jdk_internal_misc_Unsafe,  compareAndExchangeInt_name,            compareAndExchangeInt_signature,    F_RN) \\\n-  do_intrinsic(_compareAndExchangeIntAcquire,     jdk_internal_misc_Unsafe,  compareAndExchangeIntAcquire_name,     compareAndExchangeInt_signature,    F_R)  \\\n-  do_intrinsic(_compareAndExchangeIntRelease,     jdk_internal_misc_Unsafe,  compareAndExchangeIntRelease_name,     compareAndExchangeInt_signature,    F_R)  \\\n-  do_intrinsic(_compareAndSetByte,                jdk_internal_misc_Unsafe,  compareAndSetByte_name,                compareAndSetByte_signature,        F_R)  \\\n-  do_intrinsic(_compareAndExchangeByte,           jdk_internal_misc_Unsafe,  compareAndExchangeByte_name,           compareAndExchangeByte_signature,   F_R)  \\\n-  do_intrinsic(_compareAndExchangeByteAcquire,    jdk_internal_misc_Unsafe,  compareAndExchangeByteAcquire_name,    compareAndExchangeByte_signature,   F_R)  \\\n-  do_intrinsic(_compareAndExchangeByteRelease,    jdk_internal_misc_Unsafe,  compareAndExchangeByteRelease_name,    compareAndExchangeByte_signature,   F_R)  \\\n-  do_intrinsic(_compareAndSetShort,               jdk_internal_misc_Unsafe,  compareAndSetShort_name,               compareAndSetShort_signature,       F_R)  \\\n-  do_intrinsic(_compareAndExchangeShort,          jdk_internal_misc_Unsafe,  compareAndExchangeShort_name,          compareAndExchangeShort_signature,  F_R)  \\\n-  do_intrinsic(_compareAndExchangeShortAcquire,   jdk_internal_misc_Unsafe,  compareAndExchangeShortAcquire_name,   compareAndExchangeShort_signature,  F_R)  \\\n-  do_intrinsic(_compareAndExchangeShortRelease,   jdk_internal_misc_Unsafe,  compareAndExchangeShortRelease_name,   compareAndExchangeShort_signature,  F_R)  \\\n-                                                                                                                                                             \\\n-  do_intrinsic(_weakCompareAndSetReferencePlain,  jdk_internal_misc_Unsafe,  weakCompareAndSetReferencePlain_name,     compareAndSetReference_signature,      F_R) \\\n-  do_intrinsic(_weakCompareAndSetReferenceAcquire,jdk_internal_misc_Unsafe,  weakCompareAndSetReferenceAcquire_name,   compareAndSetReference_signature,      F_R) \\\n-  do_intrinsic(_weakCompareAndSetReferenceRelease,jdk_internal_misc_Unsafe,  weakCompareAndSetReferenceRelease_name,   compareAndSetReference_signature,      F_R) \\\n-  do_intrinsic(_weakCompareAndSetReference,       jdk_internal_misc_Unsafe,  weakCompareAndSetReference_name,          compareAndSetReference_signature,      F_R) \\\n-  do_intrinsic(_weakCompareAndSetLongPlain,       jdk_internal_misc_Unsafe,  weakCompareAndSetLongPlain_name,       compareAndSetLong_signature,        F_R) \\\n-  do_intrinsic(_weakCompareAndSetLongAcquire,     jdk_internal_misc_Unsafe,  weakCompareAndSetLongAcquire_name,     compareAndSetLong_signature,        F_R) \\\n-  do_intrinsic(_weakCompareAndSetLongRelease,     jdk_internal_misc_Unsafe,  weakCompareAndSetLongRelease_name,     compareAndSetLong_signature,        F_R) \\\n-  do_intrinsic(_weakCompareAndSetLong,            jdk_internal_misc_Unsafe,  weakCompareAndSetLong_name,            compareAndSetLong_signature,        F_R) \\\n-  do_intrinsic(_weakCompareAndSetIntPlain,        jdk_internal_misc_Unsafe,  weakCompareAndSetIntPlain_name,        compareAndSetInt_signature,         F_R) \\\n-  do_intrinsic(_weakCompareAndSetIntAcquire,      jdk_internal_misc_Unsafe,  weakCompareAndSetIntAcquire_name,      compareAndSetInt_signature,         F_R) \\\n-  do_intrinsic(_weakCompareAndSetIntRelease,      jdk_internal_misc_Unsafe,  weakCompareAndSetIntRelease_name,      compareAndSetInt_signature,         F_R) \\\n-  do_intrinsic(_weakCompareAndSetInt,             jdk_internal_misc_Unsafe,  weakCompareAndSetInt_name,             compareAndSetInt_signature,         F_R) \\\n-  do_intrinsic(_weakCompareAndSetBytePlain,       jdk_internal_misc_Unsafe,  weakCompareAndSetBytePlain_name,       compareAndSetByte_signature,        F_R) \\\n-  do_intrinsic(_weakCompareAndSetByteAcquire,     jdk_internal_misc_Unsafe,  weakCompareAndSetByteAcquire_name,     compareAndSetByte_signature,        F_R) \\\n-  do_intrinsic(_weakCompareAndSetByteRelease,     jdk_internal_misc_Unsafe,  weakCompareAndSetByteRelease_name,     compareAndSetByte_signature,        F_R) \\\n-  do_intrinsic(_weakCompareAndSetByte,            jdk_internal_misc_Unsafe,  weakCompareAndSetByte_name,            compareAndSetByte_signature,        F_R) \\\n-  do_intrinsic(_weakCompareAndSetShortPlain,      jdk_internal_misc_Unsafe,  weakCompareAndSetShortPlain_name,      compareAndSetShort_signature,       F_R) \\\n-  do_intrinsic(_weakCompareAndSetShortAcquire,    jdk_internal_misc_Unsafe,  weakCompareAndSetShortAcquire_name,    compareAndSetShort_signature,       F_R) \\\n-  do_intrinsic(_weakCompareAndSetShortRelease,    jdk_internal_misc_Unsafe,  weakCompareAndSetShortRelease_name,    compareAndSetShort_signature,       F_R) \\\n-  do_intrinsic(_weakCompareAndSetShort,           jdk_internal_misc_Unsafe,  weakCompareAndSetShort_name,           compareAndSetShort_signature,       F_R) \\\n-                           \\\n-  do_intrinsic(_getAndAddInt,             jdk_internal_misc_Unsafe,     getAndAddInt_name, getAndAddInt_signature, F_R)       \\\n-   do_name(     getAndAddInt_name,                                      \"getAndAddInt\")                                       \\\n-   do_signature(getAndAddInt_signature,                                 \"(Ljava\/lang\/Object;JI)I\" )                           \\\n-  do_intrinsic(_getAndAddLong,            jdk_internal_misc_Unsafe,     getAndAddLong_name, getAndAddLong_signature, F_R)     \\\n-   do_name(     getAndAddLong_name,                                     \"getAndAddLong\")                                      \\\n-   do_signature(getAndAddLong_signature,                                \"(Ljava\/lang\/Object;JJ)J\" )                           \\\n-  do_intrinsic(_getAndAddByte,            jdk_internal_misc_Unsafe,     getAndAddByte_name, getAndAddByte_signature, F_R)     \\\n-   do_name(     getAndAddByte_name,                                     \"getAndAddByte\")                                      \\\n-   do_signature(getAndAddByte_signature,                                \"(Ljava\/lang\/Object;JB)B\" )                           \\\n-  do_intrinsic(_getAndAddShort,           jdk_internal_misc_Unsafe,     getAndAddShort_name, getAndAddShort_signature, F_R)   \\\n-   do_name(     getAndAddShort_name,                                    \"getAndAddShort\")                                     \\\n-   do_signature(getAndAddShort_signature,                               \"(Ljava\/lang\/Object;JS)S\" )                           \\\n-  do_intrinsic(_getAndSetInt,             jdk_internal_misc_Unsafe,     getAndSetInt_name, getAndSetInt_signature, F_R)       \\\n-   do_name(     getAndSetInt_name,                                      \"getAndSetInt\")                                       \\\n-   do_alias(    getAndSetInt_signature,                                 \/*\"(Ljava\/lang\/Object;JI)I\"*\/ getAndAddInt_signature)   \\\n-  do_intrinsic(_getAndSetLong,            jdk_internal_misc_Unsafe,     getAndSetLong_name, getAndSetLong_signature, F_R)     \\\n-   do_name(     getAndSetLong_name,                                     \"getAndSetLong\")                                      \\\n-   do_alias(    getAndSetLong_signature,                                \/*\"(Ljava\/lang\/Object;JJ)J\"*\/ getAndAddLong_signature)  \\\n-  do_intrinsic(_getAndSetByte,            jdk_internal_misc_Unsafe,     getAndSetByte_name, getAndSetByte_signature, F_R)     \\\n-   do_name(     getAndSetByte_name,                                     \"getAndSetByte\")                                      \\\n-   do_alias(    getAndSetByte_signature,                                \/*\"(Ljava\/lang\/Object;JB)B\"*\/ getAndAddByte_signature)  \\\n-  do_intrinsic(_getAndSetShort,           jdk_internal_misc_Unsafe,     getAndSetShort_name, getAndSetShort_signature, F_R)   \\\n-   do_name(     getAndSetShort_name,                                    \"getAndSetShort\")                                     \\\n-   do_alias(    getAndSetShort_signature,                               \/*\"(Ljava\/lang\/Object;JS)S\"*\/ getAndAddShort_signature) \\\n-  do_intrinsic(_getAndSetReference,       jdk_internal_misc_Unsafe,     getAndSetReference_name, getAndSetReference_signature, F_R) \\\n-   do_name(     getAndSetReference_name,                                \"getAndSetReference\")                                  \\\n-   do_signature(getAndSetReference_signature,                           \"(Ljava\/lang\/Object;JLjava\/lang\/Object;)Ljava\/lang\/Object;\" ) \\\n-                                                                                                                               \\\n-   \/* (2) Bytecode intrinsics                                                                        *\/                        \\\n-                                                                                                                               \\\n-  do_intrinsic(_park,                     jdk_internal_misc_Unsafe,     park_name, park_signature,                     F_R)    \\\n-   do_name(     park_name,                                              \"park\")                                                \\\n-   do_signature(park_signature,                                         \"(ZJ)V\")                                               \\\n-  do_intrinsic(_unpark,                   jdk_internal_misc_Unsafe,     unpark_name, unpark_signature,                 F_R)    \\\n-   do_name(     unpark_name,                                            \"unpark\")                                              \\\n-   do_alias(    unpark_signature,                                       \/*(LObject;)V*\/ object_void_signature)                 \\\n-                                                                                                                               \\\n-  do_intrinsic(_StringBuilder_void,   java_lang_StringBuilder, object_initializer_name, void_method_signature,     F_R)   \\\n-  do_intrinsic(_StringBuilder_int,    java_lang_StringBuilder, object_initializer_name, int_void_signature,        F_R)   \\\n-  do_intrinsic(_StringBuilder_String, java_lang_StringBuilder, object_initializer_name, string_void_signature,     F_R)   \\\n-                                                                                                                          \\\n-  do_intrinsic(_StringBuilder_append_char,   java_lang_StringBuilder, append_name, char_StringBuilder_signature,   F_R)   \\\n-  do_intrinsic(_StringBuilder_append_int,    java_lang_StringBuilder, append_name, int_StringBuilder_signature,    F_R)   \\\n-  do_intrinsic(_StringBuilder_append_String, java_lang_StringBuilder, append_name, String_StringBuilder_signature, F_R)   \\\n-                                                                                                                          \\\n-  do_intrinsic(_StringBuilder_toString, java_lang_StringBuilder, toString_name, void_string_signature,             F_R)   \\\n-                                                                                                                          \\\n-  do_intrinsic(_StringBuffer_void,   java_lang_StringBuffer, object_initializer_name, void_method_signature,       F_R)   \\\n-  do_intrinsic(_StringBuffer_int,    java_lang_StringBuffer, object_initializer_name, int_void_signature,          F_R)   \\\n-  do_intrinsic(_StringBuffer_String, java_lang_StringBuffer, object_initializer_name, string_void_signature,       F_R)   \\\n-                                                                                                                          \\\n-  do_intrinsic(_StringBuffer_append_char,   java_lang_StringBuffer, append_name, char_StringBuffer_signature,      F_Y)   \\\n-  do_intrinsic(_StringBuffer_append_int,    java_lang_StringBuffer, append_name, int_StringBuffer_signature,       F_Y)   \\\n-  do_intrinsic(_StringBuffer_append_String, java_lang_StringBuffer, append_name, String_StringBuffer_signature,    F_Y)   \\\n-                                                                                                                          \\\n-  do_intrinsic(_StringBuffer_toString,  java_lang_StringBuffer, toString_name, void_string_signature,              F_Y)   \\\n-                                                                                                                          \\\n-  do_intrinsic(_Integer_toString,      java_lang_Integer, toString_name, int_String_signature,                     F_S)   \\\n-                                                                                                                          \\\n-  do_intrinsic(_String_String, java_lang_String, object_initializer_name, string_void_signature,                   F_R)   \\\n-                                                                                                                          \\\n-  do_intrinsic(_Object_init,              java_lang_Object, object_initializer_name, void_method_signature,        F_R)   \\\n-  \/*    (symbol object_initializer_name defined above) *\/                                                                 \\\n-                                                                                                                          \\\n-  do_intrinsic(_invoke,                   java_lang_reflect_Method, invoke_name, object_object_array_object_signature, F_R) \\\n-  \/*   (symbols invoke_name and invoke_signature defined above) *\/                                                      \\\n-  \/* the polymorphic MH intrinsics must be in compact order, with _invokeGeneric first and _linkToInterface last *\/     \\\n-  do_intrinsic(_invokeGeneric,            java_lang_invoke_MethodHandle, invoke_name,           star_name, F_RN)        \\\n-  do_intrinsic(_invokeBasic,              java_lang_invoke_MethodHandle, invokeBasic_name,      star_name, F_RN)        \\\n-  do_intrinsic(_linkToVirtual,            java_lang_invoke_MethodHandle, linkToVirtual_name,    star_name, F_SN)        \\\n-  do_intrinsic(_linkToStatic,             java_lang_invoke_MethodHandle, linkToStatic_name,     star_name, F_SN)        \\\n-  do_intrinsic(_linkToSpecial,            java_lang_invoke_MethodHandle, linkToSpecial_name,    star_name, F_SN)        \\\n-  do_intrinsic(_linkToInterface,          java_lang_invoke_MethodHandle, linkToInterface_name,  star_name, F_SN)        \\\n-  \/* special marker for bytecode generated for the JVM from a LambdaForm: *\/                                            \\\n-  do_intrinsic(_compiledLambdaForm,       java_lang_invoke_MethodHandle, compiledLambdaForm_name, star_name, F_RN)      \\\n-                                                                                                                        \\\n-  \/* unboxing methods: *\/                                                                                               \\\n-  do_intrinsic(_booleanValue,             java_lang_Boolean,      booleanValue_name, void_boolean_signature, F_R)       \\\n-   do_name(     booleanValue_name,       \"booleanValue\")                                                                \\\n-  do_intrinsic(_byteValue,                java_lang_Byte,         byteValue_name, void_byte_signature, F_R)             \\\n-   do_name(     byteValue_name,          \"byteValue\")                                                                   \\\n-  do_intrinsic(_charValue,                java_lang_Character,    charValue_name, void_char_signature, F_R)             \\\n-   do_name(     charValue_name,          \"charValue\")                                                                   \\\n-  do_intrinsic(_shortValue,               java_lang_Short,        shortValue_name, void_short_signature, F_R)           \\\n-   do_name(     shortValue_name,         \"shortValue\")                                                                  \\\n-  do_intrinsic(_intValue,                 java_lang_Integer,      intValue_name, void_int_signature, F_R)               \\\n-   do_name(     intValue_name,           \"intValue\")                                                                    \\\n-  do_intrinsic(_longValue,                java_lang_Long,         longValue_name, void_long_signature, F_R)             \\\n-   do_name(     longValue_name,          \"longValue\")                                                                   \\\n-  do_intrinsic(_floatValue,               java_lang_Float,        floatValue_name, void_float_signature, F_R)           \\\n-   do_name(     floatValue_name,         \"floatValue\")                                                                  \\\n-  do_intrinsic(_doubleValue,              java_lang_Double,       doubleValue_name, void_double_signature, F_R)         \\\n-   do_name(     doubleValue_name,        \"doubleValue\")                                                                 \\\n-                                                                                                                        \\\n-  \/* boxing methods: *\/                                                                                                 \\\n-   do_name(    valueOf_name,              \"valueOf\")                                                                    \\\n-  do_intrinsic(_Boolean_valueOf,          java_lang_Boolean,      valueOf_name, Boolean_valueOf_signature, F_S)         \\\n-   do_name(     Boolean_valueOf_signature,                       \"(Z)Ljava\/lang\/Boolean;\")                              \\\n-  do_intrinsic(_Byte_valueOf,             java_lang_Byte,         valueOf_name, Byte_valueOf_signature, F_S)            \\\n-   do_name(     Byte_valueOf_signature,                          \"(B)Ljava\/lang\/Byte;\")                                 \\\n-  do_intrinsic(_Character_valueOf,        java_lang_Character,    valueOf_name, Character_valueOf_signature, F_S)       \\\n-   do_name(     Character_valueOf_signature,                     \"(C)Ljava\/lang\/Character;\")                            \\\n-  do_intrinsic(_Short_valueOf,            java_lang_Short,        valueOf_name, Short_valueOf_signature, F_S)           \\\n-   do_name(     Short_valueOf_signature,                         \"(S)Ljava\/lang\/Short;\")                                \\\n-  do_intrinsic(_Integer_valueOf,          java_lang_Integer,      valueOf_name, Integer_valueOf_signature, F_S)         \\\n-   do_name(     Integer_valueOf_signature,                       \"(I)Ljava\/lang\/Integer;\")                              \\\n-  do_intrinsic(_Long_valueOf,             java_lang_Long,         valueOf_name, Long_valueOf_signature, F_S)            \\\n-   do_name(     Long_valueOf_signature,                          \"(J)Ljava\/lang\/Long;\")                                 \\\n-  do_intrinsic(_Float_valueOf,            java_lang_Float,        valueOf_name, Float_valueOf_signature, F_S)           \\\n-   do_name(     Float_valueOf_signature,                         \"(F)Ljava\/lang\/Float;\")                                \\\n-  do_intrinsic(_Double_valueOf,           java_lang_Double,       valueOf_name, Double_valueOf_signature, F_S)          \\\n-   do_name(     Double_valueOf_signature,                        \"(D)Ljava\/lang\/Double;\")                               \\\n-                                                                                                                        \\\n-  \/* forEachRemaining *\/                                                                             \\\n-  do_intrinsic(_forEachRemaining, java_util_stream_StreamsRangeIntSpliterator, forEachRemaining_name, forEachRemaining_signature, F_R) \\\n-   do_name(     forEachRemaining_name,    \"forEachRemaining\")                                                           \\\n-   do_name(     forEachRemaining_signature,                      \"(Ljava\/util\/function\/IntConsumer;)V\")                 \\\n+\/\/ enum for figuring positions and size of Symbol::_vm_symbols[]\n+enum class vmSymbolID : int {\n+  \/\/ [FIRST_SID ... LAST_SID] is the iteration range for the *valid* symbols.\n+  \/\/ NO_SID is used to indicate an invalid symbol. Some implementation code\n+  \/\/ *may* read _vm_symbols[NO_SID], so it must be a valid array index.\n+  NO_SID = 0,                \/\/ exclusive lower limit\n@@ -1505,1 +720,3 @@\n-    \/*end*\/\n+  #define VM_SYMBOL_ENUM(name, string) VM_SYMBOL_ENUM_NAME_(name),\n+  VM_SYMBOLS_DO(VM_SYMBOL_ENUM, VM_ALIAS_IGNORE)\n+  #undef VM_SYMBOL_ENUM\n@@ -1507,0 +724,1 @@\n+  SID_LIMIT,                 \/\/ exclusive upper limit\n@@ -1508,0 +726,3 @@\n+  #define VM_ALIAS_ENUM(name, def) VM_SYMBOL_ENUM_NAME_(name) = VM_SYMBOL_ENUM_NAME_(def),\n+  VM_SYMBOLS_DO(VM_SYMBOL_IGNORE, VM_ALIAS_ENUM)\n+  #undef VM_ALIAS_ENUM\n@@ -1509,0 +730,3 @@\n+  FIRST_SID = NO_SID + 1,    \/\/ inclusive lower limit\n+  LAST_SID = SID_LIMIT - 1,  \/\/ inclusive upper limit\n+};\n@@ -1510,1 +734,1 @@\n-\/\/ Class vmSymbols\n+ENUMERATOR_RANGE(vmSymbolID, vmSymbolID::FIRST_SID, vmSymbolID::LAST_SID)\n@@ -1516,0 +740,6 @@\n+\n+  static const int NO_SID    = static_cast<int>(vmSymbolID::NO_SID);    \/\/ exclusive lower limit\n+  static const int FIRST_SID = static_cast<int>(vmSymbolID::FIRST_SID); \/\/ inclusive lower limit\n+  static const int LAST_SID  = static_cast<int>(vmSymbolID::FIRST_SID); \/\/ inclusive upper limit\n+  static const int SID_LIMIT = static_cast<int>(vmSymbolID::SID_LIMIT); \/\/ exclusive upper limit\n+\n@@ -1517,3 +747,6 @@\n-  \/\/ enum for figuring positions and size of array holding Symbol*s\n-  enum SID {\n-    NO_SID = 0,\n+  static constexpr bool is_valid_id(int id) {\n+    return (id >= FIRST_SID && id < SID_LIMIT);\n+  }\n+  static constexpr bool is_valid_id(vmSymbolID sid) {\n+    return is_valid_id(static_cast<int>(sid));\n+  }\n@@ -1521,3 +754,4 @@\n-    #define VM_SYMBOL_ENUM(name, string) VM_SYMBOL_ENUM_NAME(name),\n-    VM_SYMBOLS_DO(VM_SYMBOL_ENUM, VM_ALIAS_IGNORE)\n-    #undef VM_SYMBOL_ENUM\n+  static constexpr vmSymbolID as_SID(int id) {\n+    assert(is_valid_id(id), \"must be\");\n+    return static_cast<vmSymbolID>(id);\n+  }\n@@ -1525,1 +759,4 @@\n-    SID_LIMIT,\n+  static constexpr int as_int(vmSymbolID sid) {\n+    assert(is_valid_id(sid), \"must be\");\n+    return static_cast<int>(sid);\n+  }\n@@ -1527,3 +764,5 @@\n-    #define VM_ALIAS_ENUM(name, def) VM_SYMBOL_ENUM_NAME(name) = VM_SYMBOL_ENUM_NAME(def),\n-    VM_SYMBOLS_DO(VM_SYMBOL_IGNORE, VM_ALIAS_ENUM)\n-    #undef VM_ALIAS_ENUM\n+  static constexpr int number_of_symbols() {\n+    static_assert(NO_SID == 0, \"must be a valid array index\");\n+    static_assert(FIRST_SID == 1, \"must not be the same as NO_SID\");\n+    return SID_LIMIT;\n+  }\n@@ -1531,3 +770,1 @@\n-    FIRST_SID = NO_SID + 1\n-  };\n-    log2_SID_LIMIT = 10         \/\/ checked by an assert at start-up\n+    log2_SID_LIMIT = 11         \/\/ checked by an assert at start-up\n@@ -1538,2 +775,0 @@\n-  \/\/ The symbol array\n-  static Symbol* _symbols[];\n@@ -1546,1 +781,1 @@\n-  static void initialize(TRAPS);\n+  static void initialize();\n@@ -1550,1 +785,1 @@\n-      return _symbols[VM_SYMBOL_ENUM_NAME(name)];         \\\n+      return Symbol::_vm_symbols[static_cast<int>(VM_SYMBOL_ENUM_NAME(name))]; \\\n@@ -1565,6 +800,2 @@\n-  \/\/ inverse of type_signature; returns T_OBJECT if s is not recognized\n-  static BasicType signature_type(const Symbol* s);\n-  static Symbol* symbol_at(SID id) {\n-    assert(id >= FIRST_SID && id < SID_LIMIT, \"oob\");\n-    assert(_symbols[id] != NULL, \"init\");\n-    return _symbols[id];\n+  static Symbol* symbol_at(vmSymbolID id) {\n+    return Symbol::vm_symbol_at(id);\n@@ -1574,3 +805,3 @@\n-  \/\/ Returns symbol's SID if one is assigned, else NO_SID.\n-  static SID find_sid(const Symbol* symbol);\n-  static SID find_sid(const char* symbol_name);\n+  \/\/ Returns symbol's vmSymbolID if one is assigned, else vmSymbolID::NO_SID.\n+  static vmSymbolID find_sid(const Symbol* symbol);\n+  static vmSymbolID find_sid(const char* symbol_name);\n@@ -1580,1 +811,1 @@\n-  static const char* name_for(SID sid);\n+  static const char* name_for(vmSymbolID sid);\n@@ -1584,113 +815,0 @@\n-\/\/ VM Intrinsic ID's uniquely identify some very special methods\n-class vmIntrinsics: AllStatic {\n-  friend class vmSymbols;\n-  friend class ciObjectFactory;\n-\n- public:\n-  \/\/ Accessing\n-  enum ID {\n-    _none = 0,                      \/\/ not an intrinsic (default answer)\n-\n-    #define VM_INTRINSIC_ENUM(id, klass, name, sig, flags)  id,\n-    VM_INTRINSICS_DO(VM_INTRINSIC_ENUM,\n-                     VM_SYMBOL_IGNORE, VM_SYMBOL_IGNORE, VM_SYMBOL_IGNORE, VM_ALIAS_IGNORE)\n-    #undef VM_INTRINSIC_ENUM\n-\n-    ID_LIMIT,\n-    LAST_COMPILER_INLINE = _getAndSetReference,\n-    FIRST_MH_SIG_POLY    = _invokeGeneric,\n-    FIRST_MH_STATIC      = _linkToVirtual,\n-    LAST_MH_SIG_POLY     = _linkToInterface,\n-\n-    FIRST_ID = _none + 1\n-  };\n-\n-  enum Flags {\n-    \/\/ AccessFlags syndromes relevant to intrinsics.\n-    F_none = 0,\n-    F_R,                        \/\/ !static ?native !synchronized (R=\"regular\")\n-    F_S,                        \/\/  static ?native !synchronized\n-    F_Y,                        \/\/ !static ?native  synchronized\n-    F_RN,                       \/\/ !static  native !synchronized\n-    F_SN,                       \/\/  static  native !synchronized\n-    F_RNY,                      \/\/ !static  native  synchronized\n-\n-    FLAG_LIMIT\n-  };\n-  enum {\n-    log2_FLAG_LIMIT = 4         \/\/ checked by an assert at start-up\n-  };\n-\n-public:\n-  static ID ID_from(int raw_id) {\n-    assert(raw_id >= (int)_none && raw_id < (int)ID_LIMIT,\n-           \"must be a valid intrinsic ID\");\n-    return (ID)raw_id;\n-  }\n-\n-  static const char* name_at(ID id);\n-\n-private:\n-  static ID find_id_impl(vmSymbols::SID holder,\n-                         vmSymbols::SID name,\n-                         vmSymbols::SID sig,\n-                         jshort flags);\n-\n-public:\n-  \/\/ Given a method's class, name, signature, and access flags, report its ID.\n-  static ID find_id(vmSymbols::SID holder,\n-                    vmSymbols::SID name,\n-                    vmSymbols::SID sig,\n-                    jshort flags) {\n-    ID id = find_id_impl(holder, name, sig, flags);\n-#ifdef ASSERT\n-    \/\/ ID _none does not hold the following asserts.\n-    if (id == _none)  return id;\n-#endif\n-    assert(    class_for(id) == holder, \"correct id\");\n-    assert(     name_for(id) == name,   \"correct id\");\n-    assert(signature_for(id) == sig,    \"correct id\");\n-    return id;\n-  }\n-\n-  static void verify_method(ID actual_id, Method* m) PRODUCT_RETURN;\n-\n-  \/\/ Find out the symbols behind an intrinsic:\n-  static vmSymbols::SID     class_for(ID id);\n-  static vmSymbols::SID      name_for(ID id);\n-  static vmSymbols::SID signature_for(ID id);\n-  static Flags              flags_for(ID id);\n-\n-  static const char* short_name_as_C_string(ID id, char* buf, int size);\n-\n-  \/\/ Wrapper object methods:\n-  static ID for_boxing(BasicType type);\n-  static ID for_unboxing(BasicType type);\n-\n-  \/\/ Raw conversion:\n-  static ID for_raw_conversion(BasicType src, BasicType dest);\n-\n-  \/\/ The methods below provide information related to compiling intrinsics.\n-\n-  \/\/ (1) Information needed by the C1 compiler.\n-\n-  static bool preserves_state(vmIntrinsics::ID id);\n-  static bool can_trap(vmIntrinsics::ID id);\n-  static bool should_be_pinned(vmIntrinsics::ID id);\n-\n-  \/\/ (2) Information needed by the C2 compiler.\n-\n-  \/\/ Returns true if the intrinsic for method 'method' will perform a virtual dispatch.\n-  static bool does_virtual_dispatch(vmIntrinsics::ID id);\n-  \/\/ A return value larger than 0 indicates that the intrinsic for method\n-  \/\/ 'method' requires predicated logic.\n-  static int predicates_needed(vmIntrinsics::ID id);\n-\n-  \/\/ Returns true if a compiler intrinsic is disabled by command-line flags\n-  \/\/ and false otherwise.\n-  static bool is_disabled_by_flags(const methodHandle& method);\n-  static bool is_disabled_by_flags(vmIntrinsics::ID id);\n-  static bool is_intrinsic_disabled(vmIntrinsics::ID id);\n-  static bool is_intrinsic_available(vmIntrinsics::ID id);\n-};\n-\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":108,"deletions":990,"binary":false,"changes":1098,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2019, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Azul Systems, Inc. All rights reserved.\n@@ -32,0 +32,1 @@\n+#include \"compiler\/oopMap.hpp\"\n@@ -35,1 +36,0 @@\n-#include \"gc\/g1\/g1CardTableEntryClosure.hpp\"\n@@ -45,0 +45,1 @@\n+#include \"gc\/g1\/g1GCParPhaseTimesTracker.hpp\"\n@@ -46,0 +47,1 @@\n+#include \"gc\/g1\/g1GCPauseType.hpp\"\n@@ -50,0 +52,1 @@\n+#include \"gc\/g1\/g1InitLogger.hpp\"\n@@ -54,0 +57,1 @@\n+#include \"gc\/g1\/g1PeriodicGCTask.hpp\"\n@@ -61,1 +65,0 @@\n-#include \"gc\/g1\/g1StringDedup.hpp\"\n@@ -64,2 +67,2 @@\n-#include \"gc\/g1\/g1YCTypes.hpp\"\n-#include \"gc\/g1\/g1YoungRemSetSamplingThread.hpp\"\n+#include \"gc\/g1\/g1ServiceThread.hpp\"\n+#include \"gc\/g1\/g1UncommitRegionTask.hpp\"\n@@ -67,0 +70,1 @@\n+#include \"gc\/g1\/g1YoungGCPostEvacuateTasks.hpp\"\n@@ -70,0 +74,1 @@\n+#include \"gc\/shared\/concurrentGCBreakpoints.hpp\"\n@@ -83,0 +88,1 @@\n+#include \"gc\/shared\/taskTerminator.hpp\"\n@@ -84,0 +90,1 @@\n+#include \"gc\/shared\/tlab_globals.hpp\"\n@@ -89,0 +96,2 @@\n+#include \"memory\/heapInspection.hpp\"\n+#include \"memory\/metaspaceUtils.hpp\"\n@@ -95,1 +104,0 @@\n-#include \"runtime\/flags\/flagSetting.hpp\"\n@@ -98,0 +106,1 @@\n+#include \"runtime\/java.hpp\"\n@@ -102,0 +111,1 @@\n+#include \"utilities\/autoRestore.hpp\"\n@@ -117,34 +127,0 @@\n-class RedirtyLoggedCardTableEntryClosure : public G1CardTableEntryClosure {\n- private:\n-  size_t _num_dirtied;\n-  G1CollectedHeap* _g1h;\n-  G1CardTable* _g1_ct;\n-\n-  HeapRegion* region_for_card(CardValue* card_ptr) const {\n-    return _g1h->heap_region_containing(_g1_ct->addr_for(card_ptr));\n-  }\n-\n-  bool will_become_free(HeapRegion* hr) const {\n-    \/\/ A region will be freed by free_collection_set if the region is in the\n-    \/\/ collection set and has not had an evacuation failure.\n-    return _g1h->is_in_cset(hr) && !hr->evacuation_failed();\n-  }\n-\n- public:\n-  RedirtyLoggedCardTableEntryClosure(G1CollectedHeap* g1h) : G1CardTableEntryClosure(),\n-    _num_dirtied(0), _g1h(g1h), _g1_ct(g1h->card_table()) { }\n-\n-  void do_card_ptr(CardValue* card_ptr, uint worker_id) {\n-    HeapRegion* hr = region_for_card(card_ptr);\n-\n-    \/\/ Should only dirty cards in regions that won't be freed.\n-    if (!will_become_free(hr)) {\n-      *card_ptr = G1CardTable::dirty_card_val();\n-      _num_dirtied++;\n-    }\n-  }\n-\n-  size_t num_dirtied()   const { return _num_dirtied; }\n-};\n-\n-\n@@ -161,1 +137,1 @@\n-Tickspan G1CollectedHeap::run_task(AbstractGangTask* task) {\n+Tickspan G1CollectedHeap::run_task_timed(AbstractGangTask* task) {\n@@ -163,1 +139,1 @@\n-  workers()->run_task(task, workers()->active_workers());\n+  workers()->run_task(task);\n@@ -167,0 +143,6 @@\n+void G1CollectedHeap::run_batch_task(G1BatchedGangTask* cl) {\n+  uint num_workers = MAX2(1u, MIN2(cl->num_workers_estimate(), workers()->active_workers()));\n+  cl->set_max_workers(num_workers);\n+  workers()->run_task(cl, num_workers);\n+}\n+\n@@ -182,1 +164,1 @@\n-  HeapRegion* res = _hrm->allocate_free_region(type, node_index);\n+  HeapRegion* res = _hrm.allocate_free_region(type, node_index);\n@@ -202,1 +184,1 @@\n-      res = _hrm->allocate_free_region(type, node_index);\n+      res = _hrm.allocate_free_region(type, node_index);\n@@ -211,1 +193,1 @@\n-G1CollectedHeap::humongous_obj_allocate_initialize_regions(uint first,\n+G1CollectedHeap::humongous_obj_allocate_initialize_regions(HeapRegion* first_hr,\n@@ -214,1 +196,1 @@\n-  assert(first != G1_NO_HRM_INDEX, \"pre-condition\");\n+  assert(first_hr != NULL, \"pre-condition\");\n@@ -219,0 +201,1 @@\n+  uint first = first_hr->hrm_index();\n@@ -233,4 +216,2 @@\n-  \/\/ This will be the \"starts humongous\" region.\n-  HeapRegion* first_hr = region_at(first);\n-  \/\/ The header of the new object will be placed at the bottom of\n-  \/\/ the first region.\n+  \/\/ The passed in hr will be the \"starts humongous\" region. The header\n+  \/\/ of the new object will be placed at the bottom of this region.\n@@ -342,1 +323,0 @@\n-  uint first = G1_NO_HRM_INDEX;\n@@ -345,18 +325,3 @@\n-  if (obj_regions == 1) {\n-    \/\/ Only one region to allocate, try to use a fast path by directly allocating\n-    \/\/ from the free lists. Do not try to expand here, we will potentially do that\n-    \/\/ later.\n-    HeapRegion* hr = new_region(word_size, HeapRegionType::Humongous, false \/* do_expand *\/);\n-    if (hr != NULL) {\n-      first = hr->hrm_index();\n-    }\n-  } else {\n-    \/\/ Policy: Try only empty regions (i.e. already committed first). Maybe we\n-    \/\/ are lucky enough to find some.\n-    first = _hrm->find_contiguous_only_empty(obj_regions);\n-    if (first != G1_NO_HRM_INDEX) {\n-      _hrm->allocate_free_regions_starting_at(first, obj_regions);\n-    }\n-  }\n-\n-  if (first == G1_NO_HRM_INDEX) {\n+  \/\/ Policy: First try to allocate a humongous object in the free list.\n+  HeapRegion* humongous_start = _hrm.allocate_humongous(obj_regions);\n+  if (humongous_start == NULL) {\n@@ -365,9 +330,6 @@\n-    \/\/ If so, try expansion.\n-    first = _hrm->find_contiguous_empty_or_unavailable(obj_regions);\n-    if (first != G1_NO_HRM_INDEX) {\n-      \/\/ We found something. Make sure these regions are committed, i.e. expand\n-      \/\/ the heap. Alternatively we could do a defragmentation GC.\n-      log_debug(gc, ergo, heap)(\"Attempt heap expansion (humongous allocation request failed). Allocation request: \" SIZE_FORMAT \"B\",\n-                                    word_size * HeapWordSize);\n-\n-      _hrm->expand_at(first, obj_regions, workers());\n+    \/\/ If so, expand the heap and allocate the humongous object.\n+    humongous_start = _hrm.expand_and_allocate_humongous(obj_regions);\n+    if (humongous_start != NULL) {\n+      \/\/ We managed to find a region by expanding the heap.\n+      log_debug(gc, ergo, heap)(\"Heap expansion (humongous allocation request). Allocation request: \" SIZE_FORMAT \"B\",\n+                                word_size * HeapWordSize);\n@@ -375,10 +337,0 @@\n-\n-#ifdef ASSERT\n-      for (uint i = first; i < first + obj_regions; ++i) {\n-        HeapRegion* hr = region_at(i);\n-        assert(hr->is_free(), \"sanity\");\n-        assert(hr->is_empty(), \"sanity\");\n-        assert(is_on_master_free_list(hr), \"sanity\");\n-      }\n-#endif\n-      _hrm->allocate_free_regions_starting_at(first, obj_regions);\n@@ -391,2 +343,2 @@\n-  if (first != G1_NO_HRM_INDEX) {\n-    result = humongous_obj_allocate_initialize_regions(first, obj_regions, word_size);\n+  if (humongous_start != NULL) {\n+    result = humongous_obj_allocate_initialize_regions(humongous_start, obj_regions, word_size);\n@@ -446,0 +398,1 @@\n+    bool preventive_collection_required = false;\n@@ -450,1 +403,5 @@\n-      result = _allocator->attempt_allocation_locked(word_size);\n+\n+      \/\/ Now that we have the lock, we first retry the allocation in case another\n+      \/\/ thread changed the region while we were waiting to acquire the lock.\n+      size_t actual_size;\n+      result = _allocator->attempt_allocation(word_size, word_size, &actual_size);\n@@ -455,7 +412,5 @@\n-      \/\/ If the GCLocker is active and we are bound for a GC, try expanding young gen.\n-      \/\/ This is different to when only GCLocker::needs_gc() is set: try to avoid\n-      \/\/ waiting because the GCLocker is active to not wait too long.\n-      if (GCLocker::is_active_and_needs_gc() && policy()->can_expand_young_list()) {\n-        \/\/ No need for an ergo message here, can_expand_young_list() does this when\n-        \/\/ it returns true.\n-        result = _allocator->attempt_allocation_force(word_size);\n+      preventive_collection_required = policy()->preventive_collection_required(1);\n+      if (!preventive_collection_required) {\n+        \/\/ We've already attempted a lock-free allocation above, so we don't want to\n+        \/\/ do it again. Let's jump straight to replacing the active region.\n+        result = _allocator->attempt_allocation_using_new_region(word_size);\n@@ -465,0 +420,12 @@\n+\n+        \/\/ If the GCLocker is active and we are bound for a GC, try expanding young gen.\n+        \/\/ This is different to when only GCLocker::needs_gc() is set: try to avoid\n+        \/\/ waiting because the GCLocker is active to not wait too long.\n+        if (GCLocker::is_active_and_needs_gc() && policy()->can_expand_young_list()) {\n+          \/\/ No need for an ergo message here, can_expand_young_list() does this when\n+          \/\/ it returns true.\n+          result = _allocator->attempt_allocation_force(word_size);\n+          if (result != NULL) {\n+            return result;\n+          }\n+        }\n@@ -466,0 +433,1 @@\n+\n@@ -475,0 +443,2 @@\n+      GCCause::Cause gc_cause = preventive_collection_required ? GCCause::_g1_preventive_collection\n+                                                              : GCCause::_g1_inc_collection_pause;\n@@ -476,2 +446,1 @@\n-      result = do_collection_pause(word_size, gc_count_before, &succeeded,\n-                                   GCCause::_g1_inc_collection_pause);\n+      result = do_collection_pause(word_size, gc_count_before, &succeeded, gc_cause);\n@@ -573,1 +542,1 @@\n-  MemRegion reserved = _hrm->reserved();\n+  MemRegion reserved = _hrm.reserved();\n@@ -590,1 +559,1 @@\n-  MemRegion reserved = _hrm->reserved();\n+  MemRegion reserved = _hrm.reserved();\n@@ -598,4 +567,0 @@\n-  \/\/ Enable archive object checking used by G1MarkSweep. We have to let it know\n-  \/\/ about each archive range, so that objects in those ranges aren't marked.\n-  G1ArchiveAllocator::enable_archive_object_check();\n-\n@@ -624,1 +589,1 @@\n-    HeapRegion* start_region = _hrm->addr_to_region(start_address);\n+    HeapRegion* start_region = _hrm.addr_to_region(start_address);\n@@ -634,1 +599,1 @@\n-      start_region = _hrm->addr_to_region(start_address);\n+      start_region = _hrm.addr_to_region(start_address);\n@@ -639,1 +604,1 @@\n-    if (!_hrm->allocate_containing_regions(curr_range, &commits, workers())) {\n+    if (!_hrm.allocate_containing_regions(curr_range, &commits, workers())) {\n@@ -651,2 +616,2 @@\n-    HeapRegion* curr_region = _hrm->addr_to_region(start_address);\n-    HeapRegion* last_region = _hrm->addr_to_region(last_address);\n+    HeapRegion* curr_region = _hrm.addr_to_region(start_address);\n+    HeapRegion* last_region = _hrm.addr_to_region(last_address);\n@@ -669,1 +634,1 @@\n-        next_region = _hrm->next_region_in_heap(curr_region);\n+        next_region = _hrm.next_region_in_heap(curr_region);\n@@ -677,3 +642,0 @@\n-\n-    \/\/ Notify mark-sweep of the archive\n-    G1ArchiveAllocator::set_range_archive(curr_range, open);\n@@ -688,1 +650,1 @@\n-  MemRegion reserved = _hrm->reserved();\n+  MemRegion reserved = _hrm.reserved();\n@@ -708,2 +670,2 @@\n-    HeapRegion* start_region = _hrm->addr_to_region(start_address);\n-    HeapRegion* last_region = _hrm->addr_to_region(last_address);\n+    HeapRegion* start_region = _hrm.addr_to_region(start_address);\n+    HeapRegion* last_region = _hrm.addr_to_region(last_address);\n@@ -725,1 +687,1 @@\n-        curr_region = _hrm->next_region_in_heap(curr_region);\n+        curr_region = _hrm.next_region_in_heap(curr_region);\n@@ -737,1 +699,2 @@\n-    if (start_address != bottom_address) {\n+    assert(start_address >= bottom_address, \"bottom address should not be greater than start address\");\n+    if (start_address > bottom_address) {\n@@ -770,1 +733,1 @@\n-void G1CollectedHeap::dealloc_archive_regions(MemRegion* ranges, size_t count, bool is_open) {\n+void G1CollectedHeap::populate_archive_regions_bot_part(MemRegion* ranges, size_t count) {\n@@ -774,1 +737,22 @@\n-  MemRegion reserved = _hrm->reserved();\n+\n+  HeapWord* st = ranges[0].start();\n+  HeapWord* last = ranges[count-1].last();\n+  HeapRegion* hr_st = _hrm.addr_to_region(st);\n+  HeapRegion* hr_last = _hrm.addr_to_region(last);\n+\n+  HeapRegion* hr_curr = hr_st;\n+  while (hr_curr != NULL) {\n+    hr_curr->update_bot();\n+    if (hr_curr != hr_last) {\n+      hr_curr = _hrm.next_region_in_heap(hr_curr);\n+    } else {\n+      hr_curr = NULL;\n+    }\n+  }\n+}\n+\n+void G1CollectedHeap::dealloc_archive_regions(MemRegion* ranges, size_t count) {\n+  assert(!is_init_completed(), \"Expect to be called at JVM init time\");\n+  assert(ranges != NULL, \"MemRegion array NULL\");\n+  assert(count != 0, \"No MemRegions provided\");\n+  MemRegion reserved = _hrm.reserved();\n@@ -778,1 +762,1 @@\n-  size_t uncommitted_regions = 0;\n+  uint shrink_count = 0;\n@@ -796,2 +780,2 @@\n-    HeapRegion* start_region = _hrm->addr_to_region(start_address);\n-    HeapRegion* last_region = _hrm->addr_to_region(last_address);\n+    HeapRegion* start_region = _hrm.addr_to_region(start_address);\n+    HeapRegion* last_region = _hrm.addr_to_region(last_address);\n@@ -808,1 +792,1 @@\n-      start_region = _hrm->addr_to_region(start_address);\n+      start_region = _hrm.addr_to_region(start_address);\n@@ -823,1 +807,1 @@\n-        curr_region = _hrm->next_region_in_heap(curr_region);\n+        curr_region = _hrm.next_region_in_heap(curr_region);\n@@ -827,5 +811,3 @@\n-      _hrm->shrink_at(curr_index, 1);\n-      uncommitted_regions++;\n-    }\n-    \/\/ Notify mark-sweep that this is no longer an archive range.\n-    G1ArchiveAllocator::clear_range_archive(ranges[i], is_open);\n+      _hrm.shrink_at(curr_index, 1);\n+      shrink_count++;\n+    }\n@@ -835,3 +817,5 @@\n-  if (uncommitted_regions != 0) {\n-    log_debug(gc, ergo, heap)(\"Attempt heap shrinking (uncommitted archive regions). Total size: \" SIZE_FORMAT \"B\",\n-                              HeapRegion::GrainWords * HeapWordSize * uncommitted_regions);\n+  if (shrink_count != 0) {\n+    log_debug(gc, ergo, heap)(\"Attempt heap shrinking (archive regions). Total size: \" SIZE_FORMAT \"B\",\n+                              HeapRegion::GrainWords * HeapWordSize * shrink_count);\n+    \/\/ Explicit uncommit.\n+    uncommit_regions(shrink_count);\n@@ -842,12 +826,0 @@\n-oop G1CollectedHeap::materialize_archived_object(oop obj) {\n-  assert(obj != NULL, \"archived obj is NULL\");\n-  assert(G1ArchiveAllocator::is_archived_object(obj), \"must be archived object\");\n-\n-  \/\/ Loading an archived object makes it strongly reachable. If it is\n-  \/\/ loaded during concurrent marking, it must be enqueued to the SATB\n-  \/\/ queue, shading the previously white object gray.\n-  G1BarrierSet::enqueue(obj);\n-\n-  return obj;\n-}\n-\n@@ -878,1 +850,1 @@\n-                                           word_size)) {\n+                                        word_size)) {\n@@ -889,0 +861,1 @@\n+    bool preventive_collection_required = false;\n@@ -895,8 +868,12 @@\n-      \/\/ Given that humongous objects are not allocated in young\n-      \/\/ regions, we'll first try to do the allocation without doing a\n-      \/\/ collection hoping that there's enough space in the heap.\n-      result = humongous_obj_allocate(word_size);\n-      if (result != NULL) {\n-        size_t size_in_regions = humongous_obj_size_in_regions(word_size);\n-        policy()->add_bytes_allocated_in_old_since_last_gc(size_in_regions * HeapRegion::GrainBytes);\n-        return result;\n+      size_t size_in_regions = humongous_obj_size_in_regions(word_size);\n+      preventive_collection_required = policy()->preventive_collection_required((uint)size_in_regions);\n+      if (!preventive_collection_required) {\n+        \/\/ Given that humongous objects are not allocated in young\n+        \/\/ regions, we'll first try to do the allocation without doing a\n+        \/\/ collection hoping that there's enough space in the heap.\n+        result = humongous_obj_allocate(word_size);\n+        if (result != NULL) {\n+          policy()->old_gen_alloc_tracker()->\n+            add_allocated_humongous_bytes_since_last_gc(size_in_regions * HeapRegion::GrainBytes);\n+          return result;\n+        }\n@@ -914,0 +891,2 @@\n+      GCCause::Cause gc_cause = preventive_collection_required ? GCCause::_g1_preventive_collection\n+                                                              : GCCause::_g1_humongous_allocation;\n@@ -915,2 +894,1 @@\n-      result = do_collection_pause(word_size, gc_count_before, &succeeded,\n-                                   GCCause::_g1_humongous_allocation);\n+      result = do_collection_pause(word_size, gc_count_before, &succeeded, gc_cause);\n@@ -921,0 +899,3 @@\n+        size_t size_in_regions = humongous_obj_size_in_regions(word_size);\n+        policy()->old_gen_alloc_tracker()->\n+          record_collection_pause_humongous_allocation(size_in_regions * HeapRegion::GrainBytes);\n@@ -1040,3 +1021,1 @@\n-  tear_down_region_sets(false \/* free_list_only *\/);\n-\n-  hrm()->prepare_for_full_collection_start();\n+  _hrm.remove_all_free_regions();\n@@ -1054,4 +1033,2 @@\n-  hrm()->prepare_for_full_collection_end();\n-\n-  ClassLoaderDataGraph::purge();\n-  MetaspaceUtils::verify_metrics();\n+  ClassLoaderDataGraph::purge(\/*at_safepoint*\/true);\n+  DEBUG_ONLY(MetaspaceUtils::verify();)\n@@ -1065,0 +1042,1 @@\n+  uncommit_regions_if_necessary();\n@@ -1086,1 +1064,1 @@\n-  \/\/ Discard all remembered set updates.\n+  \/\/ Discard all remembered set updates and reset refinement statistics.\n@@ -1090,0 +1068,1 @@\n+  concurrent_refine()->get_and_reset_refinement_stats();\n@@ -1093,1 +1072,1 @@\n-  _hrm->verify_optional();\n+  _hrm.verify_optional();\n@@ -1096,11 +1075,1 @@\n-  \/\/ Clear the previous marking bitmap, if needed for bitmap verification.\n-  \/\/ Note we cannot do this when we clear the next marking bitmap in\n-  \/\/ G1ConcurrentMark::abort() above since VerifyDuringGC verifies the\n-  \/\/ objects marked during a full GC against the previous bitmap.\n-  \/\/ But we need to clear it before calling check_bitmaps below since\n-  \/\/ the full GC has compacted objects and updated TAMS but not updated\n-  \/\/ the prev bitmap.\n-  if (G1VerifyBitmaps) {\n-    GCTraceTime(Debug, gc) tm(\"Clear Prev Bitmap for Verification\");\n-    _cm->clear_prev_bitmap(workers());\n-  }\n+\n@@ -1135,3 +1104,0 @@\n-#ifdef TRACESPINNING\n-  ParallelTaskTerminator::print_termination_counts();\n-#endif\n@@ -1141,1 +1107,2 @@\n-                                         bool clear_all_soft_refs) {\n+                                         bool clear_all_soft_refs,\n+                                         bool do_maximum_compaction) {\n@@ -1152,1 +1119,1 @@\n-  G1FullCollector collector(this, explicit_gc, do_clear_all_soft_refs);\n+  G1FullCollector collector(this, explicit_gc, do_clear_all_soft_refs, do_maximum_compaction);\n@@ -1167,0 +1134,3 @@\n+  \/\/ When clear_all_soft_refs is set we want to do a maximum compaction\n+  \/\/ not leaving any dead wood.\n+  bool do_maximum_compaction = clear_all_soft_refs;\n@@ -1168,1 +1138,14 @@\n-                                  clear_all_soft_refs);\n+                                  clear_all_soft_refs,\n+                                  do_maximum_compaction);\n+}\n+\n+bool G1CollectedHeap::upgrade_to_full_collection() {\n+  GCCauseSetter compaction(this, GCCause::_g1_compaction_pause);\n+  log_info(gc, ergo)(\"Attempting full compaction clearing soft references\");\n+  bool success = do_full_collection(false \/* explicit gc *\/,\n+                                    true  \/* clear_all_soft_refs *\/,\n+                                    false \/* do_maximum_compaction *\/);\n+  \/\/ do_full_collection only fails if blocked by GC locker and that can't\n+  \/\/ be the case here since we only call this when already completed one gc.\n+  assert(success, \"invariant\");\n+  return success;\n@@ -1174,77 +1157,9 @@\n-  \/\/ Capacity, free and used after the GC counted as full regions to\n-  \/\/ include the waste in the following calculations.\n-  const size_t capacity_after_gc = capacity();\n-  const size_t used_after_gc = capacity_after_gc - unused_committed_regions_in_bytes();\n-\n-  \/\/ This is enforced in arguments.cpp.\n-  assert(MinHeapFreeRatio <= MaxHeapFreeRatio,\n-         \"otherwise the code below doesn't make sense\");\n-\n-  \/\/ We don't have floating point command-line arguments\n-  const double minimum_free_percentage = (double) MinHeapFreeRatio \/ 100.0;\n-  const double maximum_used_percentage = 1.0 - minimum_free_percentage;\n-  const double maximum_free_percentage = (double) MaxHeapFreeRatio \/ 100.0;\n-  const double minimum_used_percentage = 1.0 - maximum_free_percentage;\n-\n-  \/\/ We have to be careful here as these two calculations can overflow\n-  \/\/ 32-bit size_t's.\n-  double used_after_gc_d = (double) used_after_gc;\n-  double minimum_desired_capacity_d = used_after_gc_d \/ maximum_used_percentage;\n-  double maximum_desired_capacity_d = used_after_gc_d \/ minimum_used_percentage;\n-\n-  \/\/ Let's make sure that they are both under the max heap size, which\n-  \/\/ by default will make them fit into a size_t.\n-  double desired_capacity_upper_bound = (double) MaxHeapSize;\n-  minimum_desired_capacity_d = MIN2(minimum_desired_capacity_d,\n-                                    desired_capacity_upper_bound);\n-  maximum_desired_capacity_d = MIN2(maximum_desired_capacity_d,\n-                                    desired_capacity_upper_bound);\n-\n-  \/\/ We can now safely turn them into size_t's.\n-  size_t minimum_desired_capacity = (size_t) minimum_desired_capacity_d;\n-  size_t maximum_desired_capacity = (size_t) maximum_desired_capacity_d;\n-\n-  \/\/ This assert only makes sense here, before we adjust them\n-  \/\/ with respect to the min and max heap size.\n-  assert(minimum_desired_capacity <= maximum_desired_capacity,\n-         \"minimum_desired_capacity = \" SIZE_FORMAT \", \"\n-         \"maximum_desired_capacity = \" SIZE_FORMAT,\n-         minimum_desired_capacity, maximum_desired_capacity);\n-\n-  \/\/ Should not be greater than the heap max size. No need to adjust\n-  \/\/ it with respect to the heap min size as it's a lower bound (i.e.,\n-  \/\/ we'll try to make the capacity larger than it, not smaller).\n-  minimum_desired_capacity = MIN2(minimum_desired_capacity, MaxHeapSize);\n-  \/\/ Should not be less than the heap min size. No need to adjust it\n-  \/\/ with respect to the heap max size as it's an upper bound (i.e.,\n-  \/\/ we'll try to make the capacity smaller than it, not greater).\n-  maximum_desired_capacity =  MAX2(maximum_desired_capacity, MinHeapSize);\n-\n-  if (Universe::heap()->do_cleanup_unused()) {\n-    \/\/ HeapRegionManager::shrink_by do not allow remove all regions.\n-    \/\/ Make sure at least one is there.\n-    maximum_desired_capacity = HeapRegion::GrainBytes;\n-  }\n-\n-  if (capacity_after_gc < minimum_desired_capacity) {\n-    \/\/ Don't expand unless it's significant\n-    size_t expand_bytes = minimum_desired_capacity - capacity_after_gc;\n-\n-    log_debug(gc, ergo, heap)(\"Attempt heap expansion (capacity lower than min desired capacity). \"\n-                              \"Capacity: \" SIZE_FORMAT \"B occupancy: \" SIZE_FORMAT \"B live: \" SIZE_FORMAT \"B \"\n-                              \"min_desired_capacity: \" SIZE_FORMAT \"B (\" UINTX_FORMAT \" %%)\",\n-                              capacity_after_gc, used_after_gc, used(), minimum_desired_capacity, MinHeapFreeRatio);\n-\n-    expand(expand_bytes, _workers);\n-\n-    \/\/ No expansion, now see if we want to shrink\n-  } else if (capacity_after_gc > maximum_desired_capacity) {\n-    \/\/ Capacity too large, compute shrinking size\n-    size_t shrink_bytes = capacity_after_gc - maximum_desired_capacity;\n-\n-    log_debug(gc, ergo, heap)(\"Attempt heap shrinking (capacity higher than max desired capacity). \"\n-                              \"Capacity: \" SIZE_FORMAT \"B occupancy: \" SIZE_FORMAT \"B live: \" SIZE_FORMAT \"B \"\n-                              \"maximum_desired_capacity: \" SIZE_FORMAT \"B (\" UINTX_FORMAT \" %%)\",\n-                              capacity_after_gc, used_after_gc, used(), maximum_desired_capacity, MaxHeapFreeRatio);\n-\n-    shrink(shrink_bytes);\n+  bool should_expand;\n+  size_t resize_amount = _heap_sizing_policy->full_collection_resize_amount(should_expand);\n+\n+  if (resize_amount == 0) {\n+    return;\n+  } else if (should_expand) {\n+    expand(resize_amount, _workers);\n+  } else {\n+    shrink(resize_amount);\n@@ -1256,1 +1171,1 @@\n-                                                            bool clear_all_soft_refs,\n+                                                            bool maximum_compaction,\n@@ -1278,0 +1193,1 @@\n+    GCCauseSetter compaction(this, GCCause::_g1_compaction_pause);\n@@ -1279,0 +1195,7 @@\n+    \/\/ If maximum_compaction is set we clear all soft references and don't\n+    \/\/ allow any dead wood to be left on the heap.\n+    if (maximum_compaction) {\n+      log_info(gc, ergo)(\"Attempting maximum full compaction clearing soft references\");\n+    } else {\n+      log_info(gc, ergo)(\"Attempting full compaction\");\n+    }\n@@ -1280,1 +1203,2 @@\n-                                       clear_all_soft_refs);\n+                                       maximum_compaction \/* clear_all_soft_refs *\/ ,\n+                                       maximum_compaction \/* do_maximum_compaction *\/);\n@@ -1294,1 +1218,1 @@\n-                                     false, \/* clear_all_soft_refs *\/\n+                                     false, \/* maximum_collection *\/\n@@ -1305,1 +1229,1 @@\n-                                            true, \/* clear_all_soft_refs *\/\n+                                            true, \/* maximum_collection *\/\n@@ -1316,1 +1240,1 @@\n-                                            false, \/* clear_all_soft_refs *\/\n+                                            false, \/* maximum_collection *\/\n@@ -1350,1 +1274,1 @@\n-    _hrm->verify_optional();\n+    _hrm.verify_optional();\n@@ -1375,1 +1299,1 @@\n-  uint expanded_by = _hrm->expand_by(regions_to_expand, pretouch_workers);\n+  uint expanded_by = _hrm.expand_by(regions_to_expand, pretouch_workers);\n@@ -1390,1 +1314,1 @@\n-        _hrm->available() >= regions_to_expand) {\n+        _hrm.available() >= regions_to_expand) {\n@@ -1399,1 +1323,1 @@\n-  uint expanded_by = _hrm->expand_on_preferred_node(node_index);\n+  uint expanded_by = _hrm.expand_on_preferred_node(node_index);\n@@ -1402,1 +1326,1 @@\n-    assert(is_maximal_no_gc(), \"Should be no regions left, available: %u\", _hrm->available());\n+    assert(is_maximal_no_gc(), \"Should be no regions left, available: %u\", _hrm.available());\n@@ -1418,1 +1342,1 @@\n-  uint num_regions_removed = _hrm->shrink_by(num_regions_to_remove);\n+  uint num_regions_removed = _hrm.shrink_by(num_regions_to_remove);\n@@ -1424,0 +1348,1 @@\n+    log_debug(gc, heap)(\"Uncommittable regions after shrink: %u\", num_regions_removed);\n@@ -1441,1 +1366,1 @@\n-  tear_down_region_sets(true \/* free_list_only *\/);\n+  _hrm.remove_all_free_regions();\n@@ -1445,1 +1370,1 @@\n-  _hrm->verify_optional();\n+  _hrm.verify_optional();\n@@ -1513,1 +1438,2 @@\n-  _young_gen_sampling_thread(NULL),\n+  _service_thread(NULL),\n+  _periodic_gc_task(NULL),\n@@ -1516,0 +1442,1 @@\n+  _collection_pause_end(Ticks::now()),\n@@ -1523,1 +1450,1 @@\n-  _hrm(NULL),\n+  _hrm(),\n@@ -1534,1 +1461,2 @@\n-  _has_humongous_reclaim_candidates(false),\n+  _num_humongous_objects(0),\n+  _num_humongous_reclaim_candidates(0),\n@@ -1543,1 +1471,1 @@\n-  _policy(G1Policy::create_policy(_gc_timer_stw)),\n+  _policy(new G1Policy(_gc_timer_stw)),\n@@ -1552,1 +1480,2 @@\n-  _evacuation_failed(false),\n+  _num_regions_failed_evacuation(0),\n+  _regions_failed_evacuation(NULL),\n@@ -1581,1 +1510,1 @@\n-  _task_queues = new RefToScanQueueSet(n_queues);\n+  _task_queues = new G1ScannerTasksQueueSet(n_queues);\n@@ -1586,1 +1515,1 @@\n-    RefToScanQueue* q = new RefToScanQueue();\n+    G1ScannerTasksQueue* q = new G1ScannerTasksQueue();\n@@ -1599,19 +1528,0 @@\n-static size_t actual_reserved_page_size(ReservedSpace rs) {\n-  size_t page_size = os::vm_page_size();\n-  if (UseLargePages) {\n-    \/\/ There are two ways to manage large page memory.\n-    \/\/ 1. OS supports committing large page memory.\n-    \/\/ 2. OS doesn't support committing large page memory so ReservedSpace manages it.\n-    \/\/    And ReservedSpace calls it 'special'. If we failed to set 'special',\n-    \/\/    we reserved memory without large page.\n-    if (os::can_commit_large_page_memory() || rs.special()) {\n-      \/\/ An alignment at ReservedSpace comes from preferred page size or\n-      \/\/ heap alignment, and if the alignment came from heap alignment, it could be\n-      \/\/ larger than large pages size. So need to cap with the large page size.\n-      page_size = MIN2(rs.alignment(), os::large_page_size());\n-    }\n-  }\n-\n-  return page_size;\n-}\n-\n@@ -1624,1 +1534,1 @@\n-  size_t page_size = actual_reserved_page_size(rs);\n+  size_t page_size = rs.page_size();\n@@ -1635,1 +1545,1 @@\n-                                          preferred_page_size,\n+                                          preferred_page_size,\n@@ -1649,4 +1559,4 @@\n-jint G1CollectedHeap::initialize_young_gen_sampling_thread() {\n-  _young_gen_sampling_thread = new G1YoungRemSetSamplingThread();\n-  if (_young_gen_sampling_thread->osthread() == NULL) {\n-    vm_shutdown_during_initialization(\"Could not create G1YoungRemSetSamplingThread\");\n+jint G1CollectedHeap::initialize_service_thread() {\n+  _service_thread = new G1ServiceThread();\n+  if (_service_thread->osthread() == NULL) {\n+    vm_shutdown_during_initialization(\"Could not create G1ServiceThread\");\n@@ -1715,3 +1625,2 @@\n-  \/\/ Carve out the G1 part of the heap.\n-  ReservedSpace g1_rs = heap_rs.first_part(reserved_byte_size);\n-  size_t page_size = actual_reserved_page_size(heap_rs);\n+  \/\/ Create space mappers.\n+  size_t page_size = heap_rs.page_size();\n@@ -1719,6 +1628,6 @@\n-    G1RegionToSpaceMapper::create_heap_mapper(g1_rs,\n-                                              g1_rs.size(),\n-                                              page_size,\n-                                              HeapRegion::GrainBytes,\n-                                              1,\n-                                              mtJavaHeap);\n+    G1RegionToSpaceMapper::create_mapper(heap_rs,\n+                                         heap_rs.size(),\n+                                         page_size,\n+                                         HeapRegion::GrainBytes,\n+                                         1,\n+                                         mtJavaHeap);\n@@ -1741,1 +1650,1 @@\n-                             G1BlockOffsetTable::compute_size(g1_rs.size() \/ HeapWordSize),\n+                             G1BlockOffsetTable::compute_size(heap_rs.size() \/ HeapWordSize),\n@@ -1746,1 +1655,1 @@\n-                             G1CardTable::compute_size(g1_rs.size() \/ HeapWordSize),\n+                             G1CardTable::compute_size(heap_rs.size() \/ HeapWordSize),\n@@ -1751,1 +1660,1 @@\n-                             G1CardCounts::compute_size(g1_rs.size() \/ HeapWordSize),\n+                             G1CardCounts::compute_size(heap_rs.size() \/ HeapWordSize),\n@@ -1754,1 +1663,1 @@\n-  size_t bitmap_size = G1CMBitMap::compute_size(g1_rs.size());\n+  size_t bitmap_size = G1CMBitMap::compute_size(heap_rs.size());\n@@ -1760,3 +1669,1 @@\n-  _hrm = HeapRegionManager::create_manager(this);\n-\n-  _hrm->initialize(heap_storage, prev_bitmap_storage, next_bitmap_storage, bot_storage, cardtable_storage, card_counts_storage);\n+  _hrm.initialize(heap_storage, prev_bitmap_storage, next_bitmap_storage, bot_storage, cardtable_storage, card_counts_storage);\n@@ -1771,1 +1678,1 @@\n-  guarantee((max_regions() - 1) <= max_region_idx, \"too many regions\");\n+  guarantee((max_reserved_regions() - 1) <= max_region_idx, \"too many regions\");\n@@ -1775,1 +1682,2 @@\n-  guarantee(g1_rs.base() >= (char*)G1CardTable::card_size, \"Java heap must not start within the first card.\");\n+  guarantee(heap_rs.base() >= (char*)G1CardTable::card_size, \"Java heap must not start within the first card.\");\n+  G1FromCardCache::initialize(max_reserved_regions());\n@@ -1778,1 +1686,1 @@\n-  _rem_set->initialize(max_reserved_capacity(), max_regions());\n+  _rem_set->initialize(max_reserved_regions());\n@@ -1785,1 +1693,1 @@\n-  FreeRegionList::set_unrealistically_long_length(max_expandable_regions() + 1);\n+  FreeRegionList::set_unrealistically_long_length(max_regions() + 1);\n@@ -1787,1 +1695,1 @@\n-  _bot = new G1BlockOffsetTable(reserved_region(), bot_storage);\n+  _bot = new G1BlockOffsetTable(reserved(), bot_storage);\n@@ -1790,2 +1698,0 @@\n-    HeapWord* start = _hrm->reserved().start();\n-    HeapWord* end = _hrm->reserved().end();\n@@ -1794,2 +1700,2 @@\n-    _region_attr.initialize(start, end, granularity);\n-    _humongous_reclaim_candidates.initialize(start, end, granularity);\n+    _region_attr.initialize(reserved(), granularity);\n+    _humongous_reclaim_candidates.initialize(reserved(), granularity);\n@@ -1809,1 +1715,1 @@\n-  \/\/ (Must do this late, so that \"max_regions\" is defined.)\n+  \/\/ (Must do this late, so that \"max_[reserved_]regions\" is defined.)\n@@ -1811,4 +1717,0 @@\n-  if (_cm == NULL || !_cm->completed_initialization()) {\n-    vm_shutdown_during_initialization(\"Could not create\/initialize G1ConcurrentMark\");\n-    return JNI_ENOMEM;\n-  }\n@@ -1831,1 +1733,1 @@\n-  ecode = initialize_young_gen_sampling_thread();\n+  ecode = initialize_service_thread();\n@@ -1836,0 +1738,7 @@\n+  \/\/ Initialize and schedule sampling task on service thread.\n+  _rem_set->initialize_sampling_task(service_thread());\n+\n+  \/\/ Create and schedule the periodic gc task on the service thread.\n+  _periodic_gc_task = new G1PeriodicGCTask(\"Periodic GC Task\");\n+  _service_thread->register_task(_periodic_gc_task);\n+\n@@ -1844,1 +1753,1 @@\n-  HeapRegion* dummy_region = _hrm->get_dummy_region();\n+  HeapRegion* dummy_region = _hrm.get_dummy_region();\n@@ -1861,2 +1770,0 @@\n-  G1StringDedup::initialize();\n-\n@@ -1865,1 +1772,5 @@\n-  _collection_set.initialize(max_regions());\n+  _collection_set.initialize(max_reserved_regions());\n+\n+  _regions_failed_evacuation = NEW_C_HEAP_ARRAY(volatile bool, max_regions(), mtGC);\n+\n+  G1InitLogger::print();\n@@ -1875,1 +1786,1 @@\n-  _young_gen_sampling_thread->stop();\n+  _service_thread->stop();\n@@ -1877,3 +1788,0 @@\n-  if (G1StringDedup::is_enabled()) {\n-    G1StringDedup::stop();\n-  }\n@@ -1907,1 +1815,1 @@\n-  \/\/   * Reference discovery is enabled at initial marking.\n+  \/\/   * Reference discovery is enabled at concurrent start.\n@@ -1931,2 +1839,0 @@\n-  bool mt_processing = ParallelRefProcEnabled && (ParallelGCThreads > 1);\n-\n@@ -1936,1 +1842,0 @@\n-                           mt_processing,                                  \/\/ mt processing\n@@ -1941,2 +1846,1 @@\n-                           &_is_alive_closure_cm,                          \/\/ is alive closure\n-                           true);                                          \/\/ allow changes to number of processing threads\n+                           &_is_alive_closure_cm);                         \/\/ is alive closure\n@@ -1947,1 +1851,0 @@\n-                           mt_processing,                        \/\/ mt processing\n@@ -1952,2 +1855,1 @@\n-                           &_is_alive_closure_stw,               \/\/ is alive closure\n-                           true);                                \/\/ allow changes to number of processing threads\n+                           &_is_alive_closure_stw);              \/\/ is alive closure\n@@ -1961,1 +1863,1 @@\n-  return _hrm->length() * HeapRegion::GrainBytes;\n+  return _hrm.length() * HeapRegion::GrainBytes;\n@@ -1965,1 +1867,1 @@\n-  return _hrm->total_free_bytes();\n+  return _hrm.total_free_bytes();\n@@ -2015,0 +1917,1 @@\n+    case GCCause::_wb_breakpoint:           return true;\n@@ -2019,12 +1922,0 @@\n-bool G1CollectedHeap::should_upgrade_to_full_gc(GCCause::Cause cause) {\n-  if (policy()->force_upgrade_to_full()) {\n-    return true;\n-  } else if (should_do_concurrent_full_gc(_gc_cause)) {\n-    return false;\n-  } else if (has_regions_left_for_allocation()) {\n-    return false;\n-  } else {\n-    return true;\n-  }\n-}\n-\n@@ -2040,1 +1931,1 @@\n-  SizeTFlagSetting fs(_filler_array_max_size, word_size);\n+  AutoModifyRestore<size_t> temporarily(_filler_array_max_size, word_size);\n@@ -2066,1 +1957,2 @@\n-void G1CollectedHeap::increment_old_marking_cycles_completed(bool concurrent) {\n+void G1CollectedHeap::increment_old_marking_cycles_completed(bool concurrent,\n+                                                             bool whole_heap_examined) {\n@@ -2098,0 +1990,4 @@\n+  if (whole_heap_examined) {\n+    \/\/ Signal that we have completed a visit to all live objects.\n+    record_whole_heap_examined_timestamp();\n+  }\n@@ -2147,1 +2043,1 @@\n-    \/\/ Try to schedule an initial-mark evacuation pause that will\n+    \/\/ Try to schedule concurrent start evacuation pause that will\n@@ -2185,1 +2081,17 @@\n-    if (!GCCause::is_user_requested_gc(cause)) {\n+    if (cause == GCCause::_wb_breakpoint) {\n+      if (op.gc_succeeded()) {\n+        LOG_COLLECT_CONCURRENTLY_COMPLETE(cause, true);\n+        return true;\n+      }\n+      \/\/ When _wb_breakpoint there can't be another cycle or deferred.\n+      assert(!op.cycle_already_in_progress(), \"invariant\");\n+      assert(!op.whitebox_attached(), \"invariant\");\n+      \/\/ Concurrent cycle attempt might have been cancelled by some other\n+      \/\/ collection, so retry.  Unlike other cases below, we want to retry\n+      \/\/ even if cancelled by a STW full collection, because we really want\n+      \/\/ to start a concurrent cycle.\n+      if (old_marking_started_before != old_marking_started_after) {\n+        LOG_COLLECT_CONCURRENTLY(cause, \"ignoring STW full GC\");\n+        old_marking_started_before = old_marking_started_after;\n+      }\n+    } else if (!GCCause::is_user_requested_gc(cause)) {\n@@ -2192,3 +2104,4 @@\n-      \/\/ (3) a new cycle was started (by this thread or some other), or\n-      \/\/ (4) a Full GC was performed.\n-      \/\/ Cases (3) and (4) are detected together by a change to\n+      \/\/ (3) whitebox is controlling concurrent cycles,\n+      \/\/ (4) a new cycle was started (by this thread or some other), or\n+      \/\/ (5) a Full GC was performed.\n+      \/\/ Cases (4) and (5) are detected together by a change to\n@@ -2197,1 +2110,1 @@\n-      \/\/ Note that (1) does not imply (3).  If we're still in the mixed\n+      \/\/ Note that (1) does not imply (4).  If we're still in the mixed\n@@ -2199,1 +2112,1 @@\n-      \/\/ collection an initial-mark won't be honored.  If we don't check for\n+      \/\/ collection a concurrent start won't be honored.  If we don't check for\n@@ -2203,0 +2116,1 @@\n+          op.whitebox_attached() ||\n@@ -2256,3 +2170,3 @@\n-      \/\/ If VMOp failed because a cycle was already in progress, it is now\n-      \/\/ complete.  But it didn't finish this user-requested GC, so try\n-      \/\/ again.\n+        \/\/ If VMOp failed because a cycle was already in progress, it\n+        \/\/ is now complete.  But it didn't finish this user-requested\n+        \/\/ GC, so try again.\n@@ -2262,0 +2176,12 @@\n+      } else if (op.whitebox_attached()) {\n+        \/\/ If WhiteBox wants control, wait for notification of a state\n+        \/\/ change in the controller, then try again.  Don't wait for\n+        \/\/ release of control, since collections may complete while in\n+        \/\/ control.  Note: This won't recognize a STW full collection\n+        \/\/ while waiting; we can't wait on multiple monitors.\n+        LOG_COLLECT_CONCURRENTLY(cause, \"whitebox control stall\");\n+        MonitorLocker ml(ConcurrentGCBreakpoints::monitor());\n+        if (ConcurrentGCBreakpoints::is_controlled()) {\n+          ml.wait();\n+        }\n+        continue;\n@@ -2268,1 +2194,1 @@\n-    \/\/ If GCLocker is active, wait until clear before retrying.\n+      \/\/ If GCLocker is active, wait until clear before retrying.\n@@ -2321,20 +2247,1 @@\n-  if (_hrm->reserved().contains(p)) {\n-    \/\/ Given that we know that p is in the reserved space,\n-    \/\/ heap_region_containing() should successfully\n-    \/\/ return the containing region.\n-    HeapRegion* hr = heap_region_containing(p);\n-    return hr->is_in(p);\n-  } else {\n-    return false;\n-  }\n-}\n-\n-#ifdef ASSERT\n-bool G1CollectedHeap::is_in_exact(const void* p) const {\n-  bool contains = reserved_region().contains(p);\n-  bool available = _hrm->is_available(addr_to_region((HeapWord*)p));\n-  if (contains && available) {\n-    return true;\n-  } else {\n-    return false;\n-  }\n+  return is_in_reserved(p) && _hrm.is_available(addr_to_region((HeapWord*)p));\n@@ -2342,1 +2249,0 @@\n-#endif\n@@ -2365,0 +2271,24 @@\n+class G1ParallelObjectIterator : public ParallelObjectIterator {\n+private:\n+  G1CollectedHeap*  _heap;\n+  HeapRegionClaimer _claimer;\n+\n+public:\n+  G1ParallelObjectIterator(uint thread_num) :\n+      _heap(G1CollectedHeap::heap()),\n+      _claimer(thread_num == 0 ? G1CollectedHeap::heap()->workers()->active_workers() : thread_num) {}\n+\n+  virtual void object_iterate(ObjectClosure* cl, uint worker_id) {\n+    _heap->object_iterate_parallel(cl, worker_id, &_claimer);\n+  }\n+};\n+\n+ParallelObjectIterator* G1CollectedHeap::parallel_object_iterator(uint thread_num) {\n+  return new G1ParallelObjectIterator(thread_num);\n+}\n+\n+void G1CollectedHeap::object_iterate_parallel(ObjectClosure* cl, uint worker_id, HeapRegionClaimer* claimer) {\n+  IterateObjectClosureRegionClosure blk(cl);\n+  heap_region_par_iterate_from_worker_offset(&blk, claimer, worker_id);\n+}\n+\n@@ -2370,1 +2300,1 @@\n-  _hrm->iterate(cl);\n+  _hrm.iterate(cl);\n@@ -2376,1 +2306,1 @@\n-  _hrm->par_iterate(cl, hrclaimer, hrclaimer->offset_for_worker(worker_id));\n+  _hrm.par_iterate(cl, hrclaimer, hrclaimer->offset_for_worker(worker_id));\n@@ -2381,1 +2311,1 @@\n-  _hrm->par_iterate(cl, hrclaimer, 0);\n+  _hrm.par_iterate(cl, hrclaimer, 0);\n@@ -2406,4 +2336,0 @@\n-bool G1CollectedHeap::supports_tlab_allocation() const {\n-  return true;\n-}\n-\n@@ -2429,26 +2355,1 @@\n-  return _hrm->max_expandable_length() * HeapRegion::GrainBytes;\n-}\n-\n-size_t G1CollectedHeap::max_reserved_capacity() const {\n-  return _hrm->max_length() * HeapRegion::GrainBytes;\n-}\n-\n-jlong G1CollectedHeap::millis_since_last_gc() {\n-  \/\/ See the notes in GenCollectedHeap::millis_since_last_gc()\n-  \/\/ for more information about the implementation.\n-  jlong ret_val = (os::javaTimeNanos() \/ NANOSECS_PER_MILLISEC) -\n-                  _policy->collection_pause_end_millis();\n-  if (ret_val < 0) {\n-    log_warning(gc)(\"millis_since_last_gc() would return : \" JLONG_FORMAT\n-      \". returning zero instead.\", ret_val);\n-    return 0;\n-  }\n-  return ret_val;\n-}\n-\n-void G1CollectedHeap::deduplicate_string(oop str) {\n-  assert(java_lang_String::is_instance(str), \"invariant\");\n-\n-  if (G1StringDedup::is_enabled()) {\n-    G1StringDedup::deduplicate(str);\n-  }\n+  return max_regions() * HeapRegion::GrainBytes;\n@@ -2465,1 +2366,1 @@\n-bool G1CollectedHeap::supports_concurrent_phase_control() const {\n+bool G1CollectedHeap::supports_concurrent_gc_breakpoints() const {\n@@ -2469,6 +2370,2 @@\n-bool G1CollectedHeap::request_concurrent_phase(const char* phase) {\n-  return _cm_thread->request_concurrent_phase(phase);\n-}\n-\n-bool G1CollectedHeap::is_heterogeneous_heap() const {\n-  return G1Arguments::is_heterogeneous_heap();\n+bool G1CollectedHeap::is_archived_object(oop object) const {\n+  return object != NULL && heap_region_containing(object)->is_archive();\n@@ -2519,0 +2416,1 @@\n+  size_t heap_used = Heap_lock->owned_by_self() ? used() : used_unlocked();\n@@ -2521,1 +2419,1 @@\n-            capacity()\/K, used_unlocked()\/K);\n+            capacity()\/K, heap_used\/K);\n@@ -2523,2 +2421,2 @@\n-            p2i(_hrm->reserved().start()),\n-            p2i(_hrm->reserved().end()));\n+            p2i(_hrm.reserved().start()),\n+            p2i(_hrm.reserved().end()));\n@@ -2539,1 +2437,2 @@\n-      st->print(\"%d=%u \", node_ids[node_index], _hrm->num_free_regions(node_index));\n+      uint num_free_regions = _hrm.num_free_regions(node_index);\n+      st->print(\"%d=%u \", node_ids[node_index], num_free_regions);\n@@ -2560,0 +2459,1 @@\n+  st->cr();\n@@ -2572,12 +2472,0 @@\n-void G1CollectedHeap::print_gc_threads_on(outputStream* st) const {\n-  workers()->print_worker_threads_on(st);\n-  _cm_thread->print_on(st);\n-  st->cr();\n-  _cm->print_worker_threads_on(st);\n-  _cr->print_threads_on(st);\n-  _young_gen_sampling_thread->print_on(st);\n-  if (G1StringDedup::is_enabled()) {\n-    G1StringDedup::print_worker_threads_on(st);\n-  }\n-}\n-\n@@ -2589,4 +2477,1 @@\n-  tc->do_thread(_young_gen_sampling_thread);\n-  if (G1StringDedup::is_enabled()) {\n-    G1StringDedup::threads_do(tc);\n-  }\n+  tc->do_thread(_service_thread);\n@@ -2682,7 +2567,0 @@\n-G1CollectedHeap* G1CollectedHeap::heap() {\n-  CollectedHeap* heap = Universe::heap();\n-  assert(heap != NULL, \"Uninitialized access to G1CollectedHeap::heap()\");\n-  assert(heap->kind() == CollectedHeap::G1, \"Invalid name\");\n-  return (G1CollectedHeap*)heap;\n-}\n-\n@@ -2697,1 +2575,1 @@\n-  if (full || collector_state()->in_initial_mark_gc()) {\n+  if (full || collector_state()->in_concurrent_start_gc()) {\n@@ -2702,3 +2580,16 @@\n-  double start = os::elapsedTime();\n-  ensure_parsability(true);\n-  phase_times()->record_prepare_tlab_time_ms((os::elapsedTime() - start) * 1000.0);\n+  {\n+    Ticks start = Ticks::now();\n+    ensure_parsability(true);\n+    Tickspan dt = Ticks::now() - start;\n+    phase_times()->record_prepare_tlab_time_ms(dt.seconds() * MILLIUNITS);\n+  }\n+\n+  if (!full) {\n+    \/\/ Flush dirty card queues to qset, so later phases don't need to account\n+    \/\/ for partially filled per-thread queues and such.  Not needed for full\n+    \/\/ collections, which ignore those logs.\n+    Ticks start = Ticks::now();\n+    G1BarrierSet::dirty_card_queue_set().concatenate_logs();\n+    Tickspan dt = Ticks::now() - start;\n+    phase_times()->record_concatenate_dirty_card_logs_time_ms(dt.seconds() * MILLIUNITS);\n+  }\n@@ -2711,1 +2602,1 @@\n-    increment_old_marking_cycles_completed(false \/* concurrent *\/);\n+    increment_old_marking_cycles_completed(false \/* concurrent *\/, true \/* liveness_completed *\/);\n@@ -2717,3 +2608,0 @@\n-  \/\/ FIXME: what is this about?\n-  \/\/ I'm ignoring the \"fill_newgen()\" call if \"alloc_event_enabled\"\n-  \/\/ is set.\n@@ -2731,1 +2619,1 @@\n-  Universe::update_heap_info_at_gc();\n+  Universe::heap()->update_capacity_and_used_at_gc();\n@@ -2735,0 +2623,16 @@\n+\n+  _collection_pause_end = Ticks::now();\n+}\n+\n+uint G1CollectedHeap::uncommit_regions(uint region_limit) {\n+  return _hrm.uncommit_inactive_regions(region_limit);\n+}\n+\n+bool G1CollectedHeap::has_uncommittable_regions() {\n+  return _hrm.has_inactive_regions();\n+}\n+\n+void G1CollectedHeap::uncommit_regions_if_necessary() {\n+  if (has_uncommittable_regions()) {\n+    G1UncommitRegionTask::enqueue();\n+  }\n@@ -2769,1 +2673,3 @@\n-void G1CollectedHeap::do_concurrent_mark() {\n+void G1CollectedHeap::start_concurrent_cycle(bool concurrent_operation_is_full_mark) {\n+  assert(!_cm_thread->in_progress(), \"Can not start concurrent operation while in progress\");\n+\n@@ -2771,3 +2677,6 @@\n-  if (!_cm_thread->in_progress()) {\n-    _cm_thread->set_started();\n-    CGC_lock->notify();\n+  if (concurrent_operation_is_full_mark) {\n+    _cm->post_concurrent_mark_start();\n+    _cm_thread->start_full_mark();\n+  } else {\n+    _cm->post_concurrent_undo_start();\n+    _cm_thread->start_undo_mark();\n@@ -2775,16 +2684,1 @@\n-}\n-\n-size_t G1CollectedHeap::pending_card_num() {\n-  struct CountCardsClosure : public ThreadClosure {\n-    size_t _cards;\n-    CountCardsClosure() : _cards(0) {}\n-    virtual void do_thread(Thread* t) {\n-      _cards += G1ThreadLocalData::dirty_card_queue(t).size();\n-    }\n-  } count_from_threads;\n-  Threads::threads_do(&count_from_threads);\n-\n-  G1DirtyCardQueueSet& dcqs = G1BarrierSet::dirty_card_queue_set();\n-  dcqs.verify_num_cards();\n-\n-  return dcqs.num_cards() + count_from_threads._cards;\n+  CGC_lock->notify();\n@@ -2799,1 +2693,1 @@\n-         rem_set->occupancy_less_or_equal_than(G1RSetSparseRegionEntries) :\n+         rem_set->occupancy_less_or_equal_than(G1EagerReclaimRemSetThreshold) :\n@@ -2931,1 +2825,1 @@\n-  if (collector_state()->in_initial_mark_gc()) {\n+  if (collector_state()->in_concurrent_start_gc()) {\n@@ -2963,1 +2857,1 @@\n-  size_t expand_bytes = _heap_sizing_policy->expansion_amount();\n+  size_t expand_bytes = _heap_sizing_policy->young_collection_expansion_amount();\n@@ -2967,1 +2861,1 @@\n-    double expand_ms;\n+    double expand_ms = 0.0;\n@@ -2975,12 +2869,9 @@\n-const char* G1CollectedHeap::young_gc_name() const {\n-  if (collector_state()->in_initial_mark_gc()) {\n-    return \"Pause Young (Concurrent Start)\";\n-  } else if (collector_state()->in_young_only_phase()) {\n-    if (collector_state()->in_young_gc_before_mixed()) {\n-      return \"Pause Young (Prepare Mixed)\";\n-    } else {\n-      return \"Pause Young (Normal)\";\n-    }\n-  } else {\n-    return \"Pause Young (Mixed)\";\n-  }\n+void G1CollectedHeap::set_young_gc_name(char* young_gc_name) {\n+  G1GCPauseType pause_type =\n+    \/\/ The strings for all Concurrent Start pauses are the same, so the parameter\n+    \/\/ does not matter here.\n+    collector_state()->young_gc_pause_type(false \/* concurrent_operation_is_full_mark *\/);\n+  snprintf(young_gc_name,\n+           MaxYoungGCNameLength,\n+           \"Pause Young (%s)\",\n+           G1GCPauseTypeHelper::to_string(pause_type));\n@@ -2997,0 +2888,20 @@\n+  do_collection_pause_at_safepoint_helper(target_pause_time_ms);\n+  return true;\n+}\n+\n+void G1CollectedHeap::gc_tracer_report_gc_start() {\n+  _gc_timer_stw->register_gc_start();\n+  _gc_tracer_stw->report_gc_start(gc_cause(), _gc_timer_stw->gc_start());\n+}\n+\n+void G1CollectedHeap::gc_tracer_report_gc_end(bool concurrent_operation_is_full_mark,\n+                                              G1EvacuationInfo& evacuation_info) {\n+  _gc_tracer_stw->report_evacuation_info(&evacuation_info);\n+  _gc_tracer_stw->report_tenuring_threshold(_policy->tenuring_threshold());\n+\n+  _gc_timer_stw->register_gc_end();\n+  _gc_tracer_stw->report_gc_end(_gc_timer_stw->gc_end(),\n+  _gc_timer_stw->time_partitions());\n+}\n+\n+void G1CollectedHeap::do_collection_pause_at_safepoint_helper(double target_pause_time_ms) {\n@@ -3004,2 +2915,1 @@\n-  _gc_timer_stw->register_gc_start();\n-  _gc_tracer_stw->report_gc_start(gc_cause(), _gc_timer_stw->gc_start());\n+  gc_tracer_report_gc_start();\n@@ -3016,1 +2926,1 @@\n-  \/\/ We should not be doing initial mark unless the conc mark thread is running\n+  \/\/ We should not be doing concurrent start unless the concurrent mark thread is running\n@@ -3018,2 +2928,2 @@\n-    \/\/ This call will decide whether this pause is an initial-mark\n-    \/\/ pause. If it is, in_initial_mark_gc() will return true\n+    \/\/ This call will decide whether this pause is a concurrent start\n+    \/\/ pause. If it is, in_concurrent_start_gc() will return true\n@@ -3024,2 +2934,2 @@\n-  \/\/ We do not allow initial-mark to be piggy-backed on a mixed GC.\n-  assert(!collector_state()->in_initial_mark_gc() ||\n+  \/\/ We do not allow concurrent start to be piggy-backed on a mixed GC.\n+  assert(!collector_state()->in_concurrent_start_gc() ||\n@@ -3030,7 +2940,5 @@\n-  \/\/ Record whether this pause is an initial mark. When the current\n-  \/\/ thread has completed its logging output and it's safe to signal\n-  \/\/ the CM thread, the flag's value in the policy has been reset.\n-  bool should_start_conc_mark = collector_state()->in_initial_mark_gc();\n-  if (should_start_conc_mark) {\n-    _cm->gc_tracer_cm()->set_gc_cause(gc_cause());\n-  }\n+  \/\/ Record whether this pause may need to trigger a concurrent operation. Later,\n+  \/\/ when we signal the G1ConcurrentMarkThread, the collector state has already\n+  \/\/ been reset for the next pause.\n+  bool should_start_concurrent_mark_operation = collector_state()->in_concurrent_start_gc();\n+  bool concurrent_operation_is_full_mark = false;\n@@ -3042,2 +2950,0 @@\n-    _gc_tracer_stw->report_yc_type(collector_state()->yc_type());\n-\n@@ -3046,1 +2952,4 @@\n-    GCTraceTime(Info, gc) tm(young_gc_name(), NULL, gc_cause(), true);\n+    char young_gc_name[MaxYoungGCNameLength];\n+    set_young_gc_name(young_gc_name);\n+\n+    GCTraceTime(Info, gc) tm(young_gc_name, NULL, gc_cause(), true);\n@@ -3056,1 +2965,1 @@\n-                         collector_state()->yc_type() == Mixed \/* all_memory_pools_affected *\/);\n+                         collector_state()->in_mixed_phase() \/* all_memory_pools_affected *\/);\n@@ -3100,0 +3009,1 @@\n+        bool may_do_optional_evacuation = _collection_set.optional_region_length() != 0;\n@@ -3101,1 +3011,1 @@\n-        evacuate_initial_collection_set(&per_thread_states);\n+        evacuate_initial_collection_set(&per_thread_states, may_do_optional_evacuation);\n@@ -3103,1 +3013,1 @@\n-        if (_collection_set.optional_region_length() != 0) {\n+        if (may_do_optional_evacuation) {\n@@ -3113,10 +3023,0 @@\n-        if (should_start_conc_mark) {\n-          \/\/ We have to do this before we notify the CM threads that\n-          \/\/ they can start working to make sure that all the\n-          \/\/ appropriate initialization is done on the CM object.\n-          concurrent_mark()->post_initial_mark();\n-          \/\/ Note that we don't actually trigger the CM thread at\n-          \/\/ this point. We do that later when we're sure that\n-          \/\/ the current thread has completed its logging output.\n-        }\n-\n@@ -3129,0 +3029,8 @@\n+        \/\/ Refine the type of a concurrent mark operation now that we did the\n+        \/\/ evacuation, eventually aborting it.\n+        concurrent_operation_is_full_mark = policy()->concurrent_operation_is_full_mark(\"Revise IHOP\");\n+\n+        \/\/ Need to report the collection pause now since record_collection_pause_end()\n+        \/\/ modifies it to the next state.\n+        _gc_tracer_stw->report_young_gc_pause(collector_state()->young_gc_pause_type(concurrent_operation_is_full_mark));\n+\n@@ -3131,1 +3039,1 @@\n-        policy()->record_collection_pause_end(pause_time_ms);\n+        policy()->record_collection_pause_end(pause_time_ms, concurrent_operation_is_full_mark);\n@@ -3136,4 +3044,0 @@\n-#ifdef TRACESPINNING\n-      ParallelTaskTerminator::print_termination_counts();\n-#endif\n-\n@@ -3151,1 +3055,1 @@\n-    _hrm->verify_optional();\n+    _hrm.verify_optional();\n@@ -3167,4 +3071,1 @@\n-    _gc_tracer_stw->report_evacuation_info(&evacuation_info);\n-    _gc_tracer_stw->report_tenuring_threshold(_policy->tenuring_threshold());\n-    _gc_timer_stw->register_gc_end();\n-    _gc_tracer_stw->report_gc_end(_gc_timer_stw->gc_end(), _gc_timer_stw->time_partitions());\n+    gc_tracer_report_gc_end(concurrent_operation_is_full_mark, evacuation_info);\n@@ -3176,2 +3077,2 @@\n-  if (should_start_conc_mark) {\n-    \/\/ CAUTION: after the doConcurrentMark() call below, the concurrent marking\n+  if (should_start_concurrent_mark_operation) {\n+    \/\/ CAUTION: after the start_concurrent_cycle() call below, the concurrent marking\n@@ -3182,1 +3083,2 @@\n-    do_concurrent_mark();\n+    start_concurrent_cycle(concurrent_operation_is_full_mark);\n+    ConcurrentGCBreakpoints::notify_idle_to_active();\n@@ -3184,17 +3086,0 @@\n-\n-  return true;\n-}\n-\n-void G1CollectedHeap::remove_self_forwarding_pointers(G1RedirtyCardsQueueSet* rdcqs) {\n-  G1ParRemoveSelfForwardPtrsTask rsfp_task(rdcqs);\n-  workers()->run_task(&rsfp_task);\n-}\n-\n-void G1CollectedHeap::restore_after_evac_failure(G1RedirtyCardsQueueSet* rdcqs) {\n-  double remove_self_forwards_start = os::elapsedTime();\n-\n-  remove_self_forwarding_pointers(rdcqs);\n-  SharedRestorePreservedMarksTaskExecutor task_executor(workers());\n-  _preserved_marks_set.restore(&task_executor);\n-\n-  phase_times()->record_evac_fail_remove_self_forwards((os::elapsedTime() - remove_self_forwards_start) * 1000.0);\n@@ -3204,4 +3089,0 @@\n-  if (!_evacuation_failed) {\n-    _evacuation_failed = true;\n-  }\n-\n@@ -3216,1 +3097,1 @@\n-  const bool res = terminator()->offer_termination();\n+  const bool res = (terminator() == nullptr) ? true : terminator()->offer_termination();\n@@ -3237,1 +3118,1 @@\n-  G1ParallelCleaningTask unlink_task(is_alive, num_workers, class_unloading_occurred, false);\n+  G1ParallelCleaningTask unlink_task(is_alive, num_workers, class_unloading_occurred);\n@@ -3241,92 +3122,0 @@\n-\/\/ Clean string dedup data structures.\n-\/\/ Ideally we would prefer to use a StringDedupCleaningTask here, but we want to\n-\/\/ record the durations of the phases. Hence the almost-copy.\n-class G1StringDedupCleaningTask : public AbstractGangTask {\n-  BoolObjectClosure* _is_alive;\n-  OopClosure* _keep_alive;\n-  G1GCPhaseTimes* _phase_times;\n-\n-public:\n-  G1StringDedupCleaningTask(BoolObjectClosure* is_alive,\n-                            OopClosure* keep_alive,\n-                            G1GCPhaseTimes* phase_times) :\n-    AbstractGangTask(\"Partial Cleaning Task\"),\n-    _is_alive(is_alive),\n-    _keep_alive(keep_alive),\n-    _phase_times(phase_times)\n-  {\n-    assert(G1StringDedup::is_enabled(), \"String deduplication disabled.\");\n-    StringDedup::gc_prologue(true);\n-  }\n-\n-  ~G1StringDedupCleaningTask() {\n-    StringDedup::gc_epilogue();\n-  }\n-\n-  void work(uint worker_id) {\n-    StringDedupUnlinkOrOopsDoClosure cl(_is_alive, _keep_alive);\n-    {\n-      G1GCParPhaseTimesTracker x(_phase_times, G1GCPhaseTimes::StringDedupQueueFixup, worker_id);\n-      StringDedupQueue::unlink_or_oops_do(&cl);\n-    }\n-    {\n-      G1GCParPhaseTimesTracker x(_phase_times, G1GCPhaseTimes::StringDedupTableFixup, worker_id);\n-      StringDedupTable::unlink_or_oops_do(&cl, worker_id);\n-    }\n-  }\n-};\n-\n-void G1CollectedHeap::string_dedup_cleaning(BoolObjectClosure* is_alive,\n-                                            OopClosure* keep_alive,\n-                                            G1GCPhaseTimes* phase_times) {\n-  G1StringDedupCleaningTask cl(is_alive, keep_alive, phase_times);\n-  workers()->run_task(&cl);\n-}\n-\n-class G1RedirtyLoggedCardsTask : public AbstractGangTask {\n- private:\n-  G1RedirtyCardsQueueSet* _qset;\n-  G1CollectedHeap* _g1h;\n-  BufferNode* volatile _nodes;\n-\n-  void par_apply(RedirtyLoggedCardTableEntryClosure* cl, uint worker_id) {\n-    size_t buffer_size = _qset->buffer_size();\n-    BufferNode* next = Atomic::load(&_nodes);\n-    while (next != NULL) {\n-      BufferNode* node = next;\n-      next = Atomic::cmpxchg(&_nodes, node, node->next());\n-      if (next == node) {\n-        cl->apply_to_buffer(node, buffer_size, worker_id);\n-        next = node->next();\n-      }\n-    }\n-  }\n-\n- public:\n-  G1RedirtyLoggedCardsTask(G1RedirtyCardsQueueSet* qset, G1CollectedHeap* g1h) :\n-    AbstractGangTask(\"Redirty Cards\"),\n-    _qset(qset), _g1h(g1h), _nodes(qset->all_completed_buffers()) { }\n-\n-  virtual void work(uint worker_id) {\n-    G1GCPhaseTimes* p = _g1h->phase_times();\n-    G1GCParPhaseTimesTracker x(p, G1GCPhaseTimes::RedirtyCards, worker_id);\n-\n-    RedirtyLoggedCardTableEntryClosure cl(_g1h);\n-    par_apply(&cl, worker_id);\n-\n-    p->record_thread_work_item(G1GCPhaseTimes::RedirtyCards, worker_id, cl.num_dirtied());\n-  }\n-};\n-\n-void G1CollectedHeap::redirty_logged_cards(G1RedirtyCardsQueueSet* rdcqs) {\n-  double redirty_logged_cards_start = os::elapsedTime();\n-\n-  G1RedirtyLoggedCardsTask redirty_task(rdcqs, this);\n-  workers()->run_task(&redirty_task);\n-\n-  G1DirtyCardQueueSet& dcq = G1BarrierSet::dirty_card_queue_set();\n-  dcq.merge_bufferlists(rdcqs);\n-\n-  phase_times()->record_redirty_logged_cards_time_ms((os::elapsedTime() - redirty_logged_cards_start) * 1000.0);\n-}\n-\n@@ -3411,1 +3200,1 @@\n-      _par_scan_state->push_on_queue(p);\n+      _par_scan_state->push_on_queue(ScannerTask(p));\n@@ -3439,38 +3228,5 @@\n-\/\/ Parallel Reference Processing closures\n-\n-\/\/ Implementation of AbstractRefProcTaskExecutor for parallel reference\n-\/\/ processing during G1 evacuation pauses.\n-\n-class G1STWRefProcTaskExecutor: public AbstractRefProcTaskExecutor {\n-private:\n-  G1CollectedHeap*          _g1h;\n-  G1ParScanThreadStateSet*  _pss;\n-  RefToScanQueueSet*        _queues;\n-  WorkGang*                 _workers;\n-\n-public:\n-  G1STWRefProcTaskExecutor(G1CollectedHeap* g1h,\n-                           G1ParScanThreadStateSet* per_thread_states,\n-                           WorkGang* workers,\n-                           RefToScanQueueSet *task_queues) :\n-    _g1h(g1h),\n-    _pss(per_thread_states),\n-    _queues(task_queues),\n-    _workers(workers)\n-  {\n-    g1h->ref_processor_stw()->set_active_mt_degree(workers->active_workers());\n-  }\n-\n-  \/\/ Executes the given task using concurrent marking worker threads.\n-  virtual void execute(ProcessTask& task, uint ergo_workers);\n-};\n-\n-\/\/ Gang task for possibly parallel reference processing\n-\n-class G1STWRefProcTaskProxy: public AbstractGangTask {\n-  typedef AbstractRefProcTaskExecutor::ProcessTask ProcessTask;\n-  ProcessTask&     _proc_task;\n-  G1CollectedHeap* _g1h;\n-  G1ParScanThreadStateSet* _pss;\n-  RefToScanQueueSet* _task_queues;\n-  ParallelTaskTerminator* _terminator;\n+class G1STWRefProcProxyTask : public RefProcProxyTask {\n+  G1CollectedHeap& _g1h;\n+  G1ParScanThreadStateSet& _pss;\n+  TaskTerminator _terminator;\n+  G1ScannerTasksQueueSet& _task_queues;\n@@ -3479,28 +3235,6 @@\n-  G1STWRefProcTaskProxy(ProcessTask& proc_task,\n-                        G1CollectedHeap* g1h,\n-                        G1ParScanThreadStateSet* per_thread_states,\n-                        RefToScanQueueSet *task_queues,\n-                        ParallelTaskTerminator* terminator) :\n-    AbstractGangTask(\"Process reference objects in parallel\"),\n-    _proc_task(proc_task),\n-    _g1h(g1h),\n-    _pss(per_thread_states),\n-    _task_queues(task_queues),\n-    _terminator(terminator)\n-  {}\n-\n-  virtual void work(uint worker_id) {\n-    \/\/ The reference processing task executed by a single worker.\n-    ResourceMark rm;\n-    HandleMark   hm;\n-\n-    G1STWIsAliveClosure is_alive(_g1h);\n-\n-    G1ParScanThreadState* pss = _pss->state_for_worker(worker_id);\n-    pss->set_ref_discoverer(NULL);\n-\n-    \/\/ Keep alive closure.\n-    G1CopyingKeepAliveClosure keep_alive(_g1h, pss);\n-\n-    \/\/ Complete GC closure\n-    G1ParEvacuateFollowersClosure drain_queue(_g1h, pss, _task_queues, _terminator, G1GCPhaseTimes::ObjCopy);\n+  G1STWRefProcProxyTask(uint max_workers, G1CollectedHeap& g1h, G1ParScanThreadStateSet& pss, G1ScannerTasksQueueSet& task_queues)\n+    : RefProcProxyTask(\"G1STWRefProcProxyTask\", max_workers),\n+      _g1h(g1h),\n+      _pss(pss),\n+      _terminator(max_workers, &task_queues),\n+      _task_queues(task_queues) {}\n@@ -3508,2 +3242,9 @@\n-    \/\/ Call the reference processing task's work routine.\n-    _proc_task.work(worker_id, is_alive, keep_alive, drain_queue);\n+  void work(uint worker_id) override {\n+    assert(worker_id < _max_workers, \"sanity\");\n+    uint index = (_tm == RefProcThreadModel::Single) ? 0 : worker_id;\n+    _pss.state_for_worker(index)->set_ref_discoverer(nullptr);\n+    G1STWIsAliveClosure is_alive(&_g1h);\n+    G1CopyingKeepAliveClosure keep_alive(&_g1h, _pss.state_for_worker(index));\n+    G1ParEvacuateFollowersClosure complete_gc(&_g1h, _pss.state_for_worker(index), &_task_queues, _tm == RefProcThreadModel::Single ? nullptr : &_terminator, G1GCPhaseTimes::ObjCopy);\n+    _rp_task->rp_work(worker_id, &is_alive, &keep_alive, &complete_gc);\n+  }\n@@ -3511,4 +3252,2 @@\n-    \/\/ Note we cannot assert that the refs array is empty here as not all\n-    \/\/ of the processing tasks (specifically phase2 - pp2_work) execute\n-    \/\/ the complete_gc closure (which ordinarily would drain the queue) so\n-    \/\/ the queue may not be empty.\n+  void prepare_run_task_hook() override {\n+    _terminator.reset_for_reuse(_queue_count);\n@@ -3518,15 +3257,0 @@\n-\/\/ Driver routine for parallel reference processing.\n-\/\/ Creates an instance of the ref processing gang\n-\/\/ task and has the worker threads execute it.\n-void G1STWRefProcTaskExecutor::execute(ProcessTask& proc_task, uint ergo_workers) {\n-  assert(_workers != NULL, \"Need parallel worker threads.\");\n-\n-  assert(_workers->active_workers() >= ergo_workers,\n-         \"Ergonomically chosen workers (%u) should be less than or equal to active workers (%u)\",\n-         ergo_workers, _workers->active_workers());\n-  TaskTerminator terminator(ergo_workers, _queues);\n-  G1STWRefProcTaskProxy proc_task_proxy(proc_task, _g1h, _pss, _queues, terminator.terminator());\n-\n-  _workers->run_task(&proc_task_proxy, ergo_workers);\n-}\n-\n@@ -3541,8 +3265,0 @@\n-  \/\/ Closure to test whether a referent is alive.\n-  G1STWIsAliveClosure is_alive(this);\n-\n-  \/\/ Even when parallel reference processing is enabled, the processing\n-  \/\/ of JNI refs is serial and performed serially by the current thread\n-  \/\/ rather than by a worker. The following PSS will be used for processing\n-  \/\/ JNI refs.\n-\n@@ -3554,6 +3270,0 @@\n-  \/\/ Keep alive closure.\n-  G1CopyingKeepAliveClosure keep_alive(this, pss);\n-\n-  \/\/ Serial Complete GC closure\n-  G1STWDrainQueueClosure drain_queue(this, pss);\n-\n@@ -3563,1 +3273,1 @@\n-  ReferenceProcessorPhaseTimes* pt = phase_times()->ref_phase_times();\n+  ReferenceProcessorPhaseTimes& pt = *phase_times()->ref_phase_times();\n@@ -3566,9 +3276,1 @@\n-  if (!rp->processing_is_mt()) {\n-    \/\/ Serial reference processing...\n-    stats = rp->process_discovered_references(&is_alive,\n-                                              &keep_alive,\n-                                              &drain_queue,\n-                                              NULL,\n-                                              pt);\n-  } else {\n-    uint no_of_gc_workers = workers()->active_workers();\n+  uint no_of_gc_workers = workers()->active_workers();\n@@ -3576,4 +3278,4 @@\n-    \/\/ Parallel reference processing\n-    assert(no_of_gc_workers <= rp->max_num_queues(),\n-           \"Mismatch between the number of GC workers %u and the maximum number of Reference process queues %u\",\n-           no_of_gc_workers,  rp->max_num_queues());\n+  \/\/ Parallel reference processing\n+  assert(no_of_gc_workers <= rp->max_num_queues(),\n+         \"Mismatch between the number of GC workers %u and the maximum number of Reference process queues %u\",\n+         no_of_gc_workers,  rp->max_num_queues());\n@@ -3581,7 +3283,3 @@\n-    G1STWRefProcTaskExecutor par_task_executor(this, per_thread_states, workers(), _task_queues);\n-    stats = rp->process_discovered_references(&is_alive,\n-                                              &keep_alive,\n-                                              &drain_queue,\n-                                              &par_task_executor,\n-                                              pt);\n-  }\n+  rp->set_active_mt_degree(no_of_gc_workers);\n+  G1STWRefProcProxyTask task(rp->max_num_queues(), *this, *per_thread_states, *_task_queues);\n+  stats = rp->process_discovered_references(task, pt);\n@@ -3604,1 +3302,1 @@\n-  if (collector_state()->in_initial_mark_gc()) {\n+  if (collector_state()->in_concurrent_start_gc()) {\n@@ -3613,4 +3311,10 @@\n-void G1CollectedHeap::merge_per_thread_state_info(G1ParScanThreadStateSet* per_thread_states) {\n-  Ticks start = Ticks::now();\n-  per_thread_states->flush();\n-  phase_times()->record_or_add_time_secs(G1GCPhaseTimes::MergePSS, 0 \/* worker_id *\/, (Ticks::now() - start).seconds());\n+static bool do_humongous_object_logging() {\n+  return log_is_enabled(Debug, gc, humongous);\n+}\n+\n+bool G1CollectedHeap::should_do_eager_reclaim() const {\n+  \/\/ As eager reclaim logging also gives information about humongous objects in\n+  \/\/ the heap in general, always do the eager reclaim pass even without known\n+  \/\/ candidates.\n+  return (G1EagerReclaimHumongousObjects &&\n+          (has_humongous_reclaim_candidates() || do_humongous_object_logging()));\n@@ -3623,2 +3327,2 @@\n-    size_t _worker_humongous_total;\n-    size_t _worker_humongous_candidates;\n+    uint _worker_humongous_total;\n+    uint _worker_humongous_candidates;\n@@ -3629,1 +3333,1 @@\n-      oop obj = oop(region->bottom());\n+      oop obj = cast_to_oop(region->bottom());\n@@ -3714,0 +3418,10 @@\n+      log_debug(gc, humongous)(\"Humongous region %u (object size \" SIZE_FORMAT \" @ \" PTR_FORMAT \") remset \" SIZE_FORMAT \" code roots \" SIZE_FORMAT \" marked %d reclaim candidate %d type array %d\",\n+                               index,\n+                               (size_t)cast_to_oop(hr->bottom())->size() * HeapWordSize,\n+                               p2i(hr->bottom()),\n+                               hr->rem_set()->occupied(),\n+                               hr->rem_set()->strong_code_roots_list_length(),\n+                               _g1h->concurrent_mark()->next_mark_bitmap()->is_marked(hr->bottom()),\n+                               _g1h->is_humongous_reclaim_candidate(index),\n+                               cast_to_oop(hr->bottom())->is_typeArray()\n+                              );\n@@ -3722,2 +3436,2 @@\n-  volatile size_t _humongous_total;\n-  volatile size_t _humongous_candidates;\n+  volatile uint _humongous_total;\n+  volatile uint _humongous_candidates;\n@@ -3732,4 +3446,0 @@\n-  ~G1PrepareEvacuationTask() {\n-    _g1h->set_has_humongous_reclaim_candidate(_humongous_candidates > 0);\n-  }\n-\n@@ -3741,1 +3451,1 @@\n-  void add_humongous_candidates(size_t candidates) {\n+  void add_humongous_candidates(uint candidates) {\n@@ -3745,1 +3455,1 @@\n-  void add_humongous_total(size_t total) {\n+  void add_humongous_total(uint total) {\n@@ -3749,1 +3459,1 @@\n-  size_t humongous_candidates() {\n+  uint humongous_candidates() {\n@@ -3753,1 +3463,1 @@\n-  size_t humongous_total() {\n+  uint humongous_total() {\n@@ -3762,1 +3472,3 @@\n-  _evacuation_failed = false;\n+  Atomic::store(&_num_regions_failed_evacuation, 0u);\n+\n+  memset((void*)_regions_failed_evacuation, false, sizeof(bool) * max_regions());\n@@ -3779,1 +3491,1 @@\n-    Tickspan task_time = run_task(&g1_prep_task);\n+    Tickspan task_time = run_task_timed(&g1_prep_task);\n@@ -3781,3 +3493,3 @@\n-    phase_times()->record_register_regions(task_time.seconds() * 1000.0,\n-                                           g1_prep_task.humongous_total(),\n-                                           g1_prep_task.humongous_candidates());\n+    phase_times()->record_register_regions(task_time.seconds() * 1000.0);\n+    _num_humongous_objects = g1_prep_task.humongous_total();\n+    _num_humongous_reclaim_candidates = g1_prep_task.humongous_candidates();\n@@ -3793,3 +3505,3 @@\n-  \/\/ InitialMark needs claim bits to keep track of the marked-through CLDs.\n-  if (collector_state()->in_initial_mark_gc()) {\n-    concurrent_mark()->pre_initial_mark();\n+  \/\/ Concurrent start needs claim bits to keep track of the marked-through CLDs.\n+  if (collector_state()->in_concurrent_start_gc()) {\n+    concurrent_mark()->pre_concurrent_start(gc_cause());\n@@ -3813,1 +3525,1 @@\n-  RefToScanQueueSet* _task_queues;\n+  G1ScannerTasksQueueSet* _task_queues;\n@@ -3824,1 +3536,1 @@\n-    G1ParEvacuateFollowersClosure cl(_g1h, pss, _task_queues, _terminator.terminator(), objcopy_phase);\n+    G1ParEvacuateFollowersClosure cl(_g1h, pss, _task_queues, &_terminator, objcopy_phase);\n@@ -3839,1 +3551,3 @@\n-    assert(pss->trim_ticks().seconds() == 0.0, \"Unexpected partial trimming during evacuation\");\n+    assert(pss->trim_ticks().value() == 0,\n+           \"Unexpected partial trimming during evacuation value \" JLONG_FORMAT,\n+           pss->trim_ticks().value());\n@@ -3851,1 +3565,4 @@\n-  G1EvacuateRegionsBaseTask(const char* name, G1ParScanThreadStateSet* per_thread_states, RefToScanQueueSet* task_queues, uint num_workers) :\n+  G1EvacuateRegionsBaseTask(const char* name,\n+                            G1ParScanThreadStateSet* per_thread_states,\n+                            G1ScannerTasksQueueSet* task_queues,\n+                            uint num_workers) :\n@@ -3865,1 +3582,0 @@\n-      HandleMark   hm;\n@@ -3880,0 +3596,1 @@\n+  bool _has_optional_evacuation_work;\n@@ -3883,1 +3600,1 @@\n-    _g1h->rem_set()->scan_heap_roots(pss, worker_id, G1GCPhaseTimes::ScanHR, G1GCPhaseTimes::ObjCopy);\n+    _g1h->rem_set()->scan_heap_roots(pss, worker_id, G1GCPhaseTimes::ScanHR, G1GCPhaseTimes::ObjCopy, _has_optional_evacuation_work);\n@@ -3902,1 +3619,1 @@\n-                        RefToScanQueueSet* task_queues,\n+                        G1ScannerTasksQueueSet* task_queues,\n@@ -3904,1 +3621,2 @@\n-                        uint num_workers) :\n+                        uint num_workers,\n+                        bool has_optional_evacuation_work) :\n@@ -3906,1 +3624,2 @@\n-    _root_processor(root_processor)\n+    _root_processor(root_processor),\n+    _has_optional_evacuation_work(has_optional_evacuation_work)\n@@ -3910,1 +3629,2 @@\n-void G1CollectedHeap::evacuate_initial_collection_set(G1ParScanThreadStateSet* per_thread_states) {\n+void G1CollectedHeap::evacuate_initial_collection_set(G1ParScanThreadStateSet* per_thread_states,\n+                                                      bool has_optional_evacuation_work) {\n@@ -3925,2 +3645,7 @@\n-    G1EvacuateRegionsTask g1_par_task(this, per_thread_states, _task_queues, &root_processor, num_workers);\n-    task_time = run_task(&g1_par_task);\n+    G1EvacuateRegionsTask g1_par_task(this,\n+                                      per_thread_states,\n+                                      _task_queues,\n+                                      &root_processor,\n+                                      num_workers,\n+                                      has_optional_evacuation_work);\n+    task_time = run_task_timed(&g1_par_task);\n@@ -3935,0 +3660,2 @@\n+\n+  rem_set()->complete_evac_phase(has_optional_evacuation_work);\n@@ -3940,1 +3667,1 @@\n-    _g1h->rem_set()->scan_heap_roots(pss, worker_id, G1GCPhaseTimes::OptScanHR, G1GCPhaseTimes::OptObjCopy);\n+    _g1h->rem_set()->scan_heap_roots(pss, worker_id, G1GCPhaseTimes::OptScanHR, G1GCPhaseTimes::OptObjCopy, true \/* remember_already_scanned_cards *\/);\n@@ -3950,1 +3677,1 @@\n-                                RefToScanQueueSet* queues,\n+                                G1ScannerTasksQueueSet* queues,\n@@ -3965,1 +3692,1 @@\n-    task_time = run_task(&task);\n+    task_time = run_task_timed(&task);\n@@ -4000,0 +3727,2 @@\n+\n+    rem_set()->complete_evac_phase(true \/* has_more_than_one_evacuation_phase *\/);\n@@ -4010,2 +3739,0 @@\n-  rem_set()->cleanup_after_scan_heap_roots();\n-\n@@ -4024,9 +3751,0 @@\n-  if (G1StringDedup::is_enabled()) {\n-    double string_dedup_time_ms = os::elapsedTime();\n-\n-    string_dedup_cleaning(&is_alive, &keep_alive, p);\n-\n-    double string_cleanup_time_ms = (os::elapsedTime() - string_dedup_time_ms) * 1000.0;\n-    p->record_string_deduplication_time(string_cleanup_time_ms);\n-  }\n-\n@@ -4035,35 +3753,1 @@\n-  if (evacuation_failed()) {\n-    restore_after_evac_failure(rdcqs);\n-\n-    \/\/ Reset the G1EvacuationFailureALot counters and flags\n-    NOT_PRODUCT(reset_evacuation_should_fail();)\n-\n-    double recalculate_used_start = os::elapsedTime();\n-    set_used(recalculate_used());\n-    p->record_evac_fail_recalc_used_time((os::elapsedTime() - recalculate_used_start) * 1000.0);\n-\n-    if (_archive_allocator != NULL) {\n-      _archive_allocator->clear_used();\n-    }\n-    for (uint i = 0; i < ParallelGCThreads; i++) {\n-      if (_evacuation_failed_info_array[i].has_failed()) {\n-        _gc_tracer_stw->report_evacuation_failed(_evacuation_failed_info_array[i]);\n-      }\n-    }\n-  } else {\n-    \/\/ The \"used\" of the the collection set have already been subtracted\n-    \/\/ when they were freed.  Add in the bytes used.\n-    increase_used(_bytes_used_during_gc);\n-  }\n-\n-  _preserved_marks_set.assert_empty();\n-\n-  merge_per_thread_state_info(per_thread_states);\n-\n-  \/\/ Reset and re-enable the hot card cache.\n-  \/\/ Note the counts for the cards in the regions in the\n-  \/\/ collection set are reset when the collection set is freed.\n-  _hot_card_cache->reset_hot_cache();\n-  _hot_card_cache->set_use_cache(true);\n-\n-  purge_code_root_memory();\n+  post_evacuate_cleanup_1(per_thread_states, rdcqs);\n@@ -4071,1 +3755,1 @@\n-  redirty_logged_cards(rdcqs);\n+  post_evacuate_cleanup_2(&_preserved_marks_set, rdcqs, &evacuation_info, per_thread_states->surviving_young_words());\n@@ -4073,1 +3757,1 @@\n-  free_collection_set(&_collection_set, evacuation_info, per_thread_states->surviving_young_words());\n+  assert_used_and_recalculate_used_equal(this);\n@@ -4075,1 +3759,1 @@\n-  eagerly_reclaim_humongous_regions();\n+  rebuild_free_region_list();\n@@ -4082,5 +3766,0 @@\n-#if COMPILER2_OR_JVMCI\n-  double start = os::elapsedTime();\n-  DerivedPointerTable::update_pointers();\n-  phase_times()->record_derived_pointer_table_update_time((os::elapsedTime() - start) * 1000.0);\n-#endif\n@@ -4091,1 +3770,2 @@\n-  policy()->add_bytes_allocated_in_old_since_last_gc(_old_evac_stats.allocated() * HeapWordSize);\n+  policy()->old_gen_alloc_tracker()->\n+    add_allocated_bytes_since_last_gc(_old_evac_stats.allocated() * HeapWordSize);\n@@ -4100,1 +3780,1 @@\n-  assert(_hrm->is_available(hr->hrm_index()), \"region should be committed\");\n+  assert(_hrm.is_available(hr->hrm_index()), \"region should be committed\");\n@@ -4126,1 +3806,0 @@\n-  assert(free_list != NULL, \"pre-condition\");\n@@ -4131,3 +3810,4 @@\n-void G1CollectedHeap::remove_from_old_sets(const uint old_regions_removed,\n-                                           const uint humongous_regions_removed) {\n-  if (old_regions_removed > 0 || humongous_regions_removed > 0) {\n+void G1CollectedHeap::remove_from_old_gen_sets(const uint old_regions_removed,\n+                                               const uint archive_regions_removed,\n+                                               const uint humongous_regions_removed) {\n+  if (old_regions_removed > 0 || archive_regions_removed > 0 || humongous_regions_removed > 0) {\n@@ -4136,0 +3816,1 @@\n+    _archive_set.bulk_remove(archive_regions_removed);\n@@ -4145,1 +3826,1 @@\n-    _hrm->insert_list_into_free_list(list);\n+    _hrm.insert_list_into_free_list(list);\n@@ -4153,259 +3834,3 @@\n-class G1FreeCollectionSetTask : public AbstractGangTask {\n-  \/\/ Helper class to keep statistics for the collection set freeing\n-  class FreeCSetStats {\n-    size_t _before_used_bytes;   \/\/ Usage in regions successfully evacutate\n-    size_t _after_used_bytes;    \/\/ Usage in regions failing evacuation\n-    size_t _bytes_allocated_in_old_since_last_gc; \/\/ Size of young regions turned into old\n-    size_t _failure_used_words;  \/\/ Live size in failed regions\n-    size_t _failure_waste_words; \/\/ Wasted size in failed regions\n-    size_t _rs_length;           \/\/ Remembered set size\n-    uint _regions_freed;         \/\/ Number of regions freed\n-  public:\n-    FreeCSetStats() :\n-        _before_used_bytes(0),\n-        _after_used_bytes(0),\n-        _bytes_allocated_in_old_since_last_gc(0),\n-        _failure_used_words(0),\n-        _failure_waste_words(0),\n-        _rs_length(0),\n-        _regions_freed(0) { }\n-\n-    void merge_stats(FreeCSetStats* other) {\n-      assert(other != NULL, \"invariant\");\n-      _before_used_bytes += other->_before_used_bytes;\n-      _after_used_bytes += other->_after_used_bytes;\n-      _bytes_allocated_in_old_since_last_gc += other->_bytes_allocated_in_old_since_last_gc;\n-      _failure_used_words += other->_failure_used_words;\n-      _failure_waste_words += other->_failure_waste_words;\n-      _rs_length += other->_rs_length;\n-      _regions_freed += other->_regions_freed;\n-    }\n-\n-    void report(G1CollectedHeap* g1h, G1EvacuationInfo* evacuation_info) {\n-      evacuation_info->set_regions_freed(_regions_freed);\n-      evacuation_info->increment_collectionset_used_after(_after_used_bytes);\n-\n-      g1h->decrement_summary_bytes(_before_used_bytes);\n-      g1h->alloc_buffer_stats(G1HeapRegionAttr::Old)->add_failure_used_and_waste(_failure_used_words, _failure_waste_words);\n-\n-      G1Policy *policy = g1h->policy();\n-      policy->add_bytes_allocated_in_old_since_last_gc(_bytes_allocated_in_old_since_last_gc);\n-      policy->record_rs_length(_rs_length);\n-      policy->cset_regions_freed();\n-    }\n-\n-    void account_failed_region(HeapRegion* r) {\n-      size_t used_words = r->marked_bytes() \/ HeapWordSize;\n-      _failure_used_words += used_words;\n-      _failure_waste_words += HeapRegion::GrainWords - used_words;\n-      _after_used_bytes += r->used();\n-\n-      \/\/ When moving a young gen region to old gen, we \"allocate\" that whole\n-      \/\/ region there. This is in addition to any already evacuated objects.\n-      \/\/ Notify the policy about that. Old gen regions do not cause an\n-      \/\/ additional allocation: both the objects still in the region and the\n-      \/\/ ones already moved are accounted for elsewhere.\n-      if (r->is_young()) {\n-        _bytes_allocated_in_old_since_last_gc += HeapRegion::GrainBytes;\n-      }\n-    }\n-\n-    void account_evacuated_region(HeapRegion* r) {\n-      _before_used_bytes += r->used();\n-      _regions_freed += 1;\n-    }\n-\n-    void account_rs_length(HeapRegion* r) {\n-      _rs_length += r->rem_set()->occupied();\n-    }\n-  };\n-\n-  \/\/ Closure applied to all regions in the collection set.\n-  class FreeCSetClosure : public HeapRegionClosure {\n-    \/\/ Helper to send JFR events for regions.\n-    class JFREventForRegion {\n-      EventGCPhaseParallel _event;\n-    public:\n-      JFREventForRegion(HeapRegion* region, uint worker_id) : _event() {\n-        _event.set_gcId(GCId::current());\n-        _event.set_gcWorkerId(worker_id);\n-        if (region->is_young()) {\n-          _event.set_name(G1GCPhaseTimes::phase_name(G1GCPhaseTimes::YoungFreeCSet));\n-        } else {\n-          _event.set_name(G1GCPhaseTimes::phase_name(G1GCPhaseTimes::NonYoungFreeCSet));\n-        }\n-      }\n-\n-      ~JFREventForRegion() {\n-        _event.commit();\n-      }\n-    };\n-\n-    \/\/ Helper to do timing for region work.\n-    class TimerForRegion {\n-      Tickspan& _time;\n-      Ticks     _start_time;\n-    public:\n-      TimerForRegion(Tickspan& time) : _time(time), _start_time(Ticks::now()) { }\n-      ~TimerForRegion() {\n-        _time += Ticks::now() - _start_time;\n-      }\n-    };\n-\n-    \/\/ FreeCSetClosure members\n-    G1CollectedHeap* _g1h;\n-    const size_t*    _surviving_young_words;\n-    uint             _worker_id;\n-    Tickspan         _young_time;\n-    Tickspan         _non_young_time;\n-    FreeCSetStats*   _stats;\n-\n-    void assert_in_cset(HeapRegion* r) {\n-      assert(r->young_index_in_cset() != 0 &&\n-             (uint)r->young_index_in_cset() <= _g1h->collection_set()->young_region_length(),\n-             \"Young index %u is wrong for region %u of type %s with %u young regions\",\n-             r->young_index_in_cset(), r->hrm_index(), r->get_type_str(), _g1h->collection_set()->young_region_length());\n-    }\n-\n-    void handle_evacuated_region(HeapRegion* r) {\n-      assert(!r->is_empty(), \"Region %u is an empty region in the collection set.\", r->hrm_index());\n-      stats()->account_evacuated_region(r);\n-\n-      \/\/ Free the region and and its remembered set.\n-      _g1h->free_region(r, NULL);\n-    }\n-\n-    void handle_failed_region(HeapRegion* r) {\n-      \/\/ Do some allocation statistics accounting. Regions that failed evacuation\n-      \/\/ are always made old, so there is no need to update anything in the young\n-      \/\/ gen statistics, but we need to update old gen statistics.\n-      stats()->account_failed_region(r);\n-\n-      \/\/ Update the region state due to the failed evacuation.\n-      r->handle_evacuation_failure();\n-\n-      \/\/ Add region to old set, need to hold lock.\n-      MutexLocker x(OldSets_lock, Mutex::_no_safepoint_check_flag);\n-      _g1h->old_set_add(r);\n-    }\n-\n-    Tickspan& timer_for_region(HeapRegion* r) {\n-      return r->is_young() ? _young_time : _non_young_time;\n-    }\n-\n-    FreeCSetStats* stats() {\n-      return _stats;\n-    }\n-  public:\n-    FreeCSetClosure(const size_t* surviving_young_words,\n-                    uint worker_id,\n-                    FreeCSetStats* stats) :\n-        HeapRegionClosure(),\n-        _g1h(G1CollectedHeap::heap()),\n-        _surviving_young_words(surviving_young_words),\n-        _worker_id(worker_id),\n-        _young_time(),\n-        _non_young_time(),\n-        _stats(stats) { }\n-\n-    virtual bool do_heap_region(HeapRegion* r) {\n-      assert(r->in_collection_set(), \"Invariant: %u missing from CSet\", r->hrm_index());\n-      JFREventForRegion event(r, _worker_id);\n-      TimerForRegion timer(timer_for_region(r));\n-\n-      _g1h->clear_region_attr(r);\n-      stats()->account_rs_length(r);\n-\n-      if (r->is_young()) {\n-        assert_in_cset(r);\n-        r->record_surv_words_in_group(_surviving_young_words[r->young_index_in_cset()]);\n-      }\n-\n-      if (r->evacuation_failed()) {\n-        handle_failed_region(r);\n-      } else {\n-        handle_evacuated_region(r);\n-      }\n-      assert(!_g1h->is_on_master_free_list(r), \"sanity\");\n-\n-      return false;\n-    }\n-\n-    void report_timing(Tickspan parallel_time) {\n-      G1GCPhaseTimes* pt = _g1h->phase_times();\n-      pt->record_time_secs(G1GCPhaseTimes::ParFreeCSet, _worker_id, parallel_time.seconds());\n-      if (_young_time.value() > 0) {\n-        pt->record_time_secs(G1GCPhaseTimes::YoungFreeCSet, _worker_id, _young_time.seconds());\n-      }\n-      if (_non_young_time.value() > 0) {\n-        pt->record_time_secs(G1GCPhaseTimes::NonYoungFreeCSet, _worker_id, _non_young_time.seconds());\n-      }\n-    }\n-  };\n-\n-  \/\/ G1FreeCollectionSetTask members\n-  G1CollectedHeap*  _g1h;\n-  G1EvacuationInfo* _evacuation_info;\n-  FreeCSetStats*    _worker_stats;\n-  HeapRegionClaimer _claimer;\n-  const size_t*     _surviving_young_words;\n-  uint              _active_workers;\n-\n-  FreeCSetStats* worker_stats(uint worker) {\n-    return &_worker_stats[worker];\n-  }\n-\n-  void report_statistics() {\n-    \/\/ Merge the accounting\n-    FreeCSetStats total_stats;\n-    for (uint worker = 0; worker < _active_workers; worker++) {\n-      total_stats.merge_stats(worker_stats(worker));\n-    }\n-    total_stats.report(_g1h, _evacuation_info);\n-  }\n-\n-public:\n-  G1FreeCollectionSetTask(G1EvacuationInfo* evacuation_info, const size_t* surviving_young_words, uint active_workers) :\n-      AbstractGangTask(\"G1 Free Collection Set\"),\n-      _g1h(G1CollectedHeap::heap()),\n-      _evacuation_info(evacuation_info),\n-      _worker_stats(NEW_C_HEAP_ARRAY(FreeCSetStats, active_workers, mtGC)),\n-      _claimer(active_workers),\n-      _surviving_young_words(surviving_young_words),\n-      _active_workers(active_workers) {\n-    for (uint worker = 0; worker < active_workers; worker++) {\n-      ::new (&_worker_stats[worker]) FreeCSetStats();\n-    }\n-  }\n-\n-  ~G1FreeCollectionSetTask() {\n-    Ticks serial_time = Ticks::now();\n-    report_statistics();\n-    for (uint worker = 0; worker < _active_workers; worker++) {\n-      _worker_stats[worker].~FreeCSetStats();\n-    }\n-    FREE_C_HEAP_ARRAY(FreeCSetStats, _worker_stats);\n-    _g1h->phase_times()->record_serial_free_cset_time_ms((Ticks::now() - serial_time).seconds() * 1000.0);\n-  }\n-\n-  virtual void work(uint worker_id) {\n-    EventGCPhaseParallel event;\n-    Ticks start = Ticks::now();\n-    FreeCSetClosure cl(_surviving_young_words, worker_id, worker_stats(worker_id));\n-    _g1h->collection_set_par_iterate_all(&cl, &_claimer, worker_id);\n-\n-    \/\/ Report the total parallel time along with some more detailed metrics.\n-    cl.report_timing(Ticks::now() - start);\n-    event.commit(GCId::current(), worker_id, G1GCPhaseTimes::phase_name(G1GCPhaseTimes::ParFreeCSet));\n-  }\n-};\n-\n-void G1CollectedHeap::free_collection_set(G1CollectionSet* collection_set, G1EvacuationInfo& evacuation_info, const size_t* surviving_young_words) {\n-  _eden.clear();\n-\n-  \/\/ The free collections set is split up in two tasks, the first\n-  \/\/ frees the collection set and records what regions are free,\n-  \/\/ and the second one rebuilds the free list. This proved to be\n-  \/\/ more efficient than adding a sorted list to another.\n-\n-  Ticks free_cset_start_time = Ticks::now();\n+void G1CollectedHeap::post_evacuate_cleanup_1(G1ParScanThreadStateSet* per_thread_states,\n+                                              G1RedirtyCardsQueueSet* rdcqs) {\n+  Ticks start = Ticks::now();\n@@ -4413,7 +3838,2 @@\n-    uint const num_cs_regions = _collection_set.region_length();\n-    uint const num_workers = clamp(num_cs_regions, 1u, workers()->active_workers());\n-    G1FreeCollectionSetTask cl(&evacuation_info, surviving_young_words, num_workers);\n-\n-    log_debug(gc, ergo)(\"Running %s using %u workers for collection set length %u (%u)\",\n-                        cl.name(), num_workers, num_cs_regions, num_regions());\n-    workers()->run_task(&cl, num_workers);\n+    G1PostEvacuateCollectionSetCleanupTask1 cl(per_thread_states, rdcqs);\n+    run_batch_task(&cl);\n@@ -4421,9 +3841,1 @@\n-\n-  Ticks free_cset_end_time = Ticks::now();\n-  phase_times()->record_total_free_cset_time_ms((free_cset_end_time - free_cset_start_time).seconds() * 1000.0);\n-\n-  \/\/ Now rebuild the free region list.\n-  hrm()->rebuild_free_list(workers());\n-  phase_times()->record_total_rebuild_freelist_time_ms((Ticks::now() - free_cset_end_time).seconds() * 1000.0);\n-\n-  collection_set->clear();\n+  phase_times()->record_post_evacuate_cleanup_task_1_time((Ticks::now() - start).seconds() * 1000.0);\n@@ -4432,122 +3844,8 @@\n-class G1FreeHumongousRegionClosure : public HeapRegionClosure {\n- private:\n-  FreeRegionList* _free_region_list;\n-  HeapRegionSet* _proxy_set;\n-  uint _humongous_objects_reclaimed;\n-  uint _humongous_regions_reclaimed;\n-  size_t _freed_bytes;\n- public:\n-\n-  G1FreeHumongousRegionClosure(FreeRegionList* free_region_list) :\n-    _free_region_list(free_region_list), _proxy_set(NULL), _humongous_objects_reclaimed(0), _humongous_regions_reclaimed(0), _freed_bytes(0) {\n-  }\n-\n-  virtual bool do_heap_region(HeapRegion* r) {\n-    if (!r->is_starts_humongous()) {\n-      return false;\n-    }\n-\n-    G1CollectedHeap* g1h = G1CollectedHeap::heap();\n-\n-    oop obj = (oop)r->bottom();\n-    G1CMBitMap* next_bitmap = g1h->concurrent_mark()->next_mark_bitmap();\n-\n-    \/\/ The following checks whether the humongous object is live are sufficient.\n-    \/\/ The main additional check (in addition to having a reference from the roots\n-    \/\/ or the young gen) is whether the humongous object has a remembered set entry.\n-    \/\/\n-    \/\/ A humongous object cannot be live if there is no remembered set for it\n-    \/\/ because:\n-    \/\/ - there can be no references from within humongous starts regions referencing\n-    \/\/ the object because we never allocate other objects into them.\n-    \/\/ (I.e. there are no intra-region references that may be missed by the\n-    \/\/ remembered set)\n-    \/\/ - as soon there is a remembered set entry to the humongous starts region\n-    \/\/ (i.e. it has \"escaped\" to an old object) this remembered set entry will stay\n-    \/\/ until the end of a concurrent mark.\n-    \/\/\n-    \/\/ It is not required to check whether the object has been found dead by marking\n-    \/\/ or not, in fact it would prevent reclamation within a concurrent cycle, as\n-    \/\/ all objects allocated during that time are considered live.\n-    \/\/ SATB marking is even more conservative than the remembered set.\n-    \/\/ So if at this point in the collection there is no remembered set entry,\n-    \/\/ nobody has a reference to it.\n-    \/\/ At the start of collection we flush all refinement logs, and remembered sets\n-    \/\/ are completely up-to-date wrt to references to the humongous object.\n-    \/\/\n-    \/\/ Other implementation considerations:\n-    \/\/ - never consider object arrays at this time because they would pose\n-    \/\/ considerable effort for cleaning up the the remembered sets. This is\n-    \/\/ required because stale remembered sets might reference locations that\n-    \/\/ are currently allocated into.\n-    uint region_idx = r->hrm_index();\n-    if (!g1h->is_humongous_reclaim_candidate(region_idx) ||\n-        !r->rem_set()->is_empty()) {\n-      log_debug(gc, humongous)(\"Live humongous region %u object size \" SIZE_FORMAT \" start \" PTR_FORMAT \"  with remset \" SIZE_FORMAT \" code roots \" SIZE_FORMAT \" is marked %d reclaim candidate %d type array %d\",\n-                               region_idx,\n-                               (size_t)obj->size() * HeapWordSize,\n-                               p2i(r->bottom()),\n-                               r->rem_set()->occupied(),\n-                               r->rem_set()->strong_code_roots_list_length(),\n-                               next_bitmap->is_marked(r->bottom()),\n-                               g1h->is_humongous_reclaim_candidate(region_idx),\n-                               obj->is_typeArray()\n-                              );\n-      return false;\n-    }\n-\n-    guarantee(obj->is_typeArray(),\n-              \"Only eagerly reclaiming type arrays is supported, but the object \"\n-              PTR_FORMAT \" is not.\", p2i(r->bottom()));\n-\n-    log_debug(gc, humongous)(\"Dead humongous region %u object size \" SIZE_FORMAT \" start \" PTR_FORMAT \" with remset \" SIZE_FORMAT \" code roots \" SIZE_FORMAT \" is marked %d reclaim candidate %d type array %d\",\n-                             region_idx,\n-                             (size_t)obj->size() * HeapWordSize,\n-                             p2i(r->bottom()),\n-                             r->rem_set()->occupied(),\n-                             r->rem_set()->strong_code_roots_list_length(),\n-                             next_bitmap->is_marked(r->bottom()),\n-                             g1h->is_humongous_reclaim_candidate(region_idx),\n-                             obj->is_typeArray()\n-                            );\n-\n-    G1ConcurrentMark* const cm = g1h->concurrent_mark();\n-    cm->humongous_object_eagerly_reclaimed(r);\n-    assert(!cm->is_marked_in_prev_bitmap(obj) && !cm->is_marked_in_next_bitmap(obj),\n-           \"Eagerly reclaimed humongous region %u should not be marked at all but is in prev %s next %s\",\n-           region_idx,\n-           BOOL_TO_STR(cm->is_marked_in_prev_bitmap(obj)),\n-           BOOL_TO_STR(cm->is_marked_in_next_bitmap(obj)));\n-    _humongous_objects_reclaimed++;\n-    do {\n-      HeapRegion* next = g1h->next_region_in_humongous(r);\n-      _freed_bytes += r->used();\n-      r->set_containing_set(NULL);\n-      _humongous_regions_reclaimed++;\n-      g1h->free_humongous_region(r, _free_region_list);\n-      r = next;\n-    } while (r != NULL);\n-\n-    return false;\n-  }\n-\n-  uint humongous_objects_reclaimed() {\n-    return _humongous_objects_reclaimed;\n-  }\n-\n-  uint humongous_regions_reclaimed() {\n-    return _humongous_regions_reclaimed;\n-  }\n-\n-  size_t bytes_freed() const {\n-    return _freed_bytes;\n-  }\n-};\n-\n-void G1CollectedHeap::eagerly_reclaim_humongous_regions() {\n-  assert_at_safepoint_on_vm_thread();\n-\n-  if (!G1EagerReclaimHumongousObjects ||\n-      (!_has_humongous_reclaim_candidates && !log_is_enabled(Debug, gc, humongous))) {\n-    phase_times()->record_fast_reclaim_humongous_time_ms(0.0, 0);\n-    return;\n+void G1CollectedHeap::post_evacuate_cleanup_2(PreservedMarksSet* preserved_marks,\n+                                              G1RedirtyCardsQueueSet* rdcqs,\n+                                              G1EvacuationInfo* evacuation_info,\n+                                              const size_t* surviving_young_words) {\n+  Ticks start = Ticks::now();\n+  {\n+    G1PostEvacuateCollectionSetCleanupTask2 cl(preserved_marks, rdcqs, evacuation_info, surviving_young_words);\n+    run_batch_task(&cl);\n@@ -4555,0 +3853,2 @@\n+  phase_times()->record_post_evacuate_cleanup_task_2_time((Ticks::now() - start).seconds() * 1000.0);\n+}\n@@ -4556,17 +3856,3 @@\n-  double start_time = os::elapsedTime();\n-\n-  FreeRegionList local_cleanup_list(\"Local Humongous Cleanup List\");\n-\n-  G1FreeHumongousRegionClosure cl(&local_cleanup_list);\n-  heap_region_iterate(&cl);\n-\n-  remove_from_old_sets(0, cl.humongous_regions_reclaimed());\n-\n-  G1HRPrinter* hrp = hr_printer();\n-  if (hrp->is_active()) {\n-    FreeRegionListIterator iter(&local_cleanup_list);\n-    while (iter.more_available()) {\n-      HeapRegion* hr = iter.get_next();\n-      hrp->cleanup(hr);\n-    }\n-  }\n+void G1CollectedHeap::clear_eden() {\n+  _eden.clear();\n+}\n@@ -4574,2 +3860,3 @@\n-  prepend_to_freelist(&local_cleanup_list);\n-  decrement_summary_bytes(cl.bytes_freed());\n+void G1CollectedHeap::clear_collection_set() {\n+  collection_set()->clear();\n+}\n@@ -4577,2 +3864,4 @@\n-  phase_times()->record_fast_reclaim_humongous_time_ms((os::elapsedTime() - start_time) * 1000.0,\n-                                                       cl.humongous_objects_reclaimed());\n+void G1CollectedHeap::rebuild_free_region_list() {\n+  Ticks start = Ticks::now();\n+  _hrm.rebuild_free_list(workers());\n+  phase_times()->record_total_rebuild_freelist_time_ms((Ticks::now() - start).seconds() * 1000.0);\n@@ -4638,36 +3927,12 @@\n-class TearDownRegionSetsClosure : public HeapRegionClosure {\n-  HeapRegionSet *_old_set;\n-\n-public:\n-  TearDownRegionSetsClosure(HeapRegionSet* old_set) : _old_set(old_set) { }\n-\n-  bool do_heap_region(HeapRegion* r) {\n-    if (r->is_old()) {\n-      _old_set->remove(r);\n-    } else if(r->is_young()) {\n-      r->uninstall_surv_rate_group();\n-    } else {\n-      \/\/ We ignore free regions, we'll empty the free list afterwards.\n-      \/\/ We ignore humongous and archive regions, we're not tearing down these\n-      \/\/ sets.\n-      assert(r->is_archive() || r->is_free() || r->is_humongous(),\n-             \"it cannot be another type\");\n-    }\n-    return false;\n-  }\n-\n-  ~TearDownRegionSetsClosure() {\n-    assert(_old_set->is_empty(), \"post-condition\");\n-  }\n-};\n-\n-void G1CollectedHeap::tear_down_region_sets(bool free_list_only) {\n-  assert_at_safepoint_on_vm_thread();\n-\n-  if (!free_list_only) {\n-    TearDownRegionSetsClosure cl(&_old_set);\n-    heap_region_iterate(&cl);\n-\n-    \/\/ Note that emptying the _young_list is postponed and instead done as\n-    \/\/ the first step when rebuilding the regions sets again. The reason for\n-    \/\/ this is that during a full GC string deduplication needs to know if\n+\/\/ Remove the given HeapRegion from the appropriate region set.\n+void G1CollectedHeap::prepare_region_for_full_compaction(HeapRegion* hr) {\n+   if (hr->is_archive()) {\n+    _archive_set.remove(hr);\n+  } else if (hr->is_humongous()) {\n+    _humongous_set.remove(hr);\n+  } else if (hr->is_old()) {\n+    _old_set.remove(hr);\n+  } else if (hr->is_young()) {\n+    \/\/ Note that emptying the eden and survivor lists is postponed and instead\n+    \/\/ done as the first step when rebuilding the regions sets again. The reason\n+    \/\/ for this is that during a full GC string deduplication needs to know if\n@@ -4675,0 +3940,4 @@\n+    hr->uninstall_surv_rate_group();\n+  } else {\n+    \/\/ We ignore free regions, we'll empty the free list afterwards.\n+    assert(hr->is_free(), \"it cannot be another type\");\n@@ -4676,1 +3945,0 @@\n-  _hrm->remove_all_free_regions();\n@@ -4699,0 +3967,3 @@\n+  HeapRegionSet* _archive_set;\n+  HeapRegionSet* _humongous_set;\n+\n@@ -4706,0 +3977,2 @@\n+                           HeapRegionSet* archive_set,\n+                           HeapRegionSet* humongous_set,\n@@ -4707,2 +3980,2 @@\n-    _free_list_only(free_list_only),\n-    _old_set(old_set), _hrm(hrm), _total_used(0) {\n+    _free_list_only(free_list_only), _old_set(old_set), _archive_set(archive_set),\n+    _humongous_set(humongous_set), _hrm(hrm), _total_used(0) {\n@@ -4712,0 +3985,2 @@\n+      assert(_archive_set->is_empty(), \"pre-condition\");\n+      assert(_humongous_set->is_empty(), \"pre-condition\");\n@@ -4724,2 +3999,4 @@\n-      if (r->is_archive() || r->is_humongous()) {\n-        \/\/ We ignore archive and humongous regions. We left these sets unchanged.\n+      if (r->is_humongous()) {\n+        _humongous_set->add(r);\n+      } else if (r->is_archive()) {\n+        _archive_set->add(r);\n@@ -4728,1 +4005,2 @@\n-        \/\/ We now move all (non-humongous, non-old, non-archive) regions to old gen, and register them as such.\n+        \/\/ We now move all (non-humongous, non-old, non-archive) regions to old gen,\n+        \/\/ and register them as such.\n@@ -4751,1 +4029,3 @@\n-  RebuildRegionSetsClosure cl(free_list_only, &_old_set, _hrm);\n+  RebuildRegionSetsClosure cl(free_list_only,\n+                              &_old_set, &_archive_set, &_humongous_set,\n+                              &_hrm);\n@@ -4859,1 +4139,1 @@\n-  bool const during_im = collector_state()->in_initial_mark_gc();\n+  bool const during_im = collector_state()->in_concurrent_start_gc();\n@@ -4868,1 +4148,1 @@\n-  uint index = _hrm->find_highest_free(&expanded);\n+  uint index = _hrm.find_highest_free(&expanded);\n@@ -4875,2 +4155,1 @@\n-    _hrm->allocate_free_regions_starting_at(index, 1);\n-    return region_at(index);\n+    return _hrm.allocate_free_regions_starting_at(index, 1);\n@@ -4948,0 +4227,27 @@\n+void G1CollectedHeap::update_used_after_gc() {\n+  if (evacuation_failed()) {\n+    \/\/ Reset the G1EvacuationFailureALot counters and flags\n+    NOT_PRODUCT(reset_evacuation_should_fail();)\n+\n+    set_used(recalculate_used());\n+\n+    if (_archive_allocator != NULL) {\n+      _archive_allocator->clear_used();\n+    }\n+    for (uint i = 0; i < ParallelGCThreads; i++) {\n+      if (_evacuation_failed_info_array[i].has_failed()) {\n+        _gc_tracer_stw->report_evacuation_failed(_evacuation_failed_info_array[i]);\n+      }\n+    }\n+  } else {\n+    \/\/ The \"used\" of the the collection set have already been subtracted\n+    \/\/ when they were freed.  Add in the bytes used.\n+    increase_used(_bytes_used_during_gc);\n+  }\n+}\n+\n+void G1CollectedHeap::reset_hot_card_cache() {\n+  _hot_card_cache->reset_hot_cache();\n+  _hot_card_cache->set_use_cache(true);\n+}\n+\n@@ -4949,3 +4255,0 @@\n-  double purge_start = os::elapsedTime();\n-  double purge_time_ms = (os::elapsedTime() - purge_start) * 1000.0;\n-  phase_times()->record_strong_code_root_purge_time(purge_time_ms);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":669,"deletions":1366,"binary":false,"changes":2035,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,11 +53,2 @@\n-size_t G1HeapSizingPolicy::expansion_amount() {\n-  double recent_gc_overhead = _analytics->recent_avg_pause_time_ratio() * 100.0;\n-  double last_gc_overhead = _analytics->last_pause_time_ratio() * 100.0;\n-  assert(GCTimeRatio > 0,\n-         \"we should have set it to a default value set_g1_gc_flags() \"\n-         \"if a user set it to 0\");\n-  const double gc_overhead_percent = 100.0 * (1.0 \/ (1.0 + GCTimeRatio));\n-\n-  double threshold = gc_overhead_percent;\n-  size_t expand_bytes = 0;\n-\n+double G1HeapSizingPolicy::scale_with_heap(double pause_time_threshold) {\n+  double threshold = pause_time_threshold;\n@@ -65,1 +56,1 @@\n-  \/\/ to a limit of 1. Thus the smaller the heap is, the more likely it is to expand,\n+  \/\/ to a limit of 1%. Thus the smaller the heap is, the more likely it is to expand,\n@@ -69,1 +60,40 @@\n-    threshold = MAX2(threshold, 1.0);\n+    threshold = MAX2(threshold, 0.01);\n+  }\n+\n+  return threshold;\n+}\n+\n+static void log_expansion(double short_term_pause_time_ratio,\n+                          double long_term_pause_time_ratio,\n+                          double threshold,\n+                          double pause_time_ratio,\n+                          bool fully_expanded,\n+                          size_t resize_bytes) {\n+\n+  log_debug(gc, ergo, heap)(\"Heap expansion: \"\n+                            \"short term pause time ratio %1.2f%% long term pause time ratio %1.2f%% \"\n+                            \"threshold %1.2f%% pause time ratio %1.2f%% fully expanded %s \"\n+                            \"resize by \" SIZE_FORMAT \"B\",\n+                            short_term_pause_time_ratio * 100.0,\n+                            long_term_pause_time_ratio * 100.0,\n+                            threshold * 100.0,\n+                            pause_time_ratio * 100.0,\n+                            BOOL_TO_STR(fully_expanded),\n+                            resize_bytes);\n+}\n+\n+size_t G1HeapSizingPolicy::young_collection_expansion_amount() {\n+  assert(GCTimeRatio > 0, \"must be\");\n+\n+  double long_term_pause_time_ratio = _analytics->long_term_pause_time_ratio();\n+  double short_term_pause_time_ratio = _analytics->short_term_pause_time_ratio();\n+  const double pause_time_threshold = 1.0 \/ (1.0 + GCTimeRatio);\n+  double threshold = scale_with_heap(pause_time_threshold);\n+\n+  size_t expand_bytes = 0;\n+\n+  if (_g1h->capacity() == _g1h->max_capacity()) {\n+    log_expansion(short_term_pause_time_ratio, long_term_pause_time_ratio,\n+                  threshold, pause_time_threshold, true, 0);\n+    clear_ratio_check_data();\n+    return expand_bytes;\n@@ -75,1 +105,1 @@\n-  if (last_gc_overhead > threshold) {\n+  if (short_term_pause_time_ratio > threshold) {\n@@ -77,1 +107,1 @@\n-    _ratio_over_threshold_sum += last_gc_overhead;\n+    _ratio_over_threshold_sum += short_term_pause_time_ratio;\n@@ -80,0 +110,7 @@\n+  log_trace(gc, ergo, heap)(\"Heap expansion triggers: pauses since start: %u \"\n+                            \"num prev pauses for heuristics: %u \"\n+                            \"ratio over threshold count: %u\",\n+                            _pauses_since_start,\n+                            _num_prev_pauses_for_heuristics,\n+                            _ratio_over_threshold_count);\n+\n@@ -87,1 +124,1 @@\n-      (filled_history_buffer && (recent_gc_overhead > threshold))) {\n+      (filled_history_buffer && (long_term_pause_time_ratio > threshold))) {\n@@ -115,3 +152,3 @@\n-      double const StartScaleDownAt = gc_overhead_percent;\n-      double const StartScaleUpAt = gc_overhead_percent * 1.5;\n-      double const ScaleUpRange = gc_overhead_percent * 2.0;\n+      double const StartScaleDownAt = pause_time_threshold;\n+      double const StartScaleUpAt = pause_time_threshold * 1.5;\n+      double const ScaleUpRange = pause_time_threshold * 2.0;\n@@ -121,1 +158,1 @@\n-        ratio_delta = recent_gc_overhead - threshold;\n+        ratio_delta = long_term_pause_time_ratio - threshold;\n@@ -123,1 +160,1 @@\n-        ratio_delta = (_ratio_over_threshold_sum\/_ratio_over_threshold_count) - threshold;\n+        ratio_delta = (_ratio_over_threshold_sum \/ _ratio_over_threshold_count) - threshold;\n@@ -136,4 +173,0 @@\n-    log_debug(gc, ergo, heap)(\"Attempt heap expansion (recent GC overhead higher than threshold after GC) \"\n-                              \"recent GC overhead: %1.2f %% threshold: %1.2f %% uncommitted: \" SIZE_FORMAT \"B base expansion amount and scale: \" SIZE_FORMAT \"B (%1.2f%%)\",\n-                              recent_gc_overhead, threshold, uncommitted_bytes, expand_bytes, scale_factor * 100);\n-\n@@ -144,2 +177,1 @@\n-    expand_bytes = MAX2(expand_bytes, min_expand_bytes);\n-    expand_bytes = MIN2(expand_bytes, uncommitted_bytes);\n+    expand_bytes = clamp(expand_bytes, min_expand_bytes, uncommitted_bytes);\n@@ -161,0 +193,3 @@\n+  log_expansion(short_term_pause_time_ratio, long_term_pause_time_ratio,\n+                threshold, pause_time_threshold, false, expand_bytes);\n+\n@@ -163,0 +198,78 @@\n+\n+static size_t target_heap_capacity(size_t used_bytes, uintx free_ratio) {\n+  const double desired_free_percentage = (double) free_ratio \/ 100.0;\n+  const double desired_used_percentage = 1.0 - desired_free_percentage;\n+\n+  \/\/ We have to be careful here as these two calculations can overflow\n+  \/\/ 32-bit size_t's.\n+  double used_bytes_d = (double) used_bytes;\n+  double desired_capacity_d = used_bytes_d \/ desired_used_percentage;\n+  \/\/ Let's make sure that they are both under the max heap size, which\n+  \/\/ by default will make it fit into a size_t.\n+  double desired_capacity_upper_bound = (double) MaxHeapSize;\n+  desired_capacity_d = MIN2(desired_capacity_d, desired_capacity_upper_bound);\n+  \/\/ We can now safely turn it into size_t's.\n+  return (size_t) desired_capacity_d;\n+}\n+\n+size_t G1HeapSizingPolicy::full_collection_resize_amount(bool& expand) {\n+  \/\/ Capacity, free and used after the GC counted as full regions to\n+  \/\/ include the waste in the following calculations.\n+  const size_t capacity_after_gc = _g1h->capacity();\n+  const size_t used_after_gc = capacity_after_gc - _g1h->unused_committed_regions_in_bytes();\n+\n+  size_t minimum_desired_capacity = target_heap_capacity(used_after_gc, MinHeapFreeRatio);\n+  size_t maximum_desired_capacity = target_heap_capacity(used_after_gc, MaxHeapFreeRatio);\n+\n+  \/\/ This assert only makes sense here, before we adjust them\n+  \/\/ with respect to the min and max heap size.\n+  assert(minimum_desired_capacity <= maximum_desired_capacity,\n+         \"minimum_desired_capacity = \" SIZE_FORMAT \", \"\n+         \"maximum_desired_capacity = \" SIZE_FORMAT,\n+         minimum_desired_capacity, maximum_desired_capacity);\n+\n+  \/\/ Should not be greater than the heap max size. No need to adjust\n+  \/\/ it with respect to the heap min size as it's a lower bound (i.e.,\n+  \/\/ we'll try to make the capacity larger than it, not smaller).\n+  minimum_desired_capacity = MIN2(minimum_desired_capacity, MaxHeapSize);\n+  \/\/ Should not be less than the heap min size. No need to adjust it\n+  \/\/ with respect to the heap max size as it's an upper bound (i.e.,\n+  \/\/ we'll try to make the capacity smaller than it, not greater).\n+  maximum_desired_capacity =  MAX2(maximum_desired_capacity, MinHeapSize);\n+\n+  \/\/ Handle do_cleanup_unused here to print correct capacity below.\n+  if (Universe::heap()->do_cleanup_unused()) {\n+    \/\/ HeapRegionManager::shrink_by do not allow remove all regions.\n+    \/\/ Make sure at least one is there.\n+    maximum_desired_capacity = HeapRegion::GrainBytes;\n+  }\n+\n+  \/\/ Don't expand unless it's significant; prefer expansion to shrinking.\n+  if (capacity_after_gc < minimum_desired_capacity) {\n+    size_t expand_bytes = minimum_desired_capacity - capacity_after_gc;\n+\n+    log_debug(gc, ergo, heap)(\"Attempt heap expansion (capacity lower than min desired capacity). \"\n+                              \"Capacity: \" SIZE_FORMAT \"B occupancy: \" SIZE_FORMAT \"B live: \" SIZE_FORMAT \"B \"\n+                              \"min_desired_capacity: \" SIZE_FORMAT \"B (\" UINTX_FORMAT \" %%)\",\n+                              capacity_after_gc, used_after_gc, _g1h->used(), minimum_desired_capacity, MinHeapFreeRatio);\n+\n+    expand = true;\n+    return expand_bytes;\n+    \/\/ No expansion, now see if we want to shrink\n+  } else if (capacity_after_gc > maximum_desired_capacity) {\n+    \/\/ Capacity too large, compute shrinking size\n+    size_t shrink_bytes = capacity_after_gc - maximum_desired_capacity;\n+\n+    log_debug(gc, ergo, heap)(\"Attempt heap shrinking (capacity higher than max desired capacity). \"\n+                              \"Capacity: \" SIZE_FORMAT \"B occupancy: \" SIZE_FORMAT \"B live: \" SIZE_FORMAT \"B \"\n+                              \"maximum_desired_capacity: \" SIZE_FORMAT \"B (\" UINTX_FORMAT \" %%)\",\n+                              capacity_after_gc, used_after_gc, _g1h->used(), maximum_desired_capacity, MaxHeapFreeRatio);\n+\n+    expand = false;\n+    return shrink_bytes;\n+  }\n+\n+  expand = true; \/\/ Does not matter.\n+  return 0;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapSizingPolicy.cpp","additions":141,"deletions":28,"binary":false,"changes":169,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2019, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Azul Systems, Inc. All rights reserved.\n@@ -27,1 +27,0 @@\n-#include \"aot\/aotLoader.hpp\"\n@@ -34,0 +33,1 @@\n+#include \"compiler\/oopMap.hpp\"\n@@ -53,0 +53,3 @@\n+#include \"gc\/shared\/oopStorage.inline.hpp\"\n+#include \"gc\/shared\/oopStorageSet.inline.hpp\"\n+#include \"gc\/shared\/oopStorageSetParState.inline.hpp\"\n@@ -57,1 +60,2 @@\n-#include \"gc\/shared\/weakProcessor.hpp\"\n+#include \"gc\/shared\/taskTerminator.hpp\"\n+#include \"gc\/shared\/weakProcessor.inline.hpp\"\n@@ -62,0 +66,1 @@\n+#include \"memory\/metaspaceUtils.hpp\"\n@@ -73,0 +78,1 @@\n+#include \"runtime\/java.hpp\"\n@@ -75,1 +81,0 @@\n-#include \"services\/management.hpp\"\n@@ -409,7 +414,0 @@\n-#ifdef  ASSERT\n-size_t add_obj_count;\n-size_t add_obj_size;\n-size_t mark_bitmap_count;\n-size_t mark_bitmap_size;\n-#endif  \/\/ #ifdef ASSERT\n-\n@@ -452,1 +450,1 @@\n-  ReservedSpace rs(_reserved_byte_size, rs_align, rs_align > 0);\n+  ReservedSpace rs(_reserved_byte_size, rs_align, page_sz);\n@@ -533,0 +531,1 @@\n+  \/\/ end_region is inclusive\n@@ -535,3 +534,0 @@\n-  DEBUG_ONLY(Atomic::inc(&add_obj_count);)\n-  DEBUG_ONLY(Atomic::add(&add_obj_size, len);)\n-\n@@ -548,1 +544,0 @@\n-  Klass* klass = ((oop)addr)->klass();\n@@ -564,2 +559,2 @@\n-  assert(region_offset(beg) == 0, \"not RegionSize aligned\");\n-  assert(region_offset(end) == 0, \"not RegionSize aligned\");\n+  assert(is_region_aligned(beg), \"not RegionSize aligned\");\n+  assert(is_region_aligned(end), \"not RegionSize aligned\");\n@@ -761,1 +756,1 @@\n-      } else if (region_offset(dest_addr) == 0) {\n+      } else if (is_region_aligned(dest_addr)) {\n@@ -779,1 +774,1 @@\n-HeapWord* ParallelCompactData::calc_new_pointer(HeapWord* addr, ParCompactionManager* cm) {\n+HeapWord* ParallelCompactData::calc_new_pointer(HeapWord* addr, ParCompactionManager* cm) const {\n@@ -816,1 +811,1 @@\n-  const size_t live = bitmap->live_words_in_range(cm, search_start, oop(addr));\n+  const size_t live = bitmap->live_words_in_range(cm, search_start, cast_to_oop(addr));\n@@ -844,1 +839,0 @@\n-jlong               PSParallelCompact::_time_of_last_gc = 0;\n@@ -859,1 +853,0 @@\n-      ParallelRefProcEnabled && (ParallelGCThreads > 1), \/\/ mt processing\n@@ -992,3 +985,0 @@\n-  DEBUG_ONLY(add_obj_count = add_obj_size = 0;)\n-  DEBUG_ONLY(mark_bitmap_count = mark_bitmap_size = 0;)\n-\n@@ -1008,1 +998,0 @@\n-    HandleMark hm;  \/\/ Discard invalid handles created during verification\n@@ -1042,4 +1031,0 @@\n-  if (!eden_empty) {\n-    eden_empty = absorb_live_data_from_eden(heap->size_policy(),\n-                                            heap->young_gen(), heap->old_gen());\n-  }\n@@ -1049,1 +1034,1 @@\n-  Universe::update_heap_info_at_gc();\n+  Universe::heap()->update_capacity_and_used_at_gc();\n@@ -1063,2 +1048,2 @@\n-  ClassLoaderDataGraph::purge();\n-  MetaspaceUtils::verify_metrics();\n+  ClassLoaderDataGraph::purge(\/*at_safepoint*\/true);\n+  DEBUG_ONLY(MetaspaceUtils::verify();)\n@@ -1076,2 +1061,2 @@\n-  \/\/ Update time of last GC\n-  reset_millis_since_last_gc();\n+  \/\/ Signal that we have completed a visit to all live objects.\n+  Universe::heap()->record_whole_heap_examined_timestamp();\n@@ -1118,8 +1103,8 @@\n-  if (TraceParallelOldGCDensePrefix) {\n-    tty->print_cr(\"cur_dens=%5.3f dw_dens=%5.3f dw_goal=\" SIZE_FORMAT,\n-                  cur_density, deadwood_density, deadwood_goal);\n-    tty->print_cr(\"space_live=\" SIZE_FORMAT \" \" \"space_used=\" SIZE_FORMAT \" \"\n-                  \"space_cap=\" SIZE_FORMAT,\n-                  space_live, space_used,\n-                  space_capacity);\n-  }\n+  log_develop_debug(gc, compaction)(\n+      \"cur_dens=%5.3f dw_dens=%5.3f dw_goal=\" SIZE_FORMAT,\n+      cur_density, deadwood_density, deadwood_goal);\n+  log_develop_debug(gc, compaction)(\n+      \"space_live=\" SIZE_FORMAT \" space_used=\" SIZE_FORMAT \" \"\n+      \"space_cap=\" SIZE_FORMAT,\n+      space_live, space_used,\n+      space_capacity);\n@@ -1134,6 +1119,6 @@\n-    if (TraceParallelOldGCDensePrefix && Verbose) {\n-      tty->print_cr(\"c#=\" SIZE_FORMAT_W(4) \" dst=\" PTR_FORMAT \" \"\n-                    \"dp=\" PTR_FORMAT \" \" \"cdw=\" SIZE_FORMAT_W(8),\n-                    sd.region(cp), p2i(region_destination),\n-                    p2i(dense_prefix), cur_deadwood);\n-    }\n+\n+    log_develop_trace(gc, compaction)(\n+        \"c#=\" SIZE_FORMAT_W(4) \" dst=\" PTR_FORMAT \" \"\n+        \"dp=\" PTR_FORMAT \" cdw=\" SIZE_FORMAT_W(8),\n+        sd.region(cp), p2i(region_destination),\n+        p2i(dense_prefix), cur_deadwood);\n@@ -1161,5 +1146,7 @@\n-        if (TraceParallelOldGCDensePrefix && Verbose) {\n-          tty->print_cr(\"backing up from c=\" SIZE_FORMAT_W(4) \" d2r=%10.8f \"\n-                        \"pc_d2r=%10.8f\", sd.region(cp), density_to_right,\n-                        prev_region_density_to_right);\n-        }\n+\n+        log_develop_trace(gc, compaction)(\n+            \"backing up from c=\" SIZE_FORMAT_W(4) \" d2r=%10.8f \"\n+            \"pc_d2r=%10.8f\",\n+            sd.region(cp), density_to_right,\n+            prev_region_density_to_right);\n+\n@@ -1199,10 +1186,11 @@\n-  tty->print_cr(\"%s=\" PTR_FORMAT \" dpc=\" SIZE_FORMAT_W(5) \" \"\n-                \"spl=\" SIZE_FORMAT \" \"\n-                \"d2l=\" SIZE_FORMAT \" d2l%%=%6.4f \"\n-                \"d2r=\" SIZE_FORMAT \" l2r=\" SIZE_FORMAT\n-                \" ratio=%10.8f\",\n-                algorithm, p2i(addr), region_idx,\n-                space_live,\n-                dead_to_left, dead_to_left_pct,\n-                dead_to_right, live_to_right,\n-                double(dead_to_right) \/ live_to_right);\n+  log_develop_debug(gc, compaction)(\n+      \"%s=\" PTR_FORMAT \" dpc=\" SIZE_FORMAT_W(5) \" \"\n+      \"spl=\" SIZE_FORMAT \" \"\n+      \"d2l=\" SIZE_FORMAT \" d2l%%=%6.4f \"\n+      \"d2r=\" SIZE_FORMAT \" l2r=\" SIZE_FORMAT \" \"\n+      \"ratio=%10.8f\",\n+      algorithm, p2i(addr), region_idx,\n+      space_live,\n+      dead_to_left, dead_to_left_pct,\n+      dead_to_right, live_to_right,\n+      double(dead_to_right) \/ live_to_right);\n@@ -1416,10 +1404,10 @@\n-  if (TraceParallelOldGCDensePrefix) {\n-    tty->print_cr(\"space_live=\" SIZE_FORMAT \" \" \"space_used=\" SIZE_FORMAT \" \"\n-                  \"space_cap=\" SIZE_FORMAT,\n-                  space_live, space_used,\n-                  space_capacity);\n-    tty->print_cr(\"dead_wood_limiter(%6.4f, \" SIZE_FORMAT \")=%6.4f \"\n-                  \"dead_wood_max=\" SIZE_FORMAT \" dead_wood_limit=\" SIZE_FORMAT,\n-                  density, min_percent_free, limiter,\n-                  dead_wood_max, dead_wood_limit);\n-  }\n+  log_develop_debug(gc, compaction)(\n+      \"space_live=\" SIZE_FORMAT \" space_used=\" SIZE_FORMAT \" \"\n+      \"space_cap=\" SIZE_FORMAT,\n+      space_live, space_used,\n+      space_capacity);\n+  log_develop_debug(gc, compaction)(\n+      \"dead_wood_limiter(%6.4f, \" SIZE_FORMAT \")=%6.4f \"\n+      \"dead_wood_max=\" SIZE_FORMAT \" dead_wood_limit=\" SIZE_FORMAT,\n+      density, min_percent_free, limiter,\n+      dead_wood_max, dead_wood_limit);\n@@ -1539,1 +1527,1 @@\n-    if (TraceParallelOldGCDensePrefix) {\n+    if (log_is_enabled(Debug, gc, compaction)) {\n@@ -1613,11 +1601,0 @@\n-#ifdef  ASSERT\n-  if (TraceParallelOldGCMarkingPhase) {\n-    tty->print_cr(\"add_obj_count=\" SIZE_FORMAT \" \"\n-                  \"add_obj_bytes=\" SIZE_FORMAT,\n-                  add_obj_count, add_obj_size * HeapWordSize);\n-    tty->print_cr(\"mark_bitmap_count=\" SIZE_FORMAT \" \"\n-                  \"mark_bitmap_bytes=\" SIZE_FORMAT,\n-                  mark_bitmap_count, mark_bitmap_size * HeapWordSize);\n-  }\n-#endif  \/\/ #ifdef ASSERT\n-\n@@ -1792,2 +1769,1 @@\n-  ParCompactionManager* const vmthread_cm =\n-    ParCompactionManager::manager_array(ParallelScavengeHeap::heap()->workers().total_workers());\n+  ParCompactionManager* const vmthread_cm = ParCompactionManager::get_vmthread_cm();\n@@ -1796,3 +1772,0 @@\n-    ResourceMark rm;\n-    HandleMark hm;\n-\n@@ -1843,1 +1816,1 @@\n-    adjust_roots(vmthread_cm);\n+    adjust_roots();\n@@ -1848,0 +1821,2 @@\n+    ParCompactionManager::verify_all_region_stack_empty();\n+\n@@ -1875,1 +1850,1 @@\n-        assert(young_gen->max_size() >\n+        assert(young_gen->max_gen_size() >\n@@ -1885,1 +1860,1 @@\n-        size_t max_eden_size = young_gen->max_size() -\n+        size_t max_eden_size = young_gen->max_gen_size() -\n@@ -1951,10 +1926,0 @@\n-#ifdef ASSERT\n-  for (size_t i = 0; i < ParallelGCThreads + 1; ++i) {\n-    ParCompactionManager* const cm =\n-      ParCompactionManager::manager_array(int(i));\n-    assert(cm->marking_stack()->is_empty(),       \"should be empty\");\n-    assert(cm->region_stack()->is_empty(), \"Region stack \" SIZE_FORMAT \" is not empty\", i);\n-  }\n-#endif \/\/ ASSERT\n-\n-    HandleMark hm;  \/\/ Discard invalid handles created during verification\n@@ -1986,4 +1951,0 @@\n-#ifdef TRACESPINNING\n-  ParallelTaskTerminator::print_termination_counts();\n-#endif\n-\n@@ -2000,89 +1961,0 @@\n-bool PSParallelCompact::absorb_live_data_from_eden(PSAdaptiveSizePolicy* size_policy,\n-                                             PSYoungGen* young_gen,\n-                                             PSOldGen* old_gen) {\n-  MutableSpace* const eden_space = young_gen->eden_space();\n-  assert(!eden_space->is_empty(), \"eden must be non-empty\");\n-  assert(young_gen->virtual_space()->alignment() ==\n-         old_gen->virtual_space()->alignment(), \"alignments do not match\");\n-\n-  \/\/ We also return false when it's a heterogeneous heap because old generation cannot absorb data from eden\n-  \/\/ when it is allocated on different memory (example, nv-dimm) than young.\n-  if (!(UseAdaptiveSizePolicy && UseAdaptiveGCBoundary) ||\n-      ParallelArguments::is_heterogeneous_heap()) {\n-    return false;\n-  }\n-\n-  \/\/ Both generations must be completely committed.\n-  if (young_gen->virtual_space()->uncommitted_size() != 0) {\n-    return false;\n-  }\n-  if (old_gen->virtual_space()->uncommitted_size() != 0) {\n-    return false;\n-  }\n-\n-  \/\/ Figure out how much to take from eden.  Include the average amount promoted\n-  \/\/ in the total; otherwise the next young gen GC will simply bail out to a\n-  \/\/ full GC.\n-  const size_t alignment = old_gen->virtual_space()->alignment();\n-  const size_t eden_used = eden_space->used_in_bytes();\n-  const size_t promoted = (size_t)size_policy->avg_promoted()->padded_average();\n-  const size_t absorb_size = align_up(eden_used + promoted, alignment);\n-  const size_t eden_capacity = eden_space->capacity_in_bytes();\n-\n-  if (absorb_size >= eden_capacity) {\n-    return false; \/\/ Must leave some space in eden.\n-  }\n-\n-  const size_t new_young_size = young_gen->capacity_in_bytes() - absorb_size;\n-  if (new_young_size < young_gen->min_gen_size()) {\n-    return false; \/\/ Respect young gen minimum size.\n-  }\n-\n-  log_trace(gc, ergo, heap)(\" absorbing \" SIZE_FORMAT \"K:  \"\n-                            \"eden \" SIZE_FORMAT \"K->\" SIZE_FORMAT \"K \"\n-                            \"from \" SIZE_FORMAT \"K, to \" SIZE_FORMAT \"K \"\n-                            \"young_gen \" SIZE_FORMAT \"K->\" SIZE_FORMAT \"K \",\n-                            absorb_size \/ K,\n-                            eden_capacity \/ K, (eden_capacity - absorb_size) \/ K,\n-                            young_gen->from_space()->used_in_bytes() \/ K,\n-                            young_gen->to_space()->used_in_bytes() \/ K,\n-                            young_gen->capacity_in_bytes() \/ K, new_young_size \/ K);\n-\n-  \/\/ Fill the unused part of the old gen.\n-  MutableSpace* const old_space = old_gen->object_space();\n-  HeapWord* const unused_start = old_space->top();\n-  size_t const unused_words = pointer_delta(old_space->end(), unused_start);\n-\n-  if (unused_words > 0) {\n-    if (unused_words < CollectedHeap::min_fill_size()) {\n-      return false;  \/\/ If the old gen cannot be filled, must give up.\n-    }\n-    CollectedHeap::fill_with_objects(unused_start, unused_words);\n-  }\n-\n-  \/\/ Take the live data from eden and set both top and end in the old gen to\n-  \/\/ eden top.  (Need to set end because reset_after_change() mangles the region\n-  \/\/ from end to virtual_space->high() in debug builds).\n-  HeapWord* const new_top = eden_space->top();\n-  old_gen->virtual_space()->expand_into(young_gen->virtual_space(),\n-                                        absorb_size);\n-  young_gen->reset_after_change();\n-  old_space->set_top(new_top);\n-  old_space->set_end(new_top);\n-  old_gen->reset_after_change();\n-\n-  \/\/ Update the object start array for the filler object and the data from eden.\n-  ObjectStartArray* const start_array = old_gen->start_array();\n-  for (HeapWord* p = unused_start; p < new_top; p += oop(p)->size()) {\n-    start_array->allocate_block(p);\n-  }\n-\n-  \/\/ Could update the promoted average here, but it is not typically updated at\n-  \/\/ full GCs and the value to use is unclear.  Something like\n-  \/\/\n-  \/\/ cur_promoted_avg + absorb_size \/ number_of_scavenges_since_last_full_gc.\n-\n-  size_policy->set_bytes_absorbed_from_eden(absorb_size);\n-  return true;\n-}\n-\n@@ -2120,24 +1992,0 @@\n-    case ParallelRootType::universe:\n-      Universe::oops_do(&mark_and_push_closure);\n-      break;\n-\n-    case ParallelRootType::jni_handles:\n-      JNIHandles::oops_do(&mark_and_push_closure);\n-      break;\n-\n-    case ParallelRootType::object_synchronizer:\n-      ObjectSynchronizer::oops_do(&mark_and_push_closure);\n-      break;\n-\n-    case ParallelRootType::management:\n-      Management::oops_do(&mark_and_push_closure);\n-      break;\n-\n-    case ParallelRootType::jvmti:\n-      JvmtiExport::oops_do(&mark_and_push_closure);\n-      break;\n-\n-    case ParallelRootType::system_dictionary:\n-      SystemDictionary::oops_do(&mark_and_push_closure);\n-      break;\n-\n@@ -2154,1 +2002,0 @@\n-      AOTLoader::oops_do(&mark_and_push_closure);\n@@ -2167,1 +2014,1 @@\n-static void steal_marking_work(ParallelTaskTerminator& terminator, uint worker_id) {\n+void steal_marking_work(TaskTerminator& terminator, uint worker_id) {\n@@ -2188,1 +2035,1 @@\n-  typedef AbstractRefProcTaskExecutor::ProcessTask ProcessTask;\n+  OopStorageSetStrongParState<false \/* concurrent *\/, false \/* is_const *\/> _oop_storage_set_par_state;\n@@ -2198,2 +2045,2 @@\n-      _subtasks(),\n-      _terminator(active_workers, ParCompactionManager::stack_array()),\n+      _subtasks(ParallelRootType::sentinel),\n+      _terminator(active_workers, ParCompactionManager::oop_task_queues()),\n@@ -2201,2 +2048,0 @@\n-    _subtasks.set_n_threads(active_workers);\n-    _subtasks.set_n_tasks(ParallelRootType::sentinel);\n@@ -2209,1 +2054,0 @@\n-    _subtasks.all_tasks_completed();\n@@ -2214,0 +2058,9 @@\n+    \/\/ Mark from OopStorages\n+    {\n+      ParCompactionManager* cm = ParCompactionManager::gc_thread_compaction_manager(worker_id);\n+      PCMarkAndPushClosure closure(cm);\n+      _oop_storage_set_par_state.oops_do(&closure);\n+      \/\/ Do the real work\n+      cm->follow_marking_stacks();\n+    }\n+\n@@ -2215,1 +2068,1 @@\n-      steal_marking_work(*_terminator.terminator(), worker_id);\n+      steal_marking_work(_terminator, worker_id);\n@@ -2220,4 +2073,1 @@\n-class PCRefProcTask : public AbstractGangTask {\n-  typedef AbstractRefProcTaskExecutor::ProcessTask ProcessTask;\n-  ProcessTask& _task;\n-  uint _ergo_workers;\n+class ParallelCompactRefProcProxyTask : public RefProcProxyTask {\n@@ -2227,17 +2077,3 @@\n-  PCRefProcTask(ProcessTask& task, uint ergo_workers) :\n-      AbstractGangTask(\"PCRefProcTask\"),\n-      _task(task),\n-      _ergo_workers(ergo_workers),\n-      _terminator(_ergo_workers, ParCompactionManager::stack_array()) {\n-  }\n-\n-  virtual void work(uint worker_id) {\n-    ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();\n-    assert(ParallelScavengeHeap::heap()->is_gc_active(), \"called outside gc\");\n-\n-    ParCompactionManager* cm =\n-      ParCompactionManager::gc_thread_compaction_manager(worker_id);\n-    PCMarkAndPushClosure mark_and_push_closure(cm);\n-    ParCompactionManager::FollowStackClosure follow_stack_closure(cm);\n-    _task.work(worker_id, *PSParallelCompact::is_alive_closure(),\n-               mark_and_push_closure, follow_stack_closure);\n+  ParallelCompactRefProcProxyTask(uint max_workers)\n+    : RefProcProxyTask(\"ParallelCompactRefProcProxyTask\", max_workers),\n+      _terminator(_max_workers, ParCompactionManager::oop_task_queues()) {}\n@@ -2245,1 +2081,6 @@\n-    steal_marking_work(*_terminator.terminator(), worker_id);\n+  void work(uint worker_id) override {\n+    assert(worker_id < _max_workers, \"sanity\");\n+    ParCompactionManager* cm = (_tm == RefProcThreadModel::Single) ? ParCompactionManager::get_vmthread_cm() : ParCompactionManager::gc_thread_compaction_manager(worker_id);\n+    PCMarkAndPushClosure keep_alive(cm);\n+    ParCompactionManager::FollowStackClosure complete_gc(cm, (_tm == RefProcThreadModel::Single) ? nullptr : &_terminator, worker_id);\n+    _rp_task->rp_work(worker_id, PSParallelCompact::is_alive_closure(), &keep_alive, &complete_gc);\n@@ -2247,9 +2088,2 @@\n-};\n-\n-class RefProcTaskExecutor: public AbstractRefProcTaskExecutor {\n-  void execute(ProcessTask& process_task, uint ergo_workers) {\n-    assert(ParallelScavengeHeap::heap()->workers().active_workers() == ergo_workers,\n-           \"Ergonomically chosen workers (%u) must be equal to active workers (%u)\",\n-           ergo_workers, ParallelScavengeHeap::heap()->workers().active_workers());\n-    PCRefProcTask task(process_task, ergo_workers);\n-    ParallelScavengeHeap::heap()->workers().run_task(&task);\n+  void prepare_run_task_hook() override {\n+    _terminator.reset_for_reuse(_queue_count);\n@@ -2266,1 +2100,0 @@\n-  ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();\n@@ -2269,3 +2102,0 @@\n-  PCMarkAndPushClosure mark_and_push_closure(cm);\n-  ParCompactionManager::FollowStackClosure follow_stack_closure(cm);\n-\n@@ -2289,12 +2119,3 @@\n-    if (ref_processor()->processing_is_mt()) {\n-      ref_processor()->set_active_mt_degree(active_gc_threads);\n-\n-      RefProcTaskExecutor task_executor;\n-      stats = ref_processor()->process_discovered_references(\n-        is_alive_closure(), &mark_and_push_closure, &follow_stack_closure,\n-        &task_executor, &pt);\n-    } else {\n-      stats = ref_processor()->process_discovered_references(\n-        is_alive_closure(), &mark_and_push_closure, &follow_stack_closure, NULL,\n-        &pt);\n-    }\n+    ref_processor()->set_active_mt_degree(active_gc_threads);\n+    ParallelCompactRefProcProxyTask task(ref_processor()->max_num_queues());\n+    stats = ref_processor()->process_discovered_references(task, pt);\n@@ -2307,1 +2128,1 @@\n-  assert(cm->marking_stacks_empty(), \"Marking should have completed\");\n+  ParCompactionManager::verify_all_marking_stack_empty();\n@@ -2311,1 +2132,4 @@\n-    WeakProcessor::weak_oops_do(is_alive_closure(), &do_nothing_cl);\n+    WeakProcessor::weak_oops_do(&ParallelScavengeHeap::heap()->workers(),\n+                                is_alive_closure(),\n+                                &do_nothing_cl,\n+                                1);\n@@ -2333,3 +2157,12 @@\n-void PSParallelCompact::adjust_roots(ParCompactionManager* cm) {\n-  \/\/ Adjust the pointers to reflect the new locations\n-  GCTraceTime(Info, gc, phases) tm(\"Adjust Roots\", &_gc_timer);\n+#ifdef ASSERT\n+void PCAdjustPointerClosure::verify_cm(ParCompactionManager* cm) {\n+  assert(cm != NULL, \"associate ParCompactionManage should not be NULL\");\n+  auto vmthread_cm = ParCompactionManager::get_vmthread_cm();\n+  if (Thread::current()->is_VM_thread()) {\n+    assert(cm == vmthread_cm, \"VM threads should use ParCompactionManager from get_vmthread_cm()\");\n+  } else {\n+    assert(Thread::current()->is_GC_task_thread(), \"Must be a GC thread\");\n+    assert(cm != vmthread_cm, \"GC threads should use ParCompactionManager from gc_thread_compaction_manager()\");\n+  }\n+}\n+#endif\n@@ -2337,2 +2170,5 @@\n-  \/\/ Need new claim bits when tracing through and adjusting pointers.\n-  ClassLoaderDataGraph::clear_claimed_marks();\n+class PSAdjustTask final : public AbstractGangTask {\n+  SubTasksDone                               _sub_tasks;\n+  WeakProcessor::Task                        _weak_proc_task;\n+  OopStorageSetStrongParState<false, false>  _oop_storage_iter;\n+  uint                                       _nworkers;\n@@ -2340,1 +2176,4 @@\n-  PCAdjustPointerClosure oop_closure(cm);\n+  enum PSAdjustSubTask {\n+    PSAdjustSubTask_code_cache,\n+    PSAdjustSubTask_old_ref_process,\n+    PSAdjustSubTask_young_ref_process,\n@@ -2342,10 +2181,2 @@\n-  \/\/ General strong roots.\n-  Universe::oops_do(&oop_closure);\n-  JNIHandles::oops_do(&oop_closure);   \/\/ Global (strong) JNI handles\n-  Threads::oops_do(&oop_closure, NULL);\n-  ObjectSynchronizer::oops_do(&oop_closure);\n-  Management::oops_do(&oop_closure);\n-  JvmtiExport::oops_do(&oop_closure);\n-  SystemDictionary::oops_do(&oop_closure);\n-  CLDToOopClosure cld_closure(&oop_closure, ClassLoaderData::_claim_strong);\n-  ClassLoaderDataGraph::cld_do(&cld_closure);\n+    PSAdjustSubTask_num_elements\n+  };\n@@ -2353,3 +2184,12 @@\n-  \/\/ Now adjust pointers in remaining weak roots.  (All of which should\n-  \/\/ have been cleared if they pointed to non-surviving objects.)\n-  WeakProcessor::oops_do(&oop_closure);\n+public:\n+  PSAdjustTask(uint nworkers) :\n+    AbstractGangTask(\"PSAdjust task\"),\n+    _sub_tasks(PSAdjustSubTask_num_elements),\n+    _weak_proc_task(nworkers),\n+    _nworkers(nworkers) {\n+    \/\/ Need new claim bits when tracing through and adjusting pointers.\n+    ClassLoaderDataGraph::clear_claimed_marks();\n+    if (nworkers > 1) {\n+      Threads::change_thread_claim_token();\n+    }\n+  }\n@@ -2357,3 +2197,37 @@\n-  CodeBlobToOopClosure adjust_from_blobs(&oop_closure, CodeBlobToOopClosure::FixRelocations);\n-  CodeCache::blobs_do(&adjust_from_blobs);\n-  AOT_ONLY(AOTLoader::oops_do(&oop_closure);)\n+  ~PSAdjustTask() {\n+    Threads::assert_all_threads_claimed();\n+  }\n+\n+  void work(uint worker_id) {\n+    ParCompactionManager* cm = ParCompactionManager::gc_thread_compaction_manager(worker_id);\n+    PCAdjustPointerClosure adjust(cm);\n+    {\n+      ResourceMark rm;\n+      Threads::possibly_parallel_oops_do(_nworkers > 1, &adjust, nullptr);\n+    }\n+    _oop_storage_iter.oops_do(&adjust);\n+    {\n+      CLDToOopClosure cld_closure(&adjust, ClassLoaderData::_claim_strong);\n+      ClassLoaderDataGraph::cld_do(&cld_closure);\n+    }\n+    {\n+      AlwaysTrueClosure always_alive;\n+      _weak_proc_task.work(worker_id, &always_alive, &adjust);\n+    }\n+    if (_sub_tasks.try_claim_task(PSAdjustSubTask_code_cache)) {\n+      CodeBlobToOopClosure adjust_code(&adjust, CodeBlobToOopClosure::FixRelocations);\n+      CodeCache::blobs_do(&adjust_code);\n+    }\n+    if (_sub_tasks.try_claim_task(PSAdjustSubTask_old_ref_process)) {\n+      PSParallelCompact::ref_processor()->weak_oops_do(&adjust);\n+    }\n+    if (_sub_tasks.try_claim_task(PSAdjustSubTask_young_ref_process)) {\n+      \/\/ Roots were visited so references into the young gen in roots\n+      \/\/ may have been scanned.  Process them also.\n+      \/\/ Should the reference processor have a span that excludes\n+      \/\/ young gen objects?\n+      PSScavenge::reference_processor()->weak_oops_do(&adjust);\n+    }\n+    _sub_tasks.all_tasks_claimed();\n+  }\n+};\n@@ -2361,6 +2235,6 @@\n-  ref_processor()->weak_oops_do(&oop_closure);\n-  \/\/ Roots were visited so references into the young gen in roots\n-  \/\/ may have been scanned.  Process them also.\n-  \/\/ Should the reference processor have a span that excludes\n-  \/\/ young gen objects?\n-  PSScavenge::reference_processor()->weak_oops_do(&oop_closure);\n+void PSParallelCompact::adjust_roots() {\n+  \/\/ Adjust the pointers to reflect the new locations\n+  GCTraceTime(Info, gc, phases) tm(\"Adjust Roots\", &_gc_timer);\n+  uint nworkers = ParallelScavengeHeap::heap()->workers().active_workers();\n+  PSAdjustTask task(nworkers);\n+  ParallelScavengeHeap::heap()->workers().run_task(&task);\n@@ -2435,1 +2309,1 @@\n-        ParCompactionManager* cm = ParCompactionManager::manager_array(worker_id);\n+        ParCompactionManager* cm = ParCompactionManager::gc_thread_compaction_manager(worker_id);\n@@ -2470,1 +2344,1 @@\n-    uint claimed = Atomic::add(&_counter, 1u) - 1; \/\/ -1 is so that we start with zero\n+    uint claimed = Atomic::fetch_and_add(&_counter, 1u);\n@@ -2604,1 +2478,1 @@\n-static void compaction_with_stealing_work(ParallelTaskTerminator* terminator, uint worker_id) {\n+static void compaction_with_stealing_work(TaskTerminator* terminator, uint worker_id) {\n@@ -2634,1 +2508,0 @@\n-  return;\n@@ -2638,1 +2511,0 @@\n-  typedef AbstractRefProcTaskExecutor::ProcessTask ProcessTask;\n@@ -2647,1 +2519,1 @@\n-      _terminator(active_workers, ParCompactionManager::region_array()),\n+      _terminator(active_workers, ParCompactionManager::region_task_queues()),\n@@ -2662,1 +2534,1 @@\n-    compaction_with_stealing_work(_terminator.terminator(), worker_id);\n+    compaction_with_stealing_work(&_terminator, worker_id);\n@@ -2700,2 +2572,4 @@\n-    \/\/ Update the deferred objects, if any.  Any compaction manager can be used.\n-    ParCompactionManager* cm = ParCompactionManager::manager_array(0);\n+    \/\/ Update the deferred objects, if any. In principle, any compaction\n+    \/\/ manager can be used. However, since the current thread is VM thread, we\n+    \/\/ use the rightful one to keep the verification logic happy.\n+    ParCompactionManager* cm = ParCompactionManager::get_vmthread_cm();\n@@ -2753,1 +2627,1 @@\n-  compaction_manager()->update_contents(oop(addr));\n+  compaction_manager()->update_contents(cast_to_oop(addr));\n@@ -2856,2 +2730,2 @@\n-      cm->update_contents(oop(addr));\n-      assert(oopDesc::is_oop_or_null(oop(addr)), \"Expected an oop or NULL at \" PTR_FORMAT, p2i(oop(addr)));\n+      cm->update_contents(cast_to_oop(addr));\n+      assert(oopDesc::is_oop_or_null(cast_to_oop(addr)), \"Expected an oop or NULL at \" PTR_FORMAT, p2i(cast_to_oop(addr)));\n@@ -3262,1 +3136,1 @@\n-    ParCompactionManager *cm = ParCompactionManager::manager_array(i);\n+    ParCompactionManager *cm = ParCompactionManager::gc_thread_compaction_manager(i);\n@@ -3318,19 +3192,0 @@\n-jlong PSParallelCompact::millis_since_last_gc() {\n-  \/\/ We need a monotonically non-decreasing time in ms but\n-  \/\/ os::javaTimeMillis() does not guarantee monotonicity.\n-  jlong now = os::javaTimeNanos() \/ NANOSECS_PER_MILLISEC;\n-  jlong ret_val = now - _time_of_last_gc;\n-  \/\/ XXX See note in genCollectedHeap::millis_since_last_gc().\n-  if (ret_val < 0) {\n-    NOT_PRODUCT(log_warning(gc)(\"time warp: \" JLONG_FORMAT, ret_val);)\n-    return 0;\n-  }\n-  return ret_val;\n-}\n-\n-void PSParallelCompact::reset_millis_since_last_gc() {\n-  \/\/ We need a monotonically non-decreasing time in ms but\n-  \/\/ os::javaTimeMillis() does not guarantee monotonicity.\n-  _time_of_last_gc = os::javaTimeNanos() \/ NANOSECS_PER_MILLISEC;\n-}\n-\n@@ -3396,1 +3251,1 @@\n-  oop moved_oop = (oop) copy_destination();\n+  oop moved_oop = cast_to_oop(copy_destination());\n@@ -3401,1 +3256,1 @@\n-  assert(copy_destination() == (HeapWord*)moved_oop + moved_oop->size(), \"sanity\");\n+  assert(copy_destination() == cast_from_oop<HeapWord*>(moved_oop) + moved_oop->size(), \"sanity\");\n@@ -3454,1 +3309,1 @@\n-    addr += oop(addr)->size();\n+    addr += cast_to_oop(addr)->size();\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":199,"deletions":344,"binary":false,"changes":543,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2019, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Azul Systems, Inc. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"gc\/serial\/serialGcRefProcProxyTask.hpp\"\n@@ -41,1 +42,1 @@\n-#include \"gc\/shared\/genOopClosures.inline.hpp\"\n+#include \"gc\/shared\/genOopClosures.inline.hpp\"\n@@ -73,1 +74,1 @@\n-  return (HeapWord*)p >= _young_gen->reserved().end() || p->is_forwarded();\n+  return cast_from_oop<HeapWord*>(p) >= _young_gen->reserved().end() || p->is_forwarded();\n@@ -96,2 +97,2 @@\n-                             FastScanClosure* cur,\n-                             FastScanClosure* older) :\n+                             DefNewScanClosure* cur,\n+                             DefNewYoungerGenClosure* older) :\n@@ -109,12 +110,0 @@\n-ScanClosure::ScanClosure(DefNewGeneration* g, bool gc_barrier) :\n-    OopsInClassLoaderDataOrGenClosure(g), _g(g), _gc_barrier(gc_barrier)\n-{\n-  _boundary = _g->reserved().end();\n-}\n-\n-FastScanClosure::FastScanClosure(DefNewGeneration* g, bool gc_barrier) :\n-    OopsInClassLoaderDataOrGenClosure(g), _g(g), _gc_barrier(gc_barrier)\n-{\n-  _boundary = _g->reserved().end();\n-}\n-\n@@ -131,3 +120,0 @@\n-    if (_accumulate_modified_oops) {\n-      cld->accumulate_modified_oops();\n-    }\n@@ -172,4 +158,0 @@\n-  if (_eden_space == NULL || _from_space == NULL || _to_space == NULL) {\n-    vm_exit_during_initialization(\"Could not allocate a new gen space\");\n-  }\n-\n@@ -444,4 +426,0 @@\n-void DefNewGeneration::younger_refs_iterate(OopsInGenClosure* cl, uint n_threads) {\n-  assert(false, \"NYI -- are you sure you want to call this?\");\n-}\n-\n@@ -589,2 +567,0 @@\n-  heap->rem_set()->prepare_for_younger_refs_iterate(false);\n-\n@@ -594,2 +570,2 @@\n-  FastScanClosure fsc_with_no_gc_barrier(this, false);\n-  FastScanClosure fsc_with_gc_barrier(this, true);\n+  DefNewScanClosure       scan_closure(this);\n+  DefNewYoungerGenClosure younger_gen_closure(this, _old_gen);\n@@ -597,2 +573,1 @@\n-  CLDScanClosure cld_scan_closure(&fsc_with_no_gc_barrier,\n-                                  heap->rem_set()->cld_rem_set()->accumulate_modified_oops());\n+  CLDScanClosure cld_scan_closure(&scan_closure);\n@@ -600,1 +575,1 @@\n-  set_promo_failure_scan_stack_closure(&fsc_with_no_gc_barrier);\n+  set_promo_failure_scan_stack_closure(&scan_closure);\n@@ -602,2 +577,2 @@\n-                                                  &fsc_with_no_gc_barrier,\n-                                                  &fsc_with_gc_barrier);\n+                                                  &scan_closure,\n+                                                  &younger_gen_closure);\n@@ -609,3 +584,0 @@\n-    \/\/ DefNew needs to run with n_threads == 0, to make sure the serial\n-    \/\/ version of the card table scanning code is used.\n-    \/\/ See: CardTableRS::non_clean_card_iterate_possibly_parallel.\n@@ -614,3 +586,2 @@\n-    heap->young_process_roots(&srs,\n-                              &fsc_with_no_gc_barrier,\n-                              &fsc_with_gc_barrier,\n+    heap->young_process_roots(&scan_closure,\n+                              &younger_gen_closure,\n@@ -627,3 +598,2 @@\n-  const ReferenceProcessorStats& stats =\n-  rp->process_discovered_references(&is_alive, &keep_alive, &evacuate_followers,\n-                                    NULL, &pt);\n+  SerialGCRefProcProxyTask task(is_alive, keep_alive, evacuate_followers);\n+  const ReferenceProcessorStats& stats = rp->process_discovered_references(task, pt);\n@@ -690,9 +660,0 @@\n-  \/\/ set new iteration safe limit for the survivor spaces\n-  from()->set_concurrent_iteration_safe_limit(from()->top());\n-  to()->set_concurrent_iteration_safe_limit(to()->top());\n-\n-  \/\/ We need to use a monotonically non-decreasing time in ms\n-  \/\/ or we will see time-warp warnings and os::javaTimeMillis()\n-  \/\/ does not guarantee monotonicity.\n-  jlong now = os::javaTimeNanos() \/ NANOSECS_PER_MILLISEC;\n-  update_time_of_last_gc(now);\n@@ -721,2 +682,1 @@\n-  SharedRestorePreservedMarksTaskExecutor task_executor(NULL);\n-  _preserved_marks_set.restore(&task_executor);\n+  _preserved_marks_set.restore(NULL);\n@@ -730,1 +690,1 @@\n-  _preserved_marks_set.get()->push_if_necessary(old, old->mark_raw());\n+  _preserved_marks_set.get()->push_if_necessary(old, old->mark());\n@@ -752,1 +712,1 @@\n-    obj = (oop) to()->allocate_aligned(s);\n+    obj = cast_to_oop(to()->allocate(s));\n@@ -768,1 +728,1 @@\n-    Copy::aligned_disjoint_words((HeapWord*)old, (HeapWord*)obj, s);\n+    Copy::aligned_disjoint_words(cast_from_oop<HeapWord*>(old), cast_from_oop<HeapWord*>(obj), s);\n@@ -905,4 +865,0 @@\n-  if (!CleanChunkPoolAsync) {\n-    Chunk::clean_chunk_pool();\n-  }\n-\n@@ -968,5 +924,1 @@\n-  if (result != NULL) {\n-    if (_old_gen != NULL) {\n-      _old_gen->sample_eden_chunk();\n-    }\n-  } else {\n+  if (result == NULL) {\n@@ -984,5 +936,1 @@\n-  HeapWord* res = eden()->par_allocate(word_size);\n-  if (_old_gen != NULL) {\n-    _old_gen->sample_eden_chunk();\n-  }\n-  return res;\n+  return eden()->par_allocate(word_size);\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":23,"deletions":75,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2014, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2019, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Azul Systems, Inc. All rights reserved.\n@@ -57,3 +57,0 @@\n-  if (_bts == NULL) {\n-    vm_exit_during_initialization(\"Could not allocate a BlockOffsetArray\");\n-  }\n@@ -317,4 +314,9 @@\n-void CardGeneration::younger_refs_iterate(OopsInGenClosure* blk, uint n_threads) {\n-  blk->set_generation(this);\n-  younger_refs_in_space_iterate(space(), blk, n_threads);\n-  blk->reset_generation();\n+void CardGeneration::younger_refs_iterate(OopIterateClosure* blk) {\n+  \/\/ Apply \"cl->do_oop\" to (the address of) (exactly) all the ref fields in\n+  \/\/ \"sp\" that point into the young generation.\n+  \/\/ The iteration is only over objects allocated at the start of the\n+  \/\/ iterations; objects allocated as a result of applying the closure are\n+  \/\/ not included.\n+\n+  HeapWord* gen_boundary = reserved().start();\n+  _rs->younger_refs_in_space_iterate(space(), gen_boundary, blk);\n","filename":"src\/hotspot\/share\/gc\/shared\/cardGeneration.cpp","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,2 @@\n-#include \"classfile\/systemDictionary.hpp\"\n+#include \"classfile\/classLoaderData.hpp\"\n+#include \"classfile\/vmClasses.hpp\"\n@@ -33,0 +34,1 @@\n+#include \"gc\/shared\/stringdedup\/stringDedup.hpp\"\n@@ -37,0 +39,1 @@\n+#include \"gc\/shared\/gc_globals.hpp\"\n@@ -38,0 +41,1 @@\n+#include \"gc\/shared\/tlab_globals.hpp\"\n@@ -39,1 +43,3 @@\n-#include \"memory\/metaspace.hpp\"\n+#include \"logging\/logStream.hpp\"\n+#include \"memory\/classLoaderMetaspace.hpp\"\n+#include \"memory\/metaspaceUtils.hpp\"\n@@ -46,0 +52,1 @@\n+#include \"runtime\/perfData.hpp\"\n@@ -52,0 +59,1 @@\n+#include \"utilities\/events.hpp\"\n@@ -57,0 +65,5 @@\n+class GCMessage : public FormatBuffer<1024> {\n+ public:\n+  bool is_before;\n+};\n+\n@@ -63,0 +76,15 @@\n+class GCHeapLog : public EventLogBase<GCMessage> {\n+ private:\n+  void log_heap(CollectedHeap* heap, bool before);\n+\n+ public:\n+  GCHeapLog() : EventLogBase<GCMessage>(\"GC Heap History\", \"gc\") {}\n+\n+  void log_heap_before(CollectedHeap* heap) {\n+    log_heap(heap, true);\n+  }\n+  void log_heap_after(CollectedHeap* heap) {\n+    log_heap(heap, false);\n+  }\n+};\n+\n@@ -103,13 +131,0 @@\n-  const MetaspaceSizes meta_space(\n-      MetaspaceUtils::committed_bytes(),\n-      MetaspaceUtils::used_bytes(),\n-      MetaspaceUtils::reserved_bytes());\n-  const MetaspaceSizes data_space(\n-      MetaspaceUtils::committed_bytes(Metaspace::NonClassType),\n-      MetaspaceUtils::used_bytes(Metaspace::NonClassType),\n-      MetaspaceUtils::reserved_bytes(Metaspace::NonClassType));\n-  const MetaspaceSizes class_space(\n-      MetaspaceUtils::committed_bytes(Metaspace::ClassType),\n-      MetaspaceUtils::used_bytes(Metaspace::ClassType),\n-      MetaspaceUtils::reserved_bytes(Metaspace::ClassType));\n-\n@@ -120,2 +135,2 @@\n-\n-  return MetaspaceSummary(MetaspaceGC::capacity_until_GC(), meta_space, data_space, class_space,\n+  return MetaspaceSummary(MetaspaceGC::capacity_until_GC(),\n+                          MetaspaceUtils::get_combined_statistics(),\n@@ -126,1 +141,8 @@\n-  Universe::print_heap_before_gc();\n+  LogTarget(Debug, gc, heap) lt;\n+  if (lt.is_enabled()) {\n+    LogStream ls(lt);\n+    ls.print_cr(\"Heap before GC invocations=%u (full %u):\", total_collections(), total_full_collections());\n+    ResourceMark rm;\n+    print_on(&ls);\n+  }\n+\n@@ -133,1 +155,8 @@\n-  Universe::print_heap_after_gc();\n+  LogTarget(Debug, gc, heap) lt;\n+  if (lt.is_enabled()) {\n+    LogStream ls(lt);\n+    ls.print_cr(\"Heap after GC invocations=%u (full %u):\", total_collections(), total_full_collections());\n+    ResourceMark rm;\n+    print_on(&ls);\n+  }\n+\n@@ -146,1 +175,4 @@\n-  BarrierSet::barrier_set()->print_on(st);\n+  BarrierSet* bs = BarrierSet::barrier_set();\n+  if (bs != NULL) {\n+    bs->print_on(st);\n+  }\n@@ -165,8 +197,2 @@\n-\/\/ WhiteBox API support for concurrent collectors.  These are the\n-\/\/ default implementations, for collectors which don't support this\n-\/\/ feature.\n-bool CollectedHeap::supports_concurrent_phase_control() const {\n-  return false;\n-}\n-\n-bool CollectedHeap::request_concurrent_phase(const char* phase) {\n+\/\/ Default implementation, for collectors that don't support the feature.\n+bool CollectedHeap::supports_concurrent_gc_breakpoints() const {\n@@ -196,0 +222,2 @@\n+  _capacity_at_last_gc(0),\n+  _used_at_last_gc(0),\n@@ -198,0 +226,1 @@\n+  _last_whole_heap_examined_time_ns(os::javaTimeNanos()),\n@@ -236,1 +265,2 @@\n-  assert(Thread::current()->is_VM_thread(), \"Precondition#1\");\n+  Thread* thread = Thread::current();\n+  assert(thread->is_VM_thread(), \"Precondition#1\");\n@@ -243,1 +273,1 @@\n-      HandleMark hm;\n+      HandleMark hm(thread);\n@@ -247,0 +277,1 @@\n+    case GCCause::_archive_time_gc:\n@@ -248,1 +279,1 @@\n-      HandleMark hm;\n+      HandleMark hm(thread);\n@@ -335,0 +366,8 @@\n+void CollectedHeap::set_gc_cause(GCCause::Cause v) {\n+  if (UsePerfData) {\n+    _gc_lastcause = _gc_cause;\n+    _perf_gc_lastcause->set_value(GCCause::to_string(_gc_lastcause));\n+    _perf_gc_cause->set_value(GCCause::to_string(v));\n+  }\n+  _gc_cause = v;\n+}\n@@ -410,1 +449,1 @@\n-    ObjAllocator allocator(SystemDictionary::Object_klass(), words);\n+    ObjAllocator allocator(vmClasses::Object_klass(), words);\n@@ -418,1 +457,1 @@\n-  HandleMark hm;  \/\/ Free handles before leaving.\n+  HandleMark hm(Thread::current());  \/\/ Free handles before leaving.\n@@ -425,1 +464,1 @@\n-  HandleMark hm;  \/\/ Free handles before leaving.\n+  HandleMark hm(Thread::current());  \/\/ Free handles before leaving.\n@@ -493,0 +532,8 @@\n+jlong CollectedHeap::millis_since_last_whole_heap_examined() {\n+  return (os::javaTimeNanos() - _last_whole_heap_examined_time_ns) \/ NANOSECS_PER_MILLISEC;\n+}\n+\n+void CollectedHeap::record_whole_heap_examined_timestamp() {\n+  _last_whole_heap_examined_time_ns = os::javaTimeNanos();\n+}\n+\n@@ -527,0 +574,1 @@\n+  StringDedup::initialize();\n@@ -578,6 +626,2 @@\n-void CollectedHeap::deduplicate_string(oop str) {\n-  \/\/ Do nothing, unless overridden in subclass.\n-}\n-\n-size_t CollectedHeap::obj_size(oop obj) const {\n-  return obj->size();\n+bool CollectedHeap::is_archived_object(oop object) const {\n+  return false;\n@@ -590,0 +634,7 @@\n+\n+\/\/ It's the caller's responsibility to ensure glitch-freedom\n+\/\/ (if required).\n+void CollectedHeap::update_capacity_and_used_at_gc() {\n+  _capacity_at_last_gc = capacity();\n+  _used_at_last_gc     = used();\n+}\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.cpp","additions":92,"deletions":41,"binary":false,"changes":133,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,2 @@\n+#include \"memory\/metaspace.hpp\"\n+#include \"memory\/universe.hpp\"\n@@ -33,1 +35,1 @@\n-#include \"runtime\/perfData.hpp\"\n+#include \"runtime\/perfDataTypes.hpp\"\n@@ -37,1 +39,0 @@\n-#include \"utilities\/events.hpp\"\n@@ -46,0 +47,1 @@\n+class AbstractGangTask;\n@@ -48,0 +50,1 @@\n+class GCHeapLog;\n@@ -62,23 +65,4 @@\n-class GCMessage : public FormatBuffer<1024> {\n- public:\n-  bool is_before;\n-\n- public:\n-  GCMessage() {}\n-};\n-\n-class CollectedHeap;\n-\n-class GCHeapLog : public EventLogBase<GCMessage> {\n- private:\n-  void log_heap(CollectedHeap* heap, bool before);\n-\n- public:\n-  GCHeapLog() : EventLogBase<GCMessage>(\"GC Heap History\", \"gc\") {}\n-\n-  void log_heap_before(CollectedHeap* heap) {\n-    log_heap(heap, true);\n-  }\n-  void log_heap_after(CollectedHeap* heap) {\n-    log_heap(heap, false);\n-  }\n+class ParallelObjectIterator : public CHeapObj<mtGC> {\n+public:\n+  virtual void object_iterate(ObjectClosure* cl, uint worker_id) = 0;\n+  virtual ~ParallelObjectIterator() {}\n@@ -105,0 +89,4 @@\n+  \/\/ Historic gc information\n+  size_t _capacity_at_last_gc;\n+  size_t _used_at_last_gc;\n+\n@@ -116,0 +104,6 @@\n+  \/\/ Last time the whole heap has been examined in support of RMI\n+  \/\/ MaxObjectInspectionAge.\n+  \/\/ This timestamp must be monotonically non-decreasing to avoid\n+  \/\/ time-warp warnings.\n+  jlong _last_whole_heap_examined_time_ns;\n+\n@@ -182,0 +176,14 @@\n+ protected:\n+  \/\/ Get a pointer to the derived heap object.  Used to implement\n+  \/\/ derived class heap() functions rather than being called directly.\n+  template<typename T>\n+  static T* named_heap(Name kind) {\n+    CollectedHeap* heap = Universe::heap();\n+    assert(heap != NULL, \"Uninitialized heap\");\n+    assert(kind == heap->kind(), \"Heap kind %u should be %u\",\n+           static_cast<uint>(heap->kind()), static_cast<uint>(kind));\n+    return static_cast<T*>(heap);\n+  }\n+\n+ public:\n+\n@@ -216,0 +224,5 @@\n+  \/\/ Historic gc information\n+  size_t free_at_last_gc() const { return _capacity_at_last_gc - _used_at_last_gc; }\n+  size_t used_at_last_gc() const { return _used_at_last_gc; }\n+  void update_capacity_and_used_at_gc();\n+\n@@ -238,8 +251,1 @@\n-  void set_gc_cause(GCCause::Cause v) {\n-     if (UsePerfData) {\n-       _gc_lastcause = _gc_cause;\n-       _perf_gc_lastcause->set_value(GCCause::to_string(_gc_lastcause));\n-       _perf_gc_cause->set_value(GCCause::to_string(v));\n-     }\n-    _gc_cause = v;\n-  }\n+  void set_gc_cause(GCCause::Cause v);\n@@ -277,6 +283,0 @@\n-  \/\/ Return the address \"addr\" aligned by \"alignment_in_bytes\" if such\n-  \/\/ an address is below \"end\".  Return NULL otherwise.\n-  inline static HeapWord* align_allocation_or_fail(HeapWord* addr,\n-                                                   HeapWord* end,\n-                                                   unsigned short alignment_in_bytes);\n-\n@@ -321,7 +321,0 @@\n-  \/\/ Section on thread-local allocation buffers (TLABs)\n-  \/\/ If the heap supports thread-local allocation buffers, it should override\n-  \/\/ the following methods:\n-  \/\/ Returns \"true\" iff the heap supports thread-local allocation buffers.\n-  \/\/ The default is \"no\".\n-  virtual bool supports_tlab_allocation() const = 0;\n-\n@@ -344,0 +337,5 @@\n+  \/\/ If a GC uses a stack watermark barrier, the stack processing is lazy, concurrent,\n+  \/\/ incremental and cooperative. In order for that to work well, mechanisms that stop\n+  \/\/ another thread might want to ensure its roots are in a sane state.\n+  virtual bool uses_stack_watermark_barrier() const { return false; }\n+\n@@ -375,1 +373,0 @@\n-  \/\/ Should be protected but used by PSMarkSweep - cleanup for 1.4.2\n@@ -395,0 +392,4 @@\n+  virtual ParallelObjectIterator* parallel_object_iterator(uint thread_num) {\n+    return NULL;\n+  }\n+\n@@ -398,4 +399,0 @@\n-  \/\/ Returns the longest time (in ms) that has elapsed since the last\n-  \/\/ time that any part of the heap was examined by a garbage collection.\n-  virtual jlong millis_since_last_gc() = 0;\n-\n@@ -405,1 +402,7 @@\n-  \/\/ Generate any dumps preceding or following a full gc\n+  \/\/ Returns the longest time (in ms) that has elapsed since the last\n+  \/\/ time that the whole heap has been examined by a garbage collection.\n+  jlong millis_since_last_whole_heap_examined();\n+  \/\/ GC should call this when the next whole heap analysis has completed to\n+  \/\/ satisfy above requirement.\n+  void record_whole_heap_examined_timestamp();\n+\n@@ -407,0 +410,1 @@\n+  \/\/ Generate any dumps preceding or following a full gc\n@@ -438,7 +442,0 @@\n-  \/\/ Print all GC threads (other than the VM thread)\n-  \/\/ used by this heap.\n-  virtual void print_gc_threads_on(outputStream* st) const = 0;\n-  \/\/ The default behavior is to call print_gc_threads_on() on tty.\n-  void print_gc_threads() {\n-    print_gc_threads_on(tty);\n-  }\n@@ -468,18 +465,3 @@\n-  \/\/ Return true if concurrent phase control (via\n-  \/\/ request_concurrent_phase_control) is supported by this collector.\n-  \/\/ The default implementation returns false.\n-  virtual bool supports_concurrent_phase_control() const;\n-\n-  \/\/ Request the collector enter the indicated concurrent phase, and\n-  \/\/ wait until it does so.  Supports WhiteBox testing.  Only one\n-  \/\/ request may be active at a time.  Phases are designated by name;\n-  \/\/ the set of names and their meaning is GC-specific.  Once the\n-  \/\/ requested phase has been reached, the collector will attempt to\n-  \/\/ avoid transitioning to a new phase until a new request is made.\n-  \/\/ [Note: A collector might not be able to remain in a given phase.\n-  \/\/ For example, a full collection might cancel an in-progress\n-  \/\/ concurrent collection.]\n-  \/\/\n-  \/\/ Returns true when the phase is reached.  Returns false for an\n-  \/\/ unknown phase.  The default implementation returns false.\n-  virtual bool request_concurrent_phase(const char* phase);\n+  \/\/ Return true if concurrent gc control via WhiteBox is supported by\n+  \/\/ this collector.  The default implementation returns false.\n+  virtual bool supports_concurrent_gc_breakpoints() const;\n@@ -495,1 +477,1 @@\n-  virtual WorkGang* get_safepoint_workers() { return NULL; }\n+  virtual WorkGang* safepoint_workers() { return NULL; }\n@@ -504,2 +486,2 @@\n-  \/\/ Deduplicate the string, iff the GC supports string deduplication.\n-  virtual void deduplicate_string(oop str);\n+  \/\/ Is the given object inside a CDS archive area?\n+  virtual bool is_archived_object(oop object) const;\n@@ -508,3 +490,0 @@\n-\n-  virtual size_t obj_size(oop obj) const;\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":63,"deletions":84,"binary":false,"changes":147,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,2 @@\n+#include \"jvm_constants.h\"\n+#include \"jvm_io.h\"\n@@ -47,1 +49,1 @@\n- * Second, this file contains the functions and constant definitions\n+ * Second, (included from jvm_constants.h) constant definitions\n@@ -49,1 +51,1 @@\n- * These functions allow the verifier and format checker to be written\n+ * These definitions allow the verifier and format checker to be written\n@@ -53,1 +55,2 @@\n- * by the standard Java I\/O and network APIs.\n+ * by the standard Java I\/O and network APIs. A part of these APIs,\n+ * namely the jio_xxxprintf functions, are included from jvm_io.h.\n@@ -56,14 +59,0 @@\n-\/*\n- * Bump the version number when either of the following happens:\n- *\n- * 1. There is a change in JVM_* functions.\n- *\n- * 2. There is a change in the contract between VM and Java classes.\n- *    For example, if the VM relies on a new private field in Thread\n- *    class.\n- *\/\n-\n-#define JVM_INTERFACE_VERSION 6\n-\n-JNIEXPORT jint JNICALL\n-JVM_GetInterfaceVersion(void);\n@@ -161,0 +150,3 @@\n+JNIEXPORT jboolean JNICALL\n+JVM_IsUseContainerSupport(void);\n+\n@@ -179,0 +171,38 @@\n+JNIEXPORT void JNICALL\n+JVM_RegisterLambdaProxyClassForArchiving(JNIEnv* env, jclass caller,\n+                                         jstring interfaceMethodName,\n+                                         jobject factoryType,\n+                                         jobject interfaceMethodType,\n+                                         jobject implementationMember,\n+                                         jobject dynamicMethodType,\n+                                         jclass lambdaProxyClass);\n+\n+JNIEXPORT jclass JNICALL\n+JVM_LookupLambdaProxyClassFromArchive(JNIEnv* env, jclass caller,\n+                                      jstring interfaceMethodName,\n+                                      jobject factoryType,\n+                                      jobject interfaceMethodType,\n+                                      jobject implementationMember,\n+                                      jobject dynamicMethodType);\n+\n+JNIEXPORT jboolean JNICALL\n+JVM_IsCDSDumpingEnabled(JNIEnv* env);\n+\n+JNIEXPORT jboolean JNICALL\n+JVM_IsSharingEnabled(JNIEnv* env);\n+\n+JNIEXPORT jboolean JNICALL\n+JVM_IsDumpingClassList(JNIEnv* env);\n+\n+JNIEXPORT jlong JNICALL\n+JVM_GetRandomSeedForDumping();\n+\n+JNIEXPORT void JNICALL\n+JVM_LogLambdaFormInvoker(JNIEnv* env, jstring line);\n+\n+JNIEXPORT void JNICALL\n+JVM_DumpClassListToFile(JNIEnv* env, jstring fileName);\n+\n+JNIEXPORT void JNICALL\n+JVM_DumpDynamicArchive(JNIEnv* env, jstring archiveName);\n+\n@@ -297,0 +327,12 @@\n+JNIEXPORT jboolean JNICALL\n+JVM_ReferenceRefersTo(JNIEnv *env, jobject ref, jobject o);\n+\n+JNIEXPORT void JNICALL\n+JVM_ReferenceClear(JNIEnv *env, jobject ref);\n+\n+\/*\n+ * java.lang.ref.PhantomReference\n+ *\/\n+JNIEXPORT jboolean JNICALL\n+JVM_PhantomReferenceRefersTo(JNIEnv *env, jobject ref, jobject o);\n+\n@@ -391,0 +433,15 @@\n+\/*\n+ * Define a class with the specified lookup class.\n+ *  lookup:  Lookup class\n+ *  name:    the name of the class\n+ *  buf:     class bytes\n+ *  len:     length of class bytes\n+ *  pd:      protection domain\n+ *  init:    initialize the class\n+ *  flags:   properties of the class\n+ *  classData: private static pre-initialized field; may be null\n+ *\/\n+JNIEXPORT jclass JNICALL\n+JVM_LookupDefineClass(JNIEnv *env, jclass lookup, const char *name, const jbyte *buf,\n+                      jsize len, jobject pd, jboolean init, int flags, jobject classData);\n+\n@@ -402,2 +459,1 @@\n- *  packages:     list of packages in the module\n- *  num_packages: number of packages in the module\n+ *  packages:     array of packages in the module\n@@ -407,1 +463,1 @@\n-                 jstring location, const char* const* packages, jsize num_packages);\n+                 jstring location, jobjectArray packages);\n@@ -423,1 +479,1 @@\n-JVM_AddModuleExports(JNIEnv *env, jobject from_module, const char* package, jobject to_module);\n+JVM_AddModuleExports(JNIEnv *env, jobject from_module, jstring package, jobject to_module);\n@@ -431,1 +487,1 @@\n-JVM_AddModuleExportsToAllUnnamed(JNIEnv *env, jobject from_module, const char* package);\n+JVM_AddModuleExportsToAllUnnamed(JNIEnv *env, jobject from_module, jstring package);\n@@ -439,1 +495,1 @@\n-JVM_AddModuleExportsToAll(JNIEnv *env, jobject from_module, const char* package);\n+JVM_AddModuleExportsToAll(JNIEnv *env, jobject from_module, jstring package);\n@@ -449,0 +505,8 @@\n+\/*\n+ * Define all modules that have been stored in the CDS archived heap.\n+ *  platform_loader: the built-in platform class loader\n+ *  system_loader:   the built-in system class loader\n+ *\/\n+JNIEXPORT void JNICALL\n+JVM_DefineArchivedModules(JNIEnv *env, jobject platform_loader, jobject system_loader);\n+\n@@ -477,0 +541,3 @@\n+JNIEXPORT jboolean JNICALL\n+JVM_IsHiddenClass(JNIEnv *env, jclass cls);\n+\n@@ -542,1 +609,1 @@\n-\/* Records - since JDK 14 *\/\n+\/* Records - since JDK 16 *\/\n@@ -550,0 +617,5 @@\n+\/* Sealed classes - since JDK 17 *\/\n+\n+JNIEXPORT jobjectArray JNICALL\n+JVM_GetPermittedSubclasses(JNIEnv *env, jclass current);\n+\n@@ -684,74 +756,0 @@\n-\/*\n- * com.sun.dtrace.jsdt support\n- *\/\n-\n-#define JVM_TRACING_DTRACE_VERSION 1\n-\n-\/*\n- * Structure to pass one probe description to JVM\n- *\/\n-typedef struct {\n-    jmethodID method;\n-    jstring   function;\n-    jstring   name;\n-    void*            reserved[4];     \/\/ for future use\n-} JVM_DTraceProbe;\n-\n-\/**\n- * Encapsulates the stability ratings for a DTrace provider field\n- *\/\n-typedef struct {\n-    jint nameStability;\n-    jint dataStability;\n-    jint dependencyClass;\n-} JVM_DTraceInterfaceAttributes;\n-\n-\/*\n- * Structure to pass one provider description to JVM\n- *\/\n-typedef struct {\n-    jstring                       name;\n-    JVM_DTraceProbe*              probes;\n-    jint                          probe_count;\n-    JVM_DTraceInterfaceAttributes providerAttributes;\n-    JVM_DTraceInterfaceAttributes moduleAttributes;\n-    JVM_DTraceInterfaceAttributes functionAttributes;\n-    JVM_DTraceInterfaceAttributes nameAttributes;\n-    JVM_DTraceInterfaceAttributes argsAttributes;\n-    void*                         reserved[4]; \/\/ for future use\n-} JVM_DTraceProvider;\n-\n-\/*\n- * Get the version number the JVM was built with\n- *\/\n-JNIEXPORT jint JNICALL\n-JVM_DTraceGetVersion(JNIEnv* env);\n-\n-\/*\n- * Register new probe with given signature, return global handle\n- *\n- * The version passed in is the version that the library code was\n- * built with.\n- *\/\n-JNIEXPORT jlong JNICALL\n-JVM_DTraceActivate(JNIEnv* env, jint version, jstring module_name,\n-  jint providers_count, JVM_DTraceProvider* providers);\n-\n-\/*\n- * Check JSDT probe\n- *\/\n-JNIEXPORT jboolean JNICALL\n-JVM_DTraceIsProbeEnabled(JNIEnv* env, jmethodID method);\n-\n-\/*\n- * Destroy custom DOF\n- *\/\n-JNIEXPORT void JNICALL\n-JVM_DTraceDispose(JNIEnv* env, jlong activation_handle);\n-\n-\/*\n- * Check to see if DTrace is supported by OS\n- *\/\n-JNIEXPORT jboolean JNICALL\n-JVM_DTraceIsSupported(JNIEnv* env);\n-\n@@ -1048,58 +1046,0 @@\n-\/* Get classfile constants *\/\n-#include \"classfile_constants.h\"\n-\n-\/*\n- * Support for a VM-independent class format checker.\n- *\/\n-typedef struct {\n-    unsigned long code;    \/* byte code *\/\n-    unsigned long excs;    \/* exceptions *\/\n-    unsigned long etab;    \/* catch table *\/\n-    unsigned long lnum;    \/* line number *\/\n-    unsigned long lvar;    \/* local vars *\/\n-} method_size_info;\n-\n-typedef struct {\n-    unsigned int constants;    \/* constant pool *\/\n-    unsigned int fields;\n-    unsigned int methods;\n-    unsigned int interfaces;\n-    unsigned int fields2;      \/* number of static 2-word fields *\/\n-    unsigned int innerclasses; \/* # of records in InnerClasses attr *\/\n-\n-    method_size_info clinit;   \/* memory used in clinit *\/\n-    method_size_info main;     \/* used everywhere else *\/\n-} class_size_info;\n-\n-#define JVM_RECOGNIZED_CLASS_MODIFIERS (JVM_ACC_PUBLIC | \\\n-                                        JVM_ACC_FINAL | \\\n-                                        JVM_ACC_SUPER | \\\n-                                        JVM_ACC_INTERFACE | \\\n-                                        JVM_ACC_ABSTRACT | \\\n-                                        JVM_ACC_ANNOTATION | \\\n-                                        JVM_ACC_ENUM | \\\n-                                        JVM_ACC_SYNTHETIC)\n-\n-#define JVM_RECOGNIZED_FIELD_MODIFIERS (JVM_ACC_PUBLIC | \\\n-                                        JVM_ACC_PRIVATE | \\\n-                                        JVM_ACC_PROTECTED | \\\n-                                        JVM_ACC_STATIC | \\\n-                                        JVM_ACC_FINAL | \\\n-                                        JVM_ACC_VOLATILE | \\\n-                                        JVM_ACC_TRANSIENT | \\\n-                                        JVM_ACC_ENUM | \\\n-                                        JVM_ACC_SYNTHETIC)\n-\n-#define JVM_RECOGNIZED_METHOD_MODIFIERS (JVM_ACC_PUBLIC | \\\n-                                         JVM_ACC_PRIVATE | \\\n-                                         JVM_ACC_PROTECTED | \\\n-                                         JVM_ACC_STATIC | \\\n-                                         JVM_ACC_FINAL | \\\n-                                         JVM_ACC_SYNCHRONIZED | \\\n-                                         JVM_ACC_BRIDGE | \\\n-                                         JVM_ACC_VARARGS | \\\n-                                         JVM_ACC_NATIVE | \\\n-                                         JVM_ACC_ABSTRACT | \\\n-                                         JVM_ACC_STRICT | \\\n-                                         JVM_ACC_SYNTHETIC)\n-\n@@ -1119,27 +1059,0 @@\n-\/*\n- * The standard printing functions supported by the Java VM. (Should they\n- * be renamed to JVM_* in the future?\n- *\/\n-\n-\/* jio_snprintf() and jio_vsnprintf() behave like snprintf(3) and vsnprintf(3),\n- *  respectively, with the following differences:\n- * - The string written to str is always zero-terminated, also in case of\n- *   truncation (count is too small to hold the result string), unless count\n- *   is 0. In case of truncation count-1 characters are written and '\\0'\n- *   appendend.\n- * - If count is too small to hold the whole string, -1 is returned across\n- *   all platforms. *\/\n-\n-JNIEXPORT int\n-jio_vsnprintf(char *str, size_t count, const char *fmt, va_list args);\n-\n-JNIEXPORT int\n-jio_snprintf(char *str, size_t count, const char *fmt, ...);\n-\n-JNIEXPORT int\n-jio_fprintf(FILE *, const char *fmt, ...);\n-\n-JNIEXPORT int\n-jio_vfprintf(FILE *, const char *fmt, va_list args);\n-\n-\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":97,"deletions":184,"binary":false,"changes":281,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,5 @@\n+#include \"cds\/classListParser.hpp\"\n+#include \"cds\/classListWriter.hpp\"\n+#include \"cds\/dynamicArchive.hpp\"\n+#include \"cds\/heapShared.hpp\"\n+#include \"cds\/lambdaFormInvokers.hpp\"\n@@ -29,0 +34,1 @@\n+#include \"classfile\/classLoaderData.hpp\"\n@@ -30,0 +36,1 @@\n+#include \"classfile\/classLoadInfo.hpp\"\n@@ -38,0 +45,1 @@\n+#include \"classfile\/vmClasses.hpp\"\n@@ -44,1 +52,0 @@\n-#include \"memory\/heapShared.hpp\"\n@@ -53,0 +60,1 @@\n+#include \"oops\/klass.inline.hpp\"\n@@ -61,1 +69,0 @@\n-#include \"prims\/nativeLookup.hpp\"\n@@ -65,0 +72,1 @@\n+#include \"runtime\/globals_extension.hpp\"\n@@ -75,0 +83,1 @@\n+#include \"runtime\/osThread.hpp\"\n@@ -77,0 +86,1 @@\n+#include \"runtime\/synchronizer.hpp\"\n@@ -89,1 +99,0 @@\n-#include \"utilities\/histogram.hpp\"\n@@ -95,0 +104,3 @@\n+#if INCLUDE_JFR\n+#include \"jfr\/jfr.hpp\"\n+#endif\n@@ -106,2 +118,0 @@\n-          JVMWrapper(\"JVM_GetClassDeclaredFields\");\n-\n@@ -138,1 +148,1 @@\n-  JavaThread* jthread = JavaThread::current();\n+  JavaThread* jthread = THREAD;\n@@ -152,1 +162,1 @@\n-      if (!vfst.method()->method_holder()->is_subclass_of(SystemDictionary::ClassLoader_klass())&&\n+      if (!vfst.method()->method_holder()->is_subclass_of(vmClasses::ClassLoader_klass())&&\n@@ -221,50 +231,0 @@\n-\/\/ Wrapper to trace JVM functions\n-\n-#ifdef ASSERT\n-  Histogram* JVMHistogram;\n-  volatile int JVMHistogram_lock = 0;\n-\n-  class JVMHistogramElement : public HistogramElement {\n-    public:\n-     JVMHistogramElement(const char* name);\n-  };\n-\n-  JVMHistogramElement::JVMHistogramElement(const char* elementName) {\n-    _name = elementName;\n-    uintx count = 0;\n-\n-    while (Atomic::cmpxchg(&JVMHistogram_lock, 0, 1) != 0) {\n-      while (Atomic::load_acquire(&JVMHistogram_lock) != 0) {\n-        count +=1;\n-        if ( (WarnOnStalledSpinLock > 0)\n-          && (count % WarnOnStalledSpinLock == 0)) {\n-          warning(\"JVMHistogram_lock seems to be stalled\");\n-        }\n-      }\n-     }\n-\n-    if(JVMHistogram == NULL)\n-      JVMHistogram = new Histogram(\"JVM Call Counts\",100);\n-\n-    JVMHistogram->add_element(this);\n-    Atomic::dec(&JVMHistogram_lock);\n-  }\n-\n-  #define JVMCountWrapper(arg) \\\n-      static JVMHistogramElement* e = new JVMHistogramElement(arg); \\\n-      if (e != NULL) e->increment_count();  \/\/ Due to bug in VC++, we need a NULL check here eventhough it should never happen!\n-\n-  #define JVMWrapper(arg) JVMCountWrapper(arg);\n-#else\n-  #define JVMWrapper(arg)\n-#endif\n-\n-\n-\/\/ Interface version \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-\n-JVM_LEAF(jint, JVM_GetInterfaceVersion())\n-  return JVM_INTERFACE_VERSION;\n-JVM_END\n-\n-\n@@ -275,1 +235,0 @@\n-  JVMWrapper(\"JVM_CurrentTimeMillis\");\n@@ -280,1 +239,0 @@\n-  JVMWrapper(\"JVM_NanoTime\");\n@@ -292,1 +250,0 @@\n-  JVMWrapper(\"JVM_GetNanoTimeAdjustment\");\n@@ -329,1 +286,0 @@\n-  JVMWrapper(\"JVM_ArrayCopy\");\n@@ -351,1 +307,1 @@\n-                          SystemDictionary::Properties_klass(),\n+                          vmClasses::Properties_klass(),\n@@ -368,1 +324,0 @@\n-  JVMWrapper(\"JVM_GetProperties\");\n@@ -378,1 +333,1 @@\n-  InstanceKlass* ik = SystemDictionary::String_klass();\n+  InstanceKlass* ik = vmClasses::String_klass();\n@@ -420,1 +375,1 @@\n-#ifdef TIERED\n+#if COMPILER1_AND_COMPILER2\n@@ -428,1 +383,1 @@\n-    #error \"INCLUDE_JVMCI should imply TIERED\"\n+    #error \"INCLUDE_JVMCI should imply COMPILER1_OR_COMPILER2\"\n@@ -432,1 +387,1 @@\n-#endif \/\/ TIERED\n+#endif \/\/ COMPILER1_AND_COMPILER2\n@@ -444,1 +399,1 @@\n-  return (jobjectArray) JNIHandles::make_local(env, result_h());\n+  return (jobjectArray) JNIHandles::make_local(THREAD, result_h());\n@@ -457,1 +412,0 @@\n-  JVMWrapper(\"JVM_GetTemporaryDirectory\");\n@@ -461,1 +415,1 @@\n-  return (jstring) JNIHandles::make_local(env, h());\n+  return (jstring) JNIHandles::make_local(THREAD, h());\n@@ -470,1 +424,6 @@\n-  JVMWrapper(\"JVM_BeforeHalt\");\n+#if INCLUDE_CDS\n+  \/\/ Link all classes for dynamic CDS dumping before vm exit.\n+  if (DynamicDumpSharedSpaces) {\n+    DynamicArchive::prepare_for_dynamic_dumping_at_exit();\n+  }\n+#endif\n@@ -486,1 +445,2 @@\n-  JVMWrapper(\"JVM_GC\");\n+    EventSystemGC event;\n+    event.set_invokedConcurrent(ExplicitGCInvokesConcurrent);\n@@ -489,0 +449,1 @@\n+    event.commit();\n@@ -494,2 +455,1 @@\n-  JVMWrapper(\"JVM_MaxObjectInspectionAge\");\n-  return Universe::heap()->millis_since_last_gc();\n+  return Universe::heap()->millis_since_last_whole_heap_examined();\n@@ -506,1 +466,0 @@\n-  JVMWrapper(\"JVM_TotalMemory\");\n@@ -513,1 +472,0 @@\n-  JVMWrapper(\"JVM_FreeMemory\");\n@@ -520,1 +478,0 @@\n-  JVMWrapper(\"JVM_MaxMemory\");\n@@ -527,1 +484,0 @@\n-  JVMWrapper(\"JVM_ActiveProcessorCount\");\n@@ -531,1 +487,8 @@\n-\n+JVM_ENTRY_NO_ENV(jboolean, JVM_IsUseContainerSupport(void))\n+#ifdef LINUX\n+  if (UseContainerSupport) {\n+    return JNI_TRUE;\n+  }\n+#endif\n+  return JNI_FALSE;\n+JVM_END\n@@ -536,1 +499,0 @@\n-  JVMWrapper(\"JVM_FillInStackTrace\");\n@@ -560,2 +522,2 @@\n-    oop result = java_lang_String::create_oop_from_str(ss.base(), CHECK_0);\n-    return (jstring) JNIHandles::make_local(env, result);\n+    oop result = java_lang_String::create_oop_from_str(ss.base(), CHECK_NULL);\n+    return (jstring) JNIHandles::make_local(THREAD, result);\n@@ -571,1 +533,0 @@\n-  JVMWrapper(\"JVM_InitStackTraceElementArray\");\n@@ -581,1 +542,0 @@\n-  JVMWrapper(\"JVM_InitStackTraceElement\");\n@@ -594,3 +554,1 @@\n-  JVMWrapper(\"JVM_CallStackWalk\");\n-  JavaThread* jt = (JavaThread*) THREAD;\n-  if (!jt->is_Java_thread() || !jt->has_last_Java_frame()) {\n+  if (!thread->has_last_Java_frame()) {\n@@ -615,1 +573,1 @@\n-  return JNIHandles::make_local(env, result);\n+  return JNIHandles::make_local(THREAD, result);\n@@ -622,3 +580,0 @@\n-  JVMWrapper(\"JVM_MoreStackWalk\");\n-  JavaThread* jt = (JavaThread*) THREAD;\n-\n@@ -645,1 +600,0 @@\n-  JVMWrapper(\"JVM_IHashCode\");\n@@ -652,1 +606,0 @@\n-  JVMWrapper(\"JVM_MonitorWait\");\n@@ -656,1 +609,1 @@\n-    JvmtiExport::post_monitor_wait((JavaThread *)THREAD, (oop)obj(), ms);\n+    JvmtiExport::post_monitor_wait(thread, obj(), ms);\n@@ -669,1 +622,0 @@\n-  JVMWrapper(\"JVM_MonitorNotify\");\n@@ -676,1 +628,0 @@\n-  JVMWrapper(\"JVM_MonitorNotifyAll\");\n@@ -683,1 +634,0 @@\n-  JVMWrapper(\"JVM_Clone\");\n@@ -694,1 +644,1 @@\n-    bool cloneable = klass->is_subtype_of(SystemDictionary::Cloneable_klass());\n+    bool cloneable = klass->is_subtype_of(vmClasses::Cloneable_klass());\n@@ -731,1 +681,1 @@\n-  return JNIHandles::make_local(env, new_obj());\n+  return JNIHandles::make_local(THREAD, new_obj());\n@@ -737,1 +687,0 @@\n-  JVMWrapper(\"JVM_NativePath\");\n@@ -746,2 +695,0 @@\n-  JVMWrapper(\"JVM_GetCallerClass\");\n-\n@@ -777,1 +724,1 @@\n-        return (jclass) JNIHandles::make_local(env, m->method_holder()->java_mirror());\n+        return (jclass) JNIHandles::make_local(THREAD, m->method_holder()->java_mirror());\n@@ -787,1 +734,0 @@\n-  JVMWrapper(\"JVM_FindPrimitiveClass\");\n@@ -796,1 +742,1 @@\n-    return (jclass) JNIHandles::make_local(env, mirror);\n+    return (jclass) JNIHandles::make_local(THREAD, mirror);\n@@ -806,3 +752,1 @@\n-  JVMWrapper(\"JVM_FindClassFromBootLoader\");\n-\n-  \/\/ Java libraries should ensure that name is never null...\n+  \/\/ Java libraries should ensure that name is never null or illegal.\n@@ -814,0 +758,1 @@\n+  assert(UTF8::is_legal_utf8((const unsigned char*)name, (int)strlen(name), false), \"illegal UTF name\");\n@@ -824,1 +769,1 @@\n-  return (jclass) JNIHandles::make_local(env, k->java_mirror());\n+  return (jclass) JNIHandles::make_local(THREAD, k->java_mirror());\n@@ -831,9 +776,3 @@\n-  JVMWrapper(\"JVM_FindClassFromCaller throws ClassNotFoundException\");\n-  \/\/ Java libraries should ensure that name is never null...\n-  if (name == NULL || (int)strlen(name) > Symbol::max_length()) {\n-    \/\/ It's impossible to create this class;  the name cannot fit\n-    \/\/ into the constant pool.\n-    THROW_MSG_0(vmSymbols::java_lang_ClassNotFoundException(), name);\n-  }\n-\n-  TempNewSymbol h_name = SymbolTable::new_symbol(name);\n+  TempNewSymbol h_name =\n+       SystemDictionary::class_name_symbol(name, vmSymbols::java_lang_ClassNotFoundException(),\n+                                           CHECK_NULL);\n@@ -867,15 +806,3 @@\n-  JVMWrapper(\"JVM_FindClassFromClass\");\n-  if (name == NULL) {\n-    THROW_MSG_0(vmSymbols::java_lang_NoClassDefFoundError(), \"No class name given\");\n-  }\n-  if ((int)strlen(name) > Symbol::max_length()) {\n-    \/\/ It's impossible to create this class;  the name cannot fit\n-    \/\/ into the constant pool.\n-    Exceptions::fthrow(THREAD_AND_LOCATION,\n-                       vmSymbols::java_lang_NoClassDefFoundError(),\n-                       \"Class name exceeds maximum length of %d: %s\",\n-                       Symbol::max_length(),\n-                       name);\n-    return 0;\n-  }\n-  TempNewSymbol h_name = SymbolTable::new_symbol(name);\n+  TempNewSymbol h_name =\n+       SystemDictionary::class_name_symbol(name, vmSymbols::java_lang_ClassNotFoundException(),\n+                                           CHECK_NULL);\n@@ -913,14 +840,1 @@\n-static void is_lock_held_by_thread(Handle loader, PerfCounter* counter, TRAPS) {\n-  if (loader.is_null()) {\n-    return;\n-  }\n-\n-  \/\/ check whether the current caller thread holds the lock or not.\n-  \/\/ If not, increment the corresponding counter\n-  if (ObjectSynchronizer::query_lock_ownership((JavaThread*)THREAD, loader) !=\n-      ObjectSynchronizer::owner_self) {\n-    counter->inc();\n-  }\n-}\n-\n-static jclass jvm_define_class_common(JNIEnv *env, const char *name,\n+static jclass jvm_define_class_common(const char *name,\n@@ -933,2 +847,1 @@\n-  assert(THREAD->is_Java_thread(), \"must be a JavaThread\");\n-  JavaThread* jt = (JavaThread*) THREAD;\n+  JavaThread* jt = THREAD;\n@@ -947,17 +860,4 @@\n-  \/\/ Since exceptions can be thrown, class initialization can take place\n-  \/\/ if name is NULL no check for class name in .class stream has to be made.\n-  TempNewSymbol class_name = NULL;\n-  if (name != NULL) {\n-    const int str_len = (int)strlen(name);\n-    if (str_len > Symbol::max_length()) {\n-      \/\/ It's impossible to create this class;  the name cannot fit\n-      \/\/ into the constant pool.\n-      Exceptions::fthrow(THREAD_AND_LOCATION,\n-                         vmSymbols::java_lang_NoClassDefFoundError(),\n-                         \"Class name exceeds maximum length of %d: %s\",\n-                         Symbol::max_length(),\n-                         name);\n-      return 0;\n-    }\n-    class_name = SymbolTable::new_symbol(name, str_len);\n-  }\n+  \/\/ Class resolution will get the class name from the .class stream if the name is null.\n+  TempNewSymbol class_name = name == NULL ? NULL :\n+       SystemDictionary::class_name_symbol(name, vmSymbols::java_lang_NoClassDefFoundError(),\n+                                           CHECK_NULL);\n@@ -968,6 +868,2 @@\n-  if (UsePerfData) {\n-    is_lock_held_by_thread(class_loader,\n-                           ClassLoader::sync_JVMDefineClassLockFreeCounter(),\n-                           THREAD);\n-  }\n-  Klass* k = SystemDictionary::resolve_from_stream(class_name,\n+  ClassLoadInfo cl_info(protection_domain);\n+  Klass* k = SystemDictionary::resolve_from_stream(&st, class_name,\n@@ -976,2 +872,1 @@\n-                                                   protection_domain,\n-                                                   &st,\n+                                                   cl_info,\n@@ -980,1 +875,1 @@\n-  if (log_is_enabled(Debug, class, resolve) && k != NULL) {\n+  if (log_is_enabled(Debug, class, resolve)) {\n@@ -984,1 +879,1 @@\n-  return (jclass) JNIHandles::make_local(env, k->java_mirror());\n+  return (jclass) JNIHandles::make_local(THREAD, k->java_mirror());\n@@ -987,0 +882,6 @@\n+enum {\n+  NESTMATE              = java_lang_invoke_MemberName::MN_NESTMATE_CLASS,\n+  HIDDEN_CLASS          = java_lang_invoke_MemberName::MN_HIDDEN_CLASS,\n+  STRONG_LOADER_LINK    = java_lang_invoke_MemberName::MN_STRONG_LOADER_LINK,\n+  ACCESS_VM_ANNOTATIONS = java_lang_invoke_MemberName::MN_ACCESS_VM_ANNOTATIONS\n+};\n@@ -988,2 +889,15 @@\n-JVM_ENTRY(jclass, JVM_DefineClass(JNIEnv *env, const char *name, jobject loader, const jbyte *buf, jsize len, jobject pd))\n-  JVMWrapper(\"JVM_DefineClass\");\n+\/*\n+ * Define a class with the specified flags that indicates if it's a nestmate,\n+ * hidden, or strongly referenced from class loader.\n+ *\/\n+static jclass jvm_lookup_define_class(jclass lookup, const char *name,\n+                                      const jbyte *buf, jsize len, jobject pd,\n+                                      jboolean init, int flags, jobject classData, TRAPS) {\n+  ResourceMark rm(THREAD);\n+\n+  Klass* lookup_k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(lookup));\n+  \/\/ Lookup class must be a non-null instance\n+  if (lookup_k == NULL) {\n+    THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), \"Lookup class is null\");\n+  }\n+  assert(lookup_k->is_instance_klass(), \"Lookup class must be an instance klass\");\n@@ -991,1 +905,102 @@\n-  return jvm_define_class_common(env, name, loader, buf, len, pd, NULL, THREAD);\n+  Handle class_loader (THREAD, lookup_k->class_loader());\n+\n+  bool is_nestmate = (flags & NESTMATE) == NESTMATE;\n+  bool is_hidden = (flags & HIDDEN_CLASS) == HIDDEN_CLASS;\n+  bool is_strong = (flags & STRONG_LOADER_LINK) == STRONG_LOADER_LINK;\n+  bool vm_annotations = (flags & ACCESS_VM_ANNOTATIONS) == ACCESS_VM_ANNOTATIONS;\n+\n+  InstanceKlass* host_class = NULL;\n+  if (is_nestmate) {\n+    host_class = InstanceKlass::cast(lookup_k)->nest_host(CHECK_NULL);\n+  }\n+\n+  log_info(class, nestmates)(\"LookupDefineClass: %s - %s%s, %s, %s, %s\",\n+                             name,\n+                             is_nestmate ? \"with dynamic nest-host \" : \"non-nestmate\",\n+                             is_nestmate ? host_class->external_name() : \"\",\n+                             is_hidden ? \"hidden\" : \"not hidden\",\n+                             is_strong ? \"strong\" : \"weak\",\n+                             vm_annotations ? \"with vm annotations\" : \"without vm annotation\");\n+\n+  if (!is_hidden) {\n+    \/\/ classData is only applicable for hidden classes\n+    if (classData != NULL) {\n+      THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), \"classData is only applicable for hidden classes\");\n+    }\n+    if (is_nestmate) {\n+      THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), \"dynamic nestmate is only applicable for hidden classes\");\n+    }\n+    if (!is_strong) {\n+      THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), \"an ordinary class must be strongly referenced by its defining loader\");\n+    }\n+    if (vm_annotations) {\n+      THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), \"vm annotations only allowed for hidden classes\");\n+    }\n+    if (flags != STRONG_LOADER_LINK) {\n+      THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),\n+                  err_msg(\"invalid flag 0x%x\", flags));\n+    }\n+  }\n+\n+  \/\/ Class resolution will get the class name from the .class stream if the name is null.\n+  TempNewSymbol class_name = name == NULL ? NULL :\n+       SystemDictionary::class_name_symbol(name, vmSymbols::java_lang_NoClassDefFoundError(),\n+                                           CHECK_NULL);\n+\n+  Handle protection_domain (THREAD, JNIHandles::resolve(pd));\n+  const char* source = is_nestmate ? host_class->external_name() : \"__JVM_LookupDefineClass__\";\n+  ClassFileStream st((u1*)buf, len, source, ClassFileStream::verify);\n+\n+  InstanceKlass* ik = NULL;\n+  if (!is_hidden) {\n+    ClassLoadInfo cl_info(protection_domain);\n+    ik = SystemDictionary::resolve_from_stream(&st, class_name,\n+                                               class_loader,\n+                                               cl_info,\n+                                               CHECK_NULL);\n+\n+    if (log_is_enabled(Debug, class, resolve)) {\n+      trace_class_resolution(ik);\n+    }\n+  } else { \/\/ hidden\n+    Handle classData_h(THREAD, JNIHandles::resolve(classData));\n+    ClassLoadInfo cl_info(protection_domain,\n+                          host_class,\n+                          classData_h,\n+                          is_hidden,\n+                          is_strong,\n+                          vm_annotations);\n+    ik = SystemDictionary::resolve_from_stream(&st, class_name,\n+                                               class_loader,\n+                                               cl_info,\n+                                               CHECK_NULL);\n+\n+    \/\/ The hidden class loader data has been artificially been kept alive to\n+    \/\/ this point. The mirror and any instances of this class have to keep\n+    \/\/ it alive afterwards.\n+    ik->class_loader_data()->dec_keep_alive();\n+\n+    if (is_nestmate && log_is_enabled(Debug, class, nestmates)) {\n+      ModuleEntry* module = ik->module();\n+      const char * module_name = module->is_named() ? module->name()->as_C_string() : UNNAMED_MODULE;\n+      log_debug(class, nestmates)(\"Dynamic nestmate: %s\/%s, nest_host %s, %s\",\n+                                  module_name,\n+                                  ik->external_name(),\n+                                  host_class->external_name(),\n+                                  ik->is_hidden() ? \"is hidden\" : \"is not hidden\");\n+    }\n+  }\n+  assert(Reflection::is_same_class_package(lookup_k, ik),\n+         \"lookup class and defined class are in different packages\");\n+\n+  if (init) {\n+    ik->initialize(CHECK_NULL);\n+  } else {\n+    ik->link_class(CHECK_NULL);\n+  }\n+\n+  return (jclass) JNIHandles::make_local(THREAD, ik->java_mirror());\n+}\n+\n+JVM_ENTRY(jclass, JVM_DefineClass(JNIEnv *env, const char *name, jobject loader, const jbyte *buf, jsize len, jobject pd))\n+  return jvm_define_class_common(name, loader, buf, len, pd, NULL, THREAD);\n@@ -994,0 +1009,22 @@\n+\/*\n+ * Define a class with the specified lookup class.\n+ *  lookup:  Lookup class\n+ *  name:    the name of the class\n+ *  buf:     class bytes\n+ *  len:     length of class bytes\n+ *  pd:      protection domain\n+ *  init:    initialize the class\n+ *  flags:   properties of the class\n+ *  classData: private static pre-initialized field\n+ *\/\n+JVM_ENTRY(jclass, JVM_LookupDefineClass(JNIEnv *env, jclass lookup, const char *name, const jbyte *buf,\n+          jsize len, jobject pd, jboolean initialize, int flags, jobject classData))\n+\n+  if (lookup == NULL) {\n+    THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), \"Lookup class is null\");\n+  }\n+\n+  assert(buf != NULL, \"buf must not be NULL\");\n+\n+  return jvm_lookup_define_class(lookup, name, buf, len, pd, initialize, flags, classData, THREAD);\n+JVM_END\n@@ -996,2 +1033,1 @@\n-  JVMWrapper(\"JVM_DefineClassWithSource\");\n-  return jvm_define_class_common(env, name, loader, buf, len, pd, source, THREAD);\n+  return jvm_define_class_common(name, loader, buf, len, pd, source, THREAD);\n@@ -1002,1 +1038,0 @@\n-  JVMWrapper(\"JVM_FindLoadedClass\");\n@@ -1014,4 +1049,4 @@\n-      if (*p == '.') {\n-          *p = '\/';\n-      }\n-      p++;\n+    if (*p == '.') {\n+      *p = '\/';\n+    }\n+    p++;\n@@ -1032,6 +1067,0 @@\n-  if (UsePerfData) {\n-    is_lock_held_by_thread(h_loader,\n-                           ClassLoader::sync_JVMFindLoadedClassLockFreeCounter(),\n-                           THREAD);\n-  }\n-\n@@ -1040,2 +1069,1 @@\n-                                                              Handle(),\n-                                                              CHECK_NULL);\n+                                                              Handle());\n@@ -1050,1 +1078,1 @@\n-            (jclass) JNIHandles::make_local(env, k->java_mirror());\n+            (jclass) JNIHandles::make_local(THREAD, k->java_mirror());\n@@ -1056,3 +1084,3 @@\n-                                 jstring location, const char* const* packages, jsize num_packages))\n-  JVMWrapper(\"JVM_DefineModule\");\n-  Modules::define_module(module, is_open, version, location, packages, num_packages, CHECK);\n+                                 jstring location, jobjectArray packages))\n+  Handle h_module (THREAD, JNIHandles::resolve(module));\n+  Modules::define_module(h_module, is_open, version, location, packages, CHECK);\n@@ -1062,2 +1090,2 @@\n-  JVMWrapper(\"JVM_SetBootLoaderUnnamedModule\");\n-  Modules::set_bootloader_unnamed_module(module, CHECK);\n+  Handle h_module (THREAD, JNIHandles::resolve(module));\n+  Modules::set_bootloader_unnamed_module(h_module, CHECK);\n@@ -1066,3 +1094,4 @@\n-JVM_ENTRY(void, JVM_AddModuleExports(JNIEnv *env, jobject from_module, const char* package, jobject to_module))\n-  JVMWrapper(\"JVM_AddModuleExports\");\n-  Modules::add_module_exports_qualified(from_module, package, to_module, CHECK);\n+JVM_ENTRY(void, JVM_AddModuleExports(JNIEnv *env, jobject from_module, jstring package, jobject to_module))\n+  Handle h_from_module (THREAD, JNIHandles::resolve(from_module));\n+  Handle h_to_module (THREAD, JNIHandles::resolve(to_module));\n+  Modules::add_module_exports_qualified(h_from_module, package, h_to_module, CHECK);\n@@ -1071,3 +1100,3 @@\n-JVM_ENTRY(void, JVM_AddModuleExportsToAllUnnamed(JNIEnv *env, jobject from_module, const char* package))\n-  JVMWrapper(\"JVM_AddModuleExportsToAllUnnamed\");\n-  Modules::add_module_exports_to_all_unnamed(from_module, package, CHECK);\n+JVM_ENTRY(void, JVM_AddModuleExportsToAllUnnamed(JNIEnv *env, jobject from_module, jstring package))\n+  Handle h_from_module (THREAD, JNIHandles::resolve(from_module));\n+  Modules::add_module_exports_to_all_unnamed(h_from_module, package, CHECK);\n@@ -1076,3 +1105,3 @@\n-JVM_ENTRY(void, JVM_AddModuleExportsToAll(JNIEnv *env, jobject from_module, const char* package))\n-  JVMWrapper(\"JVM_AddModuleExportsToAll\");\n-  Modules::add_module_exports(from_module, package, NULL, CHECK);\n+JVM_ENTRY(void, JVM_AddModuleExportsToAll(JNIEnv *env, jobject from_module, jstring package))\n+  Handle h_from_module (THREAD, JNIHandles::resolve(from_module));\n+  Modules::add_module_exports(h_from_module, package, Handle(), CHECK);\n@@ -1082,2 +1111,9 @@\n-  JVMWrapper(\"JVM_AddReadsModule\");\n-  Modules::add_reads_module(from_module, source_module, CHECK);\n+  Handle h_from_module (THREAD, JNIHandles::resolve(from_module));\n+  Handle h_source_module (THREAD, JNIHandles::resolve(source_module));\n+  Modules::add_reads_module(h_from_module, h_source_module, CHECK);\n+JVM_END\n+\n+JVM_ENTRY(void, JVM_DefineArchivedModules(JNIEnv *env, jobject platform_loader, jobject system_loader))\n+  Handle h_platform_loader (THREAD, JNIHandles::resolve(platform_loader));\n+  Handle h_system_loader (THREAD, JNIHandles::resolve(system_loader));\n+  Modules::define_archived_modules(h_platform_loader, h_system_loader, CHECK);\n@@ -1090,1 +1126,0 @@\n-  JVMWrapper(\"JVM_InitClassName\");\n@@ -1096,1 +1131,1 @@\n-  return (jstring) JNIHandles::make_local(env, result);\n+  return (jstring) JNIHandles::make_local(THREAD, result);\n@@ -1101,1 +1136,0 @@\n-  JVMWrapper(\"JVM_GetClassInterfaces\");\n@@ -1108,2 +1142,2 @@\n-    objArrayOop r = oopFactory::new_objArray(SystemDictionary::Class_klass(), 0, CHECK_NULL);\n-    return (jobjectArray) JNIHandles::make_local(env, r);\n+    objArrayOop r = oopFactory::new_objArray(vmClasses::Class_klass(), 0, CHECK_NULL);\n+    return (jobjectArray) JNIHandles::make_local(THREAD, r);\n@@ -1123,1 +1157,1 @@\n-  objArrayOop r = oopFactory::new_objArray(SystemDictionary::Class_klass(), size, CHECK_NULL);\n+  objArrayOop r = oopFactory::new_objArray(vmClasses::Class_klass(), size, CHECK_NULL);\n@@ -1134,2 +1168,2 @@\n-    result->obj_at_put(0, SystemDictionary::Cloneable_klass()->java_mirror());\n-    result->obj_at_put(1, SystemDictionary::Serializable_klass()->java_mirror());\n+    result->obj_at_put(0, vmClasses::Cloneable_klass()->java_mirror());\n+    result->obj_at_put(1, vmClasses::Serializable_klass()->java_mirror());\n@@ -1137,1 +1171,1 @@\n-  return (jobjectArray) JNIHandles::make_local(env, result());\n+  return (jobjectArray) JNIHandles::make_local(THREAD, result());\n@@ -1142,1 +1176,0 @@\n-  JVMWrapper(\"JVM_IsInterface\");\n@@ -1156,0 +1189,8 @@\n+JVM_ENTRY(jboolean, JVM_IsHiddenClass(JNIEnv *env, jclass cls))\n+  oop mirror = JNIHandles::resolve_non_null(cls);\n+  if (java_lang_Class::is_primitive(mirror)) {\n+    return JNI_FALSE;\n+  }\n+  Klass* k = java_lang_Class::as_Klass(mirror);\n+  return k->is_hidden();\n+JVM_END\n@@ -1158,2 +1199,2 @@\n-  JVMWrapper(\"JVM_GetClassSigners\");\n-  if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(cls))) {\n+  oop mirror = JNIHandles::resolve_non_null(cls);\n+  if (java_lang_Class::is_primitive(mirror)) {\n@@ -1165,1 +1206,1 @@\n-  objArrayHandle signers(THREAD, java_lang_Class::signers(JNIHandles::resolve_non_null(cls)));\n+  objArrayHandle signers(THREAD, java_lang_Class::signers(mirror));\n@@ -1179,1 +1220,1 @@\n-  return (jobjectArray) JNIHandles::make_local(env, signers_copy);\n+  return (jobjectArray) JNIHandles::make_local(THREAD, signers_copy);\n@@ -1184,2 +1225,2 @@\n-  JVMWrapper(\"JVM_SetClassSigners\");\n-  if (!java_lang_Class::is_primitive(JNIHandles::resolve_non_null(cls))) {\n+  oop mirror = JNIHandles::resolve_non_null(cls);\n+  if (!java_lang_Class::is_primitive(mirror)) {\n@@ -1189,1 +1230,1 @@\n-    Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));\n+    Klass* k = java_lang_Class::as_Klass(mirror);\n@@ -1198,2 +1239,2 @@\n-  JVMWrapper(\"JVM_GetProtectionDomain\");\n-  if (JNIHandles::resolve(cls) == NULL) {\n+  oop mirror = JNIHandles::resolve_non_null(cls);\n+  if (mirror == NULL) {\n@@ -1203,1 +1244,1 @@\n-  if (java_lang_Class::is_primitive(JNIHandles::resolve(cls))) {\n+  if (java_lang_Class::is_primitive(mirror)) {\n@@ -1208,2 +1249,2 @@\n-  oop pd = java_lang_Class::protection_domain(JNIHandles::resolve(cls));\n-  return (jobject) JNIHandles::make_local(env, pd);\n+  oop pd = java_lang_Class::protection_domain(mirror);\n+  return (jobject) JNIHandles::make_local(THREAD, pd);\n@@ -1215,2 +1256,1 @@\n-  JVMWrapper(\"JVM_GetInheritedAccessControlContext\");\n-  return JNIHandles::make_local(env, result);\n+  return JNIHandles::make_local(THREAD, result);\n@@ -1220,16 +1260,0 @@\n-class RegisterArrayForGC {\n- private:\n-  JavaThread *_thread;\n- public:\n-  RegisterArrayForGC(JavaThread *thread, GrowableArray<oop>* array)  {\n-    _thread = thread;\n-    _thread->register_array_for_gc(array);\n-  }\n-\n-  ~RegisterArrayForGC() {\n-    _thread->register_array_for_gc(NULL);\n-  }\n-};\n-\n-\n-  JVMWrapper(\"JVM_GetStackAccessControlContext\");\n@@ -1240,1 +1264,1 @@\n-  GrowableArray<oop>* local_array = new GrowableArray<oop>(12);\n+  GrowableArray<Handle>* local_array = new GrowableArray<Handle>(12);\n@@ -1259,1 +1283,1 @@\n-    if (method->method_holder() == SystemDictionary::AccessController_klass() &&\n+    if (method->method_holder() == vmClasses::AccessController_klass() &&\n@@ -1282,1 +1306,1 @@\n-      local_array->push(protection_domain);\n+      local_array->push(Handle(thread, protection_domain));\n@@ -1296,1 +1320,1 @@\n-    return JNIHandles::make_local(env, result);\n+    return JNIHandles::make_local(THREAD, result);\n@@ -1299,3 +1323,1 @@\n-  \/\/ the resource area must be registered in case of a gc\n-  RegisterArrayForGC ragc(thread, local_array);\n-  objArrayOop context = oopFactory::new_objArray(SystemDictionary::ProtectionDomain_klass(),\n+  objArrayOop context = oopFactory::new_objArray(vmClasses::ProtectionDomain_klass(),\n@@ -1305,1 +1327,1 @@\n-    h_context->obj_at_put(index, local_array->at(index));\n+    h_context->obj_at_put(index, local_array->at(index)());\n@@ -1310,1 +1332,1 @@\n-  return JNIHandles::make_local(env, result);\n+  return JNIHandles::make_local(THREAD, result);\n@@ -1315,1 +1337,0 @@\n-  JVMWrapper(\"JVM_IsArrayClass\");\n@@ -1322,1 +1343,0 @@\n-  JVMWrapper(\"JVM_IsPrimitiveClass\");\n@@ -1329,2 +1349,2 @@\n-  JVMWrapper(\"JVM_GetClassModifiers\");\n-  if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(cls))) {\n+  oop mirror = JNIHandles::resolve_non_null(cls);\n+  if (java_lang_Class::is_primitive(mirror)) {\n@@ -1335,2 +1355,2 @@\n-  Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));\n-  debug_only(int computed_modifiers = k->compute_modifier_flags(CHECK_0));\n+  Klass* k = java_lang_Class::as_Klass(mirror);\n+  debug_only(int computed_modifiers = k->compute_modifier_flags());\n@@ -1348,5 +1368,5 @@\n-\n-  if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(ofClass)) ||\n-      ! java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass))->is_instance_klass()) {\n-    oop result = oopFactory::new_objArray(SystemDictionary::Class_klass(), 0, CHECK_NULL);\n-    return (jobjectArray)JNIHandles::make_local(env, result);\n+  oop ofMirror = JNIHandles::resolve_non_null(ofClass);\n+  if (java_lang_Class::is_primitive(ofMirror) ||\n+      ! java_lang_Class::as_Klass(ofMirror)->is_instance_klass()) {\n+    oop result = oopFactory::new_objArray(vmClasses::Class_klass(), 0, CHECK_NULL);\n+    return (jobjectArray)JNIHandles::make_local(THREAD, result);\n@@ -1355,1 +1375,1 @@\n-  InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass)));\n+  InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(ofMirror));\n@@ -1360,2 +1380,2 @@\n-    oop result = oopFactory::new_objArray(SystemDictionary::Class_klass(), 0, CHECK_NULL);\n-    return (jobjectArray)JNIHandles::make_local(env, result);\n+    oop result = oopFactory::new_objArray(vmClasses::Class_klass(), 0, CHECK_NULL);\n+    return (jobjectArray)JNIHandles::make_local(THREAD, result);\n@@ -1369,1 +1389,1 @@\n-  objArrayOop r = oopFactory::new_objArray(SystemDictionary::Class_klass(), length\/4, CHECK_NULL);\n+  objArrayOop r = oopFactory::new_objArray(vmClasses::Class_klass(), length\/4, CHECK_NULL);\n@@ -1399,1 +1419,1 @@\n-    objArrayOop res = oopFactory::new_objArray(SystemDictionary::Class_klass(), members, CHECK_NULL);\n+    objArrayOop res = oopFactory::new_objArray(vmClasses::Class_klass(), members, CHECK_NULL);\n@@ -1403,1 +1423,1 @@\n-    return (jobjectArray)JNIHandles::make_local(env, res);\n+    return (jobjectArray)JNIHandles::make_local(THREAD, res);\n@@ -1406,1 +1426,1 @@\n-  return (jobjectArray)JNIHandles::make_local(env, result());\n+  return (jobjectArray)JNIHandles::make_local(THREAD, result());\n@@ -1413,2 +1433,6 @@\n-  if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(ofClass)) ||\n-      ! java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass))->is_instance_klass()) {\n+  oop ofMirror = JNIHandles::resolve_non_null(ofClass);\n+  if (java_lang_Class::is_primitive(ofMirror)) {\n+    return NULL;\n+  }\n+  Klass* klass = java_lang_Class::as_Klass(ofMirror);\n+  if (!klass->is_instance_klass()) {\n@@ -1420,2 +1444,1 @@\n-    = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass))\n-                          )->compute_enclosing_class(&inner_is_member, CHECK_NULL);\n+    = InstanceKlass::cast(klass)->compute_enclosing_class(&inner_is_member, CHECK_NULL);\n@@ -1423,2 +1446,2 @@\n-  if (!inner_is_member)  return NULL;     \/\/ an anonymous class (inside a method)\n-  return (jclass) JNIHandles::make_local(env, outer_klass->java_mirror());\n+  if (!inner_is_member)  return NULL;     \/\/ a hidden class (inside a method)\n+  return (jclass) JNIHandles::make_local(THREAD, outer_klass->java_mirror());\n@@ -1431,2 +1454,1 @@\n-  if (java_lang_Class::is_primitive(mirror) ||\n-      !java_lang_Class::as_Klass(mirror)->is_instance_klass()) {\n+  if (java_lang_Class::is_primitive(mirror)) {\n@@ -1435,1 +1457,5 @@\n-  InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(mirror));\n+  Klass* klass = java_lang_Class::as_Klass(mirror);\n+  if (!klass->is_instance_klass()) {\n+    return NULL;\n+  }\n+  InstanceKlass* k = InstanceKlass::cast(klass);\n@@ -1442,1 +1468,1 @@\n-      return (jstring) JNIHandles::make_local(env, str());\n+      return (jstring) JNIHandles::make_local(THREAD, str());\n@@ -1451,1 +1477,0 @@\n-  JVMWrapper(\"JVM_GetClassSignature\");\n@@ -1454,0 +1479,1 @@\n+  oop mirror = JNIHandles::resolve_non_null(cls);\n@@ -1455,2 +1481,2 @@\n-  if (!java_lang_Class::is_primitive(JNIHandles::resolve(cls))) {\n-    Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve(cls));\n+  if (!java_lang_Class::is_primitive(mirror)) {\n+    Klass* k = java_lang_Class::as_Klass(mirror);\n@@ -1461,1 +1487,1 @@\n-      return (jstring) JNIHandles::make_local(env, str());\n+      return (jstring) JNIHandles::make_local(THREAD, str());\n@@ -1470,2 +1496,1 @@\n-  JVMWrapper(\"JVM_GetClassAnnotations\");\n-\n+  oop mirror = JNIHandles::resolve_non_null(cls);\n@@ -1473,2 +1498,2 @@\n-  if (!java_lang_Class::is_primitive(JNIHandles::resolve(cls))) {\n-    Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve(cls));\n+  if (!java_lang_Class::is_primitive(mirror)) {\n+    Klass* k = java_lang_Class::as_Klass(mirror);\n@@ -1477,1 +1502,1 @@\n-      return (jbyteArray) JNIHandles::make_local(env, a);\n+      return (jbyteArray) JNIHandles::make_local(THREAD, a);\n@@ -1484,1 +1509,1 @@\n-static bool jvm_get_field_common(jobject field, fieldDescriptor& fd, TRAPS) {\n+static bool jvm_get_field_common(jobject field, fieldDescriptor& fd) {\n@@ -1520,1 +1545,1 @@\n-  if (reflected->klass() == SystemDictionary::reflect_Constructor_klass()) {\n+  if (reflected->klass() == vmClasses::reflect_Constructor_klass()) {\n@@ -1524,1 +1549,1 @@\n-    assert(reflected->klass() == SystemDictionary::reflect_Method_klass(),\n+    assert(reflected->klass() == vmClasses::reflect_Method_klass(),\n@@ -1540,1 +1565,0 @@\n-  JVMWrapper(\"JVM_GetClassTypeAnnotations\");\n@@ -1549,1 +1573,1 @@\n-        return (jbyteArray) JNIHandles::make_local(env, a);\n+        return (jbyteArray) JNIHandles::make_local(THREAD, a);\n@@ -1558,2 +1582,0 @@\n-  JVMWrapper(\"JVM_GetMethodTypeAnnotations\");\n-\n@@ -1569,1 +1591,1 @@\n-    return (jbyteArray) JNIHandles::make_local(env, a);\n+    return (jbyteArray) JNIHandles::make_local(THREAD, a);\n@@ -1577,3 +1599,1 @@\n-  JVMWrapper(\"JVM_GetFieldTypeAnnotations\");\n-\n-  bool gotFd = jvm_get_field_common(field, fd, CHECK_NULL);\n+  bool gotFd = jvm_get_field_common(field, fd);\n@@ -1585,1 +1605,1 @@\n-  return (jbyteArray) JNIHandles::make_local(env, Annotations::make_java_array(fd.type_annotations(), THREAD));\n+  return (jbyteArray) JNIHandles::make_local(THREAD, Annotations::make_java_array(fd.type_annotations(), THREAD));\n@@ -1596,1 +1616,0 @@\n-  JVMWrapper(\"JVM_GetMethodParameters\");\n@@ -1628,1 +1647,1 @@\n-    objArrayOop result_oop = oopFactory::new_objArray(SystemDictionary::reflect_Parameter_klass(), num_params, CHECK_NULL);\n+    objArrayOop result_oop = oopFactory::new_objArray(vmClasses::reflect_Parameter_klass(), num_params, CHECK_NULL);\n@@ -1641,1 +1660,1 @@\n-    return (jobjectArray)JNIHandles::make_local(env, result());\n+    return (jobjectArray)JNIHandles::make_local(THREAD, result());\n@@ -1650,1 +1669,0 @@\n-  JVMWrapper(\"JVM_GetClassDeclaredFields\");\n@@ -1653,0 +1671,1 @@\n+  oop ofMirror = JNIHandles::resolve_non_null(ofClass);\n@@ -1654,2 +1673,2 @@\n-  if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(ofClass)) ||\n-      java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass))->is_array_klass()) {\n+  if (java_lang_Class::is_primitive(ofMirror) ||\n+      java_lang_Class::as_Klass(ofMirror)->is_array_klass()) {\n@@ -1657,2 +1676,2 @@\n-    oop res = oopFactory::new_objArray(SystemDictionary::reflect_Field_klass(), 0, CHECK_NULL);\n-    return (jobjectArray) JNIHandles::make_local(env, res);\n+    oop res = oopFactory::new_objArray(vmClasses::reflect_Field_klass(), 0, CHECK_NULL);\n+    return (jobjectArray) JNIHandles::make_local(THREAD, res);\n@@ -1661,1 +1680,1 @@\n-  InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass)));\n+  InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(ofMirror));\n@@ -1679,1 +1698,1 @@\n-  objArrayOop r = oopFactory::new_objArray(SystemDictionary::reflect_Field_klass(), num_fields, CHECK_NULL);\n+  objArrayOop r = oopFactory::new_objArray(vmClasses::reflect_Field_klass(), num_fields, CHECK_NULL);\n@@ -1693,1 +1712,1 @@\n-  return (jobjectArray) JNIHandles::make_local(env, result());\n+  return (jobjectArray) JNIHandles::make_local(THREAD, result());\n@@ -1697,0 +1716,2 @@\n+\/\/ A class is a record if and only if it is final and a direct subclass of\n+\/\/ java.lang.Record and has a Record attribute; otherwise, it is not a record.\n@@ -1699,1 +1720,0 @@\n-  JVMWrapper(\"JVM_IsRecord\");\n@@ -1710,0 +1730,5 @@\n+\/\/ Returns an array containing the components of the Record attribute,\n+\/\/ or NULL if the attribute is not present.\n+\/\/\n+\/\/ Note that this function returns the components of the Record attribute\n+\/\/ even if the class is not a record.\n@@ -1712,1 +1737,0 @@\n-  JVMWrapper(\"JVM_GetRecordComponents\");\n@@ -1717,19 +1741,15 @@\n-  if (ik->is_record()) {\n-    Array<RecordComponent*>* components = ik->record_components();\n-    assert(components != NULL, \"components should not be NULL\");\n-    {\n-      JvmtiVMObjectAllocEventCollector oam;\n-      constantPoolHandle cp(THREAD, ik->constants());\n-      int length = components->length();\n-      assert(length >= 0, \"unexpected record_components length\");\n-      objArrayOop record_components =\n-        oopFactory::new_objArray(SystemDictionary::RecordComponent_klass(), length, CHECK_NULL);\n-      objArrayHandle components_h (THREAD, record_components);\n-\n-      for (int x = 0; x < length; x++) {\n-        RecordComponent* component = components->at(x);\n-        assert(component != NULL, \"unexpected NULL record component\");\n-        oop component_oop = java_lang_reflect_RecordComponent::create(ik, component, CHECK_NULL);\n-        components_h->obj_at_put(x, component_oop);\n-      }\n-      return (jobjectArray)JNIHandles::make_local(components_h());\n+  Array<RecordComponent*>* components = ik->record_components();\n+  if (components != NULL) {\n+    JvmtiVMObjectAllocEventCollector oam;\n+    constantPoolHandle cp(THREAD, ik->constants());\n+    int length = components->length();\n+    assert(length >= 0, \"unexpected record_components length\");\n+    objArrayOop record_components =\n+      oopFactory::new_objArray(vmClasses::RecordComponent_klass(), length, CHECK_NULL);\n+    objArrayHandle components_h (THREAD, record_components);\n+\n+    for (int x = 0; x < length; x++) {\n+      RecordComponent* component = components->at(x);\n+      assert(component != NULL, \"unexpected NULL record component\");\n+      oop component_oop = java_lang_reflect_RecordComponent::create(ik, component, CHECK_NULL);\n+      components_h->obj_at_put(x, component_oop);\n@@ -1737,0 +1757,1 @@\n+    return (jobjectArray)JNIHandles::make_local(THREAD, components_h());\n@@ -1739,3 +1760,1 @@\n-  \/\/ Return empty array if ofClass is not a record.\n-  objArrayOop result = oopFactory::new_objArray(SystemDictionary::RecordComponent_klass(), 0, CHECK_NULL);\n-  return (jobjectArray)JNIHandles::make_local(env, result);\n+  return NULL;\n@@ -1761,0 +1780,1 @@\n+  oop ofMirror = JNIHandles::resolve_non_null(ofClass);\n@@ -1762,2 +1782,2 @@\n-  if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(ofClass))\n-      || java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass))->is_array_klass()) {\n+  if (java_lang_Class::is_primitive(ofMirror)\n+      || java_lang_Class::as_Klass(ofMirror)->is_array_klass()) {\n@@ -1766,1 +1786,1 @@\n-    return (jobjectArray) JNIHandles::make_local(env, res);\n+    return (jobjectArray) JNIHandles::make_local(THREAD, res);\n@@ -1769,1 +1789,1 @@\n-  InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(ofClass)));\n+  InstanceKlass* k = InstanceKlass::cast(java_lang_Class::as_Klass(ofMirror));\n@@ -1819,1 +1839,1 @@\n-  return (jobjectArray) JNIHandles::make_local(env, result());\n+  return (jobjectArray) JNIHandles::make_local(THREAD, result());\n@@ -1824,1 +1844,0 @@\n-  JVMWrapper(\"JVM_GetClassDeclaredMethods\");\n@@ -1827,1 +1846,1 @@\n-                                           SystemDictionary::reflect_Method_klass(), THREAD);\n+                                           vmClasses::reflect_Method_klass(), THREAD);\n@@ -1833,1 +1852,0 @@\n-  JVMWrapper(\"JVM_GetClassDeclaredConstructors\");\n@@ -1836,1 +1854,1 @@\n-                                           SystemDictionary::reflect_Constructor_klass(), THREAD);\n+                                           vmClasses::reflect_Constructor_klass(), THREAD);\n@@ -1842,2 +1860,2 @@\n-  JVMWrapper(\"JVM_GetClassAccessFlags\");\n-  if (java_lang_Class::is_primitive(JNIHandles::resolve_non_null(cls))) {\n+  oop mirror = JNIHandles::resolve_non_null(cls);\n+  if (java_lang_Class::is_primitive(mirror)) {\n@@ -1848,1 +1866,1 @@\n-  Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));\n+  Klass* k = java_lang_Class::as_Klass(mirror);\n@@ -1855,1 +1873,0 @@\n-  JVMWrapper(\"JVM_AreNestMates\");\n@@ -1869,1 +1886,0 @@\n-  JVMWrapper(\"JVM_GetNestHost\");\n@@ -1873,2 +1889,1 @@\n-  \/\/ Don't post exceptions if validation fails\n-  InstanceKlass* host = ck->nest_host(NULL, THREAD);\n+  InstanceKlass* host = ck->nest_host(THREAD);\n@@ -1883,1 +1898,1 @@\n-  JVMWrapper(\"JVM_GetNestMembers\");\n+  ResourceMark rm(THREAD);\n@@ -1887,3 +1902,1 @@\n-  \/\/ Get the nest host for this nest - throw ICCE if validation fails\n-  Symbol* icce = vmSymbols::java_lang_IncompatibleClassChangeError();\n-  InstanceKlass* host = ck->nest_host(icce, CHECK_NULL);\n+  InstanceKlass* host = ck->nest_host(THREAD);\n@@ -1891,0 +1904,2 @@\n+  log_trace(class, nestmates)(\"Calling GetNestMembers for type %s with nest-host %s\",\n+                              ck->external_name(), host->external_name());\n@@ -1895,0 +1910,3 @@\n+\n+    log_trace(class, nestmates)(\" - host has %d listed nest members\", length);\n+\n@@ -1896,1 +1914,1 @@\n-    objArrayOop r = oopFactory::new_objArray(SystemDictionary::Class_klass(),\n+    objArrayOop r = oopFactory::new_objArray(vmClasses::Class_klass(),\n@@ -1898,1 +1916,1 @@\n-    objArrayHandle result (THREAD, r);\n+    objArrayHandle result(THREAD, r);\n@@ -1901,35 +1919,46 @@\n-      int i;\n-      for (i = 0; i < length; i++) {\n-         int cp_index = members->at(i);\n-         Klass* k = host->constants()->klass_at(cp_index, CHECK_NULL);\n-         if (k->is_instance_klass()) {\n-           InstanceKlass* nest_host_k =\n-             InstanceKlass::cast(k)->nest_host(icce, CHECK_NULL);\n-           if (nest_host_k == host) {\n-             result->obj_at_put(i+1, k->java_mirror());\n-           }\n-           else {\n-             \/\/ k's nest host is legal but it isn't our host so\n-             \/\/ throw ICCE\n-             ResourceMark rm(THREAD);\n-             Exceptions::fthrow(THREAD_AND_LOCATION,\n-                                icce,\n-                                \"Nest member %s in %s declares a different nest host of %s\",\n-                                k->external_name(),\n-                                host->external_name(),\n-                                nest_host_k->external_name()\n-                           );\n-             return NULL;\n-           }\n-         }\n-         else {\n-           \/\/ we have a bad nest member entry - throw ICCE\n-           ResourceMark rm(THREAD);\n-           Exceptions::fthrow(THREAD_AND_LOCATION,\n-                              icce,\n-                              \"Class %s can not be a nest member of %s\",\n-                              k->external_name(),\n-                              host->external_name()\n-                              );\n-           return NULL;\n-         }\n+      int count = 0;\n+      for (int i = 0; i < length; i++) {\n+        int cp_index = members->at(i);\n+        Klass* k = host->constants()->klass_at(cp_index, THREAD);\n+        if (HAS_PENDING_EXCEPTION) {\n+          if (PENDING_EXCEPTION->is_a(vmClasses::VirtualMachineError_klass())) {\n+            return NULL; \/\/ propagate VMEs\n+          }\n+          if (log_is_enabled(Trace, class, nestmates)) {\n+            stringStream ss;\n+            char* target_member_class = host->constants()->klass_name_at(cp_index)->as_C_string();\n+            ss.print(\" - resolution of nest member %s failed: \", target_member_class);\n+            java_lang_Throwable::print(PENDING_EXCEPTION, &ss);\n+            log_trace(class, nestmates)(\"%s\", ss.as_string());\n+          }\n+          CLEAR_PENDING_EXCEPTION;\n+          continue;\n+        }\n+        if (k->is_instance_klass()) {\n+          InstanceKlass* ik = InstanceKlass::cast(k);\n+          InstanceKlass* nest_host_k = ik->nest_host(CHECK_NULL);\n+          if (nest_host_k == host) {\n+            result->obj_at_put(count+1, k->java_mirror());\n+            count++;\n+            log_trace(class, nestmates)(\" - [%d] = %s\", count, ik->external_name());\n+          } else {\n+            log_trace(class, nestmates)(\" - skipping member %s with different host %s\",\n+                                        ik->external_name(), nest_host_k->external_name());\n+          }\n+        } else {\n+          log_trace(class, nestmates)(\" - skipping member %s that is not an instance class\",\n+                                      k->external_name());\n+        }\n+      }\n+      if (count < length) {\n+        \/\/ we had invalid entries so we need to compact the array\n+        log_trace(class, nestmates)(\" - compacting array from length %d to %d\",\n+                                    length + 1, count + 1);\n+\n+        objArrayOop r2 = oopFactory::new_objArray(vmClasses::Class_klass(),\n+                                                  count + 1, CHECK_NULL);\n+        objArrayHandle result2(THREAD, r2);\n+        for (int i = 0; i < count + 1; i++) {\n+          result2->obj_at_put(i, result->obj_at(i));\n+        }\n+        return (jobjectArray)JNIHandles::make_local(THREAD, result2());\n@@ -1939,1 +1968,1 @@\n-      assert(host == ck, \"must be singleton nest\");\n+      assert(host == ck || ck->is_hidden(), \"must be singleton nest or dynamic nestmate\");\n@@ -1946,0 +1975,61 @@\n+JVM_ENTRY(jobjectArray, JVM_GetPermittedSubclasses(JNIEnv* env, jclass current))\n+{\n+  oop mirror = JNIHandles::resolve_non_null(current);\n+  assert(!java_lang_Class::is_primitive(mirror), \"should not be\");\n+  Klass* c = java_lang_Class::as_Klass(mirror);\n+  assert(c->is_instance_klass(), \"must be\");\n+  InstanceKlass* ik = InstanceKlass::cast(c);\n+  ResourceMark rm(THREAD);\n+  log_trace(class, sealed)(\"Calling GetPermittedSubclasses for %s type %s\",\n+                           ik->is_sealed() ? \"sealed\" : \"non-sealed\", ik->external_name());\n+  if (ik->is_sealed()) {\n+    JvmtiVMObjectAllocEventCollector oam;\n+    Array<u2>* subclasses = ik->permitted_subclasses();\n+    int length = subclasses->length();\n+\n+    log_trace(class, sealed)(\" - sealed class has %d permitted subclasses\", length);\n+\n+    objArrayOop r = oopFactory::new_objArray(vmClasses::Class_klass(),\n+                                             length, CHECK_NULL);\n+    objArrayHandle result(THREAD, r);\n+    int count = 0;\n+    for (int i = 0; i < length; i++) {\n+      int cp_index = subclasses->at(i);\n+      Klass* k = ik->constants()->klass_at(cp_index, THREAD);\n+      if (HAS_PENDING_EXCEPTION) {\n+        if (PENDING_EXCEPTION->is_a(vmClasses::VirtualMachineError_klass())) {\n+          return NULL; \/\/ propagate VMEs\n+        }\n+        if (log_is_enabled(Trace, class, sealed)) {\n+          stringStream ss;\n+          char* permitted_subclass = ik->constants()->klass_name_at(cp_index)->as_C_string();\n+          ss.print(\" - resolution of permitted subclass %s failed: \", permitted_subclass);\n+          java_lang_Throwable::print(PENDING_EXCEPTION, &ss);\n+          log_trace(class, sealed)(\"%s\", ss.as_string());\n+        }\n+\n+        CLEAR_PENDING_EXCEPTION;\n+        continue;\n+      }\n+      if (k->is_instance_klass()) {\n+        result->obj_at_put(count++, k->java_mirror());\n+        log_trace(class, sealed)(\" - [%d] = %s\", count, k->external_name());\n+      }\n+    }\n+    if (count < length) {\n+      \/\/ we had invalid entries so we need to compact the array\n+      objArrayOop r2 = oopFactory::new_objArray(vmClasses::Class_klass(),\n+                                                count, CHECK_NULL);\n+      objArrayHandle result2(THREAD, r2);\n+      for (int i = 0; i < count; i++) {\n+        result2->obj_at_put(i, result->obj_at(i));\n+      }\n+      return (jobjectArray)JNIHandles::make_local(THREAD, result2());\n+    }\n+    return (jobjectArray)JNIHandles::make_local(THREAD, result());\n+  } else {\n+    return NULL;\n+  }\n+}\n+JVM_END\n+\n@@ -1950,2 +2040,1 @@\n-  JVMWrapper(\"JVM_GetClassConstantPool\");\n-\n+  oop mirror = JNIHandles::resolve_non_null(cls);\n@@ -1954,2 +2043,2 @@\n-  if (!java_lang_Class::is_primitive(JNIHandles::resolve_non_null(cls))) {\n-    Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(cls));\n+  if (!java_lang_Class::is_primitive(mirror)) {\n+    Klass* k = java_lang_Class::as_Klass(mirror);\n@@ -1960,1 +2049,1 @@\n-      return JNIHandles::make_local(jcp());\n+      return JNIHandles::make_local(THREAD, jcp());\n@@ -1970,1 +2059,0 @@\n-  JVMWrapper(\"JVM_ConstantPoolGetSize\");\n@@ -1979,1 +2067,0 @@\n-  JVMWrapper(\"JVM_ConstantPoolGetClassAt\");\n@@ -1987,1 +2074,1 @@\n-  return (jclass) JNIHandles::make_local(k->java_mirror());\n+  return (jclass) JNIHandles::make_local(THREAD, k->java_mirror());\n@@ -1993,1 +2080,0 @@\n-  JVMWrapper(\"JVM_ConstantPoolGetClassAtIfLoaded\");\n@@ -2002,1 +2088,1 @@\n-  return (jclass) JNIHandles::make_local(k->java_mirror());\n+  return (jclass) JNIHandles::make_local(THREAD, k->java_mirror());\n@@ -2032,1 +2118,1 @@\n-  return JNIHandles::make_local(method);\n+  return JNIHandles::make_local(THREAD, method);\n@@ -2037,1 +2123,0 @@\n-  JVMWrapper(\"JVM_ConstantPoolGetMethodAt\");\n@@ -2048,1 +2133,0 @@\n-  JVMWrapper(\"JVM_ConstantPoolGetMethodAtIfLoaded\");\n@@ -2079,1 +2163,1 @@\n-  return JNIHandles::make_local(field);\n+  return JNIHandles::make_local(THREAD, field);\n@@ -2084,1 +2168,0 @@\n-  JVMWrapper(\"JVM_ConstantPoolGetFieldAt\");\n@@ -2095,1 +2178,0 @@\n-  JVMWrapper(\"JVM_ConstantPoolGetFieldAtIfLoaded\");\n@@ -2106,1 +2188,0 @@\n-  JVMWrapper(\"JVM_ConstantPoolGetMemberRefInfoAt\");\n@@ -2118,1 +2199,1 @@\n-  objArrayOop  dest_o = oopFactory::new_objArray(SystemDictionary::String_klass(), 3, CHECK_NULL);\n+  objArrayOop  dest_o = oopFactory::new_objArray(vmClasses::String_klass(), 3, CHECK_NULL);\n@@ -2126,1 +2207,1 @@\n-  return (jobjectArray) JNIHandles::make_local(dest());\n+  return (jobjectArray) JNIHandles::make_local(THREAD, dest());\n@@ -2132,1 +2213,0 @@\n-  JVMWrapper(\"JVM_ConstantPoolGetClassRefIndexAt\");\n@@ -2146,1 +2226,0 @@\n-  JVMWrapper(\"JVM_ConstantPoolGetNameAndTypeRefIndexAt\");\n@@ -2160,1 +2239,0 @@\n-  JVMWrapper(\"JVM_ConstantPoolGetNameAndTypeRefInfoAt\");\n@@ -2170,1 +2248,1 @@\n-  objArrayOop dest_o = oopFactory::new_objArray(SystemDictionary::String_klass(), 2, CHECK_NULL);\n+  objArrayOop dest_o = oopFactory::new_objArray(vmClasses::String_klass(), 2, CHECK_NULL);\n@@ -2176,1 +2254,1 @@\n-  return (jobjectArray) JNIHandles::make_local(dest());\n+  return (jobjectArray) JNIHandles::make_local(THREAD, dest());\n@@ -2182,1 +2260,0 @@\n-  JVMWrapper(\"JVM_ConstantPoolGetIntAt\");\n@@ -2195,1 +2272,0 @@\n-  JVMWrapper(\"JVM_ConstantPoolGetLongAt\");\n@@ -2208,1 +2284,0 @@\n-  JVMWrapper(\"JVM_ConstantPoolGetFloatAt\");\n@@ -2221,1 +2296,0 @@\n-  JVMWrapper(\"JVM_ConstantPoolGetDoubleAt\");\n@@ -2234,1 +2308,0 @@\n-  JVMWrapper(\"JVM_ConstantPoolGetStringAt\");\n@@ -2242,1 +2315,1 @@\n-  return (jstring) JNIHandles::make_local(str);\n+  return (jstring) JNIHandles::make_local(THREAD, str);\n@@ -2248,1 +2321,0 @@\n-  JVMWrapper(\"JVM_ConstantPoolGetUTF8At\");\n@@ -2258,1 +2330,1 @@\n-  return (jstring) JNIHandles::make_local(str());\n+  return (jstring) JNIHandles::make_local(THREAD, str());\n@@ -2264,1 +2336,0 @@\n-  JVMWrapper(\"JVM_ConstantPoolGetTagAt\");\n@@ -2290,1 +2361,0 @@\n-  JVMWrapper(\"JVM_DesiredAssertionStatus\");\n@@ -2312,1 +2382,0 @@\n-  JVMWrapper(\"JVM_AssertionStatusDirectives\");\n@@ -2315,1 +2384,1 @@\n-  return JNIHandles::make_local(env, asd);\n+  return JNIHandles::make_local(THREAD, asd);\n@@ -2331,1 +2400,0 @@\n-  JVMWrapper(\"JVM_GetClassNameUTF\");\n@@ -2339,1 +2407,0 @@\n-  JVMWrapper(\"JVM_GetClassCPTypes\");\n@@ -2355,1 +2422,0 @@\n-  JVMWrapper(\"JVM_GetClassCPEntriesCount\");\n@@ -2363,1 +2429,0 @@\n-  JVMWrapper(\"JVM_GetClassFieldsCount\");\n@@ -2371,1 +2436,0 @@\n-  JVMWrapper(\"JVM_GetClassMethodsCount\");\n@@ -2384,1 +2448,0 @@\n-  JVMWrapper(\"JVM_GetMethodIxExceptionIndexes\");\n@@ -2399,1 +2462,0 @@\n-  JVMWrapper(\"JVM_GetMethodIxExceptionsCount\");\n@@ -2408,1 +2470,0 @@\n-  JVMWrapper(\"JVM_GetMethodIxByteCode\");\n@@ -2417,1 +2478,0 @@\n-  JVMWrapper(\"JVM_GetMethodIxByteCodeLength\");\n@@ -2426,1 +2486,0 @@\n-  JVMWrapper(\"JVM_GetMethodIxExceptionTableEntry\");\n@@ -2439,1 +2498,0 @@\n-  JVMWrapper(\"JVM_GetMethodIxExceptionTableLength\");\n@@ -2448,1 +2506,0 @@\n-  JVMWrapper(\"JVM_GetMethodIxModifiers\");\n@@ -2457,1 +2514,0 @@\n-  JVMWrapper(\"JVM_GetFieldIxModifiers\");\n@@ -2465,1 +2521,0 @@\n-  JVMWrapper(\"JVM_GetMethodIxLocalsCount\");\n@@ -2474,1 +2529,0 @@\n-  JVMWrapper(\"JVM_GetMethodIxArgsSize\");\n@@ -2483,1 +2537,0 @@\n-  JVMWrapper(\"JVM_GetMethodIxMaxStack\");\n@@ -2492,1 +2545,0 @@\n-  JVMWrapper(\"JVM_IsConstructorIx\");\n@@ -2502,1 +2554,0 @@\n-  JVMWrapper(\"JVM_IsVMGeneratedMethodIx\");\n@@ -2511,1 +2562,0 @@\n-  JVMWrapper(\"JVM_GetMethodIxIxUTF\");\n@@ -2520,1 +2570,0 @@\n-  JVMWrapper(\"JVM_GetMethodIxSignatureUTF\");\n@@ -2536,1 +2585,0 @@\n-  JVMWrapper(\"JVM_GetCPFieldNameUTF\");\n@@ -2552,1 +2600,0 @@\n-  JVMWrapper(\"JVM_GetCPMethodNameUTF\");\n@@ -2569,1 +2616,0 @@\n-  JVMWrapper(\"JVM_GetCPMethodSignatureUTF\");\n@@ -2586,1 +2632,0 @@\n-  JVMWrapper(\"JVM_GetCPFieldSignatureUTF\");\n@@ -2602,1 +2647,0 @@\n-  JVMWrapper(\"JVM_GetCPClassNameUTF\");\n@@ -2612,1 +2656,0 @@\n-  JVMWrapper(\"JVM_GetCPFieldClassNameUTF\");\n@@ -2631,1 +2674,0 @@\n-  JVMWrapper(\"JVM_GetCPMethodClassNameUTF\");\n@@ -2651,1 +2693,0 @@\n-  JVMWrapper(\"JVM_GetCPFieldModifiers\");\n@@ -2679,1 +2720,0 @@\n-  JVMWrapper(\"JVM_GetCPMethodModifiers\");\n@@ -2716,1 +2756,0 @@\n-  JVMWrapper(\"JVM_IsSameClassPackage\");\n@@ -2786,1 +2825,1 @@\n-    \/\/ Make an unused local variable to avoid warning from gcc 4.x compiler.\n+    \/\/ Make an unused local variable to avoid warning from gcc compiler.\n@@ -2808,1 +2847,1 @@\n-                          SystemDictionary::Thread_klass(),\n+                          vmClasses::Thread_klass(),\n@@ -2816,1 +2855,0 @@\n-  JVMWrapper(\"JVM_StartThread\");\n@@ -2885,0 +2923,9 @@\n+#if INCLUDE_JFR\n+  if (Jfr::is_recording() && EventThreadStart::is_enabled() &&\n+      EventThreadStart::is_stacktrace_enabled()) {\n+    JfrThreadLocal* tl = native_thread->jfr_thread_local();\n+    \/\/ skip Thread.start() and Thread.start0()\n+    tl->set_cached_stack_trace_id(JfrStackTraceRepository::record(thread, 2));\n+  }\n+#endif\n+\n@@ -2895,4 +2942,0 @@\n-  JVMWrapper(\"JVM_StopThread\");\n-\n-  \/\/ A nested ThreadsListHandle will grab the Threads_lock so create\n-  \/\/ tlh before we resolve throwable.\n@@ -2909,1 +2952,1 @@\n-                        p2i(receiver), p2i((address)java_thread), p2i(throwable));\n+                        p2i(receiver), p2i(java_thread), p2i(throwable));\n@@ -2918,1 +2961,1 @@\n-      Thread::send_async_exception(java_thread, java_throwable);\n+      JavaThread::send_async_exception(java_thread, java_throwable);\n@@ -2934,2 +2977,0 @@\n-  JVMWrapper(\"JVM_IsThreadAlive\");\n-\n@@ -2942,2 +2983,0 @@\n-  JVMWrapper(\"JVM_SuspendThread\");\n-\n@@ -2948,16 +2987,2 @@\n-    \/\/ jthread refers to a live JavaThread.\n-    {\n-      MutexLocker ml(receiver->SR_lock(), Mutex::_no_safepoint_check_flag);\n-      if (receiver->is_external_suspend()) {\n-        \/\/ Don't allow nested external suspend requests. We can't return\n-        \/\/ an error from this interface so just ignore the problem.\n-        return;\n-      }\n-      if (receiver->is_exiting()) { \/\/ thread is in the process of exiting\n-        return;\n-      }\n-      receiver->set_external_suspend();\n-    }\n-\n-    \/\/ java_suspend() will catch threads in the process of exiting\n-    \/\/ and will ignore them.\n+    \/\/ jthread refers to a live JavaThread, but java_suspend() will\n+    \/\/ detect a thread that has started to exit and will ignore it.\n@@ -2965,9 +2990,0 @@\n-\n-    \/\/ It would be nice to have the following assertion in all the\n-    \/\/ time, but it is possible for a racing resume request to have\n-    \/\/ resumed this thread right after we suspended it. Temporarily\n-    \/\/ enable this assertion if you are chasing a different kind of\n-    \/\/ bug.\n-    \/\/\n-    \/\/ assert(java_lang_Thread::thread(receiver->threadObj()) == NULL ||\n-    \/\/   receiver->is_being_ext_suspended(), \"thread is not suspended\");\n@@ -2979,2 +2995,0 @@\n-  JVMWrapper(\"JVM_ResumeThread\");\n-\n@@ -2986,16 +3000,0 @@\n-\n-    \/\/ This is the original comment for this Threads_lock grab:\n-    \/\/   We need to *always* get the threads lock here, since this operation cannot be allowed during\n-    \/\/   a safepoint. The safepoint code relies on suspending a thread to examine its state. If other\n-    \/\/   threads randomly resumes threads, then a thread might not be suspended when the safepoint code\n-    \/\/   looks at it.\n-    \/\/\n-    \/\/ The above comment dates back to when we had both internal and\n-    \/\/ external suspend APIs that shared a common underlying mechanism.\n-    \/\/ External suspend is now entirely cooperative and doesn't share\n-    \/\/ anything with internal suspend. That said, there are some\n-    \/\/ assumptions in the VM that an external resume grabs the\n-    \/\/ Threads_lock. We can't drop the Threads_lock grab here until we\n-    \/\/ resolve the assumptions that exist elsewhere.\n-    \/\/\n-    MutexLocker ml(Threads_lock);\n@@ -3008,2 +3006,0 @@\n-  JVMWrapper(\"JVM_SetThreadPriority\");\n-\n@@ -3027,1 +3023,0 @@\n-  JVMWrapper(\"JVM_Yield\");\n@@ -3041,2 +3036,0 @@\n-  JVMWrapper(\"JVM_Sleep\");\n-\n@@ -3086,3 +3079,2 @@\n-  JVMWrapper(\"JVM_CurrentThread\");\n-  assert (thread != NULL, \"no current thread!\");\n-  return JNIHandles::make_local(env, jthread);\n+  assert(jthread != NULL, \"no current thread!\");\n+  return JNIHandles::make_local(THREAD, jthread);\n@@ -3093,2 +3085,0 @@\n-  JVMWrapper(\"JVM_Interrupt\");\n-\n@@ -3108,2 +3098,0 @@\n-  JVMWrapper(\"JVM_HoldsLock\");\n-  assert(THREAD->is_Java_thread(), \"sanity check\");\n@@ -3114,1 +3102,1 @@\n-  return ObjectSynchronizer::current_thread_holds_lock((JavaThread*)THREAD, h_obj);\n+  return ObjectSynchronizer::current_thread_holds_lock(thread, h_obj);\n@@ -3119,1 +3107,0 @@\n-  JVMWrapper(\"JVM_DumpAllStacks\");\n@@ -3128,2 +3115,0 @@\n-  JVMWrapper(\"JVM_SetNativeThreadName\");\n-\n@@ -3147,1 +3132,0 @@\n-  JVMWrapper(\"JVM_GetClassContext\");\n@@ -3152,1 +3136,1 @@\n-  if (SystemDictionary::reflect_CallerSensitive_klass() != NULL) {\n+  if (vmClasses::reflect_CallerSensitive_klass() != NULL) {\n@@ -3155,1 +3139,1 @@\n-    if (!(m->method_holder() == SystemDictionary::SecurityManager_klass() &&\n+    if (!(m->method_holder() == vmClasses::SecurityManager_klass() &&\n@@ -3175,1 +3159,1 @@\n-  objArrayOop result = oopFactory::new_objArray(SystemDictionary::Class_klass(), klass_array->length(), CHECK_NULL);\n+  objArrayOop result = oopFactory::new_objArray(vmClasses::Class_klass(), klass_array->length(), CHECK_NULL);\n@@ -3181,1 +3165,1 @@\n-  return (jobjectArray) JNIHandles::make_local(env, result);\n+  return (jobjectArray) JNIHandles::make_local(THREAD, result);\n@@ -3189,1 +3173,0 @@\n-  JVMWrapper(\"JVM_GetSystemPackage\");\n@@ -3194,1 +3177,1 @@\n-  return (jstring) JNIHandles::make_local(result);\n+return (jstring) JNIHandles::make_local(THREAD, result);\n@@ -3199,1 +3182,0 @@\n-  JVMWrapper(\"JVM_GetSystemPackages\");\n@@ -3202,1 +3184,1 @@\n-  return (jobjectArray) JNIHandles::make_local(result);\n+  return (jobjectArray) JNIHandles::make_local(THREAD, result);\n@@ -3210,2 +3192,0 @@\n-  JVMWrapper(\"JVM_GetAndClearReferencePendingList\");\n-\n@@ -3215,1 +3195,1 @@\n-    Universe::set_reference_pending_list(NULL);\n+    Universe::clear_reference_pending_list();\n@@ -3217,1 +3197,1 @@\n-  return JNIHandles::make_local(env, ref);\n+  return JNIHandles::make_local(THREAD, ref);\n@@ -3221,1 +3201,0 @@\n-  JVMWrapper(\"JVM_HasReferencePendingList\");\n@@ -3227,1 +3206,0 @@\n-  JVMWrapper(\"JVM_WaitForReferencePendingList\");\n@@ -3234,0 +3212,34 @@\n+JVM_ENTRY(jboolean, JVM_ReferenceRefersTo(JNIEnv* env, jobject ref, jobject o))\n+  oop ref_oop = JNIHandles::resolve_non_null(ref);\n+  oop referent = java_lang_ref_Reference::weak_referent_no_keepalive(ref_oop);\n+  return referent == JNIHandles::resolve(o);\n+JVM_END\n+\n+JVM_ENTRY(void, JVM_ReferenceClear(JNIEnv* env, jobject ref))\n+  oop ref_oop = JNIHandles::resolve_non_null(ref);\n+  \/\/ FinalReference has it's own implementation of clear().\n+  assert(!java_lang_ref_Reference::is_final(ref_oop), \"precondition\");\n+  if (java_lang_ref_Reference::unknown_referent_no_keepalive(ref_oop) == NULL) {\n+    \/\/ If the referent has already been cleared then done.\n+    \/\/ However, if the referent is dead but has not yet been cleared by\n+    \/\/ concurrent reference processing, it should NOT be cleared here.\n+    \/\/ Instead, clearing should be left to the GC.  Clearing it here could\n+    \/\/ detectably lose an expected notification, which is impossible with\n+    \/\/ STW reference processing.  The clearing in enqueue() doesn't have\n+    \/\/ this problem, since the enqueue covers the notification, but it's not\n+    \/\/ worth the effort to handle that case specially.\n+    return;\n+  }\n+  java_lang_ref_Reference::clear_referent(ref_oop);\n+JVM_END\n+\n+\n+\/\/ java.lang.ref.PhantomReference \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+\n+JVM_ENTRY(jboolean, JVM_PhantomReferenceRefersTo(JNIEnv* env, jobject ref, jobject o))\n+  oop ref_oop = JNIHandles::resolve_non_null(ref);\n+  oop referent = java_lang_ref_Reference::phantom_referent_no_keepalive(ref_oop);\n+  return referent == JNIHandles::resolve(o);\n+JVM_END\n+\n@@ -3242,2 +3254,2 @@\n-    vfst.skip_reflection_related_frames(); \/\/ Only needed for 1.4 reflection\n-    oop loader = vfst.method()->method_holder()->class_loader();\n+    InstanceKlass* ik = vfst.method()->method_holder();\n+    oop loader = ik->class_loader();\n@@ -3245,1 +3257,5 @@\n-      return JNIHandles::make_local(env, loader);\n+      \/\/ Skip reflection related frames\n+      if (!ik->is_subclass_of(vmClasses::reflect_MethodAccessorImpl_klass()) &&\n+          !ik->is_subclass_of(vmClasses::reflect_ConstructorAccessorImpl_klass())) {\n+        return JNIHandles::make_local(THREAD, loader);\n+      }\n@@ -3271,1 +3287,0 @@\n-  JVMWrapper(\"JVM_GetArrayLength\");\n@@ -3278,1 +3293,0 @@\n-  JVMWrapper(\"JVM_Array_Get\");\n@@ -3284,1 +3298,1 @@\n-  return JNIHandles::make_local(env, box);\n+  return JNIHandles::make_local(THREAD, box);\n@@ -3289,1 +3303,0 @@\n-  JVMWrapper(\"JVM_GetPrimitiveArrayElement\");\n@@ -3304,1 +3317,0 @@\n-  JVMWrapper(\"JVM_SetArrayElement\");\n@@ -3321,1 +3333,0 @@\n-  JVMWrapper(\"JVM_SetPrimitiveArrayElement\");\n@@ -3330,1 +3341,0 @@\n-  JVMWrapper(\"JVM_NewArray\");\n@@ -3334,1 +3344,1 @@\n-  return JNIHandles::make_local(env, result);\n+  return JNIHandles::make_local(THREAD, result);\n@@ -3339,1 +3349,0 @@\n-  JVMWrapper(\"JVM_NewMultiArray\");\n@@ -3345,1 +3354,1 @@\n-  return JNIHandles::make_local(env, result);\n+  return JNIHandles::make_local(THREAD, result);\n@@ -3353,1 +3362,0 @@\n-  JVMWrapper(\"JVM_LoadLibrary\");\n@@ -3374,0 +3382,1 @@\n+  log_info(library)(\"Loaded library %s, handle \" INTPTR_FORMAT, name, p2i(load_result));\n@@ -3379,1 +3388,1 @@\n-  JVMWrapper(\"JVM_UnloadLibrary\");\n+  log_info(library)(\"Unloaded library with handle \" INTPTR_FORMAT, p2i(handle));\n@@ -3385,2 +3394,5 @@\n-  JVMWrapper(\"JVM_FindLibraryEntry\");\n-  return os::dll_lookup(handle, name);\n+  void* find_result = os::dll_lookup(handle, name);\n+  log_info(library)(\"%s %s in library with handle \" INTPTR_FORMAT,\n+                    find_result != NULL ? \"Found\" : \"Failed to find\",\n+                    name, p2i(handle));\n+  return find_result;\n@@ -3393,1 +3405,0 @@\n-  JVMWrapper(\"JVM_IsSupportedJNIVersion\");\n@@ -3401,1 +3412,0 @@\n-  JVMWrapper(\"JVM_InternString\");\n@@ -3406,1 +3416,1 @@\n-  return (jstring) JNIHandles::make_local(env, result);\n+  return (jstring) JNIHandles::make_local(THREAD, result);\n@@ -3421,1 +3431,0 @@\n-  JVMWrapper(\"JVM_RawMonitorCreate\");\n@@ -3428,1 +3437,0 @@\n-  JVMWrapper(\"JVM_RawMonitorDestroy\");\n@@ -3435,1 +3443,0 @@\n-  JVMWrapper(\"JVM_RawMonitorEnter\");\n@@ -3443,1 +3450,0 @@\n-  JVMWrapper(\"JVM_RawMonitorExit\");\n@@ -3465,1 +3471,1 @@\n-  return (jclass) JNIHandles::make_local(env, klass->java_mirror());\n+  return (jclass) JNIHandles::make_local(THREAD, klass->java_mirror());\n@@ -3472,2 +3478,1 @@\n-  JVMWrapper(\"JVM_InvokeMethod\");\n-  if (thread->stack_available((address) &method_handle) >= JVMInvokeMethodSlack) {\n+  if (thread->stack_overflow_state()->stack_available((address) &method_handle) >= JVMInvokeMethodSlack) {\n@@ -3479,1 +3484,1 @@\n-    jobject res = JNIHandles::make_local(env, result);\n+    jobject res = JNIHandles::make_local(THREAD, result);\n@@ -3486,1 +3491,1 @@\n-        JvmtiExport::post_vm_object_alloc(JavaThread::current(), result);\n+        JvmtiExport::post_vm_object_alloc(thread, result);\n@@ -3497,1 +3502,0 @@\n-  JVMWrapper(\"JVM_NewInstanceFromConstructor\");\n@@ -3501,1 +3505,1 @@\n-  jobject res = JNIHandles::make_local(env, result);\n+  jobject res = JNIHandles::make_local(THREAD, result);\n@@ -3503,1 +3507,1 @@\n-    JvmtiExport::post_vm_object_alloc(JavaThread::current(), result);\n+    JvmtiExport::post_vm_object_alloc(thread, result);\n@@ -3511,1 +3515,0 @@\n-  JVMWrapper(\"JVM_SupportsCX8\");\n@@ -3516,1 +3519,0 @@\n-  JVMWrapper(\"JVM_InitializeFromArchive\");\n@@ -3519,1 +3521,173 @@\n-  HeapShared::initialize_from_archived_subgraph(k);\n+  HeapShared::initialize_from_archived_subgraph(k, THREAD);\n+JVM_END\n+\n+JVM_ENTRY(void, JVM_RegisterLambdaProxyClassForArchiving(JNIEnv* env,\n+                                              jclass caller,\n+                                              jstring interfaceMethodName,\n+                                              jobject factoryType,\n+                                              jobject interfaceMethodType,\n+                                              jobject implementationMember,\n+                                              jobject dynamicMethodType,\n+                                              jclass lambdaProxyClass))\n+#if INCLUDE_CDS\n+  if (!Arguments::is_dumping_archive()) {\n+    return;\n+  }\n+\n+  Klass* caller_k = java_lang_Class::as_Klass(JNIHandles::resolve(caller));\n+  InstanceKlass* caller_ik = InstanceKlass::cast(caller_k);\n+  if (caller_ik->is_hidden()) {\n+    \/\/ Hidden classes not of type lambda proxy classes are currently not being archived.\n+    \/\/ If the caller_ik is of one of the above types, the corresponding lambda proxy class won't be\n+    \/\/ registered for archiving.\n+    return;\n+  }\n+  Klass* lambda_k = java_lang_Class::as_Klass(JNIHandles::resolve(lambdaProxyClass));\n+  InstanceKlass* lambda_ik = InstanceKlass::cast(lambda_k);\n+  assert(lambda_ik->is_hidden(), \"must be a hidden class\");\n+  assert(!lambda_ik->is_non_strong_hidden(), \"expected a strong hidden class\");\n+\n+  Symbol* interface_method_name = NULL;\n+  if (interfaceMethodName != NULL) {\n+    interface_method_name = java_lang_String::as_symbol(JNIHandles::resolve_non_null(interfaceMethodName));\n+  }\n+  Handle factory_type_oop(THREAD, JNIHandles::resolve_non_null(factoryType));\n+  Symbol* factory_type = java_lang_invoke_MethodType::as_signature(factory_type_oop(), true);\n+\n+  Handle interface_method_type_oop(THREAD, JNIHandles::resolve_non_null(interfaceMethodType));\n+  Symbol* interface_method_type = java_lang_invoke_MethodType::as_signature(interface_method_type_oop(), true);\n+\n+  Handle implementation_member_oop(THREAD, JNIHandles::resolve_non_null(implementationMember));\n+  assert(java_lang_invoke_MemberName::is_method(implementation_member_oop()), \"must be\");\n+  Method* m = java_lang_invoke_MemberName::vmtarget(implementation_member_oop());\n+\n+  Handle dynamic_method_type_oop(THREAD, JNIHandles::resolve_non_null(dynamicMethodType));\n+  Symbol* dynamic_method_type = java_lang_invoke_MethodType::as_signature(dynamic_method_type_oop(), true);\n+\n+  SystemDictionaryShared::add_lambda_proxy_class(caller_ik, lambda_ik, interface_method_name, factory_type,\n+                                                 interface_method_type, m, dynamic_method_type, THREAD);\n+#endif \/\/ INCLUDE_CDS\n+JVM_END\n+\n+JVM_ENTRY(jclass, JVM_LookupLambdaProxyClassFromArchive(JNIEnv* env,\n+                                                        jclass caller,\n+                                                        jstring interfaceMethodName,\n+                                                        jobject factoryType,\n+                                                        jobject interfaceMethodType,\n+                                                        jobject implementationMember,\n+                                                        jobject dynamicMethodType))\n+#if INCLUDE_CDS\n+\n+  if (interfaceMethodName == NULL || factoryType == NULL || interfaceMethodType == NULL ||\n+      implementationMember == NULL || dynamicMethodType == NULL) {\n+    THROW_(vmSymbols::java_lang_NullPointerException(), NULL);\n+  }\n+\n+  Klass* caller_k = java_lang_Class::as_Klass(JNIHandles::resolve(caller));\n+  InstanceKlass* caller_ik = InstanceKlass::cast(caller_k);\n+  if (!caller_ik->is_shared()) {\n+    \/\/ there won't be a shared lambda class if the caller_ik is not in the shared archive.\n+    return NULL;\n+  }\n+\n+  Symbol* interface_method_name = java_lang_String::as_symbol(JNIHandles::resolve_non_null(interfaceMethodName));\n+  Handle factory_type_oop(THREAD, JNIHandles::resolve_non_null(factoryType));\n+  Symbol* factory_type = java_lang_invoke_MethodType::as_signature(factory_type_oop(), true);\n+\n+  Handle interface_method_type_oop(THREAD, JNIHandles::resolve_non_null(interfaceMethodType));\n+  Symbol* interface_method_type = java_lang_invoke_MethodType::as_signature(interface_method_type_oop(), true);\n+\n+  Handle implementation_member_oop(THREAD, JNIHandles::resolve_non_null(implementationMember));\n+  assert(java_lang_invoke_MemberName::is_method(implementation_member_oop()), \"must be\");\n+  Method* m = java_lang_invoke_MemberName::vmtarget(implementation_member_oop());\n+\n+  Handle dynamic_method_type_oop(THREAD, JNIHandles::resolve_non_null(dynamicMethodType));\n+  Symbol* dynamic_method_type = java_lang_invoke_MethodType::as_signature(dynamic_method_type_oop(), true);\n+\n+  InstanceKlass* lambda_ik = SystemDictionaryShared::get_shared_lambda_proxy_class(caller_ik, interface_method_name, factory_type,\n+                                                                                   interface_method_type, m, dynamic_method_type);\n+  jclass jcls = NULL;\n+  if (lambda_ik != NULL) {\n+    InstanceKlass* loaded_lambda = SystemDictionaryShared::prepare_shared_lambda_proxy_class(lambda_ik, caller_ik, THREAD);\n+    jcls = loaded_lambda == NULL ? NULL : (jclass) JNIHandles::make_local(THREAD, loaded_lambda->java_mirror());\n+  }\n+  return jcls;\n+#else\n+  return NULL;\n+#endif \/\/ INCLUDE_CDS\n+JVM_END\n+\n+JVM_ENTRY(jboolean, JVM_IsCDSDumpingEnabled(JNIEnv* env))\n+  return Arguments::is_dumping_archive();\n+JVM_END\n+\n+JVM_ENTRY(jboolean, JVM_IsSharingEnabled(JNIEnv* env))\n+  return UseSharedSpaces;\n+JVM_END\n+\n+JVM_ENTRY_NO_ENV(jlong, JVM_GetRandomSeedForDumping())\n+  if (DumpSharedSpaces) {\n+    const char* release = Abstract_VM_Version::vm_release();\n+    const char* dbg_level = Abstract_VM_Version::jdk_debug_level();\n+    const char* version = VM_Version::internal_vm_info_string();\n+    jlong seed = (jlong)(java_lang_String::hash_code((const jbyte*)release, (int)strlen(release)) ^\n+                         java_lang_String::hash_code((const jbyte*)dbg_level, (int)strlen(dbg_level)) ^\n+                         java_lang_String::hash_code((const jbyte*)version, (int)strlen(version)));\n+    seed += (jlong)Abstract_VM_Version::vm_major_version();\n+    seed += (jlong)Abstract_VM_Version::vm_minor_version();\n+    seed += (jlong)Abstract_VM_Version::vm_security_version();\n+    seed += (jlong)Abstract_VM_Version::vm_patch_version();\n+    if (seed == 0) { \/\/ don't let this ever be zero.\n+      seed = 0x87654321;\n+    }\n+    log_debug(cds)(\"JVM_GetRandomSeedForDumping() = \" JLONG_FORMAT, seed);\n+    return seed;\n+  } else {\n+    return 0;\n+  }\n+JVM_END\n+\n+JVM_ENTRY(jboolean, JVM_IsDumpingClassList(JNIEnv *env))\n+#if INCLUDE_CDS\n+  return ClassListWriter::is_enabled() || DynamicDumpSharedSpaces;\n+#else\n+  return false;\n+#endif \/\/ INCLUDE_CDS\n+JVM_END\n+\n+JVM_ENTRY(void, JVM_LogLambdaFormInvoker(JNIEnv *env, jstring line))\n+#if INCLUDE_CDS\n+  assert(ClassListWriter::is_enabled() || DynamicDumpSharedSpaces,  \"Should be set and open or do dynamic dump\");\n+  if (line != NULL) {\n+    ResourceMark rm(THREAD);\n+    Handle h_line (THREAD, JNIHandles::resolve_non_null(line));\n+    char* c_line = java_lang_String::as_utf8_string(h_line());\n+    if (DynamicDumpSharedSpaces) {\n+      \/\/ Note: LambdaFormInvokers::append_filtered and LambdaFormInvokers::append take same format which is not\n+      \/\/ same as below the print format. The line does not include LAMBDA_FORM_TAG.\n+      LambdaFormInvokers::append_filtered(os::strdup((const char*)c_line, mtInternal));\n+    }\n+    if (ClassListWriter::is_enabled()) {\n+      ClassListWriter w;\n+      w.stream()->print_cr(\"%s %s\", LAMBDA_FORM_TAG, c_line);\n+    }\n+  }\n+#endif \/\/ INCLUDE_CDS\n+JVM_END\n+\n+JVM_ENTRY(void, JVM_DumpClassListToFile(JNIEnv *env, jstring listFileName))\n+#if INCLUDE_CDS\n+  ResourceMark rm(THREAD);\n+  Handle file_handle(THREAD, JNIHandles::resolve_non_null(listFileName));\n+  char* file_name  = java_lang_String::as_utf8_string(file_handle());\n+  MetaspaceShared::dump_loaded_classes(file_name, THREAD);\n+#endif \/\/ INCLUDE_CDS\n+JVM_END\n+\n+JVM_ENTRY(void, JVM_DumpDynamicArchive(JNIEnv *env, jstring archiveName))\n+#if INCLUDE_CDS\n+  ResourceMark rm(THREAD);\n+  Handle file_handle(THREAD, JNIHandles::resolve_non_null(archiveName));\n+  char* archive_name  = java_lang_String::as_utf8_string(file_handle());\n+  DynamicArchive::dump(archive_name, CHECK);\n+#endif \/\/ INCLUDE_CDS\n@@ -3531,1 +3705,1 @@\n-  objArrayOop r = oopFactory::new_objArray(SystemDictionary::Thread_klass(), num_threads, CHECK_NULL);\n+  objArrayOop r = oopFactory::new_objArray(vmClasses::Thread_klass(), num_threads, CHECK_NULL);\n@@ -3539,1 +3713,1 @@\n-  return (jobjectArray) JNIHandles::make_local(env, threads_ah());\n+  return (jobjectArray) JNIHandles::make_local(THREAD, threads_ah());\n@@ -3547,1 +3721,0 @@\n-  JVMWrapper(\"JVM_DumpThreads\");\n@@ -3565,1 +3738,1 @@\n-  if (k != SystemDictionary::Thread_klass()) {\n+  if (k != vmClasses::Thread_klass()) {\n@@ -3581,1 +3754,1 @@\n-  return (jobjectArray)JNIHandles::make_local(env, stacktraces());\n+  return (jobjectArray)JNIHandles::make_local(THREAD, stacktraces());\n@@ -3594,1 +3767,0 @@\n-  JVMWrapper(\"JVM_InitAgentProperties\");\n@@ -3607,1 +3779,0 @@\n-  JVMWrapper(\"JVM_GetEnclosingMethodInfo\");\n@@ -3627,1 +3798,1 @@\n-  objArrayOop dest_o = oopFactory::new_objArray(SystemDictionary::Object_klass(), 3, CHECK_NULL);\n+  objArrayOop dest_o = oopFactory::new_objArray(vmClasses::Object_klass(), 3, CHECK_NULL);\n@@ -3644,1 +3815,1 @@\n-  return (jobjectArray) JNIHandles::make_local(dest());\n+  return (jobjectArray) JNIHandles::make_local(THREAD, dest());\n@@ -3661,1 +3832,1 @@\n-  InstanceKlass* ik = SystemDictionary::String_klass();\n+  InstanceKlass* ik = vmClasses::String_klass();\n@@ -3674,1 +3845,1 @@\n-  return (jobjectArray) JNIHandles::make_local(env, result_h());\n+  return (jobjectArray) JNIHandles::make_local(THREAD, result_h());\n@@ -3683,1 +3854,1 @@\n-  return (jobjectArray) JNIHandles::make_local(env, ret());\n+  return (jobjectArray) JNIHandles::make_local(THREAD, ret());\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":774,"deletions":603,"binary":false,"changes":1377,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2017, 2020, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Azul Systems, Inc. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"cds\/filemap.hpp\"\n@@ -33,0 +34,1 @@\n+#include \"compiler\/compilerDefinitions.hpp\"\n@@ -35,0 +37,2 @@\n+#include \"gc\/shared\/stringdedup\/stringDedup.hpp\"\n+#include \"gc\/shared\/tlab_globals.hpp\"\n@@ -40,1 +44,0 @@\n-#include \"memory\/filemap.hpp\"\n@@ -45,3 +48,2 @@\n-#include \"runtime\/flags\/jvmFlagConstraintList.hpp\"\n-#include \"runtime\/flags\/jvmFlagWriteableList.hpp\"\n-#include \"runtime\/flags\/jvmFlagRangeList.hpp\"\n+#include \"runtime\/flags\/jvmFlagAccess.hpp\"\n+#include \"runtime\/flags\/jvmFlagLimit.hpp\"\n@@ -50,1 +52,1 @@\n-#include \"runtime\/os.inline.hpp\"\n+#include \"runtime\/os.hpp\"\n@@ -59,0 +61,1 @@\n+#include \"utilities\/powerOfTwo.hpp\"\n@@ -87,3 +90,1 @@\n-intx   Arguments::_Tier3InvokeNotifyFreqLog     = Tier3InvokeNotifyFreqLog;\n-intx   Arguments::_Tier4InvocationThreshold     = Tier4InvocationThreshold;\n-size_t Arguments::_SharedBaseAddress            = SharedBaseAddress;\n+size_t Arguments::_default_SharedBaseAddress    = SharedBaseAddress;\n@@ -312,0 +313,2 @@\n+#define ENABLE_NATIVE_ACCESS \"enable.native.access\"\n+#define ENABLE_NATIVE_ACCESS_LEN 20\n@@ -350,1 +353,2 @@\n-        matches_property_suffix(property_suffix, UPGRADE_PATH, UPGRADE_PATH_LEN)) {\n+        matches_property_suffix(property_suffix, UPGRADE_PATH, UPGRADE_PATH_LEN) ||\n+        matches_property_suffix(property_suffix, ENABLE_NATIVE_ACCESS, ENABLE_NATIVE_ACCESS_LEN)) {\n@@ -523,3 +527,0 @@\n-  { \"UseMembar\",                    JDK_Version::jdk(10), JDK_Version::jdk(12), JDK_Version::undefined() },\n-  { \"AllowJNIEnvProxy\",             JDK_Version::jdk(13), JDK_Version::jdk(14), JDK_Version::jdk(15) },\n-  { \"ThreadLocalHandshakes\",        JDK_Version::jdk(13), JDK_Version::jdk(14), JDK_Version::jdk(15) },\n@@ -528,5 +529,12 @@\n-  { \"FieldsAllocationStyle\",        JDK_Version::jdk(14), JDK_Version::jdk(15), JDK_Version::jdk(16) },\n-  { \"CompactFields\",                JDK_Version::jdk(14), JDK_Version::jdk(15), JDK_Version::jdk(16) },\n-  { \"MonitorBound\",                 JDK_Version::jdk(14), JDK_Version::jdk(15), JDK_Version::jdk(16) },\n-  { \"G1RSetScanBlockSize\",          JDK_Version::jdk(14), JDK_Version::jdk(15), JDK_Version::jdk(16) },\n-  { \"UseParallelOldGC\",             JDK_Version::jdk(14), JDK_Version::jdk(15), JDK_Version::jdk(16) },\n+  { \"SuspendRetryCount\",            JDK_Version::undefined(), JDK_Version::jdk(17), JDK_Version::jdk(18) },\n+  { \"SuspendRetryDelay\",            JDK_Version::undefined(), JDK_Version::jdk(17), JDK_Version::jdk(18) },\n+  { \"CriticalJNINatives\",           JDK_Version::jdk(16), JDK_Version::jdk(18), JDK_Version::jdk(19) },\n+  { \"AlwaysLockClassLoader\",        JDK_Version::jdk(17), JDK_Version::jdk(18), JDK_Version::jdk(19) },\n+  { \"UseBiasedLocking\",             JDK_Version::jdk(15), JDK_Version::jdk(18), JDK_Version::jdk(19) },\n+  { \"BiasedLockingStartupDelay\",    JDK_Version::jdk(15), JDK_Version::jdk(18), JDK_Version::jdk(19) },\n+  { \"PrintBiasedLockingStatistics\", JDK_Version::jdk(15), JDK_Version::jdk(18), JDK_Version::jdk(19) },\n+  { \"BiasedLockingBulkRebiasThreshold\",    JDK_Version::jdk(15), JDK_Version::jdk(18), JDK_Version::jdk(19) },\n+  { \"BiasedLockingBulkRevokeThreshold\",    JDK_Version::jdk(15), JDK_Version::jdk(18), JDK_Version::jdk(19) },\n+  { \"BiasedLockingDecayTime\",              JDK_Version::jdk(15), JDK_Version::jdk(18), JDK_Version::jdk(19) },\n+  { \"UseOptoBiasInlining\",                 JDK_Version::jdk(15), JDK_Version::jdk(18), JDK_Version::jdk(19) },\n+  { \"PrintPreciseBiasedLockingStatistics\", JDK_Version::jdk(15), JDK_Version::jdk(18), JDK_Version::jdk(19) },\n@@ -540,88 +548,5 @@\n-  { \"PermSize\",                      JDK_Version::undefined(), JDK_Version::jdk(8),  JDK_Version::undefined() },\n-  { \"MaxPermSize\",                   JDK_Version::undefined(), JDK_Version::jdk(8),  JDK_Version::undefined() },\n-  { \"SharedReadWriteSize\",           JDK_Version::undefined(), JDK_Version::jdk(10), JDK_Version::undefined() },\n-  { \"SharedReadOnlySize\",            JDK_Version::undefined(), JDK_Version::jdk(10), JDK_Version::undefined() },\n-  { \"SharedMiscDataSize\",            JDK_Version::undefined(), JDK_Version::jdk(10), JDK_Version::undefined() },\n-  { \"SharedMiscCodeSize\",            JDK_Version::undefined(), JDK_Version::jdk(10), JDK_Version::undefined() },\n-  { \"CompilationPolicyChoice\",       JDK_Version::jdk(13),     JDK_Version::jdk(14), JDK_Version::jdk(15) },\n-  { \"TraceNMethodInstalls\",          JDK_Version::jdk(13),     JDK_Version::jdk(14), JDK_Version::jdk(15) },\n-  { \"FailOverToOldVerifier\",         JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(15) },\n-  { \"UseConcMarkSweepGC\",            JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(15) },\n-  { \"CMSAbortSemantics\",                       JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(15) },\n-  { \"CMSAbortablePrecleanMinWorkPerIteration\", JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(15) },\n-  { \"CMSBitMapYieldQuantum\",                   JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(15) },\n-  { \"CMSBootstrapOccupancy\",                   JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(15) },\n-  { \"CMSClassUnloadingEnabled\",                JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(15) },\n-  { \"CMSClassUnloadingMaxInterval\",            JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(15) },\n-  { \"CMSCleanOnEnter\",                         JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(15) },\n-  { \"CMSConcMarkMultiple\",                     JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(15) },\n-  { \"CMSConcurrentMTEnabled\",                  JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(15) },\n-  { \"CMSCoordinatorYieldSleepCount\",           JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(15) },\n-  { \"CMSEdenChunksRecordAlways\",               JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(15) },\n-  { \"CMSExpAvgFactor\",                         JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(15) },\n-  { \"CMSExtrapolateSweep\",                     JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(15) },\n-  { \"CMSIncrementalSafetyFactor\",              JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(15) },\n-  { \"CMSIndexedFreeListReplenish\",             JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(15) },\n-  { \"CMSInitiatingOccupancyFraction\",          JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(15) },\n-  { \"CMSIsTooFullPercentage\",                  JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(15) },\n-  { \"CMSLargeCoalSurplusPercent\",              JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(15) },\n-  { \"CMSLargeSplitSurplusPercent\",             JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(15) },\n-  { \"CMSLoopWarn\",                             JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(15) },\n-  { \"CMSMaxAbortablePrecleanLoops\",            JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(15) },\n-  { \"CMSMaxAbortablePrecleanTime\",             JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(15) },\n-  { \"CMSOldPLABMax\",                           JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(15) },\n-  { \"CMSOldPLABMin\",                           JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(15) },\n-  { \"CMSOldPLABNumRefills\",                    JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(15) },\n-  { \"CMSOldPLABReactivityFactor\",              JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(15) },\n-  { \"CMSOldPLABResizeQuicker\",                 JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(15) },\n-  { \"CMSOldPLABToleranceFactor\",               JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(15) },\n-  { \"CMSPLABRecordAlways\",                     JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(15) },\n-  { \"CMSParallelInitialMarkEnabled\",           JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(15) },\n-  { \"CMSParallelRemarkEnabled\",                JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(15) },\n-  { \"CMSParallelSurvivorRemarkEnabled\",        JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(15) },\n-  { \"CMSPrecleanDenominator\",                  JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(15) },\n-  { \"CMSPrecleanIter\",                         JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(15) },\n-  { \"CMSPrecleanNumerator\",                    JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(15) },\n-  { \"CMSPrecleanRefLists1\",                    JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(15) },\n-  { \"CMSPrecleanRefLists2\",                    JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(15) },\n-  { \"CMSPrecleanSurvivors1\",                   JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(15) },\n-  { \"CMSPrecleanSurvivors2\",                   JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(15) },\n-  { \"CMSPrecleanThreshold\",                    JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(15) },\n-  { \"CMSPrecleaningEnabled\",                   JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(15) },\n-  { \"CMSPrintChunksInDump\",                    JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(15) },\n-  { \"CMSPrintObjectsInDump\",                   JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(15) },\n-  { \"CMSRemarkVerifyVariant\",                  JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(15) },\n-  { \"CMSReplenishIntermediate\",                JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(15) },\n-  { \"CMSRescanMultiple\",                       JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(15) },\n-  { \"CMSSamplingGrain\",                        JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(15) },\n-  { \"CMSScavengeBeforeRemark\",                 JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(15) },\n-  { \"CMSScheduleRemarkEdenPenetration\",        JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(15) },\n-  { \"CMSScheduleRemarkEdenSizeThreshold\",      JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(15) },\n-  { \"CMSScheduleRemarkSamplingRatio\",          JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(15) },\n-  { \"CMSSmallCoalSurplusPercent\",              JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(15) },\n-  { \"CMSSmallSplitSurplusPercent\",             JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(15) },\n-  { \"CMSSplitIndexedFreeListBlocks\",           JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(15) },\n-  { \"CMSTriggerRatio\",                         JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(15) },\n-  { \"CMSWorkQueueDrainThreshold\",              JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(15) },\n-  { \"CMSYield\",                                JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(15) },\n-  { \"CMSYieldSleepCount\",                      JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(15) },\n-  { \"CMSYoungGenPerWorker\",                    JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(15) },\n-  { \"CMS_FLSPadding\",                          JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(15) },\n-  { \"CMS_FLSWeight\",                           JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(15) },\n-  { \"CMS_SweepPadding\",                        JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(15) },\n-  { \"CMS_SweepTimerThresholdMillis\",           JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(15) },\n-  { \"CMS_SweepWeight\",                         JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(15) },\n-  { \"FLSAlwaysCoalesceLarge\",                  JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(15) },\n-  { \"FLSCoalescePolicy\",                       JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(15) },\n-  { \"FLSLargestBlockCoalesceProximity\",        JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(15) },\n-  { \"OldPLABWeight\",                           JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(15) },\n-  { \"ParGCDesiredObjsFromOverflowList\",        JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(15) },\n-  { \"ParGCTrimOverflow\",                       JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(15) },\n-  { \"ParGCUseLocalOverflow\",                   JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(15) },\n-  { \"ResizeOldPLAB\",                           JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(15) },\n-  { \"UseCMSBestFit\",                           JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(15) },\n-  { \"UseCMSInitiatingOccupancyOnly\",           JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(15) },\n-  { \"GCLockerInvokesConcurrent\",     JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(15) },\n-  { \"BindGCTaskThreadsToCPUs\",       JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(16) },\n-  { \"UseGCTaskAffinity\",             JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(16) },\n-  { \"GCTaskTimeStampEntries\",        JDK_Version::undefined(), JDK_Version::jdk(14), JDK_Version::jdk(16) },\n+  { \"AssertOnSuspendWaitFailure\",   JDK_Version::undefined(), JDK_Version::jdk(17), JDK_Version::jdk(18) },\n+  { \"TraceSuspendWaitFailures\",     JDK_Version::undefined(), JDK_Version::jdk(17), JDK_Version::jdk(18) },\n+#ifdef ASSERT\n+  { \"DummyObsoleteTestFlag\",        JDK_Version::undefined(), JDK_Version::jdk(17), JDK_Version::undefined() },\n+#endif\n@@ -634,0 +559,1 @@\n+  { \"obs > exp\",                    JDK_Version::jdk(8), JDK_Version::undefined(), JDK_Version::jdk(10) },\n@@ -654,37 +580,0 @@\n-\/\/ NOTE: A compatibility request will be necessary for each alias to be removed.\n-static AliasedLoggingFlag const aliased_logging_flags[] = {\n-  { \"PrintCompressedOopsMode\",   LogLevel::Info,  true,  LOG_TAGS(gc, heap, coops) },\n-  { \"PrintSharedSpaces\",         LogLevel::Info,  true,  LOG_TAGS(cds) },\n-  { \"TraceBiasedLocking\",        LogLevel::Info,  true,  LOG_TAGS(biasedlocking) },\n-  { \"TraceClassLoading\",         LogLevel::Info,  true,  LOG_TAGS(class, load) },\n-  { \"TraceClassLoadingPreorder\", LogLevel::Debug, true,  LOG_TAGS(class, preorder) },\n-  { \"TraceClassPaths\",           LogLevel::Info,  true,  LOG_TAGS(class, path) },\n-  { \"TraceClassResolution\",      LogLevel::Debug, true,  LOG_TAGS(class, resolve) },\n-  { \"TraceClassUnloading\",       LogLevel::Info,  true,  LOG_TAGS(class, unload) },\n-  { \"TraceExceptions\",           LogLevel::Info,  true,  LOG_TAGS(exceptions) },\n-  { \"TraceLoaderConstraints\",    LogLevel::Info,  true,  LOG_TAGS(class, loader, constraints) },\n-  { \"TraceMonitorInflation\",     LogLevel::Trace, true,  LOG_TAGS(monitorinflation) },\n-  { \"TraceSafepointCleanupTime\", LogLevel::Info,  true,  LOG_TAGS(safepoint, cleanup) },\n-  { \"TraceJVMTIObjectTagging\",   LogLevel::Debug, true,  LOG_TAGS(jvmti, objecttagging) },\n-  { \"TraceRedefineClasses\",      LogLevel::Info,  false, LOG_TAGS(redefine, class) },\n-  { \"PrintJNIResolving\",         LogLevel::Debug, true,  LOG_TAGS(jni, resolve) },\n-  { NULL,                        LogLevel::Off,   false, LOG_TAGS(_NO_TAG) }\n-};\n-\n-#ifndef PRODUCT\n-\/\/ These options are removed in jdk9. Remove this code for jdk10.\n-static AliasedFlag const removed_develop_logging_flags[] = {\n-  { \"TraceClassInitialization\",   \"-Xlog:class+init\" },\n-  { \"TraceClassLoaderData\",       \"-Xlog:class+loader+data\" },\n-  { \"TraceDefaultMethods\",        \"-Xlog:defaultmethods=debug\" },\n-  { \"TraceItables\",               \"-Xlog:itables=debug\" },\n-  { \"TraceMonitorMismatch\",       \"-Xlog:monitormismatch=info\" },\n-  { \"TraceSafepoint\",             \"-Xlog:safepoint=debug\" },\n-  { \"TraceStartupTime\",           \"-Xlog:startuptime\" },\n-  { \"TraceVMOperation\",           \"-Xlog:vmoperation=debug\" },\n-  { \"PrintVtables\",               \"-Xlog:vtables=debug\" },\n-  { \"VerboseVerification\",        \"-Xlog:verification\" },\n-  { NULL, NULL }\n-};\n-#endif \/\/PRODUCT\n-\n@@ -718,0 +607,12 @@\n+        \/\/ This flag may have been marked for obsoletion in this version, but we may not\n+        \/\/ have actually removed it yet. Rather than ignoring it as soon as we reach\n+        \/\/ this version we allow some time for the removal to happen. So if the flag\n+        \/\/ still actually exists we process it as normal, but issue an adjusted warning.\n+        const JVMFlag *real_flag = JVMFlag::find_declared_flag(flag_name);\n+        if (real_flag != NULL) {\n+          char version_str[256];\n+          version->to_string(version_str, sizeof(version_str));\n+          warning(\"Temporarily processing option %s; support is scheduled for removal in %s\",\n+                  flag_name, version_str);\n+          return false;\n+        }\n@@ -742,12 +643,0 @@\n-#ifndef PRODUCT\n-const char* Arguments::removed_develop_logging_flag_name(const char* name){\n-  for (size_t i = 0; removed_develop_logging_flags[i].alias_name != NULL; i++) {\n-    const AliasedFlag& flag = removed_develop_logging_flags[i];\n-    if (strcmp(flag.alias_name, name) == 0) {\n-      return flag.real_name;\n-    }\n-  }\n-  return NULL;\n-}\n-#endif \/\/ PRODUCT\n-\n@@ -778,5 +667,16 @@\n-\/\/ is out of date, with respect to the current version, then a warning is issued\n-\/\/ but verification does not fail. This allows the VM to operate when the version\n-\/\/ is first updated, without needing to update all the impacted flags at the\n-\/\/ same time.\n-static bool verify_special_jvm_flags() {\n+\/\/ is out of date, with respect to the current version, then ideally a warning is\n+\/\/ issued but verification does not fail. This allows the VM to operate when the\n+\/\/ version is first updated, without needing to update all the impacted flags at\n+\/\/ the same time. In practice we can't issue the warning immediately when the version\n+\/\/ is updated as it occurs for every test and some tests are not prepared to handle\n+\/\/ unexpected output - see 8196739. Instead we only check if the table is up-to-date\n+\/\/ if the check_globals flag is true, and in addition allow a grace period and only\n+\/\/ check for stale flags when we hit build 25 (which is far enough into the 6 month\n+\/\/ release cycle that all flag updates should have been processed, whilst still\n+\/\/ leaving time to make the change before RDP2).\n+\/\/ We use a gtest to call this, passing true, so that we can detect stale flags before\n+\/\/ the end of the release cycle.\n+\n+static const int SPECIAL_FLAG_VALIDATION_BUILD = 25;\n+\n+bool Arguments::verify_special_jvm_flags(bool check_globals) {\n@@ -815,1 +715,2 @@\n-      if (!version_less_than(JDK_Version::current(), flag.obsolete_in)) {\n+      if (check_globals && VM_Version::vm_build_number() >= SPECIAL_FLAG_VALIDATION_BUILD &&\n+          !version_less_than(JDK_Version::current(), flag.obsolete_in)) {\n@@ -817,2 +718,2 @@\n-          \/\/ Temporarily disable the warning: 8196739\n-          \/\/ warning(\"Global variable for obsolete special flag entry \\\"%s\\\" should be removed\", flag.name);\n+          warning(\"Global variable for obsolete special flag entry \\\"%s\\\" should be removed\", flag.name);\n+          success = false;\n@@ -821,0 +722,4 @@\n+\n+    } else if (!flag.expired_in.is_undefined()) {\n+      warning(\"Special flag entry \\\"%s\\\" must be explicitly obsoleted before expired.\", flag.name);\n+      success = false;\n@@ -825,1 +730,2 @@\n-      if (!version_less_than(JDK_Version::current(), flag.expired_in)) {\n+      if (check_globals && VM_Version::vm_build_number() >= SPECIAL_FLAG_VALIDATION_BUILD &&\n+          !version_less_than(JDK_Version::current(), flag.expired_in)) {\n@@ -827,2 +733,2 @@\n-          \/\/ Temporarily disable the warning: 8196739\n-          \/\/ warning(\"Global variable for expired flag entry \\\"%s\\\" should be removed\", flag.name);\n+          warning(\"Global variable for expired flag entry \\\"%s\\\" should be removed\", flag.name);\n+          success = false;\n@@ -832,1 +738,0 @@\n-\n@@ -910,2 +815,2 @@\n-static bool set_bool_flag(JVMFlag* flag, bool value, JVMFlag::Flags origin) {\n-  if (JVMFlag::boolAtPut(flag, &value, origin) == JVMFlag::SUCCESS) {\n+static bool set_bool_flag(JVMFlag* flag, bool value, JVMFlagOrigin origin) {\n+  if (JVMFlagAccess::set_bool(flag, &value, origin) == JVMFlag::SUCCESS) {\n@@ -918,1 +823,1 @@\n-static bool set_fp_numeric_flag(JVMFlag* flag, char* value, JVMFlag::Flags origin) {\n+static bool set_fp_numeric_flag(JVMFlag* flag, char* value, JVMFlagOrigin origin) {\n@@ -926,1 +831,1 @@\n-  if (JVMFlag::doubleAtPut(flag, &v, origin) == JVMFlag::SUCCESS) {\n+  if (JVMFlagAccess::set_double(flag, &v, origin) == JVMFlag::SUCCESS) {\n@@ -932,1 +837,1 @@\n-static bool set_numeric_flag(JVMFlag* flag, char* value, JVMFlag::Flags origin) {\n+static bool set_numeric_flag(JVMFlag* flag, char* value, JVMFlagOrigin origin) {\n@@ -958,1 +863,1 @@\n-    return JVMFlag::intAtPut(flag, &int_v, origin) == JVMFlag::SUCCESS;\n+    return JVMFlagAccess::set_int(flag, &int_v, origin) == JVMFlag::SUCCESS;\n@@ -961,1 +866,1 @@\n-    return JVMFlag::uintAtPut(flag, &uint_v, origin) == JVMFlag::SUCCESS;\n+    return JVMFlagAccess::set_uint(flag, &uint_v, origin) == JVMFlag::SUCCESS;\n@@ -967,1 +872,1 @@\n-    return JVMFlag::intxAtPut(flag, &intx_v, origin) == JVMFlag::SUCCESS;\n+    return JVMFlagAccess::set_intx(flag, &intx_v, origin) == JVMFlag::SUCCESS;\n@@ -970,1 +875,1 @@\n-    return JVMFlag::uintxAtPut(flag, &uintx_v, origin) == JVMFlag::SUCCESS;\n+    return JVMFlagAccess::set_uintx(flag, &uintx_v, origin) == JVMFlag::SUCCESS;\n@@ -973,1 +878,1 @@\n-    return JVMFlag::uint64_tAtPut(flag, &uint64_t_v, origin) == JVMFlag::SUCCESS;\n+    return JVMFlagAccess::set_uint64_t(flag, &uint64_t_v, origin) == JVMFlag::SUCCESS;\n@@ -976,1 +881,1 @@\n-    return JVMFlag::size_tAtPut(flag, &size_t_v, origin) == JVMFlag::SUCCESS;\n+    return JVMFlagAccess::set_size_t(flag, &size_t_v, origin) == JVMFlag::SUCCESS;\n@@ -979,1 +884,1 @@\n-    return JVMFlag::doubleAtPut(flag, &double_v, origin) == JVMFlag::SUCCESS;\n+    return JVMFlagAccess::set_double(flag, &double_v, origin) == JVMFlag::SUCCESS;\n@@ -985,2 +890,2 @@\n-static bool set_string_flag(JVMFlag* flag, const char* value, JVMFlag::Flags origin) {\n-  if (JVMFlag::ccstrAtPut(flag, &value, origin) != JVMFlag::SUCCESS) return false;\n+static bool set_string_flag(JVMFlag* flag, const char* value, JVMFlagOrigin origin) {\n+  if (JVMFlagAccess::set_ccstr(flag, &value, origin) != JVMFlag::SUCCESS) return false;\n@@ -992,1 +897,1 @@\n-static bool append_to_string_flag(JVMFlag* flag, const char* new_value, JVMFlag::Flags origin) {\n+static bool append_to_string_flag(JVMFlag* flag, const char* new_value, JVMFlagOrigin origin) {\n@@ -994,1 +899,1 @@\n-  if (JVMFlag::ccstrAt(flag, &old_value) != JVMFlag::SUCCESS) return false;\n+  if (JVMFlagAccess::get_ccstr(flag, &old_value) != JVMFlag::SUCCESS) return false;\n@@ -1011,1 +916,1 @@\n-  (void) JVMFlag::ccstrAtPut(flag, &value, origin);\n+  (void) JVMFlagAccess::set_ccstr(flag, &value, origin);\n@@ -1023,2 +928,11 @@\n-    case -1:\n-      return NULL; \/\/ obsolete or expired, don't process normally\n+  case -1: {\n+      \/\/ Obsolete or expired, so don't process normally,\n+      \/\/ but allow for an obsolete flag we're still\n+      \/\/ temporarily allowing.\n+      if (!is_obsolete_flag(arg, &since)) {\n+        return real_name;\n+      }\n+      \/\/ Note if we're not considered obsolete then we can't be expired either\n+      \/\/ as obsoletion must come first.\n+      return NULL;\n+    }\n@@ -1046,39 +960,1 @@\n-void log_deprecated_flag(const char* name, bool on, AliasedLoggingFlag alf) {\n-  LogTagType tagSet[] = {alf.tag0, alf.tag1, alf.tag2, alf.tag3, alf.tag4, alf.tag5};\n-  \/\/ Set tagset string buffer at max size of 256, large enough for any alias tagset\n-  const int max_tagset_size = 256;\n-  int max_tagset_len = max_tagset_size - 1;\n-  char tagset_buffer[max_tagset_size];\n-  tagset_buffer[0] = '\\0';\n-\n-  \/\/ Write tag-set for aliased logging option, in string list form\n-  int max_tags = sizeof(tagSet)\/sizeof(tagSet[0]);\n-  for (int i = 0; i < max_tags && tagSet[i] != LogTag::__NO_TAG; i++) {\n-    if (i > 0) {\n-      strncat(tagset_buffer, \"+\", max_tagset_len - strlen(tagset_buffer));\n-    }\n-    strncat(tagset_buffer, LogTag::name(tagSet[i]), max_tagset_len - strlen(tagset_buffer));\n-  }\n-  if (!alf.exactMatch) {\n-      strncat(tagset_buffer, \"*\", max_tagset_len - strlen(tagset_buffer));\n-  }\n-  log_warning(arguments)(\"-XX:%s%s is deprecated. Will use -Xlog:%s=%s instead.\",\n-                         (on) ? \"+\" : \"-\",\n-                         name,\n-                         tagset_buffer,\n-                         (on) ? LogLevel::name(alf.level) : \"off\");\n-}\n-\n-AliasedLoggingFlag Arguments::catch_logging_aliases(const char* name, bool on){\n-  for (size_t i = 0; aliased_logging_flags[i].alias_name != NULL; i++) {\n-    const AliasedLoggingFlag& alf = aliased_logging_flags[i];\n-    if (strcmp(alf.alias_name, name) == 0) {\n-      log_deprecated_flag(name, on, alf);\n-      return alf;\n-    }\n-  }\n-  AliasedLoggingFlag a = {NULL, LogLevel::Off, false, LOG_TAGS(_NO_TAG)};\n-  return a;\n-}\n-\n-bool Arguments::parse_argument(const char* arg, JVMFlag::Flags origin) {\n+bool Arguments::parse_argument(const char* arg, JVMFlagOrigin origin) {\n@@ -1095,5 +971,0 @@\n-    AliasedLoggingFlag alf = catch_logging_aliases(name, false);\n-    if (alf.alias_name != NULL){\n-      LogConfiguration::configure_stdout(LogLevel::Off, alf.exactMatch, alf.tag0, alf.tag1, alf.tag2, alf.tag3, alf.tag4, alf.tag5);\n-      return true;\n-    }\n@@ -1108,5 +979,0 @@\n-    AliasedLoggingFlag alf = catch_logging_aliases(name, true);\n-    if (alf.alias_name != NULL){\n-      LogConfiguration::configure_stdout(alf.level, alf.exactMatch, alf.tag0, alf.tag1, alf.tag2, alf.tag3, alf.tag4, alf.tag5);\n-      return true;\n-    }\n@@ -1126,5 +992,0 @@\n-    AliasedLoggingFlag alf = catch_logging_aliases(name, true);\n-    if (alf.alias_name != NULL) {\n-      LogConfiguration::configure_stdout(alf.level, alf.exactMatch, alf.tag0, alf.tag1, alf.tag2, alf.tag3, alf.tag4, alf.tag5);\n-      return true;\n-    }\n@@ -1299,1 +1160,1 @@\n-                                 JVMFlag::Flags origin) {\n+                                 JVMFlagOrigin origin) {\n@@ -1329,11 +1190,0 @@\n-#ifndef PRODUCT\n-    else {\n-      const char* replacement;\n-      if ((replacement = removed_develop_logging_flag_name(stripped_argname)) != NULL){\n-        log_warning(arguments)(\"%s has been removed. Please use %s instead.\",\n-                               stripped_argname,\n-                               replacement);\n-        return false;\n-      }\n-    }\n-#endif \/\/PRODUCT\n@@ -1380,1 +1230,1 @@\n-                  fuzzy_matched->_name,\n+                  fuzzy_matched->name(),\n@@ -1428,1 +1278,1 @@\n-        result &= process_argument(token, ignore_unrecognized, JVMFlag::CONFIG_FILE);\n+        result &= process_argument(token, ignore_unrecognized, JVMFlagOrigin::CONFIG_FILE);\n@@ -1446,1 +1296,1 @@\n-    result &= process_argument(token, ignore_unrecognized, JVMFlag::CONFIG_FILE);\n+    result &= process_argument(token, ignore_unrecognized, JVMFlagOrigin::CONFIG_FILE);\n@@ -1480,0 +1330,14 @@\n+#if INCLUDE_CDS\n+  if (is_internal_module_property(key) ||\n+      strcmp(key, \"jdk.module.main\") == 0) {\n+    MetaspaceShared::disable_optimized_module_handling();\n+    log_info(cds)(\"optimized module handling: disabled due to incompatible property: %s=%s\", key, value);\n+  }\n+  if (strcmp(key, \"jdk.module.showModuleResolution\") == 0 ||\n+      strcmp(key, \"jdk.module.validation\") == 0 ||\n+      strcmp(key, \"java.system.class.loader\") == 0) {\n+    MetaspaceShared::disable_full_module_graph();\n+    log_info(cds)(\"full module graph: disabled due to incompatible property: %s=%s\", key, value);\n+  }\n+#endif\n+\n@@ -1603,8 +1467,0 @@\n-  if (TieredCompilation) {\n-    if (FLAG_IS_DEFAULT(Tier3InvokeNotifyFreqLog)) {\n-      Tier3InvokeNotifyFreqLog = Arguments::_Tier3InvokeNotifyFreqLog;\n-    }\n-    if (FLAG_IS_DEFAULT(Tier4InvocationThreshold)) {\n-      Tier4InvocationThreshold = Arguments::_Tier4InvocationThreshold;\n-    }\n-  }\n@@ -1630,7 +1486,0 @@\n-    \/\/ Be much more aggressive in tiered mode with -Xcomp and exercise C2 more.\n-    \/\/ We will first compile a level 3 version (C1 with full profiling), then do one invocation of it and\n-    \/\/ compile a level 4 (C2) and then continue executing it.\n-    if (TieredCompilation) {\n-      Tier3InvokeNotifyFreqLog = 0;\n-      Tier4InvocationThreshold = 0;\n-    }\n@@ -1668,4 +1517,0 @@\n-\n-  if (SurvivorAlignmentInBytes == 0) {\n-    SurvivorAlignmentInBytes = ObjectAlignmentInBytes;\n-  }\n@@ -1689,1 +1534,0 @@\n-#ifndef ZERO\n@@ -1704,1 +1548,3 @@\n-      FLAG_SET_DEFAULT(UseCompressedClassPointers, false);\n+      if (COMPRESSED_CLASS_POINTERS_DEPENDS_ON_COMPRESSED_OOPS) {\n+        FLAG_SET_DEFAULT(UseCompressedClassPointers, false);\n+      }\n@@ -1708,1 +1554,0 @@\n-#endif \/\/ ZERO\n@@ -1715,3 +1560,8 @@\n-#ifndef ZERO\n-  \/\/ UseCompressedOops must be on for UseCompressedClassPointers to be on.\n-  if (!UseCompressedOops) {\n+  \/\/ On some architectures, the use of UseCompressedClassPointers implies the use of\n+  \/\/ UseCompressedOops. The reason is that the rheap_base register of said platforms\n+  \/\/ is reused to perform some optimized spilling, in order to use rheap_base as a\n+  \/\/ temp register. But by treating it as any other temp register, spilling can typically\n+  \/\/ be completely avoided instead. So it is better not to perform this trick. And by\n+  \/\/ not having that reliance, large heaps, or heaps not supporting compressed oops,\n+  \/\/ can still use compressed class pointers.\n+  if (COMPRESSED_CLASS_POINTERS_DEPENDS_ON_COMPRESSED_OOPS && !UseCompressedOops) {\n@@ -1737,1 +1587,0 @@\n-#endif \/\/ !ZERO\n@@ -1756,1 +1605,0 @@\n-#ifndef ZERO\n@@ -1767,1 +1615,0 @@\n-#endif \/\/ !ZERO\n@@ -1772,3 +1619,3 @@\n-julong Arguments::limit_by_allocatable_memory(julong limit) {\n-  julong max_allocatable;\n-  julong result = limit;\n+size_t Arguments::limit_heap_by_allocatable_memory(size_t limit) {\n+  size_t max_allocatable;\n+  size_t result = limit;\n@@ -1776,1 +1623,8 @@\n-    result = MIN2(result, max_allocatable \/ MaxVirtMemFraction);\n+    \/\/ The AggressiveHeap check is a temporary workaround to avoid calling\n+    \/\/ GCarguments::heap_virtual_to_physical_ratio() before a GC has been\n+    \/\/ selected. This works because AggressiveHeap implies UseParallelGC\n+    \/\/ where we know the ratio will be 1. Once the AggressiveHeap option is\n+    \/\/ removed, this can be cleaned up.\n+    size_t heap_virtual_to_physical_ratio = (AggressiveHeap ? 1 : GCConfig::arguments()->heap_virtual_to_physical_ratio());\n+    size_t fraction = MaxVirtMemFraction * heap_virtual_to_physical_ratio;\n+    result = MIN2(result, max_allocatable \/ fraction);\n@@ -1847,4 +1701,1 @@\n-    if (UseCompressedOops) {\n-      \/\/ Limit the heap size to the maximum possible when using compressed oops\n-      julong max_coop_heap = (julong)max_heap_for_compressed_oops();\n-\n+    if (UseCompressedOops || UseCompressedClassPointers) {\n@@ -1863,0 +1714,4 @@\n+    }\n+    if (UseCompressedOops) {\n+      \/\/ Limit the heap size to the maximum possible when using compressed oops\n+      julong max_coop_heap = (julong)max_heap_for_compressed_oops();\n@@ -1881,1 +1736,3 @@\n-          FLAG_SET_ERGO(UseCompressedClassPointers, false);\n+          if (COMPRESSED_CLASS_POINTERS_DEPENDS_ON_COMPRESSED_OOPS) {\n+            FLAG_SET_ERGO(UseCompressedClassPointers, false);\n+          }\n@@ -1889,1 +1746,1 @@\n-    reasonable_max = limit_by_allocatable_memory(reasonable_max);\n+    reasonable_max = limit_heap_by_allocatable_memory(reasonable_max);\n@@ -1894,1 +1751,1 @@\n-      \/\/ after call to limit_by_allocatable_memory because that\n+      \/\/ after call to limit_heap_by_allocatable_memory because that\n@@ -1912,1 +1769,1 @@\n-    reasonable_minimum = limit_by_allocatable_memory(reasonable_minimum);\n+    reasonable_minimum = limit_heap_by_allocatable_memory(reasonable_minimum);\n@@ -1916,0 +1773,1 @@\n+      reasonable_initial = limit_heap_by_allocatable_memory(reasonable_initial);\n@@ -1920,2 +1778,0 @@\n-      reasonable_initial = limit_by_allocatable_memory(reasonable_initial);\n-\n@@ -1961,1 +1817,1 @@\n-  initHeapSize = limit_by_allocatable_memory(initHeapSize);\n+  initHeapSize = limit_heap_by_allocatable_memory(initHeapSize);\n@@ -2115,0 +1971,1 @@\n+unsigned int enable_native_access_count = 0;\n@@ -2148,1 +2005,1 @@\n-    if (!create_numbered_property(\"jdk.module.addmods\", \"jdk.internal.vm.ci\", addmods_count++)) {\n+    if (!create_numbered_module_property(\"jdk.module.addmods\", \"jdk.internal.vm.ci\", addmods_count++)) {\n@@ -2161,8 +2018,0 @@\n-  if (!FLAG_IS_DEFAULT(AllocateHeapAt)) {\n-    if ((UseNUMAInterleaving && !FLAG_IS_DEFAULT(UseNUMAInterleaving)) || (UseNUMA && !FLAG_IS_DEFAULT(UseNUMA))) {\n-      log_warning(arguments) (\"NUMA support for Heap depends on the file system when AllocateHeapAt option is used.\\n\");\n-    }\n-  }\n-\n-  status = status && GCArguments::check_args_consistency();\n-\n@@ -2218,1 +2067,2 @@\n-bool Arguments::create_property(const char* prop_name, const char* prop_value, PropertyInternal internal) {\n+bool Arguments::create_module_property(const char* prop_name, const char* prop_value, PropertyInternal internal) {\n+  assert(is_internal_module_property(prop_name), \"unknown module property: '%s'\", prop_name);\n@@ -2226,1 +2076,6 @@\n-  bool added = add_property(property, UnwriteableProperty, internal);\n+  \/\/ These are not strictly writeable properties as they cannot be set via -Dprop=val. But that\n+  \/\/ is enforced by checking is_internal_module_property(). We need the property to be writeable so\n+  \/\/ that multiple occurrences of the associated flag just causes the existing property value to be\n+  \/\/ replaced (\"last option wins\"). Otherwise we would need to keep track of the flags and only convert\n+  \/\/ to a property after we have finished flag processing.\n+  bool added = add_property(property, WriteableProperty, internal);\n@@ -2231,1 +2086,2 @@\n-bool Arguments::create_numbered_property(const char* prop_base_name, const char* prop_value, unsigned int count) {\n+bool Arguments::create_numbered_module_property(const char* prop_base_name, const char* prop_value, unsigned int count) {\n+  assert(is_internal_module_property(prop_base_name), \"unknown module property: '%s'\", prop_base_name);\n@@ -2276,6 +2132,2 @@\n-  if (TieredCompilation) {\n-    Arguments::_Tier3InvokeNotifyFreqLog = Tier3InvokeNotifyFreqLog;\n-    Arguments::_Tier4InvocationThreshold = Tier4InvocationThreshold;\n-  }\n-  \/\/ CDS dumping always write the archive to the default value of SharedBaseAddress.\n-  Arguments::_SharedBaseAddress = SharedBaseAddress;\n+  \/\/ Remember the default value of SharedBaseAddress.\n+  Arguments::_default_SharedBaseAddress = SharedBaseAddress;\n@@ -2288,1 +2140,1 @@\n-  jint result = parse_each_vm_init_arg(vm_options_args, &patch_mod_javabase, JVMFlag::JIMAGE_RESOURCE);\n+  jint result = parse_each_vm_init_arg(vm_options_args, &patch_mod_javabase, JVMFlagOrigin::JIMAGE_RESOURCE);\n@@ -2295,1 +2147,1 @@\n-  result = parse_each_vm_init_arg(java_tool_options_args, &patch_mod_javabase, JVMFlag::ENVIRON_VAR);\n+  result = parse_each_vm_init_arg(java_tool_options_args, &patch_mod_javabase, JVMFlagOrigin::ENVIRON_VAR);\n@@ -2301,1 +2153,1 @@\n-  result = parse_each_vm_init_arg(cmd_line_args, &patch_mod_javabase, JVMFlag::COMMAND_LINE);\n+  result = parse_each_vm_init_arg(cmd_line_args, &patch_mod_javabase, JVMFlagOrigin::COMMAND_LINE);\n@@ -2308,1 +2160,1 @@\n-  result = parse_each_vm_init_arg(java_options_args, &patch_mod_javabase, JVMFlag::ENVIRON_VAR);\n+  result = parse_each_vm_init_arg(java_options_args, &patch_mod_javabase, JVMFlagOrigin::ENVIRON_VAR);\n@@ -2393,1 +2245,1 @@\n-      if (!create_numbered_property(\"jdk.module.patch\", patch_mod_tail, patch_mod_count++)) {\n+      if (!create_numbered_module_property(\"jdk.module.patch\", patch_mod_tail, patch_mod_count++)) {\n@@ -2413,0 +2265,5 @@\n+  \/\/ Make sure the above values match the range set in globals.hpp\n+  const JVMTypedFlagLimit<intx>* limit = JVMFlagLimit::get_range_at(FLAG_MEMBER_ENUM(ThreadStackSize))->cast<intx>();\n+  assert(min_ThreadStackSize == static_cast<julong>(limit->min()), \"must be\");\n+  assert(max_ThreadStackSize == static_cast<julong>(limit->max()), \"must be\");\n+\n@@ -2452,1 +2309,1 @@\n-jint Arguments::parse_each_vm_init_arg(const JavaVMInitArgs* args, bool* patch_mod_javabase, JVMFlag::Flags origin) {\n+jint Arguments::parse_each_vm_init_arg(const JavaVMInitArgs* args, bool* patch_mod_javabase, JVMFlagOrigin origin) {\n@@ -2510,0 +2367,4 @@\n+#if INCLUDE_CDS\n+      MetaspaceShared::disable_optimized_module_handling();\n+      log_info(cds)(\"optimized module handling: disabled because bootclasspath was appended\");\n+#endif\n@@ -2538,1 +2399,1 @@\n-      if (!create_numbered_property(\"jdk.module.addreads\", tail, addreads_count++)) {\n+      if (!create_numbered_module_property(\"jdk.module.addreads\", tail, addreads_count++)) {\n@@ -2542,1 +2403,1 @@\n-      if (!create_numbered_property(\"jdk.module.addexports\", tail, addexports_count++)) {\n+      if (!create_numbered_module_property(\"jdk.module.addexports\", tail, addexports_count++)) {\n@@ -2546,1 +2407,1 @@\n-      if (!create_numbered_property(\"jdk.module.addopens\", tail, addopens_count++)) {\n+      if (!create_numbered_module_property(\"jdk.module.addopens\", tail, addopens_count++)) {\n@@ -2550,1 +2411,5 @@\n-      if (!create_numbered_property(\"jdk.module.addmods\", tail, addmods_count++)) {\n+      if (!create_numbered_module_property(\"jdk.module.addmods\", tail, addmods_count++)) {\n+        return JNI_ENOMEM;\n+      }\n+    } else if (match_option(option, \"--enable-native-access=\", &tail)) {\n+      if (!create_numbered_module_property(\"jdk.module.enable.native.access\", tail, enable_native_access_count++)) {\n@@ -2554,1 +2419,1 @@\n-      if (!create_property(\"jdk.module.limitmods\", tail, InternalProperty)) {\n+      if (!create_module_property(\"jdk.module.limitmods\", tail, InternalProperty)) {\n@@ -2558,1 +2423,1 @@\n-      if (!create_property(\"jdk.module.path\", tail, ExternalProperty)) {\n+      if (!create_module_property(\"jdk.module.path\", tail, ExternalProperty)) {\n@@ -2562,1 +2427,1 @@\n-      if (!create_property(\"jdk.module.upgrade.path\", tail, ExternalProperty)) {\n+      if (!create_module_property(\"jdk.module.upgrade.path\", tail, ExternalProperty)) {\n@@ -2572,3 +2437,3 @@\n-      if (!create_property(\"jdk.module.illegalAccess\", tail, ExternalProperty)) {\n-        return JNI_ENOMEM;\n-      }\n+      char version[256];\n+      JDK_Version::jdk(17).to_string(version, sizeof(version));\n+      warning(\"Ignoring option %s; support was removed in %s\", option->optionString, version);\n@@ -2616,1 +2481,1 @@\n-        if (!create_numbered_property(\"jdk.module.addmods\", \"java.instrument\", addmods_count++)) {\n+        if (!create_numbered_module_property(\"jdk.module.addmods\", \"java.instrument\", addmods_count++)) {\n@@ -2629,6 +2494,0 @@\n-    \/\/ -Xconcgc\n-    } else if (match_option(option, \"-Xconcgc\")) {\n-      warning(\"-Xconcgc uses UseConcMarkSweepGC; support was removed for both options in 14.0\");\n-    \/\/ -Xnoconcgc\n-    } else if (match_option(option, \"-Xnoconcgc\")) {\n-      warning(\"-Xnoconcgc uses UseConcMarkSweepGC; support was removed for both options in 14.0\");\n@@ -2803,1 +2662,1 @@\n-        if (!create_numbered_property(\"jdk.module.addmods\", \"jdk.management.agent\", addmods_count++)) {\n+        if (!create_numbered_module_property(\"jdk.module.addmods\", \"jdk.management.agent\", addmods_count++)) {\n@@ -2898,0 +2757,3 @@\n+      } else if (strcmp(tail, \":async\") == 0) {\n+        LogConfiguration::set_async_mode(true);\n+        ret = true;\n@@ -3048,0 +2910,4 @@\n+      \/\/ Just continue, since \"-XX:+EnableJVMCIProduct\" has been specified before\n+      if (EnableJVMCIProduct) {\n+        continue;\n+      }\n@@ -3114,1 +2980,1 @@\n-    _patch_mod_prefix = new (ResourceObj::C_HEAP, mtArguments) GrowableArray<ModulePatchPath*>(10, true);\n+    _patch_mod_prefix = new (ResourceObj::C_HEAP, mtArguments) GrowableArray<ModulePatchPath*>(10, mtArguments);\n@@ -3211,0 +3077,5 @@\n+#ifdef ZERO\n+  \/\/ Zero always runs in interpreted mode\n+  set_mode_flags(_int);\n+#endif\n+\n@@ -3227,1 +3098,0 @@\n-  NOT_PRODUCT(UNSUPPORTED_OPTION(TraceProfileInterpreter));\n@@ -3230,2 +3100,0 @@\n-\n-#ifdef TIERED\n@@ -3236,4 +3104,0 @@\n-#else\n-  \/\/ Tiered compilation is undefined.\n-  UNSUPPORTED_OPTION(TieredCompilation);\n-#endif\n@@ -3267,1 +3131,8 @@\n-  if (ArchiveClassesAtExit == NULL) {\n+\n+  \/\/ RecordDynamicDumpInfo is not compatible with ArchiveClassesAtExit\n+  if (ArchiveClassesAtExit != NULL && RecordDynamicDumpInfo) {\n+    log_info(cds)(\"RecordDynamicDumpInfo is for jcmd only, could not set with -XX:ArchiveClassesAtExit.\");\n+    return JNI_ERR;\n+  }\n+\n+  if (ArchiveClassesAtExit == NULL && !RecordDynamicDumpInfo) {\n@@ -3269,0 +3140,2 @@\n+  } else {\n+    FLAG_SET_DEFAULT(DynamicDumpSharedSpaces, true);\n@@ -3270,0 +3143,1 @@\n+\n@@ -3324,1 +3198,1 @@\n-  jint set_args(GrowableArray<JavaVMOption>* options) {\n+  jint set_args(const GrowableArrayView<JavaVMOption>* options) {\n@@ -3382,2 +3256,2 @@\n-    GrowableArray<JavaVMOption> *options = new (ResourceObj::C_HEAP, mtArguments)\n-              GrowableArray<JavaVMOption>(length, true);    \/\/ Construct new option array\n+    \/\/ Construct new option array\n+    GrowableArrayCHeap<JavaVMOption, mtArguments> options(length);\n@@ -3389,1 +3263,1 @@\n-          options->push(args_to_insert->options[j]);\n+          options.push(args_to_insert->options[j]);\n@@ -3392,1 +3266,1 @@\n-        options->push(args->options[i]);\n+        options.push(args->options[i]);\n@@ -3396,3 +3270,1 @@\n-    jint result = set_args(options);\n-    delete options;\n-    return result;\n+    return set_args(&options);\n@@ -3495,1 +3367,2 @@\n-  GrowableArray<JavaVMOption> *options = new (ResourceObj::C_HEAP, mtArguments) GrowableArray<JavaVMOption>(2, true);    \/\/ Construct option array\n+  \/\/ Construct option array\n+  GrowableArrayCHeap<JavaVMOption, mtArguments> options(2);\n@@ -3535,1 +3408,0 @@\n-          delete options;\n@@ -3551,1 +3423,1 @@\n-    options->append(option);                \/\/ Fill in option\n+    options.append(option);                \/\/ Fill in option\n@@ -3557,4 +3429,1 @@\n-  jint status = vm_args->set_args(options);\n-\n-  delete options;\n-  return status;\n+  return vm_args->set_args(&options);\n@@ -3563,1 +3432,1 @@\n-void Arguments::set_shared_spaces_flags() {\n+jint Arguments::set_shared_spaces_flags_and_archive_paths() {\n@@ -3569,10 +3438,8 @@\n-#ifdef _LP64\n-    if (!UseCompressedOops || !UseCompressedClassPointers) {\n-      vm_exit_during_initialization(\n-        \"Cannot dump shared archive when UseCompressedOops or UseCompressedClassPointers is off.\", NULL);\n-    }\n-  } else {\n-    if (!UseCompressedOops || !UseCompressedClassPointers) {\n-      no_shared_spaces(\"UseCompressedOops and UseCompressedClassPointers must be on for UseSharedSpaces.\");\n-    }\n-#endif\n+#if INCLUDE_CDS\n+  \/\/ Initialize shared archive paths which could include both base and dynamic archive paths\n+  \/\/ This must be after set_ergonomics_flags() called so flag UseCompressedOops is set properly.\n+  if (!init_shared_archive_paths()) {\n+    return JNI_ENOMEM;\n+  }\n+#endif  \/\/ INCLUDE_CDS\n+  return JNI_OK;\n@@ -3595,1 +3462,2 @@\n-  jio_snprintf(default_archive_path, len, \"%s%sclasses.jsa\",\n+  jio_snprintf(default_archive_path, len,\n+               LP64_ONLY(!UseCompressedOops ? \"%s%sclasses_nocoops.jsa\":) \"%s%sclasses.jsa\",\n@@ -3654,0 +3522,5 @@\n+  } else {\n+    if (SharedDynamicArchivePath != nullptr) {\n+      os::free(SharedDynamicArchivePath);\n+      SharedDynamicArchivePath = nullptr;\n+    }\n@@ -3915,0 +3788,20 @@\n+static void apply_debugger_ergo() {\n+  if (ReplayCompiles) {\n+    FLAG_SET_ERGO_IF_DEFAULT(UseDebuggerErgo, true);\n+  }\n+\n+  if (UseDebuggerErgo) {\n+    \/\/ Turn on sub-flags\n+    FLAG_SET_ERGO_IF_DEFAULT(UseDebuggerErgo1, true);\n+    FLAG_SET_ERGO_IF_DEFAULT(UseDebuggerErgo2, true);\n+  }\n+\n+  if (UseDebuggerErgo2) {\n+    \/\/ Debugging with limited number of CPUs\n+    FLAG_SET_ERGO_IF_DEFAULT(UseNUMA, false);\n+    FLAG_SET_ERGO_IF_DEFAULT(ConcGCThreads, 1);\n+    FLAG_SET_ERGO_IF_DEFAULT(ParallelGCThreads, 1);\n+    FLAG_SET_ERGO_IF_DEFAULT(CICompilerCount, 2);\n+  }\n+}\n+\n@@ -3918,6 +3811,2 @@\n-  assert(verify_special_jvm_flags(), \"deprecated and obsolete flag table inconsistent\");\n-\n-  \/\/ Initialize ranges, constraints and writeables\n-  JVMFlagRangeList::init();\n-  JVMFlagConstraintList::init();\n-  JVMFlagWriteableList::init();\n+  assert(verify_special_jvm_flags(false), \"deprecated and obsolete flag table inconsistent\");\n+  JVMFlag::check_all_flag_declarations();\n@@ -4041,7 +3930,0 @@\n-#if INCLUDE_CDS\n-  \/\/ Initialize shared archive paths which could include both base and dynamic archive paths\n-  if (!init_shared_archive_paths()) {\n-    return JNI_ENOMEM;\n-  }\n-#endif\n-\n@@ -4067,1 +3949,0 @@\n-  UNSUPPORTED_OPTION_NULL(AllocateOldGenAt);\n@@ -4116,3 +3997,4 @@\n-#ifndef TIERED\n-  if (FLAG_IS_CMDLINE(CompilationMode)) {\n-    warning(\"CompilationMode has no effect in non-tiered VMs\");\n+  if (TraceDependencies && VerifyDependencies) {\n+    if (!FLAG_IS_DEFAULT(TraceDependencies)) {\n+      warning(\"TraceDependencies results may be inflated by VerifyDependencies\");\n+    }\n@@ -4120,1 +4002,2 @@\n-#endif\n+\n+  apply_debugger_ergo();\n@@ -4135,1 +4018,2 @@\n-  set_shared_spaces_flags();\n+  result = set_shared_spaces_flags_and_archive_paths();\n+  if (result != JNI_OK) return result;\n@@ -4140,0 +4024,4 @@\n+  if (!StringDedup::ergo_initialize()) {\n+    return JNI_EINVAL;\n+  }\n+\n@@ -4173,1 +4061,1 @@\n-#ifdef CC_INTERP\n+#ifdef ZERO\n@@ -4177,3 +4065,1 @@\n-  LP64_ONLY(FLAG_SET_DEFAULT(UseCompressedOops, false));\n-  LP64_ONLY(FLAG_SET_DEFAULT(UseCompressedClassPointers, false));\n-#endif \/\/ CC_INTERP\n+#endif \/\/ ZERO\n@@ -4220,1 +4106,27 @@\n-#endif\n+  if (!FLAG_IS_DEFAULT(EnableVectorSupport) && !EnableVectorSupport) {\n+    if (!FLAG_IS_DEFAULT(EnableVectorReboxing) && EnableVectorReboxing) {\n+      warning(\"Disabling EnableVectorReboxing since EnableVectorSupport is turned off.\");\n+    }\n+    FLAG_SET_DEFAULT(EnableVectorReboxing, false);\n+\n+    if (!FLAG_IS_DEFAULT(EnableVectorAggressiveReboxing) && EnableVectorAggressiveReboxing) {\n+      if (!EnableVectorReboxing) {\n+        warning(\"Disabling EnableVectorAggressiveReboxing since EnableVectorReboxing is turned off.\");\n+      } else {\n+        warning(\"Disabling EnableVectorAggressiveReboxing since EnableVectorSupport is turned off.\");\n+      }\n+    }\n+    FLAG_SET_DEFAULT(EnableVectorAggressiveReboxing, false);\n+\n+    if (!FLAG_IS_DEFAULT(UseVectorStubs) && UseVectorStubs) {\n+      warning(\"Disabling UseVectorStubs since EnableVectorSupport is turned off.\");\n+    }\n+    FLAG_SET_DEFAULT(UseVectorStubs, false);\n+  }\n+#endif \/\/ COMPILER2\n+\n+  if (FLAG_IS_CMDLINE(DiagnoseSyncOnValueBasedClasses)) {\n+    if (DiagnoseSyncOnValueBasedClasses == ObjectSynchronizer::LOG_WARNING && !log_is_enabled(Info, valuebasedclasses)) {\n+      LogConfiguration::configure_stdout(LogLevel::Info, true, LOG_TAGS(valuebasedclasses));\n+    }\n+  }\n@@ -4227,3 +4139,1 @@\n-    if (!FLAG_IS_DEFAULT(AllocateHeapAt)) {\n-      FLAG_SET_ERGO(UseNUMA, false);\n-    } else if (UseParallelGC || UseParallelOldGC) {\n+    if (UseParallelGC) {\n@@ -4234,8 +4144,0 @@\n-    \/\/ UseNUMAInterleaving is set to ON for all collectors and platforms when\n-    \/\/ UseNUMA is set to ON. NUMA-aware collectors will interleave old gen and\n-    \/\/ survivor spaces on top of NUMA allocation policy for the eden space.\n-    \/\/ Non NUMA-aware collectors will interleave all of the heap spaces across\n-    \/\/ NUMA nodes.\n-    if (FLAG_IS_DEFAULT(UseNUMAInterleaving)) {\n-      FLAG_SET_ERGO(UseNUMAInterleaving, true);\n-    }\n@@ -4361,1 +4263,2 @@\n-  \/\/ If property key exist then update with new value.\n+  \/\/ If property key exists and is writeable, then update with new value.\n+  \/\/ Trying to update a non-writeable property is silently ignored.\n@@ -4366,1 +4269,1 @@\n-        prop->append_value(v);\n+        prop->append_writeable_value(v);\n@@ -4368,1 +4271,1 @@\n-        prop->set_value(v);\n+        prop->set_writeable_value(v);\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":318,"deletions":415,"binary":false,"changes":733,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,1 @@\n-#include \"compiler\/compiler_globals.hpp\"\n-#include \"gc\/shared\/gc_globals.hpp\"\n+#include \"compiler\/compiler_globals_pd.hpp\"\n@@ -41,0 +40,10 @@\n+\/\/ develop_pd\/product_pd flags are the same as develop\/product, except that their default values\n+\/\/ are specified in platform-dependent header files.\n+\n+\/\/ Flags must be declared with the following number of parameters:\n+\/\/ non-pd flags:\n+\/\/    (type, name, default_value, doc), or\n+\/\/    (type, name, default_value, extra_attrs, doc)\n+\/\/ pd flags:\n+\/\/    (type, name, doc), or\n+\/\/    (type, name, extra_attrs, doc)\n@@ -47,9 +56,13 @@\n-\/\/ Note: Diagnostic options not meant for VM tuning or for product modes.\n-\/\/ They are to be used for VM quality assurance or field diagnosis\n-\/\/ of VM bugs.  They are hidden so that users will not be encouraged to\n-\/\/ try them as if they were VM ordinary execution options.  However, they\n-\/\/ are available in the product version of the VM.  Under instruction\n-\/\/ from support engineers, VM customers can turn them on to collect\n-\/\/ diagnostic information about VM problems.  To use a VM diagnostic\n-\/\/ option, you must first specify +UnlockDiagnosticVMOptions.\n-\/\/ (This master switch also affects the behavior of -Xprintflags.)\n+\/\/ The optional extra_attrs parameter may have one of the following values:\n+\/\/ DIAGNOSTIC, EXPERIMENTAL, or MANAGEABLE. Currently extra_attrs can be used\n+\/\/ only with product\/product_pd flags.\n+\/\/\n+\/\/ DIAGNOSTIC options are not meant for VM tuning or for product modes.\n+\/\/    They are to be used for VM quality assurance or field diagnosis\n+\/\/    of VM bugs.  They are hidden so that users will not be encouraged to\n+\/\/    try them as if they were VM ordinary execution options.  However, they\n+\/\/    are available in the product version of the VM.  Under instruction\n+\/\/    from support engineers, VM customers can turn them on to collect\n+\/\/    diagnostic information about VM problems.  To use a VM diagnostic\n+\/\/    option, you must first specify +UnlockDiagnosticVMOptions.\n+\/\/    (This master switch also affects the behavior of -Xprintflags.)\n@@ -57,1 +70,1 @@\n-\/\/ experimental flags are in support of features that are not\n+\/\/ EXPERIMENTAL flags are in support of features that are not\n@@ -73,1 +86,1 @@\n-\/\/ manageable flags are writeable external product flags.\n+\/\/ MANAGEABLE flags are writeable external product flags.\n@@ -87,14 +100,1 @@\n-\/\/ product_rw flags are writeable internal product flags.\n-\/\/    They are like \"manageable\" flags but for internal\/private use.\n-\/\/    The list of product_rw flags are internal\/private flags which\n-\/\/    may be changed\/removed in a future release.  It can be set\n-\/\/    through the management interface to get\/set value\n-\/\/    when the name of flag is supplied.\n-\/\/\n-\/\/    A flag can be made as \"product_rw\" only if\n-\/\/    - the VM implementation supports dynamic setting of the flag.\n-\/\/      This implies that the VM must *always* query the flag variable\n-\/\/      and not reuse state related to the flag state at any given time.\n-\/\/\n-\/\/ Note that when there is a need to support develop flags to be writeable,\n-\/\/ it can be done in the same way as product_rw.\n+\n@@ -103,1 +103,1 @@\n-\/\/    checking code if provided - see jvmFlagRangeList.hpp\n+\/\/    checking code if provided - see jvmFlagLimit.hpp\n@@ -106,12 +106,1 @@\n-\/\/    for constraint checking if provided - see jvmFlagConstraintList.hpp\n-\/\/\n-\/\/ writeable is a macro that controls if and how the value can change during the runtime\n-\/\/\n-\/\/ writeable(Always) is optional and allows the flag to have its value changed\n-\/\/    without any limitations at any time\n-\/\/\n-\/\/ writeable(Once) flag value's can be only set once during the lifetime of VM\n-\/\/\n-\/\/ writeable(CommandLineOnly) flag value's can be only set from command line\n-\/\/    (multiple times allowed)\n-\/\/\n+\/\/    for constraint checking if provided - see jvmFlagLimit.hpp\n@@ -126,16 +115,10 @@\n-#define RUNTIME_FLAGS(develop, \\\n-                      develop_pd, \\\n-                      product, \\\n-                      product_pd, \\\n-                      diagnostic, \\\n-                      diagnostic_pd, \\\n-                      experimental, \\\n-                      notproduct, \\\n-                      manageable, \\\n-                      product_rw, \\\n-                      lp64_product, \\\n-                      range, \\\n-                      constraint, \\\n-                      writeable) \\\n-                                                                            \\\n-  lp64_product(bool, UseCompressedOops, false,                              \\\n+#ifdef _LP64\n+#define LP64_RUNTIME_FLAGS(develop,                                         \\\n+                           develop_pd,                                      \\\n+                           product,                                         \\\n+                           product_pd,                                      \\\n+                           notproduct,                                      \\\n+                           range,                                           \\\n+                           constraint)                                      \\\n+                                                                            \\\n+  product(bool, UseCompressedOops, false,                                   \\\n@@ -145,1 +128,1 @@\n-  lp64_product(bool, UseCompressedClassPointers, false,                     \\\n+  product(bool, UseCompressedClassPointers, false,                          \\\n@@ -149,0 +132,29 @@\n+  product(intx, ObjectAlignmentInBytes, 8,                                  \\\n+          \"Default object alignment in bytes, 8 is minimum\")                \\\n+          range(8, 256)                                                     \\\n+          constraint(ObjectAlignmentInBytesConstraintFunc, AtParse)\n+\n+#else\n+\/\/ !_LP64\n+\n+#define LP64_RUNTIME_FLAGS(develop,                                         \\\n+                           develop_pd,                                      \\\n+                           product,                                         \\\n+                           product_pd,                                      \\\n+                           notproduct,                                      \\\n+                           range,                                           \\\n+                           constraint)\n+const bool UseCompressedOops = false;\n+const bool UseCompressedClassPointers = false;\n+const intx ObjectAlignmentInBytes = 8;\n+\n+#endif \/\/ _LP64\n+\n+#define RUNTIME_FLAGS(develop,                                              \\\n+                      develop_pd,                                           \\\n+                      product,                                              \\\n+                      product_pd,                                           \\\n+                      notproduct,                                           \\\n+                      range,                                                \\\n+                      constraint)                                           \\\n+                                                                            \\\n@@ -158,9 +170,1 @@\n-  lp64_product(intx, ObjectAlignmentInBytes, 8,                             \\\n-          \"Default object alignment in bytes, 8 is minimum\")                \\\n-          range(8, 256)                                                     \\\n-          constraint(ObjectAlignmentInBytesConstraintFunc,AtParse)          \\\n-                                                                            \\\n-  develop(bool, CleanChunkPoolAsync, true,                                  \\\n-          \"Clean the chunk pool asynchronously\")                            \\\n-                                                                            \\\n-  diagnostic(uint, HandshakeTimeout, 0,                                     \\\n+  product(uint, HandshakeTimeout, 0, DIAGNOSTIC,                            \\\n@@ -169,1 +173,1 @@\n-  experimental(bool, AlwaysSafeConstructors, false,                         \\\n+  product(bool, AlwaysSafeConstructors, false, EXPERIMENTAL,                \\\n@@ -172,1 +176,1 @@\n-  diagnostic(bool, UnlockDiagnosticVMOptions, trueInDebug,                  \\\n+  product(bool, UnlockDiagnosticVMOptions, trueInDebug, DIAGNOSTIC,         \\\n@@ -175,1 +179,1 @@\n-  experimental(bool, UnlockExperimentalVMOptions, false,                    \\\n+  product(bool, UnlockExperimentalVMOptions, false, EXPERIMENTAL,           \\\n@@ -180,1 +184,1 @@\n-          \"Print information about Java monitor locks when the stacks are\"  \\\n+          \"Print information about Java monitor locks when the stacks are \" \\\n@@ -192,4 +196,0 @@\n-  product(bool, UseLargePagesInMetaspace, false,                            \\\n-          \"Use large page memory in metaspace. \"                            \\\n-          \"Only used if UseLargePages is enabled.\")                         \\\n-                                                                            \\\n@@ -204,4 +204,1 @@\n-          range(os::vm_allocation_granularity(), NOT_LP64(2*G) LP64_ONLY(8192*G)) \\\n-                                                                            \\\n-  product(bool, ForceNUMA, false,                                           \\\n-          \"Force NUMA optimizations on single-node\/UMA systems\")            \\\n+          constraint(NUMAInterleaveGranularityConstraintFunc, AtParse)      \\\n@@ -229,4 +226,0 @@\n-  product(intx, UseSSE, 99,                                                 \\\n-          \"Highest supported SSE instructions set on x86\/x64\")              \\\n-          range(0, 99)                                                      \\\n-                                                                            \\\n@@ -242,1 +235,1 @@\n-  diagnostic(bool, UseGHASHIntrinsics, false,                               \\\n+  product(bool, UseGHASHIntrinsics, false, DIAGNOSTIC,                      \\\n@@ -249,1 +242,2 @@\n-          \"Large page size (0 to let VM choose the page size)\")             \\\n+          \"Maximum large page size used (0 will use the default large \"     \\\n+          \"page size for the environment as the maximum)\")                  \\\n@@ -265,4 +259,1 @@\n-  develop(bool, TraceLongCompiles, false,                                   \\\n-          \"Print out every time compilation is longer than \"                \\\n-          \"a given threshold\")                                              \\\n-  diagnostic(bool, SafepointALot, false,                                    \\\n+  product(bool, SafepointALot, false, DIAGNOSTIC,                           \\\n@@ -273,1 +264,1 @@\n-  diagnostic(bool, HandshakeALot, false,                                    \\\n+  product(bool, HandshakeALot, false, DIAGNOSTIC,                           \\\n@@ -281,3 +272,0 @@\n-  product(bool, PrintVMQWaitTime, false,                                    \\\n-          \"Print out the waiting time in VM operation queue\")               \\\n-                                                                            \\\n@@ -290,1 +278,1 @@\n-  diagnostic(bool, ForceUnreachable, false,                                 \\\n+  product(bool, ForceUnreachable, false, DIAGNOSTIC,                        \\\n@@ -294,4 +282,0 @@\n-  notproduct(bool, StressDerivedPointers, false,                            \\\n-          \"Force scavenge when a derived pointer is detected on stack \"     \\\n-          \"after rtm call\")                                                 \\\n-                                                                            \\\n@@ -310,1 +294,1 @@\n-  diagnostic(bool, InlineArrayCopy, true,                                   \\\n+  product(bool, InlineArrayCopy, true, DIAGNOSTIC,                          \\\n@@ -314,1 +298,1 @@\n-  diagnostic(bool, InlineObjectHash, true,                                  \\\n+  product(bool, InlineObjectHash, true, DIAGNOSTIC,                         \\\n@@ -318,1 +302,1 @@\n-  diagnostic(bool, InlineNatives, true,                                     \\\n+  product(bool, InlineNatives, true, DIAGNOSTIC,                            \\\n@@ -321,1 +305,1 @@\n-  diagnostic(bool, InlineMathNatives, true,                                 \\\n+  product(bool, InlineMathNatives, true, DIAGNOSTIC,                        \\\n@@ -324,1 +308,1 @@\n-  diagnostic(bool, InlineClassNatives, true,                                \\\n+  product(bool, InlineClassNatives, true, DIAGNOSTIC,                       \\\n@@ -327,1 +311,1 @@\n-  diagnostic(bool, InlineThreadNatives, true,                               \\\n+  product(bool, InlineThreadNatives, true, DIAGNOSTIC,                      \\\n@@ -330,1 +314,1 @@\n-  diagnostic(bool, InlineUnsafeOps, true,                                   \\\n+  product(bool, InlineUnsafeOps, true, DIAGNOSTIC,                          \\\n@@ -333,2 +317,2 @@\n-  product(bool, CriticalJNINatives, true,                                   \\\n-          \"Check for critical JNI entry points\")                            \\\n+  product(bool, CriticalJNINatives, false,                                  \\\n+          \"(Deprecated) Check for critical JNI entry points\")               \\\n@@ -336,4 +320,1 @@\n-  notproduct(bool, StressCriticalJNINatives, false,                         \\\n-          \"Exercise register saving code in critical natives\")              \\\n-                                                                            \\\n-  diagnostic(bool, UseAESIntrinsics, false,                                 \\\n+  product(bool, UseAESIntrinsics, false, DIAGNOSTIC,                        \\\n@@ -342,1 +323,1 @@\n-  diagnostic(bool, UseAESCTRIntrinsics, false,                              \\\n+  product(bool, UseAESCTRIntrinsics, false, DIAGNOSTIC,                     \\\n@@ -345,1 +326,4 @@\n-  diagnostic(bool, UseSHA1Intrinsics, false,                                \\\n+  product(bool, UseMD5Intrinsics, false, DIAGNOSTIC,                        \\\n+          \"Use intrinsics for MD5 crypto hash function\")                    \\\n+                                                                            \\\n+  product(bool, UseSHA1Intrinsics, false, DIAGNOSTIC,                       \\\n@@ -349,1 +333,1 @@\n-  diagnostic(bool, UseSHA256Intrinsics, false,                              \\\n+  product(bool, UseSHA256Intrinsics, false, DIAGNOSTIC,                     \\\n@@ -353,1 +337,1 @@\n-  diagnostic(bool, UseSHA512Intrinsics, false,                              \\\n+  product(bool, UseSHA512Intrinsics, false, DIAGNOSTIC,                     \\\n@@ -357,1 +341,5 @@\n-  diagnostic(bool, UseCRC32Intrinsics, false,                               \\\n+  product(bool, UseSHA3Intrinsics, false, DIAGNOSTIC,                       \\\n+          \"Use intrinsics for SHA3 crypto hash function. \"                  \\\n+          \"Requires that UseSHA is enabled.\")                               \\\n+                                                                            \\\n+  product(bool, UseCRC32Intrinsics, false, DIAGNOSTIC,                      \\\n@@ -360,1 +348,1 @@\n-  diagnostic(bool, UseCRC32CIntrinsics, false,                              \\\n+  product(bool, UseCRC32CIntrinsics, false, DIAGNOSTIC,                     \\\n@@ -363,1 +351,1 @@\n-  diagnostic(bool, UseAdler32Intrinsics, false,                             \\\n+  product(bool, UseAdler32Intrinsics, false, DIAGNOSTIC,                    \\\n@@ -366,1 +354,1 @@\n-  diagnostic(bool, UseVectorizedMismatchIntrinsic, false,                   \\\n+  product(bool, UseVectorizedMismatchIntrinsic, false, DIAGNOSTIC,          \\\n@@ -369,1 +357,7 @@\n-  diagnostic(ccstrlist, DisableIntrinsic, \"\",                               \\\n+  product(bool, UseCopySignIntrinsic, false, DIAGNOSTIC,                    \\\n+          \"Enables intrinsification of Math.copySign\")                      \\\n+                                                                            \\\n+  product(bool, UseSignumIntrinsic, false, DIAGNOSTIC,                      \\\n+          \"Enables intrinsification of Math.signum\")                        \\\n+                                                                            \\\n+  product(ccstrlist, DisableIntrinsic, \"\", DIAGNOSTIC,                      \\\n@@ -371,0 +365,6 @@\n+         constraint(DisableIntrinsicConstraintFunc,AfterErgo)               \\\n+                                                                            \\\n+  product(ccstrlist, ControlIntrinsic, \"\", DIAGNOSTIC,                      \\\n+         \"Control intrinsics using a list of +\/- (internal) names, \"        \\\n+         \"separated by commas\")                                             \\\n+         constraint(ControlIntrinsicConstraintFunc,AfterErgo)               \\\n@@ -390,3 +390,22 @@\n-  product(bool, Debugging, false,                                           \\\n-          \"Set when executing debug methods in debug.cpp \"                  \\\n-          \"(to prevent triggering assertions)\")                             \\\n+  develop(bool, DeoptimizeObjectsALot, false,                               \\\n+          \"For testing purposes concurrent threads revert optimizations \"   \\\n+          \"based on escape analysis at intervals given with \"               \\\n+          \"DeoptimizeObjectsALotInterval=n. The thread count is given \"     \\\n+          \"with DeoptimizeObjectsALotThreadCountSingle and \"                \\\n+          \"DeoptimizeObjectsALotThreadCountAll.\")                           \\\n+                                                                            \\\n+  develop(uint64_t, DeoptimizeObjectsALotInterval, 5,                       \\\n+          \"Interval for DeoptimizeObjectsALot.\")                            \\\n+          range(0, max_jlong)                                               \\\n+                                                                            \\\n+  develop(int, DeoptimizeObjectsALotThreadCountSingle, 1,                   \\\n+          \"The number of threads that revert optimizations based on \"       \\\n+          \"escape analysis for a single thread if DeoptimizeObjectsALot \"   \\\n+          \"is enabled. The target thread is selected round robin.\" )        \\\n+          range(0, max_jint)                                                \\\n+                                                                            \\\n+  develop(int, DeoptimizeObjectsALotThreadCountAll, 1,                      \\\n+          \"The number of threads that revert optimizations based on \"       \\\n+          \"escape analysis for all threads if DeoptimizeObjectsALot \"       \\\n+          \"is enabled.\" )                                                   \\\n+          range(0, max_jint)                                                \\\n@@ -401,1 +420,1 @@\n-  diagnostic(bool, AbortVMOnSafepointTimeout, false,                        \\\n+  product(bool, AbortVMOnSafepointTimeout, false, DIAGNOSTIC,               \\\n@@ -404,1 +423,1 @@\n-  diagnostic(bool, AbortVMOnVMOperationTimeout, false,                      \\\n+  product(bool, AbortVMOnVMOperationTimeout, false, DIAGNOSTIC,             \\\n@@ -407,1 +426,1 @@\n-  diagnostic(intx, AbortVMOnVMOperationTimeoutDelay, 1000,                  \\\n+  product(intx, AbortVMOnVMOperationTimeoutDelay, 1000, DIAGNOSTIC,         \\\n@@ -411,17 +430,1 @@\n-  \/* 50 retries * (5 * current_retry_count) millis = ~6.375 seconds *\/      \\\n-  \/* typically, at most a few retries are needed                    *\/      \\\n-  product(intx, SuspendRetryCount, 50,                                      \\\n-          \"Maximum retry count for an external suspend request\")            \\\n-          range(0, max_intx)                                                \\\n-                                                                            \\\n-  product(intx, SuspendRetryDelay, 5,                                       \\\n-          \"Milliseconds to delay per retry (* current_retry_count)\")        \\\n-          range(0, max_intx)                                                \\\n-                                                                            \\\n-  product(bool, AssertOnSuspendWaitFailure, false,                          \\\n-          \"Assert\/Guarantee on external suspend wait failure\")              \\\n-                                                                            \\\n-  product(bool, TraceSuspendWaitFailures, false,                            \\\n-          \"Trace external suspend wait failures\")                           \\\n-                                                                            \\\n-          \"Bump the number of file descriptors to maximum in Solaris\")      \\\n+          \"Bump the number of file descriptors to maximum (Unix only)\")     \\\n@@ -430,1 +433,1 @@\n-  diagnostic(bool, LogEvents, true,                                         \\\n+  product(bool, LogEvents, true, DIAGNOSTIC,                                \\\n@@ -433,1 +436,1 @@\n-  diagnostic(uintx, LogEventsBufferEntries, 20,                             \\\n+  product(uintx, LogEventsBufferEntries, 20, DIAGNOSTIC,                    \\\n@@ -437,1 +440,1 @@\n-  diagnostic(bool, BytecodeVerificationRemote, true,                        \\\n+  product(bool, BytecodeVerificationRemote, true, DIAGNOSTIC,               \\\n@@ -440,1 +443,1 @@\n-  diagnostic(bool, BytecodeVerificationLocal, false,                        \\\n+  product(bool, BytecodeVerificationLocal, false, DIAGNOSTIC,               \\\n@@ -443,3 +446,0 @@\n-  develop(bool, ForceFloatExceptions, trueInDebug,                          \\\n-          \"Force exceptions on FP stack under\/overflow\")                    \\\n-                                                                            \\\n@@ -476,2 +476,2 @@\n-  develop(bool, PrintVMMessages, true,                                      \\\n-          \"Print VM messages on console\")                                   \\\n+  product(bool, ExecutingUnitTests, false,                                  \\\n+          \"Whether the JVM is running unit tests or not\")                   \\\n@@ -479,1 +479,1 @@\n-  notproduct(uintx, ErrorHandlerTest, 0,                                    \\\n+  develop(uintx, ErrorHandlerTest, 0,                                       \\\n@@ -481,1 +481,1 @@\n-          \"determines which error to provoke. See test_error_handler() \"    \\\n+          \"determines which error to provoke. See controlled_crash() \"      \\\n@@ -483,0 +483,1 @@\n+          range(0, 17)                                                      \\\n@@ -484,1 +485,1 @@\n-  notproduct(uintx, TestCrashInErrorHandler, 0,                             \\\n+  develop(uintx, TestCrashInErrorHandler, 0,                                \\\n@@ -486,1 +487,2 @@\n-          \"crash). see test_error_handler() in vmError.cpp\")                \\\n+          \"crash). see controlled_crash() in vmError.cpp\")                  \\\n+          range(0, 17)                                                      \\\n@@ -488,1 +490,1 @@\n-  notproduct(bool, TestSafeFetchInErrorHandler, false,                      \\\n+  develop(bool, TestSafeFetchInErrorHandler, false   ,                      \\\n@@ -491,1 +493,1 @@\n-  notproduct(bool, TestUnresponsiveErrorHandler, false,                     \\\n+  develop(bool, TestUnresponsiveErrorHandler, false,                        \\\n@@ -514,3 +516,0 @@\n-  product_pd(bool, UseOSErrorReporting,                                     \\\n-          \"Let VM fatal error propagate to the OS (ie. WER on Windows)\")    \\\n-                                                                            \\\n@@ -525,1 +524,2 @@\n-          \"Run user-defined commands on first java.lang.OutOfMemoryError\")  \\\n+          \"Run user-defined commands on first java.lang.OutOfMemoryError \"  \\\n+          \"thrown from JVM\")                                                \\\n@@ -527,1 +527,1 @@\n-  manageable(bool, HeapDumpBeforeFullGC, false,                             \\\n+  product(bool, HeapDumpBeforeFullGC, false, MANAGEABLE,                    \\\n@@ -530,1 +530,1 @@\n-  manageable(bool, HeapDumpAfterFullGC, false,                              \\\n+  product(bool, HeapDumpAfterFullGC, false, MANAGEABLE,                     \\\n@@ -533,2 +533,3 @@\n-  manageable(bool, HeapDumpOnOutOfMemoryError, false,                       \\\n-          \"Dump heap to file when java.lang.OutOfMemoryError is thrown\")    \\\n+  product(bool, HeapDumpOnOutOfMemoryError, false, MANAGEABLE,              \\\n+          \"Dump heap to file when java.lang.OutOfMemoryError is thrown \"    \\\n+          \"from JVM\")                                                       \\\n@@ -536,1 +537,1 @@\n-  manageable(ccstr, HeapDumpPath, NULL,                                     \\\n+  product(ccstr, HeapDumpPath, NULL, MANAGEABLE,                            \\\n@@ -541,2 +542,5 @@\n-  develop(bool, BreakAtWarning, false,                                      \\\n-          \"Execute breakpoint upon encountering VM warning\")                \\\n+  product(intx, HeapDumpGzipLevel, 0, MANAGEABLE,                           \\\n+          \"When HeapDumpOnOutOfMemoryError is on, the gzip compression \"    \\\n+          \"level of the dump file. 0 (the default) disables gzip \"          \\\n+          \"compression. Otherwise the level must be between 1 and 9.\")      \\\n+          range(0, 9)                                                       \\\n@@ -547,1 +551,1 @@\n-  diagnostic(bool, PrintNMTStatistics, false,                               \\\n+  product(bool, PrintNMTStatistics, false, DIAGNOSTIC,                      \\\n@@ -550,1 +554,1 @@\n-  diagnostic(bool, LogCompilation, false,                                   \\\n+  product(bool, LogCompilation, false, DIAGNOSTIC,                          \\\n@@ -556,0 +560,4 @@\n+  product(intx, RepeatCompilation, 0, DIAGNOSTIC,                           \\\n+          \"Repeat compilation without installing code (number of times)\")   \\\n+          range(0, max_jint)                                                \\\n+                                                                            \\\n@@ -559,1 +567,1 @@\n-  diagnostic(intx, ScavengeRootsInCode, 2,                                  \\\n+  product(intx, ScavengeRootsInCode, 2, DIAGNOSTIC,                         \\\n@@ -568,1 +576,1 @@\n-  diagnostic(bool, PrintCompilation2, false,                                \\\n+  product(bool, PrintCompilation2, false, DIAGNOSTIC,                       \\\n@@ -571,1 +579,1 @@\n-  diagnostic(bool, PrintAdapterHandlers, false,                             \\\n+  product(bool, PrintAdapterHandlers, false, DIAGNOSTIC,                    \\\n@@ -574,1 +582,1 @@\n-  diagnostic(bool, VerifyAdapterCalls, trueInDebug,                         \\\n+  product(bool, VerifyAdapterCalls, trueInDebug, DIAGNOSTIC,                \\\n@@ -580,1 +588,1 @@\n-  diagnostic(bool, PrintAssembly, false,                                    \\\n+  product(bool, PrintAssembly, false, DIAGNOSTIC,                           \\\n@@ -583,1 +591,1 @@\n-  diagnostic(ccstr, PrintAssemblyOptions, NULL,                             \\\n+  product(ccstr, PrintAssemblyOptions, NULL, DIAGNOSTIC,                    \\\n@@ -589,1 +597,1 @@\n-  diagnostic(bool, PrintNMethods, false,                                    \\\n+  product(bool, PrintNMethods, false, DIAGNOSTIC,                           \\\n@@ -592,1 +600,1 @@\n-  diagnostic(bool, PrintNativeNMethods, false,                              \\\n+  product(bool, PrintNativeNMethods, false, DIAGNOSTIC,                     \\\n@@ -624,1 +632,1 @@\n-  diagnostic(bool, PrintCodeHeapAnalytics, false,                           \\\n+  product(bool, PrintCodeHeapAnalytics, false, DIAGNOSTIC,                  \\\n@@ -627,1 +635,1 @@\n-  diagnostic(bool, PrintStubCode, false,                                    \\\n+  product(bool, PrintStubCode, false, DIAGNOSTIC,                           \\\n@@ -636,1 +644,1 @@\n-  manageable(bool, ShowCodeDetailsInExceptionMessages, false,               \\\n+  product(bool, ShowCodeDetailsInExceptionMessages, true, MANAGEABLE,       \\\n@@ -643,3 +651,0 @@\n-  notproduct(uintx, WarnOnStalledSpinLock, 0,                               \\\n-          \"Print warnings for stalled SpinLocks\")                           \\\n-                                                                            \\\n@@ -654,4 +659,0 @@\n-  develop(bool, IgnoreRewrites, false,                                      \\\n-          \"Suppress rewrites of bytecodes in the oopmap generator. \"        \\\n-          \"This is unsafe!\")                                                \\\n-                                                                            \\\n@@ -664,3 +665,0 @@\n-  develop(bool, ProtectionDomainVerification, true,                         \\\n-          \"Verify protection domain before resolution in system dictionary\")\\\n-                                                                            \\\n@@ -673,7 +671,0 @@\n-  develop(bool, DisableStartThread, false,                                  \\\n-          \"Disable starting of additional Java threads \"                    \\\n-          \"(for debugging only)\")                                           \\\n-                                                                            \\\n-  develop(bool, MemProfiling, false,                                        \\\n-          \"Write memory usage profiling to log file\")                       \\\n-                                                                            \\\n@@ -683,1 +674,4 @@\n-  diagnostic(bool, DynamicallyResizeSystemDictionaries, true,               \\\n+  notproduct(bool, PrintClassLoaderDataGraphAtExit, false,                  \\\n+          \"Print the class loader data graph at exit\")                      \\\n+                                                                            \\\n+  product(bool, DynamicallyResizeSystemDictionaries, true, DIAGNOSTIC,      \\\n@@ -687,2 +681,2 @@\n-          \"Require the VM to acquire the class loader lock before calling \" \\\n-          \"loadClass() even for class loaders registering \"                 \\\n+          \"(Deprecated) Require the VM to acquire the class loader lock \"   \\\n+          \"before calling loadClass() even for class loaders registering \"  \\\n@@ -698,5 +692,1 @@\n-  develop(bool, UseDetachedThreads, true,                                   \\\n-          \"Use detached threads that are recycled upon termination \"        \\\n-          \"(for Solaris only)\")                                             \\\n-                                                                            \\\n-  experimental(bool, DisablePrimordialThreadGuardPages, false,              \\\n+  product(bool, DisablePrimordialThreadGuardPages, false, EXPERIMENTAL,     \\\n@@ -706,5 +696,5 @@\n-  product(bool, UseLWPSynchronization, true,                                \\\n-          \"Use LWP-based instead of libthread-based synchronization \"       \\\n-          \"(SPARC only)\")                                                   \\\n-                                                                            \\\n-  product(intx, MonitorBound, 0, \"(Deprecated) Bound Monitor population\")   \\\n+  \/* notice: the max range value here is max_jint, not max_intx  *\/         \\\n+  \/* because of overflow issue                                   *\/         \\\n+  product(intx, AsyncDeflationInterval, 250, DIAGNOSTIC,                    \\\n+          \"Async deflate idle monitors every so many milliseconds when \"    \\\n+          \"MonitorUsedDeflationThreshold is exceeded (0 is off).\")          \\\n@@ -713,5 +703,17 @@\n-  experimental(intx, MonitorUsedDeflationThreshold, 90,                     \\\n-                \"Percentage of used monitors before triggering cleanup \"    \\\n-                \"safepoint which deflates monitors (0 is off). \"            \\\n-                \"The check is performed on GuaranteedSafepointInterval.\")   \\\n-                range(0, 100)                                               \\\n+  product(size_t, AvgMonitorsPerThreadEstimate, 1024, DIAGNOSTIC,           \\\n+          \"Used to estimate a variable ceiling based on number of threads \" \\\n+          \"for use with MonitorUsedDeflationThreshold (0 is off).\")         \\\n+          range(0, max_uintx)                                               \\\n+                                                                            \\\n+  \/* notice: the max range value here is max_jint, not max_intx  *\/         \\\n+  \/* because of overflow issue                                   *\/         \\\n+  product(intx, MonitorDeflationMax, 1000000, DIAGNOSTIC,                   \\\n+          \"The maximum number of monitors to deflate, unlink and delete \"   \\\n+          \"at one time (minimum is 1024).\")                      \\\n+          range(1024, max_jint)                                             \\\n+                                                                            \\\n+  product(intx, MonitorUsedDeflationThreshold, 90, DIAGNOSTIC,              \\\n+          \"Percentage of used monitors before triggering deflation (0 is \"  \\\n+          \"off). The check is performed on GuaranteedSafepointInterval \"    \\\n+          \"or AsyncDeflationInterval.\")                                     \\\n+          range(0, 100)                                                     \\\n@@ -719,1 +721,6 @@\n-  experimental(intx, hashCode, 5,                                           \\\n+  product(uintx, NoAsyncDeflationProgressMax, 3, DIAGNOSTIC,                \\\n+          \"Max number of no progress async deflation attempts to tolerate \" \\\n+          \"before adjusting the in_use_list_ceiling up (0 is off).\")        \\\n+          range(0, max_uintx)                                               \\\n+                                                                            \\\n+  product(intx, hashCode, 5, EXPERIMENTAL,                                  \\\n@@ -726,4 +733,0 @@\n-  develop(bool, UsePthreads, false,                                         \\\n-          \"Use pthread-based instead of libthread-based synchronization \"   \\\n-          \"(SPARC only)\")                                                   \\\n-                                                                            \\\n@@ -744,2 +747,2 @@\n-          \"Do not complain if the application installs signal handlers \"    \\\n-          \"(Solaris & Linux only)\")                                         \\\n+          \"Application will install primary signal handlers for the JVM \"   \\\n+          \"(Unix only)\")                                                    \\\n@@ -749,1 +752,1 @@\n-          \"by the application (Solaris & Linux only)\")                      \\\n+          \"by the application (Unix only)\")                                 \\\n@@ -781,10 +784,0 @@\n-  product(intx, FieldsAllocationStyle, 1,                                   \\\n-          \"(Deprecated) 0 - type based with oops first, \"                   \\\n-          \"1 - with oops last, \"                                            \\\n-          \"2 - oops in super and sub classes are together\")                 \\\n-          range(0, 2)                                                       \\\n-                                                                            \\\n-  product(bool, CompactFields, true,                                        \\\n-          \"(Deprecated) Allocate nonstatic fields in gaps \"                 \\\n-          \"between previous fields\")                                        \\\n-                                                                            \\\n@@ -809,2 +802,2 @@\n-  product(bool, UseBiasedLocking, true,                                     \\\n-          \"Enable biased locking in JVM\")                                   \\\n+  product(bool, UseBiasedLocking, false,                                    \\\n+          \"(Deprecated) Enable biased locking in JVM\")                      \\\n@@ -813,1 +806,2 @@\n-          \"Number of milliseconds to wait before enabling biased locking\")  \\\n+          \"(Deprecated) Number of milliseconds to wait before enabling \"    \\\n+          \"biased locking\")                                                 \\\n@@ -817,2 +811,2 @@\n-  diagnostic(bool, PrintBiasedLockingStatistics, false,                     \\\n-          \"Print statistics of biased locking in JVM\")                      \\\n+  product(bool, PrintBiasedLockingStatistics, false, DIAGNOSTIC,            \\\n+          \"(Deprecated) Print statistics of biased locking in JVM\")         \\\n@@ -821,2 +815,2 @@\n-          \"Threshold of number of revocations per type to try to \"          \\\n-          \"rebias all objects in the heap of that type\")                    \\\n+          \"(Deprecated) Threshold of number of revocations per type to \"    \\\n+          \"try to rebias all objects in the heap of that type\")             \\\n@@ -827,2 +821,3 @@\n-          \"Threshold of number of revocations per type to permanently \"     \\\n-          \"revoke biases of all objects in the heap of that type\")          \\\n+          \"(Deprecated) Threshold of number of revocations per type to \"    \\\n+          \"permanently revoke biases of all objects in the heap of that \"   \\\n+          \"type\")                                                           \\\n@@ -833,2 +828,2 @@\n-          \"Decay time (in milliseconds) to re-enable bulk rebiasing of a \"  \\\n-          \"type after previous bulk rebias\")                                \\\n+          \"(Deprecated) Decay time (in milliseconds) to re-enable bulk \"    \\\n+          \"rebiasing of a type after previous bulk rebias\")                 \\\n@@ -838,0 +833,10 @@\n+  product(intx, DiagnoseSyncOnValueBasedClasses, 0, DIAGNOSTIC,             \\\n+             \"Detect and take action upon identifying synchronization on \"  \\\n+             \"value based classes. Modes: \"                                 \\\n+             \"0: off; \"                                                     \\\n+             \"1: exit with fatal error; \"                                   \\\n+             \"2: log message to stdout. Output file can be specified with \" \\\n+             \"   -Xlog:valuebasedclasses. If JFR is running it will \"       \\\n+             \"   also generate JFR events.\")                                \\\n+             range(0, 2)                                                    \\\n+                                                                            \\\n@@ -839,1 +844,2 @@\n-          \"JVM exits on the first occurrence of an out-of-memory error\")    \\\n+          \"JVM exits on the first occurrence of an out-of-memory error \"    \\\n+          \"thrown from JVM\")                                                \\\n@@ -843,1 +849,1 @@\n-          \"first occurrence of an out-of-memory error\")                     \\\n+          \"first occurrence of an out-of-memory error thrown from JVM\")     \\\n@@ -853,9 +859,5 @@\n-  \/* This option can change an EMCP method into an obsolete method. *\/      \\\n-  \/* This can affect tests that except specific methods to be EMCP. *\/      \\\n-  \/* This option should be used with caution.                       *\/      \\\n-  product(bool, StressLdcRewrite, false,                                    \\\n-          \"Force ldc -> ldc_w rewrite during RedefineClasses\")              \\\n-                                                                            \\\n-  \/* change to false by default sometime after Mustang *\/                   \\\n-  product(bool, VerifyMergedCPBytecodes, true,                              \\\n-          \"Verify bytecodes after RedefineClasses constant pool merging\")   \\\n+  product(bool, StressLdcRewrite, false, DIAGNOSTIC,                        \\\n+          \"Force ldc -> ldc_w rewrite during RedefineClasses. \"             \\\n+          \"This option can change an EMCP method into an obsolete method \"  \\\n+          \"and can affect tests that expect specific methods to be EMCP. \"  \\\n+          \"This option should be used with caution.\")                       \\\n@@ -898,1 +900,1 @@\n-          \"Trace rewriting of method oops during oop map generation\")       \\\n+          \"Trace rewriting of methods during oop map generation\")           \\\n@@ -923,6 +925,0 @@\n-  product(size_t, InitialBootClassLoaderMetaspaceSize,                      \\\n-          NOT_LP64(2200*K) LP64_ONLY(4*M),                                  \\\n-          \"Initial size of the boot class loader data metaspace\")           \\\n-          range(30*K, max_uintx\/BytesPerWord)                               \\\n-          constraint(InitialBootClassLoaderMetaspaceSizeConstraintFunc, AfterErgo)\\\n-                                                                            \\\n@@ -932,1 +928,1 @@\n-  manageable(bool, PrintClassHistogram, false,                              \\\n+  product(bool, PrintClassHistogram, false, MANAGEABLE,                     \\\n@@ -935,1 +931,1 @@\n-  experimental(double, ObjectCountCutOffPercent, 0.5,                       \\\n+  product(double, ObjectCountCutOffPercent, 0.5, EXPERIMENTAL,              \\\n@@ -942,4 +938,1 @@\n-  diagnostic(bool, TraceJVMTIObjectTagging, false,                          \\\n-          \"Trace JVMTI object tagging calls\")                               \\\n-                                                                            \\\n-  diagnostic(bool, VerifyBeforeIteration, false,                            \\\n+  product(bool, VerifyBeforeIteration, false, DIAGNOSTIC,                   \\\n@@ -948,43 +941,0 @@\n-  \/* compiler interface *\/                                                  \\\n-                                                                            \\\n-  develop(bool, CIPrintCompilerName, false,                                 \\\n-          \"when CIPrint is active, print the name of the active compiler\")  \\\n-                                                                            \\\n-  diagnostic(bool, CIPrintCompileQueue, false,                              \\\n-          \"display the contents of the compile queue whenever a \"           \\\n-          \"compilation is enqueued\")                                        \\\n-                                                                            \\\n-  develop(bool, CIPrintRequests, false,                                     \\\n-          \"display every request for compilation\")                          \\\n-                                                                            \\\n-  product(bool, CITime, false,                                              \\\n-          \"collect timing information for compilation\")                     \\\n-                                                                            \\\n-  develop(bool, CITimeVerbose, false,                                       \\\n-          \"be more verbose in compilation timings\")                         \\\n-                                                                            \\\n-  develop(bool, CITimeEach, false,                                          \\\n-          \"display timing information after each successful compilation\")   \\\n-                                                                            \\\n-  develop(bool, CICountOSR, false,                                          \\\n-          \"use a separate counter when assigning ids to osr compilations\")  \\\n-                                                                            \\\n-  develop(bool, CICompileNatives, true,                                     \\\n-          \"compile native methods if supported by the compiler\")            \\\n-                                                                            \\\n-  develop_pd(bool, CICompileOSR,                                            \\\n-          \"compile on stack replacement methods if supported by the \"       \\\n-          \"compiler\")                                                       \\\n-                                                                            \\\n-  develop(bool, CIPrintMethodCodes, false,                                  \\\n-          \"print method bytecodes of the compiled code\")                    \\\n-                                                                            \\\n-  develop(bool, CIPrintTypeFlow, false,                                     \\\n-          \"print the results of ciTypeFlow analysis\")                       \\\n-                                                                            \\\n-  develop(bool, CITraceTypeFlow, false,                                     \\\n-          \"detailed per-bytecode tracing of ciTypeFlow analysis\")           \\\n-                                                                            \\\n-  develop(intx, OSROnlyBCI, -1,                                             \\\n-          \"OSR only at this bci.  Negative values mean exclude that bci\")   \\\n-                                                                            \\\n@@ -1003,1 +953,1 @@\n-  diagnostic(bool, ReduceNumberOfCompilerThreads, true,                     \\\n+  product(bool, ReduceNumberOfCompilerThreads, true, DIAGNOSTIC,            \\\n@@ -1007,1 +957,1 @@\n-  diagnostic(bool, TraceCompilerThreads, false,                             \\\n+  product(bool, TraceCompilerThreads, false, DIAGNOSTIC,                    \\\n@@ -1014,8 +964,0 @@\n-  develop(bool, UseStackBanging, true,                                      \\\n-          \"use stack banging for stack overflow checks (required for \"      \\\n-          \"proper StackOverflow handling; disable only to measure cost \"    \\\n-          \"of stackbanging)\")                                               \\\n-                                                                            \\\n-  develop(bool, UseStrictFP, true,                                          \\\n-          \"use strict fp if modifier strictfp is set\")                      \\\n-                                                                            \\\n@@ -1029,1 +971,1 @@\n-  diagnostic_pd(bool, ImplicitNullChecks,                                   \\\n+  product_pd(bool, ImplicitNullChecks, DIAGNOSTIC,                          \\\n@@ -1038,1 +980,1 @@\n-  diagnostic(bool, EnableThreadSMRExtraValidityChecks, true,                \\\n+  product(bool, EnableThreadSMRExtraValidityChecks, true, DIAGNOSTIC,       \\\n@@ -1041,1 +983,1 @@\n-  diagnostic(bool, EnableThreadSMRStatistics, trueInDebug,                  \\\n+  product(bool, EnableThreadSMRStatistics, trueInDebug, DIAGNOSTIC,         \\\n@@ -1056,0 +998,3 @@\n+  product(bool, UseVtableBasedCHA, true,  DIAGNOSTIC,                       \\\n+          \"Use vtable information during CHA\")                              \\\n+                                                                            \\\n@@ -1059,1 +1004,1 @@\n-  diagnostic(bool, PrintInlining, false,                                    \\\n+  product(bool, PrintInlining, false, DIAGNOSTIC,                           \\\n@@ -1068,1 +1013,1 @@\n-  diagnostic(bool, LogTouchedMethods, false,                                \\\n+  product(bool, LogTouchedMethods, false, DIAGNOSTIC,                       \\\n@@ -1071,1 +1016,1 @@\n-  diagnostic(bool, PrintTouchedMethodsAtExit, false,                        \\\n+  product(bool, PrintTouchedMethodsAtExit, false, DIAGNOSTIC,               \\\n@@ -1080,1 +1025,1 @@\n-  diagnostic(bool, PrintMethodFlushingStatistics, false,                    \\\n+  product(bool, PrintMethodFlushingStatistics, false, DIAGNOSTIC,           \\\n@@ -1083,1 +1028,1 @@\n-  diagnostic(intx, HotMethodDetectionLimit, 100000,                         \\\n+  product(intx, HotMethodDetectionLimit, 100000, DIAGNOSTIC,                \\\n@@ -1088,1 +1033,1 @@\n-  diagnostic(intx, MinPassesBeforeFlush, 10,                                \\\n+  product(intx, MinPassesBeforeFlush, 10, DIAGNOSTIC,                       \\\n@@ -1096,1 +1041,1 @@\n-  diagnostic(bool, StressCodeAging, false,                                  \\\n+  product(bool, StressCodeAging, false, DIAGNOSTIC,                         \\\n@@ -1102,1 +1047,1 @@\n-  diagnostic(bool, DebugNonSafepoints, trueInDebug,                         \\\n+  product(bool, DebugNonSafepoints, trueInDebug, DIAGNOSTIC,                \\\n@@ -1128,1 +1073,1 @@\n-  diagnostic(bool, SerializeVMOutput, true,                                 \\\n+  product(bool, SerializeVMOutput, true, DIAGNOSTIC,                        \\\n@@ -1131,1 +1076,1 @@\n-  diagnostic(bool, DisplayVMOutput, true,                                   \\\n+  product(bool, DisplayVMOutput, true, DIAGNOSTIC,                          \\\n@@ -1134,1 +1079,1 @@\n-  diagnostic(bool, LogVMOutput, false,                                      \\\n+  product(bool, LogVMOutput, false, DIAGNOSTIC,                             \\\n@@ -1137,1 +1082,1 @@\n-  diagnostic(ccstr, LogFile, NULL,                                          \\\n+  product(ccstr, LogFile, NULL, DIAGNOSTIC,                                 \\\n@@ -1167,1 +1112,1 @@\n-  diagnostic(bool, VerifyStringTableAtExit, false,                          \\\n+  product(bool, VerifyStringTableAtExit, false, DIAGNOSTIC,                 \\\n@@ -1173,5 +1118,1 @@\n-  notproduct(bool, ExitVMOnVerifyError, false,                              \\\n-          \"standard exit from VM if bytecode verify error \"                 \\\n-          \"(only in debug mode)\")                                           \\\n-                                                                            \\\n-  diagnostic(ccstr, AbortVMOnException, NULL,                               \\\n+  product(ccstr, AbortVMOnException, NULL, DIAGNOSTIC,                      \\\n@@ -1181,1 +1122,1 @@\n-  diagnostic(ccstr, AbortVMOnExceptionMessage, NULL,                        \\\n+  product(ccstr, AbortVMOnExceptionMessage, NULL, DIAGNOSTIC,               \\\n@@ -1212,3 +1153,0 @@\n-  develop(bool, UseLoopSafepoints, true,                                    \\\n-          \"Generate Safepoint nodes in every loop\")                         \\\n-                                                                            \\\n@@ -1242,13 +1180,0 @@\n-  notproduct(bool, CountRuntimeCalls, false,                                \\\n-          \"Count VM runtime calls\")                                         \\\n-                                                                            \\\n-  develop(bool, CountJNICalls, false,                                       \\\n-          \"Count jni method invocations\")                                   \\\n-                                                                            \\\n-  notproduct(bool, CountJVMCalls, false,                                    \\\n-          \"Count jvm method invocations\")                                   \\\n-                                                                            \\\n-  notproduct(bool, CountRemovableExceptions, false,                         \\\n-          \"Count exceptions that could be replaced by branches due to \"     \\\n-          \"inlining\")                                                       \\\n-                                                                            \\\n@@ -1265,1 +1190,1 @@\n-  diagnostic(bool, PrintInterpreter, false,                                 \\\n+  product(bool, PrintInterpreter, false, DIAGNOSTIC,                        \\\n@@ -1297,1 +1222,1 @@\n-  diagnostic(bool, PrintSignatureHandlers, false,                           \\\n+  product(bool, PrintSignatureHandlers, false, DIAGNOSTIC,                  \\\n@@ -1332,5 +1257,0 @@\n-  develop(bool, TraceProfileInterpreter, false,                             \\\n-          \"Trace profiling at the bytecode level during interpretation. \"   \\\n-          \"This outputs the profiling information collected to improve \"    \\\n-          \"jit compilation.\")                                               \\\n-                                                                            \\\n@@ -1345,1 +1265,1 @@\n-  diagnostic(bool, PrintMethodData, false,                                  \\\n+  product(bool, PrintMethodData, false, DIAGNOSTIC,                         \\\n@@ -1351,4 +1271,0 @@\n-  develop(bool, VerifyCompiledCode, false,                                  \\\n-          \"Include miscellaneous runtime verifications in nmethod code; \"   \\\n-          \"default off because it disturbs nmethod size heuristics\")        \\\n-                                                                            \\\n@@ -1377,20 +1293,0 @@\n-  product(bool, DontCompileHugeMethods, true,                               \\\n-          \"Do not compile methods > HugeMethodLimit\")                       \\\n-                                                                            \\\n-  \/* Bytecode escape analysis estimation. *\/                                \\\n-  product(bool, EstimateArgEscape, true,                                    \\\n-          \"Analyze bytecodes to estimate escape state of arguments\")        \\\n-                                                                            \\\n-  product(intx, BCEATraceLevel, 0,                                          \\\n-          \"How much tracing to do of bytecode escape analysis estimates \"   \\\n-          \"(0-3)\")                                                          \\\n-          range(0, 3)                                                       \\\n-                                                                            \\\n-  product(intx, MaxBCEAEstimateLevel, 5,                                    \\\n-          \"Maximum number of nested calls that are analyzed by BC EA\")      \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(intx, MaxBCEAEstimateSize, 150,                                   \\\n-          \"Maximum bytecode size of a method to be analyzed by BC EA\")      \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n@@ -1449,1 +1345,1 @@\n-  diagnostic(intx, GuaranteedSafepointInterval, 1000,                       \\\n+  product(intx, GuaranteedSafepointInterval, 1000, DIAGNOSTIC,              \\\n@@ -1456,2 +1352,1 @@\n-  LP64_ONLY(range(0, max_intx\/MICROUNITS))                                  \\\n-  NOT_LP64(range(0, max_intx))                                              \\\n+          range(0, max_intx LP64_ONLY(\/MICROUNITS))                         \\\n@@ -1470,3 +1365,0 @@\n-  notproduct(intx, MemProfilingInterval, 500,                               \\\n-          \"Time between each invocation of the MemProfiler\")                \\\n-                                                                            \\\n@@ -1488,8 +1380,0 @@\n-  product(intx, MaxInlineLevel, 15,                                         \\\n-          \"maximum number of nested calls that are inlined\")                \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(intx, MaxRecursiveInlineLevel, 1,                                 \\\n-          \"maximum number of nested recursive calls that are inlined\")      \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n@@ -1501,17 +1385,0 @@\n-  product_pd(intx, InlineSmallCode,                                         \\\n-          \"Only inline already compiled methods if their code size is \"     \\\n-          \"less than this\")                                                 \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(intx, MaxInlineSize, 35,                                          \\\n-          \"The maximum bytecode size of a method to be inlined\")            \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product_pd(intx, FreqInlineSize,                                          \\\n-          \"The maximum bytecode size of a frequent method to be inlined\")   \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(intx, MaxTrivialSize, 6,                                          \\\n-          \"The maximum bytecode size of a trivial method to be inlined\")    \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n@@ -1535,1 +1402,1 @@\n-  diagnostic(uintx, MallocMaxTestWords,     0,                              \\\n+  product(uintx, MallocMaxTestWords,     0, DIAGNOSTIC,                     \\\n@@ -1559,1 +1426,1 @@\n-  experimental(intx, PerMethodSpecTrapLimit,  5000,                         \\\n+  product(intx, PerMethodSpecTrapLimit,  5000, EXPERIMENTAL,                \\\n@@ -1568,1 +1435,1 @@\n-  experimental(intx, SpecTrapLimitExtraEntries,  3,                         \\\n+  product(intx, SpecTrapLimitExtraEntries,  3, EXPERIMENTAL,                \\\n@@ -1575,1 +1442,1 @@\n-  diagnostic_pd(intx, InlineFrequencyCount,                                 \\\n+  product_pd(intx, InlineFrequencyCount, DIAGNOSTIC,                        \\\n@@ -1588,5 +1455,1 @@\n-  develop(intx, ProfilerNodeSize,  1024,                                    \\\n-          \"Size in K to allocate for the Profile Nodes of each thread\")     \\\n-          range(0, 1024)                                                    \\\n-                                                                            \\\n-  product_pd(size_t, MetaspaceSize,                                         \\\n+  product(size_t, MetaspaceSize, NOT_LP64(16 * M) LP64_ONLY(21 * M),        \\\n@@ -1606,1 +1469,17 @@\n-  manageable(uintx, MinHeapFreeRatio, 40,                                   \\\n+  develop(size_t, CompressedClassSpaceBaseAddress, 0,                       \\\n+          \"Force the class space to be allocated at this address or \"       \\\n+          \"fails VM initialization (requires -Xshare=off.\")                 \\\n+                                                                            \\\n+  product(ccstr, MetaspaceReclaimPolicy, \"balanced\",                        \\\n+          \"options: balanced, aggressive, none\")                            \\\n+                                                                            \\\n+  product(bool, PrintMetaspaceStatisticsAtExit, false, DIAGNOSTIC,          \\\n+          \"Print metaspace statistics upon VM exit.\")                       \\\n+                                                                            \\\n+  product(bool, MetaspaceGuardAllocations, false, DIAGNOSTIC,               \\\n+          \"Metapace allocations are guarded.\")                              \\\n+                                                                            \\\n+  product(bool, MetaspaceHandleDeallocations, true, DIAGNOSTIC,             \\\n+          \"Switch off Metapace deallocation handling.\")                     \\\n+                                                                            \\\n+  product(uintx, MinHeapFreeRatio, 40, MANAGEABLE,                          \\\n@@ -1613,1 +1492,1 @@\n-  manageable(uintx, MaxHeapFreeRatio, 70,                                   \\\n+  product(uintx, MaxHeapFreeRatio, 70, MANAGEABLE,                          \\\n@@ -1713,1 +1592,1 @@\n-          range(os::vm_page_size(), max_uintx)                              \\\n+          constraint(VMPageSizeConstraintFunc, AtParse)                     \\\n@@ -1724,1 +1603,1 @@\n-          range(os::vm_page_size(), max_uintx)                              \\\n+          constraint(VMPageSizeConstraintFunc, AtParse)                     \\\n@@ -1736,1 +1615,1 @@\n-          range(os::vm_page_size(), max_uintx)                              \\\n+          constraint(VMPageSizeConstraintFunc, AtParse)                     \\\n@@ -1742,1 +1621,1 @@\n-  diagnostic_pd(uintx, CodeCacheMinBlockLength,                             \\\n+  product_pd(uintx, CodeCacheMinBlockLength, DIAGNOSTIC,                    \\\n@@ -1752,0 +1631,5 @@\n+  product(double, SweeperThreshold, 0.5,                                    \\\n+          \"Threshold controlling when code cache sweeper is invoked.\"       \\\n+          \"Value is percentage of ReservedCodeCacheSize.\")                  \\\n+          range(0.0, 100.0)                                                 \\\n+                                                                            \\\n@@ -1758,19 +1642,0 @@\n-  \/* AOT parameters *\/                                                      \\\n-  experimental(bool, UseAOT, false,                                         \\\n-          \"Use AOT compiled files\")                                         \\\n-                                                                            \\\n-  experimental(ccstrlist, AOTLibrary, NULL,                                 \\\n-          \"AOT library\")                                                    \\\n-                                                                            \\\n-  experimental(bool, PrintAOT, false,                                       \\\n-          \"Print used AOT klasses and methods\")                             \\\n-                                                                            \\\n-  notproduct(bool, PrintAOTStatistics, false,                               \\\n-          \"Print AOT statistics\")                                           \\\n-                                                                            \\\n-  diagnostic(bool, UseAOTStrictLoading, false,                              \\\n-          \"Exit the VM if any of the AOT libraries has invalid config\")     \\\n-                                                                            \\\n-  product(bool, CalculateClassFingerprint, false,                           \\\n-          \"Calculate class fingerprint\")                                    \\\n-                                                                            \\\n@@ -1788,71 +1653,0 @@\n-  \/* compiler interface *\/                                                  \\\n-  develop(intx, CIStart, 0,                                                 \\\n-          \"The id of the first compilation to permit\")                      \\\n-                                                                            \\\n-  develop(intx, CIStop, max_jint,                                           \\\n-          \"The id of the last compilation to permit\")                       \\\n-                                                                            \\\n-  develop(intx, CIStartOSR, 0,                                              \\\n-          \"The id of the first osr compilation to permit \"                  \\\n-          \"(CICountOSR must be on)\")                                        \\\n-                                                                            \\\n-  develop(intx, CIStopOSR, max_jint,                                        \\\n-          \"The id of the last osr compilation to permit \"                   \\\n-          \"(CICountOSR must be on)\")                                        \\\n-                                                                            \\\n-  develop(intx, CIBreakAtOSR, -1,                                           \\\n-          \"The id of osr compilation to break at\")                          \\\n-                                                                            \\\n-  develop(intx, CIBreakAt, -1,                                              \\\n-          \"The id of compilation to break at\")                              \\\n-                                                                            \\\n-  product(ccstrlist, CompileOnly, \"\",                                       \\\n-          \"List of methods (pkg\/class.name) to restrict compilation to\")    \\\n-                                                                            \\\n-  product(ccstr, CompileCommandFile, NULL,                                  \\\n-          \"Read compiler commands from this file [.hotspot_compiler]\")      \\\n-                                                                            \\\n-  diagnostic(ccstr, CompilerDirectivesFile, NULL,                           \\\n-          \"Read compiler directives from this file\")                        \\\n-                                                                            \\\n-  product(ccstrlist, CompileCommand, \"\",                                    \\\n-          \"Prepend to .hotspot_compiler; e.g. log,java\/lang\/String.<init>\") \\\n-                                                                            \\\n-  develop(bool, ReplayCompiles, false,                                      \\\n-          \"Enable replay of compilations from ReplayDataFile\")              \\\n-                                                                            \\\n-  product(ccstr, ReplayDataFile, NULL,                                      \\\n-          \"File containing compilation replay information\"                  \\\n-          \"[default: .\/replay_pid%p.log] (%p replaced with pid)\")           \\\n-                                                                            \\\n-   product(ccstr, InlineDataFile, NULL,                                     \\\n-          \"File containing inlining replay information\"                     \\\n-          \"[default: .\/inline_pid%p.log] (%p replaced with pid)\")           \\\n-                                                                            \\\n-  develop(intx, ReplaySuppressInitializers, 2,                              \\\n-          \"Control handling of class initialization during replay: \"        \\\n-          \"0 - don't do anything special; \"                                 \\\n-          \"1 - treat all class initializers as empty; \"                     \\\n-          \"2 - treat class initializers for application classes as empty; \" \\\n-          \"3 - allow all class initializers to run during bootstrap but \"   \\\n-          \"    pretend they are empty after starting replay\")               \\\n-          range(0, 3)                                                       \\\n-                                                                            \\\n-  develop(bool, ReplayIgnoreInitErrors, false,                              \\\n-          \"Ignore exceptions thrown during initialization for replay\")      \\\n-                                                                            \\\n-  product(bool, DumpReplayDataOnError, true,                                \\\n-          \"Record replay data for crashing compiler threads\")               \\\n-                                                                            \\\n-  product(bool, CICompilerCountPerCPU, false,                               \\\n-          \"1 compiler thread for log(N CPUs)\")                              \\\n-                                                                            \\\n-  notproduct(intx, CICrashAt, -1,                                           \\\n-          \"id of compilation to trigger assert in compiler thread for \"     \\\n-          \"the purpose of testing, e.g. generation of replay data\")         \\\n-  notproduct(bool, CIObjectFactoryVerify, false,                            \\\n-          \"enable potentially expensive verification in ciObjectFactory\")   \\\n-                                                                            \\\n-  diagnostic(bool, AbortVMOnCompilationFailure, false,                      \\\n-          \"Abort VM when method had failed to compile.\")                    \\\n-                                                                            \\\n@@ -1865,4 +1659,2 @@\n-          \"    applications. On Solaris NORM_PRIORITY and above are mapped \"\\\n-          \"    to normal native priority. Java priorities below \"           \\\n-          \"    NORM_PRIORITY map to lower native priority values. On       \"\\\n-          \"    Windows applications are allowed to use higher native       \"\\\n+          \"    applications.                                               \"\\\n+          \"    On Windows applications are allowed to use higher native    \"\\\n@@ -1893,1 +1685,0 @@\n-          constraint(CompilerThreadPriorityConstraintFunc, AfterErgo)       \\\n@@ -1940,1 +1731,1 @@\n-  experimental(bool, UseCriticalJavaThreadPriority, false,                  \\\n+  product(bool, UseCriticalJavaThreadPriority, false, EXPERIMENTAL,         \\\n@@ -1943,1 +1734,1 @@\n-  experimental(bool, UseCriticalCompilerThreadPriority, false,              \\\n+  product(bool, UseCriticalCompilerThreadPriority, false, EXPERIMENTAL,     \\\n@@ -1954,4 +1745,0 @@\n-  \/* Background Compilation *\/                                              \\\n-  develop(intx, LongCompileThreshold,     50,                               \\\n-          \"Used with +TraceLongCompiles\")                                   \\\n-                                                                            \\\n@@ -1963,224 +1750,0 @@\n-  product(double, CompileThresholdScaling, 1.0,                             \\\n-          \"Factor to control when first compilation happens \"               \\\n-          \"(both with and without tiered compilation): \"                    \\\n-          \"values greater than 1.0 delay counter overflow, \"                \\\n-          \"values between 0 and 1.0 rush counter overflow, \"                \\\n-          \"value of 1.0 leaves compilation thresholds unchanged \"           \\\n-          \"value of 0.0 is equivalent to -Xint. \"                           \\\n-          \"\"                                                                \\\n-          \"Flag can be set as per-method option. \"                          \\\n-          \"If a value is specified for a method, compilation thresholds \"   \\\n-          \"for that method are scaled by both the value of the global flag \"\\\n-          \"and the value of the per-method flag.\")                          \\\n-          range(0.0, DBL_MAX)                                               \\\n-                                                                            \\\n-  product(intx, Tier0InvokeNotifyFreqLog, 7,                                \\\n-          \"Interpreter (tier 0) invocation notification frequency\")         \\\n-          range(0, 30)                                                      \\\n-                                                                            \\\n-  product(intx, Tier2InvokeNotifyFreqLog, 11,                               \\\n-          \"C1 without MDO (tier 2) invocation notification frequency\")      \\\n-          range(0, 30)                                                      \\\n-                                                                            \\\n-  product(intx, Tier3InvokeNotifyFreqLog, 10,                               \\\n-          \"C1 with MDO profiling (tier 3) invocation notification \"         \\\n-          \"frequency\")                                                      \\\n-          range(0, 30)                                                      \\\n-                                                                            \\\n-  product(intx, Tier23InlineeNotifyFreqLog, 20,                             \\\n-          \"Inlinee invocation (tiers 2 and 3) notification frequency\")      \\\n-          range(0, 30)                                                      \\\n-                                                                            \\\n-  product(intx, Tier0BackedgeNotifyFreqLog, 10,                             \\\n-          \"Interpreter (tier 0) invocation notification frequency\")         \\\n-          range(0, 30)                                                      \\\n-                                                                            \\\n-  product(intx, Tier2BackedgeNotifyFreqLog, 14,                             \\\n-          \"C1 without MDO (tier 2) invocation notification frequency\")      \\\n-          range(0, 30)                                                      \\\n-                                                                            \\\n-  product(intx, Tier3BackedgeNotifyFreqLog, 13,                             \\\n-          \"C1 with MDO profiling (tier 3) invocation notification \"         \\\n-          \"frequency\")                                                      \\\n-          range(0, 30)                                                      \\\n-                                                                            \\\n-  product(intx, Tier2CompileThreshold, 0,                                   \\\n-          \"threshold at which tier 2 compilation is invoked\")               \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(intx, Tier2BackEdgeThreshold, 0,                                  \\\n-          \"Back edge threshold at which tier 2 compilation is invoked\")     \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(intx, Tier3InvocationThreshold, 200,                              \\\n-          \"Compile if number of method invocations crosses this \"           \\\n-          \"threshold\")                                                      \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(intx, Tier3MinInvocationThreshold, 100,                           \\\n-          \"Minimum invocation to compile at tier 3\")                        \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(intx, Tier3CompileThreshold, 2000,                                \\\n-          \"Threshold at which tier 3 compilation is invoked (invocation \"   \\\n-          \"minimum must be satisfied)\")                                     \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(intx, Tier3BackEdgeThreshold,  60000,                             \\\n-          \"Back edge threshold at which tier 3 OSR compilation is invoked\") \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(intx, Tier3AOTInvocationThreshold, 10000,                         \\\n-          \"Compile if number of method invocations crosses this \"           \\\n-          \"threshold if coming from AOT\")                                   \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(intx, Tier3AOTMinInvocationThreshold, 1000,                       \\\n-          \"Minimum invocation to compile at tier 3 if coming from AOT\")     \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(intx, Tier3AOTCompileThreshold, 15000,                            \\\n-          \"Threshold at which tier 3 compilation is invoked (invocation \"   \\\n-          \"minimum must be satisfied) if coming from AOT\")                  \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(intx, Tier3AOTBackEdgeThreshold,  120000,                         \\\n-          \"Back edge threshold at which tier 3 OSR compilation is invoked \" \\\n-          \"if coming from AOT\")                                             \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  diagnostic(intx, Tier0AOTInvocationThreshold, 200,                        \\\n-          \"Switch to interpreter to profile if the number of method \"       \\\n-          \"invocations crosses this threshold if coming from AOT \"          \\\n-          \"(applicable only with \"                                          \\\n-          \"CompilationMode=high-only|high-only-quick-internal)\")            \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  diagnostic(intx, Tier0AOTMinInvocationThreshold, 100,                     \\\n-          \"Minimum number of invocations to switch to interpreter \"         \\\n-          \"to profile if coming from AOT \"                                  \\\n-          \"(applicable only with \"                                          \\\n-          \"CompilationMode=high-only|high-only-quick-internal)\")            \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  diagnostic(intx, Tier0AOTCompileThreshold, 2000,                          \\\n-          \"Threshold at which to switch to interpreter to profile \"         \\\n-          \"if coming from AOT \"                                             \\\n-          \"(invocation minimum must be satisfied, \"                         \\\n-          \"applicable only with \"                                           \\\n-          \"CompilationMode=high-only|high-only-quick-internal)\")            \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  diagnostic(intx, Tier0AOTBackEdgeThreshold,  60000,                       \\\n-          \"Back edge threshold at which to switch to interpreter \"          \\\n-          \"to profile if coming from AOT \"                                  \\\n-          \"(applicable only with \"                                          \\\n-          \"CompilationMode=high-only|high-only-quick-internal)\")            \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(intx, Tier4InvocationThreshold, 5000,                             \\\n-          \"Compile if number of method invocations crosses this \"           \\\n-          \"threshold\")                                                      \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(intx, Tier4MinInvocationThreshold, 600,                           \\\n-          \"Minimum invocation to compile at tier 4\")                        \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(intx, Tier4CompileThreshold, 15000,                               \\\n-          \"Threshold at which tier 4 compilation is invoked (invocation \"   \\\n-          \"minimum must be satisfied)\")                                     \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(intx, Tier4BackEdgeThreshold, 40000,                              \\\n-          \"Back edge threshold at which tier 4 OSR compilation is invoked\") \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  diagnostic(intx, Tier40InvocationThreshold, 5000,                         \\\n-          \"Compile if number of method invocations crosses this \"           \\\n-          \"threshold (applicable only with \"                                \\\n-          \"CompilationMode=high-only|high-only-quick-internal)\")            \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  diagnostic(intx, Tier40MinInvocationThreshold, 600,                       \\\n-          \"Minimum number of invocations to compile at tier 4 \"             \\\n-          \"(applicable only with \"                                          \\\n-          \"CompilationMode=high-only|high-only-quick-internal)\")            \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  diagnostic(intx, Tier40CompileThreshold, 10000,                           \\\n-          \"Threshold at which tier 4 compilation is invoked (invocation \"   \\\n-          \"minimum must be satisfied, applicable only with \"                \\\n-          \"CompilationMode=high-only|high-only-quick-internal)\")            \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  diagnostic(intx, Tier40BackEdgeThreshold, 15000,                          \\\n-          \"Back edge threshold at which tier 4 OSR compilation is invoked \" \\\n-          \"(applicable only with \"                                          \\\n-          \"CompilationMode=high-only|high-only-quick-internal)\")            \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  diagnostic(intx, Tier0Delay, 5,                                           \\\n-          \"If C2 queue size grows over this amount per compiler thread \"    \\\n-          \"do not start profiling in the interpreter \"                      \\\n-          \"(applicable only with \"                                          \\\n-          \"CompilationMode=high-only|high-only-quick-internal)\")            \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(intx, Tier3DelayOn, 5,                                            \\\n-          \"If C2 queue size grows over this amount per compiler thread \"    \\\n-          \"stop compiling at tier 3 and start compiling at tier 2\")         \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(intx, Tier3DelayOff, 2,                                           \\\n-          \"If C2 queue size is less than this amount per compiler thread \"  \\\n-          \"allow methods compiled at tier 2 transition to tier 3\")          \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(intx, Tier3LoadFeedback, 5,                                       \\\n-          \"Tier 3 thresholds will increase twofold when C1 queue size \"     \\\n-          \"reaches this amount per compiler thread\")                        \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(intx, Tier4LoadFeedback, 3,                                       \\\n-          \"Tier 4 thresholds will increase twofold when C2 queue size \"     \\\n-          \"reaches this amount per compiler thread\")                        \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(intx, TieredCompileTaskTimeout, 50,                               \\\n-          \"Kill compile task if method was not used within \"                \\\n-          \"given timeout in milliseconds\")                                  \\\n-          range(0, max_intx)                                                \\\n-                                                                            \\\n-  product(intx, TieredStopAtLevel, 4,                                       \\\n-          \"Stop at given compilation level\")                                \\\n-          range(0, 4)                                                       \\\n-                                                                            \\\n-  product(intx, Tier0ProfilingStartPercentage, 200,                         \\\n-          \"Start profiling in interpreter if the counters exceed tier 3 \"   \\\n-          \"thresholds (tier 4 thresholds with \"                             \\\n-          \"CompilationMode=high-only|high-only-quick-internal)\"             \\\n-          \"by the specified percentage\")                                    \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(uintx, IncreaseFirstTierCompileThresholdAt, 50,                   \\\n-          \"Increase the compile threshold for C1 compilation if the code \"  \\\n-          \"cache is filled by the specified percentage\")                    \\\n-          range(0, 99)                                                      \\\n-                                                                            \\\n-  product(intx, TieredRateUpdateMinTime, 1,                                 \\\n-          \"Minimum rate sampling interval (in milliseconds)\")               \\\n-          range(0, max_intx)                                                \\\n-                                                                            \\\n-  product(intx, TieredRateUpdateMaxTime, 25,                                \\\n-          \"Maximum rate sampling interval (in milliseconds)\")               \\\n-          range(0, max_intx)                                                \\\n-                                                                            \\\n-  product(ccstr, CompilationMode, \"default\",                                \\\n-          \"Compilation modes: \"                                             \\\n-          \"default: normal tiered compilation; \"                            \\\n-          \"quick-only: C1-only mode; \"                                      \\\n-          \"high-only: C2\/JVMCI-only mode; \"                                 \\\n-          \"high-only-quick-internal: C2\/JVMCI-only mode, \"                  \\\n-          \"with JVMCI compiler compiled with C1.\")                          \\\n-                                                                            \\\n@@ -2190,20 +1753,0 @@\n-  product(bool, PrintTieredEvents, false,                                   \\\n-          \"Print tiered events notifications\")                              \\\n-                                                                            \\\n-  product_pd(intx, OnStackReplacePercentage,                                \\\n-          \"NON_TIERED number of method invocations\/branches (expressed as \" \\\n-          \"% of CompileThreshold) before (re-)compiling OSR code\")          \\\n-          constraint(OnStackReplacePercentageConstraintFunc, AfterErgo)     \\\n-                                                                            \\\n-  product(intx, InterpreterProfilePercentage, 33,                           \\\n-          \"NON_TIERED number of method invocations\/branches (expressed as \" \\\n-          \"% of CompileThreshold) before profiling in the interpreter\")     \\\n-          range(0, 100)                                                     \\\n-                                                                            \\\n-  develop(intx, DesiredMethodLimit,  8000,                                  \\\n-          \"The desired maximum method size (in bytecodes) after inlining\")  \\\n-                                                                            \\\n-  develop(intx, HugeMethodLimit,  8000,                                     \\\n-          \"Don't compile methods larger than this if \"                      \\\n-          \"+DontCompileHugeMethods\")                                        \\\n-                                                                            \\\n@@ -2218,1 +1761,1 @@\n-  diagnostic(bool, UseNewCode, false,                                       \\\n+  product(bool, UseNewCode, false, DIAGNOSTIC,                              \\\n@@ -2221,1 +1764,1 @@\n-  diagnostic(bool, UseNewCode2, false,                                      \\\n+  product(bool, UseNewCode2, false, DIAGNOSTIC,                             \\\n@@ -2224,1 +1767,1 @@\n-  diagnostic(bool, UseNewCode3, false,                                      \\\n+  product(bool, UseNewCode3, false, DIAGNOSTIC,                             \\\n@@ -2227,0 +1770,14 @@\n+  notproduct(bool, UseDebuggerErgo, false,                                  \\\n+          \"Debugging Only: Adjust the VM to be more debugger-friendly. \"    \\\n+          \"Turns on the other UseDebuggerErgo* flags\")                      \\\n+                                                                            \\\n+  notproduct(bool, UseDebuggerErgo1, false,                                 \\\n+          \"Debugging Only: Enable workarounds for debugger induced \"        \\\n+          \"os::processor_id() >= os::processor_count() problems\")           \\\n+                                                                            \\\n+  notproduct(bool, UseDebuggerErgo2, false,                                 \\\n+          \"Debugging Only: Limit the number of spawned JVM threads\")        \\\n+                                                                            \\\n+  notproduct(bool, EnableJVMTIStackDepthAsserts, true,                      \\\n+          \"Enable JVMTI asserts related to stack depth checks\")             \\\n+                                                                            \\\n@@ -2283,1 +1840,1 @@\n-  manageable(bool, PrintConcurrentLocks, false,                             \\\n+  product(bool, PrintConcurrentLocks, false, MANAGEABLE,                    \\\n@@ -2305,0 +1862,3 @@\n+  product(bool, RecordDynamicDumpInfo, false,                               \\\n+          \"Record class info for jcmd VM.cds dynamic_dump\")                 \\\n+                                                                            \\\n@@ -2324,1 +1884,1 @@\n-  diagnostic(bool, AllowArchivingWithJavaAgent, false,                      \\\n+  product(bool, AllowArchivingWithJavaAgent, false, DIAGNOSTIC,             \\\n@@ -2327,1 +1887,1 @@\n-  diagnostic(bool, PrintMethodHandleStubs, false,                           \\\n+  product(bool, PrintMethodHandleStubs, false, DIAGNOSTIC,                  \\\n@@ -2330,4 +1890,1 @@\n-  develop(bool, TraceMethodHandles, false,                                  \\\n-          \"trace internal method handle operations\")                        \\\n-                                                                            \\\n-  diagnostic(bool, VerifyMethodHandles, trueInDebug,                        \\\n+  product(bool, VerifyMethodHandles, trueInDebug, DIAGNOSTIC,               \\\n@@ -2336,1 +1893,1 @@\n-  diagnostic(bool, ShowHiddenFrames, false,                                 \\\n+  product(bool, ShowHiddenFrames, false, DIAGNOSTIC,                        \\\n@@ -2339,1 +1896,1 @@\n-  experimental(bool, TrustFinalNonStaticFields, false,                      \\\n+  product(bool, TrustFinalNonStaticFields, false, EXPERIMENTAL,             \\\n@@ -2342,1 +1899,1 @@\n-  diagnostic(bool, FoldStableValues, true,                                  \\\n+  product(bool, FoldStableValues, true, DIAGNOSTIC,                         \\\n@@ -2345,4 +1902,1 @@\n-  develop(bool, TraceInvokeDynamic, false,                                  \\\n-          \"trace internal invoke dynamic operations\")                       \\\n-                                                                            \\\n-  diagnostic(int, UseBootstrapCallInfo, 1,                                  \\\n+  product(int, UseBootstrapCallInfo, 1, DIAGNOSTIC,                         \\\n@@ -2356,1 +1910,1 @@\n-  diagnostic(bool, PauseAtStartup,      false,                              \\\n+  product(bool, PauseAtStartup,      false, DIAGNOSTIC,                     \\\n@@ -2360,1 +1914,1 @@\n-  diagnostic(ccstr, PauseAtStartupFile, NULL,                               \\\n+  product(ccstr, PauseAtStartupFile, NULL, DIAGNOSTIC,                      \\\n@@ -2364,1 +1918,1 @@\n-  diagnostic(bool, PauseAtExit, false,                                      \\\n+  product(bool, PauseAtExit, false, DIAGNOSTIC,                             \\\n@@ -2387,1 +1941,1 @@\n-  experimental(uintx, SymbolTableSize, defaultSymbolTableSize,              \\\n+  product(uintx, SymbolTableSize, defaultSymbolTableSize, EXPERIMENTAL,     \\\n@@ -2394,1 +1948,1 @@\n-  product(uintx, StringDeduplicationAgeThreshold, 3,                        \\\n+  product(uint, StringDeduplicationAgeThreshold, 3,                         \\\n@@ -2399,2 +1953,3 @@\n-  diagnostic(bool, StringDeduplicationResizeALot, false,                    \\\n-          \"Force table resize every time the table is scanned\")             \\\n+  product(size_t, StringDeduplicationInitialTableSize, 500, EXPERIMENTAL,   \\\n+          \"Approximate initial number of buckets in the table\")             \\\n+          range(1, 1 * G)                                                   \\\n@@ -2402,2 +1957,3 @@\n-  diagnostic(bool, StringDeduplicationRehashALot, false,                    \\\n-          \"Force table rehash every time the table is scanned\")             \\\n+  product(double, StringDeduplicationGrowTableLoad, 14.0, EXPERIMENTAL,     \\\n+          \"Entries per bucket above which the table should be expanded\")    \\\n+          range(0.1, 1000.0)                                                \\\n@@ -2405,2 +1961,17 @@\n-  diagnostic(bool, WhiteBoxAPI, false,                                      \\\n-          \"Enable internal testing APIs\")                                   \\\n+  product(double, StringDeduplicationShrinkTableLoad, 1.0, EXPERIMENTAL,    \\\n+          \"Entries per bucket below which the table should be shrunk\")      \\\n+          range(0.01, 100.0)                                                \\\n+                                                                            \\\n+  product(double, StringDeduplicationTargetTableLoad, 7.0, EXPERIMENTAL,    \\\n+          \"Desired entries per bucket when resizing the table\")             \\\n+          range(0.01, 1000.0)                                               \\\n+                                                                            \\\n+  product(size_t, StringDeduplicationCleanupDeadMinimum, 100, EXPERIMENTAL, \\\n+          \"Minimum number of dead table entries for cleaning the table\")    \\\n+                                                                            \\\n+  product(int, StringDeduplicationCleanupDeadPercent, 5, EXPERIMENTAL,      \\\n+          \"Minimum percentage of dead table entries for cleaning the table\") \\\n+          range(1, 100)                                                     \\\n+                                                                            \\\n+  product(bool, StringDeduplicationResizeALot, false, DIAGNOSTIC,           \\\n+          \"Force more frequent table resizing\")                             \\\n@@ -2408,4 +1979,5 @@\n-  experimental(intx, SurvivorAlignmentInBytes, 0,                           \\\n-           \"Default survivor space alignment in bytes\")                     \\\n-           range(8, 256)                                                    \\\n-           constraint(SurvivorAlignmentInBytesConstraintFunc,AfterErgo)     \\\n+  product(uint64_t, StringDeduplicationHashSeed, 0, DIAGNOSTIC,             \\\n+          \"Seed for the table hashing function; 0 requests computed seed\")  \\\n+                                                                            \\\n+  product(bool, WhiteBoxAPI, false, DIAGNOSTIC,                             \\\n+          \"Enable internal testing APIs\")                                   \\\n@@ -2429,1 +2001,1 @@\n-  diagnostic(intx, ArchiveRelocationMode, 0,                                \\\n+  product(intx, ArchiveRelocationMode, 0, DIAGNOSTIC,                       \\\n@@ -2437,2 +2009,1 @@\n-  experimental(size_t, ArrayAllocatorMallocLimit,                           \\\n-          SOLARIS_ONLY(64*K) NOT_SOLARIS((size_t)-1),                       \\\n+  product(size_t, ArrayAllocatorMallocLimit, (size_t)-1, EXPERIMENTAL,      \\\n@@ -2442,1 +2013,1 @@\n-  experimental(bool, AlwaysAtomicAccesses, false,                           \\\n+  product(bool, AlwaysAtomicAccesses, false, EXPERIMENTAL,                  \\\n@@ -2445,1 +2016,1 @@\n-  diagnostic(bool, UseUnalignedAccesses, false,                             \\\n+  product(bool, UseUnalignedAccesses, false, DIAGNOSTIC,                    \\\n@@ -2452,1 +2023,6 @@\n-  diagnostic(bool, CheckIntrinsics, true,                                   \\\n+  product(size_t, AsyncLogBufferSize, 2*M,                                  \\\n+          \"Memory budget (in bytes) for the buffer of Asynchronous \"        \\\n+          \"Logging (-Xlog:async).\")                                         \\\n+          range(100*K, 50*M)                                                \\\n+                                                                            \\\n+  product(bool, CheckIntrinsics, true, DIAGNOSTIC,                          \\\n@@ -2456,1 +2032,1 @@\n-             \"@HotSpotIntrinsicCandidate annotation, that \"                 \\\n+             \"@IntrinsicCandidate annotation, that \"                        \\\n@@ -2458,2 +2034,2 @@\n-             \"that are annotated with the @HotSpotIntrinsicCandidate \"      \\\n-             \"annotation, and that \"                                        \\\n+             \"that are annotated with the @IntrinsicCandidate annotation, \" \\\n+             \"and that \"                                                    \\\n@@ -2465,1 +2041,1 @@\n-  diagnostic_pd(intx, InitArrayShortSize,                                   \\\n+  product_pd(intx, InitArrayShortSize, DIAGNOSTIC,                          \\\n@@ -2472,9 +2048,1 @@\n-  diagnostic(bool, CompilerDirectivesIgnoreCompileCommands, false,          \\\n-             \"Disable backwards compatibility for compile commands.\")       \\\n-                                                                            \\\n-  diagnostic(bool, CompilerDirectivesPrint, false,                          \\\n-             \"Print compiler directives on installation.\")                  \\\n-  diagnostic(int,  CompilerDirectivesLimit, 50,                             \\\n-             \"Limit on number of compiler directives.\")                     \\\n-                                                                            \\\n-          \"Path to the directoy where a temporary file will be created \"    \\\n+          \"Path to the directory where a temporary file will be created \"   \\\n@@ -2484,6 +2052,0 @@\n-  experimental(ccstr, AllocateOldGenAt, NULL,                               \\\n-          \"Path to the directoy where a temporary file will be \"            \\\n-          \"created to use as the backing store for old generation.\"         \\\n-          \"File of size Xmx is pre-allocated for performance reason, so\"    \\\n-          \"we need that much space available\")                              \\\n-                                                                            \\\n@@ -2494,1 +2056,1 @@\n-  diagnostic(bool, ShowRegistersOnAssert, true,                             \\\n+  product(bool, ShowRegistersOnAssert, true, DIAGNOSTIC,                    \\\n@@ -2497,1 +2059,1 @@\n-  diagnostic(bool, UseSwitchProfiling, true,                                \\\n+  product(bool, UseSwitchProfiling, true, DIAGNOSTIC,                       \\\n@@ -2512,1 +2074,1 @@\n-  experimental(bool, UseFastUnorderedTimeStamps, false,                     \\\n+  product(bool, UseFastUnorderedTimeStamps, false, EXPERIMENTAL,            \\\n@@ -2515,0 +2077,14 @@\n+  product(bool, UseEmptySlotsInSupers, true,                                \\\n+                \"Allow allocating fields in empty slots of super-classes\")  \\\n+                                                                            \\\n+  product(bool, DeoptimizeNMethodBarriersALot, false, DIAGNOSTIC,           \\\n+                \"Make nmethod barriers deoptimise a lot.\")                  \\\n+                                                                            \\\n+  develop(bool, VerifyCrossModifyFence,                                     \\\n+          false AARCH64_ONLY(DEBUG_ONLY(||true)),                           \\\n+             \"Mark all threads after a safepoint, and clear on a modify \"   \\\n+             \"fence. Add cleanliness checks.\")                              \\\n+                                                                            \\\n+  develop(bool, TraceOptimizedUpcallStubs, false,                           \\\n+                \"Trace optimized upcall stub generation\")                   \\\n+                                                                            \\\n@@ -2524,1 +2100,1 @@\n-  diagnostic(bool, CRAllowToSkipCheckpoint, false,                          \\\n+  product(bool, CRAllowToSkipCheckpoint, false, DIAGNOSTIC,                 \\\n@@ -2527,2 +2103,3 @@\n-  diagnostic(bool, CRHeapDumpOnCheckpointException, false, \"Dump heap on \"  \\\n-      \"CheckpointException thrown because of C\/RaC precondition failed\")    \\\n+  product(bool, CRHeapDumpOnCheckpointException, false, DIAGNOSTIC,         \\\n+      \"Dump heap on CheckpointException thrown because of CRaC \"            \\\n+      \"precondition failed\")                                                \\\n@@ -2530,2 +2107,2 @@\n-  diagnostic(bool, CRPrintResourcesOnCheckpoint, false, \"Print resources \"  \\\n-      \"to decide CheckpointException\")                                      \\\n+  product(bool, CRPrintResourcesOnCheckpoint, false, DIAGNOSTIC,            \\\n+      \"Print resources to decide CheckpointException\")                      \\\n@@ -2533,1 +2110,2 @@\n-  diagnostic(bool, CRTraceStartupTime, false, \"Trace startup time\")         \\\n+  product(bool, CRTraceStartupTime, false, DIAGNOSTIC,                      \\\n+      \"Trace startup time\")                                                 \\\n@@ -2535,2 +2113,2 @@\n-  experimental(bool, CRDoThrowCheckpointException, true, \"Throw \"           \\\n-      \"CheckpointException if uncheckpointable resource handle found\")      \\\n+  product(bool, CRDoThrowCheckpointException, true, EXPERIMENTAL,           \\\n+      \"Throw CheckpointException if uncheckpointable resource handle found\")\\\n@@ -2538,1 +2116,1 @@\n-  product(bool, CRTrace, true, \"Minimal C\/R tracing\")\n+  product(bool, CRTrace, true, \"Minimal C\/R tracing\")                       \\\n@@ -2540,23 +2118,1 @@\n-\/\/ Interface macros\n-#define DECLARE_PRODUCT_FLAG(type, name, value, doc)      extern \"C\" type name;\n-#define DECLARE_PD_PRODUCT_FLAG(type, name, doc)          extern \"C\" type name;\n-#define DECLARE_DIAGNOSTIC_FLAG(type, name, value, doc)   extern \"C\" type name;\n-#define DECLARE_PD_DIAGNOSTIC_FLAG(type, name, doc)       extern \"C\" type name;\n-#define DECLARE_EXPERIMENTAL_FLAG(type, name, value, doc) extern \"C\" type name;\n-#define DECLARE_MANAGEABLE_FLAG(type, name, value, doc)   extern \"C\" type name;\n-#define DECLARE_PRODUCT_RW_FLAG(type, name, value, doc)   extern \"C\" type name;\n-#ifdef PRODUCT\n-#define DECLARE_DEVELOPER_FLAG(type, name, value, doc)    const type name = value;\n-#define DECLARE_PD_DEVELOPER_FLAG(type, name, doc)        const type name = pd_##name;\n-#define DECLARE_NOTPRODUCT_FLAG(type, name, value, doc)   const type name = value;\n-#else\n-#define DECLARE_DEVELOPER_FLAG(type, name, value, doc)    extern \"C\" type name;\n-#define DECLARE_PD_DEVELOPER_FLAG(type, name, doc)        extern \"C\" type name;\n-#define DECLARE_NOTPRODUCT_FLAG(type, name, value, doc)   extern \"C\" type name;\n-#endif \/\/ PRODUCT\n-\/\/ Special LP64 flags, product only needed for now.\n-#ifdef _LP64\n-#define DECLARE_LP64_PRODUCT_FLAG(type, name, value, doc) extern \"C\" type name;\n-#else\n-#define DECLARE_LP64_PRODUCT_FLAG(type, name, value, doc) const type name = value;\n-#endif \/\/ _LP64\n+\/\/ end of RUNTIME_FLAGS\n@@ -2564,14 +2120,4 @@\n-ALL_FLAGS(DECLARE_DEVELOPER_FLAG,     \\\n-          DECLARE_PD_DEVELOPER_FLAG,  \\\n-          DECLARE_PRODUCT_FLAG,       \\\n-          DECLARE_PD_PRODUCT_FLAG,    \\\n-          DECLARE_DIAGNOSTIC_FLAG,    \\\n-          DECLARE_PD_DIAGNOSTIC_FLAG, \\\n-          DECLARE_EXPERIMENTAL_FLAG,  \\\n-          DECLARE_NOTPRODUCT_FLAG,    \\\n-          DECLARE_MANAGEABLE_FLAG,    \\\n-          DECLARE_PRODUCT_RW_FLAG,    \\\n-          DECLARE_LP64_PRODUCT_FLAG,  \\\n-          IGNORE_RANGE,               \\\n-          IGNORE_CONSTRAINT,          \\\n-          IGNORE_WRITEABLE)\n+DECLARE_FLAGS(LP64_RUNTIME_FLAGS)\n+DECLARE_ARCH_FLAGS(ARCH_FLAGS)\n+DECLARE_FLAGS(RUNTIME_FLAGS)\n+DECLARE_FLAGS(RUNTIME_OS_FLAGS)\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":436,"deletions":890,"binary":false,"changes":1326,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n-#include \"classfile\/classLoader.hpp\"\n@@ -31,0 +30,1 @@\n+#include \"classfile\/vmClasses.hpp\"\n@@ -54,0 +54,1 @@\n+#include \"runtime\/jniHandles.hpp\"\n@@ -56,0 +57,2 @@\n+#include \"runtime\/osThread.hpp\"\n+#include \"runtime\/safefetch.inline.hpp\"\n@@ -57,1 +60,0 @@\n-#include \"runtime\/stubRoutines.hpp\"\n@@ -60,0 +62,1 @@\n+#include \"runtime\/vmOperations.hpp\"\n@@ -67,0 +70,1 @@\n+#include \"utilities\/count_trailing_zeros.hpp\"\n@@ -69,0 +73,1 @@\n+#include \"utilities\/powerOfTwo.hpp\"\n@@ -75,1 +80,1 @@\n-volatile unsigned int os::_rand_seed      = 1;\n+volatile unsigned int os::_rand_seed      = 1234567;\n@@ -78,1 +83,1 @@\n-size_t            os::_page_sizes[os::page_sizes_max];\n+os::PageSizes     os::_page_sizes;\n@@ -91,12 +96,0 @@\n-static time_t get_timezone(const struct tm* time_struct) {\n-#if defined(_ALLBSD_SOURCE)\n-  return time_struct->tm_gmtoff;\n-#elif defined(_WINDOWS)\n-  long zone;\n-  _get_timezone(&zone);\n-  return static_cast<time_t>(zone);\n-#else\n-  return timezone;\n-#endif\n-}\n-\n@@ -112,0 +105,8 @@\n+\/\/ E.g., YYYY-MM-DDThh:mm:ss.mmm+zzzz.\n+\/\/ Returns buffer, or NULL if it failed.\n+char* os::iso8601_time(char* buffer, size_t buffer_length, bool utc) {\n+  const jlong now = javaTimeMillis();\n+  return os::iso8601_time(now, buffer, buffer_length, utc);\n+}\n+\n+\/\/ Fill in buffer with an ISO-8601 string corresponding to the given javaTimeMillis value\n@@ -119,1 +120,1 @@\n-char* os::iso8601_time(char* buffer, size_t buffer_length, bool utc) {\n+char* os::iso8601_time(jlong milliseconds_since_19700101, char* buffer, size_t buffer_length, bool utc) {\n@@ -121,4 +122,0 @@\n-  \/\/                                      1         2\n-  \/\/                             12345678901234567890123456789\n-  \/\/ format string: \"%04d-%02d-%02dT%02d:%02d:%02d.%03d%c%02d%02d\"\n-  static const size_t needed_buffer = 29;\n@@ -131,1 +128,1 @@\n-  if (buffer_length < needed_buffer) {\n+  if (buffer_length < os::iso8601_timestamp_size) {\n@@ -135,2 +132,0 @@\n-  \/\/ Get the current time\n-  jlong milliseconds_since_19700101 = javaTimeMillis();\n@@ -155,3 +150,0 @@\n-  const time_t zone = get_timezone(&time_struct);\n-  \/\/ If daylight savings time is in effect,\n-  \/\/ we are 1 hour East of our time zone\n@@ -162,4 +154,0 @@\n-  time_t UTC_to_local = zone;\n-  if (time_struct.tm_isdst > 0) {\n-    UTC_to_local = UTC_to_local - seconds_per_hour;\n-  }\n@@ -168,2 +156,20 @@\n-  if (utc) {\n-    UTC_to_local = 0;\n+  time_t UTC_to_local = 0;\n+  if (!utc) {\n+#if defined(_ALLBSD_SOURCE) || defined(_GNU_SOURCE)\n+    UTC_to_local = -(time_struct.tm_gmtoff);\n+#elif defined(_WINDOWS)\n+    long zone;\n+    _get_timezone(&zone);\n+    UTC_to_local = static_cast<time_t>(zone);\n+#else\n+    UTC_to_local = timezone;\n+#endif\n+\n+    \/\/ tm_gmtoff already includes adjustment for daylight saving\n+#if !defined(_ALLBSD_SOURCE) && !defined(_GNU_SOURCE)\n+    \/\/ If daylight savings time is in effect,\n+    \/\/ we are 1 hour East of our time zone\n+    if (time_struct.tm_isdst > 0) {\n+      UTC_to_local = UTC_to_local - seconds_per_hour;\n+    }\n+#endif\n@@ -458,7 +464,1 @@\n-  \/\/ We need to adapt the configured number of stack protection pages given\n-  \/\/ in 4K pages to the actual os page size. We must do this before setting\n-  \/\/ up minimal stack sizes etc. in os::init_2().\n-  JavaThread::set_stack_red_zone_size     (align_up(StackRedPages      * 4 * K, vm_page_size()));\n-  JavaThread::set_stack_yellow_zone_size  (align_up(StackYellowPages   * 4 * K, vm_page_size()));\n-  JavaThread::set_stack_reserved_zone_size(align_up(StackReservedPages * 4 * K, vm_page_size()));\n-  JavaThread::set_stack_shadow_zone_size  (align_up(StackShadowPages   * 4 * K, vm_page_size()));\n+  StackOverflow::initialize_stack_zone_sizes();\n@@ -479,1 +479,1 @@\n-    Handle thread_oop = JavaCalls::construct_new_instance(SystemDictionary::Thread_klass(),\n+    Handle thread_oop = JavaCalls::construct_new_instance(vmClasses::Thread_klass(),\n@@ -485,1 +485,1 @@\n-    Klass* group = SystemDictionary::ThreadGroup_klass();\n+    Klass* group = vmClasses::ThreadGroup_klass();\n@@ -495,1 +495,1 @@\n-    { MutexLocker mu(Threads_lock);\n+    { MutexLocker mu(THREAD, Threads_lock);\n@@ -819,1 +819,1 @@\n-static int random_helper(unsigned int rand_seed) {\n+int os::next_random(unsigned int rand_seed) {\n@@ -857,2 +857,2 @@\n-    unsigned int rand = random_helper(seed);\n-    if (Atomic::cmpxchg(&_rand_seed, seed, rand) == seed) {\n+    unsigned int rand = next_random(seed);\n+    if (Atomic::cmpxchg(&_rand_seed, seed, rand, memory_order_relaxed) == seed) {\n@@ -876,2 +876,0 @@\n-  \/\/ guard suspend\/resume\n-  MutexLocker ml(thread->SR_lock(), Mutex::_no_safepoint_check_flag);\n@@ -890,1 +888,78 @@\n-void os::print_hex_dump(outputStream* st, address start, address end, int unitsize) {\n+bool os::print_function_and_library_name(outputStream* st,\n+                                         address addr,\n+                                         char* buf, int buflen,\n+                                         bool shorten_paths,\n+                                         bool demangle,\n+                                         bool strip_arguments) {\n+  \/\/ If no scratch buffer given, allocate one here on stack.\n+  \/\/ (used during error handling; its a coin toss, really, if on-stack allocation\n+  \/\/  is worse than (raw) C-heap allocation in that case).\n+  char* p = buf;\n+  if (p == NULL) {\n+    p = (char*)::alloca(O_BUFLEN);\n+    buflen = O_BUFLEN;\n+  }\n+  int offset = 0;\n+  bool have_function_name = dll_address_to_function_name(addr, p, buflen,\n+                                                         &offset, demangle);\n+  bool is_function_descriptor = false;\n+#ifdef HAVE_FUNCTION_DESCRIPTORS\n+  \/\/ When we deal with a function descriptor instead of a real code pointer, try to\n+  \/\/ resolve it. There is a small chance that a random pointer given to this function\n+  \/\/ may just happen to look like a valid descriptor, but this is rare and worth the\n+  \/\/ risk to see resolved function names. But we will print a little suffix to mark\n+  \/\/ this as a function descriptor for the reader (see below).\n+  if (!have_function_name && os::is_readable_pointer(addr)) {\n+    address addr2 = (address)os::resolve_function_descriptor(addr);\n+    if (have_function_name = is_function_descriptor =\n+        dll_address_to_function_name(addr2, p, buflen, &offset, demangle)) {\n+      addr = addr2;\n+    }\n+  }\n+#endif \/\/ HANDLE_FUNCTION_DESCRIPTORS\n+\n+  if (have_function_name) {\n+    \/\/ Print function name, optionally demangled\n+    if (demangle && strip_arguments) {\n+      char* args_start = strchr(p, '(');\n+      if (args_start != NULL) {\n+        *args_start = '\\0';\n+      }\n+    }\n+    \/\/ Print offset. Omit printing if offset is zero, which makes the output\n+    \/\/ more readable if we print function pointers.\n+    if (offset == 0) {\n+      st->print(\"%s\", p);\n+    } else {\n+      st->print(\"%s+%d\", p, offset);\n+    }\n+  } else {\n+    st->print(PTR_FORMAT, p2i(addr));\n+  }\n+  offset = 0;\n+\n+  const bool have_library_name = dll_address_to_library_name(addr, p, buflen, &offset);\n+  if (have_library_name) {\n+    \/\/ Cut path parts\n+    if (shorten_paths) {\n+      char* p2 = strrchr(p, os::file_separator()[0]);\n+      if (p2 != NULL) {\n+        p = p2 + 1;\n+      }\n+    }\n+    st->print(\" in %s\", p);\n+    if (!have_function_name) { \/\/ Omit offset if we already printed the function offset\n+      st->print(\"+%d\", offset);\n+    }\n+  }\n+\n+  \/\/ Write a trailing marker if this was a function descriptor\n+  if (have_function_name && is_function_descriptor) {\n+    st->print_raw(\" (FD)\");\n+  }\n+\n+  return have_function_name || have_library_name;\n+}\n+\n+void os::print_hex_dump(outputStream* st, address start, address end, int unitsize,\n+                        int bytes_per_line, address logical_start) {\n@@ -894,0 +969,2 @@\n+  logical_start = align_down(logical_start, unitsize);\n+  bytes_per_line = align_up(bytes_per_line, 8);\n@@ -896,8 +973,1 @@\n-  int cols_per_line = 0;\n-  switch (unitsize) {\n-    case 1: cols_per_line = 16; break;\n-    case 2: cols_per_line = 8;  break;\n-    case 4: cols_per_line = 4;  break;\n-    case 8: cols_per_line = 2;  break;\n-    default: return;\n-  }\n+  int cols_per_line = bytes_per_line \/ unitsize;\n@@ -906,1 +976,4 @@\n-  st->print(PTR_FORMAT \":   \", p2i(start));\n+  address logical_p = logical_start;\n+\n+  \/\/ Print out the addresses as if we were starting from logical_start.\n+  st->print(PTR_FORMAT \":   \", p2i(logical_p));\n@@ -919,0 +992,1 @@\n+    logical_p += unitsize;\n@@ -923,1 +997,1 @@\n-       st->print(PTR_FORMAT \":   \", p2i(p));\n+       st->print(PTR_FORMAT \":   \", p2i(logical_p));\n@@ -962,1 +1036,6 @@\n-  st->print(\"total %d\", os::processor_count());\n+#if defined(__APPLE__) && !defined(ZERO)\n+   if (VM_Version::is_cpu_emulated()) {\n+     st->print(\" (EMULATED)\");\n+   }\n+#endif\n+  st->print(\" total %d\", os::processor_count());\n@@ -1012,2 +1091,8 @@\n-    ::strftime(buf, buflen, \"%Z\", &tz);\n-    st->print(\"Time: %s %s\", timestring, buf);\n+    wchar_t w_buf[80];\n+    size_t n = ::wcsftime(w_buf, 80, L\"%Z\", &tz);\n+    if (n > 0) {\n+      ::wcstombs(buf, w_buf, buflen);\n+      st->print(\"Time: %s %s\", timestring, buf);\n+    } else {\n+      st->print(\"Time: %s\", timestring);\n+    }\n@@ -1019,3 +1104,1 @@\n-  \/\/ NOTE: It tends to crash after a SEGV if we want to printf(\"%f\",...) in\n-  \/\/       Linux. Must be a bug in glibc ? Workaround is to round \"t\" to int\n-  \/\/       before printf. We lost some precision, but who cares?\n+  \/\/ NOTE: a crash using printf(\"%f\",...) on Linux was historically noted here.\n@@ -1023,0 +1106,1 @@\n+  int eltimeFraction = (int) ((t - eltime) * 1000000);\n@@ -1032,1 +1116,1 @@\n-  st->print_cr(\" elapsed time: %d seconds (%dd %dh %dm %ds)\", eltime, eldays, elhours, elmins, elsecs);\n+  st->print_cr(\" elapsed time: %d.%06d seconds (%dd %dh %dm %ds)\", eltime, eltimeFraction, eldays, elhours, elmins, elsecs);\n@@ -1117,1 +1201,1 @@\n-    if (thread->on_local_stack(addr)) {\n+    if (thread->is_in_full_stack(addr)) {\n@@ -1161,0 +1245,3 @@\n+    if (is_aligned(addr, sizeof(intptr_t))) {\n+      st->print(\" \" PTR_FORMAT \" |\", *(intptr_t*)addr);\n+    }\n@@ -1172,2 +1259,1 @@\n-\/\/ stack is walkable beyond current frame. The check for fp() is not\n-\/\/ necessary on Sparc, but it's harmless.\n+\/\/ stack is walkable beyond current frame.\n@@ -1175,0 +1261,5 @@\n+\n+#ifdef _WINDOWS\n+  return true; \/\/ native stack isn't walkable on windows this way.\n+#endif\n+\n@@ -1280,0 +1371,4 @@\n+ssize_t os::read(int fd, void *buf, unsigned int nBytes) {\n+  return ::read(fd, buf, nBytes);\n+}\n+\n@@ -1377,2 +1472,2 @@\n-  address limit = ((JavaThread*)thread)->stack_end() +\n-                  (JavaThread::stack_guard_zone_size() + JavaThread::stack_shadow_zone_size());\n+  address limit = thread->as_Java_thread()->stack_end() +\n+                  (StackOverflow::stack_guard_zone_size() + StackOverflow::stack_shadow_zone_size());\n@@ -1388,2 +1483,2 @@\n-    for (size_t i = 0; _page_sizes[i] != 0; ++i) {\n-      const size_t page_size = _page_sizes[i];\n+    for (size_t page_size = page_sizes().largest(); page_size != 0;\n+         page_size = page_sizes().next_smaller(page_size)) {\n@@ -1534,13 +1629,0 @@\n-void os::trace_page_sizes(const char* str, const size_t* page_sizes, int count) {\n-  LogTarget(Info, pagesize) log;\n-  if (log.is_enabled()) {\n-    LogStream out(log);\n-\n-    out.print(\"%s: \", str);\n-    for (int i = 0; i < count; ++i) {\n-      out.print(\" \" SIZE_FORMAT, page_sizes[i]);\n-    }\n-    out.cr();\n-  }\n-}\n-\n@@ -1654,14 +1736,6 @@\n-char* os::reserve_memory(size_t bytes, char* addr, size_t alignment_hint, int file_desc) {\n-  char* result = NULL;\n-\n-  if (file_desc != -1) {\n-    \/\/ Could have called pd_reserve_memory() followed by replace_existing_mapping_with_file_mapping(),\n-    \/\/ but AIX may use SHM in which case its more trouble to detach the segment and remap memory to the file.\n-    result = os::map_memory_to_file(addr, bytes, file_desc);\n-    if (result != NULL) {\n-      MemTracker::record_virtual_memory_reserve_and_commit((address)result, bytes, CALLER_PC);\n-    }\n-  } else {\n-    result = pd_reserve_memory(bytes, addr, alignment_hint);\n-    if (result != NULL) {\n-      MemTracker::record_virtual_memory_reserve((address)result, bytes, CALLER_PC);\n+char* os::reserve_memory(size_t bytes, bool executable, MEMFLAGS flags) {\n+  char* result = pd_reserve_memory(bytes, executable);\n+  if (result != NULL) {\n+    MemTracker::record_virtual_memory_reserve(result, bytes, CALLER_PC);\n+    if (flags != mtOther) {\n+      MemTracker::record_virtual_memory_type(result, flags);\n@@ -1674,3 +1748,2 @@\n-char* os::reserve_memory(size_t bytes, char* addr, size_t alignment_hint,\n-   MEMFLAGS flags) {\n-  char* result = pd_reserve_memory(bytes, addr, alignment_hint);\n+char* os::attempt_reserve_memory_at(char* addr, size_t bytes, bool executable) {\n+  char* result = pd_attempt_reserve_memory_at(addr, bytes, executable);\n@@ -1679,17 +1752,2 @@\n-    MemTracker::record_virtual_memory_type((address)result, flags);\n-  }\n-\n-  return result;\n-}\n-\n-char* os::attempt_reserve_memory_at(size_t bytes, char* addr, int file_desc) {\n-  char* result = NULL;\n-  if (file_desc != -1) {\n-    result = pd_attempt_reserve_memory_at(bytes, addr, file_desc);\n-    if (result != NULL) {\n-      MemTracker::record_virtual_memory_reserve_and_commit((address)result, bytes, CALLER_PC);\n-    }\n-    result = pd_attempt_reserve_memory_at(bytes, addr);\n-    if (result != NULL) {\n-      MemTracker::record_virtual_memory_reserve((address)result, bytes, CALLER_PC);\n-    }\n+    log_debug(os)(\"Attempt to reserve memory at \" INTPTR_FORMAT \" for \"\n+                 SIZE_FORMAT \" bytes failed, errno %d\", p2i(addr), bytes, get_last_error());\n@@ -1701,5 +1759,0 @@\n-void os::split_reserved_memory(char *base, size_t size,\n-                                 size_t split, bool realloc) {\n-  pd_split_reserved_memory(base, size, split, realloc);\n-}\n-\n@@ -1735,1 +1788,1 @@\n-bool os::uncommit_memory(char* addr, size_t bytes) {\n+bool os::uncommit_memory(char* addr, size_t bytes, bool executable) {\n@@ -1739,1 +1792,1 @@\n-    res = pd_uncommit_memory(addr, bytes);\n+    res = pd_uncommit_memory(addr, bytes, executable);\n@@ -1744,1 +1797,1 @@\n-    res = pd_uncommit_memory(addr, bytes);\n+    res = pd_uncommit_memory(addr, bytes, executable);\n@@ -1752,0 +1805,1 @@\n+    \/\/ Note: Tracker contains a ThreadCritical.\n@@ -1760,0 +1814,3 @@\n+  if (!res) {\n+    log_info(os)(\"os::release_memory failed (\" PTR_FORMAT \", \" SIZE_FORMAT \")\", p2i(addr), bytes);\n+  }\n@@ -1770,0 +1827,5 @@\n+\/\/ Prints all mappings\n+void os::print_memory_mappings(outputStream* st) {\n+  os::print_memory_mappings(nullptr, (size_t)-1, st);\n+}\n+\n@@ -1772,0 +1834,4 @@\n+    \/\/ Note: this must be a store, not a load. On many OSes loads from fresh\n+    \/\/ memory would be satisfied from a single mapped page containing all zeros.\n+    \/\/ We need to store something to each page to get them backed by their own\n+    \/\/ memory, which is the effect we want here.\n@@ -1776,0 +1842,19 @@\n+char* os::map_memory_to_file(size_t bytes, int file_desc) {\n+  \/\/ Could have called pd_reserve_memory() followed by replace_existing_mapping_with_file_mapping(),\n+  \/\/ but AIX may use SHM in which case its more trouble to detach the segment and remap memory to the file.\n+  \/\/ On all current implementations NULL is interpreted as any available address.\n+  char* result = os::map_memory_to_file(NULL \/* addr *\/, bytes, file_desc);\n+  if (result != NULL) {\n+    MemTracker::record_virtual_memory_reserve_and_commit(result, bytes, CALLER_PC);\n+  }\n+  return result;\n+}\n+\n+char* os::attempt_map_memory_to_file_at(char* addr, size_t bytes, int file_desc) {\n+  char* result = pd_attempt_map_memory_to_file_at(addr, bytes, file_desc);\n+  if (result != NULL) {\n+    MemTracker::record_virtual_memory_reserve_and_commit((address)result, bytes, CALLER_PC);\n+  }\n+  return result;\n+}\n+\n@@ -1778,1 +1863,1 @@\n-                           bool allow_exec) {\n+                           bool allow_exec, MEMFLAGS flags) {\n@@ -1781,1 +1866,1 @@\n-    MemTracker::record_virtual_memory_reserve_and_commit((address)result, bytes, CALLER_PC);\n+    MemTracker::record_virtual_memory_reserve_and_commit((address)result, bytes, CALLER_PC, flags);\n@@ -1815,0 +1900,29 @@\n+char* os::reserve_memory_special(size_t size, size_t alignment, size_t page_size,\n+                                 char* addr, bool executable) {\n+\n+  assert(is_aligned(addr, alignment), \"Unaligned request address\");\n+\n+  char* result = pd_reserve_memory_special(size, alignment, page_size, addr, executable);\n+  if (result != NULL) {\n+    \/\/ The memory is committed\n+    MemTracker::record_virtual_memory_reserve_and_commit((address)result, size, CALLER_PC);\n+  }\n+\n+  return result;\n+}\n+\n+bool os::release_memory_special(char* addr, size_t bytes) {\n+  bool res;\n+  if (MemTracker::tracking_level() > NMT_minimal) {\n+    \/\/ Note: Tracker contains a ThreadCritical.\n+    Tracker tkr(Tracker::release);\n+    res = pd_release_memory_special(addr, bytes);\n+    if (res) {\n+      tkr.record((address)addr, bytes);\n+    }\n+  } else {\n+    res = pd_release_memory_special(addr, bytes);\n+  }\n+  return res;\n+}\n+\n@@ -1842,0 +1956,70 @@\n+\n+\n+\/\/\/\/\/\/ Implementation of PageSizes\n+\n+void os::PageSizes::add(size_t page_size) {\n+  assert(is_power_of_2(page_size), \"page_size must be a power of 2: \" SIZE_FORMAT_HEX, page_size);\n+  _v |= page_size;\n+}\n+\n+bool os::PageSizes::contains(size_t page_size) const {\n+  assert(is_power_of_2(page_size), \"page_size must be a power of 2: \" SIZE_FORMAT_HEX, page_size);\n+  return (_v & page_size) != 0;\n+}\n+\n+size_t os::PageSizes::next_smaller(size_t page_size) const {\n+  assert(is_power_of_2(page_size), \"page_size must be a power of 2: \" SIZE_FORMAT_HEX, page_size);\n+  size_t v2 = _v & (page_size - 1);\n+  if (v2 == 0) {\n+    return 0;\n+  }\n+  return round_down_power_of_2(v2);\n+}\n+\n+size_t os::PageSizes::next_larger(size_t page_size) const {\n+  assert(is_power_of_2(page_size), \"page_size must be a power of 2: \" SIZE_FORMAT_HEX, page_size);\n+  if (page_size == max_power_of_2<size_t>()) { \/\/ Shift by 32\/64 would be UB\n+    return 0;\n+  }\n+  \/\/ Remove current and smaller page sizes\n+  size_t v2 = _v & ~(page_size + (page_size - 1));\n+  if (v2 == 0) {\n+    return 0;\n+  }\n+  return (size_t)1 << count_trailing_zeros(v2);\n+}\n+\n+size_t os::PageSizes::largest() const {\n+  const size_t max = max_power_of_2<size_t>();\n+  if (contains(max)) {\n+    return max;\n+  }\n+  return next_smaller(max);\n+}\n+\n+size_t os::PageSizes::smallest() const {\n+  \/\/ Strictly speaking the set should not contain sizes < os::vm_page_size().\n+  \/\/ But this is not enforced.\n+  return next_larger(1);\n+}\n+\n+void os::PageSizes::print_on(outputStream* st) const {\n+  bool first = true;\n+  for (size_t sz = smallest(); sz != 0; sz = next_larger(sz)) {\n+    if (first) {\n+      first = false;\n+    } else {\n+      st->print_raw(\", \");\n+    }\n+    if (sz < M) {\n+      st->print(SIZE_FORMAT \"k\", sz \/ K);\n+    } else if (sz < G) {\n+      st->print(SIZE_FORMAT \"M\", sz \/ M);\n+    } else {\n+      st->print(SIZE_FORMAT \"G\", sz \/ G);\n+    }\n+  }\n+  if (first) {\n+    st->print(\"empty\");\n+  }\n+}\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":315,"deletions":131,"binary":false,"changes":446,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,1 @@\n-#include \"jvm.h\"\n-#include \"jvmtifiles\/jvmti.h\"\n-#include \"metaprogramming\/isRegisteredEnum.hpp\"\n+#include \"jvm_md.h\"\n@@ -32,1 +30,0 @@\n-#include \"runtime\/extendedPC.hpp\"\n@@ -57,0 +54,2 @@\n+struct jvmtiTimerInfo;\n+\n@@ -81,0 +80,5 @@\n+enum WXMode {\n+  WXWrite,\n+  WXExec\n+};\n+\n@@ -86,1 +90,1 @@\n-typedef void (*java_call_t)(JavaValue* value, const methodHandle& method, JavaCallArguments* args, Thread* thread);\n+typedef void (*java_call_t)(JavaValue* value, const methodHandle& method, JavaCallArguments* args, JavaThread* thread);\n@@ -104,1 +108,19 @@\n-  enum { page_sizes_max = 9 }; \/\/ Size of _page_sizes array (8 plus a sentinel)\n+\n+  \/\/ A simple value class holding a set of page sizes (similar to sigset_t)\n+  class PageSizes {\n+    size_t _v; \/\/ actually a bitmap.\n+  public:\n+    PageSizes() : _v(0) {}\n+    void add(size_t pagesize);\n+    bool contains(size_t pagesize) const;\n+    \/\/ Given a page size, return the next smaller page size in this set, or 0.\n+    size_t next_smaller(size_t pagesize) const;\n+    \/\/ Given a page size, return the next larger page size in this set, or 0.\n+    size_t next_larger(size_t pagesize) const;\n+    \/\/ Returns the largest page size in this set, or 0 if set is empty.\n+    size_t largest() const;\n+    \/\/ Returns the smallest page size in this set, or 0 if set is empty.\n+    size_t smallest() const;\n+    \/\/ Prints one line of comma separated, human readable page sizes, \"empty\" if empty.\n+    void print_on(outputStream* st) const;\n+  };\n@@ -109,2 +131,1 @@\n- public:\n-  static size_t             _page_sizes[page_sizes_max];\n+  static PageSizes          _page_sizes;\n@@ -112,5 +133,3 @@\n- private:\n-  static void init_page_sizes(size_t default_page_size) {\n-    _page_sizes[0] = default_page_size;\n-    _page_sizes[1] = 0; \/\/ sentinel\n-  }\n+  static char*  pd_reserve_memory(size_t bytes, bool executable);\n+\n+  static char*  pd_attempt_reserve_memory_at(char* addr, size_t bytes, bool executable);\n@@ -118,6 +137,0 @@\n-  static char*  pd_reserve_memory(size_t bytes, char* addr = 0,\n-                                  size_t alignment_hint = 0);\n-  static char*  pd_attempt_reserve_memory_at(size_t bytes, char* addr);\n-  static char*  pd_attempt_reserve_memory_at(size_t bytes, char* addr, int file_desc);\n-  static void   pd_split_reserved_memory(char *base, size_t size,\n-                                      size_t split, bool realloc);\n@@ -134,1 +147,1 @@\n-  static bool   pd_uncommit_memory(char* addr, size_t bytes);\n+  static bool   pd_uncommit_memory(char* addr, size_t bytes, bool executable);\n@@ -137,0 +150,2 @@\n+  static char*  pd_attempt_map_memory_to_file_at(char* addr, size_t bytes, int file_desc);\n+\n@@ -147,0 +162,5 @@\n+  static char*  pd_reserve_memory_special(size_t size, size_t alignment, size_t page_size,\n+\n+                                          char* addr, bool executable);\n+  static bool   pd_release_memory_special(char* addr, size_t bytes);\n+\n@@ -171,0 +191,2 @@\n+  \/\/ Get environ pointer, platform independently\n+  static char** get_environ();\n@@ -179,1 +201,0 @@\n-  static bool   supports_monotonic_clock();\n@@ -207,0 +228,10 @@\n+\n+  \/\/ \"YYYY-MM-DDThh:mm:ss.mmm+zzzz\" incl. terminating zero\n+  static const size_t iso8601_timestamp_size = 29;\n+\n+  \/\/ Fill in buffer with an ISO-8601 string corresponding to the given javaTimeMillis value\n+  \/\/ E.g., YYYY-MM-DDThh:mm:ss.mmm+zzzz.\n+  \/\/ Returns buffer, or NULL if it failed.\n+  static char* iso8601_time(jlong milliseconds_since_19700101, char* buffer,\n+                            size_t buffer_length, bool utc = false);\n+\n@@ -226,1 +257,1 @@\n-  static bool has_allocatable_memory_limit(julong* limit);\n+  static bool has_allocatable_memory_limit(size_t* limit);\n@@ -274,0 +305,4 @@\n+  \/\/ The set of page sizes which the VM is allowed to use (may be a subset of\n+  \/\/  the page sizes actually available on the platform).\n+  static const PageSizes& page_sizes() { return _page_sizes; }\n+\n@@ -285,4 +320,1 @@\n-  static size_t max_page_size() {\n-    \/\/ The _page_sizes array is sorted in descending order.\n-    return _page_sizes[0];\n-  }\n+  static size_t max_page_size() { return page_sizes().largest(); }\n@@ -313,8 +345,11 @@\n-  static char*  reserve_memory(size_t bytes, char* addr = 0,\n-                               size_t alignment_hint = 0, int file_desc = -1);\n-  static char*  reserve_memory(size_t bytes, char* addr,\n-                               size_t alignment_hint, MEMFLAGS flags);\n-  static char*  reserve_memory_aligned(size_t size, size_t alignment, int file_desc = -1);\n-  static char*  attempt_reserve_memory_at(size_t bytes, char* addr, int file_desc = -1);\n-  static void   split_reserved_memory(char *base, size_t size,\n-                                      size_t split, bool realloc);\n+\n+  \/\/ Reserves virtual memory.\n+  static char*  reserve_memory(size_t bytes, bool executable = false, MEMFLAGS flags = mtOther);\n+\n+  \/\/ Reserves virtual memory that starts at an address that is aligned to 'alignment'.\n+  static char*  reserve_memory_aligned(size_t size, size_t alignment, bool executable = false);\n+\n+  \/\/ Attempts to reserve the virtual memory at [addr, addr + bytes).\n+  \/\/ Does not overwrite existing mappings.\n+  static char*  attempt_reserve_memory_at(char* addr, size_t bytes, bool executable = false);\n+\n@@ -331,1 +366,1 @@\n-  static bool   uncommit_memory(char* addr, size_t bytes);\n+  static bool   uncommit_memory(char* addr, size_t bytes, bool executable = false);\n@@ -336,0 +371,5 @@\n+  \/\/ A diagnostic function to print memory mappings in the given range.\n+  static void print_memory_mappings(char* addr, size_t bytes, outputStream* st);\n+  \/\/ Prints all mappings\n+  static void print_memory_mappings(outputStream* st);\n+\n@@ -356,0 +396,2 @@\n+  static char* map_memory_to_file(size_t size, int fd);\n+  static char* map_memory_to_file_aligned(size_t size, size_t alignment, int fd);\n@@ -357,0 +399,1 @@\n+  static char* attempt_map_memory_to_file_at(char* base, size_t size, int fd);\n@@ -362,1 +405,1 @@\n-                           bool allow_exec = false);\n+                           bool allow_exec = false, MEMFLAGS flags = mtNone);\n@@ -391,1 +434,1 @@\n-  static char*  reserve_memory_special(size_t size, size_t alignment,\n+  static char*  reserve_memory_special(size_t size, size_t alignment, size_t page_size,\n@@ -399,7 +442,0 @@\n-  \/\/ OS interface to polling page\n-  static address get_polling_page()             { return _polling_page; }\n-  static void    set_polling_page(address page) { _polling_page = page; }\n-  static bool    is_poll_address(address addr)  { return addr >= _polling_page && addr < (_polling_page + os::vm_page_size()); }\n-  static void    make_polling_page_unreadable();\n-  static void    make_polling_page_readable();\n-\n@@ -419,0 +455,1 @@\n+    asynclog_thread,   \/\/ dedicated to flushing logs\n@@ -452,1 +489,1 @@\n-  \/\/ thread id on Linux\/64bit is 64bit, on Windows and Solaris, it's 32bit\n+  \/\/ thread id on Linux\/64bit is 64bit, on Windows it's 32bit\n@@ -473,1 +510,1 @@\n-  static ExtendedPC fetch_frame_from_context(const void* ucVoid, intptr_t** sp, intptr_t** fp);\n+  static address    fetch_frame_from_context(const void* ucVoid, intptr_t** sp, intptr_t** fp);\n@@ -475,1 +512,1 @@\n-  static frame      fetch_frame_from_ucontext(Thread* thread, void* ucVoid);\n+  static frame      fetch_compiled_frame_from_context(const void* ucVoid);\n@@ -488,2 +525,6 @@\n-  \/\/ run cmd in a separate process and return its exit code; or -1 on failures\n-  static int fork_and_exec(char *cmd, bool use_vfork_if_available = false);\n+  \/\/ run cmd in a separate process and return its exit code; or -1 on failures.\n+  \/\/ Note: only safe to use in fatal error situations.\n+  \/\/ The \"prefer_vfork\" argument is only used on POSIX platforms to\n+  \/\/ indicate whether vfork should be used instead of fork to spawn the\n+  \/\/ child process (ignored on AIX, which always uses vfork).\n+  static int fork_and_exec(const char *cmd, bool prefer_vfork = false);\n@@ -575,0 +616,18 @@\n+  \/\/ Given an address, attempt to locate both the symbol and the library it\n+  \/\/ resides in. If at least one of these steps was successful, prints information\n+  \/\/ and returns true.\n+  \/\/ - if no scratch buffer is given, stack is used\n+  \/\/ - shorten_paths: path is omitted from library name\n+  \/\/ - demangle: function name is demangled\n+  \/\/ - strip_arguments: arguments are stripped (requires demangle=true)\n+  \/\/ On success prints either one of:\n+  \/\/ \"<function name>+<offset> in <library>\"\n+  \/\/ \"<function name>+<offset>\"\n+  \/\/ \"<address> in <library>+<offset>\"\n+  static bool print_function_and_library_name(outputStream* st,\n+                                              address addr,\n+                                              char* buf = NULL, int buflen = 0,\n+                                              bool shorten_paths = true,\n+                                              bool demangle = true,\n+                                              bool strip_arguments = false);\n+\n@@ -680,1 +739,5 @@\n-  static void print_hex_dump(outputStream* st, address start, address end, int unitsize);\n+  static void print_hex_dump(outputStream* st, address start, address end, int unitsize,\n+                             int bytes_per_line, address logical_start);\n+  static void print_hex_dump(outputStream* st, address start, address end, int unitsize) {\n+    print_hex_dump(st, start, end, unitsize, \/*bytes_per_line=*\/16, \/*logical_start=*\/start);\n+  }\n@@ -759,0 +822,1 @@\n+  static int next_random(unsigned int rand_seed); \/\/ pure version of random()\n@@ -762,1 +826,1 @@\n-  static void os_exception_wrapper(java_call_t f, JavaValue* value, const methodHandle& method, JavaCallArguments* args, Thread* thread);\n+  static void os_exception_wrapper(java_call_t f, JavaValue* value, const methodHandle& method, JavaCallArguments* args, JavaThread* thread);\n@@ -779,1 +843,0 @@\n-  \/\/ They are not supported on Solaris T1.\n@@ -782,1 +845,0 @@\n-  \/\/ On Solaris - call gethrvtime (fast) - user time only\n@@ -892,0 +954,5 @@\n+#if defined(__APPLE__) && defined(AARCH64)\n+  \/\/ Enables write or execute access to writeable and executable pages.\n+  static void current_thread_enable_wx(WXMode mode);\n+#endif \/\/ __APPLE__ && AARCH64\n+\n@@ -961,1 +1028,0 @@\n-\n@@ -976,4 +1042,0 @@\n-#ifndef _WINDOWS\n-template<> struct IsRegisteredEnum<os::SuspendResume::State> : public TrueType {};\n-#endif \/\/ !_WINDOWS\n-\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":121,"deletions":59,"binary":false,"changes":180,"status":"modified"},{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.\n@@ -27,1 +28,2 @@\n-#include \"aot\/aotLoader.hpp\"\n+#include \"cds\/dynamicArchive.hpp\"\n+#include \"cds\/metaspaceShared.hpp\"\n@@ -30,1 +32,1 @@\n-#include \"classfile\/moduleEntry.hpp\"\n+#include \"classfile\/javaThreadStatus.hpp\"\n@@ -32,0 +34,1 @@\n+#include \"classfile\/vmClasses.hpp\"\n@@ -37,0 +40,1 @@\n+#include \"compiler\/compilerThread.hpp\"\n@@ -38,0 +42,1 @@\n+#include \"gc\/shared\/collectedHeap.hpp\"\n@@ -40,1 +45,5 @@\n-#include \"gc\/shared\/workgroup.hpp\"\n+#include \"gc\/shared\/gcVMOperations.hpp\"\n+#include \"gc\/shared\/oopStorage.hpp\"\n+#include \"gc\/shared\/oopStorageSet.hpp\"\n+#include \"gc\/shared\/stringdedup\/stringDedup.hpp\"\n+#include \"gc\/shared\/tlab_globals.hpp\"\n@@ -47,0 +56,1 @@\n+#include \"logging\/logAsyncWriter.hpp\"\n@@ -51,1 +61,0 @@\n-#include \"memory\/metaspaceShared.hpp\"\n@@ -57,0 +66,1 @@\n+#include \"oops\/klass.inline.hpp\"\n@@ -59,0 +69,1 @@\n+#include \"oops\/oopHandle.inline.hpp\"\n@@ -63,0 +74,1 @@\n+#include \"prims\/jvmtiDeferredUpdates.hpp\"\n@@ -69,3 +81,1 @@\n-#include \"runtime\/flags\/jvmFlagConstraintList.hpp\"\n-#include \"runtime\/flags\/jvmFlagRangeList.hpp\"\n-#include \"runtime\/flags\/jvmFlagWriteableList.hpp\"\n+#include \"runtime\/flags\/jvmFlagLimit.hpp\"\n@@ -82,1 +92,1 @@\n-#include \"runtime\/memprofiler.hpp\"\n+#include \"runtime\/monitorDeflationThread.hpp\"\n@@ -84,0 +94,1 @@\n+#include \"runtime\/nonJavaThread.hpp\"\n@@ -93,0 +104,2 @@\n+#include \"runtime\/stackFrameStream.inline.hpp\"\n+#include \"runtime\/stackWatermarkSet.hpp\"\n@@ -94,2 +107,0 @@\n-#include \"runtime\/stubRoutines.hpp\"\n-#include \"runtime\/sweeper.hpp\"\n@@ -101,0 +112,1 @@\n+#include \"runtime\/threadWXSetters.inline.hpp\"\n@@ -120,1 +132,1 @@\n-#include \"utilities\/singleWriterSynchronizer.hpp\"\n+#include \"utilities\/spinYield.hpp\"\n@@ -236,1 +248,1 @@\n-  set_metadata_handles(new (ResourceObj::C_HEAP, mtClass) GrowableArray<Metadata*>(30, true));\n+  set_metadata_handles(new (ResourceObj::C_HEAP, mtClass) GrowableArray<Metadata*>(30, mtClass));\n@@ -254,1 +266,0 @@\n-  NOT_PRODUCT(_no_safepoint_count = 0;)\n@@ -258,19 +269,0 @@\n-  _vm_operation_started_count = 0;\n-  _vm_operation_completed_count = 0;\n-  _current_pending_monitor = NULL;\n-  _current_pending_monitor_is_from_java = true;\n-  _current_waiting_monitor = NULL;\n-  _num_nested_signal = 0;\n-  om_free_list = NULL;\n-  om_free_count = 0;\n-  om_free_provision = 32;\n-  om_in_use_list = NULL;\n-  om_in_use_count = 0;\n-\n-#ifdef ASSERT\n-  _visited_for_critical_count = false;\n-#endif\n-\n-  _SR_lock = new Monitor(Mutex::suspend_resume, \"SR_lock\", true,\n-                         Monitor::_safepoint_check_sometimes);\n-  _suspend_flags = 0;\n@@ -285,4 +277,0 @@\n-  _OnTrap   = 0;\n-  _Stalled  = 0;\n-  _TypeTag  = 0x2BAD;\n-\n@@ -297,1 +285,0 @@\n-  _MuxEvent    = ParkEvent::Allocate(this);\n@@ -327,0 +314,8 @@\n+\n+  MACOS_AARCH64_ONLY(DEBUG_ONLY(_wx_init = false));\n+}\n+\n+void Thread::initialize_tlab() {\n+  if (UseTLAB) {\n+    tlab().initialize();\n+  }\n@@ -355,6 +350,0 @@\n-#ifdef SOLARIS\n-  if (os::is_primordial_thread()) {\n-    os::Solaris::correct_stack_boundaries_for_primordial_thread(this);\n-  }\n-#endif\n-\n@@ -363,2 +352,1 @@\n-    ((JavaThread*) this)->set_stack_overflow_limit();\n-    ((JavaThread*) this)->set_reserved_stack_activation(stack_base());\n+    as_Java_thread()->stack_overflow_state()->initialize(stack_base(), stack_end());\n@@ -372,0 +360,4 @@\n+\n+void Thread::unregister_thread_stack_with_NMT() {\n+  MemTracker::release_thread_stack(stack_end(), stack_size());\n+}\n@@ -387,0 +379,2 @@\n+  MACOS_AARCH64_ONLY(this->init_wx());\n+\n@@ -391,1 +385,1 @@\n-    os::current_thread_id(), p2i(stack_base() - stack_size()),\n+    os::current_thread_id(), p2i(stack_end()),\n@@ -437,13 +431,0 @@\n-  \/\/ stack_base can be NULL if the thread is never started or exited before\n-  \/\/ record_stack_base_and_size called. Although, we would like to ensure\n-  \/\/ that all started threads do call record_stack_base_and_size(), there is\n-  \/\/ not proper way to enforce that.\n-#if INCLUDE_NMT\n-  if (_stack_base != NULL) {\n-    MemTracker::release_thread_stack(stack_end(), stack_size());\n-#ifdef ASSERT\n-    set_stack_base(NULL);\n-#endif\n-  }\n-#endif \/\/ INCLUDE_NMT\n-\n@@ -458,4 +439,3 @@\n-  \/\/ It's possible we can encounter a null _ParkEvent, etc., in stillborn threads.\n-  \/\/ We NULL out the fields for good hygiene.\n-  ParkEvent::Release(_ParkEvent); _ParkEvent   = NULL;\n-  ParkEvent::Release(_MuxEvent); _MuxEvent    = NULL;\n+  ParkEvent::Release(_ParkEvent);\n+  \/\/ Set to NULL as a termination indicator for has_terminated().\n+  Atomic::store(&_ParkEvent, (ParkEvent*)NULL);\n@@ -466,5 +446,0 @@\n-  \/\/ SR_handler uses this as a termination indicator -\n-  \/\/ needs to happen before os::free_thread()\n-  delete _SR_lock;\n-  _SR_lock = NULL;\n-\n@@ -485,4 +460,2 @@\n-\/\/ A JavaThread is considered \"dangling\" if it is not the current\n-\/\/ thread, has been added the Threads list, the system is not at a\n-\/\/ safepoint and the Thread is not \"protected\".\n-\/\/\n+\/\/ A JavaThread is considered dangling if it not handshake-safe with respect to\n+\/\/ the current thread, it is not on a ThreadsList, or not at safepoint.\n@@ -490,2 +463,3 @@\n-  assert(!thread->is_Java_thread() || Thread::current() == thread ||\n-         !((JavaThread *) thread)->on_thread_list() ||\n+  assert(!thread->is_Java_thread() ||\n+         thread->as_Java_thread()->is_handshake_safe_for(Thread::current()) ||\n+         !thread->as_Java_thread()->on_thread_list() ||\n@@ -493,1 +467,1 @@\n-         ThreadsSMRSupport::is_a_protected_JavaThread_with_lock((JavaThread *) thread),\n+         ThreadsSMRSupport::is_a_protected_JavaThread_with_lock(thread->as_Java_thread()),\n@@ -498,0 +472,44 @@\n+\/\/ Is the target JavaThread protected by the calling Thread\n+\/\/ or by some other mechanism:\n+bool Thread::is_JavaThread_protected(const JavaThread* p) {\n+  \/\/ Do the simplest check first:\n+  if (SafepointSynchronize::is_at_safepoint()) {\n+    \/\/ The target is protected since JavaThreads cannot exit\n+    \/\/ while we're at a safepoint.\n+    return true;\n+  }\n+\n+  \/\/ Now make the simple checks based on who the caller is:\n+  Thread* current_thread = Thread::current();\n+  if (current_thread == p || Threads_lock->owner() == current_thread) {\n+    \/\/ Target JavaThread is self or calling thread owns the Threads_lock.\n+    \/\/ Second check is the same as Threads_lock->owner_is_self(),\n+    \/\/ but we already have the current thread so check directly.\n+    return true;\n+  }\n+\n+  \/\/ Check the ThreadsLists associated with the calling thread (if any)\n+  \/\/ to see if one of them protects the target JavaThread:\n+  for (SafeThreadsListPtr* stlp = current_thread->_threads_list_ptr;\n+       stlp != NULL; stlp = stlp->previous()) {\n+    if (stlp->list()->includes(p)) {\n+      \/\/ The target JavaThread is protected by this ThreadsList:\n+      return true;\n+    }\n+  }\n+\n+  \/\/ Use this debug code with -XX:+UseNewCode to diagnose locations that\n+  \/\/ are missing a ThreadsListHandle or other protection mechanism:\n+  \/\/ guarantee(!UseNewCode, \"current_thread=\" INTPTR_FORMAT \" is not protecting p=\"\n+  \/\/           INTPTR_FORMAT, p2i(current_thread), p2i(p));\n+\n+  \/\/ Note: Since 'p' isn't protected by a TLH, the call to\n+  \/\/ p->is_handshake_safe_for() may crash, but we have debug bits so\n+  \/\/ we'll be able to figure out what protection mechanism is missing.\n+  assert(p->is_handshake_safe_for(current_thread), \"JavaThread=\" INTPTR_FORMAT\n+         \" is not protected and not handshake safe.\", p2i(p));\n+\n+  \/\/ The target JavaThread is not protected so it is not safe to query:\n+  return false;\n+}\n+\n@@ -516,340 +534,7 @@\n-  if (!DisableStartThread) {\n-    if (thread->is_Java_thread()) {\n-      \/\/ Initialize the thread state to RUNNABLE before starting this thread.\n-      \/\/ Can not set it after the thread started because we do not know the\n-      \/\/ exact thread state at that time. It could be in MONITOR_WAIT or\n-      \/\/ in SLEEPING or some other state.\n-      java_lang_Thread::set_thread_status(((JavaThread*)thread)->threadObj(),\n-                                          java_lang_Thread::RUNNABLE);\n-    }\n-    os::start_thread(thread);\n-  }\n-}\n-\n-void Thread::send_async_exception(oop java_thread, oop java_throwable) {\n-  VM_ThreadStop vm_stop(java_thread, java_throwable);\n-  VMThread::execute(&vm_stop);\n-}\n-\n-\n-\/\/ Check if an external suspend request has completed (or has been\n-\/\/ cancelled). Returns true if the thread is externally suspended and\n-\/\/ false otherwise.\n-\/\/\n-\/\/ The bits parameter returns information about the code path through\n-\/\/ the routine. Useful for debugging:\n-\/\/\n-\/\/ set in is_ext_suspend_completed():\n-\/\/ 0x00000001 - routine was entered\n-\/\/ 0x00000010 - routine return false at end\n-\/\/ 0x00000100 - thread exited (return false)\n-\/\/ 0x00000200 - suspend request cancelled (return false)\n-\/\/ 0x00000400 - thread suspended (return true)\n-\/\/ 0x00001000 - thread is in a suspend equivalent state (return true)\n-\/\/ 0x00002000 - thread is native and walkable (return true)\n-\/\/ 0x00004000 - thread is native_trans and walkable (needed retry)\n-\/\/\n-\/\/ set in wait_for_ext_suspend_completion():\n-\/\/ 0x00010000 - routine was entered\n-\/\/ 0x00020000 - suspend request cancelled before loop (return false)\n-\/\/ 0x00040000 - thread suspended before loop (return true)\n-\/\/ 0x00080000 - suspend request cancelled in loop (return false)\n-\/\/ 0x00100000 - thread suspended in loop (return true)\n-\/\/ 0x00200000 - suspend not completed during retry loop (return false)\n-\n-\/\/ Helper class for tracing suspend wait debug bits.\n-\/\/\n-\/\/ 0x00000100 indicates that the target thread exited before it could\n-\/\/ self-suspend which is not a wait failure. 0x00000200, 0x00020000 and\n-\/\/ 0x00080000 each indicate a cancelled suspend request so they don't\n-\/\/ count as wait failures either.\n-#define DEBUG_FALSE_BITS (0x00000010 | 0x00200000)\n-\n-class TraceSuspendDebugBits : public StackObj {\n- private:\n-  JavaThread * jt;\n-  bool         is_wait;\n-  bool         called_by_wait;  \/\/ meaningful when !is_wait\n-  uint32_t *   bits;\n-\n- public:\n-  TraceSuspendDebugBits(JavaThread *_jt, bool _is_wait, bool _called_by_wait,\n-                        uint32_t *_bits) {\n-    jt             = _jt;\n-    is_wait        = _is_wait;\n-    called_by_wait = _called_by_wait;\n-    bits           = _bits;\n-  }\n-\n-  ~TraceSuspendDebugBits() {\n-    if (!is_wait) {\n-#if 1\n-      \/\/ By default, don't trace bits for is_ext_suspend_completed() calls.\n-      \/\/ That trace is very chatty.\n-      return;\n-#else\n-      if (!called_by_wait) {\n-        \/\/ If tracing for is_ext_suspend_completed() is enabled, then only\n-        \/\/ trace calls to it from wait_for_ext_suspend_completion()\n-        return;\n-      }\n-#endif\n-    }\n-\n-    if (AssertOnSuspendWaitFailure || TraceSuspendWaitFailures) {\n-      if (bits != NULL && (*bits & DEBUG_FALSE_BITS) != 0) {\n-        MutexLocker ml(Threads_lock);  \/\/ needed for get_thread_name()\n-        ResourceMark rm;\n-\n-        tty->print_cr(\n-                      \"Failed wait_for_ext_suspend_completion(thread=%s, debug_bits=%x)\",\n-                      jt->get_thread_name(), *bits);\n-\n-        guarantee(!AssertOnSuspendWaitFailure, \"external suspend wait failed\");\n-      }\n-    }\n-  }\n-};\n-#undef DEBUG_FALSE_BITS\n-\n-\n-bool JavaThread::is_ext_suspend_completed(bool called_by_wait, int delay,\n-                                          uint32_t *bits) {\n-  TraceSuspendDebugBits tsdb(this, false \/* !is_wait *\/, called_by_wait, bits);\n-\n-  bool did_trans_retry = false;  \/\/ only do thread_in_native_trans retry once\n-  bool do_trans_retry;           \/\/ flag to force the retry\n-\n-  *bits |= 0x00000001;\n-\n-  do {\n-    do_trans_retry = false;\n-\n-    if (is_exiting()) {\n-      \/\/ Thread is in the process of exiting. This is always checked\n-      \/\/ first to reduce the risk of dereferencing a freed JavaThread.\n-      *bits |= 0x00000100;\n-      return false;\n-    }\n-\n-    if (!is_external_suspend()) {\n-      \/\/ Suspend request is cancelled. This is always checked before\n-      \/\/ is_ext_suspended() to reduce the risk of a rogue resume\n-      \/\/ confusing the thread that made the suspend request.\n-      *bits |= 0x00000200;\n-      return false;\n-    }\n-\n-    if (is_ext_suspended()) {\n-      \/\/ thread is suspended\n-      *bits |= 0x00000400;\n-      return true;\n-    }\n-\n-    \/\/ Now that we no longer do hard suspends of threads running\n-    \/\/ native code, the target thread can be changing thread state\n-    \/\/ while we are in this routine:\n-    \/\/\n-    \/\/   _thread_in_native -> _thread_in_native_trans -> _thread_blocked\n-    \/\/\n-    \/\/ We save a copy of the thread state as observed at this moment\n-    \/\/ and make our decision about suspend completeness based on the\n-    \/\/ copy. This closes the race where the thread state is seen as\n-    \/\/ _thread_in_native_trans in the if-thread_blocked check, but is\n-    \/\/ seen as _thread_blocked in if-thread_in_native_trans check.\n-    JavaThreadState save_state = thread_state();\n-\n-    if (save_state == _thread_blocked && is_suspend_equivalent()) {\n-      \/\/ If the thread's state is _thread_blocked and this blocking\n-      \/\/ condition is known to be equivalent to a suspend, then we can\n-      \/\/ consider the thread to be externally suspended. This means that\n-      \/\/ the code that sets _thread_blocked has been modified to do\n-      \/\/ self-suspension if the blocking condition releases. We also\n-      \/\/ used to check for CONDVAR_WAIT here, but that is now covered by\n-      \/\/ the _thread_blocked with self-suspension check.\n-      \/\/\n-      \/\/ Return true since we wouldn't be here unless there was still an\n-      \/\/ external suspend request.\n-      *bits |= 0x00001000;\n-      return true;\n-    } else if (save_state == _thread_in_native && frame_anchor()->walkable()) {\n-      \/\/ Threads running native code will self-suspend on native==>VM\/Java\n-      \/\/ transitions. If its stack is walkable (should always be the case\n-      \/\/ unless this function is called before the actual java_suspend()\n-      \/\/ call), then the wait is done.\n-      *bits |= 0x00002000;\n-      return true;\n-    } else if (!called_by_wait && !did_trans_retry &&\n-               save_state == _thread_in_native_trans &&\n-               frame_anchor()->walkable()) {\n-      \/\/ The thread is transitioning from thread_in_native to another\n-      \/\/ thread state. check_safepoint_and_suspend_for_native_trans()\n-      \/\/ will force the thread to self-suspend. If it hasn't gotten\n-      \/\/ there yet we may have caught the thread in-between the native\n-      \/\/ code check above and the self-suspend. Lucky us. If we were\n-      \/\/ called by wait_for_ext_suspend_completion(), then it\n-      \/\/ will be doing the retries so we don't have to.\n-      \/\/\n-      \/\/ Since we use the saved thread state in the if-statement above,\n-      \/\/ there is a chance that the thread has already transitioned to\n-      \/\/ _thread_blocked by the time we get here. In that case, we will\n-      \/\/ make a single unnecessary pass through the logic below. This\n-      \/\/ doesn't hurt anything since we still do the trans retry.\n-\n-      *bits |= 0x00004000;\n-\n-      \/\/ Once the thread leaves thread_in_native_trans for another\n-      \/\/ thread state, we break out of this retry loop. We shouldn't\n-      \/\/ need this flag to prevent us from getting back here, but\n-      \/\/ sometimes paranoia is good.\n-      did_trans_retry = true;\n-\n-      \/\/ We wait for the thread to transition to a more usable state.\n-      for (int i = 1; i <= SuspendRetryCount; i++) {\n-        \/\/ We used to do an \"os::yield_all(i)\" call here with the intention\n-        \/\/ that yielding would increase on each retry. However, the parameter\n-        \/\/ is ignored on Linux which means the yield didn't scale up. Waiting\n-        \/\/ on the SR_lock below provides a much more predictable scale up for\n-        \/\/ the delay. It also provides a simple\/direct point to check for any\n-        \/\/ safepoint requests from the VMThread\n-\n-        \/\/ temporarily drops SR_lock while doing wait with safepoint check\n-        \/\/ (if we're a JavaThread - the WatcherThread can also call this)\n-        \/\/ and increase delay with each retry\n-        if (Thread::current()->is_Java_thread()) {\n-          SR_lock()->wait(i * delay);\n-        } else {\n-          SR_lock()->wait_without_safepoint_check(i * delay);\n-        }\n-\n-        \/\/ check the actual thread state instead of what we saved above\n-        if (thread_state() != _thread_in_native_trans) {\n-          \/\/ the thread has transitioned to another thread state so\n-          \/\/ try all the checks (except this one) one more time.\n-          do_trans_retry = true;\n-          break;\n-        }\n-      } \/\/ end retry loop\n-\n-\n-    }\n-  } while (do_trans_retry);\n-\n-  *bits |= 0x00000010;\n-  return false;\n-}\n-\n-\/\/ Wait for an external suspend request to complete (or be cancelled).\n-\/\/ Returns true if the thread is externally suspended and false otherwise.\n-\/\/\n-bool JavaThread::wait_for_ext_suspend_completion(int retries, int delay,\n-                                                 uint32_t *bits) {\n-  TraceSuspendDebugBits tsdb(this, true \/* is_wait *\/,\n-                             false \/* !called_by_wait *\/, bits);\n-\n-  \/\/ local flag copies to minimize SR_lock hold time\n-  bool is_suspended;\n-  bool pending;\n-  uint32_t reset_bits;\n-\n-  \/\/ set a marker so is_ext_suspend_completed() knows we are the caller\n-  *bits |= 0x00010000;\n-\n-  \/\/ We use reset_bits to reinitialize the bits value at the top of\n-  \/\/ each retry loop. This allows the caller to make use of any\n-  \/\/ unused bits for their own marking purposes.\n-  reset_bits = *bits;\n-\n-  {\n-    MutexLocker ml(SR_lock(), Mutex::_no_safepoint_check_flag);\n-    is_suspended = is_ext_suspend_completed(true \/* called_by_wait *\/,\n-                                            delay, bits);\n-    pending = is_external_suspend();\n-  }\n-  \/\/ must release SR_lock to allow suspension to complete\n-\n-  if (!pending) {\n-    \/\/ A cancelled suspend request is the only false return from\n-    \/\/ is_ext_suspend_completed() that keeps us from entering the\n-    \/\/ retry loop.\n-    *bits |= 0x00020000;\n-    return false;\n-  }\n-\n-  if (is_suspended) {\n-    *bits |= 0x00040000;\n-    return true;\n-  }\n-\n-  for (int i = 1; i <= retries; i++) {\n-    *bits = reset_bits;  \/\/ reinit to only track last retry\n-\n-    \/\/ We used to do an \"os::yield_all(i)\" call here with the intention\n-    \/\/ that yielding would increase on each retry. However, the parameter\n-    \/\/ is ignored on Linux which means the yield didn't scale up. Waiting\n-    \/\/ on the SR_lock below provides a much more predictable scale up for\n-    \/\/ the delay. It also provides a simple\/direct point to check for any\n-    \/\/ safepoint requests from the VMThread\n-\n-    {\n-      Thread* t = Thread::current();\n-      MonitorLocker ml(SR_lock(),\n-                       t->is_Java_thread() ? Mutex::_safepoint_check_flag : Mutex::_no_safepoint_check_flag);\n-      \/\/ wait with safepoint check (if we're a JavaThread - the WatcherThread\n-      \/\/ can also call this)  and increase delay with each retry\n-      ml.wait(i * delay);\n-\n-      is_suspended = is_ext_suspend_completed(true \/* called_by_wait *\/,\n-                                              delay, bits);\n-\n-      \/\/ It is possible for the external suspend request to be cancelled\n-      \/\/ (by a resume) before the actual suspend operation is completed.\n-      \/\/ Refresh our local copy to see if we still need to wait.\n-      pending = is_external_suspend();\n-    }\n-\n-    if (!pending) {\n-      \/\/ A cancelled suspend request is the only false return from\n-      \/\/ is_ext_suspend_completed() that keeps us from staying in the\n-      \/\/ retry loop.\n-      *bits |= 0x00080000;\n-      return false;\n-    }\n-\n-    if (is_suspended) {\n-      *bits |= 0x00100000;\n-      return true;\n-    }\n-  } \/\/ end retry loop\n-\n-  \/\/ thread did not suspend after all our retries\n-  *bits |= 0x00200000;\n-  return false;\n-}\n-\n-\/\/ Called from API entry points which perform stack walking. If the\n-\/\/ associated JavaThread is the current thread, then wait_for_suspend\n-\/\/ is not used. Otherwise, it determines if we should wait for the\n-\/\/ \"other\" thread to complete external suspension. (NOTE: in future\n-\/\/ releases the suspension mechanism should be reimplemented so this\n-\/\/ is not necessary.)\n-\/\/\n-bool\n-JavaThread::is_thread_fully_suspended(bool wait_for_suspend, uint32_t *bits) {\n-  if (this != JavaThread::current()) {\n-    \/\/ \"other\" threads require special handling.\n-    if (wait_for_suspend) {\n-      \/\/ We are allowed to wait for the external suspend to complete\n-      \/\/ so give the other thread a chance to get suspended.\n-      if (!wait_for_ext_suspend_completion(SuspendRetryCount,\n-                                           SuspendRetryDelay, bits)) {\n-        \/\/ Didn't make it so let the caller know.\n-        return false;\n-      }\n-    }\n-    \/\/ We aren't allowed to wait for the external suspend to complete\n-    \/\/ so if the other thread isn't externally suspended we need to\n-    \/\/ let the caller know.\n-    else if (!is_ext_suspend_completed_with_lock(bits)) {\n-      return false;\n-    }\n+  if (thread->is_Java_thread()) {\n+    \/\/ Initialize the thread state to RUNNABLE before starting this thread.\n+    \/\/ Can not set it after the thread started because we do not know the\n+    \/\/ exact thread state at that time. It could be in MONITOR_WAIT or\n+    \/\/ in SLEEPING or some other state.\n+    java_lang_Thread::set_thread_status(thread->as_Java_thread()->threadObj(),\n+                                        JavaThreadStatus::RUNNABLE);\n@@ -857,2 +542,1 @@\n-\n-  return true;\n+  os::start_thread(thread);\n@@ -874,2 +558,4 @@\n-void Thread::oops_do(OopClosure* f, CodeBlobClosure* cf) {\n-  active_handles()->oops_do(f);\n+void Thread::oops_do_no_frames(OopClosure* f, CodeBlobClosure* cf) {\n+  if (active_handles() != NULL) {\n+    active_handles()->oops_do(f);\n+  }\n@@ -879,0 +565,25 @@\n+}\n+\n+\/\/ If the caller is a NamedThread, then remember, in the current scope,\n+\/\/ the given JavaThread in its _processed_thread field.\n+class RememberProcessedThread: public StackObj {\n+  NamedThread* _cur_thr;\n+public:\n+  RememberProcessedThread(Thread* thread) {\n+    Thread* self = Thread::current();\n+    if (self->is_Named_thread()) {\n+      _cur_thr = (NamedThread *)self;\n+      assert(_cur_thr->processed_thread() == NULL, \"nesting not supported\");\n+      _cur_thr->set_processed_thread(thread);\n+    } else {\n+      _cur_thr = NULL;\n+    }\n+  }\n+\n+  ~RememberProcessedThread() {\n+    if (_cur_thr) {\n+      assert(_cur_thr->processed_thread() != NULL, \"nesting not supported\");\n+      _cur_thr->set_processed_thread(NULL);\n+    }\n+  }\n+};\n@@ -880,3 +591,5 @@\n-  \/\/ We scan thread local monitor lists here, and the remaining global\n-  \/\/ monitors in ObjectSynchronizer::oops_do().\n-  ObjectSynchronizer::thread_local_used_oops_do(this, f);\n+void Thread::oops_do(OopClosure* f, CodeBlobClosure* cf) {\n+  \/\/ Record JavaThread to GC thread\n+  RememberProcessedThread rpt(this);\n+  oops_do_no_frames(f, cf);\n+  oops_do_frames(f, cf);\n@@ -942,5 +655,11 @@\n-  st->print(\" [stack: \" PTR_FORMAT \",\" PTR_FORMAT \"]\",\n-            p2i(stack_end()), p2i(stack_base()));\n-\n-  if (osthread()) {\n-    st->print(\" [id=%d]\", osthread()->thread_id());\n+  OSThread* os_thr = osthread();\n+  if (os_thr != NULL) {\n+    if (os_thr->get_state() != ZOMBIE) {\n+      st->print(\" [stack: \" PTR_FORMAT \",\" PTR_FORMAT \"]\",\n+                p2i(stack_end()), p2i(stack_base()));\n+      st->print(\" [id=%d]\", osthread()->thread_id());\n+    } else {\n+      st->print(\" terminated\");\n+    }\n+  } else {\n+    st->print(\" unknown state (no osThread)\");\n@@ -948,1 +667,0 @@\n-\n@@ -972,32 +690,0 @@\n-\n-\/\/ Checks safepoint allowed and clears unhandled oops at potential safepoints.\n-void Thread::check_possible_safepoint() {\n-  if (!is_Java_thread()) return;\n-\n-  if (_no_safepoint_count > 0) {\n-    print_owned_locks();\n-    fatal(\"Possible safepoint reached by thread that does not allow it\");\n-  }\n-#ifdef CHECK_UNHANDLED_OOPS\n-  \/\/ Clear unhandled oops in JavaThreads so we get a crash right away.\n-  clear_unhandled_oops();\n-#endif \/\/ CHECK_UNHANDLED_OOPS\n-}\n-\n-void Thread::check_for_valid_safepoint_state() {\n-  if (!is_Java_thread()) return;\n-\n-  \/\/ Check NoSafepointVerifier, which is implied by locks taken that can be\n-  \/\/ shared with the VM thread.  This makes sure that no locks with allow_vm_block\n-  \/\/ are held.\n-  check_possible_safepoint();\n-\n-  if (((JavaThread*)this)->thread_state() != _thread_in_vm) {\n-    fatal(\"LEAF method calling lock?\");\n-  }\n-\n-  if (GCALotAtAllSafepoints) {\n-    \/\/ We could enter a safepoint here and thus have a gc\n-    InterfaceSupport::check_gc_alot();\n-  }\n-}\n@@ -1006,18 +692,0 @@\n-bool Thread::is_in_stack(address adr) const {\n-  assert(Thread::current() == this, \"is_in_stack can only be called from current thread\");\n-  address end = os::current_stack_pointer();\n-  \/\/ Allow non Java threads to call this without stack_base\n-  if (_stack_base == NULL) return true;\n-  if (stack_base() > adr && adr >= end) return true;\n-\n-  return false;\n-}\n-\n-bool Thread::is_in_usable_stack(address adr) const {\n-  size_t stack_guard_size = os::uses_stack_guard_pages() ? JavaThread::stack_guard_zone_size() : 0;\n-  size_t usable_stack_size = _stack_size - stack_guard_size;\n-\n-  return ((adr < stack_base()) && (adr >= stack_base() - usable_stack_size));\n-}\n-\n-\n@@ -1030,1 +698,1 @@\n-  return on_local_stack(adr);\n+  return is_in_full_stack(adr);\n@@ -1038,1 +706,1 @@\n-  return os::create_main_thread((JavaThread*)this);\n+  return os::create_main_thread(this->as_Java_thread());\n@@ -1050,1 +718,1 @@\n-                            SystemDictionary::ThreadGroup_klass(),\n+                            vmClasses::ThreadGroup_klass(),\n@@ -1057,1 +725,1 @@\n-                            SystemDictionary::ThreadGroup_klass(),\n+                            vmClasses::ThreadGroup_klass(),\n@@ -1065,2 +733,2 @@\n-\/\/ Creates the initial Thread\n-static oop create_initial_thread(Handle thread_group, JavaThread* thread,\n+\/\/ Creates the initial Thread, and sets it to running.\n+static void create_initial_thread(Handle thread_group, JavaThread* thread,\n@@ -1068,1 +736,1 @@\n-  InstanceKlass* ik = SystemDictionary::Thread_klass();\n+  InstanceKlass* ik = vmClasses::Thread_klass();\n@@ -1070,1 +738,1 @@\n-  instanceHandle thread_oop = ik->allocate_instance_handle(CHECK_NULL);\n+  instanceHandle thread_oop = ik->allocate_instance_handle(CHECK);\n@@ -1079,1 +747,1 @@\n-  Handle string = java_lang_String::create_from_str(\"main\", CHECK_NULL);\n+  Handle string = java_lang_String::create_from_str(\"main\", CHECK);\n@@ -1088,8 +756,1 @@\n-                          CHECK_NULL);\n-  return thread_oop();\n-}\n-\n-char java_runtime_name[128] = \"\";\n-char java_runtime_version[128] = \"\";\n-char java_runtime_vendor_version[128] = \"\";\n-char java_runtime_vendor_vm_bug_url[128] = \"\";\n+                          CHECK);\n@@ -1097,64 +758,4 @@\n-\/\/ extract the JRE name from java.lang.VersionProps.java_runtime_name\n-static const char* get_java_runtime_name(TRAPS) {\n-  Klass* k = SystemDictionary::find(vmSymbols::java_lang_VersionProps(),\n-                                    Handle(), Handle(), CHECK_AND_CLEAR_NULL);\n-  fieldDescriptor fd;\n-  bool found = k != NULL &&\n-               InstanceKlass::cast(k)->find_local_field(vmSymbols::java_runtime_name_name(),\n-                                                        vmSymbols::string_signature(), &fd);\n-  if (found) {\n-    oop name_oop = k->java_mirror()->obj_field(fd.offset());\n-    if (name_oop == NULL) {\n-      return NULL;\n-    }\n-    const char* name = java_lang_String::as_utf8_string(name_oop,\n-                                                        java_runtime_name,\n-                                                        sizeof(java_runtime_name));\n-    return name;\n-  } else {\n-    return NULL;\n-  }\n-}\n-\n-\/\/ extract the JRE version from java.lang.VersionProps.java_runtime_version\n-static const char* get_java_runtime_version(TRAPS) {\n-  Klass* k = SystemDictionary::find(vmSymbols::java_lang_VersionProps(),\n-                                    Handle(), Handle(), CHECK_AND_CLEAR_NULL);\n-  fieldDescriptor fd;\n-  bool found = k != NULL &&\n-               InstanceKlass::cast(k)->find_local_field(vmSymbols::java_runtime_version_name(),\n-                                                        vmSymbols::string_signature(), &fd);\n-  if (found) {\n-    oop name_oop = k->java_mirror()->obj_field(fd.offset());\n-    if (name_oop == NULL) {\n-      return NULL;\n-    }\n-    const char* name = java_lang_String::as_utf8_string(name_oop,\n-                                                        java_runtime_version,\n-                                                        sizeof(java_runtime_version));\n-    return name;\n-  } else {\n-    return NULL;\n-  }\n-}\n-\n-\/\/ extract the JRE vendor version from java.lang.VersionProps.VENDOR_VERSION\n-static const char* get_java_runtime_vendor_version(TRAPS) {\n-  Klass* k = SystemDictionary::find(vmSymbols::java_lang_VersionProps(),\n-                                    Handle(), Handle(), CHECK_AND_CLEAR_NULL);\n-  fieldDescriptor fd;\n-  bool found = k != NULL &&\n-               InstanceKlass::cast(k)->find_local_field(vmSymbols::java_runtime_vendor_version_name(),\n-                                                        vmSymbols::string_signature(), &fd);\n-  if (found) {\n-    oop name_oop = k->java_mirror()->obj_field(fd.offset());\n-    if (name_oop == NULL) {\n-      return NULL;\n-    }\n-    const char* name = java_lang_String::as_utf8_string(name_oop,\n-                                                        java_runtime_vendor_version,\n-                                                        sizeof(java_runtime_vendor_version));\n-    return name;\n-  } else {\n-    return NULL;\n-  }\n+  \/\/ Set thread status to running since main thread has\n+  \/\/ been started and running.\n+  java_lang_Thread::set_thread_status(thread_oop(),\n+                                      JavaThreadStatus::RUNNABLE);\n@@ -1163,4 +764,6 @@\n-\/\/ extract the JRE vendor VM bug URL from java.lang.VersionProps.VENDOR_URL_VM_BUG\n-static const char* get_java_runtime_vendor_vm_bug_url(TRAPS) {\n-  Klass* k = SystemDictionary::find(vmSymbols::java_lang_VersionProps(),\n-                                    Handle(), Handle(), CHECK_AND_CLEAR_NULL);\n+\/\/ Extract version and vendor specific information from\n+\/\/ java.lang.VersionProps fields.\n+\/\/ Returned char* is allocated in the thread's resource area\n+\/\/ so must be copied for permanency.\n+static const char* get_java_version_info(InstanceKlass* ik,\n+                                         Symbol* field_name) {\n@@ -1168,3 +771,3 @@\n-  bool found = k != NULL &&\n-               InstanceKlass::cast(k)->find_local_field(vmSymbols::java_runtime_vendor_vm_bug_url_name(),\n-                                                        vmSymbols::string_signature(), &fd);\n+  bool found = ik != NULL &&\n+               ik->find_local_field(field_name,\n+                                    vmSymbols::string_signature(), &fd);\n@@ -1172,1 +775,1 @@\n-    oop name_oop = k->java_mirror()->obj_field(fd.offset());\n+    oop name_oop = ik->java_mirror()->obj_field(fd.offset());\n@@ -1176,3 +779,1 @@\n-    const char* name = java_lang_String::as_utf8_string(name_oop,\n-                                                        java_runtime_vendor_vm_bug_url,\n-                                                        sizeof(java_runtime_vendor_vm_bug_url));\n+    const char* name = java_lang_String::as_utf8_string(name_oop);\n@@ -1197,0 +798,17 @@\n+\/\/ Initialized by VMThread at vm_global_init\n+static OopStorage* _thread_oop_storage = NULL;\n+\n+oop  JavaThread::threadObj() const    {\n+  return _threadObj.resolve();\n+}\n+\n+void JavaThread::set_threadObj(oop p) {\n+  assert(_thread_oop_storage != NULL, \"not yet initialized\");\n+  _threadObj = OopHandle(_thread_oop_storage, p);\n+}\n+\n+OopStorage* JavaThread::thread_oop_storage() {\n+  assert(_thread_oop_storage != NULL, \"not yet initialized\");\n+  return _thread_oop_storage;\n+}\n+\n@@ -1202,1 +820,1 @@\n-  InstanceKlass* ik = SystemDictionary::Thread_klass();\n+  InstanceKlass* ik = vmClasses::Thread_klass();\n@@ -1247,1 +865,1 @@\n-  Klass* group =  SystemDictionary::ThreadGroup_klass();\n+  Klass* group = vmClasses::ThreadGroup_klass();\n@@ -1259,300 +877,0 @@\n-\/\/ List of all NonJavaThreads and safe iteration over that list.\n-\n-class NonJavaThread::List {\n-public:\n-  NonJavaThread* volatile _head;\n-  SingleWriterSynchronizer _protect;\n-\n-  List() : _head(NULL), _protect() {}\n-};\n-\n-NonJavaThread::List NonJavaThread::_the_list;\n-\n-NonJavaThread::Iterator::Iterator() :\n-  _protect_enter(_the_list._protect.enter()),\n-  _current(Atomic::load_acquire(&_the_list._head))\n-{}\n-\n-NonJavaThread::Iterator::~Iterator() {\n-  _the_list._protect.exit(_protect_enter);\n-}\n-\n-void NonJavaThread::Iterator::step() {\n-  assert(!end(), \"precondition\");\n-  _current = Atomic::load_acquire(&_current->_next);\n-}\n-\n-NonJavaThread::NonJavaThread() : Thread(), _next(NULL) {\n-  assert(BarrierSet::barrier_set() != NULL, \"NonJavaThread created too soon!\");\n-}\n-\n-NonJavaThread::~NonJavaThread() { }\n-\n-void NonJavaThread::add_to_the_list() {\n-  MutexLocker ml(NonJavaThreadsList_lock, Mutex::_no_safepoint_check_flag);\n-  \/\/ Initialize BarrierSet-related data before adding to list.\n-  BarrierSet::barrier_set()->on_thread_attach(this);\n-  Atomic::release_store(&_next, _the_list._head);\n-  Atomic::release_store(&_the_list._head, this);\n-}\n-\n-void NonJavaThread::remove_from_the_list() {\n-  {\n-    MutexLocker ml(NonJavaThreadsList_lock, Mutex::_no_safepoint_check_flag);\n-    \/\/ Cleanup BarrierSet-related data before removing from list.\n-    BarrierSet::barrier_set()->on_thread_detach(this);\n-    NonJavaThread* volatile* p = &_the_list._head;\n-    for (NonJavaThread* t = *p; t != NULL; p = &t->_next, t = *p) {\n-      if (t == this) {\n-        *p = _next;\n-        break;\n-      }\n-    }\n-  }\n-  \/\/ Wait for any in-progress iterators.  Concurrent synchronize is not\n-  \/\/ allowed, so do it while holding a dedicated lock.  Outside and distinct\n-  \/\/ from NJTList_lock in case an iteration attempts to lock it.\n-  MutexLocker ml(NonJavaThreadsListSync_lock, Mutex::_no_safepoint_check_flag);\n-  _the_list._protect.synchronize();\n-  _next = NULL;                 \/\/ Safe to drop the link now.\n-}\n-\n-void NonJavaThread::pre_run() {\n-  add_to_the_list();\n-\n-  \/\/ This is slightly odd in that NamedThread is a subclass, but\n-  \/\/ in fact name() is defined in Thread\n-  assert(this->name() != NULL, \"thread name was not set before it was started\");\n-  this->set_native_thread_name(this->name());\n-}\n-\n-void NonJavaThread::post_run() {\n-  JFR_ONLY(Jfr::on_thread_exit(this);)\n-  remove_from_the_list();\n-  \/\/ Ensure thread-local-storage is cleared before termination.\n-  Thread::clear_thread_current();\n-}\n-\n-\/\/ NamedThread --  non-JavaThread subclasses with multiple\n-\/\/ uniquely named instances should derive from this.\n-NamedThread::NamedThread() :\n-  NonJavaThread(),\n-  _name(NULL),\n-  _processed_thread(NULL),\n-  _gc_id(GCId::undefined())\n-{}\n-\n-NamedThread::~NamedThread() {\n-  FREE_C_HEAP_ARRAY(char, _name);\n-}\n-\n-void NamedThread::set_name(const char* format, ...) {\n-  guarantee(_name == NULL, \"Only get to set name once.\");\n-  _name = NEW_C_HEAP_ARRAY(char, max_name_len, mtThread);\n-  va_list ap;\n-  va_start(ap, format);\n-  jio_vsnprintf(_name, max_name_len, format, ap);\n-  va_end(ap);\n-}\n-\n-void NamedThread::print_on(outputStream* st) const {\n-  st->print(\"\\\"%s\\\" \", name());\n-  Thread::print_on(st);\n-  st->cr();\n-}\n-\n-\n-\/\/ ======= WatcherThread ========\n-\n-\/\/ The watcher thread exists to simulate timer interrupts.  It should\n-\/\/ be replaced by an abstraction over whatever native support for\n-\/\/ timer interrupts exists on the platform.\n-\n-WatcherThread* WatcherThread::_watcher_thread   = NULL;\n-bool WatcherThread::_startable = false;\n-volatile bool  WatcherThread::_should_terminate = false;\n-\n-WatcherThread::WatcherThread() : NonJavaThread() {\n-  assert(watcher_thread() == NULL, \"we can only allocate one WatcherThread\");\n-  if (os::create_thread(this, os::watcher_thread)) {\n-    _watcher_thread = this;\n-\n-    \/\/ Set the watcher thread to the highest OS priority which should not be\n-    \/\/ used, unless a Java thread with priority java.lang.Thread.MAX_PRIORITY\n-    \/\/ is created. The only normal thread using this priority is the reference\n-    \/\/ handler thread, which runs for very short intervals only.\n-    \/\/ If the VMThread's priority is not lower than the WatcherThread profiling\n-    \/\/ will be inaccurate.\n-    os::set_priority(this, MaxPriority);\n-    if (!DisableStartThread) {\n-      os::start_thread(this);\n-    }\n-  }\n-}\n-\n-int WatcherThread::sleep() const {\n-  \/\/ The WatcherThread does not participate in the safepoint protocol\n-  \/\/ for the PeriodicTask_lock because it is not a JavaThread.\n-  MonitorLocker ml(PeriodicTask_lock, Mutex::_no_safepoint_check_flag);\n-\n-  if (_should_terminate) {\n-    \/\/ check for termination before we do any housekeeping or wait\n-    return 0;  \/\/ we did not sleep.\n-  }\n-\n-  \/\/ remaining will be zero if there are no tasks,\n-  \/\/ causing the WatcherThread to sleep until a task is\n-  \/\/ enrolled\n-  int remaining = PeriodicTask::time_to_wait();\n-  int time_slept = 0;\n-\n-  \/\/ we expect this to timeout - we only ever get unparked when\n-  \/\/ we should terminate or when a new task has been enrolled\n-  OSThreadWaitState osts(this->osthread(), false \/* not Object.wait() *\/);\n-\n-  jlong time_before_loop = os::javaTimeNanos();\n-\n-  while (true) {\n-    bool timedout = ml.wait(remaining);\n-    jlong now = os::javaTimeNanos();\n-\n-    if (remaining == 0) {\n-      \/\/ if we didn't have any tasks we could have waited for a long time\n-      \/\/ consider the time_slept zero and reset time_before_loop\n-      time_slept = 0;\n-      time_before_loop = now;\n-    } else {\n-      \/\/ need to recalculate since we might have new tasks in _tasks\n-      time_slept = (int) ((now - time_before_loop) \/ 1000000);\n-    }\n-\n-    \/\/ Change to task list or spurious wakeup of some kind\n-    if (timedout || _should_terminate) {\n-      break;\n-    }\n-\n-    remaining = PeriodicTask::time_to_wait();\n-    if (remaining == 0) {\n-      \/\/ Last task was just disenrolled so loop around and wait until\n-      \/\/ another task gets enrolled\n-      continue;\n-    }\n-\n-    remaining -= time_slept;\n-    if (remaining <= 0) {\n-      break;\n-    }\n-  }\n-\n-  return time_slept;\n-}\n-\n-void WatcherThread::run() {\n-  assert(this == watcher_thread(), \"just checking\");\n-\n-  this->set_active_handles(JNIHandleBlock::allocate_block());\n-  while (true) {\n-    assert(watcher_thread() == Thread::current(), \"thread consistency check\");\n-    assert(watcher_thread() == this, \"thread consistency check\");\n-\n-    \/\/ Calculate how long it'll be until the next PeriodicTask work\n-    \/\/ should be done, and sleep that amount of time.\n-    int time_waited = sleep();\n-\n-    if (VMError::is_error_reported()) {\n-      \/\/ A fatal error has happened, the error handler(VMError::report_and_die)\n-      \/\/ should abort JVM after creating an error log file. However in some\n-      \/\/ rare cases, the error handler itself might deadlock. Here periodically\n-      \/\/ check for error reporting timeouts, and if it happens, just proceed to\n-      \/\/ abort the VM.\n-\n-      \/\/ This code is in WatcherThread because WatcherThread wakes up\n-      \/\/ periodically so the fatal error handler doesn't need to do anything;\n-      \/\/ also because the WatcherThread is less likely to crash than other\n-      \/\/ threads.\n-\n-      for (;;) {\n-        \/\/ Note: we use naked sleep in this loop because we want to avoid using\n-        \/\/ any kind of VM infrastructure which may be broken at this point.\n-        if (VMError::check_timeout()) {\n-          \/\/ We hit error reporting timeout. Error reporting was interrupted and\n-          \/\/ will be wrapping things up now (closing files etc). Give it some more\n-          \/\/ time, then quit the VM.\n-          os::naked_short_sleep(200);\n-          \/\/ Print a message to stderr.\n-          fdStream err(defaultStream::output_fd());\n-          err.print_raw_cr(\"# [ timer expired, abort... ]\");\n-          \/\/ skip atexit\/vm_exit\/vm_abort hooks\n-          os::die();\n-        }\n-\n-        \/\/ Wait a second, then recheck for timeout.\n-        os::naked_short_sleep(999);\n-      }\n-    }\n-\n-    if (_should_terminate) {\n-      \/\/ check for termination before posting the next tick\n-      break;\n-    }\n-\n-    PeriodicTask::real_time_tick(time_waited);\n-  }\n-\n-  \/\/ Signal that it is terminated\n-  {\n-    MutexLocker mu(Terminator_lock, Mutex::_no_safepoint_check_flag);\n-    _watcher_thread = NULL;\n-    Terminator_lock->notify_all();\n-  }\n-}\n-\n-void WatcherThread::start() {\n-  assert(PeriodicTask_lock->owned_by_self(), \"PeriodicTask_lock required\");\n-\n-  if (watcher_thread() == NULL && _startable) {\n-    _should_terminate = false;\n-    \/\/ Create the single instance of WatcherThread\n-    new WatcherThread();\n-  }\n-}\n-\n-void WatcherThread::make_startable() {\n-  assert(PeriodicTask_lock->owned_by_self(), \"PeriodicTask_lock required\");\n-  _startable = true;\n-}\n-\n-void WatcherThread::stop() {\n-  {\n-    \/\/ Follow normal safepoint aware lock enter protocol since the\n-    \/\/ WatcherThread is stopped by another JavaThread.\n-    MutexLocker ml(PeriodicTask_lock);\n-    _should_terminate = true;\n-\n-    WatcherThread* watcher = watcher_thread();\n-    if (watcher != NULL) {\n-      \/\/ unpark the WatcherThread so it can see that it should terminate\n-      watcher->unpark();\n-    }\n-  }\n-\n-  MonitorLocker mu(Terminator_lock);\n-\n-  while (watcher_thread() != NULL) {\n-    \/\/ This wait should make safepoint checks, wait without a timeout,\n-    \/\/ and wait as a suspend-equivalent condition.\n-    mu.wait(0, Mutex::_as_suspend_equivalent_flag);\n-  }\n-}\n-\n-void WatcherThread::unpark() {\n-  assert(PeriodicTask_lock->owned_by_self(), \"PeriodicTask_lock required\");\n-  PeriodicTask_lock->notify();\n-}\n-\n-void WatcherThread::print_on(outputStream* st) const {\n-  st->print(\"\\\"%s\\\" \", name());\n-  Thread::print_on(st);\n-  st->cr();\n-}\n-\n@@ -1585,1 +903,4 @@\n-  jlong* new_counters = NEW_C_HEAP_ARRAY(jlong, new_size, mtJVMCI);\n+  jlong* new_counters = NEW_C_HEAP_ARRAY_RETURN_NULL(jlong, new_size, mtJVMCI);\n+  if (new_counters == NULL) {\n+    return NULL;\n+  }\n@@ -1598,1 +919,83 @@\n-  return new_counters;\n+  return new_counters;\n+}\n+\n+\/\/ Attempt to enlarge the array for per thread counters.\n+bool JavaThread::resize_counters(int current_size, int new_size) {\n+  jlong* new_counters = resize_counters_array(_jvmci_counters, current_size, new_size);\n+  if (new_counters == NULL) {\n+    return false;\n+  } else {\n+    _jvmci_counters = new_counters;\n+    return true;\n+  }\n+}\n+\n+class VM_JVMCIResizeCounters : public VM_Operation {\n+ private:\n+  int _new_size;\n+  bool _failed;\n+\n+ public:\n+  VM_JVMCIResizeCounters(int new_size) : _new_size(new_size), _failed(false) { }\n+  VMOp_Type type()                  const        { return VMOp_JVMCIResizeCounters; }\n+  bool allow_nested_vm_operations() const        { return true; }\n+  void doit() {\n+    \/\/ Resize the old thread counters array\n+    jlong* new_counters = resize_counters_array(JavaThread::_jvmci_old_thread_counters, JVMCICounterSize, _new_size);\n+    if (new_counters == NULL) {\n+      _failed = true;\n+      return;\n+    } else {\n+      JavaThread::_jvmci_old_thread_counters = new_counters;\n+    }\n+\n+    \/\/ Now resize each threads array\n+    for (JavaThreadIteratorWithHandle jtiwh; JavaThread *tp = jtiwh.next(); ) {\n+      if (!tp->resize_counters(JVMCICounterSize, _new_size)) {\n+        _failed = true;\n+        break;\n+      }\n+    }\n+    if (!_failed) {\n+      JVMCICounterSize = _new_size;\n+    }\n+  }\n+\n+  bool failed() { return _failed; }\n+};\n+\n+bool JavaThread::resize_all_jvmci_counters(int new_size) {\n+  VM_JVMCIResizeCounters op(new_size);\n+  VMThread::execute(&op);\n+  return !op.failed();\n+}\n+\n+#endif \/\/ INCLUDE_JVMCI\n+\n+#ifdef ASSERT\n+\/\/ Checks safepoint allowed and clears unhandled oops at potential safepoints.\n+void JavaThread::check_possible_safepoint() {\n+  if (_no_safepoint_count > 0) {\n+    print_owned_locks();\n+    assert(false, \"Possible safepoint reached by thread that does not allow it\");\n+  }\n+#ifdef CHECK_UNHANDLED_OOPS\n+  \/\/ Clear unhandled oops in JavaThreads so we get a crash right away.\n+  clear_unhandled_oops();\n+#endif \/\/ CHECK_UNHANDLED_OOPS\n+}\n+\n+void JavaThread::check_for_valid_safepoint_state() {\n+  \/\/ Check NoSafepointVerifier, which is implied by locks taken that can be\n+  \/\/ shared with the VM thread.  This makes sure that no locks with allow_vm_block\n+  \/\/ are held.\n+  check_possible_safepoint();\n+\n+  if (thread_state() != _thread_in_vm) {\n+    fatal(\"LEAF method calling lock?\");\n+  }\n+\n+  if (GCALotAtAllSafepoints) {\n+    \/\/ We could enter a safepoint here and thus have a gc\n+    InterfaceSupport::check_gc_alot();\n+  }\n@@ -1600,0 +1003,1 @@\n+#endif \/\/ ASSERT\n@@ -1601,4 +1005,1 @@\n-\/\/ Attempt to enlarge the array for per thread counters.\n-void JavaThread::resize_counters(int current_size, int new_size) {\n-  _jvmci_counters = resize_counters_array(_jvmci_counters, current_size, new_size);\n-}\n+\/\/ A JavaThread is a normal Java thread\n@@ -1606,3 +1007,2 @@\n-class VM_JVMCIResizeCounters : public VM_Operation {\n- private:\n-  int _new_size;\n+JavaThread::JavaThread() :\n+  \/\/ Initialize fields\n@@ -1610,8 +1010,29 @@\n- public:\n-  VM_JVMCIResizeCounters(int new_size) : _new_size(new_size) { }\n-  VMOp_Type type()                  const        { return VMOp_JVMCIResizeCounters; }\n-  bool allow_nested_vm_operations() const        { return true; }\n-  void doit() {\n-    \/\/ Resize the old thread counters array\n-    jlong* new_counters = resize_counters_array(JavaThread::_jvmci_old_thread_counters, JVMCICounterSize, _new_size);\n-    JavaThread::_jvmci_old_thread_counters = new_counters;\n+  _on_thread_list(false),\n+  DEBUG_ONLY(_java_call_counter(0) COMMA)\n+  _entry_point(nullptr),\n+  _deopt_mark(nullptr),\n+  _deopt_nmethod(nullptr),\n+  _vframe_array_head(nullptr),\n+  _vframe_array_last(nullptr),\n+  _jvmti_deferred_updates(nullptr),\n+  _callee_target(nullptr),\n+  _vm_result(nullptr),\n+  _vm_result_2(nullptr),\n+\n+  _current_pending_monitor(NULL),\n+  _current_pending_monitor_is_from_java(true),\n+  _current_waiting_monitor(NULL),\n+  _Stalled(0),\n+\n+  _monitor_chunks(nullptr),\n+\n+  _suspend_flags(0),\n+  _async_exception_condition(_no_async_condition),\n+  _pending_async_exception(nullptr),\n+\n+  _thread_state(_thread_new),\n+  _saved_exception_pc(nullptr),\n+#ifdef ASSERT\n+  _no_safepoint_count(0),\n+  _visited_for_critical_count(false),\n+#endif\n@@ -1619,7 +1040,17 @@\n-    \/\/ Now resize each threads array\n-    for (JavaThreadIteratorWithHandle jtiwh; JavaThread *tp = jtiwh.next(); ) {\n-      tp->resize_counters(JVMCICounterSize, _new_size);\n-    }\n-    JVMCICounterSize = _new_size;\n-  }\n-};\n+  _terminated(_not_terminated),\n+  _in_deopt_handler(0),\n+  _doing_unsafe_access(false),\n+  _do_not_unlock_if_synchronized(false),\n+  _jni_attach_state(_not_attaching_via_jni),\n+#if INCLUDE_JVMCI\n+  _pending_deoptimization(-1),\n+  _pending_monitorenter(false),\n+  _pending_transfer_to_interpreter(false),\n+  _in_retryable_allocation(false),\n+  _pending_failed_speculation(0),\n+  _jvmci{nullptr},\n+  _jvmci_counters(nullptr),\n+  _jvmci_reserved0(nullptr),\n+  _jvmci_reserved1(nullptr),\n+  _jvmci_reserved_oop0(nullptr),\n+#endif \/\/ INCLUDE_JVMCI\n@@ -1627,4 +1058,4 @@\n-void JavaThread::resize_all_jvmci_counters(int new_size) {\n-  VM_JVMCIResizeCounters op(new_size);\n-  VMThread::execute(&op);\n-}\n+  _exception_oop(oop()),\n+  _exception_pc(0),\n+  _exception_handler_pc(0),\n+  _is_method_handle_return(0),\n@@ -1632,1 +1063,3 @@\n-#endif \/\/ INCLUDE_JVMCI\n+  _jni_active_critical(0),\n+  _pending_jni_exception_check_fn(nullptr),\n+  _depth_first_number(0),\n@@ -1634,1 +1067,3 @@\n-\/\/ A JavaThread is a normal Java thread\n+  \/\/ JVMTI PopFrame support\n+  _popframe_condition(popframe_inactive),\n+  _frames_to_pop_failed_realloc(0),\n@@ -1636,2 +1071,9 @@\n-void JavaThread::initialize() {\n-  \/\/ Initialize fields\n+  _handshake(this),\n+\n+  _popframe_preserved_args(nullptr),\n+  _popframe_preserved_args_size(0),\n+\n+  _jvmti_thread_state(nullptr),\n+  _interp_only_mode(0),\n+  _should_post_on_exceptions_flag(JNI_FALSE),\n+  _thread_stat(new ThreadStatistics()),\n@@ -1639,4 +1081,7 @@\n-  set_saved_exception_pc(NULL);\n-  set_threadObj(NULL);\n-  _anchor.clear();\n-  set_entry_point(NULL);\n+  _parker(),\n+  _cached_monitor_info(nullptr),\n+\n+  _class_to_be_initialized(nullptr),\n+\n+  _SleepEvent(ParkEvent::Allocate(this))\n+{\n@@ -1644,17 +1089,1 @@\n-  set_callee_target(NULL);\n-  set_vm_result(NULL);\n-  set_vm_result_2(NULL);\n-  set_vframe_array_head(NULL);\n-  set_vframe_array_last(NULL);\n-  set_deferred_locals(NULL);\n-  set_deopt_mark(NULL);\n-  set_deopt_compiled_method(NULL);\n-  set_monitor_chunks(NULL);\n-  _on_thread_list = false;\n-  _thread_state = _thread_new;\n-  _terminated = _not_terminated;\n-  _array_for_gc = NULL;\n-  _suspend_equivalent = false;\n-  _in_deopt_handler = 0;\n-  _doing_unsafe_access = false;\n-  _stack_guard_state = stack_guard_unused;\n+\n@@ -1662,8 +1091,1 @@\n-  _pending_monitorenter = false;\n-  _pending_deoptimization = -1;\n-  _pending_failed_speculation = 0;\n-  _pending_transfer_to_interpreter = false;\n-  _in_retryable_allocation = false;\n-  _jvmci._alternate_call_target = NULL;\n-  assert(_jvmci._implicit_exception_pc == NULL, \"must be\");\n-  _jvmci_counters = NULL;\n+  assert(_jvmci._implicit_exception_pc == nullptr, \"must be\");\n@@ -1674,18 +1096,1 @@\n-  _reserved_stack_activation = NULL;  \/\/ stack base not known yet\n-  (void)const_cast<oop&>(_exception_oop = oop(NULL));\n-  _exception_pc  = 0;\n-  _exception_handler_pc = 0;\n-  _is_method_handle_return = 0;\n-  _jvmti_thread_state= NULL;\n-  _should_post_on_exceptions_flag = JNI_FALSE;\n-  _interp_only_mode    = 0;\n-  _special_runtime_exit_condition = _no_async_condition;\n-  _pending_async_exception = NULL;\n-  _thread_stat = NULL;\n-  _thread_stat = new ThreadStatistics();\n-  _jni_active_critical = 0;\n-  _pending_jni_exception_check_fn = NULL;\n-  _do_not_unlock_if_synchronized = false;\n-  _cached_monitor_info = NULL;\n-  _parker = Parker::Allocate(this);\n-  _SleepEvent = ParkEvent::Allocate(this);\n+\n@@ -1695,1 +1100,1 @@\n-  debug_only(_java_call_counter = 0);\n+  SafepointMechanism::initialize_header(this);\n@@ -1697,11 +1102,1 @@\n-  \/\/ JVMTI PopFrame support\n-  _popframe_condition = popframe_inactive;\n-  _popframe_preserved_args = NULL;\n-  _popframe_preserved_args_size = 0;\n-  _frames_to_pop_failed_realloc = 0;\n-\n-  if (SafepointMechanism::uses_thread_local_poll()) {\n-    SafepointMechanism::initialize_header(this);\n-  }\n-\n-  _class_to_be_initialized = NULL;\n+  set_requires_cross_modify_fence(false);\n@@ -1710,0 +1105,1 @@\n+  assert(deferred_card_mark().is_empty(), \"Default MemRegion ctor\");\n@@ -1712,3 +1108,1 @@\n-JavaThread::JavaThread(bool is_attaching_via_jni) :\n-                       Thread() {\n-  initialize();\n+JavaThread::JavaThread(bool is_attaching_via_jni) : JavaThread() {\n@@ -1717,3 +1111,0 @@\n-  } else {\n-    _jni_attach_state = _not_attaching_via_jni;\n-  assert(deferred_card_mark().is_empty(), \"Default MemRegion ctor\");\n@@ -1727,0 +1118,3 @@\n+  \/\/ All callers should have 'this' thread protected by a\n+  \/\/ ThreadsListHandle so that it cannot terminate and deallocate\n+  \/\/ itself.\n@@ -1746,1 +1140,1 @@\n-  if (threadObj() == NULL) {\n+  if (_threadObj.peek() == NULL) {\n@@ -1781,37 +1175,0 @@\n-bool JavaThread::reguard_stack(address cur_sp) {\n-  if (_stack_guard_state != stack_guard_yellow_reserved_disabled\n-      && _stack_guard_state != stack_guard_reserved_disabled) {\n-    return true; \/\/ Stack already guarded or guard pages not needed.\n-  }\n-\n-  if (register_stack_overflow()) {\n-    \/\/ For those architectures which have separate register and\n-    \/\/ memory stacks, we must check the register stack to see if\n-    \/\/ it has overflowed.\n-    return false;\n-  }\n-\n-  \/\/ Java code never executes within the yellow zone: the latter is only\n-  \/\/ there to provoke an exception during stack banging.  If java code\n-  \/\/ is executing there, either StackShadowPages should be larger, or\n-  \/\/ some exception code in c1, c2 or the interpreter isn't unwinding\n-  \/\/ when it should.\n-  guarantee(cur_sp > stack_reserved_zone_base(),\n-            \"not enough space to reguard - increase StackShadowPages\");\n-  if (_stack_guard_state == stack_guard_yellow_reserved_disabled) {\n-    enable_stack_yellow_reserved_zone();\n-    if (reserved_stack_activation() != stack_base()) {\n-      set_reserved_stack_activation(stack_base());\n-    }\n-  } else if (_stack_guard_state == stack_guard_reserved_disabled) {\n-    set_reserved_stack_activation(stack_base());\n-    enable_stack_reserved_zone();\n-  }\n-  return true;\n-}\n-\n-bool JavaThread::reguard_stack(void) {\n-  return reguard_stack(os::current_stack_pointer());\n-}\n-\n-\n@@ -1830,8 +1187,1 @@\n-\n-\/\/ Remove this ifdef when C1 is ported to the compiler interface.\n-static void compiler_thread_entry(JavaThread* thread, TRAPS);\n-static void sweeper_thread_entry(JavaThread* thread, TRAPS);\n-\n-JavaThread::JavaThread(ThreadFunction entry_point, size_t stack_sz) :\n-                       Thread() {\n-  initialize();\n+JavaThread::JavaThread(ThreadFunction entry_point, size_t stack_sz) : JavaThread() {\n@@ -1843,2 +1193,2 @@\n-  thr_type = entry_point == &compiler_thread_entry ? os::compiler_thread :\n-                                                     os::java_thread;\n+  thr_type = entry_point == &CompilerThread::thread_entry ? os::compiler_thread :\n+                                                            os::java_thread;\n@@ -1860,3 +1210,2 @@\n-  \/\/ JSR166 -- return the parker to the free list\n-  Parker::Release(_parker);\n-  _parker = NULL;\n+  \/\/ Ask ServiceThread to release the threadObj OopHandle\n+  ServiceThread::add_oop_handle_release(_threadObj);\n@@ -1878,2 +1227,2 @@\n-  GrowableArray<jvmtiDeferredLocalVariableSet*>* deferred = deferred_locals();\n-  if (deferred != NULL) {\n+  JvmtiDeferredUpdates* updates = deferred_updates();\n+  if (updates != NULL) {\n@@ -1881,8 +1230,4 @@\n-    assert(deferred->length() != 0, \"empty array!\");\n-    do {\n-      jvmtiDeferredLocalVariableSet* dlv = deferred->at(0);\n-      deferred->remove_at(0);\n-      \/\/ individual jvmtiDeferredLocalVariableSet are CHeapObj's\n-      delete dlv;\n-    } while (deferred->length() != 0);\n-    delete deferred;\n+    assert(updates->count() > 0, \"Updates holder not deleted\");\n+    \/\/ free deferred updates.\n+    delete updates;\n+    set_deferred_updates(NULL);\n@@ -1897,5 +1242,0 @@\n-    if (jvmci_counters_include(this)) {\n-      for (int i = 0; i < JVMCICounterSize; i++) {\n-        _jvmci_old_thread_counters[i] += _jvmci_counters[i];\n-      }\n-    }\n@@ -1918,1 +1258,1 @@\n-  this->initialize_tlab();\n+  initialize_tlab();\n@@ -1920,6 +1260,1 @@\n-  \/\/ Used to test validity of stack trace backs.\n-  \/\/ This can't be moved into pre_run() else we invalidate\n-  \/\/ the requirement that thread_main_inner is lower on\n-  \/\/ the stack. Consequently all the initialization logic\n-  \/\/ stays here in run() rather than pre_run().\n-  this->record_base_of_stack_pointer();\n+  _stack_overflow_state.create_stack_guard_pages();\n@@ -1927,3 +1262,1 @@\n-  this->create_stack_guard_pages();\n-\n-  this->cache_global_variables();\n+  cache_global_variables();\n@@ -1946,1 +1279,1 @@\n-  this->set_active_handles(JNIHandleBlock::allocate_block());\n+  set_active_handles(JNIHandleBlock::allocate_block());\n@@ -1960,1 +1293,1 @@\n-  assert(this->threadObj() != NULL, \"just checking\");\n+  assert(_threadObj.peek() != NULL, \"just checking\");\n@@ -1983,0 +1316,1 @@\n+  this->unregister_thread_stack_with_NMT();\n@@ -1996,1 +1330,1 @@\n-  java_lang_Thread::set_thread_status(threadObj(), java_lang_Thread::TERMINATED);\n+  java_lang_Thread::set_thread_status(threadObj(), JavaThreadStatus::TERMINATED);\n@@ -2029,6 +1363,0 @@\n-  \/\/ FIXIT: This code should be moved into else part, when reliable 1.2\/1.3 check is in place\n-  {\n-    EXCEPTION_MARK;\n-\n-    CLEAR_PENDING_EXCEPTION;\n-  }\n@@ -2039,1 +1367,1 @@\n-      Klass* thread_klass = SystemDictionary::Thread_klass();\n+      Klass* thread_klass = vmClasses::Thread_klass();\n@@ -2057,1 +1385,0 @@\n-    JFR_ONLY(Jfr::on_java_thread_dismantle(this);)\n@@ -2067,1 +1394,1 @@\n-        Klass* thread_klass = SystemDictionary::Thread_klass();\n+        Klass* thread_klass = vmClasses::Thread_klass();\n@@ -2081,20 +1408,4 @@\n-    \/\/ We have notified the agents that we are exiting, before we go on,\n-    \/\/ we must check for a pending external suspend request and honor it\n-    \/\/ in order to not surprise the thread that made the suspend request.\n-    while (true) {\n-      {\n-        MutexLocker ml(SR_lock(), Mutex::_no_safepoint_check_flag);\n-        if (!is_external_suspend()) {\n-          set_terminated(_thread_exiting);\n-          ThreadService::current_thread_exiting(this, is_daemon(threadObj()));\n-          break;\n-        }\n-        \/\/ Implied else:\n-        \/\/ Things get a little tricky here. We have a pending external\n-        \/\/ suspend request, but we are holding the SR_lock so we\n-        \/\/ can't just self-suspend. So we temporarily drop the lock\n-        \/\/ and then self-suspend.\n-      }\n-\n-      ThreadBlockInVM tbivm(this);\n-      java_suspend_self();\n+    \/\/ The careful dance between thread suspension and exit is handled here.\n+    \/\/ Since we are in thread_in_vm state and suspension is done with handshakes,\n+    \/\/ we can just put in the exiting state and it will be correctly handled.\n+    set_terminated(_thread_exiting);\n@@ -2102,6 +1413,1 @@\n-      \/\/ We're done with this suspend request, but we have to loop around\n-      \/\/ and check again. Eventually we will get SR_lock without a pending\n-      \/\/ external suspend request and will be able to mark ourselves as\n-      \/\/ exiting.\n-    }\n-    \/\/ no more external suspends are allowed at this point\n+    ThreadService::current_thread_exiting(this, is_daemon(threadObj()));\n@@ -2165,1 +1471,1 @@\n-  remove_stack_guard_pages();\n+  _stack_overflow_state.remove_stack_guard_pages();\n@@ -2175,4 +1481,7 @@\n-  \/\/ We must flush any deferred card marks and other various GC barrier\n-  \/\/ related buffers (e.g. G1 SATB buffer and G1 dirty card queue buffer)\n-  \/\/ before removing a thread from the list of active threads.\n-  BarrierSet::barrier_set()->on_thread_detach(this);\n+  \/\/ We need to cache the thread name for logging purposes below as once\n+  \/\/ we have called on_thread_detach this thread must not access any oops.\n+  char* thread_name = NULL;\n+  if (log_is_enabled(Debug, os, thread, timer)) {\n+    ResourceMark rm(this);\n+    thread_name = os::strdup(get_thread_name());\n+  }\n@@ -2188,0 +1497,11 @@\n+\n+#if INCLUDE_JVMCI\n+  if (JVMCICounterSize > 0) {\n+    if (jvmci_counters_include(this)) {\n+      for (int i = 0; i < JVMCICounterSize; i++) {\n+        _jvmci_old_thread_counters[i] += _jvmci_counters[i];\n+      }\n+    }\n+  }\n+#endif \/\/ INCLUDE_JVMCI\n+\n@@ -2193,1 +1513,0 @@\n-    ResourceMark rm(this);\n@@ -2199,1 +1518,1 @@\n-                                 get_thread_name(),\n+                                 thread_name,\n@@ -2204,0 +1523,1 @@\n+    os::free(thread_name);\n@@ -2221,1 +1541,1 @@\n-  remove_stack_guard_pages();\n+  _stack_overflow_state.remove_stack_guard_pages();\n@@ -2227,2 +1547,0 @@\n-  BarrierSet::barrier_set()->on_thread_detach(this);\n-\n@@ -2236,1 +1554,1 @@\n-    return (JavaThread*) thread;\n+    return thread->as_Java_thread();\n@@ -2240,2 +1558,1 @@\n-    JavaThread *ret=op == NULL ? NULL : (JavaThread *)op->calling_thread();\n-    assert(ret->is_Java_thread(), \"must be a Java thread\");\n+    JavaThread *ret = op == NULL ? NULL : op->calling_thread()->as_Java_thread();\n@@ -2256,0 +1573,7 @@\n+oop JavaThread::exception_oop() const {\n+  return Atomic::load(&_exception_oop);\n+}\n+\n+void JavaThread::set_exception_oop(oop o) {\n+  Atomic::store(&_exception_oop, o);\n+}\n@@ -2273,1 +1597,2 @@\n-\/\/ JVM support.\n+\/\/ Asynchronous exceptions support\n+\/\/\n@@ -2278,3 +1603,2 @@\n-void JavaThread::check_and_handle_async_exceptions(bool check_unsafe_error) {\n-\n-  if (has_last_Java_frame() && has_async_condition()) {\n+void JavaThread::check_and_handle_async_exceptions() {\n+  if (has_last_Java_frame() && has_async_exception_condition()) {\n@@ -2304,1 +1628,1 @@\n-  JavaThread::AsyncRequests condition = clear_special_runtime_exit_condition();\n+  AsyncExceptionCondition condition = clear_async_exception_condition();\n@@ -2319,1 +1643,1 @@\n-    if (!has_pending_exception() || !pending_exception()->is_a(SystemDictionary::ThreadDeath_klass())) {\n+    if (!has_pending_exception() || !pending_exception()->is_a(vmClasses::ThreadDeath_klass())) {\n@@ -2336,1 +1660,2 @@\n-      clear_has_async_exception();\n+      \/\/ Clear condition from _suspend_flags since we have finished processing it.\n+      clear_suspend_flag(_has_async_exception);\n@@ -2340,3 +1665,3 @@\n-  if (check_unsafe_error &&\n-      condition == _async_unsafe_access_error && !has_pending_exception()) {\n-    condition = _no_async_condition;  \/\/ done\n+  if (condition == _async_unsafe_access_error && !has_pending_exception()) {\n+    \/\/ We may be at method entry which requires we save the do-not-unlock flag.\n+    UnlockFlagSaver fs(this);\n@@ -2346,1 +1671,2 @@\n-      THROW_MSG(vmSymbols::java_lang_InternalError(), \"a fault occurred in an unsafe memory access operation\");\n+      Exceptions::throw_unsafe_access_internal_error(THREAD, __FILE__, __LINE__, \"a fault occurred in an unsafe memory access operation\");\n+      return;\n@@ -2351,1 +1677,2 @@\n-      THROW_MSG(vmSymbols::java_lang_InternalError(), \"a fault occurred in an unsafe memory access operation\");\n+      Exceptions::throw_unsafe_access_internal_error(THREAD, __FILE__, __LINE__, \"a fault occurred in an unsafe memory access operation\");\n+      return;\n@@ -2356,1 +1683,2 @@\n-      THROW_MSG(vmSymbols::java_lang_InternalError(), \"a fault occurred in a recent unsafe memory access operation in compiled Java code\");\n+      Exceptions::throw_unsafe_access_internal_error(THREAD, __FILE__, __LINE__, \"a fault occurred in a recent unsafe memory access operation in compiled Java code\");\n+      return;\n@@ -2363,3 +1691,1 @@\n-  assert(condition == _no_async_condition || has_pending_exception() ||\n-         (!check_unsafe_error && condition == _async_unsafe_access_error),\n-         \"must have handled the async condition, if no exception\");\n+  assert(has_pending_exception(), \"must have handled the async condition if no exception\");\n@@ -2370,2 +1696,1 @@\n-  \/\/ Check for pending external suspend.\n-  if (is_external_suspend_with_lock()) {\n+  if (is_obj_deopt_suspend()) {\n@@ -2373,1 +1698,1 @@\n-    java_suspend_self_with_safepoint_check();\n+    wait_for_object_deoptimization();\n@@ -2385,365 +1710,4 @@\n-void JavaThread::send_thread_stop(oop java_throwable)  {\n-  assert(Thread::current()->is_VM_thread(), \"should be in the vm thread\");\n-  assert(Threads_lock->is_locked(), \"Threads_lock should be locked by safepoint code\");\n-  assert(SafepointSynchronize::is_at_safepoint(), \"all threads are stopped\");\n-\n-  \/\/ Do not throw asynchronous exceptions against the compiler thread\n-  \/\/ (the compiler thread should not be a Java thread -- fix in 1.4.2)\n-  if (!can_call_java()) return;\n-\n-  {\n-    \/\/ Actually throw the Throwable against the target Thread - however\n-    \/\/ only if there is no thread death exception installed already.\n-    if (_pending_async_exception == NULL || !_pending_async_exception->is_a(SystemDictionary::ThreadDeath_klass())) {\n-      \/\/ If the topmost frame is a runtime stub, then we are calling into\n-      \/\/ OptoRuntime from compiled code. Some runtime stubs (new, monitor_exit..)\n-      \/\/ must deoptimize the caller before continuing, as the compiled  exception handler table\n-      \/\/ may not be valid\n-      if (has_last_Java_frame()) {\n-        frame f = last_frame();\n-        if (f.is_runtime_frame() || f.is_safepoint_blob_frame()) {\n-          \/\/ BiasedLocking needs an updated RegisterMap for the revoke monitors pass\n-          RegisterMap reg_map(this, UseBiasedLocking);\n-          frame compiled_frame = f.sender(&reg_map);\n-          if (!StressCompiledExceptionHandlers && compiled_frame.can_be_deoptimized()) {\n-            Deoptimization::deoptimize(this, compiled_frame, &reg_map);\n-          }\n-        }\n-      }\n-\n-      \/\/ Set async. pending exception in thread.\n-      set_pending_async_exception(java_throwable);\n-\n-      if (log_is_enabled(Info, exceptions)) {\n-         ResourceMark rm;\n-        log_info(exceptions)(\"Pending Async. exception installed of type: %s\",\n-                             InstanceKlass::cast(_pending_async_exception->klass())->external_name());\n-      }\n-      \/\/ for AbortVMOnException flag\n-      Exceptions::debug_check_abort(_pending_async_exception->klass()->external_name());\n-    }\n-  }\n-\n-\n-  \/\/ Interrupt thread so it will wake up from a potential wait()\/sleep()\/park()\n-  java_lang_Thread::set_interrupted(threadObj(), true);\n-  this->interrupt();\n-}\n-\n-\/\/ External suspension mechanism.\n-\/\/\n-\/\/ Tell the VM to suspend a thread when ever it knows that it does not hold on\n-\/\/ to any VM_locks and it is at a transition\n-\/\/ Self-suspension will happen on the transition out of the vm.\n-\/\/ Catch \"this\" coming in from JNIEnv pointers when the thread has been freed\n-\/\/\n-\/\/ Guarantees on return:\n-\/\/   + Target thread will not execute any new bytecode (that's why we need to\n-\/\/     force a safepoint)\n-\/\/   + Target thread will not enter any new monitors\n-\/\/\n-void JavaThread::java_suspend() {\n-  ThreadsListHandle tlh;\n-  if (!tlh.includes(this) || threadObj() == NULL || is_exiting()) {\n-    return;\n-  }\n-\n-  { MutexLocker ml(SR_lock(), Mutex::_no_safepoint_check_flag);\n-    if (!is_external_suspend()) {\n-      \/\/ a racing resume has cancelled us; bail out now\n-      return;\n-    }\n-\n-    \/\/ suspend is done\n-    uint32_t debug_bits = 0;\n-    \/\/ Warning: is_ext_suspend_completed() may temporarily drop the\n-    \/\/ SR_lock to allow the thread to reach a stable thread state if\n-    \/\/ it is currently in a transient thread state.\n-    if (is_ext_suspend_completed(false \/* !called_by_wait *\/,\n-                                 SuspendRetryDelay, &debug_bits)) {\n-      return;\n-    }\n-  }\n-\n-  if (Thread::current() == this) {\n-    \/\/ Safely self-suspend.\n-    \/\/ If we don't do this explicitly it will implicitly happen\n-    \/\/ before we transition back to Java, and on some other thread-state\n-    \/\/ transition paths, but not as we exit a JVM TI SuspendThread call.\n-    \/\/ As SuspendThread(current) must not return (until resumed) we must\n-    \/\/ self-suspend here.\n-    ThreadBlockInVM tbivm(this);\n-    java_suspend_self();\n-  } else {\n-    VM_ThreadSuspend vm_suspend;\n-    VMThread::execute(&vm_suspend);\n-  }\n-}\n-\n-\/\/ Part II of external suspension.\n-\/\/ A JavaThread self suspends when it detects a pending external suspend\n-\/\/ request. This is usually on transitions. It is also done in places\n-\/\/ where continuing to the next transition would surprise the caller,\n-\/\/ e.g., monitor entry.\n-\/\/\n-\/\/ Returns the number of times that the thread self-suspended.\n-\/\/\n-\/\/ Note: DO NOT call java_suspend_self() when you just want to block current\n-\/\/       thread. java_suspend_self() is the second stage of cooperative\n-\/\/       suspension for external suspend requests and should only be used\n-\/\/       to complete an external suspend request.\n-\/\/\n-int JavaThread::java_suspend_self() {\n-  assert(thread_state() == _thread_blocked, \"wrong state for java_suspend_self()\");\n-  int ret = 0;\n-\n-  \/\/ we are in the process of exiting so don't suspend\n-  if (is_exiting()) {\n-    clear_external_suspend();\n-    return ret;\n-  }\n-\n-  assert(_anchor.walkable() ||\n-         (is_Java_thread() && !((JavaThread*)this)->has_last_Java_frame()),\n-         \"must have walkable stack\");\n-\n-  MonitorLocker ml(SR_lock(), Mutex::_no_safepoint_check_flag);\n-\n-  assert(!this->is_ext_suspended(),\n-         \"a thread trying to self-suspend should not already be suspended\");\n-\n-  if (this->is_suspend_equivalent()) {\n-    \/\/ If we are self-suspending as a result of the lifting of a\n-    \/\/ suspend equivalent condition, then the suspend_equivalent\n-    \/\/ flag is not cleared until we set the ext_suspended flag so\n-    \/\/ that wait_for_ext_suspend_completion() returns consistent\n-    \/\/ results.\n-    this->clear_suspend_equivalent();\n-  }\n-\n-  \/\/ A racing resume may have cancelled us before we grabbed SR_lock\n-  \/\/ above. Or another external suspend request could be waiting for us\n-  \/\/ by the time we return from SR_lock()->wait(). The thread\n-  \/\/ that requested the suspension may already be trying to walk our\n-  \/\/ stack and if we return now, we can change the stack out from under\n-  \/\/ it. This would be a \"bad thing (TM)\" and cause the stack walker\n-  \/\/ to crash. We stay self-suspended until there are no more pending\n-  \/\/ external suspend requests.\n-  while (is_external_suspend()) {\n-    ret++;\n-    this->set_ext_suspended();\n-\n-    \/\/ _ext_suspended flag is cleared by java_resume()\n-    while (is_ext_suspended()) {\n-      ml.wait();\n-    }\n-  }\n-  return ret;\n-}\n-\n-\/\/ Helper routine to set up the correct thread state before calling java_suspend_self.\n-\/\/ This is called when regular thread-state transition helpers can't be used because\n-\/\/ we can be in various states, in particular _thread_in_native_trans.\n-\/\/ Because this thread is external suspended the safepoint code will count it as at\n-\/\/ a safepoint, regardless of what its actual current thread-state is. But\n-\/\/ is_ext_suspend_completed() may be waiting to see a thread transition from\n-\/\/ _thread_in_native_trans to _thread_blocked. So we set the thread state directly\n-\/\/ to _thread_blocked. The problem with setting thread state directly is that a\n-\/\/ safepoint could happen just after java_suspend_self() returns after being resumed,\n-\/\/ and the VM thread will see the _thread_blocked state. So we must check for a safepoint\n-\/\/ after restoring the state to make sure we won't leave while a safepoint is in progress.\n-\/\/ However, not all initial-states are allowed when performing a safepoint check, as we\n-\/\/ should never be blocking at a safepoint whilst in those states. Of these 'bad' states\n-\/\/ only _thread_in_native is possible when executing this code (based on our two callers).\n-\/\/ A thread that is _thread_in_native is already safepoint-safe and so it doesn't matter\n-\/\/ whether the VMThread sees the _thread_blocked state, or the _thread_in_native state,\n-\/\/ and so we don't need the explicit safepoint check.\n-\n-void JavaThread::java_suspend_self_with_safepoint_check() {\n-  assert(this == Thread::current(), \"invariant\");\n-  JavaThreadState state = thread_state();\n-  set_thread_state(_thread_blocked);\n-  java_suspend_self();\n-  set_thread_state_fence(state);\n-  \/\/ Since we are not using a regular thread-state transition helper here,\n-  \/\/ we must manually emit the instruction barrier after leaving a safe state.\n-  OrderAccess::cross_modify_fence();\n-  if (state != _thread_in_native) {\n-    SafepointMechanism::block_if_requested(this);\n-  }\n-}\n-\n-#ifdef ASSERT\n-\/\/ Verify the JavaThread has not yet been published in the Threads::list, and\n-\/\/ hence doesn't need protection from concurrent access at this stage.\n-void JavaThread::verify_not_published() {\n-  \/\/ Cannot create a ThreadsListHandle here and check !tlh.includes(this)\n-  \/\/ since an unpublished JavaThread doesn't participate in the\n-  \/\/ Thread-SMR protocol for keeping a ThreadsList alive.\n-  assert(!on_thread_list(), \"JavaThread shouldn't have been published yet!\");\n-}\n-#endif\n-\n-\/\/ Slow path when the native==>VM\/Java barriers detect a safepoint is in\n-\/\/ progress or when _suspend_flags is non-zero.\n-\/\/ Current thread needs to self-suspend if there is a suspend request and\/or\n-\/\/ block if a safepoint is in progress.\n-\/\/ Async exception ISN'T checked.\n-\/\/ Note only the ThreadInVMfromNative transition can call this function\n-\/\/ directly and when thread state is _thread_in_native_trans\n-void JavaThread::check_safepoint_and_suspend_for_native_trans(JavaThread *thread) {\n-  assert(thread->thread_state() == _thread_in_native_trans, \"wrong state\");\n-\n-  assert(!thread->has_last_Java_frame() || thread->frame_anchor()->walkable(), \"Unwalkable stack in native->vm transition\");\n-\n-  if (thread->is_external_suspend()) {\n-    thread->java_suspend_self_with_safepoint_check();\n-  } else {\n-    SafepointMechanism::block_if_requested(thread);\n-  }\n-\n-  JFR_ONLY(SUSPEND_THREAD_CONDITIONAL(thread);)\n-}\n-\n-\/\/ Slow path when the native==>VM\/Java barriers detect a safepoint is in\n-\/\/ progress or when _suspend_flags is non-zero.\n-\/\/ Current thread needs to self-suspend if there is a suspend request and\/or\n-\/\/ block if a safepoint is in progress.\n-\/\/ Also check for pending async exception (not including unsafe access error).\n-\/\/ Note only the native==>VM\/Java barriers can call this function and when\n-\/\/ thread state is _thread_in_native_trans.\n-void JavaThread::check_special_condition_for_native_trans(JavaThread *thread) {\n-  check_safepoint_and_suspend_for_native_trans(thread);\n-\n-  if (thread->has_async_exception()) {\n-    \/\/ We are in _thread_in_native_trans state, don't handle unsafe\n-    \/\/ access error since that may block.\n-    thread->check_and_handle_async_exceptions(false);\n-  }\n-}\n-\n-\/\/ This is a variant of the normal\n-\/\/ check_special_condition_for_native_trans with slightly different\n-\/\/ semantics for use by critical native wrappers.  It does all the\n-\/\/ normal checks but also performs the transition back into\n-\/\/ thread_in_Java state.  This is required so that critical natives\n-\/\/ can potentially block and perform a GC if they are the last thread\n-\/\/ exiting the GCLocker.\n-void JavaThread::check_special_condition_for_native_trans_and_transition(JavaThread *thread) {\n-  check_special_condition_for_native_trans(thread);\n-\n-  \/\/ Finish the transition\n-  thread->set_thread_state(_thread_in_Java);\n-\n-  if (thread->do_critical_native_unlock()) {\n-    ThreadInVMfromJavaNoAsyncException tiv(thread);\n-    GCLocker::unlock_critical(thread);\n-    thread->clear_critical_native_unlock();\n-  }\n-}\n-\n-\/\/ We need to guarantee the Threads_lock here, since resumes are not\n-\/\/ allowed during safepoint synchronization\n-\/\/ Can only resume from an external suspension\n-void JavaThread::java_resume() {\n-  assert_locked_or_safepoint(Threads_lock);\n-\n-  \/\/ Sanity check: thread is gone, has started exiting or the thread\n-  \/\/ was not externally suspended.\n-  ThreadsListHandle tlh;\n-  if (!tlh.includes(this) || is_exiting() || !is_external_suspend()) {\n-    return;\n-  }\n-\n-  MutexLocker ml(SR_lock(), Mutex::_no_safepoint_check_flag);\n-\n-  clear_external_suspend();\n-\n-  if (is_ext_suspended()) {\n-    clear_ext_suspended();\n-    SR_lock()->notify_all();\n-  }\n-}\n-\n-size_t JavaThread::_stack_red_zone_size = 0;\n-size_t JavaThread::_stack_yellow_zone_size = 0;\n-size_t JavaThread::_stack_reserved_zone_size = 0;\n-size_t JavaThread::_stack_shadow_zone_size = 0;\n-\n-void JavaThread::create_stack_guard_pages() {\n-  if (!os::uses_stack_guard_pages() ||\n-      _stack_guard_state != stack_guard_unused ||\n-      (DisablePrimordialThreadGuardPages && os::is_primordial_thread())) {\n-      log_info(os, thread)(\"Stack guard page creation for thread \"\n-                           UINTX_FORMAT \" disabled\", os::current_thread_id());\n-    return;\n-  }\n-  address low_addr = stack_end();\n-  size_t len = stack_guard_zone_size();\n-\n-  assert(is_aligned(low_addr, os::vm_page_size()), \"Stack base should be the start of a page\");\n-  assert(is_aligned(len, os::vm_page_size()), \"Stack size should be a multiple of page size\");\n-\n-  int must_commit = os::must_commit_stack_guard_pages();\n-  \/\/ warning(\"Guarding at \" PTR_FORMAT \" for len \" SIZE_FORMAT \"\\n\", low_addr, len);\n-\n-  if (must_commit && !os::create_stack_guard_pages((char *) low_addr, len)) {\n-    log_warning(os, thread)(\"Attempt to allocate stack guard pages failed.\");\n-    return;\n-  }\n-\n-  if (os::guard_memory((char *) low_addr, len)) {\n-    _stack_guard_state = stack_guard_enabled;\n-  } else {\n-    log_warning(os, thread)(\"Attempt to protect stack guard pages failed (\"\n-      PTR_FORMAT \"-\" PTR_FORMAT \").\", p2i(low_addr), p2i(low_addr + len));\n-    if (os::uncommit_memory((char *) low_addr, len)) {\n-      log_warning(os, thread)(\"Attempt to deallocate stack guard pages failed.\");\n-    }\n-    return;\n-  }\n-\n-  log_debug(os, thread)(\"Thread \" UINTX_FORMAT \" stack guard pages activated: \"\n-    PTR_FORMAT \"-\" PTR_FORMAT \".\",\n-    os::current_thread_id(), p2i(low_addr), p2i(low_addr + len));\n-}\n-\n-void JavaThread::remove_stack_guard_pages() {\n-  assert(Thread::current() == this, \"from different thread\");\n-  if (_stack_guard_state == stack_guard_unused) return;\n-  address low_addr = stack_end();\n-  size_t len = stack_guard_zone_size();\n-\n-  if (os::must_commit_stack_guard_pages()) {\n-    if (os::remove_stack_guard_pages((char *) low_addr, len)) {\n-      _stack_guard_state = stack_guard_unused;\n-    } else {\n-      log_warning(os, thread)(\"Attempt to deallocate stack guard pages failed (\"\n-        PTR_FORMAT \"-\" PTR_FORMAT \").\", p2i(low_addr), p2i(low_addr + len));\n-      return;\n-    }\n-  } else {\n-    if (_stack_guard_state == stack_guard_unused) return;\n-    if (os::unguard_memory((char *) low_addr, len)) {\n-      _stack_guard_state = stack_guard_unused;\n-    } else {\n-      log_warning(os, thread)(\"Attempt to unprotect stack guard pages failed (\"\n-        PTR_FORMAT \"-\" PTR_FORMAT \").\", p2i(low_addr), p2i(low_addr + len));\n-      return;\n-    }\n-  }\n-\n-  log_debug(os, thread)(\"Thread \" UINTX_FORMAT \" stack guard pages removed: \"\n-    PTR_FORMAT \"-\" PTR_FORMAT \".\",\n-    os::current_thread_id(), p2i(low_addr), p2i(low_addr + len));\n-}\n-\n-void JavaThread::enable_stack_reserved_zone() {\n-  assert(_stack_guard_state == stack_guard_reserved_disabled, \"inconsistent state\");\n-\n-  \/\/ The base notation is from the stack's point of view, growing downward.\n-  \/\/ We need to adjust it to work correctly with guard_memory()\n-  address base = stack_reserved_zone_base() - stack_reserved_zone_size();\n-\n-  guarantee(base < stack_base(),\"Error calculating stack reserved zone\");\n-  guarantee(base < os::current_stack_pointer(),\"Error calculating stack reserved zone\");\n+class InstallAsyncExceptionClosure : public HandshakeClosure {\n+  Handle _throwable; \/\/ The Throwable thrown at the target Thread\n+public:\n+  InstallAsyncExceptionClosure(Handle throwable) : HandshakeClosure(\"InstallAsyncException\"), _throwable(throwable) {}\n@@ -2751,4 +1715,6 @@\n-  if (os::guard_memory((char *) base, stack_reserved_zone_size())) {\n-    _stack_guard_state = stack_guard_enabled;\n-  } else {\n-    warning(\"Attempt to guard stack reserved zone failed.\");\n+  void do_thread(Thread* thr) {\n+    JavaThread* target = thr->as_Java_thread();\n+    \/\/ Note that this now allows multiple ThreadDeath exceptions to be\n+    \/\/ thrown at a thread.\n+    \/\/ The target thread has run and has not exited yet.\n+    target->send_thread_stop(_throwable());\n@@ -2756,1 +1722,7 @@\n-  enable_register_stack_guard();\n+};\n+\n+void JavaThread::send_async_exception(oop java_thread, oop java_throwable) {\n+  Handle throwable(Thread::current(), java_throwable);\n+  JavaThread* target = java_lang_Thread::thread(java_thread);\n+  InstallAsyncExceptionClosure vm_stop(throwable);\n+  Handshake::execute(&vm_stop, target);\n@@ -2759,2 +1731,8 @@\n-void JavaThread::disable_stack_reserved_zone() {\n-  assert(_stack_guard_state == stack_guard_enabled, \"inconsistent state\");\n+void JavaThread::send_thread_stop(oop java_throwable)  {\n+  ResourceMark rm;\n+  assert(is_handshake_safe_for(Thread::current()),\n+         \"should be self or handshakee\");\n+\n+  \/\/ Do not throw asynchronous exceptions against the compiler thread\n+  \/\/ (the compiler thread should not be a Java thread -- fix in 1.4.2)\n+  if (!can_call_java()) return;\n@@ -2762,2 +1740,18 @@\n-  \/\/ Simply return if called for a thread that does not use guard pages.\n-  if (_stack_guard_state != stack_guard_enabled) return;\n+  {\n+    \/\/ Actually throw the Throwable against the target Thread - however\n+    \/\/ only if there is no thread death exception installed already.\n+    if (_pending_async_exception == NULL || !_pending_async_exception->is_a(vmClasses::ThreadDeath_klass())) {\n+      \/\/ If the topmost frame is a runtime stub, then we are calling into\n+      \/\/ OptoRuntime from compiled code. Some runtime stubs (new, monitor_exit..)\n+      \/\/ must deoptimize the caller before continuing, as the compiled  exception handler table\n+      \/\/ may not be valid\n+      if (has_last_Java_frame()) {\n+        frame f = last_frame();\n+        if (f.is_runtime_frame() || f.is_safepoint_blob_frame()) {\n+          RegisterMap reg_map(this, false);\n+          frame compiled_frame = f.sender(&reg_map);\n+          if (!StressCompiledExceptionHandlers && compiled_frame.can_be_deoptimized()) {\n+            Deoptimization::deoptimize(this, compiled_frame);\n+          }\n+        }\n+      }\n@@ -2765,3 +1759,2 @@\n-  \/\/ The base notation is from the stack's point of view, growing downward.\n-  \/\/ We need to adjust it to work correctly with guard_memory()\n-  address base = stack_reserved_zone_base() - stack_reserved_zone_size();\n+      \/\/ Set async. pending exception in thread.\n+      set_pending_async_exception(java_throwable);\n@@ -2769,4 +1762,8 @@\n-  if (os::unguard_memory((char *)base, stack_reserved_zone_size())) {\n-    _stack_guard_state = stack_guard_reserved_disabled;\n-  } else {\n-    warning(\"Attempt to unguard stack reserved zone failed.\");\n+      if (log_is_enabled(Info, exceptions)) {\n+         ResourceMark rm;\n+        log_info(exceptions)(\"Pending Async. exception installed of type: %s\",\n+                             InstanceKlass::cast(_pending_async_exception->klass())->external_name());\n+      }\n+      \/\/ for AbortVMOnException flag\n+      Exceptions::debug_check_abort(_pending_async_exception->klass()->external_name());\n+    }\n@@ -2774,8 +1771,4 @@\n-  disable_register_stack_guard();\n-}\n-void JavaThread::enable_stack_yellow_reserved_zone() {\n-  assert(_stack_guard_state != stack_guard_unused, \"must be using guard pages.\");\n-  assert(_stack_guard_state != stack_guard_enabled, \"already enabled\");\n-  \/\/ The base notation is from the stacks point of view, growing downward.\n-  \/\/ We need to adjust it to work correctly with guard_memory()\n-  address base = stack_red_zone_base();\n+  \/\/ Interrupt thread so it will wake up from a potential wait()\/sleep()\/park()\n+  java_lang_Thread::set_interrupted(threadObj(), true);\n+  this->interrupt();\n+}\n@@ -2785,6 +1778,11 @@\n-  guarantee(base < stack_base(), \"Error calculating stack yellow zone\");\n-  guarantee(base < os::current_stack_pointer(), \"Error calculating stack yellow zone\");\n-  if (os::guard_memory((char *) base, stack_yellow_reserved_zone_size())) {\n-    _stack_guard_state = stack_guard_enabled;\n-  } else {\n-    warning(\"Attempt to guard stack yellow zone failed.\");\n+\/\/ External suspension mechanism.\n+\/\/\n+\/\/ Guarantees on return (for a valid target thread):\n+\/\/   - Target thread will not execute any new bytecode.\n+\/\/   - Target thread will not enter any new monitors.\n+\/\/\n+bool JavaThread::java_suspend() {\n+  ThreadsListHandle tlh;\n+  if (!tlh.includes(this)) {\n+    log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" not on ThreadsList, no suspension\", p2i(this));\n+    return false;\n@@ -2793,1 +1791,1 @@\n-  enable_register_stack_guard();\n+  return this->handshake_state()->suspend();\n@@ -2796,3 +1794,27 @@\n-void JavaThread::disable_stack_yellow_reserved_zone() {\n-  assert(_stack_guard_state != stack_guard_unused, \"must be using guard pages.\");\n-  assert(_stack_guard_state != stack_guard_yellow_reserved_disabled, \"already disabled\");\n+bool JavaThread::java_resume() {\n+  ThreadsListHandle tlh;\n+  if (!tlh.includes(this)) {\n+    log_trace(thread, suspend)(\"JavaThread:\" INTPTR_FORMAT \" not on ThreadsList, nothing to resume\", p2i(this));\n+    return false;\n+  }\n+  return this->handshake_state()->resume();\n+}\n+\n+\/\/ Wait for another thread to perform object reallocation and relocking on behalf of\n+\/\/ this thread.\n+\/\/ Raw thread state transition to _thread_blocked and back again to the original\n+\/\/ state before returning are performed. The current thread is required to\n+\/\/ change to _thread_blocked in order to be seen to be safepoint\/handshake safe\n+\/\/ whilst suspended and only after becoming handshake safe, the other thread can\n+\/\/ complete the handshake used to synchronize with this thread and then perform\n+\/\/ the reallocation and relocking. We cannot use the thread state transition\n+\/\/ helpers because we arrive here in various states and also because the helpers\n+\/\/ indirectly call this method.  After leaving _thread_blocked we have to check\n+\/\/ for safepoint\/handshake, except if _thread_in_native. The thread is safe\n+\/\/ without blocking then. Allowed states are enumerated in\n+\/\/ SafepointSynchronize::block(). See also EscapeBarrier::sync_and_suspend_*()\n+\n+void JavaThread::wait_for_object_deoptimization() {\n+  assert(!has_last_Java_frame() || frame_anchor()->walkable(), \"should have walkable stack\");\n+  assert(this == Thread::current(), \"invariant\");\n+  JavaThreadState state = thread_state();\n@@ -2800,2 +1822,24 @@\n-  \/\/ Simply return if called for a thread that does not use guard pages.\n-  if (_stack_guard_state == stack_guard_unused) return;\n+  bool spin_wait = os::is_MP();\n+  do {\n+    set_thread_state(_thread_blocked);\n+    \/\/ Wait for object deoptimization if requested.\n+    if (spin_wait) {\n+      \/\/ A single deoptimization is typically very short. Microbenchmarks\n+      \/\/ showed 5% better performance when spinning.\n+      const uint spin_limit = 10 * SpinYield::default_spin_limit;\n+      SpinYield spin(spin_limit);\n+      for (uint i = 0; is_obj_deopt_suspend() && i < spin_limit; i++) {\n+        spin.wait();\n+      }\n+      \/\/ Spin just once\n+      spin_wait = false;\n+    } else {\n+      MonitorLocker ml(this, EscapeBarrier_lock, Monitor::_no_safepoint_check_flag);\n+      if (is_obj_deopt_suspend()) {\n+        ml.wait();\n+      }\n+    }\n+    \/\/ The current thread could have been suspended again. We have to check for\n+    \/\/ suspend after restoring the saved state. Without this the current thread\n+    \/\/ might return to _thread_in_Java and execute bytecode.\n+    set_thread_state_fence(state);\n@@ -2803,3 +1847,7 @@\n-  \/\/ The base notation is from the stacks point of view, growing downward.\n-  \/\/ We need to adjust it to work correctly with guard_memory()\n-  address base = stack_red_zone_base();\n+    if (state != _thread_in_native) {\n+      SafepointMechanism::process_if_requested(this);\n+    }\n+    \/\/ A handshake for obj. deoptimization suspend could have been processed so\n+    \/\/ we must check after processing.\n+  } while (is_obj_deopt_suspend());\n+}\n@@ -2807,6 +1855,8 @@\n-  if (os::unguard_memory((char *)base, stack_yellow_reserved_zone_size())) {\n-    _stack_guard_state = stack_guard_yellow_reserved_disabled;\n-  } else {\n-    warning(\"Attempt to unguard stack yellow zone failed.\");\n-  }\n-  disable_register_stack_guard();\n+#ifdef ASSERT\n+\/\/ Verify the JavaThread has not yet been published in the Threads::list, and\n+\/\/ hence doesn't need protection from concurrent access at this stage.\n+void JavaThread::verify_not_published() {\n+  \/\/ Cannot create a ThreadsListHandle here and check !tlh.includes(this)\n+  \/\/ since an unpublished JavaThread doesn't participate in the\n+  \/\/ Thread-SMR protocol for keeping a ThreadsList alive.\n+  assert(!on_thread_list(), \"JavaThread shouldn't have been published yet!\");\n@@ -2814,0 +1864,1 @@\n+#endif\n@@ -2815,5 +1866,8 @@\n-void JavaThread::enable_stack_red_zone() {\n-  \/\/ The base notation is from the stacks point of view, growing downward.\n-  \/\/ We need to adjust it to work correctly with guard_memory()\n-  assert(_stack_guard_state != stack_guard_unused, \"must be using guard pages.\");\n-  address base = stack_red_zone_base() - stack_red_zone_size();\n+\/\/ Slow path when the native==>Java barriers detect a safepoint\/handshake is\n+\/\/ pending, when _suspend_flags is non-zero or when we need to process a stack\n+\/\/ watermark. Also check for pending async exceptions (except unsafe access error).\n+\/\/ Note only the native==>Java barriers can call this function when thread state\n+\/\/ is _thread_in_native_trans.\n+void JavaThread::check_special_condition_for_native_trans(JavaThread *thread) {\n+  assert(thread->thread_state() == _thread_in_native_trans, \"wrong state\");\n+  assert(!thread->has_last_Java_frame() || thread->frame_anchor()->walkable(), \"Unwalkable stack in native->Java transition\");\n@@ -2821,2 +1875,2 @@\n-  guarantee(base < stack_base(), \"Error calculating stack red zone\");\n-  guarantee(base < os::current_stack_pointer(), \"Error calculating stack red zone\");\n+  \/\/ Enable WXWrite: called directly from interpreter native wrapper.\n+  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXWrite, thread));\n@@ -2824,4 +1878,1 @@\n-  if (!os::guard_memory((char *) base, stack_red_zone_size())) {\n-    warning(\"Attempt to guard stack red zone failed.\");\n-  }\n-}\n+  SafepointMechanism::process_if_requested_with_exit_check(thread, false \/* check asyncs *\/);\n@@ -2829,9 +1880,4 @@\n-void JavaThread::disable_stack_red_zone() {\n-  \/\/ The base notation is from the stacks point of view, growing downward.\n-  \/\/ We need to adjust it to work correctly with guard_memory()\n-  assert(_stack_guard_state != stack_guard_unused, \"must be using guard pages.\");\n-  address base = stack_red_zone_base() - stack_red_zone_size();\n-  if (!os::unguard_memory((char *)base, stack_red_zone_size())) {\n-    warning(\"Attempt to unguard stack red zone failed.\");\n-  }\n-}\n+  \/\/ After returning from native, it could be that the stack frames are not\n+  \/\/ yet safe to use. We catch such situations in the subsequent stack watermark\n+  \/\/ barrier, which will trap unsafe stack frames.\n+  StackWatermarkSet::before_unwind(thread);\n@@ -2839,7 +1885,4 @@\n-void JavaThread::frames_do(void f(frame*, const RegisterMap* map)) {\n-  \/\/ ignore is there is no stack\n-  if (!has_last_Java_frame()) return;\n-  \/\/ traverse the stack frames. Starts from top frame.\n-  for (StackFrameStream fst(this); !fst.is_done(); fst.next()) {\n-    frame* fr = fst.current();\n-    f(fr, fst.register_map());\n+  if (thread->has_async_exception_condition(false \/* check unsafe access error *\/)) {\n+    \/\/ We are in _thread_in_native_trans state, don't handle unsafe\n+    \/\/ access error since that may block.\n+    thread->check_and_handle_async_exceptions();\n@@ -2849,1 +1892,0 @@\n-\n@@ -2854,2 +1896,1 @@\n-  \/\/ BiasedLocking needs an updated RegisterMap for the revoke monitors pass\n-  StackFrameStream fst(this, UseBiasedLocking);\n+  StackFrameStream fst(this, false \/* update *\/, true \/* process_frames *\/);\n@@ -2892,1 +1933,1 @@\n-      Deoptimization::deoptimize(this, *fst.current(), fst.register_map());\n+      Deoptimization::deoptimize(this, *fst.current());\n@@ -2905,1 +1946,1 @@\n-  for (StackFrameStream fst(this); !fst.is_done(); fst.next()) {\n+  for (StackFrameStream fst(this, true \/* update *\/, true \/* process_frames *\/); !fst.is_done(); fst.next()) {\n@@ -2918,2 +1959,1 @@\n-  \/\/ BiasedLocking needs an updated RegisterMap for the revoke monitors pass\n-  StackFrameStream fst(this, UseBiasedLocking);\n+  StackFrameStream fst(this, false \/* update *\/, true \/* process_frames *\/);\n@@ -2922,1 +1962,1 @@\n-      Deoptimization::deoptimize(this, *fst.current(), fst.register_map());\n+      Deoptimization::deoptimize(this, *fst.current());\n@@ -2927,21 +1967,8 @@\n-\/\/ If the caller is a NamedThread, then remember, in the current scope,\n-\/\/ the given JavaThread in its _processed_thread field.\n-class RememberProcessedThread: public StackObj {\n-  NamedThread* _cur_thr;\n- public:\n-  RememberProcessedThread(JavaThread* jthr) {\n-    Thread* thread = Thread::current();\n-    if (thread->is_Named_thread()) {\n-      _cur_thr = (NamedThread *)thread;\n-      _cur_thr->set_processed_thread(jthr);\n-    } else {\n-      _cur_thr = NULL;\n-    }\n-  }\n-\n-  ~RememberProcessedThread() {\n-    if (_cur_thr) {\n-      _cur_thr->set_processed_thread(NULL);\n-    }\n-  }\n-};\n+#ifdef ASSERT\n+void JavaThread::verify_frame_info() {\n+  assert((!has_last_Java_frame() && java_call_counter() == 0) ||\n+         (has_last_Java_frame() && java_call_counter() > 0),\n+         \"unexpected frame info: has_last_frame=%s, java_call_counter=%d\",\n+         has_last_Java_frame() ? \"true\" : \"false\", java_call_counter());\n+}\n+#endif\n@@ -2949,1 +1976,1 @@\n-void JavaThread::oops_do(OopClosure* f, CodeBlobClosure* cf) {\n+void JavaThread::oops_do_no_frames(OopClosure* f, CodeBlobClosure* cf) {\n@@ -2954,1 +1981,1 @@\n-  Thread::oops_do(f, cf);\n+  Thread::oops_do_no_frames(f, cf);\n@@ -2956,2 +1983,1 @@\n-  assert((!has_last_Java_frame() && java_call_counter() == 0) ||\n-         (has_last_Java_frame() && java_call_counter() > 0), \"wrong java_sp info!\");\n+  DEBUG_ONLY(verify_frame_info();)\n@@ -2960,10 +1986,0 @@\n-    \/\/ Record JavaThread to GC thread\n-    RememberProcessedThread rpt(this);\n-\n-    \/\/ traverse the registered growable array\n-    if (_array_for_gc != NULL) {\n-      for (int index = 0; index < _array_for_gc->length(); index++) {\n-        f->do_oop(_array_for_gc->adr_at(index));\n-      }\n-    }\n-\n@@ -2974,5 +1990,0 @@\n-\n-    \/\/ Traverse the execution stack\n-    for (StackFrameStream fst(this); !fst.is_done(); fst.next()) {\n-      fst.current()->oops_do(f, cf, fst.register_map());\n-    }\n@@ -2984,1 +1995,1 @@\n-  GrowableArray<jvmtiDeferredLocalVariableSet*>* list = deferred_locals();\n+  GrowableArray<jvmtiDeferredLocalVariableSet*>* list = JvmtiDeferredUpdates::deferred_locals(this);\n@@ -2993,1 +2004,0 @@\n-  f->do_oop((oop*) &_threadObj);\n@@ -2997,0 +2007,3 @@\n+#if INCLUDE_JVMCI\n+  f->do_oop((oop*) &_jvmci_reserved_oop0);\n+#endif\n@@ -3003,0 +2016,12 @@\n+void JavaThread::oops_do_frames(OopClosure* f, CodeBlobClosure* cf) {\n+  if (!has_last_Java_frame()) {\n+    return;\n+  }\n+  \/\/ Finish any pending lazy GC activity for the frames\n+  StackWatermarkSet::finish_processing(this, NULL \/* context *\/, StackWatermarkKind::gc);\n+  \/\/ Traverse the execution stack\n+  for (StackFrameStream fst(this, true \/* update *\/, false \/* process_frames *\/); !fst.is_done(); fst.next()) {\n+    fst.current()->oops_do(f, cf, fst.register_map());\n+  }\n+}\n+\n@@ -3006,4 +2031,1 @@\n-  assert((!has_last_Java_frame() && java_call_counter() == 0) ||\n-         (has_last_Java_frame() && java_call_counter() > 0),\n-         \"unexpected frame info: has_last_frame=%d, java_call_counter=%d\",\n-         has_last_Java_frame(), java_call_counter());\n+  verify_frame_info();\n@@ -3014,4 +2036,1 @@\n-  assert((!has_last_Java_frame() && java_call_counter() == 0) ||\n-         (has_last_Java_frame() && java_call_counter() > 0),\n-         \"unexpected frame info: has_last_frame=%d, java_call_counter=%d\",\n-         has_last_Java_frame(), java_call_counter());\n+  DEBUG_ONLY(verify_frame_info();)\n@@ -3021,1 +2040,1 @@\n-    for (StackFrameStream fst(this); !fst.is_done(); fst.next()) {\n+    for (StackFrameStream fst(this, true \/* update *\/, true \/* process_frames *\/); !fst.is_done(); fst.next()) {\n@@ -3034,1 +2053,1 @@\n-    for (StackFrameStream fst(this); !fst.is_done(); fst.next()) {\n+    for (StackFrameStream fst(this, true \/* update *\/, true \/* process_frames *\/); !fst.is_done(); fst.next()) {\n@@ -3133,0 +2152,1 @@\n+\n@@ -3135,0 +2155,10 @@\n+void JavaThread::frames_do(void f(frame*, const RegisterMap* map)) {\n+  \/\/ ignore if there is no stack\n+  if (!has_last_Java_frame()) return;\n+  \/\/ traverse the stack frames. Starts from top frame.\n+  for (StackFrameStream fst(this, true \/* update *\/, true \/* process_frames *\/); !fst.is_done(); fst.next()) {\n+    frame* fr = fst.current();\n+    f(fr, fst.register_map());\n+  }\n+}\n+\n@@ -3149,1 +2179,1 @@\n-\/\/ seen prior to having it's threadObj set (eg JNI attaching threads and\n+\/\/ seen prior to having its threadObj set (e.g., JNI attaching threads and\n@@ -3153,9 +2183,3 @@\n-#ifdef ASSERT\n-  \/\/ early safepoints can hit while current thread does not yet have TLS\n-  if (!SafepointSynchronize::is_at_safepoint()) {\n-    Thread *cur = Thread::current();\n-    if (!(cur->is_Java_thread() && cur == this)) {\n-      \/\/ Current JavaThreads are allowed to get their own name without\n-      \/\/ the Threads_lock.\n-      assert_locked_or_safepoint(Threads_lock);\n-    }\n+  if (Thread::is_JavaThread_protected(this)) {\n+    \/\/ The target JavaThread is protected so get_thread_name_string() is safe:\n+    return get_thread_name_string();\n@@ -3163,2 +2187,3 @@\n-#endif \/\/ ASSERT\n-  return get_thread_name_string();\n+\n+  \/\/ The target JavaThread is not protected so we return the default:\n+  return Thread::name();\n@@ -3244,2 +2269,4 @@\n-  ResourceMark rm;\n-  HandleMark   hm;\n+\n+  Thread* current_thread = Thread::current();\n+  ResourceMark rm(current_thread);\n+  HandleMark hm(current_thread);\n@@ -3306,1 +2333,1 @@\n-  for (StackFrameStream fst(this); !fst.is_done(); fst.next()) {\n+  for (StackFrameStream fst(this, true \/* update *\/, true \/* process_frames *\/); !fst.is_done(); fst.next()) {\n@@ -3339,1 +2366,1 @@\n-  PRESERVE_EXCEPTION_MARK;\n+  PreserveExceptionMark pm(this);\n@@ -3342,1 +2369,1 @@\n-  for (StackFrameStream fst(this, false); !fst.is_done(); fst.next()) {\n+  for (StackFrameStream fst(this, false \/* update *\/, true \/* process_frames *\/); !fst.is_done(); fst.next()) {\n@@ -3374,2 +2401,3 @@\n-  ResourceMark rm;\n-  HandleMark   hm;\n+  Thread* current_thread = Thread::current();\n+  ResourceMark rm(current_thread);\n+  HandleMark hm(current_thread);\n@@ -3434,8 +2462,0 @@\n-\n-      this->set_suspend_equivalent();\n-      \/\/ cleared by handle_special_suspend_equivalent_condition() or\n-      \/\/ java_suspend_self() via check_and_wait_while_suspended()\n-\n-\n-      \/\/ were we externally suspended while we were waiting?\n-      this->check_and_wait_while_suspended();\n@@ -3450,1 +2470,1 @@\n-      assert(!os::supports_monotonic_clock(),\n+      assert(false,\n@@ -3459,64 +2479,0 @@\n-static void compiler_thread_entry(JavaThread* thread, TRAPS) {\n-  assert(thread->is_Compiler_thread(), \"must be compiler thread\");\n-  CompileBroker::compiler_thread_loop();\n-}\n-\n-static void sweeper_thread_entry(JavaThread* thread, TRAPS) {\n-  NMethodSweeper::sweeper_loop();\n-}\n-\n-\/\/ Create a CompilerThread\n-CompilerThread::CompilerThread(CompileQueue* queue,\n-                               CompilerCounters* counters)\n-                               : JavaThread(&compiler_thread_entry) {\n-  _env   = NULL;\n-  _log   = NULL;\n-  _task  = NULL;\n-  _queue = queue;\n-  _counters = counters;\n-  _buffer_blob = NULL;\n-  _compiler = NULL;\n-\n-  \/\/ Compiler uses resource area for compilation, let's bias it to mtCompiler\n-  resource_area()->bias_to(mtCompiler);\n-\n-#ifndef PRODUCT\n-  _ideal_graph_printer = NULL;\n-#endif\n-}\n-\n-CompilerThread::~CompilerThread() {\n-  \/\/ Delete objects which were allocated on heap.\n-  delete _counters;\n-}\n-\n-bool CompilerThread::can_call_java() const {\n-  return _compiler != NULL && _compiler->is_jvmci();\n-}\n-\n-\/\/ Create sweeper thread\n-CodeCacheSweeperThread::CodeCacheSweeperThread()\n-: JavaThread(&sweeper_thread_entry) {\n-  _scanned_compiled_method = NULL;\n-}\n-\n-void CodeCacheSweeperThread::oops_do(OopClosure* f, CodeBlobClosure* cf) {\n-  JavaThread::oops_do(f, cf);\n-  if (_scanned_compiled_method != NULL && cf != NULL) {\n-    \/\/ Safepoints can occur when the sweeper is scanning an nmethod so\n-    \/\/ process it here to make sure it isn't unloaded in the middle of\n-    \/\/ a scan.\n-    cf->do_code_blob(_scanned_compiled_method);\n-  }\n-}\n-\n-void CodeCacheSweeperThread::nmethods_do(CodeBlobClosure* cf) {\n-  JavaThread::nmethods_do(cf);\n-  if (_scanned_compiled_method != NULL && cf != NULL) {\n-    \/\/ Safepoints can occur when the sweeper is scanning an nmethod so\n-    \/\/ process it here to make sure it isn't unloaded in the middle of\n-    \/\/ a scan.\n-    cf->do_code_blob(_scanned_compiled_method);\n-  }\n-}\n-\n@@ -3624,1 +2580,1 @@\n-  Klass* klass =  SystemDictionary::resolve_or_fail(vmSymbols::java_lang_System(), true, CHECK);\n+  Klass* klass = vmClasses::System_klass();\n@@ -3644,1 +2600,1 @@\n-  Klass* klass = SystemDictionary::resolve_or_fail(vmSymbols::java_lang_System(), true, CHECK);\n+  Klass* klass = vmClasses::System_klass();\n@@ -3666,1 +2622,1 @@\n-  Klass* klass = SystemDictionary::resolve_or_fail(vmSymbols::java_lang_System(), true, CHECK);\n+  Klass* klass = vmClasses::System_klass();\n@@ -3692,7 +2648,1 @@\n-  oop thread_object = create_initial_thread(thread_group, main_thread, CHECK);\n-  main_thread->set_threadObj(thread_object);\n-\n-  \/\/ Set thread status to running since main thread has\n-  \/\/ been started and running.\n-  java_lang_Thread::set_thread_status(thread_object,\n-                                      java_lang_Thread::RUNNABLE);\n+  create_initial_thread(thread_group, main_thread, CHECK);\n@@ -3704,1 +2654,1 @@\n-  InstanceKlass *k = SystemDictionary::UnsafeConstants_klass();\n+  InstanceKlass *k = vmClasses::UnsafeConstants_klass();\n@@ -3719,5 +2669,17 @@\n-  \/\/ get the Java runtime name, version, and vendor info after java.lang.System is initialized\n-  JDK_Version::set_runtime_name(get_java_runtime_name(THREAD));\n-  JDK_Version::set_runtime_version(get_java_runtime_version(THREAD));\n-  JDK_Version::set_runtime_vendor_version(get_java_runtime_vendor_version(THREAD));\n-  JDK_Version::set_runtime_vendor_vm_bug_url(get_java_runtime_vendor_vm_bug_url(THREAD));\n+  \/\/ Get the Java runtime name, version, and vendor info after java.lang.System is initialized.\n+  \/\/ Some values are actually configure-time constants but some can be set via the jlink tool and\n+  \/\/ so must be read dynamically. We treat them all the same.\n+  InstanceKlass* ik = SystemDictionary::find_instance_klass(vmSymbols::java_lang_VersionProps(),\n+                                                            Handle(), Handle());\n+  {\n+    ResourceMark rm(main_thread);\n+    JDK_Version::set_java_version(get_java_version_info(ik, vmSymbols::java_version_name()));\n+\n+    JDK_Version::set_runtime_name(get_java_version_info(ik, vmSymbols::java_runtime_name_name()));\n+\n+    JDK_Version::set_runtime_version(get_java_version_info(ik, vmSymbols::java_runtime_version_name()));\n+\n+    JDK_Version::set_runtime_vendor_version(get_java_version_info(ik, vmSymbols::java_runtime_vendor_version_name()));\n+\n+    JDK_Version::set_runtime_vendor_vm_bug_url(get_java_version_info(ik, vmSymbols::java_runtime_vendor_vm_bug_url_name()));\n+  }\n@@ -3734,3 +2696,0 @@\n-\n-  \/\/ Eager box cache initialization only if AOT is on and any library is loaded.\n-  AOTLoader::initialize_box_caches(CHECK);\n@@ -3769,0 +2728,2 @@\n+  MACOS_AARCH64_ONLY(os::current_thread_enable_wx(WXWrite));\n+\n@@ -3796,1 +2757,1 @@\n-  if (!JVMFlagRangeList::check_ranges()) {\n+  if (!JVMFlagLimit::check_all_ranges()) {\n@@ -3801,1 +2762,1 @@\n-  bool constraint_result = JVMFlagConstraintList::check_constraints(JVMFlagConstraint::AfterErgo);\n+  bool constraint_result = JVMFlagLimit::check_all_constraints(JVMFlagConstraintPhase::AfterErgo);\n@@ -3806,2 +2767,0 @@\n-  JVMFlagWriteableList::mark_startup();\n-\n@@ -3865,0 +2824,3 @@\n+  \/\/ Initialize OopStorage for threadObj\n+  _thread_oop_storage = OopStorageSet::create_strong(\"Thread OopStorage\", mtThread);\n+\n@@ -3873,0 +2835,1 @@\n+  MACOS_AARCH64_ONLY(main_thread->init_wx());\n@@ -3884,1 +2847,1 @@\n-  main_thread->create_stack_guard_pages();\n+  main_thread->stack_overflow_state()->create_stack_guard_pages();\n@@ -3888,0 +2851,1 @@\n+  ObjectSynchronizer::initialize();\n@@ -3902,2 +2866,0 @@\n-  HandleMark hm;\n-\n@@ -3942,2 +2904,2 @@\n-  \/\/ to initially define it have been changed. This is needed for both CDS and\n-  \/\/ AOT, since UseSharedSpaces and UseAOT may be changed after java.vm.info\n+  \/\/ to initially define it have been changed. This is needed for both CDS\n+  \/\/ since UseSharedSpaces may be changed after java.vm.info\n@@ -3949,1 +2911,2 @@\n-  Thread* THREAD = Thread::current();\n+  JavaThread* THREAD = JavaThread::current(); \/\/ For exception macros.\n+  HandleMark hm(THREAD);\n@@ -3997,3 +2960,1 @@\n-  if (CleanChunkPoolAsync) {\n-    Chunk::start_chunk_pool_cleaner_task();\n-  }\n+  Chunk::start_chunk_pool_cleaner_task();\n@@ -4006,0 +2967,3 @@\n+  \/\/ Start the monitor deflation thread:\n+  MonitorDeflationThread::initialize();\n+\n@@ -4058,0 +3022,4 @@\n+  if (HAS_PENDING_EXCEPTION) {\n+    java_lang_Throwable::print(PENDING_EXCEPTION, tty);\n+    vm_exit_during_initialization(\"ClassLoader::initialize_module_path() failed unexpectedly\");\n+  }\n@@ -4090,1 +3058,0 @@\n-  if (MemProfiling)                   MemProfiler::engage();\n@@ -4127,1 +3094,1 @@\n-    MetaspaceShared::preload_and_dump(CHECK_JNI_ERR);\n+    MetaspaceShared::preload_and_dump();\n@@ -4341,1 +3308,3 @@\n-  \/\/ We could get here with a pending exception, if so clear it now.\n+  \/\/ We could get here with a pending exception, if so clear it now or\n+  \/\/ it will cause MetaspaceShared::link_and_cleanup_shared_classes to\n+  \/\/ fail for dynamic dump.\n@@ -4346,0 +3315,9 @@\n+#if INCLUDE_CDS\n+  \/\/ Link all classes for dynamic CDS dumping before vm exit.\n+  \/\/ Same operation is being done in JVM_BeforeHalt for handling the\n+  \/\/ case where the application calls System.exit().\n+  if (DynamicDumpSharedSpaces) {\n+    DynamicArchive::prepare_for_dynamic_dumping_at_exit();\n+  }\n+#endif\n+\n@@ -4401,1 +3379,1 @@\n-bool Threads::destroy_vm() {\n+void Threads::destroy_vm() {\n@@ -4408,1 +3386,2 @@\n-  { MonitorLocker nu(Threads_lock);\n+  {\n+    MonitorLocker nu(Threads_lock);\n@@ -4410,3 +3389,2 @@\n-      \/\/ This wait should make safepoint checks, wait without a timeout,\n-      \/\/ and wait as a suspend-equivalent condition.\n-      nu.wait(0, Mutex::_as_suspend_equivalent_flag);\n+      \/\/ This wait should make safepoint checks, wait without a timeout.\n+      nu.wait(0);\n@@ -4434,0 +3412,10 @@\n+  \/\/ We are no longer on the main thread list but could still be in a\n+  \/\/ secondary list where another thread may try to interact with us.\n+  \/\/ So wait until all such interactions are complete before we bring\n+  \/\/ the VM to the termination safepoint. Normally this would be done\n+  \/\/ using thread->smr_delete() below where we delete the thread, but\n+  \/\/ we can't call that after the termination safepoint is active as\n+  \/\/ we will deadlock on the Threads_lock. Once all interactions are\n+  \/\/ complete it is safe to directly delete the thread at any time.\n+  ThreadsSMRSupport::wait_until_not_protected(thread);\n+\n@@ -4442,0 +3430,3 @@\n+    \/\/ Assert that the thread is terminated so that acquiring the\n+    \/\/ Heap_lock doesn't cause the terminated thread to participate in\n+    \/\/ the safepoint protocol.\n@@ -4443,1 +3434,2 @@\n-    MutexLocker ml(Heap_lock, Mutex::_no_safepoint_check_flag);\n+    assert(thread->is_terminated(), \"must be terminated here\");\n+    MutexLocker ml(Heap_lock);\n@@ -4473,5 +3465,2 @@\n-  \/\/ We are after VM_Exit::set_vm_exited() so we can't call\n-  \/\/ thread->smr_delete() or we will block on the Threads_lock.\n-  \/\/ Deleting the shutdown thread here is safe because another\n-  \/\/ JavaThread cannot have an active ThreadsListHandle for\n-  \/\/ this JavaThread.\n+  \/\/ Deleting the shutdown thread here is safe. See comment on\n+  \/\/ wait_until_not_protected() above.\n@@ -4487,2 +3476,0 @@\n-\n-  return true;\n@@ -4534,0 +3521,3 @@\n+  \/\/ Increase the ObjectMonitor ceiling for the new thread.\n+  ObjectSynchronizer::inc_in_use_list_ceiling();\n+\n@@ -4536,0 +3526,3 @@\n+\n+  \/\/ Make new thread known to active EscapeBarrier\n+  EscapeBarrier::thread_added(p);\n@@ -4539,4 +3532,0 @@\n-\n-  \/\/ Reclaim the ObjectMonitors from the om_in_use_list and om_free_list of the moribund thread.\n-  ObjectSynchronizer::om_flush(p);\n-\n@@ -4547,0 +3536,6 @@\n+    \/\/ BarrierSet state must be destroyed after the last thread transition\n+    \/\/ before the thread terminates. Thread transitions result in calls to\n+    \/\/ StackWatermarkSet::on_safepoint(), which performs GC processing,\n+    \/\/ requiring the GC state to be alive.\n+    BarrierSet::barrier_set()->on_thread_detach(p);\n+\n@@ -4568,1 +3563,4 @@\n-    p->set_terminated_value();\n+    p->set_terminated(JavaThread::_thread_terminated);\n+\n+    \/\/ Notify threads waiting in EscapeBarriers\n+    EscapeBarrier::thread_removed(p);\n@@ -4571,0 +3569,3 @@\n+  \/\/ Reduce the ObjectMonitor ceiling for the exiting thread.\n+  ObjectSynchronizer::dec_in_use_list_ceiling();\n+\n@@ -4641,11 +3642,0 @@\n-void Threads::nmethods_do(CodeBlobClosure* cf) {\n-  ALL_JAVA_THREADS(p) {\n-    \/\/ This is used by the code cache sweeper to mark nmethods that are active\n-    \/\/ on the stack of a Java thread. Ignore the sweeper thread itself to avoid\n-    \/\/ marking CodeCacheSweeperThread::_scanned_compiled_method as active.\n-    if(!p->is_Code_cache_sweeper_thread()) {\n-      p->nmethods_do(cf);\n-    }\n-  }\n-}\n-\n@@ -4683,0 +3673,2 @@\n+    \/\/ The first stage of async deflation does not affect any field\n+    \/\/ used by this comparison so the ObjectMonitor* is usable here.\n@@ -4725,0 +3717,16 @@\n+class PrintOnClosure : public ThreadClosure {\n+private:\n+  outputStream* _st;\n+\n+public:\n+  PrintOnClosure(outputStream* st) :\n+      _st(st) {}\n+\n+  virtual void do_thread(Thread* thread) {\n+    if (thread != NULL) {\n+      thread->print_on(_st);\n+      _st->cr();\n+    }\n+  }\n+};\n+\n@@ -4767,7 +3775,5 @@\n-  VMThread::vm_thread()->print_on(st);\n-  st->cr();\n-  Universe::heap()->print_gc_threads_on(st);\n-  WatcherThread* wt = WatcherThread::watcher_thread();\n-  if (wt != NULL) {\n-    wt->print_on(st);\n-    st->cr();\n+  PrintOnClosure cl(st);\n+  cl.do_thread(VMThread::vm_thread());\n+  Universe::heap()->gc_threads_do(&cl);\n+  if (StringDedup::is_enabled()) {\n+    StringDedup::threads_do(&cl);\n@@ -4775,0 +3781,2 @@\n+  cl.do_thread(WatcherThread::watcher_thread());\n+  cl.do_thread(AsyncLogWriter::instance());\n@@ -4828,0 +3836,6 @@\n+  print_on_error(AsyncLogWriter::instance(), st, current, buf, buflen, &found_current);\n+\n+  if (Universe::heap() != NULL) {\n+    PrintOnErrorClosure print_closure(st, current, buf, buflen, &found_current);\n+    Universe::heap()->gc_threads_do(&print_closure);\n+  }\n@@ -4829,2 +3843,4 @@\n-  PrintOnErrorClosure print_closure(st, current, buf, buflen, &found_current);\n-  Universe::heap()->gc_threads_do(&print_closure);\n+  if (StringDedup::is_enabled()) {\n+    PrintOnErrorClosure print_closure(st, current, buf, buflen, &found_current);\n+    StringDedup::threads_do(&print_closure);\n+  }\n@@ -4864,4 +3880,1 @@\n-\/\/ Internal SpinLock and Mutex\n-\/\/ Based on ParkEvent\n-\n-\/\/ Ad-hoc mutual exclusion primitives: SpinLock and Mux\n+\/\/ Ad-hoc mutual exclusion primitives: SpinLock\n@@ -4872,8 +3885,0 @@\n-\/\/ The mux construct provides a spin-then-block mutual exclusion\n-\/\/ mechanism.\n-\/\/\n-\/\/ Testing has shown that contention on the ListLock guarding gFreeList\n-\/\/ is common.  If we implement ListLock as a simple SpinLock it's common\n-\/\/ for the JVM to devolve to yielding with little progress.  This is true\n-\/\/ despite the fact that the critical sections protected by ListLock are\n-\/\/ extremely short.\n@@ -4932,144 +3937,0 @@\n-\/\/ muxAcquire and muxRelease:\n-\/\/\n-\/\/ *  muxAcquire and muxRelease support a single-word lock-word construct.\n-\/\/    The LSB of the word is set IFF the lock is held.\n-\/\/    The remainder of the word points to the head of a singly-linked list\n-\/\/    of threads blocked on the lock.\n-\/\/\n-\/\/ *  The current implementation of muxAcquire-muxRelease uses its own\n-\/\/    dedicated Thread._MuxEvent instance.  If we're interested in\n-\/\/    minimizing the peak number of extant ParkEvent instances then\n-\/\/    we could eliminate _MuxEvent and \"borrow\" _ParkEvent as long\n-\/\/    as certain invariants were satisfied.  Specifically, care would need\n-\/\/    to be taken with regards to consuming unpark() \"permits\".\n-\/\/    A safe rule of thumb is that a thread would never call muxAcquire()\n-\/\/    if it's enqueued (cxq, EntryList, WaitList, etc) and will subsequently\n-\/\/    park().  Otherwise the _ParkEvent park() operation in muxAcquire() could\n-\/\/    consume an unpark() permit intended for monitorenter, for instance.\n-\/\/    One way around this would be to widen the restricted-range semaphore\n-\/\/    implemented in park().  Another alternative would be to provide\n-\/\/    multiple instances of the PlatformEvent() for each thread.  One\n-\/\/    instance would be dedicated to muxAcquire-muxRelease, for instance.\n-\/\/\n-\/\/ *  Usage:\n-\/\/    -- Only as leaf locks\n-\/\/    -- for short-term locking only as muxAcquire does not perform\n-\/\/       thread state transitions.\n-\/\/\n-\/\/ Alternatives:\n-\/\/ *  We could implement muxAcquire and muxRelease with MCS or CLH locks\n-\/\/    but with parking or spin-then-park instead of pure spinning.\n-\/\/ *  Use Taura-Oyama-Yonenzawa locks.\n-\/\/ *  It's possible to construct a 1-0 lock if we encode the lockword as\n-\/\/    (List,LockByte).  Acquire will CAS the full lockword while Release\n-\/\/    will STB 0 into the LockByte.  The 1-0 scheme admits stranding, so\n-\/\/    acquiring threads use timers (ParkTimed) to detect and recover from\n-\/\/    the stranding window.  Thread\/Node structures must be aligned on 256-byte\n-\/\/    boundaries by using placement-new.\n-\/\/ *  Augment MCS with advisory back-link fields maintained with CAS().\n-\/\/    Pictorially:  LockWord -> T1 <-> T2 <-> T3 <-> ... <-> Tn <-> Owner.\n-\/\/    The validity of the backlinks must be ratified before we trust the value.\n-\/\/    If the backlinks are invalid the exiting thread must back-track through the\n-\/\/    the forward links, which are always trustworthy.\n-\/\/ *  Add a successor indication.  The LockWord is currently encoded as\n-\/\/    (List, LOCKBIT:1).  We could also add a SUCCBIT or an explicit _succ variable\n-\/\/    to provide the usual futile-wakeup optimization.\n-\/\/    See RTStt for details.\n-\/\/\n-\n-\n-const intptr_t LOCKBIT = 1;\n-\n-void Thread::muxAcquire(volatile intptr_t * Lock, const char * LockName) {\n-  intptr_t w = Atomic::cmpxchg(Lock, (intptr_t)0, LOCKBIT);\n-  if (w == 0) return;\n-  if ((w & LOCKBIT) == 0 && Atomic::cmpxchg(Lock, w, w|LOCKBIT) == w) {\n-    return;\n-  }\n-\n-  ParkEvent * const Self = Thread::current()->_MuxEvent;\n-  assert((intptr_t(Self) & LOCKBIT) == 0, \"invariant\");\n-  for (;;) {\n-    int its = (os::is_MP() ? 100 : 0) + 1;\n-\n-    \/\/ Optional spin phase: spin-then-park strategy\n-    while (--its >= 0) {\n-      w = *Lock;\n-      if ((w & LOCKBIT) == 0 && Atomic::cmpxchg(Lock, w, w|LOCKBIT) == w) {\n-        return;\n-      }\n-    }\n-\n-    Self->reset();\n-    Self->OnList = intptr_t(Lock);\n-    \/\/ The following fence() isn't _strictly necessary as the subsequent\n-    \/\/ CAS() both serializes execution and ratifies the fetched *Lock value.\n-    OrderAccess::fence();\n-    for (;;) {\n-      w = *Lock;\n-      if ((w & LOCKBIT) == 0) {\n-        if (Atomic::cmpxchg(Lock, w, w|LOCKBIT) == w) {\n-          Self->OnList = 0;   \/\/ hygiene - allows stronger asserts\n-          return;\n-        }\n-        continue;      \/\/ Interference -- *Lock changed -- Just retry\n-      }\n-      assert(w & LOCKBIT, \"invariant\");\n-      Self->ListNext = (ParkEvent *) (w & ~LOCKBIT);\n-      if (Atomic::cmpxchg(Lock, w, intptr_t(Self)|LOCKBIT) == w) break;\n-    }\n-\n-    while (Self->OnList != 0) {\n-      Self->park();\n-    }\n-  }\n-}\n-\n-\/\/ Release() must extract a successor from the list and then wake that thread.\n-\/\/ It can \"pop\" the front of the list or use a detach-modify-reattach (DMR) scheme\n-\/\/ similar to that used by ParkEvent::Allocate() and ::Release().  DMR-based\n-\/\/ Release() would :\n-\/\/ (A) CAS() or swap() null to *Lock, releasing the lock and detaching the list.\n-\/\/ (B) Extract a successor from the private list \"in-hand\"\n-\/\/ (C) attempt to CAS() the residual back into *Lock over null.\n-\/\/     If there were any newly arrived threads and the CAS() would fail.\n-\/\/     In that case Release() would detach the RATs, re-merge the list in-hand\n-\/\/     with the RATs and repeat as needed.  Alternately, Release() might\n-\/\/     detach and extract a successor, but then pass the residual list to the wakee.\n-\/\/     The wakee would be responsible for reattaching and remerging before it\n-\/\/     competed for the lock.\n-\/\/\n-\/\/ Both \"pop\" and DMR are immune from ABA corruption -- there can be\n-\/\/ multiple concurrent pushers, but only one popper or detacher.\n-\/\/ This implementation pops from the head of the list.  This is unfair,\n-\/\/ but tends to provide excellent throughput as hot threads remain hot.\n-\/\/ (We wake recently run threads first).\n-\/\/\n-\/\/ All paths through muxRelease() will execute a CAS.\n-\/\/ Release consistency -- We depend on the CAS in muxRelease() to provide full\n-\/\/ bidirectional fence\/MEMBAR semantics, ensuring that all prior memory operations\n-\/\/ executed within the critical section are complete and globally visible before the\n-\/\/ store (CAS) to the lock-word that releases the lock becomes globally visible.\n-void Thread::muxRelease(volatile intptr_t * Lock)  {\n-  for (;;) {\n-    const intptr_t w = Atomic::cmpxchg(Lock, LOCKBIT, (intptr_t)0);\n-    assert(w & LOCKBIT, \"invariant\");\n-    if (w == LOCKBIT) return;\n-    ParkEvent * const List = (ParkEvent *) (w & ~LOCKBIT);\n-    assert(List != NULL, \"invariant\");\n-    assert(List->OnList == intptr_t(Lock), \"invariant\");\n-    ParkEvent * const nxt = List->ListNext;\n-    guarantee((intptr_t(nxt) & LOCKBIT) == 0, \"invariant\");\n-\n-    \/\/ The following CAS() releases the lock and pops the head element.\n-    \/\/ The CAS() also ratifies the previously fetched lock-word value.\n-    if (Atomic::cmpxchg(Lock, w, intptr_t(nxt)) != w) {\n-      continue;\n-    }\n-    List->OnList = 0;\n-    OrderAccess::fence();\n-    List->unpark();\n-    return;\n-  }\n-}\n-\n@@ -5084,0 +3945,6 @@\n+\n+#ifndef PRODUCT\n+void JavaThread::verify_cross_modify_fence_failure(JavaThread *thread) {\n+   report_vm_error(__FILE__, __LINE__, \"Cross modify fence failure\", \"%p\", thread);\n+}\n+#endif\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":801,"deletions":1934,"binary":false,"changes":2735,"status":"modified"},{"patch":"@@ -0,0 +1,176 @@\n+\/*\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_RUNTIME_VMOPERATION_HPP\n+#define SHARE_RUNTIME_VMOPERATION_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+\n+\/\/ The following classes are used for operations\n+\/\/ initiated by a Java thread but that must\n+\/\/ take place in the VMThread.\n+\n+#define VM_OP_ENUM(type)   VMOp_##type,\n+\n+\/\/ Note: When new VM_XXX comes up, add 'XXX' to the template table.\n+#define VM_OPS_DO(template)                       \\\n+  template(None)                                  \\\n+  template(Cleanup)                               \\\n+  template(ThreadDump)                            \\\n+  template(PrintThreads)                          \\\n+  template(FindDeadlocks)                         \\\n+  template(ClearICs)                              \\\n+  template(ForceSafepoint)                        \\\n+  template(ForceAsyncSafepoint)                   \\\n+  template(DeoptimizeFrame)                       \\\n+  template(DeoptimizeAll)                         \\\n+  template(ZombieAll)                             \\\n+  template(Verify)                                \\\n+  template(PrintJNI)                              \\\n+  template(HeapDumper)                            \\\n+  template(DeoptimizeTheWorld)                    \\\n+  template(CollectForMetadataAllocation)          \\\n+  template(GC_HeapInspection)                     \\\n+  template(GenCollectFull)                        \\\n+  template(GenCollectFullConcurrent)              \\\n+  template(GenCollectForAllocation)               \\\n+  template(ParallelGCFailedAllocation)            \\\n+  template(ParallelGCSystemGC)                    \\\n+  template(G1CollectForAllocation)                \\\n+  template(G1CollectFull)                         \\\n+  template(G1Concurrent)                          \\\n+  template(G1TryInitiateConcMark)                 \\\n+  template(ZMarkStart)                            \\\n+  template(ZMarkEnd)                              \\\n+  template(ZRelocateStart)                        \\\n+  template(ZVerify)                               \\\n+  template(HandshakeOneThread)                    \\\n+  template(HandshakeAllThreads)                   \\\n+  template(HandshakeFallback)                     \\\n+  template(EnableBiasedLocking)                   \\\n+  template(BulkRevokeBias)                        \\\n+  template(PopulateDumpSharedSpace)               \\\n+  template(JNIFunctionTableCopier)                \\\n+  template(RedefineClasses)                       \\\n+  template(GetObjectMonitorUsage)                 \\\n+  template(GetAllStackTraces)                     \\\n+  template(GetThreadListStackTraces)              \\\n+  template(ChangeBreakpoints)                     \\\n+  template(GetOrSetLocal)                         \\\n+  template(ChangeSingleStep)                      \\\n+  template(HeapWalkOperation)                     \\\n+  template(HeapIterateOperation)                  \\\n+  template(ReportJavaOutOfMemory)                 \\\n+  template(JFRCheckpoint)                         \\\n+  template(ShenandoahFullGC)                      \\\n+  template(ShenandoahInitMark)                    \\\n+  template(ShenandoahFinalMarkStartEvac)          \\\n+  template(ShenandoahInitUpdateRefs)              \\\n+  template(ShenandoahFinalUpdateRefs)             \\\n+  template(ShenandoahFinalRoots)                  \\\n+  template(ShenandoahDegeneratedGC)               \\\n+  template(Exit)                                  \\\n+  template(LinuxDllLoad)                          \\\n+  template(RotateGCLog)                           \\\n+  template(WhiteBoxOperation)                     \\\n+  template(JVMCIResizeCounters)                   \\\n+  template(ClassLoaderStatsOperation)             \\\n+  template(ClassLoaderHierarchyOperation)         \\\n+  template(DumpHashtable)                         \\\n+  template(DumpTouchedMethods)                    \\\n+  template(CleanClassLoaderDataMetaspaces)        \\\n+  template(PrintCompileQueue)                     \\\n+  template(PrintClassHierarchy)                   \\\n+  template(ThreadSuspend)                         \\\n+  template(ThreadsSuspendJVMTI)                   \\\n+  template(ICBufferFull)                          \\\n+  template(ScavengeMonitors)                      \\\n+  template(PrintMetadata)                         \\\n+  template(GTestExecuteAtSafepoint)               \\\n+  template(JFROldObject)                          \\\n+  template(JvmtiPostObjectFree)                   \\\n+  template(VM_Crac)\n+\n+class Thread;\n+class outputStream;\n+\n+class VM_Operation : public StackObj {\n+ public:\n+  enum VMOp_Type {\n+    VM_OPS_DO(VM_OP_ENUM)\n+    VMOp_Terminating\n+  };\n+\n+ private:\n+  Thread*         _calling_thread;\n+\n+  \/\/ The VM operation name array\n+  static const char* _names[];\n+\n+ public:\n+  VM_Operation() : _calling_thread(NULL) {}\n+\n+  \/\/ VM operation support (used by VM thread)\n+  Thread* calling_thread() const                 { return _calling_thread; }\n+  void set_calling_thread(Thread* thread);\n+\n+  \/\/ Called by VM thread - does in turn invoke doit(). Do not override this\n+  void evaluate();\n+\n+  \/\/ evaluate() is called by the VMThread and in turn calls doit().\n+  \/\/ If the thread invoking VMThread::execute((VM_Operation*) is a JavaThread,\n+  \/\/ doit_prologue() is called in that thread before transferring control to\n+  \/\/ the VMThread.\n+  \/\/ If doit_prologue() returns true the VM operation will proceed, and\n+  \/\/ doit_epilogue() will be called by the JavaThread once the VM operation\n+  \/\/ completes. If doit_prologue() returns false the VM operation is cancelled.\n+  virtual void doit()                            = 0;\n+  virtual bool doit_prologue()                   { return true; };\n+  virtual void doit_epilogue()                   {};\n+\n+  \/\/ Configuration. Override these appropriately in subclasses.\n+  virtual VMOp_Type type() const = 0;\n+  virtual bool allow_nested_vm_operations() const { return false; }\n+\n+  \/\/ You may override skip_thread_oop_barriers to return true if the operation\n+  \/\/ does not access thread-private oops (including frames).\n+  virtual bool skip_thread_oop_barriers() const { return false; }\n+\n+  \/\/ An operation can either be done inside a safepoint\n+  \/\/ or concurrently with Java threads running.\n+  virtual bool evaluate_at_safepoint() const { return true; }\n+\n+  \/\/ Debugging\n+  virtual void print_on_error(outputStream* st) const;\n+  virtual const char* name() const  { return _names[type()]; }\n+  static const char* name(int type) {\n+    assert(type >= 0 && type < VMOp_Terminating, \"invalid VM operation type\");\n+    return _names[type];\n+  }\n+#ifndef PRODUCT\n+  void print_on(outputStream* st) const { print_on_error(st); }\n+#endif\n+};\n+\n+#endif \/\/ SHARE_RUNTIME_VMOPERATION_HPP\n","filename":"src\/hotspot\/share\/runtime\/vmOperation.hpp","additions":176,"deletions":0,"binary":false,"changes":176,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,4 @@\n+#include \"classfile\/javaClasses.hpp\"\n+#include \"classfile\/systemDictionary.hpp\"\n+#include \"classfile\/vmClasses.hpp\"\n+#include \"code\/codeCache.hpp\"\n@@ -43,0 +47,1 @@\n+#include \"runtime\/jniHandles.hpp\"\n@@ -44,0 +49,2 @@\n+#include \"runtime\/vmOperations.hpp\"\n+#include \"runtime\/vm_version.hpp\"\n@@ -63,1 +70,1 @@\n-                         SystemDictionary::module_Modules_klass(),\n+                         vmClasses::module_Modules_klass(),\n@@ -93,1 +100,0 @@\n-  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<ClassStatsDCmd>(full_export, true, false));\n@@ -113,0 +119,3 @@\n+#ifdef LINUX\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<PerfMapDCmd>(full_export, true, false));\n+#endif \/\/ LINUX\n@@ -137,0 +146,3 @@\n+#if INCLUDE_CDS\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<DumpSharedArchiveDCmd>(full_export, true, false));\n+#endif \/\/ INCLUDE_CDS\n@@ -215,11 +227,0 @@\n-int HelpDCmd::num_arguments() {\n-  ResourceMark rm;\n-  HelpDCmd* dcmd = new HelpDCmd(NULL, false);\n-  if (dcmd != NULL) {\n-    DCmdMark mark(dcmd);\n-    return dcmd->_dcmdparser.num_arguments();\n-  } else {\n-    return 0;\n-  }\n-}\n-\n@@ -254,11 +255,0 @@\n-int PrintVMFlagsDCmd::num_arguments() {\n-    ResourceMark rm;\n-    PrintVMFlagsDCmd* dcmd = new PrintVMFlagsDCmd(NULL, false);\n-    if (dcmd != NULL) {\n-      DCmdMark mark(dcmd);\n-      return dcmd->_dcmdparser.num_arguments();\n-    } else {\n-      return 0;\n-    }\n-}\n-\n@@ -281,1 +271,1 @@\n-  int ret = WriteableFlags::set_flag(_flag.value(), val, JVMFlag::MANAGEMENT, err_msg);\n+  int ret = WriteableFlags::set_flag(_flag.value(), val, JVMFlagOrigin::MANAGEMENT, err_msg);\n@@ -288,11 +278,0 @@\n-int SetVMFlagDCmd::num_arguments() {\n-  ResourceMark rm;\n-  SetVMFlagDCmd* dcmd = new SetVMFlagDCmd(NULL, false);\n-  if (dcmd != NULL) {\n-    DCmdMark mark(dcmd);\n-    return dcmd->_dcmdparser.num_arguments();\n-  } else {\n-    return 0;\n-  }\n-}\n-\n@@ -306,0 +285,1 @@\n+#if INCLUDE_JVMTI\n@@ -355,10 +335,1 @@\n-int JVMTIAgentLoadDCmd::num_arguments() {\n-  ResourceMark rm;\n-  JVMTIAgentLoadDCmd* dcmd = new JVMTIAgentLoadDCmd(NULL, false);\n-  if (dcmd != NULL) {\n-    DCmdMark mark(dcmd);\n-    return dcmd->_dcmdparser.num_arguments();\n-  } else {\n-    return 0;\n-  }\n-}\n+#endif \/\/ INCLUDE_JVMTI\n@@ -401,1 +372,1 @@\n-  oop res = (oop)result.get_jobject();\n+  oop res = result.get_oop();\n@@ -426,11 +397,0 @@\n-int VMUptimeDCmd::num_arguments() {\n-  ResourceMark rm;\n-  VMUptimeDCmd* dcmd = new VMUptimeDCmd(NULL, false);\n-  if (dcmd != NULL) {\n-    DCmdMark mark(dcmd);\n-    return dcmd->_dcmdparser.num_arguments();\n-  } else {\n-    return 0;\n-  }\n-}\n-\n@@ -446,2 +406,1 @@\n-  Klass* k = SystemDictionary::resolve_or_fail(vmSymbols::java_lang_System(),\n-                                                 true, CHECK);\n+  Klass* k = vmClasses::System_klass();\n@@ -455,1 +414,1 @@\n-  MutexLocker hl(Heap_lock);\n+  MutexLocker hl(THREAD, Heap_lock);\n@@ -460,1 +419,1 @@\n-  ResourceMark rm;\n+  ResourceMark rm(THREAD);\n@@ -474,1 +433,1 @@\n-  objArrayOop result_oop = (objArrayOop) result.get_jobject();\n+  objArrayOop result_oop = (objArrayOop) result.get_oop();\n@@ -511,1 +470,4 @@\n-       \"BOOLEAN\", false, \"false\") {\n+       \"BOOLEAN\", false, \"false\"),\n+  _gzip(\"-gz\", \"If specified, the heap dump is written in gzipped format \"\n+               \"using the given compression level. 1 (recommended) is the fastest, \"\n+               \"9 the strongest compression.\", \"INT\", false, \"1\") {\n@@ -514,0 +476,1 @@\n+  _dcmdparser.add_dcmd_option(&_gzip);\n@@ -517,0 +480,11 @@\n+  jlong level = -1; \/\/ -1 means no compression.\n+\n+  if (_gzip.is_set()) {\n+    level = _gzip.value();\n+\n+    if (level < 1 || level > 9) {\n+      output()->print_cr(\"Compression level out of range (1-9): \" JLONG_FORMAT, level);\n+      return;\n+    }\n+  }\n+\n@@ -521,12 +495,1 @@\n-  dumper.dump(_filename.value(), output());\n-}\n-\n-int HeapDumpDCmd::num_arguments() {\n-  ResourceMark rm;\n-  HeapDumpDCmd* dcmd = new HeapDumpDCmd(NULL, false);\n-  if (dcmd != NULL) {\n-    DCmdMark mark(dcmd);\n-    return dcmd->_dcmdparser.num_arguments();\n-  } else {\n-    return 0;\n-  }\n+  dumper.dump(_filename.value(), output(), (int) level);\n@@ -538,1 +501,8 @@\n-       \"BOOLEAN\", false, \"false\") {\n+       \"BOOLEAN\", false, \"false\"),\n+  _parallel_thread_num(\"-parallel\",\n+       \"Number of parallel threads to use for heap inspection. \"\n+       \"0 (the default) means let the VM determine the number of threads to use. \"\n+       \"1 means use one thread (disable parallelism). \"\n+       \"For any other value the VM will try to use the specified number of \"\n+       \"threads, but might use fewer.\",\n+       \"INT\", false, \"0\") {\n@@ -540,0 +510,1 @@\n+  _dcmdparser.add_dcmd_option(&_parallel_thread_num);\n@@ -543,13 +514,4 @@\n-  VM_GC_HeapInspection heapop(output(),\n-                              !_all.value() \/* request full gc if false *\/);\n-  VMThread::execute(&heapop);\n-}\n-\n-int ClassHistogramDCmd::num_arguments() {\n-  ResourceMark rm;\n-  ClassHistogramDCmd* dcmd = new ClassHistogramDCmd(NULL, false);\n-  if (dcmd != NULL) {\n-    DCmdMark mark(dcmd);\n-    return dcmd->_dcmdparser.num_arguments();\n-  } else {\n-    return 0;\n+  jlong num = _parallel_thread_num.value();\n+  if (num < 0) {\n+    output()->print_cr(\"Parallel thread number out of range (>=0): \" JLONG_FORMAT, num);\n+    return;\n@@ -557,21 +519,3 @@\n-}\n-\n-#define DEFAULT_COLUMNS \"InstBytes,KlassBytes,CpAll,annotations,MethodCount,Bytecodes,MethodAll,ROAll,RWAll,Total\"\n-ClassStatsDCmd::ClassStatsDCmd(outputStream* output, bool heap) :\n-                                       DCmdWithParser(output, heap),\n-  _all(\"-all\", \"Show all columns\",\n-       \"BOOLEAN\", false, \"false\"),\n-  _csv(\"-csv\", \"Print in CSV (comma-separated values) format for spreadsheets\",\n-       \"BOOLEAN\", false, \"false\"),\n-  _help(\"-help\", \"Show meaning of all the columns\",\n-       \"BOOLEAN\", false, \"false\"),\n-  _columns(\"columns\", \"Comma-separated list of all the columns to show. \"\n-           \"If not specified, the following columns are shown: \" DEFAULT_COLUMNS,\n-           \"STRING\", false) {\n-  _dcmdparser.add_dcmd_option(&_all);\n-  _dcmdparser.add_dcmd_option(&_csv);\n-  _dcmdparser.add_dcmd_option(&_help);\n-  _dcmdparser.add_dcmd_argument(&_columns);\n-}\n-\n-void ClassStatsDCmd::execute(DCmdSource source, TRAPS) {\n+  uint parallel_thread_num = num == 0\n+      ? MAX2<uint>(1, (uint)os::initial_active_processor_count() * 3 \/ 8)\n+      : num;\n@@ -579,18 +523,2 @@\n-                              true \/* request_full_gc *\/);\n-  heapop.set_csv_format(_csv.value());\n-  heapop.set_print_help(_help.value());\n-  heapop.set_print_class_stats(true);\n-  if (_all.value()) {\n-    if (_columns.has_value()) {\n-      output()->print_cr(\"Cannot specify -all and individual columns at the same time\");\n-      return;\n-    } else {\n-      heapop.set_columns(NULL);\n-    }\n-  } else {\n-    if (_columns.has_value()) {\n-      heapop.set_columns(_columns.value());\n-    } else {\n-      heapop.set_columns(DEFAULT_COLUMNS);\n-    }\n-  }\n+                              !_all.value(), \/* request full gc if false *\/\n+                              parallel_thread_num);\n@@ -600,10 +528,0 @@\n-int ClassStatsDCmd::num_arguments() {\n-  ResourceMark rm;\n-  ClassStatsDCmd* dcmd = new ClassStatsDCmd(NULL, false);\n-  if (dcmd != NULL) {\n-    DCmdMark mark(dcmd);\n-    return dcmd->_dcmdparser.num_arguments();\n-  } else {\n-    return 0;\n-  }\n-}\n@@ -634,11 +552,0 @@\n-int ThreadDumpDCmd::num_arguments() {\n-  ResourceMark rm;\n-  ThreadDumpDCmd* dcmd = new ThreadDumpDCmd(NULL, false);\n-  if (dcmd != NULL) {\n-    DCmdMark mark(dcmd);\n-    return dcmd->_dcmdparser.num_arguments();\n-  } else {\n-    return 0;\n-  }\n-}\n-\n@@ -705,1 +612,1 @@\n-   \"set com.sun.management.jmxremote.ssl_config_file\", \"STRING\", false),\n+   \"set com.sun.management.jmxremote.ssl.config.file\", \"STRING\", false),\n@@ -760,13 +667,0 @@\n-\n-int JMXStartRemoteDCmd::num_arguments() {\n-  ResourceMark rm;\n-  JMXStartRemoteDCmd* dcmd = new JMXStartRemoteDCmd(NULL, false);\n-  if (dcmd != NULL) {\n-    DCmdMark mark(dcmd);\n-    return dcmd->_dcmdparser.num_arguments();\n-  } else {\n-    return 0;\n-  }\n-}\n-\n-\n@@ -901,1 +795,1 @@\n-  oop str = (oop) jv->l;\n+  oop str = cast_to_oop(jv->l);\n@@ -935,0 +829,6 @@\n+#ifdef LINUX\n+void PerfMapDCmd::execute(DCmdSource source, TRAPS) {\n+  CodeCache::write_perf_map();\n+}\n+#endif \/\/ LINUX\n+\n@@ -954,11 +854,0 @@\n-\n-int CodeHeapAnalyticsDCmd::num_arguments() {\n-  ResourceMark rm;\n-  CodeHeapAnalyticsDCmd* dcmd = new CodeHeapAnalyticsDCmd(NULL, false);\n-  if (dcmd != NULL) {\n-    DCmdMark mark(dcmd);\n-    return dcmd->_dcmdparser.num_arguments();\n-  } else {\n-    return 0;\n-  }\n-}\n@@ -995,11 +884,0 @@\n-int EventLogDCmd::num_arguments() {\n-  ResourceMark rm;\n-  EventLogDCmd* dcmd = new EventLogDCmd(NULL, false);\n-  if (dcmd != NULL) {\n-    DCmdMark mark(dcmd);\n-    return dcmd->_dcmdparser.num_arguments();\n-  } else {\n-    return 0;\n-  }\n-}\n-\n@@ -1020,11 +898,0 @@\n-int CompilerDirectivesAddDCmd::num_arguments() {\n-  ResourceMark rm;\n-  CompilerDirectivesAddDCmd* dcmd = new CompilerDirectivesAddDCmd(NULL, false);\n-  if (dcmd != NULL) {\n-    DCmdMark mark(dcmd);\n-    return dcmd->_dcmdparser.num_arguments();\n-  } else {\n-    return 0;\n-  }\n-}\n-\n@@ -1057,12 +924,0 @@\n-\n-int ClassHierarchyDCmd::num_arguments() {\n-  ResourceMark rm;\n-  ClassHierarchyDCmd* dcmd = new ClassHierarchyDCmd(NULL, false);\n-  if (dcmd != NULL) {\n-    DCmdMark mark(dcmd);\n-    return dcmd->_dcmdparser.num_arguments();\n-  } else {\n-    return 0;\n-  }\n-}\n-\n@@ -1086,4 +941,0 @@\n-TouchedMethodsDCmd::TouchedMethodsDCmd(outputStream* output, bool heap) :\n-                                       DCmdWithParser(output, heap)\n-{}\n-\n@@ -1099,2 +950,8 @@\n-int TouchedMethodsDCmd::num_arguments() {\n-  return 0;\n+#if INCLUDE_CDS\n+DumpSharedArchiveDCmd::DumpSharedArchiveDCmd(outputStream* output, bool heap) :\n+                                     DCmdWithParser(output, heap),\n+  _suboption(\"subcmd\", \"static_dump | dynamic_dump\", \"STRING\", true),\n+  _filename(\"filename\", \"Name of shared archive to be dumped\", \"STRING\", false)\n+{\n+  _dcmdparser.add_dcmd_argument(&_suboption);\n+  _dcmdparser.add_dcmd_argument(&_filename);\n@@ -1103,0 +960,43 @@\n+void DumpSharedArchiveDCmd::execute(DCmdSource source, TRAPS) {\n+  jboolean is_static;\n+  const char* scmd = _suboption.value();\n+  const char* file = _filename.value();\n+\n+  if (strcmp(scmd, \"static_dump\") == 0) {\n+    is_static = JNI_TRUE;\n+    output()->print_cr(\"Static dump:\");\n+  } else if (strcmp(scmd, \"dynamic_dump\") == 0) {\n+    is_static = JNI_FALSE;\n+    output()->print_cr(\"Dynamic dump:\");\n+    if (!UseSharedSpaces) {\n+      output()->print_cr(\"Dynamic dump is unsupported when base CDS archive is not loaded\");\n+      return;\n+    }\n+    if (!RecordDynamicDumpInfo) {\n+      output()->print_cr(\"Dump dynamic should run with -XX:+RecordDynamicDumpInfo\");\n+      return;\n+    }\n+  } else {\n+    output()->print_cr(\"Invalid command for VM.cds, valid input is static_dump or dynamic_dump\");\n+    return;\n+  }\n+\n+  \/\/ call CDS.dumpSharedArchive\n+  Handle fileh;\n+  if (file != NULL) {\n+    fileh =  java_lang_String::create_from_str(_filename.value(), CHECK);\n+  }\n+  Symbol* cds_name  = vmSymbols::jdk_internal_misc_CDS();\n+  Klass*  cds_klass = SystemDictionary::resolve_or_fail(cds_name, true \/*throw error*\/,  CHECK);\n+  JavaValue result(T_VOID);\n+  JavaCallArguments args;\n+  args.push_int(is_static);\n+  args.push_oop(fileh);\n+  JavaCalls::call_static(&result,\n+                         cds_klass,\n+                         vmSymbols::dumpSharedArchive(),\n+                         vmSymbols::dumpSharedArchive_signature(),\n+                         &args, CHECK);\n+}\n+#endif \/\/ INCLUDE_CDS\n+\n@@ -1108,3 +1008,0 @@\n-DebugOnCmdStartDCmd::DebugOnCmdStartDCmd(outputStream* output, bool heap) : DCmdWithParser(output, heap) {\n-}\n-\n@@ -1115,1 +1012,1 @@\n-  JavaThread* thread = (JavaThread*) THREAD;\n+  JavaThread* thread = THREAD;\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":118,"deletions":221,"binary":false,"changes":339,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,1 +55,0 @@\n-  static int num_arguments();\n@@ -72,1 +71,0 @@\n-  static int num_arguments() { return 0; }\n@@ -89,1 +87,0 @@\n-  static int num_arguments() { return 0; }\n@@ -111,1 +108,0 @@\n-    static int num_arguments() { return 0; }\n@@ -133,1 +129,0 @@\n-  static int num_arguments();\n@@ -156,1 +151,0 @@\n-  static int num_arguments();\n@@ -175,1 +169,0 @@\n-  static int num_arguments() { return 0; }\n@@ -197,1 +190,0 @@\n-  static int num_arguments();\n@@ -220,3 +212,0 @@\n-  static int num_arguments() {\n-    return 0;\n-  };\n@@ -238,1 +227,0 @@\n-  static int num_arguments();\n@@ -255,1 +243,0 @@\n-  static int num_arguments() { return 0; }\n@@ -269,1 +256,0 @@\n-    static int num_arguments() { return 0; }\n@@ -283,1 +269,0 @@\n-    static int num_arguments() { return 0; }\n@@ -297,1 +282,0 @@\n-  static int num_arguments() { return 0; }\n@@ -317,1 +301,0 @@\n-  static int num_arguments() { return 0; }\n@@ -333,0 +316,1 @@\n+  DCmdArgument<jlong> _gzip;\n@@ -350,1 +334,0 @@\n-  static int num_arguments();\n@@ -359,0 +342,1 @@\n+  DCmdArgument<jlong> _parallel_thread_num;\n@@ -375,1 +359,0 @@\n-  static int num_arguments();\n@@ -379,22 +362,0 @@\n-class ClassStatsDCmd : public DCmdWithParser {\n-protected:\n-  DCmdArgument<bool> _all;\n-  DCmdArgument<bool> _csv;\n-  DCmdArgument<bool> _help;\n-  DCmdArgument<char*> _columns;\n-public:\n-  ClassStatsDCmd(outputStream* output, bool heap);\n-  static const char* name() {\n-    return \"GC.class_stats\";\n-  }\n-  static const char* description() {\n-    return \"(Deprecated) Provide statistics about Java class meta data.\";\n-  }\n-  static const char* impact() {\n-    return \"High: Depends on Java heap size and content.\";\n-  }\n-  static int num_arguments();\n-  virtual void execute(DCmdSource source, TRAPS);\n-};\n-\n-\n@@ -424,1 +385,0 @@\n-  static int num_arguments();\n@@ -428,1 +388,1 @@\n-class TouchedMethodsDCmd : public DCmdWithParser {\n+class TouchedMethodsDCmd : public DCmd {\n@@ -430,1 +390,1 @@\n-  TouchedMethodsDCmd(outputStream* output, bool heap);\n+  TouchedMethodsDCmd(outputStream* output, bool heap) : DCmd(output, heap) {}\n@@ -440,0 +400,24 @@\n+  virtual void execute(DCmdSource source, TRAPS);\n+};\n+\n+#if INCLUDE_CDS\n+class DumpSharedArchiveDCmd: public DCmdWithParser {\n+protected:\n+  DCmdArgument<char*> _suboption;   \/\/ option of VM.cds\n+  DCmdArgument<char*> _filename;    \/\/ file name, optional\n+public:\n+  DumpSharedArchiveDCmd(outputStream* output, bool heap);\n+  static const char* name() {\n+    return \"VM.cds\";\n+  }\n+  static const char* description() {\n+    return \"Dump a static or dynamic shared archive including all shareable classes\";\n+  }\n+  static const char* impact() {\n+    return \"Medium: Pause time depends on number of loaded classes\";\n+  }\n+  static const JavaPermission permission() {\n+    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n+                        \"monitor\", NULL};\n+    return p;\n+  }\n@@ -443,0 +427,1 @@\n+#endif \/\/ INCLUDE_CDS\n@@ -463,1 +448,0 @@\n-  static int num_arguments();\n@@ -512,3 +496,0 @@\n-  static int num_arguments();\n-\n-\n@@ -597,1 +578,0 @@\n-  static int num_arguments() { return 0; }\n@@ -601,0 +581,22 @@\n+#ifdef LINUX\n+class PerfMapDCmd : public DCmd {\n+public:\n+  PerfMapDCmd(outputStream* output, bool heap) : DCmd(output, heap) {}\n+  static const char* name() {\n+    return \"Compiler.perfmap\";\n+  }\n+  static const char* description() {\n+    return \"Write map file for Linux perf tool.\";\n+  }\n+  static const char* impact() {\n+    return \"Low\";\n+  }\n+  static const JavaPermission permission() {\n+    JavaPermission p = {\"java.lang.management.ManagementPermission\",\n+                        \"monitor\", NULL};\n+    return p;\n+  }\n+  virtual void execute(DCmdSource source, TRAPS);\n+};\n+#endif \/\/ LINUX\n+\n@@ -618,1 +620,0 @@\n-  static int num_arguments() { return 0; }\n@@ -622,1 +623,0 @@\n-\n@@ -640,1 +640,0 @@\n-  static int num_arguments() { return 0; }\n@@ -666,1 +665,0 @@\n-  static int num_arguments();\n@@ -688,1 +686,0 @@\n-  static int num_arguments() { return 0; }\n@@ -709,1 +706,0 @@\n-  static int num_arguments() { return 0; }\n@@ -732,1 +728,0 @@\n-  static int num_arguments();\n@@ -753,1 +748,0 @@\n-  static int num_arguments() { return 0; }\n@@ -819,1 +813,0 @@\n-  static int num_arguments();\n@@ -842,1 +835,0 @@\n-  static int num_arguments();\n@@ -865,1 +857,0 @@\n-  static int num_arguments();\n@@ -870,1 +861,1 @@\n-class DebugOnCmdStartDCmd : public DCmdWithParser {\n+class DebugOnCmdStartDCmd : public DCmd {\n@@ -872,1 +863,1 @@\n-  DebugOnCmdStartDCmd(outputStream* output, bool heap);\n+  DebugOnCmdStartDCmd(outputStream* output, bool heap) : DCmd(output, heap) {}\n@@ -886,1 +877,0 @@\n-  static int num_arguments() { return 0; }\n@@ -911,1 +901,0 @@\n-  static int num_arguments();\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":54,"deletions":65,"binary":false,"changes":119,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2005, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2020, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Azul Systems, Inc. All rights reserved.\n@@ -91,3 +91,2 @@\n-    \/\/ file descriptors used for interrupt\n-    private int fd0;\n-    private int fd1;\n+    \/\/ eventfd object used for interrupt\n+    private EventFD eventfd;\n@@ -112,3 +111,2 @@\n-            long fds = IOUtil.makePipe(false);\n-            fd0 = (int) (fds >>> 32);\n-            fd1 = (int) fds;\n+            this.eventfd = new EventFD();\n+            IOUtil.configureBlocking(IOUtil.newFD(eventfd.efd()), false);\n@@ -121,2 +119,2 @@\n-        \/\/ register one end of the socket pair for wakeups\n-        EPoll.ctl(epfd, EPOLL_CTL_ADD, fd0, EPOLLIN);\n+        \/\/ register the eventfd object for wakeups\n+        EPoll.ctl(epfd, EPOLL_CTL_ADD, eventfd.efd(), EPOLLIN);\n@@ -147,1 +145,0 @@\n-            IOUtil.drain(fd0);\n@@ -151,0 +148,2 @@\n+                eventfd.close();\n+                eventfd = null;\n@@ -152,2 +151,0 @@\n-                FileDispatcherImpl.closeIntFD(fd0);\n-                FileDispatcherImpl.closeIntFD(fd1);\n@@ -177,1 +174,1 @@\n-                    IOUtil.write1(fd1, (byte)0);\n+                    eventfd.set();\n@@ -279,1 +276,1 @@\n-            if (fd == fd0) {\n+            if (fd == eventfd.efd()) {\n@@ -309,2 +306,1 @@\n-        FileDispatcherImpl.closeIntFD(fd0);\n-        FileDispatcherImpl.closeIntFD(fd1);\n+        eventfd.close();\n@@ -342,1 +338,1 @@\n-                    IOUtil.write1(fd1, (byte)0);\n+                    eventfd.set();\n@@ -354,1 +350,1 @@\n-            IOUtil.drain(fd0);\n+            eventfd.reset();\n@@ -367,1 +363,1 @@\n-            IOUtil.write1(fd1, (byte)0);\n+            eventfd.set();\n","filename":"src\/java.base\/linux\/classes\/sun\/nio\/ch\/EPollSelectorImpl.java","additions":16,"deletions":20,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+import java.nio.charset.CharacterCodingException;\n@@ -49,0 +50,2 @@\n+import java.util.List;\n+import java.util.Locale;\n@@ -54,0 +57,1 @@\n+import java.util.TreeSet;\n@@ -56,1 +60,0 @@\n-import java.util.function.Function;\n@@ -59,0 +62,1 @@\n+import java.util.jar.JarFile;\n@@ -61,1 +65,1 @@\n-import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.JavaUtilJarAccess;\n@@ -70,0 +74,1 @@\n+import sun.security.util.SignatureFileVerifier;\n@@ -96,1 +101,0 @@\n-    private final @Stable ZipCoder zc;\n@@ -227,0 +231,2 @@\n+        file = new File(name);\n+        @SuppressWarnings(\"removal\")\n@@ -236,1 +242,0 @@\n-        this.zc = ZipCoder.get(charset);\n@@ -240,1 +245,1 @@\n-        this.res = new CleanableResource(this, file, mode);\n+        this.res = new CleanableResource(this, ZipCoder.get(charset), file, mode);\n@@ -311,1 +316,1 @@\n-            return zc.toString(res.zsrc.comment);\n+            return res.zsrc.zc.toString(res.zsrc.comment);\n@@ -324,14 +329,1 @@\n-        return getEntry(name, ZipEntry::new);\n-    }\n-\n-    \/*\n-     * Returns the zip file entry for the specified name, or null\n-     * if not found.\n-     *\n-     * @param name the name of the entry\n-     * @param func the function that creates the returned entry\n-     *\n-     * @return the zip file entry, or null if not found\n-     * @throws IllegalStateException if the zip file has been closed\n-     *\/\n-    private ZipEntry getEntry(String name, Function<String, ? extends ZipEntry> func) {\n+        ZipEntry entry = null;\n@@ -341,2 +333,1 @@\n-            byte[] bname = zc.getBytes(name);\n-            int pos = res.zsrc.getEntryPos(bname, true);\n+            int pos = res.zsrc.getEntryPos(name, true);\n@@ -344,1 +335,1 @@\n-                return getZipEntry(name, bname, pos, func);\n+                entry = getZipEntry(name, pos);\n@@ -347,1 +338,1 @@\n-        return null;\n+        return entry;\n@@ -366,1 +357,1 @@\n-        int pos = -1;\n+        int pos;\n@@ -374,3 +365,1 @@\n-            } else if (!zc.isUTF8() && (entry.flag & USE_UTF8) != 0) {\n-                pos = zsrc.getEntryPos(zc.getBytesUTF8(entry.name), false);\n-                pos = zsrc.getEntryPos(zc.getBytes(entry.name), false);\n+                pos = zsrc.getEntryPos(entry.name, false);\n@@ -492,2 +481,1 @@\n-        private final Function<String, T> gen;\n-        public ZipEntryIterator(int entryCount, Function<String, T> gen) {\n+        public ZipEntryIterator(int entryCount) {\n@@ -496,1 +484,0 @@\n-            this.gen = gen;\n@@ -523,1 +510,1 @@\n-                return (T)getZipEntry(null, null, res.zsrc.getEntryPos(i++ * 3), gen);\n+                return (T)getZipEntry(null, res.zsrc.getEntryPos(i++ * 3));\n@@ -541,1 +528,1 @@\n-            return new ZipEntryIterator<ZipEntry>(res.zsrc.total, ZipEntry::new);\n+            return new ZipEntryIterator<ZipEntry>(res.zsrc.total);\n@@ -545,1 +532,1 @@\n-    private Enumeration<JarEntry> entries(Function<String, JarEntry> func) {\n+    private Enumeration<JarEntry> jarEntries() {\n@@ -548,1 +535,1 @@\n-            return new ZipEntryIterator<JarEntry>(res.zsrc.total, func);\n+            return new ZipEntryIterator<JarEntry>(res.zsrc.total);\n@@ -595,1 +582,1 @@\n-                pos -> getZipEntry(null, null, pos, ZipEntry::new)), false);\n+                pos -> getZipEntry(null, pos)), false);\n@@ -602,5 +589,2 @@\n-        if (!zc.isUTF8() && (CENFLG(cen, pos) & USE_UTF8) != 0) {\n-            return zc.toStringUTF8(cen, pos + CENHDR, nlen);\n-        } else {\n-            return zc.toString(cen, pos + CENHDR, nlen);\n-        }\n+        ZipCoder zc = res.zsrc.zipCoderForPos(pos);\n+        return zc.toString(cen, pos + CENHDR, nlen);\n@@ -633,1 +617,0 @@\n-     * @param func the function that creates the returned entry\n@@ -638,1 +621,1 @@\n-    private Stream<JarEntry> stream(Function<String, JarEntry> func) {\n+    private Stream<JarEntry> jarStream() {\n@@ -642,1 +625,1 @@\n-                pos -> (JarEntry)getZipEntry(null, null, pos, func)), false);\n+                pos -> (JarEntry)getZipEntry(null, pos)), false);\n@@ -649,3 +632,2 @@\n-    \/* Checks ensureOpen() before invoke this method *\/\n-    private ZipEntry getZipEntry(String name, byte[] bname, int pos,\n-                                 Function<String, ? extends ZipEntry> func) {\n+    \/* Check ensureOpen() before invoking this method *\/\n+    private ZipEntry getZipEntry(String name, int pos) {\n@@ -656,10 +638,10 @@\n-        int flag = CENFLG(cen, pos);\n-        if (name == null || bname.length != nlen) {\n-            \/\/ to use the entry name stored in cen, if the passed in name is\n-            \/\/ (1) null, invoked from iterator, or\n-            \/\/ (2) not equal to the name stored, a slash is appended during\n-            \/\/ getEntryPos() search.\n-            if (!zc.isUTF8() && (flag & USE_UTF8) != 0) {\n-                name = zc.toStringUTF8(cen, pos + CENHDR, nlen);\n-            } else {\n-                name = zc.toString(cen, pos + CENHDR, nlen);\n+\n+        ZipCoder zc = res.zsrc.zipCoderForPos(pos);\n+        if (name != null) {\n+            \/\/ only need to check for mismatch of trailing slash\n+            if (nlen > 0 &&\n+                !name.isEmpty() &&\n+                zc.hasTrailingSlash(cen, pos + CENHDR + nlen) &&\n+                !name.endsWith(\"\/\"))\n+            {\n+                name += '\/';\n@@ -667,0 +649,9 @@\n+        } else {\n+            \/\/ invoked from iterator, use the entry name stored in cen\n+            name = zc.toString(cen, pos + CENHDR, nlen);\n+        }\n+        ZipEntry e;\n+        if (this instanceof JarFile) {\n+            e = Source.JUJA.entryFor((JarFile)this, name);\n+        } else {\n+            e = new ZipEntry(name);\n@@ -668,2 +659,1 @@\n-        ZipEntry e = func.apply(name);    \/\/ZipEntry e = new ZipEntry(name);\n-        e.flag = flag;\n+        e.flag = CENFLG(cen, pos);\n@@ -675,0 +665,5 @@\n+        if (CENVEM_FA(cen, pos) == FILE_ATTRIBUTES_UNIX) {\n+            \/\/ read all bits in this field, including sym link attributes\n+            e.extraAttributes = CENATX_PERMS(cen, pos) & 0xFFFF;\n+        }\n+\n@@ -681,5 +676,1 @@\n-            if (!zc.isUTF8() && (flag & USE_UTF8) != 0) {\n-                e.comment = zc.toStringUTF8(cen, start, clen);\n-            } else {\n-                e.comment = zc.toString(cen, start, clen);\n-            }\n+            e.comment = zc.toString(cen, start, clen);\n@@ -716,1 +707,1 @@\n-        CleanableResource(ZipFile zf, File file, int mode) throws IOException {\n+        CleanableResource(ZipFile zf, ZipCoder zc, File file, int mode) throws IOException {\n@@ -720,1 +711,1 @@\n-            this.zsrc = Source.get(file, (mode & OPEN_DELETE) != 0);\n+            this.zsrc = Source.get(file, (mode & OPEN_DELETE) != 0, zc);\n@@ -813,8 +804,0 @@\n-        CleanableResource(File file, int mode)\n-            throws IOException {\n-            this.cleanable = null;\n-            this.istreams = Collections.newSetFromMap(new WeakHashMap<>());\n-            this.inflaterCache = new ArrayDeque<>();\n-            this.zsrc = Source.get(file, (mode & OPEN_DELETE) != 0);\n-        }\n-\n@@ -1033,4 +1016,3 @@\n-     * Returns the names of all non-directory entries that begin with\n-     * \"META-INF\/\" (case ignored). This method is used in JarFile, via\n-     * SharedSecrets, as an optimization when looking up manifest and\n-     * signature file entries. Returns null if no entries were found.\n+     * Returns the names of the META-INF\/MANIFEST.MF entry - if exists -\n+     * and any signature-related files under META-INF. This method is used in\n+     * JarFile, via SharedSecrets, as an optimization.\n@@ -1038,1 +1020,1 @@\n-    private String[] getMetaInfEntryNames() {\n+    private List<String> getManifestAndSignatureRelatedFiles() {\n@@ -1042,2 +1024,5 @@\n-            if (zsrc.metanames == null) {\n-                return null;\n+            int[] metanames = zsrc.signatureMetaNames;\n+            List<String> files = null;\n+            if (zsrc.manifestPos >= 0) {\n+                files = new ArrayList<>();\n+                files.add(getEntryName(zsrc.manifestPos));\n@@ -1045,6 +1030,38 @@\n-            String[] names = new String[zsrc.metanames.length];\n-            byte[] cen = zsrc.cen;\n-            for (int i = 0; i < names.length; i++) {\n-                int pos = zsrc.metanames[i];\n-                names[i] = new String(cen, pos + CENHDR, CENNAM(cen, pos),\n-                                      UTF_8.INSTANCE);\n+            if (metanames != null) {\n+                if (files == null) {\n+                    files = new ArrayList<>();\n+                }\n+                for (int i = 0; i < metanames.length; i++) {\n+                    files.add(getEntryName(metanames[i]));\n+                }\n+            }\n+            return files == null ? List.of() : files;\n+        }\n+    }\n+\n+    \/**\n+     * Returns the number of the META-INF\/MANIFEST.MF entries, case insensitive.\n+     * When this number is greater than 1, JarVerifier will treat a file as\n+     * unsigned.\n+     *\/\n+    private int getManifestNum() {\n+        synchronized (this) {\n+            ensureOpen();\n+            return res.zsrc.manifestNum;\n+        }\n+    }\n+\n+    \/**\n+     * Returns the name of the META-INF\/MANIFEST.MF entry, ignoring\n+     * case. If {@code onlyIfSignatureRelatedFiles} is true, we only return the\n+     * manifest if there is also at least one signature-related file.\n+     * This method is used in JarFile, via SharedSecrets, as an optimization\n+     * when looking up the manifest file.\n+     *\/\n+    private String getManifestName(boolean onlyIfSignatureRelatedFiles) {\n+        synchronized (this) {\n+            ensureOpen();\n+            Source zsrc = res.zsrc;\n+            int pos = zsrc.manifestPos;\n+            if (pos >= 0 && (!onlyIfSignatureRelatedFiles || zsrc.signatureMetaNames != null)) {\n+                return getEntryName(pos);\n@@ -1052,1 +1069,15 @@\n-            return names;\n+        }\n+        return null;\n+    }\n+\n+    \/**\n+     * Returns the versions for which there exists a non-directory\n+     * entry that begin with \"META-INF\/versions\/\" (case ignored).\n+     * This method is used in JarFile, via SharedSecrets, as an\n+     * optimization when looking up potentially versioned entries.\n+     * Returns an empty array if no versioned entries exist.\n+     *\/\n+    private int[] getMetaInfVersions() {\n+        synchronized (this) {\n+            ensureOpen();\n+            return res.zsrc.metaVersions;\n@@ -1071,1 +1102,0 @@\n-    private static final JavaLangAccess JLA;\n@@ -1081,2 +1111,10 @@\n-                public String[] getMetaInfEntryNames(ZipFile zip) {\n-                    return zip.getMetaInfEntryNames();\n+                public List<String> getManifestAndSignatureRelatedFiles(JarFile jar) {\n+                    return ((ZipFile)jar).getManifestAndSignatureRelatedFiles();\n+                }\n+                @Override\n+                public int getManifestNum(JarFile jar) {\n+                    return ((ZipFile)jar).getManifestNum();\n+                }\n+                @Override\n+                public String getManifestName(JarFile jar, boolean onlyIfHasSignatureRelatedFiles) {\n+                    return ((ZipFile)jar).getManifestName(onlyIfHasSignatureRelatedFiles);\n@@ -1085,3 +1123,2 @@\n-                public JarEntry getEntry(ZipFile zip, String name,\n-                    Function<String, JarEntry> func) {\n-                    return (JarEntry)zip.getEntry(name, func);\n+                public int[] getMetaInfVersions(JarFile jar) {\n+                    return ((ZipFile)jar).getMetaInfVersions();\n@@ -1090,3 +1127,2 @@\n-                public Enumeration<JarEntry> entries(ZipFile zip,\n-                    Function<String, JarEntry> func) {\n-                    return zip.entries(func);\n+                public Enumeration<JarEntry> entries(ZipFile zip) {\n+                    return zip.jarEntries();\n@@ -1095,3 +1131,2 @@\n-                public Stream<JarEntry> stream(ZipFile zip,\n-                    Function<String, JarEntry> func) {\n-                    return zip.stream(func);\n+                public Stream<JarEntry> stream(ZipFile zip) {\n+                    return zip.jarStream();\n@@ -1103,0 +1138,9 @@\n+                @Override\n+                public int getExtraAttributes(ZipEntry ze) {\n+                    return ze.extraAttributes;\n+                }\n+                @Override\n+                public void setExtraAttributes(ZipEntry ze, int extraAttrs) {\n+                    ze.extraAttributes = extraAttrs;\n+                }\n+\n@@ -1105,1 +1149,0 @@\n-        JLA = SharedSecrets.getJavaLangAccess();\n@@ -1110,0 +1153,7 @@\n+        \/\/ While this is only used from ZipFile, defining it there would cause\n+        \/\/ a bootstrap cycle that would leave this initialized as null\n+        private static final JavaUtilJarAccess JUJA = SharedSecrets.javaUtilJarAccess();\n+        \/\/ \"META-INF\/\".length()\n+        private static final int META_INF_LEN = 9;\n+        private static final int[] EMPTY_META_VERSIONS = new int[0];\n+\n@@ -1111,0 +1161,2 @@\n+        private final @Stable ZipCoder zc;   \/\/ zip coder used to decode\/encode\n+\n@@ -1118,1 +1170,4 @@\n-        private int[] metanames;\n+        private int   manifestPos = -1;      \/\/ position of the META-INF\/MANIFEST.MF, if exists\n+        private int   manifestNum = 0;       \/\/ number of META-INF\/MANIFEST.MF, case insensitive\n+        private int[] signatureMetaNames;    \/\/ positions of signature related entries, if such exist\n+        private int[] metaVersions;          \/\/ list of unique versions found in META-INF\/versions\/\n@@ -1136,1 +1191,1 @@\n-        \/\/ {@code hash}, {@code next} and {@code \"pos\"} for each entry. The entry can then be\n+        \/\/ {@code hash}, {@code next} and {@code pos} for each entry. The entry can then be\n@@ -1140,5 +1195,37 @@\n-        private int addEntry(int index, int hash, int next, int pos) {\n-            entries[index++] = hash;\n-            entries[index++] = next;\n-            entries[index++] = pos;\n-            return index;\n+\n+        \/\/ Checks the entry at offset pos in the CEN, calculates the Entry values as per above,\n+        \/\/ then returns the length of the entry name.\n+        private int checkAndAddEntry(int pos, int index)\n+            throws ZipException\n+        {\n+            byte[] cen = this.cen;\n+            if (CENSIG(cen, pos) != CENSIG) {\n+                zerror(\"invalid CEN header (bad signature)\");\n+            }\n+            int method = CENHOW(cen, pos);\n+            int flag   = CENFLG(cen, pos);\n+            if ((flag & 1) != 0) {\n+                zerror(\"invalid CEN header (encrypted entry)\");\n+            }\n+            if (method != STORED && method != DEFLATED) {\n+                zerror(\"invalid CEN header (bad compression method: \" + method + \")\");\n+            }\n+            int entryPos = pos + CENHDR;\n+            int nlen = CENNAM(cen, pos);\n+            if (entryPos + nlen > cen.length - ENDHDR) {\n+                zerror(\"invalid CEN header (bad header size)\");\n+            }\n+            try {\n+                ZipCoder zcp = zipCoderForPos(pos);\n+                int hash = zcp.checkedHash(cen, entryPos, nlen);\n+                int hsh = (hash & 0x7fffffff) % tablelen;\n+                int next = table[hsh];\n+                table[hsh] = index;\n+                \/\/ Record the CEN offset and the name hash in our hash cell.\n+                entries[index++] = hash;\n+                entries[index++] = next;\n+                entries[index  ] = pos;\n+            } catch (Exception e) {\n+                zerror(\"invalid CEN header (bad entry name)\");\n+            }\n+            return nlen;\n@@ -1146,0 +1233,1 @@\n+\n@@ -1155,1 +1243,1 @@\n-            BasicFileAttributes attrs;\n+            final BasicFileAttributes attrs;\n@@ -1157,0 +1245,1 @@\n+            final boolean utf8;\n@@ -1158,1 +1247,1 @@\n-            public Key(File file, BasicFileAttributes attrs) {\n+            public Key(File file, BasicFileAttributes attrs, ZipCoder zc) {\n@@ -1161,0 +1250,1 @@\n+                this.utf8 = zc.isUTF8();\n@@ -1164,1 +1254,2 @@\n-                long t = attrs.lastModifiedTime().toMillis();\n+                long t = utf8 ? 0 : Long.MAX_VALUE;\n+                t += attrs.lastModifiedTime().toMillis();\n@@ -1169,2 +1260,4 @@\n-                if (obj instanceof Key) {\n-                    Key key = (Key)obj;\n+                if (obj instanceof Key key) {\n+                    if (key.utf8 != utf8) {\n+                        return false;\n+                    }\n@@ -1187,1 +1280,1 @@\n-        static Source get(File file, boolean toDelete) throws IOException {\n+        static Source get(File file, boolean toDelete, ZipCoder zc) throws IOException {\n@@ -1191,1 +1284,2 @@\n-                        Files.readAttributes(file.toPath(), BasicFileAttributes.class));\n+                        Files.readAttributes(file.toPath(), BasicFileAttributes.class),\n+                        zc);\n@@ -1203,1 +1297,1 @@\n-            src = new Source(key, toDelete);\n+            src = new Source(key, toDelete, zc);\n@@ -1226,1 +1320,2 @@\n-        private Source(Key key, boolean toDelete) throws IOException {\n+        private Source(Key key, boolean toDelete, ZipCoder zc) throws IOException {\n+            this.zc = zc;\n@@ -1258,1 +1353,4 @@\n-            metanames = null;\n+            manifestPos = -1;\n+            manifestNum = 0;\n+            signatureMetaNames = null;\n+            metaVersions = EMPTY_META_VERSIONS;\n@@ -1287,11 +1385,0 @@\n-        private static final int hashN(byte[] a, int off, int len) {\n-            int h = 1;\n-            while (len-- > 0) {\n-                h = 31 * h + a[off++];\n-            }\n-            return h;\n-        }\n-\n-        private static final int hash_append(int hash, byte b) {\n-            return hash * 31 + b;\n-        }\n@@ -1402,2 +1489,1 @@\n-            zerror(\"zip END header not found\");\n-            return null; \/\/make compiler happy\n+            throw new ZipException(\"zip END header not found\");\n@@ -1408,0 +1494,2 @@\n+            \/\/ Prefer locals for better performance during startup\n+            byte[] cen;\n@@ -1413,2 +1501,2 @@\n-                    entries  = new int[0];\n-                    cen = null;\n+                    entries = new int[0];\n+                    this.cen = null;\n@@ -1427,1 +1515,1 @@\n-                cen = new byte[(int)(end.cenlen + ENDHDR)];\n+                cen = this.cen = new byte[(int)(end.cenlen + ENDHDR)];\n@@ -1431,1 +1519,1 @@\n-                total = end.centot;\n+                this.total = end.centot;\n@@ -1433,1 +1521,2 @@\n-                total = knownTotal;\n+                cen = this.cen;\n+                this.total = knownTotal;\n@@ -1436,3 +1525,9 @@\n-            entries  = new int[total * 3];\n-            tablelen = ((total\/2) | 1); \/\/ Odd -> fewer collisions\n-            table    =  new int[tablelen];\n+            int entriesLength = this.total * 3;\n+            entries = new int[entriesLength];\n+\n+            int tablelen = ((total\/2) | 1); \/\/ Odd -> fewer collisions\n+            this.tablelen = tablelen;\n+\n+            int[] table = new int[tablelen];\n+            this.table = table;\n+\n@@ -1440,3 +1535,0 @@\n-            int idx = 0;\n-            int hash = 0;\n-            int next = -1;\n@@ -1445,1 +1537,3 @@\n-            ArrayList<Integer> metanamesList = null;\n+            ArrayList<Integer> signatureNames = null;\n+            \/\/ Set of all version numbers seen in META-INF\/versions\/\n+            Set<Integer> metaVersionsSet = null;\n@@ -1448,2 +1542,1 @@\n-            int i = 0;\n-            int hsh = 0;\n+            int idx = 0; \/\/ Index into the entries array\n@@ -1451,0 +1544,1 @@\n+            int entryPos = CENHDR;\n@@ -1452,2 +1546,3 @@\n-            while (pos + CENHDR <= limit) {\n-                if (i >= total) {\n+            manifestNum = 0;\n+            while (entryPos <= limit) {\n+                if (idx >= entriesLength) {\n@@ -1460,18 +1555,5 @@\n-                if (CENSIG(cen, pos) != CENSIG)\n-                    zerror(\"invalid CEN header (bad signature)\");\n-                int method = CENHOW(cen, pos);\n-                int nlen   = CENNAM(cen, pos);\n-                int elen   = CENEXT(cen, pos);\n-                int clen   = CENCOM(cen, pos);\n-                if ((CENFLG(cen, pos) & 1) != 0)\n-                    zerror(\"invalid CEN header (encrypted entry)\");\n-                if (method != STORED && method != DEFLATED)\n-                    zerror(\"invalid CEN header (bad compression method: \" + method + \")\");\n-                if (pos + CENHDR + nlen > limit)\n-                    zerror(\"invalid CEN header (bad header size)\");\n-                \/\/ Record the CEN offset and the name hash in our hash cell.\n-                hash = hashN(cen, pos + CENHDR, nlen);\n-                hsh = (hash & 0x7fffffff) % tablelen;\n-                next = table[hsh];\n-                table[hsh] = idx;\n-                idx = addEntry(idx, hash, next, pos);\n+\n+                \/\/ Checks the entry and adds values to entries[idx ... idx+2]\n+                int nlen = checkAndAddEntry(pos, idx);\n+                idx += 3;\n+\n@@ -1479,4 +1561,36 @@\n-                if (isMetaName(cen, pos + CENHDR, nlen)) {\n-                    if (metanamesList == null)\n-                        metanamesList = new ArrayList<>(4);\n-                    metanamesList.add(pos);\n+                if (isMetaName(cen, entryPos, nlen)) {\n+                    \/\/ nlen is at least META_INF_LENGTH\n+                    if (isManifestName(entryPos + META_INF_LEN, nlen - META_INF_LEN)) {\n+                        manifestPos = pos;\n+                        manifestNum++;\n+                    } else {\n+                        if (isSignatureRelated(entryPos, nlen)) {\n+                            if (signatureNames == null)\n+                                signatureNames = new ArrayList<>(4);\n+                            signatureNames.add(pos);\n+                        }\n+\n+                        \/\/ If this is a versioned entry, parse the version\n+                        \/\/ and store it for later. This optimizes lookup\n+                        \/\/ performance in multi-release jar files\n+                        int version = getMetaVersion(entryPos + META_INF_LEN, nlen - META_INF_LEN);\n+                        if (version > 0) {\n+                            if (metaVersionsSet == null)\n+                                metaVersionsSet = new TreeSet<>();\n+                            metaVersionsSet.add(version);\n+                        }\n+                    }\n+                }\n+                \/\/ skip to the start of the next entry\n+                pos = nextEntryPos(pos, entryPos, nlen);\n+                entryPos = pos + CENHDR;\n+            }\n+\n+            \/\/ Adjust the total entries\n+            this.total = idx \/ 3;\n+\n+            if (signatureNames != null) {\n+                int len = signatureNames.size();\n+                signatureMetaNames = new int[len];\n+                for (int j = 0; j < len; j++) {\n+                    signatureMetaNames[j] = signatureNames.get(j);\n@@ -1484,8 +1598,5 @@\n-                \/\/ skip ext and comment\n-                pos += (CENHDR + nlen + elen + clen);\n-                i++;\n-            total = i;\n-            if (metanamesList != null) {\n-                metanames = new int[metanamesList.size()];\n-                for (int j = 0, len = metanames.length; j < len; j++) {\n-                    metanames[j] = metanamesList.get(j);\n+            if (metaVersionsSet != null) {\n+                metaVersions = new int[metaVersionsSet.size()];\n+                int c = 0;\n+                for (Integer version : metaVersionsSet) {\n+                    metaVersions[c++] = version;\n@@ -1494,0 +1605,2 @@\n+            } else {\n+                metaVersions = EMPTY_META_VERSIONS;\n@@ -1500,0 +1613,4 @@\n+        private int nextEntryPos(int pos, int entryPos, int nlen) {\n+            return entryPos + nlen + CENCOM(cen, pos) + CENEXT(cen, pos);\n+        }\n+\n@@ -1508,1 +1625,1 @@\n-        private int getEntryPos(byte[] name, boolean addSlash) {\n+        private int getEntryPos(String name, boolean addSlash) {\n@@ -1512,1 +1629,2 @@\n-            int hsh = hashN(name, 0, name.length);\n+\n+            int hsh = ZipCoder.hash(name);\n@@ -1514,28 +1632,26 @@\n-            \/*\n-             * This while loop is an optimization where a double lookup\n-             * for name and name+\/ is being performed. The name char\n-             * array has enough room at the end to try again with a\n-             * slash appended if the first table lookup does not succeed.\n-             *\/\n-            while (true) {\n-                \/*\n-                 * Search down the target hash chain for a entry whose\n-                 * 32 bit hash matches the hashed name.\n-                 *\/\n-                while (idx != ZIP_ENDCHAIN) {\n-                    if (getEntryHash(idx) == hsh) {\n-                        \/\/ The CEN name must match the specfied one\n-                        int pos = getEntryPos(idx);\n-                        if (name.length == CENNAM(cen, pos)) {\n-                            boolean matched = true;\n-                            int nameoff = pos + CENHDR;\n-                            for (int i = 0; i < name.length; i++) {\n-                                if (name[i] != cen[nameoff++]) {\n-                                    matched = false;\n-                                    break;\n-                                }\n-                            }\n-                            if (matched) {\n-                                return pos;\n-                            }\n-                         }\n+\n+            \/\/ Search down the target hash chain for a entry whose\n+            \/\/ 32 bit hash matches the hashed name.\n+            while (idx != ZIP_ENDCHAIN) {\n+                if (getEntryHash(idx) == hsh) {\n+                    \/\/ The CEN name must match the specfied one\n+                    int pos = getEntryPos(idx);\n+\n+                    try {\n+                        ZipCoder zc = zipCoderForPos(pos);\n+                        String entry = zc.toString(cen, pos + CENHDR, CENNAM(cen, pos));\n+\n+                        \/\/ If addSlash is true we'll test for name+\/ in addition to\n+                        \/\/ name, unless name is the empty string or already ends with a\n+                        \/\/ slash\n+                        int entryLen = entry.length();\n+                        int nameLen = name.length();\n+                        if ((entryLen == nameLen && entry.equals(name)) ||\n+                                (addSlash &&\n+                                nameLen + 1 == entryLen &&\n+                                entry.startsWith(name) &&\n+                                entry.charAt(entryLen - 1) == '\/')) {\n+                            return pos;\n+                        }\n+                    } catch (IllegalArgumentException iae) {\n+                        \/\/ Ignore\n@@ -1543,12 +1659,8 @@\n-                    idx = getEntryNext(idx);\n-                \/* If not addSlash, or slash is already there, we are done *\/\n-                if (!addSlash  || name.length == 0 || name[name.length - 1] == '\/') {\n-                     return -1;\n-                }\n-                \/* Add slash and try once more *\/\n-                name = Arrays.copyOf(name, name.length + 1);\n-                name[name.length - 1] = '\/';\n-                hsh = hash_append(hsh, (byte)'\/');\n-                \/\/idx = table[hsh % tablelen];\n-                idx = table[(hsh & 0x7fffffff) % tablelen];\n-                addSlash = false;\n+                idx = getEntryNext(idx);\n+            }\n+            return -1;\n+        }\n+\n+        private ZipCoder zipCoderForPos(int pos) {\n+            if (zc.isUTF8()) {\n+                return zc;\n@@ -1557,0 +1669,4 @@\n+            if ((CENFLG(cen, pos) & USE_UTF8) != 0) {\n+                return ZipCoder.UTF8;\n+            }\n+            return zc;\n@@ -1564,2 +1680,3 @@\n-            \/\/ Use the \"oldest ASCII trick in the book\"\n-            return len > 9                     \/\/ \"META-INF\/\".length()\n+            \/\/ Use the \"oldest ASCII trick in the book\":\n+            \/\/ ch | 0x20 == Character.toLowerCase(ch)\n+            return len > META_INF_LEN       \/\/ \"META-INF\/\".length()\n@@ -1578,0 +1695,88 @@\n+        \/*\n+         * Check if the bytes represents a name equals to MANIFEST.MF\n+         *\/\n+        private boolean isManifestName(int off, int len) {\n+            byte[] name = cen;\n+            return (len == 11 \/\/ \"MANIFEST.MF\".length()\n+                    && (name[off++] | 0x20) == 'm'\n+                    && (name[off++] | 0x20) == 'a'\n+                    && (name[off++] | 0x20) == 'n'\n+                    && (name[off++] | 0x20) == 'i'\n+                    && (name[off++] | 0x20) == 'f'\n+                    && (name[off++] | 0x20) == 'e'\n+                    && (name[off++] | 0x20) == 's'\n+                    && (name[off++] | 0x20) == 't'\n+                    && (name[off++]       ) == '.'\n+                    && (name[off++] | 0x20) == 'm'\n+                    && (name[off]   | 0x20) == 'f');\n+        }\n+\n+        private boolean isSignatureRelated(int off, int len) {\n+            \/\/ Only called when isMetaName(name, off, len) is true, which means\n+            \/\/ len is at least META_INF_LENGTH\n+            \/\/ assert isMetaName(name, off, len)\n+            boolean signatureRelated = false;\n+            byte[] name = cen;\n+            if (name[off + len - 3] == '.') {\n+                \/\/ Check if entry ends with .EC and .SF\n+                int b1 = name[off + len - 2] | 0x20;\n+                int b2 = name[off + len - 1] | 0x20;\n+                if ((b1 == 'e' && b2 == 'c') || (b1 == 's' && b2 == 'f')) {\n+                    signatureRelated = true;\n+                }\n+            } else if (name[off + len - 4] == '.') {\n+                \/\/ Check if entry ends with .DSA and .RSA\n+                int b1 = name[off + len - 3] | 0x20;\n+                int b2 = name[off + len - 2] | 0x20;\n+                int b3 = name[off + len - 1] | 0x20;\n+                if ((b1 == 'r' || b1 == 'd') && b2 == 's' && b3 == 'a') {\n+                    signatureRelated = true;\n+                }\n+            }\n+            \/\/ Above logic must match SignatureFileVerifier.isBlockOrSF\n+            assert(signatureRelated == SignatureFileVerifier\n+                .isBlockOrSF(new String(name, off, len, UTF_8.INSTANCE)\n+                    .toUpperCase(Locale.ENGLISH)));\n+            return signatureRelated;\n+        }\n+\n+        \/*\n+         * If the bytes represents a non-directory name beginning\n+         * with \"versions\/\", continuing with a positive integer,\n+         * followed by a '\/', then return that integer value.\n+         * Otherwise, return 0\n+         *\/\n+        private int getMetaVersion(int off, int len) {\n+            byte[] name = cen;\n+            int nend = off + len;\n+            if (!(len > 10                         \/\/ \"versions\/\/\".length()\n+                    && name[off + len - 1] != '\/'  \/\/ non-directory\n+                    && (name[off++] | 0x20) == 'v'\n+                    && (name[off++] | 0x20) == 'e'\n+                    && (name[off++] | 0x20) == 'r'\n+                    && (name[off++] | 0x20) == 's'\n+                    && (name[off++] | 0x20) == 'i'\n+                    && (name[off++] | 0x20) == 'o'\n+                    && (name[off++] | 0x20) == 'n'\n+                    && (name[off++] | 0x20) == 's'\n+                    && (name[off++]       ) == '\/')) {\n+                return 0;\n+            }\n+            int version = 0;\n+            while (off < nend) {\n+                final byte c = name[off++];\n+                if (c == '\/') {\n+                    return version;\n+                }\n+                if (c < '0' || c > '9') {\n+                    return 0;\n+                }\n+                version = version * 10 + c - '0';\n+                \/\/ Check for overflow and leading zeros\n+                if (version <= 0) {\n+                    return 0;\n+                }\n+            }\n+            return 0;\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipFile.java","additions":427,"deletions":222,"binary":false,"changes":649,"status":"modified"},{"patch":"@@ -58,1 +58,2 @@\n-        traceStartupTime = AccessController.doPrivileged(\n+        @SuppressWarnings(\"removal\")\n+        boolean doTraceStartupTime = AccessController.doPrivileged(\n@@ -64,0 +65,2 @@\n+\n+        traceStartupTime = doTraceStartupTime;\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/Core.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+    @SuppressWarnings(\"removal\")\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/impl\/AbstractContextImpl.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -141,0 +141,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -157,1 +158,1 @@\n-                        AccessControlContext acc) {\n+                        @SuppressWarnings(\"removal\") AccessControlContext acc) {\n@@ -178,1 +179,1 @@\n-    public URLClassPath(URL[] urls, AccessControlContext acc) {\n+    public URLClassPath(URL[] urls, @SuppressWarnings(\"removal\") AccessControlContext acc) {\n@@ -481,0 +482,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -551,0 +553,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -608,1 +611,1 @@\n-                throw new IllegalArgumentException(\"name\");\n+                return null;\n@@ -644,1 +647,1 @@\n-                throw new IllegalArgumentException(\"name\");\n+                return null;\n@@ -652,1 +655,1 @@\n-                InputStream in = uc.getInputStream();\n+\n@@ -660,0 +663,2 @@\n+\n+                InputStream in = uc.getInputStream();\n@@ -713,0 +718,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -724,1 +730,1 @@\n-                          AccessControlContext acc)\n+                          @SuppressWarnings(\"removal\") AccessControlContext acc)\n@@ -755,0 +761,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -798,0 +805,1 @@\n+        @SuppressWarnings(\"removal\")\n@@ -822,1 +830,2 @@\n-                    AccessController.doPrivileged(new PrivilegedAction<Void>() {\n+                    @SuppressWarnings(\"removal\")\n+                    Void v = AccessController.doPrivileged(new PrivilegedAction<Void>() {\n@@ -898,1 +907,1 @@\n-            } catch (AccessControlException e) {\n+            } catch (@SuppressWarnings(\"removal\") AccessControlException e) {\n@@ -988,0 +997,1 @@\n+        @SuppressWarnings(\"removal\")\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/loader\/URLClassPath.java","additions":19,"deletions":9,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,2 @@\n- * <dl>\n- * <dt class=\"simpleTagLabel\" style=\"font-family:'DejaVu Sans', Arial, Helvetica, sans serif\">Providers:<\/dt>\n+ * <dl class=\"notes\">\n+ * <dt>Providers:<\/dt>\n@@ -116,0 +116,1 @@\n+    exports java.util.random;\n@@ -138,0 +139,2 @@\n+    exports com.sun.crypto.provider to\n+        jdk.crypto.cryptoki;\n@@ -143,1 +146,1 @@\n-    exports jdk.internal to\n+    exports jdk.internal.javac to\n@@ -145,1 +148,0 @@\n-        jdk.jfr,\n@@ -154,0 +156,1 @@\n+        jdk.jartool,\n@@ -167,1 +170,3 @@\n-        java.logging;\n+        java.logging,\n+        java.naming,\n+        jdk.incubator.foreign;\n@@ -176,2 +181,1 @@\n-        jdk.jlink,\n-        jdk.scripting.nashorn;\n+        jdk.jlink;\n@@ -182,2 +186,1 @@\n-        jdk.jfr,\n-        jdk.scripting.nashorn;\n+        jdk.jfr;\n@@ -185,4 +188,1 @@\n-        jdk.jfr,\n-        jdk.scripting.nashorn;\n-    exports jdk.internal.org.objectweb.asm.signature to\n-        jdk.scripting.nashorn;\n+        jdk.jfr;\n@@ -201,1 +201,0 @@\n-        java.xml,\n@@ -205,0 +204,2 @@\n+        jdk.crypto.cryptoki,\n+        jdk.incubator.vector,\n@@ -208,2 +209,0 @@\n-        jdk.scripting.nashorn,\n-        jdk.scripting.nashorn.shell,\n@@ -219,1 +218,2 @@\n-        jdk.incubator.jpackage;\n+        jdk.jpackage,\n+        jdk.incubator.foreign;\n@@ -225,1 +225,2 @@\n-        jdk.management;\n+        jdk.management,\n+        jdk.jfr;\n@@ -227,1 +228,2 @@\n-        java.desktop;\n+        java.desktop,\n+        jdk.incubator.foreign;\n@@ -234,2 +236,2 @@\n-        jdk.scripting.nashorn,\n-        jdk.unsupported;\n+        jdk.unsupported,\n+        jdk.incubator.foreign;\n@@ -240,0 +242,1 @@\n+        java.instrument,\n@@ -241,0 +244,3 @@\n+        jdk.incubator.vector,\n+        jdk.incubator.foreign,\n+        jdk.jfr,\n@@ -242,0 +248,4 @@\n+    exports jdk.internal.vm.vector to\n+        jdk.incubator.vector;\n+    exports jdk.internal.util to\n+            jdk.incubator.foreign;\n@@ -248,0 +258,2 @@\n+    exports jdk.internal.util.random to\n+        jdk.random;\n@@ -274,0 +286,2 @@\n+    exports sun.nio.fs to\n+        jdk.net;\n@@ -288,0 +302,1 @@\n+        jdk.crypto.ec,\n@@ -305,0 +320,1 @@\n+        jdk.crypto.ec,\n@@ -349,1 +365,2 @@\n-\n+    exports jdk.internal.invoke to\n+        jdk.incubator.foreign;\n@@ -371,0 +388,1 @@\n+    uses java.util.random.RandomGenerator;\n@@ -394,0 +412,6 @@\n+\n+    provides java.util.random.RandomGenerator with\n+        java.security.SecureRandom,\n+        java.util.Random,\n+        java.util.SplittableRandom;\n+\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":47,"deletions":23,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -0,0 +1,728 @@\n+\/*\n+ * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"java.h\"\n+#include \"jvm_md.h\"\n+#include <dirent.h>\n+#include <dlfcn.h>\n+#include <fcntl.h>\n+#include <inttypes.h>\n+#include <stdio.h>\n+#include <string.h>\n+#include <stdlib.h>\n+#include <sys\/stat.h>\n+#include <unistd.h>\n+#include <sys\/types.h>\n+#include \"manifest_info.h\"\n+\n+\n+#define JVM_DLL \"libjvm.so\"\n+#define JAVA_DLL \"libjava.so\"\n+#ifdef AIX\n+#define LD_LIBRARY_PATH \"LIBPATH\"\n+#else\n+#define LD_LIBRARY_PATH \"LD_LIBRARY_PATH\"\n+#endif\n+\n+\/* help jettison the LD_LIBRARY_PATH settings in the future *\/\n+#ifndef SETENV_REQUIRED\n+#define SETENV_REQUIRED\n+#endif\n+\n+\/*\n+ * Flowchart of launcher execs and options processing on unix\n+ *\n+ * The selection of the proper vm shared library to open depends on\n+ * several classes of command line options, including vm \"flavor\"\n+ * options (-client, -server).\n+ * The vm selection options are not passed to the running\n+ * virtual machine; they must be screened out by the launcher.\n+ *\n+ * The version specification (if any) is processed first by the\n+ * platform independent routine SelectVersion.  This may result in\n+ * the exec of the specified launcher version.\n+ *\n+ * Previously the launcher modified the LD_LIBRARY_PATH appropriately for the\n+ * desired data model path, regardless if data models matched or not. The\n+ * launcher subsequently exec'ed the desired executable, in order to make the\n+ * LD_LIBRARY_PATH path available, for the runtime linker.\n+ *\n+ * Now, in most cases,the launcher will dlopen the target libjvm.so. All\n+ * required libraries are loaded by the runtime linker, using the\n+ * $RPATH\/$ORIGIN baked into the shared libraries at compile time. Therefore,\n+ * in most cases, the launcher will only exec, if the data models are\n+ * mismatched, and will not set any environment variables, regardless of the\n+ * data models.\n+ *\n+ * However, if the environment contains a LD_LIBRARY_PATH, this will cause the\n+ * launcher to inspect the LD_LIBRARY_PATH. The launcher will check\n+ *  a. if the LD_LIBRARY_PATH's first component is the path to the desired\n+ *     libjvm.so\n+ *  b. if any other libjvm.so is found in any of the paths.\n+ * If case b is true, then the launcher will set the LD_LIBRARY_PATH to the\n+ * desired JRE and reexec, in order to propagate the environment.\n+ *\n+ *  Main\n+ *  (incoming argv)\n+ *  |\n+ * \\|\/\n+ * CreateExecutionEnvironment\n+ * (determines desired data model)\n+ *  |\n+ *  |\n+ * \\|\/\n+ *  Have Desired Model ? --> NO --> Exit(with error)\n+ *  |\n+ *  |\n+ * \\|\/\n+ * YES\n+ *  |\n+ *  |\n+ * \\|\/\n+ * CheckJvmType\n+ * (removes -client, -server, etc.)\n+ *  |\n+ *  |\n+ * \\|\/\n+ * TranslateDashJArgs...\n+ * (Prepare to pass args to vm)\n+ *  |\n+ *  |\n+ * \\|\/\n+ * ParseArguments\n+ *   |\n+ *   |\n+ *  \\|\/\n+ * RequiresSetenv\n+ * Is LD_LIBRARY_PATH\n+ * and friends set ? --> NO --> Continue\n+ *  YES\n+ *   |\n+ *   |\n+ *  \\|\/\n+ * Path is desired JRE ? YES --> Continue\n+ *  NO\n+ *   |\n+ *   |\n+ *  \\|\/\n+ * Paths have well known\n+ * jvm paths ?       --> NO --> Error\/Exit\n+ *  YES\n+ *   |\n+ *   |\n+ *  \\|\/\n+ *  Does libjvm.so exist\n+ *  in any of them ? --> NO  --> Continue\n+ *   YES\n+ *   |\n+ *   |\n+ *  \\|\/\n+ *  Set the LD_LIBRARY_PATH\n+ *   |\n+ *   |\n+ *  \\|\/\n+ * Re-exec\n+ *   |\n+ *   |\n+ *  \\|\/\n+ * Main\n+ *\/\n+\n+\/* Store the name of the executable once computed *\/\n+static char *execname = NULL;\n+\n+\/*\n+ * execname accessor from other parts of platform dependent logic\n+ *\/\n+const char *\n+GetExecName() {\n+    return execname;\n+}\n+\n+#ifdef SETENV_REQUIRED\n+static jboolean\n+JvmExists(const char *path) {\n+    char tmp[PATH_MAX + 1];\n+    struct stat statbuf;\n+    JLI_Snprintf(tmp, PATH_MAX, \"%s\/%s\", path, JVM_DLL);\n+    if (stat(tmp, &statbuf) == 0) {\n+        return JNI_TRUE;\n+    }\n+    return JNI_FALSE;\n+}\n+\/*\n+ * contains a lib\/{server,client}\/libjvm.so ?\n+ *\/\n+static jboolean\n+ContainsLibJVM(const char *env) {\n+    \/* the usual suspects *\/\n+    char clientPattern[] = \"lib\/client\";\n+    char serverPattern[] = \"lib\/server\";\n+    char *envpath;\n+    char *path;\n+    char* save_ptr = NULL;\n+    jboolean clientPatternFound;\n+    jboolean serverPatternFound;\n+\n+    \/* fastest path *\/\n+    if (env == NULL) {\n+        return JNI_FALSE;\n+    }\n+\n+    \/* to optimize for time, test if any of our usual suspects are present. *\/\n+    clientPatternFound = JLI_StrStr(env, clientPattern) != NULL;\n+    serverPatternFound = JLI_StrStr(env, serverPattern) != NULL;\n+    if (clientPatternFound == JNI_FALSE && serverPatternFound == JNI_FALSE) {\n+        return JNI_FALSE;\n+    }\n+\n+    \/*\n+     * we have a suspicious path component, check if it contains a libjvm.so\n+     *\/\n+    envpath = JLI_StringDup(env);\n+    for (path = strtok_r(envpath, \":\", &save_ptr); path != NULL; path = strtok_r(NULL, \":\", &save_ptr)) {\n+        if (clientPatternFound && JLI_StrStr(path, clientPattern) != NULL) {\n+            if (JvmExists(path)) {\n+                JLI_MemFree(envpath);\n+                return JNI_TRUE;\n+            }\n+        }\n+        if (serverPatternFound && JLI_StrStr(path, serverPattern)  != NULL) {\n+            if (JvmExists(path)) {\n+                JLI_MemFree(envpath);\n+                return JNI_TRUE;\n+            }\n+        }\n+    }\n+    JLI_MemFree(envpath);\n+    return JNI_FALSE;\n+}\n+\n+\/*\n+ * Test whether the environment variable needs to be set, see flowchart.\n+ *\/\n+static jboolean\n+RequiresSetenv(const char *jvmpath) {\n+    char jpath[PATH_MAX + 1];\n+    char *llp;\n+    char *dmllp = NULL;\n+    char *p; \/* a utility pointer *\/\n+\n+#ifdef MUSL_LIBC\n+    \/*\n+     * The musl library loader requires LD_LIBRARY_PATH to be set in order\n+     * to correctly resolve the dependency libjava.so has on libjvm.so.\n+     *\/\n+    return JNI_TRUE;\n+#endif\n+\n+#ifdef AIX\n+    \/* We always have to set the LIBPATH on AIX because ld doesn't support $ORIGIN. *\/\n+    return JNI_TRUE;\n+#endif\n+\n+    llp = getenv(\"LD_LIBRARY_PATH\");\n+    \/* no environment variable is a good environment variable *\/\n+    if (llp == NULL && dmllp == NULL) {\n+        return JNI_FALSE;\n+    }\n+#ifdef __linux\n+    \/*\n+     * On linux, if a binary is running as sgid or suid, glibc sets\n+     * LD_LIBRARY_PATH to the empty string for security purposes. (In contrast,\n+     * on Solaris the LD_LIBRARY_PATH variable for a privileged binary does not\n+     * lose its settings; but the dynamic linker does apply more scrutiny to the\n+     * path.) The launcher uses the value of LD_LIBRARY_PATH to prevent an exec\n+     * loop, here and further downstream. Therefore, if we are running sgid or\n+     * suid, this function's setting of LD_LIBRARY_PATH will be ineffective and\n+     * we should case a return from the calling function.  Getting the right\n+     * libraries will be handled by the RPATH. In reality, this check is\n+     * redundant, as the previous check for a non-null LD_LIBRARY_PATH will\n+     * return back to the calling function forthwith, it is left here to safe\n+     * guard against any changes, in the glibc's existing security policy.\n+     *\/\n+    if ((getgid() != getegid()) || (getuid() != geteuid())) {\n+        return JNI_FALSE;\n+    }\n+#endif \/* __linux *\/\n+\n+    \/*\n+     * Prevent recursions. Since LD_LIBRARY_PATH is the one which will be set by\n+     * previous versions of the JRE, thus it is the only path that matters here.\n+     * So we check to see if the desired JRE is set.\n+     *\/\n+    JLI_StrNCpy(jpath, jvmpath, PATH_MAX);\n+    p = JLI_StrRChr(jpath, '\/');\n+    *p = '\\0';\n+    if (llp != NULL && JLI_StrNCmp(llp, jpath, JLI_StrLen(jpath)) == 0) {\n+        return JNI_FALSE;\n+    }\n+\n+    \/* scrutinize all the paths further *\/\n+    if (llp != NULL &&  ContainsLibJVM(llp)) {\n+        return JNI_TRUE;\n+    }\n+    if (dmllp != NULL && ContainsLibJVM(dmllp)) {\n+        return JNI_TRUE;\n+    }\n+    return JNI_FALSE;\n+}\n+#endif \/* SETENV_REQUIRED *\/\n+\n+void\n+CreateExecutionEnvironment(int *pargc, char ***pargv,\n+                           char jrepath[], jint so_jrepath,\n+                           char jvmpath[], jint so_jvmpath,\n+                           char jvmcfg[],  jint so_jvmcfg) {\n+\n+    char * jvmtype = NULL;\n+    int argc = *pargc;\n+    char **argv = *pargv;\n+\n+#ifdef SETENV_REQUIRED\n+    jboolean mustsetenv = JNI_FALSE;\n+    char *runpath = NULL; \/* existing effective LD_LIBRARY_PATH setting *\/\n+    char* new_runpath = NULL; \/* desired new LD_LIBRARY_PATH string *\/\n+    char* newpath = NULL; \/* path on new LD_LIBRARY_PATH *\/\n+    char* lastslash = NULL;\n+    char** newenvp = NULL; \/* current environment *\/\n+    size_t new_runpath_size;\n+#endif  \/* SETENV_REQUIRED *\/\n+\n+    \/* Compute\/set the name of the executable *\/\n+    SetExecname(*pargv);\n+\n+    \/* Check to see if the jvmpath exists *\/\n+    \/* Find out where the JRE is that we will be using. *\/\n+    if (!GetJREPath(jrepath, so_jrepath, JNI_FALSE)) {\n+        JLI_ReportErrorMessage(JRE_ERROR1);\n+        exit(2);\n+    }\n+    JLI_Snprintf(jvmcfg, so_jvmcfg, \"%s%slib%sjvm.cfg\",\n+            jrepath, FILESEP, FILESEP);\n+    \/* Find the specified JVM type *\/\n+    if (ReadKnownVMs(jvmcfg, JNI_FALSE) < 1) {\n+        JLI_ReportErrorMessage(CFG_ERROR7);\n+        exit(1);\n+    }\n+\n+    jvmpath[0] = '\\0';\n+    jvmtype = CheckJvmType(pargc, pargv, JNI_FALSE);\n+    if (JLI_StrCmp(jvmtype, \"ERROR\") == 0) {\n+        JLI_ReportErrorMessage(CFG_ERROR9);\n+        exit(4);\n+    }\n+\n+    if (!GetJVMPath(jrepath, jvmtype, jvmpath, so_jvmpath)) {\n+        JLI_ReportErrorMessage(CFG_ERROR8, jvmtype, jvmpath);\n+        exit(4);\n+    }\n+    \/*\n+     * we seem to have everything we need, so without further ado\n+     * we return back, otherwise proceed to set the environment.\n+     *\/\n+#ifdef SETENV_REQUIRED\n+    mustsetenv = RequiresSetenv(jvmpath);\n+    JLI_TraceLauncher(\"mustsetenv: %s\\n\", mustsetenv ? \"TRUE\" : \"FALSE\");\n+\n+    if (mustsetenv == JNI_FALSE) {\n+        return;\n+    }\n+#else\n+    return;\n+#endif \/* SETENV_REQUIRED *\/\n+\n+#ifdef SETENV_REQUIRED\n+    if (mustsetenv) {\n+        \/*\n+         * We will set the LD_LIBRARY_PATH as follows:\n+         *\n+         *     o          $JVMPATH (directory portion only)\n+         *     o          $JRE\/lib\n+         *     o          $JRE\/..\/lib\n+         *\n+         * followed by the user's previous effective LD_LIBRARY_PATH, if\n+         * any.\n+         *\/\n+\n+        runpath = getenv(LD_LIBRARY_PATH);\n+\n+        \/* runpath contains current effective LD_LIBRARY_PATH setting *\/\n+        { \/* New scope to declare local variable *\/\n+            char *new_jvmpath = JLI_StringDup(jvmpath);\n+            new_runpath_size = ((runpath != NULL) ? JLI_StrLen(runpath) : 0) +\n+                    2 * JLI_StrLen(jrepath) +\n+                    JLI_StrLen(new_jvmpath) + 52;\n+            new_runpath = JLI_MemAlloc(new_runpath_size);\n+            newpath = new_runpath + JLI_StrLen(LD_LIBRARY_PATH \"=\");\n+\n+\n+            \/*\n+             * Create desired LD_LIBRARY_PATH value for target data model.\n+             *\/\n+            {\n+                \/* remove the name of the .so from the JVM path *\/\n+                lastslash = JLI_StrRChr(new_jvmpath, '\/');\n+                if (lastslash)\n+                    *lastslash = '\\0';\n+\n+                sprintf(new_runpath, LD_LIBRARY_PATH \"=\"\n+                        \"%s:\"\n+                        \"%s\/lib:\"\n+                        \"%s\/..\/lib\",\n+                        new_jvmpath,\n+                        jrepath,\n+                        jrepath\n+                        );\n+\n+                JLI_MemFree(new_jvmpath);\n+\n+                \/*\n+                 * Check to make sure that the prefix of the current path is the\n+                 * desired environment variable setting, though the RequiresSetenv\n+                 * checks if the desired runpath exists, this logic does a more\n+                 * comprehensive check.\n+                 *\/\n+                if (runpath != NULL &&\n+                        JLI_StrNCmp(newpath, runpath, JLI_StrLen(newpath)) == 0 &&\n+                        (runpath[JLI_StrLen(newpath)] == 0 ||\n+                        runpath[JLI_StrLen(newpath)] == ':')) {\n+                    JLI_MemFree(new_runpath);\n+                    return;\n+                }\n+            }\n+        }\n+\n+        \/*\n+         * Place the desired environment setting onto the prefix of\n+         * LD_LIBRARY_PATH.  Note that this prevents any possible infinite\n+         * loop of execv() because we test for the prefix, above.\n+         *\/\n+        if (runpath != 0) {\n+            \/* ensure storage for runpath + colon + NULL *\/\n+            if ((JLI_StrLen(runpath) + 1 + 1) > new_runpath_size) {\n+                JLI_ReportErrorMessageSys(JRE_ERROR11);\n+                exit(1);\n+            }\n+            JLI_StrCat(new_runpath, \":\");\n+            JLI_StrCat(new_runpath, runpath);\n+        }\n+\n+        if (putenv(new_runpath) != 0) {\n+            \/* problem allocating memory; LD_LIBRARY_PATH not set properly *\/\n+            exit(1);\n+        }\n+\n+        \/*\n+         * Unix systems document that they look at LD_LIBRARY_PATH only\n+         * once at startup, so we have to re-exec the current executable\n+         * to get the changed environment variable to have an effect.\n+         *\/\n+\n+        newenvp = environ;\n+    }\n+#endif \/* SETENV_REQUIRED *\/\n+    {\n+        char *newexec = execname;\n+        JLI_TraceLauncher(\"TRACER_MARKER:About to EXEC\\n\");\n+        (void) fflush(stdout);\n+        (void) fflush(stderr);\n+#ifdef SETENV_REQUIRED\n+        if (mustsetenv) {\n+            execve(newexec, argv, newenvp);\n+        } else {\n+            execv(newexec, argv);\n+        }\n+#else \/* !SETENV_REQUIRED *\/\n+        execv(newexec, argv);\n+#endif \/* SETENV_REQUIRED *\/\n+        JLI_ReportErrorMessageSys(JRE_ERROR4, newexec);\n+    }\n+    exit(1);\n+}\n+\n+\n+static jboolean\n+GetJVMPath(const char *jrepath, const char *jvmtype,\n+           char *jvmpath, jint jvmpathsize)\n+{\n+    struct stat s;\n+\n+    if (JLI_StrChr(jvmtype, '\/')) {\n+        JLI_Snprintf(jvmpath, jvmpathsize, \"%s\/\" JVM_DLL, jvmtype);\n+    } else {\n+        JLI_Snprintf(jvmpath, jvmpathsize, \"%s\/lib\/%s\/\" JVM_DLL, jrepath, jvmtype);\n+    }\n+\n+    JLI_TraceLauncher(\"Does `%s' exist ... \", jvmpath);\n+\n+    if (stat(jvmpath, &s) == 0) {\n+        JLI_TraceLauncher(\"yes.\\n\");\n+        return JNI_TRUE;\n+    } else {\n+        JLI_TraceLauncher(\"no.\\n\");\n+        return JNI_FALSE;\n+    }\n+}\n+\n+\/*\n+ * Find path to JRE based on .exe's location or registry settings.\n+ *\/\n+static jboolean\n+GetJREPath(char *path, jint pathsize, jboolean speculative)\n+{\n+    char libjava[MAXPATHLEN];\n+    struct stat s;\n+\n+    if (GetApplicationHome(path, pathsize)) {\n+        \/* Is JRE co-located with the application? *\/\n+        JLI_Snprintf(libjava, sizeof(libjava), \"%s\/lib\/\" JAVA_DLL, path);\n+        if (access(libjava, F_OK) == 0) {\n+            JLI_TraceLauncher(\"JRE path is %s\\n\", path);\n+            return JNI_TRUE;\n+        }\n+        \/* ensure storage for path + \/jre + NULL *\/\n+        if ((JLI_StrLen(path) + 4  + 1) > (size_t) pathsize) {\n+            JLI_TraceLauncher(\"Insufficient space to store JRE path\\n\");\n+            return JNI_FALSE;\n+        }\n+        \/* Does the app ship a private JRE in <apphome>\/jre directory? *\/\n+        JLI_Snprintf(libjava, sizeof(libjava), \"%s\/jre\/lib\/\" JAVA_DLL, path);\n+        if (access(libjava, F_OK) == 0) {\n+            JLI_StrCat(path, \"\/jre\");\n+            JLI_TraceLauncher(\"JRE path is %s\\n\", path);\n+            return JNI_TRUE;\n+        }\n+    }\n+\n+    if (GetApplicationHomeFromDll(path, pathsize)) {\n+        JLI_Snprintf(libjava, sizeof(libjava), \"%s\/lib\/\" JAVA_DLL, path);\n+        if (stat(libjava, &s) == 0) {\n+            JLI_TraceLauncher(\"JRE path is %s\\n\", path);\n+            return JNI_TRUE;\n+        }\n+    }\n+\n+    if (!speculative)\n+      JLI_ReportErrorMessage(JRE_ERROR8 JAVA_DLL);\n+    return JNI_FALSE;\n+}\n+\n+jboolean\n+LoadJavaVM(const char *jvmpath, InvocationFunctions *ifn)\n+{\n+    void *libjvm;\n+\n+    JLI_TraceLauncher(\"JVM path is %s\\n\", jvmpath);\n+\n+    libjvm = dlopen(jvmpath, RTLD_NOW + RTLD_GLOBAL);\n+    if (libjvm == NULL) {\n+        JLI_ReportErrorMessage(DLL_ERROR1, __LINE__);\n+        JLI_ReportErrorMessage(DLL_ERROR2, jvmpath, dlerror());\n+        return JNI_FALSE;\n+    }\n+\n+    ifn->CreateJavaVM = (CreateJavaVM_t)\n+        dlsym(libjvm, \"JNI_CreateJavaVM\");\n+    if (ifn->CreateJavaVM == NULL) {\n+        JLI_ReportErrorMessage(DLL_ERROR2, jvmpath, dlerror());\n+        return JNI_FALSE;\n+    }\n+\n+    ifn->GetDefaultJavaVMInitArgs = (GetDefaultJavaVMInitArgs_t)\n+        dlsym(libjvm, \"JNI_GetDefaultJavaVMInitArgs\");\n+    if (ifn->GetDefaultJavaVMInitArgs == NULL) {\n+        JLI_ReportErrorMessage(DLL_ERROR2, jvmpath, dlerror());\n+        return JNI_FALSE;\n+    }\n+\n+    ifn->GetCreatedJavaVMs = (GetCreatedJavaVMs_t)\n+        dlsym(libjvm, \"JNI_GetCreatedJavaVMs\");\n+    if (ifn->GetCreatedJavaVMs == NULL) {\n+        JLI_ReportErrorMessage(DLL_ERROR2, jvmpath, dlerror());\n+        return JNI_FALSE;\n+    }\n+\n+    return JNI_TRUE;\n+}\n+\n+\/*\n+ * Compute the name of the executable\n+ *\n+ * In order to re-exec securely we need the absolute path of the\n+ * executable. On Solaris getexecname(3c) may not return an absolute\n+ * path so we use dladdr to get the filename of the executable and\n+ * then use realpath to derive an absolute path. From Solaris 9\n+ * onwards the filename returned in DL_info structure from dladdr is\n+ * an absolute pathname so technically realpath isn't required.\n+ * On Linux we read the executable name from \/proc\/self\/exe.\n+ * As a fallback, and for platforms other than Solaris and Linux,\n+ * we use FindExecName to compute the executable name.\n+ *\/\n+const char*\n+SetExecname(char **argv)\n+{\n+    char* exec_path = NULL;\n+#if defined(__linux__)\n+    {\n+        const char* self = \"\/proc\/self\/exe\";\n+        char buf[PATH_MAX+1];\n+        int len = readlink(self, buf, PATH_MAX);\n+        if (len >= 0) {\n+            buf[len] = '\\0';            \/* readlink(2) doesn't NUL terminate *\/\n+            exec_path = JLI_StringDup(buf);\n+        }\n+    }\n+#else \/* !__linux__ *\/\n+    {\n+        \/* Not implemented *\/\n+    }\n+#endif\n+\n+    if (exec_path == NULL) {\n+        exec_path = FindExecName(argv[0]);\n+    }\n+    execname = exec_path;\n+    return exec_path;\n+}\n+\n+\/* --- Splash Screen shared library support --- *\/\n+static const char* SPLASHSCREEN_SO = JNI_LIB_NAME(\"splashscreen\");\n+static void* hSplashLib = NULL;\n+\n+void* SplashProcAddress(const char* name) {\n+    if (!hSplashLib) {\n+        int ret;\n+        char jrePath[MAXPATHLEN];\n+        char splashPath[MAXPATHLEN];\n+\n+        if (!GetJREPath(jrePath, sizeof(jrePath), JNI_FALSE)) {\n+            JLI_ReportErrorMessage(JRE_ERROR1);\n+            return NULL;\n+        }\n+        ret = JLI_Snprintf(splashPath, sizeof(splashPath), \"%s\/lib\/%s\",\n+                     jrePath, SPLASHSCREEN_SO);\n+\n+        if (ret >= (int) sizeof(splashPath)) {\n+            JLI_ReportErrorMessage(JRE_ERROR11);\n+            return NULL;\n+        }\n+        if (ret < 0) {\n+            JLI_ReportErrorMessage(JRE_ERROR13);\n+            return NULL;\n+        }\n+        hSplashLib = dlopen(splashPath, RTLD_LAZY | RTLD_GLOBAL);\n+        JLI_TraceLauncher(\"Info: loaded %s\\n\", splashPath);\n+    }\n+    if (hSplashLib) {\n+        void* sym = dlsym(hSplashLib, name);\n+        return sym;\n+    } else {\n+        return NULL;\n+    }\n+}\n+\n+\/*\n+ * Signature adapter for pthread_create() or thr_create().\n+ *\/\n+static void* ThreadJavaMain(void* args) {\n+    return (void*)(intptr_t)JavaMain(args);\n+}\n+\n+\/*\n+ * Block current thread and continue execution in a new thread.\n+ *\/\n+int\n+CallJavaMainInNewThread(jlong stack_size, void* args) {\n+    int rslt;\n+    pthread_t tid;\n+    pthread_attr_t attr;\n+    pthread_attr_init(&attr);\n+    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);\n+\n+    {\n+      const int restore_signal = SIGRTMIN + 2;\n+      \/\/ block restore_signal in launcher thread to allow JVM handle it\n+      sigset_t block_sig;\n+      sigemptyset(&block_sig);\n+      sigaddset(&block_sig, restore_signal);\n+      pthread_sigmask(SIG_BLOCK, &block_sig, NULL);\n+    }\n+\n+    if (stack_size > 0) {\n+        pthread_attr_setstacksize(&attr, stack_size);\n+    }\n+    pthread_attr_setguardsize(&attr, 0); \/\/ no pthread guard page on java threads\n+\n+    if (pthread_create(&tid, &attr, ThreadJavaMain, args) == 0) {\n+        void* tmp;\n+        pthread_join(tid, &tmp);\n+        rslt = (int)(intptr_t)tmp;\n+    } else {\n+       \/*\n+        * Continue execution in current thread if for some reason (e.g. out of\n+        * memory\/LWP)  a new thread can't be created. This will likely fail\n+        * later in JavaMain as JNI_CreateJavaVM needs to create quite a\n+        * few new threads, anyway, just give it a try..\n+        *\/\n+        rslt = JavaMain(args);\n+    }\n+\n+    pthread_attr_destroy(&attr);\n+    return rslt;\n+}\n+\n+\/* Coarse estimation of number of digits assuming the worst case is a 64-bit pid. *\/\n+#define MAX_PID_STR_SZ   20\n+\n+int\n+JVMInit(InvocationFunctions* ifn, jlong threadStackSize,\n+        int argc, char **argv,\n+        int mode, char *what, int ret)\n+{\n+    ShowSplashScreen();\n+    return ContinueInNewThread(ifn, threadStackSize, argc, argv, mode, what, ret);\n+}\n+\n+void\n+PostJVMInit(JNIEnv *env, jclass mainClass, JavaVM *vm)\n+{\n+    \/\/ stubbed out for windows and *nixes.\n+}\n+\n+void\n+RegisterThread()\n+{\n+    \/\/ stubbed out for windows and *nixes.\n+}\n+\n+\/*\n+ * on unix, we return a false to indicate this option is not applicable\n+ *\/\n+jboolean\n+ProcessPlatformOption(const char *arg)\n+{\n+    return JNI_FALSE;\n+}\n","filename":"src\/java.base\/unix\/native\/libjli\/java_md.c","additions":728,"deletions":0,"binary":false,"changes":728,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -282,39 +282,0 @@\n-#ifdef __solaris__\n-        if (connect_rv == -1 && errno == EINPROGRESS ) {\n-\n-            \/* This can happen if a blocking connect is interrupted by a signal.\n-             * See 6343810.\n-             *\/\n-            while (1) {\n-                struct pollfd pfd;\n-                pfd.fd = fd;\n-                pfd.events = POLLOUT;\n-\n-                connect_rv = NET_Poll(&pfd, 1, -1);\n-\n-                if (connect_rv == -1) {\n-                    if (errno == EINTR) {\n-                        continue;\n-                    } else {\n-                        break;\n-                    }\n-                }\n-                if (connect_rv > 0) {\n-                    socklen_t optlen;\n-                    \/* has connection been established *\/\n-                    optlen = sizeof(connect_rv);\n-                    if (getsockopt(fd, SOL_SOCKET, SO_ERROR,\n-                                   (void*)&connect_rv, &optlen) <0) {\n-                        connect_rv = errno;\n-                    }\n-\n-                    if (connect_rv != 0) {\n-                        \/* restore errno *\/\n-                        errno = connect_rv;\n-                        connect_rv = -1;\n-                    }\n-                    break;\n-                }\n-            }\n-        }\n-#endif\n@@ -909,1 +870,1 @@\n-#if defined(__solaris__) || defined(_AIX)\n+#if defined(_AIX)\n@@ -911,1 +872,1 @@\n-            \/\/ On Solaris setsockopt will set errno to EINVAL if the socket\n+            \/\/ On AIX setsockopt will set errno to EINVAL if the socket\n@@ -918,1 +879,1 @@\n-#endif \/* __solaris__ *\/\n+#endif \/* _AIX *\/\n","filename":"src\/java.base\/unix\/native\/libnet\/PlainSocketImpl.c","additions":4,"deletions":43,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,4 @@\n+#ifdef MACOSX\n+#include <sys\/mount.h>\n+#include <sys\/param.h>\n+#endif\n@@ -191,3 +195,12 @@\n-    if (result == -1 && errno == ENOTSUP) {\n-        \/* Try fsync() in case F_FULLSYUNC is not implemented on the file system. *\/\n-        result = fsync(fd);\n+    if (result == -1) {\n+        struct statfs fbuf;\n+        int errno_fcntl = errno;\n+        if (fstatfs(fd, &fbuf) == 0) {\n+            if ((fbuf.f_flags & MNT_LOCAL) == 0) {\n+                \/* Try fsync() in case file is not local. *\/\n+                result = fsync(fd);\n+            }\n+        } else {\n+            \/* fstatfs() failed so restore errno from fcntl(). *\/\n+            errno = errno_fcntl;\n+        }\n@@ -399,1 +412,1 @@\n-    result == -1;\n+    result = -1;\n","filename":"src\/java.base\/unix\/native\/libnio\/ch\/FileDispatcherImpl.c","additions":18,"deletions":5,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,2 +32,0 @@\n-import java.io.File;\n-import java.io.FileOutputStream;\n@@ -38,2 +36,0 @@\n-import java.io.OutputStreamWriter;\n-import java.io.Writer;\n@@ -58,1 +54,0 @@\n-import static java.util.stream.Collectors.*;\n@@ -63,0 +58,1 @@\n+import jdk.tools.jlink.plugin.PluginException;\n@@ -67,1 +63,4 @@\n-import jdk.tools.jlink.plugin.PluginException;\n+\n+import static java.util.stream.Collectors.groupingBy;\n+import static java.util.stream.Collectors.mapping;\n+import static java.util.stream.Collectors.toSet;\n@@ -449,7 +448,0 @@\n-    private void writeSymEntry(Path dstFile, Path target) throws IOException {\n-        Objects.requireNonNull(dstFile);\n-        Objects.requireNonNull(target);\n-        Files.createDirectories(Objects.requireNonNull(dstFile.getParent()));\n-        Files.createLink(dstFile, target);\n-    }\n-\n@@ -523,7 +515,0 @@\n-    private static void createUtf8File(File file, String content) throws IOException {\n-        try (OutputStream fout = new FileOutputStream(file);\n-                Writer output = new OutputStreamWriter(fout, \"UTF-8\")) {\n-            output.write(content);\n-        }\n-    }\n-\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/builder\/DefaultImageBuilder.java","additions":6,"deletions":21,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+import jdk.crac.*;\n@@ -25,1 +26,1 @@\n-class ChannelResource implements jdk.crac.Resource {\n+class ChannelResource implements Resource {\n@@ -37,1 +38,1 @@\n-        jdk.crac.Core.getGlobalContext().register(this);\n+        Core.getGlobalContext().register(this);\n@@ -51,1 +52,1 @@\n-    public void beforeCheckpoint() throws IOException {\n+    public void beforeCheckpoint(Context<? extends Resource> context) throws IOException {\n@@ -76,1 +77,2 @@\n-    public void afterRestore() {}\n+    public void afterRestore(Context<? extends Resource> context) {\n+    }\n@@ -91,1 +93,1 @@\n-            jdk.crac.Core.checkpointRestore();\n+            Core.checkpointRestore();\n@@ -102,1 +104,1 @@\n-            jdk.crac.Core.checkpointRestore();\n+            Core.checkpointRestore();\n","filename":"test\/jdk\/jdk\/crac\/Selector\/Test970\/Test.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+import jdk.crac.*;\n@@ -25,1 +26,1 @@\n-class ChannelResource implements jdk.crac.Resource {\n+class ChannelResource implements Resource {\n@@ -33,1 +34,1 @@\n-    public ChannelResource() { jdk.crac.Core.getGlobalContext().register(this); }\n+    public ChannelResource() { Core.getGlobalContext().register(this); }\n@@ -47,1 +48,1 @@\n-    public void beforeCheckpoint() throws IOException {\n+    public void beforeCheckpoint(Context<? extends Resource> context) throws IOException {\n@@ -55,1 +56,1 @@\n-    public void afterRestore() {\n+    public void afterRestore(Context<? extends Resource> context) {\n@@ -160,6 +161,3 @@\n-            jdk.crac.Core.checkpointRestore();\n-        } catch (jdk.crac.CheckpointException e) {\n-            e.printExceptions(System.out);\n-            throw e;\n-        } catch (jdk.crac.RestoreException e) {\n-            e.printExceptions(System.out);\n+            Core.checkpointRestore();\n+        } catch (CheckpointException | RestoreException e) {\n+            e.printStackTrace();\n","filename":"test\/jdk\/jdk\/crac\/Selector\/keyAfterRestore\/Test.java","additions":8,"deletions":10,"binary":false,"changes":18,"status":"modified"}]}