{"files":[{"patch":"@@ -35,0 +35,3 @@\n+JVM_Checkpoint\n+JVM_RegisterPersistent\n+JVM_DeregisterPersistent\n","filename":"make\/data\/hotspot-symbols\/symbols-shared","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -91,0 +91,48 @@\n+\n+ifeq ($(OPENJDK_TARGET_OS), linux)\n+  $(eval $(call SetupJdkExecutable, BUILD_RESTORE_SCRIPT, \\\n+      NAME := action-script, \\\n+      SRC := $(TOPDIR)\/src\/$(MODULE)\/unix\/native\/action-script, \\\n+      INCLUDE_FILES := action-script.c, \\\n+      OPTIMIZATION := HIGH, \\\n+      CFLAGS := $(CFLAGS_JDKEXE), \\\n+      LDFLAGS := $(LDFLAGS_JDKEXE), \\\n+      OUTPUT_DIR := $(SUPPORT_OUTPUTDIR)\/modules_libs\/$(MODULE), \\\n+  ))\n+  TARGETS += $(BUILD_RESTORE_SCRIPT)\n+\n+  $(eval $(call SetupJdkExecutable, BUILD_WAIT, \\\n+      NAME := wait, \\\n+      SRC := $(TOPDIR)\/src\/$(MODULE)\/unix\/native\/wait, \\\n+      INCLUDE_FILES := wait.c, \\\n+      OPTIMIZATION := LOW, \\\n+      CFLAGS := $(CFLAGS_JDKEXE), \\\n+      LDFLAGS := $(LDFLAGS_JDKEXE), \\\n+      OUTPUT_DIR := $(SUPPORT_OUTPUTDIR)\/modules_libs\/$(MODULE), \\\n+  ))\n+  TARGETS += $(BUILD_WAIT)\n+\n+  $(eval $(call SetupJdkExecutable, BUILD_CRIU_WRAPPER, \\\n+      NAME := criu, \\\n+      SRC := $(TOPDIR)\/src\/$(MODULE)\/unix\/native\/criu, \\\n+      INCLUDE_FILES := criu.c, \\\n+      OPTIMIZATION := LOW, \\\n+      CFLAGS := $(CFLAGS_JDKEXE), \\\n+      LDFLAGS := $(LDFLAGS_JDKEXE), \\\n+      OUTPUT_DIR := $(SUPPORT_OUTPUTDIR)\/modules_libs\/$(MODULE), \\\n+  ))\n+  TARGETS += $(BUILD_CRIU_WRAPPER)\n+\n+  $(eval $(call SetupJdkExecutable, BUILD_JAVA_TIME, \\\n+      NAME := javatime, \\\n+      SRC := $(TOPDIR)\/src\/$(MODULE)\/unix\/native\/javatime, \\\n+      INCLUDE_FILES := javatime.c, \\\n+      OPTIMIZATION := LOW, \\\n+      CFLAGS := $(CFLAGS_JDKEXE), \\\n+      LDFLAGS := $(LDFLAGS_JDKEXE), \\\n+      OUTPUT_DIR := $(SUPPORT_OUTPUTDIR)\/modules_libs\/$(MODULE), \\\n+  ))\n+  TARGETS += $(BUILD_JAVA_TIME)\n+endif\n+\n+################################################################################\n","filename":"make\/modules\/java.base\/Launcher.gmk","additions":48,"deletions":0,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2017, 2021, Azul Systems, Inc. All rights reserved.\n@@ -37,0 +38,1 @@\n+#include \"memory\/oopFactory.hpp\"\n@@ -38,0 +40,1 @@\n+#include \"oops\/typeArrayOop.inline.hpp\"\n@@ -42,0 +45,1 @@\n+#include \"perfMemory_linux.hpp\"\n@@ -66,0 +70,2 @@\n+#include \"services\/attachListener.hpp\"\n+#include \"services\/heapDumper.hpp\"\n@@ -79,0 +85,1 @@\n+# include <arpa\/inet.h>\n@@ -83,0 +90,2 @@\n+# include <sys\/sysmacros.h>\n+# include <sys\/wait.h>\n@@ -109,0 +118,1 @@\n+# include <libgen.h>\n@@ -153,0 +163,143 @@\n+class FdsInfo {\n+public:\n+\n+  enum state_t {\n+    INVALID = -3,\n+    CLOSED = -2,\n+    ROOT = -1,\n+    DUP_OF_0 = 0,\n+    \/\/ ...\n+  };\n+\n+  enum mark_t {\n+    M_ZIP_CACHE    = 1 << 0,\n+    M_CANT_RESTORE = 1 << 1,\n+    M_CLASSPATH    = 1 << 2,\n+    M_PERSISTENT   = 1 << 3,\n+  };\n+\n+private:\n+  struct fdinfo {\n+    struct stat stat;\n+    state_t state;\n+    unsigned mark;\n+\n+    int flags;\n+  };\n+\n+  bool same_fd(int fd1, int fd2);\n+\n+  fdinfo *_fdinfos;\n+  int _len;\n+\n+  void assert_mark(int i) {\n+    assert(inited(), \"\");\n+    assert(i < len(), \"\");\n+    assert(_fdinfos[i].state != CLOSED, \"\");\n+  }\n+\n+public:\n+  void initialize();\n+\n+  bool inited() { return _fdinfos != NULL; }\n+  int len() { return _len; }\n+\n+  state_t get_state(int i, state_t orstate = INVALID) {\n+    assert(inited(), \"\");\n+    if (i < len()) {\n+      return _fdinfos[i].state;\n+    }\n+    guarantee(orstate != INVALID, \"can't use default orstate\");\n+    return orstate;\n+  }\n+\n+  void set_state(int i, state_t newst) {\n+    assert(inited(), \"\");\n+    assert(i < len(), \"\");\n+    _fdinfos[i].state = newst;\n+  }\n+\n+  void mark(int i, mark_t m) {\n+    assert_mark(i);\n+    _fdinfos[i].mark |= (unsigned)m;\n+  }\n+  void clear(int i, mark_t m) {\n+    assert_mark(i);\n+    _fdinfos[i].mark &= ~(unsigned)m;\n+  }\n+  bool check(int i, mark_t m) {\n+    assert_mark(i);\n+    return 0 != (_fdinfos[i].mark & (unsigned)m);\n+  }\n+\n+  struct stat* get_stat(int i) {\n+    assert(inited(), \"\");\n+    assert(i < len(), \"\");\n+    return &_fdinfos[i].stat;\n+  }\n+\n+  FdsInfo(bool do_init = true) :\n+    _fdinfos(NULL),\n+    _len(-1)\n+  {\n+    if (do_init) {\n+      initialize();\n+    }\n+  }\n+\n+  ~FdsInfo() {\n+    if (_fdinfos) {\n+      FREE_C_HEAP_ARRAY(fdinfo, _fdinfos);\n+    }\n+  }\n+};\n+\n+struct PersistentResourceDesc {\n+  int _fd;\n+  dev_t _st_dev;\n+  ino_t _st_ino;\n+  PersistentResourceDesc(int fd, int st_dev, int st_ino) :\n+    _fd(fd),\n+    _st_dev((dev_t)st_dev),\n+    _st_ino((ino_t)st_ino)\n+  {}\n+\n+  PersistentResourceDesc() :\n+    _fd(INT_MAX)\n+  {}\n+};\n+\n+struct CracFailDep {\n+  int _type;\n+  char* _msg;\n+  CracFailDep(int type, char* msg) :\n+    _type(type),\n+    _msg(msg)\n+  { }\n+  CracFailDep() :\n+    _type(JVM_CR_FAIL),\n+    _msg(NULL)\n+  { }\n+};\n+\n+class VM_Crac: public VM_Operation {\n+  bool _ok;\n+  GrowableArray<CracFailDep>* _failures;\n+ public:\n+  VM_Crac() :\n+    _ok(false),\n+    _failures(new (ResourceObj::C_HEAP, mtInternal) GrowableArray<CracFailDep>(0, mtInternal))\n+  { }\n+\n+  ~VM_Crac() {\n+    delete _failures;\n+  }\n+\n+  GrowableArray<CracFailDep>* failures() { return _failures; }\n+\n+  bool ok() { return _ok; }\n+  virtual bool allow_nested_vm_operations() const  { return true; }\n+  VMOp_Type type() const { return VMOp_VM_Crac; }\n+  void doit();\n+};\n+\n@@ -174,0 +327,2 @@\n+static const char* _criu = NULL;\n+\n@@ -187,0 +342,4 @@\n+FdsInfo _vm_inited_fds(false);\n+\n+static GrowableArray<PersistentResourceDesc>* _persistent_resources = NULL;\n+\n@@ -5435,0 +5594,749 @@\n+static void trace_cr(const char* msg, ...) {\n+  if (CRTrace) {\n+    va_list ap;\n+    va_start(ap, msg);\n+    tty->print(\"CR: \");\n+    tty->vprint_cr(msg, ap);\n+    va_end(ap);\n+  }\n+}\n+\n+void os::Linux::vm_create_start() {\n+  if (!CRaCCheckpointTo) {\n+    return;\n+  }\n+  _vm_inited_fds.initialize();\n+}\n+\n+\/* taken from criu, that took this from kernel *\/\n+#define NFS_PREF \".nfs\"\n+#define NFS_PREF_LEN ((unsigned)sizeof(NFS_PREF) - 1)\n+#define NFS_FILEID_LEN ((unsigned)sizeof(uint64_t) << 1)\n+#define NFS_COUNTER_LEN ((unsigned)sizeof(unsigned int) << 1)\n+#define NFS_LEN (NFS_PREF_LEN + NFS_FILEID_LEN + NFS_COUNTER_LEN)\n+static bool nfs_silly_rename(char* path) {\n+  char *sep = strrchr(path, '\/');\n+  char *base = sep ? sep + 1 : path;\n+  if (strncmp(base, NFS_PREF, NFS_PREF_LEN)) {\n+    return false;\n+  }\n+  for (unsigned i = NFS_PREF_LEN; i < NFS_LEN; ++i) {\n+    if (!isxdigit(base[i])) {\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n+static int readfdlink(int fd, char *link, size_t len) {\n+  char fdpath[64];\n+  snprintf(fdpath, sizeof(fdpath), \"\/proc\/self\/fd\/%d\", fd);\n+  int ret = readlink(fdpath, link, len);\n+  if (ret == -1) {\n+    return ret;\n+  }\n+  link[(unsigned)ret < len ? ret : len - 1] = '\\0';\n+  return ret;\n+}\n+\n+static bool same_stat(struct stat* st1, struct stat* st2) {\n+  return st1->st_dev == st2->st_dev &&\n+         st1->st_ino == st2->st_ino;\n+}\n+\n+bool FdsInfo::same_fd(int fd1, int fd2) {\n+  if (!same_stat(get_stat(fd1), get_stat(fd2))) {\n+    return false;\n+  }\n+\n+  int flags1 = fcntl(fd1, F_GETFL);\n+  int flags2 = fcntl(fd2, F_GETFL);\n+  if (flags1 != flags2) {\n+    return false;\n+  }\n+\n+  const int test_flag = O_NONBLOCK;\n+  const int new_flags1 = flags1 ^ test_flag;\n+  fcntl(fd1, F_SETFL, new_flags1);\n+  if (fcntl(fd1, F_GETFL) != new_flags1) {\n+    \/\/ flag write ignored or handled differently,\n+    \/\/ don't know what to do\n+    return false;\n+  }\n+\n+  const int new_flags2 = fcntl(fd2, F_GETFL);\n+  const bool are_same = new_flags1 == new_flags2;\n+\n+  fcntl(fd1, flags1);\n+\n+  return are_same;\n+}\n+\n+void FdsInfo::initialize() {\n+  assert(!inited(), \"should be called only once\");\n+\n+  const int max_fd = sysconf(_SC_OPEN_MAX);\n+  _fdinfos = NEW_C_HEAP_ARRAY(fdinfo, max_fd, mtInternal);\n+  int last_fd = -1;\n+\n+  for (int i = 0; i < max_fd; ++i) {\n+    fdinfo* info = _fdinfos + i;\n+    int r = fstat(i, &info->stat);\n+    if (r == -1) {\n+      info->state = CLOSED;\n+      continue;\n+    }\n+    info->state = ROOT; \/\/ can be changed to DUP_OF_0 + N below\n+    info->mark = 0;\n+    last_fd = i;\n+  }\n+  _len = last_fd + 1;\n+  _fdinfos = REALLOC_C_HEAP_ARRAY(fdinfo, _fdinfos, _len, mtInternal);\n+\n+  for (int i = 0; i < _len; ++i) {\n+    for (int j = 0; j < i; ++j) {\n+      if (get_state(j) == ROOT && same_fd(i, j)) {\n+        _fdinfos[i].state = (state_t)(DUP_OF_0 + j);\n+        break;\n+      }\n+    }\n+\n+    if (get_state(i) == ROOT) {\n+      char fdpath[PATH_MAX];\n+      int r = readfdlink(i, fdpath, sizeof(fdpath));\n+      guarantee(-1 != r, \"can't stat fd\");\n+      if (get_stat(i)->st_nlink == 0 ||\n+          strstr(fdpath, \"(deleted)\") ||\n+          nfs_silly_rename(fdpath)) {\n+        mark(i, FdsInfo::M_CANT_RESTORE);\n+      }\n+    }\n+  }\n+}\n+\n+static void mark_classpath_entry(FdsInfo *fds, char* cp) {\n+  struct stat st;\n+  if (-1 == stat(cp, &st)) {\n+    return;\n+  }\n+  for (int i = 0; i < fds->len(); ++i) {\n+    if (same_stat(&st, fds->get_stat(i))) {\n+      fds->mark(i, FdsInfo::M_CLASSPATH);\n+    }\n+  }\n+}\n+\n+static void do_classpaths(void (*fn)(FdsInfo*, char*), FdsInfo *fds, char* classpath) {\n+  assert(SafepointSynchronize::is_at_safepoint(),\n+      \"can't do nasty things with sysclasspath\");\n+  char *cp = classpath;\n+  char *n;\n+  while ((n = strchr(cp, ':'))) {\n+    *n = '\\0';\n+    fn(fds, cp);\n+    *n = ':';\n+    cp = n + 1;\n+  }\n+  mark_classpath_entry(fds, cp);\n+}\n+\n+\n+static void mark_all_in(FdsInfo *fds, char* dirpath) {\n+  DIR *dir = os::opendir(dirpath);\n+  if (!dir) {\n+    return;\n+  }\n+\n+  struct dirent* dent;\n+  while ((dent = os::readdir(dir))) {\n+    for (int i = 0; i < fds->len(); ++i) {\n+      if (fds->get_state(i) != FdsInfo::ROOT) {\n+        continue;\n+      }\n+      struct stat* fstat = fds->get_stat(i);\n+      if (dent->d_ino == fstat->st_ino) {\n+        fds->mark(i, FdsInfo::M_CLASSPATH);\n+      }\n+    }\n+  }\n+\n+  os::closedir(dir);\n+}\n+\n+static void mark_persistent(FdsInfo *fds) {\n+  if (!_persistent_resources) {\n+    return;\n+  }\n+\n+  for (int i = 0; i < _persistent_resources->length(); ++i) {\n+    PersistentResourceDesc* pr = _persistent_resources->adr_at(i);\n+    int fd = pr->_fd;\n+    if (fds->len() <= fd) {\n+      break;\n+    }\n+    if (fds->get_state(fd) != FdsInfo::ROOT) {\n+      continue;\n+    }\n+    struct stat* st = fds->get_stat(fd);\n+    if (st->st_dev == pr->_st_dev && st->st_ino == pr->_st_ino) {\n+      fds->mark(fd, FdsInfo::M_PERSISTENT);\n+    }\n+  }\n+\n+  delete _persistent_resources;\n+  _persistent_resources = NULL;\n+}\n+\n+static void cr_util_path(char* path, int len) {\n+  os::jvm_path(path, len);\n+  \/\/ path is \"...\/lib\/server\/libjvm.so\"\n+  for (int i = 0; i < 2; ++i) {\n+    char *after_elem = strrchr(path, '\/');\n+    *after_elem = '\\0';\n+  }\n+}\n+\n+static const char* compute_criu(const char *util_path) {\n+  if (_criu) {\n+    return _criu;\n+  }\n+\n+#define SUF \"criu\"\n+  const size_t criulen = strlen(util_path) + 1 + sizeof(SUF);\n+  char *criu = NEW_C_HEAP_ARRAY(char, criulen, mtInternal);\n+  assert(criu != NULL, \"JVM should fail\");\n+  int r = jio_snprintf(criu, criulen, \"%s\/\" SUF, util_path);\n+#undef SUF\n+  assert(r < (int)criulen, \"len miscalc\");\n+\n+  struct stat dummy;\n+  if (0 == stat(criu, &dummy)) {\n+    _criu = criu;\n+  } else {\n+    FREE_C_HEAP_ARRAY(char, criu);\n+    warning(\"Could not find %s: %s\", criu, strerror(errno));\n+    \/\/ use system one\n+    _criu = \"criu\";\n+  }\n+  return _criu;\n+}\n+\n+static int call_criu() {\n+  char util_path[JVM_MAXPATHLEN];\n+  cr_util_path(util_path, sizeof(util_path));\n+\n+  const char* criu = compute_criu(util_path);\n+\n+  pid_t jvm = getpid();\n+\n+  char cmd[3 * JVM_MAXPATHLEN];\n+  if ((int)sizeof(cmd) <= snprintf(cmd, sizeof(cmd),\n+        \"%s dump\"\n+        \" -t %d\"\n+        \" -D %s\"\n+        \" --action-script %s\/action-script\"\n+        \" --shell-job\"\n+        \" -v4 -o dump4.log\", \/\/ -D without -W makes criu cd to image dir for logs\n+        criu, jvm, CRaCCheckpointTo, util_path)) {\n+    trace_cr(\"can't fit CRIU cmd\");\n+    return -1;\n+  }\n+\n+  if (fork()) {\n+    \/\/ main JVM\n+    ::wait(NULL);\n+    return 0;\n+  }\n+\n+  pid_t parent_before = getpid();\n+\n+  \/\/ child\n+  if (fork()) {\n+    exit(0);\n+  }\n+  \/\/ grand-child\n+  pid_t parent = getppid();\n+  int tries = 300;\n+  while (parent != 1 && 0 < tries--) {\n+    ::usleep(10);\n+    parent = getppid();\n+  }\n+\n+  if (parent == parent_before) {\n+    trace_cr(\"can't move out of JVM process hierarchy\");\n+    union sigval sv = { .sival_int = -1 };\n+    sigqueue(jvm, RESTORE_SIGNAL, sv);\n+    exit(0);\n+  }\n+\n+  int cmdres = system(cmd);\n+  if (cmdres < 0 || !WIFEXITED(cmdres) || WEXITSTATUS(cmdres)) {\n+    trace_cr(\"%s call failed\", criu);\n+    union sigval sv = { .sival_int = -1 };\n+    sigqueue(jvm, RESTORE_SIGNAL, sv);\n+    exit(0);\n+  }\n+  exit(0);\n+}\n+\n+static int checkpoint_restore(FdsInfo* fds) {\n+\n+  if (CRAllowToSkipCheckpoint) {\n+    trace_cr(\"Skip Checkpoint\");\n+    return JVM_CHECKPOINT_OK;\n+  }\n+\n+  trace_cr(\"Checkpoint ...\");\n+\n+  int criu_res = call_criu();\n+  if (criu_res < 0) {\n+    return JVM_CHECKPOINT_ERROR;\n+  }\n+\n+  sigset_t waitmask;\n+  sigemptyset(&waitmask);\n+  sigaddset(&waitmask, RESTORE_SIGNAL);\n+\n+  siginfo_t info;\n+  int sig;\n+  do {\n+    sig = sigwaitinfo(&waitmask, &info);\n+  } while (sig == -1 && errno == EINTR);\n+  assert(sig == RESTORE_SIGNAL, \"got what requested\");\n+\n+  if (CRTraceStartupTime) {\n+    tty->print_cr(\"STARTUPTIME \" JLONG_FORMAT \" restore-native\", os::javaTimeNanos());\n+  }\n+\n+  if (info.si_code != SI_QUEUE || info.si_int < 0) {\n+    tty->print_cr(\"JVM: invalid info for restore provided (may be failed checkpoint)\");\n+    return JVM_CHECKPOINT_ERROR;\n+  }\n+\n+  return info.si_int;\n+}\n+\n+static const char* stat2strtype(mode_t mode) {\n+  switch (mode & S_IFMT) {\n+  case S_IFSOCK: return \"socket\";\n+  case S_IFLNK:  return \"symlink\";\n+  case S_IFREG:  return \"regular\";\n+  case S_IFBLK:  return \"block\";\n+  case S_IFDIR:  return \"directory\";\n+  case S_IFCHR:  return \"character\";\n+  case S_IFIFO:  return \"fifo\";\n+  default:       break;\n+  }\n+  return \"unknown\";\n+}\n+\n+static int stat2stfail(mode_t mode) {\n+  switch (mode & S_IFMT) {\n+  case S_IFSOCK:\n+    return JVM_CR_FAIL_SOCK;\n+  case S_IFLNK:\n+  case S_IFREG:\n+  case S_IFBLK:\n+  case S_IFDIR:\n+  case S_IFCHR:\n+    return JVM_CR_FAIL_FILE;\n+  case S_IFIFO:\n+    return JVM_CR_FAIL_PIPE;\n+  default:\n+    break;\n+  }\n+  return JVM_CR_FAIL;\n+}\n+\n+static bool find_sock_details(int sockino, const char* base, bool v6, char* buf, size_t sz) {\n+  char filename[16];\n+  snprintf(filename, sizeof(filename), \"\/proc\/net\/%s\", base);\n+  FILE* f = fopen(filename, \"r\");\n+  if (!f) {\n+    return false;\n+  }\n+  int r = fscanf(f, \"%*[^\\n]\");\n+  if (r) {} \/\/ suppress warn unused gcc diagnostic\n+\n+  char la[33], ra[33];\n+  int lp, rp;\n+  int ino;\n+  \/\/   sl  local_address         remote_address        st   tx_queue rx_queue tr tm->when retrnsmt   uid  timeout inode\n+  \/\/    0: 0100007F:08AE         00000000:0000         0A   00000000:00000000 00:00000000 00000000  1000        0 2988639\n+  \/\/  %4d: %08X%08X%08X%08X:%04X %08X%08X%08X%08X:%04X %02X %08X:%08X         %02X:%08lX  %08X       %5u      %8d %d\n+  bool eof;\n+  do {\n+    eof = EOF == fscanf(f, \"%*d: %[^:]:%X %[^:]:%X %*X %*X:%*X %*X:%*X %*X %*d %*d %d%*[^\\n]\\n\",\n+        la, &lp, ra, &rp, &ino);\n+  } while (ino != sockino && !eof);\n+  fclose(f);\n+\n+  if (ino != sockino) {\n+    return false;\n+  }\n+\n+  struct in6_addr a6l, a6r;\n+  struct in_addr a4l, a4r;\n+  if (v6) {\n+    for (int i = 0; i < 4; ++i) {\n+      sscanf(la + i * 8, \"%8\" PRIX32, a6l.s6_addr32 + i);\n+      sscanf(ra + i * 8, \"%8\" PRIX32, a6r.s6_addr32 + i);\n+    }\n+  } else {\n+    sscanf(la, \"%\" PRIX32, &a4l.s_addr);\n+    sscanf(ra, \"%\" PRIX32, &a4r.s_addr);\n+  }\n+\n+  int const af = v6 ? AF_INET6 : AF_INET;\n+  void* const laddr = v6 ? (void*)&a6l : (void*)&a4l;\n+  void* const raddr = v6 ? (void*)&a6r : (void*)&a4r;\n+  char lstrb[48], rstrb[48];\n+  const char* const lstr = ::inet_ntop(af, laddr, lstrb, sizeof(lstrb)) ? lstrb : \"NONE\";\n+  const char* const rstr = ::inet_ntop(af, raddr, rstrb, sizeof(rstrb)) ? rstrb : \"NONE\";\n+  int msgsz = snprintf(buf, sz, \"%s localAddr %s localPort %d remoteAddr %s remotePort %d\",\n+        base, lstr, lp, rstr, rp);\n+  return msgsz < (int)sz;\n+}\n+\n+static const char* sock_details(const char* details, char* buf, size_t sz) {\n+  int sockino;\n+  if (sscanf(details, \"socket:[%d]\", &sockino) <= 0) {\n+    return details;\n+  }\n+\n+  const char* bases[] = { \"tcp\", \"udp\", \"tcp6\", \"udp6\", NULL };\n+  for (const char** b = bases; *b; ++b) {\n+    if (find_sock_details(sockino, *b, 2 <= b - bases, buf, sz)) {\n+      return buf;\n+    }\n+  }\n+\n+  return details;\n+}\n+\n+\n+void VM_Crac::doit() {\n+\n+  AttachListener::abort();\n+\n+  FdsInfo fds;\n+  do_classpaths(mark_classpath_entry, &fds, Arguments::get_sysclasspath());\n+  do_classpaths(mark_classpath_entry, &fds, Arguments::get_appclasspath());\n+  do_classpaths(mark_all_in, &fds, Arguments::get_ext_dirs());\n+  mark_persistent(&fds);\n+\n+  bool ok = true;\n+  for (int i = 0; i < fds.len(); ++i) {\n+    if (fds.get_state(i) == FdsInfo::CLOSED) {\n+      continue;\n+    }\n+\n+    char detailsbuf[128];\n+    int linkret = readfdlink(i, detailsbuf, sizeof(detailsbuf));\n+    const char* details = 0 < linkret ? detailsbuf : \"\";\n+    if (CRPrintResourcesOnCheckpoint) {\n+      tty->print(\"JVM: FD fd=%d type=%s: details1=\\\"%s\\\" \",\n+          i, stat2strtype(fds.get_stat(i)->st_mode), details);\n+    }\n+\n+    if (_vm_inited_fds.get_state(i, FdsInfo::CLOSED) != FdsInfo::CLOSED) {\n+      if (CRPrintResourcesOnCheckpoint) {\n+        tty->print_cr(\"OK: inherited from process env\");\n+      }\n+      continue;\n+    }\n+\n+    struct stat* st = fds.get_stat(i);\n+    if (S_ISCHR(st->st_mode)) {\n+      const int mjr = major(st->st_rdev);\n+      const int mnr = minor(st->st_rdev);\n+      if (mjr == 1 && (mnr == 8 || mnr == 9)) {\n+        if (CRPrintResourcesOnCheckpoint) {\n+          tty->print_cr(\"OK: always available, random or urandom\");\n+        }\n+        continue;\n+      }\n+    }\n+\n+    if (fds.check(i, FdsInfo::M_CLASSPATH) && !fds.check(i, FdsInfo::M_CANT_RESTORE)) {\n+      if (CRPrintResourcesOnCheckpoint) {\n+        tty->print_cr(\"OK: in classpath\");\n+      }\n+      continue;\n+    }\n+\n+    if (fds.check(i, FdsInfo::M_PERSISTENT)) {\n+      if (CRPrintResourcesOnCheckpoint) {\n+        tty->print_cr(\"OK: assured persistent\");\n+      }\n+      continue;\n+    }\n+\n+    if (CRPrintResourcesOnCheckpoint) {\n+      tty->print(\"BAD: opened by application\");\n+    }\n+    ok = false;\n+\n+    if (S_ISSOCK(st->st_mode)) {\n+      details = sock_details(details, detailsbuf, sizeof(detailsbuf));\n+      if (CRPrintResourcesOnCheckpoint) {\n+        tty->print(\" details2=\\\"%s\\\" \", details);\n+      }\n+    }\n+\n+    if (CRPrintResourcesOnCheckpoint) {\n+      tty->cr();\n+    }\n+    char* msg = NEW_C_HEAP_ARRAY(char, strlen(details) + 1, mtInternal);\n+    strcpy(msg, details);\n+    _failures->append(CracFailDep(stat2stfail(st->st_mode & S_IFMT), msg));\n+  }\n+\n+  if (!ok && CRHeapDumpOnCheckpointException) {\n+    HeapDumper::dump_heap();\n+  }\n+\n+  if (!ok && CRDoThrowCheckpointException) {\n+    return;\n+  }\n+\n+  if (!PerfMemoryLinux::checkpoint(CRaCCheckpointTo)) {\n+    return;\n+  }\n+\n+  int ret = checkpoint_restore(&fds);\n+  if (ret == JVM_CHECKPOINT_ERROR) {\n+    PerfMemoryLinux::checkpoint_fail();\n+    return;\n+  }\n+\n+  PerfMemoryLinux::restore();\n+\n+  _ok = true;\n+}\n+\n+void os::Linux::register_persistent_fd(int fd, int st_dev, int st_ino) {\n+  if (!CRaCCheckpointTo) {\n+    return;\n+  }\n+  if (!_persistent_resources) {\n+    _persistent_resources = new (ResourceObj::C_HEAP, mtInternal)\n+      GrowableArray<PersistentResourceDesc>(0, mtInternal);\n+  }\n+  int dup = -1;\n+  int i = 0;\n+  while (i < _persistent_resources->length()) {\n+    int pfd = _persistent_resources->adr_at(i)->_fd;\n+    if (pfd == fd) {\n+      dup = i;\n+      break;\n+    } else if (fd < pfd) {\n+      break;\n+    }\n+    ++i;\n+  }\n+\n+  if (0 <= dup) {\n+    _persistent_resources->at_put(dup, PersistentResourceDesc(fd, st_dev, st_ino));\n+  } else {\n+    _persistent_resources->insert_before(i, PersistentResourceDesc(fd, st_dev, st_ino));\n+  }\n+}\n+\n+void os::Linux::deregister_persistent_fd(int fd, int st_dev, int st_ino) {\n+  if (!CRaCCheckpointTo) {\n+    return;\n+  }\n+  if (!_persistent_resources) {\n+    return;\n+  }\n+  int i = 0;\n+  while (i < _persistent_resources->length()) {\n+    PersistentResourceDesc* pr = _persistent_resources->adr_at(i);\n+    if (pr->_fd == fd && pr->_st_dev == (dev_t)st_dev && pr->_st_ino == (ino_t)st_ino) {\n+      break;\n+    }\n+  }\n+  if (i < _persistent_resources->length()) {\n+    _persistent_resources->remove_at(i);\n+  }\n+}\n+\n+bool os::Linux::prepare_checkpoint() {\n+  struct stat st;\n+\n+  if (0 == stat(CRaCCheckpointTo, &st)) {\n+    if ((st.st_mode & S_IFMT) != S_IFDIR) {\n+      warning(\"%s: not a directory\", CRaCCheckpointTo);\n+      return false;\n+    }\n+  } else {\n+    if (-1 == mkdir(CRaCCheckpointTo, 0700)) {\n+      warning(\"cannot create %s: %s\", CRaCCheckpointTo, strerror(errno));\n+      return false;\n+    }\n+    if (-1 == rmdir(CRaCCheckpointTo)) {\n+      warning(\"cannot cleanup after check: %s\", strerror(errno));\n+      \/\/ not fatal\n+    }\n+  }\n+\n+  return true;\n+}\n+\n+static Handle ret_cr(int ret, Handle codes, Handle msgs, TRAPS) {\n+  objArrayOop bundleObj = oopFactory::new_objectArray(3, CHECK_NH);\n+  objArrayHandle bundle(THREAD, bundleObj);\n+  jvalue jval = { .i = ret };\n+  oop retObj = java_lang_boxing_object::create(T_INT, &jval, CHECK_NH);\n+  bundle->obj_at_put(0, retObj);\n+  bundle->obj_at_put(1, codes());\n+  bundle->obj_at_put(2, msgs());\n+  return bundle;\n+}\n+\n+static Handle ret_cr(int ret, TRAPS) {\n+  return ret_cr(ret, Handle(), Handle(), THREAD);\n+}\n+\n+\/** Checkpoint main entry.\n+ *\/\n+Handle os::Linux::checkpoint(TRAPS) {\n+  if (!CRaCCheckpointTo) {\n+    return ret_cr(JVM_CHECKPOINT_NONE, THREAD);\n+  }\n+\n+  if (-1 == mkdir(CRaCCheckpointTo, 0700) && errno != EEXIST) {\n+    warning(\"cannot create %s: %s\", CRaCCheckpointTo, strerror(errno));\n+    return ret_cr(JVM_CHECKPOINT_NONE, THREAD);\n+  }\n+\n+  Universe::heap()->set_cleanup_unused(true);\n+  Universe::heap()->collect(GCCause::_full_gc_alot);\n+  Universe::heap()->set_cleanup_unused(false);\n+\n+  VM_Crac cr;\n+  {\n+    MutexLocker ml(Heap_lock);\n+    VMThread::execute(&cr);\n+  }\n+  if (cr.ok()) {\n+    return ret_cr(JVM_CHECKPOINT_OK, THREAD);\n+  }\n+\n+  GrowableArray<CracFailDep>* failures = cr.failures();\n+\n+  typeArrayOop codesObj = oopFactory::new_intArray(failures->length(), CHECK_NH);\n+  typeArrayHandle codes(THREAD, codesObj);\n+  objArrayOop msgsObj = oopFactory::new_objArray(vmClasses::String_klass(), failures->length(), CHECK_NH);\n+  objArrayHandle msgs(THREAD, msgsObj);\n+\n+  for (int i = 0; i < failures->length(); ++i) {\n+    codes->int_at_put(i, failures->at(i)._type);\n+    oop msgObj = java_lang_String::create_oop_from_str(failures->at(i)._msg, CHECK_NH);\n+    FREE_C_HEAP_ARRAY(char, failures->at(i)._msg);\n+    msgs->obj_at_put(i, msgObj);\n+  }\n+\n+  return ret_cr(JVM_CHECKPOINT_ERROR, codes, msgs, THREAD);\n+}\n+\n+static char* add_arg(char** begin_p, char* end, const char *fmt, ...) {\n+  char* begin = *begin_p;\n+\n+  va_list va;\n+  va_start(va, fmt);\n+\n+  int len = vsnprintf(begin, end - begin, fmt, va);\n+  if (end <= begin + len) {\n+    return NULL;\n+  }\n+  *begin_p = begin + len + 1;\n+  return begin;\n+}\n+\n+void os::Linux::restore() {\n+  struct stat st;\n+\n+  char util_path[JVM_MAXPATHLEN];\n+  cr_util_path(util_path, sizeof(util_path));\n+\n+  const char *criu = compute_criu(util_path);\n+\n+  char tempbuf[4 * JVM_MAXPATHLEN];\n+  char* end = tempbuf + sizeof(tempbuf);\n+  char* bufp = tempbuf;\n+\n+  snprintf(bufp, end - bufp, \"%s\/cppath\", CRaCRestoreFrom);\n+  int fd_cppath = ::open(bufp, O_RDONLY);\n+  if (fd_cppath < 0) {\n+    trace_cr(\"no valid image to restore: %s\", CRaCRestoreFrom);\n+    return;\n+  }\n+  int cppathlen = read(fd_cppath, bufp, end - bufp);\n+  close(fd_cppath);\n+\n+  char *cppath = bufp;\n+  if (cppathlen < 0) {\n+    warning(\"cannot read image: %s\", strerror(errno));\n+    return;\n+  }\n+  if (cppathlen == end - bufp) {\n+    warning(\"invalid image: content too long\");\n+    return;\n+  }\n+  bufp[cppathlen] = '\\0';\n+  bufp += cppathlen + 1;\n+\n+  char* restore_script = add_arg(&bufp, end, \"%s\/action-script\", util_path);\n+  if (!restore_script) {\n+    warning(\"cannot format restore_script path\");\n+    return;\n+  }\n+\n+  char* wait = add_arg(&bufp, end, \"%s\/wait\", util_path);\n+  if (!wait) {\n+    warning(\"cannot format action-script path\");\n+    return;\n+  }\n+\n+  snprintf(bufp, end - bufp, \"%s\/%s\", CRaCRestoreFrom, PerfMemoryLinux::perfdata_name());\n+  int fd_perfdata = ::open(bufp, O_RDWR);\n+  char* inherit_perfdata = NULL;\n+  if (0 < fd_perfdata) {\n+    inherit_perfdata = add_arg(&bufp, end, \"fd[%d]:%s\/%s\",\n+        fd_perfdata,\n+        cppath[0] == '\/' ? cppath + 1 : cppath,\n+        PerfMemoryLinux::perfdata_name());\n+  }\n+\n+  if (CRTraceStartupTime) {\n+    tty->print_cr(\"STARTUPTIME \" JLONG_FORMAT \" criu-call\", os::javaTimeNanos());\n+  }\n+\n+  const char* args[32];\n+  const char** argp = args;\n+  *argp++ = criu;\n+  *argp++ = \"restore\";\n+  *argp++ = \"-W\";\n+  *argp++ = \".\";\n+  if (inherit_perfdata) {\n+    *argp++ = \"--inherit-fd\";\n+    *argp++ = inherit_perfdata;\n+  }\n+  *argp++ = \"--shell-job\";\n+  *argp++ = \"--action-script\";\n+  *argp++ = restore_script;\n+  *argp++ = \"-D\";\n+  *argp++ = CRaCRestoreFrom;\n+  *argp++ = \"-v1\";\n+  *argp++ = \"--exec-cmd\";\n+  *argp++ = \"--\";\n+  *argp++ = wait;\n+  *argp++ = NULL;\n+  guarantee(argp - args < (int)ARRAY_SIZE(args), \"args overflow\");\n+\n+  execvp(criu, (char**)args);\n+  warning(\"cannot execute \\\"%s restore ...\\\" (%s)\", criu, strerror(errno));\n+}\n+\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":908,"deletions":0,"binary":false,"changes":908,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2017, 2021, Azul Systems, Inc. All rights reserved.\n@@ -173,0 +174,7 @@\n+  static void vm_create_start();\n+  static bool prepare_checkpoint();\n+  static Handle checkpoint(TRAPS);\n+  static void restore();\n+  static void register_persistent_fd(int fd, int st_dev, int st_ino);\n+  static void deregister_persistent_fd(int fd, int st_dev, int st_ino);\n+\n","filename":"src\/hotspot\/os\/linux\/os_linux.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -94,0 +94,4 @@\n+#ifdef LINUX\n+#define RESTORE_SIGNAL   (SIGRTMIN + 2)\n+#endif\n+\n","filename":"src\/hotspot\/os\/posix\/include\/jvm_md.h","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+ * Copyright (c) 2020, 2021, Azul Systems, Inc. All rights reserved.\n@@ -33,0 +34,2 @@\n+\/\/#include \"os_linux.inline.hpp\"\n+#include \"perfMemory_linux.hpp\"\n@@ -52,0 +55,1 @@\n+static int checkpoint_fd = -1;\n@@ -1326,0 +1330,119 @@\n+\n+bool PerfMemoryLinux::checkpoint(const char* checkpoint_path) {\n+  assert(checkpoint_path, \"should be set\");\n+\n+  if (!backing_store_file_name) {\n+    return true;\n+  }\n+\n+  char path[JVM_MAXPATHLEN];\n+  int pathlen = snprintf(path, sizeof(path),\"%s\/%s\", checkpoint_path, perfdata_name());\n+\n+  RESTARTABLE(::open(path, O_RDWR|O_CREAT|O_NOFOLLOW, S_IRUSR|S_IWUSR), checkpoint_fd);\n+  if (checkpoint_fd < 0) {\n+    tty->print_cr(\"cannot open checkpoint perfdata: %s\", os::strerror(errno));\n+    return false;\n+  }\n+\n+  char* p = PerfMemory::start();\n+  size_t len = PerfMemory::capacity();\n+  do {\n+    int result;\n+    RESTARTABLE(::write(checkpoint_fd, p, len), result);\n+    if (result == OS_ERR) {\n+      tty->print_cr(\"cannot write data to checkpoint perfdata file: %s\", os::strerror(errno));\n+      ::close(checkpoint_fd);\n+      checkpoint_fd = -1;\n+      return false;\n+    }\n+    p += result;\n+    len -= (size_t)result;\n+  } while (0 < len);\n+\n+  void* mmapret = ::mmap(PerfMemory::start(), PerfMemory::capacity(),\n+      PROT_READ|PROT_WRITE, MAP_FIXED|MAP_SHARED, checkpoint_fd, 0);\n+  if (MAP_FAILED == mmapret) {\n+    tty->print_cr(\"cannot mmap checkpoint perfdata file: %s\", os::strerror(errno));\n+    ::close(checkpoint_fd);\n+    checkpoint_fd = -1;\n+    return false;\n+  }\n+\n+  return true;\n+}\n+\n+bool PerfMemoryLinux::checkpoint_fail() {\n+  if (checkpoint_fd < 0) {\n+    return true;\n+  }\n+\n+  int fd;\n+  RESTARTABLE(::open(backing_store_file_name, O_RDWR|O_CREAT|O_NOFOLLOW, S_IRUSR|S_IWUSR), fd);\n+  if (fd == OS_ERR) {\n+    tty->print_cr(\"cannot open original perfdata file: %s\", os::strerror(errno));\n+    return false;\n+  }\n+\n+  void* mmapret = ::mmap(PerfMemory::start(), PerfMemory::capacity(),\n+      PROT_READ|PROT_WRITE, MAP_FIXED|MAP_SHARED, fd, 0);\n+  if (MAP_FAILED == mmapret) {\n+    tty->print_cr(\"cannot mmap old perfdata file: %s\", os::strerror(errno));\n+    ::close(fd);\n+    return false;\n+  }\n+\n+  return true;\n+}\n+\n+bool PerfMemoryLinux::restore() {\n+  if (checkpoint_fd < 0) {\n+    return true;\n+  }\n+\n+  int vmid = os::current_process_id();\n+  char* user_name = get_user_name(geteuid());\n+  char* dirname = get_user_tmp_dir(user_name, vmid, -1);\n+  if (!make_user_tmp_dir(dirname)) {\n+    return false;\n+  }\n+\n+  int fd;\n+  RESTARTABLE(::open(backing_store_file_name, O_RDWR|O_CREAT|O_NOFOLLOW, S_IRUSR|S_IWUSR), fd);\n+  if (fd == OS_ERR) {\n+    tty->print_cr(\"cannot open restore perfdata file: %s\", os::strerror(errno));\n+\n+    void* mmapret = ::mmap(PerfMemory::start(), PerfMemory::capacity(),\n+        PROT_READ|PROT_WRITE, MAP_FIXED|MAP_PRIVATE, checkpoint_fd, 0);\n+    if (MAP_FAILED == mmapret) {\n+      tty->print_cr(\"cannot remap checkpoint perfdata file: %s\", os::strerror(errno));\n+    }\n+    return false;\n+  }\n+\n+  char* p = PerfMemory::start();\n+  size_t len = PerfMemory::capacity();\n+  do {\n+    int result;\n+    RESTARTABLE(::write(fd, p, len), result);\n+    if (result == OS_ERR) {\n+      tty->print_cr(\"cannot write data to restore perfdata file: %s\", os::strerror(errno));\n+      ::close(fd);\n+      return false;\n+    }\n+    p += result;\n+    len -= (size_t)result;\n+  } while (0 < len);\n+\n+  void* mmapret = ::mmap(PerfMemory::start(), PerfMemory::capacity(),\n+      PROT_READ|PROT_WRITE, MAP_FIXED|MAP_SHARED, fd, 0);\n+  if (MAP_FAILED == mmapret) {\n+    tty->print_cr(\"cannot mmap restore perfdata file: %s\", os::strerror(errno));\n+    ::close(fd);\n+    return false;\n+  }\n+\n+  ::close(fd);\n+  ::close(checkpoint_fd);\n+  checkpoint_fd = -1;\n+  return true;\n+}\n","filename":"src\/hotspot\/os\/posix\/perfMemory_posix.cpp","additions":123,"deletions":0,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -148,1 +148,1 @@\n-static sigset_t unblocked_sigs, vm_sigs, preinstalled_sigs;\n+static sigset_t unblocked_sigs, blocked_sigs, vm_sigs, preinstalled_sigs;\n@@ -1480,0 +1480,4 @@\n+\n+  sigemptyset(&blocked_sigs);\n+  sigaddset(&blocked_sigs, RESTORE_SIGNAL);\n+\n","filename":"src\/hotspot\/os\/posix\/signals_posix.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -708,0 +708,3 @@\n+  template(jdk_crac_Core,                          \"jdk\/crac\/Core\")                                               \\\n+  template(checkpointRestoreInternal_name,         \"checkpointRestoreInternal\")                                   \\\n+                                                                                                                  \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2019, 2021, Azul Systems, Inc. All rights reserved.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -240,0 +240,7 @@\n+  \/\/ Handle do_cleanup_unused here to print correct capacity below.\n+  if (Universe::heap()->do_cleanup_unused()) {\n+    \/\/ HeapRegionManager::shrink_by do not allow remove all regions.\n+    \/\/ Make sure at least one is there.\n+    maximum_desired_capacity = HeapRegion::GrainBytes;\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapSizingPolicy.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2019, 2021, Azul Systems, Inc. All rights reserved.\n@@ -1719,0 +1720,7 @@\n+static void zero_cap(MutableSpace* ms) {\n+  os::cleanup_memory((char*)ms->top(), (char*)ms->end() - (char*)ms->top());\n+}\n+static void zero_all(MutableSpace* ms) {\n+  os::cleanup_memory((char*)ms->bottom(), (char*)ms->end() - (char*)ms->bottom());\n+}\n+\n@@ -1886,0 +1894,7 @@\n+    if (heap->do_cleanup_unused()) {\n+      zero_cap(young_gen->eden_space());\n+      zero_cap(young_gen->from_space());\n+      zero_all(young_gen->to_space());\n+      zero_cap(old_gen->object_space());\n+    }\n+\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2019, 2021, Azul Systems, Inc. All rights reserved.\n@@ -347,0 +348,6 @@\n+  if (Universe::heap()->do_cleanup_unused()) {\n+    os::cleanup_memory((char*)eden()->top(), (char*)eden()->end() - (char*)eden()->top());\n+    os::cleanup_memory((char*)from()->top(), (char*)from()->end() - (char*)from()->top());\n+    os::cleanup_memory((char*)to()->top(), (char*)to()->end() - (char*)to()->top());\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2019, 2021, Azul Systems, Inc. All rights reserved.\n@@ -296,0 +297,3 @@\n+  if (Universe::heap()->do_cleanup_unused()) {\n+    shrink_bytes = capacity_after_gc - used_after_gc;\n+  }\n","filename":"src\/hotspot\/share\/gc\/shared\/cardGeneration.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -225,0 +225,1 @@\n+  _cleanup_unused(false),\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -102,0 +102,2 @@\n+  bool _cleanup_unused;\n+\n@@ -363,0 +365,3 @@\n+  void set_cleanup_unused(bool value) { _cleanup_unused = value; }\n+  bool do_cleanup_unused() const { return _cleanup_unused; }\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1132,0 +1132,21 @@\n+enum {\n+  JVM_CHECKPOINT_OK,\n+  JVM_CHECKPOINT_ERROR,\n+  JVM_CHECKPOINT_NONE,\n+};\n+\n+enum cr_fail_type {\n+  JVM_CR_FAIL      = 0,\n+  JVM_CR_FAIL_FILE = 1,\n+  JVM_CR_FAIL_SOCK = 2,\n+  JVM_CR_FAIL_PIPE = 3,\n+};\n+\n+JNIEXPORT jobjectArray JNICALL\n+JVM_Checkpoint(JNIEnv *env);\n+\n+JNIEXPORT void JNICALL\n+JVM_RegisterPersistent(int fd, int st_dev, int st_ino);\n+\n+JNIEXPORT void JNICALL\n+JVM_DeregisterPersistent(int fd, int st_dev, int st_ino);\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -3851,0 +3851,13 @@\n+\n+JVM_ENTRY(jobjectArray, JVM_Checkpoint(JNIEnv *env))\n+  Handle ret = os::Linux::checkpoint(CHECK_NULL);\n+  return (jobjectArray) JNIHandles::make_local(THREAD, ret());\n+JVM_END\n+\n+JVM_LEAF(void, JVM_RegisterPersistent(int fd, int st_dev, int st_ino))\n+  os::Linux::register_persistent_fd(fd, st_dev, st_ino);\n+JVM_END\n+\n+JVM_LEAF(void, JVM_DeregisterPersistent(int fd, int st_dev, int st_ino))\n+  os::Linux::deregister_persistent_fd(fd, st_dev, st_ino);\n+JVM_END\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2017, 2021, Azul Systems, Inc. All rights reserved.\n@@ -3155,0 +3156,13 @@\n+  if (CRaCRestoreFrom) {\n+    os::Linux::restore();\n+    if (!CRaCIgnoreRestoreIfUnavailable) {\n+      \/\/ FIXME switch to unified hotspot logging\n+      warning(\"cannot restore\");\n+      return JNI_ERR;\n+    }\n+  }\n+\n+  if (CRaCCheckpointTo && !os::Linux::prepare_checkpoint()) {\n+    return JNI_ERR;\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2088,2 +2088,29 @@\n-  develop(bool, TraceOptimizedUpcallStubs, false,                              \\\n-                \"Trace optimized upcall stub generation\")                      \\\n+  develop(bool, TraceOptimizedUpcallStubs, false,                           \\\n+                \"Trace optimized upcall stub generation\")                   \\\n+                                                                            \\\n+  product(ccstr, CRaCCheckpointTo, NULL, \"Path to checkpoint image\")        \\\n+                                                                            \\\n+  product(ccstr, CRaCRestoreFrom, NULL, \"Path to image for restore, \"       \\\n+      \"replaces the initializing VM on success\")                            \\\n+                                                                            \\\n+  product(bool, CRaCIgnoreRestoreIfUnavailable, false, \"Ignore \"            \\\n+      \"-XX:CRaCRestoreFrom and continue initialization if restore is \"      \\\n+      \"unavailable\")                                                        \\\n+                                                                            \\\n+  product(bool, CRAllowToSkipCheckpoint, false, DIAGNOSTIC,                 \\\n+          \"Allow implementation to not call Checkpoint if helper not found\")\\\n+                                                                            \\\n+  product(bool, CRHeapDumpOnCheckpointException, false, DIAGNOSTIC,         \\\n+      \"Dump heap on CheckpointException thrown because of CRaC \"            \\\n+      \"precondition failed\")                                                \\\n+                                                                            \\\n+  product(bool, CRPrintResourcesOnCheckpoint, false, DIAGNOSTIC,            \\\n+      \"Print resources to decide CheckpointException\")                      \\\n+                                                                            \\\n+  product(bool, CRTraceStartupTime, false, DIAGNOSTIC,                      \\\n+      \"Trace startup time\")                                                 \\\n+                                                                            \\\n+  product(bool, CRDoThrowCheckpointException, true, EXPERIMENTAL,           \\\n+      \"Throw CheckpointException if uncheckpointable resource handle found\")\\\n+                                                                            \\\n+  product(bool, CRTrace, true, \"Minimal C\/R tracing\")                       \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":29,"deletions":2,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -1820,0 +1820,7 @@\n+void os::cleanup_memory(char* addr, size_t bytes) {\n+  char* start = (char*)align_up(addr, os::vm_page_size());\n+  char* end = (char*)align_down(addr + bytes, os::vm_page_size());\n+  os::uncommit_memory(start, end - start);\n+  os::commit_memory(start, end - start, false);\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -369,0 +369,2 @@\n+  static void   cleanup_memory(char* addr, size_t bytes);\n+\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2771,0 +2771,2 @@\n+  os::Linux::vm_create_start();\n+\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -112,1 +112,2 @@\n-  template(JvmtiPostObjectFree)\n+  template(JvmtiPostObjectFree)                   \\\n+  template(VM_Crac)\n","filename":"src\/hotspot\/share\/runtime\/vmOperation.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -130,0 +130,2 @@\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<CheckpointDCmd>(full_export, true,false));\n+\n@@ -1037,0 +1039,10 @@\n+\n+void CheckpointDCmd::execute(DCmdSource source, TRAPS) {\n+  Klass* k = SystemDictionary::resolve_or_fail(vmSymbols::jdk_crac_Core(),\n+                                                 true, CHECK);\n+  JavaValue result(T_VOID);\n+  JavaCalls::call_static(&result, k,\n+                         vmSymbols::checkpointRestoreInternal_name(),\n+                         vmSymbols::void_method_signature(), CHECK);\n+}\n+\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -904,0 +904,14 @@\n+class CheckpointDCmd : public DCmd {\n+public:\n+  CheckpointDCmd(outputStream* output, bool heap) : DCmd(output, heap) { }\n+    static const char* name() { return \"JDK.checkpoint\"; }\n+    static const char* description() {\n+      return \"Checkpoint via jdk.crac.checkpointRestore().\";\n+    }\n+    static const char* impact() {\n+      return \"High: JVM terminates\";\n+    }\n+    static int num_arguments() { return 0; }\n+    virtual void execute(DCmdSource source, TRAPS);\n+};\n+\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.hpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2020, 2021, Azul Systems, Inc. All rights reserved.\n@@ -28,0 +29,4 @@\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import jdk.internal.crac.JDKResource;\n+\n@@ -30,0 +35,1 @@\n+import java.nio.channels.IllegalSelectorException;\n@@ -50,1 +56,1 @@\n-class EPollSelectorImpl extends SelectorImpl {\n+class EPollSelectorImpl extends SelectorImpl implements JDKResource {\n@@ -55,0 +61,24 @@\n+    private enum CheckpointRestoreState {\n+        NORMAL_OPERATION,\n+        CHECKPOINT_TRANSITION,\n+        CHECKPOINTED,\n+        CHECKPOINT_ERROR,\n+        RESTORE_TRANSITION,\n+    }\n+\n+    private static class MoveToCheckpointThread extends Thread {\n+        private Selector selector;\n+\n+        MoveToCheckpointThread(Selector selector) {\n+            this.selector = selector;\n+        }\n+\n+        @Override\n+        public void run() {\n+            try {\n+                selector.select(1);\n+            } catch (IOException e) {\n+            }\n+        }\n+    }\n+\n@@ -56,1 +86,1 @@\n-    private final int epfd;\n+    private int epfd;\n@@ -59,1 +89,1 @@\n-    private final long pollArrayAddress;\n+    private long pollArrayAddress;\n@@ -62,1 +92,1 @@\n-    private final EventFD eventfd;\n+    private EventFD eventfd;\n@@ -75,2 +105,1 @@\n-    EPollSelectorImpl(SelectorProvider sp) throws IOException {\n-        super(sp);\n+    private volatile CheckpointRestoreState checkpointState = CheckpointRestoreState.NORMAL_OPERATION;;\n@@ -78,2 +107,2 @@\n-        this.epfd = EPoll.create();\n-        this.pollArrayAddress = EPoll.allocatePollArray(NUM_EPOLLEVENTS);\n+    private void initFDs() throws IOException {\n+        epfd = EPoll.create();\n@@ -94,0 +123,9 @@\n+    EPollSelectorImpl(SelectorProvider sp) throws IOException {\n+        super(sp);\n+        pollArrayAddress = EPoll.allocatePollArray(NUM_EPOLLEVENTS);\n+        initFDs();\n+        \/\/ trigger FileDispatcherImpl initialization\n+        new FileDispatcherImpl();\n+        jdk.internal.crac.Core.getJDKContext().register(this);\n+    }\n+\n@@ -99,0 +137,47 @@\n+    private boolean processCheckpointRestore() throws IOException {\n+        assert Thread.holdsLock(this);\n+\n+        if (checkpointState != CheckpointRestoreState.CHECKPOINT_TRANSITION) {\n+            return false;\n+        }\n+\n+        synchronized (interruptLock) {\n+\n+            CheckpointRestoreState thisState;\n+            if (fdToKey.size() == 0) {\n+                eventfd.close();\n+                eventfd = null;\n+                FileDispatcherImpl.closeIntFD(epfd);\n+                thisState = CheckpointRestoreState.CHECKPOINTED;\n+            } else {\n+                thisState = CheckpointRestoreState.CHECKPOINT_ERROR;\n+            }\n+\n+            checkpointState = thisState;\n+            interruptLock.notifyAll();\n+            while (checkpointState == thisState) {\n+                try {\n+                    interruptLock.wait();\n+                } catch (InterruptedException e) {\n+                }\n+            }\n+\n+            assert checkpointState == CheckpointRestoreState.RESTORE_TRANSITION;\n+            if (thisState == CheckpointRestoreState.CHECKPOINTED) {\n+                initFDs();\n+            }\n+            checkpointState = CheckpointRestoreState.NORMAL_OPERATION;\n+            interruptLock.notifyAll();\n+\n+            if (interruptTriggered) {\n+                try {\n+                    eventfd.set();\n+                } catch (IOException ioe) {\n+                    throw new InternalError(ioe);\n+                }\n+            }\n+        }\n+\n+        return true;\n+    }\n+\n@@ -118,1 +203,3 @@\n-                numEntries = EPoll.wait(epfd, pollArrayAddress, NUM_EPOLLEVENTS, to);\n+                do {\n+                    numEntries = EPoll.wait(epfd, pollArrayAddress, NUM_EPOLLEVENTS, to);\n+                } while (processCheckpointRestore());\n@@ -200,1 +287,1 @@\n-        if (interrupted) {\n+        if (interrupted && !(Thread.currentThread() instanceof MoveToCheckpointThread)) {\n@@ -267,0 +354,56 @@\n+\n+    @Override\n+    public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+        if (!isOpen()) {\n+            return;\n+        }\n+\n+        synchronized (interruptLock) {\n+            checkpointState = CheckpointRestoreState.CHECKPOINT_TRANSITION;\n+            eventfd.set();\n+            int tries = 5;\n+            while (checkpointState == CheckpointRestoreState.CHECKPOINT_TRANSITION && 0 < tries--) {\n+                try {\n+                    interruptLock.wait(5);\n+                } catch (InterruptedException e) {\n+                }\n+            }\n+            if (checkpointState == CheckpointRestoreState.CHECKPOINT_TRANSITION) {\n+                Thread thr = new MoveToCheckpointThread(this);\n+                thr.setDaemon(true);\n+                thr.start();\n+            }\n+            while (checkpointState == CheckpointRestoreState.CHECKPOINT_TRANSITION) {\n+                try {\n+                    interruptLock.wait();\n+                } catch (InterruptedException e) {\n+                }\n+            }\n+            if (checkpointState == CheckpointRestoreState.CHECKPOINT_ERROR) {\n+                throw new IllegalSelectorException();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void afterRestore(Context<? extends Resource> context) throws Exception {\n+        if (!isOpen()) {\n+            return;\n+        }\n+\n+        synchronized (interruptLock) {\n+            checkpointState = CheckpointRestoreState.RESTORE_TRANSITION;\n+            interruptLock.notifyAll();\n+            while (checkpointState == CheckpointRestoreState.RESTORE_TRANSITION) {\n+                try {\n+                    interruptLock.wait();\n+                } catch (InterruptedException e) {\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public int getPriority() {\n+        return -1;\n+    }\n","filename":"src\/java.base\/linux\/classes\/sun\/nio\/ch\/EPollSelectorImpl.java","additions":153,"deletions":10,"binary":false,"changes":163,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.io.FileDescriptor;\n@@ -67,0 +68,1 @@\n+import jdk.internal.crac.Core;\n@@ -801,0 +803,4 @@\n+\n+        public Source getSource() {\n+            return zsrc;\n+        }\n@@ -1081,0 +1087,14 @@\n+    private synchronized void beforeCheckpoint() {\n+        RandomAccessFile f = res.getSource().getFile();\n+        synchronized (f) {\n+            FileDescriptor fd = null;\n+            try {\n+                fd = f.getFD();\n+            } catch (IOException e) {\n+            }\n+            if (fd != null) {\n+                Core.registerPersistent(fd);\n+            }\n+        }\n+    }\n+\n@@ -1778,0 +1798,4 @@\n+\n+        public RandomAccessFile getFile() {\n+            return zfile;\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipFile.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,209 @@\n+\/*\n+ * Copyright (c) 2017, 2021, Azul Systems, Inc. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.crac;\n+\n+import jdk.crac.impl.CheckpointOpenFileException;\n+import jdk.crac.impl.CheckpointOpenResourceException;\n+import jdk.crac.impl.CheckpointOpenSocketException;\n+import jdk.crac.impl.OrderedContext;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+\n+\/**\n+ * The coordination service.\n+ *\/\n+public class Core {\n+    private static final int JVM_CHECKPOINT_OK    = 0;\n+    private static final int JVM_CHECKPOINT_ERROR = 1;\n+    private static final int JVM_CHECKPOINT_NONE  = 2;\n+\n+    private static final int JVM_CR_FAIL = 0;\n+    private static final int JVM_CR_FAIL_FILE = 1;\n+    private static final int JVM_CR_FAIL_SOCK = 2;\n+    private static final int JVM_CR_FAIL_PIPE = 3;\n+\n+    private static native Object[] checkpointRestore0();\n+\n+    private static boolean traceStartupTime;\n+\n+    private static final Context<Resource> globalContext = new OrderedContext();\n+    static {\n+        \/\/ force JDK context initialization\n+        jdk.internal.crac.Core.getJDKContext();\n+\n+        @SuppressWarnings(\"removal\")\n+        boolean doTraceStartupTime = AccessController.doPrivileged(\n+                new PrivilegedAction<Boolean>() {\n+                    public Boolean run() {\n+                        return Boolean.parseBoolean(\n+                                System.getProperty(\"jdk.crac.trace-startup-time\"));\n+                    }});\n+\n+        traceStartupTime = doTraceStartupTime;\n+    }\n+\n+    \/** This class is not instantiable. *\/\n+    private Core() {\n+    }\n+\n+    private static void translateJVMExceptions(int[] codes, String[] messages,\n+                                               CheckpointException newException) {\n+        assert codes.length == messages.length;\n+        final int length = codes.length;\n+\n+        for (int i = 0; i < length; ++i) {\n+            switch(codes[i]) {\n+                case JVM_CR_FAIL_FILE:\n+                    newException.addSuppressed(\n+                            new CheckpointOpenFileException(messages[i]));\n+                    break;\n+                case JVM_CR_FAIL_SOCK:\n+                    newException.addSuppressed(\n+                            new CheckpointOpenSocketException(messages[i]));\n+                    break;\n+                case JVM_CR_FAIL_PIPE:\n+                    \/\/ FALLTHROUGH\n+                default:\n+                    newException.addSuppressed(\n+                            new CheckpointOpenResourceException(messages[i]));\n+                    break;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Gets the global {@code Context} for checkpoint\/restore notifications.\n+     *\n+     * @return the global {@code Context}\n+     *\/\n+    public static Context<Resource> getGlobalContext() {\n+        return globalContext;\n+    }\n+\n+    private static void checkpointRestore1() throws\n+            CheckpointException,\n+            RestoreException {\n+        try {\n+            globalContext.beforeCheckpoint(null);\n+        } catch (CheckpointException ce) {\n+            \/\/ TODO make dry-run\n+            try {\n+                globalContext.afterRestore(null);\n+            } catch (RestoreException re) {\n+                CheckpointException newException = new CheckpointException();\n+                for (Throwable t : ce.getSuppressed()) {\n+                    newException.addSuppressed(t);\n+                }\n+                for (Throwable t : re.getSuppressed()) {\n+                    newException.addSuppressed(t);\n+                }\n+                throw newException;\n+            }\n+            throw ce;\n+        }\n+\n+        final Object[] bundle = checkpointRestore0();\n+        final int retCode = (Integer)bundle[0];\n+        final int[] codes = (int[])bundle[1];\n+        final String[] messages = (String[])bundle[2];\n+\n+        if (traceStartupTime) {\n+            System.out.println(\"STARTUPTIME \" + System.nanoTime() + \" restore\");\n+        }\n+\n+        if (retCode != JVM_CHECKPOINT_OK) {\n+            CheckpointException newException = new CheckpointException();\n+            switch (retCode) {\n+                case JVM_CHECKPOINT_ERROR:\n+                    translateJVMExceptions(codes, messages, newException);\n+                    break;\n+                case JVM_CHECKPOINT_NONE:\n+                    newException.addSuppressed(\n+                            new RuntimeException(\"C\/R is not configured\"));\n+                    break;\n+                default:\n+                    newException.addSuppressed(\n+                            new RuntimeException(\"Unknown C\/R result: \" + retCode));\n+            }\n+\n+            try {\n+                globalContext.afterRestore(null);\n+            } catch (RestoreException re) {\n+                for (Throwable t : re.getSuppressed()) {\n+                    newException.addSuppressed(t);\n+                }\n+            }\n+            throw newException;\n+        }\n+\n+        globalContext.afterRestore(null);\n+    }\n+\n+    \/**\n+     * Requests checkpoint and returns upon a successful restore.\n+     * May throw an exception if the checkpoint or restore are unsuccessful.\n+     *\n+     * @throws CheckpointException if an exception occured during checkpoint\n+     * notification and the execution continues in the original Java instance.\n+     * @throws RestoreException if an exception occured during restore\n+     * notification and execution continues in a new Java instance.\n+     * @throws UnsupportedOperationException if checkpoint\/restore is not\n+     * supported, no notification performed and the execution continues in\n+     * the original Java instance.\n+     *\/\n+    public static void checkpointRestore() throws\n+            CheckpointException,\n+            RestoreException {\n+        try {\n+            checkpointRestore1();\n+        } finally {\n+            if (traceStartupTime) {\n+                System.out.println(\"STARTUPTIME \" + System.nanoTime() + \" restore-finish\");\n+            }\n+        }\n+    }\n+\n+    \/* called by VM *\/\n+    private static void checkpointRestoreInternal() {\n+        Thread thread = new Thread(() -> {\n+            try {\n+                Thread.sleep(100);\n+            } catch (InterruptedException e) {\n+            }\n+\n+            try {\n+                checkpointRestore();\n+            } catch (CheckpointException | RestoreException e) {\n+                for (Throwable t : e.getSuppressed()) {\n+                    t.printStackTrace();\n+                }\n+            }\n+        });\n+        thread.setDaemon(true);\n+        thread.start();\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/Core.java","additions":209,"deletions":0,"binary":false,"changes":209,"status":"added"},{"patch":"@@ -0,0 +1,110 @@\n+\/\/ Copyright 2019-2020 Azul Systems, Inc.\n+\/\/\n+\/\/ Redistribution and use in source and binary forms, with or without\n+\/\/ modification, are permitted provided that the following conditions are met:\n+\/\/\n+\/\/ 1. Redistributions of source code must retain the above copyright notice,\n+\/\/ this list of conditions and the following disclaimer.\n+\/\/\n+\/\/ 2. Redistributions in binary form must reproduce the above copyright notice,\n+\/\/ this list of conditions and the following disclaimer in the documentation\n+\/\/ and\/or other materials provided with the distribution.\n+\/\/\n+\/\/ IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+\/\/ ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n+\/\/ LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+\/\/ CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+\/\/ SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+\/\/ INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+\/\/ CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+\/\/ ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+\/\/ POSSIBILITY OF SUCH DAMAGE.\n+\n+package jdk.crac.impl;\n+\n+import jdk.crac.CheckpointException;\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import jdk.crac.RestoreException;\n+\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+public abstract class AbstractContextImpl<R extends Resource, P> extends Context<R> {\n+    @SuppressWarnings(\"removal\")\n+    private static final boolean DEBUG = AccessController.doPrivileged(\n+            new PrivilegedAction<Boolean>() {\n+                public Boolean run() {\n+                    return Boolean.parseBoolean(\n+                            System.getProperty(\"jdk.crac.debug\"));\n+                }});\n+\n+    private WeakHashMap<R, P> checkpointQ = new WeakHashMap<>();\n+    private List<R> restoreQ = null;\n+    private Comparator<Map.Entry<R, P>> comparator;\n+\n+    protected AbstractContextImpl(Comparator<Map.Entry<R, P>> comparator) {\n+        this.comparator = comparator;\n+    }\n+\n+    protected synchronized void register(R resource, P payload) {\n+        checkpointQ.put(resource, payload);\n+    }\n+\n+    @Override\n+    public synchronized void beforeCheckpoint(Context<? extends Resource> context) throws CheckpointException {\n+        List<R> resources = checkpointQ.entrySet().stream()\n+            .sorted(comparator)\n+            .map(Map.Entry::getKey)\n+            .collect(Collectors.toList());\n+\n+        CheckpointException exception = new CheckpointException();\n+        for (Resource r : resources) {\n+            if (DEBUG) {\n+                System.err.println(\"jdk.crac beforeCheckpoint \" + r.toString());\n+            }\n+            try {\n+                r.beforeCheckpoint(this);\n+            } catch (CheckpointException e) {\n+                for (Throwable t : e.getSuppressed()) {\n+                    exception.addSuppressed(t);\n+                }\n+            } catch (Exception e) {\n+                exception.addSuppressed(e);\n+            }\n+        }\n+\n+        Collections.reverse(resources);\n+        restoreQ = resources;\n+\n+        if (0 < exception.getSuppressed().length) {\n+            throw exception;\n+        }\n+    }\n+\n+    @Override\n+    public synchronized void afterRestore(Context<? extends Resource> context) throws RestoreException {\n+        RestoreException exception = new RestoreException();\n+        for (Resource r : restoreQ) {\n+            if (DEBUG) {\n+                System.err.println(\"jdk.crac afterRestore \" + r.toString());\n+            }\n+            try {\n+                r.afterRestore(this);\n+            } catch (RestoreException e) {\n+                for (Throwable t : e.getSuppressed()) {\n+                    exception.addSuppressed(t);\n+                }\n+            } catch (Exception e) {\n+                exception.addSuppressed(e);\n+            }\n+        }\n+        restoreQ = null;\n+\n+        if (0 < exception.getSuppressed().length) {\n+            throw exception;\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/impl\/AbstractContextImpl.java","additions":110,"deletions":0,"binary":false,"changes":110,"status":"added"},{"patch":"@@ -28,0 +28,1 @@\n+import java.lang.reflect.Method;\n@@ -47,0 +48,1 @@\n+import java.security.PrivilegedAction;\n@@ -71,0 +73,1 @@\n+import jdk.crac.Context;\n@@ -74,0 +77,2 @@\n+import jdk.internal.crac.Core;\n+import jdk.internal.crac.JDKResource;\n@@ -816,0 +821,32 @@\n+        static class ClassLoaderJarFile extends JarFile implements JDKResource {\n+            public ClassLoaderJarFile (File file, boolean verify, int mode, Runtime.Version version) throws IOException {\n+                super(file, verify, mode, version);\n+            }\n+\n+            @Override\n+            public void beforeCheckpoint(Context<? extends jdk.crac.Resource> context) {\n+                try {\n+                    Method zipBeforeCheckpoint = ZipFile.class.getDeclaredMethod(\"beforeCheckpoint\");\n+                    @SuppressWarnings(\"removal\")\n+                    Void v = AccessController.doPrivileged(new PrivilegedAction<Void>() {\n+                        public Void run() {\n+                            zipBeforeCheckpoint.setAccessible(true);\n+                            return null;\n+                        }});\n+                    zipBeforeCheckpoint.invoke(this);\n+                } catch (Throwable e) {\n+                    e.printStackTrace();\n+                }\n+            }\n+\n+            @Override\n+            public void afterRestore(Context<? extends jdk.crac.Resource> context) {\n+                \/\/ do nothing, no fixup required\n+            }\n+\n+            @Override\n+            public int getPriority() {\n+                return 0;\n+            }\n+        }\n+\n@@ -823,2 +860,4 @@\n-                return checkJar(new JarFile(new File(p.getPath()), true, ZipFile.OPEN_READ,\n-                        JarFile.runtimeVersion()));\n+                ClassLoaderJarFile clJarFile = new ClassLoaderJarFile(new File(p.getPath()), true, ZipFile.OPEN_READ,\n+                        JarFile.runtimeVersion());\n+                Core.getJDKContext().register(clJarFile);\n+                return checkJar(clJarFile);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/loader\/URLClassPath.java","additions":41,"deletions":2,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -132,0 +132,1 @@\n+    exports javax.crac;\n@@ -133,0 +134,1 @@\n+    exports jdk.crac;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -665,0 +665,9 @@\n+    {\n+      const int restore_signal = SIGRTMIN + 2;\n+      \/\/ block restore_signal in launcher thread to allow JVM handle it\n+      sigset_t block_sig;\n+      sigemptyset(&block_sig);\n+      sigaddset(&block_sig, restore_signal);\n+      pthread_sigmask(SIG_BLOCK, &block_sig, NULL);\n+    }\n+\n","filename":"src\/java.base\/unix\/native\/libjli\/java_md.c","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -143,0 +143,13 @@\n+JNIEXPORT void JNICALL\n+Java_java_net_PlainSocketImpl_beforeCheckpoint0(JNIEnv *env, jclass cls) {\n+    \/* synchronized by closeLock *\/\n+    close(marker_fd);\n+    marker_fd = -1;\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_java_net_PlainSocketImpl_afterRestore0(JNIEnv *env, jclass cls) {\n+    \/* synchronized by closeLock *\/\n+    marker_fd = getMarkerFD();\n+}\n+\n@@ -725,1 +738,1 @@\n-Java_java_net_PlainSocketImpl_socketClose0(JNIEnv *env, jobject this,\n+Java_java_net_PlainSocketImpl_socketClose1(JNIEnv *env, jobject this,\n","filename":"src\/java.base\/unix\/native\/libnet\/PlainSocketImpl.c","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -76,0 +76,21 @@\n+        return;\n+    }\n+    preCloseFD = sp[0];\n+    close(sp[1]);\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_sun_nio_ch_FileDispatcherImpl_beforeCheckpoint0(JNIEnv *env, jclass cl)\n+{\n+    \/* synchronized by closeLock *\/\n+    close(preCloseFD);\n+    preCloseFD = -1;\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_sun_nio_ch_FileDispatcherImpl_afterRestore0(JNIEnv *env, jclass cl)\n+{\n+    \/* synchronized by closeLock *\/\n+    int sp[2];\n+    if (socketpair(PF_UNIX, SOCK_STREAM, 0, sp) < 0) {\n+        JNU_ThrowIOExceptionWithLastError(env, \"socketpair failed\");\n","filename":"src\/java.base\/unix\/native\/libnio\/ch\/FileDispatcherImpl.c","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -202,2 +202,7 @@\n-                        return path.getFileName().toString().equals(\"jspawnhelper\")\n-                                || path.getFileName().toString().equals(\"jexec\");\n+                        String fileName = path.getFileName().toString();\n+                        return fileName.equals(\"jspawnhelper\")\n+                            || fileName.equals(\"jexec\")\n+                            || fileName.equals(\"action-script\")\n+                            || fileName.equals(\"wait\")\n+                            || fileName.equals(\"criu\")\n+                            || fileName.equals(\"javatime\");\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/builder\/DefaultImageBuilder.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,139 @@\n+\/\/ Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it under\n+\/\/ the terms of the GNU General Public License version 2 only, as published by\n+\/\/ the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n+\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n+\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n+\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version 2\n+\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n+\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n+\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n+\/\/ have any questions.\n+\n+\n+import java.nio.channels.*;\n+import java.io.IOException;\n+import jdk.crac.*;\n+\n+class ChannelResource implements Resource {\n+\n+    public enum SelectionType {SELECT, SELECT_TIMEOUT, SELECT_NOW};\n+\n+    private SocketChannel channel;\n+    private SelectionKey  key;\n+    private Selector      selector;\n+\n+    private final SelectionType selType;\n+\n+    public ChannelResource(SelectionType selType) {\n+        this.selType = selType;\n+        Core.getGlobalContext().register(this);\n+    }\n+\n+    public void open() throws IOException {\n+        channel = SocketChannel.open();\n+        channel.configureBlocking(false);\n+    }\n+\n+    public void register(Selector selector) throws IOException {\n+        key = channel.register(selector, SelectionKey.OP_READ);\n+        this.selector = selector;\n+    }\n+\n+    @Override\n+    public void beforeCheckpoint(Context<? extends Resource> context) throws IOException {\n+\n+        channel.socket().close();\n+\n+        \/\/ causes the channel deregistration\n+        if (selType == SelectionType.SELECT_NOW) {\n+            selector.selectNow();\n+        } else if (selType == SelectionType.SELECT_TIMEOUT) {\n+            selector.select(500);\n+        } else {\n+            new Thread(new Runnable() {\n+                @Override\n+                public void run() {\n+                    try {\n+                        Thread.sleep(1000);\n+                        selector.wakeup();\n+                    } catch (InterruptedException ie) { throw new RuntimeException(ie); }\n+                }\n+            }).start();\n+\n+            selector.select();\n+        }\n+    }\n+\n+    @Override\n+    public void afterRestore(Context<? extends Resource> context) {\n+    }\n+}\n+\n+\n+public class Test {\n+\n+    private static void Test(ChannelResource.SelectionType selType, boolean openSelectorAtFirst) throws Exception {\n+\n+        if (openSelectorAtFirst) {\n+\n+            Selector selector = Selector.open();\n+            ChannelResource ch = new ChannelResource(selType);\n+            ch.open();\n+            ch.register(selector);\n+\n+            Core.checkpointRestore();\n+\n+            selector.close();\n+\n+        } else { \/\/ try in other order (see ZE-970)\n+\n+            ChannelResource ch = new ChannelResource(selType);\n+            ch.open();\n+            Selector selector = Selector.open();\n+            ch.register(selector);\n+\n+            Core.checkpointRestore();\n+\n+            selector.close();\n+        }\n+    }\n+\n+\n+    public static void main(String args[]) throws Exception {\n+\n+        if (args.length < 1) { throw new RuntimeException(\"test number is missing\"); }\n+\n+        switch (args[0]) { \/\/ 1, 2: ZE-970\n+            case \"1\":\n+                Test(ChannelResource.SelectionType.SELECT_NOW, true);\n+                break;\n+            case \"2\":\n+                Test(ChannelResource.SelectionType.SELECT_NOW, false);\n+                break;\n+            case \"3\":\n+                Test(ChannelResource.SelectionType.SELECT, true);\n+                break;\n+            case \"4\":\n+                Test(ChannelResource.SelectionType.SELECT, false);\n+                break;\n+            case \"5\":\n+                Test(ChannelResource.SelectionType.SELECT_TIMEOUT, true);\n+                break;\n+            case \"6\":\n+                Test(ChannelResource.SelectionType.SELECT_TIMEOUT, false);\n+                break;\n+            default:\n+                throw new RuntimeException(\"invalid test number\");\n+        }\n+\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/Selector\/Test970\/Test.java","additions":139,"deletions":0,"binary":false,"changes":139,"status":"added"},{"patch":"@@ -0,0 +1,190 @@\n+\/\/ Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it under\n+\/\/ the terms of the GNU General Public License version 2 only, as published by\n+\/\/ the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n+\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n+\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n+\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version 2\n+\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n+\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n+\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n+\/\/ have any questions.\n+\n+\n+import java.nio.channels.*;\n+import java.io.IOException;\n+import jdk.crac.*;\n+\n+class ChannelResource implements Resource {\n+\n+    private SocketChannel channel;\n+    private SelectionKey  key;\n+    private Selector      selector;\n+\n+    private Object        att = new Integer(123);\n+\n+    public ChannelResource() { Core.getGlobalContext().register(this); }\n+\n+    public void open() throws IOException {\n+        channel = SocketChannel.open();\n+        channel.configureBlocking(false);\n+    }\n+\n+    public void register(Selector selector) throws IOException {\n+        key = channel.register(selector, SelectionKey.OP_CONNECT);\n+        key.attach(att);\n+        this.selector = selector;\n+    }\n+\n+    @Override\n+    public void beforeCheckpoint(Context<? extends Resource> context) throws IOException {\n+\n+        channel.socket().close(); \/\/ close the channel => cancel the key\n+        check(!channel.isOpen(), \"the channel should not be open\");\n+        selector.select(100); \/\/ causes the channel deregistration\n+    }\n+\n+    @Override\n+    public void afterRestore(Context<? extends Resource> context) {\n+\n+        check(key.selector().equals(selector), \"invalid key.selector()\");\n+        check(key.channel().equals(channel), \"invalid key.channel()\");\n+\n+        \/\/ the key is cancelled\n+        check(!key.isValid(), \"expected: key.isValid() == false\");\n+\n+        boolean caught = false;\n+        try { key.readyOps(); }\n+        catch (CancelledKeyException e) { caught = true; }\n+        check(caught, \"expected CancelledKeyException is missing\");\n+\n+        caught = false;\n+        try { key.interestOps(); }\n+        catch (CancelledKeyException e) { caught = true; }\n+        check(caught, \"expected CancelledKeyException is missing\");\n+\n+        caught = false;\n+        try { key.interestOps(SelectionKey.OP_CONNECT); }\n+        catch (CancelledKeyException e) { caught = true; }\n+        check(caught, \"expected CancelledKeyException is missing\");\n+\n+        caught = false;\n+        try { key.readyOps(); }\n+        catch (CancelledKeyException e) { caught = true; }\n+        check(caught, \"expected CancelledKeyException is missing\");\n+\n+        caught = false;\n+        try { key.isReadable(); }\n+        catch (CancelledKeyException e) { caught = true; }\n+        check(caught, \"expected CancelledKeyException is missing\");\n+\n+        caught = false;\n+        try { key.isWritable(); }\n+        catch (CancelledKeyException e) { caught = true; }\n+        check(caught, \"expected CancelledKeyException is missing\");\n+\n+        caught = false;\n+        try { key.isConnectable(); }\n+        catch (CancelledKeyException e) { caught = true; }\n+        check(caught, \"expected CancelledKeyException is missing\");\n+\n+        caught = false;\n+        try { key.isAcceptable(); }\n+        catch (CancelledKeyException e) { caught = true; }\n+        check(caught, \"expected CancelledKeyException is missing\");\n+\n+        check(att.equals(key.attachment()), \"invalid key.attachment()\");\n+\n+        key.cancel(); \/\/ try just in case\n+\n+        \/\/ register again\n+        try {\n+            channel = SocketChannel.open();\n+            channel.configureBlocking(false);\n+            key = channel.register(selector, SelectionKey.OP_READ);\n+        }\n+        catch (Exception e) { throw new RuntimeException(e); }\n+    }\n+\n+    \/\/ to check after restore\n+    public void checkKey() {\n+\n+        check(key.isValid(), \"key must be valid\");\n+\n+        check(key.selector().equals(selector), \"invalid key.selector()\");\n+        check(key.channel().equals(channel), \"invalid key.channel()\");\n+\n+        key.isReadable(); \/\/ just call, cannot set \"ready\" state manually\n+        check( !key.isWritable()   , \"invalid key.isWritable()\"   );\n+        check( !key.isConnectable(), \"invalid key.isConnectable()\");\n+        check( !key.isAcceptable() , \"invalid key.isAcceptable()\" );\n+\n+        check(key.interestOps() == SelectionKey.OP_READ, \"invalid key.interestOps()\");\n+\n+        System.out.println(\">> ready >> \" + key.readyOps());\n+\n+        check(key.attachment() == null, \"key.attachment() expected to be null\");\n+\n+        key.cancel(); \/\/ try just in case\n+    }\n+\n+    private void check(boolean b, String msg) { if (!b) { throw new RuntimeException(msg); } }\n+}\n+\n+\n+public class Test {\n+\n+    private static void test(boolean openSelectorAtFirst) throws Exception {\n+\n+        ChannelResource ch;\n+        Selector selector = null;\n+\n+        \/\/ check various order (see ZE-970)\n+        if (openSelectorAtFirst) { selector = Selector.open(); }\n+\n+        ch = new ChannelResource();\n+        ch.open();\n+\n+        if (!openSelectorAtFirst) { selector = Selector.open(); }\n+\n+        ch.register(selector);\n+\n+        try {\n+            Core.checkpointRestore();\n+        } catch (CheckpointException | RestoreException e) {\n+            e.printStackTrace();\n+            throw e;\n+        }\n+\n+        Thread.sleep(200);\n+\n+        ch.checkKey();\n+\n+        selector.close();\n+    }\n+\n+    public static void main(String args[]) throws Exception {\n+\n+        if (args.length < 1) { throw new RuntimeException(\"test number is missing\"); }\n+\n+        switch (args[0]) {\n+            case \"1\":\n+                test(true);\n+                break;\n+            case \"2\":\n+                test(false);\n+                break;\n+            default:\n+                throw new RuntimeException(\"invalid test number\");\n+        }\n+\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/Selector\/keyAfterRestore\/Test.java","additions":190,"deletions":0,"binary":false,"changes":190,"status":"added"}]}