{"files":[{"patch":"@@ -40,1 +40,1 @@\n-    private static final Context<Resource> globalContext = new ContextWrapper(new OrderedContext());\n+    private static final Context<Resource> globalContext = new ContextWrapper(new OrderedContext<>());\n","filename":"src\/java.base\/share\/classes\/javax\/crac\/Core.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,2 +31,2 @@\n- *\n- * <p>The class that is interested in receiving a checkpoint\/restore notification\n+ * <p>\n+ * The class that is interested in receiving a checkpoint\/restore notification\n@@ -35,0 +35,6 @@\n+ * <p>\n+ * All notifications before checkpoint and after restore are performed in a\n+ * single thread, therefore the resource does not have to guard against\n+ * concurrent invocations of these methods. However, other threads might be\n+ * running during these notifications, therefore it is up to the implementation\n+ * to protect against concurrent access.\n@@ -40,2 +46,8 @@\n-     * The order of notification is subject to the {@link jdk.crac.Context} implementation,\n-     * e.g. for the global context see {@link Core#getGlobalContext()}.\n+     * The resource should not depend on the state of any other resource; when\n+     * this method is invoked it is possible that some other resource's\n+     * notification has thrown an error and\/or its\n+     * {@link #afterRestore(Context)} method has been already called.\n+     * <p>\n+     * The order of notification is subject to the {@link Context}\n+     * implementation, e.g. for the global context see\n+     * {@link Core#getGlobalContext()}.\n@@ -49,3 +61,14 @@\n-     * Invoked by a {@code Context} as a notification about restore.\n-     * The order of notification is subject to the {@link jdk.crac.Context} implementation,\n-     * e.g. for the global context see {@link Core#getGlobalContext()}.\n+     * Invoked by a {@code Context} both as a notification about restore or\n+     * when the checkpoint cannot be performed (e.g. due to this or some other\n+     * resource throwing an exception when {@link #beforeCheckpoint(Context)\n+     * beforeCheckpoint}.\n+     * Therefore, the resource should not have assumptions about it state; it\n+     * can be partially de-initialized if the previous invocation of\n+     * {@link #beforeCheckpoint(Context) beforeCheckpoint} was not successful.\n+     * <p>\n+     * The order of notification is subject to the {@link Context}\n+     * implementation, e.g. for the global context see\n+     * {@link Core#getGlobalContext()}.\n+     * <p>\n+     * The resource can assume that this method is called from the same thread\n+     * as {@link #beforeCheckpoint(Context)} was.\n","filename":"src\/java.base\/share\/classes\/javax\/crac\/Resource.java","additions":30,"deletions":7,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+import java.util.ArrayList;\n@@ -44,0 +45,1 @@\n+import java.util.List;\n@@ -63,0 +65,2 @@\n+    private static boolean restoring = false;\n+    private static List<Throwable> checkpointExceptions;\n@@ -69,1 +73,1 @@\n-    private static final Context<Resource> globalContext = new OrderedContext();\n+    private static final Context<Resource> globalContext = new OrderedContext<>(\"GlobalContext\");\n@@ -79,2 +83,1 @@\n-    private static void translateJVMExceptions(int[] codes, String[] messages,\n-                                               CheckpointException exception) {\n+    private static void translateJVMExceptions(int[] codes, String[] messages) {\n@@ -85,16 +88,7 @@\n-            switch(codes[i]) {\n-                case JVM_CR_FAIL_FILE:\n-                    exception.addSuppressed(\n-                            new CheckpointOpenFileException(messages[i]));\n-                    break;\n-                case JVM_CR_FAIL_SOCK:\n-                    exception.addSuppressed(\n-                            new CheckpointOpenSocketException(messages[i]));\n-                    break;\n-                case JVM_CR_FAIL_PIPE:\n-                    \/\/ FALLTHROUGH\n-                default:\n-                    exception.addSuppressed(\n-                            new CheckpointOpenResourceException(messages[i]));\n-                    break;\n-            }\n+            Throwable ex = switch (codes[i]) {\n+                case JVM_CR_FAIL_FILE -> new CheckpointOpenFileException(messages[i]);\n+                case JVM_CR_FAIL_SOCK -> new CheckpointOpenSocketException(messages[i]);\n+                case JVM_CR_FAIL_PIPE -> new CheckpointOpenResourceException(messages[i]);\n+                default -> new CheckpointOpenResourceException(messages[i]);\n+            };\n+            recordException(ex);\n@@ -118,0 +112,8 @@\n+    public static void recordException(Throwable e) {\n+        checkpointExceptions.add(e);\n+    }\n+\n+    public static synchronized boolean isRestoring() {\n+        return restoring;\n+    }\n+\n@@ -122,1 +124,0 @@\n-        CheckpointException checkpointException = null;\n@@ -127,1 +128,0 @@\n-            checkpointException = new CheckpointException();\n@@ -129,1 +129,1 @@\n-                checkpointException.addSuppressed(t);\n+                recordException(t);\n@@ -133,1 +133,4 @@\n-        final Object[] bundle = checkpointRestore0(checkpointException != null, jcmdStream);\n+        boolean checkpointHasExceptions = !checkpointExceptions.isEmpty();\n+        restoring = true;\n+\n+        final Object[] bundle = checkpointRestore0(checkpointHasExceptions, jcmdStream);\n@@ -145,3 +148,0 @@\n-            if (checkpointException == null) {\n-                checkpointException = new CheckpointException();\n-            }\n@@ -149,10 +149,3 @@\n-                case JVM_CHECKPOINT_ERROR:\n-                    translateJVMExceptions(codes, messages, checkpointException);\n-                    break;\n-                case JVM_CHECKPOINT_NONE:\n-                    checkpointException.addSuppressed(\n-                            new RuntimeException(\"C\/R is not configured\"));\n-                    break;\n-                default:\n-                    checkpointException.addSuppressed(\n-                            new RuntimeException(\"Unknown C\/R result: \" + retCode));\n+                case JVM_CHECKPOINT_ERROR -> translateJVMExceptions(codes, messages);\n+                case JVM_CHECKPOINT_NONE -> recordException(new RuntimeException(\"C\/R is not configured\"));\n+                default -> recordException(new RuntimeException(\"Unknown C\/R result: \" + retCode));\n@@ -170,1 +163,0 @@\n-        RestoreException restoreException = null;\n@@ -174,2 +166,2 @@\n-            if (checkpointException == null) {\n-                restoreException = re;\n+            if (re.getSuppressed().length == 0) {\n+                recordException(re);\n@@ -178,1 +170,1 @@\n-                    checkpointException.addSuppressed(t);\n+                    recordException(t);\n@@ -203,6 +195,1 @@\n-                    assert checkpointException == null :\n-                        \"should not have new arguments\";\n-                    if (restoreException == null) {\n-                        restoreException = new RestoreException();\n-                    }\n-                    restoreException.addSuppressed(e);\n+                    recordException(e);\n@@ -213,5 +200,14 @@\n-        assert checkpointException == null || restoreException == null;\n-        if (checkpointException != null) {\n-            throw checkpointException;\n-        } else if (restoreException != null) {\n-            throw restoreException;\n+        if (!checkpointExceptions.isEmpty()) {\n+            if (checkpointHasExceptions) {\n+                CheckpointException ce = new CheckpointException();\n+                for (Throwable checkpointException : checkpointExceptions) {\n+                    ce.addSuppressed(checkpointException);\n+                }\n+                throw ce;\n+            } else {\n+                RestoreException re = new RestoreException();\n+                for (Throwable checkpointException : checkpointExceptions) {\n+                    re.addSuppressed(checkpointException);\n+                }\n+                throw re;\n+            }\n@@ -250,0 +246,2 @@\n+                assert !restoring;\n+                checkpointExceptions = new ArrayList<>();\n@@ -257,0 +255,1 @@\n+                    restoring = false;\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/Core.java","additions":50,"deletions":51,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -31,2 +31,2 @@\n- *\n- * <p>The class that is interested in receiving a checkpoint\/restore notification\n+ * <p>\n+ * The class that is interested in receiving a checkpoint\/restore notification\n@@ -35,0 +35,6 @@\n+ * <p>\n+ * All notifications before checkpoint and after restore are performed in a\n+ * single thread, therefore the resource does not have to guard against\n+ * concurrent invocations of these methods. However, other threads might be\n+ * running during these notifications, therefore it is up to the implementation\n+ * to protect against concurrent access.\n@@ -40,2 +46,8 @@\n-     * The order of notification is subject to the {@link Context} implementation,\n-     * e.g. for the global context see {@link Core#getGlobalContext()}.\n+     * The resource should not depend on the state of any other resource; when\n+     * this method is invoked it is possible that some other resource's\n+     * notification has thrown an error and\/or its\n+     * {@link #afterRestore(Context)} method has been already called.\n+     * <p>\n+     * The order of notification is subject to the {@link Context}\n+     * implementation, e.g. for the global context see\n+     * {@link Core#getGlobalContext()}.\n@@ -49,3 +61,14 @@\n-     * Invoked by a {@code Context} as a notification about restore.\n-     * The order of notification is subject to the {@link Context} implementation,\n-     * e.g. for the global context see {@link Core#getGlobalContext()}.\n+     * Invoked by a {@code Context} both as a notification about restore or\n+     * when the checkpoint cannot be performed (e.g. due to this or some other\n+     * resource throwing an exception when {@link #beforeCheckpoint(Context)\n+     * beforeCheckpoint}.\n+     * Therefore, the resource should not have assumptions about it state; it\n+     * can be partially de-initialized if the previous invocation of\n+     * {@link #beforeCheckpoint(Context) beforeCheckpoint} was not successful.\n+     * <p>\n+     * The order of notification is subject to the {@link Context}\n+     * implementation, e.g. for the global context see\n+     * {@link Core#getGlobalContext()}.\n+     * <p>\n+     * The resource can assume that this method is called from the same thread\n+     * as {@link #beforeCheckpoint(Context)} was.\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/Resource.java","additions":30,"deletions":7,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -28,3 +28,3 @@\n-import java.util.*;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.locks.ReentrantLock;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n@@ -33,11 +33,1 @@\n-    private WeakHashMap<R, Long> resources = new WeakHashMap<>();\n-    \/\/ Queue content is temporary, so we won't mind that it's not a weak reference\n-    private Queue<Map.Entry<R, Long>> resourceQueue = new LinkedList<>();\n-    private List<R> restoreQ = null;\n-    private volatile long currentPriority = -1;\n-    \/\/ We use two locks: checkpointLock is required for both running the beforeCheckpoint\n-    \/\/ and registering a new resource, while restoreLock is required for running afterRestore\n-    \/\/ and beforeCheckpoint (to achieve exclusivity of before and after). It is fine\n-    \/\/ to acquire checkpointLock and register a new resource during afterRestore.\n-    private final ReentrantLock checkpointLock = new ReentrantLock();\n-    private final ReentrantLock restoreLock = new ReentrantLock();\n+    protected List<Resource> restoreQ = null;\n@@ -45,22 +35,7 @@\n-    protected void register(R resource, long priority) {\n-        assert priority >= 0;\n-        boolean locked = false;\n-        try {\n-            \/\/ We don't want to deadlock if the registration happens from another thread\n-            while (!checkpointLock.tryLock(10, TimeUnit.MILLISECONDS)) {\n-                throwIfCheckpointInProgress(priority);\n-            }\n-            locked = true;\n-            \/\/ This is important for the case of recursive registration\n-            throwIfCheckpointInProgress(priority);\n-            if (currentPriority < 0) {\n-                resources.put(resource, priority);\n-            } else {\n-                resourceQueue.add(Map.entry(resource, priority));\n-            }\n-        } catch (InterruptedException e) {\n-            Thread.currentThread().interrupt();\n-        } finally {\n-            if (locked) {\n-                checkpointLock.unlock();\n-            }\n+    protected static <E extends Exception> void recordExceptions(E source) {\n+        Throwable[] suppressed = source.getSuppressed();\n+        if (suppressed.length == 0) {\n+            Core.recordException(source);\n+        }\n+        for (Throwable t : suppressed) {\n+            Core.recordException(t);\n@@ -70,5 +45,3 @@\n-    private void throwIfCheckpointInProgress(long priority) {\n-        if (priority <= currentPriority) {\n-            throw new IllegalStateException(\"Notifications for an upcoming checkpoint are already in progress (priority \"\n-                    + currentPriority + \"). Please make sure to register this resource earlier or use higher priorty (\" + priority + \")\");\n-        }\n+    protected void setModified(R resource, String msg) {\n+        Core.recordException(new CheckpointException(\n+                \"Adding resource \" + resource + \" to \" + this + (msg != null ? msg : \"\")));\n@@ -77,4 +50,4 @@\n-    @Override\n-    public void beforeCheckpoint(Context<? extends Resource> context) throws CheckpointException {\n-        \/\/ If afterRestore is running we need to delay the beforeCheckpoint\n-        restoreLock.lock();\n+    protected void invokeBeforeCheckpoint(Resource resource) {\n+        LoggerContainer.debug(\"beforeCheckpoint {0}\", resource);\n+        \/\/ Resource.afterRestore is invoked even if Resource.beforeCheckpoint fails\n+        restoreQ.add(resource);\n@@ -82,12 +55,5 @@\n-            checkpointLock.lock();\n-            try {\n-                runBeforeCheckpoint();\n-            } finally {\n-                if (restoreQ != null) {\n-                    Collections.reverse(restoreQ);\n-                }\n-                currentPriority = -1;\n-                checkpointLock.unlock();\n-            }\n-        } finally {\n-            restoreLock.unlock();\n+            resource.beforeCheckpoint(semanticContext());\n+        } catch (CheckpointException e) {\n+            recordExceptions(e);\n+        } catch (Exception e) {\n+            Core.recordException(e);\n@@ -97,52 +63,2 @@\n-    private void runBeforeCheckpoint() throws CheckpointException {\n-        Map.Entry<R, Long> drained;\n-        while ((drained = resourceQueue.poll()) != null) {\n-            resources.put(drained.getKey(), drained.getValue());\n-        }\n-        CheckpointException exception = null;\n-        TreeMap<Long, List<R>> resources = this.resources.entrySet().stream().collect(\n-                TreeMap::new, (m, e) -> m.computeIfAbsent(e.getValue(), p -> new ArrayList<>()).add(e.getKey()), TreeMap::putAll);\n-        restoreQ = new ArrayList<>(this.resources.size());\n-\n-        \/\/ We cannot simply iterate because we could cause mutations\n-        while (!resources.isEmpty()) {\n-            var entry = resources.firstEntry();\n-            resources.remove(entry.getKey());\n-            currentPriority = entry.getKey();\n-            for (R r : entry.getValue()) {\n-                jdk.internal.crac.LoggerContainer.debug(\"beforeCheckpoint {0}\", r);\n-                try {\n-                    r.beforeCheckpoint(this);\n-                    restoreQ.add(r);\n-                } catch (CheckpointException e) {\n-                    enqueueIfContext(r);\n-                    if (exception == null) {\n-                        exception = new CheckpointException();\n-                    }\n-                    Throwable[] suppressed = e.getSuppressed();\n-                    if (suppressed.length == 0) {\n-                        exception.addSuppressed(e);\n-                    }\n-                    for (Throwable t : suppressed) {\n-                        exception.addSuppressed(t);\n-                    }\n-                } catch (Exception e) {\n-                    enqueueIfContext(r);\n-                    if (exception == null) {\n-                        exception = new CheckpointException();\n-                    }\n-                    exception.addSuppressed(e);\n-                }\n-            }\n-            while ((drained = resourceQueue.poll()) != null) {\n-                if (drained.getValue() <= currentPriority) {\n-                    \/\/ this should be prevented in register method\n-                    throw new IllegalStateException();\n-                }\n-                resources.computeIfAbsent(drained.getValue(), p -> new ArrayList<>()).add(drained.getKey());\n-            }\n-        }\n-\n-        if (exception != null) {\n-            throw exception;\n-        }\n+    protected Context<? extends Resource> semanticContext() {\n+        return this;\n@@ -151,7 +67,9 @@\n-    private void enqueueIfContext(R r) {\n-        \/\/ When the resource itself is a context it contains other resources that should\n-        \/\/ be restored upon unsuccessful checkpoint (if the beforeCheckpoint has thrown\n-        \/\/ we are going to call afterRestore on all checkpointed resources immediately)\n-        if (r instanceof Context<?>) {\n-            restoreQ.add(r);\n-        }\n+    @Override\n+    public void beforeCheckpoint(Context<? extends Resource> context) {\n+        \/\/ We won't synchronize access to restoreQ because methods\n+        \/\/ beforeCheckpoint and afterRestore should be invoked only\n+        \/\/ by the single thread performing the C\/R and other threads should\n+        \/\/ not touch that.\n+        restoreQ = new ArrayList<>();\n+        runBeforeCheckpoint();\n+        Collections.reverse(restoreQ);\n@@ -160,0 +78,2 @@\n+    protected abstract void runBeforeCheckpoint();\n+\n@@ -161,31 +81,5 @@\n-    public void afterRestore(Context<? extends Resource> context) throws RestoreException {\n-        restoreLock.lock();\n-        try {\n-            RestoreException exception = null;\n-            for (Resource r : restoreQ) {\n-                jdk.internal.crac.LoggerContainer.debug(\"afterRestore {0}\", r);\n-                try {\n-                    r.afterRestore(this);\n-                } catch (RestoreException e) {\n-                    \/\/ Print error early in case the restore process gets stuck\n-                    jdk.internal.crac.LoggerContainer.error(e, \"Failed to restore \" + r);\n-                    if (exception == null) {\n-                        exception = new RestoreException();\n-                    }\n-                    Throwable[] suppressed = e.getSuppressed();\n-                    if (suppressed.length == 0) {\n-                        exception.addSuppressed(e);\n-                    }\n-                    for (Throwable t : suppressed) {\n-                        exception.addSuppressed(t);\n-                    }\n-                } catch (Exception e) {\n-                    \/\/ Print error early in case the restore process gets stuck\n-                    LoggerContainer.error(e, \"Failed to restore \" + r);\n-                    if (exception == null) {\n-                        exception = new RestoreException();\n-                    }\n-                    exception.addSuppressed(e);\n-                }\n-            }\n-            restoreQ = null;\n+    public void afterRestore(Context<? extends Resource> context) {\n+        List<Resource> queue = restoreQ;\n+        restoreQ = null;\n+        runAfterRestore(queue);\n+    }\n@@ -193,2 +87,16 @@\n-            if (exception != null) {\n-                throw exception;\n+    private void runAfterRestore(List<Resource> queue) {\n+        if (queue == null) {\n+            return;\n+        }\n+        for (Resource r : queue) {\n+            LoggerContainer.debug(\"afterRestore {0}\", r);\n+            try {\n+                r.afterRestore(semanticContext());\n+            } catch (RestoreException e) {\n+                \/\/ Print error early in case the restore process gets stuck\n+                LoggerContainer.error(e, \"Failed to restore \" + r);\n+                recordExceptions(e);\n+            } catch (Exception e) {\n+                \/\/ Print error early in case the restore process gets stuck\n+                LoggerContainer.error(e, \"Failed to restore \" + r);\n+                Core.recordException(e);\n@@ -196,2 +104,0 @@\n-        } finally {\n-            restoreLock.unlock();\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/impl\/AbstractContextImpl.java","additions":57,"deletions":151,"binary":false,"changes":208,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import jdk.crac.Resource;\n+import jdk.crac.*;\n@@ -31,2 +31,10 @@\n-public class OrderedContext extends AbstractContextImpl<Resource> {\n-    private long order;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.WeakHashMap;\n+\n+public class OrderedContext<R extends Resource> extends AbstractContextImpl<R> {\n+    private final String name;\n+    private boolean checkpointing = false;\n+    protected long order = 0;\n+    protected final WeakHashMap<R, Long> resources = new WeakHashMap<>();\n@@ -35,0 +43,35 @@\n+        this(null);\n+    }\n+\n+    public OrderedContext(String name) {\n+        this.name = name;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return name != null ? name : super.toString();\n+    }\n+\n+    @Override\n+    public synchronized void register(R r) {\n+        resources.put(r, order++);\n+        \/\/ It is possible that something registers to us during restore but before\n+        \/\/ this context's afterRestore was called.\n+        if (checkpointing && !Core.isRestoring()) {\n+            setModified(r, null);\n+        }\n+    }\n+\n+    @Override\n+    protected void runBeforeCheckpoint() {\n+        List<R> resources;\n+        synchronized (this) {\n+            checkpointing = true;\n+            resources = this.resources.entrySet().stream()\n+                    .sorted(Collections.reverseOrder(Map.Entry.comparingByValue()))\n+                    .map(Map.Entry::getKey)\n+                    .toList();\n+        }\n+        for (R r : resources) {\n+            invokeBeforeCheckpoint(r);\n+        }\n@@ -38,5 +81,5 @@\n-    public synchronized void register(Resource r) {\n-        \/\/ Priorities are executed from lowest to highest; in order to call\n-        \/\/ beforeCheckpoint in reverse order compared to registration we use\n-        \/\/ descending numbers.\n-        register(r, Long.MAX_VALUE - (order++));\n+    public void afterRestore(Context<? extends Resource> context) {\n+        synchronized (this) {\n+            checkpointing = false;\n+        }\n+        super.afterRestore(context);\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/impl\/OrderedContext.java","additions":51,"deletions":8,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -0,0 +1,101 @@\n+\/\/ Copyright 2023 Azul Systems, Inc.\n+\/\/\n+\/\/ Redistribution and use in source and binary forms, with or without\n+\/\/ modification, are permitted provided that the following conditions are met:\n+\/\/\n+\/\/ 1. Redistributions of source code must retain the above copyright notice,\n+\/\/ this list of conditions and the following disclaimer.\n+\/\/\n+\/\/ 2. Redistributions in binary form must reproduce the above copyright notice,\n+\/\/ this list of conditions and the following disclaimer in the documentation\n+\/\/ and\/or other materials provided with the distribution.\n+\/\/\n+\/\/ IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+\/\/ ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n+\/\/ LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+\/\/ CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+\/\/ SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+\/\/ INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+\/\/ CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+\/\/ ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+\/\/ POSSIBILITY OF SUCH DAMAGE.\n+\n+package jdk.crac.impl;\n+\n+import jdk.crac.*;\n+\n+import java.util.*;\n+\n+public abstract class PriorityContext<P, R extends Resource> extends AbstractContextImpl<R> {\n+    private final TreeMap<P, SubContext> categories;\n+    private final Comparator<P> comparator;\n+    private P lastPriority = null;\n+\n+    protected PriorityContext(Comparator<P> comparator) {\n+        this.categories = new TreeMap<>(comparator);\n+        this.comparator = comparator;\n+    }\n+\n+    protected synchronized void register(R resource, P priority) {\n+        \/\/ computeIfAbsent does not work well here with lambda\n+        SubContext category = categories.get(priority);\n+        if (category == null) {\n+            category = new SubContext(getClass().getSimpleName() + \".\" + priority);\n+            categories.put(priority, category);\n+        }\n+        category.registerInSub(resource);\n+        if (lastPriority != null && comparator.compare(lastPriority, priority) >= 0 && !Core.isRestoring()) {\n+            setModified(resource, \": resource priority \" + priority + \", currently processing \" + lastPriority);\n+        }\n+    }\n+\n+    @Override\n+    protected void runBeforeCheckpoint() {\n+        Map.Entry<P, SubContext> entry;\n+        \/\/ We will use fine-grained synchronization to allow registration for higher category\n+        \/\/ in another thread.\n+        synchronized (this) {\n+            if (categories.isEmpty()) {\n+                return;\n+            }\n+            \/\/ This type of iteration should be O(N*log(N)), same as sorting, and does not suffer\n+            \/\/ from concurrent modifications. We'll track modifications for lower priorities in register()\n+            entry = categories.firstEntry();\n+            lastPriority = entry.getKey();\n+        }\n+        for (;;) {\n+            invokeBeforeCheckpoint(entry.getValue());\n+            synchronized (this) {\n+                entry = categories.higherEntry(entry.getKey());\n+                if (entry != null) {\n+                    lastPriority = entry.getKey();\n+                } else {\n+                    return;\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void afterRestore(Context<? extends Resource> context) {\n+        synchronized (this) {\n+            lastPriority = null;\n+        }\n+        super.afterRestore(context);\n+    }\n+\n+    public class SubContext extends OrderedContext<R> {\n+        public SubContext(String name) {\n+            super(name);\n+        }\n+\n+        synchronized void registerInSub(R r) {\n+            resources.put(r, order++);\n+        }\n+\n+        @Override\n+        protected Context<? extends Resource> semanticContext() {\n+            return PriorityContext.this;\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/impl\/PriorityContext.java","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"},{"patch":"@@ -32,1 +32,1 @@\n-    private static JDKContext JDKContext;\n+    private static final JDKContext JDKContext;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/Core.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,16 @@\n-import jdk.crac.impl.AbstractContextImpl;\n+import jdk.crac.impl.PriorityContext;\n+\n+import java.util.Comparator;\n+\n+public class JDKContext extends PriorityContext<JDKResource.Priority, JDKResource> {\n+    \/\/ We cannot use method references\/lambdas when the context is created\n+    public static final Comparator<JDKResource.Priority> PRIORITY_COMPARATOR = new Comparator<>() {\n+        @Override\n+        public int compare(JDKResource.Priority p1, JDKResource.Priority p2) {\n+            return p1.compareTo(p2);\n+        }\n+    };\n+\n+    public JDKContext() {\n+        super(PRIORITY_COMPARATOR);\n+    }\n@@ -31,1 +46,0 @@\n-public class JDKContext extends AbstractContextImpl<JDKResource> {\n@@ -34,1 +48,1 @@\n-        register(resource, resource.getPriority().ordinal());\n+        register(resource, resource.getPriority());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/JDKContext.java","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -24,4 +24,2 @@\n-import jdk.crac.CheckpointException;\n-import jdk.crac.Context;\n-import jdk.crac.Resource;\n-import jdk.crac.RestoreException;\n+import jdk.crac.*;\n+import jdk.crac.impl.OrderedContext;\n@@ -31,1 +29,0 @@\n-import java.util.Arrays;\n@@ -43,1 +40,2 @@\n- * @run main ContextOrderTest\n+ * @modules java.base\/jdk.crac.impl:+open\n+ * @run main\/othervm -ea -XX:CREngine=simengine -XX:CRaCCheckpointTo=ignored ContextOrderTest\n@@ -53,0 +51,1 @@\n+        testRegisterToCompleted();\n@@ -55,1 +54,1 @@\n-    private static void testOrder() throws CheckpointException, RestoreException {\n+    private static void testOrder() throws Exception {\n@@ -64,1 +63,2 @@\n-        getGlobalContext().beforeCheckpoint(null);\n+        Core.checkpointRestore();\n+\n@@ -68,6 +68,3 @@\n-        \/\/ The order of notifications with the same priority class is undefined\n-        List<String> normalPriority = Arrays.asList(recorder.poll(), recorder.poll(), recorder.poll());\n-        normalPriority.sort(String::compareTo);\n-        assertEquals(\"jdk-create-before\", normalPriority.get(0));\n-        assertEquals(\"jdk-normal-before\", normalPriority.get(1));\n-        assertEquals(\"regular2-child1-before\", normalPriority.get(2));\n+        assertEquals(\"regular2-child1-before\", recorder.poll());\n+        assertEquals(\"jdk-create-before\", recorder.poll());\n+        assertEquals(\"jdk-normal-before\", recorder.poll());\n@@ -77,3 +74,1 @@\n-        assertNull(recorder.poll());\n-\n-        getGlobalContext().afterRestore(null);\n+        \/\/ restore\n@@ -83,5 +78,3 @@\n-        normalPriority = Arrays.asList(recorder.poll(), recorder.poll(), recorder.poll());\n-        normalPriority.sort(String::compareTo);\n-        assertEquals(\"jdk-create-after\", normalPriority.get(0));\n-        assertEquals(\"jdk-normal-after\", normalPriority.get(1));\n-        assertEquals(\"regular2-child1-after\", normalPriority.get(2));\n+        assertEquals(\"jdk-normal-after\", recorder.poll());\n+        assertEquals(\"jdk-create-after\", recorder.poll());\n+        assertEquals(\"regular2-child1-after\", recorder.poll());\n@@ -94,1 +87,1 @@\n-        getGlobalContext().beforeCheckpoint(null);\n+        Core.checkpointRestore();\n@@ -97,0 +90,3 @@\n+\n+        rememberMe.clear();\n+        System.gc();\n@@ -99,1 +95,1 @@\n-    private static void testCannotRegister() {\n+    private static void testCannotRegister() throws Exception {\n@@ -109,1 +105,1 @@\n-            getGlobalContext().beforeCheckpoint(null);\n+            Core.checkpointRestore();\n@@ -114,6 +110,0 @@\n-            \/\/ Clear AbstractContextImpl.restoreQ\n-            try {\n-                getGlobalContext().afterRestore(null);\n-            } catch (RestoreException e) {\n-                \/\/ ignored\n-            }\n@@ -126,1 +116,1 @@\n-    private static void testThrowing() throws RestoreException {\n+    private static void testThrowing() throws Exception {\n@@ -129,1 +119,1 @@\n-        getGlobalContext().register(new ThrowingResource(null));\n+        getGlobalContext().register(new ThrowingResource(recorder, null, \"throwing1\"));\n@@ -132,1 +122,1 @@\n-        getJDKContext().register(new ThrowingResource(JDKResource.Priority.EPOLLSELECTOR));\n+        getJDKContext().register(new ThrowingResource(recorder, JDKResource.Priority.EPOLLSELECTOR, \"throwing2\"));\n@@ -136,1 +126,1 @@\n-            getGlobalContext().beforeCheckpoint(null);\n+            Core.checkpointRestore();\n@@ -139,1 +129,1 @@\n-            assertEquals(2, e.getSuppressed().length);\n+            assertEquals(4, e.getSuppressed().length);\n@@ -142,0 +132,1 @@\n+        assertEquals(\"throwing1-before\", recorder.poll());\n@@ -144,0 +135,1 @@\n+        assertEquals(\"throwing2-before\", recorder.poll());\n@@ -145,3 +137,0 @@\n-        assertNull(recorder.poll());\n-\n-        getGlobalContext().afterRestore(null);\n@@ -150,0 +139,1 @@\n+        assertEquals(\"throwing2-after\", recorder.poll());\n@@ -152,0 +142,1 @@\n+        assertEquals(\"throwing1-after\", recorder.poll());\n@@ -154,0 +145,3 @@\n+\n+        rememberMe.clear();\n+        System.gc();\n@@ -156,0 +150,38 @@\n+    \/\/ Similar to the test above but registers in context that is already done\n+    \/\/ rather than iterating through now. Also shows that registration adds\n+    \/\/ the resource to the context for the second attempt.\n+    private static void testRegisterToCompleted() throws Exception {\n+        var recorder = new LinkedList<String>();\n+\n+        OrderedContext<Resource> c1 = new OrderedContext<>();\n+        OrderedContext<Resource> c2 = new OrderedContext<>();\n+        getGlobalContext().register(c1);\n+        getGlobalContext().register(c2);\n+        c2.register(new MockResource(recorder, null, \"first\"));\n+        c1.register(new CreatingResource<>(recorder, null, \"second\", c2, null));\n+\n+        try {\n+            Core.checkpointRestore();\n+            fail(\"Expected checkpoint exception\");\n+        } catch (CheckpointException e) {\n+            e.printStackTrace();\n+            assertEquals(1, e.getSuppressed().length);\n+        } finally {\n+            getGlobalContext().afterRestore(null);\n+        }\n+        recorder.clear();\n+        \/\/ second time we should succeed\n+        Core.checkpointRestore();\n+        assertEquals(\"second-child2-before\", recorder.poll());\n+        assertEquals(\"second-child1-before\", recorder.poll());\n+        assertEquals(\"first-before\", recorder.poll());\n+        assertEquals(\"second-before\", recorder.poll());\n+\n+        assertEquals(\"second-after\", recorder.poll());\n+        assertEquals(\"first-after\", recorder.poll());\n+        assertEquals(\"second-child1-after\", recorder.poll());\n+        assertEquals(\"second-child2-after\", recorder.poll());\n+        assertNull(recorder.poll());\n+    }\n+\n+\n@@ -175,0 +207,1 @@\n+            ensureJDKContext(context);\n@@ -180,0 +213,1 @@\n+            ensureJDKContext(context);\n@@ -182,0 +216,11 @@\n+\n+        private void ensureJDKContext(Context<? extends Resource> context) {\n+            if (priority != null && context != getJDKContext()) {\n+                throw new AssertionError(context.toString());\n+            }\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return getClass().getSimpleName() + \":\" + id;\n+        }\n@@ -192,0 +237,1 @@\n+        private boolean first = true;\n@@ -202,2 +248,4 @@\n-            \/\/noinspection unchecked\n-            childContext.register((R) new MockResource(recorder, childPriority, id + \"-child1\"));\n+            if (first) {\n+                \/\/noinspection unchecked\n+                childContext.register((R) new MockResource(recorder, childPriority, id + \"-child1\"));\n+            }\n@@ -209,2 +257,5 @@\n-            \/\/noinspection unchecked\n-            childContext.register((R) new MockResource(recorder, childPriority, id + \"-child2\"));\n+            if (first) {\n+                \/\/noinspection unchecked\n+                childContext.register((R) new MockResource(recorder, childPriority, id + \"-child2\"));\n+            }\n+            first = false;\n@@ -215,2 +266,2 @@\n-        private ThrowingResource(Priority priority) {\n-            super(null, priority, \"throwing\");\n+        private ThrowingResource(List<String> recorder, Priority priority, String id) {\n+            super(recorder, priority, id);\n@@ -221,1 +272,2 @@\n-            throw new RuntimeException();\n+            super.beforeCheckpoint(context);\n+            throw new RuntimeException(id + \"-before\");\n@@ -226,1 +278,2 @@\n-            throw new RuntimeException();\n+            super.afterRestore(context);\n+            throw new RuntimeException(id + \"-after\");\n","filename":"test\/jdk\/jdk\/crac\/ContextOrderTest.java","additions":100,"deletions":47,"binary":false,"changes":147,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import jdk.test.lib.Utils;\n@@ -39,0 +40,1 @@\n+                .javaOption(\"java.util.logging.config.file\", Utils.TEST_SRC + \"\/logging.properties\")\n@@ -41,1 +43,1 @@\n-                .outputAnalyzer().shouldContain(\"jdk.crac beforeCheckpoint\");\n+                .outputAnalyzer().shouldContain(\"beforeCheckpoint LazyProps\");\n@@ -54,1 +56,0 @@\n-        System.setProperty(\"jdk.crac.debug\", \"true\");\n","filename":"test\/jdk\/jdk\/crac\/LazyProps.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,4 @@\n+handlers = java.util.logging.ConsoleHandler\n+.level = ALL\n+java.util.logging.ConsoleHandler.level = FINE\n+java.util.logging.SimpleFormatter.format=%1$tH:%1$tM:%1$tS %4$s [%3$s] %5$s%6$s%n\n\\ No newline at end of file\n","filename":"test\/jdk\/jdk\/crac\/logging.properties","additions":4,"deletions":0,"binary":false,"changes":4,"status":"added"},{"patch":"@@ -34,0 +34,1 @@\n+    final Map<String, String> javaOptions = new HashMap<>();\n@@ -102,0 +103,5 @@\n+    public CracBuilder javaOption(String name, String value) {\n+        javaOptions.put(name, value);\n+        return this;\n+    }\n+\n@@ -308,0 +314,1 @@\n+            cmd.add(\"-XX:+UnlockExperimentalVMOptions\");\n@@ -310,0 +317,3 @@\n+        for (var entry : javaOptions.entrySet()) {\n+            cmd.add(\"-D\" + entry.getKey() + \"=\" + entry.getValue());\n+        }\n","filename":"test\/lib\/jdk\/test\/lib\/crac\/CracBuilder.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"}]}