{"files":[{"patch":"@@ -40,1 +40,1 @@\n-    private static final Context<Resource> globalContext = new ContextWrapper(new OrderedContext<>());\n+    private static final Context<Resource> globalContext = new ContextWrapper(new OrderedContext<>(\"Global Context (javax)\"));\n","filename":"src\/java.base\/share\/classes\/javax\/crac\/Core.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-        super();\n+        super(null, null, true, false);\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/CheckpointException.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,1 +45,0 @@\n-import java.util.List;\n@@ -65,2 +64,0 @@\n-    private static boolean restoring = false;\n-    private static List<Throwable> checkpointExceptions;\n@@ -83,1 +80,2 @@\n-    private static void translateJVMExceptions(int[] codes, String[] messages) {\n+    private static void translateJVMExceptions(int[] codes, String[] messages,\n+                                               CheckpointException exception) {\n@@ -94,1 +92,1 @@\n-            recordException(ex);\n+            exception.addSuppressed(ex);\n@@ -131,28 +129,0 @@\n-    \/**\n-     * Records an exception thrown from a {@link Resource} during checkpoint\n-     * or restore, captured by the parent {@link Context}. As the failure from\n-     * resource notification does not affect notifications on other resources\n-     * this serves as the point for aggregation of all failures. These are\n-     * later reported as suppressed exceptions in a {@link CheckpointException}\n-     * or {@link RestoreException} thrown from {@link #checkpointRestore()}.\n-     *\n-     * @param e Exception to be aggregated.\n-     *\/\n-    public static synchronized void recordException(Throwable e) {\n-        assert checkpointInProgress;\n-        checkpointExceptions.add(e);\n-    }\n-\n-    \/**\n-     * Checks if we are currently invoking {@link Resource#afterRestore(Context)}\n-     * notifications (whether this is after a successful checkpoint or\n-     * compensating for a failed one). Calling this from a different thread\n-     * than the one performing the restore is subject to races.\n-     *\n-     * @return True if invoking <code>afterRestore<\/code>, false if the C\/R\n-     * is not in progress, or it is yet in the checkpoint phase.\n-     *\/\n-    public static synchronized boolean isRestoring() {\n-        return restoring;\n-    }\n-\n@@ -163,0 +133,1 @@\n+        CheckpointException checkpointException = null;\n@@ -167,0 +138,1 @@\n+            checkpointException = new CheckpointException();\n@@ -168,1 +140,1 @@\n-                recordException(t);\n+                checkpointException.addSuppressed(t);\n@@ -172,4 +144,1 @@\n-        boolean checkpointHasExceptions = !checkpointExceptions.isEmpty();\n-        restoring = true;\n-\n-        final Object[] bundle = checkpointRestore0(checkpointHasExceptions, jcmdStream);\n+        final Object[] bundle = checkpointRestore0(checkpointException != null, jcmdStream);\n@@ -187,0 +156,3 @@\n+            if (checkpointException == null) {\n+                checkpointException = new CheckpointException();\n+            }\n@@ -188,3 +160,3 @@\n-                case JVM_CHECKPOINT_ERROR -> translateJVMExceptions(codes, messages);\n-                case JVM_CHECKPOINT_NONE -> recordException(new RuntimeException(\"C\/R is not configured\"));\n-                default -> recordException(new RuntimeException(\"Unknown C\/R result: \" + retCode));\n+                case JVM_CHECKPOINT_ERROR -> translateJVMExceptions(codes, messages, checkpointException);\n+                case JVM_CHECKPOINT_NONE -> checkpointException.addSuppressed(new RuntimeException(\"C\/R is not configured\"));\n+                default -> checkpointException.addSuppressed(new RuntimeException(\"Unknown C\/R result: \" + retCode));\n@@ -202,0 +174,1 @@\n+        RestoreException restoreException = null;\n@@ -205,2 +178,2 @@\n-            if (re.getSuppressed().length == 0) {\n-                recordException(re);\n+            if (checkpointException == null) {\n+                restoreException = re;\n@@ -209,1 +182,1 @@\n-                    recordException(t);\n+                    checkpointException.addSuppressed(t);\n@@ -234,1 +207,6 @@\n-                    recordException(e);\n+                    assert checkpointException == null :\n+                        \"should not have new arguments\";\n+                    if (restoreException == null) {\n+                        restoreException = new RestoreException();\n+                    }\n+                    restoreException.addSuppressed(e);\n@@ -239,14 +217,5 @@\n-        if (!checkpointExceptions.isEmpty()) {\n-            if (checkpointHasExceptions) {\n-                CheckpointException ce = new CheckpointException();\n-                for (Throwable checkpointException : checkpointExceptions) {\n-                    ce.addSuppressed(checkpointException);\n-                }\n-                throw ce;\n-            } else {\n-                RestoreException re = new RestoreException();\n-                for (Throwable checkpointException : checkpointExceptions) {\n-                    re.addSuppressed(checkpointException);\n-                }\n-                throw re;\n-            }\n+        assert checkpointException == null || restoreException == null;\n+        if (checkpointException != null) {\n+            throw checkpointException;\n+        } else if (restoreException != null) {\n+            throw restoreException;\n@@ -285,2 +254,0 @@\n-                assert !restoring;\n-                checkpointExceptions = new ArrayList<>();\n@@ -294,1 +261,0 @@\n-                    restoring = false;\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/Core.java","additions":28,"deletions":62,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-        super();\n+        super(null, null, true, false);\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/RestoreException.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,18 +34,2 @@\n-\n-    protected static <E extends Exception> void recordExceptions(E exception) {\n-        assert exception instanceof CheckpointException || exception instanceof RestoreException;\n-        Throwable[] suppressed = exception.getSuppressed();\n-        if (suppressed.length == 0 || exception.getMessage() != null) {\n-            Core.recordException(exception);\n-        } else {\n-            \/\/ the exception is only wrapping actual ones...\n-            for (Throwable t : suppressed) {\n-                Core.recordException(t);\n-            }\n-        }\n-    }\n-\n-    protected void setModified(R resource, String msg) {\n-        Core.recordException(new CheckpointException(\n-                \"Adding resource \" + resource + \" to \" + this + (msg != null ? msg : \"\")));\n-    }\n+    private CheckpointException checkpointException = null;\n+    private RestoreException restoreException = null;\n@@ -59,1 +43,1 @@\n-            recordExceptions(e);\n+            handleCheckpointException(e);\n@@ -61,1 +45,4 @@\n-            Core.recordException(e);\n+            if (e instanceof InterruptedException) {\n+                Thread.currentThread().interrupt();\n+            }\n+            ensureCheckpointException().addSuppressed(e);\n@@ -65,0 +52,17 @@\n+    protected void handleCheckpointException(CheckpointException e) {\n+        CheckpointException ce = ensureCheckpointException();\n+        for (Throwable t : e.getSuppressed()) {\n+            ce.addSuppressed(t);\n+        }\n+        if (e.getMessage() != null) {\n+            ce.addSuppressed(e);\n+        }\n+    }\n+\n+    protected CheckpointException ensureCheckpointException() {\n+        if (checkpointException == null) {\n+            checkpointException = new CheckpointException();\n+        }\n+        return checkpointException;\n+    }\n+\n@@ -71,1 +75,1 @@\n-    public void beforeCheckpoint(Context<? extends Resource> context) {\n+    public void beforeCheckpoint(Context<? extends Resource> context) throws CheckpointException {\n@@ -79,0 +83,26 @@\n+        if (checkpointException != null) {\n+            CheckpointException ce = checkpointException;\n+            checkpointException = null;\n+            throw ce;\n+        }\n+    }\n+\n+    \/\/ This method has particularly verbose name to stick out in thread dumps\n+    \/\/ when the registration leads to a deadlock.\n+    protected void waitWhileCheckpointIsInProgress(R resource) {\n+        if (Thread.currentThread().isInterrupted()) {\n+            LoggerContainer.debug(Thread.currentThread().getName() + \" not waiting in \" + this +\n+                    \" to register \" + resource + \"; the thread has already been interrupted.\");\n+            \/\/ We won't cause IllegalStateException because this is not an unexpected state\n+            \/\/ from the point of CRaC - it probably tried to register some code before.\n+            throw new RuntimeException(\"Interrupted thread tried to block in registration of \" + resource + \" in \" + this);\n+        }\n+        LoggerContainer.debug(Thread.currentThread().getName() + \" waiting in \" + this + \" to register \" + resource);\n+        try {\n+            wait();\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+            LoggerContainer.debug(Thread.currentThread().getName() + \" interrupted waiting in \" + this +\n+                    \" to register \" + resource);\n+            throw new RuntimeException(\"Interrupted while trying to register \" + resource + \" in \" + this, e);\n+        }\n@@ -84,1 +114,1 @@\n-    public void afterRestore(Context<? extends Resource> context) {\n+    public void afterRestore(Context<? extends Resource> context) throws RestoreException {\n@@ -93,0 +123,5 @@\n+        if (restoreException != null) {\n+            RestoreException re = restoreException;\n+            restoreException = null;\n+            throw re;\n+        }\n@@ -102,1 +137,1 @@\n-            recordExceptions(e);\n+            handleRestoreException(e);\n@@ -104,1 +139,3 @@\n-            \/\/ Print error early in case the restore process gets stuck\n+            if (e instanceof InterruptedException) {\n+                Thread.currentThread().interrupt();\n+            }\n@@ -106,1 +143,17 @@\n-            Core.recordException(e);\n+            ensureRestoreException().addSuppressed(e);\n+        }\n+    }\n+\n+    protected void handleRestoreException(RestoreException e) {\n+        RestoreException re = ensureRestoreException();\n+        for (Throwable t : e.getSuppressed()) {\n+            re.addSuppressed(t);\n+        }\n+        if (e.getMessage() != null) {\n+            re.addSuppressed(e);\n+        }\n+    }\n+\n+    protected RestoreException ensureRestoreException() {\n+        if (restoreException == null) {\n+            restoreException = new RestoreException();\n@@ -108,0 +161,1 @@\n+        return restoreException;\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/impl\/AbstractContextImpl.java","additions":79,"deletions":25,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -42,4 +42,0 @@\n-    public OrderedContext() {\n-        this(null);\n-    }\n-\n@@ -56,6 +52,3 @@\n-    public synchronized void register(R r) {\n-        resources.put(r, order++);\n-        \/\/ It is possible that something registers to us during restore but before\n-        \/\/ this context's afterRestore was called.\n-        if (checkpointing && !Core.isRestoring()) {\n-            setModified(r, null);\n+    public synchronized void register(R resource) {\n+        while (checkpointing) {\n+            waitWhileCheckpointIsInProgress(resource);\n@@ -63,0 +56,1 @@\n+        resources.put(resource, order++);\n@@ -81,1 +75,2 @@\n-    public void afterRestore(Context<? extends Resource> context) {\n+    public void afterRestore(Context<? extends Resource> context) throws RestoreException {\n+        \/\/ Note: a resource might attempt to\n@@ -84,0 +79,1 @@\n+            notifyAll();\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/impl\/OrderedContext.java","additions":7,"deletions":11,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -43,0 +43,3 @@\n+        while (lastPriority != null && comparator.compare(lastPriority, priority) >= 0) {\n+            waitWhileCheckpointIsInProgress(resource);\n+        }\n@@ -46,1 +49,1 @@\n-            category = new SubContext(getClass().getSimpleName() + \".\" + priority);\n+            category = new SubContext(getClass().getSimpleName() + \"[\" + priority + \"]\");\n@@ -50,3 +53,0 @@\n-        if (lastPriority != null && comparator.compare(lastPriority, priority) >= 0 && !Core.isRestoring()) {\n-            setModified(resource, \": resource priority \" + priority + \", currently processing \" + lastPriority);\n-        }\n@@ -83,1 +83,1 @@\n-    public void afterRestore(Context<? extends Resource> context) {\n+    public void afterRestore(Context<? extends Resource> context) throws RestoreException {\n@@ -86,0 +86,1 @@\n+            notifyAll();\n@@ -108,1 +109,1 @@\n-                recordExceptions(e);\n+                handleCheckpointException(e);\n@@ -110,1 +111,4 @@\n-                Core.recordException(e);\n+                if (e instanceof InterruptedException) {\n+                    Thread.currentThread().interrupt();\n+                }\n+                ensureCheckpointException().addSuppressed(e);\n@@ -124,1 +128,1 @@\n-                recordExceptions(e);\n+                handleRestoreException(e);\n@@ -126,1 +130,3 @@\n-                \/\/ Print error early in case the restore process gets stuck\n+                if (e instanceof InterruptedException) {\n+                    Thread.currentThread().interrupt();\n+                }\n@@ -128,1 +134,1 @@\n-                Core.recordException(e);\n+                ensureRestoreException().addSuppressed(e);\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/impl\/PriorityContext.java","additions":16,"deletions":10,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import jdk.test.lib.Utils;\n@@ -31,0 +32,2 @@\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n@@ -34,0 +37,1 @@\n+import static jdk.internal.crac.JDKResource.Priority.*;\n@@ -48,4 +52,7 @@\n-        testOrder();\n-        testCannotRegister();\n-        testThrowing();\n-        testRegisterToCompleted();\n+        System.setProperty(\"java.util.logging.config.file\", Utils.TEST_SRC + \"\/logging.properties\");\n+\n+\/\/        testOrder();\n+\/\/        testRegisterBlocks();\n+\/\/        testThrowing();\n+\/\/        testRegisterToCompleted();\n+        testRegisterFromOtherThread();\n@@ -57,3 +64,3 @@\n-        getJDKContext().register(new MockResource(recorder, JDKResource.Priority.NORMAL, \"jdk-normal\"));\n-        getJDKContext().register(new MockResource(recorder, JDKResource.Priority.SECURE_RANDOM, \"jdk-later\"));\n-        getGlobalContext().register(new CreatingResource<>(recorder, null, \"regular2\", getJDKContext(), JDKResource.Priority.NORMAL));\n+        getJDKContext().register(new MockResource(recorder, NORMAL, \"jdk-normal\"));\n+        getJDKContext().register(new MockResource(recorder, SECURE_RANDOM, \"jdk-later\"));\n+        getGlobalContext().register(new CreatingResource<>(recorder, null, \"regular2\", getJDKContext(), NORMAL));\n@@ -61,1 +68,1 @@\n-        getJDKContext().register(new CreatingResource<>(recorder, JDKResource.Priority.NORMAL, \"jdk-create\", getJDKContext(), JDKResource.Priority.SEEDER_HOLDER));\n+        getJDKContext().register(new CreatingResource<>(recorder, NORMAL, \"jdk-create\", getJDKContext(), SEEDER_HOLDER));\n@@ -95,1 +102,1 @@\n-    private static void testCannotRegister() throws Exception {\n+    private static void testRegisterBlocks() throws Exception {\n@@ -97,6 +104,15 @@\n-        \/\/ cannot register into the same OrderedContext\n-        getGlobalContext().register(new CreatingResource<>(recorder, null, \"regular\", getGlobalContext(), null));\n-        \/\/ Cannot register with lower priority\n-        getJDKContext().register(new CreatingResource<>(recorder, JDKResource.Priority.SECURE_RANDOM, \"jdk-lower\", getJDKContext(), JDKResource.Priority.NORMAL));\n-        \/\/ Cannot register with the same priority\n-        getJDKContext().register(new CreatingResource<>(recorder, JDKResource.Priority.NORMAL, \"jdk-same\", getJDKContext(), JDKResource.Priority.NORMAL));\n+        \/\/ blocks register into the same OrderedContext\n+        getGlobalContext().register(new CreatingResource<>(recorder, null, \"regular\",\n+                getGlobalContext(), null));\n+        testWaiting();\n+\n+        \/\/ blocks registering with lower priority\n+        getJDKContext().register(new CreatingResource<>(recorder, SECURE_RANDOM, \"jdk-lower\",\n+                getJDKContext(), NORMAL));\n+        testWaiting();\n+\n+        \/\/ blocks registering with the same priority\n+        getJDKContext().register(new CreatingResource<>(recorder, NORMAL, \"jdk-same\",\n+                getJDKContext(), NORMAL));\n+        testWaiting();\n+    }\n@@ -104,9 +120,42 @@\n-        try {\n-            Core.checkpointRestore();\n-            fail(\"Expected to throw CheckpointException\");\n-        } catch (CheckpointException e) {\n-            assertEquals(3, e.getSuppressed().length);\n-        } finally {\n-            \/\/ Deregister all resources - we don't have a direct way to clear to contexts\n-            rememberMe.clear();\n-            System.gc();\n+    private static void testWaiting() throws InterruptedException {\n+        AtomicReference<Throwable> exceptionHolder = new AtomicReference<>();\n+        assertWaits(() -> {\n+            try {\n+                Core.checkpointRestore();\n+            } catch (Exception e) {\n+                assertTrue(Thread.currentThread().isInterrupted());\n+                exceptionHolder.set(e);\n+            }\n+        }, \"AbstractContextImpl\", \"waitWhileCheckpointIsInProgress\");\n+        assertNotNull(exceptionHolder.get());\n+        exceptionHolder.get().printStackTrace();\n+        rememberMe.clear();\n+        System.gc();\n+    }\n+\n+    private static void assertWaits(Runnable runnable, String cls, String method) throws InterruptedException {\n+        Thread thread = new Thread(runnable);\n+        thread.start();\n+        long deadline = System.nanoTime() + TimeUnit.SECONDS.toNanos(10);\n+        for (;;) {\n+            if (thread.getState() == Thread.State.WAITING) {\n+                for (var ste : thread.getStackTrace()) {\n+                    if ((cls == null || cls.equals(ste.getClassName()) || ste.getClassName().endsWith(\".\" + cls)) &&\n+                            (method == null || method.equals(ste.getMethodName()))) {\n+                        \/\/ It should be sufficient to interrupt the code once; if any Resource\n+                        \/\/ clears the flag without rethrowing it is a bug.\n+                        thread.interrupt();\n+                        thread.join(TimeUnit.NANOSECONDS.toMillis(deadline - System.nanoTime()));\n+                        assertFalse(thread.isAlive());\n+                        return;\n+                    }\n+                }\n+            } else if (thread.getState() == Thread.State.TERMINATED) {\n+                fail(\"Thread completed without waiting\");\n+            }\n+            if (System.nanoTime() < deadline) {\n+                \/\/noinspection BusyWait\n+                Thread.sleep(50);\n+            } else {\n+                fail(\"Timed out waiting for thread to get waiting in \" + cls + \".\" + method);\n+            }\n@@ -121,1 +170,1 @@\n-        getJDKContext().register(new MockResource(recorder, JDKResource.Priority.NORMAL, \"jdk1\"));\n+        getJDKContext().register(new MockResource(recorder, NORMAL, \"jdk1\"));\n@@ -123,1 +172,1 @@\n-        getJDKContext().register(new MockResource(recorder, JDKResource.Priority.SECURE_RANDOM, \"jdk2\"));\n+        getJDKContext().register(new MockResource(recorder, SECURE_RANDOM, \"jdk2\"));\n@@ -151,2 +200,1 @@\n-    \/\/ rather than iterating through now. Also shows that registration adds\n-    \/\/ the resource to the context for the second attempt.\n+    \/\/ rather than iterating through now.\n@@ -156,2 +204,2 @@\n-        OrderedContext<Resource> c1 = new OrderedContext<>();\n-        OrderedContext<Resource> c2 = new OrderedContext<>();\n+        OrderedContext<Resource> c1 = new OrderedContext<>(\"C1\");\n+        OrderedContext<Resource> c2 = new OrderedContext<>(\"C2\");\n@@ -161,0 +209,3 @@\n+        \/\/ Logically there's nothing that prevents to register into C2 during C1.<resource>.afterRestore\n+        \/\/ but the implementation of C1 does not know that we're already after C\/R and still blocks\n+        \/\/ any registrations.\n@@ -163,22 +214,7 @@\n-        try {\n-            Core.checkpointRestore();\n-            fail(\"Expected checkpoint exception\");\n-        } catch (CheckpointException e) {\n-            e.printStackTrace();\n-            assertEquals(1, e.getSuppressed().length);\n-        } finally {\n-            getGlobalContext().afterRestore(null);\n-        }\n-        recorder.clear();\n-        \/\/ second time we should succeed\n-        Core.checkpointRestore();\n-        assertEquals(\"second-child2-before\", recorder.poll());\n-        assertEquals(\"second-child1-before\", recorder.poll());\n-        assertEquals(\"first-before\", recorder.poll());\n-        assertEquals(\"second-before\", recorder.poll());\n-\n-        assertEquals(\"second-after\", recorder.poll());\n-        assertEquals(\"first-after\", recorder.poll());\n-        assertEquals(\"second-child1-after\", recorder.poll());\n-        assertEquals(\"second-child2-after\", recorder.poll());\n-        assertNull(recorder.poll());\n+        \/\/ This is supposed to end up with a deadlock. Even though it would block first\n+        \/\/ for -child1 and then for -child2 the first time we interrupt the thread it will\n+        \/\/ unblock and won't block any further.\n+        testWaiting();\n+\n+        \/\/ Since we have interrupted the registration no other resource was registered\n+        \/\/ so there's no point in testing anything here.\n@@ -187,0 +223,22 @@\n+    \/\/ registering from lower priority resource to higher priority shouldn't block\n+    \/\/ even in another thread\n+    private static void testRegisterFromOtherThread() throws RestoreException, CheckpointException {\n+        var recorder = new LinkedList<String>();\n+        getJDKContext().register(new MockResource(recorder, NORMAL, \"normal\") {\n+            @Override\n+            public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+                super.beforeCheckpoint(context);\n+                Thread thread = new Thread(() -> {\n+                    getJDKContext().register(new MockResource(recorder, CLEANERS, \"child\"));\n+                }, \"registrar\");\n+                thread.start();\n+                thread.join();\n+            }\n+        });\n+\n+        Core.checkpointRestore();\n+        assertEquals(\"normal-before\", recorder.poll());\n+        assertEquals(\"child-before\", recorder.poll());\n+        assertEquals(\"child-after\", recorder.poll());\n+        assertEquals(\"normal-after\", recorder.poll());\n+    }\n@@ -206,1 +264,1 @@\n-        public void beforeCheckpoint(Context<? extends Resource> context) {\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n@@ -212,1 +270,1 @@\n-        public void afterRestore(Context<? extends Resource> context) {\n+        public void afterRestore(Context<? extends Resource> context) throws Exception {\n@@ -219,1 +277,1 @@\n-                throw new AssertionError(context.toString());\n+                throw new AssertionError(id + \"expecting JDKContext, got \" + context.toString());\n@@ -246,1 +304,1 @@\n-        public void beforeCheckpoint(Context<? extends Resource> context) {\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n@@ -255,1 +313,1 @@\n-        public void afterRestore(Context<? extends Resource> context) {\n+        public void afterRestore(Context<? extends Resource> context) throws Exception {\n@@ -271,1 +329,1 @@\n-        public void beforeCheckpoint(Context<? extends Resource> context) {\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n@@ -277,1 +335,1 @@\n-        public void afterRestore(Context<? extends Resource> context) {\n+        public void afterRestore(Context<? extends Resource> context) throws Exception {\n","filename":"test\/jdk\/jdk\/crac\/ContextOrderTest.java","additions":117,"deletions":59,"binary":false,"changes":176,"status":"modified"}]}