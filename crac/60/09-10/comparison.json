{"files":[{"patch":"@@ -46,30 +46,1 @@\n-     * Gets the global {@code Context} for checkpoint\/restore notifications\n-     * with the following properties:\n-     * <ul>\n-     * <li>The context maintains a weak reference to registered {@link jdk.crac.Resource}.\n-     *     The lifecycle of the resource should be bound to the lifecycle of\n-     *     the component (registrar) through a strong reference to the resource\n-     *     (if these are not the same instance). That way the resource receives\n-     *     notifications only until the component ceases to exist.\n-     *     When the registrar does not keep a strong reference to the resource\n-     *     the garbage collector is free to trash the resource and notifications\n-     *     will not be invoked.\n-     * <li>Order of invoking {@link jdk.crac.Resource#beforeCheckpoint(jdk.crac.Context)} is\n-     *     the reverse of the order of {@linkplain jdk.crac.Context#register(jdk.crac.Resource)\n-     *     registration}.\n-     * <li>Order of invoking {@link jdk.crac.Resource#afterRestore(jdk.crac.Context)} is\n-     *     the reverse of the order of {@linkplain jdk.crac.Resource#beforeCheckpoint(jdk.crac.Context)\n-     *     checkpoint notification}, hence the same as the order of\n-     *     {@link jdk.crac.Context#register(jdk.crac.Resource) registration}.\n-     * <li>{@code Resource} is always notified of checkpoint or restore,\n-     *     regardless of whether other {@code Resource} notifications have\n-     *     thrown an exception or not,\n-     * <li>When an exception is thrown during notification it is caught by\n-     *     the {@code Context} and is suppressed by a {@link jdk.crac.CheckpointException}\n-     *     or {@link jdk.crac.RestoreException}, depends on the throwing method.\n-     * <li>When the {@code Resource} throws a {@link jdk.crac.CheckpointException} or\n-     *     {@link RestoreException} with suppressed exceptions (this happens\n-     *     e.g. when the {@code Resource} is a {@code Context}), this context\n-     *     throws a new exception of the same type, with suppressed exceptions\n-     *     from the original exception moved over to the new exception.\n-     * <\/ul>\n+     * Gets the global {@code Context} for checkpoint\/restore notifications.\n","filename":"src\/java.base\/share\/classes\/javax\/crac\/Core.java","additions":1,"deletions":30,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -31,2 +31,2 @@\n- * <p>\n- * The class that is interested in receiving a checkpoint\/restore notification\n+ *\n+ * <p>The class that is interested in receiving a checkpoint\/restore notification\n@@ -35,3 +35,0 @@\n- * <p>\n- * Note that other application threads might be running during these notifications,\n- * therefore it is up to the implementation to protect against concurrent access.\n@@ -43,8 +40,0 @@\n-     * The resource should not depend on the state of any other resource; when\n-     * this method is invoked it is possible that some other resource's\n-     * notification has thrown an error and\/or its\n-     * {@link #afterRestore(Context)} method has been already called.\n-     * <p>\n-     * The order of notification is subject to the {@link Context}\n-     * implementation, e.g. for the global context see\n-     * {@link Core#getGlobalContext()}.\n@@ -58,14 +47,1 @@\n-     * Invoked by a {@code Context} both as a notification about restore or\n-     * when the checkpoint cannot be performed (e.g. due to this or some other\n-     * resource throwing an exception when {@link #beforeCheckpoint(Context)\n-     * beforeCheckpoint}.\n-     * Therefore, the resource should not have assumptions about it state; it\n-     * can be partially de-initialized if the previous invocation of\n-     * {@link #beforeCheckpoint(Context) beforeCheckpoint} was not successful.\n-     * <p>\n-     * The order of notification is subject to the {@link Context}\n-     * implementation, e.g. for the global context see\n-     * {@link Core#getGlobalContext()}.\n-     * <p>\n-     * The resource can assume that this method is called from the same thread\n-     * as {@link #beforeCheckpoint(Context)} was.\n+     * Invoked by a {@code Context} as a notification about restore.\n","filename":"src\/java.base\/share\/classes\/javax\/crac\/Resource.java","additions":3,"deletions":27,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -70,0 +70,23 @@\n+ * <h2>Global Context Properties<\/h2>\n+ * Java Runtime maintains the global {@code Context} with following properties.\n+ * An implementor is encouraged to define {@code Context} with the properties of the global {@code Context}.\n+ * <ul>\n+ * <li>The {@code Context} maintains a weak reference to registered {@code Resource}.\n+ * <\/li>\n+ * <li>Order of checkpoint notification is the reverse order of registration.\n+ * Restore notification order is the reverse of checkpoint one, that is, forward order of registration.\n+ * <\/li>\n+ * <li>For single {@code Resource} registered in this {@code Context}:\n+ * <ul>\n+ *   <li>{@code Resource} is always notified of checkpoint, regardless of other {@code Resource} notifications have thrown an exception or not,\n+ *   <\/li>\n+ *   <li>{@code Resource} is always notified of restore, regardless of its checkpoint or others' restore notification have thrown an exception or not.\n+ *   <\/li>\n+ *   <li>When an exception is thrown during notificaion, it is caught by the {@code Context} and is suppressed by a {@code CheckpointException} or {@code RestoreException}, depends on the throwing method.\n+ *   <\/li>\n+ *   <li>When the {@code Resource} is a {@code Context} and it throws {@code CheckpointException} or {@code RestoreException}, exceptions suppressed by the original exception are suppressed by another {@code CheckpointException} or {@code RestoreException}, depends on the throwing method.\n+ *   <\/li>\n+ * <\/ul>\n+ * <li>All exceptions thrown by {@code Resource} are suppressed by {@code CheckpointException} or {@code RestoreException} thrown by the {@code Context}.\n+ * <\/li>\n+ * <\/ul>\n","filename":"src\/java.base\/share\/classes\/javax\/crac\/package-info.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-        super(null, null, true, false);\n+        super();\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/CheckpointException.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n-import java.util.ArrayList;\n@@ -86,7 +85,16 @@\n-            Throwable ex = switch (codes[i]) {\n-                case JVM_CR_FAIL_FILE -> new CheckpointOpenFileException(messages[i]);\n-                case JVM_CR_FAIL_SOCK -> new CheckpointOpenSocketException(messages[i]);\n-                case JVM_CR_FAIL_PIPE -> new CheckpointOpenResourceException(messages[i]);\n-                default -> new CheckpointOpenResourceException(messages[i]);\n-            };\n-            exception.addSuppressed(ex);\n+            switch(codes[i]) {\n+                case JVM_CR_FAIL_FILE:\n+                    exception.addSuppressed(\n+                            new CheckpointOpenFileException(messages[i]));\n+                    break;\n+                case JVM_CR_FAIL_SOCK:\n+                    exception.addSuppressed(\n+                            new CheckpointOpenSocketException(messages[i]));\n+                    break;\n+                case JVM_CR_FAIL_PIPE:\n+                    \/\/ FALLTHROUGH\n+                default:\n+                    exception.addSuppressed(\n+                            new CheckpointOpenResourceException(messages[i]));\n+                    break;\n+            }\n@@ -97,30 +105,1 @@\n-     * Gets the global {@code Context} for checkpoint\/restore notifications\n-     * with the following properties:\n-     * <ul>\n-     * <li>The context maintains a weak reference to registered {@link Resource}.\n-     *     The lifecycle of the resource should be bound to the lifecycle of\n-     *     the component (registrar) through a strong reference to the resource\n-     *     (if these are not the same instance). That way the resource receives\n-     *     notifications only until the component ceases to exist.\n-     *     When the registrar does not keep a strong reference to the resource\n-     *     the garbage collector is free to trash the resource and notifications\n-     *     will not be invoked.\n-     * <li>Order of invoking {@link Resource#beforeCheckpoint(Context)} is\n-     *     the reverse of the order of {@linkplain Context#register(Resource)\n-     *     registration}.\n-     * <li>Order of invoking {@link Resource#afterRestore(Context)} is\n-     *     the reverse of the order of {@linkplain Resource#beforeCheckpoint(Context)\n-     *     checkpoint notification}, hence the same as the order of\n-     *     {@link Context#register(Resource) registration}.\n-     * <li>{@code Resource} is always notified of checkpoint or restore,\n-     *     regardless of whether other {@code Resource} notifications have\n-     *     thrown an exception or not,\n-     * <li>When an exception is thrown during notification it is caught by\n-     *     the {@code Context} and is suppressed by a {@link CheckpointException}\n-     *     or {@link RestoreException}, depends on the throwing method.\n-     * <li>When the {@code Resource} throws a {@link CheckpointException} or\n-     *     {@link RestoreException} with suppressed exceptions (this happens\n-     *     e.g. when the {@code Resource} is a {@code Context}), this context\n-     *     throws a new exception of the same type, with suppressed exceptions\n-     *     from the original exception moved over to the new exception.\n-     * <\/ul>\n+     * Gets the global {@code Context} for checkpoint\/restore notifications.\n@@ -165,3 +144,10 @@\n-                case JVM_CHECKPOINT_ERROR -> translateJVMExceptions(codes, messages, checkpointException);\n-                case JVM_CHECKPOINT_NONE -> checkpointException.addSuppressed(new RuntimeException(\"C\/R is not configured\"));\n-                default -> checkpointException.addSuppressed(new RuntimeException(\"Unknown C\/R result: \" + retCode));\n+                case JVM_CHECKPOINT_ERROR:\n+                    translateJVMExceptions(codes, messages, checkpointException);\n+                    break;\n+                case JVM_CHECKPOINT_NONE:\n+                    checkpointException.addSuppressed(\n+                            new RuntimeException(\"C\/R is not configured\"));\n+                    break;\n+                default:\n+                    checkpointException.addSuppressed(\n+                            new RuntimeException(\"Unknown C\/R result: \" + retCode));\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/Core.java","additions":27,"deletions":41,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -31,2 +31,2 @@\n- * <p>\n- * The class that is interested in receiving a checkpoint\/restore notification\n+ *\n+ * <p>The class that is interested in receiving a checkpoint\/restore notification\n@@ -35,3 +35,0 @@\n- * <p>\n- * Note that other application threads might be running during these notifications,\n- * therefore it is up to the implementation to protect against concurrent access.\n@@ -43,8 +40,0 @@\n-     * The resource should not depend on the state of any other resource; when\n-     * this method is invoked it is possible that some other resource's\n-     * notification has thrown an error and\/or its\n-     * {@link #afterRestore(Context)} method has been already called.\n-     * <p>\n-     * The order of notification is subject to the {@link Context}\n-     * implementation, e.g. for the global context see\n-     * {@link Core#getGlobalContext()}.\n@@ -58,13 +47,1 @@\n-     * Invoked by a {@code Context} both as a notification about restore or\n-     * when the checkpoint cannot be performed (e.g. due to this or some other\n-     * resource throwing an exception from {@link #beforeCheckpoint(Context)\n-     * beforeCheckpoint}). As in the latter case the resource might be partially\n-     * de-initialized this method should validate its assumptions about resource\n-     * state and restore it to a valid state.\n-     * <p>\n-     * The order of notification is subject to the {@link Context}\n-     * implementation, e.g. for the global context see\n-     * {@link Core#getGlobalContext()}.\n-     * <p>\n-     * The resource can assume that this method is called from the same thread\n-     * as {@link #beforeCheckpoint(Context)} was.\n+     * Invoked by a {@code Context} as a notification about restore.\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/Resource.java","additions":3,"deletions":26,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-        super(null, null, true, false);\n+        super();\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/RestoreException.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n- * If the global {@code Context} throws an exception during checkpoint notification then restore notification starts immediately without the image creation.\n+ * If the global {@code Context} throws an exception during checkpoint notification then restore notificaion starts immediately without the image creation.\n@@ -70,0 +70,23 @@\n+ * <h2>Global Context Properties<\/h2>\n+ * Java Runtime maintains the global {@code Context} with following properties.\n+ * An implementor is encouraged to define {@code Context} with the properties of the global {@code Context}.\n+ * <ul>\n+ * <li>The {@code Context} maintains a weak reference to registered {@code Resource}.\n+ * <\/li>\n+ * <li>Order of checkpoint notification is the reverse order of registration.\n+ * Restore notification order is the reverse of checkpoint one, that is, forward order of registration.\n+ * <\/li>\n+ * <li>For single {@code Resource} registered in this {@code Context}:\n+ * <ul>\n+ *   <li>{@code Resource} is always notified of checkpoint, regardless of other {@code Resource} notifications have thrown an exception or not,\n+ *   <\/li>\n+ *   <li>{@code Resource} is always notified of restore, regardless of its checkpoint or others' restore notification have thrown an exception or not.\n+ *   <\/li>\n+ *   <li>When an exception is thrown during notificaion, it is caught by the {@code Context} and is suppressed by a {@code CheckpointException} or {@code RestoreException}, depends on the throwing method.\n+ *   <\/li>\n+ *   <li>When the {@code Resource} is a {@code Context} and it throws {@code CheckpointException} or {@code RestoreException}, exceptions suppressed by the original exception are suppressed by another {@code CheckpointException} or {@code RestoreException}, depends on the throwing method.\n+ *   <\/li>\n+ * <\/ul>\n+ * <li>All exceptions thrown by {@code Resource} are suppressed by {@code CheckpointException} or {@code RestoreException} thrown by the {@code Context}.\n+ * <\/li>\n+ * <\/ul>\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/package-info.java","additions":24,"deletions":1,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-    private static final JDKContext JDKContext;\n+    private static JDKContext JDKContext;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/Core.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-    public JDKContext() {\n+    JDKContext() {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/JDKContext.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -10,1 +10,1 @@\n-    public static final System.Logger logger = System.getLogger(\"jdk.internal.crac\");\n+    public static final System.Logger logger = System.getLogger(\"jdk.crac\");\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/LoggerContainer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,4 +54,4 @@\n-\/\/        testOrder();\n-\/\/        testRegisterBlocks();\n-\/\/        testThrowing();\n-\/\/        testRegisterToCompleted();\n+        testOrder();\n+        testRegisterBlocks();\n+        testThrowing();\n+        testRegisterToCompleted();\n","filename":"test\/jdk\/jdk\/crac\/ContextOrderTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1,58 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Azul Systems, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import jdk.crac.*;\n-import jdk.test.lib.Utils;\n-import jdk.test.lib.crac.CracBuilder;\n-import jdk.test.lib.crac.CracEngine;\n-import jdk.test.lib.crac.CracTest;\n-\n-\/**\n- * @test\n- * @library \/test\/lib\n- * @build LazyProps\n- * @run driver jdk.test.lib.crac.CracTest\n- *\/\n-public class LazyProps implements CracTest {\n-    @Override\n-    public void test() throws Exception {\n-        new CracBuilder().engine(CracEngine.SIMULATE)\n-                .javaOption(\"java.util.logging.config.file\", Utils.TEST_SRC + \"\/logging.properties\")\n-                .captureOutput(true)\n-                .startCheckpoint().waitForSuccess()\n-                .outputAnalyzer().shouldContain(\"beforeCheckpoint LazyProps\");\n-    }\n-\n-    @Override\n-    public void exec() throws RestoreException, CheckpointException {\n-        Resource resource = new Resource() {\n-            @Override\n-            public void beforeCheckpoint(Context<? extends Resource> context) throws Exception { }\n-            @Override\n-            public void afterRestore(Context<? extends Resource> context) throws Exception { }\n-        };\n-        Core.getGlobalContext().register(resource);\n-\n-        Core.checkpointRestore();\n-    }\n-}\n","filename":"test\/jdk\/jdk\/crac\/LazyProps.java","additions":0,"deletions":58,"binary":false,"changes":58,"status":"deleted"},{"patch":"@@ -1,4 +0,0 @@\n-handlers = java.util.logging.ConsoleHandler\n-.level = ALL\n-java.util.logging.ConsoleHandler.level = FINE\n-java.util.logging.SimpleFormatter.format=%1$tH:%1$tM:%1$tS %4$s [%3$s] %5$s%6$s%n\n\\ No newline at end of file\n","filename":"test\/jdk\/jdk\/crac\/logging.properties","additions":0,"deletions":4,"binary":false,"changes":4,"status":"deleted"},{"patch":"@@ -34,1 +34,0 @@\n-    final Map<String, String> javaOptions = new HashMap<>();\n@@ -103,5 +102,0 @@\n-    public CracBuilder javaOption(String name, String value) {\n-        javaOptions.put(name, value);\n-        return this;\n-    }\n-\n@@ -314,1 +308,0 @@\n-            cmd.add(\"-XX:+UnlockExperimentalVMOptions\");\n@@ -317,3 +310,0 @@\n-        for (var entry : javaOptions.entrySet()) {\n-            cmd.add(\"-D\" + entry.getKey() + \"=\" + entry.getValue());\n-        }\n","filename":"test\/lib\/jdk\/test\/lib\/crac\/CracBuilder.java","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"}]}