{"files":[{"patch":"@@ -40,1 +40,1 @@\n-    private static final Context<Resource> globalContext = new ContextWrapper(new OrderedContext());\n+    private static final Context<Resource> globalContext = new ContextWrapper(new OrderedContext<>());\n@@ -46,1 +46,22 @@\n-     * Gets the global {@code Context} for checkpoint\/restore notifications.\n+     * Gets the global {@code Context} for checkpoint\/restore notifications\n+     * with the following properties:\n+     * <ul>\n+     * <li>The context maintains a weak reference to registered {@link jdk.crac.Resource}.\n+     *     Therefore, it is important for the registrar to keep another strong\n+     *     reference to the resource - otherwise the garbage collector\n+     *     is free to trash the resource and notifications on this resource\n+     *     will not be invoked.\n+     * <li>Order of invoking {@link jdk.crac.Resource#beforeCheckpoint(jdk.crac.Context)} is\n+     *     the reverse of the order of {@linkplain jdk.crac.Context#register(jdk.crac.Resource)\n+     *     registration}.\n+     * <li>Order of invoking {@link jdk.crac.Resource#afterRestore(jdk.crac.Context)} is\n+     *     the reverse of the order of {@linkplain jdk.crac.Resource#beforeCheckpoint(jdk.crac.Context)\n+     *     checkpoint notification}, hence the same as the order of\n+     *     {@link jdk.crac.Context#register(jdk.crac.Resource) registration}.\n+     * <li>{@code Resource} is always notified of checkpoint or restore,\n+     *     regardless of whether other {@code Resource} notifications have\n+     *     thrown an exception or not,\n+     * <li>When an exception is thrown during notification it is caught by\n+     *     the {@code Context} and is suppressed by a {@link jdk.crac.CheckpointException}\n+     *     or {@link jdk.crac.RestoreException}, depends on the throwing method.\n+     * <\/ul>\n","filename":"src\/java.base\/share\/classes\/javax\/crac\/Core.java","additions":23,"deletions":2,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -31,2 +31,2 @@\n- *\n- * <p>The class that is interested in receiving a checkpoint\/restore notification\n+ * <p>\n+ * The class that is interested in receiving a checkpoint\/restore notification\n@@ -35,0 +35,6 @@\n+ * <p>\n+ * All notifications before checkpoint and after restore are performed in a\n+ * single thread, therefore the resource does not have to guard against\n+ * concurrent invocations of these methods. However, other threads might be\n+ * running during these notifications, therefore it is up to the implementation\n+ * to protect against concurrent access.\n@@ -40,0 +46,8 @@\n+     * The resource should not depend on the state of any other resource; when\n+     * this method is invoked it is possible that some other resource's\n+     * notification has thrown an error and\/or its\n+     * {@link #afterRestore(Context)} method has been already called.\n+     * <p>\n+     * The order of notification is subject to the {@link Context}\n+     * implementation, e.g. for the global context see\n+     * {@link Core#getGlobalContext()}.\n@@ -47,1 +61,14 @@\n-     * Invoked by a {@code Context} as a notification about restore.\n+     * Invoked by a {@code Context} both as a notification about restore or\n+     * when the checkpoint cannot be performed (e.g. due to this or some other\n+     * resource throwing an exception when {@link #beforeCheckpoint(Context)\n+     * beforeCheckpoint}.\n+     * Therefore, the resource should not have assumptions about it state; it\n+     * can be partially de-initialized if the previous invocation of\n+     * {@link #beforeCheckpoint(Context) beforeCheckpoint} was not successful.\n+     * <p>\n+     * The order of notification is subject to the {@link Context}\n+     * implementation, e.g. for the global context see\n+     * {@link Core#getGlobalContext()}.\n+     * <p>\n+     * The resource can assume that this method is called from the same thread\n+     * as {@link #beforeCheckpoint(Context)} was.\n","filename":"src\/java.base\/share\/classes\/javax\/crac\/Resource.java","additions":30,"deletions":3,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -70,23 +70,0 @@\n- * <h2>Global Context Properties<\/h2>\n- * Java Runtime maintains the global {@code Context} with following properties.\n- * An implementor is encouraged to define {@code Context} with the properties of the global {@code Context}.\n- * <ul>\n- * <li>The {@code Context} maintains a weak reference to registered {@code Resource}.\n- * <\/li>\n- * <li>Order of checkpoint notification is the reverse order of registration.\n- * Restore notification order is the reverse of checkpoint one, that is, forward order of registration.\n- * <\/li>\n- * <li>For single {@code Resource} registered in this {@code Context}:\n- * <ul>\n- *   <li>{@code Resource} is always notified of checkpoint, regardless of other {@code Resource} notifications have thrown an exception or not,\n- *   <\/li>\n- *   <li>{@code Resource} is always notified of restore, regardless of its checkpoint or others' restore notification have thrown an exception or not.\n- *   <\/li>\n- *   <li>When an exception is thrown during notificaion, it is caught by the {@code Context} and is suppressed by a {@code CheckpointException} or {@code RestoreException}, depends on the throwing method.\n- *   <\/li>\n- *   <li>When the {@code Resource} is a {@code Context} and it throws {@code CheckpointException} or {@code RestoreException}, exceptions suppressed by the original exception are suppressed by another {@code CheckpointException} or {@code RestoreException}, depends on the throwing method.\n- *   <\/li>\n- * <\/ul>\n- * <li>All exceptions thrown by {@code Resource} are suppressed by {@code CheckpointException} or {@code RestoreException} thrown by the {@code Context}.\n- * <\/li>\n- * <\/ul>\n","filename":"src\/java.base\/share\/classes\/javax\/crac\/package-info.java","additions":0,"deletions":23,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+import java.util.ArrayList;\n@@ -44,0 +45,1 @@\n+import java.util.List;\n@@ -63,0 +65,2 @@\n+    private static boolean restoring = false;\n+    private static List<Throwable> checkpointExceptions;\n@@ -69,1 +73,1 @@\n-    private static final Context<Resource> globalContext = new OrderedContext();\n+    private static final Context<Resource> globalContext = new OrderedContext<>(\"GlobalContext\");\n@@ -79,2 +83,1 @@\n-    private static void translateJVMExceptions(int[] codes, String[] messages,\n-                                               CheckpointException exception) {\n+    private static void translateJVMExceptions(int[] codes, String[] messages) {\n@@ -85,16 +88,7 @@\n-            switch(codes[i]) {\n-                case JVM_CR_FAIL_FILE:\n-                    exception.addSuppressed(\n-                            new CheckpointOpenFileException(messages[i]));\n-                    break;\n-                case JVM_CR_FAIL_SOCK:\n-                    exception.addSuppressed(\n-                            new CheckpointOpenSocketException(messages[i]));\n-                    break;\n-                case JVM_CR_FAIL_PIPE:\n-                    \/\/ FALLTHROUGH\n-                default:\n-                    exception.addSuppressed(\n-                            new CheckpointOpenResourceException(messages[i]));\n-                    break;\n-            }\n+            Throwable ex = switch (codes[i]) {\n+                case JVM_CR_FAIL_FILE -> new CheckpointOpenFileException(messages[i]);\n+                case JVM_CR_FAIL_SOCK -> new CheckpointOpenSocketException(messages[i]);\n+                case JVM_CR_FAIL_PIPE -> new CheckpointOpenResourceException(messages[i]);\n+                default -> new CheckpointOpenResourceException(messages[i]);\n+            };\n+            recordException(ex);\n@@ -105,1 +99,22 @@\n-     * Gets the global {@code Context} for checkpoint\/restore notifications.\n+     * Gets the global {@code Context} for checkpoint\/restore notifications\n+     * with the following properties:\n+     * <ul>\n+     * <li>The context maintains a weak reference to registered {@link Resource}.\n+     *     Therefore, it is important for the registrar to keep another strong\n+     *     reference to the resource - otherwise the garbage collector\n+     *     is free to trash the resource and notifications on this resource\n+     *     will not be invoked.\n+     * <li>Order of invoking {@link Resource#beforeCheckpoint(Context)} is\n+     *     the reverse of the order of {@linkplain Context#register(Resource)\n+     *     registration}.\n+     * <li>Order of invoking {@link Resource#afterRestore(Context)} is\n+     *     the reverse of the order of {@linkplain Resource#beforeCheckpoint(Context)\n+     *     checkpoint notification}, hence the same as the order of\n+     *     {@link Context#register(Resource) registration}.\n+     * <li>{@code Resource} is always notified of checkpoint or restore,\n+     *     regardless of whether other {@code Resource} notifications have\n+     *     thrown an exception or not,\n+     * <li>When an exception is thrown during notification it is caught by\n+     *     the {@code Context} and is suppressed by a {@link CheckpointException}\n+     *     or {@link RestoreException}, depends on the throwing method.\n+     * <\/ul>\n@@ -113,0 +128,17 @@\n+    public static void recordException(Throwable e) {\n+        checkpointExceptions.add(e);\n+    }\n+\n+    \/**\n+     * Checks if we are currently invoking {@link Resource#afterRestore(Context)}\n+     * notifications (whether this is after a successful checkpoint or\n+     * compensating for a failed one). Calling this from a different thread\n+     * than the one performing the restore is subject to races.\n+     *\n+     * @return True if invoking <code>afterRestore<\/code>, false if the C\/R\n+     * is not in progress, or it is yet in the checkpoint phase.\n+     *\/\n+    public static synchronized boolean isRestoring() {\n+        return restoring;\n+    }\n+\n@@ -117,1 +149,0 @@\n-        CheckpointException checkpointException = null;\n@@ -122,1 +153,0 @@\n-            checkpointException = new CheckpointException();\n@@ -124,1 +154,1 @@\n-                checkpointException.addSuppressed(t);\n+                recordException(t);\n@@ -128,1 +158,4 @@\n-        final Object[] bundle = checkpointRestore0(checkpointException != null, jcmdStream);\n+        boolean checkpointHasExceptions = !checkpointExceptions.isEmpty();\n+        restoring = true;\n+\n+        final Object[] bundle = checkpointRestore0(checkpointHasExceptions, jcmdStream);\n@@ -140,3 +173,0 @@\n-            if (checkpointException == null) {\n-                checkpointException = new CheckpointException();\n-            }\n@@ -144,10 +174,3 @@\n-                case JVM_CHECKPOINT_ERROR:\n-                    translateJVMExceptions(codes, messages, checkpointException);\n-                    break;\n-                case JVM_CHECKPOINT_NONE:\n-                    checkpointException.addSuppressed(\n-                            new RuntimeException(\"C\/R is not configured\"));\n-                    break;\n-                default:\n-                    checkpointException.addSuppressed(\n-                            new RuntimeException(\"Unknown C\/R result: \" + retCode));\n+                case JVM_CHECKPOINT_ERROR -> translateJVMExceptions(codes, messages);\n+                case JVM_CHECKPOINT_NONE -> recordException(new RuntimeException(\"C\/R is not configured\"));\n+                default -> recordException(new RuntimeException(\"Unknown C\/R result: \" + retCode));\n@@ -165,1 +188,0 @@\n-        RestoreException restoreException = null;\n@@ -169,2 +191,2 @@\n-            if (checkpointException == null) {\n-                restoreException = re;\n+            if (re.getSuppressed().length == 0) {\n+                recordException(re);\n@@ -173,1 +195,1 @@\n-                    checkpointException.addSuppressed(t);\n+                    recordException(t);\n@@ -198,6 +220,1 @@\n-                    assert checkpointException == null :\n-                        \"should not have new arguments\";\n-                    if (restoreException == null) {\n-                        restoreException = new RestoreException();\n-                    }\n-                    restoreException.addSuppressed(e);\n+                    recordException(e);\n@@ -208,5 +225,14 @@\n-        assert checkpointException == null || restoreException == null;\n-        if (checkpointException != null) {\n-            throw checkpointException;\n-        } else if (restoreException != null) {\n-            throw restoreException;\n+        if (!checkpointExceptions.isEmpty()) {\n+            if (checkpointHasExceptions) {\n+                CheckpointException ce = new CheckpointException();\n+                for (Throwable checkpointException : checkpointExceptions) {\n+                    ce.addSuppressed(checkpointException);\n+                }\n+                throw ce;\n+            } else {\n+                RestoreException re = new RestoreException();\n+                for (Throwable checkpointException : checkpointExceptions) {\n+                    re.addSuppressed(checkpointException);\n+                }\n+                throw re;\n+            }\n@@ -245,0 +271,2 @@\n+                assert !restoring;\n+                checkpointExceptions = new ArrayList<>();\n@@ -252,0 +280,1 @@\n+                    restoring = false;\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/Core.java","additions":81,"deletions":52,"binary":false,"changes":133,"status":"modified"},{"patch":"@@ -31,2 +31,2 @@\n- *\n- * <p>The class that is interested in receiving a checkpoint\/restore notification\n+ * <p>\n+ * The class that is interested in receiving a checkpoint\/restore notification\n@@ -35,0 +35,6 @@\n+ * <p>\n+ * All notifications before checkpoint and after restore are performed in a\n+ * single thread, therefore the resource does not have to guard against\n+ * concurrent invocations of these methods. However, other threads might be\n+ * running during these notifications, therefore it is up to the implementation\n+ * to protect against concurrent access.\n@@ -40,0 +46,8 @@\n+     * The resource should not depend on the state of any other resource; when\n+     * this method is invoked it is possible that some other resource's\n+     * notification has thrown an error and\/or its\n+     * {@link #afterRestore(Context)} method has been already called.\n+     * <p>\n+     * The order of notification is subject to the {@link Context}\n+     * implementation, e.g. for the global context see\n+     * {@link Core#getGlobalContext()}.\n@@ -47,1 +61,14 @@\n-     * Invoked by a {@code Context} as a notification about restore.\n+     * Invoked by a {@code Context} both as a notification about restore or\n+     * when the checkpoint cannot be performed (e.g. due to this or some other\n+     * resource throwing an exception when {@link #beforeCheckpoint(Context)\n+     * beforeCheckpoint}.\n+     * Therefore, the resource should not have assumptions about it state; it\n+     * can be partially de-initialized if the previous invocation of\n+     * {@link #beforeCheckpoint(Context) beforeCheckpoint} was not successful.\n+     * <p>\n+     * The order of notification is subject to the {@link Context}\n+     * implementation, e.g. for the global context see\n+     * {@link Core#getGlobalContext()}.\n+     * <p>\n+     * The resource can assume that this method is called from the same thread\n+     * as {@link #beforeCheckpoint(Context)} was.\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/Resource.java","additions":30,"deletions":3,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -25,5 +25,2 @@\n-import jdk.crac.CheckpointException;\n-import jdk.crac.Context;\n-import jdk.crac.Resource;\n-import jdk.crac.RestoreException;\n-import sun.security.action.GetBooleanAction;\n+import jdk.crac.*;\n+import jdk.internal.crac.LoggerContainer;\n@@ -31,2 +28,3 @@\n-import java.util.*;\n-import java.util.stream.Collectors;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n@@ -34,1 +32,2 @@\n-public abstract class AbstractContextImpl<R extends Resource, P> extends Context<R> {\n+public abstract class AbstractContextImpl<R extends Resource> extends Context<R> {\n+    private List<Resource> restoreQ = null;\n@@ -36,3 +35,11 @@\n-    private static class FlagsHolder {\n-        public static final boolean DEBUG =\n-            GetBooleanAction.privilegedGetProperty(\"jdk.crac.debug\");\n+    protected static <E extends Exception> void recordExceptions(E exception) {\n+        assert exception instanceof CheckpointException || exception instanceof RestoreException;\n+        Throwable[] suppressed = exception.getSuppressed();\n+        if (suppressed.length == 0 || exception.getMessage() != null) {\n+            Core.recordException(exception);\n+        } else {\n+            \/\/ the exception is only wrapping actual ones...\n+            for (Throwable t : suppressed) {\n+                Core.recordException(t);\n+            }\n+        }\n@@ -41,3 +48,4 @@\n-    private WeakHashMap<R, P> checkpointQ = new WeakHashMap<>();\n-    private List<R> restoreQ = null;\n-    private Comparator<Map.Entry<R, P>> comparator;\n+    protected void setModified(R resource, String msg) {\n+        Core.recordException(new CheckpointException(\n+                \"Adding resource \" + resource + \" to \" + this + (msg != null ? msg : \"\")));\n+    }\n@@ -45,2 +53,11 @@\n-    protected AbstractContextImpl(Comparator<Map.Entry<R, P>> comparator) {\n-        this.comparator = comparator;\n+    protected void invokeBeforeCheckpoint(Resource resource) {\n+        LoggerContainer.debug(\"beforeCheckpoint {0}\", resource);\n+        \/\/ Resource.afterRestore is invoked even if Resource.beforeCheckpoint fails\n+        restoreQ.add(resource);\n+        try {\n+            resource.beforeCheckpoint(semanticContext());\n+        } catch (CheckpointException e) {\n+            recordExceptions(e);\n+        } catch (Exception e) {\n+            Core.recordException(e);\n+        }\n@@ -49,2 +66,2 @@\n-    protected synchronized void register(R resource, P payload) {\n-        checkpointQ.put(resource, payload);\n+    protected Context<? extends Resource> semanticContext() {\n+        return this;\n@@ -54,28 +71,8 @@\n-    public synchronized void beforeCheckpoint(Context<? extends Resource> context) throws CheckpointException {\n-        List<R> resources = checkpointQ.entrySet().stream()\n-            .sorted(comparator)\n-            .map(Map.Entry::getKey)\n-            .collect(Collectors.toList());\n-\n-        CheckpointException exception = new CheckpointException();\n-        for (Resource r : resources) {\n-            if (FlagsHolder.DEBUG) {\n-                System.err.println(\"jdk.crac beforeCheckpoint \" + r.toString());\n-            }\n-            try {\n-                r.beforeCheckpoint(this);\n-            } catch (CheckpointException e) {\n-                for (Throwable t : e.getSuppressed()) {\n-                    exception.addSuppressed(t);\n-                }\n-            } catch (Exception e) {\n-                exception.addSuppressed(e);\n-            }\n-        }\n-\n-        Collections.reverse(resources);\n-        restoreQ = resources;\n-\n-        if (0 < exception.getSuppressed().length) {\n-            throw exception;\n-        }\n+    public void beforeCheckpoint(Context<? extends Resource> context) {\n+        \/\/ We won't synchronize access to restoreQ because methods\n+        \/\/ beforeCheckpoint and afterRestore should be invoked only\n+        \/\/ by the single thread performing the C\/R and other threads should\n+        \/\/ not touch that.\n+        restoreQ = new ArrayList<>();\n+        runBeforeCheckpoint();\n+        Collections.reverse(restoreQ);\n@@ -84,0 +81,2 @@\n+    protected abstract void runBeforeCheckpoint();\n+\n@@ -85,15 +84,4 @@\n-    public synchronized void afterRestore(Context<? extends Resource> context) throws RestoreException {\n-        RestoreException exception = new RestoreException();\n-        for (Resource r : restoreQ) {\n-            if (FlagsHolder.DEBUG) {\n-                System.err.println(\"jdk.crac afterRestore \" + r.toString());\n-            }\n-            try {\n-                r.afterRestore(this);\n-            } catch (RestoreException e) {\n-                for (Throwable t : e.getSuppressed()) {\n-                    exception.addSuppressed(t);\n-                }\n-            } catch (Exception e) {\n-                exception.addSuppressed(e);\n-            }\n+    public void afterRestore(Context<? extends Resource> context) {\n+        List<Resource> queue = restoreQ;\n+        if (queue == null) {\n+            return;\n@@ -102,0 +90,4 @@\n+        for (Resource r : queue) {\n+            invokeAfterRestore(r);\n+        }\n+    }\n@@ -103,2 +95,12 @@\n-        if (0 < exception.getSuppressed().length) {\n-            throw exception;\n+    protected void invokeAfterRestore(Resource resource) {\n+        LoggerContainer.debug(\"afterRestore {0}\", resource);\n+        try {\n+            resource.afterRestore(semanticContext());\n+        } catch (RestoreException e) {\n+            \/\/ Print error early in case the restore process gets stuck\n+            LoggerContainer.error(e, \"Failed to restore \" + resource);\n+            recordExceptions(e);\n+        } catch (Exception e) {\n+            \/\/ Print error early in case the restore process gets stuck\n+            LoggerContainer.error(e, \"Failed to restore \" + resource);\n+            Core.recordException(e);\n@@ -107,0 +109,1 @@\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/impl\/AbstractContextImpl.java","additions":66,"deletions":63,"binary":false,"changes":129,"status":"modified"},{"patch":"@@ -29,2 +29,1 @@\n-import jdk.crac.Resource;\n-import jdk.crac.impl.AbstractContextImpl;\n+import jdk.crac.*;\n@@ -32,1 +31,2 @@\n-import java.util.Comparator;\n+import java.util.Collections;\n+import java.util.List;\n@@ -34,0 +34,1 @@\n+import java.util.WeakHashMap;\n@@ -35,2 +36,5 @@\n-public class OrderedContext extends AbstractContextImpl<Resource, Long> {\n-    private long order;\n+public class OrderedContext<R extends Resource> extends AbstractContextImpl<R> {\n+    private final String name;\n+    private boolean checkpointing = false;\n+    protected long order = 0;\n+    protected final WeakHashMap<R, Long> resources = new WeakHashMap<>();\n@@ -38,4 +42,20 @@\n-    static class ContextComparator implements Comparator<Map.Entry<Resource, Long>> {\n-        @Override\n-        public int compare(Map.Entry<Resource, Long> o1, Map.Entry<Resource, Long> o2) {\n-            return (int)(o2.getValue() - o1.getValue());\n+    public OrderedContext() {\n+        this(null);\n+    }\n+\n+    public OrderedContext(String name) {\n+        this.name = name;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return name != null ? name : super.toString();\n+    }\n+\n+    @Override\n+    public synchronized void register(R r) {\n+        resources.put(r, order++);\n+        \/\/ It is possible that something registers to us during restore but before\n+        \/\/ this context's afterRestore was called.\n+        if (checkpointing && !Core.isRestoring()) {\n+            setModified(r, null);\n@@ -45,2 +65,13 @@\n-    public OrderedContext() {\n-        super(new ContextComparator());\n+    @Override\n+    protected void runBeforeCheckpoint() {\n+        List<R> resources;\n+        synchronized (this) {\n+            checkpointing = true;\n+            resources = this.resources.entrySet().stream()\n+                    .sorted(Collections.reverseOrder(Map.Entry.comparingByValue()))\n+                    .map(Map.Entry::getKey)\n+                    .toList();\n+        }\n+        for (R r : resources) {\n+            invokeBeforeCheckpoint(r);\n+        }\n@@ -50,2 +81,5 @@\n-    public synchronized void register(Resource r) {\n-        register(r, order++);\n+    public void afterRestore(Context<? extends Resource> context) {\n+        synchronized (this) {\n+            checkpointing = false;\n+        }\n+        super.afterRestore(context);\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/impl\/OrderedContext.java","additions":47,"deletions":13,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.crac.impl;\n+\n+import jdk.crac.*;\n+\n+import java.util.*;\n+\n+public abstract class PriorityContext<P, R extends Resource> extends AbstractContextImpl<R> {\n+    private final TreeMap<P, SubContext> categories;\n+    private final Comparator<P> comparator;\n+    private P lastPriority = null;\n+\n+    protected PriorityContext(Comparator<P> comparator) {\n+        this.categories = new TreeMap<>(comparator);\n+        this.comparator = comparator;\n+    }\n+\n+    protected synchronized void register(R resource, P priority) {\n+        \/\/ computeIfAbsent does not work well here with lambda\n+        SubContext category = categories.get(priority);\n+        if (category == null) {\n+            category = new SubContext(getClass().getSimpleName() + \".\" + priority);\n+            categories.put(priority, category);\n+        }\n+        category.registerInSub(resource);\n+        if (lastPriority != null && comparator.compare(lastPriority, priority) >= 0 && !Core.isRestoring()) {\n+            setModified(resource, \": resource priority \" + priority + \", currently processing \" + lastPriority);\n+        }\n+    }\n+\n+    @Override\n+    protected void runBeforeCheckpoint() {\n+        Map.Entry<P, SubContext> entry;\n+        \/\/ We will use fine-grained synchronization to allow registration for higher category\n+        \/\/ in another thread.\n+        synchronized (this) {\n+            if (categories.isEmpty()) {\n+                return;\n+            }\n+            \/\/ This type of iteration should be O(N*log(N)), same as sorting, and does not suffer\n+            \/\/ from concurrent modifications. We'll track modifications for lower priorities in register()\n+            entry = categories.firstEntry();\n+            lastPriority = entry.getKey();\n+        }\n+        for (;;) {\n+            invokeBeforeCheckpoint(entry.getValue());\n+            synchronized (this) {\n+                entry = categories.higherEntry(entry.getKey());\n+                if (entry != null) {\n+                    lastPriority = entry.getKey();\n+                } else {\n+                    return;\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void afterRestore(Context<? extends Resource> context) {\n+        synchronized (this) {\n+            lastPriority = null;\n+        }\n+        super.afterRestore(context);\n+    }\n+\n+    public class SubContext extends OrderedContext<R> {\n+        public SubContext(String name) {\n+            super(name);\n+        }\n+\n+        synchronized void registerInSub(R r) {\n+            resources.put(r, order++);\n+        }\n+\n+        @Override\n+        protected Context<? extends Resource> semanticContext() {\n+            return PriorityContext.this;\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/impl\/PriorityContext.java","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"},{"patch":"@@ -65,1 +65,1 @@\n- * If the global {@code Context} throws an exception during checkpoint notification then restore notificaion starts immediately without the image creation.\n+ * If the global {@code Context} throws an exception during checkpoint notification then restore notification starts immediately without the image creation.\n@@ -70,23 +70,0 @@\n- * <h2>Global Context Properties<\/h2>\n- * Java Runtime maintains the global {@code Context} with following properties.\n- * An implementor is encouraged to define {@code Context} with the properties of the global {@code Context}.\n- * <ul>\n- * <li>The {@code Context} maintains a weak reference to registered {@code Resource}.\n- * <\/li>\n- * <li>Order of checkpoint notification is the reverse order of registration.\n- * Restore notification order is the reverse of checkpoint one, that is, forward order of registration.\n- * <\/li>\n- * <li>For single {@code Resource} registered in this {@code Context}:\n- * <ul>\n- *   <li>{@code Resource} is always notified of checkpoint, regardless of other {@code Resource} notifications have thrown an exception or not,\n- *   <\/li>\n- *   <li>{@code Resource} is always notified of restore, regardless of its checkpoint or others' restore notification have thrown an exception or not.\n- *   <\/li>\n- *   <li>When an exception is thrown during notificaion, it is caught by the {@code Context} and is suppressed by a {@code CheckpointException} or {@code RestoreException}, depends on the throwing method.\n- *   <\/li>\n- *   <li>When the {@code Resource} is a {@code Context} and it throws {@code CheckpointException} or {@code RestoreException}, exceptions suppressed by the original exception are suppressed by another {@code CheckpointException} or {@code RestoreException}, depends on the throwing method.\n- *   <\/li>\n- * <\/ul>\n- * <li>All exceptions thrown by {@code Resource} are suppressed by {@code CheckpointException} or {@code RestoreException} thrown by the {@code Context}.\n- * <\/li>\n- * <\/ul>\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/package-info.java","additions":1,"deletions":24,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-    private static JDKContext JDKContext;\n+    private static final JDKContext JDKContext;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/Core.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import jdk.crac.impl.AbstractContextImpl;\n+import jdk.crac.impl.PriorityContext;\n@@ -32,1 +32,0 @@\n-import java.util.Map;\n@@ -34,2 +33,3 @@\n-public class JDKContext extends AbstractContextImpl<JDKResource, Void> {\n-    static class ContextComparator implements Comparator<Map.Entry<JDKResource, Void>> {\n+public class JDKContext extends PriorityContext<JDKResource.Priority, JDKResource> {\n+    \/\/ We cannot use method references\/lambdas when the context is created\n+    public static final Comparator<JDKResource.Priority> PRIORITY_COMPARATOR = new Comparator<>() {\n@@ -37,2 +37,2 @@\n-        public int compare(Map.Entry<JDKResource, Void> o1, Map.Entry<JDKResource, Void> o2) {\n-            return o1.getKey().getPriority().compareTo(o2.getKey().getPriority());\n+        public int compare(JDKResource.Priority p1, JDKResource.Priority p2) {\n+            return p1.compareTo(p2);\n@@ -40,1 +40,1 @@\n-    }\n+    };\n@@ -42,2 +42,2 @@\n-    JDKContext() {\n-        super(new ContextComparator());\n+    public JDKContext() {\n+        super(PRIORITY_COMPARATOR);\n@@ -48,1 +48,1 @@\n-        register(resource, null);\n+        register(resource, resource.getPriority());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/JDKContext.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -0,0 +1,29 @@\n+package jdk.internal.crac;\n+\n+\/**\n+ * Some classes that could use logging are initialized early during the boot\n+ * and keeping the logger in static final field there could cause problems\n+ * (e.g. recursion when service-loading logger implementation).\n+ * Therefore, we isolate the logger into a subclass and initialize lazily.\n+ *\/\n+public class LoggerContainer {\n+    public static final System.Logger logger = System.getLogger(\"jdk.internal.crac\");\n+\n+    public static void info(String msg) {\n+        logger.log(System.Logger.Level.INFO, msg);\n+    }\n+\n+    public static void debug(String fmt, Object... params) {\n+        logger.log(System.Logger.Level.DEBUG, fmt, params);\n+    }\n+\n+    private LoggerContainer() {}\n+\n+    public static void error(String msg) {\n+        logger.log(System.Logger.Level.ERROR, msg);\n+    }\n+\n+    public static void error(Throwable t, String msg) {\n+        logger.log(System.Logger.Level.ERROR, msg, t);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/LoggerContainer.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.crac.LoggerContainer;\n@@ -39,8 +40,0 @@\n-    \/\/ PersistentJarFile is <clinit>ed when loading classes on the module path;\n-    \/\/ when initializing the logger an implementation of logging is looked up through\n-    \/\/ service-loading and that causes a recursion in opening the module.\n-    \/\/ Therefore, we isolate the logger into a subclass and initialize only when needed.\n-    private static class LoggerContainer {\n-        private static final System.Logger logger = System.getLogger(\"jdk.crac\");\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/jar\/PersistentJarFile.java","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,282 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.*;\n+import jdk.crac.impl.OrderedContext;\n+import jdk.internal.crac.JDKResource;\n+\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import static jdk.crac.Core.getGlobalContext;\n+import static jdk.internal.crac.Core.*;\n+import static jdk.test.lib.Asserts.*;\n+\n+\/**\n+ * @test ContextOrderTest\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.crac:+open\n+ * @modules java.base\/jdk.crac.impl:+open\n+ * @run main\/othervm -ea -XX:CREngine=simengine -XX:CRaCCheckpointTo=ignored ContextOrderTest\n+ *\/\n+public class ContextOrderTest {\n+    \/\/ prevents GC releasing the resources\n+    private static final List<Resource> rememberMe = new ArrayList<>();\n+\n+    public static void main(String[] args) throws Exception {\n+        testOrder();\n+        testCannotRegister();\n+        testThrowing();\n+        testRegisterToCompleted();\n+    }\n+\n+    private static void testOrder() throws Exception {\n+        var recorder = new LinkedList<String>();\n+        getGlobalContext().register(new MockResource(recorder, null, \"regular1\"));\n+        getJDKContext().register(new MockResource(recorder, JDKResource.Priority.NORMAL, \"jdk-normal\"));\n+        getJDKContext().register(new MockResource(recorder, JDKResource.Priority.SECURE_RANDOM, \"jdk-later\"));\n+        getGlobalContext().register(new CreatingResource<>(recorder, null, \"regular2\", getJDKContext(), JDKResource.Priority.NORMAL));\n+        \/\/ this child should run as it has higher priority\n+        getJDKContext().register(new CreatingResource<>(recorder, JDKResource.Priority.NORMAL, \"jdk-create\", getJDKContext(), JDKResource.Priority.SEEDER_HOLDER));\n+\n+        Core.checkpointRestore();\n+\n+        assertEquals(\"regular2-before\", recorder.poll());\n+        assertEquals(\"regular1-before\", recorder.poll());\n+\n+        assertEquals(\"regular2-child1-before\", recorder.poll());\n+        assertEquals(\"jdk-create-before\", recorder.poll());\n+        assertEquals(\"jdk-normal-before\", recorder.poll());\n+\n+        assertEquals(\"jdk-later-before\", recorder.poll());\n+        assertEquals(\"jdk-create-child1-before\", recorder.poll());\n+        \/\/ restore\n+        assertEquals(\"jdk-create-child1-after\", recorder.poll());\n+        assertEquals(\"jdk-later-after\", recorder.poll());\n+\n+        assertEquals(\"jdk-normal-after\", recorder.poll());\n+        assertEquals(\"jdk-create-after\", recorder.poll());\n+        assertEquals(\"regular2-child1-after\", recorder.poll());\n+\n+        assertEquals(\"regular1-after\", recorder.poll());\n+        assertEquals(\"regular2-after\", recorder.poll());\n+        assertNull(recorder.poll());\n+\n+        \/\/ second checkpoint - whatever was registered in first afterRestore is now notified\n+        Core.checkpointRestore();\n+        assertTrue(recorder.stream().anyMatch(\"jdk-create-child2-before\"::equals));\n+        assertTrue(recorder.stream().anyMatch(\"regular2-child2-before\"::equals));\n+\n+        rememberMe.clear();\n+        System.gc();\n+    }\n+\n+    private static void testCannotRegister() throws Exception {\n+        var recorder = new LinkedList<String>();\n+        \/\/ cannot register into the same OrderedContext\n+        getGlobalContext().register(new CreatingResource<>(recorder, null, \"regular\", getGlobalContext(), null));\n+        \/\/ Cannot register with lower priority\n+        getJDKContext().register(new CreatingResource<>(recorder, JDKResource.Priority.SECURE_RANDOM, \"jdk-lower\", getJDKContext(), JDKResource.Priority.NORMAL));\n+        \/\/ Cannot register with the same priority\n+        getJDKContext().register(new CreatingResource<>(recorder, JDKResource.Priority.NORMAL, \"jdk-same\", getJDKContext(), JDKResource.Priority.NORMAL));\n+\n+        try {\n+            Core.checkpointRestore();\n+            fail(\"Expected to throw CheckpointException\");\n+        } catch (CheckpointException e) {\n+            assertEquals(3, e.getSuppressed().length);\n+        } finally {\n+            \/\/ Deregister all resources - we don't have a direct way to clear to contexts\n+            rememberMe.clear();\n+            System.gc();\n+        }\n+    }\n+\n+    private static void testThrowing() throws Exception {\n+        var recorder = new LinkedList<String>();\n+        getGlobalContext().register(new MockResource(recorder, null, \"regular1\"));\n+        getGlobalContext().register(new ThrowingResource(recorder, null, \"throwing1\"));\n+        getGlobalContext().register(new MockResource(recorder, null, \"regular2\"));\n+        getJDKContext().register(new MockResource(recorder, JDKResource.Priority.NORMAL, \"jdk1\"));\n+        getJDKContext().register(new ThrowingResource(recorder, JDKResource.Priority.EPOLLSELECTOR, \"throwing2\"));\n+        getJDKContext().register(new MockResource(recorder, JDKResource.Priority.SECURE_RANDOM, \"jdk2\"));\n+\n+        try {\n+            Core.checkpointRestore();\n+            fail(\"Expected to throw CheckpointException\");\n+        } catch (CheckpointException e) {\n+            assertEquals(4, e.getSuppressed().length);\n+        }\n+        assertEquals(\"regular2-before\", recorder.poll());\n+        assertEquals(\"throwing1-before\", recorder.poll());\n+        assertEquals(\"regular1-before\", recorder.poll());\n+        assertEquals(\"jdk1-before\", recorder.poll());\n+        assertEquals(\"throwing2-before\", recorder.poll());\n+        assertEquals(\"jdk2-before\", recorder.poll());\n+\n+        assertEquals(\"jdk2-after\", recorder.poll());\n+        assertEquals(\"throwing2-after\", recorder.poll());\n+        assertEquals(\"jdk1-after\", recorder.poll());\n+        assertEquals(\"regular1-after\", recorder.poll());\n+        assertEquals(\"throwing1-after\", recorder.poll());\n+        assertEquals(\"regular2-after\", recorder.poll());\n+        assertNull(recorder.poll());\n+\n+        rememberMe.clear();\n+        System.gc();\n+    }\n+\n+    \/\/ Similar to the test above but registers in context that is already done\n+    \/\/ rather than iterating through now. Also shows that registration adds\n+    \/\/ the resource to the context for the second attempt.\n+    private static void testRegisterToCompleted() throws Exception {\n+        var recorder = new LinkedList<String>();\n+\n+        OrderedContext<Resource> c1 = new OrderedContext<>();\n+        OrderedContext<Resource> c2 = new OrderedContext<>();\n+        getGlobalContext().register(c1);\n+        getGlobalContext().register(c2);\n+        c2.register(new MockResource(recorder, null, \"first\"));\n+        c1.register(new CreatingResource<>(recorder, null, \"second\", c2, null));\n+\n+        try {\n+            Core.checkpointRestore();\n+            fail(\"Expected checkpoint exception\");\n+        } catch (CheckpointException e) {\n+            e.printStackTrace();\n+            assertEquals(1, e.getSuppressed().length);\n+        } finally {\n+            getGlobalContext().afterRestore(null);\n+        }\n+        recorder.clear();\n+        \/\/ second time we should succeed\n+        Core.checkpointRestore();\n+        assertEquals(\"second-child2-before\", recorder.poll());\n+        assertEquals(\"second-child1-before\", recorder.poll());\n+        assertEquals(\"first-before\", recorder.poll());\n+        assertEquals(\"second-before\", recorder.poll());\n+\n+        assertEquals(\"second-after\", recorder.poll());\n+        assertEquals(\"first-after\", recorder.poll());\n+        assertEquals(\"second-child1-after\", recorder.poll());\n+        assertEquals(\"second-child2-after\", recorder.poll());\n+        assertNull(recorder.poll());\n+    }\n+\n+\n+    private static class MockResource implements JDKResource {\n+        protected final List<String> recorder;\n+        protected final Priority priority;\n+        protected final String id;\n+\n+        private MockResource(List<String> recorder, Priority priority, String id) {\n+            rememberMe.add(this);\n+            this.recorder = recorder;\n+            this.priority = priority;\n+            this.id = id;\n+        }\n+\n+        @Override\n+        public Priority getPriority() {\n+            return priority;\n+        }\n+\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) {\n+            ensureJDKContext(context);\n+            recorder.add(id + \"-before\");\n+        }\n+\n+        @Override\n+        public void afterRestore(Context<? extends Resource> context) {\n+            ensureJDKContext(context);\n+            recorder.add(id + \"-after\");\n+        }\n+\n+        private void ensureJDKContext(Context<? extends Resource> context) {\n+            if (priority != null && context != getJDKContext()) {\n+                throw new AssertionError(context.toString());\n+            }\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return getClass().getSimpleName() + \":\" + id;\n+        }\n+    }\n+\n+    \/\/ While normally resources should not directly register other resources it is possible\n+    \/\/ that running it will trigger (static) initialization of a class and that registers\n+    \/\/ a new resource. It is not legal to register a user resource, but for JDK resources\n+    \/\/ we can make an exception since it does not conflict with the general order (JDK resources\n+    \/\/ are notified after user resources).\n+    private static class CreatingResource<R extends Resource> extends MockResource {\n+        private final Priority childPriority;\n+        private final Context<R> childContext;\n+        private boolean first = true;\n+\n+        private CreatingResource(List<String> recorder, Priority priority, String id, Context<R> childContext, Priority childPriority) {\n+            super(recorder, priority, id);\n+            this.childContext = childContext;\n+            this.childPriority = childPriority;\n+        }\n+\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) {\n+            super.beforeCheckpoint(context);\n+            if (first) {\n+                \/\/noinspection unchecked\n+                childContext.register((R) new MockResource(recorder, childPriority, id + \"-child1\"));\n+            }\n+        }\n+\n+        @Override\n+        public void afterRestore(Context<? extends Resource> context) {\n+            super.afterRestore(context);\n+            if (first) {\n+                \/\/noinspection unchecked\n+                childContext.register((R) new MockResource(recorder, childPriority, id + \"-child2\"));\n+            }\n+            first = false;\n+        }\n+    }\n+\n+    private static class ThrowingResource extends MockResource {\n+        private ThrowingResource(List<String> recorder, Priority priority, String id) {\n+            super(recorder, priority, id);\n+        }\n+\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) {\n+            super.beforeCheckpoint(context);\n+            throw new RuntimeException(id + \"-before\");\n+        }\n+\n+        @Override\n+        public void afterRestore(Context<? extends Resource> context) {\n+            super.afterRestore(context);\n+            throw new RuntimeException(id + \"-after\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/ContextOrderTest.java","additions":282,"deletions":0,"binary":false,"changes":282,"status":"added"},{"patch":"@@ -25,0 +25,1 @@\n+import jdk.test.lib.Utils;\n@@ -39,0 +40,1 @@\n+                .javaOption(\"java.util.logging.config.file\", Utils.TEST_SRC + \"\/logging.properties\")\n@@ -41,1 +43,1 @@\n-                .outputAnalyzer().shouldContain(\"jdk.crac beforeCheckpoint\");\n+                .outputAnalyzer().shouldContain(\"beforeCheckpoint LazyProps\");\n@@ -54,1 +56,0 @@\n-        System.setProperty(\"jdk.crac.debug\", \"true\");\n","filename":"test\/jdk\/jdk\/crac\/LazyProps.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,114 +0,0 @@\n-\/\/ Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n-\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-\/\/\n-\/\/ This code is free software; you can redistribute it and\/or modify it under\n-\/\/ the terms of the GNU General Public License version 2 only, as published by\n-\/\/ the Free Software Foundation.\n-\/\/\n-\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n-\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n-\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n-\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n-\/\/\n-\/\/ You should have received a copy of the GNU General Public License version 2\n-\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n-\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-\/\/\n-\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n-\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n-\/\/ have any questions.\n-\n-package jdk.test.jdk.crac;\n-\n-import jdk.crac.*;\n-\n-\/**\n- * @test\n- * @compile ResourceTest.java\n- *\/\n-public class ResourceTest {\n-    static class CRResource implements Resource {\n-        String id;\n-        boolean[] throwCond;\n-        int nCalls = 0;\n-        CRResource(String id, boolean... throwCond) {\n-            this.id = id;\n-            this.throwCond = throwCond;\n-        }\n-\n-        void maybeException(String callId) throws Exception {\n-            boolean t = nCalls < throwCond.length ? throwCond[nCalls] : throwCond[throwCond.length - 1];\n-            System.out.println(id + \" \" + callId + \"(\" + nCalls + \") throw? \" + t);\n-            ++nCalls;\n-            if (t) {\n-                throw new RuntimeException(id);\n-            }\n-        }\n-\n-        @Override\n-        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n-            maybeException(\"beforeCheckpoint\");\n-        }\n-\n-        @Override\n-        public void afterRestore(Context<? extends Resource> context) throws Exception {\n-            maybeException(\"afterRestore\");\n-        }\n-    }\n-\n-    static class SingleContext extends Context<Resource> {\n-        private Resource r;\n-\n-        @Override\n-        public void beforeCheckpoint(Context<? extends Resource> context) throws CheckpointException {\n-            try {\n-                r.beforeCheckpoint(this);\n-            } catch (Exception e) {\n-                CheckpointException newException = new CheckpointException();\n-                newException.addSuppressed(e);\n-                throw newException;\n-            }\n-        }\n-\n-        @Override\n-        public void afterRestore(Context<? extends Resource> context) throws RestoreException {\n-            try {\n-                r.afterRestore(this);\n-            } catch (Exception e) {\n-                RestoreException newException = new RestoreException();\n-                newException.addSuppressed(e);\n-                throw newException;\n-            }\n-\n-        }\n-\n-        @Override\n-        public void register(Resource r) {\n-            this.r = r;\n-        }\n-\n-        public SingleContext(Resource r) {\n-            register(r);\n-        }\n-    }\n-\n-    static public void main(String[] args) throws Exception {\n-        Core.getGlobalContext().register(\n-            new CRResource(\"One\", true, false));\n-        Core.getGlobalContext().register(\n-            new SingleContext(\n-                new CRResource(\"Two\", false, true, false, true)));\n-        \/\/System.gc();\n-        int tries = 2;\n-        for (int i = 0; i < 2; ++i) {\n-            try {\n-                jdk.crac.Core.checkpointRestore();\n-            } catch (CheckpointException e) {\n-                e.printStackTrace();\n-            } catch (RestoreException e) {\n-                e.printStackTrace();\n-            }\n-        }\n-        System.out.println(\"DONE\");\n-    }\n-}\n","filename":"test\/jdk\/jdk\/crac\/ResourceTest.java","additions":0,"deletions":114,"binary":false,"changes":114,"status":"deleted"},{"patch":"@@ -0,0 +1,4 @@\n+handlers = java.util.logging.ConsoleHandler\n+.level = ALL\n+java.util.logging.ConsoleHandler.level = FINE\n+java.util.logging.SimpleFormatter.format=%1$tH:%1$tM:%1$tS %4$s [%3$s] %5$s%6$s%n\n\\ No newline at end of file\n","filename":"test\/jdk\/jdk\/crac\/logging.properties","additions":4,"deletions":0,"binary":false,"changes":4,"status":"added"},{"patch":"@@ -34,0 +34,1 @@\n+    final Map<String, String> javaOptions = new HashMap<>();\n@@ -102,0 +103,5 @@\n+    public CracBuilder javaOption(String name, String value) {\n+        javaOptions.put(name, value);\n+        return this;\n+    }\n+\n@@ -308,0 +314,1 @@\n+            cmd.add(\"-XX:+UnlockExperimentalVMOptions\");\n@@ -310,0 +317,3 @@\n+        for (var entry : javaOptions.entrySet()) {\n+            cmd.add(\"-D\" + entry.getKey() + \"=\" + entry.getValue());\n+        }\n","filename":"test\/lib\/jdk\/test\/lib\/crac\/CracBuilder.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"}]}