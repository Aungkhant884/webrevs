{"files":[{"patch":"@@ -40,1 +40,1 @@\n-    private static final Context<Resource> globalContext = new ContextWrapper(new OrderedContext());\n+    private static final Context<Resource> globalContext = new ContextWrapper(new OrderedContext<>(\"Global Context (javax)\"));\n","filename":"src\/java.base\/share\/classes\/javax\/crac\/Core.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-    private static final Context<Resource> globalContext = new OrderedContext();\n+    private static final Context<Resource> globalContext = new OrderedContext<>(\"GlobalContext\");\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/Core.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,5 +25,2 @@\n-import jdk.crac.CheckpointException;\n-import jdk.crac.Context;\n-import jdk.crac.Resource;\n-import jdk.crac.RestoreException;\n-import sun.security.action.GetBooleanAction;\n+import jdk.crac.*;\n+import jdk.internal.crac.LoggerContainer;\n@@ -31,2 +28,3 @@\n-import java.util.*;\n-import java.util.stream.Collectors;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n@@ -34,1 +32,4 @@\n-public abstract class AbstractContextImpl<R extends Resource, P> extends Context<R> {\n+public abstract class AbstractContextImpl<R extends Resource> extends Context<R> {\n+    private List<Resource> restoreQ = null;\n+    private CheckpointException checkpointException = null;\n+    private RestoreException restoreException = null;\n@@ -36,3 +37,13 @@\n-    private static class FlagsHolder {\n-        public static final boolean DEBUG =\n-            GetBooleanAction.privilegedGetProperty(\"jdk.crac.debug\");\n+    protected void invokeBeforeCheckpoint(Resource resource) {\n+        LoggerContainer.debug(\"beforeCheckpoint {0}\", resource);\n+        recordResource(resource);\n+        try {\n+            resource.beforeCheckpoint(this);\n+        } catch (CheckpointException e) {\n+            handleCheckpointException(e);\n+        } catch (Exception e) {\n+            if (e instanceof InterruptedException) {\n+                Thread.currentThread().interrupt();\n+            }\n+            ensureCheckpointException().addSuppressed(e);\n+        }\n@@ -41,3 +52,9 @@\n-    private WeakHashMap<R, P> checkpointQ = new WeakHashMap<>();\n-    private List<R> restoreQ = null;\n-    private Comparator<Map.Entry<R, P>> comparator;\n+    protected void handleCheckpointException(CheckpointException e) {\n+        CheckpointException ce = ensureCheckpointException();\n+        for (Throwable t : e.getSuppressed()) {\n+            ce.addSuppressed(t);\n+        }\n+        if (e.getMessage() != null) {\n+            ce.addSuppressed(e);\n+        }\n+    }\n@@ -45,2 +62,5 @@\n-    protected AbstractContextImpl(Comparator<Map.Entry<R, P>> comparator) {\n-        this.comparator = comparator;\n+    protected CheckpointException ensureCheckpointException() {\n+        if (checkpointException == null) {\n+            checkpointException = new CheckpointException();\n+        }\n+        return checkpointException;\n@@ -49,2 +69,3 @@\n-    protected synchronized void register(R resource, P payload) {\n-        checkpointQ.put(resource, payload);\n+    protected void recordResource(Resource resource) {\n+        \/\/ Resource.afterRestore is invoked even if Resource.beforeCheckpoint fails\n+        restoreQ.add(resource);\n@@ -54,20 +75,12 @@\n-    public synchronized void beforeCheckpoint(Context<? extends Resource> context) throws CheckpointException {\n-        List<R> resources = checkpointQ.entrySet().stream()\n-            .sorted(comparator)\n-            .map(Map.Entry::getKey)\n-            .collect(Collectors.toList());\n-\n-        CheckpointException exception = new CheckpointException();\n-        for (Resource r : resources) {\n-            if (FlagsHolder.DEBUG) {\n-                System.err.println(\"jdk.crac beforeCheckpoint \" + r.toString());\n-            }\n-            try {\n-                r.beforeCheckpoint(this);\n-            } catch (CheckpointException e) {\n-                for (Throwable t : e.getSuppressed()) {\n-                    exception.addSuppressed(t);\n-                }\n-            } catch (Exception e) {\n-                exception.addSuppressed(e);\n-            }\n+    public void beforeCheckpoint(Context<? extends Resource> context) throws CheckpointException {\n+        \/\/ We won't synchronize access to restoreQ because methods\n+        \/\/ beforeCheckpoint and afterRestore should be invoked only\n+        \/\/ by the single thread performing the C\/R and other threads should\n+        \/\/ not touch that.\n+        restoreQ = new ArrayList<>();\n+        runBeforeCheckpoint();\n+        Collections.reverse(restoreQ);\n+        if (checkpointException != null) {\n+            CheckpointException ce = checkpointException;\n+            checkpointException = null;\n+            throw ce;\n@@ -75,0 +88,1 @@\n+    }\n@@ -76,5 +90,18 @@\n-        Collections.reverse(resources);\n-        restoreQ = resources;\n-\n-        if (0 < exception.getSuppressed().length) {\n-            throw exception;\n+    \/\/ This method has particularly verbose name to stick out in thread dumps\n+    \/\/ when the registration leads to a deadlock.\n+    protected void waitWhileCheckpointIsInProgress(R resource) {\n+        if (Thread.currentThread().isInterrupted()) {\n+            LoggerContainer.debug(Thread.currentThread().getName() + \" not waiting in \" + this +\n+                    \" to register \" + resource + \"; the thread has already been interrupted.\");\n+            \/\/ We won't cause IllegalStateException because this is not an unexpected state\n+            \/\/ from the point of CRaC - it probably tried to register some code before.\n+            throw new RuntimeException(\"Interrupted thread tried to block in registration of \" + resource + \" in \" + this);\n+        }\n+        LoggerContainer.debug(Thread.currentThread().getName() + \" waiting in \" + this + \" to register \" + resource);\n+        try {\n+            wait();\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+            LoggerContainer.debug(Thread.currentThread().getName() + \" interrupted waiting in \" + this +\n+                    \" to register \" + resource);\n+            throw new RuntimeException(\"Interrupted while trying to register \" + resource + \" in \" + this, e);\n@@ -84,0 +111,2 @@\n+    protected abstract void runBeforeCheckpoint();\n+\n@@ -85,15 +114,4 @@\n-    public synchronized void afterRestore(Context<? extends Resource> context) throws RestoreException {\n-        RestoreException exception = new RestoreException();\n-        for (Resource r : restoreQ) {\n-            if (FlagsHolder.DEBUG) {\n-                System.err.println(\"jdk.crac afterRestore \" + r.toString());\n-            }\n-            try {\n-                r.afterRestore(this);\n-            } catch (RestoreException e) {\n-                for (Throwable t : e.getSuppressed()) {\n-                    exception.addSuppressed(t);\n-                }\n-            } catch (Exception e) {\n-                exception.addSuppressed(e);\n-            }\n+    public void afterRestore(Context<? extends Resource> context) throws RestoreException {\n+        List<Resource> queue = restoreQ;\n+        if (queue == null) {\n+            return;\n@@ -102,0 +120,9 @@\n+        for (Resource r : queue) {\n+            invokeAfterRestore(r);\n+        }\n+        if (restoreException != null) {\n+            RestoreException re = restoreException;\n+            restoreException = null;\n+            throw re;\n+        }\n+    }\n@@ -103,2 +130,14 @@\n-        if (0 < exception.getSuppressed().length) {\n-            throw exception;\n+    protected void invokeAfterRestore(Resource resource) {\n+        LoggerContainer.debug(\"afterRestore {0}\", resource);\n+        try {\n+            resource.afterRestore(this);\n+        } catch (RestoreException e) {\n+            \/\/ Print error early in case the restore process gets stuck\n+            LoggerContainer.error(e, \"Failed to restore \" + resource);\n+            handleRestoreException(e);\n+        } catch (Exception e) {\n+            if (e instanceof InterruptedException) {\n+                Thread.currentThread().interrupt();\n+            }\n+            LoggerContainer.error(e, \"Failed to restore \" + resource);\n+            ensureRestoreException().addSuppressed(e);\n@@ -107,0 +146,18 @@\n+\n+    protected void handleRestoreException(RestoreException e) {\n+        RestoreException re = ensureRestoreException();\n+        for (Throwable t : e.getSuppressed()) {\n+            re.addSuppressed(t);\n+        }\n+        if (e.getMessage() != null) {\n+            re.addSuppressed(e);\n+        }\n+    }\n+\n+    protected RestoreException ensureRestoreException() {\n+        if (restoreException == null) {\n+            restoreException = new RestoreException();\n+        }\n+        return restoreException;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/impl\/AbstractContextImpl.java","additions":117,"deletions":60,"binary":false,"changes":177,"status":"modified"},{"patch":"@@ -29,2 +29,1 @@\n-import jdk.crac.Resource;\n-import jdk.crac.impl.AbstractContextImpl;\n+import jdk.crac.*;\n@@ -32,1 +31,2 @@\n-import java.util.Comparator;\n+import java.util.Collections;\n+import java.util.List;\n@@ -34,0 +34,1 @@\n+import java.util.WeakHashMap;\n@@ -35,2 +36,5 @@\n-public class OrderedContext extends AbstractContextImpl<Resource, Long> {\n-    private long order;\n+public class OrderedContext<R extends Resource> extends AbstractContextImpl<R> {\n+    private final String name;\n+    private boolean checkpointing = false;\n+    protected long order = 0;\n+    protected final WeakHashMap<R, Long> resources = new WeakHashMap<>();\n@@ -38,4 +42,13 @@\n-    static class ContextComparator implements Comparator<Map.Entry<Resource, Long>> {\n-        @Override\n-        public int compare(Map.Entry<Resource, Long> o1, Map.Entry<Resource, Long> o2) {\n-            return (int)(o2.getValue() - o1.getValue());\n+    public OrderedContext(String name) {\n+        this.name = name;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return name != null ? name : super.toString();\n+    }\n+\n+    @Override\n+    public synchronized void register(R resource) {\n+        while (checkpointing) {\n+            waitWhileCheckpointIsInProgress(resource);\n@@ -43,0 +56,1 @@\n+        resources.put(resource, order++);\n@@ -45,2 +59,13 @@\n-    public OrderedContext() {\n-        super(new ContextComparator());\n+    @Override\n+    protected void runBeforeCheckpoint() {\n+        List<R> resources;\n+        synchronized (this) {\n+            checkpointing = true;\n+            resources = this.resources.entrySet().stream()\n+                    .sorted(Collections.reverseOrder(Map.Entry.comparingByValue()))\n+                    .map(Map.Entry::getKey)\n+                    .toList();\n+        }\n+        for (R r : resources) {\n+            invokeBeforeCheckpoint(r);\n+        }\n@@ -50,2 +75,6 @@\n-    public synchronized void register(Resource r) {\n-        register(r, order++);\n+    public void afterRestore(Context<? extends Resource> context) throws RestoreException {\n+        synchronized (this) {\n+            checkpointing = false;\n+            notifyAll();\n+        }\n+        super.afterRestore(context);\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/impl\/OrderedContext.java","additions":42,"deletions":13,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -0,0 +1,138 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.crac.impl;\n+\n+import jdk.crac.*;\n+import jdk.internal.crac.LoggerContainer;\n+\n+import java.util.*;\n+\n+public abstract class PriorityContext<P, R extends Resource> extends AbstractContextImpl<R> {\n+    private final TreeMap<P, SubContext> categories;\n+    private final Comparator<P> comparator;\n+    private P lastPriority = null;\n+\n+    protected PriorityContext(Comparator<P> comparator) {\n+        this.categories = new TreeMap<>(comparator);\n+        this.comparator = comparator;\n+    }\n+\n+    protected synchronized void register(R resource, P priority) {\n+        while (lastPriority != null && comparator.compare(lastPriority, priority) >= 0) {\n+            waitWhileCheckpointIsInProgress(resource);\n+        }\n+        \/\/ computeIfAbsent does not work well here with lambda\n+        SubContext category = categories.get(priority);\n+        if (category == null) {\n+            category = new SubContext(getClass().getSimpleName() + \"[\" + priority + \"]\");\n+            categories.put(priority, category);\n+        }\n+        category.registerInSub(resource);\n+    }\n+\n+    @Override\n+    protected void runBeforeCheckpoint() {\n+        Map.Entry<P, SubContext> entry;\n+        \/\/ We will use fine-grained synchronization to allow registration for higher category\n+        \/\/ in another thread.\n+        synchronized (this) {\n+            if (categories.isEmpty()) {\n+                return;\n+            }\n+            \/\/ This type of iteration should be O(N*log(N)), same as sorting, and does not suffer\n+            \/\/ from concurrent modifications. We'll track modifications for lower priorities in register()\n+            entry = categories.firstEntry();\n+            lastPriority = entry.getKey();\n+        }\n+        for (;;) {\n+            invokeBeforeCheckpoint(entry.getValue());\n+            synchronized (this) {\n+                entry = categories.higherEntry(entry.getKey());\n+                if (entry != null) {\n+                    lastPriority = entry.getKey();\n+                } else {\n+                    return;\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void afterRestore(Context<? extends Resource> context) throws RestoreException {\n+        synchronized (this) {\n+            lastPriority = null;\n+            notifyAll();\n+        }\n+        super.afterRestore(context);\n+    }\n+\n+    public class SubContext extends OrderedContext<R> {\n+        public SubContext(String name) {\n+            super(name);\n+        }\n+\n+        synchronized void registerInSub(R r) {\n+            resources.put(r, order++);\n+        }\n+\n+        \/\/ This method differs from the super method only by the\n+        \/\/ parameter to the beforeCheckpoint method\n+        @Override\n+        protected void invokeBeforeCheckpoint(Resource resource) {\n+            LoggerContainer.debug(\"beforeCheckpoint {0}\", resource);\n+            recordResource(resource);\n+            try {\n+                resource.beforeCheckpoint(PriorityContext.this);\n+            } catch (CheckpointException e) {\n+                handleCheckpointException(e);\n+            } catch (Exception e) {\n+                if (e instanceof InterruptedException) {\n+                    Thread.currentThread().interrupt();\n+                }\n+                ensureCheckpointException().addSuppressed(e);\n+            }\n+        }\n+\n+        \/\/ This method differs from the super method only by the\n+        \/\/ parameter to the afterRestore method\n+        @Override\n+        protected void invokeAfterRestore(Resource resource) {\n+            LoggerContainer.debug(\"afterRestore {0}\", resource);\n+            try {\n+                resource.afterRestore(PriorityContext.this);\n+            } catch (RestoreException e) {\n+                \/\/ Print error early in case the restore process gets stuck\n+                LoggerContainer.error(e, \"Failed to restore \" + resource);\n+                handleRestoreException(e);\n+            } catch (Exception e) {\n+                if (e instanceof InterruptedException) {\n+                    Thread.currentThread().interrupt();\n+                }\n+                LoggerContainer.error(e, \"Failed to restore \" + resource);\n+                ensureRestoreException().addSuppressed(e);\n+            }\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/impl\/PriorityContext.java","additions":138,"deletions":0,"binary":false,"changes":138,"status":"added"},{"patch":"@@ -29,1 +29,1 @@\n-import jdk.crac.impl.AbstractContextImpl;\n+import jdk.crac.impl.PriorityContext;\n@@ -32,1 +32,0 @@\n-import java.util.Map;\n@@ -34,2 +33,3 @@\n-public class JDKContext extends AbstractContextImpl<JDKResource, Void> {\n-    static class ContextComparator implements Comparator<Map.Entry<JDKResource, Void>> {\n+public class JDKContext extends PriorityContext<JDKResource.Priority, JDKResource> {\n+    \/\/ We cannot use method references\/lambdas when the context is created\n+    public static final Comparator<JDKResource.Priority> PRIORITY_COMPARATOR = new Comparator<>() {\n@@ -37,2 +37,2 @@\n-        public int compare(Map.Entry<JDKResource, Void> o1, Map.Entry<JDKResource, Void> o2) {\n-            return o1.getKey().getPriority().compareTo(o2.getKey().getPriority());\n+        public int compare(JDKResource.Priority p1, JDKResource.Priority p2) {\n+            return p1.compareTo(p2);\n@@ -40,1 +40,1 @@\n-    }\n+    };\n@@ -43,1 +43,1 @@\n-        super(new ContextComparator());\n+        super(PRIORITY_COMPARATOR);\n@@ -48,1 +48,1 @@\n-        register(resource, null);\n+        register(resource, resource.getPriority());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/JDKContext.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -0,0 +1,29 @@\n+package jdk.internal.crac;\n+\n+\/**\n+ * Some classes that could use logging are initialized early during the boot\n+ * and keeping the logger in static final field there could cause problems\n+ * (e.g. recursion when service-loading logger implementation).\n+ * Therefore, we isolate the logger into a subclass and initialize lazily.\n+ *\/\n+public class LoggerContainer {\n+    public static final System.Logger logger = System.getLogger(\"jdk.crac\");\n+\n+    public static void info(String msg) {\n+        logger.log(System.Logger.Level.INFO, msg);\n+    }\n+\n+    public static void debug(String fmt, Object... params) {\n+        logger.log(System.Logger.Level.DEBUG, fmt, params);\n+    }\n+\n+    private LoggerContainer() {}\n+\n+    public static void error(String msg) {\n+        logger.log(System.Logger.Level.ERROR, msg);\n+    }\n+\n+    public static void error(Throwable t, String msg) {\n+        logger.log(System.Logger.Level.ERROR, msg, t);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/LoggerContainer.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.crac.LoggerContainer;\n@@ -39,8 +40,0 @@\n-    \/\/ PersistentJarFile is <clinit>ed when loading classes on the module path;\n-    \/\/ when initializing the logger an implementation of logging is looked up through\n-    \/\/ service-loading and that causes a recursion in opening the module.\n-    \/\/ Therefore, we isolate the logger into a subclass and initialize only when needed.\n-    private static class LoggerContainer {\n-        private static final System.Logger logger = System.getLogger(\"jdk.crac\");\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/jar\/PersistentJarFile.java","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,340 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.*;\n+import jdk.crac.impl.OrderedContext;\n+import jdk.internal.crac.JDKResource;\n+import jdk.test.lib.Utils;\n+\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import static jdk.crac.Core.getGlobalContext;\n+import static jdk.internal.crac.Core.*;\n+import static jdk.internal.crac.JDKResource.Priority.*;\n+import static jdk.test.lib.Asserts.*;\n+\n+\/**\n+ * @test ContextOrderTest\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.crac:+open\n+ * @modules java.base\/jdk.crac.impl:+open\n+ * @run main\/othervm -ea -XX:CREngine=simengine -XX:CRaCCheckpointTo=ignored ContextOrderTest\n+ *\/\n+public class ContextOrderTest {\n+    \/\/ prevents GC releasing the resources\n+    private static final List<Resource> rememberMe = new ArrayList<>();\n+\n+    public static void main(String[] args) throws Exception {\n+        System.setProperty(\"java.util.logging.config.file\", Utils.TEST_SRC + \"\/logging.properties\");\n+\n+        testOrder();\n+        testRegisterBlocks();\n+        testThrowing();\n+        testRegisterToCompleted();\n+        testRegisterFromOtherThread();\n+    }\n+\n+    private static void testOrder() throws Exception {\n+        var recorder = new LinkedList<String>();\n+        getGlobalContext().register(new MockResource(recorder, null, \"regular1\"));\n+        getJDKContext().register(new MockResource(recorder, NORMAL, \"jdk-normal\"));\n+        getJDKContext().register(new MockResource(recorder, SECURE_RANDOM, \"jdk-later\"));\n+        getGlobalContext().register(new CreatingResource<>(recorder, null, \"regular2\", getJDKContext(), NORMAL));\n+        \/\/ this child should run as it has higher priority\n+        getJDKContext().register(new CreatingResource<>(recorder, NORMAL, \"jdk-create\", getJDKContext(), SEEDER_HOLDER));\n+\n+        Core.checkpointRestore();\n+\n+        assertEquals(\"regular2-before\", recorder.poll());\n+        assertEquals(\"regular1-before\", recorder.poll());\n+\n+        assertEquals(\"regular2-child1-before\", recorder.poll());\n+        assertEquals(\"jdk-create-before\", recorder.poll());\n+        assertEquals(\"jdk-normal-before\", recorder.poll());\n+\n+        assertEquals(\"jdk-later-before\", recorder.poll());\n+        assertEquals(\"jdk-create-child1-before\", recorder.poll());\n+        \/\/ restore\n+        assertEquals(\"jdk-create-child1-after\", recorder.poll());\n+        assertEquals(\"jdk-later-after\", recorder.poll());\n+\n+        assertEquals(\"jdk-normal-after\", recorder.poll());\n+        assertEquals(\"jdk-create-after\", recorder.poll());\n+        assertEquals(\"regular2-child1-after\", recorder.poll());\n+\n+        assertEquals(\"regular1-after\", recorder.poll());\n+        assertEquals(\"regular2-after\", recorder.poll());\n+        assertNull(recorder.poll());\n+\n+        \/\/ second checkpoint - whatever was registered in first afterRestore is now notified\n+        Core.checkpointRestore();\n+        assertTrue(recorder.stream().anyMatch(\"jdk-create-child2-before\"::equals));\n+        assertTrue(recorder.stream().anyMatch(\"regular2-child2-before\"::equals));\n+\n+        rememberMe.clear();\n+        System.gc();\n+    }\n+\n+    private static void testRegisterBlocks() throws Exception {\n+        var recorder = new LinkedList<String>();\n+        \/\/ blocks register into the same OrderedContext\n+        getGlobalContext().register(new CreatingResource<>(recorder, null, \"regular\",\n+                getGlobalContext(), null));\n+        testWaiting();\n+\n+        \/\/ blocks registering with lower priority\n+        getJDKContext().register(new CreatingResource<>(recorder, SECURE_RANDOM, \"jdk-lower\",\n+                getJDKContext(), NORMAL));\n+        testWaiting();\n+\n+        \/\/ blocks registering with the same priority\n+        getJDKContext().register(new CreatingResource<>(recorder, NORMAL, \"jdk-same\",\n+                getJDKContext(), NORMAL));\n+        testWaiting();\n+    }\n+\n+    private static void testWaiting() throws InterruptedException {\n+        AtomicReference<Throwable> exceptionHolder = new AtomicReference<>();\n+        assertWaits(() -> {\n+            try {\n+                Core.checkpointRestore();\n+            } catch (Exception e) {\n+                assertTrue(Thread.currentThread().isInterrupted());\n+                exceptionHolder.set(e);\n+            }\n+        }, \"AbstractContextImpl\", \"waitWhileCheckpointIsInProgress\");\n+        assertNotNull(exceptionHolder.get());\n+        exceptionHolder.get().printStackTrace();\n+        rememberMe.clear();\n+        System.gc();\n+    }\n+\n+    private static void assertWaits(Runnable runnable, String cls, String method) throws InterruptedException {\n+        Thread thread = new Thread(runnable);\n+        thread.start();\n+        long deadline = System.nanoTime() + TimeUnit.SECONDS.toNanos(10);\n+        for (;;) {\n+            if (thread.getState() == Thread.State.WAITING) {\n+                for (var ste : thread.getStackTrace()) {\n+                    if ((cls == null || cls.equals(ste.getClassName()) || ste.getClassName().endsWith(\".\" + cls)) &&\n+                            (method == null || method.equals(ste.getMethodName()))) {\n+                        \/\/ It should be sufficient to interrupt the code once; if any Resource\n+                        \/\/ clears the flag without rethrowing it is a bug.\n+                        thread.interrupt();\n+                        thread.join(TimeUnit.NANOSECONDS.toMillis(deadline - System.nanoTime()));\n+                        assertFalse(thread.isAlive());\n+                        return;\n+                    }\n+                }\n+            } else if (thread.getState() == Thread.State.TERMINATED) {\n+                fail(\"Thread completed without waiting\");\n+            }\n+            if (System.nanoTime() < deadline) {\n+                \/\/noinspection BusyWait\n+                Thread.sleep(50);\n+            } else {\n+                fail(\"Timed out waiting for thread to get waiting in \" + cls + \".\" + method);\n+            }\n+        }\n+    }\n+\n+    private static void testThrowing() throws Exception {\n+        var recorder = new LinkedList<String>();\n+        getGlobalContext().register(new MockResource(recorder, null, \"regular1\"));\n+        getGlobalContext().register(new ThrowingResource(recorder, null, \"throwing1\"));\n+        getGlobalContext().register(new MockResource(recorder, null, \"regular2\"));\n+        getJDKContext().register(new MockResource(recorder, NORMAL, \"jdk1\"));\n+        getJDKContext().register(new ThrowingResource(recorder, JDKResource.Priority.EPOLLSELECTOR, \"throwing2\"));\n+        getJDKContext().register(new MockResource(recorder, SECURE_RANDOM, \"jdk2\"));\n+\n+        try {\n+            Core.checkpointRestore();\n+            fail(\"Expected to throw CheckpointException\");\n+        } catch (CheckpointException e) {\n+            assertEquals(4, e.getSuppressed().length);\n+        }\n+        assertEquals(\"regular2-before\", recorder.poll());\n+        assertEquals(\"throwing1-before\", recorder.poll());\n+        assertEquals(\"regular1-before\", recorder.poll());\n+        assertEquals(\"jdk1-before\", recorder.poll());\n+        assertEquals(\"throwing2-before\", recorder.poll());\n+        assertEquals(\"jdk2-before\", recorder.poll());\n+\n+        assertEquals(\"jdk2-after\", recorder.poll());\n+        assertEquals(\"throwing2-after\", recorder.poll());\n+        assertEquals(\"jdk1-after\", recorder.poll());\n+        assertEquals(\"regular1-after\", recorder.poll());\n+        assertEquals(\"throwing1-after\", recorder.poll());\n+        assertEquals(\"regular2-after\", recorder.poll());\n+        assertNull(recorder.poll());\n+\n+        rememberMe.clear();\n+        System.gc();\n+    }\n+\n+    \/\/ Similar to the test above but registers in context that is already done\n+    \/\/ rather than iterating through now.\n+    private static void testRegisterToCompleted() throws Exception {\n+        var recorder = new LinkedList<String>();\n+\n+        OrderedContext<Resource> c1 = new OrderedContext<>(\"C1\");\n+        OrderedContext<Resource> c2 = new OrderedContext<>(\"C2\");\n+        getGlobalContext().register(c1);\n+        getGlobalContext().register(c2);\n+        c2.register(new MockResource(recorder, null, \"first\"));\n+        \/\/ Logically there's nothing that prevents to register into C2 during C1.<resource>.afterRestore\n+        \/\/ but the implementation of C1 does not know that we're already after C\/R and still blocks\n+        \/\/ any registrations.\n+        c1.register(new CreatingResource<>(recorder, null, \"second\", c2, null));\n+\n+        \/\/ This is supposed to end up with a deadlock. Even though it would block first\n+        \/\/ for -child1 and then for -child2 the first time we interrupt the thread it will\n+        \/\/ unblock and won't block any further.\n+        testWaiting();\n+\n+        \/\/ Since we have interrupted the registration no other resource was registered\n+        \/\/ so there's no point in testing anything here.\n+    }\n+\n+    \/\/ registering from lower priority resource to higher priority shouldn't block\n+    \/\/ even in another thread\n+    private static void testRegisterFromOtherThread() throws RestoreException, CheckpointException {\n+        var recorder = new LinkedList<String>();\n+        getJDKContext().register(new MockResource(recorder, NORMAL, \"normal\") {\n+            @Override\n+            public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+                super.beforeCheckpoint(context);\n+                Thread thread = new Thread(() -> {\n+                    getJDKContext().register(new MockResource(recorder, CLEANERS, \"child\"));\n+                }, \"registrar\");\n+                thread.start();\n+                thread.join();\n+            }\n+        });\n+\n+        Core.checkpointRestore();\n+        assertEquals(\"normal-before\", recorder.poll());\n+        assertEquals(\"child-before\", recorder.poll());\n+        assertEquals(\"child-after\", recorder.poll());\n+        assertEquals(\"normal-after\", recorder.poll());\n+    }\n+\n+    private static class MockResource implements JDKResource {\n+        protected final List<String> recorder;\n+        protected final Priority priority;\n+        protected final String id;\n+\n+        private MockResource(List<String> recorder, Priority priority, String id) {\n+            rememberMe.add(this);\n+            this.recorder = recorder;\n+            this.priority = priority;\n+            this.id = id;\n+        }\n+\n+        @Override\n+        public Priority getPriority() {\n+            return priority;\n+        }\n+\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+            ensureJDKContext(context);\n+            recorder.add(id + \"-before\");\n+        }\n+\n+        @Override\n+        public void afterRestore(Context<? extends Resource> context) throws Exception {\n+            ensureJDKContext(context);\n+            recorder.add(id + \"-after\");\n+        }\n+\n+        private void ensureJDKContext(Context<? extends Resource> context) {\n+            if (priority != null && context != getJDKContext()) {\n+                throw new AssertionError(id + \"expecting JDKContext, got \" + context.toString());\n+            }\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return getClass().getSimpleName() + \":\" + id;\n+        }\n+    }\n+\n+    \/\/ While normally resources should not directly register other resources it is possible\n+    \/\/ that running it will trigger (static) initialization of a class and that registers\n+    \/\/ a new resource. It is not legal to register a user resource, but for JDK resources\n+    \/\/ we can make an exception since it does not conflict with the general order (JDK resources\n+    \/\/ are notified after user resources).\n+    private static class CreatingResource<R extends Resource> extends MockResource {\n+        private final Priority childPriority;\n+        private final Context<R> childContext;\n+        private boolean first = true;\n+\n+        private CreatingResource(List<String> recorder, Priority priority, String id, Context<R> childContext, Priority childPriority) {\n+            super(recorder, priority, id);\n+            this.childContext = childContext;\n+            this.childPriority = childPriority;\n+        }\n+\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+            super.beforeCheckpoint(context);\n+            if (first) {\n+                \/\/noinspection unchecked\n+                childContext.register((R) new MockResource(recorder, childPriority, id + \"-child1\"));\n+            }\n+        }\n+\n+        @Override\n+        public void afterRestore(Context<? extends Resource> context) throws Exception {\n+            super.afterRestore(context);\n+            if (first) {\n+                \/\/noinspection unchecked\n+                childContext.register((R) new MockResource(recorder, childPriority, id + \"-child2\"));\n+            }\n+            first = false;\n+        }\n+    }\n+\n+    private static class ThrowingResource extends MockResource {\n+        private ThrowingResource(List<String> recorder, Priority priority, String id) {\n+            super(recorder, priority, id);\n+        }\n+\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+            super.beforeCheckpoint(context);\n+            throw new RuntimeException(id + \"-before\");\n+        }\n+\n+        @Override\n+        public void afterRestore(Context<? extends Resource> context) throws Exception {\n+            super.afterRestore(context);\n+            throw new RuntimeException(id + \"-after\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/ContextOrderTest.java","additions":340,"deletions":0,"binary":false,"changes":340,"status":"added"},{"patch":"@@ -1,57 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Azul Systems, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import jdk.crac.*;\n-import jdk.test.lib.crac.CracBuilder;\n-import jdk.test.lib.crac.CracEngine;\n-import jdk.test.lib.crac.CracTest;\n-\n-\/**\n- * @test\n- * @library \/test\/lib\n- * @build LazyProps\n- * @run driver jdk.test.lib.crac.CracTest\n- *\/\n-public class LazyProps implements CracTest {\n-    @Override\n-    public void test() throws Exception {\n-        new CracBuilder().engine(CracEngine.SIMULATE)\n-                .captureOutput(true)\n-                .startCheckpoint().waitForSuccess()\n-                .outputAnalyzer().shouldContain(\"jdk.crac beforeCheckpoint\");\n-    }\n-\n-    @Override\n-    public void exec() throws RestoreException, CheckpointException {\n-        Resource resource = new Resource() {\n-            @Override\n-            public void beforeCheckpoint(Context<? extends Resource> context) throws Exception { }\n-            @Override\n-            public void afterRestore(Context<? extends Resource> context) throws Exception { }\n-        };\n-        Core.getGlobalContext().register(resource);\n-\n-        System.setProperty(\"jdk.crac.debug\", \"true\");\n-        Core.checkpointRestore();\n-    }\n-}\n","filename":"test\/jdk\/jdk\/crac\/LazyProps.java","additions":0,"deletions":57,"binary":false,"changes":57,"status":"deleted"},{"patch":"@@ -1,114 +0,0 @@\n-\/\/ Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n-\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-\/\/\n-\/\/ This code is free software; you can redistribute it and\/or modify it under\n-\/\/ the terms of the GNU General Public License version 2 only, as published by\n-\/\/ the Free Software Foundation.\n-\/\/\n-\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n-\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n-\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n-\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n-\/\/\n-\/\/ You should have received a copy of the GNU General Public License version 2\n-\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n-\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-\/\/\n-\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n-\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n-\/\/ have any questions.\n-\n-package jdk.test.jdk.crac;\n-\n-import jdk.crac.*;\n-\n-\/**\n- * @test\n- * @compile ResourceTest.java\n- *\/\n-public class ResourceTest {\n-    static class CRResource implements Resource {\n-        String id;\n-        boolean[] throwCond;\n-        int nCalls = 0;\n-        CRResource(String id, boolean... throwCond) {\n-            this.id = id;\n-            this.throwCond = throwCond;\n-        }\n-\n-        void maybeException(String callId) throws Exception {\n-            boolean t = nCalls < throwCond.length ? throwCond[nCalls] : throwCond[throwCond.length - 1];\n-            System.out.println(id + \" \" + callId + \"(\" + nCalls + \") throw? \" + t);\n-            ++nCalls;\n-            if (t) {\n-                throw new RuntimeException(id);\n-            }\n-        }\n-\n-        @Override\n-        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n-            maybeException(\"beforeCheckpoint\");\n-        }\n-\n-        @Override\n-        public void afterRestore(Context<? extends Resource> context) throws Exception {\n-            maybeException(\"afterRestore\");\n-        }\n-    }\n-\n-    static class SingleContext extends Context<Resource> {\n-        private Resource r;\n-\n-        @Override\n-        public void beforeCheckpoint(Context<? extends Resource> context) throws CheckpointException {\n-            try {\n-                r.beforeCheckpoint(this);\n-            } catch (Exception e) {\n-                CheckpointException newException = new CheckpointException();\n-                newException.addSuppressed(e);\n-                throw newException;\n-            }\n-        }\n-\n-        @Override\n-        public void afterRestore(Context<? extends Resource> context) throws RestoreException {\n-            try {\n-                r.afterRestore(this);\n-            } catch (Exception e) {\n-                RestoreException newException = new RestoreException();\n-                newException.addSuppressed(e);\n-                throw newException;\n-            }\n-\n-        }\n-\n-        @Override\n-        public void register(Resource r) {\n-            this.r = r;\n-        }\n-\n-        public SingleContext(Resource r) {\n-            register(r);\n-        }\n-    }\n-\n-    static public void main(String[] args) throws Exception {\n-        Core.getGlobalContext().register(\n-            new CRResource(\"One\", true, false));\n-        Core.getGlobalContext().register(\n-            new SingleContext(\n-                new CRResource(\"Two\", false, true, false, true)));\n-        \/\/System.gc();\n-        int tries = 2;\n-        for (int i = 0; i < 2; ++i) {\n-            try {\n-                jdk.crac.Core.checkpointRestore();\n-            } catch (CheckpointException e) {\n-                e.printStackTrace();\n-            } catch (RestoreException e) {\n-                e.printStackTrace();\n-            }\n-        }\n-        System.out.println(\"DONE\");\n-    }\n-}\n","filename":"test\/jdk\/jdk\/crac\/ResourceTest.java","additions":0,"deletions":114,"binary":false,"changes":114,"status":"deleted"}]}