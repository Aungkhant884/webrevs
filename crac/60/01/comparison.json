{"files":[{"patch":"@@ -47,0 +47,5 @@\n+     * Order of invoking {@link Resource#beforeCheckpoint(Context)} is the reverse\n+     * of the order of {@link Context#register(Resource) registration}.\n+     * Order of invoking {@link Resource#afterRestore(Context)} is the reverse\n+     * of the order of {@link Resource#beforeCheckpoint(Context) checkpoint notification},\n+     * hence the same as the order of {@link Context#register(Resource) registration}.\n","filename":"src\/java.base\/share\/classes\/javax\/crac\/Core.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -40,0 +40,2 @@\n+     * The order of notification is subject to the {@link jdk.crac.Context} implementation,\n+     * e.g. for the global context see {@link Core#getGlobalContext()}.\n@@ -48,0 +50,2 @@\n+     * The order of notification is subject to the {@link jdk.crac.Context} implementation,\n+     * e.g. for the global context see {@link Core#getGlobalContext()}.\n","filename":"src\/java.base\/share\/classes\/javax\/crac\/Resource.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -106,0 +106,5 @@\n+     * Order of invoking {@link Resource#beforeCheckpoint(Context)} is the reverse\n+     * of the order of {@link Context#register(Resource) registration}.\n+     * Order of invoking {@link Resource#afterRestore(Context)} is the reverse\n+     * of the order of {@link Resource#beforeCheckpoint(Context) checkpoint notification},\n+     * hence the same as the order of {@link Context#register(Resource) registration}.\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/Core.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -40,0 +40,2 @@\n+     * The order of notification is subject to the {@link Context} implementation,\n+     * e.g. for the global context see {@link Core#getGlobalContext()}.\n@@ -48,0 +50,2 @@\n+     * The order of notification is subject to the {@link Context} implementation,\n+     * e.g. for the global context see {@link Core#getGlobalContext()}.\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/Resource.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -25,5 +25,2 @@\n-import jdk.crac.CheckpointException;\n-import jdk.crac.Context;\n-import jdk.crac.Resource;\n-import jdk.crac.RestoreException;\n-import sun.security.action.GetBooleanAction;\n+import jdk.crac.*;\n+import jdk.internal.crac.LoggerContainer;\n@@ -32,1 +29,2 @@\n-import java.util.stream.Collectors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.locks.ReentrantLock;\n@@ -34,8 +32,4 @@\n-public abstract class AbstractContextImpl<R extends Resource, P> extends Context<R> {\n-\n-    private static class FlagsHolder {\n-        public static final boolean DEBUG =\n-            GetBooleanAction.privilegedGetProperty(\"jdk.crac.debug\");\n-    }\n-\n-    private WeakHashMap<R, P> checkpointQ = new WeakHashMap<>();\n+public abstract class AbstractContextImpl<R extends Resource> extends Context<R> {\n+    private WeakHashMap<R, Long> resources = new WeakHashMap<>();\n+    \/\/ Queue content is temporary, so we won't mind that it's not a weak reference\n+    private Queue<Map.Entry<R, Long>> resourceQueue = new LinkedList<>();\n@@ -43,1 +37,7 @@\n-    private Comparator<Map.Entry<R, P>> comparator;\n+    private volatile long currentPriority = -1;\n+    \/\/ We use two locks: checkpointLock is required for both running the beforeCheckpoint\n+    \/\/ and registering a new resource, while restoreLock is required for running afterRestore\n+    \/\/ and beforeCheckpoint (to achieve exclusivity of before and after). It is fine\n+    \/\/ to acquire checkpointLock and register a new resource during afterRestore.\n+    private final ReentrantLock checkpointLock = new ReentrantLock();\n+    private final ReentrantLock restoreLock = new ReentrantLock();\n@@ -45,2 +45,23 @@\n-    protected AbstractContextImpl(Comparator<Map.Entry<R, P>> comparator) {\n-        this.comparator = comparator;\n+    protected void register(R resource, long priority) {\n+        assert priority >= 0;\n+        boolean locked = false;\n+        try {\n+            \/\/ We don't want to deadlock if the registration happens from another thread\n+            while (!checkpointLock.tryLock(10, TimeUnit.MILLISECONDS)) {\n+                throwIfCheckpointInProgress(priority);\n+            }\n+            locked = true;\n+            \/\/ This is important for the case of recursive registration\n+            throwIfCheckpointInProgress(priority);\n+            if (currentPriority < 0) {\n+                resources.put(resource, priority);\n+            } else {\n+                resourceQueue.add(Map.entry(resource, priority));\n+            }\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+        } finally {\n+            if (locked) {\n+                checkpointLock.unlock();\n+            }\n+        }\n@@ -49,2 +70,5 @@\n-    protected synchronized void register(R resource, P payload) {\n-        checkpointQ.put(resource, payload);\n+    private void throwIfCheckpointInProgress(long priority) {\n+        if (priority <= currentPriority) {\n+            throw new IllegalStateException(\"Notifications for an upcoming checkpoint are already in progress (priority \"\n+                    + currentPriority + \"). Please make sure to register this resource earlier or use higher priorty (\" + priority + \")\");\n+        }\n@@ -54,11 +78,5 @@\n-    public synchronized void beforeCheckpoint(Context<? extends Resource> context) throws CheckpointException {\n-        List<R> resources = checkpointQ.entrySet().stream()\n-            .sorted(comparator)\n-            .map(Map.Entry::getKey)\n-            .collect(Collectors.toList());\n-\n-        CheckpointException exception = new CheckpointException();\n-        for (Resource r : resources) {\n-            if (FlagsHolder.DEBUG) {\n-                System.err.println(\"jdk.crac beforeCheckpoint \" + r.toString());\n-            }\n+    public void beforeCheckpoint(Context<? extends Resource> context) throws CheckpointException {\n+        \/\/ If afterRestore is running we need to delay the beforeCheckpoint\n+        restoreLock.lock();\n+        try {\n+            checkpointLock.lock();\n@@ -66,4 +84,4 @@\n-                r.beforeCheckpoint(this);\n-            } catch (CheckpointException e) {\n-                for (Throwable t : e.getSuppressed()) {\n-                    exception.addSuppressed(t);\n+                runBeforeCheckpoint();\n+            } finally {\n+                if (restoreQ != null) {\n+                    Collections.reverse(restoreQ);\n@@ -71,2 +89,2 @@\n-            } catch (Exception e) {\n-                exception.addSuppressed(e);\n+                currentPriority = -1;\n+                checkpointLock.unlock();\n@@ -74,0 +92,9 @@\n+        } finally {\n+            restoreLock.unlock();\n+        }\n+    }\n+\n+    private void runBeforeCheckpoint() throws CheckpointException {\n+        Map.Entry<R, Long> drained;\n+        while ((drained = resourceQueue.poll()) != null) {\n+            resources.put(drained.getKey(), drained.getValue());\n@@ -75,0 +102,4 @@\n+        CheckpointException exception = null;\n+        TreeMap<Long, List<R>> resources = this.resources.entrySet().stream().collect(\n+                TreeMap::new, (m, e) -> m.computeIfAbsent(e.getValue(), p -> new ArrayList<>()).add(e.getKey()), TreeMap::putAll);\n+        restoreQ = new ArrayList<>(this.resources.size());\n@@ -76,2 +107,38 @@\n-        Collections.reverse(resources);\n-        restoreQ = resources;\n+        \/\/ We cannot simply iterate because we could cause mutations\n+        while (!resources.isEmpty()) {\n+            var entry = resources.firstEntry();\n+            resources.remove(entry.getKey());\n+            currentPriority = entry.getKey();\n+            for (R r : entry.getValue()) {\n+                jdk.internal.crac.LoggerContainer.debug(\"beforeCheckpoint {0}\", r);\n+                try {\n+                    r.beforeCheckpoint(this);\n+                    restoreQ.add(r);\n+                } catch (CheckpointException e) {\n+                    enqueueIfContext(r);\n+                    if (exception == null) {\n+                        exception = new CheckpointException();\n+                    }\n+                    Throwable[] suppressed = e.getSuppressed();\n+                    if (suppressed.length == 0) {\n+                        exception.addSuppressed(e);\n+                    }\n+                    for (Throwable t : suppressed) {\n+                        exception.addSuppressed(t);\n+                    }\n+                } catch (Exception e) {\n+                    enqueueIfContext(r);\n+                    if (exception == null) {\n+                        exception = new CheckpointException();\n+                    }\n+                    exception.addSuppressed(e);\n+                }\n+            }\n+            while ((drained = resourceQueue.poll()) != null) {\n+                if (drained.getValue() <= currentPriority) {\n+                    \/\/ this should be prevented in register method\n+                    throw new IllegalStateException();\n+                }\n+                resources.computeIfAbsent(drained.getValue(), p -> new ArrayList<>()).add(drained.getKey());\n+            }\n+        }\n@@ -79,1 +146,1 @@\n-        if (0 < exception.getSuppressed().length) {\n+        if (exception != null) {\n@@ -84,0 +151,9 @@\n+    private void enqueueIfContext(R r) {\n+        \/\/ When the resource itself is a context it contains other resources that should\n+        \/\/ be restored upon unsuccessful checkpoint (if the beforeCheckpoint has thrown\n+        \/\/ we are going to call afterRestore on all checkpointed resources immediately)\n+        if (r instanceof Context<?>) {\n+            restoreQ.add(r);\n+        }\n+    }\n+\n@@ -85,11 +161,28 @@\n-    public synchronized void afterRestore(Context<? extends Resource> context) throws RestoreException {\n-        RestoreException exception = new RestoreException();\n-        for (Resource r : restoreQ) {\n-            if (FlagsHolder.DEBUG) {\n-                System.err.println(\"jdk.crac afterRestore \" + r.toString());\n-            }\n-            try {\n-                r.afterRestore(this);\n-            } catch (RestoreException e) {\n-                for (Throwable t : e.getSuppressed()) {\n-                    exception.addSuppressed(t);\n+    public void afterRestore(Context<? extends Resource> context) throws RestoreException {\n+        restoreLock.lock();\n+        try {\n+            RestoreException exception = null;\n+            for (Resource r : restoreQ) {\n+                jdk.internal.crac.LoggerContainer.debug(\"afterRestore {0}\", r);\n+                try {\n+                    r.afterRestore(this);\n+                } catch (RestoreException e) {\n+                    \/\/ Print error early in case the restore process gets stuck\n+                    jdk.internal.crac.LoggerContainer.error(e, \"Failed to restore \" + r);\n+                    if (exception == null) {\n+                        exception = new RestoreException();\n+                    }\n+                    Throwable[] suppressed = e.getSuppressed();\n+                    if (suppressed.length == 0) {\n+                        exception.addSuppressed(e);\n+                    }\n+                    for (Throwable t : suppressed) {\n+                        exception.addSuppressed(t);\n+                    }\n+                } catch (Exception e) {\n+                    \/\/ Print error early in case the restore process gets stuck\n+                    LoggerContainer.error(e, \"Failed to restore \" + r);\n+                    if (exception == null) {\n+                        exception = new RestoreException();\n+                    }\n+                    exception.addSuppressed(e);\n@@ -97,2 +190,0 @@\n-            } catch (Exception e) {\n-                exception.addSuppressed(e);\n@@ -100,2 +191,1 @@\n-        }\n-        restoreQ = null;\n+            restoreQ = null;\n@@ -103,2 +193,5 @@\n-        if (0 < exception.getSuppressed().length) {\n-            throw exception;\n+            if (exception != null) {\n+                throw exception;\n+            }\n+        } finally {\n+            restoreLock.unlock();\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/impl\/AbstractContextImpl.java","additions":149,"deletions":56,"binary":false,"changes":205,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import jdk.crac.impl.AbstractContextImpl;\n@@ -32,4 +31,1 @@\n-import java.util.Comparator;\n-import java.util.Map;\n-\n-public class OrderedContext extends AbstractContextImpl<Resource, Long> {\n+public class OrderedContext extends AbstractContextImpl<Resource> {\n@@ -38,7 +34,0 @@\n-    static class ContextComparator implements Comparator<Map.Entry<Resource, Long>> {\n-        @Override\n-        public int compare(Map.Entry<Resource, Long> o1, Map.Entry<Resource, Long> o2) {\n-            return (int)(o2.getValue() - o1.getValue());\n-        }\n-    }\n-\n@@ -46,1 +35,0 @@\n-        super(new ContextComparator());\n@@ -51,1 +39,4 @@\n-        register(r, order++);\n+        \/\/ Priorities are executed from lowest to highest; in order to call\n+        \/\/ beforeCheckpoint in reverse order compared to registration we use\n+        \/\/ descending numbers.\n+        register(r, Long.MAX_VALUE - (order++));\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/impl\/OrderedContext.java","additions":5,"deletions":14,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -31,15 +31,1 @@\n-import java.util.Comparator;\n-import java.util.Map;\n-\n-public class JDKContext extends AbstractContextImpl<JDKResource, Void> {\n-    static class ContextComparator implements Comparator<Map.Entry<JDKResource, Void>> {\n-        @Override\n-        public int compare(Map.Entry<JDKResource, Void> o1, Map.Entry<JDKResource, Void> o2) {\n-            return o1.getKey().getPriority().compareTo(o2.getKey().getPriority());\n-        }\n-    }\n-\n-    JDKContext() {\n-        super(new ContextComparator());\n-    }\n-\n+public class JDKContext extends AbstractContextImpl<JDKResource> {\n@@ -48,1 +34,1 @@\n-        register(resource, null);\n+        register(resource, resource.getPriority().ordinal());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/JDKContext.java","additions":2,"deletions":16,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -0,0 +1,29 @@\n+package jdk.internal.crac;\n+\n+\/**\n+ * Some classes that could use logging are initialized early during the boot\n+ * and keeping the logger in static final field there could cause problems\n+ * (e.g. recursion when service-loading logger implementation).\n+ * Therefore, we isolate the logger into a subclass and initialize lazily.\n+ *\/\n+public class LoggerContainer {\n+    public static final System.Logger logger = System.getLogger(\"jdk.internal.crac\");\n+\n+    public static void info(String msg) {\n+        logger.log(System.Logger.Level.INFO, msg);\n+    }\n+\n+    public static void debug(String fmt, Object... params) {\n+        logger.log(System.Logger.Level.DEBUG, fmt, params);\n+    }\n+\n+    private LoggerContainer() {}\n+\n+    public static void error(String msg) {\n+        logger.log(System.Logger.Level.ERROR, msg);\n+    }\n+\n+    public static void error(Throwable t, String msg) {\n+        logger.log(System.Logger.Level.ERROR, msg, t);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/LoggerContainer.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.crac.LoggerContainer;\n@@ -39,8 +40,0 @@\n-    \/\/ PersistentJarFile is <clinit>ed when loading classes on the module path;\n-    \/\/ when initializing the logger an implementation of logging is looked up through\n-    \/\/ service-loading and that causes a recursion in opening the module.\n-    \/\/ Therefore, we isolate the logger into a subclass and initialize only when needed.\n-    private static class LoggerContainer {\n-        private static final System.Logger logger = System.getLogger(\"jdk.crac\");\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/jar\/PersistentJarFile.java","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,229 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.CheckpointException;\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import jdk.crac.RestoreException;\n+import jdk.internal.crac.JDKResource;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import static jdk.crac.Core.getGlobalContext;\n+import static jdk.internal.crac.Core.*;\n+import static jdk.test.lib.Asserts.*;\n+\n+\/**\n+ * @test ContextOrderTest\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.crac:+open\n+ * @run main ContextOrderTest\n+ *\/\n+public class ContextOrderTest {\n+    \/\/ prevents GC releasing the resources\n+    private static final List<Resource> rememberMe = new ArrayList<>();\n+\n+    public static void main(String[] args) throws Exception {\n+        testOrder();\n+        testCannotRegister();\n+        testThrowing();\n+    }\n+\n+    private static void testOrder() throws CheckpointException, RestoreException {\n+        var recorder = new LinkedList<String>();\n+        getGlobalContext().register(new MockResource(recorder, null, \"regular1\"));\n+        getJDKContext().register(new MockResource(recorder, JDKResource.Priority.NORMAL, \"jdk-normal\"));\n+        getJDKContext().register(new MockResource(recorder, JDKResource.Priority.SECURE_RANDOM, \"jdk-later\"));\n+        getGlobalContext().register(new CreatingResource<>(recorder, null, \"regular2\", getJDKContext(), JDKResource.Priority.NORMAL));\n+        \/\/ this child should run as it has higher priority\n+        getJDKContext().register(new CreatingResource<>(recorder, JDKResource.Priority.NORMAL, \"jdk-create\", getJDKContext(), JDKResource.Priority.SEEDER_HOLDER));\n+\n+        getGlobalContext().beforeCheckpoint(null);\n+        assertEquals(\"regular2-before\", recorder.poll());\n+        assertEquals(\"regular1-before\", recorder.poll());\n+\n+        \/\/ The order of notifications with the same priority class is undefined\n+        List<String> normalPriority = Arrays.asList(recorder.poll(), recorder.poll(), recorder.poll());\n+        normalPriority.sort(String::compareTo);\n+        assertEquals(\"jdk-create-before\", normalPriority.get(0));\n+        assertEquals(\"jdk-normal-before\", normalPriority.get(1));\n+        assertEquals(\"regular2-child1-before\", normalPriority.get(2));\n+\n+        assertEquals(\"jdk-later-before\", recorder.poll());\n+        assertEquals(\"jdk-create-child1-before\", recorder.poll());\n+        assertNull(recorder.poll());\n+\n+        getGlobalContext().afterRestore(null);\n+        assertEquals(\"jdk-create-child1-after\", recorder.poll());\n+        assertEquals(\"jdk-later-after\", recorder.poll());\n+\n+        normalPriority = Arrays.asList(recorder.poll(), recorder.poll(), recorder.poll());\n+        normalPriority.sort(String::compareTo);\n+        assertEquals(\"jdk-create-after\", normalPriority.get(0));\n+        assertEquals(\"jdk-normal-after\", normalPriority.get(1));\n+        assertEquals(\"regular2-child1-after\", normalPriority.get(2));\n+\n+        assertEquals(\"regular1-after\", recorder.poll());\n+        assertEquals(\"regular2-after\", recorder.poll());\n+        assertNull(recorder.poll());\n+\n+        \/\/ second checkpoint - whatever was registered in first afterRestore is now notified\n+        getGlobalContext().beforeCheckpoint(null);\n+        assertTrue(recorder.stream().anyMatch(\"jdk-create-child2-before\"::equals));\n+        assertTrue(recorder.stream().anyMatch(\"regular2-child2-before\"::equals));\n+    }\n+\n+    private static void testCannotRegister() {\n+        var recorder = new LinkedList<String>();\n+        \/\/ cannot register into the same OrderedContext\n+        getGlobalContext().register(new CreatingResource<>(recorder, null, \"regular\", getGlobalContext(), null));\n+        \/\/ Cannot register with lower priority\n+        getJDKContext().register(new CreatingResource<>(recorder, JDKResource.Priority.SECURE_RANDOM, \"jdk-lower\", getJDKContext(), JDKResource.Priority.NORMAL));\n+        \/\/ Cannot register with the same priority\n+        getJDKContext().register(new CreatingResource<>(recorder, JDKResource.Priority.NORMAL, \"jdk-same\", getJDKContext(), JDKResource.Priority.NORMAL));\n+\n+        try {\n+            getGlobalContext().beforeCheckpoint(null);\n+            fail(\"Expected to throw CheckpointException\");\n+        } catch (CheckpointException e) {\n+            assertEquals(3, e.getSuppressed().length);\n+        } finally {\n+            \/\/ Clear AbstractContextImpl.restoreQ\n+            try {\n+                getGlobalContext().afterRestore(null);\n+            } catch (RestoreException e) {\n+                \/\/ ignored\n+            }\n+            \/\/ Deregister all resources - we don't have a direct way to clear to contexts\n+            rememberMe.clear();\n+            System.gc();\n+        }\n+    }\n+\n+    private static void testThrowing() throws RestoreException {\n+        var recorder = new LinkedList<String>();\n+        getGlobalContext().register(new MockResource(recorder, null, \"regular1\"));\n+        getGlobalContext().register(new ThrowingResource(null));\n+        getGlobalContext().register(new MockResource(recorder, null, \"regular2\"));\n+        getJDKContext().register(new MockResource(recorder, JDKResource.Priority.NORMAL, \"jdk1\"));\n+        getJDKContext().register(new ThrowingResource(JDKResource.Priority.EPOLLSELECTOR));\n+        getJDKContext().register(new MockResource(recorder, JDKResource.Priority.SECURE_RANDOM, \"jdk2\"));\n+\n+        try {\n+            getGlobalContext().beforeCheckpoint(null);\n+            fail(\"Expected to throw CheckpointException\");\n+        } catch (CheckpointException e) {\n+            assertEquals(2, e.getSuppressed().length);\n+        }\n+        assertEquals(\"regular2-before\", recorder.poll());\n+        assertEquals(\"regular1-before\", recorder.poll());\n+        assertEquals(\"jdk1-before\", recorder.poll());\n+        assertEquals(\"jdk2-before\", recorder.poll());\n+        assertNull(recorder.poll());\n+\n+        getGlobalContext().afterRestore(null);\n+\n+        assertEquals(\"jdk2-after\", recorder.poll());\n+        assertEquals(\"jdk1-after\", recorder.poll());\n+        assertEquals(\"regular1-after\", recorder.poll());\n+        assertEquals(\"regular2-after\", recorder.poll());\n+        assertNull(recorder.poll());\n+    }\n+\n+    private static class MockResource implements JDKResource {\n+        protected final List<String> recorder;\n+        protected final Priority priority;\n+        protected final String id;\n+\n+        private MockResource(List<String> recorder, Priority priority, String id) {\n+            rememberMe.add(this);\n+            this.recorder = recorder;\n+            this.priority = priority;\n+            this.id = id;\n+        }\n+\n+        @Override\n+        public Priority getPriority() {\n+            return priority;\n+        }\n+\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) {\n+            recorder.add(id + \"-before\");\n+        }\n+\n+        @Override\n+        public void afterRestore(Context<? extends Resource> context) {\n+            recorder.add(id + \"-after\");\n+        }\n+    }\n+\n+    \/\/ While normally resources should not directly register other resources it is possible\n+    \/\/ that running it will trigger (static) initialization of a class and that registers\n+    \/\/ a new resource. It is not legal to register a user resource, but for JDK resources\n+    \/\/ we can make an exception since it does not conflict with the general order (JDK resources\n+    \/\/ are notified after user resources).\n+    private static class CreatingResource<R extends Resource> extends MockResource {\n+        private final Priority childPriority;\n+        private final Context<R> childContext;\n+\n+        private CreatingResource(List<String> recorder, Priority priority, String id, Context<R> childContext, Priority childPriority) {\n+            super(recorder, priority, id);\n+            this.childContext = childContext;\n+            this.childPriority = childPriority;\n+        }\n+\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) {\n+            super.beforeCheckpoint(context);\n+            \/\/noinspection unchecked\n+            childContext.register((R) new MockResource(recorder, childPriority, id + \"-child1\"));\n+        }\n+\n+        @Override\n+        public void afterRestore(Context<? extends Resource> context) {\n+            super.afterRestore(context);\n+            \/\/noinspection unchecked\n+            childContext.register((R) new MockResource(recorder, childPriority, id + \"-child2\"));\n+        }\n+    }\n+\n+    private static class ThrowingResource extends MockResource {\n+        private ThrowingResource(Priority priority) {\n+            super(null, priority, \"throwing\");\n+        }\n+\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) {\n+            throw new RuntimeException();\n+        }\n+\n+        @Override\n+        public void afterRestore(Context<? extends Resource> context) {\n+            throw new RuntimeException();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/ContextOrderTest.java","additions":229,"deletions":0,"binary":false,"changes":229,"status":"added"},{"patch":"@@ -1,114 +0,0 @@\n-\/\/ Copyright 2019-2020 Azul Systems, Inc.  All Rights Reserved.\n-\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-\/\/\n-\/\/ This code is free software; you can redistribute it and\/or modify it under\n-\/\/ the terms of the GNU General Public License version 2 only, as published by\n-\/\/ the Free Software Foundation.\n-\/\/\n-\/\/ This code is distributed in the hope that it will be useful, but WITHOUT ANY\n-\/\/ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n-\/\/ A PARTICULAR PURPOSE.  See the GNU General Public License version 2 for more\n-\/\/ details (a copy is included in the LICENSE file that accompanied this code).\n-\/\/\n-\/\/ You should have received a copy of the GNU General Public License version 2\n-\/\/ along with this work; if not, write to the Free Software Foundation, Inc.,\n-\/\/ 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-\/\/\n-\/\/ Please contact Azul Systems, 385 Moffett Park Drive, Suite 115, Sunnyvale,\n-\/\/ CA 94089 USA or visit www.azul.com if you need additional information or\n-\/\/ have any questions.\n-\n-package jdk.test.jdk.crac;\n-\n-import jdk.crac.*;\n-\n-\/**\n- * @test\n- * @compile ResourceTest.java\n- *\/\n-public class ResourceTest {\n-    static class CRResource implements Resource {\n-        String id;\n-        boolean[] throwCond;\n-        int nCalls = 0;\n-        CRResource(String id, boolean... throwCond) {\n-            this.id = id;\n-            this.throwCond = throwCond;\n-        }\n-\n-        void maybeException(String callId) throws Exception {\n-            boolean t = nCalls < throwCond.length ? throwCond[nCalls] : throwCond[throwCond.length - 1];\n-            System.out.println(id + \" \" + callId + \"(\" + nCalls + \") throw? \" + t);\n-            ++nCalls;\n-            if (t) {\n-                throw new RuntimeException(id);\n-            }\n-        }\n-\n-        @Override\n-        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n-            maybeException(\"beforeCheckpoint\");\n-        }\n-\n-        @Override\n-        public void afterRestore(Context<? extends Resource> context) throws Exception {\n-            maybeException(\"afterRestore\");\n-        }\n-    }\n-\n-    static class SingleContext extends Context<Resource> {\n-        private Resource r;\n-\n-        @Override\n-        public void beforeCheckpoint(Context<? extends Resource> context) throws CheckpointException {\n-            try {\n-                r.beforeCheckpoint(this);\n-            } catch (Exception e) {\n-                CheckpointException newException = new CheckpointException();\n-                newException.addSuppressed(e);\n-                throw newException;\n-            }\n-        }\n-\n-        @Override\n-        public void afterRestore(Context<? extends Resource> context) throws RestoreException {\n-            try {\n-                r.afterRestore(this);\n-            } catch (Exception e) {\n-                RestoreException newException = new RestoreException();\n-                newException.addSuppressed(e);\n-                throw newException;\n-            }\n-\n-        }\n-\n-        @Override\n-        public void register(Resource r) {\n-            this.r = r;\n-        }\n-\n-        public SingleContext(Resource r) {\n-            register(r);\n-        }\n-    }\n-\n-    static public void main(String[] args) throws Exception {\n-        Core.getGlobalContext().register(\n-            new CRResource(\"One\", true, false));\n-        Core.getGlobalContext().register(\n-            new SingleContext(\n-                new CRResource(\"Two\", false, true, false, true)));\n-        \/\/System.gc();\n-        int tries = 2;\n-        for (int i = 0; i < 2; ++i) {\n-            try {\n-                jdk.crac.Core.checkpointRestore();\n-            } catch (CheckpointException e) {\n-                e.printStackTrace();\n-            } catch (RestoreException e) {\n-                e.printStackTrace();\n-            }\n-        }\n-        System.out.println(\"DONE\");\n-    }\n-}\n","filename":"test\/jdk\/jdk\/crac\/ResourceTest.java","additions":0,"deletions":114,"binary":false,"changes":114,"status":"deleted"}]}