{"files":[{"patch":"@@ -22,1 +22,1 @@\n-      platform_linux_additional: ${{ false && steps.check_platforms.outputs.platform_linux_additional }}\n+      platform_linux_additional: ${{ steps.check_platforms.outputs.platform_linux_additional }}\n@@ -24,4 +24,4 @@\n-      platform_linux_x86: ${{ false && steps.check_platforms.outputs.platform_linux_x86 }}\n-      platform_windows_x64: ${{ false && steps.check_platforms.outputs.platform_windows_x64 }}\n-      platform_macos_x64: ${{ false && steps.check_platforms.outputs.platform_macos_x64 }}\n-      platform_macos_aarch64: ${{ false && steps.check_platforms.outputs.platform_macos_aarch64 }}\n+      platform_linux_x86: ${{ steps.check_platforms.outputs.platform_linux_x86 }}\n+      platform_windows_x64: ${{ steps.check_platforms.outputs.platform_windows_x64 }}\n+      platform_macos_x64: ${{ steps.check_platforms.outputs.platform_macos_x64 }}\n+      platform_macos_aarch64: ${{ steps.check_platforms.outputs.platform_macos_aarch64 }}\n","filename":".github\/workflows\/submit.yml","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,3 +28,0 @@\n-import jdk.crac.Context;\n-import jdk.crac.Resource;\n-import jdk.internal.crac.JDKResource;\n@@ -251,2 +248,0 @@\n-    private static JDKResource referenceHandlerResource;\n-\n@@ -334,7 +329,0 @@\n-        });\n-\n-        referenceHandlerResource = new JDKResource() {\n-            @Override\n-            public Priority getPriority() {\n-                return Priority.REFERENCE_HANDLER;\n-            }\n@@ -343,8 +331,6 @@\n-            public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n-                System.gc();\n-                \/\/ TODO ensure GC done processing all References\n-                while (waitForReferenceProcessing());\n-            }\n-\n-            @Override\n-            public void afterRestore(Context<? extends Resource> context) throws Exception {\n+            public boolean waitForQueueProcessed(ReferenceQueue<?> queue,\n+                                                 int nThreads,\n+                                                 long timeout)\n+                throws InterruptedException\n+            {\n+                return queue.waitForQueueProcessed(nThreads, timeout);\n@@ -352,2 +338,1 @@\n-        };\n-        jdk.internal.crac.Core.getJDKContext().register(referenceHandlerResource);\n+        });\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/Reference.java","additions":7,"deletions":22,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -29,0 +29,3 @@\n+\n+import jdk.internal.access.JavaLangRefAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -59,1 +62,1 @@\n-    private int nWaiters = 0;\n+    private int nBlocked = 0;\n@@ -156,1 +159,1 @@\n-                ++nWaiters;\n+                ++nBlocked;\n@@ -159,1 +162,1 @@\n-                --nWaiters;\n+                --nBlocked;\n@@ -213,3 +216,1 @@\n-     * Blocks calling thread until the specified number of threads are blocked with no reference available.\n-     * @param nWaiters number of threads to wait\n-     * @throws InterruptedException If the wait is interrupted\n+     * See {@link jdk.crac.Misc#waitForQueueProcessed(ReferenceQueue, int, long)}.\n@@ -217,1 +218,35 @@\n-    public void waitForWaiters(int nWaiters) throws InterruptedException {\n+    boolean waitForQueueProcessed(int nThreads, long timeout)\n+        throws InterruptedException\n+    {\n+        JavaLangRefAccess refAccess = SharedSecrets.getJavaLangRefAccess();\n+        long start = (timeout > 0) ? System.nanoTime() : 0;\n+\n+        \/\/ Back-to-back calls of this function are not optimized\n+        \/\/ intentionally.  It's possible to check if the previous call\n+        \/\/ has queued no reference and conclude that there is no need\n+        \/\/ to call GC and wait for reference processing.  But with such\n+        \/\/ optimization we may lose references that were queued because\n+        \/\/ some other code, beside another reference queue processing,\n+        \/\/ caused a referent be unreachable.\n+\n+        System.gc();\n+        \/\/ TODO ensure GC done processing all References\n+\n+        \/\/ should wait for the completion, otherwise the queue may appear\n+        \/\/ empty, although a ref to be about to be enqueued.\n+        while (refAccess.waitForReferenceProcessing());\n+\n+        if (timeout > 0) {\n+            timeout -= (System.nanoTime() - start) \/ 1_000_000;\n+            if (timeout <= 0) {\n+                \/\/ give a chance to detect blocked threads\n+                timeout = -1;\n+            }\n+        }\n+\n+        if (timeout < 0) {\n+            synchronized (lock) {\n+                return head == null && nThreads <= nBlocked;\n+            }\n+        }\n+\n@@ -219,2 +254,9 @@\n-            while (head != null || this.nWaiters < nWaiters) {\n-                lock.wait();\n+            while (head != null || nBlocked < nThreads) {\n+                lock.wait(timeout);\n+                if (timeout != 0) {\n+                    long end = System.nanoTime();\n+                    timeout -= (end - start) \/ 1000_000;\n+                    if (timeout <= 0)\n+                        return false;\n+                    start = end;\n+                }\n@@ -223,0 +265,1 @@\n+        return true;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/ReferenceQueue.java","additions":52,"deletions":9,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -0,0 +1,41 @@\n+package jdk.crac;\n+\n+import jdk.internal.access.SharedSecrets;\n+\n+import java.lang.ref.ReferenceQueue;\n+\n+\/**\n+ * Additional utilities.\n+ *\/\n+public final class Misc {\n+\n+    private Misc() {\n+    }\n+\n+    \/**\n+     * Blocks calling thread until there are no references in the queue and\n+     * the specified number of threads are blocked without a reference to\n+     * process.\n+     * <p>\n+     * Note that {@code timeout} specifies the timeout for threads to block,\n+     * while the total time of this function to complete may be much larger\n+     * that the specified timeout.\n+     *\n+     * @param queue the queue to wait\n+     * @param nThreads number of threads to wait\n+     * @param timeout milliseconds to wait for threads to block, if positive,\n+     *                wait indefinitely, if zero,\n+     *                and, otherwise, just check the condition\n+     * @throws InterruptedException If the wait is interrupted\n+     * @return true if condition was true during the timeout period,\n+     *         otherwise false\n+     *\/\n+    public static boolean waitForQueueProcessed(ReferenceQueue<?> queue,\n+                                                int nThreads,\n+                                                long timeout)\n+        throws InterruptedException\n+    {\n+        return SharedSecrets.getJavaLangRefAccess().\n+            waitForQueueProcessed(queue, nThreads, timeout);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/Misc.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -28,0 +28,2 @@\n+import java.lang.ref.ReferenceQueue;\n+\n@@ -46,0 +48,8 @@\n+\n+    \/**\n+     * See {@link jdk.crac.Misc#waitForQueueProcessed(ReferenceQueue, int, long)}.\n+     *\/\n+    boolean waitForQueueProcessed(ReferenceQueue<?> queue,\n+                                  int nThreads,\n+                                  long timeout)\n+        throws InterruptedException;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangRefAccess.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -36,0 +36,3 @@\n+    private Core() {\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/Core.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+     *\n@@ -42,0 +43,1 @@\n+     *\n@@ -50,0 +52,2 @@\n+         *\n+         * @see sun.awt.X11.X11GraphicsEnvironment\n@@ -76,5 +80,0 @@\n-        \/**\n-         * Priority of the\n-         * java.lan.ref.Reference static resource\n-         *\/\n-        REFERENCE_HANDLER,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/JDKResource.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -31,2 +31,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -161,2 +159,11 @@\n-    public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n-        queue.waitForWaiters(1);\n+    public void beforeCheckpoint(Context<? extends Resource> context)\n+        throws Exception\n+    {\n+        final long timeout = 1_000; \/\/ reasonable for ref.clean() to finish\n+        while (!phantomCleanableList.isListEmpty() &&\n+               !jdk.crac.Misc.waitForQueueProcessed(queue, 1, timeout)) {\n+            \/\/ This loop reflects the loop in the cleaner handler thread,\n+            \/\/ that allows a race between reference clearing from the list\n+            \/\/ and waiting for the queue. So we need to wait for the queue\n+            \/\/ to be processed with the timeout as well.\n+        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/ref\/CleanerImpl.java","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -367,0 +367,2 @@\n+    exports jdk.internal.crac to\n+        java.desktop;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.util.Arrays;\n@@ -206,0 +207,21 @@\n+\n+                \/**\n+                 * Setting to {@code null} predefined {@code Cursor} to reinitialize\n+                 * {@code XToolkit} properly.\n+                 * {@code Window} depends on this method.\n+                 *\n+                 * @see java.awt.Window\n+                 *\/\n+                public void beforeCheckpoint() throws Exception {\n+                    Arrays.fill(predefinedPrivate, null);\n+                    Arrays.fill(predefined, null);\n+                }\n+\n+                \/**\n+                 * {@code Cursor} restoring to reinitialize {@code XToolkit} properly.\n+                 * {@code Window} depends on this method.\n+                 *\n+                 * @see java.awt.Window\n+                 *\/\n+                public void afterRestore() throws Exception {\n+                }\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/Cursor.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -41,0 +41,4 @@\n+import jdk.crac.Context;\n+import jdk.crac.Resource;\n+import jdk.internal.crac.JDKResource;\n+\n@@ -101,0 +105,57 @@\n+    \/**\n+     * Reinitialization of the local {@code GraphicsEnvironment}.\n+     *\n+     * This must be done after GC and reference handling,\n+     * because some objects require connection to be disposed.\n+     * It depends on {@code GraphicsEnvironment} extending classes.\n+     *\n+     * @see sun.awt.X11GraphicsEnvironment\n+     * @see jdk.internal.crac.JDKResource\n+     *\/\n+    private static final JDKResource jdkResource = new JDKResource() {\n+        @Override\n+        public JDKResource.Priority getPriority() {\n+            return Priority.NORMAL;\n+        }\n+\n+        @Override\n+        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+            LocalGE.INSTANCE.beforeCheckpoint();\n+        }\n+\n+        @Override\n+        public void afterRestore(Context<? extends Resource> context) throws Exception {\n+            LocalGE.INSTANCE.afterRestore();\n+        }\n+    };\n+\n+    \/**\n+     * {@code beforeCheckpoint()} operation for\n+     * {@code GraphicsEnvironment} extending classes.\n+     * Should be overridden for proper reinitialization\n+     * of the local {@code GraphicsEnvironment}.\n+     *\n+     * @see sun.awt.X11GraphicsEnvironment\n+     * @throws Exception if not overridden\n+     *\/\n+    protected void beforeCheckpoint() throws Exception {\n+        throw new UnsupportedOperationException(\"Should be overridden.\");\n+    }\n+\n+    \/**\n+     * {@code afterRestore()} operation for\n+     * {@code GraphicsEnvironment} extending classes.\n+     * Should be overridden for proper reinitialization\n+     * of the local {@code GraphicsEnvironment}.\n+     *\n+     * @see sun.awt.X11GraphicsEnvironment\n+     * @throws Exception if not overridden\n+     *\/\n+    protected void afterRestore() throws Exception {\n+        throw new UnsupportedOperationException(\"Should be overridden.\");\n+    }\n+\n+    static {\n+        jdk.internal.crac.Core.getJDKContext().register(jdkResource);\n+    }\n+\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/GraphicsEnvironment.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -4121,0 +4121,38 @@\n+\n+            \/**\n+             * {@code Window} disposing to reinitialize {@code XToolkit} properly.\n+             * {@code XToolkit} depends on this method.\n+             *\n+             * @see sun.awt.X11.XToolkit\n+             *\n+             * Note: When the last displayable window within the\n+             * Java virtual machine (VM) is disposed of, the VM may terminate.\n+             *\n+             * @see #dispose\n+             *\/\n+            public void beforeCheckpoint() throws Exception {\n+                for (int i = 0; i < allWindows.size(); i++) {\n+                    Window window = allWindows.get(i);\n+                    \/\/ Ensure that the window is removed from the\n+                    \/\/ AppContext before sun.java2d.Disposer disposed it\n+                    window.disposerRecord.dispose();\n+                    \/\/ When the last displayable window within the\n+                    \/\/ Java virtual machine (VM) is disposed of, the VM may terminate\n+                    window.dispose();\n+                }\n+                nameCounter = 0;\n+\n+                AWTAccessor.getCursorAccessor().beforeCheckpoint();\n+            }\n+\n+            \/**\n+             * {@code Window} restoring to reinitialize {@code XToolkit} properly.\n+             * {@code XToolkit} depends on this method.\n+             *\n+             * TODO: AWT components reinitialization to the original state\n+             *\n+             * @see sun.awt.X11.XToolkit\n+             *\/\n+            public void afterRestore() throws Exception {\n+                AWTAccessor.getCursorAccessor().afterRestore();\n+            }\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/Window.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -43,0 +43,3 @@\n+import sun.java2d.Disposer;\n+import sun.awt.X11.XToolkit;\n+\n@@ -289,1 +292,1 @@\n-    public interface WindowAccessor {\n+    public interface WindowAccessor extends CheckpointRestoreAccessor {\n@@ -608,1 +611,1 @@\n-    public interface CursorAccessor {\n+    public interface CursorAccessor extends CheckpointRestoreAccessor {\n@@ -830,0 +833,21 @@\n+    \/**\n+     * An accessor object for the reinitialized\n+     * by CRaC AWT classes.\n+     *\/\n+    private interface CheckpointRestoreAccessor {\n+        void beforeCheckpoint() throws Exception;\n+        void afterRestore() throws Exception;\n+    }\n+\n+    \/**\n+     * An accessor object for the Java2D Disposer class.\n+     *\/\n+    public interface DisposerAccessor extends CheckpointRestoreAccessor {\n+    }\n+\n+    \/**\n+     * An accessor object for the X11 XToolkit class.\n+     *\/\n+    public interface XToolkitAccessor extends CheckpointRestoreAccessor {\n+    }\n+\n@@ -865,0 +889,2 @@\n+    private static DisposerAccessor disposerAccessor;\n+    private static XToolkitAccessor xToolkitAccessor;\n@@ -1398,0 +1424,34 @@\n+    \/*\n+     * Get the accessor object for the sun.java2d.Disposer class.\n+     *\/\n+    public static DisposerAccessor getDisposerAccessor() {\n+        if (disposerAccessor == null) {\n+            ensureClassInitialized(Disposer.class);\n+        }\n+        return disposerAccessor;\n+    }\n+\n+    \/*\n+     * Set the accessor object for the sun.java2d.Disposer class.\n+     *\/\n+    public static void setDisposerAccessor(DisposerAccessor accessor) {\n+        disposerAccessor = accessor;\n+    }\n+\n+    \/*\n+     * Get the accessor object for the sun.awt.X11.XToolkit class.\n+     *\/\n+    public static XToolkitAccessor getXToolkitAccessor() {\n+        if (xToolkitAccessor == null) {\n+            ensureClassInitialized(XToolkit.class);\n+        }\n+        return xToolkitAccessor;\n+    }\n+\n+    \/*\n+     * Set the accessor object for the sun.awt.X11.XToolkit class.\n+     *\/\n+    public static void setXToolkitAccessor(XToolkitAccessor accessor) {\n+        xToolkitAccessor = accessor;\n+    }\n+\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/AWTAccessor.java","additions":62,"deletions":2,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import sun.awt.AWTAccessor;\n+import sun.awt.AWTAccessor.DisposerAccessor;\n@@ -95,0 +97,16 @@\n+\n+        AWTAccessor.setDisposerAccessor(new DisposerAccessor() {\n+            public void beforeCheckpoint() throws Exception {\n+                final long timeout = 1_000; \/\/ reasonable for ref.clear() and rec.dispose() to finish\n+                while (!records.isEmpty() &&\n+                        !jdk.crac.Misc.waitForQueueProcessed(queue, 1, timeout)) {\n+                    \/\/ This loop reflects the loop in the disposer handler thread,\n+                    \/\/ that allows a race between reference disposing from the records\n+                    \/\/ and waiting for the queue. So we need to wait for the queue\n+                    \/\/ to be processed with the timeout as well.\n+                }\n+            }\n+\n+            public void afterRestore() throws Exception {\n+            }\n+        });\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/Disposer.java","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -143,0 +143,9 @@\n+\n+    static void beforeCheckpoint() throws Exception {\n+        atomToAtom.clear();\n+        nameToAtom.clear();\n+    }\n+\n+    static void afterRestore() throws Exception {\n+    }\n+\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XAtom.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -40,0 +40,7 @@\n+    static void beforeCheckpoint() throws Exception {\n+        wm_client_leader = null;\n+    }\n+\n+    static void afterRestore() throws Exception {\n+    }\n+\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XBaseWindow.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -96,0 +96,24 @@\n+    \/**\n+     * Setting {@code XErrorHandlerUtil} fields to default values to reinitialize\n+     * {@code XToolkit} properly.\n+     * {@code XToolkit} depends on this method.\n+     *\n+     * @see sun.awt.X11.XToolkit\n+     *\/\n+    static void beforeCheckpoint() throws Exception {\n+        display = 0;\n+        saved_error_handler = 0;\n+        saved_error = null;\n+        current_error_handler = null;\n+        initPassed = false;\n+    }\n+\n+    \/**\n+     * {@code XErrorHandlerUtil} restoring to reinitialize {@code XToolkit} properly.\n+     * {@code XToolkit} depends on this method.\n+     *\n+     * @see sun.awt.X11.XToolkit\n+     *\/\n+    static void afterRestore() throws Exception {\n+    }\n+\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XErrorHandlerUtil.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -38,0 +38,7 @@\n+    static void beforeCheckpoint() throws Exception {\n+        manager = null;\n+    }\n+\n+    static void afterRestore() throws Exception {\n+    }\n+\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XGlobalCursorManager.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-        private static final XRootWindow xawtRootWindow;\n+        private static XRootWindow xawtRootWindow;\n@@ -37,1 +37,1 @@\n-        static {\n+        private static void init() {\n@@ -47,0 +47,20 @@\n+        private static void deinit() {\n+            LazyHolder.xawtRootWindow.destroy();\n+            LazyHolder.xawtRootWindow = null;\n+        }\n+\n+        static {\n+            init();\n+        }\n+    }\n+\n+    static void beforeCheckpoint() throws Exception {\n+        LazyHolder.deinit();\n+\n+        XWindow.beforeCheckpoint();\n+    }\n+\n+    static void afterRestore() throws Exception {\n+        XWindow.afterRestore();\n+\n+        LazyHolder.init();\n@@ -48,0 +68,1 @@\n+\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XRootWindow.java","additions":23,"deletions":2,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -133,0 +133,1 @@\n+import sun.awt.AWTAccessor.XToolkitAccessor;\n@@ -201,3 +202,3 @@\n-    static final X11GraphicsEnvironment localEnv;\n-    private static final X11GraphicsDevice device;\n-    private static final long display;\n+    static X11GraphicsEnvironment localEnv;\n+    private static X11GraphicsDevice device;\n+    private static long display;\n@@ -216,16 +217,1 @@\n-    static {\n-        initSecurityWarning();\n-        if (GraphicsEnvironment.isHeadless()) {\n-            localEnv = null;\n-            device = null;\n-            display = 0;\n-        } else {\n-            localEnv = (X11GraphicsEnvironment) GraphicsEnvironment\n-                .getLocalGraphicsEnvironment();\n-            device = (X11GraphicsDevice) localEnv.getDefaultScreenDevice();\n-            display = device.getDisplay();\n-            setupModifierMap();\n-            initIDs();\n-            setBackingStoreType();\n-        }\n-    }\n+    private static int state = 0;\n@@ -329,1 +315,1 @@\n-    void init() {\n+    static void initInternal() {\n@@ -367,0 +353,6 @@\n+    }\n+\n+    @SuppressWarnings(\"removal\")\n+    void init() {\n+        initInternal();\n+\n@@ -684,0 +676,7 @@\n+                        if (state == 1) {\n+                            state = 2;\n+                            awtLockNotifyAll();\n+                            while (state == 2) {\n+                                awtLockWait();\n+                            }\n+                        }\n@@ -744,0 +743,21 @@\n+    private static void loopLock() {\n+        try {\n+            awtLock();\n+            state = 1;\n+            while (state != 2) {\n+                awtLockWait(10);\n+            }\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+        } finally {\n+            awtUnlock();\n+        }\n+    }\n+\n+    private static void loopUnlock() {\n+        awtLock();\n+        state = 0;\n+        awtLockNotifyAll();\n+        awtUnlock();\n+    }\n+\n@@ -762,0 +782,92 @@\n+        initStatic();\n+\n+        AWTAccessor.setXToolkitAccessor(new XToolkitAccessor() {\n+            \/**\n+             * Deinitialization of the {@code XToolkit} for proper\n+             * reinitialization of {@code X11GraphicsEnvironment}.\n+             *\n+             * This must be done before GC and reference handling,\n+             * because it may cause some objects to be unreachable.\n+             * Some of disposed objects may require a connection.\n+             * {@code X11GraphicsEnvironment} depends on this method.\n+             *\n+             * @see sun.awt.X11GraphicsEnvironment\n+             *\/\n+            public void beforeCheckpoint() throws Exception {\n+                \/\/ AWT\n+                AWTAccessor.getWindowAccessor().beforeCheckpoint();\n+\n+                \/\/ X11\n+                XRootWindow.beforeCheckpoint();\n+                XWM.beforeCheckpoint();\n+                XErrorHandlerUtil.beforeCheckpoint();\n+\n+                loopLock();\n+\n+                synchronized (winMap) {\n+                    for (XBaseWindow window : winMap.values()) {\n+                        window.destroy();\n+                    }\n+                    winMap.clear();\n+                }\n+                synchronized (winToDispatcher) {\n+                    winToDispatcher.clear();\n+                }\n+                for (Object peer : specialPeerMap.values()) {\n+                    if (peer instanceof XComponentPeer) {\n+                        ((XComponentPeer) peer).dispose();\n+                    }\n+                }\n+                specialPeerMap.clear();\n+\n+                initialized = false;\n+                timeStampUpdated = false;\n+                timeStamp = 0;\n+                _XA_JAVA_TIME_PROPERTY_ATOM = null;\n+\n+                maxWindowWidthInPixels = -1;\n+                maxWindowHeightInPixels = -1;\n+                dynamicLayoutSetting = false;\n+\n+                arrowCursor = 0;\n+                awt_multiclick_time = 0;\n+                awt_IsXsunKPBehavior = 0;\n+                resetKeyboardSniffer();\n+                xPeer = null;\n+\n+                altMask = 0;\n+                metaMask = 0;\n+                numLockMask = 0;\n+                modeSwitchMask = 0;\n+                modLockIsShiftLock = 0;\n+\n+                localEnv = null;\n+                device = null;\n+                display = 0;\n+            }\n+\n+            \/**\n+             * Initialization of the {@code XToolkit} for proper\n+             * reinitialization of {@code X11GraphicsEnvironment}.\n+             * {@code X11GraphicsEnvironment} depends on this method.\n+             *\n+             * @see sun.awt.X11GraphicsEnvironment\n+             *\/\n+            public void afterRestore() throws Exception {\n+                \/\/ X11\n+                initStatic();\n+                initInternal();\n+\n+                loopUnlock();\n+\n+                XErrorHandlerUtil.afterRestore();\n+                XWM.afterRestore();\n+                XRootWindow.afterRestore();\n+\n+                \/\/ AWT\n+                AWTAccessor.getWindowAccessor().afterRestore();\n+            }\n+        });\n+    }\n+\n+    private static void initStatic() {\n@@ -767,0 +879,15 @@\n+\n+        initSecurityWarning();\n+        if (GraphicsEnvironment.isHeadless()) {\n+            localEnv = null;\n+            device = null;\n+            display = 0;\n+        } else {\n+            localEnv = (X11GraphicsEnvironment) GraphicsEnvironment\n+                    .getLocalGraphicsEnvironment();\n+            device = (X11GraphicsDevice) localEnv.getDefaultScreenDevice();\n+            display = device.getDisplay();\n+            setupModifierMap();\n+            initIDs();\n+            setBackingStoreType();\n+        }\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XToolkit.java","additions":147,"deletions":20,"binary":false,"changes":167,"status":"modified"},{"patch":"@@ -57,0 +57,31 @@\n+    static void beforeCheckpoint() throws Exception {\n+        winmgr_running = false;\n+        awt_wmgr = XWM.UNDETERMINED_WM;\n+\n+        awtWMNonReparenting = -1;\n+        awtWMStaticGravity = -1;\n+\n+        inited = false;\n+        wm = null;\n+        g_net_protocol = null;\n+        g_win_protocol = null;\n+\n+        \/\/ Clear registered XAtoms\n+        XAtom.beforeCheckpoint();\n+    }\n+\n+    static void afterRestore() throws Exception {\n+        XAtom.afterRestore();\n+\n+        \/\/ Initialize the cleared XWM atoms\n+        XA_ENLIGHTENMENT_COMMS = new XAtom(\"ENLIGHTENMENT_COMMS\", false);\n+        XA_DT_SM_WINDOW_INFO = new XAtom(\"_DT_SM_WINDOW_INFO\", false);\n+        XA_DT_SM_STATE_INFO = new XAtom(\"_DT_SM_STATE_INFO\", false);\n+        XA_MOTIF_WM_INFO = new XAtom(\"_MOTIF_WM_INFO\", false);\n+        XA_DT_WORKSPACE_CURRENT = new XAtom(\"_DT_WORKSPACE_CURRENT\", false);\n+        XA_ICEWM_WINOPTHINT = new XAtom(\"_ICEWM_WINOPTHINT\", false);\n+        XA_SUN_WM_PROTOCOLS = new XAtom(\"_SUN_WM_PROTOCOLS\", false);\n+\n+        init();\n+    }\n+\n@@ -419,2 +450,2 @@\n-    static final XAtom XA_DT_SM_WINDOW_INFO = new XAtom(\"_DT_SM_WINDOW_INFO\", false);\n-    static final XAtom XA_DT_SM_STATE_INFO = new XAtom(\"_DT_SM_STATE_INFO\", false);\n+    static XAtom XA_DT_SM_WINDOW_INFO = new XAtom(\"_DT_SM_WINDOW_INFO\", false);\n+    static XAtom XA_DT_SM_STATE_INFO = new XAtom(\"_DT_SM_STATE_INFO\", false);\n@@ -496,2 +527,2 @@\n-    static final XAtom XA_MOTIF_WM_INFO = new XAtom(\"_MOTIF_WM_INFO\", false);\n-    static final XAtom XA_DT_WORKSPACE_CURRENT = new XAtom(\"_DT_WORKSPACE_CURRENT\", false);\n+    static XAtom XA_MOTIF_WM_INFO = new XAtom(\"_MOTIF_WM_INFO\", false);\n+    static XAtom XA_DT_WORKSPACE_CURRENT = new XAtom(\"_DT_WORKSPACE_CURRENT\", false);\n@@ -627,1 +658,1 @@\n-    static final XAtom XA_ICEWM_WINOPTHINT = new XAtom(\"_ICEWM_WINOPTHINT\", false);\n+    static XAtom XA_ICEWM_WINOPTHINT = new XAtom(\"_ICEWM_WINOPTHINT\", false);\n@@ -704,1 +735,1 @@\n-    static final XAtom XA_SUN_WM_PROTOCOLS = new XAtom(\"_SUN_WM_PROTOCOLS\", false);\n+    static XAtom XA_SUN_WM_PROTOCOLS = new XAtom(\"_SUN_WM_PROTOCOLS\", false);\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XWM.java","additions":37,"deletions":6,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -71,0 +71,22 @@\n+\n+    static void beforeCheckpoint() throws Exception {\n+        lastX = 0;\n+        lastY = 0;\n+        lastTime = 0;\n+        lastButton = 0;\n+        lastWindowRef = null;\n+        clickCount = 0;\n+\n+        wm_protocols = null;\n+        wm_delete_window = null;\n+        wm_take_focus = null;\n+\n+        XBaseWindow.beforeCheckpoint();\n+        XGlobalCursorManager.beforeCheckpoint();\n+    }\n+\n+    static void afterRestore() throws Exception {\n+        XGlobalCursorManager.afterRestore();\n+        XBaseWindow.afterRestore();\n+    }\n+\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XWindow.java","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -59,0 +59,27 @@\n+    protected void beforeCheckpoint() throws Exception {\n+        \/\/ Deinitialize AWT and X11\n+        AWTAccessor.getXToolkitAccessor().beforeCheckpoint();\n+\n+        \/\/ Ensure handling of pending disposal references\n+        AWTAccessor.getDisposerAccessor().beforeCheckpoint();\n+\n+        \/\/ XCloseDisplay - disconnect from X11 server\n+        beforeCheckpointNative();\n+    }\n+\n+    protected void afterRestore() throws Exception {\n+        afterRestoreNative();\n+        \/\/ XOpenDisplay - connect to X11 server\n+        initStatic();\n+        \/\/ Reinitialize X11GraphicsEnvironment\n+        init();\n+\n+        AWTAccessor.getDisposerAccessor().afterRestore();\n+\n+        \/\/ Initialize X11 and AWT\n+        AWTAccessor.getXToolkitAccessor().afterRestore();\n+    }\n+\n+    private static native void beforeCheckpointNative();\n+    private static native void afterRestoreNative();\n+\n@@ -60,0 +87,7 @@\n+        initStatic();\n+\n+        \/\/ Install the correct surface manager factory.\n+        SurfaceManagerFactory.setInstance(new UnixSurfaceManagerFactory());\n+    }\n+\n+    private static void initStatic() {\n@@ -130,4 +164,0 @@\n-\n-        \/\/ Install the correct surface manager factory.\n-        SurfaceManagerFactory.setInstance(new UnixSurfaceManagerFactory());\n-\n@@ -136,1 +166,0 @@\n-\n@@ -196,0 +225,4 @@\n+        init();\n+    }\n+\n+    private void init() {\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11GraphicsEnvironment.java","additions":38,"deletions":5,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -126,1 +126,2 @@\n-extern Display         *awt_display; \/* awt_GraphicsEnv.c *\/\n+extern Display         *get_awt_display(void); \/* awt_GraphicsEnv.c *\/\n+#define awt_display     get_awt_display()\n","filename":"src\/java.desktop\/unix\/native\/common\/awt\/awt.h","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -59,0 +59,2 @@\n+#include <pthread.h>\n+\n@@ -69,1 +71,9 @@\n-Display *awt_display;\n+Display *awt_display_storage;\n+pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;\n+Bool crac_lock = False;\n+\n+Display *get_awt_display(void) {\n+    pthread_mutex_lock(&lock);\n+    pthread_mutex_unlock(&lock);\n+    return awt_display_storage;\n+}\n@@ -289,1 +299,1 @@\n-    awt_display = NULL;\n+    awt_display_storage = NULL;\n@@ -715,1 +725,0 @@\n-    int i;\n@@ -717,1 +726,1 @@\n-    if (awt_display) {\n+    if (!crac_lock && awt_display) {\n@@ -739,1 +748,5 @@\n-    dpy = awt_display = XOpenDisplay(NULL);\n+    dpy = awt_display_storage = XOpenDisplay(NULL);\n+    if (crac_lock) {\n+        pthread_mutex_unlock(&lock);\n+        crac_lock = False;\n+    }\n@@ -799,0 +812,13 @@\n+JNIEXPORT void JNICALL\n+Java_sun_awt_X11GraphicsEnvironment_beforeCheckpointNative(JNIEnv *env, jclass this)\n+{\n+    pthread_mutex_lock(&lock);\n+    crac_lock = True;\n+    XCloseDisplay(awt_display_storage);\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_sun_awt_X11GraphicsEnvironment_afterRestoreNative(JNIEnv *env, jclass this)\n+{\n+}\n+\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/awt\/awt_GraphicsEnv.c","additions":31,"deletions":5,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -26,0 +26,3 @@\n+import java.lang.ref.Reference;\n+import java.lang.ref.ReferenceQueue;\n+import java.lang.ref.WeakReference;\n@@ -36,0 +39,36 @@\n+    static class Tuple {\n+        private Object object = new Object();\n+        private ReferenceQueue<WeakReference> queue = new ReferenceQueue<>();\n+        private Reference ref = new WeakReference(object, queue);\n+        private Thread thread;\n+\n+        Tuple(Runnable r) {\n+            thread = new Thread(() -> {\n+                while (true) {\n+                    try {\n+                        queue.remove();\n+                        if (r != null) {\n+                            r.run();\n+                        }\n+                    } catch (InterruptedException e) {\n+                        e.printStackTrace();\n+                    }\n+                }\n+            });\n+            thread.setDaemon(true);\n+            thread.start();\n+        }\n+\n+        Object getObject() {\n+            return object;\n+        }\n+\n+        void clearObject() {\n+            object = null;\n+        }\n+\n+        void waitProcessed() throws InterruptedException {\n+            Misc.waitForQueueProcessed(queue, 1, 0);\n+        }\n+    }\n+\n@@ -43,2 +82,15 @@\n-        \/\/ the cleaner would be able to run right away\n-        cleaner.register(new Object(), () -> {\n+        Tuple[] tuples = new Tuple[10];\n+        for (int i = 0; i < tuples.length - 1; ++i) {\n+            int ii = i;\n+            tuples[i] = new Tuple(() -> {\n+                System.out.println(\"WOKE \" + ii);\n+                tuples[ii + 1].clearObject();\n+            });\n+        }\n+        tuples[tuples.length - 1] = new Tuple(() -> {\n+            System.out.println(\"WOKE \" + (tuples.length - 1));\n+        });\n+\n+        \/\/ the cleaner should run only after user reference processing complete\n+        cleaner.register(tuples[tuples.length - 1].getObject(), () -> {\n+            System.out.println(\"CLEANER\");\n@@ -52,0 +104,28 @@\n+        Resource testResource = new Resource() {\n+            @Override\n+            public void beforeCheckpoint(Context<? extends Resource> context)\n+                throws Exception\n+            {\n+                tuples[0].clearObject();\n+\n+                \/\/ should return quickly: no references yet. But the\n+                \/\/ call is valid.\n+                System.out.println(\"ATTEMPT 1\");\n+                tuples[tuples.length - 1].waitProcessed();\n+\n+                \/\/ Now make sure that all necessary processing has happened.\n+                \/\/ We do this in a way that is specific to this app.\n+                System.out.println(\"ATTEMPT \" + tuples.length);\n+                for (int i = 0; i < tuples.length; ++i) {\n+                    tuples[i].waitProcessed();\n+                }\n+                System.out.println(\"ATTEMPT done\");\n+            }\n+\n+            @Override\n+            public void afterRestore(Context<? extends Resource> context) throws Exception {\n+\n+            }\n+        };\n+        jdk.crac.Core.getGlobalContext().register(testResource);\n+\n","filename":"test\/jdk\/jdk\/crac\/RefQueueTest.java","additions":82,"deletions":2,"binary":false,"changes":84,"status":"modified"}]}