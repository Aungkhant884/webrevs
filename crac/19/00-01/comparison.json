{"files":[{"patch":"@@ -22,1 +22,1 @@\n-      platform_linux_additional: ${{ false && steps.check_platforms.outputs.platform_linux_additional }}\n+      platform_linux_additional: ${{ steps.check_platforms.outputs.platform_linux_additional }}\n@@ -24,4 +24,4 @@\n-      platform_linux_x86: ${{ false && steps.check_platforms.outputs.platform_linux_x86 }}\n-      platform_windows_x64: ${{ false && steps.check_platforms.outputs.platform_windows_x64 }}\n-      platform_macos_x64: ${{ false && steps.check_platforms.outputs.platform_macos_x64 }}\n-      platform_macos_aarch64: ${{ false && steps.check_platforms.outputs.platform_macos_aarch64 }}\n+      platform_linux_x86: ${{ steps.check_platforms.outputs.platform_linux_x86 }}\n+      platform_windows_x64: ${{ steps.check_platforms.outputs.platform_windows_x64 }}\n+      platform_macos_x64: ${{ steps.check_platforms.outputs.platform_macos_x64 }}\n+      platform_macos_aarch64: ${{ steps.check_platforms.outputs.platform_macos_aarch64 }}\n","filename":".github\/workflows\/submit.yml","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,3 +28,0 @@\n-import jdk.crac.Context;\n-import jdk.crac.Resource;\n-import jdk.internal.crac.JDKResource;\n@@ -251,2 +248,0 @@\n-    private static JDKResource referenceHandlerResource;\n-\n@@ -334,7 +329,0 @@\n-        });\n-\n-        referenceHandlerResource = new JDKResource() {\n-            @Override\n-            public Priority getPriority() {\n-                return Priority.REFERENCE_HANDLER;\n-            }\n@@ -343,8 +331,6 @@\n-            public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n-                System.gc();\n-                \/\/ TODO ensure GC done processing all References\n-                while (waitForReferenceProcessing());\n-            }\n-\n-            @Override\n-            public void afterRestore(Context<? extends Resource> context) throws Exception {\n+            public boolean waitForQueueProcessed(ReferenceQueue<?> queue,\n+                                                 int nThreads,\n+                                                 long timeout)\n+                throws InterruptedException\n+            {\n+                return queue.waitForQueueProcessed(nThreads, timeout);\n@@ -352,2 +338,1 @@\n-        };\n-        jdk.internal.crac.Core.getJDKContext().register(referenceHandlerResource);\n+        });\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/Reference.java","additions":7,"deletions":22,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -29,0 +29,3 @@\n+\n+import jdk.internal.access.JavaLangRefAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -59,1 +62,1 @@\n-    private int nWaiters = 0;\n+    private int nBlocked = 0;\n@@ -156,1 +159,1 @@\n-                ++nWaiters;\n+                ++nBlocked;\n@@ -159,1 +162,1 @@\n-                --nWaiters;\n+                --nBlocked;\n@@ -213,3 +216,1 @@\n-     * Blocks calling thread until the specified number of threads are blocked with no reference available.\n-     * @param nWaiters number of threads to wait\n-     * @throws InterruptedException If the wait is interrupted\n+     * See {@link jdk.crac.Misc#waitForQueueProcessed(ReferenceQueue, int, long)}.\n@@ -217,1 +218,35 @@\n-    public void waitForWaiters(int nWaiters) throws InterruptedException {\n+    boolean waitForQueueProcessed(int nThreads, long timeout)\n+        throws InterruptedException\n+    {\n+        JavaLangRefAccess refAccess = SharedSecrets.getJavaLangRefAccess();\n+        long start = (timeout > 0) ? System.nanoTime() : 0;\n+\n+        \/\/ Back-to-back calls of this function are not optimized\n+        \/\/ intentionally.  It's possible to check if the previous call\n+        \/\/ has queued no reference and conclude that there is no need\n+        \/\/ to call GC and wait for reference processing.  But with such\n+        \/\/ optimization we may lose references that were queued because\n+        \/\/ some other code, beside another reference queue processing,\n+        \/\/ caused a referent be unreachable.\n+\n+        System.gc();\n+        \/\/ TODO ensure GC done processing all References\n+\n+        \/\/ should wait for the completion, otherwise the queue may appear\n+        \/\/ empty, although a ref to be about to be enqueued.\n+        while (refAccess.waitForReferenceProcessing());\n+\n+        if (timeout > 0) {\n+            timeout -= (System.nanoTime() - start) \/ 1_000_000;\n+            if (timeout <= 0) {\n+                \/\/ give a chance to detect blocked threads\n+                timeout = -1;\n+            }\n+        }\n+\n+        if (timeout < 0) {\n+            synchronized (lock) {\n+                return head == null && nThreads <= nBlocked;\n+            }\n+        }\n+\n@@ -219,2 +254,9 @@\n-            while (head != null || this.nWaiters < nWaiters) {\n-                lock.wait();\n+            while (head != null || nBlocked < nThreads) {\n+                lock.wait(timeout);\n+                if (timeout != 0) {\n+                    long end = System.nanoTime();\n+                    timeout -= (end - start) \/ 1000_000;\n+                    if (timeout <= 0)\n+                        return false;\n+                    start = end;\n+                }\n@@ -223,0 +265,1 @@\n+        return true;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/ReferenceQueue.java","additions":52,"deletions":9,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -0,0 +1,41 @@\n+package jdk.crac;\n+\n+import jdk.internal.access.SharedSecrets;\n+\n+import java.lang.ref.ReferenceQueue;\n+\n+\/**\n+ * Additional utilities.\n+ *\/\n+public final class Misc {\n+\n+    private Misc() {\n+    }\n+\n+    \/**\n+     * Blocks calling thread until there are no references in the queue and\n+     * the specified number of threads are blocked without a reference to\n+     * process.\n+     * <p>\n+     * Note that {@code timeout} specifies the timeout for threads to block,\n+     * while the total time of this function to complete may be much larger\n+     * that the specified timeout.\n+     *\n+     * @param queue the queue to wait\n+     * @param nThreads number of threads to wait\n+     * @param timeout milliseconds to wait for threads to block, if positive,\n+     *                wait indefinitely, if zero,\n+     *                and, otherwise, just check the condition\n+     * @throws InterruptedException If the wait is interrupted\n+     * @return true if condition was true during the timeout period,\n+     *         otherwise false\n+     *\/\n+    public static boolean waitForQueueProcessed(ReferenceQueue<?> queue,\n+                                                int nThreads,\n+                                                long timeout)\n+        throws InterruptedException\n+    {\n+        return SharedSecrets.getJavaLangRefAccess().\n+            waitForQueueProcessed(queue, nThreads, timeout);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/Misc.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -28,0 +28,2 @@\n+import java.lang.ref.ReferenceQueue;\n+\n@@ -46,0 +48,8 @@\n+\n+    \/**\n+     * See {@link jdk.crac.Misc#waitForQueueProcessed(ReferenceQueue, int, long)}.\n+     *\/\n+    boolean waitForQueueProcessed(ReferenceQueue<?> queue,\n+                                  int nThreads,\n+                                  long timeout)\n+        throws InterruptedException;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangRefAccess.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/Core.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -50,12 +50,0 @@\n-        \/* Keep this priority first to clear and\n-        reinitialize X11 and AWT resources correctly *\/\n-\n-        \/**\n-         * Priority of the\n-         * sun.awt.X11ToolkitJDKResource resource\n-         *\/\n-        X11TOOLKIT,\n-\n-\n-        \/* Use this priority in most cases. *\/\n-\n@@ -64,0 +52,2 @@\n+         *\n+         * @see sun.awt.X11.X11GraphicsEnvironment\n@@ -66,2 +56,0 @@\n-\n-\n@@ -89,2 +77,1 @@\n-\n-        \/* Keep next priorities here to ensure handling of pending References\n+        \/* Keep next priorities last to ensure handling of pending References\n@@ -93,10 +80,0 @@\n-        \/**\n-         * Priority of the\n-         * java.lan.ref.Reference static resource\n-         *\/\n-        REFERENCE_HANDLER,\n-        \/**\n-         * Priority of the\n-         * sun.java2d.Disposer resources\n-         *\/\n-        DISPOSERS,\n@@ -108,10 +85,0 @@\n-\n-\n-        \/* Keep next priority last to reinitialize\n-         X11 connection correctly *\/\n-\n-        \/**\n-         * Priority of the\n-         * sun.awt.X11GEJDKResource resource\n-         *\/\n-        X11GE,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/crac\/JDKResource.java","additions":3,"deletions":36,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -31,2 +31,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -161,2 +159,11 @@\n-    public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n-        queue.waitForWaiters(1);\n+    public void beforeCheckpoint(Context<? extends Resource> context)\n+        throws Exception\n+    {\n+        final long timeout = 1_000; \/\/ reasonable for ref.clean() to finish\n+        while (!phantomCleanableList.isListEmpty() &&\n+               !jdk.crac.Misc.waitForQueueProcessed(queue, 1, timeout)) {\n+            \/\/ This loop reflects the loop in the cleaner handler thread,\n+            \/\/ that allows a race between reference clearing from the list\n+            \/\/ and waiting for the queue. So we need to wait for the queue\n+            \/\/ to be processed with the timeout as well.\n+        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/ref\/CleanerImpl.java","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -42,3 +42,0 @@\n-import jdk.crac.Context;\n-import jdk.crac.Resource;\n-\n@@ -53,16 +50,0 @@\n-    \/**\n-     * Resource nested in {@code X11ToolkitJDKResource}.\n-     *\/\n-    public static final Resource resource = new Resource() {\n-        @Override\n-        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n-            Arrays.fill(predefinedPrivate, null);\n-            Arrays.fill(predefined, null);\n-        }\n-\n-        @Override\n-        public void afterRestore(Context<? extends Resource> context) throws Exception {\n-\n-        }\n-    };\n-\n@@ -226,0 +207,21 @@\n+\n+                \/**\n+                 * Setting to {@code null} predefined {@code Cursor} to reinitialize\n+                 * {@code XToolkit} properly.\n+                 * {@code Window} depends on this method.\n+                 *\n+                 * @see java.awt.Window\n+                 *\/\n+                public void beforeCheckpoint() throws Exception {\n+                    Arrays.fill(predefinedPrivate, null);\n+                    Arrays.fill(predefined, null);\n+                }\n+\n+                \/**\n+                 * {@code Cursor} restoring to reinitialize {@code XToolkit} properly.\n+                 * {@code Window} depends on this method.\n+                 *\n+                 * @see java.awt.Window\n+                 *\/\n+                public void afterRestore() throws Exception {\n+                }\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/Cursor.java","additions":21,"deletions":19,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+import jdk.internal.crac.JDKResource;\n@@ -87,1 +88,1 @@\n-        static GraphicsEnvironment INSTANCE = createGE();\n+        static final GraphicsEnvironment INSTANCE = createGE();\n@@ -105,1 +106,8 @@\n-     * Resource nested in {@code X11GEJDKResource}.\n+     * Reinitialization of the local {@code GraphicsEnvironment}.\n+     *\n+     * This must be done after GC and reference handling,\n+     * because some objects require connection to be disposed.\n+     * It depends on {@code GraphicsEnvironment} extending classes.\n+     *\n+     * @see sun.awt.X11GraphicsEnvironment\n+     * @see jdk.internal.crac.JDKResource\n@@ -107,1 +115,6 @@\n-    public static final Resource resource = new Resource() {\n+    private static final JDKResource jdkResource = new JDKResource() {\n+        @Override\n+        public JDKResource.Priority getPriority() {\n+            return Priority.NORMAL;\n+        }\n+\n@@ -110,1 +123,1 @@\n-            LocalGE.INSTANCE = null;\n+            LocalGE.INSTANCE.beforeCheckpoint();\n@@ -115,1 +128,1 @@\n-            LocalGE.INSTANCE = LocalGE.createGE();\n+            LocalGE.INSTANCE.afterRestore();\n@@ -119,0 +132,30 @@\n+    \/**\n+     * {@code beforeCheckpoint()} operation for\n+     * {@code GraphicsEnvironment} extending classes.\n+     * Should be overridden for proper reinitialization\n+     * of the local {@code GraphicsEnvironment}.\n+     *\n+     * @see sun.awt.X11GraphicsEnvironment\n+     * @throws Exception if not overridden\n+     *\/\n+    protected void beforeCheckpoint() throws Exception {\n+        throw new UnsupportedOperationException(\"Should be overridden.\");\n+    }\n+\n+    \/**\n+     * {@code afterRestore()} operation for\n+     * {@code GraphicsEnvironment} extending classes.\n+     * Should be overridden for proper reinitialization\n+     * of the local {@code GraphicsEnvironment}.\n+     *\n+     * @see sun.awt.X11GraphicsEnvironment\n+     * @throws Exception if not overridden\n+     *\/\n+    protected void afterRestore() throws Exception {\n+        throw new UnsupportedOperationException(\"Should be overridden.\");\n+    }\n+\n+    static {\n+        jdk.internal.crac.Core.getJDKContext().register(jdkResource);\n+    }\n+\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/GraphicsEnvironment.java","additions":48,"deletions":5,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -77,3 +77,0 @@\n-import jdk.crac.Context;\n-import jdk.crac.Resource;\n-\n@@ -172,30 +169,0 @@\n-    \/**\n-     * Resource nested in {@code X11ToolkitJDKResource}.\n-     *\/\n-    public static final Resource resource = new Resource() {\n-        @Override\n-        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n-            for (int i = 0; i < allWindows.size(); i++) {\n-                Window window = allWindows.get(i);\n-\n-                \/\/ Ensure that the window is removed from the\n-                \/\/ AppContext before sun.java2d.Disposer disposed it\n-                window.disposerRecord.dispose();\n-\n-                \/\/ When the last displayable window within the\n-                \/\/ Java virtual machine (VM) is disposed of, the VM may terminate\n-                window.dispose();\n-\n-                \/\/ Let the GC collect this window\n-                window = null;\n-            }\n-\n-            nameCounter = 0;\n-        }\n-\n-        @Override\n-        public void afterRestore(Context<? extends Resource> context) throws Exception {\n-\n-        }\n-    };\n-\n@@ -4154,0 +4121,38 @@\n+\n+            \/**\n+             * {@code Window} disposing to reinitialize {@code XToolkit} properly.\n+             * {@code XToolkit} depends on this method.\n+             *\n+             * @see sun.awt.X11.XToolkit\n+             *\n+             * Note: When the last displayable window within the\n+             * Java virtual machine (VM) is disposed of, the VM may terminate.\n+             *\n+             * @see #dispose\n+             *\/\n+            public void beforeCheckpoint() throws Exception {\n+                for (int i = 0; i < allWindows.size(); i++) {\n+                    Window window = allWindows.get(i);\n+                    \/\/ Ensure that the window is removed from the\n+                    \/\/ AppContext before sun.java2d.Disposer disposed it\n+                    window.disposerRecord.dispose();\n+                    \/\/ When the last displayable window within the\n+                    \/\/ Java virtual machine (VM) is disposed of, the VM may terminate\n+                    window.dispose();\n+                }\n+                nameCounter = 0;\n+\n+                AWTAccessor.getCursorAccessor().beforeCheckpoint();\n+            }\n+\n+            \/**\n+             * {@code Window} restoring to reinitialize {@code XToolkit} properly.\n+             * {@code XToolkit} depends on this method.\n+             *\n+             * TODO: AWT components reinitialization to the original state\n+             *\n+             * @see sun.awt.X11.XToolkit\n+             *\/\n+            public void afterRestore() throws Exception {\n+                AWTAccessor.getCursorAccessor().afterRestore();\n+            }\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/Window.java","additions":38,"deletions":33,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -43,0 +43,3 @@\n+import sun.java2d.Disposer;\n+import sun.awt.X11.XToolkit;\n+\n@@ -289,1 +292,1 @@\n-    public interface WindowAccessor {\n+    public interface WindowAccessor extends CheckpointRestoreAccessor {\n@@ -608,1 +611,1 @@\n-    public interface CursorAccessor {\n+    public interface CursorAccessor extends CheckpointRestoreAccessor {\n@@ -830,0 +833,21 @@\n+    \/**\n+     * An accessor object for the reinitialized\n+     * by CRaC AWT classes.\n+     *\/\n+    private interface CheckpointRestoreAccessor {\n+        void beforeCheckpoint() throws Exception;\n+        void afterRestore() throws Exception;\n+    }\n+\n+    \/**\n+     * An accessor object for the Java2D Disposer class.\n+     *\/\n+    public interface DisposerAccessor extends CheckpointRestoreAccessor {\n+    }\n+\n+    \/**\n+     * An accessor object for the X11 XToolkit class.\n+     *\/\n+    public interface XToolkitAccessor extends CheckpointRestoreAccessor {\n+    }\n+\n@@ -865,0 +889,2 @@\n+    private static DisposerAccessor disposerAccessor;\n+    private static XToolkitAccessor xToolkitAccessor;\n@@ -1398,0 +1424,34 @@\n+    \/*\n+     * Get the accessor object for the sun.java2d.Disposer class.\n+     *\/\n+    public static DisposerAccessor getDisposerAccessor() {\n+        if (disposerAccessor == null) {\n+            ensureClassInitialized(Disposer.class);\n+        }\n+        return disposerAccessor;\n+    }\n+\n+    \/*\n+     * Set the accessor object for the sun.java2d.Disposer class.\n+     *\/\n+    public static void setDisposerAccessor(DisposerAccessor accessor) {\n+        disposerAccessor = accessor;\n+    }\n+\n+    \/*\n+     * Get the accessor object for the sun.awt.X11.XToolkit class.\n+     *\/\n+    public static XToolkitAccessor getXToolkitAccessor() {\n+        if (xToolkitAccessor == null) {\n+            ensureClassInitialized(XToolkit.class);\n+        }\n+        return xToolkitAccessor;\n+    }\n+\n+    \/*\n+     * Set the accessor object for the sun.awt.X11.XToolkit class.\n+     *\/\n+    public static void setXToolkitAccessor(XToolkitAccessor accessor) {\n+        xToolkitAccessor = accessor;\n+    }\n+\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/AWTAccessor.java","additions":62,"deletions":2,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import sun.awt.AWTAccessor;\n+import sun.awt.AWTAccessor.DisposerAccessor;\n@@ -39,4 +41,0 @@\n-import jdk.crac.Context;\n-import jdk.crac.Resource;\n-import jdk.internal.crac.JDKResource;\n-\n@@ -58,1 +56,1 @@\n-public class Disposer implements Runnable, JDKResource {\n+public class Disposer implements Runnable {\n@@ -100,12 +98,11 @@\n-        jdk.internal.crac.Core.getJDKContext().register(disposerInstance);\n-    }\n-\n-    @Override\n-    public Priority getPriority() {\n-        return Priority.DISPOSERS;\n-    }\n-\n-    @Override\n-    public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n-        queue.waitForWaiters(1);\n-    }\n+        AWTAccessor.setDisposerAccessor(new DisposerAccessor() {\n+            public void beforeCheckpoint() throws Exception {\n+                final long timeout = 1_000; \/\/ reasonable for ref.clear() and rec.dispose() to finish\n+                while (!records.isEmpty() &&\n+                        !jdk.crac.Misc.waitForQueueProcessed(queue, 1, timeout)) {\n+                    \/\/ This loop reflects the loop in the disposer handler thread,\n+                    \/\/ that allows a race between reference disposing from the records\n+                    \/\/ and waiting for the queue. So we need to wait for the queue\n+                    \/\/ to be processed with the timeout as well.\n+                }\n+            }\n@@ -113,2 +110,3 @@\n-    @Override\n-    public void afterRestore(Context<? extends Resource> context) throws Exception {\n+            public void afterRestore() throws Exception {\n+            }\n+        });\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/Disposer.java","additions":17,"deletions":19,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -34,2 +34,0 @@\n-    private static X11GEJDKResource x11GEJDKResource;\n-    private static X11ToolkitJDKResource x11ToolkitJDKResource;\n@@ -38,3 +36,0 @@\n-        x11GEJDKResource = new X11GEJDKResource();\n-        jdk.internal.crac.Core.getJDKContext().register(x11GEJDKResource);\n-\n@@ -45,3 +40,0 @@\n-        x11ToolkitJDKResource = new X11ToolkitJDKResource();\n-        jdk.internal.crac.Core.getJDKContext().register(x11ToolkitJDKResource);\n-\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/PlatformGraphicsInfo.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -64,3 +64,0 @@\n-import jdk.crac.Context;\n-import jdk.crac.Resource;\n-\n@@ -147,12 +144,4 @@\n-    \/**\n-     * Resource nested in {@code X11ToolkitJDKResource}.\n-     *\/\n-    public static final Resource resource = new Resource() {\n-        @Override\n-        public void beforeCheckpoint (Context < ? extends Resource > context) throws Exception {\n-            atomToAtom.clear();\n-            nameToAtom.clear();\n-        }\n-\n-        @Override\n-        public void afterRestore (Context < ? extends Resource > context) throws Exception {\n+    static void beforeCheckpoint() throws Exception {\n+        atomToAtom.clear();\n+        nameToAtom.clear();\n+    }\n@@ -160,2 +149,2 @@\n-        }\n-    };\n+    static void afterRestore() throws Exception {\n+    }\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XAtom.java","additions":6,"deletions":17,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -33,3 +33,0 @@\n-import jdk.crac.Context;\n-import jdk.crac.Resource;\n-\n@@ -43,11 +40,3 @@\n-    \/**\n-     * Resource nested in {@code X11ToolkitJDKResource}.\n-     *\/\n-    public static final Resource resource = new Resource() {\n-        @Override\n-        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n-            wm_client_leader = null;\n-        }\n-\n-        @Override\n-        public void afterRestore(Context<? extends Resource> context) throws Exception {\n+    static void beforeCheckpoint() throws Exception {\n+        wm_client_leader = null;\n+    }\n@@ -55,2 +44,2 @@\n-        }\n-    };\n+    static void afterRestore() throws Exception {\n+    }\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XBaseWindow.java","additions":5,"deletions":16,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -96,0 +96,24 @@\n+    \/**\n+     * Setting {@code XErrorHandlerUtil} fields to default values to reinitialize\n+     * {@code XToolkit} properly.\n+     * {@code XToolkit} depends on this method.\n+     *\n+     * @see sun.awt.X11.XToolkit\n+     *\/\n+    static void beforeCheckpoint() throws Exception {\n+        display = 0;\n+        saved_error_handler = 0;\n+        saved_error = null;\n+        current_error_handler = null;\n+        initPassed = false;\n+    }\n+\n+    \/**\n+     * {@code XErrorHandlerUtil} restoring to reinitialize {@code XToolkit} properly.\n+     * {@code XToolkit} depends on this method.\n+     *\n+     * @see sun.awt.X11.XToolkit\n+     *\/\n+    static void afterRestore() throws Exception {\n+    }\n+\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XErrorHandlerUtil.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -36,3 +36,0 @@\n-import jdk.crac.Context;\n-import jdk.crac.Resource;\n-\n@@ -41,11 +38,3 @@\n-    \/**\n-     * Resource nested in {@code X11ToolkitJDKResource}.\n-     *\/\n-    public static final Resource resource = new Resource() {\n-        @Override\n-        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n-            manager = null;\n-        }\n-\n-        @Override\n-        public void afterRestore(Context<? extends Resource> context) throws Exception {\n+    static void beforeCheckpoint() throws Exception {\n+        manager = null;\n+    }\n@@ -53,2 +42,2 @@\n-        }\n-    };\n+    static void afterRestore() throws Exception {\n+    }\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XGlobalCursorManager.java","additions":5,"deletions":16,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -28,3 +28,0 @@\n-import jdk.crac.Context;\n-import jdk.crac.Resource;\n-\n@@ -36,1 +33,1 @@\n-public class XRootWindow extends XBaseWindow {\n+class XRootWindow extends XBaseWindow {\n@@ -50,0 +47,5 @@\n+        private static void deinit() {\n+            LazyHolder.xawtRootWindow.destroy();\n+            LazyHolder.xawtRootWindow = null;\n+        }\n+\n@@ -55,9 +57,2 @@\n-    \/**\n-     * Resource nested in {@code X11ToolkitJDKResource}.\n-     *\/\n-    public static final Resource resource = new Resource() {\n-        @Override\n-        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n-            LazyHolder.xawtRootWindow.destroy();\n-            LazyHolder.xawtRootWindow = null;\n-        }\n+    static void beforeCheckpoint() throws Exception {\n+        LazyHolder.deinit();\n@@ -65,5 +60,8 @@\n-        @Override\n-        public void afterRestore(Context<? extends Resource> context) throws Exception {\n-            LazyHolder.init();\n-        }\n-    };\n+        XWindow.beforeCheckpoint();\n+    }\n+\n+    static void afterRestore() throws Exception {\n+        XWindow.afterRestore();\n+\n+        LazyHolder.init();\n+    }\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XRootWindow.java","additions":16,"deletions":18,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -133,0 +133,1 @@\n+import sun.awt.AWTAccessor.XToolkitAccessor;\n@@ -153,3 +154,0 @@\n-import jdk.crac.Context;\n-import jdk.crac.Resource;\n-\n@@ -221,95 +219,0 @@\n-    \/**\n-     * Resource nested in {@code X11ToolkitJDKResource}.\n-     *\/\n-    public static final Resource resource = new Resource() {\n-        @Override\n-        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n-            awtLock();\n-            state = 1;\n-            while (state != 2) {\n-                awtLockWait(10);\n-            }\n-            awtUnlock();\n-\n-            synchronized (winMap) {\n-                for(XBaseWindow window : winMap.values()) {\n-                    window.destroy();\n-                }\n-                winMap.clear();\n-            }\n-\n-            for(Object peer : specialPeerMap.values()) {\n-                if (peer instanceof XComponentPeer)\n-                    ((XComponentPeer)peer).dispose();\n-            }\n-            specialPeerMap.clear();\n-\n-            synchronized (winToDispatcher) {\n-                winToDispatcher.clear();\n-            }\n-\n-            initialized = false;\n-            timeStampUpdated = false;\n-            timeStamp = 0;\n-            _XA_JAVA_TIME_PROPERTY_ATOM = null;\n-\n-            maxWindowWidthInPixels = -1;\n-            maxWindowHeightInPixels = -1;\n-            dynamicLayoutSetting = false;\n-\n-            arrowCursor = 0;\n-            awt_multiclick_time = 0;\n-            awt_IsXsunKPBehavior = 0;\n-            xPeer = null;\n-\n-            altMask = 0;\n-            metaMask = 0;\n-            numLockMask = 0;\n-            modeSwitchMask = 0;\n-            modLockIsShiftLock = 0;\n-\n-            localEnv = null;\n-            device = null;\n-            display = 0;\n-        }\n-\n-        @Override\n-        public void afterRestore(Context<? extends Resource> context) throws Exception {\n-            initStatic();\n-            resetKeyboardSniffer();\n-            initStaticInternal();\n-\n-            awtLock();\n-            state = 0;\n-            awtLockNotifyAll();\n-            awtUnlock();\n-        }\n-    };\n-\n-    private static void initStatic() {\n-        GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();\n-        if (ge instanceof SunGraphicsEnvironment) {\n-            ((SunGraphicsEnvironment) ge).addDisplayChangedListener(\n-                    displayChangedHandler);\n-        }\n-\n-        initSecurityWarning();\n-        if (GraphicsEnvironment.isHeadless()) {\n-            localEnv = null;\n-            device = null;\n-            display = 0;\n-        } else {\n-            localEnv = (X11GraphicsEnvironment) GraphicsEnvironment\n-                .getLocalGraphicsEnvironment();\n-            device = (X11GraphicsDevice) localEnv.getDefaultScreenDevice();\n-            display = device.getDisplay();\n-            setupModifierMap();\n-            initIDs();\n-            setBackingStoreType();\n-        }\n-    }\n-\n-    static {\n-        initStatic();\n-    }\n-\n@@ -412,1 +315,1 @@\n-    static void initStaticInternal() {\n+    static void initInternal() {\n@@ -454,1 +357,1 @@\n-        initStaticInternal();\n+        initInternal();\n@@ -840,0 +743,21 @@\n+    private static void loopLock() {\n+        try {\n+            awtLock();\n+            state = 1;\n+            while (state != 2) {\n+                awtLockWait(10);\n+            }\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+        } finally {\n+            awtUnlock();\n+        }\n+    }\n+\n+    private static void loopUnlock() {\n+        awtLock();\n+        state = 0;\n+        awtLockNotifyAll();\n+        awtUnlock();\n+    }\n+\n@@ -857,0 +781,115 @@\n+    static {\n+        initStatic();\n+\n+        AWTAccessor.setXToolkitAccessor(new XToolkitAccessor() {\n+            \/**\n+             * Deinitialization of the {@code XToolkit} for proper\n+             * reinitialization of {@code X11GraphicsEnvironment}.\n+             *\n+             * This must be done before GC and reference handling,\n+             * because it may cause some objects to be unreachable.\n+             * Some of disposed objects may require a connection.\n+             * {@code X11GraphicsEnvironment} depends on this method.\n+             *\n+             * @see sun.awt.X11GraphicsEnvironment\n+             *\/\n+            public void beforeCheckpoint() throws Exception {\n+                \/\/ AWT\n+                AWTAccessor.getWindowAccessor().beforeCheckpoint();\n+\n+                \/\/ X11\n+                XRootWindow.beforeCheckpoint();\n+                XWM.beforeCheckpoint();\n+                XErrorHandlerUtil.beforeCheckpoint();\n+\n+                loopLock();\n+\n+                synchronized (winMap) {\n+                    for (XBaseWindow window : winMap.values()) {\n+                        window.destroy();\n+                    }\n+                    winMap.clear();\n+                }\n+                synchronized (winToDispatcher) {\n+                    winToDispatcher.clear();\n+                }\n+                for (Object peer : specialPeerMap.values()) {\n+                    if (peer instanceof XComponentPeer) {\n+                        ((XComponentPeer) peer).dispose();\n+                    }\n+                }\n+                specialPeerMap.clear();\n+\n+                initialized = false;\n+                timeStampUpdated = false;\n+                timeStamp = 0;\n+                _XA_JAVA_TIME_PROPERTY_ATOM = null;\n+\n+                maxWindowWidthInPixels = -1;\n+                maxWindowHeightInPixels = -1;\n+                dynamicLayoutSetting = false;\n+\n+                arrowCursor = 0;\n+                awt_multiclick_time = 0;\n+                awt_IsXsunKPBehavior = 0;\n+                resetKeyboardSniffer();\n+                xPeer = null;\n+\n+                altMask = 0;\n+                metaMask = 0;\n+                numLockMask = 0;\n+                modeSwitchMask = 0;\n+                modLockIsShiftLock = 0;\n+\n+                localEnv = null;\n+                device = null;\n+                display = 0;\n+            }\n+\n+            \/**\n+             * Initialization of the {@code XToolkit} for proper\n+             * reinitialization of {@code X11GraphicsEnvironment}.\n+             * {@code X11GraphicsEnvironment} depends on this method.\n+             *\n+             * @see sun.awt.X11GraphicsEnvironment\n+             *\/\n+            public void afterRestore() throws Exception {\n+                \/\/ X11\n+                initStatic();\n+                initInternal();\n+\n+                loopUnlock();\n+\n+                XErrorHandlerUtil.afterRestore();\n+                XWM.afterRestore();\n+                XRootWindow.afterRestore();\n+\n+                \/\/ AWT\n+                AWTAccessor.getWindowAccessor().afterRestore();\n+            }\n+        });\n+    }\n+\n+    private static void initStatic() {\n+        GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment();\n+        if (ge instanceof SunGraphicsEnvironment) {\n+            ((SunGraphicsEnvironment) ge).addDisplayChangedListener(\n+                    displayChangedHandler);\n+        }\n+\n+        initSecurityWarning();\n+        if (GraphicsEnvironment.isHeadless()) {\n+            localEnv = null;\n+            device = null;\n+            display = 0;\n+        } else {\n+            localEnv = (X11GraphicsEnvironment) GraphicsEnvironment\n+                    .getLocalGraphicsEnvironment();\n+            device = (X11GraphicsDevice) localEnv.getDefaultScreenDevice();\n+            display = device.getDisplay();\n+            setupModifierMap();\n+            initIDs();\n+            setBackingStoreType();\n+        }\n+    }\n+\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XToolkit.java","additions":139,"deletions":100,"binary":false,"changes":239,"status":"modified"},{"patch":"@@ -45,2 +45,0 @@\n-import jdk.crac.Context;\n-import jdk.crac.Resource;\n@@ -52,1 +50,1 @@\n-public final class XWM\n+final class XWM\n@@ -59,48 +57,32 @@\n-    \/**\n-     * Resource nested in {@code X11ToolkitJDKResource}.\n-     *\/\n-    public static final Resource resource = new Resource() {\n-        @Override\n-        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n-            winmgr_running = false;\n-            awt_wmgr = XWM.UNDETERMINED_WM;\n-\n-            awtWMNonReparenting = -1;\n-            awtWMStaticGravity = -1;\n-\n-            wm = null;\n-            g_net_protocol = null;\n-            g_win_protocol = null;\n-            inited = false;\n-        }\n-\n-        @Override\n-        public void afterRestore(Context<? extends Resource> context) throws Exception {\n-            \/\/ Re-register the cleared XWM atoms\n-            XA_MWM_HINTS = new XAtom();\n-            XA_WM_STATE = new XAtom();\n-            XA_E_FRAME_SIZE = new XAtom();\n-            XA_KDE_NET_WM_FRAME_STRUT = new XAtom();\n-            XA_KWM_WIN_ICONIFIED = new XAtom();\n-            XA_KWM_WIN_MAXIMIZED = new XAtom();\n-            XA_OL_DECOR_DEL = new XAtom();\n-            XA_OL_DECOR_HEADER = new XAtom();\n-            XA_OL_DECOR_RESIZE = new XAtom();\n-            XA_OL_DECOR_PIN = new XAtom();\n-            XA_OL_DECOR_CLOSE = new XAtom();\n-            XA_NET_FRAME_EXTENTS = new XAtom();\n-            XA_NET_REQUEST_FRAME_EXTENTS = new XAtom();\n-\n-            XA_ENLIGHTENMENT_COMMS = new XAtom(\"ENLIGHTENMENT_COMMS\", false);\n-            XA_DT_SM_WINDOW_INFO = new XAtom(\"_DT_SM_WINDOW_INFO\", false);\n-            XA_DT_SM_STATE_INFO = new XAtom(\"_DT_SM_STATE_INFO\", false);\n-            XA_MOTIF_WM_INFO = new XAtom(\"_MOTIF_WM_INFO\", false);\n-            XA_DT_WORKSPACE_CURRENT = new XAtom(\"_DT_WORKSPACE_CURRENT\", false);\n-            XA_ICEWM_WINOPTHINT = new XAtom(\"_ICEWM_WINOPTHINT\", false);\n-            XA_SUN_WM_PROTOCOLS = new XAtom(\"_SUN_WM_PROTOCOLS\", false);\n-\n-            init();\n-        }\n-    };\n-\n-    static XAtom XA_MWM_HINTS = new XAtom();\n+    static void beforeCheckpoint() throws Exception {\n+        winmgr_running = false;\n+        awt_wmgr = XWM.UNDETERMINED_WM;\n+\n+        awtWMNonReparenting = -1;\n+        awtWMStaticGravity = -1;\n+\n+        inited = false;\n+        wm = null;\n+        g_net_protocol = null;\n+        g_win_protocol = null;\n+\n+        \/\/ Clear registered XAtoms\n+        XAtom.beforeCheckpoint();\n+    }\n+\n+    static void afterRestore() throws Exception {\n+        XAtom.afterRestore();\n+\n+        \/\/ Initialize the cleared XWM atoms\n+        XA_ENLIGHTENMENT_COMMS = new XAtom(\"ENLIGHTENMENT_COMMS\", false);\n+        XA_DT_SM_WINDOW_INFO = new XAtom(\"_DT_SM_WINDOW_INFO\", false);\n+        XA_DT_SM_STATE_INFO = new XAtom(\"_DT_SM_STATE_INFO\", false);\n+        XA_MOTIF_WM_INFO = new XAtom(\"_MOTIF_WM_INFO\", false);\n+        XA_DT_WORKSPACE_CURRENT = new XAtom(\"_DT_WORKSPACE_CURRENT\", false);\n+        XA_ICEWM_WINOPTHINT = new XAtom(\"_ICEWM_WINOPTHINT\", false);\n+        XA_SUN_WM_PROTOCOLS = new XAtom(\"_SUN_WM_PROTOCOLS\", false);\n+\n+        init();\n+    }\n+\n+    static final XAtom XA_MWM_HINTS = new XAtom();\n@@ -121,1 +103,1 @@\n-    static XAtom XA_E_FRAME_SIZE = new XAtom();\n+    static final XAtom XA_E_FRAME_SIZE = new XAtom();\n@@ -124,1 +106,1 @@\n-    static XAtom XA_KDE_NET_WM_FRAME_STRUT = new XAtom();\n+    static final XAtom XA_KDE_NET_WM_FRAME_STRUT = new XAtom();\n@@ -127,2 +109,2 @@\n-    static XAtom XA_KWM_WIN_ICONIFIED = new XAtom();\n-    static XAtom XA_KWM_WIN_MAXIMIZED = new XAtom();\n+    static final XAtom XA_KWM_WIN_ICONIFIED = new XAtom();\n+    static final XAtom XA_KWM_WIN_MAXIMIZED = new XAtom();\n@@ -131,5 +113,5 @@\n-    static XAtom XA_OL_DECOR_DEL = new XAtom();\n-    static XAtom XA_OL_DECOR_HEADER = new XAtom();\n-    static XAtom XA_OL_DECOR_RESIZE = new XAtom();\n-    static XAtom XA_OL_DECOR_PIN = new XAtom();\n-    static XAtom XA_OL_DECOR_CLOSE = new XAtom();\n+    static final XAtom XA_OL_DECOR_DEL = new XAtom();\n+    static final XAtom XA_OL_DECOR_HEADER = new XAtom();\n+    static final XAtom XA_OL_DECOR_RESIZE = new XAtom();\n+    static final XAtom XA_OL_DECOR_PIN = new XAtom();\n+    static final XAtom XA_OL_DECOR_CLOSE = new XAtom();\n@@ -138,2 +120,2 @@\n-    static XAtom XA_NET_FRAME_EXTENTS = new XAtom();\n-    static XAtom XA_NET_REQUEST_FRAME_EXTENTS = new XAtom();\n+    static final XAtom XA_NET_FRAME_EXTENTS = new XAtom();\n+    static final XAtom XA_NET_REQUEST_FRAME_EXTENTS = new XAtom();\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XWM.java","additions":44,"deletions":62,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -65,4 +65,1 @@\n-import jdk.crac.Context;\n-import jdk.crac.Resource;\n-\n-public class XWindow extends XBaseWindow implements X11ComponentPeer {\n+class XWindow extends XBaseWindow implements X11ComponentPeer {\n@@ -75,13 +72,7 @@\n-    \/**\n-     * Resource nested in {@code X11ToolkitJDKResource}.\n-     *\/\n-    public static final Resource resource = new Resource() {\n-\n-        @Override\n-        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n-            lastX = 0;\n-            lastY = 0;\n-            lastTime = 0;\n-            lastButton = 0;\n-            lastWindowRef = null;\n-            clickCount = 0;\n+    static void beforeCheckpoint() throws Exception {\n+        lastX = 0;\n+        lastY = 0;\n+        lastTime = 0;\n+        lastButton = 0;\n+        lastWindowRef = null;\n+        clickCount = 0;\n@@ -89,4 +80,3 @@\n-            wm_protocols = null;\n-            wm_delete_window = null;\n-            wm_take_focus = null;\n-        }\n+        wm_protocols = null;\n+        wm_delete_window = null;\n+        wm_take_focus = null;\n@@ -94,2 +84,3 @@\n-        @Override\n-        public void afterRestore(Context<? extends Resource> context) throws Exception {\n+        XBaseWindow.beforeCheckpoint();\n+        XGlobalCursorManager.beforeCheckpoint();\n+    }\n@@ -97,2 +88,4 @@\n-        }\n-    };\n+    static void afterRestore() throws Exception {\n+        XGlobalCursorManager.afterRestore();\n+        XBaseWindow.afterRestore();\n+    }\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XWindow.java","additions":18,"deletions":25,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -1,34 +0,0 @@\n-package sun.awt;\n-\n-import jdk.crac.Context;\n-import jdk.crac.Resource;\n-import jdk.internal.crac.JDKResource;\n-\n-import java.awt.GraphicsEnvironment;\n-\n-\n-public class X11GEJDKResource implements JDKResource {\n-\n-    @Override\n-    public Priority getPriority() {\n-        return Priority.X11GE;\n-    }\n-\n-    @Override\n-    public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n-        \/\/ GE\n-        GraphicsEnvironment.resource.beforeCheckpoint(context);\n-\n-        \/\/ X11\n-        X11GraphicsEnvironment.resource.beforeCheckpoint(context);\n-    }\n-\n-    @Override\n-    public void afterRestore(Context<? extends Resource> context) throws Exception {\n-        \/\/ X11\n-        X11GraphicsEnvironment.resource.afterRestore(context);\n-\n-        \/\/ GE\n-        GraphicsEnvironment.resource.afterRestore(context);\n-    }\n-}\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11GEJDKResource.java","additions":0,"deletions":34,"binary":false,"changes":34,"status":"deleted"},{"patch":"@@ -48,3 +48,0 @@\n-import jdk.crac.Context;\n-import jdk.crac.Resource;\n-\n@@ -62,9 +59,3 @@\n-    \/**\n-     * Resource nested in {@code X11GEJDKResource}.\n-     *\/\n-    public static final Resource resource = new Resource() {\n-        @Override\n-        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n-            \/\/ XCloseDisplay\n-            beforeCheckpoint0();\n-        }\n+    protected void beforeCheckpoint() throws Exception {\n+        \/\/ Deinitialize AWT and X11\n+        AWTAccessor.getXToolkitAccessor().beforeCheckpoint();\n@@ -72,6 +63,22 @@\n-        @Override\n-        public void afterRestore(Context<? extends Resource> context) throws Exception {\n-            \/\/ XOpenDisplay\n-            afterRestore0();\n-        }\n-    };\n+        \/\/ Ensure handling of pending disposal references\n+        AWTAccessor.getDisposerAccessor().beforeCheckpoint();\n+\n+        \/\/ XCloseDisplay - disconnect from X11 server\n+        beforeCheckpointNative();\n+    }\n+\n+    protected void afterRestore() throws Exception {\n+        afterRestoreNative();\n+        \/\/ XOpenDisplay - connect to X11 server\n+        initStatic();\n+        \/\/ Reinitialize X11GraphicsEnvironment\n+        init();\n+\n+        AWTAccessor.getDisposerAccessor().afterRestore();\n+\n+        \/\/ Initialize X11 and AWT\n+        AWTAccessor.getXToolkitAccessor().afterRestore();\n+    }\n+\n+    private static native void beforeCheckpointNative();\n+    private static native void afterRestoreNative();\n@@ -80,0 +87,7 @@\n+        initStatic();\n+\n+        \/\/ Install the correct surface manager factory.\n+        SurfaceManagerFactory.setInstance(new UnixSurfaceManagerFactory());\n+    }\n+\n+    private static void initStatic() {\n@@ -150,4 +164,0 @@\n-\n-        \/\/ Install the correct surface manager factory.\n-        SurfaceManagerFactory.setInstance(new UnixSurfaceManagerFactory());\n-\n@@ -156,1 +166,0 @@\n-\n@@ -211,3 +220,0 @@\n-    private static native void beforeCheckpoint0();\n-    private static native void afterRestore0();\n-\n@@ -219,0 +225,4 @@\n+        init();\n+    }\n+\n+    private void init() {\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11GraphicsEnvironment.java","additions":36,"deletions":26,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -1,57 +0,0 @@\n-package sun.awt;\n-\n-import java.awt.Window;\n-import java.awt.Cursor;\n-\n-import sun.awt.X11.XRootWindow;\n-import sun.awt.X11.XWindow;\n-import sun.awt.X11.XBaseWindow;\n-import sun.awt.X11.XGlobalCursorManager;\n-import sun.awt.X11.XWM;\n-import sun.awt.X11.XAtom;\n-import sun.awt.X11.XToolkit;\n-\n-import jdk.crac.Context;\n-import jdk.crac.Resource;\n-import jdk.internal.crac.JDKResource;\n-\n-\n-public class X11ToolkitJDKResource implements JDKResource {\n-\n-    @Override\n-    public Priority getPriority() {\n-        return Priority.X11TOOLKIT;\n-    }\n-\n-    @Override\n-    public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n-        \/\/ AWT\n-        Window.resource.beforeCheckpoint(context);\n-        Cursor.resource.beforeCheckpoint(context);\n-\n-        \/\/ X11\n-        XRootWindow.resource.beforeCheckpoint(context);\n-        XWindow.resource.beforeCheckpoint(context);\n-        XBaseWindow.resource.beforeCheckpoint(context);\n-        XGlobalCursorManager.resource.beforeCheckpoint(context);\n-        XWM.resource.beforeCheckpoint(context);\n-        XAtom.resource.beforeCheckpoint(context);\n-        XToolkit.resource.beforeCheckpoint(context);\n-    }\n-\n-    @Override\n-    public void afterRestore(Context<? extends Resource> context) throws Exception {\n-        \/\/ X11\n-        XToolkit.resource.afterRestore(context);\n-        XAtom.resource.afterRestore(context);\n-        XWM.resource.afterRestore(context);\n-        XGlobalCursorManager.resource.afterRestore(context);\n-        XBaseWindow.resource.afterRestore(context);\n-        XWindow.resource.afterRestore(context);\n-        XRootWindow.resource.afterRestore(context);\n-\n-        \/\/ AWT\n-        Cursor.resource.afterRestore(context);\n-        Window.resource.afterRestore(context);\n-    }\n-}\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11ToolkitJDKResource.java","additions":0,"deletions":57,"binary":false,"changes":57,"status":"deleted"},{"patch":"@@ -72,1 +72,2 @@\n-pthread_mutex_t lock;\n+pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;\n+Bool crac_lock = False;\n@@ -724,1 +725,0 @@\n-    int i;\n@@ -726,1 +726,1 @@\n-    if (awt_display) {\n+    if (!crac_lock && awt_display) {\n@@ -730,2 +730,0 @@\n-    pthread_mutex_init(&lock, NULL);\n-\n@@ -751,0 +749,4 @@\n+    if (crac_lock) {\n+        pthread_mutex_unlock(&lock);\n+        crac_lock = False;\n+    }\n@@ -811,1 +813,1 @@\n-Java_sun_awt_X11GraphicsEnvironment_beforeCheckpoint0(JNIEnv *env, jclass this)\n+Java_sun_awt_X11GraphicsEnvironment_beforeCheckpointNative(JNIEnv *env, jclass this)\n@@ -814,0 +816,1 @@\n+    crac_lock = True;\n@@ -818,1 +821,1 @@\n-Java_sun_awt_X11GraphicsEnvironment_afterRestore0(JNIEnv *env, jclass this)\n+Java_sun_awt_X11GraphicsEnvironment_afterRestoreNative(JNIEnv *env, jclass this)\n@@ -820,2 +823,0 @@\n-    awt_display_storage = XOpenDisplay(NULL);\n-    pthread_mutex_unlock(&lock);\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/awt\/awt_GraphicsEnv.c","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -26,0 +26,3 @@\n+import java.lang.ref.Reference;\n+import java.lang.ref.ReferenceQueue;\n+import java.lang.ref.WeakReference;\n@@ -36,0 +39,36 @@\n+    static class Tuple {\n+        private Object object = new Object();\n+        private ReferenceQueue<WeakReference> queue = new ReferenceQueue<>();\n+        private Reference ref = new WeakReference(object, queue);\n+        private Thread thread;\n+\n+        Tuple(Runnable r) {\n+            thread = new Thread(() -> {\n+                while (true) {\n+                    try {\n+                        queue.remove();\n+                        if (r != null) {\n+                            r.run();\n+                        }\n+                    } catch (InterruptedException e) {\n+                        e.printStackTrace();\n+                    }\n+                }\n+            });\n+            thread.setDaemon(true);\n+            thread.start();\n+        }\n+\n+        Object getObject() {\n+            return object;\n+        }\n+\n+        void clearObject() {\n+            object = null;\n+        }\n+\n+        void waitProcessed() throws InterruptedException {\n+            Misc.waitForQueueProcessed(queue, 1, 0);\n+        }\n+    }\n+\n@@ -43,2 +82,15 @@\n-        \/\/ the cleaner would be able to run right away\n-        cleaner.register(new Object(), () -> {\n+        Tuple[] tuples = new Tuple[10];\n+        for (int i = 0; i < tuples.length - 1; ++i) {\n+            int ii = i;\n+            tuples[i] = new Tuple(() -> {\n+                System.out.println(\"WOKE \" + ii);\n+                tuples[ii + 1].clearObject();\n+            });\n+        }\n+        tuples[tuples.length - 1] = new Tuple(() -> {\n+            System.out.println(\"WOKE \" + (tuples.length - 1));\n+        });\n+\n+        \/\/ the cleaner should run only after user reference processing complete\n+        cleaner.register(tuples[tuples.length - 1].getObject(), () -> {\n+            System.out.println(\"CLEANER\");\n@@ -52,0 +104,28 @@\n+        Resource testResource = new Resource() {\n+            @Override\n+            public void beforeCheckpoint(Context<? extends Resource> context)\n+                throws Exception\n+            {\n+                tuples[0].clearObject();\n+\n+                \/\/ should return quickly: no references yet. But the\n+                \/\/ call is valid.\n+                System.out.println(\"ATTEMPT 1\");\n+                tuples[tuples.length - 1].waitProcessed();\n+\n+                \/\/ Now make sure that all necessary processing has happened.\n+                \/\/ We do this in a way that is specific to this app.\n+                System.out.println(\"ATTEMPT \" + tuples.length);\n+                for (int i = 0; i < tuples.length; ++i) {\n+                    tuples[i].waitProcessed();\n+                }\n+                System.out.println(\"ATTEMPT done\");\n+            }\n+\n+            @Override\n+            public void afterRestore(Context<? extends Resource> context) throws Exception {\n+\n+            }\n+        };\n+        jdk.crac.Core.getGlobalContext().register(testResource);\n+\n","filename":"test\/jdk\/jdk\/crac\/RefQueueTest.java","additions":82,"deletions":2,"binary":false,"changes":84,"status":"modified"}]}