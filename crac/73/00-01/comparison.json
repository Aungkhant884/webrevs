{"files":[{"patch":"@@ -30,1 +30,0 @@\n-import jdk.internal.crac.JDKResource;\n@@ -32,1 +31,0 @@\n-import jdk.internal.ref.CleanerImpl;\n@@ -36,1 +34,0 @@\n-import java.lang.ref.Cleaner;\n@@ -93,5 +90,1 @@\n-            \/\/ This PhantomCleanableRef is not registered in any Context as\n-            \/\/ registration caused by the core CRaC code leads to deadlock.\n-            \/\/ The drawback is native structures may end up in the checkpoint\n-            \/\/ image and be cleaned shortly after restore, which is neglectable.\n-            SharedSecrets.getJavaLangRefAccess().cleanerRegisterWithPriority(CleanerFactory.cleaner(), cs, newContext, null);\n+            CleanerFactory.cleaner().register(cs, newContext);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleNatives.java","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -221,10 +221,1 @@\n-        return new CleanerImpl.PhantomCleanableRef(obj, this, action, JDKResource.Priority.CLEANERS);\n-    }\n-\n-    \/**\n-     * Register an object and action and also register the underlying Reference with a CRaC priority.\n-     *\/\n-    \/*non-public*\/ Cleanable register(Object obj, Runnable action, JDKResource.Priority priority) {\n-        Objects.requireNonNull(obj, \"obj\");\n-        Objects.requireNonNull(action, \"action\");\n-        return new CleanerImpl.PhantomCleanableRef(obj, this, action, priority);\n+        return new CleanerImpl.PhantomCleanableRef(obj, this, action);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/Cleaner.java","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -336,2 +336,7 @@\n-            public java.lang.ref.Cleaner.Cleanable cleanerRegisterWithPriority(java.lang.ref.Cleaner cleaner, Object obj, Runnable action, JDKResource.Priority priority) {\n-                return cleaner.register(obj, action, priority);\n+            public <T> Reference<? extends T> pollReferenceQueue(ReferenceQueue<T> queue, long timeout) throws InterruptedException {\n+                return queue.poll(timeout);\n+            }\n+\n+            @Override\n+            public void wakeupReferenceQueue(ReferenceQueue<?> queue) {\n+                queue.wakeup();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/Reference.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -124,0 +124,16 @@\n+    Reference<? extends T> poll(long timeout) throws InterruptedException {\n+        synchronized (lock) {\n+            Reference<? extends T> r = reallyPoll();\n+            if (r != null) return r;\n+            \/\/ any wake (including spurious) ends the wait\n+            lock.wait(timeout);\n+            return reallyPoll();\n+        }\n+    }\n+\n+    void wakeup() {\n+        synchronized (lock) {\n+            lock.notifyAll();\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/ReferenceQueue.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -28,3 +28,2 @@\n-import jdk.internal.crac.JDKResource;\n-\n-import java.lang.ref.Cleaner;\n+import java.lang.ref.Reference;\n+import java.lang.ref.ReferenceQueue;\n@@ -52,1 +51,6 @@\n-     * Calls package-private {@link Cleaner#register(Object, Runnable, JDKResource.Priority)}.\n+     * Calls package-private {@link ReferenceQueue#poll(long)}.\n+     *\/\n+    <T> Reference<? extends T> pollReferenceQueue(ReferenceQueue<T> queue, long timeout) throws InterruptedException;\n+\n+    \/**\n+     * Calls package-private {@link ReferenceQueue#wakeup()}.\n@@ -54,1 +58,1 @@\n-    Cleaner.Cleanable cleanerRegisterWithPriority(Cleaner cleaner, Object obj, Runnable action, JDKResource.Priority priority);\n+    void wakeupReferenceQueue(ReferenceQueue<?> queue);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangRefAccess.java","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -37,0 +37,2 @@\n+import jdk.internal.access.JavaLangRefAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -51,0 +53,1 @@\n+    private static JavaLangRefAccess javaLangRefAccess = SharedSecrets.getJavaLangRefAccess();\n@@ -60,1 +63,0 @@\n-    Thread thread;\n@@ -116,1 +118,1 @@\n-        thread = threadFactory.newThread(this);\n+        Thread thread = threadFactory.newThread(this);\n@@ -146,0 +148,6 @@\n+                    synchronized (phantomCleanableList) {\n+                        PhantomCleanable<?> next = phantomCleanableList;\n+                        do {\n+                            next = next.cleanIfNull();\n+                        } while (next != phantomCleanableList);\n+                    }\n@@ -161,1 +169,1 @@\n-                Cleanable ref = (Cleanable) queue.remove(60 * 1000L);\n+                Cleanable ref = (Cleanable) javaLangRefAccess.pollReferenceQueue(queue, 60 * 1000L);\n@@ -182,1 +190,1 @@\n-        thread.interrupt();\n+        javaLangRefAccess.wakeupReferenceQueue(queue);\n@@ -196,1 +204,1 @@\n-        return Priority.REFERENCE_HANDLER;\n+        return Priority.CLEANERS;\n@@ -202,1 +210,1 @@\n-    public static final class PhantomCleanableRef extends PhantomCleanable<Object> implements JDKResource {\n+    public static final class PhantomCleanableRef extends PhantomCleanable<Object> {\n@@ -204,1 +212,0 @@\n-        private final JDKResource.Priority priority;\n@@ -211,1 +218,0 @@\n-         * @param priority priority for checkpoint handling\n@@ -213,1 +219,1 @@\n-        public PhantomCleanableRef(Object obj, Cleaner cleaner, Runnable action, JDKResource.Priority priority) {\n+        public PhantomCleanableRef(Object obj, Cleaner cleaner, Runnable action) {\n@@ -216,4 +222,0 @@\n-            this.priority = priority;\n-            if (priority != null) {\n-                jdk.internal.crac.Core.getJDKContext().register(this);\n-            }\n@@ -228,1 +230,0 @@\n-            this.priority = Priority.CLEANERS;\n@@ -256,17 +257,0 @@\n-        @Override\n-        public Priority getPriority() {\n-            return priority;\n-        }\n-\n-        @Override\n-        public void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n-            if (refersTo(null)) {\n-                 clean();\n-            }\n-        }\n-\n-        @Override\n-        public void afterRestore(Context<? extends Resource> context) throws Exception {\n-\n-        }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/ref\/CleanerImpl.java","additions":15,"deletions":31,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -137,0 +137,20 @@\n+    PhantomCleanable<?> cleanIfNull() {\n+        if (this == list) {\n+            \/\/ The reference representing the list itself does not have\n+            \/\/ a referent, we will skip it.\n+            return next;\n+        }\n+        PhantomCleanable<?> oldNext = next;\n+        if (refersTo(null)) {\n+            try {\n+                clean();\n+            } catch (Throwable t) {\n+                \/\/ This method is called only from CleanerImpl and that one\n+                \/\/ ignores any exceptions thrown; we will do the same here.\n+                \/\/ The exception cannot be caught (and ignored) by the caller\n+                \/\/ since we want to continue traversing the list.\n+            }\n+        }\n+        return oldNext;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/ref\/PhantomCleanable.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"}]}