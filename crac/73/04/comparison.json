{"files":[{"patch":"@@ -90,5 +90,1 @@\n-            \/\/ This PhantomCleanableRef is not registered in any Context as\n-            \/\/ registration caused by the core CRaC code leads to deadlock.\n-            \/\/ The drawback is native structures may end up in the checkpoint\n-            \/\/ image and be cleaned shortly after restore, which is neglectable.\n-            SharedSecrets.getJavaLangRefAccess().cleanerRegisterWithPriority(CleanerFactory.cleaner(), cs, newContext, null);\n+            CleanerFactory.cleaner().register(cs, newContext);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleNatives.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -221,10 +221,1 @@\n-        return new CleanerImpl.PhantomCleanableRef(obj, this, action, Core.Priority.CLEANERS);\n-    }\n-\n-    \/**\n-     * Register an object and action and also register the underlying Reference with a CRaC priority.\n-     *\/\n-    \/*non-public*\/ Cleanable register(Object obj, Runnable action, Core.Priority priority) {\n-        Objects.requireNonNull(obj, \"obj\");\n-        Objects.requireNonNull(action, \"action\");\n-        return new CleanerImpl.PhantomCleanableRef(obj, this, action, priority);\n+        return new CleanerImpl.PhantomCleanableRef(obj, this, action);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/Cleaner.java","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -337,2 +337,7 @@\n-            public java.lang.ref.Cleaner.Cleanable cleanerRegisterWithPriority(java.lang.ref.Cleaner cleaner, Object obj, Runnable action, Core.Priority priority) {\n-                return cleaner.register(obj, action, priority);\n+            public <T> Reference<? extends T> pollReferenceQueue(ReferenceQueue<T> queue, long timeout) throws InterruptedException {\n+                return queue.poll(timeout);\n+            }\n+\n+            @Override\n+            public void wakeupReferenceQueue(ReferenceQueue<?> queue) {\n+                queue.wakeup();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/Reference.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -124,0 +124,16 @@\n+    Reference<? extends T> poll(long timeout) throws InterruptedException {\n+        synchronized (lock) {\n+            Reference<? extends T> r = reallyPoll();\n+            if (r != null) return r;\n+            \/\/ any wake (including spurious) ends the wait\n+            lock.wait(timeout);\n+            return reallyPoll();\n+        }\n+    }\n+\n+    void wakeup() {\n+        synchronized (lock) {\n+            lock.notifyAll();\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/ReferenceQueue.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -28,1 +28,2 @@\n-import java.lang.ref.Cleaner;\n+import java.lang.ref.Reference;\n+import java.lang.ref.ReferenceQueue;\n@@ -52,1 +53,1 @@\n-     * Calls package-private {@link Cleaner#register(Object, Runnable, Core.Priority)}.\n+     * Calls package-private {@link ReferenceQueue#poll(long)}.\n@@ -54,1 +55,6 @@\n-    Cleaner.Cleanable cleanerRegisterWithPriority(Cleaner cleaner, Object obj, Runnable action, Core.Priority priority);\n+    <T> Reference<? extends T> pollReferenceQueue(ReferenceQueue<T> queue, long timeout) throws InterruptedException;\n+\n+    \/**\n+     * Calls package-private {@link ReferenceQueue#wakeup()}.\n+     *\/\n+    void wakeupReferenceQueue(ReferenceQueue<?> queue);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangRefAccess.java","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -37,0 +37,2 @@\n+import jdk.internal.access.JavaLangRefAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -45,1 +47,1 @@\n-public final class CleanerImpl implements Runnable {\n+public final class CleanerImpl implements Runnable, JDKResource {\n@@ -51,0 +53,1 @@\n+    private static JavaLangRefAccess javaLangRefAccess = SharedSecrets.getJavaLangRefAccess();\n@@ -60,0 +63,3 @@\n+    volatile boolean forceCleanup = false;\n+    boolean cleanupComplete = false;\n+\n@@ -115,0 +121,1 @@\n+        Core.Priority.CLEANERS.getContext().register(this);\n@@ -139,0 +146,14 @@\n+            if (forceCleanup) {\n+                synchronized (phantomCleanableList) {\n+                    PhantomCleanable<?> next = phantomCleanableList;\n+                    do {\n+                        next = next.cleanIfNull();\n+                    } while (next != phantomCleanableList);\n+                }\n+                synchronized (this) {\n+                    cleanupComplete = true;\n+                    \/\/ prevent looping in the cleanup\n+                    forceCleanup = false;\n+                    notify();\n+                }\n+            }\n@@ -142,1 +163,1 @@\n-                Cleanable ref = (Cleanable) queue.remove(60 * 1000L);\n+                Cleanable ref = (Cleanable) javaLangRefAccess.pollReferenceQueue(queue, 60 * 1000L);\n@@ -153,0 +174,14 @@\n+    @Override\n+    public synchronized void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+        cleanupComplete = false;\n+        forceCleanup = true;\n+        javaLangRefAccess.wakeupReferenceQueue(queue);\n+        while (!cleanupComplete) {\n+            wait();\n+        }\n+    }\n+\n+    @Override\n+    public synchronized void afterRestore(Context<? extends Resource> context) throws Exception {\n+    }\n+\n@@ -156,1 +191,1 @@\n-    public static final class PhantomCleanableRef extends PhantomCleanable<Object> implements JDKResource {\n+    public static final class PhantomCleanableRef extends PhantomCleanable<Object> {\n@@ -164,1 +199,0 @@\n-         * @param priority priority for checkpoint handling\n@@ -166,1 +200,1 @@\n-        public PhantomCleanableRef(Object obj, Cleaner cleaner, Runnable action, Core.Priority priority) {\n+        public PhantomCleanableRef(Object obj, Cleaner cleaner, Runnable action) {\n@@ -169,3 +203,0 @@\n-            if (priority != null) {\n-                priority.getContext().register(this);\n-            }\n@@ -207,12 +238,0 @@\n-        @Override\n-        public void beforeCheckpoint(Context<? extends Resource> context) {\n-            if (refersTo(null)) {\n-                 clean();\n-            }\n-        }\n-\n-        @Override\n-        public void afterRestore(Context<? extends Resource> context) {\n-\n-        }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/ref\/CleanerImpl.java","additions":39,"deletions":20,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -137,0 +137,20 @@\n+    PhantomCleanable<?> cleanIfNull() {\n+        if (this == list) {\n+            \/\/ The reference representing the list itself does not have\n+            \/\/ a referent, we will skip it.\n+            return next;\n+        }\n+        PhantomCleanable<?> oldNext = next;\n+        if (refersTo(null)) {\n+            try {\n+                clean();\n+            } catch (Throwable t) {\n+                \/\/ This method is called only from CleanerImpl and that one\n+                \/\/ ignores any exceptions thrown; we will do the same here.\n+                \/\/ The exception cannot be caught (and ignored) by the caller\n+                \/\/ since we want to continue traversing the list.\n+            }\n+        }\n+        return oldNext;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/ref\/PhantomCleanable.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -131,0 +131,5 @@\n+    static {\n+        \/\/ trigger eager initialization\n+        new FileDispatcherImpl();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/NioSocketImpl.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n@@ -32,0 +34,2 @@\n+import static jdk.test.lib.Asserts.assertTrue;\n+\n@@ -56,4 +60,0 @@\n-            \/\/ FIXME: This test can still spuriously fail when this starts running\n-            \/\/ before C\/R, voiding the PhantomCleanableRef.beforeCheckpoint, but\n-            \/\/ does not finish the close before FileDescriptor finds itself not closed\n-            \/\/ and rightfully throws CheckpointOpenFileException.\n@@ -69,0 +69,8 @@\n+\n+        \/\/ ensure that the cleaner starts working eventually\n+        CountDownLatch latch = new CountDownLatch(1);\n+        cleaner.register(new Object(), () -> {\n+            latch.countDown();\n+        });\n+        System.gc();\n+        assertTrue(latch.await(10, TimeUnit.SECONDS));\n","filename":"test\/jdk\/jdk\/crac\/RefQueueTest.java","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"}]}