{"files":[{"patch":"@@ -31,2 +31,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -37,1 +35,0 @@\n-import jdk.crac.CheckpointException;\n@@ -40,0 +37,1 @@\n+import jdk.internal.crac.Core;\n@@ -47,1 +45,1 @@\n-public final class CleanerImpl implements Runnable {\n+public final class CleanerImpl implements Runnable, JDKResource {\n@@ -62,0 +60,4 @@\n+    Thread thread;\n+    volatile boolean blockForCheckpoint = false;\n+    boolean waitingForCheckpoint = false;\n+\n@@ -114,1 +116,1 @@\n-        Thread thread = threadFactory.newThread(this);\n+        thread = threadFactory.newThread(this);\n@@ -117,0 +119,1 @@\n+        Core.getJDKContext().register(this);\n@@ -141,0 +144,14 @@\n+            if (blockForCheckpoint) {\n+                try {\n+                    synchronized (this) {\n+                        waitingForCheckpoint = true;\n+                        notify();\n+                        while (blockForCheckpoint) {\n+                            wait();\n+                        }\n+                        waitingForCheckpoint = false;\n+                    }\n+                } catch (InterruptedException ignored) {\n+                    \/\/ interruptions are ignored below as well\n+                }\n+            }\n@@ -155,0 +172,27 @@\n+    @Override\n+    public synchronized void beforeCheckpoint(Context<? extends Resource> context) throws Exception {\n+        \/\/ We block the cleaner thread to prevent race conditions between this\n+        \/\/ thread and checkpointing thread invoking clean().\n+        \/\/ When the cleanup starts in cleaner thread the checkpoint will skip\n+        \/\/ it, but without waiting for the cleanup to finish (which might be\n+        \/\/ critical for the checkpoint, e.g. closing FDs).\n+        \/\/ The limitation is that code performing C\/R must not wait on any task\n+        \/\/ completed by the cleaner.\n+        blockForCheckpoint = true;\n+        thread.interrupt();\n+        while (!waitingForCheckpoint) {\n+            wait();\n+        }\n+    }\n+\n+    @Override\n+    public synchronized void afterRestore(Context<? extends Resource> context) throws Exception {\n+        blockForCheckpoint = false;\n+        notify();\n+    }\n+\n+    @Override\n+    public Priority getPriority() {\n+        return Priority.REFERENCE_HANDLER;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/ref\/CleanerImpl.java","additions":49,"deletions":5,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -131,0 +131,5 @@\n+    static {\n+        \/\/ trigger eager initialization\n+        new FileDispatcherImpl();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/NioSocketImpl.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n@@ -32,0 +34,2 @@\n+import static jdk.test.lib.Asserts.assertTrue;\n+\n@@ -56,4 +60,0 @@\n-            \/\/ FIXME: This test can still spuriously fail when this starts running\n-            \/\/ before C\/R, voiding the PhantomCleanableRef.beforeCheckpoint, but\n-            \/\/ does not finish the close before FileDescriptor finds itself not closed\n-            \/\/ and rightfully throws CheckpointOpenFileException.\n@@ -69,0 +69,8 @@\n+\n+        \/\/ ensure that the cleaner starts working eventually\n+        CountDownLatch latch = new CountDownLatch(1);\n+        cleaner.register(new Object(), () -> {\n+            latch.countDown();\n+        });\n+        System.gc();\n+        assertTrue(latch.await(10, TimeUnit.SECONDS));\n","filename":"test\/jdk\/jdk\/crac\/RefQueueTest.java","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"}]}