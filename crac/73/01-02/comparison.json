{"files":[{"patch":"@@ -63,2 +63,2 @@\n-    volatile boolean blockForCheckpoint = false;\n-    boolean waitingForCheckpoint = false;\n+    volatile boolean forceCleanup = false;\n+    boolean cleanupComplete = false;\n@@ -146,1 +146,1 @@\n-            if (blockForCheckpoint) {\n+            if (forceCleanup) {\n@@ -155,1 +155,1 @@\n-                        waitingForCheckpoint = true;\n+                        cleanupComplete = true;\n@@ -157,1 +157,1 @@\n-                        while (blockForCheckpoint) {\n+                        while (forceCleanup) {\n@@ -160,1 +160,1 @@\n-                        waitingForCheckpoint = false;\n+                        cleanupComplete = false;\n@@ -182,8 +182,1 @@\n-        \/\/ We block the cleaner thread to prevent race conditions between this\n-        \/\/ thread and checkpointing thread invoking clean().\n-        \/\/ When the cleanup starts in cleaner thread the checkpoint will skip\n-        \/\/ it, but without waiting for the cleanup to finish (which might be\n-        \/\/ critical for the checkpoint, e.g. closing FDs).\n-        \/\/ The limitation is that code performing C\/R must not wait on any task\n-        \/\/ completed by the cleaner.\n-        blockForCheckpoint = true;\n+        forceCleanup = true;\n@@ -191,1 +184,1 @@\n-        while (!waitingForCheckpoint) {\n+        while (!cleanupComplete) {\n@@ -194,0 +187,2 @@\n+        forceCleanup = false;\n+        notify();\n@@ -198,2 +193,0 @@\n-        blockForCheckpoint = false;\n-        notify();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/ref\/CleanerImpl.java","additions":10,"deletions":17,"binary":false,"changes":27,"status":"modified"}]}