{"files":[{"patch":"@@ -286,2 +286,1 @@\n- private:\n-  int _nprops;\n+  char* _raw_content;\n@@ -291,1 +290,7 @@\n-  int write_check_error(int fd, const void *buf, int count) {\n+  struct header {\n+    jlong _restore_time;\n+    jlong _restore_counter;\n+    int _nprops;\n+  };\n+\n+  static bool write_check_error(int fd, const void *buf, int count) {\n@@ -299,1 +304,1 @@\n-      return wret;\n+      return false;\n@@ -301,1 +306,1 @@\n-    return 0;\n+    return true;\n@@ -304,17 +309,5 @@\n- public:\n-  CracRestoreParameters(const SystemProperty* props, const char *args) :\n-    _nprops(0),\n-    _properties(new (ResourceObj::C_HEAP, mtInternal) GrowableArray<const char *>(0, mtInternal)),\n-    _args(args)\n-  {\n-    const SystemProperty *p = props;\n-    while (p != NULL) {\n-      const char *eq = \"=\";\n-      int prop_len = strlen(p->key()) + strlen(p->value()) + strlen(eq) + 1; \/\/ +1 for null char\n-      char *prop = NEW_C_HEAP_ARRAY(char, prop_len, mtInternal);\n-      strcpy(prop, p->key());\n-      strcat(prop, eq);\n-      strcat(prop, p->value());\n-      _properties->append(prop);\n-      p = p->next();\n-      _nprops += 1;\n+  static int system_props_length(const SystemProperty* props) {\n+    int len = 0;\n+    while (props != NULL) {\n+      ++len;\n+      props = props->next();\n@@ -322,0 +315,1 @@\n+    return len;\n@@ -324,6 +318,1 @@\n-  CracRestoreParameters(int nprops, GrowableArray<const char *>* properties, char *args) :\n-    _nprops(nprops),\n-    _properties(properties),\n-    _args(args)\n-  {}\n-\n+ public:\n@@ -333,0 +322,6 @@\n+  CracRestoreParameters() :\n+    _raw_content(NULL),\n+    _properties(new (ResourceObj::C_HEAP, mtInternal) GrowableArray<const char *>(0, mtInternal)),\n+    _args(NULL)\n+  {}\n+\n@@ -334,5 +329,2 @@\n-    for (int i = 0; i < _properties->length(); i++) {\n-      FREE_C_HEAP_ARRAY(char, _properties->at(i));\n-    }\n-    if (_args) {\n-      FREE_C_HEAP_ARRAY(char, _args);\n+    if (_raw_content) {\n+      FREE_C_HEAP_ARRAY(char, _raw_content);\n@@ -343,11 +335,10 @@\n-  int write_to(int fd) {\n-    int wret = write_check_error(fd, (void *)&_nprops, sizeof(_nprops));\n-\n-    for (int i = 0; i < _properties->length(); i++) {\n-      const char *prop = _properties->at(i);\n-      write_check_error(fd, prop, strlen(prop)+1);\n-    }\n-\n-    wret |= write_check_error(fd, _args, strlen(_args) + 1); \/\/ +1 for null char\n-    return wret;\n-  }\n+  static bool write_to(int fd,\n+      const SystemProperty* props,\n+      const char *args,\n+      jlong restore_time,\n+      jlong restore_counter) {\n+    header hdr = {\n+      restore_time,\n+      restore_counter,\n+      system_props_length(props)\n+    };\n@@ -355,5 +346,2 @@\n-  static CracRestoreParameters* read_from(int fd) {\n-    struct stat st;\n-    if (fstat(fd, &st)) {\n-      perror(\"fstat (ignoring restore parameters)\");\n-      return NULL;\n+    if (!write_check_error(fd, (void *)&hdr, sizeof(header))) {\n+      return false;\n@@ -362,5 +350,9 @@\n-    char *contents = NEW_C_HEAP_ARRAY(char, st.st_size, mtInternal);\n-    if (read(fd, contents, st.st_size) < 0) {\n-      perror(\"read (ignoring restore parameters)\");\n-      FREE_C_HEAP_ARRAY(char, contents);\n-      return NULL;\n+    const SystemProperty* p = props;\n+    while (p != NULL) {\n+      char prop[4096];\n+      int len = snprintf(prop, sizeof(prop), \"%s=%s\", p->key(), p->value());\n+      guarantee((unsigned)len < sizeof(prop), \"property does not fit temp buffer\");\n+      if (!write_check_error(fd, prop, len+1)) {\n+        return false;\n+      }\n+      p = p->next();\n@@ -369,7 +361,2 @@\n-    \/\/ parse the contents to read new system properties and arguments\n-    int nprops = *(int *)contents;\n-    GrowableArray<const char *>* properties = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<const char *>(nprops, mtInternal);\n-\n-    char *cursor = contents + sizeof(_nprops);\n-    for (int i = 0; i < nprops; i++) {\n-      assert((cursor + strlen(cursor) <= contents + st.st_size), \"property length exceeds shared memory size\");\n+    return write_check_error(fd, args, strlen(args)+1); \/\/ +1 for null char\n+  }\n@@ -377,3 +364,1 @@\n-      int prop_len = strlen(cursor) + 1;\n-      char *prop = NEW_C_HEAP_ARRAY(char, prop_len, mtInternal);\n-      strncpy(prop, cursor, prop_len);\n+  bool read_from(int fd);\n@@ -381,10 +366,0 @@\n-      properties->append(prop);\n-      cursor = cursor + prop_len;\n-    }\n-\n-    int argslen = strlen(cursor) + 1;\n-    char *args = NEW_C_HEAP_ARRAY(char, argslen, mtInternal);\n-    strncpy(args, cursor, argslen);\n-    FREE_C_HEAP_ARRAY(char, contents);\n-    return new CracRestoreParameters(nprops, properties, args);\n-  }\n@@ -397,1 +372,1 @@\n-  CracRestoreParameters *_restore_parameters;\n+  CracRestoreParameters _restore_parameters;\n@@ -403,1 +378,1 @@\n-    _restore_parameters(new CracRestoreParameters(NULL, NULL))\n+    _restore_parameters()\n@@ -408,1 +383,0 @@\n-    delete _restore_parameters;\n@@ -413,2 +387,2 @@\n-  const char* new_args() { return _restore_parameters->args(); }\n-  GrowableArray<const char *>* new_properties() { return _restore_parameters->properties(); }\n+  const char* new_args() { return _restore_parameters.args(); }\n+  GrowableArray<const char *>* new_properties() { return _restore_parameters.properties(); }\n@@ -418,1 +392,1 @@\n-  void read_shm(int shmid);\n+  bool read_shm(int shmid);\n@@ -442,2 +416,0 @@\n-static const char* _crengine = NULL;\n-\n@@ -448,0 +420,7 @@\n+\/\/ CRaC\n+static const char* _crengine = NULL;\n+static jlong _restore_start_time;\n+static jlong _restore_start_counter;\n+static FdsInfo _vm_inited_fds(false);\n+static GrowableArray<PersistentResourceDesc>* _persistent_resources = NULL;\n+\n@@ -457,4 +436,0 @@\n-FdsInfo _vm_inited_fds(false);\n-\n-static GrowableArray<PersistentResourceDesc>* _persistent_resources = NULL;\n-\n@@ -5709,0 +5684,16 @@\n+\/\/ CRaC\n+\n+jlong os::Linux::restore_start_time() {\n+  if (!_restore_start_time) {\n+    return -1;\n+  }\n+  return _restore_start_time;\n+}\n+\n+jlong os::Linux::uptime_since_restore() {\n+  if (!_restore_start_counter) {\n+    return -1;\n+  }\n+  return javaTimeNanos() - _restore_start_counter;\n+}\n+\n@@ -5969,6 +5960,8 @@\n-static int setup_shared_memory(int id, CracRestoreParameters& parameters) {\n-  char shmpath[128];\n-  int shmpathlen = snprintf(shmpath, sizeof(shmpath), \"\/crac_%d\", id);\n-  if (shmpathlen < 0 || sizeof(shmpath) <= (size_t)shmpathlen) {\n-    fprintf(stderr, \"shmpath is too long: %d\\n\", shmpathlen);\n-    return -1;\n+class CracSHM {\n+  char _path[128];\n+public:\n+  CracSHM(int id) {\n+    int shmpathlen = snprintf(_path, sizeof(_path), \"\/crac_%d\", id);\n+    if (shmpathlen < 0 || sizeof(_path) <= (size_t)shmpathlen) {\n+      fprintf(stderr, \"shmpath is too long: %d\\n\", shmpathlen);\n+    }\n@@ -5977,2 +5970,3 @@\n-  int shmfd = shm_open(shmpath, O_RDWR | O_CREAT, 0600);\n-  if (-1 == shmfd) {\n+  int open(int mode) {\n+    int shmfd = shm_open(_path, mode, 0600);\n+    if (-1 == shmfd) {\n@@ -5980,1 +5974,2 @@\n-      return -1;\n+    }\n+    return shmfd;\n@@ -5983,6 +5978,2 @@\n-  int rc = parameters.write_to(shmfd);\n-  close(shmfd);\n-\n-  if (rc != 0) {\n-    fprintf(stderr, \"write to shared memory failed\");\n-    return -1;\n+  void unlink() {\n+    shm_unlink(_path);\n@@ -5990,3 +5981,1 @@\n-\n-  return 0;\n-}\n+};\n@@ -6133,20 +6122,10 @@\n-void VM_Crac::read_shm(int shmid) {\n-    char shmpath[128];\n-    snprintf(shmpath, sizeof(shmpath), \"\/crac_%d\", shmid);\n-\n-    int shmfd = shm_open(shmpath, O_RDONLY, 0600);\n-    if (-1 == shmfd) {\n-      perror(\"shm_open (ignoring new args)\");\n-      return;\n-    }\n-\n-    shm_unlink(shmpath);\n-\n-    CracRestoreParameters* new_parameters = CracRestoreParameters::read_from(shmfd);\n-    if (new_parameters) {\n-      delete _restore_parameters;\n-      _restore_parameters = new_parameters;\n-    }\n-\n-    close(shmfd);\n-    return;\n+bool VM_Crac::read_shm(int shmid) {\n+  CracSHM shm(shmid);\n+  int shmfd = shm.open(O_RDONLY);\n+  shm.unlink();\n+  if (shmfd < 0) {\n+    return false;\n+  }\n+  bool ret = _restore_parameters.read_from(shmfd);\n+  close(shmfd);\n+  return ret;\n@@ -6254,1 +6233,4 @@\n-  read_shm(shmid);\n+  if (shmid <= 0 || !VM_Crac::read_shm(shmid)) {\n+    _restore_start_time = os::javaTimeMillis();\n+    _restore_start_counter = os::javaTimeNanos();\n+  }\n@@ -6403,0 +6385,3 @@\n+  jlong restore_time = javaTimeMillis();\n+  jlong restore_counter = javaTimeNanos();\n+\n@@ -6406,5 +6391,14 @@\n-  SystemProperty* props = Arguments::system_properties();\n-  const char* args = Arguments::java_command() ? Arguments::java_command() : \"\";\n-  CracRestoreParameters restore_parameters(props, args);\n-  if (setup_shared_memory(id, restore_parameters)) {\n-    id = 0;\n+  CracSHM shm(id);\n+  int shmfd = shm.open(O_RDWR | O_CREAT);\n+  if (0 <= shmfd) {\n+    if (CracRestoreParameters::write_to(\n+          shmfd,\n+          Arguments::system_properties(),\n+          Arguments::java_command() ? Arguments::java_command() : \"\",\n+          restore_time,\n+          restore_counter)) {\n+      char strid[32];\n+      snprintf(strid, sizeof(strid), \"%d\", id);\n+      setenv(\"CRAC_NEW_ARGS_ID\", strid, true);\n+    }\n+    close(shmfd);\n@@ -6413,3 +6407,0 @@\n-  char strid[32];\n-  snprintf(strid, sizeof(strid), \"%d\", id);\n-  setenv(\"CRAC_NEW_ARGS_ID\", strid, true);\n@@ -6423,0 +6414,35 @@\n+bool CracRestoreParameters::read_from(int fd) {\n+  struct stat st;\n+  if (fstat(fd, &st)) {\n+    perror(\"fstat (ignoring restore parameters)\");\n+    return false;\n+  }\n+\n+  char *contents = NEW_C_HEAP_ARRAY(char, st.st_size, mtInternal);\n+  if (read(fd, contents, st.st_size) < 0) {\n+    perror(\"read (ignoring restore parameters)\");\n+    FREE_C_HEAP_ARRAY(char, contents);\n+    return false;\n+  }\n+\n+  _raw_content = contents;\n+\n+  \/\/ parse the contents to read new system properties and arguments\n+  header* hdr = (header*)_raw_content;\n+  char* cursor = _raw_content + sizeof(header);\n+\n+  ::_restore_start_time = hdr->_restore_time;\n+  ::_restore_start_counter = hdr->_restore_counter;\n+\n+  for (int i = 0; i < hdr->_nprops; i++) {\n+    assert((cursor + strlen(cursor) <= contents + st.st_size), \"property length exceeds shared memory size\");\n+    int idx = _properties->append(cursor);\n+    int prop_len = strlen(cursor) + 1;\n+    cursor = cursor + prop_len;\n+  }\n+\n+  _args = cursor;\n+  return true;\n+}\n+\n+\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":159,"deletions":133,"binary":false,"changes":292,"status":"modified"},{"patch":"@@ -181,0 +181,3 @@\n+  static jlong restore_start_time();\n+  static jlong uptime_since_restore();\n+\n","filename":"src\/hotspot\/os\/linux\/os_linux.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -83,0 +83,2 @@\n+  JMM_JVM_RESTORE_START_TIME_MS      = 12,   \/* Time when the JVM started restore operation *\/\n+  JMM_JVM_UPTIME_SINCE_RESTORE_MS    = 13,   \/* The JVM uptime since restore *\/\n","filename":"src\/hotspot\/share\/include\/jmm.h","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -956,0 +956,12 @@\n+  case JMM_JVM_RESTORE_START_TIME_MS:\n+    return os::Linux::restore_start_time();\n+\n+  case JMM_JVM_UPTIME_SINCE_RESTORE_MS:\n+    {\n+      jlong ticks = os::Linux::uptime_since_restore();\n+      if (ticks == -1) {\n+        return -1;\n+      }\n+      return Management::ticks_to_ms(ticks);\n+    }\n+\n","filename":"src\/hotspot\/share\/services\/management.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -108,0 +108,4 @@\n+\n+    \/\/ CRaC support\n+    public long getRestoreTime();\n+    public long getUptimeSinceRestore();\n","filename":"src\/java.management\/share\/classes\/sun\/management\/VMManagement.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -285,0 +285,12 @@\n+\n+    \/\/ CRaC support\n+    private native long getRestoreTime0();\n+    private native long getUptimeSinceRestore0();\n+\n+    public long getRestoreTime() {\n+        return getRestoreTime0();\n+    }\n+\n+    public long getUptimeSinceRestore() {\n+        return getUptimeSinceRestore0();\n+    }\n","filename":"src\/java.management\/share\/classes\/sun\/management\/VMManagementImpl.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -325,0 +325,16 @@\n+\n+JNIEXPORT jlong JNICALL\n+Java_sun_management_VMManagementImpl_getRestoreTime0\n+  (JNIEnv *env, jobject dummy)\n+{\n+    return jmm_interface->GetLongAttribute(env, NULL,\n+                                           JMM_JVM_RESTORE_START_TIME_MS);\n+}\n+\n+JNIEXPORT jlong JNICALL\n+Java_sun_management_VMManagementImpl_getUptimeSinceRestore0\n+  (JNIEnv *env, jobject dummy)\n+{\n+    return jmm_interface->GetLongAttribute(env, NULL,\n+                                           JMM_JVM_UPTIME_SINCE_RESTORE_MS);\n+}\n","filename":"src\/java.management\/share\/native\/libmanagement\/VMManagementImpl.c","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import jdk.crac.management.CRaCMXBean;\n@@ -44,0 +45,2 @@\n+\n+import jdk.crac.management.internal.CRaCImpl;\n@@ -56,0 +59,5 @@\n+    \/\/ CRaC\n+    private static CRaCMXBean cracMXBean = null;\n+    public static final String CRAC_MXBEAN_NAME =\n+        \"jdk.management:type=CRaC\";\n+\n@@ -267,0 +275,30 @@\n+        \/**\n+         * CRaC MXBean\n+         *\/\n+        initMBeanList.add(new PlatformComponent<CRaCMXBean>() {\n+            private final Set<String> cracMXBeanInterfaceNames =\n+                Collections.singleton(\"jdk.crac.management.CRaCMXBean\");\n+\n+            @Override\n+            public Set<Class<? extends CRaCMXBean>> mbeanInterfaces() {\n+                return Collections.singleton(CRaCMXBean.class);\n+            }\n+\n+            @Override\n+            public Set<String> mbeanInterfaceNames() {\n+                return cracMXBeanInterfaceNames;\n+            }\n+\n+            @Override\n+            public String getObjectNamePattern() {\n+                return CRAC_MXBEAN_NAME;\n+            }\n+\n+            @Override\n+            public Map<String, CRaCMXBean> nameToMBeanMap() {\n+                return Collections.<String, CRaCMXBean>singletonMap(\n+                    CRAC_MXBEAN_NAME,\n+                    getCRaCMXBean());\n+            }\n+        });\n+\n@@ -284,0 +322,7 @@\n+\n+    private static synchronized CRaCMXBean getCRaCMXBean() {\n+        if (cracMXBean == null) {\n+            cracMXBean = new CRaCImpl(ManagementFactoryHelper.getVMManagement());\n+        }\n+        return cracMXBean;\n+    }\n","filename":"src\/jdk.management\/share\/classes\/com\/sun\/management\/internal\/PlatformMBeanProviderImpl.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2022, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.crac.management;\n+\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.PlatformManagedObject;\n+import java.lang.management.RuntimeMXBean;\n+\n+\/**\n+ * Management interface for the CRaC functionality of the Java virtual machine.\n+ *\/\n+public interface CRaCMXBean extends PlatformManagedObject {\n+\n+    \/**\n+     * Returns the time since the Java virtual machine restore was initiated.\n+     * If the machine was not restored, returns -1.\n+     *\n+     * @see RuntimeMXBean#getStartTime()\n+     * @return uptime of the Java virtual machine in milliseconds.\n+     *\/\n+    public long getUptimeSinceRestore();\n+\n+    \/**\n+     * Returns the time when the Java virtual machine restore was initiated.\n+     * The value is the number of milliseconds since the start of the epoch.\n+     * If the machine was not restored, returns -1.\n+     *\n+     * @see RuntimeMXBean#getUptime()\n+     * @return start time of the Java virtual machine in milliseconds.\n+     *\/\n+    public long getRestoreTime();\n+\n+    \/**\n+     * Returns the implementation of the MXBean.\n+     *\n+     * @return implementation of the MXBean.\n+     *\/\n+    public static CRaCMXBean getCRaCMXBean() {\n+        return ManagementFactory.getPlatformMXBean(CRaCMXBean.class);\n+    }\n+\n+}\n","filename":"src\/jdk.management\/share\/classes\/jdk\/crac\/management\/CRaCMXBean.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2022, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.crac.management.internal;\n+\n+import com.sun.management.internal.PlatformMBeanProviderImpl;\n+import jdk.crac.management.CRaCMXBean;\n+import sun.management.Util;\n+import sun.management.VMManagement;\n+\n+import javax.management.ObjectName;\n+\n+public class CRaCImpl implements CRaCMXBean {\n+    private final VMManagement vm;\n+\n+    public CRaCImpl(VMManagement vm) {\n+        this.vm = vm;\n+    }\n+\n+    @Override\n+    public long getUptimeSinceRestore() {\n+        return vm.getUptimeSinceRestore();\n+    }\n+\n+    @Override\n+    public long getRestoreTime() {\n+        return vm.getRestoreTime();\n+    }\n+\n+    @Override\n+    public ObjectName getObjectName() {\n+        return Util.newObjectName(PlatformMBeanProviderImpl.CRAC_MXBEAN_NAME);\n+    }\n+}\n","filename":"src\/jdk.management\/share\/classes\/jdk\/crac\/management\/internal\/CRaCImpl.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2022, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * This package contains management interfaces for CRaC.\n+ *\/\n+\n+package jdk.crac.management;\n","filename":"src\/jdk.management\/share\/classes\/jdk\/crac\/management\/package-info.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -36,0 +36,1 @@\n+    exports jdk.crac.management;\n@@ -40,1 +41,0 @@\n-\n","filename":"src\/jdk.management\/share\/classes\/module-info.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2022, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.crac.*;\n+import jdk.crac.management.*;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import java.lang.management.ManagementFactory;\n+import java.time.Instant;\n+import java.time.ZoneId;\n+import java.time.format.DateTimeFormatter;\n+\n+\/**\n+ * @test\n+ * @library \/test\/lib\n+ * @run main MXBean\n+ *\/\n+public class MXBean {\n+    static final long TIME_TOLERANCE = 10_000; \/\/ ms\n+\n+    static class Test {\n+        public static void main(String[] args) throws CheckpointException, RestoreException {\n+            CRaCMXBean cracMXBean = CRaCMXBean.getCRaCMXBean();\n+\n+            Core.checkpointRestore();\n+\n+            System.out.println(\"UptimeSinceRestore \" + cracMXBean.getUptimeSinceRestore());\n+\n+            long restoreTime = cracMXBean.getRestoreTime();\n+            System.out.println(\"RestoreTime \" + restoreTime + \" \" +\n+                DateTimeFormatter.ofPattern(\"E dd LLL yyyy HH:mm:ss.n\").format(\n+                    Instant.ofEpochMilli(restoreTime)\n+                        .atZone(ZoneId.systemDefault())));\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        long start = System.currentTimeMillis();\n+\n+        OutputAnalyzer output;\n+        try {\n+            output = ProcessTools.executeTestJvm(\n+                \"-XX:CREngine=simengine\", \"-XX:CRaCCheckpointTo=.\/cr\",\n+                \"MXBean$Test\");\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+\n+        output.shouldHaveExitValue(0);\n+\n+        long restoreUptime = Long.parseLong(output.firstMatch(\"UptimeSinceRestore ([0-9-]+)\", 1));\n+        if (restoreUptime < 0 || TIME_TOLERANCE < restoreUptime) {\n+            throw new Error(\"bad UptimeSinceRestore: \" + restoreUptime);\n+        }\n+\n+        long restoreTime = Long.parseLong(output.firstMatch(\"RestoreTime ([0-9-]+)\", 1));\n+        restoreTime -= start;\n+\n+        if (restoreTime < -TIME_TOLERANCE || TIME_TOLERANCE < restoreTime) {\n+            throw new Error(\"bad RestoreTime: \" + restoreTime);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/crac\/MXBean.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"}]}