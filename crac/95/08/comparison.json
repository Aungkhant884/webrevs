{"files":[{"patch":"@@ -69,1 +69,0 @@\n-static BufferBlob* stub_blob;\n@@ -2806,3 +2805,6 @@\n-  \/\/ Making this stub must be FIRST use of assembler\n-  stub_blob = BufferBlob::create(\"VM_Version stub\", stub_size);\n-  if (stub_blob == nullptr) {\n+  \/\/ With CRaC, the generated code is used early after restore from checkpoint,\n+  \/\/ before CodeCache is restored. Therefore we need to allocate the memory\n+  \/\/ outside CodeCache.\n+  size_t aligned_size = align_up(stub_size, os::vm_page_size());\n+  char *stub_memory = os::reserve_memory(aligned_size, true, mtCode);\n+  if (stub_memory == nullptr || !os::commit_memory(stub_memory, aligned_size, true)) {\n@@ -2811,1 +2813,1 @@\n-  CodeBuffer c(stub_blob);\n+  CodeBuffer c((address) stub_memory, aligned_size);\n@@ -2921,1 +2923,0 @@\n-static BufferBlob* cpuid_brand_string_stub_blob;\n@@ -3225,2 +3226,3 @@\n-  cpuid_brand_string_stub_blob = BufferBlob::create(\"getCPUIDBrandString_stub\", cpuid_brand_string_stub_size);\n-  if (cpuid_brand_string_stub_blob == nullptr) {\n+  size_t aligned_size = align_up(cpuid_brand_string_stub_size, os::vm_page_size());\n+  char *stub_memory = os::reserve_memory(aligned_size, true, mtCode);\n+  if (stub_memory == nullptr || !os::commit_memory(stub_memory, aligned_size, true)) {\n@@ -3229,1 +3231,1 @@\n-  CodeBuffer c(cpuid_brand_string_stub_blob);\n+  CodeBuffer c((address) stub_memory, aligned_size);\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"gc\/shared\/collectedHeap.hpp\"\n@@ -26,0 +27,2 @@\n+#include \"memory\/universe.hpp\"\n+#include \"memory\/metaspace\/virtualSpaceList.hpp\"\n@@ -30,0 +33,4 @@\n+#include \"runtime\/osThread.hpp\"\n+#include \"runtime\/threads.hpp\"\n+#include \"runtime\/threadSMR.hpp\"\n+#include \"runtime\/threadSMR.inline.hpp\"\n@@ -34,0 +41,12 @@\n+#include <linux\/futex.h>\n+#include <linux\/rseq.h>\n+#include <pthread.h>\n+#include <stdint.h>\n+#include <string.h>\n+#include <sys\/mman.h>\n+#include <sys\/prctl.h>\n+#include <sys\/ptrace.h>\n+#include <sys\/syscall.h>\n+#include <sys\/wait.h>\n+#include <unistd.h>\n+\n@@ -343,0 +362,21 @@\n+static bool check_can_write() {\n+  char path[PATH_MAX];\n+  snprintf(path, PATH_MAX, \"%s%s.test\", CRaCCheckpointTo, os::file_separator());\n+  int fd = os::open(path, O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR);\n+  if (fd < 0) {\n+    tty->print_cr(\"Cannot create %s: %s\\n\", path, os::strerror(errno));\n+    return false;\n+  }\n+  bool success = write(fd, \"test\", 4) > 0;\n+  if (!success) {\n+    tty->print_cr(\"Cannot write to %s: %s\\n\", path, os::strerror(errno));\n+  }\n+  if (::close(fd)) {\n+    tty->print_cr(\"Cannot close %s: %s\", path, os::strerror(errno));\n+  }\n+  if (::unlink(path)) {\n+    tty->print_cr(\"Cannot remove %s: %s\", path, os::strerror(errno));\n+  }\n+  return success;\n+}\n+\n@@ -344,0 +384,17 @@\n+  if (CRPersistMemory) {\n+    \/\/ Check early if the checkpoint directory is writable; from this point\n+    \/\/ we won't be able to go back\n+    if (!check_can_write()) {\n+      return false;\n+    }\n+    crac::MemoryPersister::init();\n+    Universe::heap()->persist_for_checkpoint();\n+    metaspace::VirtualSpaceList *vsc = metaspace::VirtualSpaceList::vslist_class();\n+    if (vsc != nullptr) {\n+      vsc->persist_for_checkpoint();\n+    }\n+    metaspace::VirtualSpaceList *vsn = metaspace::VirtualSpaceList::vslist_nonclass();\n+    if (vsn != nullptr) {\n+      vsn->persist_for_checkpoint();\n+    }\n+  }\n@@ -423,17 +480,0 @@\n-static bool read_all(int fd, char *dest, size_t n) {\n-  size_t rd = 0;\n-  do {\n-    ssize_t r = ::read(fd, dest + rd, n - rd);\n-    if (r == 0) {\n-      return false;\n-    } else if (r < 0) {\n-      if (errno == EINTR) {\n-        continue;\n-      }\n-      return false;\n-    }\n-    rd += r;\n-  } while (rd < n);\n-  return true;\n-}\n-\n@@ -460,0 +500,274 @@\n+\n+bool crac::MemoryPersister::unmap(void *addr, size_t length) {\n+  while (::munmap(addr, length) != 0) {\n+    if (errno != EINTR) {\n+      perror(\"::munmap\");\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n+bool crac::MemoryPersister::map(void *addr, size_t length, bool executable) {\n+  while (::mmap(addr, length, PROT_READ | PROT_WRITE | (executable ? PROT_EXEC : 0),\n+      MAP_PRIVATE | MAP_FIXED | MAP_ANONYMOUS, -1 , 0) != addr) {\n+    if (errno != EINTR) {\n+      fprintf(stderr, \"::mmap %p %zu RW: %m\\n\", addr, length);\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n+bool crac::MemoryPersister::map_gap(void *addr, size_t length) {\n+  while (::mmap(addr, length, PROT_NONE, MAP_PRIVATE | MAP_FIXED | MAP_ANONYMOUS, -1, 0) != addr) {\n+    if (errno != EINTR) {\n+      perror(\"::mmap NONE\");\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n+void crac::MmappingMemoryReader::read(size_t offset, void *addr, size_t size, bool executable) {\n+  assert(_fd >= 0, \"File not open!\");\n+  if (::mmap(addr, size, PROT_READ | PROT_WRITE | (executable ? PROT_EXEC : 0),\n+      MAP_PRIVATE | MAP_FIXED, _fd , offset) != addr) {\n+    fatal(\"::mmap %p %zu RW(X): %s\", addr, size, os::strerror(errno));\n+  }\n+}\n+\n+static volatile int persist_waiters = 0;\n+static volatile int persist_futex = 0;\n+\n+#if __GLIBC__ >= 2 && __GLIBC_MINOR__ >= 35\n+#define HAS_RSEQ\n+#endif\n+\n+#ifdef HAS_RSEQ\n+static struct __ptrace_rseq_configuration *rseq_configs = nullptr;\n+#endif\n+\n+static void block_in_other_futex(int signal, siginfo_t *info, void *ctx) {\n+#ifdef HAS_RSEQ\n+  struct __ptrace_rseq_configuration *rseqc = &rseq_configs[info->si_value.sival_int];\n+  if (rseqc->rseq_abi_pointer) {\n+    \/\/ Unregister rseq to prevent CRIU reading the configuration\n+    if (syscall(SYS_rseq, (void *) rseqc->rseq_abi_pointer, rseqc->rseq_abi_size, RSEQ_FLAG_UNREGISTER, rseqc->signature)) {\n+      perror(\"Unregister rseq\");\n+    }\n+  }\n+#endif \/\/ HAS_RSEQ\n+\n+  Atomic::add(&persist_waiters, 1);\n+  \/\/ From now on the code must not use stack variables!\n+  int retval = 0;\n+#ifdef AMD64\n+  asm volatile (\n+    \"mov $0, %%r8\\n\\t\"\n+    \"mov $0, %%r9\\n\\t\"\n+    \"mov $0, %%r10\\n\\t\"\n+    \".begin: mov %[sysnum], %%eax\\n\\t\"\n+    \"syscall\\n\\t\"\n+    \"test %%rax, %%rax\\n\\t\" \/\/ exit the loop on error\n+    \"jnz .end\\n\\t\"\n+    \"mov (%%rdi), %%ecx\\n\\t\"\n+    \"test %%ecx, %%ecx\\n\\t\"\n+    \"jnz .begin\\n\\t\"\n+    \".end: nop\\n\\t\"\n+    : \"=a\"(retval)\n+    : [sysnum]\"i\"(SYS_futex), \"D\"(&persist_futex), \"S\"(FUTEX_WAIT_PRIVATE), \"d\"(1)\n+    : \"memory\", \"cc\", \"rcx\", \"r8\", \"r9\", \"r10\", \"r11\");\n+#elif IA32\n+  asm volatile (\n+    \"mov $0, %%esi\\n\\t\"\n+    \"mov $0, %%edi\\n\\t\"\n+    \/\/ note: ebp (6th param) should be zero-ed as well, but GCC does not allow to clobber it\n+    \".begin: mov %[sysnum], %%eax\\n\\t\"\n+    \"int $0x80\\n\\t\"\n+    \"test %%eax, %%eax\\n\\t\" \/\/ exit the loop on error\n+    \"jnz .end\\n\\t\"\n+    \"mov (%%ebx), %%esi\\n\\t\"\n+    \"test %%esi, %%esi\\n\\t\"\n+    \"jnz .begin\\n\\t\"\n+    \".end: nop\\n\\t\"\n+    : \"=a\"(retval)\n+    : [sysnum]\"i\"(SYS_futex), \"b\"(&persist_futex), \"c\"(FUTEX_WAIT_PRIVATE), \"d\"(1)\n+    : \"memory\", \"cc\", \"esi\", \"edi\");\n+#elif defined(AARCH64)\n+  register volatile int *futex asm(\"x7\") = &persist_futex;\n+  asm volatile (\n+    \"mov x1, %[op]\\n\\t\"\n+    \"mov x2, 1\\n\\t\"\n+    \"mov x4, xzr\\n\\t\"\n+    \"mov x5, xzr\\n\\t\"\n+    \"mov x8, %[sysnum]\\n\\t\"\n+    \".begin: mov x0, %[futex]\\n\\t\"\n+    \"mov x3, xzr\\n\\t\"\n+    \"svc #0\\n\\t\"\n+    \"cbnz x0, .end\\n\\t\" \/\/ exit the loop on error\n+    \"ldr w3, [%[futex]]\\n\\t\"\n+    \"cbnz w3, .begin\\n\\t\"\n+    \".end: mov %[retval], x0\\n\\t\"\n+    : [retval]\"=r\"(retval)\n+    : [sysnum]\"i\"(SYS_futex), [futex]\"r\"(futex), [op]\"i\"(FUTEX_WAIT_PRIVATE)\n+    : \"memory\", \"cc\", \"x0\", \"x1\", \"x2\", \"x3\", \"x4\", \"x5\", \"x8\");\n+#else\n+# error Unimplemented\n+  \/\/ This is the logic any architecture should perform:\n+  do {\n+    retval = syscall(SYS_futex, &persist_futex, FUTEX_WAIT_PRIVATE, 1, nullptr, nullptr, 0);\n+  } while (retval == 0 && persist_futex);\n+#endif \/\/ x86_64 or aarch64\n+\n+  if (retval != 0) {\n+    errno = -retval;\n+    \/\/ EAGAIN = EWOULDBLOCK are returned if persist_futex is already 0 (race with the loop condition)\n+    if (errno != EAGAIN && errno != EWOULDBLOCK) {\n+      perror(\"CRaC thread futex wait loop\");\n+      os::exit(1);\n+    }\n+    \/\/ Another option is EINTR when the thread is signalled; this shouldn't happen,\n+    \/\/ though, so we'll treat that as an error.\n+  }\n+\n+#ifdef HAS_RSEQ\n+  if (rseqc->rseq_abi_pointer) {\n+    \/\/ Register the rseq back after restore\n+    if (syscall(SYS_rseq, (void *) rseqc->rseq_abi_pointer, rseqc->rseq_abi_size, 0, rseqc->signature) != 0) {\n+      perror(\"Register rseq again\");\n+    }\n+  }\n+\n+  \/\/ We cannot release this in after_threads_restored(), have to wait\n+  \/\/ until the last thread restores\n+  int dec = Atomic::sub(&persist_waiters, 1);\n+  if (dec == 0) {\n+    FREE_C_HEAP_ARRAY(struct __ptrace_rseq_configuration, rseq_configs);\n+    rseq_configs = nullptr;\n+  }\n+#endif \/\/ HAS_RSEQ\n+}\n+\n+#ifdef HAS_RSEQ\n+class GetRseqClosure: public ThreadClosure {\n+private:\n+  int _idx;\n+public:\n+  GetRseqClosure(): _idx(0) {}\n+\n+  void do_thread(Thread* thread) {\n+    pid_t tid = thread->osthread()->thread_id();\n+    if (ptrace(PTRACE_SEIZE, tid, 0, 0)) {\n+      perror(\"Cannot seize\");\n+    }\n+    if (ptrace(PTRACE_INTERRUPT, tid, 0, 0)) {\n+      perror(\"Cannot interrupt\");\n+    }\n+    int status;\n+    if (waitpid(tid, &status, 0) < 0) {\n+      perror(\"Cannot wait for tracee\");\n+    }\n+    struct __ptrace_rseq_configuration rseqc;\n+    if (ptrace(PTRACE_GET_RSEQ_CONFIGURATION, tid, sizeof(rseqc), &rseqc) != sizeof(rseqc)) {\n+      perror(\"Cannot get rseq\");\n+    }\n+    for (size_t i = 0; i < sizeof(rseqc); i += sizeof(long)) {\n+      if (ptrace(PTRACE_POKEDATA, tid, (char *)(rseq_configs + _idx) + i, *(long *)((char *)&rseqc + i))) {\n+        perror(\"Cannot write rseq to tracee process\");\n+      }\n+    }\n+    if (ptrace(PTRACE_DETACH, tid, 0, 0)) {\n+      perror(\"Cannot detach\");\n+    }\n+    _idx++;\n+  }\n+};\n+#endif \/\/ HAS_RSEQ\n+\n+class SignalClosure: public ThreadClosure {\n+private:\n+  int _idx;\n+public:\n+  SignalClosure(): _idx(0) {}\n+\n+  void do_thread(Thread* thread) {\n+    sigval_t val;\n+    val.sival_int = _idx++;\n+    pthread_sigqueue(thread->osthread()->pthread_id(), SIGUSR1, val);\n+\n+    JavaThread *jt = JavaThread::cast(thread);\n+    jt->wakeup_sleep();\n+    jt->parker()->unpark();\n+    jt->_ParkEvent->unpark();\n+  }\n+};\n+\n+\n+\/\/ JavaThreads that are going to be unmapped are parked as we're on safepoint\n+\/\/ but the parking syscall likely uses memory that is going to be unmapped.\n+\/\/ This is fine for the duration of the syscall, but if CREngine restarts\n+\/\/ these syscalls these would fail with EFAULT and crash in GLIBC.\n+\/\/ Therefore we register a signal handler that will park on global futex,\n+\/\/ send signal to each individual thread and wake up the threads to move\n+\/\/ to this signal handler.\n+void crac::before_threads_persisted() {\n+  persist_futex = 1;\n+\n+  sigset_t blocking_set;\n+  sigemptyset(&blocking_set);\n+  sigaddset(&blocking_set, SIGUSR1);\n+\n+  uint num_java_threads = ThreadsSMRSupport::get_java_thread_list()->length();\n+#ifdef HAS_RSEQ\n+  rseq_configs = NEW_C_HEAP_ARRAY(\n+    struct __ptrace_rseq_configuration, num_java_threads, mtInternal);\n+  guarantee(rseq_configs, \"Cannot allocate %u rseq structs\", num_java_threads);\n+\n+  sigprocmask(SIG_BLOCK, &blocking_set, nullptr);\n+  pid_t child = fork();\n+  if (child == 0) {\n+    siginfo_t info;\n+    sigwaitinfo(&blocking_set, &info);\n+    GetRseqClosure get_rseq;\n+    Threads::java_threads_do(&get_rseq);\n+    os::exit(0);\n+  } else {\n+    \/\/ Allow child to trace us if \/proc\/sys\/kernel\/yama\/ptrace_scope = 1\n+    prctl(PR_SET_PTRACER, child, 0, 0);\n+    kill(child, SIGUSR1);\n+    int status;\n+    if (waitpid(child, &status, 0) < 0) {\n+      perror(\"Waiting for tracer child\");\n+    }\n+  }\n+#endif \/\/ HAS_RSEQ\n+  \/\/ Make sure the signal is not blocked even if we didn't use it above for rseq\n+  sigprocmask(SIG_UNBLOCK, &blocking_set, nullptr);\n+\n+  struct sigaction action, old;\n+  action.sa_sigaction = block_in_other_futex;\n+  action.sa_flags = SA_SIGINFO;\n+  action.sa_restorer = nullptr;\n+  if (sigaction(SIGUSR1, &action, &old)) {\n+    fatal(\"Cannot install SIGUSR1 handler: %s\", os::strerror(errno));\n+  }\n+\n+  SignalClosure closure;\n+  Threads::java_threads_do(&closure);\n+\n+  while ((uint) persist_waiters < num_java_threads) {\n+    sched_yield();\n+  }\n+\n+  if (sigaction(SIGUSR1, &old, nullptr)) {\n+    fatal(\"Cannot restore SIGUSR1 handler: %s\", os::strerror(errno));\n+  }\n+}\n+\n+void crac::after_threads_restored() {\n+  persist_futex = 0;\n+  if (syscall(SYS_futex, &persist_futex, FUTEX_WAKE_PRIVATE, INT_MAX, nullptr, nullptr, 0) < 0) {\n+    fatal(\"Cannot wake up threads after restore: %s\", os::strerror(errno));\n+  }\n+}\n","filename":"src\/hotspot\/os\/linux\/crac_linux.cpp","additions":331,"deletions":17,"binary":false,"changes":348,"status":"modified"},{"patch":"@@ -64,1 +64,20 @@\n-#endif\n\\ No newline at end of file\n+\n+bool crac::MemoryPersister::unmap(void *addr, size_t length) {\n+  return false;\n+}\n+\n+bool crac::MemoryPersister::map(void *addr, size_t length, bool executable) {\n+  return false;\n+}\n+\n+bool crac::MemoryPersister::map_gap(void *addr, size_t length) {\n+  return false;\n+}\n+\n+void crac::before_threads_persisted() {\n+}\n+\n+void crac::after_threads_restored() {\n+}\n+\n+#endif\n","filename":"src\/hotspot\/os\/posix\/crac_posix.cpp","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -68,0 +68,1 @@\n+#include <spawn.h>\n@@ -1968,3 +1969,6 @@\n-  pid_t pid = fork();\n-  if (pid == -1) {\n-    perror(\"cannot fork for crengine\");\n+  \/\/ We do not use fork & exec since glibc goes over all threads on fork(),\n+  \/\/ and when some threads have stack unmapped (in-JVM memory persistence)\n+  \/\/ this would crash the process.\n+  pid_t pid;\n+  if (posix_spawn(&pid, path, nullptr, nullptr, (char * const *) argv, env) != 0) {\n+    perror(\"Cannot spawn crengine\");\n@@ -1973,5 +1977,0 @@\n-  if (pid == 0) {\n-    execve(path, (char* const*)argv, env);\n-    perror(\"execve\");\n-    exit(1);\n-  }\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -56,0 +56,18 @@\n+\n+bool crac::MemoryPersister::unmap(void *addr, size_t length) {\n+  return false;\n+}\n+\n+bool crac::MemoryPersister::map(void *addr, size_t length, bool executable) {\n+  return false;\n+}\n+\n+bool crac::MemoryPersister::map_gap(void *addr, size_t length) {\n+  return false;\n+}\n+\n+void crac::before_threads_persisted() {\n+}\n+\n+void crac::after_threads_restored() {\n+}\n","filename":"src\/hotspot\/os\/windows\/crac_windows.cpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+#include \"runtime\/crac.hpp\"\n@@ -1880,0 +1881,23 @@\n+\n+void CodeCache::persist_for_checkpoint() {\n+  FOR_ALL_HEAPS(it) {\n+    CodeHeap *heap = *it;\n+    \/\/ Non-nMethods heap is used for code stubs that are used for atomic operations\n+    \/\/ on aarch64; as these are used e.g. for all allocations\/frees it would be complicated\n+    \/\/ to avoid those until the memory is fully restored.\n+    if (heap != nullptr && heap->code_blob_type() != CodeBlobType::NonNMethod) {\n+      heap->persist_for_checkpoint();\n+    }\n+  }\n+}\n+\n+#ifdef ASSERT\n+void CodeCache::assert_checkpoint() {\n+  FOR_ALL_HEAPS(it) {\n+    CodeHeap *heap = *it;\n+    if (heap != nullptr && heap->code_blob_type() != CodeBlobType::NonNMethod) {\n+      heap->assert_checkpoint();\n+    }\n+  }\n+}\n+#endif \/\/ ASSERT\n","filename":"src\/hotspot\/share\/code\/codeCache.cpp","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -343,0 +343,3 @@\n+\n+  static void persist_for_checkpoint();\n+  DEBUG_ONLY(static void assert_checkpoint();)\n","filename":"src\/hotspot\/share\/code\/codeCache.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"gc\/g1\/g1FromCardCache.hpp\"\n@@ -1320,0 +1321,19 @@\n+\n+  void persist_for_checkpoint() override {\n+    _hrm.persist_for_checkpoint();\n+    G1FromCardCache::persist_for_checkpoint();\n+    _cm->persist_for_checkpoint();\n+    _task_queues->dealloc_queues();\n+  }\n+\n+#ifdef ASSERT\n+  void assert_checkpoint() override {\n+    _hrm.assert_checkpoint();\n+    G1FromCardCache::assert_checkpoint();\n+  }\n+#endif \/\/ ASSERT\n+\n+  void on_restore() override {\n+    _cm->on_restore();\n+    _task_queues->realloc_queues();\n+  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -70,0 +70,1 @@\n+#include \"runtime\/crac.hpp\"\n@@ -3056,0 +3057,16 @@\n+\n+void G1CMMarkStack::persist_for_checkpoint() {\n+  size_t used = MIN2(_hwm, _chunk_capacity) * sizeof(TaskQueueEntryChunk);\n+  size_t committed = _chunk_capacity * sizeof(TaskQueueEntryChunk);\n+  if (!crac::MemoryPersister::store(_base, used, committed, false)) {\n+    fatal(\"Cannot persist GC CM Mark stack\");\n+  }\n+}\n+\n+#ifdef ASSERT\n+void G1CMMarkStack::assert_checkpoint() {\n+  size_t used = MIN2(_hwm, _chunk_capacity) * sizeof(TaskQueueEntryChunk);\n+  size_t committed = _chunk_capacity * sizeof(TaskQueueEntryChunk);\n+  crac::MemoryPersister::assert_mem(_base, used, committed);\n+}\n+#endif \/\/ ASSERT\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -211,0 +211,3 @@\n+  void persist_for_checkpoint();\n+  DEBUG_ONLY(void assert_checkpoint());\n+\n@@ -620,0 +623,15 @@\n+  void persist_for_checkpoint() {\n+    _global_mark_stack.persist_for_checkpoint();\n+    _task_queues->dealloc_queues();\n+  }\n+\n+#ifdef ASSERT\n+  void assert_checkpoint() {\n+    _global_mark_stack.assert_checkpoint();\n+  }\n+#endif\n+\n+  void on_restore() {\n+    _task_queues->realloc_queues();\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.hpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"runtime\/crac.hpp\"\n@@ -93,0 +94,20 @@\n+\n+void G1FromCardCache::persist_for_checkpoint() {\n+  if (_cache == nullptr || _static_mem_size == 0) {\n+    return;\n+  }\n+  size_t size = align_up(_static_mem_size, os::vm_allocation_granularity());\n+  if (!crac::MemoryPersister::store(_cache, size, size, false)) {\n+    fatal(\"Failed to persist G1FromCardCache\");\n+  }\n+}\n+\n+#ifdef ASSERT\n+void G1FromCardCache::assert_checkpoint() {\n+  if (_cache == nullptr || _static_mem_size == 0) {\n+    return;\n+  }\n+  size_t size = align_up(_static_mem_size, os::vm_allocation_granularity());\n+  crac::MemoryPersister::assert_mem(_cache, size, size);\n+}\n+#endif \/\/ASSERT\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FromCardCache.cpp","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -98,0 +98,3 @@\n+\n+  static void persist_for_checkpoint();\n+  DEBUG_ONLY(static void assert_checkpoint();)\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FromCardCache.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"runtime\/crac.hpp\"\n@@ -253,0 +254,42 @@\n+\n+void G1PageBasedVirtualSpace::persist_for_checkpoint() {\n+  bool flip = _committed.at(0);\n+  size_t index = 0;\n+  while (index < _committed.size()) {\n+    size_t next;\n+    if (flip) {\n+      next = _committed.find_first_clear_bit(index);\n+      size_t length = (next - index) * _page_size;\n+      if (!crac::MemoryPersister::store((char *) _low_boundary + index * _page_size, length, length, false)) {\n+        fatal(\"Failed to persist committed virtual space node range\");\n+      }\n+    } else {\n+      next = _committed.find_first_set_bit(index);\n+      if (!crac::MemoryPersister::store_gap((char *) _low_boundary + index * _page_size, (next - index) * _page_size)) {\n+        fatal(\"Failed to persist uncommitted virtual space node range\");\n+      }\n+    }\n+    flip = !flip;\n+    index = next;\n+  }\n+}\n+\n+#ifdef ASSERT\n+void G1PageBasedVirtualSpace::assert_checkpoint() {\n+  bool flip = _committed.at(0);\n+  size_t index = 0;\n+  while (index < _committed.size()) {\n+    size_t next;\n+    if (flip) {\n+      next = _committed.find_first_clear_bit(index);\n+      size_t length = (next - index) * _page_size;\n+      crac::MemoryPersister::assert_mem((char *) _low_boundary + index * _page_size, length, length);\n+    } else {\n+      next = _committed.find_first_set_bit(index);\n+      crac::MemoryPersister::assert_gap((char *) _low_boundary + index * _page_size, (next - index) * _page_size);\n+    }\n+    flip = !flip;\n+    index = next;\n+  }\n+}\n+#endif \/\/ ASSERT\n","filename":"src\/hotspot\/share\/gc\/g1\/g1PageBasedVirtualSpace.cpp","additions":43,"deletions":0,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -147,0 +147,3 @@\n+\n+  void persist_for_checkpoint();\n+  DEBUG_ONLY(void assert_checkpoint());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1PageBasedVirtualSpace.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -89,0 +89,10 @@\n+\n+  void persist_for_checkpoint() {\n+    _storage.persist_for_checkpoint();\n+  }\n+\n+#ifdef ASSERT\n+  void assert_checkpoint() {\n+    _storage.assert_checkpoint();\n+  }\n+#endif \/\/ ASSERT\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RegionToSpaceMapper.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"runtime\/crac.hpp\"\n@@ -831,0 +832,45 @@\n+\n+\n+void HeapRegionManager::persist_for_checkpoint() {\n+  size_t page_size = os::vm_page_size();\n+  for (size_t i = 0; i < _regions.length(); ++i) {\n+    HeapRegion *region = _regions.get_by_index(i);\n+    if (region == nullptr) {\n+      continue;\n+    }\n+    u_int64_t top_aligned = align_up((u_int64_t) region->top(), page_size);\n+    \/\/ both active and inactive are mapped RW\n+    if (_committed_map.active(i) || _committed_map.inactive(i)) {\n+      if (!crac::MemoryPersister::store(region->bottom(), region->used(), region->capacity(), false)) {\n+        fatal(\"Cannot persist heap region %p - %p\", region->bottom(), region->end());\n+      }\n+    } else {\n+      if (!crac::MemoryPersister::store_gap(region->bottom(), region->capacity())) {\n+        fatal(\"Cannot persist heap region %p - %p\", region->bottom(), region->end());\n+      }\n+    }\n+  }\n+  _bot_mapper->persist_for_checkpoint();\n+  _cardtable_mapper->persist_for_checkpoint();\n+  _bitmap_mapper->persist_for_checkpoint();\n+}\n+\n+#ifdef ASSERT\n+void HeapRegionManager::assert_checkpoint() {\n+  for (size_t i = 0; i < _regions.length(); ++i) {\n+    HeapRegion *region = _regions.get_by_index(i);\n+    if (region == nullptr) {\n+      continue;\n+    }\n+    if (_committed_map.active(i) || _committed_map.inactive(i)) {\n+      crac::MemoryPersister::assert_mem(region->bottom(), region->used(), region->capacity());\n+    } else {\n+      crac::MemoryPersister::assert_gap(region->bottom(), region->capacity());\n+    }\n+  }\n+\n+  _bot_mapper->assert_checkpoint();\n+  _cardtable_mapper->assert_checkpoint();\n+  _bitmap_mapper->assert_checkpoint();\n+}\n+#endif \/\/ ASSERT\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionManager.cpp","additions":46,"deletions":0,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -295,0 +295,3 @@\n+\n+  void persist_for_checkpoint();\n+  DEBUG_ONLY(void assert_checkpoint();)\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionManager.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -543,0 +543,9 @@\n+\n+  \/\/ CRaC related\n+  virtual void persist_for_checkpoint() {\n+    \/\/ by default ignore the request\n+  }\n+#ifdef ASSERT\n+  virtual void assert_checkpoint() {}\n+#endif\n+  virtual void on_restore() {}\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -418,0 +418,3 @@\n+\n+  void release_memory();\n+  void realloc_memory();\n@@ -508,0 +511,11 @@\n+  void dealloc_queues() {\n+    for (uint i = 0; i < _n; ++i) {\n+      _queues[i]->release_memory();\n+    }\n+  }\n+  void realloc_queues() {\n+    for (uint i = 0; i < _n; ++i) {\n+      _queues[i]->realloc_memory();\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/taskqueue.hpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -111,0 +111,13 @@\n+template<class E, MEMFLAGS F, unsigned int N>\n+void GenericTaskQueue<E, F, N>::release_memory() {\n+  guarantee(size() == 0, \"Task queue not empty\");\n+  ArrayAllocator<E>::free(_elems, N);\n+  _elems = nullptr;\n+}\n+\n+template<class E, MEMFLAGS F, unsigned int N>\n+void GenericTaskQueue<E, F, N>::realloc_memory() {\n+  guarantee(_elems == nullptr, \"Task queue not released\");\n+  _elems = ArrayAllocator<E>::allocate(N, F);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/taskqueue.inline.hpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -231,0 +231,12 @@\n+\n+  void persist_for_checkpoint() {\n+    _memory.persist_on_checkpoint();\n+    _segmap.persist_on_checkpoint();\n+  }\n+\n+#ifdef ASSERT\n+  void assert_checkpoint() {\n+    _memory.assert_checkpoint();\n+    _segmap.assert_checkpoint();\n+  }\n+#endif \/\/ ASSERT\n","filename":"src\/hotspot\/share\/memory\/heap.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"runtime\/crac.hpp\"\n@@ -213,0 +214,22 @@\n+void VirtualSpaceList::persist_for_checkpoint() {\n+  size_t granule_size = Settings::commit_granule_bytes();\n+\n+  VirtualSpaceNode* vsn = _first_node;\n+  while (vsn != nullptr) {\n+    vsn->persist_for_checkpoint();\n+    vsn = vsn->next();\n+  }\n+}\n+\n+#ifdef ASSERT\n+void VirtualSpaceList::assert_checkpoint() {\n+  size_t granule_size = Settings::commit_granule_bytes();\n+\n+  VirtualSpaceNode* vsn = _first_node;\n+  while (vsn != nullptr) {\n+    vsn->assert_checkpoint();\n+    vsn = vsn->next();\n+  }\n+}\n+#endif \/\/ ASSERT\n+\n","filename":"src\/hotspot\/share\/memory\/metaspace\/virtualSpaceList.cpp","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -142,0 +142,2 @@\n+  void persist_for_checkpoint();\n+  DEBUG_ONLY(void assert_checkpoint();)\n","filename":"src\/hotspot\/share\/memory\/metaspace\/virtualSpaceList.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+#include \"utilities\/bitMap.inline.hpp\"\n@@ -451,0 +452,44 @@\n+void VirtualSpaceNode::persist_for_checkpoint() {\n+  size_t granule_size = Settings::commit_granule_bytes();\n+  bool flip = _commit_mask.at(0);\n+  size_t index = 0;\n+  while (index < _commit_mask.size()) {\n+    size_t next;\n+    if (flip) {\n+      next = _commit_mask.find_first_clear_bit(index);\n+      size_t length = (next - index) * granule_size;\n+      if (!crac::MemoryPersister::store((char *) _base + index * granule_size, length, length, false)) {\n+        fatal(\"Failed to persist committed virtual space node range\");\n+      }\n+    } else {\n+      next = _commit_mask.find_first_set_bit(index);\n+      if (!crac::MemoryPersister::store_gap((char *) _base + index * granule_size, (next - index) * granule_size)) {\n+        fatal(\"Failed to persist uncommitted virtual space node range\");\n+      }\n+    }\n+    flip = !flip;\n+    index = next;\n+  }\n+}\n+\n+#ifdef ASSERT\n+void VirtualSpaceNode::assert_checkpoint() {\n+  size_t granule_size = Settings::commit_granule_bytes();\n+  bool flip = _commit_mask.at(0);\n+  size_t index = 0;\n+  while (index < _commit_mask.size()) {\n+    size_t next;\n+    if (flip) {\n+      next = _commit_mask.find_first_clear_bit(index);\n+      size_t length = (next - index) * granule_size;\n+      crac::MemoryPersister::assert_mem((char *) _base + index * granule_size, length, length);\n+    } else {\n+      next = _commit_mask.find_first_set_bit(index);\n+      crac::MemoryPersister::assert_gap((char *) _base + index * granule_size, (next - index) * granule_size);\n+    }\n+    flip = !flip;\n+    index = next;\n+  }\n+}\n+#endif \/\/ ASSERT\n+\n","filename":"src\/hotspot\/share\/memory\/metaspace\/virtualSpaceNode.cpp","additions":45,"deletions":0,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"runtime\/crac.hpp\"\n@@ -258,0 +259,3 @@\n+  void persist_for_checkpoint();\n+  DEBUG_ONLY(void assert_checkpoint();)\n+\n","filename":"src\/hotspot\/share\/memory\/metaspace\/virtualSpaceNode.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"runtime\/crac.hpp\"\n@@ -1073,0 +1074,18 @@\n+\n+void VirtualSpace::persist_on_checkpoint() {\n+  size_t used = committed_size();\n+  if (!crac::MemoryPersister::store_gap(_low_boundary, _low - _low_boundary) ||\n+      !crac::MemoryPersister::store(_low, used, used, true) ||\n+      !crac::MemoryPersister::store_gap(_high, _high_boundary - _high)) {\n+    fatal(\"Cannot persist virtual space at %p - %p\", _low_boundary, _high_boundary);\n+  }\n+}\n+\n+#ifdef ASSERT\n+void VirtualSpace::assert_checkpoint() {\n+  size_t used = _high - _low;\n+  crac::MemoryPersister::assert_gap(_low_boundary, _low - _low_boundary);\n+  crac::MemoryPersister::assert_mem(_low, used, used);\n+  crac::MemoryPersister::assert_gap(_high, _high_boundary - _high);\n+}\n+#endif \/\/ASSERT\n","filename":"src\/hotspot\/share\/memory\/virtualspace.cpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -189,1 +189,0 @@\n-\n@@ -245,0 +244,3 @@\n+\n+  void persist_on_checkpoint();\n+  DEBUG_ONLY(void assert_checkpoint();)\n","filename":"src\/hotspot\/share\/memory\/virtualspace.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"code\/codeCache.hpp\"\n@@ -28,0 +29,1 @@\n+#include \"memory\/metaspace\/virtualSpaceList.hpp\"\n@@ -50,0 +52,4 @@\n+\/\/ Restore parameters must be static global variable because\n+\/\/ VM_Crac is allocated on java thread stack and the parameters\n+\/\/ are accessed before this stack is remapped.\n+static CracRestoreParameters _restore_parameters;\n@@ -286,0 +292,49 @@\n+class PersistThreadStackClosure: public ThreadClosure {\n+public:\n+  void do_thread(Thread* t) {\n+    JavaThread *thread = JavaThread::cast(t);\n+    size_t reserved = thread->stack_overflow_state()->stack_reserved_zone_base() - thread->stack_end();\n+    if (!crac::MemoryPersister::store_gap(thread->stack_end(), reserved)) {\n+      fatal(\"Cannot record reserved zone for stack\");\n+    }\n+    \/\/ On aarch64 the stack size might be not aligned to page boundaries on the upper end\n+    size_t length = align_up(thread->stack_size() - reserved, os::vm_page_size());\n+    if (!crac::MemoryPersister::store(thread->stack_end() + reserved, length, length, false)) {\n+      fatal(\"Cannot persist thread stack\");\n+    }\n+  }\n+};\n+\n+#ifdef ASSERT\n+class AssertThreadStackClosure: public ThreadClosure {\n+public:\n+  void do_thread(Thread* t) {\n+    JavaThread *thread = JavaThread::cast(t);\n+    size_t reserved = thread->stack_overflow_state()->stack_reserved_zone_base() - thread->stack_end();\n+    crac::MemoryPersister::assert_gap(thread->stack_end(), reserved);\n+    size_t length = align_up(thread->stack_size() - reserved, os::vm_page_size());\n+    crac::MemoryPersister::assert_mem(thread->stack_end() + reserved, length, length);\n+  }\n+};\n+#endif \/\/ ASSERT\n+\n+static void persist_thread_stacks() {\n+\/\/ Not platform-specific, but skip this on non-Linux\n+#ifdef LINUX\n+  crac::before_threads_persisted();\n+  PersistThreadStackClosure closure;\n+  Threads::java_threads_do(&closure);\n+#endif\n+}\n+\n+static void restore_thread_stacks() {\n+\/\/ Not platform-specific, but skip this on non-Linux\n+#ifdef LINUX\n+# ifdef ASSERT\n+  AssertThreadStackClosure closure;\n+  Threads::java_threads_do(&closure);\n+# endif \/\/ ASSERT\n+  crac::after_threads_restored();\n+#endif\n+}\n+\n@@ -335,0 +390,8 @@\n+  \/\/ We don't invoke this inside memory_checkpoint() for symmetry;\n+  \/\/ CodeCache must be restored earlier (see below)\n+  if (CRPersistMemory) {\n+    CodeCache::persist_for_checkpoint();\n+  }\n+\n+  os::trim_native_heap(nullptr);\n+\n@@ -341,0 +404,6 @@\n+    if (CRPersistMemory) {\n+      \/\/ Since VM_Crac instance is allocated on stack of other thread\n+      \/\/ we must not use it from now on\n+      persist_thread_stacks();\n+      crac::MemoryPersister::finalize();\n+    }\n@@ -343,0 +412,5 @@\n+      if (CRPersistMemory) {\n+        crac::MemoryPersister::reinit_memory();\n+        crac::MemoryPersister::load_on_restore();\n+        restore_thread_stacks();\n+      }\n@@ -351,0 +425,7 @@\n+  if (CRPersistMemory) {\n+    \/\/ Before reinit_memory the code must not change memory layout, e.g. mmapping\n+    \/\/ or even malloc'ing anything (malloc running out of space could run short and allocate\n+    \/\/ new regions).\n+    crac::MemoryPersister::reinit_memory();\n+  }\n+\n@@ -358,0 +439,17 @@\n+  if (CRPersistMemory) {\n+#ifdef ASSERT\n+    CodeCache::assert_checkpoint();\n+    metaspace::VirtualSpaceList *vsc = metaspace::VirtualSpaceList::vslist_class();\n+    if (vsc != nullptr) {\n+      vsc->assert_checkpoint();\n+    }\n+    metaspace::VirtualSpaceList *vsn = metaspace::VirtualSpaceList::vslist_nonclass();\n+    if (vsn != nullptr) {\n+      vsn->assert_checkpoint();\n+    }\n+    Universe::heap()->assert_checkpoint();\n+#endif \/\/ ASSERT\n+    crac::MemoryPersister::load_on_restore();\n+    Universe::heap()->on_restore();\n+    restore_thread_stacks();\n+  }\n@@ -432,2 +530,2 @@\n-    if (cr.new_args()) {\n-      new_args = java_lang_String::create_oop_from_str(cr.new_args(), CHECK_NH);\n+    if (_restore_parameters.args()) {\n+      new_args = java_lang_String::create_oop_from_str(_restore_parameters.args(), CHECK_NH);\n@@ -435,1 +533,1 @@\n-    GrowableArray<const char *>* new_properties = cr.new_properties();\n+    GrowableArray<const char *>* new_properties = _restore_parameters.properties();\n@@ -517,0 +615,1 @@\n+  guarantee(sizeof(header) == hdr->self_size, \"Invalid header: restoring 32 bit image with 64 bit JVM or vice versa?\");\n@@ -605,0 +704,18 @@\n+\n+bool crac::read_all(int fd, char *dest, size_t n) {\n+  size_t rd = 0;\n+  do {\n+    \/\/ without the explicit cast it fails the build on Windows\n+    ssize_t r = (ssize_t) ::read(fd, dest + rd, n - rd);\n+    if (r == 0) {\n+      return false;\n+    } else if (r < 0) {\n+      if (errno == EINTR) {\n+        continue;\n+      }\n+      return false;\n+    }\n+    rd += r;\n+  } while (rd < n);\n+  return true;\n+}\n","filename":"src\/hotspot\/share\/runtime\/crac.cpp","additions":120,"deletions":3,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"utilities\/growableArray.hpp\"\n@@ -31,0 +32,7 @@\n+#ifdef  _WINDOWS\n+# include <io.h>\n+# define close _close\n+#else\n+# include <unistd.h>\n+#endif \/\/ _WINDOWS\n+\n@@ -33,0 +41,1 @@\n+#define BAD_OFFSET 0xBAD0FF5Eull\n@@ -51,0 +60,97 @@\n+  class MemoryWriter: public CHeapObj<mtInternal> {\n+  protected:\n+    int _fd;\n+    size_t _offset_curr;\n+\n+  public:\n+    MemoryWriter(const char *filename);\n+    virtual ~MemoryWriter() {\n+      if (_fd >= 0) {\n+        ::close(_fd);\n+      }\n+    }\n+    virtual size_t write(void *addr, size_t size) = 0;\n+  };\n+\n+  class MemoryReader: public CHeapObj<mtInternal> {\n+  protected:\n+    int _fd;\n+\n+  public:\n+    MemoryReader(const char *filename);\n+    virtual ~MemoryReader() {\n+      if (_fd >= 0) {\n+        ::close(_fd);\n+      }\n+    }\n+    virtual void read(size_t offset, void *addr, size_t size, bool executable) = 0;\n+  };\n+\n+  class MmappingMemoryReader: public crac::MemoryReader {\n+  public:\n+    MmappingMemoryReader(const char *filename): MemoryReader(filename) {}\n+    void read(size_t offset, void *addr, size_t size, bool executable) override;\n+  };\n+\n+  class FileMemoryReader: public crac::MemoryReader {\n+  public:\n+    FileMemoryReader(const char *filename): MemoryReader(filename) {}\n+    void read(size_t offset, void *addr, size_t size, bool executable) override;\n+  };\n+\n+  class MemoryPersister: AllStatic {\n+  protected:\n+    enum Flags {\n+      DATA       = 1 << 0,\n+      EXECUTABLE = 1 << 1,\n+      ACCESSIBLE = 1 << 2,\n+    };\n+\n+    struct record {\n+      address addr;\n+      size_t length;\n+      size_t offset;\n+      int flags;\n+    };\n+\n+    class SearchInIndex: public CompareClosure<struct record> {\n+    public:\n+      int do_compare(const struct record &a, const struct record &b) {\n+        if (a.addr < b.addr) return -1;\n+        if (a.addr > b.addr) return 1;\n+        return 0;\n+      }\n+    };\n+\n+    static void allocate_index(size_t slots);\n+\n+    static GrowableArray<struct crac::MemoryPersister::record> _index;\n+    static MemoryWriter *_writer;\n+\n+  public:\n+    static constexpr char MEMORY_IMG[] = \"memory.img\";\n+\n+    static void init();\n+    static bool store(void *addr, size_t length, size_t mapped_length, bool executable);\n+    static bool store_gap(void *addr, size_t length);\n+\n+    static void finalize();\n+    \/\/ This method mmaps all memory as non-accessible without loading the data;\n+    \/\/ the purpose is to do this early (e.g. before reading new parameters)\n+    \/\/ to prevent other malloc or other code from accidentally mapping memory\n+    \/\/ in conflicting range.\n+    static void reinit_memory();\n+    static void load_on_restore();\n+#ifdef ASSERT\n+    static void assert_mem(void *addr, size_t used, size_t total);\n+    static void assert_gap(void *addr, size_t length);\n+#endif \/\/ ASSERT\n+  private:\n+    static bool unmap(void *addr, size_t length);\n+    static bool map(void *addr, size_t length, bool executable);\n+    static bool map_gap(void *addr, size_t length);\n+  };\n+\n+  static void before_threads_persisted();\n+  static void after_threads_restored();\n+\n@@ -52,0 +158,1 @@\n+  static bool read_all(int fd, char *buf, size_t bytes);\n","filename":"src\/hotspot\/share\/runtime\/crac.hpp","additions":107,"deletions":0,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -0,0 +1,296 @@\n+\/*\n+ * Copyright (c) 2023, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+#include <limits.h>\n+#include <string.h>\n+\n+#include \"memory\/resourceArea.hpp\"\n+#include \"runtime\/crac.hpp\"\n+#include \"runtime\/os.hpp\"\n+\n+const char crac::MemoryPersister::MEMORY_IMG[11];\n+GrowableArray<struct crac::MemoryPersister::record> crac::MemoryPersister::_index(256, mtInternal);\n+crac::MemoryWriter *crac::MemoryPersister::_writer = nullptr;\n+\n+class FileMemoryWriter: public crac::MemoryWriter {\n+private:\n+  size_t _alignment;\n+public:\n+  FileMemoryWriter(const char *filename, size_t alignment): MemoryWriter(filename), _alignment(alignment) {}\n+\n+  size_t write(void *addr, size_t size) override {\n+    if (!os::write(_fd, addr, size)) {\n+      tty->print_cr(\"Cannot store persisted memory: %s\", os::strerror(errno));\n+      return BAD_OFFSET;\n+    }\n+    size_t prev_offset = _offset_curr;\n+    _offset_curr += size;\n+    if (_alignment) {\n+      size_t off = align_up(_offset_curr, _alignment);\n+      if (off > _offset_curr) {\n+        if (os::seek_to_file_offset(_fd, off) < 0) {\n+          tty->print_cr(\"Cannot seek: %s\", os::strerror(errno));\n+          return false;\n+        }\n+        _offset_curr = off;\n+      }\n+    }\n+    return prev_offset;\n+  }\n+};\n+\n+crac::MemoryWriter::MemoryWriter(const char *filename): _offset_curr(0) {\n+  char path[PATH_MAX];\n+  snprintf(path, PATH_MAX, \"%s%s%s\", CRaCCheckpointTo, os::file_separator(), filename);\n+  _fd = os::open(path, O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR);\n+  if (_fd < 0) {\n+    fatal(\"Cannot open persisted memory file %s: %s\", path, os::strerror(errno));\n+  }\n+  _offset_curr = 0;\n+}\n+\n+crac::MemoryReader::MemoryReader(const char *filename) {\n+  char path[PATH_MAX];\n+  \/\/ When the checkpoint fails, we need to load the memory from CRaCCheckpointTo\n+  const char *dir = CRaCRestoreFrom != nullptr ? CRaCRestoreFrom : CRaCCheckpointTo;\n+  snprintf(path, PATH_MAX, \"%s%s%s\", dir, os::file_separator(), filename);\n+  _fd = os::open(path, O_RDONLY, S_IRUSR | S_IWUSR);\n+  if (_fd < 0) {\n+    fatal(\"Cannot open persisted memory file %s: %s\", path, os::strerror(errno));\n+  }\n+}\n+\n+void crac::FileMemoryReader::read(size_t offset, void *addr, size_t length, bool executable) {\n+  assert(_fd >= 0, \"File descriptor not open\");\n+  if (os::seek_to_file_offset(_fd, offset) < 0) {\n+    fatal(\"Cannot seek in persisted memory file: %d, 0x%zx: %s\", _fd, offset, os::strerror(errno));\n+  }\n+  if (!read_all(_fd, (char *) addr, length)) {\n+    fatal(\"Cannot read persisted memory file at %p (0x%zx = %zu): %s\", addr, length, length, os::strerror(errno));\n+  }\n+};\n+\n+void crac::MemoryPersister::init() {\n+  _writer = new FileMemoryWriter(MEMORY_IMG, os::vm_page_size());\n+  _index.clear();\n+}\n+\n+static bool is_all_zeroes(void *addr, size_t page_size) {\n+  unsigned long long *ptr = (unsigned long long *) addr;\n+  unsigned long long *end = (unsigned long long *)((address) addr + page_size);\n+  while (ptr < end && *ptr == 0) ++ptr;\n+  return ptr == end;\n+}\n+\n+bool crac::MemoryPersister::store(void *addr, size_t length, size_t mapped_length, bool executable) {\n+  if (mapped_length == 0) {\n+    return true;\n+  }\n+\n+  size_t page_size = os::vm_page_size();\n+  assert(is_aligned(addr, page_size), \"Unaligned address %p\", addr);\n+  assert(length <= mapped_length, \"Useful length %zx longer than mapped %zx\", length, mapped_length);\n+  assert(is_aligned(mapped_length, page_size), \"Unaligned length %zx at %p (page size %zx)\", mapped_length, addr, page_size);\n+\n+  int execFlag = (executable ? Flags::EXECUTABLE : 0);\n+  address curr = (address) addr;\n+  address end = curr + length;\n+  bool do_zeroes = is_all_zeroes(addr, page_size);\n+  while (curr < end) {\n+    address start = curr;\n+    if (do_zeroes) {\n+      do {\n+        curr += page_size;\n+      } while (curr < end && is_all_zeroes(curr, page_size));\n+      _index.append({\n+        .addr = start,\n+        .length = (size_t) (curr - start),\n+        .offset = BAD_OFFSET,\n+        .flags = Flags::ACCESSIBLE | execFlag\n+      });\n+      do_zeroes = false;\n+    } else {\n+      do {\n+        curr += page_size;\n+      } while (curr < end && !is_all_zeroes(curr, page_size));\n+      size_t to_write = (curr > end ? end : curr) - start;\n+      size_t offset = _writer->write(start, to_write);\n+      _index.append({\n+        .addr = start,\n+        .length = to_write,\n+        .offset = offset,\n+        .flags = Flags::DATA | Flags::ACCESSIBLE | execFlag\n+      });\n+      do_zeroes = true;\n+    }\n+  }\n+\n+  size_t aligned_length = align_up(length, page_size);\n+  if (aligned_length < mapped_length) {\n+    _index.append({\n+      .addr = (address) addr + aligned_length,\n+      .length = mapped_length - aligned_length,\n+      .offset = BAD_OFFSET,\n+      .flags = Flags::ACCESSIBLE | execFlag\n+    });\n+  }\n+  return unmap(addr, mapped_length);\n+}\n+\n+bool crac::MemoryPersister::store_gap(void *addr, size_t length) {\n+  assert(is_aligned(addr, os::vm_page_size()), \"Unaligned address\");\n+  assert(is_aligned(length, os::vm_page_size()), \"Unaligned length\");\n+  if (length == 0) {\n+    return true;\n+  }\n+#ifdef ASSERT\n+  for (int i = 0; i < _index.length(); ++i) {\n+    const struct record &r = _index.at(i);\n+    assert((address) addr + length <= r.addr || r.addr + r.length <= addr,\n+      \"Overlapping regions %p-%p and %p-%p\", r.addr, r.addr + r.length, addr, (address) addr + length);\n+  }\n+#endif\n+  _index.append({\n+    .addr = (address) addr,\n+    .length = length,\n+    .offset = BAD_OFFSET,\n+    .flags = 0\n+  });\n+  return unmap(addr, length);\n+}\n+\n+void crac::MemoryPersister::reinit_memory() {\n+  size_t page_size = os::vm_page_size();\n+  for (int i = 0; i < _index.length(); ++i) {\n+    const record &r = _index.at(i);\n+    size_t aligned_length = align_up(r.length, page_size);\n+    if (!map_gap(r.addr, aligned_length)) {\n+      fatal(\"Cannot reinit non-accessible memory at %p-%p\", r.addr, r.addr + aligned_length);\n+    }\n+  }\n+}\n+\n+void crac::MemoryPersister::load_on_restore() {\n+  MemoryReader *reader;\n+  bool update_protection = false;\n+  \/\/ When pauseengine\/simengine is used we can do repeated checkpoints;\n+  \/\/ when the memory is mmapped and we try to write it second time, the file\n+  \/\/ would be truncated and subsequent attempt to read the data could cause SIGBUS.\n+  if (CREngine != nullptr && (!strncmp(CREngine, \"pauseengine\", 10) || !strncmp(CREngine, \"simengine\", 8))) {\n+    reader = new FileMemoryReader(MEMORY_IMG);\n+    update_protection = true;\n+  } else {\n+    reader = new MmappingMemoryReader(MEMORY_IMG);\n+  }\n+  size_t page_size = os::vm_page_size();\n+  for (int i = 0; i < _index.length(); ++i) {\n+    const record &r = _index.at(i);\n+    size_t aligned_length = align_up(r.length, page_size);\n+    bool executable = r.flags & Flags::EXECUTABLE;\n+    if (r.flags & Flags::ACCESSIBLE) {\n+      if ((r.flags & Flags::DATA) == 0) {\n+        if (!map(r.addr, aligned_length, executable)) {\n+          fatal(\"Cannot remap memory at %p-%p\", r.addr, r.addr + aligned_length);\n+        }\n+      } else {\n+        char *data = (char *) r.addr;\n+        if (update_protection && !os::protect_memory(data, aligned_length,\n+            executable ? os::ProtType::MEM_PROT_RWX : os::ProtType::MEM_PROT_RW)) {\n+          fatal(\"Cannot remap memory at %p-%p\", r.addr, r.addr + aligned_length);\n+        }\n+        reader->read(r.offset, data, r.length, r.flags & Flags::EXECUTABLE);\n+      }\n+    }\n+  }\n+  delete reader;\n+}\n+\n+\n+#ifdef ASSERT\n+void crac::MemoryPersister::assert_mem(void *addr, size_t used, size_t total) {\n+  assert(is_aligned(addr, os::vm_page_size()), \"Unaligned address %p\", addr);\n+  assert(is_aligned(total, os::vm_page_size()), \"Unaligned length %zx\", total);\n+\n+  size_t aligned = align_up(used, os::vm_page_size());\n+  size_t unused = total - aligned;\n+  void *gap_addr = (char *) addr + aligned;\n+\n+  SearchInIndex comparator;\n+  bool found;\n+  int at = _index.find_sorted<struct record>(&comparator, { .addr = (address) addr }, found);\n+  assert(found, \"Cannot find region with address %p (%d records)\", addr, _index.length());\n+  while (used > 0) {\n+    assert(at < _index.length(), \"Overrunning index with 0x%zx used\", used);\n+    const record &r = _index.at(at);\n+    \/\/ fprintf(stderr, \"R %d %lx %lx %lx %x\\n\", at, r.addr, r.length, r.offset, r.flags);\n+    assert((void   *) r.addr == addr, \"Unexpected address %p, expected %p\", r.addr, addr);\n+    assert(r.flags & Flags::ACCESSIBLE, \"Bad flags for %p: 0x%x\", r.addr, r.flags);\n+    assert(r.length <= used, \"Persisted memory region length does not match at %p: 0x%zx vs. 0x%zx\", addr, used, r.length);\n+    if (r.flags & Flags::DATA) {\n+      assert(r.offset != BAD_OFFSET, \"Invalid offset at %p\", r.addr);\n+    } else {\n+      assert(r.offset == BAD_OFFSET, \"Invalid offset at %p: 0x%zx\", r.addr, r.offset);\n+    }\n+    used -= r.length;\n+    addr = (char *) addr + r.length;\n+    at++;\n+  }\n+  if (unused > 0) {\n+    const record &g = _index.at(at);\n+    assert(g.addr == gap_addr, \"Invalid address for the gap region: %p vs. %p\", g.addr, gap_addr);\n+    assert(g.length == unused, \"Persisted gap length does not match at %p: 0x%zx vs. 0x%zx\", gap_addr, unused, g.length);\n+    assert((g.flags & (Flags::DATA | Flags::ACCESSIBLE)) == Flags::ACCESSIBLE, \"Bad flags for gap %p: 0x%x\", gap_addr, g.flags);\n+    assert(g.offset == BAD_OFFSET, \"Invalid offset at %p: 0x%zx\", gap_addr, g.offset);\n+  }\n+}\n+\n+void crac::MemoryPersister::assert_gap(void *addr, size_t length) {\n+  assert(is_aligned(addr, os::vm_page_size()), \"Unaligned address %p\", addr);\n+  assert(is_aligned(length, os::vm_page_size()), \"Unaligned length 0x%zx\", length);\n+  if (length > 0) {\n+    SearchInIndex comparator;\n+    bool found;\n+    int at = _index.find_sorted<struct record>(&comparator, { .addr = (address) addr }, found);\n+    assert(found, \"Cannot find region with address %p (%d records)\", addr, _index.length());\n+    const record &r = _index.at(at);\n+    assert(r.length == length, \"Persisted memory region length does not match at %p: 0x%zx vs. 0x%zx\", addr, length, r.length);\n+    assert((r.flags & (Flags::DATA | Flags::ACCESSIBLE)) == 0, \"Bad flags for %p: 0x%x\", addr, r.flags);\n+    assert(r.offset == BAD_OFFSET, \"Invalid offset at %p: 0x%zx\", addr, r.offset);\n+  }\n+}\n+#endif \/\/ ASSERT\n+\n+void crac::MemoryPersister::finalize() {\n+  delete _writer;\n+  _writer = nullptr;\n+\n+#ifdef ASSERT\n+  _index.sort([](struct record *a, struct record *b) {\n+    \/\/ simple cast to int doesn't work, let compiler figure it out with cmovs\n+    if (a->addr < b->addr) return -1;\n+    if (a->addr > b->addr) return 1;\n+    return 0;\n+  });\n+#endif \/\/ ASSERT\n+  \/\/ Note: here we could persist _index and dallocate it as well but since it's\n+  \/\/ usually tens or hundreds of 32 byte records, we won't save much.\n+}\n","filename":"src\/hotspot\/share\/runtime\/crac_memory.cpp","additions":296,"deletions":0,"binary":false,"changes":296,"status":"added"},{"patch":"@@ -58,0 +58,1 @@\n+    uint32_t self_size;\n@@ -119,0 +120,1 @@\n+      (uint32_t) sizeof(struct header),\n@@ -166,1 +168,0 @@\n-  CracRestoreParameters _restore_parameters;\n@@ -178,1 +179,0 @@\n-    _restore_parameters(),\n@@ -191,2 +191,0 @@\n-  const char* new_args() { return _restore_parameters.args(); }\n-  GrowableArray<const char *>* new_properties() { return _restore_parameters.properties(); }\n","filename":"src\/hotspot\/share\/runtime\/crac_structs.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2023,0 +2023,3 @@\n+  product(bool, CRPersistMemory, true, DIAGNOSTIC, \"Persist\/load memory \"   \\\n+      \"from within the VM rather than relying on the C\/R engine.\")          \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include <stdbool.h>\n@@ -646,0 +647,7 @@\n+\/\/ Instead of waiting on the implicit futex that is located in the address\n+\/\/ space of the main Java thread stack we'll wait on a global condition here.\n+static pthread_mutex_t main_thread_mutex = PTHREAD_MUTEX_INITIALIZER;\n+static pthread_cond_t main_thread_cond = PTHREAD_COND_INITIALIZER;\n+static bool main_thread_done = false;\n+static int main_thread_result = 0;\n+\n@@ -650,1 +658,7 @@\n-    return (void*)(intptr_t)JavaMain(args);\n+    pthread_mutex_lock(&main_thread_mutex);\n+    main_thread_result = JavaMain(args);\n+    void *retval = (void*)(intptr_t) main_thread_result;\n+    main_thread_done = true;\n+    pthread_cond_signal(&main_thread_cond);\n+    pthread_mutex_unlock(&main_thread_mutex);\n+    return retval;\n@@ -676,1 +690,2 @@\n-    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);\n+    \/\/ See main_thread_mutex\n+    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n@@ -701,3 +716,9 @@\n-        void* tmp;\n-        pthread_join(tid, &tmp);\n-        rslt = (int)(intptr_t)tmp;\n+        for (;;) {\n+            pthread_mutex_lock(&main_thread_mutex);\n+            pthread_cond_wait(&main_thread_cond, &main_thread_mutex);\n+            if (main_thread_done) {\n+                break;\n+            }\n+            pthread_mutex_unlock(&main_thread_mutex);\n+        }\n+        rslt = main_thread_result;\n","filename":"src\/java.base\/unix\/native\/libjli\/java_md.c","additions":26,"deletions":5,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -24,0 +24,3 @@\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n@@ -31,1 +34,1 @@\n- * @run driver\/timeout=60 jdk.test.lib.crac.CracTest 10\n+ * @run driver\/timeout=15 jdk.test.lib.crac.CracTest 10\n@@ -35,0 +38,1 @@\n+    private static final AtomicInteger restoreCount = new AtomicInteger(0);\n@@ -37,1 +41,1 @@\n-    @CracTestArg\n+    @CracTestArg(0)\n@@ -40,0 +44,3 @@\n+    @CracTestArg(value = 1, optional = true)\n+    String restoreCountPath;\n+\n@@ -43,0 +50,7 @@\n+        \/\/ remove pid file if it exists from previous run\n+        builder.imageDir().resolve(\"pid\").toFile().delete();\n+        restoreCountPath = builder.imageDir().resolve(\"restoreCount\").toAbsolutePath().toString();\n+        builder.imageDir().toFile().mkdirs();\n+        Files.writeString(Path.of(restoreCountPath), \"0\");\n+\n+        builder.args(CracTest.args(restoreCountPath));\n@@ -46,0 +60,1 @@\n+            assert process.isAlive();\n@@ -48,0 +63,5 @@\n+            String currentRestore;\n+            do {\n+                Thread.sleep(20);\n+                currentRestore = Files.readString(Path.of(restoreCountPath));\n+            } while(!currentRestore.equals(String.valueOf(i)));\n@@ -52,1 +72,1 @@\n-    private static class TestThread extends Thread {\n+    private class TestThread extends Thread {\n@@ -57,1 +77,1 @@\n-                jdk.crac.Core.checkpointRestore();\n+                doCheckpointRestore();\n@@ -64,0 +84,4 @@\n+            } catch (IOException e) {\n+                if (exception == null) {\n+                    exception = e;\n+                }\n@@ -112,1 +136,1 @@\n-        Core.getGlobalContext().register(new Test());\n+        Core.getGlobalContext().register(this);\n@@ -122,1 +146,1 @@\n-            jdk.crac.Core.checkpointRestore();\n+            doCheckpointRestore();\n@@ -124,1 +148,1 @@\n-            throw new RuntimeException(\"Checkpoint ERROR \" + e);\n+            throw new RuntimeException(\"Checkpoint ERROR\", e);\n@@ -126,1 +150,1 @@\n-            throw new RuntimeException(\"Restore ERROR \" + e);\n+            throw new RuntimeException(\"Restore ERROR\", e);\n@@ -141,0 +165,7 @@\n+\n+    private void doCheckpointRestore() throws CheckpointException, RestoreException, IOException {\n+        Core.checkpointRestore();\n+        int rc = restoreCount.incrementAndGet();\n+        System.err.printf(\"After restore #%d%n\", rc, restoreCountPath);\n+        Files.writeString(Path.of(restoreCountPath), String.valueOf(rc));\n+    }\n","filename":"test\/jdk\/jdk\/crac\/recursiveCheckpoint\/Test.java","additions":39,"deletions":8,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -56,0 +56,2 @@\n+        String expectedPid = Files.readString(builder.imageDir().toAbsolutePath().resolve(\"pid\"));\n+        assertEquals(expectedPid.trim(), String.valueOf(process.pid()));\n@@ -131,0 +133,4 @@\n+\n+    public boolean isAlive() {\n+        return process.isAlive();\n+    }\n","filename":"test\/lib\/jdk\/test\/lib\/crac\/CracProcess.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -196,0 +196,2 @@\n+     *\n+     * @param extraArgs Optional parameters that were not part of the <code>@run<\/code> jtreg tag\n","filename":"test\/lib\/jdk\/test\/lib\/crac\/CracTest.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}