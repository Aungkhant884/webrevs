{"files":[{"patch":"@@ -69,0 +69,1 @@\n+static BufferBlob* stub_blob;\n@@ -2805,6 +2806,3 @@\n-  \/\/ With CRaC, the generated code is used early after restore from checkpoint,\n-  \/\/ before CodeCache is restored. Therefore we need to allocate the memory\n-  \/\/ outside CodeCache.\n-  size_t aligned_size = align_up(stub_size, os::vm_page_size());\n-  char *stub_memory = os::reserve_memory(aligned_size, true, mtCode);\n-  if (stub_memory == nullptr || !os::commit_memory(stub_memory, aligned_size, true)) {\n+  \/\/ Making this stub must be FIRST use of assembler\n+  stub_blob = BufferBlob::create(\"VM_Version stub\", stub_size);\n+  if (stub_blob == nullptr) {\n@@ -2813,1 +2811,1 @@\n-  CodeBuffer c((address) stub_memory, aligned_size);\n+  CodeBuffer c(stub_blob);\n@@ -2923,0 +2921,1 @@\n+static BufferBlob* cpuid_brand_string_stub_blob;\n@@ -3226,3 +3225,2 @@\n-  size_t aligned_size = align_up(cpuid_brand_string_stub_size, os::vm_page_size());\n-  char *stub_memory = os::reserve_memory(aligned_size, true, mtCode);\n-  if (stub_memory == nullptr || !os::commit_memory(stub_memory, aligned_size, true)) {\n+  cpuid_brand_string_stub_blob = BufferBlob::create(\"getCPUIDBrandString_stub\", cpuid_brand_string_stub_size);\n+  if (cpuid_brand_string_stub_blob == nullptr) {\n@@ -3231,1 +3229,1 @@\n-  CodeBuffer c((address) stub_memory, aligned_size);\n+  CodeBuffer c(cpuid_brand_string_stub_blob);\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-#include \"gc\/shared\/collectedHeap.hpp\"\n@@ -29,1 +28,0 @@\n-#include \"perfMemory_linux.hpp\"\n@@ -363,46 +361,0 @@\n-static bool check_can_write() {\n-  char path[PATH_MAX];\n-  snprintf(path, PATH_MAX, \"%s%s.test\", CRaCCheckpointTo, os::file_separator());\n-  int fd = os::open(path, O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR);\n-  if (fd < 0) {\n-    tty->print_cr(\"Cannot create %s: %s\\n\", path, os::strerror(errno));\n-    return false;\n-  }\n-  bool success = write(fd, \"test\", 4) > 0;\n-  if (!success) {\n-    tty->print_cr(\"Cannot write to %s: %s\\n\", path, os::strerror(errno));\n-  }\n-  if (::close(fd)) {\n-    tty->print_cr(\"Cannot close %s: %s\", path, os::strerror(errno));\n-  }\n-  if (::unlink(path)) {\n-    tty->print_cr(\"Cannot remove %s: %s\", path, os::strerror(errno));\n-  }\n-  return success;\n-}\n-\n-bool VM_Crac::memory_checkpoint() {\n-  if (CRPersistMemory) {\n-    \/\/ Check early if the checkpoint directory is writable; from this point\n-    \/\/ we won't be able to go back\n-    if (!check_can_write()) {\n-      return false;\n-    }\n-    crac::MemoryPersister::init();\n-    Universe::heap()->persist_for_checkpoint();\n-    metaspace::VirtualSpaceList *vsc = metaspace::VirtualSpaceList::vslist_class();\n-    if (vsc != nullptr) {\n-      vsc->persist_for_checkpoint();\n-    }\n-    metaspace::VirtualSpaceList *vsn = metaspace::VirtualSpaceList::vslist_nonclass();\n-    if (vsn != nullptr) {\n-      vsn->persist_for_checkpoint();\n-    }\n-  }\n-  return PerfMemoryLinux::checkpoint(CRaCCheckpointTo);\n-}\n-\n-void VM_Crac::memory_restore() {\n-  PerfMemoryLinux::restore();\n-}\n-\n","filename":"src\/hotspot\/os\/linux\/crac_linux.cpp","additions":0,"deletions":48,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -54,7 +54,0 @@\n-bool VM_Crac::memory_checkpoint() {\n-  return true;\n-}\n-\n-void VM_Crac::memory_restore() {\n-}\n-\n@@ -93,1 +86,7 @@\n-  while (::mmap(addr, length, p, MAP_PRIVATE | MAP_FIXED | MAP_ANONYMOUS, -1 , 0) != addr) {\n+  int mode = MAP_PRIVATE | MAP_FIXED | MAP_ANONYMOUS;\n+#ifdef __APPLE__\n+  \/\/ Apple requires either R-X or RW- mappings unless MAP_JIT is present\n+  \/\/ but combination of MAP_FIXED and MAP_JIT is prohibited.\n+  assert(protType != os::ProtType::MEM_PROT_RWX, \"Cannot create RWX mapping.\");\n+#endif\n+  while (::mmap(addr, length, p, mode, -1 , 0) != addr) {\n@@ -95,1 +94,1 @@\n-      fprintf(stderr, \"::mmap %p %zu RW: %m\\n\", addr, length);\n+      fprintf(stderr, \"::mmap %p %zu RW: %s\\n\", addr, length, os::strerror(errno));\n","filename":"src\/hotspot\/os\/posix\/crac_posix.cpp","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -68,5 +68,0 @@\n-#ifndef LINUX\n-\/\/ Stubbed out for OSX\n-inline bool os::trim_native_heap(os::size_change_t *rss_change) { return false; }\n-#endif \/\/ LINUX\n-\n","filename":"src\/hotspot\/os\/posix\/os_posix.inline.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -39,7 +39,0 @@\n-bool VM_Crac::memory_checkpoint() {\n-  return true;\n-}\n-\n-void VM_Crac::memory_restore() {\n-}\n-\n@@ -61,1 +54,1 @@\n-bool crac::MemoryPersister::map(void *addr, size_t length, bool executable) {\n+bool crac::MemoryPersister::map(void *addr, size_t length, os::ProtType protType) {\n","filename":"src\/hotspot\/os\/windows\/crac_windows.cpp","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -3070,1 +3070,1 @@\n-  crac::MemoryPersister::assert_mem(_base, used, committed);\n+  crac::MemoryPersister::assert_mem(_base, used, committed, false);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -111,1 +111,1 @@\n-  crac::MemoryPersister::assert_mem(_cache, size, size);\n+  crac::MemoryPersister::assert_mem(_cache, size, size, false);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FromCardCache.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -286,1 +286,1 @@\n-      crac::MemoryPersister::assert_mem((char *) _low_boundary + index * _page_size, length, length);\n+      crac::MemoryPersister::assert_mem((char *) _low_boundary + index * _page_size, length, length, false);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1PageBasedVirtualSpace.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -836,1 +836,1 @@\n-  for (size_t i = 0; i < _regions.length(); ++i) {\n+  for (uint i = 0; i < _regions.length(); ++i) {\n@@ -841,1 +841,0 @@\n-    u_int64_t top_aligned = align_up((u_int64_t) region->top(), page_size);\n@@ -860,1 +859,1 @@\n-  for (size_t i = 0; i < _regions.length(); ++i) {\n+  for (uint i = 0; i < _regions.length(); ++i) {\n@@ -866,1 +865,1 @@\n-      crac::MemoryPersister::assert_mem(region->bottom(), region->used(), region->capacity());\n+      crac::MemoryPersister::assert_mem(region->bottom(), region->used(), region->capacity(), false);\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionManager.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -485,1 +485,1 @@\n-      crac::MemoryPersister::assert_mem((char *) _base + index * granule_size, length, length);\n+      crac::MemoryPersister::assert_mem((char *) _base + index * granule_size, length, length, false);\n","filename":"src\/hotspot\/share\/memory\/metaspace\/virtualSpaceNode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1088,1 +1088,1 @@\n-  crac::MemoryPersister::assert_mem(_low, used, used);\n+  crac::MemoryPersister::assert_mem(_low, used, used, true);\n","filename":"src\/hotspot\/share\/memory\/virtualspace.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/shared\/collectedHeap.hpp\"\n@@ -39,0 +40,1 @@\n+#include \"runtime\/os.inline.hpp\"\n@@ -46,0 +48,1 @@\n+#include \"perfMemory_linux.hpp\"\n@@ -294,49 +297,0 @@\n-class PersistThreadStackClosure: public ThreadClosure {\n-public:\n-  void do_thread(Thread* t) {\n-    JavaThread *thread = JavaThread::cast(t);\n-    size_t reserved = thread->stack_overflow_state()->stack_reserved_zone_base() - thread->stack_end();\n-    if (!crac::MemoryPersister::store_gap(thread->stack_end(), reserved)) {\n-      fatal(\"Cannot record reserved zone for stack\");\n-    }\n-    \/\/ On aarch64 the stack size might be not aligned to page boundaries on the upper end\n-    size_t length = align_up(thread->stack_size() - reserved, os::vm_page_size());\n-    if (!crac::MemoryPersister::store(thread->stack_end() + reserved, length, length, false)) {\n-      fatal(\"Cannot persist thread stack\");\n-    }\n-  }\n-};\n-\n-#ifdef ASSERT\n-class AssertThreadStackClosure: public ThreadClosure {\n-public:\n-  void do_thread(Thread* t) {\n-    JavaThread *thread = JavaThread::cast(t);\n-    size_t reserved = thread->stack_overflow_state()->stack_reserved_zone_base() - thread->stack_end();\n-    crac::MemoryPersister::assert_gap(thread->stack_end(), reserved);\n-    size_t length = align_up(thread->stack_size() - reserved, os::vm_page_size());\n-    crac::MemoryPersister::assert_mem(thread->stack_end() + reserved, length, length);\n-  }\n-};\n-#endif \/\/ ASSERT\n-\n-static void persist_thread_stacks() {\n-\/\/ Not platform-specific, but skip this on non-Linux\n-#ifdef LINUX\n-  crac::before_threads_persisted();\n-  PersistThreadStackClosure closure;\n-  Threads::java_threads_do(&closure);\n-#endif\n-}\n-\n-static void restore_thread_stacks() {\n-\/\/ Not platform-specific, but skip this on non-Linux\n-#ifdef LINUX\n-# ifdef ASSERT\n-  AssertThreadStackClosure closure;\n-  Threads::java_threads_do(&closure);\n-# endif \/\/ ASSERT\n-  crac::after_threads_restored();\n-#endif\n-}\n-\n@@ -388,1 +342,1 @@\n-  if (!memory_checkpoint()) {\n+  if (!crac::memory_checkpoint()) {\n@@ -392,6 +346,0 @@\n-  \/\/ We don't invoke this inside memory_checkpoint() for symmetry;\n-  \/\/ CodeCache must be restored earlier (see below)\n-  if (CRPersistMemory) {\n-    CodeCache::persist_for_checkpoint();\n-  }\n-\n@@ -409,1 +357,1 @@\n-      persist_thread_stacks();\n+      crac::threads_checkpoint();\n@@ -414,6 +362,1 @@\n-      if (CRPersistMemory) {\n-        crac::MemoryPersister::reinit_memory();\n-        crac::MemoryPersister::load_on_restore();\n-        restore_thread_stacks();\n-      }\n-      memory_restore();\n+      crac::memory_restore(false);\n@@ -441,0 +384,11 @@\n+  crac::memory_restore(true);\n+\n+  \/\/ VM_Crac::read_shm needs to be already called to read RESTORE_SETTABLE parameters.\n+  VM_Version::crac_restore_finalize();\n+\n+  wakeup_threads_in_timedwait_vm();\n+\n+  _ok = true;\n+}\n+\n+bool crac::memory_checkpoint() {\n@@ -442,2 +396,7 @@\n-#ifdef ASSERT\n-    CodeCache::assert_checkpoint();\n+    \/\/ Check early if the checkpoint directory is writable; from this point\n+    \/\/ we won't be able to go back\n+    if (!can_write_image()) {\n+      return false;\n+    }\n+    MemoryPersister::init();\n+    Universe::heap()->persist_for_checkpoint();\n@@ -446,1 +405,1 @@\n-      vsc->assert_checkpoint();\n+      vsc->persist_for_checkpoint();\n@@ -450,1 +409,1 @@\n-      vsn->assert_checkpoint();\n+      vsn->persist_for_checkpoint();\n@@ -452,5 +411,1 @@\n-    Universe::heap()->assert_checkpoint();\n-#endif \/\/ ASSERT\n-    crac::MemoryPersister::load_on_restore();\n-    Universe::heap()->on_restore();\n-    restore_thread_stacks();\n+    CodeCache::persist_for_checkpoint();\n@@ -458,2 +413,6 @@\n-  \/\/ VM_Crac::read_shm needs to be already called to read RESTORE_SETTABLE parameters.\n-  VM_Version::crac_restore_finalize();\n+  bool success = true;\n+#ifdef LINUX\n+  success = PerfMemoryLinux::checkpoint(CRaCCheckpointTo);\n+#endif\n+  return success;\n+}\n@@ -461,1 +420,15 @@\n-  memory_restore();\n+class PersistThreadStackClosure: public ThreadClosure {\n+public:\n+  void do_thread(Thread* t) {\n+    JavaThread *thread = JavaThread::cast(t);\n+    size_t reserved = thread->stack_overflow_state()->stack_reserved_zone_base() - thread->stack_end();\n+    if (!crac::MemoryPersister::store_gap(thread->stack_end(), reserved)) {\n+      fatal(\"Cannot record reserved zone for stack\");\n+    }\n+    \/\/ On aarch64 the stack size might be not aligned to page boundaries on the upper end\n+    size_t length = align_up(thread->stack_size() - reserved, os::vm_page_size());\n+    if (!crac::MemoryPersister::store(thread->stack_end() + reserved, length, length, false)) {\n+      fatal(\"Cannot persist thread stack\");\n+    }\n+  }\n+};\n@@ -463,1 +436,9 @@\n-  wakeup_threads_in_timedwait_vm();\n+void crac::threads_checkpoint() {\n+  crac::before_threads_persisted();\n+  \/\/ We cannot unmap non-Linux thread stacks as the implementation\n+  \/\/ of before_threads_persisted is dummy\n+#ifdef LINUX\n+  PersistThreadStackClosure closure;\n+  Threads::java_threads_do(&closure);\n+#endif \/\/ LINUX\n+}\n@@ -465,1 +446,42 @@\n-  _ok = true;\n+void crac::memory_restore(bool successful) {\n+  if (CRPersistMemory) {\n+    if (successful) {\n+#ifdef ASSERT\n+      CodeCache::assert_checkpoint();\n+      metaspace::VirtualSpaceList *vsc = metaspace::VirtualSpaceList::vslist_class();\n+      if (vsc != nullptr) {\n+        vsc->assert_checkpoint();\n+      }\n+      metaspace::VirtualSpaceList *vsn = metaspace::VirtualSpaceList::vslist_nonclass();\n+      if (vsn != nullptr) {\n+        vsn->assert_checkpoint();\n+      }\n+      Universe::heap()->assert_checkpoint();\n+\n+      class AssertThreadStackClosure: public ThreadClosure {\n+      public:\n+        void do_thread(Thread* t) {\n+          JavaThread *thread = JavaThread::cast(t);\n+          size_t reserved = thread->stack_overflow_state()->stack_reserved_zone_base() - thread->stack_end();\n+          crac::MemoryPersister::assert_gap(thread->stack_end(), reserved);\n+          size_t length = align_up(thread->stack_size() - reserved, os::vm_page_size());\n+          crac::MemoryPersister::assert_mem(thread->stack_end() + reserved, length, length, false);\n+        }\n+      };\n+\n+# ifdef LINUX\n+      AssertThreadStackClosure closure;\n+      Threads::java_threads_do(&closure);\n+# endif \/\/ LINUX\n+#endif \/\/ ASSERT\n+    } else {\n+      \/\/ on success we've reinitialized earlier\n+      MemoryPersister::reinit_memory();\n+    }\n+    MemoryPersister::load_on_restore();\n+    Universe::heap()->on_restore();\n+    after_threads_restored();\n+  }\n+#ifdef LINUX\n+  PerfMemoryLinux::restore();\n+#endif\n@@ -468,0 +490,1 @@\n+\n","filename":"src\/hotspot\/share\/runtime\/crac.cpp","additions":100,"deletions":77,"binary":false,"changes":177,"status":"modified"},{"patch":"@@ -33,7 +33,0 @@\n-#ifdef  _WINDOWS\n-# include <io.h>\n-# define close _close\n-#else\n-# include <unistd.h>\n-#endif \/\/ _WINDOWS\n-\n@@ -68,5 +61,1 @@\n-    virtual ~MemoryWriter() {\n-      if (_fd >= 0) {\n-        ::close(_fd);\n-      }\n-    }\n+    virtual ~MemoryWriter();\n@@ -82,5 +71,1 @@\n-    virtual ~MemoryReader() {\n-      if (_fd >= 0) {\n-        ::close(_fd);\n-      }\n-    }\n+    virtual ~MemoryReader();\n@@ -132,1 +117,1 @@\n-    static constexpr char MEMORY_IMG[] = \"memory.img\";\n+    static const char *MEMORY_IMG;\n@@ -146,1 +131,1 @@\n-    static void assert_mem(void *addr, size_t used, size_t total);\n+    static void assert_mem(void *addr, size_t used, size_t total, bool executable);\n@@ -154,2 +139,3 @@\n-  static void before_threads_persisted();\n-  static void after_threads_restored();\n+  static bool memory_checkpoint();\n+  static void threads_checkpoint();\n+  static void memory_restore(bool successful);\n@@ -161,0 +147,4 @@\n+  static void before_threads_persisted();\n+  static void after_threads_restored();\n+  static bool can_write_image();\n+\n","filename":"src\/hotspot\/share\/runtime\/crac.hpp","additions":11,"deletions":21,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -23,0 +23,2 @@\n+#include \"precompiled.hpp\"\n+\n@@ -25,0 +27,1 @@\n+#include <sys\/stat.h>\n@@ -30,1 +33,19 @@\n-const char crac::MemoryPersister::MEMORY_IMG[11];\n+#ifdef  _WINDOWS\n+# include <io.h>\n+# define close _close\n+#else\n+# include <unistd.h>\n+#endif \/\/ _WINDOWS\n+\n+#ifndef PATH_MAX \/\/ Windows?\n+# define PATH_MAX MAX_PATH\n+#endif\n+#ifndef S_IRUSR\n+# define S_IRUSR _S_IREAD\n+#endif\n+#ifndef S_IWUSR\n+# define S_IWUSR _S_IWRITE\n+#endif\n+\n+\n+const char *crac::MemoryPersister::MEMORY_IMG = \"memory.img\";\n@@ -34,0 +55,12 @@\n+crac::MemoryWriter::~MemoryWriter() {\n+  if (_fd >= 0) {\n+    ::close(_fd);\n+  }\n+}\n+\n+crac::MemoryReader::~MemoryReader() {\n+  if (_fd >= 0) {\n+    ::close(_fd);\n+  }\n+}\n+\n@@ -105,0 +138,1 @@\n+  assert(_writer != nullptr, \"MemoryPersister not initialized\");\n@@ -108,0 +142,8 @@\n+#ifdef __APPLE__\n+  if (executable) {\n+    \/\/ On Apple it is not possible to create a RWX mapping without MAP_JIT flag;\n+    \/\/ however the combination MAP_JIT and MAP_FIXED is prohibites. That means\n+    \/\/ that if we unmap this region we wouldn't be able to remap it again.\n+    return true;\n+  }\n+#endif \/\/ _APPLE_\n@@ -124,6 +166,1 @@\n-      _index.append({\n-        .addr = start,\n-        .length = (size_t) (curr - start),\n-        .offset = BAD_OFFSET,\n-        .flags = Flags::ACCESSIBLE | execFlag\n-      });\n+      _index.append({ start, (size_t) (curr - start), BAD_OFFSET, Flags::ACCESSIBLE | execFlag });\n@@ -137,6 +174,1 @@\n-      _index.append({\n-        .addr = start,\n-        .length = to_write,\n-        .offset = offset,\n-        .flags = Flags::DATA | Flags::ACCESSIBLE | execFlag\n-      });\n+      _index.append({ start, to_write, offset, Flags::DATA | Flags::ACCESSIBLE | execFlag });\n@@ -149,6 +181,1 @@\n-    _index.append({\n-      .addr = (address) addr + aligned_length,\n-      .length = mapped_length - aligned_length,\n-      .offset = BAD_OFFSET,\n-      .flags = Flags::ACCESSIBLE | execFlag\n-    });\n+    _index.append({ (address) addr + aligned_length, mapped_length - aligned_length, BAD_OFFSET, Flags::ACCESSIBLE | execFlag });\n@@ -172,6 +199,1 @@\n-  _index.append({\n-    .addr = (address) addr,\n-    .length = length,\n-    .offset = BAD_OFFSET,\n-    .flags = 0\n-  });\n+  _index.append({ (address) addr, length, BAD_OFFSET, 0 });\n@@ -218,1 +240,1 @@\n-          fatal(\"Cannot remap memory at %p-%p\", r.addr, r.addr + aligned_length);\n+          fatal(\"Cannot update memory protection (%d) at %p-%p\", protType, r.addr, r.addr + aligned_length);\n@@ -229,1 +251,1 @@\n-void crac::MemoryPersister::assert_mem(void *addr, size_t used, size_t total) {\n+void crac::MemoryPersister::assert_mem(void *addr, size_t used, size_t total, bool executable) {\n@@ -233,0 +255,7 @@\n+#ifdef __APPLE__\n+  if (executable) {\n+    \/\/ not present in index; see ::store(...)\n+    return;\n+  }\n+#endif \/\/ _APPLE_\n+\n@@ -239,1 +268,1 @@\n-  int at = _index.find_sorted<struct record>(&comparator, { .addr = (address) addr }, found);\n+  int at = _index.find_sorted<struct record>(&comparator, { (address) addr, 0, 0, 0 }, found);\n@@ -247,0 +276,1 @@\n+    assert(!!(r.flags & Flags::EXECUTABLE) == executable, \"Bad flags for %p: 0x%x (executable %d)\", r.addr, r.flags, executable);\n@@ -272,1 +302,1 @@\n-    int at = _index.find_sorted<struct record>(&comparator, { .addr = (address) addr }, found);\n+    int at = _index.find_sorted<struct record>(&comparator, { (address) addr, 0, 0, 0 }, found);\n@@ -297,0 +327,21 @@\n+\n+bool crac::can_write_image() {\n+  char path[PATH_MAX];\n+  snprintf(path, PATH_MAX, \"%s%s.test\", CRaCCheckpointTo, os::file_separator());\n+  int fd = os::open(path, O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR);\n+  if (fd < 0) {\n+    tty->print_cr(\"Cannot create %s: %s\\n\", path, os::strerror(errno));\n+    return false;\n+  }\n+  bool success = write(fd, \"test\", 4) > 0;\n+  if (!success) {\n+    tty->print_cr(\"Cannot write to %s: %s\\n\", path, os::strerror(errno));\n+  }\n+  if (::close(fd)) {\n+    tty->print_cr(\"Cannot close %s: %s\", path, os::strerror(errno));\n+  }\n+  if (::unlink(path)) {\n+    tty->print_cr(\"Cannot remove %s: %s\", path, os::strerror(errno));\n+  }\n+  return success;\n+}\n","filename":"src\/hotspot\/share\/runtime\/crac_memory.cpp","additions":80,"deletions":29,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -203,2 +203,0 @@\n-  bool memory_checkpoint();\n-  void memory_restore();\n","filename":"src\/hotspot\/share\/runtime\/crac_structs.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,3 +32,2 @@\n-#ifdef LINUX\n-#include <unistd.h>\n-#define RESTORE_SIGNAL   (SIGRTMIN + 2)\n+#ifndef WIN32\n+# include <unistd.h>\n@@ -37,0 +36,3 @@\n+#endif\n+#ifdef LINUX\n+#define RESTORE_SIGNAL   (SIGRTMIN + 2)\n@@ -60,1 +62,1 @@\n-#ifdef LINUX\n+#ifndef WIN32\n@@ -64,1 +66,1 @@\n-#endif \/\/LINUX\n+#endif \/\/ WIN32\n","filename":"src\/java.base\/share\/native\/pauseengine\/pauseengine.c","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -57,1 +57,5 @@\n-        assertEquals(expectedPid.trim(), String.valueOf(process.pid()));\n+        \/\/ On Windows pauseengine does not write the actual PID to the file\n+        expectedPid = expectedPid.trim();\n+        if (!expectedPid.equals(\"-1\")) {\n+            assertEquals(expectedPid, String.valueOf(process.pid()));\n+        }\n","filename":"test\/lib\/jdk\/test\/lib\/crac\/CracProcess.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"}]}