{"files":[{"patch":"@@ -35,0 +35,2 @@\n+#include \"runtime\/threadSMR.hpp\"\n+#include \"runtime\/threadSMR.inline.hpp\"\n@@ -478,17 +480,0 @@\n-static bool read_all(int fd, char *dest, size_t n) {\n-  size_t rd = 0;\n-  do {\n-    ssize_t r = ::read(fd, dest + rd, n - rd);\n-    if (r == 0) {\n-      return false;\n-    } else if (r < 0) {\n-      if (errno == EINTR) {\n-        continue;\n-      }\n-      return false;\n-    }\n-    rd += r;\n-  } while (rd < n);\n-  return true;\n-}\n-\n@@ -574,1 +559,1 @@\n-#if defined(__x86_64__)\n+#ifdef AMD64\n@@ -590,1 +575,17 @@\n-#elif defined(__aarch64__)\n+#elif IA32\n+  asm volatile (\n+    \"mov $0, %%esi\\n\\t\"\n+    \"mov $0, %%edi\\n\\t\"\n+    \/\/ note: ebp (6th param) should be zero-ed as well, but GCC does not allow to clobber it\n+    \".begin: mov %[sysnum], %%eax\\n\\t\"\n+    \"int $0x80\\n\\t\"\n+    \"test %%eax, %%eax\\n\\t\" \/\/ exit the loop on error\n+    \"jnz .end\\n\\t\"\n+    \"mov (%%ecx), %%esi\\n\\t\"\n+    \"test %%esi, %%esi\\n\\t\"\n+    \"jnz .begin\\n\\t\"\n+    \".end: nop\\n\\t\"\n+    : \"=a\"(retval)\n+    : [sysnum]\"i\"(SYS_futex), \"b\"(&persist_futex), \"c\"(FUTEX_WAIT_PRIVATE), \"d\"(1)\n+    : \"memory\", \"cc\", \"esi\", \"edi\");\n+#elif defined(AARCH64)\n@@ -627,1 +628,0 @@\n-  int dec = Atomic::sub(&persist_waiters, 1);\n@@ -635,4 +635,0 @@\n-  if (dec == 0) {\n-    FREE_C_HEAP_ARRAY(struct __ptrace_rseq_configuration, rseq_configs);\n-    rseq_configs = nullptr;\n-  }\n@@ -707,3 +703,0 @@\n-  CountThreadsClosure counter;\n-  Threads::java_threads_do(&counter);\n-\n@@ -714,0 +707,1 @@\n+  uint num_java_threads = ThreadsSMRSupport::get_java_thread_list()->length();\n@@ -716,2 +710,2 @@\n-    struct __ptrace_rseq_configuration, counter.count(), mtInternal);\n-  guarantee(rseq_configs, \"Cannot allocate %lu rseq structs\", counter.count());\n+    struct __ptrace_rseq_configuration, num_java_threads, mtInternal);\n+  guarantee(rseq_configs, \"Cannot allocate %u rseq structs\", num_java_threads);\n@@ -751,1 +745,1 @@\n-  while ((size_t) persist_waiters < counter.count()) {\n+  while ((uint) persist_waiters < num_java_threads) {\n@@ -765,0 +759,4 @@\n+#ifdef HAS_RSEQ\n+  FREE_C_HEAP_ARRAY(struct __ptrace_rseq_configuration, rseq_configs);\n+  rseq_configs = nullptr;\n+#endif\n","filename":"src\/hotspot\/os\/linux\/crac_linux.cpp","additions":28,"deletions":30,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -1885,1 +1885,4 @@\n-    if (heap != nullptr) {\n+    \/\/ Non-nMethods heap is used for code stubs that are used for atomic operations\n+    \/\/ on aarch64; as these are used e.g. for all allocations\/frees it would be complicated\n+    \/\/ to avoid those until the memory is fully restored.\n+    if (heap != nullptr && heap->code_blob_type() != CodeBlobType::NonNMethod) {\n@@ -1895,1 +1898,1 @@\n-    if (heap != nullptr) {\n+    if (heap != nullptr && heap->code_blob_type() != CodeBlobType::NonNMethod) {\n","filename":"src\/hotspot\/share\/code\/codeCache.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1322,1 +1322,1 @@\n-  void persist_for_checkpoint() {\n+  void persist_for_checkpoint() override {\n@@ -1328,1 +1328,1 @@\n-  void on_restore() {\n+  void on_restore() override {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -696,0 +696,17 @@\n+\n+bool crac::read_all(int fd, char *dest, size_t n) {\n+  size_t rd = 0;\n+  do {\n+    ssize_t r = ::read(fd, dest + rd, n - rd);\n+    if (r == 0) {\n+      return false;\n+    } else if (r < 0) {\n+      if (errno == EINTR) {\n+        continue;\n+      }\n+      return false;\n+    }\n+    rd += r;\n+  } while (rd < n);\n+  return true;\n+}\n","filename":"src\/hotspot\/share\/runtime\/crac.cpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -32,1 +32,6 @@\n-#include <unistd.h>\n+#ifdef  _WINDOWS\n+# include <io.h>\n+# define close _close\n+#else\n+# include <unistd.h>\n+#endif \/\/ _WINDOWS\n@@ -36,1 +41,1 @@\n-#define BAD_OFFSET 0xFFFFFFFFBAD0FF5Eull\n+#define BAD_OFFSET 0xBAD0FF5Eull\n@@ -90,0 +95,6 @@\n+  class FileMemoryReader: public crac::MemoryReader {\n+  public:\n+    FileMemoryReader(const char *filename): MemoryReader(filename) {}\n+    void read(size_t offset, void *addr, size_t size, bool executable) override;\n+  };\n+\n@@ -142,0 +153,1 @@\n+  static bool read_all(int fd, char *buf, size_t bytes);\n@@ -150,15 +162,0 @@\n-class CountThreadsClosure: public ThreadClosure {\n-private:\n-  size_t _count;\n-public:\n-  CountThreadsClosure(): _count(0) {}\n-\n-  void do_thread(Thread* t) {\n-    ++_count;\n-  }\n-\n-  size_t count() {\n-    return _count;\n-  }\n-};\n-\n","filename":"src\/hotspot\/share\/runtime\/crac.hpp","additions":14,"deletions":17,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+#include <string.h>\n@@ -80,0 +81,10 @@\n+void crac::FileMemoryReader::read(size_t offset, void *addr, size_t length, bool executable) {\n+  assert(_fd >= 0, \"File descriptor not open\");\n+  if (os::seek_to_file_offset(_fd, offset) < 0) {\n+    fatal(\"Cannot seek in persisted memory file: %d, 0x%zx: %s\", _fd, offset, os::strerror(errno));\n+  }\n+  if (!read_all(_fd, (char *) addr, length)) {\n+    fatal(\"Cannot read persisted memory file at %p (0x%zx = %zu): %s\", addr, length, length, os::strerror(errno));\n+  }\n+};\n+\n@@ -82,0 +93,1 @@\n+  _index.clear();\n@@ -98,2 +110,2 @@\n-  assert(length <= mapped_length, \"Useful length %lx longer than mapped %lx\", length, mapped_length);\n-  assert((mapped_length & (page_size - 1)) == 0, \"Unaligned length %lx at %p (page size %lx)\", mapped_length, addr, page_size);\n+  assert(length <= mapped_length, \"Useful length %zx longer than mapped %zx\", length, mapped_length);\n+  assert((mapped_length & (page_size - 1)) == 0, \"Unaligned length %zx at %p (page size %zx)\", mapped_length, addr, page_size);\n@@ -162,1 +174,11 @@\n-  MmappingMemoryReader reader(MEMORY_IMG);\n+  MemoryReader *reader;\n+  bool should_map = false;\n+  \/\/ When pauseengine\/simengine is used we can do repeated checkpoints;\n+  \/\/ when the memory is mmapped and we try to write it second time, the file\n+  \/\/ would be truncated and subsequent attempt to read the data could cause SIGBUS.\n+  if (CREngine != nullptr && (!strncmp(CREngine, \"pauseengine\", 10) || !strncmp(CREngine, \"simengine\", 8))) {\n+    reader = new FileMemoryReader(MEMORY_IMG);\n+    should_map = true;\n+  } else {\n+    reader = new MmappingMemoryReader(MEMORY_IMG);\n+  }\n@@ -174,1 +196,5 @@\n-        reader.read(r.offset, (char *) r.addr, r.length, r.flags & Flags::EXECUTABLE);\n+        char *data = (char *) r.addr;\n+        if (should_map && !map(data, aligned_length, executable)) {\n+          fatal(\"Cannot remap memory at %p-%p\", (void *) r.addr, (void *)(r.addr + aligned_length));\n+        }\n+        reader->read(r.offset, data, r.length, r.flags & Flags::EXECUTABLE);\n@@ -183,0 +209,1 @@\n+  delete reader;\n@@ -185,0 +212,6 @@\n+#ifdef _LP64\n+# define FMT64X \"%lx\"\n+#else\n+# define FMT64X \"%llx\"\n+#endif\n+\n@@ -186,0 +219,1 @@\n+\n@@ -188,1 +222,1 @@\n-  assert((total & (os::vm_page_size() - 1)) == 0, \"Unaligned length %lx\", total);\n+  assert((total & (os::vm_page_size() - 1)) == 0, \"Unaligned length %zx\", total);\n@@ -202,3 +236,3 @@\n-    assert((void   *) r.addr == addr, \"Unexpected address %lx, expected %p\", r.addr, addr);\n-    assert(r.flags & Flags::ACCESSIBLE, \"Bad flags for %lx: 0x%x\", r.addr, r.flags);\n-    assert(r.length <= used, \"Persisted memory region length does not match at %p: %lu vs. %lu\", addr, used, r.length);\n+    assert((void   *) r.addr == addr, \"Unexpected address \" FMT64X \", expected %p\", r.addr, addr);\n+    assert(r.flags & Flags::ACCESSIBLE, \"Bad flags for \" FMT64X \": 0x%x\", r.addr, r.flags);\n+    assert(r.length <= used, \"Persisted memory region length does not match at %p: %zu vs. \" FMT64X, addr, used, r.length);\n@@ -206,1 +240,1 @@\n-      assert(r.offset != BAD_OFFSET, \"Invalid offset at %lx\", r.addr);\n+      assert(r.offset != BAD_OFFSET, \"Invalid offset at \" FMT64X, r.addr);\n@@ -208,1 +242,1 @@\n-      assert(r.offset == BAD_OFFSET, \"Invalid offset at %lx: %lx\", r.addr, r.offset);\n+      assert(r.offset == BAD_OFFSET, \"Invalid offset at \" FMT64X \": \" FMT64X, r.addr, r.offset);\n@@ -216,2 +250,2 @@\n-    assert((void *) g.addr == gap_addr, \"Invalid address for the gap region: %lx vs. %p\", g.addr, gap_addr);\n-    assert(g.length == unused, \"Persisted gap length does not match at %p: %lu vs. %lu\", gap_addr, unused, g.length);\n+    assert((void *) g.addr == gap_addr, \"Invalid address for the gap region: \" FMT64X \" vs. %p\", g.addr, gap_addr);\n+    assert(g.length == unused, \"Persisted gap length does not match at %p: %zu vs. \" FMT64X, gap_addr, unused, g.length);\n@@ -219,1 +253,1 @@\n-    assert(g.offset == BAD_OFFSET, \"Invalid offset at %p: %lx\", gap_addr, g.offset);\n+    assert(g.offset == BAD_OFFSET, \"Invalid offset at %p: \" FMT64X, gap_addr, g.offset);\n@@ -225,1 +259,1 @@\n-  assert((length & (os::vm_page_size() - 1)) == 0, \"Unaligned length %lx\", length);\n+  assert((length & (os::vm_page_size() - 1)) == 0, \"Unaligned length %zx\", length);\n@@ -232,1 +266,1 @@\n-    assert(r.length == length, \"Persisted memory region length does not match at %p: %lu vs. %lu\", addr, length, r.length);\n+    assert(r.length == length, \"Persisted memory region length does not match at %p: %zu vs. \" FMT64X, addr, length, r.length);\n@@ -234,1 +268,1 @@\n-    assert(r.offset == BAD_OFFSET, \"Invalid offset at %p: %lx\", addr, r.offset);\n+    assert(r.offset == BAD_OFFSET, \"Invalid offset at %p: \" FMT64X, addr, r.offset);\n","filename":"src\/hotspot\/share\/runtime\/crac_memory.cpp","additions":50,"deletions":16,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -24,0 +24,3 @@\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n@@ -31,1 +34,1 @@\n- * @run driver\/timeout=60 jdk.test.lib.crac.CracTest 10\n+ * @run driver\/timeout=15 jdk.test.lib.crac.CracTest 10\n@@ -35,0 +38,1 @@\n+    private static final AtomicInteger restoreCount = new AtomicInteger(0);\n@@ -37,1 +41,1 @@\n-    @CracTestArg\n+    @CracTestArg(0)\n@@ -40,0 +44,3 @@\n+    @CracTestArg(value = 1, optional = true)\n+    String restoreCountPath;\n+\n@@ -43,0 +50,7 @@\n+        \/\/ remove pid file if it exists from previous run\n+        builder.imageDir().resolve(\"pid\").toFile().delete();\n+        restoreCountPath = builder.imageDir().resolve(\"restoreCount\").toAbsolutePath().toString();\n+        builder.imageDir().toFile().mkdirs();\n+        Files.writeString(Path.of(restoreCountPath), \"0\");\n+\n+        builder.args(CracTest.args(restoreCountPath));\n@@ -46,0 +60,1 @@\n+            assert process.isAlive();\n@@ -48,0 +63,5 @@\n+            String currentRestore;\n+            do {\n+                Thread.sleep(20);\n+                currentRestore = Files.readString(Path.of(restoreCountPath));\n+            } while(!currentRestore.equals(String.valueOf(i)));\n@@ -52,1 +72,1 @@\n-    private static class TestThread extends Thread {\n+    private class TestThread extends Thread {\n@@ -57,1 +77,1 @@\n-                jdk.crac.Core.checkpointRestore();\n+                doCheckpointRestore();\n@@ -64,0 +84,4 @@\n+            } catch (IOException e) {\n+                if (exception == null) {\n+                    exception = e;\n+                }\n@@ -112,1 +136,1 @@\n-        Core.getGlobalContext().register(new Test());\n+        Core.getGlobalContext().register(this);\n@@ -122,1 +146,1 @@\n-            jdk.crac.Core.checkpointRestore();\n+            doCheckpointRestore();\n@@ -124,1 +148,1 @@\n-            throw new RuntimeException(\"Checkpoint ERROR \" + e);\n+            throw new RuntimeException(\"Checkpoint ERROR\", e);\n@@ -126,1 +150,1 @@\n-            throw new RuntimeException(\"Restore ERROR \" + e);\n+            throw new RuntimeException(\"Restore ERROR\", e);\n@@ -141,0 +165,7 @@\n+\n+    private void doCheckpointRestore() throws CheckpointException, RestoreException, IOException {\n+        Core.checkpointRestore();\n+        int rc = restoreCount.incrementAndGet();\n+        System.err.printf(\"After restore #%d%n\", rc, restoreCountPath);\n+        Files.writeString(Path.of(restoreCountPath), String.valueOf(rc));\n+    }\n","filename":"test\/jdk\/jdk\/crac\/recursiveCheckpoint\/Test.java","additions":39,"deletions":8,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -56,0 +56,2 @@\n+        String expectedPid = Files.readString(builder.imageDir().toAbsolutePath().resolve(\"pid\"));\n+        assertEquals(expectedPid.trim(), String.valueOf(process.pid()));\n@@ -131,0 +133,4 @@\n+\n+    public boolean isAlive() {\n+        return process.isAlive();\n+    }\n","filename":"test\/lib\/jdk\/test\/lib\/crac\/CracProcess.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -196,0 +196,2 @@\n+     *\n+     * @param extraArgs Optional parameters that were not part of the <code>@run<\/code> jtreg tag\n","filename":"test\/lib\/jdk\/test\/lib\/crac\/CracTest.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}