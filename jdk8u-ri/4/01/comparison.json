{"files":[{"patch":"@@ -1910,1 +1910,1 @@\n-  initialize_wk_klasses_through(WK_KLASS_ENUM_NAME(Cleaner_klass), scan, CHECK);\n+  initialize_wk_klasses_through(WK_KLASS_ENUM_NAME(PhantomReference_klass), scan, CHECK);\n@@ -1915,1 +1915,0 @@\n-  InstanceKlass::cast(WK_KLASS(Cleaner_klass))->set_reference_type(REF_CLEANER);\n","filename":"hotspot\/src\/share\/vm\/classfile\/systemDictionary.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -131,1 +131,0 @@\n-  do_klass(Cleaner_klass,                               sun_misc_Cleaner,                          Pre                 ) \\\n","filename":"hotspot\/src\/share\/vm\/classfile\/systemDictionary.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -82,1 +82,0 @@\n-  template(sun_misc_Cleaner,                          \"sun\/misc\/Cleaner\")                         \\\n","filename":"hotspot\/src\/share\/vm\/classfile\/vmSymbols.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -121,1 +121,0 @@\n-  _discoveredCleanerRefs = &_discoveredPhantomRefs[_max_num_q];\n@@ -248,8 +247,1 @@\n-      process_discovered_reflist(_discoveredPhantomRefs, NULL, false,\n-                                 is_alive, keep_alive, complete_gc, task_executor);\n-\n-    \/\/ Process cleaners, but include them in phantom statistics.  We expect\n-    \/\/ Cleaner references to be temporary, and don't want to deal with\n-    \/\/ possible incompatibilities arising from making it more visible.\n-    phantom_count +=\n-      process_discovered_reflist(_discoveredCleanerRefs, NULL, false,\n+      process_discovered_reflist(_discoveredPhantomRefs, NULL, true,\n@@ -894,1 +886,0 @@\n-  balance_queues(_discoveredCleanerRefs);\n@@ -1054,3 +1045,0 @@\n-    case REF_CLEANER:\n-      list = &_discoveredCleanerRefs[id];\n-      break;\n@@ -1322,11 +1310,0 @@\n-\n-    \/\/ Cleaner references.  Included in timing for phantom references.  We\n-    \/\/ expect Cleaner references to be temporary, and don't want to deal with\n-    \/\/ possible incompatibilities arising from making it more visible.\n-    for (uint i = 0; i < _max_num_q; i++) {\n-      if (yield->should_return()) {\n-        return;\n-      }\n-      preclean_discovered_reflist(_discoveredCleanerRefs[i], is_alive,\n-                                  keep_alive, complete_gc, yield);\n-    }\n@@ -1401,1 +1378,0 @@\n-     case 4: return \"CleanerRef\";\n","filename":"hotspot\/src\/share\/vm\/memory\/referenceProcessor.cpp","additions":1,"deletions":25,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -267,1 +267,0 @@\n-  DiscoveredList* _discoveredCleanerRefs;\n@@ -270,1 +269,1 @@\n-  static int number_of_subclasses_of_ref() { return (REF_CLEANER - REF_OTHER); }\n+  static int number_of_subclasses_of_ref() { return (REF_PHANTOM - REF_OTHER); }\n","filename":"hotspot\/src\/share\/vm\/memory\/referenceProcessor.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -38,2 +38,1 @@\n-  REF_PHANTOM,   \/\/ Subclass of java\/lang\/ref\/PhantomReference\n-  REF_CLEANER    \/\/ Subclass of sun\/misc\/Cleaner\n+  REF_PHANTOM    \/\/ Subclass of java\/lang\/ref\/PhantomReference\n","filename":"hotspot\/src\/share\/vm\/memory\/referenceType.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -674,1 +674,0 @@\n-      static_field(SystemDictionary,            WK_KLASS(Cleaner_klass),                       Klass*)                               \\\n","filename":"hotspot\/src\/share\/vm\/runtime\/vmStructs.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2003, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2015, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,2 +32,1 @@\n- * references are most often used for scheduling pre-mortem cleanup actions in\n- * a more flexible way than is possible with the Java finalization mechanism.\n+ * references are most often used to schedule post-mortem cleanup actions.\n@@ -35,4 +34,7 @@\n- * <p> If the garbage collector determines at a certain point in time that the\n- * referent of a phantom reference is <a\n- * href=\"package-summary.html#reachability\">phantom reachable<\/a>, then at that\n- * time or at some later time it will enqueue the reference.\n+ * <p> Suppose the garbage collector determines at a certain point in time\n+ * that an object is <a href=\"package-summary.html#reachability\">\n+ * phantom reachable<\/a>.  At that time it will atomically clear\n+ * all phantom references to that object and all phantom references to\n+ * any other phantom-reachable objects from which that object is reachable.\n+ * At the same time or at some later time it will enqueue those newly-cleared\n+ * phantom references that are registered with reference queues.\n@@ -44,5 +46,0 @@\n- * <p> Unlike soft and weak references, phantom references are not\n- * automatically cleared by the garbage collector as they are enqueued.  An\n- * object that is reachable via phantom references will remain so until all\n- * such references are cleared or themselves become unreachable.\n- *\n@@ -72,2 +69,2 @@\n-     * method will always return null and, since it does not have a queue, it\n-     * will never be enqueued.\n+     * method will always return {@code null} and, since it does not have a queue,\n+     * it will never be enqueued.\n","filename":"jdk\/src\/share\/classes\/java\/lang\/ref\/PhantomReference.java","additions":11,"deletions":14,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- Copyright (c) 1998, 2003, Oracle and\/or its affiliates. All rights reserved.\n+ Copyright (c) 1998, 2015, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,2 +49,1 @@\n-pre-mortem cleanup actions in a more flexible way than is possible with the\n-Java finalization mechanism.\n+post-mortem cleanup actions.\n@@ -69,3 +68,4 @@\n-to the value corresponding to the type of the reference, it will add the\n-reference to the associated queue.  At this point, the reference is considered\n-to be <em>enqueued<\/em>.  The program may remove references from a queue either\n+to the value corresponding to the type of the reference, it will clear the\n+reference and add it to the associated queue.  At this point, the\n+reference is considered to be <em>enqueued<\/em>.  The program may remove\n+references from a queue either\n@@ -94,11 +94,0 @@\n-\n-<h3>Automatically-cleared references<\/h3>\n-\n-Soft and weak references are automatically cleared by the collector before\n-being added to the queues with which they are registered, if any.  Therefore\n-soft and weak references need not be registered with a queue in order to be\n-useful, while phantom references do.  An object that is reachable via phantom\n-references will remain so until all such references are cleared or themselves\n-become unreachable.\n-\n-\n","filename":"jdk\/src\/share\/classes\/java\/lang\/ref\/package.html","additions":6,"deletions":17,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -0,0 +1,101 @@\n+\/*\n+ * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8071507\n+ * @summary Test that PhantomReferences are cleared when notified.\n+ * @run main\/othervm PhantomReferentClearing\n+ *\/\n+\n+import java.lang.ref.PhantomReference;\n+import java.lang.ref.ReferenceQueue;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class PhantomReferentClearing {\n+\n+    private static final long ENQUEUE_TIMEOUT = 1000;   \/\/ 1 sec, in millis\n+\n+    \/\/ P1 & P2 are PhantomReference objects\n+    \/\/ O1 & O2 are objects\n+    \/\/\n+    \/\/ -> is a strong reference\n+    \/\/ => is a referent reference\n+    \/\/\n+    \/\/   root -> P1\n+    \/\/   root -> P2\n+    \/\/   root -> O1\n+    \/\/   root -> O2\n+    \/\/   O1 -> O2\n+    \/\/   P1 => O1\n+    \/\/   P2 => O2\n+    \/\/\n+    \/\/ (1) Remove root -> O1 and collect.  P1 notified, P2 !notified.\n+    \/\/ (2) Remove root -> O2 and collect.\n+    \/\/\n+    \/\/ If phantom references are cleared when notified, as proposed by\n+    \/\/ 8071507, then P2 should be notified, and the test passes.\n+    \/\/\n+    \/\/ Otherwise, P2 does not get notified because it remains reachable\n+    \/\/ from O1, which is being retained by P1.  This fails the test.\n+\n+    private static final ReferenceQueue<Object> Q1 = new ReferenceQueue<>();\n+    private static final ReferenceQueue<Object> Q2 = new ReferenceQueue<>();\n+\n+    private static volatile Object O2 = new Object();\n+    private static volatile List<Object> O1 = new ArrayList<>();\n+    static {\n+        O1.add(O2);\n+    }\n+\n+    private static final PhantomReference<Object> P1 = new PhantomReference<>(O1, Q1);\n+    private static final PhantomReference<Object> P2 = new PhantomReference<>(O2, Q2);\n+\n+    public static void main(String[] args) throws InterruptedException {\n+\n+        \/\/ Collect, and verify neither P1 or P2 notified.\n+        System.gc();\n+        if (Q1.remove(ENQUEUE_TIMEOUT) != null) {\n+            throw new RuntimeException(\"P1 already notified\");\n+        } else if (Q2.poll() != null) {\n+            throw new RuntimeException(\"P2 already notified\");\n+        }\n+\n+        \/\/ Delete root -> O1, collect, verify P1 notified, P2 not notified.\n+        O1 = null;\n+        System.gc();\n+        if (Q1.remove(ENQUEUE_TIMEOUT) == null) {\n+            throw new RuntimeException(\"P1 not notified by O1 deletion\");\n+        } else if (Q2.remove(ENQUEUE_TIMEOUT) != null) {\n+            throw new RuntimeException(\"P2 notified by O1 deletion.\");\n+        }\n+\n+        \/\/ Delete root -> O2, collect. P2 should be notified.\n+        O2 = null;\n+        System.gc();\n+        if (Q2.remove(ENQUEUE_TIMEOUT) == null) {\n+            throw new RuntimeException(\"P2 not notified by O2 deletion\");\n+        }\n+    }\n+}\n","filename":"jdk\/test\/java\/lang\/ref\/PhantomReferentClearing.java","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"}]}