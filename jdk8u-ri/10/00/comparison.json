{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -108,0 +108,7 @@\n+        \/\/ isJavaIdentifierStart strictly conforms to code points assigned\n+        \/\/ in Unicode 6.2. Since code points {32FF}, {20BB..20BF}, and\n+        \/\/ {9FCD..9FEF} are not from Unicode 6.2, return false.\n+        if(ch == 0x32FF ||\n+          (ch>= 0x20BB && ch<= 0x20BF) ||\n+          (ch>= 0x9FCD && ch<= 0x9FEF))\n+            return false;\n@@ -113,0 +120,7 @@\n+        \/\/ isJavaIdentifierPart strictly conforms to code points assigned\n+        \/\/ in Unicode 6.2. Since code points {32FF}, {20BB..20BF}, and\n+        \/\/ {9FCD..9FEF} are not from Unicode 6.2, return false.\n+        if(ch == 0x32FF ||\n+          (ch>= 0x20BB && ch<= 0x20BF) ||\n+          (ch>= 0x9FCD && ch<= 0x9FEF))\n+            return false;\n","filename":"jdk\/make\/data\/characterdata\/CharacterData00.java.template","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -7194,0 +7194,5 @@\n+20BB;NORDIC MARK SIGN;Sc;0;ET;;;;;N;;;;;\n+20BC;MANAT SIGN;Sc;0;ET;;;;;N;;;;;\n+20BD;RUBLE SIGN;Sc;0;ET;;;;;N;;;;;\n+20BE;LARI SIGN;Sc;0;ET;;;;;N;;;;;\n+20BF;BITCOIN SIGN;Sc;0;ET;;;;;N;;;;;\n@@ -11406,0 +11411,1 @@\n+32FF;SQUARE ERA NAME NEWERA;So;0;L;<square> 5143 53F7;;;;N;SQUARED TWO IDEOGRAPHS ERA NAME NEWERA;;;;\n@@ -11729,1 +11735,1 @@\n-9FCC;<CJK Ideograph, Last>;Lo;0;L;;;;;N;;;;;\n+9FEF;<CJK Ideograph, Last>;Lo;0;L;;;;;N;;;;;\n","filename":"jdk\/make\/data\/unicodedata\/UnicodeData.txt","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,4 +52,20 @@\n- * The file and its description are available from the Unicode Consortium at:\n- * <ul>\n- * <li><a href=\"http:\/\/www.unicode.org\">http:\/\/www.unicode.org<\/a>\n- * <\/ul>\n+ * The Java SE 8 Platform uses character information from version 6.2\n+ * of the Unicode Standard, with three extensions. First, in recognition of the fact\n+ * that new currencies appear frequently, the Java SE 8 Platform allows an\n+ * implementation of class {@code Character} to use the Currency Symbols\n+ * block from version 10.0 of the Unicode Standard. Second, the Java SE 8 Platform\n+ * allows an implementation of class {@code Character} to use the code points\n+ * in the range of {@code U+9FCD} to {@code U+9FEF} from version 11.0 of the\n+ * Unicode Standard, in order for the class to allow the \"Implementation\n+ * Level 1\" of the Chinese GB18030-2022 standard. Third, the Java SE 8 Platform\n+ * allows an implementation of class {@code Character} to use the Japanese Era\n+ * code point, {@code U+32FF}, from the Unicode Standard version 12.1.\n+ * Consequently, the\n+ * behavior of fields and methods of class {@code Character} may vary across\n+ * implementations of the Java SE 8 Platform when processing the aforementioned\n+ * code points ( outside of version 6.2 ), except for the following methods\n+ * that define Java identifiers:\n+ * {@link #isJavaIdentifierStart(int)}, {@link #isJavaIdentifierStart(char)},\n+ * {@link #isJavaIdentifierPart(int)}, and {@link #isJavaIdentifierPart(char)}.\n+ * Code points in Java identifiers must be drawn from version 6.2 of\n+ * the Unicode Standard.\n@@ -3917,1 +3933,3 @@\n-            0x32D0,   \/\/ 32D0..3357; KATAKANA\n+            0x32D0,   \/\/ 32D0..32FE; KATAKANA\n+            0x32FF,   \/\/ 32FF      ; COMMON\n+            0x3300,   \/\/ 3300..3357; KATAKANA\n@@ -4238,1 +4256,3 @@\n-            KATAKANA,\n+            KATAKANA,  \/\/ 32D0..32FE\n+            COMMON,    \/\/ 32FF\n+            KATAKANA,  \/\/ 3300..3357\n","filename":"jdk\/src\/share\/classes\/java\/lang\/Character.java","additions":27,"deletions":7,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -150,0 +150,1 @@\n+20BB..20BF    ; Common # Sc   [5] NORDIC MARK SIGN..BITCOIN SIGN\n@@ -384,0 +385,1 @@\n+32FF          ; Common # So       SQUARE ERA NAME NEWERA\n@@ -1434,1 +1436,1 @@\n-4E00..9FCC    ; Han # Lo [20941] CJK UNIFIED IDEOGRAPH-4E00..CJK UNIFIED IDEOGRAPH-9FCC\n+4E00..9FEF    ; Han # Lo [20976] CJK UNIFIED IDEOGRAPH-4E00..CJK UNIFIED IDEOGRAPH-9FEF\n@@ -1442,1 +1444,1 @@\n-# Total code points: 75963\n+# Total code points: 75998\n","filename":"jdk\/test\/java\/lang\/Character\/Scripts.txt","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,314 @@\n+\/*\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary Test behavior of isJavaIdentifierXX, testIsJavaLetter, and\n+ *  testIsJavaLetterOrDigit methods for all code points.\n+ * @bug 8218915 8301400\n+ *\/\n+\n+public class TestIsJavaIdentifierMethods {\n+    \/\/ Unassigned code points not present in Unicode 6.2 (which Java SE 8\n+    \/\/ is based upon), including: various currency symbol sign code points\n+    \/\/ (Nordic Mark ... Bitcoin), Japanese Era Square character code point,\n+    \/\/ and 35 CJK Unified Ideograph code points from GB18030-2022\n+    private static final int CS_SIGNS_CODEPOINT_START = 0x20BB;\n+    private static final int CS_SIGNS_CODEPOINT_END = 0x20BF;\n+    private static final int JAPANESE_ERA_CODEPOINT = 0x32FF;\n+    private static final int GB18030_2022_CODEPOINT_START = 0x9FCD;\n+    private static final int GB18030_2022_CODEPOINT_END = 0x9FEF;\n+\n+    public static void main(String[] args) {\n+        testIsJavaIdentifierPart_int();\n+        testIsJavaIdentifierPart_char();\n+        testIsJavaIdentifierStart_int();\n+        testIsJavaIdentifierStart_char();\n+        testIsJavaLetter();\n+        testIsJavaLetterOrDigit();\n+    }\n+\n+    \/**\n+     * Assertion testing for public static boolean isJavaIdentifierPart(int\n+     * codePoint), A character may be part of a Java identifier if any of the\n+     * following are true:\n+     * <ul>\n+     * <li>it is a letter<\/li>\n+     * <li>it is a currency symbol (such as <code>'$'<\/code>)<\/li>\n+     * <li>it is a connecting punctuation character (such as <code>'_'<\/code>)\n+     * <\/li>\n+     * <li>it is a digit<\/li>\n+     * <li>it is a numeric letter (such as a Roman numeral character)<\/li>\n+     * <li>it is a combining mark<\/li>\n+     * <li>it is a non-spacing mark<\/li>\n+     * <li><code>isIdentifierIgnorable<\/code> returns <code>true<\/code> for the\n+     * character<\/li>\n+     * <\/ul>\n+     * All code points from (0x0000..0x10FFFF) are tested.\n+     *\/\n+    public static void testIsJavaIdentifierPart_int() {\n+        for (int cp = 0; cp <= Character.MAX_CODE_POINT; cp++) {\n+            boolean expected = false;\n+            \/\/ Since Character.isJavaIdentifierPart(int) strictly conforms to\n+            \/\/ character information from version 6.2 of the Unicode Standard,\n+            \/\/ check if code point is one of the extra unassigned\n+            \/\/ code points (defined at the beginning of the file). If the code\n+            \/\/ point is found to be one of the unassigned code points,\n+            \/\/ value of variable \"expected\" is considered false.\n+            if (cp != JAPANESE_ERA_CODEPOINT &&\n+                    !(cp >= CS_SIGNS_CODEPOINT_START && cp <= CS_SIGNS_CODEPOINT_END) &&\n+                    !(cp >= GB18030_2022_CODEPOINT_START && cp <= GB18030_2022_CODEPOINT_END)) {\n+                byte type = (byte) Character.getType(cp);\n+                expected = Character.isLetter(cp)\n+                        || type == Character.CURRENCY_SYMBOL\n+                        || type == Character.CONNECTOR_PUNCTUATION\n+                        || Character.isDigit(cp)\n+                        || type == Character.LETTER_NUMBER\n+                        || type == Character.COMBINING_SPACING_MARK\n+                        || type == Character.NON_SPACING_MARK\n+                        || Character.isIdentifierIgnorable(cp);\n+            }\n+\n+            if (Character.isJavaIdentifierPart(cp) != expected) {\n+                throw new RuntimeException(\n+                   \"Character.isJavaIdentifierPart(int) failed for codepoint \"\n+                                + Integer.toHexString(cp));\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Assertion testing for public static boolean isJavaIdentifierPart(char\n+     * ch), A character may be part of a Java identifier if any of the\n+     * following are true:\n+     * <ul>\n+     * <li>it is a letter;\n+     * <li>it is a currency symbol (such as \"$\");\n+     * <li>it is a connecting punctuation character (such as \"_\");\n+     * <li>it is a digit;\n+     * <li>it is a numeric letter (such as a Roman numeral character);\n+     * <li>it is a combining mark;\n+     * <li>it is a non-spacing mark;\n+     * <li>isIdentifierIgnorable returns true for the character.\n+     * <\/ul>\n+     * All Unicode code points in the BMP (0x0000..0xFFFF) are tested.\n+     *\/\n+    public static void testIsJavaIdentifierPart_char() {\n+        for (int i = 0; i <= Character.MAX_VALUE; ++i) {\n+            char ch = (char) i;\n+            boolean expected = false;\n+            \/\/ Since Character.isJavaIdentifierPart(char) strictly conforms to\n+            \/\/ character information from version 6.2 of the Unicode Standard,\n+            \/\/ check if code point is one of the extra unassigned\n+            \/\/ code points (defined at the beginning of the file). If the code\n+            \/\/ point is found to be one of the unassigned code points,\n+            \/\/ value of variable \"expected\" is considered false.\n+            if (i != JAPANESE_ERA_CODEPOINT &&\n+                    !(i >= CS_SIGNS_CODEPOINT_START && i <= CS_SIGNS_CODEPOINT_END) &&\n+                    !(i >= GB18030_2022_CODEPOINT_START && i <= GB18030_2022_CODEPOINT_END)) {\n+                byte type = (byte) Character.getType(ch);\n+                expected = Character.isLetter(ch)\n+                        || type == Character.CURRENCY_SYMBOL\n+                        || type == Character.CONNECTOR_PUNCTUATION\n+                        || Character.isDigit(ch)\n+                        || type == Character.LETTER_NUMBER\n+                        || type == Character.COMBINING_SPACING_MARK\n+                        || type == Character.NON_SPACING_MARK\n+                        || Character.isIdentifierIgnorable(ch);\n+            }\n+\n+            if (Character.isJavaIdentifierPart((char) i) != expected) {\n+                throw new RuntimeException(\n+                \"Character.isJavaIdentifierPart(char) failed for codepoint \"\n+                                + Integer.toHexString(i));\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Assertion testing for public static boolean isJavaIdentifierStart(int\n+     * codePoint), A character may start a Java identifier if and only if it is\n+     * one of the following:\n+     * <ul>\n+     * <li>it is a letter;<\/li>\n+     * <li>getType(ch) returns LETTER_NUMBER;<\/li>\n+     * <li>it is a currency symbol (such as \"$\");<\/li>\n+     * <li>it is a connecting punctuation character (such as \"_\");<\/li>\n+     * <\/ul>\n+     * All Code points from (0x0000..0x10FFFF) are tested.\n+     *\/\n+    public static void testIsJavaIdentifierStart_int() {\n+        for (int cp = 0; cp <= Character.MAX_CODE_POINT; cp++) {\n+            boolean expected = false;\n+            \/\/ Since Character.isJavaIdentifierStart(int) strictly conforms to\n+            \/\/ character information from version 6.2 of the Unicode Standard,\n+            \/\/ check if code point is one of the extra unassigned\n+            \/\/ code points (defined at the beginning of the file). If the code\n+            \/\/ point is found to be one of the unassigned code points,\n+            \/\/ value of variable \"expected\" is considered false.\n+            if (cp != JAPANESE_ERA_CODEPOINT &&\n+                    !(cp >= CS_SIGNS_CODEPOINT_START && cp <= CS_SIGNS_CODEPOINT_END) &&\n+                    !(cp >= GB18030_2022_CODEPOINT_START && cp <= GB18030_2022_CODEPOINT_END)) {\n+                byte type = (byte) Character.getType(cp);\n+                expected = Character.isLetter(cp)\n+                        || type == Character.LETTER_NUMBER\n+                        || type == Character.CURRENCY_SYMBOL\n+                        || type == Character.CONNECTOR_PUNCTUATION;\n+            }\n+\n+            if (Character.isJavaIdentifierStart(cp) != expected) {\n+                throw new RuntimeException(\n+                \"Character.isJavaIdentifierStart(int) failed for codepoint \"\n+                                + Integer.toHexString(cp));\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Assertion testing for public static boolean isJavaIdentifierStart(char),\n+     * A character may start a Java identifier if and only if it is\n+     * one of the following:\n+     * <ul>\n+     * <li>it is a letter;<\/li>\n+     * <li>getType(ch) returns LETTER_NUMBER;<\/li>\n+     * <li>it is a currency symbol (such as \"$\");<\/li>\n+     * <li>it is a connecting punctuation character (such as \"_\");<\/li>\n+     * <\/ul>\n+     * All Unicode code points in the BMP (0x0000..0xFFFF) are tested.\n+     *\/\n+    public static void testIsJavaIdentifierStart_char() {\n+        for (int i = 0; i <= Character.MAX_VALUE; i++) {\n+            char ch = (char) i;\n+            boolean expected = false;\n+            \/\/ Since Character.isJavaIdentifierStart(char) strictly conforms to\n+            \/\/ character information from version 6.2 of the Unicode Standard,\n+            \/\/ check if code point is one of the extra unassigned\n+            \/\/ code points (defined at the beginning of the file). If the code\n+            \/\/ point is found to be one of the unassigned code points,\n+            \/\/ value of variable \"expected\" is considered false.\n+            if (i != JAPANESE_ERA_CODEPOINT &&\n+                    !(i >= CS_SIGNS_CODEPOINT_START && i <= CS_SIGNS_CODEPOINT_END) &&\n+                    !(i >= GB18030_2022_CODEPOINT_START && i <= GB18030_2022_CODEPOINT_END)) {\n+                byte type = (byte) Character.getType(ch);\n+                expected = Character.isLetter(ch)\n+                        || type == Character.LETTER_NUMBER\n+                        || type == Character.CURRENCY_SYMBOL\n+                        || type == Character.CONNECTOR_PUNCTUATION;\n+            }\n+\n+            if (Character.isJavaIdentifierStart(ch) != expected) {\n+                throw new RuntimeException(\n+                \"Character.isJavaIdentifierStart(char) failed for codepoint \"\n+                                + Integer.toHexString(i));\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Assertion testing for public static boolean isJavaLetter(char ch), A\n+     * character may start a Java identifier if and only if one of the\n+     * following is true:\n+     * <ul>\n+     * <li>isLetter(ch) returns true\n+     * <li>getType(ch) returns LETTER_NUMBER\n+     * <li>ch is a currency symbol (such as \"$\")\n+     * <li>ch is a connecting punctuation character (such as \"_\").\n+     * <\/ul>\n+     * All Unicode code points in the BMP (0x0000..0xFFFF) are tested.\n+     *\/\n+    public static void testIsJavaLetter() {\n+        for (int i = 0; i <= Character.MAX_VALUE; ++i) {\n+            char ch = (char) i;\n+            boolean expected = false;\n+            \/\/ Since Character.isJavaLetter(char) strictly conforms to\n+            \/\/ character information from version 6.2 of the Unicode Standard,\n+            \/\/ check if code point is one of the extra unassigned\n+            \/\/ code points (defined at the beginning of the file). If the code\n+            \/\/ point is found to be one of the unassigned code points,\n+            \/\/ value of variable \"expected\" is considered false.\n+            if (i != JAPANESE_ERA_CODEPOINT &&\n+                    !(i >= CS_SIGNS_CODEPOINT_START && i <= CS_SIGNS_CODEPOINT_END) &&\n+                    !(i >= GB18030_2022_CODEPOINT_START && i <= GB18030_2022_CODEPOINT_END)) {\n+                byte type = (byte) Character.getType(ch);\n+                expected = Character.isLetter(ch)\n+                        || type == Character.LETTER_NUMBER\n+                        || type == Character.CURRENCY_SYMBOL\n+                        || type == Character.CONNECTOR_PUNCTUATION;\n+            }\n+\n+            if (Character.isJavaLetter(ch) != expected) {\n+                throw new RuntimeException(\n+                        \"Character.isJavaLetter(ch) failed for codepoint \"\n+                                + Integer.toHexString(i));\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Assertion testing for public static boolean isJavaLetterOrDigit(char\n+     * ch), A character may be part of a Java identifier if and only if any\n+     *  of the following are true:\n+     * <ul>\n+     * <li>it is a letter\n+     * <li>it is a currency symbol (such as '$')\n+     * <li>it is a connecting punctuation character (such as '_')\n+     * <li>it is a digit\n+     * <li>it is a numeric letter (such as a Roman numeral character)\n+     * <li>it is a combining mark\n+     * <li>it is a non-spacing mark\n+     * <li>isIdentifierIgnorable returns true for the character.\n+     * <\/ul>\n+     * All Unicode code points in the BMP (0x0000..0xFFFF) are tested.\n+     *\/\n+    public static void testIsJavaLetterOrDigit() {\n+        for (int i = 0; i <= Character.MAX_VALUE; ++i) {\n+            char ch = (char) i;\n+            boolean expected = false;\n+            \/\/ Since Character.isJavaLetterOrDigit(char) strictly conforms to\n+            \/\/ character information from version 6.2 of the Unicode Standard,\n+            \/\/ check if code point is one of the extra unassigned\n+            \/\/ code points (defined at the beginning of the file). If the code\n+            \/\/ point is found to be one of the unassigned code points,\n+            \/\/ value of variable \"expected\" is considered false.\n+            if (i != JAPANESE_ERA_CODEPOINT &&\n+                    !(i >= CS_SIGNS_CODEPOINT_START && i <= CS_SIGNS_CODEPOINT_END) &&\n+                    !(i >= GB18030_2022_CODEPOINT_START && i <= GB18030_2022_CODEPOINT_END)) {\n+                byte type = (byte) Character.getType(ch);\n+                expected = Character.isLetter(ch)\n+                        || type == Character.CURRENCY_SYMBOL\n+                        || type == Character.CONNECTOR_PUNCTUATION\n+                        || Character.isDigit(ch)\n+                        || type == Character.LETTER_NUMBER\n+                        || type == Character.COMBINING_SPACING_MARK\n+                        || type == Character.NON_SPACING_MARK\n+                        || Character.isIdentifierIgnorable(ch);\n+            }\n+\n+            if (Character.isJavaLetterOrDigit(ch) != expected) {\n+                throw new RuntimeException(\n+                  \"Character.isJavaLetterOrDigit(ch) failed for codepoint \"\n+                                + Integer.toHexString(i));\n+            }\n+        }\n+    }\n+}\n","filename":"jdk\/test\/java\/lang\/Character\/TestIsJavaIdentifierMethods.java","additions":314,"deletions":0,"binary":false,"changes":314,"status":"added"}]}