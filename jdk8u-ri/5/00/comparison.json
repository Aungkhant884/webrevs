{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2017, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,5 @@\n+\n+    @Override\n+    public boolean enqueue() {\n+        throw new InternalError(\"should never reach here\");\n+    }\n","filename":"jdk\/src\/share\/classes\/java\/lang\/ref\/FinalReference.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -216,1 +216,0 @@\n-\n@@ -233,2 +232,2 @@\n-     * Adds this reference object to the queue with which it is registered,\n-     * if any.\n+     * Clears this reference object and adds it to the queue with which\n+     * it is registered, if any.\n@@ -244,0 +243,1 @@\n+        this.referent = null;\n@@ -247,1 +247,0 @@\n-\n@@ -258,1 +257,0 @@\n-\n","filename":"jdk\/src\/share\/classes\/java\/lang\/ref\/Reference.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2017, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n- * @bug 4268317\n+ * @bug 4268317 8175797\n@@ -27,0 +27,1 @@\n+ * @run main ReferenceEnqueue\n@@ -30,0 +31,2 @@\n+import java.util.ArrayList;\n+import java.util.List;\n@@ -34,1 +37,1 @@\n-        for (int i=0; i < 5; i++)\n+        for (int i=0; i < 5; i++) {\n@@ -36,0 +39,2 @@\n+            new ExplicitEnqueue().run();\n+        }\n@@ -79,0 +84,41 @@\n+\n+    static class ExplicitEnqueue {\n+        final ReferenceQueue<Object> queue = new ReferenceQueue<>();\n+        final List<Reference<Object>> refs = new ArrayList<>();\n+        final int iterations = 1000;\n+\n+        ExplicitEnqueue() {\n+            this.refs.add(new SoftReference<>(new Object(), queue));\n+            this.refs.add(new WeakReference<>(new Object(), queue));\n+            \/\/ Can't test PhantomReference because get() always returns null.\n+        }\n+\n+        void run() throws InterruptedException {\n+            for (Reference<Object> ref : refs) {\n+                if (ref.enqueue() == false) {\n+                    throw new RuntimeException(\"Error: enqueue failed\");\n+                }\n+                if (ref.get() != null) {\n+                    throw new RuntimeException(\"Error: referent must be cleared\");\n+                }\n+            }\n+\n+            System.gc();\n+            for (int i = 0; refs.size() > 0 && i < iterations; i++) {\n+                Reference<Object> ref = (Reference<Object>)queue.poll();\n+                if (ref == null) {\n+                    System.gc();\n+                    Thread.sleep(100);\n+                    continue;\n+                }\n+\n+                if (refs.remove(ref) == false) {\n+                    throw new RuntimeException(\"Error: unknown reference \" + ref);\n+                }\n+            }\n+\n+            if (!refs.isEmpty()) {\n+                throw new RuntimeException(\"Error: not all references are removed\");\n+            }\n+        }\n+    }\n","filename":"jdk\/test\/java\/lang\/ref\/ReferenceEnqueue.java","additions":49,"deletions":3,"binary":false,"changes":52,"status":"modified"}]}