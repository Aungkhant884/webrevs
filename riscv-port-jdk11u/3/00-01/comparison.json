{"files":[{"patch":"@@ -52,0 +52,1 @@\n+#include \"opto\/intrinsicnode.hpp\"\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"memory\/metaspaceShared.hpp\"\n","filename":"src\/hotspot\/os_cpu\/linux_riscv\/thread_linux_riscv.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3196,0 +3196,1 @@\n+            boolean skipParseException;\n@@ -3211,0 +3212,4 @@\n+            \/\/ When parsing a URI, skip creating exception objects if the server-based\n+            \/\/ authority is not required and the registry parse is successful.\n+            \/\/\n+            skipParseException = (!requireServerAuthority && regChars);\n@@ -3216,4 +3221,13 @@\n-                    q = parseServer(p, n);\n-                    if (q < n)\n-                        failExpecting(\"end of authority\", q);\n-                    authority = input.substring(p, n);\n+                    q = parseServer(p, n, skipParseException);\n+                    if (q < n) {\n+                        if (skipParseException) {\n+                            userInfo = null;\n+                            host = null;\n+                            port = -1;\n+                            q = p;\n+                        } else {\n+                            failExpecting(\"end of authority\", q);\n+                        }\n+                    } else {\n+                        authority = input.substring(p, n);\n+                    }\n@@ -3257,1 +3271,1 @@\n-        private int parseServer(int start, int n)\n+        private int parseServer(int start, int n, boolean skipParseException)\n@@ -3297,1 +3311,1 @@\n-                    q = parseHostname(p, n);\n+                    q = parseHostname(p, n, skipParseException);\n@@ -3314,0 +3328,2 @@\n+            } else if (p < n && skipParseException) {\n+                return p;\n@@ -3315,0 +3331,1 @@\n+\n@@ -3419,1 +3436,1 @@\n-        private int parseHostname(int start, int n)\n+        private int parseHostname(int start, int n, boolean skipParseException)\n@@ -3447,1 +3464,4 @@\n-            if ((p < n) && !at(p, n, ':'))\n+            if ((p < n) && !at(p, n, ':')) {\n+                if (skipParseException) {\n+                    return p;\n+                }\n@@ -3449,1 +3469,1 @@\n-\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/net\/URI.java","additions":29,"deletions":9,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -46,0 +46,2 @@\n+\n+#if !defined(AIX)\n@@ -47,0 +49,2 @@\n+#endif\n+\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-subset.cc","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -475,1 +475,1 @@\n-java\/awt\/GraphicsDevice\/DisplayModes\/CycleDMImage.java 7099223 linux-all,solaris-all,windows-all\n+java\/awt\/GraphicsDevice\/DisplayModes\/CycleDMImage.java 7099223,8274106 macosx-aarch64,linux-all,solaris-all,windows-all\n@@ -739,1 +739,0 @@\n-java\/awt\/GraphicsDevice\/DisplayModes\/CycleDMImage.java 8274106 macosx-aarch64\n","filename":"test\/jdk\/ProblemList.txt","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,127 @@\n+\/*\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import javax.swing.JFrame;\n+import javax.swing.JPanel;\n+import javax.swing.JTree;\n+import java.awt.EventQueue;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Robot;\n+import java.awt.dnd.DnDConstants;\n+import java.awt.dnd.DragGestureEvent;\n+import java.awt.dnd.DragGestureListener;\n+import java.awt.dnd.DragSource;\n+import java.awt.event.InputEvent;\n+\n+\/*\n+  @test\n+  @bug 4273712 4396746\n+  @summary tests that mouse exit event doesn't trigger drag\n+  @key headful\n+  @run main MouseExitGestureTriggerTest\n+*\/\n+\n+public class MouseExitGestureTriggerTest {\n+\n+    boolean recognized = false;\n+    volatile JFrame frame;\n+    volatile JPanel panel;\n+    volatile JTree tree;\n+    volatile DragSource dragSource;\n+    volatile Point srcPoint;\n+    volatile Rectangle r;\n+    volatile DragGestureListener dgl;\n+    static final int FRAME_ACTIVATION_TIMEOUT = 2000;\n+    static final int RECOGNITION_TIMEOUT = 1000;\n+\n+    public static void main(String[] args) throws Exception {\n+        MouseExitGestureTriggerTest test = new MouseExitGestureTriggerTest();\n+        EventQueue.invokeAndWait(test::init);\n+        try {\n+            test.start();\n+        } finally {\n+            EventQueue.invokeAndWait(() -> {\n+                if (test.frame != null) {\n+                    test.frame.dispose();\n+                }\n+            });\n+        }\n+    }\n+\n+    public void init() {\n+        frame = new JFrame(\"MouseExitGestureTriggerTest\");\n+        panel = new JPanel();\n+        tree = new JTree();\n+\n+        dragSource = DragSource.getDefaultDragSource();\n+        dgl = new DragGestureListener() {\n+            public void dragGestureRecognized(DragGestureEvent dge) {\n+                Thread.dumpStack();\n+                recognized = true;\n+            }\n+        };\n+\n+        tree.setEditable(true);\n+        dragSource.createDefaultDragGestureRecognizer(tree,\n+                                                      DnDConstants.ACTION_MOVE,\n+                                                      dgl);\n+        panel.add(tree);\n+        frame.getContentPane().add(panel);\n+        frame.setLocation(200, 200);\n+\n+        frame.pack();\n+        frame.setVisible(true);\n+    }\n+\n+    public void start() throws Exception {\n+        final Robot robot = new Robot();\n+        Thread.sleep(FRAME_ACTIVATION_TIMEOUT);\n+\n+        clickRootNode(robot);\n+        clickRootNode(robot);\n+        clickRootNode(robot);\n+\n+        Thread.sleep(RECOGNITION_TIMEOUT);\n+\n+        EventQueue.invokeAndWait(() -> {\n+            if (recognized) {\n+                throw new RuntimeException(\"Mouse exit event triggered drag\");\n+            }\n+        });\n+    }\n+\n+    void clickRootNode(final Robot robot) throws Exception {\n+        EventQueue.invokeAndWait(() -> {\n+            srcPoint = tree.getLocationOnScreen();\n+            r = tree.getRowBounds(0);\n+        });\n+        srcPoint.translate(r.x + 2 * r.width \/3 , r.y + r.height \/ 2);\n+        robot.mouseMove(srcPoint.x ,srcPoint.y);\n+\n+        robot.mousePress(InputEvent.BUTTON1_MASK);\n+        Thread.sleep(10);\n+        robot.mouseRelease(InputEvent.BUTTON1_MASK);\n+        Thread.sleep(10);\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/dnd\/MouseExitGestureTriggerTest.java","additions":127,"deletions":0,"binary":false,"changes":127,"status":"added"},{"patch":"@@ -0,0 +1,494 @@\n+\/*\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.AWTEvent;\n+import java.awt.Component;\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.Panel;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.Toolkit;\n+import java.awt.datatransfer.DataFlavor;\n+import java.awt.datatransfer.SystemFlavorMap;\n+import java.awt.datatransfer.Transferable;\n+import java.awt.datatransfer.UnsupportedFlavorException;\n+import java.awt.dnd.DnDConstants;\n+import java.awt.dnd.DragGestureEvent;\n+import java.awt.dnd.DragGestureListener;\n+import java.awt.dnd.DragGestureRecognizer;\n+import java.awt.dnd.DragSource;\n+import java.awt.dnd.DragSourceAdapter;\n+import java.awt.dnd.DragSourceDropEvent;\n+import java.awt.dnd.DragSourceListener;\n+import java.awt.dnd.DropTarget;\n+import java.awt.dnd.DropTargetContext;\n+import java.awt.dnd.DropTargetDragEvent;\n+import java.awt.dnd.DropTargetDropEvent;\n+import java.awt.dnd.DropTargetEvent;\n+import java.awt.dnd.DropTargetListener;\n+import java.awt.event.AWTEventListener;\n+import java.awt.event.InputEvent;\n+import java.awt.event.KeyEvent;\n+import java.awt.event.MouseEvent;\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+\n+\/*\n+  @test\n+  @bug 4746177\n+  @summary tests that data types exported by Netscape 6.2 are supported\n+  @requires (os.family != \"windows\")\n+  @key headful\n+  @run main MozillaDnDTest\n+*\/\n+\n+public class MozillaDnDTest {\n+\n+    public static final int CODE_NOT_RETURNED = -1;\n+    public static final int CODE_OK = 0;\n+    public static final int CODE_FAILURE = 1;\n+    public static final String DATA = \"www.sun.com\";\n+\n+    private int returnCode = CODE_NOT_RETURNED;\n+\n+    volatile Frame frame;\n+    volatile Robot robot;\n+    volatile Panel panel;\n+    volatile Point p;\n+    volatile Dimension d;\n+\n+    public static void main(String[] args) throws Exception {\n+        MozillaDnDTest test = new MozillaDnDTest();\n+        if (args.length > 0) {\n+            test.run(args);\n+        } else {\n+            EventQueue.invokeAndWait(test::init);\n+            try {\n+                test.start();\n+            } finally {\n+                EventQueue.invokeAndWait(() -> {\n+                    if (test.frame != null) {\n+                        test.frame.dispose();\n+                    }\n+                });\n+            }\n+        }\n+    }\n+\n+    public void run(String[] args) {\n+        try {\n+            if (args.length != 4) {\n+                throw new RuntimeException(\"Incorrect command line arguments.\");\n+            }\n+\n+            int x = Integer.parseInt(args[0]);\n+            int y = Integer.parseInt(args[1]);\n+            int w = Integer.parseInt(args[2]);\n+            int h = Integer.parseInt(args[3]);\n+\n+            panel = new DragSourcePanel();\n+            frame = new Frame();\n+\n+            frame.setTitle(\"DragSource frame\");\n+            frame.setLocation(300, 200);\n+            frame.add(panel);\n+            frame.pack();\n+            frame.setVisible(true);\n+\n+            Util.waitForInit();\n+\n+            Point sourcePoint = panel.getLocationOnScreen();\n+            Dimension d = panel.getSize();\n+            sourcePoint.translate(d.width \/ 2, d.height \/ 2);\n+\n+            Point targetPoint = new Point(x + w \/ 2, y + h \/ 2);\n+\n+            robot = new Robot();\n+\n+            if (!Util.pointInComponent(robot, sourcePoint, panel)) {\n+                System.err.println(\"WARNING: Couldn't locate \" + panel +\n+                                   \" at point \" + sourcePoint);\n+                System.exit(MozillaDnDTest.CODE_OK);\n+            }\n+\n+            robot.mouseMove(sourcePoint.x, sourcePoint.y);\n+            robot.keyPress(KeyEvent.VK_CONTROL);\n+            robot.mousePress(InputEvent.BUTTON1_MASK);\n+            for (; !sourcePoint.equals(targetPoint);\n+                 sourcePoint.translate(sign(targetPoint.x - sourcePoint.x),\n+                                       sign(targetPoint.y - sourcePoint.y))) {\n+                robot.mouseMove(sourcePoint.x, sourcePoint.y);\n+                Thread.sleep(50);\n+            }\n+            robot.mouseRelease(InputEvent.BUTTON1_MASK);\n+            robot.keyRelease(KeyEvent.VK_CONTROL);\n+\n+        } catch (Throwable e) {\n+            e.printStackTrace();\n+            System.exit(MozillaDnDTest.CODE_FAILURE);\n+        }\n+    }\n+\n+    public static int sign(int n) {\n+        return n < 0 ? -1 : n == 0 ? 0 : 1;\n+    }\n+\n+    public void init() {\n+        frame = new Frame();\n+        panel = new DropTargetPanel();\n+\n+        frame.setTitle(\"DropTarget frame\");\n+        frame.setLocation(10, 200);\n+        frame.add(panel);\n+\n+        frame.pack();\n+        frame.setVisible(true);\n+    }\n+\n+    public void start() {\n+        \/\/ Solaris\/Linux-only test\n+        if (System.getProperty(\"os.name\").startsWith(\"Windows\")) {\n+            return;\n+        }\n+        try {\n+            Util.waitForInit();\n+            EventQueue.invokeAndWait(() -> {\n+                p = panel.getLocationOnScreen();\n+                d = panel.getSize();\n+            });\n+\n+            Robot robot = new Robot();\n+            Point pp = new Point(p);\n+            pp.translate(d.width \/ 2, d.height \/ 2);\n+            if (!Util.pointInComponent(robot, pp, panel)) {\n+                System.err.println(\"WARNING: Couldn't locate \" + panel +\n+                                   \" at point \" + pp);\n+                return;\n+            }\n+\n+            String javaPath = System.getProperty(\"java.home\", \"\");\n+            String command = javaPath + File.separator + \"bin\" +\n+                File.separator + \"java -cp \" + System.getProperty(\"test.classes\", \".\") +\n+                \" MozillaDnDTest \" +\n+                p.x + \" \" + p.y + \" \" + d.width + \" \" + d.height;\n+\n+            Process process = Runtime.getRuntime().exec(command);\n+            ProcessResults pres = ProcessResults.doWaitFor(process);\n+            returnCode = pres.exitValue;\n+\n+            if (pres.stderr != null && pres.stderr.length() > 0) {\n+                System.err.println(\"========= Child VM System.err ========\");\n+                System.err.print(pres.stderr);\n+                System.err.println(\"======================================\");\n+            }\n+\n+            if (pres.stdout != null && pres.stdout.length() > 0) {\n+                System.err.println(\"========= Child VM System.out ========\");\n+                System.err.print(pres.stdout);\n+                System.err.println(\"======================================\");\n+            }\n+\n+        } catch (Throwable e) {\n+            e.printStackTrace();\n+        }\n+        switch (returnCode) {\n+        case CODE_NOT_RETURNED:\n+            System.err.println(\"Child VM: failed to start\");\n+            break;\n+        case CODE_OK:\n+            System.err.println(\"Child VM: normal termination\");\n+            break;\n+        case CODE_FAILURE:\n+            System.err.println(\"Child VM: abnormal termination\");\n+            break;\n+        }\n+        if (returnCode != CODE_OK) {\n+            throw new RuntimeException(\"The test failed.\");\n+        }\n+    }\n+}\n+\n+class Util implements AWTEventListener {\n+    private static final Toolkit tk = Toolkit.getDefaultToolkit();\n+    public static final Object SYNC_LOCK = new Object();\n+    private Component clickedComponent = null;\n+    private static final int PAINT_TIMEOUT = 10000;\n+    private static final int MOUSE_RELEASE_TIMEOUT = 10000;\n+    private static final Util util = new Util();\n+\n+    static {\n+        tk.addAWTEventListener(util, 0xFFFFFFFF);\n+    }\n+\n+    private void reset() {\n+        clickedComponent = null;\n+    }\n+\n+    public void eventDispatched(AWTEvent e) {\n+        if (e.getID() == MouseEvent.MOUSE_RELEASED) {\n+            clickedComponent = (Component)e.getSource();\n+            synchronized (SYNC_LOCK) {\n+                SYNC_LOCK.notifyAll();\n+            }\n+        }\n+    }\n+\n+    public static boolean pointInComponent(Robot robot, Point p, Component comp)\n+      throws InterruptedException {\n+        return util.isPointInComponent(robot, p, comp);\n+    }\n+\n+    private boolean isPointInComponent(Robot robot, Point p, Component comp)\n+      throws InterruptedException {\n+        tk.sync();\n+        robot.waitForIdle();\n+        reset();\n+        robot.mouseMove(p.x, p.y);\n+        robot.mousePress(InputEvent.BUTTON1_MASK);\n+        synchronized (SYNC_LOCK) {\n+            robot.mouseRelease(InputEvent.BUTTON1_MASK);\n+            SYNC_LOCK.wait(MOUSE_RELEASE_TIMEOUT);\n+        }\n+\n+        Component c = clickedComponent;\n+\n+        while (c != null && c != comp) {\n+            c = c.getParent();\n+        }\n+\n+        return c == comp;\n+    }\n+\n+    public static void waitForInit() throws InterruptedException {\n+        final Frame f = new Frame() {\n+                public void paint(Graphics g) {\n+                    dispose();\n+                    synchronized (SYNC_LOCK) {\n+                        SYNC_LOCK.notifyAll();\n+                    }\n+                }\n+            };\n+        f.setBounds(600, 400, 200, 200);\n+        synchronized (SYNC_LOCK) {\n+            f.setVisible(true);\n+            SYNC_LOCK.wait(PAINT_TIMEOUT);\n+        }\n+        tk.sync();\n+    }\n+}\n+\n+class ProcessResults {\n+    public int exitValue;\n+    public String stdout;\n+    public String stderr;\n+\n+    public ProcessResults() {\n+        exitValue = -1;\n+        stdout = \"\";\n+        stderr = \"\";\n+    }\n+\n+    \/**\n+     * Method to perform a \"wait\" for a process and return its exit value.\n+     * This is a workaround for <code>Process.waitFor()<\/code> never returning.\n+     *\/\n+    public static ProcessResults doWaitFor(Process p) {\n+        ProcessResults pres = new ProcessResults();\n+\n+        InputStream in = null;\n+        InputStream err = null;\n+\n+        try {\n+            in = p.getInputStream();\n+            err = p.getErrorStream();\n+\n+            boolean finished = false;\n+\n+            while (!finished) {\n+                try {\n+                    while (in.available() > 0) {\n+                        pres.stdout += (char)in.read();\n+                    }\n+                    while (err.available() > 0) {\n+                        pres.stderr += (char)err.read();\n+                    }\n+                    \/\/ Ask the process for its exitValue. If the process\n+                    \/\/ is not finished, an IllegalThreadStateException\n+                    \/\/ is thrown. If it is finished, we fall through and\n+                    \/\/ the variable finished is set to true.\n+                    pres.exitValue = p.exitValue();\n+                    finished = true;\n+                }\n+                catch (IllegalThreadStateException e) {\n+                    \/\/ Process is not finished yet;\n+                    \/\/ Sleep a little to save on CPU cycles\n+                    Thread.currentThread().sleep(500);\n+                }\n+            }\n+            if (in != null) in.close();\n+            if (err != null) err.close();\n+        }\n+        catch (Throwable e) {\n+            System.err.println(\"doWaitFor(): unexpected exception\");\n+            e.printStackTrace();\n+        }\n+        return pres;\n+    }\n+}\n+\n+class DragSourcePanel extends Panel {\n+    static final Dimension preferredDimension = new Dimension(200, 200);\n+    static final DataFlavor df = new DataFlavor(\"application\/mozilla-test-flavor\",\n+                                                null);\n+    final DragSource ds = DragSource.getDefaultDragSource();\n+    final Transferable t = new Transferable() {\n+            final DataFlavor[] flavors = new DataFlavor[] { df };\n+            public DataFlavor[] getTransferDataFlavors() {\n+                return flavors;\n+            }\n+            public boolean isDataFlavorSupported(DataFlavor flav) {\n+                return df.equals(flav);\n+            }\n+            public Object getTransferData(DataFlavor flav)\n+              throws IOException, UnsupportedFlavorException {\n+                if (!isDataFlavorSupported(flav)) {\n+                    throw new UnsupportedFlavorException(flav);\n+                }\n+                byte[] bytes = MozillaDnDTest.DATA.getBytes(\"ASCII\");\n+                return new ByteArrayInputStream(bytes);\n+            }\n+        };\n+    final DragSourceListener dsl = new DragSourceAdapter() {\n+            public void dragDropEnd(DragSourceDropEvent dsde) {\n+                System.exit(MozillaDnDTest.CODE_OK);\n+            }\n+        };\n+    final DragGestureListener dgl = new DragGestureListener() {\n+            public void dragGestureRecognized(DragGestureEvent dge) {\n+                dge.startDrag(null, t, dsl);\n+            }\n+        };\n+    final DragGestureRecognizer dgr =\n+        ds.createDefaultDragGestureRecognizer(this, DnDConstants.ACTION_COPY,\n+                                              dgl);\n+    static {\n+        SystemFlavorMap sfm =\n+            (SystemFlavorMap)SystemFlavorMap.getDefaultFlavorMap();\n+        String[] natives = new String[] {\n+            \"_NETSCAPE_URL\",\n+            \"text\/plain\",\n+            \"text\/unicode\",\n+            \"text\/x-moz-url\",\n+            \"text\/html\"\n+        };\n+        sfm.setNativesForFlavor(df, natives);\n+    }\n+\n+    public Dimension getPreferredSize() {\n+        return preferredDimension;\n+    }\n+}\n+\n+class DropTargetPanel extends Panel implements DropTargetListener {\n+\n+    final Dimension preferredDimension = new Dimension(200, 200);\n+    final DropTarget dt = new DropTarget(this, this);\n+\n+    public Dimension getPreferredSize() {\n+        return preferredDimension;\n+    }\n+\n+    public void dragEnter(DropTargetDragEvent dtde) {\n+        dtde.acceptDrag(DnDConstants.ACTION_COPY);\n+    }\n+\n+    public void dragExit(DropTargetEvent dte) {}\n+\n+    public void dragOver(DropTargetDragEvent dtde) {\n+        dtde.acceptDrag(DnDConstants.ACTION_COPY);\n+    }\n+\n+    public String getTransferString(Transferable t) {\n+        String string = null;\n+        DataFlavor[] dfs = t.getTransferDataFlavors();\n+        for (int i = 0; i < dfs.length; i++) {\n+            if (\"text\".equals(dfs[i].getPrimaryType()) ||\n+                DataFlavor.stringFlavor.equals(dfs[i])) {\n+                try {\n+                    Object o = t.getTransferData(dfs[i]);\n+                    if (o instanceof InputStream ||\n+                        o instanceof Reader) {\n+                        Reader reader = null;\n+                        if (o instanceof InputStream) {\n+                            InputStream is = (InputStream)o;\n+                            reader = new InputStreamReader(is);\n+                        } else {\n+                            reader = (Reader)o;\n+                        }\n+                        StringBuffer buf = new StringBuffer();\n+                        for (int c = reader.read(); c != -1; c = reader.read()) {\n+                            buf.append((char)c);\n+                        }\n+                        reader.close();\n+                        string = buf.toString();\n+                        break;\n+                    } else if (o instanceof String) {\n+                        string = (String)o;\n+                        break;\n+                    }\n+                } catch (Exception e) {\n+                    \/\/ ignore.\n+                }\n+            }\n+        }\n+        return string;\n+     }\n+\n+    public void drop(DropTargetDropEvent dtde) {\n+        DropTargetContext dtc = dtde.getDropTargetContext();\n+\n+        if ((dtde.getSourceActions() & DnDConstants.ACTION_COPY) != 0) {\n+            dtde.acceptDrop(DnDConstants.ACTION_COPY);\n+        } else {\n+            dtde.rejectDrop();\n+            return;\n+        }\n+\n+        Transferable t = dtde.getTransferable();\n+        String str = getTransferString(t);\n+        dtde.dropComplete(true);\n+\n+        if (!MozillaDnDTest.DATA.equals(str)) {\n+            throw new RuntimeException(\"Drop data:\" + str);\n+        }\n+    }\n+\n+    public void dropActionChanged(DropTargetDragEvent dtde) {}\n+}\n","filename":"test\/jdk\/java\/awt\/dnd\/MozillaDnDTest.java","additions":494,"deletions":0,"binary":false,"changes":494,"status":"added"},{"patch":"@@ -0,0 +1,415 @@\n+\/*\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Button;\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.GridLayout;\n+import java.awt.List;\n+import java.awt.Panel;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.datatransfer.DataFlavor;\n+import java.awt.datatransfer.Transferable;\n+import java.awt.datatransfer.UnsupportedFlavorException;\n+import java.awt.dnd.DnDConstants;\n+import java.awt.dnd.DragGestureEvent;\n+import java.awt.dnd.DragGestureListener;\n+import java.awt.dnd.DragSource;\n+import java.awt.dnd.DragSourceDragEvent;\n+import java.awt.dnd.DragSourceDropEvent;\n+import java.awt.dnd.DragSourceEvent;\n+import java.awt.dnd.DragSourceListener;\n+import java.awt.dnd.DropTarget;\n+import java.awt.dnd.DropTargetContext;\n+import java.awt.dnd.DropTargetDragEvent;\n+import java.awt.dnd.DropTargetDropEvent;\n+import java.awt.dnd.DropTargetEvent;\n+import java.awt.dnd.DropTargetListener;\n+import java.awt.event.InputEvent;\n+import java.awt.event.KeyEvent;\n+import java.io.File;\n+import java.io.InputStream;\n+import java.io.Serializable;\n+\n+\/*\n+  @test\n+  @bug 4399700\n+  @summary tests that drop transfer data can be requested in several data flavors.\n+  @key headful\n+  @run main MultiDataFlavorDropTest\n+*\/\n+\n+public class MultiDataFlavorDropTest {\n+\n+    public static final int CODE_NOT_RETURNED = -1;\n+    public static final int CODE_OK = 0;\n+    public static final int CODE_FAILURE = 1;\n+    public static final int FRAME_ACTIVATION_TIMEOUT = 2000;\n+    public static final int DROP_TIMEOUT = 10000;\n+    public static final int DROP_COMPLETION_TIMEOUT = 1000;\n+\n+    private int returnCode = CODE_NOT_RETURNED;\n+\n+    volatile Frame frame;\n+    volatile Robot robot;\n+    volatile Panel panel;\n+    volatile Point p;\n+    volatile Dimension d;\n+\n+    public static void main(String[] args) throws Exception {\n+        MultiDataFlavorDropTest test = new MultiDataFlavorDropTest();\n+        if (args.length > 0) {\n+            test.run(args);\n+        } else {\n+            EventQueue.invokeAndWait(test::init);\n+            try {\n+                test.start();\n+            } finally {\n+                EventQueue.invokeAndWait(() -> {\n+                    if (test.frame != null) {\n+                        test.frame.dispose();\n+                    }\n+                });\n+            }\n+        }\n+    }\n+\n+    public void run(String[] args) {\n+        try {\n+            if (args.length != 4) {\n+                throw new RuntimeException(\"Incorrect command line arguments.\");\n+            }\n+\n+            int x = Integer.parseInt(args[0]);\n+            int y = Integer.parseInt(args[1]);\n+            int w = Integer.parseInt(args[2]);\n+            int h = Integer.parseInt(args[3]);\n+\n+            Transferable t = new TransferableNumber();\n+            panel = new DragSourcePanel(t);\n+\n+            frame = new Frame();\n+            frame.setTitle(\"DragSource frame\");\n+            frame.setLocation(300, 200);\n+            frame.add(panel);\n+            frame.pack();\n+            frame.setVisible(true);\n+\n+            Thread.sleep(FRAME_ACTIVATION_TIMEOUT);\n+\n+            Point sourcePoint = panel.getLocationOnScreen();\n+            Dimension d = panel.getSize();\n+            sourcePoint.translate(d.width \/ 2, d.height \/ 2);\n+\n+            Point targetPoint = new Point(x + w \/ 2, y + h \/ 2);\n+\n+            robot = new Robot();\n+            robot.mouseMove(sourcePoint.x, sourcePoint.y);\n+            robot.keyPress(KeyEvent.VK_CONTROL);\n+            robot.mousePress(InputEvent.BUTTON1_MASK);\n+            for (; !sourcePoint.equals(targetPoint);\n+                 sourcePoint.translate(sign(targetPoint.x - sourcePoint.x),\n+                         sign(targetPoint.y - sourcePoint.y))) {\n+                robot.mouseMove(sourcePoint.x, sourcePoint.y);\n+                Thread.sleep(10);\n+            }\n+            robot.mouseRelease(InputEvent.BUTTON1_MASK);\n+            robot.keyRelease(KeyEvent.VK_CONTROL);\n+\n+            synchronized (t) {\n+                t.wait(DROP_TIMEOUT);\n+            }\n+\n+            Thread.sleep(DROP_COMPLETION_TIMEOUT);\n+\n+        } catch (Throwable e) {\n+            e.printStackTrace();\n+            System.exit(MultiDataFlavorDropTest.CODE_FAILURE);\n+        }\n+        System.exit(MultiDataFlavorDropTest.CODE_OK);\n+    }\n+\n+    public static int sign(int n) {\n+        return n < 0 ? -1 : n == 0 ? 0 : 1;\n+    }\n+\n+    public void init() {\n+        frame = new Frame();\n+        panel = new DropTargetPanel();\n+\n+        frame.setTitle(\"MultiDataFlavorDropTest\");\n+        frame.setLocation(10, 200);\n+        frame.add(panel);\n+\n+        frame.pack();\n+        frame.setVisible(true);\n+    }\n+\n+    public void start() throws Exception {\n+        Thread.sleep(FRAME_ACTIVATION_TIMEOUT);\n+\n+        EventQueue.invokeAndWait(() -> {\n+            p = panel.getLocationOnScreen();\n+            d = panel.getSize();\n+        });\n+\n+        String javaPath = System.getProperty(\"java.home\", \"\");\n+        String command = javaPath + File.separator + \"bin\" +\n+                File.separator + \"java -cp \" + System.getProperty(\"test.classes\", \".\") +\n+                \" MultiDataFlavorDropTest \" +\n+                p.x + \" \" + p.y + \" \" + d.width + \" \" + d.height;\n+\n+        Process process = Runtime.getRuntime().exec(command);\n+        returnCode = process.waitFor();\n+\n+        InputStream errorStream = process.getErrorStream();\n+        int count = errorStream.available();\n+        if (count > 0) {\n+            byte[] b = new byte[count];\n+            errorStream.read(b);\n+            System.err.println(\"========= Child VM System.err ========\");\n+            System.err.print(new String(b));\n+            System.err.println(\"======================================\");\n+        }\n+\n+        switch (returnCode) {\n+            case CODE_NOT_RETURNED:\n+                System.err.println(\"Child VM: failed to start\");\n+                break;\n+            case CODE_OK:\n+                System.err.println(\"Child VM: normal termination\");\n+                break;\n+            case CODE_FAILURE:\n+                System.err.println(\"Child VM: abnormal termination\");\n+                break;\n+        }\n+        if (returnCode != CODE_OK) {\n+            throw new RuntimeException(\"The test failed.\");\n+        }\n+    }\n+}\n+\n+class DragSourceButton extends Button implements Serializable,\n+                                                 DragGestureListener,\n+                                                 DragSourceListener {\n+\n+    final Transferable transferable;\n+\n+    public DragSourceButton(Transferable t) {\n+        super(\"DragSourceButton\");\n+\n+        this.transferable = t;\n+        DragSource ds = DragSource.getDefaultDragSource();\n+        ds.createDefaultDragGestureRecognizer(this, DnDConstants.ACTION_COPY,\n+                                              this);\n+    }\n+\n+    public void dragGestureRecognized(DragGestureEvent dge) {\n+        dge.startDrag(null, transferable, this);\n+    }\n+\n+    public void dragEnter(DragSourceDragEvent dsde) {}\n+\n+    public void dragExit(DragSourceEvent dse) {}\n+\n+    public void dragOver(DragSourceDragEvent dsde) {}\n+\n+    public void dragDropEnd(DragSourceDropEvent dsde) {}\n+\n+    public void dropActionChanged(DragSourceDragEvent dsde) {}\n+}\n+\n+class IntegerDataFlavor extends DataFlavor {\n+\n+    private final int number;\n+\n+    public IntegerDataFlavor(int n) throws ClassNotFoundException {\n+        super(\"application\/integer-\" + n +\n+              \"; class=java.lang.Integer\");\n+        this.number = n;\n+    }\n+\n+    public int getNumber() {\n+        return number;\n+    }\n+}\n+\n+class TransferableNumber implements Transferable {\n+\n+    private int transferDataRequestCount = 0;\n+    public static final int NUM_DATA_FLAVORS = 5;\n+    static final DataFlavor[] supportedFlavors =\n+        new DataFlavor[NUM_DATA_FLAVORS];\n+\n+    static {\n+        try {\n+            for (int i = 0; i < NUM_DATA_FLAVORS; i++) {\n+                supportedFlavors[i] =\n+                    new IntegerDataFlavor(i);\n+            }\n+        } catch (ClassNotFoundException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    public DataFlavor[] getTransferDataFlavors() {\n+        return supportedFlavors;\n+    }\n+\n+    public boolean isDataFlavorSupported(DataFlavor flavor) {\n+        if (flavor instanceof IntegerDataFlavor) {\n+            IntegerDataFlavor integerFlavor = (IntegerDataFlavor)flavor;\n+            int flavorNumber = integerFlavor.getNumber();\n+            if (flavorNumber >= 0 && flavorNumber < NUM_DATA_FLAVORS) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    public Object getTransferData(DataFlavor flavor)\n+      throws UnsupportedFlavorException {\n+\n+        if (!isDataFlavorSupported(flavor)) {\n+            throw new UnsupportedFlavorException(flavor);\n+        }\n+\n+        transferDataRequestCount++;\n+\n+        if (transferDataRequestCount >= NUM_DATA_FLAVORS) {\n+            synchronized (this) {\n+                this.notifyAll();\n+            }\n+        }\n+\n+        IntegerDataFlavor integerFlavor = (IntegerDataFlavor)flavor;\n+        return new Integer(integerFlavor.getNumber());\n+    }\n+}\n+\n+class DragSourcePanel extends Panel {\n+\n+    final Dimension preferredDimension = new Dimension(200, 200);\n+\n+    public DragSourcePanel(Transferable t) {\n+        setLayout(new GridLayout(1, 1));\n+        add(new DragSourceButton(t));\n+    }\n+\n+    public Dimension getPreferredSize() {\n+        return preferredDimension;\n+    }\n+}\n+\n+class DropTargetPanel extends Panel implements DropTargetListener {\n+\n+    final Dimension preferredDimension = new Dimension(200, 200);\n+\n+    public DropTargetPanel() {\n+        setBackground(Color.green);\n+        setDropTarget(new DropTarget(this, this));\n+        setLayout(new GridLayout(1, 1));\n+    }\n+\n+    public Dimension getPreferredSize() {\n+        return preferredDimension;\n+    }\n+\n+    public void dragEnter(DropTargetDragEvent dtde) {\n+        dtde.acceptDrag(DnDConstants.ACTION_COPY);\n+    }\n+\n+    public void dragExit(DropTargetEvent dte) {}\n+\n+    public void dragOver(DropTargetDragEvent dtde) {\n+        dtde.acceptDrag(DnDConstants.ACTION_COPY);\n+    }\n+\n+    public void drop(DropTargetDropEvent dtde) {\n+        DropTargetContext dtc = dtde.getDropTargetContext();\n+\n+        if ((dtde.getSourceActions() & DnDConstants.ACTION_COPY) != 0) {\n+            dtde.acceptDrop(DnDConstants.ACTION_COPY);\n+        } else {\n+            dtde.rejectDrop();\n+            return;\n+        }\n+\n+        removeAll();\n+        final List list = new List();\n+        add(list);\n+\n+        Transferable t = dtde.getTransferable();\n+        DataFlavor[] dfs = t.getTransferDataFlavors();\n+\n+        if (dfs.length != TransferableNumber.NUM_DATA_FLAVORS) {\n+            throw new RuntimeException(\"FAILED: Incorrect number of data flavors.\");\n+        }\n+\n+        for (int i = 0; i < dfs.length; i++) {\n+\n+            DataFlavor flavor = dfs[i];\n+            Integer transferNumber = null;\n+\n+            if (flavor.getRepresentationClass().equals(Integer.class)) {\n+                try {\n+                    transferNumber = (Integer)t.getTransferData(flavor);\n+                } catch (Exception e) {\n+                    e.printStackTrace();\n+                    throw new RuntimeException(\"FAILED: Cannot get data: \" +\n+                                               flavor.getMimeType());\n+                }\n+            }\n+\n+            boolean supportedFlavor = false;\n+            for (int j = 0; j < TransferableNumber.NUM_DATA_FLAVORS; j++) {\n+                int number = (i + j) % TransferableNumber.NUM_DATA_FLAVORS;\n+                try {\n+                    if (flavor.equals(new IntegerDataFlavor(number))) {\n+                        if (!(new Integer(number).equals(transferNumber))) {\n+                            throw new RuntimeException(\"FAILED: Invalid data \\n\" +\n+                                                       \"\\tflavor : \" + flavor +\n+                                                       \"\\tdata   : \" + transferNumber);\n+                        }\n+                        supportedFlavor = true;\n+                        break;\n+                    }\n+                } catch (ClassNotFoundException cannotHappen) {\n+                }\n+            }\n+            if (!supportedFlavor) {\n+                throw new RuntimeException(\"FAILED: Invalid flavor: \" + flavor);\n+            }\n+\n+            list.add(transferNumber + \":\" + flavor.getMimeType());\n+        }\n+\n+        dtc.dropComplete(true);\n+        validate();\n+    }\n+\n+    public void dropActionChanged(DropTargetDragEvent dtde) {}\n+}\n","filename":"test\/jdk\/java\/awt\/dnd\/MultiDataFlavorDropTest.java","additions":415,"deletions":0,"binary":false,"changes":415,"status":"added"},{"patch":"@@ -0,0 +1,152 @@\n+\/*\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Label;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.datatransfer.DataFlavor;\n+import java.awt.datatransfer.Transferable;\n+import java.awt.dnd.DnDConstants;\n+import java.awt.dnd.DropTarget;\n+import java.awt.dnd.DropTargetContext;\n+import java.awt.dnd.DropTargetDragEvent;\n+import java.awt.dnd.DropTargetDropEvent;\n+import java.awt.dnd.DropTargetEvent;\n+import java.awt.dnd.DropTargetListener;\n+import java.awt.event.InputEvent;\n+\n+\/*\n+  @test\n+  @bug 4399700\n+  @summary tests that Motif drag support for label widget doesn't cause\n+           crash when used for drag and drop from label to Java drop target\n+  @key headful\n+  @run main NativeDragJavaDropTest\n+*\/\n+\n+public class NativeDragJavaDropTest {\n+\n+    volatile Frame frame;\n+    volatile DropTargetLabel label;\n+    volatile Point p;\n+    volatile Dimension d;\n+    public static final int FRAME_ACTIVATION_TIMEOUT = 1000;\n+    public static final int DRAG_START_TIMEOUT = 500;\n+    public static final int DROP_COMPLETION_TIMEOUT = 2000;\n+\n+    public static void main(String[] args) throws Exception {\n+        NativeDragJavaDropTest test = new NativeDragJavaDropTest();\n+        EventQueue.invokeAndWait(test::init);\n+        try {\n+            test.start();\n+        } finally {\n+            EventQueue.invokeAndWait(() -> {\n+                if (test.frame != null) {\n+                    test.frame.dispose();\n+                }\n+            });\n+        }\n+    }\n+\n+    public void init() {\n+        frame = new Frame();\n+        label = new DropTargetLabel();\n+        frame.setTitle(\"NativeDragJavaDropTest\");\n+        frame.setLocation(200, 200);\n+        frame.add(label);\n+\n+        frame.pack();\n+        frame.setVisible(true);\n+    }\n+\n+    public void start() throws Exception {\n+        Robot robot = new Robot();\n+        robot.waitForIdle();\n+        Thread.sleep(FRAME_ACTIVATION_TIMEOUT);\n+\n+        EventQueue.invokeAndWait(() -> {\n+            p = label.getLocationOnScreen();\n+            d = label.getSize();\n+        });\n+\n+        p.translate(d.width \/ 2, d.height \/ 2);\n+\n+        robot.mouseMove(p.x, p.y);\n+        robot.mousePress(InputEvent.BUTTON2_MASK);\n+\n+        Thread.sleep(DRAG_START_TIMEOUT);\n+\n+        robot.mouseRelease(InputEvent.BUTTON2_MASK);\n+\n+        Thread.sleep(DROP_COMPLETION_TIMEOUT);\n+    }\n+}\n+\n+class DropTargetLabel extends Label implements DropTargetListener {\n+\n+    final Dimension preferredDimension = new Dimension(200, 100);\n+\n+    public DropTargetLabel() {\n+        super(\"Label\");\n+        setDropTarget(new DropTarget(this, this));\n+    }\n+\n+    public Dimension getPreferredSize() {\n+        return preferredDimension;\n+    }\n+\n+    public void dragEnter(DropTargetDragEvent dtde) {}\n+\n+    public void dragExit(DropTargetEvent dte) {}\n+\n+    public void dragOver(DropTargetDragEvent dtde) {}\n+\n+    public void dropActionChanged(DropTargetDragEvent dtde) {}\n+\n+    public void drop(DropTargetDropEvent dtde) {\n+        DropTargetContext dtc = dtde.getDropTargetContext();\n+\n+        if ((dtde.getSourceActions() & DnDConstants.ACTION_COPY) != 0) {\n+            dtde.acceptDrop(DnDConstants.ACTION_COPY);\n+        } else {\n+            dtde.rejectDrop();\n+        }\n+\n+        DataFlavor[] dfs = dtde.getCurrentDataFlavors();\n+\n+        if (dfs != null && dfs.length >= 1) {\n+            Transferable transfer = dtde.getTransferable();\n+\n+            try {\n+                Object obj = (Object)transfer.getTransferData(dfs[0]);\n+            } catch (Throwable e) {\n+                e.printStackTrace();\n+                dtc.dropComplete(false);\n+            }\n+        }\n+        dtc.dropComplete(true);\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/dnd\/NativeDragJavaDropTest.java","additions":152,"deletions":0,"binary":false,"changes":152,"status":"added"},{"patch":"@@ -0,0 +1,492 @@\n+\/*\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.AWTEvent;\n+import java.awt.BorderLayout;\n+import java.awt.Button;\n+import java.awt.Color;\n+import java.awt.Component;\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.GridLayout;\n+import java.awt.Panel;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.Toolkit;\n+import java.awt.datatransfer.DataFlavor;\n+import java.awt.datatransfer.Transferable;\n+import java.awt.datatransfer.UnsupportedFlavorException;\n+import java.awt.dnd.DnDConstants;\n+import java.awt.dnd.DragGestureEvent;\n+import java.awt.dnd.DragGestureListener;\n+import java.awt.dnd.DragSource;\n+import java.awt.dnd.DragSourceDragEvent;\n+import java.awt.dnd.DragSourceDropEvent;\n+import java.awt.dnd.DragSourceEvent;\n+import java.awt.dnd.DragSourceListener;\n+import java.awt.dnd.DropTarget;\n+import java.awt.dnd.DropTargetContext;\n+import java.awt.dnd.DropTargetDragEvent;\n+import java.awt.dnd.DropTargetDropEvent;\n+import java.awt.dnd.DropTargetEvent;\n+import java.awt.dnd.DropTargetListener;\n+import java.awt.event.AWTEventListener;\n+import java.awt.event.InputEvent;\n+import java.awt.event.KeyEvent;\n+import java.awt.event.MouseEvent;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+\n+\/*\n+  @test\n+  @bug 4389284\n+  @summary tests that drop targets registered on nested heavyweight\n+           components work properly\n+  @key headful\n+  @run main NestedHeavyweightDropTargetTest\n+*\/\n+\n+public class NestedHeavyweightDropTargetTest {\n+\n+    volatile Frame frame;\n+    volatile DragSourceButton dragSourceButton;\n+    volatile DropTargetPanel dropTargetPanel;\n+    volatile InnerDropTargetPanel innerDropTargetPanel;\n+    volatile Button button;\n+    volatile Dimension d;\n+    volatile Point srcPoint;\n+    volatile Point dstPoint;\n+\n+    static final int DROP_COMPLETION_TIMEOUT = 1000;\n+\n+    public static void main(String[] args) throws Exception {\n+        NestedHeavyweightDropTargetTest test = new NestedHeavyweightDropTargetTest();\n+        EventQueue.invokeAndWait(test::init);\n+        try {\n+            test.start();\n+        } finally {\n+            EventQueue.invokeAndWait(() -> {\n+                if (test.frame != null) {\n+                    test.frame.dispose();\n+                }\n+            });\n+        }\n+    }\n+\n+    public void init() {\n+        frame = new Frame();\n+        dragSourceButton = new DragSourceButton();\n+        dropTargetPanel = new DropTargetPanel();\n+        innerDropTargetPanel = new InnerDropTargetPanel();\n+        button = new Button(\"button\");\n+        button.setBackground(Color.red);\n+\n+        innerDropTargetPanel.setLayout(new GridLayout(3, 1));\n+        innerDropTargetPanel.add(button);\n+        innerDropTargetPanel.setBackground(Color.yellow);\n+\n+        dropTargetPanel.setLayout(new GridLayout(2, 1));\n+        dropTargetPanel.add(innerDropTargetPanel);\n+        dropTargetPanel.setBackground(Color.green);\n+\n+        frame.setTitle(\"NestedHeavyweightDropTargetTest\");\n+        frame.setLocation(200, 200);\n+        frame.setLayout(new BorderLayout());\n+        frame.add(dropTargetPanel, BorderLayout.CENTER);\n+        frame.add(dragSourceButton, BorderLayout.SOUTH);\n+\n+        frame.pack();\n+\n+        innerDropTargetPanel.setDropTarget(new DropTarget(innerDropTargetPanel, innerDropTargetPanel));\n+        dropTargetPanel.setDropTarget(new DropTarget(dropTargetPanel, dropTargetPanel));\n+\n+        frame.setVisible(true);\n+    }\n+\n+    public void start() throws Exception {\n+        Robot robot = new Robot();\n+        Util.waitForInit();\n+\n+        test1(robot);\n+        test2(robot);\n+    }\n+\n+    public static int sign(int n) {\n+        return n < 0 ? -1 : n == 0 ? 0 : 1;\n+    }\n+\n+    public void test1(Robot robot) throws Exception {\n+        innerDropTargetPanel.setDragEnterTriggered(false);\n+        innerDropTargetPanel.setDragOverTriggered(false);\n+        innerDropTargetPanel.setDragExitTriggered(false);\n+        innerDropTargetPanel.setDropTriggered(false);\n+\n+        EventQueue.invokeAndWait(() -> {\n+            srcPoint = dragSourceButton.getLocationOnScreen();\n+            d = dragSourceButton.getSize();\n+        });\n+\n+        srcPoint.translate(d.width \/ 2, d.height \/ 2);\n+\n+        if (!Util.pointInComponent(robot, srcPoint, dragSourceButton)) {\n+            System.err.println(\"WARNING: Couldn't locate \" + dragSourceButton +\n+                               \" at point \" + srcPoint);\n+            return;\n+        }\n+\n+        EventQueue.invokeAndWait(() -> {\n+            dstPoint = innerDropTargetPanel.getLocationOnScreen();\n+            d = innerDropTargetPanel.getSize();\n+        });\n+\n+        dstPoint.translate(d.width \/ 2, d.height \/ 2);\n+\n+        if (!Util.pointInComponent(robot, dstPoint, innerDropTargetPanel)) {\n+            System.err.println(\"WARNING: Couldn't locate \" + innerDropTargetPanel +\n+                               \" at point \" + dstPoint);\n+            return;\n+        }\n+\n+        robot.mouseMove(srcPoint.x, srcPoint.y);\n+        robot.keyPress(KeyEvent.VK_CONTROL);\n+        robot.mousePress(InputEvent.BUTTON1_MASK);\n+        for (;!srcPoint.equals(dstPoint);\n+             srcPoint.translate(sign(dstPoint.x - srcPoint.x),\n+                                sign(dstPoint.y - srcPoint.y))) {\n+            robot.mouseMove(srcPoint.x, srcPoint.y);\n+            Thread.sleep(10);\n+        }\n+        robot.mouseRelease(InputEvent.BUTTON1_MASK);\n+        robot.keyRelease(KeyEvent.VK_CONTROL);\n+\n+        Thread.sleep(DROP_COMPLETION_TIMEOUT);\n+\n+        if (!innerDropTargetPanel.isDragEnterTriggered()) {\n+            throw new RuntimeException(\"child dragEnter() not triggered\");\n+        }\n+\n+        if (!innerDropTargetPanel.isDragOverTriggered()) {\n+            throw new RuntimeException(\"child dragOver() not triggered\");\n+        }\n+\n+        if (!innerDropTargetPanel.isDropTriggered()) {\n+            throw new RuntimeException(\"child drop() not triggered\");\n+        }\n+    }\n+\n+    public void test2(Robot robot) throws Exception {\n+        innerDropTargetPanel.setDragEnterTriggered(false);\n+        innerDropTargetPanel.setDragOverTriggered(false);\n+        innerDropTargetPanel.setDragExitTriggered(false);\n+        innerDropTargetPanel.setDropTriggered(false);\n+\n+        EventQueue.invokeAndWait(() -> {\n+            srcPoint = dragSourceButton.getLocationOnScreen();\n+            d = dragSourceButton.getSize();\n+        });\n+        srcPoint.translate(d.width \/ 2, d.height \/ 2);\n+\n+        if (!Util.pointInComponent(robot, srcPoint, dragSourceButton)) {\n+            System.err.println(\"WARNING: Couldn't locate \" + dragSourceButton +\n+                               \" at point \" + srcPoint);\n+            return;\n+        }\n+\n+        EventQueue.invokeAndWait(() -> {\n+            dstPoint = button.getLocationOnScreen();\n+            d = button.getSize();\n+        });\n+\n+        dstPoint.translate(d.width \/ 2, d.height \/ 2);\n+\n+        if (!Util.pointInComponent(robot, dstPoint, button)) {\n+            System.err.println(\"WARNING: Couldn't locate \" + button +\n+                               \" at point \" + dstPoint);\n+            return;\n+        }\n+\n+        robot.mouseMove(srcPoint.x, srcPoint.y);\n+        robot.keyPress(KeyEvent.VK_CONTROL);\n+        robot.mousePress(InputEvent.BUTTON1_MASK);\n+        for (;!srcPoint.equals(dstPoint);\n+             srcPoint.translate(sign(dstPoint.x - srcPoint.x),\n+                                sign(dstPoint.y - srcPoint.y))) {\n+            robot.mouseMove(srcPoint.x, srcPoint.y);\n+            Thread.sleep(10);\n+        }\n+        robot.mouseRelease(InputEvent.BUTTON1_MASK);\n+        robot.keyRelease(KeyEvent.VK_CONTROL);\n+\n+        Thread.sleep(DROP_COMPLETION_TIMEOUT);\n+\n+        if (!innerDropTargetPanel.isDragEnterTriggered()) {\n+            throw new RuntimeException(\"child dragEnter() not triggered\");\n+        }\n+\n+        if (!innerDropTargetPanel.isDragOverTriggered()) {\n+            throw new RuntimeException(\"child dragOver() not triggered\");\n+        }\n+\n+        if (!innerDropTargetPanel.isDropTriggered()) {\n+            throw new RuntimeException(\"child drop() not triggered\");\n+        }\n+    }\n+}\n+\n+class Util implements AWTEventListener {\n+    private static final Toolkit tk = Toolkit.getDefaultToolkit();\n+    public static final Object SYNC_LOCK = new Object();\n+    private Component clickedComponent = null;\n+    private static final int PAINT_TIMEOUT = 10000;\n+    private static final int MOUSE_RELEASE_TIMEOUT = 10000;\n+    private static final Util util = new Util();\n+\n+    static {\n+        tk.addAWTEventListener(util, 0xFFFFFFFF);\n+    }\n+\n+    private void reset() {\n+        clickedComponent = null;\n+    }\n+\n+    public void eventDispatched(AWTEvent e) {\n+        if (e.getID() == MouseEvent.MOUSE_RELEASED) {\n+            clickedComponent = (Component)e.getSource();\n+            synchronized (SYNC_LOCK) {\n+                SYNC_LOCK.notifyAll();\n+            }\n+        }\n+    }\n+\n+    public static boolean pointInComponent(Robot robot, Point p, Component comp)\n+      throws InterruptedException {\n+        return util.isPointInComponent(robot, p, comp);\n+    }\n+\n+    private boolean isPointInComponent(Robot robot, Point p, Component comp)\n+      throws InterruptedException {\n+        tk.sync();\n+        robot.waitForIdle();\n+        reset();\n+        robot.mouseMove(p.x, p.y);\n+        robot.mousePress(InputEvent.BUTTON1_MASK);\n+        synchronized (SYNC_LOCK) {\n+            robot.mouseRelease(InputEvent.BUTTON1_MASK);\n+            SYNC_LOCK.wait(MOUSE_RELEASE_TIMEOUT);\n+        }\n+\n+        Component c = clickedComponent;\n+\n+        while (c != null && c != comp) {\n+            c = c.getParent();\n+        }\n+\n+        return c == comp;\n+    }\n+\n+    public static void waitForInit() throws InterruptedException {\n+        final Frame f = new Frame() {\n+                public void paint(Graphics g) {\n+                    dispose();\n+                    synchronized (SYNC_LOCK) {\n+                        SYNC_LOCK.notifyAll();\n+                    }\n+                }\n+            };\n+        f.setBounds(600, 400, 200, 200);\n+        synchronized (SYNC_LOCK) {\n+            f.setVisible(true);\n+            SYNC_LOCK.wait(PAINT_TIMEOUT);\n+        }\n+        tk.sync();\n+    }\n+}\n+\n+class DragSourceButton extends Button implements Serializable,\n+                                                 Transferable,\n+                                                 DragGestureListener,\n+                                                 DragSourceListener {\n+    private final DataFlavor dataflavor =\n+        new DataFlavor(Button.class, \"DragSourceButton\");\n+\n+    public DragSourceButton() {\n+        this(\"DragSourceButton\");\n+    }\n+\n+    public DragSourceButton(String str) {\n+        super(str);\n+\n+        DragSource ds = DragSource.getDefaultDragSource();\n+        ds.createDefaultDragGestureRecognizer(this, DnDConstants.ACTION_COPY,\n+                                              this);\n+    }\n+\n+    public void dragGestureRecognized(DragGestureEvent dge) {\n+        dge.startDrag(null, this, this);\n+    }\n+\n+    public void dragEnter(DragSourceDragEvent dsde) {}\n+\n+    public void dragExit(DragSourceEvent dse) {}\n+\n+    public void dragOver(DragSourceDragEvent dsde) {}\n+\n+    public void dragDropEnd(DragSourceDropEvent dsde) {}\n+\n+    public void dropActionChanged(DragSourceDragEvent dsde) {}\n+\n+    public Object getTransferData(DataFlavor flavor)\n+      throws UnsupportedFlavorException, IOException {\n+\n+        if (!isDataFlavorSupported(flavor)) {\n+            throw new UnsupportedFlavorException(flavor);\n+        }\n+\n+        Object retObj = null;\n+\n+        ByteArrayOutputStream baoStream = new ByteArrayOutputStream();\n+        ObjectOutputStream ooStream = new ObjectOutputStream(baoStream);\n+        ooStream.writeObject(this);\n+\n+        ByteArrayInputStream baiStream = new ByteArrayInputStream(baoStream.toByteArray());\n+        ObjectInputStream ois = new ObjectInputStream(baiStream);\n+        try {\n+            retObj = ois.readObject();\n+        } catch (ClassNotFoundException e) {\n+            e.printStackTrace();\n+            throw new RuntimeException(e.toString());\n+        }\n+\n+        return retObj;\n+    }\n+\n+    public DataFlavor[] getTransferDataFlavors() {\n+        return new DataFlavor[] { dataflavor };\n+    }\n+\n+    public boolean isDataFlavorSupported(DataFlavor dflavor) {\n+        return dataflavor.equals(dflavor);\n+    }\n+}\n+\n+class InnerDropTargetPanel extends DropTargetPanel {\n+    private boolean dragEnterTriggered = false;\n+    private boolean dragOverTriggered = false;\n+    private boolean dragExitTriggered = false;\n+    private boolean dropTriggered = false;\n+\n+    public void dragEnter(DropTargetDragEvent dtde) {\n+        setDragEnterTriggered(true);\n+    }\n+\n+    public void dragExit(DropTargetEvent dte) {\n+        setDragExitTriggered(true);\n+    }\n+\n+    public void dragOver(DropTargetDragEvent dtde) {\n+        setDragOverTriggered(true);\n+    }\n+\n+    public void dropActionChanged(DropTargetDragEvent dtde) {}\n+\n+    public void drop(DropTargetDropEvent dtde) {\n+        setDropTriggered(true);\n+        dtde.rejectDrop();\n+    }\n+\n+    public boolean isDragEnterTriggered() {\n+        return dragEnterTriggered;\n+    }\n+\n+    public boolean isDragOverTriggered() {\n+        return dragOverTriggered;\n+    }\n+\n+    public boolean isDragExitTriggered() {\n+        return dragExitTriggered;\n+    }\n+\n+    public boolean isDropTriggered() {\n+        return dropTriggered;\n+    }\n+\n+    public void setDragEnterTriggered(boolean b) {\n+        dragEnterTriggered = b;\n+    }\n+\n+    public void setDragOverTriggered(boolean b) {\n+        dragOverTriggered = b;\n+    }\n+\n+    public void setDragExitTriggered(boolean b) {\n+        dragExitTriggered = b;\n+    }\n+\n+    public void setDropTriggered(boolean b) {\n+        dropTriggered = b;\n+    }\n+}\n+\n+class DropTargetPanel extends Panel implements DropTargetListener {\n+\n+    public void dragEnter(DropTargetDragEvent dtde) {}\n+\n+    public void dragExit(DropTargetEvent dte) {}\n+\n+    public void dragOver(DropTargetDragEvent dtde) {}\n+\n+    public void dropActionChanged(DropTargetDragEvent dtde) {}\n+\n+    public void drop(DropTargetDropEvent dtde) {\n+        DropTargetContext dtc = dtde.getDropTargetContext();\n+\n+        if ((dtde.getSourceActions() & DnDConstants.ACTION_COPY) != 0) {\n+            dtde.acceptDrop(DnDConstants.ACTION_COPY);\n+        } else {\n+            dtde.rejectDrop();\n+        }\n+\n+        DataFlavor[] dfs = dtde.getCurrentDataFlavors();\n+        Component comp = null;\n+\n+        if (dfs != null && dfs.length >= 1) {\n+            Transferable transfer = dtde.getTransferable();\n+\n+            try {\n+                comp = (Component)transfer.getTransferData(dfs[0]);\n+            } catch (Throwable e) {\n+                e.printStackTrace();\n+                dtc.dropComplete(false);\n+            }\n+        }\n+        dtc.dropComplete(true);\n+\n+        add(comp);\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/dnd\/NestedHeavyweightDropTargetTest.java","additions":492,"deletions":0,"binary":false,"changes":492,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+ * @test\n@@ -29,1 +30,1 @@\n- * @run applet\/manual=yesno InitToBlack.html\n+ * @run main\/manual InitToBlack\n@@ -32,3 +33,18 @@\n-import java.awt.*;\n-import java.awt.print.*;\n-import java.applet.Applet;\n+import java.awt.BorderLayout;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.print.Book;\n+import java.awt.print.PageFormat;\n+import java.awt.print.Printable;\n+import java.awt.print.PrinterException;\n+import java.awt.print.PrinterJob;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import javax.swing.JButton;\n+import javax.swing.JDialog;\n+import javax.swing.JFrame;\n+import javax.swing.JLabel;\n+import javax.swing.JPanel;\n+import javax.swing.JTextArea;\n+import javax.swing.SwingUtilities;\n@@ -36,1 +52,1 @@\n-public class InitToBlack extends Applet implements Printable {\n+public class InitToBlack implements Printable {\n@@ -38,1 +54,17 @@\n-    public void init() {\n+    private static volatile JFrame frame;\n+    private static volatile boolean testResult = false;\n+    private static volatile CountDownLatch printButtonCountDownLatch =\n+            new CountDownLatch(1);\n+    private static volatile CountDownLatch CountDownLatch =\n+            new CountDownLatch(1);\n+    private static volatile String failureReason;\n+\n+    @Override\n+    public int print(Graphics graphics, PageFormat pageFormat, int pageIndex) throws PrinterException {\n+        Graphics2D g2d = (Graphics2D) graphics;\n+        g2d.translate(pageFormat.getImageableX(), pageFormat.getImageableY());\n+        graphics.drawString(\"Test Passes\", 200, 200);\n+        return PAGE_EXISTS;\n+    }\n+\n+    private void test() {\n@@ -40,0 +72,4 @@\n+        if (pjob.getPrintService() == null) {\n+            System.out.println(\"There is no printer configured on this system\");\n+            return;\n+        }\n@@ -52,3 +88,11 @@\n-    public int print(Graphics g, PageFormat pf, int pageIndex) {\n-        Graphics2D g2d = (Graphics2D) g;\n-        g2d.translate(pf.getImageableX(), pf.getImageableY());\n+    private static void createTestUI() {\n+        frame = new JFrame(\"Test InitToBlack\");\n+        String INSTRUCTION = \"Aim: This test checks whether the default foreground color on a printer\\n\" +\n+                \"graphics object is black so that rendering will appear without having\\n\" +\n+                \"to execute setColor.\\n\" +\n+                \"Step:\\n\" +\n+                \"1) Click on the \\\"Print\\\" button. Check whether page is printed on the printer.\\n\" +\n+                \"2) Check whether \\\"Test Passes\\\" is printed on the page and it should be in\\n\" +\n+                \"black color. If yes then press \\\"Pass\\\" button else press \\\"Fail\\\" button.\\n\";\n+        JTextArea instructionTextArea = new JTextArea(INSTRUCTION, 4, 40);\n+        instructionTextArea.setEditable(false);\n@@ -56,1 +100,7 @@\n-        g.drawString(\"Test Passes\", 200, 200);\n+        JPanel buttonPanel = new JPanel();\n+        JButton printButton = new JButton(\"Print\");\n+        printButton.addActionListener((ae) -> {\n+            InitToBlack initToBlack = new InitToBlack();\n+            initToBlack.test();\n+            printButtonCountDownLatch.countDown();\n+        });\n@@ -58,1 +108,52 @@\n-        return PAGE_EXISTS;\n+        JButton passButton = new JButton(\"Pass\");\n+        passButton.addActionListener((ae) -> {\n+            testResult = true;\n+            CountDownLatch.countDown();\n+            frame.dispose();\n+        });\n+        JButton failButton = new JButton(\"Fail\");\n+        failButton.addActionListener((ae) -> {\n+            getFailureReason();\n+            frame.dispose();\n+        });\n+        buttonPanel.add(printButton);\n+        buttonPanel.add(passButton);\n+        buttonPanel.add(failButton);\n+\n+        JPanel panel = new JPanel(new BorderLayout());\n+        panel.add(instructionTextArea, BorderLayout.CENTER);\n+        panel.add(buttonPanel, BorderLayout.SOUTH);\n+\n+        frame.add(panel);\n+        frame.setLocationRelativeTo(null);\n+        frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);\n+        frame.pack();\n+        frame.setVisible(true);\n+    }\n+\n+    public static void getFailureReason() {\n+        final JDialog dialog = new JDialog();\n+        dialog.setTitle(\"Read testcase failure reason\");\n+        JPanel jPanel = new JPanel(new BorderLayout());\n+        JTextArea jTextArea = new JTextArea(5, 20);\n+\n+        JButton okButton = new JButton(\"Ok\");\n+        okButton.addActionListener((ae) -> {\n+            failureReason = jTextArea.getText();\n+            testResult = false;\n+            CountDownLatch.countDown();\n+            dialog.dispose();\n+        });\n+\n+        jPanel.add(new JLabel(\"Enter the testcase failed reason below and \" +\n+                \"click OK button\", JLabel.CENTER), BorderLayout.NORTH);\n+        jPanel.add(jTextArea, BorderLayout.CENTER);\n+\n+        JPanel okayBtnPanel = new JPanel();\n+        okayBtnPanel.add(okButton);\n+\n+        jPanel.add(okayBtnPanel, BorderLayout.SOUTH);\n+        dialog.add(jPanel);\n+        dialog.setLocationRelativeTo(null);\n+        dialog.pack();\n+        dialog.setVisible(true);\n@@ -61,3 +162,16 @@\n-    public static void main(String[] args) {\n-        new InitToBlack().init();\n-        System.exit(0);\n+    public static void main(String[] args) throws InterruptedException, InvocationTargetException {\n+        SwingUtilities.invokeAndWait(InitToBlack::createTestUI);\n+        if (!printButtonCountDownLatch.await(2, TimeUnit.MINUTES)) {\n+            throw new RuntimeException(\"Timeout: User did not perform action \" +\n+                    \"on Print button.\");\n+        }\n+        if (!CountDownLatch.await(2, TimeUnit.MINUTES)) {\n+            throw new RuntimeException(\"Timeout : User did not decide \" +\n+                    \"whether test passed or failed\");\n+        }\n+\n+        if (!testResult) {\n+            throw new RuntimeException(\"Test failed : \" + failureReason);\n+        } else {\n+            System.out.println(\"Test Passed\");\n+        }\n","filename":"test\/jdk\/java\/awt\/print\/PrinterJob\/InitToBlack.java","additions":129,"deletions":15,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-  @key headful\n+   @key headful\n@@ -29,1 +29,0 @@\n-   @author Alexander Potochkin\n@@ -32,1 +31,9 @@\n-import javax.swing.*;\n+import java.awt.Cursor;\n+import java.awt.Dimension;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Robot;\n+import java.awt.Toolkit;\n+import java.awt.image.BufferedImage;\n+import javax.imageio.ImageIO;\n+import javax.swing.JFrame;\n@@ -35,1 +42,2 @@\n-import java.awt.*;\n+import javax.swing.JTable;\n+import javax.swing.SwingUtilities;\n@@ -39,0 +47,6 @@\n+    static JFrame frame;\n+    static Robot robot;\n+    static volatile Point point;\n+    static volatile int width;\n+    static volatile int height;\n+\n@@ -40,2 +54,3 @@\n-        Robot robot = new Robot();\n-        robot.setAutoDelay(20);\n+        try {\n+            robot = new Robot();\n+            robot.setAutoDelay(100);\n@@ -43,2 +58,3 @@\n-        final JFrame frame = new JFrame();\n-        frame.setUndecorated(true);\n+            SwingUtilities.invokeAndWait(() -> {\n+                frame = new JFrame();\n+                frame.setUndecorated(true);\n@@ -46,2 +62,0 @@\n-        SwingUtilities.invokeAndWait(new Runnable() {\n-            public void run() {\n@@ -59,0 +73,14 @@\n+            });\n+            robot.waitForIdle();\n+            robot.delay(1000);\n+            SwingUtilities.invokeAndWait(() -> {\n+                point = frame.getLocationOnScreen();\n+                width = frame.getWidth();\n+                height = frame.getHeight();\n+            });\n+            int shift = 10;\n+            int x = point.x;\n+            int y = point.y + height\/2;\n+            for(int i = -shift; i < width + 2*shift; i++) {\n+                robot.mouseMove(x++, y);\n+                robot.waitForIdle();\n@@ -60,14 +88,12 @@\n-        });\n-        robot.waitForIdle();\n-        Point point = frame.getLocationOnScreen();\n-        int shift = 10;\n-        int x = point.x;\n-        int y = point.y + frame.getHeight()\/2;\n-        for(int i = -shift; i < frame.getWidth() + 2*shift; i++) {\n-            robot.mouseMove(x++, y);\n-        }\n-        robot.waitForIdle();\n-        \/\/ 9 is a magic test number\n-        if (MyTableHeaderUI.getTestValue() != 9) {\n-            throw new RuntimeException(\"Unexpected test number \"\n-                    + MyTableHeaderUI.getTestValue());\n+            robot.waitForIdle();\n+            \/\/ 9 is a magic test number\n+            if (MyTableHeaderUI.getTestValue() != 9) {\n+                throw new RuntimeException(\"Unexpected test number \"\n+                        + MyTableHeaderUI.getTestValue());\n+            }\n+        } finally {\n+            SwingUtilities.invokeAndWait(() -> {\n+                if (frame != null) {\n+                    frame.dispose();\n+                }\n+            });\n@@ -86,0 +112,9 @@\n+                try {\n+                    Dimension screenSize =\n+                               Toolkit.getDefaultToolkit().getScreenSize();\n+                    Rectangle screen = new Rectangle(0, 0,\n+                                               (int) screenSize.getWidth(),\n+                                               (int) screenSize.getHeight());\n+                    BufferedImage img = robot.createScreenCapture(screen);\n+                    ImageIO.write(img, \"png\", new java.io.File(\"image.png\"));\n+                } catch (Exception e) {}\n","filename":"test\/jdk\/javax\/swing\/JTableHeader\/6889007\/bug6889007.java","additions":59,"deletions":24,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -1,82 +0,0 @@\n-\/*\n- * Copyright (c) 2002, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.net.*;\n-import java.util.*;\n-import java.io.IOException;\n-\n-\/**\n- * This class provides a partial implementation of the HttpCallback\n- * interface. Use this class if you want to use the requestURI as a means\n- * of tracking multiple invocations of a request (on the server).\n- * In this case, you implement the modified request() method, which includes\n- * an integer count parameter. This parameter indicates the number of times\n- * (starting at zero) the request URI has been received.\n- *\/\n-\n-public abstract class AbstractCallback implements HttpCallback {\n-\n-    Map requests;\n-\n-    static class Request {\n-        URI uri;\n-        int count;\n-\n-        Request (URI u) {\n-            uri = u;\n-            count = 0;\n-        }\n-    }\n-\n-    AbstractCallback () {\n-        requests = Collections.synchronizedMap (new HashMap());\n-    }\n-\n-    \/**\n-     * handle the given request and generate an appropriate response.\n-     * @param msg the transaction containing the request from the\n-     *        client and used to send the response\n-     *\/\n-    public void request (HttpTransaction msg) {\n-        URI uri = msg.getRequestURI();\n-        Request req = (Request) requests.get (uri);\n-        if (req == null) {\n-            req = new Request (uri);\n-            requests.put (uri, req);\n-        }\n-        request (msg, req.count++);\n-    }\n-\n-    \/**\n-     * Same as HttpCallback interface except that the integer n\n-     * is provided to indicate sequencing of repeated requests using\n-     * the same request URI. n starts at zero and is incremented\n-     * for each successive call.\n-     *\n-     * @param msg the transaction containing the request from the\n-     *        client and used to send the response\n-     * @param n value is 0 at first call, and is incremented by 1 for\n-     *        each subsequent call using the same request URI.\n-     *\/\n-    abstract public void request (HttpTransaction msg, int n);\n-}\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/https\/AbstractCallback.java","additions":0,"deletions":82,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,1 @@\n- * @modules java.base\/sun.net.www\n- * @build TestHttpsServer HttpCallback\n+ * @library \/test\/lib\n@@ -36,3 +35,14 @@\n-import java.io.*;\n-import java.net.*;\n-import javax.net.ssl.*;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpRetryException;\n+import java.net.HttpURLConnection;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.Proxy;\n+import java.net.SocketException;\n+import java.net.URL;\n+import java.nio.charset.Charset;\n+import java.security.KeyStore;\n+import java.util.concurrent.Executors;\n@@ -41,1 +51,13 @@\n-public class ChunkedOutputStream implements HttpCallback {\n+import javax.net.ssl.HostnameVerifier;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSession;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+import com.sun.net.httpserver.HttpExchange;\n+import com.sun.net.httpserver.HttpHandler;\n+import com.sun.net.httpserver.HttpsConfigurator;\n+import com.sun.net.httpserver.HttpsServer;\n+\n+public class ChunkedOutputStream implements HttpHandler {\n@@ -59,20 +81,28 @@\n-    public void request (HttpTransaction req) {\n-        try {\n-            \/\/ this is needed (count++ doesn't work), 'cause we\n-            \/\/ are doing concurrent tests\n-            String path = req.getRequestURI().getPath();\n-            if (path.equals(\"\/d0\")) {\n-                count = 0;\n-            } else if (path.equals(\"\/d01\")) {\n-                count = 1;\n-            } else if (path.equals(\"\/d3\")) {\n-                count = 2;\n-            } else if (path.equals(\"\/d4\") || path.equals(\"\/d5\")) {\n-                count = 3;\n-            } else if (path.equals(\"\/d6\")) {\n-                count = 3;\n-            }  else if (path.equals(\"\/d7\")) {\n-                count = 4;\n-            }  else if (path.equals(\"\/d8\")) {\n-                count = 5;\n-            }\n+    private static String getAuthority() {\n+        InetAddress address = server.getAddress().getAddress();\n+        String hostaddr = address.getHostAddress();\n+        if (address.isAnyLocalAddress()) hostaddr = \"localhost\";\n+        if (hostaddr.indexOf(':') > -1) hostaddr = \"[\" + hostaddr + \"]\";\n+        return hostaddr + \":\" + server.getAddress().getPort();\n+    }\n+\n+    public void handle(HttpExchange req) throws IOException {\n+        \/\/ this is needed (count++ doesn't work), 'cause we\n+        \/\/ are doing concurrent tests\n+        System.out.println(\"Request Received\");\n+        String path = req.getRequestURI().getPath();\n+        if (path.equals(\"\/d0\")) {\n+            count = 0;\n+        } else if (path.equals(\"\/d01\")) {\n+            count = 1;\n+        } else if (path.equals(\"\/d3\")) {\n+            count = 2;\n+        } else if (path.equals(\"\/d4\") || path.equals(\"\/d5\")) {\n+            count = 3;\n+        } else if (path.equals(\"\/d6\")) {\n+            count = 3;\n+        }  else if (path.equals(\"\/d7\")) {\n+            count = 4;\n+        }  else if (path.equals(\"\/d8\")) {\n+            count = 5;\n+        }\n@@ -80,1 +110,1 @@\n-            switch (count) {\n+        switch (count) {\n@@ -83,1 +113,5 @@\n-                String reqbody = req.getRequestEntityBody();\n+\n+                String reqbody = \"\";\n+                try(InputStream inputStream = req.getRequestBody()) {\n+                    reqbody = new String(inputStream.readAllBytes(), Charset.forName(\"ISO8859_1\"));\n+                }\n@@ -85,2 +119,2 @@\n-                    req.sendResponse (500, \"Internal server error\");\n-                    req.orderlyClose();\n+                    req.sendResponseHeaders(500, -1);\n+                    break;\n@@ -88,4 +122,4 @@\n-                String chunk = req.getRequestHeader (\"Transfer-encoding\");\n-                if (!\"chunked\".equals (chunk)) {\n-                    req.sendResponse (501, \"Internal server error\");\n-                    req.orderlyClose();\n+                String chunk = req.getRequestHeaders().getFirst(\"Transfer-encoding\");\n+                if (!\"chunked\".equals(chunk)) {\n+                    req.sendResponseHeaders(501, -1);\n+                    break;\n@@ -93,1 +127,0 @@\n-                req.setResponseEntityBody (reqbody);\n@@ -95,1 +128,1 @@\n-                    req.setResponseHeader (\"Connection\", \"close\");\n+                    req.getResponseHeaders().set(\"Connection\", \"close\");\n@@ -97,3 +130,3 @@\n-                req.sendResponse (200, \"OK\");\n-                if (count == 1) {\n-                    req.orderlyClose();\n+                req.sendResponseHeaders(200, 0);\n+                try (OutputStream os = req.getResponseBody()) {\n+                    os.write(reqbody.getBytes(Charset.forName(\"ISO8859_1\")));\n@@ -103,1 +136,1 @@\n-                reqbody = req.getRequestEntityBody();\n+                reqbody = new String(req.getRequestBody().readAllBytes(), Charset.forName(\"ISO8859_1\"));\n@@ -105,2 +138,2 @@\n-                    req.sendResponse (500, \"Internal server error\");\n-                    req.orderlyClose();\n+                    req.sendResponseHeaders(500, -1);\n+                    break;\n@@ -108,2 +141,1 @@\n-                int clen = Integer.parseInt (\n-                        req.getRequestHeader (\"Content-length\"));\n+                int clen = Integer.parseInt (req.getRequestHeaders().getFirst(\"Content-length\"));\n@@ -111,2 +143,7 @@\n-                    req.sendResponse (501, \"Internal server error\");\n-                    req.orderlyClose();\n+                    req.sendResponseHeaders(501, -1);\n+                    break;\n+                }\n+                req.getResponseHeaders().set(\"Connection\", \"close\");\n+                req.sendResponseHeaders(200, 0);\n+                try (OutputStream os = req.getResponseBody()) {\n+                    os.write(reqbody.getBytes(Charset.forName(\"ISO8859_1\")));\n@@ -114,4 +151,0 @@\n-                req.setResponseEntityBody (reqbody);\n-                req.setResponseHeader (\"Connection\", \"close\");\n-                req.sendResponse (200, \"OK\");\n-                req.orderlyClose();\n@@ -120,4 +153,6 @@\n-                req.setResponseHeader (\"Location\", \"https:\/\/foo.bar\/\");\n-                req.setResponseHeader (\"Connection\", \"close\");\n-                req.sendResponse (307, \"Temporary Redirect\");\n-                req.orderlyClose();\n+                if (path.equals(\"\/d6\")) {\n+                    reqbody = new String(req.getRequestBody().readAllBytes(), Charset.forName(\"ISO8859_1\"));\n+                }\n+                req.getResponseHeaders().set(\"Location\", \"https:\/\/foo.bar\/\");\n+                req.getResponseHeaders().set(\"Connection\", \"close\");\n+                req.sendResponseHeaders(307, -1);\n@@ -127,4 +162,4 @@\n-                reqbody = req.getRequestEntityBody();\n-                if (reqbody != null && !\"\".equals (reqbody)) {\n-                    req.sendResponse (501, \"Internal server error\");\n-                    req.orderlyClose();\n+                reqbody = new String(req.getRequestBody().readAllBytes(), Charset.forName(\"ISO8859_1\"));\n+                if (reqbody != null && !\"\".equals(reqbody)) {\n+                    req.sendResponseHeaders(501, -1);\n+                    break;\n@@ -132,3 +167,2 @@\n-                req.setResponseHeader (\"Connection\", \"close\");\n-                req.sendResponse (200, \"OK\");\n-                req.orderlyClose();\n+                req.getResponseHeaders().set(\"Connection\", \"close\");\n+                req.sendResponseHeaders(200, -1);\n@@ -137,2 +171,1 @@\n-                req.sendResponse(404, \"Not Found\");\n-                req.orderlyClose();\n+                req.sendResponseHeaders(404, -1);\n@@ -140,3 +173,0 @@\n-            }\n-        } catch (IOException e) {\n-            e.printStackTrace();\n@@ -144,7 +174,1 @@\n-    }\n-\n-    public boolean dropPlainTextConnections() {\n-        System.out.println(\"Unrecognized SSL message, plaintext connection?\");\n-        System.out.println(\"TestHttpsServer receveived rogue connection: ignoring it.\");\n-        rogueCount.incrementAndGet();\n-        return true;\n+        req.close();\n@@ -181,3 +205,0 @@\n-            \/\/ on the client side, and confirm that this::dropPlainTextConnections\n-            \/\/ has ben called.\n-            if (rogueCount.get() == rogue) throw x;\n@@ -198,1 +219,1 @@\n-        os.write (str1.getBytes());\n+        os.write(str1.getBytes(Charset.forName(\"ISO8859_1\")));\n@@ -215,1 +236,1 @@\n-        os.write (str2.getBytes());\n+        os.write (str2.getBytes(Charset.forName(\"ISO8859_1\")));\n@@ -232,1 +253,1 @@\n-        os.write (str2.getBytes());\n+        os.write(str2.getBytes(Charset.forName(\"ISO8859_1\")));\n@@ -250,1 +271,1 @@\n-            os.write (str2.getBytes());\n+            os.write(str2.getBytes(Charset.forName(\"ISO8859_1\")));\n@@ -265,1 +286,1 @@\n-        os.write (str1.getBytes());\n+        os.write(str1.getBytes(Charset.forName(\"ISO8859_1\")));\n@@ -312,1 +333,1 @@\n-    static TestHttpsServer server;\n+    static HttpsServer server;\n@@ -315,0 +336,1 @@\n+        ChunkedOutputStream chunkedOutputStream = new ChunkedOutputStream();\n@@ -323,0 +345,2 @@\n+        InetAddress loopback = InetAddress.getLoopbackAddress();\n+\n@@ -333,4 +357,26 @@\n-                server = new TestHttpsServer(\n-                        new ChunkedOutputStream(), 1, 10, 0);\n-                System.out.println (\"Server started: listening on port: \" + server.getLocalPort());\n-                testPlainText(server.getAuthority());\n+                \/\/ create and initialize a SSLContext\n+                KeyStore ks = KeyStore.getInstance(\"JKS\");\n+                KeyStore ts = KeyStore.getInstance(\"JKS\");\n+                char[] passphrase = \"passphrase\".toCharArray();\n+\n+                ks.load(new FileInputStream(System.getProperty(\"javax.net.ssl.keyStore\")), passphrase);\n+                ts.load(new FileInputStream(System.getProperty(\"javax.net.ssl.trustStore\")), passphrase);\n+\n+                KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"SunX509\");\n+                kmf.init(ks, passphrase);\n+\n+                TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n+                tmf.init(ts);\n+\n+                SSLContext sslCtx = SSLContext.getInstance(\"TLS\");\n+\n+                sslCtx.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);\n+\n+                server = HttpsServer.create(new InetSocketAddress(loopback, 0), 10);\n+                server.setHttpsConfigurator(new HttpsConfigurator(sslCtx));\n+                server.createContext(\"\/\", chunkedOutputStream);\n+                server.setExecutor(Executors.newSingleThreadExecutor());\n+                server.start();\n+\n+                System.out.println(\"Server started: listening on: \" + getAuthority());\n+                testPlainText(getAuthority());\n@@ -339,7 +385,7 @@\n-                test1(\"https:\/\/localhost:\"+server.getLocalPort()+\"\/d01\");\n-                test3(\"https:\/\/localhost:\"+server.getLocalPort()+\"\/d3\");\n-                test4(\"https:\/\/localhost:\"+server.getLocalPort()+\"\/d4\");\n-                test5(\"https:\/\/localhost:\"+server.getLocalPort()+\"\/d5\");\n-                test6(\"https:\/\/localhost:\"+server.getLocalPort()+\"\/d6\");\n-                test7(\"https:\/\/localhost:\"+server.getLocalPort()+\"\/d7\");\n-                test8(\"https:\/\/localhost:\"+server.getLocalPort()+\"\/d8\");\n+                test1(\"https:\/\/\" + getAuthority() + \"\/d01\");\n+                test3(\"https:\/\/\" + getAuthority() + \"\/d3\");\n+                test4(\"https:\/\/\" + getAuthority() + \"\/d4\");\n+                test5(\"https:\/\/\" + getAuthority() + \"\/d5\");\n+                test6(\"https:\/\/\" + getAuthority() + \"\/d6\");\n+                test7(\"https:\/\/\" + getAuthority() + \"\/d7\");\n+                test8(\"https:\/\/\" + getAuthority() + \"\/d8\");\n@@ -348,1 +394,1 @@\n-                    server.terminate();\n+                    server.stop(1);\n@@ -352,1 +398,1 @@\n-            server.terminate();\n+            server.stop(1);\n@@ -365,1 +411,1 @@\n-        server.terminate();\n+        server.stop(1);\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/https\/ChunkedOutputStream.java","additions":143,"deletions":97,"binary":false,"changes":240,"status":"modified"},{"patch":"@@ -1,50 +0,0 @@\n-\/*\n- * Copyright (c) 2002, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * This interface is implemented by classes that wish to handle incoming HTTP\n- * requests and generate responses. This could be a general purpose HTTP server\n- * or a test case that expects specific requests from a client.\n- * <p>\n- * The incoming request fields can be examined via the {@link HttpTransaction}\n- * object, and a response can also be generated and sent via the request object.\n- *\/\n-public interface HttpCallback {\n-    \/**\n-     * handle the given request and generate an appropriate response.\n-     * @param msg the transaction containing the request from the\n-     *        client and used to send the response\n-     *\/\n-    void request (HttpTransaction msg);\n-\n-    \/**\n-     * Tells whether the server should simply close the\n-     * connection and ignore the request when the first\n-     * byte received by the server looks like a plain\n-     * text connection.\n-     * @return true if the request should be ignored.\n-     **\/\n-    default boolean dropPlainTextConnections() {\n-        return false;\n-    }\n-}\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/https\/HttpCallback.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -1,330 +0,0 @@\n-\/*\n- * Copyright (c) 2002, 2012, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.io.*;\n-import java.nio.*;\n-import java.nio.channels.*;\n-import java.net.*;\n-import sun.net.www.MessageHeader;\n-\n-\/**\n- * This class encapsulates a HTTP request received and a response to be\n- * generated in one transaction. It provides methods for examaining the\n- * request from the client, and for building and sending a reply.\n- *\/\n-\n-public class HttpTransaction {\n-\n-    String command;\n-    URI requesturi;\n-    TestHttpsServer.ServerWorker server;\n-    MessageHeader reqheaders, reqtrailers;\n-    String reqbody;\n-    byte[] rspbody;\n-    MessageHeader rspheaders, rsptrailers;\n-    SocketChannel ch;\n-    int rspbodylen;\n-    boolean rspchunked;\n-\n-    HttpTransaction (TestHttpsServer.ServerWorker server, String command,\n-                        URI requesturi, MessageHeader headers,\n-                        String body, MessageHeader trailers, SocketChannel ch) {\n-        this.command = command;\n-        this.requesturi = requesturi;\n-        this.reqheaders = headers;\n-        this.reqbody = body;\n-        this.reqtrailers = trailers;\n-        this.ch = ch;\n-        this.server = server;\n-    }\n-\n-    \/**\n-     * Get the value of a request header whose name is specified by the\n-     * String argument.\n-     *\n-     * @param key the name of the request header\n-     * @return the value of the header or null if it does not exist\n-     *\/\n-    public String getRequestHeader (String key) {\n-        return reqheaders.findValue (key);\n-    }\n-\n-    \/**\n-     * Get the value of a response header whose name is specified by the\n-     * String argument.\n-     *\n-     * @param key the name of the response header\n-     * @return the value of the header or null if it does not exist\n-     *\/\n-    public String getResponseHeader (String key) {\n-        return rspheaders.findValue (key);\n-    }\n-\n-    \/**\n-     * Get the request URI\n-     *\n-     * @return the request URI\n-     *\/\n-    public URI getRequestURI () {\n-        return requesturi;\n-    }\n-\n-    public String toString () {\n-        StringBuffer buf = new StringBuffer();\n-        buf.append (\"Request from: \").append (ch.toString()).append(\"\\r\\n\");\n-        buf.append (\"Command: \").append (command).append(\"\\r\\n\");\n-        buf.append (\"Request URI: \").append (requesturi).append(\"\\r\\n\");\n-        buf.append (\"Headers: \").append(\"\\r\\n\");\n-        buf.append (reqheaders.toString()).append(\"\\r\\n\");\n-        buf.append (\"Body: \").append (reqbody).append(\"\\r\\n\");\n-        buf.append (\"---------Response-------\\r\\n\");\n-        buf.append (\"Headers: \").append(\"\\r\\n\");\n-        if (rspheaders != null) {\n-            buf.append (rspheaders.toString()).append(\"\\r\\n\");\n-        }\n-        String rbody = rspbody == null? \"\": new String (rspbody);\n-        buf.append (\"Body: \").append (rbody).append(\"\\r\\n\");\n-        return new String (buf);\n-    }\n-\n-    \/**\n-     * Get the value of a request trailer whose name is specified by\n-     * the String argument.\n-     *\n-     * @param key the name of the request trailer\n-     * @return the value of the trailer or null if it does not exist\n-     *\/\n-    public String getRequestTrailer (String key) {\n-        return reqtrailers.findValue (key);\n-    }\n-\n-    \/**\n-     * Add a response header to the response. Multiple calls with the same\n-     * key value result in multiple header lines with the same key identifier\n-     * @param key the name of the request header to add\n-     * @param val the value of the header\n-     *\/\n-    public void addResponseHeader (String key, String val) {\n-        if (rspheaders == null)\n-            rspheaders = new MessageHeader ();\n-        rspheaders.add (key, val);\n-    }\n-\n-    \/**\n-     * Set a response header. Searches for first header with named key\n-     * and replaces its value with val\n-     * @param key the name of the request header to add\n-     * @param val the value of the header\n-     *\/\n-    public void setResponseHeader (String key, String val) {\n-        if (rspheaders == null)\n-            rspheaders = new MessageHeader ();\n-        rspheaders.set (key, val);\n-    }\n-\n-    \/**\n-     * Add a response trailer to the response. Multiple calls with the same\n-     * key value result in multiple trailer lines with the same key identifier\n-     * @param key the name of the request trailer to add\n-     * @param val the value of the trailer\n-     *\/\n-    public void addResponseTrailer (String key, String val) {\n-        if (rsptrailers == null)\n-            rsptrailers = new MessageHeader ();\n-        rsptrailers.add (key, val);\n-    }\n-\n-    \/**\n-     * Get the request method\n-     *\n-     * @return the request method\n-     *\/\n-    public String getRequestMethod (){\n-        return command;\n-    }\n-\n-    \/**\n-     * Perform an orderly close of the TCP connection associated with this\n-     * request. This method guarantees that any response already sent will\n-     * not be reset (by this end). The implementation does a shutdownOutput()\n-     * of the TCP connection and for a period of time consumes and discards\n-     * data received on the reading side of the connection. This happens\n-     * in the background. After the period has expired the\n-     * connection is completely closed.\n-     *\/\n-\n-    public void orderlyClose () {\n-        try {\n-            server.orderlyCloseChannel (ch);\n-        } catch (IOException e) {\n-            System.out.println (e);\n-        }\n-    }\n-\n-    \/**\n-     * Do an immediate abortive close of the TCP connection associated\n-     * with this request.\n-     *\/\n-    public void abortiveClose () {\n-        try {\n-            server.abortiveCloseChannel(ch);\n-        } catch (IOException e) {\n-            System.out.println (e);\n-        }\n-    }\n-\n-    \/**\n-     * Get the SocketChannel associated with this request\n-     *\n-     * @return the socket channel\n-     *\/\n-    public SocketChannel channel() {\n-        return ch;\n-    }\n-\n-    \/**\n-     * Get the request entity body associated with this request\n-     * as a single String.\n-     *\n-     * @return the entity body in one String\n-     *\/\n-    public String getRequestEntityBody (){\n-        return reqbody;\n-    }\n-\n-    \/**\n-     * Set the entity response body with the given string\n-     * The content length is set to the length of the string\n-     * @param body the string to send in the response\n-     *\/\n-    public void setResponseEntityBody (String body){\n-        rspbody = body.getBytes();\n-        rspbodylen = body.length();\n-        rspchunked = false;\n-        addResponseHeader (\"Content-length\", Integer.toString (rspbodylen));\n-    }\n-    \/**\n-     * Set the entity response body with the given byte[]\n-     * The content length is set to the gven length\n-     * @param body the string to send in the response\n-     *\/\n-    public void setResponseEntityBody (byte[] body, int len){\n-        rspbody = body;\n-        rspbodylen = len;\n-        rspchunked = false;\n-        addResponseHeader (\"Content-length\", Integer.toString (rspbodylen));\n-    }\n-\n-\n-    \/**\n-     * Set the entity response body by reading the given inputstream\n-     *\n-     * @param is the inputstream from which to read the body\n-     *\/\n-    public void setResponseEntityBody (InputStream is) throws IOException {\n-        byte[] buf = new byte [2048];\n-        byte[] total = new byte [2048];\n-        int total_len = 2048;\n-        int c, len=0;\n-        while ((c=is.read (buf)) != -1) {\n-            if (len+c > total_len) {\n-                byte[] total1 = new byte [total_len * 2];\n-                System.arraycopy (total, 0, total1, 0, len);\n-                total = total1;\n-                total_len = total_len * 2;\n-            }\n-            System.arraycopy (buf, 0, total, len, c);\n-            len += c;\n-        }\n-        setResponseEntityBody (total, len);\n-    }\n-\n-    \/* chunked *\/\n-\n-    \/**\n-     * Set the entity response body with the given array of strings\n-     * The content encoding is set to \"chunked\" and each array element\n-     * is sent as one chunk.\n-     * @param body the array of string chunks to send in the response\n-     *\/\n-    public void setResponseEntityBody (String[] body) {\n-        StringBuffer buf = new StringBuffer ();\n-        int len = 0;\n-        for (int i=0; i<body.length; i++) {\n-            String chunklen = Integer.toHexString (body[i].length());\n-            len += body[i].length();\n-            buf.append (chunklen).append (\"\\r\\n\");\n-            buf.append (body[i]).append (\"\\r\\n\");\n-        }\n-        buf.append (\"0\\r\\n\");\n-        rspbody = new String (buf).getBytes();\n-        rspbodylen = rspbody.length;\n-        rspchunked = true;\n-        addResponseHeader (\"Transfer-encoding\", \"chunked\");\n-    }\n-\n-    \/**\n-     * Send the response with the current set of response parameters\n-     * but using the response code and string tag line as specified\n-     * @param rCode the response code to send\n-     * @param rTag the response string to send with the response code\n-     *\/\n-    public void sendResponse (int rCode, String rTag) throws IOException {\n-        OutputStream os = new TestHttpsServer.NioOutputStream(channel(), server.getSSLEngine(), server.outNetBB(), server.outAppBB());\n-        PrintStream ps = new PrintStream (os);\n-        ps.print (\"HTTP\/1.1 \" + rCode + \" \" + rTag + \"\\r\\n\");\n-        if (rspheaders != null) {\n-            rspheaders.print (ps);\n-        } else {\n-            ps.print (\"\\r\\n\");\n-        }\n-        ps.flush ();\n-        if (rspbody != null) {\n-            os.write (rspbody, 0, rspbodylen);\n-            os.flush();\n-        }\n-        if (rsptrailers != null) {\n-            rsptrailers.print (ps);\n-        } else if (rspchunked) {\n-            ps.print (\"\\r\\n\");\n-        }\n-        ps.flush();\n-    }\n-\n-    \/* sends one byte less than intended *\/\n-\n-    public void sendPartialResponse (int rCode, String rTag)throws IOException {\n-        OutputStream os = new TestHttpsServer.NioOutputStream(channel(), server.getSSLEngine(), server.outNetBB(), server.outAppBB());\n-        PrintStream ps = new PrintStream (os);\n-        ps.print (\"HTTP\/1.1 \" + rCode + \" \" + rTag + \"\\r\\n\");\n-        ps.flush();\n-        if (rspbody != null) {\n-            os.write (rspbody, 0, rspbodylen-1);\n-            os.flush();\n-        }\n-        if (rsptrailers != null) {\n-            rsptrailers.print (ps);\n-        }\n-        ps.flush();\n-    }\n-}\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/https\/HttpTransaction.java","additions":0,"deletions":330,"binary":false,"changes":330,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,2 +37,2 @@\n- *        HttpCallback TestHttpsServer ClosedChannelList\n- *        HttpTransaction TunnelProxy\n+ *        ClosedChannelList\n+ *        TunnelProxy\n@@ -43,5 +43,22 @@\n-import java.io.*;\n-import java.net.*;\n-import javax.net.ssl.*;\n-import java.util.*;\n-\n+import java.io.FileInputStream;\n+import java.net.HttpURLConnection;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.NetworkInterface;\n+import java.net.ProxySelector;\n+import java.net.URL;\n+import java.security.KeyStore;\n+import java.util.Optional;\n+import java.util.concurrent.Executors;\n+\n+import javax.net.ssl.HostnameVerifier;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSession;\n+import javax.net.ssl.TrustManagerFactory;\n+\n+import com.sun.net.httpserver.HttpExchange;\n+import com.sun.net.httpserver.HttpHandler;\n+import com.sun.net.httpserver.HttpsConfigurator;\n+import com.sun.net.httpserver.HttpsServer;\n@@ -52,1 +69,1 @@\n-    static TestHttpsServer server;\n+    static HttpsServer server;\n@@ -69,1 +86,0 @@\n-\n@@ -71,1 +87,0 @@\n-\n@@ -74,3 +89,1 @@\n-            System.setProperty(\"https.proxyPort\",\n-                        (new Integer(proxy.getLocalPort())).toString() );\n-\n+            ProxySelector.setDefault(ProxySelector.of(new InetSocketAddress(firstNonLoAddress, proxy.getLocalPort())));\n@@ -78,4 +91,0 @@\n-\n-            if (httpTrans.hasBadRequest) {\n-                throw new RuntimeException(\"Test failed : bad http request\");\n-            }\n@@ -87,1 +96,1 @@\n-               server.terminate();\n+               server.stop(1);\n@@ -138,1 +147,1 @@\n-    public static void startHttpServer() throws IOException {\n+    public static void startHttpServer() throws  Exception {\n@@ -142,1 +151,23 @@\n-        server = new TestHttpsServer(httpTrans, 1, 10, 0);\n+        \/\/ create and initialize a SSLContext\n+        KeyStore ks = KeyStore.getInstance(\"JKS\");\n+        KeyStore ts = KeyStore.getInstance(\"JKS\");\n+        char[] passphrase = \"passphrase\".toCharArray();\n+\n+        ks.load(new FileInputStream(System.getProperty(\"javax.net.ssl.keyStore\")), passphrase);\n+        ts.load(new FileInputStream(System.getProperty(\"javax.net.ssl.trustStore\")), passphrase);\n+\n+        KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"SunX509\");\n+        kmf.init(ks, passphrase);\n+\n+        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n+        tmf.init(ts);\n+\n+        SSLContext sslCtx = SSLContext.getInstance(\"TLS\");\n+\n+        sslCtx.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);\n+\n+        server = HttpsServer.create(new InetSocketAddress(firstNonLoAddress, 0), 10);\n+        server.setHttpsConfigurator(new HttpsConfigurator(sslCtx));\n+        server.createContext(\"\/\", httpTrans);\n+        server.setExecutor(Executors.newSingleThreadExecutor());\n+        server.start();\n@@ -147,1 +178,1 @@\n-        System.out.println(\"https server listen on: \" + server.getLocalPort());\n+        System.out.println(\"https server listen on: \" + server.getAddress().getPort());\n@@ -150,1 +181,1 @@\n-                            server.getLocalPort(), \"\/\");\n+                            server.getAddress().getPort(), \"\/\");\n@@ -153,0 +184,4 @@\n+        if(uc.getResponseCode() != 200) {\n+            uc.disconnect();\n+            throw new RuntimeException(\"Test failed : bad http request with response code : \"+ uc.getResponseCode());\n+        }\n@@ -163,2 +198,1 @@\n-class SimpleHttpTransaction implements HttpCallback {\n-    public boolean hasBadRequest = false;\n+class SimpleHttpTransaction implements HttpHandler {\n@@ -169,1 +203,1 @@\n-    public void request(HttpTransaction trans) {\n+    public void handle(HttpExchange trans) {\n@@ -175,2 +209,2 @@\n-                trans.addResponseHeader(\"Location\", location);\n-                trans.sendResponse(302, \"Moved Temporarily\");\n+                trans.getResponseHeaders().set(\"Location\", location);\n+                trans.sendResponseHeaders(302, -1);\n@@ -178,10 +212,1 @@\n-                \/\/ if the bug exsits, it'll send 2 GET commands\n-                \/\/ check 2nd GET here\n-                String duplicatedGet = trans.getRequestHeader(null);\n-                if (duplicatedGet != null &&\n-                    duplicatedGet.toUpperCase().indexOf(\"GET\") >= 0) {\n-                    trans.sendResponse(400, \"Bad Request\");\n-                    hasBadRequest = true;\n-                } else {\n-                    trans.sendResponse(200, \"OK\");\n-                }\n+                trans.sendResponseHeaders(200, -1);\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/https\/HttpsURLConnection\/B6216082.java","additions":63,"deletions":38,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,4 +28,20 @@\n-import java.net.*;\n-import java.io.*;\n-import java.nio.*;\n-import java.nio.channels.*;\n+import java.io.BufferedInputStream;\n+import java.io.BufferedOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.nio.BufferOverflowException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.SelectionKey;\n+import java.nio.channels.Selector;\n+import java.nio.channels.ServerSocketChannel;\n+import java.nio.channels.SocketChannel;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Set;\n+\n@@ -33,1 +49,0 @@\n-import java.util.*;\n@@ -46,1 +61,0 @@\n-     * @param cb the callback object which is invoked to handle each\n@@ -58,2 +72,0 @@\n-     * @param cb the callback object which is invoked to handle each\n-     *     incoming request\n@@ -77,2 +89,0 @@\n-     * @param cb the callback object which is invoked to handle\n-     *  each incoming request\n@@ -231,1 +241,0 @@\n-            HttpTransaction msg;\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/https\/HttpsURLConnection\/TunnelProxy.java","additions":21,"deletions":12,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -1,961 +0,0 @@\n-\/*\n- * Copyright (c) 2002, 2012, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.net.*;\n-import java.io.*;\n-import java.nio.*;\n-import java.nio.channels.*;\n-import sun.net.www.MessageHeader;\n-import java.util.*;\n-import javax.net.ssl.*;\n-import javax.net.ssl.SSLEngineResult.*;\n-import java.security.*;\n-\n-\/**\n- * This class implements a simple HTTPS server. It uses multiple threads to\n- * handle connections in parallel, and will spin off a new thread to handle\n- * each request. (this is easier to implement with SSLEngine)\n- * <p>\n- * It must be instantiated with a {@link HttpCallback} object to which\n- * requests are given and must be handled.\n- * <p>\n- * Simple synchronization between the client(s) and server can be done\n- * using the {@link #waitForCondition(String)}, {@link #setCondition(String)} and\n- * {@link #rendezvous(String,int)} methods.\n- *\n- * NOTE NOTE NOTE NOTE NOTE NOTE NOTE\n- *\n- * If you make a change in here, please don't forget to make the\n- * corresponding change in the J2SE equivalent.\n- *\n- * NOTE NOTE NOTE NOTE NOTE NOTE NOTE\n- *\/\n-\n-public class TestHttpsServer {\n-\n-    ServerSocketChannel schan;\n-    int threads;\n-    int cperthread;\n-    HttpCallback cb;\n-    Server[] servers;\n-\n-    \/\/ ssl related fields\n-    static SSLContext sslCtx;\n-\n-    \/**\n-     * Create a <code>TestHttpsServer<code> instance with the specified callback object\n-     * for handling requests. One thread is created to handle requests,\n-     * and up to ten TCP connections will be handled simultaneously.\n-     * @param cb the callback object which is invoked to handle each\n-     *  incoming request\n-     *\/\n-\n-    public TestHttpsServer (HttpCallback cb) throws IOException {\n-        this (cb, 1, 10, 0);\n-    }\n-\n-    \/**\n-     * Create a <code>TestHttpsServer<code> instance with the specified number of\n-     * threads and maximum number of connections per thread. This functions\n-     * the same as the 4 arg constructor, where the port argument is set to zero.\n-     * @param cb the callback object which is invoked to handle each\n-     *     incoming request\n-     * @param threads the number of threads to create to handle requests\n-     *     in parallel\n-     * @param cperthread the number of simultaneous TCP connections to\n-     *     handle per thread\n-     *\/\n-\n-    public TestHttpsServer (HttpCallback cb, int threads, int cperthread)\n-        throws IOException {\n-        this (cb, threads, cperthread, 0);\n-    }\n-\n-    \/**\n-     * Create a <code>TestHttpsServer<code> instance with the specified number\n-     * of threads and maximum number of connections per thread and running on\n-     * the specified port. The specified number of threads are created to\n-     * handle incoming requests, and each thread is allowed\n-     * to handle a number of simultaneous TCP connections.\n-     * @param cb the callback object which is invoked to handle\n-     *  each incoming request\n-     * @param threads the number of threads to create to handle\n-     *  requests in parallel\n-     * @param cperthread the number of simultaneous TCP connections\n-     *  to handle per thread\n-     * @param port the port number to bind the server to. <code>Zero<\/code>\n-     *  means choose any free port.\n-     *\/\n-\n-    public TestHttpsServer (HttpCallback cb, int threads, int cperthread, int port)\n-        throws IOException {\n-        schan = ServerSocketChannel.open ();\n-        InetSocketAddress addr = new InetSocketAddress (port);\n-        schan.socket().bind (addr);\n-        this.threads = threads;\n-        this.cb = cb;\n-        this.cperthread = cperthread;\n-\n-        try {\n-            \/\/ create and initialize a SSLContext\n-            KeyStore ks = KeyStore.getInstance(\"JKS\");\n-            KeyStore ts = KeyStore.getInstance(\"JKS\");\n-            char[] passphrase = \"passphrase\".toCharArray();\n-\n-            ks.load(new FileInputStream(System.getProperty(\"javax.net.ssl.keyStore\")), passphrase);\n-            ts.load(new FileInputStream(System.getProperty(\"javax.net.ssl.trustStore\")), passphrase);\n-\n-            KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"SunX509\");\n-            kmf.init(ks, passphrase);\n-\n-            TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n-            tmf.init(ts);\n-\n-            sslCtx = SSLContext.getInstance(\"TLS\");\n-\n-            sslCtx.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);\n-\n-            servers = new Server [threads];\n-            for (int i=0; i<threads; i++) {\n-                servers[i] = new Server (cb, schan, cperthread);\n-                servers[i].start();\n-            }\n-        } catch (Exception ex) {\n-            throw new RuntimeException(\"test failed. cause: \"+ex.getMessage());\n-        }\n-    }\n-\n-    \/** Tell all threads in the server to exit within 5 seconds.\n-     *  This is an abortive termination. Just prior to the thread exiting\n-     *  all channels in that thread waiting to be closed are forceably closed.\n-     *\/\n-\n-    public void terminate () {\n-        for (int i=0; i<threads; i++) {\n-            servers[i].terminate ();\n-        }\n-    }\n-\n-    \/**\n-     * return the local port number to which the server is bound.\n-     * @return the local port number\n-     *\/\n-\n-    public int getLocalPort () {\n-        return schan.socket().getLocalPort ();\n-    }\n-\n-    public String getAuthority() {\n-        InetAddress address = schan.socket().getInetAddress();\n-        String hostaddr = address.getHostAddress();\n-        if (address.isAnyLocalAddress()) hostaddr = \"localhost\";\n-        if (hostaddr.indexOf(':') > -1) hostaddr = \"[\" + hostaddr + \"]\";\n-        return hostaddr + \":\" + getLocalPort();\n-    }\n-\n-    static class Server extends Thread {\n-\n-        ServerSocketChannel schan;\n-        Selector selector;\n-        SelectionKey listenerKey;\n-        SelectionKey key; \/* the current key being processed *\/\n-        HttpCallback cb;\n-        ByteBuffer consumeBuffer;\n-        int maxconn;\n-        int nconn;\n-        ClosedChannelList clist;\n-        boolean shutdown;\n-\n-        Server (HttpCallback cb, ServerSocketChannel schan, int maxconn) {\n-            this.schan = schan;\n-            this.maxconn = maxconn;\n-            this.cb = cb;\n-            nconn = 0;\n-            consumeBuffer = ByteBuffer.allocate (512);\n-            clist = new ClosedChannelList ();\n-            try {\n-                selector = Selector.open ();\n-                schan.configureBlocking (false);\n-                listenerKey = schan.register (selector, SelectionKey.OP_ACCEPT);\n-            } catch (IOException e) {\n-                System.err.println (\"Server could not start: \" + e);\n-            }\n-        }\n-\n-        \/* Stop the thread as soon as possible *\/\n-        public synchronized void terminate () {\n-            shutdown = true;\n-        }\n-\n-        public void run ()  {\n-            try {\n-                while (true) {\n-                    selector.select (1000);\n-                    Set selected = selector.selectedKeys();\n-                    Iterator iter = selected.iterator();\n-                    while (iter.hasNext()) {\n-                        key = (SelectionKey)iter.next();\n-                        if (key.equals (listenerKey)) {\n-                            SocketChannel sock = schan.accept ();\n-                            if (sock == null) {\n-                                \/* false notification *\/\n-                                iter.remove();\n-                                continue;\n-                            }\n-                            sock.configureBlocking (true);\n-                            SSLEngine sslEng = sslCtx.createSSLEngine();\n-                            sslEng.setUseClientMode(false);\n-                            new ServerWorker(cb, sock, sslEng).start();\n-                            nconn ++;\n-                            if (nconn == maxconn) {\n-                                \/* deregister *\/\n-                                listenerKey.cancel ();\n-                                listenerKey = null;\n-                            }\n-                        } else {\n-                            if (key.isReadable()) {\n-                                boolean closed = false;\n-                                SocketChannel chan = (SocketChannel) key.channel();\n-                                if (key.attachment() != null) {\n-                                    closed = consume (chan);\n-                                }\n-\n-                                if (closed) {\n-                                    chan.close ();\n-                                    key.cancel ();\n-                                    if (nconn == maxconn) {\n-                                        listenerKey = schan.register (selector, SelectionKey.OP_ACCEPT);\n-                                    }\n-                                    nconn --;\n-                                }\n-                            }\n-                        }\n-                        iter.remove();\n-                    }\n-                    clist.check();\n-\n-                    synchronized (this) {\n-                        if (shutdown) {\n-                            clist.terminate ();\n-                            return;\n-                        }\n-                    }\n-                }\n-            } catch (IOException e) {\n-                System.out.println (\"Server exception: \" + e);\n-                \/\/ TODO finish\n-            }\n-        }\n-\n-        \/* read all the data off the channel without looking at it\n-             * return true if connection closed\n-             *\/\n-        boolean consume (SocketChannel chan) {\n-            try {\n-                consumeBuffer.clear ();\n-                int c = chan.read (consumeBuffer);\n-                if (c == -1)\n-                    return true;\n-            } catch (IOException e) {\n-                return true;\n-            }\n-            return false;\n-        }\n-    }\n-\n-    static class ServerWorker extends Thread {\n-        private ByteBuffer inNetBB;\n-        private ByteBuffer outNetBB;\n-        private ByteBuffer inAppBB;\n-        private ByteBuffer outAppBB;\n-\n-        SSLEngine sslEng;\n-        SocketChannel schan;\n-        HttpCallback cb;\n-        HandshakeStatus currentHSStatus;\n-        boolean initialHSComplete;\n-        boolean handshakeStarted;\n-        \/*\n-         * All inbound data goes through this buffer.\n-         *\n-         * It might be nice to use a cache of ByteBuffers so we're\n-         * not alloc\/dealloc'ing all over the place.\n-         *\/\n-\n-        \/*\n-         * Application buffers, also used for handshaking\n-         *\/\n-        private int appBBSize;\n-\n-        ServerWorker (HttpCallback cb, SocketChannel schan, SSLEngine sslEng) {\n-            this.sslEng = sslEng;\n-            this.schan = schan;\n-            this.cb = cb;\n-            currentHSStatus = HandshakeStatus.NEED_UNWRAP;\n-            initialHSComplete = false;\n-            int netBBSize = sslEng.getSession().getPacketBufferSize();\n-            inNetBB =  ByteBuffer.allocate(netBBSize);\n-            outNetBB = ByteBuffer.allocate(netBBSize);\n-            appBBSize = sslEng.getSession().getApplicationBufferSize();\n-            inAppBB = ByteBuffer.allocate(appBBSize);\n-            outAppBB = ByteBuffer.allocate(appBBSize);\n-        }\n-\n-        public SSLEngine getSSLEngine() {\n-            return sslEng;\n-        }\n-\n-        public ByteBuffer outNetBB() {\n-            return outNetBB;\n-        }\n-\n-        public ByteBuffer outAppBB() {\n-            return outAppBB;\n-        }\n-\n-        public void run () {\n-            try {\n-                SSLEngineResult result;\n-\n-                while (!initialHSComplete) {\n-\n-                    switch (currentHSStatus) {\n-\n-                    case NEED_UNWRAP:\n-                        int bytes = schan.read(inNetBB);\n-                        if (!handshakeStarted && bytes > 0) {\n-                            handshakeStarted = true;\n-                            int byte0 = inNetBB.get(0);\n-                            if (byte0 != 0x16) {\n-                                \/\/ first byte of a TLS connection is supposed to be\n-                                \/\/ 0x16. If not it may be a plain text connection.\n-                                \/\/\n-                                \/\/ Sometime a rogue client may try to open a plain\n-                                \/\/ connection with our server. Calling this method\n-                                \/\/ gives a chance to the test logic to ignore such\n-                                \/\/ rogue connections.\n-                                \/\/\n-                                if (cb.dropPlainTextConnections()) {\n-                                    try { schan.close(); } catch (IOException x) { };\n-                                    return;\n-                                }\n-                                \/\/ else sslEng.unwrap will throw later on...\n-                            }\n-                        }\n-\n-needIO:\n-                        while (currentHSStatus == HandshakeStatus.NEED_UNWRAP) {\n-                            \/*\n-                             * Don't need to resize requestBB, since no app data should\n-                             * be generated here.\n-                             *\/\n-                            inNetBB.flip();\n-                            result = sslEng.unwrap(inNetBB, inAppBB);\n-                            inNetBB.compact();\n-                            currentHSStatus = result.getHandshakeStatus();\n-\n-                            switch (result.getStatus()) {\n-\n-                            case OK:\n-                                switch (currentHSStatus) {\n-                                case NOT_HANDSHAKING:\n-                                    throw new IOException(\n-                                                          \"Not handshaking during initial handshake\");\n-\n-                                case NEED_TASK:\n-                                    Runnable task;\n-                                    while ((task = sslEng.getDelegatedTask()) != null) {\n-                                        task.run();\n-                                        currentHSStatus = sslEng.getHandshakeStatus();\n-                                    }\n-                                    break;\n-                                }\n-\n-                                break;\n-\n-                            case BUFFER_UNDERFLOW:\n-                                break needIO;\n-\n-                            default: \/\/ BUFFER_OVERFLOW\/CLOSED:\n-                                throw new IOException(\"Received\" + result.getStatus() +\n-                                                      \"during initial handshaking\");\n-                            }\n-                        }\n-\n-                        \/*\n-                         * Just transitioned from read to write.\n-                         *\/\n-                        if (currentHSStatus != HandshakeStatus.NEED_WRAP) {\n-                            break;\n-                        }\n-\n-                        \/\/ Fall through and fill the write buffer.\n-\n-                    case NEED_WRAP:\n-                        \/*\n-                         * The flush above guarantees the out buffer to be empty\n-                         *\/\n-                        outNetBB.clear();\n-                        result = sslEng.wrap(inAppBB, outNetBB);\n-                        outNetBB.flip();\n-                        schan.write (outNetBB);\n-                        outNetBB.compact();\n-                        currentHSStatus = result.getHandshakeStatus();\n-\n-                        switch (result.getStatus()) {\n-                        case OK:\n-\n-                            if (currentHSStatus == HandshakeStatus.NEED_TASK) {\n-                                Runnable task;\n-                                while ((task = sslEng.getDelegatedTask()) != null) {\n-                                    task.run();\n-                                    currentHSStatus = sslEng.getHandshakeStatus();\n-                                }\n-                            }\n-\n-                            break;\n-\n-                        default: \/\/ BUFFER_OVERFLOW\/BUFFER_UNDERFLOW\/CLOSED:\n-                            throw new IOException(\"Received\" + result.getStatus() +\n-                                                  \"during initial handshaking\");\n-                        }\n-                        break;\n-\n-                    case FINISHED:\n-                        initialHSComplete = true;\n-                        break;\n-                    default: \/\/ NOT_HANDSHAKING\/NEED_TASK\n-                        throw new RuntimeException(\"Invalid Handshaking State\" +\n-                                                   currentHSStatus);\n-                    } \/\/ switch\n-                }\n-                \/\/ read the application data; using non-blocking mode\n-                schan.configureBlocking(false);\n-                read(schan, sslEng);\n-            } catch (Exception ex) {\n-                throw new RuntimeException(ex);\n-            }\n-        }\n-\n-        \/* return true if the connection is closed, false otherwise *\/\n-\n-        private boolean read (SocketChannel chan, SSLEngine sslEng) {\n-            HttpTransaction msg;\n-            boolean res;\n-            try {\n-                InputStream is = new BufferedInputStream (new NioInputStream (chan, sslEng, inNetBB, inAppBB));\n-                String requestline = readLine (is);\n-                MessageHeader mhead = new MessageHeader (is);\n-                String clen = mhead.findValue (\"Content-Length\");\n-                String trferenc = mhead.findValue (\"Transfer-Encoding\");\n-                String data = null;\n-                if (trferenc != null && trferenc.equals (\"chunked\"))\n-                    data = new String (readChunkedData (is));\n-                else if (clen != null)\n-                    data = new String (readNormalData (is, Integer.parseInt (clen)));\n-                String[] req = requestline.split (\" \");\n-                if (req.length < 2) {\n-                    \/* invalid request line *\/\n-                    return false;\n-                }\n-                String cmd = req[0];\n-                URI uri = null;\n-                try {\n-                    uri = new URI (req[1]);\n-                    msg = new HttpTransaction (this, cmd, uri, mhead, data, null, chan);\n-                    cb.request (msg);\n-                } catch (URISyntaxException e) {\n-                    System.err.println (\"Invalid URI: \" + e);\n-                    msg = new HttpTransaction (this, cmd, null, null, null, null, chan);\n-                    msg.sendResponse (501, \"Whatever\");\n-                }\n-                res = false;\n-            } catch (IOException e) {\n-                res = true;\n-            }\n-            return res;\n-        }\n-\n-        byte[] readNormalData (InputStream is, int len) throws IOException {\n-            byte [] buf  = new byte [len];\n-            int c, off=0, remain=len;\n-            while (remain > 0 && ((c=is.read (buf, off, remain))>0)) {\n-                remain -= c;\n-                off += c;\n-            }\n-            return buf;\n-        }\n-\n-        private void readCRLF(InputStream is) throws IOException {\n-            int cr = is.read();\n-            int lf = is.read();\n-\n-            if (((cr & 0xff) != 0x0d) ||\n-                ((lf & 0xff) != 0x0a)) {\n-                throw new IOException(\n-                    \"Expected <CR><LF>:  got '\" + cr + \"\/\" + lf + \"'\");\n-            }\n-        }\n-\n-        byte[] readChunkedData (InputStream is) throws IOException {\n-            LinkedList l = new LinkedList ();\n-            int total = 0;\n-            for (int len=readChunkLen(is); len!=0; len=readChunkLen(is)) {\n-                l.add (readNormalData(is, len));\n-                total += len;\n-                readCRLF(is); \/\/ CRLF at end of chunk\n-            }\n-            readCRLF(is); \/\/ CRLF at end of Chunked Stream.\n-            byte[] buf = new byte [total];\n-            Iterator i = l.iterator();\n-            int x = 0;\n-            while (i.hasNext()) {\n-                byte[] b = (byte[])i.next();\n-                System.arraycopy (b, 0, buf, x, b.length);\n-                x += b.length;\n-            }\n-            return buf;\n-        }\n-\n-        private int readChunkLen (InputStream is) throws IOException {\n-            int c, len=0;\n-            boolean done=false, readCR=false;\n-            while (!done) {\n-                c = is.read ();\n-                if (c == '\\n' && readCR) {\n-                    done = true;\n-                } else {\n-                    if (c == '\\r' && !readCR) {\n-                        readCR = true;\n-                    } else {\n-                        int x=0;\n-                        if (c >= 'a' && c <= 'f') {\n-                            x = c - 'a' + 10;\n-                        } else if (c >= 'A' && c <= 'F') {\n-                            x = c - 'A' + 10;\n-                        } else if (c >= '0' && c <= '9') {\n-                            x = c - '0';\n-                        }\n-                        len = len * 16 + x;\n-                    }\n-                }\n-            }\n-            return len;\n-        }\n-\n-        private String readLine (InputStream is) throws IOException {\n-            boolean done=false, readCR=false;\n-            byte[] b = new byte [512];\n-            int c, l = 0;\n-\n-            while (!done) {\n-                c = is.read ();\n-                if (c == '\\n' && readCR) {\n-                    done = true;\n-                } else {\n-                    if (c == '\\r' && !readCR) {\n-                        readCR = true;\n-                    } else {\n-                        b[l++] = (byte)c;\n-                    }\n-                }\n-            }\n-            return new String (b);\n-        }\n-\n-        \/** close the channel associated with the current key by:\n-         * 1. shutdownOutput (send a FIN)\n-         * 2. mark the key so that incoming data is to be consumed and discarded\n-         * 3. After a period, close the socket\n-         *\/\n-\n-        synchronized void orderlyCloseChannel (SocketChannel ch) throws IOException {\n-            ch.socket().shutdownOutput();\n-        }\n-\n-        synchronized void abortiveCloseChannel (SocketChannel ch) throws IOException {\n-            Socket s = ch.socket ();\n-            s.setSoLinger (true, 0);\n-            ch.close();\n-        }\n-    }\n-\n-\n-    \/**\n-     * Implements blocking reading semantics on top of a non-blocking channel\n-     *\/\n-\n-    static class NioInputStream extends InputStream {\n-        SSLEngine sslEng;\n-        SocketChannel channel;\n-        Selector selector;\n-        ByteBuffer inNetBB;\n-        ByteBuffer inAppBB;\n-        SelectionKey key;\n-        int available;\n-        byte[] one;\n-        boolean closed;\n-        ByteBuffer markBuf; \/* reads may be satisifed from this buffer *\/\n-        boolean marked;\n-        boolean reset;\n-        int readlimit;\n-\n-        public NioInputStream (SocketChannel chan, SSLEngine sslEng, ByteBuffer inNetBB, ByteBuffer inAppBB) throws IOException {\n-            this.sslEng = sslEng;\n-            this.channel = chan;\n-            selector = Selector.open();\n-            this.inNetBB = inNetBB;\n-            this.inAppBB = inAppBB;\n-            key = chan.register (selector, SelectionKey.OP_READ);\n-            available = 0;\n-            one = new byte[1];\n-            closed = marked = reset = false;\n-        }\n-\n-        public synchronized int read (byte[] b) throws IOException {\n-            return read (b, 0, b.length);\n-        }\n-\n-        public synchronized int read () throws IOException {\n-            return read (one, 0, 1);\n-        }\n-\n-        public synchronized int read (byte[] b, int off, int srclen) throws IOException {\n-\n-            int canreturn, willreturn;\n-\n-            if (closed)\n-                return -1;\n-\n-            if (reset) { \/* satisfy from markBuf *\/\n-                canreturn = markBuf.remaining ();\n-                willreturn = canreturn>srclen ? srclen : canreturn;\n-                markBuf.get(b, off, willreturn);\n-                if (canreturn == willreturn) {\n-                    reset = false;\n-                }\n-            } else { \/* satisfy from channel *\/\n-                canreturn = available();\n-                if (canreturn == 0) {\n-                    block ();\n-                    canreturn = available();\n-                }\n-                willreturn = canreturn>srclen ? srclen : canreturn;\n-                inAppBB.get(b, off, willreturn);\n-                available -= willreturn;\n-\n-                if (marked) { \/* copy into markBuf *\/\n-                    try {\n-                        markBuf.put (b, off, willreturn);\n-                    } catch (BufferOverflowException e) {\n-                        marked = false;\n-                    }\n-                }\n-            }\n-            return willreturn;\n-        }\n-\n-        public synchronized int available () throws IOException {\n-            if (closed)\n-                throw new IOException (\"Stream is closed\");\n-\n-            if (reset)\n-                return markBuf.remaining();\n-\n-            if (available > 0)\n-                return available;\n-\n-            inAppBB.clear ();\n-            int bytes = channel.read (inNetBB);\n-\n-            int needed = sslEng.getSession().getApplicationBufferSize();\n-            if (needed > inAppBB.remaining()) {\n-                inAppBB = ByteBuffer.allocate(needed);\n-            }\n-            inNetBB.flip();\n-            SSLEngineResult result = sslEng.unwrap(inNetBB, inAppBB);\n-            inNetBB.compact();\n-            available = result.bytesProduced();\n-\n-            if (available > 0)\n-                inAppBB.flip();\n-            else if (available == -1)\n-                throw new IOException (\"Stream is closed\");\n-            return available;\n-        }\n-\n-        \/**\n-         * block() only called when available==0 and buf is empty\n-         *\/\n-        private synchronized void block () throws IOException {\n-            \/\/assert available == 0;\n-            int n = selector.select ();\n-            \/\/assert n == 1;\n-            selector.selectedKeys().clear();\n-            available ();\n-        }\n-\n-        public void close () throws IOException {\n-            if (closed)\n-                return;\n-            channel.close ();\n-            closed = true;\n-        }\n-\n-        public synchronized void mark (int readlimit) {\n-            if (closed)\n-                return;\n-            this.readlimit = readlimit;\n-            markBuf = ByteBuffer.allocate (readlimit);\n-            marked = true;\n-            reset = false;\n-        }\n-\n-        public synchronized void reset () throws IOException {\n-            if (closed )\n-                return;\n-            if (!marked)\n-                throw new IOException (\"Stream not marked\");\n-            marked = false;\n-            reset = true;\n-            markBuf.flip ();\n-        }\n-    }\n-\n-    static class NioOutputStream extends OutputStream {\n-        SSLEngine sslEng;\n-        SocketChannel channel;\n-        ByteBuffer outNetBB;\n-        ByteBuffer outAppBB;\n-        SelectionKey key;\n-        Selector selector;\n-        boolean closed;\n-        byte[] one;\n-\n-        public NioOutputStream (SocketChannel channel, SSLEngine sslEng, ByteBuffer outNetBB, ByteBuffer outAppBB) throws IOException {\n-            this.sslEng = sslEng;\n-            this.channel = channel;\n-            this.outNetBB = outNetBB;\n-            this.outAppBB = outAppBB;\n-            selector = Selector.open ();\n-            key = channel.register (selector, SelectionKey.OP_WRITE);\n-            closed = false;\n-            one = new byte [1];\n-        }\n-\n-        public synchronized void write (int b) throws IOException {\n-            one[0] = (byte)b;\n-            write (one, 0, 1);\n-        }\n-\n-        public synchronized void write (byte[] b) throws IOException {\n-            write (b, 0, b.length);\n-        }\n-\n-        public synchronized void write (byte[] b, int off, int len) throws IOException {\n-            if (closed)\n-                throw new IOException (\"stream is closed\");\n-\n-            outAppBB = ByteBuffer.allocate (len);\n-            outAppBB.put (b, off, len);\n-            outAppBB.flip ();\n-            int n;\n-            outNetBB.clear();\n-            int needed = sslEng.getSession().getPacketBufferSize();\n-            if (outNetBB.capacity() < needed) {\n-                outNetBB = ByteBuffer.allocate(needed);\n-            }\n-            SSLEngineResult ret = sslEng.wrap(outAppBB, outNetBB);\n-            outNetBB.flip();\n-            int newLen = ret.bytesProduced();\n-            while ((n = channel.write (outNetBB)) < newLen) {\n-                newLen -= n;\n-                if (newLen == 0)\n-                    return;\n-                selector.select ();\n-                selector.selectedKeys().clear ();\n-            }\n-        }\n-\n-        public void close () throws IOException {\n-            if (closed)\n-                return;\n-            channel.close ();\n-            closed = true;\n-        }\n-    }\n-\n-    \/**\n-     * Utilities for synchronization. A condition is\n-     * identified by a string name, and is initialized\n-     * upon first use (ie. setCondition() or waitForCondition()). Threads\n-     * are blocked until some thread calls (or has called) setCondition() for the same\n-     * condition.\n-     * <P>\n-     * A rendezvous built on a condition is also provided for synchronizing\n-     * N threads.\n-     *\/\n-\n-    private static HashMap conditions = new HashMap();\n-\n-    \/*\n-     * Modifiable boolean object\n-     *\/\n-    private static class BValue {\n-        boolean v;\n-    }\n-\n-    \/*\n-     * Modifiable int object\n-     *\/\n-    private static class IValue {\n-        int v;\n-        IValue (int i) {\n-            v =i;\n-        }\n-    }\n-\n-\n-    private static BValue getCond (String condition) {\n-        synchronized (conditions) {\n-            BValue cond = (BValue) conditions.get (condition);\n-            if (cond == null) {\n-                cond = new BValue();\n-                conditions.put (condition, cond);\n-            }\n-            return cond;\n-        }\n-    }\n-\n-    \/**\n-     * Set the condition to true. Any threads that are currently blocked\n-     * waiting on the condition, will be unblocked and allowed to continue.\n-     * Threads that subsequently call waitForCondition() will not block.\n-     * If the named condition did not exist prior to the call, then it is created\n-     * first.\n-     *\/\n-\n-    public static void setCondition (String condition) {\n-        BValue cond = getCond (condition);\n-        synchronized (cond) {\n-            if (cond.v) {\n-                return;\n-            }\n-            cond.v = true;\n-            cond.notifyAll();\n-        }\n-    }\n-\n-    \/**\n-     * If the named condition does not exist, then it is created and initialized\n-     * to false. If the condition exists or has just been created and its value\n-     * is false, then the thread blocks until another thread sets the condition.\n-     * If the condition exists and is already set to true, then this call returns\n-     * immediately without blocking.\n-     *\/\n-\n-    public static void waitForCondition (String condition) {\n-        BValue cond = getCond (condition);\n-        synchronized (cond) {\n-            if (!cond.v) {\n-                try {\n-                    cond.wait();\n-                } catch (InterruptedException e) {}\n-            }\n-        }\n-    }\n-\n-    \/* conditions must be locked when accessing this *\/\n-    static HashMap rv = new HashMap();\n-\n-    \/**\n-     * Force N threads to rendezvous (ie. wait for each other) before proceeding.\n-     * The first thread(s) to call are blocked until the last\n-     * thread makes the call. Then all threads continue.\n-     * <p>\n-     * All threads that call with the same condition name, must use the same value\n-     * for N (or the results may be not be as expected).\n-     * <P>\n-     * Obviously, if fewer than N threads make the rendezvous then the result\n-     * will be a hang.\n-     *\/\n-\n-    public static void rendezvous (String condition, int N) {\n-        BValue cond;\n-        IValue iv;\n-        String name = \"RV_\"+condition;\n-\n-        \/* get the condition *\/\n-\n-        synchronized (conditions) {\n-            cond = (BValue)conditions.get (name);\n-            if (cond == null) {\n-                \/* we are first caller *\/\n-                if (N < 2) {\n-                    throw new RuntimeException (\"rendezvous must be called with N >= 2\");\n-                }\n-                cond = new BValue ();\n-                conditions.put (name, cond);\n-                iv = new IValue (N-1);\n-                rv.put (name, iv);\n-            } else {\n-                \/* already initialised, just decrement the counter *\/\n-                iv = (IValue) rv.get (name);\n-                iv.v --;\n-            }\n-        }\n-\n-        if (iv.v > 0) {\n-            waitForCondition (name);\n-        } else {\n-            setCondition (name);\n-            synchronized (conditions) {\n-                clearCondition (name);\n-                rv.remove (name);\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * If the named condition exists and is set then remove it, so it can\n-     * be re-initialized and used again. If the condition does not exist, or\n-     * exists but is not set, then the call returns without doing anything.\n-     * Note, some higher level synchronization\n-     * may be needed between clear and the other operations.\n-     *\/\n-\n-    public static void clearCondition(String condition) {\n-        BValue cond;\n-        synchronized (conditions) {\n-            cond = (BValue) conditions.get (condition);\n-            if (cond == null) {\n-                return;\n-            }\n-            synchronized (cond) {\n-                if (cond.v) {\n-                    conditions.remove (condition);\n-                }\n-            }\n-        }\n-    }\n-}\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/https\/TestHttpsServer.java","additions":0,"deletions":961,"binary":false,"changes":961,"status":"deleted"}]}