{"files":[{"patch":"@@ -587,0 +587,4 @@\n+\/\/ Compute base + offset components of the memory address accessed by mach.\n+\/\/ Return a node representing the base address (or NULL if it cannot be found),\n+\/\/ and an offset (which may be a concrete value or a special signal value if the\n+\/\/ offset cannot be found, e.g. because it is not a compile-time constant).\n@@ -592,1 +596,1 @@\n-  if (base == NULL || base == NodeSentinel || offset < 0) {\n+  if (base == NULL || base == NodeSentinel) {\n@@ -599,0 +603,45 @@\n+\/\/ Whether the given offset is concrete (known at compile-time) and nonnegative.\n+static bool is_concrete(intptr_t offset) {\n+  \/\/ This test implies offset != Type::OffsetTop && offset != Type::OffsetBot.\n+  return offset >= 0;\n+}\n+\n+\/\/ Whether a phi node corresponds to an array allocation.\n+\/\/ This test is incomplete: in some edge cases, it might return false even\n+\/\/ though the node does correspond to an array allocation.\n+static bool is_array_allocation(const Node* phi) {\n+  precond(phi->is_Phi());\n+  \/\/ Check whether phi has a successor cast (CheckCastPP) to Java array pointer,\n+  \/\/ possibly below spill copies and other cast nodes. Limit the exploration to\n+  \/\/ a single path from the phi node consisting of these node types.\n+  const Node* current = phi;\n+  while (true) {\n+    const Node* next = nullptr;\n+    for (DUIterator_Fast imax, i = current->fast_outs(imax); i < imax; i++) {\n+      if (!current->fast_out(i)->isa_Mach()) {\n+        continue;\n+      }\n+      const MachNode* succ = current->fast_out(i)->as_Mach();\n+      if (succ->ideal_Opcode() == Op_CheckCastPP) {\n+        if (succ->get_ptr_type()->isa_aryptr()) {\n+          \/\/ Cast to Java array pointer: phi corresponds to an array allocation.\n+          return true;\n+        }\n+        \/\/ Other cast: record as candidate for further exploration.\n+        next = succ;\n+      } else if (succ->is_SpillCopy() && next == nullptr) {\n+        \/\/ Spill copy, and no better candidate found: record as candidate.\n+        next = succ;\n+      }\n+    }\n+    if (next == nullptr) {\n+      \/\/ No evidence found that phi corresponds to an array allocation, and no\n+      \/\/ candidates available to continue exploring.\n+      return false;\n+    }\n+    \/\/ Continue exploring from the best candidate found.\n+    current = next;\n+  }\n+  ShouldNotReachHere();\n+}\n+\n@@ -615,1 +664,1 @@\n-  if (base == NULL || !base->is_Mach()) {\n+  if (base == NULL || !base->is_Mach() || !is_concrete(offset)) {\n@@ -654,0 +703,6 @@\n+        if (!is_concrete(access_offset) && !is_array_allocation(mem)) {\n+          \/\/ The accessed address has a variable or unknown offset, but the\n+          \/\/ allocated object cannot be determined to be an array. Avoid eliding\n+          \/\/ in this case, to be on the safe side.\n+          continue;\n+        }\n@@ -660,1 +715,3 @@\n-        if (mem_obj == NULL) {\n+        if (mem_obj == NULL ||\n+            !is_concrete(access_offset) ||\n+            !is_concrete(mem_offset)) {\n","filename":"src\/hotspot\/share\/gc\/z\/c2\/zBarrierSetC2.cpp","additions":60,"deletions":3,"binary":false,"changes":63,"status":"modified"}]}