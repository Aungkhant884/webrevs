{"files":[{"patch":"@@ -31,0 +31,1 @@\n+#include \"opto\/machnode.hpp\"\n@@ -305,0 +306,6 @@\n+\n+#ifndef PRODUCT\n+  virtual void dump_barrier_data(const MachNode* mach, outputStream* st) const {\n+    st->print(\"%x\", mach->barrier_data());\n+  };\n+#endif\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/barrierSetC2.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -945,0 +945,23 @@\n+\n+#ifndef PRODUCT\n+void ZBarrierSetC2::dump_barrier_data(const MachNode* mach, outputStream* st) const {\n+  if ((mach->barrier_data() & ZBarrierStrong) != 0) {\n+    st->print(\"strong \");\n+  }\n+  if ((mach->barrier_data() & ZBarrierWeak) != 0) {\n+    st->print(\"weak \");\n+  }\n+  if ((mach->barrier_data() & ZBarrierPhantom) != 0) {\n+    st->print(\"phantom \");\n+  }\n+  if ((mach->barrier_data() & ZBarrierNoKeepalive) != 0) {\n+    st->print(\"nokeepalive \");\n+  }\n+  if ((mach->barrier_data() & ZBarrierNative) != 0) {\n+    st->print(\"native \");\n+  }\n+  if ((mach->barrier_data() & ZBarrierElided) != 0) {\n+    st->print(\"elided \");\n+  }\n+}\n+#endif \/\/ !PRODUCT\n","filename":"src\/hotspot\/share\/gc\/z\/c2\/zBarrierSetC2.cpp","additions":24,"deletions":1,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -145,0 +145,4 @@\n+\n+#ifndef PRODUCT\n+  virtual void dump_barrier_data(const MachNode* mach, outputStream* st) const;\n+#endif\n","filename":"src\/hotspot\/share\/gc\/z\/c2\/zBarrierSetC2.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,2 @@\n+#include \"gc\/shared\/barrierSet.hpp\"\n+#include \"gc\/shared\/c2\/barrierSetC2.hpp\"\n@@ -538,0 +540,5 @@\n+  if (barrier_data() != 0) {\n+    st->print(\" barrier(\");\n+    BarrierSet::barrier_set()->barrier_set_c2()->dump_barrier_data(this, st);\n+    st->print(\")\");\n+  }\n","filename":"src\/hotspot\/share\/opto\/machnode.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,359 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.gcbarriers;\n+\n+import compiler.lib.ir_framework.*;\n+import java.lang.invoke.VarHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+\/**\n+ * @test\n+ * @summary Test ZGC barrier elision by allocation and domination. The tests use\n+ *          volatile memory accesses and blackholes to prevent C2 from simply\n+ *          optimizing them away.\n+ * @library \/test\/lib \/\n+ * @requires vm.gc.Z & os.simpleArch == \"x64\"\n+ * @run driver compiler.gcbarriers.TestZGCBarrierElision\n+ *\/\n+\n+class Inner {}\n+\n+class Outer {\n+    volatile Inner field1;\n+    volatile Inner field2;\n+    Outer() {}\n+}\n+\n+public class TestZGCBarrierElision {\n+\n+    static Inner inner = new Inner();\n+    static Outer outer = new Outer();\n+    static Outer outer2 = new Outer();\n+    static Outer[] outerArray = new Outer[42];\n+\n+    static final VarHandle field1VarHandle;\n+    static final VarHandle field2VarHandle;\n+    static {\n+        MethodHandles.Lookup l = MethodHandles.lookup();\n+        try {\n+            field1VarHandle = l.findVarHandle(Outer.class, \"field1\", Inner.class);\n+            field2VarHandle = l.findVarHandle(Outer.class, \"field2\", Inner.class);\n+        } catch (Exception e) {\n+            throw new Error(e);\n+        }\n+    }\n+    static final VarHandle outerArrayVarHandle =\n+        MethodHandles.arrayElementVarHandle(Outer[].class);\n+\n+    static final String REMAINING = \"strong\";\n+    static final String ELIDED = \"elided\";\n+\n+    static void blackhole(Object o) {}\n+\n+    static void nonInlinedMethod() {}\n+\n+    public static void main(String[] args) {\n+        String className = TestZGCBarrierElision.class.getName();\n+        TestFramework.runWithFlags(\"-XX:+UseZGC\", \"-XX:+UnlockExperimentalVMOptions\",\n+                                   \"-XX:CompileCommand=blackhole,\"  + className + \"::blackhole\",\n+                                   \"-XX:CompileCommand=dontinline,\" + className + \"::nonInlinedMethod\",\n+                                   \"-XX:LoopMaxUnroll=0\");\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.Z_LOAD_P_WITH_BARRIER_FLAG, ELIDED, \"1\" }, phase = CompilePhase.FINAL_CODE)\n+    static void testAllocateThenLoad() {\n+        Outer o1 = new Outer();\n+        blackhole(o1);\n+        \/\/ This load is directly optimized away by C2.\n+        blackhole(o1.field1);\n+        blackhole(o1.field1);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.Z_STORE_P_WITH_BARRIER_FLAG, ELIDED, \"1\" }, phase = CompilePhase.FINAL_CODE)\n+    static void testAllocateThenStore(Inner i) {\n+        Outer o1 = new Outer();\n+        blackhole(o1);\n+        o1.field1 = i;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.Z_LOAD_P_WITH_BARRIER_FLAG, REMAINING, \"1\" }, phase = CompilePhase.FINAL_CODE)\n+    @IR(counts = { IRNode.Z_LOAD_P_WITH_BARRIER_FLAG, ELIDED, \"1\" }, phase = CompilePhase.FINAL_CODE)\n+    static void testLoadThenLoad(Outer o) {\n+        blackhole(o.field1);\n+        blackhole(o.field1);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.Z_STORE_P_WITH_BARRIER_FLAG, REMAINING, \"1\" }, phase = CompilePhase.FINAL_CODE)\n+    @IR(counts = { IRNode.Z_STORE_P_WITH_BARRIER_FLAG, ELIDED, \"1\" }, phase = CompilePhase.FINAL_CODE)\n+    static void testStoreThenStore(Outer o, Inner i) {\n+        o.field1 = i;\n+        o.field1 = i;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.Z_STORE_P_WITH_BARRIER_FLAG, REMAINING, \"1\" }, phase = CompilePhase.FINAL_CODE)\n+    @IR(counts = { IRNode.Z_LOAD_P_WITH_BARRIER_FLAG, ELIDED, \"1\" },  phase = CompilePhase.FINAL_CODE)\n+    static void testStoreThenLoad(Outer o, Inner i) {\n+        o.field1 = i;\n+        blackhole(o.field1);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.Z_STORE_P_WITH_BARRIER_FLAG, REMAINING, \"1\" }, phase = CompilePhase.FINAL_CODE)\n+    @IR(counts = { IRNode.Z_LOAD_P_WITH_BARRIER_FLAG, REMAINING, \"1\" },  phase = CompilePhase.FINAL_CODE)\n+    static void testLoadThenStore(Outer o, Inner i) {\n+        blackhole(o.field1);\n+        o.field1 = i;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.Z_LOAD_P_WITH_BARRIER_FLAG, REMAINING, \"2\" }, phase = CompilePhase.FINAL_CODE)\n+    static void testLoadThenLoadAnotherField(Outer o) {\n+        blackhole(o.field1);\n+        blackhole(o.field2);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.Z_LOAD_P_WITH_BARRIER_FLAG, REMAINING, \"2\" }, phase = CompilePhase.FINAL_CODE)\n+    static void testLoadThenLoadFromAnotherObject(Outer o1, Outer o2) {\n+        blackhole(o1.field1);\n+        blackhole(o2.field1);\n+    }\n+\n+    @Run(test = {\"testAllocateThenLoad\",\n+                 \"testAllocateThenStore\",\n+                 \"testLoadThenLoad\",\n+                 \"testStoreThenStore\",\n+                 \"testStoreThenLoad\",\n+                 \"testLoadThenStore\",\n+                 \"testLoadThenLoadAnotherField\",\n+                 \"testLoadThenLoadFromAnotherObject\"})\n+    void runBasicTests() {\n+        testAllocateThenLoad();\n+        testAllocateThenStore(inner);\n+        testLoadThenLoad(outer);\n+        testStoreThenStore(outer, inner);\n+        testStoreThenLoad(outer, inner);\n+        testLoadThenStore(outer, inner);\n+        testLoadThenLoadAnotherField(outer);\n+        testLoadThenLoadFromAnotherObject(outer, outer2);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.Z_STORE_P_WITH_BARRIER_FLAG, ELIDED, \"1\" }, phase = CompilePhase.FINAL_CODE)\n+    static void testAllocateArrayThenStoreAtKnownIndex(Outer o) {\n+        Outer[] a = new Outer[42];\n+        blackhole(a);\n+        outerArrayVarHandle.setVolatile(a, 0, o);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.Z_STORE_P_WITH_BARRIER_FLAG, ELIDED, \"1\" }, phase = CompilePhase.FINAL_CODE)\n+    static void testAllocateArrayThenStoreAtUnknownIndex(Outer o, int index) {\n+        Outer[] a = new Outer[42];\n+        blackhole(a);\n+        outerArrayVarHandle.setVolatile(a, index, o);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.Z_LOAD_P_WITH_BARRIER_FLAG, REMAINING, \"1\" }, phase = CompilePhase.FINAL_CODE)\n+    @IR(counts = { IRNode.Z_LOAD_P_WITH_BARRIER_FLAG, ELIDED, \"1\" }, phase = CompilePhase.FINAL_CODE)\n+    static void testArrayLoadThenLoad(Outer[] a) {\n+        blackhole(outerArrayVarHandle.getVolatile(a, 0));\n+        blackhole(outerArrayVarHandle.getVolatile(a, 0));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.Z_STORE_P_WITH_BARRIER_FLAG, REMAINING, \"1\" }, phase = CompilePhase.FINAL_CODE)\n+    @IR(counts = { IRNode.Z_STORE_P_WITH_BARRIER_FLAG, ELIDED, \"1\" }, phase = CompilePhase.FINAL_CODE)\n+    static void testArrayStoreThenStore(Outer[] a, Outer o) {\n+        outerArrayVarHandle.setVolatile(a, 0, o);\n+        outerArrayVarHandle.setVolatile(a, 0, o);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.Z_STORE_P_WITH_BARRIER_FLAG, REMAINING, \"1\" }, phase = CompilePhase.FINAL_CODE)\n+    @IR(counts = { IRNode.Z_LOAD_P_WITH_BARRIER_FLAG, ELIDED, \"1\" }, phase = CompilePhase.FINAL_CODE)\n+    static void testArrayStoreThenLoad(Outer[] a, Outer o) {\n+        outerArrayVarHandle.setVolatile(a, 0, o);\n+        blackhole(outerArrayVarHandle.getVolatile(a, 0));\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.Z_LOAD_P_WITH_BARRIER_FLAG, REMAINING, \"1\" }, phase = CompilePhase.FINAL_CODE)\n+    @IR(counts = { IRNode.Z_STORE_P_WITH_BARRIER_FLAG, REMAINING, \"1\" }, phase = CompilePhase.FINAL_CODE)\n+    static void testArrayLoadThenStore(Outer[] a, Outer o) {\n+        blackhole(outerArrayVarHandle.getVolatile(a, 0));\n+        outerArrayVarHandle.setVolatile(a, 0, o);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.Z_LOAD_P_WITH_BARRIER_FLAG, REMAINING, \"2\" }, phase = CompilePhase.FINAL_CODE)\n+    static void testArrayLoadThenLoadAnotherElement(Outer[] a) {\n+        blackhole(outerArrayVarHandle.getVolatile(a, 0));\n+        blackhole(outerArrayVarHandle.getVolatile(a, 10));\n+    }\n+\n+    @Run(test = {\"testAllocateArrayThenStoreAtKnownIndex\",\n+                 \"testAllocateArrayThenStoreAtUnknownIndex\",\n+                 \"testArrayLoadThenLoad\",\n+                 \"testArrayStoreThenStore\",\n+                 \"testArrayStoreThenLoad\",\n+                 \"testArrayLoadThenStore\",\n+                 \"testArrayLoadThenLoadAnotherElement\"})\n+    void runArrayTests() {\n+        testAllocateArrayThenStoreAtKnownIndex(outer);\n+        testAllocateArrayThenStoreAtUnknownIndex(outer, 10);\n+        testArrayLoadThenLoad(outerArray);\n+        testArrayStoreThenStore(outerArray, outer);\n+        testArrayStoreThenLoad(outerArray, outer);\n+        testArrayLoadThenStore(outerArray, outer);\n+        testArrayLoadThenLoadAnotherElement(outerArray);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.Z_STORE_P_WITH_BARRIER_FLAG, REMAINING, \"1\" }, phase = CompilePhase.FINAL_CODE)\n+    @IR(counts = { IRNode.Z_STORE_P_WITH_BARRIER_FLAG, ELIDED, \"1\" }, phase = CompilePhase.FINAL_CODE)\n+    static void testStoreThenConditionalStore(Outer o, Inner i, int value) {\n+        o.field1 = i;\n+        if (value % 2 == 0) {\n+            o.field1 = i;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.Z_STORE_P_WITH_BARRIER_FLAG, REMAINING, \"2\" }, phase = CompilePhase.FINAL_CODE)\n+    static void testConditionalStoreThenStore(Outer o, Inner i, int value) {\n+        if (value % 2 == 0) {\n+            o.field1 = i;\n+        }\n+        o.field1 = i;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.Z_STORE_P_WITH_BARRIER_FLAG, REMAINING, \"1\" }, phase = CompilePhase.FINAL_CODE)\n+    @IR(counts = { IRNode.Z_STORE_P_WITH_BARRIER_FLAG, ELIDED, \"1\" }, phase = CompilePhase.FINAL_CODE)\n+    static void testStoreThenStoreInLoop(Outer o, Inner i) {\n+        o.field1 = i;\n+        for (int j = 0; j < 100; j++) {\n+            o.field1 = i;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.Z_STORE_P_WITH_BARRIER_FLAG, REMAINING, \"2\" }, phase = CompilePhase.FINAL_CODE)\n+    static void testStoreThenCallThenStore(Outer o, Inner i) {\n+        o.field1 = i;\n+        nonInlinedMethod();\n+        o.field1 = i;\n+    }\n+\n+    @Run(test = {\"testStoreThenConditionalStore\",\n+                 \"testConditionalStoreThenStore\",\n+                 \"testStoreThenStoreInLoop\",\n+                 \"testStoreThenCallThenStore\"})\n+    void runControlFlowTests() {\n+        testStoreThenConditionalStore(outer, inner, ThreadLocalRandom.current().nextInt(0, 100));\n+        testConditionalStoreThenStore(outer, inner, ThreadLocalRandom.current().nextInt(0, 100));\n+        testStoreThenStoreInLoop(outer, inner);\n+        testStoreThenCallThenStore(outer, inner);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.Z_GET_AND_SET_P_WITH_BARRIER_FLAG, REMAINING, \"1\" }, phase = CompilePhase.FINAL_CODE)\n+    static void testAllocateThenAtomic(Inner i) {\n+        Outer o = new Outer();\n+        blackhole(o);\n+        field1VarHandle.getAndSet​(o, i);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.Z_LOAD_P_WITH_BARRIER_FLAG, REMAINING, \"1\" }, phase = CompilePhase.FINAL_CODE)\n+    @IR(counts = { IRNode.Z_GET_AND_SET_P_WITH_BARRIER_FLAG, REMAINING, \"1\" }, phase = CompilePhase.FINAL_CODE)\n+    static void testLoadThenAtomic(Outer o, Inner i) {\n+        blackhole(o.field1);\n+        field1VarHandle.getAndSet​(o, i);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.Z_STORE_P_WITH_BARRIER_FLAG, REMAINING, \"1\" }, phase = CompilePhase.FINAL_CODE)\n+    \/\/ The atomic access barrier should be elided, but is not.\n+    static void testStoreThenAtomic(Outer o, Inner i) {\n+        o.field1 = i;\n+        field1VarHandle.getAndSet​(o, i);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.Z_GET_AND_SET_P_WITH_BARRIER_FLAG, REMAINING, \"1\" }, phase = CompilePhase.FINAL_CODE)\n+    \/\/ The load barrier should be elided, but is not.\n+    static void testAtomicThenLoad(Outer o, Inner i) {\n+        field1VarHandle.getAndSet​(o, i);\n+        blackhole(o.field1);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.Z_GET_AND_SET_P_WITH_BARRIER_FLAG, REMAINING, \"1\" }, phase = CompilePhase.FINAL_CODE)\n+    \/\/ The store barrier should be elided, but is not.\n+    static void testAtomicThenStore(Outer o, Inner i) {\n+        field1VarHandle.getAndSet​(o, i);\n+        o.field1 = i;\n+    }\n+\n+    @Test\n+    \/\/ The second atomic access barrier should be elided, but is not.\n+    static void testAtomicThenAtomic(Outer o, Inner i) {\n+        field1VarHandle.getAndSet​(o, i);\n+        field1VarHandle.getAndSet​(o, i);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.Z_GET_AND_SET_P_WITH_BARRIER_FLAG, REMAINING, \"2\" }, phase = CompilePhase.FINAL_CODE)\n+    static void testAtomicThenAtomicAnotherField(Outer o, Inner i) {\n+        field1VarHandle.getAndSet​(o, i);\n+        field2VarHandle.getAndSet​(o, i);\n+    }\n+\n+    @Run(test = {\"testAllocateThenAtomic\",\n+                 \"testLoadThenAtomic\",\n+                 \"testStoreThenAtomic\",\n+                 \"testAtomicThenLoad\",\n+                 \"testAtomicThenStore\",\n+                 \"testAtomicThenAtomic\",\n+                 \"testAtomicThenAtomicAnotherField\"})\n+    void runAtomicOperationTests() {\n+            testAllocateThenAtomic(inner);\n+            testLoadThenAtomic(outer, inner);\n+            testStoreThenAtomic(outer, inner);\n+            testAtomicThenLoad(outer, inner);\n+            testAtomicThenStore(outer, inner);\n+            testAtomicThenAtomic(outer, inner);\n+            testAtomicThenAtomicAnotherField(outer, inner);\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/gcbarriers\/TestZGCBarrierElision.java","additions":359,"deletions":0,"binary":false,"changes":359,"status":"added"},{"patch":"@@ -1346,0 +1346,18 @@\n+    public static final String Z_LOAD_P_WITH_BARRIER_FLAG = COMPOSITE_PREFIX + \"Z_LOAD_P_WITH_BARRIER_FLAG\" + POSTFIX;\n+    static {\n+        String regex = START + \"zLoadP\\\\S*\" + MID + \"barrier\\\\(\\\\s*\" + IS_REPLACED + \"\\\\s*\\\\)\" + END;\n+        machOnly(Z_LOAD_P_WITH_BARRIER_FLAG, regex);\n+    }\n+\n+    public static final String Z_STORE_P_WITH_BARRIER_FLAG = COMPOSITE_PREFIX + \"Z_STORE_P_WITH_BARRIER_FLAG\" + POSTFIX;\n+    static {\n+        String regex = START + \"zStoreP\\\\S*\" + MID + \"barrier\\\\(\\\\s*\" + IS_REPLACED + \"\\\\s*\\\\)\" + END;\n+        machOnly(Z_STORE_P_WITH_BARRIER_FLAG, regex);\n+    }\n+\n+    public static final String Z_GET_AND_SET_P_WITH_BARRIER_FLAG = COMPOSITE_PREFIX + \"Z_GET_AND_SET_P_WITH_BARRIER_FLAG\" + POSTFIX;\n+    static {\n+        String regex = START + \"(zXChgP)|(zGetAndSetP\\\\S*)\" + MID + \"barrier\\\\(\\\\s*\" + IS_REPLACED + \"\\\\s*\\\\)\" + END;\n+        machOnly(Z_GET_AND_SET_P_WITH_BARRIER_FLAG, regex);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"}]}