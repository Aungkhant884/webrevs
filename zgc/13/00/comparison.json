{"files":[{"patch":"@@ -609,1 +609,1 @@\n-  const Node* const base = mach->get_base_and_disp(offset, adr_type);\n+  const Node* base = mach->get_base_and_disp(offset, adr_type);\n@@ -611,2 +611,16 @@\n-  if (base == NULL || base == NodeSentinel ||\n-      is_undefined(offset) || (is_concrete(offset) && offset < 0)) {\n+  if (base == NULL || base == NodeSentinel) {\n+    return NULL;\n+  }\n+\n+  if (offset == 0 && base->is_Mach() && base->as_Mach()->ideal_Opcode() == Op_AddP) {\n+    \/\/ The memory address is computed by 'base' and fed to 'mach' via an\n+    \/\/ indirect memory operand (indicated by offset == 0). The ultimate base and\n+    \/\/ offset can be fetched directly from the inputs and Ideal type of 'base'.\n+    offset = base->bottom_type()->isa_oopptr()->offset();\n+    \/\/ Even if 'base' is not an Ideal AddP node anymore, Matcher::ReduceInst()\n+    \/\/ guarantees that the base address is still available at the same slot.\n+    base = base->in(AddPNode::Base);\n+    assert(base != NULL, \"\");\n+  }\n+\n+  if (is_undefined(offset) || (is_concrete(offset) && offset < 0)) {\n","filename":"src\/hotspot\/share\/gc\/z\/c2\/zBarrierSetC2.cpp","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n- * @requires vm.gc.Z & os.simpleArch == \"x64\"\n+ * @requires vm.gc.Z & (vm.simpleArch == \"x64\" | vm.simpleArch == \"aarch64\")\n@@ -306,1 +306,1 @@\n-    \/\/ The atomic access barrier should be elided, but is not.\n+    @IR(counts = { IRNode.Z_GET_AND_SET_P_WITH_BARRIER_FLAG, ELIDED, \"1\" }, phase = CompilePhase.FINAL_CODE)\n@@ -314,1 +314,1 @@\n-    \/\/ The load barrier should be elided, but is not.\n+    @IR(counts = { IRNode.Z_LOAD_P_WITH_BARRIER_FLAG, ELIDED, \"1\" }, phase = CompilePhase.FINAL_CODE)\n@@ -322,1 +322,1 @@\n-    \/\/ The store barrier should be elided, but is not.\n+    @IR(counts = { IRNode.Z_STORE_P_WITH_BARRIER_FLAG, ELIDED, \"1\" }, phase = CompilePhase.FINAL_CODE)\n@@ -329,1 +329,2 @@\n-    \/\/ The second atomic access barrier should be elided, but is not.\n+    @IR(counts = { IRNode.Z_GET_AND_SET_P_WITH_BARRIER_FLAG, REMAINING, \"1\" }, phase = CompilePhase.FINAL_CODE)\n+    @IR(counts = { IRNode.Z_GET_AND_SET_P_WITH_BARRIER_FLAG, ELIDED, \"1\" }, phase = CompilePhase.FINAL_CODE)\n@@ -342,0 +343,31 @@\n+    @Test\n+    @IR(counts = { IRNode.Z_GET_AND_SET_P_WITH_BARRIER_FLAG, REMAINING, \"1\" }, phase = CompilePhase.FINAL_CODE)\n+    static void testAllocateArrayThenAtomicAtKnownIndex(Outer o) {\n+        Outer[] a = new Outer[42];\n+        blackhole(a);\n+        outerArrayVarHandle.getAndSet(a, 2, o);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.Z_GET_AND_SET_P_WITH_BARRIER_FLAG, REMAINING, \"1\" }, phase = CompilePhase.FINAL_CODE)\n+    static void testAllocateArrayThenAtomicAtUnknownIndex(Outer o, int index) {\n+        Outer[] a = new Outer[42];\n+        blackhole(a);\n+        outerArrayVarHandle.getAndSet(a, index, o);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.Z_GET_AND_SET_P_WITH_BARRIER_FLAG, REMAINING, \"1\" }, phase = CompilePhase.FINAL_CODE)\n+    @IR(counts = { IRNode.Z_GET_AND_SET_P_WITH_BARRIER_FLAG, ELIDED, \"1\" }, phase = CompilePhase.FINAL_CODE)\n+    static void testArrayAtomicThenAtomic(Outer[] a, Outer o) {\n+        outerArrayVarHandle.getAndSet(a, 0, o);\n+        outerArrayVarHandle.getAndSet(a, 0, o);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.Z_GET_AND_SET_P_WITH_BARRIER_FLAG, REMAINING, \"2\" }, phase = CompilePhase.FINAL_CODE)\n+    static void testArrayAtomicThenAtomicAtUnknownIndices(Outer[] a, Outer o, int index1, int index2) {\n+        outerArrayVarHandle.getAndSet(a, index1, o);\n+        outerArrayVarHandle.getAndSet(a, index2, o);\n+    }\n+\n@@ -348,1 +380,5 @@\n-                 \"testAtomicThenAtomicAnotherField\"})\n+                 \"testAtomicThenAtomicAnotherField\",\n+                 \"testAllocateArrayThenAtomicAtKnownIndex\",\n+                 \"testAllocateArrayThenAtomicAtUnknownIndex\",\n+                 \"testArrayAtomicThenAtomic\",\n+                 \"testArrayAtomicThenAtomicAtUnknownIndices\"})\n@@ -350,7 +386,11 @@\n-            testAllocateThenAtomic(inner);\n-            testLoadThenAtomic(outer, inner);\n-            testStoreThenAtomic(outer, inner);\n-            testAtomicThenLoad(outer, inner);\n-            testAtomicThenStore(outer, inner);\n-            testAtomicThenAtomic(outer, inner);\n-            testAtomicThenAtomicAnotherField(outer, inner);\n+        testAllocateThenAtomic(inner);\n+        testLoadThenAtomic(outer, inner);\n+        testStoreThenAtomic(outer, inner);\n+        testAtomicThenLoad(outer, inner);\n+        testAtomicThenStore(outer, inner);\n+        testAtomicThenAtomic(outer, inner);\n+        testAtomicThenAtomicAnotherField(outer, inner);\n+        testAllocateArrayThenAtomicAtKnownIndex(outer);\n+        testAllocateArrayThenAtomicAtUnknownIndex(outer, 10);\n+        testArrayAtomicThenAtomic(outerArray, outer);\n+        testArrayAtomicThenAtomicAtUnknownIndices(outerArray, outer, 10, 20);\n@@ -358,1 +398,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/gcbarriers\/TestZGCBarrierElision.java","additions":53,"deletions":14,"binary":false,"changes":67,"status":"modified"}]}