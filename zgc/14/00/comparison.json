{"files":[{"patch":"@@ -33,3 +33,12 @@\n- * @summary Test ZGC barrier elision by allocation and domination. The tests use\n- *          volatile memory accesses and blackholes to prevent C2 from simply\n- *          optimizing them away.\n+ * @summary Test that the ZGC barrier elision optimization does not elide\n+ *          necessary barriers. The tests use volatile memory accesses and\n+ *          blackholes to prevent C2 from simply optimizing them away.\n+ * @library \/test\/lib \/\n+ * @requires vm.gc.Z\n+ * @run driver compiler.gcbarriers.TestZGCBarrierElision test-correctness\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary Test that the ZGC barrier elision optimization elides unnecessary\n+ *          barriers following simple allocation and domination rules.\n@@ -38,1 +47,1 @@\n- * @run driver compiler.gcbarriers.TestZGCBarrierElision\n+ * @run driver compiler.gcbarriers.TestZGCBarrierElision test-effectiveness\n@@ -49,1 +58,1 @@\n-public class TestZGCBarrierElision {\n+class Common {\n@@ -74,1 +83,0 @@\n-\n@@ -76,0 +84,3 @@\n+}\n+\n+public class TestZGCBarrierElision {\n@@ -78,5 +89,159 @@\n-        String className = TestZGCBarrierElision.class.getName();\n-        TestFramework.runWithFlags(\"-XX:+UseZGC\", \"-XX:+UnlockExperimentalVMOptions\",\n-                                   \"-XX:CompileCommand=blackhole,\"  + className + \"::blackhole\",\n-                                   \"-XX:CompileCommand=dontinline,\" + className + \"::nonInlinedMethod\",\n-                                   \"-XX:LoopMaxUnroll=0\");\n+        if (args.length != 1) {\n+            throw new IllegalArgumentException();\n+        }\n+        Class testClass;\n+        if (args[0].equals(\"test-correctness\")) {\n+            testClass = TestZGCCorrectBarrierElision.class;\n+        } else if (args[0].equals(\"test-effectiveness\")) {\n+            testClass = TestZGCEffectiveBarrierElision.class;\n+        } else {\n+            throw new IllegalArgumentException();\n+        }\n+        String commonName = Common.class.getName();\n+        TestFramework test = new TestFramework(testClass);\n+        test.addFlags(\"-XX:+UseZGC\", \"-XX:+UnlockExperimentalVMOptions\",\n+                      \"-XX:CompileCommand=blackhole,\" + commonName + \"::blackhole\",\n+                      \"-XX:CompileCommand=dontinline,\" + commonName + \"::nonInlinedMethod\",\n+                      \"-XX:LoopMaxUnroll=0\");\n+        test.start();\n+    }\n+}\n+\n+class TestZGCCorrectBarrierElision {\n+\n+    @Test\n+    @IR(counts = { IRNode.Z_STORE_P_WITH_BARRIER_FLAG, Common.REMAINING, \"1\" }, phase = CompilePhase.FINAL_CODE)\n+    @IR(counts = { IRNode.Z_LOAD_P_WITH_BARRIER_FLAG, Common.REMAINING, \"1\" },  phase = CompilePhase.FINAL_CODE)\n+    static void testLoadThenStore(Outer o, Inner i) {\n+        Common.blackhole(o.field1);\n+        o.field1 = i;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.Z_LOAD_P_WITH_BARRIER_FLAG, Common.REMAINING, \"2\" }, phase = CompilePhase.FINAL_CODE)\n+    static void testLoadThenLoadAnotherField(Outer o) {\n+        Common.blackhole(o.field1);\n+        Common.blackhole(o.field2);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.Z_LOAD_P_WITH_BARRIER_FLAG, Common.REMAINING, \"2\" }, phase = CompilePhase.FINAL_CODE)\n+    static void testLoadThenLoadFromAnotherObject(Outer o1, Outer o2) {\n+        Common.blackhole(o1.field1);\n+        Common.blackhole(o2.field1);\n+    }\n+\n+    @Run(test = {\"testLoadThenStore\",\n+                 \"testLoadThenLoadAnotherField\",\n+                 \"testLoadThenLoadFromAnotherObject\"})\n+    void runBasicTests() {\n+        testLoadThenStore(Common.outer, Common.inner);\n+        testLoadThenLoadAnotherField(Common.outer);\n+        testLoadThenLoadFromAnotherObject(Common.outer, Common.outer2);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.Z_LOAD_P_WITH_BARRIER_FLAG, Common.REMAINING, \"1\" }, phase = CompilePhase.FINAL_CODE)\n+    @IR(counts = { IRNode.Z_STORE_P_WITH_BARRIER_FLAG, Common.REMAINING, \"1\" }, phase = CompilePhase.FINAL_CODE)\n+    static void testArrayLoadThenStore(Outer[] a, Outer o) {\n+        Common.blackhole(Common.outerArrayVarHandle.getVolatile(a, 0));\n+        Common.outerArrayVarHandle.setVolatile(a, 0, o);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.Z_LOAD_P_WITH_BARRIER_FLAG, Common.REMAINING, \"2\" }, phase = CompilePhase.FINAL_CODE)\n+    static void testArrayLoadThenLoadAnotherElement(Outer[] a) {\n+        Common.blackhole(Common.outerArrayVarHandle.getVolatile(a, 0));\n+        Common.blackhole(Common.outerArrayVarHandle.getVolatile(a, 10));\n+    }\n+\n+    @Run(test = {\"testArrayLoadThenStore\",\n+                 \"testArrayLoadThenLoadAnotherElement\"})\n+    void runArrayTests() {\n+        testArrayLoadThenStore(Common.outerArray, Common.outer);\n+        testArrayLoadThenLoadAnotherElement(Common.outerArray);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.Z_STORE_P_WITH_BARRIER_FLAG, Common.REMAINING, \"2\" }, phase = CompilePhase.FINAL_CODE)\n+    static void testConditionalStoreThenStore(Outer o, Inner i, int value) {\n+        if (value % 2 == 0) {\n+            o.field1 = i;\n+        }\n+        o.field1 = i;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.Z_STORE_P_WITH_BARRIER_FLAG, Common.REMAINING, \"2\" }, phase = CompilePhase.FINAL_CODE)\n+    static void testStoreThenCallThenStore(Outer o, Inner i) {\n+        o.field1 = i;\n+        Common.nonInlinedMethod();\n+        o.field1 = i;\n+    }\n+\n+    @Run(test = {\"testConditionalStoreThenStore\",\n+                 \"testStoreThenCallThenStore\"})\n+    void runControlFlowTests() {\n+        testConditionalStoreThenStore(Common.outer, Common.inner, ThreadLocalRandom.current().nextInt(0, 100));\n+        testStoreThenCallThenStore(Common.outer, Common.inner);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.Z_GET_AND_SET_P_WITH_BARRIER_FLAG, Common.REMAINING, \"1\" }, phase = CompilePhase.FINAL_CODE)\n+    static void testAllocateThenAtomic(Inner i) {\n+        Outer o = new Outer();\n+        Common.blackhole(o);\n+        Common.field1VarHandle.getAndSet​(o, i);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.Z_LOAD_P_WITH_BARRIER_FLAG, Common.REMAINING, \"1\" }, phase = CompilePhase.FINAL_CODE)\n+    @IR(counts = { IRNode.Z_GET_AND_SET_P_WITH_BARRIER_FLAG, Common.REMAINING, \"1\" }, phase = CompilePhase.FINAL_CODE)\n+    static void testLoadThenAtomic(Outer o, Inner i) {\n+        Common.blackhole(o.field1);\n+        Common.field1VarHandle.getAndSet​(o, i);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.Z_GET_AND_SET_P_WITH_BARRIER_FLAG, Common.REMAINING, \"2\" }, phase = CompilePhase.FINAL_CODE)\n+    static void testAtomicThenAtomicAnotherField(Outer o, Inner i) {\n+        Common.field1VarHandle.getAndSet​(o, i);\n+        Common.field2VarHandle.getAndSet​(o, i);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.Z_GET_AND_SET_P_WITH_BARRIER_FLAG, Common.REMAINING, \"1\" }, phase = CompilePhase.FINAL_CODE)\n+    static void testAllocateArrayThenAtomicAtKnownIndex(Outer o) {\n+        Outer[] a = new Outer[42];\n+        Common.blackhole(a);\n+        Common.outerArrayVarHandle.getAndSet(a, 2, o);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.Z_GET_AND_SET_P_WITH_BARRIER_FLAG, Common.REMAINING, \"1\" }, phase = CompilePhase.FINAL_CODE)\n+    static void testAllocateArrayThenAtomicAtUnknownIndex(Outer o, int index) {\n+        Outer[] a = new Outer[42];\n+        Common.blackhole(a);\n+        Common.outerArrayVarHandle.getAndSet(a, index, o);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.Z_GET_AND_SET_P_WITH_BARRIER_FLAG, Common.REMAINING, \"2\" }, phase = CompilePhase.FINAL_CODE)\n+    static void testArrayAtomicThenAtomicAtUnknownIndices(Outer[] a, Outer o, int index1, int index2) {\n+        Common.outerArrayVarHandle.getAndSet(a, index1, o);\n+        Common.outerArrayVarHandle.getAndSet(a, index2, o);\n+    }\n+\n+    @Run(test = {\"testAllocateThenAtomic\",\n+                 \"testLoadThenAtomic\",\n+                 \"testAtomicThenAtomicAnotherField\",\n+                 \"testAllocateArrayThenAtomicAtKnownIndex\",\n+                 \"testAllocateArrayThenAtomicAtUnknownIndex\",\n+                 \"testArrayAtomicThenAtomicAtUnknownIndices\"})\n+    void runAtomicOperationTests() {\n+        testAllocateThenAtomic(Common.inner);\n+        testLoadThenAtomic(Common.outer, Common.inner);\n+        testAtomicThenAtomicAnotherField(Common.outer, Common.inner);\n+        testAllocateArrayThenAtomicAtKnownIndex(Common.outer);\n+        testAllocateArrayThenAtomicAtUnknownIndex(Common.outer, 10);\n+        testArrayAtomicThenAtomicAtUnknownIndices(Common.outerArray, Common.outer, 10, 20);\n@@ -84,0 +249,3 @@\n+}\n+\n+class TestZGCEffectiveBarrierElision {\n@@ -86,1 +254,1 @@\n-    @IR(counts = { IRNode.Z_LOAD_P_WITH_BARRIER_FLAG, ELIDED, \"1\" }, phase = CompilePhase.FINAL_CODE)\n+    @IR(counts = { IRNode.Z_LOAD_P_WITH_BARRIER_FLAG, Common.ELIDED, \"1\" }, phase = CompilePhase.FINAL_CODE)\n@@ -89,1 +257,1 @@\n-        blackhole(o1);\n+        Common.blackhole(o1);\n@@ -91,2 +259,2 @@\n-        blackhole(o1.field1);\n-        blackhole(o1.field1);\n+        Common.blackhole(o1.field1);\n+        Common.blackhole(o1.field1);\n@@ -96,1 +264,1 @@\n-    @IR(counts = { IRNode.Z_STORE_P_WITH_BARRIER_FLAG, ELIDED, \"1\" }, phase = CompilePhase.FINAL_CODE)\n+    @IR(counts = { IRNode.Z_STORE_P_WITH_BARRIER_FLAG, Common.ELIDED, \"1\" }, phase = CompilePhase.FINAL_CODE)\n@@ -99,1 +267,1 @@\n-        blackhole(o1);\n+        Common.blackhole(o1);\n@@ -104,2 +272,2 @@\n-    @IR(counts = { IRNode.Z_LOAD_P_WITH_BARRIER_FLAG, REMAINING, \"1\" }, phase = CompilePhase.FINAL_CODE)\n-    @IR(counts = { IRNode.Z_LOAD_P_WITH_BARRIER_FLAG, ELIDED, \"1\" }, phase = CompilePhase.FINAL_CODE)\n+    @IR(counts = { IRNode.Z_LOAD_P_WITH_BARRIER_FLAG, Common.REMAINING, \"1\" }, phase = CompilePhase.FINAL_CODE)\n+    @IR(counts = { IRNode.Z_LOAD_P_WITH_BARRIER_FLAG, Common.ELIDED, \"1\" }, phase = CompilePhase.FINAL_CODE)\n@@ -107,2 +275,2 @@\n-        blackhole(o.field1);\n-        blackhole(o.field1);\n+        Common.blackhole(o.field1);\n+        Common.blackhole(o.field1);\n@@ -112,2 +280,2 @@\n-    @IR(counts = { IRNode.Z_STORE_P_WITH_BARRIER_FLAG, REMAINING, \"1\" }, phase = CompilePhase.FINAL_CODE)\n-    @IR(counts = { IRNode.Z_STORE_P_WITH_BARRIER_FLAG, ELIDED, \"1\" }, phase = CompilePhase.FINAL_CODE)\n+    @IR(counts = { IRNode.Z_STORE_P_WITH_BARRIER_FLAG, Common.REMAINING, \"1\" }, phase = CompilePhase.FINAL_CODE)\n+    @IR(counts = { IRNode.Z_STORE_P_WITH_BARRIER_FLAG, Common.ELIDED, \"1\" }, phase = CompilePhase.FINAL_CODE)\n@@ -120,2 +288,2 @@\n-    @IR(counts = { IRNode.Z_STORE_P_WITH_BARRIER_FLAG, REMAINING, \"1\" }, phase = CompilePhase.FINAL_CODE)\n-    @IR(counts = { IRNode.Z_LOAD_P_WITH_BARRIER_FLAG, ELIDED, \"1\" },  phase = CompilePhase.FINAL_CODE)\n+    @IR(counts = { IRNode.Z_STORE_P_WITH_BARRIER_FLAG, Common.REMAINING, \"1\" }, phase = CompilePhase.FINAL_CODE)\n+    @IR(counts = { IRNode.Z_LOAD_P_WITH_BARRIER_FLAG, Common.ELIDED, \"1\" },  phase = CompilePhase.FINAL_CODE)\n@@ -124,23 +292,1 @@\n-        blackhole(o.field1);\n-    }\n-\n-    @Test\n-    @IR(counts = { IRNode.Z_STORE_P_WITH_BARRIER_FLAG, REMAINING, \"1\" }, phase = CompilePhase.FINAL_CODE)\n-    @IR(counts = { IRNode.Z_LOAD_P_WITH_BARRIER_FLAG, REMAINING, \"1\" },  phase = CompilePhase.FINAL_CODE)\n-    static void testLoadThenStore(Outer o, Inner i) {\n-        blackhole(o.field1);\n-        o.field1 = i;\n-    }\n-\n-    @Test\n-    @IR(counts = { IRNode.Z_LOAD_P_WITH_BARRIER_FLAG, REMAINING, \"2\" }, phase = CompilePhase.FINAL_CODE)\n-    static void testLoadThenLoadAnotherField(Outer o) {\n-        blackhole(o.field1);\n-        blackhole(o.field2);\n-    }\n-\n-    @Test\n-    @IR(counts = { IRNode.Z_LOAD_P_WITH_BARRIER_FLAG, REMAINING, \"2\" }, phase = CompilePhase.FINAL_CODE)\n-    static void testLoadThenLoadFromAnotherObject(Outer o1, Outer o2) {\n-        blackhole(o1.field1);\n-        blackhole(o2.field1);\n+        Common.blackhole(o.field1);\n@@ -153,4 +299,1 @@\n-                 \"testStoreThenLoad\",\n-                 \"testLoadThenStore\",\n-                 \"testLoadThenLoadAnotherField\",\n-                 \"testLoadThenLoadFromAnotherObject\"})\n+                 \"testStoreThenLoad\"})\n@@ -159,7 +302,4 @@\n-        testAllocateThenStore(inner);\n-        testLoadThenLoad(outer);\n-        testStoreThenStore(outer, inner);\n-        testStoreThenLoad(outer, inner);\n-        testLoadThenStore(outer, inner);\n-        testLoadThenLoadAnotherField(outer);\n-        testLoadThenLoadFromAnotherObject(outer, outer2);\n+        testAllocateThenStore(Common.inner);\n+        testLoadThenLoad(Common.outer);\n+        testStoreThenStore(Common.outer, Common.inner);\n+        testStoreThenLoad(Common.outer, Common.inner);\n@@ -169,1 +309,1 @@\n-    @IR(counts = { IRNode.Z_STORE_P_WITH_BARRIER_FLAG, ELIDED, \"1\" }, phase = CompilePhase.FINAL_CODE)\n+    @IR(counts = { IRNode.Z_STORE_P_WITH_BARRIER_FLAG, Common.ELIDED, \"1\" }, phase = CompilePhase.FINAL_CODE)\n@@ -172,2 +312,2 @@\n-        blackhole(a);\n-        outerArrayVarHandle.setVolatile(a, 0, o);\n+        Common.blackhole(a);\n+        Common.outerArrayVarHandle.setVolatile(a, 0, o);\n@@ -177,1 +317,1 @@\n-    @IR(counts = { IRNode.Z_STORE_P_WITH_BARRIER_FLAG, ELIDED, \"1\" }, phase = CompilePhase.FINAL_CODE)\n+    @IR(counts = { IRNode.Z_STORE_P_WITH_BARRIER_FLAG, Common.ELIDED, \"1\" }, phase = CompilePhase.FINAL_CODE)\n@@ -180,2 +320,2 @@\n-        blackhole(a);\n-        outerArrayVarHandle.setVolatile(a, index, o);\n+        Common.blackhole(a);\n+        Common.outerArrayVarHandle.setVolatile(a, index, o);\n@@ -185,2 +325,2 @@\n-    @IR(counts = { IRNode.Z_LOAD_P_WITH_BARRIER_FLAG, REMAINING, \"1\" }, phase = CompilePhase.FINAL_CODE)\n-    @IR(counts = { IRNode.Z_LOAD_P_WITH_BARRIER_FLAG, ELIDED, \"1\" }, phase = CompilePhase.FINAL_CODE)\n+    @IR(counts = { IRNode.Z_LOAD_P_WITH_BARRIER_FLAG, Common.REMAINING, \"1\" }, phase = CompilePhase.FINAL_CODE)\n+    @IR(counts = { IRNode.Z_LOAD_P_WITH_BARRIER_FLAG, Common.ELIDED, \"1\" }, phase = CompilePhase.FINAL_CODE)\n@@ -188,2 +328,2 @@\n-        blackhole(outerArrayVarHandle.getVolatile(a, 0));\n-        blackhole(outerArrayVarHandle.getVolatile(a, 0));\n+        Common.blackhole(Common.outerArrayVarHandle.getVolatile(a, 0));\n+        Common.blackhole(Common.outerArrayVarHandle.getVolatile(a, 0));\n@@ -193,2 +333,2 @@\n-    @IR(counts = { IRNode.Z_STORE_P_WITH_BARRIER_FLAG, REMAINING, \"1\" }, phase = CompilePhase.FINAL_CODE)\n-    @IR(counts = { IRNode.Z_STORE_P_WITH_BARRIER_FLAG, ELIDED, \"1\" }, phase = CompilePhase.FINAL_CODE)\n+    @IR(counts = { IRNode.Z_STORE_P_WITH_BARRIER_FLAG, Common.REMAINING, \"1\" }, phase = CompilePhase.FINAL_CODE)\n+    @IR(counts = { IRNode.Z_STORE_P_WITH_BARRIER_FLAG, Common.ELIDED, \"1\" }, phase = CompilePhase.FINAL_CODE)\n@@ -196,2 +336,2 @@\n-        outerArrayVarHandle.setVolatile(a, 0, o);\n-        outerArrayVarHandle.setVolatile(a, 0, o);\n+        Common.outerArrayVarHandle.setVolatile(a, 0, o);\n+        Common.outerArrayVarHandle.setVolatile(a, 0, o);\n@@ -201,2 +341,2 @@\n-    @IR(counts = { IRNode.Z_STORE_P_WITH_BARRIER_FLAG, REMAINING, \"1\" }, phase = CompilePhase.FINAL_CODE)\n-    @IR(counts = { IRNode.Z_LOAD_P_WITH_BARRIER_FLAG, ELIDED, \"1\" }, phase = CompilePhase.FINAL_CODE)\n+    @IR(counts = { IRNode.Z_STORE_P_WITH_BARRIER_FLAG, Common.REMAINING, \"1\" }, phase = CompilePhase.FINAL_CODE)\n+    @IR(counts = { IRNode.Z_LOAD_P_WITH_BARRIER_FLAG, Common.ELIDED, \"1\" }, phase = CompilePhase.FINAL_CODE)\n@@ -204,17 +344,2 @@\n-        outerArrayVarHandle.setVolatile(a, 0, o);\n-        blackhole(outerArrayVarHandle.getVolatile(a, 0));\n-    }\n-\n-    @Test\n-    @IR(counts = { IRNode.Z_LOAD_P_WITH_BARRIER_FLAG, REMAINING, \"1\" }, phase = CompilePhase.FINAL_CODE)\n-    @IR(counts = { IRNode.Z_STORE_P_WITH_BARRIER_FLAG, REMAINING, \"1\" }, phase = CompilePhase.FINAL_CODE)\n-    static void testArrayLoadThenStore(Outer[] a, Outer o) {\n-        blackhole(outerArrayVarHandle.getVolatile(a, 0));\n-        outerArrayVarHandle.setVolatile(a, 0, o);\n-    }\n-\n-    @Test\n-    @IR(counts = { IRNode.Z_LOAD_P_WITH_BARRIER_FLAG, REMAINING, \"2\" }, phase = CompilePhase.FINAL_CODE)\n-    static void testArrayLoadThenLoadAnotherElement(Outer[] a) {\n-        blackhole(outerArrayVarHandle.getVolatile(a, 0));\n-        blackhole(outerArrayVarHandle.getVolatile(a, 10));\n+        Common.outerArrayVarHandle.setVolatile(a, 0, o);\n+        Common.blackhole(Common.outerArrayVarHandle.getVolatile(a, 0));\n@@ -227,3 +352,1 @@\n-                 \"testArrayStoreThenLoad\",\n-                 \"testArrayLoadThenStore\",\n-                 \"testArrayLoadThenLoadAnotherElement\"})\n+                 \"testArrayStoreThenLoad\"})\n@@ -231,7 +354,5 @@\n-        testAllocateArrayThenStoreAtKnownIndex(outer);\n-        testAllocateArrayThenStoreAtUnknownIndex(outer, 10);\n-        testArrayLoadThenLoad(outerArray);\n-        testArrayStoreThenStore(outerArray, outer);\n-        testArrayStoreThenLoad(outerArray, outer);\n-        testArrayLoadThenStore(outerArray, outer);\n-        testArrayLoadThenLoadAnotherElement(outerArray);\n+        testAllocateArrayThenStoreAtKnownIndex(Common.outer);\n+        testAllocateArrayThenStoreAtUnknownIndex(Common.outer, 10);\n+        testArrayLoadThenLoad(Common.outerArray);\n+        testArrayStoreThenStore(Common.outerArray, Common.outer);\n+        testArrayStoreThenLoad(Common.outerArray, Common.outer);\n@@ -241,2 +362,2 @@\n-    @IR(counts = { IRNode.Z_STORE_P_WITH_BARRIER_FLAG, REMAINING, \"1\" }, phase = CompilePhase.FINAL_CODE)\n-    @IR(counts = { IRNode.Z_STORE_P_WITH_BARRIER_FLAG, ELIDED, \"1\" }, phase = CompilePhase.FINAL_CODE)\n+    @IR(counts = { IRNode.Z_STORE_P_WITH_BARRIER_FLAG, Common.REMAINING, \"1\" }, phase = CompilePhase.FINAL_CODE)\n+    @IR(counts = { IRNode.Z_STORE_P_WITH_BARRIER_FLAG, Common.ELIDED, \"1\" }, phase = CompilePhase.FINAL_CODE)\n@@ -251,11 +372,2 @@\n-    @IR(counts = { IRNode.Z_STORE_P_WITH_BARRIER_FLAG, REMAINING, \"2\" }, phase = CompilePhase.FINAL_CODE)\n-    static void testConditionalStoreThenStore(Outer o, Inner i, int value) {\n-        if (value % 2 == 0) {\n-            o.field1 = i;\n-        }\n-        o.field1 = i;\n-    }\n-\n-    @Test\n-    @IR(counts = { IRNode.Z_STORE_P_WITH_BARRIER_FLAG, REMAINING, \"1\" }, phase = CompilePhase.FINAL_CODE)\n-    @IR(counts = { IRNode.Z_STORE_P_WITH_BARRIER_FLAG, ELIDED, \"1\" }, phase = CompilePhase.FINAL_CODE)\n+    @IR(counts = { IRNode.Z_STORE_P_WITH_BARRIER_FLAG, Common.REMAINING, \"1\" }, phase = CompilePhase.FINAL_CODE)\n+    @IR(counts = { IRNode.Z_STORE_P_WITH_BARRIER_FLAG, Common.ELIDED, \"1\" }, phase = CompilePhase.FINAL_CODE)\n@@ -269,8 +381,0 @@\n-    @Test\n-    @IR(counts = { IRNode.Z_STORE_P_WITH_BARRIER_FLAG, REMAINING, \"2\" }, phase = CompilePhase.FINAL_CODE)\n-    static void testStoreThenCallThenStore(Outer o, Inner i) {\n-        o.field1 = i;\n-        nonInlinedMethod();\n-        o.field1 = i;\n-    }\n-\n@@ -278,3 +382,1 @@\n-                 \"testConditionalStoreThenStore\",\n-                 \"testStoreThenStoreInLoop\",\n-                 \"testStoreThenCallThenStore\"})\n+                 \"testStoreThenStoreInLoop\"})\n@@ -282,12 +384,2 @@\n-        testStoreThenConditionalStore(outer, inner, ThreadLocalRandom.current().nextInt(0, 100));\n-        testConditionalStoreThenStore(outer, inner, ThreadLocalRandom.current().nextInt(0, 100));\n-        testStoreThenStoreInLoop(outer, inner);\n-        testStoreThenCallThenStore(outer, inner);\n-    }\n-\n-    @Test\n-    @IR(counts = { IRNode.Z_GET_AND_SET_P_WITH_BARRIER_FLAG, REMAINING, \"1\" }, phase = CompilePhase.FINAL_CODE)\n-    static void testAllocateThenAtomic(Inner i) {\n-        Outer o = new Outer();\n-        blackhole(o);\n-        field1VarHandle.getAndSet​(o, i);\n+        testStoreThenConditionalStore(Common.outer, Common.inner, ThreadLocalRandom.current().nextInt(0, 100));\n+        testStoreThenStoreInLoop(Common.outer, Common.inner);\n@@ -297,10 +389,2 @@\n-    @IR(counts = { IRNode.Z_LOAD_P_WITH_BARRIER_FLAG, REMAINING, \"1\" }, phase = CompilePhase.FINAL_CODE)\n-    @IR(counts = { IRNode.Z_GET_AND_SET_P_WITH_BARRIER_FLAG, REMAINING, \"1\" }, phase = CompilePhase.FINAL_CODE)\n-    static void testLoadThenAtomic(Outer o, Inner i) {\n-        blackhole(o.field1);\n-        field1VarHandle.getAndSet​(o, i);\n-    }\n-\n-    @Test\n-    @IR(counts = { IRNode.Z_STORE_P_WITH_BARRIER_FLAG, REMAINING, \"1\" }, phase = CompilePhase.FINAL_CODE)\n-    @IR(counts = { IRNode.Z_GET_AND_SET_P_WITH_BARRIER_FLAG, ELIDED, \"1\" }, phase = CompilePhase.FINAL_CODE)\n+    @IR(counts = { IRNode.Z_STORE_P_WITH_BARRIER_FLAG, Common.REMAINING, \"1\" }, phase = CompilePhase.FINAL_CODE)\n+    @IR(counts = { IRNode.Z_GET_AND_SET_P_WITH_BARRIER_FLAG, Common.ELIDED, \"1\" }, phase = CompilePhase.FINAL_CODE)\n@@ -309,1 +393,1 @@\n-        field1VarHandle.getAndSet​(o, i);\n+        Common.field1VarHandle.getAndSet​(o, i);\n@@ -313,2 +397,2 @@\n-    @IR(counts = { IRNode.Z_GET_AND_SET_P_WITH_BARRIER_FLAG, REMAINING, \"1\" }, phase = CompilePhase.FINAL_CODE)\n-    @IR(counts = { IRNode.Z_LOAD_P_WITH_BARRIER_FLAG, ELIDED, \"1\" }, phase = CompilePhase.FINAL_CODE)\n+    @IR(counts = { IRNode.Z_GET_AND_SET_P_WITH_BARRIER_FLAG, Common.REMAINING, \"1\" }, phase = CompilePhase.FINAL_CODE)\n+    @IR(counts = { IRNode.Z_LOAD_P_WITH_BARRIER_FLAG, Common.ELIDED, \"1\" }, phase = CompilePhase.FINAL_CODE)\n@@ -316,2 +400,2 @@\n-        field1VarHandle.getAndSet​(o, i);\n-        blackhole(o.field1);\n+        Common.field1VarHandle.getAndSet​(o, i);\n+        Common.blackhole(o.field1);\n@@ -321,2 +405,2 @@\n-    @IR(counts = { IRNode.Z_GET_AND_SET_P_WITH_BARRIER_FLAG, REMAINING, \"1\" }, phase = CompilePhase.FINAL_CODE)\n-    @IR(counts = { IRNode.Z_STORE_P_WITH_BARRIER_FLAG, ELIDED, \"1\" }, phase = CompilePhase.FINAL_CODE)\n+    @IR(counts = { IRNode.Z_GET_AND_SET_P_WITH_BARRIER_FLAG, Common.REMAINING, \"1\" }, phase = CompilePhase.FINAL_CODE)\n+    @IR(counts = { IRNode.Z_STORE_P_WITH_BARRIER_FLAG, Common.ELIDED, \"1\" }, phase = CompilePhase.FINAL_CODE)\n@@ -324,1 +408,1 @@\n-        field1VarHandle.getAndSet​(o, i);\n+        Common.field1VarHandle.getAndSet​(o, i);\n@@ -329,2 +413,2 @@\n-    @IR(counts = { IRNode.Z_GET_AND_SET_P_WITH_BARRIER_FLAG, REMAINING, \"1\" }, phase = CompilePhase.FINAL_CODE)\n-    @IR(counts = { IRNode.Z_GET_AND_SET_P_WITH_BARRIER_FLAG, ELIDED, \"1\" }, phase = CompilePhase.FINAL_CODE)\n+    @IR(counts = { IRNode.Z_GET_AND_SET_P_WITH_BARRIER_FLAG, Common.REMAINING, \"1\" }, phase = CompilePhase.FINAL_CODE)\n+    @IR(counts = { IRNode.Z_GET_AND_SET_P_WITH_BARRIER_FLAG, Common.ELIDED, \"1\" }, phase = CompilePhase.FINAL_CODE)\n@@ -332,2 +416,2 @@\n-        field1VarHandle.getAndSet​(o, i);\n-        field1VarHandle.getAndSet​(o, i);\n+        Common.field1VarHandle.getAndSet​(o, i);\n+        Common.field1VarHandle.getAndSet​(o, i);\n@@ -337,25 +421,2 @@\n-    @IR(counts = { IRNode.Z_GET_AND_SET_P_WITH_BARRIER_FLAG, REMAINING, \"2\" }, phase = CompilePhase.FINAL_CODE)\n-    static void testAtomicThenAtomicAnotherField(Outer o, Inner i) {\n-        field1VarHandle.getAndSet​(o, i);\n-        field2VarHandle.getAndSet​(o, i);\n-    }\n-\n-    @Test\n-    @IR(counts = { IRNode.Z_GET_AND_SET_P_WITH_BARRIER_FLAG, REMAINING, \"1\" }, phase = CompilePhase.FINAL_CODE)\n-    static void testAllocateArrayThenAtomicAtKnownIndex(Outer o) {\n-        Outer[] a = new Outer[42];\n-        blackhole(a);\n-        outerArrayVarHandle.getAndSet(a, 2, o);\n-    }\n-\n-    @Test\n-    @IR(counts = { IRNode.Z_GET_AND_SET_P_WITH_BARRIER_FLAG, REMAINING, \"1\" }, phase = CompilePhase.FINAL_CODE)\n-    static void testAllocateArrayThenAtomicAtUnknownIndex(Outer o, int index) {\n-        Outer[] a = new Outer[42];\n-        blackhole(a);\n-        outerArrayVarHandle.getAndSet(a, index, o);\n-    }\n-\n-    @Test\n-    @IR(counts = { IRNode.Z_GET_AND_SET_P_WITH_BARRIER_FLAG, REMAINING, \"1\" }, phase = CompilePhase.FINAL_CODE)\n-    @IR(counts = { IRNode.Z_GET_AND_SET_P_WITH_BARRIER_FLAG, ELIDED, \"1\" }, phase = CompilePhase.FINAL_CODE)\n+    @IR(counts = { IRNode.Z_GET_AND_SET_P_WITH_BARRIER_FLAG, Common.REMAINING, \"1\" }, phase = CompilePhase.FINAL_CODE)\n+    @IR(counts = { IRNode.Z_GET_AND_SET_P_WITH_BARRIER_FLAG, Common.ELIDED, \"1\" }, phase = CompilePhase.FINAL_CODE)\n@@ -363,2 +424,2 @@\n-        outerArrayVarHandle.getAndSet(a, 0, o);\n-        outerArrayVarHandle.getAndSet(a, 0, o);\n+        Common.outerArrayVarHandle.getAndSet(a, 0, o);\n+        Common.outerArrayVarHandle.getAndSet(a, 0, o);\n@@ -367,10 +428,1 @@\n-    @Test\n-    @IR(counts = { IRNode.Z_GET_AND_SET_P_WITH_BARRIER_FLAG, REMAINING, \"2\" }, phase = CompilePhase.FINAL_CODE)\n-    static void testArrayAtomicThenAtomicAtUnknownIndices(Outer[] a, Outer o, int index1, int index2) {\n-        outerArrayVarHandle.getAndSet(a, index1, o);\n-        outerArrayVarHandle.getAndSet(a, index2, o);\n-    }\n-\n-    @Run(test = {\"testAllocateThenAtomic\",\n-                 \"testLoadThenAtomic\",\n-                 \"testStoreThenAtomic\",\n+    @Run(test = {\"testStoreThenAtomic\",\n@@ -380,5 +432,1 @@\n-                 \"testAtomicThenAtomicAnotherField\",\n-                 \"testAllocateArrayThenAtomicAtKnownIndex\",\n-                 \"testAllocateArrayThenAtomicAtUnknownIndex\",\n-                 \"testArrayAtomicThenAtomic\",\n-                 \"testArrayAtomicThenAtomicAtUnknownIndices\"})\n+                 \"testArrayAtomicThenAtomic\"})\n@@ -386,11 +434,5 @@\n-        testAllocateThenAtomic(inner);\n-        testLoadThenAtomic(outer, inner);\n-        testStoreThenAtomic(outer, inner);\n-        testAtomicThenLoad(outer, inner);\n-        testAtomicThenStore(outer, inner);\n-        testAtomicThenAtomic(outer, inner);\n-        testAtomicThenAtomicAnotherField(outer, inner);\n-        testAllocateArrayThenAtomicAtKnownIndex(outer);\n-        testAllocateArrayThenAtomicAtUnknownIndex(outer, 10);\n-        testArrayAtomicThenAtomic(outerArray, outer);\n-        testArrayAtomicThenAtomicAtUnknownIndices(outerArray, outer, 10, 20);\n+        testStoreThenAtomic(Common.outer, Common.inner);\n+        testAtomicThenLoad(Common.outer, Common.inner);\n+        testAtomicThenStore(Common.outer, Common.inner);\n+        testAtomicThenAtomic(Common.outer, Common.inner);\n+        testArrayAtomicThenAtomic(Common.outerArray, Common.outer);\n","filename":"test\/hotspot\/jtreg\/compiler\/gcbarriers\/TestZGCBarrierElision.java","additions":255,"deletions":213,"binary":false,"changes":468,"status":"modified"}]}