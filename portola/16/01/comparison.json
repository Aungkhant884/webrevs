{"files":[{"patch":"@@ -2,1 +2,1 @@\n-project=jdk\n+project=portola\n@@ -6,1 +6,1 @@\n-error=author,committer,reviewers,merge,issues,executable,symlink,message,hg-tag,whitespace,problemlists\n+error=author,committer,executable,symlink,whitespace\n@@ -19,7 +19,0 @@\n-[checks \"merge\"]\n-message=Merge\n-\n-[checks \"reviewers\"]\n-reviewers=1\n-ignore=duke\n-\n@@ -28,6 +21,0 @@\n-\n-[checks \"issues\"]\n-pattern=^([124-8][0-9]{6}): (\\S.*)$\n-\n-[checks \"problemlists\"]\n-dirs=test\/jdk|test\/langtools|test\/lib-test|test\/hotspot\/jtreg|test\/jaxp\n","filename":".jcheck\/conf","additions":2,"deletions":15,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+  $(call info-file-item, \"LIBC\", \"$(OPENJDK_TARGET_LIBC)\")\n","filename":"make\/ReleaseFile.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,0 +33,11 @@\n+# config.guess doesn't identify systems running the musl C library, and will\n+# instead return a string with a -gnu suffix. This block detects musl and\n+# modifies the string to have a -musl suffix instead. \n+echo $OUT | grep -- -linux- > \/dev\/null 2> \/dev\/null\n+if test $? = 0; then\n+  ldd_version=`ldd --version 2>&1 | head -1 | cut -f1 -d' '`\n+  if [ x\"${ldd_version}\" = x\"musl\" ]; then\n+    OUT=`echo $OUT | sed 's\/-gnu\/-musl\/'`\n+  fi\n+fi\n+\n","filename":"make\/autoconf\/build-aux\/config.guess","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -32,0 +32,5 @@\n+if [ \"$1\"x = \"x86_64-unknown-linux-musl\"x ]; then\n+    echo $1\n+    exit\n+fi\n+\n","filename":"make\/autoconf\/build-aux\/config.sub","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+OPENJDK_BUILD_LIBC := @OPENJDK_BUILD_LIBC@\n@@ -62,0 +63,1 @@\n+OPENJDK_TARGET_LIBC := @OPENJDK_BUILD_LIBC@\n@@ -69,0 +71,1 @@\n+HOTSPOT_TARGET_LIBC := @HOTSPOT_BUILD_LIBC@\n","filename":"make\/autoconf\/buildjdk-spec.gmk.in","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -221,0 +221,12 @@\n+\n+  case \"$1\" in\n+    *linux*-musl)\n+      VAR_LIBC=musl\n+      ;;\n+    *linux*-gnu)\n+      VAR_LIBC=gnu\n+      ;;\n+    *)\n+      VAR_LIBC=default\n+      ;;\n+  esac\n@@ -259,0 +271,1 @@\n+  OPENJDK_BUILD_LIBC=\"$VAR_LIBC\"\n@@ -266,0 +279,1 @@\n+  AC_SUBST(OPENJDK_BUILD_LIBC)\n@@ -270,0 +284,5 @@\n+  if test \"x$OPENJDK_BUILD_OS\" = \"xlinux\"; then\n+    AC_MSG_CHECKING([openjdk-build C library])\n+    AC_MSG_RESULT([$OPENJDK_BUILD_LIBC])\n+  fi\n+\n@@ -290,0 +309,1 @@\n+  OPENJDK_TARGET_LIBC=\"$VAR_LIBC\"\n@@ -299,0 +319,1 @@\n+  AC_SUBST(OPENJDK_TARGET_LIBC)\n@@ -302,0 +323,5 @@\n+\n+  if test \"x$OPENJDK_TARGET_OS\" = \"xlinux\"; then\n+    AC_MSG_CHECKING([openjdk-target C library])\n+    AC_MSG_RESULT([$OPENJDK_TARGET_LIBC])\n+  fi\n@@ -423,1 +449,7 @@\n-  OPENJDK_$1_BUNDLE_PLATFORM=\"${OPENJDK_$1_OS_BUNDLE}-${OPENJDK_$1_CPU_BUNDLE}\"\n+\n+  OPENJDK_$1_LIBC_BUNDLE=\"\"\n+  if test \"x$OPENJDK_$1_LIBC\" = \"xmusl\"; then  \n+    OPENJDK_$1_LIBC_BUNDLE=\"-$OPENJDK_$1_LIBC\"\n+  fi\n+\n+  OPENJDK_$1_BUNDLE_PLATFORM=\"${OPENJDK_$1_OS_BUNDLE}-${OPENJDK_$1_CPU_BUNDLE}${OPENJDK_$1_LIBC_BUNDLE}\"\n@@ -496,0 +528,7 @@\n+  if test \"x$OPENJDK_$1_LIBC\" = \"xmusl\"; then\n+    HOTSPOT_$1_LIBC=$OPENJDK_$1_LIBC\n+  else\n+    HOTSPOT_$1_LIBC=\"\"\n+  fi\n+  AC_SUBST(HOTSPOT_$1_LIBC)\n+\n","filename":"make\/autoconf\/platform.m4","additions":40,"deletions":1,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -83,0 +83,2 @@\n+OPENJDK_TARGET_LIBC:=@OPENJDK_TARGET_LIBC@\n+\n@@ -98,0 +100,2 @@\n+HOTSPOT_TARGET_LIBC := @HOTSPOT_TARGET_LIBC@\n+\n@@ -112,0 +116,2 @@\n+OPENJDK_BUILD_LIBC:=@OPENJDK_BUILD_LIBC@\n+\n@@ -842,0 +848,1 @@\n+INCLUDE_SA_ATTACH=@INCLUDE_SA_ATTACH@\n","filename":"make\/autoconf\/spec.gmk.in","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+ * input.target_libc\n@@ -63,0 +64,1 @@\n+ * input.build_libc\n@@ -103,1 +105,3 @@\n- *       \/\/ Combination of target_os and target_cpu for convenience\n+ *       \/\/ Optional libc string if non standard\n+ *       target_libc; <string>\n+ *       \/\/ Optional combination of target_os and target_cpu for convenience\n@@ -109,1 +113,3 @@\n- *       \/\/ Combination of build_os and build_cpu for convenience\n+ *       \/\/ Optional libc string if non standard\n+ *       build_libc; <string>\n+ *       \/\/ Optional combination of build_os and build_cpu for convenience\n@@ -195,1 +201,1 @@\n-    data.product = \"jdk\";\n+    data.product = \"jdk-portola\";\n@@ -242,1 +248,1 @@\n-        \"linux-x64\", \"linux-x86\", \"macosx-x64\",\n+        \"linux-x64\", \"linux-x64-musl\", \"linux-x86\", \"macosx-x64\",\n@@ -415,0 +421,8 @@\n+        \"linux-x64-musl\": {\n+            target_os: \"linux\",\n+            target_cpu: \"x64\",\n+            target_libc: \"musl\",\n+            configure_args: concat(common.configure_args_64bit,\n+                \"--with-zlib=system\"),\n+        },\n+\n@@ -642,0 +656,4 @@\n+        \"linux-x64-musl\": {\n+            platform: \"linux-x64-musl\",\n+            demo_ext: \"tar.gz\"\n+        },\n@@ -984,1 +1002,2 @@\n-        + \"-\" + input.build_cpu;\n+        + \"-\" + input.build_cpu +\n+        (input.build_libc ? \"-\" + input.build_libc : \"\");\n@@ -1000,1 +1019,1 @@\n-            product: \"jdk\",\n+            product: input.build_libc == \"musl\" ? \"jdk-portola\" : \"jdk\",\n","filename":"make\/conf\/jib-profiles.js","additions":25,"deletions":6,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -64,0 +64,4 @@\n+ifneq ($(HOTSPOT_TARGET_LIBC),)\n+  LIBC_DEFINE := -DHOTSPOT_LIBC='\"$(HOTSPOT_TARGET_LIBC)\"'\n+endif\n+\n@@ -71,0 +75,1 @@\n+    $(LIBC_DEFINE) \\\n","filename":"make\/hotspot\/lib\/CompileJvm.gmk","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -69,0 +69,4 @@\n+ifneq ($(HOTSPOT_TARGET_LIBC),)\n+  JVM_CFLAGS_TARGET_DEFINES += -DHOTSPOT_LIBC='\"$(HOTSPOT_TARGET_LIBC)\"'\n+endif\n+\n","filename":"make\/hotspot\/lib\/JvmFlags.gmk","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -184,0 +184,2 @@\n+LIBJLI_CFLAGS += -DLIBC=\\\"$(OPENJDK_TARGET_LIBC)\\\"\n+\n","filename":"make\/modules\/java.base\/lib\/CoreLibraries.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,0 +51,2 @@\n+SA_CFLAGS += -DLIBC=\\\"$(OPENJDK_TARGET_LIBC)\\\"\n+\n","filename":"make\/modules\/jdk.hotspot.agent\/Lib.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+    DISABLED_WARNINGS_gcc := stringop-truncation, \\\n","filename":"make\/modules\/jdk.jdwp.agent\/Lib.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -96,0 +96,5 @@\n+ifeq ($(OPENJDK_TARGET_LIBC), musl)\n+  # 'strncpy' output truncated before terminating nul copying as many bytes from a string as its length\n+  BUILD_JDK_JTREG_LIBRARIES_CFLAGS_libInheritedChannel := -Wno-stringop-truncation -Wno-stringop-overflow\n+endif\n+\n","filename":"make\/test\/JtregNativeJdk.gmk","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -106,1 +106,0 @@\n-# include <gnu\/libc-version.h>\n@@ -158,2 +157,2 @@\n-const char * os::Linux::_glibc_version = NULL;\n-const char * os::Linux::_libpthread_version = NULL;\n+const char * os::Linux::_glibc_version = \"unknown\";\n+const char * os::Linux::_libpthread_version = \"unknown\";\n@@ -612,5 +611,8 @@\n-  size_t n = confstr(_CS_GNU_LIBC_VERSION, NULL, 0);\n-  assert(n > 0, \"cannot retrieve glibc version\");\n-  char *str = (char *)malloc(n, mtInternal);\n-  confstr(_CS_GNU_LIBC_VERSION, str, n);\n-  os::Linux::set_glibc_version(str);\n+  size_t n;\n+\n+  n = confstr(_CS_GNU_LIBC_VERSION, NULL, 0);\n+  if (n > 0) {\n+    char* str = (char *)malloc(n, mtInternal);\n+    confstr(_CS_GNU_LIBC_VERSION, str, n);\n+    os::Linux::set_glibc_version(str);\n+  }\n@@ -619,4 +621,5 @@\n-  assert(n > 0, \"cannot retrieve pthread version\");\n-  str = (char *)malloc(n, mtInternal);\n-  confstr(_CS_GNU_LIBPTHREAD_VERSION, str, n);\n-  os::Linux::set_libpthread_version(str);\n+  if (n > 0) {\n+    char* str = (char *)malloc(n, mtInternal);\n+    confstr(_CS_GNU_LIBPTHREAD_VERSION, str, n);\n+    os::Linux::set_libpthread_version(str);\n+  }\n@@ -3262,0 +3265,20 @@\n+static void* dlvsym_if_available(void* handle, const char* name, const char* version) {\n+  typedef void* (*dlvsym_func_type)(void* handle, const char* name, const char* version);\n+  static dlvsym_func_type dlvsym_func;\n+  static bool initialized = false;\n+\n+  if (!initialized) {\n+    dlvsym_func = (dlvsym_func_type)dlsym(RTLD_NEXT, \"dlvsym\");\n+    initialized = true;\n+  }\n+\n+  if (dlvsym_func != NULL) {\n+    void *f = dlvsym_func(handle, name, version);\n+    if (f != NULL) {\n+      return f;\n+    }\n+  }\n+\n+  return dlsym(handle, name);\n+}\n+\n@@ -3265,5 +3288,1 @@\n-  void *f = dlvsym(handle, name, \"libnuma_1.1\");\n-  if (f == NULL) {\n-    f = dlsym(handle, name);\n-  }\n-  return f;\n+  return dlvsym_if_available(handle, name, \"libnuma_1.1\");\n@@ -3275,1 +3294,1 @@\n-  return dlvsym(handle, name, \"libnuma_1.2\");\n+  return dlvsym_if_available(handle, name, \"libnuma_1.2\");\n@@ -5216,0 +5235,57 @@\n+\/\/ Some linux distributions (notably: Alpine Linux) include the\n+\/\/ grsecurity in the kernel by default. Of particular interest from a\n+\/\/ JVM perspective is PaX (https:\/\/pax.grsecurity.net\/), which adds\n+\/\/ some security features related to page attributes. Specifically,\n+\/\/ the MPROTECT PaX functionality\n+\/\/ (https:\/\/pax.grsecurity.net\/docs\/mprotect.txt) prevents dynamic\n+\/\/ code generation by disallowing a (previously) writable page to be\n+\/\/ marked as executable. This is, of course, exactly what HotSpot does\n+\/\/ for both JIT compiled method, as well as for stubs, adapters, etc.\n+\/\/\n+\/\/ Instead of crashing \"lazily\" when trying to make a page executable,\n+\/\/ this code probes for the presence of PaX and reports the failure\n+\/\/ eagerly.\n+static void check_pax(void) {\n+  \/\/ Zero doesn't generate code dynamically, so no need to perform the PaX check\n+#ifndef ZERO\n+  size_t size = os::Linux::page_size();\n+\n+  void* p = ::mmap(NULL, size, PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);\n+  if (p == MAP_FAILED) {\n+    vm_exit_out_of_memory(size, OOM_MMAP_ERROR, \"failed to allocate memory for PaX check.\");\n+  }\n+\n+  int res = ::mprotect(p, size, PROT_WRITE|PROT_EXEC);\n+  if (res == -1) {\n+    vm_exit_during_initialization(\"Failed to mark memory page as executable\",\n+                                  \"Please check if grsecurity\/PaX is enabled in your kernel.\\n\"\n+                                  \"\\n\"\n+                                  \"For example, you can do this by running (note: you may need root privileges):\\n\"\n+                                  \"\\n\"\n+                                  \"    sysctl kernel.pax.softmode\\n\"\n+                                  \"\\n\"\n+                                  \"If PaX is included in the kernel you will see something like this:\\n\"\n+                                  \"\\n\"\n+                                  \"    kernel.pax.softmode = 0\\n\"\n+                                  \"\\n\"\n+                                  \"In particular, if the value is 0 (zero), then PaX is enabled.\\n\"\n+                                  \"\\n\"\n+                                  \"PaX includes security functionality which interferes with the dynamic code\\n\"\n+                                  \"generation the JVM relies on. Specifically, the MPROTECT functionality as\\n\"\n+                                  \"described on https:\/\/pax.grsecurity.net\/docs\/mprotect.txt is not compatible\\n\"\n+                                  \"with the JVM. If you want to allow the JVM to run you will have to disable PaX.\\n\"\n+                                  \"You can do this on a per-executable basis using the paxctl tool, for example:\\n\"\n+                                  \"\\n\"\n+                                  \"    paxctl -cm bin\/java\\n\"\n+                                  \"\\n\"\n+                                  \"Please note that this modifies the executable binary in-place, so you may want\\n\"\n+                                  \"to make a backup of it first. Also note that you have to repeat this for other\\n\"\n+                                  \"executables like javac, jar, jcmd, etc.\\n\"\n+                                  );\n+\n+  }\n+\n+  ::munmap(p, size);\n+#endif\n+}\n+\n@@ -5249,0 +5325,2 @@\n+  check_pax();\n+\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":96,"deletions":18,"binary":false,"changes":114,"status":"modified"},{"patch":"@@ -1069,1 +1069,1 @@\n-  ScratchBlock **smallest_ptr, *smallest;\n+  ScratchBlock **smallest_ptr = NULL, *smallest;\n","filename":"src\/hotspot\/share\/gc\/shared\/genCollectedHeap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -260,0 +260,6 @@\n+  #ifdef HOTSPOT_LIBC\n+    #define LIBC_STR \"-\" HOTSPOT_LIBC\n+  #else\n+    #define LIBC_STR \"\"\n+  #endif\n+\n@@ -265,1 +271,1 @@\n-         \" for \" OS \"-\" CPU FLOAT_ARCH_STR \\\n+         \" for \" OS \"-\" CPU FLOAT_ARCH_STR LIBC_STR \\\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -239,1 +239,7 @@\n-        return;\n+        \/\/ ENOEXEC indicates that the file header was not recognized. The musl C\n+        \/\/ library does not implement the fallback to \/bin\/sh for that case, so fall\n+        \/\/ through to the code below which implements that fallback using\n+        \/\/ execve_with_shell_fallback.\n+        if (errno != ENOEXEC) {\n+            return;\n+        }\n","filename":"src\/java.base\/unix\/native\/libjava\/childproc.c","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -233,0 +233,33 @@\n+#ifdef __linux\n+#ifndef LIBC\n+#error \"LIBC not set\"\n+#endif\n+\n+    if (strcmp(LIBC, \"musl\") == 0) {\n+      \/*\n+       * The musl library loader requires LD_LIBRARY_PATH to be set in\n+       * order to correctly resolve the dependency libjava.so has on libjvm.so.\n+       *\n+       * Specifically, it differs from glibc in the sense that even if\n+       * libjvm.so has already been loaded it will not be considered a\n+       * candidate for resolving the dependency unless the *full* path\n+       * of the already loaded library matches the dependency being loaded.\n+       *\n+       * libjvm.so is being loaded by the launcher using a long path to\n+       * dlopen, not just the basename of the library. Typically this\n+       * is something like \"..\/lib\/server\/libjvm.so\". However, if\/when\n+       * libjvm.so later tries to dlopen libjava.so (which it does in\n+       * order to get access to a few functions implemented in\n+       * libjava.so) the musl loader will, as part of loading\n+       * dependent libraries, try to load libjvm.so using only its\n+       * basename \"libjvm.so\". Since this does not match the longer\n+       * path path it was first loaded with, the already loaded\n+       * library is not considered a candidate, and the loader will\n+       * instead look for libjvm.so elsewhere. If it's not in\n+       * LD_LIBRARY_PATH the dependency load will fail, and libjava.so\n+       * will therefore fail as well.\n+       *\/\n+      return JNI_TRUE;\n+    }\n+#endif\n+\n","filename":"src\/java.base\/unix\/native\/libjli\/java_md.c","additions":33,"deletions":0,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -376,0 +376,4 @@\n+#ifndef LIBC\n+#error \"LIBC not set\"\n+#endif\n+\n@@ -410,2 +414,2 @@\n-\n-        if ((existing_map->memsz != page_size) &&\n+        if ((strcmp(LIBC, \"musl\")) &&\n+            (existing_map->memsz != page_size) &&\n","filename":"src\/jdk.hotspot.agent\/linux\/native\/libsaproc\/ps_core.c","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -283,3 +283,4 @@\n-    char* msg = strerror_r(errno, buf, sizeof(buf));\n-    snprintf(err_buf, err_buf_len, \"ptrace(PTRACE_ATTACH, ..) failed for %d: %s\", pid, msg);\n-    print_error(\"%s\\n\", err_buf);\n+    if (strerror_r(errno, buf, sizeof(buf) == 0)) {\n+      snprintf(err_buf, err_buf_len, \"ptrace(PTRACE_ATTACH, ..) failed for %d: %s\", pid, buf);\n+      print_error(\"%s\\n\", err_buf);\n+    }\n","filename":"src\/jdk.hotspot.agent\/linux\/native\/libsaproc\/ps_proc.c","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-    #define free(p) Do not use this interface.\n+    #define free do_not_use_this_interface_free\n@@ -40,1 +40,1 @@\n-    #define malloc(p) Do not use this interface.\n+    #define malloc do_not_use_this_interface_malloc\n@@ -42,1 +42,1 @@\n-    #define calloc(p) Do not use this interface.\n+    #define calloc do_not_use_this_interface_calloc\n@@ -44,1 +44,1 @@\n-    #define realloc(p) Do not use this interface.\n+    #define realloc do_not_use_this_interface_realloc\n@@ -46,1 +46,1 @@\n-    #define strdup(p) Do not use this interface.\n+    #define strdup do_not_use_this_interface_strdup\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/util.h","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -122,1 +122,1 @@\n-                \"\" + ProcessHandle.current().pid());\n+                getPid());\n@@ -127,1 +127,2 @@\n-                System.out.println(\"(Second VM) Open file descriptors:\\n\" + outputContainingFilenames().stream().collect(joining(\"\\n\")));\n+                System.out.printf(\"(Second VM) Open file descriptors: %s%n\",\n+                        outputContainingFilenames().stream().collect(joining(\"\\n\")));\n@@ -174,7 +175,8 @@\n-    static Optional<String[]> lsofCommandCache = stream(new String[][]{\n-            {\"\/usr\/bin\/lsof\", \"-p\"},\n-            {\"\/usr\/sbin\/lsof\", \"-p\"},\n-            {\"\/bin\/lsof\", \"-p\"},\n-            {\"\/sbin\/lsof\", \"-p\"},\n-            {\"\/usr\/local\/bin\/lsof\", \"-p\"}})\n-        .filter(args -> new File(args[0]).exists())\n+    static Optional<Command> lsofCommandCache = stream(new Command[]{\n+            new Command(\"\/usr\/bin\/lsof\", \"-p\"),\n+            new Command(\"\/usr\/sbin\/lsof\", \"-p\"),\n+            new Command(\"\/bin\/lsof\", \"-p\"),\n+            new Command(\"\/sbin\/lsof\", \"-p\"),\n+            new Command(\"\/usr\/local\/bin\/lsof\", \"-p\"),\n+        })\n+        .filter(command -> command.exists())\n@@ -183,1 +185,1 @@\n-    static Optional<String[]> lsofCommand() {\n+    static Optional<Command> lsofCommand() {\n@@ -187,2 +189,3 @@\n-    static Collection<String> outputContainingFilenames() {\n-        long pid = ProcessHandle.current().pid();\n+    static Command lsofCmd() {\n+        return lsofCommand().orElseThrow(() -> new RuntimeException(\"lsof like command not found\"));\n+    }\n@@ -190,3 +193,7 @@\n-        String[] command = lsofCommand().orElseThrow(() -> new RuntimeException(\"lsof like command not found\"));\n-        System.out.println(\"using command: \" + command[0] + \" \" + command[1]);\n-        return run(command[0], command[1], \"\" + pid).collect(toList());\n+    static Collection<String> outputContainingFilenames() {\n+        String pid = getPid();\n+        Command command = lsofCmd();\n+        System.out.printf(\"using command: %s%n\", command);\n+        return run(command.name, command.option, pid)\n+                .filter(line -> line.contains(pid))\n+                .collect(toList());\n@@ -208,0 +215,23 @@\n+\n+    private static String getPid() {\n+        return Long.toString(ProcessHandle.current().pid());\n+    }\n+\n+    private static class Command {\n+        private final String name;\n+        private final String option;\n+\n+        public Command(String name, String option) {\n+            this.name = name;\n+            this.option = option;\n+        }\n+\n+        private boolean exists() {\n+            return new File(name).exists();\n+        }\n+\n+        public String toString() {\n+            return String.format(\"[name: %s, option: %s]\",\n+                    name, option);\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/runtime\/8176717\/TestInheritFD.java","additions":45,"deletions":15,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include <jvm.h>\n@@ -94,0 +95,14 @@\n+int get_java_stacksize () {\n+  size_t stacksize;\n+  pthread_attr_t attr;\n+  JDK1_1InitArgs jdk_args;\n+\n+  jdk_args.version = JNI_VERSION_1_1;\n+  JNI_GetDefaultJavaVMInitArgs(&jdk_args);\n+  if (jdk_args.javaStackSize <= 0) {\n+    fprintf(stderr, \"Test ERROR. Can't get a valid value for the default stacksize.\\n\");\n+    exit(7);\n+  }\n+  return jdk_args.javaStackSize;\n+}\n+\n@@ -261,0 +276,1 @@\n+  int stack_size = get_java_stacksize();\n@@ -262,0 +278,4 @@\n+  pthread_attr_t thread_attr;\n+\n+  pthread_attr_init(&thread_attr);\n+  pthread_attr_setstacksize(&thread_attr, stack_size);\n@@ -267,1 +287,2 @@\n-    pthread_create (&thr, NULL, run_java_overflow, NULL);\n+\n+    pthread_create (&thr, &thread_attr, run_java_overflow, NULL);\n@@ -280,1 +301,1 @@\n-    pthread_create (&thr, NULL, run_native_overflow, NULL);\n+    pthread_create (&thr, &thread_attr, run_native_overflow, NULL);\n","filename":"test\/hotspot\/jtreg\/runtime\/StackGuardPages\/exeinvoke.c","additions":23,"deletions":2,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+\n+#ifdef __GLIBC__\n@@ -30,0 +32,1 @@\n+#endif\n@@ -57,0 +60,1 @@\n+#if defined(__GLIBC)\n@@ -69,0 +73,5 @@\n+#else\n+int glibc_has_pthread_get_minstack() {\n+  return 0;\n+}\n+#endif\n","filename":"test\/hotspot\/jtreg\/runtime\/TLS\/exestack-tls.c","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+    vm.musl \\\n","filename":"test\/jdk\/TEST.ROOT","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,3 @@\n+ * @comment Under musl, dlclose is a no-op. The static variable 'count' in libnative.c\n+ * keeps its value across a GC and the check in Test.java fails.\n+ * @requires !vm.musl\n","filename":"test\/jdk\/java\/lang\/ClassLoader\/nativeLibrary\/NativeLibraryTest.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -403,2 +403,2 @@\n-                check(new File(\"\/bin\/true\").exists());\n-                check(new File(\"\/bin\/false\").exists());\n+                check(new File(TrueExe.path()).exists());\n+                check(new File(FalseExe.path()).exists());\n@@ -445,1 +445,1 @@\n-                        copy(\"\/bin\/true\", \"dir2\/prog\");\n+                        copy(TrueExe.path(), \"dir2\/prog\");\n@@ -451,1 +451,1 @@\n-                        copy(\"\/bin\/true\", \"dir1\/prog\");\n+                        copy(TrueExe.path(), \"dir1\/prog\");\n@@ -467,1 +467,1 @@\n-                            copy(\"\/bin\/true\", \".\/prog\");\n+                            copy(TrueExe.path(), \".\/prog\");\n@@ -470,1 +470,1 @@\n-                            copy(\"\/bin\/false\", \".\/prog\");\n+                            copy(FalseExe.path(), \".\/prog\");\n@@ -525,2 +525,2 @@\n-                        copy(\"\/bin\/true\", \"dir1\/prog\");\n-                        copy(\"\/bin\/false\", \"dir3\/prog\");\n+                        copy(TrueExe.path(), \"dir1\/prog\");\n+                        copy(FalseExe.path(), \"dir3\/prog\");\n@@ -529,2 +529,2 @@\n-                        copy(\"\/bin\/true\", \"dir3\/prog\");\n-                        copy(\"\/bin\/false\", \"dir1\/prog\");\n+                        copy(TrueExe.path(), \"dir3\/prog\");\n+                        copy(FalseExe.path(), \"dir1\/prog\");\n@@ -627,0 +627,7 @@\n+    static class BusyBox {\n+        public static boolean is() { return is; }\n+        private static final boolean is =\n+            (! Windows.is() &&\n+             new File(\"\/bin\/busybox\").exists());\n+    }\n+\n@@ -665,0 +672,39 @@\n+    \/\/ On alpine linux, \/bin\/true and \/bin\/false are just links to \/bin\/busybox.\n+    \/\/ Some tests copy \/bin\/true and \/bin\/false to files with a different filename.\n+    \/\/ However, copying the busbox executable into a file with a different name\n+    \/\/ won't result in the expected return codes. As workaround, we create\n+    \/\/ executable files that can be copied and produce the exepected return\n+    \/\/ values. We use this workaround, if we find the busybox executable.\n+\n+    private static class TrueExe {\n+        public static String path() { return path; }\n+        private static final String path = path0();\n+        private static String path0(){\n+            if (!BusyBox.is()) {\n+                return \"\/bin\/true\";\n+            }\n+            else {\n+                File trueExe = new File(\"true\");\n+                setFileContents(trueExe, \"#!\/bin\/true\\n\");\n+                trueExe.setExecutable(true);\n+                return trueExe.getAbsolutePath();\n+            }\n+        }\n+    }\n+\n+    private static class FalseExe {\n+        public static String path() { return path; }\n+        private static final String path = path0();\n+        private static String path0(){\n+            if (!BusyBox.is()) {\n+                return \"\/bin\/false\";\n+            }\n+            else {\n+                File falseExe = new File(\"false\");\n+                setFileContents(falseExe, \"#!\/bin\/false\\n\");\n+                falseExe.setExecutable(true);\n+                return falseExe.getAbsolutePath();\n+            }\n+        }\n+    }\n+\n@@ -1968,1 +2014,1 @@\n-                copy(\"\/bin\/true\", \"suBdiR\/unliKely\");\n+                copy(TrueExe.path(), \"suBdiR\/unliKely\");\n","filename":"test\/jdk\/java\/lang\/ProcessBuilder\/Basic.java","additions":57,"deletions":11,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -301,1 +301,8 @@\n-                    String expected = Platform.isWindows() ? \"sleep.exe\" : \"sleep\";\n+                    String expected = \"sleep\";\n+                    if (Platform.isWindows()) {\n+                        expected = \"sleep.exe\";\n+                    } else if (new File(\"\/bin\/busybox\").exists()) {\n+                        \/\/ With busybox sleep is just a sym link to busybox.\n+                        \/\/ The busbox executable is seen as ProcessHandle.Info command.\n+                        expected = \"busybox\";\n+                    }\n","filename":"test\/jdk\/java\/lang\/ProcessHandle\/InfoTest.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -138,0 +138,2 @@\n+        boolean isExpandedLibPath = TestHelper.isExpandedSharedLibraryPath;\n+\n@@ -140,1 +142,1 @@\n-                if (TestHelper.isAIX && x.startsWith(LD_LIBRARY_PATH)) {\n+                if (isExpandedLibPath && x.startsWith(LD_LIBRARY_PATH)) {\n@@ -143,5 +145,9 @@\n-                    String aixLibPath = LD_LIBRARY_PATH + \"=\" +\n-                        System.getenv(LD_LIBRARY_PATH) +\n-                        System.getProperty(\"path.separator\") + LD_LIBRARY_PATH_VALUE;\n-                    if (!tr.matches(aixLibPath)) {\n-                        flagError(tr, \"FAIL: did not get <\" + aixLibPath + \">\");\n+                    \/\/ The musl library loader requires LD_LIBRARY_PATH to be set in\n+                    \/\/ order to correctly resolve the dependency libjava.so has on libjvm.so.\n+                    String expandedLibPath = String.format(\"%s=%s%c%s\",\n+                            LD_LIBRARY_PATH,\n+                            System.getenv(LD_LIBRARY_PATH),\n+                            File.pathSeparatorChar,\n+                            LD_LIBRARY_PATH_VALUE);\n+                    if (!tr.matches(expandedLibPath)) {\n+                        flagError(tr, \"FAIL: did not get <\" + expandedLibPath + \">\");\n","filename":"test\/jdk\/tools\/launcher\/ExecutionEnvironment.java","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -158,1 +158,1 @@\n-                    if (TestHelper.isAIX) {\n+                    if (TestHelper.isExpandedSharedLibraryPath) {\n@@ -168,1 +168,1 @@\n-                    if (TestHelper.isAIX) {\n+                    if (TestHelper.isExpandedSharedLibraryPath) {\n","filename":"test\/jdk\/tools\/launcher\/Test7029048.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -92,0 +92,1 @@\n+    static final boolean isMusl = isMuslLibc();\n@@ -95,0 +96,1 @@\n+    static final boolean isExpandedSharedLibraryPath = isAIX || isMusl;\n@@ -535,0 +537,21 @@\n+    \/**\n+     * Check if we run with musl libc.\n+     *\n+     * @return true if we run with musl libc.\n+     *\/\n+    private static boolean isMuslLibc() {\n+        try {\n+            ProcessBuilder pb = new ProcessBuilder(\"ldd\", \"--version\");\n+            pb.redirectErrorStream(true);\n+            final Process p = pb.start();\n+            try (BufferedReader br = new BufferedReader(new InputStreamReader(p.getInputStream()))) {\n+                return br.lines()\n+                        .findFirst()\n+                        .filter(line -> line.contains(\"musl\"))\n+                        .isPresent();\n+            }\n+        } catch (Exception ignore) {\n+        }\n+        return false;\n+    }\n+\n","filename":"test\/jdk\/tools\/launcher\/TestHelper.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import java.io.BufferedReader;\n@@ -29,0 +30,1 @@\n+import java.io.InputStreamReader;\n@@ -118,0 +120,1 @@\n+        map.put(\"vm.musl\", this::isMusl);\n@@ -517,0 +520,20 @@\n+    \/**\n+     * Check if we run with musl libc.\n+     *\n+     * @return true if we run with musl libc.\n+     *\/\n+    protected String isMusl() {\n+        try {\n+            ProcessBuilder pb = new ProcessBuilder(\"ldd\", \"--version\");\n+            pb.redirectErrorStream(true);\n+            final Process p = pb.start();\n+            BufferedReader br = new BufferedReader(new InputStreamReader(p.getInputStream()));\n+            String line = br.readLine();\n+            if (line != null && line.contains(\"musl\")) {\n+                return \"true\";\n+            }\n+        } catch (Exception e) {\n+        }\n+        return \"false\";\n+    }\n+\n","filename":"test\/jtreg-ext\/requires\/VMProps.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"}]}