{"files":[{"patch":"@@ -56,1 +56,1 @@\n-  $(call info-file-item, \"LIBC\", \"$(OPENJDK_TARGET_LIBC)\")\n+  $(call info-file-item, \"LIBC\", \"$(RELEASE_FILE_LIBC)\")\n","filename":"make\/ReleaseFile.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,3 +33,3 @@\n-# config.guess doesn't identify systems running the musl C library, and will\n-# instead return a string with a -gnu suffix. This block detects musl and\n-# modifies the string to have a -musl suffix instead. \n+# Detect C library.\n+# Use '-gnu'  suffix on systems that use glibc.\n+# Use '-musl' suffix on systems that use the musl libc.\n@@ -38,2 +38,2 @@\n-  ldd_version=`ldd --version 2>&1 | head -1 | cut -f1 -d' '`\n-  if [ x\"${ldd_version}\" = x\"musl\" ]; then\n+  libc_vendor=`ldd --version 2>&1 | sed -n '1s\/.*\\(musl\\).*\/\\1\/p'`\n+  if [ x\"${libc_vendor}\" = x\"musl\" ]; then\n","filename":"make\/autoconf\/build-aux\/config.guess","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -32,2 +32,2 @@\n-if [ \"$1\"x = \"x86_64-unknown-linux-musl\"x ]; then\n-    echo $1\n+if echo $* | grep linux-musl >\/dev\/null ; then\n+    echo $*\n","filename":"make\/autoconf\/build-aux\/config.sub","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -557,0 +557,5 @@\n+  OS_CFLAGS=\"$OS_CFLAGS -DLIBC=$OPENJDK_TARGET_LIBC\"\n+  if test \"x$OPENJDK_TARGET_LIBC\" = xmusl; then\n+    OS_CFLAGS=\"$OS_CFLAGS -DMUSL_LIBC\"\n+  fi\n+\n","filename":"make\/autoconf\/flags-cflags.m4","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -221,0 +221,1 @@\n+])\n@@ -222,0 +223,5 @@\n+# Support macro for PLATFORM_EXTRACT_TARGET_AND_BUILD.\n+# Converts autoconf style OS name to OpenJDK style, into\n+# VAR_LIBC.\n+AC_DEFUN([PLATFORM_EXTRACT_VARS_FROM_LIBC],\n+[\n@@ -252,1 +258,1 @@\n-  # Convert the autoconf OS\/CPU value to our own data, into the VAR_OS\/CPU variables.\n+  # Convert the autoconf OS\/CPU value to our own data, into the VAR_OS\/CPU\/LIBC variables.\n@@ -255,0 +261,1 @@\n+  PLATFORM_EXTRACT_VARS_FROM_LIBC($build_os)\n@@ -289,1 +296,1 @@\n-  # Convert the autoconf OS\/CPU value to our own data, into the VAR_OS\/CPU variables.\n+  # Convert the autoconf OS\/CPU value to our own data, into the VAR_OS\/CPU\/LIBC variables.\n@@ -292,0 +299,1 @@\n+  PLATFORM_EXTRACT_VARS_FROM_LIBC($host_os)\n@@ -451,1 +459,1 @@\n-  if test \"x$OPENJDK_$1_LIBC\" = \"xmusl\"; then  \n+  if test \"x$OPENJDK_$1_LIBC\" = \"xmusl\"; then\n@@ -560,0 +568,1 @@\n+  RELEASE_FILE_LIBC=${OPENJDK_TARGET_LIBC}\n@@ -563,0 +572,1 @@\n+  AC_SUBST(RELEASE_FILE_LIBC)\n","filename":"make\/autoconf\/platform.m4","additions":13,"deletions":3,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -126,0 +126,1 @@\n+RELEASE_FILE_LIBC:=@RELEASE_FILE_LIBC@\n@@ -848,1 +849,0 @@\n-INCLUDE_SA_ATTACH=@INCLUDE_SA_ATTACH@\n","filename":"make\/autoconf\/spec.gmk.in","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -64,4 +64,0 @@\n-ifneq ($(HOTSPOT_TARGET_LIBC),)\n-  LIBC_DEFINE := -DHOTSPOT_LIBC='\"$(HOTSPOT_TARGET_LIBC)\"'\n-endif\n-\n@@ -75,1 +71,0 @@\n-    $(LIBC_DEFINE) \\\n","filename":"make\/hotspot\/lib\/CompileJvm.gmk","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -69,4 +69,0 @@\n-ifneq ($(HOTSPOT_TARGET_LIBC),)\n-  JVM_CFLAGS_TARGET_DEFINES += -DHOTSPOT_LIBC='\"$(HOTSPOT_TARGET_LIBC)\"'\n-endif\n-\n","filename":"make\/hotspot\/lib\/JvmFlags.gmk","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -184,2 +184,0 @@\n-LIBJLI_CFLAGS += -DLIBC=\\\"$(OPENJDK_TARGET_LIBC)\\\"\n-\n","filename":"make\/modules\/java.base\/lib\/CoreLibraries.gmk","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,2 +51,0 @@\n-SA_CFLAGS += -DLIBC=\\\"$(OPENJDK_TARGET_LIBC)\\\"\n-\n","filename":"make\/modules\/jdk.hotspot.agent\/Lib.gmk","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-    DISABLED_WARNINGS_gcc := stringop-truncation, \\\n","filename":"make\/modules\/jdk.jdwp.agent\/Lib.gmk","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -96,5 +96,0 @@\n-ifeq ($(OPENJDK_TARGET_LIBC), musl)\n-  # 'strncpy' output truncated before terminating nul copying as many bytes from a string as its length\n-  BUILD_JDK_JTREG_LIBRARIES_CFLAGS_libInheritedChannel := -Wno-stringop-truncation -Wno-stringop-overflow\n-endif\n-\n","filename":"make\/test\/JtregNativeJdk.gmk","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -137,0 +137,11 @@\n+#ifdef MUSL_LIBC\n+\/\/ dlvsym is not a part of POSIX\n+\/\/ and musl libc doesn't implement it.\n+static void *dlvsym(void *handle,\n+                    const char *symbol,\n+                    const char *version) {\n+   \/\/ load the latest version of symbol\n+   return dlsym(handle, symbol);\n+}\n+#endif\n+\n@@ -156,2 +167,2 @@\n-const char * os::Linux::_glibc_version = \"unknown\";\n-const char * os::Linux::_libpthread_version = \"unknown\";\n+const char * os::Linux::_libc_version = NULL;\n+const char * os::Linux::_libpthread_version = NULL;\n@@ -610,8 +621,11 @@\n-  size_t n;\n-\n-  n = confstr(_CS_GNU_LIBC_VERSION, NULL, 0);\n-  if (n > 0) {\n-    char* str = (char *)malloc(n, mtInternal);\n-    confstr(_CS_GNU_LIBC_VERSION, str, n);\n-    os::Linux::set_glibc_version(str);\n-  }\n+#ifdef MUSL_LIBC\n+  \/\/ confstr() from musl libc returns EINVAL for\n+  \/\/ _CS_GNU_LIBC_VERSION and _CS_GNU_LIBPTHREAD_VERSION\n+  os::Linux::set_libc_version(\"unknown\");\n+  os::Linux::set_libpthread_version(\"unknown\");\n+#else\n+  size_t n = confstr(_CS_GNU_LIBC_VERSION, NULL, 0);\n+  assert(n > 0, \"cannot retrieve glibc version\");\n+  char *str = (char *)malloc(n, mtInternal);\n+  confstr(_CS_GNU_LIBC_VERSION, str, n);\n+  os::Linux::set_libc_version(str);\n@@ -620,5 +634,5 @@\n-  if (n > 0) {\n-    char* str = (char *)malloc(n, mtInternal);\n-    confstr(_CS_GNU_LIBPTHREAD_VERSION, str, n);\n-    os::Linux::set_libpthread_version(str);\n-  }\n+  assert(n > 0, \"cannot retrieve pthread version\");\n+  str = (char *)malloc(n, mtInternal);\n+  confstr(_CS_GNU_LIBPTHREAD_VERSION, str, n);\n+  os::Linux::set_libpthread_version(str);\n+#endif\n@@ -2322,1 +2336,1 @@\n-  st->print(\"%s \", os::Linux::glibc_version());\n+  st->print(\"%s \", os::Linux::libc_version());\n@@ -3273,20 +3287,0 @@\n-static void* dlvsym_if_available(void* handle, const char* name, const char* version) {\n-  typedef void* (*dlvsym_func_type)(void* handle, const char* name, const char* version);\n-  static dlvsym_func_type dlvsym_func;\n-  static bool initialized = false;\n-\n-  if (!initialized) {\n-    dlvsym_func = (dlvsym_func_type)dlsym(RTLD_NEXT, \"dlvsym\");\n-    initialized = true;\n-  }\n-\n-  if (dlvsym_func != NULL) {\n-    void *f = dlvsym_func(handle, name, version);\n-    if (f != NULL) {\n-      return f;\n-    }\n-  }\n-\n-  return dlsym(handle, name);\n-}\n-\n@@ -3296,1 +3290,5 @@\n-  return dlvsym_if_available(handle, name, \"libnuma_1.1\");\n+  void *f = dlvsym(handle, name, \"libnuma_1.1\");\n+  if (f == NULL) {\n+    f = dlsym(handle, name);\n+  }\n+  return f;\n@@ -3302,1 +3300,1 @@\n-  return dlvsym_if_available(handle, name, \"libnuma_1.2\");\n+  return dlvsym(handle, name, \"libnuma_1.2\");\n@@ -3311,0 +3309,2 @@\n+      set_numa_node_to_cpus_v2(CAST_TO_FN_PTR(numa_node_to_cpus_v2_func_t,\n+                                              libnuma_v2_dlsym(handle, \"numa_node_to_cpus\")));\n@@ -3449,0 +3449,20 @@\n+int os::Linux::numa_node_to_cpus(int node, unsigned long *buffer, int bufferlen) {\n+  \/\/ use the latest version of numa_node_to_cpus if available\n+  if (_numa_node_to_cpus_v2 != NULL) {\n+\n+    \/\/ libnuma bitmask struct\n+    struct bitmask {\n+      unsigned long size; \/* number of bits in the map *\/\n+      unsigned long *maskp;\n+    };\n+\n+    struct bitmask mask;\n+    mask.maskp = (unsigned long *)buffer;\n+    mask.size = bufferlen * 8;\n+    return _numa_node_to_cpus_v2(node, &mask);\n+  } else if (_numa_node_to_cpus != NULL) {\n+    return _numa_node_to_cpus(node, buffer, bufferlen);\n+  }\n+  return -1;\n+}\n+\n@@ -3460,0 +3480,1 @@\n+os::Linux::numa_node_to_cpus_v2_func_t os::Linux::_numa_node_to_cpus_v2;\n@@ -5259,4 +5280,3 @@\n-\/\/ grsecurity in the kernel by default. Of particular interest from a\n-\/\/ JVM perspective is PaX (https:\/\/pax.grsecurity.net\/), which adds\n-\/\/ some security features related to page attributes. Specifically,\n-\/\/ the MPROTECT PaX functionality\n+\/\/ grsecurity in the kernel. Of particular interest from a JVM perspective\n+\/\/ is PaX (https:\/\/pax.grsecurity.net\/), which adds some security features\n+\/\/ related to page attributes. Specifically, the MPROTECT PaX functionality\n@@ -5278,0 +5298,1 @@\n+    log_debug(os)(\"os_linux.cpp: check_pax: mmap failed (%s)\" , os::strerror(errno));\n@@ -5283,26 +5304,3 @@\n-    vm_exit_during_initialization(\"Failed to mark memory page as executable\",\n-                                  \"Please check if grsecurity\/PaX is enabled in your kernel.\\n\"\n-                                  \"\\n\"\n-                                  \"For example, you can do this by running (note: you may need root privileges):\\n\"\n-                                  \"\\n\"\n-                                  \"    sysctl kernel.pax.softmode\\n\"\n-                                  \"\\n\"\n-                                  \"If PaX is included in the kernel you will see something like this:\\n\"\n-                                  \"\\n\"\n-                                  \"    kernel.pax.softmode = 0\\n\"\n-                                  \"\\n\"\n-                                  \"In particular, if the value is 0 (zero), then PaX is enabled.\\n\"\n-                                  \"\\n\"\n-                                  \"PaX includes security functionality which interferes with the dynamic code\\n\"\n-                                  \"generation the JVM relies on. Specifically, the MPROTECT functionality as\\n\"\n-                                  \"described on https:\/\/pax.grsecurity.net\/docs\/mprotect.txt is not compatible\\n\"\n-                                  \"with the JVM. If you want to allow the JVM to run you will have to disable PaX.\\n\"\n-                                  \"You can do this on a per-executable basis using the paxctl tool, for example:\\n\"\n-                                  \"\\n\"\n-                                  \"    paxctl -cm bin\/java\\n\"\n-                                  \"\\n\"\n-                                  \"Please note that this modifies the executable binary in-place, so you may want\\n\"\n-                                  \"to make a backup of it first. Also note that you have to repeat this for other\\n\"\n-                                  \"executables like javac, jar, jcmd, etc.\\n\"\n-                                  );\n-\n+    log_debug(os)(\"os_linux.cpp: check_pax: mprotect failed (%s)\" , os::strerror(errno));\n+    vm_exit_during_initialization(\n+      \"Failed to mark memory page as executable - check if grsecurity\/PaX is enabled\");\n@@ -5489,1 +5487,1 @@\n-               Linux::glibc_version(), Linux::libpthread_version());\n+               Linux::libc_version(), Linux::libpthread_version());\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":67,"deletions":69,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-  static const char *_glibc_version;\n+  static const char *_libc_version;\n@@ -78,1 +78,1 @@\n-  static void set_glibc_version(const char *s)      { _glibc_version = s; }\n+  static void set_libc_version(const char *s)       { _libc_version = s; }\n@@ -169,1 +169,1 @@\n-  static const char *glibc_version()          { return _glibc_version; }\n+  static const char *libc_version()           { return _libc_version; }\n@@ -210,0 +210,1 @@\n+  typedef int (*numa_node_to_cpus_v2_func_t)(int node, void *mask);\n@@ -226,0 +227,1 @@\n+  static numa_node_to_cpus_v2_func_t _numa_node_to_cpus_v2;\n@@ -247,0 +249,1 @@\n+  static void set_numa_node_to_cpus_v2(numa_node_to_cpus_v2_func_t func) { _numa_node_to_cpus_v2 = func; }\n@@ -276,3 +279,1 @@\n-  static int numa_node_to_cpus(int node, unsigned long *buffer, int bufferlen) {\n-    return _numa_node_to_cpus != NULL ? _numa_node_to_cpus(node, buffer, bufferlen) : -1;\n-  }\n+  static int numa_node_to_cpus(int node, unsigned long *buffer, int bufferlen);\n","filename":"src\/hotspot\/os\/linux\/os_linux.hpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -77,1 +77,0 @@\n-# include <fpu_control.h>\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/os_linux_aarch64.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1083,1 +1083,1 @@\n-  ScratchBlock **smallest_ptr = NULL, *smallest;\n+  ScratchBlock **smallest_ptr, *smallest;\n","filename":"src\/hotspot\/share\/gc\/shared\/genCollectedHeap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2266,0 +2266,8 @@\n+WB_ENTRY(jstring, WB_GetLibcName(JNIEnv* env, jobject o))\n+  ThreadToNativeFromVM ttn(thread);\n+  jstring info_string = env->NewStringUTF(XSTR(LIBC));\n+  CHECK_JNI_EXCEPTION_(env, NULL);\n+\n+  return info_string;\n+WB_END\n+\n@@ -2516,0 +2524,1 @@\n+  {CC\"getLibcName\",     CC\"()Ljava\/lang\/String;\",     (void*)&WB_GetLibcName},\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -260,2 +260,2 @@\n-  #ifdef HOTSPOT_LIBC\n-    #define LIBC_STR \"-\" HOTSPOT_LIBC\n+  #ifdef MUSL_LIBC\n+    #define LIBC_STR \"-\" XSTR(LIBC)\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -239,7 +239,1 @@\n-        \/\/ ENOEXEC indicates that the file header was not recognized. The musl C\n-        \/\/ library does not implement the fallback to \/bin\/sh for that case, so fall\n-        \/\/ through to the code below which implements that fallback using\n-        \/\/ execve_with_shell_fallback.\n-        if (errno != ENOEXEC) {\n-            return;\n-        }\n+        return;\n","filename":"src\/java.base\/unix\/native\/libjava\/childproc.c","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -233,31 +233,6 @@\n-#ifdef __linux\n-#ifndef LIBC\n-#error \"LIBC not set\"\n-#endif\n-\n-    if (strcmp(LIBC, \"musl\") == 0) {\n-      \/*\n-       * The musl library loader requires LD_LIBRARY_PATH to be set in\n-       * order to correctly resolve the dependency libjava.so has on libjvm.so.\n-       *\n-       * Specifically, it differs from glibc in the sense that even if\n-       * libjvm.so has already been loaded it will not be considered a\n-       * candidate for resolving the dependency unless the *full* path\n-       * of the already loaded library matches the dependency being loaded.\n-       *\n-       * libjvm.so is being loaded by the launcher using a long path to\n-       * dlopen, not just the basename of the library. Typically this\n-       * is something like \"..\/lib\/server\/libjvm.so\". However, if\/when\n-       * libjvm.so later tries to dlopen libjava.so (which it does in\n-       * order to get access to a few functions implemented in\n-       * libjava.so) the musl loader will, as part of loading\n-       * dependent libraries, try to load libjvm.so using only its\n-       * basename \"libjvm.so\". Since this does not match the longer\n-       * path path it was first loaded with, the already loaded\n-       * library is not considered a candidate, and the loader will\n-       * instead look for libjvm.so elsewhere. If it's not in\n-       * LD_LIBRARY_PATH the dependency load will fail, and libjava.so\n-       * will therefore fail as well.\n-       *\/\n-      return JNI_TRUE;\n-    }\n+#ifdef MUSL_LIBC\n+    \/*\n+     * The musl library loader requires LD_LIBRARY_PATH to be set in order\n+     * to correctly resolve the dependency libjava.so has on libjvm.so.\n+     *\/\n+    return JNI_TRUE;\n","filename":"src\/java.base\/unix\/native\/libjli\/java_md.c","additions":6,"deletions":31,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -376,4 +376,0 @@\n-#ifndef LIBC\n-#error \"LIBC not set\"\n-#endif\n-\n@@ -414,2 +410,2 @@\n-        if ((strcmp(LIBC, \"musl\")) &&\n-            (existing_map->memsz != page_size) &&\n+\n+        if ((existing_map->memsz != page_size) &&\n","filename":"src\/jdk.hotspot.agent\/linux\/native\/libsaproc\/ps_core.c","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -282,5 +282,6 @@\n-    char buf[200];\n-    if (strerror_r(errno, buf, sizeof(buf) == 0)) {\n-      snprintf(err_buf, err_buf_len, \"ptrace(PTRACE_ATTACH, ..) failed for %d: %s\", pid, buf);\n-      print_error(\"%s\\n\", err_buf);\n-    }\n+    \/\/ To improve portability across platforms and avoid conflicts\n+    \/\/ between GNU and XSI versions of strerror_r, plain strerror is used.\n+    \/\/ It's safe because this code is not used in any multithreaded environment.\n+    char* msg = strerror(errno);\n+    snprintf(err_buf, err_buf_len, \"ptrace(PTRACE_ATTACH, ..) failed for %d: %s\", pid, msg);\n+    print_error(\"%s\\n\", err_buf);\n","filename":"src\/jdk.hotspot.agent\/linux\/native\/libsaproc\/ps_proc.c","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -35,0 +35,6 @@\n+#ifdef LINUX\n+\/\/ Note. On Alpine Linux pthread.h includes calloc\/malloc functions declaration.\n+\/\/ We need to include pthread.h before the following stdlib names poisoning.\n+#include <pthread.h>\n+#endif\n+\n@@ -38,1 +44,1 @@\n-    #define free do_not_use_this_interface_free\n+    #define free(p) Do not use this interface.\n@@ -40,1 +46,1 @@\n-    #define malloc do_not_use_this_interface_malloc\n+    #define malloc(p) Do not use this interface.\n@@ -42,1 +48,1 @@\n-    #define calloc do_not_use_this_interface_calloc\n+    #define calloc(p) Do not use this interface.\n@@ -44,1 +50,1 @@\n-    #define realloc do_not_use_this_interface_realloc\n+    #define realloc(p) Do not use this interface.\n@@ -46,1 +52,1 @@\n-    #define strdup do_not_use_this_interface_strdup\n+    #define strdup(p) Do not use this interface.\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/util.h","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -76,0 +76,1 @@\n+    vm.musl \\\n","filename":"test\/hotspot\/jtreg\/TEST.ROOT","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import jdk.test.lib.Platform;\n@@ -122,1 +123,1 @@\n-                getPid());\n+                \"\" + ProcessHandle.current().pid());\n@@ -127,2 +128,1 @@\n-                System.out.printf(\"(Second VM) Open file descriptors: %s%n\",\n-                        outputContainingFilenames().stream().collect(joining(\"\\n\")));\n+                System.out.println(\"(Second VM) Open file descriptors:\\n\" + outputContainingFilenames().stream().collect(joining(\"\\n\")));\n@@ -175,8 +175,7 @@\n-    static Optional<Command> lsofCommandCache = stream(new Command[]{\n-            new Command(\"\/usr\/bin\/lsof\", \"-p\"),\n-            new Command(\"\/usr\/sbin\/lsof\", \"-p\"),\n-            new Command(\"\/bin\/lsof\", \"-p\"),\n-            new Command(\"\/sbin\/lsof\", \"-p\"),\n-            new Command(\"\/usr\/local\/bin\/lsof\", \"-p\"),\n-        })\n-        .filter(command -> command.exists())\n+    static Optional<String[]> lsofCommandCache = stream(new String[][]{\n+            {\"\/usr\/bin\/lsof\", \"-p\"},\n+            {\"\/usr\/sbin\/lsof\", \"-p\"},\n+            {\"\/bin\/lsof\", \"-p\"},\n+            {\"\/sbin\/lsof\", \"-p\"},\n+            {\"\/usr\/local\/bin\/lsof\", \"-p\"}})\n+        .filter(args -> new File(args[0]).exists())\n@@ -185,1 +184,1 @@\n-    static Optional<Command> lsofCommand() {\n+    static Optional<String[]> lsofCommand() {\n@@ -189,4 +188,0 @@\n-    static Command lsofCmd() {\n-        return lsofCommand().orElseThrow(() -> new RuntimeException(\"lsof like command not found\"));\n-    }\n-\n@@ -194,6 +189,5 @@\n-        String pid = getPid();\n-        Command command = lsofCmd();\n-        System.out.printf(\"using command: %s%n\", command);\n-        return run(command.name, command.option, pid)\n-                .filter(line -> line.contains(pid))\n-                .collect(toList());\n+        long pid = ProcessHandle.current().pid();\n+\n+        String[] command = lsofCommand().orElseThrow(() -> new RuntimeException(\"lsof like command not found\"));\n+        System.out.println(\"using command: \" + command[0] + \" \" + command[1]);\n+        return run(command[0], command[1], \"\" + pid).collect(toList());\n@@ -203,0 +197,5 @@\n+        String pid = Long.toString(ProcessHandle.current().pid());\n+        String[] command = lsofCommand().orElseThrow(() ->\n+                new RuntimeException(\"lsof like command not found\"));\n+        String lsof = command[0];\n+        boolean isBusybox = Platform.isBusybox(lsof);\n@@ -204,0 +203,2 @@\n+            \/\/ lsof from busybox does not support \"-p\" option\n+            .filter(fileName -> !isBusybox || fileName.contains(pid))\n@@ -215,23 +216,0 @@\n-\n-    private static String getPid() {\n-        return Long.toString(ProcessHandle.current().pid());\n-    }\n-\n-    private static class Command {\n-        private final String name;\n-        private final String option;\n-\n-        public Command(String name, String option) {\n-            this.name = name;\n-            this.option = option;\n-        }\n-\n-        private boolean exists() {\n-            return new File(name).exists();\n-        }\n-\n-        public String toString() {\n-            return String.format(\"[name: %s, option: %s]\",\n-                    name, option);\n-        }\n-    }\n","filename":"test\/hotspot\/jtreg\/runtime\/8176717\/TestInheritFD.java","additions":23,"deletions":45,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -95,2 +95,1 @@\n-int get_java_stacksize () {\n-  size_t stacksize;\n+size_t get_java_stacksize () {\n@@ -100,0 +99,2 @@\n+  memset(&jdk_args, 0, (sizeof jdk_args));\n+\n@@ -276,1 +277,1 @@\n-  int stack_size = get_java_stacksize();\n+  size_t stack_size = get_java_stacksize();\n@@ -288,2 +289,2 @@\n-    pthread_create (&thr, &thread_attr, run_java_overflow, NULL);\n-    pthread_join (thr, NULL);\n+    pthread_create(&thr, &thread_attr, run_java_overflow, NULL);\n+    pthread_join(thr, NULL);\n@@ -301,2 +302,2 @@\n-    pthread_create (&thr, &thread_attr, run_native_overflow, NULL);\n-    pthread_join (thr, NULL);\n+    pthread_create(&thr, &thread_attr, run_native_overflow, NULL);\n+    pthread_join(thr, NULL);\n","filename":"test\/hotspot\/jtreg\/runtime\/StackGuardPages\/exeinvoke.c","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -29,0 +29,3 @@\n+ * @comment Calling pthread_getcpuclockid() with invalid pid leads to undefined\n+ * behavior in musl libc (see 8240187).\n+ * @requires !vm.musl\n","filename":"test\/hotspot\/jtreg\/runtime\/jni\/terminatedThread\/TestTerminatedThread.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+ * @library \/test\/lib\n@@ -43,0 +44,1 @@\n+ * @library \/test\/lib\n@@ -66,0 +68,2 @@\n+import jdk.test.lib.Platform;\n+\n@@ -627,7 +631,0 @@\n-    static class BusyBox {\n-        public static boolean is() { return is; }\n-        private static final boolean is =\n-            (! Windows.is() &&\n-             new File(\"\/bin\/busybox\").exists());\n-    }\n-\n@@ -672,1 +669,1 @@\n-    \/\/ On alpine linux, \/bin\/true and \/bin\/false are just links to \/bin\/busybox.\n+    \/\/ On Alpine Linux, \/bin\/true and \/bin\/false are just links to \/bin\/busybox.\n@@ -676,2 +673,2 @@\n-    \/\/ executable files that can be copied and produce the exepected return\n-    \/\/ values. We use this workaround, if we find the busybox executable.\n+    \/\/ executable files that can be copied and produce the expected return\n+    \/\/ values.\n@@ -683,1 +680,1 @@\n-            if (!BusyBox.is()) {\n+            if (!Platform.isBusybox(\"\/bin\/true\")) {\n@@ -685,2 +682,1 @@\n-            }\n-            else {\n+            } else {\n@@ -699,1 +695,1 @@\n-            if (!BusyBox.is()) {\n+            if (!Platform.isBusybox(\"\/bin\/false\")) {\n@@ -701,2 +697,1 @@\n-            }\n-            else {\n+            } else {\n","filename":"test\/jdk\/java\/lang\/ProcessBuilder\/Basic.java","additions":11,"deletions":16,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @requires (os.family == \"windows\")\n@@ -41,5 +42,0 @@\n-        \/\/ windows only\n-        if (!Basic.Windows.is()) {\n-            return;\n-        }\n-\n","filename":"test\/jdk\/java\/lang\/ProcessBuilder\/RedirectWithLongFilename.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -304,1 +304,1 @@\n-                    } else if (new File(\"\/bin\/busybox\").exists()) {\n+                    } else if (Platform.isBusybox(\"\/bin\/sleep\")) {\n","filename":"test\/jdk\/java\/lang\/ProcessHandle\/InfoTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ * @requires os.family != \"windows\" & !vm.musl & os.family != \"aix\"\n@@ -32,1 +33,13 @@\n- * @run main\/othervm ExecutionEnvironment\n+ * @run main\/othervm -DexpandedLdLibraryPath=false ExecutionEnvironment\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 4780570 4731671 6354700 6367077 6670965 4882974\n+ * @summary Checks for LD_LIBRARY_PATH and execution  on *nixes\n+ * @requires os.family == \"aix\" | vm.musl\n+ * @library \/test\/lib\n+ * @modules jdk.compiler\n+ *          jdk.zipfs\n+ * @compile -XDignore.symbol.file ExecutionEnvironment.java\n+ * @run main\/othervm -DexpandedLdLibraryPath=true ExecutionEnvironment\n@@ -86,0 +99,3 @@\n+    static final boolean IS_EXPANDED_LD_LIBRARY_PATH =\n+            Boolean.getBoolean(\"expandedLdLibraryPath\");\n+\n@@ -138,2 +154,0 @@\n-        boolean isExpandedLibPath = TestHelper.isExpandedSharedLibraryPath;\n-\n@@ -142,1 +156,1 @@\n-                if (isExpandedLibPath && x.startsWith(LD_LIBRARY_PATH)) {\n+                if (IS_EXPANDED_LD_LIBRARY_PATH && x.startsWith(LD_LIBRARY_PATH)) {\n@@ -147,7 +161,5 @@\n-                    String expandedLibPath = String.format(\"%s=%s%c%s\",\n-                            LD_LIBRARY_PATH,\n-                            System.getenv(LD_LIBRARY_PATH),\n-                            File.pathSeparatorChar,\n-                            LD_LIBRARY_PATH_VALUE);\n-                    if (!tr.matches(expandedLibPath)) {\n-                        flagError(tr, \"FAIL: did not get <\" + expandedLibPath + \">\");\n+                    String libPath = LD_LIBRARY_PATH + \"=\" +\n+                        System.getenv(LD_LIBRARY_PATH) +\n+                        System.getProperty(\"path.separator\") + LD_LIBRARY_PATH_VALUE;\n+                    if (!tr.matches(libPath)) {\n+                        flagError(tr, \"FAIL: did not get <\" + libPath + \">\");\n@@ -269,4 +281,0 @@\n-        if (isWindows) {\n-            System.err.println(\"Warning: test not applicable to windows\");\n-            return;\n-        }\n","filename":"test\/jdk\/tools\/launcher\/ExecutionEnvironment.java","additions":23,"deletions":15,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @requires os.family != \"windows\" & os.family != \"mac\" & !vm.musl & os.family != \"aix\"\n@@ -31,1 +32,12 @@\n- * @run main Test7029048\n+ * @run main\/othervm -DexpandedLdLibraryPath=false Test7029048\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 7029048 8217340 8217216\n+ * @summary Ensure that the launcher defends against user settings of the\n+ *          LD_LIBRARY_PATH environment variable on Unixes\n+ * @requires os.family == \"aix\" | vm.musl\n+ * @library \/test\/lib\n+ * @compile -XDignore.symbol.file ExecutionEnvironment.java Test7029048.java\n+ * @run main\/othervm -DexpandedLdLibraryPath=true Test7029048\n@@ -62,0 +74,3 @@\n+    static final boolean IS_EXPANDED_LD_LIBRARY_PATH =\n+            Boolean.getBoolean(\"expandedLdLibraryPath\");\n+\n@@ -158,1 +173,1 @@\n-                    if (TestHelper.isExpandedSharedLibraryPath) {\n+                    if (IS_EXPANDED_LD_LIBRARY_PATH) {\n@@ -168,1 +183,1 @@\n-                    if (TestHelper.isExpandedSharedLibraryPath) {\n+                    if (IS_EXPANDED_LD_LIBRARY_PATH) {\n@@ -196,2 +211,2 @@\n-        System.out.printf(\"Skipping test case '%s' because the Aix launcher\" +\n-                          \" adds the paths in any case.%n\", description);\n+        System.out.printf(\"Skipping test case '%s' because the Aix and musl launchers\" +\n+                          \" add the paths in any case.%n\", description);\n@@ -201,4 +216,0 @@\n-        if (TestHelper.isWindows || TestHelper.isMacOSX) {\n-            System.out.println(\"Note: applicable on neither Windows nor MacOSX\");\n-            return;\n-        }\n","filename":"test\/jdk\/tools\/launcher\/Test7029048.java","additions":20,"deletions":9,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -92,1 +92,0 @@\n-    static final boolean isMusl = isMuslLibc();\n@@ -96,1 +95,0 @@\n-    static final boolean isExpandedSharedLibraryPath = isAIX || isMusl;\n@@ -537,21 +535,0 @@\n-    \/**\n-     * Check if we run with musl libc.\n-     *\n-     * @return true if we run with musl libc.\n-     *\/\n-    private static boolean isMuslLibc() {\n-        try {\n-            ProcessBuilder pb = new ProcessBuilder(\"ldd\", \"--version\");\n-            pb.redirectErrorStream(true);\n-            final Process p = pb.start();\n-            try (BufferedReader br = new BufferedReader(new InputStreamReader(p.getInputStream()))) {\n-                return br.lines()\n-                        .findFirst()\n-                        .filter(line -> line.contains(\"musl\"))\n-                        .isPresent();\n-            }\n-        } catch (Exception ignore) {\n-        }\n-        return false;\n-    }\n-\n","filename":"test\/jdk\/tools\/launcher\/TestHelper.java","additions":0,"deletions":23,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import java.io.BufferedReader;\n@@ -30,1 +29,0 @@\n-import java.io.InputStreamReader;\n@@ -521,1 +519,1 @@\n-     * Check if we run with musl libc.\n+     * Checks musl libc.\n@@ -523,1 +521,1 @@\n-     * @return true if we run with musl libc.\n+     * @return true if musl libc is used.\n@@ -526,12 +524,1 @@\n-        try {\n-            ProcessBuilder pb = new ProcessBuilder(\"ldd\", \"--version\");\n-            pb.redirectErrorStream(true);\n-            final Process p = pb.start();\n-            BufferedReader br = new BufferedReader(new InputStreamReader(p.getInputStream()));\n-            String line = br.readLine();\n-            if (line != null && line.contains(\"musl\")) {\n-                return \"true\";\n-            }\n-        } catch (Exception e) {\n-        }\n-        return \"false\";\n+        return Boolean.toString(WB.getLibcName().contains(\"musl\"));\n","filename":"test\/jtreg-ext\/requires\/VMProps.java","additions":3,"deletions":16,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -112,0 +112,12 @@\n+    public static boolean isBusybox(String tool) {\n+        try {\n+            Path toolpath = Paths.get(tool);\n+            return !isWindows()\n+                    && Files.isSymbolicLink(toolpath)\n+                    && Paths.get(\"\/bin\/busybox\")\n+                        .equals(Files.readSymbolicLink(toolpath));\n+        } catch (IOException ignore) {\n+            return false;\n+        }\n+    }\n+\n","filename":"test\/lib\/jdk\/test\/lib\/Platform.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -618,0 +618,3 @@\n+  \/\/ libc name\n+  public native String getLibcName();\n+\n","filename":"test\/lib\/sun\/hotspot\/WhiteBox.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"}]}