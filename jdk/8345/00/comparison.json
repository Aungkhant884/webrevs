{"files":[{"patch":"@@ -0,0 +1,239 @@\n+\/*\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 5106309\n+ * @key headful\n+ * @summary Verifies that XOR mode works properly for all pipelines\n+ * (for both simple Colors and complex Paints).\n+ *\n+ * @requires (os.family == \"windows\")\n+ * @run main\/othervm XORPaint\n+ * @run main\/othervm -Dsun.java2d.d3d=True -Dsun.java2d.uiScale=1 XORPaint\n+ * @run main\/othervm -Dsun.java2d.d3d=True -Dsun.java2d.uiScale=1.25 XORPaint\n+ * @run main\/othervm -Dsun.java2d.d3d=True -Dsun.java2d.uiScale=1.5 XORPaint\n+ * @run main\/othervm -Dsun.java2d.d3d=True -Dsun.java2d.uiScale=1.75 XORPaint\n+ * @run main\/othervm -Dsun.java2d.d3d=True -Dsun.java2d.uiScale=2 XORPaint\n+ * @run main\/othervm -Dsun.java2d.d3d=false -Dsun.java2d.uiScale=1 XORPaint\n+ * @run main\/othervm -Dsun.java2d.d3d=false -Dsun.java2d.uiScale=1.25 XORPaint\n+ * @run main\/othervm -Dsun.java2d.d3d=false -Dsun.java2d.uiScale=1.5 XORPaint\n+ * @run main\/othervm -Dsun.java2d.d3d=false -Dsun.java2d.uiScale=1.75 XORPaint\n+ * @run main\/othervm -Dsun.java2d.d3d=false -Dsun.java2d.uiScale=2 XORPaint\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 5106309\n+ * @key headful\n+ * @summary Verifies that XOR mode works properly for all pipelines\n+ * (for both simple Colors and complex Paints).\n+ *\n+ * @requires (os.family == \"mac\")\n+ * @run main\/othervm XORPaint\n+ * @run main\/othervm -Dsun.java2d.opengl=True -Dsun.java2d.uiScale=1 XORPaint\n+ * @run main\/othervm -Dsun.java2d.opengl=True -Dsun.java2d.uiScale=2 XORPaint\n+ * @run main\/othervm -Dsun.java2d.metal=True -Dsun.java2d.uiScale=1 XORPaint\n+ * @run main\/othervm -Dsun.java2d.metal=True -Dsun.java2d.uiScale=2 XORPaint\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 5106309\n+ * @key headful\n+ * @summary Verifies that XOR mode works properly for all pipelines\n+ * (for both simple Colors and complex Paints).\n+ *\n+ * @requires (os.family == \"linux\")\n+ * @run main\/othervm XORPaint\n+ * @run main\/othervm -Dsun.java2d.xrender=True -Dsun.java2d.uiScale=1 XORPaint\n+ * @run main\/othervm -Dsun.java2d.xrender=True -Dsun.java2d.uiScale=2 XORPaint\n+ * @run main\/othervm -Dsun.java2d.xrender=false -Dsun.java2d.uiScale=1 XORPaint\n+ * @run main\/othervm -Dsun.java2d.xrender=false -Dsun.java2d.uiScale=2 XORPaint\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.EventQueue;\n+import java.awt.Font;\n+import java.awt.Frame;\n+import java.awt.GradientPaint;\n+import java.awt.Graphics;\n+import java.awt.Graphics2D;\n+import java.awt.Panel;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.RenderingHints;\n+import java.awt.Robot;\n+import java.awt.Toolkit;\n+import java.awt.image.BufferedImage;\n+import java.io.File;\n+import java.io.IOException;\n+import javax.imageio.ImageIO;\n+\n+public class XORPaint extends Panel {\n+\n+    private static final int WHITE = 0xffffffff;\n+    private static final int BLUE  = 0xff0000ff;\n+\n+    public void paint(Graphics g) {\n+        Graphics2D g2d = (Graphics2D)g;\n+\n+        g2d.setColor(Color.white);\n+        g2d.fillRect(0, 0, getWidth(), getHeight());\n+\n+        \/\/ render the tests without antialiasing\n+        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n+                             RenderingHints.VALUE_ANTIALIAS_OFF);\n+        renderTests(g2d, \"This is non-AA text\");\n+\n+        \/\/ now do the above tests again, this time with antialiasing\n+        g2d.translate(0, 100);\n+        g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n+                             RenderingHints.VALUE_ANTIALIAS_ON);\n+        renderTests(g2d, \"This is AA text\");\n+    }\n+\n+    private void renderTests(Graphics2D g2d, String text) {\n+        g2d.setFont(new Font(\"Dialog\", Font.PLAIN, 12));\n+        g2d.setColor(Color.blue);\n+        g2d.setXORMode(Color.white);\n+\n+        \/\/ fill a rectangle once and make sure it is blue\n+        g2d.fillRect(5, 5, 20, 20);\n+\n+        \/\/ fill another rectangle twice and make sure it is reversible\n+        \/\/ (should produce the background color)\n+        g2d.fillRect(35, 5, 20, 20);\n+        g2d.fillRect(35, 5, 20, 20);\n+\n+        \/\/ draw a string once and make sure it is blue\n+        g2d.drawString(text, 5, 50);\n+\n+        \/\/ draw another string twice and make sure it is reversible\n+        \/\/ (should produce the background color)\n+        g2d.drawString(text, 5, 70);\n+        g2d.drawString(text, 5, 70);\n+\n+        g2d.setPaint(new GradientPaint(0.0f, 0.0f, Color.blue,\n+                                       100.0f, 100.f, Color.blue, true));\n+        g2d.fillRect(70, 5, 20, 20);\n+    }\n+\n+    \/*\n+     * Not great having to allow any tolerance but some of\n+     * the scaling down for screen captures seems to introduce\n+     * tiny rounding errors that aren't consistent.\n+     * Allow a very small tolerance for this\n+     *\/\n+    private static boolean pixelsMatch(int p1, int p2) {\n+        \/\/ note : ignoring alpha\n+        int tol = 1;\n+        int r1 = p1 & 0x00ff0000 >> 16;\n+        int g1 = p1 & 0x0000ff00 >> 8;\n+        int b1 = p1 & 0x000000ff;\n+        int r2 = p2 & 0x00ff0000 >> 16;\n+        int g2 = p2 & 0x0000ff00 >> 8;\n+        int b2 = p2 & 0x000000ff;\n+        int rd = r2 - r1; if (rd < 0) rd = -rd;\n+        int gd = g2 - g1; if (gd < 0) gd = -gd;\n+        int bd = b2 - b1; if (bd < 0) bd = -bd;\n+        return (rd <= tol && gd <= tol && bd <= tol);\n+    }\n+\n+    private static void testPixel(BufferedImage capture,\n+                                  int x, int y, int expectedPixel,\n+                                  String testDesc, boolean expectedRes)\n+    {\n+        int pixel = capture.getRGB(x, y);\n+        if (expectedRes) {\n+            if (!pixelsMatch(pixel, expectedPixel)) {\n+                try {\n+                    ImageIO.write(capture, \"png\", new File(\"capture.png\"));\n+                } catch (IOException e) {\n+                    System.err.println(\"can't write image \" + e);\n+                }\n+                throw new RuntimeException(\n+                        \"Failed: Incorrect color for \" + testDesc\n+                                + \" at (\" + x + \", \" + y + \") \"\n+                                + \"(expected: \" + Integer\n+                                .toHexString(expectedPixel) + \" actual: \"\n+                                + Integer.toHexString(pixel) + \")\");\n+            }\n+        } else {\n+            if (pixelsMatch(pixel, expectedPixel)) {\n+                try {\n+                    ImageIO.write(capture, \"png\", new File(\"capture.png\"));\n+                } catch (IOException e) {\n+                    System.err.println(\"can't write image \" + e);\n+                }\n+                throw new RuntimeException(\n+                        \"Failed: Incorrect color for \" + testDesc +\n+                                \" at (\" + x + \", \" + y + \") \" +\n+                                \" : 0x\" + Integer.toHexString(pixel));\n+            }\n+        }\n+    }\n+\n+    private static void testPixels(BufferedImage capture,\n+                                   int yoff, String type)\n+    {\n+        testPixel(capture, 10,  yoff+10,   BLUE, \"solid rect\"+type , true);\n+        testPixel(capture, 40, yoff+10,  WHITE, \"erased solid rect\"+type, true);\n+\n+        testPixel(capture, 80, yoff+10,   BLUE, \"GradientPaint rect\"+type, true);\n+        testPixel(capture, 5,  yoff+61, WHITE, \"erased text\"+type, true);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        final Frame frame = new Frame(\"XORPaint Test\");\n+        final XORPaint xorPanel = new XORPaint();\n+        EventQueue.invokeAndWait(() -> {\n+            frame.add(xorPanel);\n+            frame.setUndecorated(true);\n+            frame.pack();\n+            frame.setSize(250, 250);\n+            frame.setLocationRelativeTo(null);\n+            frame.setVisible(true);\n+        });\n+\n+        Toolkit.getDefaultToolkit().sync();\n+        Robot robot = new Robot();\n+        robot.waitForIdle();\n+        robot.delay(2000);\n+        Point pt1 = xorPanel.getLocationOnScreen();\n+        Rectangle rect = new Rectangle(pt1.x, pt1.y, 200, 200);\n+        BufferedImage capture = robot.createScreenCapture(rect);\n+\n+        EventQueue.invokeAndWait(() -> frame.dispose());\n+\n+        \/\/ Make sure we have a white background, for starters\n+        testPixel(capture, 180, 180, WHITE, \"background\", true);\n+\n+        \/\/ Test the non-AA primitives\n+        testPixels(capture, 0, \" (non-AA)\");\n+\n+        \/\/ Test the AA primitives\n+        testPixels(capture, 100, \" (AA)\");\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Graphics\/XORPaint.java","additions":239,"deletions":0,"binary":false,"changes":239,"status":"added"}]}