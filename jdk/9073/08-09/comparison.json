{"files":[{"patch":"@@ -1814,1 +1814,0 @@\n-      assert(addp->is_AddP(), \"DecodeN user is not an AddP\");\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -535,0 +535,67 @@\n+\/\/ Validate outputs:\n+\/\/    Check if we can in fact later replace the uses of the\n+\/\/    current Phi by Phi's of individual fields.\n+\/\/    Conditions checked:\n+\/\/       - The only consumers of the Phi are:\n+\/\/           - AddP (with constant offset)\n+\/\/           -   - Load\n+\/\/           - Safepoint\n+\/\/           - uncommon_trap\n+\/\/           - DecodeN\n+\/\/\n+\/\/ TODO: add support for other kind of users.\n+bool ConnectionGraph::can_reduce_this_phi_users(const Node* phi, bool& has_call_as_user) const {\n+  for (DUIterator_Fast imax, i = phi->fast_outs(imax); i < imax; i++) {\n+    Node* use = phi->fast_out(i);\n+\n+    if (use->is_CallStaticJava() || use->Opcode() == Op_SafePoint) {\n+      has_call_as_user = true;\n+\n+      if (use->is_CallStaticJava() && use->as_CallStaticJava()->is_uncommon_trap() == false) {\n+        NOT_PRODUCT(if (TraceReduceAllocationMerges) tty->print_cr(\"Will NOT try to reduce Phi %d. Has Allocate but cannot scalar replace it. CallStaticJava is not a trap.\", phi->_idx);)\n+        return false;\n+      }\n+    }\n+    else if (use->is_AddP()) {\n+      if (use->in(AddPNode::Offset)->find_intptr_t_con(-1) == -1) {\n+        NOT_PRODUCT(if (TraceReduceAllocationMerges) tty->print_cr(\"Will NOT try to reduce Phi %d. Did not find constant input for %d : AddP.\", phi->_idx, use->_idx);)\n+        return false;\n+      }\n+\n+      for (DUIterator_Fast jmax, j = use->fast_outs(jmax); j < jmax; j++) {\n+        Node* use_use = use->fast_out(j);\n+\n+        if (!use_use->is_Load()) {\n+          NOT_PRODUCT(if (TraceReduceAllocationMerges) tty->print_cr(\"Will NOT try to reduce Phi %d. AddP use is not a Load. %d %s\", phi->_idx, use_use->_idx, use_use->Name());)\n+          return false;\n+        }\n+      }\n+    }\n+    else if (use->is_DecodeN()) {\n+      for (DUIterator_Fast jmax, j = use->fast_outs(jmax); j < jmax; j++) {\n+        Node* use_use = use->fast_out(j);\n+\n+        if (!use_use->is_AddP() || use_use->in(AddPNode::Offset)->find_intptr_t_con(-1) == -1) {\n+          NOT_PRODUCT(if (TraceReduceAllocationMerges) tty->print_cr(\"Will NOT try to reduce Phi %d. DecodeN use is not a AddP with constant offset. %d %s\", phi->_idx, use_use->_idx, use_use->Name());)\n+          return false;\n+        }\n+\n+        for (DUIterator_Fast kmax, k = use_use->fast_outs(kmax); k < kmax; k++) {\n+          Node* use_use_use = use_use->fast_out(k);\n+\n+          if (!use_use_use->is_Load()) {\n+            NOT_PRODUCT(if (TraceReduceAllocationMerges) tty->print_cr(\"Will NOT try to reduce Phi %d. DecodeN.AddP use is not a Load. %d %s\", phi->_idx, use_use_use->_idx, use_use_use->Name());)\n+            return false;\n+          }\n+        }\n+      }\n+    }\n+    else {\n+      NOT_PRODUCT(if (TraceReduceAllocationMerges) tty->print_cr(\"Will NOT try to reduce Phi %d. Has Allocate but cannot scalar replace it. One of the uses is: %d %s\", phi->_idx, use->_idx, use->Name());)\n+      return false;\n+    }\n+  }\n+\n+  return true;\n+}\n+\n@@ -547,2 +614,2 @@\n-  \/\/ Ignoring any ConP#Null, is there any of the Phi inputs Non Scalar Replaceable?\n-  bool has_nonnull_nonsr_input = false;\n+  \/\/ Is any of the Phi inputs Non Scalar Replaceable?\n+  bool has_nonsr_input = false;\n@@ -560,2 +627,2 @@\n-  \/\/    Check whether this Phi node actually point to any scalar replaceable\n-  \/\/    Allocate node of the same Klass as the Phi.\n+  \/\/    Check whether this Phi node actually point to only scalar replaceable\n+  \/\/    Allocate nodes of the same Klass as the Phi.\n@@ -573,1 +640,1 @@\n-    has_nonnull_nonsr_input |= !is_sr_input;\n+    has_nonsr_input |= !is_sr_input;\n@@ -592,2 +659,0 @@\n-\n-    klass = input_t->is_instptr()->instance_klass();\n@@ -615,1 +680,1 @@\n-  if (!found_memory_edge && has_nonnull_nonsr_input) {\n+  if (!found_memory_edge && has_nonsr_input) {\n@@ -620,31 +685,3 @@\n-  \/\/ Validate outputs:\n-  \/\/    Check if we can in fact later replace the uses of the\n-  \/\/    current Phi by Phi's of individual fields.\n-  \/\/    Conditions checked:\n-  \/\/       - The only consumers of the Phi are:\n-  \/\/           - AddP (with constant offset)\n-  \/\/           -   - Load\n-  \/\/           - Safepoint\n-  \/\/           - uncommon_trap\n-  \/\/           - DecodeN\n-  \/\/\n-  \/\/ TODO: add support for other kind of users.\n-  for (DUIterator_Fast imax, i = phi->fast_outs(imax); i < imax; i++) {\n-    Node* use = phi->fast_out(i);\n-\n-    if (use->is_CallStaticJava() || use->Opcode() == Op_SafePoint) {\n-      has_call_as_user = true;\n-\n-      if (use->is_CallStaticJava() && use->as_CallStaticJava()->is_uncommon_trap() == false) {\n-        NOT_PRODUCT(if (TraceReduceAllocationMerges) tty->print_cr(\"Will NOT try to reduce Phi %d. Has Allocate but cannot scalar replace it. CallStaticJava is not a trap.\", phi->_idx);)\n-        return false;\n-      }\n-    }\n-    else if (use->is_AddP()) {\n-      if (use->in(AddPNode::Offset)->find_intptr_t_con(-1) == -1) {\n-        NOT_PRODUCT(if (TraceReduceAllocationMerges) tty->print_cr(\"Will NOT try to reduce Phi %d. Did not find constant input for %d : AddP.\", phi->_idx, use->_idx);)\n-        return false;\n-      }\n-\n-      for (DUIterator_Fast jmax, j = use->fast_outs(jmax); j < jmax; j++) {\n-        Node* use_use = use->fast_out(j);\n+  if (can_reduce_this_phi_users(phi, has_call_as_user) == false) {\n+    return false;\n+  }\n@@ -652,5 +689,8 @@\n-        if (!use_use->is_Load()) {\n-          NOT_PRODUCT(if (TraceReduceAllocationMerges) tty->print_cr(\"Will NOT try to reduce Phi %d. AddP use is not a Load. %d %s\", phi->_idx, use_use->_idx, use_use->Name());)\n-          return false;\n-        }\n-      }\n+  \/\/ A few more restrictions apply if there is a SafePoint\/Uncommon Trap using the merge.\n+  if (has_call_as_user) {\n+    \/\/ If one of the inputs of the Phi aren't scalar replaceable we need to bail out because\n+    \/\/ current logic for handling deoptimization doesn't handle merges of scalar replaceable\n+    \/\/ allocations mixed with non-scalar replaceable ones.\n+    if (has_nonsr_input) {\n+      NOT_PRODUCT(if (TraceReduceAllocationMerges) tty->print_cr(\"Will NOT try to reduce Phi %d. One of the inputs is not a scalar replaceable Allocate and the original Phi is used by a Call.\", phi->_idx);)\n+      return false;\n@@ -658,11 +698,0 @@\n-    else if (use->is_DecodeN()) {\n-      for (DUIterator_Fast jmax, j = use->fast_outs(jmax); j < jmax; j++) {\n-        Node* use_use = use->fast_out(j);\n-\n-        if (!use_use->is_AddP()) {\n-          NOT_PRODUCT(if (TraceReduceAllocationMerges) tty->print_cr(\"Will NOT try to reduce Phi %d. DecodeN use is not a Load. %d %s\", phi->_idx, use_use->_idx, use_use->Name());)\n-          return false;\n-        }\n-\n-        for (DUIterator_Fast kmax, k = use_use->fast_outs(kmax); k < kmax; k++) {\n-          Node* use_use_use = use_use->fast_out(k);\n@@ -670,9 +699,4 @@\n-          if (!use_use_use->is_Load()) {\n-            NOT_PRODUCT(if (TraceReduceAllocationMerges) tty->print_cr(\"Will NOT try to reduce Phi %d. DecodeN.AddP use is not a Load. %d %s\", phi->_idx, use_use_use->_idx, use_use_use->Name());)\n-            return false;\n-          }\n-        }\n-      }\n-    }\n-    else {\n-      NOT_PRODUCT(if (TraceReduceAllocationMerges) tty->print_cr(\"Will NOT try to reduce Phi %d. Has Allocate but cannot scalar replace it. One of the uses is: %d %s\", phi->_idx, use->_idx, use->Name());)\n+    \/\/ If the inputs to the original Phi have different Klass'es and the Phi has a SafePoint\/Uncommon trap as a\n+    \/\/ user we can't solve the merge because we can only have one Klass type when rematerializing the objects.\n+    if (mixed_klasses) {\n+      NOT_PRODUCT(if (TraceReduceAllocationMerges) tty->print_cr(\"Will NOT try to reduce Phi %d. Inputs aren't of the same instance klass.\", phi->_idx);)\n@@ -683,5 +707,0 @@\n-  if (mixed_klasses && has_call_as_user) {\n-    NOT_PRODUCT(if (TraceReduceAllocationMerges) tty->print_cr(\"Will NOT try to reduce Phi %d. Inputs aren't of the same instance klass.\", phi->_idx);)\n-    return false;\n-  }\n-\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":88,"deletions":69,"binary":false,"changes":157,"status":"modified"},{"patch":"@@ -607,0 +607,1 @@\n+  bool can_reduce_this_phi_users(const Node* phi, bool& has_call_as_user) const;\n","filename":"src\/hotspot\/share\/opto\/escape.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+    private static Point global = new Point(2022, 2023);\n+\n@@ -299,0 +301,5 @@\n+    @Test\n+    @Arguments({ Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH })\n+    @IR(counts = { IRNode.ALLOC, \"1\" })\n+    int testObjectIdentity(boolean cond, int x, int y) {\n+        Point o = new Point(x, y);\n@@ -300,1 +307,9 @@\n-    \/\/ ------------------ Some Objects Will be Scalar Replaced in These Tests ------------------- \/\/\n+        if (cond) {\n+            o = global;\n+            dummy();\n+        }\n+\n+        dummy();\n+\n+        return o == global ? o.x + o.y : 0;\n+    }\n@@ -305,2 +320,3 @@\n-    @IR(failOn = { IRNode.ALLOC })\n-    int testSubclasses(boolean c1, boolean c2, int x, int y, int w, int z) {\n+    @IR(counts = { IRNode.ALLOC, \"2\" })\n+    \/\/ The merge won't be reduced because there is a SafePoint\/Call referring to the merge\n+    int testSubclassesTrapping(boolean c1, boolean c2, int x, int y, int w, int z) {\n@@ -322,1 +338,1 @@\n-        new G();\n+        dummy();\n@@ -327,0 +343,3 @@\n+    \/\/ ------------------ Some Objects Will be Scalar Replaced in These Tests ------------------- \/\/\n+\n+\n@@ -329,2 +348,3 @@\n-    @IR(counts = { IRNode.ALLOC, \"2\" })\n-    int testSubclassesTrapping(boolean c1, boolean c2, int x, int y, int w, int z) {\n+    @IR(failOn = { IRNode.ALLOC })\n+    \/\/ Since there is no Call\/SafePoint after the merge we can reduce the allocation\n+    int testSubclasses(boolean c1, boolean c2, int x, int y, int w, int z) {\n@@ -346,1 +366,1 @@\n-        dummy();\n+        new G();\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/scalarReplacement\/AllocationMergesTests.java","additions":27,"deletions":7,"binary":false,"changes":34,"status":"modified"}]}