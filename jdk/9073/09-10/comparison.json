{"files":[{"patch":"@@ -478,1 +478,1 @@\n-  product(bool, ReduceAllocationMerges, false,                              \\\n+  product(bool, ReduceAllocationMerges, true,                               \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1720,1 +1720,1 @@\n-  for (uint i = 1, matches = 0; i <= _number_of_bases; i++) {\n+  for (uint i = 1; i <= _number_of_bases; i++) {\n@@ -1725,2 +1725,0 @@\n-      int base_offset = base_idx(base, 0);\n-\n@@ -1737,1 +1735,9 @@\n-            set_req(fields_offset + base_offset, memory);\n+            int base_matches = 0;\n+            int base_offset = base_idx(base, base_matches);\n+\n+            \/\/ We need to check if the same base is used multiple times in the Phi\n+            do {\n+              set_req(fields_offset + base_offset, memory);\n+              base_matches++;\n+              base_offset = base_idx(base, base_matches);\n+            } while (base_offset != -1);\n@@ -1779,2 +1785,1 @@\n-  }\n-  else {\n+  } else {\n@@ -1806,2 +1811,1 @@\n-  }\n-  else if (n->Opcode() == Op_SafePoint || (n->is_CallStaticJava() && n->as_CallStaticJava()->is_uncommon_trap())) {\n+  } else if (n->Opcode() == Op_SafePoint || (n->is_CallStaticJava() && n->as_CallStaticJava()->is_uncommon_trap())) {\n@@ -1810,2 +1814,1 @@\n-  }\n-  else if (n->is_DecodeN()) {\n+  } else if (n->is_DecodeN()) {\n@@ -1816,2 +1819,1 @@\n-  }\n-  else {\n+  } else {\n@@ -1869,2 +1871,1 @@\n-    }\n-    else {\n+    } else {\n@@ -1873,0 +1874,1 @@\n+\n@@ -1877,2 +1879,1 @@\n-  }\n-  else {\n+  } else {\n@@ -1882,0 +1883,5 @@\n+  \/\/ 'decode_narrow' is set to false because consumers of the return of this\n+  \/\/ method expect a Load to be returned.  The returned Load from this method\n+  \/\/ uses an specific base and it will be used to replace a Load where the\n+  \/\/ [AddP] base is a Phi. If the returned Load is a 'LoadN' then so was the\n+  \/\/ original Load.\n@@ -1883,1 +1889,1 @@\n-                                LoadNode::DependsOnlyOnTest, false, false, false, false, (uint8_t)0U, false);\n+                                LoadNode::DependsOnlyOnTest, false, false, false, false, (uint8_t)0U, \/*decode_narrow*\/false);\n@@ -1892,2 +1898,0 @@\n-  ttyLocker ttyl;\n-\n@@ -1905,3 +1909,2 @@\n-    }\n-    \/\/ Somehow the base was eliminated and we still have a memory reference left\n-    else if (input->bottom_type()->base() == Type::Memory) {\n+    } else if (input->bottom_type()->base() == Type::Memory) {\n+      \/\/ Somehow the base was eliminated and we still have a memory reference left\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":25,"deletions":22,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -1021,1 +1021,1 @@\n-\/\/ \/ scalar replacement, if an allocation is used by a RAM node, the nodes\n+\/\/ scalar replacement, if an allocation is used by a RAM node, the nodes\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -432,2 +432,1 @@\n-        }\n-        else {\n+        } else {\n@@ -540,2 +539,1 @@\n-\/\/           - AddP (with constant offset)\n-\/\/           -   - Load\n+\/\/           - AddP (with constant offset) -> Load\n@@ -544,3 +542,1 @@\n-\/\/           - DecodeN\n-\/\/\n-\/\/ TODO: add support for other kind of users.\n+\/\/           - DecodeN -> AddP (with constant offset) -> Load\n@@ -558,2 +554,1 @@\n-    }\n-    else if (use->is_AddP()) {\n+    } else if (use->is_AddP()) {\n@@ -573,2 +568,1 @@\n-    }\n-    else if (use->is_DecodeN()) {\n+    } else if (use->is_DecodeN()) {\n@@ -592,2 +586,1 @@\n-    }\n-    else {\n+    } else {\n@@ -1414,0 +1407,16 @@\n+\/\/ Remove a Phi node (LocalVar) from the graph and update the edges accordingly.\n+\/\/ Note that users of the Phi node that are - due the Phi - fields of multiple\n+\/\/ Java objects will be disconnected from the JavaObject. Given a graph like this:\n+\/\/\n+\/\/ JavaObject(3) NoEscape(NoEscape) Edges: [ 91F 206F       ] Uses: [ 40 45 183   ]   28  Allocate ...\n+\/\/ JavaObject(4) NoEscape(NoEscape) Edges: [ 172F 206F      ] Uses: [ 119 124 183 ]  107  Allocate ...\n+\/\/ LocalVar(11)  NoEscape(NoEscape) Edges: [ 40 28P         ] Uses: [ 183         ]   45  CheckCastPP ...\n+\/\/ LocalVar(12)  NoEscape(NoEscape) Edges: [ 119 107P       ] Uses: [ 183         ]  124  CheckCastPP ...\n+\/\/ LocalVar(14)  NoEscape(NoEscape) Edges: [ 124 45 28P 107P] Uses: [ 206b        ]  183  Phi ...\n+\/\/\n+\/\/ It will become this:\n+\/\/\n+\/\/ JavaObject(3) NoEscape(NoEscape) Edges: [ 91F ----       ] Uses: [ 40 45 ---   ]   28  Allocate ...\n+\/\/ JavaObject(4) NoEscape(NoEscape) Edges: [ 172F ----      ] Uses: [ 119 124 --- ]  107  Allocate ...\n+\/\/ LocalVar(12)  NoEscape(NoEscape) Edges: [ 119 107P       ] Uses: [ ---         ]  124  CheckCastPP ...\n+\/\/ LocalVar(11)  NoEscape(NoEscape) Edges: [ 40 28P         ] Uses: [ ---         ]   45  CheckCastPP ...\n@@ -1433,0 +1442,2 @@\n+    else if (phi_use->ideal_node()->is_DecodeN()) {\n+      phi_ptn->remove_use(phi_use);\n@@ -1434,3 +1445,1 @@\n-    else {\n-      ttyLocker ttyl;\n-      tty->print(\"Trying to remove Phi from ConnectionGraph that has unsupported user:\");\n+    } else {\n@@ -1438,1 +1447,1 @@\n-    }\n+      assert(false, \"Trying to remove Phi from ConnectionGraph that has unsupported user (see dump above).\");\n@@ -1440,0 +1449,1 @@\n+    }\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":27,"deletions":17,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -595,11 +595,0 @@\n-  \/\/ Performs several checks to see if the Phi pointed by 'n'\n-  \/\/ can be reduced into a ReducedAllocationMergeNode. The\n-  \/\/ checks curently implemented are:\n-  \/\/  - The phi node should be NoEscape\n-  \/\/  - The Phi region must not dominate any store to any of the Phi inputs\n-  \/\/  - All inputs to the Phi node should come from an allocate node\n-  \/\/  - All inputs should be NoEscape\n-  \/\/  - The only uses of the Phi should be:\n-  \/\/    - AddP->Load\n-  \/\/    - SafePointNode or uncommon traps\n-  \/\/    - DecodeN->AddP->Loads\n@@ -670,16 +659,0 @@\n-  \/\/ Remove a Phi node (LocalVar) from the graph and update the edges accordingly.\n-  \/\/ Note that users of the Phi node that are - due the Phi - fields of multiple\n-  \/\/ Java objects will be disconnected from the JavaObject. Given a graph like this:\n-  \/\/\n-  \/\/ JavaObject(3) NoEscape(NoEscape) Edges: [ 91F 206F       ] Uses: [ 40 45 183   ]   28  Allocate ...\n-  \/\/ JavaObject(4) NoEscape(NoEscape) Edges: [ 172F 206F      ] Uses: [ 119 124 183 ]  107  Allocate ...\n-  \/\/ LocalVar(11)  NoEscape(NoEscape) Edges: [ 40 28P         ] Uses: [ 183         ]   45  CheckCastPP ...\n-  \/\/ LocalVar(12)  NoEscape(NoEscape) Edges: [ 119 107P       ] Uses: [ 183         ]  124  CheckCastPP ...\n-  \/\/ LocalVar(14)  NoEscape(NoEscape) Edges: [ 124 45 28P 107P] Uses: [ 206b        ]  183  Phi ...\n-  \/\/\n-  \/\/ It will become this:\n-  \/\/\n-  \/\/ JavaObject(3) NoEscape(NoEscape) Edges: [ 91F ----       ] Uses: [ 40 45 ---   ]   28  Allocate ...\n-  \/\/ JavaObject(4) NoEscape(NoEscape) Edges: [ 172F ----      ] Uses: [ 119 124 --- ]  107  Allocate ...\n-  \/\/ LocalVar(12)  NoEscape(NoEscape) Edges: [ 119 107P       ] Uses: [ ---         ]  124  CheckCastPP ...\n-  \/\/ LocalVar(11)  NoEscape(NoEscape) Edges: [ 40 28P         ] Uses: [ ---         ]   45  CheckCastPP ...\n","filename":"src\/hotspot\/share\/opto\/escape.hpp","additions":0,"deletions":27,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -1229,2 +1229,1 @@\n-    }\n-    else {\n+    } else {\n@@ -1252,2 +1251,1 @@\n-    }\n-    else if (use->Opcode() == Op_SafePoint || use->is_CallStaticJava()) {\n+    } else if (use->Opcode() == Op_SafePoint || use->is_CallStaticJava()) {\n@@ -1327,2 +1325,1 @@\n-    }\n-    else if (use->is_DecodeN()) {\n+    } else if (use->is_DecodeN()) {\n@@ -1334,2 +1331,1 @@\n-    }\n-    else {\n+    } else {\n@@ -2855,1 +2851,1 @@\n-#endif\n\\ No newline at end of file\n+#endif\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -859,2 +859,1 @@\n-      ciKlass* cik = t->isa_instptr() != NULL ? t->isa_instptr()->instance_klass()\n-                                              : t->is_oopptr()->exact_klass();\n+      ciKlass* cik = t->is_oopptr()->exact_klass();\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @requires vm.compiler2.enabled\n@@ -343,0 +344,41 @@\n+    @Test\n+    @Warmup(10)\n+    @Arguments({ Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH })\n+    @IR(counts = { IRNode.ALLOC, \"2\" })\n+    \/\/ Not reduced because there is CmpP using the merge\n+    int testCmpMergeWithNull(boolean cond, int x, int y) {\n+        Point p = null;\n+\n+        if (cond)\n+            p = new Point(x*x, y*y);\n+        else if (x == y)\n+            p = new Point(x+y, x*y);\n+\n+        if (p != null)\n+            return p.x * p.y;\n+        else\n+            return 1984;\n+    }\n+\n+    @Test\n+    @Warmup(10)\n+    @Arguments({ Argument.RANDOM_EACH, Argument.RANDOM_EACH })\n+    @IR(counts = { IRNode.ALLOC, \"1\" })\n+    \/\/ Not reduced because not all inputs are SR\n+    int testMultiwayMerge(int x, int y) {\n+        Point p = new Point(0, 0);\n+\n+        if (x == y) {\n+            p = dummy(x, x);\n+        }\n+        else if (dummy(x) == 1) {\n+            p = dummy(x, y);\n+        }\n+        else if (dummy(y) == 1) {\n+            p = dummy(y, x);\n+        }\n+\n+        return p.x;\n+    }\n+\n+\n@@ -372,0 +414,1 @@\n+    @Warmup(10)\n@@ -383,0 +426,13 @@\n+    @Test\n+    @Warmup(10)\n+    @Arguments({ Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH })\n+    @IR(counts = { IRNode.ALLOC, \"0\" })\n+    int testNestedObjectsNoEscapeObject(boolean cond, int x, int y) {\n+        Picture p = new Picture(x, x, y);\n+\n+        if (cond)\n+            p = new Picture(y, y, x);\n+\n+        return p.position.x;\n+    }\n+\n@@ -472,21 +528,0 @@\n-    @Test\n-    @Arguments({ Argument.RANDOM_EACH, Argument.RANDOM_EACH })\n-    @IR(failOn = { IRNode.ALLOC })\n-    \/\/ Object p is scalar replaced because the \"p = dummy(...)\" calls\n-    \/\/ are actually converted to traps and therefore there is no merge phi\n-    int testMultiwayMerge(int x, int y) {\n-        Point p = new Point(0, 0);\n-\n-        if (x == y) {\n-            p = dummy(x, x);\n-        }\n-        else if (dummy(x) == 1) {\n-            p = dummy(x, y);\n-        }\n-        else if (dummy(y) == 1) {\n-            p = dummy(y, x);\n-        }\n-\n-        return p.x;\n-    }\n-\n@@ -570,16 +605,0 @@\n-    @Test\n-    @Arguments({ Argument.RANDOM_EACH, Argument.RANDOM_EACH, Argument.RANDOM_EACH })\n-    @IR(failOn = { IRNode.ALLOC })\n-    int testCmpMergeWithNull(boolean cond, int x, int y) {\n-        Point p = null;\n-\n-        if (cond)\n-            p = new Point(x*x, y*y);\n-        else if (x == y)\n-            p = new Point(x+y, x*y);\n-\n-        if (p != null)\n-            return p.x * p.y;\n-        else\n-            return 1984;\n-    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/scalarReplacement\/AllocationMergesTests.java","additions":56,"deletions":37,"binary":false,"changes":93,"status":"modified"}]}