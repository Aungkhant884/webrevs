{"files":[{"patch":"@@ -1037,1 +1037,1 @@\n-    MemRegion r = heap_info->memregion();\n+    MemRegion r = heap_info->buffer_region();\n@@ -1207,2 +1207,2 @@\n-  char* start = info->start();\n-  size_t size = info->byte_size();\n+  char* start = info->buffer_start();\n+  size_t size = info->buffer_byte_size();\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+uintptr_t ArchiveHeapLoader::_mapped_heap_bottom = 0;\n@@ -62,1 +63,1 @@\n-void ArchiveHeapLoader::init_mapped_heap_relocation(ptrdiff_t delta, int dumptime_oop_shift) {\n+void ArchiveHeapLoader::init_mapped_heap_info(address mapped_heap_bottom, ptrdiff_t delta, int dumptime_oop_shift) {\n@@ -69,0 +70,1 @@\n+  _mapped_heap_bottom = (intptr_t)mapped_heap_bottom;\n@@ -377,0 +379,3 @@\n+    intptr_t bottom = is_loaded() ? _loaded_heap_bottom : _mapped_heap_bottom;\n+    intptr_t roots_oop = bottom + FileMapInfo::current_info()->heap_roots_offset();\n+    HeapShared::init_roots(cast_to_oop(roots_oop));\n","filename":"src\/hotspot\/share\/cds\/archiveHeapLoader.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -105,1 +105,1 @@\n-  static void init_mapped_heap_relocation(ptrdiff_t delta, int dumptime_oop_shift);\n+  static void init_mapped_heap_info(address mapped_heap_bottom, ptrdiff_t delta, int dumptime_oop_shift);\n@@ -127,0 +127,1 @@\n+  static uintptr_t _mapped_heap_bottom;\n","filename":"src\/hotspot\/share\/cds\/archiveHeapLoader.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-GrowableArrayCHeap<u1, mtClassShared>* ArchiveHeapWriter::_buffer;\n+GrowableArrayCHeap<u1, mtClassShared>* ArchiveHeapWriter::_buffer = nullptr;\n@@ -54,1 +54,1 @@\n-size_t ArchiveHeapWriter::_heap_roots_bottom_offset;\n+size_t ArchiveHeapWriter::_heap_roots_offset;\n@@ -156,1 +156,1 @@\n-  return cast_to_oop(_requested_bottom + _heap_roots_bottom_offset);\n+  return cast_to_oop(_requested_bottom + _heap_roots_offset);\n@@ -216,1 +216,1 @@\n-  _heap_roots_bottom_offset = _buffer_used;\n+  _heap_roots_offset = _buffer_used;\n@@ -342,1 +342,12 @@\n-  _requested_bottom = align_down(heap_end - heap_region_byte_size, HeapRegion::GrainBytes);\n+\n+  if (UseCompressedOops) {\n+    _requested_bottom = align_down(heap_end - heap_region_byte_size, HeapRegion::GrainBytes);\n+  } else {\n+    \/\/ We always write the objects as if the heap started at this address. This\n+    \/\/ makes the contents of the archive heap deterministic.\n+    \/\/\n+    \/\/ Note that at runtime, the heap address is selected by the OS, so the archive\n+    \/\/ heap will not be mapped at 0x10000000, and the contents need to be patched.\n+    _requested_bottom = (address)NOCOOPS_REQUESTED_BASE;\n+  }\n+\n@@ -347,2 +358,3 @@\n-  info->set_memregion(MemRegion(offset_to_buffered_address<HeapWord*>(0),\n-                                offset_to_buffered_address<HeapWord*>(_buffer_used)));\n+  info->set_buffer_region(MemRegion(offset_to_buffered_address<HeapWord*>(0),\n+                                    offset_to_buffered_address<HeapWord*>(_buffer_used)));\n+  info->set_heap_roots_offset(_heap_roots_offset);\n@@ -374,3 +386,2 @@\n-void ArchiveHeapWriter::store_oop_in_buffer(oop* buffered_addr, oop requested_obj) {\n-  \/\/ Make heap content deterministic. See comments inside HeapShared::to_requested_address.\n-  *buffered_addr = HeapShared::to_requested_address(requested_obj);\n+inline void ArchiveHeapWriter::store_oop_in_buffer(oop* buffered_addr, oop requested_obj) {\n+  *buffered_addr = requested_obj;\n@@ -379,3 +390,1 @@\n-void ArchiveHeapWriter::store_oop_in_buffer(narrowOop* buffered_addr, oop requested_obj) {\n-  \/\/ Note: HeapShared::to_requested_address() is not necessary because\n-  \/\/ the heap always starts at a deterministic address with UseCompressedOops==true.\n+inline void ArchiveHeapWriter::store_oop_in_buffer(narrowOop* buffered_addr, oop requested_obj) {\n@@ -484,1 +493,1 @@\n-  oop requested_roots = requested_obj_from_buffer_offset(_heap_roots_bottom_offset);\n+  oop requested_roots = requested_obj_from_buffer_offset(_heap_roots_offset);\n","filename":"src\/hotspot\/share\/cds\/archiveHeapWriter.cpp","additions":23,"deletions":14,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-  MemRegion _memregion;\n+  MemRegion _buffer_region;             \/\/ Contains the archived objects to be written into the CDS archive.\n@@ -44,0 +44,2 @@\n+  size_t _heap_roots_offset;            \/\/ Offset of the HeapShared::roots() object, from the bottom\n+                                        \/\/ of the archived heap objects, in bytes.\n@@ -46,2 +48,2 @@\n-  ArchiveHeapInfo() : _memregion(), _oopmap(128, mtClassShared), _ptrmap(128, mtClassShared) {}\n-  bool is_used() { return !_memregion.is_empty(); }\n+  ArchiveHeapInfo() : _buffer_region(), _oopmap(128, mtClassShared), _ptrmap(128, mtClassShared) {}\n+  bool is_used() { return !_buffer_region.is_empty(); }\n@@ -49,2 +51,2 @@\n-  MemRegion memregion() { return _memregion; }\n-  void set_memregion(MemRegion r) { _memregion = r; }\n+  MemRegion buffer_region() { return _buffer_region; }\n+  void set_buffer_region(MemRegion r) { _buffer_region = r; }\n@@ -52,2 +54,2 @@\n-  char* start() { return (char*)_memregion.start(); }\n-  size_t byte_size() { return _memregion.byte_size();    }\n+  char* buffer_start() { return (char*)_buffer_region.start(); }\n+  size_t buffer_byte_size() { return _buffer_region.byte_size();    }\n@@ -57,0 +59,3 @@\n+\n+  void set_heap_roots_offset(size_t n) { _heap_roots_offset = n; }\n+  size_t heap_roots_offset() const { return _heap_roots_offset; }\n@@ -61,0 +66,50 @@\n+  \/\/ ArchiveHeapWriter manipulates three types of addresses:\n+  \/\/\n+  \/\/     \"source\" vs \"buffered\" vs \"requested\"\n+  \/\/\n+  \/\/ (Note: the design and convention is the same as for the archiving of Metaspace objects.\n+  \/\/  See archiveBuilder.hpp.)\n+  \/\/\n+  \/\/ - \"source objects\" are regular Java objects allocated during the execution\n+  \/\/   of \"java -Xshare:dump\". They can be used as regular oops.\n+  \/\/\n+  \/\/   HeapShared::archive_objects() recursively searches for the oops that need to be\n+  \/\/   stored into the CDS archive. These are entered into HeapShared::archived_object_cache().\n+  \/\/\n+  \/\/ - \"buffered objects\" are copies of the \"source objects\", and are stored in into\n+  \/\/   ArchiveHeapWriter::_buffer, which is a GrowableArray that sites outside of\n+  \/\/   the valid heap range. Therefore we avoid using the addresses of these copies\n+  \/\/   as oops. They are usually called \"buffered_addr\" in the code (of the type \"address\").\n+  \/\/\n+  \/\/   The buffered objects are stored contiguously, possibly with interleaving fillers\n+  \/\/   to make sure no objects span across boundaries of MIN_GC_REGION_ALIGNMENT.\n+  \/\/\n+  \/\/ - Each archived object has a \"requested address\" -- at run time, if the object\n+  \/\/   can be mapped at this address, we can avoid relocation.\n+  \/\/\n+  \/\/ The requested address is implemented differently depending on UseCompressedOops:\n+  \/\/\n+  \/\/ UseCompressedOops == true:\n+  \/\/   The archived objects are stored assuming that the runtime COOPS compression\n+  \/\/   scheme is exactly the same as in dump time (or else a more expensive runtime relocation\n+  \/\/   would be needed.)\n+  \/\/\n+  \/\/   At dump time, we assume that the runtime heap range is exactly the same as\n+  \/\/   in dump time. The requested addresses of the archived objects are chosen such that\n+  \/\/   they would occupy the top end of a G1 heap (TBD when dumping is supported by other\n+  \/\/   collectors. See JDK-8298614).\n+  \/\/\n+  \/\/ UseCompressedOops == false:\n+  \/\/   At runtime, the heap range is usually picked (randomly) by the OS, so we will almost always\n+  \/\/   need to perform relocation. Hence, the goal of the \"requested address\" is to ensure that\n+  \/\/   the contents of the archived objects are deterministic. I.e., the oop fields of archived\n+  \/\/   objects will always point to deterministic addresses.\n+  \/\/\n+  \/\/   For G1, the archived heap is written such that the lowest archived object is placed\n+  \/\/   at NOCOOPS_REQUESTED_BASE. (TBD after JDK-8298614).\n+  \/\/ ----------------------------------------------------------------------\n+\n+public:\n+  static const intptr_t NOCOOPS_REQUESTED_BASE = 0x10000000;\n+\n+private:\n@@ -73,17 +128,0 @@\n-  \/\/ \"source\" vs \"buffered\" vs \"requested\"\n-  \/\/\n-  \/\/ [1] HeapShared::archive_objects() identifies all of the oops that need to be stored\n-  \/\/     into the CDS archive. These are entered into HeapShared::archived_object_cache().\n-  \/\/     These are called \"source objects\"\n-  \/\/\n-  \/\/ [2] ArchiveHeapWriter::write() copies all source objects into ArchiveHeapWriter::_buffer,\n-  \/\/     which is a GrowableArray that sites outside of the valid heap range. Therefore\n-  \/\/     we avoid using the addresses of these copies as oops. They are usually\n-  \/\/     called \"buffered_addr\" in the code (of the type \"address\").\n-  \/\/\n-  \/\/ [3] Each archived object has a \"requested address\" -- at run time, if the object\n-  \/\/     can be mapped at this address, we can avoid relocation.\n-  \/\/\n-  \/\/ Note: the design and convention is the same as for the archiving of Metaspace objects.\n-  \/\/ See archiveBuilder.hpp.\n-\n@@ -96,1 +134,1 @@\n-  static size_t _heap_roots_bottom_offset;\n+  static size_t _heap_roots_offset;\n@@ -163,2 +201,2 @@\n-  static void store_oop_in_buffer(oop* buffered_addr, oop requested_obj);\n-  static void store_oop_in_buffer(narrowOop* buffered_addr, oop requested_obj);\n+  inline static void store_oop_in_buffer(oop* buffered_addr, oop requested_obj);\n+  inline static void store_oop_in_buffer(narrowOop* buffered_addr, oop requested_obj);\n@@ -185,1 +223,1 @@\n-    return offset_to_buffered_address<address>(_heap_roots_bottom_offset);\n+    return offset_to_buffered_address<address>(_heap_roots_offset);\n","filename":"src\/hotspot\/share\/cds\/archiveHeapWriter.hpp","additions":66,"deletions":28,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -280,15 +280,0 @@\n-void WriteClosure::do_oop(oop* o) {\n-  if (*o == nullptr) {\n-    _dump_region->append_intptr_t(0);\n-  } else {\n-    assert(HeapShared::can_write(), \"sanity\");\n-    intptr_t p;\n-    if (UseCompressedOops) {\n-      p = (intptr_t)CompressedOops::encode_not_null(*o);\n-    } else {\n-      p = cast_from_oop<intptr_t>(HeapShared::to_requested_address(*o));\n-    }\n-    _dump_region->append_intptr_t(p);\n-  }\n-}\n-\n@@ -337,22 +322,0 @@\n-void ReadClosure::do_oop(oop *p) {\n-  if (UseCompressedOops) {\n-    narrowOop o = CompressedOops::narrow_oop_cast(nextPtr());\n-    if (CompressedOops::is_null(o) || !ArchiveHeapLoader::is_in_use()) {\n-      *p = nullptr;\n-    } else {\n-      assert(ArchiveHeapLoader::can_use(), \"sanity\");\n-      assert(ArchiveHeapLoader::is_in_use(), \"must be\");\n-      *p = ArchiveHeapLoader::decode_from_archive(o);\n-    }\n-  } else {\n-    intptr_t dumptime_oop = nextPtr();\n-    if (dumptime_oop == 0 || !ArchiveHeapLoader::is_in_use()) {\n-      *p = nullptr;\n-    } else {\n-      assert(!ArchiveHeapLoader::is_loaded(), \"ArchiveHeapLoader::can_load() is not supported for uncompessed oops\");\n-      intptr_t runtime_oop = dumptime_oop + ArchiveHeapLoader::mapped_heap_delta();\n-      *p = cast_to_oop(runtime_oop);\n-    }\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.cpp","additions":0,"deletions":37,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"cds\/serializeClosure.hpp\"\n@@ -29,1 +30,0 @@\n-#include \"memory\/iterator.hpp\"\n@@ -205,1 +205,0 @@\n-  void do_oop(oop* o);\n@@ -229,1 +228,0 @@\n-  void do_oop(oop *p);\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -210,11 +210,0 @@\n-    if (UseCompressedOops) {\n-      _heap_begin = CompressedOops::begin();\n-      _heap_end = CompressedOops::end();\n-    } else {\n-#if INCLUDE_G1GC\n-      address start = (address)G1CollectedHeap::heap()->reserved().start();\n-      address end = (address)G1CollectedHeap::heap()->reserved().end();\n-      _heap_begin = HeapShared::to_requested_address(start);\n-      _heap_end = HeapShared::to_requested_address(end);\n-#endif\n-    }\n@@ -289,2 +278,0 @@\n-  st->print_cr(\"- heap_begin:                     \" INTPTR_FORMAT, p2i(_heap_begin));\n-  st->print_cr(\"- heap_end:                       \" INTPTR_FORMAT, p2i(_heap_end));\n@@ -1570,3 +1557,1 @@\n-#if INCLUDE_G1GC\n-      mapping_offset = requested_base - (char*)G1CollectedHeap::heap()->reserved().start();\n-#endif\n+      mapping_offset = 0; \/\/ not used with !UseCompressedOops\n@@ -1637,4 +1622,5 @@\n-  char* start = heap_info->start();\n-  size_t size = heap_info->byte_size();\n-  write_region(MetaspaceShared::hp, start, size, false, false);\n-  return size;\n+  char* buffer_start = heap_info->buffer_start();\n+  size_t buffer_size = heap_info->buffer_byte_size();\n+  write_region(MetaspaceShared::hp, buffer_start, buffer_size, false, false);\n+  header()->set_heap_roots_offset(heap_info->heap_roots_offset());\n+  return buffer_size;\n@@ -2030,3 +2016,0 @@\n-  log_info(cds)(\"    heap range = [\" PTR_FORMAT \" - \"  PTR_FORMAT \"]\",\n-                p2i(header()->heap_begin()), p2i(header()->heap_end()));\n-\n@@ -2089,1 +2072,1 @@\n-    return \/*dumptime*\/header()->heap_begin() + r->mapping_offset();\n+    return (address)ArchiveHeapWriter::NOCOOPS_REQUESTED_BASE;\n@@ -2175,1 +2158,1 @@\n-  ArchiveHeapLoader::init_mapped_heap_relocation(delta, narrow_oop_shift());\n+  ArchiveHeapLoader::init_mapped_heap_info(mapped_start, delta, narrow_oop_shift());\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":8,"deletions":25,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -201,2 +201,0 @@\n-  address _heap_begin;                            \/\/ heap begin at dump time.\n-  address _heap_end;                              \/\/ heap end at dump time.\n@@ -235,0 +233,2 @@\n+  size_t _heap_roots_offset;            \/\/ Offset of the HeapShared::roots() object, from the bottom\n+                                        \/\/ of the archived heap objects, in bytes.\n@@ -266,2 +266,0 @@\n-  address heap_begin()                     const { return _heap_begin; }\n-  address heap_end()                       const { return _heap_end; }\n@@ -276,0 +274,1 @@\n+  size_t heap_roots_offset()               const { return _heap_roots_offset; }\n@@ -287,0 +286,1 @@\n+  void set_heap_roots_offset(size_t n)           { _heap_roots_offset = n; }\n@@ -382,0 +382,1 @@\n+  size_t  heap_roots_offset()  const { return header()->heap_roots_offset(); }\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -835,17 +835,4 @@\n-void HeapShared::serialize_root(SerializeClosure* soc) {\n-  oop roots_oop = nullptr;\n-\n-  if (soc->reading()) {\n-    soc->do_oop(&roots_oop); \/\/ read from archive\n-    assert(oopDesc::is_oop_or_null(roots_oop), \"is oop\");\n-    \/\/ Create an OopHandle only if we have actually mapped or loaded the roots\n-    if (roots_oop != nullptr) {\n-      assert(ArchiveHeapLoader::is_in_use(), \"must be\");\n-      _roots = OopHandle(Universe::vm_global(), roots_oop);\n-    }\n-  } else {\n-    \/\/ writing\n-    if (HeapShared::can_write()) {\n-      roots_oop = ArchiveHeapWriter::heap_roots_requested_address();\n-    }\n-    soc->do_oop(&roots_oop); \/\/ write to archive\n+void HeapShared::init_roots(oop roots_oop) {\n+  if (roots_oop != nullptr) {\n+    assert(ArchiveHeapLoader::is_in_use(), \"must be\");\n+    _roots = OopHandle(Universe::vm_global(), roots_oop);\n@@ -1672,2 +1659,0 @@\n-      \/\/ Note: HeapShared::to_requested_address() is not necessary because\n-      \/\/ the heap always starts at a deterministic address with UseCompressedOops==true.\n@@ -1695,27 +1680,0 @@\n-address HeapShared::to_requested_address(address dumptime_addr) {\n-  assert(DumpSharedSpaces, \"static dump time only\");\n-  if (dumptime_addr == nullptr || UseCompressedOops) {\n-    return dumptime_addr;\n-  }\n-\n-  \/\/ With UseCompressedOops==false, actual_base is selected by the OS so\n-  \/\/ it's different across -Xshare:dump runs.\n-  address actual_base = (address)G1CollectedHeap::heap()->reserved().start();\n-  address actual_end  = (address)G1CollectedHeap::heap()->reserved().end();\n-  assert(actual_base <= dumptime_addr && dumptime_addr <= actual_end, \"must be an address in the heap\");\n-\n-  \/\/ We always write the objects as if the heap started at this address. This\n-  \/\/ makes the heap content deterministic.\n-  \/\/\n-  \/\/ Note that at runtime, the heap address is also selected by the OS, so\n-  \/\/ the archive heap will not be mapped at 0x10000000. Instead, we will call\n-  \/\/ HeapShared::patch_embedded_pointers() to relocate the heap contents\n-  \/\/ accordingly.\n-  const address REQUESTED_BASE = (address)0x10000000;\n-  intx delta = REQUESTED_BASE - actual_base;\n-\n-  address requested_addr = dumptime_addr + delta;\n-  assert(REQUESTED_BASE != 0 && requested_addr != nullptr, \"sanity\");\n-  return requested_addr;\n-}\n-\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":4,"deletions":46,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -316,1 +316,0 @@\n-  static void copy_roots();\n@@ -408,1 +407,1 @@\n-  static void serialize_root(SerializeClosure* soc) NOT_CDS_JAVA_HEAP_RETURN;\n+  static void init_roots(oop roots_oop) NOT_CDS_JAVA_HEAP_RETURN;\n@@ -412,6 +411,0 @@\n-  \/\/ Returns the address of a heap object when it's mapped at the\n-  \/\/ runtime requested address. See comments in archiveBuilder.hpp.\n-  static address to_requested_address(address dumptime_addr) NOT_CDS_JAVA_HEAP_RETURN_(nullptr);\n-  static oop to_requested_address(oop dumptime_oop) {\n-    return cast_to_oop(to_requested_address(cast_from_oop<address>(dumptime_oop)));\n-  }\n","filename":"src\/hotspot\/share\/cds\/heapShared.hpp","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -369,1 +369,0 @@\n-  HeapShared::serialize_root(soc);\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+class SerializeClosure;\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARED_CDS_SERIALIZECLOSURE_HPP\n+#define SHARED_CDS_SERIALIZECLOSURE_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"oops\/oopsHierarchy.hpp\"\n+\n+\/\/ A handy way to read\/write auxiliary information in the CDS archive file\n+\/\/ (without the burden of adding new fields into FileMapHeader).\n+\n+class SerializeClosure : public StackObj {\n+public:\n+  \/\/ Return bool indicating whether closure implements read or write.\n+  virtual bool reading() const = 0;\n+\n+  \/\/ Read\/write the void pointer pointed to by p.\n+  virtual void do_ptr(void** p) = 0;\n+\n+  \/\/ Read\/write the 32-bit unsigned integer pointed to by p.\n+  virtual void do_u4(u4* p) = 0;\n+\n+  \/\/ Read\/write the int pointed to by p.\n+  virtual void do_int(int* p) = 0;\n+\n+  \/\/ Read\/write the bool pointed to by p.\n+  virtual void do_bool(bool* p) = 0;\n+\n+  \/\/ Read\/write the region specified.\n+  virtual void do_region(u_char* start, size_t size) = 0;\n+\n+  \/\/ Check\/write the tag.  If reading, then compare the tag against\n+  \/\/ the passed in value and fail is they don't match.  This allows\n+  \/\/ for verification that sections of the serialized data are of the\n+  \/\/ correct length.\n+  virtual void do_tag(int tag) = 0;\n+\n+  bool writing() {\n+    return !reading();\n+  }\n+\n+  \/\/ Useful alias\n+  template <typename T> void do_ptr(T** p) { do_ptr((void**)p); }\n+};\n+\n+#endif \/\/ SHARED_CDS_SERIALIZECLOSURE_HPP\n","filename":"src\/hotspot\/share\/cds\/serializeClosure.hpp","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"cds\/serializeClosure.hpp\"\n","filename":"src\/hotspot\/share\/classfile\/classLoaderDataShared.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+class SerializeClosure;\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"cds\/serializeClosure.hpp\"\n","filename":"src\/hotspot\/share\/classfile\/javaClassesImpl.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/serializeClosure.hpp\"\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -35,0 +35,2 @@\n+class SerializeClosure;\n+\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -331,39 +331,0 @@\n-\/\/ Abstract closure for serializing data (read or write).\n-\n-class SerializeClosure : public Closure {\n-public:\n-  \/\/ Return bool indicating whether closure implements read or write.\n-  virtual bool reading() const = 0;\n-\n-  \/\/ Read\/write the void pointer pointed to by p.\n-  virtual void do_ptr(void** p) = 0;\n-\n-  \/\/ Read\/write the 32-bit unsigned integer pointed to by p.\n-  virtual void do_u4(u4* p) = 0;\n-\n-  \/\/ Read\/write the int pointed to by p.\n-  virtual void do_int(int* p) = 0;\n-\n-  \/\/ Read\/write the bool pointed to by p.\n-  virtual void do_bool(bool* p) = 0;\n-\n-  \/\/ Read\/write the region specified.\n-  virtual void do_region(u_char* start, size_t size) = 0;\n-\n-  \/\/ Check\/write the tag.  If reading, then compare the tag against\n-  \/\/ the passed in value and fail is they don't match.  This allows\n-  \/\/ for verification that sections of the serialized data are of the\n-  \/\/ correct length.\n-  virtual void do_tag(int tag) = 0;\n-\n-  \/\/ Read\/write the oop\n-  virtual void do_oop(oop* o) = 0;\n-\n-  bool writing() {\n-    return !reading();\n-  }\n-\n-  \/\/ Useful alias\n-  template <typename T> void do_ptr(T** p) { do_ptr((void**)p); }\n-};\n-\n","filename":"src\/hotspot\/share\/memory\/iterator.hpp","additions":0,"deletions":39,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/serializeClosure.hpp\"\n","filename":"src\/hotspot\/share\/oops\/instanceMirrorKlass.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/serializeClosure.hpp\"\n","filename":"src\/hotspot\/share\/oops\/instanceStackChunkKlass.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-            \/\/ These options are available only on 64-bit.\n+            \/\/ This option is available only on 64-bit.\n@@ -60,1 +60,0 @@\n-            baseArgs.add(\"-XX:\" + sign + \"UseCompressedClassPointers\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/DeterministicDump.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"}]}