{"files":[{"patch":"@@ -2668,0 +2668,3 @@\n+    \/\/ Algorithm adapted from https:\/\/arxiv.org\/abs\/1704.00605, \"Faster Base64\n+    \/\/ Encoding and Decoding using AVX2 Instructions\".  URL modifications added.\n+\n@@ -2687,0 +2690,1 @@\n+    \/\/ Add in the offset value (roll) to get 6-bit out values\n@@ -2688,0 +2692,1 @@\n+    \/\/ Merge and permute the output bits into appropriate output byte lanes\n@@ -2692,0 +2697,1 @@\n+    \/\/ Store the output bytes\n@@ -2700,0 +2706,1 @@\n+    \/\/ Load in encoded string (32 bytes)\n@@ -2701,0 +2708,1 @@\n+    \/\/ Extract the high nibble for indexing into the lut tables.  High 4 bits are don't care.\n@@ -2703,0 +2711,1 @@\n+    \/\/ Extract the low nibble. 5F\/2F will isolate the low-order 4 bits.  High 4 bits are don't care.\n@@ -2704,0 +2713,1 @@\n+    \/\/ Check for special-case (0x2F or 0x5F (URL))\n@@ -2705,0 +2715,1 @@\n+    \/\/ Get the bitset based on the low nibble.  vpshufb uses low-order 4 bits only.\n@@ -2706,0 +2717,1 @@\n+    \/\/ Get the bit value of the high nibble\n@@ -2707,0 +2719,1 @@\n+    \/\/ If the and of the two is non-zero, we have an invalid input character\n@@ -2708,1 +2721,2 @@\n-    __ vpaddb(xmm0, xmm0, xmm1, Assembler::AVX_256bit);\n+    \/\/ Extract the \"roll\" value - value to add to the input to get 6-bit out value\n+    __ vpaddb(xmm0, xmm0, xmm1, Assembler::AVX_256bit); \/\/ Handle 2F \/ 5F\n@@ -2710,1 +2724,1 @@\n-    __ jcc(Assembler::equal, L_topLoop);\n+    __ jcc(Assembler::equal, L_topLoop);  \/\/ Fall through on error\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"}]}