{"files":[{"patch":"@@ -1706,2 +1706,1 @@\n-  if (VM_Version::supports_avx2()\n-      && VM_Version::supports_avx512vlbw()) {\n+  if (VM_Version::supports_avx2()) {\n@@ -1724,0 +1723,1 @@\n+    __ movdl(xmm8, rax);\n@@ -1725,1 +1725,1 @@\n-    __ evpbroadcastd(xmm8, rax, Assembler::AVX_256bit);\n+    __ vpbroadcastd(xmm8, xmm8, Assembler::AVX_256bit);\n@@ -1732,1 +1732,2 @@\n-    __ evpbroadcastd(xmm7, rax, Assembler::AVX_256bit);\n+    __ movdl(xmm7, rax);\n+    __ vpbroadcastd(xmm7, xmm7, Assembler::AVX_256bit);\n@@ -1834,1 +1835,2 @@\n-    __ evpbroadcastd(xmm6, rax, Assembler::AVX_256bit);\n+    __ movdl(xmm6, rax);\n+    __ vpbroadcastd(xmm6, xmm6, Assembler::AVX_256bit);\n@@ -1837,1 +1839,2 @@\n-    __ evpbroadcastd(xmm5, rax, Assembler::AVX_256bit);\n+    __ movdl(xmm5, rax);\n+    __ vpbroadcastd(xmm5, xmm5, Assembler::AVX_256bit);\n@@ -1844,1 +1847,2 @@\n-    __ evpbroadcastd(xmm3, rax, Assembler::AVX_256bit);\n+    __ movdl(xmm3, rax);\n+    __ vpbroadcastd(xmm3, xmm3, Assembler::AVX_256bit);\n@@ -1846,1 +1850,2 @@\n-    __ evpbroadcastd(xmm4, rax, Assembler::AVX_256bit);\n+    __ movdl(xmm4, rax);\n+    __ vpbroadcastd(xmm4, xmm4, Assembler::AVX_256bit);\n@@ -2154,0 +2159,77 @@\n+address StubGenerator::base64_AVX2_decode_tables_addr() {\n+  __ align64();\n+  StubCodeMark mark(this, \"StubRoutines\", \"AVX2_tables_base64\");\n+  address start = __ pc();\n+\n+  assert(((unsigned long long)start & 0x3f) == 0,\n+         \"Alignment problem (0x%08llx)\", (unsigned long long)start);\n+  __ emit_data64(0x2f2f2f2f2f2f2f2f, relocInfo::none);\n+  __ emit_data64(0x5f5f5f5f5f5f5f5f, relocInfo::none);  \/\/ for URL\n+\n+  \/\/ Permute table\n+  __ emit_data64(0x0000000100000000, relocInfo::none);\n+  __ emit_data64(0x0000000400000002, relocInfo::none);\n+  __ emit_data64(0x0000000600000005, relocInfo::none);\n+  __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+\n+  \/\/ lut_hi\n+  __ emit_data64(0x0804080402011010, relocInfo::none);\n+  __ emit_data64(0x1010101010101010, relocInfo::none);\n+  __ emit_data64(0x0804080402011010, relocInfo::none);\n+  __ emit_data64(0x1010101010101010, relocInfo::none);\n+\n+  \/\/ merge table\n+  __ emit_data64(0x0140014001400140, relocInfo::none);\n+  __ emit_data64(0x0140014001400140, relocInfo::none);\n+  __ emit_data64(0x0140014001400140, relocInfo::none);\n+  __ emit_data64(0x0140014001400140, relocInfo::none);\n+\n+  \/\/ merge multiplier\n+  __ emit_data64(0x0001100000011000, relocInfo::none);\n+  __ emit_data64(0x0001100000011000, relocInfo::none);\n+  __ emit_data64(0x0001100000011000, relocInfo::none);\n+  __ emit_data64(0x0001100000011000, relocInfo::none);\n+\n+  \/\/ Shuffle table\n+  __ emit_data64(0x090a040506000102, relocInfo::none);\n+  __ emit_data64(0xffffffff0c0d0e08, relocInfo::none);\n+  __ emit_data64(0x090a040506000102, relocInfo::none);\n+  __ emit_data64(0xffffffff0c0d0e08, relocInfo::none);\n+\n+  return start;\n+}\n+\n+address StubGenerator::base64_AVX2_decode_URL_tables_addr() {\n+  __ align64();\n+  StubCodeMark mark(this, \"StubRoutines\", \"AVX2_tables_URL_base64\");\n+  address start = __ pc();\n+\n+  assert(((unsigned long long)start & 0x3f) == 0,\n+         \"Alignment problem (0x%08llx)\", (unsigned long long)start);\n+  \/\/ lut_lo\n+  __ emit_data64(0x1111111111111115, relocInfo::none);\n+  __ emit_data64(0x1a1b1b1b1a131111, relocInfo::none);\n+  __ emit_data64(0x1111111111111115, relocInfo::none);\n+  __ emit_data64(0x1a1b1b1b1a131111, relocInfo::none);\n+\n+  \/\/ lut_roll\n+  __ emit_data64(0xb9b9bfbf04131000, relocInfo::none);\n+  __ emit_data64(0x0000000000000000, relocInfo::none);\n+  __ emit_data64(0xb9b9bfbf04131000, relocInfo::none);\n+  __ emit_data64(0x0000000000000000, relocInfo::none);\n+\n+  \/\/ lut_lo URL\n+  __ emit_data64(0x1111111111111115, relocInfo::none);\n+  __ emit_data64(0x1b1b1a1b1b131111, relocInfo::none);\n+  __ emit_data64(0x1111111111111115, relocInfo::none);\n+  __ emit_data64(0x1b1b1a1b1b131111, relocInfo::none);\n+\n+  \/\/ lut_roll URL\n+  __ emit_data64(0xb9b9bfbf04111000, relocInfo::none);\n+  __ emit_data64(0x0000000000000000, relocInfo::none);\n+  __ emit_data64(0xb9b9bfbf04111000, relocInfo::none);\n+  __ emit_data64(0x0000000000000000, relocInfo::none);\n+\n+  return start;\n+}\n+\n@@ -2320,1 +2402,1 @@\n-    __ cmpl(length, 128);     \/\/ 128-bytes is break-even for AVX-512\n+    __ cmpl(length, 31);     \/\/ 32-bytes is break-even for AVX-512\n@@ -2575,0 +2657,63 @@\n+  if (VM_Version::supports_avx2()) {\n+    Label L_tailProc, L_topLoop, L_enterLoop;\n+\n+    \/\/ Check for buffer too small (for algorithm)\n+    __ subl(length, 0x2c);\n+    __ jcc(Assembler::lessEqual, L_tailProc);\n+\n+    __ cmpl(isMIME, 0);\n+    __ jcc(Assembler::notEqual, L_tailProc);\n+\n+    __ shll(isURL, 3);\n+\n+    \/\/ Set up constants\n+    __ lea(r13, ExternalAddress(StubRoutines::x86::base64_AVX2_decode_tables_addr()));\n+    __ vpbroadcastq(xmm4, Address(r13, isURL, Address::times_1), Assembler::AVX_256bit);  \/\/ 2F or 5F\n+    __ vmovdqu(xmm10, xmm4);\n+    __ vmovdqu(xmm12, Address(r13, 0x10));  \/\/ permute\n+    __ vmovdqu(xmm9, Address(r13, 0x30));  \/\/ lut_hi\n+    __ vmovdqu(xmm7, Address(r13, 0x50)); \/\/ merge\n+    __ vmovdqu(xmm6, Address(r13, 0x70)); \/\/ merge mult\n+    __ vmovdqu(xmm13, Address(r13, 0x90)); \/\/ shuffle\n+\n+    __ lea(r13, ExternalAddress(StubRoutines::x86::base64_AVX2_decode_URL_tables_addr()));\n+    __ shll(isURL, 2);\n+    __ vmovdqu(xmm11, Address(r13, isURL, Address::times_1, 0x00));  \/\/ lut_lo\n+    __ vmovdqu(xmm8, Address(r13, isURL, Address::times_1, 0x20)); \/\/ lut_roll\n+    __ shrl(isURL, 5);  \/\/ restore isURL\n+    __ jmp(L_enterLoop);\n+\n+    __ align32();\n+    __ bind(L_topLoop);\n+    __ vpaddb(xmm0, xmm0, xmm2, Assembler::AVX_256bit);\n+    __ vpmaddubsw(xmm0, xmm0, xmm7, Assembler::AVX_256bit);\n+    __ vpmaddwd(xmm0, xmm0, xmm6, Assembler::AVX_256bit);\n+    __ vpshufb(xmm0, xmm0, xmm13, Assembler::AVX_256bit);\n+    __ vpermd(xmm0, xmm12, xmm0, Assembler::AVX_256bit);\n+    __ vmovdqu(Address(dest, dp, Address::times_1, 0), xmm0);\n+    __ addptr(source, 0x20);\n+    __ addptr(dest, 0x18);\n+    __ subl(length, 0x20);\n+    __ jcc(Assembler::lessEqual, L_tailProc);\n+\n+    __ bind(L_enterLoop);\n+\n+    __ vmovdqu(xmm2, Address(source, start_offset, Address::times_1, 0x0));\n+    __ vpsrld(xmm1, xmm2, 0x4, Assembler::AVX_256bit);\n+    __ vpand(xmm1, xmm4, xmm1, Assembler::AVX_256bit);\n+    __ vpand(xmm3, xmm2, xmm4, Assembler::AVX_256bit);\n+    __ vpcmpeqb(xmm0, xmm10, xmm2, Assembler::AVX_256bit);\n+    __ vpshufb(xmm3, xmm11, xmm3, Assembler::AVX_256bit);\n+    __ vpshufb(xmm5, xmm9, xmm1, Assembler::AVX_256bit);\n+    __ vptest(xmm3, xmm5);\n+    __ vpaddb(xmm0, xmm0, xmm1, Assembler::AVX_256bit);\n+    __ vpshufb(xmm0, xmm8, xmm0, Assembler::AVX_256bit);\n+    __ jcc(Assembler::equal, L_topLoop);\n+\n+    __ bind(L_tailProc);\n+\n+    __ addl(length, 0x2c);\n+\n+    __ vzeroupper();\n+  }\n+\n@@ -3850,3 +3995,1 @@\n-    if(VM_Version::supports_avx2() &&\n-       VM_Version::supports_avx512bw() &&\n-       VM_Version::supports_avx512vl()) {\n+    if(VM_Version::supports_avx2()) {\n@@ -3856,0 +3999,2 @@\n+      StubRoutines::x86::_avx2_decode_tables_base64 = base64_AVX2_decode_tables_addr();\n+      StubRoutines::x86::_avx2_decode_tables_url_base64 = base64_AVX2_decode_URL_tables_addr();\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":157,"deletions":12,"binary":false,"changes":169,"status":"modified"},{"patch":"@@ -444,0 +444,2 @@\n+  address base64_AVX2_decode_tables_addr();\n+  address base64_AVX2_decode_URL_tables_addr();\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -74,0 +74,2 @@\n+address StubRoutines::x86::_avx2_decode_tables_base64 = NULL;\n+address StubRoutines::x86::_avx2_decode_tables_url_base64 = NULL;\n","filename":"src\/hotspot\/cpu\/x86\/stubRoutines_x86.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -188,0 +188,2 @@\n+  static address _avx2_decode_tables_base64;\n+  static address _avx2_decode_tables_url_base64;\n@@ -328,0 +330,2 @@\n+  static address base64_AVX2_decode_tables_addr() { return _avx2_decode_tables_base64; }\n+  static address base64_AVX2_decode_URL_tables_addr() { return _avx2_decode_tables_url_base64; }\n","filename":"src\/hotspot\/cpu\/x86\/stubRoutines_x86.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1143,1 +1143,1 @@\n-  if ((UseAVX > 2) && supports_avx512vl() && supports_avx512bw()) {\n+  if (UseAVX >= 2) {\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,2 +34,2 @@\n-@BenchmarkMode(Mode.AverageTime)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/Base64Decode.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,2 +34,2 @@\n-@BenchmarkMode(Mode.AverageTime)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/Base64Encode.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}