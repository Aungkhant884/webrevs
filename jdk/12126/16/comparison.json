{"files":[{"patch":"@@ -1663,1 +1663,0 @@\n-  __ cmpl(length, 0);\n@@ -1706,2 +1705,1 @@\n-  if (VM_Version::supports_avx2()\n-      && VM_Version::supports_avx512vlbw()) {\n+  if (VM_Version::supports_avx2()) {\n@@ -1724,0 +1722,1 @@\n+    __ movdl(xmm8, rax);\n@@ -1725,1 +1724,1 @@\n-    __ evpbroadcastd(xmm8, rax, Assembler::AVX_256bit);\n+    __ vpbroadcastd(xmm8, xmm8, Assembler::AVX_256bit);\n@@ -1732,1 +1731,2 @@\n-    __ evpbroadcastd(xmm7, rax, Assembler::AVX_256bit);\n+    __ movdl(xmm7, rax);\n+    __ vpbroadcastd(xmm7, xmm7, Assembler::AVX_256bit);\n@@ -1834,1 +1834,2 @@\n-    __ evpbroadcastd(xmm6, rax, Assembler::AVX_256bit);\n+    __ movdl(xmm6, rax);\n+    __ vpbroadcastd(xmm6, xmm6, Assembler::AVX_256bit);\n@@ -1837,1 +1838,2 @@\n-    __ evpbroadcastd(xmm5, rax, Assembler::AVX_256bit);\n+    __ movdl(xmm5, rax);\n+    __ vpbroadcastd(xmm5, xmm5, Assembler::AVX_256bit);\n@@ -1844,1 +1846,2 @@\n-    __ evpbroadcastd(xmm3, rax, Assembler::AVX_256bit);\n+    __ movdl(xmm3, rax);\n+    __ vpbroadcastd(xmm3, xmm3, Assembler::AVX_256bit);\n@@ -1846,1 +1849,2 @@\n-    __ evpbroadcastd(xmm4, rax, Assembler::AVX_256bit);\n+    __ movdl(xmm4, rax);\n+    __ vpbroadcastd(xmm4, xmm4, Assembler::AVX_256bit);\n@@ -2154,0 +2158,74 @@\n+address StubGenerator::base64_AVX2_decode_tables_addr() {\n+  __ align64();\n+  StubCodeMark mark(this, \"StubRoutines\", \"AVX2_tables_base64\");\n+  address start = __ pc();\n+\n+  assert(((unsigned long long)start & 0x3f) == 0,\n+         \"Alignment problem (0x%08llx)\", (unsigned long long)start);\n+  __ emit_data(0x2f2f2f2f, relocInfo::none, 0);\n+  __ emit_data(0x5f5f5f5f, relocInfo::none, 0);  \/\/ for URL\n+\n+  __ emit_data(0xffffffff, relocInfo::none, 0);\n+  __ emit_data(0xfcfcfcfc, relocInfo::none, 0);  \/\/ for URL\n+\n+  \/\/ Permute table\n+  __ emit_data64(0x0000000100000000, relocInfo::none);\n+  __ emit_data64(0x0000000400000002, relocInfo::none);\n+  __ emit_data64(0x0000000600000005, relocInfo::none);\n+  __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+\n+  \/\/ Shuffle table\n+  __ emit_data64(0x090a040506000102, relocInfo::none);\n+  __ emit_data64(0xffffffff0c0d0e08, relocInfo::none);\n+  __ emit_data64(0x090a040506000102, relocInfo::none);\n+  __ emit_data64(0xffffffff0c0d0e08, relocInfo::none);\n+\n+  \/\/ merge table\n+  __ emit_data(0x01400140, relocInfo::none, 0);\n+\n+  \/\/ merge multiplier\n+  __ emit_data(0x00011000, relocInfo::none, 0);\n+\n+  return start;\n+}\n+\n+address StubGenerator::base64_AVX2_decode_LUT_tables_addr() {\n+  __ align64();\n+  StubCodeMark mark(this, \"StubRoutines\", \"AVX2_tables_URL_base64\");\n+  address start = __ pc();\n+\n+  assert(((unsigned long long)start & 0x3f) == 0,\n+         \"Alignment problem (0x%08llx)\", (unsigned long long)start);\n+  \/\/ lut_lo\n+  __ emit_data64(0x1111111111111115, relocInfo::none);\n+  __ emit_data64(0x1a1b1b1b1a131111, relocInfo::none);\n+  __ emit_data64(0x1111111111111115, relocInfo::none);\n+  __ emit_data64(0x1a1b1b1b1a131111, relocInfo::none);\n+\n+  \/\/ lut_roll\n+  __ emit_data64(0xb9b9bfbf04131000, relocInfo::none);\n+  __ emit_data64(0x0000000000000000, relocInfo::none);\n+  __ emit_data64(0xb9b9bfbf04131000, relocInfo::none);\n+  __ emit_data64(0x0000000000000000, relocInfo::none);\n+\n+  \/\/ lut_lo URL\n+  __ emit_data64(0x1111111111111115, relocInfo::none);\n+  __ emit_data64(0x1b1b1a1b1b131111, relocInfo::none);\n+  __ emit_data64(0x1111111111111115, relocInfo::none);\n+  __ emit_data64(0x1b1b1a1b1b131111, relocInfo::none);\n+\n+  \/\/ lut_roll URL\n+  __ emit_data64(0xb9b9bfbf0411e000, relocInfo::none);\n+  __ emit_data64(0x0000000000000000, relocInfo::none);\n+  __ emit_data64(0xb9b9bfbf0411e000, relocInfo::none);\n+  __ emit_data64(0x0000000000000000, relocInfo::none);\n+\n+  \/\/ lut_hi\n+  __ emit_data64(0x0804080402011010, relocInfo::none);\n+  __ emit_data64(0x1010101010101010, relocInfo::none);\n+  __ emit_data64(0x0804080402011010, relocInfo::none);\n+  __ emit_data64(0x1010101010101010, relocInfo::none);\n+\n+  return start;\n+}\n+\n@@ -2310,1 +2388,1 @@\n-  Label L_forceLoop, L_bottomLoop, L_checkMIME, L_exit_no_vzero;\n+  Label L_forceLoop, L_bottomLoop, L_checkMIME, L_exit_no_vzero, L_lastChunk;\n@@ -2320,2 +2398,2 @@\n-    __ cmpl(length, 128);     \/\/ 128-bytes is break-even for AVX-512\n-    __ jcc(Assembler::lessEqual, L_bruteForce);\n+    __ cmpl(length, 31);     \/\/ 32-bytes is break-even for AVX-512\n+    __ jcc(Assembler::lessEqual, L_lastChunk);\n@@ -2324,1 +2402,1 @@\n-    __ jcc(Assembler::notEqual, L_bruteForce);\n+    __ jcc(Assembler::notEqual, L_lastChunk);\n@@ -2575,0 +2653,83 @@\n+  if (VM_Version::supports_avx2()) {\n+    Label L_tailProc, L_topLoop, L_enterLoop;\n+\n+    __ cmpl(isMIME, 0);\n+    __ jcc(Assembler::notEqual, L_lastChunk);\n+\n+    \/\/ Check for buffer too small (for algorithm)\n+    __ subl(length, 0x2c);\n+    __ jcc(Assembler::less, L_tailProc);\n+\n+    __ shll(isURL, 2);\n+\n+    \/\/ Algorithm adapted from https:\/\/arxiv.org\/abs\/1704.00605, \"Faster Base64\n+    \/\/ Encoding and Decoding using AVX2 Instructions\".  URL modifications added.\n+\n+    \/\/ Set up constants\n+    __ lea(r13, ExternalAddress(StubRoutines::x86::base64_AVX2_decode_tables_addr()));\n+    __ vpbroadcastd(xmm4, Address(r13, isURL, Address::times_1), Assembler::AVX_256bit);  \/\/ 2F or 5F\n+    __ vpbroadcastd(xmm10, Address(r13, isURL, Address::times_1, 0x08), Assembler::AVX_256bit);  \/\/ -1 or -4\n+    __ vmovdqu(xmm12, Address(r13, 0x10));  \/\/ permute\n+    __ vmovdqu(xmm13, Address(r13, 0x30)); \/\/ shuffle\n+    __ vpbroadcastd(xmm7, Address(r13, 0x50), Assembler::AVX_256bit);  \/\/ merge\n+    __ vpbroadcastd(xmm6, Address(r13, 0x54), Assembler::AVX_256bit);  \/\/ merge mult\n+\n+    __ lea(r13, ExternalAddress(StubRoutines::x86::base64_AVX2_decode_LUT_tables_addr()));\n+    __ shll(isURL, 4);\n+    __ vmovdqu(xmm11, Address(r13, isURL, Address::times_1, 0x00));  \/\/ lut_lo\n+    __ vmovdqu(xmm8, Address(r13, isURL, Address::times_1, 0x20)); \/\/ lut_roll\n+    __ shrl(isURL, 6);  \/\/ restore isURL\n+    __ vmovdqu(xmm9, Address(r13, 0x80));  \/\/ lut_hi\n+    __ jmp(L_enterLoop);\n+\n+    __ align32();\n+    __ bind(L_topLoop);\n+    \/\/ Add in the offset value (roll) to get 6-bit out values\n+    __ vpaddb(xmm0, xmm0, xmm2, Assembler::AVX_256bit);\n+    \/\/ Merge and permute the output bits into appropriate output byte lanes\n+    __ vpmaddubsw(xmm0, xmm0, xmm7, Assembler::AVX_256bit);\n+    __ vpmaddwd(xmm0, xmm0, xmm6, Assembler::AVX_256bit);\n+    __ vpshufb(xmm0, xmm0, xmm13, Assembler::AVX_256bit);\n+    __ vpermd(xmm0, xmm12, xmm0, Assembler::AVX_256bit);\n+    \/\/ Store the output bytes\n+    __ vmovdqu(Address(dest, dp, Address::times_1, 0), xmm0);\n+    __ addptr(source, 0x20);\n+    __ addptr(dest, 0x18);\n+    __ subl(length, 0x20);\n+    __ jcc(Assembler::less, L_tailProc);\n+\n+    __ bind(L_enterLoop);\n+\n+    \/\/ Load in encoded string (32 bytes)\n+    __ vmovdqu(xmm2, Address(source, start_offset, Address::times_1, 0x0));\n+    \/\/ Extract the high nibble for indexing into the lut tables.  High 4 bits are don't care.\n+    __ vpsrld(xmm1, xmm2, 0x4, Assembler::AVX_256bit);\n+    __ vpand(xmm1, xmm4, xmm1, Assembler::AVX_256bit);\n+    \/\/ Extract the low nibble. 5F\/2F will isolate the low-order 4 bits.  High 4 bits are don't care.\n+    __ vpand(xmm3, xmm2, xmm4, Assembler::AVX_256bit);\n+    \/\/ Check for special-case (0x2F or 0x5F (URL))\n+    __ vpcmpeqb(xmm0, xmm4, xmm2, Assembler::AVX_256bit);\n+    \/\/ Get the bitset based on the low nibble.  vpshufb uses low-order 4 bits only.\n+    __ vpshufb(xmm3, xmm11, xmm3, Assembler::AVX_256bit);\n+    \/\/ Get the bit value of the high nibble\n+    __ vpshufb(xmm5, xmm9, xmm1, Assembler::AVX_256bit);\n+    \/\/ Make sure 2F \/ 5F shows as valid\n+    __ vpandn(xmm3, xmm0, xmm3, Assembler::AVX_256bit);\n+    \/\/ Make adjustment for roll index.  For non-URL, this is a no-op,\n+    \/\/ for URL, this adjusts by -4.  This is to properly index the\n+    \/\/ roll value for 2F \/ 5F.\n+    __ vpand(xmm0, xmm0, xmm10, Assembler::AVX_256bit);\n+    \/\/ If the and of the two is non-zero, we have an invalid input character\n+    __ vptest(xmm3, xmm5);\n+    \/\/ Extract the \"roll\" value - value to add to the input to get 6-bit out value\n+    __ vpaddb(xmm0, xmm0, xmm1, Assembler::AVX_256bit); \/\/ Handle 2F \/ 5F\n+    __ vpshufb(xmm0, xmm8, xmm0, Assembler::AVX_256bit);\n+    __ jcc(Assembler::equal, L_topLoop);  \/\/ Fall through on error\n+\n+    __ bind(L_tailProc);\n+\n+    __ addl(length, 0x2c);\n+\n+    __ vzeroupper();\n+  }\n+\n@@ -2605,0 +2766,2 @@\n+  __ bind(L_lastChunk);\n+\n@@ -3850,3 +4013,1 @@\n-    if(VM_Version::supports_avx2() &&\n-       VM_Version::supports_avx512bw() &&\n-       VM_Version::supports_avx512vl()) {\n+    if(VM_Version::supports_avx2()) {\n@@ -3856,0 +4017,2 @@\n+      StubRoutines::x86::_avx2_decode_tables_base64 = base64_AVX2_decode_tables_addr();\n+      StubRoutines::x86::_avx2_decode_lut_tables_base64 = base64_AVX2_decode_LUT_tables_addr();\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":179,"deletions":16,"binary":false,"changes":195,"status":"modified"},{"patch":"@@ -444,0 +444,2 @@\n+  address base64_AVX2_decode_tables_addr();\n+  address base64_AVX2_decode_LUT_tables_addr();\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -74,0 +74,2 @@\n+address StubRoutines::x86::_avx2_decode_tables_base64 = NULL;\n+address StubRoutines::x86::_avx2_decode_lut_tables_base64 = NULL;\n","filename":"src\/hotspot\/cpu\/x86\/stubRoutines_x86.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -188,0 +188,2 @@\n+  static address _avx2_decode_tables_base64;\n+  static address _avx2_decode_lut_tables_base64;\n@@ -328,0 +330,2 @@\n+  static address base64_AVX2_decode_tables_addr() { return _avx2_decode_tables_base64; }\n+  static address base64_AVX2_decode_LUT_tables_addr() { return _avx2_decode_lut_tables_base64; }\n","filename":"src\/hotspot\/cpu\/x86\/stubRoutines_x86.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1143,1 +1143,1 @@\n-  if ((UseAVX > 2) && supports_avx512vl() && supports_avx512bw()) {\n+  if (UseAVX >= 2) {\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,2 +34,2 @@\n-@BenchmarkMode(Mode.AverageTime)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n@@ -42,4 +42,4 @@\n-    private Base64.Encoder encoder, mimeEncoder;\n-    private Base64.Decoder decoder, mimeDecoder;\n-    private ArrayList<byte[]> encoded, mimeEncoded, errorEncoded;\n-    private byte[] decoded, mimeDecoded, errorDecoded;\n+    private Base64.Encoder encoder, mimeEncoder, urlEncoder;\n+    private Base64.Decoder decoder, mimeDecoder, urlDecoder;\n+    private ArrayList<byte[]> encoded, mimeEncoded, urlEncoded, errorEncoded;\n+    private byte[] decoded, mimeDecoded, urlDecoded, errorDecoded;\n@@ -63,0 +63,3 @@\n+    @Param({\"0\"})\n+    private int addSpecial;\n+\n@@ -77,0 +80,5 @@\n+        urlDecoded = new byte[maxNumBytes + 1];\n+        urlEncoder = Base64.getUrlEncoder();\n+        urlDecoder = Base64.getUrlDecoder();\n+        urlEncoded = new ArrayList<byte[]> ();\n+\n@@ -86,0 +94,4 @@\n+            if(addSpecial != 0){\n+              dst[0] = '\/';\n+              dst[1] = '+';\n+            }\n@@ -95,0 +107,11 @@\n+            int urlSrcLen = 1 + r.nextInt(maxNumBytes);\n+            byte[] urlSrc = new byte[urlSrcLen];\n+            byte[] urlDst = new byte[((urlSrcLen + 2) \/ 3) * 4];\n+            r.nextBytes(urlSrc);\n+            urlEncoder.encode(urlSrc, urlDst);\n+            if(addSpecial != 0){\n+              urlDst[0] = '_';\n+              urlDst[1] = '-';\n+            }\n+            urlEncoded.add(urlDst);\n+\n@@ -100,1 +123,0 @@\n-            errorEncoded.add(errorDst);\n@@ -102,0 +124,1 @@\n+            errorEncoded.add(errorDst);\n@@ -123,0 +146,9 @@\n+    @Benchmark\n+    @OperationsPerInvocation(TESTSIZE)\n+    public void testBase64URLDecode(Blackhole bh) {\n+        for (byte[] s : urlEncoded) {\n+            urlDecoder.decode(s, urlDecoded);\n+            bh.consume(urlDecoded);\n+        }\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/Base64Decode.java","additions":39,"deletions":7,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -34,2 +34,2 @@\n-@BenchmarkMode(Mode.AverageTime)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/Base64Encode.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}