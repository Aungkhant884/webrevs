{"files":[{"patch":"@@ -1706,2 +1706,1 @@\n-  if (VM_Version::supports_avx2()\n-      && VM_Version::supports_avx512vlbw()) {\n+  if (VM_Version::supports_avx2()) {\n@@ -1724,0 +1723,1 @@\n+    __ movdl(xmm8, rax);\n@@ -1725,1 +1725,1 @@\n-    __ evpbroadcastd(xmm8, rax, Assembler::AVX_256bit);\n+    __ vpbroadcastd(xmm8, xmm8, Assembler::AVX_256bit);\n@@ -1732,1 +1732,2 @@\n-    __ evpbroadcastd(xmm7, rax, Assembler::AVX_256bit);\n+    __ movdl(xmm7, rax);\n+    __ vpbroadcastd(xmm7, xmm7, Assembler::AVX_256bit);\n@@ -1834,1 +1835,2 @@\n-    __ evpbroadcastd(xmm6, rax, Assembler::AVX_256bit);\n+    __ movdl(xmm6, rax);\n+    __ vpbroadcastd(xmm6, xmm6, Assembler::AVX_256bit);\n@@ -1837,1 +1839,2 @@\n-    __ evpbroadcastd(xmm5, rax, Assembler::AVX_256bit);\n+    __ movdl(xmm5, rax);\n+    __ vpbroadcastd(xmm5, xmm5, Assembler::AVX_256bit);\n@@ -1844,1 +1847,2 @@\n-    __ evpbroadcastd(xmm3, rax, Assembler::AVX_256bit);\n+    __ movdl(xmm3, rax);\n+    __ vpbroadcastd(xmm3, xmm3, Assembler::AVX_256bit);\n@@ -1846,1 +1850,2 @@\n-    __ evpbroadcastd(xmm4, rax, Assembler::AVX_256bit);\n+    __ movdl(xmm4, rax);\n+    __ vpbroadcastd(xmm4, xmm4, Assembler::AVX_256bit);\n@@ -2154,0 +2159,54 @@\n+address StubGenerator::base64_AVX2_tables_addr() {\n+  __ align64();\n+  StubCodeMark mark(this, \"StubRoutines\", \"AVX2_tables_base64\");\n+  address start = __ pc();\n+\n+  assert(((unsigned long long)start & 0x3f) == 0,\n+         \"Alignment problem (0x%08llx)\", (unsigned long long)start);\n+  __ emit_data64(0x2f2f2f2f2f2f2f2f, relocInfo::none);\n+\n+  \/\/ Permute table\n+  __ emit_data64(0x0000000100000000, relocInfo::none);\n+  __ emit_data64(0x0000000400000002, relocInfo::none);\n+  __ emit_data64(0x0000000600000005, relocInfo::none);\n+  __ emit_data64(0xffffffffffffffff, relocInfo::none);\n+\n+  \/\/ lut_lo\n+  __ emit_data64(0x1111111111111115, relocInfo::none);\n+  __ emit_data64(0x1a1b1b1b1a131111, relocInfo::none);\n+  __ emit_data64(0x1111111111111115, relocInfo::none);\n+  __ emit_data64(0x1a1b1b1b1a131111, relocInfo::none);\n+\n+  \/\/ lut_hi\n+  __ emit_data64(0x0804080402011010, relocInfo::none);\n+  __ emit_data64(0x1010101010101010, relocInfo::none);\n+  __ emit_data64(0x0804080402011010, relocInfo::none);\n+  __ emit_data64(0x1010101010101010, relocInfo::none);\n+\n+  \/\/ lut_roll\n+  __ emit_data64(0xb9b9bfbf04131000, relocInfo::none);\n+  __ emit_data64(0x0000000000000000, relocInfo::none);\n+  __ emit_data64(0xb9b9bfbf04131000, relocInfo::none);\n+  __ emit_data64(0x0000000000000000, relocInfo::none);\n+\n+  \/\/ merge table\n+  __ emit_data64(0x0140014001400140, relocInfo::none);\n+  __ emit_data64(0x0140014001400140, relocInfo::none);\n+  __ emit_data64(0x0140014001400140, relocInfo::none);\n+  __ emit_data64(0x0140014001400140, relocInfo::none);\n+\n+  \/\/ merge multiplier\n+  __ emit_data64(0x0001100000011000, relocInfo::none);\n+  __ emit_data64(0x0001100000011000, relocInfo::none);\n+  __ emit_data64(0x0001100000011000, relocInfo::none);\n+  __ emit_data64(0x0001100000011000, relocInfo::none);\n+\n+  \/\/ Shuffle table\n+  __ emit_data64(0x090a040506000102, relocInfo::none);\n+  __ emit_data64(0xffffffff0c0d0e08, relocInfo::none);\n+  __ emit_data64(0x090a040506000102, relocInfo::none);\n+  __ emit_data64(0xffffffff0c0d0e08, relocInfo::none);\n+\n+  return start;\n+}\n+\n@@ -2575,0 +2634,74 @@\n+  if (VM_Version::supports_avx2()) {\n+    Label L_tailProc, L_topLoop, L_enterLoop;\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+    \/\/\n+    \/\/  **** Make sure inputs match ****\n+    \/\/ size_t fast_avx2_base64_decode(char *out, const char *src, size_t srclen)\n+    \/\/\n+    \/\/ Handle isURL \/ MIME?!?!  r12 is used for length calculation (from out)\n+    \/\/\n+    \/\/ rbx is out, r12 is saved out, rdx is size, rsi is src\n+    \/\/\n+    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+    \/\/ *************** NEEDS TO BE FIXED ************\n+    __ cmpl(isURL, 0);\n+    __ jcc(Assembler::notZero, L_tailProc);\n+\n+    __ cmpl(length, 44);\n+    __ jcc(Assembler::belowEqual, L_tailProc);\n+\n+    __ cmpl(isMIME, 0);\n+    __ jcc(Assembler::notEqual, L_tailProc);\n+\n+    \/\/ Set up constants\n+    __ lea(r13, ExternalAddress(StubRoutines::x86::base64_AVX2_tables_addr()));\n+    __ vpbroadcastq(xmm4, Address(r13, 0), Assembler::AVX_256bit);\n+    __ vmovdqu(xmm11, Address(r13, 0x28));\n+\n+    \/\/ The 0x2f2f..2f vector is used both as a table and a mask.  For now, just initialize\n+    \/\/ using movq instead of a broadcast (slight performance increase).\n+    \/\/ Will likely be changed back when URL is accelerated.\n+    \/\/ __ vpbroadcastb(xmm10, Address(r13, 0), Assembler::AVX_256bit);\n+    __ vmovdqu(xmm10, xmm4);\n+    __ vmovdqu(xmm9, Address(r13, 0x48));\n+    __ vmovdqu(xmm8, Address(r13, 0x68));\n+    __ vmovdqu(xmm7, Address(r13, 0x88));\n+    __ vmovdqu(xmm6, Address(r13, 0xa8));\n+    __ vmovdqu(xmm13, Address(r13, 0xc8));\n+    __ vmovdqu(xmm12, Address(r13, 0x08));\n+    __ jmp(L_enterLoop);\n+\n+    __ align32();\n+    __ bind(L_topLoop);\n+    __ vpaddb(xmm0, xmm0, xmm2, Assembler::AVX_256bit);\n+    __ vpmaddubsw(xmm0, xmm0, xmm7, Assembler::AVX_256bit);\n+    __ vpmaddwd(xmm0, xmm0, xmm6, Assembler::AVX_256bit);\n+    __ vpshufb(xmm0, xmm0, xmm13, Assembler::AVX_256bit);\n+    __ vpermd(xmm0, xmm12, xmm0, Assembler::AVX_256bit);\n+    __ subl(length, 0x20);\n+    __ vmovdqu(Address(dest, dp, Address::times_1, 0), xmm0);\n+    __ addptr(source, 0x20);\n+    __ addptr(dest, 0x18);\n+    __ cmpl(length, 0x2c);\n+    __ jcc(Assembler::belowEqual, L_tailProc);\n+\n+    __ bind(L_enterLoop);\n+\n+    __ vmovdqu(xmm2, Address(source, start_offset, Address::times_1, 0x0));\n+    __ vpsrld(xmm1, xmm2, 0x4, Assembler::AVX_256bit);\n+    __ vpand(xmm1, xmm4, xmm1, Assembler::AVX_256bit);\n+    __ vpand(xmm3, xmm2, xmm4, Assembler::AVX_256bit);\n+    __ vpcmpeqb(xmm0, xmm10, xmm2, Assembler::AVX_256bit);\n+    __ vpshufb(xmm3, xmm11, xmm3, Assembler::AVX_256bit);\n+    __ vpshufb(xmm5, xmm9, xmm1, Assembler::AVX_256bit);\n+    __ vptest(xmm3, xmm5);\n+    __ vpaddb(xmm0, xmm0, xmm1, Assembler::AVX_256bit);\n+    __ vpshufb(xmm0, xmm8, xmm0, Assembler::AVX_256bit);\n+    __ jcc(Assembler::equal, L_topLoop);\n+\n+    __ bind(L_tailProc);\n+\n+    __ vzeroupper();\n+  }\n+\n@@ -3850,3 +3983,1 @@\n-    if(VM_Version::supports_avx2() &&\n-       VM_Version::supports_avx512bw() &&\n-       VM_Version::supports_avx512vl()) {\n+    if(VM_Version::supports_avx2()) {\n@@ -3856,0 +3987,1 @@\n+      StubRoutines::x86::_avx2_tables_base64 = base64_AVX2_tables_addr();\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":143,"deletions":11,"binary":false,"changes":154,"status":"modified"},{"patch":"@@ -444,0 +444,1 @@\n+  address base64_AVX2_tables_addr();\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -74,0 +74,1 @@\n+address StubRoutines::x86::_avx2_tables_base64 = NULL;\n","filename":"src\/hotspot\/cpu\/x86\/stubRoutines_x86.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -188,0 +188,1 @@\n+  static address _avx2_tables_base64;\n@@ -328,0 +329,1 @@\n+  static address base64_AVX2_tables_addr() { return _avx2_tables_base64; }\n","filename":"src\/hotspot\/cpu\/x86\/stubRoutines_x86.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1143,1 +1143,1 @@\n-  if ((UseAVX > 2) && supports_avx512vl() && supports_avx512bw()) {\n+  if (UseAVX >= 2) {\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,2 +34,2 @@\n-@BenchmarkMode(Mode.AverageTime)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/Base64Decode.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,2 +34,2 @@\n-@BenchmarkMode(Mode.AverageTime)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/Base64Encode.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}