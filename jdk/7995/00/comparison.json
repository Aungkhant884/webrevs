{"files":[{"patch":"@@ -95,47 +95,33 @@\n-\/\/ The arguments follow the normal convention of denoting\n-\/\/ a right-open interval: [start, end)\n-void G1BlockOffsetTablePart::set_remainder_to_point_to_start(HeapWord* start, HeapWord* end) {\n-  assert(start < end, \"precondition\");\n-  \/\/ Write the backskip value for each region.\n-  \/\/\n-  \/\/    offset\n-  \/\/    card             2nd                       3rd\n-  \/\/     | +- 1st        |                         |\n-  \/\/     v v             v                         v\n-  \/\/    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+     +-+-+-+-+-+-+-+-+-+-+-\n-  \/\/    |x|0|0|0|0|0|0|0|1|1|1|1|1|1| ... |1|1|1|1|2|2|2|2|2|2| ...\n-  \/\/    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+     +-+-+-+-+-+-+-+-+-+-+-\n-  \/\/    11              19                        75\n-  \/\/      12\n-  \/\/\n-  \/\/    offset card is the card that points to the start of an object\n-  \/\/      x - offset value of offset card\n-  \/\/    1st - start of first logarithmic region\n-  \/\/      0 corresponds to logarithmic value N_words + 0 and 2**(3 * 0) = 1\n-  \/\/    2nd - start of second logarithmic region\n-  \/\/      1 corresponds to logarithmic value N_words + 1 and 2**(3 * 1) = 8\n-  \/\/    3rd - start of third logarithmic region\n-  \/\/      2 corresponds to logarithmic value N_words + 2 and 2**(3 * 2) = 64\n-  \/\/\n-  \/\/    integer below the block offset entry is an example of\n-  \/\/    the index of the entry\n-  \/\/\n-  \/\/    Given an address,\n-  \/\/      Find the index for the address\n-  \/\/      Find the block offset table entry\n-  \/\/      Convert the entry to a back slide\n-  \/\/        (e.g., with today's, offset = 0x81 =>\n-  \/\/          back slip = 2**(3*(0x81 - N_words)) = 2**3) = 8\n-  \/\/      Move back N (e.g., 8) entries and repeat with the\n-  \/\/        value of the new entry\n-  \/\/\n-  size_t start_card = _bot->index_for(start);\n-  size_t end_card = _bot->index_for(end-1);\n-  assert(start ==_bot->address_for_index(start_card), \"Precondition\");\n-  assert(end ==_bot->address_for_index(end_card)+BOTConstants::card_size_in_words(), \"Precondition\");\n-  set_remainder_to_point_to_start_incl(start_card, end_card); \/\/ closed interval\n-}\n-\n-\/\/ Unlike the normal convention in this code, the argument here denotes\n-\/\/ a closed, inclusive interval: [start_card, end_card], cf set_remainder_to_point_to_start()\n-\/\/ above.\n+\/\/ Write the backskip value for each region.\n+\/\/\n+\/\/    offset\n+\/\/    card             2nd                       3rd\n+\/\/     | +- 1st        |                         |\n+\/\/     v v             v                         v\n+\/\/    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+     +-+-+-+-+-+-+-+-+-+-+-\n+\/\/    |x|0|0|0|0|0|0|0|1|1|1|1|1|1| ... |1|1|1|1|2|2|2|2|2|2| ...\n+\/\/    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+     +-+-+-+-+-+-+-+-+-+-+-\n+\/\/    11              19                        75\n+\/\/      12\n+\/\/\n+\/\/    offset card is the card that points to the start of an object\n+\/\/      x - offset value of offset card\n+\/\/    1st - start of first logarithmic region\n+\/\/      0 corresponds to logarithmic value N_words + 0 and 2**(3 * 0) = 1\n+\/\/    2nd - start of second logarithmic region\n+\/\/      1 corresponds to logarithmic value N_words + 1 and 2**(3 * 1) = 8\n+\/\/    3rd - start of third logarithmic region\n+\/\/      2 corresponds to logarithmic value N_words + 2 and 2**(3 * 2) = 64\n+\/\/\n+\/\/    integer below the block offset entry is an example of\n+\/\/    the index of the entry\n+\/\/\n+\/\/    Given an address,\n+\/\/      Find the index for the address\n+\/\/      Find the block offset table entry\n+\/\/      Convert the entry to a back slide\n+\/\/        (e.g., with today's, offset = 0x81 =>\n+\/\/          back slip = 2**(3*(0x81 - N_words)) = 2**3) = 8\n+\/\/      Move back N (e.g., 8) entries and repeat with the\n+\/\/        value of the new entry\n+\/\/\n@@ -243,5 +229,1 @@\n-    HeapWord* rem_st  = _bot->address_for_index(index + 1);\n-    \/\/ Calculate rem_end this way because end_index\n-    \/\/ may be the last valid index in the covered region.\n-    HeapWord* rem_end = _bot->address_for_index(end_index) + BOTConstants::card_size_in_words();\n-    set_remainder_to_point_to_start(rem_st, rem_end);\n+    set_remainder_to_point_to_start_incl(index + 1, end_index);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BlockOffsetTable.cpp","additions":34,"deletions":52,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -120,7 +120,2 @@\n-  \/\/ Sets the entries\n-  \/\/ corresponding to the cards starting at \"start\" and ending at \"end\"\n-  \/\/ to point back to the card before \"start\": the interval [start, end)\n-  \/\/ is right-open.\n-  void set_remainder_to_point_to_start(HeapWord* start, HeapWord* end);\n-  \/\/ Same as above, except that the args here are a card _index_ interval\n-  \/\/ that is closed: [start_index, end_index]\n+  \/\/ Sets the entries corresponding to the cards starting at \"start\" and ending\n+  \/\/ at \"end\" to point back to the card before \"start\"; [start, end]\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BlockOffsetTable.hpp","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"}]}