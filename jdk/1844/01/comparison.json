{"files":[{"patch":"@@ -188,0 +188,1 @@\n+  friend class ThreadsListHandleTest;  \/\/ for _nested_threads_hazard_ptr_cnt, _threads_hazard_ptr, _threads_list_ptr access\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -469,3 +469,8 @@\n-  current_list->inc_nested_handle_cnt();\n-  _previous->_has_ref_count = true;  \/\/ promote SafeThreadsListPtr to be reference counted\n-  _thread->_threads_hazard_ptr = NULL;  \/\/ clear the hazard ptr so we can go through the fast path below\n+  if (!_previous->_has_ref_count) {\n+    \/\/ Promote the thread's current SafeThreadsListPtr to be reference counted.\n+    current_list->inc_nested_handle_cnt();\n+    _previous->_has_ref_count = true;\n+  }\n+  \/\/ Clear the hazard ptr so we can go through the fast path below and\n+  \/\/ acquire a nested stable ThreadsList.\n+  Atomic::store(&_thread->_threads_hazard_ptr, (ThreadsList*)NULL);\n@@ -488,0 +493,2 @@\n+  assert(_thread->get_threads_hazard_ptr() != NULL, \"sanity check\");\n+  assert(_thread->get_threads_hazard_ptr() == _list, \"sanity check\");\n@@ -492,8 +499,3 @@\n-    \/\/ If a SafeThreadsListPtr has been promoted to use reference counting\n-    \/\/ due to nesting of ThreadsListHandles, then the reference count must be\n-    \/\/ decremented, at which point it may be freed. The forgotten value of\n-    \/\/ the list no longer matters at this point and should already be NULL.\n-    assert(_thread->get_threads_hazard_ptr() == NULL, \"sanity check\");\n-    if (EnableThreadSMRStatistics) {\n-      _thread->dec_nested_threads_hazard_ptr_cnt();\n-    }\n+    \/\/ This thread created a nested ThreadsListHandle after the current\n+    \/\/ ThreadsListHandle so we had to protect this ThreadsList with a\n+    \/\/ ref count. We no longer need that protection.\n@@ -503,4 +505,5 @@\n-  } else {\n-    \/\/ The normal case: a leaf ThreadsListHandle. This merely requires setting\n-    \/\/ the thread hazard ptr back to NULL.\n-    assert(_thread->get_threads_hazard_ptr() != NULL, \"sanity check\");\n+  }\n+  if (_previous == NULL) {\n+    \/\/ The ThreadsListHandle being released is a leaf ThreadsListHandle.\n+    \/\/ This is the \"normal\" case and this is where we set this thread's\n+    \/\/ hazard ptr back to NULL.\n@@ -508,0 +511,11 @@\n+  } else {\n+    \/\/ The ThreadsListHandle being released is a nested ThreadsListHandle.\n+    if (EnableThreadSMRStatistics) {\n+      _thread->dec_nested_threads_hazard_ptr_cnt();\n+    }\n+    \/\/ The previous ThreadsList becomes this thread's hazard ptr again.\n+    \/\/ It is a stable ThreadsList since the non-zero _nested_handle_cnt\n+    \/\/ keeps it from being freed so we can just set the thread's hazard\n+    \/\/ ptr without going through the stabilization\/tagging protocol.\n+    assert(_previous->_list->_nested_handle_cnt > 0, \"must be > than zero\");\n+    _thread->set_threads_hazard_ptr(_previous->_list);\n","filename":"src\/hotspot\/share\/runtime\/threadSMR.cpp","additions":29,"deletions":15,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -168,0 +168,1 @@\n+  friend class ThreadsListHandleTest;  \/\/ for _nested_handle_cnt access\n@@ -209,0 +210,1 @@\n+  friend class ThreadsListHandleTest;  \/\/ for access to the fields\n@@ -280,0 +282,2 @@\n+  friend class ThreadsListHandleTest;  \/\/ for _list_ptr access\n+\n","filename":"src\/hotspot\/share\/runtime\/threadSMR.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,681 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"runtime\/thread.inline.hpp\"\n+#include \"runtime\/threadSMR.hpp\"\n+#include \"unittest.hpp\"\n+\n+class ThreadsListHandleTest : public ::testing::Test {\n+  public:\n+    \/\/ Accessors for the Threads class:\n+    \/\/\n+    \/\/ Return the protected Thread::_threads_hazard_ptr field:\n+    static ThreadsList* get_Thread_threads_hazard_ptr(Thread* thr) {\n+      return thr->get_threads_hazard_ptr();\n+    }\n+    \/\/ Return the protected Thread::_threads_list_ptr field:\n+    static SafeThreadsListPtr* get_Thread_threads_list_ptr(Thread* thr) {\n+      return thr->_threads_list_ptr;\n+    }\n+    \/\/ Return the protected Thread::_nested_threads_hazard_ptr_cnt field:\n+    static uint get_Thread_nested_threads_hazard_ptr_cnt(Thread* thr) {\n+      return thr->nested_threads_hazard_ptr_cnt();\n+    }\n+\n+    \/\/ Accessors for the ThreadsListHandle class:\n+    \/\/\n+    \/\/ Return the private ThreadsListHandle::_list_ptr field:\n+    static SafeThreadsListPtr* get_TLH_list_ptr(ThreadsListHandle* tlh_p) {\n+      return &tlh_p->_list_ptr;\n+    }\n+\n+    \/\/ Accessors for the ThreadsList class:\n+    \/\/\n+    \/\/ Return the private ThreadsList::_nested_handle_cnt field:\n+    static intx get_TL_nested_handle_cnt(ThreadsList* tl_p) {\n+      return tl_p->_nested_handle_cnt;\n+    }\n+\n+    \/\/ Accessors for the SafeThreadsListPtr class:\n+    \/\/\n+    \/\/ Return the private SafeThreadsListPtr::_thread field:\n+    static Thread* get_STLP_thread(SafeThreadsListPtr* stlp_p) {\n+      return stlp_p->_thread;\n+    }\n+    \/\/ Return the private SafeThreadsListPtr::_has_ref_count field:\n+    static bool get_STLP_has_ref_count(SafeThreadsListPtr* stlp_p) {\n+      return stlp_p->_has_ref_count;\n+    }\n+    \/\/ Return the private SafeThreadsListPtr::_needs_release field:\n+    static bool get_STLP_needs_release(SafeThreadsListPtr* stlp_p) {\n+      return stlp_p->_needs_release;\n+    }\n+};\n+\n+TEST_VM(ThreadsListHandle, sanity) {\n+  bool saved_flag_val = EnableThreadSMRStatistics;\n+  EnableThreadSMRStatistics = true;  \/\/ enable Thread::_nested_threads_hazard_ptr_cnt\n+\n+  Thread* thr = Thread::current();\n+\n+  \/\/ Test case: no ThreadsListHandle\n+  \/\/\n+\n+  \/\/ Verify the current thread refers to no ThreadsListHandle:\n+  EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_hazard_ptr(thr), (ThreadsList*)NULL)\n+      << \"thr->_threads_hazard_ptr must be NULL\";\n+  EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_list_ptr(thr), (SafeThreadsListPtr*) NULL)\n+      << \"thr->_threads_list_ptr must be NULL\";\n+  EXPECT_EQ(ThreadsListHandleTest::get_Thread_nested_threads_hazard_ptr_cnt(thr), (uint)0)\n+      << \"thr->_nested_threads_hazard_ptr_cnt must be 0\";\n+\n+  \/\/ Test case: single ThreadsListHandle, no recursion\n+  \/\/\n+  {\n+    ThreadsListHandle tlh1;\n+    SafeThreadsListPtr* list_ptr1 = ThreadsListHandleTest::get_TLH_list_ptr(&tlh1);\n+\n+    \/\/ Verify the current thread refers to tlh1:\n+    EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_hazard_ptr(thr), tlh1.list())\n+        << \"thr->_threads_hazard_ptr must match tlh1.list()\";\n+    EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_list_ptr(thr), list_ptr1)\n+        << \"thr->_threads_list_ptr must match list_ptr1\";\n+    EXPECT_EQ(ThreadsListHandleTest::get_Thread_nested_threads_hazard_ptr_cnt(thr), (uint)0)\n+        << \"thr->_nested_threads_hazard_ptr_cnt must be 0\";\n+\n+    \/\/ Verify tlh1 has the right field values:\n+    EXPECT_EQ(list_ptr1->previous(), (SafeThreadsListPtr*)NULL)\n+        << \"list_ptr1->previous() must be NULL\";\n+    EXPECT_EQ(ThreadsListHandleTest::get_STLP_thread(list_ptr1), thr)\n+        << \"list_ptr1->_thread must match current thread\";\n+    EXPECT_EQ(list_ptr1->list(), tlh1.list())\n+        << \"list_ptr1->list() must match tlh1.list()\";\n+    EXPECT_EQ(ThreadsListHandleTest::get_STLP_has_ref_count(list_ptr1), false)\n+        << \"list_ptr1->_has_ref_count must be false\";\n+    EXPECT_EQ(ThreadsListHandleTest::get_STLP_needs_release(list_ptr1), true)\n+        << \"list_ptr1->_needs_release must be true\";\n+\n+    \/\/ Verify tlh1 ThreadsList has the right field values:\n+    EXPECT_EQ(ThreadsListHandleTest::get_TL_nested_handle_cnt(list_ptr1->list()), (intx)0)\n+        << \"list_ptr1->list()->_nested_handle_cnt must be 0\";\n+  } \/\/ destroy tlh1\n+\n+  \/\/ Test case: after first ThreadsListHandle (tlh1) has been destroyed\n+  \/\/\n+\n+  \/\/ Verify the current thread refers to no ThreadsListHandle:\n+  EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_hazard_ptr(thr), (ThreadsList*)NULL)\n+      << \"thr->_threads_hazard_ptr must match be NULL\";\n+  EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_list_ptr(thr), (SafeThreadsListPtr*) NULL)\n+      << \"thr->_threads_list_ptr must be NULL\";\n+  EXPECT_EQ(ThreadsListHandleTest::get_Thread_nested_threads_hazard_ptr_cnt(thr), (uint)0)\n+      << \"thr->_nested_threads_hazard_ptr_cnt must be 0\";\n+\n+  \/\/ Test case: first ThreadsListHandle to prepare for nesting\n+  \/\/\n+  {\n+    ThreadsListHandle tlh1;\n+    SafeThreadsListPtr* list_ptr1 = ThreadsListHandleTest::get_TLH_list_ptr(&tlh1);\n+\n+    \/\/ Verify the current thread refers to tlh1:\n+    EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_hazard_ptr(thr), tlh1.list())\n+        << \"thr->_threads_hazard_ptr must match tlh1.list()\";\n+    EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_list_ptr(thr), list_ptr1)\n+        << \"thr->_threads_list_ptr must match list_ptr1\";\n+    EXPECT_EQ(ThreadsListHandleTest::get_Thread_nested_threads_hazard_ptr_cnt(thr), (uint)0)\n+        << \"thr->_nested_threads_hazard_ptr_cnt must be 0\";\n+\n+    \/\/ Verify tlh1 has the right field values:\n+    EXPECT_EQ(list_ptr1->previous(), (SafeThreadsListPtr*)NULL)\n+        << \"list_ptr1->previous() must be NULL\";\n+    EXPECT_EQ(ThreadsListHandleTest::get_STLP_thread(list_ptr1), thr)\n+        << \"list_ptr1->_thread must match current thread\";\n+    EXPECT_EQ(list_ptr1->list(), tlh1.list())\n+        << \"list_ptr1->list() must match tlh1.list()\";\n+    EXPECT_EQ(ThreadsListHandleTest::get_STLP_has_ref_count(list_ptr1), false)\n+        << \"list_ptr1->_has_ref_count must be false\";\n+    EXPECT_EQ(ThreadsListHandleTest::get_STLP_needs_release(list_ptr1), true)\n+        << \"list_ptr1->_needs_release must be true\";\n+\n+    \/\/ Verify tlh1 ThreadsList has the right field values:\n+    EXPECT_EQ(ThreadsListHandleTest::get_TL_nested_handle_cnt(list_ptr1->list()), (intx)0)\n+        << \"list_ptr1->list()->_nested_handle_cnt must be 0\";\n+\n+    \/\/ Test case: first nested ThreadsListHandle\n+    \/\/\n+    {\n+      ThreadsListHandle tlh2;\n+      SafeThreadsListPtr* list_ptr2 = ThreadsListHandleTest::get_TLH_list_ptr(&tlh2);\n+\n+      \/\/ Verify the current thread refers to tlh2:\n+      EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_hazard_ptr(thr), tlh2.list())\n+          << \"thr->_threads_hazard_ptr must match tlh2.list()\";\n+      EXPECT_EQ(tlh1.list(), tlh2.list())\n+          << \"tlh1.list() must match tlh2.list()\";\n+      EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_list_ptr(thr), list_ptr2)\n+          << \"thr->_threads_list_ptr must match list_ptr2\";\n+      EXPECT_NE(list_ptr1, list_ptr2)\n+          << \"list_ptr1 must not match list_ptr2\";\n+      EXPECT_EQ(ThreadsListHandleTest::get_Thread_nested_threads_hazard_ptr_cnt(thr), (uint)1)\n+          << \"thr->_nested_threads_hazard_ptr_cnt must be 1\";\n+\n+      \/\/ Verify tlh2 has the right field values:\n+      EXPECT_EQ(list_ptr2->previous(), list_ptr1)\n+          << \"list_ptr2->previous() must be list_ptr1\";\n+      EXPECT_EQ(ThreadsListHandleTest::get_STLP_thread(list_ptr2), thr)\n+          << \"list_ptr2->_thread must match current thread\";\n+      EXPECT_EQ(list_ptr2->list(), tlh2.list())\n+          << \"list_ptr2->list() must match tlh2.list()\";\n+      EXPECT_EQ(ThreadsListHandleTest::get_STLP_has_ref_count(list_ptr2), false)\n+          << \"list_ptr2->_has_ref_count must be false\";\n+      EXPECT_EQ(ThreadsListHandleTest::get_STLP_needs_release(list_ptr2), true)\n+          << \"list_ptr2->_needs_release must be true\";\n+\n+      \/\/ Verify tlh1 has the right field values:\n+      EXPECT_EQ(list_ptr1->previous(), (SafeThreadsListPtr*)NULL)\n+          << \"list_ptr1->previous() must be NULL\";\n+      EXPECT_EQ(ThreadsListHandleTest::get_STLP_thread(list_ptr1), thr)\n+          << \"list_ptr1->_thread must match current thread\";\n+      EXPECT_EQ(list_ptr1->list(), tlh1.list())\n+          << \"list_ptr1->list() must match tlh1.list()\";\n+      \/\/ When tlh2 was created, tlh1's _has_ref_count was set to true and\n+      \/\/ tlh1's list->_nested_handle_cnt was incremented.\n+      EXPECT_EQ(ThreadsListHandleTest::get_STLP_has_ref_count(list_ptr1), true)\n+          << \"list_ptr1->_has_ref_count must be true\";\n+      EXPECT_EQ(ThreadsListHandleTest::get_STLP_needs_release(list_ptr1), true)\n+          << \"list_ptr1->_needs_release must be true\";\n+\n+      \/\/ Verify tlh1 ThreadsList has the right field values:\n+      EXPECT_EQ(ThreadsListHandleTest::get_TL_nested_handle_cnt(list_ptr1->list()), (intx)1)\n+          << \"list_ptr1->list()->_nested_handle_cnt must be 1\";\n+    } \/\/ destroy tlh2\n+\n+    \/\/ Test case: after first nested ThreadsListHandle (tlh2) has been destroyed\n+\n+    \/\/ Verify the current thread refers to tlh1:\n+    EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_hazard_ptr(thr), tlh1.list())\n+        << \"thr->_threads_hazard_ptr must match tlh1.list()\";\n+    EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_list_ptr(thr), list_ptr1)\n+        << \"thr->_threads_list_ptr must match list_ptr1\";\n+    EXPECT_EQ(ThreadsListHandleTest::get_Thread_nested_threads_hazard_ptr_cnt(thr), (uint)0)\n+        << \"thr->_nested_threads_hazard_ptr_cnt must be 0\";\n+\n+    \/\/ Verify tlh1 has the right field values:\n+    EXPECT_EQ(list_ptr1->previous(), (SafeThreadsListPtr*)NULL)\n+        << \"list_ptr1->previous() must be NULL\";\n+    EXPECT_EQ(ThreadsListHandleTest::get_STLP_thread(list_ptr1), thr)\n+        << \"list_ptr1->_thread must match current thread\";\n+    EXPECT_EQ(list_ptr1->list(), tlh1.list())\n+        << \"list_ptr1->list() must match tlh1.list()\";\n+    \/\/ When tlh2 was created, tlh1's _has_ref_count was set to true and\n+    \/\/ tlh1's list->_nested_handle_cnt was incremented.\n+    EXPECT_EQ(ThreadsListHandleTest::get_STLP_has_ref_count(list_ptr1), true)\n+        << \"list_ptr1->_has_ref_count must be true\";\n+    EXPECT_EQ(ThreadsListHandleTest::get_STLP_needs_release(list_ptr1), true)\n+        << \"list_ptr1->_needs_release must be true\";\n+\n+      \/\/ Verify tlh1 ThreadsList has the right field values:\n+      EXPECT_EQ(ThreadsListHandleTest::get_TL_nested_handle_cnt(list_ptr1->list()), (intx)1)\n+          << \"list_ptr1->list()->_nested_handle_cnt must be 1\";\n+  } \/\/ destroy tlh1\n+\n+  \/\/ Test case: after first ThreadsListHandle to prepare for nesting has been destroyed\n+  \/\/\n+\n+  \/\/ Verify the current thread refers to no ThreadsListHandle:\n+  EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_hazard_ptr(thr), (ThreadsList*)NULL)\n+      << \"thr->_threads_hazard_ptr must match be NULL\";\n+  EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_list_ptr(thr), (SafeThreadsListPtr*) NULL)\n+      << \"thr->_threads_list_ptr must be NULL\";\n+  EXPECT_EQ(ThreadsListHandleTest::get_Thread_nested_threads_hazard_ptr_cnt(thr), (uint)0)\n+      << \"thr->_nested_threads_hazard_ptr_cnt must be 0\";\n+\n+  \/\/ Test case: first ThreadsListHandle to prepare for double nesting\n+  \/\/\n+  {\n+    ThreadsListHandle tlh1;\n+    SafeThreadsListPtr* list_ptr1 = ThreadsListHandleTest::get_TLH_list_ptr(&tlh1);\n+\n+    \/\/ Verify the current thread refers to tlh1:\n+    EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_hazard_ptr(thr), tlh1.list())\n+        << \"thr->_threads_hazard_ptr must match tlh1.list()\";\n+    EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_list_ptr(thr), list_ptr1)\n+        << \"thr->_threads_list_ptr must match list_ptr1\";\n+    EXPECT_EQ(ThreadsListHandleTest::get_Thread_nested_threads_hazard_ptr_cnt(thr), (uint)0)\n+        << \"thr->_nested_threads_hazard_ptr_cnt must be 0\";\n+\n+    \/\/ Verify tlh1 has the right field values:\n+    EXPECT_EQ(list_ptr1->previous(), (SafeThreadsListPtr*)NULL)\n+        << \"list_ptr1->previous() must be NULL\";\n+    EXPECT_EQ(ThreadsListHandleTest::get_STLP_thread(list_ptr1), thr)\n+        << \"list_ptr1->_thread must match current thread\";\n+    EXPECT_EQ(list_ptr1->list(), tlh1.list())\n+        << \"list_ptr1->list() must match tlh1.list()\";\n+    EXPECT_EQ(ThreadsListHandleTest::get_STLP_has_ref_count(list_ptr1), false)\n+        << \"list_ptr1->_has_ref_count must be false\";\n+    EXPECT_EQ(ThreadsListHandleTest::get_STLP_needs_release(list_ptr1), true)\n+        << \"list_ptr1->_needs_release must be true\";\n+\n+    \/\/ Verify tlh1 ThreadsList has the right field values:\n+    EXPECT_EQ(ThreadsListHandleTest::get_TL_nested_handle_cnt(list_ptr1->list()), (intx)0)\n+        << \"list_ptr1->list()->_nested_handle_cnt must be 0\";\n+\n+    \/\/ Test case: first nested ThreadsListHandle\n+    \/\/\n+    {\n+      ThreadsListHandle tlh2;\n+      SafeThreadsListPtr* list_ptr2 = ThreadsListHandleTest::get_TLH_list_ptr(&tlh2);\n+\n+      \/\/ Verify the current thread refers to tlh2:\n+      EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_hazard_ptr(thr), tlh2.list())\n+          << \"thr->_threads_hazard_ptr must match tlh2.list()\";\n+      EXPECT_EQ(tlh1.list(), tlh2.list())\n+          << \"tlh1.list() must match tlh2.list()\";\n+      EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_list_ptr(thr), list_ptr2)\n+          << \"thr->_threads_list_ptr must match list_ptr2\";\n+      EXPECT_NE(list_ptr1, list_ptr2)\n+          << \"list_ptr1 must not match list_ptr2\";\n+      EXPECT_EQ(ThreadsListHandleTest::get_Thread_nested_threads_hazard_ptr_cnt(thr), (uint)1)\n+          << \"thr->_nested_threads_hazard_ptr_cnt must be 1\";\n+\n+      \/\/ Verify tlh2 has the right field values:\n+      EXPECT_EQ(list_ptr2->previous(), list_ptr1)\n+          << \"list_ptr2->previous() must be list_ptr1\";\n+      EXPECT_EQ(ThreadsListHandleTest::get_STLP_thread(list_ptr2), thr)\n+          << \"list_ptr2->_thread must match current thread\";\n+      EXPECT_EQ(list_ptr2->list(), tlh2.list())\n+          << \"list_ptr2->list() must match tlh2.list()\";\n+      EXPECT_EQ(ThreadsListHandleTest::get_STLP_has_ref_count(list_ptr2), false)\n+          << \"list_ptr2->_has_ref_count must be false\";\n+      EXPECT_EQ(ThreadsListHandleTest::get_STLP_needs_release(list_ptr2), true)\n+          << \"list_ptr2->_needs_release must be true\";\n+\n+      \/\/ Verify tlh1 has the right field values:\n+      EXPECT_EQ(list_ptr1->previous(), (SafeThreadsListPtr*)NULL)\n+          << \"list_ptr1->previous() must be NULL\";\n+      EXPECT_EQ(ThreadsListHandleTest::get_STLP_thread(list_ptr1), thr)\n+          << \"list_ptr1->_thread must match current thread\";\n+      EXPECT_EQ(list_ptr1->list(), tlh1.list())\n+          << \"list_ptr1->list() must match tlh1.list()\";\n+      \/\/ When tlh2 was created, tlh1's _has_ref_count was set to true and\n+      \/\/ tlh1's list->_nested_handle_cnt was incremented.\n+      EXPECT_EQ(ThreadsListHandleTest::get_STLP_has_ref_count(list_ptr1), true)\n+          << \"list_ptr1->_has_ref_count must be true\";\n+      EXPECT_EQ(ThreadsListHandleTest::get_STLP_needs_release(list_ptr1), true)\n+          << \"list_ptr1->_needs_release must be true\";\n+\n+      \/\/ Verify tlh1 ThreadsList has the right field values:\n+      EXPECT_EQ(ThreadsListHandleTest::get_TL_nested_handle_cnt(list_ptr1->list()), (intx)1)\n+          << \"list_ptr1->list()->_nested_handle_cnt must be 1\";\n+\n+      \/\/ Test case: double nested ThreadsListHandle\n+      \/\/\n+      {\n+        ThreadsListHandle tlh3;\n+        SafeThreadsListPtr* list_ptr3 = ThreadsListHandleTest::get_TLH_list_ptr(&tlh3);\n+\n+        \/\/ Verify the current thread refers to tlh3:\n+        EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_hazard_ptr(thr), tlh3.list())\n+            << \"thr->_threads_hazard_ptr must match tlh3.list()\";\n+        EXPECT_EQ(tlh1.list(), tlh3.list())\n+            << \"tlh1.list() must match tlh3.list()\";\n+        EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_list_ptr(thr), list_ptr3)\n+            << \"thr->_threads_list_ptr must match list_ptr3\";\n+        EXPECT_NE(list_ptr1, list_ptr3)\n+            << \"list_ptr1 must not match list_ptr3\";\n+        EXPECT_NE(list_ptr2, list_ptr3)\n+            << \"list_ptr. must not match list_ptr3\";\n+        EXPECT_EQ(ThreadsListHandleTest::get_Thread_nested_threads_hazard_ptr_cnt(thr), (uint)2)\n+            << \"thr->_nested_threads_hazard_ptr_cnt must be 2\";\n+\n+        \/\/ Verify tlh3 has the right field values:\n+        EXPECT_EQ(list_ptr3->previous(), list_ptr2)\n+            << \"list_ptr3->previous() must be list_ptr2\";\n+        EXPECT_EQ(ThreadsListHandleTest::get_STLP_thread(list_ptr3), thr)\n+            << \"list_ptr3->_thread must match current thread\";\n+        EXPECT_EQ(list_ptr3->list(), tlh3.list())\n+            << \"list_ptr3->list() must match tlh3.list()\";\n+        EXPECT_EQ(ThreadsListHandleTest::get_STLP_has_ref_count(list_ptr3), false)\n+            << \"list_ptr3->_has_ref_count must be false\";\n+        EXPECT_EQ(ThreadsListHandleTest::get_STLP_needs_release(list_ptr3), true)\n+            << \"list_ptr3->_needs_release must be true\";\n+\n+        \/\/ Verify tlh2 has the right field values:\n+        EXPECT_EQ(list_ptr2->previous(), list_ptr1)\n+            << \"list_ptr2->previous() must be list_ptr1\";\n+        EXPECT_EQ(ThreadsListHandleTest::get_STLP_thread(list_ptr2), thr)\n+            << \"list_ptr2->_thread must match current thread\";\n+        EXPECT_EQ(list_ptr2->list(), tlh2.list())\n+            << \"list_ptr2->list() must match tlh2.list()\";\n+        \/\/ When tlh3 was created, tlh2's _has_ref_count was set to true and\n+        \/\/ tlh2's list->_nested_handle_cnt was incremented.\n+        EXPECT_EQ(ThreadsListHandleTest::get_STLP_has_ref_count(list_ptr2), true)\n+            << \"list_ptr2->_has_ref_count must be true\";\n+        EXPECT_EQ(ThreadsListHandleTest::get_STLP_needs_release(list_ptr2), true)\n+            << \"list_ptr2->_needs_release must be true\";\n+\n+        \/\/ Verify tlh1 has the right field values:\n+        EXPECT_EQ(list_ptr1->previous(), (SafeThreadsListPtr*)NULL)\n+            << \"list_ptr1->previous() must be NULL\";\n+        EXPECT_EQ(ThreadsListHandleTest::get_STLP_thread(list_ptr1), thr)\n+            << \"list_ptr1->_thread must match current thread\";\n+        EXPECT_EQ(list_ptr1->list(), tlh1.list())\n+            << \"list_ptr1->list() must match tlh1.list()\";\n+        \/\/ When tlh2 was created, tlh1's _has_ref_count was set to true and\n+        \/\/ tlh1's list->_nested_handle_cnt was incremented.\n+        EXPECT_EQ(ThreadsListHandleTest::get_STLP_has_ref_count(list_ptr1), true)\n+            << \"list_ptr1->_has_ref_count must be true\";\n+        EXPECT_EQ(ThreadsListHandleTest::get_STLP_needs_release(list_ptr1), true)\n+            << \"list_ptr1->_needs_release must be true\";\n+\n+        \/\/ Verify tlh1 ThreadsList has the right field values:\n+        EXPECT_EQ(ThreadsListHandleTest::get_TL_nested_handle_cnt(list_ptr1->list()), (intx)2)\n+            << \"list_ptr1->list()->_nested_handle_cnt must be 2\";\n+      } \/\/ destroy tlh3\n+\n+      \/\/ Test case: after double nested ThreadsListHandle (tlh3) has been destroyed\n+\n+      \/\/ Verify the current thread refers to tlh2:\n+      EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_hazard_ptr(thr), tlh2.list())\n+          << \"thr->_threads_hazard_ptr must match tlh2.list()\";\n+      EXPECT_EQ(tlh1.list(), tlh2.list())\n+          << \"tlh1.list() must match tlh2.list()\";\n+      EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_list_ptr(thr), list_ptr2)\n+          << \"thr->_threads_list_ptr must match list_ptr2\";\n+      EXPECT_NE(list_ptr1, list_ptr2)\n+          << \"list_ptr1 must not match list_ptr2\";\n+      EXPECT_EQ(ThreadsListHandleTest::get_Thread_nested_threads_hazard_ptr_cnt(thr), (uint)1)\n+          << \"thr->_nested_threads_hazard_ptr_cnt must be 1\";\n+\n+      \/\/ Verify tlh2 has the right field values:\n+      EXPECT_EQ(list_ptr2->previous(), list_ptr1)\n+          << \"list_ptr2->previous() must be list_ptr1\";\n+      EXPECT_EQ(ThreadsListHandleTest::get_STLP_thread(list_ptr2), thr)\n+          << \"list_ptr2->_thread must match current thread\";\n+      EXPECT_EQ(list_ptr2->list(), tlh2.list())\n+          << \"list_ptr2->list() must match tlh2.list()\";\n+      \/\/ When tlh3 was created, tlh2's _has_ref_count was set to true and\n+      \/\/ tlh2's list->_nested_handle_cnt was incremented.\n+      EXPECT_EQ(ThreadsListHandleTest::get_STLP_has_ref_count(list_ptr2), true)\n+          << \"list_ptr2->_has_ref_count must be true\";\n+      EXPECT_EQ(ThreadsListHandleTest::get_STLP_needs_release(list_ptr2), true)\n+          << \"list_ptr2->_needs_release must be true\";\n+\n+      \/\/ Verify tlh1 has the right field values:\n+      EXPECT_EQ(list_ptr1->previous(), (SafeThreadsListPtr*)NULL)\n+          << \"list_ptr1->previous() must be NULL\";\n+      EXPECT_EQ(ThreadsListHandleTest::get_STLP_thread(list_ptr1), thr)\n+          << \"list_ptr1->_thread must match current thread\";\n+      EXPECT_EQ(list_ptr1->list(), tlh1.list())\n+          << \"list_ptr1->list() must match tlh1.list()\";\n+      \/\/ When tlh2 was created, tlh1's _has_ref_count was set to true and\n+      \/\/ tlh1's list->_nested_handle_cnt was incremented.\n+      EXPECT_EQ(ThreadsListHandleTest::get_STLP_has_ref_count(list_ptr1), true)\n+          << \"list_ptr1->_has_ref_count must be true\";\n+      EXPECT_EQ(ThreadsListHandleTest::get_STLP_needs_release(list_ptr1), true)\n+          << \"list_ptr1->_needs_release must be true\";\n+\n+      \/\/ Verify tlh1 ThreadsList has the right field values:\n+      EXPECT_EQ(ThreadsListHandleTest::get_TL_nested_handle_cnt(list_ptr1->list()), (intx)2)\n+          << \"list_ptr1->list()->_nested_handle_cnt must be 2\";\n+    } \/\/ destroy tlh2\n+\n+    \/\/ Test case: after first nested ThreadsListHandle (tlh2) has been destroyed\n+\n+    \/\/ Verify the current thread refers to tlh1:\n+    EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_hazard_ptr(thr), tlh1.list())\n+        << \"thr->_threads_hazard_ptr must match tlh1.list()\";\n+    EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_list_ptr(thr), list_ptr1)\n+        << \"thr->_threads_list_ptr must match list_ptr1\";\n+    EXPECT_EQ(ThreadsListHandleTest::get_Thread_nested_threads_hazard_ptr_cnt(thr), (uint)0)\n+        << \"thr->_nested_threads_hazard_ptr_cnt must be 0\";\n+\n+    \/\/ Verify tlh1 has the right field values:\n+    EXPECT_EQ(list_ptr1->previous(), (SafeThreadsListPtr*)NULL)\n+        << \"list_ptr1->previous() must be NULL\";\n+    EXPECT_EQ(ThreadsListHandleTest::get_STLP_thread(list_ptr1), thr)\n+        << \"list_ptr1->_thread must match current thread\";\n+    EXPECT_EQ(list_ptr1->list(), tlh1.list())\n+        << \"list_ptr1->list() must match tlh1.list()\";\n+    \/\/ When tlh2 was created, tlh1's _has_ref_count was set to true and\n+    \/\/ tlh1's list->_nested_handle_cnt was incremented.\n+    EXPECT_EQ(ThreadsListHandleTest::get_STLP_has_ref_count(list_ptr1), true)\n+        << \"list_ptr1->_has_ref_count must be true\";\n+    EXPECT_EQ(ThreadsListHandleTest::get_STLP_needs_release(list_ptr1), true)\n+        << \"list_ptr1->_needs_release must be true\";\n+\n+    \/\/ Verify tlh1 ThreadsList has the right field values:\n+    EXPECT_EQ(ThreadsListHandleTest::get_TL_nested_handle_cnt(list_ptr1->list()), (intx)1)\n+        << \"list_ptr1->list()->_nested_handle_cnt must be 1\";\n+  } \/\/ destroy tlh1\n+\n+  \/\/ Test case: after first ThreadsListHandle to prepare for double nesting has been destroyed\n+  \/\/\n+\n+  \/\/ Verify the current thread refers to no ThreadsListHandle:\n+  EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_hazard_ptr(thr), (ThreadsList*)NULL)\n+      << \"thr->_threads_hazard_ptr must match be NULL\";\n+  EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_list_ptr(thr), (SafeThreadsListPtr*) NULL)\n+      << \"thr->_threads_list_ptr must be NULL\";\n+  EXPECT_EQ(ThreadsListHandleTest::get_Thread_nested_threads_hazard_ptr_cnt(thr), (uint)0)\n+      << \"thr->_nested_threads_hazard_ptr_cnt must be 0\";\n+\n+  \/\/ Test case: first ThreadsListHandle to prepare for back-to-back nesting\n+  \/\/\n+  {\n+    ThreadsListHandle tlh1;\n+    SafeThreadsListPtr* list_ptr1 = ThreadsListHandleTest::get_TLH_list_ptr(&tlh1);\n+\n+    \/\/ Verify the current thread refers to tlh1:\n+    EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_hazard_ptr(thr), tlh1.list())\n+        << \"thr->_threads_hazard_ptr must match tlh1.list()\";\n+    EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_list_ptr(thr), list_ptr1)\n+        << \"thr->_threads_list_ptr must match list_ptr1\";\n+    EXPECT_EQ(ThreadsListHandleTest::get_Thread_nested_threads_hazard_ptr_cnt(thr), (uint)0)\n+        << \"thr->_nested_threads_hazard_ptr_cnt must be 0\";\n+\n+    \/\/ Verify tlh1 has the right field values:\n+    EXPECT_EQ(list_ptr1->previous(), (SafeThreadsListPtr*)NULL)\n+        << \"list_ptr1->previous() must be NULL\";\n+    EXPECT_EQ(ThreadsListHandleTest::get_STLP_thread(list_ptr1), thr)\n+        << \"list_ptr1->_thread must match current thread\";\n+    EXPECT_EQ(list_ptr1->list(), tlh1.list())\n+        << \"list_ptr1->list() must match tlh1.list()\";\n+    EXPECT_EQ(ThreadsListHandleTest::get_STLP_has_ref_count(list_ptr1), false)\n+        << \"list_ptr1->_has_ref_count must be false\";\n+    EXPECT_EQ(ThreadsListHandleTest::get_STLP_needs_release(list_ptr1), true)\n+        << \"list_ptr1->_needs_release must be true\";\n+\n+    \/\/ Verify tlh1 ThreadsList has the right field values:\n+    EXPECT_EQ(ThreadsListHandleTest::get_TL_nested_handle_cnt(list_ptr1->list()), (intx)0)\n+        << \"list_ptr1->list()->_nested_handle_cnt must be 0\";\n+\n+    \/\/ Test case: first back-to-back nested ThreadsListHandle\n+    \/\/\n+    {\n+      ThreadsListHandle tlh2a;\n+      SafeThreadsListPtr* list_ptr2a = ThreadsListHandleTest::get_TLH_list_ptr(&tlh2a);\n+\n+      \/\/ Verify the current thread refers to tlh2a:\n+      EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_hazard_ptr(thr), tlh2a.list())\n+          << \"thr->_threads_hazard_ptr must match tlh2a.list()\";\n+      EXPECT_EQ(tlh1.list(), tlh2a.list())\n+          << \"tlh1.list() must match tlh2a.list()\";\n+      EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_list_ptr(thr), list_ptr2a)\n+          << \"thr->_threads_list_ptr must match list_ptr2a\";\n+      EXPECT_NE(list_ptr1, list_ptr2a)\n+          << \"list_ptr1 must not match list_ptr2a\";\n+      EXPECT_EQ(ThreadsListHandleTest::get_Thread_nested_threads_hazard_ptr_cnt(thr), (uint)1)\n+          << \"thr->_nested_threads_hazard_ptr_cnt must be 1\";\n+\n+      \/\/ Verify tlh2a has the right field values:\n+      EXPECT_EQ(list_ptr2a->previous(), list_ptr1)\n+          << \"list_ptr2a->previous() must be list_ptr1\";\n+      EXPECT_EQ(ThreadsListHandleTest::get_STLP_thread(list_ptr2a), thr)\n+          << \"list_ptr2a->_thread must match current thread\";\n+      EXPECT_EQ(list_ptr2a->list(), tlh2a.list())\n+          << \"list_ptr2a->list() must match tlh2a.list()\";\n+      EXPECT_EQ(ThreadsListHandleTest::get_STLP_has_ref_count(list_ptr2a), false)\n+          << \"list_ptr2a->_has_ref_count must be false\";\n+      EXPECT_EQ(ThreadsListHandleTest::get_STLP_needs_release(list_ptr2a), true)\n+          << \"list_ptr2a->_needs_release must be true\";\n+\n+      \/\/ Verify tlh1 has the right field values:\n+      EXPECT_EQ(list_ptr1->previous(), (SafeThreadsListPtr*)NULL)\n+          << \"list_ptr1->previous() must be NULL\";\n+      EXPECT_EQ(ThreadsListHandleTest::get_STLP_thread(list_ptr1), thr)\n+          << \"list_ptr1->_thread must match current thread\";\n+      EXPECT_EQ(list_ptr1->list(), tlh1.list())\n+          << \"list_ptr1->list() must match tlh1.list()\";\n+      \/\/ When tlh2a was created, tlh1's _has_ref_count was set to true and\n+      \/\/ tlh1's list->_nested_handle_cnt was incremented.\n+      EXPECT_EQ(ThreadsListHandleTest::get_STLP_has_ref_count(list_ptr1), true)\n+          << \"list_ptr1->_has_ref_count must be true\";\n+      EXPECT_EQ(ThreadsListHandleTest::get_STLP_needs_release(list_ptr1), true)\n+          << \"list_ptr1->_needs_release must be true\";\n+\n+      \/\/ Verify tlh1 ThreadsList has the right field values:\n+      EXPECT_EQ(ThreadsListHandleTest::get_TL_nested_handle_cnt(list_ptr1->list()), (intx)1)\n+          << \"list_ptr1->list()->_nested_handle_cnt must be 1\";\n+    } \/\/ destroy tlh2a\n+\n+    \/\/ Test case: after first back-to-back nested ThreadsListHandle (tlh2a) has been destroyed\n+\n+    \/\/ Verify the current thread refers to tlh1:\n+    EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_hazard_ptr(thr), tlh1.list())\n+        << \"thr->_threads_hazard_ptr must match tlh1.list()\";\n+    EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_list_ptr(thr), list_ptr1)\n+        << \"thr->_threads_list_ptr must match list_ptr1\";\n+    EXPECT_EQ(ThreadsListHandleTest::get_Thread_nested_threads_hazard_ptr_cnt(thr), (uint)0)\n+        << \"thr->_nested_threads_hazard_ptr_cnt must be 0\";\n+\n+    \/\/ Verify tlh1 has the right field values:\n+    EXPECT_EQ(list_ptr1->previous(), (SafeThreadsListPtr*)NULL)\n+        << \"list_ptr1->previous() must be NULL\";\n+    EXPECT_EQ(ThreadsListHandleTest::get_STLP_thread(list_ptr1), thr)\n+        << \"list_ptr1->_thread must match current thread\";\n+    EXPECT_EQ(list_ptr1->list(), tlh1.list())\n+        << \"list_ptr1->list() must match tlh1.list()\";\n+    \/\/ When tlh2a was created, tlh1's _has_ref_count was set to true and\n+    \/\/ tlh1's list->_nested_handle_cnt was incremented.\n+    EXPECT_EQ(ThreadsListHandleTest::get_STLP_has_ref_count(list_ptr1), true)\n+        << \"list_ptr1->_has_ref_count must be true\";\n+    EXPECT_EQ(ThreadsListHandleTest::get_STLP_needs_release(list_ptr1), true)\n+        << \"list_ptr1->_needs_release must be true\";\n+\n+    \/\/ Verify tlh1 ThreadsList has the right field values:\n+    EXPECT_EQ(ThreadsListHandleTest::get_TL_nested_handle_cnt(list_ptr1->list()), (intx)1)\n+        << \"list_ptr1->list()->_nested_handle_cnt must be 1\";\n+\n+    \/\/ Test case: second back-to-back nested ThreadsListHandle\n+    \/\/\n+    {\n+      ThreadsListHandle tlh2b;\n+      SafeThreadsListPtr* list_ptr2b = ThreadsListHandleTest::get_TLH_list_ptr(&tlh2b);\n+\n+      \/\/ Verify the current thread refers to tlh2b:\n+      EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_hazard_ptr(thr), tlh2b.list())\n+          << \"thr->_threads_hazard_ptr must match tlh2b.list()\";\n+      EXPECT_EQ(tlh1.list(), tlh2b.list())\n+          << \"tlh1.list() must match tlh2b.list()\";\n+      EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_list_ptr(thr), list_ptr2b)\n+          << \"thr->_threads_list_ptr must match list_ptr2b\";\n+      EXPECT_NE(list_ptr1, list_ptr2b)\n+          << \"list_ptr1 must not match list_ptr2b\";\n+      EXPECT_EQ(ThreadsListHandleTest::get_Thread_nested_threads_hazard_ptr_cnt(thr), (uint)1)\n+          << \"thr->_nested_threads_hazard_ptr_cnt must be 1\";\n+\n+      \/\/ Verify tlh2b has the right field values:\n+      EXPECT_EQ(list_ptr2b->previous(), list_ptr1)\n+          << \"list_ptr2b->previous() must be list_ptr1\";\n+      EXPECT_EQ(ThreadsListHandleTest::get_STLP_thread(list_ptr2b), thr)\n+          << \"list_ptr2b->_thread must match current thread\";\n+      EXPECT_EQ(list_ptr2b->list(), tlh2b.list())\n+          << \"list_ptr2b->list() must match tlh2b.list()\";\n+      EXPECT_EQ(ThreadsListHandleTest::get_STLP_has_ref_count(list_ptr2b), false)\n+          << \"list_ptr2b->_has_ref_count must be false\";\n+      EXPECT_EQ(ThreadsListHandleTest::get_STLP_needs_release(list_ptr2b), true)\n+          << \"list_ptr2b->_needs_release must be true\";\n+\n+      \/\/ Verify tlh1 has the right field values:\n+      EXPECT_EQ(list_ptr1->previous(), (SafeThreadsListPtr*)NULL)\n+          << \"list_ptr1->previous() must be NULL\";\n+      EXPECT_EQ(ThreadsListHandleTest::get_STLP_thread(list_ptr1), thr)\n+          << \"list_ptr1->_thread must match current thread\";\n+      EXPECT_EQ(list_ptr1->list(), tlh1.list())\n+          << \"list_ptr1->list() must match tlh1.list()\";\n+      \/\/ When tlh2a was created, tlh1's _has_ref_count was set to true and\n+      \/\/ tlh1's list->_nested_handle_cnt was incremented.\n+      EXPECT_EQ(ThreadsListHandleTest::get_STLP_has_ref_count(list_ptr1), true)\n+          << \"list_ptr1->_has_ref_count must be true\";\n+      EXPECT_EQ(ThreadsListHandleTest::get_STLP_needs_release(list_ptr1), true)\n+          << \"list_ptr1->_needs_release must be true\";\n+\n+      \/\/ Verify tlh1 ThreadsList has the right field values:\n+      EXPECT_EQ(ThreadsListHandleTest::get_TL_nested_handle_cnt(list_ptr1->list()), (intx)1)\n+          << \"list_ptr1->list()->_nested_handle_cnt must be 1\";\n+    } \/\/ destroy tlh2b\n+\n+    \/\/ Test case: after second back-to-back nested ThreadsListHandle (tlh2b) has been destroyed\n+\n+    \/\/ Verify the current thread refers to tlh1:\n+    EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_hazard_ptr(thr), tlh1.list())\n+        << \"thr->_threads_hazard_ptr must match tlh1.list()\";\n+    EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_list_ptr(thr), list_ptr1)\n+        << \"thr->_threads_list_ptr must match list_ptr1\";\n+    EXPECT_EQ(ThreadsListHandleTest::get_Thread_nested_threads_hazard_ptr_cnt(thr), (uint)0)\n+        << \"thr->_nested_threads_hazard_ptr_cnt must be 0\";\n+\n+    \/\/ Verify tlh1 has the right field values:\n+    EXPECT_EQ(list_ptr1->previous(), (SafeThreadsListPtr*)NULL)\n+        << \"list_ptr1->previous() must be NULL\";\n+    EXPECT_EQ(ThreadsListHandleTest::get_STLP_thread(list_ptr1), thr)\n+        << \"list_ptr1->_thread must match current thread\";\n+    EXPECT_EQ(list_ptr1->list(), tlh1.list())\n+        << \"list_ptr1->list() must match tlh1.list()\";\n+    \/\/ When tlh2a was created, tlh1's _has_ref_count was set to true and\n+    \/\/ tlh1's list->_nested_handle_cnt was incremented.\n+    EXPECT_EQ(ThreadsListHandleTest::get_STLP_has_ref_count(list_ptr1), true)\n+        << \"list_ptr1->_has_ref_count must be true\";\n+    EXPECT_EQ(ThreadsListHandleTest::get_STLP_needs_release(list_ptr1), true)\n+        << \"list_ptr1->_needs_release must be true\";\n+\n+    \/\/ Verify tlh1 ThreadsList has the right field values:\n+    EXPECT_EQ(ThreadsListHandleTest::get_TL_nested_handle_cnt(list_ptr1->list()), (intx)1)\n+        << \"list_ptr1->list()->_nested_handle_cnt must be 1\";\n+  } \/\/ destroy tlh1\n+\n+  \/\/ Test case: after first ThreadsListHandle to prepare for back-to-back nesting has been destroyed\n+  \/\/\n+\n+  \/\/ Verify the current thread refers to no ThreadsListHandle:\n+  EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_hazard_ptr(thr), (ThreadsList*)NULL)\n+      << \"thr->_threads_hazard_ptr must match be NULL\";\n+  EXPECT_EQ(ThreadsListHandleTest::get_Thread_threads_list_ptr(thr), (SafeThreadsListPtr*) NULL)\n+      << \"thr->_threads_list_ptr must be NULL\";\n+  EXPECT_EQ(ThreadsListHandleTest::get_Thread_nested_threads_hazard_ptr_cnt(thr), (uint)0)\n+      << \"thr->_nested_threads_hazard_ptr_cnt must be 0\";\n+\n+  EnableThreadSMRStatistics = saved_flag_val;\n+}\n","filename":"test\/hotspot\/gtest\/runtime\/test_ThreadsListHandle.cpp","additions":681,"deletions":0,"binary":false,"changes":681,"status":"added"}]}