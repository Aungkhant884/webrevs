{"files":[{"patch":"@@ -3,1 +3,1 @@\n-\/\/ Copyright (c) 2014, 2020, Red Hat, Inc. All rights reserved.\n+\/\/ Copyright (c) 2014, 2021, Red Hat, Inc. All rights reserved.\n@@ -1919,1 +1919,1 @@\n-  if (UseSVE > 0 && C->max_vector_size() >= 16) {\n+  if (C->max_vector_size() >= 16) {\n@@ -3801,5 +3801,3 @@\n-    if (UseSVE > 0 && Compile::current()->max_vector_size() >= 16) {\n-      \/\/ Only non uncommon_trap calls need to reinitialize ptrue.\n-      if (uncommon_trap_request() == 0) {\n-        __ reinitialize_ptrue();\n-      }\n+    \/\/ Only non uncommon_trap calls need to reinitialize ptrue.\n+    if (Compile::current()->max_vector_size() >= 16 && uncommon_trap_request() == 0) {\n+      __ reinitialize_ptrue();\n@@ -3816,1 +3814,1 @@\n-    } else if (UseSVE > 0 && Compile::current()->max_vector_size() >= 16) {\n+    } else if (Compile::current()->max_vector_size() >= 16) {\n@@ -3854,1 +3852,1 @@\n-    if (UseSVE > 0 && Compile::current()->max_vector_size() >= 16) {\n+    if (Compile::current()->max_vector_size() >= 16) {\n@@ -3867,1 +3865,1 @@\n-    if (UseSVE > 0 && Compile::current()->max_vector_size() >= 16) {\n+    if (Compile::current()->max_vector_size() >= 16) {\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":8,"deletions":10,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1,2 +1,2 @@\n-\/\/ Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n-\/\/ Copyright (c) 2020, Arm Limited. All rights reserved.\n+\/\/ Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2020, 2021, Arm Limited. All rights reserved.\n@@ -87,1 +87,1 @@\n-  format %{ \" # reinterpret $dst,$src\" %}\n+  format %{ \" # reinterpret $dst,$src\\t# D2X\" %}\n@@ -89,1 +89,3 @@\n-    \/\/ If register is the same, then move is not needed.\n+    \/\/ If registers are the same, no register move is required - the\n+    \/\/ upper 64 bits of 'src' are expected to have been initialized\n+    \/\/ to zero.\n@@ -105,1 +107,1 @@\n-  format %{ \" # reinterpret $dst,$src\" %}\n+  format %{ \" # reinterpret $dst,$src\\t# X2D\" %}\n@@ -107,6 +109,5 @@\n-    \/\/ If register is the same, then move is not needed.\n-    if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n-      __ orr(as_FloatRegister($dst$$reg), __ T8B,\n-             as_FloatRegister($src$$reg),\n-             as_FloatRegister($src$$reg));\n-    }\n+    \/\/ Resize the vector from 128-bits to 64-bits. The higher 64-bits of\n+    \/\/ the \"dst\" register must be cleared to zero.\n+    __ orr(as_FloatRegister($dst$$reg), __ T8B,\n+           as_FloatRegister($src$$reg),\n+           as_FloatRegister($src$$reg));\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_neon.ad","additions":12,"deletions":11,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -1,2 +1,2 @@\n-\/\/ Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n-\/\/ Copyright (c) 2020, Arm Limited. All rights reserved.\n+\/\/ Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2020, 2021, Arm Limited. All rights reserved.\n@@ -100,2 +100,2 @@\n-define(`REINTERPRET_X', `\n-instruct reinterpret$1`'2$2`'(vec$2 dst, vec$1 src)\n+\n+instruct reinterpretD2X(vecX dst, vecD src)\n@@ -103,2 +103,2 @@\n-  predicate(n->bottom_type()->is_vect()->length_in_bytes() == $3 &&\n-            n->in(1)->bottom_type()->is_vect()->length_in_bytes() == $4);\n+  predicate(n->bottom_type()->is_vect()->length_in_bytes() == 16 &&\n+            n->in(1)->bottom_type()->is_vect()->length_in_bytes() == 8);\n@@ -107,1 +107,1 @@\n-  format %{ \" # reinterpret $dst,$src\" %}\n+  format %{ \" # reinterpret $dst,$src\\t# D2X\" %}\n@@ -109,1 +109,3 @@\n-    \/\/ If register is the same, then move is not needed.\n+    \/\/ If registers are the same, no register move is required - the\n+    \/\/ upper 64 bits of 'src' are expected to have been initialized\n+    \/\/ to zero.\n@@ -117,5 +119,18 @@\n-%}')dnl\n-dnl           $1 $2 $3  $4\n-REINTERPRET_X(D, X, 16, 8)\n-REINTERPRET_X(X, D, 8,  16)\n-dnl\n+%}\n+\n+instruct reinterpretX2D(vecD dst, vecX src)\n+%{\n+  predicate(n->bottom_type()->is_vect()->length_in_bytes() == 8 &&\n+            n->in(1)->bottom_type()->is_vect()->length_in_bytes() == 16);\n+  match(Set dst (VectorReinterpret src));\n+  ins_cost(INSN_COST);\n+  format %{ \" # reinterpret $dst,$src\\t# X2D\" %}\n+  ins_encode %{\n+    \/\/ Resize the vector from 128-bits to 64-bits. The higher 64-bits of\n+    \/\/ the \"dst\" register must be cleared to zero.\n+    __ orr(as_FloatRegister($dst$$reg), __ T8B,\n+           as_FloatRegister($src$$reg),\n+           as_FloatRegister($src$$reg));\n+  %}\n+  ins_pipe(vlogical64);\n+%}\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_neon_ad.m4","additions":28,"deletions":13,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -357,0 +357,4 @@\n+\n+    \/\/ External runtime call may clobber ptrue reg\n+    __ reinitialize_ptrue();\n+\n@@ -431,5 +435,0 @@\n-    if (UseSVE > 0) {\n-      \/\/ Reinitialize the ptrue predicate register, in case the external runtime\n-      \/\/ call clobbers ptrue reg, as we may return to SVE compiled code.\n-      __ reinitialize_ptrue();\n-    }\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/z\/zBarrierSetAssembler_aarch64.cpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2014, 2020, Red Hat Inc. All rights reserved.\n+ * Copyright (c) 2014, 2021, Red Hat Inc. All rights reserved.\n@@ -2666,0 +2666,2 @@\n+  reinitialize_ptrue();\n+\n@@ -2702,0 +2704,5 @@\n+\n+  if (restore_vectors) {\n+    reinitialize_ptrue();\n+  }\n+\n@@ -5312,1 +5319,3 @@\n-  assert(UseSVE > 0, \"should only be used for SVE\");\n+  if (!UseSVE) {\n+    return;\n+  }\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2014, 2020, Red Hat Inc. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Red Hat Inc. All rights reserved.\n@@ -970,1 +970,3 @@\n-    sve_ptrue(ptrue, B);\n+    if (UseSVE > 0) {\n+      sve_ptrue(ptrue, B);\n+    }\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2014, 2020, Red Hat Inc. All rights reserved.\n+ * Copyright (c) 2014, 2021, Red Hat Inc. All rights reserved.\n@@ -2784,6 +2784,0 @@\n-  if (UseSVE > 0 && save_vectors) {\n-    \/\/ Reinitialize the ptrue predicate register, in case the external runtime\n-    \/\/ call clobbers ptrue reg, as we may return to SVE compiled code.\n-    __ reinitialize_ptrue();\n-  }\n-\n@@ -3012,0 +3006,3 @@\n+  \/\/ May jump to SVE compiled code\n+  __ reinitialize_ptrue();\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2014, 2020, Red Hat Inc. All rights reserved.\n+ * Copyright (c) 2014, 2021, Red Hat Inc. All rights reserved.\n@@ -493,5 +493,4 @@\n-    if (UseSVE > 0 ) {\n-      \/\/ Reinitialize the ptrue predicate register, in case the external runtime\n-      \/\/ call clobbers ptrue reg, as we may return to SVE compiled code.\n-      __ reinitialize_ptrue();\n-    }\n+    \/\/ Reinitialize the ptrue predicate register, in case the external runtime\n+    \/\/ call clobbers ptrue reg, as we may return to SVE compiled code.\n+    __ reinitialize_ptrue();\n+\n@@ -5658,5 +5657,3 @@\n-    if (UseSVE > 0) {\n-      \/\/ Reinitialize the ptrue predicate register, in case the external runtime\n-      \/\/ call clobbers ptrue reg, as we may return to SVE compiled code.\n-      __ reinitialize_ptrue();\n-    }\n+    \/\/ Reinitialize the ptrue predicate register, in case the external runtime\n+    \/\/ call clobbers ptrue reg, as we may return to SVE compiled code.\n+    __ reinitialize_ptrue();\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":8,"deletions":11,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -206,0 +206,4 @@\n+\n+#ifndef ZERO\n+  \/\/ Some Zero platforms do not have expected alignment, and do not use\n+  \/\/ this code. static_assert would still fire and fail for them.\n@@ -207,0 +211,1 @@\n+#endif\n","filename":"src\/hotspot\/share\/ci\/ciMethodData.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -309,0 +309,10 @@\n+void* VtableBlob::operator new(size_t s, unsigned size) throw() {\n+  \/\/ Handling of allocation failure stops compilation and prints a bunch of\n+  \/\/ stuff, which requires unlocking the CodeCache_lock, so that the Compile_lock\n+  \/\/ can be locked, and then re-locking the CodeCache_lock. That is not safe in\n+  \/\/ this context as we hold the CompiledICLocker. So we just don't handle code\n+  \/\/ cache exhaustion here; we leave that for a later allocation that does not\n+  \/\/ hold the CompiledICLocker.\n+  return CodeCache::allocate(size, CodeBlobType::NonNMethod, false \/* handle_alloc_failure *\/);\n+}\n+\n@@ -314,1 +324,1 @@\n-  ThreadInVMfromUnknown __tiv;  \/\/ get to VM state in case we block on CodeCache_lock\n+  assert(JavaThread::current()->thread_state() == _thread_in_vm, \"called with the wrong state\");\n@@ -323,1 +333,13 @@\n-    MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n+    if (!CodeCache_lock->try_lock()) {\n+      \/\/ If we can't take the CodeCache_lock, then this is a bad time to perform the ongoing\n+      \/\/ IC transition to megamorphic, for which this stub will be needed. It is better to\n+      \/\/ bail out the transition, and wait for a more opportune moment. Not only is it not\n+      \/\/ worth waiting for the lock blockingly for the megamorphic transition, it might\n+      \/\/ also result in a deadlock to blockingly wait, when concurrent class unloading is\n+      \/\/ performed. At this point in time, the CompiledICLocker is taken, so we are not\n+      \/\/ allowed to blockingly wait for the CodeCache_lock, as these two locks are otherwise\n+      \/\/ consistently taken in the opposite order. Bailing out results in an IC transition to\n+      \/\/ the clean state instead, which will cause subsequent calls to retry the transitioning\n+      \/\/ eventually.\n+      return NULL;\n+    }\n@@ -325,0 +347,1 @@\n+    CodeCache_lock->unlock();\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":25,"deletions":2,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -68,1 +68,3 @@\n-\n+  \/\/ Chunk size should be at least (unmodified) page size as using multiple threads\n+  \/\/ pretouch on a single page can decrease performance.\n+  size_t chunk_size = MAX2(PretouchTask::chunk_size(), page_size);\n@@ -74,1 +76,0 @@\n-  size_t chunk_size = MAX2(PretouchTask::chunk_size(), page_size);\n","filename":"src\/hotspot\/share\/gc\/shared\/pretouchTask.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -136,1 +136,1 @@\n-  uint nworkers = ergo_workers(MIN2(workers->active_workers(),\n+  uint nworkers = ergo_workers(MIN2(workers->total_workers(),\n@@ -149,1 +149,1 @@\n-  uint nworkers = ergo_workers(workers->active_workers());\n+  uint nworkers = ergo_workers(workers->total_workers());\n","filename":"src\/hotspot\/share\/gc\/shared\/weakProcessor.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2048,1 +2048,2 @@\n-  if (is_instance) {\n+  bool is_vect = (_type->isa_vect() != NULL);\n+  if (is_instance && !is_vect) {\n@@ -2051,1 +2052,2 @@\n-    \/\/ so just return a zero of the appropriate type\n+    \/\/ so just return a zero of the appropriate type -\n+    \/\/ except if it is vectorized - then we have no zero constant.\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -115,0 +115,1 @@\n+    final boolean dumpMethodReferenceSearchResults;\n@@ -154,0 +155,1 @@\n+        dumpMethodReferenceSearchResults = options.isSet(\"debug.dumpMethodReferenceSearchResults\");\n@@ -2780,1 +2782,1 @@\n-                    spMethod.owner == sym.owner) {\n+                spMethod.owner == sym.owner) {\n@@ -3093,0 +3095,3 @@\n+        if (dumpMethodReferenceSearchResults) {\n+            dumpMethodReferenceSearchResults(referenceTree, boundSearchResolveContext, boundSym, true);\n+        }\n@@ -3106,0 +3111,3 @@\n+            if (dumpMethodReferenceSearchResults) {\n+                dumpMethodReferenceSearchResults(referenceTree, unboundSearchResolveContext, unboundSym, false);\n+            }\n@@ -3129,0 +3137,36 @@\n+    private void dumpMethodReferenceSearchResults(JCMemberReference referenceTree,\n+                                                  MethodResolutionContext resolutionContext,\n+                                                  Symbol bestSoFar,\n+                                                  boolean bound) {\n+        ListBuffer<JCDiagnostic> subDiags = new ListBuffer<>();\n+        int pos = 0;\n+        int mostSpecificPos = -1;\n+        for (Candidate c : resolutionContext.candidates) {\n+            if (resolutionContext.step != c.step || !c.isApplicable()) {\n+                continue;\n+            } else {\n+                JCDiagnostic subDiag = null;\n+                if (c.sym.type.hasTag(FORALL)) {\n+                    subDiag = diags.fragment(Fragments.PartialInstSig(c.mtype));\n+                }\n+\n+                String key = subDiag == null ?\n+                        \"applicable.method.found.2\" :\n+                        \"applicable.method.found.3\";\n+                subDiags.append(diags.fragment(key, pos,\n+                        c.sym.isStatic() ? Fragments.Static : Fragments.NonStatic, c.sym, subDiag));\n+                if (c.sym == bestSoFar)\n+                    mostSpecificPos = pos;\n+                pos++;\n+            }\n+        }\n+        JCDiagnostic main = diags.note(\n+                log.currentSource(),\n+                referenceTree,\n+                \"method.ref.search.results.multi\",\n+                bound ? Fragments.Bound : Fragments.Unbound,\n+                referenceTree.toString(), mostSpecificPos);\n+        JCDiagnostic d = new JCDiagnostic.MultilineDiagnostic(main, subDiags.toList());\n+        log.report(d);\n+    }\n+\n@@ -3283,1 +3327,1 @@\n-            if (boundRes.hasKind(StaticKind.STATIC) &&\n+            if (boundRes.isSuccess() && boundRes.sym.isStatic() &&\n@@ -3288,1 +3332,1 @@\n-            } else if (unboundRes.hasKind(StaticKind.NON_STATIC) &&\n+            } else if (unboundRes.isSuccess() && !unboundRes.sym.isStatic() &&\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":47,"deletions":3,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -3076,0 +3076,31 @@\n+########################################\n+# Diagnostics for method reference search\n+# results used by Resolve (debug only)\n+########################################\n+\n+# 0: fragment, 1: string, 2: number\n+compiler.note.method.ref.search.results.multi=\\\n+    {0} search results for {1}, with most specific {2}\\n\\\n+    applicable candidates:\n+\n+# 0: number, 1: fragment, 2: symbol\n+compiler.misc.applicable.method.found.2=\\\n+    #{0} applicable method found: {1} {2}\n+\n+# 0: number, 1: fragment, 2: symbol, 3: message segment\n+compiler.misc.applicable.method.found.3=\\\n+    #{0} applicable method found: {1} {2}\\n\\\n+    ({3})\n+\n+compiler.misc.static=\\\n+    static\n+\n+compiler.misc.non.static=\\\n+    non-static\n+\n+compiler.misc.bound=\\\n+    bound\n+\n+compiler.misc.unbound=\\\n+    unbound\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":31,"deletions":0,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -221,1 +221,1 @@\n-    The {0) page lists references to system properties.\n+    The {0} page lists references to system properties.\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/standard.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -87,0 +87,1 @@\n+runtime\/cds\/appcds\/jigsaw\/modulepath\/ModulePathAndCP_JFR.java 8253437 windows-x64\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -338,0 +338,1 @@\n+ -runtime\/cds\/appcds\/LambdaWithOldClass.java \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -837,0 +837,2 @@\n+jdk\/jfr\/startupargs\/TestStartName.java                          8214685 windows-x64\n+jdk\/jfr\/startupargs\/TestStartDuration.java                      8214685 windows-x64\n@@ -879,0 +881,1 @@\n+java\/awt\/Focus\/AppletInitialFocusTest\/AppletInitialFocusTest1.java 8256289 windows-x64\n","filename":"test\/jdk\/ProblemList.txt","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"}]}