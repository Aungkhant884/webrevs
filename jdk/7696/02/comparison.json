{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,25 +28,0 @@\n-import java.io.EOFException;\n-import java.io.IOException;\n-import java.io.UncheckedIOException;\n-import java.net.InetSocketAddress;\n-import java.net.URI;\n-import java.nio.ByteBuffer;\n-import java.nio.charset.StandardCharsets;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.concurrent.CompletableFuture;\n-import java.util.ArrayList;\n-import java.util.Objects;\n-import java.util.concurrent.ConcurrentMap;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.ConcurrentLinkedQueue;\n-import java.util.concurrent.Flow;\n-import java.util.function.Function;\n-import java.util.function.Supplier;\n-import javax.net.ssl.SSLEngine;\n-import javax.net.ssl.SSLException;\n-import java.net.http.HttpClient;\n-import java.net.http.HttpHeaders;\n@@ -78,1 +53,0 @@\n-import jdk.internal.net.http.hpack.Encoder;\n@@ -81,0 +55,28 @@\n+import jdk.internal.net.http.hpack.Encoder;\n+\n+import javax.net.ssl.SSLEngine;\n+import javax.net.ssl.SSLException;\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.net.InetSocketAddress;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpHeaders;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.Flow;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n@@ -266,0 +268,2 @@\n+    private record PushContinuationState(HeaderDecoder pushContDecoder, PushPromiseFrame pushContFrame) {}\n+    private volatile PushContinuationState pushContinuationState;\n@@ -778,2 +782,2 @@\n-                    if (frame instanceof DataFrame) {\n-                        dropDataFrame((DataFrame)frame);\n+                    if (frame instanceof DataFrame df) {\n+                        dropDataFrame(df);\n@@ -796,16 +800,15 @@\n-            if (frame instanceof PushPromiseFrame) {\n-                PushPromiseFrame pp = (PushPromiseFrame)frame;\n-                try {\n-                    handlePushPromise(stream, pp);\n-                } catch (UncheckedIOException e) {\n-                    protocolError(ResetFrame.PROTOCOL_ERROR, e.getMessage());\n-                    return;\n-                }\n-            } else if (frame instanceof HeaderFrame) {\n-                \/\/ decode headers (or continuation)\n-                try {\n-                    decodeHeaders((HeaderFrame) frame, stream.rspHeadersConsumer());\n-                } catch (UncheckedIOException e) {\n-                    debug.log(\"Error decoding headers: \" + e.getMessage(), e);\n-                    protocolError(ResetFrame.PROTOCOL_ERROR, e.getMessage());\n-                    return;\n+\n+            \/\/ While push frame is not null, the only acceptable frame on this\n+            \/\/ stream is a Continuation frame\n+            if (pushContinuationState != null) {\n+                if (frame instanceof ContinuationFrame cf) {\n+                    try {\n+                        handlePushContinuation(stream, cf);\n+                    } catch (UncheckedIOException e) {\n+                        debug.log(\"Error handling Push Promise with Continuation: \" + e.getMessage(), e);\n+                        protocolError(ResetFrame.PROTOCOL_ERROR, e.getMessage());\n+                    }\n+                } else {\n+                    \/\/ TODO: Maybe say what kind of frame was received instead\n+                    pushContinuationState = null;\n+                    protocolError(ErrorFrame.PROTOCOL_ERROR, \"Expected a Continuation frame but received \" + frame);\n@@ -813,1 +816,0 @@\n-                stream.incoming(frame);\n@@ -815,1 +817,20 @@\n-                stream.incoming(frame);\n+                if (frame instanceof PushPromiseFrame pp) {\n+                    try {\n+                        handlePushPromise(stream, pp);\n+                    } catch (UncheckedIOException e) {\n+                        protocolError(ResetFrame.PROTOCOL_ERROR, e.getMessage());\n+                        return;\n+                    }\n+                } else if (frame instanceof HeaderFrame hf) {\n+                    \/\/ decode headers\n+                    try {\n+                        decodeHeaders(hf, stream.rspHeadersConsumer());\n+                    } catch (UncheckedIOException e) {\n+                        debug.log(\"Error decoding headers: \" + e.getMessage(), e);\n+                        protocolError(ResetFrame.PROTOCOL_ERROR, e.getMessage());\n+                        return;\n+                    }\n+                    stream.incoming(frame);\n+                } else {\n+                    stream.incoming(frame);\n+                }\n@@ -846,0 +867,1 @@\n+        assert pushContinuationState == null;\n@@ -848,0 +870,7 @@\n+        int promisedStreamid = pp.getPromisedStream();\n+        if (pp.endHeaders()) {\n+            completePushPromise(promisedStreamid, parent, decoder.headers());\n+        } else {\n+            pushContinuationState = new PushContinuationState(decoder, pp);\n+        }\n+    }\n@@ -849,0 +878,15 @@\n+    private <T> void handlePushContinuation(Stream<T> parent, ContinuationFrame cf)\n+            throws IOException {\n+        decodeHeaders(cf, pushContinuationState.pushContDecoder);\n+        \/\/ if all continuations are sent, set pushWithContinuation to null\n+        if (cf.endHeaders()) {\n+            completePushPromise(pushContinuationState.pushContFrame.getPromisedStream(), parent,\n+                    pushContinuationState.pushContDecoder.headers());\n+            pushContinuationState = null;\n+        }\n+    }\n+\n+    private <T> void completePushPromise(int promisedStreamid, Stream<T> parent, HttpHeaders headers)\n+            throws IOException {\n+        \/\/ Perhaps the following checks could be moved to handlePushPromise()\n+        \/\/ to reset the PushPromise stream earlier?\n@@ -850,1 +894,0 @@\n-        int promisedStreamid = pp.getPromisedStream();\n@@ -861,1 +904,0 @@\n-        HttpHeaders headers = decoder.headers();\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http2Connection.java","additions":91,"deletions":49,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -0,0 +1,288 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8263031\n+ * @summary Tests that the HttpClient can correctly receive a Push Promise\n+ *          Frame with the END_HEADERS flag unset followed by one or more\n+ *          Continuation Frames.\n+ * @library \/test\/lib server\n+ * @build jdk.test.lib.net.SimpleSSLContext\n+ * @modules java.base\/sun.net.www.http\n+ *          java.net.http\/jdk.internal.net.http.common\n+ *          java.net.http\/jdk.internal.net.http.frame\n+ *          java.net.http\/jdk.internal.net.http.hpack\n+ * @run testng\/othervm PushPromiseContinuation\n+ *\/\n+\n+\n+import jdk.internal.net.http.common.HttpHeadersBuilder;\n+import jdk.internal.net.http.frame.ContinuationFrame;\n+import jdk.internal.net.http.frame.HeaderFrame;\n+import org.testng.TestException;\n+import org.testng.annotations.AfterTest;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.Test;\n+\n+import javax.net.ssl.SSLSession;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpHeaders;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.function.BiPredicate;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static org.testng.Assert.assertEquals;\n+\n+public class PushPromiseContinuation {\n+\n+    static HttpHeaders testHeaders;\n+    static HttpHeadersBuilder testHeadersBuilder;\n+    static int continuationCount;\n+    Http2TestServer server;\n+    URI uri;\n+\n+    \/\/ Set up simple client-side push promise handler\n+    ConcurrentMap<HttpRequest, HttpRequest> resultMap = new ConcurrentHashMap<>();\n+    HttpResponse.PushPromiseHandler<String> pph = (initial, pushRequest, acceptor) -> {\n+        HttpResponse.BodyHandler<String> s = HttpResponse.BodyHandlers.ofString(UTF_8);\n+        acceptor.apply(s);\n+        resultMap.put(initial, pushRequest);\n+    };\n+\n+    @BeforeTest\n+    public void setup() throws Exception {\n+        resultMap = new ConcurrentHashMap<>();\n+\n+        server = new Http2TestServer(false, 0);\n+        server.addHandler(new ServerPushHandler(\"Main Response Body\", \"\/promise\"), \"\/\");\n+\n+        \/\/ Need to have a custom exchange supplier to manage the server's push\n+        \/\/ promise with continuation flow\n+        server.setExchangeSupplier(Http2LPPTestExchangeImpl::new);\n+\n+        System.err.println(\"PushPromiseContinuation: Server listening on port \" + server.getAddress().getPort());\n+        server.start();\n+        int port = server.getAddress().getPort();\n+        uri = new URI(\"http:\/\/localhost:\" + port + \"\/\");\n+    }\n+\n+    @AfterTest\n+    public void teardown() {\n+        resultMap = null;\n+    }\n+\n+    \/**\n+     * Tests that when the client receives PushPromise Frame with the END_HEADERS\n+     * flag set to 0x0 and subsequently receives a continuation frame, no exception\n+     * is thrown and all headers from the PushPromise and Continuation Frames sent\n+     * by the server arrive at the client.\n+     *\/\n+    @Test\n+    public void testOneContinuation() {\n+        continuationCount = 1;\n+        HttpClient client = HttpClient.newHttpClient();\n+\n+        \/\/ Carry out request\n+        HttpRequest hreq = HttpRequest.newBuilder(uri).version(HttpClient.Version.HTTP_2).GET().build();\n+        CompletableFuture<HttpResponse<String>> cf =\n+                client.sendAsync(hreq, HttpResponse.BodyHandlers.ofString(UTF_8), pph);\n+        cf.join();\n+\n+        \/\/ Verify results\n+        verify();\n+    }\n+\n+    \/**\n+     * Same as above, but tests for the case where two Continuation Frames are sent\n+     * with the END_HEADERS flag set only on the last frame.\n+     *\/\n+    @Test\n+    public void testTwoContinuations() {\n+        continuationCount = 2;\n+        HttpClient client = HttpClient.newHttpClient();\n+\n+        \/\/ Carry out request\n+        HttpRequest hreq = HttpRequest.newBuilder(uri).version(HttpClient.Version.HTTP_2).GET().build();\n+        CompletableFuture<HttpResponse<String>> cf =\n+                client.sendAsync(hreq, HttpResponse.BodyHandlers.ofString(UTF_8), pph);\n+        cf.join();\n+\n+        \/\/ Verify results\n+        verify();\n+    }\n+\n+    private void verify() {\n+        if (resultMap.size() > 1) {\n+            throw new TestException(\"Results map size is greater than 1\");\n+        } else {\n+            \/\/ This will only iterate once\n+            for (HttpRequest r : resultMap.keySet()) {\n+                HttpRequest serverPushReq = resultMap.get(r);\n+                \/\/ Received headers should be the same as the combined PushPromise\n+                \/\/ frame headers combined with the Continuation frame headers\n+                assertEquals(testHeaders, serverPushReq.headers());\n+            }\n+        }\n+    }\n+\n+    static class Http2LPPTestExchangeImpl extends Http2TestExchangeImpl {\n+\n+        HttpHeadersBuilder pushPromiseHeadersBuilder;\n+        List<ContinuationFrame> cfs;\n+\n+        Http2LPPTestExchangeImpl(int streamid, String method, HttpHeaders reqheaders,\n+                                 HttpHeadersBuilder rspheadersBuilder, URI uri, InputStream is,\n+                                 SSLSession sslSession, BodyOutputStream os,\n+                                 Http2TestServerConnection conn, boolean pushAllowed) {\n+            super(streamid, method, reqheaders, rspheadersBuilder, uri, is, sslSession, os, conn, pushAllowed);\n+        }\n+\n+        private void setPushHeaders(String name, String value) {\n+            pushPromiseHeadersBuilder.setHeader(name, value);\n+            testHeadersBuilder.setHeader(name, value);\n+        }\n+\n+        private void assembleContinuations() {\n+            for (int i = 0; i < continuationCount; i++) {\n+                HttpHeadersBuilder builder = new HttpHeadersBuilder();\n+                for (int j = 0; j < 10; j++) {\n+                    String name = \"x-cont-\" + i + \"-\" + j;\n+                    builder.setHeader(name, \"data_\" + j);\n+                    testHeadersBuilder.setHeader(name, \"data_\" + j);\n+                }\n+\n+                ContinuationFrame cf = new ContinuationFrame(streamid, 0x0, conn.encodeHeaders(builder.build()));\n+                \/\/ If this is the last Continuation Frame, set the END_HEADERS flag.\n+                if (i >= continuationCount - 1) {\n+                    cf.setFlag(HeaderFrame.END_HEADERS);\n+                }\n+                cfs.add(cf);\n+            }\n+        }\n+\n+        @Override\n+        public void serverPush(URI uri, HttpHeaders headers, InputStream content) {\n+            pushPromiseHeadersBuilder = new HttpHeadersBuilder();\n+            testHeadersBuilder = new HttpHeadersBuilder();\n+            cfs = new ArrayList<>();\n+\n+            setPushHeaders(\":method\", \"GET\");\n+            setPushHeaders(\":scheme\", uri.getScheme());\n+            setPushHeaders(\":authority\", uri.getAuthority());\n+            setPushHeaders(\":path\", uri.getPath());\n+            for (Map.Entry<String,List<String>> entry : headers.map().entrySet()) {\n+                for (String value : entry.getValue()) {\n+                    setPushHeaders(entry.getKey(), value);\n+                }\n+            }\n+\n+            for (int i = 0; i < 10; i++) {\n+                setPushHeaders(\"x-push-header-\" + i, \"data_\" + i);\n+            }\n+\n+            \/\/ Create the Continuation Frame\/s, done before Push Promise Frame for test purposes\n+            \/\/ as testHeaders contains all headers used in all frames\n+            assembleContinuations();\n+\n+            HttpHeaders pushPromiseHeaders = pushPromiseHeadersBuilder.build();\n+            testHeaders = testHeadersBuilder.build();\n+            \/\/ Create the Push Promise Frame\n+            OutgoingPushPromise pp = new OutgoingPushPromise(streamid, uri, pushPromiseHeaders, content);\n+            \/\/ Indicates to the client that a continuation should be expected\n+            pp.setFlag(0x0);\n+\n+            try {\n+                \/\/ Schedule push promise and continuation for sending\n+                conn.outputQ.put(pp);\n+                System.err.println(\"Server: Scheduled a Continuation to Send\");\n+                for (ContinuationFrame cf : cfs) {\n+                    conn.outputQ.put(cf);\n+                    System.err.println(\"Server: Scheduled a Continuation to Send\");\n+                }\n+            } catch (IOException ex) {\n+                System.err.println(\"Server: pushPromise exception: \" + ex);\n+            }\n+        }\n+    }\n+\n+    static class ServerPushHandler implements Http2Handler {\n+\n+        private final String mainResponseBody;\n+        private final String mainPromiseBody;\n+\n+        public ServerPushHandler(String mainResponseBody,\n+                                 String promise)\n+        {\n+            Objects.requireNonNull(promise);\n+            this.mainResponseBody = mainResponseBody;\n+            this.mainPromiseBody = \"Main Promise Body\";\n+        }\n+\n+        public void handle(Http2TestExchange exchange) throws IOException {\n+            System.err.println(\"Server: handle \" + exchange);\n+            try (InputStream is = exchange.getRequestBody()) {\n+                is.readAllBytes();\n+            }\n+\n+            if (exchange.serverPushAllowed()) {\n+                pushPromise(exchange);\n+            }\n+\n+            \/\/ response data for the main response\n+            try (OutputStream os = exchange.getResponseBody()) {\n+                byte[] bytes = mainResponseBody.getBytes(UTF_8);\n+                exchange.sendResponseHeaders(200, bytes.length);\n+                os.write(bytes);\n+            }\n+        }\n+\n+        static final BiPredicate<String,String> ACCEPT_ALL = (x, y) -> true;\n+\n+\n+        private void pushPromise(Http2TestExchange exchange) throws IOException {\n+            URI requestURI = exchange.getRequestURI();\n+            URI uri = requestURI.resolve(\"\/promise\");\n+            InputStream is = new ByteArrayInputStream(\"Test_String\".getBytes(UTF_8));\n+            Map<String, List<String>> map = new HashMap<>();\n+            map.put(\"x-promise\", List.of(mainPromiseBody));\n+            HttpHeaders headers = HttpHeaders.of(map, ACCEPT_ALL);\n+            exchange.serverPush(uri, headers, is);\n+            System.err.println(\"Server: Push sent\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/http2\/PushPromiseContinuation.java","additions":288,"deletions":0,"binary":false,"changes":288,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,6 @@\n+import jdk.internal.net.http.common.HttpHeadersBuilder;\n+import jdk.internal.net.http.frame.HeaderFrame;\n+import jdk.internal.net.http.frame.HeadersFrame;\n+\n+import javax.net.ssl.SSLSession;\n+import java.io.IOException;\n@@ -26,2 +32,0 @@\n-import java.io.IOException;\n-import java.net.URI;\n@@ -29,0 +33,1 @@\n+import java.net.URI;\n@@ -33,4 +38,0 @@\n-import javax.net.ssl.SSLSession;\n-import jdk.internal.net.http.common.HttpHeadersBuilder;\n-import jdk.internal.net.http.frame.HeaderFrame;\n-import jdk.internal.net.http.frame.HeadersFrame;\n@@ -194,0 +195,1 @@\n+        pp.setFlag(HeaderFrame.END_HEADERS);\n","filename":"test\/jdk\/java\/net\/httpclient\/http2\/server\/Http2TestExchangeImpl.java","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,27 @@\n+import jdk.internal.net.http.common.HttpHeadersBuilder;\n+import jdk.internal.net.http.frame.DataFrame;\n+import jdk.internal.net.http.frame.ErrorFrame;\n+import jdk.internal.net.http.frame.FramesDecoder;\n+import jdk.internal.net.http.frame.FramesEncoder;\n+import jdk.internal.net.http.frame.GoAwayFrame;\n+import jdk.internal.net.http.frame.HeaderFrame;\n+import jdk.internal.net.http.frame.HeadersFrame;\n+import jdk.internal.net.http.frame.Http2Frame;\n+import jdk.internal.net.http.frame.PingFrame;\n+import jdk.internal.net.http.frame.PushPromiseFrame;\n+import jdk.internal.net.http.frame.ResetFrame;\n+import jdk.internal.net.http.frame.SettingsFrame;\n+import jdk.internal.net.http.frame.WindowUpdateFrame;\n+import jdk.internal.net.http.hpack.Decoder;\n+import jdk.internal.net.http.hpack.DecodingCallback;\n+import jdk.internal.net.http.hpack.Encoder;\n+import sun.net.www.http.ChunkedInputStream;\n+import sun.net.www.http.HttpClient;\n+\n+import javax.net.ssl.SNIHostName;\n+import javax.net.ssl.SNIMatcher;\n+import javax.net.ssl.SNIServerName;\n+import javax.net.ssl.SSLParameters;\n+import javax.net.ssl.SSLSession;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.StandardConstants;\n@@ -28,1 +55,0 @@\n-import java.io.UncheckedIOException;\n@@ -31,0 +57,2 @@\n+import java.io.UncheckedIOException;\n+import java.net.InetAddress;\n@@ -33,2 +61,0 @@\n-import java.net.InetAddress;\n-import javax.net.ssl.*;\n@@ -38,1 +64,12 @@\n-import java.util.*;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Properties;\n+import java.util.Random;\n@@ -40,1 +77,0 @@\n-import java.util.concurrent.ExecutorService;\n@@ -42,0 +78,1 @@\n+import java.util.concurrent.ExecutorService;\n@@ -43,7 +80,1 @@\n-import jdk.internal.net.http.common.HttpHeadersBuilder;\n-import jdk.internal.net.http.frame.*;\n-import jdk.internal.net.http.hpack.Decoder;\n-import jdk.internal.net.http.hpack.DecodingCallback;\n-import jdk.internal.net.http.hpack.Encoder;\n-import sun.net.www.http.ChunkedInputStream;\n-import sun.net.www.http.HttpClient;\n+\n@@ -909,1 +940,1 @@\n-                                                   HeaderFrame.END_HEADERS,\n+                                                   op.getFlags(),\n","filename":"test\/jdk\/java\/net\/httpclient\/http2\/server\/Http2TestServerConnection.java","additions":45,"deletions":14,"binary":false,"changes":59,"status":"modified"}]}