{"files":[{"patch":"@@ -28,0 +28,1 @@\n+import java.lang.constant.ConstantDescs;\n@@ -100,0 +101,3 @@\n+    private static final ClassDesc CD_Foo = ClassDesc.of(\"Foo\");\n+    private static final ClassDesc CD_Bar = ClassDesc.of(\"Bar\");\n+\n@@ -103,1 +107,1 @@\n-                Map.of(ClassDesc.of(\"Foo\"), ClassDesc.of(\"Bar\")));\n+                Map.of(CD_Foo, CD_Bar));\n@@ -206,1 +210,1 @@\n-                                            && !\"<init>\".equals(mm.methodName().stringValue())\n+                                            && !ConstantDescs.INIT_NAME.equals(mm.methodName().stringValue())\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/components\/snippet-files\/PackageSnippets.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.util.ArrayDeque;\n@@ -33,1 +34,0 @@\n-import java.util.LinkedList;\n@@ -127,0 +127,8 @@\n+    private static final ClassDesc CD_Hello = ClassDesc.of(\"Hello\");\n+    private static final ClassDesc CD_Foo = ClassDesc.of(\"Foo\");\n+    private static final ClassDesc CD_Bar = ClassDesc.of(\"Bar\");\n+    private static final ClassDesc CD_System = ClassDesc.of(\"java.lang.System\");\n+    private static final ClassDesc CD_PrintStream = ClassDesc.of(\"java.io.PrintStream\");\n+    private static final MethodTypeDesc MTD_void_StringArray = MethodTypeDesc.of(ConstantDescs.CD_void, ConstantDescs.CD_String.arrayType());\n+    private static final MethodTypeDesc MTD_void_String = MethodTypeDesc.of(ConstantDescs.CD_void, ConstantDescs.CD_String);\n+\n@@ -129,1 +137,1 @@\n-        byte[] bytes = Classfile.build(ClassDesc.of(\"Hello\"), cb -> {\n+        byte[] bytes = Classfile.build(CD_Hello, cb -> {\n@@ -131,1 +139,1 @@\n-            cb.withMethod(\"<init>\", MethodTypeDesc.of(ConstantDescs.CD_void), Classfile.ACC_PUBLIC,\n+            cb.withMethod(ConstantDescs.INIT_NAME, ConstantDescs.MTD_void, Classfile.ACC_PUBLIC,\n@@ -134,2 +142,2 @@\n-                                        .invokespecial(ConstantDescs.CD_Object, \"<init>\",\n-                                                       MethodTypeDesc.of(ConstantDescs.CD_void))\n+                                        .invokespecial(ConstantDescs.CD_Object, ConstantDescs.INIT_NAME,\n+                                                       ConstantDescs.MTD_void)\n@@ -139,1 +147,1 @@\n-              .withMethod(\"main\", MethodTypeDesc.of(ConstantDescs.CD_void, ConstantDescs.CD_String.arrayType()),\n+              .withMethod(\"main\", MTD_void_StringArray,\n@@ -143,1 +151,1 @@\n-                                  b -> b.getstatic(ClassDesc.of(\"java.lang.System\"), \"out\", ClassDesc.of(\"java.io.PrintStream\"))\n+                                  b -> b.getstatic(CD_System, \"out\", CD_PrintStream)\n@@ -145,2 +153,1 @@\n-                                        .invokevirtual(ClassDesc.of(\"java.io.PrintStream\"), \"println\",\n-                                                       MethodTypeDesc.of(ConstantDescs.CD_void, ConstantDescs.CD_String))\n+                                        .invokevirtual(CD_PrintStream, \"println\", MTD_void_String)\n@@ -183,1 +190,1 @@\n-                        b.invokeInstruction(i.opcode(), ClassDesc.of(\"Bar\"), i.name().stringValue(), i.typeSymbol(), i.isInterface());\n+                        b.invokeInstruction(i.opcode(), CD_Bar, i.name().stringValue(), i.typeSymbol(), i.isInterface());\n@@ -193,1 +200,1 @@\n-                b.getstatic(ClassDesc.of(\"java.lang.System\"), \"out\", ClassDesc.of(\"java.io.PrintStream\"))\n+                b.getstatic(CD_System, \"out\", CD_PrintStream)\n@@ -195,2 +202,1 @@\n-                 .invokevirtual(ClassDesc.of(\"java.io.PrintStream\"), \"println\",\n-                                MethodTypeDesc.of(ConstantDescs.CD_void, ConstantDescs.CD_String));\n+                 .invokevirtual(CD_PrintStream, \"println\", MTD_void_String);\n@@ -218,1 +224,1 @@\n-                                                              codeBuilder.invokeInstruction(i.opcode(), ClassDesc.of(\"Bar\"),\n+                                                              codeBuilder.invokeInstruction(i.opcode(), CD_Bar,\n@@ -269,1 +275,1 @@\n-                                                var storeStack = new LinkedList<StoreInstruction>();\n+                                                var storeStack = new ArrayDeque<StoreInstruction>();\n@@ -304,1 +310,1 @@\n-                                            && !\"<init>\".equals(mm.methodName().stringValue())\n+                                            && !ConstantDescs.INIT_NAME.equals(mm.methodName().stringValue())\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/snippet-files\/PackageSnippets.java","additions":22,"deletions":16,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -84,0 +84,1 @@\n+import jdk.internal.vm.annotation.Stable;\n@@ -121,0 +122,2 @@\n+    private static final MethodTypeDesc MTD_StringArray = MethodTypeDesc.of(CD_String.arrayType());\n+    private static final MethodTypeDesc MTD_SystemModules = MethodTypeDesc.of(CD_SYSTEM_MODULES);\n@@ -519,0 +522,11 @@\n+        private static final ClassDesc CD_Map_Entry = ClassDesc.ofInternalName(\"java\/util\/Map$Entry\");\n+        private static final MethodTypeDesc MTD_boolean = MethodTypeDesc.of(CD_boolean);\n+        private static final MethodTypeDesc MTD_ModuleDescriptorArray = MethodTypeDesc.of(CD_MODULE_DESCRIPTOR.arrayType());\n+        private static final MethodTypeDesc MTD_ModuleTargetArray = MethodTypeDesc.of(CD_MODULE_TARGET.arrayType());\n+        private static final MethodTypeDesc MTD_void_String = MethodTypeDesc.of(CD_void, CD_String);\n+        private static final MethodTypeDesc MTD_void_int = MethodTypeDesc.of(CD_void, CD_int);\n+        private static final MethodTypeDesc MTD_ModuleHashesArray = MethodTypeDesc.of(CD_MODULE_HASHES.arrayType());\n+        private static final MethodTypeDesc MTD_ModuleResolutionArray = MethodTypeDesc.of(CD_MODULE_RESOLUTION.arrayType());\n+        private static final MethodTypeDesc MTD_Map = MethodTypeDesc.of(CD_Map);\n+        private static final MethodTypeDesc MTD_MapEntry_Object_Object = MethodTypeDesc.of(CD_Map_Entry, CD_Object, CD_Object);\n+        private static final MethodTypeDesc MTD_Map_MapEntryArray = MethodTypeDesc.of(CD_Map, CD_Map_Entry.arrayType());\n@@ -619,2 +633,2 @@\n-                    \"<init>\",\n-                    MethodTypeDesc.of(CD_void),\n+                    INIT_NAME,\n+                    MTD_void,\n@@ -624,2 +638,2 @@\n-                                             \"<init>\",\n-                                             MethodTypeDesc.of(CD_void))\n+                                             INIT_NAME,\n+                                             MTD_void)\n@@ -641,1 +655,1 @@\n-                    MethodTypeDesc.of(CD_boolean),\n+                    MTD_boolean,\n@@ -659,1 +673,1 @@\n-                    MethodTypeDesc.of(CD_boolean),\n+                    MTD_boolean,\n@@ -671,1 +685,1 @@\n-                    MethodTypeDesc.of(CD_MODULE_DESCRIPTOR.arrayType()),\n+                    MTD_ModuleDescriptorArray,\n@@ -696,1 +710,1 @@\n-                    MethodTypeDesc.of(CD_MODULE_TARGET.arrayType()),\n+                    MTD_ModuleTargetArray,\n@@ -729,2 +743,2 @@\n-                                                  \"<init>\",\n-                                                  MethodTypeDesc.of(CD_void, CD_String));\n+                                                  INIT_NAME,\n+                                                  MTD_void_String);\n@@ -747,1 +761,1 @@\n-                    MethodTypeDesc.of(CD_MODULE_HASHES.arrayType()),\n+                    MTD_ModuleHashesArray,\n@@ -774,1 +788,1 @@\n-                    MethodTypeDesc.of(CD_MODULE_RESOLUTION.arrayType()),\n+                    MTD_ModuleResolutionArray,\n@@ -790,2 +804,2 @@\n-                                                  \"<init>\",\n-                                                  MethodTypeDesc.of(CD_void, CD_int))\n+                                                  INIT_NAME,\n+                                                  MTD_void_int)\n@@ -825,1 +839,1 @@\n-                    MethodTypeDesc.of(CD_Map),\n+                    MTD_Map,\n@@ -855,1 +869,1 @@\n-                           .anewarray(ClassDesc.ofInternalName(\"java\/util\/Map$Entry\"));\n+                           .anewarray(CD_Map_Entry);\n@@ -874,2 +888,0 @@\n-                            MethodTypeDesc desc = MethodTypeDesc.ofDescriptor(\n-                                    \"(Ljava\/lang\/Object;Ljava\/lang\/Object;)Ljava\/util\/Map$Entry;\");\n@@ -878,1 +890,1 @@\n-                                             desc,\n+                                             MTD_MapEntry_Object_Object,\n@@ -887,2 +899,1 @@\n-                                         MethodTypeDesc.ofDescriptor(\n-                                                 \"([Ljava\/util\/Map$Entry;)Ljava\/util\/Map;\"),\n+                                         MTD_Map_MapEntryArray,\n@@ -898,31 +909,3 @@\n-            int size = set.size();\n-\n-            \/\/ use Set.of(Object[]) when there are more than 2 elements\n-            \/\/ use Set.of(Object) or Set.of(Object, Object) when fewer\n-            if (size > 2) {\n-                cob.constantInstruction(size)\n-                   .anewarray(CD_String);\n-                int i = 0;\n-                for (String element : sorted(set)) {\n-                    cob.dup()\n-                       .constantInstruction(i)\n-                       .constantInstruction(element)\n-                       .aastore();\n-                    i++;\n-                }\n-                cob.invokestatic(CD_Set,\n-                                 \"of\",\n-                                 MethodTypeDesc.ofDescriptor(\n-                                         \"([Ljava\/lang\/Object;)Ljava\/util\/Set;\"),\n-                                 true);\n-            } else {\n-                for (String element : sorted(set)) {\n-                    cob.constantInstruction(element);\n-                }\n-                var mtdArgs = new ClassDesc[size];\n-                Arrays.fill(mtdArgs, CD_Object);\n-                cob.invokestatic(CD_Set,\n-                                 \"of\",\n-                                 MethodTypeDesc.of(CD_Set, mtdArgs),\n-                                 true);\n-            }\n+            new SetBuilder<>(set, 0, () -> {\n+                throw new IllegalStateException();\n+            }).generateSetOf(cob);\n@@ -971,0 +954,3 @@\n+            static final MethodTypeDesc MTD_void_String = MethodTypeDesc.of(CD_void, CD_String);\n+            static final MethodTypeDesc MTD_ModuleDescriptor_int = MethodTypeDesc.of(CD_MODULE_DESCRIPTOR, CD_int);\n+            static final MethodTypeDesc MTD_List_ObjectArray = MethodTypeDesc.of(CD_List, CD_Object.arrayType());\n@@ -1023,2 +1009,2 @@\n-                                  \"<init>\",\n-                                  MethodTypeDesc.of(CD_void, CD_String))\n+                                  INIT_NAME,\n+                                  MTD_void_String)\n@@ -1060,1 +1046,1 @@\n-                                  MethodTypeDesc.of(CD_MODULE_DESCRIPTOR, CD_int))\n+                                  MTD_ModuleDescriptor_int)\n@@ -1286,2 +1272,1 @@\n-                                 MethodTypeDesc.ofDescriptor(\n-                                        \"([Ljava\/lang\/Object;)Ljava\/util\/List;\"),\n+                                 MTD_List_ObjectArray,\n@@ -1346,0 +1331,2 @@\n+            static final MethodTypeDesc MTD_void_String_int = MethodTypeDesc.of(CD_void, CD_String, CD_int);\n+            static final MethodTypeDesc MTD_ModuleHashes = MethodTypeDesc.of(CD_MODULE_HASHES);\n@@ -1388,2 +1375,2 @@\n-                                  \"<init>\",\n-                                  MethodTypeDesc.of(CD_void, CD_String, CD_int))\n+                                  INIT_NAME,\n+                                  MTD_void_String_int)\n@@ -1405,1 +1392,1 @@\n-                                  MethodTypeDesc.of(CD_MODULE_HASHES))\n+                                  MTD_ModuleHashes)\n@@ -1554,0 +1541,13 @@\n+            private static final MethodTypeDesc MTD_Set_ObjectArray = MethodTypeDesc.of(\n+                    CD_Set, CD_Object.arrayType());\n+            private static @Stable final MethodTypeDesc[] SET_OF_MTDS = new MethodTypeDesc[11];\n+\n+            private static MethodTypeDesc setOfType(int count) {\n+                var ret = SET_OF_MTDS[count];\n+                if (ret != null)\n+                    return ret;\n+                var mtdArgs = new ClassDesc[count];\n+                Arrays.fill(mtdArgs, CD_Object);\n+                return SET_OF_MTDS[count] = MethodTypeDesc.of(CD_Set, mtdArgs);\n+            }\n+\n@@ -1604,1 +1604,2 @@\n-                    generateSetOf(cob, index);\n+                    generateSetOf(cob);\n+                    cob.astore(index);\n@@ -1609,2 +1610,3 @@\n-            private void generateSetOf(CodeBuilder cob, int index) {\n-                if (elements.size() <= 10) {\n+            void generateSetOf(CodeBuilder cob) {\n+                int count = elements.size();\n+                if (count <= 10) {\n@@ -1615,2 +1617,1 @@\n-                    var mtdArgs = new ClassDesc[elements.size()];\n-                    Arrays.fill(mtdArgs, CD_Object);\n+\n@@ -1619,1 +1620,1 @@\n-                                     MethodTypeDesc.of(CD_Set, mtdArgs),\n+                                     setOfType(count),\n@@ -1623,1 +1624,1 @@\n-                    cob.constantInstruction(elements.size())\n+                    cob.constantInstruction(count)\n@@ -1635,2 +1636,1 @@\n-                                     MethodTypeDesc.ofDescriptor(\n-                                            \"([Ljava\/lang\/Object;)Ljava\/util\/Set;\"),\n+                                     MTD_Set_ObjectArray,\n@@ -1639,1 +1639,0 @@\n-                cob.astore(index);\n@@ -1686,2 +1685,2 @@\n-                                  \"<init>\",\n-                                  MethodTypeDesc.of(CD_void),\n+                                  INIT_NAME,\n+                                  MTD_void,\n@@ -1691,2 +1690,2 @@\n-                                                           \"<init>\",\n-                                                           MethodTypeDesc.of(CD_void))\n+                                                           INIT_NAME,\n+                                                           MTD_void)\n@@ -1698,1 +1697,1 @@\n-                                  MethodTypeDesc.of(CD_SYSTEM_MODULES),\n+                                  MTD_SystemModules,\n@@ -1703,2 +1702,2 @@\n-                                                           \"<init>\",\n-                                                           MethodTypeDesc.of(CD_void))\n+                                                           INIT_NAME,\n+                                                           MTD_void)\n@@ -1710,1 +1709,1 @@\n-                                   MethodTypeDesc.of(CD_SYSTEM_MODULES),\n+                                   MTD_SystemModules,\n@@ -1715,2 +1714,2 @@\n-                                                            \"<init>\",\n-                                                            MethodTypeDesc.of(CD_void))\n+                                                            INIT_NAME,\n+                                                            MTD_void)\n@@ -1722,1 +1721,1 @@\n-                                  MethodTypeDesc.of(CD_String.arrayType()),\n+                                  MTD_StringArray,\n@@ -1743,1 +1742,1 @@\n-                                  MethodTypeDesc.of(CD_String.arrayType()),\n+                                  MTD_StringArray,\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/SystemModulesPlugin.java","additions":81,"deletions":82,"binary":false,"changes":163,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.lang.constant.MethodTypeDesc;\n@@ -80,1 +79,0 @@\n-    private static final MethodTypeDesc MTD_void = MethodTypeDesc.of(ConstantDescs.CD_void);\n@@ -86,1 +84,1 @@\n-                                cob.invokestatic(CD_Cancel, \"stopCheck\", MTD_void);\n+                                cob.invokestatic(CD_Cancel, \"stopCheck\", ConstantDescs.MTD_void);\n@@ -95,1 +93,1 @@\n-                .withMethodBody(\"stopCheck\", MTD_void, Classfile.ACC_PUBLIC | Classfile.ACC_STATIC, cob ->\n+                .withMethodBody(\"stopCheck\", ConstantDescs.MTD_void, Classfile.ACC_PUBLIC | Classfile.ACC_STATIC, cob ->\n@@ -99,1 +97,1 @@\n-                                               .invokespecial(CD_ThreadDeath, \"<init>\", MTD_void)\n+                                               .invokespecial(CD_ThreadDeath, ConstantDescs.INIT_NAME, ConstantDescs.MTD_void)\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/execution\/LocalExecutionControl.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -30,0 +30,3 @@\n+import static java.lang.constant.ConstantDescs.CD_String;\n+import static java.lang.constant.ConstantDescs.CD_void;\n+\n@@ -34,0 +37,1 @@\n+    public static final ClassDesc CD_MyClass = ClassDesc.of(\"MyClass\");\n@@ -38,2 +42,2 @@\n-    public static final MethodTypeDesc MTD_INT_VOID = MethodTypeDesc.ofDescriptor(\"(I)V\");\n-    public static final MethodTypeDesc MTD_VOID = MethodTypeDesc.ofDescriptor(\"()V\");\n+    public static final MethodTypeDesc MTD_void_int = MethodTypeDesc.ofDescriptor(\"(I)V\");\n+    public static final MethodTypeDesc MTD_void_StringArray = MethodTypeDesc.of(CD_void, CD_String.arrayType());\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/TestConstants.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import jdk.internal.classfile.AccessFlags;\n@@ -30,1 +29,0 @@\n-import jdk.internal.classfile.TypeKind;\n@@ -36,1 +34,1 @@\n-import java.lang.constant.ClassDesc;\n+\n@@ -38,1 +36,1 @@\n-import java.lang.constant.MethodTypeDesc;\n+\n@@ -42,0 +40,8 @@\n+import static jdk.internal.classfile.Classfile.*;\n+import static jdk.internal.classfile.Opcode.BIPUSH;\n+import static jdk.internal.classfile.Opcode.GETSTATIC;\n+import static jdk.internal.classfile.Opcode.GOTO;\n+import static jdk.internal.classfile.Opcode.ICONST_1;\n+import static jdk.internal.classfile.Opcode.IF_ICMPGE;\n+import static jdk.internal.classfile.Opcode.IMUL;\n+import static jdk.internal.classfile.Opcode.INVOKEVIRTUAL;\n@@ -44,3 +50,1 @@\n-import static org.openjdk.bench.jdk.classfile.TestConstants.MTD_INT_VOID;\n-import static org.openjdk.bench.jdk.classfile.TestConstants.MTD_VOID;\n-import static jdk.internal.classfile.Opcode.*;\n+import static org.openjdk.bench.jdk.classfile.TestConstants.MTD_void_int;\n@@ -48,2 +52,0 @@\n-import static jdk.internal.classfile.TypeKind.IntType;\n-import static jdk.internal.org.objectweb.asm.Opcodes.V12;\n@@ -88,1 +90,1 @@\n-        cw.visit(V12, Opcodes.ACC_PUBLIC, \"MyClass\", null, \"java\/lang\/Object\", null);\n+        cw.visit(Opcodes.V12, Opcodes.ACC_PUBLIC, \"MyClass\", null, \"java\/lang\/Object\", null);\n@@ -152,1 +154,1 @@\n-        byte[] bytes = Classfile.build(ClassDesc.of(\"MyClass\"), cb -> {\n+        byte[] bytes = Classfile.build(TestConstants.CD_MyClass, cb -> {\n@@ -154,1 +156,1 @@\n-            cb.withVersion(52, 0);\n+            cb.withVersion(JAVA_12_VERSION, 0);\n@@ -156,5 +158,4 @@\n-              .withMethod(\"<init>\", MethodTypeDesc.of(CD_void), 0, mb -> mb\n-                      .withCode(codeb -> codeb.loadInstruction(TypeKind.ReferenceType, 0)\n-                                              .invokeInstruction(INVOKESPECIAL, CD_Object, \"<init>\", MTD_VOID, false)\n-                                              .returnInstruction(VoidType)\n-                      )\n+              .withMethodBody(INIT_NAME, MTD_void, 0, codeb -> codeb\n+                      .aload(0)\n+                      .invokespecial(CD_Object, INIT_NAME, MTD_void)\n+                      .return_()\n@@ -163,5 +164,7 @@\n-                cb.withMethod(\"main\" + ((xi == 0) ? \"\" : \"\" + xi), MethodTypeDesc.of(CD_void, CD_String.arrayType()),\n-                              AccessFlags.ofMethod(AccessFlag.STATIC, AccessFlag.PUBLIC).flagsMask(),\n-                              mb -> mb.withCode(c0 -> {\n-                                  jdk.internal.classfile.Label loopTop = c0.newLabel();\n-                                  jdk.internal.classfile.Label loopEnd = c0.newLabel();\n+                cb.withMethodBody(\"main\" + ((xi == 0) ? \"\" : String.valueOf(xi)), TestConstants.MTD_void_StringArray,\n+                              ACC_PUBLIC | ACC_STATIC, c0 -> {\n+                                  var loopTop = c0.newLabel();\n+                                  var loopEnd = c0.newLabel();\n+                                  var startLabel = c0.startLabel();\n+                                  var endLabel = c0.endLabel();\n+                                  var iStart = c0.newLabel();\n@@ -172,0 +175,1 @@\n+                                    .labelBinding(iStart)\n@@ -187,51 +191,5 @@\n-                                    .invokeInstruction(INVOKEVIRTUAL, CD_PrintStream, \"println\", MTD_INT_VOID, false)  \/\/ 15\n-                                    .returnInstruction(VoidType);\n-                        }));\n-            }\n-        });\n-        if (writeClassBc) writeClass(bytes, checkFileBc);\n-        return bytes;\n-    }\n-\n-    @Benchmark\n-    @BenchmarkMode(Mode.Throughput)\n-    public byte[] jdkTreePrimitive() {\n-\n-        byte[] bytes = Classfile.build(ClassDesc.of(\"MyClass\"), cb -> {\n-            cb.withFlags(AccessFlag.PUBLIC);\n-            cb.withVersion(52, 0);\n-            cb.with(SourceFileAttribute.of(cb.constantPool().utf8Entry((\"MyClass.java\"))))\n-              .withMethod(\"<init>\", MethodTypeDesc.of(CD_void), 0,\n-                          mb -> mb.withCode(codeb -> codeb.loadInstruction(ReferenceType, 0)\n-                                                          .invokeInstruction(INVOKESPECIAL, CD_Object, \"<init>\", MTD_VOID, false)\n-                                                          .returnInstruction(VoidType)\n-                          )\n-              );\n-            for (int xi = 0; xi < 40; ++xi) {\n-                cb.withMethod(\"main\" + ((xi == 0) ? \"\" : \"\" + xi), MethodTypeDesc.of(CD_void, CD_String.arrayType()),\n-                              AccessFlags.ofMethod(AccessFlag.STATIC, AccessFlag.PUBLIC).flagsMask(),\n-                              mb -> mb.withCode(c0 -> {\n-                                  jdk.internal.classfile.Label loopTop = c0.newLabel();\n-                                  jdk.internal.classfile.Label loopEnd = c0.newLabel();\n-                                  int vFac = 1;\n-                                  int vI = 2;\n-                                  c0.constantInstruction(ICONST_1, 1)        \/\/ 0\n-                                    .storeInstruction(IntType, 1)          \/\/ 1\n-                                    .constantInstruction(ICONST_1, 1)        \/\/ 2\n-                                    .storeInstruction(IntType, 2)          \/\/ 3\n-                                    .labelBinding(loopTop)\n-                                    .loadInstruction(IntType, 2)           \/\/ 4\n-                                    .constantInstruction(BIPUSH, 10)         \/\/ 5\n-                                    .branchInstruction(IF_ICMPGE, loopEnd) \/\/ 6\n-                                    .loadInstruction(IntType, 1)           \/\/ 7\n-                                    .loadInstruction(IntType, 2)           \/\/ 8\n-                                    .operatorInstruction(IMUL)             \/\/ 9\n-                                    .storeInstruction(IntType, 1)          \/\/ 10\n-                                    .incrementInstruction(2, 1)    \/\/ 11\n-                                    .branchInstruction(GOTO, loopTop)     \/\/ 12\n-                                    .labelBinding(loopEnd)\n-                                    .fieldInstruction(GETSTATIC, CD_System, \"out\", CD_PrintStream)   \/\/ 13\n-                                    .loadInstruction(IntType, 1)\n-                                    .invokeInstruction(INVOKEVIRTUAL, CD_PrintStream, \"println\", MTD_INT_VOID, false)  \/\/ 15\n-                                    .returnInstruction(VoidType);\n-                        }));\n+                                    .invokeInstruction(INVOKEVIRTUAL, CD_PrintStream, \"println\", MTD_void_int, false)  \/\/ 15\n+                                    .returnInstruction(VoidType)\n+                                    .localVariable(vFac, \"fac\", CD_int, startLabel, endLabel)\n+                                    .localVariable(vI, \"i\", CD_int, iStart, loopEnd);\n+                        });\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/Write.java","additions":31,"deletions":73,"binary":false,"changes":104,"status":"modified"}]}