{"files":[{"patch":"@@ -1214,0 +1214,586 @@\n+\/\/ This closure is responsible for collecting required information about object reallocation\n+\/\/ and field reassignment while at a safe point, so that it can be carried out after leaving\n+\/\/ the safe point. A dedicated JNIHnandleBlock is passed in for oop handle allocation. Each\n+\/\/ closure instance holds required allocation information in the ObjectSnapshot* array for one\n+\/\/ vframe.\n+class CollectingReallocClosure : public ReallocClosure {\n+private:\n+  Thread*           _thread;\n+  JNIHandleBlock*   _handles;\n+  ObjectSnapshot**  _object_array;\n+  int               _object_array_length;\n+  int               _next_available_index;\n+public:\n+  CollectingReallocClosure(Thread* thread, int objects_size, JNIHandleBlock *handles) {\n+    assert(objects_size > 0, \"just checking\");\n+    _thread = thread;\n+    _object_array_length = objects_size;\n+    \/\/ array is passed and stored inside a VFrameSnapshot, and freed there as well\n+    _object_array = NEW_C_HEAP_ARRAY(ObjectSnapshot*, objects_size, mtInternal);\n+    for (int i = 0; i < objects_size; i++) {\n+      _object_array[i] = NULL;\n+    }\n+    _handles = handles;\n+    _next_available_index = 0;\n+  }\n+\n+  int get_object_array_length() { return _object_array_length; }\n+  ObjectSnapshot** get_object_array() { return _object_array; }\n+  void pre_alloc() {}\n+  void post_single_alloc(ObjectSnapshot* object_snapshot) {}\n+  void post_alloc(bool failures) {}\n+\n+  ObjectSnapshot* cached_box(AutoBoxObjectValue* bv, frame* fr, RegisterMap* reg_map, InstanceKlass* klass) {\n+    Klass* k = java_lang_Class::as_Klass(bv->klass()->as_ConstantOopReadValue()->value()());\n+    BasicType box_type = SystemDictionary::box_klass_type(k);\n+    if (box_type != T_OBJECT) {\n+      StackValue *value = StackValue::create_stack_value(fr, reg_map, bv->field_at(box_type == T_LONG ? 1 : 0));\n+      switch (box_type) {\n+        case T_INT:\n+        case T_CHAR:\n+        case T_SHORT:\n+        case T_BYTE:\n+        case T_BOOLEAN:\n+        case T_LONG: {\n+          ObjectSnapshot* object_snapshot = new ObjectSnapshot(_thread, bv->id(), BOXED);\n+          object_snapshot->set_box_type(box_type, value->get_int(), klass);\n+          return object_snapshot;\n+        }\n+        default:\n+          return NULL;\n+      }\n+    }\n+    return NULL;\n+  }\n+\n+  ObjectSnapshot* allocate_instance_klass(InstanceKlass* ik, int object_id) {\n+    return new ObjectSnapshot(_thread, object_id, INSTANCE_KLASS, ik);\n+  }\n+\n+  ObjectSnapshot* allocate_type_array_klass(TypeArrayKlass* ak, int len, int object_id) {\n+    return new ObjectSnapshot(_thread, object_id, TYPE_ARRAY_KLASS, ak, len);\n+  }\n+\n+  ObjectSnapshot *allocate_object_array_klass(ObjArrayKlass *ak, int len, int object_id) {\n+    return new ObjectSnapshot(_thread, object_id, OBJECT_ARRAY, ak, len);\n+  }\n+\n+  void update_value(ObjectValue *ov, ObjectSnapshot* obj) {\n+    \/\/ store the wrapped obj in the collected array\n+    _object_array[_next_available_index] = obj;\n+    _next_available_index++;\n+  }\n+\n+  ObjectSnapshot* get_value(ObjectValue* value) {\n+    for (int i = 0; i < get_object_array_length(); i++) {\n+     ObjectSnapshot* obj_snap = _object_array[i];\n+     if (obj_snap != NULL && obj_snap->get_id() == value->id()) {\n+       return obj_snap;\n+     }\n+    }\n+    return NULL;\n+  }\n+\n+  void obj_field_put(int offset, StackValue* sv, ObjectSnapshot* obj) {\n+    if (sv->obj_is_scalar_replaced()) {\n+      obj->put_obj_id(offset, sv->get_obj_id());\n+    } else {\n+      jvalue value;\n+      value.l = _handles->allocate_handle(sv->get_obj()());\n+      obj->put_value(offset, T_OBJECT, value);\n+    }\n+  }\n+\n+  void value_put(BasicType type, int offset, jvalue val, ObjectSnapshot* obj) {\n+    obj->put_value(offset, type, val);\n+  }\n+\n+  void byte_field_put(int offset, intptr_t val, ObjectSnapshot* obj) {\n+    obj->put_byte_field(offset, val);\n+  }\n+\n+  void obj_at_put(int index, oop value, ObjectValue* ov, ObjectSnapshot* obj) {\n+    if (ov == NULL) {\n+      jvalue val;\n+      val.l = value != NULL ? _handles->allocate_handle(value) : NULL;\n+      obj->at_put(index, T_OBJECT, val);\n+    } else {\n+      obj->obj_at_put(index, ov);\n+    }\n+  }\n+\n+  void value_at_put(BasicType type, int index, jvalue val, ObjectSnapshot* obj) {\n+    obj->at_put(index, type, val);\n+  }\n+\n+  void byte_at_put(int index, intptr_t val, int byte_count, ObjectSnapshot* obj) {\n+    obj->byte_at_put(index, val, byte_count);\n+  }\n+};\n+\n+void collect_realloc_objects_at_safepoint(Thread* thread, ScopeDesc* scope, vframe* vf, VFrameSnapshot* vf_snapshot, JVMCIEnv* JVMCIENV, JNIHandleBlock* handles) {\n+  GrowableArray<ScopeValue*>* objects = scope->objects();\n+  RegisterMap* map = const_cast<RegisterMap*>(vf->register_map());\n+\n+  \/\/ collecting closure will collect data required to realloc objects\n+  \/\/ and reassign fields after the safe point\n+  CollectingReallocClosure f(thread, objects->length(), handles);\n+  bool realloc_failures = Deoptimization::realloc_objects(vf->frame_pointer(), map, objects, &f);\n+  Deoptimization::reassign_fields(vf->frame_pointer(), map, objects, realloc_failures, false, &f);\n+  \/\/ store the collected realloc objects in static frame\n+  vf_snapshot->set_realloc_object_array_size(objects->length());\n+  vf_snapshot->set_realloc_objects_array(f.get_object_array());\n+}\n+\n+void collect_locals(StackValueCollection* locals, VFrameSnapshot* vf_snapshot, JNIHandleBlock* handles) {\n+  int size = locals->size();\n+  GrowableArray<StackValueSnapshot*>* stackValues = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<StackValueSnapshot*>(size, mtInternal);\n+  for (int i = 0; i < size; i++) {\n+    StackValue* sv = locals->at(i);\n+    if (sv->type() == T_OBJECT) {\n+      StackValueSnapshot* ssv = new StackValueSnapshot(sv, handles);\n+      stackValues->append(ssv);\n+    } else {\n+      stackValues->append(NULL);\n+    }\n+  }\n+  vf_snapshot->set_locals(stackValues);\n+}\n+\n+void handle_compiled_frame_at_safepoint(Thread* thread, compiledVFrame* cvf, VFrameSnapshot* vf_snapshot, JNIHandleBlock* handles, JVMCIEnv* JVMCIENV) {\n+  vf_snapshot->set_bci(cvf->bci());\n+  ScopeDesc* scope = cvf->scope();\n+  \/\/ native wrappers do not have a scope\n+  if (scope == NULL) {\n+    vf_snapshot->set_locals_is_virtual(NULL);\n+  } else {\n+    if (scope->objects() != NULL && scope->objects()->length() > 0) {\n+      collect_realloc_objects_at_safepoint(thread, scope, cvf, vf_snapshot, JVMCIENV, handles);\n+    }\n+    GrowableArray<ScopeValue*>* local_values = scope->locals();\n+    bool array[local_values->length()];\n+    for (int i = 0; i < local_values->length(); i++) {\n+      array[i] = local_values->at(i)->is_object();\n+    }\n+    vf_snapshot->set_locals_is_virtual(array);\n+\n+    collect_locals(cvf->locals(), vf_snapshot, handles);\n+  }\n+}\n+\n+void handle_interpreted_frame_at_safepoint(vframe* vf, VFrameSnapshot* vf_snapshot, JNIHandleBlock* handles, JVMCIEnv* JVMCIENV) {\n+  interpretedVFrame* ivf = interpretedVFrame::cast(vf);\n+  vf_snapshot->set_bci(ivf->bci());\n+  StackValueCollection* locals = ivf->locals();\n+  \/\/ construct a StackValue array that will be retained after the safe point\n+  GrowableArray<StackValueSnapshot*>* stackValues = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<StackValueSnapshot *>(0, mtInternal);\n+  int size = locals->size();\n+  for (int i = 0; i < size; i++) {\n+    StackValue *sv = locals->at(i);\n+    if (sv->type() == T_OBJECT) {\n+      StackValueSnapshot* sst = new StackValueSnapshot(sv, handles);\n+      stackValues->push(sst);\n+    } else {\n+      stackValues->push(NULL);\n+    }\n+  }\n+  vf_snapshot->set_locals(stackValues);\n+}\n+\n+void fill_in_frame_reference(instanceHandle thread_obj, Handle &frame_reference, StackValueCollection* locals, JVMCIEnv* JVMCIENV, jlong sp, int frame_number, jobject compilerToVM,\n+                        TRAPS) {\n+  HotSpotJVMCI::HotSpotStackFrameReference::set_compilerToVM(JVMCIENV, frame_reference(), JNIHandles::resolve(compilerToVM));\n+  HotSpotJVMCI::HotSpotStackFrameReference::set_stackPointer(JVMCIENV, frame_reference(), sp);\n+  HotSpotJVMCI::HotSpotStackFrameReference::set_frameNumber(JVMCIENV, frame_reference(), frame_number);\n+  HotSpotJVMCI::HotSpotStackFrameReference::set_thread(JVMCIENV, frame_reference(), thread_obj());\n+\n+  \/\/ initialize the locals array\n+  objArrayOop array_oop = oopFactory::new_objectArray(locals->size(), CHECK);\n+  objArrayHandle array(THREAD, array_oop);\n+  for (int i = 0; i < locals->size(); i++) {\n+    StackValue* var = locals->at(i);\n+    if (var != NULL && var->type() == T_OBJECT) {\n+      array->obj_at_put(i, var->get_obj()());\n+    }\n+  }\n+  HotSpotJVMCI::HotSpotStackFrameReference::set_locals(JVMCIENV, frame_reference(), array());\n+  HotSpotJVMCI::HotSpotStackFrameReference::set_objectsMaterialized(JVMCIENV, frame_reference(), JNI_FALSE);\n+}\n+\n+FramesDumpResult::FramesDumpResult(int num_threads) {\n+  _num_threads = num_threads;\n+  _num_snapshots = 0;\n+  _last = NULL;\n+  _snapshots = NULL;\n+}\n+\n+FramesDumpResult::~FramesDumpResult() {\n+  \/\/ free all the FramesSnapshot objects created during\n+  \/\/ a VM_FramesDump operation\n+  FramesSnapshot *ts = _snapshots;\n+  while (ts != NULL) {\n+    FramesSnapshot *p = ts;\n+    ts = ts->next();\n+    delete p;\n+  }\n+}\n+\n+void FramesDumpResult::add_frames_snapshot(FramesSnapshot* ts) {\n+  assert(_num_snapshots < _num_threads,\n+         \"_num_snapshots must be less than _num_threads\");\n+  _num_snapshots++;\n+  if (ts == NULL) {\n+    ts = new FramesSnapshot();\n+  }\n+  if (_snapshots == NULL) {\n+    _snapshots = ts;\n+  } else {\n+    _last->set_next(ts);\n+  }\n+  _last = ts;\n+}\n+\n+void FramesDumpResult::dump_frames_at_safepoint(JavaThread* java_thread, jobjectArray initial_methods, jobjectArray match_methods, jint initialSkip, int max_frames,\n+                                              JNIHandleBlock* handles, JVMCIEnv* JVMCIENV) {\n+  assert(java_thread != NULL && java_thread->threadObj() != NULL && java_thread->has_last_Java_frame(), \"invalid thread\");\n+\n+  jobjectArray methods = initial_methods;\n+\n+  FramesSnapshot* frames_snapshot = new FramesSnapshot();\n+  int frame_number = 0;\n+\n+  RegisterMap reg_map(java_thread);\n+  vframe* vf = java_thread->last_java_vframe(&reg_map);\n+\n+  while (vf != NULL && (max_frames == -1 || frames_snapshot->frames_length() < max_frames)) {\n+    VFrameSnapshot* vf_snapshot = new VFrameSnapshot();\n+    Method* current_method = NULL;\n+\n+    if (vf->is_compiled_frame()) {\n+      compiledVFrame* cvf = compiledVFrame::cast(vf);\n+      if (methods == NULL || matches(methods, cvf->method(), JVMCIENV)) {\n+        if (initialSkip > 0) {\n+          initialSkip--;\n+        } else {\n+          current_method = cvf->method();\n+          handle_compiled_frame_at_safepoint(java_thread, cvf, vf_snapshot, handles, JVMCIENV);\n+        }\n+      }\n+    } else if (vf->is_interpreted_frame()) {\n+      interpretedVFrame *ivf = interpretedVFrame::cast(vf);\n+      if (methods == NULL || matches(methods, ivf->method(), JVMCIENV)) {\n+        if (initialSkip > 0) {\n+          initialSkip--;\n+        } else {\n+          vf_snapshot->set_interpreted_frame();\n+          current_method = ivf->method();\n+          handle_interpreted_frame_at_safepoint(vf, vf_snapshot, handles, JVMCIENV);\n+        }\n+      }\n+    }\n+    if (current_method != NULL) {\n+      vf_snapshot->set_not_empty();\n+      vf_snapshot->set_method(current_method);\n+      vf_snapshot->set_sp(vf->frame_pointer()->sp());\n+      vf_snapshot->set_frame_number(frame_number);\n+      frames_snapshot->add_frame(vf_snapshot);\n+\n+      methods = match_methods;\n+      assert(initialSkip == 0, \"There should be no match before initialSkip == 0\");\n+    }\n+    frame_number++;\n+\n+    if (vf->is_top()) {\n+      \/\/ reset iteration state\n+      frame_number = 0;\n+    }\n+    vf = vf->sender();\n+  } \/\/ end vframe loop\n+  add_frames_snapshot(frames_snapshot);\n+}\n+\n+void allocate_object_snapshot(ObjectSnapshot* object_snapshot, TRAPS) {\n+  assert(object_snapshot != NULL, \"must be non null\");\n+\n+  oop value = object_snapshot->get_value()();\n+  AllocType type = object_snapshot->get_alloc_type();\n+  if (type == BOXED) {\n+    value = Deoptimization::get_cached_box(object_snapshot->get_box_type(), object_snapshot->get_box_value(), CHECK);\n+    if (value == NULL) {\n+      \/\/ not available from cached box\n+      InstanceKlass* ik = InstanceKlass::cast(object_snapshot->get_klass());\n+      value = ik->allocate_instance(CHECK);\n+    }\n+  } else if (type == INSTANCE_KLASS) {\n+    InstanceKlass* ik = InstanceKlass::cast(object_snapshot->get_klass());\n+    value = ik->allocate_instance(CHECK);\n+  } else if (type == TYPE_ARRAY_KLASS) {\n+    TypeArrayKlass* ak = TypeArrayKlass::cast(object_snapshot->get_klass());\n+    value = ak->allocate(object_snapshot->get_array_length(), CHECK);\n+  } else if (type == OBJECT_ARRAY) {\n+    ObjArrayKlass* ak = ObjArrayKlass::cast(object_snapshot->get_klass());\n+    value = ak->allocate(object_snapshot->get_array_length(), CHECK);\n+  }\n+  assert(value != NULL, \"failed allocation\");\n+  object_snapshot->set_value(value);\n+}\n+\n+void reassign_fields_for_object_snapshot(ObjectSnapshot* object_snapshot, ObjectSnapshot** obj_array, int obj_array_length) {\n+  assert(object_snapshot != NULL, \"must be non null\");\n+  assert(object_snapshot->get_value()() != NULL, \"not allocated!\");\n+\n+  GrowableArray<FieldValueSnapshot*>* reassign_array = object_snapshot->get_fields();\n+  int len = reassign_array->length();\n+  for (int i = 0; i < len; i++) {\n+    FieldValueSnapshot* fvs = reassign_array->at(i);\n+    BasicType type = fvs->type();\n+    oop value = object_snapshot->get_value()();\n+    switch (type) {\n+      case T_OBJECT: {\n+        if (fvs->offset() == -1) {\n+          objArrayOop array_oop = (objArrayOop) value;\n+          if (fvs->get_object_id() != -1) {\n+            for (int j = 0; j < obj_array_length; j++) {\n+              if (obj_array[j] != NULL && obj_array[j]->get_id() == fvs->get_object_id()) {\n+                array_oop->obj_at_put(fvs->get_index(), obj_array[j]->get_value()());\n+              }\n+            }\n+          } else {\n+            array_oop->obj_at_put(fvs->get_index(), JNIHandles::resolve(fvs->get_value().l));\n+          }\n+        } else {\n+          if (fvs->get_object_id() != -1) {\n+            for (int j = 0; j < obj_array_length; j++) {\n+              if (obj_array[j] != NULL && obj_array[j]->get_id() == fvs->get_object_id()) {\n+                value->obj_field_put(fvs->offset(), obj_array[j]->get_value()());\n+              }\n+            }\n+          } else {\n+            value->obj_field_put(fvs->offset(), JNIHandles::resolve(fvs->get_value().l));\n+          }\n+        }\n+        break;\n+      }\n+      case T_INT: {\n+        if (fvs->offset() == -1) {\n+          typeArrayOop array_oop = (typeArrayOop) value;\n+          array_oop->int_at_put(fvs->get_index(), fvs->get_value().i);\n+        } else {\n+          value->int_field_put(fvs->offset(), fvs->get_value().i);\n+        }\n+        break;\n+      }\n+      case T_LONG: {\n+        if (fvs->offset() == -1) {\n+          typeArrayOop array_oop = (typeArrayOop) value;\n+          array_oop->long_at_put(fvs->get_index(), fvs->get_value().j);\n+        } else {\n+          value->long_field_put(fvs->offset(), fvs->get_value().j);\n+        }\n+        break;\n+      }\n+      case T_CHAR: {\n+        if (fvs->offset() == -1) {\n+          typeArrayOop array_oop = (typeArrayOop) value;\n+          array_oop->char_at_put(fvs->get_index(), fvs->get_value().c);\n+        } else {\n+          value->char_field_put(fvs->offset(), fvs->get_value().c);\n+        }\n+        break;\n+      }\n+      case T_BOOLEAN: {\n+        if (fvs->offset() == -1) {\n+          typeArrayOop array_oop = (typeArrayOop) value;\n+          array_oop->bool_at_put(fvs->get_index(), fvs->get_value().z);\n+        } else {\n+          value->bool_field_put(fvs->offset(), fvs->get_value().z);\n+        }\n+        break;\n+      }\n+      case T_SHORT: {\n+        if (fvs->offset() == -1) {\n+          typeArrayOop array_oop = (typeArrayOop) value;\n+          array_oop->short_at_put(fvs->get_index(), fvs->get_value().s);\n+        } else {\n+          value->short_field_put(fvs->offset(), fvs->get_value().s);\n+        }\n+        break;\n+      }\n+      case T_BYTE: {\n+        if (fvs->offset() == -1) {\n+          typeArrayOop type_array_obj = (typeArrayOop) object_snapshot->get_value()();\n+          Deoptimization::byte_array_put(type_array_obj, fvs->get_byte(), fvs->get_index(), fvs->get_byte_count());\n+        } else {\n+          value->byte_field_put(fvs->offset(), fvs->get_byte());\n+        }\n+        break;\n+      }\n+      default:\n+        ShouldNotReachHere();\n+    }\n+  }\n+}\n+\n+C2V_VMENTRY_NULL(jobjectArray, getStackFrames, (JNIEnv* env, jobject compilerToVM, jobjectArray initial_methods, jobjectArray match_methods, jint initialSkip, jint max_frames, jobjectArray threads))\n+\n+  requireInHotSpot(\"getStackFrames\", JVMCI_CHECK_NULL);\n+  \/\/ Check if threads is null\n+  if (threads == NULL) {\n+    THROW_(vmSymbols::java_lang_NullPointerException(), 0);\n+  }\n+\n+  tty->print_cr(\"getStackFrames...\");\n+\n+  objArrayHandle ah(THREAD, objArrayOop(JNIHandles::resolve_non_null(threads)));\n+  int num_threads = ah->length();\n+  \/\/ check if threads is non-empty array\n+  if (num_threads == 0) {\n+    THROW_(vmSymbols::java_lang_IllegalArgumentException(), 0);\n+  }\n+\n+  HotSpotJVMCI::HotSpotStackFrameReference::klass()->initialize(CHECK_NULL);\n+  Klass* arrayKlass = HotSpotJVMCI::HotSpotStackFrameReference::klass()->array_klass(CHECK_NULL);\n+  arrayKlass->initialize(CHECK_NULL);\n+\n+  \/\/ DO NOT use the naked oop `result` directly below these two lines.\n+  \/\/ always use the handle to avoid GC reclaiming the naked oop\n+  objArrayOop result = oopFactory::new_objArray(arrayKlass, num_threads, CHECK_NULL);\n+  objArrayHandle res(THREAD, result);\n+\n+  GrowableArray<instanceHandle>* thread_handle_array = new GrowableArray<instanceHandle>(num_threads);\n+  for (int i = 0; i < num_threads; i++) {\n+    oop thread_obj = ah->obj_at(i);\n+    instanceHandle h(THREAD, (instanceOop) thread_obj);\n+    thread_handle_array->append(h);\n+  }\n+\n+  {\n+    JNIHandleMark hm(thread);\n+    \/\/ allocate a dedicated JNI handle block chain for the operation\n+    JNIHandleBlock* operation_handles = thread->active_handles();\n+\n+    FramesDumpResult dump_result(num_threads);\n+    VM_FramesDump op(&dump_result,\n+                     thread_handle_array,\n+                     initial_methods,\n+                     match_methods,\n+                     initialSkip,\n+                     max_frames,\n+                     operation_handles,\n+                     JVMCIENV);\n+    VMThread::execute(&op);\n+\n+    assert(dump_result.num_snapshots() == num_threads, \"must be same size\");\n+\n+    tty->print_cr(\"after operation...\");\n+\n+    \/\/ using the dump result, do the actual allocations on the Java heap\n+    FramesSnapshot* snapshot = dump_result.snapshots();\n+    int thread_index = 0;\n+    while (snapshot != NULL) {\n+      GrowableArray<VFrameSnapshot*>* frames_snapshot = snapshot->get_frames();\n+\n+      int frames_length = frames_snapshot->length();\n+      \/\/ store the collected frames\n+      objArrayOop frames = oopFactory::new_objArray(HotSpotJVMCI::HotSpotStackFrameReference::klass(), frames_length, CHECK_NULL);\n+      objArrayHandle frames_handle(THREAD, frames);\n+\n+      GrowableArray<ObjectSnapshot*>* allocated_objects = new GrowableArray<ObjectSnapshot*>(0);\n+      int reassigned_count = 0;\n+      for (int j = 0; j < frames_length; j++) {\n+        oop frame_oop = HotSpotJVMCI::HotSpotStackFrameReference::klass()->allocate_instance(CHECK_NULL);\n+        Handle frame_reference(thread, frame_oop);\n+        VFrameSnapshot* vf_snapshot = frames_snapshot->at(j);\n+\n+        GrowableArray<StackValueSnapshot*>* locals_snapshot = vf_snapshot->get_locals();\n+        int locals_size = locals_snapshot->length();\n+\n+        if (vf_snapshot->is_compiled_frame()) {\n+          \/\/ allocate objects and reassign fields from the collected dump\n+          int size = vf_snapshot->get_realloc_objects_array_size();\n+          ObjectSnapshot** array = vf_snapshot->get_realloc_objects_array();\n+          \/\/ first allocate objects\n+          for (int i = 0; i < size; i++) {\n+            ObjectSnapshot* object_snapshot = array[i];\n+            if (object_snapshot != NULL) {\n+              bool allocated = false;\n+              for (int l = 0; l < allocated_objects->length(); l++) {\n+                if (allocated_objects->at(l)->get_id() == object_snapshot->get_id()) {\n+                  allocated = true;\n+                  break;\n+                }\n+              }\n+              if (!allocated) {\n+                allocate_object_snapshot(object_snapshot, CHECK_NULL);\n+                allocated_objects->append(object_snapshot);\n+              }\n+            }\n+          }\n+          \/\/ then re-assign fields\n+          for (int l = reassigned_count; l < allocated_objects->length(); l++) {\n+            ObjectSnapshot* object_snapshot = allocated_objects->at(l);\n+            reassign_fields_for_object_snapshot(object_snapshot, array, size);\n+          }\n+          reassigned_count = allocated_objects->length();\n+          \/\/ update the local values\n+          for (int i = 0; i < locals_snapshot->length(); i++) {\n+            StackValueSnapshot* sv_snapshot = locals_snapshot->at(i);\n+            if (sv_snapshot != NULL) {\n+              int obj_id = sv_snapshot->get_id();\n+              if (obj_id != -1) {\n+                for (int k = 0; k < allocated_objects->length(); k++) {\n+                  if (allocated_objects->at(k)->get_id() == obj_id) {\n+                    oop the_oop = allocated_objects->at(k)->get_value()();\n+                    sv_snapshot->set_obj(JNIHandles::make_local(the_oop));\n+                    break;\n+                  }\n+                }\n+              }\n+            }\n+          }\n+        }\n+        \/\/ is locals virtual array\n+        bool *is_virtual_array = vf_snapshot->get_locals_is_virtual();\n+        if (is_virtual_array == NULL) {\n+          HotSpotJVMCI::HotSpotStackFrameReference::set_localIsVirtual(JVMCIENV, frame_reference(), NULL);\n+        } else {\n+          typeArrayOop array_oop = oopFactory::new_boolArray(locals_size, CHECK_NULL);\n+          typeArrayHandle array(THREAD, array_oop);\n+          for (int i = 0; i < locals_size; i++) {\n+            array->bool_at_put(i, is_virtual_array[i]);\n+          }\n+          HotSpotJVMCI::HotSpotStackFrameReference::set_localIsVirtual(JVMCIENV, frame_reference(), array());\n+        }\n+        \/\/ locals\n+        StackValueCollection* locals = new StackValueCollection(locals_size);\n+        for (int i = 0; i < locals_size; i++) {\n+          StackValueSnapshot *svs = locals_snapshot->at(i);\n+          if (svs != NULL) {\n+            Handle obj_handle(thread, JNIHandles::resolve(svs->get_obj()));\n+            StackValue* sv = new StackValue(obj_handle);\n+            locals->add(sv);\n+          } else {\n+            locals->add(NULL);\n+          }\n+        }\n+        HotSpotJVMCI::HotSpotStackFrameReference::set_objectsMaterialized(JVMCIENV, frame_reference(), JNI_FALSE);\n+        HotSpotJVMCI::HotSpotStackFrameReference::set_bci(JVMCIENV, frame_reference(), vf_snapshot->get_bci());\n+        Method* method = vf_snapshot->get_method();\n+\n+        JVMCIObject jvmci_method = JVMCIENV->get_jvmci_method(methodHandle(thread, method), JVMCI_CHECK_NULL);\n+        HotSpotJVMCI::HotSpotStackFrameReference::set_method(JVMCIENV, frame_reference(), JNIHandles::resolve(jvmci_method.as_jobject()));\n+\n+        fill_in_frame_reference(thread_handle_array->at(thread_index), frame_reference, locals, JVMCIENV, (jlong) vf_snapshot->get_sp(), vf_snapshot->get_frame_number(),\n+          compilerToVM, CHECK_NULL);\n+        frames_handle->obj_at_put(j, frame_reference());\n+      }\n+      res->obj_at_put(thread_index, frames_handle());\n+      thread_index++;\n+      snapshot = snapshot->next();\n+    }\n+    tty->print_cr(\"before ending block...\");\n+  } \/\/ end JNIHandleMark block\n+  tty->print_cr(\"returning from getStackFrames...\");\n+  return (jobjectArray) JNIHandles::make_local(res());\n+}\n+\n@@ -1226,1 +1812,0 @@\n-  StackFrameStream fst(thread);\n@@ -1229,0 +1814,1 @@\n+  bool realloc_called = false;\n@@ -1230,1 +1816,0 @@\n-  vframe* vf = vframe::new_vframe(fst.current(), fst.register_map(), thread);\n@@ -1232,26 +1817,25 @@\n-  while (true) {\n-    \/\/ look for the given method\n-    bool realloc_called = false;\n-    while (true) {\n-      StackValueCollection* locals = NULL;\n-      if (vf->is_compiled_frame()) {\n-        \/\/ compiled method frame\n-        compiledVFrame* cvf = compiledVFrame::cast(vf);\n-        if (methods == NULL || matches(methods, cvf->method(), JVMCIENV)) {\n-          if (initialSkip > 0) {\n-            initialSkip--;\n-          } else {\n-            ScopeDesc* scope = cvf->scope();\n-            \/\/ native wrappers do not have a scope\n-            if (scope != NULL && scope->objects() != NULL) {\n-              GrowableArray<ScopeValue*>* objects;\n-              if (!realloc_called) {\n-                objects = scope->objects();\n-              } else {\n-                \/\/ some object might already have been re-allocated, only reallocate the non-allocated ones\n-                objects = new GrowableArray<ScopeValue*>(scope->objects()->length());\n-                for (int i = 0; i < scope->objects()->length(); i++) {\n-                  ObjectValue* sv = (ObjectValue*) scope->objects()->at(i);\n-                  if (sv->value().is_null()) {\n-                    objects->append(sv);\n-                  }\n+  RegisterMap reg_map(thread);\n+  vframe* vf = thread->last_java_vframe(&reg_map);\n+\n+  while (vf != NULL) {\n+    StackValueCollection* locals = NULL;\n+    if (vf->is_compiled_frame()) {\n+      compiledVFrame* cvf = compiledVFrame::cast(vf);\n+\n+      if (methods == NULL || matches(methods, cvf->method(), JVMCIENV)) {\n+        if (initialSkip > 0) {\n+          initialSkip--;\n+        } else {\n+          ScopeDesc* scope = cvf->scope();\n+          \/\/ native wrappers do not have a scope\n+          if (scope != NULL && scope->objects() != NULL) {\n+            GrowableArray<ScopeValue *> *objects;\n+            if (!realloc_called) {\n+              objects = scope->objects();\n+            } else {\n+              \/\/ some object might already have been re-allocated, only reallocate the non-allocated ones\n+              objects = new GrowableArray<ScopeValue*>(scope->objects()->length());\n+              for (int i = 0; i < scope->objects()->length(); i++) {\n+                ObjectValue* sv = (ObjectValue*) scope->objects()->at(i);\n+                if (sv->value().is_null()) {\n+                  objects->append(sv);\n@@ -1260,13 +1844,14 @@\n-              bool realloc_failures = Deoptimization::realloc_objects(thread, fst.current(), fst.register_map(), objects, CHECK_NULL);\n-              Deoptimization::reassign_fields(fst.current(), fst.register_map(), objects, realloc_failures, false);\n-              realloc_called = true;\n-\n-              GrowableArray<ScopeValue*>* local_values = scope->locals();\n-              assert(local_values != NULL, \"NULL locals\");\n-              typeArrayOop array_oop = oopFactory::new_boolArray(local_values->length(), CHECK_NULL);\n-              typeArrayHandle array(THREAD, array_oop);\n-              for (int i = 0; i < local_values->length(); i++) {\n-                ScopeValue* value = local_values->at(i);\n-                if (value->is_object()) {\n-                  array->bool_at_put(i, true);\n-                }\n+            }\n+            ImmediateReallocClosure f(thread);\n+            RegisterMap* map = const_cast<RegisterMap *>(vf->register_map());\n+            bool realloc_failures = Deoptimization::realloc_objects(vf->frame_pointer(), map, objects, &f);\n+            Deoptimization::reassign_fields(vf->frame_pointer(), map, objects, realloc_failures, false, &f);\n+            realloc_called = true;\n+\n+            GrowableArray<ScopeValue*>* local_values = scope->locals();\n+            typeArrayOop array_oop = oopFactory::new_boolArray(local_values->length(), CHECK_NULL);\n+            typeArrayHandle array(THREAD, array_oop);\n+            for (int i = 0; i < local_values->length(); i++) {\n+              ScopeValue *value = local_values->at(i);\n+              if (value->is_object()) {\n+                array->bool_at_put(i, true);\n@@ -1274,3 +1859,0 @@\n-              HotSpotJVMCI::HotSpotStackFrameReference::set_localIsVirtual(JVMCIENV, frame_reference(), array());\n-            } else {\n-              HotSpotJVMCI::HotSpotStackFrameReference::set_localIsVirtual(JVMCIENV, frame_reference(), NULL);\n@@ -1278,14 +1860,1 @@\n-\n-            locals = cvf->locals();\n-            HotSpotJVMCI::HotSpotStackFrameReference::set_bci(JVMCIENV, frame_reference(), cvf->bci());\n-            methodHandle mh(THREAD, cvf->method());\n-            JVMCIObject method = JVMCIENV->get_jvmci_method(mh, JVMCI_CHECK_NULL);\n-            HotSpotJVMCI::HotSpotStackFrameReference::set_method(JVMCIENV, frame_reference(), JNIHandles::resolve(method.as_jobject()));\n-          }\n-        }\n-      } else if (vf->is_interpreted_frame()) {\n-        \/\/ interpreted method frame\n-        interpretedVFrame* ivf = interpretedVFrame::cast(vf);\n-        if (methods == NULL || matches(methods, ivf->method(), JVMCIENV)) {\n-          if (initialSkip > 0) {\n-            initialSkip--;\n+            HotSpotJVMCI::HotSpotStackFrameReference::set_localIsVirtual(JVMCIENV, frame_reference(), array());\n@@ -1293,5 +1862,0 @@\n-            locals = ivf->locals();\n-            HotSpotJVMCI::HotSpotStackFrameReference::set_bci(JVMCIENV, frame_reference(), ivf->bci());\n-            methodHandle mh(THREAD, ivf->method());\n-            JVMCIObject method = JVMCIENV->get_jvmci_method(mh, JVMCI_CHECK_NULL);\n-            HotSpotJVMCI::HotSpotStackFrameReference::set_method(JVMCIENV, frame_reference(), JNIHandles::resolve(method.as_jobject()));\n@@ -1300,0 +1864,5 @@\n+\n+          locals = cvf->locals();\n+          HotSpotJVMCI::HotSpotStackFrameReference::set_bci(JVMCIENV, frame_reference(), cvf->bci());\n+          JVMCIObject method = JVMCIENV->get_jvmci_method(methodHandle(thread, cvf->method()), JVMCI_CHECK_NULL);\n+          HotSpotJVMCI::HotSpotStackFrameReference::set_method(JVMCIENV, frame_reference(), JNIHandles::resolve(method.as_jobject()));\n@@ -1302,16 +1871,12 @@\n-\n-      \/\/ locals != NULL means that we found a matching frame and result is already partially initialized\n-      if (locals != NULL) {\n-        methods = match_methods;\n-        HotSpotJVMCI::HotSpotStackFrameReference::set_compilerToVM(JVMCIENV, frame_reference(), JNIHandles::resolve(compilerToVM));\n-        HotSpotJVMCI::HotSpotStackFrameReference::set_stackPointer(JVMCIENV, frame_reference(), (jlong) fst.current()->sp());\n-        HotSpotJVMCI::HotSpotStackFrameReference::set_frameNumber(JVMCIENV, frame_reference(), frame_number);\n-\n-        \/\/ initialize the locals array\n-        objArrayOop array_oop = oopFactory::new_objectArray(locals->size(), CHECK_NULL);\n-        objArrayHandle array(THREAD, array_oop);\n-        for (int i = 0; i < locals->size(); i++) {\n-          StackValue* var = locals->at(i);\n-          if (var->type() == T_OBJECT) {\n-            array->obj_at_put(i, locals->at(i)->get_obj()());\n-          }\n+    } else if (vf->is_interpreted_frame()) {\n+      \/\/ interpreted method frame\n+      interpretedVFrame* ivf = interpretedVFrame::cast(vf);\n+      if (methods == NULL || matches(methods, ivf->method(), JVMCIENV)) {\n+        if (initialSkip > 0) {\n+          initialSkip--;\n+        } else {\n+          locals = ivf->locals();\n+          HotSpotJVMCI::HotSpotStackFrameReference::set_bci(JVMCIENV, frame_reference(), ivf->bci());\n+          JVMCIObject method = JVMCIENV->get_jvmci_method(methodHandle(thread, ivf->method()), JVMCI_CHECK_NULL);\n+          HotSpotJVMCI::HotSpotStackFrameReference::set_method(JVMCIENV, frame_reference(), JNIHandles::resolve(method.as_jobject()));\n+          HotSpotJVMCI::HotSpotStackFrameReference::set_localIsVirtual(JVMCIENV, frame_reference(), NULL);\n@@ -1319,2 +1884,2 @@\n-        HotSpotJVMCI::HotSpotStackFrameReference::set_locals(JVMCIENV, frame_reference(), array());\n-        HotSpotJVMCI::HotSpotStackFrameReference::set_objectsMaterialized(JVMCIENV, frame_reference(), JNI_FALSE);\n+      }\n+    }\n@@ -1322,6 +1887,15 @@\n-        JavaValue result(T_OBJECT);\n-        JavaCallArguments args(visitor);\n-        args.push_oop(frame_reference);\n-        call_interface(&result, HotSpotJVMCI::InspectedFrameVisitor::klass(), vmSymbols::visitFrame_name(), vmSymbols::visitFrame_signature(), &args, CHECK_NULL);\n-        if (result.get_jobject() != NULL) {\n-          return JNIHandles::make_local(thread, (oop) result.get_jobject());\n+    \/\/ locals != NULL means that we found a matching frame and result is already partially initialized\n+    if (locals != NULL) {\n+      methods = match_methods;\n+      HotSpotJVMCI::HotSpotStackFrameReference::set_compilerToVM(JVMCIENV, frame_reference(), JNIHandles::resolve(compilerToVM));\n+      HotSpotJVMCI::HotSpotStackFrameReference::set_stackPointer(JVMCIENV, frame_reference(), (jlong) vf->frame_pointer()->sp());\n+      HotSpotJVMCI::HotSpotStackFrameReference::set_frameNumber(JVMCIENV, frame_reference(), frame_number);\n+      HotSpotJVMCI::HotSpotStackFrameReference::set_thread(JVMCIENV, frame_reference(), thread->threadObj());\n+\n+      \/\/ initialize the locals array\n+      objArrayOop array_oop = oopFactory::new_objectArray(locals->size(), CHECK_NULL);\n+      objArrayHandle array(THREAD, array_oop);\n+      for (int i = 0; i < locals->size(); i++) {\n+        StackValue* var = locals->at(i);\n+        if (var->type() == T_OBJECT) {\n+          array->obj_at_put(i, var->get_obj()());\n@@ -1329,21 +1903,30 @@\n-        assert(initialSkip == 0, \"There should be no match before initialSkip == 0\");\n-        if (HotSpotJVMCI::HotSpotStackFrameReference::objectsMaterialized(JVMCIENV, frame_reference()) == JNI_TRUE) {\n-          \/\/ the frame has been deoptimized, we need to re-synchronize the frame and vframe\n-          intptr_t* stack_pointer = (intptr_t*) HotSpotJVMCI::HotSpotStackFrameReference::stackPointer(JVMCIENV, frame_reference());\n-          fst = StackFrameStream(thread);\n-          while (fst.current()->sp() != stack_pointer && !fst.is_done()) {\n-            fst.next();\n-          }\n-          if (fst.current()->sp() != stack_pointer) {\n-            THROW_MSG_NULL(vmSymbols::java_lang_IllegalStateException(), \"stack frame not found after deopt\")\n-          }\n-          vf = vframe::new_vframe(fst.current(), fst.register_map(), thread);\n-          if (!vf->is_compiled_frame()) {\n-            THROW_MSG_NULL(vmSymbols::java_lang_IllegalStateException(), \"compiled stack frame expected\")\n-          }\n-          for (int i = 0; i < frame_number; i++) {\n-            if (vf->is_top()) {\n-              THROW_MSG_NULL(vmSymbols::java_lang_IllegalStateException(), \"vframe not found after deopt\")\n-            }\n-            vf = vf->sender();\n-            assert(vf->is_compiled_frame(), \"Wrong frame type\");\n+      }\n+      HotSpotJVMCI::HotSpotStackFrameReference::set_locals(JVMCIENV, frame_reference(), array());\n+      HotSpotJVMCI::HotSpotStackFrameReference::set_objectsMaterialized(JVMCIENV, frame_reference(), JNI_FALSE);\n+\n+      JavaValue result(T_OBJECT);\n+      JavaCallArguments args(visitor);\n+      args.push_oop(frame_reference);\n+      call_interface(&result, HotSpotJVMCI::InspectedFrameVisitor::klass(), vmSymbols::visitFrame_name(), vmSymbols::visitFrame_signature(), &args, CHECK_NULL);\n+      if (result.get_jobject() != NULL) {\n+        return JNIHandles::make_local(thread, (oop) result.get_jobject());\n+      }\n+      assert(initialSkip == 0, \"There should be no match before initialSkip == 0\");\n+      if (HotSpotJVMCI::HotSpotStackFrameReference::objectsMaterialized(JVMCIENV, frame_reference()) == JNI_TRUE) {\n+        \/\/ the frame has been deoptimized, we need to re-synchronize the frame and vframe\n+        intptr_t* stack_pointer = (intptr_t*) HotSpotJVMCI::HotSpotStackFrameReference::stackPointer(JVMCIENV, frame_reference());\n+        RegisterMap reg_map_after_deopt(thread);\n+        vframe* vfAfterDeopt = thread->last_java_vframe(&reg_map_after_deopt);\n+        while (vfAfterDeopt != NULL && vfAfterDeopt->frame_pointer()->sp() != stack_pointer) {\n+          vfAfterDeopt = vfAfterDeopt->sender();\n+        }\n+        if (vfAfterDeopt == NULL) {\n+          THROW_MSG_NULL(vmSymbols::java_lang_IllegalStateException(), \"stack frame not found after deopt\")\n+        }\n+        if (!vfAfterDeopt->is_compiled_frame()) {\n+          THROW_MSG_NULL(vmSymbols::java_lang_IllegalStateException(), \"compiled stack frame expected\")\n+        }\n+        vf = vfAfterDeopt;\n+        for (int i = 0; i < frame_number; i++) {\n+          if (vf->is_top()) {\n+            THROW_MSG_NULL(vmSymbols::java_lang_IllegalStateException(), \"vframe not found after deopt\")\n@@ -1351,0 +1934,2 @@\n+          vf = vf->sender();\n+          assert(vf->is_compiled_frame(), \"Wrong frame type\");\n@@ -1352,6 +1937,0 @@\n-        frame_reference = HotSpotJVMCI::HotSpotStackFrameReference::klass()->allocate_instance_handle(CHECK_NULL);\n-        HotSpotJVMCI::HotSpotStackFrameReference::klass()->initialize(CHECK_NULL);\n-      }\n-\n-      if (vf->is_top()) {\n-        break;\n@@ -1359,6 +1938,1 @@\n-      frame_number++;\n-      vf = vf->sender();\n-    } \/\/ end of vframe loop\n-\n-    if (fst.is_done()) {\n-      break;\n+      frame_reference = HotSpotJVMCI::HotSpotStackFrameReference::klass()->allocate_instance_handle(CHECK_NULL);\n@@ -1366,5 +1940,8 @@\n-    fst.next();\n-    vf = vframe::new_vframe(fst.current(), fst.register_map(), thread);\n-    frame_number = 0;\n-  } \/\/ end of frame loop\n-\n+    frame_number++;\n+    if (vf->is_top()) {\n+      \/\/ reset iteration state\n+      frame_number = 0;\n+      realloc_called = false;\n+    }\n+    vf = vf->sender();\n+  } \/\/ end of vframe loop\n@@ -1464,0 +2041,8 @@\n+  oop the_thread = JNIHandles::resolve(JVMCIENV->get_HotSpotStackFrameReference_thread(hs_frame).as_jobject());\n+  JavaThread* java_thread = java_lang_Thread::thread(the_thread);\n+\n+  \/\/ sanity check that the thread is still alive after suspending\n+  if (java_thread == NULL || java_thread->threadObj() == NULL) {\n+    JVMCI_THROW_MSG(IllegalStateException, \"thread is not live\");\n+  }\n+\n@@ -1465,4 +2050,5 @@\n-  StackFrameStream fst(thread, false);\n-  intptr_t* stack_pointer = (intptr_t*) JVMCIENV->get_HotSpotStackFrameReference_stackPointer(hs_frame);\n-  while (fst.current()->sp() != stack_pointer && !fst.is_done()) {\n-    fst.next();\n+  RegisterMap reg_map(java_thread);\n+  vframe* vf = java_thread->last_java_vframe(&reg_map);\n+  intptr_t* stack_pointer = (intptr_t *) JVMCIENV->get_HotSpotStackFrameReference_stackPointer(hs_frame);\n+  while (vf != NULL && vf->frame_pointer()->sp() != stack_pointer) {\n+    vf = vf->sender();\n@@ -1470,1 +2056,1 @@\n-  if (fst.current()->sp() != stack_pointer) {\n+  if (vf == NULL) {\n@@ -1475,1 +2061,1 @@\n-    if (!fst.current()->is_compiled_frame()) {\n+    if (!vf->frame_pointer()->is_compiled_frame()) {\n@@ -1478,2 +2064,2 @@\n-    assert(fst.current()->cb()->is_nmethod(), \"nmethod expected\");\n-    ((nmethod*) fst.current()->cb())->make_not_entrant();\n+    assert(vf->frame_pointer()->cb()->is_nmethod(), \"nmethod expected\");\n+    ((nmethod*) vf->frame_pointer()->cb())->make_not_entrant();\n@@ -1481,1 +2067,1 @@\n-  Deoptimization::deoptimize(thread, *fst.current(), Deoptimization::Reason_none);\n+  Deoptimization::deoptimize(java_thread, *vf->frame_pointer(), Deoptimization::Reason_none);\n@@ -1483,3 +2069,4 @@\n-  StackFrameStream fstAfterDeopt(thread);\n-  while (fstAfterDeopt.current()->sp() != stack_pointer && !fstAfterDeopt.is_done()) {\n-    fstAfterDeopt.next();\n+  RegisterMap reg_map_after_deopt(java_thread);\n+  vframe* vfAfterDeopt = java_thread->last_java_vframe(&reg_map_after_deopt);\n+  while (vfAfterDeopt != NULL && vfAfterDeopt->frame_pointer()->sp() != stack_pointer) {\n+    vfAfterDeopt = vfAfterDeopt->sender();\n@@ -1487,1 +2074,1 @@\n-  if (fstAfterDeopt.current()->sp() != stack_pointer) {\n+  if (vfAfterDeopt == NULL) {\n@@ -1491,2 +2078,1 @@\n-  vframe* vf = vframe::new_vframe(fstAfterDeopt.current(), fstAfterDeopt.register_map(), thread);\n-  if (!vf->is_compiled_frame()) {\n+  if (!vfAfterDeopt->is_compiled_frame()) {\n@@ -1498,3 +2084,3 @@\n-    assert(vf->is_compiled_frame(), \"Wrong frame type\");\n-    virtualFrames->push(compiledVFrame::cast(vf));\n-    if (vf->is_top()) {\n+    assert(vfAfterDeopt->is_compiled_frame(), \"Wrong frame type\");\n+    virtualFrames->push(compiledVFrame::cast(vfAfterDeopt));\n+    if (vfAfterDeopt->is_top()) {\n@@ -1503,1 +2089,1 @@\n-    vf = vf->sender();\n+    vfAfterDeopt = vfAfterDeopt->sender();\n@@ -1511,0 +2097,8 @@\n+  \/\/ validate the method\n+  Method* actual_method = virtualFrames->at(last_frame_number)->method();\n+  Method* expected_method = JVMCIENV->asMethod(JVMCIENV->get_HotSpotStackFrameReference_method(hs_frame));\n+\n+  if (actual_method != expected_method) {\n+    JVMCI_THROW_MSG(IllegalStateException, \"unexpected method found in compiled frame\");\n+  }\n+\n@@ -1520,2 +2114,3 @@\n-  bool realloc_failures = Deoptimization::realloc_objects(thread, fstAfterDeopt.current(), fstAfterDeopt.register_map(), objects, CHECK);\n-  Deoptimization::reassign_fields(fstAfterDeopt.current(), fstAfterDeopt.register_map(), objects, realloc_failures, false);\n+  ImmediateReallocClosure f(java_thread);\n+  bool realloc_failures = Deoptimization::realloc_objects(vfAfterDeopt->frame_pointer(), const_cast<RegisterMap *>(vfAfterDeopt->register_map()), objects, &f);\n+  Deoptimization::reassign_fields(vfAfterDeopt->frame_pointer(), const_cast<RegisterMap *>(vfAfterDeopt->register_map()), objects, realloc_failures, false, &f);\n@@ -1533,1 +2128,1 @@\n-          val.l = cast_from_oop<jobject>(locals->at(i2)->get_obj()());\n+          val.l = (jobject) locals->at(i2)->get_obj()();\n@@ -1546,1 +2141,1 @@\n-          val.l = cast_from_oop<jobject>(expressions->at(i2)->get_obj()());\n+          val.l = (jobject) expressions->at(i2)->get_obj()();\n@@ -2684,0 +3279,1 @@\n+#define _THREAD                 \"Ljava\/lang\/Thread;\"\n@@ -2692,0 +3288,1 @@\n+#define INSPECTED_FRAME         \"Ljdk\/vm\/ci\/code\/stack\/InspectedFrame;\"\n@@ -2770,0 +3367,1 @@\n+  {CC \"getStackFrames\",                               CC \"([\" RESOLVED_METHOD \"[\" RESOLVED_METHOD \"II\" \"[\" _THREAD \")\" \"[[\" INSPECTED_FRAME,FN_PTR(getStackFrames)},\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":746,"deletions":148,"binary":false,"changes":894,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"runtime\/stackValueCollection.hpp\"\n@@ -31,0 +32,1 @@\n+#include \"runtime\/deoptimization.hpp\"\n@@ -33,0 +35,4 @@\n+class FramesSnapshot;\n+class VFrameSnapshot;\n+class StackValueSnapshot;\n+class ObjectSnapshot;\n@@ -186,0 +192,106 @@\n+\/\/ This class is used to collect stack values during a VM_FramesDump operation to snapshot\n+\/\/ stack frames. An instance of this class represents a snapshot of a stack value that may\n+\/\/ or may not be scalar replaced. The oop handle field is NULL for scalar-replaced objects,\n+\/\/ while the ID field always holds the ObjectValue ID.\n+class StackValueSnapshot : public CHeapObj<mtInternal> {\n+private:\n+  intptr_t  _id;            \/\/ the ObjectValue ID\n+  jobject    _oop_handle;   \/\/ handle to the oop with above ObjectValue ID\n+public:\n+  StackValueSnapshot(StackValue *sv, JNIHandleBlock* handles) {\n+    _id = sv->obj_is_scalar_replaced() ? sv->get_obj_id() : -1;\n+    _oop_handle = sv->get_obj().is_null() ? NULL : handles->allocate_handle(sv->get_obj()());\n+  }\n+\n+  void set_obj(jobject obj) { _oop_handle = obj; }\n+  jobject get_obj() { return _oop_handle; }\n+  intptr_t get_id() { return _id; }\n+};\n+\n+\/\/ This class is used to collect information about vframes during a VM_FramesDump operation\n+\/\/ to snapshot stack frames. All objects that are to be reallocated after the VM operation\n+\/\/ are stored in the realloc object array field. Locals of the corresponding vframe are\n+\/\/ stored by means of StackValueSnapshot objects.\n+class VFrameSnapshot : public CHeapObj<mtInternal> {\n+private:\n+  bool                _empty;\n+  bool                _interpreted_frame;\n+  Method*             _method;\n+  int                 _bci;\n+  intptr_t*           _sp;\n+  int                 _frame_number;\n+  int                 _locals_size;\n+  bool*               _locals_is_virtual;\n+  ObjectSnapshot**    _realloc_objects_array;\n+  int                 _realloc_objects_array_len;\n+  GrowableArray<StackValueSnapshot*>* _locals;\n+\n+public:\n+  VFrameSnapshot() {\n+    _empty = true;\n+    _interpreted_frame = false;\n+    _method = NULL;\n+    _bci = 0;\n+    _sp = NULL;\n+    _frame_number = 0;\n+    _locals_size = 0;\n+    _locals = NULL;\n+    _locals_is_virtual = NULL;\n+    _realloc_objects_array = NULL;\n+    _realloc_objects_array_len = 0;\n+  }\n+\n+  ~VFrameSnapshot() {\n+    for (int i = 0; i < _realloc_objects_array_len; i++) {\n+      delete _realloc_objects_array[i];\n+    }\n+    FREE_C_HEAP_ARRAY(ObjectSnapshot*, _realloc_objects_array);\n+    delete _locals;\n+  }\n+\n+  bool              is_empty() { return _empty; }\n+  void              set_not_empty() { _empty = false; }\n+  void              set_interpreted_frame() { _interpreted_frame = true; }\n+  bool              is_interpreted_frame() { return _interpreted_frame; }\n+  void              set_method(Method* method) { _method = method; }\n+  Method*           get_method() { return _method; }\n+  void              set_bci(int bci) { _bci = bci; }\n+  int               get_bci() { return _bci; }\n+  void              set_sp(intptr_t* sp) { _sp = sp; }\n+  intptr_t*         get_sp() { return _sp; }\n+  void              set_frame_number(int frame_number) { _frame_number = frame_number; }\n+  int               get_frame_number() { return _frame_number; }\n+  void              set_locals_is_virtual(bool array[]) { _locals_is_virtual = array; }\n+  bool*             get_locals_is_virtual() { return _locals_is_virtual; }\n+  void              set_realloc_object_array_size(int len) { _realloc_objects_array_len = len; }\n+  void              set_realloc_objects_array(ObjectSnapshot** array) { _realloc_objects_array = array; }\n+  ObjectSnapshot**  get_realloc_objects_array() { return _realloc_objects_array; }\n+  int               get_realloc_objects_array_size() { return _realloc_objects_array_len; }\n+  void              set_locals(GrowableArray<StackValueSnapshot*>* locals) { _locals = locals; }\n+  bool              is_compiled_frame() { return !_interpreted_frame; }\n+  GrowableArray<StackValueSnapshot*>* get_locals() { return _locals; }\n+};\n+\n+\/\/ This class represents the dynamic array of frames that are to be collected\n+\/\/ by a VM_FramesDump operation.\n+class FramesSnapshot : public CHeapObj<mtInternal> {\n+private:\n+  FramesSnapshot*                     _next;\n+  GrowableArray<VFrameSnapshot*>*     _frames_array;\n+public:\n+  FramesSnapshot() {\n+    _next = NULL;\n+    _frames_array = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<VFrameSnapshot*>(0, mtInternal);\n+  }\n+\n+  ~FramesSnapshot() {\n+    delete _frames_array;\n+  }\n+\n+  void              set_next(FramesSnapshot* n) { _next = n; }\n+  FramesSnapshot*   next() { return _next; }\n+  void              add_frame(VFrameSnapshot* frame) { _frames_array->append(frame); }\n+  int               frames_length() { return _frames_array->length(); }\n+  GrowableArray<VFrameSnapshot*>*   get_frames() { return _frames_array; }\n+};\n+\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.hpp","additions":112,"deletions":0,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -325,0 +325,1 @@\n+    object_field(HotSpotStackFrameReference, thread, \"Ljava\/lang\/Thread;\")                                    \\\n","filename":"src\/hotspot\/share\/jvmci\/jvmciJavaClasses.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -198,0 +198,1 @@\n+    ImmediateReallocClosure f(thread);\n@@ -199,1 +200,1 @@\n-      realloc_failures = Deoptimization::realloc_objects(thread, &deoptee, &map, objects, THREAD);\n+      realloc_failures = Deoptimization::realloc_objects(&deoptee, &map, objects, &f);\n@@ -202,1 +203,1 @@\n-    Deoptimization::reassign_fields(&deoptee, &map, objects, realloc_failures, skip_internal);\n+    Deoptimization::reassign_fields(&deoptee, &map, objects, realloc_failures, skip_internal, &f);\n@@ -961,9 +962,1 @@\n-     switch(box_type) {\n-       case T_INT:     return IntegerBoxCache::singleton(THREAD)->lookup_raw(value->get_int());\n-       case T_CHAR:    return CharacterBoxCache::singleton(THREAD)->lookup_raw(value->get_int());\n-       case T_SHORT:   return ShortBoxCache::singleton(THREAD)->lookup_raw(value->get_int());\n-       case T_BYTE:    return ByteBoxCache::singleton(THREAD)->lookup_raw(value->get_int());\n-       case T_BOOLEAN: return BooleanBoxCache::singleton(THREAD)->lookup_raw(value->get_int());\n-       case T_LONG:    return LongBoxCache::singleton(THREAD)->lookup_raw(value->get_int());\n-       default:;\n-     }\n+     return get_cached_box(box_type, value->get_int(), CHECK_NULL);\n@@ -973,0 +966,12 @@\n+\n+oop Deoptimization::get_cached_box(BasicType box_type, intptr_t value, TRAPS) {\n+  switch(box_type) {\n+    case T_INT:     return IntegerBoxCache::singleton(THREAD)->lookup_raw(value);\n+    case T_CHAR:    return CharacterBoxCache::singleton(THREAD)->lookup_raw(value);\n+    case T_SHORT:   return ShortBoxCache::singleton(THREAD)->lookup_raw(value);\n+    case T_BYTE:    return ByteBoxCache::singleton(THREAD)->lookup_raw(value);\n+    case T_BOOLEAN: return BooleanBoxCache::singleton(THREAD)->lookup_raw(value);\n+    case T_LONG:    return LongBoxCache::singleton(THREAD)->lookup_raw(value);\n+    default: return NULL;\n+  }\n+}\n@@ -975,0 +980,228 @@\n+ObjectSnapshot::ObjectSnapshot(Thread* thread, int id, Handle value, AllocType alloc_type) : _id(id), _alloc_type(alloc_type) {\n+  _thread = thread;\n+  _value = value;\n+  _fields = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<FieldValueSnapshot*>(0, mtInternal);\n+  _klass = NULL;\n+  _box_type = T_ILLEGAL;\n+  _box_value_or_array_length = 0;\n+  _materialized = false;\n+}\n+\n+ObjectSnapshot::ObjectSnapshot(Thread* thread, int id, AllocType alloc_type, Klass* klass, int array_length) : _id(id), _alloc_type(alloc_type) {\n+  _thread = thread;\n+  _value = Handle();\n+  _fields = new (ResourceObj::C_HEAP, mtInternal) GrowableArray<FieldValueSnapshot*>(0, mtInternal);\n+  _klass = klass;\n+  _box_type = T_ILLEGAL;\n+  _box_value_or_array_length = array_length;\n+  _materialized = false;\n+}\n+\n+ObjectSnapshot::~ObjectSnapshot() {\n+  delete _fields;\n+}\n+\n+Handle ObjectSnapshot::get_value() {\n+  return _value;\n+}\n+\n+int ObjectSnapshot::get_id() {\n+  return _id;\n+}\n+\n+void ObjectSnapshot::set_value(oop value) {\n+  _value = Handle(_thread, value);\n+}\n+\n+AllocType ObjectSnapshot::get_alloc_type() {\n+  return _alloc_type;\n+}\n+\n+Klass* ObjectSnapshot::get_klass() {\n+  return _klass;\n+}\n+int ObjectSnapshot::get_array_length() {\n+  return _box_value_or_array_length;\n+}\n+\n+void ObjectSnapshot::set_box_type(BasicType type, intptr_t i, Klass* klass) {\n+_box_type = type;\n+_box_value_or_array_length = i;\n+_klass = klass;\n+}\n+\n+BasicType ObjectSnapshot::get_box_type() {\n+  return _box_type;\n+}\n+\n+intptr_t ObjectSnapshot::get_box_value() {\n+  return _box_value_or_array_length;\n+}\n+\n+GrowableArray<FieldValueSnapshot*>* ObjectSnapshot::get_fields() {\n+  return _fields;\n+}\n+\n+void ObjectSnapshot::set_klass(Klass *klass, int len) {\n+_klass = klass;\n+_box_value_or_array_length = len;\n+}\n+\n+void ObjectSnapshot::put_obj_id(int offset, int id) {\n+  FieldValueSnapshot* fvs = new FieldValueSnapshot(T_OBJECT, offset);\n+  fvs->set_object_id(id);\n+  _fields->append(fvs);\n+}\n+\n+void ObjectSnapshot::put_byte_field(int offset, intptr_t val) {\n+  FieldValueSnapshot* fvs = new FieldValueSnapshot(T_BYTE, offset);\n+  fvs->set_byte(val);\n+  _fields->append(fvs);\n+}\n+\n+void ObjectSnapshot::put_value(int offset, BasicType type, jvalue value) {\n+  FieldValueSnapshot* fvs = new FieldValueSnapshot(type, offset);\n+  fvs->set_value(value);\n+  _fields->append(fvs);\n+}\n+\n+void ObjectSnapshot::at_put( int index, BasicType type, jvalue val) {\n+  FieldValueSnapshot* fvs = new FieldValueSnapshot(type, -1);\n+  fvs->set_index(index);\n+  fvs->set_value(val);\n+  _fields->append(fvs);\n+}\n+\n+void ObjectSnapshot::byte_at_put(int index, intptr_t val, int byte_count) {\n+  FieldValueSnapshot* fvs = new FieldValueSnapshot(T_BYTE, -1);\n+  fvs->set_index(index);\n+  fvs->set_byte(val);\n+  fvs->set_byte_count(byte_count);\n+  _fields->append(fvs);\n+}\n+\n+void ObjectSnapshot::obj_at_put(int index, ObjectValue* ov) {\n+  FieldValueSnapshot* fvs = new FieldValueSnapshot(T_OBJECT, -1);\n+  fvs->set_index(index);\n+  fvs->set_object_id(ov->id());\n+  _fields->append(fvs);\n+}\n+\n+void ImmediateReallocClosure::pre_alloc() {\n+  \/\/ store and clear any pending exception before realloc\n+  Handle pending_exception(_thread, _thread->pending_exception());\n+  _pending_exception = pending_exception;\n+  _exception_file = _thread->exception_file();\n+  _exception_line = _thread->exception_line();\n+  _thread->clear_pending_exception();\n+}\n+\n+void ImmediateReallocClosure::post_single_alloc(ObjectSnapshot* object_snapshot) {\n+  assert(object_snapshot != NULL || _thread->has_pending_exception(), \"allocation should succeed or we should get an exception\");\n+  _thread->clear_pending_exception();\n+}\n+\n+void ImmediateReallocClosure::post_alloc(bool failures) {\n+  \/\/ handle failures and restore any pending exception\n+  if (failures) {\n+    JavaThread* current = JavaThread::current();\n+    Exceptions::_throw_oop(current, current->exception_file(), current->exception_line(), Universe::out_of_memory_error_realloc_objects());\n+  } else if (_pending_exception.not_null()) {\n+    _thread->set_pending_exception(_pending_exception(), _exception_file, _exception_line);\n+  }\n+}\n+\n+ObjectSnapshot* ImmediateReallocClosure::cached_box(AutoBoxObjectValue *bv, frame *fr, RegisterMap *reg_map, InstanceKlass *klass) {\n+  oop cached_value = Deoptimization::get_cached_box(bv, fr, reg_map, _thread);\n+  if (cached_value != NULL) {\n+    return new ObjectSnapshot(_thread, bv->id(), Handle(_thread, cached_value));\n+  }\n+  return NULL;\n+}\n+\n+ObjectSnapshot* ImmediateReallocClosure::allocate_instance_klass(InstanceKlass *ik, int object_id) {\n+  return new ObjectSnapshot(_thread, object_id, Handle(_thread, ik->allocate_instance(_thread)));\n+}\n+\n+ObjectSnapshot* ImmediateReallocClosure::allocate_type_array_klass(TypeArrayKlass *ak, int len, int object_id) {\n+  return new ObjectSnapshot(_thread, object_id, Handle(_thread, ak->allocate(len, _thread)));\n+}\n+\n+ObjectSnapshot* ImmediateReallocClosure::allocate_object_array_klass(ObjArrayKlass* ak, int len, int object_id) {\n+  return new ObjectSnapshot(_thread, object_id, Handle(_thread, ak->allocate(len, _thread)));\n+}\n+\n+void ImmediateReallocClosure::update_value(ObjectValue* ov, ObjectSnapshot* object_snapshot) {\n+  if (object_snapshot != NULL) {\n+    ov->set_value(object_snapshot->get_value()());\n+  }\n+}\n+\n+ObjectSnapshot* ImmediateReallocClosure::get_value(ObjectValue* ov) {\n+  return new ObjectSnapshot(_thread, ov->id(), ov->value());\n+}\n+\n+void ImmediateReallocClosure::obj_field_put(int offset, StackValue *sv, ObjectSnapshot* object_snapshot) {\n+  oop obj = object_snapshot->get_value()();\n+  obj->obj_field_put(offset, sv->get_obj()());\n+}\n+\n+void ImmediateReallocClosure::value_put(BasicType type, int offset, jvalue val, ObjectSnapshot* object_snapshot) {\n+  oop obj = object_snapshot->get_value()();\n+  switch (type) {\n+    case T_INT:\n+      obj->int_field_put(offset, val.i);\n+      break;\n+    case T_SHORT:\n+      obj->short_field_put(offset, val.s);\n+      break;\n+    case T_CHAR:\n+      obj->char_field_put(offset, val.c);\n+      break;\n+    case T_LONG:\n+      obj->long_field_put(offset, val.j);\n+      break;\n+    case T_BOOLEAN:\n+      obj->bool_field_put(offset, val.z);\n+      break;\n+    default: ShouldNotReachHere();\n+  }\n+}\n+\n+void ImmediateReallocClosure::byte_field_put(int offset, intptr_t val, ObjectSnapshot* object_snapshot) {\n+  oop obj = object_snapshot->get_value()();\n+  obj->byte_field_put(offset, (jbyte)*((jint*)&val));\n+}\n+\n+void ImmediateReallocClosure::obj_at_put(int index, oop value, ObjectValue* ov, ObjectSnapshot* object_snapshot) {\n+  objArrayOop obj = (objArrayOop) object_snapshot->get_value()();\n+  obj->obj_at_put(index, value);\n+}\n+\n+void ImmediateReallocClosure::value_at_put(BasicType type, int index, jvalue val, ObjectSnapshot* object_snapshot) {\n+  typeArrayOop obj = (typeArrayOop) object_snapshot->get_value()();\n+  switch (type) {\n+    case T_INT:\n+      obj->int_at_put(index, val.i);\n+      break;\n+    case T_SHORT:\n+      obj->short_at_put(index, val.s);\n+      break;\n+    case T_CHAR:\n+      obj->char_at_put(index, val.c);\n+      break;\n+    case T_LONG:\n+      obj->long_at_put(index, val.j);\n+      break;\n+    case T_BOOLEAN:\n+      obj->bool_at_put(index, val.z);\n+      break;\n+    default: ShouldNotReachHere();\n+  }\n+}\n+\n+void ImmediateReallocClosure::byte_at_put(int index, intptr_t val, int byte_count, ObjectSnapshot* object_snapshot) {\n+  typeArrayOop obj = (typeArrayOop) object_snapshot->get_value()();\n+  Deoptimization::byte_array_put(obj, val, index, byte_count);\n+}\n+\n@@ -976,5 +1209,1 @@\n-bool Deoptimization::realloc_objects(JavaThread* thread, frame* fr, RegisterMap* reg_map, GrowableArray<ScopeValue*>* objects, TRAPS) {\n-  Handle pending_exception(THREAD, thread->pending_exception());\n-  const char* exception_file = thread->exception_file();\n-  int exception_line = thread->exception_line();\n-  thread->clear_pending_exception();\n+bool Deoptimization::realloc_objects(frame* fr, RegisterMap* reg_map, GrowableArray<ScopeValue*>* objects, ReallocClosure* f) {\n@@ -983,0 +1212,1 @@\n+  f->pre_alloc();\n@@ -989,1 +1219,1 @@\n-    oop obj = NULL;\n+    ObjectSnapshot* object_snapshot = NULL;\n@@ -996,2 +1226,2 @@\n-        obj = get_cached_box(abv, fr, reg_map, THREAD);\n-        if (obj != NULL) {\n+        object_snapshot = f->cached_box(abv, fr, reg_map, InstanceKlass::cast(k));\n+        if (object_snapshot != NULL) {\n@@ -1003,3 +1233,3 @@\n-      InstanceKlass* ik = InstanceKlass::cast(k);\n-      if (obj == NULL) {\n-        obj = ik->allocate_instance(THREAD);\n+      if (object_snapshot == NULL) {\n+        InstanceKlass* ik = InstanceKlass::cast(k);\n+        object_snapshot = f->allocate_instance_klass(ik, sv->id());\n@@ -1011,1 +1241,1 @@\n-      obj = ak->allocate(len, THREAD);\n+      object_snapshot = f->allocate_type_array_klass(ak, len, sv->id());\n@@ -1013,2 +1243,1 @@\n-      ObjArrayKlass* ak = ObjArrayKlass::cast(k);\n-      obj = ak->allocate(sv->field_size(), THREAD);\n+      object_snapshot = f->allocate_object_array_klass(ObjArrayKlass::cast(k), sv->field_size(), sv->id());\n@@ -1017,1 +1246,1 @@\n-    if (obj == NULL) {\n+    if (object_snapshot == NULL) {\n@@ -1022,9 +1251,2 @@\n-    assert(obj != NULL || HAS_PENDING_EXCEPTION, \"allocation should succeed or we should get an exception\");\n-    CLEAR_PENDING_EXCEPTION;\n-    sv->set_value(obj);\n-  }\n-\n-  if (failures) {\n-    THROW_OOP_(Universe::out_of_memory_error_realloc_objects(), failures);\n-  } else if (pending_exception.not_null()) {\n-    thread->set_pending_exception(pending_exception(), exception_file, exception_line);\n+    f->post_single_alloc(object_snapshot);\n+    f->update_value(sv, object_snapshot);\n@@ -1032,1 +1254,1 @@\n-\n+  f->post_alloc(failures);\n@@ -1075,1 +1297,1 @@\n-static void byte_array_put(typeArrayOop obj, intptr_t val, int index, int byte_count) {\n+void Deoptimization::byte_array_put(typeArrayOop obj, intptr_t val, int index, int byte_count) {\n@@ -1097,1 +1319,1 @@\n-void Deoptimization::reassign_type_array_elements(frame* fr, RegisterMap* reg_map, ObjectValue* sv, typeArrayOop obj, BasicType type) {\n+void Deoptimization::reassign_type_array_elements(frame* fr, RegisterMap* reg_map, ObjectValue* sv, ObjectSnapshot* object_snapshot, BasicType type, ReallocClosure* f) {\n@@ -1102,1 +1324,7 @@\n-    StackValue* value = StackValue::create_stack_value(fr, reg_map, sv->field_at(i));\n+    StackValue* stack_value = StackValue::create_stack_value(fr, reg_map, sv->field_at(i));\n+    if (stack_value->type() == T_CONFLICT) {\n+      \/\/ skip fields with no values\n+      index += (type == T_LONG || type == T_DOUBLE) ? 2 : 1;\n+      continue;\n+    }\n+    jvalue value;\n@@ -1105,1 +1333,1 @@\n-      assert(value->type() == T_INT, \"Agreement.\");\n+      assert(stack_value->type() == T_INT, \"Agreement.\");\n@@ -1111,1 +1339,1 @@\n-      jlong res = jlong_from((jint)value->get_int(), (jint)low->get_int());\n+      jlong res = jlong_from((jint)stack_value->get_int(), (jint)low->get_int());\n@@ -1113,1 +1341,2 @@\n-      obj->long_at_put(index, res);\n+      value.j = res;\n+      f->value_at_put(T_LONG, index, value, object_snapshot);\n@@ -1119,1 +1348,1 @@\n-      assert(value->type() == T_INT, \"Agreement.\");\n+      assert(stack_value->type() == T_INT, \"Agreement.\");\n@@ -1140,1 +1369,1 @@\n-        jlong res = jlong_from((jint)value->get_int(), (jint)low->get_int());\n+        jlong res = jlong_from((jint)stack_value->get_int(), (jint)low->get_int());\n@@ -1142,2 +1371,5 @@\n-        obj->int_at_put(index, (jint)*((jint*)&res));\n-        obj->int_at_put(++index, (jint)*(((jint*)&res) + 1));\n+        value.i = (jint)*((jint*)&res);\n+        f->value_at_put(T_INT, index, value, object_snapshot);\n+        jvalue lower;\n+        lower.i = (jint)*(((jint*)&res) + 1);\n+        f->value_at_put(T_INT, ++index, lower, object_snapshot);\n@@ -1145,2 +1377,3 @@\n-        val = value->get_int();\n-        obj->int_at_put(index, (jint)*((jint*)&val));\n+        val = stack_value->get_int();\n+        value.i = (jint)*((jint*)&val);\n+        f->value_at_put(T_INT, index, value, object_snapshot);\n@@ -1152,3 +1385,4 @@\n-      assert(value->type() == T_INT, \"Agreement.\");\n-      val = value->get_int();\n-      obj->short_at_put(index, (jshort)*((jint*)&val));\n+      assert(stack_value->type() == T_INT, \"Agreement.\");\n+      val = stack_value->get_int();\n+      value.s = (jshort)*((jint*)&val);\n+      f->value_at_put(T_SHORT, index, value, object_snapshot);\n@@ -1158,3 +1392,4 @@\n-      assert(value->type() == T_INT, \"Agreement.\");\n-      val = value->get_int();\n-      obj->char_at_put(index, (jchar)*((jint*)&val));\n+      assert(stack_value->type() == T_INT, \"Agreement.\");\n+      val = stack_value->get_int();\n+      value.c = (jchar)*((jint*)&val);\n+      f->value_at_put(T_CHAR, index, value, object_snapshot);\n@@ -1164,3 +1399,3 @@\n-      assert(value->type() == T_INT, \"Agreement.\");\n-      \/\/ The value we get is erased as a regular int. We will need to find its actual byte count 'by hand'.\n-      val = value->get_int();\n+      assert(stack_value->type() == T_INT, \"Agreement.\");\n+      \/\/ The stack_value we get is erased as a regular int. We will need to find its actual byte count 'by hand'.\n+      val = stack_value->get_int();\n@@ -1169,1 +1404,1 @@\n-      byte_array_put(obj, val, index, byte_count);\n+      f->byte_at_put(index, val, byte_count, object_snapshot);\n@@ -1182,3 +1417,4 @@\n-      assert(value->type() == T_INT, \"Agreement.\");\n-      val = value->get_int();\n-      obj->bool_at_put(index, (jboolean)*((jint*)&val));\n+      assert(stack_value->type() == T_INT, \"Agreement.\");\n+      val = stack_value->get_int();\n+      value.z = (jboolean)*((jint*)&val);\n+      f->value_at_put(T_BOOLEAN, index, value, object_snapshot);\n@@ -1196,1 +1432,1 @@\n-void Deoptimization::reassign_object_array_elements(frame* fr, RegisterMap* reg_map, ObjectValue* sv, objArrayOop obj) {\n+void Deoptimization::reassign_object_array_elements(frame* fr, RegisterMap* reg_map, ObjectValue* sv, ObjectSnapshot* object_snapshot, ReallocClosure* f) {\n@@ -1199,0 +1435,4 @@\n+    if (value->type() == T_CONFLICT) {\n+      \/\/ skip fields with no values\n+      continue;\n+    }\n@@ -1200,1 +1440,1 @@\n-    obj->obj_at_put(i, value->get_obj()());\n+    f->obj_at_put(i, value->get_obj()(), sv->field_at(i)->is_object() ? sv->field_at(i)->as_ObjectValue() : NULL, object_snapshot);\n@@ -1221,1 +1461,1 @@\n-static int reassign_fields_by_klass(InstanceKlass* klass, frame* fr, RegisterMap* reg_map, ObjectValue* sv, int svIndex, oop obj, bool skip_internal) {\n+static int reassign_fields_by_klass(InstanceKlass* klass, frame* fr, RegisterMap* reg_map, ObjectValue* sv, int svIndex, ObjectSnapshot* object_snapshot, bool skip_internal, ReallocClosure* f) {\n@@ -1239,1 +1479,1 @@\n-    StackValue* value = StackValue::create_stack_value(fr, reg_map, scope_field);\n+    StackValue* stack_value = StackValue::create_stack_value(fr, reg_map, scope_field);\n@@ -1242,0 +1482,6 @@\n+    if (stack_value->type() == T_CONFLICT) {\n+      \/\/ skip fields with no values\n+      svIndex += (type == T_LONG || type == T_DOUBLE) ? 2 : 1;\n+      continue;\n+    }\n+    jvalue value;\n@@ -1244,2 +1490,2 @@\n-        assert(value->type() == T_OBJECT, \"Agreement.\");\n-        obj->obj_field_put(offset, value->get_obj()());\n+        assert(stack_value->type() == T_OBJECT, \"Agreement.\");\n+        f->obj_field_put(offset, stack_value, object_snapshot);\n@@ -1250,1 +1496,1 @@\n-        assert(value->type() == T_INT, \"Agreement.\");\n+        assert(stack_value->type() == T_INT, \"Agreement.\");\n@@ -1272,2 +1518,4 @@\n-          val = value->get_int();\n-          obj->int_field_put(offset, (jint)*((jint*)&val));\n+          val = stack_value->get_int();\n+          jvalue value;\n+          value.i = (jint) *((jint *) &val);\n+          f->value_put(T_INT, offset, value, object_snapshot);\n@@ -1280,1 +1528,1 @@\n-        assert(value->type() == T_INT, \"Agreement.\");\n+        assert(stack_value->type() == T_INT, \"Agreement.\");\n@@ -1287,1 +1535,2 @@\n-        obj->long_field_put(offset, res);\n+        value.j = res;\n+        f->value_put(T_LONG, offset, value, object_snapshot);\n@@ -1292,3 +1541,4 @@\n-        assert(value->type() == T_INT, \"Agreement.\");\n-        val = value->get_int();\n-        obj->short_field_put(offset, (jshort)*((jint*)&val));\n+        assert(stack_value->type() == T_INT, \"Agreement.\");\n+        val = stack_value->get_int();\n+        value.s = (jshort)*((jint*)&val);\n+        f->value_put(T_SHORT, offset, value, object_snapshot);\n@@ -1298,3 +1548,4 @@\n-        assert(value->type() == T_INT, \"Agreement.\");\n-        val = value->get_int();\n-        obj->char_field_put(offset, (jchar)*((jint*)&val));\n+        assert(stack_value->type() == T_INT, \"Agreement.\");\n+        val = stack_value->get_int();\n+        value.c = (jchar)*((jint*)&val);\n+        f->value_put(T_CHAR, offset, value, object_snapshot);\n@@ -1304,3 +1555,3 @@\n-        assert(value->type() == T_INT, \"Agreement.\");\n-        val = value->get_int();\n-        obj->byte_field_put(offset, (jbyte)*((jint*)&val));\n+        assert(stack_value->type() == T_INT, \"Agreement.\");\n+        val = stack_value->get_int();\n+        f->byte_field_put(offset, (jbyte)*((jint*)&val), object_snapshot);\n@@ -1310,3 +1561,4 @@\n-        assert(value->type() == T_INT, \"Agreement.\");\n-        val = value->get_int();\n-        obj->bool_field_put(offset, (jboolean)*((jint*)&val));\n+        assert(stack_value->type() == T_INT, \"Agreement.\");\n+        val = stack_value->get_int();\n+        value.z = (jboolean)*((jint*)&val);\n+        f->value_put(T_BOOLEAN, offset, value, object_snapshot);\n@@ -1324,1 +1576,1 @@\n-void Deoptimization::reassign_fields(frame* fr, RegisterMap* reg_map, GrowableArray<ScopeValue*>* objects, bool realloc_failures, bool skip_internal) {\n+void Deoptimization::reassign_fields(frame* fr, RegisterMap* reg_map, GrowableArray<ScopeValue*>* objects, bool realloc_failures, bool skip_internal, ReallocClosure* f) {\n@@ -1328,2 +1580,5 @@\n-    Handle obj = sv->value();\n-    assert(obj.not_null() || realloc_failures, \"reallocation was missed\");\n+    ObjectSnapshot* obj_snapshot = f->get_value(sv);\n+    assert(obj_snapshot != NULL || realloc_failures, \"reallocation was missed\");\n+    if (obj_snapshot == NULL) {\n+      continue;\n+    }\n@@ -1333,3 +1588,0 @@\n-    if (obj.is_null()) {\n-      continue;\n-    }\n@@ -1344,1 +1596,1 @@\n-      reassign_fields_by_klass(ik, fr, reg_map, sv, 0, obj(), skip_internal);\n+      reassign_fields_by_klass(ik, fr, reg_map, sv, 0, obj_snapshot, skip_internal, f);\n@@ -1347,1 +1599,1 @@\n-      reassign_type_array_elements(fr, reg_map, sv, (typeArrayOop) obj(), ak->element_type());\n+      reassign_type_array_elements(fr, reg_map, sv, obj_snapshot, ak->element_type(), f);\n@@ -1349,1 +1601,1 @@\n-      reassign_object_array_elements(fr, reg_map, sv, (objArrayOop) obj());\n+      reassign_object_array_elements(fr, reg_map, sv, obj_snapshot, f);\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":345,"deletions":93,"binary":false,"changes":438,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,2 @@\n+class ReallocClosure;\n+class ObjectSnapshot;\n@@ -162,0 +164,1 @@\n+  static oop get_cached_box(BasicType box_type, intptr_t value, TRAPS);\n@@ -172,4 +175,4 @@\n-  static bool realloc_objects(JavaThread* thread, frame* fr, RegisterMap* reg_map, GrowableArray<ScopeValue*>* objects, TRAPS);\n-  static void reassign_type_array_elements(frame* fr, RegisterMap* reg_map, ObjectValue* sv, typeArrayOop obj, BasicType type);\n-  static void reassign_object_array_elements(frame* fr, RegisterMap* reg_map, ObjectValue* sv, objArrayOop obj);\n-  static void reassign_fields(frame* fr, RegisterMap* reg_map, GrowableArray<ScopeValue*>* objects, bool realloc_failures, bool skip_internal);\n+  static bool realloc_objects(frame* fr, RegisterMap* reg_map, GrowableArray<ScopeValue*>* objects, ReallocClosure* f);\n+  static void reassign_type_array_elements(frame* fr, RegisterMap* reg_map, ObjectValue* sv, ObjectSnapshot* object_snapshot, BasicType type, ReallocClosure* f);\n+  static void reassign_object_array_elements(frame* fr, RegisterMap* reg_map, ObjectValue* sv, ObjectSnapshot* object_snapshot, ReallocClosure* f);\n+  static void reassign_fields(frame* fr, RegisterMap* reg_map, GrowableArray<ScopeValue*>* objects, bool realloc_failures, bool skip_internal, ReallocClosure* f);\n@@ -177,0 +180,1 @@\n+  static void byte_array_put(typeArrayOop obj, intptr_t val, int index, int byte_count);\n@@ -477,0 +481,137 @@\n+\/\/ marker types for reallocating objects after VM frames dump operation\n+enum AllocType {\n+  BOXED                 = 1,\n+  INSTANCE_KLASS        = 2,\n+  TYPE_ARRAY_KLASS      = 3,\n+  OBJECT_ARRAY          = 4,\n+  PRE_EXISTING          = 5,\n+};\n+\n+\/\/ An instance of this class represents the value of a field or array element.\n+\/\/ For fields an _offset is stored and for array elements an _index.\n+\/\/ A FieldValueSnapshot instance stores primitive values directly (using jvalue),\n+\/\/ scalar-replaced objects as an ObjectValue ID and already allocated objects as jobject (using jvalue).\n+class FieldValueSnapshot : public CHeapObj<mtInternal> {\n+private:\n+  int                       _offset;\n+  int                       _index;\n+  BasicType                 _type;\n+  int                       _object_id;\n+  jvalue                    _val;\n+  int                       _byte_count;\n+  intptr_t                  _byte_val; \/\/ the raw intptr_t is needed for Deoptimization::byte_array_put() call\n+\n+public:\n+  FieldValueSnapshot(BasicType type, int offset) {\n+    _type = type;\n+    _offset = offset;\n+    _object_id = -1;\n+    _index = -1;\n+    _byte_count = -1;\n+    _byte_val = -1;\n+  }\n+\n+  BasicType type() { return _type; }\n+  int offset() { return _offset; }\n+  void set_index(int index) { _index = index; }\n+  int get_index() { return _index; }\n+  void set_object_id(int id) { _object_id = id; }\n+  int get_object_id() { return _object_id; }\n+  void set_value(jvalue value) { _val = value; }\n+  jvalue get_value() { return _val; }\n+  void set_byte(intptr_t val) { _byte_val = val; }\n+  intptr_t get_byte() { return _byte_val; }\n+  void set_byte_count(int byte_count) { _byte_count = byte_count; }\n+  int get_byte_count() { return _byte_count; }\n+};\n+\n+class StackValue;\n+\/\/ An ObjectSnapshot represents the information required to allocate an object based on allocation type.\n+\/\/ ObjectSnapshot instances are created by implementations of ReallocClosure while executing realloc_objects.\n+class ObjectSnapshot : public CHeapObj<mtInternal> {\n+private:\n+  Thread*                  _thread;\n+  Handle                   _value;\n+  const int                _id;\n+  const AllocType          _alloc_type;\n+  BasicType                _box_type;\n+  intptr_t                 _box_value_or_array_length;\n+  Klass*                   _klass;\n+  GrowableArray<FieldValueSnapshot*>* _fields;\n+  bool                    _materialized;\n+\n+public:\n+  ObjectSnapshot(Thread* thread, int id, Handle value, AllocType allocType = PRE_EXISTING);\n+  ObjectSnapshot(Thread* thread, int id, AllocType alloc_type, Klass* klass = NULL, int array_length = 0);\n+  ~ObjectSnapshot();\n+\n+  Handle get_value();\n+  int get_id();\n+  void set_value(oop value);\n+  AllocType get_alloc_type();\n+  Klass* get_klass();\n+  int get_array_length();\n+  void set_box_type(BasicType type, intptr_t i, Klass* klass);\n+  BasicType get_box_type();\n+  intptr_t get_box_value();\n+  GrowableArray<FieldValueSnapshot*>* get_fields();\n+  void set_klass(Klass *klass, int len = -1);\n+  void put_obj_id(int offset, int id);\n+  void put_byte_field(int offset, intptr_t val);\n+  void put_value(int offset, BasicType type, jvalue value);\n+  void at_put( int index, BasicType type, jvalue val);\n+  void byte_at_put(int index, intptr_t val, int byte_count);\n+  void obj_at_put(int index, ObjectValue* ov);\n+};\n+\n+\/\/ ReallocClosure is the super class used to control a specific re-allocation\n+\/\/ and reassign fields implementation.\n+class ReallocClosure : public Closure {\n+public:\n+  virtual ObjectSnapshot* cached_box(AutoBoxObjectValue *bv, frame *fr, RegisterMap *reg_map, InstanceKlass *klass) = 0;\n+  virtual ObjectSnapshot* allocate_instance_klass(InstanceKlass* ik, int object_id) = 0;\n+  virtual ObjectSnapshot* allocate_type_array_klass(TypeArrayKlass* ak, int len, int object_id) = 0;\n+  virtual ObjectSnapshot* allocate_object_array_klass(ObjArrayKlass* ak, int i, int object_id) = 0;\n+  virtual void update_value(ObjectValue* ov, ObjectSnapshot* obj) = 0;\n+  virtual ObjectSnapshot* get_value(ObjectValue* value) = 0;\n+  virtual void obj_field_put(int offset, StackValue* sv, ObjectSnapshot* obj) = 0;\n+  virtual void value_put(BasicType type, int offset, jvalue val, ObjectSnapshot* obj) = 0;\n+  virtual void byte_field_put(int offset, intptr_t val, ObjectSnapshot* obj) = 0;\n+  virtual void obj_at_put(int index, oop value, ObjectValue* ov, ObjectSnapshot* obj) = 0;\n+  virtual void value_at_put(BasicType type, int index, jvalue val, ObjectSnapshot* obj) = 0;\n+  virtual void byte_at_put(int index, intptr_t val, int byte_count, ObjectSnapshot* obj) = 0;\n+  virtual void pre_alloc() = 0;\n+  virtual void post_single_alloc(ObjectSnapshot* object_snapshot) = 0;\n+  virtual void post_alloc(bool failures) = 0;\n+};\n+\n+\/\/ An implementation of ReallocClosure that does object re-allocation and\n+\/\/ reassign fields immediately.\n+class ImmediateReallocClosure : public ReallocClosure {\n+private:\n+  Thread*                 _thread;\n+  Handle                  _pending_exception;\n+  const char*             _exception_file;\n+  int                     _exception_line;\n+public:\n+  ImmediateReallocClosure(Thread* thread) {\n+    _thread = thread;\n+  }\n+\n+  void pre_alloc();\n+  void post_single_alloc(ObjectSnapshot* object_snapshot);\n+  void post_alloc(bool failures);\n+  ObjectSnapshot* cached_box(AutoBoxObjectValue *bv, frame *fr, RegisterMap *reg_map, InstanceKlass *Klass);\n+  ObjectSnapshot* allocate_instance_klass(InstanceKlass* ik, int object_id);\n+  ObjectSnapshot* allocate_type_array_klass(TypeArrayKlass* ak, int len, int object_id);\n+  ObjectSnapshot* allocate_object_array_klass(ObjArrayKlass* ak, int len, int object_id);\n+  void update_value(ObjectValue* ov, ObjectSnapshot* object_snapshot);\n+  ObjectSnapshot* get_value(ObjectValue* value);\n+  void obj_field_put(int offset, StackValue* sv, ObjectSnapshot* object_snapshot);\n+  void value_put(BasicType type, int offset, jvalue val, ObjectSnapshot* object_snapshot);\n+  void byte_field_put(int offset, intptr_t val, ObjectSnapshot* object_snapshot);\n+  void obj_at_put(int index, oop value, ObjectValue* ov, ObjectSnapshot *object_snapshot);\n+  void value_at_put(BasicType type, int index, jvalue val, ObjectSnapshot* obj);\n+  void byte_at_put(int index, intptr_t val, int byte_count, ObjectSnapshot* object_snapshot);\n+};\n+\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.hpp","additions":146,"deletions":5,"binary":false,"changes":151,"status":"modified"},{"patch":"@@ -95,0 +95,1 @@\n+      assert(value_addr != NULL, \"Location:narrowoop: must be non-null\");\n@@ -119,0 +120,1 @@\n+      assert(value_addr != NULL, \"Location:oop: must be non-null\");\n@@ -180,1 +182,1 @@\n-    return new StackValue(ov, (ov.is_null()) ? 1 : 0);\n+    return new StackValue(ov, (ov.is_null()) ? ((ObjectValue *)sv)->id() : -1);\n","filename":"src\/hotspot\/share\/runtime\/stackValue.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,1 @@\n-  StackValue(Handle value, intptr_t scalar_replaced = 0) {\n+  StackValue(Handle value, intptr_t scalar_replaced = -1) {\n@@ -51,1 +51,1 @@\n-    assert(_integer_value == 0 ||  _handle_value.is_null(), \"not null object should not be marked as scalar replaced\");\n+    assert(_integer_value == -1 ||  _handle_value.is_null(), \"not null object should not be marked as scalar replaced\");\n@@ -56,1 +56,1 @@\n-    _integer_value  = 0;\n+    _integer_value  = -1;\n@@ -73,1 +73,6 @@\n-    return _integer_value != 0;\n+    return _integer_value != -1;\n+  }\n+\n+  int get_obj_id() {\n+    assert(obj_is_scalar_replaced(), \"must be!\");\n+    return _integer_value;\n","filename":"src\/hotspot\/share\/runtime\/stackValue.hpp","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -347,0 +347,44 @@\n+VM_FramesDump::VM_FramesDump(FramesDumpResult* result,\n+                             GrowableArray<instanceHandle>* threads,\n+                             jobjectArray initial_methods,\n+                             jobjectArray match_methods,\n+                             jint initialSkip,\n+                             int max_depth,\n+                             JNIHandleBlock* handles,\n+                             JVMCIEnv* JVMCIENV) {\n+  _result = result;\n+  _threads = threads;\n+  _max_depth = max_depth;\n+  _initial_methods = initial_methods;\n+  _match_methods = match_methods;\n+  _initialSkip = initialSkip;\n+  _handles = handles;\n+  _JVMCIENV = JVMCIENV;\n+}\n+\n+void VM_FramesDump::doit() {\n+  \/\/ Snapshot frames in the given _threads array\n+  for (int i = 0; i < _threads->length(); i++) {\n+    instanceHandle th = _threads->at(i);\n+    if (th() == NULL) {\n+      \/\/ skip if the thread doesn't exist\n+      \/\/ Add a NULL snapshot\n+      _result->add_frames_snapshot(NULL);\n+      continue;\n+    }\n+\n+    \/\/ Dump thread stack only if the thread is alive and not exiting\n+    \/\/ and not VM internal thread.\n+    JavaThread* jt = java_lang_Thread::thread(th());\n+    if (jt == NULL || \/* thread not alive *\/\n+        jt->is_exiting() ||\n+        jt->is_hidden_from_external_view() ||\n+        !jt->has_last_Java_frame())  {\n+      \/\/ add a NULL snapshot if skipped\n+      _result->add_frames_snapshot(NULL);\n+      continue;\n+    }\n+    _result->dump_frames_at_safepoint(jt, _initial_methods, _match_methods, _initialSkip, _max_depth, _handles, _JVMCIENV);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.cpp","additions":44,"deletions":0,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+  template(FramesDump)                            \\\n@@ -387,0 +388,46 @@\n+class FramesSnapshot;\n+\n+\/\/ The full dump taken of frames during a VM_FramesDump operation.\n+\/\/ The first snapshot is looked up by means of the _snapshots field, of which\n+\/\/ further iteration is possible by calling next() of current snapshot.\n+class FramesDumpResult : public StackObj {\n+private:\n+  int                  _num_threads;\n+  int                  _num_snapshots;\n+  FramesSnapshot*      _snapshots;\n+  FramesSnapshot*      _last;\n+public:\n+  FramesDumpResult(int num_threads);\n+  ~FramesDumpResult();\n+\n+  void                 add_frames_snapshot(FramesSnapshot* ts);\n+  void                 dump_frames_at_safepoint(JavaThread* java_thread, jobjectArray initial_methods, jobjectArray match_methods, jint initialSkip, int max_frames, JNIHandleBlock* handles, JVMCIEnv* JVMCIENV);\n+  int                  num_threads()                    { return _num_threads; }\n+  int                  num_snapshots()                  { return _num_snapshots; }\n+  FramesSnapshot*      snapshots()                      { return _snapshots; }\n+};\n+\n+class VM_FramesDump : public VM_Operation {\n+private:\n+  FramesDumpResult*              _result;\n+  GrowableArray<instanceHandle>* _threads;\n+  int                            _max_depth;\n+  jobjectArray                   _initial_methods;\n+  jobjectArray                   _match_methods;\n+  jint                           _initialSkip;\n+  JNIHandleBlock*                _handles;\n+  JVMCIEnv*                      _JVMCIENV;\n+\n+public:\n+  VM_FramesDump(FramesDumpResult* result,\n+                GrowableArray<instanceHandle>* threads,\n+                jobjectArray initial_methods,\n+                jobjectArray match_methods,\n+                jint initialSkip,\n+                int max_depth, \/\/ -1 indicates entire stack\n+                JNIHandleBlock* handles,\n+                JVMCIEnv* JVMCIENV);\n+\n+  VMOp_Type type() const { return VMOp_FramesDump; }\n+  void doit();\n+};\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.hpp","additions":47,"deletions":0,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,0 +46,59 @@\n+\n+    \/**\n+     * Returns a snapshot of the stack frames for each thread in {@code threads} up to and including\n+     * {@code limit}. The returned {@link InspectedFrame}s should be seen as a snapshot in the sense\n+     * that any client inspecting and possibly mutating the frame contents will do so under the\n+     * assumption that the underlying threads might have continued, executing potentially\n+     * invalidating the frame state.\n+     *\n+     * Note that the locals of the {@link InspectedFrame}s will be collected as copies when the\n+     * underlying frame was compiled, whereas they'll be references for interpreted frames. Use\n+     * {@link InspectedFrame#isVirtual} to determine if locals are virtual copies and\n+     * {@link InspectedFrame#materializeVirtualObjects} when a materialization is required. This\n+     * means that if the underlying thread continues to execute and a client later read locals, the\n+     * values will be either the current value or the value at collecting time. Any client that\n+     * requires a deterministic read from a local returned from this method, must do so while the\n+     * thread is suspended throughout executing this method and performing the locals read.\n+     *\n+     * Example use cases:\n+     *\n+     * A debugger needs access to the content of stack frames such as local variables.\n+     * In cases where threads execute in the runtime or in native code, it's not possible to obtain\n+     * a thread suspension hook, for which {@link StackIntrospection#iterateFrames} can be used on\n+     * the suspended thread. The getStackFrames method enables an immediate stack frames lookup\n+     * regardless of the status of the underlying (active) thread.\n+     *\n+     * Any tool or system that require taking stack frame snapshots will benefit from this method.\n+     * Whenever there is a need to fetch the stack frames from n threads at a fixed point in time,\n+     * this method provides a way to do so utilizing at most one single safe point.\n+     *\n+     * The following example shows how to read and manipulate an object stored at a known index in a\n+     * frame:\n+     * <pre>\n+     *     StackIntrospection si = ...;\n+     *     Thread[] suspendedThreads = ...;\n+     *     InspectedFrame[][] stacks = si.getStackFrames(null, null, 0, -1, suspendedThreads);\n+     *     for (InspectedFrame[] stack : stacks) {\n+     *         for (InspectedFrame frame : stack) {\n+     *             \/\/ read the (known MyObject) at index 0\n+     *             MyObject value = (MyObject) frame.getLocal(0);\n+     *             \/\/ manipulating the object requires the local to be materialized\n+     *             if (frame.isVirtual(0) {\n+     *                 \/\/ we got a copy of the MyObject, so materialize the frame\n+     *                 frame.materializeVirtualObjects(false);\n+     *             }\n+     *             value.manipulate();\n+     *         }\n+     *     }\n+     * <\/pre>\n+     *\n+     * @param initialMethods if this is non-{@code null}, then the stack walk will start at the\n+     *            first frame whose method is one of these methods.\n+     * @param matchingMethods if this is non-{@code null}, then only frames whose methods are in\n+     *            this array are walked\n+     * @param initialSkip the number of matching methods to skip (including the initial method)\n+     * @param limit limit the returned frames to this limit or when -1 return all frames\n+     * @param threads the input thread array\n+     * @return a two-dimensional array of stack frames in the order of the input threads array\n+     *\/\n+    InspectedFrame[][] getStackFrames(ResolvedJavaMethod[] initialMethods, ResolvedJavaMethod[] matchingMethods, int initialSkip, int limit, Thread[] threads);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.code\/src\/jdk\/vm\/ci\/code\/stack\/StackIntrospection.java","additions":60,"deletions":1,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import jdk.vm.ci.code.stack.InspectedFrame;\n@@ -591,0 +592,5 @@\n+    \/**\n+     * @see jdk.vm.ci.code.stack.StackIntrospection#getStackFrames\n+     *\/\n+    native InspectedFrame[][] getStackFrames(ResolvedJavaMethod[] initialMethods, ResolvedJavaMethod[] matchingMethods, int initialSkip, int maxFrames, Thread[] threads);\n+\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/CompilerToVM.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+    private Thread thread;\n@@ -46,0 +47,4 @@\n+    public Thread getThread() {\n+        return thread;\n+    }\n+\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotStackFrameReference.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+import jdk.vm.ci.code.stack.InspectedFrame;\n@@ -42,0 +43,6 @@\n+\n+    @Override\n+    public InspectedFrame[][] getStackFrames(ResolvedJavaMethod[] initialMethods, ResolvedJavaMethod[] matchingMethods, int initialSkip, int maxFrames, Thread[] threads) {\n+        CompilerToVM compilerToVM = runtime.getCompilerToVM();\n+        return compilerToVM.getStackFrames(initialMethods, matchingMethods, initialSkip, maxFrames, threads);\n+    }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotStackIntrospection.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import jdk.vm.ci.code.stack.InspectedFrame;\n@@ -284,0 +285,9 @@\n+    public static InspectedFrame[][] getStackFrames(\n+            ResolvedJavaMethod[] initialMethods,\n+            ResolvedJavaMethod[] matchingMethods,\n+            int initialSkip,\n+            int maxFrames,\n+            Thread[] threads) {\n+        return CTVM.getStackFrames(initialMethods, matchingMethods, initialSkip, maxFrames, threads);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/common\/patches\/jdk.internal.vm.ci\/jdk\/vm\/ci\/hotspot\/CompilerToVMHelper.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,375 @@\n+\/*\n+ * Copyright (c) 2020, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8136421\n+ *\n+ * @requires vm.jvmci & vm.compMode == \"Xmixed\"\n+ * @requires vm.opt.final.EliminateAllocations == true\n+ *\n+ * @comment no \"-Xcomp -XX:-TieredCompilation\" combination allowed until JDK-8140018 is resolved\n+ * @requires vm.opt.TieredCompilation == null | vm.opt.TieredCompilation == true\n+ *\n+ * @library \/ \/test\/lib\n+ * @library ..\/common\/patches\n+ * @modules java.base\/jdk.internal.misc\n+ * @modules java.base\/jdk.internal.org.objectweb.asm\n+ *          java.base\/jdk.internal.org.objectweb.asm.tree\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.hotspot\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.code\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.code.stack\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.meta\n+ *\n+ * @build jdk.internal.vm.ci\/jdk.vm.ci.hotspot.CompilerToVMHelper sun.hotspot.WhiteBox\n+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -Xbatch -Xbootclasspath\/a:.\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI\n+ *                   -XX:CompileCommand=exclude,compiler.jvmci.compilerToVM.GetStackFramesOtherThreadTest::check\n+ *                   -XX:CompileCommand=dontinline,compiler.jvmci.compilerToVM.GetStackFramesOtherThreadTest::testFrame\n+ *                   -XX:CompileCommand=dontinline,compiler.jvmci.compilerToVM.GetStackFramesOtherThreadTest::testFrame2\n+ *                   -XX:CompileCommand=inline,compiler.jvmci.compilerToVM.GetStackFramesOtherThreadTest::recurse\n+ *                   -XX:CompileCommand=inline,compiler.jvmci.compilerToVM.GetStackFramesOtherThreadTest::testFrame3\n+ *                   -XX:+DoEscapeAnalysis -XX:-UseCounterDecay\n+ *                   -Dcompiler.jvmci.compilerToVM.GetStackFramesOtherThreadTest.materializeFirst=true\n+ *                   -Dcompiler.jvmci.compilerToVM.GetStackFramesOtherThreadTest.invalidate=false\n+ *                   compiler.jvmci.compilerToVM.GetStackFramesOtherThreadTest\n+ * @run main\/othervm -Xbatch -Xbootclasspath\/a:.\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI\n+ *                   -XX:CompileCommand=exclude,compiler.jvmci.compilerToVM.GetStackFramesOtherThreadTest::check\n+ *                   -XX:CompileCommand=dontinline,compiler.jvmci.compilerToVM.GetStackFramesOtherThreadTest::testFrame\n+ *                   -XX:CompileCommand=dontinline,compiler.jvmci.compilerToVM.GetStackFramesOtherThreadTest::testFrame2\n+ *                   -XX:CompileCommand=inline,compiler.jvmci.compilerToVM.GetStackFramesOtherThreadTest::recurse\n+ *                   -XX:CompileCommand=inline,compiler.jvmci.compilerToVM.GetStackFramesOtherThreadTest::testFrame3\n+ *                   -XX:+DoEscapeAnalysis -XX:-UseCounterDecay\n+ *                   -Dcompiler.jvmci.compilerToVM.GetStackFramesOtherThreadTest.materializeFirst=false\n+ *                   -Dcompiler.jvmci.compilerToVM.GetStackFramesOtherThreadTest.invalidate=false\n+ *                   compiler.jvmci.compilerToVM.GetStackFramesOtherThreadTest\n+ * @run main\/othervm -Xbatch -Xbootclasspath\/a:.\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI\n+ *                   -XX:CompileCommand=exclude,compiler.jvmci.compilerToVM.GetStackFramesOtherThreadTest::check\n+ *                   -XX:CompileCommand=dontinline,compiler.jvmci.compilerToVM.GetStackFramesOtherThreadTest::testFrame\n+ *                   -XX:CompileCommand=dontinline,compiler.jvmci.compilerToVM.GetStackFramesOtherThreadTest::testFrame2\n+ *                   -XX:CompileCommand=inline,compiler.jvmci.compilerToVM.GetStackFramesOtherThreadTest::recurse\n+ *                   -XX:CompileCommand=inline,compiler.jvmci.compilerToVM.GetStackFramesOtherThreadTest::testFrame3\n+ *                   -XX:+DoEscapeAnalysis -XX:-UseCounterDecay\n+ *                   -Dcompiler.jvmci.compilerToVM.GetStackFramesOtherThreadTest.materializeFirst=true\n+ *                   -Dcompiler.jvmci.compilerToVM.GetStackFramesOtherThreadTest.invalidate=true\n+ *                   compiler.jvmci.compilerToVM.GetStackFramesOtherThreadTest\n+ * @run main\/othervm -Xbatch -Xbootclasspath\/a:.\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI\n+ *                   -XX:CompileCommand=exclude,compiler.jvmci.compilerToVM.GetStackFramesOtherThreadTest::check\n+ *                   -XX:CompileCommand=dontinline,compiler.jvmci.compilerToVM.GetStackFramesOtherThreadTest::testFrame\n+ *                   -XX:CompileCommand=dontinline,compiler.jvmci.compilerToVM.GetStackFramesOtherThreadTest::testFrame2\n+ *                   -XX:CompileCommand=inline,compiler.jvmci.compilerToVM.GetStackFramesOtherThreadTest::recurse\n+ *                   -XX:CompileCommand=inline,compiler.jvmci.compilerToVM.GetStackFramesOtherThreadTest::testFrame3\n+ *                   -XX:+DoEscapeAnalysis -XX:-UseCounterDecay\n+ *                   -Dcompiler.jvmci.compilerToVM.GetStackFramesOtherThreadTest.materializeFirst=false\n+ *                   -Dcompiler.jvmci.compilerToVM.GetStackFramesOtherThreadTest.invalidate=true\n+ *                   compiler.jvmci.compilerToVM.GetStackFramesOtherThreadTest\n+ *\/\n+\n+package compiler.jvmci.compilerToVM;\n+\n+import compiler.jvmci.common.CTVMUtilities;\n+import compiler.testlibrary.CompilerUtils;\n+import compiler.whitebox.CompilerWhiteBoxTest;\n+import jdk.test.lib.Asserts;\n+import jdk.vm.ci.code.stack.InspectedFrame;\n+import jdk.vm.ci.hotspot.CompilerToVMHelper;\n+import jdk.vm.ci.hotspot.HotSpotStackFrameReference;\n+import jdk.vm.ci.meta.ResolvedJavaMethod;\n+import jdk.vm.ci.code.stack.InspectedFrame;\n+import jtreg.SkippedException;\n+import sun.hotspot.WhiteBox;\n+\n+import java.lang.reflect.Method;\n+\n+public class GetStackFramesOtherThreadTest {\n+    private static final WhiteBox WB;\n+    private static final boolean INVALIDATE;\n+    private static final int COMPILE_THRESHOLD;\n+    private static final Method MATERIALIZED_METHOD;\n+    private static final Method NOT_MATERIALIZED_METHOD;\n+    private static final Method FRAME3_METHOD;\n+    private static final ResolvedJavaMethod MATERIALIZED_RESOLVED;\n+    private static final ResolvedJavaMethod NOT_MATERIALIZED_RESOLVED;\n+    private static final ResolvedJavaMethod FRAME2_RESOLVED;\n+    private static final ResolvedJavaMethod FRAME3_RESOLVED;\n+    private static final boolean MATERIALIZE_FIRST;\n+\n+    static {\n+        Method method1;\n+        Method method2;\n+        WB = WhiteBox.getWhiteBox();\n+        try {\n+            method1 = GetStackFramesOtherThreadTest.class.getDeclaredMethod(\"testFrame\",\n+                    String.class, int.class);\n+            method2 = GetStackFramesOtherThreadTest.class.getDeclaredMethod(\"testFrame2\",\n+                    String.class, int.class);\n+            FRAME3_METHOD = GetStackFramesOtherThreadTest.class.getDeclaredMethod(\"testFrame3\",\n+                    Helper.class, int.class);\n+        } catch (NoSuchMethodException e) {\n+            throw new Error(\"Can't get executable for test method\", e);\n+        }\n+        ResolvedJavaMethod resolved1;\n+        resolved1 = CTVMUtilities.getResolvedMethod(method1);\n+        FRAME2_RESOLVED = CTVMUtilities.getResolvedMethod(method2);\n+        FRAME3_RESOLVED = CTVMUtilities.getResolvedMethod(FRAME3_METHOD);\n+        INVALIDATE = Boolean.getBoolean(\n+                \"compiler.jvmci.compilerToVM.GetStackFramesOtherThreadTest.invalidate\");\n+        COMPILE_THRESHOLD = WB.getBooleanVMFlag(\"TieredCompilation\")\n+                ? CompilerWhiteBoxTest.THRESHOLD\n+                : CompilerWhiteBoxTest.THRESHOLD * 2;\n+        MATERIALIZE_FIRST = Boolean.getBoolean(\n+                \"compiler.jvmci.compilerToVM.GetStackFramesOtherThreadTest.materializeFirst\");\n+        MATERIALIZED_RESOLVED = MATERIALIZE_FIRST ? resolved1 : FRAME2_RESOLVED;\n+        NOT_MATERIALIZED_RESOLVED = MATERIALIZE_FIRST ? FRAME2_RESOLVED : resolved1;\n+        MATERIALIZED_METHOD = MATERIALIZE_FIRST ? method1 : method2;\n+        NOT_MATERIALIZED_METHOD = MATERIALIZE_FIRST ? method2 : method1;\n+    }\n+\n+    public static void main(String[] args) {\n+        int levels[] = CompilerUtils.getAvailableCompilationLevels();\n+        \/\/ we need compilation level 4 to use EscapeAnalysis\n+        if (levels.length < 1 || levels[levels.length - 1] != 4) {\n+            throw new SkippedException(\"Test needs compilation level 4\");\n+        }\n+\n+        new GetStackFramesOtherThreadTest().test();\n+    }\n+\n+    private static String getName() {\n+        return \"CASE: invalidate=\" + INVALIDATE + \", materializedMethod=\"\n+                + (MATERIALIZE_FIRST ? \"testFrame\" : \"testFrame2\")\n+                + \", notMaterializedMethod=\"\n+                + (MATERIALIZE_FIRST ? \"testFrame2\" : \"testFrame\");\n+    }\n+\n+    private void test() {\n+        System.out.println(getName());\n+        Asserts.assertFalse(WB.isMethodCompiled(MATERIALIZED_METHOD),\n+                getName() + \" : materialized method is compiled\");\n+        Asserts.assertFalse(WB.isMethodCompiled(NOT_MATERIALIZED_METHOD),\n+                getName() + \" : not materialized method is compiled\");\n+        for (int i = 0; i < CompilerWhiteBoxTest.THRESHOLD; i++) {\n+            testFrame(\"someString\", i);\n+        }\n+        Asserts.assertTrue(WB.isMethodCompiled(MATERIALIZED_METHOD), getName()\n+                + \" : materialized method not compiled\");\n+        Asserts.assertTrue(WB.isMethodCompiled(NOT_MATERIALIZED_METHOD),\n+                getName() + \" : not materialized method not compiled\");\n+        testFrame(\"someString\", \/* materialize *\/ CompilerWhiteBoxTest.THRESHOLD);\n+\n+        \/\/ run second test types\n+        for (int i = 0; i < CompilerWhiteBoxTest.THRESHOLD; i++) {\n+            testFrame(\"someString\", i);\n+        }\n+        Asserts.assertTrue(WB.isMethodCompiled(MATERIALIZED_METHOD), getName()\n+                + \" : materialized method not compiled\");\n+        Asserts.assertTrue(WB.isMethodCompiled(NOT_MATERIALIZED_METHOD),\n+                getName() + \" : not materialized method not compiled\");\n+        testFrame(\"someString\", \/* materialize *\/ CompilerWhiteBoxTest.THRESHOLD + 1);\n+    }\n+\n+    private void testFrame(String str, int iteration) {\n+        Helper helper = new Helper(str);\n+        testFrame2(str, iteration);\n+        Asserts.assertTrue((helper.string != null) && (this != null)\n+                && (helper != null), String.format(\"%s : some locals are null\", getName()));\n+    }\n+\n+    private void testFrame2(String str, int iteration) {\n+        Helper helper = new Helper(str);\n+        Helper helper2 = new Helper(\"bar\");\n+        testFrame3(helper, iteration);\n+        Asserts.assertTrue((helper.string != null) && (this != null) && helper.string == str\n+                && (helper != null), String.format(\"%s : some locals are null\", getName()));\n+        Asserts.assertTrue((helper2.string != null) && (this != null)\n+                && (helper2 != null), String.format(\"%s : some locals are null\", getName()));\n+    }\n+\n+    private void testFrame3(Helper outerHelper, int iteration) {\n+        Helper innerHelper = new Helper(\"foo\");\n+        recurse(2, iteration);\n+        Asserts.assertTrue((innerHelper.string != null) && (this != null)\n+                && (innerHelper != null), String.format(\"%s : some locals are null\", getName()));\n+        Asserts.assertTrue((outerHelper.string != null) && (this != null)\n+                && (outerHelper != null), String.format(\"%s : some locals are null\", getName()));\n+    }\n+\n+    private void recurse(int depth, int iteration) {\n+        if (depth == 0) {\n+            check(iteration);\n+        } else {\n+            Integer s = new Integer(depth);\n+            recurse(depth - 1, iteration);\n+            Asserts.assertEQ(s.intValue(), depth,\n+                    String.format(\"different values: %s != %s\", s.intValue(), depth));\n+        }\n+    }\n+\n+    private InspectedFrame[] getCurrentThreadFramesFromOtherThread(ResolvedJavaMethod initialMethod, int maxFrames) {\n+        InspectedFrame[] frames = new InspectedFrame[maxFrames];\n+        SimpleLock lock = new SimpleLock();\n+        lock.acquire();\n+        Thread current = Thread.currentThread();\n+        new Thread(() -> {\n+             InspectedFrame[] fetchedFrames = CompilerToVMHelper.getStackFrames(\n+                    new ResolvedJavaMethod[] {initialMethod},\n+                    null, \/* any *\/\n+                    0,\n+                    maxFrames,\n+                    new Thread[] {current}\n+                )[0];\n+              for (int i = 0; i < maxFrames; i++) {\n+                frames[i] = fetchedFrames[i];\n+              }\n+              \/\/ signal to main thread that frames are ready\n+              synchronized (lock) {\n+                lock.release();\n+                lock.notifyAll();\n+              }\n+        }).start();\n+        synchronized(lock) {\n+            while (lock.isLocked()) {\n+                try {\n+                  lock.wait();\n+                } catch (Throwable t) {\n+                    throw new RuntimeException(\"interrupted in wait loop\", t);\n+                }\n+            }\n+        }\n+        return frames;\n+    }\n+\n+    private void checkStructure(boolean materialize) {\n+        boolean[] framesSeen = new boolean[2];\n+        Object[] helpers = new Object[1];\n+        InspectedFrame[] frames = getCurrentThreadFramesFromOtherThread(FRAME3_RESOLVED, 2);\n+        for (InspectedFrame f : frames) {\n+            if (!framesSeen[1]) {\n+                Asserts.assertTrue(f.isMethod(FRAME3_RESOLVED),\n+                        \"Expected testFrame3 first\");\n+                framesSeen[1] = true;\n+                Asserts.assertTrue(f.getLocal(0) != null, \"this should not be null\");\n+                Asserts.assertTrue(f.getLocal(1) != null, \"outerHelper should not be null\");\n+                Asserts.assertTrue(f.getLocal(3) != null, \"innerHelper should not be null\");\n+                Asserts.assertEQ(((Helper) f.getLocal(3)).string, \"foo\", \"innerHelper.string should be foo\");\n+                helpers[0] = f.getLocal(1);\n+                if (materialize) {\n+                    f.materializeVirtualObjects(false);\n+                }\n+            } else {\n+                Asserts.assertFalse(framesSeen[0], \"frame3 can not have been seen\");\n+                Asserts.assertTrue(f.isMethod(FRAME2_RESOLVED),\n+                        \"Expected testFrame2 second\");\n+                framesSeen[0] = true;\n+                Asserts.assertTrue(f.getLocal(0) != null, \"this should not be null\");\n+                Asserts.assertTrue(f.getLocal(1) != null, \"str should not be null\");\n+                Asserts.assertTrue(f.getLocal(3) != null, \"helper should not be null\");\n+                Asserts.assertTrue(f.getLocal(4) != null, \"helper2 should not be null\");\n+                Asserts.assertEQ(((Helper) f.getLocal(3)).string, f.getLocal(1), \"helper.string should be the same as str\");\n+                Asserts.assertEQ(((Helper) f.getLocal(4)).string, \"bar\", \"helper2.string should be bar\");\n+                if (!materialize) {\n+                    Asserts.assertEQ(f.getLocal(3), helpers[0], \"helper should be the same as frame3's outerHelper\");\n+                }\n+            }\n+        }\n+\n+        Asserts.assertTrue(framesSeen[1], \"frame3 should have been seen\");\n+        Asserts.assertTrue(framesSeen[0], \"frame2 should have been seen\");\n+    }\n+\n+    private void check(int iteration) {\n+        \/\/ Materialize virtual objects on last invocation\n+        if (iteration == COMPILE_THRESHOLD) {\n+            \/\/ get frames and check not-null\n+            HotSpotStackFrameReference materialized = (HotSpotStackFrameReference) getCurrentThreadFramesFromOtherThread(MATERIALIZED_RESOLVED, 1)[0];\n+            Asserts.assertNotNull(materialized, getName()\n+                    + \" : got null frame for materialized method\");\n+            Asserts.assertTrue(materialized.isMethod(MATERIALIZED_RESOLVED),\n+                \"Expected materialized method but got \" + materialized);\n+            InspectedFrame notMaterialized = getCurrentThreadFramesFromOtherThread(NOT_MATERIALIZED_RESOLVED, 1)[0];\n+            Asserts.assertNE(materialized, notMaterialized,\n+                    \"Got same frame pointer for both tested frames\");\n+            Asserts.assertTrue(notMaterialized.isMethod(NOT_MATERIALIZED_RESOLVED),\n+                \"Expected notMaterialized method but got \" + notMaterialized);\n+            Asserts.assertNotNull(notMaterialized, getName()\n+                    + \" : got null frame for not materialized method\");\n+            Asserts.assertTrue(WB.isMethodCompiled(MATERIALIZED_METHOD), getName()\n+                + \" : materialized method not compiled\");\n+            Asserts.assertTrue(WB.isMethodCompiled(NOT_MATERIALIZED_METHOD),\n+                getName() + \" : not materialized method not compiled\");\n+            \/\/ check that frames has virtual objects before materialization stage\n+            Asserts.assertTrue(materialized.hasVirtualObjects(), getName()\n+                    + \": materialized frame has no virtual object before materialization\");\n+            Asserts.assertTrue(notMaterialized.hasVirtualObjects(), getName()\n+                    + \": notMaterialized frame has no virtual object before materialization\");\n+            \/\/ materialize\n+            CompilerToVMHelper.materializeVirtualObjects(materialized, INVALIDATE);\n+            \/\/ check that only not materialized frame has virtual objects\n+            Asserts.assertFalse(materialized.hasVirtualObjects(), getName()\n+                    + \" : materialized has virtual object after materialization\");\n+            Asserts.assertTrue(notMaterialized.hasVirtualObjects(), getName()\n+                    + \" : notMaterialized has no virtual object after materialization\");\n+            \/\/ check that materialized frame was deoptimized in case invalidate=true\n+            Asserts.assertEQ(WB.isMethodCompiled(MATERIALIZED_METHOD), !INVALIDATE, getName()\n+                    + \" : materialized method has unexpected compiled status\");\n+            \/\/ check that not materialized frame wasn't deoptimized\n+            Asserts.assertTrue(WB.isMethodCompiled(NOT_MATERIALIZED_METHOD), getName()\n+                    + \" : not materialized method has unexpected compiled status\");\n+        } else if (iteration == COMPILE_THRESHOLD + 1) {\n+            checkStructure(false);\n+            checkStructure(true);\n+        }\n+    }\n+\n+    private class Helper {\n+        public String string;\n+\n+        public Helper(String s) {\n+            this.string = s;\n+        }\n+    }\n+\n+    private class SimpleLock {\n+        private volatile boolean locked;\n+\n+        public synchronized void acquire() {\n+            locked = true;\n+        }\n+\n+        public synchronized void release() {\n+            locked = false;\n+        }\n+\n+        public boolean isLocked() {\n+            return locked;\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/compilerToVM\/GetStackFramesOtherThreadTest.java","additions":375,"deletions":0,"binary":false,"changes":375,"status":"added"},{"patch":"@@ -0,0 +1,244 @@\n+\/*\n+ * Copyright (c) 2020, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8136421\n+ *\n+ * @requires vm.jvmci & vm.compMode == \"Xmixed\"\n+ * @requires vm.opt.final.EliminateAllocations == true\n+ *\n+ * @comment no \"-Xcomp -XX:-TieredCompilation\" combination allowed until JDK-8140018 is resolved\n+ * @requires vm.opt.TieredCompilation == null | vm.opt.TieredCompilation == true\n+ *\n+ * @library \/ \/test\/lib\n+ * @library ..\/common\/patches\n+ * @modules java.base\/jdk.internal.misc\n+ * @modules java.base\/jdk.internal.org.objectweb.asm\n+ *          java.base\/jdk.internal.org.objectweb.asm.tree\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.hotspot\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.code\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.code.stack\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.meta\n+ *\n+ * @build jdk.internal.vm.ci\/jdk.vm.ci.hotspot.CompilerToVMHelper sun.hotspot.WhiteBox\n+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -Xbatch -Xbootclasspath\/a:.\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI\n+ *                   -XX:CompileCommand=exclude,compiler.jvmci.compilerToVM.GetStackFramesPrimitiveTypesTest::checkStructure\n+ *                   -XX:CompileCommand=dontinline,compiler.jvmci.compilerToVM.GetStackFramesPrimitiveTypesTest::testFrame1\n+ *                   -XX:CompileCommand=dontinline,compiler.jvmci.compilerToVM.GetStackFramesPrimitiveTypesTest::testFrame2\n+ *                   -XX:+DoEscapeAnalysis -XX:-UseCounterDecay\n+ *                   compiler.jvmci.compilerToVM.GetStackFramesPrimitiveTypesTest\n+ *\/\n+\n+package compiler.jvmci.compilerToVM;\n+\n+import compiler.jvmci.common.CTVMUtilities;\n+import compiler.testlibrary.CompilerUtils;\n+import compiler.whitebox.CompilerWhiteBoxTest;\n+import jdk.test.lib.Asserts;\n+import jdk.vm.ci.code.stack.InspectedFrame;\n+import jdk.vm.ci.hotspot.CompilerToVMHelper;\n+import jdk.vm.ci.hotspot.HotSpotStackFrameReference;\n+import jdk.vm.ci.meta.ResolvedJavaMethod;\n+import jdk.vm.ci.code.stack.InspectedFrame;\n+import jtreg.SkippedException;\n+import sun.hotspot.WhiteBox;\n+\n+import java.lang.reflect.Method;\n+\n+public class GetStackFramesPrimitiveTypesTest {\n+    private static final WhiteBox WB;\n+    private static final int COMPILE_THRESHOLD;\n+    private static final Method FRAME1_METHOD;\n+    private static final Method FRAME2_METHOD;\n+    private static final ResolvedJavaMethod FRAME1_RESOLVED;\n+    private static final ResolvedJavaMethod FRAME2_RESOLVED;\n+\n+    static {\n+        WB = WhiteBox.getWhiteBox();\n+        try {\n+            FRAME1_METHOD = GetStackFramesPrimitiveTypesTest.class.getDeclaredMethod(\"testFrame1\",\n+                   int.class);\n+            FRAME2_METHOD = GetStackFramesPrimitiveTypesTest.class.getDeclaredMethod(\"testFrame2\",\n+                   Helper.class, int.class);\n+        } catch (NoSuchMethodException e) {\n+            throw new Error(\"Can't get executable for test method\", e);\n+        }\n+        FRAME1_RESOLVED = CTVMUtilities.getResolvedMethod(FRAME1_METHOD);\n+        FRAME2_RESOLVED = CTVMUtilities.getResolvedMethod(FRAME2_METHOD);\n+        COMPILE_THRESHOLD = WB.getBooleanVMFlag(\"TieredCompilation\")\n+                ? CompilerWhiteBoxTest.THRESHOLD\n+                : CompilerWhiteBoxTest.THRESHOLD * 2;\n+    }\n+\n+    public static void main(String[] args) {\n+        int levels[] = CompilerUtils.getAvailableCompilationLevels();\n+        \/\/ we need compilation level 4 to use EscapeAnalysis\n+        if (levels.length < 1 || levels[levels.length - 1] != 4) {\n+            throw new SkippedException(\"Test needs compilation level 4\");\n+        }\n+\n+        new GetStackFramesPrimitiveTypesTest().test();\n+    }\n+\n+    private void test() {\n+        Asserts.assertFalse(WB.isMethodCompiled(FRAME1_METHOD), \"frame1 method is compiled\");\n+        Asserts.assertFalse(WB.isMethodCompiled(FRAME2_METHOD), \"frame2 method is compiled\");\n+        testFrame1(COMPILE_THRESHOLD);\n+\n+        for (int i = 0; i < COMPILE_THRESHOLD * 2; i++) {\n+            testFrame1(i);\n+        }\n+        Asserts.assertTrue(WB.isMethodCompiled(FRAME1_METHOD), \"frame1 method not compiled\");\n+        Asserts.assertTrue(WB.isMethodCompiled(FRAME2_METHOD), \"frame2 method not compiled\");\n+\n+        testFrame1(COMPILE_THRESHOLD);\n+    }\n+\n+    private void testFrame1(int iteration) {\n+        Helper helper = new Helper(\"someString\", 42, true, (byte) 1, 'c', (short) 42, 42, 0.42, 42f);\n+        testFrame2(helper, iteration);\n+        Asserts.assertTrue((helper.string != null) && (this != null)\n+                        && (helper != null), \"some locals are null\");\n+\n+        Asserts.assertTrue(\"someString\".equals(helper.string), \"helper.string has unexpected value\");\n+        Asserts.assertTrue(helper.i == 42, \"helper.i has unexpected value\");\n+        Asserts.assertTrue(helper.z == true, \"helper.z has unexpected value\");\n+        Asserts.assertTrue(helper.b == (byte) 1, \"helper.b has unexpected value\");\n+        Asserts.assertTrue(helper.c == 'c', \"helper.c has unexpected value\");\n+        Asserts.assertTrue(helper.s == (short) 42, \"helper.s has unexpected value\");\n+        Asserts.assertTrue(helper.j == 42, \"helper.j has unexpected value\");\n+        Asserts.assertTrue(helper.d == 0.42, \"helper.d has unexpected value\");\n+        Asserts.assertTrue(helper.f == 42f, \"helper.f has unexpected value\");\n+    }\n+\n+    private void testFrame2(Helper outerHelper, int iteration) {\n+        Helper innerHelper = new Helper(\"foo\", 42, true, (byte) 1, 'c', (short) 42, 42, 0.42, 42f);\n+        if (iteration == COMPILE_THRESHOLD) {\n+            checkStructure();\n+        }\n+        Asserts.assertTrue((innerHelper.string != null) && (this != null)\n+                  && (innerHelper != null), \"some locals are null\");\n+        Asserts.assertTrue((outerHelper.string != null) && (this != null)\n+                  && (outerHelper != null), \"some locals are null\");\n+\n+        Asserts.assertTrue(\"someString\".equals(outerHelper.string), \"helper.string has unexpected value\");\n+        Asserts.assertTrue(outerHelper.i == 42, \"helper.i has unexpected value\");\n+        Asserts.assertTrue(outerHelper.z == true, \"helper.z has unexpected value\");\n+        Asserts.assertTrue(outerHelper.b == (byte) 1, \"helper.b has unexpected value\");\n+        Asserts.assertTrue(outerHelper.c == 'c', \"helper.c has unexpected value\");\n+        Asserts.assertTrue(outerHelper.s == (short) 42, \"helper.s has unexpected value\");\n+        Asserts.assertTrue(outerHelper.j == 42, \"helper.j has unexpected value\");\n+        Asserts.assertTrue(outerHelper.d == 0.42, \"helper.d has unexpected value\");\n+        Asserts.assertTrue(outerHelper.f == 42f, \"helper.f has unexpected value\");\n+\n+        Asserts.assertTrue(\"foo\".equals(innerHelper.string), \"helper.string has unexpected value\");\n+        Asserts.assertTrue(innerHelper.i == 42, \"helper.i has unexpected value\");\n+        Asserts.assertTrue(innerHelper.z == true, \"helper.z has unexpected value\");\n+        Asserts.assertTrue(innerHelper.b == (byte) 1, \"helper.b has unexpected value\");\n+        Asserts.assertTrue(innerHelper.c == 'c', \"helper.c has unexpected value\");\n+        Asserts.assertTrue(innerHelper.s == (short) 42, \"helper.s has unexpected value\");\n+        Asserts.assertTrue(innerHelper.j == 42, \"helper.j has unexpected value\");\n+        Asserts.assertTrue(innerHelper.d == 0.42, \"helper.d has unexpected value\");\n+        Asserts.assertTrue(innerHelper.f == 42f, \"helper.f has unexpected value\");\n+    }\n+\n+    private void checkStructure() {\n+        boolean[] framesSeen = new boolean[2];\n+\n+        InspectedFrame[] frames = CompilerToVMHelper.getStackFrames(\n+            new ResolvedJavaMethod[] {FRAME2_RESOLVED},\n+            null,\n+            0,\n+            2, \/\/ fetch only 2 frames\n+            new Thread[] {Thread.currentThread()}\n+        )[0];\n+\n+        for (InspectedFrame f : frames) {\n+            if (!framesSeen[1]) {\n+                Asserts.assertTrue(f.isMethod(FRAME2_RESOLVED),\n+                        \"Expected testFrame2 first\");\n+                framesSeen[1] = true;\n+                System.out.println(\"checking frame: \" + f);\n+                Asserts.assertTrue(f.getLocal(0) != null, \"this should not be null\");\n+                Asserts.assertTrue(f.getLocal(1) != null, \"outerHelper should not be null\");\n+                Asserts.assertEQ(((Helper) f.getLocal(1)).string, \"someString\", \"outerHelper.string should be foo\");\n+                Asserts.assertEQ(((Helper) f.getLocal(1)).i, 42, \"outerHelper.i should be 42\");\n+                Asserts.assertEQ(((Helper) f.getLocal(1)).z, true, \"outerHelper.z should be true\");\n+                Asserts.assertEQ(((Helper) f.getLocal(1)).b, (byte) 1, \"outerHelper.b should be 1\");\n+                Asserts.assertEQ(((Helper) f.getLocal(1)).c, 'c', \"outerHelper.c should be c\");\n+                Asserts.assertEQ(((Helper) f.getLocal(1)).s, (short) 42, \"outerHelper.s should be 42\");\n+                Asserts.assertEQ(((Helper) f.getLocal(1)).j, (long) 42, \"outerHelper.j should be 42\");\n+                Asserts.assertEQ(((Helper) f.getLocal(1)).d, 0.42, \"outerHelper.d should be 0.42\");\n+                Asserts.assertEQ(((Helper) f.getLocal(1)).f, 42f, \"outerHelper.f should be 42\");\n+\n+                Asserts.assertTrue(f.getLocal(3) != null, \"innerHelper should not be null\");\n+                Asserts.assertEQ(((Helper) f.getLocal(3)).string, \"foo\", \"innerHelper.string should be foo\");\n+                Asserts.assertEQ(((Helper) f.getLocal(3)).i, 42, \"innerHelper.i should be 42\");\n+                Asserts.assertEQ(((Helper) f.getLocal(3)).z, true, \"innerHelper.z should be true\");\n+                Asserts.assertEQ(((Helper) f.getLocal(3)).b, (byte) 1, \"innerHelper.b should be 1\");\n+                Asserts.assertEQ(((Helper) f.getLocal(3)).c, 'c', \"innerHelper.c should be c\");\n+                Asserts.assertEQ(((Helper) f.getLocal(3)).s, (short) 42, \"innerHelper.s should be 42\");\n+                Asserts.assertEQ(((Helper) f.getLocal(3)).j, (long) 42, \"innerHelper.j should be 42\");\n+                Asserts.assertEQ(((Helper) f.getLocal(3)).d, 0.42, \"innerHelper.d should be 0.42\");\n+                Asserts.assertEQ(((Helper) f.getLocal(3)).f, 42f, \"innerHelper.f should be 42\");\n+            } else {\n+                Asserts.assertFalse(framesSeen[0], \"frame1 can not have been seen\");\n+                Asserts.assertTrue(f.isMethod(FRAME1_RESOLVED),\n+                        \"Expected testFrame1 second\");\n+                framesSeen[0] = true;\n+                Asserts.assertTrue(f.getLocal(0) != null, \"this should not be null\");\n+                Asserts.assertTrue(f.getLocal(2) != null, \"helper should not be null\");\n+            }\n+        }\n+        Asserts.assertTrue(framesSeen[1], \"frame3 should have been seen\");\n+        Asserts.assertTrue(framesSeen[0], \"frame2 should have been seen\");\n+    }\n+\n+    private class Helper {\n+        public String string;\n+        public int i;\n+        public boolean z;\n+        public byte b;\n+        public char c;\n+        public short s;\n+        public long j;\n+        public double d;\n+        public float f;\n+\n+        public Helper(String string, int i, boolean z, byte b, char c, short s, long j, double d, float f) {\n+            this.string = string;\n+            this.i = i;\n+            this.z = z;\n+            this.b = b;\n+            this.c = c;\n+            this.s = s;\n+            this.j = j;\n+            this.d = d;\n+            this.f = f;\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/compilerToVM\/GetStackFramesPrimitiveTypesTest.java","additions":244,"deletions":0,"binary":false,"changes":244,"status":"added"},{"patch":"@@ -0,0 +1,345 @@\n+\/*\n+ * Copyright (c) 2020, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8136421\n+ *\n+ * @requires vm.jvmci & vm.compMode == \"Xmixed\"\n+ * @requires vm.opt.final.EliminateAllocations == true\n+ *\n+ * @comment no \"-Xcomp -XX:-TieredCompilation\" combination allowed until JDK-8140018 is resolved\n+ * @requires vm.opt.TieredCompilation == null | vm.opt.TieredCompilation == true\n+ *\n+ * @library \/ \/test\/lib\n+ * @library ..\/common\/patches\n+ * @modules java.base\/jdk.internal.misc\n+ * @modules java.base\/jdk.internal.org.objectweb.asm\n+ *          java.base\/jdk.internal.org.objectweb.asm.tree\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.hotspot\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.code\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.code.stack\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.meta\n+ *\n+ * @build jdk.internal.vm.ci\/jdk.vm.ci.hotspot.CompilerToVMHelper sun.hotspot.WhiteBox\n+ * @run driver ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -Xbatch -Xbootclasspath\/a:.\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI\n+ *                   -XX:CompileCommand=exclude,compiler.jvmci.compilerToVM.GetStackFramesTest::check\n+ *                   -XX:CompileCommand=dontinline,compiler.jvmci.compilerToVM.GetStackFramesTest::testFrame\n+ *                   -XX:CompileCommand=dontinline,compiler.jvmci.compilerToVM.GetStackFramesTest::testFrame2\n+ *                   -XX:CompileCommand=inline,compiler.jvmci.compilerToVM.GetStackFramesTest::recurse\n+ *                   -XX:CompileCommand=inline,compiler.jvmci.compilerToVM.GetStackFramesTest::testFrame3\n+ *                   -XX:+DoEscapeAnalysis -XX:-UseCounterDecay\n+ *                   -Dcompiler.jvmci.compilerToVM.GetStackFramesTest.materializeFirst=true\n+ *                   -Dcompiler.jvmci.compilerToVM.GetStackFramesTest.invalidate=false\n+ *                   compiler.jvmci.compilerToVM.GetStackFramesTest\n+ * @run main\/othervm -Xbatch -Xbootclasspath\/a:.\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI\n+ *                   -XX:CompileCommand=exclude,compiler.jvmci.compilerToVM.GetStackFramesTest::check\n+ *                   -XX:CompileCommand=dontinline,compiler.jvmci.compilerToVM.GetStackFramesTest::testFrame\n+ *                   -XX:CompileCommand=dontinline,compiler.jvmci.compilerToVM.GetStackFramesTest::testFrame2\n+ *                   -XX:CompileCommand=inline,compiler.jvmci.compilerToVM.GetStackFramesTest::recurse\n+ *                   -XX:CompileCommand=inline,compiler.jvmci.compilerToVM.GetStackFramesTest::testFrame3\n+ *                   -XX:+DoEscapeAnalysis -XX:-UseCounterDecay\n+ *                   -Dcompiler.jvmci.compilerToVM.GetStackFramesTest.materializeFirst=false\n+ *                   -Dcompiler.jvmci.compilerToVM.GetStackFramesTest.invalidate=false\n+ *                   compiler.jvmci.compilerToVM.GetStackFramesTest\n+ * @run main\/othervm -Xbatch -Xbootclasspath\/a:.\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI\n+ *                   -XX:CompileCommand=exclude,compiler.jvmci.compilerToVM.GetStackFramesTest::check\n+ *                   -XX:CompileCommand=dontinline,compiler.jvmci.compilerToVM.GetStackFramesTest::testFrame\n+ *                   -XX:CompileCommand=dontinline,compiler.jvmci.compilerToVM.GetStackFramesTest::testFrame2\n+ *                   -XX:CompileCommand=inline,compiler.jvmci.compilerToVM.GetStackFramesTest::recurse\n+ *                   -XX:CompileCommand=inline,compiler.jvmci.compilerToVM.GetStackFramesTest::testFrame3\n+ *                   -XX:+DoEscapeAnalysis -XX:-UseCounterDecay\n+ *                   -Dcompiler.jvmci.compilerToVM.GetStackFramesTest.materializeFirst=true\n+ *                   -Dcompiler.jvmci.compilerToVM.GetStackFramesTest.invalidate=true\n+ *                   compiler.jvmci.compilerToVM.GetStackFramesTest\n+ * @run main\/othervm -Xbatch -Xbootclasspath\/a:.\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI\n+ *                   -XX:CompileCommand=exclude,compiler.jvmci.compilerToVM.GetStackFramesTest::check\n+ *                   -XX:CompileCommand=dontinline,compiler.jvmci.compilerToVM.GetStackFramesTest::testFrame\n+ *                   -XX:CompileCommand=dontinline,compiler.jvmci.compilerToVM.GetStackFramesTest::testFrame2\n+ *                   -XX:CompileCommand=inline,compiler.jvmci.compilerToVM.GetStackFramesTest::recurse\n+ *                   -XX:CompileCommand=inline,compiler.jvmci.compilerToVM.GetStackFramesTest::testFrame3\n+ *                   -XX:+DoEscapeAnalysis -XX:-UseCounterDecay\n+ *                   -Dcompiler.jvmci.compilerToVM.GetStackFramesTest.materializeFirst=false\n+ *                   -Dcompiler.jvmci.compilerToVM.GetStackFramesTest.invalidate=true\n+ *                   compiler.jvmci.compilerToVM.GetStackFramesTest\n+ *\/\n+\n+package compiler.jvmci.compilerToVM;\n+\n+import compiler.jvmci.common.CTVMUtilities;\n+import compiler.testlibrary.CompilerUtils;\n+import compiler.whitebox.CompilerWhiteBoxTest;\n+import jdk.test.lib.Asserts;\n+import jdk.vm.ci.code.stack.InspectedFrame;\n+import jdk.vm.ci.hotspot.CompilerToVMHelper;\n+import jdk.vm.ci.hotspot.HotSpotStackFrameReference;\n+import jdk.vm.ci.meta.ResolvedJavaMethod;\n+import jdk.vm.ci.code.stack.InspectedFrame;\n+import jtreg.SkippedException;\n+import sun.hotspot.WhiteBox;\n+\n+import java.lang.reflect.Method;\n+\n+public class GetStackFramesTest {\n+    private static final WhiteBox WB;\n+    private static final boolean INVALIDATE;\n+    private static final int COMPILE_THRESHOLD;\n+    private static final Method MATERIALIZED_METHOD;\n+    private static final Method NOT_MATERIALIZED_METHOD;\n+    private static final Method FRAME3_METHOD;\n+    private static final ResolvedJavaMethod MATERIALIZED_RESOLVED;\n+    private static final ResolvedJavaMethod NOT_MATERIALIZED_RESOLVED;\n+    private static final ResolvedJavaMethod FRAME2_RESOLVED;\n+    private static final ResolvedJavaMethod FRAME3_RESOLVED;\n+    private static final boolean MATERIALIZE_FIRST;\n+\n+    static {\n+        Method method1;\n+        Method method2;\n+        WB = WhiteBox.getWhiteBox();\n+        try {\n+            method1 = GetStackFramesTest.class.getDeclaredMethod(\"testFrame\",\n+                    String.class, int.class);\n+            method2 = GetStackFramesTest.class.getDeclaredMethod(\"testFrame2\",\n+                    String.class, int.class);\n+            FRAME3_METHOD = GetStackFramesTest.class.getDeclaredMethod(\"testFrame3\",\n+                    Helper.class, int.class);\n+        } catch (NoSuchMethodException e) {\n+            throw new Error(\"Can't get executable for test method\", e);\n+        }\n+        ResolvedJavaMethod resolved1;\n+        resolved1 = CTVMUtilities.getResolvedMethod(method1);\n+        FRAME2_RESOLVED = CTVMUtilities.getResolvedMethod(method2);\n+        FRAME3_RESOLVED = CTVMUtilities.getResolvedMethod(FRAME3_METHOD);\n+        INVALIDATE = Boolean.getBoolean(\n+                \"compiler.jvmci.compilerToVM.GetStackFramesTest.invalidate\");\n+        COMPILE_THRESHOLD = WB.getBooleanVMFlag(\"TieredCompilation\")\n+                ? CompilerWhiteBoxTest.THRESHOLD\n+                : CompilerWhiteBoxTest.THRESHOLD * 2;\n+        MATERIALIZE_FIRST = Boolean.getBoolean(\n+                \"compiler.jvmci.compilerToVM.GetStackFramesTest.materializeFirst\");\n+        MATERIALIZED_RESOLVED = MATERIALIZE_FIRST ? resolved1 : FRAME2_RESOLVED;\n+        NOT_MATERIALIZED_RESOLVED = MATERIALIZE_FIRST ? FRAME2_RESOLVED : resolved1;\n+        MATERIALIZED_METHOD = MATERIALIZE_FIRST ? method1 : method2;\n+        NOT_MATERIALIZED_METHOD = MATERIALIZE_FIRST ? method2 : method1;\n+    }\n+\n+    public static void main(String[] args) {\n+        int levels[] = CompilerUtils.getAvailableCompilationLevels();\n+        \/\/ we need compilation level 4 to use EscapeAnalysis\n+        if (levels.length < 1 || levels[levels.length - 1] != 4) {\n+            throw new SkippedException(\"Test needs compilation level 4\");\n+        }\n+\n+        new GetStackFramesTest().test();\n+    }\n+\n+    private static String getName() {\n+        return \"CASE: invalidate=\" + INVALIDATE + \", materializedMethod=\"\n+                + (MATERIALIZE_FIRST ? \"testFrame\" : \"testFrame2\")\n+                + \", notMaterializedMethod=\"\n+                + (MATERIALIZE_FIRST ? \"testFrame2\" : \"testFrame\");\n+    }\n+\n+    private void test() {\n+        System.out.println(getName());\n+        Asserts.assertFalse(WB.isMethodCompiled(MATERIALIZED_METHOD),\n+                getName() + \" : materialized method is compiled\");\n+        Asserts.assertFalse(WB.isMethodCompiled(NOT_MATERIALIZED_METHOD),\n+                getName() + \" : not materialized method is compiled\");\n+        for (int i = 0; i < CompilerWhiteBoxTest.THRESHOLD; i++) {\n+            testFrame(\"someString\", i);\n+        }\n+        Asserts.assertTrue(WB.isMethodCompiled(MATERIALIZED_METHOD), getName()\n+                + \" : materialized method not compiled\");\n+        Asserts.assertTrue(WB.isMethodCompiled(NOT_MATERIALIZED_METHOD),\n+                getName() + \" : not materialized method not compiled\");\n+        testFrame(\"someString\", \/* materialize *\/ CompilerWhiteBoxTest.THRESHOLD);\n+\n+        \/\/ run second test types\n+        for (int i = 0; i < CompilerWhiteBoxTest.THRESHOLD; i++) {\n+            testFrame(\"someString\", i);\n+        }\n+        Asserts.assertTrue(WB.isMethodCompiled(MATERIALIZED_METHOD), getName()\n+                + \" : materialized method not compiled\");\n+        Asserts.assertTrue(WB.isMethodCompiled(NOT_MATERIALIZED_METHOD),\n+                getName() + \" : not materialized method not compiled\");\n+        testFrame(\"someString\", \/* materialize *\/ CompilerWhiteBoxTest.THRESHOLD + 1);\n+    }\n+\n+    private void testFrame(String str, int iteration) {\n+        Helper helper = new Helper(str);\n+        testFrame2(str, iteration);\n+        Asserts.assertTrue((helper.string != null) && (this != null)\n+                && (helper != null), String.format(\"%s : some locals are null\", getName()));\n+    }\n+\n+    private void testFrame2(String str, int iteration) {\n+        Helper helper = new Helper(str);\n+        Helper helper2 = new Helper(\"bar\");\n+        testFrame3(helper, iteration);\n+        Asserts.assertTrue((helper.string != null) && (this != null) && helper.string == str\n+                && (helper != null), String.format(\"%s : some locals are null\", getName()));\n+        Asserts.assertTrue((helper2.string != null) && (this != null)\n+                && (helper2 != null), String.format(\"%s : some locals are null\", getName()));\n+    }\n+\n+    private void testFrame3(Helper outerHelper, int iteration) {\n+        Helper innerHelper = new Helper(\"foo\");\n+        recurse(2, iteration);\n+        Asserts.assertTrue((innerHelper.string != null) && (this != null)\n+                && (innerHelper != null), String.format(\"%s : some locals are null\", getName()));\n+        Asserts.assertTrue((outerHelper.string != null) && (this != null)\n+                && (outerHelper != null), String.format(\"%s : some locals are null\", getName()));\n+    }\n+\n+    private void recurse(int depth, int iteration) {\n+        if (depth == 0) {\n+            check(iteration);\n+        } else {\n+            Integer s = new Integer(depth);\n+            recurse(depth - 1, iteration);\n+            Asserts.assertEQ(s.intValue(), depth,\n+                    String.format(\"different values: %s != %s\", s.intValue(), depth));\n+        }\n+    }\n+\n+    private void checkStructure(boolean materialize) {\n+        boolean[] framesSeen = new boolean[2];\n+        Object[] helpers = new Object[1];\n+\n+        InspectedFrame[] frames = CompilerToVMHelper.getStackFrames(\n+            new ResolvedJavaMethod[] {FRAME3_RESOLVED},\n+            null, \/* any *\/\n+            0,\n+            2, \/\/ fetch only 2 frames\n+            new Thread[] {Thread.currentThread()}\n+        )[0];\n+\n+        for (InspectedFrame f : frames) {\n+            if (!framesSeen[1]) {\n+                Asserts.assertTrue(f.isMethod(FRAME3_RESOLVED),\n+                        \"Expected testFrame3 first\");\n+                framesSeen[1] = true;\n+                Asserts.assertTrue(f.getLocal(0) != null, \"this should not be null\");\n+                Asserts.assertTrue(f.getLocal(1) != null, \"outerHelper should not be null\");\n+                Asserts.assertTrue(f.getLocal(3) != null, \"innerHelper should not be null\");\n+                Asserts.assertEQ(((Helper) f.getLocal(3)).string, \"foo\", \"innerHelper.string should be foo\");\n+                helpers[0] = f.getLocal(1);\n+                if (materialize) {\n+                    f.materializeVirtualObjects(false);\n+                }\n+            } else {\n+                Asserts.assertFalse(framesSeen[0], \"frame3 can not have been seen\");\n+                Asserts.assertTrue(f.isMethod(FRAME2_RESOLVED),\n+                        \"Expected testFrame2 second\");\n+                framesSeen[0] = true;\n+                Asserts.assertTrue(f.getLocal(0) != null, \"this should not be null\");\n+                Asserts.assertTrue(f.getLocal(1) != null, \"str should not be null\");\n+                Asserts.assertTrue(f.getLocal(3) != null, \"helper should not be null\");\n+                Asserts.assertTrue(f.getLocal(4) != null, \"helper2 should not be null\");\n+                Asserts.assertEQ(((Helper) f.getLocal(3)).string, f.getLocal(1), \"helper.string should be the same as str\");\n+                Asserts.assertEQ(((Helper) f.getLocal(4)).string, \"bar\", \"helper2.string should be bar\");\n+                if (!materialize) {\n+                    Asserts.assertEQ(f.getLocal(3), helpers[0], \"helper should be the same as frame3's outerHelper\");\n+                }\n+            }\n+        }\n+\n+        Asserts.assertTrue(framesSeen[1], \"frame3 should have been seen\");\n+        Asserts.assertTrue(framesSeen[0], \"frame2 should have been seen\");\n+    }\n+\n+    private void check(int iteration) {\n+        \/\/ Materialize virtual objects on last invocation\n+        if (iteration == COMPILE_THRESHOLD) {\n+            \/\/ get frames and check not-null\n+            HotSpotStackFrameReference materialized = (HotSpotStackFrameReference) CompilerToVMHelper.getStackFrames(\n+                  new ResolvedJavaMethod[] {MATERIALIZED_RESOLVED},\n+                  null, \/* any *\/\n+                  0,\n+                  1, \/\/ fetch only 1 matching frame\n+                  new Thread[] {Thread.currentThread()}\n+              )[0][0];\n+            Asserts.assertNotNull(materialized, getName()\n+                    + \" : got null frame for materialized method\");\n+            Asserts.assertTrue(materialized.isMethod(MATERIALIZED_RESOLVED),\n+                \"Expected materialized method but got \" + materialized);\n+            InspectedFrame notMaterialized = CompilerToVMHelper.getStackFrames(\n+                  new ResolvedJavaMethod[] {NOT_MATERIALIZED_RESOLVED},\n+                  null, \/* any *\/\n+                  0,\n+                  1, \/\/ fetch only 1 matching frame\n+                  new Thread[] {Thread.currentThread()}\n+              )[0][0];\n+            Asserts.assertNE(materialized, notMaterialized,\n+                    \"Got same frame pointer for both tested frames\");\n+            Asserts.assertTrue(notMaterialized.isMethod(NOT_MATERIALIZED_RESOLVED),\n+                \"Expected notMaterialized method but got \" + notMaterialized);\n+            Asserts.assertNotNull(notMaterialized, getName()\n+                    + \" : got null frame for not materialized method\");\n+            Asserts.assertTrue(WB.isMethodCompiled(MATERIALIZED_METHOD), getName()\n+                + \" : materialized method not compiled\");\n+            Asserts.assertTrue(WB.isMethodCompiled(NOT_MATERIALIZED_METHOD),\n+                getName() + \" : not materialized method not compiled\");\n+            \/\/ check that frames has virtual objects before materialization stage\n+            Asserts.assertTrue(materialized.hasVirtualObjects(), getName()\n+                    + \": materialized frame has no virtual object before materialization\");\n+            Asserts.assertTrue(notMaterialized.hasVirtualObjects(), getName()\n+                    + \": notMaterialized frame has no virtual object before materialization\");\n+            \/\/ materialize\n+            CompilerToVMHelper.materializeVirtualObjects(materialized, INVALIDATE);\n+            \/\/ check that only not materialized frame has virtual objects\n+            Asserts.assertFalse(materialized.hasVirtualObjects(), getName()\n+                    + \" : materialized has virtual object after materialization\");\n+            Asserts.assertTrue(notMaterialized.hasVirtualObjects(), getName()\n+                    + \" : notMaterialized has no virtual object after materialization\");\n+            \/\/ check that materialized frame was deoptimized in case invalidate=true\n+            Asserts.assertEQ(WB.isMethodCompiled(MATERIALIZED_METHOD), !INVALIDATE, getName()\n+                    + \" : materialized method has unexpected compiled status\");\n+            \/\/ check that not materialized frame wasn't deoptimized\n+            Asserts.assertTrue(WB.isMethodCompiled(NOT_MATERIALIZED_METHOD), getName()\n+                    + \" : not materialized method has unexpected compiled status\");\n+        } else if (iteration == COMPILE_THRESHOLD + 1) {\n+            checkStructure(false);\n+            checkStructure(true);\n+        }\n+    }\n+\n+    private class Helper {\n+        public String string;\n+\n+        public Helper(String s) {\n+            this.string = s;\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/compilerToVM\/GetStackFramesTest.java","additions":345,"deletions":0,"binary":false,"changes":345,"status":"added"}]}