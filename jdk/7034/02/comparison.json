{"files":[{"patch":"@@ -2205,1 +2205,1 @@\n-bool ciTypeFlow::clone_loop_heads(Loop* lp, StateVector* temp_vector, JsrSet* temp_set) {\n+bool ciTypeFlow::clone_loop_heads(StateVector* temp_vector, JsrSet* temp_set) {\n@@ -2208,1 +2208,1 @@\n-    lp = iter.current();\n+    Loop* lp = iter.current();\n@@ -2453,0 +2453,70 @@\n+\/\/ If the tail is a branch to the head, retrieve how many times that path was taken from profiling\n+static int profiled_count(ciMethod* m, ciTypeFlow::Loop* loop) {\n+  ciMethodData* methodData = m->method_data();\n+  if (!methodData->is_mature()) {\n+    return 0;\n+  }\n+  ciTypeFlow::Block* tail = loop->tail();\n+  if (tail->control() == -1) {\n+    return 0;\n+  }\n+\n+  ciProfileData* data = methodData->bci_to_data(tail->control());\n+  assert(data != NULL, \"some profile data expected at branch\");\n+\n+  if (!data->is_JumpData()) {\n+    return 0;\n+  }\n+\n+  ciBytecodeStream iter(m);\n+  iter.reset_to_bci(tail->control());\n+\n+  bool is_an_if = false;\n+  switch (iter.next()) {\n+    case Bytecodes::_ifeq:\n+    case Bytecodes::_ifne:\n+    case Bytecodes::_iflt:\n+    case Bytecodes::_ifge:\n+    case Bytecodes::_ifgt:\n+    case Bytecodes::_ifle:\n+    case Bytecodes::_if_icmpeq:\n+    case Bytecodes::_if_icmpne:\n+    case Bytecodes::_if_icmplt:\n+    case Bytecodes::_if_icmpge:\n+    case Bytecodes::_if_icmpgt:\n+    case Bytecodes::_if_icmple:\n+    case Bytecodes::_if_acmpeq:\n+    case Bytecodes::_if_acmpne:\n+    case Bytecodes::_ifnull:\n+    case Bytecodes::_ifnonnull:\n+      is_an_if = true;\n+      break;\n+    case Bytecodes::_goto:\n+    case Bytecodes::_goto_w:\n+    case Bytecodes::_jsr:\n+    case Bytecodes::_jsr_w:\n+      break;\n+    default:\n+      fatal(\" invalid bytecode: %s\", Bytecodes::name(iter.cur_bc()));\n+  }\n+\n+  GrowableArray<ciTypeFlow::Block*>* succs = tail->successors();\n+\n+  if (!is_an_if) {\n+    assert((iter.get_dest() == loop->head()->start()) == (succs->at(ciTypeFlow::GOTO_TARGET) == loop->head()), \"branch should lead to loop head\");\n+    if (succs->at(ciTypeFlow::GOTO_TARGET) == loop->head()) {\n+      return m->scale_count(data->as_JumpData()->taken());\n+    }\n+  } else {\n+    assert((iter.get_dest() == loop->head()->start()) == (succs->at(ciTypeFlow::IF_TAKEN) == loop->head()), \"bytecode and CFG not consistent\");\n+    assert((succs->at(ciTypeFlow::IF_NOT_TAKEN) == loop->head()) == (tail->limit() == loop->head()->start()), \"bytecode and CFG not consistent\");\n+    if (succs->at(ciTypeFlow::IF_TAKEN) == loop->head()) {\n+      return m->scale_count(data->as_JumpData()->taken());\n+    } else if (succs->at(ciTypeFlow::IF_NOT_TAKEN) == loop->head()) {\n+      return m->scale_count(data->as_BranchData()->not_taken());\n+    }\n+  }\n+\n+  return 0;\n+}\n+\n@@ -2462,1 +2532,1 @@\n-ciTypeFlow::Loop* ciTypeFlow::Loop::sorted_merge(Loop* lp) {\n+ciTypeFlow::Loop* ciTypeFlow::Loop::sorted_merge(Loop* lp, ciMethod* method) {\n@@ -2468,0 +2538,1 @@\n+    int lp_count = profiled_count(method, lp);\n@@ -2470,1 +2541,1 @@\n-      if (current == lp)\n+      if (current == lp) {\n@@ -2472,1 +2543,7 @@\n-      if (current->head()->pre_order() < lp_pre_order)\n+      }\n+      if (current->head()->pre_order() < lp_pre_order) {\n+        break;\n+      }\n+      int current_count = profiled_count(method, current);\n+      \/\/ In the case of a shared head, make the most frequent head\/tail (as reported by profiling) the inner loop\n+      if (current->head() == lp->head() && current_count < lp_count) {\n@@ -2474,2 +2551,3 @@\n-      if (current->head()->pre_order() == lp_pre_order &&\n-          current->tail()->pre_order() > lp->tail()->pre_order()) {\n+      } else if (current->head()->pre_order() == lp_pre_order &&\n+                 (current->head() != lp->head() || current_count == lp_count) &&\n+                 current->tail()->pre_order() > lp->tail()->pre_order()) {\n@@ -2549,1 +2627,1 @@\n-    innermost = innermost == NULL ? lp : innermost->sorted_merge(lp);\n+    innermost = innermost == NULL ? lp : innermost->sorted_merge(lp, method());\n@@ -2735,1 +2813,1 @@\n-    bool changed = clone_loop_heads(loop_tree_root(), temp_vector, temp_set);\n+    bool changed = clone_loop_heads(temp_vector, temp_set);\n","filename":"src\/hotspot\/share\/ci\/ciTypeFlow.cpp","additions":87,"deletions":9,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -749,1 +749,1 @@\n-    Loop* sorted_merge(Loop* lp);\n+    Loop* sorted_merge(Loop* lp, ciMethod* method);\n@@ -798,1 +798,1 @@\n-  bool clone_loop_heads(Loop* lp, StateVector* temp_vector, JsrSet* temp_set);\n+  bool clone_loop_heads(StateVector* temp_vector, JsrSet* temp_set);\n","filename":"src\/hotspot\/share\/ci\/ciTypeFlow.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2022, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Mode;\n+import java.util.concurrent.TimeUnit;\n+\n+@State(Scope.Thread)\n+public class SharedLoopHeader {\n+\n+    private static final int size = 1000;\n+    private static final boolean branch[] = new boolean[size];\n+    private static final int count[] = new int[size];\n+\n+    @Setup\n+    public void setup() {\n+        for (int i = 0; i < branch.length; i++) {\n+            branch[i] = ((i % 10) != 0);\n+        }\n+    }\n+\n+    @Benchmark\n+    @BenchmarkMode(Mode.AverageTime)\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public void sharedHeader() {\n+        int i = 0;\n+        while (i < branch.length) {\n+            if (branch[i]) {\n+                \/\/ common branch\n+                count[i]++;\n+                i++;\n+                continue;\n+            }\n+            i += 2;\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/SharedLoopHeader.java","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2022, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.Setup;\n+import java.util.concurrent.TimeUnit;\n+import java.nio.charset.StandardCharsets;\n+\n+@State(Scope.Thread)\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+public class StringConstructorBenchmark {\n+  private byte[] array;\n+  private String str;\n+\n+  @Setup\n+  public void setup() {\n+    str = \"Quizdeltagerne spiste jordb\\u00e6r med fl\\u00f8de, mens cirkusklovnen. \\u042f\";\/\/Latin1 ending with Russian\n+    array = str.getBytes(StandardCharsets.UTF_8);\n+  }\n+\n+  @Benchmark\n+  public String newString()  {\n+      return new String(array, 0, array.length, StandardCharsets.UTF_8);\n+  }\n+\n+  @Benchmark\n+  public String translateEscapes()  {\n+      return str.translateEscapes();\n+  }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/StringConstructorBenchmark.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"}]}