{"files":[{"patch":"@@ -2205,1 +2205,1 @@\n-bool ciTypeFlow::clone_loop_heads(Loop* lp, StateVector* temp_vector, JsrSet* temp_set) {\n+bool ciTypeFlow::clone_loop_heads(StateVector* temp_vector, JsrSet* temp_set) {\n@@ -2208,1 +2208,1 @@\n-    lp = iter.current();\n+    Loop* lp = iter.current();\n@@ -2453,0 +2453,67 @@\n+\/\/ If the tail is a branch to the head, retrieve how many times that path was taken from profiling\n+static int profiled_count(ciMethod* m, ciTypeFlow::Loop* loop) {\n+  ciMethodData* methodData = m->method_data();\n+  if (!methodData->is_mature()) {\n+    return 0;\n+  }\n+  ciTypeFlow::Block* tail = loop->tail();\n+  if (tail->control() == -1) {\n+    return 0;\n+  }\n+\n+  ciProfileData* data = methodData->bci_to_data(tail->control());\n+  assert(data != NULL, \"some profile data expected at branch\");\n+\n+  if (!data->is_JumpData()) {\n+    return 0;\n+  }\n+\n+  ciBytecodeStream iter(m);\n+  iter.reset_to_bci(tail->control());\n+\n+  bool is_an_if = false;\n+  switch (iter.next()) {\n+    case Bytecodes::_ifeq:\n+    case Bytecodes::_ifne:\n+    case Bytecodes::_iflt:\n+    case Bytecodes::_ifge:\n+    case Bytecodes::_ifgt:\n+    case Bytecodes::_ifle:\n+    case Bytecodes::_if_icmpeq:\n+    case Bytecodes::_if_icmpne:\n+    case Bytecodes::_if_icmplt:\n+    case Bytecodes::_if_icmpge:\n+    case Bytecodes::_if_icmpgt:\n+    case Bytecodes::_if_icmple:\n+    case Bytecodes::_if_acmpeq:\n+    case Bytecodes::_if_acmpne:\n+    case Bytecodes::_ifnull:\n+    case Bytecodes::_ifnonnull:\n+      is_an_if = true;\n+      break;\n+    case Bytecodes::_goto:\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+  }\n+\n+  GrowableArray<ciTypeFlow::Block*>* succs = tail->successors();\n+\n+  if (!is_an_if) {\n+    assert((iter.get_dest() == loop->head()->start()) == (succs->at(ciTypeFlow::GOTO_TARGET) == loop->head()), \"branch should lead to loop head\");\n+    if (succs->at(ciTypeFlow::GOTO_TARGET) == loop->head()) {\n+      return m->scale_count(data->as_JumpData()->taken());\n+    }\n+  } else {\n+    assert((iter.get_dest() == loop->head()->start()) == (succs->at(ciTypeFlow::IF_TAKEN) == loop->head()), \"bytecode and CFG not consistent\");\n+    assert((succs->at(ciTypeFlow::IF_NOT_TAKEN) == loop->head()) == (tail->limit() == loop->head()->start()), \"bytecode and CFG not consistent\");\n+    if (succs->at(ciTypeFlow::IF_TAKEN) == loop->head()) {\n+      return m->scale_count(data->as_JumpData()->taken());\n+    } else if (succs->at(ciTypeFlow::IF_NOT_TAKEN) == loop->head()) {\n+      return m->scale_count(data->as_BranchData()->not_taken());\n+    }\n+  }\n+\n+  return 0;\n+}\n+\n@@ -2462,1 +2529,1 @@\n-ciTypeFlow::Loop* ciTypeFlow::Loop::sorted_merge(Loop* lp) {\n+ciTypeFlow::Loop* ciTypeFlow::Loop::sorted_merge(Loop* lp, ciMethod* method) {\n@@ -2468,0 +2535,1 @@\n+    int lp_count = profiled_count(method, lp);\n@@ -2470,1 +2538,1 @@\n-      if (current == lp)\n+      if (current == lp) {\n@@ -2472,1 +2540,7 @@\n-      if (current->head()->pre_order() < lp_pre_order)\n+      }\n+      if (current->head()->pre_order() < lp_pre_order) {\n+        break;\n+      }\n+      int current_count = profiled_count(method, current);\n+      \/\/ In the case of a shared head, make the most frequent head\/tail (as reported by profiling) the inner loop\n+      if (current->head() == lp->head() && current_count < lp_count) {\n@@ -2474,2 +2548,3 @@\n-      if (current->head()->pre_order() == lp_pre_order &&\n-          current->tail()->pre_order() > lp->tail()->pre_order()) {\n+      } else if (current->head()->pre_order() == lp_pre_order &&\n+                 (current->head() != lp->head() || current_count == lp_count) &&\n+                 current->tail()->pre_order() > lp->tail()->pre_order()) {\n@@ -2549,1 +2624,1 @@\n-    innermost = innermost == NULL ? lp : innermost->sorted_merge(lp);\n+    innermost = innermost == NULL ? lp : innermost->sorted_merge(lp, method());\n@@ -2735,1 +2810,1 @@\n-    bool changed = clone_loop_heads(loop_tree_root(), temp_vector, temp_set);\n+    bool changed = clone_loop_heads(temp_vector, temp_set);\n","filename":"src\/hotspot\/share\/ci\/ciTypeFlow.cpp","additions":84,"deletions":9,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -749,1 +749,1 @@\n-    Loop* sorted_merge(Loop* lp);\n+    Loop* sorted_merge(Loop* lp, ciMethod* method);\n@@ -798,1 +798,1 @@\n-  bool clone_loop_heads(Loop* lp, StateVector* temp_vector, JsrSet* temp_set);\n+  bool clone_loop_heads(StateVector* temp_vector, JsrSet* temp_set);\n","filename":"src\/hotspot\/share\/ci\/ciTypeFlow.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}