{"files":[{"patch":"@@ -129,1 +129,1 @@\n-private:\n+\n@@ -131,1 +131,1 @@\n-  typedef Symbol* Value;  \/\/ value of the Node in the hashtable\n+  typedef Symbol Value;  \/\/ value of the Node in the hashtable\n@@ -134,1 +134,1 @@\n-    *is_dead = (value->refcount() == 0);\n+    *is_dead = (value.refcount() == 0);\n@@ -138,1 +138,1 @@\n-      return hash_symbol((const char*)value->bytes(), value->utf8_length(), _alt_hash);\n+      return hash_symbol((const char*)value.bytes(), value.utf8_length(), _alt_hash);\n@@ -144,1 +144,1 @@\n-    return AllocateHeap(size, mtSymbol);\n+    return allocate_node_impl(size, value);\n@@ -146,1 +146,1 @@\n-  static void free_node(void* context, void* memory, Value const& value) {\n+  static void free_node(void* context, void* memory, Value & value) {\n@@ -152,5 +152,23 @@\n-    assert(value->is_permanent() || (value->refcount() == 1) || (value->refcount() == 0),\n-           \"refcount %d\", value->refcount());\n-    if (value->refcount() == 1) {\n-      value->decrement_refcount();\n-      assert(value->refcount() == 0, \"expected dead symbol\");\n+    assert(value.is_permanent() || (value.refcount() == 1) || (value.refcount() == 0),\n+           \"refcount %d\", value.refcount());\n+#if INCLUDE_CDS\n+    if (DumpSharedSpaces) {\n+      \/\/ no deallocation is needed\n+      return;\n+    }\n+#endif\n+    if (value.refcount() == 1) {\n+      value.decrement_refcount();\n+      assert(value.refcount() == 0, \"expected dead symbol\");\n+    }\n+    if (value.refcount() != PERM_REFCOUNT) {\n+      FreeHeap(memory);\n+    } else {\n+      MutexLocker ml(SymbolArena_lock, Mutex::_no_safepoint_check_flag); \/\/ Protect arena\n+      \/\/ Deleting permanent symbol should not occur very often (insert race condition),\n+      \/\/ so log it.\n+      log_trace_symboltable_helper(&value, \"Freeing permanent symbol\");\n+      size_t alloc_size = _local_table->get_node_size() + value.byte_size() + value.effective_length();\n+      if (!SymbolTable::arena()->Afree(memory, alloc_size)) {\n+        log_trace_symboltable_helper(&value, \"Leaked permanent symbol\");\n+      }\n@@ -158,2 +176,0 @@\n-    SymbolTable::delete_symbol(value);\n-    FreeHeap(memory);\n@@ -162,0 +178,29 @@\n+\n+private:\n+  static void* allocate_node_impl(size_t size, Value const& value) {\n+    size_t alloc_size = size + value.byte_size() + value.effective_length();\n+#if INCLUDE_CDS\n+    if (DumpSharedSpaces) {\n+      MutexLocker ml(DumpRegion_lock, Mutex::_no_safepoint_check_flag);\n+      \/\/ To get deterministic output from -Xshare:dump, we ensure that Symbols are allocated in\n+      \/\/ increasing addresses. When the symbols are copied into the archive, we preserve their\n+      \/\/ relative address order (sorted, see ArchiveBuilder::gather_klasses_and_symbols).\n+      \/\/\n+      \/\/ We cannot use arena because arena chunks are allocated by the OS. As a result, for example,\n+      \/\/ the archived symbol of \"java\/lang\/Object\" may sometimes be lower than \"java\/lang\/String\", and\n+      \/\/ sometimes be higher. This would cause non-deterministic contents in the archive.\n+      DEBUG_ONLY(static void* last = 0);\n+      void* p = (void*)MetaspaceShared::symbol_space_alloc(alloc_size);\n+      assert(p > last, \"must increase monotonically\");\n+      DEBUG_ONLY(last = p);\n+      return p;\n+    }\n+#endif\n+    if (value.refcount() != PERM_REFCOUNT) {\n+      return AllocateHeap(alloc_size, mtSymbol);\n+    } else {\n+      \/\/ Allocate to global arena\n+      MutexLocker ml(SymbolArena_lock, Mutex::_no_safepoint_check_flag); \/\/ Protect arena\n+      return SymbolTable::arena()->Amalloc(alloc_size);\n+    }\n+  }\n@@ -179,14 +224,0 @@\n-void SymbolTable::delete_symbol(Symbol* sym) {\n-  if (sym->is_permanent()) {\n-    MutexLocker ml(SymbolArena_lock, Mutex::_no_safepoint_check_flag); \/\/ Protect arena\n-    \/\/ Deleting permanent symbol should not occur very often (insert race condition),\n-    \/\/ so log it.\n-    log_trace_symboltable_helper(sym, \"Freeing permanent symbol\");\n-    if (!arena()->Afree(sym, sym->size())) {\n-      log_trace_symboltable_helper(sym, \"Leaked permanent symbol\");\n-    }\n-  } else {\n-    delete sym;\n-  }\n-}\n-\n@@ -220,25 +251,0 @@\n-Symbol* SymbolTable::allocate_symbol(const char* name, int len, bool c_heap) {\n-  assert (len <= Symbol::max_length(), \"should be checked by caller\");\n-\n-  Symbol* sym;\n-  if (DumpSharedSpaces) {\n-    \/\/ TODO: Special handling of Symbol allocation for DumpSharedSpaces will be removed\n-    \/\/ in JDK-8250989\n-    c_heap = false;\n-  }\n-  if (c_heap) {\n-    \/\/ refcount starts as 1\n-    sym = new (len) Symbol((const u1*)name, len, 1);\n-    assert(sym != nullptr, \"new should call vm_exit_out_of_memory if C_HEAP is exhausted\");\n-  } else if (DumpSharedSpaces) {\n-    \/\/ See comments inside Symbol::operator new(size_t, int)\n-    sym = new (len) Symbol((const u1*)name, len, PERM_REFCOUNT);\n-    assert(sym != nullptr, \"new should call vm_exit_out_of_memory if failed to allocate symbol during DumpSharedSpaces\");\n-  } else {\n-    \/\/ Allocate to global arena\n-    MutexLocker ml(SymbolArena_lock, Mutex::_no_safepoint_check_flag); \/\/ Protect arena\n-    sym = new (len, arena()) Symbol((const u1*)name, len, PERM_REFCOUNT);\n-  }\n-  return sym;\n-}\n-\n@@ -249,1 +255,1 @@\n-  bool operator()(Symbol** value) {\n+  bool operator()(Symbol* value) {\n@@ -251,2 +257,1 @@\n-    assert(*value != nullptr, \"value should point to a symbol\");\n-    _cl->do_symbol(value);\n+    _cl->do_symbol(&value);\n@@ -337,1 +342,1 @@\n-    sym = do_add_if_needed(name, len, hash, true);\n+    sym = do_add_if_needed(name, len, hash, \/* is_permanent *\/ false);\n@@ -352,1 +357,1 @@\n-    found = do_add_if_needed(name, len, hash, true);\n+    found = do_add_if_needed(name, len, hash, \/* is_permanent *\/ false);\n@@ -368,1 +373,1 @@\n-  bool equals(Symbol** value, bool* is_dead) {\n+  bool equals(Symbol* value, bool* is_dead) {\n@@ -370,2 +375,1 @@\n-    assert(*value != nullptr, \"value should point to a symbol\");\n-    Symbol *sym = *value;\n+    Symbol *sym = value;\n@@ -392,1 +396,1 @@\n-  void operator()(Symbol** value) {\n+  void operator()(Symbol* value) {\n@@ -394,2 +398,1 @@\n-    assert(*value != nullptr, \"value should point to a symbol\");\n-    _return = *value;\n+    _return = value;\n@@ -456,1 +459,1 @@\n-  \/\/ Note that c_heap will be true for non-strong hidden classes.\n+  \/\/ Note that is_permanent will be false for non-strong hidden classes.\n@@ -458,1 +461,1 @@\n-  bool c_heap = !loader_data->is_the_null_class_loader_data();\n+  bool is_permanent = loader_data->is_the_null_class_loader_data();\n@@ -464,1 +467,1 @@\n-    Symbol* sym = do_add_if_needed(name, len, hash, c_heap);\n+    Symbol* sym = do_add_if_needed(name, len, hash, is_permanent);\n@@ -470,1 +473,1 @@\n-Symbol* SymbolTable::do_add_if_needed(const char* name, int len, uintx hash, bool heap) {\n+Symbol* SymbolTable::do_add_if_needed(const char* name, int len, uintx hash, bool is_permanent) {\n@@ -475,1 +478,0 @@\n-  Symbol* sym = nullptr;\n@@ -477,0 +479,7 @@\n+  Symbol* sym;\n+\n+  ResourceMark rm(current);\n+  const int alloc_size = Symbol::byte_size(len);\n+  u1* u1_buf = NEW_RESOURCE_ARRAY_IN_THREAD(current, u1, alloc_size);\n+  Symbol* tmp = ::new ((void*)u1_buf) Symbol((const u1*)name, len,\n+                                             (is_permanent || DumpSharedSpaces) ? PERM_REFCOUNT : 1);\n@@ -479,4 +488,10 @@\n-    \/\/ Callers have looked up the symbol once, insert the symbol.\n-    sym = allocate_symbol(name, len, heap);\n-    if (_local_table->insert(current, lookup, sym, &rehash_warning, &clean_hint)) {\n-      break;\n+    if (_local_table->insert(current, lookup, *tmp, &rehash_warning, &clean_hint)) {\n+      if (_local_table->get(current, lookup, stg, &rehash_warning)) {\n+        sym = stg.get_res_sym();\n+        \/\/ The get adds one to ref count, but we inserted with our ref already included.\n+        \/\/ Therefore decrement with one.\n+        if (sym->refcount() != PERM_REFCOUNT) {\n+          sym->decrement_refcount();\n+        }\n+        break;\n+      }\n@@ -484,0 +499,1 @@\n+\n@@ -487,0 +503,1 @@\n+      \/\/ The lookup added a refcount, which is ours.\n@@ -508,1 +525,1 @@\n-    sym = do_add_if_needed(name, len, hash, false);\n+    sym = do_add_if_needed(name, len, hash, \/* is_permanent *\/ true);\n@@ -518,1 +535,1 @@\n-  size_t operator()(Symbol** value) {\n+  size_t operator()(Symbol* value) {\n@@ -520,2 +537,1 @@\n-    assert(*value != nullptr, \"value should point to a symbol\");\n-    return (*value)->size() * HeapWordSize;\n+    return (value)->size() * HeapWordSize;\n@@ -548,1 +564,1 @@\n-  bool operator()(Symbol** value) {\n+  bool operator()(Symbol* value) {\n@@ -550,2 +566,1 @@\n-    guarantee(*value != nullptr, \"value should point to a symbol\");\n-    Symbol* sym = *value;\n+    Symbol* sym = value;\n@@ -580,1 +595,1 @@\n-  bool operator()(Symbol** value) {\n+  bool operator()(Symbol* value) {\n@@ -582,2 +597,1 @@\n-    assert(*value != nullptr, \"value should point to a symbol\");\n-    print_symbol(_st, *value);\n+    print_symbol(_st, value);\n@@ -698,1 +712,1 @@\n-  void operator()(Symbol** value) {\n+  void operator()(Symbol* value) {\n@@ -700,2 +714,1 @@\n-    assert(*value != nullptr, \"value should point to a symbol\");\n-    Symbol *sym = *value;\n+    Symbol *sym = value;\n@@ -710,1 +723,1 @@\n-  bool operator()(Symbol** value) {\n+  bool operator()(Symbol* value) {\n@@ -712,1 +725,0 @@\n-    assert(*value != nullptr, \"value should point to a symbol\");\n@@ -714,1 +726,1 @@\n-    Symbol *sym = *value;\n+    Symbol *sym = value;\n@@ -852,1 +864,1 @@\n-  bool operator()(Symbol** value) {\n+  bool operator()(Symbol* value) {\n@@ -854,2 +866,1 @@\n-    assert(*value != nullptr, \"value should point to a symbol\");\n-    Symbol* sym = *value;\n+    Symbol* sym = value;\n","filename":"src\/hotspot\/share\/classfile\/symbolTable.cpp","additions":102,"deletions":91,"binary":false,"changes":193,"status":"modified"},{"patch":"@@ -62,1 +62,0 @@\n-  static void delete_symbol(Symbol* sym);\n@@ -78,1 +77,0 @@\n-  static Symbol* allocate_symbol(const char* name, int len, bool c_heap); \/\/ Assumes no characters larger than 0x7F\n@@ -80,1 +78,1 @@\n-  static Symbol* do_add_if_needed(const char* name, int len, uintx hash, bool heap);\n+  static Symbol* do_add_if_needed(const char* name, int len, uintx hash, bool is_permanent);\n","filename":"src\/hotspot\/share\/classfile\/symbolTable.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -68,32 +68,5 @@\n-void* Symbol::operator new(size_t sz, int len) throw() {\n-#if INCLUDE_CDS\n- if (DumpSharedSpaces) {\n-   MutexLocker ml(DumpRegion_lock, Mutex::_no_safepoint_check_flag);\n-   \/\/ To get deterministic output from -Xshare:dump, we ensure that Symbols are allocated in\n-   \/\/ increasing addresses. When the symbols are copied into the archive, we preserve their\n-   \/\/ relative address order (sorted, see ArchiveBuilder::gather_klasses_and_symbols).\n-   \/\/\n-   \/\/ We cannot use arena because arena chunks are allocated by the OS. As a result, for example,\n-   \/\/ the archived symbol of \"java\/lang\/Object\" may sometimes be lower than \"java\/lang\/String\", and\n-   \/\/ sometimes be higher. This would cause non-deterministic contents in the archive.\n-   DEBUG_ONLY(static void* last = 0);\n-   void* p = (void*)MetaspaceShared::symbol_space_alloc(size(len)*wordSize);\n-   assert(p > last, \"must increase monotonically\");\n-   DEBUG_ONLY(last = p);\n-   return p;\n- }\n-#endif\n-  int alloc_size = size(len)*wordSize;\n-  address res = (address) AllocateHeap(alloc_size, mtSymbol);\n-  return res;\n-}\n-\n-void* Symbol::operator new(size_t sz, int len, Arena* arena) throw() {\n-  int alloc_size = size(len)*wordSize;\n-  address res = (address)arena->AmallocWords(alloc_size);\n-  return res;\n-}\n-\n-void Symbol::operator delete(void *p) {\n-  assert(((Symbol*)p)->refcount() == 0, \"should not call this\");\n-  FreeHeap(p);\n+\/\/ This copies the symbol when it is added to the ConcurrentHashTable.\n+Symbol::Symbol(const Symbol& s1) {\n+  _hash_and_refcount = s1._hash_and_refcount;\n+  _length = s1._length;\n+  memcpy(_body, s1._body, _length);\n","filename":"src\/hotspot\/share\/oops\/symbol.cpp","additions":5,"deletions":32,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -134,4 +134,0 @@\n-  void* operator new(size_t size, int len) throw();\n-  void* operator new(size_t size, int len, Arena* arena) throw();\n-\n-  void  operator delete(void* p);\n@@ -146,0 +142,2 @@\n+  Symbol(const Symbol& s1);\n+\n@@ -149,2 +147,4 @@\n-  int size()                { return size(utf8_length()); }\n-  int byte_size()           { return byte_size(utf8_length()); }\n+  int size()      const     { return size(utf8_length()); }\n+  int byte_size() const     { return byte_size(utf8_length()); };\n+  \/\/ length without the _body\n+  size_t effective_length() const { return (size_t)byte_size() - sizeof(Symbol); }\n","filename":"src\/hotspot\/share\/oops\/symbol.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"}]}