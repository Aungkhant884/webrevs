{"files":[{"patch":"@@ -210,1 +210,2 @@\n-  case vmIntrinsics::_checkIndex:\n+  case vmIntrinsics::_Preconditions_checkIndex:\n+  case vmIntrinsics::_Preconditions_checkLongIndex:\n","filename":"src\/hotspot\/share\/c1\/c1_Compiler.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -488,16 +488,0 @@\n-\n-void LIRGenerator::nio_range_check(LIR_Opr buffer, LIR_Opr index, LIR_Opr result, CodeEmitInfo* info) {\n-  CodeStub* stub = new RangeCheckStub(info, index);\n-  if (index->is_constant()) {\n-    cmp_mem_int(lir_cond_belowEqual, buffer, java_nio_Buffer::limit_offset(), index->as_jint(), info);\n-    __ branch(lir_cond_belowEqual, stub); \/\/ forward branch\n-  } else {\n-    cmp_reg_mem(lir_cond_aboveEqual, index, buffer,\n-                java_nio_Buffer::limit_offset(), T_INT, info);\n-    __ branch(lir_cond_aboveEqual, stub); \/\/ forward branch\n-  }\n-  __ move(index, result);\n-}\n-\n-\n-\n@@ -1862,0 +1846,6 @@\n+\/\/ int\/long jdk.internal.util.Preconditions.checkIndex\n+void LIRGenerator::do_PreconditionsCheckIndex(Intrinsic* x, BasicType type) {\n+  assert(x->number_of_arguments() == 3, \"wrong type\");\n+  LIRItem index(x->argument_at(0), this);\n+  LIRItem length(x->argument_at(1), this);\n+  LIRItem oobef(x->argument_at(2), this);\n@@ -1863,11 +1853,0 @@\n-\/\/------------------------java.nio.Buffer.checkIndex------------------------\n-\n-\/\/ int java.nio.Buffer.checkIndex(int)\n-void LIRGenerator::do_NIOCheckIndex(Intrinsic* x) {\n-  \/\/ NOTE: by the time we are in checkIndex() we are guaranteed that\n-  \/\/ the buffer is non-null (because checkIndex is package-private and\n-  \/\/ only called from within other methods in the buffer).\n-  assert(x->number_of_arguments() == 2, \"wrong type\");\n-  LIRItem buf  (x->argument_at(0), this);\n-  LIRItem index(x->argument_at(1), this);\n-  buf.load_item();\n@@ -1875,0 +1854,2 @@\n+  length.load_item();\n+  oobef.load_item();\n@@ -1877,6 +1858,25 @@\n-  if (GenerateRangeChecks) {\n-    CodeEmitInfo* info = state_for(x);\n-    CodeStub* stub = new RangeCheckStub(info, index.result());\n-    if (index.result()->is_constant()) {\n-      cmp_mem_int(lir_cond_belowEqual, buf.result(), java_nio_Buffer::limit_offset(), index.result()->as_jint(), info);\n-      __ branch(lir_cond_belowEqual, stub);\n+  \/\/ x->state() is created from copy_state_for_exception, it does not contains arguments\n+  \/\/ we should prepare them before entering into interpreter mode due to deoptimization.\n+  ValueStack* state = x->state();\n+  for (int i = 0; i < x->number_of_arguments(); i++) {\n+    Value arg = x->argument_at(i);\n+    state->push(arg->type(), arg);\n+  }\n+  CodeEmitInfo* info = state_for(x, state);\n+  CodeStub* deopt = new DeoptimizeStub(info, Deoptimization::Reason_range_check,\n+                                       Deoptimization::Action_make_not_entrant);\n+\n+  if (length.result()->is_constant()) {\n+#if defined(X86) && !defined(_LP64)\n+    \/\/ BEWARE! On 32-bit x86 cmp clobbers its left argument so we need a temp copy.\n+    LIR_Opr index_copy = new_register(index.type());\n+    __ move(index.result(), index_copy);\n+    if (type == T_INT) {\n+      __ cmp(lir_cond_aboveEqual, index_copy, LIR_OprFact::intConst(length.result()->as_jint()));\n+    } else {\n+      assert(type == T_LONG, \"sanity check\");\n+      __ cmp(lir_cond_aboveEqual, index_copy, LIR_OprFact::longConst(length.result()->as_jlong()));\n+    }\n+#else\n+    if (type == T_INT) {\n+      __ cmp(lir_cond_aboveEqual, index.result(), LIR_OprFact::intConst(length.result()->as_jint()));\n@@ -1884,3 +1884,2 @@\n-      cmp_reg_mem(lir_cond_aboveEqual, index.result(), buf.result(),\n-                  java_nio_Buffer::limit_offset(), T_INT, info);\n-      __ branch(lir_cond_aboveEqual, stub);\n+      assert(type == T_LONG, \"sanity check\");\n+      __ cmp(lir_cond_aboveEqual, index.result(), LIR_OprFact::longConst(length.result()->as_jlong()));\n@@ -1888,1 +1887,2 @@\n-    __ move(index.result(), result);\n+#endif\n+    __ branch(lir_cond_aboveEqual, deopt);\n@@ -1890,2 +1890,9 @@\n-    \/\/ Just load the index into the result register\n-    __ move(index.result(), result);\n+#if defined(X86) && !defined(_LP64)\n+    \/\/ BEWARE! On 32-bit x86 cmp clobbers its left argument so we need a temp copy.\n+    LIR_Opr index_copy = new_register(index.type());\n+    __ move(index.result(), index_copy);\n+    __ cmp(lir_cond_aboveEqual, index_copy, length.result());\n+#else\n+    __ cmp(lir_cond_aboveEqual, index.result(), length.result());\n+#endif\n+    __ branch(lir_cond_aboveEqual, deopt);\n@@ -1893,0 +1900,1 @@\n+  __ move(index.result(), result);\n@@ -1895,1 +1903,0 @@\n-\n@@ -3118,2 +3125,6 @@\n-  \/\/ java.nio.Buffer.checkIndex\n-  case vmIntrinsics::_checkIndex:     do_NIOCheckIndex(x); break;\n+  case vmIntrinsics::_Preconditions_checkIndex:\n+    do_PreconditionsCheckIndex(x, T_INT);\n+    break;\n+  case vmIntrinsics::_Preconditions_checkLongIndex:\n+    do_PreconditionsCheckIndex(x, T_LONG);\n+    break;\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":53,"deletions":42,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -263,1 +263,1 @@\n-  void do_NIOCheckIndex(Intrinsic* x);\n+  void do_PreconditionsCheckIndex(Intrinsic* x, BasicType type);\n@@ -351,2 +351,0 @@\n-  \/\/ For java.nio.Buffer.checkIndex\n-  void nio_range_check            (LIR_Opr buffer, LIR_Opr index, LIR_Opr result, CodeEmitInfo* info);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -156,3 +156,0 @@\n-  product(bool, InlineNIOCheckIndex, true, DIAGNOSTIC,                      \\\n-          \"Intrinsify java.nio.Buffer.checkIndex\")                          \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/c1\/c1_globals.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -4656,20 +4656,0 @@\n-\n-\/\/ Support for intrinsification of java.nio.Buffer.checkIndex\n-\n-int java_nio_Buffer::_limit_offset;\n-\n-#define BUFFER_FIELDS_DO(macro) \\\n-  macro(_limit_offset, k, \"limit\", int_signature, false)\n-\n-void java_nio_Buffer::compute_offsets() {\n-  InstanceKlass* k = vmClasses::nio_Buffer_klass();\n-  assert(k != NULL, \"must be loaded in 1.4+\");\n-  BUFFER_FIELDS_DO(FIELD_COMPUTE_OFFSET);\n-}\n-\n-#if INCLUDE_CDS\n-void java_nio_Buffer::serialize_offsets(SerializeClosure* f) {\n-  BUFFER_FIELDS_DO(FIELD_SERIALIZE_OFFSET);\n-}\n-#endif\n-\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":0,"deletions":20,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -69,1 +69,0 @@\n-  f(java_nio_Buffer) \\\n@@ -1590,10 +1589,0 @@\n-class java_nio_Buffer: AllStatic {\n- private:\n-  static int _limit_offset;\n-\n- public:\n-  static int  limit_offset() { CHECK_INIT(_limit_offset); }\n-  static void compute_offsets();\n-  static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;\n-};\n-\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -91,1 +91,2 @@\n-  case vmIntrinsics::_checkIndex:\n+  case vmIntrinsics::_Preconditions_checkIndex:\n+  case vmIntrinsics::_Preconditions_checkLongIndex:\n@@ -470,5 +471,0 @@\n-#ifdef COMPILER1\n-  case vmIntrinsics::_checkIndex:\n-    if (!InlineNIOCheckIndex) return true;\n-    break;\n-#endif \/\/ COMPILER1\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -344,4 +344,0 @@\n-  do_class(java_nio_Buffer,               \"java\/nio\/Buffer\")                                                            \\\n-  do_intrinsic(_checkIndex,               java_nio_Buffer,        checkIndex_name, int_int_signature,            F_R)   \\\n-   do_name(     checkIndex_name,                                 \"checkIndex\")                                          \\\n-                                                                                                                        \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -127,0 +127,1 @@\n+  template(java_nio_Buffer,                           \"java\/nio\/Buffer\")                          \\\n@@ -485,0 +486,1 @@\n+  template(checkIndex_name,                           \"checkIndex\")                               \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,0 @@\n-import jdk.internal.vm.annotation.IntrinsicCandidate;\n@@ -39,0 +38,1 @@\n+import java.util.Objects;\n@@ -739,1 +739,0 @@\n-    @IntrinsicCandidate\n@@ -741,3 +740,1 @@\n-        if ((i < 0) || (i >= limit))\n-            throw new IndexOutOfBoundsException();\n-        return i;\n+        return Objects.checkIndex(i, limit);\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Buffer.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,197 @@\n+\/*\n+ * Copyright (c) 2021, Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @author Yi Yang\n+ * @bug 8265518\n+ * @summary C1 intrinsic support for jdk.internal.util.Preconditions.checkIndex\n+ * @requires vm.compiler1.enabled\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.util\n+ * @run main\/othervm -XX:TieredStopAtLevel=1 -Xbatch\n+ *                   -XX:CompileCommand=dontinline,*TestCheckIndexC1Intrinsic.check*\n+ *                   -XX:CompileCommand=compileonly,*TestCheckIndexC1Intrinsic.check*\n+ *                   compiler.c1.TestCheckIndexC1Intrinsic\n+ *\/\n+\n+package compiler.c1;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.internal.util.Preconditions;\n+\n+public class TestCheckIndexC1Intrinsic {\n+    static int limit = 100;\n+\n+    private static class MyException extends RuntimeException {\n+        public MyException(String msg) {\n+            super(msg);\n+        }\n+    }\n+\n+    static void check0() {\n+        long res = Preconditions.checkIndex(0, 1, null);\n+        Asserts.assertEquals((int)res, 0);\n+        try {\n+            Preconditions.checkIndex(1, 1, null);\n+            throw new AssertionError(\"Expected IndexOutOfBoundsException not thrown\");\n+        } catch (IndexOutOfBoundsException e) {\n+            \/\/ got it!\n+        }\n+        try {\n+            Preconditions.checkIndex(Integer.MIN_VALUE, -1, null);\n+            throw new AssertionError(\"Expected IndexOutOfBoundsException not thrown\");\n+        } catch (IndexOutOfBoundsException e) {\n+            \/\/ got it!\n+        }\n+        try {\n+            Preconditions.checkIndex(Integer.MIN_VALUE, Integer.MIN_VALUE, null);\n+            throw new AssertionError(\"Expected IndexOutOfBoundsException not thrown\");\n+        } catch (IndexOutOfBoundsException e) {\n+            \/\/ got it!\n+        }\n+        try {\n+            Preconditions.checkIndex(Long.MAX_VALUE, Long.MAX_VALUE, null);\n+            throw new AssertionError(\"Expected IndexOutOfBoundsException not thrown\");\n+        } catch (IndexOutOfBoundsException e) {\n+            \/\/ got it!\n+        }\n+        res = Preconditions.checkIndex(Long.MAX_VALUE - 1, Long.MAX_VALUE, null);\n+        Asserts.assertEquals(res, Long.MAX_VALUE - 1);\n+\n+        try {\n+            \/\/ read fields\n+            Preconditions.checkIndex(limit + 1, limit, (s, integers) -> new MyException(\"Reason:\" + s + \"::\" + integers));\n+            throw new AssertionError(\"Expected IndexOutOfBoundsException not thrown\");\n+        } catch(MyException e){\n+            \/\/ got it!\n+        }\n+    }\n+\n+    static void check1(int i) {\n+        boolean trigger = false;\n+        try {\n+            Preconditions.checkIndex(i, 9999, (s, integers) -> new RuntimeException(\"ex\"));\n+        } catch (RuntimeException e) {\n+            Asserts.assertTrue(\"ex\".equals(e.getMessage()));\n+            trigger = true;\n+        } finally {\n+            if (trigger) {\n+                Asserts.assertTrue(i == 9999L);\n+            } else {\n+                Asserts.assertTrue(i != 9999L);\n+            }\n+        }\n+    }\n+\n+    static void check2(long i) {\n+        boolean trigger = false;\n+        try {\n+            Preconditions.checkIndex(i, 9999L, (s, integers) -> new RuntimeException(\"ex\"));\n+        } catch (RuntimeException e) {\n+            Asserts.assertTrue(\"ex\".equals(e.getMessage()));\n+            trigger = true;\n+        } finally {\n+            if (trigger) {\n+                Asserts.assertTrue(i == 9999L);\n+            } else {\n+                Asserts.assertTrue(i != 9999L);\n+            }\n+        }\n+    }\n+\n+    static void check3(int i) {\n+        boolean trigger = false;\n+        try {\n+            Preconditions.checkIndex(i, 9999, null);\n+        } catch (IndexOutOfBoundsException e) {\n+            Asserts.assertTrue(i == 9999);\n+            trigger = true;\n+        } finally {\n+            if (trigger) {\n+                Asserts.assertTrue(i == 9999L);\n+            } else {\n+                Asserts.assertTrue(i != 9999L);\n+            }\n+        }\n+    }\n+\n+    static void check4(long i) {\n+        boolean trigger = false;\n+        try {\n+            Preconditions.checkIndex(i, 9999L, null);\n+        } catch (IndexOutOfBoundsException e) {\n+            trigger = true;\n+        } finally {\n+            if (trigger) {\n+                Asserts.assertTrue(i == 9999L);\n+            } else {\n+                Asserts.assertTrue(i != 9999L);\n+            }\n+        }\n+    }\n+\n+    static void check5(int i) {\n+        Preconditions.checkIndex(i, 99999, (s, integers) -> new RuntimeException(\"ex\"));\n+    }\n+\n+    static void check6(long i) {\n+        Preconditions.checkIndex(i, 99999L, (s, integers) -> new RuntimeException(\"ex\"));\n+    }\n+\n+    static void check7(int i) {\n+        Preconditions.checkIndex(i, 99999, null);\n+    }\n+\n+    static void check8(long i) {\n+        Preconditions.checkIndex(i, 99999L, null);\n+    }\n+\n+    static void check9(int i) {\n+        Preconditions.checkIndex(i, i + 1, null);\n+    }\n+\n+    static void check10(long i) {\n+        Preconditions.checkIndex(i, i + 1L, null);\n+    }\n+\n+    public static void main(String... args) {\n+        for (int i = 0; i < 10_000; i++) {\n+            check0();\n+\n+            check1(i);\n+            check2((long) i);\n+            check3(i);\n+            check4((long) i);\n+\n+            check5(i);\n+            check6((long) i);\n+            check7(i);\n+            check8((long) i);\n+\n+            check9(i);\n+            check10((long)i);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c1\/TestCheckIndexC1Intrinsic.java","additions":197,"deletions":0,"binary":false,"changes":197,"status":"added"}]}