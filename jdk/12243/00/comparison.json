{"files":[{"patch":"@@ -285,2 +285,1 @@\n-  HeapWord* gen_boundary = reserved().start();\n-  _rs->younger_refs_in_space_iterate(space(), gen_boundary, blk);\n+  _rs->younger_refs_in_space_iterate(space(), blk);\n","filename":"src\/hotspot\/share\/gc\/serial\/tenuredGeneration.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -115,1 +115,0 @@\n-                                                HeapWord* gen_boundary,\n@@ -120,1 +119,1 @@\n-  non_clean_card_iterate(sp, gen_boundary, urasm, cl, this);\n+  non_clean_card_iterate(sp, urasm, cl, this);\n@@ -444,1 +443,0 @@\n-                                         HeapWord* gen_boundary,\n@@ -454,1 +452,1 @@\n-  DirtyCardToOopClosure* dcto_cl = sp->new_dcto_cl(cl, gen_boundary);\n+  DirtyCardToOopClosure* dcto_cl = sp->new_dcto_cl(cl);\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTableRS.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-  void younger_refs_in_space_iterate(TenuredSpace* sp, HeapWord* gen_boundary, OopIterateClosure* cl);\n+  void younger_refs_in_space_iterate(TenuredSpace* sp, OopIterateClosure* cl);\n@@ -75,1 +75,0 @@\n-                              HeapWord* gen_boundary,\n","filename":"src\/hotspot\/share\/gc\/shared\/cardTableRS.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -103,23 +103,0 @@\n-#endif \/\/ INCLUDE_SERIALGC\n-\n-class FilteringClosure: public OopIterateClosure {\n- private:\n-  HeapWord*   _boundary;\n-  OopIterateClosure* _cl;\n- protected:\n-  template <class T> inline void do_oop_work(T* p);\n- public:\n-  FilteringClosure(HeapWord* boundary, OopIterateClosure* cl) :\n-    OopIterateClosure(cl->ref_discoverer()), _boundary(boundary),\n-    _cl(cl) {}\n-  virtual void do_oop(oop* p);\n-  virtual void do_oop(narrowOop* p);\n-  virtual bool do_metadata()            { assert(!_cl->do_metadata(), \"assumption broken, must change to 'return _cl->do_metadata()'\"); return false; }\n-  virtual void do_klass(Klass*)         { ShouldNotReachHere(); }\n-  virtual void do_cld(ClassLoaderData*) { ShouldNotReachHere(); }\n-  virtual void do_method(Method*)       { ShouldNotReachHere(); }\n-  virtual void do_nmethod(nmethod*)     { ShouldNotReachHere(); }\n-};\n-\n-#if INCLUDE_SERIALGC\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/genOopClosures.hpp","additions":0,"deletions":23,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -101,17 +101,0 @@\n-#endif \/\/ INCLUDE_SERIALGC\n-\n-template <class T> void FilteringClosure::do_oop_work(T* p) {\n-  T heap_oop = RawAccess<>::oop_load(p);\n-  if (!CompressedOops::is_null(heap_oop)) {\n-    oop obj = CompressedOops::decode_not_null(heap_oop);\n-    if (cast_from_oop<HeapWord*>(obj) < _boundary) {\n-      _cl->do_oop(p);\n-    }\n-  }\n-}\n-\n-inline void FilteringClosure::do_oop(oop* p)       { FilteringClosure::do_oop_work(p); }\n-inline void FilteringClosure::do_oop(narrowOop* p) { FilteringClosure::do_oop_work(p); }\n-\n-#if INCLUDE_SERIALGC\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/genOopClosures.inline.hpp","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -79,10 +79,1 @@\n-  if (_boundary != NULL) {\n-    \/\/ We have a boundary outside of which we don't want to look\n-    \/\/ at objects, so create a filtering closure around the\n-    \/\/ oop closure before walking the region.\n-    FilteringClosure filter(_boundary, _cl);\n-    walk_mem_region_with_cl(mr, bottom, top, &filter);\n-  } else {\n-    \/\/ No boundary, simply walk the heap with the oop closure.\n-    walk_mem_region_with_cl(mr, bottom, top, _cl);\n-  }\n+  walk_mem_region_with_cl(mr, bottom, top, _cl);\n@@ -143,20 +134,17 @@\n-\/\/ We must replicate this so that the static type of \"FilteringClosure\"\n-\/\/ (see above) is apparent at the oop_iterate calls.\n-#define DirtyCardToOopClosure__walk_mem_region_with_cl_DEFN(ClosureType) \\\n-void DirtyCardToOopClosure::walk_mem_region_with_cl(MemRegion mr,        \\\n-                                                    HeapWord* bottom,    \\\n-                                                    HeapWord* top,       \\\n-                                                    ClosureType* cl) {   \\\n-  bottom += cast_to_oop(bottom)->oop_iterate_size(cl, mr);               \\\n-  if (bottom < top) {                                                    \\\n-    HeapWord* next_obj = bottom + cast_to_oop(bottom)->size();           \\\n-    while (next_obj < top) {                                             \\\n-      \/* Bottom lies entirely below top, so we can call the *\/           \\\n-      \/* non-memRegion version of oop_iterate below. *\/                  \\\n-      cast_to_oop(bottom)->oop_iterate(cl);                              \\\n-      bottom = next_obj;                                                 \\\n-      next_obj = bottom + cast_to_oop(bottom)->size();                   \\\n-    }                                                                    \\\n-    \/* Last object. *\/                                                   \\\n-    cast_to_oop(bottom)->oop_iterate(cl, mr);                            \\\n-  }                                                                      \\\n+void DirtyCardToOopClosure::walk_mem_region_with_cl(MemRegion mr,\n+                                                    HeapWord* bottom,\n+                                                    HeapWord* top,\n+                                                    OopIterateClosure* cl) {\n+  bottom += cast_to_oop(bottom)->oop_iterate_size(cl, mr);\n+  if (bottom < top) {\n+    HeapWord* next_obj = bottom + cast_to_oop(bottom)->size();\n+    while (next_obj < top) {\n+      \/* Bottom lies entirely below top, so we can call the *\/\n+      \/* non-memRegion version of oop_iterate below. *\/\n+      cast_to_oop(bottom)->oop_iterate(cl);\n+      bottom = next_obj;\n+      next_obj = bottom + cast_to_oop(bottom)->size();\n+    }\n+    \/* Last object. *\/\n+    cast_to_oop(bottom)->oop_iterate(cl, mr);\n+  }\n@@ -165,6 +153,0 @@\n-\/\/ (There are only two of these, rather than N, because the split is due\n-\/\/ only to the introduction of the FilteringClosure, a local part of the\n-\/\/ impl of this abstraction.)\n-DirtyCardToOopClosure__walk_mem_region_with_cl_DEFN(OopIterateClosure)\n-DirtyCardToOopClosure__walk_mem_region_with_cl_DEFN(FilteringClosure)\n-\n@@ -172,3 +154,2 @@\n-ContiguousSpace::new_dcto_cl(OopIterateClosure* cl,\n-                             HeapWord* boundary) {\n-  return new DirtyCardToOopClosure(this, cl, boundary);\n+ContiguousSpace::new_dcto_cl(OopIterateClosure* cl) {\n+  return new DirtyCardToOopClosure(this, cl);\n","filename":"src\/hotspot\/share\/gc\/shared\/space.cpp","additions":20,"deletions":39,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -246,2 +246,0 @@\n-  HeapWord* _boundary;          \/\/ If non-NULL, process only non-NULL oops\n-                                \/\/ pointing below boundary.\n@@ -281,4 +279,0 @@\n-  void walk_mem_region_with_cl(MemRegion mr,\n-                               HeapWord* bottom, HeapWord* top,\n-                               FilteringClosure* cl);\n-\n@@ -286,4 +280,2 @@\n-  DirtyCardToOopClosure(Space* sp, OopIterateClosure* cl,\n-                        HeapWord* boundary) :\n-    _cl(cl), _sp(sp), _boundary(boundary),\n-    _min_done(NULL) {\n+  DirtyCardToOopClosure(Space* sp, OopIterateClosure* cl) :\n+    _cl(cl), _sp(sp), _min_done(NULL) {\n@@ -484,2 +476,1 @@\n-  DirtyCardToOopClosure* new_dcto_cl(OopIterateClosure* cl,\n-                                     HeapWord* boundary);\n+  DirtyCardToOopClosure* new_dcto_cl(OopIterateClosure* cl);\n","filename":"src\/hotspot\/share\/gc\/shared\/space.hpp","additions":3,"deletions":12,"binary":false,"changes":15,"status":"modified"}]}