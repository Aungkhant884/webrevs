{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-import java.util.stream.IntStream;\n+import java.util.stream.LongStream;\n@@ -85,2 +85,2 @@\n-    public static void logX509ValidationEvent(int anchorCertId,\n-                                         int[] certIds) {\n+    public static void logX509ValidationEvent(long anchorCertId,\n+                                         long[] certIds) {\n@@ -88,2 +88,2 @@\n-        String codes = IntStream.of(certIds)\n-                .mapToObj(Integer::toString)\n+        String codes = LongStream.of(certIds)\n+                .mapToObj(Long::toString)\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/event\/EventHelper.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -113,0 +113,1 @@\n+\t    long certificateId = Integer.toUnsignedLong(hashCode);\n@@ -123,1 +124,1 @@\n-                xce.certificateId = hashCode;\n+                xce.certificateId = certificateId;\n@@ -135,1 +136,1 @@\n-                        hashCode,\n+                        certificateId,\n","filename":"src\/java.base\/share\/classes\/sun\/security\/jca\/JCAUtil.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -230,1 +230,1 @@\n-            int[] certIds = params.certificates().stream()\n+            long[] certIds = params.certificates().stream()\n@@ -232,0 +232,1 @@\n+                    .mapToLong(Integer::toUnsignedLong)\n@@ -233,1 +234,1 @@\n-            int anchorCertId = (anchorCert != null) ?\n+            int hash = (anchorCert != null) ?\n@@ -235,0 +236,1 @@\n+            long anchorCertId = Integer.toUnsignedLong(hash);\n@@ -242,1 +244,1 @@\n-                for (int id : certIds) {\n+                for (long id : certIds) {\n@@ -246,1 +248,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/certpath\/PKIXCertPathValidator.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1149,1 +1149,1 @@\n-            int peerCertificateId = 0;\n+            int hash = 0;\n@@ -1152,1 +1152,1 @@\n-                peerCertificateId = session\n+                hash = session\n@@ -1158,0 +1158,1 @@\n+            long peerCertificateId = Integer.toUnsignedLong(hash);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/Finished.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+import jdk.jfr.Unsigned;\n@@ -55,0 +56,1 @@\n+    @Unsigned\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/TLSHandshakeEvent.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,0 +57,1 @@\n+    @Unsigned\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/X509CertificateEvent.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+    @Unsigned\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/X509ValidationEvent.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import java.math.BigInteger;\n@@ -41,0 +42,1 @@\n+import jdk.jfr.Unsigned;\n@@ -50,1 +52,1 @@\n-        TIMESPAN, TIMESTAMP, OTHER\n+        TIMESPAN, TIMESTAMP, UNSIGNED, OTHER\n@@ -121,7 +123,20 @@\n-        switch (valueType) {\n-        case TIMESPAN:\n-            return object.getDuration(v.getName());\n-        case TIMESTAMP:\n-            return PRIVATE_ACCESS.getOffsetDataTime(object, v.getName());\n-        default:\n-            return object.getValue(v.getName());\n+        String name = v.getName();\n+        return switch (valueType) {\n+            case TIMESPAN -> object.getDuration(name);\n+            case TIMESTAMP -> PRIVATE_ACCESS.getOffsetDataTime(object, name);\n+            case UNSIGNED -> getUnsigned(object, name);\n+            case OTHER -> object.getValue(name);\n+        };\n+    }\n+\n+    private Object getUnsigned(RecordedObject object, String name) {\n+        \/\/ RecordedObject::getLong handles unsigned byte, short, int\n+        long value = object.getLong(name);\n+        \/\/ If unsigned long value exceeds 2^63, return (upper << 32) + lower\n+        if (value < 0) {\n+            int upper = (int) (value >>> 32);\n+            int lower = (int) value;\n+            BigInteger u = BigInteger.valueOf(Integer.toUnsignedLong(upper));\n+            u = u.shiftLeft(32);\n+            BigInteger l = BigInteger.valueOf(Integer.toUnsignedLong(lower));\n+            return u.add(l);\n@@ -129,0 +144,1 @@\n+        return Long.valueOf(value);\n@@ -130,1 +146,2 @@\n-    \/\/ It's expensive t check\n+\n+    \/\/ Somewhat expensive operation\n@@ -138,0 +155,6 @@\n+        if (v.getAnnotation(Unsigned.class) != null) {\n+            return switch(v.getTypeName()) {\n+                case \"byte\", \"short\", \"int\", \"long\" -> ValueType.UNSIGNED;\n+                default -> ValueType.OTHER;\n+            };\n+        }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/EventPrintWriter.java","additions":33,"deletions":10,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-                Events.assertField(e, \"certificateId\").equal(TestTLSHandshake.HASHCODE);\n+                Events.assertField(e, \"certificateId\").equal(TestTLSHandshake.CERT_ID);\n","filename":"test\/jdk\/jdk\/jfr\/event\/security\/TestTLSHandshakeEvent.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -131,2 +131,3 @@\n-                    Asserts.assertEquals(e.getLong(\"certificateId\"),\n-                        Long.valueOf(TestCertificate.ROOT_CA.certificate().getPublicKey().hashCode()));\n+                    int hash = TestCertificate.ROOT_CA.certificate().getPublicKey().hashCode();\n+                    Long id = Integer.toUnsignedLong(hash);\n+                    Asserts.assertEquals(e.getLong(\"certificateId\"), id);\n","filename":"test\/jdk\/jdk\/jfr\/event\/security\/TestX509ValidationEvent.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+import jdk.jfr.Unsigned;\n@@ -152,0 +153,3 @@\n+                if (expectedValue instanceof Number && v.getAnnotation(Unsigned.class) != null) {\n+                    expectedValue = Long.toUnsignedString(re.getLong(name));\n+                }\n","filename":"test\/jdk\/jdk\/jfr\/tool\/TestPrintXML.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -43,2 +43,2 @@\n-                TestTLSHandshake.ANCHOR_HASHCODE +\n-                \", \" + TestTLSHandshake.HASHCODE);\n+                TestTLSHandshake.ANCHOR_CERT_ID +\n+                \", \" + TestTLSHandshake.CERT_ID);\n@@ -48,1 +48,1 @@\n-        l.addExpected(TestTLSHandshake.CIPHER_SUITE +\", \" + TestTLSHandshake.HASHCODE);\n+        l.addExpected(TestTLSHandshake.CIPHER_SUITE +\", \" + TestTLSHandshake.CERT_ID);\n","filename":"test\/jdk\/jdk\/security\/logging\/TestTLSHandshakeLog.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import java.math.BigInteger;\n@@ -320,1 +321,1 @@\n-                Long.parseLong(value);\n+                new BigInteger(value);\n","filename":"test\/lib\/jdk\/test\/lib\/json\/JSONValue.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -142,1 +142,1 @@\n-                    long certId, String encoded) {\n+                    int hash, String encoded) {\n@@ -148,1 +148,1 @@\n-        this.certId = certId;\n+        this.certId = Integer.toUnsignedLong(hash);\n","filename":"test\/lib\/jdk\/test\/lib\/security\/TestCertificate.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,2 +36,2 @@\n-    public static final long HASHCODE = -1057291798L;\n-    public static final long ANCHOR_HASHCODE = 1688661792L;\n+    public static final long CERT_ID = Integer.toUnsignedLong(-1057291798);\n+    public static final long ANCHOR_CERT_ID = Integer.toUnsignedLong(1688661792);\n","filename":"test\/lib\/jdk\/test\/lib\/security\/TestTLSHandshake.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}