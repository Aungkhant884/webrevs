{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-import java.lang.invoke.ConstantBootstraps;\n@@ -35,0 +34,1 @@\n+import java.util.List;\n@@ -37,0 +37,2 @@\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.vm.annotation.Stable;\n@@ -39,1 +41,0 @@\n-import jdk.internal.vm.annotation.Stable;\n@@ -53,0 +54,1 @@\n+    private static final Object SENTINEL = new Object();\n@@ -55,2 +57,8 @@\n-    private static final MethodHandle DO_TYPE_SWITCH;\n-    private static final MethodHandle DO_ENUM_SWITCH;\n+    private static final MethodHandle INSTANCEOF_CHECK;\n+    private static final MethodHandle INTEGER_EQ_CHECK;\n+    private static final MethodHandle OBJECT_EQ_CHECK;\n+    private static final MethodHandle ENUM_EQ_CHECK;\n+    private static final MethodHandle NULL_CHECK;\n+    private static final MethodHandle IS_ZERO;\n+    private static final MethodHandle CHECK_INDEX;\n+    private static final MethodHandle MAPPED_ENUM_LOOKUP;\n@@ -60,5 +68,18 @@\n-            DO_TYPE_SWITCH = LOOKUP.findStatic(SwitchBootstraps.class, \"doTypeSwitch\",\n-                                           MethodType.methodType(int.class, Object.class, int.class, Object[].class));\n-            DO_ENUM_SWITCH = LOOKUP.findStatic(SwitchBootstraps.class, \"doEnumSwitch\",\n-                                           MethodType.methodType(int.class, Enum.class, int.class, Object[].class,\n-                                                                 MethodHandles.Lookup.class, Class.class, ResolvedEnumLabels.class));\n+            INSTANCEOF_CHECK = MethodHandles.permuteArguments(LOOKUP.findVirtual(Class.class, \"isInstance\",\n+                                                                                 MethodType.methodType(boolean.class, Object.class)),\n+                                                              MethodType.methodType(boolean.class, Object.class, Class.class), 1, 0);\n+            INTEGER_EQ_CHECK = LOOKUP.findStatic(SwitchBootstraps.class, \"integerEqCheck\",\n+                                           MethodType.methodType(boolean.class, Object.class, Integer.class));\n+            OBJECT_EQ_CHECK = LOOKUP.findStatic(Objects.class, \"equals\",\n+                                           MethodType.methodType(boolean.class, Object.class, Object.class));\n+            ENUM_EQ_CHECK = LOOKUP.findStatic(SwitchBootstraps.class, \"enumEqCheck\",\n+                                           MethodType.methodType(boolean.class, Object.class, EnumDesc.class, MethodHandles.Lookup.class, ResolvedEnumLabel.class));\n+            NULL_CHECK = LOOKUP.findStatic(Objects.class, \"isNull\",\n+                                           MethodType.methodType(boolean.class, Object.class));\n+            IS_ZERO = LOOKUP.findStatic(SwitchBootstraps.class, \"isZero\",\n+                                           MethodType.methodType(boolean.class, int.class));\n+            CHECK_INDEX = LOOKUP.findStatic(Objects.class, \"checkIndex\",\n+                                           MethodType.methodType(int.class, int.class, int.class));\n+            MAPPED_ENUM_LOOKUP = LOOKUP.findStatic(SwitchBootstraps.class, \"mappedEnumLookup\",\n+                                                   MethodType.methodType(int.class, Enum.class, MethodHandles.Lookup.class,\n+                                                                         Class.class, EnumDesc[].class, EnumMap.class));\n@@ -137,1 +158,2 @@\n-        MethodHandle target = MethodHandles.insertArguments(DO_TYPE_SWITCH, 2, (Object) labels);\n+        MethodHandle target = createMethodHandleSwitch(lookup, labels);\n+\n@@ -154,23 +176,30 @@\n-    private static int doTypeSwitch(Object target, int startIndex, Object[] labels) {\n-        Objects.checkIndex(startIndex, labels.length + 1);\n-\n-        if (target == null)\n-            return -1;\n-\n-        \/\/ Dumbest possible strategy\n-        Class<?> targetClass = target.getClass();\n-        for (int i = startIndex; i < labels.length; i++) {\n-            Object label = labels[i];\n-            if (label instanceof Class<?> c) {\n-                if (c.isAssignableFrom(targetClass))\n-                    return i;\n-            } else if (label instanceof Integer constant) {\n-                if (target instanceof Number input && constant.intValue() == input.intValue()) {\n-                    return i;\n-                } else if (target instanceof Character input && constant.intValue() == input.charValue()) {\n-                    return i;\n-                }\n-            } else if (label instanceof EnumDesc<?> enumDesc) {\n-                if (target.getClass().isEnum() &&\n-                    ((Enum<?>) target).describeConstable().stream().anyMatch(d -> d.equals(enumDesc))) {\n-                    return i;\n+    \/*\n+     * Construct test chains for labels inside switch, to handle switch repeats:\n+     * switch (idx) {\n+     *     case 0 -> if (selector matches label[0]) return 0; else if (selector matches label[1]) return 1; else ...\n+     *     case 1 -> if (selector matches label[1]) return 1; else ...\n+     *     ...\n+     * }\n+     *\/\n+    private static MethodHandle createRepeatIndexSwitch(MethodHandles.Lookup lookup, Object[] labels) {\n+        MethodHandle def = MethodHandles.dropArguments(MethodHandles.constant(int.class, labels.length), 0, Object.class);\n+        MethodHandle[] testChains = new MethodHandle[labels.length];\n+        List<Object> labelsList = List.of(labels).reversed();\n+\n+        for (int i = 0; i < labels.length; i++) {\n+            MethodHandle test = def;\n+            int idx = labels.length - 1;\n+            List<Object> currentLabels = labelsList.subList(0, labels.length - i);\n+\n+            for (int j = 0; j < currentLabels.size(); j++, idx--) {\n+                Object currentLabel = currentLabels.get(j);\n+                if (j + 1 < currentLabels.size() && currentLabels.get(j + 1) == currentLabel) continue;\n+                MethodHandle currentTest;\n+                if (currentLabel instanceof Class<?>) {\n+                    currentTest = INSTANCEOF_CHECK;\n+                } else if (currentLabel instanceof Integer) {\n+                    currentTest = INTEGER_EQ_CHECK;\n+                } else if (currentLabel instanceof EnumDesc) {\n+                    currentTest = MethodHandles.insertArguments(ENUM_EQ_CHECK, 2, lookup, new ResolvedEnumLabel());\n+                } else {\n+                    currentTest = OBJECT_EQ_CHECK;\n@@ -178,2 +207,3 @@\n-            } else if (label.equals(target)) {\n-                return i;\n+                test = MethodHandles.guardWithTest(MethodHandles.insertArguments(currentTest, 1, currentLabel),\n+                                                   MethodHandles.dropArguments(MethodHandles.constant(int.class, idx), 0, Object.class),\n+                                                   test);\n@@ -181,0 +211,33 @@\n+            testChains[i] = MethodHandles.dropArguments(test, 0, int.class);\n+        }\n+\n+        return MethodHandles.tableSwitch(MethodHandles.dropArguments(def, 0, int.class), testChains);\n+    }\n+\n+    \/*\n+     * Construct code that maps the given selector and repeat index to a case label number:\n+     * if (selector == null) return -1;\n+     * else return \"createRepeatIndexSwitch(labels)\"\n+     *\/\n+    private static MethodHandle createMethodHandleSwitch(MethodHandles.Lookup lookup, Object[] labels) {\n+        MethodHandle mainTest;\n+        MethodHandle def = MethodHandles.dropArguments(MethodHandles.constant(int.class, labels.length), 0, Object.class);\n+        if (labels.length > 0) {\n+            mainTest = createRepeatIndexSwitch(lookup, labels);\n+        } else {\n+            mainTest = MethodHandles.dropArguments(def, 0, int.class);\n+        }\n+        MethodHandle body =\n+                MethodHandles.guardWithTest(MethodHandles.dropArguments(NULL_CHECK, 0, int.class),\n+                                            MethodHandles.dropArguments(MethodHandles.constant(int.class, -1), 0, int.class, Object.class),\n+                                            mainTest);\n+        MethodHandle switchImpl =\n+                MethodHandles.permuteArguments(body, MethodType.methodType(int.class, Object.class, int.class), 1, 0);\n+        return withIndexCheck(switchImpl, labels.length);\n+    }\n+\n+    private static boolean integerEqCheck(Object value, Integer constant) {\n+        if (value instanceof Number input && constant.intValue() == input.intValue()) {\n+            return true;\n+        } else if (value instanceof Character input && constant.intValue() == input.charValue()) {\n+            return true;\n@@ -183,1 +246,5 @@\n-        return labels.length;\n+        return false;\n+    }\n+\n+    private static boolean isZero(int value) {\n+        return value == 0;\n@@ -257,4 +324,1 @@\n-        Stream.of(labels).forEach(l -> validateEnumLabel(enumClass, l));\n-        MethodHandle temporary =\n-                MethodHandles.insertArguments(DO_ENUM_SWITCH, 2, labels, lookup, enumClass, new ResolvedEnumLabels());\n-        temporary = temporary.asType(invocationType);\n+        labels = Stream.of(labels).map(l -> convertEnumConstants(lookup, enumClass, l)).toArray();\n@@ -262,2 +326,2 @@\n-        return new ConstantCallSite(temporary);\n-    }\n+        MethodHandle target;\n+        boolean constantsOnly = Stream.of(labels).allMatch(l -> enumClass.isAssignableFrom(EnumDesc.class));\n@@ -265,13 +329,14 @@\n-    private static <E extends Enum<E>> void validateEnumLabel(Class<?> enumClassTemplate, Object label) {\n-        if (label == null) {\n-            throw new IllegalArgumentException(\"null label found\");\n-        }\n-        Class<?> labelClass = label.getClass();\n-        if (labelClass == Class.class) {\n-            if (label != enumClassTemplate) {\n-                throw new IllegalArgumentException(\"the Class label: \" + label +\n-                                                   \", expected the provided enum class: \" + enumClassTemplate);\n-            }\n-        } else if (labelClass != String.class) {\n-            throw new IllegalArgumentException(\"label with illegal type found: \" + labelClass +\n-                                               \", expected label of type either String or Class\");\n+        if (labels.length > 0 && constantsOnly) {\n+            \/\/If all labels are enum constants, construct an optimized handle for repeat index 0:\n+            \/\/if (selector == null) return -1\n+            \/\/else if (idx == 0) return mappingArray[selector.ordinal()]; \/\/mapping array created lazily\n+            \/\/else return \"createRepeatIndexSwitch(labels)\"\n+            MethodHandle body =\n+                    MethodHandles.guardWithTest(MethodHandles.dropArguments(NULL_CHECK, 0, int.class),\n+                                                MethodHandles.dropArguments(MethodHandles.constant(int.class, -1), 0, int.class, Object.class),\n+                                                MethodHandles.guardWithTest(MethodHandles.dropArguments(IS_ZERO, 1, Object.class),\n+                                                                            createRepeatIndexSwitch(lookup, labels),\n+                                                                            MethodHandles.insertArguments(MAPPED_ENUM_LOOKUP, 1, lookup, enumClass, labels, new EnumMap())));\n+            target = MethodHandles.permuteArguments(body, MethodType.methodType(int.class, Object.class, int.class), 1, 0);\n+        } else {\n+            target = createMethodHandleSwitch(lookup, labels);\n@@ -279,0 +344,5 @@\n+\n+        target = target.asType(invocationType);\n+        target = withIndexCheck(target, labels.length);\n+\n+        return new ConstantCallSite(target);\n@@ -293,7 +363,1 @@\n-            @SuppressWarnings(\"unchecked\")\n-            Class<E> enumClass = (Class<E>) enumClassTemplate;\n-            try {\n-                return ConstantBootstraps.enumConstant(lookup, (String) label, enumClass);\n-            } catch (IllegalArgumentException ex) {\n-                return null;\n-            }\n+            return EnumDesc.of(enumClassTemplate.describeConstable().get(), (String) label);\n@@ -306,4 +370,5 @@\n-    private static int doEnumSwitch(Enum<?> target, int startIndex, Object[] unresolvedLabels,\n-                                    MethodHandles.Lookup lookup, Class<?> enumClass,\n-                                    ResolvedEnumLabels resolvedLabels) {\n-        Objects.checkIndex(startIndex, unresolvedLabels.length + 1);\n+    private static <T extends Enum<T>> int mappedEnumLookup(T value, MethodHandles.Lookup lookup, Class<T> enumClass, EnumDesc<?>[] labels, EnumMap enumMap) {\n+        if (enumMap.map == null) {\n+            T[] constants = SharedSecrets.getJavaLangAccess().getEnumConstantsShared(enumClass);\n+            int[] map = new int[constants.length];\n+            int ordinal = 0;\n@@ -311,2 +376,2 @@\n-        if (target == null)\n-            return -1;\n+            for (T constant : constants) {\n+                map[ordinal] = labels.length;\n@@ -314,4 +379,9 @@\n-        if (resolvedLabels.resolvedLabels == null) {\n-            resolvedLabels.resolvedLabels = Stream.of(unresolvedLabels)\n-                                                  .map(l -> convertEnumConstants(lookup, enumClass, l))\n-                                                  .toArray();\n+                for (int i = 0; i < labels.length; i++) {\n+                    if (Objects.equals(labels[i].constantName(), constant.name())) {\n+                        map[ordinal] = i;\n+                        break;\n+                    }\n+                }\n+\n+                ordinal++;\n+            }\n@@ -319,0 +389,9 @@\n+        return enumMap.map[value.ordinal()];\n+    }\n+\n+    private static boolean enumEqCheck(Object value, EnumDesc<?> label, MethodHandles.Lookup lookup, ResolvedEnumLabel resolvedEnum) {\n+        if (resolvedEnum.resolvedEnum == null) {\n+            Object resolved;\n+\n+            try {\n+                Class<?> clazz = label.constantType().resolveConstantDesc(lookup);\n@@ -320,11 +399,7 @@\n-        Object[] labels = resolvedLabels.resolvedLabels;\n-\n-        \/\/ Dumbest possible strategy\n-        Class<?> targetClass = target.getClass();\n-        for (int i = startIndex; i < labels.length; i++) {\n-            Object label = labels[i];\n-            if (label instanceof Class<?> c) {\n-                if (c.isAssignableFrom(targetClass))\n-                    return i;\n-            } else if (label == target) {\n-                return i;\n+                if (value.getClass() != clazz) {\n+                    return false;\n+                }\n+\n+                resolved = label.resolveConstantDesc(lookup);\n+            } catch (IllegalArgumentException | ReflectiveOperationException ex) {\n+                resolved = SENTINEL;\n@@ -332,0 +407,2 @@\n+\n+            resolvedEnum.resolvedEnum = resolved;\n@@ -334,1 +411,12 @@\n-        return labels.length;\n+        return value == resolvedEnum.resolvedEnum;\n+    }\n+\n+    private static MethodHandle withIndexCheck(MethodHandle target, int labelsCount) {\n+        MethodHandle checkIndex = MethodHandles.insertArguments(CHECK_INDEX, 1, labelsCount + 1);\n+\n+        return MethodHandles.filterArguments(target, 1, checkIndex);\n+    }\n+\n+    private static final class ResolvedEnumLabel {\n+        @Stable\n+        public Object resolvedEnum;\n@@ -337,1 +425,1 @@\n-    private static final class ResolvedEnumLabels {\n+    private static final class EnumMap {\n@@ -339,1 +427,1 @@\n-        public Object[] resolvedLabels;\n+        public int[] map;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/SwitchBootstraps.java","additions":175,"deletions":87,"binary":false,"changes":262,"status":"modified"},{"patch":"@@ -116,0 +116,1 @@\n+        testType(\"\", 0, 0);\n@@ -134,0 +135,6 @@\n+        testEnum(E1.B, 0, 0, \"B\", \"A\");\n+        testEnum(E1.A, 0, 1, \"B\", \"A\");\n+        testEnum(E1.A, 0, 0, \"A\", \"A\", \"B\");\n+        testEnum(E1.A, 1, 1, \"A\", \"A\", \"B\");\n+        testEnum(E1.A, 2, 3, \"A\", \"A\", \"B\");\n+        testEnum(E1.A, 0, 0);\n","filename":"test\/jdk\/java\/lang\/runtime\/SwitchBootstrapsTest.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"}]}