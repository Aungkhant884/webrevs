{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,5 @@\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n@@ -55,2 +60,6 @@\n-    private static final MethodHandle DO_TYPE_SWITCH;\n-    private static final MethodHandle DO_ENUM_SWITCH;\n+    private static final MethodHandle INSTANCEOF_CHECK;\n+    private static final MethodHandle INTEGER_EQ_CHECK;\n+    private static final MethodHandle OBJECT_EQ_CHECK;\n+    private static final MethodHandle NULL_CHECK;\n+    private static final MethodHandle IS_ZERO;\n+    private static final MethodHandle ENUM_LOOKUP;\n@@ -60,4 +69,12 @@\n-            DO_TYPE_SWITCH = LOOKUP.findStatic(SwitchBootstraps.class, \"doTypeSwitch\",\n-                                           MethodType.methodType(int.class, Object.class, int.class, Object[].class));\n-            DO_ENUM_SWITCH = LOOKUP.findStatic(SwitchBootstraps.class, \"doEnumSwitch\",\n-                                           MethodType.methodType(int.class, Enum.class, int.class, Object[].class));\n+            INSTANCEOF_CHECK = LOOKUP.findStatic(SwitchBootstraps.class, \"instanceofCheck\",\n+                                           MethodType.methodType(boolean.class, Object.class, Class.class));\n+            INTEGER_EQ_CHECK = LOOKUP.findStatic(SwitchBootstraps.class, \"integerEqCheck\",\n+                                           MethodType.methodType(boolean.class, Object.class, Integer.class));\n+            OBJECT_EQ_CHECK = LOOKUP.findStatic(Objects.class, \"equals\",\n+                                           MethodType.methodType(boolean.class, Object.class, Object.class));\n+            NULL_CHECK = LOOKUP.findStatic(SwitchBootstraps.class, \"nullCheck\",\n+                                           MethodType.methodType(boolean.class, Object.class));\n+            IS_ZERO = LOOKUP.findStatic(SwitchBootstraps.class, \"isZero\",\n+                                           MethodType.methodType(boolean.class, int.class));\n+            ENUM_LOOKUP = LOOKUP.findStatic(SwitchBootstraps.class, \"enumLookup\",\n+                                           MethodType.methodType(int.class, int[].class, Object.class));\n@@ -130,1 +147,2 @@\n-        MethodHandle target = MethodHandles.insertArguments(DO_TYPE_SWITCH, 2, (Object) labels);\n+        MethodHandle target = createMethodHandleSwitch(labels);\n+\n@@ -146,16 +164,30 @@\n-    private static int doTypeSwitch(Object target, int startIndex, Object[] labels) {\n-        if (target == null)\n-            return -1;\n-\n-        \/\/ Dumbest possible strategy\n-        Class<?> targetClass = target.getClass();\n-        for (int i = startIndex; i < labels.length; i++) {\n-            Object label = labels[i];\n-            if (label instanceof Class<?> c) {\n-                if (c.isAssignableFrom(targetClass))\n-                    return i;\n-            } else if (label instanceof Integer constant) {\n-                if (target instanceof Number input && constant.intValue() == input.intValue()) {\n-                    return i;\n-                } else if (target instanceof Character input && constant.intValue() == input.charValue()) {\n-                    return i;\n+    \/*\n+     * Construct test chains for labels inside switch, to handle switch repeats:\n+     * switch (idx) {\n+     *     case 0 -> if (selector matches label[0]) return 0; else if (selector matches label[1]) return 1; else ...\n+     *     case 1 -> if (selector matches label[1]) return 1; else ...\n+     *     ...\n+     * }\n+     *\/\n+    private static MethodHandle createRepeatIndexSwitch(Object[] labels) {\n+        MethodHandle def = MethodHandles.dropArguments(MethodHandles.constant(int.class, labels.length), 0, Object.class);\n+        MethodHandle[] testChains = new MethodHandle[labels.length];\n+        List<Object> labelsList = new ArrayList<>(Arrays.asList(labels));\n+\n+        Collections.reverse(labelsList);\n+\n+        for (int i = 0; i < labels.length; i++) {\n+            MethodHandle test = def;\n+            int idx = labels.length - 1;\n+            List<Object> currentLabels = labelsList.subList(0, labels.length - i);\n+\n+            for (int j = 0; j < currentLabels.size(); j++, idx--) {\n+                Object currentLabel = currentLabels.get(j);\n+                if (j + 1 < currentLabels.size() && currentLabels.get(j + 1) == currentLabel) continue;\n+                MethodHandle currentTest;\n+                if (currentLabel instanceof Class<?>) {\n+                    currentTest = INSTANCEOF_CHECK;\n+                } else if (currentLabel instanceof Integer) {\n+                    currentTest = INTEGER_EQ_CHECK;\n+                } else {\n+                    currentTest = OBJECT_EQ_CHECK;\n@@ -163,2 +195,3 @@\n-            } else if (label.equals(target)) {\n-                return i;\n+                test = MethodHandles.guardWithTest(MethodHandles.insertArguments(currentTest, 1, currentLabel),\n+                                                   MethodHandles.dropArguments(MethodHandles.constant(int.class, idx), 0, Object.class),\n+                                                   test);\n@@ -166,0 +199,1 @@\n+            testChains[i] = MethodHandles.dropArguments(test, 0, int.class);\n@@ -168,1 +202,43 @@\n-        return labels.length;\n+        return MethodHandles.tableSwitch(MethodHandles.dropArguments(def, 0, int.class), testChains);\n+    }\n+\n+    \/*\n+     * Construct code that maps the given selector and repeat index to a case label number:\n+     * if (selector == null) return -1;\n+     * else return \"createRepeatIndexSwitch(labels)\"\n+     *\/\n+    private static MethodHandle createMethodHandleSwitch(Object[] labels) {\n+        MethodHandle mainTest;\n+        MethodHandle def = MethodHandles.dropArguments(MethodHandles.constant(int.class, labels.length), 0, Object.class);\n+        if (labels.length > 0) {\n+            mainTest = createRepeatIndexSwitch(labels);\n+        } else {\n+            mainTest = MethodHandles.dropArguments(def, 0, int.class);\n+        }\n+        MethodHandle body =\n+                MethodHandles.guardWithTest(MethodHandles.dropArguments(NULL_CHECK, 0, int.class),\n+                                            MethodHandles.dropArguments(MethodHandles.constant(int.class, -1), 0, int.class, Object.class),\n+                                            mainTest);\n+        return MethodHandles.permuteArguments(body, MethodType.methodType(int.class, Object.class, int.class), 1, 0);\n+    }\n+\n+    private static boolean instanceofCheck(Object value, Class<?> label) {\n+        return label.isAssignableFrom(value.getClass());\n+    }\n+\n+    private static boolean integerEqCheck(Object value, Integer constant) {\n+        if (value instanceof Number input && constant.intValue() == input.intValue()) {\n+            return true;\n+        } else if (value instanceof Character input && constant.intValue() == input.charValue()) {\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    private static boolean nullCheck(Object value) {\n+        return value == null;\n+    }\n+\n+    private static boolean isZero(int value) {\n+        return value == 0;\n@@ -240,2 +316,49 @@\n-        MethodHandle target =\n-                MethodHandles.insertArguments(DO_ENUM_SWITCH, 2, (Object) labels);\n+        MethodHandle target;\n+        boolean constantsOnly = Stream.of(labels).allMatch(l -> l == null || enumClass.isAssignableFrom(l.getClass()));\n+\n+        if (constantsOnly) {\n+            long nonNullValues = Stream.of(labels).filter(l -> l != null).count();\n+            long distinctNonNullValues = Stream.of(labels).filter(l -> l != null).distinct().count();\n+\n+            if (nonNullValues != distinctNonNullValues) {\n+                constantsOnly = false;\n+            }\n+        }\n+\n+        if (labels.length > 0 && constantsOnly) {\n+            \/\/If all labels are enum constants, construct an optimized handle for repeat index 0:\n+            \/\/if (selector == null) return -1\n+            \/\/else if (idx == 0) return switch (selector.ordinal()) {\n+            \/\/                              case <label1-ordinal>: return 0;\n+            \/\/                              case <label2-ordinal>: return 1;\n+            \/\/                              ...\n+            \/\/                          };\n+            \/\/else return \"createRepeatIndexSwitch(labels)\"\n+            MethodHandle[] map = new MethodHandle[enumClass.getEnumConstants().length];\n+            MethodHandle def = MethodHandles.dropArguments(MethodHandles.constant(int.class, labels.length), 0, int.class, Object.class);\n+            int ordinal = 0;\n+\n+            for (Object constant : enumClass.getEnumConstants()) {\n+                map[ordinal] = def;\n+\n+                for (int i = 0; i < labels.length; i++) {\n+                    if (labels[i] == constant) {\n+                        map[ordinal] = MethodHandles.dropArguments(MethodHandles.constant(int.class, i), 0, int.class, Object.class);\n+                        break;\n+                    }\n+                }\n+\n+                ordinal++;\n+            }\n+\n+            MethodHandle body =\n+                    MethodHandles.guardWithTest(MethodHandles.dropArguments(NULL_CHECK, 0, int.class),\n+                                                MethodHandles.dropArguments(MethodHandles.constant(int.class, -1), 0, int.class, Object.class),\n+                                                MethodHandles.guardWithTest(MethodHandles.dropArguments(IS_ZERO, 1, Object.class),\n+                                                                            createRepeatIndexSwitch(labels),\n+                                                                            MethodHandles.tableSwitch(def, map)));\n+            target = MethodHandles.permuteArguments(body, MethodType.methodType(int.class, Object.class, int.class), 1, 0);\n+        } else {\n+            target = createMethodHandleSwitch(labels);\n+        }\n+\n@@ -247,0 +370,4 @@\n+    private static int enumLookup(int[] map, Object label) {\n+        return map[((Enum) label).ordinal()];\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/SwitchBootstraps.java","additions":156,"deletions":29,"binary":false,"changes":185,"status":"modified"},{"patch":"@@ -111,0 +111,1 @@\n+        testType(\"\", 0, 0);\n@@ -129,0 +130,6 @@\n+        testEnum(E1.B, 0, 0, \"B\", \"A\");\n+        testEnum(E1.A, 0, 1, \"B\", \"A\");\n+        testEnum(E1.A, 0, 0, \"A\", \"A\", \"B\");\n+        testEnum(E1.A, 1, 1, \"A\", \"A\", \"B\");\n+        testEnum(E1.A, 2, 3, \"A\", \"A\", \"B\");\n+        testEnum(E1.A, 0, 0);\n","filename":"test\/jdk\/java\/lang\/runtime\/SwitchBootstrapsTest.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"}]}