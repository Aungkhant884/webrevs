{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,4 @@\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n@@ -55,1 +59,0 @@\n-    private static final MethodHandle DO_TYPE_SWITCH;\n@@ -57,0 +60,3 @@\n+    private static final MethodHandle INSTANCEOF_CHECK;\n+    private static final MethodHandle EQ_CHECK;\n+    private static final MethodHandle NULL_CHECK;\n@@ -60,2 +66,0 @@\n-            DO_TYPE_SWITCH = LOOKUP.findStatic(SwitchBootstraps.class, \"doTypeSwitch\",\n-                                           MethodType.methodType(int.class, Object.class, int.class, Object[].class));\n@@ -64,0 +68,6 @@\n+            INSTANCEOF_CHECK = LOOKUP.findStatic(SwitchBootstraps.class, \"instanceofCheck\",\n+                                           MethodType.methodType(boolean.class, Object.class, Class.class));\n+            EQ_CHECK = LOOKUP.findStatic(SwitchBootstraps.class, \"eqCheck\",\n+                                           MethodType.methodType(boolean.class, Object.class, Object.class));\n+            NULL_CHECK = LOOKUP.findStatic(SwitchBootstraps.class, \"nullCheck\",\n+                                           MethodType.methodType(boolean.class, Object.class));\n@@ -130,1 +140,2 @@\n-        MethodHandle target = MethodHandles.insertArguments(DO_TYPE_SWITCH, 2, (Object) labels);\n+        MethodHandle target  = createMethodHandleSwitch(labels);\n+\n@@ -146,16 +157,24 @@\n-    private static int doTypeSwitch(Object target, int startIndex, Object[] labels) {\n-        if (target == null)\n-            return -1;\n-\n-        \/\/ Dumbest possible strategy\n-        Class<?> targetClass = target.getClass();\n-        for (int i = startIndex; i < labels.length; i++) {\n-            Object label = labels[i];\n-            if (label instanceof Class<?> c) {\n-                if (c.isAssignableFrom(targetClass))\n-                    return i;\n-            } else if (label instanceof Integer constant) {\n-                if (target instanceof Number input && constant.intValue() == input.intValue()) {\n-                    return i;\n-                } else if (target instanceof Character input && constant.intValue() == input.charValue()) {\n-                    return i;\n+    private static MethodHandle createMethodHandleSwitch(Object[] labels) {\n+        MethodHandle mainTest;\n+        MethodHandle def = MethodHandles.dropArguments(MethodHandles.constant(int.class, labels.length), 0, Object.class);\n+        if (labels.length > 0) {\n+            MethodHandle[] testChains = new MethodHandle[labels.length];\n+            List<Object> labelsList = new ArrayList<>(Arrays.asList(labels));\n+            Collections.reverse(labelsList);\n+            for (int i = 0; i < labels.length; i++) {\n+                MethodHandle test = def;\n+                int idx = labels.length - 1;\n+                List<Object> currentLabels = labelsList.subList(0, labels.length - i);\n+\n+                for (int j = 0; j < currentLabels.size(); j++, idx--) {\n+                    Object currentLabel = currentLabels.get(j);\n+                    if (j + 1 < currentLabels.size() && currentLabels.get(j + 1) == currentLabel) continue;\n+                    MethodHandle currentTest;\n+                    if (currentLabel instanceof Class<?>) {\n+                        currentTest = INSTANCEOF_CHECK;\n+                    } else {\n+                        currentTest = EQ_CHECK;\n+                    }\n+                    test = MethodHandles.guardWithTest(MethodHandles.insertArguments(currentTest, 1, currentLabel),\n+                                                       MethodHandles.dropArguments(MethodHandles.constant(int.class, idx), 0, Object.class),\n+                                                       test);\n@@ -163,2 +182,1 @@\n-            } else if (label.equals(target)) {\n-                return i;\n+                testChains[i] = MethodHandles.dropArguments(test, 0, int.class);\n@@ -166,0 +184,3 @@\n+            mainTest = MethodHandles.tableSwitch(MethodHandles.dropArguments(def, 0, int.class), testChains);\n+        } else {\n+            mainTest = MethodHandles.dropArguments(def, 0, int.class);\n@@ -167,0 +188,24 @@\n+        MethodHandle body =\n+                MethodHandles.guardWithTest(MethodHandles.dropArguments(NULL_CHECK, 0, int.class),\n+                                            MethodHandles.dropArguments(MethodHandles.constant(int.class, -1), 0, int.class, Object.class),\n+                                            mainTest);\n+        return MethodHandles.permuteArguments(body, MethodType.methodType(int.class, Object.class, int.class), 1, 0);\n+    }\n+\n+    private static boolean instanceofCheck(Object value, Class<?> label) {\n+        return label.isAssignableFrom(value.getClass());\n+    }\n+\n+    private static boolean eqCheck(Object value, Object label) {\n+        if (label instanceof Integer constant) {\n+            if (value instanceof Number input && constant.intValue() == input.intValue()) {\n+                return true;\n+            } else if (value instanceof Character input && constant.intValue() == input.charValue()) {\n+                return true;\n+            }\n+        } else if (label.equals(value)) {\n+            return true;\n+        }\n+\n+        return false;\n+    }\n@@ -168,1 +213,2 @@\n-        return labels.length;\n+    private static boolean nullCheck(Object value) {\n+        return value == null;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/SwitchBootstraps.java","additions":70,"deletions":24,"binary":false,"changes":94,"status":"modified"}]}