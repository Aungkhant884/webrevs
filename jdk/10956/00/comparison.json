{"files":[{"patch":"@@ -1151,0 +1151,16 @@\n+        \/** Determine whether the given outer class strictly encloses this one.\n+         *\/\n+        public boolean isInnerClassOf(Types types, Type outerType) {\n+            if (!outerType.hasTag(CLASS))\n+                return false;\n+            outerType = types.erasure(outerType);\n+            for (Type type = getEnclosingType();\n+                    type != null && type.hasTag(CLASS);\n+                    type = type.getEnclosingType()) {\n+                if (types.erasure(type).equalsIgnoreMetadata(outerType)) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Type.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2894,1 +2894,1 @@\n-        \/\/ check fields accessed through this.<field> are definitely\n+        \/\/ check fields accessed through [<Type>.]this.<field> are definitely\n@@ -2898,2 +2898,3 @@\n-            if (TreeInfo.isThisQualifier(tree.selected) &&\n-                tree.sym.kind == VAR) {\n+            if (classDef != null &&\n+                tree.sym.kind == VAR &&\n+                TreeInfo.isThisReference(types, (Type.ClassType)classDef.sym.type, tree.selected)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+import static com.sun.tools.javac.code.TypeTag.CLASS;\n@@ -213,0 +214,35 @@\n+    \/** Check if the given tree is a reference to the 'this' instance of the class\n+     *  'currentClass' which is currently being compiled. This is true if tree is:\n+     *  - An unqualified 'this' identifier\n+     *  - A 'super' identifier qualified by a class name whose type is 'currentClass' or a supertype\n+     *  - A 'this' identifier qualified by a class name whose type is 'currentClass' or a supertype\n+     *    but also NOT an enclosing outer class of 'currentClass'.\n+     *\/\n+    public static boolean isThisReference(Types types, Type.ClassType currentClass, JCTree tree) {\n+        switch (tree.getTag()) {\n+            case PARENS:\n+                return isThisReference(types, currentClass, skipParens(tree));\n+            case IDENT:\n+            {\n+                JCIdent ident = (JCIdent)tree;\n+                Names names = ident.name.table.names;\n+                return ident.name == names._this;\n+            }\n+            case SELECT:\n+            {\n+                JCFieldAccess select = (JCFieldAccess)tree;\n+                Type selectedType = types.erasure(select.selected.type);\n+                if (!selectedType.hasTag(CLASS))\n+                    return false;\n+                Type.ClassType selectecClassType = (Type.ClassType)selectedType;\n+                currentClass = (Type.ClassType)types.erasure(currentClass);\n+                Names names = select.name.table.names;\n+                return types.isSubtype(currentClass, selectecClassType) &&\n+                        (select.name == names._super ||\n+                        (select.name == names._this && !currentClass.isInnerClassOf(types, selectecClassType)));\n+            }\n+            default:\n+                return false;\n+        }\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -0,0 +1,15 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8193904\n+ * @summary Definite assignment required whether \"this.x\" or \"Foo.this.x\"\n+ *\n+ * @compile\/fail\/ref=QualifiedThis.out -XDrawDiagnostics QualifiedThis.java\n+ *\/\n+\n+class QualifiedThis {\n+    final int foo;\n+    QualifiedThis() {\n+        System.err.println(QualifiedThis.this.foo);\n+        this.foo = 42;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/DefiniteAssignment\/QualifiedThis.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+QualifiedThis.java:12:46: compiler.err.var.might.not.have.been.initialized: foo\n+1 error\n","filename":"test\/langtools\/tools\/javac\/DefiniteAssignment\/QualifiedThis.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"}]}