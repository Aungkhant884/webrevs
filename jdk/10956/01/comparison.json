{"files":[{"patch":"@@ -2339,0 +2339,17 @@\n+    \/** Determine whether the given outer class strictly encloses the inner one.\n+     *\/\n+    public boolean hasOuterClass(Type innerType, Type outerType) {\n+        if (!innerType.hasTag(CLASS) || !outerType.hasTag(CLASS))\n+            return false;\n+        innerType = erasure(innerType);\n+        outerType = erasure(outerType);\n+        for (Type type = innerType.getEnclosingType();\n+                type != null && type.hasTag(CLASS);\n+                type = type.getEnclosingType()) {\n+            if (erasure(type).equalsIgnoreMetadata(outerType)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -300,1 +300,1 @@\n-               TreeInfo.isThisQualifier(base)) &&\n+               TreeInfo.isExplicitThisReference(types, (ClassType)env.enclClass.sym.type, base)) &&\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2887,1 +2887,1 @@\n-            if (!TreeInfo.isIdentOrThisDotIdent(tree.lhs))\n+            if (!TreeInfo.isIdentOrThisDotIdent(types, (Type.ClassType)classDef.sym.type, tree.lhs))\n@@ -2893,1 +2893,1 @@\n-        \/\/ check fields accessed through this.<field> are definitely\n+        \/\/ check fields accessed through [<Type>.]this.<field> are definitely\n@@ -2897,2 +2897,3 @@\n-            if (TreeInfo.isThisQualifier(tree.selected) &&\n-                tree.sym.kind == VAR) {\n+            if (classDef != null &&\n+                tree.sym.kind == VAR &&\n+                TreeInfo.isExplicitThisReference(types, (Type.ClassType)classDef.sym.type, tree.selected)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+import static com.sun.tools.javac.code.TypeTag.CLASS;\n@@ -183,1 +184,2 @@\n-    \/** Is this tree a 'this' identifier?\n+    \/** Is this tree an identifier, possibly qualified by an explicit reference to the\n+     *  'this' instance of the class currently being compiled?\n@@ -185,1 +187,1 @@\n-    public static boolean isThisQualifier(JCTree tree) {\n+    public static boolean isIdentOrThisDotIdent(Types types, Type.ClassType currentClass, JCTree tree) {\n@@ -188,5 +190,5 @@\n-                return isThisQualifier(skipParens(tree));\n-            case IDENT: {\n-                JCIdent id = (JCIdent)tree;\n-                return id.name == id.name.table.names._this;\n-            }\n+                return isIdentOrThisDotIdent(types, currentClass, skipParens(tree));\n+            case IDENT:\n+                return true;\n+            case SELECT:\n+                return isExplicitThisReference(types, currentClass, ((JCFieldAccess)tree).selected);\n@@ -198,1 +200,6 @@\n-    \/** Is this tree an identifier, possibly qualified by 'this'?\n+    \/** Check if the given tree is an explicit reference to the 'this' instance of the\n+     *  class currently being compiled. This is true if tree is:\n+     *  - An unqualified 'this' identifier\n+     *  - A 'super' identifier qualified by a class name whose type is 'currentClass' or a supertype\n+     *  - A 'this' identifier qualified by a class name whose type is 'currentClass' or a supertype\n+     *    but also NOT an enclosing outer class of 'currentClass'.\n@@ -200,1 +207,1 @@\n-    public static boolean isIdentOrThisDotIdent(JCTree tree) {\n+    public static boolean isExplicitThisReference(Types types, Type.ClassType currentClass, JCTree tree) {\n@@ -203,1 +210,1 @@\n-                return isIdentOrThisDotIdent(skipParens(tree));\n+                return isExplicitThisReference(types, currentClass, skipParens(tree));\n@@ -205,1 +212,5 @@\n-                return true;\n+            {\n+                JCIdent ident = (JCIdent)tree;\n+                Names names = ident.name.table.names;\n+                return ident.name == names._this;\n+            }\n@@ -207,1 +218,12 @@\n-                return isThisQualifier(((JCFieldAccess)tree).selected);\n+            {\n+                JCFieldAccess select = (JCFieldAccess)tree;\n+                Type selectedType = types.erasure(select.selected.type);\n+                if (!selectedType.hasTag(CLASS))\n+                    return false;\n+                Type.ClassType selectecClassType = (Type.ClassType)selectedType;\n+                currentClass = (Type.ClassType)types.erasure(currentClass);\n+                Names names = select.name.table.names;\n+                return types.isSubtype(currentClass, selectecClassType) &&\n+                        (select.name == names._super ||\n+                        (select.name == names._this && !types.hasOuterClass(currentClass, selectecClassType)));\n+            }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":34,"deletions":12,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -0,0 +1,15 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8193904\n+ * @summary Definite assignment required whether \"this.x\" or \"Foo.this.x\"\n+ *\n+ * @compile\/fail\/ref=QualifiedThis.out -XDrawDiagnostics QualifiedThis.java\n+ *\/\n+\n+class QualifiedThis {\n+    final int foo;\n+    QualifiedThis() {\n+        System.err.println(QualifiedThis.this.foo);\n+        this.foo = 42;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/DefiniteAssignment\/QualifiedThis.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+QualifiedThis.java:12:46: compiler.err.var.might.not.have.been.initialized: foo\n+1 error\n","filename":"test\/langtools\/tools\/javac\/DefiniteAssignment\/QualifiedThis.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8193904\n+ * @summary Accept \"Foo.this.x\" as a valid definite assignment\n+ *\/\n+\n+public class QualifiedThis2 {\n+\n+    private final int foo;\n+\n+    public QualifiedThis2() {\n+        QualifiedThis2.this.foo = 42;\n+    }\n+\n+    public static void main(String[] args) {\n+        if (new QualifiedThis2().foo != 42)\n+            throw new AssertionError(\"fail\");\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/DefiniteAssignment\/QualifiedThis2.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"}]}