{"files":[{"patch":"@@ -1151,16 +1151,0 @@\n-        \/** Determine whether the given outer class strictly encloses this one.\n-         *\/\n-        public boolean isInnerClassOf(Types types, Type outerType) {\n-            if (!outerType.hasTag(CLASS))\n-                return false;\n-            outerType = types.erasure(outerType);\n-            for (Type type = getEnclosingType();\n-                    type != null && type.hasTag(CLASS);\n-                    type = type.getEnclosingType()) {\n-                if (types.erasure(type).equalsIgnoreMetadata(outerType)) {\n-                    return true;\n-                }\n-            }\n-            return false;\n-        }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Type.java","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2339,0 +2339,17 @@\n+    \/** Determine whether the given outer class strictly encloses the inner one.\n+     *\/\n+    public boolean hasOuterClass(Type innerType, Type outerType) {\n+        if (!innerType.hasTag(CLASS) || !outerType.hasTag(CLASS))\n+            return false;\n+        innerType = erasure(innerType);\n+        outerType = erasure(outerType);\n+        for (Type type = innerType.getEnclosingType();\n+                type != null && type.hasTag(CLASS);\n+                type = type.getEnclosingType()) {\n+            if (erasure(type).equalsIgnoreMetadata(outerType)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -300,1 +300,1 @@\n-               TreeInfo.isThisQualifier(base)) &&\n+               TreeInfo.isExplicitThisReference(types, (ClassType)env.enclClass.sym.type, base)) &&\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2887,1 +2887,1 @@\n-            if (!TreeInfo.isIdentOrThisDotIdent(tree.lhs))\n+            if (!TreeInfo.isIdentOrThisDotIdent(types, (Type.ClassType)classDef.sym.type, tree.lhs))\n@@ -2899,1 +2899,1 @@\n-                TreeInfo.isThisReference(types, (Type.ClassType)classDef.sym.type, tree.selected)) {\n+                TreeInfo.isExplicitThisReference(types, (Type.ClassType)classDef.sym.type, tree.selected)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -184,1 +184,2 @@\n-    \/** Is this tree a 'this' identifier?\n+    \/** Is this tree an identifier, possibly qualified by an explicit reference to the\n+     *  'this' instance of the class currently being compiled?\n@@ -186,1 +187,1 @@\n-    public static boolean isThisQualifier(JCTree tree) {\n+    public static boolean isIdentOrThisDotIdent(Types types, Type.ClassType currentClass, JCTree tree) {\n@@ -189,16 +190,1 @@\n-                return isThisQualifier(skipParens(tree));\n-            case IDENT: {\n-                JCIdent id = (JCIdent)tree;\n-                return id.name == id.name.table.names._this;\n-            }\n-            default:\n-                return false;\n-        }\n-    }\n-\n-    \/** Is this tree an identifier, possibly qualified by 'this'?\n-     *\/\n-    public static boolean isIdentOrThisDotIdent(JCTree tree) {\n-        switch (tree.getTag()) {\n-            case PARENS:\n-                return isIdentOrThisDotIdent(skipParens(tree));\n+                return isIdentOrThisDotIdent(types, currentClass, skipParens(tree));\n@@ -208,1 +194,1 @@\n-                return isThisQualifier(((JCFieldAccess)tree).selected);\n+                return isExplicitThisReference(types, currentClass, ((JCFieldAccess)tree).selected);\n@@ -214,2 +200,2 @@\n-    \/** Check if the given tree is a reference to the 'this' instance of the class\n-     *  'currentClass' which is currently being compiled. This is true if tree is:\n+    \/** Check if the given tree is an explicit reference to the 'this' instance of the\n+     *  class currently being compiled. This is true if tree is:\n@@ -221,1 +207,1 @@\n-    public static boolean isThisReference(Types types, Type.ClassType currentClass, JCTree tree) {\n+    public static boolean isExplicitThisReference(Types types, Type.ClassType currentClass, JCTree tree) {\n@@ -224,1 +210,1 @@\n-                return isThisReference(types, currentClass, skipParens(tree));\n+                return isExplicitThisReference(types, currentClass, skipParens(tree));\n@@ -242,1 +228,1 @@\n-                        (select.name == names._this && !currentClass.isInnerClassOf(types, selectecClassType)));\n+                        (select.name == names._this && !types.hasOuterClass(currentClass, selectecClassType)));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":10,"deletions":24,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8193904\n+ * @summary Accept \"Foo.this.x\" as a valid definite assignment\n+ *\/\n+\n+public class QualifiedThis2 {\n+\n+    private final int foo;\n+\n+    public QualifiedThis2() {\n+        QualifiedThis2.this.foo = 42;\n+    }\n+\n+    public static void main(String[] args) {\n+        if (new QualifiedThis2().foo != 42)\n+            throw new AssertionError(\"fail\");\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/DefiniteAssignment\/QualifiedThis2.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"}]}