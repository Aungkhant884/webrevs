{"files":[{"patch":"@@ -722,0 +722,1 @@\n+                SSLLogger.logKey(\"CLIENT_TRAFFIC_SECRET_0\", chc.clientHelloRandom, writeSecret);\n@@ -825,0 +826,1 @@\n+                SSLLogger.logKey(\"SERVER_TRAFFIC_SECRET_0\", shc.clientHelloRandom, writeSecret);\n@@ -983,0 +985,1 @@\n+                SSLLogger.logKey(\"SERVER_TRAFFIC_SECRET_0\", chc.clientHelloRandom, readSecret);\n@@ -1088,0 +1091,1 @@\n+                SSLLogger.logKey(\"CLIENT_TRAFFIC_SECRET_0\", shc.clientHelloRandom, readSecret);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/Finished.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.io.FileWriter;\n@@ -32,0 +33,1 @@\n+import java.io.Writer;\n@@ -35,0 +37,2 @@\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n@@ -46,0 +50,1 @@\n+import javax.crypto.SecretKey;\n@@ -66,0 +71,1 @@\n+    private static final Writer keyLogger;\n@@ -88,0 +94,41 @@\n+\n+        \/\/ Setting up the key log requires multiple privileged actions,\n+        \/\/ so it is better and easier to bundle them into a single PrivilegedAction block\n+        \/\/ 1. Getting the property\n+        \/\/ 2. Opening the file for writing\n+        \/\/ 3. Getting the process id for the header comment in the file\n+        keyLogger = AccessController.doPrivileged(new PrivilegedAction<Writer>(){\n+            public Writer run() {\n+                final String fileName = System.getProperty(\"javax.net.debug.keylog\");\n+                if (fileName == null) {\n+                    return null;\n+                }\n+                final long pid = ProcessHandle.current().pid();\n+\n+                Writer tempWriter = null;\n+                try {\n+                    tempWriter = new FileWriter(fileName, true);\n+\n+                    tempWriter.write(\"# Java TLS key logging started for PID \" + pid);\n+                    tempWriter.write(\". Started at \");\n+                    tempWriter.write(SSLSimpleFormatter.dateTimeFormat.format(Instant.now()));\n+                    tempWriter.write(\"\\n\");\n+                    tempWriter.flush();\n+                } catch (final IOException ex) {\n+                    if (logger != null) {\n+                        logger.log(Level.WARNING, \"Unable to create key logger\", ex);\n+                    } else {\n+                        ex.printStackTrace();\n+                    }\n+                    if (tempWriter != null) {\n+                        try {\n+                            tempWriter.close();\n+                        } catch (final IOException ignored) {\n+                            \/\/ Ignore exception when closing logger\n+                        }\n+                    }\n+                    tempWriter = null;\n+                }\n+                return tempWriter;\n+            }\n+        });\n@@ -118,0 +165,2 @@\n+        System.err.println(\"Key logging can be enabled with javax.net.debug.keylog=<filename>\");\n+        System.err.println();\n@@ -121,0 +170,20 @@\n+    public static void logKey(String label, RandomCookie clientRandom, SecretKey secret) {\n+        if (label == null || keyLogger == null || clientRandom == null || secret == null) {\n+            return;\n+        }\n+        synchronized (keyLogger) {\n+            try {\n+                keyLogger.append(label).append(' ');\n+                keyLogger.append(HexFormat.of().formatHex(clientRandom.randomBytes)).append(' ');\n+                keyLogger.append(HexFormat.of().formatHex(secret.getEncoded())).append('\\n');\n+                keyLogger.flush();\n+            } catch (final IOException ex) {\n+                if (logger != null) {\n+                    logger.log(Level.INFO, \"Could not log tls key\", ex);\n+                } else {\n+                    ex.printStackTrace();\n+                }\n+            }\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLLogger.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -141,0 +141,3 @@\n+    \/\/ Used for logging and to tie a session to data visible on the wire\n+    private RandomCookie clientHelloRandom;\n+\n@@ -162,0 +165,1 @@\n+        this.clientHelloRandom = null;\n@@ -217,0 +221,1 @@\n+        this.clientHelloRandom = hc.clientHelloRandom;\n@@ -237,0 +242,1 @@\n+        this.clientHelloRandom = baseSession.clientHelloRandom;\n@@ -339,0 +345,1 @@\n+        this.clientHelloRandom = hc.clientHelloRandom;\n@@ -378,0 +385,1 @@\n+            logMasterSecret();\n@@ -696,0 +704,7 @@\n+        logMasterSecret();\n+    }\n+\n+    private void logMasterSecret() {\n+        if (protocolVersion.compare(ProtocolVersion.TLS13) < 0) {\n+            SSLLogger.logKey(\"CLIENT_RANDOM\", this.clientHelloRandom, this.masterSecret);\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLSessionImpl.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -627,0 +627,1 @@\n+            SSLLogger.logKey(\"CLIENT_HANDSHAKE_TRAFFIC_SECRET\", shc.clientHelloRandom, readSecret);\n@@ -661,0 +662,1 @@\n+            SSLLogger.logKey(\"SERVER_HANDSHAKE_TRAFFIC_SECRET\", shc.clientHelloRandom, writeSecret);\n@@ -1311,0 +1313,1 @@\n+            SSLLogger.logKey(\"SERVER_HANDSHAKE_TRAFFIC_SECRET\", chc.clientHelloRandom, readSecret);\n@@ -1346,0 +1349,1 @@\n+            SSLLogger.logKey(\"CLIENT_HANDSHAKE_TRAFFIC_SECRET\", chc.clientHelloRandom, writeSecret);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/ServerHello.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,235 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8262880\n+ * @library \/test\/lib \/javax\/net\/ssl\/templates ..\/..\/\n+ * @summary Tests for TLS key logging in the proper format\n+ * @run main\/othervm KeyLogTest\n+ *\/\n+\n+\/*\n+ * This test runs in another process so we can examine the key log after process completion.\n+ *\/\n+\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.security.SecurityUtils;\n+\n+import javax.net.ssl.HostnameVerifier;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.SSLSession;\n+import javax.net.ssl.SSLSocket;\n+import java.io.BufferedReader;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.File;\n+import java.io.FileReader;\n+import java.net.InetAddress;\n+import java.net.URL;\n+import java.util.HashMap;\n+import java.util.regex.Pattern;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+public class KeyLogTest extends SSLSocketTemplate {\n+    KeyLogTest () {\n+        serverAddress = InetAddress.getLoopbackAddress();\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length != 0) {\n+            \/\/ A non-empty set of arguments occurs when the \"runTest\" argument\n+            \/\/ is passed to the test via ProcessTools::executeTestJvm.\n+            \/\/\n+            \/\/ This is done because an OutputAnalyzer is unable to read\n+            \/\/ the output of the current running JVM, and must therefore create\n+            \/\/ a test JVM. When this case occurs, it will inherit all specified\n+            \/\/ properties passed to the test JVM - debug flags, tls version, etc.\n+            new KeyLogTest().run();\n+        } else {\n+            \/\/ We are in the test JVM that the test is being ran in.\n+            var testSrc = \"-Dtest.src=\" + System.getProperty(\"test.src\");\n+            var keyLogFile = new File(System.getProperty(\"test.dir\", \".\"), \"keylog.txt\");\n+\n+            if (keyLogFile.exists()) {\n+                \/\/ Delete existing file to avoid having the test incorrectly fail\n+                keyLogFile.delete();\n+            }\n+            var javaxNetDebug = \"-Djavax.net.debug.keylog=\" + keyLogFile.getAbsolutePath();\n+\n+            var tlsVersions = new String[]{\"TLSv1.2\", \"TLSv1.3\"};\n+\n+            for (var tlsVersion : tlsVersions) {\n+                System.out.println(\"TESTING \" + tlsVersion);\n+                var activeTLSProtocol = \"-Djdk.tls.client.protocols=\" + tlsVersion;\n+                var output = ProcessTools.executeTestJvm(\n+                        testSrc,\n+                        activeTLSProtocol,\n+                        javaxNetDebug,\n+                        \"KeyLogTest\",\n+                        \"runTest\"); \/\/ Ensuring args.length is greater than 0 when test JVM starts\n+\n+                if (output.getExitValue() != 0) {\n+                    throw new RuntimeException(\"Test JVM process failed. JVM stderr= \" + output.getStderr());\n+                }\n+            }\n+\n+            validateFile(keyLogFile);\n+        }\n+    }\n+\n+    private static void validateFile(File keyLog) throws Exception {\n+        \/\/ The resulting file must have the following structure where the lines between the comments are unordered\n+        \/\/ and every line between the comments must show up exactly twice (though they are represented just once below)\n+        \/\/ Comment\n+        \/\/ CLIENT_RANDOM\n+        \/\/ Comment\n+        \/\/ CLIENT_HANDSHAKE_TRAFFIC_SECRET\n+        \/\/ SERVER_HANDSHAKE_TRAFFIC_SECRET\n+        \/\/ SERVER_TRAFFIC_SECRET_0\n+        \/\/ CLIENT_TRAFFIC_SECRET_0\n+        var pattern = Pattern.compile(\"([A-Z0-9_]+) ([a-f0-9]+) ([a-f0-9]+)\");\n+        try (final BufferedReader in = new BufferedReader(new FileReader(keyLog))) {\n+            \/\/ First line must be a comment\n+            var line = in.readLine();\n+            if (line.charAt(0) != '#') {\n+                throw new RuntimeException(\"First line of log file is not a comment\");\n+            }\n+            \/\/ Next two lines must both be equal and be of type CLIENT_RANDOM\n+            line = in.readLine();\n+            var matcher = pattern.matcher(line);\n+            if (!matcher.matches()) {\n+                throw new RuntimeException(\"Second line is not a valid key log\");\n+            }\n+            if (!matcher.group(1).equals(\"CLIENT_RANDOM\")) {\n+                throw new RuntimeException(\"Second line is not CLIENT_RANDOM\");\n+            }\n+            var thirdLine = in.readLine();\n+            if (!line.equals(thirdLine)) {\n+                throw new RuntimeException(\"Third line does not match second line\");\n+            }\n+\n+            \/\/ Fourth line is a comment from the second run (with TLS 1.3)\n+            line = in.readLine();\n+            if (line.charAt(0) != '#') {\n+                throw new RuntimeException(\"Fourth line of log file is not a comment\");\n+            }\n+\n+            \/\/ Now things become more complicated because we can't know the ordering for certain.\n+            \/\/ So we use a HashMap to track what we still need to see and what's already been found.\n+            \/\/ Each type will be seeded with an empty string. This indicates we haven't seen it yet.\n+            \/\/ When we see it for the first time, we replace the empty string with the value of that line.\n+            \/\/ The next time we see it (which we can tell becase the Map doesn't contain an empty string)\n+            \/\/ we compare it against the first. If they match, we remove the item from the map entirely.\n+            \/\/ At the end, the map must be empty for us to pass.\n+            \/\/ Additionally, the second element (client random) must be the same for all of them.\n+            var expectedEntries = new HashMap<String, String>();\n+            expectedEntries.put(\"CLIENT_HANDSHAKE_TRAFFIC_SECRET\", \"\");\n+            expectedEntries.put(\"SERVER_HANDSHAKE_TRAFFIC_SECRET\", \"\");\n+            expectedEntries.put(\"SERVER_TRAFFIC_SECRET_0\", \"\");\n+            expectedEntries.put(\"CLIENT_TRAFFIC_SECRET_0\", \"\");\n+            var clientRandom = \"\";\n+\n+            while ((line = in.readLine()) != null) {\n+                matcher = pattern.matcher(line);\n+                if (!matcher.matches()) {\n+                    throw new RuntimeException(\"Line is not a valid key log: \" + line);\n+                }\n+                var type = matcher.group(1);\n+                var newClientRandom = matcher.group(2);\n+                if (clientRandom.isEmpty()) {\n+                    clientRandom = newClientRandom;\n+                } else if (!clientRandom.equals(newClientRandom)) {\n+                    throw new RuntimeException(\"Unexpected change in client random\");\n+                }\n+                var oldValue = expectedEntries.put(type, line);\n+                if (oldValue == null) {\n+                    throw new RuntimeException(\"Unexpected type: \" + line);\n+                } else if (!oldValue.isEmpty()) {\n+                    if (!oldValue.equals(line)) {\n+                        throw new RuntimeException(\"Mismatched lines for type \" + type);\n+                    }\n+                    expectedEntries.remove(type);\n+                }\n+            }\n+\n+            if (!expectedEntries.isEmpty()) {\n+                throw new RuntimeException(\"Expected entries remaining: \" + expectedEntries.toString());\n+            }\n+        }\n+\n+    }\n+\n+    @Override\n+    protected boolean isCustomizedClientConnection() { return true; }\n+\n+    @Override\n+    protected void runServerApplication(SSLSocket socket) throws Exception {\n+        var response = \"Hello World!\";\n+        var out = new DataOutputStream(socket.getOutputStream());\n+        try {\n+            \/\/ We don't need to process the data from the socket\n+            \/\/ Simply sending a response right away is sufficient\n+            \/\/ to generate the desired debug output\n+            var responseBytes = response.getBytes(UTF_8);\n+\n+            out.writeBytes(\"HTTP\/1.0 200 OK\\r\\n\");\n+            out.writeBytes(\"Content-Length: \" + responseBytes.length + \"\\r\\n\");\n+            out.writeBytes(\"Content-Type: text\/html\\r\\n\\r\\n\");\n+            out.write(responseBytes);\n+            out.flush();\n+        } catch (IOException e) {\n+            out.writeBytes(\"HTTP\/1.0 400 \" + e.getMessage() + \"\\r\\n\");\n+            out.writeBytes(\"Content-Type: text\/html\\r\\n\\r\\n\");\n+            out.flush();\n+        }\n+    }\n+\n+    @Override\n+    protected void runClientApplication(int serverPort) throws Exception {\n+        var context = createClientSSLContext();\n+        HttpsURLConnection.setDefaultSSLSocketFactory(context.getSocketFactory());\n+        HttpsURLConnection.setDefaultHostnameVerifier(new NameVerifier());\n+\n+        var host = serverAddress == null ? \"localhost\" : serverAddress.getHostAddress();\n+        var url = new URL(\"https:\/\/\" + host + \":\" + serverPort + \"\/\");\n+        var httpsConnection = (HttpsURLConnection) url.openConnection();\n+        httpsConnection.disconnect();\n+        try (var in = new BufferedReader(new InputStreamReader(httpsConnection.getInputStream()))) {\n+            \/\/ Getting the input stream from the BufferedReader is sufficient to generate the desired debug output\n+            \/\/ We don't need to process the data\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static class NameVerifier implements HostnameVerifier {\n+        @Override\n+        public boolean verify(String s, SSLSession sslSession) {\n+            return true;\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLLogger\/KeyLogTest.java","additions":235,"deletions":0,"binary":false,"changes":235,"status":"added"}]}