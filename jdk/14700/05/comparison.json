{"files":[{"patch":"@@ -595,8 +595,3 @@\n-  Node* start = argument(4);\n-  Node* step  = argument(5);\n-\n-  if (shuffle_klass == nullptr || vlen == nullptr || start_val == nullptr || step_val == nullptr || wrap == nullptr) {\n-    return false; \/\/ dead code\n-  }\n-  if (!vlen->is_con() || !is_power_of_2(vlen->get_con()) ||\n-      shuffle_klass->const_oop() == nullptr || !wrap->is_con()) {\n+  if (shuffle_klass == nullptr || shuffle_klass->const_oop() == nullptr     ||\n+      vlen == nullptr || !vlen->is_con() || start_val == nullptr || step_val == nullptr ||\n+      wrap == nullptr || !wrap->is_con()) {\n@@ -605,0 +600,1 @@\n+\n@@ -616,2 +612,5 @@\n-  if (!arch_supports_vector(VectorNode::replicate_opcode(elem_bt), num_elem, elem_bt, VecMaskNotUsed)) {\n-    return false;\n+  bool effective_indices_in_range = false;\n+  if (start_val->is_con() && step_val->is_con()) {\n+    int effective_min_index = start_val->get_con();\n+    int effective_max_index = start_val->get_con() + step_val->get_con() * (num_elem - 1);\n+    effective_indices_in_range = effective_max_index >= effective_min_index && effective_min_index >= -128 && effective_max_index <= 127;\n@@ -619,4 +618,5 @@\n-  if (!arch_supports_vector(Op_AddVB, num_elem, elem_bt, VecMaskNotUsed)) {\n-    return false;\n-  }\n-  if (!arch_supports_vector(Op_AndV, num_elem, elem_bt, VecMaskNotUsed)) {\n+\n+  if (!do_wrap && !effective_indices_in_range) {\n+    \/\/ FIXME: disable instrinsification for unwrapped shuffle iota\n+    \/\/ if start\/step values are non-constant OR if intermediate result\n+    \/\/ overflows byte value range.\n@@ -625,1 +625,5 @@\n-  if (!arch_supports_vector(Op_VectorLoadConst, num_elem, elem_bt, VecMaskNotUsed)) {\n+\n+  if (!arch_supports_vector(Op_AddVB, num_elem, elem_bt, VecMaskNotUsed)           ||\n+      !arch_supports_vector(Op_AndV, num_elem, elem_bt, VecMaskNotUsed)            ||\n+      !arch_supports_vector(Op_VectorLoadConst, num_elem, elem_bt, VecMaskNotUsed) ||\n+      !arch_supports_vector(VectorNode::replicate_opcode(elem_bt), num_elem, elem_bt, VecMaskNotUsed)) {\n@@ -628,1 +632,5 @@\n-  if (!arch_supports_vector(Op_VectorBlend, num_elem, elem_bt, VecMaskUseLoad)) {\n+\n+  if (!do_wrap &&\n+      (!arch_supports_vector(Op_SubVB, num_elem, elem_bt, VecMaskNotUsed)       ||\n+      !arch_supports_vector(Op_VectorBlend, num_elem, elem_bt, VecMaskNotUsed)  ||\n+      !arch_supports_vector(Op_VectorMaskCmp, num_elem, elem_bt, VecMaskNotUsed))) {\n@@ -631,2 +639,10 @@\n-  if (!arch_supports_vector(Op_VectorMaskCmp, num_elem, elem_bt, VecMaskUseStore)) {\n-    return false;\n+\n+  bool step_multiply = !step_val->is_con() || !is_power_of_2(step_val->get_con());\n+  if(step_multiply) {\n+    if (!arch_supports_vector(Op_MulVB, num_elem, elem_bt, VecMaskNotUsed)) {\n+      return false;\n+    }\n+  } else {\n+    if (!arch_supports_vector(Op_LShiftVB, num_elem, elem_bt, VecMaskNotUsed)) {\n+      return false;\n+    }\n@@ -638,1 +654,1 @@\n-  Node* res =  gvn().transform(new VectorLoadConstNode(gvn().makecon(TypeInt::ZERO), vt));\n+  Node* res = gvn().transform(new VectorLoadConstNode(gvn().makecon(TypeInt::ZERO), vt));\n@@ -640,1 +656,4 @@\n-  if(!step_val->is_con() || !is_power_of_2(step_val->get_con())) {\n+  Node* start = argument(4);\n+  Node* step  = argument(5);\n+\n+  if(step_multiply) {\n@@ -642,1 +661,1 @@\n-    res = gvn().transform(VectorNode::make(Op_MulI, res, bcast_step, num_elem, elem_bt));\n+    res = gvn().transform(VectorNode::make(Op_MulVB, res, bcast_step, vt));\n@@ -651,1 +670,1 @@\n-    res = gvn().transform(VectorNode::make(Op_AddI, res, bcast_start, num_elem, elem_bt));\n+    res = gvn().transform(VectorNode::make(Op_AddVB, res, bcast_start, vt));\n@@ -656,0 +675,1 @@\n+\n@@ -658,1 +678,1 @@\n-    res = gvn().transform(VectorNode::make(Op_AndI, res, bcast_mod, num_elem, elem_bt));\n+     res = gvn().transform(VectorNode::make(Op_AndV, res, bcast_mod, vt));\n@@ -660,1 +680,1 @@\n-    ConINode* pred_node = (ConINode*)gvn().makecon(TypeInt::make(BoolTest::ge));\n+    ConINode* pred_node = (ConINode*)gvn().makecon(TypeInt::make(BoolTest::ugt));\n@@ -664,1 +684,1 @@\n-    Node* mask = gvn().transform(new VectorMaskCmpNode(BoolTest::ge, bcast_lane_cnt, res, pred_node, vmask_type));\n+    Node* mask = gvn().transform(new VectorMaskCmpNode(BoolTest::ugt, bcast_lane_cnt, res, pred_node, vmask_type));\n@@ -666,3 +686,3 @@\n-    \/\/ Make the indices greater than lane count as -ve values. This matches the java side implementation.\n-    res = gvn().transform(VectorNode::make(Op_AndI, res, bcast_mod, num_elem, elem_bt));\n-    Node * biased_val = gvn().transform(VectorNode::make(Op_SubI, res, bcast_lane_cnt, num_elem, elem_bt));\n+    \/\/ Make the indices greater than lane count as -ve values to match the java side implementation.\n+    res = gvn().transform(VectorNode::make(Op_AndV, res, bcast_mod, vt));\n+    Node * biased_val = gvn().transform(VectorNode::make(Op_SubVB, res, bcast_lane_cnt, vt));\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":48,"deletions":28,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +27,1 @@\n+import jdk.incubator.vector.ByteVector;\n@@ -27,0 +29,1 @@\n+import jdk.incubator.vector.ShortVector;\n@@ -34,1 +37,1 @@\n- * @run main\/othervm compiler.vectorapi.TestVectorShuffleIota\n+ * @run main\/othervm -XX:CompileThresholdScaling=0.3 -XX:-TieredCompilation compiler.vectorapi.TestVectorShuffleIota\n@@ -39,0 +42,2 @@\n+    static final VectorSpecies<Short> SPECIESs = ShortVector.SPECIES_128;\n+    static final VectorSpecies<Byte> SPECIESb = ByteVector.SPECIES_128;\n@@ -40,1 +45,1 @@\n-    static final int INVOC_COUNT = 50000;\n+    static final int INVOC_COUNT = 5000;\n@@ -44,0 +49,76 @@\n+    static long expected_value(VectorSpecies<?> SPECIES, int start, int step, boolean wrap) {\n+        long res = 0;\n+        int lanesM1 = SPECIES.length() - 1;\n+        if (wrap) {\n+            res = (lanesM1 & (start + step * lanesM1));\n+        } else {\n+            int effective_index = start + step * lanesM1;\n+            int wrapped_effective_index = effective_index & lanesM1;\n+            res = (effective_index == wrapped_effective_index ?\n+                   wrapped_effective_index :\n+                   -SPECIES.length() + wrapped_effective_index);\n+        }\n+        return res;\n+    }\n+\n+    static void validateTests(long actual, VectorSpecies<?> SPECIES, int start, int step, boolean wrap) {\n+        long expected = expected_value(SPECIES, start, step, wrap);\n+        if (actual != expected) {\n+            throw new AssertionError(\"Result Mismatch!, actual = \" + actual + \" expected = \" + expected);\n+        }\n+    }\n+\n+    static void testShuffleIotaB128(int start, int step, boolean wrap) {\n+        long res = SPECIESb.iotaShuffle(start, step, wrap)\n+                           .laneSource(SPECIESb.length()-1);\n+        validateTests(res, SPECIESb, start, step, wrap);\n+    }\n+\n+    static void testShuffleIotaS128(int start, int step, boolean wrap) {\n+        long res = SPECIESs.iotaShuffle(start, step, wrap)\n+                           .laneSource(SPECIESs.length()-1);\n+        validateTests(res, SPECIESs, start, step, wrap);\n+    }\n+\n+    static void testShuffleIotaI128(int start, int step, boolean wrap) {\n+        long res = SPECIESi.iotaShuffle(start, step, wrap)\n+                           .laneSource(SPECIESi.length()-1);\n+        validateTests(res, SPECIESi, start, step, wrap);\n+    }\n+\n+    static void testShuffleIotaConst0B128() {\n+        long res = SPECIESb.iotaShuffle(-32, 1, false)\n+                           .laneSource(SPECIESb.length()-1);\n+        validateTests(res, SPECIESb, -32, 1, false);\n+    }\n+\n+    static void testShuffleIotaConst0S128() {\n+        long res = SPECIESs.iotaShuffle(-32, 1, false)\n+                           .laneSource(SPECIESs.length()-1);\n+        validateTests(res, SPECIESs, -32, 1, false);\n+    }\n+\n+    static void testShuffleIotaConst0I128() {\n+        long res = SPECIESi.iotaShuffle(-32, 1, false)\n+                           .laneSource(SPECIESi.length()-1);\n+        validateTests(res, SPECIESi, -32, 1, false);\n+    }\n+\n+    static void testShuffleIotaConst1B128() {\n+        long res = SPECIESb.iotaShuffle(-32, 1, true)\n+                           .laneSource(SPECIESb.length()-1);\n+        validateTests(res, SPECIESb, -32, 1, true);\n+    }\n+\n+    static void testShuffleIotaConst1S128() {\n+        long res = SPECIESs.iotaShuffle(-32, 1, true)\n+                           .laneSource(SPECIESs.length()-1);\n+        validateTests(res, SPECIESs, -32, 1, true);\n+    }\n+\n+    static void testShuffleIotaConst1I128() {\n+        long res = SPECIESi.iotaShuffle(-32, 1, true)\n+                           .laneSource(SPECIESi.length()-1);\n+        validateTests(res, SPECIESi, -32, 1, true);\n+    }\n+\n@@ -56,0 +137,28 @@\n+        for (int i = 0; i < INVOC_COUNT; i++) {\n+            testShuffleIotaI128(128, 1, true);\n+            testShuffleIotaI128(128, 1, false);\n+            testShuffleIotaI128(-128, 1, true);\n+            testShuffleIotaI128(-128, 1, false);\n+            testShuffleIotaI128(1, 1, true);\n+            testShuffleIotaI128(1, 1, false);\n+\n+            testShuffleIotaS128(128, 1, true);\n+            testShuffleIotaS128(128, 1, false);\n+            testShuffleIotaS128(-128, 1, true);\n+            testShuffleIotaS128(-128, 1, false);\n+            testShuffleIotaS128(1, 1, true);\n+            testShuffleIotaS128(1, 1, false);\n+\n+            testShuffleIotaB128(128, 1, true);\n+            testShuffleIotaB128(128, 1, false);\n+            testShuffleIotaB128(-128, 1, true);\n+            testShuffleIotaB128(-128, 1, false);\n+            testShuffleIotaB128(1, 1, true);\n+            testShuffleIotaB128(1, 1, false);\n+            testShuffleIotaConst0B128();\n+            testShuffleIotaConst0S128();\n+            testShuffleIotaConst0I128();\n+            testShuffleIotaConst1B128();\n+            testShuffleIotaConst1S128();\n+            testShuffleIotaConst1I128();\n+        }\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestVectorShuffleIota.java","additions":111,"deletions":2,"binary":false,"changes":113,"status":"modified"}]}