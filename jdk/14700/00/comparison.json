{"files":[{"patch":"@@ -595,8 +595,3 @@\n-  Node* start = argument(4);\n-  Node* step  = argument(5);\n-\n-  if (shuffle_klass == nullptr || vlen == nullptr || start_val == nullptr || step_val == nullptr || wrap == nullptr) {\n-    return false; \/\/ dead code\n-  }\n-  if (!vlen->is_con() || !is_power_of_2(vlen->get_con()) ||\n-      shuffle_klass->const_oop() == nullptr || !wrap->is_con()) {\n+  if (shuffle_klass == NULL || shuffle_klass->const_oop() == NULL ||\n+      vlen == NULL || !vlen->is_con() || start_val == NULL || step_val == NULL ||\n+      wrap == NULL || !wrap->is_con()) {\n@@ -605,0 +600,1 @@\n+\n@@ -616,2 +612,5 @@\n-  if (!arch_supports_vector(VectorNode::replicate_opcode(elem_bt), num_elem, elem_bt, VecMaskNotUsed)) {\n-    return false;\n+  bool effective_indices_in_range = false;\n+  if (start_val->is_con() && step_val->is_con()) {\n+    int effective_min_index = start_val->get_con();\n+    int effective_max_index = start_val->get_con() + step_val->get_con() * (num_elem - 1);\n+    effective_indices_in_range = effective_min_index >= -128 && effective_max_index <= 127;\n@@ -619,4 +618,5 @@\n-  if (!arch_supports_vector(Op_AddVB, num_elem, elem_bt, VecMaskNotUsed)) {\n-    return false;\n-  }\n-  if (!arch_supports_vector(Op_AndV, num_elem, elem_bt, VecMaskNotUsed)) {\n+\n+  if (!do_wrap && !effective_indices_in_range) {\n+    \/\/ FIXME: disable instrinsification for unwrapped shuffle iota\n+    \/\/ if start\/step values are non-constant OR if intermediate result\n+    \/\/ overflows byte value range.\n@@ -625,1 +625,7 @@\n-  if (!arch_supports_vector(Op_VectorLoadConst, num_elem, elem_bt, VecMaskNotUsed)) {\n+\n+  bool step_multiply = !step_val->is_con() || !is_power_of_2(step_val->get_con());\n+\n+  if (!arch_supports_vector(Op_AddVB, num_elem, elem_bt, VecMaskNotUsed)           ||\n+      !arch_supports_vector(Op_AndV, num_elem, elem_bt, VecMaskNotUsed)            ||\n+      !arch_supports_vector(Op_VectorLoadConst, num_elem, elem_bt, VecMaskNotUsed) ||\n+      !arch_supports_vector(VectorNode::replicate_opcode(elem_bt), num_elem, elem_bt, VecMaskNotUsed)) {\n@@ -628,1 +634,5 @@\n-  if (!arch_supports_vector(Op_VectorBlend, num_elem, elem_bt, VecMaskUseLoad)) {\n+\n+  if (do_wrap &&\n+      !arch_supports_vector(Op_SubVB, num_elem, elem_bt, VecMaskNotUsed)        ||\n+      !arch_supports_vector(Op_VectorBlend, num_elem, elem_bt, VecMaskNotUsed)  ||\n+      !arch_supports_vector(Op_VectorMaskCmp, num_elem, elem_bt, VecMaskNotUsed)) {\n@@ -631,2 +641,9 @@\n-  if (!arch_supports_vector(Op_VectorMaskCmp, num_elem, elem_bt, VecMaskUseStore)) {\n-    return false;\n+\n+  if(step_multiply) {\n+    if (!arch_supports_vector(Op_MulVB, num_elem, elem_bt, VecMaskNotUsed)) {\n+      return false;\n+    }\n+  } else {\n+    if (!arch_supports_vector(Op_LShiftVB, num_elem, elem_bt, VecMaskNotUsed)) {\n+      return false;\n+    }\n@@ -640,1 +657,4 @@\n-  if(!step_val->is_con() || !is_power_of_2(step_val->get_con())) {\n+  Node* start = argument(4);\n+  Node* step  = argument(5);\n+\n+  if(step_multiply) {\n@@ -642,1 +662,1 @@\n-    res = gvn().transform(VectorNode::make(Op_MulI, res, bcast_step, num_elem, elem_bt));\n+    res = gvn().transform(VectorNode::make(Op_MulVB, res, bcast_step, vt));\n@@ -651,1 +671,1 @@\n-    res = gvn().transform(VectorNode::make(Op_AddI, res, bcast_start, num_elem, elem_bt));\n+    res = gvn().transform(VectorNode::make(Op_AddVB, res, bcast_start, vt));\n@@ -656,0 +676,1 @@\n+\n@@ -658,1 +679,1 @@\n-    res = gvn().transform(VectorNode::make(Op_AndI, res, bcast_mod, num_elem, elem_bt));\n+     res = gvn().transform(VectorNode::make(Op_AndV, res, bcast_mod, vt));\n@@ -660,1 +681,1 @@\n-    ConINode* pred_node = (ConINode*)gvn().makecon(TypeInt::make(BoolTest::ge));\n+    ConINode* pred_node = (ConINode*)gvn().makecon(TypeInt::make(BoolTest::gt));\n@@ -664,1 +685,1 @@\n-    Node* mask = gvn().transform(new VectorMaskCmpNode(BoolTest::ge, bcast_lane_cnt, res, pred_node, vmask_type));\n+    Node* mask = gvn().transform(new VectorMaskCmpNode(BoolTest::gt, bcast_lane_cnt, res, pred_node, vmask_type));\n@@ -666,3 +687,3 @@\n-    \/\/ Make the indices greater than lane count as -ve values. This matches the java side implementation.\n-    res = gvn().transform(VectorNode::make(Op_AndI, res, bcast_mod, num_elem, elem_bt));\n-    Node * biased_val = gvn().transform(VectorNode::make(Op_SubI, res, bcast_lane_cnt, num_elem, elem_bt));\n+    \/\/ Make the indices greater than lane count as -ve values to match the java side implementation.\n+    res = gvn().transform(VectorNode::make(Op_AndV, res, bcast_mod, vt));\n+    Node * biased_val = gvn().transform(VectorNode::make(Op_SubVB, res, bcast_lane_cnt, vt));\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":48,"deletions":27,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +27,1 @@\n+import jdk.incubator.vector.ByteVector;\n@@ -27,0 +29,1 @@\n+import jdk.incubator.vector.ShortVector;\n@@ -39,0 +42,2 @@\n+    static final VectorSpecies<Short> SPECIESs = ShortVector.SPECIES_128;\n+    static final VectorSpecies<Byte> SPECIESb = ByteVector.SPECIES_128;\n@@ -40,1 +45,1 @@\n-    static final int INVOC_COUNT = 50000;\n+    static final int INVOC_COUNT = 5000;\n@@ -44,0 +49,51 @@\n+    interface compute_kernel {\n+        long apply(int start, int step, boolean wrap);\n+    }\n+\n+    static void validateTests(compute_kernel agen, compute_kernel egen, int start, int step, boolean wrap) {\n+        long actual   = agen.apply(start, step, wrap);\n+        long expected = egen.apply(start, step, wrap);\n+        if (actual != expected) {\n+            throw new AssertionError(\"Result Mismatch!, actual = \" + actual + \" expected = \" + expected);\n+        }\n+    }\n+\n+    static void testShuffleIota (VectorSpecies<?> SPECIES, int start, int step, boolean wrap) {\n+        compute_kernel sobj = new compute_kernel()  {\n+            public long apply(int start, int step, boolean wrap) {\n+                long res = 0;\n+                int lanesM1 = SPECIES.length() - 1;\n+                if (wrap) {\n+                    for (int i = 0; i < 1024; i++) {\n+                        start += i;\n+                        res += (lanesM1 & (start + step * lanesM1)) * i;\n+                    }\n+                } else {\n+                    for (int i = 0; i < 1024; i++) {\n+                        start += i;\n+                        int effective_index = start + step * lanesM1;\n+                        int wrapped_effective_index = effective_index & lanesM1;\n+                        res += (effective_index == wrapped_effective_index ?\n+                                 wrapped_effective_index :\n+                                 -SPECIES.length() + wrapped_effective_index) * i;\n+                    }\n+                }\n+                return res;\n+            }\n+        };\n+\n+        compute_kernel vobj = new compute_kernel()  {\n+            public long apply(int start, int step, boolean wrap) {\n+                long res = 0;\n+                for (int i = 0; i < 1024; i++) {\n+                    start += i;\n+                    res += SPECIES.iotaShuffle(start, step, wrap)\n+                                  .laneSource(SPECIES.length()-1) * i;\n+                }\n+                return res;\n+            }\n+        };\n+\n+        validateTests(vobj, sobj, start, step, wrap);\n+    }\n+\n@@ -52,0 +108,21 @@\n+\n+            testShuffleIota(SPECIESi, 128, 1, true);\n+            testShuffleIota(SPECIESi, 128, 1, false);\n+            testShuffleIota(SPECIESi, -128, 1, true);\n+            testShuffleIota(SPECIESi, -128, 1, false);\n+            testShuffleIota(SPECIESi, 1, 1, true);\n+            testShuffleIota(SPECIESi, 1, 1, false);\n+\n+            testShuffleIota(SPECIESs, 128, 1, true);\n+            testShuffleIota(SPECIESs, 128, 1, false);\n+            testShuffleIota(SPECIESs, -128, 1, true);\n+            testShuffleIota(SPECIESs, -128, 1, false);\n+            testShuffleIota(SPECIESs, 1, 1, true);\n+            testShuffleIota(SPECIESs, 1, 1, false);\n+\n+            testShuffleIota(SPECIESb, 128, 1, true);\n+            testShuffleIota(SPECIESb, 128, 1, false);\n+            testShuffleIota(SPECIESb, -128, 1, true);\n+            testShuffleIota(SPECIESb, -128, 1, false);\n+            testShuffleIota(SPECIESb, 1, 1, true);\n+            testShuffleIota(SPECIESb, 1, 1, false);\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestVectorShuffleIota.java","additions":78,"deletions":1,"binary":false,"changes":79,"status":"modified"}]}