{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,0 +66,2 @@\n+import java.io.ObjectStreamException;\n+\n@@ -77,3 +79,4 @@\n- * Instances of this class are used to find the current instant, which can be\n- * interpreted using the stored time-zone to find the current date and time.\n- * As such, a clock can be used instead of {@link System#currentTimeMillis()}\n+ * Instances of this abstract class are used to access a pluggable representation of the\n+ * current instant, which can be interpreted using the stored time-zone to find the\n+ * current date and time.\n+ * For example, {@code Clock} can be used instead of {@link System#currentTimeMillis()}\n@@ -88,0 +91,4 @@\n+ * As such, this abstract class does not guarantee the result actually represents the current instant\n+ * on the time-line. Instead, it allows the application to provide a controlled view as to what\n+ * the current instant and time-zone are.\n+ * <p>\n@@ -89,2 +96,2 @@\n- * that requires the current instant. A dependency injection framework is one\n- * way to achieve this:\n+ * that requires the current instant and time-zone. A dependency injection framework\n+ * is one way to achieve this:\n@@ -102,1 +109,1 @@\n- * This approach allows an alternate clock, such as {@link #fixed(Instant, ZoneId) fixed}\n+ * This approach allows an alternative clock, such as {@link #fixed(Instant, ZoneId) fixed}\n@@ -106,1 +113,1 @@\n- * system clock This may use {@link System#currentTimeMillis()}, or a higher\n+ * system clock. This may use {@link System#currentTimeMillis()}, or a higher\n@@ -111,1 +118,2 @@\n- * All implementations that can be instantiated must be final, immutable and thread-safe.\n+ * All implementations must be thread-safe - a single instance must be capable of be invoked\n+ * from multiple threads without negative consequences such as race conditions.\n@@ -129,8 +137,1 @@\n- * @implNote\n- * The clock implementation provided here is based on the same underlying clock\n- * as {@link System#currentTimeMillis()}, but may have a precision finer than\n- * milliseconds if available.\n- * However, little to no guarantee is provided about the accuracy of the\n- * underlying clock. Applications requiring a more accurate clock must implement\n- * this abstract class themselves using a different external clock, such as an\n- * NTP server.\n+ * @see InstantSource\n@@ -140,1 +141,1 @@\n-public abstract class Clock {\n+public abstract class Clock implements InstantSource {\n@@ -357,1 +358,1 @@\n-     * specified duration added\n+     * specified duration added.\n@@ -411,0 +412,1 @@\n+    @Override\n@@ -431,0 +433,1 @@\n+    @Override\n@@ -444,0 +447,1 @@\n+    @Override\n@@ -476,0 +480,100 @@\n+    \/\/-----------------------------------------------------------------------\n+    \/\/ initial offset\n+    private static final long OFFSET_SEED = System.currentTimeMillis() \/ 1000 - 1024;\n+    \/\/ We don't actually need a volatile here.\n+    \/\/ We don't care if offset is set or read concurrently by multiple\n+    \/\/ threads - we just need a value which is 'recent enough' - in other\n+    \/\/ words something that has been updated at least once in the last\n+    \/\/ 2^32 secs (~136 years). And even if we by chance see an invalid\n+    \/\/ offset, the worst that can happen is that we will get a -1 value\n+    \/\/ from getNanoTimeAdjustment, forcing us to update the offset\n+    \/\/ once again.\n+    private static long offset = OFFSET_SEED;\n+\n+    static Instant currentInstant() {\n+        \/\/ Take a local copy of offset. offset can be updated concurrently\n+        \/\/ by other threads (even if we haven't made it volatile) so we will\n+        \/\/ work with a local copy.\n+        long localOffset = offset;\n+        long adjustment = VM.getNanoTimeAdjustment(localOffset);\n+\n+        if (adjustment == -1) {\n+            \/\/ -1 is a sentinel value returned by VM.getNanoTimeAdjustment\n+            \/\/ when the offset it is given is too far off the current UTC\n+            \/\/ time. In principle, this should not happen unless the\n+            \/\/ JVM has run for more than ~136 years (not likely) or\n+            \/\/ someone is fiddling with the system time, or the offset is\n+            \/\/ by chance at 1ns in the future (very unlikely).\n+            \/\/ We can easily recover from all these conditions by bringing\n+            \/\/ back the offset in range and retry.\n+\n+            \/\/ bring back the offset in range. We use -1024 to make\n+            \/\/ it more unlikely to hit the 1ns in the future condition.\n+            localOffset = System.currentTimeMillis()\/1000 - 1024;\n+\n+            \/\/ retry\n+            adjustment = VM.getNanoTimeAdjustment(localOffset);\n+\n+            if (adjustment == -1) {\n+                \/\/ Should not happen: we just recomputed a new offset.\n+                \/\/ It should have fixed the issue.\n+                throw new InternalError(\"Offset \" + localOffset + \" is not in range\");\n+            } else {\n+                \/\/ OK - recovery succeeded. Update the offset for the\n+                \/\/ next call...\n+                offset = localOffset;\n+            }\n+        }\n+        return Instant.ofEpochSecond(localOffset, adjustment);\n+    }\n+\n+    \/\/-----------------------------------------------------------------------\n+    \/**\n+     * An instant source that always returns the latest time from\n+     * {@link System#currentTimeMillis()} or equivalent.\n+     *\/\n+    static final class SystemInstantSource implements InstantSource, Serializable {\n+        @java.io.Serial\n+        private static final long serialVersionUID = 3232399674412L;\n+        \/\/ this is a singleton, but the class is coded such that it is not a\n+        \/\/ problem if someone hacks around and creates another instance\n+        static final SystemInstantSource INSTANCE = new SystemInstantSource();\n+\n+        SystemInstantSource() {\n+        }\n+        @Override\n+        public Clock withZone(ZoneId zone) {\n+            return Clock.system(zone);\n+        }\n+        @Override\n+        public long millis() {\n+            \/\/ System.currentTimeMillis() and VM.getNanoTimeAdjustment(offset)\n+            \/\/ use the same time source - System.currentTimeMillis() simply\n+            \/\/ limits the resolution to milliseconds.\n+            \/\/ So we take the faster path and call System.currentTimeMillis()\n+            \/\/ directly - in order to avoid the performance penalty of\n+            \/\/ VM.getNanoTimeAdjustment(offset) which is less efficient.\n+            return System.currentTimeMillis();\n+        }\n+        @Override\n+        public Instant instant() {\n+            return currentInstant();\n+        }\n+        @Override\n+        public boolean equals(Object obj) {\n+            return obj instanceof SystemInstantSource;\n+        }\n+        @Override\n+        public int hashCode() {\n+            return SystemInstantSource.class.hashCode();\n+        }\n+        @Override\n+        public String toString() {\n+            return \"SystemInstantSource\";\n+        }\n+        @java.io.Serial\n+        private Object readResolve() throws ObjectStreamException {\n+            return SystemInstantSource.INSTANCE;\n+        }\n+    }\n+\n@@ -479,1 +583,1 @@\n-     * {@link System#currentTimeMillis()}.\n+     * {@code SystemInstantSource.INSTANCE}.\n@@ -484,2 +588,0 @@\n-        private static final long OFFSET_SEED =\n-                System.currentTimeMillis()\/1000 - 1024; \/\/ initial offest\n@@ -489,9 +591,0 @@\n-        \/\/ We don't actually need a volatile here.\n-        \/\/ We don't care if offset is set or read concurrently by multiple\n-        \/\/ threads - we just need a value which is 'recent enough' - in other\n-        \/\/ words something that has been updated at least once in the last\n-        \/\/ 2^32 secs (~136 years). And even if we by chance see an invalid\n-        \/\/ offset, the worst that can happen is that we will get a -1 value\n-        \/\/ from getNanoTimeAdjustment, forcing us to update the offset\n-        \/\/ once again.\n-        private transient long offset;\n@@ -501,1 +594,0 @@\n-            this.offset = OFFSET_SEED;\n@@ -516,6 +608,1 @@\n-            \/\/ System.currentTimeMillis() and VM.getNanoTimeAdjustment(offset)\n-            \/\/ use the same time source - System.currentTimeMillis() simply\n-            \/\/ limits the resolution to milliseconds.\n-            \/\/ So we take the faster path and call System.currentTimeMillis()\n-            \/\/ directly - in order to avoid the performance penalty of\n-            \/\/ VM.getNanoTimeAdjustment(offset) which is less efficient.\n+            \/\/ inline of SystemInstantSource.INSTANCE.millis()\n@@ -526,34 +613,2 @@\n-            \/\/ Take a local copy of offset. offset can be updated concurrently\n-            \/\/ by other threads (even if we haven't made it volatile) so we will\n-            \/\/ work with a local copy.\n-            long localOffset = offset;\n-            long adjustment = VM.getNanoTimeAdjustment(localOffset);\n-\n-            if (adjustment == -1) {\n-                \/\/ -1 is a sentinel value returned by VM.getNanoTimeAdjustment\n-                \/\/ when the offset it is given is too far off the current UTC\n-                \/\/ time. In principle, this should not happen unless the\n-                \/\/ JVM has run for more than ~136 years (not likely) or\n-                \/\/ someone is fiddling with the system time, or the offset is\n-                \/\/ by chance at 1ns in the future (very unlikely).\n-                \/\/ We can easily recover from all these conditions by bringing\n-                \/\/ back the offset in range and retry.\n-\n-                \/\/ bring back the offset in range. We use -1024 to make\n-                \/\/ it more unlikely to hit the 1ns in the future condition.\n-                localOffset = System.currentTimeMillis()\/1000 - 1024;\n-\n-                \/\/ retry\n-                adjustment = VM.getNanoTimeAdjustment(localOffset);\n-\n-                if (adjustment == -1) {\n-                    \/\/ Should not happen: we just recomputed a new offset.\n-                    \/\/ It should have fixed the issue.\n-                    throw new InternalError(\"Offset \" + localOffset + \" is not in range\");\n-                } else {\n-                    \/\/ OK - recovery succeeded. Update the offset for the\n-                    \/\/ next call...\n-                    offset = localOffset;\n-                }\n-            }\n-            return Instant.ofEpochSecond(localOffset, adjustment);\n+            \/\/ inline of SystemInstantSource.INSTANCE.instant()\n+            return currentInstant();\n@@ -576,7 +631,0 @@\n-        @java.io.Serial\n-        private void readObject(ObjectInputStream is)\n-                throws IOException, ClassNotFoundException {\n-            \/\/ ensure that offset is initialized\n-            is.defaultReadObject();\n-            offset = OFFSET_SEED;\n-        }\n@@ -687,1 +735,1 @@\n-     * Implementation of a clock that adds an offset to an underlying clock.\n+     * Implementation of a clock that reduces the tick frequency of an underlying clock.\n@@ -743,0 +791,50 @@\n+    \/\/-----------------------------------------------------------------------\n+    \/**\n+     * Implementation of a clock based on an {@code InstantSource}.\n+     *\/\n+    static final class SourceClock extends Clock implements Serializable {\n+        @java.io.Serial\n+        private static final long serialVersionUID = 235386528762398L;\n+        @SuppressWarnings(\"serial\") \/\/ Not statically typed as Serializable\n+        private final InstantSource baseSource;\n+        private final ZoneId zone;\n+\n+        SourceClock(InstantSource baseSource, ZoneId zone) {\n+            this.baseSource = baseSource;\n+            this.zone = zone;\n+        }\n+        @Override\n+        public ZoneId getZone() {\n+            return zone;\n+        }\n+        @Override\n+        public Clock withZone(ZoneId zone) {\n+            if (zone.equals(this.zone)) {  \/\/ intentional NPE\n+                return this;\n+            }\n+            return new SourceClock(baseSource, zone);\n+        }\n+        @Override\n+        public long millis() {\n+            return baseSource.millis();\n+        }\n+        @Override\n+        public Instant instant() {\n+            return baseSource.instant();\n+        }\n+        @Override\n+        public boolean equals(Object obj) {\n+            return (obj instanceof SourceClock other)\n+                    && zone.equals(other.zone)\n+                    && baseSource.equals(other.baseSource);\n+        }\n+        @Override\n+        public int hashCode() {\n+            return baseSource.hashCode() ^ zone.hashCode();\n+        }\n+        @Override\n+        public String toString() {\n+            return \"SourceClock[\" + baseSource + \",\" + zone + \"]\";\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/time\/Clock.java","additions":178,"deletions":80,"binary":false,"changes":258,"status":"modified"},{"patch":"@@ -275,1 +275,1 @@\n-        return Clock.systemUTC().instant();\n+        return Clock.currentInstant();\n","filename":"src\/java.base\/share\/classes\/java\/time\/Instant.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,248 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package java.time;\n+\n+import java.time.Clock.SourceClock;\n+import java.time.Clock.SystemInstantSource;\n+import java.util.Objects;\n+\n+\/**\n+ * Provides access to the current instant.\n+ * <p>\n+ * Instances of this interface are used to access a pluggable representation of the current instant.\n+ * For example, {@code InstantSource} can be used instead of {@link System#currentTimeMillis()}.\n+ * <p>\n+ * The primary purpose of this abstraction is to allow alternate instant sources to be\n+ * plugged in as and when required. Applications use an object to obtain the\n+ * current time rather than a static method. This can simplify testing.\n+ * <p>\n+ * As such, this interface does not guarantee the result actually represents the current instant\n+ * on the time-line. Instead, it allows the application to provide a controlled view as to what\n+ * the current instant is.\n+ * <p>\n+ * Best practice for applications is to pass an {@code InstantSource} into any method\n+ * that requires the current instant. A dependency injection framework is one\n+ * way to achieve this:\n+ * <pre>\n+ *  public class MyBean {\n+ *    private InstantSource source;  \/\/ dependency inject\n+ *    ...\n+ *    public void process(Instant endInstant) {\n+ *      if (source.instant().isAfter(endInstant) {\n+ *        ...\n+ *      }\n+ *    }\n+ *  }\n+ * <\/pre>\n+ * This approach allows an alternative source, such as {@link #fixed(Instant) fixed}\n+ * or {@link #offset(InstantSource, Duration) offset} to be used during testing.\n+ * <p>\n+ * The {@code system} factory method provides a source based on the best available\n+ * system clock. This may use {@link System#currentTimeMillis()}, or a higher\n+ * resolution clock if one is available.\n+ *\n+ * @implSpec\n+ * This interface must be implemented with care to ensure other classes operate correctly.\n+ * All implementations must be thread-safe - a single instance must be capable of be invoked\n+ * from multiple threads without negative consequences such as race conditions.\n+ * <p>\n+ * The principal methods are defined to allow the throwing of an exception.\n+ * In normal use, no exceptions will be thrown, however one possible implementation would be to\n+ * obtain the time from a central time server across the network. Obviously, in this case the\n+ * lookup could fail, and so the method is permitted to throw an exception.\n+ * <p>\n+ * The returned instants from {@code InstantSource} work on a time-scale that ignores leap seconds,\n+ * as described in {@link Instant}. If the implementation wraps a source that provides leap\n+ * second information, then a mechanism should be used to \"smooth\" the leap second.\n+ * The Java Time-Scale mandates the use of UTC-SLS, however implementations may choose\n+ * how accurate they are with the time-scale so long as they document how they work.\n+ * Implementations are therefore not required to actually perform the UTC-SLS slew or to\n+ * otherwise be aware of leap seconds.\n+ * <p>\n+ * Implementations should implement {@code Serializable} wherever possible and must\n+ * document whether or not they do support serialization.\n+ *\n+ * @implNote\n+ * The implementation provided here is based on the same underlying system clock\n+ * as {@link System#currentTimeMillis()}, but may have a precision finer than\n+ * milliseconds if available.\n+ * However, little to no guarantee is provided about the accuracy of the\n+ * underlying system clock. Applications requiring a more accurate system clock must\n+ * implement this abstract class themselves using a different external system clock,\n+ * such as an NTP server.\n+ *\n+ * @since 17\n+ *\/\n+public interface InstantSource {\n+\n+    \/**\n+     * Obtains a source that returns the current instant using the best available\n+     * system clock.\n+     * <p>\n+     * This source is based on the best available system clock. This may use\n+     * {@link System#currentTimeMillis()}, or a higher resolution system clock if\n+     * one is available.\n+     * <p>\n+     * The returned implementation is immutable, thread-safe and\n+     * {@code Serializable}.\n+     *\n+     * @return a source that uses the best available system clock, not null\n+     *\/\n+    static InstantSource system() {\n+        return SystemInstantSource.INSTANCE;\n+    }\n+\n+    \/\/-------------------------------------------------------------------------\n+    \/**\n+     * Obtains a source that returns instants from the specified source truncated to\n+     * the nearest occurrence of the specified duration.\n+     * <p>\n+     * This source will only tick as per the specified duration. Thus, if the\n+     * duration is half a second, the source will return instants truncated to the\n+     * half second.\n+     * <p>\n+     * The tick duration must be positive. If it has a part smaller than a whole\n+     * millisecond, then the whole duration must divide into one second without\n+     * leaving a remainder. All normal tick durations will match these criteria,\n+     * including any multiple of hours, minutes, seconds and milliseconds, and\n+     * sensible nanosecond durations, such as 20ns, 250,000ns and 500,000ns.\n+     * <p>\n+     * A duration of zero or one nanosecond would have no truncation effect. Passing\n+     * one of these will return the underlying source.\n+     * <p>\n+     * Implementations may use a caching strategy for performance reasons. As such,\n+     * it is possible that the start of the requested duration observed via this\n+     * source will be later than that observed directly via the underlying source.\n+     * <p>\n+     * The returned implementation is immutable, thread-safe and\n+     * {@code Serializable} providing that the base source is.\n+     *\n+     * @param baseSource  the base source to base the ticking source on, not null\n+     * @param tickDuration  the duration of each visible tick, not negative, not null\n+     * @return a source that ticks in whole units of the duration, not null\n+     * @throws IllegalArgumentException if the duration is negative, or has a\n+     *  part smaller than a whole millisecond such that the whole duration is not\n+     *  divisible into one second\n+     * @throws ArithmeticException if the duration is too large to be represented as nanos\n+     *\/\n+    static InstantSource tick(InstantSource baseSource, Duration tickDuration) {\n+        Objects.requireNonNull(baseSource, \"baseSource\");\n+        return Clock.tick(baseSource.withZone(ZoneOffset.UTC), tickDuration);\n+    }\n+\n+    \/\/-----------------------------------------------------------------------\n+    \/**\n+     * Obtains a source that always returns the same instant.\n+     * <p>\n+     * This source simply returns the specified instant.\n+     * As such, it is not a source that represents the current instant.\n+     * The main use case for this is in testing, where the fixed source ensures\n+     * tests are not dependent on the current source.\n+     * <p>\n+     * The returned implementation is immutable, thread-safe and {@code Serializable}.\n+     *\n+     * @param fixedInstant  the instant to use, not null\n+     * @return a source that always returns the same instant, not null\n+     *\/\n+    static InstantSource fixed(Instant fixedInstant) {\n+        return Clock.fixed(fixedInstant, ZoneOffset.UTC);\n+    }\n+\n+    \/\/-------------------------------------------------------------------------\n+    \/**\n+     * Obtains a source that returns instants from the specified source with the\n+     * specified duration added.\n+     * <p>\n+     * This source wraps another source, returning instants that are later by the\n+     * specified duration. If the duration is negative, the instants will be\n+     * earlier than the current date and time.\n+     * The main use case for this is to simulate running in the future or in the past.\n+     * <p>\n+     * A duration of zero would have no offsetting effect.\n+     * Passing zero will return the underlying source.\n+     * <p>\n+     * The returned implementation is immutable, thread-safe and {@code Serializable}\n+     * providing that the base source is.\n+     *\n+     * @param baseSource  the base source to add the duration to, not null\n+     * @param offsetDuration  the duration to add, not null\n+     * @return a source based on the base source with the duration added, not null\n+     *\/\n+    static InstantSource offset(InstantSource baseSource, Duration offsetDuration) {\n+        Objects.requireNonNull(baseSource, \"baseSource\");\n+        return Clock.offset(baseSource.withZone(ZoneOffset.UTC), offsetDuration);\n+    }\n+\n+    \/\/-----------------------------------------------------------------------\n+    \/**\n+     * Gets the current instant of the source.\n+     * <p>\n+     * This returns an instant representing the current instant as defined by the source.\n+     *\n+     * @return the current instant from this source, not null\n+     * @throws DateTimeException if the instant cannot be obtained, not thrown by most implementations\n+     *\/\n+    Instant instant();\n+\n+    \/\/-------------------------------------------------------------------------\n+    \/**\n+     * Gets the current millisecond instant of the source.\n+     * <p>\n+     * This returns the millisecond-based instant, measured from 1970-01-01T00:00Z (UTC).\n+     * This is equivalent to the definition of {@link System#currentTimeMillis()}.\n+     * <p>\n+     * Most applications should avoid this method and use {@link Instant} to represent\n+     * an instant on the time-line rather than a raw millisecond value.\n+     * This method is provided to allow the use of the source in high performance use cases\n+     * where the creation of an object would be unacceptable.\n+     * <p>\n+     * The default implementation calls {@link #instant()}.\n+     *\n+     * @return the current millisecond instant from this source, measured from\n+     *  the Java epoch of 1970-01-01T00:00Z (UTC), not null\n+     * @throws DateTimeException if the instant cannot be obtained, not thrown by most implementations\n+     *\/\n+    default long millis() {\n+        return instant().toEpochMilli();\n+    }\n+\n+    \/\/-----------------------------------------------------------------------\n+    \/**\n+     * Returns a clock with the specified time-zone.\n+     * <p>\n+     * This returns a {@link Clock}, which is an extension of this interface\n+     * that combines this source and the specified time-zone.\n+     * <p>\n+     * The returned implementation is immutable, thread-safe and {@code Serializable}\n+     * providing that this source is.\n+     *\n+     * @param zone  the time-zone to use, not null\n+     * @return a clock based on this source with the specified time-zone, not null\n+     *\/\n+    default Clock withZone(ZoneId zone) {\n+        return new SourceClock(this, zone);\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/java\/time\/InstantSource.java","additions":248,"deletions":0,"binary":false,"changes":248,"status":"added"},{"patch":"@@ -0,0 +1,121 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package test.java.time;\n+\n+import static java.time.temporal.ChronoUnit.SECONDS;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertSame;\n+import static org.testng.Assert.assertTrue;\n+\n+import java.lang.reflect.Field;\n+import java.time.Clock;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.time.InstantSource;\n+import java.time.ZoneId;\n+import java.time.ZoneOffset;\n+\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+\/**\n+ * Test instant source.\n+ *\/\n+@Test\n+public class TestInstantSource {\n+\n+    private static final ZoneId PARIS = ZoneId.of(\"Europe\/Paris\");\n+\n+    public void test_system() {\n+        \/\/ main tests for Clock.currentInstant() are in TestClock_System\n+        var test = InstantSource.system();\n+        assertSame(test.withZone(ZoneOffset.UTC), Clock.systemUTC());\n+        assertEquals(test.withZone(PARIS), Clock.system(PARIS));\n+        var millis = System.currentTimeMillis();\n+        var testMillis = test.millis();\n+        var testInstantMillis = test.instant().toEpochMilli();\n+        assertTrue(Math.abs(testMillis - millis) < 1000);\n+        assertTrue(Math.abs(testInstantMillis - millis) < 1000);\n+        assertSame(test.equals(InstantSource.system());\n+        assertEquals(test.hashCode(), InstantSource.system().hashCode());\n+        assertEquals(test.toString(), \"SystemInstantSource\");\n+    }\n+\n+    public void test_tick() {\n+        var millis = 257265861691L;\n+        var instant = Instant.ofEpochMilli(millis);\n+        var duration = Duration.ofSeconds(1);\n+        var test = InstantSource.tick(InstantSource.fixed(instant), duration);\n+        assertEquals(test.withZone(ZoneOffset.UTC), Clock.tick(Clock.fixed(instant, ZoneOffset.UTC), duration));\n+        assertEquals(test.withZone(PARIS), Clock.tick(Clock.fixed(instant, PARIS), duration));\n+        assertEquals(test.millis(), (millis \/ 1000) * 1000);\n+        assertEquals(test.instant(), instant.truncatedTo(SECONDS));\n+        assertSame(test.equals(InstantSource.tick(InstantSource.fixed(instant), duration));\n+        assertEquals(test.hashCode(), InstantSource.tick(InstantSource.fixed(instant), duration).hashCode());\n+    }\n+\n+    public void test_fixed() {\n+        var millis = 257265861691L;\n+        var instant = Instant.ofEpochMilli(millis);\n+        var test = InstantSource.fixed(instant);\n+        assertEquals(test.withZone(ZoneOffset.UTC), Clock.fixed(instant, ZoneOffset.UTC));\n+        assertEquals(test.withZone(PARIS), Clock.fixed(instant, PARIS));\n+        assertEquals(test.millis(), millis);\n+        assertEquals(test.instant(), instant);\n+        assertSame(test.equals(InstantSource..fixed(instant));\n+        assertEquals(test.hashCode(), InstantSource..fixed(instant).hashCode());\n+    }\n+\n+    public void test_offset() {\n+        var millis = 257265861691L;\n+        var instant = Instant.ofEpochMilli(millis);\n+        var duration = Duration.ofSeconds(120);\n+        var test = InstantSource.offset(InstantSource.fixed(instant), duration);\n+        assertEquals(test.withZone(ZoneOffset.UTC), Clock.offset(Clock.fixed(instant, ZoneOffset.UTC), duration));\n+        assertEquals(test.withZone(PARIS), Clock.offset(Clock.fixed(instant, PARIS), duration));\n+        assertEquals(test.millis(), millis + 120_000);\n+        assertEquals(test.instant(), instant.plusSeconds(120));\n+        assertSame(test.equals(InstantSource.offset(InstantSource.fixed(instant), duration));\n+        assertEquals(test.hashCode(), InstantSource.offset(InstantSource.fixed(instant), duration).hashCode());\n+    }\n+\n+    static class MockInstantSource implements InstantSource {\n+        static final Instant FIXED = Instant.now();\n+\n+        public Instant instant() {\n+            return FIXED;\n+        }\n+    }\n+\n+    public void test_mock() {\n+        var test = new MockInstantSource();\n+        assertEquals(test.withZone(ZoneOffset.UTC).getZone(), ZoneOffset.UTC);\n+        assertEquals(test.withZone(PARIS).getZone(), PARIS);\n+        assertEquals(test.withZone(ZoneOffset.UTC).withZone(PARIS).getZone(), PARIS);\n+        assertEquals(test.millis(), MockInstantSource.FIXED.toEpochMilli());\n+        assertEquals(test.instant(), MockInstantSource.FIXED);\n+        assertSame(test.withZone(ZoneOffset.UTC).equals(test.withZone(ZoneOffset.UTC)));\n+        assertEquals(test.withZone(ZoneOffset.UTC).hashCode(), test.withZone(ZoneOffset.UTC).hashCode());\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/time\/test\/java\/time\/TestInstantSource.java","additions":121,"deletions":0,"binary":false,"changes":121,"status":"added"}]}