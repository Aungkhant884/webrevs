{"files":[{"patch":"@@ -1375,44 +1375,1 @@\n-struct _address_to_library_name {\n-  address addr;          \/\/ input : memory address\n-  size_t  buflen;        \/\/         size of fname\n-  char*   fname;         \/\/ output: library name\n-  address base;          \/\/         library base addr\n-};\n-\n-static int address_to_library_name_callback(struct dl_phdr_info *info,\n-                                            size_t size, void *data) {\n-  int i;\n-  bool found = false;\n-  address libbase = NULL;\n-  struct _address_to_library_name * d = (struct _address_to_library_name *)data;\n-\n-  \/\/ iterate through all loadable segments\n-  for (i = 0; i < info->dlpi_phnum; i++) {\n-    address segbase = (address)(info->dlpi_addr + info->dlpi_phdr[i].p_vaddr);\n-    if (info->dlpi_phdr[i].p_type == PT_LOAD) {\n-      \/\/ base address of a library is the lowest address of its loaded\n-      \/\/ segments.\n-      if (libbase == NULL || libbase > segbase) {\n-        libbase = segbase;\n-      }\n-      \/\/ see if 'addr' is within current segment\n-      if (segbase <= d->addr &&\n-          d->addr < segbase + info->dlpi_phdr[i].p_memsz) {\n-        found = true;\n-      }\n-    }\n-  }\n-\n-  \/\/ dlpi_name is NULL or empty if the ELF file is executable, return 0\n-  \/\/ so dll_address_to_library_name() can fall through to use dladdr() which\n-  \/\/ can figure out executable name from argv[0].\n-  if (found && info->dlpi_name && info->dlpi_name[0]) {\n-    d->base = libbase;\n-    if (d->fname) {\n-      jio_snprintf(d->fname, d->buflen, \"%s\", info->dlpi_name);\n-    }\n-    return 1;\n-  }\n-  return 0;\n-}\n-\n+\/\/ Ported from BSD version\n@@ -1422,1 +1379,1 @@\n-  assert(buf != NULL, \"sanity check\");\n+  assert(buf != nullptr, \"sanity check\");\n@@ -1425,18 +1382,0 @@\n-  struct _address_to_library_name data;\n-\n-  \/\/ There is a bug in old glibc dladdr() implementation that it could resolve\n-  \/\/ to wrong library name if the .so file has a base address != NULL. Here\n-  \/\/ we iterate through the program headers of all loaded libraries to find\n-  \/\/ out which library 'addr' really belongs to. This workaround can be\n-  \/\/ removed once the minimum requirement for glibc is moved to 2.3.x.\n-  data.addr = addr;\n-  data.fname = buf;\n-  data.buflen = buflen;\n-  data.base = NULL;\n-  int rslt = dl_iterate_phdr(address_to_library_name_callback, (void *)&data);\n-\n-  if (rslt) {\n-    \/\/ buf already contains library name\n-    if (offset) *offset = addr - data.base;\n-    return true;\n-  }\n@@ -1444,1 +1383,1 @@\n-    if (dlinfo.dli_fname != NULL) {\n+    if (dlinfo.dli_fname != nullptr) {\n@@ -1447,1 +1386,1 @@\n-    if (dlinfo.dli_fbase != NULL && offset != NULL) {\n+    if (dlinfo.dli_fbase != nullptr && offset != nullptr) {\n@@ -1452,1 +1391,0 @@\n-\n@@ -1458,5 +1396,0 @@\n-\/\/ Loads .dll\/.so and\n-\/\/ in case of error it checks if .dll\/.so was built for the\n-\/\/ same architecture as Hotspot is running on\n-\n-\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":4,"deletions":71,"binary":false,"changes":75,"status":"modified"}]}