{"files":[{"patch":"@@ -474,1 +474,1 @@\n-    private static final boolean RETRY_CONNECT = !disableRetryConnect();\n+    static final boolean RETRY_CONNECT = !disableRetryConnect();\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/MultiExchange.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import java.time.Instant;\n@@ -40,0 +41,2 @@\n+import java.util.function.Function;\n+\n@@ -59,0 +62,6 @@\n+    private volatile int unsuccessfulAttempts;\n+\n+    \/\/ Indicates whether a connection attempt has succeeded or should be retried.\n+    \/\/ If the attempt failed, and shouldn't be retried, there will be an exception\n+    \/\/ instead.\n+    private enum ConnectState { SUCCESS, RETRY }\n@@ -60,1 +69,0 @@\n-    \/\/ should be volatile to provide proper synchronization(visibility) action\n@@ -67,1 +75,1 @@\n-                                              CompletableFuture<Void> cf) {\n+                                              CompletableFuture<?> cf) {\n@@ -77,1 +85,1 @@\n-        private final CompletableFuture<Void> cf;\n+        private final CompletableFuture<?> cf;\n@@ -82,1 +90,1 @@\n-                          CompletableFuture<Void> cf) {\n+                          CompletableFuture<?> cf) {\n@@ -105,1 +113,1 @@\n-        private final CompletableFuture<Void> cf;\n+        private final CompletableFuture<ConnectState> cf;\n@@ -108,1 +116,1 @@\n-        ConnectEvent(CompletableFuture<Void> cf, Exchange<?> exchange) {\n+        ConnectEvent(CompletableFuture<ConnectState> cf, Exchange<?> exchange) {\n@@ -136,1 +144,1 @@\n-                cf.completeAsync(() -> null, client().theExecutor());\n+                cf.completeAsync(() -> ConnectState.SUCCESS, client().theExecutor());\n@@ -138,0 +146,5 @@\n+                if (canRetryConnect(e)) {\n+                    unsuccessfulAttempts++;\n+                    cf.completeAsync(() -> ConnectState.RETRY, client().theExecutor());\n+                    return;\n+                }\n@@ -153,1 +166,1 @@\n-        CompletableFuture<Void> cf = new MinimalFuture<>();\n+        CompletableFuture<ConnectState> cf = new MinimalFuture<>();\n@@ -159,5 +172,7 @@\n-            connectTimerEvent = newConnectTimer(exchange, cf);\n-            if (connectTimerEvent != null) {\n-                if (debug.on())\n-                    debug.log(\"registering connect timer: \" + connectTimerEvent);\n-                client().registerTimer(connectTimerEvent);\n+            if (connectTimerEvent == null) {\n+                connectTimerEvent = newConnectTimer(exchange, cf);\n+                if (connectTimerEvent != null) {\n+                    if (debug.on())\n+                        debug.log(\"registering connect timer: \" + connectTimerEvent);\n+                    client().registerTimer(connectTimerEvent);\n+                }\n@@ -175,1 +190,1 @@\n-                cf.complete(null);\n+                cf.complete(ConnectState.SUCCESS);\n@@ -190,1 +205,38 @@\n-        return cf;\n+        return cf.handle((r,t) -> checkRetryConnect(r, t,exchange))\n+                .thenCompose(Function.identity());\n+    }\n+\n+    \/**\n+     * On some platforms, a ConnectEvent may be raised and a ConnectionException\n+     * may occur with the message \"Connection timed out: no further information\"\n+     * before our actual connection timeout has expired. In this case, this\n+     * method will be called with a {@code connect} state of {@code ConnectState.RETRY)\n+     * and we will retry once again.\n+     * @param connect indicates whether the connection was successful or should be retried\n+     * @param failed the failure if the connection failed\n+     * @param exchange the exchange\n+     * @return a completable future that will take care of retrying the connection if needed.\n+     *\/\n+    private CompletableFuture<Void> checkRetryConnect(ConnectState connect, Throwable failed, Exchange<?> exchange) {\n+        \/\/ first check if the connection failed\n+        if (failed != null) return MinimalFuture.failedFuture(failed);\n+        \/\/ then check if the connection should be retried\n+        if (connect == ConnectState.RETRY) {\n+            int attempts = unsuccessfulAttempts;\n+            assert attempts <= 1;\n+            if (debug.on())\n+                debug.log(\"Retrying connect after %d attempts\", attempts);\n+            return connectAsync(exchange);\n+        }\n+        \/\/ Otherwise, the connection was successful;\n+        assert connect == ConnectState.SUCCESS;\n+        return MinimalFuture.completedFuture(null);\n+    }\n+\n+    private boolean canRetryConnect(Throwable e) {\n+        if (!MultiExchange.RETRY_CONNECT) return false;\n+        if (!(e instanceof ConnectException)) return false;\n+        if (unsuccessfulAttempts > 0) return false;\n+        ConnectTimerEvent timer = connectTimerEvent;\n+        if (timer == null) return true;\n+        return timer.deadline().isAfter(Instant.now());\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/PlainHttpConnection.java","additions":67,"deletions":15,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+import java.util.concurrent.ExecutorService;\n@@ -508,0 +509,4 @@\n+        public static HttpTestServer of(HttpServer server, ExecutorService executor) {\n+            return new Http1TestServer(server, executor);\n+        }\n+\n@@ -514,0 +519,1 @@\n+            private final ExecutorService executor;\n@@ -515,0 +521,5 @@\n+                this(server, null);\n+            }\n+            Http1TestServer(HttpServer server, ExecutorService executor) {\n+                if (executor != null) server.setExecutor(executor);\n+                this.executor = executor;\n@@ -525,1 +536,7 @@\n-                impl.stop(0);\n+                try {\n+                    impl.stop(0);\n+                } finally {\n+                    if (executor != null) {\n+                        executor.shutdownNow();\n+                    }\n+                }\n","filename":"test\/jdk\/java\/net\/httpclient\/HttpServerAdapters.java","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+import java.net.http.HttpClient.Builder;\n@@ -46,0 +47,2 @@\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n@@ -47,0 +50,2 @@\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.atomic.AtomicInteger;\n@@ -74,0 +79,1 @@\n+ * @bug 8256459\n@@ -185,0 +191,7 @@\n+    HttpClient newClient() {\n+        return HttpClient.newBuilder()\n+                .sslContext(sslContext)\n+                .proxy(Builder.NO_PROXY)\n+                .build();\n+    }\n+\n@@ -188,2 +201,1 @@\n-        HttpClient client = HttpClient.newBuilder().sslContext(sslContext)\n-                .build();\n+        HttpClient client = newClient();\n@@ -210,2 +222,1 @@\n-        HttpClient client = HttpClient.newBuilder().sslContext(sslContext)\n-                .build();\n+        HttpClient client = newClient();\n@@ -233,1 +244,2 @@\n-        HttpClient client = HttpClient.newBuilder().sslContext(sslContext).build();\n+        HttpClient client = newClient();\n+\n@@ -254,1 +266,1 @@\n-        HttpClient client = HttpClient.newBuilder().sslContext(sslContext).build();\n+        HttpClient client = newClient();\n@@ -278,1 +290,1 @@\n-        HttpClient client = HttpClient.newBuilder().sslContext(sslContext).build();\n+        HttpClient client = newClient();\n@@ -295,1 +307,1 @@\n-        HttpClient client = HttpClient.newBuilder().sslContext(sslContext).build();\n+        HttpClient client = newClient();\n@@ -314,1 +326,1 @@\n-        HttpClient client = HttpClient.newBuilder().sslContext(sslContext).build();\n+        HttpClient client = newClient();\n@@ -341,1 +353,1 @@\n-        HttpClient client = HttpClient.newBuilder().sslContext(sslContext).build();\n+        HttpClient client = newClient();\n@@ -367,1 +379,1 @@\n-        HttpClient client = HttpClient.newBuilder().sslContext(sslContext).build();\n+        HttpClient client = newClient();\n@@ -394,1 +406,1 @@\n-        HttpClient client = HttpClient.newBuilder().sslContext(sslContext).build();\n+        HttpClient client = newClient();\n@@ -419,1 +431,1 @@\n-        HttpClient client = HttpClient.newBuilder().sslContext(sslContext).build();\n+        HttpClient client = newClient();\n@@ -445,2 +457,1 @@\n-        HttpClient client = HttpClient.newBuilder().sslContext(sslContext)\n-                .build();\n+        HttpClient client = newClient();\n@@ -472,2 +483,1 @@\n-        HttpClient client = HttpClient.newBuilder().sslContext(sslContext)\n-                .build();\n+        HttpClient client = newClient();\n@@ -497,2 +507,1 @@\n-        HttpClient client = HttpClient.newBuilder().sslContext(sslContext)\n-                .build();\n+        HttpClient client = newClient();\n@@ -532,2 +541,1 @@\n-        HttpClient client = HttpClient.newBuilder().sslContext(sslContext)\n-                .build();\n+        HttpClient client = newClient();\n@@ -554,2 +562,1 @@\n-        HttpClient client = HttpClient.newBuilder().sslContext(sslContext)\n-                .build();\n+        HttpClient client = newClient();\n@@ -643,0 +650,13 @@\n+    private static ExecutorService executorFor(String serverThreadName) {\n+        ThreadFactory factory = new ThreadFactory() {\n+            final AtomicInteger counter = new AtomicInteger();\n+            @Override\n+            public Thread newThread(Runnable r) {\n+                Thread thread = new Thread(r);\n+                thread.setName(serverThreadName + \"#\" + counter.incrementAndGet());\n+                return thread;\n+            }\n+        };\n+        return Executors.newCachedThreadPool(factory);\n+    }\n+\n@@ -650,1 +670,2 @@\n-        httpTestServer = HttpTestServer.of(HttpServer.create(sa, 0));\n+        httpTestServer = HttpTestServer.of(HttpServer.create(sa, 0),\n+                executorFor(\"HTTP\/1.1 Server Thread\"));\n@@ -656,1 +677,2 @@\n-        httpsTestServer = HttpTestServer.of(httpsServer);\n+        httpsTestServer = HttpTestServer.of(httpsServer,\n+                executorFor(\"HTTPS\/1.1 Server Thread\"));\n","filename":"test\/jdk\/java\/net\/httpclient\/LineBodyHandlerTest.java","additions":48,"deletions":26,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8087112 8180044\n+ * @bug 8087112 8180044 8256459\n@@ -54,0 +54,1 @@\n+import java.net.http.HttpClient.Builder;\n@@ -57,0 +58,1 @@\n+import java.time.Duration;\n@@ -62,0 +64,4 @@\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.atomic.AtomicInteger;\n@@ -84,0 +90,1 @@\n+        ExecutorService executor = executorFor(\"HTTPS\/1.1 Server Thread\");\n@@ -85,0 +92,1 @@\n+        server.setExecutor(executor);\n@@ -87,0 +95,1 @@\n+                                      .proxy(Builder.NO_PROXY)\n@@ -88,0 +97,1 @@\n+                                      .connectTimeout(Duration.ofMillis(120_000)) \/\/ 2mins\n@@ -94,0 +104,1 @@\n+            executor.shutdownNow();\n@@ -105,1 +116,1 @@\n-        final Random rand = new Random();\n+        final Random rand = jdk.test.lib.RandomFactory.getRandom();\n@@ -282,0 +293,14 @@\n+\n+    private static ExecutorService executorFor(String serverThreadName) {\n+        ThreadFactory factory = new ThreadFactory() {\n+            final AtomicInteger counter = new AtomicInteger();\n+            @Override\n+            public Thread newThread(Runnable r) {\n+                Thread thread = new Thread(r);\n+                thread.setName(serverThreadName + \"#\" + counter.incrementAndGet());\n+                return thread;\n+            }\n+        };\n+        return Executors.newCachedThreadPool(factory);\n+    }\n+\n","filename":"test\/jdk\/java\/net\/httpclient\/ManyRequests.java","additions":28,"deletions":3,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8087112 8180044\n+ * @bug 8087112 8180044 8256459\n","filename":"test\/jdk\/java\/net\/httpclient\/ManyRequests2.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}