{"files":[{"patch":"@@ -39,0 +39,1 @@\n+import java.time.Instant;\n@@ -40,0 +41,2 @@\n+import java.util.function.Function;\n+\n@@ -59,0 +62,5 @@\n+    private volatile int unsuccessfulAttempts;\n+\n+    private enum ConnectState {\n+        SUCCESS, RETRY\n+    }\n@@ -60,1 +68,0 @@\n-    \/\/ should be volatile to provide proper synchronization(visibility) action\n@@ -67,1 +74,1 @@\n-                                              CompletableFuture<Void> cf) {\n+                                              CompletableFuture<?> cf) {\n@@ -77,1 +84,1 @@\n-        private final CompletableFuture<Void> cf;\n+        private final CompletableFuture<?> cf;\n@@ -82,1 +89,1 @@\n-                          CompletableFuture<Void> cf) {\n+                          CompletableFuture<?> cf) {\n@@ -105,1 +112,1 @@\n-        private final CompletableFuture<Void> cf;\n+        private final CompletableFuture<ConnectState> cf;\n@@ -108,1 +115,1 @@\n-        ConnectEvent(CompletableFuture<Void> cf, Exchange<?> exchange) {\n+        ConnectEvent(CompletableFuture<ConnectState> cf, Exchange<?> exchange) {\n@@ -136,1 +143,1 @@\n-                cf.completeAsync(() -> null, client().theExecutor());\n+                cf.completeAsync(() -> ConnectState.SUCCESS, client().theExecutor());\n@@ -138,0 +145,5 @@\n+                if (canRetryConnect(e)) {\n+                    unsuccessfulAttempts++;\n+                    cf.completeAsync(() -> ConnectState.RETRY, client().theExecutor());\n+                    return;\n+                }\n@@ -153,1 +165,1 @@\n-        CompletableFuture<Void> cf = new MinimalFuture<>();\n+        CompletableFuture<ConnectState> cf = new MinimalFuture<>();\n@@ -159,5 +171,7 @@\n-            connectTimerEvent = newConnectTimer(exchange, cf);\n-            if (connectTimerEvent != null) {\n-                if (debug.on())\n-                    debug.log(\"registering connect timer: \" + connectTimerEvent);\n-                client().registerTimer(connectTimerEvent);\n+            if (connectTimerEvent == null) {\n+                connectTimerEvent = newConnectTimer(exchange, cf);\n+                if (connectTimerEvent != null) {\n+                    if (debug.on())\n+                        debug.log(\"registering connect timer: \" + connectTimerEvent);\n+                    client().registerTimer(connectTimerEvent);\n+                }\n@@ -175,1 +189,1 @@\n-                cf.complete(null);\n+                cf.complete(ConnectState.SUCCESS);\n@@ -190,1 +204,37 @@\n-        return cf;\n+        return cf.handle((r,t) -> checkRetryConnect(r, t,exchange))\n+                .thenCompose(Function.identity());\n+    }\n+\n+    \/**\n+     * On some platforms, a ConnectEvent may be raised and a ConnectionException\n+     * may occur with the message \"Connection timed out: no further information\"\n+     * before our actual connection timeout has expired. In this case, this\n+     * method will be called with a {@code connect} state of {@code ConnectState.RETRY)\n+     * and we will retry once again.\n+     * @param connect indicates whether the connection was successful or should be retried\n+     * @param failed the failure if the connection failed\n+     * @param exchange the exchange\n+     * @return a completable future that will take care of retrying the connection if needed.\n+     *\/\n+    private CompletableFuture<Void> checkRetryConnect(ConnectState connect, Throwable failed, Exchange<?> exchange) {\n+        \/\/ first check if the connection failed\n+        if (failed != null) return MinimalFuture.failedFuture(failed);\n+        \/\/ then check if the connection should be retried\n+        if (connect == ConnectState.RETRY) {\n+            int attempts = unsuccessfulAttempts;\n+            assert attempts <= 1;\n+            if (debug.on())\n+                debug.log(\"Retrying connect after %d attempts\", attempts);\n+            return connectAsync(exchange);\n+        }\n+        \/\/ Otherwise, the connection was successful;\n+        assert connect == ConnectState.SUCCESS;\n+        return MinimalFuture.completedFuture(null);\n+    }\n+\n+    private boolean canRetryConnect(Throwable e) {\n+        if (!(e instanceof ConnectException)) return false;\n+        if (unsuccessfulAttempts > 0) return false;\n+        ConnectTimerEvent timer = connectTimerEvent;\n+        if (timer == null) return true;\n+        return timer.deadline().isAfter(Instant.now());\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/PlainHttpConnection.java","additions":65,"deletions":15,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+import java.util.concurrent.ExecutorService;\n@@ -508,0 +509,4 @@\n+        public static HttpTestServer of(HttpServer server, ExecutorService executor) {\n+            return new Http1TestServer(server, executor);\n+        }\n+\n@@ -514,0 +519,1 @@\n+            private final ExecutorService executor;\n@@ -515,0 +521,5 @@\n+                this(server, null);\n+            }\n+            Http1TestServer(HttpServer server, ExecutorService executor) {\n+                if (executor != null) server.setExecutor(executor);\n+                this.executor = executor;\n@@ -525,1 +536,7 @@\n-                impl.stop(0);\n+                try {\n+                    impl.stop(0);\n+                } finally {\n+                    if (executor != null) {\n+                        executor.shutdownNow();\n+                    }\n+                }\n","filename":"test\/jdk\/java\/net\/httpclient\/HttpServerAdapters.java","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.net.http.HttpClient.Builder;\n@@ -46,0 +47,2 @@\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n@@ -47,0 +50,2 @@\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.atomic.AtomicInteger;\n@@ -185,0 +190,7 @@\n+    HttpClient newClient() {\n+        return HttpClient.newBuilder()\n+                .sslContext(sslContext)\n+                .proxy(Builder.NO_PROXY)\n+                .build();\n+    }\n+\n@@ -188,2 +200,1 @@\n-        HttpClient client = HttpClient.newBuilder().sslContext(sslContext)\n-                .build();\n+        HttpClient client = newClient();\n@@ -210,2 +221,1 @@\n-        HttpClient client = HttpClient.newBuilder().sslContext(sslContext)\n-                .build();\n+        HttpClient client = newClient();\n@@ -233,1 +243,2 @@\n-        HttpClient client = HttpClient.newBuilder().sslContext(sslContext).build();\n+        HttpClient client = newClient();\n+\n@@ -254,1 +265,1 @@\n-        HttpClient client = HttpClient.newBuilder().sslContext(sslContext).build();\n+        HttpClient client = newClient();\n@@ -278,1 +289,1 @@\n-        HttpClient client = HttpClient.newBuilder().sslContext(sslContext).build();\n+        HttpClient client = newClient();\n@@ -295,1 +306,1 @@\n-        HttpClient client = HttpClient.newBuilder().sslContext(sslContext).build();\n+        HttpClient client = newClient();\n@@ -314,1 +325,1 @@\n-        HttpClient client = HttpClient.newBuilder().sslContext(sslContext).build();\n+        HttpClient client = newClient();\n@@ -341,1 +352,1 @@\n-        HttpClient client = HttpClient.newBuilder().sslContext(sslContext).build();\n+        HttpClient client = newClient();\n@@ -367,1 +378,1 @@\n-        HttpClient client = HttpClient.newBuilder().sslContext(sslContext).build();\n+        HttpClient client = newClient();\n@@ -394,1 +405,1 @@\n-        HttpClient client = HttpClient.newBuilder().sslContext(sslContext).build();\n+        HttpClient client = newClient();\n@@ -419,1 +430,1 @@\n-        HttpClient client = HttpClient.newBuilder().sslContext(sslContext).build();\n+        HttpClient client = newClient();\n@@ -445,2 +456,1 @@\n-        HttpClient client = HttpClient.newBuilder().sslContext(sslContext)\n-                .build();\n+        HttpClient client = newClient();\n@@ -472,2 +482,1 @@\n-        HttpClient client = HttpClient.newBuilder().sslContext(sslContext)\n-                .build();\n+        HttpClient client = newClient();\n@@ -497,2 +506,1 @@\n-        HttpClient client = HttpClient.newBuilder().sslContext(sslContext)\n-                .build();\n+        HttpClient client = newClient();\n@@ -532,2 +540,1 @@\n-        HttpClient client = HttpClient.newBuilder().sslContext(sslContext)\n-                .build();\n+        HttpClient client = newClient();\n@@ -554,2 +561,1 @@\n-        HttpClient client = HttpClient.newBuilder().sslContext(sslContext)\n-                .build();\n+        HttpClient client = newClient();\n@@ -643,0 +649,13 @@\n+    private static ExecutorService executorFor(String serverThreadName) {\n+        ThreadFactory factory = new ThreadFactory() {\n+            final AtomicInteger counter = new AtomicInteger();\n+            @Override\n+            public Thread newThread(Runnable r) {\n+                Thread thread = new Thread(r);\n+                thread.setName(serverThreadName + \"#\" + counter.incrementAndGet());\n+                return thread;\n+            }\n+        };\n+        return Executors.newCachedThreadPool(factory);\n+    }\n+\n@@ -650,1 +669,2 @@\n-        httpTestServer = HttpTestServer.of(HttpServer.create(sa, 0));\n+        httpTestServer = HttpTestServer.of(HttpServer.create(sa, 0),\n+                executorFor(\"HTTP\/1.1 Server Thread\"));\n@@ -656,1 +676,2 @@\n-        httpsTestServer = HttpTestServer.of(httpsServer);\n+        httpsTestServer = HttpTestServer.of(httpsServer,\n+                executorFor(\"HTTPS\/1.1 Server Thread\"));\n","filename":"test\/jdk\/java\/net\/httpclient\/LineBodyHandlerTest.java","additions":46,"deletions":25,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+import java.net.http.HttpClient.Builder;\n@@ -57,0 +58,1 @@\n+import java.time.Duration;\n@@ -62,0 +64,4 @@\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.atomic.AtomicInteger;\n@@ -84,0 +90,1 @@\n+        ExecutorService executor = executorFor(\"HTTPS\/1.1 Server Thread\");\n@@ -85,0 +92,1 @@\n+        server.setExecutor(executor);\n@@ -87,0 +95,1 @@\n+                                      .proxy(Builder.NO_PROXY)\n@@ -88,0 +97,1 @@\n+                                      .connectTimeout(Duration.ofMillis(120_000)) \/\/ 2mins\n@@ -94,0 +104,1 @@\n+            executor.shutdownNow();\n@@ -105,1 +116,1 @@\n-        final Random rand = new Random();\n+        final Random rand = jdk.test.lib.RandomFactory.getRandom();\n@@ -282,0 +293,14 @@\n+\n+    private static ExecutorService executorFor(String serverThreadName) {\n+        ThreadFactory factory = new ThreadFactory() {\n+            final AtomicInteger counter = new AtomicInteger();\n+            @Override\n+            public Thread newThread(Runnable r) {\n+                Thread thread = new Thread(r);\n+                thread.setName(serverThreadName + \"#\" + counter.incrementAndGet());\n+                return thread;\n+            }\n+        };\n+        return Executors.newCachedThreadPool(factory);\n+    }\n+\n","filename":"test\/jdk\/java\/net\/httpclient\/ManyRequests.java","additions":26,"deletions":1,"binary":false,"changes":27,"status":"modified"}]}