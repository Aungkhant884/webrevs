{"files":[{"patch":"@@ -1707,1 +1707,1 @@\n-instruct insert8B(vecD dst, vecD src, iRegIorL2I val, immI idx)\n+instruct insertID(vecD dst, vecD src, iRegIorL2I val, immI idx)\n@@ -1709,1 +1709,3 @@\n-  predicate(n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n+  predicate((n->bottom_type()->is_vect()->element_basic_type() == T_BYTE ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_INT));\n@@ -1711,69 +1713,1 @@\n-  ins_cost(INSN_COST);\n-  format %{ \"orr    $dst, T8B, $src, $src\\n\\t\"\n-            \"mov    $dst, B, $idx, $val\\t# insert into vector(8B)\" %}\n-  ins_encode %{\n-    if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n-      __ orr(as_FloatRegister($dst$$reg), __ T8B,\n-             as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-    }\n-    __ mov(as_FloatRegister($dst$$reg), __ B, $idx$$constant, $val$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct insert16B(vecX dst, vecX src, iRegIorL2I val, immI idx)\n-%{\n-  predicate(n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (VectorInsert (Binary src val) idx));\n-  ins_cost(INSN_COST);\n-  format %{ \"orr    $dst, T16B, $src, $src\\n\\t\"\n-            \"mov    $dst, B, $idx, $val\\t# insert into vector(16B)\" %}\n-  ins_encode %{\n-    if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n-      __ orr(as_FloatRegister($dst$$reg), __ T16B,\n-             as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-    }\n-    __ mov(as_FloatRegister($dst$$reg), __ B, $idx$$constant, $val$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct insert4S(vecD dst, vecD src, iRegIorL2I val, immI idx)\n-%{\n-  predicate(n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (VectorInsert (Binary src val) idx));\n-  ins_cost(INSN_COST);\n-  format %{ \"orr    $dst, T8B, $src, $src\\n\\t\"\n-            \"mov    $dst, H, $idx, $val\\t# insert into vector(4S)\" %}\n-  ins_encode %{\n-    if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n-      __ orr(as_FloatRegister($dst$$reg), __ T8B,\n-             as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-    }\n-    __ mov(as_FloatRegister($dst$$reg), __ H, $idx$$constant, $val$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct insert8S(vecX dst, vecX src, iRegIorL2I val, immI idx)\n-%{\n-  predicate(n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (VectorInsert (Binary src val) idx));\n-  ins_cost(INSN_COST);\n-  format %{ \"orr    $dst, T16B, $src, $src\\n\\t\"\n-            \"mov    $dst, H, $idx, $val\\t# insert into vector(8S)\" %}\n-  ins_encode %{\n-    if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n-      __ orr(as_FloatRegister($dst$$reg), __ T16B,\n-             as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-    }\n-    __ mov(as_FloatRegister($dst$$reg), __ H, $idx$$constant, $val$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct insert2I(vecD dst, vecD src, iRegIorL2I val, immI idx)\n-%{\n-  predicate(n->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (VectorInsert (Binary src val) idx));\n-  ins_cost(INSN_COST);\n+  ins_cost(2 * INSN_COST);\n@@ -1781,1 +1715,1 @@\n-            \"mov    $dst, S, $idx, $val\\t# insert into vector(2I)\" %}\n+            \"mov    $dst, B\/H\/S, $idx, $val\\t# insertI into vector(D)\" %}\n@@ -1787,1 +1721,2 @@\n-    __ mov(as_FloatRegister($dst$$reg), __ S, $idx$$constant, $val$$Register);\n+    __ mov(as_FloatRegister($dst$$reg), __ elemType_to_regVariant(Matcher::vector_element_basic_type(this)),\n+           $idx$$constant, $val$$Register);\n@@ -1792,1 +1727,1 @@\n-instruct insert4I(vecX dst, vecX src, iRegIorL2I val, immI idx)\n+instruct insertIX(vecX dst, vecX src, iRegIorL2I val, immI idx)\n@@ -1794,1 +1729,3 @@\n-  predicate(n->bottom_type()->is_vect()->element_basic_type() == T_INT);\n+  predicate((n->bottom_type()->is_vect()->element_basic_type() == T_BYTE ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_INT));\n@@ -1796,1 +1733,1 @@\n-  ins_cost(INSN_COST);\n+  ins_cost(2 * INSN_COST);\n@@ -1798,1 +1735,1 @@\n-            \"mov    $dst, S, $idx, $val\\t# insert into vector(4I)\" %}\n+            \"mov    $dst, B\/H\/S, $idx, $val\\t# insertI into vector(X)\" %}\n@@ -1804,1 +1741,2 @@\n-    __ mov(as_FloatRegister($dst$$reg), __ S, $idx$$constant, $val$$Register);\n+    __ mov(as_FloatRegister($dst$$reg), __ elemType_to_regVariant(Matcher::vector_element_basic_type(this)),\n+           $idx$$constant, $val$$Register);\n@@ -1813,1 +1751,1 @@\n-  ins_cost(INSN_COST);\n+  ins_cost(2 * INSN_COST);\n@@ -1815,1 +1753,1 @@\n-            \"mov    $dst, D, $idx, $val\\t# insert into vector(2L)\" %}\n+            \"mov    $dst, D, $idx, $val\\t# insertL into vector(2L)\" %}\n@@ -1821,1 +1759,2 @@\n-    __ mov(as_FloatRegister($dst$$reg), __ D, $idx$$constant, $val$$Register);\n+    __ mov(as_FloatRegister($dst$$reg), __ D,\n+           $idx$$constant, $val$$Register);\n@@ -1830,1 +1769,1 @@\n-  ins_cost(INSN_COST);\n+  ins_cost(2 * INSN_COST);\n@@ -1847,1 +1786,1 @@\n-  ins_cost(INSN_COST);\n+  ins_cost(2 * INSN_COST);\n@@ -1864,1 +1803,1 @@\n-  ins_cost(INSN_COST);\n+  ins_cost(2 * INSN_COST);\n@@ -1970,2 +1909,9 @@\n-    __ ins(as_FloatRegister($dst$$reg), __ S,\n-           as_FloatRegister($src$$reg), 0, $idx$$constant);\n+    if ((0 == $idx$$constant) &&\n+        (as_FloatRegister($dst$$reg) == as_FloatRegister($src$$reg))) {\n+      \/* empty *\/\n+    } else if ($idx$$constant == 0) {\n+      __ fmovs(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg));\n+    } else {\n+      __ ins(as_FloatRegister($dst$$reg), __ S,\n+             as_FloatRegister($src$$reg), 0, $idx$$constant);\n+    }\n@@ -1983,2 +1929,9 @@\n-    __ ins(as_FloatRegister($dst$$reg), __ S,\n-           as_FloatRegister($src$$reg), 0, $idx$$constant);\n+    if ((0 == $idx$$constant) &&\n+        (as_FloatRegister($dst$$reg) == as_FloatRegister($src$$reg))) {\n+      \/* empty *\/\n+    } else if ($idx$$constant == 0) {\n+      __ fmovs(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg));\n+    } else {\n+      __ ins(as_FloatRegister($dst$$reg), __ S,\n+             as_FloatRegister($src$$reg), 0, $idx$$constant);\n+    }\n@@ -1996,2 +1949,9 @@\n-    __ ins(as_FloatRegister($dst$$reg), __ D,\n-           as_FloatRegister($src$$reg), 0, $idx$$constant);\n+    if ((0 == $idx$$constant) &&\n+        (as_FloatRegister($dst$$reg) == as_FloatRegister($src$$reg))) {\n+      \/* empty *\/\n+    } else if ($idx$$constant == 0) {\n+      __ fmovd(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg));\n+    } else {\n+      __ ins(as_FloatRegister($dst$$reg), __ D,\n+             as_FloatRegister($src$$reg), 0, $idx$$constant);\n+    }\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_neon.ad","additions":50,"deletions":90,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -872,1 +872,1 @@\n-instruct insert$1$2`'(vec$3 dst, vec$3 src, iReg$4`'ORL2I($4) val, immI idx)\n+instruct insert`'ifelse($2, I, $2$3, $3)(ifelse($1, 8, vecD, vecX) dst, ifelse($1, 8, vecD, vecX) src, ifelse($2, I, iRegIorL2I, iRegL) val, immI idx)\n@@ -874,1 +874,4 @@\n-  predicate(n->bottom_type()->is_vect()->element_basic_type() == T_`'TYPE2DATATYPE($2));\n+  predicate(ifelse($2, L, n->bottom_type()->is_vect()->element_basic_type() == T_LONG,\n+            (n->bottom_type()->is_vect()->element_basic_type() == T_BYTE ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_INT)));\n@@ -876,3 +879,3 @@\n-  ins_cost(INSN_COST);\n-  format %{ \"orr    $dst, T$5, $src, $src\\n\\t\"\n-            \"mov    $dst, iTYPE2SIMD($2), $idx, $val\\t# insert into vector($1$2)\" %}\n+  ins_cost(2 * INSN_COST);\n+  format %{ \"orr    $dst, T$1B, $src, $src\\n\\t\"\n+            \"mov    $dst, ifelse($2, I, B\/H\/S, D), $idx, $val\\t# insert$2 into vector($3)\" %}\n@@ -881,1 +884,1 @@\n-      __ orr(as_FloatRegister($dst$$reg), __ T$5,\n+      __ orr(as_FloatRegister($dst$$reg), __ T$1B,\n@@ -884,1 +887,2 @@\n-    __ mov(as_FloatRegister($dst$$reg), __ iTYPE2SIMD($2), $idx$$constant, $val$$Register);\n+    __ mov(as_FloatRegister($dst$$reg), __ ifelse($2, I, elemType_to_regVariant(Matcher::vector_element_basic_type(this)), D),\n+           $idx$$constant, $val$$Register);\n@@ -888,8 +892,4 @@\n-dnl             $1  $2 $3 $4 $5\n-VECTOR_INSERT_I(8,  B, D, I, 8B)\n-VECTOR_INSERT_I(16, B, X, I, 16B)\n-VECTOR_INSERT_I(4,  S, D, I, 8B)\n-VECTOR_INSERT_I(8,  S, X, I, 16B)\n-VECTOR_INSERT_I(2,  I, D, I, 8B)\n-VECTOR_INSERT_I(4,  I, X, I, 16B)\n-VECTOR_INSERT_I(2,  L, X, L, 16B)\n+dnl             $1  $2 $3\n+VECTOR_INSERT_I(8,  I, D)\n+VECTOR_INSERT_I(16, I, X)\n+VECTOR_INSERT_I(16, L, 2L)\n@@ -898,1 +898,1 @@\n-instruct insert$1`'(vec$2 dst, vec$2 src, vReg$3 val, immI idx)\n+instruct insert$3`'(vec$2 dst, vec$2 src, vReg$1 val, immI idx)\n@@ -900,1 +900,1 @@\n-  predicate(n->bottom_type()->is_vect()->element_basic_type() == T_`'TYPE2DATATYPE($3));\n+  predicate(n->bottom_type()->is_vect()->element_basic_type() == T_`'TYPE2DATATYPE($1));\n@@ -902,1 +902,1 @@\n-  ins_cost(INSN_COST);\n+  ins_cost(2 * INSN_COST);\n@@ -904,2 +904,2 @@\n-  format %{ \"orr    $dst, T$4, $src, $src\\n\\t\"\n-            \"ins    $dst, $5, $val, $idx, 0\\t# insert into vector($1)\" %}\n+  format %{ \"orr    $dst, ifelse($2, D, T8B, T16B), $src, $src\\n\\t\"\n+            \"ins    $dst, ifelse($1, F, S, D), $val, $idx, 0\\t# insert into vector($3)\" %}\n@@ -907,1 +907,1 @@\n-    __ orr(as_FloatRegister($dst$$reg), __ T$4,\n+    __ orr(as_FloatRegister($dst$$reg), __ ifelse($2, D, T8B, T16B),\n@@ -909,1 +909,1 @@\n-    __ ins(as_FloatRegister($dst$$reg), __ $5,\n+    __ ins(as_FloatRegister($dst$$reg), __ ifelse($1, F, S, D),\n@@ -914,4 +914,4 @@\n-dnl             $1  $2 $3 $4   $5\n-VECTOR_INSERT_F(2F, D, F, 8B,  S)\n-VECTOR_INSERT_F(4F, X, F, 16B, S)\n-VECTOR_INSERT_F(2D, X, D, 16B, D)\n+dnl             $1 $2 $3\n+VECTOR_INSERT_F(F, D, 2F)\n+VECTOR_INSERT_F(F, X, 4F)\n+VECTOR_INSERT_F(D, X, 2D)\n@@ -950,2 +950,9 @@\n-    __ ins(as_FloatRegister($dst$$reg), __ $4,\n-           as_FloatRegister($src$$reg), 0, $idx$$constant);\n+    if ((0 == $idx$$constant) &&\n+        (as_FloatRegister($dst$$reg) == as_FloatRegister($src$$reg))) {\n+      \/* empty *\/\n+    } else if ($idx$$constant == 0) {\n+      __ ifelse($2, F, fmovs, fmovd)(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg));\n+    } else {\n+      __ ins(as_FloatRegister($dst$$reg), __ $4,\n+             as_FloatRegister($src$$reg), 0, $idx$$constant);\n+    }\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_neon_ad.m4","additions":35,"deletions":28,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -4663,1 +4663,1 @@\n-instruct extractB(iRegINoSp dst, vReg src, immI idx, pRegGov pgtmp, rFlagsReg cr)\n+instruct extractB(iRegINoSp dst, vReg src, immI idx, vReg vtmp)\n@@ -4665,1 +4665,1 @@\n-  predicate(UseSVE > 0);\n+  predicate(UseSVE > 0 && n->in(2)->get_int() >= 16);\n@@ -4667,1 +4667,1 @@\n-  effect(TEMP pgtmp, KILL cr);\n+  effect(TEMP vtmp);\n@@ -4669,2 +4669,1 @@\n-  format %{ \"sve_extract $dst, B, $pgtmp, $src, $idx\\n\\t\"\n-            \"sbfmw $dst, $dst, 0U, 7U\\t# extract from vector(B)\" %}\n+  format %{ \"sve_extract_integral $dst, B, $src, $idx\\t# extract from vector(B)\" %}\n@@ -4672,3 +4671,2 @@\n-    __ sve_extract(as_Register($dst$$reg), __ B, as_PRegister($pgtmp$$reg),\n-                   as_FloatRegister($src$$reg), (int)($idx$$constant));\n-    __ sbfmw(as_Register($dst$$reg), as_Register($dst$$reg), 0U, 7U);\n+    __ sve_extract_integral(as_Register($dst$$reg), __ B, as_FloatRegister($src$$reg),\n+                            (int)($idx$$constant), \/* is_signed *\/ true, as_FloatRegister($vtmp$$reg));\n@@ -4679,1 +4677,1 @@\n-instruct extractS(iRegINoSp dst, vReg src, immI idx, pRegGov pgtmp, rFlagsReg cr)\n+instruct extractS(iRegINoSp dst, vReg src, immI idx, vReg vtmp)\n@@ -4681,1 +4679,1 @@\n-  predicate(UseSVE > 0);\n+  predicate(UseSVE > 0 && n->in(2)->get_int() >= 8);\n@@ -4683,1 +4681,1 @@\n-  effect(TEMP pgtmp, KILL cr);\n+  effect(TEMP vtmp);\n@@ -4685,2 +4683,1 @@\n-  format %{ \"sve_extract $dst, H, $pgtmp, $src, $idx\\n\\t\"\n-            \"sbfmw $dst, $dst, 0U, 15U\\t# extract from vector(S)\" %}\n+  format %{ \"sve_extract_integral $dst, H, $src, $idx\\t# extract from vector(S)\" %}\n@@ -4688,3 +4685,2 @@\n-    __ sve_extract(as_Register($dst$$reg), __ H, as_PRegister($pgtmp$$reg),\n-                   as_FloatRegister($src$$reg), (int)($idx$$constant));\n-    __ sbfmw(as_Register($dst$$reg), as_Register($dst$$reg), 0U, 15U);\n+    __ sve_extract_integral(as_Register($dst$$reg), __ H, as_FloatRegister($src$$reg),\n+                            (int)($idx$$constant), \/* is_signed *\/ true, as_FloatRegister($vtmp$$reg));\n@@ -4695,2 +4691,1 @@\n-\n-instruct extractI(iRegINoSp dst, vReg src, immI idx, pRegGov pgtmp, rFlagsReg cr)\n+instruct extractI(iRegINoSp dst, vReg src, immI idx, vReg vtmp)\n@@ -4698,1 +4693,1 @@\n-  predicate(UseSVE > 0);\n+  predicate(UseSVE > 0 && n->in(2)->get_int() >= 4);\n@@ -4700,1 +4695,1 @@\n-  effect(TEMP pgtmp, KILL cr);\n+  effect(TEMP vtmp);\n@@ -4702,1 +4697,1 @@\n-  format %{ \"sve_extract $dst, S, $pgtmp, $src, $idx\\t# extract from vector(I)\" %}\n+  format %{ \"sve_extract_integral $dst, S, $src, $idx\\t# extract from vector(I)\" %}\n@@ -4704,2 +4699,2 @@\n-    __ sve_extract(as_Register($dst$$reg), __ S, as_PRegister($pgtmp$$reg),\n-                   as_FloatRegister($src$$reg), (int)($idx$$constant));\n+    __ sve_extract_integral(as_Register($dst$$reg), __ S, as_FloatRegister($src$$reg),\n+                            (int)($idx$$constant), \/* is_signed *\/ true, as_FloatRegister($vtmp$$reg));\n@@ -4710,1 +4705,1 @@\n-instruct extractL(iRegLNoSp dst, vReg src, immI idx, pRegGov pgtmp, rFlagsReg cr)\n+instruct extractL(iRegLNoSp dst, vReg src, immI idx, vReg vtmp)\n@@ -4712,1 +4707,1 @@\n-  predicate(UseSVE > 0);\n+  predicate(UseSVE > 0 && n->in(2)->get_int() >= 2);\n@@ -4714,1 +4709,1 @@\n-  effect(TEMP pgtmp, KILL cr);\n+  effect(TEMP vtmp);\n@@ -4716,1 +4711,1 @@\n-  format %{ \"sve_extract $dst, D, $pgtmp, $src, $idx\\t# extract from vector(L)\" %}\n+  format %{ \"sve_extract_integral $dst, D, $src, $idx\\t# extract from vector(L)\" %}\n@@ -4718,2 +4713,2 @@\n-    __ sve_extract(as_Register($dst$$reg), __ D, as_PRegister($pgtmp$$reg),\n-                   as_FloatRegister($src$$reg), (int)($idx$$constant));\n+    __ sve_extract_integral(as_Register($dst$$reg), __ D, as_FloatRegister($src$$reg),\n+                            (int)($idx$$constant), \/* is_signed *\/ false, as_FloatRegister($vtmp$$reg));\n@@ -4724,1 +4719,49 @@\n-instruct extractF(vRegF dst, vReg src, immI idx, pRegGov pgtmp, rFlagsReg cr)\n+instruct extractB_LT16(iRegINoSp dst, vReg src, immI idx)\n+%{\n+  predicate(UseSVE > 0 && n->in(2)->get_int() < 16);\n+  match(Set dst (ExtractB src idx));\n+  ins_cost(INSN_COST);\n+  format %{ \"smov $dst, B, $src, $idx\\t# extract from vector(B)\" %}\n+  ins_encode %{\n+    __ smov(as_Register($dst$$reg), as_FloatRegister($src$$reg), __ B, $idx$$constant);\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct extractS_LT8(iRegINoSp dst, vReg src, immI idx)\n+%{\n+  predicate(UseSVE > 0 && n->in(2)->get_int() < 8);\n+  match(Set dst (ExtractS src idx));\n+  ins_cost(INSN_COST);\n+  format %{ \"smov $dst, H, $src, $idx\\t# extract from vector(S)\" %}\n+  ins_encode %{\n+    __ smov(as_Register($dst$$reg), as_FloatRegister($src$$reg), __ H, $idx$$constant);\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct extractI_LT4(iRegINoSp dst, vReg src, immI idx)\n+%{\n+  predicate(UseSVE > 0 && n->in(2)->get_int() < 4);\n+  match(Set dst (ExtractI src idx));\n+  ins_cost(INSN_COST);\n+  format %{ \"smov $dst, S, $src, $idx\\t# extract from vector(I)\" %}\n+  ins_encode %{\n+    __ smov(as_Register($dst$$reg), as_FloatRegister($src$$reg), __ S, $idx$$constant);\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct extractL_LT2(iRegLNoSp dst, vReg src, immI idx)\n+%{\n+  predicate(UseSVE > 0 && n->in(2)->get_int() < 2);\n+  match(Set dst (ExtractL src idx));\n+  ins_cost(INSN_COST);\n+  format %{ \"umov $dst, D, $src, $idx\\t# extract from vector(L)\" %}\n+  ins_encode %{\n+    __ umov(as_Register($dst$$reg), as_FloatRegister($src$$reg), __ D, $idx$$constant);\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct extractF(vRegF dst, vReg src, immI idx)\n@@ -4728,1 +4771,0 @@\n-  effect(TEMP pgtmp, KILL cr);\n@@ -4730,4 +4772,12 @@\n-  format %{ \"sve_extract $dst, S, $pgtmp, $src, $idx\\t# extract from vector(F)\" %}\n-  ins_encode %{\n-    __ sve_extract(as_FloatRegister($dst$$reg), __ S, as_PRegister($pgtmp$$reg),\n-                   as_FloatRegister($src$$reg), (int)($idx$$constant));\n+  format %{ \"sve_extract_f $dst, S, $src, $idx\\t# extract from vector(F)\" %}\n+  ins_encode %{\n+    if ((as_FloatRegister($dst$$reg) == as_FloatRegister($src$$reg)) && ($idx$$constant == 0)) {\n+      \/* empty *\/\n+    } else if ($idx$$constant == 0) {\n+      __ fmovs(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg));\n+    } else if ($idx$$constant < 4) {\n+      __ ins(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($src$$reg), 0, (int)($idx$$constant));\n+    } else {\n+      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n+      __ sve_ext(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), $idx$$constant << 2);\n+    }\n@@ -4738,1 +4788,1 @@\n-instruct extractD(vRegD dst, vReg src, immI idx, pRegGov pgtmp, rFlagsReg cr)\n+instruct extractD(vRegD dst, vReg src, immI idx)\n@@ -4742,1 +4792,0 @@\n-  effect(TEMP pgtmp, KILL cr);\n@@ -4744,4 +4793,12 @@\n-  format %{ \"sve_extract $dst, D, $pgtmp, $src, $idx\\t# extract from vector(D)\" %}\n-  ins_encode %{\n-    __ sve_extract(as_FloatRegister($dst$$reg), __ D, as_PRegister($pgtmp$$reg),\n-                   as_FloatRegister($src$$reg), (int)($idx$$constant));\n+  format %{ \"sve_extract_d $dst, D, $src, $idx\\t# extract from vector(D)\" %}\n+  ins_encode %{\n+    if ((as_FloatRegister($dst$$reg) == as_FloatRegister($src$$reg)) && ($idx$$constant == 0)) {\n+      \/* empty *\/\n+    } else if ($idx$$constant == 0) {\n+      __ fmovd(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg));\n+    } else if ($idx$$constant == 1) {\n+      __ ins(as_FloatRegister($dst$$reg), __ D, as_FloatRegister($src$$reg), 0, 1);\n+    } else {\n+      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n+      __ sve_ext(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), $idx$$constant << 3);\n+    }\n@@ -4789,3 +4846,3 @@\n-instruct insertI_small(vReg dst, vReg src, iRegIorL2I val, immI idx, pRegGov pgtmp, rFlagsReg cr)\n-%{\n-  predicate(UseSVE > 0 && n->as_Vector()->length() <= 32 &&\n+instruct insertI_le128bits(vReg dst, vReg src, iRegIorL2I val, immI idx) %{\n+  predicate(UseSVE > 0 &&\n+            (Matcher::vector_length_in_bytes(n) == 8 || Matcher::vector_length_in_bytes(n) == 16) &&\n@@ -4796,6 +4853,3 @@\n-  effect(TEMP_DEF dst, TEMP pgtmp, KILL cr);\n-  ins_cost(4 * SVE_COST);\n-  format %{ \"sve_index $dst, -16, 1\\t# (B\/H\/S)\\n\\t\"\n-            \"sve_cmpeq $pgtmp, $dst, ($idx-#16) # shift from [0, 31] to [-16, 15]\\n\\t\"\n-            \"sve_orr $dst, $src, $src\\n\\t\"\n-            \"sve_cpy $dst, $pgtmp, $val\\t# insert into vector (B\/H\/S)\" %}\n+  ins_cost(2 * INSN_COST);\n+  format %{ \"orr    $dst, T8\/16B, $src, $src\\n\\t\"\n+            \"mov    $dst, B\/H\/S, $idx, $val\\t# insertI into vector(64\/128bits)\" %}\n@@ -4803,7 +4857,7 @@\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ sve_index(as_FloatRegister($dst$$reg), size, -16, 1);\n-    __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), size, ptrue,\n-               as_FloatRegister($dst$$reg), (int)($idx$$constant) - 16);\n-    __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-    __ sve_cpy(as_FloatRegister($dst$$reg), size, as_PRegister($pgtmp$$reg), as_Register($val$$reg));\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n+      __ orr(as_FloatRegister($dst$$reg), Matcher::vector_length_in_bytes(this) == 8 ? __ T8B : __ T16B,\n+             as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n+    }\n+    __ mov(as_FloatRegister($dst$$reg), __ elemType_to_regVariant(Matcher::vector_element_basic_type(this)),\n+           $idx$$constant, $val$$Register);\n@@ -4814,4 +4868,6 @@\n-instruct insertF_small(vReg dst, vReg src, vRegF val, immI idx, pRegGov pgtmp, rFlagsReg cr)\n-%{\n-  predicate(UseSVE > 0 && n->as_Vector()->length() <= 32 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n+instruct insertI_small_index(vReg dst, vReg src, iRegIorL2I val, immI idx, vReg vtmp, pRegGov pgtmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && n->in(2)->get_int() < 32 &&\n+            Matcher::vector_length_in_bytes(n) > 16 &&\n+            (n->bottom_type()->is_vect()->element_basic_type() == T_BYTE ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_INT));\n@@ -4819,1 +4875,1 @@\n-  effect(TEMP_DEF dst, TEMP pgtmp, KILL cr);\n+  effect(TEMP vtmp, TEMP pgtmp, KILL cr);\n@@ -4821,2 +4877,2 @@\n-  format %{ \"sve_index $dst, S, -16, 1\\n\\t\"\n-            \"sve_cmpeq $pgtmp, $dst, ($idx-#16) # shift from [0, 31] to [-16, 15]\\n\\t\"\n+  format %{ \"sve_index $vtmp, -16, 1\\t# (B\/H\/S)\\n\\t\"\n+            \"sve_cmpeq $pgtmp, $vtmp, ($idx-#16) # shift from [0, 31] to [-16, 15]\\n\\t\"\n@@ -4824,1 +4880,1 @@\n-            \"sve_cpy $dst, $pgtmp, $val\\t# insert into vector (F)\" %}\n+            \"sve_cpy $dst, $pgtmp, $val\\t# insert into vector (B\/H\/S)\" %}\n@@ -4826,5 +4882,11 @@\n-    __ sve_index(as_FloatRegister($dst$$reg), __ S, -16, 1);\n-    __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), __ S, ptrue,\n-               as_FloatRegister($dst$$reg), (int)($idx$$constant) - 16);\n-    __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-    __ sve_cpy(as_FloatRegister($dst$$reg), __ S, as_PRegister($pgtmp$$reg), as_FloatRegister($val$$reg));\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ block_comment(\"insert into vector (B\/H\/S) {\");\n+      __ sve_index(as_FloatRegister($vtmp$$reg), size, -16, 1);\n+      __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), size, ptrue,\n+                 as_FloatRegister($vtmp$$reg), (int)($idx$$constant) - 16);\n+      if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n+        __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n+      }\n+      __ sve_cpy(as_FloatRegister($dst$$reg), size, as_PRegister($pgtmp$$reg), $val$$Register);\n+    __ block_comment(\"} insert into vector (B\/H\/S)\");\n@@ -4835,3 +4897,3 @@\n-instruct insertI(vReg dst, vReg src, iRegIorL2I val, immI idx, vReg tmp1, pRegGov pgtmp, rFlagsReg cr)\n-%{\n-  predicate(UseSVE > 0 && n->as_Vector()->length() > 32 &&\n+instruct insertI(vReg dst, vReg src, iRegIorL2I val, immI idx, vReg vtmp1, vReg vtmp2, pRegGov pgtmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && n->in(2)->get_int() >= 32 &&\n+            Matcher::vector_length_in_bytes(n) > 16 &&\n@@ -4842,1 +4904,1 @@\n-  effect(TEMP_DEF dst, TEMP tmp1, TEMP pgtmp, KILL cr);\n+  effect(TEMP vtmp1, TEMP vtmp2, TEMP pgtmp, KILL cr);\n@@ -4844,3 +4906,3 @@\n-  format %{ \"sve_index $tmp1, 0, 1\\t# (B\/H\/S)\\n\\t\"\n-            \"sve_dup $dst, $idx\\t# (B\/H\/S)\\n\\t\"\n-            \"sve_cmpeq $pgtmp, $tmp1, $dst\\n\\t\"\n+  format %{ \"sve_index $vtmp1, 0, 1\\t# (B\/H\/S)\\n\\t\"\n+            \"sve_dup $vtmp2, $idx\\t# (B\/H\/S)\\n\\t\"\n+            \"sve_cmpeq $pgtmp, $vtmp1, $vtmp2\\n\\t\"\n@@ -4852,6 +4914,10 @@\n-    __ sve_index(as_FloatRegister($tmp1$$reg), size, 0, 1);\n-    __ sve_dup(as_FloatRegister($dst$$reg), size, (int)($idx$$constant));\n-    __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), size, ptrue,\n-               as_FloatRegister($tmp1$$reg), as_FloatRegister($dst$$reg));\n-    __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-    __ sve_cpy(as_FloatRegister($dst$$reg), size, as_PRegister($pgtmp$$reg), as_Register($val$$reg));\n+    __ block_comment(\"insert into vector (B\/H\/S) {\");\n+      __ sve_index(as_FloatRegister($vtmp1$$reg), size, 0, 1);\n+      __ sve_dup(as_FloatRegister($vtmp2$$reg), size, (int)($idx$$constant));\n+      __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), size, ptrue,\n+                 as_FloatRegister($vtmp1$$reg), as_FloatRegister($vtmp2$$reg));\n+      if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n+        __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n+      }\n+      __ sve_cpy(as_FloatRegister($dst$$reg), size, as_PRegister($pgtmp$$reg), $val$$Register);\n+    __ block_comment(\"} insert into vector (B\/H\/S)\");\n@@ -4862,2 +4928,19 @@\n-instruct insertL(vReg dst, vReg src, iRegL val, immI idx, pRegGov pgtmp, rFlagsReg cr)\n-%{\n+instruct insertL_128bits(vReg dst, vReg src, iRegL val, immI idx) %{\n+  predicate(UseSVE > 0 && Matcher::vector_length_in_bytes(n) == 16 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  ins_cost(2 * INSN_COST);\n+  format %{ \"orr    $dst, T16B, $src, $src\\n\\t\"\n+            \"mov    $dst, D, $idx, $val\\t# insertL into vector(128bits)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n+      __ orr(as_FloatRegister($dst$$reg), __ T16B,\n+             as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n+    }\n+    __ mov(as_FloatRegister($dst$$reg), __ D, $idx$$constant, $val$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct insertL(vReg dst, vReg src, iRegL val, immI idx, vReg vtmp, pRegGov pgtmp, rFlagsReg cr) %{\n@@ -4865,0 +4948,1 @@\n+            Matcher::vector_length_in_bytes(n) > 16 &&\n@@ -4867,1 +4951,1 @@\n-  effect(TEMP_DEF dst, TEMP pgtmp, KILL cr);\n+  effect(TEMP vtmp, TEMP pgtmp, KILL cr);\n@@ -4869,2 +4953,2 @@\n-  format %{ \"sve_index $dst, D, -16, 1\\n\\t\"\n-            \"sve_cmpeq $pgtmp, $dst, ($idx-#16) # shift from [0, 31] to [-16, 15]\\n\\t\"\n+  format %{ \"sve_index $vtmp, D, -16, 1\\n\\t\"\n+            \"sve_cmpeq $pgtmp, $vtmp, ($idx-#16) # shift from [0, 31] to [-16, 15]\\n\\t\"\n@@ -4874,5 +4958,10 @@\n-    __ sve_index(as_FloatRegister($dst$$reg), __ D, -16, 1);\n-    __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), __ D, ptrue,\n-               as_FloatRegister($dst$$reg), (int)($idx$$constant) - 16);\n-    __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-    __ sve_cpy(as_FloatRegister($dst$$reg), __ D, as_PRegister($pgtmp$$reg), as_Register($val$$reg));\n+    __ block_comment(\"insert into vector (L) {\");\n+      __ sve_index(as_FloatRegister($vtmp$$reg), __ D, -16, 1);\n+      __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), __ D, ptrue,\n+                 as_FloatRegister($vtmp$$reg), (int)($idx$$constant) - 16);\n+      if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n+        __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n+      }\n+      __ sve_cpy(as_FloatRegister($dst$$reg), __ D,\n+                 as_PRegister($pgtmp$$reg), $val$$Register);\n+    __ block_comment(\"} insert into vector (L)\");\n@@ -4883,4 +4972,21 @@\n-instruct insertD(vReg dst, vReg src, vRegD val, immI idx, pRegGov pgtmp, rFlagsReg cr)\n-%{\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n+instruct insertF_le128bits(vReg dst, vReg src, vRegF val, immI idx) %{\n+  predicate(UseSVE > 0 && n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT &&\n+            (Matcher::vector_length_in_bytes(n) == 8 || Matcher::vector_length_in_bytes(n) == 16));\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  ins_cost(2 * INSN_COST);\n+  effect(TEMP_DEF dst);\n+  format %{ \"orr    $dst, T8\/16B, $src, $src\\n\\t\"\n+            \"ins    $dst, S, $val, $idx, 0\\t# insertF into vector(64\/128bits)\" %}\n+  ins_encode %{\n+    __ orr(as_FloatRegister($dst$$reg), Matcher::vector_length_in_bytes(this) == 8 ? __ T8B : __ T16B,\n+           as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n+    __ ins(as_FloatRegister($dst$$reg), __ S,\n+           as_FloatRegister($val$$reg), $idx$$constant, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct insertF_small_index(vReg dst, vReg src, vRegF val, immI idx, pRegGov pgtmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && n->in(2)->get_int() < 32 &&\n+            Matcher::vector_length_in_bytes(n) > 16 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n@@ -4890,1 +4996,1 @@\n-  format %{ \"sve_index $dst, D, -16, 1\\n\\t\"\n+  format %{ \"sve_index $dst, S, -16, 1\\n\\t\"\n@@ -4893,1 +4999,1 @@\n-            \"sve_cpy $dst, $pgtmp, $val\\t# insert into vector (D)\" %}\n+            \"sve_cpy $dst, $pgtmp, $val\\t# insert into vector (F)\" %}\n@@ -4895,5 +5001,7 @@\n-    __ sve_index(as_FloatRegister($dst$$reg), __ D, -16, 1);\n-    __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), __ D, ptrue,\n-               as_FloatRegister($dst$$reg), (int)($idx$$constant) - 16);\n-    __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-    __ sve_cpy(as_FloatRegister($dst$$reg), __ D, as_PRegister($pgtmp$$reg), as_FloatRegister($val$$reg));\n+    __ block_comment(\"insert into vector (F) {\");\n+      __ sve_index(as_FloatRegister($dst$$reg), __ S, -16, 1);\n+      __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), __ S, ptrue,\n+                 as_FloatRegister($dst$$reg), (int)($idx$$constant) - 16);\n+      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n+      __ sve_cpy(as_FloatRegister($dst$$reg), __ S, as_PRegister($pgtmp$$reg), as_FloatRegister($val$$reg));\n+    __ block_comment(\"} insert into vector (F)\");\n@@ -4904,3 +5012,3 @@\n-instruct insertF(vReg dst, vReg src, vRegF val, immI idx, vReg tmp1, pRegGov pgtmp, rFlagsReg cr)\n-%{\n-  predicate(UseSVE > 0 && n->as_Vector()->length() > 32 &&\n+instruct insertF(vReg dst, vReg src, vRegF val, immI idx, vReg tmp1, pRegGov pgtmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && n->in(2)->get_int() >= 32 &&\n+            Matcher::vector_length_in_bytes(n) > 16 &&\n@@ -4917,9 +5025,52 @@\n-    __ sve_index(as_FloatRegister($tmp1$$reg), __ S, 0, 1);\n-    __ sve_dup(as_FloatRegister($dst$$reg), __ S, (int)($idx$$constant));\n-    __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), __ S, ptrue,\n-               as_FloatRegister($tmp1$$reg), as_FloatRegister($dst$$reg));\n-    __ sve_orr(as_FloatRegister($dst$$reg),\n-               as_FloatRegister($src$$reg),\n-               as_FloatRegister($src$$reg));\n-    __ sve_cpy(as_FloatRegister($dst$$reg), __ S,\n-               as_PRegister($pgtmp$$reg), as_FloatRegister($val$$reg));\n+    __ block_comment(\"insert into vector (F) {\");\n+      __ sve_index(as_FloatRegister($tmp1$$reg), __ S, 0, 1);\n+      __ sve_dup(as_FloatRegister($dst$$reg), __ S, (int)($idx$$constant));\n+      __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), __ S, ptrue,\n+                 as_FloatRegister($tmp1$$reg), as_FloatRegister($dst$$reg));\n+      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n+                 as_FloatRegister($src$$reg));\n+      __ sve_cpy(as_FloatRegister($dst$$reg), __ S,\n+                 as_PRegister($pgtmp$$reg), as_FloatRegister($val$$reg));\n+    __ block_comment(\"} insert into vector (F)\");\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct insertD_128bits(vReg dst, vReg src, vRegD val, immI idx) %{\n+  predicate(UseSVE > 0 && Matcher::vector_length_in_bytes(n) == 16 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  ins_cost(2 * INSN_COST);\n+  effect(TEMP_DEF dst);\n+  format %{ \"orr    $dst, T16B, $src, $src\\n\\t\"\n+            \"ins    $dst, D, $val, $idx, 0\\t# insertD into vector(128bits)\" %}\n+  ins_encode %{\n+    __ orr(as_FloatRegister($dst$$reg), __ T16B,\n+           as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n+    __ ins(as_FloatRegister($dst$$reg), __ D,\n+           as_FloatRegister($val$$reg), $idx$$constant, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct insertD(vReg dst, vReg src, vRegD val, immI idx, pRegGov pgtmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 &&\n+            Matcher::vector_length_in_bytes(n) > 16 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  effect(TEMP_DEF dst, TEMP pgtmp, KILL cr);\n+  ins_cost(4 * SVE_COST);\n+  format %{ \"sve_index $dst, D, -16, 1\\n\\t\"\n+            \"sve_cmpeq $pgtmp, $dst, ($idx-#16) # shift from [0, 31] to [-16, 15]\\n\\t\"\n+            \"sve_orr $dst, $src, $src\\n\\t\"\n+            \"sve_cpy $dst, $pgtmp, $val\\t# insert into vector (D)\" %}\n+  ins_encode %{\n+    __ block_comment(\"insert into vector (D) {\");\n+      __ sve_index(as_FloatRegister($dst$$reg), __ D, -16, 1);\n+      __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), __ D, ptrue,\n+                 as_FloatRegister($dst$$reg), (int)($idx$$constant) - 16);\n+      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n+                 as_FloatRegister($src$$reg));\n+      __ sve_cpy(as_FloatRegister($dst$$reg), __ D,\n+                 as_PRegister($pgtmp$$reg), as_FloatRegister($val$$reg));\n+    __ block_comment(\"} insert into vector (D)\");\n@@ -5276,1 +5427,1 @@\n-instruct vmask_tolong(iRegLNoSp dst, pReg src, vReg vtmp1, vReg vtmp2, pRegGov pgtmp, rFlagsReg cr) %{\n+instruct vmask_tolong(iRegLNoSp dst, pReg src, vReg vtmp1, vReg vtmp2) %{\n@@ -5280,1 +5431,1 @@\n-  effect(TEMP vtmp1, TEMP vtmp2, TEMP pgtmp, KILL cr);\n+  effect(TEMP vtmp1, TEMP vtmp2);\n@@ -5287,2 +5438,1 @@\n-                        as_FloatRegister($vtmp1$$reg), as_FloatRegister($vtmp2$$reg),\n-                        as_PRegister($pgtmp$$reg));\n+                        as_FloatRegister($vtmp1$$reg), as_FloatRegister($vtmp2$$reg));\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve.ad","additions":270,"deletions":120,"binary":false,"changes":390,"status":"modified"},{"patch":"@@ -2331,2 +2331,3 @@\n-define(`VECTOR_EXTRACT_SXT', `\n-instruct extract$1`'($2 dst, vReg src, immI idx, pRegGov pgtmp, rFlagsReg cr)\n+dnl\n+define(`VECTOR_EXTRACT_I', `\n+instruct extract$1`'($3 dst, vReg src, immI idx, vReg vtmp)\n@@ -2334,1 +2335,1 @@\n-  predicate(UseSVE > 0);\n+  predicate(UseSVE > 0 && n->in(2)->get_int() >= $2);\n@@ -2336,1 +2337,1 @@\n-  effect(TEMP pgtmp, KILL cr);\n+  effect(TEMP vtmp);\n@@ -2338,2 +2339,1 @@\n-  format %{ \"sve_extract $dst, $3, $pgtmp, $src, $idx\\n\\t\"\n-            \"sbfmw $dst, $dst, 0U, $5\\t# extract from vector($1)\" %}\n+  format %{ \"sve_extract_integral $dst, $4, $src, $idx\\t# extract from vector($1)\" %}\n@@ -2341,3 +2341,2 @@\n-    __ sve_extract(as_$4($dst$$reg), __ $3, as_PRegister($pgtmp$$reg),\n-                   as_FloatRegister($src$$reg), (int)($idx$$constant));\n-    __ sbfmw(as_$4($dst$$reg), as_$4($dst$$reg), 0U, $5);\n+    __ sve_extract_integral(as_Register($dst$$reg), __ $4, as_FloatRegister($src$$reg),\n+                            (int)($idx$$constant), \/* is_signed *\/ ifelse($1, L, false, true), as_FloatRegister($vtmp$$reg));\n@@ -2347,4 +2346,5 @@\n-dnl                $1 $2         $3 $4        $5\n-VECTOR_EXTRACT_SXT(B, iRegINoSp, B, Register, 7U)\n-VECTOR_EXTRACT_SXT(S, iRegINoSp, H, Register, 15U)\n-\n+dnl              $1 $2  $3         $4\n+VECTOR_EXTRACT_I(B, 16, iRegINoSp, B)\n+VECTOR_EXTRACT_I(S, 8,  iRegINoSp, H)\n+VECTOR_EXTRACT_I(I, 4,  iRegINoSp, S)\n+VECTOR_EXTRACT_I(L, 2,  iRegLNoSp, D)\n@@ -2352,2 +2352,2 @@\n-define(`VECTOR_EXTRACT', `\n-instruct extract$1`'($2 dst, vReg src, immI idx, pRegGov pgtmp, rFlagsReg cr)\n+define(`VECTOR_EXTRACT_I_LT', `\n+instruct extract$1_LT$2`'($3 dst, vReg src, immI idx)\n@@ -2355,1 +2355,1 @@\n-  predicate(UseSVE > 0);\n+  predicate(UseSVE > 0 && n->in(2)->get_int() < $2);\n@@ -2357,3 +2357,2 @@\n-  effect(TEMP pgtmp, KILL cr);\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_extract $dst, $3, $pgtmp, $src, $idx\\t# extract from vector($1)\" %}\n+  ins_cost(INSN_COST);\n+  format %{ \"ifelse($4, D, umov, smov) $dst, $4, $src, $idx\\t# extract from vector($1)\" %}\n@@ -2361,2 +2360,1 @@\n-    __ sve_extract(as_$4($dst$$reg), __ $3, as_PRegister($pgtmp$$reg),\n-                   as_FloatRegister($src$$reg), (int)($idx$$constant));\n+    __ ifelse($4, D, umov, smov)(as_Register($dst$$reg), as_FloatRegister($src$$reg), __ $4, $idx$$constant);\n@@ -2364,1 +2362,1 @@\n-  ins_pipe(pipe_slow);\n+  ins_pipe(pipe_class_default);\n@@ -2366,5 +2364,47 @@\n-dnl            $1 $2         $3 $4\n-VECTOR_EXTRACT(I, iRegINoSp, S, Register)\n-VECTOR_EXTRACT(L, iRegLNoSp, D, Register)\n-VECTOR_EXTRACT(F, vRegF,     S, FloatRegister)\n-VECTOR_EXTRACT(D, vRegD,     D, FloatRegister)\n+dnl                 $1  $2  $3         $4\n+VECTOR_EXTRACT_I_LT(B,  16, iRegINoSp, B)\n+VECTOR_EXTRACT_I_LT(S,  8,  iRegINoSp, H)\n+VECTOR_EXTRACT_I_LT(I,  4,  iRegINoSp, S)\n+VECTOR_EXTRACT_I_LT(L,  2,  iRegLNoSp, D)\n+\n+instruct extractF(vRegF dst, vReg src, immI idx)\n+%{\n+  predicate(UseSVE > 0);\n+  match(Set dst (ExtractF src idx));\n+  ins_cost(2 * SVE_COST);\n+  format %{ \"sve_extract_f $dst, S, $src, $idx\\t# extract from vector(F)\" %}\n+  ins_encode %{\n+    if ((as_FloatRegister($dst$$reg) == as_FloatRegister($src$$reg)) && ($idx$$constant == 0)) {\n+      \/* empty *\/\n+    } else if ($idx$$constant == 0) {\n+      __ fmovs(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg));\n+    } else if ($idx$$constant < 4) {\n+      __ ins(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($src$$reg), 0, (int)($idx$$constant));\n+    } else {\n+      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n+      __ sve_ext(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), $idx$$constant << 2);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct extractD(vRegD dst, vReg src, immI idx)\n+%{\n+  predicate(UseSVE > 0);\n+  match(Set dst (ExtractD src idx));\n+  ins_cost(2 * SVE_COST);\n+  format %{ \"sve_extract_d $dst, D, $src, $idx\\t# extract from vector(D)\" %}\n+  ins_encode %{\n+    if ((as_FloatRegister($dst$$reg) == as_FloatRegister($src$$reg)) && ($idx$$constant == 0)) {\n+      \/* empty *\/\n+    } else if ($idx$$constant == 0) {\n+      __ fmovd(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg));\n+    } else if ($idx$$constant == 1) {\n+      __ ins(as_FloatRegister($dst$$reg), __ D, as_FloatRegister($src$$reg), 0, 1);\n+    } else {\n+      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n+      __ sve_ext(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), $idx$$constant << 3);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n@@ -2410,3 +2450,3 @@\n-instruct insertI_small(vReg dst, vReg src, iRegIorL2I val, immI idx, pRegGov pgtmp, rFlagsReg cr)\n-%{\n-  predicate(UseSVE > 0 && n->as_Vector()->length() <= 32 &&\n+instruct insertI_le128bits(vReg dst, vReg src, iRegIorL2I val, immI idx) %{\n+  predicate(UseSVE > 0 &&\n+            (Matcher::vector_length_in_bytes(n) == 8 || Matcher::vector_length_in_bytes(n) == 16) &&\n@@ -2417,6 +2457,3 @@\n-  effect(TEMP_DEF dst, TEMP pgtmp, KILL cr);\n-  ins_cost(4 * SVE_COST);\n-  format %{ \"sve_index $dst, -16, 1\\t# (B\/H\/S)\\n\\t\"\n-            \"sve_cmpeq $pgtmp, $dst, ($idx-#16) # shift from [0, 31] to [-16, 15]\\n\\t\"\n-            \"sve_orr $dst, $src, $src\\n\\t\"\n-            \"sve_cpy $dst, $pgtmp, $val\\t# insert into vector (B\/H\/S)\" %}\n+  ins_cost(2 * INSN_COST);\n+  format %{ \"orr    $dst, T8\/16B, $src, $src\\n\\t\"\n+            \"mov    $dst, B\/H\/S, $idx, $val\\t# insertI into vector(64\/128bits)\" %}\n@@ -2424,7 +2461,7 @@\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ sve_index(as_FloatRegister($dst$$reg), size, -16, 1);\n-    __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), size, ptrue,\n-               as_FloatRegister($dst$$reg), (int)($idx$$constant) - 16);\n-    __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-    __ sve_cpy(as_FloatRegister($dst$$reg), size, as_PRegister($pgtmp$$reg), as_Register($val$$reg));\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n+      __ orr(as_FloatRegister($dst$$reg), Matcher::vector_length_in_bytes(this) == 8 ? __ T8B : __ T16B,\n+             as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n+    }\n+    __ mov(as_FloatRegister($dst$$reg), __ elemType_to_regVariant(Matcher::vector_element_basic_type(this)),\n+           $idx$$constant, $val$$Register);\n@@ -2435,4 +2472,6 @@\n-instruct insertF_small(vReg dst, vReg src, vRegF val, immI idx, pRegGov pgtmp, rFlagsReg cr)\n-%{\n-  predicate(UseSVE > 0 && n->as_Vector()->length() <= 32 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n+instruct insertI_small_index(vReg dst, vReg src, iRegIorL2I val, immI idx, vReg vtmp, pRegGov pgtmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && n->in(2)->get_int() < 32 &&\n+            Matcher::vector_length_in_bytes(n) > 16 &&\n+            (n->bottom_type()->is_vect()->element_basic_type() == T_BYTE ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_INT));\n@@ -2440,1 +2479,1 @@\n-  effect(TEMP_DEF dst, TEMP pgtmp, KILL cr);\n+  effect(TEMP vtmp, TEMP pgtmp, KILL cr);\n@@ -2442,2 +2481,2 @@\n-  format %{ \"sve_index $dst, S, -16, 1\\n\\t\"\n-            \"sve_cmpeq $pgtmp, $dst, ($idx-#16) # shift from [0, 31] to [-16, 15]\\n\\t\"\n+  format %{ \"sve_index $vtmp, -16, 1\\t# (B\/H\/S)\\n\\t\"\n+            \"sve_cmpeq $pgtmp, $vtmp, ($idx-#16) # shift from [0, 31] to [-16, 15]\\n\\t\"\n@@ -2445,1 +2484,1 @@\n-            \"sve_cpy $dst, $pgtmp, $val\\t# insert into vector (F)\" %}\n+            \"sve_cpy $dst, $pgtmp, $val\\t# insert into vector (B\/H\/S)\" %}\n@@ -2447,5 +2486,11 @@\n-    __ sve_index(as_FloatRegister($dst$$reg), __ S, -16, 1);\n-    __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), __ S, ptrue,\n-               as_FloatRegister($dst$$reg), (int)($idx$$constant) - 16);\n-    __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-    __ sve_cpy(as_FloatRegister($dst$$reg), __ S, as_PRegister($pgtmp$$reg), as_FloatRegister($val$$reg));\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ block_comment(\"insert into vector (B\/H\/S) {\");\n+      __ sve_index(as_FloatRegister($vtmp$$reg), size, -16, 1);\n+      __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), size, ptrue,\n+                 as_FloatRegister($vtmp$$reg), (int)($idx$$constant) - 16);\n+      if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n+        __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n+      }\n+      __ sve_cpy(as_FloatRegister($dst$$reg), size, as_PRegister($pgtmp$$reg), $val$$Register);\n+    __ block_comment(\"} insert into vector (B\/H\/S)\");\n@@ -2456,3 +2501,3 @@\n-instruct insertI(vReg dst, vReg src, iRegIorL2I val, immI idx, vReg tmp1, pRegGov pgtmp, rFlagsReg cr)\n-%{\n-  predicate(UseSVE > 0 && n->as_Vector()->length() > 32 &&\n+instruct insertI(vReg dst, vReg src, iRegIorL2I val, immI idx, vReg vtmp1, vReg vtmp2, pRegGov pgtmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && n->in(2)->get_int() >= 32 &&\n+            Matcher::vector_length_in_bytes(n) > 16 &&\n@@ -2463,1 +2508,1 @@\n-  effect(TEMP_DEF dst, TEMP tmp1, TEMP pgtmp, KILL cr);\n+  effect(TEMP vtmp1, TEMP vtmp2, TEMP pgtmp, KILL cr);\n@@ -2465,3 +2510,3 @@\n-  format %{ \"sve_index $tmp1, 0, 1\\t# (B\/H\/S)\\n\\t\"\n-            \"sve_dup $dst, $idx\\t# (B\/H\/S)\\n\\t\"\n-            \"sve_cmpeq $pgtmp, $tmp1, $dst\\n\\t\"\n+  format %{ \"sve_index $vtmp1, 0, 1\\t# (B\/H\/S)\\n\\t\"\n+            \"sve_dup $vtmp2, $idx\\t# (B\/H\/S)\\n\\t\"\n+            \"sve_cmpeq $pgtmp, $vtmp1, $vtmp2\\n\\t\"\n@@ -2473,6 +2518,10 @@\n-    __ sve_index(as_FloatRegister($tmp1$$reg), size, 0, 1);\n-    __ sve_dup(as_FloatRegister($dst$$reg), size, (int)($idx$$constant));\n-    __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), size, ptrue,\n-               as_FloatRegister($tmp1$$reg), as_FloatRegister($dst$$reg));\n-    __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-    __ sve_cpy(as_FloatRegister($dst$$reg), size, as_PRegister($pgtmp$$reg), as_Register($val$$reg));\n+    __ block_comment(\"insert into vector (B\/H\/S) {\");\n+      __ sve_index(as_FloatRegister($vtmp1$$reg), size, 0, 1);\n+      __ sve_dup(as_FloatRegister($vtmp2$$reg), size, (int)($idx$$constant));\n+      __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), size, ptrue,\n+                 as_FloatRegister($vtmp1$$reg), as_FloatRegister($vtmp2$$reg));\n+      if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n+        __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n+      }\n+      __ sve_cpy(as_FloatRegister($dst$$reg), size, as_PRegister($pgtmp$$reg), $val$$Register);\n+    __ block_comment(\"} insert into vector (B\/H\/S)\");\n@@ -2482,5 +2531,20 @@\n-dnl\n-dnl\n-define(`VECTOR_INSERT_D', `\n-instruct insert$1`'(vReg dst, vReg src, $2 val, immI idx, pRegGov pgtmp, rFlagsReg cr)\n-%{\n+\n+instruct insertL_128bits(vReg dst, vReg src, iRegL val, immI idx) %{\n+  predicate(UseSVE > 0 && Matcher::vector_length_in_bytes(n) == 16 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  ins_cost(2 * INSN_COST);\n+  format %{ \"orr    $dst, T16B, $src, $src\\n\\t\"\n+            \"mov    $dst, D, $idx, $val\\t# insertL into vector(128bits)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n+      __ orr(as_FloatRegister($dst$$reg), __ T16B,\n+             as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n+    }\n+    __ mov(as_FloatRegister($dst$$reg), __ D, $idx$$constant, $val$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct insertL(vReg dst, vReg src, iRegL val, immI idx, vReg vtmp, pRegGov pgtmp, rFlagsReg cr) %{\n@@ -2488,1 +2552,45 @@\n-            n->bottom_type()->is_vect()->element_basic_type() == T_`'TYPE2DATATYPE($1));\n+            Matcher::vector_length_in_bytes(n) > 16 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  effect(TEMP vtmp, TEMP pgtmp, KILL cr);\n+  ins_cost(4 * SVE_COST);\n+  format %{ \"sve_index $vtmp, D, -16, 1\\n\\t\"\n+            \"sve_cmpeq $pgtmp, $vtmp, ($idx-#16) # shift from [0, 31] to [-16, 15]\\n\\t\"\n+            \"sve_orr $dst, $src, $src\\n\\t\"\n+            \"sve_cpy $dst, $pgtmp, $val\\t# insert into vector (L)\" %}\n+  ins_encode %{\n+    __ block_comment(\"insert into vector (L) {\");\n+      __ sve_index(as_FloatRegister($vtmp$$reg), __ D, -16, 1);\n+      __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), __ D, ptrue,\n+                 as_FloatRegister($vtmp$$reg), (int)($idx$$constant) - 16);\n+      if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n+        __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n+      }\n+      __ sve_cpy(as_FloatRegister($dst$$reg), __ D,\n+                 as_PRegister($pgtmp$$reg), $val$$Register);\n+    __ block_comment(\"} insert into vector (L)\");\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct insertF_le128bits(vReg dst, vReg src, vRegF val, immI idx) %{\n+  predicate(UseSVE > 0 && n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT &&\n+            (Matcher::vector_length_in_bytes(n) == 8 || Matcher::vector_length_in_bytes(n) == 16));\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  ins_cost(2 * INSN_COST);\n+  effect(TEMP_DEF dst);\n+  format %{ \"orr    $dst, T8\/16B, $src, $src\\n\\t\"\n+            \"ins    $dst, S, $val, $idx, 0\\t# insertF into vector(64\/128bits)\" %}\n+  ins_encode %{\n+    __ orr(as_FloatRegister($dst$$reg), Matcher::vector_length_in_bytes(this) == 8 ? __ T8B : __ T16B,\n+           as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n+    __ ins(as_FloatRegister($dst$$reg), __ S,\n+           as_FloatRegister($val$$reg), $idx$$constant, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct insertF_small_index(vReg dst, vReg src, vRegF val, immI idx, pRegGov pgtmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && n->in(2)->get_int() < 32 &&\n+            Matcher::vector_length_in_bytes(n) > 16 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n@@ -2492,1 +2600,1 @@\n-  format %{ \"sve_index $dst, $3, -16, 1\\n\\t\"\n+  format %{ \"sve_index $dst, S, -16, 1\\n\\t\"\n@@ -2495,1 +2603,1 @@\n-            \"sve_cpy $dst, $pgtmp, $val\\t# insert into vector ($1)\" %}\n+            \"sve_cpy $dst, $pgtmp, $val\\t# insert into vector (F)\" %}\n@@ -2497,5 +2605,7 @@\n-    __ sve_index(as_FloatRegister($dst$$reg), __ $3, -16, 1);\n-    __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), __ $3, ptrue,\n-               as_FloatRegister($dst$$reg), (int)($idx$$constant) - 16);\n-    __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-    __ sve_cpy(as_FloatRegister($dst$$reg), __ $3, as_PRegister($pgtmp$$reg), as_$4($val$$reg));\n+    __ block_comment(\"insert into vector (F) {\");\n+      __ sve_index(as_FloatRegister($dst$$reg), __ S, -16, 1);\n+      __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), __ S, ptrue,\n+                 as_FloatRegister($dst$$reg), (int)($idx$$constant) - 16);\n+      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n+      __ sve_cpy(as_FloatRegister($dst$$reg), __ S, as_PRegister($pgtmp$$reg), as_FloatRegister($val$$reg));\n+    __ block_comment(\"} insert into vector (F)\");\n@@ -2504,4 +2614,1 @@\n-%}')dnl\n-dnl             $1 $2     $3 $4\n-VECTOR_INSERT_D(L, iRegL, D, Register)\n-VECTOR_INSERT_D(D, vRegD, D, FloatRegister)\n+%}\n@@ -2509,3 +2616,3 @@\n-instruct insertF(vReg dst, vReg src, vRegF val, immI idx, vReg tmp1, pRegGov pgtmp, rFlagsReg cr)\n-%{\n-  predicate(UseSVE > 0 && n->as_Vector()->length() > 32 &&\n+instruct insertF(vReg dst, vReg src, vRegF val, immI idx, vReg tmp1, pRegGov pgtmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && n->in(2)->get_int() >= 32 &&\n+            Matcher::vector_length_in_bytes(n) > 16 &&\n@@ -2522,9 +2629,52 @@\n-    __ sve_index(as_FloatRegister($tmp1$$reg), __ S, 0, 1);\n-    __ sve_dup(as_FloatRegister($dst$$reg), __ S, (int)($idx$$constant));\n-    __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), __ S, ptrue,\n-               as_FloatRegister($tmp1$$reg), as_FloatRegister($dst$$reg));\n-    __ sve_orr(as_FloatRegister($dst$$reg),\n-               as_FloatRegister($src$$reg),\n-               as_FloatRegister($src$$reg));\n-    __ sve_cpy(as_FloatRegister($dst$$reg), __ S,\n-               as_PRegister($pgtmp$$reg), as_FloatRegister($val$$reg));\n+    __ block_comment(\"insert into vector (F) {\");\n+      __ sve_index(as_FloatRegister($tmp1$$reg), __ S, 0, 1);\n+      __ sve_dup(as_FloatRegister($dst$$reg), __ S, (int)($idx$$constant));\n+      __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), __ S, ptrue,\n+                 as_FloatRegister($tmp1$$reg), as_FloatRegister($dst$$reg));\n+      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n+                 as_FloatRegister($src$$reg));\n+      __ sve_cpy(as_FloatRegister($dst$$reg), __ S,\n+                 as_PRegister($pgtmp$$reg), as_FloatRegister($val$$reg));\n+    __ block_comment(\"} insert into vector (F)\");\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct insertD_128bits(vReg dst, vReg src, vRegD val, immI idx) %{\n+  predicate(UseSVE > 0 && Matcher::vector_length_in_bytes(n) == 16 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  ins_cost(2 * INSN_COST);\n+  effect(TEMP_DEF dst);\n+  format %{ \"orr    $dst, T16B, $src, $src\\n\\t\"\n+            \"ins    $dst, D, $val, $idx, 0\\t# insertD into vector(128bits)\" %}\n+  ins_encode %{\n+    __ orr(as_FloatRegister($dst$$reg), __ T16B,\n+           as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n+    __ ins(as_FloatRegister($dst$$reg), __ D,\n+           as_FloatRegister($val$$reg), $idx$$constant, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct insertD(vReg dst, vReg src, vRegD val, immI idx, pRegGov pgtmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 &&\n+            Matcher::vector_length_in_bytes(n) > 16 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  effect(TEMP_DEF dst, TEMP pgtmp, KILL cr);\n+  ins_cost(4 * SVE_COST);\n+  format %{ \"sve_index $dst, D, -16, 1\\n\\t\"\n+            \"sve_cmpeq $pgtmp, $dst, ($idx-#16) # shift from [0, 31] to [-16, 15]\\n\\t\"\n+            \"sve_orr $dst, $src, $src\\n\\t\"\n+            \"sve_cpy $dst, $pgtmp, $val\\t# insert into vector (D)\" %}\n+  ins_encode %{\n+    __ block_comment(\"insert into vector (D) {\");\n+      __ sve_index(as_FloatRegister($dst$$reg), __ D, -16, 1);\n+      __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), __ D, ptrue,\n+                 as_FloatRegister($dst$$reg), (int)($idx$$constant) - 16);\n+      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n+                 as_FloatRegister($src$$reg));\n+      __ sve_cpy(as_FloatRegister($dst$$reg), __ D,\n+                 as_PRegister($pgtmp$$reg), as_FloatRegister($val$$reg));\n+    __ block_comment(\"} insert into vector (D)\");\n@@ -2867,1 +3017,1 @@\n-instruct vmask_tolong(iRegLNoSp dst, pReg src, vReg vtmp1, vReg vtmp2, pRegGov pgtmp, rFlagsReg cr) %{\n+instruct vmask_tolong(iRegLNoSp dst, pReg src, vReg vtmp1, vReg vtmp2) %{\n@@ -2871,1 +3021,1 @@\n-  effect(TEMP vtmp1, TEMP vtmp2, TEMP pgtmp, KILL cr);\n+  effect(TEMP vtmp1, TEMP vtmp2);\n@@ -2878,2 +3028,1 @@\n-                        as_FloatRegister($vtmp1$$reg), as_FloatRegister($vtmp2$$reg),\n-                        as_PRegister($pgtmp$$reg));\n+                        as_FloatRegister($vtmp1$$reg), as_FloatRegister($vtmp2$$reg));\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve_ad.m4","additions":251,"deletions":102,"binary":false,"changes":353,"status":"modified"},{"patch":"@@ -3479,0 +3479,7 @@\n+  \/\/ SVE Permute Vector - Extract\n+  void sve_ext(FloatRegister Zdn, FloatRegister Zm, int imm8) {\n+    starti;\n+    f(0b00000101001, 31, 21), f(imm8 >> 3, 20, 16), f(0b000, 15, 13);\n+    f(imm8 & 0b111, 12, 10), rf(Zm, 5), rf(Zdn, 0);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -963,2 +963,1 @@\n-                                         FloatRegister vtmp1, FloatRegister vtmp2, PRegister pgtmp) {\n-  assert(pgtmp->is_governing(), \"This register has to be a governing predicate register.\");\n+                                         FloatRegister vtmp1, FloatRegister vtmp2) {\n@@ -967,0 +966,1 @@\n+  assert_different_registers(vtmp1, vtmp2);\n@@ -984,1 +984,1 @@\n-    idx == 1 ? fmovhid(rscratch1, vtmp1) : sve_extract(rscratch1, D, pgtmp, vtmp1, idx);\n+    sve_extract_integral(rscratch1, D, vtmp1, idx, \/* is_signed *\/ false, vtmp2);\n@@ -1270,0 +1270,15 @@\n+\n+\/\/ Extract a scalar element from an sve vector at position 'idx'.\n+\/\/ The input elements in src are expected to be of integral type.\n+void C2_MacroAssembler::sve_extract_integral(Register dst, SIMD_RegVariant size, FloatRegister src, int idx,\n+                                             bool is_signed, FloatRegister vtmp) {\n+  assert(UseSVE > 0 && size != Q, \"unsupported\");\n+  assert(!(is_signed && size == D), \"signed extract (D) not supported.\");\n+  if (regVariant_to_elemBits(size) * idx < 128) { \/\/ generate lower cost NEON instruction\n+    is_signed ? smov(dst, src, size, idx) : umov(dst, src, size, idx);\n+  } else {\n+    sve_orr(vtmp, src, src);\n+    sve_ext(vtmp, vtmp, idx << size);\n+    is_signed ? smov(dst, vtmp, size, 0) : umov(dst, vtmp, size, 0);\n+  }\n+}\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":19,"deletions":4,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-                        FloatRegister vtmp1, FloatRegister vtmp2, PRegister pgtmp);\n+                        FloatRegister vtmp1, FloatRegister vtmp2);\n@@ -95,10 +95,3 @@\n-  \/\/ rscratch1 will be clobbered.\n-  \/\/ T could be FloatRegister or Register.\n-  template<class T>\n-  inline void sve_extract(T dst, SIMD_RegVariant size, PRegister pg, FloatRegister src, int idx) {\n-    assert(UseSVE > 0, \"not supported\");\n-    assert(pg->is_governing(), \"This register has to be a governing predicate register\");\n-    mov(rscratch1, idx);\n-    sve_whilele(pg, size, zr, rscratch1);\n-    sve_lastb(dst, size, pg, src);\n-  }\n+  \/\/ The input elements in src are expected to be of integral type.\n+  void sve_extract_integral(Register dst, SIMD_RegVariant size, FloatRegister src, int idx,\n+                            bool is_signed, FloatRegister vtmp);\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.hpp","additions":4,"deletions":11,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1783,0 +1783,1 @@\n+                        [\"ext\",     \"__ sve_ext(z17, z16, 63);\",                          \"ext\\tz17.b, z17.b, z16.b, #63\"],\n","filename":"test\/hotspot\/gtest\/aarch64\/aarch64-asmtest.py","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -942,0 +942,1 @@\n+    __ sve_ext(z17, z16, 63);                          \/\/       ext     z17.b, z17.b, z16.b, #63\n@@ -1198,7 +1199,7 @@\n-    0x14000000,     0x17ffffd7,     0x140003d5,     0x94000000,\n-    0x97ffffd4,     0x940003d2,     0x3400000a,     0x34fffa2a,\n-    0x340079ea,     0x35000008,     0x35fff9c8,     0x35007988,\n-    0xb400000b,     0xb4fff96b,     0xb400792b,     0xb500001d,\n-    0xb5fff91d,     0xb50078dd,     0x10000013,     0x10fff8b3,\n-    0x10007873,     0x90000013,     0x36300016,     0x3637f836,\n-    0x363077f6,     0x3758000c,     0x375ff7cc,     0x3758778c,\n+    0x14000000,     0x17ffffd7,     0x140003d6,     0x94000000,\n+    0x97ffffd4,     0x940003d3,     0x3400000a,     0x34fffa2a,\n+    0x34007a0a,     0x35000008,     0x35fff9c8,     0x350079a8,\n+    0xb400000b,     0xb4fff96b,     0xb400794b,     0xb500001d,\n+    0xb5fff91d,     0xb50078fd,     0x10000013,     0x10fff8b3,\n+    0x10007893,     0x90000013,     0x36300016,     0x3637f836,\n+    0x36307816,     0x3758000c,     0x375ff7cc,     0x375877ac,\n@@ -1209,13 +1210,13 @@\n-    0x54007560,     0x54000001,     0x54fff541,     0x54007501,\n-    0x54000002,     0x54fff4e2,     0x540074a2,     0x54000002,\n-    0x54fff482,     0x54007442,     0x54000003,     0x54fff423,\n-    0x540073e3,     0x54000003,     0x54fff3c3,     0x54007383,\n-    0x54000004,     0x54fff364,     0x54007324,     0x54000005,\n-    0x54fff305,     0x540072c5,     0x54000006,     0x54fff2a6,\n-    0x54007266,     0x54000007,     0x54fff247,     0x54007207,\n-    0x54000008,     0x54fff1e8,     0x540071a8,     0x54000009,\n-    0x54fff189,     0x54007149,     0x5400000a,     0x54fff12a,\n-    0x540070ea,     0x5400000b,     0x54fff0cb,     0x5400708b,\n-    0x5400000c,     0x54fff06c,     0x5400702c,     0x5400000d,\n-    0x54fff00d,     0x54006fcd,     0x5400000e,     0x54ffefae,\n-    0x54006f6e,     0x5400000f,     0x54ffef4f,     0x54006f0f,\n+    0x54007580,     0x54000001,     0x54fff541,     0x54007521,\n+    0x54000002,     0x54fff4e2,     0x540074c2,     0x54000002,\n+    0x54fff482,     0x54007462,     0x54000003,     0x54fff423,\n+    0x54007403,     0x54000003,     0x54fff3c3,     0x540073a3,\n+    0x54000004,     0x54fff364,     0x54007344,     0x54000005,\n+    0x54fff305,     0x540072e5,     0x54000006,     0x54fff2a6,\n+    0x54007286,     0x54000007,     0x54fff247,     0x54007227,\n+    0x54000008,     0x54fff1e8,     0x540071c8,     0x54000009,\n+    0x54fff189,     0x54007169,     0x5400000a,     0x54fff12a,\n+    0x5400710a,     0x5400000b,     0x54fff0cb,     0x540070ab,\n+    0x5400000c,     0x54fff06c,     0x5400704c,     0x5400000d,\n+    0x54fff00d,     0x54006fed,     0x5400000e,     0x54ffefae,\n+    0x54006f8e,     0x5400000f,     0x54ffef4f,     0x54006f2f,\n@@ -1393,51 +1394,52 @@\n-    0x05e14c00,     0x05304001,     0x05314001,     0x1e601000,\n-    0x1e603000,     0x1e621000,     0x1e623000,     0x1e641000,\n-    0x1e643000,     0x1e661000,     0x1e663000,     0x1e681000,\n-    0x1e683000,     0x1e6a1000,     0x1e6a3000,     0x1e6c1000,\n-    0x1e6c3000,     0x1e6e1000,     0x1e6e3000,     0x1e701000,\n-    0x1e703000,     0x1e721000,     0x1e723000,     0x1e741000,\n-    0x1e743000,     0x1e761000,     0x1e763000,     0x1e781000,\n-    0x1e783000,     0x1e7a1000,     0x1e7a3000,     0x1e7c1000,\n-    0x1e7c3000,     0x1e7e1000,     0x1e7e3000,     0xf82a822f,\n-    0xf822018a,     0xf82c11af,     0xf8222287,     0xf83a3090,\n-    0xf8225184,     0xf8304215,     0xf83072ab,     0xf837634c,\n-    0xf8b781dc,     0xf8ab0038,     0xf8ac115f,     0xf8b02047,\n-    0xf8a3326d,     0xf8b15070,     0xf8a143cb,     0xf8a571e8,\n-    0xf8bd601e,     0xf8f48287,     0xf8f702bc,     0xf8fb10b9,\n-    0xf8e12217,     0xf8ff3185,     0xf8e951fc,     0xf8fd43f6,\n-    0xf8f370bf,     0xf8ee63f0,     0xf870829b,     0xf870016c,\n-    0xf86913c6,     0xf871239b,     0xf87e3147,     0xf874508a,\n-    0xf8784231,     0xf87673a3,     0xf86f6276,     0xb8338056,\n-    0xb82f0186,     0xb83011ab,     0xb83723c1,     0xb8333225,\n-    0xb82252d0,     0xb82d42aa,     0xb83d719b,     0xb83b6023,\n-    0xb8bf8278,     0xb8b10389,     0xb8bb10ef,     0xb8b523f7,\n-    0xb8b933e2,     0xb8bb5150,     0xb8b74073,     0xb8b07320,\n-    0xb8ba6057,     0xb8f0808c,     0xb8fc03be,     0xb8f010db,\n-    0xb8e921fd,     0xb8e730e4,     0xb8ef52e9,     0xb8e84382,\n-    0xb8f570bf,     0xb8fb6220,     0xb86f8344,     0xb86802dc,\n-    0xb87b133b,     0xb8772080,     0xb8663010,     0xb864502f,\n-    0xb86a40a7,     0xb86a70fc,     0xb87462b7,     0xce284145,\n-    0xce1108de,     0xce7c8fab,     0xce96eb42,     0xce7b81ae,\n-    0xce6586f0,     0xcec081a2,     0xce6a89ea,     0x25a0cc5a,\n-    0x25a1d143,     0x05800e44,     0x05406531,     0x05002d42,\n-    0x2520c677,     0x25a1cd07,     0x0580687b,     0x0543bb42,\n-    0x050044a6,     0x25a0c86c,     0x25a1d358,     0x05800500,\n-    0x05400ad3,     0x05000e06,     0x25e0c951,     0x25a1d54a,\n-    0x05839276,     0x0540ea6f,     0x0503c8a4,     0x25a0d448,\n-    0x2521d056,     0x058059c9,     0x05406d05,     0x05003cb6,\n-    0x25a0d0c8,     0x2561c4f9,     0x05809904,     0x05400e5d,\n-    0x0500cadd,     0x043c0162,     0x04ba0427,     0x65c801d1,\n-    0x65c50b15,     0x65d60635,     0x0416b67d,     0x040012e4,\n-    0x04da06f3,     0x04508113,     0x04db1a2e,     0x041aa7d5,\n-    0x0419158a,     0x04938709,     0x045198c4,     0x049019bb,\n-    0x0497b6de,     0x045ebd3e,     0x04d80693,     0x044809a9,\n-    0x044a0313,     0x04810e33,     0x049ca410,     0x658089eb,\n-    0x65cd85ef,     0x65c68145,     0x6587801a,     0x65c29d53,\n-    0x04ddb4e3,     0x6582aebc,     0x65c0ae3a,     0x65c1ac51,\n-    0x658db690,     0x65c18033,     0x65f18a11,     0x65b70440,\n-    0x65ee2a86,     0x65e3ac7d,     0x65bbc309,     0x65f9f4f3,\n-    0x65b944ed,     0x65a07235,     0x04475569,     0x044b722e,\n-    0x043e3238,     0x04ae31e8,     0x04763376,     0x04fb30a8,\n-    0x05ee680a,     0x05206e95,     0x04da38b6,     0x0418323d,\n-    0x04592fac,     0x04c83040,     0x04ca36b4,     0x6587284c,\n-    0x658636ce,     0x65d83b53,     0x040136ac,\n+    0x05e14c00,     0x05304001,     0x05314001,     0x05271e11,\n+    0x1e601000,     0x1e603000,     0x1e621000,     0x1e623000,\n+    0x1e641000,     0x1e643000,     0x1e661000,     0x1e663000,\n+    0x1e681000,     0x1e683000,     0x1e6a1000,     0x1e6a3000,\n+    0x1e6c1000,     0x1e6c3000,     0x1e6e1000,     0x1e6e3000,\n+    0x1e701000,     0x1e703000,     0x1e721000,     0x1e723000,\n+    0x1e741000,     0x1e743000,     0x1e761000,     0x1e763000,\n+    0x1e781000,     0x1e783000,     0x1e7a1000,     0x1e7a3000,\n+    0x1e7c1000,     0x1e7c3000,     0x1e7e1000,     0x1e7e3000,\n+    0xf82a822f,     0xf822018a,     0xf82c11af,     0xf8222287,\n+    0xf83a3090,     0xf8225184,     0xf8304215,     0xf83072ab,\n+    0xf837634c,     0xf8b781dc,     0xf8ab0038,     0xf8ac115f,\n+    0xf8b02047,     0xf8a3326d,     0xf8b15070,     0xf8a143cb,\n+    0xf8a571e8,     0xf8bd601e,     0xf8f48287,     0xf8f702bc,\n+    0xf8fb10b9,     0xf8e12217,     0xf8ff3185,     0xf8e951fc,\n+    0xf8fd43f6,     0xf8f370bf,     0xf8ee63f0,     0xf870829b,\n+    0xf870016c,     0xf86913c6,     0xf871239b,     0xf87e3147,\n+    0xf874508a,     0xf8784231,     0xf87673a3,     0xf86f6276,\n+    0xb8338056,     0xb82f0186,     0xb83011ab,     0xb83723c1,\n+    0xb8333225,     0xb82252d0,     0xb82d42aa,     0xb83d719b,\n+    0xb83b6023,     0xb8bf8278,     0xb8b10389,     0xb8bb10ef,\n+    0xb8b523f7,     0xb8b933e2,     0xb8bb5150,     0xb8b74073,\n+    0xb8b07320,     0xb8ba6057,     0xb8f0808c,     0xb8fc03be,\n+    0xb8f010db,     0xb8e921fd,     0xb8e730e4,     0xb8ef52e9,\n+    0xb8e84382,     0xb8f570bf,     0xb8fb6220,     0xb86f8344,\n+    0xb86802dc,     0xb87b133b,     0xb8772080,     0xb8663010,\n+    0xb864502f,     0xb86a40a7,     0xb86a70fc,     0xb87462b7,\n+    0xce284145,     0xce1108de,     0xce7c8fab,     0xce96eb42,\n+    0xce7b81ae,     0xce6586f0,     0xcec081a2,     0xce6a89ea,\n+    0x25a0cc5a,     0x25a1d143,     0x05800e44,     0x05406531,\n+    0x05002d42,     0x2520c677,     0x25a1cd07,     0x0580687b,\n+    0x0543bb42,     0x050044a6,     0x25a0c86c,     0x25a1d358,\n+    0x05800500,     0x05400ad3,     0x05000e06,     0x25e0c951,\n+    0x25a1d54a,     0x05839276,     0x0540ea6f,     0x0503c8a4,\n+    0x25a0d448,     0x2521d056,     0x058059c9,     0x05406d05,\n+    0x05003cb6,     0x25a0d0c8,     0x2561c4f9,     0x05809904,\n+    0x05400e5d,     0x0500cadd,     0x043c0162,     0x04ba0427,\n+    0x65c801d1,     0x65c50b15,     0x65d60635,     0x0416b67d,\n+    0x040012e4,     0x04da06f3,     0x04508113,     0x04db1a2e,\n+    0x041aa7d5,     0x0419158a,     0x04938709,     0x045198c4,\n+    0x049019bb,     0x0497b6de,     0x045ebd3e,     0x04d80693,\n+    0x044809a9,     0x044a0313,     0x04810e33,     0x049ca410,\n+    0x658089eb,     0x65cd85ef,     0x65c68145,     0x6587801a,\n+    0x65c29d53,     0x04ddb4e3,     0x6582aebc,     0x65c0ae3a,\n+    0x65c1ac51,     0x658db690,     0x65c18033,     0x65f18a11,\n+    0x65b70440,     0x65ee2a86,     0x65e3ac7d,     0x65bbc309,\n+    0x65f9f4f3,     0x65b944ed,     0x65a07235,     0x04475569,\n+    0x044b722e,     0x043e3238,     0x04ae31e8,     0x04763376,\n+    0x04fb30a8,     0x05ee680a,     0x05206e95,     0x04da38b6,\n+    0x0418323d,     0x04592fac,     0x04c83040,     0x04ca36b4,\n+    0x6587284c,     0x658636ce,     0x65d83b53,     0x040136ac,\n+\n","filename":"test\/hotspot\/gtest\/aarch64\/asmtest.out.h","additions":73,"deletions":71,"binary":false,"changes":144,"status":"modified"}]}