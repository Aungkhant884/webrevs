{"files":[{"patch":"@@ -1753,1 +1753,1 @@\n-instruct insert8B(vecD dst, vecD src, iRegIorL2I val, immI idx)\n+instruct insertID(vecD dst, vecD src, iRegIorL2I val, immI idx)\n@@ -1755,1 +1755,3 @@\n-  predicate(n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n+  predicate((n->bottom_type()->is_vect()->element_basic_type() == T_BYTE ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_INT));\n@@ -1757,69 +1759,1 @@\n-  ins_cost(INSN_COST);\n-  format %{ \"orr    $dst, T8B, $src, $src\\n\\t\"\n-            \"mov    $dst, B, $idx, $val\\t# insert into vector(8B)\" %}\n-  ins_encode %{\n-    if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n-      __ orr(as_FloatRegister($dst$$reg), __ T8B,\n-             as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-    }\n-    __ mov(as_FloatRegister($dst$$reg), __ B, $idx$$constant, $val$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct insert16B(vecX dst, vecX src, iRegIorL2I val, immI idx)\n-%{\n-  predicate(n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (VectorInsert (Binary src val) idx));\n-  ins_cost(INSN_COST);\n-  format %{ \"orr    $dst, T16B, $src, $src\\n\\t\"\n-            \"mov    $dst, B, $idx, $val\\t# insert into vector(16B)\" %}\n-  ins_encode %{\n-    if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n-      __ orr(as_FloatRegister($dst$$reg), __ T16B,\n-             as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-    }\n-    __ mov(as_FloatRegister($dst$$reg), __ B, $idx$$constant, $val$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct insert4S(vecD dst, vecD src, iRegIorL2I val, immI idx)\n-%{\n-  predicate(n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (VectorInsert (Binary src val) idx));\n-  ins_cost(INSN_COST);\n-  format %{ \"orr    $dst, T8B, $src, $src\\n\\t\"\n-            \"mov    $dst, H, $idx, $val\\t# insert into vector(4S)\" %}\n-  ins_encode %{\n-    if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n-      __ orr(as_FloatRegister($dst$$reg), __ T8B,\n-             as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-    }\n-    __ mov(as_FloatRegister($dst$$reg), __ H, $idx$$constant, $val$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct insert8S(vecX dst, vecX src, iRegIorL2I val, immI idx)\n-%{\n-  predicate(n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (VectorInsert (Binary src val) idx));\n-  ins_cost(INSN_COST);\n-  format %{ \"orr    $dst, T16B, $src, $src\\n\\t\"\n-            \"mov    $dst, H, $idx, $val\\t# insert into vector(8S)\" %}\n-  ins_encode %{\n-    if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n-      __ orr(as_FloatRegister($dst$$reg), __ T16B,\n-             as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-    }\n-    __ mov(as_FloatRegister($dst$$reg), __ H, $idx$$constant, $val$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct insert2I(vecD dst, vecD src, iRegIorL2I val, immI idx)\n-%{\n-  predicate(n->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (VectorInsert (Binary src val) idx));\n-  ins_cost(INSN_COST);\n+  ins_cost(2 * INSN_COST);\n@@ -1827,1 +1761,1 @@\n-            \"mov    $dst, S, $idx, $val\\t# insert into vector(2I)\" %}\n+            \"mov    $dst, B\/H\/S, $idx, $val\\t# insert into vector (B\/H\/S)\" %}\n@@ -1833,1 +1767,2 @@\n-    __ mov(as_FloatRegister($dst$$reg), __ S, $idx$$constant, $val$$Register);\n+    __ mov(as_FloatRegister($dst$$reg), __ elemType_to_regVariant(Matcher::vector_element_basic_type(this)),\n+           $idx$$constant, $val$$Register);\n@@ -1838,1 +1773,1 @@\n-instruct insert4I(vecX dst, vecX src, iRegIorL2I val, immI idx)\n+instruct insertIX(vecX dst, vecX src, iRegIorL2I val, immI idx)\n@@ -1840,1 +1775,3 @@\n-  predicate(n->bottom_type()->is_vect()->element_basic_type() == T_INT);\n+  predicate((n->bottom_type()->is_vect()->element_basic_type() == T_BYTE ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_INT));\n@@ -1842,1 +1779,1 @@\n-  ins_cost(INSN_COST);\n+  ins_cost(2 * INSN_COST);\n@@ -1844,1 +1781,1 @@\n-            \"mov    $dst, S, $idx, $val\\t# insert into vector(4I)\" %}\n+            \"mov    $dst, B\/H\/S, $idx, $val\\t# insert into vector (B\/H\/S)\" %}\n@@ -1850,1 +1787,2 @@\n-    __ mov(as_FloatRegister($dst$$reg), __ S, $idx$$constant, $val$$Register);\n+    __ mov(as_FloatRegister($dst$$reg), __ elemType_to_regVariant(Matcher::vector_element_basic_type(this)),\n+           $idx$$constant, $val$$Register);\n@@ -1859,1 +1797,1 @@\n-  ins_cost(INSN_COST);\n+  ins_cost(2 * INSN_COST);\n@@ -1861,1 +1799,1 @@\n-            \"mov    $dst, D, $idx, $val\\t# insert into vector(2L)\" %}\n+            \"mov    $dst, D, $idx, $val\\t# insert into vector (D)\" %}\n@@ -1867,1 +1805,2 @@\n-    __ mov(as_FloatRegister($dst$$reg), __ D, $idx$$constant, $val$$Register);\n+    __ mov(as_FloatRegister($dst$$reg), __ D,\n+           $idx$$constant, $val$$Register);\n@@ -1876,1 +1815,1 @@\n-  ins_cost(INSN_COST);\n+  ins_cost(2 * INSN_COST);\n@@ -1893,1 +1832,1 @@\n-  ins_cost(INSN_COST);\n+  ins_cost(2 * INSN_COST);\n@@ -1910,1 +1849,1 @@\n-  ins_cost(INSN_COST);\n+  ins_cost(2 * INSN_COST);\n@@ -2016,2 +1955,9 @@\n-    __ ins(as_FloatRegister($dst$$reg), __ S,\n-           as_FloatRegister($src$$reg), 0, $idx$$constant);\n+    if ((0 == $idx$$constant) &&\n+        (as_FloatRegister($dst$$reg) == as_FloatRegister($src$$reg))) {\n+      \/* empty *\/\n+    } else if ($idx$$constant == 0) {\n+      __ fmovs(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg));\n+    } else {\n+      __ ins(as_FloatRegister($dst$$reg), __ S,\n+             as_FloatRegister($src$$reg), 0, $idx$$constant);\n+    }\n@@ -2029,2 +1975,9 @@\n-    __ ins(as_FloatRegister($dst$$reg), __ S,\n-           as_FloatRegister($src$$reg), 0, $idx$$constant);\n+    if ((0 == $idx$$constant) &&\n+        (as_FloatRegister($dst$$reg) == as_FloatRegister($src$$reg))) {\n+      \/* empty *\/\n+    } else if ($idx$$constant == 0) {\n+      __ fmovs(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg));\n+    } else {\n+      __ ins(as_FloatRegister($dst$$reg), __ S,\n+             as_FloatRegister($src$$reg), 0, $idx$$constant);\n+    }\n@@ -2042,2 +1995,9 @@\n-    __ ins(as_FloatRegister($dst$$reg), __ D,\n-           as_FloatRegister($src$$reg), 0, $idx$$constant);\n+    if ((0 == $idx$$constant) &&\n+        (as_FloatRegister($dst$$reg) == as_FloatRegister($src$$reg))) {\n+      \/* empty *\/\n+    } else if ($idx$$constant == 0) {\n+      __ fmovd(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg));\n+    } else {\n+      __ ins(as_FloatRegister($dst$$reg), __ D,\n+             as_FloatRegister($src$$reg), 0, $idx$$constant);\n+    }\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_neon.ad","additions":50,"deletions":90,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -890,0 +890,2 @@\n+dnl VECTOR_INSERT_I($1,        $2,                     $3,          $4,   $5)\n+dnl VECTOR_INSERT_I(rule_name, vector_length_in_bytes, reg_variant, vreg, ireg)\n@@ -891,1 +893,1 @@\n-instruct insert$1$2`'(vec$3 dst, vec$3 src, iReg$4`'ORL2I($4) val, immI idx)\n+instruct $1($4 dst, $4 src, $5 val, immI idx)\n@@ -893,1 +895,4 @@\n-  predicate(n->bottom_type()->is_vect()->element_basic_type() == T_`'TYPE2DATATYPE($2));\n+  predicate(ifelse($3, D, n->bottom_type()->is_vect()->element_basic_type() == T_LONG,\n+            (n->bottom_type()->is_vect()->element_basic_type() == T_BYTE ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_INT)));\n@@ -895,3 +900,3 @@\n-  ins_cost(INSN_COST);\n-  format %{ \"orr    $dst, T$5, $src, $src\\n\\t\"\n-            \"mov    $dst, iTYPE2SIMD($2), $idx, $val\\t# insert into vector($1$2)\" %}\n+  ins_cost(2 * INSN_COST);\n+  format %{ \"orr    $dst, T$2B, $src, $src\\n\\t\"\n+            \"mov    $dst, $3, $idx, $val\\t`#' insert into vector ($3)\" %}\n@@ -900,1 +905,1 @@\n-      __ orr(as_FloatRegister($dst$$reg), __ T$5,\n+      __ orr(as_FloatRegister($dst$$reg), __ T$2B,\n@@ -903,1 +908,2 @@\n-    __ mov(as_FloatRegister($dst$$reg), __ iTYPE2SIMD($2), $idx$$constant, $val$$Register);\n+    __ mov(as_FloatRegister($dst$$reg), __ ifelse($3, D, D, elemType_to_regVariant(Matcher::vector_element_basic_type(this))),\n+           $idx$$constant, $val$$Register);\n@@ -907,8 +913,4 @@\n-dnl             $1  $2 $3 $4 $5\n-VECTOR_INSERT_I(8,  B, D, I, 8B)\n-VECTOR_INSERT_I(16, B, X, I, 16B)\n-VECTOR_INSERT_I(4,  S, D, I, 8B)\n-VECTOR_INSERT_I(8,  S, X, I, 16B)\n-VECTOR_INSERT_I(2,  I, D, I, 8B)\n-VECTOR_INSERT_I(4,  I, X, I, 16B)\n-VECTOR_INSERT_I(2,  L, X, L, 16B)\n+dnl             $1        $2  $3     $4    $5\n+VECTOR_INSERT_I(insertID, 8,  B\/H\/S, vecD, iRegIorL2I)\n+VECTOR_INSERT_I(insertIX, 16, B\/H\/S, vecX, iRegIorL2I)\n+VECTOR_INSERT_I(insert2L, 16, D,     vecX, iRegL)\n@@ -917,1 +919,1 @@\n-instruct insert$1`'(vec$2 dst, vec$2 src, vReg$3 val, immI idx)\n+instruct insert$3`'(vec$2 dst, vec$2 src, vReg$1 val, immI idx)\n@@ -919,1 +921,1 @@\n-  predicate(n->bottom_type()->is_vect()->element_basic_type() == T_`'TYPE2DATATYPE($3));\n+  predicate(n->bottom_type()->is_vect()->element_basic_type() == T_`'TYPE2DATATYPE($1));\n@@ -921,1 +923,1 @@\n-  ins_cost(INSN_COST);\n+  ins_cost(2 * INSN_COST);\n@@ -923,2 +925,2 @@\n-  format %{ \"orr    $dst, T$4, $src, $src\\n\\t\"\n-            \"ins    $dst, $5, $val, $idx, 0\\t# insert into vector($1)\" %}\n+  format %{ \"orr    $dst, ifelse($2, D, T8B, T16B), $src, $src\\n\\t\"\n+            \"ins    $dst, ifelse($1, F, S, D), $val, $idx, 0\\t# insert into vector($3)\" %}\n@@ -926,1 +928,1 @@\n-    __ orr(as_FloatRegister($dst$$reg), __ T$4,\n+    __ orr(as_FloatRegister($dst$$reg), __ ifelse($2, D, T8B, T16B),\n@@ -928,1 +930,1 @@\n-    __ ins(as_FloatRegister($dst$$reg), __ $5,\n+    __ ins(as_FloatRegister($dst$$reg), __ ifelse($1, F, S, D),\n@@ -933,4 +935,4 @@\n-dnl             $1  $2 $3 $4   $5\n-VECTOR_INSERT_F(2F, D, F, 8B,  S)\n-VECTOR_INSERT_F(4F, X, F, 16B, S)\n-VECTOR_INSERT_F(2D, X, D, 16B, D)\n+dnl             $1 $2 $3\n+VECTOR_INSERT_F(F, D, 2F)\n+VECTOR_INSERT_F(F, X, 4F)\n+VECTOR_INSERT_F(D, X, 2D)\n@@ -969,2 +971,9 @@\n-    __ ins(as_FloatRegister($dst$$reg), __ $4,\n-           as_FloatRegister($src$$reg), 0, $idx$$constant);\n+    if ((0 == $idx$$constant) &&\n+        (as_FloatRegister($dst$$reg) == as_FloatRegister($src$$reg))) {\n+      \/* empty *\/\n+    } else if ($idx$$constant == 0) {\n+      __ ifelse($2, F, fmovs, fmovd)(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg));\n+    } else {\n+      __ ins(as_FloatRegister($dst$$reg), __ $4,\n+             as_FloatRegister($src$$reg), 0, $idx$$constant);\n+    }\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_neon_ad.m4","additions":37,"deletions":28,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -4710,1 +4710,1 @@\n-instruct extractB(iRegINoSp dst, vReg src, immI idx, pRegGov pgtmp, rFlagsReg cr)\n+instruct extractB(iRegINoSp dst, vReg src, immI idx, vReg vtmp)\n@@ -4712,1 +4712,1 @@\n-  predicate(UseSVE > 0);\n+  predicate(UseSVE > 0 && n->in(2)->get_int() >= 16);\n@@ -4714,1 +4714,1 @@\n-  effect(TEMP pgtmp, KILL cr);\n+  effect(TEMP vtmp);\n@@ -4716,2 +4716,1 @@\n-  format %{ \"sve_extract $dst, B, $pgtmp, $src, $idx\\n\\t\"\n-            \"sbfmw $dst, $dst, 0U, 7U\\t# extract from vector(B)\" %}\n+  format %{ \"sve_extract_integral $dst, B, $src, $idx\\t# extract from vector(B)\" %}\n@@ -4719,3 +4718,2 @@\n-    __ sve_extract(as_Register($dst$$reg), __ B, as_PRegister($pgtmp$$reg),\n-                   as_FloatRegister($src$$reg), (int)($idx$$constant));\n-    __ sbfmw(as_Register($dst$$reg), as_Register($dst$$reg), 0U, 7U);\n+    __ sve_extract_integral(as_Register($dst$$reg), __ B, as_FloatRegister($src$$reg),\n+                            (int)($idx$$constant), \/* is_signed *\/ true, as_FloatRegister($vtmp$$reg));\n@@ -4726,1 +4724,1 @@\n-instruct extractS(iRegINoSp dst, vReg src, immI idx, pRegGov pgtmp, rFlagsReg cr)\n+instruct extractS(iRegINoSp dst, vReg src, immI idx, vReg vtmp)\n@@ -4728,1 +4726,1 @@\n-  predicate(UseSVE > 0);\n+  predicate(UseSVE > 0 && n->in(2)->get_int() >= 8);\n@@ -4730,1 +4728,1 @@\n-  effect(TEMP pgtmp, KILL cr);\n+  effect(TEMP vtmp);\n@@ -4732,2 +4730,1 @@\n-  format %{ \"sve_extract $dst, H, $pgtmp, $src, $idx\\n\\t\"\n-            \"sbfmw $dst, $dst, 0U, 15U\\t# extract from vector(S)\" %}\n+  format %{ \"sve_extract_integral $dst, H, $src, $idx\\t# extract from vector(S)\" %}\n@@ -4735,3 +4732,2 @@\n-    __ sve_extract(as_Register($dst$$reg), __ H, as_PRegister($pgtmp$$reg),\n-                   as_FloatRegister($src$$reg), (int)($idx$$constant));\n-    __ sbfmw(as_Register($dst$$reg), as_Register($dst$$reg), 0U, 15U);\n+    __ sve_extract_integral(as_Register($dst$$reg), __ H, as_FloatRegister($src$$reg),\n+                            (int)($idx$$constant), \/* is_signed *\/ true, as_FloatRegister($vtmp$$reg));\n@@ -4742,2 +4738,1 @@\n-\n-instruct extractI(iRegINoSp dst, vReg src, immI idx, pRegGov pgtmp, rFlagsReg cr)\n+instruct extractI(iRegINoSp dst, vReg src, immI idx, vReg vtmp)\n@@ -4745,1 +4740,1 @@\n-  predicate(UseSVE > 0);\n+  predicate(UseSVE > 0 && n->in(2)->get_int() >= 4);\n@@ -4747,1 +4742,1 @@\n-  effect(TEMP pgtmp, KILL cr);\n+  effect(TEMP vtmp);\n@@ -4749,1 +4744,1 @@\n-  format %{ \"sve_extract $dst, S, $pgtmp, $src, $idx\\t# extract from vector(I)\" %}\n+  format %{ \"sve_extract_integral $dst, S, $src, $idx\\t# extract from vector(I)\" %}\n@@ -4751,2 +4746,2 @@\n-    __ sve_extract(as_Register($dst$$reg), __ S, as_PRegister($pgtmp$$reg),\n-                   as_FloatRegister($src$$reg), (int)($idx$$constant));\n+    __ sve_extract_integral(as_Register($dst$$reg), __ S, as_FloatRegister($src$$reg),\n+                            (int)($idx$$constant), \/* is_signed *\/ true, as_FloatRegister($vtmp$$reg));\n@@ -4757,1 +4752,1 @@\n-instruct extractL(iRegLNoSp dst, vReg src, immI idx, pRegGov pgtmp, rFlagsReg cr)\n+instruct extractL(iRegLNoSp dst, vReg src, immI idx, vReg vtmp)\n@@ -4759,1 +4754,1 @@\n-  predicate(UseSVE > 0);\n+  predicate(UseSVE > 0 && n->in(2)->get_int() >= 2);\n@@ -4761,1 +4756,1 @@\n-  effect(TEMP pgtmp, KILL cr);\n+  effect(TEMP vtmp);\n@@ -4763,1 +4758,1 @@\n-  format %{ \"sve_extract $dst, D, $pgtmp, $src, $idx\\t# extract from vector(L)\" %}\n+  format %{ \"sve_extract_integral $dst, D, $src, $idx\\t# extract from vector(L)\" %}\n@@ -4765,2 +4760,2 @@\n-    __ sve_extract(as_Register($dst$$reg), __ D, as_PRegister($pgtmp$$reg),\n-                   as_FloatRegister($src$$reg), (int)($idx$$constant));\n+    __ sve_extract_integral(as_Register($dst$$reg), __ D, as_FloatRegister($src$$reg),\n+                            (int)($idx$$constant), \/* is_signed *\/ false, as_FloatRegister($vtmp$$reg));\n@@ -4771,1 +4766,49 @@\n-instruct extractF(vRegF dst, vReg src, immI idx, pRegGov pgtmp, rFlagsReg cr)\n+instruct extractB_LT16(iRegINoSp dst, vReg src, immI idx)\n+%{\n+  predicate(UseSVE > 0 && n->in(2)->get_int() < 16);\n+  match(Set dst (ExtractB src idx));\n+  ins_cost(INSN_COST);\n+  format %{ \"smov $dst, B, $src, $idx\\t# extract from vector(B)\" %}\n+  ins_encode %{\n+    __ smov(as_Register($dst$$reg), as_FloatRegister($src$$reg), __ B, $idx$$constant);\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct extractS_LT8(iRegINoSp dst, vReg src, immI idx)\n+%{\n+  predicate(UseSVE > 0 && n->in(2)->get_int() < 8);\n+  match(Set dst (ExtractS src idx));\n+  ins_cost(INSN_COST);\n+  format %{ \"smov $dst, H, $src, $idx\\t# extract from vector(S)\" %}\n+  ins_encode %{\n+    __ smov(as_Register($dst$$reg), as_FloatRegister($src$$reg), __ H, $idx$$constant);\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct extractI_LT4(iRegINoSp dst, vReg src, immI idx)\n+%{\n+  predicate(UseSVE > 0 && n->in(2)->get_int() < 4);\n+  match(Set dst (ExtractI src idx));\n+  ins_cost(INSN_COST);\n+  format %{ \"smov $dst, S, $src, $idx\\t# extract from vector(I)\" %}\n+  ins_encode %{\n+    __ smov(as_Register($dst$$reg), as_FloatRegister($src$$reg), __ S, $idx$$constant);\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct extractL_LT2(iRegLNoSp dst, vReg src, immI idx)\n+%{\n+  predicate(UseSVE > 0 && n->in(2)->get_int() < 2);\n+  match(Set dst (ExtractL src idx));\n+  ins_cost(INSN_COST);\n+  format %{ \"umov $dst, D, $src, $idx\\t# extract from vector(L)\" %}\n+  ins_encode %{\n+    __ umov(as_Register($dst$$reg), as_FloatRegister($src$$reg), __ D, $idx$$constant);\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct extractF(vRegF dst, vReg src, immI idx)\n@@ -4775,1 +4818,0 @@\n-  effect(TEMP pgtmp, KILL cr);\n@@ -4777,4 +4819,12 @@\n-  format %{ \"sve_extract $dst, S, $pgtmp, $src, $idx\\t# extract from vector(F)\" %}\n-  ins_encode %{\n-    __ sve_extract(as_FloatRegister($dst$$reg), __ S, as_PRegister($pgtmp$$reg),\n-                   as_FloatRegister($src$$reg), (int)($idx$$constant));\n+  format %{ \"sve_extract_f $dst, S, $src, $idx\\t# extract from vector(F)\" %}\n+  ins_encode %{\n+    if ((as_FloatRegister($dst$$reg) == as_FloatRegister($src$$reg)) && ($idx$$constant == 0)) {\n+      \/* empty *\/\n+    } else if ($idx$$constant == 0) {\n+      __ fmovs(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg));\n+    } else if ($idx$$constant < 4) {\n+      __ ins(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($src$$reg), 0, (int)($idx$$constant));\n+    } else {\n+      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n+      __ sve_ext(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), $idx$$constant << 2);\n+    }\n@@ -4785,1 +4835,1 @@\n-instruct extractD(vRegD dst, vReg src, immI idx, pRegGov pgtmp, rFlagsReg cr)\n+instruct extractD(vRegD dst, vReg src, immI idx)\n@@ -4789,1 +4839,0 @@\n-  effect(TEMP pgtmp, KILL cr);\n@@ -4791,4 +4840,12 @@\n-  format %{ \"sve_extract $dst, D, $pgtmp, $src, $idx\\t# extract from vector(D)\" %}\n-  ins_encode %{\n-    __ sve_extract(as_FloatRegister($dst$$reg), __ D, as_PRegister($pgtmp$$reg),\n-                   as_FloatRegister($src$$reg), (int)($idx$$constant));\n+  format %{ \"sve_extract_d $dst, D, $src, $idx\\t# extract from vector(D)\" %}\n+  ins_encode %{\n+    if ((as_FloatRegister($dst$$reg) == as_FloatRegister($src$$reg)) && ($idx$$constant == 0)) {\n+      \/* empty *\/\n+    } else if ($idx$$constant == 0) {\n+      __ fmovd(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg));\n+    } else if ($idx$$constant == 1) {\n+      __ ins(as_FloatRegister($dst$$reg), __ D, as_FloatRegister($src$$reg), 0, 1);\n+    } else {\n+      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n+      __ sve_ext(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), $idx$$constant << 3);\n+    }\n@@ -4836,3 +4893,3 @@\n-instruct insertI_small(vReg dst, vReg src, iRegIorL2I val, immI idx, pRegGov pgtmp, rFlagsReg cr)\n-%{\n-  predicate(UseSVE > 0 && n->as_Vector()->length() <= 32 &&\n+instruct insertI_le128bits(vReg dst, vReg src, iRegIorL2I val, immI idx) %{\n+  predicate(UseSVE > 0 &&\n+            (Matcher::vector_length_in_bytes(n) == 8 || Matcher::vector_length_in_bytes(n) == 16) &&\n@@ -4843,6 +4900,3 @@\n-  effect(TEMP_DEF dst, TEMP pgtmp, KILL cr);\n-  ins_cost(4 * SVE_COST);\n-  format %{ \"sve_index $dst, -16, 1\\t# (B\/H\/S)\\n\\t\"\n-            \"sve_cmpeq $pgtmp, $dst, ($idx-#16) # shift from [0, 31] to [-16, 15]\\n\\t\"\n-            \"sve_orr $dst, $src, $src\\n\\t\"\n-            \"sve_cpy $dst, $pgtmp, $val\\t# insert into vector (B\/H\/S)\" %}\n+  ins_cost(2 * INSN_COST);\n+  format %{ \"orr    $dst, T8\/16B, $src, $src\\n\\t\"\n+            \"mov    $dst, B\/H\/S, $idx, $val\\t# insertI into vector(64\/128bits)\" %}\n@@ -4850,7 +4904,7 @@\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ sve_index(as_FloatRegister($dst$$reg), size, -16, 1);\n-    __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), size, ptrue,\n-               as_FloatRegister($dst$$reg), (int)($idx$$constant) - 16);\n-    __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-    __ sve_cpy(as_FloatRegister($dst$$reg), size, as_PRegister($pgtmp$$reg), as_Register($val$$reg));\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n+      __ orr(as_FloatRegister($dst$$reg), Matcher::vector_length_in_bytes(this) == 8 ? __ T8B : __ T16B,\n+             as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n+    }\n+    __ mov(as_FloatRegister($dst$$reg), __ elemType_to_regVariant(Matcher::vector_element_basic_type(this)),\n+           $idx$$constant, $val$$Register);\n@@ -4861,4 +4915,6 @@\n-instruct insertF_small(vReg dst, vReg src, vRegF val, immI idx, pRegGov pgtmp, rFlagsReg cr)\n-%{\n-  predicate(UseSVE > 0 && n->as_Vector()->length() <= 32 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n+instruct insertI_small_index(vReg dst, vReg src, iRegIorL2I val, immI idx, vReg vtmp, pRegGov pgtmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && n->in(2)->get_int() < 32 &&\n+            Matcher::vector_length_in_bytes(n) > 16 &&\n+            (n->bottom_type()->is_vect()->element_basic_type() == T_BYTE ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_INT));\n@@ -4866,1 +4922,1 @@\n-  effect(TEMP_DEF dst, TEMP pgtmp, KILL cr);\n+  effect(TEMP vtmp, TEMP pgtmp, KILL cr);\n@@ -4868,2 +4924,2 @@\n-  format %{ \"sve_index $dst, S, -16, 1\\n\\t\"\n-            \"sve_cmpeq $pgtmp, $dst, ($idx-#16) # shift from [0, 31] to [-16, 15]\\n\\t\"\n+  format %{ \"sve_index $vtmp, -16, 1\\t# (B\/H\/S)\\n\\t\"\n+            \"sve_cmpeq $pgtmp, $vtmp, ($idx-#16) # shift from [0, 31] to [-16, 15]\\n\\t\"\n@@ -4871,1 +4927,1 @@\n-            \"sve_cpy $dst, $pgtmp, $val\\t# insert into vector (F)\" %}\n+            \"sve_cpy $dst, $pgtmp, $val\\t# insert into vector (B\/H\/S)\" %}\n@@ -4873,5 +4929,11 @@\n-    __ sve_index(as_FloatRegister($dst$$reg), __ S, -16, 1);\n-    __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), __ S, ptrue,\n-               as_FloatRegister($dst$$reg), (int)($idx$$constant) - 16);\n-    __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-    __ sve_cpy(as_FloatRegister($dst$$reg), __ S, as_PRegister($pgtmp$$reg), as_FloatRegister($val$$reg));\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ block_comment(\"insert into vector (B\/H\/S) {\");\n+      __ sve_index(as_FloatRegister($vtmp$$reg), size, -16, 1);\n+      __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), size, ptrue,\n+                 as_FloatRegister($vtmp$$reg), (int)($idx$$constant) - 16);\n+      if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n+        __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n+      }\n+      __ sve_cpy(as_FloatRegister($dst$$reg), size, as_PRegister($pgtmp$$reg), $val$$Register);\n+    __ block_comment(\"} insert into vector (B\/H\/S)\");\n@@ -4882,3 +4944,3 @@\n-instruct insertI(vReg dst, vReg src, iRegIorL2I val, immI idx, vReg tmp1, pRegGov pgtmp, rFlagsReg cr)\n-%{\n-  predicate(UseSVE > 0 && n->as_Vector()->length() > 32 &&\n+instruct insertI(vReg dst, vReg src, iRegIorL2I val, immI idx, vReg vtmp1, vReg vtmp2, pRegGov pgtmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && n->in(2)->get_int() >= 32 &&\n+            Matcher::vector_length_in_bytes(n) > 16 &&\n@@ -4889,1 +4951,1 @@\n-  effect(TEMP_DEF dst, TEMP tmp1, TEMP pgtmp, KILL cr);\n+  effect(TEMP vtmp1, TEMP vtmp2, TEMP pgtmp, KILL cr);\n@@ -4891,3 +4953,3 @@\n-  format %{ \"sve_index $tmp1, 0, 1\\t# (B\/H\/S)\\n\\t\"\n-            \"sve_dup $dst, $idx\\t# (B\/H\/S)\\n\\t\"\n-            \"sve_cmpeq $pgtmp, $tmp1, $dst\\n\\t\"\n+  format %{ \"sve_index $vtmp1, 0, 1\\t# (B\/H\/S)\\n\\t\"\n+            \"sve_dup $vtmp2, $idx\\t# (B\/H\/S)\\n\\t\"\n+            \"sve_cmpeq $pgtmp, $vtmp1, $vtmp2\\n\\t\"\n@@ -4899,6 +4961,10 @@\n-    __ sve_index(as_FloatRegister($tmp1$$reg), size, 0, 1);\n-    __ sve_dup(as_FloatRegister($dst$$reg), size, (int)($idx$$constant));\n-    __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), size, ptrue,\n-               as_FloatRegister($tmp1$$reg), as_FloatRegister($dst$$reg));\n-    __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-    __ sve_cpy(as_FloatRegister($dst$$reg), size, as_PRegister($pgtmp$$reg), as_Register($val$$reg));\n+    __ block_comment(\"insert into vector (B\/H\/S) {\");\n+      __ sve_index(as_FloatRegister($vtmp1$$reg), size, 0, 1);\n+      __ sve_dup(as_FloatRegister($vtmp2$$reg), size, (int)($idx$$constant));\n+      __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), size, ptrue,\n+                 as_FloatRegister($vtmp1$$reg), as_FloatRegister($vtmp2$$reg));\n+      if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n+        __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n+      }\n+      __ sve_cpy(as_FloatRegister($dst$$reg), size, as_PRegister($pgtmp$$reg), $val$$Register);\n+    __ block_comment(\"} insert into vector (B\/H\/S)\");\n@@ -4909,2 +4975,19 @@\n-instruct insertL(vReg dst, vReg src, iRegL val, immI idx, pRegGov pgtmp, rFlagsReg cr)\n-%{\n+instruct insertL_128bits(vReg dst, vReg src, iRegL val, immI idx) %{\n+  predicate(UseSVE > 0 && Matcher::vector_length_in_bytes(n) == 16 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  ins_cost(2 * INSN_COST);\n+  format %{ \"orr    $dst, T16B, $src, $src\\n\\t\"\n+            \"mov    $dst, D, $idx, $val\\t# insertL into vector(128bits)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n+      __ orr(as_FloatRegister($dst$$reg), __ T16B,\n+             as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n+    }\n+    __ mov(as_FloatRegister($dst$$reg), __ D, $idx$$constant, $val$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct insertL(vReg dst, vReg src, iRegL val, immI idx, vReg vtmp, pRegGov pgtmp, rFlagsReg cr) %{\n@@ -4912,0 +4995,1 @@\n+            Matcher::vector_length_in_bytes(n) > 16 &&\n@@ -4914,1 +4998,1 @@\n-  effect(TEMP_DEF dst, TEMP pgtmp, KILL cr);\n+  effect(TEMP vtmp, TEMP pgtmp, KILL cr);\n@@ -4916,2 +5000,2 @@\n-  format %{ \"sve_index $dst, D, -16, 1\\n\\t\"\n-            \"sve_cmpeq $pgtmp, $dst, ($idx-#16) # shift from [0, 31] to [-16, 15]\\n\\t\"\n+  format %{ \"sve_index $vtmp, D, -16, 1\\n\\t\"\n+            \"sve_cmpeq $pgtmp, $vtmp, ($idx-#16) # shift from [0, 31] to [-16, 15]\\n\\t\"\n@@ -4921,5 +5005,10 @@\n-    __ sve_index(as_FloatRegister($dst$$reg), __ D, -16, 1);\n-    __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), __ D, ptrue,\n-               as_FloatRegister($dst$$reg), (int)($idx$$constant) - 16);\n-    __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-    __ sve_cpy(as_FloatRegister($dst$$reg), __ D, as_PRegister($pgtmp$$reg), as_Register($val$$reg));\n+    __ block_comment(\"insert into vector (L) {\");\n+      __ sve_index(as_FloatRegister($vtmp$$reg), __ D, -16, 1);\n+      __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), __ D, ptrue,\n+                 as_FloatRegister($vtmp$$reg), (int)($idx$$constant) - 16);\n+      if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n+        __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n+      }\n+      __ sve_cpy(as_FloatRegister($dst$$reg), __ D,\n+                 as_PRegister($pgtmp$$reg), $val$$Register);\n+    __ block_comment(\"} insert into vector (L)\");\n@@ -4930,4 +5019,21 @@\n-instruct insertD(vReg dst, vReg src, vRegD val, immI idx, pRegGov pgtmp, rFlagsReg cr)\n-%{\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n+instruct insertF_le128bits(vReg dst, vReg src, vRegF val, immI idx) %{\n+  predicate(UseSVE > 0 && n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT &&\n+            (Matcher::vector_length_in_bytes(n) == 8 || Matcher::vector_length_in_bytes(n) == 16));\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  ins_cost(2 * INSN_COST);\n+  effect(TEMP_DEF dst);\n+  format %{ \"orr    $dst, T8\/16B, $src, $src\\n\\t\"\n+            \"ins    $dst, S, $val, $idx, 0\\t# insertF into vector(64\/128bits)\" %}\n+  ins_encode %{\n+    __ orr(as_FloatRegister($dst$$reg), Matcher::vector_length_in_bytes(this) == 8 ? __ T8B : __ T16B,\n+           as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n+    __ ins(as_FloatRegister($dst$$reg), __ S,\n+           as_FloatRegister($val$$reg), $idx$$constant, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct insertF_small_index(vReg dst, vReg src, vRegF val, immI idx, pRegGov pgtmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && n->in(2)->get_int() < 32 &&\n+            Matcher::vector_length_in_bytes(n) > 16 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n@@ -4937,1 +5043,1 @@\n-  format %{ \"sve_index $dst, D, -16, 1\\n\\t\"\n+  format %{ \"sve_index $dst, S, -16, 1\\n\\t\"\n@@ -4940,1 +5046,1 @@\n-            \"sve_cpy $dst, $pgtmp, $val\\t# insert into vector (D)\" %}\n+            \"sve_cpy $dst, $pgtmp, $val\\t# insert into vector (F)\" %}\n@@ -4942,5 +5048,7 @@\n-    __ sve_index(as_FloatRegister($dst$$reg), __ D, -16, 1);\n-    __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), __ D, ptrue,\n-               as_FloatRegister($dst$$reg), (int)($idx$$constant) - 16);\n-    __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-    __ sve_cpy(as_FloatRegister($dst$$reg), __ D, as_PRegister($pgtmp$$reg), as_FloatRegister($val$$reg));\n+    __ block_comment(\"insert into vector (F) {\");\n+      __ sve_index(as_FloatRegister($dst$$reg), __ S, -16, 1);\n+      __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), __ S, ptrue,\n+                 as_FloatRegister($dst$$reg), (int)($idx$$constant) - 16);\n+      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n+      __ sve_cpy(as_FloatRegister($dst$$reg), __ S, as_PRegister($pgtmp$$reg), as_FloatRegister($val$$reg));\n+    __ block_comment(\"} insert into vector (F)\");\n@@ -4951,3 +5059,3 @@\n-instruct insertF(vReg dst, vReg src, vRegF val, immI idx, vReg tmp1, pRegGov pgtmp, rFlagsReg cr)\n-%{\n-  predicate(UseSVE > 0 && n->as_Vector()->length() > 32 &&\n+instruct insertF(vReg dst, vReg src, vRegF val, immI idx, vReg tmp1, pRegGov pgtmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && n->in(2)->get_int() >= 32 &&\n+            Matcher::vector_length_in_bytes(n) > 16 &&\n@@ -4964,9 +5072,52 @@\n-    __ sve_index(as_FloatRegister($tmp1$$reg), __ S, 0, 1);\n-    __ sve_dup(as_FloatRegister($dst$$reg), __ S, (int)($idx$$constant));\n-    __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), __ S, ptrue,\n-               as_FloatRegister($tmp1$$reg), as_FloatRegister($dst$$reg));\n-    __ sve_orr(as_FloatRegister($dst$$reg),\n-               as_FloatRegister($src$$reg),\n-               as_FloatRegister($src$$reg));\n-    __ sve_cpy(as_FloatRegister($dst$$reg), __ S,\n-               as_PRegister($pgtmp$$reg), as_FloatRegister($val$$reg));\n+    __ block_comment(\"insert into vector (F) {\");\n+      __ sve_index(as_FloatRegister($tmp1$$reg), __ S, 0, 1);\n+      __ sve_dup(as_FloatRegister($dst$$reg), __ S, (int)($idx$$constant));\n+      __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), __ S, ptrue,\n+                 as_FloatRegister($tmp1$$reg), as_FloatRegister($dst$$reg));\n+      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n+                 as_FloatRegister($src$$reg));\n+      __ sve_cpy(as_FloatRegister($dst$$reg), __ S,\n+                 as_PRegister($pgtmp$$reg), as_FloatRegister($val$$reg));\n+    __ block_comment(\"} insert into vector (F)\");\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct insertD_128bits(vReg dst, vReg src, vRegD val, immI idx) %{\n+  predicate(UseSVE > 0 && Matcher::vector_length_in_bytes(n) == 16 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  ins_cost(2 * INSN_COST);\n+  effect(TEMP_DEF dst);\n+  format %{ \"orr    $dst, T16B, $src, $src\\n\\t\"\n+            \"ins    $dst, D, $val, $idx, 0\\t# insertD into vector(128bits)\" %}\n+  ins_encode %{\n+    __ orr(as_FloatRegister($dst$$reg), __ T16B,\n+           as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n+    __ ins(as_FloatRegister($dst$$reg), __ D,\n+           as_FloatRegister($val$$reg), $idx$$constant, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct insertD(vReg dst, vReg src, vRegD val, immI idx, pRegGov pgtmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 &&\n+            Matcher::vector_length_in_bytes(n) > 16 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  effect(TEMP_DEF dst, TEMP pgtmp, KILL cr);\n+  ins_cost(4 * SVE_COST);\n+  format %{ \"sve_index $dst, D, -16, 1\\n\\t\"\n+            \"sve_cmpeq $pgtmp, $dst, ($idx-#16) # shift from [0, 31] to [-16, 15]\\n\\t\"\n+            \"sve_orr $dst, $src, $src\\n\\t\"\n+            \"sve_cpy $dst, $pgtmp, $val\\t# insert into vector (D)\" %}\n+  ins_encode %{\n+    __ block_comment(\"insert into vector (D) {\");\n+      __ sve_index(as_FloatRegister($dst$$reg), __ D, -16, 1);\n+      __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), __ D, ptrue,\n+                 as_FloatRegister($dst$$reg), (int)($idx$$constant) - 16);\n+      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n+                 as_FloatRegister($src$$reg));\n+      __ sve_cpy(as_FloatRegister($dst$$reg), __ D,\n+                 as_PRegister($pgtmp$$reg), as_FloatRegister($val$$reg));\n+    __ block_comment(\"} insert into vector (D)\");\n@@ -5323,1 +5474,1 @@\n-instruct vmask_tolong(iRegLNoSp dst, pReg src, vReg vtmp1, vReg vtmp2, pRegGov pgtmp, rFlagsReg cr) %{\n+instruct vmask_tolong(iRegLNoSp dst, pReg src, vReg vtmp1, vReg vtmp2) %{\n@@ -5327,1 +5478,1 @@\n-  effect(TEMP vtmp1, TEMP vtmp2, TEMP pgtmp, KILL cr);\n+  effect(TEMP vtmp1, TEMP vtmp2);\n@@ -5334,2 +5485,1 @@\n-                        as_FloatRegister($vtmp1$$reg), as_FloatRegister($vtmp2$$reg),\n-                        as_PRegister($pgtmp$$reg));\n+                        as_FloatRegister($vtmp1$$reg), as_FloatRegister($vtmp2$$reg));\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve.ad","additions":270,"deletions":120,"binary":false,"changes":390,"status":"modified"},{"patch":"@@ -2356,2 +2356,3 @@\n-define(`VECTOR_EXTRACT_SXT', `\n-instruct extract$1`'($2 dst, vReg src, immI idx, pRegGov pgtmp, rFlagsReg cr)\n+dnl\n+define(`VECTOR_EXTRACT_I', `\n+instruct extract$1`'($3 dst, vReg src, immI idx, vReg vtmp)\n@@ -2359,1 +2360,1 @@\n-  predicate(UseSVE > 0);\n+  predicate(UseSVE > 0 && n->in(2)->get_int() >= $2);\n@@ -2361,1 +2362,1 @@\n-  effect(TEMP pgtmp, KILL cr);\n+  effect(TEMP vtmp);\n@@ -2363,2 +2364,1 @@\n-  format %{ \"sve_extract $dst, $3, $pgtmp, $src, $idx\\n\\t\"\n-            \"sbfmw $dst, $dst, 0U, $5\\t# extract from vector($1)\" %}\n+  format %{ \"sve_extract_integral $dst, $4, $src, $idx\\t# extract from vector($1)\" %}\n@@ -2366,3 +2366,2 @@\n-    __ sve_extract(as_$4($dst$$reg), __ $3, as_PRegister($pgtmp$$reg),\n-                   as_FloatRegister($src$$reg), (int)($idx$$constant));\n-    __ sbfmw(as_$4($dst$$reg), as_$4($dst$$reg), 0U, $5);\n+    __ sve_extract_integral(as_Register($dst$$reg), __ $4, as_FloatRegister($src$$reg),\n+                            (int)($idx$$constant), \/* is_signed *\/ ifelse($1, L, false, true), as_FloatRegister($vtmp$$reg));\n@@ -2372,4 +2371,5 @@\n-dnl                $1 $2         $3 $4        $5\n-VECTOR_EXTRACT_SXT(B, iRegINoSp, B, Register, 7U)\n-VECTOR_EXTRACT_SXT(S, iRegINoSp, H, Register, 15U)\n-\n+dnl              $1 $2  $3         $4\n+VECTOR_EXTRACT_I(B, 16, iRegINoSp, B)\n+VECTOR_EXTRACT_I(S, 8,  iRegINoSp, H)\n+VECTOR_EXTRACT_I(I, 4,  iRegINoSp, S)\n+VECTOR_EXTRACT_I(L, 2,  iRegLNoSp, D)\n@@ -2377,2 +2377,2 @@\n-define(`VECTOR_EXTRACT', `\n-instruct extract$1`'($2 dst, vReg src, immI idx, pRegGov pgtmp, rFlagsReg cr)\n+define(`VECTOR_EXTRACT_I_LT', `\n+instruct extract$1_LT$2`'($3 dst, vReg src, immI idx)\n@@ -2380,1 +2380,1 @@\n-  predicate(UseSVE > 0);\n+  predicate(UseSVE > 0 && n->in(2)->get_int() < $2);\n@@ -2382,3 +2382,2 @@\n-  effect(TEMP pgtmp, KILL cr);\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_extract $dst, $3, $pgtmp, $src, $idx\\t# extract from vector($1)\" %}\n+  ins_cost(INSN_COST);\n+  format %{ \"ifelse($4, D, umov, smov) $dst, $4, $src, $idx\\t# extract from vector($1)\" %}\n@@ -2386,2 +2385,1 @@\n-    __ sve_extract(as_$4($dst$$reg), __ $3, as_PRegister($pgtmp$$reg),\n-                   as_FloatRegister($src$$reg), (int)($idx$$constant));\n+    __ ifelse($4, D, umov, smov)(as_Register($dst$$reg), as_FloatRegister($src$$reg), __ $4, $idx$$constant);\n@@ -2389,1 +2387,1 @@\n-  ins_pipe(pipe_slow);\n+  ins_pipe(pipe_class_default);\n@@ -2391,5 +2389,47 @@\n-dnl            $1 $2         $3 $4\n-VECTOR_EXTRACT(I, iRegINoSp, S, Register)\n-VECTOR_EXTRACT(L, iRegLNoSp, D, Register)\n-VECTOR_EXTRACT(F, vRegF,     S, FloatRegister)\n-VECTOR_EXTRACT(D, vRegD,     D, FloatRegister)\n+dnl                 $1  $2  $3         $4\n+VECTOR_EXTRACT_I_LT(B,  16, iRegINoSp, B)\n+VECTOR_EXTRACT_I_LT(S,  8,  iRegINoSp, H)\n+VECTOR_EXTRACT_I_LT(I,  4,  iRegINoSp, S)\n+VECTOR_EXTRACT_I_LT(L,  2,  iRegLNoSp, D)\n+\n+instruct extractF(vRegF dst, vReg src, immI idx)\n+%{\n+  predicate(UseSVE > 0);\n+  match(Set dst (ExtractF src idx));\n+  ins_cost(2 * SVE_COST);\n+  format %{ \"sve_extract_f $dst, S, $src, $idx\\t# extract from vector(F)\" %}\n+  ins_encode %{\n+    if ((as_FloatRegister($dst$$reg) == as_FloatRegister($src$$reg)) && ($idx$$constant == 0)) {\n+      \/* empty *\/\n+    } else if ($idx$$constant == 0) {\n+      __ fmovs(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg));\n+    } else if ($idx$$constant < 4) {\n+      __ ins(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($src$$reg), 0, (int)($idx$$constant));\n+    } else {\n+      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n+      __ sve_ext(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), $idx$$constant << 2);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct extractD(vRegD dst, vReg src, immI idx)\n+%{\n+  predicate(UseSVE > 0);\n+  match(Set dst (ExtractD src idx));\n+  ins_cost(2 * SVE_COST);\n+  format %{ \"sve_extract_d $dst, D, $src, $idx\\t# extract from vector(D)\" %}\n+  ins_encode %{\n+    if ((as_FloatRegister($dst$$reg) == as_FloatRegister($src$$reg)) && ($idx$$constant == 0)) {\n+      \/* empty *\/\n+    } else if ($idx$$constant == 0) {\n+      __ fmovd(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg));\n+    } else if ($idx$$constant == 1) {\n+      __ ins(as_FloatRegister($dst$$reg), __ D, as_FloatRegister($src$$reg), 0, 1);\n+    } else {\n+      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n+      __ sve_ext(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), $idx$$constant << 3);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n@@ -2435,3 +2475,3 @@\n-instruct insertI_small(vReg dst, vReg src, iRegIorL2I val, immI idx, pRegGov pgtmp, rFlagsReg cr)\n-%{\n-  predicate(UseSVE > 0 && n->as_Vector()->length() <= 32 &&\n+instruct insertI_le128bits(vReg dst, vReg src, iRegIorL2I val, immI idx) %{\n+  predicate(UseSVE > 0 &&\n+            (Matcher::vector_length_in_bytes(n) == 8 || Matcher::vector_length_in_bytes(n) == 16) &&\n@@ -2442,6 +2482,3 @@\n-  effect(TEMP_DEF dst, TEMP pgtmp, KILL cr);\n-  ins_cost(4 * SVE_COST);\n-  format %{ \"sve_index $dst, -16, 1\\t# (B\/H\/S)\\n\\t\"\n-            \"sve_cmpeq $pgtmp, $dst, ($idx-#16) # shift from [0, 31] to [-16, 15]\\n\\t\"\n-            \"sve_orr $dst, $src, $src\\n\\t\"\n-            \"sve_cpy $dst, $pgtmp, $val\\t# insert into vector (B\/H\/S)\" %}\n+  ins_cost(2 * INSN_COST);\n+  format %{ \"orr    $dst, T8\/16B, $src, $src\\n\\t\"\n+            \"mov    $dst, B\/H\/S, $idx, $val\\t# insertI into vector(64\/128bits)\" %}\n@@ -2449,7 +2486,7 @@\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ sve_index(as_FloatRegister($dst$$reg), size, -16, 1);\n-    __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), size, ptrue,\n-               as_FloatRegister($dst$$reg), (int)($idx$$constant) - 16);\n-    __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-    __ sve_cpy(as_FloatRegister($dst$$reg), size, as_PRegister($pgtmp$$reg), as_Register($val$$reg));\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n+      __ orr(as_FloatRegister($dst$$reg), Matcher::vector_length_in_bytes(this) == 8 ? __ T8B : __ T16B,\n+             as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n+    }\n+    __ mov(as_FloatRegister($dst$$reg), __ elemType_to_regVariant(Matcher::vector_element_basic_type(this)),\n+           $idx$$constant, $val$$Register);\n@@ -2460,4 +2497,6 @@\n-instruct insertF_small(vReg dst, vReg src, vRegF val, immI idx, pRegGov pgtmp, rFlagsReg cr)\n-%{\n-  predicate(UseSVE > 0 && n->as_Vector()->length() <= 32 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n+instruct insertI_small_index(vReg dst, vReg src, iRegIorL2I val, immI idx, vReg vtmp, pRegGov pgtmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && n->in(2)->get_int() < 32 &&\n+            Matcher::vector_length_in_bytes(n) > 16 &&\n+            (n->bottom_type()->is_vect()->element_basic_type() == T_BYTE ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_INT));\n@@ -2465,1 +2504,1 @@\n-  effect(TEMP_DEF dst, TEMP pgtmp, KILL cr);\n+  effect(TEMP vtmp, TEMP pgtmp, KILL cr);\n@@ -2467,2 +2506,2 @@\n-  format %{ \"sve_index $dst, S, -16, 1\\n\\t\"\n-            \"sve_cmpeq $pgtmp, $dst, ($idx-#16) # shift from [0, 31] to [-16, 15]\\n\\t\"\n+  format %{ \"sve_index $vtmp, -16, 1\\t# (B\/H\/S)\\n\\t\"\n+            \"sve_cmpeq $pgtmp, $vtmp, ($idx-#16) # shift from [0, 31] to [-16, 15]\\n\\t\"\n@@ -2470,1 +2509,1 @@\n-            \"sve_cpy $dst, $pgtmp, $val\\t# insert into vector (F)\" %}\n+            \"sve_cpy $dst, $pgtmp, $val\\t# insert into vector (B\/H\/S)\" %}\n@@ -2472,5 +2511,11 @@\n-    __ sve_index(as_FloatRegister($dst$$reg), __ S, -16, 1);\n-    __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), __ S, ptrue,\n-               as_FloatRegister($dst$$reg), (int)($idx$$constant) - 16);\n-    __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-    __ sve_cpy(as_FloatRegister($dst$$reg), __ S, as_PRegister($pgtmp$$reg), as_FloatRegister($val$$reg));\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ block_comment(\"insert into vector (B\/H\/S) {\");\n+      __ sve_index(as_FloatRegister($vtmp$$reg), size, -16, 1);\n+      __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), size, ptrue,\n+                 as_FloatRegister($vtmp$$reg), (int)($idx$$constant) - 16);\n+      if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n+        __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n+      }\n+      __ sve_cpy(as_FloatRegister($dst$$reg), size, as_PRegister($pgtmp$$reg), $val$$Register);\n+    __ block_comment(\"} insert into vector (B\/H\/S)\");\n@@ -2481,3 +2526,3 @@\n-instruct insertI(vReg dst, vReg src, iRegIorL2I val, immI idx, vReg tmp1, pRegGov pgtmp, rFlagsReg cr)\n-%{\n-  predicate(UseSVE > 0 && n->as_Vector()->length() > 32 &&\n+instruct insertI(vReg dst, vReg src, iRegIorL2I val, immI idx, vReg vtmp1, vReg vtmp2, pRegGov pgtmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && n->in(2)->get_int() >= 32 &&\n+            Matcher::vector_length_in_bytes(n) > 16 &&\n@@ -2488,1 +2533,1 @@\n-  effect(TEMP_DEF dst, TEMP tmp1, TEMP pgtmp, KILL cr);\n+  effect(TEMP vtmp1, TEMP vtmp2, TEMP pgtmp, KILL cr);\n@@ -2490,3 +2535,3 @@\n-  format %{ \"sve_index $tmp1, 0, 1\\t# (B\/H\/S)\\n\\t\"\n-            \"sve_dup $dst, $idx\\t# (B\/H\/S)\\n\\t\"\n-            \"sve_cmpeq $pgtmp, $tmp1, $dst\\n\\t\"\n+  format %{ \"sve_index $vtmp1, 0, 1\\t# (B\/H\/S)\\n\\t\"\n+            \"sve_dup $vtmp2, $idx\\t# (B\/H\/S)\\n\\t\"\n+            \"sve_cmpeq $pgtmp, $vtmp1, $vtmp2\\n\\t\"\n@@ -2498,6 +2543,10 @@\n-    __ sve_index(as_FloatRegister($tmp1$$reg), size, 0, 1);\n-    __ sve_dup(as_FloatRegister($dst$$reg), size, (int)($idx$$constant));\n-    __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), size, ptrue,\n-               as_FloatRegister($tmp1$$reg), as_FloatRegister($dst$$reg));\n-    __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-    __ sve_cpy(as_FloatRegister($dst$$reg), size, as_PRegister($pgtmp$$reg), as_Register($val$$reg));\n+    __ block_comment(\"insert into vector (B\/H\/S) {\");\n+      __ sve_index(as_FloatRegister($vtmp1$$reg), size, 0, 1);\n+      __ sve_dup(as_FloatRegister($vtmp2$$reg), size, (int)($idx$$constant));\n+      __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), size, ptrue,\n+                 as_FloatRegister($vtmp1$$reg), as_FloatRegister($vtmp2$$reg));\n+      if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n+        __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n+      }\n+      __ sve_cpy(as_FloatRegister($dst$$reg), size, as_PRegister($pgtmp$$reg), $val$$Register);\n+    __ block_comment(\"} insert into vector (B\/H\/S)\");\n@@ -2507,5 +2556,20 @@\n-dnl\n-dnl\n-define(`VECTOR_INSERT_D', `\n-instruct insert$1`'(vReg dst, vReg src, $2 val, immI idx, pRegGov pgtmp, rFlagsReg cr)\n-%{\n+\n+instruct insertL_128bits(vReg dst, vReg src, iRegL val, immI idx) %{\n+  predicate(UseSVE > 0 && Matcher::vector_length_in_bytes(n) == 16 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  ins_cost(2 * INSN_COST);\n+  format %{ \"orr    $dst, T16B, $src, $src\\n\\t\"\n+            \"mov    $dst, D, $idx, $val\\t# insertL into vector(128bits)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n+      __ orr(as_FloatRegister($dst$$reg), __ T16B,\n+             as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n+    }\n+    __ mov(as_FloatRegister($dst$$reg), __ D, $idx$$constant, $val$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct insertL(vReg dst, vReg src, iRegL val, immI idx, vReg vtmp, pRegGov pgtmp, rFlagsReg cr) %{\n@@ -2513,1 +2577,45 @@\n-            n->bottom_type()->is_vect()->element_basic_type() == T_`'TYPE2DATATYPE($1));\n+            Matcher::vector_length_in_bytes(n) > 16 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  effect(TEMP vtmp, TEMP pgtmp, KILL cr);\n+  ins_cost(4 * SVE_COST);\n+  format %{ \"sve_index $vtmp, D, -16, 1\\n\\t\"\n+            \"sve_cmpeq $pgtmp, $vtmp, ($idx-#16) # shift from [0, 31] to [-16, 15]\\n\\t\"\n+            \"sve_orr $dst, $src, $src\\n\\t\"\n+            \"sve_cpy $dst, $pgtmp, $val\\t# insert into vector (L)\" %}\n+  ins_encode %{\n+    __ block_comment(\"insert into vector (L) {\");\n+      __ sve_index(as_FloatRegister($vtmp$$reg), __ D, -16, 1);\n+      __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), __ D, ptrue,\n+                 as_FloatRegister($vtmp$$reg), (int)($idx$$constant) - 16);\n+      if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n+        __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n+      }\n+      __ sve_cpy(as_FloatRegister($dst$$reg), __ D,\n+                 as_PRegister($pgtmp$$reg), $val$$Register);\n+    __ block_comment(\"} insert into vector (L)\");\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct insertF_le128bits(vReg dst, vReg src, vRegF val, immI idx) %{\n+  predicate(UseSVE > 0 && n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT &&\n+            (Matcher::vector_length_in_bytes(n) == 8 || Matcher::vector_length_in_bytes(n) == 16));\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  ins_cost(2 * INSN_COST);\n+  effect(TEMP_DEF dst);\n+  format %{ \"orr    $dst, T8\/16B, $src, $src\\n\\t\"\n+            \"ins    $dst, S, $val, $idx, 0\\t# insertF into vector(64\/128bits)\" %}\n+  ins_encode %{\n+    __ orr(as_FloatRegister($dst$$reg), Matcher::vector_length_in_bytes(this) == 8 ? __ T8B : __ T16B,\n+           as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n+    __ ins(as_FloatRegister($dst$$reg), __ S,\n+           as_FloatRegister($val$$reg), $idx$$constant, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct insertF_small_index(vReg dst, vReg src, vRegF val, immI idx, pRegGov pgtmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && n->in(2)->get_int() < 32 &&\n+            Matcher::vector_length_in_bytes(n) > 16 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n@@ -2517,1 +2625,1 @@\n-  format %{ \"sve_index $dst, $3, -16, 1\\n\\t\"\n+  format %{ \"sve_index $dst, S, -16, 1\\n\\t\"\n@@ -2520,1 +2628,1 @@\n-            \"sve_cpy $dst, $pgtmp, $val\\t# insert into vector ($1)\" %}\n+            \"sve_cpy $dst, $pgtmp, $val\\t# insert into vector (F)\" %}\n@@ -2522,5 +2630,7 @@\n-    __ sve_index(as_FloatRegister($dst$$reg), __ $3, -16, 1);\n-    __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), __ $3, ptrue,\n-               as_FloatRegister($dst$$reg), (int)($idx$$constant) - 16);\n-    __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-    __ sve_cpy(as_FloatRegister($dst$$reg), __ $3, as_PRegister($pgtmp$$reg), as_$4($val$$reg));\n+    __ block_comment(\"insert into vector (F) {\");\n+      __ sve_index(as_FloatRegister($dst$$reg), __ S, -16, 1);\n+      __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), __ S, ptrue,\n+                 as_FloatRegister($dst$$reg), (int)($idx$$constant) - 16);\n+      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n+      __ sve_cpy(as_FloatRegister($dst$$reg), __ S, as_PRegister($pgtmp$$reg), as_FloatRegister($val$$reg));\n+    __ block_comment(\"} insert into vector (F)\");\n@@ -2529,4 +2639,1 @@\n-%}')dnl\n-dnl             $1 $2     $3 $4\n-VECTOR_INSERT_D(L, iRegL, D, Register)\n-VECTOR_INSERT_D(D, vRegD, D, FloatRegister)\n+%}\n@@ -2534,3 +2641,3 @@\n-instruct insertF(vReg dst, vReg src, vRegF val, immI idx, vReg tmp1, pRegGov pgtmp, rFlagsReg cr)\n-%{\n-  predicate(UseSVE > 0 && n->as_Vector()->length() > 32 &&\n+instruct insertF(vReg dst, vReg src, vRegF val, immI idx, vReg tmp1, pRegGov pgtmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && n->in(2)->get_int() >= 32 &&\n+            Matcher::vector_length_in_bytes(n) > 16 &&\n@@ -2547,9 +2654,52 @@\n-    __ sve_index(as_FloatRegister($tmp1$$reg), __ S, 0, 1);\n-    __ sve_dup(as_FloatRegister($dst$$reg), __ S, (int)($idx$$constant));\n-    __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), __ S, ptrue,\n-               as_FloatRegister($tmp1$$reg), as_FloatRegister($dst$$reg));\n-    __ sve_orr(as_FloatRegister($dst$$reg),\n-               as_FloatRegister($src$$reg),\n-               as_FloatRegister($src$$reg));\n-    __ sve_cpy(as_FloatRegister($dst$$reg), __ S,\n-               as_PRegister($pgtmp$$reg), as_FloatRegister($val$$reg));\n+    __ block_comment(\"insert into vector (F) {\");\n+      __ sve_index(as_FloatRegister($tmp1$$reg), __ S, 0, 1);\n+      __ sve_dup(as_FloatRegister($dst$$reg), __ S, (int)($idx$$constant));\n+      __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), __ S, ptrue,\n+                 as_FloatRegister($tmp1$$reg), as_FloatRegister($dst$$reg));\n+      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n+                 as_FloatRegister($src$$reg));\n+      __ sve_cpy(as_FloatRegister($dst$$reg), __ S,\n+                 as_PRegister($pgtmp$$reg), as_FloatRegister($val$$reg));\n+    __ block_comment(\"} insert into vector (F)\");\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct insertD_128bits(vReg dst, vReg src, vRegD val, immI idx) %{\n+  predicate(UseSVE > 0 && Matcher::vector_length_in_bytes(n) == 16 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  ins_cost(2 * INSN_COST);\n+  effect(TEMP_DEF dst);\n+  format %{ \"orr    $dst, T16B, $src, $src\\n\\t\"\n+            \"ins    $dst, D, $val, $idx, 0\\t# insertD into vector(128bits)\" %}\n+  ins_encode %{\n+    __ orr(as_FloatRegister($dst$$reg), __ T16B,\n+           as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n+    __ ins(as_FloatRegister($dst$$reg), __ D,\n+           as_FloatRegister($val$$reg), $idx$$constant, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct insertD(vReg dst, vReg src, vRegD val, immI idx, pRegGov pgtmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 &&\n+            Matcher::vector_length_in_bytes(n) > 16 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  effect(TEMP_DEF dst, TEMP pgtmp, KILL cr);\n+  ins_cost(4 * SVE_COST);\n+  format %{ \"sve_index $dst, D, -16, 1\\n\\t\"\n+            \"sve_cmpeq $pgtmp, $dst, ($idx-#16) # shift from [0, 31] to [-16, 15]\\n\\t\"\n+            \"sve_orr $dst, $src, $src\\n\\t\"\n+            \"sve_cpy $dst, $pgtmp, $val\\t# insert into vector (D)\" %}\n+  ins_encode %{\n+    __ block_comment(\"insert into vector (D) {\");\n+      __ sve_index(as_FloatRegister($dst$$reg), __ D, -16, 1);\n+      __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), __ D, ptrue,\n+                 as_FloatRegister($dst$$reg), (int)($idx$$constant) - 16);\n+      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n+                 as_FloatRegister($src$$reg));\n+      __ sve_cpy(as_FloatRegister($dst$$reg), __ D,\n+                 as_PRegister($pgtmp$$reg), as_FloatRegister($val$$reg));\n+    __ block_comment(\"} insert into vector (D)\");\n@@ -2892,1 +3042,1 @@\n-instruct vmask_tolong(iRegLNoSp dst, pReg src, vReg vtmp1, vReg vtmp2, pRegGov pgtmp, rFlagsReg cr) %{\n+instruct vmask_tolong(iRegLNoSp dst, pReg src, vReg vtmp1, vReg vtmp2) %{\n@@ -2896,1 +3046,1 @@\n-  effect(TEMP vtmp1, TEMP vtmp2, TEMP pgtmp, KILL cr);\n+  effect(TEMP vtmp1, TEMP vtmp2);\n@@ -2903,2 +3053,1 @@\n-                        as_FloatRegister($vtmp1$$reg), as_FloatRegister($vtmp2$$reg),\n-                        as_PRegister($pgtmp$$reg));\n+                        as_FloatRegister($vtmp1$$reg), as_FloatRegister($vtmp2$$reg));\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve_ad.m4","additions":251,"deletions":102,"binary":false,"changes":353,"status":"modified"},{"patch":"@@ -3509,0 +3509,7 @@\n+  \/\/ SVE Permute Vector - Extract\n+  void sve_ext(FloatRegister Zdn, FloatRegister Zm, int imm8) {\n+    starti;\n+    f(0b00000101001, 31, 21), f(imm8 >> 3, 20, 16), f(0b000, 15, 13);\n+    f(imm8 & 0b111, 12, 10), rf(Zm, 5), rf(Zdn, 0);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -963,2 +963,1 @@\n-                                         FloatRegister vtmp1, FloatRegister vtmp2, PRegister pgtmp) {\n-  assert(pgtmp->is_governing(), \"This register has to be a governing predicate register.\");\n+                                         FloatRegister vtmp1, FloatRegister vtmp2) {\n@@ -967,0 +966,1 @@\n+  assert_different_registers(vtmp1, vtmp2);\n@@ -984,1 +984,1 @@\n-    idx == 1 ? fmovhid(rscratch1, vtmp1) : sve_extract(rscratch1, D, pgtmp, vtmp1, idx);\n+    sve_extract_integral(rscratch1, D, vtmp1, idx, \/* is_signed *\/ false, vtmp2);\n@@ -1271,0 +1271,15 @@\n+\/\/ Extract a scalar element from an sve vector at position 'idx'.\n+\/\/ The input elements in src are expected to be of integral type.\n+void C2_MacroAssembler::sve_extract_integral(Register dst, SIMD_RegVariant size, FloatRegister src, int idx,\n+                                             bool is_signed, FloatRegister vtmp) {\n+  assert(UseSVE > 0 && size != Q, \"unsupported\");\n+  assert(!(is_signed && size == D), \"signed extract (D) not supported.\");\n+  if (regVariant_to_elemBits(size) * idx < 128) { \/\/ generate lower cost NEON instruction\n+    is_signed ? smov(dst, src, size, idx) : umov(dst, src, size, idx);\n+  } else {\n+    sve_orr(vtmp, src, src);\n+    sve_ext(vtmp, vtmp, idx << size);\n+    is_signed ? smov(dst, vtmp, size, 0) : umov(dst, vtmp, size, 0);\n+  }\n+}\n+\n@@ -1340,1 +1355,0 @@\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":18,"deletions":4,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-                        FloatRegister vtmp1, FloatRegister vtmp2, PRegister pgtmp);\n+                        FloatRegister vtmp1, FloatRegister vtmp2);\n@@ -95,10 +95,3 @@\n-  \/\/ rscratch1 will be clobbered.\n-  \/\/ T could be FloatRegister or Register.\n-  template<class T>\n-  inline void sve_extract(T dst, SIMD_RegVariant size, PRegister pg, FloatRegister src, int idx) {\n-    assert(UseSVE > 0, \"not supported\");\n-    assert(pg->is_governing(), \"This register has to be a governing predicate register\");\n-    mov(rscratch1, idx);\n-    sve_whilele(pg, size, zr, rscratch1);\n-    sve_lastb(dst, size, pg, src);\n-  }\n+  \/\/ The input elements in src are expected to be of integral type.\n+  void sve_extract_integral(Register dst, SIMD_RegVariant size, FloatRegister src, int idx,\n+                            bool is_signed, FloatRegister vtmp);\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.hpp","additions":4,"deletions":11,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1814,0 +1814,1 @@\n+                        [\"ext\",     \"__ sve_ext(z17, z16, 63);\",                          \"ext\\tz17.b, z17.b, z16.b, #63\"],\n","filename":"test\/hotspot\/gtest\/aarch64\/aarch64-asmtest.py","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -958,0 +958,1 @@\n+    __ sve_ext(z17, z16, 63);                          \/\/       ext     z17.b, z17.b, z16.b, #63\n@@ -1214,7 +1215,7 @@\n-    0x14000000,     0x17ffffd7,     0x140003e3,     0x94000000,\n-    0x97ffffd4,     0x940003e0,     0x3400000a,     0x34fffa2a,\n-    0x34007baa,     0x35000008,     0x35fff9c8,     0x35007b48,\n-    0xb400000b,     0xb4fff96b,     0xb4007aeb,     0xb500001d,\n-    0xb5fff91d,     0xb5007a9d,     0x10000013,     0x10fff8b3,\n-    0x10007a33,     0x90000013,     0x36300016,     0x3637f836,\n-    0x363079b6,     0x3758000c,     0x375ff7cc,     0x3758794c,\n+    0x14000000,     0x17ffffd7,     0x140003e4,     0x94000000,\n+    0x97ffffd4,     0x940003e1,     0x3400000a,     0x34fffa2a,\n+    0x34007bca,     0x35000008,     0x35fff9c8,     0x35007b68,\n+    0xb400000b,     0xb4fff96b,     0xb4007b0b,     0xb500001d,\n+    0xb5fff91d,     0xb5007abd,     0x10000013,     0x10fff8b3,\n+    0x10007a53,     0x90000013,     0x36300016,     0x3637f836,\n+    0x363079d6,     0x3758000c,     0x375ff7cc,     0x3758796c,\n@@ -1225,13 +1226,13 @@\n-    0x54007720,     0x54000001,     0x54fff541,     0x540076c1,\n-    0x54000002,     0x54fff4e2,     0x54007662,     0x54000002,\n-    0x54fff482,     0x54007602,     0x54000003,     0x54fff423,\n-    0x540075a3,     0x54000003,     0x54fff3c3,     0x54007543,\n-    0x54000004,     0x54fff364,     0x540074e4,     0x54000005,\n-    0x54fff305,     0x54007485,     0x54000006,     0x54fff2a6,\n-    0x54007426,     0x54000007,     0x54fff247,     0x540073c7,\n-    0x54000008,     0x54fff1e8,     0x54007368,     0x54000009,\n-    0x54fff189,     0x54007309,     0x5400000a,     0x54fff12a,\n-    0x540072aa,     0x5400000b,     0x54fff0cb,     0x5400724b,\n-    0x5400000c,     0x54fff06c,     0x540071ec,     0x5400000d,\n-    0x54fff00d,     0x5400718d,     0x5400000e,     0x54ffefae,\n-    0x5400712e,     0x5400000f,     0x54ffef4f,     0x540070cf,\n+    0x54007740,     0x54000001,     0x54fff541,     0x540076e1,\n+    0x54000002,     0x54fff4e2,     0x54007682,     0x54000002,\n+    0x54fff482,     0x54007622,     0x54000003,     0x54fff423,\n+    0x540075c3,     0x54000003,     0x54fff3c3,     0x54007563,\n+    0x54000004,     0x54fff364,     0x54007504,     0x54000005,\n+    0x54fff305,     0x540074a5,     0x54000006,     0x54fff2a6,\n+    0x54007446,     0x54000007,     0x54fff247,     0x540073e7,\n+    0x54000008,     0x54fff1e8,     0x54007388,     0x54000009,\n+    0x54fff189,     0x54007329,     0x5400000a,     0x54fff12a,\n+    0x540072ca,     0x5400000b,     0x54fff0cb,     0x5400726b,\n+    0x5400000c,     0x54fff06c,     0x5400720c,     0x5400000d,\n+    0x54fff00d,     0x540071ad,     0x5400000e,     0x54ffefae,\n+    0x5400714e,     0x5400000f,     0x54ffef4f,     0x540070ef,\n@@ -1413,51 +1414,51 @@\n-    0x05314001,     0x1e601000,     0x1e603000,     0x1e621000,\n-    0x1e623000,     0x1e641000,     0x1e643000,     0x1e661000,\n-    0x1e663000,     0x1e681000,     0x1e683000,     0x1e6a1000,\n-    0x1e6a3000,     0x1e6c1000,     0x1e6c3000,     0x1e6e1000,\n-    0x1e6e3000,     0x1e701000,     0x1e703000,     0x1e721000,\n-    0x1e723000,     0x1e741000,     0x1e743000,     0x1e761000,\n-    0x1e763000,     0x1e781000,     0x1e783000,     0x1e7a1000,\n-    0x1e7a3000,     0x1e7c1000,     0x1e7c3000,     0x1e7e1000,\n-    0x1e7e3000,     0xf82c815f,     0xf8300047,     0xf823126d,\n-    0xf8312070,     0xf82133cb,     0xf82551e8,     0xf83d401e,\n-    0xf8347287,     0xf83762bc,     0xf8bb80b9,     0xf8a10217,\n-    0xf8bf1185,     0xf8a921fc,     0xf8bd33f6,     0xf8b350bf,\n-    0xf8ae43f0,     0xf8b0729b,     0xf8b0616c,     0xf8e983c6,\n-    0xf8f1039b,     0xf8fe1147,     0xf8f4208a,     0xf8f83231,\n-    0xf8f653a3,     0xf8ef4276,     0xf8f37056,     0xf8ef6186,\n-    0xf87081ab,     0xf87703c1,     0xf8731225,     0xf86222d0,\n-    0xf86d32aa,     0xf87d519b,     0xf87b4023,     0xf87f7278,\n-    0xf8716389,     0xb83b80ef,     0xb83503f7,     0xb83913e2,\n-    0xb83b2150,     0xb8373073,     0xb8305320,     0xb83a4057,\n-    0xb830708c,     0xb83c63be,     0xb8b080db,     0xb8a901fd,\n-    0xb8a710e4,     0xb8af22e9,     0xb8a83382,     0xb8b550bf,\n-    0xb8bb4220,     0xb8af7344,     0xb8a862dc,     0xb8fb833b,\n-    0xb8f70080,     0xb8e61010,     0xb8e4202f,     0xb8ea30a7,\n-    0xb8ea50fc,     0xb8f442b7,     0xb8e6710b,     0xb8f160df,\n-    0xb8718182,     0xb87e007d,     0xb87b13b6,     0xb86e238d,\n-    0xb87130b8,     0xb862514e,     0xb870436b,     0xb877708c,\n-    0xb8766091,     0xce304661,     0xce0c09cc,     0xce748c70,\n-    0xce863cb7,     0xce7b8191,     0xce668610,     0xcec08382,\n-    0xce668883,     0x25a0cdd1,     0x25a1c86c,     0x058000b8,\n-    0x054242ca,     0x0500051e,     0x2520cf00,     0x25e1c951,\n-    0x058039ea,     0x05400e1b,     0x05009891,     0x2520c09c,\n-    0x25a1d448,     0x05801e36,     0x05400516,     0x050039fe,\n-    0x2520ce0b,     0x25a1d0c8,     0x058074d9,     0x05404531,\n-    0x05031e84,     0x2560cf1a,     0x2561dda2,     0x058026a3,\n-    0x05404c35,     0x05007851,     0x25a0d293,     0x25a1de96,\n-    0x05808874,     0x05423bb1,     0x050030e4,     0x04680102,\n-    0x04be0638,     0x658103c4,     0x65800993,     0x65910707,\n-    0x04d6a53b,     0x04c00e17,     0x04da1696,     0x049089bc,\n-    0x045b1787,     0x049aad6b,     0x04991901,     0x0493922d,\n-    0x04518064,     0x04900dc7,     0x0417afa4,     0x04deaaa0,\n-    0x04980123,     0x04080b1c,     0x04ca06f3,     0x04c1154d,\n-    0x04dcb3cc,     0x65c083ae,     0x65cd94f5,     0x65c68342,\n-    0x65c79229,     0x65c28440,     0x04dda56e,     0x6582b3ae,\n-    0x6580a2c3,     0x6581bb63,     0x65cdb4f3,     0x65818cb5,\n-    0x65f186b9,     0x65b30120,     0x65f12dc7,     0x65f1af0b,\n-    0x65eec9f1,     0x65a7fed6,     0x65aa5f65,     0x65b47aae,\n-    0x04c55723,     0x0441723d,     0x042d33ae,     0x04be3051,\n-    0x047d32b6,     0x04e03048,     0x05a06ad7,     0x05776f59,\n-    0x041a3435,     0x0498356a,     0x04d93917,     0x04883671,\n-    0x04ca35a4,     0x65c73fd6,     0x658631d1,     0x65983e8c,\n-    0x04012da1,\n+    0x05314001,     0x05271e11,     0x1e601000,     0x1e603000,\n+    0x1e621000,     0x1e623000,     0x1e641000,     0x1e643000,\n+    0x1e661000,     0x1e663000,     0x1e681000,     0x1e683000,\n+    0x1e6a1000,     0x1e6a3000,     0x1e6c1000,     0x1e6c3000,\n+    0x1e6e1000,     0x1e6e3000,     0x1e701000,     0x1e703000,\n+    0x1e721000,     0x1e723000,     0x1e741000,     0x1e743000,\n+    0x1e761000,     0x1e763000,     0x1e781000,     0x1e783000,\n+    0x1e7a1000,     0x1e7a3000,     0x1e7c1000,     0x1e7c3000,\n+    0x1e7e1000,     0x1e7e3000,     0xf82c815f,     0xf8300047,\n+    0xf823126d,     0xf8312070,     0xf82133cb,     0xf82551e8,\n+    0xf83d401e,     0xf8347287,     0xf83762bc,     0xf8bb80b9,\n+    0xf8a10217,     0xf8bf1185,     0xf8a921fc,     0xf8bd33f6,\n+    0xf8b350bf,     0xf8ae43f0,     0xf8b0729b,     0xf8b0616c,\n+    0xf8e983c6,     0xf8f1039b,     0xf8fe1147,     0xf8f4208a,\n+    0xf8f83231,     0xf8f653a3,     0xf8ef4276,     0xf8f37056,\n+    0xf8ef6186,     0xf87081ab,     0xf87703c1,     0xf8731225,\n+    0xf86222d0,     0xf86d32aa,     0xf87d519b,     0xf87b4023,\n+    0xf87f7278,     0xf8716389,     0xb83b80ef,     0xb83503f7,\n+    0xb83913e2,     0xb83b2150,     0xb8373073,     0xb8305320,\n+    0xb83a4057,     0xb830708c,     0xb83c63be,     0xb8b080db,\n+    0xb8a901fd,     0xb8a710e4,     0xb8af22e9,     0xb8a83382,\n+    0xb8b550bf,     0xb8bb4220,     0xb8af7344,     0xb8a862dc,\n+    0xb8fb833b,     0xb8f70080,     0xb8e61010,     0xb8e4202f,\n+    0xb8ea30a7,     0xb8ea50fc,     0xb8f442b7,     0xb8e6710b,\n+    0xb8f160df,     0xb8718182,     0xb87e007d,     0xb87b13b6,\n+    0xb86e238d,     0xb87130b8,     0xb862514e,     0xb870436b,\n+    0xb877708c,     0xb8766091,     0xce304661,     0xce0c09cc,\n+    0xce748c70,     0xce863cb7,     0xce7b8191,     0xce668610,\n+    0xcec08382,     0xce668883,     0x25a0cdd1,     0x25a1c86c,\n+    0x058000b8,     0x054242ca,     0x0500051e,     0x2520cf00,\n+    0x25e1c951,     0x058039ea,     0x05400e1b,     0x05009891,\n+    0x2520c09c,     0x25a1d448,     0x05801e36,     0x05400516,\n+    0x050039fe,     0x2520ce0b,     0x25a1d0c8,     0x058074d9,\n+    0x05404531,     0x05031e84,     0x2560cf1a,     0x2561dda2,\n+    0x058026a3,     0x05404c35,     0x05007851,     0x25a0d293,\n+    0x25a1de96,     0x05808874,     0x05423bb1,     0x050030e4,\n+    0x04680102,     0x04be0638,     0x658103c4,     0x65800993,\n+    0x65910707,     0x04d6a53b,     0x04c00e17,     0x04da1696,\n+    0x049089bc,     0x045b1787,     0x049aad6b,     0x04991901,\n+    0x0493922d,     0x04518064,     0x04900dc7,     0x0417afa4,\n+    0x04deaaa0,     0x04980123,     0x04080b1c,     0x04ca06f3,\n+    0x04c1154d,     0x04dcb3cc,     0x65c083ae,     0x65cd94f5,\n+    0x65c68342,     0x65c79229,     0x65c28440,     0x04dda56e,\n+    0x6582b3ae,     0x6580a2c3,     0x6581bb63,     0x65cdb4f3,\n+    0x65818cb5,     0x65f186b9,     0x65b30120,     0x65f12dc7,\n+    0x65f1af0b,     0x65eec9f1,     0x65a7fed6,     0x65aa5f65,\n+    0x65b47aae,     0x04c55723,     0x0441723d,     0x042d33ae,\n+    0x04be3051,     0x047d32b6,     0x04e03048,     0x05a06ad7,\n+    0x05776f59,     0x041a3435,     0x0498356a,     0x04d93917,\n+    0x04883671,     0x04ca35a4,     0x65c73fd6,     0x658631d1,\n+    0x65983e8c,     0x04012da1,\n","filename":"test\/hotspot\/gtest\/aarch64\/asmtest.out.h","additions":72,"deletions":71,"binary":false,"changes":143,"status":"modified"}]}