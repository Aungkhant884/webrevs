{"files":[{"patch":"@@ -1700,1 +1700,1 @@\n-instruct insert8B(vecD dst, vecD src, iRegIorL2I val, immI idx)\n+instruct insertID(vecD dst, vecD src, iRegIorL2I val, immI idx)\n@@ -1702,1 +1702,3 @@\n-  predicate(n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n+  predicate((n->bottom_type()->is_vect()->element_basic_type() == T_BYTE ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_INT));\n@@ -1704,69 +1706,1 @@\n-  ins_cost(INSN_COST);\n-  format %{ \"orr    $dst, T8B, $src, $src\\n\\t\"\n-            \"mov    $dst, B, $idx, $val\\t# insert into vector(8B)\" %}\n-  ins_encode %{\n-    if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n-      __ orr(as_FloatRegister($dst$$reg), __ T8B,\n-             as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-    }\n-    __ mov(as_FloatRegister($dst$$reg), __ B, $idx$$constant, $val$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct insert16B(vecX dst, vecX src, iRegIorL2I val, immI idx)\n-%{\n-  predicate(n->bottom_type()->is_vect()->element_basic_type() == T_BYTE);\n-  match(Set dst (VectorInsert (Binary src val) idx));\n-  ins_cost(INSN_COST);\n-  format %{ \"orr    $dst, T16B, $src, $src\\n\\t\"\n-            \"mov    $dst, B, $idx, $val\\t# insert into vector(16B)\" %}\n-  ins_encode %{\n-    if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n-      __ orr(as_FloatRegister($dst$$reg), __ T16B,\n-             as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-    }\n-    __ mov(as_FloatRegister($dst$$reg), __ B, $idx$$constant, $val$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct insert4S(vecD dst, vecD src, iRegIorL2I val, immI idx)\n-%{\n-  predicate(n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (VectorInsert (Binary src val) idx));\n-  ins_cost(INSN_COST);\n-  format %{ \"orr    $dst, T8B, $src, $src\\n\\t\"\n-            \"mov    $dst, H, $idx, $val\\t# insert into vector(4S)\" %}\n-  ins_encode %{\n-    if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n-      __ orr(as_FloatRegister($dst$$reg), __ T8B,\n-             as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-    }\n-    __ mov(as_FloatRegister($dst$$reg), __ H, $idx$$constant, $val$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct insert8S(vecX dst, vecX src, iRegIorL2I val, immI idx)\n-%{\n-  predicate(n->bottom_type()->is_vect()->element_basic_type() == T_SHORT);\n-  match(Set dst (VectorInsert (Binary src val) idx));\n-  ins_cost(INSN_COST);\n-  format %{ \"orr    $dst, T16B, $src, $src\\n\\t\"\n-            \"mov    $dst, H, $idx, $val\\t# insert into vector(8S)\" %}\n-  ins_encode %{\n-    if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n-      __ orr(as_FloatRegister($dst$$reg), __ T16B,\n-             as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-    }\n-    __ mov(as_FloatRegister($dst$$reg), __ H, $idx$$constant, $val$$Register);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct insert2I(vecD dst, vecD src, iRegIorL2I val, immI idx)\n-%{\n-  predicate(n->bottom_type()->is_vect()->element_basic_type() == T_INT);\n-  match(Set dst (VectorInsert (Binary src val) idx));\n-  ins_cost(INSN_COST);\n+  ins_cost(2 * INSN_COST);\n@@ -1774,1 +1708,1 @@\n-            \"mov    $dst, S, $idx, $val\\t# insert into vector(2I)\" %}\n+            \"mov    $dst, B\/H\/S, $idx, $val\\t# insertI into vector(D)\" %}\n@@ -1780,1 +1714,2 @@\n-    __ mov(as_FloatRegister($dst$$reg), __ S, $idx$$constant, $val$$Register);\n+    __ mov(as_FloatRegister($dst$$reg), __ elemType_to_regVariant(Matcher::vector_element_basic_type(this)),\n+           $idx$$constant, $val$$Register);\n@@ -1785,1 +1720,1 @@\n-instruct insert4I(vecX dst, vecX src, iRegIorL2I val, immI idx)\n+instruct insertIX(vecX dst, vecX src, iRegIorL2I val, immI idx)\n@@ -1787,1 +1722,3 @@\n-  predicate(n->bottom_type()->is_vect()->element_basic_type() == T_INT);\n+  predicate((n->bottom_type()->is_vect()->element_basic_type() == T_BYTE ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_INT));\n@@ -1789,1 +1726,1 @@\n-  ins_cost(INSN_COST);\n+  ins_cost(2 * INSN_COST);\n@@ -1791,1 +1728,1 @@\n-            \"mov    $dst, S, $idx, $val\\t# insert into vector(4I)\" %}\n+            \"mov    $dst, B\/H\/S, $idx, $val\\t# insertI into vector(X)\" %}\n@@ -1797,1 +1734,2 @@\n-    __ mov(as_FloatRegister($dst$$reg), __ S, $idx$$constant, $val$$Register);\n+    __ mov(as_FloatRegister($dst$$reg), __ elemType_to_regVariant(Matcher::vector_element_basic_type(this)),\n+           $idx$$constant, $val$$Register);\n@@ -1806,1 +1744,1 @@\n-  ins_cost(INSN_COST);\n+  ins_cost(2 * INSN_COST);\n@@ -1808,1 +1746,1 @@\n-            \"mov    $dst, D, $idx, $val\\t# insert into vector(2L)\" %}\n+            \"mov    $dst, D, $idx, $val\\t# insertL into vector(2L)\" %}\n@@ -1814,1 +1752,2 @@\n-    __ mov(as_FloatRegister($dst$$reg), __ D, $idx$$constant, $val$$Register);\n+    __ mov(as_FloatRegister($dst$$reg), __ D,\n+           $idx$$constant, $val$$Register);\n@@ -1823,1 +1762,1 @@\n-  ins_cost(INSN_COST);\n+  ins_cost(2 * INSN_COST);\n@@ -1840,1 +1779,1 @@\n-  ins_cost(INSN_COST);\n+  ins_cost(2 * INSN_COST);\n@@ -1857,1 +1796,1 @@\n-  ins_cost(INSN_COST);\n+  ins_cost(2 * INSN_COST);\n@@ -1963,2 +1902,9 @@\n-    __ ins(as_FloatRegister($dst$$reg), __ S,\n-           as_FloatRegister($src$$reg), 0, $idx$$constant);\n+    if ((0 == $idx$$constant) &&\n+        (as_FloatRegister($dst$$reg) == as_FloatRegister($src$$reg))) {\n+      \/* empty *\/\n+    } else if ($idx$$constant == 0) {\n+      __ fmovs(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg));\n+    } else {\n+      __ ins(as_FloatRegister($dst$$reg), __ S,\n+             as_FloatRegister($src$$reg), 0, $idx$$constant);\n+    }\n@@ -1976,2 +1922,9 @@\n-    __ ins(as_FloatRegister($dst$$reg), __ S,\n-           as_FloatRegister($src$$reg), 0, $idx$$constant);\n+    if ((0 == $idx$$constant) &&\n+        (as_FloatRegister($dst$$reg) == as_FloatRegister($src$$reg))) {\n+      \/* empty *\/\n+    } else if ($idx$$constant == 0) {\n+      __ fmovs(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg));\n+    } else {\n+      __ ins(as_FloatRegister($dst$$reg), __ S,\n+             as_FloatRegister($src$$reg), 0, $idx$$constant);\n+    }\n@@ -1989,2 +1942,9 @@\n-    __ ins(as_FloatRegister($dst$$reg), __ D,\n-           as_FloatRegister($src$$reg), 0, $idx$$constant);\n+    if ((0 == $idx$$constant) &&\n+        (as_FloatRegister($dst$$reg) == as_FloatRegister($src$$reg))) {\n+      \/* empty *\/\n+    } else if ($idx$$constant == 0) {\n+      __ fmovd(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg));\n+    } else {\n+      __ ins(as_FloatRegister($dst$$reg), __ D,\n+             as_FloatRegister($src$$reg), 0, $idx$$constant);\n+    }\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_neon.ad","additions":50,"deletions":90,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -865,1 +865,1 @@\n-instruct insert$1$2`'(vec$3 dst, vec$3 src, iReg$4`'ORL2I($4) val, immI idx)\n+instruct insert`'ifelse($2, I, $2$3, $3)(ifelse($1, 8, vecD, vecX) dst, ifelse($1, 8, vecD, vecX) src, ifelse($2, I, iRegIorL2I, iRegL) val, immI idx)\n@@ -867,1 +867,4 @@\n-  predicate(n->bottom_type()->is_vect()->element_basic_type() == T_`'TYPE2DATATYPE($2));\n+  predicate(ifelse($2, L, n->bottom_type()->is_vect()->element_basic_type() == T_LONG,\n+            (n->bottom_type()->is_vect()->element_basic_type() == T_BYTE ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_INT)));\n@@ -869,3 +872,3 @@\n-  ins_cost(INSN_COST);\n-  format %{ \"orr    $dst, T$5, $src, $src\\n\\t\"\n-            \"mov    $dst, iTYPE2SIMD($2), $idx, $val\\t# insert into vector($1$2)\" %}\n+  ins_cost(2 * INSN_COST);\n+  format %{ \"orr    $dst, T$1B, $src, $src\\n\\t\"\n+            \"mov    $dst, ifelse($2, I, B\/H\/S, D), $idx, $val\\t# insert$2 into vector($3)\" %}\n@@ -874,1 +877,1 @@\n-      __ orr(as_FloatRegister($dst$$reg), __ T$5,\n+      __ orr(as_FloatRegister($dst$$reg), __ T$1B,\n@@ -877,1 +880,2 @@\n-    __ mov(as_FloatRegister($dst$$reg), __ iTYPE2SIMD($2), $idx$$constant, $val$$Register);\n+    __ mov(as_FloatRegister($dst$$reg), __ ifelse($2, I, elemType_to_regVariant(Matcher::vector_element_basic_type(this)), D),\n+           $idx$$constant, $val$$Register);\n@@ -881,8 +885,4 @@\n-dnl             $1  $2 $3 $4 $5\n-VECTOR_INSERT_I(8,  B, D, I, 8B)\n-VECTOR_INSERT_I(16, B, X, I, 16B)\n-VECTOR_INSERT_I(4,  S, D, I, 8B)\n-VECTOR_INSERT_I(8,  S, X, I, 16B)\n-VECTOR_INSERT_I(2,  I, D, I, 8B)\n-VECTOR_INSERT_I(4,  I, X, I, 16B)\n-VECTOR_INSERT_I(2,  L, X, L, 16B)\n+dnl             $1  $2 $3\n+VECTOR_INSERT_I(8,  I, D)\n+VECTOR_INSERT_I(16, I, X)\n+VECTOR_INSERT_I(16, L, 2L)\n@@ -891,1 +891,1 @@\n-instruct insert$1`'(vec$2 dst, vec$2 src, vReg$3 val, immI idx)\n+instruct insert$3`'(vec$2 dst, vec$2 src, vReg$1 val, immI idx)\n@@ -893,1 +893,1 @@\n-  predicate(n->bottom_type()->is_vect()->element_basic_type() == T_`'TYPE2DATATYPE($3));\n+  predicate(n->bottom_type()->is_vect()->element_basic_type() == T_`'TYPE2DATATYPE($1));\n@@ -895,1 +895,1 @@\n-  ins_cost(INSN_COST);\n+  ins_cost(2 * INSN_COST);\n@@ -897,2 +897,2 @@\n-  format %{ \"orr    $dst, T$4, $src, $src\\n\\t\"\n-            \"ins    $dst, $5, $val, $idx, 0\\t# insert into vector($1)\" %}\n+  format %{ \"orr    $dst, ifelse($2, D, T8B, T16B), $src, $src\\n\\t\"\n+            \"ins    $dst, ifelse($1, F, S, D), $val, $idx, 0\\t# insert into vector($3)\" %}\n@@ -900,1 +900,1 @@\n-    __ orr(as_FloatRegister($dst$$reg), __ T$4,\n+    __ orr(as_FloatRegister($dst$$reg), __ ifelse($2, D, T8B, T16B),\n@@ -902,1 +902,1 @@\n-    __ ins(as_FloatRegister($dst$$reg), __ $5,\n+    __ ins(as_FloatRegister($dst$$reg), __ ifelse($1, F, S, D),\n@@ -907,4 +907,4 @@\n-dnl             $1  $2 $3 $4   $5\n-VECTOR_INSERT_F(2F, D, F, 8B,  S)\n-VECTOR_INSERT_F(4F, X, F, 16B, S)\n-VECTOR_INSERT_F(2D, X, D, 16B, D)\n+dnl             $1 $2 $3\n+VECTOR_INSERT_F(F, D, 2F)\n+VECTOR_INSERT_F(F, X, 4F)\n+VECTOR_INSERT_F(D, X, 2D)\n@@ -943,2 +943,9 @@\n-    __ ins(as_FloatRegister($dst$$reg), __ $4,\n-           as_FloatRegister($src$$reg), 0, $idx$$constant);\n+    if ((0 == $idx$$constant) &&\n+        (as_FloatRegister($dst$$reg) == as_FloatRegister($src$$reg))) {\n+      \/* empty *\/\n+    } else if ($idx$$constant == 0) {\n+      __ ifelse($2, F, fmovs, fmovd)(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg));\n+    } else {\n+      __ ins(as_FloatRegister($dst$$reg), __ $4,\n+             as_FloatRegister($src$$reg), 0, $idx$$constant);\n+    }\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_neon_ad.m4","additions":35,"deletions":28,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -4938,1 +4938,1 @@\n-instruct extractB(iRegINoSp dst, vReg src, immI idx, pRegGov pgtmp, rFlagsReg cr)\n+instruct extractB(iRegINoSp dst, vReg src, immI idx, vReg vtmp)\n@@ -4940,1 +4940,1 @@\n-  predicate(UseSVE > 0);\n+  predicate(UseSVE > 0 && n->in(2)->get_int() >= 16);\n@@ -4942,1 +4942,1 @@\n-  effect(TEMP pgtmp, KILL cr);\n+  effect(TEMP vtmp);\n@@ -4944,2 +4944,1 @@\n-  format %{ \"sve_extract $dst, B, $pgtmp, $src, $idx\\n\\t\"\n-            \"sbfmw $dst, $dst, 0U, 7U\\t# extract from vector(B)\" %}\n+  format %{ \"sve_extract_integral $dst, B, $src, $idx\\t# extract from vector(B)\" %}\n@@ -4947,3 +4946,2 @@\n-    __ sve_extract(as_Register($dst$$reg), __ B, as_PRegister($pgtmp$$reg),\n-                   as_FloatRegister($src$$reg), (int)($idx$$constant));\n-    __ sbfmw(as_Register($dst$$reg), as_Register($dst$$reg), 0U, 7U);\n+    __ sve_extract_integral(as_Register($dst$$reg), __ B, as_FloatRegister($src$$reg),\n+                            (int)($idx$$constant), \/* is_signed *\/ true, as_FloatRegister($vtmp$$reg));\n@@ -4954,1 +4952,1 @@\n-instruct extractS(iRegINoSp dst, vReg src, immI idx, pRegGov pgtmp, rFlagsReg cr)\n+instruct extractS(iRegINoSp dst, vReg src, immI idx, vReg vtmp)\n@@ -4956,1 +4954,1 @@\n-  predicate(UseSVE > 0);\n+  predicate(UseSVE > 0 && n->in(2)->get_int() >= 8);\n@@ -4958,1 +4956,1 @@\n-  effect(TEMP pgtmp, KILL cr);\n+  effect(TEMP vtmp);\n@@ -4960,2 +4958,1 @@\n-  format %{ \"sve_extract $dst, H, $pgtmp, $src, $idx\\n\\t\"\n-            \"sbfmw $dst, $dst, 0U, 15U\\t# extract from vector(S)\" %}\n+  format %{ \"sve_extract_integral $dst, H, $src, $idx\\t# extract from vector(S)\" %}\n@@ -4963,3 +4960,2 @@\n-    __ sve_extract(as_Register($dst$$reg), __ H, as_PRegister($pgtmp$$reg),\n-                   as_FloatRegister($src$$reg), (int)($idx$$constant));\n-    __ sbfmw(as_Register($dst$$reg), as_Register($dst$$reg), 0U, 15U);\n+    __ sve_extract_integral(as_Register($dst$$reg), __ H, as_FloatRegister($src$$reg),\n+                            (int)($idx$$constant), \/* is_signed *\/ true, as_FloatRegister($vtmp$$reg));\n@@ -4970,2 +4966,1 @@\n-\n-instruct extractI(iRegINoSp dst, vReg src, immI idx, pRegGov pgtmp, rFlagsReg cr)\n+instruct extractI(iRegINoSp dst, vReg src, immI idx, vReg vtmp)\n@@ -4973,1 +4968,1 @@\n-  predicate(UseSVE > 0);\n+  predicate(UseSVE > 0 && n->in(2)->get_int() >= 4);\n@@ -4975,1 +4970,1 @@\n-  effect(TEMP pgtmp, KILL cr);\n+  effect(TEMP vtmp);\n@@ -4977,1 +4972,1 @@\n-  format %{ \"sve_extract $dst, S, $pgtmp, $src, $idx\\t# extract from vector(I)\" %}\n+  format %{ \"sve_extract_integral $dst, S, $src, $idx\\t# extract from vector(I)\" %}\n@@ -4979,2 +4974,2 @@\n-    __ sve_extract(as_Register($dst$$reg), __ S, as_PRegister($pgtmp$$reg),\n-                   as_FloatRegister($src$$reg), (int)($idx$$constant));\n+    __ sve_extract_integral(as_Register($dst$$reg), __ S, as_FloatRegister($src$$reg),\n+                            (int)($idx$$constant), \/* is_signed *\/ true, as_FloatRegister($vtmp$$reg));\n@@ -4985,1 +4980,1 @@\n-instruct extractL(iRegLNoSp dst, vReg src, immI idx, pRegGov pgtmp, rFlagsReg cr)\n+instruct extractL(iRegLNoSp dst, vReg src, immI idx, vReg vtmp)\n@@ -4987,1 +4982,1 @@\n-  predicate(UseSVE > 0);\n+  predicate(UseSVE > 0 && n->in(2)->get_int() >= 2);\n@@ -4989,1 +4984,1 @@\n-  effect(TEMP pgtmp, KILL cr);\n+  effect(TEMP vtmp);\n@@ -4991,1 +4986,1 @@\n-  format %{ \"sve_extract $dst, D, $pgtmp, $src, $idx\\t# extract from vector(L)\" %}\n+  format %{ \"sve_extract_integral $dst, D, $src, $idx\\t# extract from vector(L)\" %}\n@@ -4993,2 +4988,2 @@\n-    __ sve_extract(as_Register($dst$$reg), __ D, as_PRegister($pgtmp$$reg),\n-                   as_FloatRegister($src$$reg), (int)($idx$$constant));\n+    __ sve_extract_integral(as_Register($dst$$reg), __ D, as_FloatRegister($src$$reg),\n+                            (int)($idx$$constant), \/* is_signed *\/ false, as_FloatRegister($vtmp$$reg));\n@@ -4999,1 +4994,49 @@\n-instruct extractF(vRegF dst, vReg src, immI idx, pRegGov pgtmp, rFlagsReg cr)\n+instruct extractB_LT16(iRegINoSp dst, vReg src, immI idx)\n+%{\n+  predicate(UseSVE > 0 && n->in(2)->get_int() < 16);\n+  match(Set dst (ExtractB src idx));\n+  ins_cost(INSN_COST);\n+  format %{ \"smov $dst, B, $src, $idx\\t# extract from vector(B)\" %}\n+  ins_encode %{\n+    __ smov(as_Register($dst$$reg), as_FloatRegister($src$$reg), __ B, $idx$$constant);\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct extractS_LT8(iRegINoSp dst, vReg src, immI idx)\n+%{\n+  predicate(UseSVE > 0 && n->in(2)->get_int() < 8);\n+  match(Set dst (ExtractS src idx));\n+  ins_cost(INSN_COST);\n+  format %{ \"smov $dst, H, $src, $idx\\t# extract from vector(S)\" %}\n+  ins_encode %{\n+    __ smov(as_Register($dst$$reg), as_FloatRegister($src$$reg), __ H, $idx$$constant);\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct extractI_LT4(iRegINoSp dst, vReg src, immI idx)\n+%{\n+  predicate(UseSVE > 0 && n->in(2)->get_int() < 4);\n+  match(Set dst (ExtractI src idx));\n+  ins_cost(INSN_COST);\n+  format %{ \"smov $dst, S, $src, $idx\\t# extract from vector(I)\" %}\n+  ins_encode %{\n+    __ smov(as_Register($dst$$reg), as_FloatRegister($src$$reg), __ S, $idx$$constant);\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct extractL_LT2(iRegLNoSp dst, vReg src, immI idx)\n+%{\n+  predicate(UseSVE > 0 && n->in(2)->get_int() < 2);\n+  match(Set dst (ExtractL src idx));\n+  ins_cost(INSN_COST);\n+  format %{ \"umov $dst, D, $src, $idx\\t# extract from vector(L)\" %}\n+  ins_encode %{\n+    __ umov(as_Register($dst$$reg), as_FloatRegister($src$$reg), __ D, $idx$$constant);\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct extractF(vRegF dst, vReg src, immI idx)\n@@ -5003,1 +5046,0 @@\n-  effect(TEMP pgtmp, KILL cr);\n@@ -5005,4 +5047,12 @@\n-  format %{ \"sve_extract $dst, S, $pgtmp, $src, $idx\\t# extract from vector(F)\" %}\n-  ins_encode %{\n-    __ sve_extract(as_FloatRegister($dst$$reg), __ S, as_PRegister($pgtmp$$reg),\n-                   as_FloatRegister($src$$reg), (int)($idx$$constant));\n+  format %{ \"sve_extract_f $dst, S, $src, $idx\\t# extract from vector(F)\" %}\n+  ins_encode %{\n+    if ((as_FloatRegister($dst$$reg) == as_FloatRegister($src$$reg)) && ($idx$$constant == 0)) {\n+      \/* empty *\/\n+    } else if ($idx$$constant == 0) {\n+      __ fmovs(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg));\n+    } else if ($idx$$constant < 4) {\n+      __ ins(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($src$$reg), 0, (int)($idx$$constant));\n+    } else {\n+      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n+      __ sve_ext(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), $idx$$constant << 2);\n+    }\n@@ -5013,1 +5063,1 @@\n-instruct extractD(vRegD dst, vReg src, immI idx, pRegGov pgtmp, rFlagsReg cr)\n+instruct extractD(vRegD dst, vReg src, immI idx)\n@@ -5017,1 +5067,0 @@\n-  effect(TEMP pgtmp, KILL cr);\n@@ -5019,4 +5068,12 @@\n-  format %{ \"sve_extract $dst, D, $pgtmp, $src, $idx\\t# extract from vector(D)\" %}\n-  ins_encode %{\n-    __ sve_extract(as_FloatRegister($dst$$reg), __ D, as_PRegister($pgtmp$$reg),\n-                   as_FloatRegister($src$$reg), (int)($idx$$constant));\n+  format %{ \"sve_extract_d $dst, D, $src, $idx\\t# extract from vector(D)\" %}\n+  ins_encode %{\n+    if ((as_FloatRegister($dst$$reg) == as_FloatRegister($src$$reg)) && ($idx$$constant == 0)) {\n+      \/* empty *\/\n+    } else if ($idx$$constant == 0) {\n+      __ fmovd(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg));\n+    } else if ($idx$$constant == 1) {\n+      __ ins(as_FloatRegister($dst$$reg), __ D, as_FloatRegister($src$$reg), 0, 1);\n+    } else {\n+      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n+      __ sve_ext(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), $idx$$constant << 3);\n+    }\n@@ -5109,3 +5166,3 @@\n-instruct insertI_small(vReg dst, vReg src, iRegIorL2I val, immI idx, pRegGov pgtmp, rFlagsReg cr)\n-%{\n-  predicate(UseSVE > 0 && n->as_Vector()->length() <= 32 &&\n+instruct insertI_le128bits(vReg dst, vReg src, iRegIorL2I val, immI idx) %{\n+  predicate(UseSVE > 0 &&\n+            (Matcher::vector_length_in_bytes(n) == 8 || Matcher::vector_length_in_bytes(n) == 16) &&\n@@ -5116,6 +5173,3 @@\n-  effect(TEMP_DEF dst, TEMP pgtmp, KILL cr);\n-  ins_cost(4 * SVE_COST);\n-  format %{ \"sve_index $dst, -16, 1\\t# (B\/H\/S)\\n\\t\"\n-            \"sve_cmpeq $pgtmp, $dst, ($idx-#16) # shift from [0, 31] to [-16, 15]\\n\\t\"\n-            \"sve_orr $dst, $src, $src\\n\\t\"\n-            \"sve_cpy $dst, $pgtmp, $val\\t# insert into vector (B\/H\/S)\" %}\n+  ins_cost(2 * INSN_COST);\n+  format %{ \"orr    $dst, T8\/16B, $src, $src\\n\\t\"\n+            \"mov    $dst, B\/H\/S, $idx, $val\\t# insertI into vector(64\/128bits)\" %}\n@@ -5123,7 +5177,7 @@\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ sve_index(as_FloatRegister($dst$$reg), size, -16, 1);\n-    __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), size, ptrue,\n-               as_FloatRegister($dst$$reg), (int)($idx$$constant) - 16);\n-    __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-    __ sve_cpy(as_FloatRegister($dst$$reg), size, as_PRegister($pgtmp$$reg), as_Register($val$$reg));\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n+      __ orr(as_FloatRegister($dst$$reg), Matcher::vector_length_in_bytes(this) == 8 ? __ T8B : __ T16B,\n+             as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n+    }\n+    __ mov(as_FloatRegister($dst$$reg), __ elemType_to_regVariant(Matcher::vector_element_basic_type(this)),\n+           $idx$$constant, $val$$Register);\n@@ -5134,4 +5188,6 @@\n-instruct insertF_small(vReg dst, vReg src, vRegF val, immI idx, pRegGov pgtmp, rFlagsReg cr)\n-%{\n-  predicate(UseSVE > 0 && n->as_Vector()->length() <= 32 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n+instruct insertI_small_index(vReg dst, vReg src, iRegIorL2I val, immI idx, vReg vtmp, pRegGov pgtmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && n->in(2)->get_int() < 32 &&\n+            Matcher::vector_length_in_bytes(n) > 16 &&\n+            (n->bottom_type()->is_vect()->element_basic_type() == T_BYTE ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_INT));\n@@ -5139,1 +5195,1 @@\n-  effect(TEMP_DEF dst, TEMP pgtmp, KILL cr);\n+  effect(TEMP vtmp, TEMP pgtmp, KILL cr);\n@@ -5141,2 +5197,2 @@\n-  format %{ \"sve_index $dst, S, -16, 1\\n\\t\"\n-            \"sve_cmpeq $pgtmp, $dst, ($idx-#16) # shift from [0, 31] to [-16, 15]\\n\\t\"\n+  format %{ \"sve_index $vtmp, -16, 1\\t# (B\/H\/S)\\n\\t\"\n+            \"sve_cmpeq $pgtmp, $vtmp, ($idx-#16) # shift from [0, 31] to [-16, 15]\\n\\t\"\n@@ -5144,1 +5200,1 @@\n-            \"sve_cpy $dst, $pgtmp, $val\\t# insert into vector (F)\" %}\n+            \"sve_cpy $dst, $pgtmp, $val\\t# insert into vector (B\/H\/S)\" %}\n@@ -5146,5 +5202,11 @@\n-    __ sve_index(as_FloatRegister($dst$$reg), __ S, -16, 1);\n-    __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), __ S, ptrue,\n-               as_FloatRegister($dst$$reg), (int)($idx$$constant) - 16);\n-    __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-    __ sve_cpy(as_FloatRegister($dst$$reg), __ S, as_PRegister($pgtmp$$reg), as_FloatRegister($val$$reg));\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ block_comment(\"insert into vector (B\/H\/S) {\");\n+      __ sve_index(as_FloatRegister($vtmp$$reg), size, -16, 1);\n+      __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), size, ptrue,\n+                 as_FloatRegister($vtmp$$reg), (int)($idx$$constant) - 16);\n+      if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n+        __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n+      }\n+      __ sve_cpy(as_FloatRegister($dst$$reg), size, as_PRegister($pgtmp$$reg), $val$$Register);\n+    __ block_comment(\"} insert into vector (B\/H\/S)\");\n@@ -5155,3 +5217,3 @@\n-instruct insertI(vReg dst, vReg src, iRegIorL2I val, immI idx, vReg tmp1, pRegGov pgtmp, rFlagsReg cr)\n-%{\n-  predicate(UseSVE > 0 && n->as_Vector()->length() > 32 &&\n+instruct insertI(vReg dst, vReg src, iRegIorL2I val, immI idx, vReg vtmp1, vReg vtmp2, pRegGov pgtmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && n->in(2)->get_int() >= 32 &&\n+            Matcher::vector_length_in_bytes(n) > 16 &&\n@@ -5162,1 +5224,1 @@\n-  effect(TEMP_DEF dst, TEMP tmp1, TEMP pgtmp, KILL cr);\n+  effect(TEMP vtmp1, TEMP vtmp2, TEMP pgtmp, KILL cr);\n@@ -5164,3 +5226,3 @@\n-  format %{ \"sve_index $tmp1, 0, 1\\t# (B\/H\/S)\\n\\t\"\n-            \"sve_dup $dst, $idx\\t# (B\/H\/S)\\n\\t\"\n-            \"sve_cmpeq $pgtmp, $tmp1, $dst\\n\\t\"\n+  format %{ \"sve_index $vtmp1, 0, 1\\t# (B\/H\/S)\\n\\t\"\n+            \"sve_dup $vtmp2, $idx\\t# (B\/H\/S)\\n\\t\"\n+            \"sve_cmpeq $pgtmp, $vtmp1, $vtmp2\\n\\t\"\n@@ -5172,6 +5234,10 @@\n-    __ sve_index(as_FloatRegister($tmp1$$reg), size, 0, 1);\n-    __ sve_dup(as_FloatRegister($dst$$reg), size, (int)($idx$$constant));\n-    __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), size, ptrue,\n-               as_FloatRegister($tmp1$$reg), as_FloatRegister($dst$$reg));\n-    __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-    __ sve_cpy(as_FloatRegister($dst$$reg), size, as_PRegister($pgtmp$$reg), as_Register($val$$reg));\n+    __ block_comment(\"insert into vector (B\/H\/S) {\");\n+      __ sve_index(as_FloatRegister($vtmp1$$reg), size, 0, 1);\n+      __ sve_dup(as_FloatRegister($vtmp2$$reg), size, (int)($idx$$constant));\n+      __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), size, ptrue,\n+                 as_FloatRegister($vtmp1$$reg), as_FloatRegister($vtmp2$$reg));\n+      if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n+        __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n+      }\n+      __ sve_cpy(as_FloatRegister($dst$$reg), size, as_PRegister($pgtmp$$reg), $val$$Register);\n+    __ block_comment(\"} insert into vector (B\/H\/S)\");\n@@ -5182,2 +5248,19 @@\n-instruct insertL(vReg dst, vReg src, iRegL val, immI idx, pRegGov pgtmp, rFlagsReg cr)\n-%{\n+instruct insertL_128bits(vReg dst, vReg src, iRegL val, immI idx) %{\n+  predicate(UseSVE > 0 && Matcher::vector_length_in_bytes(n) == 16 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  ins_cost(2 * INSN_COST);\n+  format %{ \"orr    $dst, T16B, $src, $src\\n\\t\"\n+            \"mov    $dst, D, $idx, $val\\t# insertL into vector(128bits)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n+      __ orr(as_FloatRegister($dst$$reg), __ T16B,\n+             as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n+    }\n+    __ mov(as_FloatRegister($dst$$reg), __ D, $idx$$constant, $val$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct insertL(vReg dst, vReg src, iRegL val, immI idx, vReg vtmp, pRegGov pgtmp, rFlagsReg cr) %{\n@@ -5185,0 +5268,1 @@\n+            Matcher::vector_length_in_bytes(n) > 16 &&\n@@ -5187,1 +5271,1 @@\n-  effect(TEMP_DEF dst, TEMP pgtmp, KILL cr);\n+  effect(TEMP vtmp, TEMP pgtmp, KILL cr);\n@@ -5189,2 +5273,2 @@\n-  format %{ \"sve_index $dst, D, -16, 1\\n\\t\"\n-            \"sve_cmpeq $pgtmp, $dst, ($idx-#16) # shift from [0, 31] to [-16, 15]\\n\\t\"\n+  format %{ \"sve_index $vtmp, D, -16, 1\\n\\t\"\n+            \"sve_cmpeq $pgtmp, $vtmp, ($idx-#16) # shift from [0, 31] to [-16, 15]\\n\\t\"\n@@ -5194,5 +5278,10 @@\n-    __ sve_index(as_FloatRegister($dst$$reg), __ D, -16, 1);\n-    __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), __ D, ptrue,\n-               as_FloatRegister($dst$$reg), (int)($idx$$constant) - 16);\n-    __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-    __ sve_cpy(as_FloatRegister($dst$$reg), __ D, as_PRegister($pgtmp$$reg), as_Register($val$$reg));\n+    __ block_comment(\"insert into vector (L) {\");\n+      __ sve_index(as_FloatRegister($vtmp$$reg), __ D, -16, 1);\n+      __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), __ D, ptrue,\n+                 as_FloatRegister($vtmp$$reg), (int)($idx$$constant) - 16);\n+      if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n+        __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n+      }\n+      __ sve_cpy(as_FloatRegister($dst$$reg), __ D,\n+                 as_PRegister($pgtmp$$reg), $val$$Register);\n+    __ block_comment(\"} insert into vector (L)\");\n@@ -5203,4 +5292,21 @@\n-instruct insertD(vReg dst, vReg src, vRegD val, immI idx, pRegGov pgtmp, rFlagsReg cr)\n-%{\n-  predicate(UseSVE > 0 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n+instruct insertF_le128bits(vReg dst, vReg src, vRegF val, immI idx) %{\n+  predicate(UseSVE > 0 && n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT &&\n+            (Matcher::vector_length_in_bytes(n) == 8 || Matcher::vector_length_in_bytes(n) == 16));\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  ins_cost(2 * INSN_COST);\n+  effect(TEMP_DEF dst);\n+  format %{ \"orr    $dst, T8\/16B, $src, $src\\n\\t\"\n+            \"ins    $dst, S, $val, $idx, 0\\t# insertF into vector(64\/128bits)\" %}\n+  ins_encode %{\n+    __ orr(as_FloatRegister($dst$$reg), Matcher::vector_length_in_bytes(this) == 8 ? __ T8B : __ T16B,\n+           as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n+    __ ins(as_FloatRegister($dst$$reg), __ S,\n+           as_FloatRegister($val$$reg), $idx$$constant, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct insertF_small_index(vReg dst, vReg src, vRegF val, immI idx, pRegGov pgtmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && n->in(2)->get_int() < 32 &&\n+            Matcher::vector_length_in_bytes(n) > 16 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n@@ -5210,1 +5316,1 @@\n-  format %{ \"sve_index $dst, D, -16, 1\\n\\t\"\n+  format %{ \"sve_index $dst, S, -16, 1\\n\\t\"\n@@ -5213,1 +5319,1 @@\n-            \"sve_cpy $dst, $pgtmp, $val\\t# insert into vector (D)\" %}\n+            \"sve_cpy $dst, $pgtmp, $val\\t# insert into vector (F)\" %}\n@@ -5215,5 +5321,7 @@\n-    __ sve_index(as_FloatRegister($dst$$reg), __ D, -16, 1);\n-    __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), __ D, ptrue,\n-               as_FloatRegister($dst$$reg), (int)($idx$$constant) - 16);\n-    __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-    __ sve_cpy(as_FloatRegister($dst$$reg), __ D, as_PRegister($pgtmp$$reg), as_FloatRegister($val$$reg));\n+    __ block_comment(\"insert into vector (F) {\");\n+      __ sve_index(as_FloatRegister($dst$$reg), __ S, -16, 1);\n+      __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), __ S, ptrue,\n+                 as_FloatRegister($dst$$reg), (int)($idx$$constant) - 16);\n+      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n+      __ sve_cpy(as_FloatRegister($dst$$reg), __ S, as_PRegister($pgtmp$$reg), as_FloatRegister($val$$reg));\n+    __ block_comment(\"} insert into vector (F)\");\n@@ -5224,3 +5332,3 @@\n-instruct insertF(vReg dst, vReg src, vRegF val, immI idx, vReg tmp1, pRegGov pgtmp, rFlagsReg cr)\n-%{\n-  predicate(UseSVE > 0 && n->as_Vector()->length() > 32 &&\n+instruct insertF(vReg dst, vReg src, vRegF val, immI idx, vReg tmp1, pRegGov pgtmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && n->in(2)->get_int() >= 32 &&\n+            Matcher::vector_length_in_bytes(n) > 16 &&\n@@ -5237,9 +5345,52 @@\n-    __ sve_index(as_FloatRegister($tmp1$$reg), __ S, 0, 1);\n-    __ sve_dup(as_FloatRegister($dst$$reg), __ S, (int)($idx$$constant));\n-    __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), __ S, ptrue,\n-               as_FloatRegister($tmp1$$reg), as_FloatRegister($dst$$reg));\n-    __ sve_orr(as_FloatRegister($dst$$reg),\n-               as_FloatRegister($src$$reg),\n-               as_FloatRegister($src$$reg));\n-    __ sve_cpy(as_FloatRegister($dst$$reg), __ S,\n-               as_PRegister($pgtmp$$reg), as_FloatRegister($val$$reg));\n+    __ block_comment(\"insert into vector (F) {\");\n+      __ sve_index(as_FloatRegister($tmp1$$reg), __ S, 0, 1);\n+      __ sve_dup(as_FloatRegister($dst$$reg), __ S, (int)($idx$$constant));\n+      __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), __ S, ptrue,\n+                 as_FloatRegister($tmp1$$reg), as_FloatRegister($dst$$reg));\n+      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n+                 as_FloatRegister($src$$reg));\n+      __ sve_cpy(as_FloatRegister($dst$$reg), __ S,\n+                 as_PRegister($pgtmp$$reg), as_FloatRegister($val$$reg));\n+    __ block_comment(\"} insert into vector (F)\");\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct insertD_128bits(vReg dst, vReg src, vRegD val, immI idx) %{\n+  predicate(UseSVE > 0 && Matcher::vector_length_in_bytes(n) == 16 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  ins_cost(2 * INSN_COST);\n+  effect(TEMP_DEF dst);\n+  format %{ \"orr    $dst, T16B, $src, $src\\n\\t\"\n+            \"ins    $dst, D, $val, $idx, 0\\t# insertD into vector(128bits)\" %}\n+  ins_encode %{\n+    __ orr(as_FloatRegister($dst$$reg), __ T16B,\n+           as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n+    __ ins(as_FloatRegister($dst$$reg), __ D,\n+           as_FloatRegister($val$$reg), $idx$$constant, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct insertD(vReg dst, vReg src, vRegD val, immI idx, pRegGov pgtmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 &&\n+            Matcher::vector_length_in_bytes(n) > 16 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  effect(TEMP_DEF dst, TEMP pgtmp, KILL cr);\n+  ins_cost(4 * SVE_COST);\n+  format %{ \"sve_index $dst, D, -16, 1\\n\\t\"\n+            \"sve_cmpeq $pgtmp, $dst, ($idx-#16) # shift from [0, 31] to [-16, 15]\\n\\t\"\n+            \"sve_orr $dst, $src, $src\\n\\t\"\n+            \"sve_cpy $dst, $pgtmp, $val\\t# insert into vector (D)\" %}\n+  ins_encode %{\n+    __ block_comment(\"insert into vector (D) {\");\n+      __ sve_index(as_FloatRegister($dst$$reg), __ D, -16, 1);\n+      __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), __ D, ptrue,\n+                 as_FloatRegister($dst$$reg), (int)($idx$$constant) - 16);\n+      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n+                 as_FloatRegister($src$$reg));\n+      __ sve_cpy(as_FloatRegister($dst$$reg), __ D,\n+                 as_PRegister($pgtmp$$reg), as_FloatRegister($val$$reg));\n+    __ block_comment(\"} insert into vector (D)\");\n@@ -5732,1 +5883,1 @@\n-instruct vmask_tolong(iRegLNoSp dst, pReg src, vReg vtmp1, vReg vtmp2, pRegGov pgtmp, rFlagsReg cr) %{\n+instruct vmask_tolong(iRegLNoSp dst, pReg src, vReg vtmp1, vReg vtmp2) %{\n@@ -5736,1 +5887,1 @@\n-  effect(TEMP vtmp1, TEMP vtmp2, TEMP pgtmp, KILL cr);\n+  effect(TEMP vtmp1, TEMP vtmp2);\n@@ -5743,2 +5894,1 @@\n-                        as_FloatRegister($vtmp1$$reg), as_FloatRegister($vtmp2$$reg),\n-                        as_PRegister($pgtmp$$reg));\n+                        as_FloatRegister($vtmp1$$reg), as_FloatRegister($vtmp2$$reg));\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve.ad","additions":270,"deletions":120,"binary":false,"changes":390,"status":"modified"},{"patch":"@@ -2503,2 +2503,3 @@\n-define(`VECTOR_EXTRACT_SXT', `\n-instruct extract$1`'($2 dst, vReg src, immI idx, pRegGov pgtmp, rFlagsReg cr)\n+dnl\n+define(`VECTOR_EXTRACT_I', `\n+instruct extract$1`'($3 dst, vReg src, immI idx, vReg vtmp)\n@@ -2506,1 +2507,1 @@\n-  predicate(UseSVE > 0);\n+  predicate(UseSVE > 0 && n->in(2)->get_int() >= $2);\n@@ -2508,1 +2509,1 @@\n-  effect(TEMP pgtmp, KILL cr);\n+  effect(TEMP vtmp);\n@@ -2510,2 +2511,1 @@\n-  format %{ \"sve_extract $dst, $3, $pgtmp, $src, $idx\\n\\t\"\n-            \"sbfmw $dst, $dst, 0U, $5\\t# extract from vector($1)\" %}\n+  format %{ \"sve_extract_integral $dst, $4, $src, $idx\\t# extract from vector($1)\" %}\n@@ -2513,3 +2513,2 @@\n-    __ sve_extract(as_$4($dst$$reg), __ $3, as_PRegister($pgtmp$$reg),\n-                   as_FloatRegister($src$$reg), (int)($idx$$constant));\n-    __ sbfmw(as_$4($dst$$reg), as_$4($dst$$reg), 0U, $5);\n+    __ sve_extract_integral(as_Register($dst$$reg), __ $4, as_FloatRegister($src$$reg),\n+                            (int)($idx$$constant), \/* is_signed *\/ ifelse($1, L, false, true), as_FloatRegister($vtmp$$reg));\n@@ -2519,4 +2518,5 @@\n-dnl                $1 $2         $3 $4        $5\n-VECTOR_EXTRACT_SXT(B, iRegINoSp, B, Register, 7U)\n-VECTOR_EXTRACT_SXT(S, iRegINoSp, H, Register, 15U)\n-\n+dnl              $1 $2  $3         $4\n+VECTOR_EXTRACT_I(B, 16, iRegINoSp, B)\n+VECTOR_EXTRACT_I(S, 8,  iRegINoSp, H)\n+VECTOR_EXTRACT_I(I, 4,  iRegINoSp, S)\n+VECTOR_EXTRACT_I(L, 2,  iRegLNoSp, D)\n@@ -2524,2 +2524,2 @@\n-define(`VECTOR_EXTRACT', `\n-instruct extract$1`'($2 dst, vReg src, immI idx, pRegGov pgtmp, rFlagsReg cr)\n+define(`VECTOR_EXTRACT_I_LT', `\n+instruct extract$1_LT$2`'($3 dst, vReg src, immI idx)\n@@ -2527,1 +2527,1 @@\n-  predicate(UseSVE > 0);\n+  predicate(UseSVE > 0 && n->in(2)->get_int() < $2);\n@@ -2529,3 +2529,2 @@\n-  effect(TEMP pgtmp, KILL cr);\n-  ins_cost(2 * SVE_COST);\n-  format %{ \"sve_extract $dst, $3, $pgtmp, $src, $idx\\t# extract from vector($1)\" %}\n+  ins_cost(INSN_COST);\n+  format %{ \"ifelse($4, D, umov, smov) $dst, $4, $src, $idx\\t# extract from vector($1)\" %}\n@@ -2533,2 +2532,1 @@\n-    __ sve_extract(as_$4($dst$$reg), __ $3, as_PRegister($pgtmp$$reg),\n-                   as_FloatRegister($src$$reg), (int)($idx$$constant));\n+    __ ifelse($4, D, umov, smov)(as_Register($dst$$reg), as_FloatRegister($src$$reg), __ $4, $idx$$constant);\n@@ -2536,1 +2534,1 @@\n-  ins_pipe(pipe_slow);\n+  ins_pipe(pipe_class_default);\n@@ -2538,5 +2536,47 @@\n-dnl            $1 $2         $3 $4\n-VECTOR_EXTRACT(I, iRegINoSp, S, Register)\n-VECTOR_EXTRACT(L, iRegLNoSp, D, Register)\n-VECTOR_EXTRACT(F, vRegF,     S, FloatRegister)\n-VECTOR_EXTRACT(D, vRegD,     D, FloatRegister)\n+dnl                 $1  $2  $3         $4\n+VECTOR_EXTRACT_I_LT(B,  16, iRegINoSp, B)\n+VECTOR_EXTRACT_I_LT(S,  8,  iRegINoSp, H)\n+VECTOR_EXTRACT_I_LT(I,  4,  iRegINoSp, S)\n+VECTOR_EXTRACT_I_LT(L,  2,  iRegLNoSp, D)\n+\n+instruct extractF(vRegF dst, vReg src, immI idx)\n+%{\n+  predicate(UseSVE > 0);\n+  match(Set dst (ExtractF src idx));\n+  ins_cost(2 * SVE_COST);\n+  format %{ \"sve_extract_f $dst, S, $src, $idx\\t# extract from vector(F)\" %}\n+  ins_encode %{\n+    if ((as_FloatRegister($dst$$reg) == as_FloatRegister($src$$reg)) && ($idx$$constant == 0)) {\n+      \/* empty *\/\n+    } else if ($idx$$constant == 0) {\n+      __ fmovs(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg));\n+    } else if ($idx$$constant < 4) {\n+      __ ins(as_FloatRegister($dst$$reg), __ S, as_FloatRegister($src$$reg), 0, (int)($idx$$constant));\n+    } else {\n+      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n+      __ sve_ext(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), $idx$$constant << 2);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct extractD(vRegD dst, vReg src, immI idx)\n+%{\n+  predicate(UseSVE > 0);\n+  match(Set dst (ExtractD src idx));\n+  ins_cost(2 * SVE_COST);\n+  format %{ \"sve_extract_d $dst, D, $src, $idx\\t# extract from vector(D)\" %}\n+  ins_encode %{\n+    if ((as_FloatRegister($dst$$reg) == as_FloatRegister($src$$reg)) && ($idx$$constant == 0)) {\n+      \/* empty *\/\n+    } else if ($idx$$constant == 0) {\n+      __ fmovd(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg));\n+    } else if ($idx$$constant == 1) {\n+      __ ins(as_FloatRegister($dst$$reg), __ D, as_FloatRegister($src$$reg), 0, 1);\n+    } else {\n+      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n+      __ sve_ext(as_FloatRegister($dst$$reg), as_FloatRegister($dst$$reg), $idx$$constant << 3);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n@@ -2612,3 +2652,3 @@\n-instruct insertI_small(vReg dst, vReg src, iRegIorL2I val, immI idx, pRegGov pgtmp, rFlagsReg cr)\n-%{\n-  predicate(UseSVE > 0 && n->as_Vector()->length() <= 32 &&\n+instruct insertI_le128bits(vReg dst, vReg src, iRegIorL2I val, immI idx) %{\n+  predicate(UseSVE > 0 &&\n+            (Matcher::vector_length_in_bytes(n) == 8 || Matcher::vector_length_in_bytes(n) == 16) &&\n@@ -2619,6 +2659,3 @@\n-  effect(TEMP_DEF dst, TEMP pgtmp, KILL cr);\n-  ins_cost(4 * SVE_COST);\n-  format %{ \"sve_index $dst, -16, 1\\t# (B\/H\/S)\\n\\t\"\n-            \"sve_cmpeq $pgtmp, $dst, ($idx-#16) # shift from [0, 31] to [-16, 15]\\n\\t\"\n-            \"sve_orr $dst, $src, $src\\n\\t\"\n-            \"sve_cpy $dst, $pgtmp, $val\\t# insert into vector (B\/H\/S)\" %}\n+  ins_cost(2 * INSN_COST);\n+  format %{ \"orr    $dst, T8\/16B, $src, $src\\n\\t\"\n+            \"mov    $dst, B\/H\/S, $idx, $val\\t# insertI into vector(64\/128bits)\" %}\n@@ -2626,7 +2663,7 @@\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n-    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n-    __ sve_index(as_FloatRegister($dst$$reg), size, -16, 1);\n-    __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), size, ptrue,\n-               as_FloatRegister($dst$$reg), (int)($idx$$constant) - 16);\n-    __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-    __ sve_cpy(as_FloatRegister($dst$$reg), size, as_PRegister($pgtmp$$reg), as_Register($val$$reg));\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n+      __ orr(as_FloatRegister($dst$$reg), Matcher::vector_length_in_bytes(this) == 8 ? __ T8B : __ T16B,\n+             as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n+    }\n+    __ mov(as_FloatRegister($dst$$reg), __ elemType_to_regVariant(Matcher::vector_element_basic_type(this)),\n+           $idx$$constant, $val$$Register);\n@@ -2637,4 +2674,6 @@\n-instruct insertF_small(vReg dst, vReg src, vRegF val, immI idx, pRegGov pgtmp, rFlagsReg cr)\n-%{\n-  predicate(UseSVE > 0 && n->as_Vector()->length() <= 32 &&\n-            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n+instruct insertI_small_index(vReg dst, vReg src, iRegIorL2I val, immI idx, vReg vtmp, pRegGov pgtmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && n->in(2)->get_int() < 32 &&\n+            Matcher::vector_length_in_bytes(n) > 16 &&\n+            (n->bottom_type()->is_vect()->element_basic_type() == T_BYTE ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_SHORT ||\n+             n->bottom_type()->is_vect()->element_basic_type() == T_INT));\n@@ -2642,1 +2681,1 @@\n-  effect(TEMP_DEF dst, TEMP pgtmp, KILL cr);\n+  effect(TEMP vtmp, TEMP pgtmp, KILL cr);\n@@ -2644,2 +2683,2 @@\n-  format %{ \"sve_index $dst, S, -16, 1\\n\\t\"\n-            \"sve_cmpeq $pgtmp, $dst, ($idx-#16) # shift from [0, 31] to [-16, 15]\\n\\t\"\n+  format %{ \"sve_index $vtmp, -16, 1\\t# (B\/H\/S)\\n\\t\"\n+            \"sve_cmpeq $pgtmp, $vtmp, ($idx-#16) # shift from [0, 31] to [-16, 15]\\n\\t\"\n@@ -2647,1 +2686,1 @@\n-            \"sve_cpy $dst, $pgtmp, $val\\t# insert into vector (F)\" %}\n+            \"sve_cpy $dst, $pgtmp, $val\\t# insert into vector (B\/H\/S)\" %}\n@@ -2649,5 +2688,11 @@\n-    __ sve_index(as_FloatRegister($dst$$reg), __ S, -16, 1);\n-    __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), __ S, ptrue,\n-               as_FloatRegister($dst$$reg), (int)($idx$$constant) - 16);\n-    __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-    __ sve_cpy(as_FloatRegister($dst$$reg), __ S, as_PRegister($pgtmp$$reg), as_FloatRegister($val$$reg));\n+    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n+    Assembler::SIMD_RegVariant size = __ elemType_to_regVariant(bt);\n+    __ block_comment(\"insert into vector (B\/H\/S) {\");\n+      __ sve_index(as_FloatRegister($vtmp$$reg), size, -16, 1);\n+      __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), size, ptrue,\n+                 as_FloatRegister($vtmp$$reg), (int)($idx$$constant) - 16);\n+      if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n+        __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n+      }\n+      __ sve_cpy(as_FloatRegister($dst$$reg), size, as_PRegister($pgtmp$$reg), $val$$Register);\n+    __ block_comment(\"} insert into vector (B\/H\/S)\");\n@@ -2658,3 +2703,3 @@\n-instruct insertI(vReg dst, vReg src, iRegIorL2I val, immI idx, vReg tmp1, pRegGov pgtmp, rFlagsReg cr)\n-%{\n-  predicate(UseSVE > 0 && n->as_Vector()->length() > 32 &&\n+instruct insertI(vReg dst, vReg src, iRegIorL2I val, immI idx, vReg vtmp1, vReg vtmp2, pRegGov pgtmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && n->in(2)->get_int() >= 32 &&\n+            Matcher::vector_length_in_bytes(n) > 16 &&\n@@ -2665,1 +2710,1 @@\n-  effect(TEMP_DEF dst, TEMP tmp1, TEMP pgtmp, KILL cr);\n+  effect(TEMP vtmp1, TEMP vtmp2, TEMP pgtmp, KILL cr);\n@@ -2667,3 +2712,3 @@\n-  format %{ \"sve_index $tmp1, 0, 1\\t# (B\/H\/S)\\n\\t\"\n-            \"sve_dup $dst, $idx\\t# (B\/H\/S)\\n\\t\"\n-            \"sve_cmpeq $pgtmp, $tmp1, $dst\\n\\t\"\n+  format %{ \"sve_index $vtmp1, 0, 1\\t# (B\/H\/S)\\n\\t\"\n+            \"sve_dup $vtmp2, $idx\\t# (B\/H\/S)\\n\\t\"\n+            \"sve_cmpeq $pgtmp, $vtmp1, $vtmp2\\n\\t\"\n@@ -2675,6 +2720,10 @@\n-    __ sve_index(as_FloatRegister($tmp1$$reg), size, 0, 1);\n-    __ sve_dup(as_FloatRegister($dst$$reg), size, (int)($idx$$constant));\n-    __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), size, ptrue,\n-               as_FloatRegister($tmp1$$reg), as_FloatRegister($dst$$reg));\n-    __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-    __ sve_cpy(as_FloatRegister($dst$$reg), size, as_PRegister($pgtmp$$reg), as_Register($val$$reg));\n+    __ block_comment(\"insert into vector (B\/H\/S) {\");\n+      __ sve_index(as_FloatRegister($vtmp1$$reg), size, 0, 1);\n+      __ sve_dup(as_FloatRegister($vtmp2$$reg), size, (int)($idx$$constant));\n+      __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), size, ptrue,\n+                 as_FloatRegister($vtmp1$$reg), as_FloatRegister($vtmp2$$reg));\n+      if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n+        __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n+      }\n+      __ sve_cpy(as_FloatRegister($dst$$reg), size, as_PRegister($pgtmp$$reg), $val$$Register);\n+    __ block_comment(\"} insert into vector (B\/H\/S)\");\n@@ -2684,5 +2733,20 @@\n-dnl\n-dnl\n-define(`VECTOR_INSERT_D', `\n-instruct insert$1`'(vReg dst, vReg src, $2 val, immI idx, pRegGov pgtmp, rFlagsReg cr)\n-%{\n+\n+instruct insertL_128bits(vReg dst, vReg src, iRegL val, immI idx) %{\n+  predicate(UseSVE > 0 && Matcher::vector_length_in_bytes(n) == 16 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  ins_cost(2 * INSN_COST);\n+  format %{ \"orr    $dst, T16B, $src, $src\\n\\t\"\n+            \"mov    $dst, D, $idx, $val\\t# insertL into vector(128bits)\" %}\n+  ins_encode %{\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n+    if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n+      __ orr(as_FloatRegister($dst$$reg), __ T16B,\n+             as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n+    }\n+    __ mov(as_FloatRegister($dst$$reg), __ D, $idx$$constant, $val$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct insertL(vReg dst, vReg src, iRegL val, immI idx, vReg vtmp, pRegGov pgtmp, rFlagsReg cr) %{\n@@ -2690,1 +2754,45 @@\n-            n->bottom_type()->is_vect()->element_basic_type() == T_`'TYPE2DATATYPE($1));\n+            Matcher::vector_length_in_bytes(n) > 16 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_LONG);\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  effect(TEMP vtmp, TEMP pgtmp, KILL cr);\n+  ins_cost(4 * SVE_COST);\n+  format %{ \"sve_index $vtmp, D, -16, 1\\n\\t\"\n+            \"sve_cmpeq $pgtmp, $vtmp, ($idx-#16) # shift from [0, 31] to [-16, 15]\\n\\t\"\n+            \"sve_orr $dst, $src, $src\\n\\t\"\n+            \"sve_cpy $dst, $pgtmp, $val\\t# insert into vector (L)\" %}\n+  ins_encode %{\n+    __ block_comment(\"insert into vector (L) {\");\n+      __ sve_index(as_FloatRegister($vtmp$$reg), __ D, -16, 1);\n+      __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), __ D, ptrue,\n+                 as_FloatRegister($vtmp$$reg), (int)($idx$$constant) - 16);\n+      if (as_FloatRegister($dst$$reg) != as_FloatRegister($src$$reg)) {\n+        __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n+      }\n+      __ sve_cpy(as_FloatRegister($dst$$reg), __ D,\n+                 as_PRegister($pgtmp$$reg), $val$$Register);\n+    __ block_comment(\"} insert into vector (L)\");\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct insertF_le128bits(vReg dst, vReg src, vRegF val, immI idx) %{\n+  predicate(UseSVE > 0 && n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT &&\n+            (Matcher::vector_length_in_bytes(n) == 8 || Matcher::vector_length_in_bytes(n) == 16));\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  ins_cost(2 * INSN_COST);\n+  effect(TEMP_DEF dst);\n+  format %{ \"orr    $dst, T8\/16B, $src, $src\\n\\t\"\n+            \"ins    $dst, S, $val, $idx, 0\\t# insertF into vector(64\/128bits)\" %}\n+  ins_encode %{\n+    __ orr(as_FloatRegister($dst$$reg), Matcher::vector_length_in_bytes(this) == 8 ? __ T8B : __ T16B,\n+           as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n+    __ ins(as_FloatRegister($dst$$reg), __ S,\n+           as_FloatRegister($val$$reg), $idx$$constant, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct insertF_small_index(vReg dst, vReg src, vRegF val, immI idx, pRegGov pgtmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && n->in(2)->get_int() < 32 &&\n+            Matcher::vector_length_in_bytes(n) > 16 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_FLOAT);\n@@ -2694,1 +2802,1 @@\n-  format %{ \"sve_index $dst, $3, -16, 1\\n\\t\"\n+  format %{ \"sve_index $dst, S, -16, 1\\n\\t\"\n@@ -2697,1 +2805,1 @@\n-            \"sve_cpy $dst, $pgtmp, $val\\t# insert into vector ($1)\" %}\n+            \"sve_cpy $dst, $pgtmp, $val\\t# insert into vector (F)\" %}\n@@ -2699,5 +2807,7 @@\n-    __ sve_index(as_FloatRegister($dst$$reg), __ $3, -16, 1);\n-    __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), __ $3, ptrue,\n-               as_FloatRegister($dst$$reg), (int)($idx$$constant) - 16);\n-    __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n-    __ sve_cpy(as_FloatRegister($dst$$reg), __ $3, as_PRegister($pgtmp$$reg), as_$4($val$$reg));\n+    __ block_comment(\"insert into vector (F) {\");\n+      __ sve_index(as_FloatRegister($dst$$reg), __ S, -16, 1);\n+      __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), __ S, ptrue,\n+                 as_FloatRegister($dst$$reg), (int)($idx$$constant) - 16);\n+      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n+      __ sve_cpy(as_FloatRegister($dst$$reg), __ S, as_PRegister($pgtmp$$reg), as_FloatRegister($val$$reg));\n+    __ block_comment(\"} insert into vector (F)\");\n@@ -2706,4 +2816,1 @@\n-%}')dnl\n-dnl             $1 $2     $3 $4\n-VECTOR_INSERT_D(L, iRegL, D, Register)\n-VECTOR_INSERT_D(D, vRegD, D, FloatRegister)\n+%}\n@@ -2711,3 +2818,3 @@\n-instruct insertF(vReg dst, vReg src, vRegF val, immI idx, vReg tmp1, pRegGov pgtmp, rFlagsReg cr)\n-%{\n-  predicate(UseSVE > 0 && n->as_Vector()->length() > 32 &&\n+instruct insertF(vReg dst, vReg src, vRegF val, immI idx, vReg tmp1, pRegGov pgtmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 && n->in(2)->get_int() >= 32 &&\n+            Matcher::vector_length_in_bytes(n) > 16 &&\n@@ -2724,9 +2831,52 @@\n-    __ sve_index(as_FloatRegister($tmp1$$reg), __ S, 0, 1);\n-    __ sve_dup(as_FloatRegister($dst$$reg), __ S, (int)($idx$$constant));\n-    __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), __ S, ptrue,\n-               as_FloatRegister($tmp1$$reg), as_FloatRegister($dst$$reg));\n-    __ sve_orr(as_FloatRegister($dst$$reg),\n-               as_FloatRegister($src$$reg),\n-               as_FloatRegister($src$$reg));\n-    __ sve_cpy(as_FloatRegister($dst$$reg), __ S,\n-               as_PRegister($pgtmp$$reg), as_FloatRegister($val$$reg));\n+    __ block_comment(\"insert into vector (F) {\");\n+      __ sve_index(as_FloatRegister($tmp1$$reg), __ S, 0, 1);\n+      __ sve_dup(as_FloatRegister($dst$$reg), __ S, (int)($idx$$constant));\n+      __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), __ S, ptrue,\n+                 as_FloatRegister($tmp1$$reg), as_FloatRegister($dst$$reg));\n+      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n+                 as_FloatRegister($src$$reg));\n+      __ sve_cpy(as_FloatRegister($dst$$reg), __ S,\n+                 as_PRegister($pgtmp$$reg), as_FloatRegister($val$$reg));\n+    __ block_comment(\"} insert into vector (F)\");\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct insertD_128bits(vReg dst, vReg src, vRegD val, immI idx) %{\n+  predicate(UseSVE > 0 && Matcher::vector_length_in_bytes(n) == 16 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  ins_cost(2 * INSN_COST);\n+  effect(TEMP_DEF dst);\n+  format %{ \"orr    $dst, T16B, $src, $src\\n\\t\"\n+            \"ins    $dst, D, $val, $idx, 0\\t# insertD into vector(128bits)\" %}\n+  ins_encode %{\n+    __ orr(as_FloatRegister($dst$$reg), __ T16B,\n+           as_FloatRegister($src$$reg), as_FloatRegister($src$$reg));\n+    __ ins(as_FloatRegister($dst$$reg), __ D,\n+           as_FloatRegister($val$$reg), $idx$$constant, 0);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct insertD(vReg dst, vReg src, vRegD val, immI idx, pRegGov pgtmp, rFlagsReg cr) %{\n+  predicate(UseSVE > 0 &&\n+            Matcher::vector_length_in_bytes(n) > 16 &&\n+            n->bottom_type()->is_vect()->element_basic_type() == T_DOUBLE);\n+  match(Set dst (VectorInsert (Binary src val) idx));\n+  effect(TEMP_DEF dst, TEMP pgtmp, KILL cr);\n+  ins_cost(4 * SVE_COST);\n+  format %{ \"sve_index $dst, D, -16, 1\\n\\t\"\n+            \"sve_cmpeq $pgtmp, $dst, ($idx-#16) # shift from [0, 31] to [-16, 15]\\n\\t\"\n+            \"sve_orr $dst, $src, $src\\n\\t\"\n+            \"sve_cpy $dst, $pgtmp, $val\\t# insert into vector (D)\" %}\n+  ins_encode %{\n+    __ block_comment(\"insert into vector (D) {\");\n+      __ sve_index(as_FloatRegister($dst$$reg), __ D, -16, 1);\n+      __ sve_cmp(Assembler::EQ, as_PRegister($pgtmp$$reg), __ D, ptrue,\n+                 as_FloatRegister($dst$$reg), (int)($idx$$constant) - 16);\n+      __ sve_orr(as_FloatRegister($dst$$reg), as_FloatRegister($src$$reg),\n+                 as_FloatRegister($src$$reg));\n+      __ sve_cpy(as_FloatRegister($dst$$reg), __ D,\n+                 as_PRegister($pgtmp$$reg), as_FloatRegister($val$$reg));\n+    __ block_comment(\"} insert into vector (D)\");\n@@ -3205,1 +3355,1 @@\n-instruct vmask_tolong(iRegLNoSp dst, pReg src, vReg vtmp1, vReg vtmp2, pRegGov pgtmp, rFlagsReg cr) %{\n+instruct vmask_tolong(iRegLNoSp dst, pReg src, vReg vtmp1, vReg vtmp2) %{\n@@ -3209,1 +3359,1 @@\n-  effect(TEMP vtmp1, TEMP vtmp2, TEMP pgtmp, KILL cr);\n+  effect(TEMP vtmp1, TEMP vtmp2);\n@@ -3216,2 +3366,1 @@\n-                        as_FloatRegister($vtmp1$$reg), as_FloatRegister($vtmp2$$reg),\n-                        as_PRegister($pgtmp$$reg));\n+                        as_FloatRegister($vtmp1$$reg), as_FloatRegister($vtmp2$$reg));\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve_ad.m4","additions":251,"deletions":102,"binary":false,"changes":353,"status":"modified"},{"patch":"@@ -3476,0 +3476,7 @@\n+  \/\/ SVE Permute Vector - Extract\n+  void sve_ext(FloatRegister Zdn, FloatRegister Zm, int imm8) {\n+    starti;\n+    f(0b00000101001, 31, 21), f(imm8 >> 3, 20, 16), f(0b000, 15, 13);\n+    f(imm8 & 0b111, 12, 10), rf(Zm, 5), rf(Zdn, 0);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -963,2 +963,1 @@\n-                                         FloatRegister vtmp1, FloatRegister vtmp2, PRegister pgtmp) {\n-  assert(pgtmp->is_governing(), \"This register has to be a governing predicate register.\");\n+                                         FloatRegister vtmp1, FloatRegister vtmp2) {\n@@ -967,0 +966,1 @@\n+  assert_different_registers(vtmp1, vtmp2);\n@@ -984,1 +984,1 @@\n-    idx == 1 ? fmovhid(rscratch1, vtmp1) : sve_extract(rscratch1, D, pgtmp, vtmp1, idx);\n+    sve_extract_integral(rscratch1, D, vtmp1, idx, \/* is_signed *\/ false, vtmp2);\n@@ -1270,0 +1270,15 @@\n+\n+\/\/ Extract a scalar element from an sve vector at position 'idx'.\n+\/\/ The input elements in src are expected to be of integral type.\n+void C2_MacroAssembler::sve_extract_integral(Register dst, SIMD_RegVariant size, FloatRegister src, int idx,\n+                                             bool is_signed, FloatRegister vtmp) {\n+  assert(UseSVE > 0 && size != Q, \"unsupported\");\n+  assert(!(is_signed && size == D), \"signed extract (D) not supported.\");\n+  if (regVariant_to_elemBits(size) * idx < 128) { \/\/ generate lower cost NEON instruction\n+    is_signed ? smov(dst, src, size, idx) : umov(dst, src, size, idx);\n+  } else {\n+    sve_orr(vtmp, src, src);\n+    sve_ext(vtmp, vtmp, idx << size);\n+    is_signed ? smov(dst, vtmp, size, 0) : umov(dst, vtmp, size, 0);\n+  }\n+}\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":19,"deletions":4,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,1 +64,1 @@\n-                        FloatRegister vtmp1, FloatRegister vtmp2, PRegister pgtmp);\n+                        FloatRegister vtmp1, FloatRegister vtmp2);\n@@ -103,10 +103,3 @@\n-  \/\/ rscratch1 will be clobbered.\n-  \/\/ T could be FloatRegister or Register.\n-  template<class T>\n-  inline void sve_extract(T dst, SIMD_RegVariant size, PRegister pg, FloatRegister src, int idx) {\n-    assert(UseSVE > 0, \"not supported\");\n-    assert(pg->is_governing(), \"This register has to be a governing predicate register\");\n-    mov(rscratch1, idx);\n-    sve_whilele(pg, size, zr, rscratch1);\n-    sve_lastb(dst, size, pg, src);\n-  }\n+  \/\/ The input elements in src are expected to be of integral type.\n+  void sve_extract_integral(Register dst, SIMD_RegVariant size, FloatRegister src, int idx,\n+                            bool is_signed, FloatRegister vtmp);\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.hpp","additions":5,"deletions":12,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1783,0 +1783,1 @@\n+                        [\"ext\",     \"__ sve_ext(z17, z16, 63);\",                          \"ext\\tz17.b, z17.b, z16.b, #63\"],\n","filename":"test\/hotspot\/gtest\/aarch64\/aarch64-asmtest.py","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -942,0 +942,1 @@\n+    __ sve_ext(z17, z16, 63);                          \/\/       ext     z17.b, z17.b, z16.b, #63\n@@ -1195,7 +1196,7 @@\n-    0x14000000,     0x17ffffd7,     0x140003d2,     0x94000000,\n-    0x97ffffd4,     0x940003cf,     0x3400000a,     0x34fffa2a,\n-    0x3400798a,     0x35000008,     0x35fff9c8,     0x35007928,\n-    0xb400000b,     0xb4fff96b,     0xb40078cb,     0xb500001d,\n-    0xb5fff91d,     0xb500787d,     0x10000013,     0x10fff8b3,\n-    0x10007813,     0x90000013,     0x36300016,     0x3637f836,\n-    0x36307796,     0x3758000c,     0x375ff7cc,     0x3758772c,\n+    0x14000000,     0x17ffffd7,     0x140003d3,     0x94000000,\n+    0x97ffffd4,     0x940003d0,     0x3400000a,     0x34fffa2a,\n+    0x340079aa,     0x35000008,     0x35fff9c8,     0x35007948,\n+    0xb400000b,     0xb4fff96b,     0xb40078eb,     0xb500001d,\n+    0xb5fff91d,     0xb500789d,     0x10000013,     0x10fff8b3,\n+    0x10007833,     0x90000013,     0x36300016,     0x3637f836,\n+    0x363077b6,     0x3758000c,     0x375ff7cc,     0x3758774c,\n@@ -1206,13 +1207,13 @@\n-    0x54007500,     0x54000001,     0x54fff541,     0x540074a1,\n-    0x54000002,     0x54fff4e2,     0x54007442,     0x54000002,\n-    0x54fff482,     0x540073e2,     0x54000003,     0x54fff423,\n-    0x54007383,     0x54000003,     0x54fff3c3,     0x54007323,\n-    0x54000004,     0x54fff364,     0x540072c4,     0x54000005,\n-    0x54fff305,     0x54007265,     0x54000006,     0x54fff2a6,\n-    0x54007206,     0x54000007,     0x54fff247,     0x540071a7,\n-    0x54000008,     0x54fff1e8,     0x54007148,     0x54000009,\n-    0x54fff189,     0x540070e9,     0x5400000a,     0x54fff12a,\n-    0x5400708a,     0x5400000b,     0x54fff0cb,     0x5400702b,\n-    0x5400000c,     0x54fff06c,     0x54006fcc,     0x5400000d,\n-    0x54fff00d,     0x54006f6d,     0x5400000e,     0x54ffefae,\n-    0x54006f0e,     0x5400000f,     0x54ffef4f,     0x54006eaf,\n+    0x54007520,     0x54000001,     0x54fff541,     0x540074c1,\n+    0x54000002,     0x54fff4e2,     0x54007462,     0x54000002,\n+    0x54fff482,     0x54007402,     0x54000003,     0x54fff423,\n+    0x540073a3,     0x54000003,     0x54fff3c3,     0x54007343,\n+    0x54000004,     0x54fff364,     0x540072e4,     0x54000005,\n+    0x54fff305,     0x54007285,     0x54000006,     0x54fff2a6,\n+    0x54007226,     0x54000007,     0x54fff247,     0x540071c7,\n+    0x54000008,     0x54fff1e8,     0x54007168,     0x54000009,\n+    0x54fff189,     0x54007109,     0x5400000a,     0x54fff12a,\n+    0x540070aa,     0x5400000b,     0x54fff0cb,     0x5400704b,\n+    0x5400000c,     0x54fff06c,     0x54006fec,     0x5400000d,\n+    0x54fff00d,     0x54006f8d,     0x5400000e,     0x54ffefae,\n+    0x54006f2e,     0x5400000f,     0x54ffef4f,     0x54006ecf,\n@@ -1390,51 +1391,51 @@\n-    0x05e14c00,     0x05304001,     0x05314001,     0x1e601000,\n-    0x1e603000,     0x1e621000,     0x1e623000,     0x1e641000,\n-    0x1e643000,     0x1e661000,     0x1e663000,     0x1e681000,\n-    0x1e683000,     0x1e6a1000,     0x1e6a3000,     0x1e6c1000,\n-    0x1e6c3000,     0x1e6e1000,     0x1e6e3000,     0x1e701000,\n-    0x1e703000,     0x1e721000,     0x1e723000,     0x1e741000,\n-    0x1e743000,     0x1e761000,     0x1e763000,     0x1e781000,\n-    0x1e783000,     0x1e7a1000,     0x1e7a3000,     0x1e7c1000,\n-    0x1e7c3000,     0x1e7e1000,     0x1e7e3000,     0xf82a822f,\n-    0xf822018a,     0xf82c11af,     0xf8222287,     0xf83a3090,\n-    0xf8225184,     0xf8304215,     0xf83072ab,     0xf837634c,\n-    0xf8b781dc,     0xf8ab0038,     0xf8ac115f,     0xf8b02047,\n-    0xf8a3326d,     0xf8b15070,     0xf8a143cb,     0xf8a571e8,\n-    0xf8bd601e,     0xf8f48287,     0xf8f702bc,     0xf8fb10b9,\n-    0xf8e12217,     0xf8ff3185,     0xf8e951fc,     0xf8fd43f6,\n-    0xf8f370bf,     0xf8ee63f0,     0xf870829b,     0xf870016c,\n-    0xf86913c6,     0xf871239b,     0xf87e3147,     0xf874508a,\n-    0xf8784231,     0xf87673a3,     0xf86f6276,     0xb8338056,\n-    0xb82f0186,     0xb83011ab,     0xb83723c1,     0xb8333225,\n-    0xb82252d0,     0xb82d42aa,     0xb83d719b,     0xb83b6023,\n-    0xb8bf8278,     0xb8b10389,     0xb8bb10ef,     0xb8b523f7,\n-    0xb8b933e2,     0xb8bb5150,     0xb8b74073,     0xb8b07320,\n-    0xb8ba6057,     0xb8f0808c,     0xb8fc03be,     0xb8f010db,\n-    0xb8e921fd,     0xb8e730e4,     0xb8ef52e9,     0xb8e84382,\n-    0xb8f570bf,     0xb8fb6220,     0xb86f8344,     0xb86802dc,\n-    0xb87b133b,     0xb8772080,     0xb8663010,     0xb864502f,\n-    0xb86a40a7,     0xb86a70fc,     0xb87462b7,     0xce284145,\n-    0xce1108de,     0xce7c8fab,     0xce96eb42,     0xce7b81ae,\n-    0xce6586f0,     0xcec081a2,     0xce6a89ea,     0x25a0cc5a,\n-    0x25a1d143,     0x05800e44,     0x05406531,     0x05002d42,\n-    0x2520c677,     0x25a1cd07,     0x0580687b,     0x0543bb42,\n-    0x050044a6,     0x25a0c86c,     0x25a1d358,     0x05800500,\n-    0x05400ad3,     0x05000e06,     0x25e0c951,     0x25a1d54a,\n-    0x05839276,     0x0540ea6f,     0x0503c8a4,     0x25a0d448,\n-    0x2521d056,     0x058059c9,     0x05406d05,     0x05003cb6,\n-    0x25a0d0c8,     0x2561c4f9,     0x05809904,     0x05400e5d,\n-    0x0500cadd,     0x043c0162,     0x04ba0427,     0x65c801d1,\n-    0x65c50b15,     0x65d60635,     0x0416b67d,     0x040012e4,\n-    0x04da06f3,     0x04508113,     0x04db1a2e,     0x041aa7d5,\n-    0x0419158a,     0x04938709,     0x045198c4,     0x049019bb,\n-    0x0497b6de,     0x045ebd3e,     0x04d80693,     0x044809a9,\n-    0x044a0313,     0x04810e33,     0x049ca410,     0x658089eb,\n-    0x65cd85ef,     0x65c68145,     0x6587801a,     0x65c29d53,\n-    0x04ddb4e3,     0x6582aebc,     0x65c0ae3a,     0x65c1ac51,\n-    0x658db690,     0x65c18033,     0x65f18a11,     0x65b70440,\n-    0x65ee2a86,     0x65e34c7d,     0x65bb6309,     0x049954f3,\n-    0x041964ed,     0x04313235,     0x04b33123,     0x046e3167,\n-    0x04ed3171,     0x05716bd1,     0x05ba6dcf,     0x045a34fb,\n-    0x04583f65,     0x04992f00,     0x04882074,     0x04ca2739,\n-    0x65873031,     0x65863dae,     0x65d823d1,     0x044137b6,\n-\n+    0x05e14c00,     0x05304001,     0x05314001,     0x05271e11,\n+    0x1e601000,     0x1e603000,     0x1e621000,     0x1e623000,\n+    0x1e641000,     0x1e643000,     0x1e661000,     0x1e663000,\n+    0x1e681000,     0x1e683000,     0x1e6a1000,     0x1e6a3000,\n+    0x1e6c1000,     0x1e6c3000,     0x1e6e1000,     0x1e6e3000,\n+    0x1e701000,     0x1e703000,     0x1e721000,     0x1e723000,\n+    0x1e741000,     0x1e743000,     0x1e761000,     0x1e763000,\n+    0x1e781000,     0x1e783000,     0x1e7a1000,     0x1e7a3000,\n+    0x1e7c1000,     0x1e7c3000,     0x1e7e1000,     0x1e7e3000,\n+    0xf82a822f,     0xf822018a,     0xf82c11af,     0xf8222287,\n+    0xf83a3090,     0xf8225184,     0xf8304215,     0xf83072ab,\n+    0xf837634c,     0xf8b781dc,     0xf8ab0038,     0xf8ac115f,\n+    0xf8b02047,     0xf8a3326d,     0xf8b15070,     0xf8a143cb,\n+    0xf8a571e8,     0xf8bd601e,     0xf8f48287,     0xf8f702bc,\n+    0xf8fb10b9,     0xf8e12217,     0xf8ff3185,     0xf8e951fc,\n+    0xf8fd43f6,     0xf8f370bf,     0xf8ee63f0,     0xf870829b,\n+    0xf870016c,     0xf86913c6,     0xf871239b,     0xf87e3147,\n+    0xf874508a,     0xf8784231,     0xf87673a3,     0xf86f6276,\n+    0xb8338056,     0xb82f0186,     0xb83011ab,     0xb83723c1,\n+    0xb8333225,     0xb82252d0,     0xb82d42aa,     0xb83d719b,\n+    0xb83b6023,     0xb8bf8278,     0xb8b10389,     0xb8bb10ef,\n+    0xb8b523f7,     0xb8b933e2,     0xb8bb5150,     0xb8b74073,\n+    0xb8b07320,     0xb8ba6057,     0xb8f0808c,     0xb8fc03be,\n+    0xb8f010db,     0xb8e921fd,     0xb8e730e4,     0xb8ef52e9,\n+    0xb8e84382,     0xb8f570bf,     0xb8fb6220,     0xb86f8344,\n+    0xb86802dc,     0xb87b133b,     0xb8772080,     0xb8663010,\n+    0xb864502f,     0xb86a40a7,     0xb86a70fc,     0xb87462b7,\n+    0xce284145,     0xce1108de,     0xce7c8fab,     0xce96eb42,\n+    0xce7b81ae,     0xce6586f0,     0xcec081a2,     0xce6a89ea,\n+    0x25a0cc5a,     0x25a1d143,     0x05800e44,     0x05406531,\n+    0x05002d42,     0x2520c677,     0x25a1cd07,     0x0580687b,\n+    0x0543bb42,     0x050044a6,     0x25a0c86c,     0x25a1d358,\n+    0x05800500,     0x05400ad3,     0x05000e06,     0x25e0c951,\n+    0x25a1d54a,     0x05839276,     0x0540ea6f,     0x0503c8a4,\n+    0x25a0d448,     0x2521d056,     0x058059c9,     0x05406d05,\n+    0x05003cb6,     0x25a0d0c8,     0x2561c4f9,     0x05809904,\n+    0x05400e5d,     0x0500cadd,     0x043c0162,     0x04ba0427,\n+    0x65c801d1,     0x65c50b15,     0x65d60635,     0x0416b67d,\n+    0x040012e4,     0x04da06f3,     0x04508113,     0x04db1a2e,\n+    0x041aa7d5,     0x0419158a,     0x04938709,     0x045198c4,\n+    0x049019bb,     0x0497b6de,     0x045ebd3e,     0x04d80693,\n+    0x044809a9,     0x044a0313,     0x04810e33,     0x049ca410,\n+    0x658089eb,     0x65cd85ef,     0x65c68145,     0x6587801a,\n+    0x65c29d53,     0x04ddb4e3,     0x6582aebc,     0x65c0ae3a,\n+    0x65c1ac51,     0x658db690,     0x65c18033,     0x65f18a11,\n+    0x65b70440,     0x65ee2a86,     0x65e34c7d,     0x65bb6309,\n+    0x049954f3,     0x041964ed,     0x04313235,     0x04b33123,\n+    0x046e3167,     0x04ed3171,     0x05716bd1,     0x05ba6dcf,\n+    0x045a34fb,     0x04583f65,     0x04992f00,     0x04882074,\n+    0x04ca2739,     0x65873031,     0x65863dae,     0x65d823d1,\n+    0x044137b6,\n","filename":"test\/hotspot\/gtest\/aarch64\/asmtest.out.h","additions":72,"deletions":71,"binary":false,"changes":143,"status":"modified"}]}