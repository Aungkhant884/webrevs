{"files":[{"patch":"@@ -736,2 +736,1 @@\n-\/\/%note monitor_1\n-JRT_ENTRY_NO_ASYNC(void, InterpreterRuntime::monitorexit(JavaThread* thread, BasicObjectLock* elem))\n+JRT_LEAF(void, InterpreterRuntime::monitorexit(JavaThread* thread, BasicObjectLock* elem))\n@@ -741,5 +740,9 @@\n-  Handle h_obj(thread, elem->obj());\n-  assert(Universe::heap()->is_in_or_null(h_obj()),\n-         \"must be NULL or an object\");\n-  if (elem == NULL || h_obj()->is_unlocked()) {\n-    THROW(vmSymbols::java_lang_IllegalMonitorStateException());\n+  oop obj = elem->obj();\n+  assert(Universe::heap()->is_in(obj), \"must an object\");\n+  \/\/ The object could become unlocked through a JNI call, which we have no other checks for.\n+  \/\/ Give a message if CheckJNICalls but ignore.\n+  if (obj->is_unlocked()) {\n+    if (CheckJNICalls) {\n+      fatal(\"Object has been unlocked by JNI\");\n+    }\n+    return;\n@@ -747,3 +750,3 @@\n-  ObjectSynchronizer::exit(h_obj(), elem->lock(), thread);\n-  \/\/ Free entry. This must be done here, since a pending exception might be installed on\n-  \/\/ exit. If it is not cleared, the exception handling code will try to unlock the monitor again.\n+  ObjectSynchronizer::exit(obj, elem->lock(), thread);\n+  \/\/ Free entry. If it is not cleared, the exception handling code will try to unlock the monitor\n+  \/\/ again at method exit or in the case of an exception.\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":13,"deletions":10,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2105,0 +2105,8 @@\n+  \/\/ The object could become unlocked through a JNI call, which we have no other checks for.\n+  \/\/ Give a message if CheckJNICalls but ignore.\n+  if (obj->is_unlocked()) {\n+    if (CheckJNICalls) {\n+      fatal(\"Object has been unlocked by JNI\");\n+    }\n+    return;\n+  }\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"}]}