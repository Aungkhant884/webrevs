{"files":[{"patch":"@@ -736,2 +736,1 @@\n-\/\/%note monitor_1\n-JRT_ENTRY_NO_ASYNC(void, InterpreterRuntime::monitorexit(JavaThread* thread, BasicObjectLock* elem))\n+JRT_LEAF(void, InterpreterRuntime::monitorexit(JavaThread* thread, BasicObjectLock* elem))\n@@ -741,9 +740,6 @@\n-  Handle h_obj(thread, elem->obj());\n-  assert(Universe::heap()->is_in_or_null(h_obj()),\n-         \"must be NULL or an object\");\n-  if (elem == NULL || h_obj()->is_unlocked()) {\n-    THROW(vmSymbols::java_lang_IllegalMonitorStateException());\n-  }\n-  ObjectSynchronizer::exit(h_obj(), elem->lock(), thread);\n-  \/\/ Free entry. This must be done here, since a pending exception might be installed on\n-  \/\/ exit. If it is not cleared, the exception handling code will try to unlock the monitor again.\n+  oop obj = elem->obj();\n+  assert(!obj->is_unlocked(), \"caller checked these conditions\");\n+  assert(Universe::heap()->is_in_or_null(obj), \"must be NULL or an object\");\n+  ObjectSynchronizer::exit(obj, elem->lock(), thread);\n+  \/\/ Free entry. If it is not cleared, the exception handling code will try to unlock the monitor\n+  \/\/ again at method exit or in the case of an exception.\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":7,"deletions":11,"binary":false,"changes":18,"status":"modified"}]}