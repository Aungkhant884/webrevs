{"files":[{"patch":"@@ -2574,0 +2574,1 @@\n+#if INCLUDE_JVMTI\n@@ -2580,0 +2581,4 @@\n+    \/\/ First fix any default methods that point to a super class that may\n+    \/\/ have been redefined.\n+    bool trace_name_printed = false;\n+    adjust_default_methods(&trace_name_printed);\n@@ -2583,0 +2588,1 @@\n+#endif\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -225,3 +225,9 @@\n-          methodHandle mh(THREAD, default_methods->at(i));\n-          assert(!mh->is_private(), \"private interface method in the default method list\");\n-          bool needs_new_entry = update_inherited_vtable(mh, super_vtable_len, i, checkconstraints, CHECK);\n+          bool needs_new_entry;\n+          {\n+            \/\/ Reduce the scope of this handle so that it is fetched again.\n+            \/\/ The methodHandle keeps it from being deleted by RedefineClasses while\n+            \/\/ we're using it.\n+            methodHandle mh(THREAD, default_methods->at(i));\n+            assert(!mh->is_private(), \"private interface method in the default method list\");\n+            needs_new_entry = update_inherited_vtable(mh, super_vtable_len, i, checkconstraints, CHECK);\n+          }\n@@ -231,1 +237,3 @@\n-            put_method_at(mh(), initialized);\n+            \/\/ Refetch this default method in case of redefinition in safepoint above.\n+            Method* method = default_methods->at(i);\n+            put_method_at(method, initialized);\n@@ -497,0 +505,5 @@\n+        \/\/ Set the vtable index before the constraint check safepoint potentially\n+        \/\/ redefines this method, which is possible if it is a default method belonging\n+        \/\/ to a super class or interface.\n+        put_method_at(target_method(), i);\n+\n@@ -534,1 +547,0 @@\n-        put_method_at(target_method(), i);\n","filename":"src\/hotspot\/share\/oops\/klassVtable.cpp","additions":17,"deletions":5,"binary":false,"changes":22,"status":"modified"}]}