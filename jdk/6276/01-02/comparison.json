{"files":[{"patch":"@@ -2275,0 +2275,1 @@\n+        Node* hook = new Node(1);\n@@ -2279,2 +2280,1 @@\n-        } else {\n-          phase->record_for_igvn(new_base);\n+          hook->add_req(new_base);\n@@ -2282,1 +2282,0 @@\n-\n@@ -2285,1 +2284,1 @@\n-          Node* ii = in(i);\n+          Node *ii = in(i);\n@@ -2296,2 +2295,1 @@\n-                } else {\n-                  phase->record_for_igvn(new_phi);\n+                  hook->add_req(new_phi);\n@@ -2316,3 +2314,16 @@\n-        \/\/ Replace self with the result without transforming the new phi nodes now. This prevents a\n-        \/\/ potential dead loop because this phi is still alive during the transformations and could\n-        \/\/ let a dead loop check fail even though there is one without this phi.\n+\n+        if (igvn) {\n+          \/\/ Already replace this phi node to cut it off from the graph to not interfere in dead loop checks during the\n+          \/\/ transformations of the new phi nodes below. Otherwise, we could wrongly conclude that there is no dead loop\n+          \/\/ because we are finding this phi node again. Also set the type of the new MergeMem node in case we are also\n+          \/\/ visiting it in the transformations below.\n+          igvn->replace_node(this, result);\n+          igvn->set_type(result, result->bottom_type());\n+        }\n+        \/\/ now transform the new nodes, and return the mergemem\n+        for (MergeMemStream mms(result); mms.next_non_empty(); ) {\n+          Node* phi = mms.memory();\n+          mms.set_memory(phase->transform(phi));\n+        }\n+        hook->destruct(igvn);\n+        \/\/ Replace self with the result.\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":20,"deletions":9,"binary":false,"changes":29,"status":"modified"}]}