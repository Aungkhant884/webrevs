{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,1 @@\n- * bool register_serializer(JfrTypeId id, bool require_safepoint, bool permit_cache, JfrSerializer* serializer)\n+ * bool register_serializer(JfrTypeId id, bool permit_cache, JfrSerializer* serializer)\n@@ -62,1 +62,0 @@\n- * require_safepoint  indicate if your type need to be evaluated and serialized under a safepoint.\n","filename":"src\/hotspot\/share\/jfr\/metadata\/jfrSerializer.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -160,0 +160,4 @@\n+  if (java_lang_Class::is_primitive(my_oop)) {\n+    assert(java_lang_Class::as_Klass(my_oop) == NULL, \"invariant\");\n+    return (traceid)java_lang_Class::primitive_type(my_oop);\n+  }\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceId.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -79,0 +79,4 @@\n+  if (java_lang_Class::is_primitive(my_oop)) {\n+    assert(java_lang_Class::as_Klass(my_oop) == NULL, \"invariant\");\n+    return (traceid)java_lang_Class::primitive_type(my_oop);\n+  }\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdLoadBarrier.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,4 @@\n+#if INCLUDE_JFR\n+#include \"jfr\/jfrEvents.hpp\"\n+#include \"jfr\/metadata\/jfrSerializer.hpp\"\n+#endif\n@@ -70,0 +74,45 @@\n+#if INCLUDE_JFR\n+class BasicTypeNameSerializer : public JfrSerializer {\n+ public:\n+  void serialize(JfrCheckpointWriter& writer) {\n+    writer.write_count((u4)(T_VOID - T_BOOLEAN - 1));\n+    for (int i = T_BOOLEAN; i <= T_VOID; ++i) {\n+      BasicType bt = (BasicType)i;\n+      if (!is_reference_type(bt)) {\n+        \/\/ use the index as the key here, it will not conflict\n+        \/\/ with the key generated in jfrTypeSet, because the\n+        \/\/ latter will contain checkpoint_id\n+        writer.write_key((u8)i);\n+        writer.write(type2name(bt));\n+      }\n+    }\n+  }\n+};\n+\n+class BasicTypeSerializer : public JfrSerializer {\n+ public:\n+  void serialize(JfrCheckpointWriter& writer) {\n+    writer.write_count((u4)(T_VOID - T_BOOLEAN - 1));\n+    for (int i = T_BOOLEAN; i <= T_VOID; ++i) {\n+      BasicType bt = (BasicType)i;\n+      if (!is_reference_type(bt)) {\n+        \/\/ use the index as the key here, it will not conflict\n+        \/\/ with the key generated by JfrTraceId::next_class_id,\n+        \/\/ because the latter must be greater than LAST_TYPE_ID\n+        writer.write_key((u8)i);\n+        \/\/ FIXME: should we use _the_null_class_loader_data here?\n+        writer.write(0);\n+        \/\/ name\n+        writer.write((u8)i);\n+        \/\/ package\n+        writer.write(0);\n+        \/\/ modifier, same with JVM_GetClassModifiers\n+        writer.write(JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC);\n+        \/\/ hidden\n+        writer.write<bool>(false);\n+      }\n+    }\n+  }\n+};\n+#endif\n+\n@@ -196,0 +245,5 @@\n+\n+#if INCLUDE_JFR\n+  JfrSerializer::register_serializer(TYPE_SYMBOL, true, new BasicTypeNameSerializer());\n+  JfrSerializer::register_serializer(TYPE_CLASS, true, new BasicTypeSerializer());\n+#endif\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.cpp","additions":55,"deletions":1,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2021, Alibaba Group Holding Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test TestBasicTypes\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @run main\/othervm jdk.jfr.event.runtime.TestBasicTypes\n+ *\/\n+\n+package jdk.jfr.event.runtime;\n+\n+import java.lang.reflect.Modifier;\n+import java.util.List;\n+\n+import jdk.jfr.Event;\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedClass;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.jfr.Events;\n+\n+public class TestBasicTypes {\n+\n+    private static class MyEvent extends Event {\n+        Class<?> booleanClass = boolean.class;\n+        Class<?> charClass = char.class;\n+        Class<?> floatClass = float.class;\n+        Class<?> doubleClass = double.class;\n+        Class<?> byteClass = byte.class;\n+        Class<?> shortClass = short.class;\n+        Class<?> intClass = int.class;\n+        Class<?> longClass = long.class;\n+        Class<?> voidClass = void.class;\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        try (Recording r = new Recording()) {\n+            r.enable(MyEvent.class);\n+            r.enable(MyEvent.class);\n+            r.start();\n+            MyEvent myEvent = new MyEvent();\n+            myEvent.commit();\n+            r.stop();\n+            List<RecordedEvent> events = Events.fromRecording(r);\n+            Events.hasEvents(events);\n+            RecordedEvent event = events.get(0);\n+            System.out.println(event);\n+            testField(event, \"booleanClass\", boolean.class);\n+            testField(event, \"charClass\", char.class);\n+            testField(event, \"floatClass\", float.class);\n+            testField(event, \"doubleClass\", double.class);\n+            testField(event, \"byteClass\", byte.class);\n+            testField(event, \"shortClass\", short.class);\n+            testField(event, \"intClass\", int.class);\n+            testField(event, \"longClass\", long.class);\n+            testField(event, \"voidClass\", void.class);\n+        }\n+    }\n+\n+    private static void testField(RecordedEvent event, String fieldName, Class<?> excepted) {\n+        Asserts.assertTrue(event.hasField(fieldName));\n+        RecordedClass classField = event.getValue(fieldName);\n+        Asserts.assertEquals(classField.getName(), excepted.getName());\n+        Asserts.assertNull(classField.getClassLoader());\n+        Asserts.assertEquals(classField.getModifiers(), excepted.getModifiers());\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/TestBasicTypes.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"}]}