{"files":[{"patch":"@@ -34,0 +34,1 @@\n+#include \"utilities\/bitCast.hpp\"\n@@ -303,1 +304,1 @@\n-  return PrimitiveConversions::cast<T>((unsigned char)old_value);\n+  return bit_cast<T>((unsigned char)old_value);\n","filename":"src\/hotspot\/os_cpu\/aix_ppc\/atomic_aix_ppc.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+#include \"utilities\/bitCast.hpp\"\n+\n@@ -162,1 +164,1 @@\n-  return PrimitiveConversions::cast<T>(dest);\n+  return bit_cast<T>(dest);\n","filename":"src\/hotspot\/os_cpu\/bsd_x86\/atomic_bsd_x86.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"utilities\/bitCast.hpp\"\n@@ -313,1 +314,1 @@\n-  return PrimitiveConversions::cast<T>(dest);\n+  return bit_cast<T>(dest);\n","filename":"src\/hotspot\/os_cpu\/bsd_zero\/atomic_bsd_zero.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"utilities\/bitCast.hpp\"\n@@ -83,1 +84,1 @@\n-  return PrimitiveConversions::cast<T>(\n+  return bit_cast<T>(\n@@ -93,1 +94,1 @@\n-    PrimitiveConversions::cast<int64_t>(store_value), reinterpret_cast<volatile int64_t*>(dest));\n+    bit_cast<int64_t>(store_value), reinterpret_cast<volatile int64_t*>(dest));\n","filename":"src\/hotspot\/os_cpu\/linux_arm\/atomic_linux_arm.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"utilities\/bitCast.hpp\"\n@@ -303,1 +304,1 @@\n-  return PrimitiveConversions::cast<T>((unsigned char)old_value);\n+  return bit_cast<T>((unsigned char)old_value);\n","filename":"src\/hotspot\/os_cpu\/linux_ppc\/atomic_linux_ppc.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+#include \"utilities\/bitCast.hpp\"\n+\n@@ -162,1 +164,1 @@\n-  return PrimitiveConversions::cast<T>(dest);\n+  return bit_cast<T>(dest);\n","filename":"src\/hotspot\/os_cpu\/linux_x86\/atomic_linux_x86.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"utilities\/bitCast.hpp\"\n@@ -184,1 +185,1 @@\n-  return PrimitiveConversions::cast<T>(dest);\n+  return bit_cast<T>(dest);\n","filename":"src\/hotspot\/os_cpu\/linux_zero\/atomic_linux_zero.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"utilities\/bitCast.hpp\"\n@@ -60,1 +61,1 @@\n-    return PrimitiveConversions::cast<D>(                                 \\\n+    return bit_cast<D>(                                                   \\\n@@ -62,1 +63,1 @@\n-                    PrimitiveConversions::cast<IntrinsicType>(add_value))); \\\n+                    bit_cast<IntrinsicType>(add_value)));                 \\\n@@ -77,1 +78,1 @@\n-    return PrimitiveConversions::cast<T>(                                 \\\n+    return bit_cast<T>(                                                   \\\n@@ -79,1 +80,1 @@\n-                    PrimitiveConversions::cast<IntrinsicType>(exchange_value))); \\\n+                    bit_cast<IntrinsicType>(exchange_value)));            \\\n@@ -99,1 +100,1 @@\n-    return PrimitiveConversions::cast<T>(                                 \\\n+    return bit_cast<T>(                                                   \\\n@@ -101,2 +102,2 @@\n-                    PrimitiveConversions::cast<IntrinsicType>(exchange_value), \\\n-                    PrimitiveConversions::cast<IntrinsicType>(compare_value))); \\\n+                    bit_cast<IntrinsicType>(exchange_value),              \\\n+                    bit_cast<IntrinsicType>(compare_value)));             \\\n","filename":"src\/hotspot\/os_cpu\/windows_aarch64\/atomic_windows_aarch64.hpp","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"utilities\/bitCast.hpp\"\n@@ -63,1 +64,1 @@\n-    return PrimitiveConversions::cast<D>(                                 \\\n+    return bit_cast<D>(                                                   \\\n@@ -65,1 +66,1 @@\n-                    PrimitiveConversions::cast<IntrinsicType>(add_value))); \\\n+                    bit_cast<IntrinsicType>(add_value)));                 \\\n@@ -80,1 +81,1 @@\n-    return PrimitiveConversions::cast<T>(                                 \\\n+    return bit_cast<T>(                                                   \\\n@@ -82,1 +83,1 @@\n-                    PrimitiveConversions::cast<IntrinsicType>(exchange_value))); \\\n+                    bit_cast<IntrinsicType>(exchange_value)));            \\\n@@ -102,1 +103,1 @@\n-    return PrimitiveConversions::cast<T>(                                 \\\n+    return bit_cast<T>(                                                   \\\n@@ -104,2 +105,2 @@\n-                    PrimitiveConversions::cast<IntrinsicType>(exchange_value), \\\n-                    PrimitiveConversions::cast<IntrinsicType>(compare_value))); \\\n+                    bit_cast<IntrinsicType>(exchange_value),              \\\n+                    bit_cast<IntrinsicType>(compare_value)));             \\\n","filename":"src\/hotspot\/os_cpu\/windows_x86\/atomic_windows_x86.hpp","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"metaprogramming\/enableIf.hpp\"\n+#include \"utilities\/bitCast.hpp\"\n@@ -31,0 +31,1 @@\n+\n@@ -34,8 +35,0 @@\n-\n-  \/\/ True if types are the same size and either is integral.\n-  template<typename To, typename From>\n-  static constexpr bool check_cast() {\n-    return (sizeof(To) == sizeof(From)) &&\n-           (std::is_integral<To>::value || std::is_integral<From>::value);\n-  }\n-\n@@ -43,65 +36,0 @@\n-  \/\/ template<typename To, typename From> To cast(From x)\n-  \/\/\n-  \/\/ Return a value of type To with the same value representation as x.\n-  \/\/\n-  \/\/ To and From must be of the same size.\n-  \/\/\n-  \/\/ At least one of To or From must be an integral type.  The other must\n-  \/\/ be an integral, enum, floating point, or pointer type.\n-\n-  \/\/ integer -> integer\n-  \/\/ Use static_cast for conversion.  See C++14 4.7 Integral\n-  \/\/ conversions. If To is signed and From unsigned, the result is\n-  \/\/ implementation-defined.  All supported platforms provide two's\n-  \/\/ complement behavior, and that behavior is required by C++20.\n-  \/\/ Using an lvalue to reference cast (see C++03 3.10\/15) involves a\n-  \/\/ reinterpret_cast, which prevents constexpr support.\n-  template<typename To, typename From,\n-           ENABLE_IF(sizeof(To) == sizeof(From)),\n-           ENABLE_IF(std::is_integral<To>::value),\n-           ENABLE_IF(std::is_integral<From>::value)>\n-  static constexpr To cast(From x) {\n-    return static_cast<To>(x);\n-  }\n-\n-  \/\/ integer -> enum, enum -> integer\n-  \/\/ Use the enum's underlying type for integer -> integer cast.\n-  template<typename To, typename From,\n-           ENABLE_IF(check_cast<To, From>()),\n-           ENABLE_IF(std::is_enum<To>::value)>\n-  static constexpr To cast(From x) {\n-    return static_cast<To>(cast<std::underlying_type_t<To>>(x));\n-  }\n-\n-  template<typename To, typename From,\n-           ENABLE_IF(check_cast<To, From>()),\n-           ENABLE_IF(std::is_enum<From>::value)>\n-  static constexpr To cast(From x) {\n-    return cast<To>(static_cast<std::underlying_type_t<From>>(x));\n-  }\n-\n-  \/\/ integer -> pointer, pointer -> integer\n-  \/\/ Use reinterpret_cast, so no constexpr support.\n-  template<typename To, typename From,\n-           ENABLE_IF(check_cast<To, From>()),\n-           ENABLE_IF(std::is_pointer<To>::value || std::is_pointer<From>::value)>\n-  static To cast(From x) {\n-    return reinterpret_cast<To>(x);\n-  }\n-\n-  \/\/ integer -> floating point, floating point -> integer\n-  \/\/ Use the union trick.  The union trick is technically UB, but is\n-  \/\/ widely and well supported, producing good code.  In some cases,\n-  \/\/ such as gcc, that support is explicitly documented.  Using memcpy\n-  \/\/ is the correct method, but some compilers produce wretched code\n-  \/\/ for that method, even at maximal optimization levels.  Neither\n-  \/\/ the union trick nor memcpy provides constexpr support.\n-  template<typename To, typename From,\n-           ENABLE_IF(check_cast<To, From>()),\n-           ENABLE_IF(std::is_floating_point<To>::value ||\n-                     std::is_floating_point<From>::value)>\n-  static To cast(From x) {\n-    union { From from; To to; } converter = { x };\n-    return converter.to;\n-  }\n-\n@@ -140,2 +68,2 @@\n-  static Decayed decay(Value x) { return PrimitiveConversions::cast<Decayed>(x); }\n-  static Value recover(Decayed x) { return PrimitiveConversions::cast<Value>(x); }\n+  static Decayed decay(Value x) { return bit_cast<Decayed>(x); }\n+  static Value recover(Decayed x) { return bit_cast<Value>(x); }\n@@ -149,2 +77,2 @@\n-  static Decayed decay(Value x) { return PrimitiveConversions::cast<Decayed>(x); }\n-  static Value recover(Decayed x) { return PrimitiveConversions::cast<Value>(x); }\n+  static Decayed decay(Value x) { return bit_cast<Decayed>(x); }\n+  static Value recover(Decayed x) { return bit_cast<Value>(x); }\n","filename":"src\/hotspot\/share\/metaprogramming\/primitiveConversions.hpp","additions":6,"deletions":78,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"utilities\/bitCast.hpp\"\n@@ -743,2 +744,2 @@\n-  return PrimitiveConversions::cast<D>(\n-    fn(PrimitiveConversions::cast<Type>(add_value),\n+  return bit_cast<D>(\n+    fn(bit_cast<Type>(add_value),\n@@ -842,2 +843,2 @@\n-  return PrimitiveConversions::cast<T>(\n-    fn(PrimitiveConversions::cast<Type>(exchange_value),\n+  return bit_cast<T>(\n+    fn(bit_cast<Type>(exchange_value),\n@@ -845,1 +846,1 @@\n-       PrimitiveConversions::cast<Type>(compare_value)));\n+       bit_cast<Type>(compare_value)));\n@@ -898,1 +899,1 @@\n-  return PrimitiveConversions::cast<T>(get_byte_in_int(cur, idx));\n+  return bit_cast<T>(get_byte_in_int(cur, idx));\n@@ -961,2 +962,2 @@\n-  return PrimitiveConversions::cast<T>(\n-    fn(PrimitiveConversions::cast<Type>(exchange_value),\n+  return bit_cast<T>(\n+    fn(bit_cast<Type>(exchange_value),\n","filename":"src\/hotspot\/share\/runtime\/atomic.hpp","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+#include \"utilities\/bitCast.hpp\"\n@@ -1005,7 +1006,0 @@\n-template<typename T, typename F> T bit_cast(F from) { \/\/ replace with the real thing when we can use c++20\n-  T to;\n-  static_assert(sizeof(to) == sizeof(from), \"must be of the same size\");\n-  memcpy(&to, &from, sizeof(to));\n-  return to;\n-}\n-\n","filename":"src\/hotspot\/share\/services\/heapDumper.cpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,198 @@\n+\/*\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_UTILITIES_BIT_CAST_HPP\n+#define SHARE_UTILITIES_BIT_CAST_HPP\n+\n+\/\/ C++14 compatible implementation of std::bit_cast introduced in C++20.\n+\n+#include \"metaprogramming\/enableIf.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n+#include <cstdint>\n+#include <cstring>\n+#include <type_traits>\n+\n+\/\/ Trivial implementation when To and From are the same.\n+template <typename To, typename From, ENABLE_IF(std::is_same<From, To>::value)>\n+constexpr To bit_cast(const From& from) {\n+  return from;\n+}\n+\n+\/\/ From and To are integrals of the same size. We can simply static_cast without changing the bit\n+\/\/ representation.\n+template <typename To, typename From,\n+          ENABLE_IF(sizeof(To) == sizeof(From) &&\n+                    !std::is_same<From, To>::value &&\n+                    std::is_integral<From>::value &&\n+                    std::is_integral<To>::value)>\n+constexpr To bit_cast(const From& from) {\n+#if HAS_BUILTIN(__builtin_bit_cast) && !defined(__APPLE__)\n+  return __builtin_bit_cast(To, from);\n+#else\n+  return static_cast<To>(from);\n+#endif\n+}\n+\n+\/\/ From is an integral and To is a enum. We can simply static_cast using the underlying type.\n+template <typename To, typename From,\n+          ENABLE_IF(sizeof(To) == sizeof(From) &&\n+                    !std::is_same<From, To>::value &&\n+                    std::is_integral<From>::value &&\n+                    std::is_enum<To>::value)>\n+constexpr To bit_cast(const From& from) {\n+#if HAS_BUILTIN(__builtin_bit_cast) && !defined(__APPLE__)\n+  return __builtin_bit_cast(To, from);\n+#else\n+  return static_cast<To>(bit_cast<std::underlying_type_t<To>>(from));\n+#endif\n+}\n+\n+\/\/ From is an enum and To is an integral. We can simply static_cast using the underlying type.\n+template <typename To, typename From,\n+          ENABLE_IF(sizeof(To) == sizeof(From) &&\n+                    !std::is_same<From, To>::value &&\n+                    std::is_enum<From>::value &&\n+                    std::is_integral<To>::value)>\n+constexpr To bit_cast(const From& from) {\n+#if HAS_BUILTIN(__builtin_bit_cast) && !defined(__APPLE__)\n+  return __builtin_bit_cast(To, from);\n+#else\n+  return bit_cast<To>(static_cast<std::underlying_type_t<From>>(from));\n+#endif\n+}\n+\n+\/\/ From is an enum and To is an enum. We can simply static_cast using the underlying type.\n+template <typename To, typename From,\n+          ENABLE_IF(sizeof(To) == sizeof(From) &&\n+                    !std::is_same<From, To>::value &&\n+                    std::is_enum<From>::value &&\n+                    std::is_enum<To>::value)>\n+constexpr To bit_cast(const From& from) {\n+#if HAS_BUILTIN(__builtin_bit_cast) && !defined(__APPLE__)\n+  return __builtin_bit_cast(To, from);\n+#else\n+  return static_cast<To>(bit_cast<std::underlying_type_t<To>>(\n+      static_cast<std::underlying_type_t<From>>(from)));\n+#endif\n+}\n+\n+\/\/ From and To are pointers.\n+template <typename To, typename From,\n+          ENABLE_IF(sizeof(To) == sizeof(From) &&\n+                    !std::is_same<From, To>::value &&\n+                    std::is_pointer<From>::value &&\n+                    std::is_pointer<To>::value)>\n+inline To bit_cast(const From& from) {\n+#if HAS_BUILTIN(__builtin_bit_cast) && !defined(__APPLE__)\n+  return __builtin_bit_cast(To, from);\n+#else\n+  STATIC_ASSERT(sizeof(uintptr_t) == sizeof(From));\n+  STATIC_ASSERT(sizeof(uintptr_t) == sizeof(To));\n+  return reinterpret_cast<To>(reinterpret_cast<uintptr_t>(from));\n+#endif\n+}\n+\n+\/\/ From is a pointer.\n+template <typename To, typename From,\n+          ENABLE_IF(sizeof(To) == sizeof(From) &&\n+                    !std::is_same<From, To>::value &&\n+                    std::is_pointer<From>::value &&\n+                    !std::is_pointer<To>::value)>\n+inline To bit_cast(const From& from) {\n+#if HAS_BUILTIN(__builtin_bit_cast) && !defined(__APPLE__)\n+  return __builtin_bit_cast(To, from);\n+#else\n+  STATIC_ASSERT(sizeof(uintptr_t) == sizeof(From));\n+  return bit_cast<To>(reinterpret_cast<uintptr_t>(from));\n+#endif\n+}\n+\n+\/\/ To is a pointer.\n+template <typename To, typename From,\n+          ENABLE_IF(sizeof(To) == sizeof(From) &&\n+                    !std::is_same<From, To>::value &&\n+                    !std::is_pointer<From>::value &&\n+                    std::is_pointer<To>::value)>\n+inline To bit_cast(const From& from) {\n+#if HAS_BUILTIN(__builtin_bit_cast) && !defined(__APPLE__)\n+  return __builtin_bit_cast(To, from);\n+#else\n+  STATIC_ASSERT(sizeof(uintptr_t) == sizeof(To));\n+  return reinterpret_cast<To>(bit_cast<uintptr_t>(from));\n+#endif\n+}\n+\n+\/\/ From or To is floating point.\n+template <typename To, typename From,\n+          ENABLE_IF(sizeof(To) == sizeof(From) &&\n+                    !std::is_same<From, To>::value &&\n+                    (std::is_floating_point<From>::value || std::is_floating_point<To>::value))>\n+inline To bit_cast(const From& from) {\n+#if HAS_BUILTIN(__builtin_bit_cast) && !defined(__APPLE__)\n+  return __builtin_bit_cast(To, from);\n+#else\n+  \/\/ Use the union trick. The union trick is technically UB, but is\n+  \/\/ widely and well supported, producing good code. In some cases,\n+  \/\/ such as gcc, that support is explicitly documented. Using memcpy\n+  \/\/ is the correct method, but some compilers produce wretched code\n+  \/\/ for that method, even at maximal optimization levels. Neither\n+  \/\/ the union trick nor memcpy provides constexpr support.\n+  union {\n+    From from;\n+    To to;\n+  } converter = { from };\n+  return converter.to;\n+#endif\n+}\n+\n+\/\/ Everything else not handled above.\n+template <typename To, typename From,\n+          ENABLE_IF(sizeof(To) == sizeof(From) &&\n+                    !std::is_same<From, To>::value &&\n+                    std::is_trivially_copyable<To>::value &&\n+                    std::is_trivially_copyable<From>::value &&\n+                    std::is_default_constructible<To>::value &&\n+                    !std::is_integral<From>::value &&\n+                    !std::is_enum<From>::value &&\n+                    !std::is_pointer<From>::value &&\n+                    !std::is_floating_point<From>::value &&\n+                    !std::is_integral<To>::value &&\n+                    !std::is_enum<To>::value &&\n+                    !std::is_pointer<To>::value &&\n+                    !std::is_floating_point<To>::value)>\n+inline To bit_cast(const From& from) {\n+#if HAS_BUILTIN(__builtin_bit_cast) && !defined(__APPLE__)\n+  return __builtin_bit_cast(To, from);\n+#else\n+  \/\/ Most modern compilers will produce optimal code for memcpy.\n+  To to;\n+  std::memcpy(&to, &from, sizeof(To));\n+  return to;\n+#endif\n+}\n+\n+#endif  \/\/ SHARE_UTILITIES_BIT_CAST_HPP\n","filename":"src\/hotspot\/share\/utilities\/bitCast.hpp","additions":198,"deletions":0,"binary":false,"changes":198,"status":"added"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"utilities\/bitCast.hpp\"\n@@ -144,2 +145,2 @@\n-                                        V start = PrimitiveConversions::cast<V>(_start),\n-                                        V end = PrimitiveConversions::cast<V>(_end)) {\n+                                        V start = bit_cast<V>(_start),\n+                                        V end = bit_cast<V>(_end)) {\n","filename":"src\/hotspot\/share\/utilities\/enumIterator.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"utilities\/bitCast.hpp\"\n@@ -177,1 +178,1 @@\n-  return (intptr_t) p;\n+  return bit_cast<intptr_t>(p);\n@@ -455,2 +456,2 @@\n-inline address       set_address_bits(address x, int m)       { return address(intptr_t(x) | m); }\n-inline address       clear_address_bits(address x, int m)     { return address(intptr_t(x) & ~m); }\n+inline address       set_address_bits(address x, int m)       { return bit_cast<address>(bit_cast<intptr_t>(x) | m); }\n+inline address       clear_address_bits(address x, int m)     { return bit_cast<address>(bit_cast<intptr_t>(x) & ~m); }\n@@ -460,3 +461,3 @@\n-inline address_word  mask_address_bits(address x, int m)      { return address_word(x) & m; }\n-inline address_word  castable_address(address x)              { return address_word(x) ; }\n-inline address_word  castable_address(void* x)                { return address_word(x) ; }\n+inline address_word  mask_address_bits(address x, int m)      { return bit_cast<address_word>(x) & m; }\n+inline address_word  castable_address(address x)              { return bit_cast<address_word>(x) ; }\n+inline address_word  castable_address(void* x)                { return bit_cast<address_word>(x) ; }\n@@ -479,1 +480,1 @@\n-  return (((uintptr_t) left) - ((uintptr_t) right)) \/ element_size;\n+  return (bit_cast<uintptr_t>(left) - bit_cast<uintptr_t>(right)) \/ element_size;\n@@ -662,4 +663,0 @@\n-typedef union {\n-  jfloat f;\n-  jint i;\n-} FloatIntConv;\n@@ -667,5 +664,2 @@\n-typedef union {\n-  jdouble d;\n-  jlong l;\n-  julong ul;\n-} DoubleLongConv;\n+inline jint    jint_cast    (jfloat  x)  { return bit_cast<jint>(x); }\n+inline jfloat  jfloat_cast  (jint    x)  { return bit_cast<jfloat>(x); }\n@@ -673,6 +667,3 @@\n-inline jint    jint_cast    (jfloat  x)  { return ((FloatIntConv*)&x)->i; }\n-inline jfloat  jfloat_cast  (jint    x)  { return ((FloatIntConv*)&x)->f; }\n-\n-inline jlong   jlong_cast   (jdouble x)  { return ((DoubleLongConv*)&x)->l;  }\n-inline julong  julong_cast  (jdouble x)  { return ((DoubleLongConv*)&x)->ul; }\n-inline jdouble jdouble_cast (jlong   x)  { return ((DoubleLongConv*)&x)->d;  }\n+inline jlong   jlong_cast   (jdouble x)  { return bit_cast<jlong>(x);  }\n+inline julong  julong_cast  (jdouble x)  { return bit_cast<julong>(x); }\n+inline jdouble jdouble_cast (jlong   x)  { return bit_cast<jdouble>(x);  }\n@@ -1055,1 +1046,1 @@\n-#define       badAddress        ((address)::badAddressVal)\n+#define       badAddress        (::bit_cast<address>(::badAddressVal))\n@@ -1155,1 +1146,1 @@\n-  return (address)to - (address)from;\n+  return bit_cast<address>(to) - bit_cast<address>(from);\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":15,"deletions":24,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -638,0 +638,7 @@\n+\/\/ Macro which can be used to detect the availability of builtins. Supports GCC 10+ and Clang.\n+#ifdef __has_builtin\n+#define HAS_BUILTIN(x) __has_builtin(x)\n+#else\n+#define HAS_BUILTIN(x) 0\n+#endif\n+\n","filename":"src\/hotspot\/share\/utilities\/macros.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n-#include \"memory\/allocation.hpp\"\n-#include \"metaprogramming\/isSame.hpp\"\n@@ -30,144 +28,0 @@\n-#include \"utilities\/debug.hpp\"\n-\n-struct PrimitiveConversionsTestSupport: AllStatic {\n-\n-  template<size_t byte_size> struct SignedTypeOfSize;\n-  template<size_t byte_size> struct UnsignedTypeOfSize;\n-\n-  template<typename T> struct Signed;\n-  template<typename T> struct Unsigned;\n-};\n-\n-#define DEFINE_CANONICAL_SIGNED_TYPE(T)                                 \\\n-  template<>                                                            \\\n-  struct PrimitiveConversionsTestSupport::SignedTypeOfSize<sizeof(T)>   \\\n-    : public AllStatic                                                  \\\n-  {                                                                     \\\n-    typedef T type;                                                     \\\n-  };\n-\n-#define DEFINE_CANONICAL_UNSIGNED_TYPE(T)                               \\\n-  template<>                                                            \\\n-  struct PrimitiveConversionsTestSupport::UnsignedTypeOfSize<sizeof(T)> \\\n-    : public AllStatic                                                  \\\n-  {                                                                     \\\n-    typedef T type;                                                     \\\n-  };\n-\n-#define DEFINE_INTEGER_TYPES_OF_SIZE(NBITS)            \\\n-  DEFINE_CANONICAL_SIGNED_TYPE(int ## NBITS ## _t)     \\\n-  DEFINE_CANONICAL_UNSIGNED_TYPE(uint ## NBITS ## _t)\n-\n-DEFINE_INTEGER_TYPES_OF_SIZE(8)\n-DEFINE_INTEGER_TYPES_OF_SIZE(16)\n-DEFINE_INTEGER_TYPES_OF_SIZE(32)\n-DEFINE_INTEGER_TYPES_OF_SIZE(64)\n-\n-#undef DEFINE_INTEGER_TYPES_OF_SIZE\n-#undef DEFINE_CANONICAL_SIGNED_TYPE\n-#undef DEFINE_CANONICAL_UNSIGNED_TYPE\n-\n-template<typename T>\n-struct PrimitiveConversionsTestSupport::Signed\n-  : public SignedTypeOfSize<sizeof(T)>\n-{};\n-\n-template<typename T>\n-struct PrimitiveConversionsTestSupport::Unsigned\n-  : public UnsignedTypeOfSize<sizeof(T)>\n-{};\n-\n-TEST(PrimitiveConversionsTest, round_trip_int) {\n-  int  sfive = 5;\n-  int  mfive = -5;\n-  uint ufive = 5u;\n-\n-  typedef PrimitiveConversionsTestSupport::Signed<int>::type SI;\n-  typedef PrimitiveConversionsTestSupport::Unsigned<int>::type UI;\n-\n-  EXPECT_EQ(sfive, PrimitiveConversions::cast<int>(PrimitiveConversions::cast<SI>(sfive)));\n-  EXPECT_EQ(sfive, PrimitiveConversions::cast<int>(PrimitiveConversions::cast<UI>(sfive)));\n-\n-  EXPECT_EQ(mfive, PrimitiveConversions::cast<int>(PrimitiveConversions::cast<SI>(mfive)));\n-  EXPECT_EQ(mfive, PrimitiveConversions::cast<int>(PrimitiveConversions::cast<UI>(mfive)));\n-\n-  EXPECT_EQ(ufive, PrimitiveConversions::cast<uint>(PrimitiveConversions::cast<SI>(ufive)));\n-  EXPECT_EQ(ufive, PrimitiveConversions::cast<uint>(PrimitiveConversions::cast<UI>(ufive)));\n-}\n-\n-TEST(PrimitiveConversionsTest, round_trip_int_constexpr) {\n-  constexpr int  sfive = 5;\n-  constexpr int  mfive = -5;\n-  constexpr uint ufive = 5u;\n-\n-  typedef PrimitiveConversionsTestSupport::Signed<int>::type SI;\n-  typedef PrimitiveConversionsTestSupport::Unsigned<int>::type UI;\n-\n-  {\n-    constexpr SI i = PrimitiveConversions::cast<SI>(sfive);\n-    constexpr int r = PrimitiveConversions::cast<int>(i);\n-    EXPECT_EQ(sfive, r);\n-  }\n-\n-  {\n-    constexpr UI i = PrimitiveConversions::cast<UI>(sfive);\n-    constexpr int r = PrimitiveConversions::cast<int>(i);\n-    EXPECT_EQ(sfive, r);\n-  }\n-\n-  {\n-    constexpr SI i = PrimitiveConversions::cast<SI>(mfive);\n-    constexpr int r = PrimitiveConversions::cast<int>(i);\n-    EXPECT_EQ(mfive, r);\n-  }\n-\n-  {\n-    constexpr UI i = PrimitiveConversions::cast<UI>(mfive);\n-    constexpr int r = PrimitiveConversions::cast<int>(i);\n-    EXPECT_EQ(mfive, r);\n-  }\n-\n-  {\n-    constexpr SI i = PrimitiveConversions::cast<SI>(ufive);\n-    constexpr uint r = PrimitiveConversions::cast<uint>(i);\n-    EXPECT_EQ(ufive, r);\n-  }\n-\n-  {\n-    constexpr UI i = PrimitiveConversions::cast<UI>(ufive);\n-    constexpr uint r = PrimitiveConversions::cast<uint>(i);\n-    EXPECT_EQ(ufive, r);\n-  }\n-}\n-\n-TEST(PrimitiveConversionsTest, round_trip_float) {\n-  float  ffive = 5.0f;\n-  double dfive = 5.0;\n-\n-  typedef PrimitiveConversionsTestSupport::Signed<float>::type SF;\n-  typedef PrimitiveConversionsTestSupport::Unsigned<float>::type UF;\n-\n-  typedef PrimitiveConversionsTestSupport::Signed<double>::type SD;\n-  typedef PrimitiveConversionsTestSupport::Unsigned<double>::type UD;\n-\n-  EXPECT_EQ(ffive, PrimitiveConversions::cast<float>(PrimitiveConversions::cast<SF>(ffive)));\n-  EXPECT_EQ(ffive, PrimitiveConversions::cast<float>(PrimitiveConversions::cast<UF>(ffive)));\n-\n-  EXPECT_EQ(dfive, PrimitiveConversions::cast<double>(PrimitiveConversions::cast<SD>(dfive)));\n-  EXPECT_EQ(dfive, PrimitiveConversions::cast<double>(PrimitiveConversions::cast<UD>(dfive)));\n-}\n-\n-TEST(PrimitiveConversionsTest, round_trip_ptr) {\n-  int five = 5;\n-  int* pfive = &five;\n-  const int* cpfive = &five;\n-\n-  typedef PrimitiveConversionsTestSupport::Signed<int*>::type SIP;\n-  typedef PrimitiveConversionsTestSupport::Unsigned<int*>::type UIP;\n-\n-  EXPECT_EQ(pfive, PrimitiveConversions::cast<int*>(PrimitiveConversions::cast<SIP>(pfive)));\n-  EXPECT_EQ(pfive, PrimitiveConversions::cast<int*>(PrimitiveConversions::cast<UIP>(pfive)));\n-\n-  EXPECT_EQ(cpfive, PrimitiveConversions::cast<const int*>(PrimitiveConversions::cast<SIP>(cpfive)));\n-  EXPECT_EQ(cpfive, PrimitiveConversions::cast<const int*>(PrimitiveConversions::cast<UIP>(cpfive)));\n-}\n","filename":"test\/hotspot\/gtest\/metaprogramming\/test_primitiveConversions.cpp","additions":0,"deletions":146,"binary":false,"changes":146,"status":"modified"},{"patch":"@@ -0,0 +1,159 @@\n+\/*\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"memory\/allStatic.hpp\"\n+#include \"utilities\/bitCast.hpp\"\n+#include \"unittest.hpp\"\n+\n+TEST(BitCast, round_trip_int) {\n+  int  sfive = 5;\n+  int  mfive = -5;\n+  uint ufive = 5u;\n+\n+  using SI = signed int;\n+  using UI = unsigned int;\n+\n+  EXPECT_EQ(sfive, bit_cast<int>(bit_cast<SI>(sfive)));\n+  EXPECT_EQ(sfive, bit_cast<int>(bit_cast<UI>(sfive)));\n+\n+  EXPECT_EQ(mfive, bit_cast<int>(bit_cast<SI>(mfive)));\n+  EXPECT_EQ(mfive, bit_cast<int>(bit_cast<UI>(mfive)));\n+\n+  EXPECT_EQ(ufive, bit_cast<uint>(bit_cast<SI>(ufive)));\n+  EXPECT_EQ(ufive, bit_cast<uint>(bit_cast<UI>(ufive)));\n+}\n+\n+TEST(BitCast, round_trip_int_constexpr) {\n+  constexpr int  sfive = 5;\n+  constexpr int  mfive = -5;\n+  constexpr uint ufive = 5u;\n+\n+  using SI = signed int;\n+  using UI = unsigned int;\n+\n+  {\n+    constexpr SI i = bit_cast<SI>(sfive);\n+    constexpr int r = bit_cast<int>(i);\n+    EXPECT_EQ(sfive, r);\n+  }\n+\n+  {\n+    constexpr UI i = bit_cast<UI>(sfive);\n+    constexpr int r = bit_cast<int>(i);\n+    EXPECT_EQ(sfive, r);\n+  }\n+\n+  {\n+    constexpr SI i = bit_cast<SI>(mfive);\n+    constexpr int r = bit_cast<int>(i);\n+    EXPECT_EQ(mfive, r);\n+  }\n+\n+  {\n+    constexpr UI i = bit_cast<UI>(mfive);\n+    constexpr int r = bit_cast<int>(i);\n+    EXPECT_EQ(mfive, r);\n+  }\n+\n+  {\n+    constexpr SI i = bit_cast<SI>(ufive);\n+    constexpr uint r = bit_cast<uint>(i);\n+    EXPECT_EQ(ufive, r);\n+  }\n+\n+  {\n+    constexpr UI i = bit_cast<UI>(ufive);\n+    constexpr uint r = bit_cast<uint>(i);\n+    EXPECT_EQ(ufive, r);\n+  }\n+}\n+\n+TEST(BitCast, round_trip_float) {\n+  float  ffive = 5.0f;\n+  double dfive = 5.0;\n+\n+  using SF = int32_t;\n+  using UF = uint32_t;\n+\n+  using SD = int64_t;\n+  using UD = uint64_t;\n+\n+  EXPECT_EQ(ffive, bit_cast<float>(bit_cast<SF>(ffive)));\n+  EXPECT_EQ(ffive, bit_cast<float>(bit_cast<UF>(ffive)));\n+\n+  EXPECT_EQ(dfive, bit_cast<double>(bit_cast<SD>(dfive)));\n+  EXPECT_EQ(dfive, bit_cast<double>(bit_cast<UD>(dfive)));\n+}\n+\n+TEST(BitCast, round_trip_ptr) {\n+  int five = 5;\n+  int* pfive = &five;\n+  const int* cpfive = &five;\n+\n+  using SIP = intptr_t;\n+  using UIP = uintptr_t;\n+\n+  EXPECT_EQ(pfive, bit_cast<int*>(bit_cast<SIP>(pfive)));\n+  EXPECT_EQ(pfive, bit_cast<int*>(bit_cast<UIP>(pfive)));\n+\n+  EXPECT_EQ(cpfive, bit_cast<const int*>(bit_cast<SIP>(cpfive)));\n+  EXPECT_EQ(cpfive, bit_cast<const int*>(bit_cast<UIP>(cpfive)));\n+}\n+\n+TEST(BitCast, round_trip_const_ptr) {\n+  int five = 5;\n+  int* pfive = &five;\n+  const int* cpfive = &five;\n+\n+  EXPECT_EQ(pfive, bit_cast<int*>(cpfive));\n+  EXPECT_EQ(cpfive, bit_cast<const int*>(pfive));\n+}\n+\n+TEST(BitCast, round_trip_volatile_ptr) {\n+  int five = 5;\n+  int* pfive = &five;\n+  volatile int* vpfive = &five;\n+\n+  EXPECT_EQ(pfive, bit_cast<int*>(vpfive));\n+  EXPECT_EQ(vpfive, bit_cast<volatile int*>(pfive));\n+}\n+\n+class BitCastTest : public AllStatic {\n+ public:\n+  struct TrivialStruct1 {\n+    int member;\n+  };\n+\n+  struct TrivialStruct2 {\n+    int member;\n+  };\n+};\n+\n+TEST(BitCast, round_trip_trivial_struct) {\n+  BitCastTest::TrivialStruct1 s1 = {5};\n+  BitCastTest::TrivialStruct2 s2 = bit_cast<BitCastTest::TrivialStruct2>(s1);\n+  EXPECT_EQ(s1.member, s2.member);\n+}\n","filename":"test\/hotspot\/gtest\/utilities\/test_bitCast.cpp","additions":159,"deletions":0,"binary":false,"changes":159,"status":"added"}]}