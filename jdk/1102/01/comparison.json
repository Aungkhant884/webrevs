{"files":[{"patch":"@@ -244,1 +244,1 @@\n-      memcpy(new_block->words(), block->words(), sizeof(uint32_t) * words_per_block);\n+      memcpy(new_block->words(), block->words(), sizeof(uintptr_t) * words_per_block);\n","filename":"src\/hotspot\/share\/opto\/indexSet.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -63,3 +63,6 @@\n-  enum { bit_index_length = 5,\n-         word_index_length = 3,\n-         block_index_length = 8 \/\/ not used\n+  enum {\n+         \/\/ Each block consists of 256 bits\n+         block_index_length = 8,\n+         \/\/ Split over 4 or 8 words depending on bitness\n+         word_index_length  = block_index_length - LogBitsPerWord,\n+         bit_index_length   = block_index_length - word_index_length,\n@@ -91,1 +94,1 @@\n-    return mask_bits(element,bit_index_mask);\n+    return mask_bits(element, bit_index_mask);\n@@ -105,1 +108,1 @@\n-    \/\/ A BitBlock is composed of some number of 32 bit words.  When a BitBlock\n+    \/\/ A BitBlock is composed of some number of 32- or 64-bit words.  When a BitBlock\n@@ -107,1 +110,1 @@\n-    \/\/ is used by IndexSet to mainting this free list.\n+    \/\/ is used by IndexSet to maintain this free list.\n@@ -110,1 +113,1 @@\n-      uint32_t _words[words_per_block];\n+      uintptr_t _words[words_per_block];\n@@ -115,1 +118,1 @@\n-    uint32_t* words() { return _data._words; }\n+    uintptr_t* words() { return _data._words; }\n@@ -124,1 +127,1 @@\n-      memset(words(), 0, sizeof(uint32_t) * words_per_block);\n+      memset(words(), 0, sizeof(uintptr_t) * words_per_block);\n@@ -129,1 +132,1 @@\n-      uint bit_index = IndexSet::get_bit_index(element);\n+      uintptr_t bit_index = IndexSet::get_bit_index(element);\n@@ -131,1 +134,1 @@\n-      return ((words()[word_index] & (uint32_t)(0x1 << bit_index)) != 0);\n+      return ((words()[word_index] & (uintptr_t(1) << bit_index)) != 0);\n@@ -136,1 +139,1 @@\n-      uint bit_index = IndexSet::get_bit_index(element);\n+      uintptr_t bit_index = IndexSet::get_bit_index(element);\n@@ -138,2 +141,2 @@\n-      uint32_t bit = (0x1 << bit_index);\n-      uint32_t before = words()[word_index];\n+      uintptr_t bit = uintptr_t(1) << bit_index;\n+      uintptr_t before = words()[word_index];\n@@ -146,1 +149,1 @@\n-      uint bit_index = IndexSet::get_bit_index(element);\n+      uintptr_t bit_index = IndexSet::get_bit_index(element);\n@@ -148,2 +151,2 @@\n-      uint32_t bit = (0x1 << bit_index);\n-      uint32_t before = words()[word_index];\n+      uintptr_t bit = uintptr_t(1) << bit_index;\n+      uintptr_t before = words()[word_index];\n@@ -379,1 +382,1 @@\n-  uint32_t              _current;\n+  uintptr_t             _current;\n@@ -394,1 +397,1 @@\n-  uint32_t             *_words;\n+  uintptr_t*            _words;\n@@ -450,1 +453,1 @@\n-    uint current = _current;\n+    uintptr_t current = _current;\n","filename":"src\/hotspot\/share\/opto\/indexSet.hpp","additions":23,"deletions":20,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -35,2 +35,0 @@\n-#define RM_SIZE _RM_SIZE \/* a constant private to the class RegMask *\/\n-\n@@ -68,11 +66,11 @@\n-    switch(ireg) {\n-      case Op_VecZ:\n-        return SlotsPerVecZ;\n-      case Op_VecY:\n-        return SlotsPerVecY;\n-      case Op_VecX:\n-        return SlotsPerVecX;\n-      case Op_VecD:\n-        return SlotsPerVecD;\n-      case Op_RegD:\n-      case Op_RegL:\n+  switch(ireg) {\n+    case Op_VecZ:\n+      return SlotsPerVecZ;\n+    case Op_VecY:\n+      return SlotsPerVecY;\n+    case Op_VecX:\n+      return SlotsPerVecX;\n+    case Op_VecD:\n+      return SlotsPerVecD;\n+    case Op_RegD:\n+    case Op_RegL:\n@@ -80,1 +78,1 @@\n-      case Op_RegP:\n+    case Op_RegP:\n@@ -82,7 +80,9 @@\n-        return 2;\n-      case Op_VecA:\n-        assert(Matcher::supports_scalable_vector(), \"does not support scalable vector\");\n-        return SlotsPerVecA;\n-    }\n-    \/\/ Op_VecS and the rest ideal registers.\n-    return 1;\n+      return 2;\n+    case Op_VecA:\n+      assert(Matcher::supports_scalable_vector(), \"does not support scalable vector\");\n+      return SlotsPerVecA;\n+    default:\n+      \/\/ Op_VecS and the rest ideal registers.\n+      assert(ireg == Op_VecS || !is_vector(ireg), \"unexpected, possibly multi-slot register\");\n+      return 1;\n+  }\n@@ -104,0 +104,11 @@\n+static const uintptr_t zero  = uintptr_t(0);  \/\/ 0x00..00\n+static const uintptr_t all   = ~uintptr_t(0);  \/\/ 0xFF..FF\n+static const uintptr_t fives = all\/3;        \/\/ 0x5555..55\n+\n+\/\/ only indices of power 2 are accessed, so index 3 is only filled in for storage.\n+static const uintptr_t low_bits[5] = { fives, \/\/ 0x5555..55\n+                                       all\/0xF,        \/\/ 0x1111..11,\n+                                       all\/0xFF,       \/\/ 0x0101..01,\n+                                       zero,           \/\/ 0x0000..00\n+                                       all\/0xFFFF };   \/\/ 0x0001..01\n+\n@@ -107,5 +118,5 @@\n-  for (int i = _lwm; i <= _hwm; i++) {\n-    int bits = _A[i];\n-    bits &= ((bits & 0x55555555)<<1); \/\/ 1 hi-bit set for each pair\n-    bits |= (bits>>1);          \/\/ Smear 1 hi-bit into a pair\n-    _A[i] = bits;\n+  for (unsigned i = _lwm; i <= _hwm; i++) {\n+    uintptr_t bits = _RM_UP[i];\n+    bits &= ((bits & fives) << 1U); \/\/ 1 hi-bit set for each pair\n+    bits |= (bits >> 1U);          \/\/ Smear 1 hi-bit into a pair\n+    _RM_UP[i] = bits;\n@@ -123,2 +134,2 @@\n-  for (int i = _lwm; i <= _hwm; i++) {\n-    int bits = _A[i];\n+  for (unsigned i = _lwm; i <= _hwm; i++) {\n+    uintptr_t bits = _RM_UP[i];\n@@ -126,1 +137,1 @@\n-      int bit = bits & -bits;   \/\/ Extract low bit\n+      uintptr_t bit = uintptr_t(1) << find_lowest_bit(bits); \/\/ Extract low bit\n@@ -128,1 +139,1 @@\n-      if ((bit & 0x55555555) == 0) return false;\n+      if ((bit & fives) == 0) return false;\n@@ -131,2 +142,2 @@\n-      if ((bits & (bit<<1)) == 0) return false;\n-      bits -= (bit<<1);         \/\/ Remove other halve of pair\n+      if ((bits & (bit << 1U)) == 0) return false;\n+      bits -= (bit << 1U); \/\/ Remove other halve of pair\n@@ -147,1 +158,1 @@\n-  int bit = -1;                 \/\/ Set to hold the one bit allowed\n+  uintptr_t bit = all;               \/\/ Set to hold the one bit allowed\n@@ -149,6 +160,6 @@\n-  for (int i = _lwm; i <= _hwm; i++) {\n-    if (_A[i]) {                   \/\/ Found some bits\n-      if (bit != -1) return false; \/\/ Already had bits, so fail\n-      bit = _A[i] & -(_A[i]);      \/\/ Extract 1 bit from mask\n-      if ((bit << 1) != 0) {       \/\/ Bit pair stays in same word?\n-        if ((bit | (bit<<1)) != _A[i])\n+  for (unsigned i = _lwm; i <= _hwm; i++) {\n+    if (_RM_UP[i]) {               \/\/ Found some bits\n+      if (bit != all) return false; \/\/ Already had bits, so fail\n+      bit = uintptr_t(1) << find_lowest_bit(_RM_UP[i]); \/\/ Extract lowest bit from mask\n+      if ((bit << 1U) != 0) {      \/\/ Bit pair stays in same word?\n+        if ((bit | (bit << 1U)) != _RM_UP[i])\n@@ -157,1 +168,1 @@\n-        if(bit != _A[i]) return false; \/\/ Found many bits, so fail\n+        if (bit != _RM_UP[i]) return false; \/\/ Found many bits, so fail\n@@ -159,1 +170,1 @@\n-        if (i > _hwm || _A[i] != 1)\n+        if (i > _hwm || _RM_UP[i] != 1)\n@@ -189,3 +200,0 @@\n-\/\/ only indicies of power 2 are accessed, so index 3 is only filled in for storage.\n-static int low_bits[5] = { 0x55555555, 0x11111111, 0x01010101, 0x00000000, 0x00010001 };\n-\n@@ -203,2 +211,2 @@\n-  for (int i = _lwm; i <= _hwm; i++) {\n-    if (_A[i]) {                \/\/ Found some bits\n+  for (unsigned i = _lwm; i <= _hwm; i++) {\n+    if (_RM_UP[i]) {                \/\/ Found some bits\n@@ -206,1 +214,1 @@\n-      return OptoReg::Name((i<<_LogWordBits) + find_lowest_bit(_A[i]) + (size - 1));\n+      return OptoReg::Name((i<<_LogWordBits) + find_lowest_bit(_RM_UP[i]) + (size - 1));\n@@ -213,1 +221,1 @@\n-void RegMask::clear_to_sets(const int size) {\n+void RegMask::clear_to_sets(const unsigned int size) {\n@@ -218,6 +226,6 @@\n-  int low_bits_mask = low_bits[size>>2];\n-  for (int i = _lwm; i <= _hwm; i++) {\n-    int bits = _A[i];\n-    int sets = (bits & low_bits_mask);\n-    for (int j = 1; j < size; j++) {\n-      sets = (bits & (sets<<1)); \/\/ filter bits which produce whole sets\n+  uintptr_t low_bits_mask = low_bits[size >> 2U];\n+  for (unsigned i = _lwm; i <= _hwm; i++) {\n+    uintptr_t bits = _RM_UP[i];\n+    uintptr_t sets = (bits & low_bits_mask);\n+    for (unsigned j = 1U; j < size; j++) {\n+      sets = (bits & (sets << 1U)); \/\/ filter bits which produce whole sets\n@@ -225,1 +233,1 @@\n-    sets |= (sets>>1);           \/\/ Smear 1 hi-bit into a set\n+    sets |= (sets >> 1U);           \/\/ Smear 1 hi-bit into a set\n@@ -227,1 +235,1 @@\n-      sets |= (sets>>2);         \/\/ Smear 2 hi-bits into a set\n+      sets |= (sets >> 2U);         \/\/ Smear 2 hi-bits into a set\n@@ -229,1 +237,1 @@\n-        sets |= (sets>>4);       \/\/ Smear 4 hi-bits into a set\n+        sets |= (sets >> 4U);       \/\/ Smear 4 hi-bits into a set\n@@ -231,1 +239,1 @@\n-          sets |= (sets>>8);     \/\/ Smear 8 hi-bits into a set\n+          sets |= (sets >> 8U);     \/\/ Smear 8 hi-bits into a set\n@@ -235,1 +243,1 @@\n-    _A[i] = sets;\n+    _RM_UP[i] = sets;\n@@ -241,1 +249,1 @@\n-void RegMask::smear_to_sets(const int size) {\n+void RegMask::smear_to_sets(const unsigned int size) {\n@@ -246,5 +254,5 @@\n-  int low_bits_mask = low_bits[size>>2];\n-  for (int i = _lwm; i <= _hwm; i++) {\n-    int bits = _A[i];\n-    int sets = 0;\n-    for (int j = 0; j < size; j++) {\n+  uintptr_t low_bits_mask = low_bits[size >> 2U];\n+  for (unsigned i = _lwm; i <= _hwm; i++) {\n+    uintptr_t bits = _RM_UP[i];\n+    uintptr_t sets = 0;\n+    for (unsigned j = 0; j < size; j++) {\n@@ -252,1 +260,1 @@\n-      bits  = bits>>1;\n+      bits  = bits >> 1U;\n@@ -254,1 +262,1 @@\n-    sets |= (sets<<1);           \/\/ Smear 1 lo-bit  into a set\n+    sets |= (sets << 1U);           \/\/ Smear 1 lo-bit  into a set\n@@ -256,1 +264,1 @@\n-      sets |= (sets<<2);         \/\/ Smear 2 lo-bits into a set\n+      sets |= (sets << 2U);         \/\/ Smear 2 lo-bits into a set\n@@ -258,1 +266,1 @@\n-        sets |= (sets<<4);       \/\/ Smear 4 lo-bits into a set\n+        sets |= (sets << 4U);       \/\/ Smear 4 lo-bits into a set\n@@ -260,1 +268,1 @@\n-          sets |= (sets<<8);     \/\/ Smear 8 lo-bits into a set\n+          sets |= (sets << 8U);     \/\/ Smear 8 lo-bits into a set\n@@ -264,1 +272,1 @@\n-    _A[i] = sets;\n+    _RM_UP[i] = sets;\n@@ -270,1 +278,1 @@\n-bool RegMask::is_aligned_sets(const int size) const {\n+bool RegMask::is_aligned_sets(const unsigned int size) const {\n@@ -274,1 +282,1 @@\n-  int low_bits_mask = low_bits[size>>2];\n+  uintptr_t low_bits_mask = low_bits[size >> 2U];\n@@ -276,2 +284,2 @@\n-  for (int i = _lwm; i <= _hwm; i++) {\n-    int bits = _A[i];\n+  for (unsigned i = _lwm; i <= _hwm; i++) {\n+    uintptr_t bits = _RM_UP[i];\n@@ -279,1 +287,1 @@\n-      int bit = bits & -bits;   \/\/ Extract low bit\n+      uintptr_t bit = uintptr_t(1) << find_lowest_bit(bits);\n@@ -285,2 +293,2 @@\n-      int hi_bit = bit << (size-1); \/\/ high bit\n-      int set = hi_bit + ((hi_bit-1) & ~(bit-1));\n+      uintptr_t hi_bit = bit << (size-1); \/\/ high bit\n+      uintptr_t set = hi_bit + ((hi_bit-1) & ~(bit-1));\n@@ -299,1 +307,1 @@\n-int RegMask::is_bound_set(const int size) const {\n+bool RegMask::is_bound_set(const unsigned int size) const {\n@@ -303,7 +311,8 @@\n-  int bit = -1;                 \/\/ Set to hold the one bit allowed\n-  for (int i = _lwm; i <= _hwm; i++) {\n-    if (_A[i] ) {               \/\/ Found some bits\n-      if (bit != -1)\n-       return false;            \/\/ Already had bits, so fail\n-      bit = _A[i] & -_A[i];     \/\/ Extract low bit from mask\n-      int hi_bit = bit << (size-1); \/\/ high bit\n+  uintptr_t bit = all;         \/\/ Set to hold the one bit allowed\n+  for (unsigned i = _lwm; i <= _hwm; i++) {\n+    if (_RM_UP[i] ) {           \/\/ Found some bits\n+      if (bit != all)\n+        return false;           \/\/ Already had bits, so fail\n+      unsigned bit_index = find_lowest_bit(_RM_UP[i]);\n+      bit = uintptr_t(1) << bit_index;\n+      uintptr_t hi_bit = bit << (size - 1); \/\/ high bit\n@@ -311,2 +320,2 @@\n-        int set = hi_bit + ((hi_bit-1) & ~(bit-1));\n-        if (set != _A[i])\n+        uintptr_t set = hi_bit + ((hi_bit-1) & ~(bit-1));\n+        if (set != _RM_UP[i])\n@@ -315,1 +324,1 @@\n-        if (((-1) & ~(bit-1)) != _A[i])\n+        if ((all & ~(bit-1)) != _RM_UP[i])\n@@ -318,7 +327,3 @@\n-        \/\/ The lower (32-size) bits should be 0 since it is split case.\n-        int clear_bit_size = 32-size;\n-        int shift_back_size = 32-clear_bit_size;\n-        int set = bit>>clear_bit_size;\n-        set = set & -set; \/\/ Remove sign extension.\n-        set = (((set << size) - 1) >> shift_back_size);\n-        if (i > _hwm || _A[i] != set)\n+        \/\/ The lower (BitsPerWord - size) bits should be 1 since it is split case.\n+        uintptr_t set = (bit >> (BitsPerWord - bit_index)) - 1;\n+        if (i > _hwm || _RM_UP[i] != set)\n@@ -349,2 +354,2 @@\n-  for (int i = _lwm; i <= _hwm; i++) {\n-    sum += population_count((unsigned)_A[i]);\n+  for (unsigned i = _lwm; i <= _hwm; i++) {\n+    sum += population_count(_RM_UP[i]);\n","filename":"src\/hotspot\/share\/opto\/regmask.cpp","additions":103,"deletions":98,"binary":false,"changes":201,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-static int find_lowest_bit(uint32_t mask) {\n+static unsigned int find_lowest_bit(uintptr_t mask) {\n@@ -41,2 +41,2 @@\n-static int find_highest_bit(uint32_t mask) {\n-  return count_leading_zeros(mask) ^ 31;\n+static unsigned int find_highest_bit(uintptr_t mask) {\n+  return count_leading_zeros(mask) ^ (BitsPerWord - 1U);\n@@ -51,1 +51,1 @@\n-\/\/ RM_SIZE is the size of a register mask in words.\n+\/\/ RM_SIZE is the size of a register mask in 32-bit words.\n@@ -58,0 +58,7 @@\n+\n+  enum {\n+    _WordBits    = BitsPerWord,\n+    _LogWordBits = LogBitsPerWord,\n+    _RM_SIZE     = LP64_ONLY(align_up(RM_SIZE, 2) >> 1) NOT_LP64(RM_SIZE)\n+  };\n+\n@@ -59,1 +66,0 @@\n-    double _dummy_force_double_alignment[RM_SIZE>>1];\n@@ -65,1 +71,2 @@\n-    int _A[RM_SIZE];\n+    int       _RM_I[RM_SIZE];\n+    uintptr_t _RM_UP[_RM_SIZE];\n@@ -67,0 +74,1 @@\n+\n@@ -71,8 +79,2 @@\n-  int _lwm;\n-  int _hwm;\n-\n-  enum {\n-    _WordBits    = BitsPerInt,\n-    _LogWordBits = LogBitsPerInt,\n-    _RM_SIZE     = RM_SIZE   \/\/ local constant, imported, then hidden by #undef\n-  };\n+  unsigned int _lwm;\n+  unsigned int _hwm;\n@@ -81,1 +83,1 @@\n-  enum { CHUNK_SIZE = RM_SIZE*_WordBits };\n+  enum { CHUNK_SIZE = RM_SIZE*BitsPerInt };\n@@ -111,1 +113,1 @@\n-#   define BODY(I) _A[I] = a##I;\n+#   define BODY(I) _RM_I[I] = a##I;\n@@ -115,3 +117,3 @@\n-    _hwm = RM_SIZE - 1;\n-    while (_hwm > 0 && _A[_hwm] == 0) _hwm--;\n-    while ((_lwm < _hwm) && _A[_lwm] == 0) _lwm++;\n+    _hwm = _RM_SIZE - 1;\n+    while (_hwm > 0      && _RM_UP[_hwm] == 0) _hwm--;\n+    while ((_lwm < _hwm) && _RM_UP[_lwm] == 0) _lwm++;\n@@ -125,2 +127,2 @@\n-    for (int i = 0; i < RM_SIZE; i++) {\n-      _A[i] = rm->_A[i];\n+    for (unsigned i = 0; i < _RM_SIZE; i++) {\n+      _RM_UP[i] = rm->_RM_UP[i];\n@@ -132,3 +134,1 @@\n-  RegMask() {\n-    Clear();\n-  }\n+  RegMask() : _RM_UP(), _lwm(_RM_SIZE - 1), _hwm(0) {}\n@@ -137,2 +137,1 @@\n-  RegMask(OptoReg::Name reg) {\n-    Clear();\n+  RegMask(OptoReg::Name reg) : RegMask() {\n@@ -143,1 +142,1 @@\n-  int Member(OptoReg::Name reg) const {\n+  bool Member(OptoReg::Name reg) const {\n@@ -145,1 +144,3 @@\n-    return _A[reg>>_LogWordBits] & (1<<(reg&(_WordBits-1)));\n+\n+    unsigned r = (unsigned)reg;\n+    return _RM_UP[r >> _LogWordBits] & (uintptr_t(1) <<(r & (_WordBits - 1U)));\n@@ -151,8 +152,2 @@\n-  int is_AllStack() const { return _A[RM_SIZE-1] >> (_WordBits-1); }\n-\n-  \/\/ Work around an -xO3 optimization problme in WS6U1. The old way:\n-  \/\/   void set_AllStack() { _A[RM_SIZE-1] |= (1<<(_WordBits-1)); }\n-  \/\/ will cause _A[RM_SIZE-1] to be clobbered, not updated when set_AllStack()\n-  \/\/ follows an Insert() loop, like the one found in init_spill_mask(). Using\n-  \/\/ Insert() instead works because the index into _A in computed instead of\n-  \/\/ constant.  See bug 4665841.\n+  bool is_AllStack() const { return _RM_UP[_RM_SIZE - 1U] >> (_WordBits - 1U); }\n+\n@@ -162,1 +157,1 @@\n-  int is_NotEmpty() const {\n+  bool is_NotEmpty() const {\n@@ -164,3 +159,3 @@\n-    int tmp = 0;\n-    for (int i = _lwm; i <= _hwm; i++) {\n-      tmp |= _A[i];\n+    uintptr_t tmp = 0;\n+    for (unsigned i = _lwm; i <= _hwm; i++) {\n+      tmp |= _RM_UP[i];\n@@ -174,2 +169,2 @@\n-    for (int i = _lwm; i <= _hwm; i++) {\n-      int bits = _A[i];\n+    for (unsigned i = _lwm; i <= _hwm; i++) {\n+      uintptr_t bits = _RM_UP[i];\n@@ -186,2 +181,4 @@\n-    for (int i = _hwm; i >= _lwm; i--) {\n-      int bits = _A[i];\n+    \/\/ Careful not to overflow if _lwm == 0\n+    unsigned i = _hwm + 1;\n+    while (i > _lwm) {\n+      uintptr_t bits = _RM_UP[--i];\n@@ -202,4 +199,4 @@\n-    assert(_hwm >= 0 && _hwm < RM_SIZE, \"_hwm out of range: %d\", _hwm);\n-    assert(_lwm >= 0 && _lwm < RM_SIZE, \"_lwm out of range: %d\", _lwm);\n-    for (int i = 0; i < _lwm; i++) {\n-      assert(_A[i] == 0, \"_lwm too high: %d regs at: %d\", _lwm, i);\n+    assert(_hwm < _RM_SIZE, \"_hwm out of range: %d\", _hwm);\n+    assert(_lwm < _RM_SIZE, \"_lwm out of range: %d\", _lwm);\n+    for (unsigned i = 0; i < _lwm; i++) {\n+      assert(_RM_UP[i] == 0, \"_lwm too high: %d regs at: %d\", _lwm, i);\n@@ -207,2 +204,2 @@\n-    for (int i = _hwm + 1; i < RM_SIZE; i++) {\n-      assert(_A[i] == 0, \"_hwm too low: %d regs at: %d\", _hwm, i);\n+    for (unsigned i = _hwm + 1; i < _RM_SIZE; i++) {\n+      assert(_RM_UP[i] == 0, \"_hwm too low: %d regs at: %d\", _hwm, i);\n@@ -236,1 +233,1 @@\n-  void clear_to_sets(const int size);\n+  void clear_to_sets(const unsigned int size);\n@@ -238,1 +235,1 @@\n-  void smear_to_sets(const int size);\n+  void smear_to_sets(const unsigned int size);\n@@ -240,1 +237,1 @@\n-  bool is_aligned_sets(const int size) const;\n+  bool is_aligned_sets(const unsigned int size) const;\n@@ -243,1 +240,1 @@\n-  int is_bound_set(const int size) const;\n+  bool is_bound_set(const unsigned int size) const;\n@@ -250,1 +247,1 @@\n-  int overlap(const RegMask &rm) const {\n+  bool overlap(const RegMask &rm) const {\n@@ -252,5 +249,5 @@\n-    int hwm = MIN2(_hwm, rm._hwm);\n-    int lwm = MAX2(_lwm, rm._lwm);\n-    int result = 0;\n-    for (int i = lwm; i <= hwm; i++) {\n-      result |= _A[i] & rm._A[i];\n+    unsigned hwm = MIN2(_hwm, rm._hwm);\n+    unsigned lwm = MAX2(_lwm, rm._lwm);\n+    uintptr_t result = 0;\n+    for (unsigned i = lwm; i <= hwm; i++) {\n+      result |= _RM_UP[i] & rm._RM_UP[i];\n@@ -267,1 +264,1 @@\n-    _lwm = RM_SIZE - 1;\n+    _lwm = _RM_SIZE - 1;\n@@ -269,1 +266,1 @@\n-    memset(_A, 0, sizeof(int)*RM_SIZE);\n+    memset(_RM_UP, 0, sizeof(uintptr_t)*_RM_SIZE);\n@@ -276,2 +273,2 @@\n-    _hwm = RM_SIZE - 1;\n-    memset(_A, 0xFF, sizeof(int)*RM_SIZE);\n+    _hwm = _RM_SIZE - 1;\n+    memset(_RM_UP, 0xFF, sizeof(uintptr_t)*_RM_SIZE);\n@@ -283,0 +280,2 @@\n+    assert(reg != OptoReg::Bad, \"sanity\");\n+    assert(reg != OptoReg::Special, \"sanity\");\n@@ -285,1 +284,2 @@\n-    int index = reg>>_LogWordBits;\n+    unsigned r = (unsigned)reg;\n+    unsigned index = r >> _LogWordBits;\n@@ -288,1 +288,1 @@\n-    _A[index] |= (1<<(reg&(_WordBits-1)));\n+    _RM_UP[index] |= (uintptr_t(1) << (r & (_WordBits - 1U)));\n@@ -295,1 +295,2 @@\n-    _A[reg>>_LogWordBits] &= ~(1<<(reg&(_WordBits-1)));\n+    unsigned r = (unsigned)reg;\n+    _RM_UP[r >> _LogWordBits] &= ~(uintptr_t(1) << (r & (_WordBits-1U)));\n@@ -304,2 +305,2 @@\n-    for (int i = _lwm; i <= _hwm; i++) {\n-      _A[i] |= rm._A[i];\n+    for (unsigned i = _lwm; i <= _hwm; i++) {\n+      _RM_UP[i] |= rm._RM_UP[i];\n@@ -315,2 +316,2 @@\n-    for (int i = _lwm; i <= _hwm; i++) {\n-      _A[i] &= rm._A[i];\n+    for (unsigned i = _lwm; i <= _hwm; i++) {\n+      _RM_UP[i] &= rm._RM_UP[i];\n@@ -327,4 +328,4 @@\n-    int hwm = MIN2(_hwm, rm._hwm);\n-    int lwm = MAX2(_lwm, rm._lwm);\n-    for (int i = lwm; i <= hwm; i++) {\n-      _A[i] &= ~rm._A[i];\n+    unsigned hwm = MIN2(_hwm, rm._hwm);\n+    unsigned lwm = MAX2(_lwm, rm._lwm);\n+    for (unsigned i = lwm; i <= hwm; i++) {\n+      _RM_UP[i] &= ~rm._RM_UP[i];\n","filename":"src\/hotspot\/share\/opto\/regmask.hpp","additions":76,"deletions":75,"binary":false,"changes":151,"status":"modified"},{"patch":"@@ -0,0 +1,249 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.vm.compiler.overhead;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.Arrays;\n+\n+\/**\n+ * The purpose of these microbenchmarks is to use RepeatCompilation\n+ * to produce a benchmark that focuses on the overhead of various JIT\n+ * compilations themselves.\n+ *\/\n+\n+@State(Scope.Benchmark)\n+@BenchmarkMode(Mode.SingleShotTime)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@Fork(value = 10, warmups = 1)\n+public class SimpleRepeatCompilation {\n+\n+    public static final String MIXHASH_METHOD\n+     = \"-XX:CompileCommand=option,org\/openjdk\/bench\/vm\/compiler\/overhead\/SimpleRepeatCompilation.mixHashCode,intx,RepeatCompilation,500\";\n+\n+    @Benchmark\n+    @Fork(jvmArgsAppend={\"-Xbatch\", MIXHASH_METHOD})\n+    public int mixHashCode_repeat() {\n+        return loop_hashCode();\n+    }\n+\n+    @Benchmark\n+    @Fork(jvmArgsAppend={\"-Xbatch\", \"-XX:-TieredCompilation\", MIXHASH_METHOD})\n+    public int mixHashCode_repeat_c2() {\n+        return loop_hashCode();\n+    }\n+\n+    @Benchmark\n+    @Fork(jvmArgsAppend={\"-Xbatch\", \"-XX:TieredStopAtLevel=1\", MIXHASH_METHOD})\n+    public int mixHashCode_repeat_c1() {\n+        return loop_hashCode();\n+    }\n+\n+    @Benchmark\n+    @Fork(jvmArgsAppend={\"-Xbatch\"})\n+    public int mixHashCode_baseline() {\n+        return loop_hashCode();\n+    }\n+\n+    public int loop_hashCode() {\n+        int value = 0;\n+        for (int i = 0; i < 1_000_000; i++) {\n+            value += mixHashCode(\"simple_string\");\n+        }\n+        return value;\n+    }\n+\n+    public int mixHashCode(String value) {\n+        int h = value.hashCode();\n+        for (int i = 0; i < value.length(); i++) {\n+            h = value.charAt(i) ^ h;\n+        }\n+        return h;\n+    }\n+\n+    public static final String TRIVIAL_MATH_METHOD\n+     = \"-XX:CompileCommand=option,org\/openjdk\/bench\/vm\/compiler\/overhead\/SimpleRepeatCompilation.trivialMath,intx,RepeatCompilation,2000\";\n+\n+    @Benchmark\n+    @Fork(jvmArgsAppend={\"-Xbatch\",TRIVIAL_MATH_METHOD})\n+    public int trivialMath_repeat() {\n+        return loop_trivialMath();\n+    }\n+\n+    @Benchmark\n+    @Fork(jvmArgsAppend={\"-Xbatch\", \"-XX:-TieredCompilation\", TRIVIAL_MATH_METHOD})\n+    public int trivialMath_repeat_c2() {\n+        return loop_trivialMath();\n+    }\n+\n+    @Benchmark\n+    @Fork(jvmArgsAppend={\"-Xbatch\", \"-XX:TieredStopAtLevel=1\", TRIVIAL_MATH_METHOD})\n+    public int trivialMath_repeat_c1() {\n+        return loop_trivialMath();\n+    }\n+\n+    @Benchmark\n+    @Fork(jvmArgsAppend={\"-Xbatch\"})\n+    public int trivialMath_baseline() {\n+        return loop_trivialMath();\n+    }\n+\n+    public int loop_trivialMath() {\n+        int value = 0;\n+        for (int i = 0; i < 1_000_000; i++) {\n+            value += trivialMath(i, i - 1);\n+        }\n+        return value;\n+    }\n+\n+    public int trivialMath(int a, int b) {\n+        return a * b + a;\n+    }\n+\n+\n+    public static final String LARGE_METHOD\n+     = \"-XX:CompileCommand=option,org\/openjdk\/bench\/vm\/compiler\/overhead\/SimpleRepeatCompilation.largeMethod,intx,RepeatCompilation,100\";\n+\n+    @Benchmark\n+    @Fork(jvmArgsAppend={\"-Xbatch\",LARGE_METHOD})\n+    public int largeMethod_repeat() {\n+        return loop_largeMethod();\n+    }\n+\n+    @Benchmark\n+    @Fork(jvmArgsAppend={\"-Xbatch\", \"-XX:-TieredCompilation\", LARGE_METHOD})\n+    public int largeMethod_repeat_c2() {\n+        return loop_largeMethod();\n+    }\n+\n+    @Benchmark\n+    @Fork(jvmArgsAppend={\"-Xbatch\", \"-XX:TieredStopAtLevel=1\", LARGE_METHOD})\n+    public int largeMethod_repeat_c1() {\n+        return loop_largeMethod();\n+    }\n+\n+    @Benchmark\n+    @Fork(jvmArgsAppend={\"-Xbatch\"})\n+    public int largeMethod_baseline() {\n+        return loop_largeMethod();\n+    }\n+\n+    public int loop_largeMethod() {\n+        int value = 0;\n+        for (int i = 0; i < 50_000; i++) {\n+            value += largeMethod(i, i - 1);\n+        }\n+        return value;\n+    }\n+\n+    \/\/ Meaningless but largish method with plenty of locals\n+    \/\/ to put more stress on register allocation\n+    public int largeMethod(int a, int b) {\n+        int c = b + 17;\n+        int d = a + b + 6;\n+        int e = c + d + 99;\n+        int f = d + e + 919;\n+        long val = 0;\n+        for (int i = 0; i < 2; i++) {\n+            for (int j = 0; j < 2; j++) {\n+                for (int k = 0; k < 2; k++) {\n+                    a -= b;\n+                    b += c;\n+                    c -= d;\n+                    d += e;\n+                    e -= a;\n+                    val = a - b + c - d + e - f;\n+                }\n+            }\n+        }\n+        int g = b;\n+        int h = a;\n+        int l = c;\n+        int m = d;\n+        int n = d;\n+        for (int i = 0; i < 2; i++) {\n+            for (int j = 0; j < 2; j++) {\n+                for (int k = 0; k < 2; k++) {\n+                    g += b;\n+                    h -= c;\n+                    l += d;\n+                    m -= e;\n+                    e += a;\n+                    val = g + h + l + m + n;\n+                }\n+            }\n+        }\n+        for (int i = 0; i < 2; i++) {\n+            for (int j = 0; j < 2; j++) {\n+                for (int k = 0; k < 2; k++) {\n+                    a -= b;\n+                    b += c;\n+                    c -= d;\n+                    d += e;\n+                    e -= a;\n+                    val = a - b - c - d - e - f;\n+                }\n+            }\n+        }\n+        int o = b;\n+        int p = a;\n+        int q = c;\n+        int r = d;\n+        int s = d;\n+        for (int i = 0; i < 2; i++) {\n+            for (int j = 0; j < 2; j++) {\n+                for (int k = 0; k < 2; k++) {\n+                    o += b;\n+                    p += c;\n+                    q += d;\n+                    r += e;\n+                    s += a;\n+                    val = o + p + q + r + s;\n+                }\n+            }\n+        }\n+        for (int i = 0; i < 2; i++) {\n+            for (int j = 0; j < 2; j++) {\n+                for (int k = 0; k < 2; k++) {\n+                    g += b;\n+                    h -= c;\n+                    l += d;\n+                    m -= e;\n+                    e += a;\n+                    val = g + h + l + m + n;\n+                }\n+            }\n+        }\n+        return (int)(val ^ (val >> 32L));\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/overhead\/SimpleRepeatCompilation.java","additions":249,"deletions":0,"binary":false,"changes":249,"status":"added"}]}