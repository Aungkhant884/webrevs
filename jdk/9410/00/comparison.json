{"files":[{"patch":"@@ -306,0 +306,14 @@\n+    \/*\n+     * Let l = log_2(10).\n+     * Then, L < l < L + ulp(L) \/ 2, that is, L = roundTiesToEven(l).\n+     *\/\n+    private static final double L = 3.321928094887362;\n+\n+    private static final int P_F = Float.PRECISION;  \/\/ 24\n+    private static final int Q_MIN_F = Float.MIN_EXPONENT - (P_F - 1);  \/\/ -149\n+    private static final int Q_MAX_F = Float.MAX_EXPONENT - (P_F - 1);  \/\/ 104\n+\n+    private static final int P_D = Double.PRECISION;  \/\/ 53\n+    private static final int Q_MIN_D = (Double.MIN_EXPONENT - (P_D - 1));  \/\/ -1_074\n+    private static final int Q_MAX_D = (Double.MAX_EXPONENT - (P_D - 1));  \/\/ 971\n+\n@@ -3735,2 +3749,4 @@\n-    public float floatValue(){\n-        if(intCompact != INFLATED) {\n+    public float floatValue() {\n+        \/* For details, see the extensive comments in doubleValue(). *\/\n+        if (intCompact != INFLATED) {\n+            float v = intCompact;\n@@ -3738,17 +3754,13 @@\n-                return (float)intCompact;\n-            } else {\n-                \/*\n-                 * If both intCompact and the scale can be exactly\n-                 * represented as float values, perform a single float\n-                 * multiply or divide to compute the (properly\n-                 * rounded) result.\n-                 *\/\n-                if (Math.abs(intCompact) < 1L<<22 ) {\n-                    \/\/ Don't have too guard against\n-                    \/\/ Math.abs(MIN_VALUE) because of outer check\n-                    \/\/ against INFLATED.\n-                    if (scale > 0 && scale < FLOAT_10_POW.length) {\n-                        return (float)intCompact \/ FLOAT_10_POW[scale];\n-                    } else if (scale < 0 && scale > -FLOAT_10_POW.length) {\n-                        return (float)intCompact * FLOAT_10_POW[-scale];\n-                    }\n+                return v;\n+            }\n+            \/*\n+             * The discussion for the double case also applies here. That is,\n+             * the following test is precise for all long values except for\n+             * Long.MAX_VALUE but the result is correct nevertheless.\n+             *\/\n+            if ((long) v == intCompact) {\n+                if (0 < scale && scale < FLOAT_10_POW.length) {\n+                    return v \/ FLOAT_10_POW[scale];\n+                }\n+                if (0 > scale && scale > -FLOAT_10_POW.length) {\n+                    return v * FLOAT_10_POW[-scale];\n@@ -3758,2 +3770,42 @@\n-        \/\/ Somewhat inefficient, but guaranteed to work.\n-        return Float.parseFloat(this.toString());\n+        return fullFloatValue();\n+    }\n+\n+    private float fullFloatValue() {\n+        if (intCompact == 0) {\n+            return 0.0f;\n+        }\n+        BigInteger d = unscaledValue().abs();\n+        long qb = d.bitLength() - (long) Math.ceil(scale * L);\n+        if (qb < Q_MIN_F - 2) {  \/\/ qb < -151\n+            return signum() * 0.0f;\n+        }\n+        if (qb > Q_MAX_F + P_F + 1) {  \/\/ qb > 129\n+            return signum() * Float.POSITIVE_INFINITY;\n+        }\n+        if (scale < 0) {\n+            return signum() * d.multiply(bigTenToThe(-scale)).floatValue();\n+        }\n+        if (scale == 0) {\n+            return signum() * d.floatValue();\n+        }\n+        int ql = (int) qb - (P_F + 3);\n+        BigInteger pow10 = bigTenToThe(scale);\n+        BigInteger m, n;\n+        if (ql <= 0) {\n+            m = d.shiftLeft(-ql);\n+            n = pow10;\n+        } else {\n+            m = d;\n+            n = pow10.shiftLeft(ql);\n+        }\n+        BigInteger[] qr = m.divideAndRemainder(n);\n+        int i = qr[0].intValue();\n+        int sb = qr[1].signum();\n+        int dq = (Integer.SIZE - (P_F + 2)) - Integer.numberOfLeadingZeros(i);\n+        int eq = (Q_MIN_F - 2) - ql;\n+        if (dq >= eq) {\n+            return signum() * Math.scalb((float) (i | sb), ql);\n+        }\n+        int mask = (1 << eq) - 1;\n+        int j = i >> eq | (Integer.signum(i & mask)) | sb;\n+        return signum() * Math.scalb((float) j, Q_MIN_F - 2);\n@@ -3780,2 +3832,7 @@\n-    public double doubleValue(){\n-        if(intCompact != INFLATED) {\n+    public double doubleValue() {\n+        \/*\n+         * Attempt a fast path when the significand is compact and the\n+         * scale is small enough.\n+         *\/\n+        if (intCompact != INFLATED) {\n+            double v = intCompact;\n@@ -3783,2 +3840,9 @@\n-                return (double)intCompact;\n-            } else {\n+                \/* v is the result of a single rounding. *\/\n+                return v;\n+            }\n+            \/*\n+             * The test (long) (double) l == l to check whether l is an exact\n+             * double is always accurate, except for l = Long.MAX_VALUE.\n+             * This special case is not an issue, though, as explained below.\n+             *\/\n+            if ((long) v == intCompact) {\n@@ -3786,4 +3850,9 @@\n-                 * If both intCompact and the scale can be exactly\n-                 * represented as double values, perform a single\n-                 * double multiply or divide to compute the (properly\n-                 * rounded) result.\n+                 * If intCompact != Long.MAX_VALUE, v is exactly equal to it\n+                 * and 10^|scale| is an exact double when 0 < |scale| <= 22.\n+                 * Hence, the multiplication or division below are on exact\n+                 * doubles, so the result is subject to a single rounding.\n+                 *\n+                 * If intCompact = Long.MAX_VALUE, v is not exactly equal to it.\n+                 * Luckily, when 0 < |scale| <= 22, full precision computations\n+                 * show that the end result as computed here is correct anyway,\n+                 * despite being the outcome of 2 roundings.\n@@ -3791,9 +3860,5 @@\n-                if (Math.abs(intCompact) < 1L<<52 ) {\n-                    \/\/ Don't have too guard against\n-                    \/\/ Math.abs(MIN_VALUE) because of outer check\n-                    \/\/ against INFLATED.\n-                    if (scale > 0 && scale < DOUBLE_10_POW.length) {\n-                        return (double)intCompact \/ DOUBLE_10_POW[scale];\n-                    } else if (scale < 0 && scale > -DOUBLE_10_POW.length) {\n-                        return (double)intCompact * DOUBLE_10_POW[-scale];\n-                    }\n+                if (0 < scale && scale < DOUBLE_10_POW.length) {\n+                    return v \/ DOUBLE_10_POW[scale];\n+                }\n+                if (0 > scale && scale > -DOUBLE_10_POW.length) {\n+                    return v * DOUBLE_10_POW[-scale];\n@@ -3803,2 +3868,215 @@\n-        \/\/ Somewhat inefficient, but guaranteed to work.\n-        return Double.parseDouble(this.toString());\n+        return fullDoubleValue();\n+    }\n+\n+    private double fullDoubleValue() {\n+        \/*\n+         * This method works on all instances but might throw or consume a lot\n+         * of memory and cpu on huge scales or huge significands.\n+         *\n+         * It is expected that this computations might exhaust memory or consume\n+         * an unreasonable amount of cpu when both the significand and the scale\n+         * are huge and conjure to meet MIN < |this| < MAX, where MIN and MAX\n+         * are approximately Double.MIN_VALUE and Double.MAX_VALUE, resp.\n+         *\/\n+        if (intCompact == 0) {\n+            return 0.0;\n+        }\n+\n+        \/*\n+         * Let\n+         *      d = |unscaledValue()|\n+         *      s = scale\n+         *      bl = d.bitLength()\n+         *      P = Double.PRECISION  \/\/ 53\n+         *      Q_MIN = Double.MIN_EXPONENT - (P - 1)  \/\/ -1_074\n+         *      Q_MAX = Double.MAX_EXPONENT - (P - 1)  \/\/ 971\n+         * Thus\n+         *      |this| = d 10^{-s}\n+         *      Double.MIN_VALUE = 2^Q_MIN\n+         *      Double.MAX_VALUE = (2^P - 1) 2^Q_MAX\n+         * Here d > 0, so 2^{bl-1} <= d < 2^bl, hence\n+         *      bl = floor(log_2(d)) + 1\n+         *\n+         * To determine the return value, it helps to define real beta\n+         * and integer q meeting\n+         *      d 10^{-s} = beta 2^q such that 2^{P+1} <= beta < 2^{P+2}\n+         * Note that floor(log_2(beta)) = P + 1.\n+         * The reason for having beta meet these inequalities rather than the\n+         * more \"natural\" 2^{P-1} <= beta < 2^P will become clearer below.\n+         * (They ensure that there's room for a \"round\" and a \"sticky\" bit.)\n+         *\n+         * Determining beta and q, however, requires costly computations.\n+         * Instead, try to quickly determine integer bounds ql, qh such that\n+         * ql <= q <= qh and with qh - ql as small as reasonably possible.\n+         * They help to quickly filter out most values that do not round\n+         * to a finite, non-zero double.\n+         *\n+         * To this end, let l = log_2(10). Then\n+         *      log_2(d) - s l = log_2(d 10^{-s}) = log_2(beta) + q\n+         * Mathematically, for any real x, y:\n+         *      floor(x) + floor(y) <= floor(x + y) <= floor(x) + floor(y) + 1\n+         *      floor(-x) = -ceil(x)\n+         * Therefore, remembering that\n+         *      floor(log_2(d)) = bl - 1 and floor(log_2(beta)) = P + 1\n+         * the above leads to\n+         *      bl - ceil(s l) - P - 2 <= q <= bl - ceil(s l) - P - 1\n+         *\n+         * However, ceil(s l) is still a purely mathematical quantity.\n+         * To determine computable bounds for it, let L = roundTiesToEven(l)\n+         * and let u = 2^{-P} (see the comment about constant L).\n+         * Let * denote multiplication on doubles, which is subject to errors.\n+         * Then, since all involved values are not subnormals, it follows that\n+         * (see any textbook on numerical algorithms):\n+         *      s * L = s l (1 + delta_1) (1 + delta_2) = s l (1 + theta)\n+         * where |delta_i| <= u, |theta| <= 2u \/ (1 - 2u) < 4u = 2^{2-P}\n+         * The delta_i account for the relative error of l and of *.\n+         * Note that s (the int scale) converts exactly as double.\n+         * Hence, as 3 < l < 4\n+         *      |s * L - s l| = |s| l |theta| < 2^31 4 2^{2-P} = 2^{-18} < 1\n+         * For reals x, y, |x - y| <= 1 entails |ceil(x) - ceil(y)| <= 1. Thus,\n+         *      ceil(s * L) - 1 <= ceil(s l) <= ceil(s * L) + 1\n+         *\n+         * Using these inequalities implies\n+         *      bl - ceil(s * L) - P - 3 <= q <= bl - ceil(s * L) - P\n+         * finally leading to the definitions\n+         *      qb = bl - ceil(s * L), ql = qb - P - 3, qh = qb - P\n+         * meeting\n+         *      ql <= q <= qh and qh - ql = 3, which is small enough.\n+         * Note that qb doesn't always fit in an int.\n+         *\n+         * To filter out most values that round to 0 or infinity, define\n+         *      ZCO = 1\/2 2^Q_MIN = 2^{Q_MIN-1}    (zero cutoff)\n+         *      ICO = (2^P - 1\/2) 2^Q_MAX    (infinity cutoff)\n+         * Return [+\/-]0 iff |this| <= ZCO, [+\/-]infinity iff |this| >= ICO.\n+         *\n+         * To play safely, whenever 2^{P+2} 2^qh <= ZCO then\n+         *      |this| = beta 2^q < 2^{P+2} 2^qh <= ZCO\n+         * Now, 2^{P+2} 2^qh <= ZCO means the same as P + 2 + qh < Q_MIN,\n+         * leading to\n+         *      if qb < Q_MIN - 2 then return [+\/-]0\n+         *\n+         * Similarly, whenever 2^{P+1} 2^ql >= 2^P 2^Q_MAX then\n+         *      |this| = beta 2^q >= 2^{P+1} 2^ql >= 2^P 2^Q_MAX > ICO\n+         * Here, 2^{P+1} 2^ql >= 2^P 2^Q_MAX is equivalent to ql + 2 > Q_MAX,\n+         * which entails\n+         *      if qb > Q_MAX + P + 1 then return [+\/-]infinity\n+         *\n+         * Observe that |s * L| <= 2^31 4 = 2^33, so\n+         *      (long) ceil(s * L) = ceil(s * L)\n+         * since all integers <= 2^P are exact doubles.\n+         *\/\n+        BigInteger d = unscaledValue().abs();\n+        long qb = d.bitLength() - (long) Math.ceil(scale * L);\n+        if (qb < Q_MIN_D - 2) {  \/\/ qb < -1_076\n+            return signum() * 0.0;\n+        }\n+        if (qb > Q_MAX_D + P_D + 1) {  \/\/ qb > 1_025\n+            \/* If s <= -309 then qb >= 1_027, so these cases all end up here. *\/\n+            return signum() * Double.POSITIVE_INFINITY;\n+        }\n+\n+        \/*\n+         * There's still a small chance to return [+\/-]0 or [+\/-]infinity.\n+         * But rather than chasing for specific cases, do the full computations.\n+         * Here, Q_MIN - 2 <= qb <= Q_MAX + P + 1\n+         *\/\n+        if (scale < 0) {\n+            \/*\n+             * Here -309 < s < 0, so d 10^{-s} is an integer: delegate to\n+             * BigInteger.doubleValue() without further ado.\n+             * Also, |this| < 10^309, so the integers involved are manageable.\n+             *\/\n+            return signum() * d.multiply(bigTenToThe(-scale)).doubleValue();\n+        }\n+        if (scale == 0) {\n+            return signum() * d.doubleValue();\n+        }\n+\n+        \/*\n+         * This last case has s > 0 and sometimes unmanageable large integers.\n+         * It is expected that these computations might exhaust memory or\n+         * consume an unreasonable amount of cpu when both d and s are huge.\n+         *\n+         * Assume a number eta >= 2^{P+1} and split it into i = floor(eta)\n+         * and f = eta - i. Thus i >= 2^{P+1} and 0 <= f < 1.\n+         * Define sb = 0 iff f = 0 and sb = 1 iff f > 0.\n+         * Let j = i | sb (| denotes bitwise \"or\").\n+         * j has at least P + 2 bits to accommodate P most significand bits\n+         * (msb), 1 rounding bit rb just to the right of them and 1 \"sticky\" bit\n+         * sb as its least significant bit, as depicted here:\n+         * eta = | P msb | rb | ... | lsb | bits of fraction f...\n+         * i   = | P msb | rb | ... | lsb |\n+         * j   = | P msb | rb | ... | sb  |\n+         * All the bits in eta, i and j to the left of lsb or sb are identical.\n+         * It's not hard to see that\n+         *      roundTiesToEven(eta) = roundTiesToEven(j)\n+         *\n+         * To apply the above, define\n+         *      eta = (d\/10^s) 2^{-ql}\n+         * which meets\n+         *      eta = (d\/10^s) 2^{-q} 2^{q-ql} = beta 2^{q-ql} = beta 2^dq\n+         * where dq = q - ql. Therefore, since ql <= q <= qh = ql + 3\n+         *      2^{P+1} <= eta < 2^{P+2}    iff q = ql\n+         *      2^{P+2} <= eta < 2^{P+3}    iff q = ql + 1\n+         *      2^{P+3} <= eta < 2^{P+4}    iff q = ql + 2\n+         *      2^{P+4} <= eta < 2^{P+5}    iff q = ql + 3\n+         * There are no other cases. The same holds for i = floor(eta),\n+         * which therefore fits in a long, as P + 5 < Long.SIZE:\n+         *      2^{P+1} <= i < 2^{P+2}      iff q = ql\n+         *      2^{P+2} <= i < 2^{P+3}      iff q = ql + 1\n+         *      2^{P+3} <= i < 2^{P+4}      iff q = ql + 2\n+         *      2^{P+4} <= i < 2^{P+5}      iff q = ql + 3\n+         * This shows dq = bitLength(i) - (P + 2).\n+         *\n+         * Let integer m = d 2^{-ql} if ql <= 0, or m = d if ql > 0 and\n+         * let integer n = 10^s if ql <= 0, or n = 10^s 2^ql if ql > 0.\n+         * It follows that eta = m\/n, i = m \/\/ n, (\/\/ is integer division)\n+         * and f = (m \\\\ n) \/ n (\\\\ is binary \"mod\" (remainder)).\n+         * Of course, f > 0 iff m \\\\ n > 0, hence sb = signum(m \\\\ n).\n+         *\n+         * If q >= Q_MIN - 2 then |this| is in the normal range or overflows.\n+         * With eq = Q_MIN - 2 - ql the condition is the same as dq >= eq.\n+         * Provided |this| = eta 2^ql does not overflow, it follows that\n+         *      roundTiesToEven(|this|) = roundTiesToEven(eta) 2^ql\n+         *          = roundTiesToEven(j) 2^ql = scalb((double) j, ql)\n+         * If |this| overflows, however, so does scalb((double) j, ql). Thus,\n+         * in either case\n+         *      roundTiesToEven(|this|) = scalb((double) j, ql)\n+         *\n+         * When q < Q_MIN - 2, that is, when dq < eq, |this| is in the\n+         * subnormal range. The integer j needs to be shortened to ensure that\n+         * the precision is gradually shortened for the final significand.\n+         *      |this| = eta 2^ql = (eta\/2^eq) 2^{Q_MIN-2}\n+         * Compare eta and i as depicted here\n+         * eta = | msb | eq lsb | bits of fraction f...\n+         * i   = | msb | eq lsb |\n+         * where there are eq least significant bits in the right section.\n+         * To obtain j in this case, shift i to the right by eq positions and\n+         * thereafter \"or\" its least significant bit with signum(eq lsb) and\n+         * with sb as defined above. This leads to\n+         *      roundTiesToEven(|this|) = scalb((double) j, Q_MIN - 2)\n+         *\/\n+        int ql = (int) qb - (P_D + 3);  \/\/ narrowing qb to an int is safe\n+        BigInteger pow10 = bigTenToThe(scale);\n+        BigInteger m, n;\n+        if (ql <= 0) {\n+            m = d.shiftLeft(-ql);\n+            n = pow10;\n+        } else {\n+            m = d;\n+            n = pow10.shiftLeft(ql);\n+        }\n+\n+        BigInteger[] qr = m.divideAndRemainder(n);\n+        long i = qr[0].longValue();\n+        int sb = qr[1].signum();\n+        int dq = (Long.SIZE - (P_D + 2)) - Long.numberOfLeadingZeros(i);\n+        int eq = (Q_MIN_D - 2) - ql;\n+        if (dq >= eq) {\n+            return signum() * Math.scalb((double) (i | sb), ql);\n+        }\n+\n+        \/* Subnormal *\/\n+        long mask = (1L << eq) - 1;\n+        long j = i >> eq | Long.signum(i & mask) | sb;\n+        return signum() * Math.scalb((double) j, Q_MIN_D - 2);\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigDecimal.java","additions":318,"deletions":40,"binary":false,"changes":358,"status":"modified"},{"patch":"@@ -0,0 +1,259 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8205592\n+ * @summary Verify {double, float}Value methods work\n+ * @library \/test\/lib\n+ * @key randomness\n+ * @build jdk.test.lib.RandomFactory\n+ * @run main DoubleFloatValueTests\n+ *\/\n+\n+import jdk.test.lib.RandomFactory;\n+\n+import java.math.BigDecimal;\n+import java.util.Random;\n+\n+public class DoubleFloatValueTests {\n+    private static final BigDecimal HALF = BigDecimal.valueOf(5, 1);\n+    private static final BigDecimal EPS = BigDecimal.valueOf(1, 10_000);\n+\n+    private static BigDecimal nextHalfUp(double v) {\n+        BigDecimal bv = new BigDecimal(v);\n+        BigDecimal ulp = new BigDecimal(Math.ulp(v));\n+        return bv.add(ulp.multiply(HALF));\n+    }\n+\n+    private static BigDecimal nextHalfDown(double v) {\n+        BigDecimal bv = new BigDecimal(v);\n+        BigDecimal ulp = new BigDecimal(v - Math.nextDown(v));\n+        return bv.subtract(ulp.multiply(HALF));\n+    }\n+\n+    private static BigDecimal nextHalfUp(float v) {\n+        BigDecimal bv = new BigDecimal(v);\n+        BigDecimal ulp = new BigDecimal(Math.ulp(v));\n+        return bv.add(ulp.multiply(HALF));\n+    }\n+\n+    private static BigDecimal nextHalfDown(float v) {\n+        BigDecimal bv = new BigDecimal(v);\n+        BigDecimal ulp = new BigDecimal(v - Math.nextDown(v));\n+        return bv.subtract(ulp.multiply(HALF));\n+    }\n+\n+    private static String toDecHexString(double v) {\n+        return v + \" (\" + Double.toHexString(v) + \")\";\n+    }\n+\n+    private static String toDecHexString(float v) {\n+        return v + \" (\" + Float.toHexString(v) + \")\";\n+    }\n+\n+    private static void checkDouble(BigDecimal bd, double exp) {\n+        double res = bd.doubleValue();\n+        if (exp != res ) {\n+            String message = \"Bad conversion: got \" + toDecHexString(res) +\n+                    \", expected \" + toDecHexString(exp);\n+            throw new RuntimeException(message);\n+        }\n+    }\n+\n+    private static void checkFloat(BigDecimal bv, float exp) {\n+        float res = bv.floatValue();\n+        if (exp != res ) {\n+            String message = \"Bad conversion: got \" + toDecHexString(res) +\n+                    \", expected \" + toDecHexString(exp);\n+            throw new RuntimeException(message);\n+        }\n+    }\n+\n+    private static boolean isOdd(int n) {\n+        return (n & 0x1) != 0;\n+    }\n+\n+    private static void testDoubleValueNearMinValue() {\n+        for (int n = 0; n < 100; ++n) {\n+            BigDecimal b = nextHalfUp(n * Double.MIN_VALUE);\n+            checkDouble(b, ((n + 1) \/ 2 * 2) * Double.MIN_VALUE);\n+            checkDouble(b.subtract(EPS), n * Double.MIN_VALUE);\n+            checkDouble(b.add(EPS), (n + 1) * Double.MIN_VALUE);\n+        }\n+    }\n+\n+    private static void testFloatValueNearMinValue() {\n+        for (int n = 0; n < 100; ++n) {\n+            BigDecimal b = nextHalfUp(n * Float.MIN_VALUE);\n+            checkFloat(b, ((n + 1) \/ 2 * 2) * Float.MIN_VALUE);\n+            checkFloat(b.subtract(EPS), n * Float.MIN_VALUE);\n+            checkFloat(b.add(EPS), (n + 1) * Float.MIN_VALUE);\n+        }\n+    }\n+\n+    private static void testDoubleValueNearMinNormal() {\n+        double v = Double.MIN_NORMAL;\n+        for (int n = 0; n < 100; ++n) {\n+            BigDecimal bv = nextHalfDown(v);\n+            checkDouble(bv, isOdd(n) ? Math.nextDown(v) : v);\n+            checkDouble(bv.subtract(EPS), Math.nextDown(v));\n+            checkDouble(bv.add(EPS), v);\n+            v = Math.nextDown(v);\n+        }\n+        v = Double.MIN_NORMAL;\n+        for (int n = 0; n < 100; ++n) {\n+            BigDecimal bv = nextHalfUp(v);\n+            checkDouble(bv, isOdd(n) ? Math.nextUp(v) : v);\n+            checkDouble(bv.subtract(EPS), v);\n+            checkDouble(bv.add(EPS), Math.nextUp(v));\n+            v = Math.nextUp(v);\n+        }\n+    }\n+\n+    private static void testFloatValueNearMinNormal() {\n+        float v = Float.MIN_NORMAL;\n+        for (int n = 0; n < 100; ++n) {\n+            BigDecimal bv = nextHalfDown(v);\n+            checkFloat(bv, isOdd(n) ? Math.nextDown(v) : v);\n+            checkFloat(bv.subtract(EPS), Math.nextDown(v));\n+            checkFloat(bv.add(EPS), v);\n+            v = Math.nextDown(v);\n+        }\n+        v = Float.MIN_NORMAL;\n+        for (int n = 0; n < 100; ++n) {\n+            BigDecimal bv = nextHalfUp(v);\n+            checkFloat(bv, isOdd(n) ? Math.nextUp(v) : v);\n+            checkFloat(bv.subtract(EPS), v);\n+            checkFloat(bv.add(EPS), Math.nextUp(v));\n+            v = Math.nextUp(v);\n+        }\n+    }\n+\n+    private static void testDoubleValueNearMaxValue() {\n+        double v = Double.MAX_VALUE;\n+        for (int n = 0; n < 100; ++n) {\n+            BigDecimal bv = nextHalfDown(v);\n+            checkDouble(bv, isOdd(n) ? v : Math.nextDown(v));\n+            checkDouble(bv.subtract(EPS), Math.nextDown(v));\n+            checkDouble(bv.add(EPS), v);\n+            v = Math.nextDown(v);\n+        }\n+        BigDecimal bv = nextHalfUp(Double.MAX_VALUE);\n+        checkDouble(bv, Double.POSITIVE_INFINITY);\n+        checkDouble(bv.subtract(EPS), Double.MAX_VALUE);\n+        checkDouble(bv.add(EPS), Double.POSITIVE_INFINITY);\n+    }\n+\n+    private static void testFloatValueNearMaxValue() {\n+        float v = Float.MAX_VALUE;\n+        for (int n = 0; n < 100; ++n) {\n+            BigDecimal bv = nextHalfDown(v);\n+            checkFloat(bv, isOdd(n) ? v : Math.nextDown(v));\n+            checkFloat(bv.subtract(EPS), Math.nextDown(v));\n+            checkFloat(bv.add(EPS), v);\n+            v = Math.nextDown(v);\n+        }\n+        BigDecimal bv = nextHalfUp(Float.MAX_VALUE);\n+        checkFloat(bv, Float.POSITIVE_INFINITY);\n+        checkFloat(bv.subtract(EPS), Float.MAX_VALUE);\n+        checkFloat(bv.add(EPS), Float.POSITIVE_INFINITY);\n+    }\n+\n+    private static void testDoubleValueRandom() {\n+        Random r = RandomFactory.getRandom();\n+        for (int i = 0; i < 10_000; ++i) {\n+            double v = r.nextDouble(-Double.MAX_VALUE, Double.MAX_VALUE);\n+            checkDouble(new BigDecimal(v), v);\n+        }\n+        for (int i = 0; i < 10_000; ++i) {\n+            double v = r.nextDouble(-1e9, 1e9);\n+            checkDouble(new BigDecimal(v), v);\n+        }\n+        for (int i = 0; i < 10_000; ++i) {\n+            double v = r.nextDouble(-1e6, 1e6);\n+            checkDouble(new BigDecimal(v), v);\n+        }\n+        for (int i = 0; i < 10_000; ++i) {\n+            double v = r.nextDouble(-1e-6, 1e-6);\n+            checkDouble(new BigDecimal(v), v);\n+        }\n+        for (int i = 0; i < 10_000; ++i) {\n+            double v = r.nextDouble(-1e-9, 1e-9);\n+            checkDouble(new BigDecimal(v), v);\n+        }\n+    }\n+\n+    private static void testFloatValueRandom() {\n+        Random r = RandomFactory.getRandom();\n+        for (int i = 0; i < 10_000; ++i) {\n+            float v = r.nextFloat(-Float.MAX_VALUE, Float.MAX_VALUE);\n+            checkFloat(new BigDecimal(v), v);\n+        }\n+        for (int i = 0; i < 10_000; ++i) {\n+            float v = r.nextFloat(-1e9f, 1e9f);\n+            checkFloat(new BigDecimal(v), v);\n+        }\n+        for (int i = 0; i < 10_000; ++i) {\n+            float v = r.nextFloat(-1e6f, 1e6f);\n+            checkFloat(new BigDecimal(v), v);\n+        }\n+        for (int i = 0; i < 10_000; ++i) {\n+            float v = r.nextFloat(-1e-6f, 1e-6f);\n+            checkFloat(new BigDecimal(v), v);\n+        }\n+        for (int i = 0; i < 10_000; ++i) {\n+            float v = r.nextFloat(-1e-9f, 1e-9f);\n+            checkFloat(new BigDecimal(v), v);\n+        }\n+    }\n+\n+    private static void testDoubleValueExtremes() {\n+        checkDouble(BigDecimal.valueOf(1, 1000), 0.0);\n+        checkDouble(BigDecimal.valueOf(-1, 1000), -0.0);\n+        checkDouble(BigDecimal.valueOf(1, -1000), Double.POSITIVE_INFINITY);\n+        checkDouble(BigDecimal.valueOf(-1, -1000), -Double.POSITIVE_INFINITY);\n+    }\n+\n+    private static void testFloatValueExtremes() {\n+        checkFloat(BigDecimal.valueOf(1, 1000), 0.0f);\n+        checkFloat(BigDecimal.valueOf(-1, 1000), -0.0f);\n+        checkFloat(BigDecimal.valueOf(1, -1000), Float.POSITIVE_INFINITY);\n+        checkFloat(BigDecimal.valueOf(-1, -1000), -Float.POSITIVE_INFINITY);\n+    }\n+\n+    public static void main(String[] args) {\n+        testDoubleValueNearMinValue();\n+        testDoubleValueNearMinNormal();\n+        testDoubleValueNearMaxValue();\n+        testDoubleValueRandom();\n+        testDoubleValueExtremes();\n+\n+        testFloatValueNearMinValue();\n+        testFloatValueNearMinNormal();\n+        testFloatValueNearMaxValue();\n+        testFloatValueRandom();\n+        testFloatValueExtremes();\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/math\/BigDecimal\/DoubleFloatValueTests.java","additions":259,"deletions":0,"binary":false,"changes":259,"status":"added"}]}