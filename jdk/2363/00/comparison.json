{"files":[{"patch":"@@ -243,1 +243,1 @@\n-            if (x.errno() == ENODATA)\n+            if (x.errno() == XATTR_NOT_FOUND)\n","filename":"src\/java.base\/linux\/classes\/sun\/nio\/fs\/LinuxDosFileAttributeView.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -108,21 +108,0 @@\n-    \/\/ returns true if extended attributes enabled on file system where given\n-    \/\/ file resides, returns false if disabled or unable to determine.\n-    private boolean isExtendedAttributesEnabled(UnixPath path) {\n-        int fd = -1;\n-        try {\n-            fd = path.openForAttributeAccess(false);\n-\n-            \/\/ fgetxattr returns size if called with size==0\n-            byte[] name = Util.toBytes(\"user.java\");\n-            LinuxNativeDispatcher.fgetxattr(fd, name, 0L, 0);\n-            return true;\n-        } catch (UnixException e) {\n-            \/\/ attribute does not exist\n-            if (e.errno() == UnixConstants.ENODATA)\n-                return true;\n-        } finally {\n-            UnixNativeDispatcher.close(fd);\n-        }\n-        return false;\n-    }\n-\n","filename":"src\/java.base\/linux\/classes\/sun\/nio\/fs\/LinuxFileStore.java","additions":0,"deletions":21,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-        LinuxUserDefinedFileAttributeView.copyExtendedAttributes(ofd, nfd);\n+        UnixUserDefinedFileAttributeView.copyExtendedAttributes(ofd, nfd);\n","filename":"src\/java.base\/linux\/classes\/sun\/nio\/fs\/LinuxFileSystem.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -72,55 +72,0 @@\n-    \/**\n-     * ssize_t fgetxattr(int filedes, const char *name, void *value, size_t size);\n-     *\/\n-    static int fgetxattr(int filedes, byte[] name, long valueAddress,\n-                         int valueLen) throws UnixException\n-    {\n-        NativeBuffer buffer = NativeBuffers.asNativeBuffer(name);\n-        try {\n-            return fgetxattr0(filedes, buffer.address(), valueAddress, valueLen);\n-        } finally {\n-            buffer.release();\n-        }\n-    }\n-\n-    private static native int fgetxattr0(int filedes, long nameAddress,\n-        long valueAddress, int valueLen) throws UnixException;\n-\n-    \/**\n-     *  fsetxattr(int filedes, const char *name, const void *value, size_t size, int flags);\n-     *\/\n-    static void fsetxattr(int filedes, byte[] name, long valueAddress,\n-        int valueLen) throws UnixException\n-    {\n-        NativeBuffer buffer = NativeBuffers.asNativeBuffer(name);\n-        try {\n-            fsetxattr0(filedes, buffer.address(), valueAddress, valueLen);\n-        } finally {\n-            buffer.release();\n-        }\n-    }\n-\n-    private static native void fsetxattr0(int filedes, long nameAddress,\n-        long valueAddress, int valueLen) throws UnixException;\n-\n-    \/**\n-     * fremovexattr(int filedes, const char *name);\n-     *\/\n-    static void fremovexattr(int filedes, byte[] name) throws UnixException {\n-        NativeBuffer buffer = NativeBuffers.asNativeBuffer(name);\n-        try {\n-            fremovexattr0(filedes, buffer.address());\n-        } finally {\n-            buffer.release();\n-        }\n-    }\n-\n-    private static native void fremovexattr0(int filedes, long nameAddress)\n-        throws UnixException;\n-\n-    \/**\n-     * size_t flistxattr(int filedes, const char *list, size_t size)\n-     *\/\n-    static native int flistxattr(int filedes, long listAddress, int size)\n-        throws UnixException;\n-\n","filename":"src\/java.base\/linux\/classes\/sun\/nio\/fs\/LinuxNativeDispatcher.java","additions":0,"deletions":55,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -28,13 +28,0 @@\n-import java.nio.file.*;\n-import java.nio.ByteBuffer;\n-import java.io.IOException;\n-import java.util.*;\n-import jdk.internal.misc.Unsafe;\n-\n-import static sun.nio.fs.UnixConstants.*;\n-import static sun.nio.fs.LinuxNativeDispatcher.*;\n-\n-\/**\n- * Linux implementation of UserDefinedFileAttributeView using extended attributes.\n- *\/\n-\n@@ -42,1 +29,1 @@\n-    extends AbstractUserDefinedFileAttributeView\n+    extends UnixUserDefinedFileAttributeView\n@@ -44,45 +31,0 @@\n-    private static final Unsafe unsafe = Unsafe.getUnsafe();\n-\n-    \/\/ namespace for extended user attributes\n-    private static final String USER_NAMESPACE = \"user.\";\n-\n-    \/\/ maximum bytes in extended attribute name (includes namespace)\n-    private static final int XATTR_NAME_MAX = 255;\n-\n-    private byte[] nameAsBytes(UnixPath file, String name) throws IOException {\n-        if (name == null)\n-            throw new NullPointerException(\"'name' is null\");\n-        name = USER_NAMESPACE + name;\n-        byte[] bytes = Util.toBytes(name);\n-        if (bytes.length > XATTR_NAME_MAX) {\n-            throw new FileSystemException(file.getPathForExceptionMessage(),\n-                null, \"'\" + name + \"' is too big\");\n-        }\n-        return bytes;\n-    }\n-\n-    \/\/ Parses buffer as array of NULL-terminated C strings.\n-    private List<String> asList(long address, int size) {\n-        List<String> list = new ArrayList<>();\n-        int start = 0;\n-        int pos = 0;\n-        while (pos < size) {\n-            if (unsafe.getByte(address + pos) == 0) {\n-                int len = pos - start;\n-                byte[] value = new byte[len];\n-                unsafe.copyMemory(null, address+start, value,\n-                    Unsafe.ARRAY_BYTE_BASE_OFFSET, len);\n-                String s = Util.toString(value);\n-                if (s.startsWith(USER_NAMESPACE)) {\n-                    s = s.substring(USER_NAMESPACE.length());\n-                    list.add(s);\n-                }\n-                start = pos + 1;\n-            }\n-            pos++;\n-        }\n-        return list;\n-    }\n-\n-    private final UnixPath file;\n-    private final boolean followLinks;\n@@ -91,127 +33,1 @@\n-        this.file = file;\n-        this.followLinks = followLinks;\n-    }\n-\n-    @Override\n-    public List<String> list() throws IOException  {\n-        if (System.getSecurityManager() != null)\n-            checkAccess(file.getPathForPermissionCheck(), true, false);\n-\n-        int fd = -1;\n-        try {\n-            fd = file.openForAttributeAccess(followLinks);\n-        } catch (UnixException x) {\n-            x.rethrowAsIOException(file);\n-        }\n-        NativeBuffer buffer = null;\n-        try {\n-            int size = 1024;\n-            buffer = NativeBuffers.getNativeBuffer(size);\n-            for (;;) {\n-                try {\n-                    int n = flistxattr(fd, buffer.address(), size);\n-                    List<String> list = asList(buffer.address(), n);\n-                    return Collections.unmodifiableList(list);\n-                } catch (UnixException x) {\n-                    \/\/ allocate larger buffer if required\n-                    if (x.errno() == ERANGE && size < 32*1024) {\n-                        buffer.release();\n-                        size *= 2;\n-                        buffer = null;\n-                        buffer = NativeBuffers.getNativeBuffer(size);\n-                        continue;\n-                    }\n-                    throw new FileSystemException(file.getPathForExceptionMessage(),\n-                        null, \"Unable to get list of extended attributes: \" +\n-                        x.getMessage());\n-                }\n-            }\n-        } finally {\n-            if (buffer != null)\n-                buffer.release();\n-            close(fd);\n-        }\n-    }\n-\n-    @Override\n-    public int size(String name) throws IOException  {\n-        if (System.getSecurityManager() != null)\n-            checkAccess(file.getPathForPermissionCheck(), true, false);\n-\n-        int fd = -1;\n-        try {\n-            fd = file.openForAttributeAccess(followLinks);\n-        } catch (UnixException x) {\n-            x.rethrowAsIOException(file);\n-        }\n-        try {\n-            \/\/ fgetxattr returns size if called with size==0\n-            return fgetxattr(fd, nameAsBytes(file,name), 0L, 0);\n-        } catch (UnixException x) {\n-            throw new FileSystemException(file.getPathForExceptionMessage(),\n-                null, \"Unable to get size of extended attribute '\" + name +\n-                \"': \" + x.getMessage());\n-        } finally {\n-            close(fd);\n-        }\n-    }\n-\n-    @Override\n-    public int read(String name, ByteBuffer dst) throws IOException {\n-        if (System.getSecurityManager() != null)\n-            checkAccess(file.getPathForPermissionCheck(), true, false);\n-\n-        if (dst.isReadOnly())\n-            throw new IllegalArgumentException(\"Read-only buffer\");\n-        int pos = dst.position();\n-        int lim = dst.limit();\n-        assert (pos <= lim);\n-        int rem = (pos <= lim ? lim - pos : 0);\n-\n-        NativeBuffer nb;\n-        long address;\n-        if (dst instanceof sun.nio.ch.DirectBuffer) {\n-            nb = null;\n-            address = ((sun.nio.ch.DirectBuffer)dst).address() + pos;\n-        } else {\n-            \/\/ substitute with native buffer\n-            nb = NativeBuffers.getNativeBuffer(rem);\n-            address = nb.address();\n-        }\n-\n-        int fd = -1;\n-        try {\n-            fd = file.openForAttributeAccess(followLinks);\n-        } catch (UnixException x) {\n-            x.rethrowAsIOException(file);\n-        }\n-        try {\n-            try {\n-                int n = fgetxattr(fd, nameAsBytes(file,name), address, rem);\n-\n-                \/\/ if remaining is zero then fgetxattr returns the size\n-                if (rem == 0) {\n-                    if (n > 0)\n-                        throw new UnixException(ERANGE);\n-                    return 0;\n-                }\n-\n-                \/\/ copy from buffer into backing array if necessary\n-                if (nb != null) {\n-                    int off = dst.arrayOffset() + pos + Unsafe.ARRAY_BYTE_BASE_OFFSET;\n-                    unsafe.copyMemory(null, address, dst.array(), off, n);\n-                }\n-                dst.position(pos + n);\n-                return n;\n-            } catch (UnixException x) {\n-                String msg = (x.errno() == ERANGE) ?\n-                    \"Insufficient space in buffer\" : x.getMessage();\n-                throw new FileSystemException(file.getPathForExceptionMessage(),\n-                    null, \"Error reading extended attribute '\" + name + \"': \" + msg);\n-            } finally {\n-                close(fd);\n-            }\n-        } finally {\n-            if (nb != null)\n-                nb.release();\n-        }\n+        super(file, followLinks);\n@@ -221,55 +37,2 @@\n-    public int write(String name, ByteBuffer src) throws IOException {\n-        if (System.getSecurityManager() != null)\n-            checkAccess(file.getPathForPermissionCheck(), false, true);\n-\n-        int pos = src.position();\n-        int lim = src.limit();\n-        assert (pos <= lim);\n-        int rem = (pos <= lim ? lim - pos : 0);\n-\n-        NativeBuffer nb;\n-        long address;\n-        if (src instanceof sun.nio.ch.DirectBuffer) {\n-            nb = null;\n-            address = ((sun.nio.ch.DirectBuffer)src).address() + pos;\n-        } else {\n-            \/\/ substitute with native buffer\n-            nb = NativeBuffers.getNativeBuffer(rem);\n-            address = nb.address();\n-\n-            if (src.hasArray()) {\n-                \/\/ copy from backing array into buffer\n-                int off = src.arrayOffset() + pos + Unsafe.ARRAY_BYTE_BASE_OFFSET;\n-                unsafe.copyMemory(src.array(), off, null, address, rem);\n-            } else {\n-                \/\/ backing array not accessible so transfer via temporary array\n-                byte[] tmp = new byte[rem];\n-                src.get(tmp);\n-                src.position(pos);  \/\/ reset position as write may fail\n-                unsafe.copyMemory(tmp, Unsafe.ARRAY_BYTE_BASE_OFFSET, null,\n-                    address, rem);\n-            }\n-        }\n-\n-        int fd = -1;\n-        try {\n-            fd = file.openForAttributeAccess(followLinks);\n-        } catch (UnixException x) {\n-            x.rethrowAsIOException(file);\n-        }\n-        try {\n-            try {\n-                fsetxattr(fd, nameAsBytes(file,name), address, rem);\n-                src.position(pos + rem);\n-                return rem;\n-            } catch (UnixException x) {\n-                throw new FileSystemException(file.getPathForExceptionMessage(),\n-                    null, \"Error writing extended attribute '\" + name + \"': \" +\n-                    x.getMessage());\n-            } finally {\n-                close(fd);\n-            }\n-        } finally {\n-            if (nb != null)\n-                nb.release();\n-        }\n+    protected int maxNameLength() {\n+        return 255;\n@@ -278,97 +41,0 @@\n-    @Override\n-    public void delete(String name) throws IOException {\n-        if (System.getSecurityManager() != null)\n-            checkAccess(file.getPathForPermissionCheck(), false, true);\n-\n-        int fd = -1;\n-        try {\n-            fd = file.openForAttributeAccess(followLinks);\n-        } catch (UnixException x) {\n-            x.rethrowAsIOException(file);\n-        }\n-        try {\n-            fremovexattr(fd, nameAsBytes(file,name));\n-        } catch (UnixException x) {\n-            throw new FileSystemException(file.getPathForExceptionMessage(),\n-                null, \"Unable to delete extended attribute '\" + name + \"': \" + x.getMessage());\n-        } finally {\n-            close(fd);\n-        }\n-    }\n-\n-    \/**\n-     * Used by copyTo\/moveTo to copy extended attributes from source to target.\n-     *\n-     * @param   ofd\n-     *          file descriptor for source file\n-     * @param   nfd\n-     *          file descriptor for target file\n-     *\/\n-    static void copyExtendedAttributes(int ofd, int nfd) {\n-        NativeBuffer buffer = null;\n-        try {\n-\n-            \/\/ call flistxattr to get list of extended attributes.\n-            int size = 1024;\n-            buffer = NativeBuffers.getNativeBuffer(size);\n-            for (;;) {\n-                try {\n-                    size = flistxattr(ofd, buffer.address(), size);\n-                    break;\n-                } catch (UnixException x) {\n-                    \/\/ allocate larger buffer if required\n-                    if (x.errno() == ERANGE && size < 32*1024) {\n-                        buffer.release();\n-                        size *= 2;\n-                        buffer = null;\n-                        buffer = NativeBuffers.getNativeBuffer(size);\n-                        continue;\n-                    }\n-\n-                    \/\/ unable to get list of attributes\n-                    return;\n-                }\n-            }\n-\n-            \/\/ parse buffer as array of NULL-terminated C strings.\n-            long address = buffer.address();\n-            int start = 0;\n-            int pos = 0;\n-            while (pos < size) {\n-                if (unsafe.getByte(address + pos) == 0) {\n-                    \/\/ extract attribute name and copy attribute to target.\n-                    \/\/ FIXME: We can avoid needless copying by using address+pos\n-                    \/\/ as the address of the name.\n-                    int len = pos - start;\n-                    byte[] name = new byte[len];\n-                    unsafe.copyMemory(null, address+start, name,\n-                        Unsafe.ARRAY_BYTE_BASE_OFFSET, len);\n-                    try {\n-                        copyExtendedAttribute(ofd, name, nfd);\n-                    } catch (UnixException ignore) {\n-                        \/\/ ignore\n-                    }\n-                    start = pos + 1;\n-                }\n-                pos++;\n-            }\n-\n-        } finally {\n-            if (buffer != null)\n-                buffer.release();\n-        }\n-    }\n-\n-    private static void copyExtendedAttribute(int ofd, byte[] name, int nfd)\n-        throws UnixException\n-    {\n-        int size = fgetxattr(ofd, name, 0L, 0);\n-        NativeBuffer buffer = NativeBuffers.getNativeBuffer(size);\n-        try {\n-            long address = buffer.address();\n-            size = fgetxattr(ofd, name, address, size);\n-            fsetxattr(nfd, name, address, size);\n-        } finally {\n-            buffer.release();\n-        }\n-    }\n","filename":"src\/java.base\/linux\/classes\/sun\/nio\/fs\/LinuxUserDefinedFileAttributeView.java","additions":4,"deletions":338,"binary":false,"changes":342,"status":"modified"},{"patch":"@@ -39,10 +39,0 @@\n-typedef size_t fgetxattr_func(int fd, const char* name, void* value, size_t size);\n-typedef int fsetxattr_func(int fd, const char* name, void* value, size_t size, int flags);\n-typedef int fremovexattr_func(int fd, const char* name);\n-typedef int flistxattr_func(int fd, char* list, size_t size);\n-\n-fgetxattr_func* my_fgetxattr_func = NULL;\n-fsetxattr_func* my_fsetxattr_func = NULL;\n-fremovexattr_func* my_fremovexattr_func = NULL;\n-flistxattr_func* my_flistxattr_func = NULL;\n-\n@@ -65,5 +55,0 @@\n-    my_fgetxattr_func = (fgetxattr_func*)dlsym(RTLD_DEFAULT, \"fgetxattr\");\n-    my_fsetxattr_func = (fsetxattr_func*)dlsym(RTLD_DEFAULT, \"fsetxattr\");\n-    my_fremovexattr_func = (fremovexattr_func*)dlsym(RTLD_DEFAULT, \"fremovexattr\");\n-    my_flistxattr_func = (flistxattr_func*)dlsym(RTLD_DEFAULT, \"flistxattr\");\n-\n@@ -82,72 +67,0 @@\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_fs_LinuxNativeDispatcher_fgetxattr0(JNIEnv* env, jclass clazz,\n-    jint fd, jlong nameAddress, jlong valueAddress, jint valueLen)\n-{\n-    size_t res = -1;\n-    const char* name = jlong_to_ptr(nameAddress);\n-    void* value = jlong_to_ptr(valueAddress);\n-\n-    if (my_fgetxattr_func == NULL) {\n-        errno = ENOTSUP;\n-    } else {\n-        \/* EINTR not documented *\/\n-        res = (*my_fgetxattr_func)(fd, name, value, valueLen);\n-    }\n-    if (res == (size_t)-1)\n-        throwUnixException(env, errno);\n-    return (jint)res;\n-}\n-\n-JNIEXPORT void JNICALL\n-Java_sun_nio_fs_LinuxNativeDispatcher_fsetxattr0(JNIEnv* env, jclass clazz,\n-    jint fd, jlong nameAddress, jlong valueAddress, jint valueLen)\n-{\n-    int res = -1;\n-    const char* name = jlong_to_ptr(nameAddress);\n-    void* value = jlong_to_ptr(valueAddress);\n-\n-    if (my_fsetxattr_func == NULL) {\n-        errno = ENOTSUP;\n-    } else {\n-        \/* EINTR not documented *\/\n-        res = (*my_fsetxattr_func)(fd, name, value, valueLen, 0);\n-    }\n-    if (res == -1)\n-        throwUnixException(env, errno);\n-}\n-\n-JNIEXPORT void JNICALL\n-Java_sun_nio_fs_LinuxNativeDispatcher_fremovexattr0(JNIEnv* env, jclass clazz,\n-    jint fd, jlong nameAddress)\n-{\n-    int res = -1;\n-    const char* name = jlong_to_ptr(nameAddress);\n-\n-    if (my_fremovexattr_func == NULL) {\n-        errno = ENOTSUP;\n-    } else {\n-        \/* EINTR not documented *\/\n-        res = (*my_fremovexattr_func)(fd, name);\n-    }\n-    if (res == -1)\n-        throwUnixException(env, errno);\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_fs_LinuxNativeDispatcher_flistxattr(JNIEnv* env, jclass clazz,\n-    jint fd, jlong listAddress, jint size)\n-{\n-    size_t res = -1;\n-    char* list = jlong_to_ptr(listAddress);\n-\n-    if (my_flistxattr_func == NULL) {\n-        errno = ENOTSUP;\n-    } else {\n-        \/* EINTR not documented *\/\n-        res = (*my_flistxattr_func)(fd, list, (size_t)size);\n-    }\n-    if (res == (size_t)-1)\n-        throwUnixException(env, errno);\n-    return (jint)res;\n-}\n-\n","filename":"src\/java.base\/linux\/native\/libnio\/fs\/LinuxNativeDispatcher.c","additions":0,"deletions":87,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -83,21 +83,0 @@\n-    \/\/ returns true if extended attributes enabled on file system where given\n-    \/\/ file resides, returns false if disabled or unable to determine.\n-    private boolean isExtendedAttributesEnabled(UnixPath path) {\n-        int fd = -1;\n-        try {\n-            fd = path.openForAttributeAccess(false);\n-\n-            \/\/ fgetxattr returns size if called with size==0\n-            byte[] name = Util.toBytes(\"user.java\");\n-            BsdNativeDispatcher.fgetxattr(fd, name, 0L, 0);\n-            return true;\n-        } catch (UnixException e) {\n-            \/\/ attribute does not exist\n-            if (e.errno() == UnixConstants.ENOATTR)\n-                return true;\n-        } finally {\n-            UnixNativeDispatcher.close(fd);\n-        }\n-        return false;\n-    }\n-\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/fs\/BsdFileStore.java","additions":0,"deletions":21,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -72,0 +72,1 @@\n+        UnixUserDefinedFileAttributeView.copyExtendedAttributes(ofd, nfd);\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/fs\/BsdFileSystem.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -65,61 +65,0 @@\n-    \/**\n-     * ssize_t fgetxattr(int fd, const char *name, void *value, size_t size,\n-     *  u_int32_t position, int options);\n-     *\/\n-    static int fgetxattr(int fd, byte[] name, long valueAddress,\n-                         int valueLen) throws UnixException\n-    {\n-        NativeBuffer buffer = NativeBuffers.asNativeBuffer(name);\n-        try {\n-            return fgetxattr0(fd, buffer.address(), valueAddress, valueLen, 0L, 0);\n-        } finally {\n-            buffer.release();\n-        }\n-    }\n-\n-    private static native int fgetxattr0(int fd, long nameAddress,\n-        long valueAddress, int valueLen, long position, int options) throws UnixException;\n-\n-    \/**\n-     * int fsetxattr(int fd, const char *name, void *value, size_t size,\n-     *  u_int32_t position, int options);\n-     *\/\n-    static void fsetxattr(int fd, byte[] name, long valueAddress,\n-                          int valueLen) throws UnixException\n-    {\n-        NativeBuffer buffer = NativeBuffers.asNativeBuffer(name);\n-        try {\n-            fsetxattr0(fd, buffer.address(), valueAddress, valueLen, 0L, 0);\n-        } finally {\n-            buffer.release();\n-        }\n-    }\n-\n-    private static native void fsetxattr0(int fd, long nameAddress,\n-        long valueAddress, int valueLen, long position, int options) throws UnixException;\n-\n-    \/**\n-     * int fremovexattr(int fd, const char *name, int options);\n-     *\/\n-    static void fremovexattr(int fd, byte[] name) throws UnixException {\n-        NativeBuffer buffer = NativeBuffers.asNativeBuffer(name);\n-        try {\n-            fremovexattr0(fd, buffer.address(), 0);\n-        } finally {\n-            buffer.release();\n-        }\n-    }\n-\n-    private static native void fremovexattr0(int fd, long nameAddress, int options)\n-        throws UnixException;\n-\n-    \/**\n-     * ssize_t flistxattr(int fd, char *namebuf, size_t size, int options);\n-     *\/\n-    static int flistxattr(int fd, long nameBufAddress, int size) throws UnixException {\n-        return flistxattr0(fd, nameBufAddress, size, 0);\n-    }\n-\n-    private static native int flistxattr0(int fd, long nameBufAddress, int size,\n-        int options) throws UnixException;\n-\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/fs\/BsdNativeDispatcher.java","additions":0,"deletions":61,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -28,13 +28,0 @@\n-import java.nio.file.*;\n-import java.nio.ByteBuffer;\n-import java.io.IOException;\n-import java.util.*;\n-import jdk.internal.misc.Unsafe;\n-\n-import static sun.nio.fs.UnixConstants.*;\n-import static sun.nio.fs.BsdNativeDispatcher.*;\n-\n-\/**\n- * BSD implementation of UserDefinedFileAttributeView using extended attributes.\n- *\/\n-\n@@ -42,1 +29,1 @@\n-    extends AbstractUserDefinedFileAttributeView\n+    extends UnixUserDefinedFileAttributeView\n@@ -44,46 +31,0 @@\n-    private static final Unsafe unsafe = Unsafe.getUnsafe();\n-\n-    \/\/ namespace for extended user attributes\n-    private static final String USER_NAMESPACE = \"user.\";\n-\n-    \/\/ maximum bytes in extended attribute name (includes namespace),\n-    \/\/ see XATTR_MAXNAMELEN in https:\/\/github.com\/apple\/darwin-xnu\/blob\/master\/bsd\/sys\/xattr.h\n-    private static final int XATTR_NAME_MAX = 127;\n-\n-    private byte[] nameAsBytes(UnixPath file, String name) throws IOException {\n-        if (name == null)\n-            throw new NullPointerException(\"'name' is null\");\n-        name = USER_NAMESPACE + name;\n-        byte[] bytes = Util.toBytes(name);\n-        if (bytes.length > XATTR_NAME_MAX) {\n-            throw new FileSystemException(file.getPathForExceptionMessage(),\n-                null, \"'\" + name + \"' is too big\");\n-        }\n-        return bytes;\n-    }\n-\n-    \/\/ Parses buffer as array of NULL-terminated C strings.\n-    private List<String> asList(long address, int size) {\n-        List<String> list = new ArrayList<>();\n-        int start = 0;\n-        int pos = 0;\n-        while (pos < size) {\n-            if (unsafe.getByte(address + pos) == 0) {\n-                int len = pos - start;\n-                byte[] value = new byte[len];\n-                unsafe.copyMemory(null, address+start, value,\n-                    Unsafe.ARRAY_BYTE_BASE_OFFSET, len);\n-                String s = Util.toString(value);\n-                if (s.startsWith(USER_NAMESPACE)) {\n-                    s = s.substring(USER_NAMESPACE.length());\n-                    list.add(s);\n-                }\n-                start = pos + 1;\n-            }\n-            pos++;\n-        }\n-        return list;\n-    }\n-\n-    private final UnixPath file;\n-    private final boolean followLinks;\n@@ -92,127 +33,1 @@\n-        this.file = file;\n-        this.followLinks = followLinks;\n-    }\n-\n-    @Override\n-    public List<String> list() throws IOException  {\n-        if (System.getSecurityManager() != null)\n-            checkAccess(file.getPathForPermissionCheck(), true, false);\n-\n-        int fd = -1;\n-        try {\n-            fd = file.openForAttributeAccess(followLinks);\n-        } catch (UnixException x) {\n-            x.rethrowAsIOException(file);\n-        }\n-        NativeBuffer buffer = null;\n-        try {\n-            int size = 1024;\n-            buffer = NativeBuffers.getNativeBuffer(size);\n-            for (;;) {\n-                try {\n-                    int n = flistxattr(fd, buffer.address(), size);\n-                    List<String> list = asList(buffer.address(), n);\n-                    return Collections.unmodifiableList(list);\n-                } catch (UnixException x) {\n-                    \/\/ allocate larger buffer if required\n-                    if (x.errno() == ERANGE && size < 32*1024) {\n-                        buffer.release();\n-                        size *= 2;\n-                        buffer = null;\n-                        buffer = NativeBuffers.getNativeBuffer(size);\n-                        continue;\n-                    }\n-                    throw new FileSystemException(file.getPathForExceptionMessage(),\n-                        null, \"Unable to get list of extended attributes: \" +\n-                        x.getMessage());\n-                }\n-            }\n-        } finally {\n-            if (buffer != null)\n-                buffer.release();\n-            close(fd);\n-        }\n-    }\n-\n-    @Override\n-    public int size(String name) throws IOException  {\n-        if (System.getSecurityManager() != null)\n-            checkAccess(file.getPathForPermissionCheck(), true, false);\n-\n-        int fd = -1;\n-        try {\n-            fd = file.openForAttributeAccess(followLinks);\n-        } catch (UnixException x) {\n-            x.rethrowAsIOException(file);\n-        }\n-        try {\n-            \/\/ fgetxattr returns size if called with size==0\n-            return fgetxattr(fd, nameAsBytes(file,name), 0L, 0);\n-        } catch (UnixException x) {\n-            throw new FileSystemException(file.getPathForExceptionMessage(),\n-                null, \"Unable to get size of extended attribute '\" + name +\n-                \"': \" + x.getMessage());\n-        } finally {\n-            close(fd);\n-        }\n-    }\n-\n-    @Override\n-    public int read(String name, ByteBuffer dst) throws IOException {\n-        if (System.getSecurityManager() != null)\n-            checkAccess(file.getPathForPermissionCheck(), true, false);\n-\n-        if (dst.isReadOnly())\n-            throw new IllegalArgumentException(\"Read-only buffer\");\n-        int pos = dst.position();\n-        int lim = dst.limit();\n-        assert (pos <= lim);\n-        int rem = (pos <= lim ? lim - pos : 0);\n-\n-        NativeBuffer nb;\n-        long address;\n-        if (dst instanceof sun.nio.ch.DirectBuffer) {\n-            nb = null;\n-            address = ((sun.nio.ch.DirectBuffer)dst).address() + pos;\n-        } else {\n-            \/\/ substitute with native buffer\n-            nb = NativeBuffers.getNativeBuffer(rem);\n-            address = nb.address();\n-        }\n-\n-        int fd = -1;\n-        try {\n-            fd = file.openForAttributeAccess(followLinks);\n-        } catch (UnixException x) {\n-            x.rethrowAsIOException(file);\n-        }\n-        try {\n-            try {\n-                int n = fgetxattr(fd, nameAsBytes(file,name), address, rem);\n-\n-                \/\/ if remaining is zero then fgetxattr returns the size\n-                if (rem == 0) {\n-                    if (n > 0)\n-                        throw new UnixException(ERANGE);\n-                    return 0;\n-                }\n-\n-                \/\/ copy from buffer into backing array if necessary\n-                if (nb != null) {\n-                    int off = dst.arrayOffset() + pos + Unsafe.ARRAY_BYTE_BASE_OFFSET;\n-                    unsafe.copyMemory(null, address, dst.array(), off, n);\n-                }\n-                dst.position(pos + n);\n-                return n;\n-            } catch (UnixException x) {\n-                String msg = (x.errno() == ERANGE) ?\n-                    \"Insufficient space in buffer\" : x.getMessage();\n-                throw new FileSystemException(file.getPathForExceptionMessage(),\n-                    null, \"Error reading extended attribute '\" + name + \"': \" + msg);\n-            } finally {\n-                close(fd);\n-            }\n-        } finally {\n-            if (nb != null)\n-                nb.release();\n-        }\n+        super(file, followLinks);\n@@ -222,55 +37,3 @@\n-    public int write(String name, ByteBuffer src) throws IOException {\n-        if (System.getSecurityManager() != null)\n-            checkAccess(file.getPathForPermissionCheck(), false, true);\n-\n-        int pos = src.position();\n-        int lim = src.limit();\n-        assert (pos <= lim);\n-        int rem = (pos <= lim ? lim - pos : 0);\n-\n-        NativeBuffer nb;\n-        long address;\n-        if (src instanceof sun.nio.ch.DirectBuffer) {\n-            nb = null;\n-            address = ((sun.nio.ch.DirectBuffer)src).address() + pos;\n-        } else {\n-            \/\/ substitute with native buffer\n-            nb = NativeBuffers.getNativeBuffer(rem);\n-            address = nb.address();\n-\n-            if (src.hasArray()) {\n-                \/\/ copy from backing array into buffer\n-                int off = src.arrayOffset() + pos + Unsafe.ARRAY_BYTE_BASE_OFFSET;\n-                unsafe.copyMemory(src.array(), off, null, address, rem);\n-            } else {\n-                \/\/ backing array not accessible so transfer via temporary array\n-                byte[] tmp = new byte[rem];\n-                src.get(tmp);\n-                src.position(pos);  \/\/ reset position as write may fail\n-                unsafe.copyMemory(tmp, Unsafe.ARRAY_BYTE_BASE_OFFSET, null,\n-                    address, rem);\n-            }\n-        }\n-\n-        int fd = -1;\n-        try {\n-            fd = file.openForAttributeAccess(followLinks);\n-        } catch (UnixException x) {\n-            x.rethrowAsIOException(file);\n-        }\n-        try {\n-            try {\n-                fsetxattr(fd, nameAsBytes(file,name), address, rem);\n-                src.position(pos + rem);\n-                return rem;\n-            } catch (UnixException x) {\n-                throw new FileSystemException(file.getPathForExceptionMessage(),\n-                    null, \"Error writing extended attribute '\" + name + \"': \" +\n-                    x.getMessage());\n-            } finally {\n-                close(fd);\n-            }\n-        } finally {\n-            if (nb != null)\n-                nb.release();\n-        }\n+    protected int maxNameLength() {\n+        \/\/ see XATTR_MAXNAMELEN in https:\/\/github.com\/apple\/darwin-xnu\/blob\/master\/bsd\/sys\/xattr.h\n+        return 127;\n@@ -279,97 +42,0 @@\n-    @Override\n-    public void delete(String name) throws IOException {\n-        if (System.getSecurityManager() != null)\n-            checkAccess(file.getPathForPermissionCheck(), false, true);\n-\n-        int fd = -1;\n-        try {\n-            fd = file.openForAttributeAccess(followLinks);\n-        } catch (UnixException x) {\n-            x.rethrowAsIOException(file);\n-        }\n-        try {\n-            fremovexattr(fd, nameAsBytes(file,name));\n-        } catch (UnixException x) {\n-            throw new FileSystemException(file.getPathForExceptionMessage(),\n-                null, \"Unable to delete extended attribute '\" + name + \"': \" + x.getMessage());\n-        } finally {\n-            close(fd);\n-        }\n-    }\n-\n-    \/**\n-     * Used by copyTo\/moveTo to copy extended attributes from source to target.\n-     *\n-     * @param   ofd\n-     *          file descriptor for source file\n-     * @param   nfd\n-     *          file descriptor for target file\n-     *\/\n-    static void copyExtendedAttributes(int ofd, int nfd) {\n-        NativeBuffer buffer = null;\n-        try {\n-\n-            \/\/ call flistxattr to get list of extended attributes.\n-            int size = 1024;\n-            buffer = NativeBuffers.getNativeBuffer(size);\n-            for (;;) {\n-                try {\n-                    size = flistxattr(ofd, buffer.address(), size);\n-                    break;\n-                } catch (UnixException x) {\n-                    \/\/ allocate larger buffer if required\n-                    if (x.errno() == ERANGE && size < 32*1024) {\n-                        buffer.release();\n-                        size *= 2;\n-                        buffer = null;\n-                        buffer = NativeBuffers.getNativeBuffer(size);\n-                        continue;\n-                    }\n-\n-                    \/\/ unable to get list of attributes\n-                    return;\n-                }\n-            }\n-\n-            \/\/ parse buffer as array of NULL-terminated C strings.\n-            long address = buffer.address();\n-            int start = 0;\n-            int pos = 0;\n-            while (pos < size) {\n-                if (unsafe.getByte(address + pos) == 0) {\n-                    \/\/ extract attribute name and copy attribute to target.\n-                    \/\/ FIXME: We can avoid needless copying by using address+pos\n-                    \/\/ as the address of the name.\n-                    int len = pos - start;\n-                    byte[] name = new byte[len];\n-                    unsafe.copyMemory(null, address+start, name,\n-                        Unsafe.ARRAY_BYTE_BASE_OFFSET, len);\n-                    try {\n-                        copyExtendedAttribute(ofd, name, nfd);\n-                    } catch (UnixException ignore) {\n-                        \/\/ ignore\n-                    }\n-                    start = pos + 1;\n-                }\n-                pos++;\n-            }\n-\n-        } finally {\n-            if (buffer != null)\n-                buffer.release();\n-        }\n-    }\n-\n-    private static void copyExtendedAttribute(int ofd, byte[] name, int nfd)\n-        throws UnixException\n-    {\n-        int size = fgetxattr(ofd, name, 0L, 0);\n-        NativeBuffer buffer = NativeBuffers.getNativeBuffer(size);\n-        try {\n-            long address = buffer.address();\n-            size = fgetxattr(ofd, name, address, size);\n-            fsetxattr(nfd, name, address, size);\n-        } finally {\n-            buffer.release();\n-        }\n-    }\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/fs\/BsdUserDefinedFileAttributeView.java","additions":5,"deletions":339,"binary":false,"changes":344,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-#include <sys\/xattr.h>\n@@ -228,49 +227,0 @@\n-\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_fs_BsdNativeDispatcher_fgetxattr0(JNIEnv* env, jclass clazz,\n-    jint fd, jlong nameAddress, jlong valueAddress, jint valueLen, jlong position, jint options)\n-{\n-    const char* name = jlong_to_ptr(nameAddress);\n-    void* value = jlong_to_ptr(valueAddress);\n-\n-    ssize_t res = fgetxattr(fd, name, value, valueLen, (u_int32_t)position, options);\n-    if (res == (ssize_t)-1)\n-        throwUnixException(env, errno);\n-    return (jint)res;\n-}\n-\n-JNIEXPORT void JNICALL\n-Java_sun_nio_fs_BsdNativeDispatcher_fsetxattr0(JNIEnv* env, jclass clazz,\n-    jint fd, jlong nameAddress, jlong valueAddress, jint valueLen, jlong position, jint options)\n-{\n-    const char* name = jlong_to_ptr(nameAddress);\n-    void* value = jlong_to_ptr(valueAddress);\n-\n-    int res = fsetxattr(fd, name, value, valueLen, (u_int32_t)position, options);\n-    if (res == -1)\n-        throwUnixException(env, errno);\n-}\n-\n-JNIEXPORT void JNICALL\n-Java_sun_nio_fs_BsdNativeDispatcher_fremovexattr0(JNIEnv* env, jclass clazz,\n-    jint fd, jlong nameAddress, jint options)\n-{\n-    const char* name = jlong_to_ptr(nameAddress);\n-\n-    int res = fremovexattr(fd, name, options);\n-    if (res == -1)\n-        throwUnixException(env, errno);\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_fs_BsdNativeDispatcher_flistxattr0(JNIEnv* env, jclass clazz,\n-    jint fd, jlong nameBufAddress, jint size, jint options)\n-{\n-    char* nameBuf = jlong_to_ptr(nameBufAddress);\n-\n-    ssize_t res = flistxattr(fd, nameBuf, (size_t)size, options);\n-\n-    if (res == (ssize_t)-1)\n-        throwUnixException(env, errno);\n-    return (jint)res;\n-}\n","filename":"src\/java.base\/macosx\/native\/libnio\/fs\/BsdNativeDispatcher.c","additions":0,"deletions":50,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-class NativeBuffer {\n+class NativeBuffer implements AutoCloseable {\n@@ -64,0 +64,5 @@\n+    @Override\n+    public void close() {\n+        release();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/fs\/NativeBuffer.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -113,3 +113,5 @@\n-#ifndef ENODATA\n-    \/\/ Only used in Linux java source, provide any value so it compiles\n-    static final int PREFIX_ENODATA = ELAST;\n+\/\/ fgetxattr error codes for absent attributes depend on the OS:\n+#ifdef _ALLBSD_SOURCE\n+    static final int PREFIX_XATTR_NOT_FOUND = ENOATTR;\n+#elif __linux__\n+    static final int PREFIX_XATTR_NOT_FOUND = ENODATA;\n@@ -117,6 +119,2 @@\n-    static final int PREFIX_ENODATA = ENODATA;\n-#endif\n-\n-#ifdef ENOATTR\n-    \/\/ BSD uses ENOATTR instead of ENODATA during xattr calls\n-    static final int PREFIX_ENOATTR = ENOATTR;\n+    \/\/ not supported (dummy values will not be used at runtime).\n+    static final int PREFIX_XATTR_NOT_FOUND = 00;\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixConstants.java.template","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -175,0 +175,26 @@\n+    \/\/ returns true if extended attributes enabled on file system where given\n+    \/\/ file resides, returns false if disabled or unable to determine.\n+    protected boolean isExtendedAttributesEnabled(UnixPath path) {\n+        if (!UnixNativeDispatcher.xattrSupported()) {\n+            \/\/ avoid I\/O if native code doesn't support xattr\n+            return false;\n+        }\n+\n+        int fd = -1;\n+        try {\n+            fd = path.openForAttributeAccess(false);\n+\n+            \/\/ fgetxattr returns size if called with size==0\n+            byte[] name = Util.toBytes(\"user.java\");\n+            UnixNativeDispatcher.fgetxattr(fd, name, 0L, 0);\n+            return true;\n+        } catch (UnixException e) {\n+            \/\/ attribute does not exist\n+            if (e.errno() == UnixConstants.XATTR_NOT_FOUND)\n+                return true;\n+        } finally {\n+            UnixNativeDispatcher.close(fd);\n+        }\n+        return false;\n+    }\n+\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixFileStore.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -566,0 +566,46 @@\n+    \/**\n+     * ssize_t fgetxattr(int filedes, const char *name, void *value, size_t size);\n+     *\/\n+    static int fgetxattr(int filedes, byte[] name, long valueAddress,\n+                         int valueLen) throws UnixException\n+    {\n+        try (NativeBuffer buffer = NativeBuffers.asNativeBuffer(name)) {\n+            return fgetxattr0(filedes, buffer.address(), valueAddress, valueLen);\n+        }\n+    }\n+\n+    private static native int fgetxattr0(int filedes, long nameAddress,\n+                                         long valueAddress, int valueLen) throws UnixException;\n+\n+    \/**\n+     *  fsetxattr(int filedes, const char *name, const void *value, size_t size, int flags);\n+     *\/\n+    static void fsetxattr(int filedes, byte[] name, long valueAddress,\n+                          int valueLen) throws UnixException\n+    {\n+        try (NativeBuffer buffer = NativeBuffers.asNativeBuffer(name)) {\n+            fsetxattr0(filedes, buffer.address(), valueAddress, valueLen);\n+        }\n+    }\n+\n+    private static native void fsetxattr0(int filedes, long nameAddress,\n+                                          long valueAddress, int valueLen) throws UnixException;\n+\n+    \/**\n+     * fremovexattr(int filedes, const char *name);\n+     *\/\n+    static void fremovexattr(int filedes, byte[] name) throws UnixException {\n+        try (NativeBuffer buffer = NativeBuffers.asNativeBuffer(name)) {\n+            fremovexattr0(filedes, buffer.address());\n+        }\n+    }\n+\n+    private static native void fremovexattr0(int filedes, long nameAddress)\n+            throws UnixException;\n+\n+    \/**\n+     * size_t flistxattr(int filedes, const char *list, size_t size)\n+     *\/\n+    static native int flistxattr(int filedes, long listAddress, int size)\n+            throws UnixException;\n+\n@@ -571,2 +617,3 @@\n-    private static final int SUPPORTS_FUTIMENS      = 1 << 4;\n-    private static final int SUPPORTS_LUTIMES       = 1 << 8;\n+    private static final int SUPPORTS_FUTIMENS      = 1 << 3;\n+    private static final int SUPPORTS_LUTIMES       = 1 << 4;\n+    private static final int SUPPORTS_XATTR         = 1 << 5;\n@@ -611,0 +658,7 @@\n+    \/**\n+     * Supports extended attributes\n+     *\/\n+    static boolean xattrSupported() {\n+        return (capabilities & SUPPORTS_XATTR) != 0;\n+    }\n+\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixNativeDispatcher.java","additions":56,"deletions":2,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -0,0 +1,342 @@\n+\/*\n+ * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.nio.fs;\n+\n+import java.nio.file.*;\n+import java.nio.ByteBuffer;\n+import java.io.IOException;\n+import java.util.*;\n+import jdk.internal.misc.Unsafe;\n+\n+import static sun.nio.fs.UnixConstants.*;\n+import static sun.nio.fs.UnixNativeDispatcher.*;\n+\n+\/**\n+ * Unix implementation of UserDefinedFileAttributeView using extended attributes.\n+ *\/\n+abstract class UnixUserDefinedFileAttributeView\n+        extends AbstractUserDefinedFileAttributeView\n+{\n+    private static final Unsafe unsafe = Unsafe.getUnsafe();\n+\n+    \/\/ namespace for extended user attributes\n+    private static final String USER_NAMESPACE = \"user.\";\n+\n+    private static final int MIN_LISTXATTR_BUF_SIZE = 1024;\n+    private static final int MAX_LISTXATTR_BUF_SIZE = 32 * 1024;\n+\n+    private final UnixPath file;\n+    private final boolean followLinks;\n+\n+    UnixUserDefinedFileAttributeView(UnixPath file, boolean followLinks) {\n+        this.file = file;\n+        this.followLinks = followLinks;\n+    }\n+\n+    \/\/ returns the maximum supported length of xattr names (in bytes, including namespace)\n+    protected abstract int maxNameLength();\n+\n+    private byte[] nameAsBytes(UnixPath file, String name) throws IOException {\n+        if (name == null)\n+            throw new NullPointerException(\"'name' is null\");\n+        name = USER_NAMESPACE + name;\n+        byte[] bytes = Util.toBytes(name);\n+        if (bytes.length > maxNameLength()) {\n+            throw new FileSystemException(file.getPathForExceptionMessage(),\n+                    null, \"'\" + name + \"' is too big\");\n+        }\n+        return bytes;\n+    }\n+\n+    \/\/ Parses buffer as array of NULL-terminated C strings.\n+    private static List<String> asList(long address, int size) {\n+        List<String> list = new ArrayList<>();\n+        int start = 0;\n+        int pos = 0;\n+        while (pos < size) {\n+            if (unsafe.getByte(address + pos) == 0) {\n+                int len = pos - start;\n+                byte[] value = new byte[len];\n+                unsafe.copyMemory(null, address+start, value,\n+                        Unsafe.ARRAY_BYTE_BASE_OFFSET, len);\n+                String s = Util.toString(value);\n+                list.add(s);\n+                start = pos + 1;\n+            }\n+            pos++;\n+        }\n+        return list;\n+    }\n+\n+    \/\/ runs flistxattr, increases buffer size if required\n+    private static List<String> list(int fd, int bufSize) throws UnixException {\n+        try {\n+            try (NativeBuffer buffer = NativeBuffers.getNativeBuffer(bufSize)) {\n+                int n = flistxattr(fd, buffer.address(), bufSize);\n+                return asList(buffer.address(), n);\n+            } \/\/ release buffer before potential recursive call\n+        } catch (UnixException x) {\n+            if (x.errno() == ERANGE && bufSize < MAX_LISTXATTR_BUF_SIZE) {\n+                return list(fd, bufSize * 2); \/\/ try larger buffer size:\n+            } else {\n+                throw x;\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public List<String> list() throws IOException {\n+        if (System.getSecurityManager() != null)\n+            checkAccess(file.getPathForPermissionCheck(), true, false);\n+\n+        int fd = -1;\n+        try {\n+            fd = file.openForAttributeAccess(followLinks);\n+        } catch (UnixException x) {\n+            x.rethrowAsIOException(file);\n+        }\n+        try {\n+            List<String> rawList = list(fd, MIN_LISTXATTR_BUF_SIZE);\n+            List<String> userAttr = rawList.stream()\n+                    .filter(s -> s.startsWith(USER_NAMESPACE))\n+                    .map(s -> s.substring(USER_NAMESPACE.length()))\n+                    .toList();\n+            return Collections.unmodifiableList(userAttr);\n+        } catch (UnixException x) {\n+            throw new FileSystemException(file.getPathForExceptionMessage(),\n+                    null, \"Unable to get list of extended attributes: \" +\n+                    x.getMessage());\n+        } finally {\n+            close(fd);\n+        }\n+    }\n+\n+    @Override\n+    public int size(String name) throws IOException  {\n+        if (System.getSecurityManager() != null)\n+            checkAccess(file.getPathForPermissionCheck(), true, false);\n+\n+        int fd = -1;\n+        try {\n+            fd = file.openForAttributeAccess(followLinks);\n+        } catch (UnixException x) {\n+            x.rethrowAsIOException(file);\n+        }\n+        try {\n+            \/\/ fgetxattr returns size if called with size==0\n+            return fgetxattr(fd, nameAsBytes(file,name), 0L, 0);\n+        } catch (UnixException x) {\n+            throw new FileSystemException(file.getPathForExceptionMessage(),\n+                    null, \"Unable to get size of extended attribute '\" + name +\n+                    \"': \" + x.getMessage());\n+        } finally {\n+            close(fd);\n+        }\n+    }\n+\n+    @Override\n+    public int read(String name, ByteBuffer dst) throws IOException {\n+        if (System.getSecurityManager() != null)\n+            checkAccess(file.getPathForPermissionCheck(), true, false);\n+\n+        if (dst.isReadOnly())\n+            throw new IllegalArgumentException(\"Read-only buffer\");\n+        int pos = dst.position();\n+        int lim = dst.limit();\n+        assert (pos <= lim);\n+        int rem = (pos <= lim ? lim - pos : 0);\n+\n+        if (dst instanceof sun.nio.ch.DirectBuffer) {\n+            long address = ((sun.nio.ch.DirectBuffer)dst).address() + pos;\n+            int n = read(name, address, rem);\n+            dst.position(pos + n);\n+            return n;\n+        } else {\n+            \/\/ substitute with native buffer\n+            try (NativeBuffer nb = NativeBuffers.getNativeBuffer(rem)) {\n+                long address = nb.address();\n+                int n = read(name, address, rem);\n+\n+                if (dst.hasArray()) {\n+                    \/\/ copy from buffer into backing array\n+                    int off = dst.arrayOffset() + pos + Unsafe.ARRAY_BYTE_BASE_OFFSET;\n+                    unsafe.copyMemory(null, address, dst.array(), off, n);\n+                    dst.position(pos + n);\n+                } else {\n+                    \/\/ backing array not accessible so transfer via temporary array\n+                    byte[] tmp = new byte[n];\n+                    unsafe.copyMemory(null, address, tmp, 0, n);\n+                    dst.put(tmp);\n+                }\n+\n+                return n;\n+            }\n+        }\n+    }\n+\n+    private int read(String name, long address, int rem) throws IOException {\n+        int fd = -1;\n+        try {\n+            fd = file.openForAttributeAccess(followLinks);\n+        } catch (UnixException x) {\n+            x.rethrowAsIOException(file);\n+        }\n+        try {\n+            int n = fgetxattr(fd, nameAsBytes(file, name), address, rem);\n+\n+            \/\/ if remaining is zero then fgetxattr returns the size\n+            if (rem == 0) {\n+                if (n > 0)\n+                    throw new UnixException(ERANGE);\n+                return 0;\n+            }\n+\n+            return n;\n+        } catch (UnixException x) {\n+            String msg = (x.errno() == ERANGE) ?\n+                    \"Insufficient space in buffer\" : x.getMessage();\n+            throw new FileSystemException(file.getPathForExceptionMessage(),\n+                    null, \"Error reading extended attribute '\" + name + \"': \" + msg);\n+        } finally {\n+            close(fd);\n+        }\n+    }\n+\n+    @Override\n+    public int write(String name, ByteBuffer src) throws IOException {\n+        if (System.getSecurityManager() != null)\n+            checkAccess(file.getPathForPermissionCheck(), false, true);\n+\n+        int pos = src.position();\n+        int lim = src.limit();\n+        assert (pos <= lim);\n+        int rem = (pos <= lim ? lim - pos : 0);\n+\n+        if (src instanceof sun.nio.ch.DirectBuffer) {\n+            long address = ((sun.nio.ch.DirectBuffer)src).address() + pos;\n+            write(name, address, rem);\n+            src.position(pos + rem);\n+            return rem;\n+        } else {\n+            \/\/ substitute with native buffer\n+            try (NativeBuffer nb = NativeBuffers.getNativeBuffer(rem)) {\n+                long address = nb.address();\n+\n+                if (src.hasArray()) {\n+                    \/\/ copy from backing array into buffer\n+                    int off = src.arrayOffset() + pos + Unsafe.ARRAY_BYTE_BASE_OFFSET;\n+                    unsafe.copyMemory(src.array(), off, null, address, rem);\n+                } else {\n+                    \/\/ backing array not accessible so transfer via temporary array\n+                    byte[] tmp = new byte[rem];\n+                    src.get(tmp);\n+                    src.position(pos);  \/\/ reset position as write may fail\n+                    unsafe.copyMemory(tmp, Unsafe.ARRAY_BYTE_BASE_OFFSET, null,\n+                            address, rem);\n+                }\n+\n+                write(name, address, rem);\n+                src.position(pos + rem);\n+                return rem;\n+            }\n+        }\n+    }\n+\n+    private void write(String name, long address, int rem) throws IOException {\n+        int fd = -1;\n+        try {\n+            fd = file.openForAttributeAccess(followLinks);\n+        } catch (UnixException x) {\n+            x.rethrowAsIOException(file);\n+        }\n+        try {\n+            fsetxattr(fd, nameAsBytes(file,name), address, rem);\n+        } catch (UnixException x) {\n+            throw new FileSystemException(file.getPathForExceptionMessage(),\n+                    null, \"Error writing extended attribute '\" + name + \"': \" +\n+                    x.getMessage());\n+        } finally {\n+            close(fd);\n+        }\n+    }\n+\n+    @Override\n+    public void delete(String name) throws IOException {\n+        if (System.getSecurityManager() != null)\n+            checkAccess(file.getPathForPermissionCheck(), false, true);\n+\n+        int fd = -1;\n+        try {\n+            fd = file.openForAttributeAccess(followLinks);\n+        } catch (UnixException x) {\n+            x.rethrowAsIOException(file);\n+        }\n+        try {\n+            fremovexattr(fd, nameAsBytes(file,name));\n+        } catch (UnixException x) {\n+            throw new FileSystemException(file.getPathForExceptionMessage(),\n+                    null, \"Unable to delete extended attribute '\" + name + \"': \" + x.getMessage());\n+        } finally {\n+            close(fd);\n+        }\n+    }\n+\n+    \/**\n+     * Used by copyTo\/moveTo to copy extended attributes from source to target.\n+     *\n+     * @param   ofd\n+     *          file descriptor for source file\n+     * @param   nfd\n+     *          file descriptor for target file\n+     *\/\n+    static void copyExtendedAttributes(int ofd, int nfd) {\n+        try {\n+            List<String> rawList = list(ofd, MIN_LISTXATTR_BUF_SIZE);\n+            for (String name : rawList) {\n+                try {\n+                    copyExtendedAttribute(ofd, Util.toBytes(name), nfd);\n+                } catch (UnixException ignore) {\n+                    \/\/ ignore\n+                }\n+            }\n+        } catch (UnixException e) {\n+            \/\/ unable to get list of attributes\n+            return;\n+        }\n+    }\n+\n+    private static void copyExtendedAttribute(int ofd, byte[] name, int nfd)\n+            throws UnixException\n+    {\n+        int size = fgetxattr(ofd, name, 0L, 0);\n+        try (NativeBuffer buffer = NativeBuffers.getNativeBuffer(size)) {\n+            long address = buffer.address();\n+            size = fgetxattr(ofd, name, address, size);\n+            fsetxattr(nfd, name, address, size);\n+        }\n+    }\n+\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixUserDefinedFileAttributeView.java","additions":342,"deletions":0,"binary":false,"changes":342,"status":"added"},{"patch":"@@ -44,0 +44,4 @@\n+#if defined(__linux__) || defined(_ALLBSD_SOURCE)\n+#include <sys\/xattr.h>\n+#endif\n+\n@@ -52,1 +56,0 @@\n-#if defined(__linux__) || defined(_AIX)\n@@ -54,1 +57,0 @@\n-#endif\n@@ -57,2 +59,0 @@\n-#include <string.h>\n-\n@@ -314,0 +314,6 @@\n+    \/* supports extended attributes *\/\n+\n+#ifdef _SYS_XATTR_H_\n+    capabilities |= sun_nio_fs_UnixNativeDispatcher_SUPPORTS_XATTR;\n+#endif\n+\n@@ -1244,0 +1250,80 @@\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_fs_UnixNativeDispatcher_fgetxattr0(JNIEnv* env, jclass clazz,\n+    jint fd, jlong nameAddress, jlong valueAddress, jint valueLen)\n+{\n+    size_t res = -1;\n+    const char* name = jlong_to_ptr(nameAddress);\n+    void* value = jlong_to_ptr(valueAddress);\n+\n+#ifdef __linux__\n+    res = fgetxattr(fd, name, value, valueLen);\n+#elif _ALLBSD_SOURCE\n+    res = fgetxattr(fd, name, value, valueLen, 0, 0);\n+#else\n+    throwUnixException(env, ENOTSUP);\n+#endif\n+\n+    if (res == (size_t)-1)\n+        throwUnixException(env, errno);\n+    return (jint)res;\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_sun_nio_fs_UnixNativeDispatcher_fsetxattr0(JNIEnv* env, jclass clazz,\n+    jint fd, jlong nameAddress, jlong valueAddress, jint valueLen)\n+{\n+    int res = -1;\n+    const char* name = jlong_to_ptr(nameAddress);\n+    void* value = jlong_to_ptr(valueAddress);\n+\n+#ifdef __linux__\n+    res = fsetxattr(fd, name, value, valueLen, 0);\n+#elif _ALLBSD_SOURCE\n+    res = fsetxattr(fd, name, value, valueLen, 0, 0);\n+#else\n+    throwUnixException(env, ENOTSUP);\n+#endif\n+\n+    if (res == -1)\n+        throwUnixException(env, errno);\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_sun_nio_fs_UnixNativeDispatcher_fremovexattr0(JNIEnv* env, jclass clazz,\n+    jint fd, jlong nameAddress)\n+{\n+    int res = -1;\n+    const char* name = jlong_to_ptr(nameAddress);\n+\n+#ifdef __linux__\n+    res = fremovexattr(fd, name);\n+#elif _ALLBSD_SOURCE\n+    res = fremovexattr(fd, name, 0);\n+#else\n+    throwUnixException(env, ENOTSUP);\n+#endif\n+\n+    if (res == -1)\n+        throwUnixException(env, errno);\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_fs_UnixNativeDispatcher_flistxattr(JNIEnv* env, jclass clazz,\n+    jint fd, jlong listAddress, jint size)\n+{\n+    size_t res = -1;\n+    char* list = jlong_to_ptr(listAddress);\n+\n+#ifdef __linux__\n+    res = flistxattr(fd, list, (size_t)size);\n+#elif _ALLBSD_SOURCE\n+    res = flistxattr(fd, list, (size_t)size, 0);\n+#else\n+    throwUnixException(env, ENOTSUP);\n+#endif\n+\n+    if (res == (size_t)-1)\n+        throwUnixException(env, errno);\n+    return (jint)res;\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/unix\/native\/libnio\/fs\/UnixNativeDispatcher.c","additions":90,"deletions":4,"binary":false,"changes":94,"status":"modified"}]}