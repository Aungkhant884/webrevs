{"files":[{"patch":"@@ -887,1 +887,0 @@\n-                                g.setClip(rect.x, rect.y, rect.width, rect.height);\n@@ -889,1 +888,12 @@\n-                                    dirtyComponent.paint(g);\n+                                    Component componentToPaint = dirtyComponent;\n+                                    if (dirtyComponent instanceof Window &&\n+                                            dirtyComponent instanceof RootPaneContainer rootPaneContainer) {\n+                                        JRootPane rootPane = rootPaneContainer.getRootPane();\n+                                        componentToPaint = rootPane;\n+\n+                                        \/\/ offset for the titlebar, if necessary:\n+                                        g.translate(rootPane.getX(), rootPane.getY());\n+                                    }\n+\n+                                    g.setClip(rect.x, rect.y, rect.width, rect.height);\n+                                    componentToPaint.paint(g);\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/RepaintManager.java","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,214 @@\n+\/*\n+ * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.*;\n+import java.awt.geom.RoundRectangle2D;\n+\n+import javax.swing.JComponent;\n+import javax.swing.SwingUtilities;\n+import javax.swing.*;\n+import javax.swing.border.EmptyBorder;\n+import javax.swing.plaf.PanelUI;\n+\n+\/* @test\n+ * @bug 8303950\n+ * @summary translucent windows flicker on repaint\n+ * @author Jeremy Wood\n+ * @key headful\n+ *\/\n+public class bug8303950 {\n+\n+    \/\/ pick two random and distinct colors:\n+    static final Color FLICKER_OF_BACKGROUND_COLOR = new Color(91, 152, 214);\n+    static final Color CORRECT_FOREGROUND_COLOR = new Color(119, 33, 236);\n+\n+    private static boolean TEST_FAILED = false;\n+\n+    public static void main(String[] args) throws Exception {\n+        SwingUtilities.invokeAndWait(new Runnable() {\n+            @Override\n+            public void run() {\n+                FlickerTestWindow flickeringWindow = new FlickerTestWindow();\n+                flickeringWindow.pack();\n+                flickeringWindow.setLocationRelativeTo(null);\n+\n+                \/\/ put a solid sheet under our test window. If we see this window's background color\n+                \/\/ we know our test is failing because there's a flicker.\n+\n+                JDialog backgroundWindow = new JDialog();\n+                backgroundWindow.getContentPane().setBackground(FLICKER_OF_BACKGROUND_COLOR);\n+                backgroundWindow.setBounds(flickeringWindow.getBounds());\n+                backgroundWindow.setVisible(true);\n+\n+                \/\/ now show our test window on top:\n+                flickeringWindow.setVisible(true);\n+                flickeringWindow.toFront();\n+\n+                Thread watcherThread = new Thread() {\n+                    @Override\n+                    public void run() {\n+                        waitUntilReady();\n+\n+                        \/\/ now grab the center pixel for 3 seconds and see if it ever flickers to reveal\n+                        \/\/ the background window:\n+                        Robot robot;\n+                        try {\n+                            robot = new Robot();\n+\n+                            int flickerSamples = 0;\n+                            int noFlickerSamples = 0;\n+                            int notSetupSamples = 0;\n+\n+                            Point loc = new Point(flickeringWindow.label.getLocationOnScreen());\n+                            loc.x += 150;\n+                            loc.y += 150;\n+                            long t = System.currentTimeMillis();\n+                            while (true) {\n+                                long elapsed = System.currentTimeMillis() - t;\n+                                if (elapsed > 3_000) {\n+                                    System.out.println(\"flicker samples: \" + flickerSamples);\n+                                    System.out.println(\"successful samples: \" + noFlickerSamples);\n+                                    if (notSetupSamples > 0) {\n+                                        System.out.println(\"setup failed samples: \" + notSetupSamples);\n+                                        System.out.println(\"This means the windows weren't configured correctly, or the Robot was unable to capture pixels.\");\n+                                    }\n+                                    if (notSetupSamples + flickerSamples > 0) {\n+                                        System.err.println(\"This test failed.\");\n+                                        TEST_FAILED = true;\n+                                    } else {\n+                                        System.out.println(\"This test passed.\");\n+                                        return;\n+                                    }\n+                                }\n+                                Color c = robot.getPixelColor(loc.x, loc.y);\n+                                if (matches(CORRECT_FOREGROUND_COLOR, c)) {\n+                                    noFlickerSamples++;\n+                                } else if (matches(FLICKER_OF_BACKGROUND_COLOR, c)) {\n+                                    flickerSamples++;\n+                                } else {\n+                                    notSetupSamples++;\n+                                }\n+                            }\n+                        } catch (AWTException e) {\n+                            e.printStackTrace();\n+                            TEST_FAILED = true;\n+                        }\n+                    }\n+\n+                    private void waitUntilReady() {\n+                        try {\n+                            Thread.sleep(500);\n+                        } catch (InterruptedException e) {\n+                            throw new RuntimeException(e);\n+                        }\n+\n+                        while (true) {\n+                            if (flickeringWindow.isShowing() && backgroundWindow.isShowing()) {\n+                                break;\n+                            }\n+                            Thread.yield();\n+                        }\n+                    }\n+\n+                    \/**\n+                     * Return true if two colors are very similar.\n+                     * <p>\n+                     * This exists because I don't get an exact match on the static\n+                     * colors in this test, but the RGB values we get back are recognizable\n+                     * close to what we're aiming for.\n+                     * <\/p>\n+                     *\/\n+                    private boolean matches(Color c1, Color c2) {\n+                        return Math.abs(c1.getRed() - c2.getRed()) +\n+                                Math.abs(c1.getGreen() - c2.getGreen()) +\n+                                Math.abs(c1.getBlue() - c2.getBlue()) < 60;\n+                    }\n+                };\n+                watcherThread.start();\n+            }\n+        });\n+        Thread.currentThread().sleep(5000);\n+        if (TEST_FAILED)\n+            throw new Exception(\"This test failed; see System.err for details.\");\n+    }\n+\n+    static class FlickerTestWindow extends JWindow {\n+        JTextPane instructions = new JTextPane();\n+        JLabel label = new JLabel();\n+\n+        public FlickerTestWindow() {\n+            instructions.setText(\"Instructions:\\nCheck if the center of the animation (which is constantly repainting) ever flickers.\");\n+            instructions.setBorder(new EmptyBorder(10, 10, 10, 10));\n+            instructions.setOpaque(false);\n+            instructions.setEditable(false);\n+\n+            setBackground(new Color(0,0,0,0));\n+\n+            JPanel p = new JPanel();\n+            p.setOpaque(false);\n+            p.setBorder(new EmptyBorder(10,10,10,10));\n+            p.setUI(new PanelUI() {\n+                @Override\n+                public void paint(Graphics g, JComponent c) {\n+                    Graphics2D g2 = (Graphics2D) g;\n+                    g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);\n+                    g2.setColor(new Color(220, 180, 0, 200));\n+                    g2.fill(new RoundRectangle2D.Double(0,0,c.getWidth(),c.getHeight(),20,20));\n+                    c.repaint();\n+                }\n+            });\n+            p.setLayout(new BorderLayout());\n+            p.add(instructions, BorderLayout.NORTH);\n+            p.add(label, BorderLayout.CENTER);\n+\n+            Icon icon = new Icon() {\n+                @Override\n+                public void paintIcon(Component c, Graphics g, int x, int y) {\n+                    int startAngle = (int)( (System.currentTimeMillis() % 1000) * 360 \/ 1000 );\n+\n+                    g.setColor(CORRECT_FOREGROUND_COLOR);\n+                    g.fillRect(x, y, getIconWidth(), getIconHeight());\n+\n+                    g.setColor(new Color(0,0,0,100));\n+                    ((Graphics2D)g).setStroke(new BasicStroke(8));\n+                    g.drawArc(10, 10, 280, 280, startAngle, 200);\n+\n+                    c.repaint();\n+                }\n+\n+                @Override\n+                public int getIconWidth() {\n+                    return 300;\n+                }\n+\n+                @Override\n+                public int getIconHeight() {\n+                    return 300;\n+                }\n+            };\n+            label.setIcon(icon);\n+\n+            getContentPane().add(p);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/RepaintManager\/8303950\/bug8303950.java","additions":214,"deletions":0,"binary":false,"changes":214,"status":"added"},{"patch":"@@ -0,0 +1,183 @@\n+\/*\n+ * Copyright (c) 2007, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.*;\n+import java.awt.geom.RoundRectangle2D;\n+import java.awt.image.BufferedImage;\n+import java.util.concurrent.Semaphore;\n+\n+import javax.swing.JComponent;\n+import javax.swing.SwingUtilities;\n+import javax.swing.*;\n+import javax.swing.border.EmptyBorder;\n+import javax.swing.plaf.PanelUI;\n+\n+\/* @test\n+ * @bug 8303950\n+ * @summary this codifies the preexisting behavior for Window\/JRootPane backgrounds. I want to be sure the resolution\n+ *          to 8303950 does not alter this behavior.\n+ * @key headful\n+ * @author Jeremy Wood\n+ *\/\n+public class bug8303950_legacyWindowPaintBehavior {\n+\n+    private static Color WINDOW_BACKGROUND = Color.red;\n+    private static Color ROOTPANE_BACKGROUND = Color.blue;\n+\n+    static boolean TEST_FAILED = false;\n+\n+    public static void main(String[] args) throws Exception {\n+        Semaphore semaphore = new Semaphore(1);\n+        semaphore.acquireUninterruptibly();\n+        SwingUtilities.invokeAndWait(new Runnable() {\n+            @Override\n+            public void run() {\n+                UIManager.getDefaults().put(\"Panel.background\", Color.green);\n+\n+                int x = 0;\n+                int y = 0;\n+\n+                GraphicsConfiguration gc = GraphicsEnvironment.getLocalGraphicsEnvironment().getDefaultScreenDevice().getDefaultConfiguration();\n+                Insets i = Toolkit.getDefaultToolkit().getScreenInsets(gc);\n+                x += i.left;\n+                y += i.top;\n+\n+                Window w1 = createWindow( WINDOW_BACKGROUND, null, x, y, 400, 400, false, \"window 1\");\n+                Window w2 = createWindow( WINDOW_BACKGROUND, ROOTPANE_BACKGROUND, x + 400, y, 400, 400, false, \"window 2\");\n+                Window w3 = createWindow( WINDOW_BACKGROUND, null, x, y + 400, 400, 400, true, \"window 3\");\n+                Window w4 =  createWindow( WINDOW_BACKGROUND, ROOTPANE_BACKGROUND, x + 400, y + 400, 400, 400, true, \"window 4\");\n+\n+                \/\/ using a white background helps keep the colors we detect constant (because some windows\n+                \/\/ are translucent)\n+                Window background = createWhiteBackground(w1, w2, w3, w4);\n+                w1.toFront();\n+                w2.toFront();\n+                w3.toFront();\n+                w4.toFront();\n+\n+                \/\/ So... one liability of this test is I'm unsure how to synchronize it really well. I'm open\n+                \/\/ to suggestions here. Currently I use a combination of a large (but fast) loop, calling\n+                \/\/ Window#repaint() and Toolkit#sync().\n+\n+                w1.repaint();\n+                w2.repaint();\n+                w3.repaint();\n+                w4.repaint();\n+\n+                SwingUtilities.invokeLater(new Runnable() {\n+                    int ctr = 0;\n+                    @Override\n+                    public void run() {\n+                        if (ctr == 0) {\n+                            Toolkit.getDefaultToolkit().sync();\n+                        }\n+                        while (ctr++ < 100_000) {\n+                            SwingUtilities.invokeLater(this);\n+                            return;\n+                        }\n+\n+                        try {\n+                            Robot robot = new Robot();\n+                            testColor(robot, w1, Color.green);\n+                            testColor(robot, w2, Color.green);\n+                            testColor(robot, w3, Color.red);\n+                            testColor(robot, w4, Color.blue);\n+                        } catch (AWTException e) {\n+                            throw new RuntimeException(e);\n+                        } finally {\n+                            semaphore.release();\n+                        }\n+                    }\n+\n+                    private void testColor(Robot robot, Window window, Color expectedColor) {\n+                        Color actual = robot.getPixelColor(window.getLocationOnScreen().x + window.getWidth() \/ 2, window.getLocationOnScreen().y + window.getHeight() \/ 2);\n+                        if (Math.abs(actual.getRed() - expectedColor.getRed()) > 150 ||\n+                                Math.abs(actual.getGreen() - expectedColor.getGreen()) > 150 ||\n+                                Math.abs(actual.getBlue() - expectedColor.getBlue()) > 150) {\n+                            System.err.println(\"name = \\\"\" + window.getName() + \"\\\" expected = \" + expectedColor + \", actual = \" + actual);\n+                            TEST_FAILED = true;\n+                        }\n+                    }\n+                });\n+            }\n+        });\n+        semaphore.acquireUninterruptibly();\n+        if (TEST_FAILED)\n+            throw new Exception(\"This test failed; see System.err for details.\");\n+    }\n+\n+    \/**\n+     * Create a white window behind a series of Windows\n+     *\/\n+    private static Window createWhiteBackground(Window... windows) {\n+        JWindow background = new JWindow();\n+\n+        Rectangle totalBounds = windows[0].getBounds();\n+        for (int a = 1; a < windows.length; a++) {\n+            totalBounds.add(windows[a].getBounds());\n+        }\n+\n+        background.pack();\n+        background.setBounds(totalBounds);\n+        background.setVisible(true);\n+\n+        background.setBackground(Color.white);\n+        background.getContentPane().setBackground(Color.white);\n+\n+        return background;\n+    }\n+\n+    private static JWindow createWindow(Color windowBackground, Color rootPaneBackground, int x, int y, int w, int h, boolean translucent, String name) {\n+        JWindow window = new JWindow();\n+        window.setName(name);\n+        if (translucent) {\n+            windowBackground = new Color(windowBackground.getRed(), windowBackground.getGreen(), windowBackground.getBlue(), 128);\n+            if (rootPaneBackground != null)\n+                rootPaneBackground = new Color(rootPaneBackground.getRed(), rootPaneBackground.getGreen(), rootPaneBackground.getBlue(), 128);\n+        }\n+        window.setBackground(windowBackground);\n+        if (rootPaneBackground != null)\n+            window.getRootPane().setBackground(rootPaneBackground);\n+\n+        window.getContentPane().setLayout(new BorderLayout());\n+        JTextArea text = new JTextArea(\"translucent = \" + translucent +\n+                \"\\nwindowBackground = \" + toString(windowBackground) +\n+                \"\\nrootPaneBackground = \" + toString(rootPaneBackground) +\n+                \"\\n\\\"Panel.background\\\" = \" + toString( (Color) UIManager.getDefaults().get(\"Panel.background\")));\n+        text.setOpaque(false);\n+        text.setEditable(false);\n+        window.getContentPane().add(text, BorderLayout.NORTH);\n+\n+        window.pack();\n+        window.setBounds(x,y,w,h);\n+        window.setVisible(true);\n+\n+        return window;\n+    }\n+\n+    private static String toString(Color color) {\n+        if (color == null)\n+            return \"null\";\n+        return \"#\" + Integer.toUnsignedString(color.getRGB(), 16);\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/RepaintManager\/8303950\/bug8303950_legacyWindowPaintBehavior.java","additions":183,"deletions":0,"binary":false,"changes":183,"status":"added"}]}