{"files":[{"patch":"@@ -532,1 +532,1 @@\n-  return buffer != nullptr ? buffer : JfrTraceIdLoadBarrier::renew_enqueue_buffer(this);\n+  return buffer != nullptr ? renew_if_full(buffer) : JfrTraceIdLoadBarrier::renew_enqueue_buffer(this);\n@@ -550,0 +550,7 @@\n+  \/\/ Explicitly monitor the available space of the thread-local buffer used for enqueuing klasses as part of tagging methods.\n+  \/\/ We do this because if space becomes sparse, we cannot rely on the implicit allocation of a new buffer as part of the\n+  \/\/ regular tag mechanism. If the free list is empty, a malloc could result, and the problem with that is that the thread\n+  \/\/ we have suspended could be the holder of the malloc lock. Instead, the buffer is pre-emptively renewed before thread suspension.\n+  const JfrBuffer* enqueue_buffer = get_enqueue_buffer();\n+  assert(enqueue_buffer != nullptr, \"invariant\");\n+\n@@ -560,9 +567,0 @@\n-\n-      \/\/ Explicitly monitor the available space of the thread-local buffer used for enqueuing klasses as part of tagging methods.\n-      \/\/ We do this because if space becomes sparse, we cannot rely on the implicit allocation of a new buffer as part of the\n-      \/\/ regular tag mechanism. If the free list is empty, a malloc could result, and the problem with that is that the thread\n-      \/\/ we have suspended could be the holder of the malloc lock. Instead, the buffer is pre-emptively renewed before thread suspension.\n-      const JfrBuffer* enqueue_buffer = get_enqueue_buffer();\n-      assert(enqueue_buffer != nullptr, \"invariant\");\n-      enqueue_buffer = renew_if_full(enqueue_buffer);\n-\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrThreadSampler.cpp","additions":8,"deletions":10,"binary":false,"changes":18,"status":"modified"}]}