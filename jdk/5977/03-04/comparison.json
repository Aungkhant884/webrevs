{"files":[{"patch":"@@ -549,8 +549,0 @@\n-\n-  \/\/ Explicitly monitor the available space of the thread-local buffer used for enqueuing klasses as part of tagging methods.\n-  \/\/ We do this because if space becomes sparse, we cannot rely on the implicit allocation of a new buffer as part of the\n-  \/\/ regular tag mechanism. If the free list is empty, a malloc could result, and the problem with that is that the thread\n-  \/\/ we have suspended could be the holder of the malloc lock. Instead, the buffer is pre-emptively renewed before thread suspension.\n-  const JfrBuffer* enqueue_buffer = get_enqueue_buffer();\n-  assert(enqueue_buffer != nullptr, \"invariant\");\n-\n@@ -567,0 +559,8 @@\n+\n+      \/\/ Explicitly monitor the available space of the thread-local buffer used for enqueuing klasses as part of tagging methods.\n+      \/\/ We do this because if space becomes sparse, we cannot rely on the implicit allocation of a new buffer as part of the\n+      \/\/ regular tag mechanism. If the free list is empty, a malloc could result, and the problem with that is that the thread\n+      \/\/ we have suspended could be the holder of the malloc lock. Instead, the buffer is pre-emptively renewed before thread suspension.\n+      const JfrBuffer* enqueue_buffer = get_enqueue_buffer();\n+      assert(enqueue_buffer != nullptr, \"invariant\");\n+\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrThreadSampler.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+  assert(this->thread_local_storage(thread) == buffer, \"invariant\");\n","filename":"src\/hotspot\/share\/jfr\/utilities\/jfrEpochQueue.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}