{"files":[{"patch":"@@ -649,1 +649,1 @@\n-    switch( bc ) {\n+    switch (bc) {\n@@ -668,1 +668,1 @@\n-        if( bcs.dest() < bcs.next_bci() ) _access_flags.set_has_loops();\n+        if (bcs.dest() < bcs.next_bci()) _access_flags.set_has_loops();\n@@ -673,1 +673,1 @@\n-        if( bcs.dest_w() < bcs.next_bci() ) _access_flags.set_has_loops();\n+        if (bcs.dest_w() < bcs.next_bci()) _access_flags.set_has_loops();\n@@ -676,0 +676,28 @@\n+      case Bytecodes::_lookupswitch: {\n+        Bytecode_lookupswitch lookupswitch(this, bcs.bcp());\n+        if (lookupswitch.default_offset() < 0) {\n+          _access_flags.set_has_loops();\n+        } else {\n+          for (int i = 0; i < lookupswitch.number_of_pairs(); ++i) {\n+            LookupswitchPair pair = lookupswitch.pair_at(i);\n+            if (pair.offset() < 0) {\n+              _access_flags.set_has_loops();\n+              break;\n+            }\n+          }\n+        }\n+        break;\n+      }\n+      case Bytecodes::_tableswitch: {\n+        Bytecode_tableswitch tableswitch(this, bcs.bcp());\n+        if (tableswitch.default_offset() < 0) {\n+          _access_flags.set_has_loops();\n+        } else {\n+          for (int i = 0; i < tableswitch.length(); ++i) {\n+            if (tableswitch.dest_offset_at(i) < 0) {\n+              _access_flags.set_has_loops();\n+            }\n+          }\n+        }\n+        break;\n+      }\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":31,"deletions":3,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -459,1 +459,0 @@\n-    C->set_has_loops(C->has_loops() || _inline_cg->method()->has_loops());\n","filename":"src\/hotspot\/share\/opto\/callGenerator.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -925,1 +925,1 @@\n-  set_has_loops(has_method() && method()->has_loops()); \/\/ first approximation\n+  set_has_loops(false); \/\/ first approximation\n@@ -1025,0 +1025,1 @@\n+  _exception_backedge = false;\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -432,0 +432,1 @@\n+  DEBUG_ONLY(bool _exception_backedge;)\n@@ -1169,0 +1170,2 @@\n+  void set_exception_backedge() { _exception_backedge = true; }\n+  bool has_exception_backedge() const { return _exception_backedge; }\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -660,1 +660,0 @@\n-    C->set_has_loops(C->has_loops() || cg->method()->has_loops());\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2918,0 +2918,25 @@\n+#ifdef ASSERT\n+bool PhaseIdealLoop::only_has_infinite_loops() {\n+  for (LoopTreeIterator iter(_ltree_root); !iter.done(); iter.next()) {\n+    IdealLoopTree* lpt = iter.current();\n+    if (lpt->is_innermost()) {\n+      uint i = 1;\n+      for (; i < C->root()->req(); i++) {\n+        Node* in = C->root()->in(i);\n+        if (in != NULL &&\n+            in->Opcode() == Op_Halt &&\n+            in->in(0)->is_Proj() &&\n+            in->in(0)->in(0)->Opcode() == Op_NeverBranch &&\n+            in->in(0)->in(0)->in(0) == lpt->_head) {\n+          break;\n+        }\n+      }\n+      if (i == C->root()->req()) {\n+        return false;\n+      }\n+    }\n+  }\n+  return true;\n+}\n+#endif\n+\n@@ -2973,0 +2998,7 @@\n+  \/\/ Verify that the has_loops() flag set at parse time is consistent\n+  \/\/ with the just built loop tree. With infinite loops, it could be\n+  \/\/ that one pass of loop opts only finds infinite loops, clears the\n+  \/\/ has_loops() flag but adds NeverBranch nodes so the next loop opts\n+  \/\/ verification pass finds a non empty loop tree. When the back edge\n+  \/\/ is an exception edge, parsing doesn't set has_loops().\n+  assert(_ltree_root->_child == NULL || C->has_loops() || only_has_infinite_loops() || C->has_exception_backedge(), \"parsing found no loops but there are some\");\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":32,"deletions":0,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -806,0 +806,3 @@\n+#ifdef ASSERT\n+  bool only_has_infinite_loops();\n+#endif\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -438,0 +438,1 @@\n+  C->set_has_loops(C->has_loops() || method()->has_loops());\n@@ -1602,0 +1603,5 @@\n+#ifdef ASSERT\n+  if (target_bci < bci()) {\n+    C->set_exception_backedge();\n+  }\n+#endif\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1213,0 +1213,1 @@\n+    C->set_has_loops(true);\n@@ -1290,0 +1291,1 @@\n+  C->set_has_loops(true);\n","filename":"src\/hotspot\/share\/opto\/stringopts.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}