{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import java.util.Map;\n+import java.util.Objects;\n+\n@@ -51,1 +54,1 @@\n-    public int start();\n+    int start();\n@@ -77,1 +80,38 @@\n-    public int start(int group);\n+    int start(int group);\n+\n+    \/**\n+     * Returns the start index of the subsequence captured by the given\n+     * <a href=\"Pattern.html#groupname\">named-capturing group<\/a> during the\n+     * previous match operation.\n+     *\n+     * @param  name\n+     *         The name of a named-capturing group in this matcher's pattern\n+     *\n+     * @return  The index of the first character captured by the group,\n+     *          or {@code -1} if the match was successful but the group\n+     *          itself did not match anything\n+     *\n+     * @throws  IllegalStateException\n+     *          If no match has yet been attempted,\n+     *          or if the previous match operation failed\n+     *\n+     * @throws  IllegalArgumentException\n+     *          If there is no capturing group in the pattern\n+     *          with the given name\n+     *\n+     * @implNote\n+     * The default implementation of this method makes use of the map returned\n+     * by {@link #namedGroups()}. It is thus sufficient to override\n+     * {@link #namedGroups()} for this method to work. However, overriding this\n+     * method directly might be preferable for performance or for other reasons.\n+     *\n+     * @implSpec\n+     * The default implementation of this method throws\n+     * {@link UnsupportedOperationException} if {@link #namedGroups()} is not\n+     * overridden.\n+     *\n+     * @since 20\n+     *\/\n+    default int start(String name) {\n+        return start(groupIndex(name));\n+    }\n@@ -88,1 +128,1 @@\n-    public int end();\n+    int end();\n@@ -114,1 +154,38 @@\n-    public int end(int group);\n+    int end(int group);\n+\n+    \/**\n+     * Returns the offset after the last character of the subsequence\n+     * captured by the given <a href=\"Pattern.html#groupname\">named-capturing\n+     * group<\/a> during the previous match operation.\n+     *\n+     * @param  name\n+     *         The name of a named-capturing group in this matcher's pattern\n+     *\n+     * @return  The offset after the last character captured by the group,\n+     *          or {@code -1} if the match was successful\n+     *          but the group itself did not match anything\n+     *\n+     * @throws  IllegalStateException\n+     *          If no match has yet been attempted,\n+     *          or if the previous match operation failed\n+     *\n+     * @throws  IllegalArgumentException\n+     *          If there is no capturing group in the pattern\n+     *          with the given name\n+     *\n+     * @implNote\n+     * The default implementation of this method makes use of the map returned\n+     * by {@link #namedGroups()}. It is thus sufficient to override\n+     * {@link #namedGroups()} for this method to work. However, overriding this\n+     * method directly might be preferable for performance or for other reasons.\n+     *\n+     * @implSpec\n+     * The default implementation of this method throws\n+     * {@link UnsupportedOperationException} if {@link #namedGroups()} is not\n+     * overridden.\n+     *\n+     * @since 20\n+     *\/\n+    default int end(String name) {\n+        return end(groupIndex(name));\n+    }\n@@ -135,1 +212,1 @@\n-    public String group();\n+    String group();\n@@ -173,1 +250,44 @@\n-    public String group(int group);\n+    String group(int group);\n+\n+    \/**\n+     * Returns the input subsequence captured by the given\n+     * <a href=\"Pattern.html#groupname\">named-capturing group<\/a> during the\n+     * previous match operation.\n+     *\n+     * <p> If the match was successful but the group specified failed to match\n+     * any part of the input sequence, then {@code null} is returned. Note\n+     * that some groups, for example {@code (a*)}, match the empty string.\n+     * This method will return the empty string when such a group successfully\n+     * matches the empty string in the input.  <\/p>\n+     *\n+     * @param  name\n+     *         The name of a named-capturing group in this matcher's pattern\n+     *\n+     * @return  The (possibly empty) subsequence captured by the named group\n+     *          during the previous match, or {@code null} if the group\n+     *          failed to match part of the input\n+     *\n+     * @throws  IllegalStateException\n+     *          If no match has yet been attempted,\n+     *          or if the previous match operation failed\n+     *\n+     * @throws  IllegalArgumentException\n+     *          If there is no capturing group in the pattern\n+     *          with the given name\n+     *\n+     * @implNote\n+     * The default implementation of this method makes use of the map returned\n+     * by {@link #namedGroups()}. It is thus sufficient to override\n+     * {@link #namedGroups()} for this method to work. However, overriding this\n+     * method directly might be preferable for performance or for other reasons.\n+     *\n+     * @implSpec\n+     * The default implementation of this method throws\n+     * {@link UnsupportedOperationException} if {@link #namedGroups()} is not\n+     * overridden.\n+     *\n+     * @since 20\n+     *\/\n+    default String group(String name) {\n+        return group(groupIndex(name));\n+    }\n@@ -187,1 +307,48 @@\n-    public int groupCount();\n+    int groupCount();\n+\n+    \/**\n+     * Returns an unmodifiable map from capturing group names to group numbers.\n+     * If there are no named groups, returns an empty map.\n+     *\n+     * @return an unmodifiable map from capturing group names to group numbers\n+     *\n+     * @implSpec\n+     * The default implementation of this method throws\n+     * {@link UnsupportedOperationException}.\n+     *\n+     * @apiNote\n+     * This method must be overridden by an implementation that supports named groups.\n+     *\n+     * @since 20\n+     *\/\n+    default Map<String,Integer> namedGroups() {\n+        throw new UnsupportedOperationException(\"namedGroups()\");\n+    }\n+\n+    private int groupIndex(String name) {\n+        Objects.requireNonNull(name, \"Group name\");\n+        Integer index = namedGroups().get(name);\n+        if (index != null) {\n+            return index;\n+        }\n+        throw new IllegalArgumentException(\"No group with name <\" + name + \">\");\n+    }\n+\n+    \/**\n+     * Returns whether {@code this} contains a valid match from\n+     * a previous match or find operation.\n+     *\n+     * @return whether {@code this} contains a valid match\n+     *\n+     * @implSpec\n+     * The default implementation of this method throws\n+     * {@link UnsupportedOperationException}.\n+     *\n+     * @apiNote\n+     * This method must be overridden by an implementation.\n+     *\n+     * @since 20\n+     *\/\n+    default boolean hasMatch() {\n+        throw new UnsupportedOperationException(\"hasMatch()\");\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/util\/regex\/MatchResult.java","additions":175,"deletions":8,"binary":false,"changes":183,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.util.Map;\n@@ -232,0 +233,2 @@\n+    private Map<String, Integer> namedGroups;\n+\n@@ -281,1 +284,2 @@\n-                                        text);\n+                                        text,\n+                                        namedGroups());\n@@ -290,0 +294,1 @@\n+        private final Map<String, Integer> namedGroups;\n@@ -292,1 +297,2 @@\n-                             int[] groups, String text)\n+                             int[] groups, String text,\n+                             Map<String, Integer> namedGroups)\n@@ -299,0 +305,1 @@\n+            this.namedGroups = namedGroups;\n@@ -310,2 +317,1 @@\n-            if (group < 0 || group > groupCount)\n-                throw new IndexOutOfBoundsException(\"No group \" + group);\n+            checkGroup(group);\n@@ -324,2 +330,1 @@\n-            if (group < 0 || group > groupCount)\n-                throw new IndexOutOfBoundsException(\"No group \" + group);\n+            checkGroup(group);\n@@ -343,3 +348,2 @@\n-            if (group < 0 || group > groupCount)\n-                throw new IndexOutOfBoundsException(\"No group \" + group);\n-            if ((groups[group*2] == -1) || (groups[group*2+1] == -1))\n+            checkGroup(group);\n+            if ((groups[group * 2] == -1) || (groups[group * 2 + 1] == -1))\n@@ -350,0 +354,15 @@\n+        @Override\n+        public Map<String, Integer> namedGroups() {\n+            return namedGroups;\n+        }\n+\n+        @Override\n+        public boolean hasMatch() {\n+            return first >= 0;\n+        }\n+\n+        private void checkGroup(int group) {\n+            if (group < 0 || group > groupCount)\n+                throw new IndexOutOfBoundsException(\"No group \" + group);\n+        }\n+\n@@ -351,1 +370,1 @@\n-            if (first < 0)\n+            if (!hasMatch())\n@@ -355,0 +374,1 @@\n+\n@@ -449,2 +469,1 @@\n-        if (first < 0)\n-            throw new IllegalStateException(\"No match available\");\n+        checkMatch();\n@@ -479,4 +498,2 @@\n-        if (first < 0)\n-            throw new IllegalStateException(\"No match available\");\n-        if (group < 0 || group > groupCount())\n-            throw new IndexOutOfBoundsException(\"No group \" + group);\n+        checkMatch();\n+        checkGroup(group);\n@@ -521,2 +538,1 @@\n-        if (first < 0)\n-            throw new IllegalStateException(\"No match available\");\n+        checkMatch();\n@@ -551,4 +567,2 @@\n-        if (first < 0)\n-            throw new IllegalStateException(\"No match available\");\n-        if (group < 0 || group > groupCount())\n-            throw new IndexOutOfBoundsException(\"No group \" + group);\n+        checkMatch();\n+        checkGroup(group);\n@@ -643,4 +657,2 @@\n-        if (first < 0)\n-            throw new IllegalStateException(\"No match found\");\n-        if (group < 0 || group > groupCount())\n-            throw new IndexOutOfBoundsException(\"No group \" + group);\n+        checkMatch();\n+        checkGroup(group);\n@@ -903,3 +915,1 @@\n-        \/\/ If no match, return error\n-        if (first < 0)\n-            throw new IllegalStateException(\"No match available\");\n+        checkMatch();\n@@ -994,2 +1004,1 @@\n-        if (first < 0)\n-            throw new IllegalStateException(\"No match available\");\n+        checkMatch();\n@@ -1058,1 +1067,1 @@\n-                    if (!parentPattern.namedGroups().containsKey(gname))\n+                    if (!namedGroups().containsKey(gname))\n@@ -1061,1 +1070,1 @@\n-                    refNum = parentPattern.namedGroups().get(gname);\n+                    refNum = namedGroups().get(gname);\n@@ -1799,3 +1808,2 @@\n-        if (first < 0)\n-            throw new IllegalStateException(\"No match found\");\n-        if (!parentPattern.namedGroups().containsKey(name))\n+        checkMatch();\n+        if (!namedGroups().containsKey(name))\n@@ -1803,1 +1811,38 @@\n-        return parentPattern.namedGroups().get(name);\n+        return namedGroups().get(name);\n+    }\n+\n+    private void checkGroup(int group) {\n+        if (group < 0 || group > groupCount())\n+            throw new IndexOutOfBoundsException(\"No group \" + group);\n+    }\n+\n+    private void checkMatch() {\n+        if (!hasMatch())\n+            throw new IllegalStateException(\"No match found\");\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @return {@inheritDoc}\n+     *\n+     * @since {@inheritDoc}\n+     *\/\n+    @Override\n+    public Map<String, Integer> namedGroups() {\n+        if (namedGroups == null) {\n+            return namedGroups = parentPattern.namedGroups();\n+        }\n+        return namedGroups;\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @return {@inheritDoc}\n+     *\n+     * @since {@inheritDoc}\n+     *\/\n+    @Override\n+    public boolean hasMatch() {\n+        return first >= 0;\n@@ -1805,0 +1850,1 @@\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/regex\/Matcher.java","additions":84,"deletions":38,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -1845,1 +1845,1 @@\n-    Map<String, Integer> namedGroups() {\n+    private Map<String, Integer> namedGroupsMap() {\n@@ -1853,0 +1853,12 @@\n+    \/**\n+     * Returns an unmodifiable map from capturing group names to group numbers.\n+     * If there are no named groups, returns an empty map.\n+     *\n+     * @return an unmodifiable map from capturing group names to group numbers\n+     *\n+     * @since 20\n+     *\/\n+    public Map<String, Integer> namedGroups() {\n+        return Map.copyOf(namedGroupsMap());\n+    }\n+\n@@ -2556,1 +2568,1 @@\n-            if (!namedGroups().containsKey(name))\n+            if (!namedGroupsMap().containsKey(name))\n@@ -2561,1 +2573,1 @@\n-                    root = new CIBackRef(namedGroups().get(name), has(UNICODE_CASE));\n+                    root = new CIBackRef(namedGroupsMap().get(name), has(UNICODE_CASE));\n@@ -2563,1 +2575,1 @@\n-                    root = new BackRef(namedGroups().get(name));\n+                    root = new BackRef(namedGroupsMap().get(name));\n@@ -3010,1 +3022,1 @@\n-                        if (namedGroups().containsKey(name))\n+                        if (namedGroupsMap().containsKey(name))\n@@ -3016,1 +3028,1 @@\n-                        namedGroups().put(name, capturingGroupCount - 1);\n+                        namedGroupsMap().put(name, capturingGroupCount - 1);\n","filename":"src\/java.base\/share\/classes\/java\/util\/regex\/Pattern.java","additions":18,"deletions":6,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,277 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8065554\n+ * @run main NamedGroupsTests\n+ *\/\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.MatchResult;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+public class NamedGroupsTests {\n+\n+    public static void main(String[] args) {\n+        testPatternNamedGroups();\n+        testMatcherNamedGroups();\n+        testMatchResultNamedGroups();\n+\n+        testMatcherHasMatch();\n+        testMatchResultHasMatch();\n+\n+        testMatchResultStartEndGroup();\n+    }\n+\n+    private static void testMatchResultStartEndGroup() {\n+        testMatchResultStartEndGroup1();\n+        testMatchResultStartEndGroup2();\n+        testMatchResultStartEndGroup3();\n+        testMatchResultStartEndGroup4();\n+    }\n+\n+    private static void testMatchResultStartEndGroup1() {\n+        List<MatchResult> list = Pattern.compile(\"(?<some>.+?)(?<rest>.*)\").matcher(\"\")\n+                .results().toList();\n+        for (var result : list) {\n+            if (result.start(\"some\") >= 0) {\n+                throw new RuntimeException(\"start(\\\"some\\\")\");\n+            }\n+            if (result.start(\"rest\") >= 0) {\n+                throw new RuntimeException(\"start(\\\"rest\\\")\");\n+            }\n+            if (result.end(\"some\") >= 0) {\n+                throw new RuntimeException(\"end(\\\"some\\\")\");\n+            }\n+            if (result.end(\"rest\") >= 0) {\n+                throw new RuntimeException(\"end(\\\"rest\\\")\");\n+            }\n+            if (result.group(\"some\") != null) {\n+                throw new RuntimeException(\"group(\\\"some\\\")\");\n+            }\n+            if (result.group(\"rest\") != null) {\n+                throw new RuntimeException(\"group(\\\"rest\\\")\");\n+            }\n+        }\n+    }\n+\n+    private static void testMatchResultStartEndGroup2() {\n+        List<MatchResult> list = Pattern.compile(\"(?<some>.+?)(?<rest>.*)\").matcher(\"abc\")\n+                .results().toList();\n+        for (var result : list) {\n+            if (result.start(\"some\") < 0) {\n+                throw new RuntimeException(\"start(\\\"some\\\")\");\n+            }\n+            if (result.start(\"rest\") < 0) {\n+                throw new RuntimeException(\"start(\\\"rest\\\")\");\n+            }\n+            if (result.end(\"some\") < 0) {\n+                throw new RuntimeException(\"end(\\\"some\\\")\");\n+            }\n+            if (result.end(\"rest\") < 0) {\n+                throw new RuntimeException(\"end(\\\"rest\\\")\");\n+            }\n+            if (result.group(\"some\") == null) {\n+                throw new RuntimeException(\"group(\\\"some\\\")\");\n+            }\n+            if (result.group(\"rest\") == null) {\n+                throw new RuntimeException(\"group(\\\"rest\\\")\");\n+            }\n+        }\n+    }\n+\n+    private static void testMatchResultStartEndGroup3() {\n+        Pattern.compile(\"(?<some>.+?)(?<rest>.*)\").matcher(\"\")\n+                .results()\n+                .forEach(r -> {\n+                        try {\n+                            r.start(\"noSuchGroup\");\n+                            r.end(\"noSuchGroup\");\n+                            r.group(\"noSuchGroup\");\n+                        } catch (IllegalArgumentException e) {  \/\/ swallowing intended\n+                        }\n+                    });\n+    }\n+\n+    private static void testMatchResultStartEndGroup4() {\n+        List<MatchResult> list = Pattern.compile(\"(?<some>.+?)(?<rest>.*)\").matcher(\"abc\")\n+                .results().toList();\n+        for (var result : list) {\n+            try {\n+                result.start(\"noSuchGroup\");\n+                result.end(\"noSuchGroup\");\n+                result.group(\"noSuchGroup\");\n+            } catch (IllegalArgumentException e) {  \/\/ swallowing intended\n+            }\n+        }\n+    }\n+\n+    private static void testMatchResultHasMatch() {\n+        testMatchResultHasMatch1();\n+        testMatchResultHasMatch2();\n+    }\n+\n+    private static void testMatchResultHasMatch1() {\n+        Matcher m = Pattern.compile(\".+\").matcher(\"\");\n+        m.find();\n+        if (m.toMatchResult().hasMatch()) {\n+            throw new RuntimeException();\n+        };\n+    }\n+\n+    private static void testMatchResultHasMatch2() {\n+        Matcher m = Pattern.compile(\".+\").matcher(\"abc\");\n+        m.find();\n+        if (!m.toMatchResult().hasMatch()) {\n+            throw new RuntimeException();\n+        };\n+    }\n+\n+    private static void testMatcherHasMatch() {\n+        testMatcherHasMatch1();\n+        testMatcherHasMatch2();\n+    }\n+\n+    private static void testMatcherHasMatch1() {\n+        Matcher m = Pattern.compile(\".+\").matcher(\"\");\n+        m.find();\n+        if (m.hasMatch()) {\n+            throw new RuntimeException();\n+        };\n+    }\n+\n+    private static void testMatcherHasMatch2() {\n+        Matcher m = Pattern.compile(\".+\").matcher(\"abc\");\n+        m.find();\n+        if (!m.hasMatch()) {\n+            throw new RuntimeException();\n+        };\n+    }\n+\n+    private static void testMatchResultNamedGroups() {\n+        testMatchResultNamedGroups1();\n+        testMatchResultNamedGroups2();\n+        testMatchResultNamedGroups3();\n+        testMatchResultNamedGroups4();\n+    }\n+\n+    private static void testMatchResultNamedGroups1() {\n+        if (!Pattern.compile(\".*\").matcher(\"\")\n+                .toMatchResult().namedGroups().isEmpty()) {\n+            throw new RuntimeException();\n+        };\n+    }\n+\n+    private static void testMatchResultNamedGroups2() {\n+        if (!Pattern.compile(\"(.*)\").matcher(\"\")\n+                .toMatchResult().namedGroups().isEmpty()) {\n+            throw new RuntimeException();\n+        };\n+    }\n+\n+    private static void testMatchResultNamedGroups3() {\n+        if (!Pattern.compile(\"(?<all>.*)\").matcher(\"\")\n+                .toMatchResult().namedGroups()\n+                .equals(Map.of(\"all\", 1))) {\n+            throw new RuntimeException();\n+        };\n+    }\n+\n+    private static void testMatchResultNamedGroups4() {\n+        if (!Pattern.compile(\"(?<some>.+?)(?<rest>.*)\").matcher(\"\")\n+                .toMatchResult().namedGroups()\n+                .equals(Map.of(\"some\", 1, \"rest\", 2))) {\n+            throw new RuntimeException();\n+        };\n+    }\n+\n+    private static void testMatcherNamedGroups() {\n+        testmatcherNamedGroups1();\n+        testMatcherNamedGroups2();\n+        testMatcherNamedGroups3();\n+        testMatcherNamedGroups4();\n+    }\n+\n+    private static void testmatcherNamedGroups1() {\n+        if (!Pattern.compile(\".*\").matcher(\"\").namedGroups().isEmpty()) {\n+            throw new RuntimeException();\n+        };\n+    }\n+\n+    private static void testMatcherNamedGroups2() {\n+        if (!Pattern.compile(\"(.*)\").matcher(\"\").namedGroups().isEmpty()) {\n+            throw new RuntimeException();\n+        };\n+    }\n+\n+    private static void testMatcherNamedGroups3() {\n+        if (!Pattern.compile(\"(?<all>.*)\").matcher(\"\").namedGroups()\n+                .equals(Map.of(\"all\", 1))) {\n+            throw new RuntimeException();\n+        };\n+    }\n+\n+    private static void testMatcherNamedGroups4() {\n+        if (!Pattern.compile(\"(?<some>.+?)(?<rest>.*)\").matcher(\"\").namedGroups()\n+                .equals(Map.of(\"some\", 1, \"rest\", 2))) {\n+            throw new RuntimeException();\n+        };\n+    }\n+\n+    private static void testPatternNamedGroups() {\n+        testPatternNamedGroups1();\n+        testPatternNamedGroups2();\n+        testPatternNamedGroups3();\n+        testPatternNamedGroups4();\n+    }\n+\n+    private static void testPatternNamedGroups1() {\n+        if (!Pattern.compile(\".*\").namedGroups().isEmpty()) {\n+            throw new RuntimeException();\n+        };\n+    }\n+\n+    private static void testPatternNamedGroups2() {\n+        if (!Pattern.compile(\"(.*)\").namedGroups().isEmpty()) {\n+            throw new RuntimeException();\n+        };\n+    }\n+\n+    private static void testPatternNamedGroups3() {\n+        if (!Pattern.compile(\"(?<all>.*)\").namedGroups()\n+                .equals(Map.of(\"all\", 1))) {\n+            throw new RuntimeException();\n+        };\n+    }\n+\n+    private static void testPatternNamedGroups4() {\n+        if (!Pattern.compile(\"(?<some>.+?)(?<rest>.*)\").namedGroups()\n+                .equals(Map.of(\"some\", 1, \"rest\", 2))) {\n+            throw new RuntimeException();\n+        };\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/util\/regex\/NamedGroupsTests.java","additions":277,"deletions":0,"binary":false,"changes":277,"status":"added"}]}