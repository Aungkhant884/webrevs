{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import java.util.Map;\n+import java.util.Objects;\n+\n@@ -36,0 +39,9 @@\n+ * @implNote\n+ * Support for named groups is implemented by the default methods\n+ * {@link #start(String)}, {@link #end(String)} and {@link #group(String)}.\n+ * They all make use of the map returned by {@link #namedGroups()}, whose\n+ * default implementation simply throws {@link UnsupportedOperationException}.\n+ * It is thus sufficient to override {@link #namedGroups()} for these methods\n+ * to work. However, overriding them directly might be preferable for\n+ * performance or other reasons.\n+ *\n@@ -51,1 +63,1 @@\n-    public int start();\n+    int start();\n@@ -77,1 +89,36 @@\n-    public int start(int group);\n+    int start(int group);\n+\n+    \/**\n+     * Returns the start index of the subsequence captured by the given\n+     * <a href=\"Pattern.html#groupname\">named-capturing group<\/a> during the\n+     * previous match operation.\n+     *\n+     * @param  name\n+     *         The name of a named-capturing group in this matcher's pattern\n+     *\n+     * @return  The index of the first character captured by the group,\n+     *          or {@code -1} if the match was successful but the group\n+     *          itself did not match anything\n+     *\n+     * @throws  IllegalStateException\n+     *          If no match has yet been attempted,\n+     *          or if the previous match operation failed\n+     *\n+     * @throws  IllegalArgumentException\n+     *          If there is no capturing group in the pattern\n+     *          with the given name\n+     *\n+     * @throws UnsupportedOperationException\n+     *          If the default implementation of {@link #namedGroups()}\n+     *          is not overridden.\n+     *\n+     * @implSpec\n+     * The default implementation of this method invokes {@link #namedGroups()}\n+     * to obtain the group number from the {@code name} argument, and uses this\n+     * number as argument to an invocation of {@link #start(int)}.\n+     *\n+     * @since 20\n+     *\/\n+    default int start(String name) {\n+        return start(groupNumber(name));\n+    }\n@@ -88,1 +135,1 @@\n-    public int end();\n+    int end();\n@@ -114,1 +161,36 @@\n-    public int end(int group);\n+    int end(int group);\n+\n+    \/**\n+     * Returns the offset after the last character of the subsequence\n+     * captured by the given <a href=\"Pattern.html#groupname\">named-capturing\n+     * group<\/a> during the previous match operation.\n+     *\n+     * @param  name\n+     *         The name of a named-capturing group in this matcher's pattern\n+     *\n+     * @return  The offset after the last character captured by the group,\n+     *          or {@code -1} if the match was successful\n+     *          but the group itself did not match anything\n+     *\n+     * @throws  IllegalStateException\n+     *          If no match has yet been attempted,\n+     *          or if the previous match operation failed\n+     *\n+     * @throws  IllegalArgumentException\n+     *          If there is no capturing group in the pattern\n+     *          with the given name\n+     *\n+     * @throws UnsupportedOperationException\n+     *          If the default implementation of {@link #namedGroups()}\n+     *          is not overridden.\n+     *\n+     * @implSpec\n+     * The default implementation of this method invokes {@link #namedGroups()}\n+     * to obtain the group number from the {@code name} argument, and uses this\n+     * number as argument to an invocation of {@link #end(int)}.\n+     *\n+     * @since 20\n+     *\/\n+    default int end(String name) {\n+        return end(groupNumber(name));\n+    }\n@@ -135,1 +217,1 @@\n-    public String group();\n+    String group();\n@@ -173,1 +255,42 @@\n-    public String group(int group);\n+    String group(int group);\n+\n+    \/**\n+     * Returns the input subsequence captured by the given\n+     * <a href=\"Pattern.html#groupname\">named-capturing group<\/a> during the\n+     * previous match operation.\n+     *\n+     * <p> If the match was successful but the group specified failed to match\n+     * any part of the input sequence, then {@code null} is returned. Note\n+     * that some groups, for example {@code (a*)}, match the empty string.\n+     * This method will return the empty string when such a group successfully\n+     * matches the empty string in the input.  <\/p>\n+     *\n+     * @param  name\n+     *         The name of a named-capturing group in this matcher's pattern\n+     *\n+     * @return  The (possibly empty) subsequence captured by the named group\n+     *          during the previous match, or {@code null} if the group\n+     *          failed to match part of the input\n+     *\n+     * @throws  IllegalStateException\n+     *          If no match has yet been attempted,\n+     *          or if the previous match operation failed\n+     *\n+     * @throws  IllegalArgumentException\n+     *          If there is no capturing group in the pattern\n+     *          with the given name\n+     *\n+     * @throws UnsupportedOperationException\n+     *          If the default implementation of {@link #namedGroups()}\n+     *          is not overridden.\n+     *\n+     * @implSpec\n+     * The default implementation of this method invokes {@link #namedGroups()}\n+     * to obtain the group number from the {@code name} argument, and uses this\n+     * number as argument to an invocation of {@link #group(int)}.\n+     *\n+     * @since 20\n+     *\/\n+    default String group(String name) {\n+        return group(groupNumber(name));\n+    }\n@@ -187,1 +310,44 @@\n-    public int groupCount();\n+    int groupCount();\n+\n+    \/**\n+     * Returns an unmodifiable map from capturing group names to group numbers.\n+     * If there are no named groups, returns an empty map.\n+     *\n+     * @return an unmodifiable map from capturing group names to group numbers\n+     *\n+     * @throws UnsupportedOperationException\n+     *          The default implementation of this method always throws\n+     *\n+     * @apiNote\n+     * This method must be overridden by an implementation that supports\n+     * named groups.\n+     *\n+     * @since 20\n+     *\/\n+    default Map<String,Integer> namedGroups() {\n+        throw new UnsupportedOperationException(\"namedGroups()\");\n+    }\n+\n+    private int groupNumber(String name) {\n+        Objects.requireNonNull(name, \"Group name\");\n+        Integer number = namedGroups().get(name);\n+        if (number != null) {\n+            return number;\n+        }\n+        throw new IllegalArgumentException(\"No group with name <\" + name + \">\");\n+    }\n+\n+    \/**\n+     * Returns whether {@code this} contains a valid match from\n+     * a previous match or find operation.\n+     *\n+     * @return whether {@code this} contains a valid match\n+     *\n+     * @throws UnsupportedOperationException\n+     *          The default implementation of this method always throws\n+     *\n+     * @since 20\n+     *\/\n+    default boolean hasMatch() {\n+        throw new UnsupportedOperationException(\"hasMatch()\");\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/util\/regex\/MatchResult.java","additions":174,"deletions":8,"binary":false,"changes":182,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.util.Map;\n@@ -232,0 +233,2 @@\n+    private Map<String, Integer> namedGroups;\n+\n@@ -281,1 +284,2 @@\n-                                        text);\n+                                        text,\n+                                        namedGroups());\n@@ -290,0 +294,1 @@\n+        private final Map<String, Integer> namedGroups;\n@@ -292,1 +297,2 @@\n-                             int[] groups, String text)\n+                             int[] groups, String text,\n+                             Map<String, Integer> namedGroups)\n@@ -299,0 +305,1 @@\n+            this.namedGroups = namedGroups;\n@@ -310,2 +317,1 @@\n-            if (group < 0 || group > groupCount)\n-                throw new IndexOutOfBoundsException(\"No group \" + group);\n+            checkGroup(group);\n@@ -324,2 +330,1 @@\n-            if (group < 0 || group > groupCount)\n-                throw new IndexOutOfBoundsException(\"No group \" + group);\n+            checkGroup(group);\n@@ -343,3 +348,2 @@\n-            if (group < 0 || group > groupCount)\n-                throw new IndexOutOfBoundsException(\"No group \" + group);\n-            if ((groups[group*2] == -1) || (groups[group*2+1] == -1))\n+            checkGroup(group);\n+            if ((groups[group * 2] == -1) || (groups[group * 2 + 1] == -1))\n@@ -350,0 +354,15 @@\n+        @Override\n+        public Map<String, Integer> namedGroups() {\n+            return namedGroups;\n+        }\n+\n+        @Override\n+        public boolean hasMatch() {\n+            return first >= 0;\n+        }\n+\n+        private void checkGroup(int group) {\n+            if (group < 0 || group > groupCount)\n+                throw new IndexOutOfBoundsException(\"No group \" + group);\n+        }\n+\n@@ -351,1 +370,1 @@\n-            if (first < 0)\n+            if (!hasMatch())\n@@ -355,0 +374,1 @@\n+\n@@ -449,2 +469,1 @@\n-        if (first < 0)\n-            throw new IllegalStateException(\"No match available\");\n+        checkMatch();\n@@ -479,4 +498,2 @@\n-        if (first < 0)\n-            throw new IllegalStateException(\"No match available\");\n-        if (group < 0 || group > groupCount())\n-            throw new IndexOutOfBoundsException(\"No group \" + group);\n+        checkMatch();\n+        checkGroup(group);\n@@ -521,2 +538,1 @@\n-        if (first < 0)\n-            throw new IllegalStateException(\"No match available\");\n+        checkMatch();\n@@ -551,4 +567,2 @@\n-        if (first < 0)\n-            throw new IllegalStateException(\"No match available\");\n-        if (group < 0 || group > groupCount())\n-            throw new IndexOutOfBoundsException(\"No group \" + group);\n+        checkMatch();\n+        checkGroup(group);\n@@ -643,4 +657,2 @@\n-        if (first < 0)\n-            throw new IllegalStateException(\"No match found\");\n-        if (group < 0 || group > groupCount())\n-            throw new IndexOutOfBoundsException(\"No group \" + group);\n+        checkMatch();\n+        checkGroup(group);\n@@ -903,3 +915,1 @@\n-        \/\/ If no match, return error\n-        if (first < 0)\n-            throw new IllegalStateException(\"No match available\");\n+        checkMatch();\n@@ -994,2 +1004,1 @@\n-        if (first < 0)\n-            throw new IllegalStateException(\"No match available\");\n+        checkMatch();\n@@ -1058,1 +1067,1 @@\n-                    if (!parentPattern.namedGroups().containsKey(gname))\n+                    if (!namedGroups().containsKey(gname))\n@@ -1061,1 +1070,1 @@\n-                    refNum = parentPattern.namedGroups().get(gname);\n+                    refNum = namedGroups().get(gname);\n@@ -1799,3 +1808,2 @@\n-        if (first < 0)\n-            throw new IllegalStateException(\"No match found\");\n-        if (!parentPattern.namedGroups().containsKey(name))\n+        checkMatch();\n+        if (!namedGroups().containsKey(name))\n@@ -1803,1 +1811,38 @@\n-        return parentPattern.namedGroups().get(name);\n+        return namedGroups().get(name);\n+    }\n+\n+    private void checkGroup(int group) {\n+        if (group < 0 || group > groupCount())\n+            throw new IndexOutOfBoundsException(\"No group \" + group);\n+    }\n+\n+    private void checkMatch() {\n+        if (!hasMatch())\n+            throw new IllegalStateException(\"No match found\");\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @return {@inheritDoc}\n+     *\n+     * @since {@inheritDoc}\n+     *\/\n+    @Override\n+    public Map<String, Integer> namedGroups() {\n+        if (namedGroups == null) {\n+            return namedGroups = parentPattern.namedGroups();\n+        }\n+        return namedGroups;\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @return {@inheritDoc}\n+     *\n+     * @since {@inheritDoc}\n+     *\/\n+    @Override\n+    public boolean hasMatch() {\n+        return first >= 0;\n@@ -1805,0 +1850,1 @@\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/regex\/Matcher.java","additions":84,"deletions":38,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -1845,1 +1845,1 @@\n-    Map<String, Integer> namedGroups() {\n+    private Map<String, Integer> namedGroupsMap() {\n@@ -1853,0 +1853,12 @@\n+    \/**\n+     * Returns an unmodifiable map from capturing group names to group numbers.\n+     * If there are no named groups, returns an empty map.\n+     *\n+     * @return an unmodifiable map from capturing group names to group numbers\n+     *\n+     * @since 20\n+     *\/\n+    public Map<String, Integer> namedGroups() {\n+        return Map.copyOf(namedGroupsMap());\n+    }\n+\n@@ -2556,1 +2568,1 @@\n-            if (!namedGroups().containsKey(name))\n+            if (!namedGroupsMap().containsKey(name))\n@@ -2561,1 +2573,1 @@\n-                    root = new CIBackRef(namedGroups().get(name), has(UNICODE_CASE));\n+                    root = new CIBackRef(namedGroupsMap().get(name), has(UNICODE_CASE));\n@@ -2563,1 +2575,1 @@\n-                    root = new BackRef(namedGroups().get(name));\n+                    root = new BackRef(namedGroupsMap().get(name));\n@@ -3010,1 +3022,1 @@\n-                        if (namedGroups().containsKey(name))\n+                        if (namedGroupsMap().containsKey(name))\n@@ -3016,1 +3028,1 @@\n-                        namedGroups().put(name, capturingGroupCount - 1);\n+                        namedGroupsMap().put(name, capturingGroupCount - 1);\n","filename":"src\/java.base\/share\/classes\/java\/util\/regex\/Pattern.java","additions":18,"deletions":6,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,349 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8065554\n+ * @run main NamedGroupsTests\n+ *\/\n+\n+import java.util.Map;\n+import java.util.regex.MatchResult;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+public class NamedGroupsTests {\n+\n+    \/* An implementation purposely not overriding any default method *\/\n+    private static class TestMatcherNoNamedGroups implements MatchResult {\n+\n+        @Override\n+        public int start() {\n+            return 0;\n+        }\n+\n+        @Override\n+        public int start(int group) {\n+            return 0;\n+        }\n+\n+        @Override\n+        public int end() {\n+            return 0;\n+        }\n+\n+        @Override\n+        public int end(int group) {\n+            return 0;\n+        }\n+\n+        @Override\n+        public String group() {\n+            return null;\n+        }\n+\n+        @Override\n+        public String group(int group) {\n+            return null;\n+        }\n+\n+        @Override\n+        public int groupCount() {\n+            return 0;\n+        }\n+\n+    }\n+\n+    public static void main(String[] args) {\n+        testMatchResultNoDefault();\n+\n+        testPatternNamedGroups();\n+        testMatcherNamedGroups();\n+        testMatchResultNamedGroups();\n+\n+        testMatcherHasMatch();\n+        testMatchResultHasMatch();\n+\n+        testMatchResultStartEndGroupBeforeMatchOp();\n+        testMatchResultStartEndGroupAfterMatchOp();\n+    }\n+\n+    private static void testMatchResultNoDefault() {\n+        TestMatcherNoNamedGroups m = new TestMatcherNoNamedGroups();\n+        try {\n+            m.hasMatch();\n+        } catch (UnsupportedOperationException e) {  \/\/ swallowing intended\n+        }\n+        try {\n+            m.namedGroups();\n+        } catch (UnsupportedOperationException e) {  \/\/ swallowing intended\n+        }\n+        try {\n+            m.start(\"anyName\");\n+        } catch (UnsupportedOperationException e) {  \/\/ swallowing intended\n+        }\n+        try {\n+            m.end(\"anyName\");\n+        } catch (UnsupportedOperationException e) {  \/\/ swallowing intended\n+        }\n+        try {\n+            m.group(\"anyName\");\n+        } catch (UnsupportedOperationException e) {  \/\/ swallowing intended\n+        }\n+    }\n+\n+    private static void testMatchResultStartEndGroupBeforeMatchOp() {\n+        Matcher m = Pattern.compile(\"(?<some>.+?)(?<rest>.*)\").matcher(\"abc\");\n+        try {\n+            m.start(\"anyName\");\n+        } catch (IllegalStateException e) {  \/\/ swallowing intended\n+        }\n+        try {\n+            m.end(\"anyName\");\n+        } catch (IllegalStateException e) {  \/\/ swallowing intended\n+        }\n+        try {\n+            m.group(\"anyName\");\n+        } catch (IllegalStateException e) {  \/\/ swallowing intended\n+        }\n+    }\n+\n+    private static void testMatchResultStartEndGroupAfterMatchOp() {\n+        testMatchResultStartEndGroupNoMatch();\n+        testMatchResultStartEndGroupWithMatch();\n+        testMatchResultStartEndGroupNoMatchNoSuchGroup();\n+        testMatchResultStartEndGroupWithMatchNoSuchGroup();\n+    }\n+\n+    private static void testMatchResultStartEndGroupNoMatch() {\n+        Pattern.compile(\"(?<some>.+?)(?<rest>.*)\").matcher(\"\")\n+                .results()\n+                .forEach(r -> {\n+                    if (r.start(\"some\") >= 0) {\n+                        throw new RuntimeException(\"start(\\\"some\\\")\");\n+                    }\n+                    if (r.start(\"rest\") >= 0) {\n+                        throw new RuntimeException(\"start(\\\"rest\\\")\");\n+                    }\n+                    if (r.end(\"some\") >= 0) {\n+                        throw new RuntimeException(\"end(\\\"some\\\")\");\n+                    }\n+                    if (r.end(\"rest\") >= 0) {\n+                        throw new RuntimeException(\"end(\\\"rest\\\")\");\n+                    }\n+                    if (r.group(\"some\") != null) {\n+                        throw new RuntimeException(\"group(\\\"some\\\")\");\n+                    }\n+                    if (r.group(\"rest\") != null) {\n+                        throw new RuntimeException(\"group(\\\"rest\\\")\");\n+                    }\n+                });\n+    }\n+\n+    private static void testMatchResultStartEndGroupWithMatch() {\n+        Pattern.compile(\"(?<some>.+?)(?<rest>.*)\").matcher(\"abc\")\n+                .results()\n+                .forEach(r -> {\n+                    if (r.start(\"some\") < 0) {\n+                        throw new RuntimeException(\"start(\\\"some\\\")\");\n+                    }\n+                    if (r.start(\"rest\") < 0) {\n+                        throw new RuntimeException(\"start(\\\"rest\\\")\");\n+                    }\n+                    if (r.end(\"some\") < 0) {\n+                        throw new RuntimeException(\"end(\\\"some\\\")\");\n+                    }\n+                    if (r.end(\"rest\") < 0) {\n+                        throw new RuntimeException(\"end(\\\"rest\\\")\");\n+                    }\n+                    if (r.group(\"some\") == null) {\n+                        throw new RuntimeException(\"group(\\\"some\\\")\");\n+                    }\n+                    if (r.group(\"rest\") == null) {\n+                        throw new RuntimeException(\"group(\\\"rest\\\")\");\n+                    }\n+                });\n+    }\n+\n+    private static void testMatchResultStartEndGroupNoMatchNoSuchGroup() {\n+        Pattern.compile(\"(?<some>.+?)(?<rest>.*)\").matcher(\"\")\n+                .results()\n+                .forEach(r -> {\n+                    try {\n+                        r.start(\"noSuchGroup\");\n+                    } catch (IllegalArgumentException e) {  \/\/ swallowing intended\n+                    }\n+                    try {\n+                        r.end(\"noSuchGroup\");\n+                    } catch (IllegalArgumentException e) {  \/\/ swallowing intended\n+                    }\n+                    try {\n+                        r.group(\"noSuchGroup\");\n+                    } catch (IllegalArgumentException e) {  \/\/ swallowing intended\n+                    }\n+                });\n+    }\n+\n+    private static void testMatchResultStartEndGroupWithMatchNoSuchGroup() {\n+        Pattern.compile(\"(?<some>.+?)(?<rest>.*)\").matcher(\"abc\")\n+                .results()\n+                .forEach(r -> {\n+                    try {\n+                        r.start(\"noSuchGroup\");\n+                    } catch (IllegalArgumentException e) {  \/\/ swallowing intended\n+                    }\n+                    try {\n+                        r.end(\"noSuchGroup\");\n+                    } catch (IllegalArgumentException e) {  \/\/ swallowing intended\n+                    }\n+                    try {\n+                        r.group(\"noSuchGroup\");\n+                    } catch (IllegalArgumentException e) {  \/\/ swallowing intended\n+                    }\n+                });\n+    }\n+\n+    private static void testMatchResultHasMatch() {\n+        testMatchResultHasMatchNoMatch();\n+        testMatchResultHasMatchWithMatch();\n+    }\n+\n+    private static void testMatchResultHasMatchNoMatch() {\n+        Matcher m = Pattern.compile(\".+\").matcher(\"\");\n+        m.find();\n+        if (m.toMatchResult().hasMatch()) {\n+            throw new RuntimeException();\n+        }\n+    }\n+\n+    private static void testMatchResultHasMatchWithMatch() {\n+        Matcher m = Pattern.compile(\".+\").matcher(\"abc\");\n+        m.find();\n+        if (!m.toMatchResult().hasMatch()) {\n+            throw new RuntimeException();\n+        }\n+    }\n+\n+    private static void testMatcherHasMatch() {\n+        testMatcherHasMatchNoMatch();\n+        testMatcherHasMatchWithMatch();\n+    }\n+\n+    private static void testMatcherHasMatchNoMatch() {\n+        Matcher m = Pattern.compile(\".+\").matcher(\"\");\n+        m.find();\n+        if (m.hasMatch()) {\n+            throw new RuntimeException();\n+        }\n+    }\n+\n+    private static void testMatcherHasMatchWithMatch() {\n+        Matcher m = Pattern.compile(\".+\").matcher(\"abc\");\n+        m.find();\n+        if (!m.hasMatch()) {\n+            throw new RuntimeException();\n+        }\n+    }\n+\n+    private static void testMatchResultNamedGroups() {\n+        testMatchResultNamedGroupsNoNamedGroups();\n+        testMatchResultNamedGroupsOneNamedGroup();\n+        testMatchResultNamedGroupsTwoNamedGroups();\n+    }\n+\n+    private static void testMatchResultNamedGroupsNoNamedGroups() {\n+        if (!Pattern.compile(\".*\").matcher(\"\")\n+                .toMatchResult().namedGroups().isEmpty()) {\n+            throw new RuntimeException();\n+        }\n+    }\n+\n+    private static void testMatchResultNamedGroupsOneNamedGroup() {\n+        if (!Pattern.compile(\"(?<all>.*)\").matcher(\"\")\n+                .toMatchResult().namedGroups()\n+                .equals(Map.of(\"all\", 1))) {\n+            throw new RuntimeException();\n+        }\n+    }\n+\n+    private static void testMatchResultNamedGroupsTwoNamedGroups() {\n+        if (!Pattern.compile(\"(?<some>.+?)(?<rest>.*)\").matcher(\"\")\n+                .toMatchResult().namedGroups()\n+                .equals(Map.of(\"some\", 1, \"rest\", 2))) {\n+            throw new RuntimeException();\n+        }\n+    }\n+\n+    private static void testMatcherNamedGroups() {\n+        testMatcherNamedGroupsNoNamedGroups();\n+        testMatcherNamedGroupsOneNamedGroup();\n+        testMatcherNamedGroupsTwoNamedGroups();\n+    }\n+\n+    private static void testMatcherNamedGroupsNoNamedGroups() {\n+        if (!Pattern.compile(\".*\").matcher(\"\").namedGroups().isEmpty()) {\n+            throw new RuntimeException();\n+        }\n+    }\n+\n+    private static void testMatcherNamedGroupsOneNamedGroup() {\n+        if (!Pattern.compile(\"(?<all>.*)\").matcher(\"\").namedGroups()\n+                .equals(Map.of(\"all\", 1))) {\n+            throw new RuntimeException();\n+        }\n+    }\n+\n+    private static void testMatcherNamedGroupsTwoNamedGroups() {\n+        if (!Pattern.compile(\"(?<some>.+?)(?<rest>.*)\").matcher(\"\").namedGroups()\n+                .equals(Map.of(\"some\", 1, \"rest\", 2))) {\n+            throw new RuntimeException();\n+        }\n+    }\n+\n+    private static void testPatternNamedGroups() {\n+        testPatternNamedGroupsNoNamedGroups();\n+        testPatternNamedGroupsOneNamedGroup();\n+        testPatternNamedGroupsTwoNamedGroups();\n+    }\n+\n+    private static void testPatternNamedGroupsNoNamedGroups() {\n+        if (!Pattern.compile(\".*\").namedGroups().isEmpty()) {\n+            throw new RuntimeException();\n+        }\n+    }\n+\n+    private static void testPatternNamedGroupsOneNamedGroup() {\n+        if (!Pattern.compile(\"(?<all>.*)\").namedGroups()\n+                .equals(Map.of(\"all\", 1))) {\n+            throw new RuntimeException();\n+        }\n+    }\n+\n+    private static void testPatternNamedGroupsTwoNamedGroups() {\n+        if (!Pattern.compile(\"(?<some>.+?)(?<rest>.*)\").namedGroups()\n+                .equals(Map.of(\"some\", 1, \"rest\", 2))) {\n+            throw new RuntimeException();\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/util\/regex\/NamedGroupsTests.java","additions":349,"deletions":0,"binary":false,"changes":349,"status":"added"}]}