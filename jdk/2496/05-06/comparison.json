{"files":[{"patch":"@@ -50,3 +50,2 @@\n- * ...Release-Acquire ordering is as good. Hand-written arch-specific assembly code\n- * can use data dependencies to provide \"Consume\" semantics that would not be\n- * affected by C++ compilers.\n+ * ...Release-Acquire ordering might be considered. But, on weakly-ordered\n+ * architectures, doing \"Acquire\" on hot-path would significantly penalize users.\n@@ -54,4 +53,17 @@\n- * The criticial point where synchronization is needed are mark word accesses:\n- *   1. markword loads that are then decoded into forwardee are marked with \"acquire\";\n- *   2. markword loads that are not decoded into forwardee (e.g. is_forwarded) can still be relaxed;\n- *   3. markword stores that publish new forwardee are marked with \"release\"\n+ * We can recognize that C++ GC code hardly ever accesses the object contents after\n+ * the evacuation: the marking is done by the time evacuations happen, the evacuation\n+ * code only reads the contents of the from-copy (that is not protected by\n+ * synchronization anyhow), and update-refs only writes the object pointers themselves.\n+ * Therefore, \"Relaxed\" still works, \"Consume\" is good as the additional safety measure,\n+ * but the cost of \"Acquire\" is too high.\n+ *\n+ * The mutator code accesses forwarded objects through runtime interface, which\n+ * among other things inhibits the problematic C++ optimizations that are otherwise\n+ * would require \"Consume\".\n+ *\n+ * Hand-written arch-specific assembly code for barriers uses data dependencies to\n+ * provide \"Consume\" semantics that would not be affected by C++ compilers.\n+ *\n+ * The critical point where synchronization is needed are mark word accesses:\n+ *   1. markword loads are using the \"relaxed\" loads, due to the reasons above;\n+ *   2. markword stores that publish new forwardee are marked with \"release\";\n@@ -70,1 +82,1 @@\n-  markWord mark = obj->mark_acquire();\n+  markWord mark = obj->mark();\n@@ -85,1 +97,1 @@\n-  markWord mark = obj->mark_acquire();\n+  markWord mark = obj->mark();\n@@ -105,1 +117,1 @@\n-  markWord old_mark = obj->mark_acquire();\n+  markWord old_mark = obj->mark();\n@@ -111,1 +123,1 @@\n-  markWord prev_mark = obj->cas_set_mark(new_mark, old_mark, memory_order_acq_rel);\n+  markWord prev_mark = obj->cas_set_mark(new_mark, old_mark, memory_order_release);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahForwarding.inline.hpp","additions":23,"deletions":11,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -61,3 +61,2 @@\n-  inline markWord  mark()         const;\n-  inline markWord  mark_acquire() const;\n-  inline markWord* mark_addr()    const;\n+  inline markWord  mark()          const;\n+  inline markWord* mark_addr() const;\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -52,5 +52,0 @@\n-markWord oopDesc::mark_acquire() const {\n-  uintptr_t v = HeapAccess<MO_ACQUIRE>::load_at(as_oop(), mark_offset_in_bytes());\n-  return markWord(v);\n-}\n-\n","filename":"src\/hotspot\/share\/oops\/oop.inline.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"}]}