{"files":[{"patch":"@@ -215,0 +215,5 @@\n+\n+  \/\/ Load the forwardee with \"consume\" semantics, which in this case\n+  \/\/ can be done with just a plain load, as AArch64 maintains ordering\n+  \/\/ with address dependencies. See ShenandoahForwarding helpers for\n+  \/\/ more discussion.\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shenandoah\/shenandoahBarrierSetAssembler_aarch64.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -737,1 +737,3 @@\n-  \/\/ Load and mask forwarding pointer\n+  \/\/ Load and mask forwarding pointer with \"consume\" semantics, which in this case\n+  \/\/ can be done with just a plain load, as x86 maintains ordering with address\n+  \/\/ dependencies. See ShenandoahForwarding helpers for more discussion.\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shenandoah\/shenandoahBarrierSetAssembler_x86.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -142,1 +142,1 @@\n-    oop fwd = ShenandoahForwarding::get_forwardee_raw_unchecked(obj);\n+    oop fwd = ShenandoahForwarding::get_forwardee_raw(obj);\n@@ -157,2 +157,2 @@\n-    oop fwd = ShenandoahForwarding::get_forwardee_raw_unchecked(obj);\n-    oop fwd2 = ShenandoahForwarding::get_forwardee_raw_unchecked(fwd);\n+    oop fwd = ShenandoahForwarding::get_forwardee_raw(obj);\n+    oop fwd2 = ShenandoahForwarding::get_forwardee_raw(fwd);\n@@ -213,1 +213,1 @@\n-  oop fwd = ShenandoahForwarding::get_forwardee_raw_unchecked(obj);\n+  oop fwd = ShenandoahForwarding::get_forwardee_raw(obj);\n@@ -246,1 +246,1 @@\n-    oop fwd2 = ShenandoahForwarding::get_forwardee_raw_unchecked(fwd);\n+    oop fwd2 = ShenandoahForwarding::get_forwardee_raw(fwd);\n@@ -288,1 +288,1 @@\n-  oop fwd =   ShenandoahForwarding::get_forwardee_raw_unchecked(obj);\n+  oop fwd =   ShenandoahForwarding::get_forwardee_raw(obj);\n@@ -299,1 +299,1 @@\n-  oop fwd = ShenandoahForwarding::get_forwardee_raw_unchecked(obj);\n+  oop fwd = ShenandoahForwarding::get_forwardee_raw(obj);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAsserts.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -84,4 +84,0 @@\n-  static inline oop resolve_forwarded_not_null(oop p);\n-  static inline oop resolve_forwarded_not_null_mutator(oop p);\n-  static inline oop resolve_forwarded(oop p);\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -41,16 +41,0 @@\n-inline oop ShenandoahBarrierSet::resolve_forwarded_not_null(oop p) {\n-  return ShenandoahForwarding::get_forwardee(p);\n-}\n-\n-inline oop ShenandoahBarrierSet::resolve_forwarded(oop p) {\n-  if (p != NULL) {\n-    return resolve_forwarded_not_null(p);\n-  } else {\n-    return p;\n-  }\n-}\n-\n-inline oop ShenandoahBarrierSet::resolve_forwarded_not_null_mutator(oop p) {\n-  return ShenandoahForwarding::get_forwardee_mutator(p);\n-}\n-\n@@ -62,1 +46,1 @@\n-  oop fwd = resolve_forwarded_not_null_mutator(obj);\n+  oop fwd = ShenandoahForwarding::get_forwardee_mutator(obj);\n@@ -73,1 +57,1 @@\n-    ShenandoahHeap::atomic_update_oop(fwd, load_addr, obj);\n+    ShenandoahForwarding::update_with_forwarded(obj, load_addr, fwd);\n@@ -86,1 +70,1 @@\n-    oop fwd = resolve_forwarded_not_null(obj);\n+    oop fwd = ShenandoahForwarding::get_forwardee(obj);\n@@ -133,1 +117,1 @@\n-    ShenandoahHeap::atomic_update_oop(fwd, load_addr, obj);\n+    ShenandoahForwarding::update_with_forwarded(obj, load_addr, fwd);\n@@ -204,1 +188,2 @@\n-  } while ((compare_value != expected) && (resolve_forwarded(compare_value) == resolve_forwarded(expected)));\n+  } while ((compare_value != expected) &&\n+           (ShenandoahForwarding::get_forwardee_maybe_null(compare_value) == ShenandoahForwarding::get_forwardee_maybe_null(expected)));\n@@ -356,1 +341,3 @@\n-        oop fwd = resolve_forwarded_not_null(obj);\n+        oop fwd = EVAC ?\n+                ShenandoahForwarding::get_forwardee(obj) :\n+                ShenandoahForwarding::get_forwardee_stable(obj);\n@@ -361,1 +348,5 @@\n-        ShenandoahHeap::atomic_update_oop(fwd, elem_ptr, o);\n+        if (EVAC) {\n+          ShenandoahForwarding::update_with_forwarded(o, elem_ptr, fwd);\n+        } else {\n+          ShenandoahForwarding::update_with_forwarded_stable(o, elem_ptr, fwd);\n+        }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.inline.hpp","additions":14,"deletions":23,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -52,1 +52,3 @@\n-        oop fwd = _bs->resolve_forwarded_not_null(obj);\n+        oop fwd = EVAC ?\n+                ShenandoahForwarding::get_forwardee(obj) :\n+                ShenandoahForwarding::get_forwardee_stable(obj);\n@@ -57,1 +59,5 @@\n-        ShenandoahHeap::atomic_update_oop(fwd, p, o);\n+        if (EVAC) {\n+          ShenandoahForwarding::update_with_forwarded(o, p, fwd);\n+        } else {\n+          ShenandoahForwarding::update_with_forwarded_stable(o, p, fwd);\n+        }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSetClone.inline.hpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-  obj = ShenandoahBarrierSet::resolve_forwarded_not_null(obj);\n+  obj = ShenandoahForwarding::get_forwardee(obj);\n@@ -125,1 +125,1 @@\n-      oop resolved = ShenandoahBarrierSet::resolve_forwarded_not_null(obj);\n+      oop resolved = ShenandoahForwarding::get_forwardee(obj);\n@@ -160,1 +160,1 @@\n-      oop resolved = ShenandoahBarrierSet::resolve_forwarded_not_null(obj);\n+      oop resolved = ShenandoahForwarding::get_forwardee(obj);\n@@ -164,1 +164,1 @@\n-      ShenandoahHeap::atomic_update_oop(resolved, p, o);\n+      ShenandoahForwarding::update_with_forwarded(o, p, resolved);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahClosures.inline.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -691,1 +691,1 @@\n-      oop resolved = ShenandoahBarrierSet::resolve_forwarded_not_null(obj);\n+      oop resolved = ShenandoahForwarding::get_forwardee(obj);\n@@ -695,1 +695,1 @@\n-      ShenandoahHeap::atomic_update_oop(resolved, p, obj);\n+      ShenandoahForwarding::update_with_forwarded(obj, p, resolved);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,0 +32,4 @@\n+private:\n+  static inline oop decode_forwardee(oop obj, markWord mark);\n+  static inline oop decode_forwardee_mutator(oop obj, markWord mark);\n+\n@@ -34,0 +38,1 @@\n+   * Stable versions are only safe when no evacs happen.\n@@ -36,0 +41,2 @@\n+  static inline oop get_forwardee_maybe_null(oop obj);\n+  static inline oop get_forwardee_stable(oop obj);\n@@ -41,4 +48,0 @@\n-  \/* Returns the raw value from forwardee slot.\n-   *\/\n-  static inline oop get_forwardee_raw(oop obj);\n-\n@@ -47,0 +50,1 @@\n+   * Stable versions are only safe when no evacs happen.\n@@ -48,1 +52,2 @@\n-  static inline oop get_forwardee_raw_unchecked(oop obj);\n+  static inline oop get_forwardee_raw(oop obj);\n+  static inline oop get_forwardee_stable_raw(oop obj);\n@@ -50,1 +55,1 @@\n-  \/**\n+  \/*\n@@ -65,0 +70,10 @@\n+  \/*\n+   * Tries to atomically update the heap address to object's forwardee.\n+   * Stable versions are only safe when no evacs happen.\n+   *\/\n+  static inline void update_with_forwarded(      oop obj,       oop* addr, oop update);\n+  static inline void update_with_forwarded(      oop obj, narrowOop* addr, oop update);\n+  static inline void update_with_forwarded(narrowOop obj, narrowOop* addr, oop update);\n+  static inline void update_with_forwarded_stable(      oop obj,       oop* addr, oop update);\n+  static inline void update_with_forwarded_stable(      oop obj, narrowOop* addr, oop update);\n+  static inline void update_with_forwarded_stable(narrowOop obj, narrowOop* addr, oop update);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahForwarding.hpp","additions":21,"deletions":6,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+#include \"oops\/compressedOops.inline.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n@@ -32,0 +34,1 @@\n+#include \"runtime\/atomic.hpp\"\n@@ -34,4 +37,54 @@\n-inline oop ShenandoahForwarding::get_forwardee_raw(oop obj) {\n-  shenandoah_assert_in_heap(NULL, obj);\n-  return get_forwardee_raw_unchecked(obj);\n-}\n+\/*\n+ * Implementation note on memory ordering:\n+ *\n+ * Since concurrent GC like Shenandoah effectively publishes the forwardee copy\n+ * to concurrently running mutators, we need to consider the memory ordering\n+ * that comes with it. Most crucially, we need to ensure that all the stores to\n+ * the forwardee before its publication are visible to readers of the forwardee.\n+ * This is the GC hotpath, and thus the weakest synchronization should be used.\n+ *\n+ * Because the whole thing is the pointer-mediated publishing, the weakest way\n+ * to achieve this is Release-Consume ordering. But, because:\n+ *   a) we do not have \"Consume\" for in Hotspot;\n+ *   b) \"Consume\" gets promoted to \"Acquire\" by most current compilers\n+ *      (because doing otherwise requires tracking load dependencies);\n+ *   c) the use of \"Consume\" is generally discouraged in current C++;\n+ *\n+ * ...Release-Acquire ordering should be considered.\n+ *\n+ * It is beyond doubt that forwardee installations need to be \"Release\".\n+ * But doing \"Acquire\" on hot-path, especially on weakly-ordered architectures,\n+ * would significantly penalize users. The rest of the discussion is about the\n+ * need for \"Acquire\" on some paths.\n+ *\n+ * There are several distinct places from where the access happens:\n+ *   1. C++ GC code\n+ *   2. Mutator code (through runtime\/C++ barriers)\n+ *   3. Mutator code (through interpreter\/assembly barriers)\n+ *\n+ * The problematic places in C++ GC code fall into two categories:\n+ *   *) Concurrent with evacuation: these need to to see the concurrently installed\n+ *      forwardee. This also affects the CAS for forwarding installation, as the failing\n+ *      CAS should to see the other forwardee. Therefore, these paths use\n+ *      \"Acquire\" in lieu of \"Consume\". This is also a default mode to get the forwardee,\n+ *      for extra safety.\n+ *   *) Happening past the evacuation: since all forwardee installations have happened,\n+ *      and there was a coordination event (safepoint) from the last evacuation,\n+ *      we should not observe anything in flight. That is a \"stable\" mode, and on\n+ *      that path, \"Relaxed\" is enough. This usually matters for a heavy-weight update\n+ *      heap operations.\n+ *\n+ * The mutator code can access the forwardee at arbitrary point during the GC. Therefore,\n+ * it can potentially race with the concurrent evacuation.\n+ *\n+ * The mutator runtime\/C++ code accesses forwardees through the default method\n+ * that does \"Acquire\" for additional safety. That path is taken by self-healing paths,\n+ * which are relatively rare, and already paid the significant cost of going to runtime.\n+ *\n+ * The mutator interpreter\/assembly accesses use the hand-written arch-specific assembly\n+ * code for barriers that is immune to C++ shenanigans, and does use data dependencies to\n+ * provide \"Consume\" semantics.\n+ *\n+ * TODO: When \"Consume\" is available, load mark words with \"consume\" everywhere,\n+ * and drop the distinction between default and stable accessors.\n+ *\/\n@@ -39,1 +92,1 @@\n-inline oop ShenandoahForwarding::get_forwardee_raw_unchecked(oop obj) {\n+inline oop ShenandoahForwarding::decode_forwardee(oop obj, markWord mark) {\n@@ -44,1 +97,0 @@\n-  markWord mark = obj->mark();\n@@ -54,1 +106,1 @@\n-inline oop ShenandoahForwarding::get_forwardee_mutator(oop obj) {\n+inline oop ShenandoahForwarding::decode_forwardee_mutator(oop obj, markWord mark) {\n@@ -56,4 +108,0 @@\n-  shenandoah_assert_correct(NULL, obj);\n-  assert(Thread::current()->is_Java_thread(), \"Must be a mutator thread\");\n-\n-  markWord mark = obj->mark();\n@@ -62,4 +110,3 @@\n-    assert(fwdptr != NULL, \"Forwarding pointer is never null here\");\n-    return cast_to_oop(fwdptr);\n-  } else {\n-    return obj;\n+    if (fwdptr != NULL) {\n+      return cast_to_oop(fwdptr);\n+    }\n@@ -67,0 +114,22 @@\n+  return obj;\n+}\n+\n+inline oop ShenandoahForwarding::get_forwardee_raw(oop obj) {\n+  \/\/ Forwardee might be changing, acquire the mark\n+  markWord mark = obj->mark_acquire();\n+  return decode_forwardee(obj, mark);\n+}\n+\n+inline oop ShenandoahForwarding::get_forwardee_stable_raw(oop obj) {\n+  \/\/ Forwardee is stable, non-acquiring mark is enough.\n+  markWord mark = obj->mark();\n+  return decode_forwardee(obj, mark);\n+}\n+\n+inline oop ShenandoahForwarding::get_forwardee_mutator(oop obj) {\n+  \/\/ Same as above, but mutator thread cannot ever see NULL forwardee.\n+  \/\/ It also performs the \"acquire\" read to coordinate with GC evacs.\n+  shenandoah_assert_correct(NULL, obj);\n+  assert(Thread::current()->is_Java_thread(), \"Must be a mutator thread\");\n+  markWord mark = obj->mark_acquire();\n+  return decode_forwardee_mutator(obj, mark);\n@@ -71,1 +140,12 @@\n-  return get_forwardee_raw_unchecked(obj);\n+  return get_forwardee_raw(obj);\n+}\n+\n+inline oop ShenandoahForwarding::get_forwardee_maybe_null(oop obj) {\n+  if (obj == NULL) return obj;\n+  shenandoah_assert_correct(NULL, obj);\n+  return get_forwardee_raw(obj);\n+}\n+\n+inline oop ShenandoahForwarding::get_forwardee_stable(oop obj) {\n+  shenandoah_assert_correct(NULL, obj);\n+  return get_forwardee_stable_raw(obj);\n@@ -81,1 +161,2 @@\n-    return cast_to_oop(old_mark.clear_lock_bits().to_pointer());\n+    \/\/ Already forwarded, don't try to overwrite. Re-read with acquire semantics.\n+    return get_forwardee_raw(obj);\n@@ -85,1 +166,1 @@\n-  markWord prev_mark = obj->cas_set_mark(new_mark, old_mark, memory_order_conservative);\n+  markWord prev_mark = obj->cas_set_mark(new_mark, old_mark, memory_order_release);\n@@ -89,1 +170,2 @@\n-    return cast_to_oop(prev_mark.clear_lock_bits().to_pointer());\n+    \/\/ Lost the race. Re-read with acquire semantics.\n+    return get_forwardee_raw(obj);\n@@ -93,0 +175,93 @@\n+\/\/ Atomic updates of object with their forwardees. The reason why we need stronger-than-relaxed\n+\/\/ memory ordering has to do with coordination with GC barriers and mutator accesses.\n+\/\/\n+\/\/ In essence, stronger CAS access is required to maintain the transitive chains that mutator\n+\/\/ accesses build by themselves. To illustrate this point, consider the following example.\n+\/\/\n+\/\/ Suppose \"o\" is the object that has a field \"x\" and the reference to \"o\" is stored\n+\/\/ to field at \"addr\", which happens to be Java volatile field. Normally, the accesses to volatile\n+\/\/ field at \"addr\" would be matched with release\/acquire barriers. This changes when GC moves\n+\/\/ the object under mutator feet.\n+\/\/\n+\/\/ Thread 1 (Java)\n+\/\/         \/\/ --- previous access starts here\n+\/\/         ...\n+\/\/   T1.1: store(&o.x, 1, mo_relaxed)\n+\/\/   T1.2: store(&addr, o, mo_release) \/\/ volatile store\n+\/\/\n+\/\/         \/\/ --- new access starts here\n+\/\/         \/\/ LRB: copy and install the new copy to fwdptr\n+\/\/   T1.3: var copy = copy(o)\n+\/\/   T1.4: cas(&fwd, t, copy, mo_release) \/\/ pointer-mediated publication\n+\/\/         <access continues>\n+\/\/\n+\/\/ Thread 2 (GC updater)\n+\/\/   T2.1: var f = load(&fwd, mo_{consume|acquire}) \/\/ pointer-mediated acquisition\n+\/\/   T2.2: cas(&addr, o, f, mo_release) \/\/ this method\n+\/\/\n+\/\/ Thread 3 (Java)\n+\/\/   T3.1: var o = load(&addr, mo_acquire) \/\/ volatile read\n+\/\/   T3.2: if (o != null)\n+\/\/   T3.3:   var r = load(&o.x, mo_relaxed)\n+\/\/\n+\/\/ r is guaranteed to contain \"1\".\n+\/\/\n+\/\/ Without GC involvement, there is synchronizes-with edge from T1.2 to T3.1,\n+\/\/ which guarantees this. With GC involvement, when LRB copies the object and\n+\/\/ another thread updates the reference to it, we need to have the transitive edge\n+\/\/ from T1.4 to T2.1 (that one is guaranteed by forwarding accesses), plus the edge\n+\/\/ from T2.2 to T3.1 (which is brought by this CAS).\n+\/\/\n+\/\/ Note that we do not need to \"acquire\" in these methods, because we do not read the\n+\/\/ failure witnesses contents on any path, and \"release\" is enough.\n+\/\/\n+\/\/ Note: this derivation is valid under quite weak C++ memory model. Real hardware can\n+\/\/ provide the stronger consistency model that would obviate the need for \"release\" here.\n+\/\/ Instead of relaxing everywhere based on specific hardware knowledge, we instead\n+\/\/ provide the \"stable\" fast-path versions of these in the next section.\n+\/\/\n+\n+inline void ShenandoahForwarding::update_with_forwarded(oop obj, oop* addr, oop update) {\n+  assert(is_aligned(addr, HeapWordSize), \"Address should be aligned: \" PTR_FORMAT, p2i(addr));\n+  Atomic::cmpxchg(addr, obj, update, memory_order_release);\n+}\n+\n+inline void ShenandoahForwarding::update_with_forwarded(oop obj, narrowOop* addr, oop update) {\n+  assert(is_aligned(addr, sizeof(narrowOop)), \"Address should be aligned: \" PTR_FORMAT, p2i(addr));\n+  narrowOop o = CompressedOops::encode(obj);\n+  narrowOop u = CompressedOops::encode(update);\n+  Atomic::cmpxchg(addr, o, u, memory_order_release);\n+}\n+\n+inline void ShenandoahForwarding::update_with_forwarded(narrowOop obj, narrowOop* addr, oop update) {\n+  assert(is_aligned(addr, sizeof(narrowOop)), \"Address should be aligned: \" PTR_FORMAT, p2i(addr));\n+  narrowOop u = CompressedOops::encode(update);\n+  Atomic::cmpxchg(addr, obj, u, memory_order_release);\n+}\n+\n+\/*\n+ * Stable versions of the above.\n+ *\n+ * These do not need any special memory semantics, as these are only called when no\n+ * forwardings are being installed concurrently. This is usually happens outside of\n+ * evacuation, during the bulk heap updates.\n+ *\/\n+\n+inline void ShenandoahForwarding::update_with_forwarded_stable(oop obj, oop* addr, oop update) {\n+  assert(is_aligned(addr, HeapWordSize), \"Address should be aligned: \" PTR_FORMAT, p2i(addr));\n+  Atomic::cmpxchg(addr, obj, update, memory_order_relaxed);\n+}\n+\n+inline void ShenandoahForwarding::update_with_forwarded_stable(oop obj, narrowOop* addr, oop update) {\n+  assert(is_aligned(addr, sizeof(narrowOop)), \"Address should be aligned: \" PTR_FORMAT, p2i(addr));\n+  narrowOop o = CompressedOops::encode(obj);\n+  narrowOop u = CompressedOops::encode(update);\n+  Atomic::cmpxchg(addr, o, u, memory_order_relaxed);\n+}\n+\n+inline void ShenandoahForwarding::update_with_forwarded_stable(narrowOop obj, narrowOop* addr, oop update) {\n+  assert(is_aligned(addr, sizeof(narrowOop)), \"Address should be aligned: \" PTR_FORMAT, p2i(addr));\n+  narrowOop u = CompressedOops::encode(update);\n+  Atomic::cmpxchg(addr, obj, u, memory_order_relaxed);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahForwarding.inline.hpp","additions":194,"deletions":19,"binary":false,"changes":213,"status":"modified"},{"patch":"@@ -1242,1 +1242,1 @@\n-      obj = ShenandoahBarrierSet::resolve_forwarded_not_null(obj);\n+      obj = ShenandoahForwarding::get_forwardee(obj);\n@@ -1351,1 +1351,1 @@\n-      obj = ShenandoahBarrierSet::resolve_forwarded_not_null(obj);\n+      obj = ShenandoahForwarding::get_forwardee(obj);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -638,4 +638,0 @@\n-  static inline void atomic_update_oop(oop update,       oop* addr,       oop compare);\n-  static inline void atomic_update_oop(oop update, narrowOop* addr,       oop compare);\n-  static inline void atomic_update_oop(oop update, narrowOop* addr, narrowOop compare);\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -107,1 +107,1 @@\n-      oop fwd = ShenandoahBarrierSet::resolve_forwarded_not_null(obj);\n+      oop fwd = ShenandoahForwarding::get_forwardee_stable(obj);\n@@ -126,1 +126,1 @@\n-      oop fwd = ShenandoahBarrierSet::resolve_forwarded_not_null(obj);\n+      oop fwd = ShenandoahForwarding::get_forwardee_stable(obj);\n@@ -135,1 +135,1 @@\n-      atomic_update_oop(fwd, p, obj);\n+      ShenandoahForwarding::update_with_forwarded_stable(obj, p, fwd);\n@@ -140,63 +140,0 @@\n-\/\/ Atomic updates of heap location. This is only expected to work with updating the same\n-\/\/ logical object with its forwardee. The reason why we need stronger-than-relaxed memory\n-\/\/ ordering has to do with coordination with GC barriers and mutator accesses.\n-\/\/\n-\/\/ In essence, stronger CAS access is required to maintain the transitive chains that mutator\n-\/\/ accesses build by themselves. To illustrate this point, consider the following example.\n-\/\/\n-\/\/ Suppose \"o\" is the object that has a field \"x\" and the reference to \"o\" is stored\n-\/\/ to field at \"addr\", which happens to be Java volatile field. Normally, the accesses to volatile\n-\/\/ field at \"addr\" would be matched with release\/acquire barriers. This changes when GC moves\n-\/\/ the object under mutator feet.\n-\/\/\n-\/\/ Thread 1 (Java)\n-\/\/         \/\/ --- previous access starts here\n-\/\/         ...\n-\/\/   T1.1: store(&o.x, 1, mo_relaxed)\n-\/\/   T1.2: store(&addr, o, mo_release) \/\/ volatile store\n-\/\/\n-\/\/         \/\/ --- new access starts here\n-\/\/         \/\/ LRB: copy and install the new copy to fwdptr\n-\/\/   T1.3: var copy = copy(o)\n-\/\/   T1.4: cas(&fwd, t, copy, mo_release) \/\/ pointer-mediated publication\n-\/\/         <access continues>\n-\/\/\n-\/\/ Thread 2 (GC updater)\n-\/\/   T2.1: var f = load(&fwd, mo_{consume|acquire}) \/\/ pointer-mediated acquisition\n-\/\/   T2.2: cas(&addr, o, f, mo_release) \/\/ this method\n-\/\/\n-\/\/ Thread 3 (Java)\n-\/\/   T3.1: var o = load(&addr, mo_acquire) \/\/ volatile read\n-\/\/   T3.2: if (o != null)\n-\/\/   T3.3:   var r = load(&o.x, mo_relaxed)\n-\/\/\n-\/\/ r is guaranteed to contain \"1\".\n-\/\/\n-\/\/ Without GC involvement, there is synchronizes-with edge from T1.2 to T3.1,\n-\/\/ which guarantees this. With GC involvement, when LRB copies the object and\n-\/\/ another thread updates the reference to it, we need to have the transitive edge\n-\/\/ from T1.4 to T2.1 (that one is guaranteed by forwarding accesses), plus the edge\n-\/\/ from T2.2 to T3.1 (which is brought by this CAS).\n-\/\/\n-\/\/ Note that we do not need to \"acquire\" in these methods, because we do not read the\n-\/\/ failure witnesses contents on any path, and \"release\" is enough.\n-\/\/\n-\n-inline void ShenandoahHeap::atomic_update_oop(oop update, oop* addr, oop compare) {\n-  assert(is_aligned(addr, HeapWordSize), \"Address should be aligned: \" PTR_FORMAT, p2i(addr));\n-  Atomic::cmpxchg(addr, compare, update, memory_order_release);\n-}\n-\n-inline void ShenandoahHeap::atomic_update_oop(oop update, narrowOop* addr, narrowOop compare) {\n-  assert(is_aligned(addr, sizeof(narrowOop)), \"Address should be aligned: \" PTR_FORMAT, p2i(addr));\n-  narrowOop u = CompressedOops::encode(update);\n-  Atomic::cmpxchg(addr, compare, u, memory_order_release);\n-}\n-\n-inline void ShenandoahHeap::atomic_update_oop(oop update, narrowOop* addr, oop compare) {\n-  assert(is_aligned(addr, sizeof(narrowOop)), \"Address should be aligned: \" PTR_FORMAT, p2i(addr));\n-  narrowOop c = CompressedOops::encode(compare);\n-  narrowOop u = CompressedOops::encode(update);\n-  Atomic::cmpxchg(addr, c, u, memory_order_release);\n-}\n-\n@@ -294,1 +231,1 @@\n-    return ShenandoahBarrierSet::resolve_forwarded(p);\n+    return ShenandoahForwarding::get_forwardee_maybe_null(p);\n@@ -329,1 +266,1 @@\n-    return ShenandoahBarrierSet::resolve_forwarded(p);\n+    return ShenandoahForwarding::get_forwardee_maybe_null(p);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.inline.hpp","additions":5,"deletions":68,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -174,1 +174,1 @@\n-    oop fwd = ShenandoahForwarding::get_forwardee_raw_unchecked(obj);\n+    oop fwd = ShenandoahForwarding::get_forwardee_raw(obj);\n@@ -207,1 +207,1 @@\n-      oop fwd2 = ShenandoahForwarding::get_forwardee_raw_unchecked(fwd);\n+      oop fwd2 = ShenandoahForwarding::get_forwardee_raw(fwd);\n@@ -921,1 +921,1 @@\n-      oop fwd = ShenandoahForwarding::get_forwardee_raw_unchecked(obj);\n+      oop fwd = ShenandoahForwarding::get_forwardee_raw(obj);\n@@ -953,1 +953,1 @@\n-      oop fwd = ShenandoahForwarding::get_forwardee_raw_unchecked(obj);\n+      oop fwd = ShenandoahForwarding::get_forwardee_raw(obj);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVerifier.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"}]}