{"files":[{"patch":"@@ -215,0 +215,5 @@\n+\n+  \/\/ Load the forwardee with \"consume\" semantics, which in this case\n+  \/\/ can be done with just a plain load, as AArch64 maintains ordering\n+  \/\/ with address dependencies. See ShenandoahForwarding helpers for\n+  \/\/ more discussion.\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shenandoah\/shenandoahBarrierSetAssembler_aarch64.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -737,1 +737,3 @@\n-  \/\/ Load and mask forwarding pointer\n+  \/\/ Load and mask forwarding pointer with \"consume\" semantics, which in this case\n+  \/\/ can be done with just a plain load, as x86 maintains ordering with address\n+  \/\/ dependencies. See ShenandoahForwarding helpers for more discussion.\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shenandoah\/shenandoahBarrierSetAssembler_x86.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,0 +34,40 @@\n+\/*\n+ * Implementation note on memory ordering:\n+ *\n+ * Since concurrent GC like Shenandoah effectively publishes the forwardee copy\n+ * to concurrently running mutators, we need to consider the memory ordering\n+ * that comes with it. Most crucially, we need to ensure that all the stores to\n+ * the forwardee before its publication are visible to readers of the forwardee.\n+ * This is the GC hotpath, and thus the weakest synchronization should be used.\n+ *\n+ * Because the whole thing is the pointer-mediated publishing, the weakest way\n+ * to achieve this is Release-Consume ordering. But, because:\n+ *   a) we do not have \"Consume\" for in Hotspot;\n+ *   b) \"Consume\" gets promoted to \"Acquire\" by most current compilers\n+ *      (because doing otherwise requires tracking load dependencies);\n+ *   c) the use of \"Consume\" is generally discouraged in current C++;\n+ *\n+ * ...Release-Acquire ordering might be considered. But, on weakly-ordered\n+ * architectures, doing \"Acquire\" on hot-path would significantly penalize users.\n+ *\n+ * We can recognize that C++ GC code hardly ever accesses the object contents after\n+ * the evacuation: the marking is done by the time evacuations happen, the evacuation\n+ * code only reads the contents of the from-copy (that is not protected by\n+ * synchronization anyhow), and update-refs only writes the object pointers themselves.\n+ * Therefore, \"Relaxed\" still works, \"Consume\" is good as the additional safety measure,\n+ * but the cost of \"Acquire\" is too high.\n+ *\n+ * The mutator code accesses forwarded objects through runtime interface, which\n+ * among other things inhibits the problematic C++ optimizations that are otherwise\n+ * would require \"Consume\".\n+ *\n+ * Hand-written arch-specific assembly code for barriers uses data dependencies to\n+ * provide \"Consume\" semantics that would not be affected by C++ compilers.\n+ *\n+ * The critical point where synchronization is needed are mark word accesses:\n+ *   1. markword loads are using the \"relaxed\" loads, due to the reasons above;\n+ *   2. markword stores that publish new forwardee are marked with \"release\";\n+ *\n+ * TODO: When \"Consume\" is available, load mark words with \"consume\" for extra safety.\n+ *\/\n+\n@@ -85,1 +125,1 @@\n-  markWord prev_mark = obj->cas_set_mark(new_mark, old_mark, memory_order_conservative);\n+  markWord prev_mark = obj->cas_set_mark(new_mark, old_mark, memory_order_release);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahForwarding.inline.hpp","additions":41,"deletions":1,"binary":false,"changes":42,"status":"modified"}]}