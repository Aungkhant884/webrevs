{"files":[{"patch":"@@ -216,4 +216,5 @@\n-  \/\/ Make sure to load the forwardee with acquire semantics.\n-  \/\/ This matches accesses in C++ ShenandoahForwarding helpers.\n-  __ lea(tmp, Address(dst, oopDesc::mark_offset_in_bytes()));\n-  __ ldar(tmp, tmp);\n+  \/\/ Load the forwardee with \"consume\" semantics, which in this case\n+  \/\/ can be done with just a plain load, as AArch64 maintains ordering\n+  \/\/ with address dependencies. See ShenandoahForwarding helpers for\n+  \/\/ more discussion.\n+  __ ldr(tmp, Address(dst, oopDesc::mark_offset_in_bytes()));\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shenandoah\/shenandoahBarrierSetAssembler_aarch64.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -733,1 +733,3 @@\n-  \/\/ Load and mask forwarding pointer\n+  \/\/ Load and mask forwarding pointer with \"consume\" semantics, which in this case\n+  \/\/ can be done with just a plain load, as x86 maintains ordering with address\n+  \/\/ dependencies. See ShenandoahForwarding helpers for more discussion.\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shenandoah\/shenandoahBarrierSetAssembler_x86.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,0 +33,26 @@\n+\/*\n+ * Implementation note on memory ordering:\n+ *\n+ * Since concurrent GC like Shenandoah effectively publishes the forwardee copy\n+ * to concurrently running mutators, we need to consider the memory ordering\n+ * that comes with it. Most crucially, we need to ensure that all the stores to\n+ * the forwardee before its publication are visible to readers of the forwardee.\n+ * This is the GC hotpath, and thus the weakest synchronization should be used.\n+ *\n+ * Because the whole thing is the pointer-mediated publishing, the weakest way\n+ * to achieve this is Release-Consume ordering. But, because:\n+ *   a) we do not have \"Consume\" for in Hotspot;\n+ *   b) \"Consume\" gets promoted to \"Acquire\" by most current compilers\n+ *      (because doing otherwise requires tracking load dependencies);\n+ *   c) the use of \"Consume\" is generally discouraged in current C++;\n+ *\n+ * ...Release-Acquire ordering is as good. Hand-written arch-specific assembly code\n+ * can use data dependencies to provide \"Consume\" semantics that would not be\n+ * affected by C++ compilers.\n+ *\n+ * The criticial point where synchronization is needed are mark word accesses:\n+ *   1. markword loads that are then decoded into forwardee are marked with \"acquire\";\n+ *   2. markword loads that are not decoded into forwardee (e.g. is_forwarded) can still be relaxed;\n+ *   3. markword stores that publish new forwardee are marked with \"release\"\n+ *\/\n+\n@@ -84,5 +110,0 @@\n-\n-  \/\/ We need a stronger acq\/rel memory order here. Release on successful forwardee\n-  \/\/ update guarantees publishing the new object copy contents correctly\n-  \/\/ (would be paired with acquire in forwardee accessors). Acquire on failed update\n-  \/\/ would get the updated object after the forwardee load.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahForwarding.inline.hpp","additions":26,"deletions":5,"binary":false,"changes":31,"status":"modified"}]}