{"files":[{"patch":"@@ -215,0 +215,5 @@\n+\n+  \/\/ Load the forwardee with \"consume\" semantics, which in this case\n+  \/\/ can be done with just a plain load, as AArch64 maintains ordering\n+  \/\/ with address dependencies. See ShenandoahForwarding helpers for\n+  \/\/ more discussion.\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shenandoah\/shenandoahBarrierSetAssembler_aarch64.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -733,1 +733,3 @@\n-  \/\/ Load and mask forwarding pointer\n+  \/\/ Load and mask forwarding pointer with \"consume\" semantics, which in this case\n+  \/\/ can be done with just a plain load, as x86 maintains ordering with address\n+  \/\/ dependencies. See ShenandoahForwarding helpers for more discussion.\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shenandoah\/shenandoahBarrierSetAssembler_x86.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,0 +33,26 @@\n+\/*\n+ * Implementation note on memory ordering:\n+ *\n+ * Since concurrent GC like Shenandoah effectively publishes the forwardee copy\n+ * to concurrently running mutators, we need to consider the memory ordering\n+ * that comes with it. Most crucially, we need to ensure that all the stores to\n+ * the forwardee before its publication are visible to readers of the forwardee.\n+ * This is the GC hotpath, and thus the weakest synchronization should be used.\n+ *\n+ * Because the whole thing is the pointer-mediated publishing, the weakest way\n+ * to achieve this is Release-Consume ordering. But, because:\n+ *   a) we do not have \"Consume\" for in Hotspot;\n+ *   b) \"Consume\" gets promoted to \"Acquire\" by most current compilers\n+ *      (because doing otherwise requires tracking load dependencies);\n+ *   c) the use of \"Consume\" is generally discouraged in current C++;\n+ *\n+ * ...Release-Acquire ordering is as good. Hand-written arch-specific assembly code\n+ * can use data dependencies to provide \"Consume\" semantics that would not be\n+ * affected by C++ compilers.\n+ *\n+ * The criticial point where synchronization is needed are mark word accesses:\n+ *   1. markword loads that are then decoded into forwardee are marked with \"acquire\";\n+ *   2. markword loads that are not decoded into forwardee (e.g. is_forwarded) can still be relaxed;\n+ *   3. markword stores that publish new forwardee are marked with \"release\"\n+ *\/\n+\n@@ -43,1 +69,1 @@\n-  markWord mark = obj->mark();\n+  markWord mark = obj->mark_acquire();\n@@ -58,1 +84,1 @@\n-  markWord mark = obj->mark();\n+  markWord mark = obj->mark_acquire();\n@@ -78,1 +104,1 @@\n-  markWord old_mark = obj->mark();\n+  markWord old_mark = obj->mark_acquire();\n@@ -84,1 +110,1 @@\n-  markWord prev_mark = obj->cas_set_mark(new_mark, old_mark, memory_order_conservative);\n+  markWord prev_mark = obj->cas_set_mark(new_mark, old_mark, memory_order_acq_rel);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahForwarding.inline.hpp","additions":30,"deletions":4,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -61,2 +61,3 @@\n-  inline markWord  mark()          const;\n-  inline markWord* mark_addr() const;\n+  inline markWord  mark()         const;\n+  inline markWord  mark_acquire() const;\n+  inline markWord* mark_addr()    const;\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -49,0 +49,5 @@\n+  return markWord(v);\n+}\n+\n+markWord oopDesc::mark_acquire() const {\n+  uintptr_t v = HeapAccess<MO_ACQUIRE>::load_at(as_oop(), mark_offset_in_bytes());\n","filename":"src\/hotspot\/share\/oops\/oop.inline.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"}]}