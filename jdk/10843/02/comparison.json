{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,0 +42,4 @@\n+    boolean isCaseInsensitiveAndPreserving() {\n+        return true;\n+    }\n+\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/fs\/MacOSXFileSystem.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -122,0 +122,4 @@\n+    boolean isCaseInsensitiveAndPreserving() {\n+        return false;\n+    }\n+\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixFileSystem.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -814,0 +814,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -832,1 +833,1 @@\n-        for (int i=0; i<absolute.getNameCount(); i++) {\n+        for (int i = 0; i < absolute.getNameCount(); i++) {\n@@ -836,1 +837,2 @@\n-            if ((element.asByteArray().length == 1) && (element.asByteArray()[0] == '.'))\n+            if ((element.asByteArray().length == 1) &&\n+                (element.asByteArray()[0] == '.'))\n@@ -840,1 +842,2 @@\n-            if ((element.asByteArray().length == 2) && (element.asByteArray()[0] == '.') &&\n+            if ((element.asByteArray().length == 2) &&\n+                (element.asByteArray()[0] == '.') &&\n@@ -860,1 +863,1 @@\n-        \/\/ check file exists (without following links)\n+        \/\/ check whether file exists (without following links)\n@@ -866,1 +869,64 @@\n-        return result;\n+\n+        \/\/ Return if the file system is not both case insensitive and retentive\n+        if (!fs.isCaseInsensitiveAndPreserving())\n+            return result;\n+\n+        UnixPath path = fs.rootDirectory();\n+\n+        SecurityManager sm = System.getSecurityManager();\n+\n+        \/\/ Traverse the result obtained above from the root downward, leaving\n+        \/\/ any '..' elements intact, and replacing other elements with the\n+        \/\/ entry in the same directory which has an equal key\n+        for (int i = 0; i < result.getNameCount(); i++ ) {\n+            UnixPath element = result.getName(i);\n+\n+            \/\/ If the element is \"..\", append it directly and continue\n+            if (element.toString().equals(\"..\")) {\n+                path = path.resolve(element);\n+                continue;\n+            }\n+\n+            \/\/ Derive full path to element and check readability\n+            UnixPath elementPath = path.resolve(element);\n+\n+            \/\/ Derive element key\n+            UnixFileAttributes attrs = null;\n+            try {\n+                attrs = UnixFileAttributes.get(elementPath, false);\n+            } catch (UnixException x) {\n+                x.rethrowAsIOException(result);\n+            }\n+            final UnixFileKey elementKey = attrs.fileKey();\n+\n+            \/\/ Obtain the stream of entries in the directory corresponding\n+            \/\/ to the path constructed thus far, and extract the entry whose\n+            \/\/ key is equal to the key of the current element\n+            DirectoryStream.Filter<Path> filter = (p) -> { return true; };\n+            try (DirectoryStream<Path> entries =\n+                getFileSystem().provider().newDirectoryStream(path, filter)) {\n+                boolean found = false;\n+                for (Path entry : entries) {\n+                    UnixPath p = path.resolve(entry.getFileName());\n+                    UnixFileAttributes attributes = null;\n+                    try {\n+                        attributes = UnixFileAttributes.get(p, false);\n+                        UnixFileKey key = attributes.fileKey();\n+                        if (key.equals(elementKey)) {\n+                            path = path.resolve(entry);\n+                            found = true;\n+                            break;\n+                        }\n+                    } catch (UnixException ignore) {\n+                        continue;\n+                    }\n+                }\n+\n+                \/\/ Fallback which should in theory never happen\n+                if (!found) {\n+                    path = path.resolve(element);\n+                }\n+            }\n+        }\n+\n+        return path;\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixPath.java","additions":72,"deletions":6,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n- * @bug 4313887 6838333 7029979\n+ * @bug 4313887 6838333 7029979 8295753\n@@ -27,1 +27,3 @@\n- * @library ..\n+ * @library .. \/test\/lib\n+ * @build jdk.test.lib.Platform\n+ * @run main Misc\n@@ -30,0 +32,1 @@\n+import java.io.*;\n@@ -31,0 +34,1 @@\n+\n@@ -32,1 +36,2 @@\n-import java.io.*;\n+\n+import jdk.test.lib.Platform;\n@@ -35,2 +40,0 @@\n-    static final boolean isWindows =\n-        System.getProperty(\"os.name\").startsWith(\"Windows\");\n@@ -73,1 +76,1 @@\n-        if (isWindows) {\n+        if (Platform.isWindows()) {\n@@ -100,1 +103,1 @@\n-         * Test: totRealPath() will access same file as toRealPath(NOFOLLOW_LINKS)\n+         * Test: toRealPath() will access same file as toRealPath(NOFOLLOW_LINKS)\n@@ -124,1 +127,1 @@\n-            if (isWindows) {\n+            if (Platform.isWindows()) {\n@@ -173,1 +176,43 @@\n-        Files.delete(subdir);\n+\n+        \/**\n+         * Test: toRealPath yields accurate case of path elements when\n+         *       not following links\n+         *\/\n+        if (Platform.isOSX()) {\n+            \/\/ theTarget = dir\/subdir\/theTarget\n+            Path theTarget = Path.of(subdir.toString(), \"theTarget\");\n+            Files.createFile(theTarget);\n+\n+            \/\/ dir\/theLink -> dir\/subdir\n+            Path theLink = Path.of(dir.toString(), \"theLink\");\n+            Files.createSymbolicLink(theLink, subdir);\n+\n+            \/\/ thePath = dir\/thelink\/thetarget (all lower case)\n+            Path thePath = Path.of(dir.toString(), \"thelink\", \"thetarget\");\n+            Path noFollow = thePath.toRealPath(NOFOLLOW_LINKS);\n+            int nc = noFollow.getNameCount();\n+\n+            \/\/ Real path should retain case as dir\/theLink\/theTarget\n+            assertTrue(noFollow.getName(nc - 2).equals(Path.of(\"theLink\")));\n+            assertTrue(noFollow.getName(nc - 1).equals(Path.of(\"theTarget\")));\n+            assertTrue(noFollow.toString().equals(\n+                Path.of(dir.toString(), \"theLink\", \"theTarget\").toString()));\n+\n+            \/\/ Test where a link is preceded by \"..\" in the path\n+            Path superBeforeLink =\n+                Path.of(subdir.toString(), \"..\", \"thelink\", \"thetarget\");\n+            noFollow = superBeforeLink.toRealPath(NOFOLLOW_LINKS);\n+            nc = noFollow.getNameCount();\n+            assertTrue(noFollow.getName(nc - 2).equals(Path.of(\"theLink\")));\n+            assertTrue(noFollow.getName(nc - 1).equals(Path.of(\"theTarget\")));\n+\n+            \/\/ Test where a link is followed by \"..\" in the path\n+            Path linkBeforeSuper =\n+                Path.of(dir.toString(), \"thelink\", \"..\", \"subdir\", \"thetarget\");\n+            noFollow = linkBeforeSuper.toRealPath(NOFOLLOW_LINKS);\n+            nc = noFollow.getNameCount();\n+            assertTrue(noFollow.getName(nc - 4).equals(Path.of(\"theLink\")));\n+            assertTrue(noFollow.getName(nc - 1).equals(Path.of(\"theTarget\")));\n+\n+            Files.delete(theTarget);\n+        }\n@@ -176,0 +221,1 @@\n+        Files.delete(subdir);\n","filename":"test\/jdk\/java\/nio\/file\/Path\/Misc.java","additions":56,"deletions":10,"binary":false,"changes":66,"status":"modified"}]}