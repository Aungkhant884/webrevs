{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,0 +42,4 @@\n+    boolean isCaseInsensitiveAndRetentive() {\n+        return true;\n+    }\n+\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/fs\/MacOSXFileSystem.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -122,0 +122,4 @@\n+    boolean isCaseInsensitiveAndRetentive() {\n+        return false;\n+    }\n+\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixFileSystem.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,2 @@\n+import java.util.function.Predicate;\n+import java.util.stream.Stream;\n@@ -836,1 +838,2 @@\n-            if ((element.asByteArray().length == 1) && (element.asByteArray()[0] == '.'))\n+            if ((element.asByteArray().length == 1) &&\n+                (element.asByteArray()[0] == '.'))\n@@ -840,1 +843,2 @@\n-            if ((element.asByteArray().length == 2) && (element.asByteArray()[0] == '.') &&\n+            if ((element.asByteArray().length == 2) &&\n+                (element.asByteArray()[0] == '.') &&\n@@ -866,1 +870,34 @@\n-        return result;\n+\n+        \/\/ Return if the file system is not both case insensitive and retentive\n+        if (!fs.isCaseInsensitiveAndRetentive())\n+            return result;\n+\n+        UnixPath path = fs.rootDirectory();\n+\n+        \/\/ Traverse the result obtained above from the root downward, leaving\n+        \/\/ any '..' elements intact, and replacing other elements with the\n+        \/\/ entry in the same directory to which it is equal ignoring case\n+        for (int i = 0; i < result.getNameCount(); i++ ) {\n+            UnixPath elt = result.getName(i);\n+            String els = elt.toString();\n+\n+            \/\/ If the element is \"..\", append it directly and continue\n+            if (els.equals(\"..\")) {\n+                path = path.resolve(elt);\n+                continue;\n+            }\n+\n+            \/\/ Obtain the stream of entries in the directory corresponding\n+            \/\/ to the path constructed thus far, and extract the entry whose\n+            \/\/ name is equal ignoring case to the name of the current element\n+            try (Stream<Path> entries = Files.list(path)) {\n+                Predicate<Path> predicate =\n+                    (f) -> f.getFileName().toString().equalsIgnoreCase(els);\n+                Optional<Path> op = entries.filter(predicate).findFirst();\n+\n+                \/\/ Use entry if found, otherwise use the current element\n+                path = path.resolve(op.isPresent() ? op.get() : elt);\n+            }\n+        }\n+\n+        return path;\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixPath.java","additions":41,"deletions":4,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n- * @bug 4313887 6838333 7029979\n+ * @bug 4313887 6838333 7029979 8295753\n@@ -27,1 +27,3 @@\n- * @library ..\n+ * @library .. \/test\/lib\n+ * @build jdk.test.lib.Platform\n+ * @run main Misc\n@@ -30,0 +32,1 @@\n+import java.io.*;\n@@ -31,0 +34,1 @@\n+\n@@ -32,1 +36,2 @@\n-import java.io.*;\n+\n+import jdk.test.lib.Platform;\n@@ -35,2 +40,0 @@\n-    static final boolean isWindows =\n-        System.getProperty(\"os.name\").startsWith(\"Windows\");\n@@ -73,1 +76,1 @@\n-        if (isWindows) {\n+        if (Platform.isWindows()) {\n@@ -100,1 +103,1 @@\n-         * Test: totRealPath() will access same file as toRealPath(NOFOLLOW_LINKS)\n+         * Test: toRealPath() will access same file as toRealPath(NOFOLLOW_LINKS)\n@@ -124,1 +127,1 @@\n-            if (isWindows) {\n+            if (Platform.isWindows()) {\n@@ -173,1 +176,43 @@\n-        Files.delete(subdir);\n+\n+        \/**\n+         * Test: toRealPath yields accurate case of path elements when\n+         *       not following links\n+         *\/\n+        if (Platform.isOSX()) {\n+            \/\/ theTarget = dir\/subdir\/theTarget\n+            Path theTarget = Path.of(subdir.toString(), \"theTarget\");\n+            Files.createFile(theTarget);\n+\n+            \/\/ dir\/theLink -> dir\/subdir\n+            Path theLink = Path.of(dir.toString(), \"theLink\");\n+            Files.createSymbolicLink(theLink, subdir);\n+\n+            \/\/ thePath = dir\/thelink\/thetarget (all lower case)\n+            Path thePath = Path.of(dir.toString(), \"thelink\", \"thetarget\");\n+            Path noFollow = thePath.toRealPath(NOFOLLOW_LINKS);\n+            int nc = noFollow.getNameCount();\n+\n+            \/\/ Real path should retain case as dir\/theLink\/theTarget\n+            assertTrue(noFollow.getName(nc - 2).equals(Path.of(\"theLink\")));\n+            assertTrue(noFollow.getName(nc - 1).equals(Path.of(\"theTarget\")));\n+            assertTrue(noFollow.toString().equals(\n+                Path.of(dir.toString(), \"theLink\", \"theTarget\").toString()));\n+\n+            \/\/ Test where a link is preceded by \"..\" in the path\n+            Path superBeforeLink =\n+                Path.of(subdir.toString(), \"..\", \"thelink\", \"thetarget\");\n+            noFollow = superBeforeLink.toRealPath(NOFOLLOW_LINKS);\n+            nc = noFollow.getNameCount();\n+            assertTrue(noFollow.getName(nc - 2).equals(Path.of(\"theLink\")));\n+            assertTrue(noFollow.getName(nc - 1).equals(Path.of(\"theTarget\")));\n+\n+            \/\/ Test where a link is followed by \"..\" in the path\n+            Path linkBeforeSuper =\n+                Path.of(dir.toString(), \"thelink\", \"..\", \"subdir\", \"thetarget\");\n+            noFollow = linkBeforeSuper.toRealPath(NOFOLLOW_LINKS);\n+            nc = noFollow.getNameCount();\n+            assertTrue(noFollow.getName(nc - 4).equals(Path.of(\"theLink\")));\n+            assertTrue(noFollow.getName(nc - 1).equals(Path.of(\"theTarget\")));\n+\n+            Files.delete(theTarget);\n+        }\n@@ -176,0 +221,1 @@\n+        Files.delete(subdir);\n","filename":"test\/jdk\/java\/nio\/file\/Path\/Misc.java","additions":56,"deletions":10,"binary":false,"changes":66,"status":"modified"}]}