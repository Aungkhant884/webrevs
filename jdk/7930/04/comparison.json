{"files":[{"patch":"@@ -552,1 +552,3 @@\n-  thread->check_and_handle_async_exceptions();\n+  if (thread->has_async_exception_condition()) {\n+    SafepointMechanism::process_if_requested_with_exit_check(thread, true \/* check asyncs *\/);\n+  }\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+#include \"classfile\/javaClasses.hpp\"\n+#include \"classfile\/vmSymbols.hpp\"\n@@ -81,0 +83,2 @@\n+  bool is_async_exception()        { return _handshake_cl->is_async_exception(); }\n+  bool is_ThreadDeath()            { return _handshake_cl->is_ThreadDeath(); }\n@@ -316,1 +320,0 @@\n-    NoSafepointVerifier nsv;\n@@ -429,0 +432,1 @@\n+  _async_exceptions_blocked(false),\n@@ -446,2 +450,15 @@\n-static bool no_suspend_filter(HandshakeOperation* op) {\n-  return !op->is_suspend();\n+\/\/ Filters\n+static bool non_self_executable_filter(HandshakeOperation* op) {\n+  return !op->is_async();\n+}\n+static bool no_async_exception_filter(HandshakeOperation* op) {\n+  return !op->is_async_exception();\n+}\n+static bool async_exception_filter(HandshakeOperation* op) {\n+  return op->is_async_exception();\n+}\n+static bool is_ThreadDeath_filter(HandshakeOperation* op) {\n+  return op->is_ThreadDeath();\n+}\n+static bool no_suspend_no_async_exception_filter(HandshakeOperation* op) {\n+  return !op->is_suspend() && !op->is_async_exception();\n@@ -450,1 +467,1 @@\n-HandshakeOperation* HandshakeState::get_op_for_self(bool allow_suspend) {\n+HandshakeOperation* HandshakeState::get_op_for_self(bool allow_suspend, bool check_async_exception) {\n@@ -453,1 +470,4 @@\n-  if (allow_suspend) {\n+  assert(allow_suspend || !check_async_exception, \"invalid case\");\n+  if (!allow_suspend) {\n+    return _queue.peek(no_suspend_no_async_exception_filter);\n+  } else if (check_async_exception && !_async_exceptions_blocked) {\n@@ -456,1 +476,1 @@\n-    return _queue.peek(no_suspend_filter);\n+    return _queue.peek(no_async_exception_filter);\n@@ -460,2 +480,13 @@\n-static bool non_self_queue_filter(HandshakeOperation* op) {\n-  return !op->is_async();\n+bool HandshakeState::has_operation(bool allow_suspend, bool check_async_exception) {\n+  MutexLocker ml(&_lock, Mutex::_no_safepoint_check_flag);\n+  return get_op_for_self(allow_suspend, check_async_exception) != NULL;\n+}\n+\n+bool HandshakeState::has_async_exception_operation(bool ThreadDeath_only) {\n+  if (!has_operation()) return false;\n+  MutexLocker ml(_lock.owned_by_self() ? NULL :  &_lock, Mutex::_no_safepoint_check_flag);\n+  if (!ThreadDeath_only) {\n+    return _queue.peek(async_exception_filter) != NULL;\n+  } else {\n+    return _queue.peek(is_ThreadDeath_filter) != NULL;\n+  }\n@@ -467,6 +498,1 @@\n-  return _queue.contains(non_self_queue_filter);\n-}\n-\n-bool HandshakeState::has_a_non_suspend_operation() {\n-  MutexLocker ml(&_lock, Mutex::_no_safepoint_check_flag);\n-  return _queue.contains(no_suspend_filter);\n+  return _queue.contains(non_self_executable_filter);\n@@ -478,1 +504,1 @@\n-  return _queue.peek(non_self_queue_filter);\n+  return _queue.peek(non_self_executable_filter);\n@@ -488,1 +514,1 @@\n-bool HandshakeState::process_by_self(bool allow_suspend) {\n+bool HandshakeState::process_by_self(bool allow_suspend, bool check_async_exception) {\n@@ -496,5 +522,0 @@\n-  \/\/ Handshakes cannot safely safepoint.\n-  \/\/ The exception to this rule is the asynchronous suspension handshake.\n-  \/\/ It by-passes the NSV by manually doing the transition.\n-  NoSafepointVerifier nsv;\n-\n@@ -502,0 +523,2 @@\n+    \/\/ Handshakes cannot safely safepoint. The exceptions to this rule are\n+    \/\/ the asynchronous suspension and unsafe access error handshakes.\n@@ -504,1 +527,1 @@\n-    HandshakeOperation* op = get_op_for_self(allow_suspend);\n+    HandshakeOperation* op = get_op_for_self(allow_suspend, check_async_exception);\n@@ -520,1 +543,0 @@\n-        op->do_handshake(_handshakee); \/\/ acquire, op removed after\n@@ -522,0 +544,1 @@\n+        op->do_handshake(_handshakee);\n@@ -733,0 +756,26 @@\n+\n+void HandshakeState::handle_unsafe_access_error() {\n+  if (is_suspended()) {\n+    \/\/ A suspend handshake was added to the queue after the\n+    \/\/ unsafe access error. Since the suspender has already\n+    \/\/ considered this JT as suspended and assumes it won't go\n+    \/\/ back to Java until resumed we cannot create the exception\n+    \/\/ object yet. Add a new unsafe access error operation to\n+    \/\/ the end of the queue and try again in the next attempt.\n+    Handshake::execute(new UnsafeAccessErrorHandshake(), _handshakee);\n+    log_info(handshake)(\"JavaThread \" INTPTR_FORMAT \" skipping unsafe access processing due to suspend.\", p2i(_handshakee));\n+    return;\n+  }\n+  \/\/ Release the handshake lock before constructing the oop to\n+  \/\/ avoid deadlocks since that can block. This will allow the\n+  \/\/ JavaThread to execute normally as if it was outside a handshake.\n+  \/\/ We will reacquire the handshake lock at return from ~MutexUnlocker.\n+  MutexUnlocker ml(&_lock, Mutex::_no_safepoint_check_flag);\n+  \/\/ We may be at method entry which requires we save the do-not-unlock flag.\n+  UnlockFlagSaver fs(_handshakee);\n+  Handle h_exception = Exceptions::new_exception(_handshakee, vmSymbols::java_lang_InternalError(), \"a fault occurred in an unsafe memory access operation\");\n+  if (h_exception()->is_a(vmClasses::InternalError_klass())) {\n+    java_lang_InternalError::set_during_unsafe_access(h_exception());\n+  }\n+  _handshakee->handle_async_exception(h_exception());\n+}\n","filename":"src\/hotspot\/share\/runtime\/handshake.cpp","additions":72,"deletions":23,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+class AsyncHandshakeOperation;\n@@ -39,0 +40,1 @@\n+class UnsafeAccessErrorHandshake;\n@@ -54,0 +56,2 @@\n+  virtual bool is_async_exception()                { return false; }\n+  virtual bool is_ThreadDeath()                    { return false; }\n@@ -90,0 +94,1 @@\n+  friend UnsafeAccessErrorHandshake;\n@@ -107,1 +112,1 @@\n-  HandshakeOperation* get_op_for_self(bool allow_suspend);\n+  HandshakeOperation* get_op_for_self(bool allow_suspend, bool check_async_exception);\n@@ -127,4 +132,3 @@\n-  bool has_operation() {\n-    return !_queue.is_empty();\n-  }\n-  bool has_a_non_suspend_operation();\n+  bool has_operation() { return !_queue.is_empty(); }\n+  bool has_operation(bool allow_suspend, bool check_async_exception);\n+  bool has_async_exception_operation(bool ThreadDeath_only);\n@@ -137,1 +141,1 @@\n-  bool process_by_self(bool allow_suspend);\n+  bool process_by_self(bool allow_suspend, bool check_async_exception);\n@@ -151,0 +155,8 @@\n+  \/\/ Support for asynchronous exceptions\n+ private:\n+  bool _async_exceptions_blocked;\n+\n+  bool async_exceptions_blocked() { return _async_exceptions_blocked; }\n+  void set_async_exceptions_blocked(bool b) { _async_exceptions_blocked = b; }\n+  void handle_unsafe_access_error();\n+\n","filename":"src\/hotspot\/share\/runtime\/handshake.hpp","additions":18,"deletions":6,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -213,1 +213,1 @@\n-      SafepointMechanism::process_if_requested(_thread, _allow_suspend);\n+      SafepointMechanism::process_if_requested(_thread, _allow_suspend, false \/* check_async_exception *\/);\n","filename":"src\/hotspot\/share\/runtime\/interfaceSupport.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1900,1 +1900,4 @@\n-      if (SafepointMechanism::should_process(current)) {\n+      \/\/ Can't call SafepointMechanism::should_process() since that\n+      \/\/ might update the poll values and we could be in a thread_blocked\n+      \/\/ state here which is not allowed so just check the poll.\n+      if (SafepointMechanism::local_poll_armed(current)) {\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -966,4 +966,6 @@\n-    \/\/ compiler may not have an exception handler for it. The polling\n-    \/\/ code will notice the pending async exception, deoptimize and\n-    \/\/ the exception will be delivered. (Polling at a return point\n-    \/\/ is ok though). Sure is a lot of bother for a deprecated feature...\n+    \/\/ compiler may not have an exception handler for it (polling at\n+    \/\/ a return point is ok though). We will check for a pending async\n+    \/\/ exception below and deoptimize if needed. We also cannot deoptimize\n+    \/\/ and still install the exception here because live registers needed\n+    \/\/ during deoptimization are clobbered by the exception path. The\n+    \/\/ exception will just be delivered once we get into the interpreter.\n@@ -973,2 +975,0 @@\n-    \/\/ If we have a pending async exception deoptimize the frame\n-    \/\/ as otherwise we may never deliver it.\n@@ -977,0 +977,1 @@\n+      log_info(exceptions)(\"deferred async exception at compiled safepoint\");\n@@ -979,3 +980,1 @@\n-    \/\/ If an exception has been installed we must check for a pending deoptimization\n-    \/\/ Deoptimize frame if exception has been thrown.\n-\n+    \/\/ If an exception has been installed we must verify that the top frame wasn't deoptimized.\n@@ -986,7 +985,9 @@\n-        \/\/ The exception patch will destroy registers that are still\n-        \/\/ live and will be needed during deoptimization. Defer the\n-        \/\/ Async exception should have deferred the exception until the\n-        \/\/ next safepoint which will be detected when we get into\n-        \/\/ the interpreter so if we have an exception now things\n-        \/\/ are messed up.\n-\n+        \/\/ The exception path will destroy registers that are still\n+        \/\/ live and will be needed during deoptimization, so if we\n+        \/\/ have an exception now things are messed up. We only check\n+        \/\/ at this scope because for a poll return it is ok to deoptimize\n+        \/\/ while having a pending exception since the call we are returning\n+        \/\/ from already collides with exception handling registers and\n+        \/\/ so there is no issue (the exception handling path kills call\n+        \/\/ result registers but this is ok since the exception kills\n+        \/\/ the result anyway).\n","filename":"src\/hotspot\/share\/runtime\/safepoint.cpp","additions":17,"deletions":16,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -114,1 +114,1 @@\n-void SafepointMechanism::process(JavaThread *thread, bool allow_suspend) {\n+void SafepointMechanism::process(JavaThread *thread, bool allow_suspend, bool check_async_exception) {\n@@ -138,1 +138,1 @@\n-    need_rechecking = thread->handshake_state()->has_operation() && thread->handshake_state()->process_by_self(allow_suspend);\n+    need_rechecking = thread->handshake_state()->has_operation() && thread->handshake_state()->process_by_self(allow_suspend, check_async_exception);\n","filename":"src\/hotspot\/share\/runtime\/safepointMechanism.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-  static void process(JavaThread *thread, bool allow_suspend);\n+  static void process(JavaThread *thread, bool allow_suspend, bool check_async_exception);\n@@ -83,2 +83,2 @@\n-  static inline void process_if_requested(JavaThread* thread, bool allow_suspend = true);\n-  static inline void process_if_requested_with_exit_check(JavaThread* thread, bool check_asyncs);\n+  static inline void process_if_requested(JavaThread* thread, bool allow_suspend, bool check_async_exception);\n+  static inline void process_if_requested_with_exit_check(JavaThread* thread, bool check_async_exception);\n","filename":"src\/hotspot\/share\/runtime\/safepointMechanism.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -69,2 +69,0 @@\n-  } else if (allow_suspend) {\n-    return true;\n@@ -72,1 +70,1 @@\n-  \/\/  We are armed but we should ignore suspend operations.\n+\n@@ -74,1 +72,1 @@\n-      thread->handshake_state()->has_a_non_suspend_operation() || \/\/ Non-suspend handshake\n+      thread->handshake_state()->has_operation(allow_suspend, false \/* check_async_exception *\/) || \/\/ Handshake\n@@ -81,1 +79,1 @@\n-  \/\/ 2: We have a suspend handshake, which cannot be processed.\n+  \/\/ 2: We have a suspend or async exception handshake, which cannot be processed.\n@@ -91,1 +89,1 @@\n-void SafepointMechanism::process_if_requested(JavaThread* thread, bool allow_suspend) {\n+void SafepointMechanism::process_if_requested(JavaThread* thread, bool allow_suspend, bool check_async_exception) {\n@@ -96,1 +94,1 @@\n-    process(thread, allow_suspend);\n+    process(thread, allow_suspend, check_async_exception);\n@@ -100,2 +98,2 @@\n-void SafepointMechanism::process_if_requested_with_exit_check(JavaThread* thread, bool check_asyncs) {\n-  process_if_requested(thread);\n+void SafepointMechanism::process_if_requested_with_exit_check(JavaThread* thread, bool check_async_exception) {\n+  process_if_requested(thread, true \/* allow_suspend *\/, check_async_exception);\n@@ -103,1 +101,1 @@\n-    thread->handle_special_runtime_exit_condition(check_asyncs);\n+    thread->handle_special_runtime_exit_condition();\n","filename":"src\/hotspot\/share\/runtime\/safepointMechanism.inline.hpp","additions":8,"deletions":10,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -269,1 +269,1 @@\n-  if (SafepointMechanism::should_process(thread)) {\n+  if (SafepointMechanism::local_poll_armed(thread)) {\n","filename":"src\/hotspot\/share\/runtime\/sweeper.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1017,4 +1017,0 @@\n-  _pending_async_exception(nullptr),\n-#ifdef ASSERT\n-  _is_unsafe_access_error(false),\n-#endif\n@@ -1588,0 +1584,8 @@\n+void JavaThread::handle_special_runtime_exit_condition() {\n+  if (is_obj_deopt_suspend()) {\n+    frame_anchor()->make_walkable(this);\n+    wait_for_object_deoptimization();\n+  }\n+  JFR_ONLY(SUSPEND_THREAD_CONDITIONAL(this);)\n+}\n+\n@@ -1591,24 +1595,3 @@\n-void JavaThread::check_and_handle_async_exceptions() {\n-  if (has_last_Java_frame() && has_async_exception_condition()) {\n-    \/\/ If we are at a polling page safepoint (not a poll return)\n-    \/\/ then we must defer async exception because live registers\n-    \/\/ will be clobbered by the exception path. Poll return is\n-    \/\/ ok because the call we are returning from already collides\n-    \/\/ with exception handling registers and so there is no issue.\n-    \/\/ (The exception handling path kills call result registers but\n-    \/\/  this is ok since the exception kills the result anyway).\n-\n-    if (is_at_poll_safepoint()) {\n-      \/\/ if the code we are returning to has deoptimized we must defer\n-      \/\/ the exception otherwise live registers get clobbered on the\n-      \/\/ exception path before deoptimization is able to retrieve them.\n-      \/\/\n-      RegisterMap map(this, false);\n-      frame caller_fr = last_frame().sender(&map);\n-      assert(caller_fr.is_compiled_frame(), \"what?\");\n-      if (caller_fr.is_deoptimized_frame()) {\n-        log_info(exceptions)(\"deferred async exception at compiled safepoint\");\n-        return;\n-      }\n-    }\n-  }\n+void JavaThread::handle_async_exception(oop java_throwable) {\n+  assert(java_throwable != NULL, \"should have an _async_exception to throw\");\n+  assert(!is_at_poll_safepoint(), \"should have never called this method\");\n@@ -1616,3 +1599,12 @@\n-  if (!clear_async_exception_condition()) {\n-    if ((_suspend_flags & _async_delivery_disabled) != 0) {\n-      log_info(exceptions)(\"Async exception delivery is disabled\");\n+  if (has_last_Java_frame()) {\n+    frame f = last_frame();\n+    if (f.is_runtime_frame()) {\n+      \/\/ If the topmost frame is a runtime stub, then we are calling into\n+      \/\/ OptoRuntime from compiled code. Some runtime stubs (new, monitor_exit..)\n+      \/\/ must deoptimize the caller before continuing, as the compiled exception\n+      \/\/ handler table may not be valid.\n+      RegisterMap reg_map(this, false);\n+      frame compiled_frame = f.sender(&reg_map);\n+      if (!StressCompiledExceptionHandlers && compiled_frame.can_be_deoptimized()) {\n+        Deoptimization::deoptimize(this, compiled_frame);\n+      }\n@@ -1620,1 +1612,0 @@\n-    return;\n@@ -1623,3 +1614,2 @@\n-  if (_pending_async_exception != NULL) {\n-    \/\/ Only overwrite an already pending exception if it is not a threadDeath.\n-    if (!has_pending_exception() || !pending_exception()->is_a(vmClasses::ThreadDeath_klass())) {\n+  \/\/ Only overwrite an already pending exception if it is not a ThreadDeath.\n+  if (!has_pending_exception() || !pending_exception()->is_a(vmClasses::ThreadDeath_klass())) {\n@@ -1627,2 +1617,2 @@\n-      \/\/ We cannot call Exceptions::_throw(...) here because we cannot block\n-      set_pending_exception(_pending_async_exception, __FILE__, __LINE__);\n+    \/\/ We cannot call Exceptions::_throw(...) here because we cannot block\n+    set_pending_exception(java_throwable, __FILE__, __LINE__);\n@@ -1630,10 +1620,8 @@\n-      LogTarget(Info, exceptions) lt;\n-      if (lt.is_enabled()) {\n-        ResourceMark rm;\n-        LogStream ls(lt);\n-        ls.print(\"Async. exception installed at runtime exit (\" INTPTR_FORMAT \")\", p2i(this));\n-          if (has_last_Java_frame()) {\n-            frame f = last_frame();\n-           ls.print(\" (pc: \" INTPTR_FORMAT \" sp: \" INTPTR_FORMAT \" )\", p2i(f.pc()), p2i(f.sp()));\n-          }\n-        ls.print_cr(\" of type: %s\", _pending_async_exception->klass()->external_name());\n+    LogTarget(Info, exceptions) lt;\n+    if (lt.is_enabled()) {\n+      ResourceMark rm;\n+      LogStream ls(lt);\n+      ls.print(\"Async. exception installed at runtime exit (\" INTPTR_FORMAT \")\", p2i(this));\n+      if (has_last_Java_frame()) {\n+        frame f = last_frame();\n+        ls.print(\" (pc: \" INTPTR_FORMAT \" sp: \" INTPTR_FORMAT \" )\", p2i(f.pc()), p2i(f.sp()));\n@@ -1641,0 +1629,1 @@\n+      ls.print_cr(\" of type: %s\", java_throwable->klass()->external_name());\n@@ -1642,13 +1631,0 @@\n-    \/\/ Always null out the _pending_async_exception oop here since the async condition was\n-    \/\/ already cleared above and thus considered handled.\n-    _pending_async_exception = NULL;\n-  } else {\n-    assert(_is_unsafe_access_error, \"must be\");\n-    DEBUG_ONLY(_is_unsafe_access_error = false);\n-\n-    \/\/ We may be at method entry which requires we save the do-not-unlock flag.\n-    UnlockFlagSaver fs(this);\n-    Exceptions::throw_unsafe_access_internal_error(this, __FILE__, __LINE__, \"a fault occurred in an unsafe memory access operation\");\n-    \/\/ We might have blocked in a ThreadBlockInVM wrapper in the call above so make sure we process pending\n-    \/\/ suspend requests and object reallocation operations if any since we might be going to Java after this.\n-    SafepointMechanism::process_if_requested_with_exit_check(this, true \/* check asyncs *\/);\n@@ -1658,1 +1634,6 @@\n-void JavaThread::handle_special_runtime_exit_condition(bool check_asyncs) {\n+void JavaThread::install_async_exception(AsyncExceptionHandshake* aeh) {\n+  \/\/ Do not throw asynchronous exceptions against the compiler thread.\n+  if (!can_call_java()) {\n+    delete aeh;\n+    return;\n+  }\n@@ -1660,3 +1641,8 @@\n-  if (is_obj_deopt_suspend()) {\n-    frame_anchor()->make_walkable(this);\n-    wait_for_object_deoptimization();\n+  \/\/ Don't install a new pending async exception if there is already\n+  \/\/ a pending ThreadDeath one. Just interrupt thread from potential\n+  \/\/ wait()\/sleep()\/park() and return.\n+  if (has_async_exception_condition(true \/* ThreadDeath_only *\/)) {\n+    java_lang_Thread::set_interrupted(threadObj(), true);\n+    this->interrupt();\n+    delete aeh;\n+    return;\n@@ -1665,4 +1651,7 @@\n-  \/\/ We might be here for reasons in addition to the self-suspend request\n-  \/\/ so check for other async requests.\n-  if (check_asyncs) {\n-    check_and_handle_async_exceptions();\n+  oop exception = aeh->exception();\n+  Handshake::execute(aeh, this);  \/\/ Install asynchronous handshake\n+\n+  ResourceMark rm;\n+  if (log_is_enabled(Info, exceptions)) {\n+    log_info(exceptions)(\"Pending Async. exception installed of type: %s\",\n+                         InstanceKlass::cast(exception->klass())->external_name());\n@@ -1670,0 +1659,2 @@\n+  \/\/ for AbortVMOnException flag\n+  Exceptions::debug_check_abort(exception->klass()->external_name());\n@@ -1671,1 +1662,3 @@\n-  JFR_ONLY(SUSPEND_THREAD_CONDITIONAL(this);)\n+  \/\/ Interrupt thread so it will wake up from a potential wait()\/sleep()\/park()\n+  java_lang_Thread::set_interrupted(threadObj(), true);\n+  this->interrupt();\n@@ -1674,2 +1667,2 @@\n-class InstallAsyncExceptionClosure : public HandshakeClosure {\n-  Handle _throwable; \/\/ The Throwable thrown at the target Thread\n+class InstallAsyncExceptionHandshake : public HandshakeClosure {\n+  AsyncExceptionHandshake* _aeh;\n@@ -1677,2 +1670,2 @@\n-  InstallAsyncExceptionClosure(Handle throwable) : HandshakeClosure(\"InstallAsyncException\"), _throwable(throwable) {}\n-\n+  InstallAsyncExceptionHandshake(AsyncExceptionHandshake* aeh) :\n+    HandshakeClosure(\"InstallAsyncException\"), _aeh(aeh) {}\n@@ -1681,4 +1674,1 @@\n-    \/\/ Note that this now allows multiple ThreadDeath exceptions to be\n-    \/\/ thrown at a thread.\n-    \/\/ The target thread has run and has not exited yet.\n-    target->send_thread_stop(_throwable());\n+    target->install_async_exception(_aeh);\n@@ -1689,50 +1679,3 @@\n-  Handle throwable(Thread::current(), java_throwable);\n-  InstallAsyncExceptionClosure vm_stop(throwable);\n-  Handshake::execute(&vm_stop, target);\n-}\n-\n-void JavaThread::send_thread_stop(oop java_throwable)  {\n-  ResourceMark rm;\n-  assert(is_handshake_safe_for(Thread::current()),\n-         \"should be self or handshakee\");\n-\n-  \/\/ Do not throw asynchronous exceptions against the compiler thread\n-  \/\/ (the compiler thread should not be a Java thread -- fix in 1.4.2)\n-  if (!can_call_java()) return;\n-\n-  {\n-    \/\/ Actually throw the Throwable against the target Thread - however\n-    \/\/ only if there is no thread death exception installed already.\n-    if (_pending_async_exception == NULL || !_pending_async_exception->is_a(vmClasses::ThreadDeath_klass())) {\n-      \/\/ If the topmost frame is a runtime stub, then we are calling into\n-      \/\/ OptoRuntime from compiled code. Some runtime stubs (new, monitor_exit..)\n-      \/\/ must deoptimize the caller before continuing, as the compiled  exception handler table\n-      \/\/ may not be valid\n-      if (has_last_Java_frame()) {\n-        frame f = last_frame();\n-        if (f.is_runtime_frame() || f.is_safepoint_blob_frame()) {\n-          RegisterMap reg_map(this, false);\n-          frame compiled_frame = f.sender(&reg_map);\n-          if (!StressCompiledExceptionHandlers && compiled_frame.can_be_deoptimized()) {\n-            Deoptimization::deoptimize(this, compiled_frame);\n-          }\n-        }\n-      }\n-\n-      \/\/ Set async. pending exception in thread.\n-      set_pending_async_exception(java_throwable);\n-\n-      if (log_is_enabled(Info, exceptions)) {\n-         ResourceMark rm;\n-        log_info(exceptions)(\"Pending Async. exception installed of type: %s\",\n-                             InstanceKlass::cast(_pending_async_exception->klass())->external_name());\n-      }\n-      \/\/ for AbortVMOnException flag\n-      Exceptions::debug_check_abort(_pending_async_exception->klass()->external_name());\n-    }\n-  }\n-\n-\n-  \/\/ Interrupt thread so it will wake up from a potential wait()\/sleep()\/park()\n-  java_lang_Thread::set_interrupted(threadObj(), true);\n-  this->interrupt();\n+  OopHandle e(Universe::vm_global(), java_throwable);\n+  InstallAsyncExceptionHandshake iaeh(new AsyncExceptionHandshake(e));\n+  Handshake::execute(&iaeh, target);\n@@ -1969,1 +1912,0 @@\n-  f->do_oop((oop*) &_pending_async_exception);\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":70,"deletions":128,"binary":false,"changes":198,"status":"modified"},{"patch":"@@ -71,0 +71,1 @@\n+class AsyncExceptionHandshake;\n@@ -788,4 +789,2 @@\n-    _has_async_exception     = 0x00000001U, \/\/ there is a pending async exception\n-    _async_delivery_disabled = 0x00000002U, \/\/ async exception delivery is disabled\n-    _trace_flag              = 0x00000004U, \/\/ call tracing backend\n-    _obj_deopt               = 0x00000008U  \/\/ suspend for object reallocation and relocking for JVMTI agent\n+    _trace_flag             = 0x00000004U, \/\/ call tracing backend\n+    _obj_deopt              = 0x00000008U  \/\/ suspend for object reallocation and relocking for JVMTI agent\n@@ -795,1 +794,0 @@\n-  \/\/ overloaded with async exceptions so that we do a single check when transitioning from native->Java\n@@ -809,1 +807,1 @@\n-  \/\/ Asynchronous exceptions support\n+  \/\/ Asynchronous exception support\n@@ -811,4 +809,3 @@\n-  oop     _pending_async_exception;\n-#ifdef ASSERT\n-  bool    _is_unsafe_access_error;\n-#endif\n+  friend class InstallAsyncExceptionHandshake;\n+  friend class AsyncExceptionHandshake;\n+  friend class HandshakeState;\n@@ -816,1 +813,2 @@\n-  inline bool clear_async_exception_condition();\n+  void install_async_exception(AsyncExceptionHandshake* aec = NULL);\n+  void handle_async_exception(oop java_throwable);\n@@ -818,5 +816,1 @@\n-  bool has_async_exception_condition() {\n-    return (_suspend_flags & _has_async_exception) != 0 &&\n-           (_suspend_flags & _async_delivery_disabled) == 0;\n-  }\n-  inline void set_pending_async_exception(oop e);\n+  bool has_async_exception_condition(bool ThreadDeath_only = false);\n@@ -825,2 +819,0 @@\n-  void send_thread_stop(oop throwable);\n-  void check_and_handle_async_exceptions();\n@@ -1172,5 +1164,2 @@\n-  \/\/ these next two are also used for self-suspension and async exception support\n-  void handle_special_runtime_exit_condition(bool check_asyncs = true);\n-\n-  \/\/ Return true if JavaThread has an asynchronous condition or\n-  \/\/ if external suspension is requested.\n+  \/\/ Support for object deoptimization and JFR suspension\n+  void handle_special_runtime_exit_condition();\n@@ -1178,1 +1167,1 @@\n-    return (_suspend_flags & (_has_async_exception | _obj_deopt JFR_ONLY(| _trace_flag))) != 0;\n+    return (_suspend_flags & (_obj_deopt JFR_ONLY(| _trace_flag))) != 0;\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":13,"deletions":24,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"classfile\/vmClasses.hpp\"\n@@ -32,0 +33,3 @@\n+#include \"memory\/universe.hpp\"\n+#include \"oops\/instanceKlass.hpp\"\n+#include \"oops\/oopHandle.inline.hpp\"\n@@ -125,4 +129,7 @@\n-inline bool JavaThread::clear_async_exception_condition() {\n-  bool ret = has_async_exception_condition();\n-  if (ret) {\n-    clear_suspend_flag(_has_async_exception);\n+class AsyncExceptionHandshake : public AsyncHandshakeClosure {\n+  OopHandle _exception;\n+  bool _is_ThreadDeath;\n+ public:\n+  AsyncExceptionHandshake(OopHandle& o, const char* name = \"AsyncExceptionHandshake\")\n+  : AsyncHandshakeClosure(name), _exception(o) {\n+    _is_ThreadDeath = exception()->is_a(vmClasses::ThreadDeath_klass());\n@@ -130,2 +137,0 @@\n-  return ret;\n-}\n@@ -133,4 +138,30 @@\n-inline void JavaThread::set_pending_async_exception(oop e) {\n-  _pending_async_exception = e;\n-  set_suspend_flag(_has_async_exception);\n-}\n+  ~AsyncExceptionHandshake() {\n+    assert(!_exception.is_empty(), \"invariant\");\n+    _exception.release(Universe::vm_global());\n+  }\n+\n+  void do_thread(Thread* thr) {\n+    JavaThread* self = JavaThread::cast(thr);\n+    assert(self == JavaThread::current(), \"must be\");\n+\n+    self->handle_async_exception(exception());\n+  }\n+  oop exception() {\n+    assert(!_exception.is_empty(), \"invariant\");\n+    return _exception.resolve();\n+  }\n+  bool is_async_exception()   { return true; }\n+  bool is_ThreadDeath()       { return _is_ThreadDeath; }\n+};\n+\n+class UnsafeAccessErrorHandshake : public AsyncHandshakeClosure {\n+ public:\n+  UnsafeAccessErrorHandshake() : AsyncHandshakeClosure(\"UnsafeAccessErrorHandshake\") {}\n+  void do_thread(Thread* thr) {\n+    JavaThread* self = JavaThread::cast(thr);\n+    assert(self == JavaThread::current(), \"must be\");\n+\n+    self->handshake_state()->handle_unsafe_access_error();\n+  }\n+  bool is_async_exception()   { return true; }\n+};\n@@ -139,2 +170,3 @@\n-  set_suspend_flag(_has_async_exception);\n-  DEBUG_ONLY(_is_unsafe_access_error = true);\n+  if (!has_async_exception_condition()) {\n+    Handshake::execute(new UnsafeAccessErrorHandshake(), this);\n+  }\n@@ -143,0 +175,3 @@\n+inline bool JavaThread::has_async_exception_condition(bool ThreadDeath_only) {\n+  return handshake_state()->has_async_exception_operation(ThreadDeath_only);\n+}\n@@ -145,2 +180,2 @@\n-  assert((_target->_suspend_flags & _async_delivery_disabled) == 0, \"Nesting is not supported\");\n-  _target->set_suspend_flag(_async_delivery_disabled);\n+  assert(!_target->handshake_state()->async_exceptions_blocked(), \"Nesting is not supported\");\n+  _target->handshake_state()->set_async_exceptions_blocked(true);\n@@ -149,1 +184,1 @@\n-  _target->clear_suspend_flag(_async_delivery_disabled);\n+  _target->handshake_state()->set_async_exceptions_blocked(false);\n","filename":"src\/hotspot\/share\/runtime\/thread.inline.hpp","additions":50,"deletions":15,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -719,1 +719,0 @@\n-  nonstatic_field(JavaThread,                  _pending_async_exception,                      oop)                                   \\\n@@ -2122,6 +2121,0 @@\n-  \/*****************************\/                                         \\\n-  \/* Thread::SuspendFlags enum *\/                                         \\\n-  \/*****************************\/                                         \\\n-                                                                          \\\n-  declare_constant(JavaThread::_has_async_exception)                      \\\n-                                                                          \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -253,6 +253,0 @@\n-void Exceptions::throw_unsafe_access_internal_error(JavaThread* thread, const char* file, int line, const char* message) {\n-  Handle h_exception = new_exception(thread, vmSymbols::java_lang_InternalError(), message);\n-  java_lang_InternalError::set_during_unsafe_access(h_exception());\n-  _throw(thread, file, line, h_exception, message);\n-}\n-\n","filename":"src\/hotspot\/share\/utilities\/exceptions.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -176,2 +176,0 @@\n-  static void throw_unsafe_access_internal_error(JavaThread* thread, const char* file, int line, const char* message);\n-\n","filename":"src\/hotspot\/share\/utilities\/exceptions.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,2 +37,0 @@\n-  \/\/ Thread::SuspendFlags enum constants\n-  private static int HAS_ASYNC_EXCEPTION;\n@@ -58,1 +56,0 @@\n-    HAS_ASYNC_EXCEPTION = db.lookupIntConstant(\"JavaThread::_has_async_exception\").intValue();\n@@ -74,4 +71,0 @@\n-  public boolean hasAsyncException() {\n-    return (suspendFlags() & HAS_ASYNC_EXCEPTION) != 0;\n-  }\n-\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/Thread.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,200 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8283044\n+ * @summary Stress delivery of asynchronous exceptions while target is at monitorenter\n+ * @build AsyncExceptionOnMonitorEnter\n+ * @run main\/othervm AsyncExceptionOnMonitorEnter 0\n+ * @run main\/othervm\/native -agentlib:AsyncExceptionOnMonitorEnter AsyncExceptionOnMonitorEnter 1\n+ *\/\n+\n+import java.util.concurrent.Semaphore;\n+\n+public class AsyncExceptionOnMonitorEnter extends Thread {\n+    private final static int DEF_TIME_MAX = 30;  \/\/ default max # secs to test\n+    private final static String PROG_NAME = \"AsyncExceptionOnMonitorEnter\";\n+    private static int TEST_MODE = 0;\n+\n+    public static native int createRawMonitor();\n+    public static native int enterRawMonitor();\n+    public static native int exitRawMonitor();\n+    public static native void destroyRawMonitor();\n+\n+    private static Object o1 = new Object();\n+    private static boolean firstWorker = true;\n+    private static Semaphore sem = new Semaphore(0);\n+\n+    @Override\n+    public void run() {\n+        if (TEST_MODE == 0) {\n+            testWithJavaMonitor();\n+        } else {\n+            testWithJVMTIRawMonitor();\n+        }\n+    }\n+\n+    public void testWithJavaMonitor() {\n+        try {\n+            synchronized (o1) {\n+                if (firstWorker) {\n+                    firstWorker = false;\n+                    sem.release();\n+                }\n+                Thread.sleep(1000);\n+            }\n+        } catch (ThreadDeath td) {\n+        } catch (InterruptedException e) {\n+            throw new Error(\"Unexpected: \" + e);\n+        }\n+    }\n+\n+\n+    public void testWithJVMTIRawMonitor() {\n+        boolean savedFirst = false;\n+        try {\n+            int retCode = enterRawMonitor();\n+            if (retCode != 0 && firstWorker) {\n+                throw new RuntimeException(\"error in JVMTI RawMonitorEnter: retCode=\" + retCode);\n+            }\n+            if (firstWorker) {\n+                firstWorker = false;\n+                savedFirst = true;\n+                sem.release();\n+            }\n+            Thread.sleep(1000);\n+            retCode = exitRawMonitor();\n+            if (retCode != 0 && savedFirst) {\n+                throw new RuntimeException(\"error in JVMTI RawMonitorExit: retCode=\" + retCode);\n+            }\n+        } catch (ThreadDeath td) {\n+        } catch (InterruptedException e) {\n+            throw new Error(\"Unexpected: \" + e);\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        int timeMax = DEF_TIME_MAX;\n+        try {\n+            if (args.length == 1) {\n+                TEST_MODE = Integer.parseUnsignedInt(args[0]);\n+            } else if (args.length == 2) {\n+                TEST_MODE = Integer.parseUnsignedInt(args[0]);\n+                timeMax = Integer.parseUnsignedInt(args[1]);\n+            }\n+            if (TEST_MODE != 0 && TEST_MODE != 1) {\n+                System.err.println(\"'\" + TEST_MODE + \"': invalid mode\");\n+                usage();\n+            }\n+        } catch (NumberFormatException nfe) {\n+            System.err.println(\"'\" + args[0] + \"': invalid value.\");\n+            usage();\n+        }\n+\n+        System.out.println(\"About to execute for \" + timeMax + \" seconds.\");\n+\n+        long count = 0;\n+        long start_time = System.currentTimeMillis();\n+        while (System.currentTimeMillis() < start_time + (timeMax * 1000)) {\n+            count++;\n+\n+            if (TEST_MODE == 1) {\n+                \/\/ Create JVMTI raw monitor that will be used\n+                int retCode = createRawMonitor();\n+                if (retCode != 0) {\n+                    throw new RuntimeException(\"error in JVMTI CreateRawMonitor: retCode=\" + retCode);\n+                }\n+            }\n+\n+            AsyncExceptionOnMonitorEnter worker1 = new AsyncExceptionOnMonitorEnter();\n+            AsyncExceptionOnMonitorEnter worker2 = new AsyncExceptionOnMonitorEnter();\n+\n+            try {\n+                \/\/ Start firstWorker worker and wait until monitor is acquired\n+                firstWorker = true;\n+                worker1.start();\n+                sem.acquire();\n+\n+                \/\/ Start second worker and allow some time for target to block on monitorenter\n+                \/\/ before executing Thread.stop()\n+                worker2.start();\n+                Thread.sleep(300);\n+\n+                while (true) {\n+                    worker2.stop();\n+                    if (TEST_MODE != 1) {\n+                        \/\/ Don't stop() worker1 with JVMTI raw monitors since if the monitor is\n+                        \/\/ not released worker2 will deadlock on enter\n+                        worker1.stop();\n+                    }\n+\n+                    if (!worker1.isAlive() && !worker2.isAlive()) {\n+                        \/\/ Done with Thread.stop() calls since\n+                        \/\/ threads are not alive.\n+                        break;\n+                    }\n+                }\n+            } catch (InterruptedException e) {\n+                throw new Error(\"Unexpected: \" + e);\n+            } catch (NoClassDefFoundError ncdfe) {\n+                \/\/ Ignore because we're testing Thread.stop() which can\n+                \/\/ cause it. Yes, a NoClassDefFoundError that happens\n+                \/\/ in a worker thread can subsequently be seen in the\n+                \/\/ main thread.\n+            }\n+\n+            try {\n+                worker1.join();\n+                worker2.join();\n+            } catch (InterruptedException e) {\n+                throw new Error(\"Unexpected: \" + e);\n+            }\n+\n+            if (TEST_MODE == 1) {\n+                \/\/ Destroy JVMTI raw monitor used\n+                destroyRawMonitor();\n+            }\n+        }\n+\n+        System.out.println(\"Executed \" + count + \" loops in \" + timeMax +\n+                           \" seconds.\");\n+\n+        String cmd = System.getProperty(\"sun.java.command\");\n+        if (cmd != null && !cmd.startsWith(\"com.sun.javatest.regtest.agent.MainWrapper\")) {\n+            \/\/ Exit with success in a non-JavaTest environment:\n+            System.exit(0);\n+        }\n+    }\n+\n+    public static void usage() {\n+        System.err.println(\"Usage: \" + PROG_NAME + \" [mode [time_max]]\");\n+        System.err.println(\"where:\");\n+        System.err.println(\"    mode      0: Test with Java monitors (default); 1: Test with JVMTI raw monitors\");\n+        System.err.println(\"    time_max  max looping time in seconds\");\n+        System.err.println(\"              (default is \" + DEF_TIME_MAX +\n+                           \" seconds)\");\n+        System.exit(1);\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/Thread\/AsyncExceptionOnMonitorEnter.java","additions":200,"deletions":0,"binary":false,"changes":200,"status":"added"},{"patch":"@@ -0,0 +1,216 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8283044\n+ * @summary Stress delivery of asynchronous exceptions.\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\n+ * @build AsyncExceptionTest\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI AsyncExceptionTest\n+ *\/\n+\n+import compiler.testlibrary.CompilerUtils;\n+import compiler.whitebox.CompilerWhiteBoxTest;\n+import java.util.concurrent.CountDownLatch;\n+import sun.hotspot.WhiteBox;\n+\n+public class AsyncExceptionTest extends Thread {\n+    private final static int DEF_TIME_MAX = 30;  \/\/ default max # secs to test\n+    private final static String PROG_NAME = \"AsyncExceptionTest\";\n+\n+    public static final WhiteBox WB = WhiteBox.getWhiteBox();\n+\n+    public CountDownLatch exitSyncObj = new CountDownLatch(1);\n+    public CountDownLatch startSyncObj = new CountDownLatch(1);\n+\n+    private boolean realRun;\n+    private boolean firstEntry = true;\n+    private boolean receivedThreadDeathinInternal1 = false;\n+    private boolean receivedThreadDeathinInternal2 = false;\n+\n+    public void setDontInline(String method) {\n+        java.lang.reflect.Method m;\n+        try {\n+            m = AsyncExceptionTest.class.getMethod(method);\n+        } catch(NoSuchMethodException e) {\n+            throw new RuntimeException(\"Unexpected: \" + e);\n+        }\n+        WB.testSetDontInlineMethod(m, true);\n+    }\n+\n+    public void checkCompLevel(String method) {\n+        int highestLevel = CompilerUtils.getMaxCompilationLevel();\n+        java.lang.reflect.Method m;\n+        try {\n+            m = AsyncExceptionTest.class.getMethod(method);\n+        } catch(NoSuchMethodException e) {\n+            throw new RuntimeException(\"Unexpected: \" + e);\n+        }\n+        int compLevel = WB.getMethodCompilationLevel(m);\n+        while (compLevel < (highestLevel - 1)) {\n+            try {\n+                Thread.sleep(200);\n+            } catch (InterruptedException e) { \/* ignored *\/ }\n+            compLevel = WB.getMethodCompilationLevel(m);\n+        }\n+    }\n+\n+    @Override\n+    public void run() {\n+        try {\n+            setDontInline(\"internalRun1\");\n+            setDontInline(\"internalRun2\");\n+\n+            int callCount = CompilerWhiteBoxTest.THRESHOLD;\n+            while (callCount-- > 0) {\n+                receivedThreadDeathinInternal2 = false;\n+                realRun = false;\n+                internalRun1();\n+            }\n+            checkCompLevel(\"internalRun1\");\n+            checkCompLevel(\"internalRun2\");\n+\n+            receivedThreadDeathinInternal2 = false;\n+            realRun = true;\n+            internalRun1();\n+        } catch (ThreadDeath td) {\n+            throw new RuntimeException(\"Catched ThreadDeath in run() instead of internalRun2() or internalRun1(). receivedThreadDeathinInternal1=\" + receivedThreadDeathinInternal1 + \"; receivedThreadDeathinInternal2=\" + receivedThreadDeathinInternal2);\n+        } catch (NoClassDefFoundError ncdfe) {\n+            \/\/ ignore because we're testing Thread.stop() which can cause it\n+        }\n+\n+        if (receivedThreadDeathinInternal2 == false && receivedThreadDeathinInternal1 == false) {\n+            throw new RuntimeException(\"Didn't catched ThreadDeath in internalRun2() nor in internalRun1(). receivedThreadDeathinInternal1=\" + receivedThreadDeathinInternal1 + \"; receivedThreadDeathinInternal2=\" + receivedThreadDeathinInternal2);\n+        }\n+        exitSyncObj.countDown();\n+    }\n+\n+    public void internalRun1() {\n+        long start_time = System.currentTimeMillis();\n+        try {\n+            while (!receivedThreadDeathinInternal2) {\n+              internalRun2();\n+            }\n+        } catch (ThreadDeath e) {\n+            receivedThreadDeathinInternal1 = true;\n+        }\n+    }\n+\n+    public void internalRun2() {\n+        try {\n+            Integer myLocalCount = 1;\n+            Integer myLocalCount2 = 1;\n+\n+            if (realRun && firstEntry) {\n+                \/\/ Tell main thread we have started.\n+                startSyncObj.countDown();\n+                firstEntry = false;\n+            }\n+\n+            while(myLocalCount > 0) {\n+                if (!realRun) {\n+                    receivedThreadDeathinInternal2 = true;\n+                    break;\n+                }\n+                myLocalCount2 = (myLocalCount % 3) \/ 2;\n+                myLocalCount -= 1;\n+            }\n+        } catch (ThreadDeath e) {\n+            receivedThreadDeathinInternal2 = true;\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        int timeMax = 0;\n+        if (args.length == 0) {\n+            timeMax = DEF_TIME_MAX;\n+        } else {\n+            try {\n+                timeMax = Integer.parseUnsignedInt(args[0]);\n+            } catch (NumberFormatException nfe) {\n+                System.err.println(\"'\" + args[0] + \"': invalid timeMax value.\");\n+                usage();\n+            }\n+        }\n+\n+        System.out.println(\"About to execute for \" + timeMax + \" seconds.\");\n+\n+        long count = 0;\n+        long start_time = System.currentTimeMillis();\n+        while (System.currentTimeMillis() < start_time + (timeMax * 1000)) {\n+            count++;\n+            AsyncExceptionTest thread = new AsyncExceptionTest();\n+            thread.start();\n+            try {\n+                \/\/ Wait for the worker thread to get going.\n+                thread.startSyncObj.await();\n+                while (true) {\n+                    \/\/ Send async exception and wait until it is thrown\n+                    thread.stop();\n+                    thread.exitSyncObj.await();\n+                    Thread.sleep(100);\n+\n+                    if (!thread.isAlive()) {\n+                        \/\/ Done with Thread.stop() calls since\n+                        \/\/ thread is not alive.\n+                        break;\n+                    }\n+                }\n+            } catch (InterruptedException e) {\n+                throw new Error(\"Unexpected: \" + e);\n+            } catch (NoClassDefFoundError ncdfe) {\n+                \/\/ Ignore because we're testing Thread.stop() which can\n+                \/\/ cause it. Yes, a NoClassDefFoundError that happens\n+                \/\/ in a worker thread can subsequently be seen in the\n+                \/\/ main thread.\n+            }\n+\n+            try {\n+                thread.join();\n+            } catch (InterruptedException e) {\n+                throw new Error(\"Unexpected: \" + e);\n+            }\n+        }\n+\n+        System.out.println(\"Executed \" + count + \" loops in \" + timeMax +\n+                           \" seconds.\");\n+\n+        String cmd = System.getProperty(\"sun.java.command\");\n+        if (cmd != null && !cmd.startsWith(\"com.sun.javatest.regtest.agent.MainWrapper\")) {\n+            \/\/ Exit with success in a non-JavaTest environment:\n+            System.exit(0);\n+        }\n+    }\n+\n+    public static void usage() {\n+        System.err.println(\"Usage: \" + PROG_NAME + \" [time_max]\");\n+        System.err.println(\"where:\");\n+        System.err.println(\"    time_max  max looping time in seconds\");\n+        System.err.println(\"              (default is \" + DEF_TIME_MAX +\n+                           \" seconds)\");\n+        System.exit(1);\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/Thread\/AsyncExceptionTest.java","additions":216,"deletions":0,"binary":false,"changes":216,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <string.h>\n+#include \"jvmti.h\"\n+\n+extern \"C\" {\n+\n+static jvmtiEnv* jvmti = NULL;\n+static jrawMonitorID monitor;\n+\n+JNIEXPORT jint JNICALL\n+Java_AsyncExceptionOnMonitorEnter_createRawMonitor(JNIEnv *jni, jclass cls) {\n+  jvmtiError err;\n+  char name[32];\n+\n+  sprintf(name, \"MyRawMonitor\");\n+  err = jvmti->CreateRawMonitor(name, &monitor);\n+  if (err != JVMTI_ERROR_NONE) {\n+    printf(\"CreateRawMonitor unexpected error: (%d)\\n\", err);\n+  }\n+  return err;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_AsyncExceptionOnMonitorEnter_enterRawMonitor(JNIEnv *jni, jclass cls) {\n+  jvmtiError err;\n+  err = jvmti->RawMonitorEnter(monitor);\n+  if (err != JVMTI_ERROR_NONE) {\n+      printf(\"RawMonitorEnter unexpected error: (%d)\\n\", err);\n+  }\n+  return err;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_AsyncExceptionOnMonitorEnter_exitRawMonitor(JNIEnv *jni, jclass cls) {\n+  jvmtiError err;\n+  err = jvmti->RawMonitorExit(monitor);\n+  if (err != JVMTI_ERROR_NONE) {\n+      printf(\"RawMonitorExit unexpected error: (%d)\\n\", err);\n+  }\n+  return err;\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_AsyncExceptionOnMonitorEnter_destroyRawMonitor(JNIEnv *jni, jclass cls) {\n+  jvmtiError err;\n+  err = jvmti->DestroyRawMonitor(monitor);\n+  \/\/ Almost always worker2 will be stopped before being able to release the\n+  \/\/ JVMTI monitor so just ignore those errors.\n+  if (err != JVMTI_ERROR_NONE && err != JVMTI_ERROR_NOT_MONITOR_OWNER) {\n+    printf(\"DestroyRawMonitor unexpected error: (%d)\\n\", err);\n+  }\n+}\n+\n+JNIEXPORT jint JNICALL\n+Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n+  \/\/ create JVMTI environment\n+  if (jvm->GetEnv((void **) (&jvmti), JVMTI_VERSION) != JNI_OK) {\n+    return JNI_ERR;\n+  }\n+  return JNI_OK;\n+}\n+\n+}\n\\ No newline at end of file\n","filename":"test\/hotspot\/jtreg\/runtime\/Thread\/libAsyncExceptionOnMonitorEnter.cpp","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"}]}