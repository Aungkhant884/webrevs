[{"commit":{"message":"JDK-8267985: Allow AsyncGetCallTrace and JFR to walk a stub frame\n\nWhen the signal sent for AsyncGetCallTrace or JFR would land on a stub\n(like arraycopy), it wouldn't be able to detect the sender (caller)\nframe because `_cb->frame_size() == 0`.\n\nBecause we fully control how the prolog and epilog of stub code is\ngenerated, we know there are two cases:\n1. A stack frame is allocated via macroAssembler->enter(), and consists\nin `push rbp; mov rsp, rbp;`.\n2. No stack frames are allocated and rbp is left unchanged and rsp is\ndecremented with the `call` instruction that push the return `pc` on the\nstack.\n\nFor case 1., we can easily know the sender frame by simply looking at\nrbp, especially since we know that all stubs preserver the frame pointer\n(on x86 at least).\n\nFor case 2., we end up returning the sender's sender, but that already\ngives us more information than what we have today."},"files":[{"filename":"src\/hotspot\/cpu\/x86\/frame_x86.cpp"}],"sha":"d413a9cfa902d17cc188e56dd44f86bac8b5dc9d"}]