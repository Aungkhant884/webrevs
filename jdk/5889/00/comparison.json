{"files":[{"patch":"@@ -0,0 +1,132 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8269574\n+ * @summary Verifies that exceptions are reported correctly to JVMTI in the compiled code\n+ * @requires vm.jvmti\n+ * @library \/test\/lib \/\n+ *\n+ * @build sun.hotspot.WhiteBox\n+ * @build compiler.jvmti.TriggerBuiltinExceptionsTest\n+ *\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm\/native\n+ *                   -Xbootclasspath\/a:.\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -XX:-BackgroundCompilation\n+ *                   -XX:-TieredCompilation\n+ *                   -agentlib:TriggerBuiltinExceptions\n+ *                   compiler.jvmti.TriggerBuiltinExceptionsTest\n+ *\/\n+\n+package compiler.jvmti;\n+\n+import compiler.testlibrary.CompilerUtils;\n+\n+import java.lang.reflect.Method;\n+import static java.lang.Integer.valueOf;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+\n+import sun.hotspot.WhiteBox;\n+\n+\n+public class TriggerBuiltinExceptionsTest {\n+    private static final WhiteBox WB = WhiteBox.getWhiteBox();\n+    private static final int ITERATIONS = 30;           \/\/Arbitrary value, feel free to change\n+    private static final long COMP_TIMEOUT = 2000L;     \/\/Arbitrary value, feel free to change (millis)\n+    private static final int COMP_LEVEL = CompilerUtils.getMaxCompilationLevel();\n+\n+    private static int caughtByJavaTest = 0;\n+    private static native int caughtByJVMTIAgent();\n+\n+    public static void methodToCompile(int i, Object src[], Object[] dest) {\n+        try {\n+            int idxFromSrc = (int)(src[i]);                   \/\/ NPEs, CastExceptions;\n+            int rangeAdjust = 3 \/ (idxFromSrc % 3);           \/\/ Each 3rd is division by 0\n+            Object value = src[i - rangeAdjust];              \/\/ Array indexing is broken\n+            dest[i] = (Long)value;                            \/\/ ArrayStoreException or CastException\n+        } catch (Exception e) {\n+            caughtByJavaTest += 1;\n+        }\n+    }\n+\n+    \/**\n+     * Makes sure that method is compiled.\n+     *\/\n+    private static void compileMethodOrThrow(Method method) {\n+        boolean enqueued = WB.enqueueMethodForCompilation(method, COMP_LEVEL);\n+        if (!enqueued) {\n+            throw new Error(String.format(\"%s can't be enqueued for compilation on level %d\",\n+                        method, COMP_LEVEL));\n+        }\n+        Asserts.assertTrue(\n+                Utils.waitForCondition(() -> WB.isMethodCompiled(method), COMP_TIMEOUT),\n+                String.format(\"Method hasn't been compiled in %d millis\", COMP_TIMEOUT));\n+    }\n+\n+    \/**\n+     * 1. Compiles method with no profiling information;\n+     * 2. Causes deoptimization using arguments that causes hot throws;\n+     * 3. Compiles the method again;\n+     * 4. Checks that exceptions within compiled code are registered by JVMTI agent.\n+     *\/\n+    public static void main(String[] args) throws Throwable {\n+        \/\/ Preparing the method\n+        final Method method = TriggerBuiltinExceptionsTest.class.getMethod(\n+                \"methodToCompile\", int.class, Object[].class, Object[].class);\n+        WB.deoptimizeMethod(method);\n+        TriggerBuiltinExceptionsTest.compileMethodOrThrow(method);\n+\n+        \/\/ Preparing source - badly formed, supposed-to-be-int array\n+        final Object[] src = new Object[] {\n+                valueOf(0), null, null, valueOf(3), null, valueOf(5), \"string\",\n+                Long.valueOf(Long.MAX_VALUE), null, valueOf(9), \"string\"};\n+        final Object[] dst = new Integer[ITERATIONS];\n+\n+        \/\/ 1. Should cause deoptimization as array is null\n+        \/\/ 2. Make the throw hot to make the next compilation aware of it.\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            TriggerBuiltinExceptionsTest.methodToCompile(i, src, dst);\n+        }\n+        Asserts.assertTrue(\n+                Utils.waitForCondition(() -> !WB.isMethodCompiled(method), COMP_TIMEOUT),\n+                String.format(\"Method hasn't been deoptimized in %d millis\", COMP_TIMEOUT));\n+\n+        \/\/ Compile method with throw being hot\n+        TriggerBuiltinExceptionsTest.compileMethodOrThrow(method);\n+\n+        \/\/ Gathering exceptions in compiled code\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            TriggerBuiltinExceptionsTest.methodToCompile(i, src, dst);\n+        }\n+\n+        Asserts.assertEQ(\n+                TriggerBuiltinExceptionsTest.caughtByJVMTIAgent(), caughtByJavaTest,\n+                \"Number of Exceptions caught by java code and JVMTI agent does not match\");\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmti\/TriggerBuiltinExceptionsTest.java","additions":132,"deletions":0,"binary":false,"changes":132,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <string.h>\n+#include \"jvmti.h\"\n+\n+static jint exceptions_caught = 0;\n+\n+extern \"C\" {\n+\n+void JNICALL\n+callbackException(jvmtiEnv *jvmti_env, JNIEnv* jni_env,\n+                  jthread thread, jmethodID method,\n+                  jlocation location, jobject exception,\n+                  jmethodID catch_method, jlocation catch_location) {\n+    exceptions_caught += 1;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n+    jvmtiEnv *jvmti = nullptr;\n+\n+    bool successful = true;\n+    jint result = JNI_OK;\n+    do {\n+        result = jvm->GetEnv((void **) (&jvmti), JVMTI_VERSION);\n+        if (result != JNI_OK) {\n+            printf(\"Agent_OnLoad: Error in GetEnv in obtaining jvmtiEnv: %d\\n\", result);\n+            break;\n+        }\n+\n+        jvmtiEventCallbacks callbacks;\n+        memset(&callbacks, 0, sizeof(callbacks));\n+        callbacks.Exception = &callbackException;\n+\n+        result = jvmti->SetEventCallbacks(&callbacks, sizeof(jvmtiEventCallbacks));\n+        if (result != JVMTI_ERROR_NONE) {\n+            printf(\"Agent_OnLoad: Error in JVMTI SetEventCallbacks: %d\\n\", result);\n+            break;\n+        }\n+\n+        jvmtiCapabilities capabilities;\n+        memset(&capabilities, 0, sizeof(capabilities));\n+        capabilities.can_generate_exception_events = 1;\n+        result = jvmti->AddCapabilities(&capabilities);\n+        if (result != JVMTI_ERROR_NONE) {\n+            printf(\"Agent_OnLoad: Error in JVMTI AddCapabilities: %d\\n\", result);\n+            break;\n+        }\n+\n+        result = jvmti->SetEventNotificationMode(JVMTI_ENABLE, JVMTI_EVENT_EXCEPTION, (jthread)NULL);\n+        if (result != JVMTI_ERROR_NONE) {\n+            printf(\"Agent_OnLoad: Error in JVMTI SetEventNotificationMode: %d\\n\", result);\n+            break;\n+        }\n+\n+    } while (false);\n+\n+    return (result == JNI_OK) || (result == JVMTI_ERROR_NONE) ? JNI_OK : JNI_ERR;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_compiler_jvmti_TriggerBuiltinExceptionsTest_caughtByJVMTIAgent(JNIEnv *env, jclass cls) {\n+    return exceptions_caught;\n+}\n+\n+\n+} \/\/ extern \"C\"\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmti\/libTriggerBuiltinExceptions.cpp","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"}]}