{"files":[{"patch":"@@ -38,0 +38,21 @@\n+void G1CollectionSetCandidates::prune(uint keep_min_regions, size_t prune_total_bytes) {\n+  uint regions_left = _num_regions;\n+  size_t pruned_bytes = 0;\n+\n+  while (regions_left > keep_min_regions) {\n+    uint cur_idx = regions_left - 1;\n+    \/\/ Do not prune more than prune_total_bytes.\n+    if ((at(cur_idx)->reclaimable_bytes() + pruned_bytes) > prune_total_bytes) {\n+      break;\n+    }\n+\n+    pruned_bytes += at(cur_idx)->reclaimable_bytes();\n+    at(cur_idx)->rem_set()->clear(true \/* only_cardset *\/);\n+    \/\/ Clear HeapRegion reference to make sure it is not going to be used.\n+    _regions[cur_idx] = NULL;\n+    regions_left--;\n+  }\n+  _remaining_reclaimable_bytes -= pruned_bytes;\n+  _num_regions = regions_left;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetCandidates.cpp","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -77,0 +77,6 @@\n+  \/\/ Remove collection set candidates which would reclaim at most prune_total_bytes\n+  \/\/ bytes and keeping at least keep_min_regions. Removes the least efficient\n+  \/\/ collection set candidate regions first.\n+  void prune(uint keep_min_regions, size_t prune_total_bytes);\n+\n+  \/\/ Remove num_regions from the front of the collection set candidate list.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetCandidates.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -268,0 +268,2 @@\n+  G1Policy* p = G1CollectedHeap::heap()->policy();\n+  p->prune_collection_set(result);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetChooser.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1281,12 +1281,2 @@\n-\n-  \/\/ Is the amount of uncollected reclaimable space above G1HeapWastePercent?\n-  size_t reclaimable_bytes = candidates->remaining_reclaimable_bytes();\n-  double reclaimable_percent = reclaimable_bytes_percent(reclaimable_bytes);\n-  double threshold = (double) G1HeapWastePercent;\n-  if (reclaimable_percent <= threshold) {\n-    log_debug(gc, ergo)(\"%s (reclaimable percentage not over threshold). candidate old regions: %u reclaimable: \" SIZE_FORMAT \" (%1.2f) threshold: \" UINTX_FORMAT,\n-                        false_action_str, candidates->num_remaining(), reclaimable_bytes, reclaimable_percent, G1HeapWastePercent);\n-    return false;\n-  }\n-  log_debug(gc, ergo)(\"%s (candidate old regions available). candidate old regions: %u reclaimable: \" SIZE_FORMAT \" (%1.2f) threshold: \" UINTX_FORMAT,\n-                      true_action_str, candidates->num_remaining(), reclaimable_bytes, reclaimable_percent, G1HeapWastePercent);\n+  \/\/ Go through all regions - we already pruned regions not worth collecting\n+  \/\/ during candidate selection.\n@@ -1296,1 +1286,16 @@\n-uint G1Policy::calc_min_old_cset_length() const {\n+void G1Policy::prune_collection_set(G1CollectionSetCandidates* candidates) {\n+  uint num_candidates_before = candidates->num_remaining();\n+  size_t reclaimable_bytes_before = candidates->remaining_reclaimable_bytes();\n+\n+  size_t accepted_waste = G1HeapWastePercent * _g1h->capacity() \/ 100;\n+\n+  candidates->prune(calc_min_old_cset_length(candidates), accepted_waste);\n+\n+  log_debug(gc, ergo, cset)(\"Pruned %u regions out of %u, leaving \" SIZE_FORMAT \" bytes waste (accepted \" SIZE_FORMAT \")\",\n+                            num_candidates_before - candidates->num_remaining(),\n+                            candidates->num_regions(),\n+                            reclaimable_bytes_before - candidates->remaining_reclaimable_bytes(),\n+                            accepted_waste);\n+}\n+\n+uint G1Policy::calc_min_old_cset_length(G1CollectionSetCandidates* candidates) const {\n@@ -1307,1 +1312,1 @@\n-  const size_t region_num = _collection_set->candidates()->num_regions();\n+  const size_t region_num = candidates->num_regions();\n@@ -1350,1 +1355,1 @@\n-  const uint min_old_cset_length = calc_min_old_cset_length();\n+  const uint min_old_cset_length = calc_min_old_cset_length(candidates);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":20,"deletions":15,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -249,1 +249,1 @@\n-  uint calc_min_old_cset_length() const;\n+  uint calc_min_old_cset_length(G1CollectionSetCandidates* candidates) const;\n@@ -350,0 +350,4 @@\n+  \/\/ Prune collection set candidates according to G1HeapWastePercent heuristics\n+  \/\/ during selection. Guarantee some forward progress by always keeping a minimum\n+  \/\/ of old collection set candidates for a single GC.\n+  void prune_collection_set(G1CollectionSetCandidates* candidates);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"}]}