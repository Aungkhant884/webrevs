{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,15 @@\n+void G1CollectionSetCandidates::remove_from_end(uint num_remove) {\n+  assert(num_remove <= num_remaining(), \"trying to remove more regions than remaining\");\n+\n+  size_t reclaimable = 0;\n+\n+  for (uint i = 0; i < num_remove; i++) {\n+    uint cur_idx = _num_regions - i - 1;\n+    reclaimable += at(cur_idx)->reclaimable_bytes();\n+    \/\/ Make sure we crash if we access it.\n+    _regions[cur_idx] = NULL;\n+  }\n+  _num_regions -= num_remove;\n+  _remaining_reclaimable_bytes -= reclaimable;\n+}\n+\n@@ -48,0 +63,10 @@\n+void G1CollectionSetCandidates::iterate_backwards(HeapRegionClosure* cl) {\n+  for (uint i = _num_regions; i > _front_idx; i--) {\n+    HeapRegion* r = _regions[i - 1];\n+    if (cl->do_heap_region(r)) {\n+      cl->set_incomplete();\n+      break;\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetCandidates.cpp","additions":26,"deletions":1,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,0 +77,1 @@\n+  \/\/ Remove num_regions from the front of the collection set candidate list.\n@@ -78,0 +79,2 @@\n+  \/\/ Remove num_remove regions from the back of the collection set candidate list.\n+  void remove_from_end(uint num_remove);\n@@ -81,0 +84,3 @@\n+  \/\/ Iterate over all remaining collectin set candidate regions from the end\n+  \/\/ to the beginning of the set.\n+  void iterate_backwards(HeapRegionClosure* cl);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetCandidates.hpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -260,0 +260,53 @@\n+\/\/ Closure implementing early pruning (removal) of regions meeting the\n+\/\/ G1HeapWastePercent criteria. That is, either until _max_pruned regions were\n+\/\/ removed (for forward progress in evacuation) or the waste accumulated by the\n+\/\/ removed regions is above max_wasted.\n+class G1PruneRegionClosure : public HeapRegionClosure {\n+  uint _num_pruned;\n+  size_t _cur_wasted;\n+\n+  uint const _max_pruned;\n+  size_t const _max_wasted;\n+\n+public:\n+  G1PruneRegionClosure(uint max_pruned, size_t max_wasted) :\n+    _num_pruned(0), _cur_wasted(0), _max_pruned(max_pruned), _max_wasted(max_wasted) { }\n+\n+  virtual bool do_heap_region(HeapRegion* r) {\n+    if (_num_pruned > _max_pruned ||\n+        _cur_wasted + r->reclaimable_bytes() > _max_wasted) {\n+      return true;\n+    }\n+    r->rem_set()->clear(true \/* cardset_only *\/);\n+    _cur_wasted += r->reclaimable_bytes();\n+    _num_pruned++;\n+    return false;\n+  }\n+\n+  uint num_pruned() const { return _num_pruned; }\n+  size_t wasted() const { return _cur_wasted; }\n+};\n+\n+void G1CollectionSetChooser::prune(G1CollectionSetCandidates* candidates) {\n+  G1Policy* p = G1CollectedHeap::heap()->policy();\n+\n+  uint min_old_cset_length = p->calc_min_old_cset_length(candidates);\n+  uint num_candidates = candidates->num_regions();\n+\n+  if (min_old_cset_length < num_candidates) {\n+    size_t allowed_waste = p->allowed_waste_in_collection_set();\n+\n+    G1PruneRegionClosure prune_cl(num_candidates - min_old_cset_length,\n+                                  allowed_waste);\n+    candidates->iterate_backwards(&prune_cl);\n+\n+    log_debug(gc, ergo, cset)(\"Pruned %u regions out of %u, leaving \" SIZE_FORMAT \" bytes waste (allowed \" SIZE_FORMAT \")\",\n+                              prune_cl.num_pruned(),\n+                              candidates->num_regions(),\n+                              prune_cl.wasted(),\n+                              allowed_waste);\n+\n+    candidates->remove_from_end(prune_cl.num_pruned());\n+  }\n+}\n+\n@@ -268,0 +321,1 @@\n+  prune(result);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetChooser.cpp","additions":55,"deletions":1,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,5 @@\n+\n+  \/\/ Remove regions in the collection set candidates as long as the G1HeapWastePercent\n+  \/\/ criteria is met. Keep at least the minimum amount of old regions to guarantee\n+  \/\/ some progress.\n+  static void prune(G1CollectionSetCandidates* candidates);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetChooser.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1281,12 +1281,2 @@\n-\n-  \/\/ Is the amount of uncollected reclaimable space above G1HeapWastePercent?\n-  size_t reclaimable_bytes = candidates->remaining_reclaimable_bytes();\n-  double reclaimable_percent = reclaimable_bytes_percent(reclaimable_bytes);\n-  double threshold = (double) G1HeapWastePercent;\n-  if (reclaimable_percent <= threshold) {\n-    log_debug(gc, ergo)(\"%s (reclaimable percentage not over threshold). candidate old regions: %u reclaimable: \" SIZE_FORMAT \" (%1.2f) threshold: \" UINTX_FORMAT,\n-                        false_action_str, candidates->num_remaining(), reclaimable_bytes, reclaimable_percent, G1HeapWastePercent);\n-    return false;\n-  }\n-  log_debug(gc, ergo)(\"%s (candidate old regions available). candidate old regions: %u reclaimable: \" SIZE_FORMAT \" (%1.2f) threshold: \" UINTX_FORMAT,\n-                      true_action_str, candidates->num_remaining(), reclaimable_bytes, reclaimable_percent, G1HeapWastePercent);\n+  \/\/ Go through all regions - we already pruned regions not worth collecting\n+  \/\/ during candidate selection.\n@@ -1296,1 +1286,5 @@\n-uint G1Policy::calc_min_old_cset_length() const {\n+size_t G1Policy::allowed_waste_in_collection_set() const {\n+  return G1HeapWastePercent * _g1h->capacity() \/ 100;\n+}\n+\n+uint G1Policy::calc_min_old_cset_length(G1CollectionSetCandidates* candidates) const {\n@@ -1307,1 +1301,1 @@\n-  const size_t region_num = _collection_set->candidates()->num_regions();\n+  const size_t region_num = candidates->num_regions();\n@@ -1350,1 +1344,1 @@\n-  const uint min_old_cset_length = calc_min_old_cset_length();\n+  const uint min_old_cset_length = calc_min_old_cset_length(candidates);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":10,"deletions":16,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -249,1 +249,1 @@\n-  uint calc_min_old_cset_length() const;\n+  uint calc_min_old_cset_length(G1CollectionSetCandidates* candidates) const;\n@@ -350,0 +350,2 @@\n+  \/\/ Amount of allowed waste in bytes in the collection set.\n+  size_t allowed_waste_in_collection_set() const;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"}]}