{"files":[{"patch":"@@ -53,22 +53,0 @@\n-void G1CollectionSetCandidates::prune(uint keep_min_regions,\n-                                      size_t prune_total_bytes,\n-                                      HeapRegionClosure* cl) {\n-  uint regions_left;\n-  size_t pruned_bytes = 0;\n-\n-  for (regions_left = _num_regions; regions_left > keep_min_regions; regions_left--) {\n-    uint cur_idx = regions_left - 1;\n-    HeapRegion* region = at(cur_idx);\n-    \/\/ Do not prune more than prune_total_bytes.\n-    if ((region->reclaimable_bytes() + pruned_bytes) > prune_total_bytes) {\n-      break;\n-    }\n-    pruned_bytes += region->reclaimable_bytes();\n-    cl->do_heap_region(region);\n-    \/\/ Clear HeapRegion reference to make sure it is not going to be used.\n-    _regions[cur_idx] = NULL;\n-  }\n-  _remaining_reclaimable_bytes -= pruned_bytes;\n-  _num_regions = regions_left;\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetCandidates.cpp","additions":0,"deletions":22,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -77,5 +77,0 @@\n-  \/\/ Remove collection set candidates which would reclaim at most prune_total_bytes\n-  \/\/ bytes and keeping at least keep_min_regions. Removes the least efficient\n-  \/\/ collection set candidate regions first. Applies cl on the pruned regions.\n-  void prune(uint keep_min_regions, size_t prune_total_bytes, HeapRegionClosure* cl);\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetCandidates.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"}]}