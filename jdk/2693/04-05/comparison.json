{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,15 @@\n+void G1CollectionSetCandidates::remove_from_end(uint num_remove) {\n+  assert(num_remove <= num_remaining(), \"trying to remove more regions than remaining\");\n+\n+  size_t reclaimable = 0;\n+\n+  for (uint i = 0; i < num_remove; i++) {\n+    uint cur_idx = _num_regions - i - 1;\n+    reclaimable += at(cur_idx)->reclaimable_bytes();\n+    \/\/ Make sure we crash if we access it.\n+    _regions[cur_idx] = NULL;\n+  }\n+  _num_regions -= num_remove;\n+  _remaining_reclaimable_bytes -= reclaimable;\n+}\n+\n@@ -70,0 +85,10 @@\n+void G1CollectionSetCandidates::iterate_backwards(HeapRegionClosure* cl) {\n+  for (uint i = _num_regions; i > _front_idx; i--) {\n+    HeapRegion* r = _regions[i - 1];\n+    if (cl->do_heap_region(r)) {\n+      cl->set_incomplete();\n+      break;\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetCandidates.cpp","additions":26,"deletions":1,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -84,0 +84,2 @@\n+  \/\/ Remove num_remove regions from the back of the collection set candidate list.\n+  void remove_from_end(uint num_remove);\n@@ -87,0 +89,3 @@\n+  \/\/ Iterate over all remaining collectin set candidate regions from the end\n+  \/\/ to the beginning of the set.\n+  void iterate_backwards(HeapRegionClosure* cl);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetCandidates.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -260,0 +260,53 @@\n+\/\/ Closure implementing early pruning (removal) of regions meeting the\n+\/\/ G1HeapWastePercent criteria. That is, either until _max_pruned regions were\n+\/\/ removed (for forward progress in evacuation) or the waste accumulated by the\n+\/\/ removed regions is above max_wasted.\n+class G1PruneRegionClosure : public HeapRegionClosure {\n+  uint _num_pruned;\n+  size_t _cur_wasted;\n+\n+  uint const _max_pruned;\n+  size_t const _max_wasted;\n+\n+public:\n+  G1PruneRegionClosure(uint max_pruned, size_t max_wasted) :\n+    _num_pruned(0), _cur_wasted(0), _max_pruned(max_pruned), _max_wasted(max_wasted) { }\n+\n+  virtual bool do_heap_region(HeapRegion* r) {\n+    if (_num_pruned > _max_pruned ||\n+        _cur_wasted + r->reclaimable_bytes() > _max_wasted) {\n+      return true;\n+    }\n+    r->rem_set()->clear(true \/* cardset_only *\/);\n+    _cur_wasted += r->reclaimable_bytes();\n+    _num_pruned++;\n+    return false;\n+  }\n+\n+  uint num_pruned() const { return _num_pruned; }\n+  size_t wasted() const { return _cur_wasted; }\n+};\n+\n+void G1CollectionSetChooser::prune(G1CollectionSetCandidates* candidates) {\n+  G1Policy* p = G1CollectedHeap::heap()->policy();\n+\n+  uint min_old_cset_length = p->calc_min_old_cset_length(candidates);\n+  uint num_candidates = candidates->num_regions();\n+\n+  if (min_old_cset_length < num_candidates) {\n+    size_t allowed_waste = p->allowed_waste_in_collection_set();\n+\n+    G1PruneRegionClosure prune_cl(num_candidates - min_old_cset_length,\n+                                  allowed_waste);\n+    candidates->iterate_backwards(&prune_cl);\n+\n+    log_debug(gc, ergo, cset)(\"Pruned %u regions out of %u, leaving \" SIZE_FORMAT \" bytes waste (allowed \" SIZE_FORMAT \")\",\n+                              prune_cl.num_pruned(),\n+                              candidates->num_regions(),\n+                              prune_cl.wasted(),\n+                              allowed_waste);\n+\n+    candidates->remove_from_end(prune_cl.num_pruned());\n+  }\n+}\n+\n@@ -267,8 +320,0 @@\n-  class PruneRegionClosure : public HeapRegionClosure {\n-  public:\n-    virtual bool do_heap_region(HeapRegion* r) {\n-      r->rem_set()->clear(true \/* only_cardset *\/); \/\/ Simply drop the remembered set cards.\n-      return false;\n-    }\n-  } prune_cl;\n-\n@@ -276,3 +321,1 @@\n-\n-  G1Policy* p = G1CollectedHeap::heap()->policy();\n-  p->prune_collection_set(result, &prune_cl);\n+  prune(result);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetChooser.cpp","additions":55,"deletions":12,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,5 @@\n+\n+  \/\/ Remove regions in the collection set candidates as long as the G1HeapWastePercent\n+  \/\/ criteria is met. Keep at least the minimum amount of old regions to guarantee\n+  \/\/ some progress.\n+  static void prune(G1CollectionSetCandidates* candidates);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetChooser.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1286,13 +1286,2 @@\n-void G1Policy::prune_collection_set(G1CollectionSetCandidates* candidates, HeapRegionClosure* cl) {\n-  uint num_candidates_before = candidates->num_remaining();\n-  size_t reclaimable_bytes_before = candidates->remaining_reclaimable_bytes();\n-\n-  size_t accepted_waste = G1HeapWastePercent * _g1h->capacity() \/ 100;\n-\n-  candidates->prune(calc_min_old_cset_length(candidates), accepted_waste, cl);\n-\n-  log_debug(gc, ergo, cset)(\"Pruned %u regions out of %u, leaving \" SIZE_FORMAT \" bytes waste (accepted \" SIZE_FORMAT \")\",\n-                            num_candidates_before - candidates->num_remaining(),\n-                            candidates->num_regions(),\n-                            reclaimable_bytes_before - candidates->remaining_reclaimable_bytes(),\n-                            accepted_waste);\n+size_t G1Policy::allowed_waste_in_collection_set() const {\n+  return G1HeapWastePercent * _g1h->capacity() \/ 100;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":3,"deletions":14,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -350,5 +350,2 @@\n-  \/\/ Prune collection set candidates according to G1HeapWastePercent heuristics\n-  \/\/ during selection. Guarantee some forward progress by always keeping a minimum\n-  \/\/ of old collection set candidates for a single GC. Applies cl onto the pruned\n-  \/\/ regions.\n-  void prune_collection_set(G1CollectionSetCandidates* candidates, HeapRegionClosure* cl);\n+  \/\/ Amount of allowed waste in bytes in the collection set.\n+  size_t allowed_waste_in_collection_set() const;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.hpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"}]}