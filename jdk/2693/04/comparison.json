{"files":[{"patch":"@@ -38,0 +38,22 @@\n+void G1CollectionSetCandidates::prune(uint keep_min_regions,\n+                                      size_t prune_total_bytes,\n+                                      HeapRegionClosure* cl) {\n+  uint regions_left;\n+  size_t pruned_bytes = 0;\n+\n+  for (regions_left = _num_regions; regions_left > keep_min_regions; regions_left--) {\n+    uint cur_idx = regions_left - 1;\n+    HeapRegion* region = at(cur_idx);\n+    \/\/ Do not prune more than prune_total_bytes.\n+    if ((region->reclaimable_bytes() + pruned_bytes) > prune_total_bytes) {\n+      break;\n+    }\n+    pruned_bytes += region->reclaimable_bytes();\n+    cl->do_heap_region(region);\n+    \/\/ Clear HeapRegion reference to make sure it is not going to be used.\n+    _regions[cur_idx] = NULL;\n+  }\n+  _remaining_reclaimable_bytes -= pruned_bytes;\n+  _num_regions = regions_left;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetCandidates.cpp","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -77,0 +77,6 @@\n+  \/\/ Remove collection set candidates which would reclaim at most prune_total_bytes\n+  \/\/ bytes and keeping at least keep_min_regions. Removes the least efficient\n+  \/\/ collection set candidate regions first. Applies cl on the pruned regions.\n+  void prune(uint keep_min_regions, size_t prune_total_bytes, HeapRegionClosure* cl);\n+\n+  \/\/ Remove num_regions from the front of the collection set candidate list.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetCandidates.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -267,0 +267,8 @@\n+  class PruneRegionClosure : public HeapRegionClosure {\n+  public:\n+    virtual bool do_heap_region(HeapRegion* r) {\n+      r->rem_set()->clear(true \/* only_cardset *\/); \/\/ Simply drop the remembered set cards.\n+      return false;\n+    }\n+  } prune_cl;\n+\n@@ -268,0 +276,3 @@\n+\n+  G1Policy* p = G1CollectedHeap::heap()->policy();\n+  p->prune_collection_set(result, &prune_cl);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetChooser.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1281,12 +1281,2 @@\n-\n-  \/\/ Is the amount of uncollected reclaimable space above G1HeapWastePercent?\n-  size_t reclaimable_bytes = candidates->remaining_reclaimable_bytes();\n-  double reclaimable_percent = reclaimable_bytes_percent(reclaimable_bytes);\n-  double threshold = (double) G1HeapWastePercent;\n-  if (reclaimable_percent <= threshold) {\n-    log_debug(gc, ergo)(\"%s (reclaimable percentage not over threshold). candidate old regions: %u reclaimable: \" SIZE_FORMAT \" (%1.2f) threshold: \" UINTX_FORMAT,\n-                        false_action_str, candidates->num_remaining(), reclaimable_bytes, reclaimable_percent, G1HeapWastePercent);\n-    return false;\n-  }\n-  log_debug(gc, ergo)(\"%s (candidate old regions available). candidate old regions: %u reclaimable: \" SIZE_FORMAT \" (%1.2f) threshold: \" UINTX_FORMAT,\n-                      true_action_str, candidates->num_remaining(), reclaimable_bytes, reclaimable_percent, G1HeapWastePercent);\n+  \/\/ Go through all regions - we already pruned regions not worth collecting\n+  \/\/ during candidate selection.\n@@ -1296,1 +1286,16 @@\n-uint G1Policy::calc_min_old_cset_length() const {\n+void G1Policy::prune_collection_set(G1CollectionSetCandidates* candidates, HeapRegionClosure* cl) {\n+  uint num_candidates_before = candidates->num_remaining();\n+  size_t reclaimable_bytes_before = candidates->remaining_reclaimable_bytes();\n+\n+  size_t accepted_waste = G1HeapWastePercent * _g1h->capacity() \/ 100;\n+\n+  candidates->prune(calc_min_old_cset_length(candidates), accepted_waste, cl);\n+\n+  log_debug(gc, ergo, cset)(\"Pruned %u regions out of %u, leaving \" SIZE_FORMAT \" bytes waste (accepted \" SIZE_FORMAT \")\",\n+                            num_candidates_before - candidates->num_remaining(),\n+                            candidates->num_regions(),\n+                            reclaimable_bytes_before - candidates->remaining_reclaimable_bytes(),\n+                            accepted_waste);\n+}\n+\n+uint G1Policy::calc_min_old_cset_length(G1CollectionSetCandidates* candidates) const {\n@@ -1307,1 +1312,1 @@\n-  const size_t region_num = _collection_set->candidates()->num_regions();\n+  const size_t region_num = candidates->num_regions();\n@@ -1350,1 +1355,1 @@\n-  const uint min_old_cset_length = calc_min_old_cset_length();\n+  const uint min_old_cset_length = calc_min_old_cset_length(candidates);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":20,"deletions":15,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -249,1 +249,1 @@\n-  uint calc_min_old_cset_length() const;\n+  uint calc_min_old_cset_length(G1CollectionSetCandidates* candidates) const;\n@@ -350,0 +350,5 @@\n+  \/\/ Prune collection set candidates according to G1HeapWastePercent heuristics\n+  \/\/ during selection. Guarantee some forward progress by always keeping a minimum\n+  \/\/ of old collection set candidates for a single GC. Applies cl onto the pruned\n+  \/\/ regions.\n+  void prune_collection_set(G1CollectionSetCandidates* candidates, HeapRegionClosure* cl);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"}]}