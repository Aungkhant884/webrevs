{"files":[{"patch":"@@ -117,0 +117,4 @@\n+        \/\/ Add record component getters\n+        for (final Method rcg: introspector.getRecordComponentGetters()) {\n+            setPropertyGetter(rcg, 0);\n+        }\n@@ -140,3 +144,1 @@\n-            if(!propertyGetters.containsKey(name)) {\n-                setPropertyGetter(name, introspector.unreflectGetter(field), ValidationType.EXACT_CLASS);\n-            }\n+            setPropertyGetter(name, introspector.unreflectGetter(field), ValidationType.EXACT_CLASS);\n@@ -151,4 +153,1 @@\n-            final String name = innerClassSpec.getKey();\n-            if(!propertyGetters.containsKey(name)) {\n-                setPropertyGetter(name, innerClassSpec.getValue(), ValidationType.EXACT_CLASS);\n-            }\n+            setPropertyGetter(innerClassSpec.getKey(), innerClassSpec.getValue(), ValidationType.EXACT_CLASS);\n@@ -207,1 +206,3 @@\n-        propertyGetters.put(name, new AnnotatedDynamicMethod(handle, validationType));\n+        if (!propertyGetters.containsKey(name)) {\n+            propertyGetters.put(name, new AnnotatedDynamicMethod(handle, validationType));\n+        }\n","filename":"src\/jdk.dynalink\/share\/classes\/jdk\/dynalink\/beans\/AbstractJavaLinker.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -104,0 +104,4 @@\n+    Method getAccessibleMethod(final Method m) {\n+        return methods.get(new MethodSignature(m));\n+    }\n+\n","filename":"src\/jdk.dynalink\/share\/classes\/jdk\/dynalink\/beans\/AccessibleMembersLookup.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -64,1 +64,7 @@\n-import java.util.Collections;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.RecordComponent;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n@@ -66,0 +72,1 @@\n+import java.util.Objects;\n@@ -68,0 +75,2 @@\n+    private final Class<?> clazz;\n+\n@@ -70,0 +79,1 @@\n+        this.clazz = clazz;\n@@ -74,1 +84,21 @@\n-        return Collections.emptyMap(); \/\/ NOTE: non-static inner classes are also on StaticClassIntrospector.\n+        return Map.of(); \/\/ NOTE: non-static inner classes are also on StaticClassIntrospector.\n+    }\n+\n+    @Override Collection<Method> getRecordComponentGetters() {\n+        if (clazz.isRecord()) {\n+            try {\n+                \/\/ Need to use doPrivileged as getRecordComponents is rather strict.\n+                final RecordComponent[] rcs = AccessController.doPrivileged(\n+                    (PrivilegedAction<RecordComponent[]>) clazz::getRecordComponents);\n+                return Arrays.stream(rcs)\n+                    .map(RecordComponent::getAccessor)\n+                    .map(membersLookup::getAccessibleMethod)\n+                    .filter(Objects::nonNull) \/\/ no accessible counterpart\n+                    .toList();\n+            } catch (SecurityException e) {\n+                \/\/ We couldn't execute getRecordComponents.\n+                return List.of();\n+            }\n+        } else {\n+            return List.of();\n+        }\n","filename":"src\/jdk.dynalink\/share\/classes\/jdk\/dynalink\/beans\/BeanIntrospector.java","additions":32,"deletions":2,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -81,0 +81,3 @@\n+ * <li>if the object is a {@link java.lang.Record record}, expose all public accessors of\n+ * record components as property getters for {@link StandardOperation#GET} operations\n+ * in the {@link StandardNamespace#PROPERTY} namespace;<\/li>\n@@ -84,1 +87,2 @@\n- * {@link StandardNamespace#PROPERTY} namespace;<\/li>\n+ * {@link StandardNamespace#PROPERTY} namespace, except for getters for properties\n+ * with names already handled by record component getters;<\/li>\n","filename":"src\/jdk.dynalink\/share\/classes\/jdk\/dynalink\/beans\/BeansLinker.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -95,0 +95,1 @@\n+            \/\/ Classes in unexported packages of modules are always restricted\n","filename":"src\/jdk.dynalink\/share\/classes\/jdk\/dynalink\/beans\/CheckRestrictedPackage.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -98,0 +98,6 @@\n+    \/**\n+     * Returns getter methods for record components.\n+     * @return getter methods for record components.\n+     *\/\n+    abstract Collection<Method> getRecordComponentGetters();\n+\n@@ -144,1 +150,0 @@\n-\n","filename":"src\/jdk.dynalink\/share\/classes\/jdk\/dynalink\/beans\/FacetIntrospector.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -66,0 +66,2 @@\n+import java.lang.reflect.Method;\n+import java.util.Collection;\n@@ -67,0 +69,1 @@\n+import java.util.List;\n@@ -84,0 +87,4 @@\n+    @Override Collection<Method> getRecordComponentGetters() {\n+        return List.of();\n+    }\n+\n","filename":"src\/jdk.dynalink\/share\/classes\/jdk\/dynalink\/beans\/StaticClassIntrospector.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8262503\n+ * @summary Dynalink supports property getters for record components\n+ *\/\n+\n+import static jdk.dynalink.StandardNamespace.PROPERTY;\n+import static jdk.dynalink.StandardOperation.GET;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.util.List;\n+import java.util.Set;\n+import jdk.dynalink.CallSiteDescriptor;\n+import jdk.dynalink.DynamicLinker;\n+import jdk.dynalink.DynamicLinkerFactory;\n+import jdk.dynalink.NoSuchDynamicMethodException;\n+import jdk.dynalink.beans.BeansLinker;\n+import jdk.dynalink.support.SimpleRelinkableCallSite;\n+\n+public class BeanLinkerRecordsTest {\n+    public static record A(int num) {}\n+\n+    public interface I {\n+        int num();\n+    }\n+\n+    static record B(int num, int inaccessible) implements I {}\n+\n+    public static record C(int num) {\n+        public int num() { return 42; }\n+        public int getNum() { return 43; }\n+    }\n+\n+    public static void main(String[] args) throws Throwable {\n+        DynamicLinker linker = new DynamicLinkerFactory().createLinker();\n+\n+        MethodHandle get_num = linker.link(makePropertyGetter(\"num\")).dynamicInvoker();\n+\n+        \/\/ Can access public record's component through its accessor\n+        assert(get_num.invoke(new A(100)).equals(100));\n+\n+        \/\/ Can access non-public record's component through accessor declared in public interface\n+        assert(get_num.invoke(new B(100, 200)).equals(100));\n+\n+        \/\/ Correctly selects overridden accessor; also ignores getXxx style getters\n+        assert(get_num.invoke(new C(100)).equals(42));\n+\n+        \/\/ Can not access non-public record's component without accessor declared in public interface\n+        MethodHandle get_inaccessible = linker.link(makePropertyGetter(\"inaccessible\")).dynamicInvoker();\n+        try {\n+            get_inaccessible.invoke(new B(100, 200));\n+            throw new AssertionError(); \/\/ should've failed\n+        } catch (NoSuchDynamicMethodException e) {\n+            \/\/ This is expected\n+        }\n+\n+        \/\/ Record components show up in the list of readable instance property names.\n+        List.of(A.class, B.class, C.class).forEach(clazz -> {\n+            var propNames = BeansLinker.getReadableInstancePropertyNames(clazz);\n+            assert propNames.equals(Set.of(\"num\", \"class\")): String.valueOf(propNames);\n+        });\n+    }\n+\n+    private static SimpleRelinkableCallSite makePropertyGetter(String name) {\n+        return new SimpleRelinkableCallSite(new CallSiteDescriptor(\n+            MethodHandles.publicLookup(),\n+            GET.withNamespace(PROPERTY).named(name),\n+            MethodType.methodType(Object.class, Object.class)));\n+    }\n+}\n","filename":"test\/jdk\/jdk\/dynalink\/BeanLinkerRecordsTest.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"}]}