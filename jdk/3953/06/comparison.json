{"files":[{"patch":"@@ -262,0 +262,1 @@\n+  log_info(cds)(\"               symbols = %5d\", _symbols->length());\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"cds\/lambdaFormInvokers.hpp\"\n@@ -172,1 +173,0 @@\n-  Thread* THREAD = Thread::current();\n@@ -253,1 +253,0 @@\n-  Thread* THREAD = Thread::current();\n@@ -334,0 +333,14 @@\n+void DynamicArchive::prepare_for_dynamic_dumping_at_exit() {\n+  EXCEPTION_MARK;\n+  ResourceMark rm(THREAD);\n+  MetaspaceShared::link_and_cleanup_shared_classes(THREAD);\n+  if (HAS_PENDING_EXCEPTION) {\n+    log_error(cds)(\"ArchiveClassesAtExit has failed\");\n+    log_error(cds)(\"%s: %s\", PENDING_EXCEPTION->klass()->external_name(),\n+                   java_lang_String::as_utf8_string(java_lang_Throwable::message(PENDING_EXCEPTION)));\n+    \/\/ We cannot continue to dump the archive anymore.\n+    DynamicDumpSharedSpaces = false;\n+    CLEAR_PENDING_EXCEPTION;\n+  }\n+}\n+\n@@ -347,7 +360,6 @@\n-  }\n-  ArchiveClassesAtExit = archive_name;\n-  if (Arguments::init_shared_archive_paths()) {\n-    dump();\n-  } else {\n-    ArchiveClassesAtExit = nullptr;\n-    THROW_MSG(vmSymbols::java_lang_RuntimeException(),\n+    ArchiveClassesAtExit = archive_name;\n+    if (Arguments::init_shared_archive_paths()) {\n+      dump();\n+    } else {\n+      ArchiveClassesAtExit = nullptr;\n+      THROW_MSG(vmSymbols::java_lang_RuntimeException(),\n@@ -355,5 +367,5 @@\n-  }\n-  \/\/ prevent do dynamic dump at exit.\n-  ArchiveClassesAtExit = nullptr;\n-  if (!Arguments::init_shared_archive_paths()) {\n-    THROW_MSG(vmSymbols::java_lang_RuntimeException(),\n+    }\n+    \/\/ prevent do dynamic dump at exit.\n+    ArchiveClassesAtExit = nullptr;\n+    if (!Arguments::init_shared_archive_paths()) {\n+      THROW_MSG(vmSymbols::java_lang_RuntimeException(),\n@@ -361,0 +373,1 @@\n+    }\n","filename":"src\/hotspot\/share\/cds\/dynamicArchive.cpp","additions":27,"deletions":14,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+  static void prepare_for_dynamic_dumping_at_exit();\n","filename":"src\/hotspot\/share\/cds\/dynamicArchive.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"cds\/archiveBuilder.hpp\"\n@@ -48,0 +49,1 @@\n+#include \"runtime\/mutexLocker.hpp\"\n@@ -49,1 +51,24 @@\n-GrowableArray<char*>* LambdaFormInvokers::_lambdaform_lines = NULL;\n+GrowableArrayCHeap<char*, mtClassShared>* LambdaFormInvokers::_lambdaform_lines = nullptr;\n+Array<Array<char>*>*  LambdaFormInvokers::_static_archive_invokers = nullptr;\n+\n+#define NUM_FILTER 4\n+static const char* filter[NUM_FILTER] = {\"java.lang.invoke.Invokers$Holder\",\n+                                         \"java.lang.invoke.DirectMethodHandle$Holder\",\n+                                         \"java.lang.invoke.DelegatingMethodHandle$Holder\",\n+                                         \"java.lang.invoke.LambdaForm$Holder\"};\n+\n+static bool should_be_archived(char* line) {\n+  for (int k = 0; k < NUM_FILTER; k++) {\n+    if (strstr(line, filter[k]) != nullptr) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+void LambdaFormInvokers::append_filtered(char* line) {\n+  if (should_be_archived(line)) {\n+      append(line);\n+  }\n+}\n+#undef NUM_FILTER\n@@ -52,0 +77,1 @@\n+  MutexLocker ml(Thread::current(), LambdaFormInvokers_lock);\n@@ -53,1 +79,1 @@\n-    _lambdaform_lines = new GrowableArray<char*>(100);\n+    _lambdaform_lines = new GrowableArrayCHeap<char*, mtClassShared>(150);\n@@ -58,0 +84,11 @@\n+\/\/ convenient output\n+class PrintLambdaFormMessage {\n+ public:\n+  PrintLambdaFormMessage() {\n+    log_info(cds)(\"Regenerate MethodHandle Holder classes...\");\n+  }\n+  ~PrintLambdaFormMessage() {\n+    log_info(cds)(\"Regenerate MethodHandle Holder classes...done\");\n+  }\n+};\n+\n@@ -59,1 +96,6 @@\n-  assert(_lambdaform_lines != NULL, \"Bad List\");\n+  PrintLambdaFormMessage plm;\n+  if (_lambdaform_lines == nullptr || _lambdaform_lines->length() == 0) {\n+    log_info(cds)(\"Nothing to regenerate for holder classes\");\n+    return;\n+  }\n+\n@@ -66,0 +108,1 @@\n+  HandleMark hm(THREAD);\n@@ -67,6 +110,9 @@\n-  objArrayHandle list_lines = oopFactory::new_objArray_handle(vmClasses::String_klass(), len, CHECK);\n-  for (int i = 0; i < len; i++) {\n-    Handle h_line = java_lang_String::create_from_str(_lambdaform_lines->at(i), CHECK);\n-    list_lines->obj_at_put(i, h_line());\n-  }\n-\n+  objArrayHandle list_lines;\n+  {\n+    MutexLocker ml(Thread::current(), LambdaFormInvokers_lock);\n+    list_lines = oopFactory::new_objArray_handle(vmClasses::String_klass(), len, CHECK);\n+    for (int i = 0; i < len; i++) {\n+      Handle h_line = java_lang_String::create_from_str(_lambdaform_lines->at(i), CHECK);\n+      list_lines->obj_at_put(i, h_line());\n+    }\n+  } \/\/ Before calling into java, release vm lock.\n@@ -84,3 +130,10 @@\n-    log_info(cds)(\"%s: %s\", THREAD->pending_exception()->klass()->external_name(),\n-                            java_lang_String::as_utf8_string(java_lang_Throwable::message(THREAD->pending_exception())));\n-    CLEAR_PENDING_EXCEPTION;\n+    if (!PENDING_EXCEPTION->is_a(vmClasses::OutOfMemoryError_klass())) {\n+      log_error(cds)(\"%s: %s\", PENDING_EXCEPTION->klass()->external_name(),\n+                     java_lang_String::as_utf8_string(java_lang_Throwable::message(PENDING_EXCEPTION)));\n+      if (DumpSharedSpaces) {\n+        log_error(cds)(\"Failed to generate LambdaForm holder classes. Is your classlist out of date?\");\n+      } else {\n+        log_error(cds)(\"Failed to generate LambdaForm holder classes. Was the base archive generated with an outdated classlist?\");\n+      }\n+      CLEAR_PENDING_EXCEPTION;\n+    }\n@@ -102,1 +155,1 @@\n-    char *buf = resource_allocate_bytes(THREAD, len);\n+    char *buf = NEW_RESOURCE_ARRAY(char, len);\n@@ -105,11 +158,1 @@\n-\n-    reload_class(class_name, st, THREAD);\n-    \/\/ free buf\n-    resource_free_bytes(buf, len);\n-\n-    if (HAS_PENDING_EXCEPTION) {\n-      log_info(cds)(\"Exception happened: %s\", PENDING_EXCEPTION->klass()->name()->as_C_string());\n-      log_info(cds)(\"Could not create InstanceKlass for class %s\", class_name);\n-      CLEAR_PENDING_EXCEPTION;\n-      return;\n-    }\n+    reload_class(class_name, st, CHECK);\n@@ -150,1 +193,49 @@\n-  log_info(cds, lambda)(\"Replaced class %s, old: %p  new: %p\", name, klass, result);\n+  SystemDictionaryShared::init_dumptime_info(result);\n+  log_info(cds, lambda)(\"Replaced class %s, old: \" INTPTR_FORMAT \" new: \" INTPTR_FORMAT,\n+                 name, p2i(klass), p2i(result));\n+}\n+\n+void LambdaFormInvokers::dump_static_archive_invokers() {\n+  if (_lambdaform_lines != nullptr && _lambdaform_lines->length() > 0) {\n+    int count = 0;\n+    int len   = _lambdaform_lines->length();\n+    for (int i = 0; i < len; i++) {\n+      char* str = _lambdaform_lines->at(i);\n+      if (should_be_archived(str)) {\n+        count++;\n+      }\n+    }\n+    if (count > 0) {\n+      _static_archive_invokers = ArchiveBuilder::new_ro_array<Array<char>*>(count);\n+      int index = 0;\n+      for (int i = 0; i < len; i++) {\n+        char* str = _lambdaform_lines->at(i);\n+        if (should_be_archived(str)) {\n+          size_t str_len = strlen(str) + 1;  \/\/ including terminating zero\n+          Array<char>* line = ArchiveBuilder::new_ro_array<char>((int)str_len);\n+          strncpy(line->adr_at(0), str, str_len);\n+\n+          _static_archive_invokers->at_put(index, line);\n+          ArchivePtrMarker::mark_pointer(_static_archive_invokers->adr_at(index));\n+          index++;\n+        }\n+      }\n+      assert(index == count, \"Should match\");\n+    }\n+    log_debug(cds)(\"Total LF lines stored into static archive: %d\", count);\n+  }\n+}\n+\n+void LambdaFormInvokers::read_static_archive_invokers() {\n+  if (_static_archive_invokers != nullptr) {\n+    for (int i = 0; i < _static_archive_invokers->length(); i++) {\n+      Array<char>* line = _static_archive_invokers->at(i);\n+      char* str = line->adr_at(0);\n+      append(str);\n+    }\n+    log_debug(cds)(\"Total LF lines read from static archive: %d\", _static_archive_invokers->length());\n+  }\n+}\n+\n+void LambdaFormInvokers::serialize(SerializeClosure* soc) {\n+  soc->do_ptr((void**)&_static_archive_invokers);\n","filename":"src\/hotspot\/share\/cds\/lambdaFormInvokers.cpp","additions":116,"deletions":25,"binary":false,"changes":141,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"utilities\/growableArray.hpp\"\n@@ -30,2 +31,0 @@\n-template <class T>\n-class GrowableArray;\n@@ -33,0 +32,2 @@\n+template <class T>\n+class Array;\n@@ -36,1 +37,3 @@\n-  static GrowableArray<char*>* _lambdaform_lines;\n+  static GrowableArrayCHeap<char*, mtClassShared>* _lambdaform_lines;\n+  \/\/ For storing LF form lines (LF_RESOLVE only) in read only table.\n+  static Array<Array<char>*>* _static_archive_invokers;\n@@ -39,1 +42,0 @@\n-\n@@ -41,0 +43,3 @@\n+  static void append_filtered(char* line);\n+  static void dump_static_archive_invokers();\n+  static void read_static_archive_invokers();\n@@ -42,3 +47,1 @@\n-  static GrowableArray<char*>* lambdaform_lines() {\n-    return _lambdaform_lines;\n-  }\n+  static void serialize(SerializeClosure* soc);\n","filename":"src\/hotspot\/share\/cds\/lambdaFormInvokers.hpp","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -364,0 +364,1 @@\n+  LambdaFormInvokers::serialize(soc);\n@@ -463,0 +464,2 @@\n+  \/\/ Write lambform lines into archive\n+  LambdaFormInvokers::dump_static_archive_invokers();\n@@ -601,0 +604,2 @@\n+\n+  LambdaFormInvokers::regenerate_holder_classes(CHECK);\n@@ -721,6 +726,0 @@\n-  if (LambdaFormInvokers::lambdaform_lines() != NULL) {\n-    log_info(cds)(\"Regenerate MethodHandle Holder classes...\");\n-    LambdaFormInvokers::regenerate_holder_classes(CHECK);\n-    log_info(cds)(\"Regenerate MethodHandle Holder classes done.\");\n-  }\n-\n@@ -907,0 +906,1 @@\n+    _requested_base_address = static_mapinfo->requested_base_address();\n@@ -912,1 +912,0 @@\n-    _requested_base_address = static_mapinfo->requested_base_address();\n@@ -1426,0 +1425,6 @@\n+  \/\/ Set up LambdaFormInvokers::_lambdaform_lines for dynamic dump\n+  if (DynamicDumpSharedSpaces) {\n+    \/\/ Read stored LF format lines stored in static archive\n+    LambdaFormInvokers::read_static_archive_invokers();\n+  }\n+\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":12,"deletions":7,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2203,0 +2203,13 @@\n+  if (DynamicArchive::is_mapped()) {\n+    \/\/ Those regenerated holder classes are in dynamic archive\n+    if (name == vmSymbols::java_lang_invoke_Invokers_Holder() ||\n+        name == vmSymbols::java_lang_invoke_DirectMethodHandle_Holder() ||\n+        name == vmSymbols::java_lang_invoke_LambdaForm_Holder() ||\n+        name == vmSymbols::java_lang_invoke_DelegatingMethodHandle_Holder()) {\n+      record = dynamic_dict->lookup(name, hash, 0);\n+      if (record != nullptr) {\n+        return record;\n+      }\n+    }\n+  }\n+\n@@ -2259,1 +2272,1 @@\n-    _st->print_cr(\"%4d: %s %s\", (_index++), record->_klass->external_name(),\n+    _st->print_cr(\"%4d: %s %s\", _index++, record->_klass->external_name(),\n@@ -2276,1 +2289,1 @@\n-        _st->print_cr(\"%4d: %s %s\", (++_index), k->external_name(),\n+        _st->print_cr(\"%4d: %s %s\", _index++, k->external_name(),\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -300,6 +300,0 @@\n-  \/* used by CDS *\/                                                                               \\\n-  template(jdk_internal_misc_CDS,                     \"jdk\/internal\/misc\/CDS\")                    \\\n-  template(generateLambdaFormHolderClasses,           \"generateLambdaFormHolderClasses\")          \\\n-  template(generateLambdaFormHolderClasses_signature, \"([Ljava\/lang\/String;)[Ljava\/lang\/Object;\") \\\n-  template(dumpSharedArchive,                         \"dumpSharedArchive\")                        \\\n-  template(dumpSharedArchive_signature,               \"(ZLjava\/lang\/String;)V\")                   \\\n@@ -697,7 +691,16 @@\n-  \/* cds *\/                                                                                                       \\\n-  template(jdk_internal_loader_ClassLoaders,       \"jdk\/internal\/loader\/ClassLoaders\")                            \\\n-  template(java_util_concurrent_ConcurrentHashMap, \"java\/util\/concurrent\/ConcurrentHashMap\")                      \\\n-  template(java_util_ArrayList,                    \"java\/util\/ArrayList\")                                         \\\n-  template(toFileURL_name,                         \"toFileURL\")                                                   \\\n-  template(toFileURL_signature,                    \"(Ljava\/lang\/String;)Ljava\/net\/URL;\")                          \\\n-  template(url_void_signature,                     \"(Ljava\/net\/URL;)V\")                                           \\\n+  \/* CDS *\/                                                                                                       \\\n+  template(dumpSharedArchive,                               \"dumpSharedArchive\")                                  \\\n+  template(dumpSharedArchive_signature,                     \"(ZLjava\/lang\/String;)V\")                             \\\n+  template(generateLambdaFormHolderClasses,                 \"generateLambdaFormHolderClasses\")                    \\\n+  template(generateLambdaFormHolderClasses_signature,       \"([Ljava\/lang\/String;)[Ljava\/lang\/Object;\")           \\\n+  template(java_lang_invoke_Invokers_Holder,                \"java\/lang\/invoke\/Invokers$Holder\")                   \\\n+  template(java_lang_invoke_DirectMethodHandle_Holder,      \"java\/lang\/invoke\/DirectMethodHandle$Holder\")         \\\n+  template(java_lang_invoke_LambdaForm_Holder,              \"java\/lang\/invoke\/LambdaForm$Holder\")                 \\\n+  template(java_lang_invoke_DelegatingMethodHandle_Holder,  \"java\/lang\/invoke\/DelegatingMethodHandle$Holder\")     \\\n+  template(jdk_internal_loader_ClassLoaders,                \"jdk\/internal\/loader\/ClassLoaders\")                   \\\n+  template(jdk_internal_misc_CDS,                           \"jdk\/internal\/misc\/CDS\")                              \\\n+  template(java_util_concurrent_ConcurrentHashMap,          \"java\/util\/concurrent\/ConcurrentHashMap\")             \\\n+  template(java_util_ArrayList,                             \"java\/util\/ArrayList\")                                \\\n+  template(toFileURL_name,                                  \"toFileURL\")                                          \\\n+  template(toFileURL_signature,                             \"(Ljava\/lang\/String;)Ljava\/net\/URL;\")                 \\\n+  template(url_void_signature,                              \"(Ljava\/net\/URL;)V\")                                  \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":16,"deletions":13,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"cds\/lambdaFormInvokers.hpp\"\n@@ -423,0 +424,1 @@\n+#if INCLUDE_CDS\n@@ -425,1 +427,1 @@\n-    MetaspaceShared::link_and_cleanup_shared_classes(THREAD);\n+    DynamicArchive::prepare_for_dynamic_dumping_at_exit();\n@@ -427,0 +429,1 @@\n+#endif\n@@ -3646,1 +3649,1 @@\n-  return ClassListWriter::is_enabled();\n+  return ClassListWriter::is_enabled() || DynamicDumpSharedSpaces;\n@@ -3654,1 +3657,1 @@\n-  assert(ClassListWriter::is_enabled(), \"Should be set and open\");\n+  assert(ClassListWriter::is_enabled() || DynamicDumpSharedSpaces,  \"Should be set and open or do dynamic dump\");\n@@ -3659,2 +3662,9 @@\n-    ClassListWriter w;\n-    w.stream()->print_cr(\"%s %s\", LAMBDA_FORM_TAG, c_line);\n+    if (DynamicDumpSharedSpaces) {\n+      \/\/ Note: LambdaFormInvokers::append_filtered and LambdaFormInvokers::append take same format which is not\n+      \/\/ same as below the print format. The line does not include LAMBDA_FORM_TAG.\n+      LambdaFormInvokers::append_filtered(os::strdup((const char*)c_line, mtInternal));\n+    }\n+    if (ClassListWriter::is_enabled()) {\n+      ClassListWriter w;\n+      w.stream()->print_cr(\"%s %s\", LAMBDA_FORM_TAG, c_line);\n+    }\n@@ -3679,1 +3689,1 @@\n-  DynamicArchive::dump(archive_name, THREAD);\n+  DynamicArchive::dump(archive_name, CHECK);\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":16,"deletions":6,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -506,0 +506,1 @@\n+    ExceptionMark em(thread);\n@@ -507,0 +508,7 @@\n+    if (thread->has_pending_exception()) {\n+      ResourceMark rm(thread);\n+      oop pending_exception = thread->pending_exception();\n+      log_error(cds)(\"ArchiveClassesAtExit has failed %s: %s\", pending_exception->klass()->external_name(),\n+                     java_lang_String::as_utf8_string(java_lang_Throwable::message(pending_exception)));\n+      thread->clear_pending_exception();\n+    }\n","filename":"src\/hotspot\/share\/runtime\/java.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -157,0 +157,1 @@\n+Mutex*   LambdaFormInvokers_lock      = NULL;\n@@ -352,0 +353,1 @@\n+  def(LambdaFormInvokers_lock      , PaddedMutex  , nonleaf+2,   false, _safepoint_check_always);\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -135,0 +135,1 @@\n+extern Mutex*   LambdaFormInvokers_lock;         \/\/ Protecting LambdaFormInvokers::_lambdaform_lines\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"cds\/dynamicArchive.hpp\"\n@@ -3302,0 +3303,1 @@\n+#if INCLUDE_CDS\n@@ -3306,1 +3308,1 @@\n-    MetaspaceShared::link_and_cleanup_shared_classes(this);\n+    DynamicArchive::prepare_for_dynamic_dumping_at_exit();\n@@ -3308,0 +3310,1 @@\n+#endif\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8266764\n+ * @summary test dynamic dump with OOM\n+ * @requires vm.cds\n+ * @requires vm.gc.Serial & vm.gc == null\n+ * @comment Test dynamic dump at OOM, currently only works with SerialGC\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/test-classes\n+ * @compile .\/test-classes\/MiniStoreOom.java\n+ * @build LambHello sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar ministore.jar MiniStoreOom\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:. TestDynamicDumpAtOom\n+ *\/\n+\n+import jdk.test.lib.helpers.ClassFileInstaller;\n+import jdk.test.lib.cds.CDSTestUtils.Result;\n+\n+public class TestDynamicDumpAtOom extends DynamicArchiveTestBase {\n+    private static final String mainClass = \"MiniStoreOom\";\n+    private static final String jarFile   = \"ministore.jar\";\n+    private static void doTest(String topArchiveName) throws Exception {\n+        dump(topArchiveName,\n+             \"-Xmx64M\",\n+             \"-XX:+UseSerialGC\",\n+             \"-Xlog:cds\",\n+             \"-Xlog:cds+dynamic=debug\",\n+             \"-cp\",\n+             jarFile,\n+             mainClass,\n+             \"1024\").assertAbnormalExit(output -> {\n+                 output.shouldContain(\"ArchiveClassesAtExit has failed\")\n+                       .shouldContain(\"java.lang.OutOfMemoryError: Java heap space\");\n+             });\n+    }\n+\n+    static void testDefaultBase() throws Exception {\n+        String topArchiveName = getNewArchiveName(\"top\");\n+        doTest(topArchiveName);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        runTest(TestDynamicDumpAtOom::testDefaultBase);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/TestDynamicDumpAtOom.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8255493\n+ * @summary LambHello World test for regenerate lambda holder classes in dynamic archive\n+ * @requires vm.cds\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/test-classes\n+ * @build LambHello sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar lambhello.jar LambHello\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:. TestDynamicRegenerateHolderClasses\n+ *\/\n+\n+import jdk.test.lib.helpers.ClassFileInstaller;\n+\n+public class TestDynamicRegenerateHolderClasses extends DynamicArchiveTestBase {\n+    static String CHECK_MESSAGES[] = {\"java.lang.invoke.Invokers$Holder source: shared objects file (top)\",\n+                                      \"java.lang.invoke.DirectMethodHandle$Holder source: shared objects file (top)\",\n+                                      \"java.lang.invoke.DelegatingMethodHandle$Holder source: shared objects file (top)\",\n+                                      \"java.lang.invoke.LambdaForm$Holder source: shared objects file (top)\"};\n+    public static void main(String[] args) throws Exception {\n+        runTest(TestDynamicRegenerateHolderClasses::testDefaultBase);\n+    }\n+\n+    static void testDefaultBase() throws Exception {\n+        String topArchiveName = getNewArchiveName(\"top\");\n+        doTest(topArchiveName);\n+    }\n+\n+    private static void doTest(String topArchiveName) throws Exception {\n+        String appJar = ClassFileInstaller.getJarPath(\"lambhello.jar\");\n+        String mainClass = \"LambHello\";\n+        dump(topArchiveName,\n+              \"-Xlog:cds\",\n+              \"-Xlog:cds+dynamic=debug\",\n+              \"-cp\", appJar, mainClass)\n+            .assertNormalExit(output -> {\n+                    output.shouldContain(\"Written dynamic archive 0x\");\n+                });\n+        run(topArchiveName,\n+             \"-Xlog:class+load\",\n+             \"-Xlog:cds+dynamic=debug,cds=debug,class+load\",\n+             \"-cp\", appJar, mainClass)\n+            .assertNormalExit(output -> {\n+                    output.shouldContain(\"LambHello source: shared objects file (top)\")\n+                          .shouldHaveExitValue(0);\n+                    for (String s : CHECK_MESSAGES) {\n+                          output.shouldContain(s);\n+                    }\n+                });\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/TestDynamicRegenerateHolderClasses.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+import java.util.HashMap;\n+public class MiniStoreOom {\n+    private static HashMap<Integer, Byte[]>  store = new HashMap<Integer, Byte[]>();\n+    public static void main(String... args) throws Exception {\n+        int size = Integer.valueOf(args[0]);\n+        int i = 0;\n+        while (i++ < Integer.MAX_VALUE) {\n+            store.put(i, new Byte[size]);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/test-classes\/MiniStoreOom.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"}]}