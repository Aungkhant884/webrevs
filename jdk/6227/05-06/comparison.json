{"files":[{"patch":"@@ -2105,2 +2105,1 @@\n-        final double[] x_coeff = new double[4];\n-        final double[] y_coeff = new double[4];\n+        final double[] coeff = new double[4];\n@@ -2109,2 +2108,1 @@\n-        final double[] x_deriv_coeff = new double[3];\n-        final double[] y_deriv_coeff = new double[3];\n+        final double[] deriv_coeff = new double[3];\n@@ -2122,0 +2120,10 @@\n+        \/\/ Whenever we have to examine cubic or quadratic extrema that change\n+        \/\/ our bounding box: we run the risk of machine error that may produce\n+        \/\/ a box that is slightly too small. But the contract of this method\n+        \/\/ says we should err on the side of being too large.\n+        \/\/ So to address this: we take the difference between the control\n+        \/\/ point and our calculated extrema, divide that difference by this\n+        \/\/ constant, and then nudge our extrema by that amount.\n+        \/\/ This will slightly expand the bounds to help overcome machine error.\n+        double marginDivisor = 1000000000.0;\n+\n@@ -2155,7 +2163,3 @@\n-                        x_coeff[2] = (coords[2] - coords[0]) - dx21;  \/\/ A = P3 - P0 - 2 P2\n-                        x_coeff[1] = 2.0 * dx21;                      \/\/ B = 2 (P2 - P1)\n-                        x_coeff[0] = lastX;                           \/\/ C = P1\n-\n-                        x_coeff[2] = lastX - 2.0 * coords[0] + coords[2];\n-                        x_coeff[1] = -2.0 * lastX + 2.0 * coords[0];\n-                        x_coeff[0] = lastX;\n+                        coeff[2] = (coords[2] - coords[0]) - dx21;  \/\/ A = P3 - P0 - 2 P2\n+                        coeff[1] = 2.0 * dx21;                      \/\/ B = 2 (P2 - P1)\n+                        coeff[0] = lastX;                           \/\/ C = P1\n@@ -2163,2 +2167,2 @@\n-                        x_deriv_coeff[0] = x_coeff[1];\n-                        x_deriv_coeff[1] = 2.0 * x_coeff[2];\n+                        deriv_coeff[0] = coeff[1];\n+                        deriv_coeff[1] = 2.0 * coeff[2];\n@@ -2166,1 +2170,1 @@\n-                        double t = -x_deriv_coeff[0] \/ x_deriv_coeff[1];\n+                        double t = -deriv_coeff[0] \/ deriv_coeff[1];\n@@ -2168,3 +2172,9 @@\n-                            double x = x_coeff[0] + t * (x_coeff[1] + t * x_coeff[2]);\n-                            if (x < leftX) leftX = x;\n-                            if (x > rightX) rightX = x;\n+                            double x = coeff[0] + t * (coeff[1] + t * coeff[2]);\n+                            if (x < leftX) {\n+                                double margin = (x - coords[0]) \/ marginDivisor;\n+                                leftX = x - margin;\n+                            }\n+                            if (x > rightX) {\n+                                double margin = (coords[0] - x) \/ marginDivisor;\n+                                rightX = x + margin;\n+                            }\n@@ -2175,3 +2185,3 @@\n-                        y_coeff[2] = (coords[3] - coords[1]) - dy21;\n-                        y_coeff[1] = 2.0 * dy21;\n-                        y_coeff[0] = lastY;\n+                        coeff[2] = (coords[3] - coords[1]) - dy21;\n+                        coeff[1] = 2.0 * dy21;\n+                        coeff[0] = lastY;\n@@ -2179,2 +2189,2 @@\n-                        y_deriv_coeff[0] = y_coeff[1];\n-                        y_deriv_coeff[1] = 2.0 * y_coeff[2];\n+                        deriv_coeff[0] = coeff[1];\n+                        deriv_coeff[1] = 2.0 * coeff[2];\n@@ -2182,1 +2192,1 @@\n-                        double t = -y_deriv_coeff[0] \/ y_deriv_coeff[1];\n+                        double t = -deriv_coeff[0] \/ deriv_coeff[1];\n@@ -2184,3 +2194,9 @@\n-                            double y = y_coeff[0] + t * (y_coeff[1] + t * y_coeff[2]);\n-                            if (y < topY) topY = y;\n-                            if (y > bottomY) bottomY = y;\n+                            double y = coeff[0] + t * (coeff[1] + t * coeff[2]);\n+                            if (y < topY) {\n+                                double margin = (y - coords[1]) \/ marginDivisor;\n+                                topY = y - margin;\n+                            }\n+                            if (y > bottomY) {\n+                                double margin = (coords[1] - y) \/ marginDivisor;\n+                                bottomY = y + margin;\n+                            }\n@@ -2201,4 +2217,4 @@\n-                        x_coeff[3] = (coords[4] - lastX) - dx32;  \/\/ A = P3 - P0 - 3 (P2 - P1) = (P3 - P0) + 3 (P1 - P2)\n-                        x_coeff[2] = (dx32 - dx21);               \/\/ B = 3 (P2 - P1) - 3(P1 - P0) = 3 (P2 + P0) - 6 P1\n-                        x_coeff[1] = dx21;                        \/\/ C = 3 (P1 - P0)\n-                        x_coeff[0] = lastX;                       \/\/ D = P0\n+                        coeff[3] = (coords[4] - lastX) - dx32;  \/\/ A = P3 - P0 - 3 (P2 - P1) = (P3 - P0) + 3 (P1 - P2)\n+                        coeff[2] = (dx32 - dx21);               \/\/ B = 3 (P2 - P1) - 3(P1 - P0) = 3 (P2 + P0) - 6 P1\n+                        coeff[1] = dx21;                        \/\/ C = 3 (P1 - P0)\n+                        coeff[0] = lastX;                       \/\/ D = P0\n@@ -2206,3 +2222,3 @@\n-                        x_deriv_coeff[0] = x_coeff[1];\n-                        x_deriv_coeff[1] = 2.0 * x_coeff[2];\n-                        x_deriv_coeff[2] = 3.0 * x_coeff[3];\n+                        deriv_coeff[0] = coeff[1];\n+                        deriv_coeff[1] = 2.0 * coeff[2];\n+                        deriv_coeff[2] = 3.0 * coeff[3];\n@@ -2210,1 +2226,1 @@\n-                        int tExtremaCount = QuadCurve2D.solveQuadratic(x_deriv_coeff, tExtrema);\n+                        int tExtremaCount = QuadCurve2D.solveQuadratic(deriv_coeff, tExtrema);\n@@ -2214,3 +2230,19 @@\n-                                double x = x_coeff[0] + t * (x_coeff[1] + t * (x_coeff[2] + t * x_coeff[3]));\n-                                if (x < leftX) leftX = x;\n-                                if (x > rightX) rightX = x;\n+                                double x = coeff[0] + t * (coeff[1] + t * (coeff[2] + t * coeff[3]));\n+                                if (x < leftX) {\n+                                    double margin;\n+                                    if (coords[0] < coords[2]) {\n+                                        margin = (x - coords[0]) \/ marginDivisor;\n+                                    } else {\n+                                        margin = (x - coords[2]) \/ marginDivisor;\n+                                    }\n+                                    leftX = x - margin;\n+                                }\n+                                if (x > rightX) {\n+                                    double margin;\n+                                    if (coords[0] > coords[2]) {\n+                                        margin = (coords[0] - x) \/ marginDivisor;\n+                                    } else {\n+                                        margin = (coords[2] - x) \/ marginDivisor;\n+                                    }\n+                                    rightX = x + margin;\n+                                }\n@@ -2223,4 +2255,4 @@\n-                        y_coeff[3] = (coords[5] - lastY) - dy32;\n-                        y_coeff[2] = (dy32 - dy21);\n-                        y_coeff[1] = dy21;\n-                        y_coeff[0] = lastY;\n+                        coeff[3] = (coords[5] - lastY) - dy32;\n+                        coeff[2] = (dy32 - dy21);\n+                        coeff[1] = dy21;\n+                        coeff[0] = lastY;\n@@ -2228,3 +2260,3 @@\n-                        y_deriv_coeff[0] = y_coeff[1];\n-                        y_deriv_coeff[1] = 2.0 * y_coeff[2];\n-                        y_deriv_coeff[2] = 3.0 * y_coeff[3];\n+                        deriv_coeff[0] = coeff[1];\n+                        deriv_coeff[1] = 2.0 * coeff[2];\n+                        deriv_coeff[2] = 3.0 * coeff[3];\n@@ -2232,1 +2264,1 @@\n-                        int tExtremaCount = QuadCurve2D.solveQuadratic(y_deriv_coeff, tExtrema);\n+                        int tExtremaCount = QuadCurve2D.solveQuadratic(deriv_coeff, tExtrema);\n@@ -2236,3 +2268,19 @@\n-                                double y = y_coeff[0] + t * (y_coeff[1] + t * (y_coeff[2] + t * y_coeff[3]));\n-                                if (y < topY) topY = y;\n-                                if (y > bottomY) bottomY = y;\n+                                double y = coeff[0] + t * (coeff[1] + t * (coeff[2] + t * coeff[3]));\n+                                if (y < topY) {\n+                                    double margin;\n+                                    if (coords[1] < coords[3]) {\n+                                        margin = (y - coords[1]) \/ marginDivisor;\n+                                    } else {\n+                                        margin = (y - coords[3]) \/ marginDivisor;\n+                                    }\n+                                    topY = y - margin;\n+                                }\n+                                if (y > bottomY) {\n+                                    double margin;\n+                                    if (coords[1] > coords[3]) {\n+                                        margin = (coords[1] - y) \/ marginDivisor;\n+                                    } else {\n+                                        margin = (coords[3] - y) \/ marginDivisor;\n+                                    }\n+                                    bottomY = y + margin;\n+                                }\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/geom\/Path2D.java","additions":96,"deletions":48,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -10,3 +10,2 @@\n- * @summary This is not a test. This is an exploratory task to empirically\n- *          identify how to expand a rectangle to comfortably fit just outside\n- *          (and never inside) a precise bounding box.\n+ * @summary This tests thousands of shapes and makes sure a high-precision bounding box fits inside the\n+ * results of Path2D.getBounds(PathIterator)\n@@ -14,1 +13,0 @@\n-\n@@ -17,0 +15,12 @@\n+    public static void main(String[] args) {\n+        String msg1 = testSmallCubics();\n+        if (msg1 != null) {\n+            System.out.println(\"testSmallCubics: \"+msg1);\n+        } else {\n+            System.out.println(\"testSmallCubics: passed\");\n+        }\n+\n+        if (msg1 != null)\n+            throw new RuntimeException(\"One or more tests failed; see System.out output for details.\");\n+    }\n+\n@@ -18,11 +28,1 @@\n-     * This iterates through a million random CubicCurve2D and identifies the\n-     * marginMultiplier constant needed to consistently expand the bounding box\n-     * so it slightly exceeds a precise bounding box. The precise bounding box\n-     * follows the same algorithm, but it uses BigDecimals to have several more\n-     * digits of accuracy.\n-     * <p>\n-     * This currently suffers from a design flaw: the multiplier is applied to the\n-     * ulp of the x or y value in question. So the size of that ulp varies based\n-     * on how close x or y is to zero. This results in the multiplier being extremely\n-     * large to compensate.\n-     * <\/p>\n+     * @return a String describing the failure, or null if this test passed.\n@@ -30,4 +30,6 @@\n-    public static void main(String[] args) {\n-        Random random = new Random(0);\n-        for(int a = 0; a < 1000000; a++) {\n-            test(a, random);\n+    private static String testSmallCubics() {\n+        int failureCtr = 0;\n+        for(int a = 0; a < 1000; a++) {\n+            CubicCurve2D cubicCurve2D = createSmallCubic(a);\n+            if (!test(a, cubicCurve2D, getHorizontalEdges(cubicCurve2D)))\n+                failureCtr++;\n@@ -35,1 +37,3 @@\n-        System.out.println(\"Final multiplier: \" + marginMultiplier);\n+        if (failureCtr > 0)\n+            return failureCtr+\" tests failed; see System.out for details\";\n+        return null;\n@@ -38,1 +42,2 @@\n-    static double marginMultiplier = 1;\n+    private static CubicCurve2D createSmallCubic(int trial) {\n+        Random random = new Random(trial);\n@@ -40,1 +45,0 @@\n-    private static void test(int trial, Random random) {\n@@ -46,1 +50,2 @@\n-        CubicCurve2D curve = new CubicCurve2D.Double(0, 0, cx1, cy1, cx2, cy2, 0, 1);\n+        return new CubicCurve2D.Double(0, 0, cx1, cy1, cx2, cy2, 0, 1);\n+    }\n@@ -48,3 +53,21 @@\n-        \/\/ The incoming data from a PathIterator is always represented by doubles, so that needs\n-        \/\/ to be where we start. (That is: if there's machine error already baked into those\n-        \/\/ doubles, then that's not something we can control for or accommodate.)\n+    \/**\n+     * This returns true if the shape's getBounds2D() method returns a bounding box whose\n+     * left & right edges matches or exceeds the horizontalEdges arguments.\n+     *\/\n+    private static boolean test(int trial, Shape shape, BigDecimal[] horizontalEdges) {\n+        Rectangle2D bounds_doublePrecision = Path2D.getBounds2D(shape.getPathIterator(null));\n+\n+        Rectangle2D bounds_bigDecimalPrecision = new Rectangle2D.Double(\n+                horizontalEdges[0].doubleValue(),\n+                bounds_doublePrecision.getY(),\n+                horizontalEdges[1].subtract(horizontalEdges[0]).doubleValue(),\n+                bounds_doublePrecision.getHeight() );\n+\n+        boolean pass = true;\n+        if (bounds_doublePrecision.getMinX() > bounds_bigDecimalPrecision.getMinX()) {\n+            pass = false;\n+            String x1a = toUniformString(bounds_bigDecimalPrecision.getX());\n+            String x1b = toComparisonString(x1a, toUniformString(bounds_doublePrecision.getX()));\n+            System.out.println(\"Left expected:\\t\"+x1a);\n+            System.out.println(\"Left observed:\\t\"+x1b);\n+        }\n@@ -52,1 +75,18 @@\n-        \/\/ ... but everything that follows can, technically be calculated in really high precision:\n+        if (bounds_doublePrecision.getMaxX() < bounds_bigDecimalPrecision.getMaxX()) {\n+            pass = false;\n+            String x2a = toUniformString(bounds_bigDecimalPrecision.getMaxX());\n+            String x2b = toComparisonString(x2a, toUniformString(bounds_doublePrecision.getMaxX()));\n+            System.out.println(\"Right expected:\\t\"+x2a);\n+            System.out.println(\"Right observed:\\t\"+x2b);\n+        }\n+        if (!pass)\n+            System.out.println(\"\\ttrial \"+trial +\" failed (\"+toString(shape)+\")\");\n+        return pass;\n+    }\n+\n+    \/**\n+     * Return the left and right edges in high precision\n+     *\/\n+    private static BigDecimal[] getHorizontalEdges(CubicCurve2D curve) {\n+        double cx1 = curve.getCtrlX1();\n+        double cx2 = curve.getCtrlX2();\n@@ -85,0 +125,2 @@\n+        return new BigDecimal[] { leftX, rightX };\n+    }\n@@ -86,5 +128,5 @@\n-        Result result = getResult(curve, leftX, rightX);\n-        if (result == Result.PASSING)\n-            return;\n-\n-        System.out.println(\"Examining (trial #\"+trial+\"), \"+result+\", \"+toString(curve));\n+    \/**\n+     * Return the left and right edges in high precision\n+     *\/\n+    private static BigDecimal[] getHorizontalEdges(QuadCurve2D curve) {\n+        double cx = curve.getCtrlX();\n@@ -92,9 +134,2 @@\n-        String leftStr = toUniformString(leftX);\n-        String rightStr = toUniformString(rightX);\n-        if (result == Result.FAIL_BOTH) {\n-            System.out.println(\"Exp:\\t\" + leftStr + \"\\t\" + rightStr);\n-        } else if (result == Result.FAIL_LEFT) {\n-            System.out.println(\"Exp:\\t\" + leftStr);\n-        } else if (result == Result.FAIL_RIGHT) {\n-            System.out.println(\"Exp:\\t\" + rightStr);\n-        }\n+        BigDecimal[] coeff = new BigDecimal[3];\n+        BigDecimal[] deriv_coeff = new BigDecimal[2];\n@@ -102,13 +137,4 @@\n-        double v = marginMultiplier;\n-        marginMultiplier = 0;\n-        Rectangle2D bounds = getBounds2D(curve.getPathIterator(null));\n-        marginMultiplier = v;\n-        String leftStr2 = toComparisonString(new BigDecimal(bounds.getMinX()), leftStr);\n-        String rightStr2 = toComparisonString(new BigDecimal(bounds.getMaxX()), rightStr);\n-        if (result == Result.FAIL_BOTH) {\n-            System.out.println(\"Orig:\\t\"+leftStr2+\"\\t\"+rightStr2);\n-        } else if (result == Result.FAIL_LEFT) {\n-            System.out.println(\"Orig:\\t\"+leftStr2);\n-        } else if (result == Result.FAIL_RIGHT) {\n-            System.out.println(\"Orig:\\t\"+rightStr2);\n-        }\n+        BigDecimal dx21 = new BigDecimal(cx).subtract(new BigDecimal(curve.getX1()));\n+        coeff[2] = new BigDecimal(curve.getX2()).subtract(new BigDecimal(cx)).subtract(dx21);  \/\/ A = P3 - P0 - 2 P2\n+        coeff[1] = new BigDecimal(2.0).multiply(dx21);                      \/\/ B = 2 (P2 - P1)\n+        coeff[0] = new BigDecimal(curve.getX1());                           \/\/ C = P1\n@@ -116,10 +142,2 @@\n-        bounds = getBounds2D(curve.getPathIterator(null));\n-        leftStr2 = toComparisonString(new BigDecimal(bounds.getMinX()), leftStr);\n-        rightStr2 = toComparisonString(new BigDecimal(bounds.getMaxX()), rightStr);\n-        if (result == Result.FAIL_BOTH) {\n-            System.out.println(\"Was:\\t\"+leftStr2+\"\\t\"+rightStr2);\n-        } else if (result == Result.FAIL_LEFT) {\n-            System.out.println(\"Was:\\t\"+leftStr2);\n-        } else if (result == Result.FAIL_RIGHT) {\n-            System.out.println(\"Was:\\t\"+rightStr2);\n-        }\n+        deriv_coeff[0] = coeff[1];\n+        deriv_coeff[1] = new BigDecimal(2.0).multiply( coeff[2] );\n@@ -127,2 +145,2 @@\n-        double minMargin = marginMultiplier;\n-        double maxMargin = marginMultiplier * 1000;\n+        BigDecimal leftX = BigDecimal.ZERO;\n+        BigDecimal rightX = BigDecimal.ZERO;\n@@ -130,6 +148,2 @@\n-        marginMultiplier = maxMargin;\n-        while(getResult(curve, leftX, rightX) != Result.PASSING) {\n-            minMargin = maxMargin;\n-            maxMargin = maxMargin * 1000;\n-            marginMultiplier = maxMargin;\n-        }\n+        if (!deriv_coeff[1].equals(BigDecimal.ZERO)) {\n+            BigDecimal t = deriv_coeff[0].negate().divide(deriv_coeff[1], RoundingMode.HALF_EVEN);\n@@ -137,24 +151,4 @@\n-        int ctr = 0;\n-        while(true) {\n-            double newMargin = (maxMargin + minMargin) \/ 2;\n-            if (newMargin == maxMargin || newMargin == minMargin || ctr > 1000) {\n-                bounds = getBounds2D(curve.getPathIterator(null));\n-                leftStr2 = toComparisonString(new BigDecimal(bounds.getMinX()), leftStr);\n-                rightStr2 = toComparisonString(new BigDecimal(bounds.getMaxX()), rightStr);\n-\n-                if (result == Result.FAIL_BOTH) {\n-                    System.out.println(\"Now:\\t\"+leftStr2+\"\\t\"+rightStr2);\n-                } else if (result == Result.FAIL_LEFT) {\n-                    System.out.println(\"Now:\\t\"+leftStr2);\n-                } else if (result == Result.FAIL_RIGHT) {\n-                    System.out.println(\"Now:\\t\"+rightStr2);\n-                }\n-\n-                System.out.println(\"New marginMultiplier = \"+marginMultiplier);\n-                return;\n-            }\n-            marginMultiplier= newMargin;\n-            if (getResult(curve, leftX, rightX)==Result.PASSING) {\n-                maxMargin = marginMultiplier;\n-            } else {\n-                minMargin = marginMultiplier;\n+            if (t.compareTo( BigDecimal.ZERO ) > 0 && t.compareTo(BigDecimal.ONE) < 0) {\n+                BigDecimal x = coeff[0].add( t.multiply(coeff[1].add(t.multiply(coeff[2]))) );\n+                if (x.compareTo(leftX) < 0) leftX = x;\n+                if (x.compareTo(rightX) > 0) rightX = x;\n@@ -162,1 +156,0 @@\n-            ctr++;\n@@ -164,0 +157,2 @@\n+\n+        return new BigDecimal[] { leftX, rightX };\n@@ -191,1 +186,2 @@\n-    private static String toUniformString(BigDecimal decimal) {\n+    private static String toUniformString(double value) {\n+        BigDecimal decimal = new BigDecimal(value);\n@@ -203,5 +199,4 @@\n-    private static String toComparisonString(BigDecimal target, String compareAgainst) {\n-        String str = toUniformString(target);\n-        for(int a = 0; a<str.length(); a++) {\n-            char ch1 = str.charAt(a);\n-            char ch2 = compareAgainst.charAt(a);\n+    private static String toComparisonString(String target, String observed) {\n+        for(int a = 0; a<target.length(); a++) {\n+            char ch1 = target.charAt(a);\n+            char ch2 = observed.charAt(a);\n@@ -209,1 +204,1 @@\n-                return str.substring(0,a) + createCircleDigit(ch1)+str.substring(a+1);\n+                return observed.substring(0,a) + createCircleDigit(ch2)+observed.substring(a+1);\n@@ -212,1 +207,1 @@\n-        return str;\n+        return observed;\n@@ -227,25 +222,0 @@\n-    enum Result {\n-        PASSING, FAIL_LEFT, FAIL_RIGHT, FAIL_BOTH;\n-    }\n-\n-    \/**\n-     * Check to see if getBounds2D(..) is as big or larger than the precise bounds. If the left or right\n-     * edge comes in too small then this returns a failing Result.\n-     *\/\n-    private static Result getResult(CubicCurve2D curve, BigDecimal preciseLeft, BigDecimal preciseRight) {\n-        Rectangle2D r = getBounds2D(curve.getPathIterator(null));\n-\n-        BigDecimal observedLeftX = new BigDecimal(r.getMinX());\n-        BigDecimal observedRightX = new BigDecimal(r.getMaxX());\n-\n-        boolean badLeft = observedLeftX.compareTo(preciseLeft) > 0;\n-        boolean badRight = observedRightX.compareTo(preciseRight) < 0;\n-        if (badLeft && badRight)\n-            return Result.FAIL_BOTH;\n-        if (badLeft)\n-            return Result.FAIL_LEFT;\n-        if (badRight)\n-            return Result.FAIL_RIGHT;\n-        return Result.PASSING;\n-    }\n-\n@@ -289,163 +259,0 @@\n-\n-    \/**\n-     * This is an adaptation of the existing Path2D.getBounds2D(PathIterator) draft that\n-     * expands bounding box by <code>double margin = marginMultiplier * Math.ulp(v);<\/code>\n-     *\/\n-    public static Rectangle2D getBounds2D(final PathIterator pi) {\n-        \/\/ define x and y parametric coefficients where:\n-        \/\/ x(t) = x_coeff[0] + x_coeff[1] * t + x_coeff[2] * t^2 + x_coeff[3] * t^3\n-        final double[] coeff = new double[4];\n-\n-        \/\/ define the derivative's coefficients\n-        final double[] deriv_coeff = new double[3];\n-\n-        final double[] coords = new double[6];\n-        final double[] tExtrema = new double[2];\n-        boolean isDefined = false;\n-        double leftX = 0.0;\n-        double rightX = 0.0;\n-        double topY = 0.0;\n-        double bottomY = 0.0;\n-        double lastX = 0.0;\n-        double lastY = 0.0;\n-\n-        for (; !pi.isDone(); pi.next()) {\n-            int type = pi.currentSegment(coords);\n-            switch (type) {\n-                case PathIterator.SEG_MOVETO:\n-                    if (!isDefined) {\n-                        isDefined = true;\n-                        leftX = rightX = coords[0];\n-                        topY = bottomY = coords[1];\n-                    } else {\n-                        if (coords[0] < leftX) leftX = coords[0];\n-                        if (coords[0] > rightX) rightX = coords[0];\n-                        if (coords[1] < topY) topY = coords[1];\n-                        if (coords[1] > bottomY) bottomY = coords[1];\n-                    }\n-                    lastX = coords[0];\n-                    lastY = coords[1];\n-                    break;\n-                case PathIterator.SEG_LINETO:\n-                    if (coords[0] < leftX) leftX = coords[0];\n-                    if (coords[0] > rightX) rightX = coords[0];\n-                    if (coords[1] < topY) topY = coords[1];\n-                    if (coords[1] > bottomY) bottomY = coords[1];\n-                    lastX = coords[0];\n-                    lastY = coords[1];\n-                    break;\n-                case PathIterator.SEG_QUADTO:\n-                    if (coords[2] < leftX) leftX = coords[2];\n-                    if (coords[2] > rightX) rightX = coords[2];\n-                    if (coords[3] < topY) topY = coords[3];\n-                    if (coords[3] > bottomY) bottomY = coords[3];\n-\n-                    if (coords[0] < leftX || coords[0] > rightX) {\n-                        final double dx21 = (coords[0] - lastX);\n-                        coeff[2] = (coords[2] - coords[0]) - dx21;  \/\/ A = P3 - P0 - 2 P2\n-                        coeff[1] = 2.0 * dx21;                      \/\/ B = 2 (P2 - P1)\n-                        coeff[0] = lastX;                           \/\/ C = P1\n-\n-                        coeff[2] = lastX - 2.0 * coords[0] + coords[2];\n-                        coeff[1] = -2.0 * lastX + 2.0 * coords[0];\n-                        coeff[0] = lastX;\n-\n-                        deriv_coeff[0] = coeff[1];\n-                        deriv_coeff[1] = 2.0 * coeff[2];\n-\n-                        double t = -deriv_coeff[0] \/ deriv_coeff[1];\n-                        if (t > 0.0 && t < 1.0) {\n-                            double x = coeff[0] + t * (coeff[1] + t * coeff[2]);\n-                            double margin = marginMultiplier * Math.ulp(x);\n-                            if (x - margin < leftX) leftX = x - margin;\n-                            if (x + margin> rightX) rightX = x + margin;\n-                        }\n-                    }\n-                    if (coords[1] < topY || coords[1] > bottomY) {\n-                        final double dy21 = (coords[1] - lastY);\n-                        coeff[2] = (coords[3] - coords[1]) - dy21;\n-                        coeff[1] = 2.0 * dy21;\n-                        coeff[0] = lastY;\n-\n-                        deriv_coeff[0] = coeff[1];\n-                        deriv_coeff[1] = 2.0 * coeff[2];\n-\n-                        double t = -deriv_coeff[0] \/ deriv_coeff[1];\n-                        if (t > 0.0 && t < 1.0) {\n-                            double y = coeff[0] + t * (coeff[1] + t * coeff[2]);\n-                            double margin = marginMultiplier * Math.ulp(y);\n-                            if (y - margin < topY) topY = y - margin;\n-                            if (y + margin > bottomY) bottomY = y + margin;\n-                        }\n-                    }\n-                    lastX = coords[2];\n-                    lastY = coords[3];\n-                    break;\n-                case PathIterator.SEG_CUBICTO:\n-                    if (coords[4] < leftX) leftX = coords[4];\n-                    if (coords[4] > rightX) rightX = coords[4];\n-                    if (coords[5] < topY) topY = coords[5];\n-                    if (coords[5] > bottomY) bottomY = coords[5];\n-\n-                    if (coords[0] < leftX || coords[0] > rightX || coords[2] < leftX || coords[2] > rightX) {\n-                        final double dx32 = 3.0 * (coords[2] - coords[0]);\n-                        final double dx21 = 3.0 * (coords[0] - lastX);\n-                        coeff[3] = (coords[4] - lastX) - dx32;  \/\/ A = P3 - P0 - 3 (P2 - P1) = (P3 - P0) + 3 (P1 - P2)\n-                        coeff[2] = (dx32 - dx21);               \/\/ B = 3 (P2 - P1) - 3(P1 - P0) = 3 (P2 + P0) - 6 P1\n-                        coeff[1] = dx21;                        \/\/ C = 3 (P1 - P0)\n-                        coeff[0] = lastX;                       \/\/ D = P0\n-\n-                        deriv_coeff[0] = coeff[1];\n-                        deriv_coeff[1] = 2.0 * coeff[2];\n-                        deriv_coeff[2] = 3.0 * coeff[3];\n-\n-                        int tExtremaCount = QuadCurve2D.solveQuadratic(deriv_coeff, tExtrema);\n-                        for (int i = 0; i < tExtremaCount; i++) {\n-                            double t = tExtrema[i];\n-                            if (t > 0.0 && t < 1.0) {\n-                                double x = coeff[0] + t * (coeff[1] + t * (coeff[2] + t * coeff[3]));\n-                                double margin = marginMultiplier * Math.ulp(x);\n-                                if (x - margin < leftX) leftX = x - margin;\n-                                if (x + margin > rightX) rightX = x + margin;\n-                            }\n-                        }\n-                    }\n-                    if (coords[1] < topY || coords[1] > bottomY || coords[3] < topY || coords[3] > bottomY) {\n-                        final double dy32 = 3.0 * (coords[3] - coords[1]);\n-                        final double dy21 = 3.0 * (coords[1] - lastY);\n-                        coeff[3] = (coords[5] - lastY) - dy32;\n-                        coeff[2] = (dy32 - dy21);\n-                        coeff[1] = dy21;\n-                        coeff[0] = lastY;\n-\n-                        deriv_coeff[0] = coeff[1];\n-                        deriv_coeff[1] = 2.0 * coeff[2];\n-                        deriv_coeff[2] = 3.0 * coeff[3];\n-\n-                        int tExtremaCount = QuadCurve2D.solveQuadratic(deriv_coeff, tExtrema);\n-                        for (int i = 0; i < tExtremaCount; i++) {\n-                            double t = tExtrema[i];\n-                            if (t > 0.0 && t < 1.0) {\n-                                double y = coeff[0] + t * (coeff[1] + t * (coeff[2] + t * coeff[3]));\n-                                double margin = marginMultiplier * Math.ulp(y);\n-                                if (y - margin < topY) topY = y - margin;\n-                                if (y + margin > bottomY) bottomY = y + margin;\n-                            }\n-                        }\n-                    }\n-                    lastX = coords[4];\n-                    lastY = coords[5];\n-                    break;\n-                case PathIterator.SEG_CLOSE:\n-                default:\n-                    continue;\n-            }\n-        }\n-        if (isDefined) {\n-            return new Rectangle2D.Double(leftX, topY, rightX - leftX, bottomY - topY);\n-        }\n-\n-        \/\/ there's room to debate what should happen here, but historically we return a zeroed\n-        \/\/ out rectangle here. So for backwards compatibility let's keep doing that:\n-        return new Rectangle2D.Double();\n-    }\n","filename":"test\/jdk\/java\/awt\/geom\/Path2D\/GetBounds2DPrecisionTest.java","additions":100,"deletions":293,"binary":false,"changes":393,"status":"modified"}]}