{"files":[{"patch":"@@ -0,0 +1,452 @@\n+\n+import java.awt.*;\n+import java.awt.geom.*;\n+import java.math.*;\n+import java.util.*;\n+\n+\/*\n+ * @test\n+ * @bug 8176501\n+ * @summary This is not a test. This is an exploratory task to empirically\n+ *          identify how to expand a rectangle to comfortably fit just outside\n+ *          (and never inside) a precise bounding box.\n+ *\/\n+\n+public class GetBounds2DPrecisionTest {\n+\n+    \/**\n+     * This iterates through a million random CubicCurve2D and identifies the\n+     * marginMultiplier constant needed to consistently expand the bounding box\n+     * so it slightly exceeds a precise bounding box. The precise bounding box\n+     * follows the same algorithm, but it uses BigDecimals to have several more\n+     * digits of accuracy.\n+     * <p>\n+     * This currently suffers from a design flaw: the multiplier is applied to the\n+     * ulp of the x or y value in question. So the size of that ulp varies based\n+     * on how close x or y is to zero. This results in the multiplier being extremely\n+     * large to compensate.\n+     * <\/p>\n+     *\/\n+    public static void main(String[] args) {\n+        Random random = new Random(0);\n+        for(int a = 0; a < 1000000; a++) {\n+            test(a, random);\n+        }\n+        System.out.println(\"Final multiplier: \" + marginMultiplier);\n+    }\n+\n+    static double marginMultiplier = 1;\n+\n+    private static void test(int trial, Random random) {\n+        double cx1 = random.nextDouble() * 10 - 5;\n+        double cy1 = random.nextDouble();\n+        double cx2 = random.nextDouble() * 10 - 5;\n+        double cy2 = random.nextDouble();\n+\n+        CubicCurve2D curve = new CubicCurve2D.Double(0, 0, cx1, cy1, cx2, cy2, 0, 1);\n+\n+        \/\/ The incoming data from a PathIterator is always represented by doubles, so that needs\n+        \/\/ to be where we start. (That is: if there's machine error already baked into those\n+        \/\/ doubles, then that's not something we can control for or accommodate.)\n+\n+        \/\/ ... but everything that follows can, technically be calculated in really high precision:\n+\n+        BigDecimal[] coeff = new BigDecimal[4];\n+        BigDecimal[] deriv_coeff = new BigDecimal[3];\n+        BigDecimal[] tExtrema = new BigDecimal[2];\n+\n+\/\/        coeff[3] = -lastX + 3.0 * coords[0] - 3.0 * coords[2] + coords[4];\n+\/\/        coeff[2] = 3.0 * lastX - 6.0 * coords[0] + 3.0 * coords[2];\n+\/\/        coeff[1] = -3.0 * lastX + 3.0 * coords[0];\n+\/\/        coeff[0] = lastX;\n+\n+        coeff[3] = new BigDecimal(3).multiply(new BigDecimal(cx1)).add( new BigDecimal(-3).multiply(new BigDecimal(cx2)) );\n+        coeff[2] = new BigDecimal(-6).multiply(new BigDecimal(cx1)).add(new BigDecimal(3).multiply(new BigDecimal(cx2)));\n+        coeff[1] = new BigDecimal(3).multiply(new BigDecimal(cx1));\n+        coeff[0] = BigDecimal.ZERO;\n+\n+        deriv_coeff[0] = coeff[1];\n+        deriv_coeff[1] = new BigDecimal(2.0).multiply( coeff[2] );\n+        deriv_coeff[2] = new BigDecimal(3.0).multiply( coeff[3] );\n+\n+        int tExtremaCount = solveQuadratic(deriv_coeff, tExtrema);\n+\n+        BigDecimal leftX = BigDecimal.ZERO;\n+        BigDecimal rightX = BigDecimal.ZERO;\n+\n+        for (int i = 0; i < tExtremaCount; i++) {\n+            BigDecimal t = tExtrema[i];\n+            if (t.compareTo( BigDecimal.ZERO ) > 0 && t.compareTo(BigDecimal.ONE) < 0) {\n+                BigDecimal x = coeff[0].add( t.multiply(coeff[1].add(t.multiply(coeff[2].add(t.multiply(coeff[3]))))) );\n+                if (x.compareTo(leftX) < 0) leftX = x;\n+                if (x.compareTo(rightX) > 0) rightX = x;\n+            }\n+        }\n+\n+        Result result = getResult(curve, leftX, rightX);\n+        if (result == Result.PASSING)\n+            return;\n+\n+        System.out.println(\"Examining (trial #\"+trial+\"), \"+result+\", \"+toString(curve));\n+\n+        String leftStr = toUniformString(leftX);\n+        String rightStr = toUniformString(rightX);\n+        if (result == Result.FAIL_BOTH) {\n+            System.out.println(\"Exp:\\t\" + leftStr + \"\\t\" + rightStr);\n+        } else if (result == Result.FAIL_LEFT) {\n+            System.out.println(\"Exp:\\t\" + leftStr);\n+        } else if (result == Result.FAIL_RIGHT) {\n+            System.out.println(\"Exp:\\t\" + rightStr);\n+        }\n+\n+        double v = marginMultiplier;\n+        marginMultiplier = 0;\n+        Rectangle2D bounds = getBounds2D(curve.getPathIterator(null));\n+        marginMultiplier = v;\n+        String leftStr2 = toComparisonString(new BigDecimal(bounds.getMinX()), leftStr);\n+        String rightStr2 = toComparisonString(new BigDecimal(bounds.getMaxX()), rightStr);\n+        if (result == Result.FAIL_BOTH) {\n+            System.out.println(\"Orig:\\t\"+leftStr2+\"\\t\"+rightStr2);\n+        } else if (result == Result.FAIL_LEFT) {\n+            System.out.println(\"Orig:\\t\"+leftStr2);\n+        } else if (result == Result.FAIL_RIGHT) {\n+            System.out.println(\"Orig:\\t\"+rightStr2);\n+        }\n+\n+        bounds = getBounds2D(curve.getPathIterator(null));\n+        leftStr2 = toComparisonString(new BigDecimal(bounds.getMinX()), leftStr);\n+        rightStr2 = toComparisonString(new BigDecimal(bounds.getMaxX()), rightStr);\n+        if (result == Result.FAIL_BOTH) {\n+            System.out.println(\"Was:\\t\"+leftStr2+\"\\t\"+rightStr2);\n+        } else if (result == Result.FAIL_LEFT) {\n+            System.out.println(\"Was:\\t\"+leftStr2);\n+        } else if (result == Result.FAIL_RIGHT) {\n+            System.out.println(\"Was:\\t\"+rightStr2);\n+        }\n+\n+        double minMargin = marginMultiplier;\n+        double maxMargin = marginMultiplier * 1000;\n+\n+        marginMultiplier = maxMargin;\n+        while(getResult(curve, leftX, rightX) != Result.PASSING) {\n+            minMargin = maxMargin;\n+            maxMargin = maxMargin * 1000;\n+            marginMultiplier = maxMargin;\n+        }\n+\n+        int ctr = 0;\n+        while(true) {\n+            double newMargin = (maxMargin + minMargin) \/ 2;\n+            if (newMargin == maxMargin || newMargin == minMargin || ctr > 1000) {\n+                bounds = getBounds2D(curve.getPathIterator(null));\n+                leftStr2 = toComparisonString(new BigDecimal(bounds.getMinX()), leftStr);\n+                rightStr2 = toComparisonString(new BigDecimal(bounds.getMaxX()), rightStr);\n+\n+                if (result == Result.FAIL_BOTH) {\n+                    System.out.println(\"Now:\\t\"+leftStr2+\"\\t\"+rightStr2);\n+                } else if (result == Result.FAIL_LEFT) {\n+                    System.out.println(\"Now:\\t\"+leftStr2);\n+                } else if (result == Result.FAIL_RIGHT) {\n+                    System.out.println(\"Now:\\t\"+rightStr2);\n+                }\n+\n+                System.out.println(\"New marginMultiplier = \"+marginMultiplier);\n+                return;\n+            }\n+            marginMultiplier= newMargin;\n+            if (getResult(curve, leftX, rightX)==Result.PASSING) {\n+                maxMargin = marginMultiplier;\n+            } else {\n+                minMargin = marginMultiplier;\n+            }\n+            ctr++;\n+        }\n+    }\n+\n+    \/**\n+     * Convert a shape into SVG-ish notation for debugging\/readability.\n+     *\/\n+    private static String toString(Shape shape) {\n+        StringBuilder returnValue = new StringBuilder();\n+        PathIterator pi = shape.getPathIterator(null);\n+        double[] coords = new double[6];\n+        while(!pi.isDone()) {\n+            int k = pi.currentSegment(coords);\n+            if (k == PathIterator.SEG_MOVETO) {\n+                returnValue.append(\"m \"+coords[0]+\" \"+coords[1]+\" \");\n+            } else if (k == PathIterator.SEG_LINETO) {\n+                returnValue.append(\"l \"+coords[0]+\" \"+coords[1]+\" \");\n+            } else if (k == PathIterator.SEG_QUADTO) {\n+                returnValue.append(\"q \"+coords[0]+\" \"+coords[1]+\" \"+coords[2]+\" \"+coords[3]+\" \");\n+            } else if (k == PathIterator.SEG_CUBICTO) {\n+                returnValue.append(\"c \"+coords[0]+\" \"+coords[1]+\" \"+coords[2]+\" \"+coords[3]+\" \"+coords[4]+\" \"+coords[5]+\" \");\n+            } else if (k == PathIterator.SEG_CLOSE) {\n+                returnValue.append(\"z\");\n+            }\n+            pi.next();\n+        }\n+        return returnValue.toString();\n+    }\n+\n+    private static String toUniformString(BigDecimal decimal) {\n+        int DIGIT_COUNT = 40;\n+        String str = decimal.toPlainString();\n+        if (str.length() >= DIGIT_COUNT) {\n+            str = str.substring(0,DIGIT_COUNT-1)+\"â€¦\";\n+        }\n+        while(str.length() < DIGIT_COUNT) {\n+            str = str + \" \";\n+        }\n+        return str;\n+    }\n+\n+    private static String toComparisonString(BigDecimal target, String compareAgainst) {\n+        String str = toUniformString(target);\n+        for(int a = 0; a<str.length(); a++) {\n+            char ch1 = str.charAt(a);\n+            char ch2 = compareAgainst.charAt(a);\n+            if (ch1 != ch2) {\n+                return str.substring(0,a) + createCircleDigit(ch1)+str.substring(a+1);\n+            }\n+        }\n+        return str;\n+    }\n+\n+    \/**\n+     * Convert a digit 0-9 into a \"circle digit\". Really we just want any unobtrusive way to\n+     * highlight a character.\n+     *\/\n+    private static char createCircleDigit(char ch) {\n+        if (ch >= '1' && ch <='9')\n+            return (char)( ch - '1' + '\\u2460');\n+        if (ch == '0')\n+            return '\\u24ea';\n+        return ch;\n+    }\n+\n+    enum Result {\n+        PASSING, FAIL_LEFT, FAIL_RIGHT, FAIL_BOTH;\n+    }\n+\n+    \/**\n+     * Check to see if getBounds2D(..) is as big or larger than the precise bounds. If the left or right\n+     * edge comes in too small then this returns a failing Result.\n+     *\/\n+    private static Result getResult(CubicCurve2D curve, BigDecimal preciseLeft, BigDecimal preciseRight) {\n+        Rectangle2D r = getBounds2D(curve.getPathIterator(null));\n+\n+        BigDecimal observedLeftX = new BigDecimal(r.getMinX());\n+        BigDecimal observedRightX = new BigDecimal(r.getMaxX());\n+\n+        boolean badLeft = observedLeftX.compareTo(preciseLeft) > 0;\n+        boolean badRight = observedRightX.compareTo(preciseRight) < 0;\n+        if (badLeft && badRight)\n+            return Result.FAIL_BOTH;\n+        if (badLeft)\n+            return Result.FAIL_LEFT;\n+        if (badRight)\n+            return Result.FAIL_RIGHT;\n+        return Result.PASSING;\n+    }\n+\n+    private static int solveQuadratic(BigDecimal[] eqn, BigDecimal[] res) {\n+        BigDecimal a = eqn[2];\n+        BigDecimal b = eqn[1];\n+        BigDecimal c = eqn[0];\n+        int roots = 0;\n+        if (a.equals(BigDecimal.ZERO)) {\n+            \/\/ The quadratic parabola has degenerated to a line.\n+            if (b.equals(BigDecimal.ZERO)) {\n+                \/\/ The line has degenerated to a constant.\n+                return -1;\n+            }\n+            res[roots++] = c.negate().divide(b);\n+        } else {\n+            \/\/ From Numerical Recipes, 5.6, Quadratic and Cubic Equations\n+            BigDecimal d = b.multiply(b).add(new BigDecimal(-4.0).multiply(a).multiply(c));\n+            if (d.compareTo(BigDecimal.ZERO) < 0) {\n+                \/\/ If d < 0.0, then there are no roots\n+                return 0;\n+            }\n+            d = d.sqrt(MathContext.DECIMAL128);\n+            \/\/ For accuracy, calculate one root using:\n+            \/\/     (-b +\/- d) \/ 2a\n+            \/\/ and the other using:\n+            \/\/     2c \/ (-b +\/- d)\n+            \/\/ Choose the sign of the +\/- so that b+d gets larger in magnitude\n+            if (b.compareTo(BigDecimal.ZERO) < 0) {\n+                d = d.negate();\n+            }\n+            BigDecimal q = b.add(d).divide(new BigDecimal(-2.0));\n+            \/\/ We already tested a for being 0 above\n+            res[roots++] = q.divide(a, RoundingMode.HALF_EVEN);\n+            if (!q.equals(BigDecimal.ZERO)) {\n+                res[roots++] = c.divide(q, RoundingMode.HALF_EVEN);\n+            }\n+        }\n+        return roots;\n+    }\n+\n+    \/**\n+     * This is an adaptation of the existing Path2D.getBounds2D(PathIterator) draft that\n+     * expands bounding box by <code>double margin = marginMultiplier * Math.ulp(v);<\/code>\n+     *\/\n+    public static Rectangle2D getBounds2D(final PathIterator pi) {\n+        \/\/ define x and y parametric coefficients where:\n+        \/\/ x(t) = x_coeff[0] + x_coeff[1] * t + x_coeff[2] * t^2 + x_coeff[3] * t^3\n+        final double[] coeff = new double[4];\n+\n+        \/\/ define the derivative's coefficients\n+        final double[] deriv_coeff = new double[3];\n+\n+        final double[] coords = new double[6];\n+        final double[] tExtrema = new double[2];\n+        boolean isDefined = false;\n+        double leftX = 0.0;\n+        double rightX = 0.0;\n+        double topY = 0.0;\n+        double bottomY = 0.0;\n+        double lastX = 0.0;\n+        double lastY = 0.0;\n+\n+        for (; !pi.isDone(); pi.next()) {\n+            int type = pi.currentSegment(coords);\n+            switch (type) {\n+                case PathIterator.SEG_MOVETO:\n+                    if (!isDefined) {\n+                        isDefined = true;\n+                        leftX = rightX = coords[0];\n+                        topY = bottomY = coords[1];\n+                    } else {\n+                        if (coords[0] < leftX) leftX = coords[0];\n+                        if (coords[0] > rightX) rightX = coords[0];\n+                        if (coords[1] < topY) topY = coords[1];\n+                        if (coords[1] > bottomY) bottomY = coords[1];\n+                    }\n+                    lastX = coords[0];\n+                    lastY = coords[1];\n+                    break;\n+                case PathIterator.SEG_LINETO:\n+                    if (coords[0] < leftX) leftX = coords[0];\n+                    if (coords[0] > rightX) rightX = coords[0];\n+                    if (coords[1] < topY) topY = coords[1];\n+                    if (coords[1] > bottomY) bottomY = coords[1];\n+                    lastX = coords[0];\n+                    lastY = coords[1];\n+                    break;\n+                case PathIterator.SEG_QUADTO:\n+                    if (coords[2] < leftX) leftX = coords[2];\n+                    if (coords[2] > rightX) rightX = coords[2];\n+                    if (coords[3] < topY) topY = coords[3];\n+                    if (coords[3] > bottomY) bottomY = coords[3];\n+\n+                    if (coords[0] < leftX || coords[0] > rightX) {\n+                        final double dx21 = (coords[0] - lastX);\n+                        coeff[2] = (coords[2] - coords[0]) - dx21;  \/\/ A = P3 - P0 - 2 P2\n+                        coeff[1] = 2.0 * dx21;                      \/\/ B = 2 (P2 - P1)\n+                        coeff[0] = lastX;                           \/\/ C = P1\n+\n+                        coeff[2] = lastX - 2.0 * coords[0] + coords[2];\n+                        coeff[1] = -2.0 * lastX + 2.0 * coords[0];\n+                        coeff[0] = lastX;\n+\n+                        deriv_coeff[0] = coeff[1];\n+                        deriv_coeff[1] = 2.0 * coeff[2];\n+\n+                        double t = -deriv_coeff[0] \/ deriv_coeff[1];\n+                        if (t > 0.0 && t < 1.0) {\n+                            double x = coeff[0] + t * (coeff[1] + t * coeff[2]);\n+                            double margin = marginMultiplier * Math.ulp(x);\n+                            if (x - margin < leftX) leftX = x - margin;\n+                            if (x + margin> rightX) rightX = x + margin;\n+                        }\n+                    }\n+                    if (coords[1] < topY || coords[1] > bottomY) {\n+                        final double dy21 = (coords[1] - lastY);\n+                        coeff[2] = (coords[3] - coords[1]) - dy21;\n+                        coeff[1] = 2.0 * dy21;\n+                        coeff[0] = lastY;\n+\n+                        deriv_coeff[0] = coeff[1];\n+                        deriv_coeff[1] = 2.0 * coeff[2];\n+\n+                        double t = -deriv_coeff[0] \/ deriv_coeff[1];\n+                        if (t > 0.0 && t < 1.0) {\n+                            double y = coeff[0] + t * (coeff[1] + t * coeff[2]);\n+                            double margin = marginMultiplier * Math.ulp(y);\n+                            if (y - margin < topY) topY = y - margin;\n+                            if (y + margin > bottomY) bottomY = y + margin;\n+                        }\n+                    }\n+                    lastX = coords[2];\n+                    lastY = coords[3];\n+                    break;\n+                case PathIterator.SEG_CUBICTO:\n+                    if (coords[4] < leftX) leftX = coords[4];\n+                    if (coords[4] > rightX) rightX = coords[4];\n+                    if (coords[5] < topY) topY = coords[5];\n+                    if (coords[5] > bottomY) bottomY = coords[5];\n+\n+                    if (coords[0] < leftX || coords[0] > rightX || coords[2] < leftX || coords[2] > rightX) {\n+                        final double dx32 = 3.0 * (coords[2] - coords[0]);\n+                        final double dx21 = 3.0 * (coords[0] - lastX);\n+                        coeff[3] = (coords[4] - lastX) - dx32;  \/\/ A = P3 - P0 - 3 (P2 - P1) = (P3 - P0) + 3 (P1 - P2)\n+                        coeff[2] = (dx32 - dx21);               \/\/ B = 3 (P2 - P1) - 3(P1 - P0) = 3 (P2 + P0) - 6 P1\n+                        coeff[1] = dx21;                        \/\/ C = 3 (P1 - P0)\n+                        coeff[0] = lastX;                       \/\/ D = P0\n+\n+                        deriv_coeff[0] = coeff[1];\n+                        deriv_coeff[1] = 2.0 * coeff[2];\n+                        deriv_coeff[2] = 3.0 * coeff[3];\n+\n+                        int tExtremaCount = QuadCurve2D.solveQuadratic(deriv_coeff, tExtrema);\n+                        for (int i = 0; i < tExtremaCount; i++) {\n+                            double t = tExtrema[i];\n+                            if (t > 0.0 && t < 1.0) {\n+                                double x = coeff[0] + t * (coeff[1] + t * (coeff[2] + t * coeff[3]));\n+                                double margin = marginMultiplier * Math.ulp(x);\n+                                if (x - margin < leftX) leftX = x - margin;\n+                                if (x + margin > rightX) rightX = x + margin;\n+                            }\n+                        }\n+                    }\n+                    if (coords[1] < topY || coords[1] > bottomY || coords[3] < topY || coords[3] > bottomY) {\n+                        final double dy32 = 3.0 * (coords[3] - coords[1]);\n+                        final double dy21 = 3.0 * (coords[1] - lastY);\n+                        coeff[3] = (coords[5] - lastY) - dy32;\n+                        coeff[2] = (dy32 - dy21);\n+                        coeff[1] = dy21;\n+                        coeff[0] = lastY;\n+\n+                        deriv_coeff[0] = coeff[1];\n+                        deriv_coeff[1] = 2.0 * coeff[2];\n+                        deriv_coeff[2] = 3.0 * coeff[3];\n+\n+                        int tExtremaCount = QuadCurve2D.solveQuadratic(deriv_coeff, tExtrema);\n+                        for (int i = 0; i < tExtremaCount; i++) {\n+                            double t = tExtrema[i];\n+                            if (t > 0.0 && t < 1.0) {\n+                                double y = coeff[0] + t * (coeff[1] + t * (coeff[2] + t * coeff[3]));\n+                                double margin = marginMultiplier * Math.ulp(y);\n+                                if (y - margin < topY) topY = y - margin;\n+                                if (y + margin > bottomY) bottomY = y + margin;\n+                            }\n+                        }\n+                    }\n+                    lastX = coords[4];\n+                    lastY = coords[5];\n+                    break;\n+                case PathIterator.SEG_CLOSE:\n+                default:\n+                    continue;\n+            }\n+        }\n+        if (isDefined) {\n+            return new Rectangle2D.Double(leftX, topY, rightX - leftX, bottomY - topY);\n+        }\n+\n+        \/\/ there's room to debate what should happen here, but historically we return a zeroed\n+        \/\/ out rectangle here. So for backwards compatibility let's keep doing that:\n+        return new Rectangle2D.Double();\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/awt\/geom\/Path2D\/GetBounds2DPrecisionTest.java","additions":452,"deletions":0,"binary":false,"changes":452,"status":"added"}]}