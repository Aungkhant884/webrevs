{"files":[{"patch":"@@ -2103,2 +2103,0 @@\n-        \/\/ define x and y parametric coefficients where:\n-        \/\/ x(t) = x_coeff[0] + x_coeff[1] * t + x_coeff[2] * t^2 + x_coeff[3] * t^3\n@@ -2106,2 +2104,0 @@\n-\n-        \/\/ define the derivative's coefficients\n@@ -2111,6 +2107,1 @@\n-        final double[] tExtrema = new double[2];\n-        boolean isDefined = false;\n-        double leftX = 0.0;\n-        double rightX = 0.0;\n-        double topY = 0.0;\n-        double bottomY = 0.0;\n+        double[] bounds = null;\n@@ -2119,10 +2110,2 @@\n-\n-        \/\/ Whenever we have to examine cubic or quadratic extrema that change\n-        \/\/ our bounding box: we run the risk of machine error that may produce\n-        \/\/ a box that is slightly too small. But the contract of this method\n-        \/\/ says we should err on the side of being too large.\n-        \/\/ So to address this: we take the difference between the control\n-        \/\/ point and our calculated extrema, divide that difference by this\n-        \/\/ constant, and then nudge our extrema by that amount.\n-        \/\/ This will slightly expand the bounds to help overcome machine error.\n-        double marginDivisor = 1000000000.0;\n+        double endX = 0.0;\n+        double endY = 0.0;\n@@ -2131,1 +2114,1 @@\n-            int type = pi.currentSegment(coords);\n+            final int type = pi.currentSegment(coords);\n@@ -2134,9 +2117,2 @@\n-                    if (!isDefined) {\n-                        isDefined = true;\n-                        leftX = rightX = coords[0];\n-                        topY = bottomY = coords[1];\n-                    } else {\n-                        if (coords[0] < leftX) leftX = coords[0];\n-                        if (coords[0] > rightX) rightX = coords[0];\n-                        if (coords[1] < topY) topY = coords[1];\n-                        if (coords[1] > bottomY) bottomY = coords[1];\n+                    if (bounds == null) {\n+                        bounds = new double[] { coords[0], coords[1], coords[0], coords[1] };\n@@ -2144,2 +2120,2 @@\n-                    lastX = coords[0];\n-                    lastY = coords[1];\n+                    endX = coords[0];\n+                    endY = coords[1];\n@@ -2148,6 +2124,2 @@\n-                    if (coords[0] < leftX) leftX = coords[0];\n-                    if (coords[0] > rightX) rightX = coords[0];\n-                    if (coords[1] < topY) topY = coords[1];\n-                    if (coords[1] > bottomY) bottomY = coords[1];\n-                    lastX = coords[0];\n-                    lastY = coords[1];\n+                    endX = coords[0];\n+                    endY = coords[1];\n@@ -2156,51 +2128,2 @@\n-                    if (coords[2] < leftX) leftX = coords[2];\n-                    if (coords[2] > rightX) rightX = coords[2];\n-                    if (coords[3] < topY) topY = coords[3];\n-                    if (coords[3] > bottomY) bottomY = coords[3];\n-\n-                    if (coords[0] < leftX || coords[0] > rightX) {\n-                        final double dx21 = (coords[0] - lastX);\n-                        coeff[2] = (coords[2] - coords[0]) - dx21;  \/\/ A = P3 - P0 - 2 P2\n-                        coeff[1] = 2.0 * dx21;                      \/\/ B = 2 (P2 - P1)\n-                        coeff[0] = lastX;                           \/\/ C = P1\n-\n-                        deriv_coeff[0] = coeff[1];\n-                        deriv_coeff[1] = 2.0 * coeff[2];\n-\n-                        double t = -deriv_coeff[0] \/ deriv_coeff[1];\n-                        if (t > 0.0 && t < 1.0) {\n-                            double x = coeff[0] + t * (coeff[1] + t * coeff[2]);\n-                            if (x < leftX) {\n-                                double margin = (x - coords[0]) \/ marginDivisor;\n-                                leftX = x - margin;\n-                            }\n-                            if (x > rightX) {\n-                                double margin = (coords[0] - x) \/ marginDivisor;\n-                                rightX = x + margin;\n-                            }\n-                        }\n-                    }\n-                    if (coords[1] < topY || coords[1] > bottomY) {\n-                        final double dy21 = (coords[1] - lastY);\n-                        coeff[2] = (coords[3] - coords[1]) - dy21;\n-                        coeff[1] = 2.0 * dy21;\n-                        coeff[0] = lastY;\n-\n-                        deriv_coeff[0] = coeff[1];\n-                        deriv_coeff[1] = 2.0 * coeff[2];\n-\n-                        double t = -deriv_coeff[0] \/ deriv_coeff[1];\n-                        if (t > 0.0 && t < 1.0) {\n-                            double y = coeff[0] + t * (coeff[1] + t * coeff[2]);\n-                            if (y < topY) {\n-                                double margin = (y - coords[1]) \/ marginDivisor;\n-                                topY = y - margin;\n-                            }\n-                            if (y > bottomY) {\n-                                double margin = (coords[1] - y) \/ marginDivisor;\n-                                bottomY = y + margin;\n-                            }\n-                        }\n-                    }\n-                    lastX = coords[2];\n-                    lastY = coords[3];\n+                    endX = coords[2];\n+                    endY = coords[3];\n@@ -2209,83 +2132,2 @@\n-                    if (coords[4] < leftX) leftX = coords[4];\n-                    if (coords[4] > rightX) rightX = coords[4];\n-                    if (coords[5] < topY) topY = coords[5];\n-                    if (coords[5] > bottomY) bottomY = coords[5];\n-\n-                    if (coords[0] < leftX || coords[0] > rightX || coords[2] < leftX || coords[2] > rightX) {\n-                        final double dx32 = 3.0 * (coords[2] - coords[0]);\n-                        final double dx21 = 3.0 * (coords[0] - lastX);\n-                        coeff[3] = (coords[4] - lastX) - dx32;  \/\/ A = P3 - P0 - 3 (P2 - P1) = (P3 - P0) + 3 (P1 - P2)\n-                        coeff[2] = (dx32 - dx21);               \/\/ B = 3 (P2 - P1) - 3(P1 - P0) = 3 (P2 + P0) - 6 P1\n-                        coeff[1] = dx21;                        \/\/ C = 3 (P1 - P0)\n-                        coeff[0] = lastX;                       \/\/ D = P0\n-\n-                        deriv_coeff[0] = coeff[1];\n-                        deriv_coeff[1] = 2.0 * coeff[2];\n-                        deriv_coeff[2] = 3.0 * coeff[3];\n-\n-                        int tExtremaCount = QuadCurve2D.solveQuadratic(deriv_coeff, tExtrema);\n-                        for (int i = 0; i < tExtremaCount; i++) {\n-                            double t = tExtrema[i];\n-                            if (t > 0.0 && t < 1.0) {\n-                                double x = coeff[0] + t * (coeff[1] + t * (coeff[2] + t * coeff[3]));\n-                                if (x < leftX) {\n-                                    double margin;\n-                                    if (coords[0] < coords[2]) {\n-                                        margin = (x - coords[0]) \/ marginDivisor;\n-                                    } else {\n-                                        margin = (x - coords[2]) \/ marginDivisor;\n-                                    }\n-                                    leftX = x - margin;\n-                                }\n-                                if (x > rightX) {\n-                                    double margin;\n-                                    if (coords[0] > coords[2]) {\n-                                        margin = (coords[0] - x) \/ marginDivisor;\n-                                    } else {\n-                                        margin = (coords[2] - x) \/ marginDivisor;\n-                                    }\n-                                    rightX = x + margin;\n-                                }\n-                            }\n-                        }\n-                    }\n-                    if (coords[1] < topY || coords[1] > bottomY || coords[3] < topY || coords[3] > bottomY) {\n-                        final double dy32 = 3.0 * (coords[3] - coords[1]);\n-                        final double dy21 = 3.0 * (coords[1] - lastY);\n-                        coeff[3] = (coords[5] - lastY) - dy32;\n-                        coeff[2] = (dy32 - dy21);\n-                        coeff[1] = dy21;\n-                        coeff[0] = lastY;\n-\n-                        deriv_coeff[0] = coeff[1];\n-                        deriv_coeff[1] = 2.0 * coeff[2];\n-                        deriv_coeff[2] = 3.0 * coeff[3];\n-\n-                        int tExtremaCount = QuadCurve2D.solveQuadratic(deriv_coeff, tExtrema);\n-                        for (int i = 0; i < tExtremaCount; i++) {\n-                            double t = tExtrema[i];\n-                            if (t > 0.0 && t < 1.0) {\n-                                double y = coeff[0] + t * (coeff[1] + t * (coeff[2] + t * coeff[3]));\n-                                if (y < topY) {\n-                                    double margin;\n-                                    if (coords[1] < coords[3]) {\n-                                        margin = (y - coords[1]) \/ marginDivisor;\n-                                    } else {\n-                                        margin = (y - coords[3]) \/ marginDivisor;\n-                                    }\n-                                    topY = y - margin;\n-                                }\n-                                if (y > bottomY) {\n-                                    double margin;\n-                                    if (coords[1] > coords[3]) {\n-                                        margin = (coords[1] - y) \/ marginDivisor;\n-                                    } else {\n-                                        margin = (coords[3] - y) \/ marginDivisor;\n-                                    }\n-                                    bottomY = y + margin;\n-                                }\n-                            }\n-                        }\n-                    }\n-                    lastX = coords[4];\n-                    lastY = coords[5];\n+                    endX = coords[4];\n+                    endY = coords[5];\n@@ -2297,0 +2139,19 @@\n+\n+            if (endX < bounds[0]) bounds[0] = endX;\n+            if (endX > bounds[2]) bounds[2] = endX;\n+            if (endY < bounds[1]) bounds[1] = endY;\n+            if (endY > bounds[3]) bounds[3] = endY;\n+\n+            switch (type) {\n+                case PathIterator.SEG_QUADTO:\n+                    Curve.accumulateExtremaBoundsForQuad(bounds, lastX, lastY, coords, coeff, deriv_coeff);\n+                    break;\n+                case PathIterator.SEG_CUBICTO:\n+                    Curve.accumulateExtremaBoundsForCubic(bounds, lastX, lastY, coords, coeff, deriv_coeff);\n+                    break;\n+                default:\n+                    \/\/ intentionally empty\n+            }\n+\n+            lastX = endX;\n+            lastY = endY;\n@@ -2298,2 +2159,2 @@\n-        if (isDefined) {\n-            return new Rectangle2D.Double(leftX, topY, rightX - leftX, bottomY - topY);\n+        if (bounds != null) {\n+            return new Rectangle2D.Double(bounds[0], bounds[1], bounds[2] - bounds[0], bounds[3] - bounds[1]);\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/geom\/Path2D.java","additions":35,"deletions":174,"binary":false,"changes":209,"status":"modified"},{"patch":"@@ -715,0 +715,123 @@\n+    \/**\n+     * Accumulate the quadratic extrema into the pre-existing bounding box.\n+     * <p>\n+     * Whenever we have to examine cubic or quadratic extrema that change our bounding\n+     * box: we run the risk of machine error that may produce a box that is slightly\n+     * too small. But the contract of {@link Shape#getBounds2D()} says we should err\n+     * on the side of being too large. So to address this: we'll apply a margin based\n+     * on the upper limit of numerical error caused by the polynomial evaluation (horner\n+     * scheme).\n+     * <\/p>\n+     *\n+     * @param bounds the bounds to update, which are expressed as: { left_x, top_y, right_x, bottom_y }\n+     * @param startX the initial x value of the bezier quadratic curve\n+     * @param startY the initial y value of the bezier quadratic curve\n+     * @param coords the two (x,y) coordinates returned by {@link PathIterator#currentSegment(double[])}\n+     * @param coeff an array of at least 3 elements that will be overwritten and reused\n+     * @param deriv_coeff an array of at least 2 elements that will be overwritten and reused\n+     *\/\n+    public static void accumulateExtremaBoundsForQuad(double[] bounds, double startX, double startY, double[] coords, double[] coeff, double[] deriv_coeff) {\n+        \/\/ when arrayOffset = 0 we look at x values; when arrayOffset = 1 we look at y values\n+        for(int arrayOffset = 0; arrayOffset < 2; arrayOffset++) {\n+            if (coords[0 + arrayOffset] < bounds[0 + arrayOffset] ||\n+                    coords[0 + arrayOffset] > bounds[2 + arrayOffset]) {\n+                final double start = arrayOffset == 0 ? startX : startY;\n+                final double ctrl = coords[0 + arrayOffset];\n+                final double end = coords[2 + arrayOffset];\n+\n+                final double dx21 = ctrl - start;\n+                coeff[2] = (end - ctrl) - dx21;  \/\/ A = P3 - P0 - 2 P2\n+                coeff[1] = 2.0 * dx21;           \/\/ B = 2 (P2 - P1)\n+                coeff[0] = start;                \/\/ C = P1\n+\n+                deriv_coeff[0] = coeff[1];\n+                deriv_coeff[1] = 2.0 * coeff[2];\n+\n+                final double t = -deriv_coeff[0] \/ deriv_coeff[1];\n+                if (t > 0.0 && t < 1.0) {\n+                    final double v = coeff[0] + t * (coeff[1] + t * coeff[2]);\n+\n+                    \/\/ error condition = sum ( abs (coeff) ):\n+                    final double margin = Math.ulp(Math.abs(coeff[0])\n+                            + Math.abs(coeff[1]) + Math.abs(coeff[2]));\n+\n+                    if (v - margin < bounds[0 + arrayOffset]) {\n+                        bounds[0 + arrayOffset] = v - margin;\n+                    }\n+                    if (v + margin > bounds[2 + arrayOffset]) {\n+                        bounds[2 + arrayOffset] = v + margin;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Accumulate the cubic extrema into the pre-existing bounding box.\n+     * <p>\n+     * Whenever we have to examine cubic or quadratic extrema that change our bounding\n+     * box: we run the risk of machine error that may produce a box that is slightly\n+     * too small. But the contract of {@link Shape#getBounds2D()} says we should err\n+     * on the side of being too large. So to address this: we'll apply a margin based\n+     * on the upper limit of numerical error caused by the polynomial evaluation (horner\n+     * scheme).\n+     * <\/p>\n+     *\n+     * @param bounds the bounds to update, which are expressed as: { left_x, top_y, right_x, bottom_y }\n+     * @param startX the initial x value of the bezier cubic curve\n+     * @param startY the initial y value of the bezier cubic curve\n+     * @param coords the three (x,y) coordinates returned by {@link PathIterator#currentSegment(double[])}\n+     * @param coeff an array of at least 4 elements that will be overwritten and reused\n+     * @param deriv_coeff an array of at least 3 elements that will be overwritten and reused\n+     *\/\n+    public static void accumulateExtremaBoundsForCubic(double[] bounds, double startX, double startY, double[] coords, double[] coeff, double[] deriv_coeff) {\n+        \/\/ when arrayOffset = 0 we look at x values; when arrayOffset = 1 we look at y values\n+        for (int arrayOffset = 0; arrayOffset < 2; arrayOffset++) {\n+            if (coords[arrayOffset] < bounds[0 + arrayOffset] ||\n+                    coords[arrayOffset] > bounds[2 + arrayOffset] ||\n+                    coords[2 + arrayOffset] < bounds[0 + arrayOffset] ||\n+                    coords[2 + arrayOffset] > bounds[2 + arrayOffset]) {\n+                final double start = arrayOffset == 0 ? startX : startY;\n+                final double ctrl1 = coords[0 + arrayOffset];\n+                final double ctrl2 = coords[2 + arrayOffset];\n+                final double end = coords[4 + arrayOffset];\n+\n+                final double dx32 = 3.0 * (ctrl2 - ctrl1);\n+                final double dx21 = 3.0 * (ctrl1 - start);\n+                coeff[3] = (end - start) - dx32;  \/\/ A = P3 - P0 - 3 (P2 - P1) = (P3 - P0) + 3 (P1 - P2)\n+                coeff[2] = (dx32 - dx21);         \/\/ B = 3 (P2 - P1) - 3(P1 - P0) = 3 (P2 + P0) - 6 P1\n+                coeff[1] = dx21;                  \/\/ C = 3 (P1 - P0)\n+                coeff[0] = start;                 \/\/ D = P0\n+\n+                deriv_coeff[0] = coeff[1];\n+                deriv_coeff[1] = 2.0 * coeff[2];\n+                deriv_coeff[2] = 3.0 * coeff[3];\n+\n+                \/\/ reuse this array, give it a new name for readability:\n+                final double[] tExtrema = deriv_coeff;\n+\n+                \/\/ solveQuadratic should be improved to get correct t extrema (1 ulp):\n+                final int tExtremaCount = QuadCurve2D.solveQuadratic(deriv_coeff, tExtrema);\n+                if (tExtremaCount > 0) {\n+                    \/\/ error condition = sum ( abs (coeff) ):\n+                    final double margin = Math.ulp(Math.abs(coeff[0])\n+                            + Math.abs(coeff[1]) + Math.abs(coeff[2])\n+                            + Math.abs(coeff[3]));\n+\n+                    for (int i = 0; i < tExtremaCount; i++) {\n+                        final double t = tExtrema[i];\n+                        if (t > 0.0 && t < 1.0) {\n+                            final double v = coeff[0] + t * (coeff[1] + t * (coeff[2] + t * coeff[3]));\n+                            if (v - margin < bounds[0 + arrayOffset]) {\n+                                bounds[0 + arrayOffset] = v - margin;\n+                            }\n+                            if (v + margin > bounds[2 + arrayOffset]) {\n+                                bounds[2 + arrayOffset] = v + margin;\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/geom\/Curve.java","additions":123,"deletions":0,"binary":false,"changes":123,"status":"modified"}]}