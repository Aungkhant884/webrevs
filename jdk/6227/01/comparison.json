{"files":[{"patch":"@@ -314,17 +314,0 @@\n-        \/**\n-         * {@inheritDoc}\n-         * @since 1.2\n-         *\/\n-        public Rectangle2D getBounds2D() {\n-            float left   = Math.min(Math.min(x1, x2),\n-                                    Math.min(ctrlx1, ctrlx2));\n-            float top    = Math.min(Math.min(y1, y2),\n-                                    Math.min(ctrly1, ctrly2));\n-            float right  = Math.max(Math.max(x1, x2),\n-                                    Math.max(ctrlx1, ctrlx2));\n-            float bottom = Math.max(Math.max(y1, y2),\n-                                    Math.max(ctrly1, ctrly2));\n-            return new Rectangle2D.Float(left, top,\n-                                         right - left, bottom - top);\n-        }\n-\n@@ -561,17 +544,0 @@\n-        \/**\n-         * {@inheritDoc}\n-         * @since 1.2\n-         *\/\n-        public Rectangle2D getBounds2D() {\n-            double left   = Math.min(Math.min(x1, x2),\n-                                     Math.min(ctrlx1, ctrlx2));\n-            double top    = Math.min(Math.min(y1, y2),\n-                                     Math.min(ctrly1, ctrly2));\n-            double right  = Math.max(Math.max(x1, x2),\n-                                     Math.max(ctrlx1, ctrlx2));\n-            double bottom = Math.max(Math.max(y1, y2),\n-                                     Math.max(ctrly1, ctrly2));\n-            return new Rectangle2D.Double(left, top,\n-                                          right - left, bottom - top);\n-        }\n-\n@@ -1512,0 +1478,9 @@\n+\n+    \/**\n+     * {@inheritDoc}\n+     * @since 1.2\n+     *\/\n+    public Rectangle2D getBounds2D() {\n+        return Path2D.getBounds2D(getPathIterator(null));\n+    }\n+\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/geom\/CubicCurve2D.java","additions":9,"deletions":34,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -798,24 +798,0 @@\n-        \/**\n-         * {@inheritDoc}\n-         * @since 1.6\n-         *\/\n-        public final synchronized Rectangle2D getBounds2D() {\n-            float x1, y1, x2, y2;\n-            int i = numCoords;\n-            if (i > 0) {\n-                y1 = y2 = floatCoords[--i];\n-                x1 = x2 = floatCoords[--i];\n-                while (i > 0) {\n-                    float y = floatCoords[--i];\n-                    float x = floatCoords[--i];\n-                    if (x < x1) x1 = x;\n-                    if (y < y1) y1 = y;\n-                    if (x > x2) x2 = x;\n-                    if (y > y2) y2 = y;\n-                }\n-            } else {\n-                x1 = y1 = x2 = y2 = 0.0f;\n-            }\n-            return new Rectangle2D.Float(x1, y1, x2 - x1, y2 - y1);\n-        }\n-\n@@ -1590,24 +1566,0 @@\n-        \/**\n-         * {@inheritDoc}\n-         * @since 1.6\n-         *\/\n-        public final synchronized Rectangle2D getBounds2D() {\n-            double x1, y1, x2, y2;\n-            int i = numCoords;\n-            if (i > 0) {\n-                y1 = y2 = doubleCoords[--i];\n-                x1 = x2 = doubleCoords[--i];\n-                while (i > 0) {\n-                    double y = doubleCoords[--i];\n-                    double x = doubleCoords[--i];\n-                    if (x < x1) x1 = x;\n-                    if (y < y1) y1 = y;\n-                    if (x > x2) x2 = x;\n-                    if (y > y2) y2 = y;\n-                }\n-            } else {\n-                x1 = y1 = x2 = y2 = 0.0;\n-            }\n-            return new Rectangle2D.Double(x1, y1, x2 - x1, y2 - y1);\n-        }\n-\n@@ -2132,0 +2084,134 @@\n+    \/**\n+     * {@inheritDoc}\n+     * @since 1.6\n+     *\/\n+    public Rectangle2D getBounds2D() {\n+        return getBounds2D(getPathIterator(null));\n+    }\n+\n+    \/**\n+     * Returns a high precision bounding box of the specified PathIterator.\n+     * <p>\n+     * This method provides a basic facility for implementors of the {@link Shape} interface to\n+     * implement support for the {@link Shape#getBounds2D()} method.\n+     * <\/p>\n+     * @return an instance of {@code Rectangle2D} that is a high-precision bounding box of the\n+     *         {@code PathIterator}.\n+     * @see Shape#getBounds2D()\n+     *\/\n+    public static Rectangle2D getBounds2D(PathIterator pi) {\n+        \/\/ define x and y parametric coefficients where:\n+        \/\/ x(t) = x_coeff[0] + x_coeff[1] * t + x_coeff[2] * t^2 + x_coeff[3] * t^3\n+        double[] x_coeff = new double[4];\n+        double[] y_coeff = new double[4];\n+\n+        double[] coords = new double[6];\n+        double[] tExtrema = new double[3];\n+        boolean isEmpty = true;\n+        double leftX = 0.0;\n+        double rightX = 0.0;\n+        double topY = 0.0;\n+        double bottomY = 0.0;\n+        double lastX = 0.0;\n+        double lastY = 0.0;\n+\n+        pathIteratorLoop : while (!pi.isDone()) {\n+            int type = pi.currentSegment(coords);\n+            pi.next();\n+            double endX, endY;\n+            switch (type) {\n+                case PathIterator.SEG_MOVETO, PathIterator.SEG_LINETO:\n+                    endX = coords[0];\n+                    endY = coords[1];\n+                    break;\n+                case PathIterator.SEG_QUADTO:\n+                    endX = coords[2];\n+                    endY = coords[3];\n+                    break;\n+                case PathIterator.SEG_CUBICTO:\n+                    endX = coords[4];\n+                    endY = coords[5];\n+                    break;\n+                default:\n+                    continue pathIteratorLoop;\n+            }\n+\n+            if (isEmpty) {\n+                \/\/ we're seeding our bounds for the first time:\n+                isEmpty = false;\n+                leftX = rightX = endX;\n+                topY = bottomY = endY;\n+            } else {\n+                \/\/ extend our rectangle to cover the point at t = 1:\n+                leftX = (endX < leftX) ? endX : leftX;\n+                rightX = (endX > rightX) ? endX : rightX;\n+                topY = (endY < topY) ? endY : topY;\n+                bottomY = (endY > bottomY) ? endY : bottomY;\n+            }\n+\n+            \/\/ here's the slightly trickier part: examine quadratic and cubic\n+            \/\/ segments for extrema where t is between (0, 1):\n+\n+            boolean definedParametricEquations;\n+            if (type == PathIterator.SEG_QUADTO) {\n+                definedParametricEquations = true;\n+\n+                x_coeff[3] = 0.0;\n+                x_coeff[2] = lastX - 2.0 * coords[0] + coords[2];\n+                x_coeff[1] = -2.0 * lastX + 2.0 * coords[0];\n+                x_coeff[0] = lastX;\n+\n+                y_coeff[3] = 0;\n+                y_coeff[2] = lastY - 2.0 * coords[1] + coords[3];\n+                y_coeff[1] = -2.0 * lastY + 2.0 * coords[1];\n+                y_coeff[0] = lastY;\n+            } else if (type == PathIterator.SEG_CUBICTO) {\n+                definedParametricEquations = true;\n+\n+                x_coeff[3] = -lastX + 3.0 * coords[0] - 3.0 * coords[2] + coords[4];\n+                x_coeff[2] = 3.0 * lastX - 6.0 * coords[0] + 3.0 * coords[2];\n+                x_coeff[1] = -3.0 * lastX + 3.0 * coords[0];\n+                x_coeff[0] = lastX;\n+\n+                y_coeff[3] = -lastY + 3.0 * coords[1] - 3.0 * coords[3] + coords[5];\n+                y_coeff[2] = 3.0 * lastY - 6.0 * coords[1] + 3.0 * coords[3];\n+                y_coeff[1] = -3.0 * lastY + 3.0 * coords[1];\n+                y_coeff[0] = lastY;\n+            } else {\n+                definedParametricEquations = false;\n+            }\n+\n+            if (definedParametricEquations) {\n+                int tExtremaCount = Curve.findExtrema(x_coeff, tExtrema);\n+                for(int i = 0; i < tExtremaCount; i++) {\n+                    double t = tExtrema[i];\n+                    if (t > 0 && t < 1) {\n+                        double x = x_coeff[0] + t * (x_coeff[1] + t * (x_coeff[2] + t * x_coeff[3]));\n+                        leftX = (x < leftX) ? x : leftX;\n+                        rightX = (x > rightX) ? x : rightX;\n+                    }\n+                }\n+\n+                tExtremaCount = Curve.findExtrema(y_coeff, tExtrema);\n+                for(int i = 0; i < tExtremaCount; i++) {\n+                    double t = tExtrema[i];\n+                    if (t > 0 && t < 1) {\n+                        double y = y_coeff[0] + t * (y_coeff[1] + t * (y_coeff[2] + t * y_coeff[3]));\n+                        topY = (y < topY) ? y : topY;\n+                        bottomY = (y > bottomY) ? y : bottomY;\n+                    }\n+                }\n+            }\n+\n+            lastX = endX;\n+            lastY = endY;\n+        }\n+        if (!isEmpty) {\n+            return new Rectangle2D.Double(leftX, topY, rightX - leftX, bottomY - topY);\n+        }\n+\n+        \/\/ there's room to debate what should happen here, but historically we return a zeroed\n+        \/\/ out rectangle here. So for backwards compatibility let's keep doing that:\n+        return new Rectangle2D.Double();\n+    }\n+\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/geom\/Path2D.java","additions":134,"deletions":48,"binary":false,"changes":182,"status":"modified"},{"patch":"@@ -241,13 +241,0 @@\n-        \/**\n-         * {@inheritDoc}\n-         * @since 1.2\n-         *\/\n-        public Rectangle2D getBounds2D() {\n-            float left   = Math.min(Math.min(x1, x2), ctrlx);\n-            float top    = Math.min(Math.min(y1, y2), ctrly);\n-            float right  = Math.max(Math.max(x1, x2), ctrlx);\n-            float bottom = Math.max(Math.max(y1, y2), ctrly);\n-            return new Rectangle2D.Float(left, top,\n-                                         right - left, bottom - top);\n-        }\n-\n@@ -431,13 +418,0 @@\n-        \/**\n-         * {@inheritDoc}\n-         * @since 1.2\n-         *\/\n-        public Rectangle2D getBounds2D() {\n-            double left   = Math.min(Math.min(x1, x2), ctrlx);\n-            double top    = Math.min(Math.min(y1, y2), ctrly);\n-            double right  = Math.max(Math.max(x1, x2), ctrlx);\n-            double bottom = Math.max(Math.max(y1, y2), ctrly);\n-            return new Rectangle2D.Double(left, top,\n-                                          right - left, bottom - top);\n-        }\n-\n@@ -1338,0 +1312,8 @@\n+    \/**\n+     * {@inheritDoc}\n+     * @since 1.2\n+     *\/\n+    public Rectangle2D getBounds2D() {\n+        return Path2D.getBounds2D(getPathIterator(null));\n+    }\n+\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/geom\/QuadCurve2D.java","additions":8,"deletions":26,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -715,0 +715,66 @@\n+    \/**\n+     * Return the t values that correspond to possible extrema in a given cubic function.\n+     * <p>\n+     * If the coefficient of the t^3 is large then the polynomial is a cubic and up to\n+     * two values may be returned. If that coefficient is zero then the polynomial\n+     * is a quadratic and up to one value may be returned. But if that coefficient is\n+     * small then this method considers the possibility it could be either, so in that\n+     * scenario this method may return up to three values. For ex: if the leading\n+     * coefficient is .000001 that might be because the polynomial really is a cubic, or\n+     * it might be because of rounding error and the polynomial is basically a quadratic.\n+     * <\/p>\n+     *\n+     * @param coefficients four coefficients for a cubic polynomial equation. The nth element in this array is\n+     *                     the coefficient for (t^n).\n+     * @param dest an array to store the t values in. This must be at least 3 elements.\n+     * @return the number of t-values that were stored in dest. This will be between 0-3.\n+     *\/\n+    public static int findExtrema(double[] coefficients, double[] dest) {\n+\n+        int returnValue = 0;\n+\n+        if (coefficients[3] != 0.0) {\n+            \/\/ evaluate this as a cubic, where:\n+\n+            \/\/ f(t) = c[3] * t^3 + c[2] * t^2 + c[1] * t + c[0]\n+            \/\/ df\/dt = 3 * c[3] * t^2 + 2 * c[2] * t + c[1]\n+\n+            \/\/ so we have a quadratic polynomial:\n+            \/\/ df\/dt = A * t^2 + B * t + C\n+\n+            \/\/ ... where:\n+            \/\/ A = 3 * c[3]\n+            \/\/ B = 2 * c[2]\n+            \/\/ C = c[1]\n+\n+            double[] eqn = new double[]{ coefficients[1],\n+                    2.0 * coefficients[2],\n+                    3.0 * coefficients[3] };\n+            returnValue = QuadCurve2D.solveQuadratic(eqn, dest);\n+\n+            if (returnValue < 0.0)\n+                returnValue = 0;\n+        }\n+\n+        if (coefficients[3] > -.01 && coefficients[3] < .01 && coefficients[2] != 0.0) {\n+            \/\/ evaluate this as if it's a quadratic, where:\n+\n+            \/\/ f = c[2] * t^2 + c[1] * t + c[0]\n+\n+            \/\/ this only really makes sense if coefficients[3] is close to zero.\n+            \/\/ We chose \"less than .01\" as the threshold for \"close to zero\". It's\n+            \/\/ a very generous threshold, but it should be harmless to err on the\n+            \/\/ side of a generously high threshold in this case. The worst-case\n+            \/\/ scenario is: we return an extra t-value that isn't really an extrema.\n+\n+            \/\/ df\/dt = 2 * c[2] * t + c[1]\n+\n+            \/\/ so our only extrema is at:\n+            \/\/ t = -c[1] \/ (2*c[2])\n+\n+            double t = -coefficients[1] \/ (2.0 * coefficients[2]);\n+            dest[returnValue++] = t;\n+        }\n+        return returnValue;\n+    }\n+\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/geom\/Curve.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 4172661\n+ * @bug 4172661 8176501\n@@ -135,0 +135,10 @@\n+            makeJDK8176501(),\n+\n+            \/\/ this shape has a special property: some coefficients to the t^3 term\n+            \/\/ are *nearly* zero. And analytically they should be zero, but machine\n+            \/\/ error prevented it. In these cases cubic polynomials should degenerate\n+            \/\/ into quadratic polynomials, but because the coefficient is not exactly\n+            \/\/ zero that may not always be handled correctly:\n+            AffineTransform.getRotateInstance(Math.PI \/ 4).createTransformedShape(\n+                    new Ellipse2D.Float(0, 0, 100, 100))\n+\n@@ -196,0 +206,14 @@\n+    \/**\n+     * JDK-8176501 focused on a shape whose bounds included a lot of dead space.\n+     * This recreates that shape, and the unit test testGetBounds2D checks the\n+     * accuracy of {@link Shape#getBounds2D()}\n+     *\/\n+    public static Path2D makeJDK8176501() {\n+        Path2D.Double path = new Path2D.Double();\n+        path.moveTo(40, 140);\n+        path.curveTo(40, 60, 160, 60, 160, 140);\n+        path.curveTo(160, 220, 40, 220, 40, 140);\n+        path.closePath();\n+        return path;\n+    }\n+\n@@ -541,22 +565,0 @@\n-        private Rectangle2D cachedBounds;\n-        public Rectangle2D getCachedBounds2D() {\n-            if (cachedBounds == null) {\n-                double xmin, ymin, xmax, ymax;\n-                int ci = 0;\n-                xmin = xmax = theCoords[ci++];\n-                ymin = ymax = theCoords[ci++];\n-                while (ci < numCoords) {\n-                    double c = theCoords[ci++];\n-                    if (xmin > c) xmin = c;\n-                    if (xmax < c) xmax = c;\n-                    c = theCoords[ci++];\n-                    if (ymin > c) ymin = c;\n-                    if (ymax < c) ymax = c;\n-                }\n-                cachedBounds = new Rectangle2D.Double(xmin, ymin,\n-                                                      xmax - xmin,\n-                                                      ymax - ymin);\n-            }\n-            return cachedBounds;\n-        }\n-\n@@ -564,1 +566,1 @@\n-            return getCachedBounds2D().getBounds();\n+            return getBounds2D().getBounds();\n@@ -567,1 +569,1 @@\n-            return getCachedBounds2D().getBounds2D();\n+            return getTestShape().getBounds2D();\n@@ -1300,0 +1302,1 @@\n+            testGetBounds2D(stest);\n@@ -1315,0 +1318,87 @@\n+    \/**\n+     * Make sure the {@link Shape#getBounds2D()} returns a Rectangle2D that tightly fits the\n+     * shape data. It shouldn't contain lots of dead space (see JDK 8176501), and it shouldn't\n+     * leave out any shape path. This test relies on the accuracy of\n+     * {@link Shape#intersects(double, double, double, double)}\n+     *\/\n+    public static void testGetBounds2D(Shape shape) {\n+        \/\/ first: make sure the shape is actually close to the perimeter of shape.getBounds2D().\n+        \/\/ this is the crux of JDK 8176501:\n+\n+        Rectangle2D r = shape.getBounds2D();\n+\n+        if (r.getWidth() == 0 || r.getHeight() == 0) {\n+            \/\/ this can happen for completely empty paths, which are part of our\n+            \/\/ edge test cases in this class.\n+            return;\n+        }\n+\n+        if (verbose) System.out.println(\"testGetBounds2D \"+shape+\", \"+r);\n+\n+        double xminInterior = r.getMinX() + .000001;\n+        double yminInterior = r.getMinY() + .000001;\n+        double xmaxInterior = r.getMaxX() - .000001;\n+        double ymaxInterior = r.getMaxY() - .000001;\n+\n+        Rectangle2D topStrip = new Rectangle2D.Double(r.getMinX(), r.getMinY(), r.getWidth(), yminInterior - r.getMinY());\n+        Rectangle2D leftStrip = new Rectangle2D.Double(r.getMinX(), r.getMinY(), xminInterior - r.getMinX(), r.getHeight());\n+        Rectangle2D bottomStrip = new Rectangle2D.Double(r.getMinX(), ymaxInterior, r.getWidth(), r.getMaxY() - ymaxInterior);\n+        Rectangle2D rightStrip = new Rectangle2D.Double(xmaxInterior, r.getMinY(), r.getMaxX() - xmaxInterior, r.getHeight());\n+        if (!shape.intersects(topStrip)) {\n+            if (verbose)\n+                System.out.println(\"topStrip = \"+topStrip);\n+            throw new RuntimeException(\"the shape must intersect the top strip of its bounds\");\n+        }\n+        if (!shape.intersects(leftStrip)) {\n+            if (verbose)\n+                System.out.println(\"leftStrip = \" + leftStrip);\n+            throw new RuntimeException(\"the shape must intersect the left strip of its bounds\");\n+        }\n+        if (!shape.intersects(bottomStrip)) {\n+            if (verbose)\n+                System.out.println(\"bottomStrip = \" + bottomStrip);\n+            throw new RuntimeException(\"the shape must intersect the bottom strip of its bounds\");\n+        }\n+        if (!shape.intersects(rightStrip)) {\n+            if (verbose)\n+                System.out.println(\"rightStrip = \" + rightStrip);\n+            throw new RuntimeException(\"the shape must intersect the right strip of bounds\");\n+        }\n+\n+        \/\/ Similarly: make sure our shape doesn't exist OUTSIDE of r, either. To my knowledge this has never\n+        \/\/ been a problem, but if it did happen this would be an even more serious breach of contract than\n+        \/\/ the former case.\n+\n+        double xminExterior = r.getMinX() - .000001;\n+        double yminExterior = r.getMinY() - .000001;\n+        double xmaxExterior = r.getMaxX() + .000001;\n+        double ymaxExterior = r.getMaxY() + .000001;\n+\n+        \/\/ k is simply meant to mean \"a large number, functionally similar to infinity for this test\"\n+        double k = 10000.0;\n+        leftStrip = new Rectangle2D.Double(xminExterior - k, -k, k, 3 * k);\n+        rightStrip = new Rectangle2D.Double(xmaxExterior, -k, k, 3 * k);\n+        topStrip = new Rectangle2D.Double(-k, yminExterior - k, 3 * k, k);\n+        bottomStrip = new Rectangle2D.Double(-k, ymaxExterior, 3 * k, k);\n+        if (shape.intersects(leftStrip)) {\n+            if (verbose)\n+                System.out.println(\"leftStrip = \" + leftStrip);\n+            throw new RuntimeException(\"the shape must not intersect anything to the left of its bounds\");\n+        }\n+        if (shape.intersects(rightStrip)) {\n+            if (verbose)\n+                System.out.println(\"rightStrip = \" + rightStrip);\n+            throw new RuntimeException(\"the shape must not intersect anything to the right of its bounds\");\n+        }\n+        if (shape.intersects(topStrip)) {\n+            if (verbose)\n+                System.out.println(\"topStrip = \" + topStrip);\n+            throw new RuntimeException(\"the shape must not intersect anything above its bounds\");\n+        }\n+        if (shape.intersects(bottomStrip)) {\n+            if (verbose)\n+                System.out.println(\"bottomStrip = \" + bottomStrip);\n+            throw new RuntimeException(\"the shape must not intersect anything below its bounds\");\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/awt\/geom\/Path2D\/UnitTest.java","additions":115,"deletions":25,"binary":false,"changes":140,"status":"modified"}]}