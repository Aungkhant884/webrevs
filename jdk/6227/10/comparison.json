{"files":[{"patch":"@@ -314,17 +314,0 @@\n-        \/**\n-         * {@inheritDoc}\n-         * @since 1.2\n-         *\/\n-        public Rectangle2D getBounds2D() {\n-            float left   = Math.min(Math.min(x1, x2),\n-                                    Math.min(ctrlx1, ctrlx2));\n-            float top    = Math.min(Math.min(y1, y2),\n-                                    Math.min(ctrly1, ctrly2));\n-            float right  = Math.max(Math.max(x1, x2),\n-                                    Math.max(ctrlx1, ctrlx2));\n-            float bottom = Math.max(Math.max(y1, y2),\n-                                    Math.max(ctrly1, ctrly2));\n-            return new Rectangle2D.Float(left, top,\n-                                         right - left, bottom - top);\n-        }\n-\n@@ -561,17 +544,0 @@\n-        \/**\n-         * {@inheritDoc}\n-         * @since 1.2\n-         *\/\n-        public Rectangle2D getBounds2D() {\n-            double left   = Math.min(Math.min(x1, x2),\n-                                     Math.min(ctrlx1, ctrlx2));\n-            double top    = Math.min(Math.min(y1, y2),\n-                                     Math.min(ctrly1, ctrly2));\n-            double right  = Math.max(Math.max(x1, x2),\n-                                     Math.max(ctrlx1, ctrlx2));\n-            double bottom = Math.max(Math.max(y1, y2),\n-                                     Math.max(ctrly1, ctrly2));\n-            return new Rectangle2D.Double(left, top,\n-                                          right - left, bottom - top);\n-        }\n-\n@@ -1512,0 +1478,9 @@\n+\n+    \/**\n+     * {@inheritDoc}\n+     * @since 1.2\n+     *\/\n+    public Rectangle2D getBounds2D() {\n+        return Path2D.getBounds2D(getPathIterator(null));\n+    }\n+\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/geom\/CubicCurve2D.java","additions":9,"deletions":34,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -798,24 +798,0 @@\n-        \/**\n-         * {@inheritDoc}\n-         * @since 1.6\n-         *\/\n-        public final synchronized Rectangle2D getBounds2D() {\n-            float x1, y1, x2, y2;\n-            int i = numCoords;\n-            if (i > 0) {\n-                y1 = y2 = floatCoords[--i];\n-                x1 = x2 = floatCoords[--i];\n-                while (i > 0) {\n-                    float y = floatCoords[--i];\n-                    float x = floatCoords[--i];\n-                    if (x < x1) x1 = x;\n-                    if (y < y1) y1 = y;\n-                    if (x > x2) x2 = x;\n-                    if (y > y2) y2 = y;\n-                }\n-            } else {\n-                x1 = y1 = x2 = y2 = 0.0f;\n-            }\n-            return new Rectangle2D.Float(x1, y1, x2 - x1, y2 - y1);\n-        }\n-\n@@ -1590,24 +1566,0 @@\n-        \/**\n-         * {@inheritDoc}\n-         * @since 1.6\n-         *\/\n-        public final synchronized Rectangle2D getBounds2D() {\n-            double x1, y1, x2, y2;\n-            int i = numCoords;\n-            if (i > 0) {\n-                y1 = y2 = doubleCoords[--i];\n-                x1 = x2 = doubleCoords[--i];\n-                while (i > 0) {\n-                    double y = doubleCoords[--i];\n-                    double x = doubleCoords[--i];\n-                    if (x < x1) x1 = x;\n-                    if (y < y1) y1 = y;\n-                    if (x > x2) x2 = x;\n-                    if (y > y2) y2 = y;\n-                }\n-            } else {\n-                x1 = y1 = x2 = y2 = 0.0;\n-            }\n-            return new Rectangle2D.Double(x1, y1, x2 - x1, y2 - y1);\n-        }\n-\n@@ -2132,0 +2084,90 @@\n+    \/**\n+     * {@inheritDoc}\n+     * @since 1.6\n+     *\/\n+    public final synchronized Rectangle2D getBounds2D() {\n+        return getBounds2D(getPathIterator(null));\n+    }\n+\n+    \/**\n+     * Returns a high precision bounding box of the specified PathIterator.\n+     * <p>\n+     * This method provides a basic facility for implementors of the {@link Shape} interface to\n+     * implement support for the {@link Shape#getBounds2D()} method.\n+     * <\/p>\n+     *\n+     * @param pi the specified {@code PathIterator}\n+     * @return an instance of {@code Rectangle2D} that is a high-precision bounding box of the\n+     *         {@code PathIterator}.\n+     * @see Shape#getBounds2D()\n+     *\/\n+    static Rectangle2D getBounds2D(final PathIterator pi) {\n+        final double[] coeff = new double[4];\n+        final double[] deriv_coeff = new double[3];\n+\n+        final double[] coords = new double[6];\n+\n+        \/\/ bounds are stored as {leftX, rightX, topY, bottomY}\n+        double[] bounds = null;\n+        double lastX = 0.0;\n+        double lastY = 0.0;\n+        double endX = 0.0;\n+        double endY = 0.0;\n+\n+        for (; !pi.isDone(); pi.next()) {\n+            final int type = pi.currentSegment(coords);\n+            switch (type) {\n+                case PathIterator.SEG_MOVETO:\n+                    if (bounds == null) {\n+                        bounds = new double[] { coords[0], coords[0], coords[1], coords[1] };\n+                    }\n+                    endX = coords[0];\n+                    endY = coords[1];\n+                    break;\n+                case PathIterator.SEG_LINETO:\n+                    endX = coords[0];\n+                    endY = coords[1];\n+                    break;\n+                case PathIterator.SEG_QUADTO:\n+                    endX = coords[2];\n+                    endY = coords[3];\n+                    break;\n+                case PathIterator.SEG_CUBICTO:\n+                    endX = coords[4];\n+                    endY = coords[5];\n+                    break;\n+                case PathIterator.SEG_CLOSE:\n+                default:\n+                    continue;\n+            }\n+\n+            if (endX < bounds[0]) bounds[0] = endX;\n+            if (endX > bounds[1]) bounds[1] = endX;\n+            if (endY < bounds[2]) bounds[2] = endY;\n+            if (endY > bounds[3]) bounds[3] = endY;\n+\n+            switch (type) {\n+                case PathIterator.SEG_QUADTO:\n+                    Curve.accumulateExtremaBoundsForQuad(bounds, 0, lastX, coords[0], coords[2], coeff, deriv_coeff);\n+                    Curve.accumulateExtremaBoundsForQuad(bounds, 2, lastY, coords[1], coords[3], coeff, deriv_coeff);\n+                    break;\n+                case PathIterator.SEG_CUBICTO:\n+                    Curve.accumulateExtremaBoundsForCubic(bounds, 0, lastX, coords[0], coords[2], coords[4], coeff, deriv_coeff);\n+                    Curve.accumulateExtremaBoundsForCubic(bounds, 2, lastY, coords[1], coords[3], coords[5], coeff, deriv_coeff);\n+                    break;\n+                default:\n+                    break;\n+            }\n+\n+            lastX = endX;\n+            lastY = endY;\n+        }\n+        if (bounds != null) {\n+            return new Rectangle2D.Double(bounds[0], bounds[2], bounds[1] - bounds[0], bounds[3] - bounds[2]);\n+        }\n+\n+        \/\/ there's room to debate what should happen here, but historically we return a zeroed\n+        \/\/ out rectangle here. So for backwards compatibility let's keep doing that:\n+        return new Rectangle2D.Double();\n+    }\n+\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/geom\/Path2D.java","additions":90,"deletions":48,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -241,13 +241,0 @@\n-        \/**\n-         * {@inheritDoc}\n-         * @since 1.2\n-         *\/\n-        public Rectangle2D getBounds2D() {\n-            float left   = Math.min(Math.min(x1, x2), ctrlx);\n-            float top    = Math.min(Math.min(y1, y2), ctrly);\n-            float right  = Math.max(Math.max(x1, x2), ctrlx);\n-            float bottom = Math.max(Math.max(y1, y2), ctrly);\n-            return new Rectangle2D.Float(left, top,\n-                                         right - left, bottom - top);\n-        }\n-\n@@ -431,13 +418,0 @@\n-        \/**\n-         * {@inheritDoc}\n-         * @since 1.2\n-         *\/\n-        public Rectangle2D getBounds2D() {\n-            double left   = Math.min(Math.min(x1, x2), ctrlx);\n-            double top    = Math.min(Math.min(y1, y2), ctrly);\n-            double right  = Math.max(Math.max(x1, x2), ctrlx);\n-            double bottom = Math.max(Math.max(y1, y2), ctrly);\n-            return new Rectangle2D.Double(left, top,\n-                                          right - left, bottom - top);\n-        }\n-\n@@ -1338,0 +1312,8 @@\n+    \/**\n+     * {@inheritDoc}\n+     * @since 1.2\n+     *\/\n+    public Rectangle2D getBounds2D() {\n+        return Path2D.getBounds2D(getPathIterator(null));\n+    }\n+\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/geom\/QuadCurve2D.java","additions":8,"deletions":26,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -715,0 +715,120 @@\n+    \/**\n+     * Accumulate the quadratic extrema into the pre-existing bounding array.\n+     * <p>\n+     * This method focuses on one dimension at a time, so to get both the x and y\n+     * dimensions you'll need to call this method twice.\n+     * <\/p>\n+     * <p>\n+     * Whenever we have to examine cubic or quadratic extrema that change our bounding\n+     * box: we run the risk of machine error that may produce a box that is slightly\n+     * too small. But the contract of {@link Shape#getBounds2D()} says we should err\n+     * on the side of being too large. So to address this: we'll apply a margin based\n+     * on the upper limit of numerical error caused by the polynomial evaluation (horner\n+     * scheme).\n+     * <\/p>\n+     *\n+     * @param bounds the bounds to update, which are expressed as: { minX, maxX }\n+     * @param boundsOffset the index in boundsof the minimum value\n+     * @param x1 the starting value of the bezier curve where t = 0.0\n+     * @param ctrlX the control value of the bezier curve\n+     * @param x2 the ending value of the bezier curve where t = 1.0\n+     * @param coeff an array of at least 3 elements that will be overwritten and reused\n+     * @param deriv_coeff an array of at least 2 elements that will be overwritten and reused\n+     *\/\n+    public static void accumulateExtremaBoundsForQuad(double[] bounds, int boundsOffset, double x1, double ctrlX, double x2, double[] coeff, double[] deriv_coeff) {\n+        if (ctrlX < bounds[boundsOffset] ||\n+                ctrlX > bounds[boundsOffset + 1]) {\n+\n+            final double dx21 = ctrlX - x1;\n+            coeff[2] = (x2 - ctrlX) - dx21;  \/\/ A = P3 - P0 - 2 P2\n+            coeff[1] = 2.0 * dx21;           \/\/ B = 2 (P2 - P1)\n+            coeff[0] = x1;                   \/\/ C = P1\n+\n+            deriv_coeff[0] = coeff[1];\n+            deriv_coeff[1] = 2.0 * coeff[2];\n+\n+            final double t = -deriv_coeff[0] \/ deriv_coeff[1];\n+            if (t > 0.0 && t < 1.0) {\n+                final double v = coeff[0] + t * (coeff[1] + t * coeff[2]);\n+\n+                \/\/ error condition = sum ( abs (coeff) ):\n+                final double margin = Math.ulp(Math.abs(coeff[0])\n+                        + Math.abs(coeff[1]) + Math.abs(coeff[2]));\n+\n+                if (v - margin < bounds[boundsOffset]) {\n+                    bounds[boundsOffset] = v - margin;\n+                }\n+                if (v + margin > bounds[boundsOffset + 1]) {\n+                    bounds[boundsOffset + 1] = v + margin;\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Accumulate the cubic extrema into the pre-existing bounding array.\n+     * <p>\n+     * This method focuses on one dimension at a time, so to get both the x and y\n+     * dimensions you'll need to call this method twice.\n+     * <\/p>\n+     * <p>\n+     * Whenever we have to examine cubic or quadratic extrema that change our bounding\n+     * box: we run the risk of machine error that may produce a box that is slightly\n+     * too small. But the contract of {@link Shape#getBounds2D()} says we should err\n+     * on the side of being too large. So to address this: we'll apply a margin based\n+     * on the upper limit of numerical error caused by the polynomial evaluation (horner\n+     * scheme).\n+     * <\/p>\n+     *\n+     * @param bounds the bounds to update, which are expressed as: { minX, maxX }\n+     * @param boundsOffset the index in boundsof the minimum value\n+     * @param x1 the starting value of the bezier curve where t = 0.0\n+     * @param ctrlX1 the first control value of the bezier curve\n+     * @param ctrlX1 the second control value of the bezier curve\n+     * @param x2 the ending value of the bezier curve where t = 1.0\n+     * @param coeff an array of at least 3 elements that will be overwritten and reused\n+     * @param deriv_coeff an array of at least 2 elements that will be overwritten and reused\n+     *\/\n+    public static void accumulateExtremaBoundsForCubic(double[] bounds, int boundsOffset, double x1, double ctrlX1, double ctrlX2, double x2, double[] coeff, double[] deriv_coeff) {\n+        if (ctrlX1 < bounds[boundsOffset] ||\n+                ctrlX1 > bounds[boundsOffset + 1] ||\n+                ctrlX2 < bounds[boundsOffset] ||\n+                ctrlX2 > bounds[boundsOffset + 1]) {\n+            final double dx32 = 3.0 * (ctrlX2 - ctrlX1);\n+            final double dx21 = 3.0 * (ctrlX1 - x1);\n+            coeff[3] = (x2 - x1) - dx32;  \/\/ A = P3 - P0 - 3 (P2 - P1) = (P3 - P0) + 3 (P1 - P2)\n+            coeff[2] = (dx32 - dx21);         \/\/ B = 3 (P2 - P1) - 3(P1 - P0) = 3 (P2 + P0) - 6 P1\n+            coeff[1] = dx21;                  \/\/ C = 3 (P1 - P0)\n+            coeff[0] = x1;                 \/\/ D = P0\n+\n+            deriv_coeff[0] = coeff[1];\n+            deriv_coeff[1] = 2.0 * coeff[2];\n+            deriv_coeff[2] = 3.0 * coeff[3];\n+\n+            \/\/ reuse this array, give it a new name for readability:\n+            final double[] tExtrema = deriv_coeff;\n+\n+            \/\/ solveQuadratic should be improved to get correct t extrema (1 ulp):\n+            final int tExtremaCount = QuadCurve2D.solveQuadratic(deriv_coeff, tExtrema);\n+            if (tExtremaCount > 0) {\n+                \/\/ error condition = sum ( abs (coeff) ):\n+                final double margin = Math.ulp(Math.abs(coeff[0])\n+                        + Math.abs(coeff[1]) + Math.abs(coeff[2])\n+                        + Math.abs(coeff[3]));\n+\n+                for (int i = 0; i < tExtremaCount; i++) {\n+                    final double t = tExtrema[i];\n+                    if (t > 0.0 && t < 1.0) {\n+                        final double v = coeff[0] + t * (coeff[1] + t * (coeff[2] + t * coeff[3]));\n+                        if (v - margin < bounds[boundsOffset]) {\n+                            bounds[boundsOffset] = v - margin;\n+                        }\n+                        if (v + margin > bounds[boundsOffset + 1]) {\n+                            bounds[boundsOffset + 1] = v + margin;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/geom\/Curve.java","additions":120,"deletions":0,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -0,0 +1,263 @@\n+\n+import java.awt.*;\n+import java.awt.geom.*;\n+import java.math.*;\n+import java.util.*;\n+\n+\/*\n+ * @test\n+ * @bug 8176501\n+ * @summary This tests thousands of shapes and makes sure a high-precision bounding box fits inside the\n+ * results of Path2D.getBounds(PathIterator)\n+ * @run main GetBounds2DPrecisionTest\n+ *\/\n+public class GetBounds2DPrecisionTest {\n+\n+    public static void main(String[] args) {\n+        String msg1 = testSmallCubics();\n+        if (msg1 != null) {\n+            System.out.println(\"testSmallCubics: \"+msg1);\n+        } else {\n+            System.out.println(\"testSmallCubics: passed\");\n+        }\n+\n+        if (msg1 != null)\n+            throw new RuntimeException(\"One or more tests failed; see System.out output for details.\");\n+    }\n+\n+    \/**\n+     * @return a String describing the failure, or null if this test passed.\n+     *\/\n+    private static String testSmallCubics() {\n+        int failureCtr = 0;\n+        for(int a = 0; a < 1000; a++) {\n+            CubicCurve2D cubicCurve2D = createSmallCubic(a);\n+            if (!test(a, cubicCurve2D, getHorizontalEdges(cubicCurve2D)))\n+                failureCtr++;\n+        }\n+        if (failureCtr > 0)\n+            return failureCtr+\" tests failed; see System.out for details\";\n+        return null;\n+    }\n+\n+    private static CubicCurve2D createSmallCubic(int trial) {\n+        Random random = new Random(trial);\n+\n+        double cx1 = random.nextDouble() * 10 - 5;\n+        double cy1 = random.nextDouble();\n+        double cx2 = random.nextDouble() * 10 - 5;\n+        double cy2 = random.nextDouble();\n+\n+        return new CubicCurve2D.Double(0, 0, cx1, cy1, cx2, cy2, 0, 1);\n+    }\n+\n+    \/**\n+     * This returns true if the shape's getBounds2D() method returns a bounding box whose\n+     * left & right edges matches or exceeds the horizontalEdges arguments.\n+     *\/\n+    private static boolean test(int trial, Shape shape, BigDecimal[] horizontalEdges) {\n+        Rectangle2D bounds_doublePrecision = shape.getBounds2D();\n+\n+        Rectangle2D bounds_bigDecimalPrecision = new Rectangle2D.Double(\n+                horizontalEdges[0].doubleValue(),\n+                bounds_doublePrecision.getY(),\n+                horizontalEdges[1].subtract(horizontalEdges[0]).doubleValue(),\n+                bounds_doublePrecision.getHeight() );\n+\n+        boolean pass = true;\n+        if (bounds_doublePrecision.getMinX() > bounds_bigDecimalPrecision.getMinX()) {\n+            pass = false;\n+            String x1a = toUniformString(bounds_bigDecimalPrecision.getX());\n+            String x1b = toComparisonString(x1a, toUniformString(bounds_doublePrecision.getX()));\n+            System.out.println(\"Left expected:\\t\"+x1a);\n+            System.out.println(\"Left observed:\\t\"+x1b);\n+        }\n+\n+        if (bounds_doublePrecision.getMaxX() < bounds_bigDecimalPrecision.getMaxX()) {\n+            pass = false;\n+            String x2a = toUniformString(bounds_bigDecimalPrecision.getMaxX());\n+            String x2b = toComparisonString(x2a, toUniformString(bounds_doublePrecision.getMaxX()));\n+            System.out.println(\"Right expected:\\t\"+x2a);\n+            System.out.println(\"Right observed:\\t\"+x2b);\n+        }\n+        if (!pass)\n+            System.out.println(\"\\ttrial \"+trial +\" failed (\"+toString(shape)+\")\");\n+        return pass;\n+    }\n+\n+    \/**\n+     * Return the left and right edges in high precision\n+     *\/\n+    private static BigDecimal[] getHorizontalEdges(CubicCurve2D curve) {\n+        double cx1 = curve.getCtrlX1();\n+        double cx2 = curve.getCtrlX2();\n+\n+        BigDecimal[] coeff = new BigDecimal[4];\n+        BigDecimal[] deriv_coeff = new BigDecimal[3];\n+        BigDecimal[] tExtrema = new BigDecimal[2];\n+\n+\/\/        coeff[3] = -lastX + 3.0 * coords[0] - 3.0 * coords[2] + coords[4];\n+\/\/        coeff[2] = 3.0 * lastX - 6.0 * coords[0] + 3.0 * coords[2];\n+\/\/        coeff[1] = -3.0 * lastX + 3.0 * coords[0];\n+\/\/        coeff[0] = lastX;\n+\n+        coeff[3] = new BigDecimal(3).multiply(new BigDecimal(cx1)).add( new BigDecimal(-3).multiply(new BigDecimal(cx2)) );\n+        coeff[2] = new BigDecimal(-6).multiply(new BigDecimal(cx1)).add(new BigDecimal(3).multiply(new BigDecimal(cx2)));\n+        coeff[1] = new BigDecimal(3).multiply(new BigDecimal(cx1));\n+        coeff[0] = BigDecimal.ZERO;\n+\n+        deriv_coeff[0] = coeff[1];\n+        deriv_coeff[1] = new BigDecimal(2.0).multiply( coeff[2] );\n+        deriv_coeff[2] = new BigDecimal(3.0).multiply( coeff[3] );\n+\n+        int tExtremaCount = solveQuadratic(deriv_coeff, tExtrema);\n+\n+        BigDecimal leftX = BigDecimal.ZERO;\n+        BigDecimal rightX = BigDecimal.ZERO;\n+\n+        for (int i = 0; i < tExtremaCount; i++) {\n+            BigDecimal t = tExtrema[i];\n+            if (t.compareTo( BigDecimal.ZERO ) > 0 && t.compareTo(BigDecimal.ONE) < 0) {\n+                BigDecimal x = coeff[0].add( t.multiply(coeff[1].add(t.multiply(coeff[2].add(t.multiply(coeff[3]))))) );\n+                if (x.compareTo(leftX) < 0) leftX = x;\n+                if (x.compareTo(rightX) > 0) rightX = x;\n+            }\n+        }\n+        return new BigDecimal[] { leftX, rightX };\n+    }\n+\n+    \/**\n+     * Return the left and right edges in high precision\n+     *\/\n+    private static BigDecimal[] getHorizontalEdges(QuadCurve2D curve) {\n+        double cx = curve.getCtrlX();\n+\n+        BigDecimal[] coeff = new BigDecimal[3];\n+        BigDecimal[] deriv_coeff = new BigDecimal[2];\n+\n+        BigDecimal dx21 = new BigDecimal(cx).subtract(new BigDecimal(curve.getX1()));\n+        coeff[2] = new BigDecimal(curve.getX2()).subtract(new BigDecimal(cx)).subtract(dx21);  \/\/ A = P3 - P0 - 2 P2\n+        coeff[1] = new BigDecimal(2.0).multiply(dx21);                      \/\/ B = 2 (P2 - P1)\n+        coeff[0] = new BigDecimal(curve.getX1());                           \/\/ C = P1\n+\n+        deriv_coeff[0] = coeff[1];\n+        deriv_coeff[1] = new BigDecimal(2.0).multiply( coeff[2] );\n+\n+        BigDecimal leftX = BigDecimal.ZERO;\n+        BigDecimal rightX = BigDecimal.ZERO;\n+\n+        if (!deriv_coeff[1].equals(BigDecimal.ZERO)) {\n+            BigDecimal t = deriv_coeff[0].negate().divide(deriv_coeff[1], RoundingMode.HALF_EVEN);\n+\n+            if (t.compareTo( BigDecimal.ZERO ) > 0 && t.compareTo(BigDecimal.ONE) < 0) {\n+                BigDecimal x = coeff[0].add( t.multiply(coeff[1].add(t.multiply(coeff[2]))) );\n+                if (x.compareTo(leftX) < 0) leftX = x;\n+                if (x.compareTo(rightX) > 0) rightX = x;\n+            }\n+        }\n+\n+        return new BigDecimal[] { leftX, rightX };\n+    }\n+\n+    \/**\n+     * Convert a shape into SVG-ish notation for debugging\/readability.\n+     *\/\n+    private static String toString(Shape shape) {\n+        StringBuilder returnValue = new StringBuilder();\n+        PathIterator pi = shape.getPathIterator(null);\n+        double[] coords = new double[6];\n+        while(!pi.isDone()) {\n+            int k = pi.currentSegment(coords);\n+            if (k == PathIterator.SEG_MOVETO) {\n+                returnValue.append(\"m \"+coords[0]+\" \"+coords[1]+\" \");\n+            } else if (k == PathIterator.SEG_LINETO) {\n+                returnValue.append(\"l \"+coords[0]+\" \"+coords[1]+\" \");\n+            } else if (k == PathIterator.SEG_QUADTO) {\n+                returnValue.append(\"q \"+coords[0]+\" \"+coords[1]+\" \"+coords[2]+\" \"+coords[3]+\" \");\n+            } else if (k == PathIterator.SEG_CUBICTO) {\n+                returnValue.append(\"c \"+coords[0]+\" \"+coords[1]+\" \"+coords[2]+\" \"+coords[3]+\" \"+coords[4]+\" \"+coords[5]+\" \");\n+            } else if (k == PathIterator.SEG_CLOSE) {\n+                returnValue.append(\"z\");\n+            }\n+            pi.next();\n+        }\n+        return returnValue.toString();\n+    }\n+\n+    private static String toUniformString(double value) {\n+        BigDecimal decimal = new BigDecimal(value);\n+        int DIGIT_COUNT = 40;\n+        String str = decimal.toPlainString();\n+        if (str.length() >= DIGIT_COUNT) {\n+            str = str.substring(0,DIGIT_COUNT-1)+\"…\";\n+        }\n+        while(str.length() < DIGIT_COUNT) {\n+            str = str + \" \";\n+        }\n+        return str;\n+    }\n+\n+    private static String toComparisonString(String target, String observed) {\n+        for(int a = 0; a<target.length(); a++) {\n+            char ch1 = target.charAt(a);\n+            char ch2 = observed.charAt(a);\n+            if (ch1 != ch2) {\n+                return observed.substring(0,a) + createCircleDigit(ch2)+observed.substring(a+1);\n+            }\n+        }\n+        return observed;\n+    }\n+\n+    \/**\n+     * Convert a digit 0-9 into a \"circle digit\". Really we just want any unobtrusive way to\n+     * highlight a character.\n+     *\/\n+    private static char createCircleDigit(char ch) {\n+        if (ch >= '1' && ch <='9')\n+            return (char)( ch - '1' + '\\u2460');\n+        if (ch == '0')\n+            return '\\u24ea';\n+        return ch;\n+    }\n+\n+    private static int solveQuadratic(BigDecimal[] eqn, BigDecimal[] res) {\n+        BigDecimal a = eqn[2];\n+        BigDecimal b = eqn[1];\n+        BigDecimal c = eqn[0];\n+        int roots = 0;\n+        if (a.equals(BigDecimal.ZERO)) {\n+            \/\/ The quadratic parabola has degenerated to a line.\n+            if (b.equals(BigDecimal.ZERO)) {\n+                \/\/ The line has degenerated to a constant.\n+                return -1;\n+            }\n+            res[roots++] = c.negate().divide(b);\n+        } else {\n+            \/\/ From Numerical Recipes, 5.6, Quadratic and Cubic Equations\n+            BigDecimal d = b.multiply(b).add(new BigDecimal(-4.0).multiply(a).multiply(c));\n+            if (d.compareTo(BigDecimal.ZERO) < 0) {\n+                \/\/ If d < 0.0, then there are no roots\n+                return 0;\n+            }\n+            d = d.sqrt(MathContext.DECIMAL128);\n+            \/\/ For accuracy, calculate one root using:\n+            \/\/     (-b +\/- d) \/ 2a\n+            \/\/ and the other using:\n+            \/\/     2c \/ (-b +\/- d)\n+            \/\/ Choose the sign of the +\/- so that b+d gets larger in magnitude\n+            if (b.compareTo(BigDecimal.ZERO) < 0) {\n+                d = d.negate();\n+            }\n+            BigDecimal q = b.add(d).divide(new BigDecimal(-2.0));\n+            q = q.setScale(40, RoundingMode.HALF_EVEN);\n+\n+            \/\/ We already tested a for being 0 above\n+            res[roots++] = q.divide(a, RoundingMode.HALF_EVEN);\n+            if (!q.equals(BigDecimal.ZERO)) {\n+                c = c.setScale(40, RoundingMode.HALF_EVEN);\n+                res[roots++] = c.divide(q, RoundingMode.HALF_EVEN);\n+            }\n+        }\n+        return roots;\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/awt\/geom\/Path2D\/GetBounds2DPrecisionTest.java","additions":263,"deletions":0,"binary":false,"changes":263,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 4172661\n+ * @bug 4172661 8176501\n@@ -135,0 +135,10 @@\n+            makeJDK8176501(),\n+\n+            \/\/ this shape has a special property: some coefficients to the t^3 term\n+            \/\/ are *nearly* zero. And analytically they should be zero, but machine\n+            \/\/ error prevented it. In these cases cubic polynomials should degenerate\n+            \/\/ into quadratic polynomials, but because the coefficient is not exactly\n+            \/\/ zero that may not always be handled correctly:\n+            AffineTransform.getRotateInstance(Math.PI \/ 4).createTransformedShape(\n+                    new Ellipse2D.Float(0, 0, 100, 100))\n+\n@@ -196,0 +206,14 @@\n+    \/**\n+     * JDK-8176501 focused on a shape whose bounds included a lot of dead space.\n+     * This recreates that shape, and the unit test testGetBounds2D checks the\n+     * accuracy of {@link Shape#getBounds2D()}\n+     *\/\n+    public static Path2D makeJDK8176501() {\n+        Path2D.Double path = new Path2D.Double();\n+        path.moveTo(40, 140);\n+        path.curveTo(40, 60, 160, 60, 160, 140);\n+        path.curveTo(160, 220, 40, 220, 40, 140);\n+        path.closePath();\n+        return path;\n+    }\n+\n@@ -541,22 +565,0 @@\n-        private Rectangle2D cachedBounds;\n-        public Rectangle2D getCachedBounds2D() {\n-            if (cachedBounds == null) {\n-                double xmin, ymin, xmax, ymax;\n-                int ci = 0;\n-                xmin = xmax = theCoords[ci++];\n-                ymin = ymax = theCoords[ci++];\n-                while (ci < numCoords) {\n-                    double c = theCoords[ci++];\n-                    if (xmin > c) xmin = c;\n-                    if (xmax < c) xmax = c;\n-                    c = theCoords[ci++];\n-                    if (ymin > c) ymin = c;\n-                    if (ymax < c) ymax = c;\n-                }\n-                cachedBounds = new Rectangle2D.Double(xmin, ymin,\n-                                                      xmax - xmin,\n-                                                      ymax - ymin);\n-            }\n-            return cachedBounds;\n-        }\n-\n@@ -564,1 +566,1 @@\n-            return getCachedBounds2D().getBounds();\n+            return getBounds2D().getBounds();\n@@ -567,1 +569,1 @@\n-            return getCachedBounds2D().getBounds2D();\n+            return getTestShape().getBounds2D();\n@@ -1300,0 +1302,1 @@\n+            testGetBounds2D(stest);\n@@ -1315,0 +1318,87 @@\n+    \/**\n+     * Make sure the {@link Shape#getBounds2D()} returns a Rectangle2D that tightly fits the\n+     * shape data. It shouldn't contain lots of dead space (see JDK 8176501), and it shouldn't\n+     * leave out any shape path. This test relies on the accuracy of\n+     * {@link Shape#intersects(double, double, double, double)}\n+     *\/\n+    public static void testGetBounds2D(Shape shape) {\n+        \/\/ first: make sure the shape is actually close to the perimeter of shape.getBounds2D().\n+        \/\/ this is the crux of JDK 8176501:\n+\n+        Rectangle2D r = shape.getBounds2D();\n+\n+        if (r.getWidth() == 0 || r.getHeight() == 0) {\n+            \/\/ this can happen for completely empty paths, which are part of our\n+            \/\/ edge test cases in this class.\n+            return;\n+        }\n+\n+        if (verbose) System.out.println(\"testGetBounds2D \"+shape+\", \"+r);\n+\n+        double xminInterior = r.getMinX() + .000001;\n+        double yminInterior = r.getMinY() + .000001;\n+        double xmaxInterior = r.getMaxX() - .000001;\n+        double ymaxInterior = r.getMaxY() - .000001;\n+\n+        Rectangle2D topStrip = new Rectangle2D.Double(r.getMinX(), r.getMinY(), r.getWidth(), yminInterior - r.getMinY());\n+        Rectangle2D leftStrip = new Rectangle2D.Double(r.getMinX(), r.getMinY(), xminInterior - r.getMinX(), r.getHeight());\n+        Rectangle2D bottomStrip = new Rectangle2D.Double(r.getMinX(), ymaxInterior, r.getWidth(), r.getMaxY() - ymaxInterior);\n+        Rectangle2D rightStrip = new Rectangle2D.Double(xmaxInterior, r.getMinY(), r.getMaxX() - xmaxInterior, r.getHeight());\n+        if (!shape.intersects(topStrip)) {\n+            if (verbose)\n+                System.out.println(\"topStrip = \"+topStrip);\n+            throw new RuntimeException(\"the shape must intersect the top strip of its bounds\");\n+        }\n+        if (!shape.intersects(leftStrip)) {\n+            if (verbose)\n+                System.out.println(\"leftStrip = \" + leftStrip);\n+            throw new RuntimeException(\"the shape must intersect the left strip of its bounds\");\n+        }\n+        if (!shape.intersects(bottomStrip)) {\n+            if (verbose)\n+                System.out.println(\"bottomStrip = \" + bottomStrip);\n+            throw new RuntimeException(\"the shape must intersect the bottom strip of its bounds\");\n+        }\n+        if (!shape.intersects(rightStrip)) {\n+            if (verbose)\n+                System.out.println(\"rightStrip = \" + rightStrip);\n+            throw new RuntimeException(\"the shape must intersect the right strip of bounds\");\n+        }\n+\n+        \/\/ Similarly: make sure our shape doesn't exist OUTSIDE of r, either. To my knowledge this has never\n+        \/\/ been a problem, but if it did happen this would be an even more serious breach of contract than\n+        \/\/ the former case.\n+\n+        double xminExterior = r.getMinX() - .000001;\n+        double yminExterior = r.getMinY() - .000001;\n+        double xmaxExterior = r.getMaxX() + .000001;\n+        double ymaxExterior = r.getMaxY() + .000001;\n+\n+        \/\/ k is simply meant to mean \"a large number, functionally similar to infinity for this test\"\n+        double k = 10000.0;\n+        leftStrip = new Rectangle2D.Double(xminExterior - k, -k, k, 3 * k);\n+        rightStrip = new Rectangle2D.Double(xmaxExterior, -k, k, 3 * k);\n+        topStrip = new Rectangle2D.Double(-k, yminExterior - k, 3 * k, k);\n+        bottomStrip = new Rectangle2D.Double(-k, ymaxExterior, 3 * k, k);\n+        if (shape.intersects(leftStrip)) {\n+            if (verbose)\n+                System.out.println(\"leftStrip = \" + leftStrip);\n+            throw new RuntimeException(\"the shape must not intersect anything to the left of its bounds\");\n+        }\n+        if (shape.intersects(rightStrip)) {\n+            if (verbose)\n+                System.out.println(\"rightStrip = \" + rightStrip);\n+            throw new RuntimeException(\"the shape must not intersect anything to the right of its bounds\");\n+        }\n+        if (shape.intersects(topStrip)) {\n+            if (verbose)\n+                System.out.println(\"topStrip = \" + topStrip);\n+            throw new RuntimeException(\"the shape must not intersect anything above its bounds\");\n+        }\n+        if (shape.intersects(bottomStrip)) {\n+            if (verbose)\n+                System.out.println(\"bottomStrip = \" + bottomStrip);\n+            throw new RuntimeException(\"the shape must not intersect anything below its bounds\");\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/awt\/geom\/Path2D\/UnitTest.java","additions":115,"deletions":25,"binary":false,"changes":140,"status":"modified"}]}