{"files":[{"patch":"@@ -2107,0 +2107,2 @@\n+\n+        \/\/ bounds are stored as {leftX, rightX, topY, bottomY}\n@@ -2118,1 +2120,1 @@\n-                        bounds = new double[] { coords[0], coords[1], coords[0], coords[1] };\n+                        bounds = new double[] { coords[0], coords[0], coords[1], coords[1] };\n@@ -2141,2 +2143,2 @@\n-            if (endX > bounds[2]) bounds[2] = endX;\n-            if (endY < bounds[1]) bounds[1] = endY;\n+            if (endX > bounds[1]) bounds[1] = endX;\n+            if (endY < bounds[2]) bounds[2] = endY;\n@@ -2147,1 +2149,2 @@\n-                    Curve.accumulateExtremaBoundsForQuad(bounds, lastX, lastY, coords, coeff, deriv_coeff);\n+                    Curve.accumulateExtremaBoundsForQuad(bounds, 0, lastX, coords[0], coords[2], coeff, deriv_coeff);\n+                    Curve.accumulateExtremaBoundsForQuad(bounds, 2, lastY, coords[1], coords[3], coeff, deriv_coeff);\n@@ -2150,1 +2153,2 @@\n-                    Curve.accumulateExtremaBoundsForCubic(bounds, lastX, lastY, coords, coeff, deriv_coeff);\n+                    Curve.accumulateExtremaBoundsForCubic(bounds, 0, lastX, coords[0], coords[2], coords[4], coeff, deriv_coeff);\n+                    Curve.accumulateExtremaBoundsForCubic(bounds, 2, lastY, coords[1], coords[3], coords[5], coeff, deriv_coeff);\n@@ -2153,1 +2157,1 @@\n-                    \/\/ intentionally empty\n+                    break;\n@@ -2160,1 +2164,1 @@\n-            return new Rectangle2D.Double(bounds[0], bounds[1], bounds[2] - bounds[0], bounds[3] - bounds[1]);\n+            return new Rectangle2D.Double(bounds[0], bounds[2], bounds[1] - bounds[0], bounds[3] - bounds[2]);\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/geom\/Path2D.java","additions":11,"deletions":7,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -716,1 +716,5 @@\n-     * Accumulate the quadratic extrema into the pre-existing bounding box.\n+     * Accumulate the quadratic extrema into the pre-existing bounding array.\n+     * <p>\n+     * This method focuses on one dimension at a time, so to get both the x and y\n+     * dimensions you'll need to call this method twice.\n+     * <\/p>\n@@ -726,4 +730,5 @@\n-     * @param bounds the bounds to update, which are expressed as: { left_x, top_y, right_x, bottom_y }\n-     * @param startX the initial x value of the bezier quadratic curve\n-     * @param startY the initial y value of the bezier quadratic curve\n-     * @param coords the two (x,y) coordinates returned by {@link PathIterator#currentSegment(double[])}\n+     * @param bounds the bounds to update, which are expressed as: { minX, maxX }\n+     * @param boundsOffset the index in boundsof the minimum value\n+     * @param x1 the starting value of the bezier curve where t = 0.0\n+     * @param ctrlX the control value of the bezier curve\n+     * @param x2 the ending value of the bezier curve where t = 1.0\n@@ -733,31 +738,25 @@\n-    public static void accumulateExtremaBoundsForQuad(double[] bounds, double startX, double startY, double[] coords, double[] coeff, double[] deriv_coeff) {\n-        \/\/ when arrayOffset = 0 we look at x values; when arrayOffset = 1 we look at y values\n-        for(int arrayOffset = 0; arrayOffset < 2; arrayOffset++) {\n-            if (coords[0 + arrayOffset] < bounds[0 + arrayOffset] ||\n-                    coords[0 + arrayOffset] > bounds[2 + arrayOffset]) {\n-                final double start = arrayOffset == 0 ? startX : startY;\n-                final double ctrl = coords[0 + arrayOffset];\n-                final double end = coords[2 + arrayOffset];\n-\n-                final double dx21 = ctrl - start;\n-                coeff[2] = (end - ctrl) - dx21;  \/\/ A = P3 - P0 - 2 P2\n-                coeff[1] = 2.0 * dx21;           \/\/ B = 2 (P2 - P1)\n-                coeff[0] = start;                \/\/ C = P1\n-\n-                deriv_coeff[0] = coeff[1];\n-                deriv_coeff[1] = 2.0 * coeff[2];\n-\n-                final double t = -deriv_coeff[0] \/ deriv_coeff[1];\n-                if (t > 0.0 && t < 1.0) {\n-                    final double v = coeff[0] + t * (coeff[1] + t * coeff[2]);\n-\n-                    \/\/ error condition = sum ( abs (coeff) ):\n-                    final double margin = Math.ulp(Math.abs(coeff[0])\n-                            + Math.abs(coeff[1]) + Math.abs(coeff[2]));\n-\n-                    if (v - margin < bounds[0 + arrayOffset]) {\n-                        bounds[0 + arrayOffset] = v - margin;\n-                    }\n-                    if (v + margin > bounds[2 + arrayOffset]) {\n-                        bounds[2 + arrayOffset] = v + margin;\n-                    }\n+    public static void accumulateExtremaBoundsForQuad(double[] bounds, int boundsOffset, double x1, double ctrlX, double x2, double[] coeff, double[] deriv_coeff) {\n+        if (ctrlX < bounds[boundsOffset] ||\n+                ctrlX > bounds[boundsOffset + 1]) {\n+\n+            final double dx21 = ctrlX - x1;\n+            coeff[2] = (x2 - ctrlX) - dx21;  \/\/ A = P3 - P0 - 2 P2\n+            coeff[1] = 2.0 * dx21;           \/\/ B = 2 (P2 - P1)\n+            coeff[0] = x1;                   \/\/ C = P1\n+\n+            deriv_coeff[0] = coeff[1];\n+            deriv_coeff[1] = 2.0 * coeff[2];\n+\n+            final double t = -deriv_coeff[0] \/ deriv_coeff[1];\n+            if (t > 0.0 && t < 1.0) {\n+                final double v = coeff[0] + t * (coeff[1] + t * coeff[2]);\n+\n+                \/\/ error condition = sum ( abs (coeff) ):\n+                final double margin = Math.ulp(Math.abs(coeff[0])\n+                        + Math.abs(coeff[1]) + Math.abs(coeff[2]));\n+\n+                if (v - margin < bounds[boundsOffset]) {\n+                    bounds[boundsOffset] = v - margin;\n+                }\n+                if (v + margin > bounds[boundsOffset + 1]) {\n+                    bounds[boundsOffset + 1] = v + margin;\n@@ -770,1 +769,5 @@\n-     * Accumulate the cubic extrema into the pre-existing bounding box.\n+     * Accumulate the cubic extrema into the pre-existing bounding array.\n+     * <p>\n+     * This method focuses on one dimension at a time, so to get both the x and y\n+     * dimensions you'll need to call this method twice.\n+     * <\/p>\n@@ -780,6 +783,8 @@\n-     * @param bounds the bounds to update, which are expressed as: { left_x, top_y, right_x, bottom_y }\n-     * @param startX the initial x value of the bezier cubic curve\n-     * @param startY the initial y value of the bezier cubic curve\n-     * @param coords the three (x,y) coordinates returned by {@link PathIterator#currentSegment(double[])}\n-     * @param coeff an array of at least 4 elements that will be overwritten and reused\n-     * @param deriv_coeff an array of at least 3 elements that will be overwritten and reused\n+     * @param bounds the bounds to update, which are expressed as: { minX, maxX }\n+     * @param boundsOffset the index in boundsof the minimum value\n+     * @param x1 the starting value of the bezier curve where t = 0.0\n+     * @param ctrlX1 the first control value of the bezier curve\n+     * @param ctrlX1 the second control value of the bezier curve\n+     * @param x2 the ending value of the bezier curve where t = 1.0\n+     * @param coeff an array of at least 3 elements that will be overwritten and reused\n+     * @param deriv_coeff an array of at least 2 elements that will be overwritten and reused\n@@ -787,44 +792,34 @@\n-    public static void accumulateExtremaBoundsForCubic(double[] bounds, double startX, double startY, double[] coords, double[] coeff, double[] deriv_coeff) {\n-        \/\/ when arrayOffset = 0 we look at x values; when arrayOffset = 1 we look at y values\n-        for (int arrayOffset = 0; arrayOffset < 2; arrayOffset++) {\n-            if (coords[arrayOffset] < bounds[0 + arrayOffset] ||\n-                    coords[arrayOffset] > bounds[2 + arrayOffset] ||\n-                    coords[2 + arrayOffset] < bounds[0 + arrayOffset] ||\n-                    coords[2 + arrayOffset] > bounds[2 + arrayOffset]) {\n-                final double start = arrayOffset == 0 ? startX : startY;\n-                final double ctrl1 = coords[0 + arrayOffset];\n-                final double ctrl2 = coords[2 + arrayOffset];\n-                final double end = coords[4 + arrayOffset];\n-\n-                final double dx32 = 3.0 * (ctrl2 - ctrl1);\n-                final double dx21 = 3.0 * (ctrl1 - start);\n-                coeff[3] = (end - start) - dx32;  \/\/ A = P3 - P0 - 3 (P2 - P1) = (P3 - P0) + 3 (P1 - P2)\n-                coeff[2] = (dx32 - dx21);         \/\/ B = 3 (P2 - P1) - 3(P1 - P0) = 3 (P2 + P0) - 6 P1\n-                coeff[1] = dx21;                  \/\/ C = 3 (P1 - P0)\n-                coeff[0] = start;                 \/\/ D = P0\n-\n-                deriv_coeff[0] = coeff[1];\n-                deriv_coeff[1] = 2.0 * coeff[2];\n-                deriv_coeff[2] = 3.0 * coeff[3];\n-\n-                \/\/ reuse this array, give it a new name for readability:\n-                final double[] tExtrema = deriv_coeff;\n-\n-                \/\/ solveQuadratic should be improved to get correct t extrema (1 ulp):\n-                final int tExtremaCount = QuadCurve2D.solveQuadratic(deriv_coeff, tExtrema);\n-                if (tExtremaCount > 0) {\n-                    \/\/ error condition = sum ( abs (coeff) ):\n-                    final double margin = Math.ulp(Math.abs(coeff[0])\n-                            + Math.abs(coeff[1]) + Math.abs(coeff[2])\n-                            + Math.abs(coeff[3]));\n-\n-                    for (int i = 0; i < tExtremaCount; i++) {\n-                        final double t = tExtrema[i];\n-                        if (t > 0.0 && t < 1.0) {\n-                            final double v = coeff[0] + t * (coeff[1] + t * (coeff[2] + t * coeff[3]));\n-                            if (v - margin < bounds[0 + arrayOffset]) {\n-                                bounds[0 + arrayOffset] = v - margin;\n-                            }\n-                            if (v + margin > bounds[2 + arrayOffset]) {\n-                                bounds[2 + arrayOffset] = v + margin;\n-                            }\n+    public static void accumulateExtremaBoundsForCubic(double[] bounds, int boundsOffset, double x1, double ctrlX1, double ctrlX2, double x2, double[] coeff, double[] deriv_coeff) {\n+        if (ctrlX1 < bounds[boundsOffset] ||\n+                ctrlX1 > bounds[boundsOffset + 1]) {\n+            final double dx32 = 3.0 * (ctrlX2 - ctrlX1);\n+            final double dx21 = 3.0 * (ctrlX1 - x1);\n+            coeff[3] = (x2 - x1) - dx32;  \/\/ A = P3 - P0 - 3 (P2 - P1) = (P3 - P0) + 3 (P1 - P2)\n+            coeff[2] = (dx32 - dx21);         \/\/ B = 3 (P2 - P1) - 3(P1 - P0) = 3 (P2 + P0) - 6 P1\n+            coeff[1] = dx21;                  \/\/ C = 3 (P1 - P0)\n+            coeff[0] = x1;                 \/\/ D = P0\n+\n+            deriv_coeff[0] = coeff[1];\n+            deriv_coeff[1] = 2.0 * coeff[2];\n+            deriv_coeff[2] = 3.0 * coeff[3];\n+\n+            \/\/ reuse this array, give it a new name for readability:\n+            final double[] tExtrema = deriv_coeff;\n+\n+            \/\/ solveQuadratic should be improved to get correct t extrema (1 ulp):\n+            final int tExtremaCount = QuadCurve2D.solveQuadratic(deriv_coeff, tExtrema);\n+            if (tExtremaCount > 0) {\n+                \/\/ error condition = sum ( abs (coeff) ):\n+                final double margin = Math.ulp(Math.abs(coeff[0])\n+                        + Math.abs(coeff[1]) + Math.abs(coeff[2])\n+                        + Math.abs(coeff[3]));\n+\n+                for (int i = 0; i < tExtremaCount; i++) {\n+                    final double t = tExtrema[i];\n+                    if (t > 0.0 && t < 1.0) {\n+                        final double v = coeff[0] + t * (coeff[1] + t * (coeff[2] + t * coeff[3]));\n+                        if (v - margin < bounds[boundsOffset]) {\n+                            bounds[boundsOffset] = v - margin;\n+                        }\n+                        if (v + margin > bounds[boundsOffset + 1]) {\n+                            bounds[boundsOffset + 1] = v + margin;\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/geom\/Curve.java","additions":82,"deletions":87,"binary":false,"changes":169,"status":"modified"}]}