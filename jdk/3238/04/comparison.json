{"files":[{"patch":"@@ -3292,0 +3292,30 @@\n+\/\/ vector mask cast\n+\n+instruct vmaskcastD(vecD dst)\n+%{\n+  predicate(n->bottom_type()->is_vect()->length_in_bytes() == 8 &&\n+            n->in(1)->bottom_type()->is_vect()->length_in_bytes() == 8 &&\n+            n->bottom_type()->is_vect()->length() == n->in(1)->bottom_type()->is_vect()->length());\n+  match(Set dst (VectorMaskCast dst));\n+  ins_cost(0);\n+  format %{ \"vmaskcast $dst\\t# empty\" %}\n+  ins_encode %{\n+    \/\/ empty\n+  %}\n+  ins_pipe(pipe_class_empty);\n+%}\n+\n+instruct vmaskcastX(vecX dst)\n+%{\n+  predicate(n->bottom_type()->is_vect()->length_in_bytes() == 16 &&\n+            n->in(1)->bottom_type()->is_vect()->length_in_bytes() == 16 &&\n+            n->bottom_type()->is_vect()->length() == n->in(1)->bottom_type()->is_vect()->length());\n+  match(Set dst (VectorMaskCast dst));\n+  ins_cost(0);\n+  format %{ \"vmaskcast $dst\\t# empty\" %}\n+  ins_encode %{\n+    \/\/ empty\n+  %}\n+  ins_pipe(pipe_class_empty);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_neon.ad","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -1235,0 +1235,21 @@\n+\/\/ vector mask cast\n+dnl\n+define(`VECTOR_MASK_CAST', `\n+instruct vmaskcast$1`'(vec$1 dst)\n+%{\n+  predicate(n->bottom_type()->is_vect()->length_in_bytes() == $2 &&\n+            n->in(1)->bottom_type()->is_vect()->length_in_bytes() == $2 &&\n+            n->bottom_type()->is_vect()->length() == n->in(1)->bottom_type()->is_vect()->length());\n+  match(Set dst (VectorMaskCast dst));\n+  ins_cost(0);\n+  format %{ \"vmaskcast $dst\\t# empty\" %}\n+  ins_encode %{\n+    \/\/ empty\n+  %}\n+  ins_pipe(pipe_class_empty);\n+%}')dnl\n+dnl              $1 $2\n+VECTOR_MASK_CAST(D, 8)\n+VECTOR_MASK_CAST(X, 16)\n+dnl\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_neon_ad.m4","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -1703,0 +1703,15 @@\n+\n+\/\/ vector mask cast\n+\n+instruct vmaskcast(vReg dst) %{\n+  predicate(UseSVE > 0 && n->bottom_type()->is_vect()->length() == n->in(1)->bottom_type()->is_vect()->length() &&\n+            n->bottom_type()->is_vect()->length_in_bytes() == n->in(1)->bottom_type()->is_vect()->length_in_bytes());\n+  match(Set dst (VectorMaskCast dst));\n+  ins_cost(0);\n+  format %{ \"vmaskcast $dst\\t# empty (sve)\" %}\n+  ins_encode %{\n+    \/\/ empty\n+  %}\n+  ins_pipe(pipe_class_empty);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve.ad","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -856,0 +856,15 @@\n+\n+\/\/ vector mask cast\n+\n+instruct vmaskcast(vReg dst) %{\n+  predicate(UseSVE > 0 && n->bottom_type()->is_vect()->length() == n->in(1)->bottom_type()->is_vect()->length() &&\n+            n->bottom_type()->is_vect()->length_in_bytes() == n->in(1)->bottom_type()->is_vect()->length_in_bytes());\n+  match(Set dst (VectorMaskCast dst));\n+  ins_cost(0);\n+  format %{ \"vmaskcast $dst\\t# empty (sve)\" %}\n+  ins_encode %{\n+    \/\/ empty\n+  %}\n+  ins_pipe(pipe_class_empty);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve_ad.m4","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -4202,1 +4202,2 @@\n-    \"ExtractB\",\"ExtractUB\",\"ExtractC\",\"ExtractS\",\"ExtractI\",\"ExtractL\",\"ExtractF\",\"ExtractD\"\n+    \"ExtractB\",\"ExtractUB\",\"ExtractC\",\"ExtractS\",\"ExtractI\",\"ExtractL\",\"ExtractF\",\"ExtractD\",\n+    \"VectorMaskCast\"\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -449,0 +449,1 @@\n+macro(VectorMaskCast)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1235,0 +1235,7 @@\n+          if (in_vt->length_in_bytes() == out_vt->length_in_bytes() &&\n+              Matcher::match_rule_supported_vector(Op_VectorMaskCast, out_vt->length(), out_vt->element_basic_type())) {\n+            \/\/ Apply \"VectorUnbox (VectorBox vmask) ==> VectorMaskCast (vmask)\"\n+            \/\/ directly. This could avoid the transformation ordering issue from\n+            \/\/ \"VectorStoreMask (VectorLoadMask vmask) => vmask\".\n+            return new VectorMaskCastNode(value, out_vt);\n+          }\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1240,0 +1240,11 @@\n+class VectorMaskCastNode : public VectorNode {\n+ public:\n+  VectorMaskCastNode(Node* in, const TypeVect* vt) : VectorNode(in, vt) {\n+    const TypeVect* in_vt = in->bottom_type()->is_vect();\n+    assert(in_vt->length() == vt->length(), \"vector length must match\");\n+    assert(type2aelembytes(in_vt->element_basic_type()) == type2aelembytes(vt->element_basic_type()), \"element size must match\");\n+  }\n+\n+  virtual int Opcode() const;\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1880,0 +1880,1 @@\n+  declare_c2_type(VectorMaskCastNode, VectorNode)                         \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}