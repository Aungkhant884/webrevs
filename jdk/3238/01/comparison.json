{"files":[{"patch":"@@ -806,0 +806,5 @@\n+  bool mask_compatible(const TypeVect* t) const {\n+    return base() == t->base() && length() == t->length() &&\n+           type2aelembytes(element_basic_type()) == type2aelembytes(t->element_basic_type());\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -975,1 +975,2 @@\n-  BasicType out_bt = type()->is_vect()->element_basic_type();\n+  const TypeVect* out_type = type()->is_vect();\n+  BasicType out_bt = out_type->element_basic_type();\n@@ -979,0 +980,10 @@\n+\n+  \/\/ \"VectorLoadMask (VectorStoreMask vmask) ==> vmask\" if:\n+  \/\/ \"vmask\" has the same vector length and the same element size\n+  \/\/ (i.e. T_FLOAT and T_INT have the same size) with current node.\n+  if (in(1)->Opcode() == Op_VectorStoreMask) {\n+    Node* mask = in(1)->in(1);\n+    if (out_type->mask_compatible(mask->bottom_type()->is_vect())) {\n+      return mask;\n+    }\n+  }\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1227,0 +1227,11 @@\n+  virtual bool cmp( const Node &n ) const {\n+    \/\/ The vector types for mask nodes can be treated equal if they are compatible.\n+    return vect_type()->mask_compatible(((VectorLoadMaskNode&)n).vect_type());\n+  }\n+\n+  virtual uint hash() const {\n+    \/\/ Compute the hash value based on the vector length and element size\n+    \/\/ for mask nodes. Note that the same element size can be verified with\n+    \/\/ the same length and same length in bytes.\n+    return Node::hash() + (intptr_t)length_in_bytes() + (intptr_t)length();\n+  }\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"}]}