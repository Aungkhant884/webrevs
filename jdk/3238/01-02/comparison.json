{"files":[{"patch":"@@ -3292,0 +3292,26 @@\n+\/\/ vector mask cast\n+\n+instruct vmaskcastD(vecD dst)\n+%{\n+  predicate(n->bottom_type()->is_vect()->length_in_bytes() == 8);\n+  match(Set dst (VectorMaskCast dst));\n+  ins_cost(0);\n+  format %{ \"vmaskcast $dst\\t# empty\" %}\n+  ins_encode %{\n+    \/\/ empty\n+  %}\n+  ins_pipe(pipe_class_empty);\n+%}\n+\n+instruct vmaskcastX(vecX dst)\n+%{\n+  predicate(n->bottom_type()->is_vect()->length_in_bytes() == 16);\n+  match(Set dst (VectorMaskCast dst));\n+  ins_cost(0);\n+  format %{ \"vmaskcast $dst\\t# empty\" %}\n+  ins_encode %{\n+    \/\/ empty\n+  %}\n+  ins_pipe(pipe_class_empty);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_neon.ad","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1235,0 +1235,19 @@\n+\/\/ vector mask cast\n+dnl\n+define(`VECTOR_MASK_CAST', `\n+instruct vmaskcast$1`'(vec$1 dst)\n+%{\n+  predicate(n->bottom_type()->is_vect()->length_in_bytes() == $2);\n+  match(Set dst (VectorMaskCast dst));\n+  ins_cost(0);\n+  format %{ \"vmaskcast $dst\\t# empty\" %}\n+  ins_encode %{\n+    \/\/ empty\n+  %}\n+  ins_pipe(pipe_class_empty);\n+%}')dnl\n+dnl              $1 $2\n+VECTOR_MASK_CAST(D, 8)\n+VECTOR_MASK_CAST(X, 16)\n+dnl\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_neon_ad.m4","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -1703,0 +1703,14 @@\n+\n+\/\/ vector mask cast\n+\n+instruct vmaskcast(vReg dst) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (VectorMaskCast dst));\n+  ins_cost(0);\n+  format %{ \"vmaskcast $dst\\t# empty (sve)\" %}\n+  ins_encode %{\n+    \/\/ empty\n+  %}\n+  ins_pipe(pipe_class_empty);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve.ad","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -856,0 +856,14 @@\n+\n+\/\/ vector mask cast\n+\n+instruct vmaskcast(vReg dst) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst (VectorMaskCast dst));\n+  ins_cost(0);\n+  format %{ \"vmaskcast $dst\\t# empty (sve)\" %}\n+  ins_encode %{\n+    \/\/ empty\n+  %}\n+  ins_pipe(pipe_class_empty);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve_ad.m4","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -4202,1 +4202,2 @@\n-    \"ExtractB\",\"ExtractUB\",\"ExtractC\",\"ExtractS\",\"ExtractI\",\"ExtractL\",\"ExtractF\",\"ExtractD\"\n+    \"ExtractB\",\"ExtractUB\",\"ExtractC\",\"ExtractS\",\"ExtractI\",\"ExtractL\",\"ExtractF\",\"ExtractD\",\n+    \"VectorMaskCast\"\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -449,0 +449,1 @@\n+macro(VectorMaskCast)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -806,5 +806,0 @@\n-  bool mask_compatible(const TypeVect* t) const {\n-    return base() == t->base() && length() == t->length() &&\n-           type2aelembytes(element_basic_type()) == type2aelembytes(t->element_basic_type());\n-  }\n-\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -975,2 +975,1 @@\n-  const TypeVect* out_type = type()->is_vect();\n-  BasicType out_bt = out_type->element_basic_type();\n+  BasicType out_bt = type()->is_vect()->element_basic_type();\n@@ -980,10 +979,0 @@\n-\n-  \/\/ \"VectorLoadMask (VectorStoreMask vmask) ==> vmask\" if:\n-  \/\/ \"vmask\" has the same vector length and the same element size\n-  \/\/ (i.e. T_FLOAT and T_INT have the same size) with current node.\n-  if (in(1)->Opcode() == Op_VectorStoreMask) {\n-    Node* mask = in(1)->in(1);\n-    if (out_type->mask_compatible(mask->bottom_type()->is_vect())) {\n-      return mask;\n-    }\n-  }\n@@ -1246,0 +1235,5 @@\n+          if (in_vt->length_in_bytes() == out_vt->length_in_bytes() &&\n+              Matcher::match_rule_supported(Op_VectorMaskCast)) {\n+            \/\/ VectorUnbox (VectorBox vmask) ==> VectorMaskCast (vmask)\n+            return new VectorMaskCastNode(value, out_vt);\n+          }\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":6,"deletions":12,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1227,11 +1227,0 @@\n-  virtual bool cmp( const Node &n ) const {\n-    \/\/ The vector types for mask nodes can be treated equal if they are compatible.\n-    return vect_type()->mask_compatible(((VectorLoadMaskNode&)n).vect_type());\n-  }\n-\n-  virtual uint hash() const {\n-    \/\/ Compute the hash value based on the vector length and element size\n-    \/\/ for mask nodes. Note that the same element size can be verified with\n-    \/\/ the same length and same length in bytes.\n-    return Node::hash() + (intptr_t)length_in_bytes() + (intptr_t)length();\n-  }\n@@ -1251,0 +1240,11 @@\n+class VectorMaskCastNode : public VectorNode {\n+ public:\n+  VectorMaskCastNode(Node* in, const TypeVect* vt) : VectorNode(in, vt) {\n+    const TypeVect* in_vt = in->bottom_type()->is_vect();\n+    assert(in_vt->length() == vt->length(), \"vector length must match\");\n+    assert(type2aelembytes(in_vt->element_basic_type()) == type2aelembytes(vt->element_basic_type()), \"element size must match\");\n+  }\n+\n+  virtual int Opcode() const;\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1880,0 +1880,1 @@\n+  declare_c2_type(VectorMaskCastNode, VectorNode)                         \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}