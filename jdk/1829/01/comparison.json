{"files":[{"patch":"@@ -89,2 +89,0 @@\n-    private static List<String> keyChains;\n-\n@@ -327,0 +325,2 @@\n+        List<String> keyChains = new ArrayList<>();\n+\n@@ -330,1 +330,1 @@\n-                addNewKeychain(params);\n+                addNewKeychain(keyChains, params);\n@@ -342,1 +342,1 @@\n-            restoreKeychainList(params);\n+            restoreKeychainList(keyChains, params);\n@@ -543,2 +543,3 @@\n-    public static void addNewKeychain(Map<String, ? super Object> params)\n-                                    throws IOException, InterruptedException {\n+    public static void addNewKeychain(List<String> keyChains,\n+            Map<String, ? super Object> params)\n+            throws IOException, InterruptedException {\n@@ -574,1 +575,1 @@\n-        keyChains = new ArrayList<>();\n+        keyChains.clear();\n@@ -596,2 +597,2 @@\n-    public static void restoreKeychainList(Map<String, ? super Object> params)\n-            throws IOException{\n+    public static void restoreKeychainList(List<String> keyChains,\n+            Map<String, ? super Object> params) throws IOException {\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacAppImageBuilder.java","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -109,0 +109,1 @@\n+        List<String> keyChains = new ArrayList<>();\n@@ -124,1 +125,1 @@\n-                MacAppImageBuilder.addNewKeychain(params);\n+                MacAppImageBuilder.addNewKeychain(keyChains, params);\n@@ -141,1 +142,1 @@\n-            MacAppImageBuilder.restoreKeychainList(params);\n+            MacAppImageBuilder.restoreKeychainList(keyChains, params);\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacAppStoreBundler.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -103,1 +103,1 @@\n-    private static boolean runtimeInstaller = false;\n+    private boolean runtimeInstaller = false;\n@@ -107,2 +107,2 @@\n-    private static Map<String, CLIOptions> argIds = new HashMap<>();\n-    private static Map<String, CLIOptions> argShortIds = new HashMap<>();\n+    private static final Map<String, CLIOptions> argIds = new HashMap<>();\n+    private static final Map<String, CLIOptions> argShortIds = new HashMap<>();\n@@ -120,0 +120,3 @@\n+    private static final InheritableThreadLocal<Arguments> instance =\n+            new InheritableThreadLocal<Arguments>();\n+\n@@ -121,0 +124,2 @@\n+        instance.set(this);\n+\n@@ -395,4 +400,0 @@\n-        static void setContext(Arguments context) {\n-            argContext = context;\n-        }\n-\n@@ -400,5 +401,1 @@\n-            if (argContext != null) {\n-                return argContext;\n-            } else {\n-                throw new RuntimeException(\"Argument context is not set.\");\n-            }\n+            return instance.get();\n@@ -465,4 +462,0 @@\n-\n-            \/\/ init context of arguments\n-            CLIOptions.setContext(this);\n-\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/Arguments.java","additions":9,"deletions":16,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -176,1 +176,1 @@\n-    static void exec(ProcessBuilder pb, boolean testForPresenceOnly,\n+    static synchronized void exec(ProcessBuilder pb, boolean testForPresenceOnly,\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/IOUtils.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -157,1 +157,1 @@\n-    private static void runJLink(Path output, List<Path> modulePath,\n+    private static synchronized void runJLink(Path output, List<Path> modulePath,\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/JLinkBundlerHelper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,2 +43,1 @@\n-    public synchronized int run(\n-            PrintWriter out, PrintWriter err, String... args) {\n+    public int run(PrintWriter out, PrintWriter err, String... args) {\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/JPackageToolProvider.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -78,2 +78,0 @@\n-            } else {\n-                System.out.println(msg);\n@@ -86,2 +84,0 @@\n-            } else {\n-                System.err.println(msg);\n@@ -95,2 +91,0 @@\n-            } else {\n-                System.err.println(msg);\n@@ -104,3 +98,0 @@\n-            } else if (verbose) {\n-                System.out.print(addTimestamp(\"\"));\n-                t.printStackTrace(System.out);\n@@ -114,2 +105,0 @@\n-            } else if (verbose) {\n-                System.out.println(msg);\n@@ -145,1 +134,6 @@\n-    private static Logger delegate = null;\n+    private static final InheritableThreadLocal<Logger> instance =\n+            new InheritableThreadLocal<Logger>() {\n+                @Override protected Logger initialValue() {\n+                    return new Logger();\n+                }\n+            };\n@@ -147,2 +141,2 @@\n-    public static void setLogger(Logger logger) {\n-        delegate = (logger != null) ? logger : new Logger();\n+    public static void setPrintWriter (PrintWriter out, PrintWriter err) {\n+        instance.get().setPrintWriter(out, err);\n@@ -152,3 +146,1 @@\n-        if (delegate != null) {\n-            delegate.flush();\n-        }\n+        instance.get().flush();\n@@ -158,3 +150,1 @@\n-        if (delegate != null) {\n-           delegate.info(msg);\n-        }\n+        instance.get().info(msg);\n@@ -164,3 +154,1 @@\n-        if (delegate != null) {\n-            delegate.fatalError(msg);\n-        }\n+        instance.get().fatalError(msg);\n@@ -170,3 +158,1 @@\n-        if (delegate != null) {\n-            delegate.error(msg);\n-        }\n+        instance.get().error(msg);\n@@ -176,3 +162,1 @@\n-        if (delegate != null) {\n-            delegate.setVerbose();\n-        }\n+        instance.get().setVerbose();\n@@ -182,1 +166,1 @@\n-        return (delegate != null) ? delegate.isVerbose() : false;\n+        return instance.get().isVerbose();\n@@ -186,3 +170,1 @@\n-        if (delegate != null) {\n-           delegate.verbose(msg);\n-        }\n+       instance.get().verbose(msg);\n@@ -192,3 +174,1 @@\n-        if (delegate != null) {\n-           delegate.verbose(t);\n-        }\n+       instance.get().verbose(t);\n@@ -198,3 +178,1 @@\n-        if (delegate != null) {\n-           delegate.verbose(strings, out, ret);\n-        }\n+       instance.get().verbose(strings, out, ret);\n@@ -202,1 +180,0 @@\n-\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/Log.java","additions":17,"deletions":40,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -49,2 +49,0 @@\n-        \/\/ Create logger with default system.out and system.err\n-        Log.setLogger(null);\n@@ -52,1 +50,3 @@\n-        int status = new jdk.jpackage.main.Main().execute(args);\n+        PrintWriter out = new PrintWriter(System.out);\n+        PrintWriter err = new PrintWriter(System.err);\n+        int status = new jdk.jpackage.main.Main().execute(out, err, args);\n@@ -65,4 +65,1 @@\n-        \/\/ Create logger with provided streams\n-        Log.Logger logger = new Log.Logger();\n-        logger.setPrintWriter(out, err);\n-        Log.setLogger(logger);\n+        Log.setPrintWriter(out, err);\n@@ -70,4 +67,0 @@\n-        return execute(args);\n-    }\n-\n-    private int execute(String... args) {\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/main\/Main.java","additions":4,"deletions":11,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,108 @@\n+\/*\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.jpackage.test.TKit;\n+import jdk.jpackage.test.PackageTest;\n+import jdk.jpackage.test.JavaAppDesc;\n+import jdk.jpackage.test.Annotations.Test;\n+import jdk.jpackage.test.Annotations.Parameter;\n+import jdk.jpackage.test.Functional;\n+import jdk.jpackage.test.HelloApp;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ExecutorService;\n+import java.nio.file.Path;\n+\n+\n+\/**\n+ * Concurrent test.  Using ToolProvider, run several jpackage test concurrently\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Concurrent jpackage command runs using ToolProvider\n+ * @library ..\/helpers\n+ * @key jpackagePlatformPackage\n+ * @build jdk.jpackage.test.*\n+ * @modules jdk.jpackage\/jdk.jpackage.internal\n+ * @compile ConcurrentTest.java\n+ * @run main\/othervm\/timeout=480 -Xmx512m jdk.jpackage.test.Main\n+ *  --jpt-run=ConcurrentTest\n+ *\/\n+public class ConcurrentTest {\n+\n+    final int TEST_COUNT = 3; \/\/ default number of jpackage commands to run\n+\n+    @Test\n+    public void test() throws Exception {\n+        final Path inputDir = TKit.workDir().resolve(\"input\");\n+        int count = TEST_COUNT;\n+        String propValue = System.getProperty(\"jpackage.concurrent.count\");\n+        if (propValue != null) {\n+            try {\n+                count = Integer.parseInt(propValue);\n+            } catch (Exception e) {\n+                \/\/ ignore - use default count\n+            }\n+        }\n+        long timeout = 2L * count; \/\/ minutes to run tests before timeout\n+        HelloApp.createBundle(JavaAppDesc.parse(\"hello.jar:Hello\"), inputDir);\n+\n+        List<Runnable> tasks = new ArrayList<>();\n+        for (int i = 0; i < count; i++) {\n+            tasks.add(Functional.ThrowingRunnable.toRunnable(() ->\n+                    initTest(inputDir).run(\n+                    PackageTest.Action.CREATE)));\n+        }\n+\n+        ExecutorService exec = Executors.newCachedThreadPool();\n+        tasks.stream().forEach(exec::execute);\n+        exec.shutdown();\n+        boolean finished = exec.awaitTermination(timeout, TimeUnit.MINUTES);\n+        \/\/ even if we are throwing assertion below we need to try to stop these\n+        \/\/ threads before exiting\n+        if (!finished) {\n+            exec.shutdownNow();\n+        }\n+        TKit.assertTrue(finished, \"Executing jpackage \" + count +\n+                \" times timed out after \" + timeout + \" minutes.\");\n+    }\n+\n+    private PackageTest initTest(Path inputDir)\n+            throws Exception {\n+        final Path outputDir;\n+        synchronized (this) {\n+            outputDir = TKit.createTempDirectory(\"output\");\n+        }\n+        return new PackageTest().addInitializer(cmd -> {\n+            cmd.useToolProvider(true);\n+            cmd.setArgumentValue(\"--input\", inputDir);\n+            cmd.setArgumentValue(\"--main-class\", \"Hello\");\n+            cmd.setArgumentValue(\"--main-jar\", \"hello.jar\");\n+            cmd.setArgumentValue(\"--dest\", outputDir);\n+            cmd.addArguments(\"--verbose\");\n+        });\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/share\/ConcurrentTest.java","additions":108,"deletions":0,"binary":false,"changes":108,"status":"added"}]}