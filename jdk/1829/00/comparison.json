{"files":[{"patch":"@@ -89,2 +89,0 @@\n-    private static List<String> keyChains;\n-\n@@ -327,0 +325,2 @@\n+        List<String> keyChains = new ArrayList<>();\n+\n@@ -330,1 +330,1 @@\n-                addNewKeychain(params);\n+                addNewKeychain(keyChains, params);\n@@ -342,1 +342,1 @@\n-            restoreKeychainList(params);\n+            restoreKeychainList(keyChains, params);\n@@ -543,2 +543,3 @@\n-    public static void addNewKeychain(Map<String, ? super Object> params)\n-                                    throws IOException, InterruptedException {\n+    public static void addNewKeychain(List<String> keyChains,\n+            Map<String, ? super Object> params)\n+            throws IOException, InterruptedException {\n@@ -574,1 +575,1 @@\n-        keyChains = new ArrayList<>();\n+        keyChains.clear();\n@@ -596,2 +597,2 @@\n-    public static void restoreKeychainList(Map<String, ? super Object> params)\n-            throws IOException{\n+    public static void restoreKeychainList(List<String> keyChains,\n+            Map<String, ? super Object> params) throws IOException {\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacAppImageBuilder.java","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -109,0 +109,1 @@\n+        List<String> keyChains = new ArrayList<>();\n@@ -124,1 +125,1 @@\n-                MacAppImageBuilder.addNewKeychain(params);\n+                MacAppImageBuilder.addNewKeychain(keyChains, params);\n@@ -141,1 +142,1 @@\n-            MacAppImageBuilder.restoreKeychainList(params);\n+            MacAppImageBuilder.restoreKeychainList(keyChains, params);\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacAppStoreBundler.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -103,1 +103,1 @@\n-    private static boolean runtimeInstaller = false;\n+    private boolean runtimeInstaller = false;\n@@ -107,2 +107,2 @@\n-    private static Map<String, CLIOptions> argIds = new HashMap<>();\n-    private static Map<String, CLIOptions> argShortIds = new HashMap<>();\n+    private static final Map<String, CLIOptions> argIds = new HashMap<>();\n+    private static final Map<String, CLIOptions> argShortIds = new HashMap<>();\n@@ -120,0 +120,3 @@\n+    private static final InheritableThreadLocal<Arguments> instance =\n+            new InheritableThreadLocal<Arguments>();\n+\n@@ -121,0 +124,2 @@\n+        instance.set(this);\n+\n@@ -395,4 +400,0 @@\n-        static void setContext(Arguments context) {\n-            argContext = context;\n-        }\n-\n@@ -400,5 +401,1 @@\n-            if (argContext != null) {\n-                return argContext;\n-            } else {\n-                throw new RuntimeException(\"Argument context is not set.\");\n-            }\n+            return instance.get();\n@@ -465,4 +462,0 @@\n-\n-            \/\/ init context of arguments\n-            CLIOptions.setContext(this);\n-\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/Arguments.java","additions":9,"deletions":16,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -43,2 +43,1 @@\n-    public synchronized int run(\n-            PrintWriter out, PrintWriter err, String... args) {\n+    public int run(PrintWriter out, PrintWriter err, String... args) {\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/JPackageToolProvider.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -78,2 +78,0 @@\n-            } else {\n-                System.out.println(msg);\n@@ -86,2 +84,0 @@\n-            } else {\n-                System.err.println(msg);\n@@ -95,2 +91,0 @@\n-            } else {\n-                System.err.println(msg);\n@@ -104,3 +98,0 @@\n-            } else if (verbose) {\n-                System.out.print(addTimestamp(\"\"));\n-                t.printStackTrace(System.out);\n@@ -114,2 +105,0 @@\n-            } else if (verbose) {\n-                System.out.println(msg);\n@@ -145,1 +134,6 @@\n-    private static Logger delegate = null;\n+    private static final InheritableThreadLocal<Logger> instance =\n+            new InheritableThreadLocal<Logger>() {\n+                @Override protected Logger initialValue() {\n+                    return new Logger();\n+                }\n+            };\n@@ -147,2 +141,2 @@\n-    public static void setLogger(Logger logger) {\n-        delegate = (logger != null) ? logger : new Logger();\n+    public static void setPrintWriter (PrintWriter out, PrintWriter err) {\n+        instance.get().setPrintWriter(out, err);\n@@ -152,3 +146,1 @@\n-        if (delegate != null) {\n-            delegate.flush();\n-        }\n+        instance.get().flush();\n@@ -158,3 +150,1 @@\n-        if (delegate != null) {\n-           delegate.info(msg);\n-        }\n+        instance.get().info(msg);\n@@ -164,3 +154,1 @@\n-        if (delegate != null) {\n-            delegate.fatalError(msg);\n-        }\n+        instance.get().fatalError(msg);\n@@ -170,3 +158,1 @@\n-        if (delegate != null) {\n-            delegate.error(msg);\n-        }\n+        instance.get().error(msg);\n@@ -176,3 +162,1 @@\n-        if (delegate != null) {\n-            delegate.setVerbose();\n-        }\n+        instance.get().setVerbose();\n@@ -182,1 +166,1 @@\n-        return (delegate != null) ? delegate.isVerbose() : false;\n+        return instance.get().isVerbose();\n@@ -186,3 +170,1 @@\n-        if (delegate != null) {\n-           delegate.verbose(msg);\n-        }\n+       instance.get().verbose(msg);\n@@ -192,3 +174,1 @@\n-        if (delegate != null) {\n-           delegate.verbose(t);\n-        }\n+       instance.get().verbose(t);\n@@ -198,3 +178,1 @@\n-        if (delegate != null) {\n-           delegate.verbose(strings, out, ret);\n-        }\n+       instance.get().verbose(strings, out, ret);\n@@ -202,1 +180,0 @@\n-\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/Log.java","additions":17,"deletions":40,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -49,2 +49,0 @@\n-        \/\/ Create logger with default system.out and system.err\n-        Log.setLogger(null);\n@@ -52,1 +50,3 @@\n-        int status = new jdk.jpackage.main.Main().execute(args);\n+        PrintWriter out = new PrintWriter(System.out);\n+        PrintWriter err = new PrintWriter(System.err);\n+        int status = new jdk.jpackage.main.Main().execute(out, err, args);\n@@ -65,4 +65,1 @@\n-        \/\/ Create logger with provided streams\n-        Log.Logger logger = new Log.Logger();\n-        logger.setPrintWriter(out, err);\n-        Log.setLogger(logger);\n+        Log.setPrintWriter(out, err);\n@@ -70,4 +67,0 @@\n-        return execute(args);\n-    }\n-\n-    private int execute(String... args) {\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/main\/Main.java","additions":4,"deletions":11,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -63,0 +63,15 @@\n+    public static PackageType getDefault() {\n+        if (TKit.isWindows()) {\n+            return WIN_EXE;\n+        } else if (TKit.isOSX()) {\n+            return MAC_DMG;\n+        } else if (TKit.isLinux()) {\n+            if (LINUX_DEB.isSupported()) {\n+                return LINUX_DEB;\n+            } else if (LINUX_RPM.isSupported()) {\n+                return LINUX_RPM;\n+            }\n+        }\n+        throw new RuntimeException(\"Failed to determine default package type\");\n+    }\n+\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/PackageType.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.util.Date;\n+import jdk.jpackage.test.TKit;\n+import jdk.jpackage.test.PackageType;\n+import jdk.jpackage.test.JPackageCommand;\n+import jdk.jpackage.test.Annotations.Test;\n+\n+\/**\n+ * Concurrent test.  Using ToolProvider, run several jpackage test concurrently\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Concurrent jpackage command runs using ToolProvider\n+ * @library ..\/helpers\n+ * @key jpackagePlatformPackage\n+ * @build jdk.jpackage.test.*\n+ * @modules jdk.jpackage\/jdk.jpackage.internal\n+ * @compile ConcurrentTest.java\n+ * @run main\/othervm\/timeout=360 -Xmx512m jdk.jpackage.test.Main\n+ *  --jpt-run=ConcurrentTest\n+ *\/\n+public class ConcurrentTest {\n+\n+    @Test\n+    public static void test() {\n+\n+        final JPackageCommand cmd1 =\n+                JPackageCommand.helloAppImage(\"com.other\/com.other.Hello\")\n+        .useToolProvider(true)\n+        .setPackageType(PackageType.getDefault())\n+        .setArgumentValue(\"--name\", \"ConcurrentOtherInstaller\");\n+\n+        final JPackageCommand cmd2 =\n+                JPackageCommand.helloAppImage(\"Hello\")\n+        .useToolProvider(true)\n+        .setPackageType(PackageType.IMAGE)\n+        .setArgumentValue(\"--name\", \"ConcurrentAppImage\");\n+\n+        Date[] times = race(cmd1, cmd2);\n+        TKit.assertTrue(times[0].after(times[1]),\n+                \"We expected app-image command to finish first, but times[0] is \"\n+                + times[0] + \" and times[1] is\" + times[1]);\n+\n+        cmd1.useToolProvider(false);\n+        cmd1.useToolProvider(false);\n+\n+        times = race(cmd1, cmd2);\n+        TKit.assertTrue(times[0].after(times[1]),\n+                \"We expected app-image command to finish first, but times[0] is \"\n+                + times[0] + \" and times[1] is\" + times[1]);\n+    }\n+\n+    private static Date[] race(JPackageCommand cmd1, JPackageCommand cmd2) {\n+        final Date[] times = new Date[2];\n+\n+        Thread t1 = new Thread(new Runnable() {\n+            public void run() {\n+                cmd1.execute();\n+                times[0] = new Date();\n+            }\n+        });\n+\n+        Thread t2 = new Thread(new Runnable() {\n+            public void run() {\n+                cmd2.execute();\n+                times[1] = new Date();\n+            }\n+        });\n+        try {\n+            t1.start();\n+            t2.start();\n+\n+            t1.join();\n+            t2.join();\n+            return times;\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/share\/ConcurrentTest.java","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"}]}