{"files":[{"patch":"@@ -521,1 +521,1 @@\n-  init((intptr_t*)sp, (intptr_t*)fp, (address)pc);\n+  init((intptr_t*)sp, (intptr_t*)sp, (intptr_t*)fp, (address)pc);\n","filename":"src\/hotspot\/cpu\/arm\/frame_arm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -108,1 +108,1 @@\n-  void init(intptr_t* sp, intptr_t* fp, address pc);\n+  void init(intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, address pc);\n","filename":"src\/hotspot\/cpu\/arm\/frame_arm.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+  _oop_map = NULL;\n@@ -50,1 +51,1 @@\n-inline void frame::init(intptr_t* sp, intptr_t* fp, address pc) {\n+inline void frame::init(intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, address pc) {\n@@ -52,1 +53,1 @@\n-  _unextended_sp = sp;\n+  _unextended_sp = unextended_sp;\n@@ -63,0 +64,2 @@\n+    assert(_cb->as_compiled_method()->insts_contains_inclusive(_pc),\n+           \"original PC must be in the main code section of the the compiled method (or must be immediately following it)\");\n@@ -68,0 +71,1 @@\n+  _oop_map = NULL;\n@@ -71,1 +75,1 @@\n-  init(sp, fp, pc);\n+  init(sp, sp, fp, pc);\n@@ -75,19 +79,1 @@\n-  _sp = sp;\n-  _unextended_sp = unextended_sp;\n-  _fp = fp;\n-  _pc = pc;\n-  assert(pc != NULL, \"no pc?\");\n-  _cb = CodeCache::find_blob(pc);\n-  adjust_unextended_sp();\n-  DEBUG_ONLY(_frame_index = -1;)\n-\n-  address original_pc = CompiledMethod::get_deopt_original_pc(this);\n-  if (original_pc != NULL) {\n-    _pc = original_pc;\n-    assert(_cb->as_compiled_method()->insts_contains_inclusive(_pc),\n-           \"original PC must be in the main code section of the compiled method (or must be immediately following it)\");\n-    _deopt_state = is_deoptimized;\n-  } else {\n-    _deopt_state = not_deoptimized;\n-  }\n-  _on_heap = false;\n+  init(sp, unextended_sp, fp, pc);\n@@ -96,1 +82,0 @@\n-\n@@ -98,18 +83,3 @@\n-  _sp = sp;\n-  _unextended_sp = sp;\n-  _fp = fp;\n-  assert(sp != NULL,\"null SP ?\");\n-  _pc = (address)(sp[-1]);\n-  \/\/ assert(_pc != NULL, \"no pc?\"); \/\/ see comments in x86\n-  _cb = CodeCache::find_blob(_pc);\n-  adjust_unextended_sp();\n-  DEBUG_ONLY(_frame_index = -1;)\n-\n-  address original_pc = CompiledMethod::get_deopt_original_pc(this);\n-  if (original_pc != NULL) {\n-    _pc = original_pc;\n-    _deopt_state = is_deoptimized;\n-  } else {\n-    _deopt_state = not_deoptimized;\n-  }\n-  _on_heap = false;\n+  assert(sp != NULL, \"null SP?\");\n+  address pc = (address)(sp[-1]);\n+  init(sp, sp, fp, pc);\n@@ -246,1 +216,10 @@\n-  Unimplemented();\n+  if (_cb == NULL) return NULL;\n+  if (_cb->oop_maps() != NULL) {\n+    NativePostCallNop* nop = nativePostCallNop_at(_pc);\n+    if (nop != NULL && nop->displacement() != 0) {\n+      int slot = ((nop->displacement() >> 24) & 0xff);\n+      return _cb->oop_map_for_slot(slot, _pc);\n+    }\n+    const ImmutableOopMap* oop_map = OopMapSet::find_map(this);\n+    return oop_map;\n+  }\n","filename":"src\/hotspot\/cpu\/arm\/frame_arm.inline.hpp","additions":21,"deletions":42,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -340,0 +340,22 @@\n+void NativePostCallNop::make_deopt() {\n+  NativeDeoptInstruction::insert(addr_at(0));\n+}\n+\n+void NativePostCallNop::patch(jint diff) {\n+  \/\/ unsupported for now\n+}\n+\n+void NativeDeoptInstruction::verify() {\n+}\n+\n+\/\/ Inserts an undefined instruction at a given pc\n+void NativeDeoptInstruction::insert(address code_pos) {\n+  \/\/ UDF, Encoding A1:\n+  \/\/ 1 1 1 0 | 0 1 1 1 | 1 1 1 1 | imm12 | 1 1 1 1 | imm4 |\n+  \/\/ e       | 7       | f       | dec   | f       | a    |\n+  \/\/ 0xe7              | 0xfd, 0xec      | 0xfa\n+  uint32_t insn = 0xe7fdecfa;\n+  uint32_t *pos = (uint32_t *) code_pos;\n+  *pos = insn;\n+  ICache::invalidate_range(code_pos, 4);\n+}\n","filename":"src\/hotspot\/cpu\/arm\/nativeInst_arm_32.cpp","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -437,4 +437,4 @@\n-  bool check() const { Unimplemented(); return false; }\n-  int displacement() const { Unimplemented(); return 0; }\n-  void patch(jint diff) { Unimplemented(); }\n-  void make_deopt() { Unimplemented(); }\n+  bool check() const { return is_nop(); }\n+  int displacement() const { return 0; }\n+  void patch(jint diff);\n+  void make_deopt();\n@@ -444,1 +444,4 @@\n-  Unimplemented();\n+  NativePostCallNop* nop = (NativePostCallNop*) address;\n+  if (nop->check()) {\n+    return nop;\n+  }\n@@ -450,2 +453,4 @@\n-  address instruction_address() const       { Unimplemented(); return NULL; }\n-  address next_instruction_address() const  { Unimplemented(); return NULL; }\n+  enum {\n+    instruction_size            =    4,\n+    instruction_offset          =    0,\n+  };\n@@ -453,1 +458,4 @@\n-  void  verify() { Unimplemented(); }\n+  address instruction_address() const       { return addr_at(instruction_offset); }\n+  address next_instruction_address() const  { return addr_at(instruction_size); }\n+\n+  void  verify();\n@@ -456,2 +464,3 @@\n-    Unimplemented();\n-    return false;\n+    assert(instr != NULL, \"\");\n+    uint32_t value = *(uint32_t *) instr;\n+    return value == 0xe7fdecfa;\n@@ -461,3 +470,1 @@\n-  static void insert(address code_pos) {\n-    Unimplemented();\n-  }\n+  static void insert(address code_pos);\n","filename":"src\/hotspot\/cpu\/arm\/nativeInst_arm_32.hpp","additions":20,"deletions":13,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2962,0 +2962,79 @@\n+  RuntimeStub* generate_cont_doYield() {\n+    if (!Continuations::enabled()) return nullptr;\n+    Unimplemented();\n+    return nullptr;\n+  }\n+\n+  address generate_cont_thaw(const char* label, Continuation::thaw_kind kind) {\n+    if (!Continuations::enabled()) return nullptr;\n+    Unimplemented();\n+    return nullptr;\n+  }\n+\n+  address generate_cont_thaw() {\n+    return generate_cont_thaw(\"Cont thaw\", Continuation::thaw_top);\n+  }\n+\n+  address generate_cont_returnBarrier() {\n+    return generate_cont_thaw(\"Cont thaw return barrier\", Continuation::thaw_return_barrier);\n+  }\n+\n+  address generate_cont_returnBarrier_exception() {\n+    return generate_cont_thaw(\"Cont thaw return barrier exception\", Continuation::thaw_return_barrier_exception);\n+  }\n+\n+#if INCLUDE_JFR\n+\n+  \/\/ For c2: c_rarg0 is junk, call to runtime to write a checkpoint.\n+  \/\/ It returns a jobject handle to the event writer.\n+  \/\/ The handle is dereferenced and the return value is the event writer oop.\n+  static RuntimeStub* generate_jfr_write_checkpoint() {\n+    enum layout {\n+      r1_off,\n+      r2_off,\n+      return_off,\n+      framesize \/\/ inclusive of return address\n+    };\n+\n+    CodeBuffer code(\"jfr_write_checkpoint\", 512, 64);\n+    MacroAssembler* masm = new MacroAssembler(&code);\n+\n+    address start = __ pc();\n+    __ raw_push(R1, R2, LR);\n+    address the_pc = __ pc();\n+\n+    int frame_complete = the_pc - start;\n+\n+    __ set_last_Java_frame(SP, FP, true, Rtemp);\n+    __ mov(c_rarg0, Rthread);\n+    __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::write_checkpoint), c_rarg0);\n+    __ reset_last_Java_frame(Rtemp);\n+\n+    \/\/ R0 is jobject handle result, unpack and process it through a barrier.\n+    Label L_null_jobject;\n+    __ cbz(R0, L_null_jobject);\n+\n+    BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n+    bs->load_at(masm, ACCESS_READ | IN_NATIVE, T_OBJECT, R0, Address(R0, 0), Rtemp, R1, R2);\n+\n+    __ bind(L_null_jobject);\n+\n+    __ raw_pop(R1, R2, LR);\n+    __ ret();\n+\n+    OopMapSet* oop_maps = new OopMapSet();\n+    OopMap* map = new OopMap(framesize, 1);\n+    oop_maps->add_gc_map(frame_complete, map);\n+\n+    RuntimeStub* stub =\n+      RuntimeStub::new_runtime_stub(code.name(),\n+                                    &code,\n+                                    frame_complete,\n+                                    (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                    oop_maps,\n+                                    false);\n+    return stub;\n+  }\n+\n+#endif \/\/ INCLUDE_JFR\n+\n@@ -2994,0 +3073,12 @@\n+  void generate_phase1() {\n+    \/\/ Continuation stubs:\n+    StubRoutines::_cont_thaw          = generate_cont_thaw();\n+    StubRoutines::_cont_returnBarrier = generate_cont_returnBarrier();\n+    StubRoutines::_cont_returnBarrierExc = generate_cont_returnBarrier_exception();\n+    StubRoutines::_cont_doYield_stub = generate_cont_doYield();\n+    StubRoutines::_cont_doYield      = StubRoutines::_cont_doYield_stub == nullptr ? nullptr\n+                                                                                   : StubRoutines::_cont_doYield_stub->entry_point();\n+\n+    JFR_ONLY(StubRoutines::_jfr_write_checkpoint_stub = generate_jfr_write_checkpoint();)\n+    JFR_ONLY(StubRoutines::_jfr_write_checkpoint = StubRoutines::_jfr_write_checkpoint_stub->entry_point();)\n+  }\n@@ -3032,4 +3123,2 @@\n-  StubGenerator(CodeBuffer* code, bool all) : StubCodeGenerator(code) {\n-    if (all) {\n-      generate_all();\n-    } else {\n+  StubGenerator(CodeBuffer* code, int phase) : StubCodeGenerator(code) {\n+    if (phase == 0) {\n@@ -3037,0 +3126,4 @@\n+    } else if (phase == 1) {\n+      generate_phase1();\n+    } else {\n+      generate_all();\n","filename":"src\/hotspot\/cpu\/arm\/stubGenerator_arm.cpp","additions":97,"deletions":4,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -732,0 +732,1 @@\n+  if (!Continuations::enabled()) return nullptr;\n","filename":"src\/hotspot\/cpu\/arm\/templateInterpreterGenerator_arm.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}