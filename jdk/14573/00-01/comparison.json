{"files":[{"patch":"@@ -460,1 +460,1 @@\n-  SourceObjInfo src_info(orig_src_obj, p->buffered_addr());\n+  SourceObjInfo orig_src_info(orig_src_obj, p);\n@@ -462,2 +462,2 @@\n-  _src_obj_table.put_if_absent(orig_src_obj, src_info, &created);\n-  assert(created, \"We shouldn't have archived the original copy of an regenerated object\");\n+  _src_obj_table.put_if_absent(orig_src_obj, orig_src_info, &created);\n+  assert(created, \"We shouldn't have archived the original copy of a regenerated object\");\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -145,4 +145,9 @@\n-    SourceObjInfo(address src, address buf) {\n-      _source_addr = src;\n-      _buffered_addr = buf;\n-    }\n+\n+    \/\/ This constructor is only used for regenerated objects (created by LambdaFormInvokers, etc).\n+    \/\/   src = address of a Method or InstanceKlass that has been regenerated.\n+    \/\/   renegerated_obj_info = info for the regenerated version of src.\n+    SourceObjInfo(address src, SourceObjInfo* renegerated_obj_info) :\n+      _ptrmap_start(0), _ptrmap_end(0), _read_only(false),\n+      _follow_mode(renegerated_obj_info->_follow_mode),\n+      _size_in_bytes(0), _msotype(renegerated_obj_info->_msotype),\n+      _source_addr(src),  _buffered_addr(renegerated_obj_info->_buffered_addr) {}\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.hpp","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+#include \"utilities\/growableArray.hpp\"\n+#include \"utilities\/resourceHash.hpp\"\n@@ -35,2 +37,3 @@\n-RegeneratedClasses::RegeneratedObjTable* RegeneratedClasses::_renegerated_objs = nullptr;\n-GrowableArrayCHeap<OopHandle, mtClassShared>* RegeneratedClasses::_regenerated_mirrors = nullptr;\n+using RegeneratedObjTable = ResourceHashtable<address, address, 15889, AnyObj::C_HEAP, mtClassShared>;\n+static RegeneratedObjTable* _renegerated_objs = nullptr; \/\/ InstanceKlass* and Method*\n+static GrowableArrayCHeap<OopHandle, mtClassShared>* _regenerated_mirrors = nullptr;\n@@ -75,0 +78,1 @@\n+  assert(SafepointSynchronize::is_at_safepoint(), \"must be\");\n","filename":"src\/hotspot\/share\/cds\/regeneratedClasses.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -29,4 +29,1 @@\n-#include \"oops\/oopHandle.hpp\"\n-#include \"runtime\/handles.hpp\"\n-#include \"utilities\/growableArray.hpp\"\n-#include \"utilities\/resourceHash.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -34,0 +31,10 @@\n+class InstanceKlass;\n+\n+\/\/ CDS regenerates some of the classes that are loaded normally during the dumping\n+\/\/ process. For example, LambdaFormInvokers creates new versions of the four\n+\/\/ java.lang.invoke.xxx$Holder classes that have additional methods.\n+\/\/\n+\/\/ RegeneratedClasses records the relocation between the \"original\" and\n+\/\/ \"regenerated\" versions of these classes. When writing the CDS archive, all\n+\/\/ references to the \"original\" versions are redirected to the \"regenerated\"\n+\/\/ versions.\n@@ -35,4 +42,0 @@\n- private:\n-  using RegeneratedObjTable = ResourceHashtable<address, address, 15889, AnyObj::C_HEAP, mtClassShared>;\n-  static RegeneratedObjTable* _renegerated_objs; \/\/ InstanceKlass* and Method*\n-  static GrowableArrayCHeap<OopHandle, mtClassShared>* _regenerated_mirrors;\n@@ -40,1 +43,1 @@\n-  static void add_class(InstanceKlass* src_klass, InstanceKlass* regen_klass);\n+  static void add_class(InstanceKlass* orig_klass, InstanceKlass* regen_klass);\n","filename":"src\/hotspot\/share\/cds\/regeneratedClasses.hpp","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"}]}