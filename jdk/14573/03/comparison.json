{"files":[{"patch":"@@ -33,0 +33,1 @@\n+#include \"cds\/regeneratedClasses.hpp\"\n@@ -416,0 +417,4 @@\n+  if (RegeneratedClasses::has_been_regenerated(src_obj)) {\n+    \/\/ No need to copy it. We will later relocate it to point to the regenerated klass\/method.\n+    return false;\n+  }\n@@ -428,0 +433,8 @@\n+#ifdef ASSERT\n+  if (ref->msotype() == MetaspaceObj::MethodType) {\n+    Method* m = (Method*)ref->obj();\n+    assert(!RegeneratedClasses::has_been_regenerated((address)m->method_holder()),\n+           \"Should not archive methods in a class that has been regenerated\");\n+  }\n+#endif\n+\n@@ -442,0 +455,11 @@\n+void ArchiveBuilder::record_regenerated_object(address orig_src_obj, address regen_src_obj) {\n+  \/\/ Record the fact that orig_src_obj has been replaced by regen_src_obj. All calls to get_buffered_addr(orig_src_obj)\n+  \/\/ should return the same value as get_buffered_addr(regen_src_obj).\n+  SourceObjInfo* p = _src_obj_table.get(regen_src_obj);\n+  assert(p != nullptr, \"regenerated object should always be dumped\");\n+  SourceObjInfo orig_src_info(orig_src_obj, p);\n+  bool created;\n+  _src_obj_table.put_if_absent(orig_src_obj, orig_src_info, &created);\n+  assert(created, \"We shouldn't have archived the original copy of a regenerated object\");\n+}\n+\n@@ -586,0 +610,2 @@\n+\n+  RegeneratedClasses::record_regenerated_objects();\n@@ -640,1 +666,1 @@\n-\/\/ This is used by code that hand-assemble data structures, such as the LambdaProxyClassKey, that are\n+\/\/ This is used by code that hand-assembles data structures, such as the LambdaProxyClassKey, that are\n@@ -655,1 +681,2 @@\n-  assert(p != nullptr, \"must be\");\n+  assert(p != nullptr, \"src_addr \" INTPTR_FORMAT \" is used but has not been archived\",\n+         p2i(src_addr));\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":29,"deletions":2,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -146,0 +146,9 @@\n+    \/\/ This constructor is only used for regenerated objects (created by LambdaFormInvokers, etc).\n+    \/\/   src = address of a Method or InstanceKlass that has been regenerated.\n+    \/\/   renegerated_obj_info = info for the regenerated version of src.\n+    SourceObjInfo(address src, SourceObjInfo* renegerated_obj_info) :\n+      _ptrmap_start(0), _ptrmap_end(0), _read_only(false),\n+      _follow_mode(renegerated_obj_info->_follow_mode),\n+      _size_in_bytes(0), _msotype(renegerated_obj_info->_msotype),\n+      _source_addr(src),  _buffered_addr(renegerated_obj_info->_buffered_addr) {}\n+\n@@ -371,0 +380,1 @@\n+  void record_regenerated_object(address orig_src_obj, address regen_src_obj);\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -32,2 +32,1 @@\n-#include \"cds\/lambdaFormInvokers.hpp\"\n-#include \"cds\/metaspaceShared.hpp\"\n+#include \"cds\/regeneratedClasses.hpp\"\n@@ -349,1 +348,1 @@\n-    LambdaFormInvokers::cleanup_regenerated_classes();\n+    RegeneratedClasses::cleanup();\n","filename":"src\/hotspot\/share\/cds\/dynamicArchive.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"cds\/regeneratedClasses.hpp\"\n@@ -54,1 +55,0 @@\n-GrowableArrayCHeap<OopHandle, mtClassShared>* LambdaFormInvokers::_regenerated_mirrors = nullptr;\n@@ -80,18 +80,0 @@\n-\/\/ The regenerated Klass is not added to any class loader, so we need\n-\/\/ to keep its java_mirror alive to avoid class unloading.\n-void LambdaFormInvokers::add_regenerated_class(oop regenerated_class) {\n-  if (_regenerated_mirrors == nullptr) {\n-    _regenerated_mirrors = new GrowableArrayCHeap<OopHandle, mtClassShared>(150);\n-  }\n-  _regenerated_mirrors->append(OopHandle(Universe::vm_global(), regenerated_class));\n-}\n-\n-void LambdaFormInvokers::cleanup_regenerated_classes() {\n-  if (_regenerated_mirrors == nullptr) return;\n-\n-  for (int i = 0; i < _regenerated_mirrors->length(); i++) {\n-    _regenerated_mirrors->at(i).release(Universe::vm_global());\n-  }\n-  delete _regenerated_mirrors;\n-  _regenerated_mirrors = nullptr;\n-}\n@@ -210,1 +192,1 @@\n-  add_regenerated_class(result->java_mirror());\n+  RegeneratedClasses::add_class(InstanceKlass::cast(klass), result);\n","filename":"src\/hotspot\/share\/cds\/lambdaFormInvokers.cpp","additions":2,"deletions":20,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,0 @@\n-  static GrowableArrayCHeap<OopHandle, mtClassShared>* _regenerated_mirrors;\n@@ -43,1 +42,0 @@\n-  static void add_regenerated_class(oop regenerated_class);\n","filename":"src\/hotspot\/share\/cds\/lambdaFormInvokers.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,99 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"cds\/archiveBuilder.hpp\"\n+#include \"cds\/regeneratedClasses.hpp\"\n+#include \"memory\/universe.hpp\"\n+#include \"oops\/instanceKlass.hpp\"\n+#include \"oops\/method.hpp\"\n+#include \"oops\/oopHandle.inline.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n+#include \"runtime\/thread.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+#include \"utilities\/resourceHash.hpp\"\n+\n+using RegeneratedObjTable = ResourceHashtable<address, address, 15889, AnyObj::C_HEAP, mtClassShared>;\n+static RegeneratedObjTable* _renegerated_objs = nullptr; \/\/ InstanceKlass* and Method*\n+static GrowableArrayCHeap<OopHandle, mtClassShared>* _regenerated_mirrors = nullptr;\n+\n+\/\/ The regenerated Klass is not added to any class loader, so we need\n+\/\/ to keep its java_mirror alive to avoid class unloading.\n+void RegeneratedClasses::add_class(InstanceKlass* orig_klass, InstanceKlass* regen_klass) {\n+  MutexLocker ml(DumpTimeTable_lock, Mutex::_no_safepoint_check_flag);\n+  if (_regenerated_mirrors == nullptr) {\n+    _regenerated_mirrors = new GrowableArrayCHeap<OopHandle, mtClassShared>(150);\n+  }\n+  _regenerated_mirrors->append(OopHandle(Universe::vm_global(), regen_klass->java_mirror()));\n+\n+  if (_renegerated_objs == nullptr) {\n+    _renegerated_objs = new (mtClass)RegeneratedObjTable();\n+  }\n+\n+  _renegerated_objs->put((address)orig_klass, (address)regen_klass);\n+  Array<Method*>* methods = orig_klass->methods();\n+  for (int i = 0; i < methods->length(); i++) {\n+    Method* orig_m = methods->at(i);\n+    Method* regen_m = regen_klass->find_method(orig_m->name(), orig_m->signature());\n+    if (regen_m == nullptr) {\n+      ResourceMark rm;\n+      log_warning(cds)(\"Method in original class is missing from regenerated class: \" INTPTR_FORMAT \" %s\",\n+                       p2i(orig_m), orig_m->external_name());\n+    } else {\n+      _renegerated_objs->put((address)orig_m, (address)regen_m);\n+    }\n+  }\n+}\n+\n+bool RegeneratedClasses::has_been_regenerated(address orig_obj) {\n+  if (_renegerated_objs == nullptr) {\n+    return false;\n+  } else {\n+    return _renegerated_objs->get(orig_obj) != nullptr;\n+  }\n+}\n+\n+void RegeneratedClasses::record_regenerated_objects() {\n+  assert_locked_or_safepoint(DumpTimeTable_lock);\n+  if (_renegerated_objs != nullptr) {\n+    auto doit = [&] (address orig_obj, address regen_obj) {\n+      ArchiveBuilder::current()->record_regenerated_object(orig_obj, regen_obj);\n+    };\n+    _renegerated_objs->iterate_all(doit);\n+  }\n+}\n+\n+void RegeneratedClasses::cleanup() {\n+  MutexLocker ml(DumpTimeTable_lock, Mutex::_no_safepoint_check_flag);\n+  if (_regenerated_mirrors != nullptr) {\n+    for (int i = 0; i < _regenerated_mirrors->length(); i++) {\n+      _regenerated_mirrors->at(i).release(Universe::vm_global());\n+    }\n+    delete _regenerated_mirrors;\n+    _regenerated_mirrors = nullptr;\n+  }\n+  if (_renegerated_objs != nullptr) {\n+    delete _renegerated_objs;\n+  }\n+}\n","filename":"src\/hotspot\/share\/cds\/regeneratedClasses.cpp","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_CDS_REGENERATEDCLASSES_HPP\n+#define SHARE_CDS_REGENERATEDCLASSES_HPP\n+\n+#include \"memory\/allStatic.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+class InstanceKlass;\n+\n+\/\/ CDS regenerates some of the classes that are loaded normally during the dumping\n+\/\/ process. For example, LambdaFormInvokers creates new versions of the four\n+\/\/ java.lang.invoke.xxx$Holder classes that have additional methods.\n+\/\/\n+\/\/ RegeneratedClasses records the relocation between the \"original\" and\n+\/\/ \"regenerated\" versions of these classes. When writing the CDS archive, all\n+\/\/ references to the \"original\" versions are redirected to the \"regenerated\"\n+\/\/ versions.\n+class RegeneratedClasses : public AllStatic {\n+ public:\n+  static void add_class(InstanceKlass* orig_klass, InstanceKlass* regen_klass);\n+  static void cleanup();\n+  static bool has_been_regenerated(address orig_obj);\n+  static void record_regenerated_objects();\n+};\n+\n+#endif \/\/ SHARE_CDS_REGENERATEDCLASSES_HPP\n","filename":"src\/hotspot\/share\/cds\/regeneratedClasses.hpp","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"}]}