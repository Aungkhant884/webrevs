{"files":[{"patch":"@@ -39,0 +39,1 @@\n+import java.util.function.Function;\n@@ -390,4 +391,6 @@\n-            if (member.isField())\n-                updateForm(preparedFieldLambdaForm(member));\n-            else\n-                updateForm(preparedLambdaForm(member));\n+            updateForm(new Function<>() {\n+                public LambdaForm apply(LambdaForm oldForm) {\n+                    return (member.isField() ? preparedFieldLambdaForm(member)\n+                                             : preparedLambdaForm(member));\n+                }\n+            });\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/DirectMethodHandle.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -599,3 +599,5 @@\n-        if (MethodHandleImpl.isCompileConstant(mh)) return;\n-        if (mh.form.customized == null) {\n-            maybeCustomize(mh);\n+        if (MethodHandleImpl.isCompileConstant(mh)) {\n+            return; \/\/ no need to customize a MH when the instance is known to JIT\n+        }\n+        if (mh.form.customized == null) { \/\/ fast approximate check that the underlying form is already customized\n+            maybeCustomize(mh); \/\/ marked w\/ @DontInline\n@@ -606,1 +608,0 @@\n-    \/*non-public*\/\n@@ -608,6 +609,1 @@\n-        byte count = mh.customizationCount;\n-        if (count >= CUSTOMIZE_THRESHOLD) {\n-            mh.customize();\n-        } else {\n-            mh.customizationCount = (byte)(count+1);\n-        }\n+        mh.maybeCustomize();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/Invokers.java","additions":6,"deletions":10,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -504,0 +504,3 @@\n+        if (customized == mh) {\n+            return this;\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaForm.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import java.lang.constant.ConstantDesc;\n@@ -40,0 +39,1 @@\n+import java.util.function.Function;\n@@ -458,0 +458,1 @@\n+\n@@ -459,2 +460,1 @@\n-    byte customizationCount;\n-    \/\/ customizationCount should be accessible from invokers\n+    private byte customizationCount;\n@@ -1736,0 +1736,25 @@\n+    \/* non-public *\/\n+    void maybeCustomize() {\n+        if (form.customized == null) {\n+            byte count = customizationCount;\n+            if (count >= CUSTOMIZE_THRESHOLD) {\n+                customize();\n+            } else {\n+                customizationCount = (byte) (count + 1);\n+            }\n+        }\n+    }\n+\n+    \/** Craft a LambdaForm customized for this particular MethodHandle. *\/\n+    \/*non-public*\/\n+    void customize() {\n+        final MethodHandle mh = this;\n+        updateForm(new Function<>() {\n+                public LambdaForm apply(LambdaForm oldForm) {\n+                    return oldForm.customize(mh);\n+                }\n+            });\n+    }\n+\n+    private volatile boolean updateInProgress = false;\n+\n@@ -1744,15 +1769,15 @@\n-    void updateForm(LambdaForm newForm) {\n-        assert(newForm.customized == null || newForm.customized == this);\n-        if (form == newForm)  return;\n-        newForm.prepare();  \/\/ as in MethodHandle.<init>\n-        UNSAFE.putReference(this, FORM_OFFSET, newForm);\n-        UNSAFE.fullFence();\n-    }\n-\n-    \/** Craft a LambdaForm customized for this particular MethodHandle *\/\n-    \/*non-public*\/\n-    void customize() {\n-        final LambdaForm form = this.form;\n-        if (form.customized == null) {\n-            LambdaForm newForm = form.customize(this);\n-            updateForm(newForm);\n+    void updateForm(Function<LambdaForm,LambdaForm> updater) {\n+        if (UNSAFE.compareAndSetBoolean(this, UPDATE_OFFSET, false, true)) { \/\/ updateInProgress = true\n+            \/\/ Only 1 thread wins the race and updates MH.form field.\n+            try {\n+                LambdaForm oldForm = form;\n+                LambdaForm newForm = updater.apply(oldForm);\n+                if (oldForm != newForm) {\n+                    assert (newForm.customized == null || newForm.customized == this);\n+                    newForm.prepare(); \/\/ as in MethodHandle.<init>\n+                    UNSAFE.putReference(this, FORM_OFFSET, newForm);\n+                    UNSAFE.fullFence();\n+                }\n+            } finally {\n+                updateInProgress = false;\n+            }\n@@ -1760,1 +1785,1 @@\n-            assert(form.customized == this);\n+            \/\/ Update got lost due to concurrent update. But callers don't care.\n@@ -1764,2 +1789,2 @@\n-    private static final long FORM_OFFSET\n-            = UNSAFE.objectFieldOffset(MethodHandle.class, \"form\");\n+    private static final long   FORM_OFFSET = UNSAFE.objectFieldOffset(MethodHandle.class, \"form\");\n+    private static final long UPDATE_OFFSET = UNSAFE.objectFieldOffset(MethodHandle.class, \"updateInProgress\");\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandle.java","additions":46,"deletions":21,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -844,12 +844,0 @@\n-        \/\/ Customize target if counting happens for too long.\n-        private int invocations = CUSTOMIZE_THRESHOLD;\n-        private void maybeCustomizeTarget() {\n-            int c = invocations;\n-            if (c >= 0) {\n-                if (c == 1) {\n-                    target.customize();\n-                }\n-                invocations = c - 1;\n-            }\n-        }\n-\n@@ -858,1 +846,1 @@\n-            maybeCustomizeTarget();\n+            target.maybeCustomize(); \/\/ customize if counting happens for too long\n@@ -875,1 +863,1 @@\n-             CountingWrapper wrapper = (CountingWrapper) o1;\n+             final CountingWrapper wrapper = (CountingWrapper) o1;\n@@ -878,3 +866,6 @@\n-                 LambdaForm lform = wrapper.nonCountingFormProducer.apply(wrapper.target);\n-                 lform.compileToBytecode(); \/\/ speed up warmup by avoiding LF interpretation again after transition\n-                 wrapper.updateForm(lform);\n+                 wrapper.updateForm(new Function<>() {\n+                     public LambdaForm apply(LambdaForm oldForm) {\n+                         LambdaForm lform = wrapper.nonCountingFormProducer.apply(wrapper.target);\n+                         lform.compileToBytecode(); \/\/ speed up warmup by avoiding LF interpretation again after transition\n+                         return lform;\n+                     }});\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":8,"deletions":17,"binary":false,"changes":25,"status":"modified"}]}