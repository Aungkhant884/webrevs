{"files":[{"patch":"@@ -3315,11 +3315,13 @@\n-\/\/ Parallel Reference Processing closures\n-\n-\/\/ Implementation of AbstractRefProcTaskExecutor for parallel reference\n-\/\/ processing during G1 evacuation pauses.\n-\n-class G1STWRefProcTaskExecutor: public AbstractRefProcTaskExecutor {\n-private:\n-  G1CollectedHeap*          _g1h;\n-  G1ParScanThreadStateSet*  _pss;\n-  G1ScannerTasksQueueSet*   _queues;\n-  WorkGang*                 _workers;\n+class G1STWRefProcClosureContext : public AbstractClosureContext {\n+  uint                           _max_workers;\n+  uint                           _queues;\n+  G1CollectedHeap&               _g1h;\n+  G1ParScanThreadStateSet&       _pss;\n+  G1ScannerTasksQueueSet&        _task_queues;\n+  TaskTerminator                 _terminator;\n+  G1STWIsAliveClosure            _is_alive;\n+  G1CopyingKeepAliveClosure*     _keep_alive;\n+  G1ParEvacuateFollowersClosure* _parallel_complete_gc;\n+  G1CopyingKeepAliveClosure      _serial_keep_alive;\n+  G1STWDrainQueueClosure         _serial_complete_gc;\n+  ThreadModel                    _tm;\n@@ -3328,10 +3330,30 @@\n-  G1STWRefProcTaskExecutor(G1CollectedHeap* g1h,\n-                           G1ParScanThreadStateSet* per_thread_states,\n-                           WorkGang* workers,\n-                           G1ScannerTasksQueueSet *task_queues) :\n-    _g1h(g1h),\n-    _pss(per_thread_states),\n-    _queues(task_queues),\n-    _workers(workers)\n-  {\n-    g1h->ref_processor_stw()->set_active_mt_degree(workers->active_workers());\n+  G1STWRefProcClosureContext(\n+    uint max_workers,\n+    G1CollectedHeap& g1h,\n+    G1ParScanThreadStateSet& pss,\n+    G1ScannerTasksQueueSet& task_queues)\n+    : _max_workers(max_workers),\n+      _queues(0),\n+      _g1h(g1h),\n+      _pss(pss),\n+      _task_queues(task_queues),\n+      _terminator(_max_workers, &task_queues),\n+      _is_alive(&g1h),\n+      _keep_alive(NEW_C_HEAP_ARRAY(G1CopyingKeepAliveClosure, _max_workers, mtGC)),\n+      _parallel_complete_gc(NEW_C_HEAP_ARRAY(G1ParEvacuateFollowersClosure, _max_workers, mtGC)),\n+      _serial_keep_alive(&g1h, _pss.state_for_worker(0)),\n+      _serial_complete_gc(&g1h, _pss.state_for_worker(0)),\n+      _tm(ThreadModel::Single) {}\n+\n+  ~G1STWRefProcClosureContext() {\n+    FREE_C_HEAP_ARRAY(G1CopyingKeepAliveClosure, _keep_alive);\n+    FREE_C_HEAP_ARRAY(G1ParEvacuateFollowersClosure, _parallel_complete_gc);\n+  }\n+\n+  BoolObjectClosure* is_alive(uint worker_id) { return &_is_alive; }\n+  OopClosure* keep_alive(uint worker_id) {\n+    assert(worker_id < _queues || _tm == ThreadModel::Single, \"sanity\");\n+    if (_tm == ThreadModel::Single) {\n+      return ::new (&_serial_keep_alive) G1CopyingKeepAliveClosure(&_g1h, _pss.state_for_worker(0));\n+    }\n+    return ::new (&_keep_alive[worker_id]) G1CopyingKeepAliveClosure(&_g1h, _pss.state_for_worker(worker_id));\n@@ -3339,51 +3361,6 @@\n-\n-  \/\/ Executes the given task using concurrent marking worker threads.\n-  virtual void execute(ProcessTask& task, uint ergo_workers);\n-};\n-\n-\/\/ Gang task for possibly parallel reference processing\n-\n-class G1STWRefProcTaskProxy: public AbstractGangTask {\n-  typedef AbstractRefProcTaskExecutor::ProcessTask ProcessTask;\n-  ProcessTask&     _proc_task;\n-  G1CollectedHeap* _g1h;\n-  G1ParScanThreadStateSet* _pss;\n-  G1ScannerTasksQueueSet* _task_queues;\n-  TaskTerminator* _terminator;\n-\n-public:\n-  G1STWRefProcTaskProxy(ProcessTask& proc_task,\n-                        G1CollectedHeap* g1h,\n-                        G1ParScanThreadStateSet* per_thread_states,\n-                        G1ScannerTasksQueueSet *task_queues,\n-                        TaskTerminator* terminator) :\n-    AbstractGangTask(\"Process reference objects in parallel\"),\n-    _proc_task(proc_task),\n-    _g1h(g1h),\n-    _pss(per_thread_states),\n-    _task_queues(task_queues),\n-    _terminator(terminator)\n-  {}\n-\n-  virtual void work(uint worker_id) {\n-    \/\/ The reference processing task executed by a single worker.\n-    ResourceMark rm;\n-\n-    G1STWIsAliveClosure is_alive(_g1h);\n-\n-    G1ParScanThreadState* pss = _pss->state_for_worker(worker_id);\n-    pss->set_ref_discoverer(NULL);\n-\n-    \/\/ Keep alive closure.\n-    G1CopyingKeepAliveClosure keep_alive(_g1h, pss);\n-\n-    \/\/ Complete GC closure\n-    G1ParEvacuateFollowersClosure drain_queue(_g1h, pss, _task_queues, _terminator, G1GCPhaseTimes::ObjCopy);\n-\n-    \/\/ Call the reference processing task's work routine.\n-    _proc_task.work(worker_id, is_alive, keep_alive, drain_queue);\n-\n-    \/\/ Note we cannot assert that the refs array is empty here as not all\n-    \/\/ of the processing tasks (specifically phase2 - pp2_work) execute\n-    \/\/ the complete_gc closure (which ordinarily would drain the queue) so\n-    \/\/ the queue may not be empty.\n+  VoidClosure* complete_gc(uint worker_id) {\n+    assert(worker_id < _queues || _tm == ThreadModel::Single, \"sanity\");\n+    if (_tm == ThreadModel::Single) {\n+      return ::new (&_serial_complete_gc) G1STWDrainQueueClosure(&_g1h, _pss.state_for_worker(0));\n+    }\n+    return ::new (&_parallel_complete_gc[worker_id]) G1ParEvacuateFollowersClosure(&_g1h, _pss.state_for_worker(worker_id), &_task_queues, &_terminator, G1GCPhaseTimes::ObjCopy);\n@@ -3391,1 +3368,0 @@\n-};\n@@ -3393,5 +3369,5 @@\n-\/\/ Driver routine for parallel reference processing.\n-\/\/ Creates an instance of the ref processing gang\n-\/\/ task and has the worker threads execute it.\n-void G1STWRefProcTaskExecutor::execute(ProcessTask& proc_task, uint ergo_workers) {\n-  assert(_workers != NULL, \"Need parallel worker threads.\");\n+  void prepare_run_task(uint queue_count, ThreadModel tm, bool marks_oops_alive) {\n+    log_debug(gc, ref)(\"G1STWRefProcClosureContext: prepare_run_task\");\n+    assert(queue_count <= _max_workers, \"sanity\");\n+    _queues = queue_count;\n+    _tm = tm;\n@@ -3399,8 +3375,6 @@\n-  assert(_workers->active_workers() >= ergo_workers,\n-         \"Ergonomically chosen workers (%u) should be less than or equal to active workers (%u)\",\n-         ergo_workers, _workers->active_workers());\n-  TaskTerminator terminator(ergo_workers, _queues);\n-  G1STWRefProcTaskProxy proc_task_proxy(proc_task, _g1h, _pss, _queues, &terminator);\n-\n-  _workers->run_task(&proc_task_proxy, ergo_workers);\n-}\n+    for (uint qid = 0; qid < index(queue_count, tm); ++qid ) {\n+      _pss.state_for_worker(qid)->set_ref_discoverer(nullptr); \/\/ move?, maybe not...\n+    }\n+    _terminator.reset_for_reuse(queue_count);\n+  };\n+};\n@@ -3416,8 +3390,0 @@\n-  \/\/ Closure to test whether a referent is alive.\n-  G1STWIsAliveClosure is_alive(this);\n-\n-  \/\/ Even when parallel reference processing is enabled, the processing\n-  \/\/ of JNI refs is serial and performed serially by the current thread\n-  \/\/ rather than by a worker. The following PSS will be used for processing\n-  \/\/ JNI refs.\n-\n@@ -3429,6 +3395,0 @@\n-  \/\/ Keep alive closure.\n-  G1CopyingKeepAliveClosure keep_alive(this, pss);\n-\n-  \/\/ Serial Complete GC closure\n-  G1STWDrainQueueClosure drain_queue(this, pss);\n-\n@@ -3438,1 +3398,1 @@\n-  ReferenceProcessorPhaseTimes* pt = phase_times()->ref_phase_times();\n+  ReferenceProcessorPhaseTimes& pt = *phase_times()->ref_phase_times();\n@@ -3441,9 +3401,1 @@\n-  if (!rp->processing_is_mt()) {\n-    \/\/ Serial reference processing...\n-    stats = rp->process_discovered_references(&is_alive,\n-                                              &keep_alive,\n-                                              &drain_queue,\n-                                              NULL,\n-                                              pt);\n-  } else {\n-    uint no_of_gc_workers = workers()->active_workers();\n+  uint no_of_gc_workers = workers()->active_workers();\n@@ -3451,4 +3403,4 @@\n-    \/\/ Parallel reference processing\n-    assert(no_of_gc_workers <= rp->max_num_queues(),\n-           \"Mismatch between the number of GC workers %u and the maximum number of Reference process queues %u\",\n-           no_of_gc_workers,  rp->max_num_queues());\n+  \/\/ Parallel reference processing\n+  assert(no_of_gc_workers <= rp->max_num_queues(),\n+         \"Mismatch between the number of GC workers %u and the maximum number of Reference process queues %u\",\n+         no_of_gc_workers,  rp->max_num_queues());\n@@ -3456,7 +3408,3 @@\n-    G1STWRefProcTaskExecutor par_task_executor(this, per_thread_states, workers(), _task_queues);\n-    stats = rp->process_discovered_references(&is_alive,\n-                                              &keep_alive,\n-                                              &drain_queue,\n-                                              &par_task_executor,\n-                                              pt);\n-  }\n+  rp->set_active_mt_degree(no_of_gc_workers);\n+  G1STWRefProcClosureContext context(rp->max_num_queues(), *this, *per_thread_states, *_task_queues);\n+  stats = rp->process_discovered_references(context, pt);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":69,"deletions":121,"binary":false,"changes":190,"status":"modified"},{"patch":"@@ -1464,9 +1464,7 @@\n-\/\/ Implementation of AbstractRefProcTaskExecutor for parallel\n-\/\/ reference processing at the end of G1 concurrent marking\n-\n-class G1CMRefProcTaskExecutor : public AbstractRefProcTaskExecutor {\n-private:\n-  G1CollectedHeap*  _g1h;\n-  G1ConcurrentMark* _cm;\n-  WorkGang*         _workers;\n-  uint              _active_workers;\n+class G1CMRefProcClosureContext : public AbstractClosureContext {\n+  uint                          _max_workers;\n+  G1ConcurrentMark&             _cm;\n+  G1CMIsAliveClosure            _is_alive;\n+  G1CMKeepAliveAndDrainClosure* _keep_alive;\n+  G1CMDrainMarkingStackClosure* _complete_gc;\n+  ThreadModel                   _tm;\n@@ -1475,24 +1473,14 @@\n-  G1CMRefProcTaskExecutor(G1CollectedHeap* g1h,\n-                          G1ConcurrentMark* cm,\n-                          WorkGang* workers,\n-                          uint n_workers) :\n-    _g1h(g1h), _cm(cm),\n-    _workers(workers), _active_workers(n_workers) { }\n-\n-  virtual void execute(ProcessTask& task, uint ergo_workers);\n-};\n-\n-class G1CMRefProcTaskProxy : public AbstractGangTask {\n-  typedef AbstractRefProcTaskExecutor::ProcessTask ProcessTask;\n-  ProcessTask&      _proc_task;\n-  G1CollectedHeap*  _g1h;\n-  G1ConcurrentMark* _cm;\n-\n-public:\n-  G1CMRefProcTaskProxy(ProcessTask& proc_task,\n-                       G1CollectedHeap* g1h,\n-                       G1ConcurrentMark* cm) :\n-    AbstractGangTask(\"Process reference objects in parallel\"),\n-    _proc_task(proc_task), _g1h(g1h), _cm(cm) {\n-    ReferenceProcessor* rp = _g1h->ref_processor_cm();\n-    assert(rp->processing_is_mt(), \"shouldn't be here otherwise\");\n+  G1CMRefProcClosureContext(\n+    uint max_workers,\n+    G1CollectedHeap& g1h,\n+    G1ConcurrentMark& cm)\n+    : _max_workers(max_workers),\n+      _cm(cm),\n+      _is_alive(&g1h),\n+      _keep_alive(NEW_C_HEAP_ARRAY(G1CMKeepAliveAndDrainClosure, _max_workers, mtGC)),\n+      _complete_gc(NEW_C_HEAP_ARRAY(G1CMDrainMarkingStackClosure, _max_workers, mtGC)),\n+      _tm(ThreadModel::Single) {}\n+\n+  ~G1CMRefProcClosureContext() {\n+    FREE_C_HEAP_ARRAY(G1CMKeepAliveAndDrainClosure, _keep_alive);\n+    FREE_C_HEAP_ARRAY(G1CMDrainMarkingStackClosure, _complete_gc);\n@@ -1501,8 +1489,8 @@\n-  virtual void work(uint worker_id) {\n-    ResourceMark rm;\n-    G1CMTask* task = _cm->task(worker_id);\n-    G1CMIsAliveClosure g1_is_alive(_g1h);\n-    G1CMKeepAliveAndDrainClosure g1_par_keep_alive(_cm, task, false \/* is_serial *\/);\n-    G1CMDrainMarkingStackClosure g1_par_drain(_cm, task, false \/* is_serial *\/);\n-\n-    _proc_task.work(worker_id, g1_is_alive, g1_par_keep_alive, g1_par_drain);\n+  BoolObjectClosure* is_alive(uint worker_id) { return &_is_alive; }\n+  OopClosure* keep_alive(uint worker_id)      {\n+    assert(worker_id < _max_workers, \"sanity\");\n+    return ::new (&_keep_alive[index(worker_id, _tm)]) G1CMKeepAliveAndDrainClosure(&_cm, _cm.task(index(worker_id, _tm)), _tm == ThreadModel::Single );\n+  }\n+  VoidClosure* complete_gc(uint worker_id)    {\n+    assert(worker_id < _max_workers, \"sanity\");\n+    return ::new (&_complete_gc[index(worker_id, _tm)]) G1CMDrainMarkingStackClosure(&_cm, _cm.task(index(worker_id, _tm)), _tm == ThreadModel::Single);\n@@ -1510,0 +1498,6 @@\n+  void prepare_run_task(uint queue_count, ThreadModel tm, bool marks_oops_alive) {\n+    log_debug(gc, ref)(\"G1CMRefProcClosureContext: prepare_run_task\");\n+    assert(queue_count <= _max_workers, \"sanity\");\n+    _tm = tm;\n+    _cm.set_concurrency(queue_count);\n+  };\n@@ -1512,17 +1506,0 @@\n-void G1CMRefProcTaskExecutor::execute(ProcessTask& proc_task, uint ergo_workers) {\n-  assert(_workers != NULL, \"Need parallel worker threads.\");\n-  assert(_g1h->ref_processor_cm()->processing_is_mt(), \"processing is not MT\");\n-  assert(_workers->active_workers() >= ergo_workers,\n-         \"Ergonomically chosen workers(%u) should be less than or equal to active workers(%u)\",\n-         ergo_workers, _workers->active_workers());\n-\n-  G1CMRefProcTaskProxy proc_task_proxy(proc_task, _g1h, _cm);\n-\n-  \/\/ We need to reset the concurrency level before each\n-  \/\/ proxy task execution, so that the termination protocol\n-  \/\/ and overflow handling in G1CMTask::do_marking_step() knows\n-  \/\/ how many workers to wait for.\n-  _cm->set_concurrency(ergo_workers);\n-  _workers->run_task(&proc_task_proxy, ergo_workers);\n-}\n-\n@@ -1549,17 +1526,0 @@\n-    \/\/ Instances of the 'Keep Alive' and 'Complete GC' closures used\n-    \/\/ in serial reference processing. Note these closures are also\n-    \/\/ used for serially processing (by the the current thread) the\n-    \/\/ JNI references during parallel reference processing.\n-    \/\/\n-    \/\/ These closures do not need to synchronize with the worker\n-    \/\/ threads involved in parallel reference processing as these\n-    \/\/ instances are executed serially by the current thread (e.g.\n-    \/\/ reference processing is not multi-threaded and is thus\n-    \/\/ performed by the current thread instead of a gang worker).\n-    \/\/\n-    \/\/ The gang tasks involved in parallel reference processing create\n-    \/\/ their own instances of these closures, which do their own\n-    \/\/ synchronization among themselves.\n-    G1CMKeepAliveAndDrainClosure g1_keep_alive(this, task(0), true \/* is_serial *\/);\n-    G1CMDrainMarkingStackClosure g1_drain_mark_stack(this, task(0), true \/* is_serial *\/);\n-\n@@ -1574,4 +1534,2 @@\n-    \/\/ Parallel processing task executor.\n-    G1CMRefProcTaskExecutor par_task_executor(_g1h, this,\n-                                              _g1h->workers(), active_workers);\n-    AbstractRefProcTaskExecutor* executor = (processing_is_mt ? &par_task_executor : NULL);\n+    \/\/ reference processing context.\n+    G1CMRefProcClosureContext context(rp->max_num_queues(), *_g1h, *this);\n@@ -1592,6 +1550,1 @@\n-    const ReferenceProcessorStats& stats =\n-        rp->process_discovered_references(&g1_is_alive,\n-                                          &g1_keep_alive,\n-                                          &g1_drain_mark_stack,\n-                                          executor,\n-                                          &pt);\n+    const ReferenceProcessorStats& stats = rp->process_discovered_references(context, pt);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":38,"deletions":85,"binary":false,"changes":123,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -282,2 +282,1 @@\n-  friend class G1CMRefProcTaskProxy;\n-  friend class G1CMRefProcTaskExecutor;\n+  friend class G1CMRefProcClosureContext;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-#include \"gc\/g1\/g1FullGCReferenceProcessorExecutor.hpp\"\n@@ -233,0 +232,33 @@\n+class G1FullRefProcClosureContext : public AbstractClosureContext {\n+  uint                    _max_workers;\n+  G1FullCollector&        _collector;\n+  G1IsAliveClosure        _is_alive;\n+  G1FullKeepAliveClosure* _keep_alive;\n+  ThreadModel             _tm;\n+\n+public:\n+  G1FullRefProcClosureContext(G1FullCollector& collector, uint max_workers)\n+    : _max_workers(max_workers), _collector(collector), _is_alive(&collector), _keep_alive(NEW_C_HEAP_ARRAY(G1FullKeepAliveClosure, max_workers, mtGC)), _tm(ThreadModel::Single) {}\n+\n+  ~G1FullRefProcClosureContext() {\n+    FREE_C_HEAP_ARRAY(G1FullKeepAliveClosure, _keep_alive);\n+  }\n+  BoolObjectClosure* is_alive(uint worker_id) {\n+    assert(worker_id < _max_workers, \"sanity\");\n+    return &_is_alive;\n+  }\n+  OopClosure* keep_alive(uint worker_id) {\n+    assert(worker_id < _max_workers, \"sanity\");\n+    return ::new (&_keep_alive[index(worker_id, _tm)]) G1FullKeepAliveClosure(_collector.marker(index(worker_id, _tm)));\n+  };\n+  VoidClosure* complete_gc(uint worker_id) {\n+    assert(worker_id < _max_workers, \"sanity\");\n+    return _collector.marker(index(worker_id, _tm))->stack_closure();\n+  }\n+  void prepare_run_task(uint queue_count, ThreadModel tm, bool marks_oops_alive) {\n+    log_debug(gc, ref)(\"G1FullRefProcClosureContext: prepare_run_task\");\n+    assert(queue_count <= _max_workers, \"sanity\");\n+    _tm = tm;\n+  };\n+};\n+\n@@ -244,3 +276,12 @@\n-    \/\/ Process references discovered during marking.\n-    G1FullGCReferenceProcessingExecutor reference_processing(this);\n-    reference_processing.execute(scope()->timer(), scope()->tracer());\n+    uint old_active_mt_degree = reference_processor()->num_queues();\n+    reference_processor()->set_active_mt_degree(workers());\n+    GCTraceTime(Debug, gc, phases) debug(\"Phase 1: Reference Processing\", scope()->timer());\n+    \/\/ Process reference objects found during marking.\n+    ReferenceProcessorPhaseTimes pt(scope()->timer(), reference_processor()->max_num_queues());\n+    G1FullRefProcClosureContext context(*this, reference_processor()->max_num_queues());\n+    const ReferenceProcessorStats& stats = reference_processor()->process_discovered_references(context, pt);\n+    scope()->tracer()->report_gc_reference_stats(stats);\n+    pt.print_all_references();\n+    assert(marker(0)->oop_stack()->is_empty(), \"Should be no oops on the stack\");\n+\n+    reference_processor()->set_active_mt_degree(old_active_mt_degree);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":45,"deletions":4,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,0 @@\n-#include \"gc\/g1\/g1FullGCReferenceProcessorExecutor.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCMarkTask.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,102 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"gc\/g1\/g1CollectedHeap.hpp\"\n-#include \"gc\/g1\/g1FullCollector.hpp\"\n-#include \"gc\/g1\/g1FullGCMarker.hpp\"\n-#include \"gc\/g1\/g1FullGCOopClosures.inline.hpp\"\n-#include \"gc\/g1\/g1FullGCReferenceProcessorExecutor.hpp\"\n-#include \"gc\/shared\/gcTraceTime.inline.hpp\"\n-#include \"gc\/shared\/referenceProcessor.hpp\"\n-#include \"gc\/shared\/referenceProcessorPhaseTimes.hpp\"\n-#include \"memory\/iterator.inline.hpp\"\n-\n-G1FullGCReferenceProcessingExecutor::G1FullGCReferenceProcessingExecutor(G1FullCollector* collector) :\n-    _collector(collector),\n-    _reference_processor(collector->reference_processor()),\n-    _old_mt_degree(_reference_processor->num_queues()) {\n-  if (_reference_processor->processing_is_mt()) {\n-    _reference_processor->set_active_mt_degree(_collector->workers());\n-  }\n-}\n-\n-G1FullGCReferenceProcessingExecutor::~G1FullGCReferenceProcessingExecutor() {\n-  if (_reference_processor->processing_is_mt()) {\n-    _reference_processor->set_active_mt_degree(_old_mt_degree);\n-  }\n-}\n-\n-G1FullGCReferenceProcessingExecutor::G1RefProcTaskProxy::G1RefProcTaskProxy(ProcessTask& proc_task,\n-                                                                      G1FullCollector* collector) :\n-     AbstractGangTask(\"G1 reference processing task\"),\n-     _proc_task(proc_task),\n-     _collector(collector) { }\n-\n-void G1FullGCReferenceProcessingExecutor::G1RefProcTaskProxy::work(uint worker_id) {\n-  G1FullGCMarker* marker = _collector->marker(worker_id);\n-  G1IsAliveClosure is_alive(_collector);\n-  G1FullKeepAliveClosure keep_alive(marker);\n-  _proc_task.work(worker_id,\n-                  is_alive,\n-                  keep_alive,\n-                  *marker->stack_closure());\n-}\n-\n-void G1FullGCReferenceProcessingExecutor::run_task(AbstractGangTask* task) {\n-  G1CollectedHeap::heap()->workers()->run_task(task, _collector->workers());\n-}\n-\n-void G1FullGCReferenceProcessingExecutor::run_task(AbstractGangTask* task, uint workers) {\n-  G1CollectedHeap::heap()->workers()->run_task(task, workers);\n-}\n-\n-void G1FullGCReferenceProcessingExecutor::execute(ProcessTask& proc_task, uint ergo_workers) {\n-  G1RefProcTaskProxy proc_task_proxy(proc_task, _collector);\n-  run_task(&proc_task_proxy, ergo_workers);\n-}\n-\n-void G1FullGCReferenceProcessingExecutor::execute(STWGCTimer* timer, G1FullGCTracer* tracer) {\n-  GCTraceTime(Debug, gc, phases) debug(\"Phase 1: Reference Processing\", timer);\n-  \/\/ Process reference objects found during marking.\n-  G1FullGCMarker* marker = _collector->marker(0);\n-  G1IsAliveClosure is_alive(_collector);\n-  G1FullKeepAliveClosure keep_alive(marker);\n-  ReferenceProcessorPhaseTimes pt(timer, _reference_processor->max_num_queues());\n-  AbstractRefProcTaskExecutor* executor = _reference_processor->processing_is_mt() ? this : NULL;\n-\n-  \/\/ Process discovered references, use this executor if multi-threaded\n-  \/\/ processing is enabled.\n-  const ReferenceProcessorStats& stats =\n-      _reference_processor->process_discovered_references(&is_alive,\n-                                                          &keep_alive,\n-                                                          marker->stack_closure(),\n-                                                          executor,\n-                                                          &pt);\n-\n-  tracer->report_gc_reference_stats(stats);\n-  pt.print_all_references();\n-\n-  assert(marker->oop_stack()->is_empty(), \"Should be no oops on the stack\");\n-}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCReferenceProcessorExecutor.cpp","additions":0,"deletions":102,"binary":false,"changes":102,"status":"deleted"},{"patch":"@@ -1,73 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_G1_G1FULLGCREFERENCEPROCESSOREXECUTOR_HPP\n-#define SHARE_GC_G1_G1FULLGCREFERENCEPROCESSOREXECUTOR_HPP\n-\n-#include \"gc\/g1\/g1FullGCCompactionPoint.hpp\"\n-#include \"gc\/g1\/g1FullGCScope.hpp\"\n-#include \"gc\/g1\/g1FullGCTask.hpp\"\n-#include \"gc\/g1\/g1RootProcessor.hpp\"\n-#include \"gc\/g1\/g1StringDedup.hpp\"\n-#include \"gc\/g1\/heapRegionManager.hpp\"\n-#include \"gc\/shared\/referenceProcessor.hpp\"\n-#include \"gc\/shared\/taskqueue.hpp\"\n-#include \"utilities\/ticks.hpp\"\n-\n-class G1FullGCTracer;\n-class STWGCTimer;\n-\n-class G1FullGCReferenceProcessingExecutor: public AbstractRefProcTaskExecutor {\n-  G1FullCollector*    _collector;\n-  ReferenceProcessor* _reference_processor;\n-  uint                _old_mt_degree;\n-\n-public:\n-  G1FullGCReferenceProcessingExecutor(G1FullCollector* collector);\n-  ~G1FullGCReferenceProcessingExecutor();\n-\n-  \/\/ Do reference processing.\n-  void execute(STWGCTimer* timer, G1FullGCTracer* tracer);\n-\n-  \/\/ Executes the given task using concurrent marking worker threads.\n-  virtual void execute(ProcessTask& task, uint ergo_workers);\n-\n-private:\n-  void run_task(AbstractGangTask* task);\n-  void run_task(AbstractGangTask* task, uint workers);\n-\n-  class G1RefProcTaskProxy : public AbstractGangTask {\n-    typedef AbstractRefProcTaskExecutor::ProcessTask ProcessTask;\n-    ProcessTask&                  _proc_task;\n-    G1FullCollector*              _collector;\n-\n-  public:\n-    G1RefProcTaskProxy(ProcessTask& proc_task,\n-                       G1FullCollector* scope);\n-\n-    virtual void work(uint worker_id);\n-  };\n-};\n-\n-#endif \/\/ SHARE_GC_G1_G1FULLGCREFERENCEPROCESSOREXECUTOR_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCReferenceProcessorExecutor.hpp","additions":0,"deletions":73,"binary":false,"changes":73,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"gc\/shared\/taskTerminator.hpp\"\n@@ -41,0 +42,2 @@\n+  friend class CompactionWithStealingTask;\n+  friend class MarkFromRootsTask;\n@@ -42,0 +45,1 @@\n+  friend class PCRefProcClosureContext;\n@@ -43,1 +47,1 @@\n-  friend class CompactionWithStealingTask;\n+  friend class RefProcClosureContext;\n@@ -45,3 +49,0 @@\n-  friend class RefProcTaskExecutor;\n-  friend class PCRefProcTask;\n-  friend class MarkFromRootsTask;\n@@ -50,3 +51,0 @@\n- public:\n-\n-\n@@ -195,0 +193,2 @@\n+    TaskTerminator* _maybe_terminator;\n+    uint _worker_id;\n@@ -196,1 +196,2 @@\n-    FollowStackClosure(ParCompactionManager* cm) : _compaction_manager(cm) { }\n+    FollowStackClosure(ParCompactionManager* cm, TaskTerminator* maybe_terminator, uint worker_id)\n+      : _compaction_manager(cm), _maybe_terminator(maybe_terminator), _worker_id(worker_id) { }\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCompactionManager.hpp","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -121,0 +121,3 @@\n+  if (_maybe_terminator != nullptr) {\n+    steal_marking_work(*_maybe_terminator, _worker_id);\n+  }\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCompactionManager.inline.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2036,1 +2036,1 @@\n-static void steal_marking_work(TaskTerminator& terminator, uint worker_id) {\n+void steal_marking_work(TaskTerminator& terminator, uint worker_id) {\n@@ -2057,1 +2057,0 @@\n-  typedef AbstractRefProcTaskExecutor::ProcessTask ProcessTask;\n@@ -2099,5 +2098,6 @@\n-class PCRefProcTask : public AbstractGangTask {\n-  typedef AbstractRefProcTaskExecutor::ProcessTask ProcessTask;\n-  ProcessTask& _task;\n-  uint _ergo_workers;\n-  TaskTerminator _terminator;\n+class PCRefProcClosureContext : public AbstractClosureContext {\n+  uint                                      _max_workers;\n+  TaskTerminator                            _terminator;\n+  PCMarkAndPushClosure*                     _keep_alive;\n+  ParCompactionManager::FollowStackClosure* _complete_gc;\n+  ThreadModel                               _tm;\n@@ -2106,31 +2106,29 @@\n-  PCRefProcTask(ProcessTask& task, uint ergo_workers) :\n-      AbstractGangTask(\"PCRefProcTask\"),\n-      _task(task),\n-      _ergo_workers(ergo_workers),\n-      _terminator(_ergo_workers, ParCompactionManager::oop_task_queues()) {\n-  }\n-\n-  virtual void work(uint worker_id) {\n-    ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();\n-    assert(ParallelScavengeHeap::heap()->is_gc_active(), \"called outside gc\");\n-\n-    ParCompactionManager* cm =\n-      ParCompactionManager::gc_thread_compaction_manager(worker_id);\n-    PCMarkAndPushClosure mark_and_push_closure(cm);\n-    ParCompactionManager::FollowStackClosure follow_stack_closure(cm);\n-    _task.work(worker_id, *PSParallelCompact::is_alive_closure(),\n-               mark_and_push_closure, follow_stack_closure);\n-\n-    steal_marking_work(_terminator, worker_id);\n-  }\n-};\n-\n-class RefProcTaskExecutor: public AbstractRefProcTaskExecutor {\n-  void execute(ProcessTask& process_task, uint ergo_workers) {\n-    assert(ParallelScavengeHeap::heap()->workers().active_workers() == ergo_workers,\n-           \"Ergonomically chosen workers (%u) must be equal to active workers (%u)\",\n-           ergo_workers, ParallelScavengeHeap::heap()->workers().active_workers());\n-\n-    PCRefProcTask task(process_task, ergo_workers);\n-    ParallelScavengeHeap::heap()->workers().run_task(&task);\n-  }\n+  PCRefProcClosureContext(uint max_workers)\n+    : _max_workers(max_workers),\n+      _terminator(_max_workers, ParCompactionManager::oop_task_queues()),\n+      _keep_alive(NEW_C_HEAP_ARRAY(PCMarkAndPushClosure, _max_workers, mtGC)),\n+      _complete_gc(NEW_C_HEAP_ARRAY(ParCompactionManager::FollowStackClosure, _max_workers, mtGC)),\n+      _tm(ThreadModel::Single) {}\n+\n+  ~PCRefProcClosureContext() {\n+    FREE_C_HEAP_ARRAY(PCMarkAndPushClosure, _keep_alive);\n+    FREE_C_HEAP_ARRAY(ParCompactionManager::FollowStackClosure, _complete_gc);\n+  }\n+\n+  BoolObjectClosure* is_alive(uint worker_id) {\n+    return PSParallelCompact::is_alive_closure();\n+  }\n+  OopClosure* keep_alive(uint worker_id) {\n+    ParCompactionManager* cm = ParCompactionManager::gc_thread_compaction_manager(worker_id);\n+    return ::new (&_keep_alive[worker_id]) PCMarkAndPushClosure(cm);\n+  }\n+  VoidClosure* complete_gc(uint worker_id) {\n+    ParCompactionManager* cm = ParCompactionManager::gc_thread_compaction_manager(worker_id);\n+    return ::new (&_complete_gc[worker_id]) ParCompactionManager::FollowStackClosure(cm, (_tm == ThreadModel::Single)?nullptr:&_terminator, worker_id);\n+  }\n+  void prepare_run_task(uint queue_count, ThreadModel tm, bool marks_oops_alive) {\n+    log_debug(gc, ref)(\"PCRefProcClosureContext: prepare_run_task\");\n+    assert(queue_count <= _max_workers, \"sanity\");\n+    _tm = tm;\n+   _terminator.reset_for_reuse(queue_count);\n+  };\n@@ -2145,1 +2143,0 @@\n-  ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();\n@@ -2148,3 +2145,0 @@\n-  PCMarkAndPushClosure mark_and_push_closure(cm);\n-  ParCompactionManager::FollowStackClosure follow_stack_closure(cm);\n-\n@@ -2168,12 +2162,3 @@\n-    if (ref_processor()->processing_is_mt()) {\n-      ref_processor()->set_active_mt_degree(active_gc_threads);\n-\n-      RefProcTaskExecutor task_executor;\n-      stats = ref_processor()->process_discovered_references(\n-        is_alive_closure(), &mark_and_push_closure, &follow_stack_closure,\n-        &task_executor, &pt);\n-    } else {\n-      stats = ref_processor()->process_discovered_references(\n-        is_alive_closure(), &mark_and_push_closure, &follow_stack_closure, NULL,\n-        &pt);\n-    }\n+    ref_processor()->set_active_mt_degree(active_gc_threads);\n+    PCRefProcClosureContext context(ref_processor()->max_num_queues());\n+    stats = ref_processor()->process_discovered_references(context, pt);\n@@ -2512,1 +2497,0 @@\n-  typedef AbstractRefProcTaskExecutor::ProcessTask ProcessTask;\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":39,"deletions":55,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"gc\/parallel\/parMarkBitMap.hpp\"\n@@ -32,0 +31,1 @@\n+#include \"gc\/parallel\/parMarkBitMap.hpp\"\n@@ -34,0 +34,1 @@\n+#include \"gc\/shared\/taskTerminator.hpp\"\n@@ -1392,0 +1393,2 @@\n+void steal_marking_work(TaskTerminator& terminator, uint worker_id);\n+\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,0 +53,1 @@\n+  friend class PSRefProcClosureContext;\n@@ -55,2 +56,0 @@\n-  friend class PSRefProcTaskExecutor;\n-  friend class PSRefProcTask;\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -183,0 +183,3 @@\n+  TaskTerminator* _maybe_terminator;\n+  uint _worker_id;\n+\n@@ -184,1 +187,2 @@\n-  PSEvacuateFollowersClosure(PSPromotionManager* pm) : _promotion_manager(pm) {}\n+  PSEvacuateFollowersClosure(PSPromotionManager* pm, TaskTerminator* maybe_terminator, uint worker_id)\n+    : _promotion_manager(pm), _maybe_terminator(maybe_terminator), _worker_id(worker_id) {}\n@@ -191,2 +195,0 @@\n-  }\n-};\n@@ -194,2 +196,4 @@\n-class PSRefProcTaskExecutor: public AbstractRefProcTaskExecutor {\n-  virtual void execute(ProcessTask& process_task, uint ergo_workers);\n+    if (_maybe_terminator != nullptr) {\n+      steal_work(*_maybe_terminator, _worker_id);\n+    }\n+  }\n@@ -198,5 +202,7 @@\n-class PSRefProcTask : public AbstractGangTask {\n-  typedef AbstractRefProcTaskExecutor::ProcessTask ProcessTask;\n-  TaskTerminator _terminator;\n-  ProcessTask& _task;\n-  uint _active_workers;\n+class PSRefProcClosureContext : public AbstractClosureContext {\n+  uint                        _max_workers;\n+  TaskTerminator              _terminator;\n+  TaskTerminator*             _maybe_terminator; \/\/ nullptr when no termination is to be done\n+  PSIsAliveClosure            _is_alive;\n+  PSKeepAliveClosure*         _keep_alive;\n+  PSEvacuateFollowersClosure* _complete_gc;\n@@ -205,5 +211,11 @@\n-  PSRefProcTask(ProcessTask& task, uint active_workers)\n-    : AbstractGangTask(\"PSRefProcTask\"),\n-      _terminator(active_workers, PSPromotionManager::stack_array_depth()),\n-      _task(task),\n-      _active_workers(active_workers) {\n+  PSRefProcClosureContext(uint max_workers)\n+    : _max_workers(max_workers),\n+      _terminator(_max_workers, PSPromotionManager::stack_array_depth()),\n+      _maybe_terminator(nullptr),\n+      _is_alive(),\n+      _keep_alive(NEW_C_HEAP_ARRAY(PSKeepAliveClosure, _max_workers, mtGC)),\n+      _complete_gc(NEW_C_HEAP_ARRAY(PSEvacuateFollowersClosure, _max_workers, mtGC)) {}\n+\n+  ~PSRefProcClosureContext() {\n+    FREE_C_HEAP_ARRAY(PSKeepAliveClosure, _keep_alive);\n+    FREE_C_HEAP_ARRAY(PSEvacuateFollowersClosure, _complete_gc);\n@@ -212,12 +224,8 @@\n-  virtual void work(uint worker_id) {\n-    PSPromotionManager* promotion_manager =\n-      PSPromotionManager::gc_thread_promotion_manager(worker_id);\n-    assert(promotion_manager != NULL, \"sanity check\");\n-    PSKeepAliveClosure keep_alive(promotion_manager);\n-    PSEvacuateFollowersClosure evac_followers(promotion_manager);\n-    PSIsAliveClosure is_alive;\n-    _task.work(worker_id, is_alive, keep_alive, evac_followers);\n-\n-    if (_task.marks_oops_alive() && _active_workers > 1) {\n-      steal_work(_terminator, worker_id);\n-    }\n+  BoolObjectClosure* is_alive(uint worker_id) { return &_is_alive; }\n+  OopClosure* keep_alive(uint worker_id) {\n+    PSPromotionManager* promotion_manager = PSPromotionManager::gc_thread_promotion_manager(worker_id);\n+    return ::new (&_keep_alive[worker_id]) PSKeepAliveClosure(promotion_manager);\n+  }\n+  VoidClosure* complete_gc(uint worker_id) {\n+    PSPromotionManager* promotion_manager = PSPromotionManager::gc_thread_promotion_manager(worker_id);\n+    return ::new (&_complete_gc[worker_id]) PSEvacuateFollowersClosure(promotion_manager, _maybe_terminator, worker_id);\n@@ -225,0 +233,6 @@\n+  void prepare_run_task(uint queue_count, ThreadModel tm, bool marks_oops_alive) {\n+    log_debug(gc, ref)(\"PSRefProcClosureContext: prepare_run_task\");\n+    assert(queue_count <= _max_workers, \"sanity\");\n+    _terminator.reset_for_reuse(queue_count);\n+    _maybe_terminator = (marks_oops_alive && tm == ThreadModel::Multi)?&_terminator:nullptr;\n+  };\n@@ -227,5 +241,0 @@\n-void PSRefProcTaskExecutor::execute(ProcessTask& process_task, uint ergo_workers) {\n-  PSRefProcTask task(process_task, ergo_workers);\n-  ParallelScavengeHeap::heap()->workers().run_task(&task);\n-}\n-\n@@ -503,2 +512,0 @@\n-      PSKeepAliveClosure keep_alive(promotion_manager);\n-      PSEvacuateFollowersClosure evac_followers(promotion_manager);\n@@ -507,9 +514,3 @@\n-      if (reference_processor()->processing_is_mt()) {\n-        PSRefProcTaskExecutor task_executor;\n-        stats = reference_processor()->process_discovered_references(\n-          &_is_alive_closure, &keep_alive, &evac_followers, &task_executor,\n-          &pt);\n-      } else {\n-        stats = reference_processor()->process_discovered_references(\n-          &_is_alive_closure, &keep_alive, &evac_followers, NULL, &pt);\n-      }\n+\n+      PSRefProcClosureContext context(reference_processor()->max_num_queues());\n+      stats = reference_processor()->process_discovered_references(context, pt);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psScavenge.cpp","additions":44,"deletions":43,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"gc\/serial\/serialClosureContext.hpp\"\n@@ -40,1 +41,0 @@\n-#include \"gc\/shared\/genOopClosures.inline.hpp\"\n@@ -42,0 +42,1 @@\n+#include \"gc\/shared\/genOopClosures.inline.hpp\"\n@@ -590,3 +591,2 @@\n-  const ReferenceProcessorStats& stats =\n-  rp->process_discovered_references(&is_alive, &keep_alive, &evacuate_followers,\n-                                    NULL, &pt);\n+  SerialClosureContext closure_context(is_alive, keep_alive, evacuate_followers);\n+  const ReferenceProcessorStats& stats = rp->process_discovered_references(closure_context, pt);\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+#include \"gc\/serial\/serialClosureContext.hpp\"\n@@ -201,3 +202,2 @@\n-    const ReferenceProcessorStats& stats =\n-      ref_processor()->process_discovered_references(\n-        &is_alive, &keep_alive, &follow_stack_closure, NULL, &pt);\n+    SerialClosureContext closure_context(is_alive, keep_alive, follow_stack_closure);\n+    const ReferenceProcessorStats& stats = ref_processor()->process_discovered_references(closure_context, pt);\n","filename":"src\/hotspot\/share\/gc\/serial\/genMarkSweep.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SERIAL_SERIALCLOSURECONTEXT_HPP\n+#define SHARE_GC_SERIAL_SERIALCLOSURECONTEXT_HPP\n+\n+#include \"gc\/shared\/referenceProcessor.hpp\"\n+\n+class SerialClosureContext : public AbstractClosureContext {\n+  BoolObjectClosure& _is_alive;\n+  OopClosure& _keep_alive;\n+  VoidClosure& _complete_gc;\n+public:\n+  SerialClosureContext(BoolObjectClosure& is_alive, OopClosure& keep_alive, VoidClosure& complete_gc)\n+    : _is_alive(is_alive), _keep_alive(keep_alive), _complete_gc(complete_gc) {};\n+  BoolObjectClosure* is_alive(uint worker_id)                                    { return &_is_alive; }\n+  OopClosure* keep_alive(uint worker_id)                                         { return &_keep_alive; }\n+  VoidClosure* complete_gc(uint worker_id)                                       { return &_complete_gc; }\n+  void prepare_run_task(uint queue_count, ThreadModel tm, bool marks_oops_alive) { log_debug(gc, ref)(\"SerialClosureContext: prepare_run_task\"); };\n+};\n+\n+#endif \/* SHARE_GC_SERIAL_SERIALCLOSURECONTEXT_HPP *\/\n","filename":"src\/hotspot\/share\/gc\/serial\/serialClosureContext.hpp","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -200,5 +200,2 @@\n-  BoolObjectClosure*            is_alive,\n-  OopClosure*                   keep_alive,\n-  VoidClosure*                  complete_gc,\n-  AbstractRefProcTaskExecutor*  task_executor,\n-  ReferenceProcessorPhaseTimes* phase_times) {\n+  AbstractClosureContext& closure_context,\n+  ReferenceProcessorPhaseTimes& phase_times) {\n@@ -228,3 +225,2 @@\n-    RefProcTotalPhaseTimesTracker tt(RefPhase1, phase_times, this);\n-    process_soft_ref_reconsider(is_alive, keep_alive, complete_gc,\n-                                task_executor, phase_times);\n+    RefProcTotalPhaseTimesTracker tt(RefPhase1, &phase_times, this);\n+    process_soft_ref_reconsider(closure_context, phase_times);\n@@ -236,2 +232,2 @@\n-    RefProcTotalPhaseTimesTracker tt(RefPhase2, phase_times, this);\n-    process_soft_weak_final_refs(is_alive, keep_alive, complete_gc, task_executor, phase_times);\n+    RefProcTotalPhaseTimesTracker tt(RefPhase2, &phase_times, this);\n+    process_soft_weak_final_refs(closure_context, phase_times);\n@@ -241,2 +237,2 @@\n-    RefProcTotalPhaseTimesTracker tt(RefPhase3, phase_times, this);\n-    process_final_keep_alive(keep_alive, complete_gc, task_executor, phase_times);\n+    RefProcTotalPhaseTimesTracker tt(RefPhase3, &phase_times, this);\n+    process_final_keep_alive(closure_context, phase_times);\n@@ -246,2 +242,2 @@\n-    RefProcTotalPhaseTimesTracker tt(RefPhase4, phase_times, this);\n-    process_phantom_refs(is_alive, keep_alive, complete_gc, task_executor, phase_times);\n+    RefProcTotalPhaseTimesTracker tt(RefPhase4, &phase_times, this);\n+    process_phantom_refs(closure_context, phase_times);\n@@ -250,1 +246,1 @@\n-  phase_times->set_total_time_ms((os::elapsedTime() - start_time) * 1000);\n+  phase_times.set_total_time_ms((os::elapsedTime() - start_time) * 1000);\n@@ -444,3 +440,3 @@\n-                                          BoolObjectClosure* is_alive,\n-                                          OopClosure*        keep_alive,\n-                                          VoidClosure*       complete_gc) {\n+                                                     BoolObjectClosure* is_alive,\n+                                                     OopClosure*        keep_alive,\n+                                                     VoidClosure*       complete_gc) {\n@@ -519,1 +515,19 @@\n-class RefProcPhase1Task : public AbstractRefProcTaskExecutor::ProcessTask {\n+class RefProcTask : public AbstractGangTask {\n+protected:\n+  ReferenceProcessor& _ref_processor;\n+  ReferenceProcessorPhaseTimes* _phase_times;\n+  AbstractClosureContext& _closure_context;\n+\n+public:\n+  RefProcTask(\n+    const char* name,\n+    ReferenceProcessor& ref_processor,\n+    ReferenceProcessorPhaseTimes* phase_times,\n+    AbstractClosureContext& closure_context)\n+    : AbstractGangTask(name),\n+      _ref_processor(ref_processor),\n+      _phase_times(phase_times),\n+      _closure_context(closure_context) {}\n+};\n+\n+class RefProcPhase1Task : public RefProcTask {\n@@ -523,8 +537,9 @@\n-                    ReferencePolicy*              policy)\n-    : ProcessTask(ref_processor, true \/* marks_oops_alive *\/, phase_times),\n-      _policy(policy) { }\n-\n-  virtual void work(uint worker_id,\n-                    BoolObjectClosure& is_alive,\n-                    OopClosure& keep_alive,\n-                    VoidClosure& complete_gc)\n+                    ReferencePolicy*              policy,\n+                    AbstractClosureContext&       closure_context)\n+  : RefProcTask(\"RefProcPhase1Task\",\n+            ref_processor,\n+            phase_times,\n+            closure_context),\n+    _policy(policy) { }\n+\n+  virtual void work(uint worker_id)\n@@ -532,0 +547,1 @@\n+    ResourceMark rm;\n@@ -535,3 +551,3 @@\n-                                                                           &is_alive,\n-                                                                           &keep_alive,\n-                                                                           &complete_gc);\n+                                                                           _closure_context.is_alive(worker_id),\n+                                                                           _closure_context.keep_alive(worker_id),\n+                                                                           _closure_context.complete_gc(worker_id));\n@@ -544,1 +560,1 @@\n-class RefProcPhase2Task: public AbstractRefProcTaskExecutor::ProcessTask {\n+class RefProcPhase2Task: public RefProcTask {\n@@ -547,2 +563,1 @@\n-                  BoolObjectClosure& is_alive,\n-                  OopClosure& keep_alive,\n+                  AbstractClosureContext& closure_context,\n@@ -552,2 +567,2 @@\n-                                                                            &is_alive,\n-                                                                            &keep_alive,\n+                                                                            closure_context.is_alive(worker_id),\n+                                                                            closure_context.keep_alive(worker_id),\n@@ -560,2 +575,6 @@\n-                    ReferenceProcessorPhaseTimes* phase_times)\n-    : ProcessTask(ref_processor, false \/* marks_oops_alive *\/, phase_times) { }\n+                    ReferenceProcessorPhaseTimes* phase_times,\n+                    AbstractClosureContext& closure_context)\n+    : RefProcTask(\"RefProcPhase2Task\",\n+              ref_processor,\n+              phase_times,\n+              closure_context) { }\n@@ -563,4 +582,2 @@\n-  virtual void work(uint worker_id,\n-                    BoolObjectClosure& is_alive,\n-                    OopClosure& keep_alive,\n-                    VoidClosure& complete_gc) {\n+  virtual void work(uint worker_id) {\n+    ResourceMark rm;\n@@ -570,1 +587,1 @@\n-      run_phase2(worker_id, _ref_processor._discoveredSoftRefs, is_alive, keep_alive, true \/* do_enqueue_and_clear *\/, REF_SOFT);\n+      run_phase2(worker_id, _ref_processor._discoveredSoftRefs, _closure_context, true \/* do_enqueue_and_clear *\/, REF_SOFT);\n@@ -574,1 +591,1 @@\n-      run_phase2(worker_id, _ref_processor._discoveredWeakRefs, is_alive, keep_alive, true \/* do_enqueue_and_clear *\/, REF_WEAK);\n+      run_phase2(worker_id, _ref_processor._discoveredWeakRefs, _closure_context, true \/* do_enqueue_and_clear *\/, REF_WEAK);\n@@ -578,1 +595,1 @@\n-      run_phase2(worker_id, _ref_processor._discoveredFinalRefs, is_alive, keep_alive, false \/* do_enqueue_and_clear *\/, REF_FINAL);\n+      run_phase2(worker_id, _ref_processor._discoveredFinalRefs, _closure_context, false \/* do_enqueue_and_clear *\/, REF_FINAL);\n@@ -582,1 +599,1 @@\n-    complete_gc.do_void();\n+    _closure_context.complete_gc(worker_id)->do_void();\n@@ -586,1 +603,1 @@\n-class RefProcPhase3Task: public AbstractRefProcTaskExecutor::ProcessTask {\n+class RefProcPhase3Task: public RefProcTask {\n@@ -589,2 +606,7 @@\n-                    ReferenceProcessorPhaseTimes* phase_times)\n-    : ProcessTask(ref_processor, true \/* marks_oops_alive *\/, phase_times) { }\n+                    ReferenceProcessorPhaseTimes* phase_times,\n+                    AbstractClosureContext& closure_context)\n+    : RefProcTask(\"RefProcPhase3Task\",\n+              ref_processor,\n+              phase_times,\n+              closure_context) { }\n+\n@@ -592,4 +614,1 @@\n-  virtual void work(uint worker_id,\n-                    BoolObjectClosure& is_alive,\n-                    OopClosure& keep_alive,\n-                    VoidClosure& complete_gc)\n+  virtual void work(uint worker_id)\n@@ -597,0 +616,1 @@\n+    ResourceMark rm;\n@@ -598,1 +618,1 @@\n-    _ref_processor.process_final_keep_alive_work(_ref_processor._discoveredFinalRefs[worker_id], &keep_alive, &complete_gc);\n+    _ref_processor.process_final_keep_alive_work(_ref_processor._discoveredFinalRefs[worker_id], _closure_context.keep_alive(worker_id), _closure_context.complete_gc(worker_id));\n@@ -602,1 +622,1 @@\n-class RefProcPhase4Task: public AbstractRefProcTaskExecutor::ProcessTask {\n+class RefProcPhase4Task: public RefProcTask {\n@@ -605,2 +625,6 @@\n-                    ReferenceProcessorPhaseTimes* phase_times)\n-    : ProcessTask(ref_processor, false \/* marks_oops_alive *\/, phase_times) { }\n+                    ReferenceProcessorPhaseTimes* phase_times,\n+                    AbstractClosureContext&       closure_context)\n+    : RefProcTask(\"RefProcPhase4Task\",\n+              ref_processor,\n+              phase_times,\n+              closure_context) { }\n@@ -608,4 +632,1 @@\n-  virtual void work(uint worker_id,\n-                    BoolObjectClosure& is_alive,\n-                    OopClosure& keep_alive,\n-                    VoidClosure& complete_gc)\n+  virtual void work(uint worker_id)\n@@ -613,0 +634,1 @@\n+    ResourceMark rm;\n@@ -615,3 +637,3 @@\n-                                                                    &is_alive,\n-                                                                    &keep_alive,\n-                                                                    &complete_gc);\n+                                                                    _closure_context.is_alive(worker_id),\n+                                                                    _closure_context.keep_alive(worker_id),\n+                                                                    _closure_context.complete_gc(worker_id));\n@@ -774,6 +796,21 @@\n-void ReferenceProcessor::process_soft_ref_reconsider(BoolObjectClosure* is_alive,\n-                                                     OopClosure* keep_alive,\n-                                                     VoidClosure* complete_gc,\n-                                                     AbstractRefProcTaskExecutor* task_executor,\n-                                                     ReferenceProcessorPhaseTimes* phase_times) {\n-  assert(!processing_is_mt() || task_executor != NULL, \"Task executor must not be NULL when mt processing is set.\");\n+void ReferenceProcessor::run_task(AbstractGangTask& task, AbstractClosureContext& closure_context, bool marks_oops_alive) {\n+  WorkGang* gang = Universe::heap()->safepoint_workers();\n+  assert(gang != NULL || !processing_is_mt(), \"can not dispatch multi threaded without a work gang\");\n+  log_debug(gc, ref)(\"ReferenceProcessor::execute queues: %d, %s, marks_oops_alive: %s\",\n+    num_queues(), processing_is_mt() ? \"ThreadModel::Multi\" : \"ThreadModel::Single\", marks_oops_alive?\"true\":\"false\");\n+  closure_context.prepare_run_task(num_queues(), processing_is_mt() ? ThreadModel::Multi : ThreadModel::Single, marks_oops_alive);\n+  if (gang != NULL && processing_is_mt()) {\n+    assert(gang->active_workers() >= num_queues(),\n+           \"Ergonomically chosen workers(%u) should be less than or equal to active workers(%u)\",\n+           num_queues(), gang->active_workers());\n+    gang->run_task(&task, num_queues());\n+  } else {\n+    log_debug(gc, ref)(\"Serial loop: %d\\n\", _max_num_queues);\n+    for (unsigned i = 0; i < _max_num_queues; ++i) {\n+      task.work(i);\n+    }\n+  }\n+}\n+\n+void ReferenceProcessor::process_soft_ref_reconsider(AbstractClosureContext& closure_context,\n+                                                     ReferenceProcessorPhaseTimes& phase_times) {\n@@ -782,2 +819,2 @@\n-  phase_times->set_ref_discovered(REF_SOFT, num_soft_refs);\n-  phase_times->set_processing_is_mt(processing_is_mt());\n+  phase_times.set_ref_discovered(REF_SOFT, num_soft_refs);\n+  phase_times.set_processing_is_mt(processing_is_mt());\n@@ -798,1 +835,1 @@\n-    RefProcBalanceQueuesTimeTracker tt(RefPhase1, phase_times);\n+    RefProcBalanceQueuesTimeTracker tt(RefPhase1, &phase_times);\n@@ -802,1 +839,1 @@\n-  RefProcPhaseTimeTracker tt(RefPhase1, phase_times);\n+  RefProcPhaseTimeTracker tt(RefPhase1, &phase_times);\n@@ -805,14 +842,2 @@\n-  if (processing_is_mt()) {\n-    RefProcPhase1Task phase1(*this, phase_times, _current_soft_ref_policy);\n-    task_executor->execute(phase1, num_queues());\n-  } else {\n-    size_t removed = 0;\n-\n-    RefProcSubPhasesWorkerTimeTracker tt2(SoftRefSubPhase1, phase_times, 0);\n-    for (uint i = 0; i < _max_num_queues; i++) {\n-      removed += process_soft_ref_reconsider_work(_discoveredSoftRefs[i], _current_soft_ref_policy,\n-                                                  is_alive, keep_alive, complete_gc);\n-    }\n-\n-    phase_times->add_ref_cleared(REF_SOFT, removed);\n-  }\n+  RefProcPhase1Task phase1(*this, &phase_times, _current_soft_ref_policy, closure_context);\n+  run_task(phase1, closure_context, true);\n@@ -822,6 +847,2 @@\n-void ReferenceProcessor::process_soft_weak_final_refs(BoolObjectClosure* is_alive,\n-                                                      OopClosure* keep_alive,\n-                                                      VoidClosure* complete_gc,\n-                                                      AbstractRefProcTaskExecutor*  task_executor,\n-                                                      ReferenceProcessorPhaseTimes* phase_times) {\n-  assert(!processing_is_mt() || task_executor != NULL, \"Task executor must not be NULL when mt processing is set.\");\n+void ReferenceProcessor::process_soft_weak_final_refs(AbstractClosureContext& closure_context,\n+                                                      ReferenceProcessorPhaseTimes& phase_times) {\n@@ -833,2 +854,2 @@\n-  phase_times->set_ref_discovered(REF_WEAK, num_weak_refs);\n-  phase_times->set_ref_discovered(REF_FINAL, num_final_refs);\n+  phase_times.set_ref_discovered(REF_WEAK, num_weak_refs);\n+  phase_times.set_ref_discovered(REF_FINAL, num_final_refs);\n@@ -836,1 +857,1 @@\n-  phase_times->set_processing_is_mt(processing_is_mt());\n+  phase_times.set_processing_is_mt(processing_is_mt());\n@@ -846,1 +867,1 @@\n-    RefProcBalanceQueuesTimeTracker tt(RefPhase2, phase_times);\n+    RefProcBalanceQueuesTimeTracker tt(RefPhase2, &phase_times);\n@@ -852,1 +873,1 @@\n-  RefProcPhaseTimeTracker tt(RefPhase2, phase_times);\n+  RefProcPhaseTimeTracker tt(RefPhase2, &phase_times);\n@@ -857,17 +878,0 @@\n-  if (processing_is_mt()) {\n-    RefProcPhase2Task phase2(*this, phase_times);\n-    task_executor->execute(phase2, num_queues());\n-  } else {\n-    RefProcWorkerTimeTracker t(phase_times->phase2_worker_time_sec(), 0);\n-    {\n-      size_t removed = 0;\n-\n-      RefProcSubPhasesWorkerTimeTracker tt2(SoftRefSubPhase2, phase_times, 0);\n-      for (uint i = 0; i < _max_num_queues; i++) {\n-        removed += process_soft_weak_final_refs_work(_discoveredSoftRefs[i], is_alive, keep_alive, true \/* do_enqueue *\/);\n-      }\n-\n-      phase_times->add_ref_cleared(REF_SOFT, removed);\n-    }\n-    {\n-      size_t removed = 0;\n@@ -875,14 +879,2 @@\n-      RefProcSubPhasesWorkerTimeTracker tt2(WeakRefSubPhase2, phase_times, 0);\n-      for (uint i = 0; i < _max_num_queues; i++) {\n-        removed += process_soft_weak_final_refs_work(_discoveredWeakRefs[i], is_alive, keep_alive, true \/* do_enqueue *\/);\n-      }\n-\n-      phase_times->add_ref_cleared(REF_WEAK, removed);\n-    }\n-    {\n-      size_t removed = 0;\n-\n-      RefProcSubPhasesWorkerTimeTracker tt2(FinalRefSubPhase2, phase_times, 0);\n-      for (uint i = 0; i < _max_num_queues; i++) {\n-        removed += process_soft_weak_final_refs_work(_discoveredFinalRefs[i], is_alive, keep_alive, false \/* do_enqueue *\/);\n-      }\n+  RefProcPhase2Task phase2(*this, &phase_times, closure_context);\n+  run_task(phase2, closure_context, false);\n@@ -890,4 +882,0 @@\n-      phase_times->add_ref_cleared(REF_FINAL, removed);\n-    }\n-    complete_gc->do_void();\n-  }\n@@ -899,5 +887,2 @@\n-void ReferenceProcessor::process_final_keep_alive(OopClosure* keep_alive,\n-                                                  VoidClosure* complete_gc,\n-                                                  AbstractRefProcTaskExecutor*  task_executor,\n-                                                  ReferenceProcessorPhaseTimes* phase_times) {\n-  assert(!processing_is_mt() || task_executor != NULL, \"Task executor must not be NULL when mt processing is set.\");\n+void ReferenceProcessor::process_final_keep_alive(AbstractClosureContext& closure_context,\n+                                                  ReferenceProcessorPhaseTimes& phase_times) {\n@@ -906,2 +891,1 @@\n-\n-  phase_times->set_processing_is_mt(processing_is_mt());\n+  phase_times.set_processing_is_mt(processing_is_mt());\n@@ -917,1 +901,1 @@\n-    RefProcBalanceQueuesTimeTracker tt(RefPhase3, phase_times);\n+    RefProcBalanceQueuesTimeTracker tt(RefPhase3, &phase_times);\n@@ -923,1 +907,3 @@\n-  RefProcPhaseTimeTracker tt(RefPhase3, phase_times);\n+  RefProcPhaseTimeTracker tt(RefPhase3, &phase_times);\n+  RefProcPhase3Task phase3(*this, &phase_times, closure_context);\n+  run_task(phase3, closure_context, true);\n@@ -925,9 +911,0 @@\n-  if (processing_is_mt()) {\n-    RefProcPhase3Task phase3(*this, phase_times);\n-    task_executor->execute(phase3, num_queues());\n-  } else {\n-    RefProcSubPhasesWorkerTimeTracker tt2(FinalRefSubPhase3, phase_times, 0);\n-    for (uint i = 0; i < _max_num_queues; i++) {\n-      process_final_keep_alive_work(_discoveredFinalRefs[i], keep_alive, complete_gc);\n-    }\n-  }\n@@ -937,6 +914,2 @@\n-void ReferenceProcessor::process_phantom_refs(BoolObjectClosure* is_alive,\n-                                              OopClosure* keep_alive,\n-                                              VoidClosure* complete_gc,\n-                                              AbstractRefProcTaskExecutor* task_executor,\n-                                              ReferenceProcessorPhaseTimes* phase_times) {\n-  assert(!processing_is_mt() || task_executor != NULL, \"Task executor must not be NULL when mt processing is set.\");\n+void ReferenceProcessor::process_phantom_refs(AbstractClosureContext& closure_context,\n+                                              ReferenceProcessorPhaseTimes& phase_times) {\n@@ -945,3 +918,2 @@\n-\n-  phase_times->set_ref_discovered(REF_PHANTOM, num_phantom_refs);\n-  phase_times->set_processing_is_mt(processing_is_mt());\n+  phase_times.set_ref_discovered(REF_PHANTOM, num_phantom_refs);\n+  phase_times.set_processing_is_mt(processing_is_mt());\n@@ -957,1 +929,1 @@\n-    RefProcBalanceQueuesTimeTracker tt(RefPhase4, phase_times);\n+    RefProcBalanceQueuesTimeTracker tt(RefPhase4, &phase_times);\n@@ -962,1 +934,1 @@\n-  RefProcPhaseTimeTracker tt(RefPhase4, phase_times);\n+  RefProcPhaseTimeTracker tt(RefPhase4, &phase_times);\n@@ -965,5 +937,0 @@\n-  if (processing_is_mt()) {\n-    RefProcPhase4Task phase4(*this, phase_times);\n-    task_executor->execute(phase4, num_queues());\n-  } else {\n-    size_t removed = 0;\n@@ -971,4 +938,2 @@\n-    RefProcSubPhasesWorkerTimeTracker tt(PhantomRefSubPhase4, phase_times, 0);\n-    for (uint i = 0; i < _max_num_queues; i++) {\n-      removed += process_phantom_refs_work(_discoveredPhantomRefs[i], is_alive, keep_alive, complete_gc);\n-    }\n+  RefProcPhase4Task phase4(*this, &phase_times, closure_context);\n+  run_task(phase4, closure_context, false);\n@@ -976,2 +941,0 @@\n-    phase_times->add_ref_cleared(REF_PHANTOM, removed);\n-  }\n","filename":"src\/hotspot\/share\/gc\/shared\/referenceProcessor.cpp","additions":136,"deletions":173,"binary":false,"changes":309,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"gc\/shared\/workgroup.hpp\"\n@@ -34,1 +35,1 @@\n-class AbstractRefProcTaskExecutor;\n+class AbstractClosureContext;\n@@ -238,0 +239,2 @@\n+  void run_task(AbstractGangTask& task, AbstractClosureContext& closure_context, bool marks_oops_alive);\n+\n@@ -239,5 +242,2 @@\n-  void process_soft_ref_reconsider(BoolObjectClosure* is_alive,\n-                                   OopClosure* keep_alive,\n-                                   VoidClosure* complete_gc,\n-                                   AbstractRefProcTaskExecutor*  task_executor,\n-                                   ReferenceProcessorPhaseTimes* phase_times);\n+  void process_soft_ref_reconsider(AbstractClosureContext& closure_context,\n+                                   ReferenceProcessorPhaseTimes& phase_times);\n@@ -247,5 +247,2 @@\n-  void process_soft_weak_final_refs(BoolObjectClosure* is_alive,\n-                                    OopClosure* keep_alive,\n-                                    VoidClosure* complete_gc,\n-                                    AbstractRefProcTaskExecutor*  task_executor,\n-                                    ReferenceProcessorPhaseTimes* phase_times);\n+  void process_soft_weak_final_refs(AbstractClosureContext& closure_context,\n+                                    ReferenceProcessorPhaseTimes& phase_times);\n@@ -254,4 +251,2 @@\n-  void process_final_keep_alive(OopClosure* keep_alive,\n-                                VoidClosure* complete_gc,\n-                                AbstractRefProcTaskExecutor*  task_executor,\n-                                ReferenceProcessorPhaseTimes* phase_times);\n+  void process_final_keep_alive(AbstractClosureContext& closure_context,\n+                                ReferenceProcessorPhaseTimes& phase_times);\n@@ -260,5 +255,2 @@\n-  void process_phantom_refs(BoolObjectClosure* is_alive,\n-                            OopClosure* keep_alive,\n-                            VoidClosure* complete_gc,\n-                            AbstractRefProcTaskExecutor*  task_executor,\n-                            ReferenceProcessorPhaseTimes* phase_times);\n+  void process_phantom_refs(AbstractClosureContext& closure_context,\n+                            ReferenceProcessorPhaseTimes& phase_times);\n@@ -435,5 +427,2 @@\n-  process_discovered_references(BoolObjectClosure*            is_alive,\n-                                OopClosure*                   keep_alive,\n-                                VoidClosure*                  complete_gc,\n-                                AbstractRefProcTaskExecutor*  task_executor,\n-                                ReferenceProcessorPhaseTimes* phase_times);\n+  process_discovered_references(AbstractClosureContext&  closure_context,\n+                                ReferenceProcessorPhaseTimes& phase_times);\n@@ -599,28 +588,1 @@\n-\/\/ This class is an interface used to implement task execution for the\n-\/\/ reference processing.\n-class AbstractRefProcTaskExecutor {\n-public:\n-\n-  \/\/ Abstract tasks to execute.\n-  class ProcessTask;\n-\n-  \/\/ Executes a task using worker threads.\n-  virtual void execute(ProcessTask& task, uint ergo_workers) = 0;\n-};\n-\n-\/\/ Abstract reference processing task to execute.\n-class AbstractRefProcTaskExecutor::ProcessTask {\n-protected:\n-  ReferenceProcessor&           _ref_processor;\n-  \/\/ Indicates whether the phase could generate work that should be balanced across\n-  \/\/ threads after execution.\n-  bool                          _marks_oops_alive;\n-  ReferenceProcessorPhaseTimes* _phase_times;\n-\n-  ProcessTask(ReferenceProcessor& ref_processor,\n-              bool marks_oops_alive,\n-              ReferenceProcessorPhaseTimes* phase_times)\n-    : _ref_processor(ref_processor),\n-      _marks_oops_alive(marks_oops_alive),\n-      _phase_times(phase_times)\n-  { }\n+enum class ThreadModel {Multi, Single};\n@@ -628,0 +590,1 @@\n+class AbstractClosureContext {\n@@ -629,6 +592,5 @@\n-  virtual void work(uint worker_id,\n-                    BoolObjectClosure& is_alive,\n-                    OopClosure& keep_alive,\n-                    VoidClosure& complete_gc) = 0;\n-\n-  bool marks_oops_alive() const { return _marks_oops_alive; }\n+  virtual BoolObjectClosure* is_alive(uint worker_id) = 0;\n+  virtual OopClosure* keep_alive(uint worker_id) = 0;\n+  virtual VoidClosure* complete_gc(uint worker_id) = 0;\n+  virtual void prepare_run_task(uint queue_count, ThreadModel tm, bool marks_oops_alive) = 0;\n+  uint index(uint id, ThreadModel tm) { return (tm==ThreadModel::Single)?0:id; }\n","filename":"src\/hotspot\/share\/gc\/shared\/referenceProcessor.hpp","additions":21,"deletions":59,"binary":false,"changes":80,"status":"modified"}]}