{"files":[{"patch":"@@ -3116,1 +3116,1 @@\n-  const bool res = terminator()->offer_termination();\n+  const bool res = (terminator() == nullptr) ? true : terminator()->offer_termination();\n@@ -3339,38 +3339,5 @@\n-\/\/ Parallel Reference Processing closures\n-\n-\/\/ Implementation of AbstractRefProcTaskExecutor for parallel reference\n-\/\/ processing during G1 evacuation pauses.\n-\n-class G1STWRefProcTaskExecutor: public AbstractRefProcTaskExecutor {\n-private:\n-  G1CollectedHeap*          _g1h;\n-  G1ParScanThreadStateSet*  _pss;\n-  G1ScannerTasksQueueSet*   _queues;\n-  WorkGang*                 _workers;\n-\n-public:\n-  G1STWRefProcTaskExecutor(G1CollectedHeap* g1h,\n-                           G1ParScanThreadStateSet* per_thread_states,\n-                           WorkGang* workers,\n-                           G1ScannerTasksQueueSet *task_queues) :\n-    _g1h(g1h),\n-    _pss(per_thread_states),\n-    _queues(task_queues),\n-    _workers(workers)\n-  {\n-    g1h->ref_processor_stw()->set_active_mt_degree(workers->active_workers());\n-  }\n-\n-  \/\/ Executes the given task using concurrent marking worker threads.\n-  virtual void execute(ProcessTask& task, uint ergo_workers);\n-};\n-\n-\/\/ Gang task for possibly parallel reference processing\n-\n-class G1STWRefProcTaskProxy: public AbstractGangTask {\n-  typedef AbstractRefProcTaskExecutor::ProcessTask ProcessTask;\n-  ProcessTask&     _proc_task;\n-  G1CollectedHeap* _g1h;\n-  G1ParScanThreadStateSet* _pss;\n-  G1ScannerTasksQueueSet* _task_queues;\n-  TaskTerminator* _terminator;\n+class G1STWRefProcProxyTask : public RefProcProxyTask {\n+  G1CollectedHeap& _g1h;\n+  G1ParScanThreadStateSet& _pss;\n+  TaskTerminator _terminator;\n+  G1ScannerTasksQueueSet& _task_queues;\n@@ -3379,24 +3346,6 @@\n-  G1STWRefProcTaskProxy(ProcessTask& proc_task,\n-                        G1CollectedHeap* g1h,\n-                        G1ParScanThreadStateSet* per_thread_states,\n-                        G1ScannerTasksQueueSet *task_queues,\n-                        TaskTerminator* terminator) :\n-    AbstractGangTask(\"Process reference objects in parallel\"),\n-    _proc_task(proc_task),\n-    _g1h(g1h),\n-    _pss(per_thread_states),\n-    _task_queues(task_queues),\n-    _terminator(terminator)\n-  {}\n-\n-  virtual void work(uint worker_id) {\n-    \/\/ The reference processing task executed by a single worker.\n-    ResourceMark rm;\n-\n-    G1STWIsAliveClosure is_alive(_g1h);\n-\n-    G1ParScanThreadState* pss = _pss->state_for_worker(worker_id);\n-    pss->set_ref_discoverer(NULL);\n-\n-    \/\/ Keep alive closure.\n-    G1CopyingKeepAliveClosure keep_alive(_g1h, pss);\n+  G1STWRefProcProxyTask(uint max_workers, G1CollectedHeap& g1h, G1ParScanThreadStateSet& pss, G1ScannerTasksQueueSet& task_queues)\n+    : RefProcProxyTask(\"G1STWRefProcProxyTask\", max_workers),\n+      _g1h(g1h),\n+      _pss(pss),\n+      _terminator(max_workers, &task_queues),\n+      _task_queues(task_queues) {}\n@@ -3404,5 +3353,8 @@\n-    \/\/ Complete GC closure\n-    G1ParEvacuateFollowersClosure drain_queue(_g1h, pss, _task_queues, _terminator, G1GCPhaseTimes::ObjCopy);\n-\n-    \/\/ Call the reference processing task's work routine.\n-    _proc_task.work(worker_id, is_alive, keep_alive, drain_queue);\n+  void work(uint worker_id) override {\n+    assert(worker_id < _max_workers, \"sanity\");\n+    _pss.state_for_worker(index(worker_id))->set_ref_discoverer(nullptr);\n+    G1STWIsAliveClosure is_alive(&_g1h);\n+    G1CopyingKeepAliveClosure keep_alive(&_g1h, _pss.state_for_worker(index(worker_id)));\n+    G1ParEvacuateFollowersClosure complete_gc(&_g1h, _pss.state_for_worker(index(worker_id)), &_task_queues, _tm == RefProcThreadModel::Single ? nullptr : &_terminator, G1GCPhaseTimes::ObjCopy);\n+    _rp_task->rp_work(worker_id, &is_alive, &keep_alive, &complete_gc);\n+  }\n@@ -3410,4 +3362,2 @@\n-    \/\/ Note we cannot assert that the refs array is empty here as not all\n-    \/\/ of the processing tasks (specifically phase2 - pp2_work) execute\n-    \/\/ the complete_gc closure (which ordinarily would drain the queue) so\n-    \/\/ the queue may not be empty.\n+  void prepare_run_task_hook() override {\n+    _terminator.reset_for_reuse(_queue_count);\n@@ -3417,15 +3367,0 @@\n-\/\/ Driver routine for parallel reference processing.\n-\/\/ Creates an instance of the ref processing gang\n-\/\/ task and has the worker threads execute it.\n-void G1STWRefProcTaskExecutor::execute(ProcessTask& proc_task, uint ergo_workers) {\n-  assert(_workers != NULL, \"Need parallel worker threads.\");\n-\n-  assert(_workers->active_workers() >= ergo_workers,\n-         \"Ergonomically chosen workers (%u) should be less than or equal to active workers (%u)\",\n-         ergo_workers, _workers->active_workers());\n-  TaskTerminator terminator(ergo_workers, _queues);\n-  G1STWRefProcTaskProxy proc_task_proxy(proc_task, _g1h, _pss, _queues, &terminator);\n-\n-  _workers->run_task(&proc_task_proxy, ergo_workers);\n-}\n-\n@@ -3440,8 +3375,0 @@\n-  \/\/ Closure to test whether a referent is alive.\n-  G1STWIsAliveClosure is_alive(this);\n-\n-  \/\/ Even when parallel reference processing is enabled, the processing\n-  \/\/ of JNI refs is serial and performed serially by the current thread\n-  \/\/ rather than by a worker. The following PSS will be used for processing\n-  \/\/ JNI refs.\n-\n@@ -3453,6 +3380,0 @@\n-  \/\/ Keep alive closure.\n-  G1CopyingKeepAliveClosure keep_alive(this, pss);\n-\n-  \/\/ Serial Complete GC closure\n-  G1STWDrainQueueClosure drain_queue(this, pss);\n-\n@@ -3462,1 +3383,1 @@\n-  ReferenceProcessorPhaseTimes* pt = phase_times()->ref_phase_times();\n+  ReferenceProcessorPhaseTimes& pt = *phase_times()->ref_phase_times();\n@@ -3465,9 +3386,1 @@\n-  if (!rp->processing_is_mt()) {\n-    \/\/ Serial reference processing...\n-    stats = rp->process_discovered_references(&is_alive,\n-                                              &keep_alive,\n-                                              &drain_queue,\n-                                              NULL,\n-                                              pt);\n-  } else {\n-    uint no_of_gc_workers = workers()->active_workers();\n+  uint no_of_gc_workers = workers()->active_workers();\n@@ -3475,4 +3388,4 @@\n-    \/\/ Parallel reference processing\n-    assert(no_of_gc_workers <= rp->max_num_queues(),\n-           \"Mismatch between the number of GC workers %u and the maximum number of Reference process queues %u\",\n-           no_of_gc_workers,  rp->max_num_queues());\n+  \/\/ Parallel reference processing\n+  assert(no_of_gc_workers <= rp->max_num_queues(),\n+         \"Mismatch between the number of GC workers %u and the maximum number of Reference process queues %u\",\n+         no_of_gc_workers,  rp->max_num_queues());\n@@ -3480,7 +3393,3 @@\n-    G1STWRefProcTaskExecutor par_task_executor(this, per_thread_states, workers(), _task_queues);\n-    stats = rp->process_discovered_references(&is_alive,\n-                                              &keep_alive,\n-                                              &drain_queue,\n-                                              &par_task_executor,\n-                                              pt);\n-  }\n+  rp->set_active_mt_degree(no_of_gc_workers);\n+  G1STWRefProcProxyTask task(rp->max_num_queues(), *this, *per_thread_states, *_task_queues);\n+  stats = rp->process_discovered_references(task, pt);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":31,"deletions":122,"binary":false,"changes":153,"status":"modified"},{"patch":"@@ -1462,9 +1462,3 @@\n-\/\/ Implementation of AbstractRefProcTaskExecutor for parallel\n-\/\/ reference processing at the end of G1 concurrent marking\n-\n-class G1CMRefProcTaskExecutor : public AbstractRefProcTaskExecutor {\n-private:\n-  G1CollectedHeap*  _g1h;\n-  G1ConcurrentMark* _cm;\n-  WorkGang*         _workers;\n-  uint              _active_workers;\n+class G1CMRefProcProxyTask : public RefProcProxyTask {\n+  G1CollectedHeap& _g1h;\n+  G1ConcurrentMark& _cm;\n@@ -1473,24 +1467,11 @@\n-  G1CMRefProcTaskExecutor(G1CollectedHeap* g1h,\n-                          G1ConcurrentMark* cm,\n-                          WorkGang* workers,\n-                          uint n_workers) :\n-    _g1h(g1h), _cm(cm),\n-    _workers(workers), _active_workers(n_workers) { }\n-\n-  virtual void execute(ProcessTask& task, uint ergo_workers);\n-};\n-\n-class G1CMRefProcTaskProxy : public AbstractGangTask {\n-  typedef AbstractRefProcTaskExecutor::ProcessTask ProcessTask;\n-  ProcessTask&      _proc_task;\n-  G1CollectedHeap*  _g1h;\n-  G1ConcurrentMark* _cm;\n-\n-public:\n-  G1CMRefProcTaskProxy(ProcessTask& proc_task,\n-                       G1CollectedHeap* g1h,\n-                       G1ConcurrentMark* cm) :\n-    AbstractGangTask(\"Process reference objects in parallel\"),\n-    _proc_task(proc_task), _g1h(g1h), _cm(cm) {\n-    ReferenceProcessor* rp = _g1h->ref_processor_cm();\n-    assert(rp->processing_is_mt(), \"shouldn't be here otherwise\");\n+  G1CMRefProcProxyTask(uint max_workers, G1CollectedHeap& g1h, G1ConcurrentMark &cm)\n+    : RefProcProxyTask(\"G1CMRefProcProxyTask\", max_workers),\n+      _g1h(g1h),\n+      _cm(cm) {}\n+\n+  void work(uint worker_id) override {\n+    assert(worker_id < _max_workers, \"sanity\");\n+    G1CMIsAliveClosure is_alive(&_g1h);\n+    G1CMKeepAliveAndDrainClosure keep_alive(&_cm, _cm.task(index(worker_id)), _tm == RefProcThreadModel::Single);\n+    G1CMDrainMarkingStackClosure complete_gc(&_cm, _cm.task(index(worker_id)), _tm == RefProcThreadModel::Single);\n+    _rp_task->rp_work(worker_id, &is_alive, &keep_alive, &complete_gc);\n@@ -1499,8 +1480,6 @@\n-  virtual void work(uint worker_id) {\n-    ResourceMark rm;\n-    G1CMTask* task = _cm->task(worker_id);\n-    G1CMIsAliveClosure g1_is_alive(_g1h);\n-    G1CMKeepAliveAndDrainClosure g1_par_keep_alive(_cm, task, false \/* is_serial *\/);\n-    G1CMDrainMarkingStackClosure g1_par_drain(_cm, task, false \/* is_serial *\/);\n-\n-    _proc_task.work(worker_id, g1_is_alive, g1_par_keep_alive, g1_par_drain);\n+  void prepare_run_task_hook() override {\n+    \/\/ We need to reset the concurrency level before each\n+    \/\/ proxy task execution, so that the termination protocol\n+    \/\/ and overflow handling in G1CMTask::do_marking_step() knows\n+    \/\/ how many workers to wait for.\n+    _cm.set_concurrency(_queue_count);\n@@ -1510,17 +1489,0 @@\n-void G1CMRefProcTaskExecutor::execute(ProcessTask& proc_task, uint ergo_workers) {\n-  assert(_workers != NULL, \"Need parallel worker threads.\");\n-  assert(_g1h->ref_processor_cm()->processing_is_mt(), \"processing is not MT\");\n-  assert(_workers->active_workers() >= ergo_workers,\n-         \"Ergonomically chosen workers(%u) should be less than or equal to active workers(%u)\",\n-         ergo_workers, _workers->active_workers());\n-\n-  G1CMRefProcTaskProxy proc_task_proxy(proc_task, _g1h, _cm);\n-\n-  \/\/ We need to reset the concurrency level before each\n-  \/\/ proxy task execution, so that the termination protocol\n-  \/\/ and overflow handling in G1CMTask::do_marking_step() knows\n-  \/\/ how many workers to wait for.\n-  _cm->set_concurrency(ergo_workers);\n-  _workers->run_task(&proc_task_proxy, ergo_workers);\n-}\n-\n@@ -1547,17 +1509,0 @@\n-    \/\/ Instances of the 'Keep Alive' and 'Complete GC' closures used\n-    \/\/ in serial reference processing. Note these closures are also\n-    \/\/ used for serially processing (by the the current thread) the\n-    \/\/ JNI references during parallel reference processing.\n-    \/\/\n-    \/\/ These closures do not need to synchronize with the worker\n-    \/\/ threads involved in parallel reference processing as these\n-    \/\/ instances are executed serially by the current thread (e.g.\n-    \/\/ reference processing is not multi-threaded and is thus\n-    \/\/ performed by the current thread instead of a gang worker).\n-    \/\/\n-    \/\/ The gang tasks involved in parallel reference processing create\n-    \/\/ their own instances of these closures, which do their own\n-    \/\/ synchronization among themselves.\n-    G1CMKeepAliveAndDrainClosure g1_keep_alive(this, task(0), true \/* is_serial *\/);\n-    G1CMDrainMarkingStackClosure g1_drain_mark_stack(this, task(0), true \/* is_serial *\/);\n-\n@@ -1571,5 +1516,1 @@\n-\n-    \/\/ Parallel processing task executor.\n-    G1CMRefProcTaskExecutor par_task_executor(_g1h, this,\n-                                              _g1h->workers(), active_workers);\n-    AbstractRefProcTaskExecutor* executor = (processing_is_mt ? &par_task_executor : NULL);\n+    G1CMRefProcProxyTask task(rp->max_num_queues(), *_g1h, *this);\n@@ -1590,6 +1531,1 @@\n-    const ReferenceProcessorStats& stats =\n-        rp->process_discovered_references(&g1_is_alive,\n-                                          &g1_keep_alive,\n-                                          &g1_drain_mark_stack,\n-                                          executor,\n-                                          &pt);\n+    const ReferenceProcessorStats& stats = rp->process_discovered_references(task, pt);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":22,"deletions":86,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -281,5 +281,0 @@\n-  friend class G1ConcurrentMarkThread;\n-  friend class G1CMRefProcTaskProxy;\n-  friend class G1CMRefProcTaskExecutor;\n-  friend class G1CMKeepAliveAndDrainClosure;\n-  friend class G1CMDrainMarkingStackClosure;\n@@ -288,0 +283,3 @@\n+  friend class G1CMDrainMarkingStackClosure;\n+  friend class G1CMKeepAliveAndDrainClosure;\n+  friend class G1CMRefProcProxyTask;\n@@ -290,0 +288,1 @@\n+  friend class G1ConcurrentMarkThread;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.hpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-#include \"gc\/g1\/g1FullGCReferenceProcessorExecutor.hpp\"\n@@ -245,0 +244,17 @@\n+class G1FullGCRefProcProxyTask : public RefProcProxyTask {\n+  G1FullCollector& _collector;\n+\n+public:\n+  G1FullGCRefProcProxyTask(G1FullCollector &collector, uint max_workers)\n+    : RefProcProxyTask(\"G1FullGCRefProcProxyTask\", max_workers),\n+      _collector(collector) {}\n+\n+  void work(uint worker_id) override {\n+    assert(worker_id < _max_workers, \"sanity\");\n+    G1IsAliveClosure is_alive(&_collector);\n+    G1FullKeepAliveClosure keep_alive(_collector.marker(index(worker_id)));\n+    G1FollowStackClosure* complete_gc = _collector.marker(index(worker_id))->stack_closure();\n+    _rp_task->rp_work(worker_id, &is_alive, &keep_alive, complete_gc);\n+  }\n+};\n+\n@@ -256,3 +272,12 @@\n-    \/\/ Process references discovered during marking.\n-    G1FullGCReferenceProcessingExecutor reference_processing(this);\n-    reference_processing.execute(scope()->timer(), scope()->tracer());\n+    uint old_active_mt_degree = reference_processor()->num_queues();\n+    reference_processor()->set_active_mt_degree(workers());\n+    GCTraceTime(Debug, gc, phases) debug(\"Phase 1: Reference Processing\", scope()->timer());\n+    \/\/ Process reference objects found during marking.\n+    ReferenceProcessorPhaseTimes pt(scope()->timer(), reference_processor()->max_num_queues());\n+    G1FullGCRefProcProxyTask task(*this, reference_processor()->max_num_queues());\n+    const ReferenceProcessorStats& stats = reference_processor()->process_discovered_references(task, pt);\n+    scope()->tracer()->report_gc_reference_stats(stats);\n+    pt.print_all_references();\n+    assert(marker(0)->oop_stack()->is_empty(), \"Should be no oops on the stack\");\n+\n+    reference_processor()->set_active_mt_degree(old_active_mt_degree);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":29,"deletions":4,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,0 @@\n-#include \"gc\/g1\/g1FullGCReferenceProcessorExecutor.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCMarkTask.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,102 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"gc\/g1\/g1CollectedHeap.hpp\"\n-#include \"gc\/g1\/g1FullCollector.hpp\"\n-#include \"gc\/g1\/g1FullGCMarker.hpp\"\n-#include \"gc\/g1\/g1FullGCOopClosures.inline.hpp\"\n-#include \"gc\/g1\/g1FullGCReferenceProcessorExecutor.hpp\"\n-#include \"gc\/shared\/gcTraceTime.inline.hpp\"\n-#include \"gc\/shared\/referenceProcessor.hpp\"\n-#include \"gc\/shared\/referenceProcessorPhaseTimes.hpp\"\n-#include \"memory\/iterator.inline.hpp\"\n-\n-G1FullGCReferenceProcessingExecutor::G1FullGCReferenceProcessingExecutor(G1FullCollector* collector) :\n-    _collector(collector),\n-    _reference_processor(collector->reference_processor()),\n-    _old_mt_degree(_reference_processor->num_queues()) {\n-  if (_reference_processor->processing_is_mt()) {\n-    _reference_processor->set_active_mt_degree(_collector->workers());\n-  }\n-}\n-\n-G1FullGCReferenceProcessingExecutor::~G1FullGCReferenceProcessingExecutor() {\n-  if (_reference_processor->processing_is_mt()) {\n-    _reference_processor->set_active_mt_degree(_old_mt_degree);\n-  }\n-}\n-\n-G1FullGCReferenceProcessingExecutor::G1RefProcTaskProxy::G1RefProcTaskProxy(ProcessTask& proc_task,\n-                                                                      G1FullCollector* collector) :\n-     AbstractGangTask(\"G1 reference processing task\"),\n-     _proc_task(proc_task),\n-     _collector(collector) { }\n-\n-void G1FullGCReferenceProcessingExecutor::G1RefProcTaskProxy::work(uint worker_id) {\n-  G1FullGCMarker* marker = _collector->marker(worker_id);\n-  G1IsAliveClosure is_alive(_collector);\n-  G1FullKeepAliveClosure keep_alive(marker);\n-  _proc_task.work(worker_id,\n-                  is_alive,\n-                  keep_alive,\n-                  *marker->stack_closure());\n-}\n-\n-void G1FullGCReferenceProcessingExecutor::run_task(AbstractGangTask* task) {\n-  G1CollectedHeap::heap()->workers()->run_task(task, _collector->workers());\n-}\n-\n-void G1FullGCReferenceProcessingExecutor::run_task(AbstractGangTask* task, uint workers) {\n-  G1CollectedHeap::heap()->workers()->run_task(task, workers);\n-}\n-\n-void G1FullGCReferenceProcessingExecutor::execute(ProcessTask& proc_task, uint ergo_workers) {\n-  G1RefProcTaskProxy proc_task_proxy(proc_task, _collector);\n-  run_task(&proc_task_proxy, ergo_workers);\n-}\n-\n-void G1FullGCReferenceProcessingExecutor::execute(STWGCTimer* timer, G1FullGCTracer* tracer) {\n-  GCTraceTime(Debug, gc, phases) debug(\"Phase 1: Reference Processing\", timer);\n-  \/\/ Process reference objects found during marking.\n-  G1FullGCMarker* marker = _collector->marker(0);\n-  G1IsAliveClosure is_alive(_collector);\n-  G1FullKeepAliveClosure keep_alive(marker);\n-  ReferenceProcessorPhaseTimes pt(timer, _reference_processor->max_num_queues());\n-  AbstractRefProcTaskExecutor* executor = _reference_processor->processing_is_mt() ? this : NULL;\n-\n-  \/\/ Process discovered references, use this executor if multi-threaded\n-  \/\/ processing is enabled.\n-  const ReferenceProcessorStats& stats =\n-      _reference_processor->process_discovered_references(&is_alive,\n-                                                          &keep_alive,\n-                                                          marker->stack_closure(),\n-                                                          executor,\n-                                                          &pt);\n-\n-  tracer->report_gc_reference_stats(stats);\n-  pt.print_all_references();\n-\n-  assert(marker->oop_stack()->is_empty(), \"Should be no oops on the stack\");\n-}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCReferenceProcessorExecutor.cpp","additions":0,"deletions":102,"binary":false,"changes":102,"status":"deleted"},{"patch":"@@ -1,73 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_G1_G1FULLGCREFERENCEPROCESSOREXECUTOR_HPP\n-#define SHARE_GC_G1_G1FULLGCREFERENCEPROCESSOREXECUTOR_HPP\n-\n-#include \"gc\/g1\/g1FullGCCompactionPoint.hpp\"\n-#include \"gc\/g1\/g1FullGCScope.hpp\"\n-#include \"gc\/g1\/g1FullGCTask.hpp\"\n-#include \"gc\/g1\/g1RootProcessor.hpp\"\n-#include \"gc\/g1\/g1StringDedup.hpp\"\n-#include \"gc\/g1\/heapRegionManager.hpp\"\n-#include \"gc\/shared\/referenceProcessor.hpp\"\n-#include \"gc\/shared\/taskqueue.hpp\"\n-#include \"utilities\/ticks.hpp\"\n-\n-class G1FullGCTracer;\n-class STWGCTimer;\n-\n-class G1FullGCReferenceProcessingExecutor: public AbstractRefProcTaskExecutor {\n-  G1FullCollector*    _collector;\n-  ReferenceProcessor* _reference_processor;\n-  uint                _old_mt_degree;\n-\n-public:\n-  G1FullGCReferenceProcessingExecutor(G1FullCollector* collector);\n-  ~G1FullGCReferenceProcessingExecutor();\n-\n-  \/\/ Do reference processing.\n-  void execute(STWGCTimer* timer, G1FullGCTracer* tracer);\n-\n-  \/\/ Executes the given task using concurrent marking worker threads.\n-  virtual void execute(ProcessTask& task, uint ergo_workers);\n-\n-private:\n-  void run_task(AbstractGangTask* task);\n-  void run_task(AbstractGangTask* task, uint workers);\n-\n-  class G1RefProcTaskProxy : public AbstractGangTask {\n-    typedef AbstractRefProcTaskExecutor::ProcessTask ProcessTask;\n-    ProcessTask&                  _proc_task;\n-    G1FullCollector*              _collector;\n-\n-  public:\n-    G1RefProcTaskProxy(ProcessTask& proc_task,\n-                       G1FullCollector* scope);\n-\n-    virtual void work(uint worker_id);\n-  };\n-};\n-\n-#endif \/\/ SHARE_GC_G1_G1FULLGCREFERENCEPROCESSOREXECUTOR_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCReferenceProcessorExecutor.hpp","additions":0,"deletions":73,"binary":false,"changes":73,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"gc\/shared\/taskTerminator.hpp\"\n@@ -41,0 +42,3 @@\n+  friend class MarkFromRootsTask;\n+  friend class ParallelCompactRefProcProxyTask;\n+  friend class ParallelScavengeRefProcProxyTask;\n@@ -43,5 +47,0 @@\n-  friend class CompactionWithStealingTask;\n-  friend class UpdateAndFillClosure;\n-  friend class RefProcTaskExecutor;\n-  friend class PCRefProcTask;\n-  friend class MarkFromRootsTask;\n@@ -49,0 +48,1 @@\n+\n@@ -190,0 +190,2 @@\n+    TaskTerminator* _terminator;\n+    uint _worker_id;\n@@ -191,1 +193,2 @@\n-    FollowStackClosure(ParCompactionManager* cm) : _compaction_manager(cm) { }\n+    FollowStackClosure(ParCompactionManager* cm, TaskTerminator* terminator, uint worker_id)\n+      : _compaction_manager(cm), _terminator(terminator), _worker_id(worker_id) { }\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCompactionManager.hpp","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -121,0 +121,3 @@\n+  if (_terminator != nullptr) {\n+    steal_marking_work(*_terminator, _worker_id);\n+  }\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCompactionManager.inline.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2027,1 +2027,1 @@\n-static void steal_marking_work(TaskTerminator& terminator, uint worker_id) {\n+void steal_marking_work(TaskTerminator& terminator, uint worker_id) {\n@@ -2048,1 +2048,0 @@\n-  typedef AbstractRefProcTaskExecutor::ProcessTask ProcessTask;\n@@ -2087,4 +2086,1 @@\n-class PCRefProcTask : public AbstractGangTask {\n-  typedef AbstractRefProcTaskExecutor::ProcessTask ProcessTask;\n-  ProcessTask& _task;\n-  uint _ergo_workers;\n+class ParallelCompactRefProcProxyTask : public RefProcProxyTask {\n@@ -2094,10 +2090,3 @@\n-  PCRefProcTask(ProcessTask& task, uint ergo_workers) :\n-      AbstractGangTask(\"PCRefProcTask\"),\n-      _task(task),\n-      _ergo_workers(ergo_workers),\n-      _terminator(_ergo_workers, ParCompactionManager::oop_task_queues()) {\n-  }\n-\n-  virtual void work(uint worker_id) {\n-    ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();\n-    assert(ParallelScavengeHeap::heap()->is_gc_active(), \"called outside gc\");\n+  ParallelCompactRefProcProxyTask(uint max_workers)\n+    : RefProcProxyTask(\"ParallelCompactRefProcProxyTask\", max_workers),\n+      _terminator(_max_workers, ParCompactionManager::oop_task_queues()) {}\n@@ -2105,8 +2094,6 @@\n-    ParCompactionManager* cm =\n-      ParCompactionManager::gc_thread_compaction_manager(worker_id);\n-    PCMarkAndPushClosure mark_and_push_closure(cm);\n-    ParCompactionManager::FollowStackClosure follow_stack_closure(cm);\n-    _task.work(worker_id, *PSParallelCompact::is_alive_closure(),\n-               mark_and_push_closure, follow_stack_closure);\n-\n-    steal_marking_work(_terminator, worker_id);\n+  void work(uint worker_id) override {\n+    assert(worker_id < _max_workers, \"sanity\");\n+    ParCompactionManager* cm = (_tm == RefProcThreadModel::Single) ? ParCompactionManager::get_vmthread_cm() : ParCompactionManager::gc_thread_compaction_manager(worker_id);\n+    PCMarkAndPushClosure keep_alive(cm);\n+    ParCompactionManager::FollowStackClosure complete_gc(cm, (_tm == RefProcThreadModel::Single) ? nullptr : &_terminator, worker_id);\n+    _rp_task->rp_work(worker_id, PSParallelCompact::is_alive_closure(), &keep_alive, &complete_gc);\n@@ -2114,7 +2101,0 @@\n-};\n-\n-class RefProcTaskExecutor: public AbstractRefProcTaskExecutor {\n-  void execute(ProcessTask& process_task, uint ergo_workers) {\n-    assert(ParallelScavengeHeap::heap()->workers().active_workers() == ergo_workers,\n-           \"Ergonomically chosen workers (%u) must be equal to active workers (%u)\",\n-           ergo_workers, ParallelScavengeHeap::heap()->workers().active_workers());\n@@ -2122,2 +2102,2 @@\n-    PCRefProcTask task(process_task, ergo_workers);\n-    ParallelScavengeHeap::heap()->workers().run_task(&task);\n+  void prepare_run_task_hook() override {\n+    _terminator.reset_for_reuse(_queue_count);\n@@ -2133,1 +2113,0 @@\n-  ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();\n@@ -2136,3 +2115,0 @@\n-  PCMarkAndPushClosure mark_and_push_closure(cm);\n-  ParCompactionManager::FollowStackClosure follow_stack_closure(cm);\n-\n@@ -2156,12 +2132,3 @@\n-    if (ref_processor()->processing_is_mt()) {\n-      ref_processor()->set_active_mt_degree(active_gc_threads);\n-\n-      RefProcTaskExecutor task_executor;\n-      stats = ref_processor()->process_discovered_references(\n-        is_alive_closure(), &mark_and_push_closure, &follow_stack_closure,\n-        &task_executor, &pt);\n-    } else {\n-      stats = ref_processor()->process_discovered_references(\n-        is_alive_closure(), &mark_and_push_closure, &follow_stack_closure, NULL,\n-        &pt);\n-    }\n+    ref_processor()->set_active_mt_degree(active_gc_threads);\n+    ParallelCompactRefProcProxyTask task(ref_processor()->max_num_queues());\n+    stats = ref_processor()->process_discovered_references(task, pt);\n@@ -2558,1 +2525,0 @@\n-  typedef AbstractRefProcTaskExecutor::ProcessTask ProcessTask;\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":16,"deletions":50,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"gc\/parallel\/parMarkBitMap.hpp\"\n@@ -32,0 +31,1 @@\n+#include \"gc\/parallel\/parMarkBitMap.hpp\"\n@@ -34,0 +34,1 @@\n+#include \"gc\/shared\/taskTerminator.hpp\"\n@@ -1393,0 +1394,2 @@\n+void steal_marking_work(TaskTerminator& terminator, uint worker_id);\n+\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,2 +55,0 @@\n-  friend class PSRefProcTaskExecutor;\n-  friend class PSRefProcTask;\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -184,0 +184,3 @@\n+  TaskTerminator* _terminator;\n+  uint _worker_id;\n+\n@@ -185,1 +188,2 @@\n-  PSEvacuateFollowersClosure(PSPromotionManager* pm) : _promotion_manager(pm) {}\n+  PSEvacuateFollowersClosure(PSPromotionManager* pm, TaskTerminator* terminator, uint worker_id)\n+    : _promotion_manager(pm), _terminator(terminator), _worker_id(worker_id) {}\n@@ -188,1 +192,1 @@\n-    assert(_promotion_manager != NULL, \"Sanity\");\n+    assert(_promotion_manager != nullptr, \"Sanity\");\n@@ -192,2 +196,0 @@\n-  }\n-};\n@@ -195,2 +197,4 @@\n-class PSRefProcTaskExecutor: public AbstractRefProcTaskExecutor {\n-  virtual void execute(ProcessTask& process_task, uint ergo_workers);\n+    if (_terminator != nullptr) {\n+      steal_work(*_terminator, _worker_id);\n+    }\n+  }\n@@ -199,2 +203,1 @@\n-class PSRefProcTask : public AbstractGangTask {\n-  typedef AbstractRefProcTaskExecutor::ProcessTask ProcessTask;\n+class ParallelScavengeRefProcProxyTask : public RefProcProxyTask {\n@@ -202,2 +205,0 @@\n-  ProcessTask& _task;\n-  uint _active_workers;\n@@ -206,6 +207,3 @@\n-  PSRefProcTask(ProcessTask& task, uint active_workers)\n-    : AbstractGangTask(\"PSRefProcTask\"),\n-      _terminator(active_workers, PSPromotionManager::stack_array_depth()),\n-      _task(task),\n-      _active_workers(active_workers) {\n-  }\n+  ParallelScavengeRefProcProxyTask(uint max_workers)\n+    : RefProcProxyTask(\"ParallelScavengeRefProcProxyTask\", max_workers),\n+      _terminator(max_workers, ParCompactionManager::oop_task_queues()) {}\n@@ -213,6 +211,3 @@\n-  virtual void work(uint worker_id) {\n-    PSPromotionManager* promotion_manager =\n-      PSPromotionManager::gc_thread_promotion_manager(worker_id);\n-    assert(promotion_manager != NULL, \"sanity check\");\n-    PSKeepAliveClosure keep_alive(promotion_manager);\n-    PSEvacuateFollowersClosure evac_followers(promotion_manager);\n+  void work(uint worker_id) override {\n+    assert(worker_id < _max_workers, \"sanity\");\n+    PSPromotionManager* promotion_manager = (_tm == RefProcThreadModel::Single) ? PSPromotionManager::vm_thread_promotion_manager() : PSPromotionManager::gc_thread_promotion_manager(worker_id);\n@@ -220,1 +215,4 @@\n-    _task.work(worker_id, is_alive, keep_alive, evac_followers);\n+    PSKeepAliveClosure keep_alive(promotion_manager);;\n+    PSEvacuateFollowersClosure complete_gc(promotion_manager, (_marks_oops_alive && _tm == RefProcThreadModel::Multi) ? &_terminator : nullptr, worker_id);;\n+    _rp_task->rp_work(worker_id, &is_alive, &keep_alive, &complete_gc);\n+  }\n@@ -222,3 +220,2 @@\n-    if (_task.marks_oops_alive() && _active_workers > 1) {\n-      steal_work(_terminator, worker_id);\n-    }\n+  void prepare_run_task_hook() override {\n+    _terminator.reset_for_reuse(_queue_count);\n@@ -228,5 +225,0 @@\n-void PSRefProcTaskExecutor::execute(ProcessTask& process_task, uint ergo_workers) {\n-  PSRefProcTask task(process_task, ergo_workers);\n-  ParallelScavengeHeap::heap()->workers().run_task(&task);\n-}\n-\n@@ -501,2 +493,0 @@\n-      PSKeepAliveClosure keep_alive(promotion_manager);\n-      PSEvacuateFollowersClosure evac_followers(promotion_manager);\n@@ -505,9 +495,3 @@\n-      if (reference_processor()->processing_is_mt()) {\n-        PSRefProcTaskExecutor task_executor;\n-        stats = reference_processor()->process_discovered_references(\n-          &_is_alive_closure, &keep_alive, &evac_followers, &task_executor,\n-          &pt);\n-      } else {\n-        stats = reference_processor()->process_discovered_references(\n-          &_is_alive_closure, &keep_alive, &evac_followers, NULL, &pt);\n-      }\n+\n+      ParallelScavengeRefProcProxyTask task(reference_processor()->max_num_queues());\n+      stats = reference_processor()->process_discovered_references(task, pt);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psScavenge.cpp","additions":26,"deletions":42,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"gc\/serial\/serialGcRefProcProxyTask.hpp\"\n@@ -40,1 +41,0 @@\n-#include \"gc\/shared\/genOopClosures.inline.hpp\"\n@@ -42,0 +42,1 @@\n+#include \"gc\/shared\/genOopClosures.inline.hpp\"\n@@ -590,3 +591,2 @@\n-  const ReferenceProcessorStats& stats =\n-  rp->process_discovered_references(&is_alive, &keep_alive, &evacuate_followers,\n-                                    NULL, &pt);\n+  SerialGCRefProcProxyTask task(is_alive, keep_alive, evacuate_followers);\n+  const ReferenceProcessorStats& stats = rp->process_discovered_references(task, pt);\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"gc\/serial\/serialGcRefProcProxyTask.hpp\"\n@@ -202,3 +203,2 @@\n-    const ReferenceProcessorStats& stats =\n-      ref_processor()->process_discovered_references(\n-        &is_alive, &keep_alive, &follow_stack_closure, NULL, &pt);\n+    SerialGCRefProcProxyTask task(is_alive, keep_alive, follow_stack_closure);\n+    const ReferenceProcessorStats& stats = ref_processor()->process_discovered_references(task, pt);\n","filename":"src\/hotspot\/share\/gc\/serial\/genMarkSweep.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SERIAL_SERIALGCREFPROCPROXYTASK_HPP\n+#define SHARE_GC_SERIAL_SERIALGCREFPROCPROXYTASK_HPP\n+\n+#include \"gc\/shared\/referenceProcessor.hpp\"\n+\n+class SerialGCRefProcProxyTask : public RefProcProxyTask {\n+  BoolObjectClosure& _is_alive;\n+  OopClosure& _keep_alive;\n+  VoidClosure& _complete_gc;\n+\n+public:\n+  SerialGCRefProcProxyTask(BoolObjectClosure& is_alive, OopClosure& keep_alive, VoidClosure& complete_gc)\n+    : RefProcProxyTask(\"SerialGCRefProcProxyTask\", 1),\n+      _is_alive(is_alive),\n+      _keep_alive(keep_alive),\n+      _complete_gc(complete_gc) {}\n+\n+  void work(uint worker_id) override {\n+    assert(worker_id < _max_workers, \"sanity\");\n+    _rp_task->rp_work(worker_id, &_is_alive, &_keep_alive, &_complete_gc);\n+  }\n+};\n+\n+#endif \/* SHARE_GC_SERIAL_SERIALGCREFPROCPROXYTASK_HPP *\/\n","filename":"src\/hotspot\/share\/gc\/serial\/serialGcRefProcProxyTask.hpp","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -199,6 +199,2 @@\n-ReferenceProcessorStats ReferenceProcessor::process_discovered_references(\n-  BoolObjectClosure*            is_alive,\n-  OopClosure*                   keep_alive,\n-  VoidClosure*                  complete_gc,\n-  AbstractRefProcTaskExecutor*  task_executor,\n-  ReferenceProcessorPhaseTimes* phase_times) {\n+ReferenceProcessorStats ReferenceProcessor::process_discovered_references(RefProcProxyTask& proxy_task,\n+                                                                          ReferenceProcessorPhaseTimes& phase_times) {\n@@ -228,3 +224,2 @@\n-    RefProcTotalPhaseTimesTracker tt(RefPhase1, phase_times, this);\n-    process_soft_ref_reconsider(is_alive, keep_alive, complete_gc,\n-                                task_executor, phase_times);\n+    RefProcTotalPhaseTimesTracker tt(RefPhase1, &phase_times);\n+    process_soft_ref_reconsider(proxy_task, phase_times);\n@@ -236,2 +231,2 @@\n-    RefProcTotalPhaseTimesTracker tt(RefPhase2, phase_times, this);\n-    process_soft_weak_final_refs(is_alive, keep_alive, complete_gc, task_executor, phase_times);\n+    RefProcTotalPhaseTimesTracker tt(RefPhase2, &phase_times);\n+    process_soft_weak_final_refs(proxy_task, phase_times);\n@@ -241,2 +236,2 @@\n-    RefProcTotalPhaseTimesTracker tt(RefPhase3, phase_times, this);\n-    process_final_keep_alive(keep_alive, complete_gc, task_executor, phase_times);\n+    RefProcTotalPhaseTimesTracker tt(RefPhase3, &phase_times);\n+    process_final_keep_alive(proxy_task, phase_times);\n@@ -246,2 +241,2 @@\n-    RefProcTotalPhaseTimesTracker tt(RefPhase4, phase_times, this);\n-    process_phantom_refs(is_alive, keep_alive, complete_gc, task_executor, phase_times);\n+    RefProcTotalPhaseTimesTracker tt(RefPhase4, &phase_times);\n+    process_phantom_refs(proxy_task, phase_times);\n@@ -250,1 +245,1 @@\n-  phase_times->set_total_time_ms((os::elapsedTime() - start_time) * 1000);\n+  phase_times.set_total_time_ms((os::elapsedTime() - start_time) * 1000);\n@@ -444,3 +439,3 @@\n-                                          BoolObjectClosure* is_alive,\n-                                          OopClosure*        keep_alive,\n-                                          VoidClosure*       complete_gc) {\n+                                                     BoolObjectClosure* is_alive,\n+                                                     OopClosure*        keep_alive,\n+                                                     VoidClosure*       complete_gc) {\n@@ -519,1 +514,3 @@\n-class RefProcPhase1Task : public AbstractRefProcTaskExecutor::ProcessTask {\n+\n+\n+class RefProcPhase1Task : public RefProcTask {\n@@ -521,1 +518,1 @@\n-  RefProcPhase1Task(ReferenceProcessor&           ref_processor,\n+  RefProcPhase1Task(ReferenceProcessor& ref_processor,\n@@ -523,2 +520,3 @@\n-                    ReferencePolicy*              policy)\n-    : ProcessTask(ref_processor, true \/* marks_oops_alive *\/, phase_times),\n+                    ReferencePolicy* policy)\n+    : RefProcTask(ref_processor,\n+                  phase_times),\n@@ -527,5 +525,5 @@\n-  virtual void work(uint worker_id,\n-                    BoolObjectClosure& is_alive,\n-                    OopClosure& keep_alive,\n-                    VoidClosure& complete_gc)\n-  {\n+  void rp_work(uint worker_id,\n+               BoolObjectClosure* is_alive,\n+               OopClosure* keep_alive,\n+               VoidClosure* complete_gc) override {\n+    ResourceMark rm;\n@@ -535,3 +533,3 @@\n-                                                                           &is_alive,\n-                                                                           &keep_alive,\n-                                                                           &complete_gc);\n+                                                                           is_alive,\n+                                                                           keep_alive,\n+                                                                           complete_gc);\n@@ -540,0 +538,1 @@\n+\n@@ -544,1 +543,1 @@\n-class RefProcPhase2Task: public AbstractRefProcTaskExecutor::ProcessTask {\n+class RefProcPhase2Task: public RefProcTask {\n@@ -547,2 +546,2 @@\n-                  BoolObjectClosure& is_alive,\n-                  OopClosure& keep_alive,\n+                  BoolObjectClosure* is_alive,\n+                  OopClosure* keep_alive,\n@@ -552,2 +551,2 @@\n-                                                                            &is_alive,\n-                                                                            &keep_alive,\n+                                                                            is_alive,\n+                                                                            keep_alive,\n@@ -561,1 +560,2 @@\n-    : ProcessTask(ref_processor, false \/* marks_oops_alive *\/, phase_times) { }\n+    : RefProcTask(ref_processor,\n+                  phase_times) {}\n@@ -563,4 +563,5 @@\n-  virtual void work(uint worker_id,\n-                    BoolObjectClosure& is_alive,\n-                    OopClosure& keep_alive,\n-                    VoidClosure& complete_gc) {\n+  void rp_work(uint worker_id,\n+               BoolObjectClosure* is_alive,\n+               OopClosure* keep_alive,\n+               VoidClosure* complete_gc) override {\n+    ResourceMark rm;\n@@ -582,1 +583,1 @@\n-    complete_gc.do_void();\n+    complete_gc->do_void();\n@@ -586,1 +587,1 @@\n-class RefProcPhase3Task: public AbstractRefProcTaskExecutor::ProcessTask {\n+class RefProcPhase3Task: public RefProcTask {\n@@ -588,1 +589,1 @@\n-  RefProcPhase3Task(ReferenceProcessor&           ref_processor,\n+  RefProcPhase3Task(ReferenceProcessor& ref_processor,\n@@ -590,1 +591,2 @@\n-    : ProcessTask(ref_processor, true \/* marks_oops_alive *\/, phase_times) { }\n+    : RefProcTask(ref_processor,\n+                  phase_times) {}\n@@ -592,5 +594,5 @@\n-  virtual void work(uint worker_id,\n-                    BoolObjectClosure& is_alive,\n-                    OopClosure& keep_alive,\n-                    VoidClosure& complete_gc)\n-  {\n+  void rp_work(uint worker_id,\n+               BoolObjectClosure* is_alive,\n+               OopClosure* keep_alive,\n+               VoidClosure* complete_gc) override {\n+    ResourceMark rm;\n@@ -598,1 +600,1 @@\n-    _ref_processor.process_final_keep_alive_work(_ref_processor._discoveredFinalRefs[worker_id], &keep_alive, &complete_gc);\n+    _ref_processor.process_final_keep_alive_work(_ref_processor._discoveredFinalRefs[worker_id], keep_alive, complete_gc);\n@@ -602,1 +604,1 @@\n-class RefProcPhase4Task: public AbstractRefProcTaskExecutor::ProcessTask {\n+class RefProcPhase4Task: public RefProcTask {\n@@ -604,1 +606,1 @@\n-  RefProcPhase4Task(ReferenceProcessor&           ref_processor,\n+  RefProcPhase4Task(ReferenceProcessor& ref_processor,\n@@ -606,1 +608,2 @@\n-    : ProcessTask(ref_processor, false \/* marks_oops_alive *\/, phase_times) { }\n+    : RefProcTask(ref_processor,\n+                  phase_times) {}\n@@ -608,5 +611,5 @@\n-  virtual void work(uint worker_id,\n-                    BoolObjectClosure& is_alive,\n-                    OopClosure& keep_alive,\n-                    VoidClosure& complete_gc)\n-  {\n+  void rp_work(uint worker_id,\n+               BoolObjectClosure* is_alive,\n+               OopClosure* keep_alive,\n+               VoidClosure* complete_gc) override {\n+    ResourceMark rm;\n@@ -615,3 +618,3 @@\n-                                                                    &is_alive,\n-                                                                    &keep_alive,\n-                                                                    &complete_gc);\n+                                                                    is_alive,\n+                                                                    keep_alive,\n+                                                                    complete_gc);\n@@ -774,6 +777,23 @@\n-void ReferenceProcessor::process_soft_ref_reconsider(BoolObjectClosure* is_alive,\n-                                                     OopClosure* keep_alive,\n-                                                     VoidClosure* complete_gc,\n-                                                     AbstractRefProcTaskExecutor* task_executor,\n-                                                     ReferenceProcessorPhaseTimes* phase_times) {\n-  assert(!processing_is_mt() || task_executor != NULL, \"Task executor must not be NULL when mt processing is set.\");\n+void ReferenceProcessor::run_task(RefProcTask& task, RefProcProxyTask& proxy_task, bool marks_oops_alive) {\n+  log_debug(gc, ref)(\"ReferenceProcessor::execute queues: %d, %s, marks_oops_alive: %s\",\n+                     num_queues(),\n+                     processing_is_mt() ? \"RefProcThreadModel::Multi\" : \"RefProcThreadModel::Single\",\n+                     marks_oops_alive ? \"true\" : \"false\");\n+\n+  proxy_task.prepare_run_task(task, num_queues(), processing_is_mt() ? RefProcThreadModel::Multi : RefProcThreadModel::Single, marks_oops_alive);\n+  if (processing_is_mt()) {\n+    WorkGang* gang = Universe::heap()->safepoint_workers();\n+    assert(gang != NULL, \"can not dispatch multi threaded without a work gang\");\n+    assert(gang->active_workers() >= num_queues(),\n+           \"Ergonomically chosen workers(%u) should be less than or equal to active workers(%u)\",\n+           num_queues(), gang->active_workers());\n+    gang->run_task(&proxy_task, num_queues());\n+  } else {\n+    for (unsigned i = 0; i < _max_num_queues; ++i) {\n+      proxy_task.work(i);\n+    }\n+  }\n+}\n+\n+void ReferenceProcessor::process_soft_ref_reconsider(RefProcProxyTask& proxy_task,\n+                                                     ReferenceProcessorPhaseTimes& phase_times) {\n@@ -782,2 +802,2 @@\n-  phase_times->set_ref_discovered(REF_SOFT, num_soft_refs);\n-  phase_times->set_processing_is_mt(processing_is_mt());\n+  phase_times.set_ref_discovered(REF_SOFT, num_soft_refs);\n+  phase_times.set_processing_is_mt(processing_is_mt());\n@@ -798,1 +818,1 @@\n-    RefProcBalanceQueuesTimeTracker tt(RefPhase1, phase_times);\n+    RefProcBalanceQueuesTimeTracker tt(RefPhase1, &phase_times);\n@@ -802,1 +822,1 @@\n-  RefProcPhaseTimeTracker tt(RefPhase1, phase_times);\n+  RefProcPhaseTimeTracker tt(RefPhase1, &phase_times);\n@@ -805,14 +825,2 @@\n-  if (processing_is_mt()) {\n-    RefProcPhase1Task phase1(*this, phase_times, _current_soft_ref_policy);\n-    task_executor->execute(phase1, num_queues());\n-  } else {\n-    size_t removed = 0;\n-\n-    RefProcSubPhasesWorkerTimeTracker tt2(SoftRefSubPhase1, phase_times, 0);\n-    for (uint i = 0; i < _max_num_queues; i++) {\n-      removed += process_soft_ref_reconsider_work(_discoveredSoftRefs[i], _current_soft_ref_policy,\n-                                                  is_alive, keep_alive, complete_gc);\n-    }\n-\n-    phase_times->add_ref_cleared(REF_SOFT, removed);\n-  }\n+  RefProcPhase1Task phase1(*this, &phase_times, _current_soft_ref_policy);\n+  run_task(phase1, proxy_task, true);\n@@ -822,6 +830,2 @@\n-void ReferenceProcessor::process_soft_weak_final_refs(BoolObjectClosure* is_alive,\n-                                                      OopClosure* keep_alive,\n-                                                      VoidClosure* complete_gc,\n-                                                      AbstractRefProcTaskExecutor*  task_executor,\n-                                                      ReferenceProcessorPhaseTimes* phase_times) {\n-  assert(!processing_is_mt() || task_executor != NULL, \"Task executor must not be NULL when mt processing is set.\");\n+void ReferenceProcessor::process_soft_weak_final_refs(RefProcProxyTask& proxy_task,\n+                                                      ReferenceProcessorPhaseTimes& phase_times) {\n@@ -833,2 +837,2 @@\n-  phase_times->set_ref_discovered(REF_WEAK, num_weak_refs);\n-  phase_times->set_ref_discovered(REF_FINAL, num_final_refs);\n+  phase_times.set_ref_discovered(REF_WEAK, num_weak_refs);\n+  phase_times.set_ref_discovered(REF_FINAL, num_final_refs);\n@@ -836,1 +840,1 @@\n-  phase_times->set_processing_is_mt(processing_is_mt());\n+  phase_times.set_processing_is_mt(processing_is_mt());\n@@ -846,1 +850,1 @@\n-    RefProcBalanceQueuesTimeTracker tt(RefPhase2, phase_times);\n+    RefProcBalanceQueuesTimeTracker tt(RefPhase2, &phase_times);\n@@ -852,1 +856,1 @@\n-  RefProcPhaseTimeTracker tt(RefPhase2, phase_times);\n+  RefProcPhaseTimeTracker tt(RefPhase2, &phase_times);\n@@ -857,12 +861,0 @@\n-  if (processing_is_mt()) {\n-    RefProcPhase2Task phase2(*this, phase_times);\n-    task_executor->execute(phase2, num_queues());\n-  } else {\n-    RefProcWorkerTimeTracker t(phase_times->phase2_worker_time_sec(), 0);\n-    {\n-      size_t removed = 0;\n-\n-      RefProcSubPhasesWorkerTimeTracker tt2(SoftRefSubPhase2, phase_times, 0);\n-      for (uint i = 0; i < _max_num_queues; i++) {\n-        removed += process_soft_weak_final_refs_work(_discoveredSoftRefs[i], is_alive, keep_alive, true \/* do_enqueue *\/);\n-      }\n@@ -870,9 +862,2 @@\n-      phase_times->add_ref_cleared(REF_SOFT, removed);\n-    }\n-    {\n-      size_t removed = 0;\n-\n-      RefProcSubPhasesWorkerTimeTracker tt2(WeakRefSubPhase2, phase_times, 0);\n-      for (uint i = 0; i < _max_num_queues; i++) {\n-        removed += process_soft_weak_final_refs_work(_discoveredWeakRefs[i], is_alive, keep_alive, true \/* do_enqueue *\/);\n-      }\n+  RefProcPhase2Task phase2(*this, &phase_times);\n+  run_task(phase2, proxy_task, false);\n@@ -880,14 +865,0 @@\n-      phase_times->add_ref_cleared(REF_WEAK, removed);\n-    }\n-    {\n-      size_t removed = 0;\n-\n-      RefProcSubPhasesWorkerTimeTracker tt2(FinalRefSubPhase2, phase_times, 0);\n-      for (uint i = 0; i < _max_num_queues; i++) {\n-        removed += process_soft_weak_final_refs_work(_discoveredFinalRefs[i], is_alive, keep_alive, false \/* do_enqueue *\/);\n-      }\n-\n-      phase_times->add_ref_cleared(REF_FINAL, removed);\n-    }\n-    complete_gc->do_void();\n-  }\n@@ -899,5 +870,2 @@\n-void ReferenceProcessor::process_final_keep_alive(OopClosure* keep_alive,\n-                                                  VoidClosure* complete_gc,\n-                                                  AbstractRefProcTaskExecutor*  task_executor,\n-                                                  ReferenceProcessorPhaseTimes* phase_times) {\n-  assert(!processing_is_mt() || task_executor != NULL, \"Task executor must not be NULL when mt processing is set.\");\n+void ReferenceProcessor::process_final_keep_alive(RefProcProxyTask& proxy_task,\n+                                                  ReferenceProcessorPhaseTimes& phase_times) {\n@@ -906,2 +874,1 @@\n-\n-  phase_times->set_processing_is_mt(processing_is_mt());\n+  phase_times.set_processing_is_mt(processing_is_mt());\n@@ -917,1 +884,1 @@\n-    RefProcBalanceQueuesTimeTracker tt(RefPhase3, phase_times);\n+    RefProcBalanceQueuesTimeTracker tt(RefPhase3, &phase_times);\n@@ -923,1 +890,3 @@\n-  RefProcPhaseTimeTracker tt(RefPhase3, phase_times);\n+  RefProcPhaseTimeTracker tt(RefPhase3, &phase_times);\n+  RefProcPhase3Task phase3(*this, &phase_times);\n+  run_task(phase3, proxy_task, true);\n@@ -925,9 +894,0 @@\n-  if (processing_is_mt()) {\n-    RefProcPhase3Task phase3(*this, phase_times);\n-    task_executor->execute(phase3, num_queues());\n-  } else {\n-    RefProcSubPhasesWorkerTimeTracker tt2(FinalRefSubPhase3, phase_times, 0);\n-    for (uint i = 0; i < _max_num_queues; i++) {\n-      process_final_keep_alive_work(_discoveredFinalRefs[i], keep_alive, complete_gc);\n-    }\n-  }\n@@ -937,6 +897,2 @@\n-void ReferenceProcessor::process_phantom_refs(BoolObjectClosure* is_alive,\n-                                              OopClosure* keep_alive,\n-                                              VoidClosure* complete_gc,\n-                                              AbstractRefProcTaskExecutor* task_executor,\n-                                              ReferenceProcessorPhaseTimes* phase_times) {\n-  assert(!processing_is_mt() || task_executor != NULL, \"Task executor must not be NULL when mt processing is set.\");\n+void ReferenceProcessor::process_phantom_refs(RefProcProxyTask& proxy_task,\n+                                              ReferenceProcessorPhaseTimes& phase_times) {\n@@ -945,3 +901,2 @@\n-\n-  phase_times->set_ref_discovered(REF_PHANTOM, num_phantom_refs);\n-  phase_times->set_processing_is_mt(processing_is_mt());\n+  phase_times.set_ref_discovered(REF_PHANTOM, num_phantom_refs);\n+  phase_times.set_processing_is_mt(processing_is_mt());\n@@ -957,1 +912,1 @@\n-    RefProcBalanceQueuesTimeTracker tt(RefPhase4, phase_times);\n+    RefProcBalanceQueuesTimeTracker tt(RefPhase4, &phase_times);\n@@ -962,1 +917,1 @@\n-  RefProcPhaseTimeTracker tt(RefPhase4, phase_times);\n+  RefProcPhaseTimeTracker tt(RefPhase4, &phase_times);\n@@ -965,5 +920,0 @@\n-  if (processing_is_mt()) {\n-    RefProcPhase4Task phase4(*this, phase_times);\n-    task_executor->execute(phase4, num_queues());\n-  } else {\n-    size_t removed = 0;\n@@ -971,4 +921,2 @@\n-    RefProcSubPhasesWorkerTimeTracker tt(PhantomRefSubPhase4, phase_times, 0);\n-    for (uint i = 0; i < _max_num_queues; i++) {\n-      removed += process_phantom_refs_work(_discoveredPhantomRefs[i], is_alive, keep_alive, complete_gc);\n-    }\n+  RefProcPhase4Task phase4(*this, &phase_times);\n+  run_task(phase4, proxy_task, false);\n@@ -976,2 +924,0 @@\n-    phase_times->add_ref_cleared(REF_PHANTOM, removed);\n-  }\n","filename":"src\/hotspot\/share\/gc\/shared\/referenceProcessor.cpp","additions":118,"deletions":172,"binary":false,"changes":290,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"gc\/shared\/workgroup.hpp\"\n@@ -34,1 +35,0 @@\n-class AbstractRefProcTaskExecutor;\n@@ -38,0 +38,2 @@\n+class RefProcTask;\n+class RefProcProxyTask;\n@@ -238,0 +240,2 @@\n+  void run_task(RefProcTask& task, RefProcProxyTask& proxy_task, bool marks_oops_alive);\n+\n@@ -239,5 +243,2 @@\n-  void process_soft_ref_reconsider(BoolObjectClosure* is_alive,\n-                                   OopClosure* keep_alive,\n-                                   VoidClosure* complete_gc,\n-                                   AbstractRefProcTaskExecutor*  task_executor,\n-                                   ReferenceProcessorPhaseTimes* phase_times);\n+  void process_soft_ref_reconsider(RefProcProxyTask& proxy_task,\n+                                   ReferenceProcessorPhaseTimes& phase_times);\n@@ -247,5 +248,2 @@\n-  void process_soft_weak_final_refs(BoolObjectClosure* is_alive,\n-                                    OopClosure* keep_alive,\n-                                    VoidClosure* complete_gc,\n-                                    AbstractRefProcTaskExecutor*  task_executor,\n-                                    ReferenceProcessorPhaseTimes* phase_times);\n+  void process_soft_weak_final_refs(RefProcProxyTask& proxy_task,\n+                                    ReferenceProcessorPhaseTimes& phase_times);\n@@ -254,4 +252,2 @@\n-  void process_final_keep_alive(OopClosure* keep_alive,\n-                                VoidClosure* complete_gc,\n-                                AbstractRefProcTaskExecutor*  task_executor,\n-                                ReferenceProcessorPhaseTimes* phase_times);\n+  void process_final_keep_alive(RefProcProxyTask& proxy_task,\n+                                ReferenceProcessorPhaseTimes& phase_times);\n@@ -260,5 +256,2 @@\n-  void process_phantom_refs(BoolObjectClosure* is_alive,\n-                            OopClosure* keep_alive,\n-                            VoidClosure* complete_gc,\n-                            AbstractRefProcTaskExecutor*  task_executor,\n-                            ReferenceProcessorPhaseTimes* phase_times);\n+  void process_phantom_refs(RefProcProxyTask& proxy_task,\n+                            ReferenceProcessorPhaseTimes& phase_times);\n@@ -435,5 +428,2 @@\n-  process_discovered_references(BoolObjectClosure*            is_alive,\n-                                OopClosure*                   keep_alive,\n-                                VoidClosure*                  complete_gc,\n-                                AbstractRefProcTaskExecutor*  task_executor,\n-                                ReferenceProcessorPhaseTimes* phase_times);\n+  process_discovered_references(RefProcProxyTask& proxy_task,\n+                                ReferenceProcessorPhaseTimes& phase_times);\n@@ -599,11 +589,1 @@\n-\/\/ This class is an interface used to implement task execution for the\n-\/\/ reference processing.\n-class AbstractRefProcTaskExecutor {\n-public:\n-\n-  \/\/ Abstract tasks to execute.\n-  class ProcessTask;\n-\n-  \/\/ Executes a task using worker threads.\n-  virtual void execute(ProcessTask& task, uint ergo_workers) = 0;\n-};\n+enum class RefProcThreadModel { Multi, Single };\n@@ -611,2 +591,7 @@\n-\/\/ Abstract reference processing task to execute.\n-class AbstractRefProcTaskExecutor::ProcessTask {\n+\/*\n+ * This is the (base) task that handles reference processing that does not depend on\n+ * the chosen GC (Serial, Parallel or G1). This RefProcTask will be called from a subclass\n+ * of RefProcProxyTask. The RefProcProxyTask will give the behaviour of the selected GC by\n+ * calling rp_work with the gc-specific closures.\n+ *\/\n+class RefProcTask : StackObj {\n@@ -614,4 +599,1 @@\n-  ReferenceProcessor&           _ref_processor;\n-  \/\/ Indicates whether the phase could generate work that should be balanced across\n-  \/\/ threads after execution.\n-  bool                          _marks_oops_alive;\n+  ReferenceProcessor& _ref_processor;\n@@ -620,2 +602,2 @@\n-  ProcessTask(ReferenceProcessor& ref_processor,\n-              bool marks_oops_alive,\n+public:\n+  RefProcTask(ReferenceProcessor& ref_processor,\n@@ -624,3 +606,21 @@\n-      _marks_oops_alive(marks_oops_alive),\n-      _phase_times(phase_times)\n-  { }\n+      _phase_times(phase_times) {}\n+\n+  virtual void rp_work(uint worker_id,\n+                       BoolObjectClosure* is_alive,\n+                       OopClosure* keep_alive,\n+                       VoidClosure* complete_gc) = 0;\n+};\n+\n+\/*\n+ * This is the (base) task that handles reference processing that do depend on\n+ * the chosen GC (Serial, Parallel or G1). This RefProcProxyTask will call a subclass\n+ * of RefProcTask that will handle reference processing in a generic way for Serial,\n+ * Parallel and G1. This proxy will add the relevant closures, task terminators etc.\n+ *\/\n+class RefProcProxyTask : public AbstractGangTask {\n+protected:\n+  const uint _max_workers;\n+  RefProcTask* _rp_task;\n+  RefProcThreadModel _tm;\n+  uint _queue_count;\n+  bool _marks_oops_alive;\n@@ -629,4 +629,9 @@\n-  virtual void work(uint worker_id,\n-                    BoolObjectClosure& is_alive,\n-                    OopClosure& keep_alive,\n-                    VoidClosure& complete_gc) = 0;\n+  RefProcProxyTask(const char* name, uint max_workers) : AbstractGangTask(name), _max_workers(max_workers), _rp_task(nullptr),_tm(RefProcThreadModel::Single), _queue_count(0), _marks_oops_alive(false) {}\n+\n+  void prepare_run_task(RefProcTask& rp_task, uint queue_count, RefProcThreadModel tm, bool marks_oops_alive) {\n+    _rp_task = &rp_task;\n+    _tm = tm;\n+    _queue_count = queue_count;\n+    _marks_oops_alive = marks_oops_alive;\n+    prepare_run_task_hook();\n+  }\n@@ -634,1 +639,5 @@\n-  bool marks_oops_alive() const { return _marks_oops_alive; }\n+  virtual void prepare_run_task_hook() {}\n+\n+  uint index(uint id) const {\n+    return (_tm == RefProcThreadModel::Single) ? 0 : id;\n+  }\n","filename":"src\/hotspot\/share\/gc\/shared\/referenceProcessor.hpp","additions":61,"deletions":52,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -167,3 +167,2 @@\n-                                                             ReferenceProcessorPhaseTimes* phase_times,\n-                                                             ReferenceProcessor* rp) :\n-  RefProcPhaseTimeBaseTracker(phase_enum_2_phase_string(phase_number), phase_number, phase_times), _rp(rp) {\n+                                                             ReferenceProcessorPhaseTimes* phase_times) :\n+  RefProcPhaseTimeBaseTracker(phase_enum_2_phase_string(phase_number), phase_number, phase_times) {\n","filename":"src\/hotspot\/share\/gc\/shared\/referenceProcessorPhaseTimes.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -163,1 +163,0 @@\n-  ReferenceProcessor* _rp;\n@@ -166,2 +165,1 @@\n-                                ReferenceProcessorPhaseTimes* phase_times,\n-                                ReferenceProcessor* rp);\n+                                ReferenceProcessorPhaseTimes* phase_times);\n","filename":"src\/hotspot\/share\/gc\/shared\/referenceProcessorPhaseTimes.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"}]}