{"files":[{"patch":"@@ -3315,9 +3315,9 @@\n-class G1STWRefProcClosureContext : public AbstractClosureContext {\n-  uint                           _max_workers;\n-  uint                           _queues;\n-  G1CollectedHeap&               _g1h;\n-  G1ParScanThreadStateSet&       _pss;\n-  G1ScannerTasksQueueSet&        _task_queues;\n-  TaskTerminator                 _terminator;\n-  G1STWIsAliveClosure            _is_alive;\n-  G1CopyingKeepAliveClosure*     _keep_alive;\n+class G1STWRefProcClosureContext : public AbstractRefProcClosureContext {\n+  uint _max_workers;\n+  uint _queues;\n+  G1CollectedHeap& _g1h;\n+  G1ParScanThreadStateSet& _pss;\n+  G1ScannerTasksQueueSet& _task_queues;\n+  TaskTerminator _terminator;\n+  G1STWIsAliveClosure _is_alive;\n+  G1CopyingKeepAliveClosure* _keep_alive;\n@@ -3325,3 +3325,3 @@\n-  G1CopyingKeepAliveClosure      _serial_keep_alive;\n-  G1STWDrainQueueClosure         _serial_complete_gc;\n-  ThreadModel                    _tm;\n+  G1CopyingKeepAliveClosure _serial_keep_alive;\n+  G1STWDrainQueueClosure _serial_complete_gc;\n+  RefProcThreadModel _tm;\n@@ -3330,5 +3330,4 @@\n-  G1STWRefProcClosureContext(\n-    uint max_workers,\n-    G1CollectedHeap& g1h,\n-    G1ParScanThreadStateSet& pss,\n-    G1ScannerTasksQueueSet& task_queues)\n+  G1STWRefProcClosureContext(uint max_workers,\n+                             G1CollectedHeap& g1h,\n+                             G1ParScanThreadStateSet& pss,\n+                             G1ScannerTasksQueueSet& task_queues)\n@@ -3346,1 +3345,1 @@\n-      _tm(ThreadModel::Single) {}\n+      _tm(RefProcThreadModel::Single) {}\n@@ -3353,1 +3352,4 @@\n-  BoolObjectClosure* is_alive(uint worker_id) { return &_is_alive; }\n+  BoolObjectClosure* is_alive(uint worker_id) {\n+    return &_is_alive;\n+  }\n+\n@@ -3355,3 +3357,5 @@\n-    assert(worker_id < _queues || _tm == ThreadModel::Single, \"sanity\");\n-    if (_tm == ThreadModel::Single) {\n-      return ::new (&_serial_keep_alive) G1CopyingKeepAliveClosure(&_g1h, _pss.state_for_worker(0));\n+    assert(worker_id < _queues || _tm == RefProcThreadModel::Single, \"sanity\");\n+    if (_tm == RefProcThreadModel::Single) {\n+      return &_serial_keep_alive;\n+    } else {\n+      return ::new (&_keep_alive[worker_id]) G1CopyingKeepAliveClosure(&_g1h, _pss.state_for_worker(worker_id));\n@@ -3359,1 +3363,0 @@\n-    return ::new (&_keep_alive[worker_id]) G1CopyingKeepAliveClosure(&_g1h, _pss.state_for_worker(worker_id));\n@@ -3361,0 +3364,1 @@\n+\n@@ -3362,3 +3366,5 @@\n-    assert(worker_id < _queues || _tm == ThreadModel::Single, \"sanity\");\n-    if (_tm == ThreadModel::Single) {\n-      return ::new (&_serial_complete_gc) G1STWDrainQueueClosure(&_g1h, _pss.state_for_worker(0));\n+    assert(worker_id < _queues || _tm == RefProcThreadModel::Single, \"sanity\");\n+    if (_tm == RefProcThreadModel::Single) {\n+      return &_serial_complete_gc;\n+    } else {\n+      return ::new (&_parallel_complete_gc[worker_id]) G1ParEvacuateFollowersClosure(&_g1h, _pss.state_for_worker(worker_id), &_task_queues, &_terminator, G1GCPhaseTimes::ObjCopy);\n@@ -3366,1 +3372,0 @@\n-    return ::new (&_parallel_complete_gc[worker_id]) G1ParEvacuateFollowersClosure(&_g1h, _pss.state_for_worker(worker_id), &_task_queues, &_terminator, G1GCPhaseTimes::ObjCopy);\n@@ -3369,1 +3374,1 @@\n-  void prepare_run_task(uint queue_count, ThreadModel tm, bool marks_oops_alive) {\n+  void prepare_run_task(uint queue_count, RefProcThreadModel tm, bool marks_oops_alive) {\n@@ -3376,1 +3381,1 @@\n-      _pss.state_for_worker(qid)->set_ref_discoverer(nullptr); \/\/ move?, maybe not...\n+      _pss.state_for_worker(qid)->set_ref_discoverer(nullptr);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":34,"deletions":29,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -1464,4 +1464,4 @@\n-class G1CMRefProcClosureContext : public AbstractClosureContext {\n-  uint                          _max_workers;\n-  G1ConcurrentMark&             _cm;\n-  G1CMIsAliveClosure            _is_alive;\n+class G1CMRefProcClosureContext : public AbstractRefProcClosureContext {\n+  uint _max_workers;\n+  G1ConcurrentMark& _cm;\n+  G1CMIsAliveClosure _is_alive;\n@@ -1470,1 +1470,1 @@\n-  ThreadModel                   _tm;\n+  RefProcThreadModel _tm;\n@@ -1473,4 +1473,3 @@\n-  G1CMRefProcClosureContext(\n-    uint max_workers,\n-    G1CollectedHeap& g1h,\n-    G1ConcurrentMark& cm)\n+  G1CMRefProcClosureContext(uint max_workers,\n+                            G1CollectedHeap& g1h,\n+                            G1ConcurrentMark& cm)\n@@ -1482,1 +1481,1 @@\n-      _tm(ThreadModel::Single) {}\n+      _tm(RefProcThreadModel::Single) {}\n@@ -1489,2 +1488,5 @@\n-  BoolObjectClosure* is_alive(uint worker_id) { return &_is_alive; }\n-  OopClosure* keep_alive(uint worker_id)      {\n+  BoolObjectClosure* is_alive(uint worker_id) {\n+    return &_is_alive;\n+  }\n+\n+  OopClosure* keep_alive(uint worker_id) {\n@@ -1492,1 +1494,1 @@\n-    return ::new (&_keep_alive[index(worker_id, _tm)]) G1CMKeepAliveAndDrainClosure(&_cm, _cm.task(index(worker_id, _tm)), _tm == ThreadModel::Single );\n+    return ::new (&_keep_alive[index(worker_id, _tm)]) G1CMKeepAliveAndDrainClosure(&_cm, _cm.task(index(worker_id, _tm)), _tm == RefProcThreadModel::Single );\n@@ -1494,1 +1496,2 @@\n-  VoidClosure* complete_gc(uint worker_id)    {\n+\n+  VoidClosure* complete_gc(uint worker_id) {\n@@ -1496,1 +1499,1 @@\n-    return ::new (&_complete_gc[index(worker_id, _tm)]) G1CMDrainMarkingStackClosure(&_cm, _cm.task(index(worker_id, _tm)), _tm == ThreadModel::Single);\n+    return ::new (&_complete_gc[index(worker_id, _tm)]) G1CMDrainMarkingStackClosure(&_cm, _cm.task(index(worker_id, _tm)), _tm == RefProcThreadModel::Single);\n@@ -1498,1 +1501,2 @@\n-  void prepare_run_task(uint queue_count, ThreadModel tm, bool marks_oops_alive) {\n+\n+  void prepare_run_task(uint queue_count, RefProcThreadModel tm, bool marks_oops_alive) {\n@@ -1533,2 +1537,0 @@\n-\n-    \/\/ reference processing context.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":20,"deletions":18,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -281,4 +281,0 @@\n-  friend class G1ConcurrentMarkThread;\n-  friend class G1CMRefProcClosureContext;\n-  friend class G1CMKeepAliveAndDrainClosure;\n-  friend class G1CMDrainMarkingStackClosure;\n@@ -287,0 +283,3 @@\n+  friend class G1CMDrainMarkingStackClosure;\n+  friend class G1CMKeepAliveAndDrainClosure;\n+  friend class G1CMRefProcClosureContext;\n@@ -289,0 +288,1 @@\n+  friend class G1ConcurrentMarkThread;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -232,4 +232,4 @@\n-class G1FullRefProcClosureContext : public AbstractClosureContext {\n-  uint                    _max_workers;\n-  G1FullCollector&        _collector;\n-  G1IsAliveClosure        _is_alive;\n+class G1FullGCRefProcClosureContext : public AbstractRefProcClosureContext {\n+  uint _max_workers;\n+  G1FullCollector& _collector;\n+  G1IsAliveClosure _is_alive;\n@@ -237,1 +237,1 @@\n-  ThreadModel             _tm;\n+  RefProcThreadModel _tm;\n@@ -240,4 +240,8 @@\n-  G1FullRefProcClosureContext(G1FullCollector& collector, uint max_workers)\n-    : _max_workers(max_workers), _collector(collector), _is_alive(&collector), _keep_alive(NEW_C_HEAP_ARRAY(G1FullKeepAliveClosure, max_workers, mtGC)), _tm(ThreadModel::Single) {}\n-\n-  ~G1FullRefProcClosureContext() {\n+  G1FullGCRefProcClosureContext(G1FullCollector& collector, uint max_workers)\n+    : _max_workers(max_workers),\n+      _collector(collector),\n+      _is_alive(&collector),\n+      _keep_alive(NEW_C_HEAP_ARRAY(G1FullKeepAliveClosure, max_workers, mtGC)),\n+      _tm(RefProcThreadModel::Single) {}\n+\n+  ~G1FullGCRefProcClosureContext() {\n@@ -246,0 +250,1 @@\n+\n@@ -250,0 +255,1 @@\n+\n@@ -254,0 +260,1 @@\n+\n@@ -258,2 +265,3 @@\n-  void prepare_run_task(uint queue_count, ThreadModel tm, bool marks_oops_alive) {\n-    log_debug(gc, ref)(\"G1FullRefProcClosureContext: prepare_run_task\");\n+\n+  void prepare_run_task(uint queue_count, RefProcThreadModel tm, bool marks_oops_alive) {\n+    log_debug(gc, ref)(\"G1FullGCRefProcClosureContext: prepare_run_task\");\n@@ -281,1 +289,1 @@\n-    G1FullRefProcClosureContext context(*this, reference_processor()->max_num_queues());\n+    G1FullGCRefProcClosureContext context(*this, reference_processor()->max_num_queues());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":20,"deletions":12,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-  friend class PCRefProcClosureContext;\n+  friend class ParallelCompactRefProcClosureContext;\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCompactionManager.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2098,4 +2098,4 @@\n-class PCRefProcClosureContext : public AbstractClosureContext {\n-  uint                                      _max_workers;\n-  TaskTerminator                            _terminator;\n-  PCMarkAndPushClosure*                     _keep_alive;\n+class ParallelCompactRefProcClosureContext : public AbstractRefProcClosureContext {\n+  uint _max_workers;\n+  TaskTerminator _terminator;\n+  PCMarkAndPushClosure* _keep_alive;\n@@ -2103,1 +2103,1 @@\n-  ThreadModel                               _tm;\n+  RefProcThreadModel _tm;\n@@ -2106,1 +2106,1 @@\n-  PCRefProcClosureContext(uint max_workers)\n+  ParallelCompactRefProcClosureContext(uint max_workers)\n@@ -2111,1 +2111,1 @@\n-      _tm(ThreadModel::Single) {}\n+      _tm(RefProcThreadModel::Single) {}\n@@ -2113,1 +2113,1 @@\n-  ~PCRefProcClosureContext() {\n+  ~ParallelCompactRefProcClosureContext() {\n@@ -2121,0 +2121,1 @@\n+\n@@ -2125,0 +2126,1 @@\n+\n@@ -2127,1 +2129,1 @@\n-    return ::new (&_complete_gc[worker_id]) ParCompactionManager::FollowStackClosure(cm, (_tm == ThreadModel::Single)?nullptr:&_terminator, worker_id);\n+    return ::new (&_complete_gc[worker_id]) ParCompactionManager::FollowStackClosure(cm, (_tm == RefProcThreadModel::Single) ? nullptr : &_terminator, worker_id);\n@@ -2129,2 +2131,3 @@\n-  void prepare_run_task(uint queue_count, ThreadModel tm, bool marks_oops_alive) {\n-    log_debug(gc, ref)(\"PCRefProcClosureContext: prepare_run_task\");\n+\n+  void prepare_run_task(uint queue_count, RefProcThreadModel tm, bool marks_oops_alive) {\n+    log_debug(gc, ref)(\"ParallelCompactRefProcClosureContext: prepare_run_task\");\n@@ -2163,1 +2166,1 @@\n-    PCRefProcClosureContext context(ref_processor()->max_num_queues());\n+    ParallelCompactRefProcClosureContext context(ref_processor()->max_num_queues());\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":15,"deletions":12,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-  friend class PSRefProcClosureContext;\n+  friend class ParallelScavengeRefProcClosureContext;\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -191,1 +191,1 @@\n-    assert(_promotion_manager != NULL, \"Sanity\");\n+    assert(_promotion_manager != nullptr, \"Sanity\");\n@@ -202,6 +202,6 @@\n-class PSRefProcClosureContext : public AbstractClosureContext {\n-  uint                        _max_workers;\n-  TaskTerminator              _terminator;\n-  TaskTerminator*             _maybe_terminator; \/\/ nullptr when no termination is to be done\n-  PSIsAliveClosure            _is_alive;\n-  PSKeepAliveClosure*         _keep_alive;\n+class ParallelScavengeRefProcClosureContext : public AbstractRefProcClosureContext {\n+  uint _max_workers;\n+  TaskTerminator _terminator;\n+  TaskTerminator* _maybe_terminator; \/\/ nullptr when no termination is to be done\n+  PSIsAliveClosure _is_alive;\n+  PSKeepAliveClosure* _keep_alive;\n@@ -211,1 +211,1 @@\n-  PSRefProcClosureContext(uint max_workers)\n+  ParallelScavengeRefProcClosureContext(uint max_workers)\n@@ -219,1 +219,1 @@\n-  ~PSRefProcClosureContext() {\n+  ~ParallelScavengeRefProcClosureContext() {\n@@ -224,1 +224,4 @@\n-  BoolObjectClosure* is_alive(uint worker_id) { return &_is_alive; }\n+  BoolObjectClosure* is_alive(uint worker_id) {\n+    return &_is_alive;\n+  }\n+\n@@ -229,0 +232,1 @@\n+\n@@ -233,2 +237,3 @@\n-  void prepare_run_task(uint queue_count, ThreadModel tm, bool marks_oops_alive) {\n-    log_debug(gc, ref)(\"PSRefProcClosureContext: prepare_run_task\");\n+\n+  void prepare_run_task(uint queue_count, RefProcThreadModel tm, bool marks_oops_alive) {\n+    log_debug(gc, ref)(\"ParallelScavengeRefProcClosureContext: prepare_run_task\");\n@@ -237,1 +242,1 @@\n-    _maybe_terminator = (marks_oops_alive && tm == ThreadModel::Multi)?&_terminator:nullptr;\n+    _maybe_terminator = (marks_oops_alive && tm == RefProcThreadModel::Multi)?&_terminator:nullptr;\n@@ -515,1 +520,1 @@\n-      PSRefProcClosureContext context(reference_processor()->max_num_queues());\n+      ParallelScavengeRefProcClosureContext context(reference_processor()->max_num_queues());\n","filename":"src\/hotspot\/share\/gc\/parallel\/psScavenge.cpp","additions":19,"deletions":14,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-#include \"gc\/serial\/serialClosureContext.hpp\"\n+#include \"gc\/serial\/serialGcRefProcClosureContext.hpp\"\n@@ -591,1 +591,1 @@\n-  SerialClosureContext closure_context(is_alive, keep_alive, evacuate_followers);\n+  SerialGCRefProcClosureContext closure_context(is_alive, keep_alive, evacuate_followers);\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-#include \"gc\/serial\/serialClosureContext.hpp\"\n+#include \"gc\/serial\/serialGcRefProcClosureContext.hpp\"\n@@ -202,1 +202,1 @@\n-    SerialClosureContext closure_context(is_alive, keep_alive, follow_stack_closure);\n+    SerialGCRefProcClosureContext closure_context(is_alive, keep_alive, follow_stack_closure);\n","filename":"src\/hotspot\/share\/gc\/serial\/genMarkSweep.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,43 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_SERIAL_SERIALCLOSURECONTEXT_HPP\n-#define SHARE_GC_SERIAL_SERIALCLOSURECONTEXT_HPP\n-\n-#include \"gc\/shared\/referenceProcessor.hpp\"\n-\n-class SerialClosureContext : public AbstractClosureContext {\n-  BoolObjectClosure& _is_alive;\n-  OopClosure& _keep_alive;\n-  VoidClosure& _complete_gc;\n-public:\n-  SerialClosureContext(BoolObjectClosure& is_alive, OopClosure& keep_alive, VoidClosure& complete_gc)\n-    : _is_alive(is_alive), _keep_alive(keep_alive), _complete_gc(complete_gc) {};\n-  BoolObjectClosure* is_alive(uint worker_id)                                    { return &_is_alive; }\n-  OopClosure* keep_alive(uint worker_id)                                         { return &_keep_alive; }\n-  VoidClosure* complete_gc(uint worker_id)                                       { return &_complete_gc; }\n-  void prepare_run_task(uint queue_count, ThreadModel tm, bool marks_oops_alive) { log_debug(gc, ref)(\"SerialClosureContext: prepare_run_task\"); };\n-};\n-\n-#endif \/* SHARE_GC_SERIAL_SERIALCLOSURECONTEXT_HPP *\/\n","filename":"src\/hotspot\/share\/gc\/serial\/serialClosureContext.hpp","additions":0,"deletions":43,"binary":false,"changes":43,"status":"deleted"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SERIAL_SERIALGCREFPROCCLOSURECONTEXT_HPP\n+#define SHARE_GC_SERIAL_SERIALGCREFPROCCLOSURECONTEXT_HPP\n+\n+#include \"gc\/shared\/referenceProcessor.hpp\"\n+\n+class SerialGCRefProcClosureContext : public AbstractRefProcClosureContext {\n+  BoolObjectClosure& _is_alive;\n+  OopClosure& _keep_alive;\n+  VoidClosure& _complete_gc;\n+\n+public:\n+  SerialGCRefProcClosureContext(BoolObjectClosure& is_alive,\n+                                OopClosure& keep_alive,\n+                                VoidClosure& complete_gc)\n+    : _is_alive(is_alive),\n+      _keep_alive(keep_alive),\n+      _complete_gc(complete_gc) {}\n+\n+  BoolObjectClosure* is_alive(uint worker_id) {\n+    return &_is_alive;\n+  }\n+\n+  OopClosure* keep_alive(uint worker_id) {\n+    return &_keep_alive;\n+  }\n+\n+  VoidClosure* complete_gc(uint worker_id) {\n+    return &_complete_gc;\n+  }\n+\n+  void prepare_run_task(uint queue_count, RefProcThreadModel tm, bool marks_oops_alive) {\n+    log_debug(gc, ref)(\"SerialGCRefProcClosureContext: prepare_run_task\");\n+  };\n+};\n+\n+#endif \/* SHARE_GC_SERIAL_SERIALGCREFPROCCLOSURECONTEXT_HPP *\/\n","filename":"src\/hotspot\/share\/gc\/serial\/serialGcRefProcClosureContext.hpp","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -199,3 +199,2 @@\n-ReferenceProcessorStats ReferenceProcessor::process_discovered_references(\n-  AbstractClosureContext& closure_context,\n-  ReferenceProcessorPhaseTimes& phase_times) {\n+ReferenceProcessorStats ReferenceProcessor::process_discovered_references(AbstractRefProcClosureContext& closure_context,\n+                                                                          ReferenceProcessorPhaseTimes& phase_times) {\n@@ -519,1 +518,1 @@\n-  AbstractClosureContext& _closure_context;\n+  AbstractRefProcClosureContext& _closure_context;\n@@ -522,5 +521,4 @@\n-  RefProcTask(\n-    const char* name,\n-    ReferenceProcessor& ref_processor,\n-    ReferenceProcessorPhaseTimes* phase_times,\n-    AbstractClosureContext& closure_context)\n+  RefProcTask(const char* name,\n+              ReferenceProcessor& ref_processor,\n+              ReferenceProcessorPhaseTimes* phase_times,\n+              AbstractRefProcClosureContext& closure_context)\n@@ -535,1 +533,1 @@\n-  RefProcPhase1Task(ReferenceProcessor&           ref_processor,\n+  RefProcPhase1Task(ReferenceProcessor& ref_processor,\n@@ -537,7 +535,7 @@\n-                    ReferencePolicy*              policy,\n-                    AbstractClosureContext&       closure_context)\n-  : RefProcTask(\"RefProcPhase1Task\",\n-            ref_processor,\n-            phase_times,\n-            closure_context),\n-    _policy(policy) { }\n+                    ReferencePolicy* policy,\n+                    AbstractRefProcClosureContext& closure_context)\n+    : RefProcTask(\"RefProcPhase1Task\",\n+                  ref_processor,\n+                  phase_times,\n+                  closure_context),\n+      _policy(policy) { }\n@@ -563,1 +561,1 @@\n-                  AbstractClosureContext& closure_context,\n+                  AbstractRefProcClosureContext& closure_context,\n@@ -576,1 +574,1 @@\n-                    AbstractClosureContext& closure_context)\n+                    AbstractRefProcClosureContext& closure_context)\n@@ -578,3 +576,3 @@\n-              ref_processor,\n-              phase_times,\n-              closure_context) { }\n+                  ref_processor,\n+                  phase_times,\n+                  closure_context) { }\n@@ -605,1 +603,1 @@\n-  RefProcPhase3Task(ReferenceProcessor&           ref_processor,\n+  RefProcPhase3Task(ReferenceProcessor& ref_processor,\n@@ -607,1 +605,1 @@\n-                    AbstractClosureContext& closure_context)\n+                    AbstractRefProcClosureContext& closure_context)\n@@ -609,3 +607,3 @@\n-              ref_processor,\n-              phase_times,\n-              closure_context) { }\n+                  ref_processor,\n+                  phase_times,\n+                  closure_context) { }\n@@ -624,1 +622,1 @@\n-  RefProcPhase4Task(ReferenceProcessor&           ref_processor,\n+  RefProcPhase4Task(ReferenceProcessor& ref_processor,\n@@ -626,1 +624,1 @@\n-                    AbstractClosureContext&       closure_context)\n+                    AbstractRefProcClosureContext& closure_context)\n@@ -628,3 +626,3 @@\n-              ref_processor,\n-              phase_times,\n-              closure_context) { }\n+                  ref_processor,\n+                  phase_times,\n+                  closure_context) { }\n@@ -796,1 +794,1 @@\n-void ReferenceProcessor::run_task(AbstractGangTask& task, AbstractClosureContext& closure_context, bool marks_oops_alive) {\n+void ReferenceProcessor::run_task(AbstractGangTask& task, AbstractRefProcClosureContext& closure_context, bool marks_oops_alive) {\n@@ -800,2 +798,5 @@\n-    num_queues(), processing_is_mt() ? \"ThreadModel::Multi\" : \"ThreadModel::Single\", marks_oops_alive?\"true\":\"false\");\n-  closure_context.prepare_run_task(num_queues(), processing_is_mt() ? ThreadModel::Multi : ThreadModel::Single, marks_oops_alive);\n+                     num_queues(),\n+                     processing_is_mt() ? \"RefProcThreadModel::Multi\" : \"RefProcThreadModel::Single\",\n+                     marks_oops_alive ? \"true\" : \"false\");\n+\n+  closure_context.prepare_run_task(num_queues(), processing_is_mt() ? RefProcThreadModel::Multi : RefProcThreadModel::Single, marks_oops_alive);\n@@ -808,1 +809,0 @@\n-    log_debug(gc, ref)(\"Serial loop: %d\\n\", _max_num_queues);\n@@ -815,1 +815,1 @@\n-void ReferenceProcessor::process_soft_ref_reconsider(AbstractClosureContext& closure_context,\n+void ReferenceProcessor::process_soft_ref_reconsider(AbstractRefProcClosureContext& closure_context,\n@@ -847,1 +847,1 @@\n-void ReferenceProcessor::process_soft_weak_final_refs(AbstractClosureContext& closure_context,\n+void ReferenceProcessor::process_soft_weak_final_refs(AbstractRefProcClosureContext& closure_context,\n@@ -887,1 +887,1 @@\n-void ReferenceProcessor::process_final_keep_alive(AbstractClosureContext& closure_context,\n+void ReferenceProcessor::process_final_keep_alive(AbstractRefProcClosureContext& closure_context,\n@@ -914,1 +914,1 @@\n-void ReferenceProcessor::process_phantom_refs(AbstractClosureContext& closure_context,\n+void ReferenceProcessor::process_phantom_refs(AbstractRefProcClosureContext& closure_context,\n","filename":"src\/hotspot\/share\/gc\/shared\/referenceProcessor.cpp","additions":40,"deletions":40,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-class AbstractClosureContext;\n+class AbstractRefProcClosureContext;\n@@ -239,1 +239,1 @@\n-  void run_task(AbstractGangTask& task, AbstractClosureContext& closure_context, bool marks_oops_alive);\n+  void run_task(AbstractGangTask& task, AbstractRefProcClosureContext& closure_context, bool marks_oops_alive);\n@@ -242,1 +242,1 @@\n-  void process_soft_ref_reconsider(AbstractClosureContext& closure_context,\n+  void process_soft_ref_reconsider(AbstractRefProcClosureContext& closure_context,\n@@ -247,1 +247,1 @@\n-  void process_soft_weak_final_refs(AbstractClosureContext& closure_context,\n+  void process_soft_weak_final_refs(AbstractRefProcClosureContext& closure_context,\n@@ -251,1 +251,1 @@\n-  void process_final_keep_alive(AbstractClosureContext& closure_context,\n+  void process_final_keep_alive(AbstractRefProcClosureContext& closure_context,\n@@ -255,1 +255,1 @@\n-  void process_phantom_refs(AbstractClosureContext& closure_context,\n+  void process_phantom_refs(AbstractRefProcClosureContext& closure_context,\n@@ -427,1 +427,1 @@\n-  process_discovered_references(AbstractClosureContext&  closure_context,\n+  process_discovered_references(AbstractRefProcClosureContext&  closure_context,\n@@ -588,1 +588,1 @@\n-enum class ThreadModel {Multi, Single};\n+enum class RefProcThreadModel { Multi, Single };\n@@ -590,1 +590,1 @@\n-class AbstractClosureContext {\n+class AbstractRefProcClosureContext {\n@@ -595,2 +595,2 @@\n-  virtual void prepare_run_task(uint queue_count, ThreadModel tm, bool marks_oops_alive) = 0;\n-  uint index(uint id, ThreadModel tm) { return (tm==ThreadModel::Single)?0:id; }\n+  virtual void prepare_run_task(uint queue_count, RefProcThreadModel tm, bool marks_oops_alive) = 0;\n+  uint index(uint id, RefProcThreadModel tm) { return (tm == RefProcThreadModel::Single) ? 0 : id; }\n","filename":"src\/hotspot\/share\/gc\/shared\/referenceProcessor.hpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"}]}