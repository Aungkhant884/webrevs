{"files":[{"patch":"@@ -215,21 +215,0 @@\n-\/\/ Return the number of arguments parsed.\n-static int parse_args(char* line, const char** args, uint args_count, const char delim) {\n-  if (line == NULL || args == NULL || delim == '\\0')\n-    return 0;\n-\n-  char* ptr = line;\n-  uint count = 0;\n-  while (count < args_count) {\n-    args[count++] = ptr;\n-    while (*ptr != delim && *ptr != '\\0') {\n-      ptr++;\n-    }\n-    if (*ptr == '\\0') {\n-      return count;\n-    }\n-    *ptr = '\\0';\n-    ptr++;\n-  }\n-  return count;\n-}\n-\n@@ -242,1 +221,1 @@\n-\/\/   arg2: more_args: \"compress_level,parallel\"\n+\/\/   arg2: Compress level\n@@ -244,15 +223,1 @@\n-  \/\/ Possible argument number for op->arg(2).\n-  const int MAX_EXTRA_ARGS_COUNT = 2;\n-  const char* extra_args[MAX_EXTRA_ARGS_COUNT] = {NULL};\n-  const char* arg_str = op->arg(2);\n-  const char* path = NULL;\n-  bool live_objects_only = true;   \/\/ default is true to retain the behavior before this change is made\n-\n-  \/\/ Parse heap dump arguments. Because the max arguments number can exceed the limitation\n-  \/\/ defined by AttachOperation::arg_count_max, the argument passing style has changed.\n-  \/\/ For backward compatibility, arguments are passed by op->arg(i) where i range from 0-2.\n-  \/\/ But the op->arg(2) may contain many arguments that need to be parsed here.\n-\n-  \/\/ First process filename and liveopt.\n-  \/\/ filename\n-  path = op->arg(0);\n+  const char* path = op->arg(0);\n@@ -261,1 +226,0 @@\n-    return JNI_ERR;\n@@ -263,1 +227,1 @@\n-    \/\/ -live\n+    bool live_objects_only = true;   \/\/ default is true to retain the behavior before this change is made\n@@ -272,1 +236,0 @@\n-  }\n@@ -274,9 +237,1 @@\n-  \/\/ Then parse arguments from op->arg(2).\n-  \/\/ Format: \"compress_level,parallel\".\n-  if (arg_str != NULL && arg_str[0] != '\\0') {\n-    int args_len = strlen(arg_str);\n-    char* args_line = NEW_C_HEAP_ARRAY(char, args_len + 1, mtInternal);\n-    snprintf(args_line, args_len + 1, \"%s\", arg_str);\n-    int args_count = parse_args(args_line, extra_args, MAX_EXTRA_ARGS_COUNT, ',');\n-    \/\/ gz=\n-    const char* num_str = extra_args[0];\n+    const char* num_str = op->arg(2);\n@@ -293,11 +248,0 @@\n-    \/\/ parallel=\n-    uint parallel_thread_num = MAX2<uint>(1, (uint)os::initial_active_processor_count() * 3 \/ 8);\n-    const char* par_str = extra_args[1];\n-    if (par_str != NULL && par_str[0] != '\\0') {\n-      uintx num;\n-      if (!Arguments::parse_uintx(par_str, &num, 0)) {\n-        out->print_cr(\"Invalid parallel thread number: [%s]\", par_str);\n-        return JNI_ERR;\n-      }\n-      parallel_thread_num = num == 0 ? parallel_thread_num : (uint)num;\n-    }\n@@ -305,0 +249,4 @@\n+    \/\/ parallel thread number for heap dump, initialize based on active processor count.\n+    \/\/ Note the real number of threads used is also determined by active workers and compression\n+    \/\/ backend thread number.\n+    uint parallel_thread_num = MAX2<uint>(1, (uint)os::initial_active_processor_count() * 3 \/ 8);\n@@ -310,1 +258,0 @@\n-    FREE_C_HEAP_ARRAY(char, args_line);\n","filename":"src\/hotspot\/share\/services\/attachListener.cpp","additions":8,"deletions":61,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -634,1 +634,1 @@\n-struct ParWriterBufferListEntry {\n+struct ParWriterBufferQueueElem {\n@@ -637,1 +637,58 @@\n-  ParWriterBufferListEntry* _next;\n+  ParWriterBufferQueueElem* _next;\n+};\n+\n+class ParWriterBufferQueue : public CHeapObj<mtInternal> {\n+ private:\n+  ParWriterBufferQueueElem* _head;\n+  ParWriterBufferQueueElem* _tail;\n+  uint _length;\n+ public:\n+  ParWriterBufferQueue() : _head(NULL), _tail(NULL), _length(0) { }\n+\n+  bool enqueue(char* buffer, size_t size) {\n+      if (_head == NULL) {\n+        assert(is_empty() && _tail == NULL, \"Sanity check\");\n+        _head = _tail =\n+          (ParWriterBufferQueueElem*)os::malloc(sizeof(ParWriterBufferQueueElem), mtInternal);\n+        if (_head == NULL) {\n+          \/\/ \"Could not allocate buffer list for writer\"\n+          return false;\n+        }\n+      _tail->_buffer = buffer;\n+      _tail->_used = size;\n+      _tail->_next = NULL;\n+      _length++;\n+    } else {\n+      assert ((_tail->_next == NULL && _tail->_buffer != NULL), \"Buffer queue is polluted\");\n+\n+      ParWriterBufferQueueElem* entry =\n+          (ParWriterBufferQueueElem*)os::malloc(sizeof(ParWriterBufferQueueElem), mtInternal);\n+      if (entry == NULL) {\n+        \/\/ \"Could not allocate buffer list for writer\"\n+        return false;\n+      }\n+      entry->_buffer = buffer;\n+      entry->_used = size;\n+      entry->_next = NULL;\n+      _tail->_next = entry;\n+      _tail = entry;\n+      _length++;\n+    }\n+    return true;\n+  }\n+\n+  ParWriterBufferQueueElem* dequeue() {\n+    if (_head == NULL) return NULL;\n+    ParWriterBufferQueueElem* entry = _head;\n+    assert (entry->_buffer != NULL, \"polluted buffer in writer list\");\n+    _head = entry->_next;\n+    entry->_next = NULL;\n+    _length--;\n+    return entry;\n+  }\n+\n+  bool is_empty() {\n+    return _length == 0;\n+  }\n+\n+  uint length() { return _length; }\n@@ -648,3 +705,1 @@\n-  ParWriterBufferListEntry* _list_head;\n-  ParWriterBufferListEntry* _list_tail;\n-  uint _list_length;\n+  ParWriterBufferQueue* _buffer_queue;\n@@ -676,5 +731,3 @@\n-    _list_head(NULL),\n-    _list_tail(NULL) {\n-      \/\/ todo. assert backend has no data to compress.\n-    _buffer_base = NULL;\n-    _splited_data = false;\n+    _buffer_queue(NULL),\n+    _buffer_base(NULL),\n+    _splited_data(false) {\n@@ -685,1 +738,5 @@\n-     assert(_internal_buffer_used == 0 ,\"All data must be send to backend\");\n+     assert(_buffer_queue != NULL, \"Sanity check\");\n+     assert((_internal_buffer_used == 0) && (_buffer_queue->is_empty()),\n+            \"All data must be send to backend\");\n+     delete _buffer_queue;\n+     _buffer_queue = NULL;\n@@ -730,2 +787,0 @@\n-    assert(_buffer == NULL && _pos == 0 &&\n-            _list_head == NULL, \"Invalid state for initialize\");\n@@ -734,1 +789,0 @@\n-    _list_length = 0;\n@@ -738,1 +792,7 @@\n-    assert(_buffer == NULL && _buffer_base == NULL, \"sanity check\");\n+    assert(_buffer == NULL && _buffer_base == NULL, \"current buffer must be NULL before allocate\");\n+    _buffer_queue = (new (std::nothrow) ParWriterBufferQueue());\n+    if (_buffer_queue == NULL) {\n+      set_error(\"Could not allocate buffer queue for writer\");\n+      return;\n+    }\n+\n@@ -771,36 +831,4 @@\n-    \/\/ need new buffer.\n-    if (_list_head == NULL) {\n-\n-      \/\/ TODO. list.isEmpty();\n-      \/\/       list.push();\n-      assert(_list_tail == NULL, \"Santy check\");\n-      _list_head = _list_tail =\n-          (ParWriterBufferListEntry*)os::malloc(sizeof(ParWriterBufferListEntry), mtInternal);\n-      if (_list_head == NULL) {\n-        set_error(\"Could not allocate buffer list for writer\");\n-        return;\n-      }\n-      assert(_buffer - _buffer_base <= io_buffer_max_size, \"internal buffer overflow\");\n-      _list_tail->_buffer = _buffer_base;\n-      _list_tail->_used = expected_total;\n-      _list_tail->_next = NULL;\n-      _list_length++;\n-      _buffer_base =_buffer = NULL;\n-    } else {\n-      assert ((_list_tail->_next == NULL && _list_tail->_buffer != NULL), \"writer has polluted buffer list\");\n-\n-      ParWriterBufferListEntry* entry =\n-          (ParWriterBufferListEntry*)os::malloc(sizeof(ParWriterBufferListEntry), mtInternal);\n-      if (entry == NULL) {\n-        set_error(\"Could not allocate buffer list entry for writer\");\n-        return;\n-      }\n-      \/\/ Todo zlin: combine code above, enqueue()\n-      assert(_buffer - _buffer_base <= io_buffer_max_size, \"internal buffer overflow\");\n-      entry->_buffer = _buffer_base;\n-      entry->_used = expected_total;\n-      entry->_next = NULL;\n-      _list_tail->_next = entry;\n-      _list_tail = entry;\n-      _list_length++;\n-      _buffer_base =_buffer = NULL;\n+    assert(_buffer - _buffer_base <= io_buffer_max_size, \"internal buffer overflow\");\n+    if (!_buffer_queue->enqueue(_buffer_base, expected_total)) {\n+      set_error(\"Heap dumper can not enqueue to internal buffer\");\n+      return;\n@@ -808,0 +836,1 @@\n+    _buffer_base =_buffer = NULL;\n@@ -811,1 +840,1 @@\n-  void reclaim_entry(ParWriterBufferListEntry* entry) {\n+  void reclaim_entry(ParWriterBufferQueueElem* entry) {\n@@ -826,1 +855,1 @@\n-    return force || _list_length > backend_flush_threshold;\n+    return force || _buffer_queue->length() > backend_flush_threshold;\n@@ -832,7 +861,2 @@\n-    while (_list_head !=  NULL) {\n-      \/\/TODO: zlin dequeue\n-      ParWriterBufferListEntry* entry = _list_head;\n-      assert (entry->_buffer != NULL, \"polluted buffer in writer list\");\n-      _list_head = entry->_next;\n-      entry->_next = NULL;\n-      _list_length--;\n+    while (!_buffer_queue->is_empty()) {\n+      ParWriterBufferQueueElem* entry = _buffer_queue->dequeue();\n@@ -844,2 +868,1 @@\n-    assert(_list_length == 0, \"must send all list entries to backend!\");\n-    assert(_pos == 0, \"_pos is not zero [%d]\", (int)_pos);\n+    assert(_pos == 0, \"available buffer must be clean before flush\");\n@@ -856,3 +879,0 @@\n-\n-    assert(_list_head == NULL, \"buffer list must be empty after flush to backend\");\n-    _list_tail = NULL;\n","filename":"src\/hotspot\/share\/services\/heapDumper.cpp","additions":85,"deletions":65,"binary":false,"changes":150,"status":"modified"},{"patch":"@@ -437,1 +437,0 @@\n-        assert(_current->_in_used > 0 || force_reset, \"zlin - must enqueue non-empty buffer\");\n","filename":"src\/hotspot\/share\/services\/heapDumperCompression.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -212,2 +212,1 @@\n-        String compress_level = \"\";\n-        String parallel = \"\";\n+        String compress_level = null;\n@@ -235,6 +234,0 @@\n-            } else if (subopt.startsWith(\"parallel=\")) {\n-               parallel = subopt.substring(\"parallel=\".length());\n-               if (parallel == null) {\n-                    System.err.println(\"Fail: no number provided in option: '\" + subopt + \"'\");\n-                    usage(1);\n-               }\n@@ -254,9 +247,0 @@\n-        \/\/ There is a limitation that at most 3 arguments could be passed to hotspot.\n-        \/\/ For backward compatibility, pass filename and liveopt as 1st and 2nd argument and\n-        \/\/ then compose remaining arguments as the 3rd one, and use comma to seperate them.\n-        \/\/ The difinition of 3rd argument in current implementation is:\n-        \/\/        \"compress_level,parallel\"\n-        \/\/ Not that making all arguments as a whole string like jcmd did does not guarantee the\n-        \/\/ compatiabilty when the new jmap is uses on old version of JDK.\n-        \/\/ See AttachOperation::arg_count_max in attachListener.hpp for argument count limitation.\n-        String more_args = compress_level + \",\" + parallel;\n@@ -264,1 +248,1 @@\n-        executeCommandForPid(pid, \"dumpheap\", filename, liveopt, more_args);\n+        executeCommandForPid(pid, \"dumpheap\", filename, liveopt, compress_level);\n@@ -331,4 +315,0 @@\n-        System.err.println(\"      parallel=<number>  parallel threads number for heap dump:\");\n-        System.err.println(\"                                  parallel=0 default behavior, use predefined number of threads\");\n-        System.err.println(\"                                  parallel=1 disable parallel heap iteration\");\n-        System.err.println(\"                                  parallel=<N> use N threads for parallel heap iteration\");\n","filename":"src\/jdk.jcmd\/share\/classes\/sun\/tools\/jmap\/JMap.java","additions":2,"deletions":22,"binary":false,"changes":24,"status":"modified"}]}