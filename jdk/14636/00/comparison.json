{"files":[{"patch":"@@ -28,3 +28,2 @@\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteOrder;\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -34,1 +33,1 @@\n- * using {@linkplain ByteOrder#BIG_ENDIAN big endian order} (aka. \"network order\").\n+ * using {@linkplain java.nio.ByteOrder#BIG_ENDIAN big endian order} (aka. \"network order\").\n@@ -44,6 +43,7 @@\n-    private static final VarHandle SHORT = create(short[].class);\n-    private static final VarHandle CHAR = create(char[].class);\n-    private static final VarHandle INT = create(int[].class);\n-    private static final VarHandle FLOAT = create(float[].class);\n-    private static final VarHandle LONG = create(long[].class);\n-    private static final VarHandle DOUBLE = create(double[].class);\n+    static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+\n+    @ForceInline\n+    static long arrayOffset(byte[] array, int typeBytes, int offset) {\n+        return (long) Preconditions.checkIndex(offset, array.length - typeBytes + 1, Preconditions.AIOOBE_FORMATTER)\n+                + Unsafe.ARRAY_BYTE_BASE_OFFSET;\n+    }\n@@ -65,0 +65,1 @@\n+    @ForceInline\n@@ -81,0 +82,1 @@\n+    @ForceInline\n@@ -82,1 +84,4 @@\n-        return (char) CHAR.get(array, offset);\n+        return UNSAFE.getCharUnaligned(\n+            array,\n+            arrayOffset(array, Character.BYTES, offset),\n+            true);\n@@ -98,0 +103,1 @@\n+    @ForceInline\n@@ -99,1 +105,4 @@\n-        return (short) SHORT.get(array, offset);\n+        return UNSAFE.getShortUnaligned(\n+            array,\n+            arrayOffset(array, Short.BYTES, offset),\n+            true);\n@@ -115,0 +124,1 @@\n+    @ForceInline\n@@ -116,1 +126,1 @@\n-        return Short.toUnsignedInt((short) SHORT.get(array, offset));\n+        return Short.toUnsignedInt(getShort(array, offset));\n@@ -131,0 +141,1 @@\n+    @ForceInline\n@@ -132,1 +143,4 @@\n-        return (int) INT.get(array, offset);\n+        return UNSAFE.getIntUnaligned(\n+            array,\n+            arrayOffset(array, Integer.BYTES, offset),\n+            true);\n@@ -136,1 +150,1 @@\n-     * {@return a {@code float} from the provided {@code array} at the given {@code offset}\n+     * {@return an {@code unsigned int} from the provided {@code array} at the given {@code offset}\n@@ -139,2 +153,0 @@\n-     * Variants of {@linkplain Float#NaN } values are canonized to a single NaN value.\n-     * <p>\n@@ -145,0 +157,1 @@\n+     * @return an {@code long} representing an unsigned int from the array\n@@ -147,1 +160,1 @@\n-     * @see #setFloat(byte[], int, float)\n+     * @see #setUnsignedInt(byte[], int, long)\n@@ -149,4 +162,3 @@\n-    public static float getFloat(byte[] array, int offset) {\n-        \/\/ Using Float.intBitsToFloat collapses NaN values to a single\n-        \/\/ \"canonical\" NaN value\n-        return Float.intBitsToFloat((int) INT.get(array, offset));\n+    @ForceInline\n+    public static long getUnsignedInt(byte[] array, int offset) {\n+        return Integer.toUnsignedLong(getInt(array, offset));\n@@ -159,2 +171,1 @@\n-     * Variants of {@linkplain Float#NaN } values are silently read according\n-     * to their bit patterns.\n+     * Variants of {@linkplain Float#NaN } values are canonized to a single NaN value.\n@@ -168,1 +179,1 @@\n-     * @see #setFloatRaw(byte[], int, float)\n+     * @see #setFloat(byte[], int, float)\n@@ -170,3 +181,5 @@\n-    public static float getFloatRaw(byte[] array, int offset) {\n-        \/\/ Just gets the bits as they are\n-        return (float) FLOAT.get(array, offset);\n+    @ForceInline\n+    public static float getFloat(byte[] array, int offset) {\n+        \/\/ Using Float.intBitsToFloat collapses NaN values to a single\n+        \/\/ \"canonical\" NaN value\n+        return Float.intBitsToFloat(getInt(array, offset));\n@@ -187,0 +200,1 @@\n+    @ForceInline\n@@ -188,1 +202,4 @@\n-        return (long) LONG.get(array, offset);\n+        return UNSAFE.getLongUnaligned(\n+            array,\n+            arrayOffset(array, Long.BYTES, offset),\n+            true);\n@@ -205,0 +222,1 @@\n+    @ForceInline\n@@ -208,21 +226,1 @@\n-        return Double.longBitsToDouble((long) LONG.get(array, offset));\n-    }\n-\n-    \/**\n-     * {@return a {@code double} from the provided {@code array} at the given {@code offset}\n-     * using big endian order}.\n-     * <p>\n-     * Variants of {@linkplain Double#NaN } values are silently read according to\n-     * their bit patterns.\n-     * <p>\n-     * There are no access alignment requirements.\n-     *\n-     * @param array  to get a value from.\n-     * @param offset where extraction in the array should begin\n-     * @throws IndexOutOfBoundsException if the provided {@code offset} is outside\n-     *                                   the range [0, array.length - 8]\n-     * @see #setDoubleRaw(byte[], int, double)\n-     *\/\n-    public static double getDoubleRaw(byte[] array, int offset) {\n-        \/\/ Just gets the bits as they are\n-        return (double) DOUBLE.get(array, offset);\n+        return Double.longBitsToDouble(getLong(array, offset));\n@@ -247,0 +245,1 @@\n+    @ForceInline\n@@ -264,0 +263,1 @@\n+    @ForceInline\n@@ -265,1 +265,5 @@\n-        CHAR.set(array, offset, value);\n+        UNSAFE.putCharUnaligned(\n+                array,\n+                arrayOffset(array, Character.BYTES, offset),\n+                value,\n+                true);\n@@ -281,0 +285,1 @@\n+    @ForceInline\n@@ -282,1 +287,5 @@\n-        SHORT.set(array, offset, value);\n+        UNSAFE.putShortUnaligned(\n+                array,\n+                arrayOffset(array, Short.BYTES, offset),\n+                value,\n+                true);\n@@ -298,0 +307,1 @@\n+    @ForceInline\n@@ -299,1 +309,1 @@\n-        SHORT.set(array, offset, (short) (char) value);\n+        setShort(array, offset, (short) (char) value);\n@@ -315,0 +325,1 @@\n+    @ForceInline\n@@ -316,1 +327,23 @@\n-        INT.set(array, offset, value);\n+        UNSAFE.putIntUnaligned(\n+                array,\n+                arrayOffset(array, Integer.BYTES, offset),\n+                value,\n+                true);\n+    }\n+\n+    \/**\n+     * Sets (writes) the provided {@code value} using big endian order into\n+     * the provided {@code array} beginning at the given {@code offset}.\n+     * <p>\n+     * There are no access alignment requirements.\n+     *\n+     * @param array  to set (write) a value into\n+     * @param offset where setting (writing) in the array should begin\n+     * @param value  value to set in the array\n+     * @throws IndexOutOfBoundsException if the provided {@code offset} is outside\n+     *                                   the range [0, array.length - 4]\n+     * @see #getUnsignedInt(byte[], int)\n+     *\/\n+    @ForceInline\n+    public static void setUnsignedInt(byte[] array, int offset, long value) {\n+        setInt(array, offset, (int) value);\n@@ -334,0 +367,1 @@\n+    @ForceInline\n@@ -337,1 +371,1 @@\n-        INT.set(array, offset, Float.floatToIntBits(value));\n+        setInt(array, offset, Float.floatToIntBits(value));\n@@ -354,1 +388,1 @@\n-     * @see #getFloatRaw(byte[], int)\n+     * @see #getFloat(byte[], int)\n@@ -356,0 +390,1 @@\n+    @ForceInline\n@@ -358,1 +393,1 @@\n-        FLOAT.set(array, offset, value);\n+        setInt(array, offset, Float.floatToRawIntBits(value));\n@@ -374,0 +409,1 @@\n+    @ForceInline\n@@ -375,1 +411,5 @@\n-        LONG.set(array, offset, value);\n+        UNSAFE.putLongUnaligned(\n+                array,\n+                arrayOffset(array, Long.BYTES, offset),\n+                value,\n+                true);\n@@ -393,0 +433,1 @@\n+    @ForceInline\n@@ -396,1 +437,1 @@\n-        LONG.set(array, offset, Double.doubleToLongBits(value));\n+        setLong(array, offset, Double.doubleToLongBits(value));\n@@ -413,1 +454,1 @@\n-     * @see #getDoubleRaw(byte[], int)\n+     * @see #getDouble(byte[], int)\n@@ -415,0 +456,1 @@\n+    @ForceInline\n@@ -417,5 +459,1 @@\n-        DOUBLE.set(array, offset, value);\n-    }\n-\n-    private static VarHandle create(Class<?> viewArrayClass) {\n-        return MethodHandles.byteArrayViewVarHandle(viewArrayClass, ByteOrder.BIG_ENDIAN);\n+        setLong(array, offset, Double.doubleToRawLongBits(value));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/ByteArray.java","additions":103,"deletions":65,"binary":false,"changes":168,"status":"modified"},{"patch":"@@ -28,3 +28,5 @@\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteOrder;\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.vm.annotation.ForceInline;\n+\n+import static jdk.internal.util.ByteArray.arrayOffset;\n+import static jdk.internal.util.ByteArray.UNSAFE;\n@@ -34,1 +36,1 @@\n- * using {@linkplain ByteOrder#LITTLE_ENDIAN little endian order}.\n+ * using {@linkplain java.nio.ByteOrder#LITTLE_ENDIAN little endian order}.\n@@ -44,7 +46,0 @@\n-    private static final VarHandle SHORT = createLittleEndian(short[].class);\n-    private static final VarHandle CHAR = createLittleEndian(char[].class);\n-    private static final VarHandle INT = createLittleEndian(int[].class);\n-    private static final VarHandle FLOAT = createLittleEndian(float[].class);\n-    private static final VarHandle LONG = createLittleEndian(long[].class);\n-    private static final VarHandle DOUBLE = createLittleEndian(double[].class);\n-\n@@ -65,0 +60,1 @@\n+    @ForceInline\n@@ -81,0 +77,1 @@\n+    @ForceInline\n@@ -82,1 +79,4 @@\n-        return (char) CHAR.get(array, offset);\n+        return UNSAFE.getCharUnaligned(\n+            array,\n+            arrayOffset(array, Character.BYTES, offset),\n+            false);\n@@ -98,0 +98,1 @@\n+    @ForceInline\n@@ -99,1 +100,4 @@\n-        return (short) SHORT.get(array, offset);\n+        return UNSAFE.getShortUnaligned(\n+            array,\n+            arrayOffset(array, Short.BYTES, offset),\n+            false);\n@@ -115,0 +119,1 @@\n+    @ForceInline\n@@ -116,1 +121,1 @@\n-        return Short.toUnsignedInt((short) SHORT.get(array, offset));\n+        return Short.toUnsignedInt(getShort(array, offset));\n@@ -131,0 +136,1 @@\n+    @ForceInline\n@@ -132,1 +138,4 @@\n-        return (int) INT.get(array, offset);\n+        return UNSAFE.getIntUnaligned(\n+            array,\n+            arrayOffset(array, Integer.BYTES, offset),\n+            false);\n@@ -135,5 +144,3 @@\n-    \/**\n-     * {@return a {@code float} from the provided {@code array} at the given {@code offset}\n-     * using little endian order}.\n-     * <p>\n-     * Variants of {@linkplain Float#NaN } values are canonized to a single NaN value.\n+   \/**\n+     * {@return an {@code unsigned int} from the provided {@code array} at the given {@code offset}\n+     * using big endian order}.\n@@ -145,0 +152,1 @@\n+     * @return an {@code long} representing an unsigned int from the array\n@@ -147,1 +155,1 @@\n-     * @see #setFloat(byte[], int, float)\n+     * @see #setUnsignedInt(byte[], int, long)\n@@ -149,4 +157,3 @@\n-    public static float getFloat(byte[] array, int offset) {\n-        \/\/ Using Float.intBitsToFloat collapses NaN values to a single\n-        \/\/ \"canonical\" NaN value\n-        return Float.intBitsToFloat((int) INT.get(array, offset));\n+    @ForceInline\n+    public static long getUnsignedInt(byte[] array, int offset) {\n+        return Integer.toUnsignedLong(getInt(array, offset));\n@@ -159,2 +166,1 @@\n-     * Variants of {@linkplain Float#NaN } values are silently read according\n-     * to their bit patterns.\n+     * Variants of {@linkplain Float#NaN } values are canonized to a single NaN value.\n@@ -168,1 +174,1 @@\n-     * @see #setFloatRaw(byte[], int, float)\n+     * @see #setFloat(byte[], int, float)\n@@ -170,3 +176,5 @@\n-    public static float getFloatRaw(byte[] array, int offset) {\n-        \/\/ Just gets the bits as they are\n-        return (float) FLOAT.get(array, offset);\n+    @ForceInline\n+    public static float getFloat(byte[] array, int offset) {\n+        \/\/ Using Float.intBitsToFloat collapses NaN values to a single\n+        \/\/ \"canonical\" NaN value\n+        return Float.intBitsToFloat(getInt(array, offset));\n@@ -187,0 +195,1 @@\n+    @ForceInline\n@@ -188,1 +197,4 @@\n-        return (long) LONG.get(array, offset);\n+        return UNSAFE.getLongUnaligned(\n+            array,\n+            arrayOffset(array, Long.BYTES, offset),\n+            false);\n@@ -205,0 +217,1 @@\n+    @ForceInline\n@@ -208,21 +221,1 @@\n-        return Double.longBitsToDouble((long) LONG.get(array, offset));\n-    }\n-\n-    \/**\n-     * {@return a {@code double} from the provided {@code array} at the given {@code offset}\n-     * using little endian order}.\n-     * <p>\n-     * Variants of {@linkplain Double#NaN } values are silently read according to\n-     * their bit patterns.\n-     * <p>\n-     * There are no access alignment requirements.\n-     *\n-     * @param array  to get a value from.\n-     * @param offset where extraction in the array should begin\n-     * @throws IndexOutOfBoundsException if the provided {@code offset} is outside\n-     *                                   the range [0, array.length - 8]\n-     * @see #setDoubleRaw(byte[], int, double)\n-     *\/\n-    public static double getDoubleRaw(byte[] array, int offset) {\n-        \/\/ Just gets the bits as they are\n-        return (double) DOUBLE.get(array, offset);\n+        return Double.longBitsToDouble(getLong(array, offset));\n@@ -247,0 +240,1 @@\n+    @ForceInline\n@@ -264,0 +258,1 @@\n+    @ForceInline\n@@ -265,1 +260,5 @@\n-        CHAR.set(array, offset, value);\n+        UNSAFE.putCharUnaligned(\n+                array,\n+                arrayOffset(array, Character.BYTES, offset),\n+                value,\n+                false);\n@@ -281,0 +280,1 @@\n+    @ForceInline\n@@ -282,1 +282,5 @@\n-        SHORT.set(array, offset, value);\n+        UNSAFE.putShortUnaligned(\n+                array,\n+                arrayOffset(array, Short.BYTES, offset),\n+                value,\n+                false);\n@@ -298,0 +302,1 @@\n+    @ForceInline\n@@ -299,1 +304,1 @@\n-        SHORT.set(array, offset, (short) (char) value);\n+        setShort(array, offset, (short) (char) value);\n@@ -315,0 +320,1 @@\n+    @ForceInline\n@@ -316,1 +322,23 @@\n-        INT.set(array, offset, value);\n+        UNSAFE.putIntUnaligned(\n+                array,\n+                arrayOffset(array, Integer.BYTES, offset),\n+                value,\n+                false);\n+    }\n+\n+   \/**\n+     * Sets (writes) the provided {@code value} using big endian order into\n+     * the provided {@code array} beginning at the given {@code offset}.\n+     * <p>\n+     * There are no access alignment requirements.\n+     *\n+     * @param array  to set (write) a value into\n+     * @param offset where setting (writing) in the array should begin\n+     * @param value  value to set in the array\n+     * @throws IndexOutOfBoundsException if the provided {@code offset} is outside\n+     *                                   the range [0, array.length - 4]\n+     * @see #getUnsignedInt(byte[], int)\n+     *\/\n+    @ForceInline\n+    public static void setUnsignedInt(byte[] array, int offset, long value) {\n+        setInt(array, offset, (int) value);\n@@ -334,0 +362,1 @@\n+    @ForceInline\n@@ -337,1 +366,1 @@\n-        INT.set(array, offset, Float.floatToIntBits(value));\n+        setInt(array, offset, Float.floatToIntBits(value));\n@@ -354,1 +383,1 @@\n-     * @see #getFloatRaw(byte[], int)\n+     * @see #getFloat(byte[], int)\n@@ -356,0 +385,1 @@\n+    @ForceInline\n@@ -358,1 +388,1 @@\n-        FLOAT.set(array, offset, value);\n+        setInt(array, offset, Float.floatToRawIntBits(value));\n@@ -374,0 +404,1 @@\n+    @ForceInline\n@@ -375,1 +406,5 @@\n-        LONG.set(array, offset, value);\n+        UNSAFE.putLongUnaligned(\n+                array,\n+                arrayOffset(array, Long.BYTES, offset),\n+                value,\n+                false);\n@@ -393,0 +428,1 @@\n+    @ForceInline\n@@ -396,1 +432,1 @@\n-        LONG.set(array, offset, Double.doubleToLongBits(value));\n+        setLong(array, offset, Double.doubleToLongBits(value));\n@@ -413,1 +449,1 @@\n-     * @see #getDoubleRaw(byte[], int)\n+     * @see #getDouble(byte[], int)\n@@ -415,0 +451,1 @@\n+    @ForceInline\n@@ -417,5 +454,1 @@\n-        DOUBLE.set(array, offset, value);\n-    }\n-\n-    private static VarHandle createLittleEndian(Class<?> viewArrayClass) {\n-        return MethodHandles.byteArrayViewVarHandle(viewArrayClass, ByteOrder.LITTLE_ENDIAN);\n+        setLong(array, offset, Double.doubleToRawLongBits(value));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/ByteArrayLittleEndian.java","additions":101,"deletions":68,"binary":false,"changes":169,"status":"modified"}]}