{"files":[{"patch":"@@ -58,0 +58,3 @@\n+\n+  \/\/ Prime space\n+  _end += expand_space();\n@@ -64,0 +67,59 @@\n+size_t ZMarkStackSpace::size() const {\n+  return _end - _start;\n+}\n+\n+static bool is_high_usage(size_t size) {\n+  \/\/ Consider usage to be high if we've used more than a 8th of the available space.\n+  \/\/ The available space (controlled by ZMarkStackSpaceLimit) is by default 8G, so\n+  \/\/ the high usage threshold will by default be 1G. The vast majority of workloads\n+  \/\/ will use a few hundred megabytes of space at most, so hitting the high usage\n+  \/\/ limit should be a rare event. At the same time, workloads that do see excessive\n+  \/\/ mark stack usage will typically see continuous mark stack space growth until\n+  \/\/ the high usage limit it hit, so setting the high usage limit too high will in\n+  \/\/ those situations just waste memory.\n+  return size > (ZMarkStackSpaceLimit \/ 8);\n+}\n+\n+size_t ZMarkStackSpace::expand_space() {\n+  const size_t expand_size = ZMarkStackSpaceExpandSize;\n+  const size_t old_size = size();\n+  const size_t new_size = old_size + expand_size;\n+\n+  if (new_size > ZMarkStackSpaceLimit) {\n+    \/\/ Expansion limit reached. This is a fatal error since we\n+    \/\/ currently can't recover from running out of mark stack space.\n+    fatal(\"Mark stack space exhausted. Use -XX:ZMarkStackSpaceLimit=<size> to increase the \"\n+          \"maximum number of bytes allocated for mark stacks. Current limit is \" SIZE_FORMAT \"M.\",\n+          ZMarkStackSpaceLimit \/ M);\n+  }\n+\n+  if (!_high_usage && is_high_usage(new_size)) {\n+    Atomic::store(&_high_usage, true);\n+  }\n+\n+  log_debug(gc, marking)(\"Expanding mark stack space: \" SIZE_FORMAT \"M->\" SIZE_FORMAT \"M (%s Usage)\",\n+                         old_size \/ M, new_size \/ M, _high_usage ? \"High\" : \"Low\");\n+\n+  \/\/ Expand\n+  os::commit_memory_or_exit((char*)_end, expand_size, false \/* executable *\/, \"Mark stack space\");\n+\n+  return expand_size;\n+}\n+\n+size_t ZMarkStackSpace::shrink_space() {\n+  const size_t old_size = size();\n+  const size_t new_size = ZMarkStackSpaceExpandSize;\n+  const size_t shrink_size = old_size - new_size;\n+\n+  if (shrink_size > 0) {\n+    \/\/ Shrink\n+    log_debug(gc, marking)(\"Shrinking mark stack space: \" SIZE_FORMAT \"M->\" SIZE_FORMAT \"M\",\n+                           old_size \/ M, new_size \/ M);\n+\n+    const uintptr_t shrink_start = _end - shrink_size;\n+    os::uncommit_memory((char*)shrink_start, shrink_size, false \/* executable *\/);\n+  }\n+\n+  return shrink_size;\n+}\n+\n@@ -95,20 +157,0 @@\n-  \/\/ Check expansion limit\n-  const size_t expand_size = ZMarkStackSpaceExpandSize;\n-  const size_t old_size = _end - _start;\n-  const size_t new_size = old_size + expand_size;\n-  if (new_size > ZMarkStackSpaceLimit) {\n-    \/\/ Expansion limit reached. This is a fatal error since we\n-    \/\/ currently can't recover from running out of mark stack space.\n-    fatal(\"Mark stack space exhausted. Use -XX:ZMarkStackSpaceLimit=<size> to increase the \"\n-          \"maximum number of bytes allocated for mark stacks. Current limit is \" SIZE_FORMAT \"M.\",\n-          ZMarkStackSpaceLimit \/ M);\n-  }\n-\n-  \/\/ Set high usage flag if we've used more than a 8th of the available space\n-  if (!_high_usage && new_size > ZMarkStackSpaceLimit \/ 8) {\n-    Atomic::store(&_high_usage, true);\n-  }\n-\n-  log_debug(gc, marking)(\"Expanding mark stack space: \" SIZE_FORMAT \"M->\" SIZE_FORMAT \"M (%s Usage)\",\n-                         old_size \/ M, new_size \/ M, _high_usage ? \"High\" : \"Low\");\n-\n@@ -116,1 +158,1 @@\n-  os::commit_memory_or_exit((char*)_end, expand_size, false \/* executable *\/, \"Mark stack space\");\n+  const size_t expand_size = expand_space();\n@@ -127,0 +169,2 @@\n+  assert(size <= ZMarkStackSpaceExpandSize, \"Invalid size\");\n+\n@@ -136,3 +180,3 @@\n-  os::uncommit_memory((char*)_start, _end - _start, false \/* executable *\/);\n-  _end = _top = _start;\n-  _high_usage = false;\n+  _top = _start;\n+  _end -= shrink_space();\n+  _high_usage = is_high_usage(size());\n","filename":"src\/hotspot\/share\/gc\/z\/zMarkStackAllocator.cpp","additions":68,"deletions":24,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,4 @@\n-  void expand();\n+  size_t size() const;\n+\n+  size_t expand_space();\n+  size_t shrink_space();\n","filename":"src\/hotspot\/share\/gc\/z\/zMarkStackAllocator.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"}]}