{"files":[{"patch":"@@ -772,0 +772,1 @@\n+  \/\/ Free any unused mark stack space\n@@ -773,0 +774,3 @@\n+\n+  \/\/ Update statistics\n+  ZStatMark::set_at_mark_free(_allocator.size());\n","filename":"src\/hotspot\/share\/gc\/z\/zMark.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -67,1 +67,0 @@\n-  template <bool gc_thread> bool should_mark_before_push() const;\n","filename":"src\/hotspot\/share\/gc\/z\/zMark.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"gc\/z\/zMarkStackAllocator.inline.hpp\"\n@@ -37,8 +36,3 @@\n-\/\/ Marking before pushing defeats the purpose of striped marking, but it\n-\/\/ can also help reduce mark stack usage. We mark before pushing, only if\n-\/\/ the mark stack usage is high, or if we're using a single stripe (in\n-\/\/ which case striped marking is essesntially disabled).\n-\/\/\n-\/\/ Furthermore, we only consider doing mark before pushing in GC threads\n-\/\/ to avoid burdening Java threads with writing to, and potentially first\n-\/\/ having to clear, mark bitmaps.\n+\/\/ Marking before pushing helps reduce mark stack memory usage. However,\n+\/\/ we only mark before pushing in GC threads to avoid burdening Java threads\n+\/\/ with writing to, and potentially first having to clear, mark bitmaps.\n@@ -51,5 +45,0 @@\n-template <bool gc_thread>\n-inline bool ZMark::should_mark_before_push() const {\n-  return gc_thread && (_allocator.high_usage() || _stripes.nstripes() == 1);\n-}\n-\n@@ -66,1 +55,1 @@\n-  const bool mark_before_push = should_mark_before_push<gc_thread>();\n+  const bool mark_before_push = gc_thread;\n","filename":"src\/hotspot\/share\/gc\/z\/zMark.inline.hpp","additions":4,"deletions":15,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -41,2 +41,1 @@\n-    _end(0),\n-    _high_usage(false) {\n+    _end(0) {\n@@ -71,10 +70,2 @@\n-static bool is_high_usage(size_t size) {\n-  \/\/ Consider usage to be high if we've used more than one 8th of the available space.\n-  \/\/ The available space (controlled by ZMarkStackSpaceLimit) is by default 8G, so\n-  \/\/ the high usage threshold will by default be 1G. The vast majority of workloads\n-  \/\/ will use a few hundred megabytes of space at most, so hitting the high usage\n-  \/\/ limit should be a rare event. At the same time, workloads that do see excessive\n-  \/\/ mark stack usage will typically see continuous mark stack space growth until\n-  \/\/ the high usage limit it hit, so setting the high usage limit too high will in\n-  \/\/ those situations just waste memory.\n-  return size > (ZMarkStackSpaceLimit \/ 8);\n+size_t ZMarkStackSpace::used() const {\n+  return _top - _start;\n@@ -96,6 +87,2 @@\n-  if (!_high_usage && is_high_usage(new_size)) {\n-    Atomic::store(&_high_usage, true);\n-  }\n-\n-  log_debug(gc, marking)(\"Expanding mark stack space: \" SIZE_FORMAT \"M->\" SIZE_FORMAT \"M (%s Usage)\",\n-                         old_size \/ M, new_size \/ M, _high_usage ? \"High\" : \"Normal\");\n+  log_debug(gc, marking)(\"Expanding mark stack space: \" SIZE_FORMAT \"M->\" SIZE_FORMAT \"M\",\n+                         old_size \/ M, new_size \/ M);\n@@ -110,0 +97,1 @@\n+  \/\/ Shrink to what is currently used\n@@ -111,1 +99,1 @@\n-  const size_t new_size = ZMarkStackSpaceExpandSize;\n+  const size_t new_size = align_up(used(), ZMarkStackSpaceExpandSize);\n@@ -180,1 +168,0 @@\n-  _top = _start;\n@@ -182,1 +169,1 @@\n-  _high_usage = is_high_usage(size());\n+  _top = _start;\n@@ -193,0 +180,4 @@\n+size_t ZMarkStackAllocator::size() const {\n+  return _space.size();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zMarkStackAllocator.cpp","additions":12,"deletions":21,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-  volatile bool      _high_usage;\n@@ -39,1 +38,1 @@\n-  size_t size() const;\n+  size_t used() const;\n@@ -52,1 +51,1 @@\n-  bool high_usage() const;\n+  size_t size() const;\n@@ -70,1 +69,1 @@\n-  bool high_usage() const;\n+  size_t size() const;\n","filename":"src\/hotspot\/share\/gc\/z\/zMarkStackAllocator.hpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1,38 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#ifndef SHARE_GC_Z_ZMARKSTACKALLOCATOR_INLINE_HPP\n-#define SHARE_GC_Z_ZMARKSTACKALLOCATOR_INLINE_HPP\n-\n-#include \"gc\/z\/zMarkStackAllocator.hpp\"\n-#include \"runtime\/atomic.hpp\"\n-\n-inline bool ZMarkStackSpace::high_usage() const {\n-  return Atomic::load(&_high_usage);\n-}\n-\n-inline bool ZMarkStackAllocator::high_usage() const {\n-  return _space.high_usage();\n-}\n-\n-#endif \/\/ SHARE_GC_Z_ZMARKSTACKALLOCATOR_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/z\/zMarkStackAllocator.inline.hpp","additions":0,"deletions":38,"binary":false,"changes":38,"status":"deleted"},{"patch":"@@ -1128,0 +1128,1 @@\n+size_t ZStatMark::_mark_stack_usage;\n@@ -1143,0 +1144,4 @@\n+void ZStatMark::set_at_mark_free(size_t mark_stack_usage) {\n+  _mark_stack_usage = mark_stack_usage;\n+}\n+\n@@ -1155,0 +1160,2 @@\n+\n+  log_info(gc, marking)(\"Mark Stack Usage: \" SIZE_FORMAT \"M\", _mark_stack_usage \/ M);\n","filename":"src\/hotspot\/share\/gc\/z\/zStat.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -410,0 +410,1 @@\n+  static size_t _mark_stack_usage;\n@@ -417,0 +418,1 @@\n+  static void set_at_mark_free(size_t mark_stack_usage);\n","filename":"src\/hotspot\/share\/gc\/z\/zStat.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}