{"files":[{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/z\/zThread.inline.hpp\"\n@@ -67,1 +68,1 @@\n-template <bool follow, bool finalizable, bool publish>\n+template <bool gc_thread, bool follow, bool finalizable, bool publish>\n@@ -84,1 +85,1 @@\n-    ZHeap::heap()->mark_object<follow, finalizable, publish>(good_addr);\n+    ZHeap::heap()->mark_object<gc_thread, follow, finalizable, publish>(good_addr);\n@@ -114,1 +115,1 @@\n-  return during_relocate() ? relocate(addr) : mark<Follow, Strong, Publish>(addr);\n+  return during_relocate() ? relocate(addr) : mark<AnyThread, Follow, Strong, Publish>(addr);\n@@ -118,1 +119,1 @@\n-  return during_relocate() ? relocate(addr) : mark<DontFollow, Strong, Publish>(addr);\n+  return during_relocate() ? relocate(addr) : mark<AnyThread, DontFollow, Strong, Publish>(addr);\n@@ -172,0 +173,7 @@\n+uintptr_t ZBarrier::keep_alive_barrier_on_oop_slow_path(uintptr_t addr) {\n+  assert(during_mark(), \"Invalid phase\");\n+\n+  \/\/ Mark\n+  return mark<AnyThread, Follow, Strong, Overflow>(addr);\n+}\n+\n@@ -189,0 +197,1 @@\n+  assert(ZThread::is_worker(), \"Invalid thread\");\n@@ -191,1 +200,1 @@\n-  return mark<Follow, Strong, Overflow>(addr);\n+  return mark<GCThread, Follow, Strong, Overflow>(addr);\n@@ -196,0 +205,1 @@\n+  assert(ZThread::is_worker(), \"Invalid thread\");\n@@ -198,1 +208,1 @@\n-  return mark<Follow, Finalizable, Overflow>(addr);\n+  return mark<GCThread, Follow, Finalizable, Overflow>(addr);\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrier.cpp","additions":16,"deletions":6,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -36,0 +36,3 @@\n+  static const bool GCThread    = true;\n+  static const bool AnyThread   = false;\n+\n@@ -58,1 +61,1 @@\n-  template <bool follow, bool finalizable, bool publish> static uintptr_t mark(uintptr_t addr);\n+  template <bool gc_thread, bool follow, bool finalizable, bool publish> static uintptr_t mark(uintptr_t addr);\n@@ -72,0 +75,1 @@\n+  static uintptr_t keep_alive_barrier_on_oop_slow_path(uintptr_t addr);\n@@ -107,0 +111,1 @@\n+  static void keep_alive_barrier_on_oop(oop o);\n@@ -110,1 +115,0 @@\n-  static void keep_alive_barrier_on_oop(oop o);\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrier.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -367,1 +367,1 @@\n-    mark_barrier_on_oop_slow_path(addr);\n+    keep_alive_barrier_on_oop_slow_path(addr);\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrier.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+static const ZStatPhaseConcurrent ZPhaseConcurrentMarkFree(\"Concurrent Mark Free\");\n@@ -325,0 +326,5 @@\n+void ZDriver::concurrent_mark_free() {\n+  ZStatTimer timer(ZPhaseConcurrentMarkFree);\n+  ZHeap::heap()->mark_free();\n+}\n+\n@@ -429,1 +435,4 @@\n-  \/\/ Phase 4: Concurrent Process Non-Strong References\n+  \/\/ Phase 4: Concurrent Mark Free\n+  concurrent(mark_free);\n+\n+  \/\/ Phase 5: Concurrent Process Non-Strong References\n@@ -432,1 +441,1 @@\n-  \/\/ Phase 5: Concurrent Reset Relocation Set\n+  \/\/ Phase 6: Concurrent Reset Relocation Set\n@@ -435,1 +444,1 @@\n-  \/\/ Phase 6: Pause Verify\n+  \/\/ Phase 7: Pause Verify\n@@ -438,1 +447,1 @@\n-  \/\/ Phase 7: Concurrent Select Relocation Set\n+  \/\/ Phase 8: Concurrent Select Relocation Set\n@@ -441,1 +450,1 @@\n-  \/\/ Phase 8: Pause Relocate Start\n+  \/\/ Phase 9: Pause Relocate Start\n@@ -444,1 +453,1 @@\n-  \/\/ Phase 9: Concurrent Relocate\n+  \/\/ Phase 10: Concurrent Relocate\n","filename":"src\/hotspot\/share\/gc\/z\/zDriver.cpp","additions":15,"deletions":6,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+  void concurrent_mark_free();\n","filename":"src\/hotspot\/share\/gc\/z\/zDriver.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -287,0 +287,4 @@\n+void ZHeap::mark_free() {\n+  _mark.free();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zHeap.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -125,1 +125,1 @@\n-  template <bool follow, bool finalizable, bool publish> void mark_object(uintptr_t addr);\n+  template <bool gc_thread, bool follow, bool finalizable, bool publish> void mark_object(uintptr_t addr);\n@@ -130,0 +130,1 @@\n+  void mark_free();\n","filename":"src\/hotspot\/share\/gc\/z\/zHeap.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-template <bool follow, bool finalizable, bool publish>\n+template <bool gc_thread, bool follow, bool finalizable, bool publish>\n@@ -63,1 +63,1 @@\n-  _mark.mark_object<follow, finalizable, publish>(addr);\n+  _mark.mark_object<gc_thread, follow, finalizable, publish>(addr);\n","filename":"src\/hotspot\/share\/gc\/z\/zHeap.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -281,22 +281,0 @@\n-bool ZMark::try_mark_object(ZMarkCache* cache, uintptr_t addr, bool finalizable) {\n-  ZPage* const page = _page_table->get(addr);\n-  if (page->is_allocating()) {\n-    \/\/ Newly allocated objects are implicitly marked\n-    return false;\n-  }\n-\n-  \/\/ Try mark object\n-  bool inc_live = false;\n-  const bool success = page->mark_object(addr, finalizable, inc_live);\n-  if (inc_live) {\n-    \/\/ Update live objects\/bytes for page. We use the aligned object\n-    \/\/ size since that is the actual number of bytes used on the page\n-    \/\/ and alignment paddings can never be reclaimed.\n-    const size_t size = ZUtils::object_size(addr);\n-    const size_t aligned_size = align_up(size, page->object_alignment());\n-    cache->inc_live(page, aligned_size);\n-  }\n-\n-  return success;\n-}\n-\n@@ -313,1 +291,1 @@\n-  \/\/ Decode object address and follow flag\n+  \/\/ Decode object address and additional flags\n@@ -315,0 +293,3 @@\n+  const bool mark = entry.mark();\n+  bool inc_live = entry.inc_live();\n+  const bool follow = entry.follow();\n@@ -316,1 +297,5 @@\n-  if (!try_mark_object(cache, addr, finalizable)) {\n+  ZPage* const page = _page_table->get(addr);\n+  assert(page->is_relocatable(), \"Invalid page state\");\n+\n+  \/\/ Mark\n+  if (mark && !page->mark_object(addr, finalizable, inc_live)) {\n@@ -321,3 +306,9 @@\n-  if (is_array(addr)) {\n-    \/\/ Decode follow flag\n-    const bool follow = entry.follow();\n+  \/\/ Increment live\n+  if (inc_live) {\n+    \/\/ Update live objects\/bytes for page. We use the aligned object\n+    \/\/ size since that is the actual number of bytes used on the page\n+    \/\/ and alignment paddings can never be reclaimed.\n+    const size_t size = ZUtils::object_size(addr);\n+    const size_t aligned_size = align_up(size, page->object_alignment());\n+    cache->inc_live(page, aligned_size);\n+  }\n@@ -325,2 +316,3 @@\n-    \/\/ The follow flag is currently only relevant for object arrays\n-    if (follow) {\n+  \/\/ Follow\n+  if (follow) {\n+    if (is_array(addr)) {\n@@ -328,0 +320,2 @@\n+    } else {\n+      follow_object(ZOop::from_address(addr), finalizable);\n@@ -329,2 +323,0 @@\n-  } else {\n-    follow_object(ZOop::from_address(addr), finalizable);\n@@ -779,0 +771,8 @@\n+void ZMark::free() {\n+  \/\/ Free any unused mark stack space\n+  _allocator.free();\n+\n+  \/\/ Update statistics\n+  ZStatMark::set_at_mark_free(_allocator.size());\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zMark.cpp","additions":31,"deletions":31,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,1 +67,0 @@\n-  bool try_mark_object(ZMarkCache* cache, uintptr_t addr, bool finalizable);\n@@ -104,1 +103,1 @@\n-  template <bool follow, bool finalizable, bool publish> void mark_object(uintptr_t addr);\n+  template <bool gc_thread, bool follow, bool finalizable, bool publish> void mark_object(uintptr_t addr);\n@@ -109,0 +108,1 @@\n+  void free();\n","filename":"src\/hotspot\/share\/gc\/z\/zMark.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,2 @@\n+#include \"gc\/z\/zPage.inline.hpp\"\n+#include \"gc\/z\/zPageTable.inline.hpp\"\n@@ -34,1 +36,10 @@\n-template <bool follow, bool finalizable, bool publish>\n+\/\/ Marking before pushing helps reduce mark stack memory usage. However,\n+\/\/ we only mark before pushing in GC threads to avoid burdening Java threads\n+\/\/ with writing to, and potentially first having to clear, mark bitmaps.\n+\/\/\n+\/\/ It's also worth noting that while marking an object can be done at any\n+\/\/ time in the marking phase, following an object can only be done after\n+\/\/ root processing has called ClassLoaderDataGraph::clear_claimed_marks(),\n+\/\/ since it otherwise would interact badly with claiming of CLDs.\n+\n+template <bool gc_thread, bool follow, bool finalizable, bool publish>\n@@ -37,0 +48,25 @@\n+\n+  ZPage* const page = _page_table->get(addr);\n+  if (page->is_allocating()) {\n+    \/\/ Already implicitly marked\n+    return;\n+  }\n+\n+  const bool mark_before_push = gc_thread;\n+  bool inc_live = false;\n+\n+  if (mark_before_push) {\n+    \/\/ Try mark object\n+    if (!page->mark_object(addr, finalizable, inc_live)) {\n+      \/\/ Already marked\n+      return;\n+    }\n+  } else {\n+    \/\/ Don't push if already marked\n+    if (page->is_object_marked<finalizable>(addr)) {\n+      \/\/ Already marked\n+      return;\n+    }\n+  }\n+\n+  \/\/ Push\n@@ -39,2 +75,1 @@\n-  ZMarkStackEntry entry(addr, follow, finalizable);\n-\n+  ZMarkStackEntry entry(addr, !mark_before_push, inc_live, follow, finalizable);\n","filename":"src\/hotspot\/share\/gc\/z\/zMark.inline.hpp","additions":39,"deletions":4,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -67,0 +67,2 @@\n+\n+  void clear();\n","filename":"src\/hotspot\/share\/gc\/z\/zMarkStack.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -159,0 +159,5 @@\n+template <typename T>\n+inline void ZStackList<T>::clear() {\n+  _head = encode_versioned_pointer(NULL, 0);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zMarkStack.inline.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -57,0 +57,3 @@\n+\n+  \/\/ Prime space\n+  _end += expand_space();\n@@ -63,0 +66,48 @@\n+size_t ZMarkStackSpace::size() const {\n+  return _end - _start;\n+}\n+\n+size_t ZMarkStackSpace::used() const {\n+  return _top - _start;\n+}\n+\n+size_t ZMarkStackSpace::expand_space() {\n+  const size_t expand_size = ZMarkStackSpaceExpandSize;\n+  const size_t old_size = size();\n+  const size_t new_size = old_size + expand_size;\n+\n+  if (new_size > ZMarkStackSpaceLimit) {\n+    \/\/ Expansion limit reached. This is a fatal error since we\n+    \/\/ currently can't recover from running out of mark stack space.\n+    fatal(\"Mark stack space exhausted. Use -XX:ZMarkStackSpaceLimit=<size> to increase the \"\n+          \"maximum number of bytes allocated for mark stacks. Current limit is \" SIZE_FORMAT \"M.\",\n+          ZMarkStackSpaceLimit \/ M);\n+  }\n+\n+  log_debug(gc, marking)(\"Expanding mark stack space: \" SIZE_FORMAT \"M->\" SIZE_FORMAT \"M\",\n+                         old_size \/ M, new_size \/ M);\n+\n+  \/\/ Expand\n+  os::commit_memory_or_exit((char*)_end, expand_size, false \/* executable *\/, \"Mark stack space\");\n+\n+  return expand_size;\n+}\n+\n+size_t ZMarkStackSpace::shrink_space() {\n+  \/\/ Shrink to what is currently used\n+  const size_t old_size = size();\n+  const size_t new_size = align_up(used(), ZMarkStackSpaceExpandSize);\n+  const size_t shrink_size = old_size - new_size;\n+\n+  if (shrink_size > 0) {\n+    \/\/ Shrink\n+    log_debug(gc, marking)(\"Shrinking mark stack space: \" SIZE_FORMAT \"M->\" SIZE_FORMAT \"M\",\n+                           old_size \/ M, new_size \/ M);\n+\n+    const uintptr_t shrink_start = _end - shrink_size;\n+    os::uncommit_memory((char*)shrink_start, shrink_size, false \/* executable *\/);\n+  }\n+\n+  return shrink_size;\n+}\n+\n@@ -94,15 +145,0 @@\n-  \/\/ Check expansion limit\n-  const size_t expand_size = ZMarkStackSpaceExpandSize;\n-  const size_t old_size = _end - _start;\n-  const size_t new_size = old_size + expand_size;\n-  if (new_size > ZMarkStackSpaceLimit) {\n-    \/\/ Expansion limit reached. This is a fatal error since we\n-    \/\/ currently can't recover from running out of mark stack space.\n-    fatal(\"Mark stack space exhausted. Use -XX:ZMarkStackSpaceLimit=<size> to increase the \"\n-          \"maximum number of bytes allocated for mark stacks. Current limit is \" SIZE_FORMAT \"M.\",\n-          ZMarkStackSpaceLimit \/ M);\n-  }\n-\n-  log_debug(gc, marking)(\"Expanding mark stack space: \" SIZE_FORMAT \"M->\" SIZE_FORMAT \"M\",\n-                         old_size \/ M, new_size \/ M);\n-\n@@ -110,1 +146,1 @@\n-  os::commit_memory_or_exit((char*)_end, expand_size, false \/* executable *\/, \"Mark stack space\");\n+  const size_t expand_size = expand_space();\n@@ -121,0 +157,2 @@\n+  assert(size <= ZMarkStackSpaceExpandSize, \"Invalid size\");\n+\n@@ -129,0 +167,5 @@\n+void ZMarkStackSpace::free() {\n+  _end -= shrink_space();\n+  _top = _start;\n+}\n+\n@@ -131,7 +174,1 @@\n-    _space() {\n-  \/\/ Prime free list to avoid an immediate space\n-  \/\/ expansion when marking starts.\n-  if (_space.is_initialized()) {\n-    prime_freelist();\n-  }\n-}\n+    _space() {}\n@@ -143,6 +180,2 @@\n-void ZMarkStackAllocator::prime_freelist() {\n-  for (size_t size = 0; size < ZMarkStackSpaceExpandSize; size += ZMarkStackMagazineSize) {\n-    const uintptr_t addr = _space.alloc(ZMarkStackMagazineSize);\n-    ZMarkStackMagazine* const magazine = create_magazine_from_space(addr, ZMarkStackMagazineSize);\n-    free_magazine(magazine);\n-  }\n+size_t ZMarkStackAllocator::size() const {\n+  return _space.size();\n@@ -184,0 +217,5 @@\n+\n+void ZMarkStackAllocator::free() {\n+  _freelist.clear();\n+  _space.free();\n+}\n","filename":"src\/hotspot\/share\/gc\/z\/zMarkStackAllocator.cpp","additions":67,"deletions":29,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,4 @@\n-  void expand();\n+  size_t used() const;\n+\n+  size_t expand_space();\n+  size_t shrink_space();\n@@ -48,0 +51,2 @@\n+  size_t size() const;\n+\n@@ -49,0 +54,1 @@\n+  void free();\n@@ -56,1 +62,0 @@\n-  void prime_freelist();\n@@ -64,0 +69,2 @@\n+  size_t size() const;\n+\n@@ -66,0 +73,2 @@\n+\n+  void free();\n","filename":"src\/hotspot\/share\/gc\/z\/zMarkStackAllocator.hpp","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,10 +38,14 @@\n-\/\/   3                                                                  3 2 1 0\n-\/\/  +--------------------------------------------------------------------+-+-+-+\n-\/\/  |11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111|1|1|1|\n-\/\/  +--------------------------------------------------------------------+-+-+-+\n-\/\/  |                                                                    | | |\n-\/\/  |                                            2-2 Follow Flag (1-bit) * | |\n-\/\/  |                                                                      | |\n-\/\/  |                                       1-1 Partial Array Flag (1-bit) * |\n-\/\/  |                                                                        |\n-\/\/  |                                                 0-0 Final Flag (1-bit) *\n+\/\/   3                                                                5 4 3 2 1 0\n+\/\/  +------------------------------------------------------------------+-+-+-+-+-+\n+\/\/  |11111111 11111111 11111111 11111111 11111111 11111111 11111111 111|1|1|1|1|1|\n+\/\/  +------------------------------------------------------------------+-+-+-+-+-+\n+\/\/  |                                                                  | | | | |\n+\/\/  |                                            4-4 Mark Flag (1-bit) * | | | |\n+\/\/  |                                                                    | | | |\n+\/\/  |                                    3-3 Increment Live Flag (1-bit) * | | |\n+\/\/  |                                                                      | | |\n+\/\/  |                                              2-2 Follow Flag (1-bit) * | |\n+\/\/  |                                                                        | |\n+\/\/  |                                         1-1 Partial Array Flag (1-bit) * |\n+\/\/  |                                                                          |\n+\/\/  |                                                   0-0 Final Flag (1-bit) *\n@@ -49,1 +53,1 @@\n-\/\/  * 63-3 Object Address (61-bits)\n+\/\/  * 63-5 Object Address (59-bits)\n@@ -75,1 +79,3 @@\n-  typedef ZBitField<uint64_t, uintptr_t, 3,  61> field_object_address;\n+  typedef ZBitField<uint64_t, bool,      3,  1>  field_inc_live;\n+  typedef ZBitField<uint64_t, bool,      4,  1>  field_mark;\n+  typedef ZBitField<uint64_t, uintptr_t, 5,  59> field_object_address;\n@@ -89,1 +95,1 @@\n-  ZMarkStackEntry(uintptr_t object_address, bool follow, bool finalizable) :\n+  ZMarkStackEntry(uintptr_t object_address, bool mark, bool inc_live, bool follow, bool finalizable) :\n@@ -91,0 +97,2 @@\n+             field_mark::encode(mark) |\n+             field_inc_live::encode(inc_live) |\n@@ -121,0 +129,8 @@\n+  bool inc_live() const {\n+    return field_inc_live::decode(_entry);\n+  }\n+\n+  bool mark() const {\n+    return field_mark::decode(_entry);\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zMarkStackEntry.hpp","additions":30,"deletions":14,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -95,0 +95,1 @@\n+  template <bool finalizable> bool is_object_marked(uintptr_t addr) const;\n","filename":"src\/hotspot\/share\/gc\/z\/zPage.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -174,0 +174,1 @@\n+  assert(is_relocatable(), \"Invalid page state\");\n@@ -179,0 +180,1 @@\n+  assert(is_relocatable(), \"Invalid page state\");\n@@ -183,0 +185,5 @@\n+template <bool finalizable>\n+inline bool ZPage::is_object_marked(uintptr_t addr) const {\n+  return finalizable ? is_object_marked(addr) : is_object_strongly_marked(addr);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zPage.inline.hpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1128,0 +1128,1 @@\n+size_t ZStatMark::_mark_stack_usage;\n@@ -1143,0 +1144,4 @@\n+void ZStatMark::set_at_mark_free(size_t mark_stack_usage) {\n+  _mark_stack_usage = mark_stack_usage;\n+}\n+\n@@ -1155,0 +1160,2 @@\n+\n+  log_info(gc, marking)(\"Mark Stack Usage: \" SIZE_FORMAT \"M\", _mark_stack_usage \/ M);\n","filename":"src\/hotspot\/share\/gc\/z\/zStat.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -410,0 +410,1 @@\n+  static size_t _mark_stack_usage;\n@@ -417,0 +418,1 @@\n+  static void set_at_mark_free(size_t mark_stack_usage);\n","filename":"src\/hotspot\/share\/gc\/z\/zStat.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}