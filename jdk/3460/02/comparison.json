{"files":[{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/z\/zThread.inline.hpp\"\n@@ -67,1 +68,1 @@\n-template <bool follow, bool finalizable, bool publish>\n+template <bool gc_thread, bool follow, bool finalizable, bool publish>\n@@ -84,1 +85,1 @@\n-    ZHeap::heap()->mark_object<follow, finalizable, publish>(good_addr);\n+    ZHeap::heap()->mark_object<gc_thread, follow, finalizable, publish>(good_addr);\n@@ -114,1 +115,1 @@\n-  return during_relocate() ? relocate(addr) : mark<Follow, Strong, Publish>(addr);\n+  return during_relocate() ? relocate(addr) : mark<AnyThread, Follow, Strong, Publish>(addr);\n@@ -118,1 +119,1 @@\n-  return during_relocate() ? relocate(addr) : mark<DontFollow, Strong, Publish>(addr);\n+  return during_relocate() ? relocate(addr) : mark<AnyThread, DontFollow, Strong, Publish>(addr);\n@@ -172,0 +173,7 @@\n+uintptr_t ZBarrier::keep_alive_barrier_on_oop_slow_path(uintptr_t addr) {\n+  assert(during_mark(), \"Invalid phase\");\n+\n+  \/\/ Mark\n+  return mark<AnyThread, Follow, Strong, Overflow>(addr);\n+}\n+\n@@ -189,0 +197,1 @@\n+  assert(ZThread::is_worker(), \"Invalid thread\");\n@@ -191,1 +200,1 @@\n-  return mark<Follow, Strong, Overflow>(addr);\n+  return mark<GCThread, Follow, Strong, Overflow>(addr);\n@@ -196,0 +205,1 @@\n+  assert(ZThread::is_worker(), \"Invalid thread\");\n@@ -198,1 +208,1 @@\n-  return mark<Follow, Finalizable, Overflow>(addr);\n+  return mark<GCThread, Follow, Finalizable, Overflow>(addr);\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrier.cpp","additions":16,"deletions":6,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -36,0 +36,3 @@\n+  static const bool GCThread    = true;\n+  static const bool AnyThread   = false;\n+\n@@ -58,1 +61,1 @@\n-  template <bool follow, bool finalizable, bool publish> static uintptr_t mark(uintptr_t addr);\n+  template <bool gc_thread, bool follow, bool finalizable, bool publish> static uintptr_t mark(uintptr_t addr);\n@@ -72,0 +75,1 @@\n+  static uintptr_t keep_alive_barrier_on_oop_slow_path(uintptr_t addr);\n@@ -107,0 +111,1 @@\n+  static void keep_alive_barrier_on_oop(oop o);\n@@ -110,1 +115,0 @@\n-  static void keep_alive_barrier_on_oop(oop o);\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrier.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -367,1 +367,1 @@\n-    mark_barrier_on_oop_slow_path(addr);\n+    keep_alive_barrier_on_oop_slow_path(addr);\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrier.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+static const ZStatPhaseConcurrent ZPhaseConcurrentMarkFree(\"Concurrent Mark Free\");\n@@ -325,0 +326,5 @@\n+void ZDriver::concurrent_mark_free() {\n+  ZStatTimer timer(ZPhaseConcurrentMarkFree);\n+  ZHeap::heap()->mark_free();\n+}\n+\n@@ -429,1 +435,4 @@\n-  \/\/ Phase 4: Concurrent Process Non-Strong References\n+  \/\/ Phase 4: Concurrent Mark Free\n+  concurrent(mark_free);\n+\n+  \/\/ Phase 5: Concurrent Process Non-Strong References\n@@ -432,1 +441,1 @@\n-  \/\/ Phase 5: Concurrent Reset Relocation Set\n+  \/\/ Phase 6: Concurrent Reset Relocation Set\n@@ -435,1 +444,1 @@\n-  \/\/ Phase 6: Pause Verify\n+  \/\/ Phase 7: Pause Verify\n@@ -438,1 +447,1 @@\n-  \/\/ Phase 7: Concurrent Select Relocation Set\n+  \/\/ Phase 8: Concurrent Select Relocation Set\n@@ -441,1 +450,1 @@\n-  \/\/ Phase 8: Pause Relocate Start\n+  \/\/ Phase 9: Pause Relocate Start\n@@ -444,1 +453,1 @@\n-  \/\/ Phase 9: Concurrent Relocate\n+  \/\/ Phase 10: Concurrent Relocate\n","filename":"src\/hotspot\/share\/gc\/z\/zDriver.cpp","additions":15,"deletions":6,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+  void concurrent_mark_free();\n","filename":"src\/hotspot\/share\/gc\/z\/zDriver.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -287,0 +287,4 @@\n+void ZHeap::mark_free() {\n+  _mark.free();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zHeap.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -125,1 +125,1 @@\n-  template <bool follow, bool finalizable, bool publish> void mark_object(uintptr_t addr);\n+  template <bool gc_thread, bool follow, bool finalizable, bool publish> void mark_object(uintptr_t addr);\n@@ -130,0 +130,1 @@\n+  void mark_free();\n","filename":"src\/hotspot\/share\/gc\/z\/zHeap.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-template <bool follow, bool finalizable, bool publish>\n+template <bool gc_thread, bool follow, bool finalizable, bool publish>\n@@ -63,1 +63,1 @@\n-  _mark.mark_object<follow, finalizable, publish>(addr);\n+  _mark.mark_object<gc_thread, follow, finalizable, publish>(addr);\n","filename":"src\/hotspot\/share\/gc\/z\/zHeap.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -281,22 +281,0 @@\n-bool ZMark::try_mark_object(ZMarkCache* cache, uintptr_t addr, bool finalizable) {\n-  ZPage* const page = _page_table->get(addr);\n-  if (page->is_allocating()) {\n-    \/\/ Newly allocated objects are implicitly marked\n-    return false;\n-  }\n-\n-  \/\/ Try mark object\n-  bool inc_live = false;\n-  const bool success = page->mark_object(addr, finalizable, inc_live);\n-  if (inc_live) {\n-    \/\/ Update live objects\/bytes for page. We use the aligned object\n-    \/\/ size since that is the actual number of bytes used on the page\n-    \/\/ and alignment paddings can never be reclaimed.\n-    const size_t size = ZUtils::object_size(addr);\n-    const size_t aligned_size = align_up(size, page->object_alignment());\n-    cache->inc_live(page, aligned_size);\n-  }\n-\n-  return success;\n-}\n-\n@@ -313,1 +291,1 @@\n-  \/\/ Decode object address and follow flag\n+  \/\/ Decode object address and additional flags\n@@ -315,0 +293,6 @@\n+  const bool mark = entry.mark();\n+  bool inc_live = entry.inc_live();\n+  const bool follow = entry.follow();\n+\n+  ZPage* const page = _page_table->get(addr);\n+  assert(page->is_relocatable(), \"Invalid page state\");\n@@ -316,1 +300,2 @@\n-  if (!try_mark_object(cache, addr, finalizable)) {\n+  \/\/ Mark\n+  if (mark && !page->mark_object(addr, finalizable, inc_live)) {\n@@ -321,3 +306,9 @@\n-  if (is_array(addr)) {\n-    \/\/ Decode follow flag\n-    const bool follow = entry.follow();\n+  \/\/ Increment live\n+  if (inc_live) {\n+    \/\/ Update live objects\/bytes for page. We use the aligned object\n+    \/\/ size since that is the actual number of bytes used on the page\n+    \/\/ and alignment paddings can never be reclaimed.\n+    const size_t size = ZUtils::object_size(addr);\n+    const size_t aligned_size = align_up(size, page->object_alignment());\n+    cache->inc_live(page, aligned_size);\n+  }\n@@ -325,2 +316,3 @@\n-    \/\/ The follow flag is currently only relevant for object arrays\n-    if (follow) {\n+  \/\/ Follow\n+  if (follow) {\n+    if (is_array(addr)) {\n@@ -328,0 +320,2 @@\n+    } else {\n+      follow_object(ZOop::from_address(addr), finalizable);\n@@ -329,2 +323,0 @@\n-  } else {\n-    follow_object(ZOop::from_address(addr), finalizable);\n@@ -779,0 +771,4 @@\n+void ZMark::free() {\n+  _allocator.free();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zMark.cpp","additions":27,"deletions":31,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,1 +67,1 @@\n-  bool try_mark_object(ZMarkCache* cache, uintptr_t addr, bool finalizable);\n+  template <bool gc_thread> bool should_mark_before_push() const;\n@@ -104,1 +104,1 @@\n-  template <bool follow, bool finalizable, bool publish> void mark_object(uintptr_t addr);\n+  template <bool gc_thread, bool follow, bool finalizable, bool publish> void mark_object(uintptr_t addr);\n@@ -109,0 +109,1 @@\n+  void free();\n","filename":"src\/hotspot\/share\/gc\/z\/zMark.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,3 @@\n+#include \"gc\/z\/zMarkStackAllocator.inline.hpp\"\n+#include \"gc\/z\/zPage.inline.hpp\"\n+#include \"gc\/z\/zPageTable.inline.hpp\"\n@@ -34,1 +37,20 @@\n-template <bool follow, bool finalizable, bool publish>\n+\/\/ Marking before pushing defeats the purpose of striped marking, but it\n+\/\/ can also help reduce mark stack usage. We mark before pushing, only if\n+\/\/ the mark stack usage is high, or if we're using a single stripe (in\n+\/\/ which case striped marking is essesntially disabled).\n+\/\/\n+\/\/ Furthermore, we only consider doing mark before pushing in GC threads\n+\/\/ to avoid burdening Java threads with writing to, and potentially first\n+\/\/ having to clear, mark bitmaps.\n+\/\/\n+\/\/ It's also worth noting that while marking an object can be done at any\n+\/\/ time in the marking phase, following an object can only be done after\n+\/\/ root processing has called ClassLoaderDataGraph::clear_claimed_marks(),\n+\/\/ since it otherwise would interact badly with claiming of CLDs.\n+\n+template <bool gc_thread>\n+inline bool ZMark::should_mark_before_push() const {\n+  return gc_thread && (_allocator.high_usage() || _stripes.nstripes() == 1);\n+}\n+\n+template <bool gc_thread, bool follow, bool finalizable, bool publish>\n@@ -37,0 +59,25 @@\n+\n+  ZPage* const page = _page_table->get(addr);\n+  if (page->is_allocating()) {\n+    \/\/ Already implicitly marked\n+    return;\n+  }\n+\n+  const bool mark_before_push = should_mark_before_push<gc_thread>();\n+  bool inc_live = false;\n+\n+  if (mark_before_push) {\n+    \/\/ Try mark object\n+    if (!page->mark_object(addr, finalizable, inc_live)) {\n+      \/\/ Already marked\n+      return;\n+    }\n+  } else {\n+    \/\/ Don't push if already marked\n+    if (page->is_object_marked<finalizable>(addr)) {\n+      \/\/ Already marked\n+      return;\n+    }\n+  }\n+\n+  \/\/ Push\n@@ -39,2 +86,1 @@\n-  ZMarkStackEntry entry(addr, follow, finalizable);\n-\n+  ZMarkStackEntry entry(addr, !mark_before_push, inc_live, follow, finalizable);\n","filename":"src\/hotspot\/share\/gc\/z\/zMark.inline.hpp","additions":50,"deletions":4,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -67,0 +67,2 @@\n+\n+  void clear();\n","filename":"src\/hotspot\/share\/gc\/z\/zMarkStack.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -159,0 +159,5 @@\n+template <typename T>\n+inline void ZStackList<T>::clear() {\n+  _head = encode_versioned_pointer(NULL, 0);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zMarkStack.inline.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -41,1 +41,2 @@\n-    _end(0) {\n+    _end(0),\n+    _high_usage(false) {\n@@ -57,0 +58,3 @@\n+\n+  \/\/ Prime space\n+  _end += expand_space();\n@@ -63,0 +67,59 @@\n+size_t ZMarkStackSpace::size() const {\n+  return _end - _start;\n+}\n+\n+static bool is_high_usage(size_t size) {\n+  \/\/ Consider usage to be high if we've used more than a 8th of the available space.\n+  \/\/ The available space (controlled by ZMarkStackSpaceLimit) is by default 8G, so\n+  \/\/ the high usage threshold will by default be 1G. The vast majority of workloads\n+  \/\/ will use a few hundred megabytes of space at most, so hitting the high usage\n+  \/\/ limit should be a rare event. At the same time, workloads that do see excessive\n+  \/\/ mark stack usage will typically see continuous mark stack space growth until\n+  \/\/ the high usage limit it hit, so setting the high usage limit too high will in\n+  \/\/ those situations just waste memory.\n+  return size > (ZMarkStackSpaceLimit \/ 8);\n+}\n+\n+size_t ZMarkStackSpace::expand_space() {\n+  const size_t expand_size = ZMarkStackSpaceExpandSize;\n+  const size_t old_size = size();\n+  const size_t new_size = old_size + expand_size;\n+\n+  if (new_size > ZMarkStackSpaceLimit) {\n+    \/\/ Expansion limit reached. This is a fatal error since we\n+    \/\/ currently can't recover from running out of mark stack space.\n+    fatal(\"Mark stack space exhausted. Use -XX:ZMarkStackSpaceLimit=<size> to increase the \"\n+          \"maximum number of bytes allocated for mark stacks. Current limit is \" SIZE_FORMAT \"M.\",\n+          ZMarkStackSpaceLimit \/ M);\n+  }\n+\n+  if (!_high_usage && is_high_usage(new_size)) {\n+    Atomic::store(&_high_usage, true);\n+  }\n+\n+  log_debug(gc, marking)(\"Expanding mark stack space: \" SIZE_FORMAT \"M->\" SIZE_FORMAT \"M (%s Usage)\",\n+                         old_size \/ M, new_size \/ M, _high_usage ? \"High\" : \"Low\");\n+\n+  \/\/ Expand\n+  os::commit_memory_or_exit((char*)_end, expand_size, false \/* executable *\/, \"Mark stack space\");\n+\n+  return expand_size;\n+}\n+\n+size_t ZMarkStackSpace::shrink_space() {\n+  const size_t old_size = size();\n+  const size_t new_size = ZMarkStackSpaceExpandSize;\n+  const size_t shrink_size = old_size - new_size;\n+\n+  if (shrink_size > 0) {\n+    \/\/ Shrink\n+    log_debug(gc, marking)(\"Shrinking mark stack space: \" SIZE_FORMAT \"M->\" SIZE_FORMAT \"M\",\n+                           old_size \/ M, new_size \/ M);\n+\n+    const uintptr_t shrink_start = _end - shrink_size;\n+    os::uncommit_memory((char*)shrink_start, shrink_size, false \/* executable *\/);\n+  }\n+\n+  return shrink_size;\n+}\n+\n@@ -94,15 +157,0 @@\n-  \/\/ Check expansion limit\n-  const size_t expand_size = ZMarkStackSpaceExpandSize;\n-  const size_t old_size = _end - _start;\n-  const size_t new_size = old_size + expand_size;\n-  if (new_size > ZMarkStackSpaceLimit) {\n-    \/\/ Expansion limit reached. This is a fatal error since we\n-    \/\/ currently can't recover from running out of mark stack space.\n-    fatal(\"Mark stack space exhausted. Use -XX:ZMarkStackSpaceLimit=<size> to increase the \"\n-          \"maximum number of bytes allocated for mark stacks. Current limit is \" SIZE_FORMAT \"M.\",\n-          ZMarkStackSpaceLimit \/ M);\n-  }\n-\n-  log_debug(gc, marking)(\"Expanding mark stack space: \" SIZE_FORMAT \"M->\" SIZE_FORMAT \"M\",\n-                         old_size \/ M, new_size \/ M);\n-\n@@ -110,1 +158,1 @@\n-  os::commit_memory_or_exit((char*)_end, expand_size, false \/* executable *\/, \"Mark stack space\");\n+  const size_t expand_size = expand_space();\n@@ -121,0 +169,2 @@\n+  assert(size <= ZMarkStackSpaceExpandSize, \"Invalid size\");\n+\n@@ -129,0 +179,6 @@\n+void ZMarkStackSpace::free() {\n+  _top = _start;\n+  _end -= shrink_space();\n+  _high_usage = is_high_usage(size());\n+}\n+\n@@ -131,7 +187,1 @@\n-    _space() {\n-  \/\/ Prime free list to avoid an immediate space\n-  \/\/ expansion when marking starts.\n-  if (_space.is_initialized()) {\n-    prime_freelist();\n-  }\n-}\n+    _space() {}\n@@ -143,8 +193,0 @@\n-void ZMarkStackAllocator::prime_freelist() {\n-  for (size_t size = 0; size < ZMarkStackSpaceExpandSize; size += ZMarkStackMagazineSize) {\n-    const uintptr_t addr = _space.alloc(ZMarkStackMagazineSize);\n-    ZMarkStackMagazine* const magazine = create_magazine_from_space(addr, ZMarkStackMagazineSize);\n-    free_magazine(magazine);\n-  }\n-}\n-\n@@ -184,0 +226,5 @@\n+\n+void ZMarkStackAllocator::free() {\n+  _freelist.clear();\n+  _space.free();\n+}\n","filename":"src\/hotspot\/share\/gc\/z\/zMarkStackAllocator.cpp","additions":79,"deletions":32,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+  volatile bool      _high_usage;\n@@ -38,1 +39,4 @@\n-  void expand();\n+  size_t size() const;\n+\n+  size_t expand_space();\n+  size_t shrink_space();\n@@ -48,0 +52,2 @@\n+  bool high_usage() const;\n+\n@@ -49,0 +55,1 @@\n+  void free();\n@@ -56,1 +63,0 @@\n-  void prime_freelist();\n@@ -64,0 +70,2 @@\n+  bool high_usage() const;\n+\n@@ -66,0 +74,2 @@\n+\n+  void free();\n","filename":"src\/hotspot\/share\/gc\/z\/zMarkStackAllocator.hpp","additions":13,"deletions":3,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef SHARE_GC_Z_ZMARKSTACKALLOCATOR_INLINE_HPP\n+#define SHARE_GC_Z_ZMARKSTACKALLOCATOR_INLINE_HPP\n+\n+#include \"gc\/z\/zMarkStackAllocator.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+\n+inline bool ZMarkStackSpace::high_usage() const {\n+  return Atomic::load(&_high_usage);\n+}\n+\n+inline bool ZMarkStackAllocator::high_usage() const {\n+  return _space.high_usage();\n+}\n+\n+#endif \/\/ SHARE_GC_Z_ZMARKSTACKALLOCATOR_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/z\/zMarkStackAllocator.inline.hpp","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,10 +38,14 @@\n-\/\/   3                                                                  3 2 1 0\n-\/\/  +--------------------------------------------------------------------+-+-+-+\n-\/\/  |11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111|1|1|1|\n-\/\/  +--------------------------------------------------------------------+-+-+-+\n-\/\/  |                                                                    | | |\n-\/\/  |                                            2-2 Follow Flag (1-bit) * | |\n-\/\/  |                                                                      | |\n-\/\/  |                                       1-1 Partial Array Flag (1-bit) * |\n-\/\/  |                                                                        |\n-\/\/  |                                                 0-0 Final Flag (1-bit) *\n+\/\/   3                                                                5 4 3 2 1 0\n+\/\/  +------------------------------------------------------------------+-+-+-+-+-+\n+\/\/  |11111111 11111111 11111111 11111111 11111111 11111111 11111111 111|1|1|1|1|1|\n+\/\/  +------------------------------------------------------------------+-+-+-+-+-+\n+\/\/  |                                                                  | | | | |\n+\/\/  |                                            4-4 Mark Flag (1-bit) * | | | |\n+\/\/  |                                                                    | | | |\n+\/\/  |                                    3-3 Increment Live Flag (1-bit) * | | |\n+\/\/  |                                                                      | | |\n+\/\/  |                                              2-2 Follow Flag (1-bit) * | |\n+\/\/  |                                                                        | |\n+\/\/  |                                         1-1 Partial Array Flag (1-bit) * |\n+\/\/  |                                                                          |\n+\/\/  |                                                   0-0 Final Flag (1-bit) *\n@@ -49,1 +53,1 @@\n-\/\/  * 63-3 Object Address (61-bits)\n+\/\/  * 63-5 Object Address (59-bits)\n@@ -75,1 +79,3 @@\n-  typedef ZBitField<uint64_t, uintptr_t, 3,  61> field_object_address;\n+  typedef ZBitField<uint64_t, bool,      3,  1>  field_inc_live;\n+  typedef ZBitField<uint64_t, bool,      4,  1>  field_mark;\n+  typedef ZBitField<uint64_t, uintptr_t, 5,  59> field_object_address;\n@@ -89,1 +95,1 @@\n-  ZMarkStackEntry(uintptr_t object_address, bool follow, bool finalizable) :\n+  ZMarkStackEntry(uintptr_t object_address, bool mark, bool inc_live, bool follow, bool finalizable) :\n@@ -91,0 +97,2 @@\n+             field_mark::encode(mark) |\n+             field_inc_live::encode(inc_live) |\n@@ -121,0 +129,8 @@\n+  bool inc_live() const {\n+    return field_inc_live::decode(_entry);\n+  }\n+\n+  bool mark() const {\n+    return field_mark::decode(_entry);\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zMarkStackEntry.hpp","additions":30,"deletions":14,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -95,0 +95,1 @@\n+  template <bool finalizable> bool is_object_marked(uintptr_t addr) const;\n","filename":"src\/hotspot\/share\/gc\/z\/zPage.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -174,0 +174,1 @@\n+  assert(is_relocatable(), \"Invalid page state\");\n@@ -179,0 +180,1 @@\n+  assert(is_relocatable(), \"Invalid page state\");\n@@ -183,0 +185,5 @@\n+template <bool finalizable>\n+inline bool ZPage::is_object_marked(uintptr_t addr) const {\n+  return finalizable ? is_object_marked(addr) : is_object_strongly_marked(addr);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zPage.inline.hpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"}]}