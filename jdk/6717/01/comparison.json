{"files":[{"patch":"@@ -170,0 +170,8 @@\n+ciObjArrayKlass* ciObjArrayKlass::make(ciKlass* element_klass, int dims) {\n+  ciKlass* klass = element_klass;\n+  for (int i = 0; i < dims; i++) {\n+    klass = ciObjArrayKlass::make(klass);\n+  }\n+  return klass->as_obj_array_klass();\n+}\n+\n","filename":"src\/hotspot\/share\/ci\/ciObjArrayKlass.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -76,0 +76,1 @@\n+  static ciObjArrayKlass* make(ciKlass* element_klass, int dims);\n","filename":"src\/hotspot\/share\/ci\/ciObjArrayKlass.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -531,2 +531,2 @@\n-      ciKlass* klass = itype->klass();\n-      if ( klass->is_loaded() &&\n+      ciKlass* klass = itype->instance_klass();\n+      if (klass->is_loaded() &&\n","filename":"src\/hotspot\/share\/gc\/g1\/c2\/g1BarrierSetC2.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -377,1 +377,1 @@\n-        int s = Klass::layout_helper_size_in_bytes(adr_type->isa_instptr()->klass()->layout_helper());\n+        int s = Klass::layout_helper_size_in_bytes(adr_type->isa_instptr()->instance_klass()->layout_helper());\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/barrierSetC2.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -392,2 +392,2 @@\n-      ciKlass* klass = itype->klass();\n-      if ( klass->is_loaded() &&\n+      ciKlass* klass = itype->instance_klass();\n+      if (klass->is_loaded() &&\n@@ -786,2 +786,2 @@\n-    ciInstanceKlass* ik = src_type->klass()->as_instance_klass();\n-    if ((src_type->klass_is_exact() || (!ik->is_interface() && !ik->has_subklass())) && !ik->has_injected_fields()) {\n+    ciInstanceKlass* ik = src_type->is_instptr()->instance_klass();\n+    if ((src_type->klass_is_exact() || !ik->has_subklass()) && !ik->has_injected_fields()) {\n@@ -799,2 +799,2 @@\n-    BasicType src_elem  = src_type->klass()->as_array_klass()->element_type()->basic_type();\n-    if (is_reference_type(src_elem)) {\n+    BasicType src_elem = src_type->isa_aryptr()->elem()->array_element_basic_type();\n+    if (is_reference_type(src_elem, true)) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahBarrierSetC2.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -301,1 +301,1 @@\n-                   adr_type->is_instptr()->klass()->is_subtype_of(Compile::current()->env()->Reference_klass()) &&\n+                   adr_type->is_instptr()->instance_klass()->is_subtype_of(Compile::current()->env()->Reference_klass()) &&\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -102,1 +102,1 @@\n-\/\/ Initialization of vtables and mirror object is done separatly from base_create_array_klass,\n+\/\/ Initialization of vtables and mirror object is done separately from base_create_array_klass,\n","filename":"src\/hotspot\/share\/oops\/arrayKlass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -123,1 +123,1 @@\n-      ciInstanceKlass* ik = inst_src->klass()->as_instance_klass();\n+      ciInstanceKlass* ik = inst_src->instance_klass();\n@@ -197,0 +197,3 @@\n+\n+  ciInstanceKlass* ik = inst_src->instance_klass();\n+\n@@ -198,1 +201,0 @@\n-    ciInstanceKlass* ik = inst_src->klass()->as_instance_klass();\n@@ -209,1 +211,0 @@\n-  ciInstanceKlass* ik = inst_src->klass()->as_instance_klass();\n@@ -267,3 +268,2 @@\n-\n-    if (ary_src  == NULL || ary_src->klass()  == NULL ||\n-        ary_dest == NULL || ary_dest->klass() == NULL) {\n+    if (ary_src  == NULL || ary_src->elem()  == Type::BOTTOM ||\n+        ary_dest == NULL || ary_dest->elem() == Type::BOTTOM) {\n@@ -274,4 +274,4 @@\n-    BasicType src_elem  = ary_src->klass()->as_array_klass()->element_type()->basic_type();\n-    BasicType dest_elem = ary_dest->klass()->as_array_klass()->element_type()->basic_type();\n-    if (is_reference_type(src_elem))   src_elem  = T_OBJECT;\n-    if (is_reference_type(dest_elem))  dest_elem = T_OBJECT;\n+    BasicType src_elem = ary_src->elem()->array_element_basic_type();\n+    BasicType dest_elem = ary_dest->elem()->array_element_basic_type();\n+    if (is_reference_type(src_elem, true)) src_elem = T_OBJECT;\n+    if (is_reference_type(dest_elem, true)) dest_elem = T_OBJECT;\n@@ -322,2 +322,2 @@\n-    BasicType elem = ary_src->klass()->as_array_klass()->element_type()->basic_type();\n-    if (is_reference_type(elem)) {\n+    BasicType elem = ary_src->isa_aryptr()->elem()->array_element_basic_type();\n+    if (is_reference_type(elem, true)) {\n@@ -724,1 +724,3 @@\n-  BasicType ary_elem = ary_t->klass()->as_array_klass()->element_type()->basic_type();\n+  BasicType ary_elem = ary_t->isa_aryptr()->elem()->array_element_basic_type();\n+  if (is_reference_type(ary_elem, true)) ary_elem = T_OBJECT;\n+\n","filename":"src\/hotspot\/share\/opto\/arraycopynode.cpp","additions":15,"deletions":13,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -383,1 +383,1 @@\n-      st->print(\" %s%d]=#Ptr\" INTPTR_FORMAT,msg,i,p2i(t->make_ptr()->isa_klassptr()->klass()));\n+      st->print(\" %s%d]=#Ptr\" INTPTR_FORMAT,msg,i,p2i(t->make_ptr()->isa_klassptr()->exact_klass()));\n@@ -474,1 +474,1 @@\n-      ciKlass* cik = spobj->bottom_type()->is_oopptr()->klass();\n+      ciKlass* cik = spobj->bottom_type()->is_oopptr()->exact_klass();\n@@ -810,1 +810,1 @@\n-    ciKlass* boxing_klass = t_oop->klass();\n+    ciKlass* boxing_klass = t_oop->is_instptr()->instance_klass();\n@@ -814,1 +814,1 @@\n-      if ((proj == NULL) || (phase->type(proj)->is_instptr()->klass() != boxing_klass)) {\n+      if ((proj == NULL) || (phase->type(proj)->is_instptr()->instance_klass() != boxing_klass)) {\n@@ -829,1 +829,1 @@\n-                                 (inst_t->klass() == boxing_klass))) {\n+                                 (inst_t->instance_klass() == boxing_klass))) {\n@@ -837,1 +837,1 @@\n-                                 (inst_t->klass() == boxing_klass))) {\n+                                 (inst_t->instance_klass() == boxing_klass))) {\n@@ -2315,1 +2315,1 @@\n-  if (dest_t->isa_instptr() && !dest_t->klass()->equals(phase->C->env()->Object_klass())) {\n+  if (dest_t->isa_instptr() && !dest_t->is_instptr()->instance_klass()->equals(phase->C->env()->Object_klass())) {\n@@ -2323,1 +2323,1 @@\n-    if (dest_t->klass()->is_subtype_of(t_oop->klass()) || t_oop->klass()->is_subtype_of(dest_t->klass())) {\n+    if (dest_t->maybe_java_subtype_of(t_oop) || t_oop->maybe_java_subtype_of(dest_t)) {\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1143,1 +1143,1 @@\n-  const TypeKlassPtr* ttkp = (ttp != NULL) ? ttp->isa_instklassptr() : NULL;\n+  const TypeInstKlassPtr* ttkp = (ttp != NULL) ? ttp->isa_instklassptr() : NULL;\n@@ -1146,2 +1146,1 @@\n-    ciKlass* k = ttip->klass();\n-    if (k->is_loaded() && k->is_interface())\n+    if (ttip->is_interface())\n@@ -1151,2 +1150,1 @@\n-    ciKlass* k = ttkp->klass();\n-    if (k->is_loaded() && k->is_interface())\n+    if (ttkp->is_interface())\n@@ -1171,2 +1169,1 @@\n-        ciKlass* k = tiip->klass();\n-        if (k->is_loaded() && k->is_interface())\n+        if (tiip->is_interface())\n@@ -1210,1 +1207,1 @@\n-    if (!t->empty() && ttip && ttip->is_loaded() && ttip->klass()->is_interface()) {\n+    if (!t->empty() && ttip && ttip->is_interface()) {\n@@ -1212,1 +1209,1 @@\n-    } else if (!t->empty() && ttkp && ttkp->is_loaded() && ttkp->klass()->is_interface()) {\n+    } else if (!t->empty() && ttkp && ttkp->is_interface()) {\n@@ -1217,1 +1214,1 @@\n-      if (!t->empty() && ttip != NULL && ttip->is_loaded() && ttip->klass()->is_interface()) {\n+      if (!t->empty() && ttip != NULL && ttip->is_interface()) {\n@@ -1236,4 +1233,4 @@\n-    const TypeKlassPtr *jtkp = (jtp != NULL) ? jtp->isa_instklassptr() : NULL;\n-    if( jtip && ttip ) {\n-      if( jtip->is_loaded() &&  jtip->klass()->is_interface() &&\n-          ttip->is_loaded() && !ttip->klass()->is_interface() ) {\n+    const TypeInstKlassPtr *jtkp = (jtp != NULL) ? jtp->isa_instklassptr() : NULL;\n+    if (jtip && ttip) {\n+      if (jtip->is_interface() &&\n+          !ttip->is_interface()) {\n@@ -1245,2 +1242,2 @@\n-    if( jtkp && ttkp ) {\n-      if( jtkp->is_loaded() &&  jtkp->klass()->is_interface() &&\n+    if (jtkp && ttkp) {\n+      if (jtkp->is_interface() &&\n@@ -1248,1 +1245,1 @@\n-          ttkp->is_loaded() && !ttkp->klass()->is_interface() ) {\n+          ttkp->is_loaded() && !ttkp->is_interface()) {\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":14,"deletions":17,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -1297,1 +1297,1 @@\n-  const TypeAryPtr *ta = tj->isa_aryptr();\n+  const TypeAryPtr* ta = tj->isa_aryptr();\n@@ -1306,1 +1306,4 @@\n-      tj = ta = TypeAryPtr::make(ptr, ta->ary(), ta->klass(), true, offset, ta->instance_id());\n+      tj = ta = ta->\n+              remove_speculative()->\n+              cast_to_ptr_type(ptr)->\n+              with_offset(offset);\n@@ -1315,1 +1318,5 @@\n-        tj = ta = TypeAryPtr::make(ptr,ta->const_oop(),ta->ary(),ta->klass(),false,offset);\n+        tj = ta = ta->\n+                remove_speculative()->\n+                cast_to_ptr_type(ptr)->\n+                cast_to_exactness(false)->\n+                with_offset(offset);\n@@ -1329,1 +1336,5 @@\n-        tj = ta = TypeAryPtr::make(ptr,ta->ary(),ta->klass(),false,offset);\n+        tj = ta = ta->\n+                remove_speculative()->\n+                cast_to_ptr_type(ptr)->\n+                cast_to_exactness(false)->\n+                with_offset(offset);\n@@ -1335,1 +1346,5 @@\n-      tj = ta = TypeAryPtr::make(ptr,ta->const_oop(),tary,ta->klass(),false,offset);\n+      tj = ta = ta->\n+              remove_speculative()->\n+              cast_to_ptr_type(ptr)->\n+              with_ary(tary)->\n+              cast_to_exactness(false);\n@@ -1357,1 +1372,5 @@\n-      tj = ta = TypeAryPtr::make(TypePtr::BotPTR,ta->ary(),ta->klass(),false,offset);\n+      tj = ta = ta->\n+              remove_speculative()->\n+              cast_to_ptr_type(TypePtr::BotPTR)->\n+              cast_to_exactness(false)->\n+              with_offset(offset);\n@@ -1364,1 +1383,1 @@\n-    ciInstanceKlass *k = to->klass()->as_instance_klass();\n+    ciInstanceKlass* ik = to->instance_klass();\n@@ -1366,2 +1385,2 @@\n-      if (to->klass() != ciEnv::current()->Class_klass() ||\n-          offset < k->layout_helper_size_in_bytes()) {\n+      if (ik != ciEnv::current()->Class_klass() ||\n+          offset < ik->layout_helper_size_in_bytes()) {\n@@ -1371,1 +1390,5 @@\n-        tj = to = TypeInstPtr::make(TypePtr::BotPTR,to->klass(),false,0,offset);\n+        tj = to = to->\n+                cast_to_instance_id(TypeOopPtr::InstanceBot)->\n+                remove_speculative()->\n+                cast_to_ptr_type(TypePtr::BotPTR)->\n+                cast_to_exactness(false);\n@@ -1379,1 +1402,5 @@\n-      tj = to = TypeInstPtr::make(TypePtr::BotPTR,to->klass(),false,0,offset);\n+      tj = to = to->\n+              remove_speculative()->\n+              cast_to_instance_id(TypeOopPtr::InstanceBot)->\n+              cast_to_ptr_type(TypePtr::BotPTR)->\n+              cast_to_exactness(false);\n@@ -1382,1 +1409,1 @@\n-      tj = to = TypeInstPtr::make(to->ptr(),to->klass(),to->klass_is_exact(),to->const_oop(),to->offset(), to->instance_id());\n+      tj = to = to->remove_speculative();\n@@ -1391,1 +1418,1 @@\n-    } else if (offset < 0 || offset >= k->layout_helper_size_in_bytes()) {\n+    } else if (offset < 0 || offset >= ik->layout_helper_size_in_bytes()) {\n@@ -1394,1 +1421,1 @@\n-      if (to->klass() != ciEnv::current()->Class_klass()) {\n+      if (ik != ciEnv::current()->Class_klass()) {\n@@ -1400,1 +1427,1 @@\n-      ciInstanceKlass *canonical_holder = k->get_canonical_holder(offset);\n+      ciInstanceKlass *canonical_holder = ik->get_canonical_holder(offset);\n@@ -1402,1 +1429,1 @@\n-      if (!k->equals(canonical_holder) || tj->offset() != offset) {\n+      if (!ik->equals(canonical_holder) || tj->offset() != offset) {\n@@ -1420,4 +1447,3 @@\n-\n-      tj = tk = TypeKlassPtr::make(TypePtr::NotNull,\n-                                   TypeInstKlassPtr::OBJECT->klass(),\n-                                   offset);\n+      tj = tk = TypeInstKlassPtr::make(TypePtr::NotNull,\n+                                       env()->Object_klass(),\n+                                       offset);\n@@ -1426,6 +1452,7 @@\n-    ciKlass* klass = tk->klass();\n-    if( klass->is_obj_array_klass() ) {\n-      ciKlass* k = TypeAryPtr::OOPS->klass();\n-      if( !k || !k->is_loaded() )                  \/\/ Only fails for some -Xcomp runs\n-        k = TypeInstPtr::BOTTOM->klass();\n-      tj = tk = TypeKlassPtr::make( TypePtr::NotNull, k, offset );\n+    if (tk->isa_aryklassptr() && tk->is_aryklassptr()->elem()->isa_klassptr()) {\n+      ciKlass* k = ciObjArrayKlass::make(env()->Object_klass());\n+      if (!k || !k->is_loaded()) {                  \/\/ Only fails for some -Xcomp runs\n+        tj = tk = TypeInstKlassPtr::make(TypePtr::NotNull, env()->Object_klass(), offset);\n+      } else {\n+        tj = tk = TypeAryKlassPtr::make(TypePtr::NotNull, tk->is_aryklassptr()->elem(), k, offset);\n+      }\n@@ -1447,1 +1474,1 @@\n-      tj = tk = TypeKlassPtr::make( TypePtr::NotNull, tk->klass(), offset );\n+      tj = tk = tk->with_offset(offset);\n@@ -1546,1 +1573,1 @@\n-    if (tjp->klass()  != field()->holder() ||\n+    if (tjp->is_instptr()->instance_klass()  != field()->holder() ||\n@@ -1641,1 +1668,1 @@\n-          && flat->is_instptr()->klass() == env()->Class_klass())\n+          && flat->is_instptr()->instance_klass() == env()->Class_klass())\n@@ -1675,2 +1702,2 @@\n-          tinst->klass() == ciEnv::current()->Class_klass() &&\n-          tinst->offset() >= (tinst->klass()->as_instance_klass()->layout_helper_size_in_bytes())) {\n+          tinst->instance_klass() == ciEnv::current()->Class_klass() &&\n+          tinst->offset() >= (tinst->instance_klass()->layout_helper_size_in_bytes())) {\n@@ -1681,1 +1708,1 @@\n-        ciInstanceKlass *k = tinst->klass()->as_instance_klass();\n+        ciInstanceKlass *k = tinst->instance_klass();\n@@ -4152,1 +4179,1 @@\n-int Compile::static_subtype_check(ciKlass* superk, ciKlass* subk) {\n+Compile::SubTypeCheckResult Compile::static_subtype_check(const TypeKlassPtr* superk, const TypeKlassPtr* subk) {\n@@ -4157,2 +4184,2 @@\n-  if (superk == env()->Object_klass()) {\n-    return SSC_always_true;     \/\/ (0) this test cannot fail\n+  if (subk->is_java_subtype_of(superk)) {\n+    return SSC_always_true; \/\/ (0) and (1)  this test cannot fail\n@@ -4161,7 +4188,2 @@\n-  ciType* superelem = superk;\n-  ciType* subelem = subk;\n-  if (superelem->is_array_klass()) {\n-    superelem = superelem->as_array_klass()->base_element_type();\n-  }\n-  if (subelem->is_array_klass()) {\n-    subelem = subelem->as_array_klass()->base_element_type();\n+  if (!subk->maybe_java_subtype_of(superk)) {\n+    return SSC_always_false; \/\/ (2) true path dead; no dynamic test needed\n@@ -4170,9 +4192,4 @@\n-  if (!subk->is_interface()) {  \/\/ cannot trust static interface types yet\n-    if (subk->is_subtype_of(superk)) {\n-      return SSC_always_true;   \/\/ (1) false path dead; no dynamic test needed\n-    }\n-    if (!(superelem->is_klass() && superelem->as_klass()->is_interface()) &&\n-        !(subelem->is_klass() && subelem->as_klass()->is_interface()) &&\n-        !superk->is_subtype_of(subk)) {\n-      return SSC_always_false;  \/\/ (2) true path dead; no dynamic test needed\n-    }\n+  const Type* superelem = superk;\n+  if (superk->isa_aryklassptr()) {\n+    int ignored;\n+    superelem = superk->is_aryklassptr()->base_element_type(ignored);\n@@ -4181,7 +4198,3 @@\n-  \/\/ If casting to an instance klass, it must have no subtypes\n-  if (superk->is_interface()) {\n-    \/\/ Cannot trust interfaces yet.\n-    \/\/ %%% S.B. superk->nof_implementors() == 1\n-  } else if (superelem->is_instance_klass()) {\n-    ciInstanceKlass* ik = superelem->as_instance_klass();\n-    if (!ik->has_subklass() && !ik->is_interface()) {\n+  if (superelem->isa_instklassptr()) {\n+    ciInstanceKlass* ik = superelem->is_instklassptr()->instance_klass();\n+    if (!ik->has_subklass()) {\n@@ -4192,0 +4205,3 @@\n+      if (!superk->maybe_java_subtype_of(subk)) {\n+        return SSC_always_false;\n+      }\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":74,"deletions":58,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -87,0 +87,1 @@\n+class TypeKlassPtr;\n@@ -1167,2 +1168,2 @@\n-  enum { SSC_always_false, SSC_always_true, SSC_easy_test, SSC_full_test };\n-  int static_subtype_check(ciKlass* superk, ciKlass* subk);\n+  enum SubTypeCheckResult { SSC_always_false, SSC_always_true, SSC_easy_test, SSC_full_test };\n+  SubTypeCheckResult static_subtype_check(const TypeKlassPtr* superk, const TypeKlassPtr* subk);\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -857,1 +857,1 @@\n-        extype->klass()->print_name();\n+        extype->instance_klass()->print_name();\n@@ -867,1 +867,1 @@\n-                    extype->klass(), \"!loaded exception\");\n+                    extype->instance_klass(), \"!loaded exception\");\n@@ -914,1 +914,1 @@\n-                                    ex_type->klass()->as_instance_klass(),\n+                                    ex_type->instance_klass(),\n@@ -1136,1 +1136,1 @@\n-  ciInstanceKlass* receiver_klass = receiver_type->klass()->as_instance_klass();\n+  ciInstanceKlass* receiver_klass = receiver_type->is_instptr()->instance_klass();\n","filename":"src\/hotspot\/share\/opto\/doCall.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -892,1 +892,0 @@\n-    ciKlass* cik = kt->klass();\n@@ -896,1 +895,1 @@\n-      if (!cik->is_array_klass()) { \/\/ StressReflectiveCode\n+      if (!kt->isa_aryklassptr()) { \/\/ StressReflectiveCode\n@@ -906,5 +905,1 @@\n-      if (cik->is_subclass_of(_compile->env()->Thread_klass()) ||\n-          cik->is_subclass_of(_compile->env()->Reference_klass()) ||\n-         !cik->is_instance_klass() || \/\/ StressReflectiveCode\n-         !cik->as_instance_klass()->can_be_instantiated() ||\n-          cik->as_instance_klass()->has_finalizer()) {\n+      if (!kt->isa_instklassptr()) { \/\/ StressReflectiveCode\n@@ -913,4 +908,13 @@\n-        int nfields = cik->as_instance_klass()->nof_nonstatic_fields();\n-        if (nfields > EliminateAllocationFieldsLimit) {\n-          \/\/ Not scalar replaceable if there are too many fields.\n-          scalar_replaceable = false;\n+        const TypeInstKlassPtr* ikt = kt->is_instklassptr();\n+        ciInstanceKlass* ik = ikt->klass_is_exact() ? ikt->exact_klass()->as_instance_klass() : ikt->instance_klass();\n+        if (ik->is_subclass_of(_compile->env()->Thread_klass()) ||\n+            ik->is_subclass_of(_compile->env()->Reference_klass()) ||\n+            !ik->can_be_instantiated() ||\n+            ik->has_finalizer()) {\n+          es = PointsToNode::GlobalEscape;\n+        } else {\n+          int nfields = ik->as_instance_klass()->nof_nonstatic_fields();\n+          if (nfields > EliminateAllocationFieldsLimit) {\n+            \/\/ Not scalar replaceable if there are too many fields.\n+            scalar_replaceable = false;\n+          }\n@@ -1057,2 +1061,2 @@\n-                              (aat->isa_oopptr()->klass() == NULL || aat->isa_instptr() ||\n-                               (aat->isa_aryptr() && aat->isa_aryptr()->klass()->is_obj_array_klass()));\n+                              (aat->isa_instptr() ||\n+                               (aat->isa_aryptr() && (aat->isa_aryptr()->elem() == Type::BOTTOM || aat->isa_aryptr()->elem()->make_oopptr() != NULL)));\n@@ -2180,2 +2184,2 @@\n-        (adr_type->isa_aryptr()->klass() == NULL) ||\n-         adr_type->isa_aryptr()->klass()->is_obj_array_klass()) {\n+        adr_type->isa_aryptr()->elem() == Type::BOTTOM ||\n+        adr_type->isa_aryptr()->elem()->make_oopptr() != NULL) {\n@@ -2572,1 +2576,1 @@\n-      !base_t->klass()->is_subtype_of(t->klass())) {\n+      !t->maybe_java_subtype_of(base_t)) {\n@@ -2738,2 +2742,2 @@\n-      !(toop->klass() != NULL &&\n-        toop->klass()->is_java_lang_Object() &&\n+      !(toop->isa_instptr() &&\n+        toop->is_instptr()->instance_klass()->is_java_lang_Object() &&\n@@ -3256,1 +3260,1 @@\n-        if (tn_t != NULL && tinst->klass()->is_subtype_of(tn_t->klass())) {\n+        if (tn_t != NULL && tn_t->maybe_java_subtype_of(tinst)) {\n@@ -3269,1 +3273,1 @@\n-                 tn_t != NULL && !tinst->klass()->is_subtype_of(tn_t->klass()),\n+                 tn_t != NULL && !tinst->is_java_subtype_of(tn_t),\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":24,"deletions":20,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -529,1 +529,1 @@\n-void GraphKit::builtin_throw(Deoptimization::DeoptReason reason, Node* arg) {\n+void GraphKit::builtin_throw(Deoptimization::DeoptReason reason) {\n@@ -1245,1 +1245,1 @@\n-      if (tp != NULL && tp->klass() != NULL && !tp->klass()->is_loaded()\n+      if (tp != NULL && !tp->is_loaded()\n@@ -1259,0 +1259,1 @@\n+        ciKlass* klass = tp->unloaded_klass();\n@@ -1260,1 +1261,1 @@\n-        if (WizardMode) { tty->print(\"Null check of unloaded \"); tp->klass()->print(); tty->cr(); }\n+        if (WizardMode) { tty->print(\"Null check of unloaded \"); klass->print(); tty->cr(); }\n@@ -1264,1 +1265,1 @@\n-                      tp->klass(), \"!loaded\");\n+                      klass, \"!loaded\");\n@@ -2795,2 +2796,2 @@\n-    ciKlass* superk = gvn.type(superklass)->is_klassptr()->klass();\n-    ciKlass* subk   = gvn.type(subklass)->is_klassptr()->klass();\n+    const TypeKlassPtr* superk = gvn.type(superklass)->is_klassptr();\n+    const TypeKlassPtr* subk   = gvn.type(subklass)->is_klassptr();\n@@ -3108,1 +3109,1 @@\n-                                             ciKlass* require_klass,\n+                                             const TypeKlassPtr* require_klass,\n@@ -3126,1 +3127,1 @@\n-        C->static_subtype_check(require_klass, exact_kls) == Compile::SSC_always_true) {\n+        C->static_subtype_check(require_klass, TypeKlassPtr::make(exact_kls)) == Compile::SSC_always_true) {\n@@ -3251,3 +3252,3 @@\n-    ciKlass* superk = _gvn.type(superklass)->is_klassptr()->klass();\n-    ciKlass* subk = _gvn.type(obj)->is_oopptr()->klass();\n-    if (subk != NULL && subk->is_loaded()) {\n+    const TypeKlassPtr* superk = _gvn.type(superklass)->is_klassptr();\n+    const TypeKlassPtr* subk = _gvn.type(obj)->is_oopptr()->as_klass_type();\n+    if (subk->is_loaded()) {\n@@ -3313,1 +3314,1 @@\n-  const Type *toop = TypeOopPtr::make_from_klass(tk->klass());\n+  const Type *toop = tk->cast_to_exactness(false)->as_instance_type();\n@@ -3323,2 +3324,2 @@\n-    if (objtp != NULL && objtp->klass() != NULL) {\n-      switch (C->static_subtype_check(tk->klass(), objtp->klass())) {\n+    if (objtp != NULL) {\n+      switch (C->static_subtype_check(tk, objtp->as_klass_type())) {\n@@ -3337,1 +3338,1 @@\n-          builtin_throw(reason, makecon(TypeKlassPtr::make(objtp->klass())));\n+          builtin_throw(reason);\n@@ -3343,0 +3344,2 @@\n+      default:\n+        break;\n@@ -3398,1 +3401,1 @@\n-      cast_obj = maybe_cast_profiled_receiver(not_null_obj, tk->klass(), spec_obj_type, safe_for_replace);\n+      cast_obj = maybe_cast_profiled_receiver(not_null_obj, tk, spec_obj_type, safe_for_replace);\n@@ -3422,1 +3425,1 @@\n-        builtin_throw(reason, load_object_klass(not_null_obj));\n+        builtin_throw(reason);\n@@ -3624,1 +3627,0 @@\n-    ciKlass* klass = inst_klass->klass();\n@@ -3626,2 +3628,11 @@\n-    if (xklass || klass->is_array_klass()) {\n-      jint lhelper = klass->layout_helper();\n+    if (xklass || inst_klass->isa_aryklassptr()) {\n+      jint lhelper;\n+      if (inst_klass->isa_aryklassptr()) {\n+        BasicType elem = inst_klass->as_instance_type()->isa_aryptr()->elem()->array_element_basic_type();\n+        if (is_reference_type(elem, true)) {\n+          elem = T_OBJECT;\n+        }\n+        lhelper = Klass::array_layout_helper(elem);\n+      } else {\n+        lhelper = inst_klass->is_instklassptr()->exact_klass()->layout_helper();\n+      }\n@@ -3699,1 +3710,1 @@\n-      ciInstanceKlass* ik = oop_type->klass()->as_instance_klass();\n+      ciInstanceKlass* ik = oop_type->is_instptr()->instance_klass();\n@@ -3976,2 +3987,2 @@\n-  if (ary_type->klass()->is_array_klass()) {\n-    BasicType bt = ary_type->klass()->as_array_klass()->element_type()->basic_type();\n+  if (ary_type->isa_aryptr()) {\n+    BasicType bt = ary_type->isa_aryptr()->elem()->array_element_basic_type();\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":34,"deletions":23,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -274,1 +274,1 @@\n-  void builtin_throw(Deoptimization::DeoptReason reason, Node* arg = NULL);\n+  void builtin_throw(Deoptimization::DeoptReason reason);\n@@ -427,1 +427,1 @@\n-                                     ciKlass* require_klass,\n+                                     const TypeKlassPtr* require_klass,\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -491,1 +491,1 @@\n-    if (t != NULL && (t->isa_instptr() || t->isa_klassptr())) {\n+    if (t != NULL && (t->isa_instptr() || t->isa_instklassptr())) {\n@@ -493,3 +493,2 @@\n-      const TypeKlassPtr *tkls = t->isa_klassptr();\n-      ciKlass*           klass = toop ? toop->klass() : (tkls ? tkls->klass() : NULL );\n-      if( klass && klass->is_loaded() && klass->is_interface() ) {\n+      const TypeInstKlassPtr *tkls = t->isa_instklassptr();\n+      if ((toop != NULL && toop->is_interface()) || (tkls != NULL && tkls->is_interface())) {\n@@ -497,1 +496,1 @@\n-      } else if( toop ) {\n+      } else if (toop) {\n@@ -499,1 +498,1 @@\n-      } else if( tkls ) {\n+      } else if (tkls) {\n","filename":"src\/hotspot\/share\/opto\/idealGraphPrinter.cpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1312,2 +1312,2 @@\n-  BasicType src_elem = src_type->isa_aryptr()->klass()->as_array_klass()->element_type()->basic_type();\n-  BasicType dst_elem = dst_type->isa_aryptr()->klass()->as_array_klass()->element_type()->basic_type();\n+  BasicType src_elem = src_type->isa_aryptr()->elem()->array_element_basic_type();\n+  BasicType dst_elem = dst_type->isa_aryptr()->elem()->array_element_basic_type();\n@@ -2197,0 +2197,1 @@\n+  const TypeOopPtr* result = NULL;\n@@ -2201,2 +2202,3 @@\n-      if (elem_type != NULL) {\n-        sharpened_klass = elem_type->klass();\n+      if (elem_type != NULL && elem_type->is_loaded()) {\n+        \/\/ Sharpen the value type.\n+        result = elem_type;\n@@ -2209,3 +2211,5 @@\n-  if (sharpened_klass != NULL && sharpened_klass->is_loaded()) {\n-    const TypeOopPtr* tjp = TypeOopPtr::make_from_klass(sharpened_klass);\n-\n+  if (result == NULL && sharpened_klass != NULL && sharpened_klass->is_loaded()) {\n+    \/\/ Sharpen the value type.\n+    result = TypeOopPtr::make_from_klass(sharpened_klass);\n+  }\n+  if (result != NULL) {\n@@ -2215,1 +2219,1 @@\n-      tty->print(\"  sharpened value: \");  tjp->dump();      tty->cr();\n+      tty->print(\"  sharpened value: \");  result->dump();    tty->cr();\n@@ -2218,2 +2222,0 @@\n-    \/\/ Sharpen the value type.\n-    return tjp;\n@@ -2221,1 +2223,1 @@\n-  return NULL;\n+  return result;\n@@ -2356,1 +2358,1 @@\n-    if (bt == T_ARRAY || bt == T_NARROWOOP) {\n+    if (is_reference_type(bt, true)) {\n@@ -2736,1 +2738,1 @@\n-  const TypeKlassPtr* klsptr = kls->bottom_type()->isa_klassptr();\n+  const TypeInstKlassPtr* klsptr = kls->bottom_type()->isa_instklassptr();\n@@ -2740,1 +2742,1 @@\n-  ciInstanceKlass* ik = klsptr->klass()->as_instance_klass();\n+  ciInstanceKlass* ik = klsptr->instance_klass();\n@@ -3230,2 +3232,2 @@\n-      tp != NULL && tp->klass() != NULL) {\n-    if (!tp->klass()->is_loaded()) {\n+      tp != NULL) {\n+    if (!tp->is_loaded()) {\n@@ -3235,1 +3237,1 @@\n-      int static_res = C->static_subtype_check(tm->as_klass(), tp->klass());\n+      int static_res = C->static_subtype_check(TypeKlassPtr::make(tm->as_klass()), tp->as_klass_type());\n@@ -3644,2 +3646,2 @@\n-        ciKlass* subk   = _gvn.type(load_object_klass(original))->is_klassptr()->klass();\n-        ciKlass* superk = _gvn.type(klass_node)->is_klassptr()->klass();\n+        const TypeKlassPtr* subk = _gvn.type(load_object_klass(original))->is_klassptr();\n+        const TypeKlassPtr* superk = _gvn.type(klass_node)->is_klassptr();\n@@ -4266,4 +4268,2 @@\n-        ciKlass* k = obj_type->klass();\n-        if (!k->is_instance_klass() ||\n-            k->as_instance_klass()->is_interface() ||\n-            k->as_instance_klass()->has_subklass()) {\n+        if (!obj_type->isa_instptr() ||\n+            obj_type->is_instptr()->instance_klass()->has_subklass()) {\n@@ -4644,1 +4644,1 @@\n-  bool has_src = (top_src != NULL && top_src->klass() != NULL);\n+  bool has_src = (top_src != NULL && top_src->elem() != Type::BOTTOM);\n@@ -4646,1 +4646,1 @@\n-  bool has_dest = (top_dest != NULL && top_dest->klass() != NULL);\n+  bool has_dest = (top_dest != NULL && top_dest->elem() != Type::BOTTOM);\n@@ -4684,1 +4684,1 @@\n-        has_src = (top_src != NULL && top_src->klass() != NULL);\n+        has_src = (top_src != NULL && top_src->elem() != Type::BOTTOM);\n@@ -4691,1 +4691,1 @@\n-        has_dest = (top_dest != NULL && top_dest->klass() != NULL);\n+        has_dest = (top_dest != NULL && top_dest->elem() != Type::BOTTOM);\n@@ -4698,4 +4698,4 @@\n-    BasicType src_elem  = top_src->klass()->as_array_klass()->element_type()->basic_type();\n-    BasicType dest_elem = top_dest->klass()->as_array_klass()->element_type()->basic_type();\n-    if (is_reference_type(src_elem))   src_elem  = T_OBJECT;\n-    if (is_reference_type(dest_elem))  dest_elem = T_OBJECT;\n+    BasicType src_elem = top_src->isa_aryptr()->elem()->array_element_basic_type();\n+    BasicType dest_elem = top_dest->isa_aryptr()->elem()->array_element_basic_type();\n+    if (is_reference_type(src_elem, true)) src_elem = T_OBJECT;\n+    if (is_reference_type(dest_elem, true)) dest_elem = T_OBJECT;\n@@ -4712,2 +4712,2 @@\n-      ciKlass* src_k = top_src->klass();\n-      ciKlass* dest_k = top_dest->klass();\n+      ciKlass* src_k = NULL;\n+      ciKlass* dest_k = NULL;\n@@ -4810,1 +4810,1 @@\n-    const Type *toop = TypeOopPtr::make_from_klass(dest_klass_t->klass());\n+    const Type *toop = dest_klass_t->cast_to_exactness(false)->as_instance_type();\n@@ -4930,2 +4930,2 @@\n-  if (top_src  == NULL || top_src->klass()  == NULL ||\n-      top_dest == NULL || top_dest->klass() == NULL) {\n+  if (top_src  == NULL || top_src->elem()  == Type::BOTTOM ||\n+      top_dest == NULL || top_dest->elem() == Type::BOTTOM) {\n@@ -4937,2 +4937,2 @@\n-  BasicType src_elem = src_type->isa_aryptr()->klass()->as_array_klass()->element_type()->basic_type();\n-  BasicType dst_elem = dst_type->isa_aryptr()->klass()->as_array_klass()->element_type()->basic_type();\n+  BasicType src_elem = src_type->isa_aryptr()->elem()->array_element_basic_type();\n+  BasicType dst_elem = dst_type->isa_aryptr()->elem()->array_element_basic_type();\n@@ -4985,2 +4985,2 @@\n-  if (top_x  == NULL || top_x->klass()  == NULL ||\n-      top_y == NULL || top_y->klass() == NULL) {\n+  if (top_x  == NULL || top_x->elem()  == Type::BOTTOM ||\n+      top_y == NULL || top_y->elem() == Type::BOTTOM) {\n@@ -4991,2 +4991,2 @@\n-  BasicType x_elem = x_type->isa_aryptr()->klass()->as_array_klass()->element_type()->basic_type();\n-  BasicType y_elem = y_type->isa_aryptr()->klass()->as_array_klass()->element_type()->basic_type();\n+  BasicType x_elem = x_type->isa_aryptr()->elem()->array_element_basic_type();\n+  BasicType y_elem = y_type->isa_aryptr()->elem()->array_element_basic_type();\n@@ -5093,2 +5093,2 @@\n-  if (top_x  == NULL || top_x->klass()  == NULL ||\n-      top_z  == NULL || top_z->klass()  == NULL) {\n+  if (top_x  == NULL || top_x->elem()  == Type::BOTTOM ||\n+      top_z  == NULL || top_z->elem()  == Type::BOTTOM) {\n@@ -5099,2 +5099,2 @@\n-  BasicType x_elem = x_type->isa_aryptr()->klass()->as_array_klass()->element_type()->basic_type();\n-  BasicType z_elem = z_type->isa_aryptr()->klass()->as_array_klass()->element_type()->basic_type();\n+  BasicType x_elem = x_type->isa_aryptr()->elem()->array_element_basic_type();\n+  BasicType z_elem = z_type->isa_aryptr()->elem()->array_element_basic_type();\n@@ -5142,2 +5142,2 @@\n-  if (top_out  == NULL || top_out->klass()  == NULL ||\n-      top_in == NULL || top_in->klass() == NULL) {\n+  if (top_out  == NULL || top_out->elem()  == Type::BOTTOM ||\n+      top_in == NULL || top_in->elem() == Type::BOTTOM) {\n@@ -5148,2 +5148,2 @@\n-  BasicType out_elem = out_type->isa_aryptr()->klass()->as_array_klass()->element_type()->basic_type();\n-  BasicType in_elem = in_type->isa_aryptr()->klass()->as_array_klass()->element_type()->basic_type();\n+  BasicType out_elem = out_type->isa_aryptr()->elem()->array_element_basic_type();\n+  BasicType in_elem = in_type->isa_aryptr()->elem()->array_element_basic_type();\n@@ -5195,4 +5195,4 @@\n-  if (top_a  == NULL || top_a->klass()  == NULL ||\n-      top_b == NULL || top_b->klass()  == NULL ||\n-      top_n == NULL || top_n->klass()  == NULL ||\n-      top_m == NULL || top_m->klass()  == NULL) {\n+  if (top_a  == NULL || top_a->elem()  == Type::BOTTOM ||\n+      top_b == NULL || top_b->elem()  == Type::BOTTOM ||\n+      top_n == NULL || top_n->elem()  == Type::BOTTOM ||\n+      top_m == NULL || top_m->elem()  == Type::BOTTOM) {\n@@ -5203,4 +5203,4 @@\n-  BasicType a_elem = a_type->isa_aryptr()->klass()->as_array_klass()->element_type()->basic_type();\n-  BasicType b_elem = b_type->isa_aryptr()->klass()->as_array_klass()->element_type()->basic_type();\n-  BasicType n_elem = n_type->isa_aryptr()->klass()->as_array_klass()->element_type()->basic_type();\n-  BasicType m_elem = m_type->isa_aryptr()->klass()->as_array_klass()->element_type()->basic_type();\n+  BasicType a_elem = a_type->isa_aryptr()->elem()->array_element_basic_type();\n+  BasicType b_elem = b_type->isa_aryptr()->elem()->array_element_basic_type();\n+  BasicType n_elem = n_type->isa_aryptr()->elem()->array_element_basic_type();\n+  BasicType m_elem = m_type->isa_aryptr()->elem()->array_element_basic_type();\n@@ -5252,3 +5252,3 @@\n-  if (top_a  == NULL || top_a->klass()  == NULL ||\n-      top_n == NULL || top_n->klass()  == NULL ||\n-      top_m == NULL || top_m->klass()  == NULL) {\n+  if (top_a  == NULL || top_a->elem()  == Type::BOTTOM ||\n+      top_n == NULL || top_n->elem()  == Type::BOTTOM ||\n+      top_m == NULL || top_m->elem()  == Type::BOTTOM) {\n@@ -5259,3 +5259,3 @@\n-  BasicType a_elem = a_type->isa_aryptr()->klass()->as_array_klass()->element_type()->basic_type();\n-  BasicType n_elem = n_type->isa_aryptr()->klass()->as_array_klass()->element_type()->basic_type();\n-  BasicType m_elem = m_type->isa_aryptr()->klass()->as_array_klass()->element_type()->basic_type();\n+  BasicType a_elem = a_type->isa_aryptr()->elem()->array_element_basic_type();\n+  BasicType n_elem = n_type->isa_aryptr()->elem()->array_element_basic_type();\n+  BasicType m_elem = m_type->isa_aryptr()->elem()->array_element_basic_type();\n@@ -5306,2 +5306,2 @@\n-  if (top_newArr == NULL || top_newArr->klass() == NULL || top_oldArr == NULL\n-      || top_oldArr->klass() == NULL) {\n+  if (top_newArr == NULL || top_newArr->elem() == Type::BOTTOM || top_oldArr == NULL\n+      || top_oldArr->elem() == Type::BOTTOM) {\n@@ -5311,2 +5311,2 @@\n-  BasicType newArr_elem = newArr_type->isa_aryptr()->klass()->as_array_klass()->element_type()->basic_type();\n-  BasicType oldArr_elem = oldArr_type->isa_aryptr()->klass()->as_array_klass()->element_type()->basic_type();\n+  BasicType newArr_elem = newArr_type->isa_aryptr()->elem()->array_element_basic_type();\n+  BasicType oldArr_elem = oldArr_type->isa_aryptr()->elem()->array_element_basic_type();\n@@ -5351,2 +5351,2 @@\n-  if (obja_t == NULL || obja_t->klass() == NULL ||\n-      objb_t == NULL || objb_t->klass() == NULL ||\n+  if (obja_t == NULL || obja_t->elem() == Type::BOTTOM ||\n+      objb_t == NULL || objb_t->elem() == Type::BOTTOM ||\n@@ -5519,1 +5519,1 @@\n-  if (top_src  == NULL || top_src->klass()  == NULL) {\n+  if (top_src  == NULL || top_src->elem()  == Type::BOTTOM) {\n@@ -5525,1 +5525,1 @@\n-  BasicType src_elem = src_type->isa_aryptr()->klass()->as_array_klass()->element_type()->basic_type();\n+  BasicType src_elem = src_type->isa_aryptr()->elem()->array_element_basic_type();\n@@ -5608,1 +5608,1 @@\n-  if (top_src  == NULL || top_src->klass()  == NULL) {\n+  if (top_src  == NULL || top_src->elem()  == Type::BOTTOM) {\n@@ -5614,1 +5614,1 @@\n-  BasicType src_elem = src_type->isa_aryptr()->klass()->as_array_klass()->element_type()->basic_type();\n+  BasicType src_elem = src_type->isa_aryptr()->elem()->array_element_basic_type();\n@@ -5701,1 +5701,1 @@\n-  if (top_src  == NULL || top_src->klass()  == NULL) {\n+  if (top_src  == NULL || top_src->elem()  == Type::BOTTOM) {\n@@ -5707,1 +5707,1 @@\n-  BasicType src_elem = src_type->isa_aryptr()->klass()->as_array_klass()->element_type()->basic_type();\n+  BasicType src_elem = src_type->isa_aryptr()->elem()->array_element_basic_type();\n@@ -5834,2 +5834,2 @@\n-    assert(tinst->klass()->is_loaded(), \"obj is not loaded\");\n-    fromKls = tinst->klass()->as_instance_klass();\n+    assert(tinst->is_loaded(), \"obj is not loaded\");\n+    fromKls = tinst->instance_klass();\n@@ -5883,1 +5883,1 @@\n-    assert(tinst->klass()->is_loaded(), \"obj is not loaded\");\n+    assert(tinst->is_loaded(), \"obj is not loaded\");\n@@ -5885,1 +5885,1 @@\n-    fromKls = tinst->klass()->as_instance_klass();\n+    fromKls = tinst->instance_klass();\n@@ -5945,1 +5945,1 @@\n-  assert (top_src  != NULL && top_src->klass()  != NULL &&  top_dest != NULL && top_dest->klass() != NULL, \"args are strange\");\n+  assert (top_src  != NULL && top_src->elem()  != Type::BOTTOM &&  top_dest != NULL && top_dest->elem() != Type::BOTTOM, \"args are strange\");\n@@ -6006,2 +6006,2 @@\n-  assert (top_src  != NULL && top_src->klass()  != NULL\n-          &&  top_dest != NULL && top_dest->klass() != NULL, \"args are strange\");\n+  assert (top_src  != NULL && top_src->elem()  != Type::BOTTOM\n+          &&  top_dest != NULL && top_dest->elem() != Type::BOTTOM, \"args are strange\");\n@@ -6029,2 +6029,2 @@\n-  assert(tinst->klass()->is_loaded(), \"CBC obj is not loaded\");\n-  ciKlass* klass_AESCrypt = tinst->klass()->as_instance_klass()->find_klass(ciSymbol::make(\"com\/sun\/crypto\/provider\/AESCrypt\"));\n+  assert(tinst->is_loaded(), \"CBC obj is not loaded\");\n+  ciKlass* klass_AESCrypt = tinst->instance_klass()->find_klass(ciSymbol::make(\"com\/sun\/crypto\/provider\/AESCrypt\"));\n@@ -6094,2 +6094,2 @@\n-  assert(top_src != NULL && top_src->klass() != NULL\n-         &&  top_dest != NULL && top_dest->klass() != NULL, \"args are strange\");\n+  assert(top_src != NULL && top_src->elem() != Type::BOTTOM\n+         &&  top_dest != NULL && top_dest->elem() != Type::BOTTOM, \"args are strange\");\n@@ -6117,2 +6117,2 @@\n-  assert(tinst->klass()->is_loaded(), \"ECB obj is not loaded\");\n-  ciKlass* klass_AESCrypt = tinst->klass()->as_instance_klass()->find_klass(ciSymbol::make(\"com\/sun\/crypto\/provider\/AESCrypt\"));\n+  assert(tinst->is_loaded(), \"ECB obj is not loaded\");\n+  ciKlass* klass_AESCrypt = tinst->instance_klass()->find_klass(ciSymbol::make(\"com\/sun\/crypto\/provider\/AESCrypt\"));\n@@ -6168,2 +6168,2 @@\n-  assert(top_src != NULL && top_src->klass() != NULL &&\n-         top_dest != NULL && top_dest->klass() != NULL, \"args are strange\");\n+  assert(top_src != NULL && top_src->elem() != Type::BOTTOM &&\n+         top_dest != NULL && top_dest->elem() != Type::BOTTOM, \"args are strange\");\n@@ -6189,2 +6189,2 @@\n-  assert(tinst->klass()->is_loaded(), \"CTR obj is not loaded\");\n-  ciKlass* klass_AESCrypt = tinst->klass()->as_instance_klass()->find_klass(ciSymbol::make(\"com\/sun\/crypto\/provider\/AESCrypt\"));\n+  assert(tinst->is_loaded(), \"CTR obj is not loaded\");\n+  ciKlass* klass_AESCrypt = tinst->instance_klass()->find_klass(ciSymbol::make(\"com\/sun\/crypto\/provider\/AESCrypt\"));\n@@ -6270,1 +6270,1 @@\n-  assert(tinst->klass()->is_loaded(), \"CBCobj is not loaded\");\n+  assert(tinst->is_loaded(), \"CBCobj is not loaded\");\n@@ -6273,1 +6273,1 @@\n-  ciKlass* klass_AESCrypt = tinst->klass()->as_instance_klass()->find_klass(ciSymbol::make(\"com\/sun\/crypto\/provider\/AESCrypt\"));\n+  ciKlass* klass_AESCrypt = tinst->instance_klass()->find_klass(ciSymbol::make(\"com\/sun\/crypto\/provider\/AESCrypt\"));\n@@ -6333,1 +6333,1 @@\n-  assert(tinst->klass()->is_loaded(), \"ECBobj is not loaded\");\n+  assert(tinst->is_loaded(), \"ECBobj is not loaded\");\n@@ -6336,1 +6336,1 @@\n-  ciKlass* klass_AESCrypt = tinst->klass()->as_instance_klass()->find_klass(ciSymbol::make(\"com\/sun\/crypto\/provider\/AESCrypt\"));\n+  ciKlass* klass_AESCrypt = tinst->instance_klass()->find_klass(ciSymbol::make(\"com\/sun\/crypto\/provider\/AESCrypt\"));\n@@ -6393,1 +6393,1 @@\n-  assert(tinst->klass()->is_loaded(), \"CTRobj is not loaded\");\n+  assert(tinst->is_loaded(), \"CTRobj is not loaded\");\n@@ -6396,1 +6396,1 @@\n-  ciKlass* klass_AESCrypt = tinst->klass()->as_instance_klass()->find_klass(ciSymbol::make(\"com\/sun\/crypto\/provider\/AESCrypt\"));\n+  ciKlass* klass_AESCrypt = tinst->instance_klass()->find_klass(ciSymbol::make(\"com\/sun\/crypto\/provider\/AESCrypt\"));\n@@ -6539,1 +6539,1 @@\n-  if (top_src  == NULL || top_src->klass()  == NULL) {\n+  if (top_src  == NULL || top_src->elem()  == Type::BOTTOM) {\n@@ -6544,1 +6544,1 @@\n-  BasicType src_elem = src_type->isa_aryptr()->klass()->as_array_klass()->element_type()->basic_type();\n+  BasicType src_elem = src_type->isa_aryptr()->elem()->array_element_basic_type();\n@@ -6631,1 +6631,1 @@\n-  if (top_src  == NULL || top_src->klass()  == NULL) {\n+  if (top_src  == NULL || top_src->elem()  == Type::BOTTOM) {\n@@ -6636,1 +6636,1 @@\n-  BasicType src_elem = src_type->isa_aryptr()->klass()->as_array_klass()->element_type()->basic_type();\n+  BasicType src_elem = src_type->isa_aryptr()->elem()->array_element_basic_type();\n@@ -6697,1 +6697,1 @@\n-    assert(tinst->klass()->is_loaded(), \"DigestBase is not loaded\");\n+    assert(tinst->is_loaded(), \"DigestBase is not loaded\");\n@@ -6699,1 +6699,1 @@\n-    ciKlass* klass_digestBase = tinst->klass()->as_instance_klass()->find_klass(ciSymbol::make(klass_digestBase_name));\n+    ciKlass* klass_digestBase = tinst->instance_klass()->find_klass(ciSymbol::make(klass_digestBase_name));\n@@ -6773,3 +6773,3 @@\n-  assert(top_in != NULL && top_in->klass() != NULL &&\n-         top_ct != NULL && top_ct->klass() != NULL &&\n-         top_out != NULL && top_out->klass() != NULL, \"args are strange\");\n+  assert(top_in != NULL && top_in->elem() != Type::BOTTOM &&\n+         top_ct != NULL && top_ct->elem() != Type::BOTTOM &&\n+         top_out != NULL && top_out->elem() != Type::BOTTOM, \"args are strange\");\n@@ -6803,2 +6803,2 @@\n-  assert(tinst->klass()->is_loaded(), \"GCTR obj is not loaded\");\n-  ciKlass* klass_AESCrypt = tinst->klass()->as_instance_klass()->find_klass(ciSymbol::make(\"com\/sun\/crypto\/provider\/AESCrypt\"));\n+  assert(tinst->is_loaded(), \"GCTR obj is not loaded\");\n+  ciKlass* klass_AESCrypt = tinst->instance_klass()->find_klass(ciSymbol::make(\"com\/sun\/crypto\/provider\/AESCrypt\"));\n@@ -6855,1 +6855,1 @@\n-  assert(tinst->klass()->is_loaded(), \"GCTR obj is not loaded\");\n+  assert(tinst->is_loaded(), \"GCTR obj is not loaded\");\n@@ -6858,1 +6858,1 @@\n-  ciKlass* klass_AESCrypt = tinst->klass()->as_instance_klass()->find_klass(ciSymbol::make(\"com\/sun\/crypto\/provider\/AESCrypt\"));\n+  ciKlass* klass_AESCrypt = tinst->instance_klass()->find_klass(ciSymbol::make(\"com\/sun\/crypto\/provider\/AESCrypt\"));\n@@ -6909,1 +6909,1 @@\n-  assert(tinst->klass()->is_loaded(), \"DigestBase is not loaded\");\n+  assert(tinst->is_loaded(), \"DigestBase is not loaded\");\n@@ -6949,1 +6949,1 @@\n-    klass = tinst->klass()->as_instance_klass()->find_klass(ciSymbol::make(klass_name));\n+    klass = tinst->instance_klass()->find_klass(ciSymbol::make(klass_name));\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":114,"deletions":114,"binary":false,"changes":228,"status":"modified"},{"patch":"@@ -680,1 +680,0 @@\n-  ciKlass* klass = NULL;\n@@ -686,1 +685,1 @@\n-  ciType* elem_type = NULL;\n+  const Type* field_type = NULL;\n@@ -696,1 +695,0 @@\n-    klass = res_type->klass();\n@@ -699,2 +697,1 @@\n-      assert(klass->is_instance_klass(), \"must be an instance klass.\");\n-      iklass = klass->as_instance_klass();\n+      iklass = res_type->is_instptr()->instance_klass();\n@@ -705,3 +702,2 @@\n-      assert(klass->is_array_klass() && nfields >= 0, \"must be an array klass.\");\n-      elem_type = klass->as_array_klass()->element_type();\n-      basic_elem_type = elem_type->basic_type();\n+      assert(nfields >= 0, \"must be an array klass.\");\n+      basic_elem_type = res_type->is_aryptr()->elem()->array_element_basic_type();\n@@ -710,0 +706,1 @@\n+      field_type = res_type->is_aryptr()->elem();\n@@ -739,1 +736,1 @@\n-        elem_type = field->type();\n+        ciType* elem_type = field->type();\n@@ -741,3 +738,0 @@\n-      } else {\n-        offset = array_base + j * (intptr_t)element_size;\n-      }\n@@ -745,12 +739,17 @@\n-      const Type *field_type;\n-      \/\/ The next code is taken from Parse::do_get_xxx().\n-      if (is_reference_type(basic_elem_type)) {\n-        if (!elem_type->is_loaded()) {\n-          field_type = TypeInstPtr::BOTTOM;\n-        } else if (field != NULL && field->is_static_constant()) {\n-          \/\/ This can happen if the constant oop is non-perm.\n-          ciObject* con = field->constant_value().as_object();\n-          \/\/ Do not \"join\" in the previous type; it doesn't add value,\n-          \/\/ and may yield a vacuous result if the field is of interface type.\n-          field_type = TypeOopPtr::make_from_constant(con)->isa_oopptr();\n-          assert(field_type != NULL, \"field singleton type must be consistent\");\n+        \/\/ The next code is taken from Parse::do_get_xxx().\n+        if (is_reference_type(basic_elem_type)) {\n+          if (!elem_type->is_loaded()) {\n+            field_type = TypeInstPtr::BOTTOM;\n+          } else if (field != NULL && field->is_static_constant()) {\n+            ciObject* con = field->constant_value().as_object();\n+            \/\/ Do not \"join\" in the previous type; it doesn't add value,\n+            \/\/ and may yield a vacuous result if the field is of interface type.\n+            field_type = TypeOopPtr::make_from_constant(con)->isa_oopptr();\n+            assert(field_type != NULL, \"field singleton type must be consistent\");\n+          } else {\n+            field_type = TypeOopPtr::make_from_klass(elem_type->as_klass());\n+          }\n+          if (UseCompressedOops) {\n+            field_type = field_type->make_narrowoop();\n+            basic_elem_type = T_NARROWOOP;\n+          }\n@@ -758,5 +757,1 @@\n-          field_type = TypeOopPtr::make_from_klass(elem_type->as_klass());\n-        }\n-        if (UseCompressedOops) {\n-          field_type = field_type->make_narrowoop();\n-          basic_elem_type = T_NARROWOOP;\n+          field_type = Type::get_const_basic_type(basic_elem_type);\n@@ -765,1 +760,1 @@\n-        field_type = Type::get_const_basic_type(basic_elem_type);\n+        offset = array_base + j * (intptr_t)element_size;\n@@ -1026,2 +1021,2 @@\n-                      tklass->klass()->is_instance_klass()  &&\n-                      tklass->klass()->as_instance_klass()->is_box_klass();\n+                      tklass->isa_instklassptr() &&\n+                      tklass->is_instklassptr()->instance_klass()->is_box_klass();\n@@ -1056,1 +1051,1 @@\n-              log->identify(tklass->klass()));\n+              log->identify(tklass->exact_klass()));\n@@ -1097,1 +1092,1 @@\n-              log->identify(t->klass()));\n+              log->identify(t->instance_klass()));\n@@ -1691,3 +1686,7 @@\n-    ciKlass* k = _igvn.type(klass_node)->is_klassptr()->klass();\n-    if (k->is_array_klass())    \/\/ we know the exact header size in most cases:\n-      header_size = Klass::layout_helper_header_size(k->layout_helper());\n+    if (_igvn.type(klass_node)->isa_aryklassptr()) {   \/\/ we know the exact header size in most cases:\n+      BasicType elem = _igvn.type(klass_node)->is_klassptr()->as_instance_type()->isa_aryptr()->elem()->array_element_basic_type();\n+      if (is_reference_type(elem, true)) {\n+        elem = T_OBJECT;\n+      }\n+      header_size = Klass::layout_helper_header_size(Klass::array_layout_helper(elem));\n+    }\n@@ -1893,1 +1892,1 @@\n-  ciKlass* k = _igvn.type(klass_node)->is_klassptr()->klass();\n+  const TypeAryKlassPtr* ary_klass_t = _igvn.type(klass_node)->isa_aryklassptr();\n@@ -1896,1 +1895,1 @@\n-      k->is_type_array_klass()) {\n+      ary_klass_t && ary_klass_t->elem()->isa_klassptr() == NULL) {\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":38,"deletions":39,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -1295,2 +1295,2 @@\n-  if (top_dest != NULL && top_dest->klass() != NULL) {\n-    dest_elem = top_dest->klass()->as_array_klass()->element_type()->basic_type();\n+  if (top_src != NULL && top_src->elem() != Type::BOTTOM) {\n+    src_elem = top_src->elem()->array_element_basic_type();\n@@ -1298,2 +1298,2 @@\n-  if (top_src != NULL && top_src->klass() != NULL) {\n-    src_elem = top_src->klass()->as_array_klass()->element_type()->basic_type();\n+  if (top_dest != NULL && top_dest->elem() != Type::BOTTOM) {\n+    dest_elem = top_dest->elem()->array_element_basic_type();\n@@ -1301,2 +1301,2 @@\n-  if (is_reference_type(src_elem))  src_elem  = T_OBJECT;\n-  if (is_reference_type(dest_elem)) dest_elem = T_OBJECT;\n+  if (is_reference_type(src_elem, true)) src_elem = T_OBJECT;\n+  if (is_reference_type(dest_elem, true)) dest_elem = T_OBJECT;\n","filename":"src\/hotspot\/share\/opto\/macroArrayCopy.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -180,1 +180,1 @@\n-          if (tklass->klass_is_exact() && !tklass->klass()->equals(t_oop->klass())) {\n+          if (tklass->klass_is_exact() && !tklass->exact_klass()->equals(t_oop->is_instptr()->exact_klass())) {\n@@ -268,1 +268,1 @@\n-  if( tp->base() != Type::AnyPtr &&\n+  if (tp->base() != Type::AnyPtr &&\n@@ -270,3 +270,3 @@\n-        toop->klass() != NULL &&\n-        toop->klass()->is_java_lang_Object() &&\n-        toop->offset() == Type::OffsetBot) ) {\n+        toop->isa_instptr() &&\n+        toop->is_instptr()->instance_klass()->is_java_lang_Object() &&\n+        toop->offset() == Type::OffsetBot)) {\n@@ -553,1 +553,1 @@\n-      BasicType ary_elem = ary_t->klass()->as_array_klass()->element_type()->basic_type();\n+      BasicType ary_elem = ary_t->elem()->array_element_basic_type();\n@@ -1018,1 +1018,3 @@\n-      BasicType ary_elem  = ary_t->klass()->as_array_klass()->element_type()->basic_type();\n+      BasicType ary_elem = ary_t->isa_aryptr()->elem()->array_element_basic_type();\n+      if (is_reference_type(ary_elem, true)) ary_elem = T_OBJECT;\n+\n@@ -1961,1 +1963,2 @@\n-            tp->is_oopptr()->klass()->is_java_lang_Object() ||\n+            !tp->isa_instptr() ||\n+            tp->is_instptr()->instance_klass()->is_java_lang_Object() ||\n@@ -1977,7 +1980,8 @@\n-    assert( off != Type::OffsetBot ||\n-            \/\/ arrays can be cast to Objects\n-            tp->is_klassptr()->klass()->is_java_lang_Object() ||\n-            \/\/ also allow array-loading from the primary supertype\n-            \/\/ array during subtype checks\n-            Opcode() == Op_LoadKlass,\n-            \"Field accesses must be precise\" );\n+    assert(off != Type::OffsetBot ||\n+            !tp->isa_instklassptr() ||\n+           \/\/ arrays can be cast to Objects\n+           tp->isa_instklassptr()->instance_klass()->is_java_lang_Object() ||\n+           \/\/ also allow array-loading from the primary supertype\n+           \/\/ array during subtype checks\n+           Opcode() == Op_LoadKlass,\n+           \"Field accesses must be precise\");\n@@ -1995,2 +1999,2 @@\n-      ciKlass* klass = tkls->klass();\n-      if (klass->is_loaded() && tkls->klass_is_exact() && tkls->offset() == in_bytes(Klass::java_mirror_offset())) {\n+      if (tkls->is_loaded() && tkls->klass_is_exact() && tkls->offset() == in_bytes(Klass::java_mirror_offset())) {\n+        ciKlass* klass = tkls->exact_klass();\n@@ -2006,2 +2010,2 @@\n-    ciKlass* klass = tkls->klass();\n-    if (klass->is_loaded() && tkls->klass_is_exact()) {\n+    if (tkls->is_loaded() && tkls->klass_is_exact()) {\n+      ciKlass* klass = tkls->exact_klass();\n@@ -2034,6 +2038,13 @@\n-    if (klass->is_loaded() ) {\n-      ciType *inner = klass;\n-      while( inner->is_obj_array_klass() )\n-        inner = inner->as_obj_array_klass()->base_element_type();\n-      if( inner->is_instance_klass() &&\n-          !inner->as_instance_klass()->flags().is_interface() ) {\n+    if (tkls->is_loaded()) {\n+      ciKlass* klass = NULL;\n+      if (tkls->isa_instklassptr()) {\n+        klass = tkls->is_instklassptr()->instance_klass();\n+      } else {\n+        int dims;\n+        const Type* inner = tkls->is_aryklassptr()->base_element_type(dims);\n+        if (inner->isa_instklassptr()) {\n+          klass = inner->is_instklassptr()->instance_klass();\n+          klass = ciObjArrayKlass::make(klass, dims);\n+        }\n+      }\n+      if (klass != NULL) {\n@@ -2043,2 +2054,2 @@\n-        if( depth < ciKlass::primary_super_limit() &&\n-            depth <= klass->super_depth() ) { \/\/ allow self-depth checks to handle self-check case\n+        if (depth < ciKlass::primary_super_limit() &&\n+            depth <= klass->super_depth()) { \/\/ allow self-depth checks to handle self-check case\n@@ -2057,4 +2068,3 @@\n-    if (tkls->offset() == in_bytes(Klass::layout_helper_offset())\n-        && !klass->is_array_klass() \/\/ not directly typed as an array\n-        && !klass->is_interface()  \/\/ specifically not Serializable & Cloneable\n-        && !klass->is_java_lang_Object()   \/\/ not the supertype of all T[]\n+    if (tkls->offset() == in_bytes(Klass::layout_helper_offset()) &&\n+        tkls->isa_instklassptr() && \/\/ not directly typed as an array\n+        !tkls->is_instklassptr()->instance_klass()->is_java_lang_Object() \/\/ not the supertype of all T[] and specifically not Serializable & Cloneable\n@@ -2293,1 +2303,1 @@\n-    ciInstanceKlass* ik = tinst->klass()->as_instance_klass();\n+    ciInstanceKlass* ik = tinst->instance_klass();\n@@ -2321,1 +2331,1 @@\n-    if( !ik->is_loaded() )\n+    if (!tinst->is_loaded())\n@@ -2324,17 +2334,1 @@\n-      if (tinst->klass_is_exact()) {\n-        return TypeKlassPtr::make(ik);\n-      }\n-      \/\/ See if we can become precise: no subklasses and no interface\n-      \/\/ (Note:  We need to support verified interfaces.)\n-      if (!ik->is_interface() && !ik->has_subklass()) {\n-        \/\/ Add a dependence; if any subclass added we need to recompile\n-        if (!ik->is_final()) {\n-          \/\/ %%% should use stronger assert_unique_concrete_subtype instead\n-          phase->C->dependencies()->assert_leaf_type(ik);\n-        }\n-        \/\/ Return precise klass\n-        return TypeKlassPtr::make(ik);\n-      }\n-\n-      \/\/ Return root of possible klass\n-      return TypeKlassPtr::make(TypePtr::NotNull, ik, 0\/*offset*\/);\n+      return tinst->as_klass_type(true);\n@@ -2346,31 +2340,3 @@\n-  if( tary != NULL ) {\n-    ciKlass *tary_klass = tary->klass();\n-    if (tary_klass != NULL   \/\/ can be NULL when at BOTTOM or TOP\n-        && tary->offset() == oopDesc::klass_offset_in_bytes()) {\n-      if (tary->klass_is_exact()) {\n-        return TypeKlassPtr::make(tary_klass);\n-      }\n-      ciArrayKlass *ak = tary->klass()->as_array_klass();\n-      \/\/ If the klass is an object array, we defer the question to the\n-      \/\/ array component klass.\n-      if( ak->is_obj_array_klass() ) {\n-        assert( ak->is_loaded(), \"\" );\n-        ciKlass *base_k = ak->as_obj_array_klass()->base_element_klass();\n-        if( base_k->is_loaded() && base_k->is_instance_klass() ) {\n-          ciInstanceKlass* ik = base_k->as_instance_klass();\n-          \/\/ See if we can become precise: no subklasses and no interface\n-          if (!ik->is_interface() && !ik->has_subklass()) {\n-            \/\/ Add a dependence; if any subclass added we need to recompile\n-            if (!ik->is_final()) {\n-              phase->C->dependencies()->assert_leaf_type(ik);\n-            }\n-            \/\/ Return precise array klass\n-            return TypeKlassPtr::make(ak);\n-          }\n-        }\n-        return TypeKlassPtr::make(TypePtr::NotNull, ak, 0\/*offset*\/);\n-      } else {                  \/\/ Found a type-array?\n-        assert( ak->is_type_array_klass(), \"\" );\n-        return TypeKlassPtr::make(ak); \/\/ These are always precise\n-      }\n-    }\n+  if (tary != NULL && tary->elem() != Type::BOTTOM &&\n+      tary->offset() == oopDesc::klass_offset_in_bytes()) {\n+    return tary->as_klass_type(true);\n@@ -2382,4 +2348,3 @@\n-    ciKlass* klass = tkls->klass();\n-    if( !klass->is_loaded() )\n-      return _type;             \/\/ Bail out if not loaded\n-    if( klass->is_obj_array_klass() &&\n+    if (!tkls->is_loaded())\n+     return _type;             \/\/ Bail out if not loaded\n+    if (tkls->isa_aryklassptr() && tkls->is_aryklassptr()->elem()->isa_klassptr() &&\n@@ -2387,1 +2352,0 @@\n-      ciKlass* elem = klass->as_obj_array_klass()->element_klass();\n@@ -2394,1 +2358,1 @@\n-      return TypeKlassPtr::make(tkls->ptr(), elem, 0\/*offset*\/);\n+      return tkls->is_aryklassptr()->elem();\n@@ -2396,1 +2360,1 @@\n-    if( klass->is_instance_klass() && tkls->klass_is_exact() &&\n+    if (tkls->isa_instklassptr() != NULL && tkls->klass_is_exact() &&\n@@ -2398,1 +2362,1 @@\n-      ciKlass* sup = klass->as_instance_klass()->super();\n+      ciKlass* sup = tkls->is_instklassptr()->instance_klass()->super();\n@@ -2453,1 +2417,1 @@\n-  if (toop->isa_instptr() && toop->klass() == phase->C->env()->Class_klass()\n+  if (toop->isa_instptr() && toop->is_instptr()->instance_klass() == phase->C->env()->Class_klass()\n@@ -2461,2 +2425,1 @@\n-            && (tkls->klass()->is_instance_klass() ||\n-              tkls->klass()->is_array_klass())\n+            && (tkls->isa_instklassptr() || tkls->isa_aryklassptr())\n@@ -4526,1 +4489,1 @@\n-        ciKlass* k = phase->type(klass_node)->is_klassptr()->klass();\n+        ciKlass* k = phase->type(klass_node)->is_instklassptr()->instance_klass();\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":56,"deletions":93,"binary":false,"changes":149,"status":"modified"},{"patch":"@@ -1791,1 +1791,1 @@\n-  if (t != NULL && (t->isa_instptr() || t->isa_klassptr())) {\n+  if (t != NULL && (t->isa_instptr() || t->isa_instklassptr())) {\n@@ -1793,3 +1793,3 @@\n-    const TypeKlassPtr *tkls = t->isa_klassptr();\n-    ciKlass*           klass = toop ? toop->klass() : (tkls ? tkls->klass() : NULL );\n-    if (klass && klass->is_loaded() && klass->is_interface()) {\n+    const TypeInstKlassPtr *tkls = t->isa_instklassptr();\n+    ciKlass*           klass = toop ? toop->instance_klass() : (tkls ? tkls->instance_klass() : NULL );\n+    if (klass && klass->is_loaded() && ((toop && toop->is_interface()) || (tkls && tkls->is_interface()))) {\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -817,1 +817,1 @@\n-      ciKlass* cik = t->is_oopptr()->klass();\n+      ciKlass* cik = t->is_oopptr()->exact_klass();\n@@ -1091,1 +1091,1 @@\n-          ciKlass* cik = t->is_oopptr()->klass();\n+          ciKlass* cik = t->is_oopptr()->exact_klass();\n","filename":"src\/hotspot\/share\/opto\/output.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -155,1 +155,1 @@\n-      (tp != NULL && !tp->klass()->is_loaded())) {\n+      (tp != NULL && !tp->is_loaded())) {\n@@ -171,1 +171,1 @@\n-  if (tp != NULL && tp->klass() != C->env()->Object_klass()) {\n+  if (tp != NULL && !tp->is_same_java_type_as(TypeInstPtr::BOTTOM)) {\n@@ -174,1 +174,1 @@\n-    l = gen_checkcast(l, makecon(TypeKlassPtr::make(tp->klass())), &bad_type_ctrl);\n+    l = gen_checkcast(l, makecon(tp->as_klass_type()->cast_to_exactness(true)), &bad_type_ctrl);\n@@ -796,1 +796,1 @@\n-    if (ret_oop_type && !ret_oop_type->klass()->is_loaded()) {\n+    if (ret_oop_type && !ret_oop_type->is_loaded()) {\n@@ -2063,1 +2063,1 @@\n-  if (tinst != NULL && tinst->klass()->is_loaded() && !tinst->klass_is_exact()) {\n+  if (tinst != NULL && tinst->is_loaded() && !tinst->klass_is_exact()) {\n@@ -2065,1 +2065,1 @@\n-    ciInstanceKlass* ik = tinst->klass()->as_instance_klass();\n+    ciInstanceKlass* ik = tinst->instance_klass();\n@@ -2238,2 +2238,2 @@\n-    if (tr && tr->klass()->is_loaded() &&\n-        tr->klass()->is_interface()) {\n+    if (tr && tr->is_loaded() &&\n+        tr->is_interface()) {\n@@ -2241,2 +2241,2 @@\n-      if (tp && tp->klass()->is_loaded() &&\n-          !tp->klass()->is_interface()) {\n+      if (tp && tp->is_loaded() &&\n+          !tp->is_interface()) {\n@@ -2253,2 +2253,2 @@\n-      if (phi_tip != NULL && phi_tip->is_loaded() && phi_tip->klass()->is_interface() &&\n-          val_tip != NULL && val_tip->is_loaded() && !val_tip->klass()->is_interface()) {\n+      if (phi_tip != NULL && phi_tip->is_loaded() && phi_tip->is_interface() &&\n+          val_tip != NULL && val_tip->is_loaded() && !val_tip->is_interface()) {\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -127,1 +127,1 @@\n-      if (toop->klass()->as_instance_klass()->unique_concrete_subklass()) {\n+      if (toop->instance_klass()->unique_concrete_subklass()) {\n@@ -129,1 +129,1 @@\n-        const Type* subklass = Type::get_const_type(toop->klass());\n+        const Type* subklass = Type::get_const_type(toop->instance_klass());\n@@ -146,2 +146,1 @@\n-  ciKlass * arytype_klass = arytype->klass();\n-  if ((arytype_klass != NULL) && (!arytype_klass->is_loaded())) {\n+  if (!arytype->is_loaded()) {\n@@ -150,0 +149,2 @@\n+    ciKlass* klass = arytype->unloaded_klass();\n+\n@@ -152,1 +153,1 @@\n-                  arytype->klass(), \"!loaded array\");\n+                  klass, \"!loaded array\");\n@@ -197,1 +198,1 @@\n-        builtin_throw(Deoptimization::Reason_range_check, idx);\n+        builtin_throw(Deoptimization::Reason_range_check);\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-  if (!will_link || (tp && tp->klass() && !tp->klass()->is_loaded())) {\n+  if (!will_link || (tp && !tp->is_loaded())) {\n@@ -81,1 +81,1 @@\n-      if (tp && tp->klass() && !tp->klass()->is_loaded()) {\n+      if (tp && !tp->is_loaded()) {\n@@ -83,0 +83,1 @@\n+        ciKlass* klass = tp->unloaded_klass();\n@@ -84,1 +85,1 @@\n-                       C->log()->identify(tp->klass()));\n+                       C->log()->identify(klass));\n@@ -197,19 +198,23 @@\n-    const TypeKlassPtr *extak = tak->cast_to_exactness(true)->is_klassptr();\n-    Node* con = makecon(extak);\n-    Node* cmp = _gvn.transform(new CmpPNode( array_klass, con ));\n-    Node* bol = _gvn.transform(new BoolNode( cmp, BoolTest::eq ));\n-    Node* ctrl= control();\n-    { BuildCutout unless(this, bol, PROB_MAX);\n-      uncommon_trap(Deoptimization::Reason_array_check,\n-                    Deoptimization::Action_maybe_recompile,\n-                    tak->klass());\n-    }\n-    if (stopped()) {          \/\/ MUST uncommon-trap?\n-      set_control(ctrl);      \/\/ Then Don't Do It, just fall into the normal checking\n-    } else {                  \/\/ Cast array klass to exactness:\n-      \/\/ Use the exact constant value we know it is.\n-      replace_in_map(array_klass,con);\n-      CompileLog* log = C->log();\n-      if (log != NULL) {\n-        log->elem(\"cast_up reason='monomorphic_array' from='%d' to='(exact)'\",\n-                  log->identify(tak->klass()));\n+    const TypeKlassPtr *extak = tak->cast_to_exactness(true);\n+\n+    if (extak->exact_klass(true) != NULL) {\n+      Node* con = makecon(extak);\n+      Node* cmp = _gvn.transform(new CmpPNode( array_klass, con ));\n+      Node* bol = _gvn.transform(new BoolNode( cmp, BoolTest::eq ));\n+      Node* ctrl= control();\n+      { BuildCutout unless(this, bol, PROB_MAX);\n+        uncommon_trap(Deoptimization::Reason_array_check,\n+                      Deoptimization::Action_maybe_recompile,\n+                      extak->exact_klass());\n+      }\n+      if (stopped()) {          \/\/ MUST uncommon-trap?\n+        set_control(ctrl);      \/\/ Then Don't Do It, just fall into the normal checking\n+      } else {                  \/\/ Cast array klass to exactness:\n+        \/\/ Use the exact constant value we know it is.\n+        replace_in_map(array_klass,con);\n+        CompileLog* log = C->log();\n+        if (log != NULL) {\n+          log->elem(\"cast_up reason='monomorphic_array' from='%d' to='(exact)'\",\n+                    log->identify(extak->exact_klass()));\n+        }\n+        array_klass = con;      \/\/ Use cast value moving forward\n@@ -217,1 +222,0 @@\n-      array_klass = con;      \/\/ Use cast value moving forward\n@@ -301,1 +305,0 @@\n-\n","filename":"src\/hotspot\/share\/opto\/parseHelper.cpp","additions":27,"deletions":24,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -969,30 +969,13 @@\n-  const TypeOopPtr* oop_p0 = r0->isa_oopptr();\n-  const TypeOopPtr* oop_p1 = r1->isa_oopptr();\n-  bool both_oop_ptr = oop_p0 && oop_p1;\n-\n-  if (both_oop_ptr) {\n-    Node* in1 = in(1)->uncast();\n-    Node* in2 = in(2)->uncast();\n-    AllocateNode* alloc1 = AllocateNode::Ideal_allocation(in1, NULL);\n-    AllocateNode* alloc2 = AllocateNode::Ideal_allocation(in2, NULL);\n-    if (MemNode::detect_ptr_independence(in1, alloc1, in2, alloc2, NULL)) {\n-      return TypeInt::CC_GT;  \/\/ different pointers\n-    }\n-  }\n-\n-  const TypeKlassPtr* klass_p0 = r0->isa_klassptr();\n-  const TypeKlassPtr* klass_p1 = r1->isa_klassptr();\n-\n-  if (both_oop_ptr || (klass_p0 && klass_p1)) { \/\/ both or neither are klass pointers\n-    ciKlass* klass0 = NULL;\n-    bool    xklass0 = false;\n-    ciKlass* klass1 = NULL;\n-    bool    xklass1 = false;\n-\n-    if (oop_p0) {\n-      klass0 = oop_p0->klass();\n-      xklass0 = oop_p0->klass_is_exact();\n-    } else {\n-      assert(klass_p0, \"must be non-null if oop_p0 is null\");\n-      klass0 = klass_p0->klass();\n-      xklass0 = klass_p0->klass_is_exact();\n+  const TypeOopPtr* p0 = r0->isa_oopptr();\n+  const TypeOopPtr* p1 = r1->isa_oopptr();\n+  const TypeKlassPtr* k0 = r0->isa_klassptr();\n+  const TypeKlassPtr* k1 = r1->isa_klassptr();\n+  if ((p0 && p1) || (k0 && k1)) {\n+    if (p0 && p1) {\n+      Node* in1 = in(1)->uncast();\n+      Node* in2 = in(2)->uncast();\n+      AllocateNode* alloc1 = AllocateNode::Ideal_allocation(in1, NULL);\n+      AllocateNode* alloc2 = AllocateNode::Ideal_allocation(in2, NULL);\n+      if (MemNode::detect_ptr_independence(in1, alloc1, in2, alloc2, NULL)) {\n+        return TypeInt::CC_GT;  \/\/ different pointers\n+      }\n@@ -1000,8 +983,15 @@\n-\n-    if (oop_p1) {\n-      klass1 = oop_p1->klass();\n-      xklass1 = oop_p1->klass_is_exact();\n-    } else {\n-      assert(klass_p1, \"must be non-null if oop_p1 is null\");\n-      klass1 = klass_p1->klass();\n-      xklass1 = klass_p1->klass_is_exact();\n+    bool    xklass0 = p0 ? p0->klass_is_exact() : k0->klass_is_exact();\n+    bool    xklass1 = p1 ? p1->klass_is_exact() : k1->klass_is_exact();\n+    bool unrelated_classes = false;\n+\n+    if ((p0 && p0->is_same_java_type_as(p1)) ||\n+        (k0 && k0->is_same_java_type_as(k1))) {\n+    } else if ((p0 && !p1->maybe_java_subtype_of(p0) && !p0->maybe_java_subtype_of(p1)) ||\n+               (k0 && !k1->maybe_java_subtype_of(k0) && !k0->maybe_java_subtype_of(k1))) {\n+      unrelated_classes = true;\n+    } else if ((p0 && !p1->maybe_java_subtype_of(p0)) ||\n+               (k0 && !k1->maybe_java_subtype_of(k0))) {\n+      unrelated_classes = xklass1;\n+    } else if ((p0 && !p0->maybe_java_subtype_of(p1)) ||\n+               (k0 && !k0->maybe_java_subtype_of(k1))) {\n+      unrelated_classes = xklass0;\n@@ -1010,30 +1000,7 @@\n-    if (klass0 && klass1 &&\n-        klass0->is_loaded() && !klass0->is_interface() && \/\/ do not trust interfaces\n-        klass1->is_loaded() && !klass1->is_interface() &&\n-        (!klass0->is_obj_array_klass() ||\n-         !klass0->as_obj_array_klass()->base_element_klass()->is_interface()) &&\n-        (!klass1->is_obj_array_klass() ||\n-         !klass1->as_obj_array_klass()->base_element_klass()->is_interface())) {\n-      bool unrelated_classes = false;\n-      \/\/ See if neither subclasses the other, or if the class on top\n-      \/\/ is precise.  In either of these cases, the compare is known\n-      \/\/ to fail if at least one of the pointers is provably not null.\n-      if (klass0->equals(klass1)) {  \/\/ if types are unequal but klasses are equal\n-        \/\/ Do nothing; we know nothing for imprecise types\n-      } else if (klass0->is_subtype_of(klass1)) {\n-        \/\/ If klass1's type is PRECISE, then classes are unrelated.\n-        unrelated_classes = xklass1;\n-      } else if (klass1->is_subtype_of(klass0)) {\n-        \/\/ If klass0's type is PRECISE, then classes are unrelated.\n-        unrelated_classes = xklass0;\n-      } else {                  \/\/ Neither subtypes the other\n-        unrelated_classes = true;\n-      }\n-      if (unrelated_classes) {\n-        \/\/ The oops classes are known to be unrelated. If the joined PTRs of\n-        \/\/ two oops is not Null and not Bottom, then we are sure that one\n-        \/\/ of the two oops is non-null, and the comparison will always fail.\n-        TypePtr::PTR jp = r0->join_ptr(r1->_ptr);\n-        if (jp != TypePtr::Null && jp != TypePtr::BotPTR) {\n-          return TypeInt::CC_GT;\n-        }\n+    if (unrelated_classes) {\n+      \/\/ The oops classes are known to be unrelated. If the joined PTRs of\n+      \/\/ two oops is not Null and not Bottom, then we are sure that one\n+      \/\/ of the two oops is non-null, and the comparison will always fail.\n+      TypePtr::PTR jp = r0->join_ptr(r1->_ptr);\n+      if (jp != TypePtr::Null && jp != TypePtr::BotPTR) {\n+        return TypeInt::CC_GT;\n@@ -1069,1 +1036,1 @@\n-  if (!tp || tp->klass() != phase->C->env()->Class_klass()) return NULL;\n+  if (!tp || tp->instance_klass() != phase->C->env()->Class_klass()) return NULL;\n@@ -1149,1 +1116,1 @@\n-  ciKlass* superklass = t2->klass();\n+  ciKlass* superklass = t2->exact_klass();\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":37,"deletions":70,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -36,5 +36,2 @@\n-  ciKlass* superk = super_t->is_klassptr()->klass();\n-  ciKlass* subk   = sub_t->isa_klassptr() ? sub_t->is_klassptr()->klass() : sub_t->is_oopptr()->klass();\n-\n-  bool xsubk = sub_t->isa_klassptr() ? sub_t->is_klassptr()->klass_is_exact() : sub_t->is_oopptr()->klass_is_exact();\n-\n+  const TypeKlassPtr* superk = super_t->isa_klassptr();\n+  const TypeKlassPtr* subk = sub_t->isa_klassptr() ? sub_t->is_klassptr() : sub_t->is_oopptr()->as_klass_type();\n@@ -43,41 +40,6 @@\n-  if (sub_t->isa_oopptr() && superk->is_instance_klass() &&\n-      !superk->is_interface() && superk->is_abstract() &&\n-      !superk->as_instance_klass()->has_subklass()) {\n-    Compile::current()->dependencies()->assert_leaf_type(superk);\n-    return TypeInt::CC_GT;\n-  }\n-\n-  \/\/ Similar to logic in CmpPNode::sub()\n-\n-  \/\/ Interfaces can't be trusted unless the subclass is an exact\n-  \/\/ interface (it can then only be a constant) or the subclass is an\n-  \/\/ exact array of interfaces (a newly allocated array of interfaces\n-  \/\/ for instance)\n-  if (superk && subk &&\n-      superk->is_loaded() && !superk->is_interface() &&\n-      subk->is_loaded() && (!subk->is_interface() || xsubk) &&\n-      (!superk->is_obj_array_klass() ||\n-       !superk->as_obj_array_klass()->base_element_klass()->is_interface()) &&\n-      (!subk->is_obj_array_klass() ||\n-       !subk->as_obj_array_klass()->base_element_klass()->is_interface() ||\n-       xsubk)) {\n-    bool unrelated_classes = false;\n-    if (superk->equals(subk)) {\n-      \/\/ skip\n-    } else if (superk->is_subtype_of(subk)) {\n-      \/\/ If the subclass is exact then the superclass is a subtype of\n-      \/\/ the subclass. Given they're no equals, that subtype check can\n-      \/\/ only fail.\n-      unrelated_classes = xsubk;\n-    } else if (subk->is_subtype_of(superk)) {\n-      \/\/ skip\n-    } else {\n-      \/\/ Neither class subtypes the other: they are unrelated and this\n-      \/\/ type check is known to fail.\n-      unrelated_classes = true;\n-    }\n-    if (unrelated_classes) {\n-      TypePtr::PTR jp = sub_t->is_ptr()->join_ptr(super_t->is_ptr()->_ptr);\n-      if (jp != TypePtr::Null && jp != TypePtr::BotPTR) {\n-        return TypeInt::CC_GT;\n-      }\n+  if (sub_t->isa_oopptr() && superk->isa_instklassptr() && superk->klass_is_exact()) {\n+    ciKlass* superklass = superk->exact_klass();\n+    if (!superklass->is_interface() && superklass->is_abstract() &&\n+        !superklass->as_instance_klass()->has_subklass()) {\n+      Compile::current()->dependencies()->assert_leaf_type(superklass);\n+      return TypeInt::CC_GT;\n@@ -87,3 +49,2 @@\n-  if (super_t->singleton()) {\n-    if (subk != NULL) {\n-      switch (Compile::current()->static_subtype_check(superk, subk)) {\n+  if (subk != NULL) {\n+    switch (Compile::current()->static_subtype_check(superk, subk)) {\n@@ -99,1 +60,0 @@\n-      }\n@@ -206,2 +166,2 @@\n-  ciKlass* subk = sub_t->isa_klassptr() ? sub_t->is_klassptr()->klass() : sub_t->is_oopptr()->klass(); \/\/ can be NULL for bottom[]\n-  ciKlass* superk = super_t->is_klassptr()->klass();\n+  const TypeKlassPtr* superk = super_t->isa_klassptr();\n+  const TypeKlassPtr* subk = sub_t->isa_klassptr() ? sub_t->is_klassptr() : sub_t->is_oopptr()->as_klass_type();\n","filename":"src\/hotspot\/share\/opto\/subtypenode.cpp","additions":12,"deletions":52,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -794,2 +794,2 @@\n-    bool this_interface = this_inst->klass()->is_interface();\n-    bool    t_interface =    t_inst->klass()->is_interface();\n+    bool this_interface = this_inst->is_interface();\n+    bool    t_interface =    t_inst->is_interface();\n@@ -2279,1 +2279,1 @@\n-const Type* TypeAry::remove_speculative() const {\n+const TypeAry* TypeAry::remove_speculative() const {\n@@ -2564,1 +2564,1 @@\n-const Type *TypePtr::cast_to_ptr_type(PTR ptr) const {\n+const TypePtr* TypePtr::cast_to_ptr_type(PTR ptr) const {\n@@ -2690,0 +2690,4 @@\n+const TypePtr *TypePtr::with_offset(intptr_t offset) const {\n+  return make(AnyPtr, _ptr, offset, _speculative, _inline_depth);\n+}\n+\n@@ -2707,1 +2711,1 @@\n-const Type* TypePtr::remove_speculative() const {\n+const TypePtr* TypePtr::remove_speculative() const {\n@@ -2842,0 +2846,7 @@\n+const TypePtr* TypePtr::with_offset_speculative(intptr_t offset) const {\n+  if (_speculative == NULL) {\n+    return NULL;\n+  }\n+  return _speculative->with_offset(offset)->is_ptr();\n+}\n+\n@@ -3097,1 +3108,1 @@\n-const TypePtr *TypeRawPtr::add_offset( intptr_t offset ) const {\n+const TypePtr* TypeRawPtr::add_offset(intptr_t offset) const {\n@@ -3248,1 +3259,1 @@\n-const Type *TypeOopPtr::cast_to_exactness(bool klass_is_exact) const {\n+const TypeOopPtr* TypeOopPtr::cast_to_exactness(bool klass_is_exact) const {\n@@ -3573,0 +3584,4 @@\n+const TypeOopPtr* TypeOopPtr::with_offset(intptr_t offset) const {\n+  return make(_ptr, offset, _instance_id, with_offset_speculative(offset), _inline_depth);\n+}\n+\n@@ -3576,1 +3591,1 @@\n-const Type* TypeOopPtr::remove_speculative() const {\n+const TypeOopPtr* TypeOopPtr::remove_speculative() const {\n@@ -3656,0 +3671,4 @@\n+ciKlass* TypeInstPtr::exact_klass_helper() const {\n+  return _klass;\n+}\n+\n@@ -3659,2 +3678,1 @@\n-  : TypeOopPtr(InstPtr, ptr, k, xk, o, off, instance_id, speculative, inline_depth),\n-    _name(k->name()) {\n+  : TypeOopPtr(InstPtr, ptr, k, xk, o, off, instance_id, speculative, inline_depth) {\n@@ -3723,1 +3741,1 @@\n-const TypeInstPtr *TypeInstPtr::cast_to_ptr_type(PTR ptr) const {\n+const TypeInstPtr* TypeInstPtr::cast_to_ptr_type(PTR ptr) const {\n@@ -3727,1 +3745,1 @@\n-  return make(ptr, klass(), klass_is_exact(), const_oop(), _offset, _instance_id, _speculative, _inline_depth);\n+  return make(ptr, klass(), klass_is_exact(), ptr == Constant ? const_oop() : NULL, _offset, _instance_id, _speculative, _inline_depth);\n@@ -3732,1 +3750,1 @@\n-const Type *TypeInstPtr::cast_to_exactness(bool klass_is_exact) const {\n+const TypeInstPtr* TypeInstPtr::cast_to_exactness(bool klass_is_exact) const {\n@@ -3742,1 +3760,1 @@\n-const TypeOopPtr *TypeInstPtr::cast_to_instance_id(int instance_id) const {\n+const TypeInstPtr* TypeInstPtr::cast_to_instance_id(int instance_id) const {\n@@ -4140,0 +4158,64 @@\n+bool TypeInstPtr::is_java_subtype_of_helper(const TypeOopPtr* other, bool this_exact, bool other_exact) const {\n+  if (!is_loaded() || !other->is_loaded()) {\n+    return false;\n+  }\n+  if (!other->isa_instptr()) {\n+    return false;\n+  }\n+\n+  if (!other_exact) {\n+    return false;\n+  }\n+\n+  if (other->klass()->equals(ciEnv::current()->Object_klass())) {\n+    return true;\n+  }\n+\n+  if (!this_exact && klass()->is_interface()) {\n+    return false;\n+  }\n+\n+  return _klass->is_subtype_of(other->klass());\n+}\n+\n+bool TypeInstPtr::is_same_java_type_as(const TypeOopPtr* other) const {\n+  if (!is_loaded() || !other->is_loaded()) {\n+    return false;\n+  }\n+  if (!other->isa_instptr()) {\n+    return false;\n+  }\n+  return _klass->equals(other->_klass);\n+}\n+\n+bool TypeInstPtr::maybe_java_subtype_of_helper(const TypeOopPtr* other, bool this_exact, bool other_exact) const {\n+  if (!is_loaded() || !other->is_loaded()) {\n+    return true;\n+  }\n+\n+  if (other->isa_aryptr()) {\n+    return !this_exact && (_klass->equals(ciEnv::current()->Object_klass()) || _klass->is_interface());\n+  }\n+\n+  if ((_klass->is_interface() && !this_exact) || (other->klass()->is_interface() \/*&& !other_exact*\/)) {\n+    return true;\n+  }\n+\n+  assert(other->isa_instptr(), \"unsupported\");\n+\n+  if (this_exact && other_exact) {\n+    return is_java_subtype_of(other);\n+  }\n+\n+  if (!_klass->is_subtype_of(other->_klass) && !other->_klass->is_subtype_of(_klass)) {\n+    return false;\n+  }\n+\n+  if (this_exact) {\n+    return _klass->is_subtype_of(other->_klass);\n+  }\n+\n+  return true;\n+}\n+\n+\n@@ -4194,1 +4276,1 @@\n-const TypePtr *TypeInstPtr::add_offset(intptr_t offset) const {\n+const TypePtr* TypeInstPtr::add_offset(intptr_t offset) const {\n@@ -4199,1 +4281,6 @@\n-const Type *TypeInstPtr::remove_speculative() const {\n+const TypeInstPtr* TypeInstPtr::with_offset(intptr_t offset) const {\n+  return make(_ptr, klass(), klass_is_exact(), const_oop(), offset,\n+              _instance_id, with_offset_speculative(offset), _inline_depth);\n+}\n+\n+const TypeInstPtr* TypeInstPtr::remove_speculative() const {\n@@ -4270,1 +4357,1 @@\n-  return make(ptr, const_oop(), _ary, klass(), klass_is_exact(), _offset, _instance_id, _speculative, _inline_depth);\n+  return make(ptr, ptr == Constant ? const_oop() : NULL, _ary, klass(), klass_is_exact(), _offset, _instance_id, _speculative, _inline_depth);\n@@ -4275,1 +4362,1 @@\n-const Type *TypeAryPtr::cast_to_exactness(bool klass_is_exact) const {\n+const TypeAryPtr* TypeAryPtr::cast_to_exactness(bool klass_is_exact) const {\n@@ -4282,1 +4369,1 @@\n-const TypeOopPtr *TypeAryPtr::cast_to_instance_id(int instance_id) const {\n+const TypeAryPtr* TypeAryPtr::cast_to_instance_id(int instance_id) const {\n@@ -4398,0 +4485,67 @@\n+bool TypeAryPtr::is_java_subtype_of_helper(const TypeOopPtr* other, bool this_exact, bool other_exact) const {\n+  if (other->klass() == ciEnv::current()->Object_klass() && other_exact) {\n+    return true;\n+  }\n+\n+  if (!is_loaded() || !other->is_loaded() || other->klass() == NULL || klass() == NULL) {\n+    return false;\n+  }\n+  if (other->isa_instptr()) {\n+    return _klass->is_subtype_of(other->_klass) && other_exact;\n+  }\n+  if (klass() == NULL) {\n+    return false;\n+  }\n+  assert(other->isa_aryptr(), \"\");\n+  const TypeAryPtr* other_ary = other->isa_aryptr();\n+  if (other_ary->elem()->make_oopptr() && elem()->make_oopptr()) {\n+    return elem()->make_oopptr()->is_java_subtype_of_helper(other_ary->elem()->make_oopptr(), this_exact, other_exact);\n+  }\n+  if (!other_ary->elem()->make_oopptr() && !elem()->make_oopptr()) {\n+    return _klass->is_subtype_of(other->_klass);\n+  }\n+  return false;\n+}\n+\n+bool TypeAryPtr::is_same_java_type_as(const TypeOopPtr* other) const {\n+  if (!other->isa_aryptr() ||\n+      !is_loaded() || !other->is_loaded() || klass() == NULL || other->klass() == NULL) {\n+    return false;\n+  }\n+  const TypeAryPtr* other_ary = other->isa_aryptr();\n+  if (other_ary->elem()->make_oopptr() && elem()->make_oopptr()) {\n+    return elem()->make_oopptr()->is_same_java_type_as(other_ary->elem()->make_oopptr());\n+  }\n+  if (!other_ary->elem()->make_oopptr() && !elem()->make_oopptr()) {\n+    return _klass->equals(other->_klass);\n+  }\n+  return false;\n+}\n+\n+bool TypeAryPtr::maybe_java_subtype_of_helper(const TypeOopPtr* other, bool this_exact, bool other_exact) const {\n+  if (other->klass() == ciEnv::current()->Object_klass()) {\n+    return true;\n+  }\n+\n+  if (!is_loaded() || !other->is_loaded() || klass() == NULL || other->klass() == NULL) {\n+    return true;\n+  }\n+  if (other->isa_instptr()) {\n+    return (!other_exact && other->_klass->is_interface()) || _klass->is_subtype_of(other->_klass);\n+  }\n+  assert(other->isa_aryptr(), \"\");\n+\n+  if (this_exact && other_exact) {\n+    return is_java_subtype_of(other);\n+  }\n+\n+  const TypeAryPtr* other_ary = other->isa_aryptr();\n+  if (other_ary->elem()->make_oopptr() && elem()->make_oopptr()) {\n+    return elem()->make_oopptr()->maybe_java_subtype_of_helper(other_ary->elem()->make_oopptr(), this_exact,\n+                                                               other_exact);\n+  }\n+  if (!other_ary->elem()->make_oopptr() && !elem()->make_oopptr()) {\n+    return _klass->is_subtype_of(other->_klass);\n+  }\n+  return false;\n+}\n@@ -4719,1 +4873,9 @@\n-const Type *TypeAryPtr::remove_speculative() const {\n+const TypeAryPtr* TypeAryPtr::with_offset(intptr_t offset) const {\n+  return make(_ptr, _const_oop, _ary, _klass, _klass_is_exact, offset, _instance_id, with_offset_speculative(offset), _inline_depth);\n+}\n+\n+const TypeAryPtr* TypeAryPtr::with_ary(const TypeAry* ary) const {\n+  return make(_ptr, _const_oop, ary, _klass, _klass_is_exact, _offset, _instance_id, _speculative, _inline_depth);\n+}\n+\n+const TypeAryPtr* TypeAryPtr::remove_speculative() const {\n@@ -4859,1 +5021,1 @@\n-const Type* TypeNarrowOop::remove_speculative() const {\n+const TypeNarrowOop* TypeNarrowOop::remove_speculative() const {\n@@ -5114,0 +5276,4 @@\n+ciKlass* TypeKlassPtr::exact_klass_helper() const {\n+  return _klass;\n+}\n+\n@@ -5181,1 +5347,3 @@\n-  return (intptr_t)klass()->constant_encoding();\n+  ciKlass* k = exact_klass();\n+\n+  return (intptr_t)k->constant_encoding();\n@@ -5252,1 +5420,1 @@\n-const TypeKlassPtr *TypeInstKlassPtr::with_offset(intptr_t offset) const {\n+const TypeInstKlassPtr* TypeInstKlassPtr::with_offset(intptr_t offset) const {\n@@ -5257,1 +5425,1 @@\n-const TypePtr* TypeInstKlassPtr::cast_to_ptr_type(PTR ptr) const {\n+const TypeInstKlassPtr* TypeInstKlassPtr::cast_to_ptr_type(PTR ptr) const {\n@@ -5283,1 +5451,1 @@\n-const TypeOopPtr* TypeInstKlassPtr::as_instance_type() const {\n+const TypeOopPtr* TypeInstKlassPtr::as_instance_type(bool klass_change) const {\n@@ -5285,1 +5453,20 @@\n-  bool    xk = klass_is_exact();\n+  bool xk = klass_is_exact();\n+  Compile* C = Compile::current();\n+  Dependencies* deps = C->dependencies();\n+  assert((deps != NULL) == (C->method() != NULL && C->method()->code_size() > 0), \"sanity\");\n+  \/\/ Element is an instance\n+  bool klass_is_exact = false;\n+  if (k->is_loaded()) {\n+    \/\/ Try to set klass_is_exact.\n+    ciInstanceKlass* ik = k->as_instance_klass();\n+    klass_is_exact = ik->is_final();\n+    if (!klass_is_exact && klass_change\n+        && deps != NULL && UseUniqueSubclasses) {\n+      ciInstanceKlass* sub = ik->unique_concrete_subklass();\n+      if (sub != NULL) {\n+        deps->assert_abstract_with_unique_concrete_subtype(ik, sub);\n+        k = ik = sub;\n+        xk = sub->is_final();\n+      }\n+    }\n+  }\n@@ -5437,0 +5624,63 @@\n+bool TypeInstKlassPtr::is_java_subtype_of_helper(const TypeKlassPtr* other, bool this_exact, bool other_exact) const {\n+  if (!is_loaded() || !other->is_loaded()) {\n+    return false;\n+  }\n+  if (!other->isa_instklassptr()) {\n+    return false;\n+  }\n+\n+  if (!other_exact) {\n+    return false;\n+  }\n+\n+  if (other->_klass->equals(ciEnv::current()->Object_klass())) {\n+    return true;\n+  }\n+\n+  if (!this_exact && klass()->is_interface()) {\n+    return false;\n+  }\n+\n+  return _klass->is_subtype_of(other->_klass);\n+}\n+\n+bool TypeInstKlassPtr::is_same_java_type_as(const TypeKlassPtr* other) const {\n+  if (!is_loaded() || !other->is_loaded()) {\n+    return false;\n+  }\n+  if (!other->isa_instklassptr()) {\n+    return false;\n+  }\n+  return _klass->equals(other->_klass);\n+}\n+\n+bool TypeInstKlassPtr::maybe_java_subtype_of_helper(const TypeKlassPtr* other, bool this_exact, bool other_exact) const {\n+  if (!is_loaded() || !other->is_loaded()) {\n+    return true;\n+  }\n+\n+  if (other->isa_aryklassptr()) {\n+    return !this_exact && (_klass->equals(ciEnv::current()->Object_klass()) || _klass->is_interface());\n+  }\n+\n+  if ((_klass->is_interface() && !this_exact) || (other->klass()->is_interface() \/*&& !other_exact*\/)) {\n+    return true;\n+  }\n+\n+  assert(other->isa_instklassptr(), \"unsupported\");\n+\n+  if (this_exact && other_exact) {\n+    return is_java_subtype_of(other);\n+  }\n+\n+  if (!_klass->is_subtype_of(other->_klass) && !other->_klass->is_subtype_of(_klass)) {\n+    return false;\n+  }\n+\n+  if (this_exact) {\n+    return _klass->is_subtype_of(other->_klass);\n+  }\n+\n+  return true;\n+}\n+\n@@ -5556,1 +5806,2 @@\n-        _offset != 0 && _offset != arrayOopDesc::length_offset_in_bytes()) {\n+        _offset != 0 && _offset != arrayOopDesc::length_offset_in_bytes() &&\n+        _offset != arrayOopDesc::klass_offset_in_bytes()) {\n@@ -5563,0 +5814,22 @@\n+ciKlass* TypeAryPtr::exact_klass_helper() const {\n+  if (_ary->_elem->make_ptr() && _ary->_elem->make_ptr()->isa_oopptr()) {\n+    ciKlass* k = _ary->_elem->make_ptr()->is_oopptr()->exact_klass_helper();\n+    if (k == NULL) {\n+      return NULL;\n+    }\n+    k = ciObjArrayKlass::make(k);\n+    return k;\n+  }\n+\n+  return klass();\n+}\n+\n+const Type* TypeAryPtr::base_element_type(int& dims) const {\n+  const Type* elem = this->elem();\n+  dims = 1;\n+  while (elem->make_ptr() && elem->make_ptr()->isa_aryptr()) {\n+    elem = elem->make_ptr()->is_aryptr()->elem();\n+    dims++;\n+  }\n+  return elem;\n+}\n@@ -5570,1 +5843,1 @@\n-const TypeKlassPtr *TypeAryKlassPtr::with_offset(intptr_t offset) const {\n+const TypeAryKlassPtr* TypeAryKlassPtr::with_offset(intptr_t offset) const {\n@@ -5575,1 +5848,1 @@\n-const TypePtr* TypeAryKlassPtr::cast_to_ptr_type(PTR ptr) const {\n+const TypeAryKlassPtr* TypeAryKlassPtr::cast_to_ptr_type(PTR ptr) const {\n@@ -5604,2 +5877,2 @@\n-\/\/ It will be exact if and only if the klass type is exact.\n-const TypeOopPtr* TypeAryKlassPtr::as_instance_type() const {\n+\/\/ It will be NotNull, and exact if and only if the klass type is exact.\n+const TypeOopPtr* TypeAryKlassPtr::as_instance_type(bool klass_change) const {\n@@ -5608,1 +5881,7 @@\n-  const Type* el = elem()->isa_klassptr() ? elem()->is_klassptr()->as_instance_type()->is_oopptr()->cast_to_exactness(false) : elem();\n+  const Type* el = NULL;\n+  if (elem()->isa_klassptr()) {\n+    el = elem()->is_klassptr()->as_instance_type(false)->cast_to_exactness(false);\n+    k = NULL;\n+  } else {\n+    el = elem();\n+  }\n@@ -5740,0 +6019,66 @@\n+bool TypeAryKlassPtr::is_java_subtype_of_helper(const TypeKlassPtr* other, bool this_exact, bool other_exact) const {\n+  if (other->klass() == ciEnv::current()->Object_klass() && other_exact) {\n+    return true;\n+  }\n+\n+  if (!is_loaded() || !other->is_loaded() || other->klass() == NULL || klass() == NULL) {\n+    return false;\n+  }\n+  if (other->isa_instklassptr()) {\n+    return _klass->is_subtype_of(other->_klass) && other_exact;\n+  }\n+  if (klass() == NULL) {\n+    return false;\n+  }\n+  assert(other->isa_aryklassptr(), \"\");\n+  const TypeAryKlassPtr* other_ary = other->isa_aryklassptr();\n+  if (other_ary->_elem->isa_klassptr() && _elem->isa_klassptr()) {\n+    return _elem->is_klassptr()->is_java_subtype_of_helper(other_ary->_elem->is_klassptr(), this_exact, other_exact);\n+  }\n+  if (!other_ary->_elem->isa_klassptr() && !_elem->isa_klassptr()) {\n+    return _klass->is_subtype_of(other->_klass);\n+  }\n+  return false;\n+}\n+\n+bool TypeAryKlassPtr::is_same_java_type_as(const TypeKlassPtr* other) const {\n+  if (!other->isa_aryklassptr() ||\n+      !is_loaded() || !other->is_loaded() || klass() == NULL || other->klass() == NULL) {\n+    return false;\n+  }\n+  const TypeAryKlassPtr* other_ary = other->isa_aryklassptr();\n+  if (other_ary->_elem->isa_klassptr() && _elem->isa_klassptr()) {\n+    return _elem->is_klassptr()->is_same_java_type_as(other_ary->_elem->is_klassptr());\n+  }\n+  if (!other_ary->_elem->isa_klassptr() && !_elem->isa_klassptr()) {\n+    return _klass->equals(other->_klass);\n+  }\n+  return false;\n+}\n+\n+bool TypeAryKlassPtr::maybe_java_subtype_of_helper(const TypeKlassPtr* other, bool this_exact, bool other_exact) const {\n+  if (other->klass() == ciEnv::current()->Object_klass()) {\n+    return true;\n+  }\n+  if (!is_loaded() || !other->is_loaded() || klass() == NULL || other->klass() == NULL) {\n+    return true;\n+  }\n+  if (other->isa_instklassptr()) {\n+    return (!other_exact && other->_klass->is_interface()) || _klass->is_subtype_of(other->_klass);\n+  }\n+  assert(other->isa_aryklassptr(), \"\");\n+\n+  if (this_exact && other_exact) {\n+    return is_java_subtype_of(other);\n+  }\n+\n+  const TypeAryKlassPtr* other_ary = other->isa_aryklassptr();\n+  if (other_ary->_elem->isa_klassptr() && _elem->isa_klassptr()) {\n+    return _elem->is_klassptr()->maybe_java_subtype_of_helper(other_ary->_elem->is_klassptr(), this_exact, other_exact);\n+  }\n+  if (!other_ary->_elem->isa_klassptr() && !_elem->isa_klassptr()) {\n+    return _klass->is_subtype_of(other->_klass);\n+  }\n+  return false;\n+}\n+\n@@ -5747,0 +6092,13 @@\n+ciKlass* TypeAryKlassPtr::exact_klass_helper() const {\n+  if (elem()->isa_klassptr()) {\n+    ciKlass* k = elem()->is_klassptr()->exact_klass_helper();\n+    if (k == NULL) {\n+      return NULL;\n+    }\n+    k = ciObjArrayKlass::make(k);\n+    return k;\n+  }\n+\n+  return klass();\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":390,"deletions":32,"binary":false,"changes":422,"status":"modified"},{"patch":"@@ -777,1 +777,1 @@\n-  virtual const Type* remove_speculative() const;\n+  virtual const TypeAry* remove_speculative() const;\n@@ -922,0 +922,1 @@\n+  const TypePtr* with_offset_speculative(intptr_t offset) const;\n@@ -963,1 +964,1 @@\n-  virtual const Type *cast_to_ptr_type(PTR ptr) const;\n+  virtual const TypePtr* cast_to_ptr_type(PTR ptr) const;\n@@ -968,1 +969,2 @@\n-  virtual const TypePtr *add_offset( intptr_t offset ) const;\n+  virtual const TypePtr* add_offset(intptr_t offset) const;\n+  virtual const TypePtr* with_offset(intptr_t offset) const;\n@@ -997,1 +999,1 @@\n-  virtual const Type* remove_speculative() const;\n+  virtual const TypePtr* remove_speculative() const;\n@@ -1037,1 +1039,2 @@\n-  virtual const TypePtr *add_offset( intptr_t offset ) const;\n+  virtual const TypePtr* add_offset(intptr_t offset) const;\n+  virtual const TypeRawPtr* with_offset(intptr_t offset) const { ShouldNotReachHere(); return NULL;}\n@@ -1052,0 +1055,4 @@\n+  friend class TypeAry;\n+  friend class TypePtr;\n+  friend class TypeInstPtr;\n+  friend class TypeAryPtr;\n@@ -1088,0 +1095,3 @@\n+  virtual ciKlass* exact_klass_helper() const { return NULL; }\n+  virtual ciKlass* klass() const { return _klass;     }\n+\n@@ -1089,0 +1099,12 @@\n+\n+  bool is_java_subtype_of(const TypeOopPtr* other) const {\n+    return is_java_subtype_of_helper(other, klass_is_exact(), other->klass_is_exact());\n+  }\n+  virtual bool is_same_java_type_as(const TypeOopPtr* other) const { ShouldNotReachHere(); return false; }\n+  bool maybe_java_subtype_of(const TypeOopPtr* other) const {\n+    return maybe_java_subtype_of_helper(other, klass_is_exact(), other->klass_is_exact());\n+  }\n+  virtual bool is_java_subtype_of_helper(const TypeOopPtr* other, bool this_exact, bool other_exact) const { ShouldNotReachHere(); return false; }\n+  virtual bool maybe_java_subtype_of_helper(const TypeOopPtr* other, bool this_exact, bool other_exact) const { ShouldNotReachHere(); return false; }\n+\n+\n@@ -1118,1 +1140,5 @@\n-  virtual ciKlass* klass() const { return _klass;     }\n+  \/\/ Exact klass, possibly an interface or an array of interface\n+  ciKlass* exact_klass(bool maybe_null = false) const { assert(klass_is_exact(), \"\"); ciKlass* k = exact_klass_helper(); assert(k != NULL || maybe_null, \"\"); return k;  }\n+  ciKlass* unloaded_klass() const { assert(!is_loaded(), \"only for unloaded types\"); return klass(); }\n+\n+  virtual bool  is_loaded() const { return klass()->is_loaded(); }\n@@ -1134,1 +1160,1 @@\n-  virtual const Type *cast_to_exactness(bool klass_is_exact) const;\n+  virtual const TypeOopPtr* cast_to_exactness(bool klass_is_exact) const;\n@@ -1141,1 +1167,2 @@\n-  virtual const TypePtr *add_offset( intptr_t offset ) const;\n+  virtual const TypeOopPtr* with_offset(intptr_t offset) const;\n+  virtual const TypePtr* add_offset(intptr_t offset) const;\n@@ -1144,1 +1171,1 @@\n-  virtual const Type* remove_speculative() const;\n+  virtual const TypeOopPtr* remove_speculative() const;\n@@ -1171,1 +1198,1 @@\n-  ciSymbol*  _name;        \/\/ class name\n+  ciKlass* exact_klass_helper() const;\n@@ -1173,2 +1200,1 @@\n- public:\n-  ciSymbol* name()         const { return _name; }\n+public:\n@@ -1176,1 +1202,11 @@\n-  bool  is_loaded() const { return _klass->is_loaded(); }\n+  \/\/ Instance klass, ignoring any interface\n+  ciInstanceKlass* instance_klass() const {\n+    if (klass()->is_loaded() && klass()->is_interface()) {\n+      return Compile::current()->env()->Object_klass();\n+    }\n+    return klass()->as_instance_klass();\n+  }\n+\n+  bool is_same_java_type_as(const TypeOopPtr* other) const;\n+  bool is_java_subtype_of_helper(const TypeOopPtr* other, bool this_exact, bool other_exact) const;\n+  bool maybe_java_subtype_of_helper(const TypeOopPtr* other, bool this_exact, bool other_exact) const;\n@@ -1218,1 +1254,1 @@\n-  virtual const Type *cast_to_exactness(bool klass_is_exact) const;\n+  virtual const TypeInstPtr* cast_to_exactness(bool klass_is_exact) const;\n@@ -1220,1 +1256,1 @@\n-  virtual const TypeOopPtr *cast_to_instance_id(int instance_id) const;\n+  virtual const TypeInstPtr* cast_to_instance_id(int instance_id) const;\n@@ -1222,1 +1258,2 @@\n-  virtual const TypePtr *add_offset( intptr_t offset ) const;\n+  virtual const TypePtr* add_offset(intptr_t offset) const;\n+  virtual const TypeInstPtr* with_offset(intptr_t offset) const;\n@@ -1225,1 +1262,1 @@\n-  virtual const Type* remove_speculative() const;\n+  virtual const TypeInstPtr* remove_speculative() const;\n@@ -1236,0 +1273,2 @@\n+  bool is_interface() const { return is_loaded() && klass()->is_interface(); }\n+\n@@ -1281,0 +1320,3 @@\n+  ciKlass* exact_klass_helper() const;\n+  ciKlass* klass() const;\n+\n@@ -1282,0 +1324,8 @@\n+\n+  bool is_same_java_type_as(const TypeOopPtr* other) const;\n+  bool is_java_subtype_of_helper(const TypeOopPtr* other, bool this_exact, bool other_exact) const;\n+  bool maybe_java_subtype_of_helper(const TypeOopPtr* other, bool this_exact, bool other_exact) const;\n+\n+  \/\/ returns base element type, an instance klass (and not interface) for object arrays\n+  const Type* base_element_type(int& dims) const;\n+\n@@ -1283,1 +1333,2 @@\n-  ciKlass* klass() const;\n+  bool  is_loaded() const { return (_ary->_elem->make_oopptr() ? _ary->_elem->make_oopptr()->is_loaded() : true); }\n+\n@@ -1304,1 +1355,1 @@\n-  virtual const Type *cast_to_exactness(bool klass_is_exact) const;\n+  virtual const TypeAryPtr* cast_to_exactness(bool klass_is_exact) const;\n@@ -1306,1 +1357,1 @@\n-  virtual const TypeOopPtr *cast_to_instance_id(int instance_id) const;\n+  virtual const TypeAryPtr* cast_to_instance_id(int instance_id) const;\n@@ -1313,0 +1364,2 @@\n+  virtual const TypeAryPtr *with_offset( intptr_t offset ) const;\n+  const TypeAryPtr* with_ary(const TypeAry* ary) const;\n@@ -1315,1 +1368,1 @@\n-  virtual const Type* remove_speculative() const;\n+  virtual const TypeAryPtr* remove_speculative() const;\n@@ -1401,0 +1454,2 @@\n+  friend class TypeInstKlassPtr;\n+  friend class TypeAryKlassPtr;\n@@ -1410,1 +1465,0 @@\n-  virtual bool must_be_exact() const { ShouldNotReachHere(); return false; }\n@@ -1416,0 +1470,4 @@\n+  virtual bool must_be_exact() const { ShouldNotReachHere(); return false; }\n+  virtual ciKlass* exact_klass_helper() const;\n+  virtual ciKlass* klass() const { return  _klass; }\n+\n@@ -1418,1 +1476,13 @@\n-  virtual ciKlass* klass() const { return  _klass; }\n+  bool is_java_subtype_of(const TypeKlassPtr* other) const {\n+    return is_java_subtype_of_helper(other, klass_is_exact(), other->klass_is_exact());\n+  }\n+  bool maybe_java_subtype_of(const TypeKlassPtr* other) const {\n+    return maybe_java_subtype_of_helper(other, klass_is_exact(), other->klass_is_exact());\n+  }\n+  virtual bool is_same_java_type_as(const TypeKlassPtr* other) const { ShouldNotReachHere(); return false; }\n+  virtual bool is_java_subtype_of_helper(const TypeKlassPtr* other, bool this_exact, bool other_exact) const { ShouldNotReachHere(); return false; }\n+  virtual bool maybe_java_subtype_of_helper(const TypeKlassPtr* other, bool this_exact, bool other_exact) const { ShouldNotReachHere(); return false; }\n+\n+  \/\/ Exact klass, possibly an interface or an array of interface\n+  ciKlass* exact_klass(bool maybe_null = false) const { assert(klass_is_exact(), \"\"); ciKlass* k = exact_klass_helper(); assert(k != NULL || maybe_null, \"\"); return k;  }\n+\n@@ -1420,1 +1490,0 @@\n-  bool  is_loaded() const { return klass()->is_loaded(); }\n@@ -1425,0 +1494,1 @@\n+  virtual bool  is_loaded() const { return _klass->is_loaded(); }\n@@ -1426,1 +1496,1 @@\n-  virtual const TypePtr* cast_to_ptr_type(PTR ptr) const { ShouldNotReachHere(); return NULL; }\n+  virtual const TypeKlassPtr* cast_to_ptr_type(PTR ptr) const { ShouldNotReachHere(); return NULL; }\n@@ -1431,1 +1501,1 @@\n-  virtual const TypeOopPtr* as_instance_type() const { ShouldNotReachHere(); return NULL; }\n+  virtual const TypeOopPtr* as_instance_type(bool klass_change = true) const { ShouldNotReachHere(); return NULL; }\n@@ -1457,1 +1527,10 @@\n-  ciInstanceKlass* instance_klass() const { return klass()->as_instance_klass();     }\n+  ciInstanceKlass* instance_klass() const {\n+    if (klass()->is_interface()) {\n+      return Compile::current()->env()->Object_klass();\n+    }\n+    return klass()->as_instance_klass();\n+  }\n+\n+  bool is_same_java_type_as(const TypeKlassPtr* other) const;\n+  bool is_java_subtype_of_helper(const TypeKlassPtr* other, bool this_exact, bool other_exact) const;\n+  bool maybe_java_subtype_of_helper(const TypeKlassPtr* other, bool this_exact, bool other_exact) const;\n@@ -1464,1 +1543,1 @@\n-  virtual const TypePtr* cast_to_ptr_type(PTR ptr) const;\n+  virtual const TypeInstKlassPtr* cast_to_ptr_type(PTR ptr) const;\n@@ -1469,1 +1548,1 @@\n-  virtual const TypeOopPtr* as_instance_type() const;\n+  virtual const TypeOopPtr* as_instance_type(bool klass_change = true) const;\n@@ -1476,1 +1555,3 @@\n-  virtual const TypeKlassPtr* with_offset(intptr_t offset) const;\n+  virtual const TypeInstKlassPtr* with_offset(intptr_t offset) const;\n+\n+  bool is_interface() const { return klass()->is_interface(); }\n@@ -1485,0 +1566,1 @@\n+  friend class TypeInstKlassPtr;\n@@ -1491,0 +1573,3 @@\n+  virtual ciKlass* exact_klass_helper() const;\n+  virtual ciKlass* klass() const;\n+\n@@ -1494,1 +1579,0 @@\n-  virtual ciKlass* klass() const;\n@@ -1500,0 +1584,7 @@\n+\n+  bool is_same_java_type_as(const TypeKlassPtr* other) const;\n+  bool is_java_subtype_of_helper(const TypeKlassPtr* other, bool this_exact, bool other_exact) const;\n+  bool maybe_java_subtype_of_helper(const TypeKlassPtr* other, bool this_exact, bool other_exact) const;\n+\n+  bool  is_loaded() const { return (_elem->isa_klassptr() ? _elem->is_klassptr()->is_loaded() : true); }\n+\n@@ -1508,1 +1599,1 @@\n-  virtual const TypePtr* cast_to_ptr_type(PTR ptr) const;\n+  virtual const TypeAryKlassPtr* cast_to_ptr_type(PTR ptr) const;\n@@ -1513,1 +1604,1 @@\n-  virtual const TypeOopPtr* as_instance_type() const;\n+  virtual const TypeOopPtr* as_instance_type(bool klass_change = true) const;\n@@ -1519,1 +1610,1 @@\n-  virtual const TypeKlassPtr* with_offset(intptr_t offset) const;\n+  virtual const TypeAryKlassPtr* with_offset(intptr_t offset) const;\n@@ -1611,1 +1702,1 @@\n-  virtual const Type* remove_speculative() const;\n+  virtual const TypeNarrowOop* remove_speculative() const;\n@@ -1949,2 +2040,1 @@\n-         tp->klass()->is_instance_klass()  &&\n-         tp->klass()->as_instance_klass()->is_box_klass();\n+         tp->instance_klass()->is_box_klass();\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":127,"deletions":37,"binary":false,"changes":164,"status":"modified"},{"patch":"@@ -250,1 +250,1 @@\n-  ciInstanceKlass* iklass = vec_box->box_type()->klass()->as_instance_klass();\n+  ciInstanceKlass* iklass = vec_box->box_type()->instance_klass();\n@@ -351,1 +351,1 @@\n-  ciInstanceKlass* box_klass = box_type->klass()->as_instance_klass();\n+  ciInstanceKlass* box_klass = box_type->instance_klass();\n@@ -423,1 +423,1 @@\n-    ciInstanceKlass* from_kls = tinst->klass()->as_instance_klass();\n+    ciInstanceKlass* from_kls = tinst->instance_klass();\n","filename":"src\/hotspot\/share\/opto\/vector.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-  ciInstanceKlass* ik = vbox_type->klass()->as_instance_klass();\n+  ciInstanceKlass* ik = vbox_type->instance_klass();\n@@ -156,1 +156,1 @@\n-  const TypeVect* vt = TypeVect::make(elem_bt, num_elem, is_vector_mask(vbox_type->klass()));\n+  const TypeVect* vt = TypeVect::make(elem_bt, num_elem, is_vector_mask(vbox_type->instance_klass()));\n@@ -164,1 +164,1 @@\n-  if (vbox_type->klass() != vbox_type_v->klass()) {\n+  if (vbox_type->instance_klass() != vbox_type_v->instance_klass()) {\n@@ -171,1 +171,1 @@\n-  const TypeVect* vt = TypeVect::make(elem_bt, num_elem, is_vector_mask(vbox_type->klass()));\n+  const TypeVect* vt = TypeVect::make(elem_bt, num_elem, is_vector_mask(vbox_type->instance_klass()));\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1376,1 +1376,1 @@\n-      ciKlass* vbox_klass = vbox->box_type()->klass();\n+      ciKlass* vbox_klass = vbox->box_type()->instance_klass();\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -716,2 +716,2 @@\n-inline bool is_reference_type(BasicType t) {\n-  return (t == T_OBJECT || t == T_ARRAY);\n+inline bool is_reference_type(BasicType t, bool include_narrow_oop = false) {\n+  return (t == T_OBJECT || t == T_ARRAY || (include_narrow_oop && t == T_NARROWOOP));\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}