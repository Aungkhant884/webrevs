{"files":[{"patch":"@@ -1096,0 +1096,2 @@\n+<li><p>Rvalue references and move semantics (<a\n+href=\"https:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2004\/n1690.html\">n1690<\/a>)<\/p><\/li>\n@@ -1206,1 +1208,0 @@\n-<li><p>Rvalue references and move semantics<\/p><\/li>\n","filename":"doc\/hotspot-style.html","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1089,0 +1089,11 @@\n+* Rvalue references and move semantics\n+([n1690](https:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2004\/n1690.html))\n+* Use `std::move` when moving an object.\n+Rvalue references and move semantics is an advanced C++ concept and should be\n+treated as such. In HotSpot we prefer copy construction when possible.\n+However, we do recognize that there are cases where move semantics permit significant\n+ergonomic and performance advantages to the developer.\n+For example, if you have a data structure T which is non-copyable but needs to\n+be stored in a resizable container, then defining a move constructor may be preferable\n+to changing the contained element type from T to T\\*.\n+\n@@ -1213,2 +1224,0 @@\n-* Rvalue references and move semantics\n-\n","filename":"doc\/hotspot-style.md","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"}]}