{"files":[{"patch":"@@ -51,1 +51,1 @@\n-  if (*ref != NULL) {\n+  if (NativeAccess<>::oop_load(ref) != nullptr) {\n@@ -67,0 +67,24 @@\n+template <typename Delegate>\n+class NonBarrieredRootClosure : public OopClosure {\n+  Delegate* _delegate;\n+\n+public:\n+  NonBarrieredRootClosure(Delegate* delegate) : _delegate(delegate) {}\n+\n+  void do_oop(oop* ref) {\n+    assert(ref != NULL, \"invariant\");\n+    assert(is_aligned(ref, HeapWordSize), \"invariant\");\n+    if (*ref != nullptr) {\n+      _delegate->do_root(UnifiedOopRef::encode_non_barriered(ref));\n+    }\n+  }\n+\n+  void do_oop(narrowOop* ref) {\n+    assert(ref != NULL, \"invariant\");\n+    assert(is_aligned(ref, HeapWordSize), \"invariant\");\n+    if (!CompressedOops::is_null(*ref)) {\n+      _delegate->do_root(UnifiedOopRef::encode_non_barriered(ref));\n+    }\n+  }\n+};\n+\n@@ -70,0 +94,1 @@\n+\n@@ -72,2 +97,1 @@\n-  \/\/ We don't follow code blob oops, because they have misaligned oops.\n-  Threads::oops_do(this, NULL);\n+\n@@ -75,0 +99,4 @@\n+\n+  \/\/ We don't follow code blob oops, because they have misaligned oops.\n+  NonBarrieredRootClosure<Delegate> nbrc(_delegate);\n+  Threads::oops_do(&nbrc, NULL);\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/rootSetClosure.cpp","additions":31,"deletions":3,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -32,0 +32,9 @@\n+  static const uintptr_t tag_mask          = LP64_ONLY(0b111) NOT_LP64(0b011);\n+  static const uintptr_t native_tag        = 0b001;\n+  static const uintptr_t non_barriered_tag = 0b010;\n+  static const uintptr_t narrow_tag        = LP64_ONLY(0b100) NOT_LP64(0);\n+  STATIC_ASSERT((native_tag & non_barriered_tag) == 0);\n+  STATIC_ASSERT((native_tag & narrow_tag) == 0);\n+  STATIC_ASSERT((non_barriered_tag & narrow_tag) == 0);\n+  STATIC_ASSERT((native_tag | non_barriered_tag | narrow_tag) == tag_mask);\n+\n@@ -39,0 +48,1 @@\n+  bool is_non_barriered() const;\n@@ -45,1 +55,2 @@\n-  static UnifiedOopRef encode_in_heap(const oop* ref);\n+  static UnifiedOopRef encode_non_barriered(const narrowOop* ref);\n+  static UnifiedOopRef encode_non_barriered(const oop* ref);\n@@ -47,0 +58,1 @@\n+  static UnifiedOopRef encode_in_heap(const oop* ref);\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/utilities\/unifiedOopRef.hpp","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-  return reinterpret_cast<T>(_value & ~uintptr_t(3));\n+  return reinterpret_cast<T>(UnifiedOopRef::addr<uintptr_t>());\n@@ -45,1 +45,1 @@\n-  return _value & ~uintptr_t(3);\n+  return (_value & ~tag_mask) LP64_ONLY(>> 1);\n@@ -49,1 +49,1 @@\n-  return _value & 1;\n+  return (_value & narrow_tag) != 0;\n@@ -53,1 +53,5 @@\n-  return _value & 2;\n+  return (_value & native_tag) != 0;\n+}\n+\n+inline bool UnifiedOopRef::is_non_barriered() const {\n+  return (_value & non_barriered_tag) != 0;\n@@ -60,1 +64,2 @@\n-inline UnifiedOopRef UnifiedOopRef::encode_in_native(const narrowOop* ref) {\n+template <typename T>\n+inline UnifiedOopRef create_with_tag(T ref, uintptr_t tag) {\n@@ -62,2 +67,4 @@\n-  UnifiedOopRef result = { reinterpret_cast<uintptr_t>(ref) | 3 };\n-  assert(result.addr<narrowOop*>() == ref, \"sanity\");\n+  assert(((reinterpret_cast<uintptr_t>(ref) LP64_ONLY(<< 1)) & UnifiedOopRef::tag_mask) == 0, \"Unexpected low-order bits\");\n+  LP64_ONLY(assert(((reinterpret_cast<uintptr_t>(ref)) & (1ull << 63)) == 0, \"Unexpected high-order bit\"));\n+  UnifiedOopRef result = { (reinterpret_cast<uintptr_t>(ref) LP64_ONLY(<< 1)) | tag };\n+  assert(result.addr<T>() == ref, \"sanity\");\n@@ -67,0 +74,5 @@\n+inline UnifiedOopRef UnifiedOopRef::encode_in_native(const narrowOop* ref) {\n+  NOT_LP64(ShouldNotReachHere());\n+  return create_with_tag(ref, native_tag | narrow_tag);\n+}\n+\n@@ -68,4 +80,10 @@\n-  assert(ref != NULL, \"invariant\");\n-  UnifiedOopRef result = { reinterpret_cast<uintptr_t>(ref) | 2 };\n-  assert(result.addr<oop*>() == ref, \"sanity\");\n-  return result;\n+  return create_with_tag(ref, native_tag);\n+}\n+\n+inline UnifiedOopRef UnifiedOopRef::encode_non_barriered(const narrowOop* ref) {\n+  NOT_LP64(ShouldNotReachHere());\n+  return create_with_tag(ref, non_barriered_tag | narrow_tag);\n+}\n+\n+inline UnifiedOopRef UnifiedOopRef::encode_non_barriered(const oop* ref) {\n+  return create_with_tag(ref, non_barriered_tag);\n@@ -75,4 +93,2 @@\n-  assert(ref != NULL, \"invariant\");\n-  UnifiedOopRef result = { reinterpret_cast<uintptr_t>(ref) | 1 };\n-  assert(result.addr<narrowOop*>() == ref, \"sanity\");\n-  return result;\n+  NOT_LP64(ShouldNotReachHere());\n+  return create_with_tag(ref, narrow_tag);\n@@ -82,4 +98,1 @@\n-  assert(ref != NULL, \"invariant\");\n-  UnifiedOopRef result = { reinterpret_cast<uintptr_t>(ref) | 0 };\n-  assert(result.addr<oop*>() == ref, \"sanity\");\n-  return result;\n+  return create_with_tag(ref, 0);\n@@ -94,1 +107,8 @@\n-  if (is_native()) {\n+  if (is_non_barriered()) {\n+    if (is_narrow()) {\n+      NOT_LP64(ShouldNotReachHere());\n+      return RawAccess<>::oop_load(addr<narrowOop*>());\n+    } else {\n+      return *addr<oop*>();\n+    }\n+  } else if (is_native()) {\n@@ -96,0 +116,1 @@\n+      NOT_LP64(ShouldNotReachHere());\n@@ -102,0 +123,1 @@\n+      NOT_LP64(ShouldNotReachHere());\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/utilities\/unifiedOopRef.inline.hpp","additions":42,"deletions":20,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -1259,0 +1259,8 @@\n+\n+    inline bool operator ==(std::nullptr_t) const {\n+      return load<decorators | INTERNAL_VALUE_IS_OOP, P, oop>(_addr) == nullptr;\n+    }\n+\n+    inline bool operator !=(std::nullptr_t) const {\n+      return load<decorators | INTERNAL_VALUE_IS_OOP, P, oop>(_addr) != nullptr;\n+    }\n","filename":"src\/hotspot\/share\/oops\/accessBackend.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"}]}