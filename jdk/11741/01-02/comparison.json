{"files":[{"patch":"@@ -67,3 +67,8 @@\n-  assert(((reinterpret_cast<uintptr_t>(ref) LP64_ONLY(<< 1)) & UnifiedOopRef::tag_mask) == 0, \"Unexpected low-order bits\");\n-  LP64_ONLY(assert(((reinterpret_cast<uintptr_t>(ref)) & (1ull << 63)) == 0, \"Unexpected high-order bit\"));\n-  UnifiedOopRef result = { (reinterpret_cast<uintptr_t>(ref) LP64_ONLY(<< 1)) | tag };\n+\n+  \/\/ We need to encode 3 bits worth of information on 64-bit and 2 bits worth on 32-bit.\n+  \/\/ narrowOop* are 4 byte aligned on 64-bit so a shift is needed to fit the tag in the lower bits.\n+  \/\/ The shift requires that the narrowOop\/oop is in an address space with the highest bit not set.\n+  uintptr_t raw_ref = reinterpret_cast<uintptr_t>(ref);\n+  assert(((raw_ref LP64_ONLY(<< 1)) & UnifiedOopRef::tag_mask) == 0, \"Unexpected low-order bits\");\n+  LP64_ONLY(assert((raw_ref & (1ull << 63)) == 0, \"Unexpected high-order bit\"));\n+  UnifiedOopRef result = { (raw_ref LP64_ONLY(<< 1)) | tag };\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/utilities\/unifiedOopRef.inline.hpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"}]}