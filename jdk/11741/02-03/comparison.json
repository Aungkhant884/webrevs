{"files":[{"patch":"@@ -68,7 +68,12 @@\n-  \/\/ We need to encode 3 bits worth of information on 64-bit and 2 bits worth on 32-bit.\n-  \/\/ narrowOop* are 4 byte aligned on 64-bit so a shift is needed to fit the tag in the lower bits.\n-  \/\/ The shift requires that the narrowOop\/oop is in an address space with the highest bit not set.\n-  uintptr_t raw_ref = reinterpret_cast<uintptr_t>(ref);\n-  assert(((raw_ref LP64_ONLY(<< 1)) & UnifiedOopRef::tag_mask) == 0, \"Unexpected low-order bits\");\n-  LP64_ONLY(assert((raw_ref & (1ull << 63)) == 0, \"Unexpected high-order bit\"));\n-  UnifiedOopRef result = { (raw_ref LP64_ONLY(<< 1)) | tag };\n+  uintptr_t value = reinterpret_cast<uintptr_t>(ref);\n+\n+#ifdef _LP64\n+  \/\/ tag_mask is 3 bits. When ref is a narrowOop* we only have 2 alignment\n+  \/\/ bits, because of the 4 byte alignment of compressed oops addresses.\n+  \/\/ Shift up to make way for one more bit.\n+  assert((value & (1ull << 63)) == 0, \"Unexpected high-order bit\");\n+  value <<= 1;\n+#endif\n+  assert((value & UnifiedOopRef::tag_mask) == 0, \"Unexpected low-order bits\");\n+\n+  UnifiedOopRef result = { value | tag };\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/utilities\/unifiedOopRef.inline.hpp","additions":12,"deletions":7,"binary":false,"changes":19,"status":"modified"}]}