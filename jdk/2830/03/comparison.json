{"files":[{"patch":"@@ -53,1 +53,0 @@\n-import java.util.Objects;\n@@ -1937,6 +1936,3 @@\n-    private final char zero;\n-    private static double scaleUp;\n-\n-    \/\/ 1 (sign) + 19 (max # sig digits) + 1 ('.') + 1 ('e') + 1 (sign)\n-    \/\/ + 3 (max # exp digits) + 4 (error) = 30\n-    private static final int MAX_FD_CHARS = 30;\n+    \/\/ Non-character value used to mark zero as uninitialized\n+    private static final char ZERO_SENTINEL = '\\uFFFE';\n+    private char zero = ZERO_SENTINEL;\n@@ -1972,1 +1968,0 @@\n-        this.zero = getZero(l);\n@@ -2451,6 +2446,10 @@\n-    private static char getZero(Locale l) {\n-        if ((l != null) && !l.equals(Locale.US)) {\n-            DecimalFormatSymbols dfs = DecimalFormatSymbols.getInstance(l);\n-            return dfs.getZeroDigit();\n-        } else {\n-            return '0';\n+    private char zero() {\n+        char zero = this.zero;\n+        if (zero == ZERO_SENTINEL) {\n+            if ((l != null) && !l.equals(Locale.US)) {\n+                DecimalFormatSymbols dfs = DecimalFormatSymbols.getInstance(l);\n+                zero = dfs.getZeroDigit();\n+            } else {\n+                zero = '0';\n+            }\n+            this.zero = zero;\n@@ -2458,0 +2457,1 @@\n+        return zero;\n@@ -2672,1 +2672,2 @@\n-        for (FormatString fs : fsa) {\n+        for (int i = 0; i < fsa.size(); i++) {\n+            var fs = fsa.get(i);\n@@ -2709,1 +2710,1 @@\n-    private static Pattern fsPattern = Pattern.compile(formatSpecifier);\n+    private static final Pattern fsPattern = Pattern.compile(formatSpecifier);\n@@ -2716,21 +2717,9 @@\n-        Matcher m = fsPattern.matcher(s);\n-        for (int i = 0, len = s.length(); i < len; ) {\n-            if (m.find(i)) {\n-                \/\/ Anything between the start of the string and the beginning\n-                \/\/ of the format specifier is either fixed text or contains\n-                \/\/ an invalid format string.\n-                if (m.start() != i) {\n-                    \/\/ Make sure we didn't miss any invalid format specifiers\n-                    checkText(s, i, m.start());\n-                    \/\/ Assume previous characters were fixed text\n-                    al.add(new FixedString(s, i, m.start()));\n-                }\n-\n-                al.add(new FormatSpecifier(s, m));\n-                i = m.end();\n-            } else {\n-                \/\/ No more valid format specifiers.  Check for possible invalid\n-                \/\/ format specifiers.\n-                checkText(s, i, len);\n-                \/\/ The rest of the string is fixed text\n-                al.add(new FixedString(s, i, s.length()));\n+        int i = 0;\n+        int max = s.length();\n+        Matcher m = null; \/\/ create if needed\n+        while (i < max) {\n+            int n = s.indexOf('%', i);\n+            if (n < 0) {\n+                \/\/ No more format specifiers, but since\n+                \/\/ i < max there's some trailing text\n+                al.add(new FixedString(s, i, max));\n@@ -2739,10 +2728,25 @@\n-        }\n-        return al;\n-    }\n-\n-    private static void checkText(String s, int start, int end) {\n-        for (int i = start; i < end; i++) {\n-            \/\/ Any '%' found in the region starts an invalid format specifier.\n-            if (s.charAt(i) == '%') {\n-                char c = (i == end - 1) ? '%' : s.charAt(i + 1);\n-                throw new UnknownFormatConversionException(String.valueOf(c));\n+            if (i != n) {\n+                \/\/ Previous characters were fixed text\n+                al.add(new FixedString(s, i, n));\n+            }\n+            i = n + 1;\n+            if (i >= max) {\n+                \/\/ Trailing %\n+                throw new UnknownFormatConversionException(\"%\");\n+            }\n+            char c = s.charAt(i);\n+            if (Conversion.isValid(c)) {\n+                al.add(new FormatSpecifier(c));\n+                i++;\n+            } else {\n+                if (m == null) {\n+                    m = fsPattern.matcher(s);\n+                }\n+                \/\/ We have already parsed a '%' at n, so we either have a\n+                \/\/ match or the specifier at n is invalid\n+                if (m.find(n) && m.start() == n) {\n+                    al.add(new FormatSpecifier(s, m));\n+                    i = m.end();\n+                } else {\n+                    throw new UnknownFormatConversionException(String.valueOf(c));\n+                }\n@@ -2751,0 +2755,1 @@\n+        return al;\n@@ -2760,3 +2765,3 @@\n-        private String s;\n-        private int start;\n-        private int end;\n+        private final String s;\n+        private final int start;\n+        private final int end;\n@@ -2790,1 +2795,2 @@\n-        private int index = -1;\n+\n+        private int index = 0;\n@@ -2792,2 +2798,2 @@\n-        private int width;\n-        private int precision;\n+        private int width = -1;\n+        private int precision = -1;\n@@ -2797,1 +2803,1 @@\n-        private int index(String s, int start, int end) {\n+        private void index(String s, int start, int end) {\n@@ -2808,2 +2814,0 @@\n-            } else {\n-                index = 0;\n@@ -2811,1 +2815,0 @@\n-            return index;\n@@ -2818,1 +2821,1 @@\n-        private Flags flags(String s, int start, int end) {\n+        private void flags(String s, int start, int end) {\n@@ -2822,1 +2825,0 @@\n-            return f;\n@@ -2825,2 +2827,1 @@\n-        private int width(String s, int start, int end) {\n-            width = -1;\n+        private void width(String s, int start, int end) {\n@@ -2836,1 +2837,0 @@\n-            return width;\n@@ -2839,2 +2839,1 @@\n-        private int precision(String s, int start, int end) {\n-            precision = -1;\n+        private void precision(String s, int start, int end) {\n@@ -2851,1 +2850,0 @@\n-            return precision;\n@@ -2854,1 +2852,1 @@\n-        private char conversion(char conv) {\n+        private void conversion(char conv) {\n@@ -2868,1 +2866,11 @@\n-            return c;\n+        }\n+\n+        FormatSpecifier(char conv) {\n+            c = conv;\n+            if (Character.isUpperCase(conv)) {\n+                f = Flags.UPPERCASE;\n+                c = Character.toLowerCase(conv);\n+            }\n+            if (Conversion.isText(conv)) {\n+                index = -2;\n+            }\n@@ -2920,1 +2928,0 @@\n-            case Conversion.CHARACTER_UPPER:\n@@ -3015,1 +3022,1 @@\n-                byte i = ((Byte)arg).byteValue();\n+                byte i = (Byte) arg;\n@@ -3021,1 +3028,1 @@\n-                short i = ((Short)arg).shortValue();\n+                short i = (Short) arg;\n@@ -3027,1 +3034,1 @@\n-                int i = ((Integer)arg).intValue();\n+                int i = (Integer) arg;\n@@ -3085,1 +3092,1 @@\n-        private Appendable appendJustified(Appendable a, CharSequence cs) throws IOException {\n+        private void appendJustified(Appendable a, CharSequence cs) throws IOException {\n@@ -3087,1 +3094,2 @@\n-                 return a.append(cs);\n+                 a.append(cs);\n+                 return;\n@@ -3100,1 +3108,0 @@\n-             return a;\n@@ -3232,1 +3239,0 @@\n-                assert v >= 0 : v;\n@@ -3620,1 +3626,1 @@\n-                    scaleUp = Math.scalb(1.0, 54);\n+                    double scaleUp = Math.scalb(1.0, 54);\n@@ -4453,1 +4459,1 @@\n-            return zero;\n+            return zero();\n@@ -4632,12 +4638,11 @@\n-            switch (c) {\n-            case '-': return LEFT_JUSTIFY;\n-            case '#': return ALTERNATE;\n-            case '+': return PLUS;\n-            case ' ': return LEADING_SPACE;\n-            case '0': return ZERO_PAD;\n-            case ',': return GROUP;\n-            case '(': return PARENTHESES;\n-            case '<': return PREVIOUS;\n-            default:\n-                throw new UnknownFormatFlagsException(String.valueOf(c));\n-            }\n+            return switch (c) {\n+                case '-' -> LEFT_JUSTIFY;\n+                case '#' -> ALTERNATE;\n+                case '+' -> PLUS;\n+                case ' ' -> LEADING_SPACE;\n+                case '0' -> ZERO_PAD;\n+                case ',' -> GROUP;\n+                case '(' -> PARENTHESES;\n+                case '<' -> PREVIOUS;\n+                default -> throw new UnknownFormatFlagsException(String.valueOf(c));\n+            };\n@@ -4709,2 +4714,24 @@\n-            return (isGeneral(c) || isInteger(c) || isFloat(c) || isText(c)\n-                    || c == 't' || isCharacter(c));\n+            return switch (c) {\n+                case BOOLEAN,\n+                     BOOLEAN_UPPER,\n+                     STRING,\n+                     STRING_UPPER,\n+                     HASHCODE,\n+                     HASHCODE_UPPER,\n+                     CHARACTER,\n+                     CHARACTER_UPPER,\n+                     DECIMAL_INTEGER,\n+                     OCTAL_INTEGER,\n+                     HEXADECIMAL_INTEGER,\n+                     HEXADECIMAL_INTEGER_UPPER,\n+                     SCIENTIFIC,\n+                     SCIENTIFIC_UPPER,\n+                     GENERAL,\n+                     GENERAL_UPPER,\n+                     DECIMAL_FLOAT,\n+                     HEXADECIMAL_FLOAT,\n+                     HEXADECIMAL_FLOAT_UPPER,\n+                     LINE_SEPARATOR,\n+                     PERCENT_SIGN -> true;\n+                default -> false;\n+            };\n@@ -4715,11 +4742,9 @@\n-            switch (c) {\n-            case BOOLEAN:\n-            case BOOLEAN_UPPER:\n-            case STRING:\n-            case STRING_UPPER:\n-            case HASHCODE:\n-            case HASHCODE_UPPER:\n-                return true;\n-            default:\n-                return false;\n-            }\n+            return switch (c) {\n+                case BOOLEAN,\n+                     BOOLEAN_UPPER,\n+                     STRING,\n+                     STRING_UPPER,\n+                     HASHCODE,\n+                     HASHCODE_UPPER -> true;\n+                default -> false;\n+            };\n@@ -4730,7 +4755,5 @@\n-            switch (c) {\n-            case CHARACTER:\n-            case CHARACTER_UPPER:\n-                return true;\n-            default:\n-                return false;\n-            }\n+            return switch (c) {\n+                case CHARACTER,\n+                     CHARACTER_UPPER -> true;\n+                default -> false;\n+            };\n@@ -4741,9 +4764,7 @@\n-            switch (c) {\n-            case DECIMAL_INTEGER:\n-            case OCTAL_INTEGER:\n-            case HEXADECIMAL_INTEGER:\n-            case HEXADECIMAL_INTEGER_UPPER:\n-                return true;\n-            default:\n-                return false;\n-            }\n+            return switch (c) {\n+                case DECIMAL_INTEGER,\n+                     OCTAL_INTEGER,\n+                     HEXADECIMAL_INTEGER,\n+                     HEXADECIMAL_INTEGER_UPPER -> true;\n+                default -> false;\n+            };\n@@ -4754,12 +4775,10 @@\n-            switch (c) {\n-            case SCIENTIFIC:\n-            case SCIENTIFIC_UPPER:\n-            case GENERAL:\n-            case GENERAL_UPPER:\n-            case DECIMAL_FLOAT:\n-            case HEXADECIMAL_FLOAT:\n-            case HEXADECIMAL_FLOAT_UPPER:\n-                return true;\n-            default:\n-                return false;\n-            }\n+            return switch (c) {\n+                case SCIENTIFIC,\n+                     SCIENTIFIC_UPPER,\n+                     GENERAL,\n+                     GENERAL_UPPER,\n+                     DECIMAL_FLOAT,\n+                     HEXADECIMAL_FLOAT,\n+                     HEXADECIMAL_FLOAT_UPPER -> true;\n+                default -> false;\n+            };\n@@ -4770,7 +4789,4 @@\n-            switch (c) {\n-            case LINE_SEPARATOR:\n-            case PERCENT_SIGN:\n-                return true;\n-            default:\n-                return false;\n-            }\n+            return switch (c) {\n+                case LINE_SEPARATOR, PERCENT_SIGN -> true;\n+                default -> false;\n+            };\n@@ -4804,2 +4820,0 @@\n-\/\/ *    static final char ISO_WEEK_OF_YEAR_2    = 'g'; \/\/ cross %y %V\n-\/\/ *    static final char ISO_WEEK_OF_YEAR_4    = 'G'; \/\/ cross %Y %V\n@@ -4809,5 +4823,0 @@\n-\/\/ *    static final char DAY_OF_WEEK_1         = 'u'; \/\/ (1 - 7) Monday\n-\/\/ *    static final char WEEK_OF_YEAR_SUNDAY   = 'U'; \/\/ (0 - 53) Sunday+\n-\/\/ *    static final char WEEK_OF_YEAR_MONDAY_01 = 'V'; \/\/ (01 - 53) Monday+\n-\/\/ *    static final char DAY_OF_WEEK_0         = 'w'; \/\/ (0 - 6) Sunday\n-\/\/ *    static final char WEEK_OF_YEAR_MONDAY   = 'W'; \/\/ (00 - 53) Monday\n@@ -4820,1 +4829,0 @@\n-\/\/ *    static final char LOCALE_TIME   = 'X'; \/\/ (%H:%M:%S) - parse format?\n@@ -4825,1 +4833,0 @@\n-\/\/ *    static final char LOCALE_DATE           = 'x'; \/\/ (mm\/dd\/yy)\n@@ -4852,2 +4859,0 @@\n-\/\/ *        case ISO_WEEK_OF_YEAR_2:\n-\/\/ *        case ISO_WEEK_OF_YEAR_4:\n@@ -4857,5 +4862,0 @@\n-\/\/ *        case DAY_OF_WEEK_1:\n-\/\/ *        case WEEK_OF_YEAR_SUNDAY:\n-\/\/ *        case WEEK_OF_YEAR_MONDAY_01:\n-\/\/ *        case DAY_OF_WEEK_0:\n-\/\/ *        case WEEK_OF_YEAR_MONDAY:\n@@ -4868,1 +4868,0 @@\n-\/\/ *        case LOCALE_TIME:\n@@ -4872,1 +4871,0 @@\n-\/\/ *        case LOCALE_DATE:\n","filename":"src\/java.base\/share\/classes\/java\/util\/Formatter.java","additions":153,"deletions":155,"binary":false,"changes":308,"status":"modified"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+\/*\n+ * This benchmark naively explores String::format\/formatted performance\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Benchmark)\n+public class StringFormat {\n+\n+    public String s = \"str\";\n+    public int i = 17;\n+\n+    @Benchmark\n+    public String stringFormat() {\n+        return \"%s\".formatted(s);\n+    }\n+\n+    @Benchmark\n+    public String stringIntFormat() {\n+        return \"%s %d\".formatted(s, i);\n+    }\n+\n+    @Benchmark\n+    public String widthStringFormat() {\n+        return \"%3s\".formatted(s);\n+    }\n+\n+    @Benchmark\n+    public String widthStringIntFormat() {\n+        return \"%3s %d\".formatted(s, i);\n+    }\n+\n+    @Benchmark\n+    public String complexFormat() {\n+        return \"%3s %10d %4S %04X %4S %04X %4S %04X\".formatted(s, i, s, i, s, i, s, i);\n+    }\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/StringFormat.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"}]}