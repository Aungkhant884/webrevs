{"files":[{"patch":"@@ -2975,21 +2975,0 @@\n-\/\/ Returns true iff super_method can be overridden by a method in targetclassname\n-\/\/ See JLS 3rd edition 8.4.6.1\n-\/\/ Assumes name-signature match\n-\/\/ \"this\" is InstanceKlass of super_method which must exist\n-\/\/ note that the InstanceKlass of the method in the targetclassname has not always been created yet\n-bool InstanceKlass::is_override(const methodHandle& super_method, Handle targetclassloader, Symbol* targetclassname, TRAPS) {\n-   \/\/ Private methods can not be overridden\n-   if (super_method->is_private()) {\n-     return false;\n-   }\n-   \/\/ If super method is accessible, then override\n-   if ((super_method->is_protected()) ||\n-       (super_method->is_public())) {\n-     return true;\n-   }\n-   \/\/ Package-private methods are not inherited outside of package\n-   assert(super_method->is_package_private(), \"must be package private\");\n-   return(is_same_class_package(targetclassloader(), targetclassname));\n-}\n-\n-\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":0,"deletions":21,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -515,3 +515,0 @@\n-  \/\/ method override check\n-  bool is_override(const methodHandle& super_method, Handle targetclassloader, Symbol* targetclassname, TRAPS);\n-\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -83,2 +83,1 @@\n-    assert(methods->at(i)->is_method(), \"must be a Method*\");\n-    methodHandle mh(THREAD, methods->at(i));\n+    Method* method = methods->at(i);\n@@ -86,2 +85,2 @@\n-    if (needs_new_vtable_entry(mh, super, classloader, classname, class_flags, major_version, THREAD)) {\n-      assert(!methods->at(i)->is_private(), \"private methods should not need a vtable entry\");\n+    if (needs_new_vtable_entry(method, super, classloader, classname, class_flags, major_version)) {\n+      assert(!method->is_private(), \"private methods should not need a vtable entry\");\n@@ -202,2 +201,0 @@\n-      HandleMark hm(THREAD);\n-      assert(methods->at(i)->is_method(), \"must be a Method*\");\n@@ -210,1 +207,1 @@\n-        mh()->set_vtable_index(initialized); \/\/ set primary vtable index\n+        mh->set_vtable_index(initialized); \/\/ set primary vtable index\n@@ -228,2 +225,0 @@\n-          HandleMark hm(THREAD);\n-          assert(default_methods->at(i)->is_method(), \"must be a Method*\");\n@@ -236,1 +231,3 @@\n-            put_method_at(mh(), initialized);\n+            \/\/ Refetch this default method in case of redefinition in safepoint above.\n+            Method* method = default_methods->at(i);\n+            put_method_at(method, initialized);\n@@ -275,0 +272,19 @@\n+\/\/ Returns true iff super_method can be overridden by a method in targetclassname\n+\/\/ See JLS 3rd edition 8.4.6.1\n+\/\/ Assumes name-signature match\n+\/\/ Note that the InstanceKlass of the method in the targetclassname has not always been created yet\n+static bool is_override(Method* super_method, Handle targetclassloader, Symbol* targetclassname) {\n+   \/\/ Private methods can not be overridden\n+   assert(!super_method->is_private(), \"shouldn't call with a private method\");\n+\n+   \/\/ If super method is accessible, then override\n+   if ((super_method->is_protected()) ||\n+       (super_method->is_public())) {\n+     return true;\n+   }\n+   \/\/ Package-private methods are not inherited outside of package\n+   assert(super_method->is_package_private(), \"must be package private\");\n+   return(super_method->method_holder()->is_same_class_package(targetclassloader(), targetclassname));\n+}\n+\n+\n@@ -290,2 +306,6 @@\n-InstanceKlass* klassVtable::find_transitive_override(InstanceKlass* initialsuper, const methodHandle& target_method,\n-                            int vtable_index, Handle target_loader, Symbol* target_classname, Thread * THREAD) {\n+InstanceKlass* klassVtable::find_transitive_override(InstanceKlass* initialsuper,\n+                                                     const methodHandle& target_method,\n+                                                     int vtable_index,\n+                                                     Handle target_loader,\n+                                                     Symbol* target_classname) {\n+\n@@ -297,3 +317,0 @@\n-      \/\/ get the class holding the matching method\n-      \/\/ make sure you use that class for is_override\n-      InstanceKlass* supermethodholder = super_method->method_holder();\n@@ -306,1 +323,1 @@\n-      if (supermethodholder->is_override(methodHandle(THREAD, super_method), target_loader, target_classname, THREAD)) {\n+      if (is_override(super_method, target_loader, target_classname)) {\n@@ -308,1 +325,1 @@\n-          ResourceMark rm(THREAD);\n+          ResourceMark rm;\n@@ -313,1 +330,1 @@\n-                       supermethodholder->internal_name(),\n+                       super_method->method_holder()->internal_name(),\n@@ -381,1 +398,1 @@\n-    assert(!target_method()->is_private(), \"private interface method flagged as default\");\n+    assert(!target_method->is_private(), \"private interface method flagged as default\");\n@@ -385,1 +402,1 @@\n-    assert(klass == target_method()->method_holder(), \"caller resp.\");\n+    assert(klass == target_method->method_holder(), \"caller resp.\");\n@@ -388,1 +405,1 @@\n-    target_method()->set_vtable_index(Method::nonvirtual_vtable_index);\n+    target_method->set_vtable_index(Method::nonvirtual_vtable_index);\n@@ -392,2 +409,2 @@\n-  if (target_method()->is_private() || target_method()->is_static() ||\n-      (target_method()->name()->fast_compare(vmSymbols::object_initializer_name()) == 0)) {\n+  if (target_method->is_private() || target_method->is_static() ||\n+      (target_method->name()->fast_compare(vmSymbols::object_initializer_name()) == 0)) {\n@@ -413,2 +430,2 @@\n-    if ((!is_default || !target_method()->has_itable_index())) {\n-      target_method()->set_vtable_index(Method::pending_itable_index);\n+    if ((!is_default || !target_method->has_itable_index())) {\n+      target_method->set_vtable_index(Method::pending_itable_index);\n@@ -429,2 +446,2 @@\n-  Symbol* name = target_method()->name();\n-  Symbol* signature = target_method()->signature();\n+  Symbol* name = target_method->name();\n+  Symbol* signature = target_method->signature();\n@@ -432,1 +449,2 @@\n-  Klass* target_klass = target_method()->method_holder();\n+  Klass* target_klass = target_method->method_holder();\n+  assert(target_klass != NULL, \"impossible\");\n@@ -437,0 +455,1 @@\n+  HandleMark hm(THREAD);\n@@ -455,1 +474,1 @@\n-        (!_klass->is_interface() ||\n+        (!klass->is_interface() ||\n@@ -466,8 +485,7 @@\n-          (is_default\n-          || ((super_klass->is_override(methodHandle(THREAD, super_method), target_loader, target_classname, THREAD))\n-          || ((klass->major_version() >= VTABLE_TRANSITIVE_OVERRIDE_VERSION)\n-          && ((super_klass = find_transitive_override(super_klass,\n-                             target_method, i, target_loader,\n-                             target_classname, THREAD))\n-                             != (InstanceKlass*)NULL)))))\n-        {\n+          (is_default ||\n+           is_override(super_method, target_loader, target_classname) ||\n+           (klass->major_version() >= VTABLE_TRANSITIVE_OVERRIDE_VERSION &&\n+             (super_klass = find_transitive_override(super_klass,\n+                                                     target_method, i, target_loader,\n+                                                     target_classname)) != NULL))) {\n+\n@@ -476,1 +494,1 @@\n-        if (!target_method()->is_package_private()) {\n+        if (!target_method->is_package_private()) {\n@@ -480,0 +498,4 @@\n+        \/\/ Speculatively set the vtable index before the constraint check safepoint\n+        \/\/ redefines this method, which is possible if it is a default method.\n+        put_method_at(target_method(), i);\n+\n@@ -482,1 +504,1 @@\n-        if (checkconstraints && !target_method()->is_overpass()) {\n+        if (checkconstraints && !target_method->is_overpass()) {\n@@ -501,1 +523,1 @@\n-              target_method()->print_external_name(&ss),\n+              target_method->print_external_name(&ss),\n@@ -517,1 +539,0 @@\n-        put_method_at(target_method(), i);\n@@ -520,1 +541,1 @@\n-          target_method()->set_vtable_index(i);\n+          target_method->set_vtable_index(i);\n@@ -547,0 +568,1 @@\n+  JVMTI_ONLY(assert(!m->is_old() || ik()->is_being_redefined(), \"old methods should not be in vtable\"));\n@@ -579,1 +601,1 @@\n-bool klassVtable::needs_new_vtable_entry(const methodHandle& target_method,\n+bool klassVtable::needs_new_vtable_entry(Method* target_method,\n@@ -584,2 +606,1 @@\n-                                         u2 major_version,\n-                                         TRAPS) {\n+                                         u2 major_version) {\n@@ -598,1 +619,1 @@\n-      (target_method()->is_private()) ||\n+      (target_method->is_private()) ||\n@@ -600,1 +621,1 @@\n-      (target_method()->is_static()) ||\n+      (target_method->is_static()) ||\n@@ -602,1 +623,1 @@\n-      (target_method()->name()->fast_compare(vmSymbols::object_initializer_name()) == 0)\n+      (target_method->name()->fast_compare(vmSymbols::object_initializer_name()) == 0)\n@@ -610,4 +631,4 @@\n-  if (target_method()->method_holder() != NULL &&\n-      target_method()->method_holder()->is_interface()  &&\n-      !target_method()->is_abstract()) {\n-    assert(target_method()->is_default_method(),\n+  if (target_method->method_holder() != NULL &&\n+      target_method->method_holder()->is_interface()  &&\n+      !target_method->is_abstract()) {\n+    assert(target_method->is_default_method(),\n@@ -625,1 +646,1 @@\n-  if (target_method()->is_package_private()) {\n+  if (target_method->is_package_private()) {\n@@ -631,3 +652,2 @@\n-  ResourceMark rm(THREAD);\n-  Symbol* name = target_method()->name();\n-  Symbol* signature = target_method()->signature();\n+  Symbol* name = target_method->name();\n+  Symbol* signature = target_method->signature();\n@@ -646,1 +666,0 @@\n-    \/\/ make sure you use that class for is_override\n@@ -654,3 +673,3 @@\n-    if ((!super_method->is_static()) &&\n-       (!super_method->is_private())) {\n-      if (superk->is_override(methodHandle(THREAD, super_method), classloader, classname, THREAD)) {\n+    if (!super_method->is_static() &&\n+        !super_method->is_private()) {\n+      if (is_override(super_method, classloader, classname)) {\n@@ -658,1 +677,1 @@\n-      \/\/ else keep looking for transitive overrides\n+        \/\/ else keep looking for transitive overrides\n@@ -721,2 +740,1 @@\n-  Klass* method_holder = m->method_holder();\n-  InstanceKlass *mhk = InstanceKlass::cast(method_holder);\n+  InstanceKlass* holder = m->method_holder();\n@@ -725,1 +743,1 @@\n-  if (mhk->is_interface()) {\n+  if (holder->is_interface()) {\n@@ -727,1 +745,1 @@\n-    assert(ik()->implements_interface(method_holder) , \"this class should implement the interface\");\n+    assert(ik()->implements_interface(holder) , \"this class should implement the interface\");\n@@ -891,1 +909,1 @@\n-    InstanceKlass *ik = InstanceKlass::cast(local_interfaces->at(i));\n+    InstanceKlass *ik = local_interfaces->at(i);\n@@ -1110,1 +1128,1 @@\n-      Klass* interf = ioe->interface_klass();\n+      InstanceKlass* interf = ioe->interface_klass();\n@@ -1112,1 +1130,1 @@\n-      initialize_itable_for_interface(ioe->offset(), InstanceKlass::cast(interf), checkconstraints, CHECK);\n+      initialize_itable_for_interface(ioe->offset(), interf, checkconstraints, CHECK);\n","filename":"src\/hotspot\/share\/oops\/klassVtable.cpp","additions":86,"deletions":68,"binary":false,"changes":154,"status":"modified"},{"patch":"@@ -112,1 +112,1 @@\n-  static bool needs_new_vtable_entry(const methodHandle& m,\n+  static bool needs_new_vtable_entry(Method* m,\n@@ -117,2 +117,1 @@\n-                                     u2 major_version,\n-                                     TRAPS);\n+                                     u2 major_version);\n@@ -121,2 +120,3 @@\n- InstanceKlass* find_transitive_override(InstanceKlass* initialsuper, const methodHandle& target_method, int vtable_index,\n-                                         Handle target_loader, Symbol* target_classname, Thread* THREAD);\n+ InstanceKlass* find_transitive_override(InstanceKlass* initialsuper,\n+                                         const methodHandle& target_method, int vtable_index,\n+                                         Handle target_loader, Symbol* target_classname);\n","filename":"src\/hotspot\/share\/oops\/klassVtable.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"}]}