{"files":[{"patch":"@@ -41,5 +41,0 @@\n-#ifdef ASSERT\n-volatile jint GCLocker::_debug_jni_lock_count = 0;\n-#endif\n-\n-\n@@ -49,1 +44,0 @@\n-    assert(!needs_gc() || _debug_jni_lock_count == _jni_lock_count, \"must agree\");\n@@ -70,11 +64,0 @@\n-\n-\/\/ In debug mode track the locking state at all times\n-void GCLocker::increment_debug_jni_lock_count() {\n-  assert(_debug_jni_lock_count >= 0, \"bad value\");\n-  Atomic::inc(&_debug_jni_lock_count);\n-}\n-\n-void GCLocker::decrement_debug_jni_lock_count() {\n-  assert(_debug_jni_lock_count > 0, \"bad value\");\n-  Atomic::dec(&_debug_jni_lock_count);\n-}\n@@ -126,1 +109,1 @@\n-void GCLocker::jni_lock(JavaThread* thread) {\n+void GCLocker::stall_until_no_needs_gc(JavaThread* thread) {\n@@ -133,1 +116,1 @@\n-    \/\/ blocking) exits CR, it calls `jni_unlock`, which sets `_needs_gc`\n+    \/\/ blocking) exits CR, it calls `unlock_critical`, which sets `_needs_gc`\n@@ -135,3 +118,3 @@\n-    \/\/ We would like to assert #threads in CR to be > 0, `_jni_lock_count > 0`\n-    \/\/ in the code, but it's too strong; it's possible that the last thread\n-    \/\/ has called `jni_unlock`, but not yet finished the call, e.g. initiating\n+    \/\/ We would like to assert #threads in CR to be > 0, i.e. `_jni_lock_count > 0`,\n+    \/\/ but that would be too strong -- it's possible that the last thread\n+    \/\/ has called `unlock_critical`, but not yet finished the call, e.g. initiating\n@@ -141,3 +124,0 @@\n-  thread->enter_critical();\n-  _jni_lock_count++;\n-  increment_debug_jni_lock_count();\n@@ -146,7 +126,7 @@\n-void GCLocker::jni_unlock(JavaThread* thread) {\n-  assert(thread->in_last_critical(), \"should be exiting critical region\");\n-  MutexLocker mu(JNICritical_lock);\n-  _jni_lock_count--;\n-  decrement_debug_jni_lock_count();\n-  thread->exit_critical();\n-  if (needs_gc() && !is_active_internal()) {\n+void GCLocker::ack_needs_gc_if_last_thread(JavaThread* thread) {\n+  assert(!thread->in_critical(), \"shouldn't currently be in a critical region\");\n+  assert(needs_gc(), \"precondition\");\n+  jint old_value = Atomic::fetch_and_add(&_jni_lock_count, -1);\n+  assert(old_value > 0, \"inv\");\n+  bool is_last_thread = (old_value == 1);\n+  if (is_last_thread) {\n@@ -161,0 +141,2 @@\n+    log_debug_jni(\"Performing GC after exiting critical section.\");\n+    Universe::heap()->collect(GCCause::_gc_locker);\n@@ -162,4 +144,3 @@\n-      \/\/ Must give up the lock while at a safepoint\n-      MutexUnlocker munlock(JNICritical_lock);\n-      log_debug_jni(\"Performing GC after exiting critical section.\");\n-      Universe::heap()->collect(GCCause::_gc_locker);\n+      MutexLocker mu(JNICritical_lock);\n+      _needs_gc = false;\n+      JNICritical_lock->notify_all();\n@@ -167,2 +148,0 @@\n-    _needs_gc = false;\n-    JNICritical_lock->notify_all();\n","filename":"src\/hotspot\/share\/gc\/shared\/gcLocker.cpp","additions":17,"deletions":38,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -49,6 +49,0 @@\n-#ifdef ASSERT\n-  \/\/ This lock count is updated for all operations and is used to\n-  \/\/ validate the jni_lock_count that is computed during safepoints.\n-  static volatile jint _debug_jni_lock_count;\n-#endif\n-\n@@ -60,2 +54,2 @@\n-  static void jni_lock(JavaThread* thread);\n-  static void jni_unlock(JavaThread* thread);\n+  static void stall_until_no_needs_gc(JavaThread* thread);\n+  static void ack_needs_gc_if_last_thread(JavaThread* thread);\n@@ -88,4 +82,0 @@\n-  \/\/ In debug mode track the locking state at all times\n-  static void increment_debug_jni_lock_count() NOT_DEBUG_RETURN;\n-  static void decrement_debug_jni_lock_count() NOT_DEBUG_RETURN;\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/gcLocker.hpp","additions":2,"deletions":12,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -33,8 +33,3 @@\n-  if (!thread->in_critical()) {\n-    if (needs_gc()) {\n-      \/\/ jni_lock call calls enter_critical under the lock so that the\n-      \/\/ global lock count and per thread count are in agreement.\n-      jni_lock(thread);\n-      return;\n-    }\n-    increment_debug_jni_lock_count();\n+  if (!thread->in_critical() && needs_gc()) {\n+    stall_until_no_needs_gc(thread);\n+    assert(!needs_gc(), \"postcondition\");\n@@ -46,9 +41,0 @@\n-  if (thread->in_last_critical()) {\n-    if (needs_gc()) {\n-      \/\/ jni_unlock call calls exit_critical under the lock so that\n-      \/\/ the global lock count and per thread count are in agreement.\n-      jni_unlock(thread);\n-      return;\n-    }\n-    decrement_debug_jni_lock_count();\n-  }\n@@ -56,0 +42,3 @@\n+  if (!thread->in_critical() && needs_gc()) {\n+    ack_needs_gc_if_last_thread(thread);\n+  }\n","filename":"src\/hotspot\/share\/gc\/shared\/gcLocker.inline.hpp","additions":6,"deletions":17,"binary":false,"changes":23,"status":"modified"}]}