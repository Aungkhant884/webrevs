{"files":[{"patch":"@@ -72,0 +72,21 @@\n+\n+  \/\/ Visit all non-cast uses of the node, bypassing ConstraintCasts.\n+  \/\/ Pattern: this (-> ConstraintCast)* -> non_cast\n+  \/\/ In other words: find all non_cast nodes such that\n+  \/\/ non_cast->uncast() == this.\n+  template <typename Callback>\n+  static void visit_uncasted_uses(const Node* n, Callback callback) {\n+    Unique_Node_List internals;\n+    internals.push((Node*)n); \/\/ start traversal\n+    for (uint j = 0; j < internals.size(); ++j) {\n+      Node* internal = internals.at(j); \/\/ for every internal\n+      for (DUIterator_Fast kmax, k = internal->fast_outs(kmax); k < kmax; k++) {\n+        Node* internal_use = internal->fast_out(k);\n+        if (internal_use->is_ConstraintCast()) {\n+          internals.push(internal_use); \/\/ traverse this cast also\n+        } else {\n+          callback(internal_use);\n+        }\n+      }\n+    }\n+  }\n","filename":"src\/hotspot\/share\/opto\/castnode.hpp","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -1763,0 +1763,3 @@\n+    \/\/ Patterns:\n+    \/\/ ConstraintCast+ -> Sub\n+    \/\/ ConstraintCast+ -> Phi\n@@ -1764,22 +1767,3 @@\n-      for (DUIterator_Fast i2max, i2 = use->fast_outs(i2max); i2 < i2max; i2++) {\n-        Node* u = use->fast_out(i2);\n-        if (u->is_Phi() || u->is_Sub()) {\n-          \/\/ Phi (.., CastII, ..) or Sub(Cast(x), x)\n-          _worklist.push(u);\n-        } else if (u->is_ConstraintCast()) {\n-          \/\/ Follow cast-chains down to Sub: Sub( CastII(CastII(x)), x)\n-          \/\/ This case is quite rare. Let's BFS-traverse casts, to find Subs:\n-          ResourceMark rm;\n-          Unique_Node_List casts;\n-          casts.push(u); \/\/ start traversal\n-          for (uint j = 0; j < casts.size(); ++j) {\n-            Node* cast = casts.at(j); \/\/ for every cast\n-            for (DUIterator_Fast kmax, k = cast->fast_outs(kmax); k < kmax; k++) {\n-              Node* cast_use = cast->fast_out(k);\n-              if (cast_use->is_ConstraintCast()) {\n-                casts.push(cast_use); \/\/ traverse this cast also\n-              } else if (cast_use->is_Sub()) {\n-                _worklist.push(cast_use); \/\/ found Sub\n-              }\n-            }\n-          }\n+      auto push_phi_or_sub_uses_to_worklist = [&](Node* n){\n+        if (n->is_Phi() || n->is_Sub()) {\n+          _worklist.push(n);\n@@ -1787,1 +1771,2 @@\n-      }\n+      };\n+      ConstraintCastNode::visit_uncasted_uses(use, push_phi_or_sub_uses_to_worklist);\n@@ -2152,0 +2137,1 @@\n+\/\/ Pattern: parent -> LShift (use) -> ConstraintCast* -> And\n@@ -2156,5 +2142,4 @@\n-    for (DUIterator_Fast imax, i = use->fast_outs(imax); i < imax; i++) {\n-      Node* and_node = use->fast_out(i);\n-      uint and_node_op = and_node->Opcode();\n-      if (and_node_op == Op_AndI || and_node_op == Op_AndL) {\n-        push_if_not_bottom_type(worklist, and_node);\n+    auto push_and_uses_to_worklist = [&](Node* n){\n+      uint opc = n->Opcode();\n+      if (opc == Op_AndI || opc == Op_AndL) {\n+        push_if_not_bottom_type(worklist, n);\n@@ -2162,1 +2147,2 @@\n-    }\n+    };\n+    ConstraintCastNode::visit_uncasted_uses(use, push_and_uses_to_worklist);\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":15,"deletions":29,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8306042\n+ * @summary CCP missed optimization opportunity. Due to missing notification through Casts.\n+ * @library \/test\/lib\n+ * @run main\/othervm -Xcomp -XX:-TieredCompilation\n+ *                   -XX:CompileOnly=compiler.ccp.TestShiftCastAndNotification::test\n+ *                   compiler.ccp.TestShiftCastAndNotification\n+ *\/\n+\n+package compiler.ccp;\n+\n+public class TestShiftCastAndNotification {\n+  static int N;\n+  static int iArrFld[] = new int[1];\n+  static int test() {\n+    int x = 1;\n+    int sval = 4;\n+    long useless[] = new long[N];\n+    for (double d1 = 63; d1 > 2; d1 -= 2) {\n+      for (double d2 = 3; 1 < d2; d2--) {\n+        x <<= sval; \/\/ The LShiftI\n+      }\n+      \/\/ CastII probably somewhere in the loop structure\n+      x &= 3; \/\/ The AndI\n+      for (int i = 1; i < 3; i++) {\n+        try {\n+          x = iArrFld[0];\n+          sval = 0;\n+        } catch (ArithmeticException a_e) {\n+        }\n+      }\n+    }\n+    return x;\n+  }\n+  public static void main(String[] args) {\n+      test();\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/ccp\/TestShiftCastAndNotification.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"}]}