{"files":[{"patch":"@@ -125,0 +125,1 @@\n+  -compiler\/arraycopy\/stress \\\n@@ -179,0 +180,5 @@\n+tier2_compiler =\n+\n+tier3_compiler = \\\n+  compiler\/arraycopy\/stress\n+\n@@ -470,0 +476,1 @@\n+  :tier2_compiler \\\n@@ -475,0 +482,1 @@\n+  :tier3_compiler \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,145 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n+public abstract class AbstractStressArrayCopy {\n+    \/**\n+     * Max array size to test.\n+     *\/\n+    static final int MAX_SIZE = 1024*1024 + 1;\n+\n+    \/**\n+     * Arrays up to this size would be tested exhaustively: with all combinations\n+     * of source\/destination starts and copy lengths. Exercise restraint when bumping\n+     * this value, as the test costs are proportional to N^3 of this setting.\n+     *\/\n+    static final int EXHAUSTIVE_SIZES = Integer.getInteger(\"exhaustiveSizes\", 192);\n+\n+    \/*\n+     * Larger arrays would fuzzed with this many attempts.\n+     *\/\n+    static final int FUZZ_COUNT = Integer.getInteger(\"fuzzCount\", 300);\n+\n+    public static void throwSeedError(int len, int pos) {\n+        throw new RuntimeException(\"Error after seed: \" +\n+            len + \" elements, at pos \" + pos);\n+    }\n+\n+    public static void throwContentsError(int l, int r, int len, int pos) {\n+        throwError(\"in contents\", l, r, len, pos);\n+    }\n+\n+    public static void throwHeadError(int l, int r, int len, int pos) {\n+        throwError(\"in head\", l, r, len, pos);\n+    }\n+\n+    public static void throwTailError(int l, int r, int len, int pos) {\n+        throwError(\"in tail\", l, r, len, pos);\n+    }\n+\n+    private static void throwError(String phase, int l, int r, int len, int pos) {\n+        throw new RuntimeException(\"Error \" + phase + \": \" +\n+            len + \" elements, \" +\n+            \"[\" + l + \", \" + (l+len) + \") -> \" +\n+            \"[\" + r + \", \" + (r+len) + \"), \" +\n+            \"at pos \" + pos);\n+    }\n+\n+    protected abstract void testWith(int size, int l, int r, int len);\n+\n+    public void exhaustiveWith(int size) {\n+        for (int l = 0; l < size; l++) {\n+            for (int r = 0; r < size; r++) {\n+                int maxLen = Math.min(size - l, size - r);\n+                for (int len = 0; len <= maxLen; len++) {\n+                    testWith(size, l, r, len);\n+                }\n+            }\n+        }\n+    }\n+\n+    public void fuzzWith(Random rand, int size) {\n+        \/\/ Some basic checks first\n+        testWith(size, 0, 1, 1);\n+        testWith(size, 0, 1, size-1);\n+\n+        \/\/ Test disjoint:\n+        for (int c = 0; c < FUZZ_COUNT; c++) {\n+            int l = rand.nextInt(size \/ 2);\n+            int len = rand.nextInt((size - l) \/ 2);\n+            int r = (l + len) + rand.nextInt(size - 2*len - l);\n+\n+            if (l >= size)      throw new IllegalStateException(\"l is out of bounds\");\n+            if (l + len > size) throw new IllegalStateException(\"l+len is out of bounds\");\n+            if (r >= size)      throw new IllegalStateException(\"r is out of bounds\");\n+            if (r + len > size) throw new IllegalStateException(\"r+len is out of bounds: \" + l + \" \" + r + \" \" + len + \" \" + size);\n+            if (l + len > r)    throw new IllegalStateException(\"Not disjoint\");\n+\n+            testWith(size, l, r, len);\n+            testWith(size, r, l, len);\n+        }\n+\n+        \/\/ Test conjoint:\n+        for (int c = 0; c < FUZZ_COUNT; c++) {\n+            int l = rand.nextInt(size);\n+            int len = rand.nextInt(size - l);\n+            int r = Math.min(l + (len > 0 ? rand.nextInt(len) : 0), size - len);\n+\n+            if (l >= size)      throw new IllegalStateException(\"l is out of bounds\");\n+            if (l + len > size) throw new IllegalStateException(\"l+len is out of bounds\");\n+            if (r >= size)      throw new IllegalStateException(\"r is out of bounds\");\n+            if (r + len > size) throw new IllegalStateException(\"r+len is out of bounds: \" + l + \" \" + r + \" \" + len + \" \" + size);\n+            if (l + len < r)    throw new IllegalStateException(\"Not conjoint\");\n+\n+            testWith(size, l, r, len);\n+            testWith(size, r, l, len);\n+        }\n+    }\n+\n+    public void run(Random rand) {\n+        \/\/ Exhaustive on all small arrays\n+        for (int size = 1; size <= EXHAUSTIVE_SIZES; size++) {\n+            exhaustiveWith(size);\n+        }\n+\n+        \/\/ Fuzz powers of ten\n+        for (int size = 10; size < MAX_SIZE; size *= 10) {\n+            if (size <= EXHAUSTIVE_SIZES) continue;\n+            fuzzWith(rand, size - 1);\n+            fuzzWith(rand, size);\n+            fuzzWith(rand, size + 1);\n+        }\n+\n+        \/\/ Fuzz powers of two\n+        for (int size = 2; size < MAX_SIZE; size *= 2) {\n+            if (size <= EXHAUSTIVE_SIZES) continue;\n+            fuzzWith(rand, size - 1);\n+            fuzzWith(rand, size);\n+            fuzzWith(rand, size + 1);\n+        }\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/stress\/AbstractStressArrayCopy.java","additions":145,"deletions":0,"binary":false,"changes":145,"status":"added"},{"patch":"@@ -0,0 +1,164 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Deque;\n+import java.util.List;\n+import java.util.Random;\n+\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import jdk.test.whitebox.cpuinfo.CPUInfo;\n+\n+public abstract class StressArrayCopyDriver {\n+\n+    \/\/ These tests are remarkably memory bandwidth hungry. Running multiple\n+    \/\/ configs in parallel makes sense only when running a single test in\n+    \/\/ isolation, and only on machines with many memory channels. In common\n+    \/\/ testing, or even running all arraycopy stress tests at once, overloading\n+    \/\/ the system with many configs become counter-productive very quickly.\n+    \/\/\n+    \/\/ The sweet-spot seems to be 2. Default to it, and allow users to override.\n+    static final int MAX_PARALLELISM = Integer.getInteger(\"maxParallelism\", 2);\n+\n+    private static List<String> mix(List<String> o, String... mix) {\n+        List<String> n = new ArrayList<>(o);\n+        for (String m : mix) {\n+            n.add(m);\n+        }\n+        return n;\n+    }\n+\n+    private static List<List<String>> product(List<List<String>> list, String... mix) {\n+        List<List<String>> newList = new ArrayList<>();\n+        for (List<String> c : list) {\n+            for (String m : mix) {\n+                newList.add(mix(c, m));\n+            }\n+        }\n+        return newList;\n+    }\n+\n+    private static List<List<String>> alternate(List<List<String>> list, String opt) {\n+        return product(list, \"-XX:+\" + opt, \"-XX:-\" + opt);\n+    }\n+\n+    private static boolean containsFuzzy(List<String> list, String sub) {\n+        for (String s : list) {\n+            if (s.contains(sub)) return true;\n+        }\n+        return false;\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        if (args.length < 1) {\n+            throw new IllegalArgumentException(\"Should provide at least 1 argument\");\n+        }\n+\n+        String className = args[0];\n+\n+        List<List<String>> configs = new ArrayList<>();\n+        List<String> cpuFeatures = CPUInfo.getFeatures();\n+\n+        if (Platform.isX64() || Platform.isX86()) {\n+            \/\/ If CPU features were not found, provide a default config.\n+            if (cpuFeatures.isEmpty()) {\n+                configs.add(new ArrayList());\n+            }\n+\n+            \/\/ Otherwise, select the tests that make sense on current platform.\n+            if (containsFuzzy(cpuFeatures, \"avx512\")) {\n+                configs.add(List.of(\"-XX:UseAVX=3\"));\n+            }\n+            if (containsFuzzy(cpuFeatures, \"avx2\")) {\n+                configs.add(List.of(\"-XX:UseAVX=2\"));\n+            }\n+            if (containsFuzzy(cpuFeatures, \"avx\")) {\n+                configs.add(List.of(\"-XX:UseAVX=1\"));\n+            }\n+            if (containsFuzzy(cpuFeatures, \"sse4\")) {\n+                configs.add(List.of(\"-XX:UseAVX=0\", \"-XX:UseSSE=4\"));\n+            }\n+            if (containsFuzzy(cpuFeatures, \"sse3\")) {\n+                configs.add(List.of(\"-XX:UseAVX=0\", \"-XX:UseSSE=3\"));\n+            }\n+            if (containsFuzzy(cpuFeatures, \"sse2\")) {\n+                configs.add(List.of(\"-XX:UseAVX=0\", \"-XX:UseSSE=2\"));\n+            }\n+\n+            \/\/ x86_64 always has UseSSE >= 2. These lower configurations only\n+            \/\/ make sense for x86_32.\n+            if (Platform.isX86()) {\n+                if (containsFuzzy(cpuFeatures, \"sse\")) {\n+                    configs.add(List.of(\"-XX:UseAVX=0\", \"-XX:UseSSE=1\"));\n+                }\n+\n+                configs.add(List.of(\"-XX:UseAVX=0\", \"-XX:UseSSE=0\"));\n+            }\n+\n+            \/\/ Alternate configs with other flags\n+            if (Platform.isX64()) {\n+                configs = alternate(configs, \"UseCompressedOops\");\n+            }\n+            configs = alternate(configs, \"UseUnalignedLoadStores\");\n+\n+        } else if (Platform.isAArch64()) {\n+            \/\/ AArch64.\n+            configs.add(new ArrayList());\n+\n+            \/\/ Alternate configs with other flags\n+            configs = alternate(configs, \"UseCompressedOops\");\n+            configs = alternate(configs, \"UseSIMDForMemoryOps\");\n+        } else {\n+            \/\/ Generic config.\n+            configs.add(new ArrayList());\n+        }\n+\n+        Deque<OutputAnalyzer> oas = new ArrayDeque<>();\n+        int jobs = 0;\n+\n+        for (List<String> c : configs) {\n+            ProcessBuilder pb = ProcessTools.createTestJvm(mix(c, \"-Xmx256m\", className));\n+            OutputAnalyzer oa = new OutputAnalyzer(pb.start());\n+            oas.addLast(oa);\n+            if (++jobs >= MAX_PARALLELISM) {\n+                \/\/ Pop and block wait\n+                oa = oas.pollFirst();\n+                oa.shouldHaveExitValue(0);\n+                jobs--;\n+            }\n+        }\n+\n+        \/\/ Drain the rest\n+        while (!oas.isEmpty()) {\n+            OutputAnalyzer oa = oas.pollFirst();\n+            oa.shouldHaveExitValue(0);\n+        }\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/stress\/StressArrayCopyDriver.java","additions":164,"deletions":0,"binary":false,"changes":164,"status":"added"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @key stress randomness\n+ * @library \/test\/lib\n+ * @build TestStressBooleanArrayCopy\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ *\n+ * @run main\/othervm\/timeout=960\n+ *      -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *      StressArrayCopyDriver TestStressBooleanArrayCopy\n+ *\/\n+\n+import java.util.Arrays;\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n+public class TestStressBooleanArrayCopy extends AbstractStressArrayCopy {\n+\n+    private static final boolean[] orig = new boolean[MAX_SIZE];\n+    private static final boolean[] test = new boolean[MAX_SIZE];\n+\n+    protected void testWith(int size, int l, int r, int len) {\n+        \/\/ Seed the test from the original\n+        System.arraycopy(orig, 0, test, 0, size);\n+\n+        \/\/ Check the seed is correct\n+        {\n+            int m = Arrays.mismatch(test, 0, size,\n+                                    orig, 0, size);\n+            if (m != -1) {\n+                throwSeedError(size, m);\n+            }\n+        }\n+\n+        \/\/ Perform the tested copy\n+        System.arraycopy(test, l, test, r, len);\n+\n+        \/\/ Check the copy has proper contents\n+        {\n+            int m = Arrays.mismatch(test, r, r+len,\n+                                    orig, l, l+len);\n+            if (m != -1) {\n+                throwContentsError(l, r, len, r+m);\n+            }\n+        }\n+\n+        \/\/ Check anything else was not affected: head and tail\n+        {\n+            int m = Arrays.mismatch(test, 0, r,\n+                                    orig, 0, r);\n+            if (m != -1) {\n+                throwHeadError(l, r, len, m);\n+            }\n+        }\n+        {\n+            int m = Arrays.mismatch(test, r + len, size,\n+                                    orig, r + len, size);\n+            if (m != -1) {\n+                throwTailError(l, r, len, m);\n+            }\n+        }\n+    }\n+\n+    public static void main(String... args) {\n+        Random rand = Utils.getRandomInstance();\n+        for (int c = 0; c < orig.length; c++) {\n+            orig[c] = rand.nextBoolean();\n+        }\n+        new TestStressBooleanArrayCopy().run(rand);\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/stress\/TestStressBooleanArrayCopy.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @key stress randomness\n+ * @library \/test\/lib\n+ * @build TestStressByteArrayCopy\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ *\n+ * @run main\/othervm\/timeout=960\n+ *      -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *      StressArrayCopyDriver TestStressByteArrayCopy\n+ *\/\n+\n+import java.util.Arrays;\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n+public class TestStressByteArrayCopy extends AbstractStressArrayCopy {\n+\n+    private static final byte[] orig = new byte[MAX_SIZE];\n+    private static final byte[] test = new byte[MAX_SIZE];\n+\n+    protected void testWith(int size, int l, int r, int len) {\n+        \/\/ Seed the test from the original\n+        System.arraycopy(orig, 0, test, 0, size);\n+\n+        \/\/ Check the seed is correct\n+        {\n+            int m = Arrays.mismatch(test, 0, size,\n+                                    orig, 0, size);\n+            if (m != -1) {\n+                throwSeedError(size, m);\n+            }\n+        }\n+\n+        \/\/ Perform the tested copy\n+        System.arraycopy(test, l, test, r, len);\n+\n+        \/\/ Check the copy has proper contents\n+        {\n+            int m = Arrays.mismatch(test, r, r+len,\n+                                    orig, l, l+len);\n+            if (m != -1) {\n+                throwContentsError(l, r, len, r+m);\n+            }\n+        }\n+\n+        \/\/ Check anything else was not affected: head and tail\n+        {\n+            int m = Arrays.mismatch(test, 0, r,\n+                                    orig, 0, r);\n+            if (m != -1) {\n+                throwHeadError(l, r, len, m);\n+            }\n+        }\n+        {\n+            int m = Arrays.mismatch(test, r + len, size,\n+                                    orig, r + len, size);\n+            if (m != -1) {\n+                throwTailError(l, r, len, m);\n+            }\n+        }\n+    }\n+\n+    public static void main(String... args) {\n+        Random rand = Utils.getRandomInstance();\n+        for (int c = 0; c < orig.length; c++) {\n+            orig[c] = (byte)rand.nextInt();\n+        }\n+        new TestStressByteArrayCopy().run(rand);\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/stress\/TestStressByteArrayCopy.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @key stress randomness\n+ * @library \/test\/lib\n+ * @build TestStressCharArrayCopy\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ *\n+ * @run main\/othervm\/timeout=960\n+ *      -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *      StressArrayCopyDriver TestStressCharArrayCopy\n+ *\/\n+\n+import java.util.Arrays;\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n+public class TestStressCharArrayCopy extends AbstractStressArrayCopy {\n+\n+    private static final char[] orig = new char[MAX_SIZE];\n+    private static final char[] test = new char[MAX_SIZE];\n+\n+    protected void testWith(int size, int l, int r, int len) {\n+        \/\/ Seed the test from the original\n+        System.arraycopy(orig, 0, test, 0, size);\n+\n+        \/\/ Check the seed is correct\n+        {\n+            int m = Arrays.mismatch(test, 0, size,\n+                                    orig, 0, size);\n+            if (m != -1) {\n+                throwSeedError(size, m);\n+            }\n+        }\n+\n+        \/\/ Perform the tested copy\n+        System.arraycopy(test, l, test, r, len);\n+\n+        \/\/ Check the copy has proper contents\n+        {\n+            int m = Arrays.mismatch(test, r, r+len,\n+                                    orig, l, l+len);\n+            if (m != -1) {\n+                throwContentsError(l, r, len, r+m);\n+            }\n+        }\n+\n+        \/\/ Check anything else was not affected: head and tail\n+        {\n+            int m = Arrays.mismatch(test, 0, r,\n+                                    orig, 0, r);\n+            if (m != -1) {\n+                throwHeadError(l, r, len, m);\n+            }\n+        }\n+        {\n+            int m = Arrays.mismatch(test, r + len, size,\n+                                    orig, r + len, size);\n+            if (m != -1) {\n+                throwTailError(l, r, len, m);\n+            }\n+        }\n+    }\n+\n+    public static void main(String... args) {\n+        Random rand = Utils.getRandomInstance();\n+        for (int c = 0; c < orig.length; c++) {\n+            orig[c] = (char)rand.nextInt();\n+        }\n+        new TestStressCharArrayCopy().run(rand);\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/stress\/TestStressCharArrayCopy.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @key stress randomness\n+ * @library \/test\/lib\n+ * @build TestStressDoubleArrayCopy\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ *\n+ * @run main\/othervm\/timeout=960\n+ *      -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *      StressArrayCopyDriver TestStressDoubleArrayCopy\n+ *\/\n+\n+import java.util.Arrays;\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n+public class TestStressDoubleArrayCopy extends AbstractStressArrayCopy {\n+\n+    private static final double[] orig = new double[MAX_SIZE];\n+    private static final double[] test = new double[MAX_SIZE];\n+\n+    protected void testWith(int size, int l, int r, int len) {\n+        \/\/ Seed the test from the original\n+        System.arraycopy(orig, 0, test, 0, size);\n+\n+        \/\/ Check the seed is correct\n+        {\n+            int m = Arrays.mismatch(test, 0, size,\n+                                    orig, 0, size);\n+            if (m != -1) {\n+                throwSeedError(size, m);\n+            }\n+        }\n+\n+        \/\/ Perform the tested copy\n+        System.arraycopy(test, l, test, r, len);\n+\n+        \/\/ Check the copy has proper contents\n+        {\n+            int m = Arrays.mismatch(test, r, r+len,\n+                                    orig, l, l+len);\n+            if (m != -1) {\n+                throwContentsError(l, r, len, r+m);\n+            }\n+        }\n+\n+        \/\/ Check anything else was not affected: head and tail\n+        {\n+            int m = Arrays.mismatch(test, 0, r,\n+                                    orig, 0, r);\n+            if (m != -1) {\n+                throwHeadError(l, r, len, m);\n+            }\n+        }\n+        {\n+            int m = Arrays.mismatch(test, r + len, size,\n+                                    orig, r + len, size);\n+            if (m != -1) {\n+                throwTailError(l, r, len, m);\n+            }\n+        }\n+    }\n+\n+    public static void main(String... args) {\n+        Random rand = Utils.getRandomInstance();\n+        for (int c = 0; c < orig.length; c++) {\n+            orig[c] = rand.nextDouble();\n+        }\n+        new TestStressDoubleArrayCopy().run(rand);\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/stress\/TestStressDoubleArrayCopy.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @key stress randomness\n+ * @library \/test\/lib\n+ * @build TestStressFloatArrayCopy\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ *\n+ * @run main\/othervm\/timeout=960\n+ *      -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *      StressArrayCopyDriver TestStressFloatArrayCopy\n+ *\/\n+\n+import java.util.Arrays;\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n+public class TestStressFloatArrayCopy extends AbstractStressArrayCopy {\n+\n+    private static final float[] orig = new float[MAX_SIZE];\n+    private static final float[] test = new float[MAX_SIZE];\n+\n+    protected void testWith(int size, int l, int r, int len) {\n+        \/\/ Seed the test from the original\n+        System.arraycopy(orig, 0, test, 0, size);\n+\n+        \/\/ Check the seed is correct\n+        {\n+            int m = Arrays.mismatch(test, 0, size,\n+                                    orig, 0, size);\n+            if (m != -1) {\n+                throwSeedError(size, m);\n+            }\n+        }\n+\n+        \/\/ Perform the tested copy\n+        System.arraycopy(test, l, test, r, len);\n+\n+        \/\/ Check the copy has proper contents\n+        {\n+            int m = Arrays.mismatch(test, r, r+len,\n+                                    orig, l, l+len);\n+            if (m != -1) {\n+                throwContentsError(l, r, len, r+m);\n+            }\n+        }\n+\n+        \/\/ Check anything else was not affected: head and tail\n+        {\n+            int m = Arrays.mismatch(test, 0, r,\n+                                    orig, 0, r);\n+            if (m != -1) {\n+                throwHeadError(l, r, len, m);\n+            }\n+        }\n+        {\n+            int m = Arrays.mismatch(test, r + len, size,\n+                                    orig, r + len, size);\n+            if (m != -1) {\n+                throwTailError(l, r, len, m);\n+            }\n+        }\n+    }\n+\n+    public static void main(String... args) {\n+        Random rand = Utils.getRandomInstance();\n+        for (int c = 0; c < orig.length; c++) {\n+            orig[c] = rand.nextFloat();\n+        }\n+        new TestStressFloatArrayCopy().run(rand);\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/stress\/TestStressFloatArrayCopy.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @key stress randomness\n+ * @library \/test\/lib\n+ * @build TestStressIntArrayCopy\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ *\n+ * @run main\/othervm\/timeout=960\n+ *      -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *      StressArrayCopyDriver TestStressIntArrayCopy\n+ *\/\n+\n+import java.util.Arrays;\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n+public class TestStressIntArrayCopy extends AbstractStressArrayCopy {\n+\n+    private static final int[] orig = new int[MAX_SIZE];\n+    private static final int[] test = new int[MAX_SIZE];\n+\n+    protected void testWith(int size, int l, int r, int len) {\n+        \/\/ Seed the test from the original\n+        System.arraycopy(orig, 0, test, 0, size);\n+\n+        \/\/ Check the seed is correct\n+        {\n+            int m = Arrays.mismatch(test, 0, size,\n+                                    orig, 0, size);\n+            if (m != -1) {\n+                throwSeedError(size, m);\n+            }\n+        }\n+\n+        \/\/ Perform the tested copy\n+        System.arraycopy(test, l, test, r, len);\n+\n+        \/\/ Check the copy has proper contents\n+        {\n+            int m = Arrays.mismatch(test, r, r+len,\n+                                    orig, l, l+len);\n+            if (m != -1) {\n+                throwContentsError(l, r, len, r+m);\n+            }\n+        }\n+\n+        \/\/ Check anything else was not affected: head and tail\n+        {\n+            int m = Arrays.mismatch(test, 0, r,\n+                                    orig, 0, r);\n+            if (m != -1) {\n+                throwHeadError(l, r, len, m);\n+            }\n+        }\n+        {\n+            int m = Arrays.mismatch(test, r + len, size,\n+                                    orig, r + len, size);\n+            if (m != -1) {\n+                throwTailError(l, r, len, m);\n+            }\n+        }\n+    }\n+\n+    public static void main(String... args) {\n+        Random rand = Utils.getRandomInstance();\n+        for (int c = 0; c < orig.length; c++) {\n+            orig[c] = rand.nextInt();\n+        }\n+        new TestStressIntArrayCopy().run(rand);\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/stress\/TestStressIntArrayCopy.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @key stress randomness\n+ * @library \/test\/lib\n+ * @build TestStressLongArrayCopy\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ *\n+ * @run main\/othervm\/timeout=960\n+ *      -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *      StressArrayCopyDriver TestStressLongArrayCopy\n+ *\/\n+\n+import java.util.Arrays;\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n+public class TestStressLongArrayCopy extends AbstractStressArrayCopy {\n+\n+    private static final long[] orig = new long[MAX_SIZE];\n+    private static final long[] test = new long[MAX_SIZE];\n+\n+    protected void testWith(int size, int l, int r, int len) {\n+        \/\/ Seed the test from the original\n+        System.arraycopy(orig, 0, test, 0, size);\n+\n+        \/\/ Check the seed is correct\n+        {\n+            int m = Arrays.mismatch(test, 0, size,\n+                                    orig, 0, size);\n+            if (m != -1) {\n+                throwSeedError(size, m);\n+            }\n+        }\n+\n+        \/\/ Perform the tested copy\n+        System.arraycopy(test, l, test, r, len);\n+\n+        \/\/ Check the copy has proper contents\n+        {\n+            int m = Arrays.mismatch(test, r, r+len,\n+                                    orig, l, l+len);\n+            if (m != -1) {\n+                throwContentsError(l, r, len, r+m);\n+            }\n+        }\n+\n+        \/\/ Check anything else was not affected: head and tail\n+        {\n+            int m = Arrays.mismatch(test, 0, r,\n+                                    orig, 0, r);\n+            if (m != -1) {\n+                throwHeadError(l, r, len, m);\n+            }\n+        }\n+        {\n+            int m = Arrays.mismatch(test, r + len, size,\n+                                    orig, r + len, size);\n+            if (m != -1) {\n+                throwTailError(l, r, len, m);\n+            }\n+        }\n+    }\n+\n+    public static void main(String... args) {\n+        Random rand = Utils.getRandomInstance();\n+        for (int c = 0; c < orig.length; c++) {\n+            orig[c] = rand.nextLong();\n+        }\n+        new TestStressLongArrayCopy().run(rand);\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/stress\/TestStressLongArrayCopy.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @key stress randomness\n+ * @library \/test\/lib\n+ * @build TestStressObjectArrayCopy\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ *\n+ * @run main\/othervm\/timeout=960\n+ *      -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *      StressArrayCopyDriver TestStressObjectArrayCopy\n+ *\/\n+\n+import java.util.Arrays;\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n+public class TestStressObjectArrayCopy extends AbstractStressArrayCopy {\n+\n+    private static final Object[] orig = new Object[MAX_SIZE];\n+    private static final Object[] test = new Object[MAX_SIZE];\n+\n+    protected void testWith(int size, int l, int r, int len) {\n+        \/\/ Seed the test from the original\n+        System.arraycopy(orig, 0, test, 0, size);\n+\n+        \/\/ Check the seed is correct\n+        {\n+            int m = Arrays.mismatch(test, 0, size,\n+                                    orig, 0, size);\n+            if (m != -1) {\n+                throwSeedError(size, m);\n+            }\n+        }\n+\n+        \/\/ Perform the tested copy\n+        System.arraycopy(test, l, test, r, len);\n+\n+        \/\/ Check the copy has proper contents\n+        {\n+            int m = Arrays.mismatch(test, r, r+len,\n+                                    orig, l, l+len);\n+            if (m != -1) {\n+                throwContentsError(l, r, len, r+m);\n+            }\n+        }\n+\n+        \/\/ Check anything else was not affected: head and tail\n+        {\n+            int m = Arrays.mismatch(test, 0, r,\n+                                    orig, 0, r);\n+            if (m != -1) {\n+                throwHeadError(l, r, len, m);\n+            }\n+        }\n+        {\n+            int m = Arrays.mismatch(test, r + len, size,\n+                                    orig, r + len, size);\n+            if (m != -1) {\n+                throwTailError(l, r, len, m);\n+            }\n+        }\n+    }\n+\n+    public static void main(String... args) {\n+        Random rand = Utils.getRandomInstance();\n+        for (int c = 0; c < orig.length; c++) {\n+            orig[c] = new Object();\n+        }\n+        new TestStressObjectArrayCopy().run(rand);\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/stress\/TestStressObjectArrayCopy.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @key stress randomness\n+ * @library \/test\/lib\n+ * @build TestStressShortArrayCopy\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ *\n+ * @run main\/othervm\/timeout=960\n+ *      -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *      StressArrayCopyDriver TestStressShortArrayCopy\n+ *\/\n+\n+import java.util.Arrays;\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n+public class TestStressShortArrayCopy extends AbstractStressArrayCopy {\n+\n+    private static final short[] orig = new short[MAX_SIZE];\n+    private static final short[] test = new short[MAX_SIZE];\n+\n+    protected void testWith(int size, int l, int r, int len) {\n+        \/\/ Seed the test from the original\n+        System.arraycopy(orig, 0, test, 0, size);\n+\n+        \/\/ Check the seed is correct\n+        {\n+            int m = Arrays.mismatch(test, 0, size,\n+                                    orig, 0, size);\n+            if (m != -1) {\n+                throwSeedError(size, m);\n+            }\n+        }\n+\n+        \/\/ Perform the tested copy\n+        System.arraycopy(test, l, test, r, len);\n+\n+        \/\/ Check the copy has proper contents\n+        {\n+            int m = Arrays.mismatch(test, r, r+len,\n+                                    orig, l, l+len);\n+            if (m != -1) {\n+                throwContentsError(l, r, len, r+m);\n+            }\n+        }\n+\n+        \/\/ Check anything else was not affected: head and tail\n+        {\n+            int m = Arrays.mismatch(test, 0, r,\n+                                    orig, 0, r);\n+            if (m != -1) {\n+                throwHeadError(l, r, len, m);\n+            }\n+        }\n+        {\n+            int m = Arrays.mismatch(test, r + len, size,\n+                                    orig, r + len, size);\n+            if (m != -1) {\n+                throwTailError(l, r, len, m);\n+            }\n+        }\n+    }\n+\n+    public static void main(String... args) {\n+        Random rand = Utils.getRandomInstance();\n+        for (int c = 0; c < orig.length; c++) {\n+            orig[c] = (short)rand.nextInt();\n+        }\n+        new TestStressShortArrayCopy().run(rand);\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/stress\/TestStressShortArrayCopy.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"}]}