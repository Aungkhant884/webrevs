{"files":[{"patch":"@@ -17074,1 +17074,1 @@\n-instruct has_negatives(iRegP_R1 ary1, iRegI_R2 len, iRegI_R0 result, rFlagsReg cr)\n+instruct count_positives(iRegP_R1 ary1, iRegI_R2 len, iRegI_R0 result, rFlagsReg cr)\n@@ -17076,1 +17076,1 @@\n-  match(Set result (HasNegatives ary1 len));\n+  match(Set result (CountPositives ary1 len));\n@@ -17078,1 +17078,1 @@\n-  format %{ \"has negatives byte[] $ary1,$len -> $result\" %}\n+  format %{ \"count positives byte[] $ary1,$len -> $result\" %}\n@@ -17080,1 +17080,1 @@\n-    address tpc = __ has_negatives($ary1$$Register, $len$$Register, $result$$Register);\n+    address tpc = __ count_positives($ary1$$Register, $len$$Register, $result$$Register);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -4342,2 +4342,2 @@\n-\/\/ This method checks if provided byte array contains byte with highest bit set.\n-address MacroAssembler::has_negatives(Register ary1, Register len, Register result) {\n+\/\/ This method counts leading positive bytes (highest bit not set) in provided byte array\n+address MacroAssembler::count_positives(Register ary1, Register len, Register result) {\n@@ -4350,0 +4350,1 @@\n+    mov(result, len);\n@@ -4351,1 +4352,1 @@\n-    br(LE, SET_RESULT);\n+    br(LE, DONE);\n@@ -4370,1 +4371,1 @@\n-    br(EQ, SET_RESULT);\n+    br(EQ, DONE);\n@@ -4373,5 +4374,6 @@\n-    ldr(result, Address(ary1));\n-    sub(len, zr, len, LSL, 3); \/\/ LSL 3 is to get bits from bytes\n-    lslv(result, result, len);\n-    tst(result, UPPER_BIT_MASK);\n-    b(SET_RESULT);\n+    ldr(rscratch1, Address(ary1));\n+    sub(rscratch2, zr, len, LSL, 3); \/\/ LSL 3 is to get bits from bytes\n+    lslv(rscratch1, rscratch1, rscratch2);\n+    tst(rscratch1, UPPER_BIT_MASK);\n+    br(NE, SET_RESULT);\n+    b(DONE);\n@@ -4380,3 +4382,3 @@\n-    RuntimeAddress has_neg = RuntimeAddress(StubRoutines::aarch64::has_negatives());\n-    assert(has_neg.target() != NULL, \"has_negatives stub has not been generated\");\n-    address tpc1 = trampoline_call(has_neg);\n+    RuntimeAddress count_pos = RuntimeAddress(StubRoutines::aarch64::count_positives());\n+    assert(count_pos.target() != NULL, \"count_positives stub has not been generated\");\n+    address tpc1 = trampoline_call(count_pos);\n@@ -4391,3 +4393,3 @@\n-    RuntimeAddress has_neg_long = RuntimeAddress(StubRoutines::aarch64::has_negatives_long());\n-    assert(has_neg_long.target() != NULL, \"has_negatives stub has not been generated\");\n-    address tpc2 = trampoline_call(has_neg_long);\n+    RuntimeAddress count_pos_long = RuntimeAddress(StubRoutines::aarch64::count_positives_long());\n+    assert(count_pos_long.target() != NULL, \"count_positives_long stub has not been generated\");\n+    address tpc2 = trampoline_call(count_pos_long);\n@@ -4402,1 +4404,3 @@\n-    cset(result, NE); \/\/ set true or false\n+\n+    add(len, len, wordSize);\n+    sub(result, result, len);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":20,"deletions":16,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -1237,1 +1237,1 @@\n-  address has_negatives(Register ary1, Register len, Register result);\n+  address count_positives(Register ary1, Register len, Register result);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4660,1 +4660,1 @@\n-  address generate_has_negatives(address &has_negatives_long) {\n+  address generate_count_positives(address &count_positives_long) {\n@@ -4669,1 +4669,1 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"has_negatives\");\n+    StubCodeMark mark(this, \"StubRoutines\", \"count_positives\");\n@@ -4674,0 +4674,2 @@\n+    \/\/ precondition: a copy of len is already in result\n+    \/\/ __ mov(result, len);\n@@ -4675,1 +4677,1 @@\n-  Label RET_TRUE, RET_TRUE_NO_POP, RET_FALSE, ALIGNED, LOOP16, CHECK_16,\n+  Label RET_ADJUST, RET_ADJUST_16, RET_ADJUST_LONG, RET_NO_POP, RET_LEN, ALIGNED, LOOP16, CHECK_16,\n@@ -4689,1 +4691,1 @@\n-  __ cset(result, Assembler::NE);\n+  __ csel(result, zr, result, Assembler::NE);\n@@ -4696,1 +4698,1 @@\n-  __ br(Assembler::NE, RET_TRUE_NO_POP);\n+  __ br(Assembler::NE, RET_NO_POP);\n@@ -4700,1 +4702,2 @@\n-  __ cset(result, Assembler::NE);\n+  __ bind(RET_NO_POP);\n+  __ csel(result, zr, result, Assembler::NE);\n@@ -4707,1 +4710,1 @@\n-  has_negatives_long = __ pc(); \/\/ 2nd entry point\n+  count_positives_long = __ pc(); \/\/ 2nd entry point\n@@ -4719,1 +4722,0 @@\n-    __ sub(len, len, rscratch1);\n@@ -4722,1 +4724,2 @@\n-    __ br(Assembler::NE, RET_TRUE);\n+    __ br(Assembler::NE, RET_ADJUST);\n+    __ sub(len, len, rscratch1);\n@@ -4737,1 +4740,1 @@\n-    __ br(Assembler::NE, RET_TRUE);\n+    __ br(Assembler::NE, RET_ADJUST_16);\n@@ -4769,1 +4772,1 @@\n-    __ br(Assembler::NE, RET_TRUE);\n+    __ br(Assembler::NE, RET_ADJUST_LONG);\n@@ -4782,1 +4785,1 @@\n-    __ br(Assembler::NE, RET_TRUE);\n+    __ br(Assembler::NE, RET_ADJUST_16);\n@@ -4790,1 +4793,0 @@\n-    __ sub(len, len, 8);\n@@ -4792,1 +4794,2 @@\n-    __ br(Assembler::NE, RET_TRUE);\n+    __ br(Assembler::NE, RET_ADJUST);\n+    __ sub(len, len, 8);\n@@ -4795,1 +4798,1 @@\n-    __ cbz(len, RET_FALSE); \/\/ Can't shift left by 64 when len==0\n+    __ cbz(len, RET_LEN); \/\/ Can't shift left by 64 when len==0\n@@ -4801,1 +4804,1 @@\n-    __ br(Assembler::NE, RET_TRUE);\n+    __ br(Assembler::NE, RET_ADJUST);\n@@ -4804,1 +4807,1 @@\n-  __ bind(RET_FALSE);\n+  __ bind(RET_LEN);\n@@ -4807,1 +4810,0 @@\n-    __ mov(result, zr);\n@@ -4810,1 +4812,8 @@\n-  __ bind(RET_TRUE);\n+    \/\/ difference result - len is the count of guaranteed to be\n+    \/\/ positive bytes\n+\n+  __ bind(RET_ADJUST_LONG);\n+    __ add(len, len, (u1)(large_loop_size - 16));\n+  __ bind(RET_ADJUST_16);\n+    __ add(len, len, 16);\n+  __ bind(RET_ADJUST);\n@@ -4812,1 +4821,0 @@\n-  __ bind(RET_TRUE_NO_POP);\n@@ -4814,1 +4822,1 @@\n-    __ mov(result, 1);\n+    __ sub(result, result, len);\n@@ -7518,2 +7526,2 @@\n-    \/\/ has negatives stub for large arrays.\n-    StubRoutines::aarch64::_has_negatives = generate_has_negatives(StubRoutines::aarch64::_has_negatives_long);\n+    \/\/ countPositives stub for large arrays.\n+    StubRoutines::aarch64::_count_positives = generate_count_positives(StubRoutines::aarch64::_count_positives_long);\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":31,"deletions":23,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -48,2 +48,2 @@\n-address StubRoutines::aarch64::_has_negatives = NULL;\n-address StubRoutines::aarch64::_has_negatives_long = NULL;\n+address StubRoutines::aarch64::_count_positives = NULL;\n+address StubRoutines::aarch64::_count_positives_long = NULL;\n","filename":"src\/hotspot\/cpu\/aarch64\/stubRoutines_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -79,2 +79,2 @@\n-  static address _has_negatives;\n-  static address _has_negatives_long;\n+  static address _count_positives;\n+  static address _count_positives_long;\n@@ -135,2 +135,2 @@\n-  static address has_negatives() {\n-    return _has_negatives;\n+  static address count_positives() {\n+    return _count_positives;\n@@ -139,2 +139,2 @@\n-  static address has_negatives_long() {\n-      return _has_negatives_long;\n+  static address count_positives_long() {\n+      return _count_positives_long;\n","filename":"src\/hotspot\/cpu\/aarch64\/stubRoutines_aarch64.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -568,2 +568,2 @@\n-void C2_MacroAssembler::has_negatives(Register src, Register cnt, Register result,\n-                                      Register tmp1, Register tmp2) {\n+void C2_MacroAssembler::count_positives(Register src, Register cnt, Register result,\n+                                        Register tmp1, Register tmp2) {\n@@ -572,1 +572,1 @@\n-  Label Lfastloop, Lslow, Lloop, Lnoneg, Ldone;\n+  Label Lfastloop, Lslow, Lloop, Ldone;\n@@ -577,1 +577,1 @@\n-  li(result, 1);                  \/\/ Assume there's a negative byte.\n+  mr(result, src);                \/\/ Use result reg to point to the current position.\n@@ -585,2 +585,2 @@\n-  ld(tmp2, 0, src);\n-  ld(tmp0, 8, src);\n+  ld(tmp2, 0, result);\n+  ld(tmp0, 8, result);\n@@ -591,3 +591,2 @@\n-  bne(CCR0, Ldone);               \/\/ Found negative byte.\n-  addi(src, src, 16);\n-\n+  bne(CCR0, Lslow);               \/\/ Found negative byte.\n+  addi(result, result, 16);\n@@ -596,3 +595,4 @@\n-  bind(Lslow);                    \/\/ Fallback to slow version\n-  rldicl_(tmp0, cnt, 0, 64-4);\n-  beq(CCR0, Lnoneg);\n+  bind(Lslow);                    \/\/ Fallback to slow version.\n+  subf(tmp0, src, result);        \/\/ Bytes known positive.\n+  subf_(tmp0, tmp0, cnt);         \/\/ Remaining Bytes.\n+  beq(CCR0, Ldone);\n@@ -601,2 +601,1 @@\n-  lbz(tmp0, 0, src);\n-  addi(src, src, 1);\n+  lbz(tmp0, 0, result);\n@@ -605,0 +604,1 @@\n+  addi(result, result, 1);\n@@ -606,2 +606,0 @@\n-  bind(Lnoneg);\n-  li(result, 0);\n@@ -610,0 +608,1 @@\n+  subf(result, src, result);      \/\/ Result is offset from src.\n@@ -611,1 +610,0 @@\n-\n","filename":"src\/hotspot\/cpu\/ppc\/c2_MacroAssembler_ppc.cpp","additions":15,"deletions":17,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-  void has_negatives(Register src, Register cnt, Register result, Register tmp1, Register tmp2);\n+  void count_positives(Register src, Register cnt, Register result, Register tmp1, Register tmp2);\n","filename":"src\/hotspot\/cpu\/ppc\/c2_MacroAssembler_ppc.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -12782,2 +12782,2 @@\n-instruct has_negatives(rarg1RegP ary1, iRegIsrc len, iRegIdst result, iRegLdst tmp1, iRegLdst tmp2,\n-                       regCTR ctr, flagsRegCR0 cr0)\n+instruct count_positives(iRegPsrc ary1, iRegIsrc len, iRegIdst result, iRegLdst tmp1, iRegLdst tmp2,\n+                         regCTR ctr, flagsRegCR0 cr0)\n@@ -12785,2 +12785,2 @@\n-  match(Set result (HasNegatives ary1 len));\n-  effect(TEMP_DEF result, USE_KILL ary1, TEMP tmp1, TEMP tmp2, KILL ctr, KILL cr0);\n+  match(Set result (CountPositives ary1 len));\n+  effect(TEMP_DEF result, TEMP tmp1, TEMP tmp2, KILL ctr, KILL cr0);\n@@ -12788,1 +12788,1 @@\n-  format %{ \"has negatives byte[] $ary1,$len -> $result \\t\/\/ KILL $tmp1, $tmp2\" %}\n+  format %{ \"count positives byte[] $ary1,$len -> $result \\t\/\/ KILL $tmp1, $tmp2\" %}\n@@ -12790,2 +12790,2 @@\n-    __ has_negatives($ary1$$Register, $len$$Register, $result$$Register,\n-                     $tmp1$$Register, $tmp2$$Register);\n+    __ count_positives($ary1$$Register, $len$$Register, $result$$Register,\n+                       $tmp1$$Register, $tmp2$$Register);\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -826,46 +826,58 @@\n-\/\/ Kills src.\n-unsigned int C2_MacroAssembler::has_negatives(Register result, Register src, Register cnt,\n-                                              Register odd_reg, Register even_reg, Register tmp) {\n-  int block_start = offset();\n-  Label Lloop1, Lloop2, Lslow, Lnotfound, Ldone;\n-  const Register addr = src, mask = tmp;\n-\n-  BLOCK_COMMENT(\"has_negatives {\");\n-\n-  z_llgfr(Z_R1, cnt);      \/\/ Number of bytes to read. (Must be a positive simm32.)\n-  z_llilf(mask, 0x80808080);\n-  z_lhi(result, 1);        \/\/ Assume true.\n-  \/\/ Last possible addr for fast loop.\n-  z_lay(odd_reg, -16, Z_R1, src);\n-  z_chi(cnt, 16);\n-  z_brl(Lslow);\n-\n-  \/\/ ind1: index, even_reg: index increment, odd_reg: index limit\n-  z_iihf(mask, 0x80808080);\n-  z_lghi(even_reg, 16);\n-\n-  bind(Lloop1); \/\/ 16 bytes per iteration.\n-  z_lg(Z_R0, Address(addr));\n-  z_lg(Z_R1, Address(addr, 8));\n-  z_ogr(Z_R0, Z_R1);\n-  z_ngr(Z_R0, mask);\n-  z_brne(Ldone);           \/\/ If found return 1.\n-  z_brxlg(addr, even_reg, Lloop1);\n-\n-  bind(Lslow);\n-  z_aghi(odd_reg, 16-1);   \/\/ Last possible addr for slow loop.\n-  z_lghi(even_reg, 1);\n-  z_cgr(addr, odd_reg);\n-  z_brh(Lnotfound);\n-\n-  bind(Lloop2); \/\/ 1 byte per iteration.\n-  z_cli(Address(addr), 0x80);\n-  z_brnl(Ldone);           \/\/ If found return 1.\n-  z_brxlg(addr, even_reg, Lloop2);\n-\n-  bind(Lnotfound);\n-  z_lhi(result, 0);\n-\n-  bind(Ldone);\n-\n-  BLOCK_COMMENT(\"} has_negatives\");\n+\/\/ Returns the number of non-negative bytes (aka US-ASCII characters) found\n+\/\/ before the first negative byte is encountered.\n+unsigned int C2_MacroAssembler::count_positives(Register result, Register src, Register cnt, Register tmp) {\n+  const unsigned int block_start   = offset();\n+  const unsigned int byte_mask     = 0x80;\n+  const unsigned int twobyte_mask  = byte_mask<<8 | byte_mask;\n+  const unsigned int unroll_factor = 16;\n+  const unsigned int log_unroll_factor = exact_log2(unroll_factor);\n+  Register pos  = src;     \/\/ current position in src array, restored at end\n+  Register ctr  = result;  \/\/ loop counter, result value\n+  Register mask = tmp;     \/\/ holds the sign detection mask\n+  Label unrolledLoop, unrolledDone, byteLoop, allDone;\n+\n+  assert_different_registers(result, src, cnt, tmp);\n+\n+  BLOCK_COMMENT(\"count_positives {\");\n+\n+  lgr_if_needed(pos, src);              \/\/ current position in src array\n+  z_srak(ctr, cnt, log_unroll_factor);  \/\/ # iterations of unrolled loop\n+  z_brnh(unrolledDone);                 \/\/ array too short for unrolled loop\n+\n+  z_iilf(mask, twobyte_mask<<16 | twobyte_mask);\n+  z_iihf(mask, twobyte_mask<<16 | twobyte_mask);\n+\n+  bind(unrolledLoop);\n+    z_lmg(Z_R0, Z_R1, 0, pos);\n+    z_ogr(Z_R0, Z_R1);\n+    z_ngr(Z_R0, mask);\n+    z_brne(unrolledDone);               \/\/ There is a negative byte somewhere.\n+                                        \/\/ ctr and pos are not updated yet ->\n+                                        \/\/ delegate finding correct pos to byteLoop.\n+    add2reg(pos, unroll_factor);\n+    z_brct(ctr, unrolledLoop);\n+\n+  \/\/ Once we arrive here, we have to examine at most (unroll_factor - 1) bytes more.\n+  \/\/ We then either have reached the end of the array or we hit a negative byte.\n+  bind(unrolledDone);\n+  z_sll(ctr, log_unroll_factor);        \/\/ calculate # bytes not processed by unrolled loop\n+                                        \/\/ > 0 only if a negative byte was found\n+  z_lr(Z_R0, cnt);                      \/\/ calculate remainder bytes\n+  z_nilf(Z_R0, unroll_factor - 1);\n+  z_ar(ctr, Z_R0);                      \/\/ remaining bytes\n+  z_brnh(allDone);                      \/\/ shortcut if nothing left to do\n+\n+  bind(byteLoop);\n+    z_cli(0, pos, byte_mask);           \/\/ unsigned comparison! byte@pos must be smaller that byte_mask\n+    z_brnl(allDone);                    \/\/ negative byte found.\n+\n+    add2reg(pos, 1);\n+    z_brct(ctr, byteLoop);\n+\n+  bind(allDone);\n+\n+  z_srk(ctr, cnt, ctr);                 \/\/ # bytes actually processed (= cnt or index of first negative byte)\n+  z_sgfr(pos, ctr);                     \/\/ restore src\n+  z_lgfr(result, ctr);                  \/\/ unnecessary. Only there to be sure the high word has a defined state.\n+\n+  BLOCK_COMMENT(\"} count_positives\");\n","filename":"src\/hotspot\/cpu\/s390\/c2_MacroAssembler_s390.cpp","additions":58,"deletions":46,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -60,3 +60,1 @@\n-  \/\/ Kills src.\n-  unsigned int has_negatives(Register result, Register src, Register cnt,\n-                             Register odd_reg, Register even_reg, Register tmp);\n+  unsigned int count_positives(Register result, Register src, Register cnt, Register tmp);\n","filename":"src\/hotspot\/cpu\/s390\/c2_MacroAssembler_s390.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -10276,3 +10276,3 @@\n-instruct has_negatives(rarg5RegP ary1, iRegI len, iRegI result, roddRegI oddReg, revenRegI evenReg, iRegI tmp, flagsReg cr) %{\n-  match(Set result (HasNegatives ary1 len));\n-  effect(TEMP_DEF result, USE_KILL ary1, TEMP oddReg, TEMP evenReg, TEMP tmp, KILL cr); \/\/ R0, R1 are killed, too.\n+instruct count_positives(iRegP ary1, iRegI len, iRegI result, iRegI tmp, flagsReg cr) %{\n+  match(Set result (CountPositives ary1 len));\n+  effect(TEMP_DEF result, TEMP tmp, KILL cr); \/\/ R0, R1 are killed, too.\n@@ -10280,1 +10280,1 @@\n-  format %{ \"has negatives byte[] $ary1($len) -> $result\" %}\n+  format %{ \"count positives byte[] $ary1($len) -> $result\" %}\n@@ -10282,2 +10282,1 @@\n-    __ has_negatives($result$$Register, $ary1$$Register, $len$$Register,\n-                     $oddReg$$Register, $evenReg$$Register, $tmp$$Register);\n+    __ count_positives($result$$Register, $ary1$$Register, $len$$Register, $tmp$$Register);\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -3377,1 +3377,2 @@\n-\/\/ return true if it has any and false otherwise.\n+\/\/ return the index of the first such character, otherwise the length\n+\/\/ of the array segment searched.\n@@ -3380,1 +3381,1 @@\n-\/\/   private static boolean hasNegatives(byte[] ba, int off, int len) {\n+\/\/   public static int countPositives(byte[] ba, int off, int len) {\n@@ -3383,1 +3384,1 @@\n-\/\/         return true;\n+\/\/         return i - off;\n@@ -3386,1 +3387,1 @@\n-\/\/     return false;\n+\/\/     return len;\n@@ -3388,1 +3389,1 @@\n-void C2_MacroAssembler::has_negatives(Register ary1, Register len,\n+void C2_MacroAssembler::count_positives(Register ary1, Register len,\n@@ -3397,1 +3398,1 @@\n-  Label TRUE_LABEL, FALSE_LABEL, DONE, COMPARE_CHAR, COMPARE_VECTORS, COMPARE_BYTE;\n+  Label ADJUST, TAIL_ADJUST, DONE, TAIL_START, CHAR_ADJUST, COMPARE_CHAR, COMPARE_VECTORS, COMPARE_BYTE;\n@@ -3399,0 +3400,1 @@\n+  movl(result, len); \/\/ copy\n@@ -3401,1 +3403,1 @@\n-  jcc(Assembler::zero, FALSE_LABEL);\n+  jcc(Assembler::zero, DONE);\n@@ -3407,1 +3409,1 @@\n-    Label test_64_loop, test_tail;\n+    Label test_64_loop, test_tail, BREAK_LOOP;\n@@ -3424,1 +3426,1 @@\n-    jcc(Assembler::notZero, TRUE_LABEL);\n+    jcc(Assembler::notZero, BREAK_LOOP);\n@@ -3429,1 +3431,0 @@\n-\n@@ -3433,1 +3434,1 @@\n-    jcc(Assembler::zero, FALSE_LABEL);\n+    jcc(Assembler::zero, DONE);\n@@ -3470,1 +3471,1 @@\n-    jcc(Assembler::notZero, TRUE_LABEL);\n+    jcc(Assembler::zero, DONE);\n@@ -3472,1 +3473,11 @@\n-    jmp(FALSE_LABEL);\n+    bind(BREAK_LOOP);\n+    \/\/ At least one byte in the last 64 bytes is negative.\n+    \/\/ Set up to look at the last 64 bytes as if they were a tail\n+    lea(ary1, Address(ary1, len, Address::times_1));\n+    addptr(result, len);\n+    \/\/ Ignore the very last byte: if all others are positive,\n+    \/\/ it must be negative, so we can skip right to the 2+1 byte\n+    \/\/ end comparison at this point\n+    orl(result, 63);\n+    movl(len, 63);\n+    \/\/ Fallthru to tail compare\n@@ -3474,1 +3485,0 @@\n-    movl(result, len); \/\/ copy\n@@ -3478,1 +3488,1 @@\n-      Label COMPARE_WIDE_VECTORS, COMPARE_TAIL;\n+      Label COMPARE_WIDE_VECTORS, BREAK_LOOP;\n@@ -3481,3 +3491,2 @@\n-      andl(result, 0x0000001f);  \/\/   tail count (in bytes)\n-      andl(len, 0xffffffe0);   \/\/ vector count (in bytes)\n-      jccb(Assembler::zero, COMPARE_TAIL);\n+      testl(len, 0xffffffe0);   \/\/ vector count (in bytes)\n+      jccb(Assembler::zero, TAIL_START);\n@@ -3485,0 +3494,1 @@\n+      andl(len, 0xffffffe0);\n@@ -3495,1 +3505,1 @@\n-      jccb(Assembler::notZero, TRUE_LABEL);\n+      jccb(Assembler::notZero, BREAK_LOOP);\n@@ -3497,1 +3507,1 @@\n-      jcc(Assembler::notZero, COMPARE_WIDE_VECTORS);\n+      jccb(Assembler::notZero, COMPARE_WIDE_VECTORS);\n@@ -3499,2 +3509,2 @@\n-      testl(result, result);\n-      jccb(Assembler::zero, FALSE_LABEL);\n+      testl(result, 0x0000001f);   \/\/ any bytes remaining?\n+      jcc(Assembler::zero, DONE);\n@@ -3502,1 +3512,4 @@\n-      vmovdqu(vec1, Address(ary1, result, Address::times_1, -32));\n+      \/\/ Quick test using the already prepared vector mask\n+      movl(len, result);\n+      andl(len, 0x0000001f);\n+      vmovdqu(vec1, Address(ary1, len, Address::times_1, -32));\n@@ -3504,2 +3517,3 @@\n-      jccb(Assembler::notZero, TRUE_LABEL);\n-      jmpb(FALSE_LABEL);\n+      jcc(Assembler::zero, DONE);\n+      \/\/ There are zeros, jump to the tail to determine exactly where\n+      jmpb(TAIL_START);\n@@ -3507,2 +3521,10 @@\n-      bind(COMPARE_TAIL); \/\/ len is zero\n-      movl(len, result);\n+      bind(BREAK_LOOP);\n+      \/\/ At least one byte in the last 32-byte vector is negative.\n+      \/\/ Set up to look at the last 32 bytes as if they were a tail\n+      lea(ary1, Address(ary1, len, Address::times_1));\n+      addptr(result, len);\n+      \/\/ Ignore the very last byte: if all others are positive,\n+      \/\/ it must be negative, so we can skip right to the 2+1 byte\n+      \/\/ end comparison at this point\n+      orl(result, 31);\n+      movl(len, 31);\n@@ -3512,1 +3534,1 @@\n-      Label COMPARE_WIDE_VECTORS, COMPARE_TAIL;\n+      Label COMPARE_WIDE_VECTORS, BREAK_LOOP;\n@@ -3515,3 +3537,2 @@\n-      andl(result, 0x0000000f);  \/\/   tail count (in bytes)\n-      andl(len, 0xfffffff0);   \/\/ vector count (in bytes)\n-      jcc(Assembler::zero, COMPARE_TAIL);\n+      testl(len, 0xfffffff0);   \/\/ vector count (in bytes)\n+      jcc(Assembler::zero, TAIL_START);\n@@ -3519,0 +3540,1 @@\n+      andl(len, 0xfffffff0);\n@@ -3529,1 +3551,1 @@\n-      jcc(Assembler::notZero, TRUE_LABEL);\n+      jccb(Assembler::notZero, BREAK_LOOP);\n@@ -3531,1 +3553,1 @@\n-      jcc(Assembler::notZero, COMPARE_WIDE_VECTORS);\n+      jccb(Assembler::notZero, COMPARE_WIDE_VECTORS);\n@@ -3533,2 +3555,2 @@\n-      testl(result, result);\n-      jcc(Assembler::zero, FALSE_LABEL);\n+      testl(result, 0x0000000f); \/\/ len is zero, any bytes remaining?\n+      jcc(Assembler::zero, DONE);\n@@ -3536,1 +3558,4 @@\n-      movdqu(vec1, Address(ary1, result, Address::times_1, -16));\n+      \/\/ Quick test using the already prepared vector mask\n+      movl(len, result);\n+      andl(len, 0x0000000f);   \/\/ tail count (in bytes)\n+      movdqu(vec1, Address(ary1, len, Address::times_1, -16));\n@@ -3538,2 +3563,2 @@\n-      jccb(Assembler::notZero, TRUE_LABEL);\n-      jmpb(FALSE_LABEL);\n+      jcc(Assembler::zero, DONE);\n+      jmpb(TAIL_START);\n@@ -3541,2 +3566,10 @@\n-      bind(COMPARE_TAIL); \/\/ len is zero\n-      movl(len, result);\n+      bind(BREAK_LOOP);\n+      \/\/ At least one byte in the last 16-byte vector is negative.\n+      \/\/ Set up and look at the last 16 bytes as if they were a tail\n+      lea(ary1, Address(ary1, len, Address::times_1));\n+      addptr(result, len);\n+      \/\/ Ignore the very last byte: if all others are positive,\n+      \/\/ it must be negative, so we can skip right to the 2+1 byte\n+      \/\/ end comparison at this point\n+      orl(result, 15);\n+      movl(len, 15);\n@@ -3546,0 +3579,2 @@\n+\n+  bind(TAIL_START);\n@@ -3556,1 +3591,1 @@\n-  jccb(Assembler::notZero, TRUE_LABEL);\n+  jccb(Assembler::notZero, TAIL_ADJUST);\n@@ -3558,1 +3593,1 @@\n-  jcc(Assembler::notZero, COMPARE_VECTORS);\n+  jccb(Assembler::notZero, COMPARE_VECTORS);\n@@ -3560,1 +3595,1 @@\n-  \/\/ Compare trailing char (final 2 bytes), if any\n+  \/\/ Compare trailing char (final 2-3 bytes), if any\n@@ -3562,0 +3597,1 @@\n+\n@@ -3566,2 +3602,1 @@\n-  jccb(Assembler::notZero, TRUE_LABEL);\n-  subptr(result, 2);\n+  jccb(Assembler::notZero, CHAR_ADJUST);\n@@ -3572,1 +3607,1 @@\n-  jccb(Assembler::zero, FALSE_LABEL);\n+  jccb(Assembler::zero, DONE);\n@@ -3574,6 +3609,3 @@\n-  andl(tmp1, 0x00000080);\n-  jccb(Assembler::notEqual, TRUE_LABEL);\n-  jmpb(FALSE_LABEL);\n-\n-  bind(TRUE_LABEL);\n-  movl(result, 1);   \/\/ return true\n+  testl(tmp1, 0x00000080);\n+  jccb(Assembler::zero, DONE);\n+  subptr(result, 1);\n@@ -3582,2 +3614,16 @@\n-  bind(FALSE_LABEL);\n-  xorl(result, result); \/\/ return false\n+  bind(TAIL_ADJUST);\n+  \/\/ there are negative bits in the last 4 byte block.\n+  \/\/ Adjust result and check the next three bytes\n+  addptr(result, len);\n+  orl(result, 3);\n+  lea(ary1, Address(ary1, len, Address::times_1));\n+  jmpb(COMPARE_CHAR);\n+\n+  bind(CHAR_ADJUST);\n+  \/\/ We are looking at a char + optional byte tail, and found that one\n+  \/\/ of the bytes in the char is negative. Adjust the result, check the\n+  \/\/ first byte and readjust if needed.\n+  andl(result, 0xfffffffc);\n+  testl(tmp1, 0x00000080); \/\/ little-endian, so lowest byte comes first\n+  jccb(Assembler::notZero, DONE);\n+  addptr(result, 1);\n@@ -3593,0 +3639,1 @@\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":101,"deletions":54,"binary":false,"changes":155,"status":"modified"},{"patch":"@@ -274,5 +274,4 @@\n-  \/\/ return true if it has any and false otherwise.\n-  void has_negatives(Register ary1, Register len,\n-                     Register result, Register tmp1,\n-                     XMMRegister vec1, XMMRegister vec2, KRegister mask1 = knoreg, KRegister mask2 = knoreg);\n-\n+  \/\/ return index of the first such character, otherwise len.\n+  void count_positives(Register ary1, Register len,\n+                       Register result, Register tmp1,\n+                       XMMRegister vec1, XMMRegister vec2, KRegister mask1 = knoreg, KRegister mask2 = knoreg);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -12125,2 +12125,2 @@\n-instruct has_negatives(eSIRegP ary1, eCXRegI len, eAXRegI result,\n-                      regD tmp1, regD tmp2, eBXRegI tmp3, eFlagsReg cr)\n+instruct count_positives(eSIRegP ary1, eCXRegI len, eAXRegI result,\n+                         regD tmp1, regD tmp2, eBXRegI tmp3, eFlagsReg cr)\n@@ -12129,1 +12129,1 @@\n-  match(Set result (HasNegatives ary1 len));\n+  match(Set result (CountPositives ary1 len));\n@@ -12132,1 +12132,1 @@\n-  format %{ \"has negatives byte[] $ary1,$len -> $result   \/\/ KILL $tmp1, $tmp2, $tmp3\" %}\n+  format %{ \"countPositives byte[] $ary1,$len -> $result   \/\/ KILL $tmp1, $tmp2, $tmp3\" %}\n@@ -12134,3 +12134,3 @@\n-    __ has_negatives($ary1$$Register, $len$$Register,\n-                     $result$$Register, $tmp3$$Register,\n-                     $tmp1$$XMMRegister, $tmp2$$XMMRegister, knoreg, knoreg);\n+    __ count_positives($ary1$$Register, $len$$Register,\n+                       $result$$Register, $tmp3$$Register,\n+                       $tmp1$$XMMRegister, $tmp2$$XMMRegister, knoreg, knoreg);\n@@ -12141,2 +12141,2 @@\n-instruct has_negatives_evex(eSIRegP ary1, eCXRegI len, eAXRegI result,\n-                           regD tmp1, regD tmp2, kReg ktmp1, kReg ktmp2, eBXRegI tmp3, eFlagsReg cr)\n+instruct count_positives_evex(eSIRegP ary1, eCXRegI len, eAXRegI result,\n+                              regD tmp1, regD tmp2, kReg ktmp1, kReg ktmp2, eBXRegI tmp3, eFlagsReg cr)\n@@ -12145,1 +12145,1 @@\n-  match(Set result (HasNegatives ary1 len));\n+  match(Set result (CountPositives ary1 len));\n@@ -12148,1 +12148,1 @@\n-  format %{ \"has negatives byte[] $ary1,$len -> $result   \/\/ KILL $tmp1, $tmp2, $tmp3\" %}\n+  format %{ \"countPositives byte[] $ary1,$len -> $result   \/\/ KILL $tmp1, $tmp2, $tmp3\" %}\n@@ -12150,3 +12150,3 @@\n-    __ has_negatives($ary1$$Register, $len$$Register,\n-                     $result$$Register, $tmp3$$Register,\n-                     $tmp1$$XMMRegister, $tmp2$$XMMRegister, $ktmp1$$KRegister, $ktmp2$$KRegister);\n+    __ count_positives($ary1$$Register, $len$$Register,\n+                       $result$$Register, $tmp3$$Register,\n+                       $tmp1$$XMMRegister, $tmp2$$XMMRegister, $ktmp1$$KRegister, $ktmp2$$KRegister);\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -11688,2 +11688,2 @@\n-instruct has_negatives(rsi_RegP ary1, rcx_RegI len, rax_RegI result,\n-                       legRegD tmp1, legRegD tmp2, rbx_RegI tmp3, rFlagsReg cr,)\n+instruct count_positives(rsi_RegP ary1, rcx_RegI len, rax_RegI result,\n+                         legRegD tmp1, legRegD tmp2, rbx_RegI tmp3, rFlagsReg cr,)\n@@ -11692,1 +11692,1 @@\n-  match(Set result (HasNegatives ary1 len));\n+  match(Set result (CountPositives ary1 len));\n@@ -11695,1 +11695,1 @@\n-  format %{ \"has negatives byte[] $ary1,$len -> $result   \/\/ KILL $tmp1, $tmp2, $tmp3\" %}\n+  format %{ \"countPositives byte[] $ary1,$len -> $result   \/\/ KILL $tmp1, $tmp2, $tmp3\" %}\n@@ -11697,3 +11697,3 @@\n-    __ has_negatives($ary1$$Register, $len$$Register,\n-                     $result$$Register, $tmp3$$Register,\n-                     $tmp1$$XMMRegister, $tmp2$$XMMRegister, knoreg, knoreg);\n+    __ count_positives($ary1$$Register, $len$$Register,\n+                       $result$$Register, $tmp3$$Register,\n+                       $tmp1$$XMMRegister, $tmp2$$XMMRegister, knoreg, knoreg);\n@@ -11704,2 +11704,2 @@\n-instruct has_negatives_evex(rsi_RegP ary1, rcx_RegI len, rax_RegI result,\n-                            legRegD tmp1, legRegD tmp2, kReg ktmp1, kReg ktmp2, rbx_RegI tmp3, rFlagsReg cr,)\n+instruct count_positives_evex(rsi_RegP ary1, rcx_RegI len, rax_RegI result,\n+                              legRegD tmp1, legRegD tmp2, kReg ktmp1, kReg ktmp2, rbx_RegI tmp3, rFlagsReg cr,)\n@@ -11708,1 +11708,1 @@\n-  match(Set result (HasNegatives ary1 len));\n+  match(Set result (CountPositives ary1 len));\n@@ -11711,1 +11711,1 @@\n-  format %{ \"has negatives byte[] $ary1,$len -> $result   \/\/ KILL $tmp1, $tmp2, $tmp3\" %}\n+  format %{ \"countPositives byte[] $ary1,$len -> $result   \/\/ KILL $tmp1, $tmp2, $tmp3\" %}\n@@ -11713,3 +11713,3 @@\n-    __ has_negatives($ary1$$Register, $len$$Register,\n-                     $result$$Register, $tmp3$$Register,\n-                     $tmp1$$XMMRegister, $tmp2$$XMMRegister, $ktmp1$$KRegister, $ktmp2$$KRegister);\n+    __ count_positives($ary1$$Register, $len$$Register,\n+                       $result$$Register, $tmp3$$Register,\n+                       $tmp1$$XMMRegister, $tmp2$$XMMRegister, $ktmp1$$KRegister, $ktmp2$$KRegister);\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -615,1 +615,1 @@\n-        strcmp(_matrule->_rChild->_opType,\"HasNegatives\" )==0 ||\n+        strcmp(_matrule->_rChild->_opType,\"CountPositives\" )==0 ||\n@@ -905,1 +905,1 @@\n-        strcmp(_matrule->_rChild->_opType,\"HasNegatives\")==0 ||\n+        strcmp(_matrule->_rChild->_opType,\"CountPositives\")==0 ||\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -232,1 +232,1 @@\n-    case vmIntrinsics::_hasNegatives:\n+    case vmIntrinsics::_countPositives:\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -357,3 +357,3 @@\n-  do_intrinsic(_hasNegatives,             java_lang_StringCoding, hasNegatives_name, hasNegatives_signature,     F_S)   \\\n-   do_name(     hasNegatives_name,                               \"hasNegatives\")                                        \\\n-   do_signature(hasNegatives_signature,                          \"([BII)Z\")                                             \\\n+  do_intrinsic(_countPositives,     java_lang_StringCoding, countPositives_name, countPositives_signature, F_S)         \\\n+   do_name(     countPositives_name,                       \"countPositives\")                                            \\\n+   do_signature(countPositives_signature,                  \"([BII)I\")                                                   \\\n@@ -462,1 +462,1 @@\n-  do_intrinsic(_digestBase_implCompressMB, sun_security_provider_digestbase, implCompressMB_name, implCompressMB_signature, F_R)   \\\n+  do_intrinsic(_digestBase_implCompressMB, sun_security_provider_digestbase, implCompressMB_name, countPositives_signature, F_R)   \\\n@@ -464,1 +464,0 @@\n-   do_signature(implCompressMB_signature,                          \"([BII)I\")                                           \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -570,1 +570,1 @@\n-        Op_HasNegatives,\n+        Op_CountPositives,\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -745,2 +745,2 @@\n-  static_field(StubRoutines::aarch64, _has_negatives, address)          \\\n-  static_field(StubRoutines::aarch64, _has_negatives_long, address)     \\\n+  static_field(StubRoutines::aarch64, _count_positives, address)        \\\n+  static_field(StubRoutines::aarch64, _count_positives_long, address)   \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -237,2 +237,2 @@\n-  case vmIntrinsics::_hasNegatives:\n-    if (!Matcher::match_rule_supported(Op_HasNegatives))  return false;\n+  case vmIntrinsics::_countPositives:\n+    if (!Matcher::match_rule_supported(Op_CountPositives))  return false;\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -177,1 +177,1 @@\n-macro(HasNegatives)\n+macro(CountPositives)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -624,1 +624,1 @@\n-    case Op_HasNegatives:\n+    case Op_CountPositives:\n@@ -762,1 +762,1 @@\n-    case Op_HasNegatives:\n+    case Op_CountPositives:\n@@ -3326,1 +3326,2 @@\n-              op == Op_FastLock || op == Op_AryEq || op == Op_StrComp || op == Op_HasNegatives ||\n+              op == Op_FastLock || op == Op_AryEq || op == Op_StrComp ||\n+              op == Op_CountPositives ||\n@@ -3457,1 +3458,1 @@\n-              op == Op_AryEq || op == Op_StrComp || op == Op_HasNegatives ||\n+              op == Op_AryEq || op == Op_StrComp || op == Op_CountPositives ||\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -160,2 +160,2 @@\n-\/\/------------------------------HasNegatives---------------------------------\n-class HasNegativesNode: public StrIntrinsicNode {\n+\/\/------------------------------CountPositives------------------------------\n+class CountPositivesNode: public StrIntrinsicNode {\n@@ -163,1 +163,1 @@\n-  HasNegativesNode(Node* control, Node* char_array_mem, Node* s1, Node* c1):\n+  CountPositivesNode(Node* control, Node* char_array_mem, Node* s1, Node* c1):\n@@ -166,1 +166,1 @@\n-  virtual const Type* bottom_type() const { return TypeInt::BOOL; }\n+  virtual const Type* bottom_type() const { return TypeInt::POS; }\n","filename":"src\/hotspot\/share\/opto\/intrinsicnode.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -206,1 +206,1 @@\n-    case Op_HasNegatives:\n+    case Op_CountPositives:\n","filename":"src\/hotspot\/share\/opto\/lcm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -620,2 +620,2 @@\n-  case vmIntrinsics::_hasNegatives:\n-    return inline_hasNegatives();\n+  case vmIntrinsics::_countPositives:\n+    return inline_countPositives();\n@@ -1014,2 +1014,2 @@\n-\/\/------------------------------inline_hasNegatives------------------------------\n-bool LibraryCallKit::inline_hasNegatives() {\n+\/\/------------------------------inline_countPositives------------------------------\n+bool LibraryCallKit::inline_countPositives() {\n@@ -1020,1 +1020,1 @@\n-  assert(callee()->signature()->size() == 3, \"hasNegatives has 3 parameters\");\n+  assert(callee()->signature()->size() == 3, \"countPositives has 3 parameters\");\n@@ -1034,1 +1034,1 @@\n-  Node* result = new HasNegativesNode(control(), memory(TypeAryPtr::BYTES), ba_start, len);\n+  Node* result = new CountPositivesNode(control(), memory(TypeAryPtr::BYTES), ba_start, len);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -299,1 +299,1 @@\n-  bool inline_hasNegatives();\n+  bool inline_countPositives();\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -831,1 +831,1 @@\n-      case Op_HasNegatives: {\n+      case Op_CountPositives: {\n@@ -977,1 +977,1 @@\n-      case Op_HasNegatives: {\n+      case Op_CountPositives: {\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -5672,1 +5672,1 @@\n-    case Op_HasNegatives:\n+    case Op_CountPositives:\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1069,1 +1069,1 @@\n-    case Op_HasNegatives:\n+    case Op_CountPositives:\n@@ -2255,1 +2255,1 @@\n-    case Op_HasNegatives:\n+    case Op_CountPositives:\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -528,4 +528,7 @@\n-            if (COMPACT_STRINGS && !StringCoding.hasNegatives(bytes, offset, length)) {\n-                this.value = Arrays.copyOfRange(bytes, offset, offset + length);\n-                this.coder = LATIN1;\n-            } else {\n+            if (COMPACT_STRINGS) {\n+                int dp = StringCoding.countPositives(bytes, offset, length);\n+                if (dp == length) {\n+                    this.value = Arrays.copyOfRange(bytes, offset, offset + length);\n+                    this.coder = LATIN1;\n+                    return;\n+                }\n@@ -533,8 +536,15 @@\n-                int dp = 0;\n-                byte[] dst = null;\n-                if (COMPACT_STRINGS) {\n-                    dst = new byte[length];\n-                    while (offset < sl) {\n-                        int b1 = bytes[offset];\n-                        if (b1 >= 0) {\n-                            dst[dp++] = (byte)b1;\n+                byte[] dst = new byte[length];\n+                if (dp > 0) {\n+                    System.arraycopy(bytes, offset, dst, 0, dp);\n+                    offset += dp;\n+                }\n+                while (offset < sl) {\n+                    int b1 = bytes[offset++];\n+                    if (b1 >= 0) {\n+                        dst[dp++] = (byte)b1;\n+                        continue;\n+                    }\n+                    if ((b1 & 0xfe) == 0xc2 && offset < sl) { \/\/ b1 either 0xc2 or 0xc3\n+                        int b2 = bytes[offset];\n+                        if (b2 < -64) { \/\/ continuation bytes are always negative values in the range -128 to -65\n+                            dst[dp++] = (byte)decode2(b1, b2);\n@@ -544,19 +554,0 @@\n-                        if ((b1 & 0xfe) == 0xc2 && offset + 1 < sl) { \/\/ b1 either 0xc2 or 0xc3\n-                            int b2 = bytes[offset + 1];\n-                            if (!isNotContinuation(b2)) {\n-                                dst[dp++] = (byte)decode2(b1, b2);\n-                                offset += 2;\n-                                continue;\n-                            }\n-                        }\n-                        \/\/ anything not a latin1, including the repl\n-                        \/\/ we have to go with the utf16\n-                        break;\n-                    }\n-                    if (offset == sl) {\n-                        if (dp != dst.length) {\n-                            dst = Arrays.copyOf(dst, dp);\n-                        }\n-                        this.value = dst;\n-                        this.coder = LATIN1;\n-                        return;\n@@ -564,0 +555,4 @@\n+                    \/\/ anything not a latin1, including the REPL\n+                    \/\/ we have to go with the utf16\n+                    offset--;\n+                    break;\n@@ -565,6 +560,7 @@\n-                if (dp == 0 || dst == null) {\n-                    dst = new byte[length << 1];\n-                } else {\n-                    byte[] buf = new byte[length << 1];\n-                    StringLatin1.inflate(dst, 0, buf, 0, dp);\n-                    dst = buf;\n+                if (offset == sl) {\n+                    if (dp != dst.length) {\n+                        dst = Arrays.copyOf(dst, dp);\n+                    }\n+                    this.value = dst;\n+                    this.coder = LATIN1;\n+                    return;\n@@ -572,0 +568,3 @@\n+                byte[] buf = new byte[length << 1];\n+                StringLatin1.inflate(dst, 0, buf, 0, dp);\n+                dst = buf;\n@@ -578,0 +577,8 @@\n+            } else { \/\/ !COMPACT_STRINGS\n+                byte[] dst = new byte[length << 1];\n+                int dp = decodeUTF8_UTF16(bytes, offset, offset + length, dst, 0, true);\n+                if (dp != length) {\n+                    dst = Arrays.copyOf(dst, dp << 1);\n+                }\n+                this.value = dst;\n+                this.coder = UTF16;\n@@ -685,3 +692,4 @@\n-        if (COMPACT_STRINGS && !StringCoding.hasNegatives(bytes, offset, length)) {\n-            return new String(Arrays.copyOfRange(bytes, offset, offset + length), LATIN1);\n-        } else {\n+        int dp;\n+        byte[] dst;\n+        if (COMPACT_STRINGS) {\n+            dp = StringCoding.countPositives(bytes, offset, length);\n@@ -689,8 +697,16 @@\n-            int dp = 0;\n-            byte[] dst = null;\n-            if (COMPACT_STRINGS) {\n-                dst = new byte[length];\n-                while (offset < sl) {\n-                    int b1 = bytes[offset];\n-                    if (b1 >= 0) {\n-                        dst[dp++] = (byte) b1;\n+            if (dp == length) {\n+                return new String(Arrays.copyOfRange(bytes, offset, offset + length), LATIN1);\n+            }\n+            dst = new byte[length];\n+            System.arraycopy(bytes, offset, dst, 0, dp);\n+            offset += dp;\n+            while (offset < sl) {\n+                int b1 = bytes[offset++];\n+                if (b1 >= 0) {\n+                    dst[dp++] = (byte)b1;\n+                    continue;\n+                }\n+                if ((b1 & 0xfe) == 0xc2 && offset < sl) { \/\/ b1 either 0xc2 or 0xc3\n+                    int b2 = bytes[offset];\n+                    if (b2 < -64) { \/\/ continuation bytes are always negative values in the range -128 to -65\n+                        dst[dp++] = (byte)decode2(b1, b2);\n@@ -700,11 +716,0 @@\n-                    if ((b1 & 0xfe) == 0xc2 && offset + 1 < sl) { \/\/ b1 either 0xc2 or 0xc3\n-                        int b2 = bytes[offset + 1];\n-                        if (!isNotContinuation(b2)) {\n-                            dst[dp++] = (byte) decode2(b1, b2);\n-                            offset += 2;\n-                            continue;\n-                        }\n-                    }\n-                    \/\/ anything not a latin1, including the REPL\n-                    \/\/ we have to go with the utf16\n-                    break;\n@@ -712,5 +717,8 @@\n-                if (offset == sl) {\n-                    if (dp != dst.length) {\n-                        dst = Arrays.copyOf(dst, dp);\n-                    }\n-                    return new String(dst, LATIN1);\n+                \/\/ anything not a latin1, including the REPL\n+                \/\/ we have to go with the utf16\n+                offset--;\n+                break;\n+            }\n+            if (offset == sl) {\n+                if (dp != dst.length) {\n+                    dst = Arrays.copyOf(dst, dp);\n@@ -718,0 +726,1 @@\n+                return new String(dst, LATIN1);\n@@ -719,1 +728,1 @@\n-            if (dp == 0 || dst == null) {\n+            if (dp == 0) {\n@@ -727,4 +736,3 @@\n-            if (dp != length) {\n-                dst = Arrays.copyOf(dst, dp << 1);\n-            }\n-            return new String(dst, UTF16);\n+        } else { \/\/ !COMPACT_STRINGS\n+            dst = new byte[length << 1];\n+            dp = decodeUTF8_UTF16(bytes, offset, offset + length, dst, 0, false);\n@@ -732,0 +740,4 @@\n+        if (dp != length) {\n+            dst = Arrays.copyOf(dst, dp << 1);\n+        }\n+        return new String(dst, UTF16);\n@@ -1022,11 +1034,3 @@\n-        if (!StringCoding.hasNegatives(sa, sp, len)) {\n-            StringLatin1.inflate(sa, sp, da, dp, len);\n-            return len;\n-        } else {\n-            int start = sp;\n-            int end = sp + len;\n-            while (sp < end && sa[sp] >= 0) {\n-                da[dp++] = (char) sa[sp++];\n-            }\n-            return sp - start;\n-        }\n+        int count = StringCoding.countPositives(sa, sp, len);\n+        StringLatin1.inflate(sa, sp, da, dp, count);\n+        return count;\n@@ -1259,1 +1263,1 @@\n-        if (coder == UTF16)\n+        if (coder == UTF16) {\n@@ -1261,7 +1265,15 @@\n-\n-        if (!StringCoding.hasNegatives(val, 0, val.length))\n-            return Arrays.copyOf(val, val.length);\n-\n-        int dp = 0;\n-        byte[] dst = new byte[val.length << 1];\n-        for (byte c : val) {\n+        }\n+        final int len = val.length;\n+        int dp = StringCoding.countPositives(val, 0, len);\n+        byte[] dst;\n+        if (dp > 0) {\n+            if (dp == len) {\n+                return Arrays.copyOf(val, len);\n+            }\n+            dst = new byte[dp + ((len - dp) << 1)];\n+            System.arraycopy(val, 0, dst, 0, dp);\n+        } else {\n+            dst = new byte[len << 1];\n+        }\n+        for (int i = dp; i < len; i++) {\n+            byte c = val[i];\n@@ -1275,1 +1287,1 @@\n-        if (dp == dst.length)\n+        if (dp == dst.length) {\n@@ -1277,0 +1289,1 @@\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/String.java","additions":102,"deletions":89,"binary":false,"changes":191,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,0 @@\n-    @IntrinsicCandidate\n@@ -39,1 +38,15 @@\n-        for (int i = off; i < off + len; i++) {\n+        return countPositives(ba, off, len) != len;\n+    }\n+\n+    \/**\n+     * Count the number of leading positive bytes in the range.\n+     *\n+     * @implSpec the implementation must return len if there are no negative\n+     *   bytes in the range. If there are negative bytes, the implementation must return\n+     *   a value that is less than or equal to the index of the first negative byte\n+     *   in the range.\n+     *\/\n+    @IntrinsicCandidate\n+    public static int countPositives(byte[] ba, int off, int len) {\n+        int limit = off + len;\n+        for (int i = off; i < limit; i++) {\n@@ -41,1 +54,1 @@\n-                return true;\n+                return i - off;\n@@ -44,1 +57,1 @@\n-        return false;\n+        return len;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringCoding.java","additions":18,"deletions":5,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -0,0 +1,130 @@\n+\/*\n+ * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.intrinsics.string;\n+\n+\/*\n+ * @test\n+ * @bug 8999999\n+ * @summary Validates StringCoding.countPositives intrinsic with a small range of tests.\n+ * @library \/compiler\/patches\n+ *\n+ * @build java.base\/java.lang.Helper\n+ * @run main compiler.intrinsics.string.TestCountPositives\n+ *\/\n+\n+public class TestCountPositives {\n+\n+    private static byte[] tBa = new byte[4096 + 16];\n+\n+    \/**\n+     * Completely initialize the test array, preparing it for tests of the\n+     * StringCoding.hasNegatives method with a given array segment offset,\n+     * length, and number of negative bytes.\n+     *\/\n+    public static void initialize(int off, int len, int neg) {\n+        assert (len + off <= tBa.length);\n+        \/\/ insert \"canary\" (negative) values before offset\n+        for (int i = 0; i < off; ++i) {\n+            tBa[i] = (byte) (((i + 15) & 0x7F) | 0x80);\n+        }\n+        \/\/ fill the array segment\n+        for (int i = off; i < len + off; ++i) {\n+            tBa[i] = (byte) (((i - off + 15) & 0x7F));\n+        }\n+        if (neg != 0) {\n+            \/\/ modify a number (neg) disparate array bytes inside\n+            \/\/ segment to be negative.\n+            int div = (neg > 1) ? (len - 1) \/ (neg - 1) : 0;\n+            int idx;\n+            for (int i = 0; i < neg; ++i) {\n+                idx = off + (len - 1) - div * i;\n+                tBa[idx] = (byte) (0x80 | tBa[idx]);\n+            }\n+        }\n+        \/\/ insert \"canary\" negative values after array segment\n+        for (int i = len + off; i < tBa.length; ++i) {\n+            tBa[i] = (byte) (((i + 15) & 0x7F) | 0x80);\n+        }\n+    }\n+\n+    \/** Sizes of array segments to test. *\/\n+    private static int sizes[] = { 1, 2, 3, 4, 5, 6, 7, 8, 10, 11, 13, 17, 19, 23, 37, 61, 131,\n+            4099 };\n+\n+    \/**\n+     * Test different array segment sizes, offsets, and number of negative\n+     * bytes.\n+     *\/\n+    public static void test_countPositives() throws Exception {\n+        int len, off;\n+        int ng;\n+\n+        for (ng = 0; ng < 57; ++ng) { \/\/ number of negatives in array segment\n+            for (off = 0; off < 8; ++off) { \/\/ starting offset of array segment\n+                for (int i = 0; i < sizes.length; ++i) { \/\/ array segment size\n+                                                         \/\/ choice\n+                    len = sizes[i];\n+                    if (len + off > tBa.length)\n+                        continue;\n+                    initialize(off, len, ng);\n+                    int calculated = Helper.StringCodingCountPositives(tBa, off, len);\n+                    int expected = countPositives(tBa, off, len);\n+                    if (calculated != expected) {\n+                        if (calculated < expected && expected != len) {\n+                            \/\/ allow intrinsics to return early with a lower value,\n+                            \/\/ but only if we're not expecting the full length (no\n+                            \/\/ negative bytes)\n+                            continue;\n+                        }\n+                        throw new Exception(\"Failed test countPositives \" + \"offset: \" + off + \" \"\n+                                + \"length: \" + len + \" \" + \"return: \" + calculated + \" expected: \" + expected + \" negatives: \"\n+                                + ng);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static int countPositives(byte[] ba, int off, int len) {\n+        int limit = off + len;\n+        for (int i = off; i < limit; i++) {\n+            if (ba[i] < 0) {\n+                return i - off;\n+            }\n+        }\n+        return len;\n+    }\n+\n+    public void run() throws Exception {\n+        \/\/ iterate to eventually get intrinsic inlined\n+        for (int j = 0; j < 1000; ++j) {\n+            test_countPositives();\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        (new TestCountPositives()).run();\n+        System.out.println(\"countPositives validated\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/string\/TestCountPositives.java","additions":130,"deletions":0,"binary":false,"changes":130,"status":"added"},{"patch":"@@ -35,0 +35,5 @@\n+    @jdk.internal.vm.annotation.ForceInline\n+    public static int StringCodingCountPositives(byte[] ba, int off, int len) {\n+        return StringCoding.countPositives(ba, off, len);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/patches\/java.base\/java\/lang\/Helper.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -90,1 +90,1 @@\n-        bh.consume(new String(longAsciiString, 512, 512 + 7, charset));\n+        bh.consume(new String(longAsciiString, 512, 7, charset));\n@@ -106,1 +106,1 @@\n-        bh.consume(new String(longLatin1OnlyString, 512, 512 + 7, charset));\n+        bh.consume(new String(longLatin1OnlyString, 512, 7, charset));\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/StringDecode.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}