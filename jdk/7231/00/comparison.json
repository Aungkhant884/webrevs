{"files":[{"patch":"@@ -3357,1 +3357,2 @@\n-\/\/ return true if it has any and false otherwise.\n+\/\/ return the index of the first such character, otherwise the length\n+\/\/ of the array segment searched.\n@@ -3360,1 +3361,1 @@\n-\/\/   private static boolean hasNegatives(byte[] ba, int off, int len) {\n+\/\/   public static int countPositives(byte[] ba, int off, int len) {\n@@ -3363,1 +3364,1 @@\n-\/\/         return true;\n+\/\/         return i - off;\n@@ -3366,1 +3367,1 @@\n-\/\/     return false;\n+\/\/     return len;\n@@ -3368,1 +3369,1 @@\n-void C2_MacroAssembler::has_negatives(Register ary1, Register len,\n+void C2_MacroAssembler::count_positives(Register ary1, Register len,\n@@ -3377,1 +3378,1 @@\n-  Label TRUE_LABEL, FALSE_LABEL, DONE, COMPARE_CHAR, COMPARE_VECTORS, COMPARE_BYTE;\n+  Label ADJUST, TAIL_ADJUST, DONE, TAIL_START, CHAR_ADJUST, COMPARE_CHAR, COMPARE_VECTORS, COMPARE_BYTE;\n@@ -3379,0 +3380,1 @@\n+  movl(result, len); \/\/ copy\n@@ -3381,1 +3383,1 @@\n-  jcc(Assembler::zero, FALSE_LABEL);\n+  jcc(Assembler::zero, DONE);\n@@ -3387,1 +3389,1 @@\n-    Label test_64_loop, test_tail;\n+    Label test_64_loop, test_tail, BREAK_LOOP;\n@@ -3404,1 +3406,1 @@\n-    jcc(Assembler::notZero, TRUE_LABEL);\n+    jcc(Assembler::notZero, BREAK_LOOP);\n@@ -3409,1 +3411,0 @@\n-\n@@ -3413,1 +3414,1 @@\n-    jcc(Assembler::zero, FALSE_LABEL);\n+    jcc(Assembler::zero, DONE);\n@@ -3450,1 +3451,1 @@\n-    jcc(Assembler::notZero, TRUE_LABEL);\n+    jcc(Assembler::zero, DONE);\n@@ -3452,1 +3453,11 @@\n-    jmp(FALSE_LABEL);\n+    bind(BREAK_LOOP);\n+    \/\/ At least one byte in the last 64 bytes is negative.\n+    \/\/ Set up to look at the last 64 bytes as if they were a tail\n+    lea(ary1, Address(ary1, len, Address::times_1));\n+    addptr(result, len);\n+    \/\/ Ignore the very last byte: if all others are positive,\n+    \/\/ it must be negative, so we can skip right to the 2+1 byte\n+    \/\/ end comparison at this point\n+    orl(result, 63);\n+    movl(len, 63);\n+    \/\/ Fallthru to tail compare\n@@ -3454,1 +3465,0 @@\n-    movl(result, len); \/\/ copy\n@@ -3458,1 +3468,1 @@\n-      Label COMPARE_WIDE_VECTORS, COMPARE_TAIL;\n+      Label COMPARE_WIDE_VECTORS, BREAK_LOOP;\n@@ -3461,3 +3471,2 @@\n-      andl(result, 0x0000001f);  \/\/   tail count (in bytes)\n-      andl(len, 0xffffffe0);   \/\/ vector count (in bytes)\n-      jccb(Assembler::zero, COMPARE_TAIL);\n+      testl(len, 0xffffffe0);   \/\/ vector count (in bytes)\n+      jccb(Assembler::zero, TAIL_START);\n@@ -3465,0 +3474,1 @@\n+      andl(len, 0xffffffe0);\n@@ -3475,1 +3485,1 @@\n-      jccb(Assembler::notZero, TRUE_LABEL);\n+      jccb(Assembler::notZero, BREAK_LOOP);\n@@ -3479,9 +3489,0 @@\n-      testl(result, result);\n-      jccb(Assembler::zero, FALSE_LABEL);\n-\n-      vmovdqu(vec1, Address(ary1, result, Address::times_1, -32));\n-      vptest(vec1, vec2);\n-      jccb(Assembler::notZero, TRUE_LABEL);\n-      jmpb(FALSE_LABEL);\n-\n-      bind(COMPARE_TAIL); \/\/ len is zero\n@@ -3489,0 +3490,14 @@\n+      andl(len, 0x0000001f);   \/\/ tail count (in bytes)\n+      jcc(Assembler::zero, DONE);\n+      jmpb(TAIL_START);\n+\n+      bind(BREAK_LOOP);\n+      \/\/ At least one byte in the last 32-byte vector is negative.\n+      \/\/ Set up to look at the last 32 bytes as if they were a tail\n+      lea(ary1, Address(ary1, len, Address::times_1));\n+      addptr(result, len);\n+      \/\/ Ignore the very last byte: if all others are positive,\n+      \/\/ it must be negative, so we can skip right to the 2+1 byte\n+      \/\/ end comparison at this point\n+      orl(result, 31);\n+      movl(len, 31);\n@@ -3492,1 +3507,1 @@\n-      Label COMPARE_WIDE_VECTORS, COMPARE_TAIL;\n+      Label COMPARE_WIDE_VECTORS, BREAK_LOOP;\n@@ -3495,3 +3510,2 @@\n-      andl(result, 0x0000000f);  \/\/   tail count (in bytes)\n-      andl(len, 0xfffffff0);   \/\/ vector count (in bytes)\n-      jcc(Assembler::zero, COMPARE_TAIL);\n+      testl(len, 0xfffffff0);   \/\/ vector count (in bytes)\n+      jcc(Assembler::zero, TAIL_START);\n@@ -3499,0 +3513,1 @@\n+      andl(len, 0xfffffff0);\n@@ -3509,1 +3524,1 @@\n-      jcc(Assembler::notZero, TRUE_LABEL);\n+      jcc(Assembler::notZero, BREAK_LOOP);\n@@ -3513,9 +3528,0 @@\n-      testl(result, result);\n-      jcc(Assembler::zero, FALSE_LABEL);\n-\n-      movdqu(vec1, Address(ary1, result, Address::times_1, -16));\n-      ptest(vec1, vec2);\n-      jccb(Assembler::notZero, TRUE_LABEL);\n-      jmpb(FALSE_LABEL);\n-\n-      bind(COMPARE_TAIL); \/\/ len is zero\n@@ -3523,0 +3529,14 @@\n+      andl(len, 0x0000000f);   \/\/ tail count (in bytes)\n+      jcc(Assembler::zero, DONE);\n+      jmpb(TAIL_START);\n+\n+      bind(BREAK_LOOP);\n+      \/\/ At least one byte in the last 16-byte vector is negative.\n+      \/\/ Set up and look at the last 16 bytes as if they were a tail\n+      lea(ary1, Address(ary1, len, Address::times_1));\n+      addptr(result, len);\n+      \/\/ Ignore the very last byte: if all others are positive,\n+      \/\/ it must be negative, so we can skip right to the 2+1 byte\n+      \/\/ end comparison at this point\n+      orl(result, 15);\n+      movl(len, 15);\n@@ -3526,0 +3546,2 @@\n+\n+  bind(TAIL_START);\n@@ -3536,1 +3558,1 @@\n-  jccb(Assembler::notZero, TRUE_LABEL);\n+  jccb(Assembler::notZero, TAIL_ADJUST);\n@@ -3538,1 +3560,1 @@\n-  jcc(Assembler::notZero, COMPARE_VECTORS);\n+  jccb(Assembler::notZero, COMPARE_VECTORS);\n@@ -3540,1 +3562,1 @@\n-  \/\/ Compare trailing char (final 2 bytes), if any\n+  \/\/ Compare trailing char (final 2-3 bytes), if any\n@@ -3542,0 +3564,1 @@\n+\n@@ -3546,2 +3569,1 @@\n-  jccb(Assembler::notZero, TRUE_LABEL);\n-  subptr(result, 2);\n+  jccb(Assembler::notZero, CHAR_ADJUST);\n@@ -3552,1 +3574,1 @@\n-  jccb(Assembler::zero, FALSE_LABEL);\n+  jccb(Assembler::zero, DONE);\n@@ -3554,6 +3576,3 @@\n-  andl(tmp1, 0x00000080);\n-  jccb(Assembler::notEqual, TRUE_LABEL);\n-  jmpb(FALSE_LABEL);\n-\n-  bind(TRUE_LABEL);\n-  movl(result, 1);   \/\/ return true\n+  testl(tmp1, 0x00000080);\n+  jccb(Assembler::zero, DONE);\n+  subptr(result, 1);\n@@ -3562,2 +3581,16 @@\n-  bind(FALSE_LABEL);\n-  xorl(result, result); \/\/ return false\n+  bind(TAIL_ADJUST);\n+  \/\/ there are negative bits in the last 4 byte block.\n+  \/\/ Adjust result and check the next three bytes\n+  addptr(result, len);\n+  orl(result, 3);\n+  lea(ary1, Address(ary1, len, Address::times_1));\n+  jmpb(COMPARE_CHAR);\n+\n+  bind(CHAR_ADJUST);\n+  \/\/ We are looking at a char + optional byte tail, and found that one\n+  \/\/ of the bytes in the char is negative. Adjust the result, check the\n+  \/\/ first byte and readjust if needed.\n+  andl(result, 0xfffffffc);\n+  testl(tmp1, 0x00000080); \/\/ little-endian, so lowest byte comes first\n+  jccb(Assembler::notZero, DONE);\n+  addptr(result, 1);\n@@ -3573,0 +3606,1 @@\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":90,"deletions":56,"binary":false,"changes":146,"status":"modified"},{"patch":"@@ -272,5 +272,4 @@\n-  \/\/ return true if it has any and false otherwise.\n-  void has_negatives(Register ary1, Register len,\n-                     Register result, Register tmp1,\n-                     XMMRegister vec1, XMMRegister vec2, KRegister mask1 = knoreg, KRegister mask2 = knoreg);\n-\n+  \/\/ return index of the first such character, otherwise len.\n+  void count_positives(Register ary1, Register len,\n+                       Register result, Register tmp1,\n+                       XMMRegister vec1, XMMRegister vec2, KRegister mask1 = knoreg, KRegister mask2 = knoreg);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -12125,2 +12125,2 @@\n-instruct has_negatives(eSIRegP ary1, eCXRegI len, eAXRegI result,\n-                      regD tmp1, regD tmp2, eBXRegI tmp3, eFlagsReg cr)\n+instruct count_positives(eSIRegP ary1, eCXRegI len, eAXRegI result,\n+                         regD tmp1, regD tmp2, eBXRegI tmp3, eFlagsReg cr)\n@@ -12129,1 +12129,1 @@\n-  match(Set result (HasNegatives ary1 len));\n+  match(Set result (CountPositives ary1 len));\n@@ -12132,1 +12132,1 @@\n-  format %{ \"has negatives byte[] $ary1,$len -> $result   \/\/ KILL $tmp1, $tmp2, $tmp3\" %}\n+  format %{ \"countPositives byte[] $ary1,$len -> $result   \/\/ KILL $tmp1, $tmp2, $tmp3\" %}\n@@ -12134,3 +12134,3 @@\n-    __ has_negatives($ary1$$Register, $len$$Register,\n-                     $result$$Register, $tmp3$$Register,\n-                     $tmp1$$XMMRegister, $tmp2$$XMMRegister, knoreg, knoreg);\n+    __ count_positives($ary1$$Register, $len$$Register,\n+                       $result$$Register, $tmp3$$Register,\n+                       $tmp1$$XMMRegister, $tmp2$$XMMRegister, knoreg, knoreg);\n@@ -12141,2 +12141,2 @@\n-instruct has_negatives_evex(eSIRegP ary1, eCXRegI len, eAXRegI result,\n-                           regD tmp1, regD tmp2, kReg ktmp1, kReg ktmp2, eBXRegI tmp3, eFlagsReg cr)\n+instruct count_positives_evex(eSIRegP ary1, eCXRegI len, eAXRegI result,\n+                              regD tmp1, regD tmp2, kReg ktmp1, kReg ktmp2, eBXRegI tmp3, eFlagsReg cr)\n@@ -12145,1 +12145,1 @@\n-  match(Set result (HasNegatives ary1 len));\n+  match(Set result (CountPositives ary1 len));\n@@ -12148,1 +12148,1 @@\n-  format %{ \"has negatives byte[] $ary1,$len -> $result   \/\/ KILL $tmp1, $tmp2, $tmp3\" %}\n+  format %{ \"countPositives byte[] $ary1,$len -> $result   \/\/ KILL $tmp1, $tmp2, $tmp3\" %}\n@@ -12150,3 +12150,3 @@\n-    __ has_negatives($ary1$$Register, $len$$Register,\n-                     $result$$Register, $tmp3$$Register,\n-                     $tmp1$$XMMRegister, $tmp2$$XMMRegister, $ktmp1$$KRegister, $ktmp2$$KRegister);\n+    __ count_positives($ary1$$Register, $len$$Register,\n+                       $result$$Register, $tmp3$$Register,\n+                       $tmp1$$XMMRegister, $tmp2$$XMMRegister, $ktmp1$$KRegister, $ktmp2$$KRegister);\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -11688,2 +11688,2 @@\n-instruct has_negatives(rsi_RegP ary1, rcx_RegI len, rax_RegI result,\n-                       legRegD tmp1, legRegD tmp2, rbx_RegI tmp3, rFlagsReg cr,)\n+instruct count_positives(rsi_RegP ary1, rcx_RegI len, rax_RegI result,\n+                         legRegD tmp1, legRegD tmp2, rbx_RegI tmp3, rFlagsReg cr,)\n@@ -11692,1 +11692,1 @@\n-  match(Set result (HasNegatives ary1 len));\n+  match(Set result (CountPositives ary1 len));\n@@ -11695,1 +11695,1 @@\n-  format %{ \"has negatives byte[] $ary1,$len -> $result   \/\/ KILL $tmp1, $tmp2, $tmp3\" %}\n+  format %{ \"countPositives byte[] $ary1,$len -> $result   \/\/ KILL $tmp1, $tmp2, $tmp3\" %}\n@@ -11697,3 +11697,3 @@\n-    __ has_negatives($ary1$$Register, $len$$Register,\n-                     $result$$Register, $tmp3$$Register,\n-                     $tmp1$$XMMRegister, $tmp2$$XMMRegister, knoreg, knoreg);\n+    __ count_positives($ary1$$Register, $len$$Register,\n+                       $result$$Register, $tmp3$$Register,\n+                       $tmp1$$XMMRegister, $tmp2$$XMMRegister, knoreg, knoreg);\n@@ -11704,2 +11704,2 @@\n-instruct has_negatives_evex(rsi_RegP ary1, rcx_RegI len, rax_RegI result,\n-                            legRegD tmp1, legRegD tmp2, kReg ktmp1, kReg ktmp2, rbx_RegI tmp3, rFlagsReg cr,)\n+instruct count_positives_evex(rsi_RegP ary1, rcx_RegI len, rax_RegI result,\n+                              legRegD tmp1, legRegD tmp2, kReg ktmp1, kReg ktmp2, rbx_RegI tmp3, rFlagsReg cr,)\n@@ -11708,1 +11708,1 @@\n-  match(Set result (HasNegatives ary1 len));\n+  match(Set result (CountPositives ary1 len));\n@@ -11711,1 +11711,1 @@\n-  format %{ \"has negatives byte[] $ary1,$len -> $result   \/\/ KILL $tmp1, $tmp2, $tmp3\" %}\n+  format %{ \"countPositives byte[] $ary1,$len -> $result   \/\/ KILL $tmp1, $tmp2, $tmp3\" %}\n@@ -11713,3 +11713,3 @@\n-    __ has_negatives($ary1$$Register, $len$$Register,\n-                     $result$$Register, $tmp3$$Register,\n-                     $tmp1$$XMMRegister, $tmp2$$XMMRegister, $ktmp1$$KRegister, $ktmp2$$KRegister);\n+    __ count_positives($ary1$$Register, $len$$Register,\n+                       $result$$Register, $tmp3$$Register,\n+                       $tmp1$$XMMRegister, $tmp2$$XMMRegister, $ktmp1$$KRegister, $ktmp2$$KRegister);\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -616,0 +616,1 @@\n+        strcmp(_matrule->_rChild->_opType,\"CountPositives\" )==0 ||\n@@ -906,0 +907,1 @@\n+        strcmp(_matrule->_rChild->_opType,\"CountPositives\")==0 ||\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -233,0 +233,1 @@\n+    case vmIntrinsics::_countPositives:\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -361,0 +361,4 @@\n+  do_intrinsic(_countPositives,     java_lang_StringCoding, countPositives_name, countPositives_signature, F_S)         \\\n+   do_name(     countPositives_name,                       \"countPositives\")                                            \\\n+   do_signature(countPositives_signature,                  \"([BII)I\")                                                   \\\n+                                                                                                                        \\\n@@ -462,1 +466,1 @@\n-  do_intrinsic(_digestBase_implCompressMB, sun_security_provider_digestbase, implCompressMB_name, implCompressMB_signature, F_R)   \\\n+  do_intrinsic(_digestBase_implCompressMB, sun_security_provider_digestbase, implCompressMB_name, countPositives_signature, F_R)   \\\n@@ -464,1 +468,0 @@\n-   do_signature(implCompressMB_signature,                          \"([BII)I\")                                           \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -571,0 +571,2 @@\n+        Op_CountPositives,\n+        { { 2, ShenandoahLoad },                  { -1, ShenandoahNone} },\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -240,0 +240,3 @@\n+  case vmIntrinsics::_countPositives:\n+    if (!Matcher::match_rule_supported(Op_CountPositives))  return false;\n+    break;\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -178,0 +178,1 @@\n+macro(CountPositives)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -625,0 +625,1 @@\n+    case Op_CountPositives:\n@@ -763,0 +764,1 @@\n+    case Op_CountPositives:\n@@ -3326,1 +3328,2 @@\n-              op == Op_FastLock || op == Op_AryEq || op == Op_StrComp || op == Op_HasNegatives ||\n+              op == Op_FastLock || op == Op_AryEq || op == Op_StrComp ||\n+              op == Op_HasNegatives || op == Op_CountPositives ||\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -169,0 +169,9 @@\n+\/\/------------------------------HasNegatives---------------------------------\n+class CountPositivesNode: public StrIntrinsicNode {\n+ public:\n+  CountPositivesNode(Node* control, Node* char_array_mem, Node* s1, Node* c1):\n+  StrIntrinsicNode(control, char_array_mem, s1, c1, none) {};\n+  virtual int Opcode() const;\n+  virtual const Type* bottom_type() const { return TypeInt::INT; }\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/intrinsicnode.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -207,0 +207,1 @@\n+    case Op_CountPositives:\n","filename":"src\/hotspot\/share\/opto\/lcm.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -623,0 +623,3 @@\n+  case vmIntrinsics::_countPositives:\n+    return inline_countPositives();\n+\n@@ -1039,0 +1042,25 @@\n+\/\/------------------------------inline_countPositives------------------------------\n+bool LibraryCallKit::inline_countPositives() {\n+  if (too_many_traps(Deoptimization::Reason_intrinsic)) {\n+    return false;\n+  }\n+\n+  assert(callee()->signature()->size() == 3, \"countPositives has 3 parameters\");\n+  \/\/ no receiver since it is static method\n+  Node* ba         = argument(0);\n+  Node* offset     = argument(1);\n+  Node* len        = argument(2);\n+\n+  ba = must_be_not_null(ba, true);\n+\n+  \/\/ Range checks\n+  generate_string_range_check(ba, offset, len, false);\n+  if (stopped()) {\n+    return true;\n+  }\n+  Node* ba_start = array_element_address(ba, offset, T_BYTE);\n+  Node* result = new CountPositivesNode(control(), memory(TypeAryPtr::BYTES), ba_start, len);\n+  set_result(_gvn.transform(result));\n+  return true;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -300,0 +300,1 @@\n+  bool inline_countPositives();\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -831,1 +831,2 @@\n-      case Op_HasNegatives: {\n+      case Op_HasNegatives:\n+      case Op_CountPositives: {\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -5676,0 +5676,1 @@\n+    case Op_CountPositives:\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1070,0 +1070,1 @@\n+    case Op_CountPositives:\n@@ -2256,0 +2257,1 @@\n+    case Op_CountPositives:\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -528,4 +528,7 @@\n-            if (COMPACT_STRINGS && !StringCoding.hasNegatives(bytes, offset, length)) {\n-                this.value = Arrays.copyOfRange(bytes, offset, offset + length);\n-                this.coder = LATIN1;\n-            } else {\n+            if (COMPACT_STRINGS) {\n+                int dp = StringCoding.countPositives(bytes, offset, length);\n+                if (dp == length) {\n+                    this.value = Arrays.copyOfRange(bytes, offset, offset + length);\n+                    this.coder = LATIN1;\n+                    return;\n+                }\n@@ -533,22 +536,11 @@\n-                int dp = 0;\n-                byte[] dst = null;\n-                if (COMPACT_STRINGS) {\n-                    dst = new byte[length];\n-                    while (offset < sl) {\n-                        int b1 = bytes[offset];\n-                        if (b1 >= 0) {\n-                            dst[dp++] = (byte)b1;\n-                            offset++;\n-                            continue;\n-                        }\n-                        if ((b1 & 0xfe) == 0xc2 && offset + 1 < sl) { \/\/ b1 either 0xc2 or 0xc3\n-                            int b2 = bytes[offset + 1];\n-                            if (!isNotContinuation(b2)) {\n-                                dst[dp++] = (byte)decode2(b1, b2);\n-                                offset += 2;\n-                                continue;\n-                            }\n-                        }\n-                        \/\/ anything not a latin1, including the repl\n-                        \/\/ we have to go with the utf16\n-                        break;\n+                byte[] dst = new byte[length];\n+                if (dp > 0) {\n+                    System.arraycopy(bytes, offset, dst, 0, dp);\n+                    offset += dp;\n+                }\n+                while (offset < sl) {\n+                    int b1 = bytes[offset];\n+                    if (b1 >= 0) {\n+                        dst[dp++] = (byte)b1;\n+                        offset++;\n+                        continue;\n@@ -556,3 +548,6 @@\n-                    if (offset == sl) {\n-                        if (dp != dst.length) {\n-                            dst = Arrays.copyOf(dst, dp);\n+                    if ((b1 & 0xfe) == 0xc2 && offset + 1 < sl) { \/\/ b1 either 0xc2 or 0xc3\n+                        int b2 = bytes[offset + 1];\n+                        if (!isNotContinuation(b2)) {\n+                            dst[dp++] = (byte)decode2(b1, b2);\n+                            offset += 2;\n+                            continue;\n@@ -560,3 +555,0 @@\n-                        this.value = dst;\n-                        this.coder = LATIN1;\n-                        return;\n@@ -564,0 +556,3 @@\n+                    \/\/ anything not a latin1, including the repl\n+                    \/\/ we have to go with the utf16\n+                    break;\n@@ -565,6 +560,7 @@\n-                if (dp == 0 || dst == null) {\n-                    dst = new byte[length << 1];\n-                } else {\n-                    byte[] buf = new byte[length << 1];\n-                    StringLatin1.inflate(dst, 0, buf, 0, dp);\n-                    dst = buf;\n+                if (offset == sl) {\n+                    if (dp != dst.length) {\n+                        dst = Arrays.copyOf(dst, dp);\n+                    }\n+                    this.value = dst;\n+                    this.coder = LATIN1;\n+                    return;\n@@ -572,0 +568,3 @@\n+                byte[] buf = new byte[length << 1];\n+                StringLatin1.inflate(dst, 0, buf, 0, dp);\n+                dst = buf;\n@@ -578,0 +577,8 @@\n+            } else { \/\/ !COMPACT_STRINGS\n+                byte[] dst = new byte[length << 1];\n+                int dp = decodeUTF8_UTF16(bytes, offset, offset + length, dst, 0, true);\n+                if (dp != length) {\n+                    dst = Arrays.copyOf(dst, dp << 1);\n+                }\n+                this.value = dst;\n+                this.coder = UTF16;\n@@ -685,3 +692,4 @@\n-        if (COMPACT_STRINGS && !StringCoding.hasNegatives(bytes, offset, length)) {\n-            return new String(Arrays.copyOfRange(bytes, offset, offset + length), LATIN1);\n-        } else {\n+        int dp;\n+        byte[] dst;\n+        if (COMPACT_STRINGS) {\n+            dp = StringCoding.countPositives(bytes, offset, length);\n@@ -689,9 +697,16 @@\n-            int dp = 0;\n-            byte[] dst = null;\n-            if (COMPACT_STRINGS) {\n-                dst = new byte[length];\n-                while (offset < sl) {\n-                    int b1 = bytes[offset];\n-                    if (b1 >= 0) {\n-                        dst[dp++] = (byte) b1;\n-                        offset++;\n+            if (dp == length) {\n+                return new String(Arrays.copyOfRange(bytes, offset, offset + length), LATIN1);\n+            }\n+            dst = new byte[length];\n+            System.arraycopy(bytes, offset, dst, 0, dp);\n+            offset += dp;\n+            while (offset < sl) {\n+                int b1 = bytes[offset++];\n+                if (b1 >= 0) {\n+                    dst[dp++] = (byte)b1;\n+                    continue;\n+                }\n+                if ((b1 & 0xfe) == 0xc2 && offset < sl) { \/\/ b1 either 0xc2 or 0xc3\n+                    int b2 = bytes[offset++];\n+                    if (!isNotContinuation(b2)) {\n+                        dst[dp++] = (byte)decode2(b1, b2);\n@@ -699,0 +714,2 @@\n+                    } else {\n+                        offset--;\n@@ -700,11 +717,0 @@\n-                    if ((b1 & 0xfe) == 0xc2 && offset + 1 < sl) { \/\/ b1 either 0xc2 or 0xc3\n-                        int b2 = bytes[offset + 1];\n-                        if (!isNotContinuation(b2)) {\n-                            dst[dp++] = (byte) decode2(b1, b2);\n-                            offset += 2;\n-                            continue;\n-                        }\n-                    }\n-                    \/\/ anything not a latin1, including the REPL\n-                    \/\/ we have to go with the utf16\n-                    break;\n@@ -712,5 +718,8 @@\n-                if (offset == sl) {\n-                    if (dp != dst.length) {\n-                        dst = Arrays.copyOf(dst, dp);\n-                    }\n-                    return new String(dst, LATIN1);\n+                offset--;\n+                \/\/ anything not a latin1, including the REPL\n+                \/\/ we have to go with the utf16\n+                break;\n+            }\n+            if (offset == sl) {\n+                if (dp != dst.length) {\n+                    dst = Arrays.copyOf(dst, dp);\n@@ -718,0 +727,1 @@\n+                return new String(dst, LATIN1);\n@@ -719,1 +729,1 @@\n-            if (dp == 0 || dst == null) {\n+            if (dp == 0) {\n@@ -727,4 +737,3 @@\n-            if (dp != length) {\n-                dst = Arrays.copyOf(dst, dp << 1);\n-            }\n-            return new String(dst, UTF16);\n+        } else { \/\/ !COMPACT_STRINGS\n+            dst = new byte[length << 1];\n+            dp = decodeUTF8_UTF16(bytes, offset, offset + length, dst, 0, false);\n@@ -732,0 +741,4 @@\n+        if (dp != length) {\n+            dst = Arrays.copyOf(dst, dp << 1);\n+        }\n+        return new String(dst, UTF16);\n@@ -1022,11 +1035,3 @@\n-        if (!StringCoding.hasNegatives(sa, sp, len)) {\n-            StringLatin1.inflate(sa, sp, da, dp, len);\n-            return len;\n-        } else {\n-            int start = sp;\n-            int end = sp + len;\n-            while (sp < end && sa[sp] >= 0) {\n-                da[dp++] = (char) sa[sp++];\n-            }\n-            return sp - start;\n-        }\n+        int count = StringCoding.countPositives(sa, sp, len);\n+        StringLatin1.inflate(sa, sp, da, dp, count);\n+        return count;\n@@ -1262,2 +1267,5 @@\n-        if (!StringCoding.hasNegatives(val, 0, val.length))\n-            return Arrays.copyOf(val, val.length);\n+        int len = val.length;\n+        int dp = StringCoding.countPositives(val, 0, len);\n+        if (dp == len) {\n+            return Arrays.copyOf(val, len);\n+        }\n@@ -1265,3 +1273,6 @@\n-        int dp = 0;\n-        byte[] dst = new byte[val.length << 1];\n-        for (byte c : val) {\n+        int i = dp;\n+        byte[] dst = new byte[dp + ((len - dp) << 1)];\n+        if (dp > 0)\n+            System.arraycopy(val, 0, dst, 0, dp);\n+        while (i < len) {\n+            byte c = val[i++];\n","filename":"src\/java.base\/share\/classes\/java\/lang\/String.java","additions":98,"deletions":87,"binary":false,"changes":185,"status":"modified"},{"patch":"@@ -39,1 +39,2 @@\n-        for (int i = off; i < off + len; i++) {\n+        int limit = off + len;\n+        for (int i = off; i < limit; i++) {\n@@ -47,0 +48,18 @@\n+    \/**\n+     * Count the number of consecutive, leading positive bytes in the\n+     * range.\n+     *\/\n+    @IntrinsicCandidate\n+    public static int countPositives(byte[] ba, int off, int len) {\n+        if (!hasNegatives(ba, off, len))\n+            return len;\n+\n+        int limit = off + len;\n+        for (int i = off; i < limit; i++) {\n+            if (ba[i] < 0) {\n+                return i - off;\n+            }\n+        }\n+        return len;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringCoding.java","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -0,0 +1,124 @@\n+\/*\n+ * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.intrinsics.string;\n+\n+\/*\n+ * @test\n+ * @bug 8999999\n+ * @summary Validates StringCoding.countPositives intrinsic with a small range of tests.\n+ * @library \/compiler\/patches\n+ *\n+ * @build java.base\/java.lang.Helper\n+ * @run main compiler.intrinsics.string.TestCountPositives\n+ *\/\n+\n+public class TestCountPositives {\n+\n+    private static byte[] tBa = new byte[4096 + 16];\n+\n+    \/**\n+     * Completely initialize the test array, preparing it for tests of the\n+     * StringCoding.hasNegatives method with a given array segment offset,\n+     * length, and number of negative bytes.\n+     *\/\n+    public static void initialize(int off, int len, int neg) {\n+        assert (len + off <= tBa.length);\n+        \/\/ insert \"canary\" (negative) values before offset\n+        for (int i = 0; i < off; ++i) {\n+            tBa[i] = (byte) (((i + 15) & 0x7F) | 0x80);\n+        }\n+        \/\/ fill the array segment\n+        for (int i = off; i < len + off; ++i) {\n+            tBa[i] = (byte) (((i - off + 15) & 0x7F));\n+        }\n+        if (neg != 0) {\n+            \/\/ modify a number (neg) disparate array bytes inside\n+            \/\/ segment to be negative.\n+            int div = (neg > 1) ? (len - 1) \/ (neg - 1) : 0;\n+            int idx;\n+            for (int i = 0; i < neg; ++i) {\n+                idx = off + (len - 1) - div * i;\n+                tBa[idx] = (byte) (0x80 | tBa[idx]);\n+            }\n+        }\n+        \/\/ insert \"canary\" negative values after array segment\n+        for (int i = len + off; i < tBa.length; ++i) {\n+            tBa[i] = (byte) (((i + 15) & 0x7F) | 0x80);\n+        }\n+    }\n+\n+    \/** Sizes of array segments to test. *\/\n+    private static int sizes[] = { 1, 2, 3, 4, 5, 6, 7, 8, 10, 11, 13, 17, 19, 23, 37, 61, 131,\n+            4099 };\n+\n+    \/**\n+     * Test different array segment sizes, offsets, and number of negative\n+     * bytes.\n+     *\/\n+    public static void test_countPositives() throws Exception {\n+        int len, off;\n+        int ng;\n+\n+        for (ng = 0; ng < 57; ++ng) { \/\/ number of negatives in array segment\n+            for (off = 0; off < 8; ++off) { \/\/ starting offset of array segment\n+                for (int i = 0; i < sizes.length; ++i) { \/\/ array segment size\n+                                                         \/\/ choice\n+                    len = sizes[i];\n+                    if (len + off > tBa.length)\n+                        continue;\n+                    initialize(off, len, ng);\n+                    int r = Helper.StringCodingCountPositives(tBa, off, len);\n+                    int t = countPositives(tBa, off, len);\n+                    if (r != t) {\n+                        throw new Exception(\"Failed test countPositives \" + \"offset: \" + off + \" \"\n+                                + \"length: \" + len + \" \" + \"return: \" + r + \" expected: \" + t + \" negatives: \"\n+                                + ng);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static int countPositives(byte[] ba, int off, int len) {\n+        int limit = off + len;\n+        for (int i = off; i < limit; i++) {\n+            if (ba[i] < 0) {\n+                return i - off;\n+            }\n+        }\n+        return len;\n+    }\n+\n+    public void run() throws Exception {\n+        \/\/ iterate to eventually get intrinsic inlined\n+        for (int j = 0; j < 1000; ++j) {\n+            test_countPositives();\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        (new TestCountPositives()).run();\n+        System.out.println(\"countPositives validated\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/string\/TestCountPositives.java","additions":124,"deletions":0,"binary":false,"changes":124,"status":"added"},{"patch":"@@ -35,0 +35,5 @@\n+    @jdk.internal.vm.annotation.ForceInline\n+    public static int StringCodingCountPositives(byte[] ba, int off, int len) {\n+        return StringCoding.countPositives(ba, off, len);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/patches\/java.base\/java\/lang\/Helper.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -25,11 +25,1 @@\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Param;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.annotations.*;\n@@ -54,0 +44,1 @@\n+    private byte[] longAsciiString;\n@@ -55,1 +46,1 @@\n-    private byte[] longUtf16String;\n+    private byte[] longUtf16EndString;\n@@ -57,1 +48,3 @@\n-    private byte[] longLatin1String;\n+    private byte[] latin1String;\n+    private byte[] longLatin1EndString;\n+    private byte[] longLatin1StartString;\n@@ -63,0 +56,20 @@\n+        longAsciiString = \"\"\"\n+             Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aliquam ac sem eu\n+             urna egestas placerat. Etiam finibus ipsum nulla, non mattis dolor cursus a.\n+             Nulla nec nisl consectetur, lacinia neque id, accumsan ante. Curabitur et\n+             sapien in magna porta ultricies. Sed vel pellentesque nibh. Pellentesque dictum\n+             dignissim diam eu ultricies. Class aptent taciti sociosqu ad litora torquent\n+             per conubia nostra, per inceptos himenaeos. Suspendisse erat diam, fringilla\n+             sed massa sed, posuere viverra orci. Suspendisse tempor libero non gravida\n+             efficitur. Vivamus lacinia risus non orci viverra, at consectetur odio laoreet.\n+             Suspendisse potenti.\n+\n+             Phasellus vel nisi iaculis, accumsan quam sed, bibendum eros. Sed venenatis\n+             nulla tortor, et eleifend urna sodales id. Nullam tempus ac metus sit amet\n+             sollicitudin. Nam sed ex diam. Praesent vitae eros et neque condimentum\n+             consectetur eget non tortor. Praesent bibendum vel felis nec dignissim.\n+             Maecenas a enim diam. Suspendisse quis ligula at nisi accumsan lacinia id\n+             hendrerit sapien. Donec aliquam mattis lectus eu ultrices. Duis eu nisl\n+             euismod, blandit mauris vel, placerat urna. Etiam malesuada enim purus,\n+             tristique mollis odio blandit quis. Vivamus posuere.\n+            \"\"\".getBytes(charset);\n@@ -64,1 +77,1 @@\n-        longUtf16String = \"\"\"\n+        longUtf16EndString = \"\"\"\n@@ -107,1 +120,1 @@\n-        longLatin1String = \"\"\"\n+        latin1String = \"\"\"\n@@ -109,12 +122,0 @@\n-             b\\u00F6\\u00F6\\u00B6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\n-             c\\u00F6\\u00F6\\u00F6\\u00B6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\n-             d\\u00F6\\u00F6\\u00F6\\u00F6\\u00B6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\n-             e\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00B6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\n-             f\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00B6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\n-             g\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00B6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\n-             h\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00B6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\n-             i\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00B6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\n-             j\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00B6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\n-             k\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00B6\\u00F6\\u00F6\\u00F6\\u00F6\n-             l\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00B6\\u00F6\\u00F6\\u00F6\n-             m\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00B6\\u00F6\\u00F6\n@@ -122,0 +123,44 @@\n+\n+        longLatin1EndString = \"\"\"\n+             Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aliquam ac sem eu\n+             urna egestas placerat. Etiam finibus ipsum nulla, non mattis dolor cursus a.\n+             Nulla nec nisl consectetur, lacinia neque id, accumsan ante. Curabitur et\n+             sapien in magna porta ultricies. Sed vel pellentesque nibh. Pellentesque dictum\n+             dignissim diam eu ultricies. Class aptent taciti sociosqu ad litora torquent\n+             per conubia nostra, per inceptos himenaeos. Suspendisse erat diam, fringilla\n+             sed massa sed, posuere viverra orci. Suspendisse tempor libero non gravida\n+             efficitur. Vivamus lacinia risus non orci viverra, at consectetur odio laoreet.\n+             Suspendisse potenti.\n+\n+             Phasellus vel nisi iaculis, accumsan quam sed, bibendum eros. Sed venenatis\n+             nulla tortor, et eleifend urna sodales id. Nullam tempus ac metus sit amet\n+             sollicitudin. Nam sed ex diam. Praesent vitae eros et neque condimentum\n+             consectetur eget non tortor. Praesent bibendum vel felis nec dignissim.\n+             Maecenas a enim diam. Suspendisse quis ligula at nisi accumsan lacinia id\n+             hendrerit sapien. \\u00F6Donec aliquam mattis lectus eu ultrices. Duis eu nisl\\u00F6\n+             euismod, blandit mauris vel, \\u00F6placerat urna. Etiam malesuada enim purus,\n+             tristique mollis odio blandit quis.\\u00B6 Vivamus posuere. \\u00F6\n+             \\u00F6\n+            \"\"\".getBytes(charset);\n+        longLatin1StartString = \"\"\"\n+             \\u00F6\n+             Lorem ipsum dolor sit amet, \\u00B6consectetur adipiscing elit. Aliquam ac sem eu\n+             urna egestas \\u00F6placerat. Etiam finibus ipsum nulla, non mattis dolor cursus a.\n+             Nulla \\u00F6nec nisl consectetur, lacinia neque id, accumsan ante. Curabitur et\n+             sapien in \\u00F6magna porta ultricies. \\u00F6Sed vel pellentesque nibh. Pellentesque dictum\n+             dignissim diam eu ultricies. Class aptent taciti sociosqu ad litora torquent\n+             per conubia nostra, per inceptos himenaeos. Suspendisse erat diam, fringilla\n+             sed massa sed, posuere viverra orci. Suspendisse tempor libero non gravida\n+             efficitur. Vivamus lacinia risus non orci viverra, at consectetur odio laoreet.\n+             Suspendisse potenti.\n+\n+             Phasellus vel nisi iaculis, accumsan quam sed, bibendum eros. Sed venenatis\n+             nulla tortor, et eleifend urna sodales id. Nullam tempus ac metus sit amet\n+             sollicitudin. Nam sed ex diam. Praesent vitae eros et neque condimentum\n+             consectetur eget non tortor. Praesent bibendum vel felis nec dignissim.\n+             Maecenas a enim diam. Suspendisse quis ligula at nisi accumsan lacinia id\n+             hendrerit sapien. Donec aliquam mattis lectus eu ultrices. Duis eu nisl\n+             euismod, blandit mauris vel, placerat urna. Etiam malesuada enim purus,\n+             tristique mollis odio blandit quis. Vivamus posuere.\n+            \"\"\".getBytes(charset);\n+\n@@ -125,0 +170,1 @@\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n@@ -130,0 +176,1 @@\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n@@ -135,2 +182,3 @@\n-    public String decodeLatin1Long() throws Exception {\n-        return new String(longLatin1String, charset);\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public String decodeAsciiLong() throws Exception {\n+        return new String(longAsciiString, charset);\n@@ -140,0 +188,27 @@\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public String decodeLatin1Short() throws Exception {\n+        return new String(latin1String, charset);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public String decodeLatin1StartLong() throws Exception {\n+        return new String(longLatin1StartString, charset);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public String decodeLatin1EndLong() throws Exception {\n+        return new String(longLatin1EndString, charset);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void decodeLatin1Mixed(Blackhole bh) throws Exception {\n+        bh.consume(new String(longLatin1EndString, charset));\n+        bh.consume(new String(longLatin1StartString, charset));\n+        bh.consume(new String(latin1String, charset));\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n@@ -145,0 +220,1 @@\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n@@ -146,1 +222,1 @@\n-        return new String(longUtf16String, charset);\n+        return new String(longUtf16EndString, charset);\n@@ -150,0 +226,1 @@\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n@@ -155,1 +232,12 @@\n-    public void decodeUTF16LongMixed(Blackhole bh) throws Exception {\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void decodeUTF16Mixed(Blackhole bh) throws Exception {\n+        bh.consume(new String(longUtf16StartString, charset));\n+        bh.consume(new String(longUtf16EndString, charset));\n+        bh.consume(new String(utf16String, charset));\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void decodeAllMixed(Blackhole bh) throws Exception {\n+        bh.consume(new String(utf16String, charset));\n+        bh.consume(new String(longUtf16EndString, charset));\n@@ -157,1 +245,24 @@\n-        bh.consume(new String(longUtf16String, charset));\n+        bh.consume(new String(latin1String, charset));\n+        bh.consume(new String(longLatin1EndString, charset));\n+        bh.consume(new String(longLatin1StartString, charset));\n+        bh.consume(new String(asciiString, charset));\n+        bh.consume(new String(longAsciiString, charset));\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void decodeStartMixed(Blackhole bh) throws Exception {\n+        bh.consume(new String(utf16String, charset));\n+        bh.consume(new String(longUtf16StartString, charset));\n+        bh.consume(new String(longLatin1StartString, charset));\n+        bh.consume(new String(latin1String, charset));\n+        bh.consume(new String(asciiString, charset));\n+        bh.consume(new String(longAsciiString, charset));\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void decodeShortMixed(Blackhole bh) throws Exception {\n+        bh.consume(new String(utf16String, charset));\n+        bh.consume(new String(latin1String, charset));\n+        bh.consume(new String(asciiString, charset));\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/StringDecode.java","additions":143,"deletions":32,"binary":false,"changes":175,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+    private String longAsciiString;\n@@ -44,1 +45,1 @@\n-    private String longUtf16String;\n+    private String longUtf16EndString;\n@@ -46,0 +47,3 @@\n+    private String latin1String;\n+    private String longLatin1EndString;\n+    private String longLatin1StartString;\n@@ -51,0 +55,20 @@\n+        longAsciiString = \"\"\"\n+                 Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aliquam ac sem eu\n+                 urna egestas placerat. Etiam finibus ipsum nulla, non mattis dolor cursus a.\n+                 Nulla nec nisl consectetur, lacinia neque id, accumsan ante. Curabitur et\n+                 sapien in magna porta ultricies. Sed vel pellentesque nibh. Pellentesque dictum\n+                 dignissim diam eu ultricies. Class aptent taciti sociosqu ad litora torquent\n+                 per conubia nostra, per inceptos himenaeos. Suspendisse erat diam, fringilla\n+                 sed massa sed, posuere viverra orci. Suspendisse tempor libero non gravida\n+                 efficitur. Vivamus lacinia risus non orci viverra, at consectetur odio laoreet.\n+                 Suspendisse potenti.\n+\n+                 Phasellus vel nisi iaculis, accumsan quam sed, bibendum eros. Sed venenatis\n+                 nulla tortor, et eleifend urna sodales id. Nullam tempus ac metus sit amet\n+                 sollicitudin. Nam sed ex diam. Praesent vitae eros et neque condimentum\n+                 consectetur eget non tortor. Praesent bibendum vel felis nec dignissim.\n+                 Maecenas a enim diam. Suspendisse quis ligula at nisi accumsan lacinia id\n+                 hendrerit sapien. Donec aliquam mattis lectus eu ultrices. Duis eu nisl\n+                 euismod, blandit mauris vel, placerat urna. Etiam malesuada enim purus,\n+                 tristique mollis odio blandit quis. Vivamus posuere.\n+                 \"\"\";\n@@ -52,1 +76,1 @@\n-        longUtf16String = \"\"\"\n+        longUtf16EndString = \"\"\"\n@@ -94,0 +118,46 @@\n+        latin1String = \"\"\"\n+             a\\u00B6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\\u00F6\n+            \"\"\";\n+\n+        longLatin1EndString = \"\"\"\n+             Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aliquam ac sem eu\n+             urna egestas placerat. Etiam finibus ipsum nulla, non mattis dolor cursus a.\n+             Nulla nec nisl consectetur, lacinia neque id, accumsan ante. Curabitur et\n+             sapien in magna porta ultricies. Sed vel pellentesque nibh. Pellentesque dictum\n+             dignissim diam eu ultricies. Class aptent taciti sociosqu ad litora torquent\n+             per conubia nostra, per inceptos himenaeos. Suspendisse erat diam, fringilla\n+             sed massa sed, posuere viverra orci. Suspendisse tempor libero non gravida\n+             efficitur. Vivamus lacinia risus non orci viverra, at consectetur odio laoreet.\n+             Suspendisse potenti.\n+\n+             Phasellus vel nisi iaculis, accumsan quam sed, bibendum eros. Sed venenatis\n+             nulla tortor, et eleifend urna sodales id. Nullam tempus ac metus sit amet\n+             sollicitudin. Nam sed ex diam. Praesent vitae eros et neque condimentum\n+             consectetur eget non tortor. Praesent bibendum vel felis nec dignissim.\n+             Maecenas a enim diam. Suspendisse quis ligula at nisi accumsan lacinia id\n+             hendrerit sapien. \\u00F6Donec aliquam mattis lectus eu ultrices. Duis eu nisl\\u00F6\n+             euismod, blandit mauris vel, \\u00F6placerat urna. Etiam malesuada enim purus,\n+             tristique mollis odio blandit quis.\\u00B6 Vivamus posuere. \\u00F6\n+             \\u00F6\n+            \"\"\";\n+        longLatin1StartString = \"\"\"\n+             \\u00F6\n+             Lorem ipsum dolor sit amet, \\u00B6consectetur adipiscing elit. Aliquam ac sem eu\n+             urna egestas \\u00F6placerat. Etiam finibus ipsum nulla, non mattis dolor cursus a.\n+             Nulla \\u00F6nec nisl consectetur, lacinia neque id, accumsan ante. Curabitur et\n+             sapien in \\u00F6magna porta ultricies. \\u00F6Sed vel pellentesque nibh. Pellentesque dictum\n+             dignissim diam eu ultricies. Class aptent taciti sociosqu ad litora torquent\n+             per conubia nostra, per inceptos himenaeos. Suspendisse erat diam, fringilla\n+             sed massa sed, posuere viverra orci. Suspendisse tempor libero non gravida\n+             efficitur. Vivamus lacinia risus non orci viverra, at consectetur odio laoreet.\n+             Suspendisse potenti.\n+\n+             Phasellus vel nisi iaculis, accumsan quam sed, bibendum eros. Sed venenatis\n+             nulla tortor, et eleifend urna sodales id. Nullam tempus ac metus sit amet\n+             sollicitudin. Nam sed ex diam. Praesent vitae eros et neque condimentum\n+             consectetur eget non tortor. Praesent bibendum vel felis nec dignissim.\n+             Maecenas a enim diam. Suspendisse quis ligula at nisi accumsan lacinia id\n+             hendrerit sapien. Donec aliquam mattis lectus eu ultrices. Duis eu nisl\n+             euismod, blandit mauris vel, placerat urna. Etiam malesuada enim purus,\n+             tristique mollis odio blandit quis. Vivamus posuere.\n+            \"\"\";\n@@ -97,0 +167,1 @@\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n@@ -98,1 +169,1 @@\n-        return asciiString.getBytes(charset);\n+        return asciiString.getBytes(charsetName);\n@@ -102,0 +173,1 @@\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n@@ -107,3 +179,3 @@\n-    public void encodeMix(Blackhole bh) throws Exception {\n-        bh.consume(asciiString.getBytes(charset));\n-        bh.consume(utf16String.getBytes(charset));\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public byte[] encodeAsciiLong() throws Exception {\n+        return longAsciiString.getBytes(charset);\n@@ -113,0 +185,1 @@\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n@@ -114,1 +187,1 @@\n-        return longUtf16String.getBytes(charset);\n+        return longUtf16EndString.getBytes(charset);\n@@ -118,0 +191,1 @@\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n@@ -123,0 +197,1 @@\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n@@ -126,0 +201,66 @@\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void encodeUTF16Mixed(Blackhole bh) throws Exception {\n+        bh.consume(utf16String.getBytes(charset));\n+        bh.consume(longUtf16StartString.getBytes(charset));\n+        bh.consume(longUtf16EndString.getBytes(charset));\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public byte[] encodeLatin1Short() throws Exception {\n+        return latin1String.getBytes(charset);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public byte[] encodeLatin1StartLong() throws Exception {\n+        return longLatin1StartString.getBytes(charset);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public byte[] encodeLatin1EndLong() throws Exception {\n+        return longLatin1EndString.getBytes(charset);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void encodeLatin1Mixed(Blackhole bh) throws Exception {\n+        bh.consume(longLatin1EndString.getBytes(charset));\n+        bh.consume(longLatin1StartString.getBytes(charset));\n+        bh.consume(latin1String.getBytes(charset));\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void encodeAllMixed(Blackhole bh) throws Exception {\n+        bh.consume(utf16String.getBytes(charset));\n+        bh.consume(longUtf16StartString.getBytes(charset));\n+        bh.consume(longUtf16EndString.getBytes(charset));\n+        bh.consume(longLatin1EndString.getBytes(charset));\n+        bh.consume(longLatin1StartString.getBytes(charset));\n+        bh.consume(latin1String.getBytes(charset));\n+        bh.consume(asciiString.getBytes(charset));\n+        bh.consume(longAsciiString.getBytes(charset));\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void encodeStartMixed(Blackhole bh) throws Exception {\n+        bh.consume(utf16String.getBytes(charset));\n+        bh.consume(longUtf16StartString.getBytes(charset));\n+        bh.consume(longLatin1StartString.getBytes(charset));\n+        bh.consume(latin1String.getBytes(charset));\n+        bh.consume(asciiString.getBytes(charset));\n+        bh.consume(longAsciiString.getBytes(charset));\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    public void encodeShortMixed(Blackhole bh) throws Exception {\n+        bh.consume(utf16String.getBytes(charset));\n+        bh.consume(latin1String.getBytes(charset));\n+        bh.consume(asciiString.getBytes(charset));\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/StringEncode.java","additions":148,"deletions":7,"binary":false,"changes":155,"status":"modified"}]}