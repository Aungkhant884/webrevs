{"files":[{"patch":"@@ -16975,1 +16975,1 @@\n-instruct has_negatives(iRegP_R1 ary1, iRegI_R2 len, iRegI_R0 result, rFlagsReg cr)\n+instruct count_positives(iRegP_R1 ary1, iRegI_R2 len, iRegI_R0 result, rFlagsReg cr)\n@@ -16977,1 +16977,1 @@\n-  match(Set result (HasNegatives ary1 len));\n+  match(Set result (CountPositives ary1 len));\n@@ -16979,1 +16979,1 @@\n-  format %{ \"has negatives byte[] $ary1,$len -> $result\" %}\n+  format %{ \"count positives byte[] $ary1,$len -> $result\" %}\n@@ -16981,1 +16981,1 @@\n-    address tpc = __ has_negatives($ary1$$Register, $len$$Register, $result$$Register);\n+    address tpc = __ count_positives($ary1$$Register, $len$$Register, $result$$Register);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -4334,2 +4334,2 @@\n-\/\/ This method checks if provided byte array contains byte with highest bit set.\n-address MacroAssembler::has_negatives(Register ary1, Register len, Register result) {\n+\/\/ This method counts leading positive bytes (highest bit not set) in provided byte array\n+address MacroAssembler::count_positives(Register ary1, Register len, Register result) {\n@@ -4342,0 +4342,1 @@\n+    mov(result, len);\n@@ -4343,1 +4344,1 @@\n-    br(LE, SET_RESULT);\n+    br(LE, DONE);\n@@ -4365,1 +4366,1 @@\n-    ldr(result, Address(ary1));\n+    ldr(rscratch1, Address(ary1));\n@@ -4367,2 +4368,2 @@\n-    lslv(result, result, len);\n-    tst(result, UPPER_BIT_MASK);\n+    lslv(rscratch1, rscratch1, len);\n+    tst(rscratch1, UPPER_BIT_MASK);\n@@ -4372,3 +4373,3 @@\n-    RuntimeAddress has_neg = RuntimeAddress(StubRoutines::aarch64::has_negatives());\n-    assert(has_neg.target() != NULL, \"has_negatives stub has not been generated\");\n-    address tpc1 = trampoline_call(has_neg);\n+    RuntimeAddress count_pos = RuntimeAddress(StubRoutines::aarch64::count_positives());\n+    assert(count_pos.target() != NULL, \"count_positives stub has not been generated\");\n+    address tpc1 = trampoline_call(count_pos);\n@@ -4383,3 +4384,3 @@\n-    RuntimeAddress has_neg_long = RuntimeAddress(StubRoutines::aarch64::has_negatives_long());\n-    assert(has_neg_long.target() != NULL, \"has_negatives stub has not been generated\");\n-    address tpc2 = trampoline_call(has_neg_long);\n+    RuntimeAddress count_pos_long = RuntimeAddress(StubRoutines::aarch64::count_positives_long());\n+    assert(count_pos_long.target() != NULL, \"count_positives_long stub has not been generated\");\n+    address tpc2 = trampoline_call(count_pos_long);\n@@ -4394,1 +4395,1 @@\n-    cset(result, NE); \/\/ set true or false\n+    csel(result, zr, result, NE); \/\/ set len or 0\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":14,"deletions":13,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -1237,1 +1237,1 @@\n-  address has_negatives(Register ary1, Register len, Register result);\n+  address count_positives(Register ary1, Register len, Register result);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4660,1 +4660,1 @@\n-  address generate_has_negatives(address &has_negatives_long) {\n+  address generate_count_positives(address &count_positives_long) {\n@@ -4669,1 +4669,1 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"has_negatives\");\n+    StubCodeMark mark(this, \"StubRoutines\", \"count_positives\");\n@@ -4674,2 +4674,3 @@\n-\n-  Label RET_TRUE, RET_TRUE_NO_POP, RET_FALSE, ALIGNED, LOOP16, CHECK_16, DONE,\n+    \/\/ precondition: a copy of len is already in result\n+    \/\/ __ mov(result, len);\n+  Label RET_TRUE, RET_TRUE_NO_POP, RET_FALSE, ALIGNED, LOOP16, CHECK_16,\n@@ -4689,1 +4690,1 @@\n-  __ cset(result, Assembler::NE);\n+  __ csel(result, zr, result, Assembler::NE);\n@@ -4700,1 +4701,1 @@\n-  __ cset(result, Assembler::NE);\n+  __ csel(result, zr, result, Assembler::NE);\n@@ -4707,1 +4708,1 @@\n-  has_negatives_long = __ pc(); \/\/ 2nd entry point\n+  count_positives_long = __ pc(); \/\/ 2nd entry point\n@@ -4807,1 +4808,0 @@\n-    __ mov(result, zr);\n@@ -4814,1 +4814,1 @@\n-    __ mov(result, 1);\n+    __ mov(result, zr);\n@@ -4817,4 +4817,0 @@\n-  __ bind(DONE);\n-    __ pop(spilled_regs, sp);\n-    __ leave();\n-    __ ret(lr);\n@@ -7522,2 +7518,2 @@\n-    \/\/ has negatives stub for large arrays.\n-    StubRoutines::aarch64::_has_negatives = generate_has_negatives(StubRoutines::aarch64::_has_negatives_long);\n+    \/\/ countPositives stub for large arrays.\n+    StubRoutines::aarch64::_count_positives = generate_count_positives(StubRoutines::aarch64::_count_positives_long);\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":11,"deletions":15,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -48,2 +48,2 @@\n-address StubRoutines::aarch64::_has_negatives = NULL;\n-address StubRoutines::aarch64::_has_negatives_long = NULL;\n+address StubRoutines::aarch64::_count_positives = NULL;\n+address StubRoutines::aarch64::_count_positives_long = NULL;\n","filename":"src\/hotspot\/cpu\/aarch64\/stubRoutines_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -61,2 +61,2 @@\n-  static address _has_negatives;\n-  static address _has_negatives_long;\n+  static address _count_positives;\n+  static address _count_positives_long;\n@@ -134,2 +134,2 @@\n-  static address has_negatives() {\n-    return _has_negatives;\n+  static address count_positives() {\n+    return _count_positives;\n@@ -138,2 +138,2 @@\n-  static address has_negatives_long() {\n-      return _has_negatives_long;\n+  static address count_positives_long() {\n+      return _count_positives_long;\n","filename":"src\/hotspot\/cpu\/aarch64\/stubRoutines_aarch64.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,7 +39,1 @@\n-        int limit = off + len;\n-        for (int i = off; i < limit; i++) {\n-            if (ba[i] < 0) {\n-                return true;\n-            }\n-        }\n-        return false;\n+        return countPositives(ba, off, len) != len;\n@@ -54,3 +48,0 @@\n-        if (!hasNegatives(ba, off, len))\n-            return len;\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringCoding.java","additions":2,"deletions":11,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -94,0 +94,5 @@\n+                        if (t == 0 && r < len) {\n+                            \/\/ allow intrinsics to bail out and return zero when there\n+                            \/\/ are negative bytes\n+                            continue;\n+                        }\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/string\/TestCountPositives.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"}]}