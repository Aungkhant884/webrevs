{"files":[{"patch":"@@ -812,0 +812,1 @@\n+#if INCLUDE_CDS_JAVA_HEAP\n@@ -816,1 +817,3 @@\n-  return CompressedKlassPointers::encode_not_null(requested_k, _requested_static_archive_bottom);\n+  address narrow_klass_base = _requested_static_archive_bottom; \/\/ future encoding base == future mapping start\n+  const int narrow_klass_shift = ArchiveHeapWriter::precomputed_narrow_klass_shift;\n+  return CompressedKlassPointers::encode_not_null(requested_k, narrow_klass_base, narrow_klass_shift);\n@@ -818,0 +821,1 @@\n+#endif \/\/ INCLUDE_CDS_JAVA_HEAP\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -195,0 +195,12 @@\n+\n+  \/\/ Archived heap object headers carry pre-computed narrow Klass ids calculated with the\n+  \/\/ following scheme:\n+  \/\/ 1) the encoding base must be the mapping start address.\n+  \/\/ 2) shift must be large enough to result in an encoding range that covers the future Klass range.\n+  \/\/    That Klass range is defined by CDS archive size and future class space size. Luckily, the maximum\n+  \/\/    size can be predicted: archive size is assumed to be <1G, class space size capped at 3G, and at\n+  \/\/    runtime we put both regions adjacent to each other. Therefore, future Klass range size < 4G.\n+  \/\/    Since nKlass itself is 32 bit, our encoding range len is 4G, and since we set the base directly\n+  \/\/    at mapping start, these 4G are enough. Therefore, we don't need to shift at all (shift=0).\n+  static constexpr int precomputed_narrow_klass_shift = 0;\n+\n","filename":"src\/hotspot\/share\/cds\/archiveHeapWriter.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -225,1 +225,0 @@\n-  _narrow_klass_shift = CompressedKlassPointers::shift();\n@@ -286,1 +285,0 @@\n-  st->print_cr(\"- narrow_klass_shift:             %d\", _narrow_klass_shift);\n@@ -2019,0 +2017,7 @@\n+  \/\/ We pre-compute narrow Klass IDs with the future mapping start intended to be the base, and a shift of\n+  \/\/ ArchiveHeapWriter::precomputed_narrow_klass_shift. We enforce this encoding at runtime (see\n+  \/\/ CompressedKlassPointers::initialize_for_given_encoding()). Therefore, the following assertions must\n+  \/\/ hold:\n+  address archive_narrow_klass_base = (address)header()->mapped_base_address();\n+  const int archive_narrow_klass_shift = ArchiveHeapWriter::precomputed_narrow_klass_shift;\n+\n@@ -2021,2 +2026,2 @@\n-  log_info(cds)(\"    narrow_klass_base = \" PTR_FORMAT \", narrow_klass_shift = %d\",\n-                p2i(narrow_klass_base()), narrow_klass_shift());\n+  log_info(cds)(\"    narrow_klass_base at mapping start address, narrow_klass_shift = %d\",\n+                archive_narrow_klass_shift);\n@@ -2040,5 +2045,5 @@\n-  if (narrow_klass_base() != CompressedKlassPointers::base() ||\n-      narrow_klass_shift() != CompressedKlassPointers::shift()) {\n-    log_info(cds)(\"CDS heap data cannot be used because the archive was created with an incompatible narrow klass encoding mode.\");\n-    return false;\n-  }\n+  assert(archive_narrow_klass_base == CompressedKlassPointers::base(), \"Unexpected encoding base encountered \"\n+         \"(\" PTR_FORMAT \", expected \" PTR_FORMAT \")\", p2i(CompressedKlassPointers::base()), p2i(archive_narrow_klass_base));\n+  assert(archive_narrow_klass_shift == CompressedKlassPointers::shift(), \"Unexpected encoding shift encountered \"\n+         \"(%d, expected %d)\", CompressedKlassPointers::shift(), archive_narrow_klass_shift);\n+\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":14,"deletions":9,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -197,1 +197,0 @@\n-  int     _narrow_klass_shift;                    \/\/ save narrow klass base and shift\n@@ -265,2 +264,0 @@\n-  int narrow_klass_shift()                 const { return _narrow_klass_shift; }\n-  address narrow_klass_base()              const { return (address)mapped_base_address(); }\n@@ -385,2 +382,0 @@\n-  address narrow_klass_base()  const { return header()->narrow_klass_base(); }\n-  int     narrow_klass_shift() const { return header()->narrow_klass_shift(); }\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -72,0 +72,1 @@\n+#include \"runtime\/globals.hpp\"\n@@ -1149,1 +1150,6 @@\n-          CompressedKlassPointers::initialize(cds_base, ccs_end - cds_base);\n+          address precomputed_narrow_klass_base = cds_base;\n+          const int precomputed_narrow_klass_shift = ArchiveHeapWriter::precomputed_narrow_klass_shift;\n+          CompressedKlassPointers::initialize_for_given_encoding(\n+            cds_base, ccs_end - cds_base, \/\/ Klass range\n+            precomputed_narrow_klass_base, precomputed_narrow_klass_shift \/\/ precomputed encoding, see ArchiveHeapWriter\n+            );\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -189,0 +189,22 @@\n+\/\/ Given a klass range [addr, addr+len) and a given encoding scheme, assert that this scheme covers the range, then\n+\/\/ set this encoding scheme. Used by CDS at runtime to re-instate the scheme used to pre-compute klass ids for\n+\/\/ archived heap objects.\n+void CompressedKlassPointers::initialize_for_given_encoding(address addr, size_t len, address requested_base, int requested_shift) {\n+#ifdef _LP64\n+  assert(is_valid_base(requested_base), \"Address must be a valid encoding base\");\n+  address const end = addr + len;\n+\n+  const int narrow_klasspointer_bits = sizeof(narrowKlass) * 8;\n+  const size_t encoding_range_size = nth_bit(narrow_klasspointer_bits + requested_shift);\n+  address encoding_range_end = requested_base + encoding_range_size;\n+\n+  assert(requested_base <= addr && encoding_range_end >= end, \"Encoding does not cover the full Klass range\");\n+\n+  set_base(requested_base);\n+  set_shift(requested_shift);\n+  set_range(encoding_range_size);\n+\n+  #else\n+  fatal(\"64bit only.\");\n+#endif\n+}\n@@ -204,17 +226,4 @@\n-  if (UseSharedSpaces || DumpSharedSpaces) {\n-\n-    \/\/ Special requirements if CDS is active:\n-    \/\/ Encoding base and shift must be the same between dump and run time.\n-    \/\/   CDS takes care that the SharedBaseAddress and CompressedClassSpaceSize\n-    \/\/   are the same. Archive size will be probably different at runtime, but\n-    \/\/   it can only be smaller than at, never larger, since archives get\n-    \/\/   shrunk at the end of the dump process.\n-    \/\/   From that it follows that the range [addr, len) we are handed in at\n-    \/\/   runtime will start at the same address then at dumptime, and its len\n-    \/\/   may be smaller at runtime then it was at dump time.\n-    \/\/\n-    \/\/ To be very careful here, we avoid any optimizations and just keep using\n-    \/\/  the same address and shift value. Specifically we avoid using zero-based\n-    \/\/  encoding. We also set the expected value range to 4G (encoding range\n-    \/\/  cannot be larger than that).\n-\n+  \/\/ Otherwise we attempt to use a zero base if the range fits in lower 32G.\n+  if (end <= (address)KlassEncodingMetaspaceMax) {\n+    base = 0;\n+  } else {\n@@ -222,0 +231,1 @@\n+  }\n@@ -223,14 +233,2 @@\n-    \/\/ JDK-8265705\n-    \/\/ This is a temporary fix for aarch64: there, if the range-to-be-encoded is located\n-    \/\/  below 32g, either encoding base should be zero or base should be aligned to 4G\n-    \/\/  and shift should be zero. The simplest way to fix this for now is to force\n-    \/\/  shift to zero for both runtime and dumptime.\n-    \/\/ Note however that this is not a perfect solution. Ideally this whole function\n-    \/\/  should be CDS agnostic, that would simplify it - and testing - a lot. See JDK-8267141\n-    \/\/  for details.\n-    shift = 0;\n-\n-    \/\/ This must be true since at dumptime cds+ccs is 4G, at runtime it can\n-    \/\/  only be smaller, see comment above.\n-    assert(len <= 4 * G, \"Encoding range cannot be larger than 4G\");\n-    range = 4 * G;\n+  \/\/ Highest offset a Klass* can ever have in relation to base.\n+  range = end - base;\n@@ -238,0 +236,4 @@\n+  \/\/ We may not even need a shift if the range fits into 32bit:\n+  const uint64_t UnscaledClassSpaceMax = (uint64_t(max_juint) + 1);\n+  if (range < UnscaledClassSpaceMax) {\n+    shift = 0;\n@@ -239,19 +241,1 @@\n-\n-    \/\/ Otherwise we attempt to use a zero base if the range fits in lower 32G.\n-    if (end <= (address)KlassEncodingMetaspaceMax) {\n-      base = 0;\n-    } else {\n-      base = addr;\n-    }\n-\n-    \/\/ Highest offset a Klass* can ever have in relation to base.\n-    range = end - base;\n-\n-    \/\/ We may not even need a shift if the range fits into 32bit:\n-    const uint64_t UnscaledClassSpaceMax = (uint64_t(max_juint) + 1);\n-    if (range < UnscaledClassSpaceMax) {\n-      shift = 0;\n-    } else {\n-      shift = LogKlassAlignmentInBytes;\n-    }\n-\n+    shift = LogKlassAlignmentInBytes;\n","filename":"src\/hotspot\/share\/oops\/compressedOops.cpp","additions":34,"deletions":50,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -169,0 +169,5 @@\n+  \/\/ Given a klass range [addr, addr+len) and a given encoding scheme, assert that this scheme covers the range, then\n+  \/\/ set this encoding scheme. Used by CDS at runtime to re-instate the scheme used to pre-compute klass ids for\n+  \/\/ archived heap objects.\n+  static void initialize_for_given_encoding(address addr, size_t len, address requested_base, int requested_shift);\n+\n@@ -185,1 +190,1 @@\n-  static inline Klass* decode_raw(narrowKlass v, address base);\n+  static inline Klass* decode_raw(narrowKlass v, address base, int shift);\n@@ -188,1 +193,1 @@\n-  static inline Klass* decode_not_null(narrowKlass v, address base);\n+  static inline Klass* decode_not_null(narrowKlass v, address base, int shift);\n@@ -191,1 +196,1 @@\n-  static inline narrowKlass encode_not_null(Klass* v, address base);\n+  static inline narrowKlass encode_not_null(Klass* v, address base, int shift);\n","filename":"src\/hotspot\/share\/oops\/compressedOops.hpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -126,1 +126,1 @@\n-  return decode_raw(v, base());\n+  return decode_raw(v, base(), shift());\n@@ -129,2 +129,2 @@\n-inline Klass* CompressedKlassPointers::decode_raw(narrowKlass v, address narrow_base) {\n-  return (Klass*)((uintptr_t)narrow_base +((uintptr_t)v << shift()));\n+inline Klass* CompressedKlassPointers::decode_raw(narrowKlass v, address narrow_base, int shift) {\n+  return (Klass*)((uintptr_t)narrow_base +((uintptr_t)v << shift));\n@@ -134,1 +134,1 @@\n-  return decode_not_null(v, base());\n+  return decode_not_null(v, base(), shift());\n@@ -137,1 +137,1 @@\n-inline Klass* CompressedKlassPointers::decode_not_null(narrowKlass v, address narrow_base) {\n+inline Klass* CompressedKlassPointers::decode_not_null(narrowKlass v, address narrow_base, int shift) {\n@@ -139,1 +139,1 @@\n-  Klass* result = decode_raw(v, narrow_base);\n+  Klass* result = decode_raw(v, narrow_base, shift);\n@@ -149,1 +149,1 @@\n-  return encode_not_null(v, base());\n+  return encode_not_null(v, base(), shift());\n@@ -152,1 +152,1 @@\n-inline narrowKlass CompressedKlassPointers::encode_not_null(Klass* v, address narrow_base) {\n+inline narrowKlass CompressedKlassPointers::encode_not_null(Klass* v, address narrow_base, int shift) {\n@@ -157,1 +157,1 @@\n-  uint64_t result = pd >> shift();\n+  uint64_t result = pd >> shift;\n@@ -159,1 +159,1 @@\n-  assert(decode_not_null((narrowKlass)result, narrow_base) == v, \"reversibility\");\n+  assert(decode_not_null((narrowKlass)result, narrow_base, shift) == v, \"reversibility\");\n","filename":"src\/hotspot\/share\/oops\/compressedOops.inline.hpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"}]}