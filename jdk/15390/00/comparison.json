{"files":[{"patch":"@@ -92,6 +92,6 @@\n-\n-        \/\/ The key is zeroized by finalize()\n-        \/\/ The reachability fence ensures finalize() isn't called early\n-        byte[] result = key.clone();\n-        Reference.reachabilityFence(this);\n-        return result;\n+        try {\n+            return key.clone();\n+        } finally {\n+            \/\/ prevent this from being cleaned for the above block\n+            Reference.reachabilityFence(this);\n+        }\n@@ -114,1 +114,6 @@\n-        return Arrays.hashCode(this.key) ^ \"des\".hashCode();\n+        try {\n+            return Arrays.hashCode(this.key) ^ \"des\".hashCode();\n+        } finally {\n+            \/\/ prevent this from being cleaned for the above block\n+            Reference.reachabilityFence(this);\n+        }\n@@ -119,14 +124,19 @@\n-        if (this == obj)\n-            return true;\n-\n-        if (!(obj instanceof SecretKey that))\n-            return false;\n-\n-        String thatAlg = that.getAlgorithm();\n-        if (!(thatAlg.equalsIgnoreCase(\"DES\")))\n-            return false;\n-\n-        byte[] thatKey = that.getEncoded();\n-        boolean ret = MessageDigest.isEqual(this.key, thatKey);\n-        java.util.Arrays.fill(thatKey, (byte)0x00);\n-        return ret;\n+        try {\n+            if (this == obj)\n+                return true;\n+\n+            if (!(obj instanceof SecretKey that))\n+                return false;\n+\n+            String thatAlg = that.getAlgorithm();\n+            if (!(thatAlg.equalsIgnoreCase(\"DES\")))\n+                return false;\n+\n+            byte[] thatKey = that.getEncoded();\n+            boolean ret = MessageDigest.isEqual(this.key, thatKey);\n+            java.util.Arrays.fill(thatKey, (byte)0x00);\n+            return ret;\n+        } finally {\n+            \/\/ prevent this from being cleaned for the above block\n+            Reference.reachabilityFence(this);\n+        }\n@@ -144,1 +154,7 @@\n-        key = key.clone();\n+        byte[] temp = key;\n+        key = temp.clone();\n+        Arrays.fill(temp, (byte)0x00);\n+        \/\/ Use the cleaner to zero the key when no longer referenced\n+        final byte[] k = this.key;\n+        CleanerFactory.cleaner().register(this,\n+                () -> java.util.Arrays.fill(k, (byte)0x00));\n@@ -157,1 +173,2 @@\n-        return new KeyRep(KeyRep.Type.SECRET,\n+        try {\n+            return new KeyRep(KeyRep.Type.SECRET,\n@@ -161,0 +178,4 @@\n+        } finally {\n+            \/\/ prevent this from being cleaned for the above block\n+            Reference.reachabilityFence(this);\n+        }\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DESKey.java","additions":44,"deletions":23,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -92,5 +92,6 @@\n-        \/\/ The key is zeroized by finalize()\n-        \/\/ The reachability fence ensures finalize() isn't called early\n-        byte[] result = key.clone();\n-        Reference.reachabilityFence(this);\n-        return result;\n+        try {\n+            return key.clone();\n+        } finally {\n+            \/\/ prevent this from being cleaned for the above block\n+            Reference.reachabilityFence(this);\n+        }\n@@ -113,1 +114,6 @@\n-        return Arrays.hashCode(this.key) ^ \"desede\".hashCode();\n+        try {\n+            return Arrays.hashCode(this.key) ^ \"desede\".hashCode();\n+        } finally {\n+            \/\/ prevent this from being cleaned for the above block\n+            Reference.reachabilityFence(this);\n+        }\n@@ -118,15 +124,20 @@\n-        if (this == obj)\n-            return true;\n-\n-        if (!(obj instanceof SecretKey that))\n-            return false;\n-\n-        String thatAlg = that.getAlgorithm();\n-        if (!(thatAlg.equalsIgnoreCase(\"DESede\"))\n-            && !(thatAlg.equalsIgnoreCase(\"TripleDES\")))\n-            return false;\n-\n-        byte[] thatKey = that.getEncoded();\n-        boolean ret = MessageDigest.isEqual(this.key, thatKey);\n-        java.util.Arrays.fill(thatKey, (byte)0x00);\n-        return ret;\n+        try {\n+            if (this == obj)\n+                return true;\n+\n+            if (!(obj instanceof SecretKey that))\n+                return false;\n+\n+            String thatAlg = that.getAlgorithm();\n+            if (!(thatAlg.equalsIgnoreCase(\"DESede\"))\n+                && !(thatAlg.equalsIgnoreCase(\"TripleDES\")))\n+                return false;\n+\n+            byte[] thatKey = that.getEncoded();\n+            boolean ret = MessageDigest.isEqual(this.key, thatKey);\n+            java.util.Arrays.fill(thatKey, (byte)0x00);\n+            return ret;\n+        } finally {\n+            \/\/ prevent this from being cleaned for the above block\n+            Reference.reachabilityFence(this);\n+        }\n@@ -144,1 +155,7 @@\n-        key = key.clone();\n+        byte[] temp = key;\n+        this.key = temp.clone();\n+        java.util.Arrays.fill(temp, (byte)0x00);\n+        \/\/ Use the cleaner to zero the key when no longer referenced\n+        final byte[] k = this.key;\n+        CleanerFactory.cleaner().register(this,\n+                () -> java.util.Arrays.fill(k, (byte)0x00));\n@@ -157,4 +174,9 @@\n-        return new KeyRep(KeyRep.Type.SECRET,\n-                getAlgorithm(),\n-                getFormat(),\n-                key);\n+        try {\n+            return new KeyRep(KeyRep.Type.SECRET,\n+                    getAlgorithm(),\n+                    getFormat(),\n+                    key);\n+        } finally {\n+            \/\/ prevent this from being cleaned for the above block\n+            Reference.reachabilityFence(this);\n+        }\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/DESedeKey.java","additions":48,"deletions":26,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -132,1 +132,1 @@\n-            sKey = new PBEKey(pbeKeySpec, \"PBEWithMD5AndTripleDES\", false);\n+            sKey = new PBEKey(pbeKeySpec, \"PBEWithMD5AndTripleDES\");\n@@ -196,1 +196,1 @@\n-                sKey = new PBEKey(pbeKeySpec, \"PBEWithMD5AndTripleDES\", false);\n+                sKey = new PBEKey(pbeKeySpec, \"PBEWithMD5AndTripleDES\");\n@@ -342,1 +342,1 @@\n-            sKey = new PBEKey(pbeKeySpec, \"PBEWithMD5AndTripleDES\", false);\n+            sKey = new PBEKey(pbeKeySpec, \"PBEWithMD5AndTripleDES\");\n@@ -369,2 +369,1 @@\n-            sKey = new PBEKey(pbeKeySpec,\n-                    \"PBEWithMD5AndTripleDES\", false);\n+            sKey = new PBEKey(pbeKeySpec, \"PBEWithMD5AndTripleDES\");\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/KeyProtector.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.lang.ref.Cleaner.Cleanable;\n@@ -54,0 +55,2 @@\n+    private transient Cleanable cleanable;\n+\n@@ -59,2 +62,1 @@\n-    PBEKey(PBEKeySpec keySpec, String keytype, boolean useCleaner)\n-            throws InvalidKeySpecException {\n+    PBEKey(PBEKeySpec keySpec, String keytype) throws InvalidKeySpecException {\n@@ -81,5 +83,3 @@\n-        if (useCleaner) {\n-            final byte[] k = this.key;\n-            CleanerFactory.cleaner().register(this,\n-                () -> Arrays.fill(k, (byte) 0x00));\n-        }\n+        final byte[] k = this.key;\n+        cleanable = CleanerFactory.cleaner().register(this,\n+                () -> java.util.Arrays.fill(k, (byte)0x00));\n@@ -89,5 +89,6 @@\n-        \/\/ The key is zeroized by finalize()\n-        \/\/ The reachability fence ensures finalize() isn't called early\n-        byte[] result = key.clone();\n-        Reference.reachabilityFence(this);\n-        return result;\n+        try {\n+            return key.clone();\n+        } finally {\n+            \/\/ prevent this from being cleaned for the above block\n+            Reference.reachabilityFence(this);\n+        }\n@@ -110,2 +111,7 @@\n-        return Arrays.hashCode(this.key)\n-                ^ getAlgorithm().toLowerCase(Locale.ENGLISH).hashCode();\n+        try {\n+            return Arrays.hashCode(this.key)\n+                    ^ getAlgorithm().toLowerCase(Locale.ENGLISH).hashCode();\n+        } finally {\n+            \/\/ prevent this from being cleaned for the above block\n+            Reference.reachabilityFence(this);\n+        }\n@@ -116,2 +122,6 @@\n-        if (obj == this)\n-            return true;\n+        try {\n+            if (obj == this)\n+                return true;\n+\n+            if (!(obj instanceof SecretKey that))\n+                return false;\n@@ -119,2 +129,4 @@\n-        if (!(obj instanceof SecretKey that))\n-            return false;\n+            \/\/ destroyed keys are considered different\n+            if (isDestroyed() || that.isDestroyed()) {\n+                return false;\n+            }\n@@ -122,2 +134,2 @@\n-        if (!(that.getAlgorithm().equalsIgnoreCase(type)))\n-            return false;\n+            if (!(that.getAlgorithm().equalsIgnoreCase(type)))\n+                return false;\n@@ -125,4 +137,8 @@\n-        byte[] thatEncoded = that.getEncoded();\n-        boolean ret = MessageDigest.isEqual(this.key, thatEncoded);\n-        Arrays.fill(thatEncoded, (byte)0x00);\n-        return ret;\n+            byte[] thatEncoded = that.getEncoded();\n+            boolean ret = MessageDigest.isEqual(this.key, thatEncoded);\n+            Arrays.fill(thatEncoded, (byte)0x00);\n+            return ret;\n+        } finally {\n+            \/\/ prevent this from being cleaned for the above block\n+            Reference.reachabilityFence(this);\n+        }\n@@ -137,3 +153,3 @@\n-        if (key != null) {\n-            Arrays.fill(key, (byte) 0x00);\n-            key = null;\n+        if (cleanable != null) {\n+            cleanable.clean();\n+            cleanable = null;\n@@ -143,0 +159,5 @@\n+    @Override\n+    public boolean isDestroyed() {\n+        return (cleanable == null);\n+    }\n+\n@@ -152,1 +173,7 @@\n-        key = key.clone();\n+        byte[] temp = key;\n+        key = temp.clone();\n+        Arrays.fill(temp, (byte)0x00);\n+        \/\/ Use cleaner to zero the key when no longer referenced\n+        final byte[] k = this.key;\n+        cleanable = CleanerFactory.cleaner().register(this,\n+                () -> java.util.Arrays.fill(k, (byte)0x00));\n@@ -166,4 +193,9 @@\n-        return new KeyRep(KeyRep.Type.SECRET,\n-                getAlgorithm(),\n-                getFormat(),\n-                key);\n+        try {\n+            return new KeyRep(KeyRep.Type.SECRET,\n+                    getAlgorithm(),\n+                    getFormat(),\n+                    key);\n+        } finally {\n+            \/\/ prevent this from being cleaned for the above block\n+            Reference.reachabilityFence(this);\n+        }\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/PBEKey.java","additions":64,"deletions":32,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -242,1 +242,1 @@\n-        return new PBEKey((PBEKeySpec)keySpec, type, true);\n+        return new PBEKey((PBEKeySpec)keySpec, type);\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/PBEKeyFactory.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8312306\n+ * @summary Check the destroy()\/isDestroyed() of the PBEKey impl from SunJCE\n+ * @library \/test\/lib\n+ * @run testng\/othervm PBEKeyDestroyTest\n+ *\/\n+import javax.crypto.*;\n+import javax.crypto.spec.*;\n+import java.nio.charset.StandardCharsets;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+public class PBEKeyDestroyTest {\n+\n+    @Test\n+    public void test() throws Exception {\n+        PBEKeySpec keySpec = new PBEKeySpec(\"12345678\".toCharArray(),\n+                \"abcdefgh\".getBytes(StandardCharsets.UTF_8), 100000, 128 >> 3);\n+\n+        SecretKeyFactory skf = SecretKeyFactory.getInstance\n+                (\"PBEWithHmacSHA1AndAES_128\", \"SunJCE\");\n+\n+        SecretKey key1 = skf.generateSecret(keySpec);\n+        SecretKey key2 = skf.generateSecret(keySpec);\n+\n+        \/\/ should be equal\n+        Assert.assertFalse(key1.isDestroyed());\n+        Assert.assertFalse(key2.isDestroyed());\n+        Assert.assertTrue(key1.equals(key2));\n+        Assert.assertTrue(key2.equals(key1));\n+\n+        \/\/ destroy key1\n+        key1.destroy();\n+        Assert.assertTrue(key1.isDestroyed());\n+        Assert.assertFalse(key1.equals(key2));\n+        Assert.assertFalse(key2.equals(key1));\n+\n+        \/\/ also destroy key2\n+        key2.destroy();\n+        Assert.assertTrue(key2.isDestroyed());\n+        Assert.assertFalse(key1.equals(key2));\n+        Assert.assertFalse(key2.equals(key1));\n+\n+        \/\/ call destroy again to make sure no unexpected exceptions\n+        key2.destroy();\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/KeyFactory\/PBEKeyDestroyTest.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"}]}