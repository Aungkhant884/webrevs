{"files":[{"patch":"@@ -1550,2 +1550,6 @@\n-} else {\n-    \/\/ We want the nmethod to be deoptimized immediately.\n+\n+    \/\/ Do not clear the address field here as the Java code may still\n+    \/\/ want to later call this method with deoptimize == true. That requires\n+    \/\/ the address field to still be pointing at the nmethod.\n+   } else {\n+    \/\/ Deoptimize the nmethod immediately.\n@@ -1553,1 +1557,0 @@\n-  }\n@@ -1555,3 +1558,4 @@\n-  \/\/ A HotSpotNmethod instance can only reference a single nmethod\n-  \/\/ during its lifetime so simply clear it here.\n-  set_InstalledCode_address(mirror, 0);\n+    \/\/ A HotSpotNmethod instance can only reference a single nmethod\n+    \/\/ during its lifetime so simply clear it here.\n+    set_InstalledCode_address(mirror, 0);\n+  }\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.cpp","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,131 @@\n+\/*\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.jvmci.common;\n+\n+import jdk.vm.ci.code.Architecture;\n+import jdk.vm.ci.code.CodeCacheProvider;\n+import jdk.vm.ci.code.Register;\n+import jdk.vm.ci.code.RegisterArray;\n+import jdk.vm.ci.code.StackSlot;\n+import jdk.vm.ci.code.site.DataPatch;\n+import jdk.vm.ci.code.site.Site;\n+import jdk.vm.ci.code.InstalledCode;\n+import jdk.vm.ci.hotspot.HotSpotCompiledCode;\n+import jdk.vm.ci.hotspot.HotSpotCompiledCode.Comment;\n+import jdk.vm.ci.hotspot.HotSpotCompiledNmethod;\n+import jdk.vm.ci.hotspot.HotSpotConstantReflectionProvider;\n+import jdk.vm.ci.hotspot.HotSpotResolvedJavaMethod;\n+import jdk.vm.ci.meta.Assumptions.Assumption;\n+import jdk.vm.ci.meta.MetaAccessProvider;\n+import jdk.vm.ci.meta.PlatformKind;\n+import jdk.vm.ci.meta.ResolvedJavaMethod;\n+import jdk.vm.ci.meta.SpeculationLog;\n+import jdk.vm.ci.runtime.JVMCI;\n+import jdk.vm.ci.runtime.JVMCIBackend;\n+import org.junit.Assert;\n+\n+import java.lang.reflect.Method;\n+\n+public class CodeInstallerTest {\n+\n+    protected final Architecture arch;\n+    protected final CodeCacheProvider codeCache;\n+    protected final MetaAccessProvider metaAccess;\n+    protected final HotSpotConstantReflectionProvider constantReflection;\n+\n+    protected final HotSpotResolvedJavaMethod dummyMethod;\n+\n+    public static void dummyMethod() {\n+    }\n+\n+    protected CodeInstallerTest() {\n+        JVMCIBackend backend = JVMCI.getRuntime().getHostJVMCIBackend();\n+        metaAccess = backend.getMetaAccess();\n+        codeCache = backend.getCodeCache();\n+        constantReflection = (HotSpotConstantReflectionProvider) backend.getConstantReflection();\n+        arch = codeCache.getTarget().arch;\n+\n+        Method method = null;\n+        try {\n+            method = CodeInstallerTest.class.getMethod(\"dummyMethod\");\n+        } catch (NoSuchMethodException e) {\n+            Assert.fail();\n+        }\n+\n+        dummyMethod = (HotSpotResolvedJavaMethod) metaAccess.lookupJavaMethod(method);\n+    }\n+\n+    protected InstalledCode installEmptyCode(Site[] sites,\n+                                    Assumption[] assumptions,\n+                                    Comment[] comments,\n+                                    int dataSectionAlignment,\n+                                    DataPatch[] dataSectionPatches,\n+                                    StackSlot deoptRescueSlot) {\n+        ResolvedJavaMethod[] methods = {dummyMethod};\n+        byte[] targetCode = {0};\n+        int targetCodeSize = targetCode.length;\n+        boolean isImmutablePIC = false;\n+        int totalFrameSize = 0;\n+        int entryBCI = 0;\n+        int id = 1;\n+        long compileState = 0L;\n+        boolean hasUnsafeAccess = false;\n+\n+        HotSpotCompiledCode code =\n+            new HotSpotCompiledNmethod(\"dummyMethod\",\n+                                    targetCode,\n+                                    targetCodeSize,\n+                                    sites,\n+                                    assumptions,\n+                                    methods,\n+                                    comments,\n+                                    new byte[8],\n+                                    dataSectionAlignment,\n+                                    dataSectionPatches,\n+                                    isImmutablePIC,\n+                                    totalFrameSize,\n+                                    deoptRescueSlot,\n+                                    dummyMethod,\n+                                    entryBCI,\n+                                    id,\n+                                    compileState,\n+                                    hasUnsafeAccess);\n+        SpeculationLog log = null;\n+        InstalledCode installedCode = null;\n+        return codeCache.addCode(dummyMethod, code, log, installedCode);\n+    }\n+\n+    protected Register getRegister(PlatformKind kind, int index) {\n+        int idx = index;\n+        RegisterArray allRegs = arch.getAvailableValueRegisters();\n+        for (Register reg : allRegs) {\n+            if (arch.canStoreValue(reg.getRegisterCategory(), kind)) {\n+                if (idx-- == 0) {\n+                    return reg;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/common\/CodeInstallerTest.java","additions":131,"deletions":0,"binary":false,"changes":131,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -246,2 +246,2 @@\n-    public static void invalidateHotSpotNmethod(HotSpotNmethod nmethodMirror) {\n-        CTVM.invalidateHotSpotNmethod(nmethodMirror, true);\n+    public static void invalidateHotSpotNmethod(HotSpotNmethod nmethodMirror, boolean deoptimize) {\n+        CTVM.invalidateHotSpotNmethod(nmethodMirror, deoptimize);\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/common\/patches\/jdk.internal.vm.ci\/jdk\/vm\/ci\/hotspot\/CompilerToVMHelper.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,2 +30,0 @@\n- * @ignore 8249621\n- * @ignore 8163894\n@@ -37,0 +35,2 @@\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.code.site\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.meta\n@@ -40,2 +40,1 @@\n- * @build compiler.jvmci.compilerToVM.InvalidateInstalledCodeTest\n- * @build jdk.test.whitebox.WhiteBox\n+ *        jdk.test.whitebox.WhiteBox jdk.test.whitebox.parser.DiagnosticCommand\n@@ -43,1 +42,2 @@\n- * @run main\/othervm -Xbootclasspath\/a:.\n+ *                                jdk.test.whitebox.parser.DiagnosticCommand\n+ * @run junit\/othervm -Xbootclasspath\/a:.\n@@ -51,0 +51,1 @@\n+import compiler.jvmci.common.CodeInstallerTest;\n@@ -54,2 +55,0 @@\n-import jdk.vm.ci.code.CodeCacheProvider;\n-import jdk.vm.ci.code.CompilationResult;\n@@ -57,0 +56,2 @@\n+import jdk.vm.ci.code.site.Site;\n+import jdk.vm.ci.code.site.DataPatch;\n@@ -58,1 +59,0 @@\n-import jdk.vm.ci.hotspot.HotSpotCompilationRequest;\n@@ -61,1 +61,3 @@\n-import jdk.test.whitebox.code.NMethod;\n+import jdk.vm.ci.hotspot.HotSpotCompiledCode.Comment;\n+import jdk.vm.ci.hotspot.HotSpotNmethod;\n+import jdk.vm.ci.meta.Assumptions.Assumption;\n@@ -64,0 +66,1 @@\n+import org.junit.Test;\n@@ -65,4 +68,1 @@\n-public class InvalidateInstalledCodeTest {\n-    private static final CodeCacheProvider CACHE_PROVIDER\n-            = HotSpotJVMCIRuntime.runtime().getHostJVMCIBackend()\n-                    .getCodeCache();\n+public class InvalidateInstalledCodeTest extends CodeInstallerTest {\n@@ -70,3 +70,2 @@\n-    public static void main(String[] args) {\n-        InvalidateInstalledCodeTest test\n-                = new InvalidateInstalledCodeTest();\n+    @Test\n+    public void testInvalidation() {\n@@ -76,2 +75,2 @@\n-        testCases.forEach(test::check);\n-        test.checkNull();\n+        testCases.forEach(t -> check(t));\n+        checkNull();\n@@ -82,1 +81,1 @@\n-                () -> CompilerToVMHelper.invalidateInstalledCode(null),\n+                () -> CompilerToVMHelper.invalidateHotSpotNmethod(null, true),\n@@ -87,16 +86,3 @@\n-        System.out.println(testCase);\n-        HotSpotResolvedJavaMethod javaMethod\n-                = CTVMUtilities.getResolvedMethod(testCase.executable);\n-        HotSpotCompilationRequest compRequest = new HotSpotCompilationRequest(\n-                javaMethod, testCase.bci, \/* jvmciEnv = *\/ 0L);\n-        String name = testCase.executable.getName();\n-        CompilationResult compResult = new CompilationResult(name);\n-        \/\/ to pass sanity check of default -1\n-        compResult.setTotalFrameSize(0);\n-        compResult.close();\n-        InstalledCode installedCode = CACHE_PROVIDER.installCode(\n-                compRequest, compResult,\n-                new InstalledCode(name), \/* speculationLog = *\/ null,\n-                \/* isDefault = *\/ false);\n-        Asserts.assertTrue(installedCode.isValid(), testCase\n-                + \" : code is invalid even before invalidation\");\n+        HotSpotResolvedJavaMethod javaMethod = CTVMUtilities.getResolvedMethod(testCase.executable);\n+        HotSpotNmethod nmethod = (HotSpotNmethod) installEmptyCode(new Site[0], new Assumption[0],\n+                new Comment[0], 8, new DataPatch[0], null);\n@@ -104,17 +90,14 @@\n-        NMethod beforeInvalidation = testCase.toNMethod();\n-        if (beforeInvalidation != null) {\n-            throw new Error(\"TESTBUG : \" + testCase + \" : nmethod isn't found\");\n-        }\n-        \/\/ run twice to verify how it works if method is already invalidated\n-        for (int i = 0; i < 2; ++i) {\n-            CompilerToVMHelper.invalidateInstalledCode(installedCode);\n-            Asserts.assertFalse(installedCode.isValid(), testCase\n-                            + \" : code is valid after invalidation, i = \" + i);\n-            NMethod afterInvalidation = testCase.toNMethod();\n-            if (afterInvalidation != null) {\n-                System.err.println(\"before: \" + beforeInvalidation);\n-                System.err.println(\"after: \" + afterInvalidation);\n-                throw new AssertionError(testCase\n-                        + \" : method hasn't been invalidated, i = \" + i);\n-            }\n-        }\n+        Asserts.assertTrue(nmethod.isValid(), testCase + \" : code is invalid even before invalidation\");\n+\n+        Asserts.assertTrue(nmethod.isValid(), testCase + \" : code is not valid, i = \" + nmethod);\n+        Asserts.assertTrue(nmethod.isAlive(), testCase + \" : code is not alive, i = \" + nmethod);\n+\n+        \/\/ Make nmethod non-entrant but still alive\n+        CompilerToVMHelper.invalidateHotSpotNmethod(nmethod, false);\n+        Asserts.assertFalse(nmethod.isValid(), testCase + \" : code is valid, i = \" + nmethod);\n+        Asserts.assertTrue(nmethod.isAlive(), testCase + \" : code is not alive, i = \" + nmethod);\n+\n+        \/\/ Deoptimize the nmethod and cut the link to it from the HotSpotNmethod\n+        CompilerToVMHelper.invalidateHotSpotNmethod(nmethod, true);\n+        Asserts.assertFalse(nmethod.isValid(), testCase + \" : code is valid, i = \" + nmethod);\n+        Asserts.assertFalse(nmethod.isAlive(), testCase + \" : code is alive, i = \" + nmethod);\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/compilerToVM\/InvalidateInstalledCodeTest.java","additions":36,"deletions":53,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -1,96 +0,0 @@\n-\/*\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.jvmci.errors;\n-\n-import jdk.vm.ci.code.Architecture;\n-import jdk.vm.ci.code.CodeCacheProvider;\n-import jdk.vm.ci.code.Register;\n-import jdk.vm.ci.code.RegisterArray;\n-import jdk.vm.ci.code.StackSlot;\n-import jdk.vm.ci.code.site.DataPatch;\n-import jdk.vm.ci.code.site.Site;\n-import jdk.vm.ci.hotspot.HotSpotCompiledCode;\n-import jdk.vm.ci.hotspot.HotSpotCompiledCode.Comment;\n-import jdk.vm.ci.hotspot.HotSpotCompiledNmethod;\n-import jdk.vm.ci.hotspot.HotSpotConstantReflectionProvider;\n-import jdk.vm.ci.hotspot.HotSpotResolvedJavaMethod;\n-import jdk.vm.ci.meta.Assumptions.Assumption;\n-import jdk.vm.ci.meta.MetaAccessProvider;\n-import jdk.vm.ci.meta.PlatformKind;\n-import jdk.vm.ci.meta.ResolvedJavaMethod;\n-import jdk.vm.ci.runtime.JVMCI;\n-import jdk.vm.ci.runtime.JVMCIBackend;\n-import org.junit.Assert;\n-\n-import java.lang.reflect.Method;\n-\n-public class CodeInstallerTest {\n-\n-    protected final Architecture arch;\n-    protected final CodeCacheProvider codeCache;\n-    protected final MetaAccessProvider metaAccess;\n-    protected final HotSpotConstantReflectionProvider constantReflection;\n-\n-    protected final HotSpotResolvedJavaMethod dummyMethod;\n-\n-    public static void dummyMethod() {\n-    }\n-\n-    protected CodeInstallerTest() {\n-        JVMCIBackend backend = JVMCI.getRuntime().getHostJVMCIBackend();\n-        metaAccess = backend.getMetaAccess();\n-        codeCache = backend.getCodeCache();\n-        constantReflection = (HotSpotConstantReflectionProvider) backend.getConstantReflection();\n-        arch = codeCache.getTarget().arch;\n-\n-        Method method = null;\n-        try {\n-            method = CodeInstallerTest.class.getMethod(\"dummyMethod\");\n-        } catch (NoSuchMethodException e) {\n-            Assert.fail();\n-        }\n-\n-        dummyMethod = (HotSpotResolvedJavaMethod) metaAccess.lookupJavaMethod(method);\n-    }\n-\n-    protected void installEmptyCode(Site[] sites, Assumption[] assumptions, Comment[] comments, int dataSectionAlignment, DataPatch[] dataSectionPatches, StackSlot deoptRescueSlot) {\n-        HotSpotCompiledCode code = new HotSpotCompiledNmethod(\"dummyMethod\", new byte[0], 0, sites, assumptions, new ResolvedJavaMethod[]{dummyMethod}, comments, new byte[8], dataSectionAlignment,\n-                        dataSectionPatches, false, 0, deoptRescueSlot,\n-                        dummyMethod, 0, 1, 0L, false);\n-        codeCache.addCode(dummyMethod, code, null, null);\n-    }\n-\n-    protected Register getRegister(PlatformKind kind, int index) {\n-        int idx = index;\n-        RegisterArray allRegs = arch.getAvailableValueRegisters();\n-        for (Register reg : allRegs) {\n-            if (arch.canStoreValue(reg.getRegisterCategory(), kind)) {\n-                if (idx-- == 0) {\n-                    return reg;\n-                }\n-            }\n-        }\n-        return null;\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/errors\/CodeInstallerTest.java","additions":0,"deletions":96,"binary":false,"changes":96,"status":"deleted"},{"patch":"@@ -26,0 +26,1 @@\n+ * @library \/\n@@ -33,1 +34,0 @@\n- * @compile CodeInstallerTest.java\n@@ -40,0 +40,1 @@\n+import compiler.jvmci.common.CodeInstallerTest;\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/errors\/TestInvalidCompilationResult.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @library \/\n@@ -33,1 +34,0 @@\n- * @compile CodeInstallerTest.java\n@@ -40,0 +40,1 @@\n+import compiler.jvmci.common.CodeInstallerTest;\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/errors\/TestInvalidDebugInfo.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * @library \/\n@@ -33,1 +34,0 @@\n- * @compile CodeInstallerTest.java\n@@ -40,0 +40,1 @@\n+import compiler.jvmci.common.CodeInstallerTest;\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/errors\/TestInvalidOopMap.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}