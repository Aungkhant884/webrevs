{"files":[{"patch":"@@ -437,2 +437,1 @@\n-    if (result != nullptr) {\n-      assert(succeeded, \"only way to get back a non-null result\");\n+    if (succeeded) {\n@@ -444,7 +443,0 @@\n-    if (succeeded) {\n-      \/\/ We successfully scheduled a collection which failed to allocate. No\n-      \/\/ point in trying to allocate further. We'll just return null.\n-      log_trace(gc, alloc)(\"%s: Successfully scheduled collection failing to allocate \"\n-                           SIZE_FORMAT \" words\", Thread::current()->name(), word_size);\n-      return nullptr;\n-    }\n@@ -669,2 +661,1 @@\n-    if (result != nullptr) {\n-      assert(succeeded, \"only way to get back a non-null result\");\n+    if (succeeded) {\n@@ -673,3 +664,5 @@\n-      size_t size_in_regions = humongous_obj_size_in_regions(word_size);\n-      policy()->old_gen_alloc_tracker()->\n-        record_collection_pause_humongous_allocation(size_in_regions * HeapRegion::GrainBytes);\n+      if (result != nullptr) {\n+        size_t size_in_regions = humongous_obj_size_in_regions(word_size);\n+        policy()->old_gen_alloc_tracker()->\n+          record_collection_pause_humongous_allocation(size_in_regions * HeapRegion::GrainBytes);\n+      }\n@@ -679,7 +672,0 @@\n-    if (succeeded) {\n-      \/\/ We successfully scheduled a collection which failed to allocate. No\n-      \/\/ point in trying to allocate further. We'll just return null.\n-      log_trace(gc, alloc)(\"%s: Successfully scheduled collection failing to allocate \"\n-                           SIZE_FORMAT \" words\", Thread::current()->name(), word_size);\n-      return nullptr;\n-    }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":7,"deletions":21,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -36,3 +36,3 @@\n-\/\/ This class records for every region on the heap whether it has to be retained\n-\/\/ (i.e. pinned or evacuation failure or both) and records for every such region\n-\/\/ information to speed up iteration of these regions in various gc phases.\n+\/\/ This class records for every region on the heap whether it had experienced an\n+\/\/ evacuation failure or has been found pinned or both and records for every such\n+\/\/ region information to speed up iteration of these regions in various gc phases.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailureRegions.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -57,0 +57,2 @@\n+  inline bool has_pinned_objects(HeapRegion* hr) const;\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCPrepareTask.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -76,0 +76,5 @@\n+inline bool G1DetermineCompactionQueueClosure::has_pinned_objects(HeapRegion* hr) const {\n+  return hr->has_pinned_objects() ||\n+      (hr->is_humongous() && hr->humongous_start_region()->has_pinned_objects());\n+}\n+\n@@ -80,17 +85,15 @@\n-  } else {\n-    assert(hr->containing_set() == nullptr, \"already cleared by PrepareRegionsClosure\");\n-    if (hr->has_pinned_objects() ||\n-        (hr->is_humongous() && hr->humongous_start_region()->has_pinned_objects())) {\n-      \/\/ First check regions with pinned objects: they need to be skipped regardless\n-      \/\/ of region type and never be considered for reclamation.\n-      assert(_collector->is_skip_compacting(hr->hrm_index()), \"pinned region %u must be skip_compacting\", hr->hrm_index());\n-      log_trace(gc, phases)(\"Phase 2: skip compaction region index: %u (%s), has pinned objects\",\n-                            hr->hrm_index(), hr->get_short_type_str());\n-    } else if (hr->is_humongous()) {\n-      oop obj = cast_to_oop(hr->humongous_start_region()->bottom());\n-      bool is_empty = !_collector->mark_bitmap()->is_marked(obj);\n-      if (is_empty) {\n-        free_empty_humongous_region(hr);\n-      } else {\n-        _collector->set_has_humongous();\n-      }\n+    return false;\n+  }\n+\n+  assert(hr->containing_set() == nullptr, \"already cleared by PrepareRegionsClosure\");\n+  if (has_pinned_objects(hr)) {\n+    \/\/ First check regions with pinned objects: they need to be skipped regardless\n+    \/\/ of region type and never be considered for reclamation.\n+    assert(_collector->is_skip_compacting(hr->hrm_index()), \"pinned region %u must be skip_compacting\", hr->hrm_index());\n+    log_trace(gc, phases)(\"Phase 2: skip compaction region index: %u (%s), has pinned objects\",\n+                          hr->hrm_index(), hr->get_short_type_str());\n+  } else if (hr->is_humongous()) {\n+    oop obj = cast_to_oop(hr->humongous_start_region()->bottom());\n+    bool is_empty = !_collector->mark_bitmap()->is_marked(obj);\n+    if (is_empty) {\n+      free_empty_humongous_region(hr);\n@@ -98,2 +101,5 @@\n-      assert(MarkSweepDeadRatio > 0,\n-             \"only skip compaction for other regions when MarkSweepDeadRatio > 0\");\n+      _collector->set_has_humongous();\n+    }\n+  } else {\n+    assert(MarkSweepDeadRatio > 0,\n+           \"only skip compaction for other regions when MarkSweepDeadRatio > 0\");\n@@ -101,3 +107,3 @@\n-      \/\/ Too many live objects in the region; skip compacting it.\n-      _collector->update_from_compacting_to_skip_compacting(hr->hrm_index());\n-      log_trace(gc, phases)(\"Phase 2: skip compaction region index: %u, live words: \" SIZE_FORMAT,\n+    \/\/ Too many live objects in the region; skip compacting it.\n+    _collector->update_from_compacting_to_skip_compacting(hr->hrm_index());\n+    log_trace(gc, phases)(\"Phase 2: skip compaction region index: %u, live words: \" SIZE_FORMAT,\n@@ -105,1 +111,0 @@\n-    }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCPrepareTask.inline.hpp","additions":28,"deletions":23,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -494,1 +494,1 @@\n-    return handle_evacuation_failure_par(old, old_mark, word_sz, true \/* cause_pinned *\/);\n+    return handle_evacuation_failure_par(old, old_mark, word_sz, false \/* cause_pinned *\/);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -535,1 +535,1 @@\n-    if (!r->can_reclaim()) {\n+    if (r->has_pinned_objects()) {\n@@ -1505,1 +1505,1 @@\n-    if (!hr->can_reclaim()) {\n+    if (hr->has_pinned_objects()) {\n@@ -1599,1 +1599,1 @@\n-    if (!r->can_reclaim()) {\n+    if (r->has_pinned_objects()) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -407,2 +407,0 @@\n-  bool can_reclaim() const;\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -262,4 +262,0 @@\n-inline bool HeapRegion::can_reclaim() const {\n-  return !has_pinned_objects();\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.inline.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"}]}