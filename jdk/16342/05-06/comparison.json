{"files":[{"patch":"@@ -2952,2 +2952,2 @@\n-void G1CollectedHeap::update_used_after_gc(bool retained) {\n-  if (retained) {\n+void G1CollectedHeap::update_used_after_gc(bool evacuation_failed) {\n+  if (evacuation_failed) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1261,1 +1261,1 @@\n-  void update_used_after_gc(bool retained);\n+  void update_used_after_gc(bool evacuation_failed);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"gc\/g1\/g1EvacFailureRegions.hpp\"\n+#include \"gc\/g1\/g1EvacFailureRegions.inline.hpp\"\n@@ -197,1 +197,1 @@\n-  _num_evac_fail_regions = _evac_failure_regions->num_regions_retained();\n+  _num_evac_fail_regions = _evac_failure_regions->num_regions_evac_failed();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailure.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-  _regions_retained(mtGC),\n+  _regions_evac_failed(mtGC),\n@@ -38,5 +38,5 @@\n-  _regions_failed_evacuation(mtGC),\n-  _evac_retained_regions(nullptr),\n-  _evac_retained_regions_cur_length(0),\n-  _evac_failure_regions_pinned(0),\n-  _evac_failure_regions_failed_evacuation(0) { }\n+  _regions_alloc_failed(mtGC),\n+  _evac_failed_regions(nullptr),\n+  _num_regions_evac_failed(0),\n+  _num_regions_pinned(0),\n+  _num_regions_alloc_failed(0) { }\n@@ -45,1 +45,1 @@\n-  assert(_evac_retained_regions == nullptr, \"not cleaned up\");\n+  assert(_evac_failed_regions == nullptr, \"not cleaned up\");\n@@ -49,4 +49,4 @@\n-  Atomic::store(&_evac_retained_regions_cur_length, 0u);\n-  Atomic::store(&_evac_failure_regions_pinned, 0u);\n-  Atomic::store(&_evac_failure_regions_failed_evacuation, 0u);\n-  _regions_retained.resize(max_regions);\n+  Atomic::store(&_num_regions_evac_failed, 0u);\n+  Atomic::store(&_num_regions_pinned, 0u);\n+  Atomic::store(&_num_regions_alloc_failed, 0u);\n+  _regions_evac_failed.resize(max_regions);\n@@ -54,2 +54,2 @@\n-  _regions_failed_evacuation.resize(max_regions);\n-  _evac_retained_regions = NEW_C_HEAP_ARRAY(uint, max_regions, mtGC);\n+  _regions_alloc_failed.resize(max_regions);\n+  _evac_failed_regions = NEW_C_HEAP_ARRAY(uint, max_regions, mtGC);\n@@ -59,1 +59,1 @@\n-  _regions_retained.resize(0);\n+  _regions_evac_failed.resize(0);\n@@ -61,1 +61,1 @@\n-  _regions_failed_evacuation.resize(0);\n+  _regions_alloc_failed.resize(0);\n@@ -63,2 +63,2 @@\n-  FREE_C_HEAP_ARRAY(uint, _evac_retained_regions);\n-  _evac_retained_regions = nullptr;\n+  FREE_C_HEAP_ARRAY(uint, _evac_failed_regions);\n+  _evac_failed_regions = nullptr;\n@@ -68,1 +68,1 @@\n-  return _regions_retained.par_at(region_idx, memory_order_relaxed);\n+  return _regions_evac_failed.par_at(region_idx, memory_order_relaxed);\n@@ -76,2 +76,2 @@\n-                                                     _evac_retained_regions,\n-                                                     Atomic::load(&_evac_retained_regions_cur_length),\n+                                                     _evac_failed_regions,\n+                                                     Atomic::load(&_num_regions_evac_failed),\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailureRegions.cpp","additions":20,"deletions":20,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"runtime\/atomic.hpp\"\n@@ -32,1 +31,0 @@\n-class G1HeapRegionChunkClosure;\n@@ -37,2 +35,10 @@\n-\/\/ evacuation failure or has been found pinned or both and records for every such\n-\/\/ region information to speed up iteration of these regions in various gc phases.\n+\/\/ evacuation failure.\n+\/\/ An evacuation failure may occur due to pinning or due to allocation failure\n+\/\/ (not enough to-space). For every such occurrence the class records region\n+\/\/ information to speed up iteration of these regions in various gc phases.\n+\/\/\n+\/\/ Pinned regions may experience an allocation failure at the same time as G1\n+\/\/ tries to evacuate anything but objects that are possible to be pinned. So\n+\/\/\n+\/\/   _num_regions_pinned + _num_regions_alloc_failed >= _num_regions_evac_failed\n+\/\/\n@@ -40,2 +46,3 @@\n-  \/\/ Records for every region on the heap whether the region has been retained.\n-  CHeapBitMap _regions_retained;\n+  \/\/ Records for every region on the heap whether the region has experienced an\n+  \/\/ evacuation failure.\n+  CHeapBitMap _regions_evac_failed;\n@@ -43,1 +50,1 @@\n-  \/\/ has been region pinning.\n+  \/\/ has been allocation failure or region pinning.\n@@ -45,8 +52,9 @@\n-  CHeapBitMap _regions_failed_evacuation;\n-  \/\/ Retained regions (indexes) in the current collection.\n-  uint* _evac_retained_regions;\n-  \/\/ Number of regions evacuation retained in the current collection.\n-  volatile uint _evac_retained_regions_cur_length;\n-  \/\/ Number of regions evacuation failed due to pinning in the current collection.\n-  volatile uint _evac_failure_regions_pinned;\n-  volatile uint _evac_failure_regions_failed_evacuation;\n+  CHeapBitMap _regions_alloc_failed;\n+  \/\/ Evacuation failed regions (indexes) in the current collection.\n+  uint* _evac_failed_regions;\n+  \/\/ Number of regions evacuation failed in the current collection.\n+  volatile uint _num_regions_evac_failed;\n+  \/\/ Number of regions evacuation failed due to pinning.\n+  volatile uint _num_regions_pinned;\n+  \/\/ Number of regions evacuation failed due to allocation failure.\n+  volatile uint _num_regions_alloc_failed;\n@@ -59,2 +67,2 @@\n-    assert(idx < _evac_retained_regions_cur_length, \"precondition\");\n-    return _evac_retained_regions[idx];\n+    assert(idx < _num_regions_evac_failed, \"precondition\");\n+    return _evac_failed_regions[idx];\n@@ -76,11 +84,3 @@\n-  uint num_regions_retained() const {\n-    return Atomic::load(&_evac_retained_regions_cur_length);\n-  }\n-\n-  uint num_regions_pinned() const {\n-    return Atomic::load(&_evac_failure_regions_pinned);\n-  }\n-\n-  uint num_regions_evac_failed() const {\n-      return Atomic::load(&_evac_failure_regions_failed_evacuation);\n-  }\n+  inline uint num_regions_evac_failed() const;\n+  inline uint num_regions_pinned() const;\n+  inline uint num_regions_alloc_failed() const;\n@@ -88,11 +88,3 @@\n-  bool has_regions_retained() const {\n-    return num_regions_retained() > 0;\n-  }\n-\n-  bool has_regions_evac_pinned() const {\n-    return num_regions_pinned() > 0;\n-  }\n-\n-  bool has_regions_evac_failed() const {\n-    return num_regions_evac_failed() > 0;\n-  }\n+  inline bool has_regions_evac_failed() const;\n+  inline bool has_regions_evac_pinned() const;\n+  inline bool has_regions_alloc_failed() const;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailureRegions.hpp","additions":31,"deletions":39,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -32,0 +32,24 @@\n+uint G1EvacFailureRegions::num_regions_evac_failed() const {\n+  return Atomic::load(&_num_regions_evac_failed);\n+}\n+\n+uint G1EvacFailureRegions::num_regions_pinned() const {\n+  return Atomic::load(&_num_regions_pinned);\n+}\n+\n+uint G1EvacFailureRegions::num_regions_alloc_failed() const {\n+    return Atomic::load(&_num_regions_alloc_failed);\n+}\n+\n+bool G1EvacFailureRegions::has_regions_evac_failed() const {\n+  return num_regions_evac_failed() > 0;\n+}\n+\n+bool G1EvacFailureRegions::has_regions_evac_pinned() const {\n+  return num_regions_pinned() > 0;\n+}\n+\n+bool G1EvacFailureRegions::has_regions_alloc_failed() const {\n+  return num_regions_alloc_failed() > 0;\n+}\n+\n@@ -33,1 +57,1 @@\n-  bool success = _regions_retained.par_set_bit(region_idx,\n+  bool success = _regions_evac_failed.par_set_bit(region_idx,\n@@ -36,2 +60,2 @@\n-    size_t offset = Atomic::fetch_then_add(&_evac_retained_regions_cur_length, 1u);\n-    _evac_retained_regions[offset] = region_idx;\n+    size_t offset = Atomic::fetch_then_add(&_num_regions_evac_failed, 1u);\n+    _evac_failed_regions[offset] = region_idx;\n@@ -46,1 +70,1 @@\n-      Atomic::inc(&_evac_failure_regions_pinned, memory_order_relaxed);\n+      Atomic::inc(&_num_regions_pinned, memory_order_relaxed);\n@@ -49,2 +73,2 @@\n-    if (_regions_failed_evacuation.par_set_bit(region_idx, memory_order_relaxed)) {\n-      Atomic::inc(&_evac_failure_regions_failed_evacuation, memory_order_relaxed);\n+    if (_regions_alloc_failed.par_set_bit(region_idx, memory_order_relaxed)) {\n+      Atomic::inc(&_num_regions_alloc_failed, memory_order_relaxed);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailureRegions.inline.hpp","additions":30,"deletions":6,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -135,1 +135,1 @@\n-  _gc_par_phases[RestoreRetainedRegions]->create_thread_work_items(\"Evacuation Failed Regions:\", RestoreRetainedRegionsFailedNum);\n+  _gc_par_phases[RestoreRetainedRegions]->create_thread_work_items(\"Evacuation Failed Regions:\", RestoreRetainedRegionsEvacFailedNum);\n@@ -137,1 +137,1 @@\n-  _gc_par_phases[RestoreRetainedRegions]->create_thread_work_items(\"Retained Regions:\", RestoreRetainedRegionsRetainedNum);\n+  _gc_par_phases[RestoreRetainedRegions]->create_thread_work_items(\"Allocation Failed Regions:\", RestoreRetainedRegionsAllocFailedNum);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1GCPhaseTimes.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -150,3 +150,3 @@\n-    RestoreRetainedRegionsFailedNum,\n-    RestoreRetainedRegionsPinnedNum,\n-    RestoreRetainedRegionsRetainedNum\n+    RestoreRetainedRegionsEvacFailedNum,       \/\/ How many regions experienced an evacuation failure (pinned or allocation failure)\n+    RestoreRetainedRegionsPinnedNum,           \/\/ How many regions were found as pinned.\n+    RestoreRetainedRegionsAllocFailedNum       \/\/ How many regions were found experiencing an allocation failure.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1GCPhaseTimes.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -431,1 +431,1 @@\n-bool G1ParScanThreadState::inject_evacuation_failure(uint region_idx) {\n+bool G1ParScanThreadState::inject_allocation_failure(uint region_idx) {\n@@ -490,1 +490,1 @@\n-  if (inject_evacuation_failure(from_region->hrm_index())) {\n+  if (inject_allocation_failure(from_region->hrm_index())) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -123,1 +123,1 @@\n-  bool inject_evacuation_failure(uint region_idx) EVAC_FAILURE_INJECTOR_RETURN_( return false; );\n+  bool inject_allocation_failure(uint region_idx) EVAC_FAILURE_INJECTOR_RETURN_( return false; );\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1052,1 +1052,1 @@\n-void G1Policy::record_young_gc_pause_end(bool evacuation_retained) {\n+void G1Policy::record_young_gc_pause_end(bool evacuation_failed) {\n@@ -1054,1 +1054,1 @@\n-  phase_times()->print(evacuation_retained);\n+  phase_times()->print(evacuation_failed);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -304,1 +304,1 @@\n-  void record_young_gc_pause_end(bool evacuation_retained);\n+  void record_young_gc_pause_end(bool evacuation_failed);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"gc\/g1\/g1EvacFailureRegions.inline.hpp\"\n@@ -86,1 +87,1 @@\n-             _collector->evacuation_failed() ? \" (Evacuation Failure)\" : \"\");\n+             _collector->evacuation_alloc_failed() ? \" (Allocation Failure)\" : \"\");\n@@ -117,1 +118,1 @@\n-    G1CollectedHeap::heap()->policy()->record_young_gc_pause_end(_collector->evacuation_retained());\n+    G1CollectedHeap::heap()->policy()->record_young_gc_pause_end(_collector->evacuation_failed());\n@@ -168,1 +169,1 @@\n-    if (_collector->evacuation_retained()) {\n+    if (_collector->evacuation_failed()) {\n@@ -769,1 +770,1 @@\n-  while (!evacuation_failed() && collection_set()->optional_region_length() > 0) {\n+  while (!evacuation_alloc_failed() && collection_set()->optional_region_length() > 0) {\n@@ -1019,2 +1020,2 @@\n-bool G1YoungCollector::evacuation_retained() const {\n-  return _evac_failure_regions.has_regions_retained();\n+bool G1YoungCollector::evacuation_failed() const {\n+  return _evac_failure_regions.has_regions_evac_failed();\n@@ -1027,2 +1028,2 @@\n-bool G1YoungCollector::evacuation_failed() const {\n-  return _evac_failure_regions.has_regions_evac_failed();\n+bool G1YoungCollector::evacuation_alloc_failed() const {\n+  return _evac_failure_regions.has_regions_alloc_failed();\n@@ -1101,1 +1102,1 @@\n-    policy()->record_young_collection_end(_concurrent_operation_is_full_mark, evacuation_failed());\n+    policy()->record_young_collection_end(_concurrent_operation_is_full_mark, evacuation_alloc_failed());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.cpp","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -134,5 +134,1 @@\n-  \/\/ True iff an evacuation required retaining in the most-recent collection.\n-  bool evacuation_retained() const;\n-  \/\/ True iff an evacuation has pinned in the most-recent collection.\n-  bool evacuation_pinned() const;\n-  \/\/ True iff an evacuation has failed in the most-recent collection.\n+  \/\/ True iff an evacuation failure of any kind occurred in the most-recent collection.\n@@ -140,0 +136,4 @@\n+  \/\/ True iff an evacuation had pinned regions in the most-recent collection.\n+  bool evacuation_pinned() const;\n+  \/\/ True iff an evacuation had allocation failures in the most-recent collection.\n+  bool evacuation_alloc_failed() const;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-#include \"gc\/g1\/g1EvacStats.inline.hpp\"\n+#include \"gc\/g1\/g1EvacFailureRegions.inline.hpp\"\n@@ -35,0 +35,1 @@\n+#include \"gc\/g1\/g1EvacStats.inline.hpp\"\n@@ -58,1 +59,1 @@\n-  bool _retained;\n+  bool _evacuation_failed;\n@@ -61,1 +62,1 @@\n-  RecalculateUsedTask(bool retained) : G1AbstractSubTask(G1GCPhaseTimes::RecalculateUsed), _retained(retained) { }\n+  RecalculateUsedTask(bool evacuation_failed) : G1AbstractSubTask(G1GCPhaseTimes::RecalculateUsed), _evacuation_failed(evacuation_failed) { }\n@@ -65,1 +66,1 @@\n-    return _retained ? 1.0 : AlmostNoWork;\n+    return _evacuation_failed ? 1.0 : AlmostNoWork;\n@@ -68,1 +69,1 @@\n-  void do_work(uint worker_id) override { G1CollectedHeap::heap()->update_used_after_gc(_retained); }\n+  void do_work(uint worker_id) override { G1CollectedHeap::heap()->update_used_after_gc(_evacuation_failed); }\n@@ -107,1 +108,1 @@\n-    assert(_evac_failure_regions->has_regions_retained(), \"Should not call this if not executed\");\n+    assert(_evac_failure_regions->has_regions_evac_failed(), \"Should not call this if there were no evacuation failures\");\n@@ -110,1 +111,1 @@\n-    return workers_per_region * _evac_failure_regions->num_regions_retained();\n+    return workers_per_region * _evac_failure_regions->num_regions_evac_failed();\n@@ -122,1 +123,1 @@\n-  bool retained = evac_failure_regions->has_regions_retained();\n+  bool evac_failed = evac_failure_regions->has_regions_evac_failed();\n@@ -125,1 +126,1 @@\n-  add_serial_task(new RecalculateUsedTask(retained));\n+  add_serial_task(new RecalculateUsedTask(evac_failed));\n@@ -130,1 +131,1 @@\n-  if (retained) {\n+  if (evac_failed) {\n@@ -383,1 +384,1 @@\n-    return _evac_failure_regions->num_regions_retained();\n+    return _evac_failure_regions->num_regions_evac_failed();\n@@ -571,2 +572,0 @@\n-    bool is_pinned = r->has_pinned_objects();\n-\n@@ -576,2 +575,1 @@\n-                                      is_pinned ? G1GCPhaseTimes::RestoreRetainedRegionsPinnedNum\n-                                                : G1GCPhaseTimes::RestoreRetainedRegionsFailedNum);\n+                                      G1GCPhaseTimes::RestoreRetainedRegionsEvacFailedNum);\n@@ -661,0 +659,1 @@\n+  volatile uint     _num_retained_regions;\n@@ -686,1 +685,2 @@\n-    _evac_failure_regions(evac_failure_regions) {\n+    _evac_failure_regions(evac_failure_regions),\n+    _num_retained_regions(0) {\n@@ -694,4 +694,1 @@\n-    G1GCPhaseTimes* p = _g1h->phase_times();\n-    bool has_new_retained_regions =\n-      p->sum_thread_work_items(G1GCPhaseTimes::RestoreRetainedRegions, G1GCPhaseTimes::RestoreRetainedRegionsRetainedNum) != 0;\n-\n+    bool has_new_retained_regions = Atomic::load(&_num_retained_regions) != 0;\n@@ -708,0 +705,2 @@\n+\n+    G1GCPhaseTimes* p = _g1h->phase_times();\n@@ -709,0 +708,1 @@\n+\n@@ -728,4 +728,12 @@\n-    _g1h->phase_times()->record_or_add_thread_work_item(G1GCPhaseTimes::RestoreRetainedRegions,\n-                                                        worker_id,\n-                                                        cl.num_retained_regions(),\n-                                                        G1GCPhaseTimes::RestoreRetainedRegionsRetainedNum);\n+\n+    G1GCPhaseTimes* p = _g1h->phase_times();\n+    p->record_or_add_thread_work_item(G1GCPhaseTimes::RestoreRetainedRegions,\n+                                      worker_id,\n+                                      _evac_failure_regions->num_regions_pinned(),\n+                                      G1GCPhaseTimes::RestoreRetainedRegionsPinnedNum);\n+    p->record_or_add_thread_work_item(G1GCPhaseTimes::RestoreRetainedRegions,\n+                                      worker_id,\n+                                      _evac_failure_regions->num_regions_alloc_failed(),\n+                                      G1GCPhaseTimes::RestoreRetainedRegionsAllocFailedNum);\n+\n+    Atomic::add(&_num_retained_regions, cl.num_retained_regions(), memory_order_relaxed);\n@@ -772,1 +780,1 @@\n-  if (evac_failure_regions->has_regions_retained()) {\n+  if (evac_failure_regions->has_regions_evac_failed()) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.cpp","additions":33,"deletions":25,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @summary Ensure the output for a minor GC with G1 that has evacuation failure contains the correct strings.\n+ * @summary Ensure the output for a minor GC with G1 that has allocation failure contains the correct strings.\n@@ -58,1 +58,1 @@\n-        output.shouldContain(\"(Evacuation Failure)\");\n+        output.shouldContain(\"(Allocation Failure)\");\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestEvacuationFailure.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -270,2 +270,3 @@\n-                                                                  \/\/ We only want the one region containing the pinned object to be part of the collection set.\n-                                                                  \"-XX:G1MixedGCLiveThresholdPercent=2\",\n+                                                                  \/\/ Take all old regions to make sure that the pinned one is included in the collection set.\n+                                                                  \"-XX:G1MixedGCLiveThresholdPercent=100\",\n+                                                                  \"-XX:G1HeapWastePercent=0\",\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/pinnedobjs\/TestPinnedOldObjectsEvacuation.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @summary Checks PLAB statistics on evacuation failure\n+ * @summary Checks PLAB statistics on evacuation\/allocation failure\n@@ -199,1 +199,1 @@\n-                .filter(line -> line.contains(\"(Evacuation Failure)\"))\n+                .filter(line -> line.contains(\"(Allocation Failure)\"))\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/plab\/TestPLABEvacuationFailure.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}