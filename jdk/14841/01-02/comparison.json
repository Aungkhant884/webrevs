{"files":[{"patch":"@@ -0,0 +1,298 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.BufferedReader;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+\/\/ This is a simple parser for parsing the output of\n+\/\/\n+\/\/   java -Xshare:dump -Xlog:cds+map=debug,cds+map+oops=trace:file=cds.map:none:filesize=0\n+\/\/\n+\/\/ Currently it just check the output related to JDK-8308903.\n+\/\/ I.e., each oop fields in the HeapObjects must point to a valid HeapObject.\n+\/\/\n+\/\/ It can be extended to check for the other parts of the map file, or perform\n+\/\/ more analysis on the HeapObjects.\n+public class CDSMapReader {\n+    public static class MapFile {\n+        ArrayList<HeapObject> heapObjects = new ArrayList<>();\n+        HashMap<Long, HeapObject> oopToObject = new HashMap<>();\n+        HashMap<Long, HeapObject> narrowOopToObject = new HashMap<>();\n+\n+        void add(HeapObject heapObject) {\n+            heapObjects.add(heapObject);\n+            oopToObject.put(heapObject.address.oop, heapObject);\n+            if (heapObject.address.narrowOop != 0) {\n+                narrowOopToObject.put(heapObject.address.narrowOop, heapObject);\n+            }\n+        }\n+\n+        public int heapObjectCount() {\n+            return heapObjects.size();\n+        }\n+    }\n+\n+    public static class HeapAddress {\n+        long oop;\n+        long narrowOop;\n+\n+        HeapAddress(String oopStr, String narrowOopStr) {\n+            oop = Long.parseUnsignedLong(oopStr, 16);\n+            if (narrowOopStr != null) {\n+                narrowOop = Long.parseUnsignedLong(narrowOopStr, 16);\n+            }\n+        }\n+    }\n+\n+    public static class Klass {\n+        long address;\n+        String name;\n+\n+        static Klass getKlass(String name, String addr) {\n+            \/\/ TODO: look up from a table of known Klasses\n+            Klass k = new Klass();\n+            k.name = name;\n+            k.address =  Long.parseUnsignedLong(addr, 16);\n+            return k;\n+        }\n+    }\n+\n+    public static class HeapObject {\n+        HeapAddress address;\n+        ArrayList<Field> fields;\n+        String className;\n+        Klass klass;\n+\n+        HeapObject(String className, String oop, String narrowOop) {\n+            this.className = className;\n+            address = new HeapAddress(oop, narrowOop);\n+        }\n+\n+        void setKlass(String klassName, String address) {\n+            klass = Klass.getKlass(klassName, address);\n+        }\n+\n+        void addOopField(String name, String offset, String oopStr, String narrowOopStr) {\n+            if (fields == null) {\n+                fields = new ArrayList<Field>();\n+            }\n+            fields.add(new Field(name, offset, oopStr, narrowOopStr));\n+        }\n+    }\n+\n+    public static class Field {\n+        String name;\n+        int offset;\n+        HeapAddress referentAddress; \/\/ non-null iff this is an object field\n+        int lineCount;\n+\n+        Field(String name, String offset, String oopStr, String narrowOopStr) {\n+            this.name = name;\n+            this.offset = Integer.parseInt(offset);\n+            this.referentAddress = new HeapAddress(oopStr, narrowOopStr);\n+            this.lineCount = CDSMapReader.lineCount;\n+        }\n+    }\n+\n+    \/\/ 0x00000007ffc00000:   4a5b8701 00000063 00010290 00000000 00010100 fff80003\n+    static Pattern rawDataPattern = Pattern.compile(\"^0x([0-9a-f]+): *( [0-9a-f]+)+ *$\");\n+\n+    \/\/ (one address)\n+    \/\/ 0x00000007ffc00000: @@ Object java.lang.String\n+    static Pattern objPattern1 = Pattern.compile(\"^0x([0-9a-f]+): @@ Object (.*)\");\n+\n+    \/\/ (two addresses)\n+    \/\/ 0x00000007ffc00000: @@ Object (0xfff80000) java.lang.String\n+    static Pattern objPattern2 = Pattern.compile(\"^0x([0-9a-f]+): @@ Object [(]0x([0-9a-f]+)[)] (.*)\");\n+\n+    \/\/  - klass: 'java\/lang\/String' 0x0000000800010290\n+    static Pattern instanceObjKlassPattern = Pattern.compile(\"^ - klass: '([^']+)' 0x([0-9a-f]+)\");\n+\n+    \/\/  - klass: {type array byte} 0x00000008000024c8\n+    static Pattern typeArrayKlassPattern = Pattern.compile(\"^ - klass: [{]type array ([a-z]+)[}] 0x([0-9a-f]+)\");\n+\n+    \/\/  - klass: 'java\/lang\/Object'[] 0x00000008000013e0\n+    static Pattern objArrayKlassPattern = Pattern.compile(\"^ - klass: ('[^']+'(\\\\[\\\\])+) 0x([0-9a-f]+)\");\n+\n+    \/\/  - fields (3 words):\n+    static Pattern fieldsWordsPattern = Pattern.compile(\"^ - fields [(]([0-9]+) words[)]:$\");\n+\n+    \/\/ (one address)\n+    \/\/  - final 'key' 'Ljava\/lang\/Object;' @16 0x00000007ffc68260 java.lang.String\n+    static Pattern oopFieldPattern1 = Pattern.compile(\" - [^']* '([^']+)'.*@([0-9]+) 0x([0-9a-f]+) (.*)\");\n+\n+    \/\/ (two addresses)\n+    \/\/  - final 'key' 'Ljava\/lang\/Object;' @16 0x00000007ffc68260 (0xfff8d04c) java.lang.String\n+    static Pattern oopFieldPattern2 = Pattern.compile(\" - [^']* '([^']+)'.*@([0-9]+) 0x([0-9a-f]+) [(]0x([0-9a-f]+)[)] (.*)\");\n+\n+    private static Matcher match(String line, Pattern pattern) {\n+        Matcher m = pattern.matcher(line);\n+        if (m.find()) {\n+            return m;\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    private static void parseHeapObject(String className, String oop, String narrowOop) throws IOException {\n+        HeapObject heapObject = parseHeapObjectImpl(className, oop, narrowOop);\n+        mapFile.add(heapObject);\n+    }\n+\n+    private static HeapObject parseHeapObjectImpl(String className, String oop, String narrowOop) throws IOException {\n+        HeapObject heapObject = new HeapObject(className, oop, narrowOop);\n+        Matcher m;\n+\n+        nextLine();\n+        while (line != null && match(line, rawDataPattern) != null) { \/\/ skip raw data\n+            nextLine();\n+        }\n+\n+        if (line == null || !line.startsWith(\" - \")) {\n+            return heapObject;\n+        }\n+\n+        if ((m = match(line, instanceObjKlassPattern)) != null) {\n+            heapObject.setKlass(m.group(1), m.group(2));\n+            nextLine();\n+            if ((m = match(line, fieldsWordsPattern)) == null) {\n+                throw new RuntimeException(\"Expected field size info\");\n+            }\n+            \/\/ TODO: read all the array elements\n+            while (true) {\n+                nextLine();\n+                if (line == null || !line.startsWith(\" - \")) {\n+                    return heapObject;\n+                }\n+                if (!line.contains(\"marked metadata pointer\")) {\n+                    if ((m = match(line, oopFieldPattern2)) != null) {\n+                        heapObject.addOopField(m.group(1), m.group(2), m.group(3), m.group(4));\n+                    } else if ((m = match(line, oopFieldPattern1)) != null) {\n+                        heapObject.addOopField(m.group(1), m.group(2), m.group(3), null);\n+                    }\n+                }\n+            }\n+        } else if ((m = match(line, typeArrayKlassPattern)) != null) {\n+            heapObject.setKlass(m.group(1), m.group(2));\n+            \/\/ TODO: read all the array elements\n+            while (true) {\n+                nextLine();\n+                if (line == null || !line.startsWith(\" - \")) {\n+                    return heapObject;\n+                }\n+            }\n+        } else if ((m = match(line, objArrayKlassPattern)) != null) {\n+            heapObject.setKlass(m.group(1), m.group(3));\n+            \/\/ TODO: read all the array elements\n+            while (true) {\n+                nextLine();\n+                if (line == null || !line.startsWith(\" - \")) {\n+                    return heapObject;\n+                }\n+            }\n+        } else {\n+            throw new RuntimeException(\"Expected klass info\");\n+        }\n+    }\n+\n+    static MapFile mapFile;\n+    static BufferedReader reader;\n+    static String line = null; \/\/ current line being parsed\n+    static int lineCount = 0;\n+    static String nextLine()  throws IOException {\n+        line = reader.readLine();\n+        ++ lineCount;\n+        return line;\n+    }\n+\n+    public static MapFile read(String fileName) {\n+        mapFile = new MapFile();\n+\n+        try (BufferedReader r = new BufferedReader(new FileReader(fileName))) {\n+            reader = r;\n+            nextLine();\n+\n+            Matcher m;\n+            while (line != null) {\n+                if ((m = match(line, objPattern2)) != null) {\n+                    parseHeapObject(m.group(3), m.group(1), m.group(2));\n+                } else if ((m = match(line, objPattern1)) != null) {\n+                    parseHeapObject(m.group(2), m.group(1), null);\n+                } else {\n+                    nextLine();\n+                }\n+            }\n+            return mapFile;\n+        } catch (Throwable t) {\n+            System.out.println(\"Error parsing line \" + lineCount + \": \" + line);\n+            throw new RuntimeException(t);\n+        } finally {\n+            System.out.println(\"Parsed \" + lineCount + \" lines in \" + fileName);\n+            System.out.println(\"Found \"  + mapFile.heapObjectCount() + \" heap objects\");\n+            mapFile = null;\n+            reader = null;\n+            line = null;\n+            lineCount = 0;\n+        }\n+    }\n+\n+    private static void mustContain(HashMap<Long, HeapObject> allObjects, Field field, long pointer, boolean isNarrow) {\n+        if (allObjects.get(pointer) == null) {\n+            throw new RuntimeException((isNarrow ? \"narrowOop\" : \"oop\") + \" pointer 0x\" + Long.toHexString(pointer) +\n+                                       \" on line \" + field.lineCount + \" doesn't point to a valid heap object\");\n+        }\n+    }\n+\n+    \/\/ Check that each oop fields in the HeapObjects must point to a valid HeapObject.\n+    public static int validate(MapFile mapFile) {\n+        int count = 0;\n+        for (HeapObject heapObject : mapFile.heapObjects) {\n+            if (heapObject.fields != null) {\n+                for (Field field : heapObject.fields) {\n+                    HeapAddress referentAddress = field.referentAddress;\n+                    long oop = referentAddress.oop;\n+                    long narrowOop = referentAddress.narrowOop;\n+                    mustContain(mapFile.oopToObject, field, oop, false);\n+                    count ++;\n+                    if (narrowOop != 0) {\n+                        mustContain(mapFile.narrowOopToObject, field, narrowOop, true);\n+                        count ++;\n+                    }\n+                }\n+            }\n+        }\n+        System.out.println(\"Checked \" + count + \" oop field references\");\n+        return count;\n+    }\n+\n+    public static void main(String args[]) {\n+        MapFile mapFile = read(args[0]);\n+        validate(mapFile);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/CDSMapReader.java","additions":298,"deletions":0,"binary":false,"changes":298,"status":"added"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8308903\n+ * @summary Test the contents of -Xlog:cds+map\n+ * @requires vm.cds\n+ * @library \/test\/lib\n+ * @run driver CDSMapTest\n+ *\/\n+\n+import jdk.test.lib.cds.CDSOptions;\n+import jdk.test.lib.cds.CDSTestUtils;\n+import jdk.test.lib.Platform;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+\n+public class CDSMapTest {\n+    public static void main(String[] args) throws Exception {\n+        doTest(false);\n+\n+        if (Platform.is64bit()) {\n+            \/\/ There's no oop\/klass compression on 32-bit.\n+            doTest(true);\n+        }\n+    }\n+\n+    public static void doTest(boolean compressed) throws Exception {\n+        ArrayList<String> dumpArgs = new ArrayList<>();\n+\n+        \/\/ Use the same heap size as make\/Images.gmk\n+        dumpArgs.add(\"-Xmx128M\");\n+\n+        if (Platform.is64bit()) {\n+            \/\/ These options are available only on 64-bit.\n+            String sign = (compressed) ?  \"+\" : \"-\";\n+            dumpArgs.add(\"-XX:\" + sign + \"UseCompressedOops\");\n+        }\n+\n+        dump(dumpArgs);\n+    }\n+\n+    static int id = 0;\n+    static void dump(ArrayList<String> args, String... more) throws Exception {\n+        String logName = \"SharedArchiveFile\" + (id++);\n+        String archiveName = logName + \".jsa\";\n+        String mapName = logName + \".map\";\n+        CDSOptions opts = (new CDSOptions())\n+            .addPrefix(\"-Xlog:cds=debug\")\n+            .addPrefix(\"-Xlog:cds+map=debug,cds+map+oops=trace:file=\" + mapName + \":none:filesize=0\")\n+            .setArchiveName(archiveName)\n+            .addSuffix(args)\n+            .addSuffix(more);\n+        CDSTestUtils.createArchiveAndCheck(opts);\n+\n+        CDSMapReader.MapFile mapFile = CDSMapReader.read(mapName);\n+        int oopFieldCount = CDSMapReader.validate(mapFile);\n+        if (mapFile.heapObjectCount() > 0 && oopFieldCount < 10000) {\n+            \/\/ heapObjectCount() may be zero if the selected GC doesn't support heap object archiving.\n+            throw new RuntimeException(\"CDS map file seems incorrect: \" + mapFile.heapObjectCount() +\n+                                       \" objects but only \" + oopFieldCount + \" oop field references\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/CDSMapTest.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"}]}