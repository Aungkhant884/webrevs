{"files":[{"patch":"@@ -35,0 +35,1 @@\n+#include \"classfile\/javaClasses.hpp\"\n@@ -50,0 +51,1 @@\n+#include \"runtime\/fieldDescriptor.inline.hpp\"\n@@ -968,1 +970,1 @@\n-      log_data(last_obj_base, dest, last_obj_base + buffer_to_runtime_delta());\n+      log_as_hex(last_obj_base, dest, last_obj_base + buffer_to_runtime_delta());\n@@ -1010,1 +1012,1 @@\n-    log_data(last_obj_base, last_obj_end, last_obj_base + buffer_to_runtime_delta());\n+    log_as_hex(last_obj_base, last_obj_end, last_obj_base + buffer_to_runtime_delta());\n@@ -1015,1 +1017,1 @@\n-      log_data(last_obj_end, region_end, last_obj_end + buffer_to_runtime_delta());\n+      log_as_hex(last_obj_end, region_end, last_obj_end + buffer_to_runtime_delta());\n@@ -1041,1 +1043,3 @@\n-    log_region(\"heap\", start, end, to_requested(start));\n+    log_region(\"heap\", start, end, ArchiveHeapWriter::buffered_addr_to_requested_addr(start));\n+\n+    LogStreamHandle(Info, cds, map) st;\n@@ -1045,6 +1049,8 @@\n-      oop original_oop = ArchiveHeapWriter::buffered_addr_to_source_obj(start);\n-      if (original_oop != nullptr) {\n-        ResourceMark rm;\n-        log_info(cds, map)(PTR_FORMAT \": @@ Object %s\",\n-                           p2i(to_requested(start)), original_oop->klass()->external_name());\n-        byte_size = original_oop->size() * BytesPerWord;\n+      oop source_oop = ArchiveHeapWriter::buffered_addr_to_source_obj(start);\n+      address requested_start = ArchiveHeapWriter::buffered_addr_to_requested_addr(start);\n+      st.print(PTR_FORMAT \": @@ Object \", p2i(requested_start));\n+\n+      if (source_oop != nullptr) {\n+        \/\/ This is a regular oop that got archived.\n+        print_oop_with_requested_addr_cr(&st, source_oop, false);\n+        byte_size = source_oop->size() * BytesPerWord;\n@@ -1052,4 +1058,4 @@\n-        \/\/ HeapShared::roots() is copied specially so it doesn't exist in\n-        \/\/ HeapShared::OriginalObjectTable. See HeapShared::copy_roots().\n-        log_info(cds, map)(PTR_FORMAT \": @@ Object HeapShared::roots (ObjArray)\",\n-                           p2i(to_requested(start)));\n+        \/\/ HeapShared::roots() is copied specially, so it doesn't exist in\n+        \/\/ ArchiveHeapWriter::BufferOffsetToSourceObjectTable.\n+        \/\/ See ArchiveHeapWriter::copy_roots_to_buffer().\n+        st.print_cr(\"HeapShared::roots[%d]\", HeapShared::pending_roots()->length());\n@@ -1057,0 +1063,3 @@\n+      } else if ((byte_size = ArchiveHeapWriter::get_filler_size_at(start)) > 0) {\n+        \/\/ We have a filler oop, which also does not exist in BufferOffsetToSourceObjectTable.\n+        st.print_cr(\"filler \" SIZE_FORMAT \" bytes\", byte_size);\n@@ -1058,6 +1067,1 @@\n-        \/\/ We have reached the end of the region, but have some unused space\n-        \/\/ at the end.\n-        log_info(cds, map)(PTR_FORMAT \": @@ Unused heap space \" SIZE_FORMAT \" bytes\",\n-                           p2i(to_requested(start)), size_t(end - start));\n-        log_data(start, end, to_requested(start), \/*is_heap=*\/true);\n-        break;\n+        ShouldNotReachHere();\n@@ -1065,0 +1069,1 @@\n+\n@@ -1066,1 +1071,7 @@\n-      log_data(start, oop_end, to_requested(start), \/*is_heap=*\/true);\n+      log_as_hex(start, oop_end, requested_start, \/*is_heap=*\/true);\n+\n+      if (source_oop != nullptr) {\n+        log_oop_details(heap_info, source_oop);\n+      } else if (start == ArchiveHeapWriter::buffered_heap_roots_addr()) {\n+        log_heap_roots();\n+      }\n@@ -1071,2 +1082,91 @@\n-  static address to_requested(address p) {\n-    return ArchiveHeapWriter::buffered_addr_to_requested_addr(p);\n+  \/\/ ArchivedFieldPrinter is used to print the fields of archived objects. We can't\n+  \/\/ use _source_obj->print_on(), because we want to print the oop fields\n+  \/\/ in _source_obj with their requested addresses using print_oop_with_requested_addr_cr().\n+  class ArchivedFieldPrinter : public FieldClosure {\n+    ArchiveHeapInfo* _heap_info;\n+    outputStream* _st;\n+    oop _source_obj;\n+  public:\n+    ArchivedFieldPrinter(ArchiveHeapInfo* heap_info, outputStream* st, oop src_obj) :\n+      _heap_info(heap_info), _st(st), _source_obj(src_obj) {}\n+\n+    void do_field(fieldDescriptor* fd) {\n+      _st->print(\" - \");\n+      BasicType ft = fd->field_type();\n+      switch (ft) {\n+      case T_ARRAY:\n+      case T_OBJECT:\n+        fd->print_on(_st); \/\/ print just the name and offset\n+        print_oop_with_requested_addr_cr(_st, _source_obj->obj_field(fd->offset()));\n+        break;\n+      default:\n+        if (ArchiveHeapWriter::is_marked_as_native_pointer(_heap_info, _source_obj, fd->offset())) {\n+          print_as_native_pointer(fd);\n+        } else {\n+          fd->print_on_for(_st, _source_obj); \/\/ name, offset, value\n+          _st->cr();\n+        }\n+      }\n+    }\n+\n+    void print_as_native_pointer(fieldDescriptor* fd) {\n+      LP64_ONLY(assert(fd->field_type() == T_LONG, \"must be\"));\n+      NOT_LP64 (assert(fd->field_type() == T_INT,  \"must be\"));\n+\n+      \/\/ We have a field that looks like an integer, but it's actually a pointer to a MetaspaceObj.\n+      address source_native_ptr = (address)\n+          LP64_ONLY(_source_obj->long_field(fd->offset()))\n+          NOT_LP64( _source_obj->int_field (fd->offset()));\n+      ArchiveBuilder* builder = ArchiveBuilder::current();\n+\n+      \/\/ The value of the native pointer at runtime.\n+      address requested_native_ptr = builder->to_requested(builder->get_buffered_addr(source_native_ptr));\n+\n+      \/\/ The address of _source_obj at runtime\n+      oop requested_obj = ArchiveHeapWriter::source_obj_to_requested_obj(_source_obj);\n+      \/\/ The address of this field in the requested space\n+      address requested_field_addr = cast_from_oop<address>(requested_obj) + fd->offset();\n+\n+      fd->print_on(_st);\n+      _st->print_cr(PTR_FORMAT \" (marked metadata pointer @\" PTR_FORMAT \" )\",\n+                    p2i(requested_native_ptr), p2i(requested_field_addr));\n+    }\n+  };\n+\n+  \/\/ Print the fields of instanceOops, or the elements of arrayOops\n+  static void log_oop_details(ArchiveHeapInfo* heap_info, oop source_oop) {\n+    LogStreamHandle(Trace, cds, map, oops) st;\n+    if (st.is_enabled()) {\n+      Klass* source_klass = source_oop->klass();\n+      ArchiveBuilder* builder = ArchiveBuilder::current();\n+      Klass* requested_klass = builder->to_requested(builder->get_buffered_addr(source_klass));\n+\n+      st.print(\" - klass: \");\n+      source_klass->print_value_on(&st);\n+      st.print(\" \" PTR_FORMAT, p2i(requested_klass));\n+      st.cr();\n+\n+      if (source_oop->is_typeArray()) {\n+        TypeArrayKlass::cast(source_klass)->oop_print_elements_on(typeArrayOop(source_oop), &st);\n+      } else if (source_oop->is_objArray()) {\n+        objArrayOop source_obj_array = objArrayOop(source_oop);\n+        for (int i = 0; i < source_obj_array->length(); i++) {\n+          st.print(\" -%4d: \", i);\n+          print_oop_with_requested_addr_cr(&st, source_obj_array->obj_at(i));\n+        }\n+      } else {\n+        st.print_cr(\" - fields (\" SIZE_FORMAT \" words):\", source_oop->size());\n+        ArchivedFieldPrinter print_field(heap_info, &st, source_oop);\n+        InstanceKlass::cast(source_klass)->print_nonstatic_fields(&print_field);\n+      }\n+    }\n+  }\n+\n+  static void log_heap_roots() {\n+    LogStreamHandle(Trace, cds, map, oops) st;\n+    if (st.is_enabled()) {\n+      for (int i = 0; i < HeapShared::pending_roots()->length(); i++) {\n+        st.print(\"roots[%4d]: \", i);\n+        print_oop_with_requested_addr_cr(&st, HeapShared::pending_roots()->at(i));\n+      }\n+    }\n@@ -1074,1 +1174,26 @@\n-#endif\n+\n+  \/\/ The output looks like this. The first number is the requested address. The second number is\n+  \/\/ the narrowOop version of the requested address.\n+  \/\/     0x00000007ffc7e840 (0xfff8fd08) java.lang.Class\n+  \/\/     0x00000007ffc000f8 (0xfff8001f) [B length: 11\n+  static void print_oop_with_requested_addr_cr(outputStream* st, oop source_oop, bool print_addr = true) {\n+    if (source_oop == nullptr) {\n+      st->print_cr(\"null\");\n+    } else {\n+      ResourceMark rm;\n+      oop requested_obj = ArchiveHeapWriter::source_obj_to_requested_obj(source_oop);\n+      if (print_addr) {\n+        st->print(PTR_FORMAT \" \", p2i(requested_obj));\n+      }\n+      if (UseCompressedOops) {\n+        st->print(\"(0x%08x) \", CompressedOops::narrow_oop_value(requested_obj));\n+      }\n+      if (source_oop->is_array()) {\n+        int array_len = arrayOop(source_oop)->length();\n+        st->print_cr(\"%s length: %d\", source_oop->klass()->external_name(), array_len);\n+      } else {\n+        st->print_cr(\"%s\", source_oop->klass()->external_name());\n+      }\n+    }\n+  }\n+#endif \/\/ INCLUDE_CDS_JAVA_HEAP\n@@ -1078,1 +1203,1 @@\n-  static void log_data(address base, address top, address requested_base, bool is_heap = false) {\n+  static void log_as_hex(address base, address top, address requested_base, bool is_heap = false) {\n@@ -1110,1 +1235,1 @@\n-    log_data(header, header_end, 0);\n+    log_as_hex(header, header_end, 0);\n@@ -1120,1 +1245,1 @@\n-    log_data((address)bitmap, bitmap_end, 0);\n+    log_as_hex((address)bitmap, bitmap_end, 0);\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":152,"deletions":27,"binary":false,"changes":179,"status":"modified"},{"patch":"@@ -67,0 +67,7 @@\n+\n+typedef ResourceHashtable<address, size_t,\n+      127, \/\/ prime number\n+      AnyObj::C_HEAP,\n+      mtClassShared> FillersTable;\n+static FillersTable* _fillers;\n+\n@@ -72,1 +79,1 @@\n-\n+    _fillers = new FillersTable();\n@@ -258,1 +265,1 @@\n-void ArchiveHeapWriter::init_filler_array_at_buffer_top(int array_length, size_t fill_bytes) {\n+HeapWord* ArchiveHeapWriter::init_filler_array_at_buffer_top(int array_length, size_t fill_bytes) {\n@@ -267,0 +274,1 @@\n+  return mem;\n@@ -296,2 +304,1 @@\n-    init_filler_array_at_buffer_top(array_length, fill_bytes);\n-\n+    HeapWord* filler = init_filler_array_at_buffer_top(array_length, fill_bytes);\n@@ -299,0 +306,11 @@\n+    _fillers->put((address)filler, fill_bytes);\n+  }\n+}\n+\n+size_t ArchiveHeapWriter::get_filler_size_at(address buffered_addr) {\n+  size_t* p = _fillers->get(buffered_addr);\n+  if (p != nullptr) {\n+    assert(*p > 0, \"filler must be larger than zero bytes\");\n+    return *p;\n+  } else {\n+    return 0; \/\/ buffered_addr is not a filler\n@@ -517,0 +535,14 @@\n+\/\/ Do we have a jlong\/jint field that's actually a pointer to a MetaspaceObj?\n+bool ArchiveHeapWriter::is_marked_as_native_pointer(ArchiveHeapInfo* heap_info, oop src_obj, int field_offset) {\n+  HeapShared::CachedOopInfo* p = HeapShared::archived_object_cache()->get(src_obj);\n+  assert(p != nullptr, \"must be\");\n+\n+  \/\/ requested_field_addr = the address of this field in the requested space\n+  oop requested_obj = requested_obj_from_buffer_offset(p->buffer_offset());\n+  Metadata** requested_field_addr = (Metadata**)(cast_from_oop<address>(requested_obj) + field_offset);\n+  assert((Metadata**)_requested_bottom <= requested_field_addr && requested_field_addr < (Metadata**) _requested_top, \"range check\");\n+\n+  BitMap::idx_t idx = requested_field_addr - (Metadata**) _requested_bottom;\n+  return (idx < heap_info->ptrmap()->size()) && (heap_info->ptrmap()->at(idx) == true);\n+}\n+\n","filename":"src\/hotspot\/share\/cds\/archiveHeapWriter.cpp","additions":36,"deletions":4,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -191,1 +191,1 @@\n-  static void init_filler_array_at_buffer_top(int array_length, size_t fill_bytes);\n+  static HeapWord* init_filler_array_at_buffer_top(int array_length, size_t fill_bytes);\n@@ -228,0 +228,1 @@\n+  static size_t get_filler_size_at(address buffered_addr);\n@@ -230,0 +231,1 @@\n+  static bool is_marked_as_native_pointer(ArchiveHeapInfo* heap_info, oop src_obj, int field_offset);\n","filename":"src\/hotspot\/share\/cds\/archiveHeapWriter.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -384,0 +384,1 @@\n+  static GrowableArrayCHeap<oop, mtClassShared>* pending_roots() { return _pending_roots; }\n","filename":"src\/hotspot\/share\/cds\/heapShared.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -279,2 +279,0 @@\n-#ifndef PRODUCT\n-\n@@ -344,1 +342,4 @@\n-  typeArrayOop ta = typeArrayOop(obj);\n+  oop_print_elements_on(typeArrayOop(obj), st);\n+}\n+\n+void TypeArrayKlass::oop_print_elements_on(typeArrayOop ta, outputStream* st) {\n@@ -363,2 +364,0 @@\n-#endif \/\/ PRODUCT\n-\n","filename":"src\/hotspot\/share\/oops\/typeArrayKlass.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -126,1 +126,0 @@\n-#ifndef PRODUCT\n@@ -128,2 +127,1 @@\n-#endif\n-\n+  void oop_print_elements_on(typeArrayOop ta, outputStream* st);\n","filename":"src\/hotspot\/share\/oops\/typeArrayKlass.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,298 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.BufferedReader;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.io.RandomAccessFile;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+\/\/ This is a simple parser for parsing the output of\n+\/\/\n+\/\/   java -Xshare:dump -Xlog:cds+map=debug,cds+map+oops=trace:file=cds.map:none:filesize=0\n+\/\/\n+\/\/ Currently it just check the output related to JDK-8308903.\n+\/\/ I.e., each oop fields in the HeapObjects must point to a valid HeapObject.\n+\/\/\n+\/\/ It can be extended to check for the other parts of the map file, or perform\n+\/\/ more analysis on the HeapObjects.\n+public class CDSMapReader {\n+    public static class MapFile {\n+        ArrayList<HeapObject> heapObjects = new ArrayList<>();\n+        HashMap<Long, HeapObject> oopToObject = new HashMap<>();\n+        HashMap<Long, HeapObject> narrowOopToObject = new HashMap<>();\n+\n+        void add(HeapObject heapObject) {\n+            heapObjects.add(heapObject);\n+            oopToObject.put(heapObject.address.oop, heapObject);\n+            if (heapObject.address.narrowOop != 0) {\n+                narrowOopToObject.put(heapObject.address.narrowOop, heapObject);\n+            }\n+        }\n+\n+        public int heapObjectCount() {\n+            return heapObjects.size();\n+        }\n+    }\n+\n+    public static class HeapAddress {\n+        long oop;\n+        long narrowOop;\n+\n+        HeapAddress(String oopStr, String narrowOopStr) {\n+            oop = Long.parseUnsignedLong(oopStr, 16);\n+            if (narrowOopStr != null) {\n+                narrowOop = Long.parseUnsignedLong(narrowOopStr, 16);\n+            }\n+        }\n+    }\n+\n+    public static class Klass {\n+        long address;\n+        String name;\n+\n+        static Klass getKlass(String name, String addr) {\n+            \/\/ TODO: look up from a table of known Klasses\n+            Klass k = new Klass();\n+            k.name = name;\n+            k.address =  Long.parseUnsignedLong(addr, 16);\n+            return k;\n+        }\n+    }\n+\n+    public static class HeapObject {\n+        HeapAddress address;\n+        ArrayList<Field> fields;\n+        String className;\n+        Klass klass;\n+\n+        HeapObject(String className, String oop, String narrowOop) {\n+            this.className = className;\n+            address = new HeapAddress(oop, narrowOop);\n+        }\n+\n+        void setKlass(String klassName, String address) {\n+            klass = Klass.getKlass(klassName, address);\n+        }\n+\n+        void addOopField(String name, String offset, String oopStr, String narrowOopStr) {\n+            if (fields == null) {\n+                fields = new ArrayList<Field>();\n+            }\n+            fields.add(new Field(name, offset, oopStr, narrowOopStr));\n+        }\n+    }\n+\n+    public static class Field {\n+        String name;\n+        int offset;\n+        HeapAddress referentAddress; \/\/ non-null iff this is an object field\n+        int lineCount;\n+\n+        Field(String name, String offset, String oopStr, String narrowOopStr) {\n+            this.name = name;\n+            this.offset = Integer.parseInt(offset);\n+            this.referentAddress = new HeapAddress(oopStr, narrowOopStr);\n+            this.lineCount = CDSMapReader.lineCount;\n+        }\n+    }\n+\n+    \/\/ 0x00000007ffc00000:   4a5b8701 00000063 00010290 00000000 00010100 fff80003\n+    static Pattern rawDataPattern = Pattern.compile(\"^0x([0-9a-f]+): *( [0-9a-f]+)+ *$\");\n+\n+    \/\/ (one address)\n+    \/\/ 0x00000007ffc00000: @@ Object java.lang.String\n+    static Pattern objPattern1 = Pattern.compile(\"^0x([0-9a-f]+): @@ Object (.*)\");\n+\n+    \/\/ (two addresses)\n+    \/\/ 0x00000007ffc00000: @@ Object (0xfff80000) java.lang.String\n+    static Pattern objPattern2 = Pattern.compile(\"^0x([0-9a-f]+): @@ Object [(]0x([0-9a-f]+)[)] (.*)\");\n+\n+    \/\/  - klass: 'java\/lang\/String' 0x0000000800010290\n+    static Pattern instanceObjKlassPattern = Pattern.compile(\"^ - klass: '([^']+)' 0x([0-9a-f]+)\");\n+\n+    \/\/  - klass: {type array byte} 0x00000008000024c8\n+    static Pattern typeArrayKlassPattern = Pattern.compile(\"^ - klass: [{]type array ([a-z]+)[}] 0x([0-9a-f]+)\");\n+\n+    \/\/  - klass: 'java\/lang\/Object'[] 0x00000008000013e0\n+    static Pattern objArrayKlassPattern = Pattern.compile(\"^ - klass: ('[^']+'(\\\\[\\\\])+) 0x([0-9a-f]+)\");\n+\n+    \/\/  - fields (3 words):\n+    static Pattern fieldsWordsPattern = Pattern.compile(\"^ - fields [(]([0-9]+) words[)]:$\");\n+\n+    \/\/ (one address)\n+    \/\/  - final 'key' 'Ljava\/lang\/Object;' @16 0x00000007ffc68260 java.lang.String\n+    static Pattern oopFieldPattern1 = Pattern.compile(\" - [^']* '([^']+)'.*@([0-9]+) 0x([0-9a-f]+) (.*)\");\n+\n+    \/\/ (two addresses)\n+    \/\/  - final 'key' 'Ljava\/lang\/Object;' @16 0x00000007ffc68260 (0xfff8d04c) java.lang.String\n+    static Pattern oopFieldPattern2 = Pattern.compile(\" - [^']* '([^']+)'.*@([0-9]+) 0x([0-9a-f]+) [(]0x([0-9a-f]+)[)] (.*)\");\n+\n+    private static Matcher match(String line, Pattern pattern) {\n+        Matcher m = pattern.matcher(line);\n+        if (m.find()) {\n+            return m;\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    private static void parseHeapObject(String className, String oop, String narrowOop) throws IOException {\n+        HeapObject heapObject = parseHeapObjectImpl(className, oop, narrowOop);\n+        mapFile.add(heapObject);\n+    }\n+\n+    private static HeapObject parseHeapObjectImpl(String className, String oop, String narrowOop) throws IOException {\n+        HeapObject heapObject = new HeapObject(className, oop, narrowOop);\n+        Matcher m;\n+\n+        nextLine();\n+        while (line != null && match(line, rawDataPattern) != null) { \/\/ skip raw data\n+            nextLine();\n+        }\n+\n+        if (line == null || !line.startsWith(\" - \")) {\n+            return heapObject;\n+        }\n+\n+        if ((m = match(line, instanceObjKlassPattern)) != null) {\n+            heapObject.setKlass(m.group(1), m.group(2));\n+            nextLine();\n+            if ((m = match(line, fieldsWordsPattern)) == null) {\n+                throw new RuntimeException(\"Expected field size info\");\n+            }\n+            \/\/ TODO: read all the array elements\n+            while (true) {\n+                nextLine();\n+                if (line == null || !line.startsWith(\" - \")) {\n+                    return heapObject;\n+                }\n+                if (!line.contains(\"marked metadata pointer\")) {\n+                    if ((m = match(line, oopFieldPattern2)) != null) {\n+                        heapObject.addOopField(m.group(1), m.group(2), m.group(3), m.group(4));\n+                    } else if ((m = match(line, oopFieldPattern1)) != null) {\n+                        heapObject.addOopField(m.group(1), m.group(2), m.group(3), null);\n+                    }\n+                }\n+            }\n+        } else if ((m = match(line, typeArrayKlassPattern)) != null) {\n+            heapObject.setKlass(m.group(1), m.group(2));\n+            \/\/ TODO: read all the array elements\n+            while (true) {\n+                nextLine();\n+                if (line == null || !line.startsWith(\" - \")) {\n+                    return heapObject;\n+                }\n+            }\n+        } else if ((m = match(line, objArrayKlassPattern)) != null) {\n+            heapObject.setKlass(m.group(1), m.group(3));\n+            \/\/ TODO: read all the array elements\n+            while (true) {\n+                nextLine();\n+                if (line == null || !line.startsWith(\" - \")) {\n+                    return heapObject;\n+                }\n+            }\n+        } else {\n+            throw new RuntimeException(\"Expected klass info\");\n+        }\n+    }\n+\n+    static MapFile mapFile;\n+    static BufferedReader reader;\n+    static String line = null; \/\/ current line being parsed\n+    static int lineCount = 0;\n+    static String nextLine()  throws IOException {\n+        line = reader.readLine();\n+        ++ lineCount;\n+        return line;\n+    }\n+\n+    public static MapFile read(String fileName) {\n+        mapFile = new MapFile();\n+\n+        try (BufferedReader r = new BufferedReader(new FileReader(fileName))) {\n+            reader = r;\n+            nextLine();\n+\n+            Matcher m;\n+            while (line != null) {\n+                if ((m = match(line, objPattern2)) != null) {\n+                    parseHeapObject(m.group(3), m.group(1), m.group(2));\n+                } else if ((m = match(line, objPattern1)) != null) {\n+                    parseHeapObject(m.group(2), m.group(1), null);\n+                } else {\n+                    nextLine();\n+                }\n+            }\n+            return mapFile;\n+        } catch (Throwable t) {\n+            System.out.println(\"Error parsing line \" + lineCount + \": \" + line);\n+            throw new RuntimeException(t);\n+        } finally {\n+            System.out.println(\"Parsed \" + lineCount + \" lines in \" + fileName);\n+            System.out.println(\"Found \"  + mapFile.heapObjectCount() + \" heap objects\");\n+            mapFile = null;\n+            reader = null;\n+            line = null;\n+            lineCount = 0;\n+        }\n+    }\n+\n+    private static void mustContain(HashMap<Long, HeapObject> allObjects, Field field, long pointer, boolean isNarrow) {\n+        if (allObjects.get(pointer) == null) {\n+            throw new RuntimeException((isNarrow ? \"narrowOop\" : \"oop\") + \" pointer 0x\" + Long.toHexString(pointer) +\n+                                       \" on line \" + field.lineCount + \" doesn't point to a valid heap object\");\n+        }\n+    }\n+\n+    \/\/ Check that each oop fields in the HeapObjects must point to a valid HeapObject.\n+    public static int validate(MapFile mapFile) {\n+        int count = 0;\n+        for (HeapObject heapObject : mapFile.heapObjects) {\n+            if (heapObject.fields != null) {\n+                for (Field field : heapObject.fields) {\n+                    HeapAddress referentAddress = field.referentAddress;\n+                    long oop = referentAddress.oop;\n+                    long narrowOop = referentAddress.narrowOop;\n+                    mustContain(mapFile.oopToObject, field, oop, false);\n+                    count ++;\n+                    if (narrowOop != 0) {\n+                        mustContain(mapFile.narrowOopToObject, field, narrowOop, true);\n+                        count ++;\n+                    }\n+                }\n+            }\n+        }\n+        System.out.println(\"Checked \" + count + \" oop field references\");\n+        return count;\n+    }\n+\n+    public static void main(String args[]) {\n+        MapFile mapFile = read(args[0]);\n+        validate(mapFile);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/CDSMapReader.java","additions":298,"deletions":0,"binary":false,"changes":298,"status":"added"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8308903\n+ * @summary Test the contents of -Xlog:cds+map\n+ * @requires vm.cds\n+ * @library \/test\/lib\n+ * @run driver CDSMapTest\n+ *\/\n+\n+import jdk.test.lib.cds.CDSOptions;\n+import jdk.test.lib.cds.CDSTestUtils;\n+import jdk.test.lib.Platform;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+\n+public class CDSMapTest {\n+    public static void main(String[] args) throws Exception {\n+        doTest(false);\n+\n+        if (Platform.is64bit()) {\n+            \/\/ There's no oop\/klass compression on 32-bit.\n+            doTest(true);\n+        }\n+    }\n+\n+    public static void doTest(boolean compressed) throws Exception {\n+        ArrayList<String> dumpArgs = new ArrayList<>();\n+\n+        \/\/ Use the same heap size as make\/Images.gmk\n+        dumpArgs.add(\"-Xmx128M\");\n+\n+        if (Platform.is64bit()) {\n+            \/\/ These options are available only on 64-bit.\n+            String sign = (compressed) ?  \"+\" : \"-\";\n+            dumpArgs.add(\"-XX:\" + sign + \"UseCompressedOops\");\n+        }\n+\n+        dump(dumpArgs);\n+    }\n+\n+    static int id = 0;\n+    static void dump(ArrayList<String> args, String... more) throws Exception {\n+        String logName = \"SharedArchiveFile\" + (id++);\n+        String archiveName = logName + \".jsa\";\n+        String mapName = logName + \".map\";\n+        CDSOptions opts = (new CDSOptions())\n+            .addPrefix(\"-Xlog:cds=debug\")\n+            .addPrefix(\"-Xlog:cds+map=debug,cds+map+oops=trace:file=\" + mapName + \":none:filesize=0\")\n+            .setArchiveName(archiveName)\n+            .addSuffix(args)\n+            .addSuffix(more);\n+        CDSTestUtils.createArchiveAndCheck(opts);\n+\n+        CDSMapReader.MapFile mapFile = CDSMapReader.read(mapName);\n+        int oopFieldCount = CDSMapReader.validate(mapFile);\n+        if (mapFile.heapObjectCount() > 0 && oopFieldCount < 10000) {\n+            \/\/ heapObjectCount() may be zero if the selected GC doesn't support heap object archiving.\n+            throw new RuntimeException(\"CDS map file seems incorrect: \" + mapFile.heapObjectCount() +\n+                                       \" objects but only \" + oopFieldCount + \" oop field references\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/CDSMapTest.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -83,1 +83,1 @@\n-            .addPrefix(\"-Xlog:cds+map=trace:file=\" + mapName + \":none:filesize=0\")\n+            .addPrefix(\"-Xlog:cds+map*=trace:file=\" + mapName + \":none:filesize=0\")\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/DeterministicDump.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}