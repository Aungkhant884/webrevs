{"files":[{"patch":"@@ -35,0 +35,1 @@\n+#include \"classfile\/javaClasses.hpp\"\n@@ -50,0 +51,1 @@\n+#include \"runtime\/fieldDescriptor.inline.hpp\"\n@@ -968,1 +970,1 @@\n-      log_data(last_obj_base, dest, last_obj_base + buffer_to_runtime_delta());\n+      log_as_hex(last_obj_base, dest, last_obj_base + buffer_to_runtime_delta());\n@@ -1010,1 +1012,1 @@\n-    log_data(last_obj_base, last_obj_end, last_obj_base + buffer_to_runtime_delta());\n+    log_as_hex(last_obj_base, last_obj_end, last_obj_base + buffer_to_runtime_delta());\n@@ -1015,1 +1017,1 @@\n-      log_data(last_obj_end, region_end, last_obj_end + buffer_to_runtime_delta());\n+      log_as_hex(last_obj_end, region_end, last_obj_end + buffer_to_runtime_delta());\n@@ -1041,1 +1043,3 @@\n-    log_region(\"heap\", start, end, to_requested(start));\n+    log_region(\"heap\", start, end, ArchiveHeapWriter::buffered_addr_to_requested_addr(start));\n+\n+    LogStreamHandle(Info, cds, map) st;\n@@ -1045,6 +1049,8 @@\n-      oop original_oop = ArchiveHeapWriter::buffered_addr_to_source_obj(start);\n-      if (original_oop != nullptr) {\n-        ResourceMark rm;\n-        log_info(cds, map)(PTR_FORMAT \": @@ Object %s\",\n-                           p2i(to_requested(start)), original_oop->klass()->external_name());\n-        byte_size = original_oop->size() * BytesPerWord;\n+      oop source_oop = ArchiveHeapWriter::buffered_addr_to_source_obj(start);\n+      address requested_start = ArchiveHeapWriter::buffered_addr_to_requested_addr(start);\n+      st.print(PTR_FORMAT \": @@ Object \", p2i(requested_start));\n+\n+      if (source_oop != nullptr) {\n+        \/\/ This is a regular oop that got archived.\n+        print_oop_with_requested_addr_cr(&st, source_oop, false);\n+        byte_size = source_oop->size() * BytesPerWord;\n@@ -1052,4 +1058,4 @@\n-        \/\/ HeapShared::roots() is copied specially so it doesn't exist in\n-        \/\/ HeapShared::OriginalObjectTable. See HeapShared::copy_roots().\n-        log_info(cds, map)(PTR_FORMAT \": @@ Object HeapShared::roots (ObjArray)\",\n-                           p2i(to_requested(start)));\n+        \/\/ HeapShared::roots() is copied specially, so it doesn't exist in\n+        \/\/ ArchiveHeapWriter::BufferOffsetToSourceObjectTable.\n+        \/\/ See ArchiveHeapWriter::copy_roots_to_buffer().\n+        st.print_cr(\"HeapShared::roots[%d]\", HeapShared::pending_roots()->length());\n@@ -1057,0 +1063,3 @@\n+      } else if ((byte_size = ArchiveHeapWriter::get_filler_size_at(start)) > 0) {\n+        \/\/ We have a filler oop, which also does not exist in BufferOffsetToSourceObjectTable.\n+        st.print_cr(\"filler \" SIZE_FORMAT \" bytes\", byte_size);\n@@ -1058,6 +1067,1 @@\n-        \/\/ We have reached the end of the region, but have some unused space\n-        \/\/ at the end.\n-        log_info(cds, map)(PTR_FORMAT \": @@ Unused heap space \" SIZE_FORMAT \" bytes\",\n-                           p2i(to_requested(start)), size_t(end - start));\n-        log_data(start, end, to_requested(start), \/*is_heap=*\/true);\n-        break;\n+        ShouldNotReachHere();\n@@ -1065,0 +1069,1 @@\n+\n@@ -1066,1 +1071,7 @@\n-      log_data(start, oop_end, to_requested(start), \/*is_heap=*\/true);\n+      log_as_hex(start, oop_end, requested_start, \/*is_heap=*\/true);\n+\n+      if (source_oop != nullptr) {\n+        log_oop_details(heap_info, source_oop);\n+      } else if (start == ArchiveHeapWriter::buffered_heap_roots_addr()) {\n+        log_heap_roots();\n+      }\n@@ -1071,2 +1082,91 @@\n-  static address to_requested(address p) {\n-    return ArchiveHeapWriter::buffered_addr_to_requested_addr(p);\n+  \/\/ ArchivedFieldPrinter is used to print the fields of archived objects. We can't\n+  \/\/ use _source_obj->print_on(), because we want to print the oop fields\n+  \/\/ in _source_obj with their requested addresses using print_oop_with_requested_addr_cr().\n+  class ArchivedFieldPrinter : public FieldClosure {\n+    ArchiveHeapInfo* _heap_info;\n+    outputStream* _st;\n+    oop _source_obj;\n+  public:\n+    ArchivedFieldPrinter(ArchiveHeapInfo* heap_info, outputStream* st, oop src_obj) :\n+      _heap_info(heap_info), _st(st), _source_obj(src_obj) {}\n+\n+    void do_field(fieldDescriptor* fd) {\n+      _st->print(\" - \");\n+      BasicType ft = fd->field_type();\n+      switch (ft) {\n+      case T_ARRAY:\n+      case T_OBJECT:\n+        fd->print_on(_st); \/\/ print just the name and offset\n+        print_oop_with_requested_addr_cr(_st, _source_obj->obj_field(fd->offset()));\n+        break;\n+      default:\n+        if (ArchiveHeapWriter::is_marked_as_native_pointer(_heap_info, _source_obj, fd->offset())) {\n+          print_as_native_pointer(fd);\n+        } else {\n+          fd->print_on_for(_st, _source_obj); \/\/ name, offset, value\n+          _st->cr();\n+        }\n+      }\n+    }\n+\n+    void print_as_native_pointer(fieldDescriptor* fd) {\n+      LP64_ONLY(assert(fd->field_type() == T_LONG, \"must be\"));\n+      NOT_LP64 (assert(fd->field_type() == T_INT,  \"must be\"));\n+\n+      \/\/ We have a field that looks like an integer, but it's actually a pointer to a MetaspaceObj.\n+      address source_native_ptr = (address)\n+          LP64_ONLY(_source_obj->long_field(fd->offset()))\n+          NOT_LP64( _source_obj->int_field (fd->offset()));\n+      ArchiveBuilder* builder = ArchiveBuilder::current();\n+\n+      \/\/ The value of the native pointer at runtime.\n+      address requested_native_ptr = builder->to_requested(builder->get_buffered_addr(source_native_ptr));\n+\n+      \/\/ The address of _source_obj at runtime\n+      oop requested_obj = ArchiveHeapWriter::source_obj_to_requested_obj(_source_obj);\n+      \/\/ The address of this field in the requested space\n+      address requested_field_addr = cast_from_oop<address>(requested_obj) + fd->offset();\n+\n+      fd->print_on(_st);\n+      _st->print_cr(PTR_FORMAT \" (marked metadata pointer @\" PTR_FORMAT \" )\",\n+                    p2i(requested_native_ptr), p2i(requested_field_addr));\n+    }\n+  };\n+\n+  \/\/ Print the fields of instanceOops, or the elements of arrayOops\n+  static void log_oop_details(ArchiveHeapInfo* heap_info, oop source_oop) {\n+    LogStreamHandle(Trace, cds, map, oops) st;\n+    if (st.is_enabled()) {\n+      Klass* source_klass = source_oop->klass();\n+      ArchiveBuilder* builder = ArchiveBuilder::current();\n+      Klass* requested_klass = builder->to_requested(builder->get_buffered_addr(source_klass));\n+\n+      st.print(\" - klass: \");\n+      source_klass->print_value_on(&st);\n+      st.print(\" \" PTR_FORMAT, p2i(requested_klass));\n+      st.cr();\n+\n+      if (source_oop->is_typeArray()) {\n+        TypeArrayKlass::cast(source_klass)->oop_print_elements_on(typeArrayOop(source_oop), &st);\n+      } else if (source_oop->is_objArray()) {\n+        objArrayOop source_obj_array = objArrayOop(source_oop);\n+        for (int i = 0; i < source_obj_array->length(); i++) {\n+          st.print(\" -%4d: \", i);\n+          print_oop_with_requested_addr_cr(&st, source_obj_array->obj_at(i));\n+        }\n+      } else {\n+        st.print_cr(\" - fields (\" SIZE_FORMAT \" words):\", source_oop->size());\n+        ArchivedFieldPrinter print_field(heap_info, &st, source_oop);\n+        InstanceKlass::cast(source_klass)->print_nonstatic_fields(&print_field);\n+      }\n+    }\n+  }\n+\n+  static void log_heap_roots() {\n+    LogStreamHandle(Trace, cds, map, oops) st;\n+    if (st.is_enabled()) {\n+      for (int i = 0; i < HeapShared::pending_roots()->length(); i++) {\n+        st.print(\"roots[%4d]: \", i);\n+        print_oop_with_requested_addr_cr(&st, HeapShared::pending_roots()->at(i));\n+      }\n+    }\n@@ -1074,1 +1174,26 @@\n-#endif\n+\n+  \/\/ The output looks like this. The first number is the requested address. The second number is\n+  \/\/ the narrowOop version of the requested address.\n+  \/\/     0x00000007ffc7e840 (0xfff8fd08) java.lang.Class\n+  \/\/     0x00000007ffc000f8 (0xfff8001f) [B length: 11\n+  static void print_oop_with_requested_addr_cr(outputStream* st, oop source_oop, bool print_addr = true) {\n+    if (source_oop == nullptr) {\n+      st->print_cr(\"null\");\n+    } else {\n+      ResourceMark rm;\n+      oop requested_obj = ArchiveHeapWriter::source_obj_to_requested_obj(source_oop);\n+      if (print_addr) {\n+        st->print(PTR_FORMAT \" \", p2i(requested_obj));\n+      }\n+      if (UseCompressedOops) {\n+        st->print(\"(0x%08x) \", CompressedOops::narrow_oop_value(requested_obj));\n+      }\n+      if (source_oop->is_array()) {\n+        int array_len = arrayOop(source_oop)->length();\n+        st->print_cr(\"%s length: %d\", source_oop->klass()->external_name(), array_len);\n+      } else {\n+        st->print_cr(\"%s\", source_oop->klass()->external_name());\n+      }\n+    }\n+  }\n+#endif \/\/ INCLUDE_CDS_JAVA_HEAP\n@@ -1078,1 +1203,1 @@\n-  static void log_data(address base, address top, address requested_base, bool is_heap = false) {\n+  static void log_as_hex(address base, address top, address requested_base, bool is_heap = false) {\n@@ -1110,1 +1235,1 @@\n-    log_data(header, header_end, 0);\n+    log_as_hex(header, header_end, 0);\n@@ -1120,1 +1245,1 @@\n-    log_data((address)bitmap, bitmap_end, 0);\n+    log_as_hex((address)bitmap, bitmap_end, 0);\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":152,"deletions":27,"binary":false,"changes":179,"status":"modified"},{"patch":"@@ -67,0 +67,7 @@\n+\n+typedef ResourceHashtable<address, size_t,\n+      127, \/\/ prime number\n+      AnyObj::C_HEAP,\n+      mtClassShared> FillersTable;\n+static FillersTable* _fillers;\n+\n@@ -72,1 +79,1 @@\n-\n+    _fillers = new FillersTable();\n@@ -258,1 +265,1 @@\n-void ArchiveHeapWriter::init_filler_array_at_buffer_top(int array_length, size_t fill_bytes) {\n+HeapWord* ArchiveHeapWriter::init_filler_array_at_buffer_top(int array_length, size_t fill_bytes) {\n@@ -267,0 +274,1 @@\n+  return mem;\n@@ -296,2 +304,1 @@\n-    init_filler_array_at_buffer_top(array_length, fill_bytes);\n-\n+    HeapWord* filler = init_filler_array_at_buffer_top(array_length, fill_bytes);\n@@ -299,0 +306,11 @@\n+    _fillers->put((address)filler, fill_bytes);\n+  }\n+}\n+\n+size_t ArchiveHeapWriter::get_filler_size_at(address buffered_addr) {\n+  size_t* p = _fillers->get(buffered_addr);\n+  if (p != nullptr) {\n+    assert(*p > 0, \"filler must be larger than zero bytes\");\n+    return *p;\n+  } else {\n+    return 0; \/\/ buffered_addr is not a filler\n@@ -517,0 +535,14 @@\n+\/\/ Do we have a jlong\/jint field that's actually a pointer to a MetaspaceObj?\n+bool ArchiveHeapWriter::is_marked_as_native_pointer(ArchiveHeapInfo* heap_info, oop src_obj, int field_offset) {\n+  HeapShared::CachedOopInfo* p = HeapShared::archived_object_cache()->get(src_obj);\n+  assert(p != nullptr, \"must be\");\n+\n+  \/\/ requested_field_addr = the address of this field in the requested space\n+  oop requested_obj = requested_obj_from_buffer_offset(p->buffer_offset());\n+  Metadata** requested_field_addr = (Metadata**)(cast_from_oop<address>(requested_obj) + field_offset);\n+  assert((Metadata**)_requested_bottom <= requested_field_addr && requested_field_addr < (Metadata**) _requested_top, \"range check\");\n+\n+  BitMap::idx_t idx = requested_field_addr - (Metadata**) _requested_bottom;\n+  return (idx < heap_info->ptrmap()->size()) && (heap_info->ptrmap()->at(idx) == true);\n+}\n+\n","filename":"src\/hotspot\/share\/cds\/archiveHeapWriter.cpp","additions":36,"deletions":4,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -191,1 +191,1 @@\n-  static void init_filler_array_at_buffer_top(int array_length, size_t fill_bytes);\n+  static HeapWord* init_filler_array_at_buffer_top(int array_length, size_t fill_bytes);\n@@ -228,0 +228,1 @@\n+  static size_t get_filler_size_at(address buffered_addr);\n@@ -230,0 +231,1 @@\n+  static bool is_marked_as_native_pointer(ArchiveHeapInfo* heap_info, oop src_obj, int field_offset);\n","filename":"src\/hotspot\/share\/cds\/archiveHeapWriter.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -384,0 +384,1 @@\n+  static GrowableArrayCHeap<oop, mtClassShared>* pending_roots() { return _pending_roots; }\n","filename":"src\/hotspot\/share\/cds\/heapShared.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -279,2 +279,0 @@\n-#ifndef PRODUCT\n-\n@@ -344,1 +342,4 @@\n-  typeArrayOop ta = typeArrayOop(obj);\n+  oop_print_elements_on(typeArrayOop(obj), st);\n+}\n+\n+void TypeArrayKlass::oop_print_elements_on(typeArrayOop ta, outputStream* st) {\n@@ -363,2 +364,0 @@\n-#endif \/\/ PRODUCT\n-\n","filename":"src\/hotspot\/share\/oops\/typeArrayKlass.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -126,1 +126,0 @@\n-#ifndef PRODUCT\n@@ -128,2 +127,1 @@\n-#endif\n-\n+  void oop_print_elements_on(typeArrayOop ta, outputStream* st);\n","filename":"src\/hotspot\/share\/oops\/typeArrayKlass.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -83,1 +83,1 @@\n-            .addPrefix(\"-Xlog:cds+map=trace:file=\" + mapName + \":none:filesize=0\")\n+            .addPrefix(\"-Xlog:cds+map*=trace:file=\" + mapName + \":none:filesize=0\")\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/DeterministicDump.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}