{"files":[{"patch":"@@ -344,3 +344,0 @@\n-  product(bool, DoReserveCopyInSuperWord, true,                             \\\n-          \"Create reserve copy of graph in SuperWord.\")                     \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -58,0 +58,3 @@\n+const char* C2Compiler::retry_no_superword() {\n+  return \"retry without SuperWord\";\n+}\n@@ -115,0 +118,1 @@\n+  bool do_superword = UseSuperWord;\n@@ -118,1 +122,8 @@\n-    Options options(subsume_loads, do_escape_analysis, do_iterative_escape_analysis, do_reduce_allocation_merges, eliminate_boxing, do_locks_coarsening, install_code);\n+    Options options(subsume_loads,\n+                    do_escape_analysis,\n+                    do_iterative_escape_analysis,\n+                    do_reduce_allocation_merges,\n+                    eliminate_boxing,\n+                    do_locks_coarsening,\n+                    do_superword,\n+                    install_code);\n@@ -153,0 +164,6 @@\n+      if (C.failure_reason_is(retry_no_superword())) {\n+        assert(do_superword, \"must make progress\");\n+        do_superword = false;\n+        env->report_failure(C.failure_reason());\n+        continue;  \/\/ retry\n+      }\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+  static const char* retry_no_superword();\n","filename":"src\/hotspot\/share\/opto\/c2compiler.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -183,0 +183,1 @@\n+  const bool _do_superword;          \/\/ Do SuperWord\n@@ -185,1 +186,2 @@\n-  Options(bool subsume_loads, bool do_escape_analysis,\n+  Options(bool subsume_loads,\n+          bool do_escape_analysis,\n@@ -188,1 +190,3 @@\n-          bool eliminate_boxing, bool do_locks_coarsening,\n+          bool eliminate_boxing,\n+          bool do_locks_coarsening,\n+          bool do_superword,\n@@ -196,0 +200,1 @@\n+          _do_superword(do_superword),\n@@ -207,0 +212,1 @@\n+       \/* do_superword = *\/ true,\n@@ -581,0 +587,1 @@\n+  bool              do_superword() const        { return _options._do_superword; }\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -936,1 +936,2 @@\n-  if (UseSuperWord && cl->node_count_before_unroll() > 0 &&\n+  if (phase->C->do_superword() &&\n+      cl->node_count_before_unroll() > 0 &&\n@@ -1041,1 +1042,1 @@\n-  if (UseSuperWord) {\n+  if (phase->C->do_superword()) {\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -287,145 +287,0 @@\n-LoopNode* PhaseIdealLoop::create_reserve_version_of_loop(IdealLoopTree *loop, CountedLoopReserveKit* lk) {\n-  Node_List old_new;\n-  LoopNode* head  = loop->_head->as_Loop();\n-  Node*     entry = head->skip_strip_mined()->in(LoopNode::EntryControl);\n-  _igvn.rehash_node_delayed(entry);\n-  IdealLoopTree* outer_loop = head->is_strip_mined() ? loop->_parent->_parent : loop->_parent;\n-\n-  ConINode* const_1 = _igvn.intcon(1);\n-  set_ctrl(const_1, C->root());\n-  IfNode* iff = new IfNode(entry, const_1, PROB_MAX, COUNT_UNKNOWN);\n-  register_node(iff, outer_loop, entry, dom_depth(entry));\n-  ProjNode* iffast = new IfTrueNode(iff);\n-  register_node(iffast, outer_loop, iff, dom_depth(iff));\n-  ProjNode* ifslow = new IfFalseNode(iff);\n-  register_node(ifslow, outer_loop, iff, dom_depth(iff));\n-\n-  \/\/ Clone the loop body.  The clone becomes the slow loop.  The\n-  \/\/ original pre-header will (illegally) have 3 control users\n-  \/\/ (old & new loops & new if).\n-  clone_loop(loop, old_new, dom_depth(head), CloneIncludesStripMined, iff);\n-  assert(old_new[head->_idx]->is_Loop(), \"\" );\n-\n-  LoopNode* slow_head = old_new[head->_idx]->as_Loop();\n-\n-#ifndef PRODUCT\n-  if (TraceLoopOpts) {\n-    tty->print_cr(\"PhaseIdealLoop::create_reserve_version_of_loop:\");\n-    tty->print(\"\\t iff = %d, \", iff->_idx); iff->dump();\n-    tty->print(\"\\t iffast = %d, \", iffast->_idx); iffast->dump();\n-    tty->print(\"\\t ifslow = %d, \", ifslow->_idx); ifslow->dump();\n-    tty->print(\"\\t before replace_input_of: head = %d, \", head->_idx); head->dump();\n-    tty->print(\"\\t before replace_input_of: slow_head = %d, \", slow_head->_idx); slow_head->dump();\n-  }\n-#endif\n-\n-  \/\/ Fast (true) control\n-  _igvn.replace_input_of(head->skip_strip_mined(), LoopNode::EntryControl, iffast);\n-  \/\/ Slow (false) control\n-  _igvn.replace_input_of(slow_head->skip_strip_mined(), LoopNode::EntryControl, ifslow);\n-\n-  recompute_dom_depth();\n-\n-  lk->set_iff(iff);\n-\n-#ifndef PRODUCT\n-  if (TraceLoopOpts ) {\n-    tty->print(\"\\t after  replace_input_of: head = %d, \", head->_idx); head->dump();\n-    tty->print(\"\\t after  replace_input_of: slow_head = %d, \", slow_head->_idx); slow_head->dump();\n-  }\n-#endif\n-\n-  return slow_head->as_Loop();\n-}\n-\n-CountedLoopReserveKit::CountedLoopReserveKit(PhaseIdealLoop* phase, IdealLoopTree *loop, bool active = true) :\n-  _phase(phase),\n-  _lpt(loop),\n-  _lp(nullptr),\n-  _iff(nullptr),\n-  _lp_reserved(nullptr),\n-  _has_reserved(false),\n-  _use_new(false),\n-  _active(active)\n-  {\n-    create_reserve();\n-  };\n-\n-CountedLoopReserveKit::~CountedLoopReserveKit() {\n-  if (!_active) {\n-    return;\n-  }\n-\n-  if (_has_reserved && !_use_new) {\n-    \/\/ intcon(0)->iff-node reverts CF to the reserved copy\n-    ConINode* const_0 = _phase->_igvn.intcon(0);\n-    _phase->set_ctrl(const_0, _phase->C->root());\n-    _iff->set_req(1, const_0);\n-\n-    #ifndef PRODUCT\n-      if (TraceLoopOpts) {\n-        tty->print_cr(\"CountedLoopReserveKit::~CountedLoopReserveKit()\");\n-        tty->print(\"\\t discard loop %d and revert to the reserved loop clone %d: \", _lp->_idx, _lp_reserved->_idx);\n-        _lp_reserved->dump();\n-      }\n-    #endif\n-  }\n-}\n-\n-bool CountedLoopReserveKit::create_reserve() {\n-  if (!_active) {\n-    return false;\n-  }\n-\n-  if(!_lpt->_head->is_CountedLoop()) {\n-    if (TraceLoopOpts) {\n-      tty->print_cr(\"CountedLoopReserveKit::create_reserve: %d not counted loop\", _lpt->_head->_idx);\n-    }\n-    return false;\n-  }\n-  CountedLoopNode *cl = _lpt->_head->as_CountedLoop();\n-  if (!cl->is_valid_counted_loop(T_INT)) {\n-    if (TraceLoopOpts) {\n-      tty->print_cr(\"CountedLoopReserveKit::create_reserve: %d not valid counted loop\", cl->_idx);\n-    }\n-    return false; \/\/ skip malformed counted loop\n-  }\n-  if (!cl->is_main_loop()) {\n-    bool loop_not_canonical = true;\n-    if (cl->is_post_loop() && (cl->slp_max_unroll() > 0)) {\n-      loop_not_canonical = false;\n-    }\n-    \/\/ only reject some loop forms\n-    if (loop_not_canonical) {\n-      if (TraceLoopOpts) {\n-        tty->print_cr(\"CountedLoopReserveKit::create_reserve: %d not canonical loop\", cl->_idx);\n-      }\n-      return false; \/\/ skip normal, pre, and post (conditionally) loops\n-    }\n-  }\n-\n-  _lp = _lpt->_head->as_Loop();\n-  _lp_reserved = _phase->create_reserve_version_of_loop(_lpt, this);\n-\n-  if (!_lp_reserved->is_CountedLoop()) {\n-    return false;\n-  }\n-\n-  Node* ifslow_pred = _lp_reserved->skip_strip_mined()->in(LoopNode::EntryControl);\n-\n-  if (!ifslow_pred->is_IfFalse()) {\n-    return false;\n-  }\n-\n-  Node* iff = ifslow_pred->in(0);\n-  if (!iff->is_If() || iff != _iff) {\n-    return false;\n-  }\n-\n-  if (iff->in(1)->Opcode() != Op_ConI) {\n-    return false;\n-  }\n-\n-  _has_reserved = true;\n-  return true;\n-}\n","filename":"src\/hotspot\/share\/opto\/loopUnswitch.cpp","additions":0,"deletions":145,"binary":false,"changes":145,"status":"modified"},{"patch":"@@ -4643,1 +4643,1 @@\n-  if (UseSuperWord && C->has_loops() && !C->major_progress()) {\n+  if (C->do_superword() && C->has_loops() && !C->major_progress()) {\n@@ -5362,4 +5362,4 @@\n-          if( UseSuperWord || !iff->is_If() ||\n-              (n->in(0)->Opcode() == Op_IfFalse &&\n-               (1.0 - iff->as_If()->_prob) >= 0.01) ||\n-              (iff->as_If()->_prob >= 0.01) )\n+          if (C->do_superword() ||\n+              !iff->is_If() ||\n+              (n->in(0)->Opcode() == Op_IfFalse && (1.0 - iff->as_If()->_prob) >= 0.01) ||\n+              iff->as_If()->_prob >= 0.01) {\n@@ -5367,0 +5367,1 @@\n+          }\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -45,1 +45,0 @@\n-class CountedLoopReserveKit;\n@@ -821,1 +820,0 @@\n-  friend class CountedLoopReserveKit;\n@@ -1418,10 +1416,0 @@\n-  \/\/ Clone a loop and return the clone head (clone_loop_head).\n-  \/\/ Added nodes include int(1), int(0) - disconnected, If, IfTrue, IfFalse,\n-  \/\/ This routine was created for usage in CountedLoopReserveKit.\n-  \/\/\n-  \/\/    int(1) -> If -> IfTrue -> original_loop_head\n-  \/\/              |\n-  \/\/              V\n-  \/\/           IfFalse -> clone_loop_head (returned by function pointer)\n-  \/\/\n-  LoopNode* create_reserve_version_of_loop(IdealLoopTree *loop, CountedLoopReserveKit* lk);\n@@ -1797,63 +1785,0 @@\n-\n-\/\/ This kit may be used for making of a reserved copy of a loop before this loop\n-\/\/  goes under non-reversible changes.\n-\/\/\n-\/\/ Function create_reserve() creates a reserved copy (clone) of the loop.\n-\/\/ The reserved copy is created by calling\n-\/\/ PhaseIdealLoop::create_reserve_version_of_loop - see there how\n-\/\/ the original and reserved loops are connected in the outer graph.\n-\/\/ If create_reserve succeeded, it returns 'true' and _has_reserved is set to 'true'.\n-\/\/\n-\/\/ By default the reserved copy (clone) of the loop is created as dead code - it is\n-\/\/ dominated in the outer loop by this node chain:\n-\/\/   intcon(1)->If->IfFalse->reserved_copy.\n-\/\/ The original loop is dominated by the same node chain but IfTrue projection:\n-\/\/   intcon(0)->If->IfTrue->original_loop.\n-\/\/\n-\/\/ In this implementation of CountedLoopReserveKit the ctor includes create_reserve()\n-\/\/ and the dtor, checks _use_new value.\n-\/\/ If _use_new == false, it \"switches\" control to reserved copy of the loop\n-\/\/ by simple replacing of node intcon(1) with node intcon(0).\n-\/\/\n-\/\/ Here is a proposed example of usage (see also SuperWord::output in superword.cpp).\n-\/\/\n-\/\/ void CountedLoopReserveKit_example()\n-\/\/ {\n-\/\/    CountedLoopReserveKit lrk((phase, lpt, DoReserveCopy = true); \/\/ create local object\n-\/\/    if (DoReserveCopy && !lrk.has_reserved()) {\n-\/\/      return; \/\/failed to create reserved loop copy\n-\/\/    }\n-\/\/    ...\n-\/\/    \/\/something is wrong, switch to original loop\n-\/\/\/   if(something_is_wrong) return; \/\/ ~CountedLoopReserveKit makes the switch\n-\/\/    ...\n-\/\/    \/\/everything worked ok, return with the newly modified loop\n-\/\/    lrk.use_new();\n-\/\/    return; \/\/ ~CountedLoopReserveKit does nothing once use_new() was called\n-\/\/  }\n-\/\/\n-\/\/ Keep in mind, that by default if create_reserve() is not followed by use_new()\n-\/\/ the dtor will \"switch to the original\" loop.\n-\/\/ NOTE. You you modify outside of the original loop this class is no help.\n-\/\/\n-class CountedLoopReserveKit {\n-  private:\n-    PhaseIdealLoop* _phase;\n-    IdealLoopTree*  _lpt;\n-    LoopNode*       _lp;\n-    IfNode*         _iff;\n-    LoopNode*       _lp_reserved;\n-    bool            _has_reserved;\n-    bool            _use_new;\n-    const bool      _active; \/\/may be set to false in ctor, then the object is dummy\n-\n-  public:\n-    CountedLoopReserveKit(PhaseIdealLoop* phase, IdealLoopTree *loop, bool active);\n-    ~CountedLoopReserveKit();\n-    void use_new()                {_use_new = true;}\n-    void set_iff(IfNode* x)       {_iff = x;}\n-    bool has_reserved()     const { return _active && _has_reserved;}\n-  private:\n-    bool create_reserve();\n-};\/\/ class CountedLoopReserveKit\n-\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":0,"deletions":75,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"opto\/c2compiler.hpp\"\n@@ -73,1 +74,0 @@\n-  _do_reserve_copy(DoReserveCopyInSuperWord),\n@@ -88,1 +88,1 @@\n-  assert(UseSuperWord, \"should be\");\n+  assert(_phase->C->do_superword(), \"SuperWord option should be enabled\");\n@@ -2496,16 +2496,0 @@\n-#ifndef PRODUCT\n-void SuperWord::print_loop(bool whole) {\n-  Node_Stack stack(_arena, _phase->C->unique() >> 2);\n-  Node_List rpo_list;\n-  VectorSet visited(_arena);\n-  visited.set(lpt()->_head->_idx);\n-  _phase->rpo(lpt()->_head, stack, visited, rpo_list);\n-  _phase->dump(lpt(), rpo_list.size(), rpo_list );\n-  if(whole) {\n-    tty->print_cr(\"\\n Whole loop tree\");\n-    _phase->dump();\n-    tty->print_cr(\" End of whole loop tree\\n\");\n-  }\n-}\n-#endif\n-\n@@ -2514,0 +2498,5 @@\n+\/\/ At this point, all correctness and profitability checks have passed.\n+\/\/ We start the irreversible process of editing the C2 graph. Should\n+\/\/ there be an unexpected situation (assert fails), then we can only\n+\/\/ bail out of the compilation, as the graph has already been partially\n+\/\/ modified. We bail out, and retry without SuperWord.\n@@ -2541,11 +2530,0 @@\n-  NOT_PRODUCT(if(is_trace_loop_reverse()) {tty->print_cr(\"VPointer::output: print loop before create_reserve_version_of_loop\"); print_loop(true);})\n-\n-  CountedLoopReserveKit make_reversable(_phase, _lpt, do_reserve_copy());\n-\n-  NOT_PRODUCT(if(is_trace_loop_reverse()) {tty->print_cr(\"VPointer::output: print loop after create_reserve_version_of_loop\"); print_loop(true);})\n-\n-  if (do_reserve_copy() && !make_reversable.has_reserved()) {\n-    NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty->print_cr(\"VPointer::output: loop was not reserved correctly, exiting SuperWord\");})\n-    return false;\n-  }\n-\n@@ -2590,6 +2568,3 @@\n-          if (do_reserve_copy()) {\n-            NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty->print_cr(\"VPointer::output: val should not be null, exiting SuperWord\");})\n-            assert(false, \"input to vector store was not created\");\n-            return false; \/\/and reverse to backup IG\n-          }\n-          ShouldNotReachHere();\n+          assert(false, \"input to vector store was not created\");\n+          C->record_failure(C2Compiler::retry_no_superword());\n+          return false; \/\/ bailout\n@@ -2732,6 +2707,3 @@\n-            if (do_reserve_copy()) {\n-              NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty->print_cr(\"VPointer::output: in1 should not be null, exiting SuperWord\");})\n-              assert(false, \"input in1 to vector operand was not created\");\n-              return false; \/\/and reverse to backup IG\n-            }\n-            ShouldNotReachHere();\n+            assert(false, \"input in1 to vector operand was not created\");\n+            C->record_failure(C2Compiler::retry_no_superword());\n+            return false; \/\/ bailout\n@@ -2742,6 +2714,3 @@\n-          if (do_reserve_copy()) {\n-            NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty->print_cr(\"VPointer::output: in2 should not be null, exiting SuperWord\");})\n-            assert(false, \"input in2 to vector operand was not created\");\n-            return false; \/\/and reverse to backup IG\n-          }\n-          ShouldNotReachHere();\n+          assert(false, \"input in2 to vector operand was not created\");\n+          C->record_failure(C2Compiler::retry_no_superword());\n+          return false; \/\/ bailout\n@@ -2816,6 +2785,3 @@\n-        if (do_reserve_copy()) {\n-          NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty->print_cr(\"VPointer::output: Unhandled scalar opcode (%s), ShouldNotReachHere, exiting SuperWord\", NodeClassNames[opc]);})\n-          assert(false, \"Unhandled scalar opcode (%s)\", NodeClassNames[opc]);\n-          return false; \/\/and reverse to backup IG\n-        }\n-        ShouldNotReachHere();\n+        assert(false, \"Unhandled scalar opcode (%s)\", NodeClassNames[opc]);\n+        C->record_failure(C2Compiler::retry_no_superword());\n+        return false; \/\/ bailout\n@@ -2824,1 +2790,0 @@\n-      assert(vn != nullptr, \"sanity\");\n@@ -2826,5 +2791,3 @@\n-        if (do_reserve_copy()){\n-          NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty->print_cr(\"VPointer::output: got null node, cannot proceed, exiting SuperWord\");})\n-          return false; \/\/and reverse to backup IG\n-        }\n-        ShouldNotReachHere();\n+        assert(false, \"got null node instead of vector node\");\n+        C->record_failure(C2Compiler::retry_no_superword());\n+        return false; \/\/ bailout\n@@ -2877,5 +2840,0 @@\n-  if (do_reserve_copy()) {\n-    make_reversable.use_new();\n-  }\n-\n-  NOT_PRODUCT(if(is_trace_loop_reverse()) {tty->print_cr(\"\\n Final loop after SuperWord\"); print_loop(true);})\n@@ -2912,1 +2870,0 @@\n-      assert(((opd_idx != 2) || !VectorNode::is_shift(p0)), \"shift's count can't be vector\");\n@@ -2914,1 +2871,1 @@\n-        NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty->print_cr(\"shift's count can't be vector\");})\n+        assert(false, \"shift's count can't be vector\");\n@@ -2938,1 +2895,0 @@\n-        assert(opd->bottom_type()->isa_int(), \"int type only\");\n@@ -2940,1 +2896,1 @@\n-          NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty->print_cr(\"Should be int type only\");})\n+          assert(false, \"int type only\");\n@@ -2950,1 +2906,0 @@\n-    assert(!opd->is_StoreVector(), \"such vector is not expected here\");\n@@ -2952,1 +2907,1 @@\n-      NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty->print_cr(\"StoreVector is not expected here\");})\n+      assert(false, \"StoreVector is not expected here\");\n@@ -2989,1 +2944,0 @@\n-    assert(my_pack(in) == nullptr, \"Should already have been unpacked\");\n@@ -2991,1 +2945,1 @@\n-      NOT_PRODUCT(if(is_trace_loop_reverse() || TraceLoopOpts) {tty->print_cr(\"Should already have been unpacked\");})\n+      assert(false, \"Should already have been unpacked\");\n@@ -2998,1 +2952,0 @@\n-      assert(my_pack(in2) == nullptr, \"Should already have been unpacked\");\n@@ -3000,2 +2953,2 @@\n-        NOT_PRODUCT(if (is_trace_loop_reverse() || TraceLoopOpts) { tty->print_cr(\"Should already have been unpacked\"); })\n-          return nullptr;\n+        assert(false, \"Should already have been unpacked\");\n+        return nullptr;\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":28,"deletions":75,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -284,1 +284,0 @@\n-  bool     is_trace_loop_reverse() { return (_vector_loop_debug & 64) > 0; }\n@@ -287,1 +286,0 @@\n-  bool     do_reserve_copy()       { return _do_reserve_copy; }\n@@ -301,1 +299,0 @@\n-  bool           _do_reserve_copy; \/\/ do reserve copy of the graph(loop) before final modification in output\n@@ -450,1 +447,0 @@\n-  void print_loop(bool whole);\n","filename":"src\/hotspot\/share\/opto\/superword.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -527,0 +527,1 @@\n+  { \"DoReserveCopyInSuperWord\",     JDK_Version::undefined(), JDK_Version::jdk(22), JDK_Version::jdk(23) },\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}