{"files":[{"patch":"@@ -388,1 +388,0 @@\n-\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/AnnotationElement.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -229,1 +229,0 @@\n-\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/EventFactory.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-public final class ASMToolkit {\n+final class ASMToolkit {\n@@ -42,28 +42,14 @@\n-        String typeName = v.getTypeName();\n-\n-        switch (typeName) {\n-        case \"byte\":\n-            return Type.BYTE_TYPE;\n-        case \"short\":\n-            return Type.SHORT_TYPE;\n-        case \"int\":\n-            return Type.INT_TYPE;\n-        case \"long\":\n-            return Type.LONG_TYPE;\n-        case \"double\":\n-            return Type.DOUBLE_TYPE;\n-        case \"float\":\n-            return Type.FLOAT_TYPE;\n-        case \"char\":\n-            return Type.CHAR_TYPE;\n-        case \"boolean\":\n-            return Type.BOOLEAN_TYPE;\n-        case \"java.lang.String\":\n-            return TYPE_STRING;\n-        case \"java.lang.Thread\":\n-            return TYPE_THREAD;\n-        case \"java.lang.Class\":\n-            return TYPE_CLASS;\n-        }\n-        \/\/ Add support for SettingControl?\n-       throw new Error(\"Not a valid type \" + v.getTypeName());\n+        return switch (v.getTypeName()) {\n+            case \"byte\" -> Type.BYTE_TYPE;\n+            case \"short\" -> Type.SHORT_TYPE;\n+            case \"int\" ->  Type.INT_TYPE;\n+            case \"long\" ->Type.LONG_TYPE;\n+            case \"double\" -> Type.DOUBLE_TYPE;\n+            case \"float\" -> Type.FLOAT_TYPE;\n+            case \"char\" -> Type.CHAR_TYPE;\n+            case \"boolean\" -> Type.BOOLEAN_TYPE;\n+            case \"java.lang.String\" -> TYPE_STRING;\n+            case \"java.lang.Thread\" -> TYPE_THREAD;\n+            case \"java.lang.Class\" -> TYPE_CLASS;\n+            default -> throw new Error(\"Not a valid type \" + v.getTypeName());\n+        };\n@@ -81,26 +67,11 @@\n-        if (\"int\".equals(typeName)) {\n-            return \"I\";\n-        }\n-        if (\"long\".equals(typeName)) {\n-            return \"J\";\n-        }\n-        if (\"boolean\".equals(typeName)) {\n-            return \"Z\";\n-        }\n-        if (\"float\".equals(typeName)) {\n-            return \"F\";\n-        }\n-        if (\"double\".equals(typeName)) {\n-            return \"D\";\n-        }\n-        if (\"short\".equals(typeName)) {\n-            return \"S\";\n-        }\n-        if (\"char\".equals(typeName)) {\n-            return \"C\";\n-        }\n-        if (\"byte\".equals(typeName)) {\n-            return \"B\";\n-        }\n-        String internal = getInternalName(typeName);\n-        return Type.getObjectType(internal).getDescriptor();\n+        return switch (typeName) {\n+            case \"int\" -> \"I\";\n+            case \"long\" -> \"J\";\n+            case \"boolean\" -> \"Z\";\n+            case \"float\" -> \"F\";\n+            case \"double\" -> \"D\";\n+            case \"short\" -> \"S\";\n+            case \"char\" -> \"C\";\n+            case \"byte\" -> \"B\";\n+            default -> Type.getObjectType(getInternalName(typeName)).getDescriptor();\n+        };\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/ASMToolkit.java","additions":26,"deletions":55,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-    private static final class AnnotationInvokationHandler implements InvocationHandler {\n+    private static final class AnnotationInvocationHandler implements InvocationHandler {\n@@ -45,1 +45,1 @@\n-        AnnotationInvokationHandler(AnnotationElement a) {\n+        AnnotationInvocationHandler(AnnotationElement a) {\n@@ -94,1 +94,1 @@\n-            return (T) Proxy.newProxyInstance(clazz.getClassLoader(), new Class<?>[] { clazz }, new AnnotationInvokationHandler(ae));\n+            return (T) Proxy.newProxyInstance(clazz.getClassLoader(), new Class<?>[] { clazz }, new AnnotationInvocationHandler(ae));\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/AnnotationConstruct.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-public final class Control {\n+final class Control {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/Control.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -59,7 +59,1 @@\n-    static final class NamedControl {\n-        public final String name;\n-        public final Control control;\n-        NamedControl(String name, Control control) {\n-            this.name = name;\n-            this.control = control;\n-        }\n+    record NamedControl(String name, Control control) {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/EventControl.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -44,8 +44,1 @@\n-    static final class Attribute {\n-        final String name;\n-        final String value;\n-\n-        private Attribute(String name, String value) {\n-            this.name = name;\n-            this.value = value;\n-        }\n+    record Attribute(String name, String value) {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/MetadataDescriptor.java","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -114,1 +114,1 @@\n-    private static class FieldElement {\n+    private static final class FieldElement {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/MetadataLoader.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -184,14 +184,11 @@\n-            switch (typeName) {\n-            case \"int\":\n-                return Integer.valueOf(text);\n-            case \"long\":\n-                return Long.valueOf(text);\n-            case \"double\":\n-                return Double.valueOf(text);\n-            case \"float\":\n-                return Float.valueOf(text);\n-            case \"short\":\n-                return Short.valueOf(text);\n-            case \"char\":\n-                if (text.length() != 1) {\n-                    throw new IOException(\"Unexpected size of char\");\n+            return switch (typeName) {\n+                case \"int\" -> Integer.valueOf(text);\n+                case \"long\" -> Long.valueOf(text);\n+                case \"double\" ->   Double.valueOf(text);\n+                case \"float\" -> Float.valueOf(text);\n+                case \"short\" -> Short.valueOf(text);\n+                case \"char\" -> {\n+                    if (text.length() != 1) {\n+                        throw new IOException(\"Unexpected size of char\");\n+                    }\n+                    yield text.charAt(0);\n@@ -199,8 +196,5 @@\n-                return text.charAt(0);\n-            case \"byte\":\n-                return Byte.valueOf(text);\n-            case \"boolean\":\n-                return Boolean.valueOf(text);\n-            case \"java.lang.String\":\n-                return text;\n-            }\n+                case \"byte\" -> Byte.valueOf(text);\n+                case \"boolean\" -> Boolean.valueOf(text);\n+                case \"java.lang.String\" -> text;\n+                default -> throw new IOException(\"Unsupported type for annotation \" + typeName);\n+            };\n@@ -210,1 +204,0 @@\n-        throw new IOException(\"Unsupported type for annotation \" + typeName);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/MetadataReader.java","additions":16,"deletions":23,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-import java.util.Set;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/MetadataRepository.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -140,2 +140,2 @@\n-            pool.add(a.name);\n-            pool.add(a.value);\n+            pool.add(a.name());\n+            pool.add(a.value());\n@@ -152,2 +152,2 @@\n-            writeInt(output, lookup.get(a.name));\n-            writeInt(output, lookup.get(a.value));\n+            writeInt(output, lookup.get(a.name()));\n+            writeInt(output, lookup.get(a.value()));\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/MetadataWriter.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -222,1 +222,1 @@\n-            String settingName = nc.name;\n+            String settingName = nc.name();\n@@ -226,1 +226,1 @@\n-            Control control = nc.control;\n+            Control control = nc.control();\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/SettingsManager.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -62,1 +62,0 @@\n-    protected final PlatformRecording recording;\n@@ -64,1 +63,1 @@\n-\n+    private final ParserState parserState = new ParserState();\n@@ -67,3 +66,0 @@\n-\n-    protected final ParserState parserState = new ParserState();\n-\n@@ -72,1 +68,1 @@\n-    AbstractEventStream(@SuppressWarnings(\"removal\") AccessControlContext acc, PlatformRecording recording, List<Configuration> configurations) throws IOException {\n+    AbstractEventStream(@SuppressWarnings(\"removal\") AccessControlContext acc, List<Configuration> configurations) throws IOException {\n@@ -74,1 +70,0 @@\n-        this.recording = recording;\n@@ -218,0 +213,2 @@\n+    protected abstract boolean isRecording();\n+\n@@ -226,0 +223,4 @@\n+    protected final ParserState parserState() {\n+        return parserState;\n+    }\n+\n@@ -257,1 +258,1 @@\n-            if (recording != null && streamConfiguration.startTime == null) {\n+            if (isRecording() && streamConfiguration.startTime == null) {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/AbstractEventStream.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import jdk.jfr.internal.Utils;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/ChunkHeader.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -53,17 +53,1 @@\n-    public static final class ParserConfiguration {\n-        private final boolean reuse;\n-        private final boolean ordered;\n-        private final ParserFilter eventFilter;\n-        private final ChunkWriter chunkWriter;\n-\n-        long filterStart;\n-        long filterEnd;\n-\n-        public ParserConfiguration(long filterStart, long filterEnd, boolean reuse, boolean ordered, ParserFilter filter, ChunkWriter chunkWriter) {\n-            this.filterStart = filterStart;\n-            this.filterEnd = filterEnd;\n-            this.reuse = reuse;\n-            this.ordered = ordered;\n-            this.eventFilter = filter;\n-            this.chunkWriter = chunkWriter;\n-        }\n+    public record ParserConfiguration(long filterStart, long filterEnd, boolean reuse,  boolean ordered, ParserFilter filter, ChunkWriter chunkWriter) {\n@@ -75,2 +59,5 @@\n-        public boolean isOrdered() {\n-            return ordered;\n+        ParserConfiguration withRange(long filterStart, long filterEnd) {\n+            if (filterStart == this.filterStart && filterEnd == this.filterEnd) {\n+                return this;\n+            }\n+            return new ParserConfiguration(filterStart, filterEnd, reuse, ordered, filter, chunkWriter);\n@@ -181,1 +168,1 @@\n-                long threshold = configuration.eventFilter.getThreshold(name);\n+                long threshold = configuration.filter().getThreshold(name);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/ChunkParser.java","additions":7,"deletions":20,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-    final Type type;\n+    private final Type type;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/ConstantLookup.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,1 +44,0 @@\n-import jdk.jfr.internal.consumer.ChunkParser.ParserConfiguration;\n@@ -57,1 +56,1 @@\n-\n+    private final PlatformRecording recording;\n@@ -73,1 +72,2 @@\n-        super(acc, recording, configurations);\n+        super(acc, configurations);\n+        this.recording = recording;\n@@ -137,1 +137,1 @@\n-        boolean validStartTime = recording != null || disp.startTime != null;\n+        boolean validStartTime = isRecording() || disp.startTime != null;\n@@ -149,1 +149,1 @@\n-            currentParser = new ChunkParser(input, disp.parserConfiguration, parserState);\n+            currentParser = new ChunkParser(input, disp.parserConfiguration, parserState());\n@@ -159,4 +159,2 @@\n-                        ParserConfiguration pc = disp.parserConfiguration;\n-                        pc.filterStart = filterStart;\n-                        pc.filterEnd = filterEnd;\n-                        currentParser.updateConfiguration(pc, true);\n+                        var ranged = disp.parserConfiguration.withRange(filterStart, filterEnd);\n+                        currentParser.updateConfiguration(ranged, true);\n@@ -165,1 +163,1 @@\n-                    if (disp.parserConfiguration.isOrdered()) {\n+                    if (disp.parserConfiguration.ordered()) {\n@@ -211,1 +209,1 @@\n-        if (recording == null) {\n+        if (!isRecording()) {\n@@ -217,0 +215,4 @@\n+    protected boolean isRecording() {\n+        return recording != null;\n+    }\n+\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/EventDirectoryStream.java","additions":13,"deletions":11,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import java.util.Objects;\n@@ -50,1 +49,1 @@\n-        super(acc, null, Collections.emptyList());\n+        super(acc, Collections.emptyList());\n@@ -76,0 +75,5 @@\n+    @Override\n+    protected boolean isRecording() {\n+        return false;\n+    }\n+\n@@ -88,1 +92,1 @@\n-        currentParser = new ChunkParser(input, disp.parserConfiguration, parserState);\n+        currentParser = new ChunkParser(input, disp.parserConfiguration, parserState());\n@@ -96,4 +100,3 @@\n-            disp.parserConfiguration.filterStart = start;\n-            disp.parserConfiguration.filterEnd = end;\n-            currentParser.updateConfiguration(disp.parserConfiguration, true);\n-            if (disp.parserConfiguration.isOrdered()) {\n+            var ranged  = disp.parserConfiguration.withRange(start, end);\n+            currentParser.updateConfiguration(ranged, true);\n+            if (disp.parserConfiguration.ordered()) {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/EventFileStream.java","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.util.ArrayList;\n@@ -33,1 +32,0 @@\n-import java.util.function.Predicate;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/EventParser.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -66,1 +66,0 @@\n-\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/FinishedStream.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -125,25 +125,17 @@\n-        switch (type.getName()) {\n-        case \"int\":\n-            return new IntegerParser();\n-        case \"long\":\n-            return new LongParser();\n-        case \"float\":\n-            return new FloatParser();\n-        case \"double\":\n-            return new DoubleParser();\n-        case \"char\":\n-            return new CharacterParser();\n-        case \"boolean\":\n-            return new BooleanParser();\n-        case \"short\":\n-            return new ShortParser();\n-        case \"byte\":\n-            return new ByteParser();\n-        case \"java.lang.String\":\n-            ConstantMap pool = new ConstantMap(ObjectFactory.create(type, timeConverter), type);\n-            ConstantLookup lookup = new ConstantLookup(pool, type);\n-            constantLookups.put(type.getId(), lookup);\n-            return new StringParser(lookup, event);\n-        default:\n-            throw new IOException(\"Unknown primitive type \" + type.getName());\n-        }\n+        return switch (type.getName()) {\n+            case \"int\" ->  new IntegerParser();\n+            case \"long\" -> new LongParser();\n+            case \"float\" ->  new FloatParser();\n+            case \"double\" -> new DoubleParser();\n+            case \"char\" ->  new CharacterParser();\n+            case \"boolean\" -> new BooleanParser();\n+            case \"short\" -> new ShortParser();\n+            case \"byte\" ->  new ByteParser();\n+            case \"java.lang.String\" -> {\n+                ConstantMap pool = new ConstantMap(ObjectFactory.create(type, timeConverter), type);\n+                ConstantLookup lookup = new ConstantLookup(pool, type);\n+                constantLookups.put(type.getId(), lookup);\n+                yield new StringParser(lookup, event);\n+            }\n+            default ->  throw new IOException(\"Unknown primitive type \" + type.getName());\n+        };\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/consumer\/ParserFactory.java","additions":17,"deletions":25,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -41,1 +41,2 @@\n-    private ConstructorWriter useInputParameter, noUseInputParameter;\n+    private final ConstructorWriter useInputParameter;\n+    private final ConstructorWriter noUseInputParameter;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/instrument\/ConstructorTracerWriter.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -37,3 +37,3 @@\n-    private boolean useInputParameter;\n-    private String shortClassName;\n-    private String fullClassName;\n+    private final boolean useInputParameter;\n+    private final String shortClassName;\n+    private final String fullClassName;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/instrument\/ConstructorWriter.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-    private static final Predicate<RecordedThread> FALSE_THREAD_PREDICATE = e -> false;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/Filters.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.util.ArrayDeque;\n@@ -30,1 +31,0 @@\n-import java.util.LinkedList;\n@@ -43,1 +43,1 @@\n-        Deque<String> argList = new LinkedList<>(Arrays.asList(args));\n+        Deque<String> argList = new ArrayDeque<>(Arrays.asList(args));\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/Main.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-    private char[] indentionArray = new char[0];\n+    private String indention = \"\";\n@@ -68,1 +68,1 @@\n-        builder.append(indentionArray, 0, indent);\n+        builder.append(indention, 0, indent);\n@@ -117,5 +117,2 @@\n-        if (indent > indentionArray.length) {\n-            indentionArray = new char[indent];\n-            for (int i = 0; i < indentionArray.length; i++) {\n-                indentionArray[i] = ' ';\n-            }\n+        if (indent > indention.length()) {\n+            indention = \" \".repeat(2 * indent);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/StructuredWriter.java","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -150,2 +150,2 @@\n-            println(typeHeader + pad(minWidth - typeHeader.length(), ' ') + header);\n-            println(pad(minWidth + header.length(), '='));\n+            println(typeHeader + \" \".repeat(minWidth - typeHeader.length()) + header);\n+            println(\"=\".repeat(minWidth + header.length()));\n@@ -157,8 +157,0 @@\n-\n-    private String pad(int count, char c) {\n-        StringBuilder sb = new StringBuilder();\n-        for (int i = 0; i < count; i++) {\n-            sb.append(c);\n-        }\n-        return sb.toString();\n-    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/tool\/Summary.java","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"}]}