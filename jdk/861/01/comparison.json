{"files":[{"patch":"@@ -96,0 +96,2 @@\n+  product(bool, UseSIMDForBigIntegerShiftIntrinsics, true,              \\\n+          \"Use SIMD instructions for left\/right shift of BigInteger\")   \\\n","filename":"src\/hotspot\/cpu\/aarch64\/globals_aarch64.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3971,0 +3971,232 @@\n+  \/\/ Arguments:\n+  \/\/\n+  \/\/ Input:\n+  \/\/   c_rarg0   - newArr address\n+  \/\/   c_rarg1   - oldArr address\n+  \/\/   c_rarg2   - newIdx\n+  \/\/   c_rarg3   - shiftCount\n+  \/\/   c_rarg4   - numIter\n+  \/\/\n+  address generate_bigIntegerRightShift() {\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this,  \"StubRoutines\", \"bigIntegerRightShiftWorker\");\n+    address start = __ pc();\n+\n+    Label ShiftSIMDLoop, ShiftTwoLoop, ShiftThree, ShiftTwo, ShiftOne, Exit;\n+\n+    Register newArr        = c_rarg0;\n+    Register oldArr        = c_rarg1;\n+    Register newIdx        = c_rarg2;\n+    Register shiftCount    = c_rarg3;\n+    Register numIter       = c_rarg4;\n+    Register idx           = numIter;\n+\n+    Register newArrCur     = rscratch1;\n+    Register shiftRevCount = rscratch2;\n+    Register oldArrCur     = r13;\n+    Register oldArrNext    = r14;\n+\n+    FloatRegister oldElem0        = v0;\n+    FloatRegister oldElem1        = v1;\n+    FloatRegister newElem         = v2;\n+    FloatRegister shiftVCount     = v3;\n+    FloatRegister shiftVRevCount  = v4;\n+\n+    __ cbz(idx, Exit);\n+\n+    __ add(newArr, newArr, newIdx, Assembler::LSL, 2);\n+\n+    \/\/ left shift count\n+    __ movw(shiftRevCount, 32);\n+    __ subw(shiftRevCount, shiftRevCount, shiftCount);\n+\n+    \/\/ numIter too small to allow a 4-words SIMD loop, rolling back\n+    __ cmp(numIter, (u1)4);\n+    __ br(Assembler::LT, ShiftThree);\n+\n+    __ dup(shiftVCount,    __ T4S, shiftCount);\n+    __ dup(shiftVRevCount, __ T4S, shiftRevCount);\n+    __ negr(shiftVCount,   __ T4S, shiftVCount);\n+\n+    __ BIND(ShiftSIMDLoop);\n+\n+    \/\/ Calculate the load addresses\n+    __ sub(idx, idx, 4);\n+    __ add(oldArrNext, oldArr, idx, Assembler::LSL, 2);\n+    __ add(newArrCur,  newArr, idx, Assembler::LSL, 2);\n+    __ add(oldArrCur,  oldArrNext, 4);\n+\n+    \/\/ Load 4 words and process\n+    __ ld1(oldElem0,  __ T4S,  Address(oldArrCur));\n+    __ ld1(oldElem1,  __ T4S,  Address(oldArrNext));\n+    __ ushl(oldElem0, __ T4S,  oldElem0, shiftVCount);\n+    __ ushl(oldElem1, __ T4S,  oldElem1, shiftVRevCount);\n+    __ orr(newElem,   __ T16B, oldElem0, oldElem1);\n+    __ st1(newElem,   __ T4S,  Address(newArrCur));\n+\n+    __ cmp(idx, (u1)4);\n+    __ br(Assembler::LT, ShiftTwoLoop);\n+    __ b(ShiftSIMDLoop);\n+\n+    __ BIND(ShiftTwoLoop);\n+    __ cbz(idx, Exit);\n+    __ cmp(idx, (u1)1);\n+    __ br(Assembler::EQ, ShiftOne);\n+\n+    \/\/ Calculate the load addresses\n+    __ sub(idx, idx, 2);\n+    __ add(oldArrNext, oldArr, idx, Assembler::LSL, 2);\n+    __ add(newArrCur,  newArr, idx, Assembler::LSL, 2);\n+    __ add(oldArrCur,  oldArrNext, 4);\n+\n+    \/\/ Load 2 words and process\n+    __ ld1(oldElem0,  __ T2S, Address(oldArrCur));\n+    __ ld1(oldElem1,  __ T2S, Address(oldArrNext));\n+    __ ushl(oldElem0, __ T2S, oldElem0, shiftVCount);\n+    __ ushl(oldElem1, __ T2S, oldElem1, shiftVRevCount);\n+    __ orr(newElem,   __ T8B, oldElem0, oldElem1);\n+    __ st1(newElem,   __ T2S, Address(newArrCur));\n+    __ b(ShiftTwoLoop);\n+\n+    __ BIND(ShiftThree);\n+    __ tbz(idx, 1, ShiftOne);\n+    __ tbz(idx, 0, ShiftTwo);\n+    __ ldrw(r10,  Address(oldArr, 12));\n+    __ ldrw(r11,  Address(oldArr, 8));\n+    __ lsrvw(r10, r10, shiftCount);\n+    __ lslvw(r11, r11, shiftRevCount);\n+    __ orrw(r12,  r10, r11);\n+    __ strw(r12,  Address(newArr, 8));\n+\n+    __ BIND(ShiftTwo);\n+    __ ldrw(r10,  Address(oldArr, 8));\n+    __ ldrw(r11,  Address(oldArr, 4));\n+    __ lsrvw(r10, r10, shiftCount);\n+    __ lslvw(r11, r11, shiftRevCount);\n+    __ orrw(r12,  r10, r11);\n+    __ strw(r12,  Address(newArr, 4));\n+\n+    __ BIND(ShiftOne);\n+    __ ldrw(r10,  Address(oldArr, 4));\n+    __ ldrw(r11,  Address(oldArr));\n+    __ lsrvw(r10, r10, shiftCount);\n+    __ lslvw(r11, r11, shiftRevCount);\n+    __ orrw(r12,  r10, r11);\n+    __ strw(r12,  Address(newArr));\n+\n+    __ BIND(Exit);\n+    __ ret(lr);\n+\n+    return start;\n+  }\n+\n+  \/\/ Arguments:\n+  \/\/\n+  \/\/ Input:\n+  \/\/   c_rarg0   - newArr address\n+  \/\/   c_rarg1   - oldArr address\n+  \/\/   c_rarg2   - newIdx\n+  \/\/   c_rarg3   - shiftCount\n+  \/\/   c_rarg4   - numIter\n+  \/\/\n+  address generate_bigIntegerLeftShift() {\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this,  \"StubRoutines\", \"bigIntegerLeftShiftWorker\");\n+    address start = __ pc();\n+\n+    Label ShiftSIMDLoop, ShiftTwoLoop, ShiftThree, ShiftTwo, ShiftOne, Exit;\n+\n+    Register newArr        = c_rarg0;\n+    Register oldArr        = c_rarg1;\n+    Register newIdx        = c_rarg2;\n+    Register shiftCount    = c_rarg3;\n+    Register numIter       = c_rarg4;\n+\n+    Register shiftRevCount = rscratch1;\n+    Register oldArrNext    = rscratch2;\n+\n+    FloatRegister oldElem0        = v0;\n+    FloatRegister oldElem1        = v1;\n+    FloatRegister newElem         = v2;\n+    FloatRegister shiftVCount     = v3;\n+    FloatRegister shiftVRevCount  = v4;\n+\n+    __ cbz(numIter, Exit);\n+\n+    __ add(oldArrNext, oldArr, 4);\n+    __ add(newArr, newArr, newIdx, Assembler::LSL, 2);\n+\n+    \/\/ right shift count\n+    __ movw(shiftRevCount, 32);\n+    __ subw(shiftRevCount, shiftRevCount, shiftCount);\n+\n+    \/\/ numIter too small to allow a 4-words SIMD loop, rolling back\n+    __ cmp(numIter, (u1)4);\n+    __ br(Assembler::LT, ShiftThree);\n+\n+    __ dup(shiftVCount,     __ T4S, shiftCount);\n+    __ dup(shiftVRevCount,  __ T4S, shiftRevCount);\n+    __ negr(shiftVRevCount, __ T4S, shiftVRevCount);\n+\n+    __ BIND(ShiftSIMDLoop);\n+\n+    \/\/ load 4 words and process\n+    __ ld1(oldElem0,  __ T4S,  __ post(oldArr, 16));\n+    __ ld1(oldElem1,  __ T4S,  __ post(oldArrNext, 16));\n+    __ ushl(oldElem0, __ T4S,  oldElem0, shiftVCount);\n+    __ ushl(oldElem1, __ T4S,  oldElem1, shiftVRevCount);\n+    __ orr(newElem,   __ T16B, oldElem0, oldElem1);\n+    __ st1(newElem,   __ T4S,  __ post(newArr, 16));\n+    __ sub(numIter,   numIter, 4);\n+\n+    __ cmp(numIter, (u1)4);\n+    __ br(Assembler::LT, ShiftTwoLoop);\n+    __ b(ShiftSIMDLoop);\n+\n+    __ BIND(ShiftTwoLoop);\n+    __ cbz(numIter, Exit);\n+    __ cmp(numIter, (u1)1);\n+    __ br(Assembler::EQ, ShiftOne);\n+\n+    \/\/ load 2 words and process\n+    __ ld1(oldElem0,  __ T2S,  __ post(oldArr, 8));\n+    __ ld1(oldElem1,  __ T2S,  __ post(oldArrNext, 8));\n+    __ ushl(oldElem0, __ T2S,  oldElem0, shiftVCount);\n+    __ ushl(oldElem1, __ T2S,  oldElem1, shiftVRevCount);\n+    __ orr(newElem,   __ T8B,  oldElem0, oldElem1);\n+    __ st1(newElem,   __ T2S,  __ post(newArr, 8));\n+    __ sub(numIter,   numIter, 2);\n+    __ b(ShiftTwoLoop);\n+\n+    __ BIND(ShiftThree);\n+    __ ldrw(r10,  __ post(oldArr, 4));\n+    __ ldrw(r11,  __ post(oldArrNext, 4));\n+    __ lslvw(r10, r10, shiftCount);\n+    __ lsrvw(r11, r11, shiftRevCount);\n+    __ orrw(r12,  r10, r11);\n+    __ strw(r12,  __ post(newArr, 4));\n+    __ tbz(numIter, 1, Exit);\n+    __ tbz(numIter, 0, ShiftOne);\n+\n+    __ BIND(ShiftTwo);\n+    __ ldrw(r10,  __ post(oldArr, 4));\n+    __ ldrw(r11,  __ post(oldArrNext, 4));\n+    __ lslvw(r10, r10, shiftCount);\n+    __ lsrvw(r11, r11, shiftRevCount);\n+    __ orrw(r12,  r10, r11);\n+    __ strw(r12,  __ post(newArr, 4));\n+\n+    __ BIND(ShiftOne);\n+    __ ldrw(r10,  Address(oldArr));\n+    __ ldrw(r11,  Address(oldArrNext));\n+    __ lslvw(r10, r10, shiftCount);\n+    __ lsrvw(r11, r11, shiftRevCount);\n+    __ orrw(r12,  r10, r11);\n+    __ strw(r12,  Address(newArr));\n+\n+    __ BIND(Exit);\n+    __ ret(lr);\n+\n+    return start;\n+  }\n+\n@@ -6227,0 +6459,5 @@\n+    if (UseSIMDForBigIntegerShiftIntrinsics) {\n+      StubRoutines::_bigIntegerRightShiftWorker = generate_bigIntegerRightShift();\n+      StubRoutines::_bigIntegerLeftShiftWorker  = generate_bigIntegerLeftShift();\n+    }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":237,"deletions":0,"binary":false,"changes":237,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+import org.openjdk.jmh.annotations.Param;\n@@ -48,1 +49,1 @@\n-    private BigInteger[] hugeArray, largeArray, smallArray, shiftArray;\n+    private BigInteger[] hugeArray, largeArray, smallArray, shiftArray, smallShiftArray;\n@@ -53,0 +54,3 @@\n+    @Param({\"32\", \"64\", \"96\", \"128\", \"160\", \"192\", \"224\", \"256\"})\n+    private int maxNumbits;\n+\n@@ -75,0 +79,3 @@\n+        smallShiftArray = new BigInteger[TESTSIZE]; \/*\n+        * Small numbers, bits count in range [maxNumbits - 31, maxNumbits]\n+        *\/\n@@ -87,0 +94,1 @@\n+            smallShiftArray[i] = new BigInteger(Math.max(maxNumbits - value % 32, 0), r);\n@@ -180,0 +188,26 @@\n+\n+    \/** Invokes the shiftLeft method of small BigInteger with different values. *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TESTSIZE)\n+    public void testSmallLeftShift(Blackhole bh) {\n+        Random rand = new Random();\n+        int shift = rand.nextInt(30) + 1;\n+        BigInteger tmp = null;\n+        for (BigInteger s : smallShiftArray) {\n+            tmp = s.shiftLeft(shift);\n+            bh.consume(tmp);\n+        }\n+    }\n+\n+    \/** Invokes the shiftRight method of small BigInteger with different values. *\/\n+    @Benchmark\n+    @OperationsPerInvocation(TESTSIZE)\n+    public void testSmallRightShift(Blackhole bh) {\n+        Random rand = new Random();\n+        int shift = rand.nextInt(30) + 1;\n+        BigInteger tmp = null;\n+        for (BigInteger s : smallShiftArray) {\n+            tmp = s.shiftRight(shift);\n+            bh.consume(tmp);\n+        }\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/math\/BigIntegers.java","additions":36,"deletions":2,"binary":false,"changes":38,"status":"modified"}]}