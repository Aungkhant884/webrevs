{"files":[{"patch":"@@ -208,1 +208,3 @@\n-        tk = TokenKind.ERROR;\n+        if (flags != DiagnosticFlag.SOURCE_LEVEL) {\n+            tk = TokenKind.ERROR;\n+        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavaTokenizer.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -170,1 +170,5 @@\n-            wasBackslash = !unicodeEscape();\n+            switch (unicodeEscape()) {\n+                case BACKSLASH -> wasBackslash = true;\n+                case VALID_ESCAPE -> wasBackslash = false;\n+                case BROKEN_ESCAPE -> nextUnicodeInputCharacter(); \/\/skip broken unicode escapes\n+            }\n@@ -221,1 +225,1 @@\n-    private boolean unicodeEscape() {\n+    private UnicodeEscapeResult unicodeEscape() {\n@@ -239,1 +243,1 @@\n-            return false;\n+            return UnicodeEscapeResult.BACKSLASH;\n@@ -264,0 +268,1 @@\n+            return UnicodeEscapeResult.VALID_ESCAPE;\n@@ -265,1 +270,2 @@\n-            log.error(position, Errors.IllegalUnicodeEsc);\n+            log.error(index, Errors.IllegalUnicodeEsc);\n+            return UnicodeEscapeResult.BROKEN_ESCAPE;\n@@ -267,0 +273,1 @@\n+    }\n@@ -268,2 +275,4 @@\n-        \/\/ Return true even if error so that the invalid unicode escape is skipped.\n-        return true;\n+    private enum UnicodeEscapeResult {\n+        BACKSLASH,\n+        VALID_ESCAPE,\n+        BROKEN_ESCAPE;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/UnicodeReader.java","additions":15,"deletions":6,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -97,4 +97,4 @@\n-            new TestTuple(ERROR,         \"\\\"\\\\u20\\\"\"),\n-            new TestTuple(ERROR,         \"\\\"\\\\u\\\"\"),\n-            new TestTuple(ERROR,         \"\\\"\\\\uG000\\\"\"),\n-            new TestTuple(ERROR,         \"\\\"\\\\u \\\"\"),\n+            new TestTuple(STRINGLITERAL, \"\\\"\\\\u20\\\"\"),\n+            new TestTuple(STRINGLITERAL, \"\\\"\\\\u\\\"\"),\n+            new TestTuple(STRINGLITERAL, \"\\\"\\\\uG000\\\"\"),\n+            new TestTuple(STRINGLITERAL, \"\\\"\\\\u \\\"\"),\n@@ -102,0 +102,1 @@\n+            new TestTuple(EOF,           \"\\\\u\", \"\"),\n","filename":"test\/langtools\/tools\/javac\/lexer\/JavaLexerTest.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 7073631 7159445 7156633 8028235 8065753 8205418 8205913 8228451 8237041 8253584 8246774 8256411 8256149\n+ * @bug 7073631 7159445 7156633 8028235 8065753 8205418 8205913 8228451 8237041 8253584 8246774 8256411 8256149 8259050\n@@ -1694,0 +1694,67 @@\n+    @Test \/\/JDK-8259050\n+    void testBrokenUnicodeEscape() throws IOException {\n+        String code = \"package t;\\n\" +\n+                      \"class Test {\\n\" +\n+                      \"    private String s1 = \\\"\\\\\" + \"uaaa\\\";\\n\" +\n+                      \"    private String s2 = \\\\\" + \"uaaa;\\n\" +\n+                      \"}\\n\";\n+        DiagnosticCollector<JavaFileObject> coll =\n+                new DiagnosticCollector<>();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll, null,\n+                null, Arrays.asList(new MyFileObject(code)));\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+        Trees trees = Trees.instance(ct);\n+        String ast = cut.toString().replaceAll(\"\\\\R\", \"\\n\");\n+        String expected = \"\"\"\n+                          package t;\n+\n+                          class Test {\n+                              private String s1 = \"\";\n+                              private String s2 = (ERROR);\n+                          } \"\"\";\n+        assertEquals(\"Unexpected AST, got:\\n\" + ast, expected, ast);\n+        List<String> codes = new LinkedList<>();\n+\n+        for (Diagnostic<? extends JavaFileObject> d : coll.getDiagnostics()) {\n+            codes.add(d.getCode());\n+        }\n+\n+        assertEquals(\"testBrokenUnicodeEscape: \" + codes,\n+                Arrays.<String>asList(\"compiler.err.illegal.unicode.esc\",\n+                                      \"compiler.err.illegal.unicode.esc\"),\n+                codes);\n+    }\n+\n+    @Test \/\/JDK-8259050\n+    void testUsupportedTextBlock() throws IOException {\n+        String code = \"\"\"\n+                      package t;\n+                      class Test {\n+                          private String s = \\\"\"\"\n+                                             \\\"\"\";\n+                      }\"\"\";\n+        DiagnosticCollector<JavaFileObject> coll =\n+                new DiagnosticCollector<>();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll, List.of(\"--release\", \"14\"),\n+                null, Arrays.asList(new MyFileObject(code)));\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+        Trees trees = Trees.instance(ct);\n+        String ast = cut.toString().replaceAll(\"\\\\R\", \"\\n\");\n+        String expected = \"\"\"\n+                          package t;\n+\n+                          class Test {\n+                              private String s = \"\";\n+                          } \"\"\";\n+        assertEquals(\"Unexpected AST, got:\\n\" + ast, expected, ast);\n+        List<String> codes = new LinkedList<>();\n+\n+        for (Diagnostic<? extends JavaFileObject> d : coll.getDiagnostics()) {\n+            codes.add(d.getCode());\n+        }\n+\n+        assertEquals(\"testUsupportedTextBlock: \" + codes,\n+                Arrays.<String>asList(\"compiler.err.feature.not.supported.in.source.plural\"),\n+                codes);\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/parser\/JavacParserTest.java","additions":68,"deletions":1,"binary":false,"changes":69,"status":"modified"}]}