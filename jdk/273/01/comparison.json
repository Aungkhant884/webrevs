{"files":[{"patch":"@@ -178,1 +178,2 @@\n-    narrowOop n = CompressedOops::encode((oop)o);\n+    narrowOop noop = CompressedOops::encode((oop)o);\n+    uint32_t n = CompressedOops::narrow_oop_value(noop);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -223,2 +223,3 @@\n-  int xc = (data >> 16) & 0xffff;\n-  int xd = (data >>  0) & 0xffff;\n+  uint32_t data_value = CompressedOops::narrow_oop_value(data);\n+  int xc = (data_value >> 16) & 0xffff;\n+  int xd = (data_value >>  0) & 0xffff;\n@@ -257,1 +258,1 @@\n-  return (int) (xl | xh);\n+  return CompressedOops::narrow_oop_cast(xl | xh);\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -199,1 +199,1 @@\n-    narrowOop no = (narrowOop)MacroAssembler::get_narrow_oop(addr, cb->content_begin());\n+    narrowOop no = MacroAssembler::get_narrow_oop(addr, cb->content_begin());\n@@ -296,1 +296,1 @@\n-  if (MacroAssembler::get_narrow_oop(inst2_addr, cb->content_begin()) == (long)data)\n+  if (MacroAssembler::get_narrow_oop(inst2_addr, cb->content_begin()) == data) {\n@@ -298,0 +298,1 @@\n+  }\n@@ -299,1 +300,1 @@\n-    MacroAssembler::patch_set_narrow_oop(inst2_addr, cb->content_begin(), (long)data);\n+    MacroAssembler::patch_set_narrow_oop(inst2_addr, cb->content_begin(), data);\n","filename":"src\/hotspot\/cpu\/ppc\/nativeInst_ppc.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,1 +61,3 @@\n-          CompressedOops::encode((oop)x) : CompressedKlassPointers::encode((Klass*)x);\n+          CompressedOops::encode((oop)x) :\n+          \/\/ FIXME: Cheating! Treating narrowKlass as a narrowOop.\n+          CompressedOops::narrow_oop_cast(CompressedKlassPointers::encode((Klass*)x));\n","filename":"src\/hotspot\/cpu\/ppc\/relocInfo_ppc.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1166,1 +1166,1 @@\n-  load_const_32to64(t, a, false \/*sign_extend*\/);\n+  load_const_32to64(t, CompressedOops::narrow_oop_value(a), false \/*sign_extend*\/);\n@@ -1184,1 +1184,1 @@\n-  Assembler::z_clfi(oop1, oop2);\n+  Assembler::z_clfi(oop1, CompressedOops::narrow_oop_value(oop2));\n@@ -1278,1 +1278,1 @@\n-  return patch_load_const_32to64(pos, no);\n+  return patch_load_const_32to64(pos, CompressedOops::narrow_oop_value(no));\n@@ -1296,1 +1296,1 @@\n-  return patch_compare_immediate_32(pos, no);\n+  return patch_compare_immediate_32(pos, CompressedOops::narrow_oop_value(no));\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -55,2 +55,7 @@\n-    if (verify_only) {\n-      guarantee(*(uint32_t*) disp == CompressedOops::encode((oop)x), \"instructions must match\");\n+      narrowOop narrow_oop = CompressedOops::encode((oop)x);\n+      uint32_t encoded = CompressedOops::narrow_oop_value(narrow_oop);\n+      if (verify_only) {\n+        guarantee(*(uint32_t*) disp == encoded, \"instructions must match\");\n+      } else {\n+        *(int32_t*) disp = encoded;\n+      }\n@@ -58,3 +63,0 @@\n-      *(int32_t*) disp = CompressedOops::encode((oop)x);\n-    }\n-  } else {\n","filename":"src\/hotspot\/cpu\/x86\/relocInfo_x86.cpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-  narrowOop v = (narrowOop)offset;\n+  narrowOop v = CompressedOops::narrow_oop_cast(offset);\n@@ -753,1 +753,1 @@\n-    _writer->add(hash, CompressedOops::encode(new_s));\n+    _writer->add(hash, CompressedOops::narrow_oop_value(CompressedOops::encode(new_s)));\n","filename":"src\/hotspot\/share\/classfile\/stringTable.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,1 +73,1 @@\n-    narrowOop narrow_oop = (narrowOop)(uintptr_t)addr;\n+    narrowOop narrow_oop = CompressedOops::narrow_oop_cast((uintptr_t)addr);\n@@ -77,1 +77,2 @@\n-      st->print(UINT32_FORMAT \" is a compressed pointer to object: \", narrow_oop);\n+      st->print(UINT32_FORMAT \" is a compressed pointer to object: \",\n+                CompressedOops::narrow_oop_value(narrow_oop));\n","filename":"src\/hotspot\/share\/gc\/shared\/locationPrinter.inline.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n-  DiscoveredList() : _oop_head(NULL), _compressed_head(0), _len(0) { }\n+  DiscoveredList() : _oop_head(NULL), _compressed_head(narrowOop::null), _len(0) { }\n","filename":"src\/hotspot\/share\/gc\/shared\/referenceProcessor.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -152,1 +152,1 @@\n-  return CompressedOops::decode((narrowOop) Atomic::cmpxchg(addr, c, val));\n+  return CompressedOops::decode(Atomic::cmpxchg(addr, c, val));\n@@ -159,1 +159,1 @@\n-  return CompressedOops::decode((narrowOop) Atomic::cmpxchg(addr, cmp, val));\n+  return CompressedOops::decode(Atomic::cmpxchg(addr, cmp, val));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-  if (*ref != 0) {\n+  if (CompressedOops::is_null(*ref)) {\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/rootSetClosure.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -274,2 +274,2 @@\n-  narrowOop o = (narrowOop)nextPtr();\n-  if (o == 0 || !HeapShared::open_archive_heap_region_mapped()) {\n+  narrowOop o = CompressedOops::narrow_oop_cast(nextPtr());\n+  if (CompressedOops::is_null(o) || !HeapShared::open_archive_heap_region_mapped()) {\n","filename":"src\/hotspot\/share\/memory\/archiveUtils.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1666,2 +1666,1 @@\n-  assert(offset == (size_t)(uint32_t)offset, \"must be 32-bit only\");\n-  uint n = (uint)offset;\n+  narrowOop n = CompressedOops::narrow_oop_cast(offset);\n","filename":"src\/hotspot\/share\/memory\/filemap.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -385,1 +385,1 @@\n-  _subgraph_entry_fields->append(CompressedOops::encode(v));\n+  _subgraph_entry_fields->append(CompressedOops::narrow_oop_value(CompressedOops::encode(v)));\n@@ -593,1 +593,1 @@\n-        narrowOop nv = entry_field_records->at(i+1);\n+        narrowOop nv = CompressedOops::narrow_oop_cast(entry_field_records->at(i+1));\n","filename":"src\/hotspot\/share\/memory\/heapShared.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+#include <type_traits>\n@@ -79,0 +80,4 @@\n+  \/\/ The representation type for narrowOop is assumed to be uint32_t.\n+  static_assert(std::is_same<uint32_t, std::underlying_type_t<narrowOop>>::value,\n+                \"narrowOop has unexpected representation type\");\n+\n@@ -115,1 +120,1 @@\n-  static bool is_null(narrowOop v) { return v == 0; }\n+  static bool is_null(narrowOop v) { return v == narrowOop::null; }\n@@ -128,0 +133,12 @@\n+\n+  static uint32_t narrow_oop_value(narrowOop o) {\n+    return static_cast<uint32_t>(o);\n+  }\n+\n+  template<typename T>\n+  static narrowOop narrow_oop_cast(T i) {\n+    static_assert(std::is_integral<T>::value, \"precondition\");\n+    static_assert(sizeof(T) >= sizeof(narrowOop), \"precondition\");\n+    assert(i == static_cast<T>(static_cast<uint32_t>(i)), \"narrowOop overflow\");\n+    return static_cast<narrowOop>(static_cast<uint32_t>(i));\n+  }\n","filename":"src\/hotspot\/share\/oops\/compressedOops.hpp","additions":19,"deletions":2,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,2 +65,1 @@\n-  uint64_t result = pd >> shift();\n-  assert((result & CONST64(0xffffffff00000000)) == 0, \"narrow oop overflow\");\n+  narrowOop result = narrow_oop_cast(pd >> shift());\n@@ -68,1 +67,1 @@\n-  return (narrowOop)result;\n+  return result;\n@@ -72,1 +71,1 @@\n-  return is_null(v) ? (narrowOop)0 : encode_not_null(v);\n+  return is_null(v) ? narrowOop::null : encode_not_null(v);\n","filename":"src\/hotspot\/share\/oops\/compressedOops.inline.hpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -92,1 +92,1 @@\n-  CDS_JAVA_HEAP_ONLY(_archived_references = 0;)\n+  CDS_JAVA_HEAP_ONLY(_archived_references = narrowOop::null;)\n","filename":"src\/hotspot\/share\/oops\/cpCache.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -207,1 +207,1 @@\n-  CDS_JAVA_HEAP_ONLY(_archived_mirror = 0;)\n+  CDS_JAVA_HEAP_ONLY(_archived_mirror = narrowOop::null;)\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -266,1 +266,1 @@\n-  narrowOop archived_java_mirror_raw_narrow() NOT_CDS_JAVA_HEAP_RETURN_(0); \/\/ no GC barrier\n+  narrowOop archived_java_mirror_raw_narrow() NOT_CDS_JAVA_HEAP_RETURN_(narrowOop::null); \/\/ no GC barrier\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -160,1 +160,1 @@\n-    if (narrow_oop == 0) return NULL;\n+    if (CompressedOops::is_null(narrow_oop)) return NULL;\n","filename":"src\/hotspot\/share\/oops\/oop.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,1 +36,2 @@\n-typedef juint narrowOop; \/\/ Offset instead of address for an oop within a java object\n+\/\/ Global offset instead of address for an oop within a java object.\n+enum class narrowOop : uint32_t { null = 0 };\n","filename":"src\/hotspot\/share\/oops\/oopsHierarchy.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -101,2 +101,6 @@\n-        \/\/ saved long to the int that the JVM wants.\n-        value.noop =  (narrowOop) *(julong*) value_addr;\n+        \/\/ saved long to the int that the JVM wants.  We can't just\n+        \/\/ use narrow_oop_cast directly, because we don't know what\n+        \/\/ the high bits of the value might be.\n+        static_assert(sizeof(narrowOop) == sizeof(juint), \"size mismatch\");\n+        juint narrow_value = (juint) *(julong*)value_addr;\n+        value.noop = CompressedOops::narrow_oop_cast(narrow_value);\n","filename":"src\/hotspot\/share\/runtime\/stackValue.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"}]}