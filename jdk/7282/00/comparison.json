{"files":[{"patch":"@@ -1729,6 +1729,0 @@\n-  {\n-    G1DirtyCardQueueSet& dcqs = G1BarrierSet::dirty_card_queue_set();\n-    dcqs.set_process_cards_threshold(concurrent_refine()->yellow_zone());\n-    dcqs.set_max_cards(concurrent_refine()->red_zone());\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-    result = new G1ConcurrentRefineThread(_cr, worker_id);\n+    result = G1ConcurrentRefineThread::create(_cr, worker_id);\n@@ -56,2 +56,3 @@\n-  _cr(NULL),\n-  _threads(NULL),\n+  _cr(nullptr),\n+  _primary_thread(nullptr),\n+  _threads(nullptr),\n@@ -79,8 +80,17 @@\n-  for (uint i = 0; i < num_max_threads; i++) {\n-    if (UseDynamicNumberOfGCThreads && i != 0 \/* Always start first thread. *\/) {\n-      _threads[i] = NULL;\n-    } else {\n-      _threads[i] = create_refinement_thread(i, true);\n-      if (_threads[i] == NULL) {\n-        vm_shutdown_during_initialization(\"Could not allocate refinement threads.\");\n-        return JNI_ENOMEM;\n+  if (num_max_threads > 0) {\n+    auto primary = G1PrimaryConcurrentRefineThread::create(cr);\n+    if (primary == nullptr) {\n+      vm_shutdown_during_initialization(\"Could not allocate primary refinement thread\");\n+      return JNI_ENOMEM;\n+    }\n+    _threads[0] = _primary_thread = primary;\n+\n+    for (uint i = 1; i < num_max_threads; ++i) {\n+      if (UseDynamicNumberOfGCThreads) {\n+        _threads[i] = nullptr;\n+      } else {\n+        _threads[i] = create_refinement_thread(i, true);\n+        if (_threads[i] == nullptr) {\n+          vm_shutdown_during_initialization(\"Could not allocate refinement threads.\");\n+          return JNI_ENOMEM;\n+        }\n@@ -91,4 +101,0 @@\n-  if (num_max_threads > 0) {\n-    G1BarrierSet::dirty_card_queue_set().set_primary_refinement_thread(_threads[0]);\n-  }\n-\n@@ -240,1 +246,12 @@\n-  return _thread_control.initialize(this, max_num_threads());\n+  jint result = _thread_control.initialize(this, max_num_threads());\n+  if (result != JNI_OK) return result;\n+\n+  G1DirtyCardQueueSet& dcqs = G1BarrierSet::dirty_card_queue_set();\n+  dcqs.set_max_cards(red_zone());\n+  if (max_num_threads() > 0) {\n+    G1PrimaryConcurrentRefineThread* primary_thread = _thread_control.primary_thread();\n+    primary_thread->update_notify_threshold(primary_activation_threshold());\n+    dcqs.set_refinement_notification_thread(primary_thread);\n+  }\n+\n+  return JNI_OK;\n@@ -395,8 +412,3 @@\n-    if (max_num_threads() == 0) {\n-      \/\/ Disable dcqs notification when there are no threads to notify.\n-      dcqs.set_process_cards_threshold(G1DirtyCardQueueSet::ProcessCardsThresholdNever);\n-    } else {\n-      \/\/ Worker 0 is the primary; wakeup is via dcqs notification.\n-      STATIC_ASSERT(max_yellow_zone <= INT_MAX);\n-      size_t activate = activation_threshold(0);\n-      dcqs.set_process_cards_threshold(activate);\n+    if (max_num_threads() > 0) {\n+      size_t threshold = primary_activation_threshold();\n+      _thread_control.primary_thread()->update_notify_threshold(threshold);\n@@ -414,1 +426,0 @@\n-  dcqs.notify_if_necessary();\n@@ -441,0 +452,5 @@\n+size_t G1ConcurrentRefine::primary_activation_threshold() const {\n+  assert(max_num_threads() > 0, \"No primary refinement thread\");\n+  return activation_threshold(0);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentRefine.cpp","additions":41,"deletions":25,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"utilities\/debug.hpp\"\n@@ -31,1 +32,0 @@\n-#include \"utilities\/ticks.hpp\"\n@@ -36,1 +36,1 @@\n-class outputStream;\n+class G1PrimaryConcurrentRefineThread;\n@@ -43,1 +43,1 @@\n-\n+  G1PrimaryConcurrentRefineThread* _primary_thread;\n@@ -56,0 +56,6 @@\n+  G1PrimaryConcurrentRefineThread* primary_thread() const {\n+    assert(_num_max_threads > 0, \"precondition\");\n+    assert(_primary_thread != nullptr, \"uninitialized\");\n+    return _primary_thread;\n+  }\n+\n@@ -119,0 +125,4 @@\n+  \/\/ The minimum number of pending cards for activation of the primary\n+  \/\/ refinement thread.\n+  size_t primary_activation_threshold() const;\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentRefine.hpp","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+#include \"runtime\/init.hpp\"\n+#include \"runtime\/safepoint.hpp\"\n@@ -42,2 +44,0 @@\n-  _notifier(new Semaphore(0)),\n-  _should_notify(true),\n@@ -48,1 +48,0 @@\n-  create_and_start();\n@@ -53,42 +52,0 @@\n-  delete _notifier;\n-}\n-\n-void G1ConcurrentRefineThread::wait_for_completed_buffers() {\n-  assert(this == Thread::current(), \"precondition\");\n-  while (Atomic::load_acquire(&_should_notify)) {\n-    _notifier->wait();\n-  }\n-}\n-\n-void G1ConcurrentRefineThread::activate() {\n-  assert(this != Thread::current(), \"precondition\");\n-  \/\/ Notify iff transitioning from needing activation to not.  This helps\n-  \/\/ keep the semaphore count bounded and minimizes the work done by\n-  \/\/ activators when the thread is already active.\n-  if (Atomic::load_acquire(&_should_notify) &&\n-      Atomic::cmpxchg(&_should_notify, true, false)) {\n-    _notifier->signal();\n-  }\n-}\n-\n-bool G1ConcurrentRefineThread::maybe_deactivate(bool more_work) {\n-  assert(this == Thread::current(), \"precondition\");\n-\n-  if (more_work) {\n-    \/\/ Suppress unnecessary notifications.\n-    Atomic::release_store(&_should_notify, false);\n-    return false;\n-  } else if (Atomic::load_acquire(&_should_notify)) {\n-    \/\/ Deactivate if no notifications since enabled (see below).\n-    return true;\n-  } else {\n-    \/\/ Try for more refinement work with notifications enabled, to close\n-    \/\/ race; there could be a plethora of suppressed activation attempts\n-    \/\/ after we found no work but before we enable notifications here\n-    \/\/ (so there could be lots of work for this thread to do), followed\n-    \/\/ by a long time without activation after enabling notifications.\n-    \/\/ But first, clear any pending signals to prevent accumulation.\n-    while (_notifier->trywait()) {}\n-    Atomic::release_store(&_should_notify, true);\n-    return false;\n-  }\n@@ -100,7 +57,1 @@\n-  while (!should_terminate()) {\n-    \/\/ Wait for work\n-    wait_for_completed_buffers();\n-    if (should_terminate()) {\n-      break;\n-    }\n-\n+  while (wait_for_completed_buffers()) {\n@@ -128,2 +79,5 @@\n-        bool more_work = _cr->do_refinement_step(_worker_id, _refinement_stats);\n-        if (maybe_deactivate(more_work)) break;\n+        if (!_cr->do_refinement_step(_worker_id, _refinement_stats)) {\n+          if (maybe_deactivate()) {\n+            break;\n+          }\n+        }\n@@ -154,0 +108,161 @@\n+\n+G1PrimaryConcurrentRefineThread*\n+G1PrimaryConcurrentRefineThread::create(G1ConcurrentRefine* cr) {\n+  G1PrimaryConcurrentRefineThread* crt =\n+    new (std::nothrow) G1PrimaryConcurrentRefineThread(cr);\n+  if (crt != nullptr) {\n+    crt->create_and_start();\n+  }\n+  return crt;\n+}\n+\n+G1PrimaryConcurrentRefineThread::G1PrimaryConcurrentRefineThread(G1ConcurrentRefine* cr) :\n+  G1ConcurrentRefineThread(cr, 0),\n+  _notifier(0),\n+  _threshold(0)\n+{}\n+\n+void G1PrimaryConcurrentRefineThread::stop_service() {\n+  G1DirtyCardQueueSet& dcqs = G1BarrierSet::dirty_card_queue_set();\n+  dcqs.set_refinement_notification_thread(nullptr);\n+  G1ConcurrentRefineThread::stop_service();\n+}\n+\n+\/\/ The primary refinement thread is notified when buffers\/cards are added to\n+\/\/ the dirty card queue.  That can happen in fairly arbitrary contexts.\n+\/\/ This means there may be arbitrary other locks held when notifying.  We\n+\/\/ also don't want to have to take a lock on the fairly common notification\n+\/\/ path, as contention for that lock can significantly impact performance.\n+\/\/\n+\/\/ We use a semaphore to implement waiting and unblocking, to avoid\n+\/\/ lock rank checking issues.  (We could alternatively use an\n+\/\/ arbitrarily low ranked mutex.)  The atomic variable _threshold is\n+\/\/ used to decide when to signal the semaphore.  When its value is\n+\/\/ SIZE_MAX then the thread is running.  Otherwise, the thread should\n+\/\/ be requested to run when notified that the number of cards has\n+\/\/ exceeded the threshold value.\n+\n+bool G1PrimaryConcurrentRefineThread::wait_for_completed_buffers() {\n+  assert(this == Thread::current(), \"precondition\");\n+  _notifier.wait();\n+  assert(Atomic::load(&_threshold) == SIZE_MAX || should_terminate(), \"incorrect state\");\n+  return !should_terminate();\n+}\n+\n+bool G1PrimaryConcurrentRefineThread::maybe_deactivate() {\n+  assert(this == Thread::current(), \"precondition\");\n+  assert(Atomic::load(&_threshold) == SIZE_MAX, \"incorrect state\");\n+  Atomic::store(&_threshold, cr()->primary_activation_threshold());\n+  \/\/ Always deactivate when no refinement work found.  New refinement\n+  \/\/ work may have arrived after we tried, but checking for that would\n+  \/\/ still be racy.  Instead, the next time additional work is made\n+  \/\/ available we'll get reactivated.\n+  return true;\n+}\n+\n+void G1PrimaryConcurrentRefineThread::activate() {\n+  assert(this != Thread::current(), \"precondition\");\n+  \/\/ The thread is running when notifications are disabled, so shouldn't\n+  \/\/ signal is this case.  But there's a race between stop requests and\n+  \/\/ maybe_deactivate, so also signal if stop requested.\n+  size_t threshold = Atomic::load(&_threshold);\n+  if (((threshold != SIZE_MAX) &&\n+       (threshold == Atomic::cmpxchg(&_threshold, threshold, SIZE_MAX))) ||\n+      should_terminate()) {\n+    _notifier.signal();\n+  }\n+}\n+\n+void G1PrimaryConcurrentRefineThread::notify(size_t num_cards) {\n+  \/\/ Only activate if the number of pending cards exceeds the activation\n+  \/\/ threshold.  Notification is disabled when the thread is running, by\n+  \/\/ setting _threshold to SIZE_MAX.  A relaxed load is sufficient; we don't\n+  \/\/ need to be precise about this.\n+  if (num_cards > Atomic::load(&_threshold)) {\n+    \/\/ Discard notifications occurring during a safepoint.  A GC safepoint\n+    \/\/ may dirty some cards (such as during reference processing), possibly\n+    \/\/ leading to notification.  End-of-GC update_notify_threshold activates\n+    \/\/ the primary thread if needed.  Non-GC safepoints are expected to\n+    \/\/ rarely (if ever) dirty cards, so defer activation to a post-safepoint\n+    \/\/ notification.\n+    if (SafepointSynchronize::is_at_safepoint()) {\n+      activate();\n+    }\n+  }\n+}\n+\n+void G1PrimaryConcurrentRefineThread::update_notify_threshold(size_t threshold) {\n+#ifdef ASSERT\n+  if (is_init_completed()) {\n+    assert_at_safepoint();\n+    assert(Thread::current()->is_VM_thread(), \"precondition\");\n+  }\n+#endif \/\/ ASSERT\n+  \/\/ If _threshold is SIZE_MAX then the thread is active and the value\n+  \/\/ of _threshold shouldn't be changed.\n+  if (Atomic::load(&_threshold) != SIZE_MAX) {\n+    Atomic::store(&_threshold, threshold);\n+    if (G1BarrierSet::dirty_card_queue_set().num_cards() > threshold) {\n+      activate();\n+    }\n+  }\n+}\n+\n+class G1SecondaryConcurrentRefineThread final : public G1ConcurrentRefineThread {\n+  Monitor _notifier;\n+  bool _requested_active;\n+\n+  bool wait_for_completed_buffers() override;\n+  bool maybe_deactivate() override;\n+\n+public:\n+  G1SecondaryConcurrentRefineThread(G1ConcurrentRefine* cr, uint worker_id);\n+\n+  void activate() override;\n+};\n+\n+G1SecondaryConcurrentRefineThread::G1SecondaryConcurrentRefineThread(G1ConcurrentRefine* cr,\n+                                                                     uint worker_id) :\n+  G1ConcurrentRefineThread(cr, worker_id),\n+  _notifier(Mutex::nosafepoint, this->name(), true),\n+  _requested_active(false)\n+{\n+  assert(worker_id > 0, \"precondition\");\n+}\n+\n+bool G1SecondaryConcurrentRefineThread::wait_for_completed_buffers() {\n+  assert(this == Thread::current(), \"precondition\");\n+  MonitorLocker ml(&_notifier, Mutex::_no_safepoint_check_flag);\n+  while (!_requested_active && !should_terminate()) {\n+    ml.wait();\n+  }\n+  return !should_terminate();\n+}\n+\n+void G1SecondaryConcurrentRefineThread::activate() {\n+  assert(this != Thread::current(), \"precondition\");\n+  MonitorLocker ml(&_notifier, Mutex::_no_safepoint_check_flag);\n+  if (!_requested_active || should_terminate()) {\n+    _requested_active = true;\n+    ml.notify();\n+  }\n+}\n+\n+bool G1SecondaryConcurrentRefineThread::maybe_deactivate() {\n+  assert(this == Thread::current(), \"precondition\");\n+  MutexLocker ml(&_notifier, Mutex::_no_safepoint_check_flag);\n+  bool requested = _requested_active;\n+  _requested_active = false;\n+  return !requested;            \/\/ Deactivate if not recently requested active.\n+}\n+\n+G1ConcurrentRefineThread*\n+G1ConcurrentRefineThread::create(G1ConcurrentRefine* cr, uint worker_id) {\n+  assert(worker_id > 0, \"precondition\");\n+  G1ConcurrentRefineThread* crt =\n+    new (std::nothrow) G1SecondaryConcurrentRefineThread(cr, worker_id);\n+  if (crt != nullptr) {\n+    crt->create_and_start();\n+  }\n+  return crt;\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentRefineThread.cpp","additions":169,"deletions":54,"binary":false,"changes":223,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,3 @@\n-#include \"utilities\/ticks.hpp\"\n+#include \"memory\/padded.hpp\"\n+#include \"runtime\/semaphore.hpp\"\n+#include \"utilities\/macros.hpp\"\n@@ -48,12 +50,10 @@\n-  \/\/ _notifier and _should_notify form a single-reader \/ multi-writer\n-  \/\/ notification mechanism.  The owning concurrent refinement thread is the\n-  \/\/ single reader. The writers are (other) threads that call activate() on\n-  \/\/ the thread.  The i-th concurrent refinement thread is responsible for\n-  \/\/ activating thread i+1 if the number of buffers in the queue exceeds a\n-  \/\/ threshold for that i+1th thread.  The 0th (primary) thread is activated\n-  \/\/ by threads that add cards to the dirty card queue set when the primary\n-  \/\/ thread's threshold is exceeded.  activate() is also used to wake up the\n-  \/\/ threads during termination, so even the non-primary thread case is\n-  \/\/ multi-writer.\n-  Semaphore* _notifier;\n-  volatile bool _should_notify;\n+  G1ConcurrentRefine* _cr;\n+\n+  NONCOPYABLE(G1ConcurrentRefineThread);\n+\n+protected:\n+  G1ConcurrentRefineThread(G1ConcurrentRefine* cr, uint worker_id);\n+\n+  \/\/ Returns !should_terminate().\n+  \/\/ precondition: this is the current thread.\n+  virtual bool wait_for_completed_buffers() = 0;\n@@ -63,1 +63,2 @@\n-  bool maybe_deactivate(bool more_work);\n+  \/\/ precondition: this is the current thread.\n+  virtual bool maybe_deactivate() = 0;\n@@ -65,3 +66,1 @@\n-  G1ConcurrentRefine* _cr;\n-\n-  void wait_for_completed_buffers();\n+  G1ConcurrentRefine* cr() const { return _cr; }\n@@ -69,2 +68,2 @@\n-  virtual void run_service();\n-  virtual void stop_service();\n+  void run_service() override;\n+  void stop_service() override;\n@@ -73,1 +72,1 @@\n-  G1ConcurrentRefineThread(G1ConcurrentRefine* cg1r, uint worker_id);\n+  static G1ConcurrentRefineThread* create(G1ConcurrentRefine* cr, uint worker_id);\n@@ -77,1 +76,2 @@\n-  void activate();\n+  \/\/ precondition: this is not the current thread.\n+  virtual void activate() = 0;\n@@ -87,0 +87,26 @@\n+\/\/ Singleton special refinement thread, registered with the dirty card queue.\n+\/\/ This thread supports notification of increases to the number of cards in\n+\/\/ the dirty card queue, which may trigger activation of this thread when it\n+\/\/ is not already running.\n+class G1PrimaryConcurrentRefineThread final : public G1ConcurrentRefineThread {\n+  Semaphore _notifier;\n+  DEFINE_PAD_MINUS_SIZE(0, DEFAULT_CACHE_LINE_SIZE, 0);\n+  volatile size_t _threshold;\n+  DEFINE_PAD_MINUS_SIZE(1, DEFAULT_CACHE_LINE_SIZE, sizeof(size_t));\n+\n+  bool wait_for_completed_buffers() override;\n+  bool maybe_deactivate() override;\n+\n+  G1PrimaryConcurrentRefineThread(G1ConcurrentRefine* cr);\n+\n+  void stop_service() override;\n+\n+public:\n+  static G1PrimaryConcurrentRefineThread* create(G1ConcurrentRefine* cr);\n+\n+  void activate() override;\n+\n+  void notify(size_t num_cards);\n+  void update_notify_threshold(size_t threshold);\n+};\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentRefineThread.hpp","additions":48,"deletions":22,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-  _primary_refinement_thread(NULL),\n+  _refinement_notification_thread(nullptr),\n@@ -74,1 +74,0 @@\n-  _process_cards_threshold(ProcessCardsThresholdNever),\n@@ -121,0 +120,4 @@\n+size_t G1DirtyCardQueueSet::num_cards() const {\n+  return Atomic::load(&_num_cards);\n+}\n+\n@@ -133,3 +136,2 @@\n-  if ((new_num_cards > process_cards_threshold()) &&\n-      (_primary_refinement_thread != NULL)) {\n-    _primary_refinement_thread->activate();\n+  if (_refinement_notification_thread != nullptr) {\n+    _refinement_notification_thread->notify(new_num_cards);\n@@ -326,7 +328,0 @@\n-void G1DirtyCardQueueSet::notify_if_necessary() {\n-  if ((_primary_refinement_thread != NULL) &&\n-      (num_cards() > process_cards_threshold())) {\n-    _primary_refinement_thread->activate();\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1DirtyCardQueue.cpp","additions":7,"deletions":12,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-class G1ConcurrentRefineThread;\n+class G1PrimaryConcurrentRefineThread;\n@@ -159,4 +159,4 @@\n-  \/\/ The primary refinement thread, for activation when the processing\n-  \/\/ threshold is reached.  NULL if there aren't any refinement threads.\n-  G1ConcurrentRefineThread* _primary_refinement_thread;\n-  DEFINE_PAD_MINUS_SIZE(1, DEFAULT_CACHE_LINE_SIZE, sizeof(G1ConcurrentRefineThread*));\n+  \/\/ The refinement notification thread, for activation when the notification\n+  \/\/ threshold is reached.  nullptr if there aren't any refinement threads.\n+  G1PrimaryConcurrentRefineThread* _refinement_notification_thread;\n+  DEFINE_PAD_MINUS_SIZE(1, DEFAULT_CACHE_LINE_SIZE, sizeof(G1PrimaryConcurrentRefineThread*));\n@@ -177,3 +177,0 @@\n-  \/\/ Activation threshold for the primary refinement thread.\n-  size_t _process_cards_threshold;\n-\n@@ -245,4 +242,0 @@\n-  void set_primary_refinement_thread(G1ConcurrentRefineThread* thread) {\n-    _primary_refinement_thread = thread;\n-  }\n-\n@@ -257,1 +250,1 @@\n-  \/\/ Upper bound on the number of cards currently in in this queue set.\n+  \/\/ Upper bound on the number of cards currently in this queue set.\n@@ -260,1 +253,1 @@\n-  size_t num_cards() const { return _num_cards; }\n+  size_t num_cards() const;\n@@ -262,5 +255,4 @@\n-  \/\/ Get\/Set the number of cards that triggers log processing.\n-  \/\/ Log processing should be done when the number of cards exceeds the\n-  \/\/ threshold.\n-  void set_process_cards_threshold(size_t sz) {\n-    _process_cards_threshold = sz;\n+  \/\/ Record the primary concurrent refinement thread.  This is the thread to\n+  \/\/ be notified when num_cards() exceeds the refinement notification threshold.\n+  void set_refinement_notification_thread(G1PrimaryConcurrentRefineThread* thread) {\n+    _refinement_notification_thread = thread;\n@@ -268,7 +260,0 @@\n-  size_t process_cards_threshold() const {\n-    return _process_cards_threshold;\n-  }\n-  static const size_t ProcessCardsThresholdNever = SIZE_MAX;\n-\n-  \/\/ Notify the consumer if the number of buffers crossed the threshold\n-  void notify_if_necessary();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1DirtyCardQueue.hpp","additions":11,"deletions":26,"binary":false,"changes":37,"status":"modified"}]}