{"files":[{"patch":"@@ -57,1 +57,1 @@\n- * <p><b>Extension example<\/b>. Here is a sketch of a class\n+ * <p><b>Extension example.<\/b> Here is a sketch of a class\n@@ -63,1 +63,1 @@\n- *   static class CustomTask<V> implements RunnableFuture<V> {...}\n+ *   static class CustomTask<V> implements RunnableFuture<V> { ... }\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/AbstractExecutorService.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n- * class Handler { void handle(); ... }\n+ * class Handler { void handle() { ... } }\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/CopyOnWriteArraySet.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -121,1 +121,1 @@\n- *     Executor e = ...\n+ *     Executor e = ...;\n@@ -138,4 +138,2 @@\n- *     try {\n- *       doWork(i);\n- *       doneSignal.countDown();\n- *     } catch (InterruptedException ex) {} \/\/ return;\n+ *     doWork();\n+ *     doneSignal.countDown();\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/CountDownLatch.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -97,1 +97,3 @@\n- *       thread.join();\n+ *       try {\n+ *         thread.join();\n+ *       } catch (InterruptedException ex) { }\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/CyclicBarrier.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -60,2 +60,2 @@\n- *   DataBuffer initialEmptyBuffer = ... a made-up type\n- *   DataBuffer initialFullBuffer = ...\n+ *   DataBuffer initialEmptyBuffer = ...; \/\/ a made-up type\n+ *   DataBuffer initialFullBuffer = ...;\n@@ -72,1 +72,1 @@\n- *       } catch (InterruptedException ex) { ... handle ... }\n+ *       } catch (InterruptedException ex) { ... handle ...}\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/Exchanger.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -120,1 +120,1 @@\n- *   } catch (InterruptedException ie) {\n+ *   } catch (InterruptedException ex) {\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ExecutorService.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -59,2 +59,2 @@\n- *   ExecutorService executor = ...\n- *   ArchiveSearcher searcher = ...\n+ *   ExecutorService executor = ...;\n+ *   ArchiveSearcher searcher = ...;\n@@ -91,8 +91,8 @@\n-     * Attempts to cancel execution of this task.  This attempt will\n-     * fail if the task has already completed, has already been cancelled,\n-     * or could not be cancelled for some other reason. If successful,\n-     * and this task has not started when {@code cancel} is called,\n-     * this task should never run.  If the task has already started,\n-     * then the {@code mayInterruptIfRunning} parameter determines\n-     * whether the thread executing this task should be interrupted in\n-     * an attempt to stop the task.\n+     * Attempts to cancel execution of this task.  This method has no\n+     * effect if the task is already completed or cancelled, or could\n+     * not be cancelled for some other reason.  Otherwise, if this\n+     * task has not started when {@code cancel} is called, this task\n+     * should never run.  If the task has already started, then the\n+     * {@code mayInterruptIfRunning} parameter determines whether the\n+     * thread executing this task (when known by the implementation)\n+     * is interrupted in an attempt to stop the task.\n@@ -100,3 +100,3 @@\n-     * <p>After this method returns, subsequent calls to {@link #isDone} will\n-     * always return {@code true}.  Subsequent calls to {@link #isCancelled}\n-     * will always return {@code true} if this method returned {@code true}.\n+     * <p>The return value from this method does not necessarily\n+     * indicate whether the task is now cancelled; use {@link\n+     * #isCancelled}.\n@@ -104,3 +104,4 @@\n-     * @param mayInterruptIfRunning {@code true} if the thread executing this\n-     * task should be interrupted; otherwise, in-progress tasks are allowed\n-     * to complete\n+     * @param mayInterruptIfRunning {@code true} if the thread\n+     * executing this task should be interrupted (if the thread is\n+     * known to the implementation); otherwise, in-progress tasks are\n+     * allowed to complete\n@@ -108,2 +109,4 @@\n-     * typically because it has already completed normally;\n-     * {@code true} otherwise\n+     * typically because it has already completed; {@code true}\n+     * otherwise. If two or more threads cause a task to be cancelled,\n+     * then at least one of them returns {@code true}. Implementations\n+     * may provide stronger guarantees.\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/Future.java","additions":21,"deletions":18,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -248,1 +248,1 @@\n- * <p><b>Implementation notes<\/b>: This implementation restricts the\n+ * <p><b>Implementation notes:<\/b> This implementation restricts the\n@@ -922,1 +922,1 @@\n-     * }}<\/pre>\n+     * };}<\/pre>\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/Phaser.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -90,1 +90,1 @@\n- *   static final AtomicLong seq = new AtomicLong(0);\n+ *   static final AtomicLong seq = new AtomicLong();\n@@ -293,1 +293,3 @@\n-                int growth = oldCap < 64 ? oldCap + 2 : oldCap >> 1;\n+                int growth = (oldCap < 64)\n+                    ? (oldCap + 2) \/\/ grow faster if small\n+                    : (oldCap >> 1);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/PriorityBlockingQueue.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n- *   protected Object[] items = ... whatever kinds of items being managed\n+ *   protected Object[] items = ...; \/\/ whatever kinds of items being managed\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/Semaphore.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+import java.util.concurrent.locks.ReentrantLock;\n@@ -178,5 +179,5 @@\n-     * built-in synchronization locks across public methods. Using\n-     * built-in locks works well in the most typical case in which\n-     * only one thread submits items. We extend this idea in\n-     * submission methods by detecting single-ownership to reduce\n-     * producer-consumer synchronization strength.\n+     * locks across public methods, to ensure thread-safety in the\n+     * presence of multiple sources and maintain acquire-release\n+     * ordering around user operations. However, we also track whether\n+     * there is only a single source, and if so streamline some buffer\n+     * operations by avoiding some atomics.\n@@ -237,0 +238,2 @@\n+    \/** Lock for exclusion across multiple sources *\/\n+    final ReentrantLock lock;\n@@ -277,0 +280,1 @@\n+        this.lock = new ReentrantLock();\n@@ -340,0 +344,1 @@\n+        ReentrantLock lock = this.lock;\n@@ -346,1 +351,2 @@\n-        synchronized (this) {\n+        lock.lock();\n+        try {\n@@ -381,0 +387,2 @@\n+        } finally {\n+            lock.unlock();\n@@ -393,1 +401,3 @@\n-        synchronized (this) {\n+        ReentrantLock lock = this.lock;\n+        lock.lock();\n+        try {\n@@ -424,0 +434,2 @@\n+        } finally {\n+            lock.unlock();\n@@ -612,0 +624,1 @@\n+        ReentrantLock lock = this.lock;\n@@ -614,1 +627,2 @@\n-            synchronized (this) {\n+            lock.lock();\n+            try {\n@@ -620,0 +634,2 @@\n+            } finally {\n+                lock.unlock();\n@@ -644,0 +660,1 @@\n+        ReentrantLock lock = this.lock;\n@@ -646,1 +663,2 @@\n-            synchronized (this) {\n+            lock.lock();\n+            try {\n@@ -654,0 +672,2 @@\n+            } finally {\n+                lock.unlock();\n@@ -691,1 +711,3 @@\n-        synchronized (this) {\n+        ReentrantLock lock = this.lock;\n+        lock.lock();\n+        try {\n@@ -703,0 +725,2 @@\n+        } finally {\n+            lock.unlock();\n@@ -713,2 +737,7 @@\n-        synchronized (this) {\n-            return cleanAndCount();\n+        int n;\n+        ReentrantLock lock = this.lock;\n+        lock.lock();\n+        try {\n+            n = cleanAndCount();\n+        } finally {\n+            lock.unlock();\n@@ -716,0 +745,1 @@\n+        return n;\n@@ -745,1 +775,3 @@\n-        synchronized (this) {\n+        ReentrantLock lock = this.lock;\n+        lock.lock();\n+        try {\n@@ -761,0 +793,2 @@\n+        } finally {\n+            lock.unlock();\n@@ -774,0 +808,2 @@\n+        boolean subscribed = false;\n+        ReentrantLock lock = this.lock;\n@@ -775,1 +811,2 @@\n-            synchronized (this) {\n+            lock.lock();\n+            try {\n@@ -786,2 +823,2 @@\n-                    else if (subscriber.equals(b.subscriber))\n-                        return true;\n+                    else if (subscribed = subscriber.equals(b.subscriber))\n+                        break;\n@@ -791,0 +828,2 @@\n+            } finally {\n+                lock.unlock();\n@@ -793,1 +832,1 @@\n-        return false;\n+        return subscribed;\n@@ -806,1 +845,3 @@\n-        synchronized (this) {\n+        ReentrantLock lock = this.lock;\n+        lock.lock();\n+        try {\n@@ -825,0 +866,2 @@\n+        } finally {\n+            lock.unlock();\n@@ -837,1 +880,3 @@\n-        synchronized (this) {\n+        ReentrantLock lock = this.lock;\n+        lock.lock();\n+        try {\n@@ -855,0 +900,2 @@\n+        } finally {\n+            lock.unlock();\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/SubmissionPublisher.java","additions":66,"deletions":19,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -224,2 +224,3 @@\n- * <li>In {@link ThreadPoolExecutor.DiscardPolicy}, a task that\n- * cannot be executed is simply dropped.\n+ * <li>In {@link ThreadPoolExecutor.DiscardPolicy}, a task that cannot\n+ * be executed is simply dropped. This policy is designed only for\n+ * those rare cases in which task completion is never relied upon.\n@@ -230,1 +231,5 @@\n- * causing this to be repeated.)\n+ * causing this to be repeated.) This policy is rarely acceptable.  In\n+ * nearly all cases, you should also cancel the task to cause an\n+ * exception in any component waiting for its completion, and\/or log\n+ * the failure, as illustrated in {@link\n+ * ThreadPoolExecutor.DiscardOldestPolicy} documentation.\n@@ -275,1 +280,1 @@\n- * <p><b>Extension example<\/b>. Most extensions of this class\n+ * <p><b>Extension example.<\/b> Most extensions of this class\n@@ -1152,2 +1157,4 @@\n-     * parameters, the default thread factory and the default rejected\n-     * execution handler.\n+     * parameters, the\n+     * {@linkplain Executors#defaultThreadFactory default thread factory}\n+     * and the {@linkplain ThreadPoolExecutor.AbortPolicy\n+     * default rejected execution handler}.\n@@ -1187,1 +1194,1 @@\n-     * parameters and {@linkplain ThreadPoolExecutor.AbortPolicy\n+     * parameters and the {@linkplain ThreadPoolExecutor.AbortPolicy\n@@ -1223,1 +1230,1 @@\n-     * parameters and\n+     * parameters and the\n@@ -2084,1 +2091,14 @@\n-     * is shut down, in which case the task is discarded.\n+     * is shut down, in which case the task is discarded. This policy is\n+     * rarely useful in cases where other threads may be waiting for\n+     * tasks to terminate, or failures must be recorded. Instead consider\n+     * using a handler of the form:\n+     * <pre> {@code\n+     * new RejectedExecutionHandler() {\n+     *   public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {\n+     *     Runnable dropped = e.getQueue().poll();\n+     *     if (dropped instanceof Future<?>) {\n+     *       ((Future<?>)dropped).cancel(false);\n+     *       \/\/ also consider logging the failure\n+     *     }\n+     *     e.execute(r);  \/\/ retry\n+     * }}}<\/pre>\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ThreadPoolExecutor.java","additions":29,"deletions":9,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-        if (initialValue) {\n+        if (initialValue)\n@@ -73,1 +73,0 @@\n-        }\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/atomic\/AtomicBoolean.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n- *   private static AtomicReferenceFieldUpdater<Node, Node> rightUpdater =\n+ *   private static final AtomicReferenceFieldUpdater<Node, Node> rightUpdater =\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/atomic\/AtomicReferenceFieldUpdater.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -114,0 +114,1 @@\n+            int index = getProbe();\n@@ -117,1 +118,1 @@\n-                || (c = cs[getProbe() & m]) == null\n+                || (c = cs[index & m]) == null\n@@ -123,1 +124,1 @@\n-                doubleAccumulate(x, function, uncontended);\n+                doubleAccumulate(x, function, uncontended, index);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/atomic\/DoubleAccumulator.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -95,0 +95,1 @@\n+            int index = getProbe();\n@@ -97,1 +98,1 @@\n-                (c = cs[getProbe() & m]) == null ||\n+                (c = cs[index & m]) == null ||\n@@ -101,1 +102,1 @@\n-                doubleAccumulate(x, null, uncontended);\n+                doubleAccumulate(x, null, uncontended, index);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/atomic\/DoubleAdder.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -111,0 +111,1 @@\n+            int index = getProbe();\n@@ -114,1 +115,1 @@\n-                || (c = cs[getProbe() & m]) == null\n+                || (c = cs[index & m]) == null\n@@ -118,1 +119,1 @@\n-                longAccumulate(x, function, uncontended);\n+                longAccumulate(x, function, uncontended, index);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/atomic\/LongAccumulator.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -88,0 +88,1 @@\n+            int index = getProbe();\n@@ -90,1 +91,1 @@\n-                (c = cs[getProbe() & m]) == null ||\n+                (c = cs[index & m]) == null ||\n@@ -92,1 +93,1 @@\n-                longAccumulate(x, null, uncontended);\n+                longAccumulate(x, null, uncontended, index);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/atomic\/LongAdder.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -128,1 +128,1 @@\n-            return VALUE.compareAndSet(this, cmp, val);\n+            return VALUE.weakCompareAndSetRelease(this, cmp, val);\n@@ -181,1 +181,1 @@\n-        return BASE.compareAndSet(this, cmp, val);\n+        return BASE.weakCompareAndSetRelease(this, cmp, val);\n@@ -227,0 +227,1 @@\n+     * @param index thread index from getProbe\n@@ -229,3 +230,2 @@\n-                              boolean wasUncontended) {\n-        int h;\n-        if ((h = getProbe()) == 0) {\n+                              boolean wasUncontended, int index) {\n+        if (index == 0) {\n@@ -233,1 +233,1 @@\n-            h = getProbe();\n+            index = getProbe();\n@@ -236,2 +236,1 @@\n-        boolean collide = false;                \/\/ True if last slot nonempty\n-        done: for (;;) {\n+        for (boolean collide = false;;) {       \/\/ True if last slot nonempty\n@@ -240,1 +239,1 @@\n-                if ((c = cs[(n - 1) & h]) == null) {\n+                if ((c = cs[(n - 1) & index]) == null) {\n@@ -248,1 +247,1 @@\n-                                    rs[j = (m - 1) & h] == null) {\n+                                    rs[j = (m - 1) & index] == null) {\n@@ -250,1 +249,1 @@\n-                                    break done;\n+                                    break;\n@@ -279,1 +278,1 @@\n-                h = advanceProbe(h);\n+                index = advanceProbe(index);\n@@ -285,1 +284,1 @@\n-                        rs[h & 1] = new Cell(x);\n+                        rs[index & 1] = new Cell(x);\n@@ -287,1 +286,1 @@\n-                        break done;\n+                        break;\n@@ -296,1 +295,1 @@\n-                break done;\n+                break;\n@@ -313,3 +312,2 @@\n-                                boolean wasUncontended) {\n-        int h;\n-        if ((h = getProbe()) == 0) {\n+                                boolean wasUncontended, int index) {\n+        if (index == 0) {\n@@ -317,1 +315,1 @@\n-            h = getProbe();\n+            index = getProbe();\n@@ -320,2 +318,1 @@\n-        boolean collide = false;                \/\/ True if last slot nonempty\n-        done: for (;;) {\n+        for (boolean collide = false;;) {       \/\/ True if last slot nonempty\n@@ -324,1 +321,1 @@\n-                if ((c = cs[(n - 1) & h]) == null) {\n+                if ((c = cs[(n - 1) & index]) == null) {\n@@ -332,1 +329,1 @@\n-                                    rs[j = (m - 1) & h] == null) {\n+                                    rs[j = (m - 1) & index] == null) {\n@@ -334,1 +331,1 @@\n-                                    break done;\n+                                    break;\n@@ -362,1 +359,1 @@\n-                h = advanceProbe(h);\n+                index = advanceProbe(index);\n@@ -368,1 +365,1 @@\n-                        rs[h & 1] = new Cell(Double.doubleToRawLongBits(x));\n+                        rs[index & 1] = new Cell(Double.doubleToRawLongBits(x));\n@@ -370,1 +367,1 @@\n-                        break done;\n+                        break;\n@@ -378,1 +375,1 @@\n-                break done;\n+                break;\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/atomic\/Striped64.java","additions":25,"deletions":28,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n- *     = new AtomicLong(0);\n+ *     = new AtomicLong(17);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/atomic\/package-info.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -140,1 +140,1 @@\n- * Acquire:\n+ * <em>Acquire:<\/em>\n@@ -146,1 +146,1 @@\n- * Release:\n+ * <em>Release:<\/em>\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/locks\/AbstractQueuedSynchronizer.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -553,1 +553,1 @@\n-     *   ReentrantLock lock = new ReentrantLock();\n+     *   final ReentrantLock lock = new ReentrantLock();\n@@ -583,1 +583,1 @@\n-     *   ReentrantLock lock = new ReentrantLock();\n+     *   final ReentrantLock lock = new ReentrantLock();\n@@ -597,1 +597,1 @@\n-     *   ReentrantLock lock = new ReentrantLock();\n+     *   final ReentrantLock lock = new ReentrantLock();\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/locks\/ReentrantLock.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -131,1 +131,1 @@\n- * <p><b>Sample usages<\/b>. Here is a code sketch showing how to perform\n+ * <p><b>Sample usages.<\/b> Here is a code sketch showing how to perform\n@@ -152,1 +152,1 @@\n- *           data = ...\n+ *           data = ...;\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/locks\/ReentrantReadWriteLock.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -215,2 +215,2 @@\n- *   \/\/ Upgrade read lock to write lock\n- *   void moveIfAtOrigin(double newX, double newY) {\n+ *   \/\/ upgrade read lock to write lock\n+ *   void moveIfAtOrigin2(double newX, double newY) {\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/locks\/StampedLock.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -363,1 +363,0 @@\n-        final String klazz = goodClassName(x);\n","filename":"test\/jdk\/java\/util\/Collection\/IteratorMicroBenchmark.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -87,3 +87,10 @@\n-            testInvokeAll();\n-            testInvokeAny();\n-            testInvokeAny_cancellationInterrupt();\n+            for (int nThreads = 1; nThreads <= 6; ++nThreads) {\n+                \/\/ untimed\n+                testInvokeAll(nThreads, false);\n+                testInvokeAny(nThreads, false);\n+                testInvokeAny_cancellationInterrupt(nThreads, false);\n+                \/\/ timed\n+                testInvokeAll(nThreads, true);\n+                testInvokeAny(nThreads, true);\n+                testInvokeAny_cancellationInterrupt(nThreads, true);\n+            }\n@@ -99,1 +106,1 @@\n-    static void testInvokeAll() throws Throwable {\n+    static void testInvokeAll(int nThreads, boolean timed) throws Throwable {\n@@ -101,2 +108,0 @@\n-        final int nThreads = rnd.nextInt(2, 7);\n-        final boolean timed = rnd.nextBoolean();\n@@ -139,1 +144,1 @@\n-    static void testInvokeAny() throws Throwable {\n+    static void testInvokeAny(int nThreads, boolean timed) throws Throwable {\n@@ -141,2 +146,1 @@\n-        final boolean timed = rnd.nextBoolean();\n-        final ExecutorService pool = Executors.newSingleThreadExecutor();\n+        final ExecutorService pool = Executors.newFixedThreadPool(nThreads);\n@@ -148,2 +152,1 @@\n-                check(x <= 2);\n-                if (x == 2) {\n+                if (x > 1) {\n@@ -176,4 +179,0 @@\n-            \/\/ inherent race between main thread interrupt and\n-            \/\/ start of second task\n-            check(count.get() == 1 || count.get() == 2);\n-\n@@ -182,0 +181,4 @@\n+\n+            long c = count.get();\n+            check(c >= 1 && c <= tasks.size());\n+\n@@ -190,1 +193,1 @@\n-    static void testInvokeAny_cancellationInterrupt() throws Throwable {\n+    static void testInvokeAny_cancellationInterrupt(int nThreads, boolean timed) throws Throwable {\n@@ -192,2 +195,0 @@\n-        final int nThreads = rnd.nextInt(2, 7);\n-        final boolean timed = rnd.nextBoolean();\n@@ -200,1 +201,0 @@\n-                allStarted.await();\n@@ -202,0 +202,1 @@\n+                allStarted.await();\n","filename":"test\/jdk\/java\/util\/concurrent\/ExecutorService\/Invoke.java","additions":20,"deletions":19,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -718,1 +718,1 @@\n-                assertSame(a1[i], x);\n+                assertSame(a[i], x);\n","filename":"test\/jdk\/java\/util\/concurrent\/tck\/ArrayBlockingQueueTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -741,1 +741,1 @@\n-                assertSame(a1[i], x);\n+                assertSame(a[i], x);\n","filename":"test\/jdk\/java\/util\/concurrent\/tck\/ArrayDequeTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-                \/\/ ArrayListTest.class,\n+                ArrayListTest.class,\n","filename":"test\/jdk\/java\/util\/concurrent\/tck\/ArrayListTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -443,1 +443,0 @@\n-        Consumer alwaysThrows = e -> { throw new AssertionError(); };\n@@ -664,1 +663,0 @@\n-        final AtomicLong count = new AtomicLong(0L);\n@@ -722,1 +720,0 @@\n-        final AtomicLong count = new AtomicLong(0L);\n","filename":"test\/jdk\/java\/util\/concurrent\/tck\/Collection8Test.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3781,10 +3781,0 @@\n-    \/**\n-     * failedFuture(null) throws NPE\n-     *\/\n-    public void testFailedFuture_null() {\n-        try {\n-            CompletableFuture<Integer> f = CompletableFuture.failedFuture(null);\n-            shouldThrow();\n-        } catch (NullPointerException success) {}\n-    }\n-\n@@ -4220,6 +4210,3 @@\n-                if (parameterTypes[i] == boolean.class)\n-                    args[i] = false;\n-                else if (parameterTypes[i] == int.class)\n-                    args[i] = 0;\n-                else if (parameterTypes[i] == long.class)\n-                    args[i] = 0L;\n+                if      (type == boolean.class) args[i] = false;\n+                else if (type == int.class)     args[i] = 0;\n+                else if (type == long.class)    args[i] = 0L;\n","filename":"test\/jdk\/java\/util\/concurrent\/tck\/CompletableFutureTest.java","additions":3,"deletions":16,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -1013,1 +1013,0 @@\n-        final ThreadLocalRandom rnd = ThreadLocalRandom.current();\n","filename":"test\/jdk\/java\/util\/concurrent\/tck\/ConcurrentLinkedDequeTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-            ExecutorService e = Executors.newCachedThreadPool(null);\n+            ExecutorService unused = Executors.newCachedThreadPool(null);\n@@ -127,1 +127,1 @@\n-            ExecutorService e = Executors.newSingleThreadExecutor(null);\n+            ExecutorService unused = Executors.newSingleThreadExecutor(null);\n@@ -175,1 +175,1 @@\n-            ExecutorService e = Executors.newFixedThreadPool(2, null);\n+            ExecutorService unused = Executors.newFixedThreadPool(2, null);\n@@ -185,1 +185,1 @@\n-            ExecutorService e = Executors.newFixedThreadPool(0);\n+            ExecutorService unused = Executors.newFixedThreadPool(0);\n@@ -207,1 +207,2 @@\n-            ExecutorService e = Executors.unconfigurableExecutorService(null);\n+            ExecutorService unused =\n+                Executors.unconfigurableExecutorService(null);\n@@ -217,1 +218,2 @@\n-            ExecutorService e = Executors.unconfigurableScheduledExecutorService(null);\n+            ExecutorService unused =\n+                Executors.unconfigurableScheduledExecutorService(null);\n@@ -307,1 +309,3 @@\n-        final Runnable sleeper = new CheckedInterruptedRunnable() {\n+        final CountDownLatch done = new CountDownLatch(1);\n+\n+        final Runnable sleeper = new CheckedRunnable() {\n@@ -309,1 +313,1 @@\n-                delay(LONG_DELAY_MS);\n+                done.await(LONG_DELAY_MS, MILLISECONDS);\n@@ -322,0 +326,1 @@\n+        done.countDown();\n@@ -581,1 +586,1 @@\n-            Callable c = Executors.callable((Runnable) null);\n+            Callable unused = Executors.callable((Runnable) null);\n@@ -591,1 +596,1 @@\n-            Callable c = Executors.callable((Runnable) null, one);\n+            Callable unused = Executors.callable((Runnable) null, one);\n@@ -601,1 +606,1 @@\n-            Callable c = Executors.callable((PrivilegedAction) null);\n+            Callable unused = Executors.callable((PrivilegedAction) null);\n@@ -611,1 +616,1 @@\n-            Callable c = Executors.callable((PrivilegedExceptionAction) null);\n+            Callable unused = Executors.callable((PrivilegedExceptionAction) null);\n","filename":"test\/jdk\/java\/util\/concurrent\/tck\/ExecutorsTest.java","additions":17,"deletions":12,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -378,1 +378,1 @@\n-                ForkJoinTask<Integer> f = p.submit(new FibTask(8));\n+                ForkJoinTask<Integer> unused = p.submit(new FibTask(8));\n@@ -566,1 +566,1 @@\n-                Future<?> future = e.submit((Runnable) null);\n+                Future<?> unused = e.submit((Runnable) null);\n@@ -579,1 +579,1 @@\n-                Future<String> future = e.submit((Callable) null);\n+                Future<String> unused = e.submit((Callable) null);\n","filename":"test\/jdk\/java\/util\/concurrent\/tck\/ForkJoinPoolTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1230,1 +1230,1 @@\n-        } finally { future.cancel(true); }\n+        }\n@@ -1232,0 +1232,1 @@\n+        assertFalse(future.isDone());\n","filename":"test\/jdk\/java\/util\/concurrent\/tck\/JSR166TestCase.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -411,1 +411,1 @@\n-                    Integer r = f.join();\n+                    f.join();\n@@ -430,1 +430,1 @@\n-                    Integer r = f.get();\n+                    f.get();\n@@ -451,1 +451,1 @@\n-                    Integer r = f.get(LONG_DELAY_MS, MILLISECONDS);\n+                    f.get(LONG_DELAY_MS, MILLISECONDS);\n@@ -488,1 +488,1 @@\n-                    Integer r = f.invoke();\n+                    f.invoke();\n@@ -508,1 +508,1 @@\n-                    Integer r = f.join();\n+                    f.join();\n@@ -528,1 +528,1 @@\n-                    Integer r = f.get();\n+                    f.get();\n@@ -548,1 +548,1 @@\n-                    Integer r = f.get(LONG_DELAY_MS, MILLISECONDS);\n+                    f.get(LONG_DELAY_MS, MILLISECONDS);\n@@ -692,1 +692,1 @@\n-                    Integer r = f.invoke();\n+                    f.invoke();\n","filename":"test\/jdk\/java\/util\/concurrent\/tck\/RecursiveTaskTest.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -42,0 +42,3 @@\n+import java.util.stream.DoubleStream;\n+import java.util.stream.IntStream;\n+import java.util.stream.LongStream;\n@@ -360,6 +363,6 @@\n-            () -> { java.util.stream.IntStream x = r.ints(-1L); },\n-            () -> { java.util.stream.IntStream x = r.ints(-1L, 2, 3); },\n-            () -> { java.util.stream.LongStream x = r.longs(-1L); },\n-            () -> { java.util.stream.LongStream x = r.longs(-1L, -1L, 1L); },\n-            () -> { java.util.stream.DoubleStream x = r.doubles(-1L); },\n-            () -> { java.util.stream.DoubleStream x = r.doubles(-1L, .5, .6); });\n+            () -> { IntStream unused = r.ints(-1L); },\n+            () -> { IntStream unused = r.ints(-1L, 2, 3); },\n+            () -> { LongStream unused = r.longs(-1L); },\n+            () -> { LongStream unused = r.longs(-1L, -1L, 1L); },\n+            () -> { DoubleStream unused = r.doubles(-1L); },\n+            () -> { DoubleStream unused = r.doubles(-1L, .5, .6); });\n@@ -376,6 +379,6 @@\n-            () -> { java.util.stream.IntStream x = r.ints(2, 1); },\n-            () -> { java.util.stream.IntStream x = r.ints(10, 42, 42); },\n-            () -> { java.util.stream.LongStream x = r.longs(-1L, -1L); },\n-            () -> { java.util.stream.LongStream x = r.longs(10, 1L, -2L); },\n-            () -> { java.util.stream.DoubleStream x = r.doubles(0.0, 0.0); },\n-            () -> { java.util.stream.DoubleStream x = r.doubles(10, .5, .4); });\n+            () -> { IntStream unused = r.ints(2, 1); },\n+            () -> { IntStream unused = r.ints(10, 42, 42); },\n+            () -> { LongStream unused = r.longs(-1L, -1L); },\n+            () -> { LongStream unused = r.longs(10, 1L, -2L); },\n+            () -> { DoubleStream unused = r.doubles(0.0, 0.0); },\n+            () -> { DoubleStream unused = r.doubles(10, .5, .4); });\n","filename":"test\/jdk\/java\/util\/concurrent\/tck\/SplittableRandomTest.java","additions":15,"deletions":12,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -373,1 +373,1 @@\n-        long s = lock.writeLock();\n+        long stamp = lock.writeLock();\n@@ -388,0 +388,2 @@\n+\n+        releaseWriteLock(lock, stamp);\n@@ -395,1 +397,1 @@\n-        long s = lock.readLock();\n+        long stamp = lock.readLock();\n@@ -406,0 +408,2 @@\n+\n+        releaseReadLock(lock, stamp);\n@@ -729,0 +733,1 @@\n+        releaseReadLock(lock, s);\n","filename":"test\/jdk\/java\/util\/concurrent\/tck\/StampedLockTest.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -988,1 +988,1 @@\n-            CompletableFuture<Void> f = p.consume(null);\n+            CompletableFuture<Void> unused = p.consume(null);\n","filename":"test\/jdk\/java\/util\/concurrent\/tck\/SubmissionPublisherTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -467,1 +467,1 @@\n-            Object[] o = q.toArray((Object[])null);\n+            Object[] unused = q.toArray((Object[])null);\n","filename":"test\/jdk\/java\/util\/concurrent\/tck\/SynchronousQueueTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -387,3 +387,0 @@\n-        long firstRand = 0;\n-        ThreadLocalRandom firstThreadLocalRandom = null;\n-\n@@ -394,2 +391,0 @@\n-                \/\/ test bug: the following is not guaranteed and not true in JDK8\n-                \/\/                assertNotSame(current, threadLocalRandom.get());\n@@ -400,4 +395,4 @@\n-        Thread first = newStartedThread(getRandomState);\n-        awaitTermination(first);\n-        firstRand = rand.get();\n-        firstThreadLocalRandom = threadLocalRandom.get();\n+        awaitTermination(newStartedThread(getRandomState));\n+        long firstRand = rand.get();\n+        ThreadLocalRandom firstThreadLocalRandom = threadLocalRandom.get();\n+        assertNotNull(firstThreadLocalRandom);\n@@ -406,2 +401,4 @@\n-            Thread t = newStartedThread(getRandomState);\n-            awaitTermination(t);\n+            awaitTermination(newStartedThread(getRandomState));\n+            if (testImplementationDetails)\n+                \/\/ ThreadLocalRandom has been a singleton since jdk8.\n+                assertSame(firstThreadLocalRandom, threadLocalRandom.get());\n","filename":"test\/jdk\/java\/util\/concurrent\/tck\/ThreadLocalRandomTest.java","additions":8,"deletions":11,"binary":false,"changes":19,"status":"modified"}]}