{"files":[{"patch":"@@ -3726,0 +3726,24 @@\n+void os::Linux::register_large_page_sizes() {\n+  \/\/ We need to scan \/sys\/kernel\/mm\/hugepages\n+  \/\/ to discover the available page sizes\n+  const char* sys_hugepages = \"\/sys\/kernel\/mm\/hugepages\";\n+\n+  DIR *dir = opendir(sys_hugepages);\n+  if (dir == NULL) {\n+    _page_sizes.add(_default_large_page_size);\n+  }\n+\n+  struct dirent *entry;\n+  size_t page_size;\n+  while ((entry = readdir(dir)) != NULL) {\n+    if (entry->d_type == DT_DIR &&\n+        sscanf(entry->d_name, \"hugepages-%zukB\", &page_size) == 1) {\n+      \/\/ The kernel is using kB, hotspot uses bytes\n+      if (page_size * K > (size_t)Linux::page_size()) {\n+          _page_sizes.add(page_size * K);\n+      }\n+    }\n+  }\n+  closedir(dir);\n+}\n+\n@@ -3772,1 +3796,4 @@\n-    _page_sizes.add(_large_page_size);\n+    \/\/ Scan '\/sys\/kernel\/mm\/hugepages' to setup large page sizes\n+    \/\/ using Linux::register_large_page_sizes()\n+    \/\/ put an entry in _page_sizes per large_page_sizes entry\n+    Linux::register_large_page_sizes();\n@@ -3986,1 +4013,1 @@\n-                                        int error) {\n+                                        size_t large_page_sz, int error) {\n@@ -3996,2 +4023,2 @@\n-    jio_snprintf(msg, sizeof(msg), \"Failed to reserve large pages memory req_addr: \"\n-                 PTR_FORMAT \" bytes: \" SIZE_FORMAT \" (errno = %d).\", req_addr, bytes, error);\n+    jio_snprintf(msg, sizeof(msg), \"Failed to reserve memory with large_page_size: \" SIZE_FORMAT \"' req_addr: \"\n+                 PTR_FORMAT \" bytes: \" SIZE_FORMAT \" (errno = %d).\", large_page_sz, req_addr, bytes, error);\n@@ -4005,0 +4032,4 @@\n+  \/\/ Select large_page_size from _page_sizes\n+  \/\/ that is smaller than size_t bytes\n+  size_t large_page_size = os::Linux::select_large_page_size(bytes);\n+\n@@ -4006,2 +4037,2 @@\n-  assert(is_aligned(bytes, os::large_page_size()), \"Unaligned size\");\n-  assert(is_aligned(req_addr, os::large_page_size()), \"Unaligned address\");\n+  assert(is_aligned(bytes, large_page_size), \"Unaligned size\");\n+  assert(is_aligned(req_addr, large_page_size), \"Unaligned address\");\n@@ -4012,2 +4043,2 @@\n-  if (os::large_page_size() != default_large_page_size()) {\n-    flags |= (exact_log2(os::large_page_size()) << MAP_HUGE_SHIFT);\n+  if (large_page_size != default_large_page_size()) {\n+    flags |= (exact_log2(large_page_size) << MAP_HUGE_SHIFT);\n@@ -4018,1 +4049,1 @@\n-    warn_on_large_pages_failure(req_addr, bytes, errno);\n+    warn_on_large_pages_failure(req_addr, bytes, large_page_size, errno);\n@@ -4022,1 +4053,1 @@\n-  assert(is_aligned(addr, os::large_page_size()), \"Must be\");\n+  assert(is_aligned(addr, large_page_size), \"Must be\");\n@@ -4038,1 +4069,4 @@\n-  size_t large_page_size = os::large_page_size();\n+  \/\/ Select large_page_size from _page_sizes\n+  \/\/ that is smaller than size_t bytes\n+  size_t large_page_size = os::Linux::select_large_page_size(bytes);\n+\n@@ -4086,2 +4120,2 @@\n-  if (os::large_page_size() != default_large_page_size()) {\n-    flags |= (exact_log2(os::large_page_size()) << MAP_HUGE_SHIFT);\n+  if (large_page_size != default_large_page_size()) {\n+    flags |= (exact_log2(large_page_size) << MAP_HUGE_SHIFT);\n@@ -4092,1 +4126,1 @@\n-    warn_on_large_pages_failure(lp_start, lp_bytes, errno);\n+    warn_on_large_pages_failure(lp_start, lp_bytes, large_page_size, errno);\n@@ -4123,0 +4157,4 @@\n+  \/\/ Select large_page_size from _page_sizes\n+  \/\/ that is smaller than size_t bytes\n+  size_t large_page_size = os::Linux::select_large_page_size(bytes);\n+\n@@ -4126,2 +4164,2 @@\n-  assert(is_power_of_2(os::large_page_size()), \"Must be\");\n-  assert(bytes >= os::large_page_size(), \"Shouldn't allocate large pages for small sizes\");\n+  assert(is_power_of_2(large_page_size), \"Must be\");\n+  assert(bytes >= large_page_size, \"Shouldn't allocate large pages for small sizes\");\n@@ -4129,1 +4167,1 @@\n-  if (is_aligned(bytes, os::large_page_size()) && alignment <= os::large_page_size()) {\n+  if (is_aligned(bytes, large_page_size) && alignment <= large_page_size) {\n@@ -4183,0 +4221,9 @@\n+size_t os::Linux::select_large_page_size(size_t bytes) {\n+    for (size_t page_size = os::page_sizes().largest(); page_size != 0; page_size = os::page_sizes().next_smaller(page_size)) {\n+      if (page_size <= bytes) {\n+        return page_size;\n+      }\n+    }\n+  return (size_t)Linux::page_size();\n+}\n+\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":64,"deletions":17,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -82,0 +82,1 @@\n+  static void register_large_page_sizes();\n@@ -84,0 +85,1 @@\n+  static size_t select_large_page_size(size_t bytes);\n","filename":"src\/hotspot\/os\/linux\/os_linux.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -190,1 +190,1 @@\n-}\n+}\n\\ No newline at end of file\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestLargePageUseForAuxMemory.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}