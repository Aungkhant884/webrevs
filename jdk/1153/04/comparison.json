{"files":[{"patch":"@@ -2444,1 +2444,1 @@\n-  _page_sizes[0] = 0;\n+  _page_sizes.add(Aix::_page_size);\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2096,1 +2096,1 @@\n-  init_page_sizes((size_t) Bsd::page_size());\n+  _page_sizes.add(Bsd::page_size());\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3726,0 +3726,26 @@\n+void os::Linux::register_large_page_sizes() {\n+  \/\/ We need to scan \/sys\/kernel\/mm\/hugepages\n+  \/\/ to discover the available page sizes\n+  const char* sys_hugepages = \"\/sys\/kernel\/mm\/hugepages\";\n+\n+  DIR *dir = opendir(sys_hugepages);\n+  if (dir == NULL) {\n+    _page_sizes.add(_default_large_page_size);\n+  }\n+\n+  struct dirent *entry;\n+  size_t page_size;\n+  while ((entry = readdir(dir)) != NULL) {\n+    if (entry->d_type == DT_DIR &&\n+        sscanf(entry->d_name, \"hugepages-%zukB\", &page_size) == 1) {\n+      \/\/ The kernel is using kB, hotspot uses bytes\n+      if (page_size * K > (size_t)Linux::page_size()) {\n+        if (!os::page_sizes().is_set(page_size * K)) {\n+          _page_sizes.add(page_size * K);\n+        }\n+      }\n+    }\n+  }\n+  closedir(dir);\n+}\n+\n@@ -3772,3 +3798,4 @@\n-    _page_sizes[0] = _large_page_size;\n-    _page_sizes[1] = default_page_size;\n-    _page_sizes[2] = 0;\n+    \/\/ Scan '\/sys\/kernel\/mm\/hugepages' to setup large page sizes\n+    \/\/ using Linux::register_large_page_sizes()\n+    \/\/ put an entry in _page_sizes per large_page_sizes entry\n+    Linux::register_large_page_sizes();\n@@ -3988,1 +4015,1 @@\n-                                        int error) {\n+                                        size_t large_page_sz, int error) {\n@@ -3998,2 +4025,2 @@\n-    jio_snprintf(msg, sizeof(msg), \"Failed to reserve large pages memory req_addr: \"\n-                 PTR_FORMAT \" bytes: \" SIZE_FORMAT \" (errno = %d).\", req_addr, bytes, error);\n+    jio_snprintf(msg, sizeof(msg), \"Failed to reserve memory with large_page_size: \" SIZE_FORMAT \"' req_addr: \"\n+                 PTR_FORMAT \" bytes: \" SIZE_FORMAT \" (errno = %d).\", large_page_sz, req_addr, bytes, error);\n@@ -4007,0 +4034,4 @@\n+  \/\/ Select large_page_size from _page_sizes\n+  \/\/ that is smaller than size_t bytes\n+  size_t large_page_size = os::Linux::select_large_page_size(bytes);\n+\n@@ -4008,2 +4039,2 @@\n-  assert(is_aligned(bytes, os::large_page_size()), \"Unaligned size\");\n-  assert(is_aligned(req_addr, os::large_page_size()), \"Unaligned address\");\n+  assert(is_aligned(bytes, large_page_size), \"Unaligned size\");\n+  assert(is_aligned(req_addr, large_page_size), \"Unaligned address\");\n@@ -4014,2 +4045,2 @@\n-  if (os::large_page_size() != default_large_page_size()) {\n-    flags |= (exact_log2(os::large_page_size()) << MAP_HUGE_SHIFT);\n+  if (large_page_size != default_large_page_size()) {\n+    flags |= (exact_log2(large_page_size) << MAP_HUGE_SHIFT);\n@@ -4020,1 +4051,1 @@\n-    warn_on_large_pages_failure(req_addr, bytes, errno);\n+    warn_on_large_pages_failure(req_addr, bytes, large_page_size, errno);\n@@ -4024,1 +4055,1 @@\n-  assert(is_aligned(addr, os::large_page_size()), \"Must be\");\n+  assert(is_aligned(addr, large_page_size), \"Must be\");\n@@ -4040,1 +4071,4 @@\n-  size_t large_page_size = os::large_page_size();\n+  \/\/ Select large_page_size from _page_sizes\n+  \/\/ that is smaller than size_t bytes\n+  size_t large_page_size = os::Linux::select_large_page_size(bytes);\n+\n@@ -4088,2 +4122,2 @@\n-  if (os::large_page_size() != default_large_page_size()) {\n-    flags |= (exact_log2(os::large_page_size()) << MAP_HUGE_SHIFT);\n+  if (large_page_size != default_large_page_size()) {\n+    flags |= (exact_log2(large_page_size) << MAP_HUGE_SHIFT);\n@@ -4094,1 +4128,1 @@\n-    warn_on_large_pages_failure(lp_start, lp_bytes, errno);\n+    warn_on_large_pages_failure(lp_start, lp_bytes, large_page_size, errno);\n@@ -4125,0 +4159,4 @@\n+  \/\/ Select large_page_size from _page_sizes\n+  \/\/ that is smaller than size_t bytes\n+  size_t large_page_size = os::Linux::select_large_page_size(bytes);\n+\n@@ -4128,2 +4166,2 @@\n-  assert(is_power_of_2(os::large_page_size()), \"Must be\");\n-  assert(bytes >= os::large_page_size(), \"Shouldn't allocate large pages for small sizes\");\n+  assert(is_power_of_2(large_page_size), \"Must be\");\n+  assert(bytes >= large_page_size, \"Shouldn't allocate large pages for small sizes\");\n@@ -4131,1 +4169,1 @@\n-  if (is_aligned(bytes, os::large_page_size()) && alignment <= os::large_page_size()) {\n+  if (is_aligned(bytes, large_page_size) && alignment <= large_page_size) {\n@@ -4185,0 +4223,9 @@\n+size_t os::Linux::select_large_page_size(size_t bytes) {\n+    for (size_t page_size = os::page_sizes().largest(); page_size != 0; page_size = os::page_sizes().next_smaller(page_size)) {\n+      if (page_size <= bytes) {\n+        return page_size;\n+      }\n+    }\n+  return (size_t)Linux::page_size();\n+}\n+\n@@ -4402,1 +4449,1 @@\n-  init_page_sizes((size_t) Linux::page_size());\n+  _page_sizes.add(Linux::page_size());\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":67,"deletions":20,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -82,0 +82,1 @@\n+  static void register_large_page_sizes();\n@@ -84,0 +85,1 @@\n+  static size_t select_large_page_size(size_t bytes);\n","filename":"src\/hotspot\/os\/linux\/os_linux.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3121,1 +3121,0 @@\n-\n@@ -3124,3 +3123,1 @@\n-    _page_sizes[0] = _large_page_size;\n-    _page_sizes[1] = default_page_size;\n-    _page_sizes[2] = 0;\n+    _page_sizes.add(_large_page_size);\n@@ -4169,1 +4166,1 @@\n-  init_page_sizes((size_t) win32::vm_page_size());\n+  _page_sizes.add(win32::vm_page_size());\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -69,0 +69,1 @@\n+#include \"utilities\/powerOfTwo.hpp\"\n@@ -78,1 +79,1 @@\n-size_t            os::_page_sizes[os::page_sizes_max];\n+os::PagesizeSet   os::_page_sizes;\n@@ -1393,2 +1394,2 @@\n-    for (size_t i = 0; _page_sizes[i] != 0; ++i) {\n-      const size_t page_size = _page_sizes[i];\n+    for (size_t page_size = page_sizes().largest(); page_size != 0;\n+         page_size = page_sizes().next_smaller(page_size)) {\n@@ -1539,13 +1540,0 @@\n-void os::trace_page_sizes(const char* str, const size_t* page_sizes, int count) {\n-  LogTarget(Info, pagesize) log;\n-  if (log.is_enabled()) {\n-    LogStream out(log);\n-\n-    out.print(\"%s: \", str);\n-    for (int i = 0; i < count; ++i) {\n-      out.print(\" \" SIZE_FORMAT, page_sizes[i]);\n-    }\n-    out.cr();\n-  }\n-}\n-\n@@ -1860,0 +1848,70 @@\n+\n+\n+\/\/\/\/\/\/ Implementation of PagesizeSet\n+\n+void os::PagesizeSet::add(size_t pagesize) {\n+  assert(is_power_of_2(pagesize), \"pagesize must be a power of 2: \" INTPTR_FORMAT, pagesize);\n+  _v |= pagesize;\n+}\n+\n+bool os::PagesizeSet::is_set(size_t pagesize) const {\n+  assert(is_power_of_2(pagesize), \"pagesize must be a power of 2: \" INTPTR_FORMAT, pagesize);\n+  return (_v & pagesize) > 0;\n+}\n+\n+size_t os::PagesizeSet::next_smaller(size_t pagesize) const {\n+  assert(is_power_of_2(pagesize), \"pagesize must be a power of 2: \" INTPTR_FORMAT, pagesize);\n+  \/\/ mask out all pages sizes >= pagesize:\n+  uintx v2 = _v & (pagesize - 1);\n+  if (v2 > 0) {\n+    return round_down_power_of_2(v2);\n+  }\n+  return 0;\n+}\n+\n+size_t os::PagesizeSet::next_larger(size_t pagesize) const {\n+  assert(is_power_of_2(pagesize), \"pagesize must be a power of 2: \" INTPTR_FORMAT, pagesize);\n+  if (pagesize == max_power_of_2<uintx>()) { \/\/ Shift by 32\/64 would be UB\n+    return 0;\n+  }\n+  int l = exact_log2(pagesize) + 1;\n+  uintx v2 = _v >> l;\n+  if (v2 == 0) {\n+    return 0;\n+  }\n+  return (size_t)1 << (l + count_trailing_zeros(v2));\n+}\n+\n+size_t os::PagesizeSet::largest() const {\n+  const size_t max = max_power_of_2<uintx>();\n+  if (is_set(max)) {\n+    return max;\n+  }\n+  return next_smaller(max);\n+}\n+\n+size_t os::PagesizeSet::smallest() const {\n+  assert(min_page_size() > 0, \"Sanity\");\n+  return next_larger(min_page_size() \/ 2);\n+}\n+\n+void os::PagesizeSet::print_on(outputStream* st) const {\n+  bool first = true;\n+  for (size_t sz = smallest(); sz != 0; sz = next_larger(sz)) {\n+    if (first) {\n+      first = false;\n+    } else {\n+      st->print_raw(\", \");\n+    }\n+    if (sz < M) {\n+      st->print(SIZE_FORMAT \"k\", sz \/ K);\n+    } else if (sz < G) {\n+      st->print(SIZE_FORMAT \"M\", sz \/ M);\n+    } else {\n+      st->print(SIZE_FORMAT \"G\", sz \/ G);\n+    }\n+  }\n+  if (first) {\n+    st->print(\"empty\");\n+  }\n+}\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":74,"deletions":16,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -103,1 +103,19 @@\n-  enum { page_sizes_max = 9 }; \/\/ Size of _page_sizes array (8 plus a sentinel)\n+\n+  \/\/ A simple value class holding a set of page sizes (similar to sigset_t)\n+  class PagesizeSet {\n+    uintx _v;\n+  public:\n+    PagesizeSet() : _v(0) {}\n+    void add(size_t pagesize);\n+    bool is_set(size_t pagesize) const;\n+    \/\/ Given a page size, return the next smaller page size in this set, or 0.\n+    size_t next_smaller(size_t pagesize) const;\n+    \/\/ Given a page size, return the next larger page size in this set, or 0.\n+    size_t next_larger(size_t pagesize) const;\n+    \/\/ Returns the largest page size in this set, or 0 if set is empty.\n+    size_t largest() const;\n+    \/\/ Returns the smallest page size in this set, or 0 if set is empty.\n+    size_t smallest() const;\n+    \/\/ Prints one line of comma separated, human readable page sizes, \"empty\" if empty.\n+    void print_on(outputStream* st) const;\n+  };\n@@ -108,8 +126,1 @@\n- public:\n-  static size_t             _page_sizes[page_sizes_max];\n-\n- private:\n-  static void init_page_sizes(size_t default_page_size) {\n-    _page_sizes[0] = default_page_size;\n-    _page_sizes[1] = 0; \/\/ sentinel\n-  }\n+  static PagesizeSet        _page_sizes;\n@@ -277,0 +288,4 @@\n+  \/\/ The set of page sizes which the VM is allowed to use (may be a subset of\n+  \/\/  the page sizes actually available on the platform).\n+  static const PagesizeSet& page_sizes() { return _page_sizes; }\n+\n@@ -288,4 +303,1 @@\n-  static size_t max_page_size() {\n-    \/\/ The _page_sizes array is sorted in descending order.\n-    return _page_sizes[0];\n-  }\n+  static size_t max_page_size() { return page_sizes().largest(); }\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":25,"deletions":13,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -88,4 +88,3 @@\n-    for (size_t i = 0; os::_page_sizes[i] != 0; i++) {\n-      size_t expected = os::_page_sizes[i];\n-      size_t actual = os::page_size_for_region_unaligned(expected, 1);\n-      ASSERT_EQ(expected, actual);\n+    for (size_t s = os::page_sizes().largest(); s != 0; s = os::page_sizes().next_smaller(s)) {\n+      size_t actual = os::page_size_for_region_unaligned(s, 1);\n+      ASSERT_EQ(s, actual);\n@@ -95,4 +94,3 @@\n-    for (size_t i = 0; os::_page_sizes[i] != 0; i++) {\n-      size_t expected = os::_page_sizes[i];\n-      size_t actual = os::page_size_for_region_unaligned(expected + 17, 1);\n-      ASSERT_EQ(expected, actual);\n+    for (size_t s = os::page_sizes().largest(); s != 0; s = os::page_sizes().next_smaller(s)) {\n+      size_t actual = os::page_size_for_region_unaligned(s + 17, 1);\n+      ASSERT_EQ(s, actual);\n@@ -103,4 +101,6 @@\n-    if (os::_page_sizes[1] > os::_page_sizes[0]) {\n-      size_t expected = os::_page_sizes[0];\n-      size_t actual = os::page_size_for_region_unaligned(os::_page_sizes[1] - 17, 1);\n-      ASSERT_EQ(actual, expected);\n+    for (size_t s = os::page_sizes().largest(); s != 0; s = os::page_sizes().next_smaller(s)) {\n+      const size_t expected = os::page_sizes().next_smaller(s);\n+      if (expected != 0) {\n+        size_t actual = os::page_size_for_region_unaligned(expected - 17, 1);\n+        ASSERT_EQ(actual, expected);\n+      }\n@@ -110,1 +110,1 @@\n-    size_t small_page = small_page_size();\n+    size_t small_page = os::page_sizes().smallest();\n@@ -590,0 +590,82 @@\n+\n+TEST_VM(os, pagesizes) {\n+  ASSERT_EQ(os::min_page_size(), 4 * K);\n+  ASSERT_LE(os::min_page_size(), (size_t)os::vm_page_size());\n+  \/\/ The vm_page_size should be the smallest in the set of allowed page sizes\n+  \/\/ (contract says \"default\" page size but a lot of code actually assumes\n+  \/\/  this to be the smallest page size; notable, deliberate exception is\n+  \/\/  AIX which can have smaller page sizes but those are not part of the\n+  \/\/  page_sizes() set).\n+  ASSERT_EQ(os::page_sizes().smallest(), (size_t)os::vm_page_size());\n+  \/\/ The large page size, if it exists, shall be part of the set\n+  if (UseLargePages) {\n+    ASSERT_GT(os::large_page_size(), (size_t)os::vm_page_size());\n+    ASSERT_TRUE(os::page_sizes().is_set(os::large_page_size()));\n+  }\n+  os::page_sizes().print_on(tty);\n+  tty->cr();\n+}\n+\n+static const int min_page_size_log2 = exact_log2(os::min_page_size());\n+static const int max_page_size_log2 = (int)(sizeof(size_t) * 8);\n+\n+TEST_VM(os, pagesizeset_test_range) {\n+  for (int bit = min_page_size_log2; bit < max_page_size_log2; bit ++) {\n+    for (int bit2 = min_page_size_log2; bit2 < max_page_size_log2; bit2 ++) {\n+      const size_t s =  (size_t)1 << bit;\n+      const size_t s2 = (size_t)1 << bit2;\n+      \/\/tty->print_cr(SIZE_FORMAT \" - \" SIZE_FORMAT, s, s2);\n+      os::PagesizeSet pss;\n+      \/\/ Empty set\n+      for (int bit3 = min_page_size_log2; bit3 < max_page_size_log2; bit3 ++) {\n+        const size_t s3 = (size_t)1 << bit3;\n+        ASSERT_FALSE(pss.is_set(s3));\n+      }\n+      ASSERT_EQ((size_t)0, pss.smallest());\n+      ASSERT_EQ((size_t)0, pss.largest());\n+      \/\/ one size set\n+      pss.add(s);\n+      ASSERT_TRUE(pss.is_set(s));\n+      ASSERT_EQ(s, pss.smallest());\n+      ASSERT_EQ(s, pss.largest());\n+      ASSERT_EQ(pss.next_larger(s), (size_t)0);\n+      ASSERT_EQ(pss.next_smaller(s), (size_t)0);\n+      \/\/ two set\n+      pss.add(s2);\n+      ASSERT_TRUE(pss.is_set(s2));\n+      if (s2 < s) {\n+        ASSERT_EQ(s2, pss.smallest());\n+        ASSERT_EQ(s, pss.largest());\n+        ASSERT_EQ(pss.next_larger(s2), (size_t)s);\n+        ASSERT_EQ(pss.next_smaller(s2), (size_t)0);\n+        ASSERT_EQ(pss.next_larger(s), (size_t)0);\n+        ASSERT_EQ(pss.next_smaller(s), (size_t)s2);\n+      } else if (s2 > s) {\n+        ASSERT_EQ(s, pss.smallest());\n+        ASSERT_EQ(s2, pss.largest());\n+        ASSERT_EQ(pss.next_larger(s), (size_t)s2);\n+        ASSERT_EQ(pss.next_smaller(s), (size_t)0);\n+        ASSERT_EQ(pss.next_larger(s2), (size_t)0);\n+        ASSERT_EQ(pss.next_smaller(s2), (size_t)s);\n+      }\n+      for (int bit3 = min_page_size_log2; bit3 < max_page_size_log2; bit3 ++) {\n+        const size_t s3 = (size_t)1 << bit3;\n+        ASSERT_EQ(s3 == s || s3 == s2, pss.is_set(s3));\n+      }\n+    }\n+  }\n+}\n+\n+TEST_VM(os, pagesizeset_print) {\n+  os::PagesizeSet pss;\n+  const size_t sizes[] = { 16 * K, 64 * K, 128 * K, 1 * M, 4 * M, 1 * G, 2 * G, 0 };\n+  static const char* const expected = \"16k, 64k, 128k, 1M, 4M, 1G, 2G\";\n+  for (int i = 0; sizes[i] != 0; i ++) {\n+    pss.add(sizes[i]);\n+  }\n+  char buffer[256];\n+  stringStream ss(buffer, sizeof(buffer));\n+  pss.print_on(&ss);\n+  \/\/ tty->print_cr(\"%s\", buffer);\n+  ASSERT_EQ(strcmp(expected, buffer), 0);\n+}\n","filename":"test\/hotspot\/gtest\/runtime\/test_os.cpp","additions":95,"deletions":13,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -190,1 +190,1 @@\n-}\n+}\n\\ No newline at end of file\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestLargePageUseForAuxMemory.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}