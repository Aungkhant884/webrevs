{"files":[{"patch":"@@ -65,0 +65,1 @@\n+#include \"services\/mallocHeader.inline.hpp\"\n@@ -717,6 +718,4 @@\n-    const size_t old_size = MallocTracker::malloc_header(memblock)->size();\n-\n-    \/\/ De-account the old block from NMT *before* calling the real realloc(3) since it\n-    \/\/ may invalidate old block including its header. This will also perform integrity checks\n-    \/\/ on the old block (e.g. overwriters) and mark the old header as dead.\n-    void* const old_outer_ptr = MemTracker::record_free(memblock);\n+    MallocHeader* header = MallocTracker::malloc_header(memblock);\n+    header->assert_block_integrity(); \/\/ Assert block hasn't been tampered with.\n+    const FreePackage free_package = header->free_package();\n+    header->mark_block_as_dead();\n@@ -725,1 +724,1 @@\n-    ALLOW_C_FUNCTION(::realloc, void* const new_outer_ptr = ::realloc(old_outer_ptr, new_outer_size);)\n+    ALLOW_C_FUNCTION(::realloc, void* const new_outer_ptr = ::realloc((void*)header, new_outer_size);)\n@@ -728,6 +727,4 @@\n-      \/\/ If realloc(3) failed, the old block still exists. We must re-instantiate the old\n-      \/\/ NMT header then, since we marked it dead already. Otherwise subsequent os::realloc()\n-      \/\/ or os::free() calls would trigger block integrity asserts.\n-      void* p = MemTracker::record_malloc(old_outer_ptr, old_size, memflags, stack);\n-      assert(p == memblock, \"sanity\");\n-      return NULL;\n+      \/\/ realloc(3) failed and the block still exists.\n+      \/\/ We have however marked it as dead, revert this change.\n+      header->mark_block_as_alive();\n+      return nullptr;\n@@ -735,0 +732,2 @@\n+    \/\/ realloc(3) succeeded, variable header now points to invalid memory and we need to record the free:ing\n+    MemTracker::record_free(free_package);\n@@ -741,0 +740,1 @@\n+    size_t old_size = free_package.size;\n@@ -777,2 +777,2 @@\n-  \/\/ If NMT is enabled, this checks for heap overwrites, then de-accounts the old block.\n-  void* const old_outer_ptr = MemTracker::record_free(memblock);\n+  \/\/ When NMT is enabled this checks for heap overwrites, then de-accounts the old block.\n+  void* const old_outer_ptr = MemTracker::enabled() ? MemTracker::record_free_block(memblock) : memblock;\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -90,0 +90,7 @@\n+\/\/ Contains all of the necessary data to record a free().\n+struct FreePackage {\n+  const size_t size;\n+  const MEMFLAGS flags;\n+  const uint32_t mst_marker;\n+};\n+\n@@ -118,1 +125,1 @@\n-\n+  MallocHeader(const MallocHeader&) = default;\n@@ -126,0 +133,4 @@\n+  \/\/ Return the necessary data to record the block this belongs to as freed\n+  FreePackage free_package() {\n+    return FreePackage{this->size(), this->flags(), this->mst_marker()};\n+  }\n@@ -127,0 +138,1 @@\n+  inline void mark_block_as_alive();\n","filename":"src\/hotspot\/share\/services\/mallocHeader.hpp","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -47,0 +47,6 @@\n+\n+inline void MallocHeader::mark_block_as_alive() {\n+  _canary = _header_canary_life_mark;\n+  NOT_LP64(_alt_canary = _header_alt_canary_life_mark);\n+  set_footer(_footer_canary_life_mark);\n+}\n","filename":"src\/hotspot\/share\/services\/mallocHeader.inline.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -195,1 +195,1 @@\n-void* MallocTracker::record_free(void* memblock) {\n+void* MallocTracker::record_free_block(void* memblock) {\n@@ -202,4 +202,1 @@\n-  MallocMemorySummary::record_free(header->size(), header->flags());\n-  if (MemTracker::tracking_level() == NMT_detail) {\n-    MallocSiteTable::deallocation_at(header->size(), header->mst_marker());\n-  }\n+  record_free(header->free_package());\n@@ -212,0 +209,7 @@\n+void MallocTracker::record_free(FreePackage free_package) {\n+  MallocMemorySummary::record_free(free_package.size, free_package.flags);\n+  if (MemTracker::tracking_level() == NMT_detail) {\n+    MallocSiteTable::deallocation_at(free_package.size, free_package.mst_marker);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/services\/mallocTracker.cpp","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -294,2 +294,5 @@\n-  \/\/ Record free on specified memory block\n-  static void* record_free(void* memblock);\n+  \/\/ Record free on specified memory block.\n+  \/\/ Returns the outer pointer to this block.\n+  static void* record_free_block(void* memblock);\n+  \/\/ Record a free.\n+  static void record_free(FreePackage free_package);\n","filename":"src\/hotspot\/share\/services\/mallocTracker.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -106,1 +106,1 @@\n-  static inline void* record_free(void* memblock) {\n+  static inline void* record_free_block(void* memblock) {\n@@ -109,4 +109,6 @@\n-    if (!enabled()) {\n-      return memblock;\n-    }\n-    return MallocTracker::record_free(memblock);\n+    assert(enabled(), \"NMT must be enabled\");\n+    return MallocTracker::record_free_block(memblock);\n+  }\n+  static inline void record_free(FreePackage free_package) {\n+    assert(enabled(), \"NMT must be enabled\");\n+    MallocTracker::record_free(free_package);\n","filename":"src\/hotspot\/share\/services\/memTracker.hpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"}]}