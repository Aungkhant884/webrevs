{"files":[{"patch":"@@ -65,0 +65,1 @@\n+#include \"services\/mallocHeader.inline.hpp\"\n@@ -717,6 +718,6 @@\n-    const size_t old_size = MallocTracker::malloc_header(memblock)->size();\n-\n-    \/\/ De-account the old block from NMT *before* calling the real realloc(3) since it\n-    \/\/ may invalidate old block including its header. This will also perform integrity checks\n-    \/\/ on the old block (e.g. overwriters) and mark the old header as dead.\n-    void* const old_outer_ptr = MemTracker::record_free(memblock);\n+    \/\/ Perform integrity checks on and mark the old block as dead *before* calling the real realloc(3) since it\n+    \/\/ may invalidate the old block, including its header.\n+    MallocHeader* header = MallocTracker::malloc_header(memblock);\n+    header->assert_block_integrity(); \/\/ Assert block hasn't been tampered with.\n+    const MallocHeader::FreeInfo free_info = header->free_info();\n+    header->mark_block_as_dead();\n@@ -725,1 +726,1 @@\n-    ALLOW_C_FUNCTION(::realloc, void* const new_outer_ptr = ::realloc(old_outer_ptr, new_outer_size);)\n+    ALLOW_C_FUNCTION(::realloc, void* const new_outer_ptr = ::realloc(header, new_outer_size);)\n@@ -728,6 +729,4 @@\n-      \/\/ If realloc(3) failed, the old block still exists. We must re-instantiate the old\n-      \/\/ NMT header then, since we marked it dead already. Otherwise subsequent os::realloc()\n-      \/\/ or os::free() calls would trigger block integrity asserts.\n-      void* p = MemTracker::record_malloc(old_outer_ptr, old_size, memflags, stack);\n-      assert(p == memblock, \"sanity\");\n-      return NULL;\n+      \/\/ realloc(3) failed and the block still exists.\n+      \/\/ We have however marked it as dead, revert this change.\n+      header->revive();\n+      return nullptr;\n@@ -735,0 +734,2 @@\n+    \/\/ realloc(3) succeeded, variable header now points to invalid memory and we need to deaccount the old block.\n+    MemTracker::deaccount(free_info);\n@@ -736,2 +737,2 @@\n-    \/\/ After a successful realloc(3), we re-account the resized block with its new size\n-    \/\/ to NMT. This re-instantiates the NMT header.\n+    \/\/ After a successful realloc(3), we account the resized block with its new size\n+    \/\/ to NMT.\n@@ -741,0 +742,1 @@\n+    size_t old_size = free_info.size;\n@@ -777,1 +779,1 @@\n-  \/\/ If NMT is enabled, this checks for heap overwrites, then de-accounts the old block.\n+  \/\/ When NMT is enabled this checks for heap overwrites, then deaccounts the old block.\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":18,"deletions":16,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -91,1 +91,1 @@\n-\n+  NONCOPYABLE(MallocHeader);\n@@ -118,0 +118,6 @@\n+  \/\/ Contains all of the necessary data to to deaccount block with NMT.\n+  struct FreeInfo {\n+    const size_t size;\n+    const MEMFLAGS flags;\n+    const uint32_t mst_marker;\n+  };\n@@ -126,0 +132,4 @@\n+  \/\/ Return the necessary data to deaccount the block with NMT.\n+  FreeInfo free_info() {\n+    return FreeInfo{this->size(), this->flags(), this->mst_marker()};\n+  }\n@@ -127,0 +137,1 @@\n+  inline void revive();\n","filename":"src\/hotspot\/share\/services\/mallocHeader.hpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -48,0 +48,10 @@\n+inline void MallocHeader::revive() {\n+  assert(_canary == _header_canary_dead_mark, \"must be dead\");\n+  assert(get_footer() == _footer_canary_dead_mark, \"must be dead\");\n+  NOT_LP64(assert(_alt_canary == _header_alt_canary_dead_mark, \"must be dead\"));\n+  _canary = _header_canary_life_mark;\n+  NOT_LP64(_alt_canary = _header_alt_canary_life_mark);\n+  set_footer(_footer_canary_life_mark);\n+}\n+\n+\/\/ The effects of this method must be reversible with MallocHeader::revive()\n","filename":"src\/hotspot\/share\/services\/mallocHeader.inline.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -195,1 +195,1 @@\n-void* MallocTracker::record_free(void* memblock) {\n+void* MallocTracker::record_free_block(void* memblock) {\n@@ -202,4 +202,1 @@\n-  MallocMemorySummary::record_free(header->size(), header->flags());\n-  if (MemTracker::tracking_level() == NMT_detail) {\n-    MallocSiteTable::deallocation_at(header->size(), header->mst_marker());\n-  }\n+  deaccount(header->free_info());\n@@ -212,0 +209,7 @@\n+void MallocTracker::deaccount(MallocHeader::FreeInfo free_info) {\n+  MallocMemorySummary::record_free(free_info.size, free_info.flags);\n+  if (MemTracker::tracking_level() == NMT_detail) {\n+    MallocSiteTable::deallocation_at(free_info.size, free_info.mst_marker);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/services\/mallocTracker.cpp","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -294,2 +294,5 @@\n-  \/\/ Record free on specified memory block\n-  static void* record_free(void* memblock);\n+  \/\/ Given a block returned by os::malloc() or os::realloc():\n+  \/\/ deaccount block from NMT, mark its header as dead and return pointer to header.\n+  static void* record_free_block(void* memblock);\n+  \/\/ Given the free info from a block, de-account block from NMT.\n+  static void deaccount(MallocHeader::FreeInfo free_info);\n","filename":"src\/hotspot\/share\/services\/mallocTracker.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -112,1 +112,5 @@\n-    return MallocTracker::record_free(memblock);\n+    return MallocTracker::record_free_block(memblock);\n+  }\n+  static inline void deaccount(MallocHeader::FreeInfo free_info) {\n+    assert(enabled(), \"NMT must be enabled\");\n+    MallocTracker::deaccount(free_info);\n","filename":"src\/hotspot\/share\/services\/memTracker.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -144,0 +144,13 @@\n+\n+TEST_VM(NMT, HeaderKeepsIntegrityAfterRevival) {\n+  if (!MemTracker::enabled()) {\n+    return;\n+  }\n+  size_t some_size = 16;\n+  void* p = os::malloc(some_size, mtTest);\n+  ASSERT_NOT_NULL(p) << \"Failed to malloc()\";\n+  MallocHeader* hdr = MallocTracker::malloc_header(p);\n+  hdr->mark_block_as_dead();\n+  hdr->revive();\n+  check_expected_malloc_header(p, mtTest, some_size);\n+}\n","filename":"test\/hotspot\/gtest\/nmt\/test_nmt_cornercases.cpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"}]}