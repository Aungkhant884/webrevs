{"files":[{"patch":"@@ -5541,31 +5541,2 @@\n-instruct vmask_firsttrue_lt8e(iRegINoSp dst, vReg src, rFlagsReg cr) %{\n-  predicate(UseSVE == 0 &&\n-            Matcher::vector_length(n->in(1)) < 8);\n-  match(Set dst (VectorMaskFirstTrue src));\n-  effect(KILL cr);\n-  format %{ \"vmask_firsttrue_lt8e $dst, $src\\t# vector < 8 elements (neon). KILL cr\" %}\n-  ins_encode %{\n-    \/\/ Returns the index of the first active lane of the\n-    \/\/ vector mask, or VLENGTH if no lane is active.\n-    \/\/\n-    \/\/ Input \"src\" is a vector of boolean represented as\n-    \/\/ bytes with 0x00\/0x01 as element values.\n-    \/\/\n-    \/\/ Computed by reversing the bits and counting the leading\n-    \/\/ zero bytes.\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n-    assert(bt == T_BOOLEAN, \"unsupported type\");\n-    __ fmovd($dst$$Register, $src$$FloatRegister);\n-    __ rbit($dst$$Register, $dst$$Register);\n-    __ clz($dst$$Register, $dst$$Register);\n-    __ lsrw($dst$$Register, $dst$$Register, 3);\n-    __ movw(rscratch1, Matcher::vector_length(this, $src));\n-    __ cmpw($dst$$Register, rscratch1);\n-    __ cselw($dst$$Register, rscratch1, $dst$$Register, Assembler::GE);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmask_firsttrue_8or16e(iRegINoSp dst, vReg src) %{\n-  predicate(UseSVE == 0 &&\n-            (Matcher::vector_length(n->in(1)) == 8 || Matcher::vector_length(n->in(1)) == 16));\n+instruct vmask_firsttrue_neon(iRegINoSp dst, vReg src) %{\n+  predicate(UseSVE == 0);\n@@ -5573,1 +5544,1 @@\n-  format %{ \"vmask_firsttrue_8or16e $dst, $src\\t# vector 8B\/16B (neon)\" %}\n+  format %{ \"vmask_firsttrue_neon $dst, $src\" %}\n@@ -5586,2 +5557,2 @@\n-    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $src);\n-    if (length_in_bytes == 8) {\n+    uint vlength = Matcher::vector_length(this, $src);\n+    if (vlength <= 8) {\n@@ -5589,0 +5560,7 @@\n+      if (vlength == 2 || vlength == 4) {\n+        \/\/ Special handling for 2B or 4B cases:\n+        \/\/ Vector mask is moved to a 64-bit general register, but only the low 16\/32 bits are\n+        \/\/ significant for 2B\/4B cases. We initialize the 16th\/32nd bit as bit 1, so as to generate\n+        \/\/ the expected result (i.e. VLENGTH) for the case that all lanes are zero.\n+        __ orr($dst$$Register, $dst$$Register, vlength == 2 ? 0x10000 : 0x100000000);\n+      }\n@@ -5593,1 +5571,1 @@\n-      assert(length_in_bytes == 16, \"must be\");\n+      assert(vlength == 16, \"must be\");\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad","additions":13,"deletions":35,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -3851,31 +3851,2 @@\n-instruct vmask_firsttrue_lt8e(iRegINoSp dst, vReg src, rFlagsReg cr) %{\n-  predicate(UseSVE == 0 &&\n-            Matcher::vector_length(n->in(1)) < 8);\n-  match(Set dst (VectorMaskFirstTrue src));\n-  effect(KILL cr);\n-  format %{ \"vmask_firsttrue_lt8e $dst, $src\\t# vector < 8 elements (neon). KILL cr\" %}\n-  ins_encode %{\n-    \/\/ Returns the index of the first active lane of the\n-    \/\/ vector mask, or VLENGTH if no lane is active.\n-    \/\/\n-    \/\/ Input \"src\" is a vector of boolean represented as\n-    \/\/ bytes with 0x00\/0x01 as element values.\n-    \/\/\n-    \/\/ Computed by reversing the bits and counting the leading\n-    \/\/ zero bytes.\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n-    assert(bt == T_BOOLEAN, \"unsupported type\");\n-    __ fmovd($dst$$Register, $src$$FloatRegister);\n-    __ rbit($dst$$Register, $dst$$Register);\n-    __ clz($dst$$Register, $dst$$Register);\n-    __ lsrw($dst$$Register, $dst$$Register, 3);\n-    __ movw(rscratch1, Matcher::vector_length(this, $src));\n-    __ cmpw($dst$$Register, rscratch1);\n-    __ cselw($dst$$Register, rscratch1, $dst$$Register, Assembler::GE);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmask_firsttrue_8or16e(iRegINoSp dst, vReg src) %{\n-  predicate(UseSVE == 0 &&\n-            (Matcher::vector_length(n->in(1)) == 8 || Matcher::vector_length(n->in(1)) == 16));\n+instruct vmask_firsttrue_neon(iRegINoSp dst, vReg src) %{\n+  predicate(UseSVE == 0);\n@@ -3883,1 +3854,1 @@\n-  format %{ \"vmask_firsttrue_8or16e $dst, $src\\t# vector 8B\/16B (neon)\" %}\n+  format %{ \"vmask_firsttrue_neon $dst, $src\" %}\n@@ -3896,2 +3867,2 @@\n-    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $src);\n-    if (length_in_bytes == 8) {\n+    uint vlength = Matcher::vector_length(this, $src);\n+    if (vlength <= 8) {\n@@ -3899,0 +3870,7 @@\n+      if (vlength == 2 || vlength == 4) {\n+        \/\/ Special handling for 2B or 4B cases:\n+        \/\/ Vector mask is moved to a 64-bit general register, but only the low 16\/32 bits are\n+        \/\/ significant for 2B\/4B cases. We initialize the 16th\/32nd bit as bit 1, so as to generate\n+        \/\/ the expected result (i.e. VLENGTH) for the case that all lanes are zero.\n+        __ orr($dst$$Register, $dst$$Register, vlength == 2 ? 0x10000 : 0x100000000);\n+      }\n@@ -3903,1 +3881,1 @@\n-      assert(length_in_bytes == 16, \"must be\");\n+      assert(vlength == 16, \"must be\");\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4","additions":13,"deletions":35,"binary":false,"changes":48,"status":"modified"}]}