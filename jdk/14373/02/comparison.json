{"files":[{"patch":"@@ -5541,31 +5541,2 @@\n-instruct vmask_firsttrue_lt8e(iRegINoSp dst, vReg src, rFlagsReg cr) %{\n-  predicate(UseSVE == 0 &&\n-            Matcher::vector_length(n->in(1)) < 8);\n-  match(Set dst (VectorMaskFirstTrue src));\n-  effect(KILL cr);\n-  format %{ \"vmask_firsttrue_lt8e $dst, $src\\t# vector < 8 elements (neon). KILL cr\" %}\n-  ins_encode %{\n-    \/\/ Returns the index of the first active lane of the\n-    \/\/ vector mask, or VLENGTH if no lane is active.\n-    \/\/\n-    \/\/ Input \"src\" is a vector of boolean represented as\n-    \/\/ bytes with 0x00\/0x01 as element values.\n-    \/\/\n-    \/\/ Computed by reversing the bits and counting the leading\n-    \/\/ zero bytes.\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n-    assert(bt == T_BOOLEAN, \"unsupported type\");\n-    __ fmovd($dst$$Register, $src$$FloatRegister);\n-    __ rbit($dst$$Register, $dst$$Register);\n-    __ clz($dst$$Register, $dst$$Register);\n-    __ lsrw($dst$$Register, $dst$$Register, 3);\n-    __ movw(rscratch1, Matcher::vector_length(this, $src));\n-    __ cmpw($dst$$Register, rscratch1);\n-    __ cselw($dst$$Register, rscratch1, $dst$$Register, Assembler::GE);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmask_firsttrue_8or16e(iRegINoSp dst, vReg src) %{\n-  predicate(UseSVE == 0 &&\n-            (Matcher::vector_length(n->in(1)) == 8 || Matcher::vector_length(n->in(1)) == 16));\n+instruct vmask_firsttrue_neon(iRegINoSp dst, vReg src) %{\n+  predicate(UseSVE == 0);\n@@ -5573,1 +5544,1 @@\n-  format %{ \"vmask_firsttrue_8or16e $dst, $src\\t# vector 8B\/16B (neon)\" %}\n+  format %{ \"vmask_firsttrue_neon $dst, $src\" %}\n@@ -5586,2 +5557,2 @@\n-    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $src);\n-    if (length_in_bytes == 8) {\n+    uint vlength = Matcher::vector_length(this, $src);\n+    if (vlength <= 8) {\n@@ -5589,0 +5560,7 @@\n+      if (vlength == 2 || vlength == 4) {\n+        \/\/ Special handling for 2B or 4B cases:\n+        \/\/ Vector mask is moved to a 64-bit general register, but only the low 16\/32 bits are\n+        \/\/ significant for 2B\/4B cases. We initialize the 16th\/32nd bit as bit 1, so as to generate\n+        \/\/ the expected result (i.e. VLENGTH) for the case that all lanes are zero.\n+        __ orr($dst$$Register, $dst$$Register, vlength == 2 ? 0x10000 : 0x100000000);\n+      }\n@@ -5593,1 +5571,1 @@\n-      assert(length_in_bytes == 16, \"must be\");\n+      assert(vlength == 16, \"must be\");\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad","additions":13,"deletions":35,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -3851,31 +3851,2 @@\n-instruct vmask_firsttrue_lt8e(iRegINoSp dst, vReg src, rFlagsReg cr) %{\n-  predicate(UseSVE == 0 &&\n-            Matcher::vector_length(n->in(1)) < 8);\n-  match(Set dst (VectorMaskFirstTrue src));\n-  effect(KILL cr);\n-  format %{ \"vmask_firsttrue_lt8e $dst, $src\\t# vector < 8 elements (neon). KILL cr\" %}\n-  ins_encode %{\n-    \/\/ Returns the index of the first active lane of the\n-    \/\/ vector mask, or VLENGTH if no lane is active.\n-    \/\/\n-    \/\/ Input \"src\" is a vector of boolean represented as\n-    \/\/ bytes with 0x00\/0x01 as element values.\n-    \/\/\n-    \/\/ Computed by reversing the bits and counting the leading\n-    \/\/ zero bytes.\n-    BasicType bt = Matcher::vector_element_basic_type(this, $src);\n-    assert(bt == T_BOOLEAN, \"unsupported type\");\n-    __ fmovd($dst$$Register, $src$$FloatRegister);\n-    __ rbit($dst$$Register, $dst$$Register);\n-    __ clz($dst$$Register, $dst$$Register);\n-    __ lsrw($dst$$Register, $dst$$Register, 3);\n-    __ movw(rscratch1, Matcher::vector_length(this, $src));\n-    __ cmpw($dst$$Register, rscratch1);\n-    __ cselw($dst$$Register, rscratch1, $dst$$Register, Assembler::GE);\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n-instruct vmask_firsttrue_8or16e(iRegINoSp dst, vReg src) %{\n-  predicate(UseSVE == 0 &&\n-            (Matcher::vector_length(n->in(1)) == 8 || Matcher::vector_length(n->in(1)) == 16));\n+instruct vmask_firsttrue_neon(iRegINoSp dst, vReg src) %{\n+  predicate(UseSVE == 0);\n@@ -3883,1 +3854,1 @@\n-  format %{ \"vmask_firsttrue_8or16e $dst, $src\\t# vector 8B\/16B (neon)\" %}\n+  format %{ \"vmask_firsttrue_neon $dst, $src\" %}\n@@ -3896,2 +3867,2 @@\n-    uint length_in_bytes = Matcher::vector_length_in_bytes(this, $src);\n-    if (length_in_bytes == 8) {\n+    uint vlength = Matcher::vector_length(this, $src);\n+    if (vlength <= 8) {\n@@ -3899,0 +3870,7 @@\n+      if (vlength == 2 || vlength == 4) {\n+        \/\/ Special handling for 2B or 4B cases:\n+        \/\/ Vector mask is moved to a 64-bit general register, but only the low 16\/32 bits are\n+        \/\/ significant for 2B\/4B cases. We initialize the 16th\/32nd bit as bit 1, so as to generate\n+        \/\/ the expected result (i.e. VLENGTH) for the case that all lanes are zero.\n+        __ orr($dst$$Register, $dst$$Register, vlength == 2 ? 0x10000 : 0x100000000);\n+      }\n@@ -3903,1 +3881,1 @@\n-      assert(length_in_bytes == 16, \"must be\");\n+      assert(vlength == 16, \"must be\");\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4","additions":13,"deletions":35,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-import org.openjdk.jmh.infra.Blackhole;\n@@ -36,3 +35,0 @@\n-    @Param({\"128\",\"256\",\"512\"})\n-    int bits;\n-\n@@ -42,8 +38,5 @@\n-    VectorSpecies<Byte> bspecies;\n-    VectorSpecies<Short> sspecies;\n-    VectorSpecies<Integer> ispecies;\n-    VectorSpecies<Long> lspecies;\n-    VectorMask<Byte> bmask;\n-    VectorMask<Short> smask;\n-    VectorMask<Integer> imask;\n-    VectorMask<Long> lmask;\n+    static final Random RD = new Random();\n+    static final VectorSpecies<Byte> bspecies = ByteVector.SPECIES_PREFERRED;\n+    static final VectorSpecies<Short> sspecies = ShortVector.SPECIES_PREFERRED;\n+    static final VectorSpecies<Integer> ispecies = IntVector.SPECIES_PREFERRED;\n+    static final VectorSpecies<Long> lspecies = LongVector.SPECIES_PREFERRED;\n@@ -51,33 +44,16 @@\n-\n-    static final boolean [] mask_avg_case = {\n-       false, false, false, true, false, false, false, false,\n-       false, false, false, true, false, false, false, false,\n-       false, false, false, true, false, false, false, false,\n-       true, true, true, true, true, true, true, true,\n-       true, true, true, true, true, true, true, true,\n-       false, false, false, true, false, false, false, false,\n-       false, false, false, true, false, false, false, false,\n-       false, false, false, true, false, false, false, false\n-    };\n-\n-    static final boolean [] mask_best_case  = {\n-       true, true, true, true, true, true, true, true,\n-       true, true, true, true, true, true, true, true,\n-       true, true, true, true, true, true, true, true,\n-       true, true, true, true, true, true, true, true,\n-       true, true, true, true, true, true, true, true,\n-       true, true, true, true, true, true, true, true,\n-       true, true, true, true, true, true, true, true,\n-       true, true, true, true, true, true, true, true\n-    };\n-\n-    static final boolean [] mask_worst_case  = {\n-       false, false, false, false, false, false, false, false,\n-       false, false, false, false, false, false, false, false,\n-       false, false, false, false, false, false, false, false,\n-       false, false, false, false, false, false, false, false,\n-       false, false, false, false, false, false, false, false,\n-       false, false, false, false, false, false, false, false,\n-       false, false, false, false, false, false, false, false,\n-       false, false, false, false, false, false, false, false\n-    };\n+    static final int LENGTH = 512;\n+\n+    static final boolean [] mask_avg_case;\n+    static final boolean [] mask_best_case;\n+    static final boolean [] mask_worst_case;\n+    static {\n+        mask_avg_case = new boolean[LENGTH];\n+        mask_best_case = new boolean[LENGTH];\n+        mask_worst_case = new boolean[LENGTH];\n+\n+        for (int i = 0; i < LENGTH; i++) {\n+            mask_best_case[i] = true;\n+            mask_worst_case[i] = false;\n+            mask_avg_case[i] = RD.nextBoolean();\n+        }\n+    }\n@@ -86,7 +62,2 @@\n-    public void BmSetup() {\n-        bspecies = VectorSpecies.of(byte.class, VectorShape.forBitSize(bits));\n-        sspecies = VectorSpecies.of(short.class, VectorShape.forBitSize(bits));\n-        ispecies = VectorSpecies.of(int.class, VectorShape.forBitSize(bits));\n-        lspecies = VectorSpecies.of(long.class, VectorShape.forBitSize(bits));\n-\n-        if( 1 == inputs) {\n+    public void bmSetup() {\n+        if (1 == inputs) {\n@@ -94,1 +65,1 @@\n-        } else if ( 2 == inputs ) {\n+        } else if (2 == inputs) {\n@@ -99,5 +70,0 @@\n-\n-        bmask   = VectorMask.fromArray(bspecies, mask_arr, 0);\n-        smask   = VectorMask.fromArray(sspecies, mask_arr, 0);\n-        imask   = VectorMask.fromArray(ispecies, mask_arr, 0);\n-        lmask   = VectorMask.fromArray(lspecies, mask_arr, 0);\n@@ -107,2 +73,8 @@\n-    public int testTrueCountByte(Blackhole bh) {\n-        return bmask.trueCount();\n+    public int testTrueCountByte() {\n+        int res = 0;\n+        for (int i = 0; i < LENGTH; i += bspecies.length()) {\n+            VectorMask<Byte> m = VectorMask.fromArray(bspecies, mask_arr, i);\n+            res += m.trueCount();\n+        }\n+\n+        return res;\n@@ -112,2 +84,8 @@\n-    public int testTrueCountShort(Blackhole bh) {\n-        return smask.trueCount();\n+    public int testTrueCountShort() {\n+        int res = 0;\n+        for (int i = 0; i < LENGTH; i += sspecies.length()) {\n+            VectorMask<Short> m = VectorMask.fromArray(sspecies, mask_arr, i);\n+            res += m.trueCount();\n+        }\n+\n+        return res;\n@@ -115,0 +93,1 @@\n+\n@@ -116,2 +95,8 @@\n-    public int testTrueCountInt(Blackhole bh) {\n-        return imask.trueCount();\n+    public int testTrueCountInt() {\n+        int res = 0;\n+        for (int i = 0; i < LENGTH; i += ispecies.length()) {\n+            VectorMask<Integer> m = VectorMask.fromArray(ispecies, mask_arr, i);\n+            res += m.trueCount();\n+        }\n+\n+        return res;\n@@ -119,0 +104,1 @@\n+\n@@ -120,2 +106,8 @@\n-    public int testTrueCountLong(Blackhole bh) {\n-        return lmask.trueCount();\n+    public int testTrueCountLong() {\n+        int res = 0;\n+        for (int i = 0; i < LENGTH; i += lspecies.length()) {\n+            VectorMask<Long> m = VectorMask.fromArray(lspecies, mask_arr, i);\n+            res += m.trueCount();\n+        }\n+\n+        return res;\n@@ -125,2 +117,8 @@\n-    public int testFirstTrueByte(Blackhole bh) {\n-        return bmask.firstTrue();\n+    public int testFirstTrueByte() {\n+        int res = 0;\n+        for (int i = 0; i < LENGTH; i += bspecies.length()) {\n+            VectorMask<Byte> m = VectorMask.fromArray(bspecies, mask_arr, i);\n+            res += m.firstTrue();\n+        }\n+\n+        return res;\n@@ -130,2 +128,8 @@\n-    public int testFirstTrueShort(Blackhole bh) {\n-        return smask.firstTrue();\n+    public int testFirstTrueShort() {\n+        int res = 0;\n+        for (int i = 0; i < LENGTH; i += sspecies.length()) {\n+            VectorMask<Short> m = VectorMask.fromArray(sspecies, mask_arr, i);\n+            res += m.firstTrue();\n+        }\n+\n+        return res;\n@@ -133,0 +137,1 @@\n+\n@@ -134,2 +139,8 @@\n-    public int testFirstTrueInt(Blackhole bh) {\n-        return imask.firstTrue();\n+    public int testFirstTrueInt() {\n+        int res = 0;\n+        for (int i = 0; i < LENGTH; i += ispecies.length()) {\n+            VectorMask<Integer> m = VectorMask.fromArray(ispecies, mask_arr, i);\n+            res += m.firstTrue();\n+        }\n+\n+        return res;\n@@ -137,0 +148,1 @@\n+\n@@ -138,2 +150,8 @@\n-    public int testFirstTrueLong(Blackhole bh) {\n-        return lmask.firstTrue();\n+    public int testFirstTrueLong() {\n+        int res = 0;\n+        for (int i = 0; i < LENGTH; i += lspecies.length()) {\n+            VectorMask<Long> m = VectorMask.fromArray(lspecies, mask_arr, i);\n+            res += m.firstTrue();\n+        }\n+\n+        return res;\n@@ -143,2 +161,8 @@\n-    public int testLastTrueByte(Blackhole bh) {\n-        return bmask.lastTrue();\n+    public int testLastTrueByte() {\n+        int res = 0;\n+        for (int i = 0; i < LENGTH; i += bspecies.length()) {\n+            VectorMask<Byte> m = VectorMask.fromArray(bspecies, mask_arr, i);\n+            res += m.lastTrue();\n+        }\n+\n+        return res;\n@@ -148,2 +172,8 @@\n-    public int testLastTrueShort(Blackhole bh) {\n-        return smask.lastTrue();\n+    public int testLastTrueShort() {\n+        int res = 0;\n+        for (int i = 0; i < LENGTH; i += sspecies.length()) {\n+            VectorMask<Short> m = VectorMask.fromArray(sspecies, mask_arr, i);\n+            res += m.lastTrue();\n+        }\n+\n+        return res;\n@@ -151,0 +181,1 @@\n+\n@@ -152,2 +183,8 @@\n-    public int testLastTrueInt(Blackhole bh) {\n-        return imask.lastTrue();\n+    public int testLastTrueInt() {\n+        int res = 0;\n+        for (int i = 0; i < LENGTH; i += ispecies.length()) {\n+            VectorMask<Integer> m = VectorMask.fromArray(ispecies, mask_arr, i);\n+            res += m.lastTrue();\n+        }\n+\n+        return res;\n@@ -155,0 +192,1 @@\n+\n@@ -156,2 +194,8 @@\n-    public int testLastTrueLong(Blackhole bh) {\n-        return lmask.lastTrue();\n+    public int testLastTrueLong() {\n+        int res = 0;\n+        for (int i = 0; i < LENGTH; i += lspecies.length()) {\n+            VectorMask<Long> m = VectorMask.fromArray(lspecies, mask_arr, i);\n+            res += m.lastTrue();\n+        }\n+\n+        return res;\n@@ -161,2 +205,8 @@\n-    public long testToLongByte(Blackhole bh) {\n-        return bmask.toLong();\n+    public long testToLongByte() {\n+        long res = 0;\n+        for (int i = 0; i < LENGTH; i += bspecies.length()) {\n+            VectorMask<Byte> m = VectorMask.fromArray(bspecies, mask_arr, i);\n+            res += m.toLong();\n+        }\n+\n+        return res;\n@@ -166,2 +216,8 @@\n-    public long testToLongShort(Blackhole bh) {\n-        return smask.toLong();\n+    public long testToLongShort() {\n+        long res = 0;\n+        for (int i = 0; i < LENGTH; i += sspecies.length()) {\n+            VectorMask<Short> m = VectorMask.fromArray(sspecies, mask_arr, i);\n+            res += m.toLong();\n+        }\n+\n+        return res;\n@@ -169,0 +225,1 @@\n+\n@@ -170,2 +227,8 @@\n-    public long testToLongInt(Blackhole bh) {\n-        return imask.toLong();\n+    public long testToLongInt() {\n+        long res = 0;\n+        for (int i = 0; i < LENGTH; i += ispecies.length()) {\n+            VectorMask<Integer> m = VectorMask.fromArray(ispecies, mask_arr, i);\n+            res += m.toLong();\n+        }\n+\n+        return res;\n@@ -173,0 +236,1 @@\n+\n@@ -174,3 +238,6 @@\n-    public long testToLongLong(Blackhole bh) {\n-        return lmask.toLong();\n-    }\n+    public long testToLongLong() {\n+        long res = 0;\n+        for (int i = 0; i < LENGTH; i += lspecies.length()) {\n+            VectorMask<Long> m = VectorMask.fromArray(lspecies, mask_arr, i);\n+            res += m.toLong();\n+        }\n@@ -178,0 +245,2 @@\n+        return res;\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/MaskQueryOperationsBenchmark.java","additions":161,"deletions":92,"binary":false,"changes":253,"status":"modified"}]}