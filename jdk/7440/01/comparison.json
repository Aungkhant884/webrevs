{"files":[{"patch":"@@ -2408,1 +2408,0 @@\n-  case VerifyOption_G1UseNextMarking: return is_obj_ill(obj, hr);\n@@ -2419,1 +2418,0 @@\n-  case VerifyOption_G1UseNextMarking: return is_obj_ill(obj);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1239,5 +1239,0 @@\n-  \/\/ This function returns true when an object has been\n-  \/\/ around since the previous marking and hasn't yet\n-  \/\/ been marked during this marking, and is not in a closed archive region.\n-  inline bool is_obj_ill(const oop obj, const HeapRegion* hr) const;\n-\n@@ -1252,2 +1247,0 @@\n-  inline bool is_obj_ill(const oop obj) const;\n-\n@@ -1305,1 +1298,0 @@\n-  \/\/ vo == UseNextMarking -> use \"next\" marking information\n@@ -1311,3 +1303,0 @@\n-  \/\/ Currently, there is only one case where this is called with\n-  \/\/ vo == UseNextMarking, which is to verify the \"next\" marking\n-  \/\/ information at the end of remark.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -227,14 +227,0 @@\n-}\n-\n-inline bool G1CollectedHeap::is_obj_ill(const oop obj, const HeapRegion* hr) const {\n-  return\n-    !hr->obj_allocated_since_next_marking(obj) &&\n-    !is_marked_next(obj) &&\n-    !hr->is_closed_archive();\n-}\n-\n-inline bool G1CollectedHeap::is_obj_ill(const oop obj) const {\n-  if (obj == NULL) {\n-    return false;\n-  }\n-  return is_obj_ill(obj, heap_region_containing(obj));\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.inline.hpp","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -44,1 +44,14 @@\n-  return !_g1h->is_obj_ill(obj);\n+  HeapRegion* hr = _g1h->heap_region_containing(cast_from_oop<HeapWord*>(obj));\n+\n+  \/\/ All objects allocated since the start of marking are considered live.\n+  if (hr->obj_allocated_since_next_marking(obj)) {\n+    return true;\n+  }\n+\n+  \/\/ All objects in closed archive regions are live.\n+  if (hr->is_closed_archive()) {\n+    return true;\n+  }\n+\n+  \/\/ All objects that are marked are live.\n+  return _g1h->is_marked_next(obj);\n@@ -113,1 +126,0 @@\n-  assert(task_entry.is_array_slice() || !_g1h->is_obj_ill(task_entry.obj()), \"invariant\");  \/\/ FIXME!!!\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.inline.hpp","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -56,1 +56,0 @@\n-  \/\/ _vo == UseNextMarking -> use \"next\" marking information,\n@@ -209,1 +208,0 @@\n-  \/\/ _vo == UseNextMarking -> use \"next\" marking information,\n@@ -362,1 +360,0 @@\n-  \/\/ _vo == UseNextMarking -> use \"next\" marking information,\n@@ -410,3 +407,2 @@\n-        if (_vo != VerifyOption_G1UseNextMarking) {\n-          if (r->max_live_bytes() < not_dead_yet_cl.live_bytes()) {\n-            log_error(gc, verify)(\"[\" PTR_FORMAT \",\" PTR_FORMAT \"] max_live_bytes \" SIZE_FORMAT \" < calculated \" SIZE_FORMAT,\n+        if (r->max_live_bytes() < not_dead_yet_cl.live_bytes()) {\n+          log_error(gc, verify)(\"[\" PTR_FORMAT \",\" PTR_FORMAT \"] max_live_bytes \" SIZE_FORMAT \" < calculated \" SIZE_FORMAT,\n@@ -414,6 +410,1 @@\n-            _failures = true;\n-          }\n-        } else {\n-          \/\/ When vo == UseNextMarking we cannot currently do a sanity\n-          \/\/ check on the live bytes as the calculation has not been\n-          \/\/ finalized yet.\n+          _failures = true;\n@@ -438,1 +429,0 @@\n-  \/\/ _vo == UseNextMarking -> use \"next\" marking information,\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapVerifier.cpp","additions":3,"deletions":13,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -64,1 +64,0 @@\n-  \/\/ vo == UseNextMarking -> use \"next\" marking information\n@@ -70,3 +69,0 @@\n-  \/\/ Currently, there is only one case where this is called with\n-  \/\/ vo == UseNextMarking, which is to verify the \"next\" marking\n-  \/\/ information at the end of remark.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapVerifier.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -482,1 +482,0 @@\n-  \/\/ _vo == UseNextMarking -> use \"next\" marking information,\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -585,1 +585,0 @@\n-  \/\/ vo == UseNextMarking -> use \"next\" marking information\n@@ -591,3 +590,0 @@\n-  \/\/ Currently, there is only one case where this is called with\n-  \/\/ vo == UseNextMarking, which is to verify the \"next\" marking\n-  \/\/ information at the end of remark.\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,2 +33,1 @@\n-      VerifyOption_G1UseNextMarking = VerifyOption_G1UsePrevMarking + 1,\n-      VerifyOption_G1UseFullMarking = VerifyOption_G1UseNextMarking + 1\n+      VerifyOption_G1UseFullMarking = VerifyOption_G1UsePrevMarking + 1\n","filename":"src\/hotspot\/share\/gc\/shared\/verifyOption.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"}]}