{"files":[{"patch":"@@ -1488,1 +1488,5 @@\n-C2V_VMENTRY(void, resolveInvokeDynamicInPool, (JNIEnv* env, jobject, ARGUMENT_PAIR(cp), jint index))\n+C2V_VMENTRY_0(int, resolveInvokeDynamicInPool, (JNIEnv* env, jobject, ARGUMENT_PAIR(cp), jint index))\n+  if (!ConstantPool::is_invokedynamic_index(index)) {\n+    JVMCI_THROW_MSG_0(IllegalStateException, err_msg(\"not an invokedynamic index %d\", index));\n+  }\n+\n@@ -1491,2 +1495,4 @@\n-  LinkResolver::resolve_invoke(callInfo, Handle(), cp, index, Bytecodes::_invokedynamic, CHECK);\n-  cp->cache()->set_dynamic_call(callInfo, index); \/\/ Index already decoded\n+  LinkResolver::resolve_invoke(callInfo, Handle(), cp, index, Bytecodes::_invokedynamic, CHECK_0);\n+  int indy_index = cp->decode_invokedynamic_index(index);\n+  cp->cache()->set_dynamic_call(callInfo, indy_index);\n+  return cp->resolved_indy_entry_at(indy_index)->constant_pool_index();\n@@ -2892,1 +2898,1 @@\n-  {CC \"resolveInvokeDynamicInPool\",                   CC \"(\" HS_CONSTANT_POOL2 \"I)V\",                                                       FN_PTR(resolveInvokeDynamicInPool)},\n+  {CC \"resolveInvokeDynamicInPool\",                   CC \"(\" HS_CONSTANT_POOL2 \"I)I\",                                                       FN_PTR(resolveInvokeDynamicInPool)},\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -379,2 +379,2 @@\n-     * The behavior of this method is undefined if {@code cpi} does not denote a\n-     * {@code JVM_CONSTANT_InvokeDynamic} entry.\n+     * @throws IllegalArgumentException if {@code cpi} is not an invokedynamic index\n+     * @return the invokedynamic index\n@@ -382,2 +382,2 @@\n-    void resolveInvokeDynamicInPool(HotSpotConstantPool constantPool, int cpi) {\n-        resolveInvokeDynamicInPool(constantPool, constantPool.getConstantPoolPointer(), cpi);\n+    int resolveInvokeDynamicInPool(HotSpotConstantPool constantPool, int cpi) {\n+        return resolveInvokeDynamicInPool(constantPool, constantPool.getConstantPoolPointer(), cpi);\n@@ -386,1 +386,1 @@\n-    private native void resolveInvokeDynamicInPool(HotSpotConstantPool constantPool, long constantPoolPointer, int cpi);\n+    private native int resolveInvokeDynamicInPool(HotSpotConstantPool constantPool, long constantPoolPointer, int cpi);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/CompilerToVM.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -280,16 +280,0 @@\n-    \/**\n-     * Decode a constant pool cache index to a constant pool index.\n-     *\n-     * See {@code ConstantPool::decode_cpcache_index}.\n-     *\n-     * @param index constant pool cache index\n-     * @return decoded index\n-     *\/\n-    private static int decodeConstantPoolCacheIndex(int index) {\n-        if (isInvokedynamicIndex(index)) {\n-            return decodeInvokedynamicIndex(index);\n-        } else {\n-            return index - config().constantPoolCpCacheIndexTag;\n-        }\n-    }\n-\n@@ -880,3 +864,2 @@\n-                index = decodeConstantPoolCacheIndex(cpi);\n-                if (isInvokedynamicIndex(cpi)) {\n-                    compilerToVM().resolveInvokeDynamicInPool(this, index);\n+                if (!isInvokedynamicIndex(cpi)) {\n+                    throw new IllegalArgumentException(\"must use invokedynamic index but got \" + cpi);\n@@ -884,0 +867,1 @@\n+                index = compilerToVM().resolveInvokeDynamicInPool(this, cpi);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotConstantPool.java","additions":3,"deletions":19,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -197,1 +197,1 @@\n-            Object[] bsmArgs = {recipe};\n+            Object[] bsmArgs = {recipe, condy};\n@@ -319,0 +319,17 @@\n+\n+        testLoadReferencedType(concat);\n+    }\n+\n+    private static int beS4(byte[] data, int bci) {\n+        return (data[bci] << 24) | ((data[bci + 1] & 0xff) << 16) | ((data[bci + 2] & 0xff) << 8) | (data[bci + 3] & 0xff);\n+    }\n+\n+    private static final int LDC2_W = 20;\n+    private static void testLoadReferencedType(ResolvedJavaMethod method) {\n+        \/\/ Make sure that loadReferencedType for an invokedynamic call site works.\n+        byte[] code = method.getCode();\n+        Assert.assertTrue(code[0] == LDC || code[0] == LDC2_W, \"unexpected ldc sequence\");\n+        int bci = code[0] == LDC ? 2 : 3;\n+        Assert.assertTrue((code[bci] & 0xff) == INVOKEDYNAMIC, \"unexpected bytecode\");\n+        int cpi = beS4(code, bci + 1);\n+        method.getConstantPool().loadReferencedType(cpi, INVOKEDYNAMIC, false);\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.hotspot.test\/src\/jdk\/vm\/ci\/hotspot\/test\/TestDynamicConstant.java","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"}]}