{"files":[{"patch":"@@ -1,177 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <string.h>\n-#include \"jvmti.h\"\n-#include \"jvmti_common.h\"\n-#include \"jvmti_thread.h\"\n-\n-extern \"C\" {\n-\n-\/* scaffold objects *\/\n-static jlong timeout = 0;\n-\n-\/* constant names *\/\n-#define THREAD_NAME     \"TestedThread\"\n-#define N_LATE_CALLS    10000\n-\n-\/** Agent algorithm. *\/\n-static void JNICALL\n-agentProc(jvmtiEnv *jvmti, JNIEnv *jni, void *arg) {\n-  jvmtiError err;\n-  \/* Original agentProc test block starts here: *\/\n-  LOG(\"Wait for thread to start\\n\");\n-  \/\/ SP2.1-n - notify agent is waiting and wait\n-  \/\/ SP3.1-w - wait to start test\n-  if (!agent_wait_for_sync(timeout))\n-    return;\n-\n-  \/* perform testing *\/\n-  {\n-    jthread testedThread = NULL;\n-    int late_count;\n-\n-    LOG(\"Find thread: %s\\n\", THREAD_NAME);\n-    testedThread = find_thread_by_name(jvmti, jni, THREAD_NAME);\n-    if (testedThread == NULL) {\n-      return;\n-    }\n-    LOG(\"  ... found thread: %p\\n\", (void *) testedThread);\n-\n-    LOG(\"Suspend thread: %p\\n\", (void *) testedThread);\n-    err = jvmti->SuspendThread(testedThread);\n-    if (err != JVMTI_ERROR_NONE) {\n-      set_agent_fail_status();\n-      return;\n-    }\n-\n-    LOG(\"Let thread to run and finish\\n\");\n-    \/\/ SP5.1-n - notify suspend done\n-    if (!agent_resume_sync())\n-      return;\n-\n-    LOG(\"Get state vector for thread: %p\\n\", (void *) testedThread);\n-    {\n-      jint state = 0;\n-\n-      err = jvmti->GetThreadState(testedThread, &state);\n-      if (err != JVMTI_ERROR_NONE) {\n-        set_agent_fail_status();\n-        return;\n-      }\n-      LOG(\"  ... got state vector: %s (%d)\\n\", TranslateState(state), (int) state);\n-\n-      if ((state & JVMTI_THREAD_STATE_SUSPENDED) == 0) {\n-        LOG(\"SuspendThread() does not turn on flag SUSPENDED:\\n\"\n-            \"#   state: %s (%d)\\n\", TranslateState(state), (int) state);\n-        set_agent_fail_status();\n-      }\n-    }\n-\n-    LOG(\"Resume thread: %p\\n\", (void *) testedThread);\n-    err = jvmti->ResumeThread(testedThread);\n-    if (err != JVMTI_ERROR_NONE) {\n-      set_agent_fail_status();\n-      return;\n-    }\n-    \/* Original agentProc test block ends here. *\/\n-\n-    \/*\n-     * Using LOG() instead of LOG() in this loop\n-     * in order to slow down the rate of SuspendThread() calls.\n-     *\/\n-    for (late_count = 0; late_count < N_LATE_CALLS; late_count++) {\n-      jvmtiError l_err;\n-      LOG(\"INFO: Late suspend thread: %p\\n\", (void *) testedThread);\n-      l_err = jvmti->SuspendThread(testedThread);\n-      if (l_err != JVMTI_ERROR_NONE) {\n-        LOG(\"INFO: Late suspend thread err: %d\\n\", l_err);\n-        \/\/ testedThread has exited so we're done with late calls\n-        break;\n-      }\n-\n-      \/\/ Only resume a thread if suspend worked. Using LOG()\n-      \/\/ here because we want ResumeThread() to be faster.\n-      LOG(\"INFO: Late resume thread: %p\\n\", (void *) testedThread);\n-      err = jvmti->ResumeThread(testedThread);\n-      if (err != JVMTI_ERROR_NONE) {\n-        set_agent_fail_status();\n-        return;\n-      }\n-    }\n-\n-    LOG(\"INFO: made %d late calls to JVM\/TI SuspendThread()\\n\", late_count);\n-    LOG(\"INFO: N_LATE_CALLS == %d value is %slarge enough to cause a \"\n-        \"SuspendThread() call after thread exit.\\n\", N_LATE_CALLS,\n-        (late_count == N_LATE_CALLS) ? \"NOT \" : \"\");\n-\n-    \/* Second part of original agentProc test block starts here: *\/\n-    LOG(\"Wait for thread to finish\\n\");\n-    \/\/ SP4.1-n - notify agent is waiting and wait\n-    \/\/ SP6.1-w - wait to end test\n-    if (!agent_wait_for_sync(timeout))\n-      return;\n-\n-    LOG(\"Delete thread reference\\n\");\n-    jni->DeleteGlobalRef(testedThread);\n-  }\n-\n-  LOG(\"Let debugee to finish\\n\");\n-  \/\/ SP7.1-n - notify agent end\n-  if (!agent_resume_sync())\n-    return;\n-  \/* Second part of original agentProc test block ends here. *\/\n-}\n-\n-JNIEXPORT jint JNICALL\n-Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n-  jvmtiEnv *jvmti = NULL;\n-\n-  timeout = 60 * 1000;\n-\n-  jint res = jvm->GetEnv((void **) &jvmti, JVMTI_VERSION_9);\n-  if (res != JNI_OK || jvmti == NULL) {\n-    LOG(\"Wrong result of a valid call to GetEnv!\\n\");\n-    return JNI_ERR;\n-  }\n-\n-  \/* add specific capabilities for suspending thread *\/\n-  jvmtiCapabilities suspendCaps;\n-  memset(&suspendCaps, 0, sizeof(suspendCaps));\n-  suspendCaps.can_suspend = 1;\n-  if (jvmti->AddCapabilities(&suspendCaps) != JVMTI_ERROR_NONE) {\n-    return JNI_ERR;\n-  }\n-\n-  if (init_agent_data(jvmti, &agent_data) != JVMTI_ERROR_NONE) {\n-    return JNI_ERR;\n-  }\n-  \/* register agent proc and arg *\/\n-  if (!set_agent_proc(agentProc, NULL)) {\n-    return JNI_ERR;\n-  }\n-\n-  return JNI_OK;\n-}\n-\n-}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/SuspendThread\/suspendthrd03\/libsuspendthrd03.cpp","additions":0,"deletions":177,"binary":false,"changes":177,"status":"deleted"},{"patch":"@@ -1,311 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/jvmti\/SuspendThread\/suspendthrd003.\n- * VM Testbase keywords: [jpda, jvmti, noras]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     Same test as suspendthrd001 with additional calls to\n- *     SuspendThread() and ResumeThread() while threads are exiting.\n- *     Failing criteria for the test are:\n- *       - failures of used JVMTI functions.\n- * COMMENTS\n- *     Derived from nsk\/jvmti\/SuspendThread\/suspendthrd001.\n- * Transaction Diagram for this test:\n- * main thread                                      agent thread                                       TestedThread-N\n- * ===============================================  =================================================  =============================================\n- * data->thread_state = NEW\n- * for N = 0; i < N_THREADS; i++ {\n- *   thr = new TestedThread-N\n- *   thr.start()                                                                                       run()\n- *   # SP1-w - wait for TestedThread-N to be ready                                                     :\n- *   thr.checkReady()                                                                                  \/\/ SP1-n - tell main we are ready\n- *   :                                                                                                 threadReady = true\n- *   \/\/ SP2.1-w - wait for agent thread                                                                while (!shouldFinish) {\n- *   \/\/ SP3.1-n - notify to start test                                                                   \/\/ do work\n- *   \/\/ SP5.1-w - wait while testing                                                                     :\n- *   checkStatus(() {                                                                                    :\n- *     enter(data.monitor)                                                                               :\n- *     if data.thread_state == NEW {                                                                     :\n- *       run_agent_thread                                                                        :\n- *       :                                          \/\/ this set is in the agent wrapper:                 :\n- *       :                                          data.thread_state = RUNNABLE                         :\n- *       :                                          agentProc() {                                        :\n- *       :                                            \/\/ SP2.1-n - notify agent is waiting               :\n- *       :                                            \/\/ SP3.1-w - wait to start test                    :\n- *       while (data.thread_state == NEW) {           waitForSync() {                                    :\n- *         \/\/ SP2.2-w - wait for agent thread           enter(data.monitor)                              :\n- *         wait(data.monitor)                           : <blocked>                                      :\n- *         :                                            : <enter>                                        :\n- *         :                                            data.thread_state = WAITING                      :\n- *         :                                            \/\/ SP2.2-n - notify agent is waiting and wait    :\n- *         :                                            notify(data.monitor)                             :\n- *         : <notified>                                 while (data.thread_state == WAITING) {           :\n- *         :                                              \/\/ SP3.2-w - wait to start test                :\n- *         :                                              wait(data.monitor)                             :\n- *         : <reentered>                                  :                                              :\n- *       }                                                :                                              :\n- *       \/\/ saw data.thread_state == WAITING              :                                              :\n- *     }                                                  :                                              :\n- *     \/\/ we don't enter loop in first call               :                                              :\n- *     while (data.thread_state != WAITING                :                                              :\n- *            data.thread_state != TERMINATED) {          :                                              :\n- *       \/\/ SP4.2-w - second wait for agent thread        :                                              :\n- *       wait(data.monitor)                               :                                              :\n- *     }                                                  :                                              :\n- *     if (data.thread_state != TERMINATED) {             :                                              :\n- *       data.thread_state = SUSPENDED                    :                                              :\n- *       \/\/ SP3.2-n - notify to start test                :                                              :\n- *       notify(data.monitor)                             :                                              :\n- *     }                                                  : <notified>                                   :\n- *     while (data.thread_state == SUSPENDED) {           :                                              :\n- *       \/\/ SP5.2-w - wait while testing                  :                                              :\n- *       wait(data.monitor)                               :                                              :\n- *       :                                                : <reentered>                                  :\n- *       :                                              }                                                :\n- *       :                                              \/\/ saw data.thread_state == SUSPENDED            :\n- *       :                                              exit(data.monitor)                               :\n- *       :                                            } \/\/ end waitForSync()                             :\n- *       :                                            SuspendThread(TestedThread-N)                      :\n- *       :                                            \/\/ SP5.1-n - notify suspend done                   : <thread suspended>\n- *       :                                            resumeSync() {                                     :\n- *       :                                              enter(data.monitor)                              :\n- *       :                                              if (data.thread_state == SUSPENDED) {            :\n- *       :                                                data.thread_state = RUNNABLE                   :\n- *       :                                                \/\/ SP5.2-n - notify suspend done               :\n- *       :                                                notify(data.monitor)                           :\n- *       : <notified>                                   }                                                :\n- *       :                                              exit(data.monitor)                               :\n- *       : <re-entered>                               } \/\/ end resumeSync()                              :\n- *     }                                              GetThreadState(TestedThread-N)                     :\n- *     \/\/ saw data.thread_state -= RUNNABLE           ResumeThread(TestedThread-N)                       : <thread resumed>\n- *     :                                              for (1..N_LATE_CALLS) {                            :\n- *   } \/\/ end checkStatus()                             SuspendThread(TestedThread-N)                    :\n- *   :                                                  :                                                : <thread suspended>\n- *   thr.letFinish()                                    ResumeThread(TestedThread-N)                     :\n- *     shouldFinish = true;                             :                                                : <thread resumed>\n- *   thr.join()                                         :                                                : <sees shouldFinish == true>\n- *   :                                                  :                                              }\n- *   :                                                  :                                              : <thread exits>\n- *   : <join() sees thread exit>                        : <SuspendThread sees thread exit & breaks>\n- *   \/\/ SP4.1-w - second wait for agent thread        }\n- *   \/\/ SP6.1-n - notify to end test                  :\n- *   \/\/ SP7.1 - wait for agent end                    :\n- *   checkStatus()                                    \/\/ SP4.1-n - notify agent is waiting and wait\n- *     enter(data.monitor)                            \/\/ SP6.1-w - wait to end test\n- *     :                                              waitForSync()\n- *     \/\/ we don't enter if-stmt in second call         enter(data.monitor)\n- *     if data.thread_state == NEW {                    : <blocked>\n- *     }                                                :\n- *     while (data.thread_state != WAITING              :\n- *            data.thread_state != TERMINATED) {        :\n- *       \/\/ SP4.2-w - second wait for agent thread      :\n- *       wait(data.monitor)                             :\n- *       :                                              : <enter>\n- *       :                                              data.thread_state = WAITING\n- *       :                                              \/\/ SP4.2-n - notify agent is waiting and wait\n- *       :                                              notify(data.monitor)\n- *       : <notified>                                   while (data.thread_state == WAITING) {\n- *       :                                                \/\/ SP6.2-w - wait to end test\n- *       :                                                wait(data.monitor)\n- *       : <reentered>                                    :\n- *     }                                                  :\n- *     \/\/ saw thread_state == WAITING                     :\n- *     if (data.thread_state != TERMINATED) {             :\n- *       data.thread_state = SUSPENDED                    :\n- *       \/\/ SP6.2-n - notify to end test                  :\n- *       notify(data.monitor)                             :\n- *     }                                                  : <notified>\n- *     while (data.thread_state == SUSPENDED) {           :\n- *       \/\/ SP7.2 - wait for agent end                    :\n- *       wait(data.monitor)                               :\n- *       :                                                : <reentered>\n- *       :                                              }\n- *       :                                              \/\/ saw data.thread_state == SUSPENDED\n- *       :                                              exit(data.monitor)\n- *       :                                            } \/\/ end waitForSync()\n- *       :                                            \/\/ SP7.1-n - notify agent end\n- *       :                                            resumeSync() {\n- *       :                                              enter(data.monitor)\n- *       :                                              if (data.thread_state == SUSPENDED) {\n- *       :                                                data.thread_state = RUNNABLE\n- *       :                                                \/\/ SP7.2-n - notify agent end\n- *       :                                                notify(data.monitor)\n- *       : <notified>                                   }\n- *       :                                              exit(data.monitor)\n- *       : <re-entered>                               } \/\/ end resumeSync()\n- *     }                                            } \/\/ end agentProc\n- *     \/\/ saw data.thread_state -= RUNNABLE         \/\/ this set is in the wrapper:\n- *   } \/\/ end checkStatus()                         data.thread_state = TERMINATED\n- *   resetAgentData() {\n- *     enter(data.monitor)\n- *     while (data.thread_state != TERMINATED) {\n- *       wait(data.monitor, 10);\n- *     }\n- *     data.thread_state = NEW\n- *     exit(data.monitor)\n- *   } \/\/ end resetAgentData()\n- *\n- * @library \/test\/lib\n- * @run main\/othervm\/native -Xlog:thread+smr=debug -agentlib:suspendthrd03=-waittime=5 suspendthrd03\n- *\/\n-\n-import jdk.test.lib.jvmti.DebugeeClass;\n-\n-public class suspendthrd03 extends DebugeeClass {\n-\n-    final static int N_THREADS = 10;\n-\n-    \/\/ load native library if required\n-    static {\n-        System.loadLibrary(\"suspendthrd03\");\n-    }\n-\n-    public static void main(String argv[]) {\n-        int result =  new suspendthrd03().runIt();\n-        if (result != 0) {\n-            throw new RuntimeException(\"check failed with result \" + result);\n-        }\n-    }\n-\n-    \/* =================================================================== *\/\n-    long timeout = 0;\n-    int status = DebugeeClass.TEST_PASSED;\n-\n-    \/\/ tested thread\n-    suspendthrd03Thread thread = null;\n-\n-    \/\/ run debuggee\n-    public int runIt() {\n-        timeout = 60 * 1000; \/\/ milliseconds\n-\n-        for (int i = 0; i < N_THREADS; i++) {\n-            System.out.println(\"Starting TestedThread #\" + i + \".\");\n-\n-            \/\/ Original suspendthrd001 test block starts here:\n-            \/\/\n-            \/\/ create tested thread\n-            \/\/ Note: Cannot use TestedThread-N for thread name since\n-            \/\/ the agent has to know the thread's name.\n-            thread = new suspendthrd03Thread(\"TestedThread\");\n-\n-            \/\/ run tested thread\n-            System.out.println(\"Starting tested thread\");\n-            try {\n-                thread.start();\n-                \/\/ SP1-w - wait for TestedThread-N to be ready\n-                if (!thread.checkReady()) {\n-                    throw new RuntimeException(\"Unable to prepare tested thread: \" + thread);\n-                }\n-\n-                \/\/ testing sync\n-                System.out.println(\"Sync: thread started\");\n-                \/\/ SP2.1-w - wait for agent thread\n-                \/\/ SP3.1-n - notify to start test\n-                \/\/ SP5.1-w - wait while testing\n-                status = checkStatus(status);\n-            } finally {\n-                \/\/ let thread to finish\n-                thread.letFinish();\n-            }\n-\n-            \/\/ wait for thread to finish\n-            System.out.println(\"Finishing tested thread\");\n-            try {\n-                thread.join();\n-            } catch (InterruptedException e) {\n-                throw new RuntimeException(e);\n-            }\n-\n-            \/\/ testing sync\n-            System.out.println(\"Sync: thread finished\");\n-            \/\/ SP4.1-w - second wait for agent thread\n-            \/\/ SP6.1-n - notify to end test\n-            \/\/ SP7.1 - wait for agent end\n-            status = checkStatus(status);\n-\n-            \/\/ Original suspendthrd001 test block ends here.\n-\n-            if (status != DebugeeClass.TEST_PASSED) {\n-                break;\n-            }\n-\n-            resetAgentData();  \/\/ reset for another iteration\n-        }\n-\n-        return status;\n-    }\n-}\n-\n-\/* =================================================================== *\/\n-\n-\/\/ basic class for tested threads\n-class suspendthrd03Thread extends Thread {\n-    private volatile boolean threadReady = false;\n-    private volatile boolean shouldFinish = false;\n-\n-    \/\/ make thread with specific name\n-    public suspendthrd03Thread(String name) {\n-        super(name);\n-    }\n-\n-    \/\/ run thread continuously\n-    public void run() {\n-        \/\/ run in a loop\n-        \/\/ SP1-n - tell main we are ready\n-        threadReady = true;\n-        int i = 0;\n-        int n = 1000;\n-        while (!shouldFinish) {\n-            if (n <= 0) {\n-                n = 1000;\n-            }\n-            if (i > n) {\n-                i = 0;\n-                n = n - 1;\n-            }\n-            i = i + 1;\n-        }\n-    }\n-\n-    \/\/ check if thread is ready\n-    public boolean checkReady() {\n-        try {\n-            while (!threadReady) {\n-                sleep(1000);\n-            }\n-        } catch (InterruptedException e) {\n-            throw new RuntimeException(\"Interruption while preparing tested thread: \\n\\t\" + e);\n-        }\n-        return threadReady;\n-    }\n-\n-    \/\/ let thread to finish\n-    public void letFinish() {\n-        shouldFinish = true;\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/SuspendThread\/suspendthrd03\/suspendthrd03.java","additions":0,"deletions":311,"binary":false,"changes":311,"status":"deleted"}]}