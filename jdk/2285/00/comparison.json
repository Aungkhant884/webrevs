{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -277,0 +277,7 @@\n+            \/\/ Set the \"label\" property of each input node, so that by default\n+            \/\/ search is done on the node label (without line breaks). See also\n+            \/\/ class NodeQuickSearch in the View module.\n+            for (InputNode n : getSource().getSourceNodes()) {\n+                String label = resolveString(diagram.getNodeText(), n.getProperties());\n+                n.getProperties().setProperty(\"label\", label);\n+            }\n","filename":"src\/utils\/IdealGraphVisualizer\/Graph\/src\/com\/sun\/hotspot\/igv\/graph\/Figure.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-javac.source=1.7\r\n+javac.source=1.8\r\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/nbproject\/project.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+import java.util.Collections;\n@@ -49,1 +50,1 @@\n-    private static final String DEFAULT_PROPERTY = \"name\";\n+    private static final String DEFAULT_PROPERTY = \"label\";\n@@ -69,0 +70,1 @@\n+        String rawValue;\n@@ -73,1 +75,2 @@\n-            value = \".*\" + Pattern.quote(parts[0]) + \".*\";\n+            rawValue = parts[0];\n+            value = \".*\" + Pattern.quote(rawValue) + \".*\";\n@@ -76,5 +79,2 @@\n-            value = parts[1];\n-        }\n-\n-        if (value.isEmpty()) {\n-            value = \".*\";\n+            rawValue = parts[1];\n+            value = (rawValue.isEmpty() ? \"\" : Pattern.quote(rawValue)) + \".*\";\n@@ -112,7 +112,15 @@\n-                response.addResult(new Runnable() {\n-                    @Override\n-                    public void run() {\n-                        final EditorTopComponent comp = EditorTopComponent.getActive();\n-                        if (comp != null) {\n-                            if (theGraph != null) {\n-                                comp.getDiagramModel().selectGraph(theGraph);\n+                \/\/ Show \"All N matching nodes\" entry only if 1) there are\n+                \/\/ multiple matches and 2) the query does not only contain\n+                \/\/ digits (it is rare to select all nodes whose id contains a\n+                \/\/ certain subsequence of digits).\n+                if (matches.size() > 1 && !rawValue.matches(\"\\\\d+\")) {\n+                    if (!response.addResult(new Runnable() {\n+                        @Override\n+                        public void run() {\n+                            final EditorTopComponent comp = EditorTopComponent.getActive();\n+                            if (comp != null) {\n+                                if (theGraph != null) {\n+                                    comp.getDiagramModel().selectGraph(theGraph);\n+                                }\n+                                comp.setSelectedNodes(set);\n+                                comp.requestActive();\n@@ -120,2 +128,0 @@\n-                            comp.setSelectedNodes(set);\n-                            comp.requestActive();\n@@ -123,0 +129,4 @@\n+                    },\n+                            \"All \" + matches.size() + \" matching nodes (\" + name + \"=\" + value + \")\" + (theGraph != null ? \" in \" + theGraph.getName() : \"\")\n+                    )) {\n+                        return;\n@@ -124,3 +134,7 @@\n-                },\n-                        \"All \" + matches.size() + \" matching nodes (\" + name + \"=\" + value + \")\" + (theGraph != null ? \" in \" + theGraph.getName() : \"\")\n-                );\n+                }\n+\n+                \/\/ Rank the matches.\n+                Collections.sort(matches,\n+                                 (InputNode a, InputNode b) ->\n+                                 Integer.valueOf(rankMatch(rawValue, a.getProperties().get(name)))\n+                                 .compareTo(rankMatch(rawValue, b.getProperties().get(name))));\n@@ -130,1 +144,1 @@\n-                    response.addResult(new Runnable() {\n+                    if (!response.addResult(new Runnable() {\n@@ -146,1 +160,3 @@\n-                    );\n+                    )) {\n+                        return;\n+                    }\n@@ -176,0 +192,27 @@\n+\n+    \/**\n+     * Rank a match by splitting the property into words. Full matches of a word\n+     * rank highest, followed by partial matches at the word start, followed by\n+     * the rest of matches in increasing size of the partially matched word, for\n+     * example:\n+     *\n+     *   rank(\"5\", \"5 AddI\")   = 1 (full match of first word)\n+     *   rank(\"5\", \"554 MulI\") = 2 (start match of first word)\n+     *   rank(\"5\", \"25 AddL\")  = 3 (middle match of first word with excess 1)\n+     *   rank(\"5\", \"253 AddL\") = 4 (middle match of first word with excess 2)\n+     *\/\n+    private int rankMatch(String qry, String prop) {\n+        String query = qry.toLowerCase();\n+        String property = prop.toLowerCase();\n+        for (String component : property.split(\"\\\\W+\")) {\n+            if (component.equals(query)) {\n+                return 1;\n+            } else if (component.startsWith(query)) {\n+                return 2;\n+            } else if (component.contains(query)) {\n+                return component.length() - query.length() + 2;\n+            }\n+        }\n+        System.out.println(Integer.MAX_VALUE);\n+        return Integer.MAX_VALUE;\n+    }\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/com\/sun\/hotspot\/igv\/view\/NodeQuickSearch.java","additions":65,"deletions":22,"binary":false,"changes":87,"status":"modified"}]}