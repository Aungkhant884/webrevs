{"files":[{"patch":"@@ -138,13 +138,33 @@\n-  if (next_node == NULL) {\n-    \/\/ A concurrent try_pop already claimed what was the last entry.  That\n-    \/\/ operation may not have cleared queue head yet, but we should still\n-    \/\/ treat the queue as empty until a push\/append operation changes head\n-    \/\/ to an entry with a non-NULL next value.\n-    *node_ptr = NULL;\n-    return true;\n-\n-  } else if (!is_end(next_node)) {\n-    \/\/ The next_node is not at the end of the queue's list.  Use the \"usual\"\n-    \/\/ lock-free pop from the head of a singly linked list to try to take it.\n-    if (result == Atomic::cmpxchg(&_head, result, next_node)) {\n-      \/\/ Former head successfully taken.\n+  if (!is_end(next_node)) {\n+    \/\/ [Clause 1]\n+    \/\/ There are several cases for next_node.\n+    \/\/ (1) next_node is the extension of the queue's list.\n+    \/\/ (2) next_node is NULL, because a competing try_pop took result.\n+    \/\/ (3) next_node is the extension of some unrelated list, because a\n+    \/\/ competing try_pop took result and put it in some other list.\n+    \/\/\n+    \/\/ Attempt to advance the list, replacing result with next_node in\n+    \/\/ _head.  The success or failure of that attempt, along with the value\n+    \/\/ of next_node, are used to partially determine which case we're in and\n+    \/\/ how to proceed.  In particular, advancement will fail for case (3).\n+    if (result != Atomic::cmpxchg(&_head, result, next_node)) {\n+      \/\/ [Clause 1a]\n+      \/\/ The cmpxchg to advance the list failed; a concurrent try_pop won\n+      \/\/ the race and claimed result.  This can happen for any of the\n+      \/\/ next_node cases.\n+      return false;\n+    } else if (next_node == NULL) {\n+      \/\/ [Clause 1b]\n+      \/\/ The cmpxchg to advance the list succeeded, but a concurrent try_pop\n+      \/\/ has already claimed result (see [Clause 2] - result was the last\n+      \/\/ entry in the list) by nulling result's next field.  The advance set\n+      \/\/ _head to NULL, \"helping\" the competing try_pop.  _head will remain\n+      \/\/ NULL until a subsequent push\/append.  This is a lost race, and we\n+      \/\/ report it as such for consistency, though we could report the queue\n+      \/\/ was empty.\n+      return false;\n+    } else {\n+      \/\/ [Clause 1c]\n+      \/\/ Successfully advanced the list and claimed result.  next_node was\n+      \/\/ in the extension of the queue's list.  Return result after\n+      \/\/ unlinking it from next_node.\n@@ -154,3 +174,0 @@\n-    } else {\n-      \/\/ Lost race to take result from the head of the list.\n-      return false;\n@@ -159,1 +176,2 @@\n-  } else if (is_end(Atomic::cmpxchg(next_ptr(*result), end_marker(), (T*)NULL))) {\n+  } else if (is_end(Atomic::cmpxchg(next_ptr(*result), next_node, (T*)NULL))) {\n+    \/\/ [Clause 2]\n@@ -173,1 +191,2 @@\n-    \/\/ cmpxchg indicates a concurrent push\/append updated the head first.\n+    \/\/ cmpxchg indicates a concurrent operation updated _head first.  That\n+    \/\/ could be either a push\/extend or a try_pop in [Clause 1b].\n@@ -181,3 +200,4 @@\n-    \/\/ Result was the last entry in the list, but either a concurrent pop\n-    \/\/ claimed it first or a concurrent push\/append extended the list from\n-    \/\/ it.  Either way, we lost the race.\n+    \/\/ [Clause 3]\n+    \/\/ Result was the last entry in the list, but either a concurrent\n+    \/\/ try_pop claimed it first or a concurrent push\/append extended the\n+    \/\/ list from it.  Either way, we lost the race to claim it.\n","filename":"src\/hotspot\/share\/utilities\/nonblockingQueue.inline.hpp","additions":41,"deletions":21,"binary":false,"changes":62,"status":"modified"}]}