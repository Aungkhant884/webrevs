{"files":[{"patch":"@@ -1115,63 +1115,0 @@\n-\/\/ Unpack an array argument into a pointer to the body and the length\n-\/\/ if the array is non-null, otherwise pass 0 for both.\n-static void unpack_array_argument(MacroAssembler* masm, VMRegPair reg, BasicType in_elem_type, VMRegPair body_arg, VMRegPair length_arg) { Unimplemented(); }\n-\n-\n-class ComputeMoveOrder: public StackObj {\n-  class MoveOperation: public ResourceObj {\n-    friend class ComputeMoveOrder;\n-   private:\n-    VMRegPair        _src;\n-    VMRegPair        _dst;\n-    int              _src_index;\n-    int              _dst_index;\n-    bool             _processed;\n-    MoveOperation*  _next;\n-    MoveOperation*  _prev;\n-\n-    static int get_id(VMRegPair r) { Unimplemented(); return 0; }\n-\n-   public:\n-    MoveOperation(int src_index, VMRegPair src, int dst_index, VMRegPair dst):\n-      _src(src)\n-    , _dst(dst)\n-    , _src_index(src_index)\n-    , _dst_index(dst_index)\n-    , _processed(false)\n-    , _next(NULL)\n-    , _prev(NULL) { Unimplemented(); }\n-\n-    VMRegPair src() const              { Unimplemented(); return _src; }\n-    int src_id() const                 { Unimplemented(); return 0; }\n-    int src_index() const              { Unimplemented(); return 0; }\n-    VMRegPair dst() const              { Unimplemented(); return _src; }\n-    void set_dst(int i, VMRegPair dst) { Unimplemented(); }\n-    int dst_index() const              { Unimplemented(); return 0; }\n-    int dst_id() const                 { Unimplemented(); return 0; }\n-    MoveOperation* next() const        { Unimplemented(); return 0; }\n-    MoveOperation* prev() const        { Unimplemented(); return 0; }\n-    void set_processed()               { Unimplemented(); }\n-    bool is_processed() const          { Unimplemented(); return 0; }\n-\n-    \/\/ insert\n-    void break_cycle(VMRegPair temp_register) { Unimplemented(); }\n-\n-    void link(GrowableArray<MoveOperation*>& killer) { Unimplemented(); }\n-  };\n-\n- private:\n-  GrowableArray<MoveOperation*> edges;\n-\n- public:\n-  ComputeMoveOrder(int total_in_args, VMRegPair* in_regs, int total_c_args, VMRegPair* out_regs,\n-                    BasicType* in_sig_bt, GrowableArray<int>& arg_order, VMRegPair tmp_vmreg) { Unimplemented(); }\n-\n-  \/\/ Collected all the move operations\n-  void add_edge(int src_index, VMRegPair src, int dst_index, VMRegPair dst) { Unimplemented(); }\n-\n-  \/\/ Walk the edges breaking cycles between moves.  The result list\n-  \/\/ can be walked in order to produce the proper set of loads\n-  GrowableArray<MoveOperation*>* get_store_order(VMRegPair temp_register) { Unimplemented(); return 0; }\n-};\n-\n-\n@@ -1290,2 +1227,1 @@\n-                                                BasicType ret_type,\n-                                                address critical_entry) {\n+                                                BasicType ret_type) {\n@@ -1316,6 +1252,1 @@\n-  bool is_critical_native = true;\n-  address native_func = critical_entry;\n-  if (native_func == NULL) {\n-    native_func = method->native_function();\n-    is_critical_native = false;\n-  }\n+  address native_func = method->native_function();\n@@ -1335,13 +1266,1 @@\n-  int total_c_args = total_in_args;\n-  if (!is_critical_native) {\n-    total_c_args += 1;\n-    if (method->is_static()) {\n-      total_c_args++;\n-    }\n-  } else {\n-    for (int i = 0; i < total_in_args; i++) {\n-      if (in_sig_bt[i] == T_ARRAY) {\n-        total_c_args++;\n-      }\n-    }\n-  }\n+  int total_c_args = total_in_args + (method->is_static() ? 2 : 1);\n@@ -1354,5 +1273,4 @@\n-  if (!is_critical_native) {\n-    out_sig_bt[argc++] = T_ADDRESS;\n-    if (method->is_static()) {\n-      out_sig_bt[argc++] = T_OBJECT;\n-    }\n+  out_sig_bt[argc++] = T_ADDRESS;\n+  if (method->is_static()) {\n+    out_sig_bt[argc++] = T_OBJECT;\n+  }\n@@ -1360,24 +1278,2 @@\n-    for (int i = 0; i < total_in_args ; i++ ) {\n-      out_sig_bt[argc++] = in_sig_bt[i];\n-    }\n-  } else {\n-    in_elem_bt = NEW_RESOURCE_ARRAY(BasicType, total_in_args);\n-    SignatureStream ss(method->signature());\n-    for (int i = 0; i < total_in_args ; i++ ) {\n-      if (in_sig_bt[i] == T_ARRAY) {\n-        \/\/ Arrays are passed as int, elem* pair\n-        out_sig_bt[argc++] = T_INT;\n-        out_sig_bt[argc++] = T_ADDRESS;\n-        ss.skip_array_prefix(1);  \/\/ skip one '['\n-        assert(ss.is_primitive(), \"primitive type expected\");\n-        in_elem_bt[i] = ss.type();\n-      } else {\n-        out_sig_bt[argc++] = in_sig_bt[i];\n-        in_elem_bt[i] = T_VOID;\n-      }\n-      if (in_sig_bt[i] != T_VOID) {\n-        assert(in_sig_bt[i] == ss.type() ||\n-               in_sig_bt[i] == T_ARRAY, \"must match\");\n-        ss.next();\n-      }\n-    }\n+  for (int i = 0; i < total_in_args ; i++ ) {\n+    out_sig_bt[argc++] = in_sig_bt[i];\n@@ -1405,28 +1301,0 @@\n-  if (is_critical_native) {\n-    \/\/ Critical natives may have to call out so they need a save area\n-    \/\/ for register arguments.\n-    int double_slots = 0;\n-    int single_slots = 0;\n-    for ( int i = 0; i < total_in_args; i++) {\n-      if (in_regs[i].first()->is_Register()) {\n-        const Register reg = in_regs[i].first()->as_Register();\n-        switch (in_sig_bt[i]) {\n-          case T_BOOLEAN:\n-          case T_BYTE:\n-          case T_SHORT:\n-          case T_CHAR:\n-          case T_INT:  single_slots++; break;\n-          case T_ARRAY:  \/\/ specific to LP64 (7145024)\n-          case T_LONG: double_slots++; break;\n-          default:  ShouldNotReachHere();\n-        }\n-      } else if (in_regs[i].first()->is_FloatRegister()) {\n-        ShouldNotReachHere();\n-      }\n-    }\n-    total_save_slots = double_slots * 2 + single_slots;\n-    \/\/ align the save area\n-    if (double_slots != 0) {\n-      stack_slots = align_up(stack_slots, 2);\n-    }\n-  }\n@@ -1599,4 +1467,1 @@\n-  \/\/ This may iterate in two different directions depending on the\n-  \/\/ kind of native it is.  The reason is that for regular JNI natives\n-  \/\/ the incoming and outgoing registers are offset upwards and for\n-  \/\/ critical natives they are offset down.\n+  \/\/ For JNI natives the incoming and outgoing registers are offset upwards.\n@@ -1607,8 +1472,3 @@\n-  if (!is_critical_native) {\n-    for (int i = total_in_args - 1, c_arg = total_c_args - 1; i >= 0; i--, c_arg--) {\n-      arg_order.push(i);\n-      arg_order.push(c_arg);\n-    }\n-  } else {\n-    \/\/ Compute a valid move order, using tmp_vmreg to break any cycles\n-    ComputeMoveOrder cmo(total_in_args, in_regs, total_c_args, out_regs, in_sig_bt, arg_order, tmp_vmreg);\n+  for (int i = total_in_args - 1, c_arg = total_c_args - 1; i >= 0; i--, c_arg--) {\n+    arg_order.push(i);\n+    arg_order.push(c_arg);\n@@ -1622,14 +1482,1 @@\n-    if (c_arg == -1) {\n-      assert(is_critical_native, \"should only be required for critical natives\");\n-      \/\/ This arg needs to be moved to a temporary\n-      __ mov(tmp_vmreg.first()->as_Register(), in_regs[i].first()->as_Register());\n-      in_regs[i] = tmp_vmreg;\n-      temploc = i;\n-      continue;\n-    } else if (i == -1) {\n-      assert(is_critical_native, \"should only be required for critical natives\");\n-      \/\/ Read from the temporary location\n-      assert(temploc != -1, \"must be valid\");\n-      i = temploc;\n-      temploc = -1;\n-    }\n+    assert(c_arg != -1 && i != -1, \"wrong order\");\n@@ -1650,13 +1497,0 @@\n-        if (is_critical_native) {\n-          unpack_array_argument(masm, in_regs[i], in_elem_bt[i], out_regs[c_arg + 1], out_regs[c_arg]);\n-          c_arg++;\n-#ifdef ASSERT\n-          if (out_regs[c_arg].first()->is_Register()) {\n-            reg_destroyed[out_regs[c_arg].first()->as_Register()->encoding()] = true;\n-          } else if (out_regs[c_arg].first()->is_FloatRegister()) {\n-            freg_destroyed[out_regs[c_arg].first()->as_FloatRegister()->encoding()] = true;\n-          }\n-#endif\n-          int_args++;\n-          break;\n-        }\n@@ -1664,1 +1498,0 @@\n-        assert(!is_critical_native, \"no oop arguments\");\n@@ -1704,1 +1537,1 @@\n-  if (method->is_static() && !is_critical_native) {\n+  if (method->is_static()) {\n@@ -1762,1 +1595,0 @@\n-    assert(!is_critical_native, \"unhandled\");\n@@ -1816,2 +1648,1 @@\n-  if (!is_critical_native) {\n-    __ lea(c_rarg0, Address(rthread, in_bytes(JavaThread::jni_environment_offset())));\n+  __ lea(c_rarg0, Address(rthread, in_bytes(JavaThread::jni_environment_offset())));\n@@ -1819,5 +1650,4 @@\n-    \/\/ Now set thread in native\n-    __ mov(rscratch1, _thread_in_native);\n-    __ lea(rscratch2, Address(rthread, JavaThread::thread_state_offset()));\n-    __ stlrw(rscratch1, rscratch2);\n-  }\n+  \/\/ Now set thread in native\n+  __ mov(rscratch1, _thread_in_native);\n+  __ lea(rscratch2, Address(rthread, JavaThread::thread_state_offset()));\n+  __ stlrw(rscratch1, rscratch2);\n@@ -1854,12 +1684,0 @@\n-  \/\/ If this is a critical native, check for a safepoint or suspend request after the call.\n-  \/\/ If a safepoint is needed, transition to native, then to native_trans to handle\n-  \/\/ safepoints like the native methods that are not critical natives.\n-  if (is_critical_native) {\n-    Label needs_safepoint;\n-    __ safepoint_poll(needs_safepoint, false \/* at_return *\/, true \/* acquire *\/, false \/* in_nmethod *\/);\n-    __ ldrw(rscratch1, Address(rthread, JavaThread::suspend_flags_offset()));\n-    __ cbnzw(rscratch1, needs_safepoint);\n-    __ b(after_transition);\n-    __ bind(needs_safepoint);\n-  }\n-\n@@ -1974,5 +1792,3 @@\n-  if (!is_critical_native) {\n-    \/\/ reset handle block\n-    __ ldr(r2, Address(rthread, JavaThread::active_handles_offset()));\n-    __ str(zr, Address(r2, JNIHandleBlock::top_offset_in_bytes()));\n-  }\n+  \/\/ reset handle block\n+  __ ldr(r2, Address(rthread, JavaThread::active_handles_offset()));\n+  __ str(zr, Address(r2, JNIHandleBlock::top_offset_in_bytes()));\n@@ -1982,5 +1798,3 @@\n-  if (!is_critical_native) {\n-    \/\/ Any exception pending?\n-    __ ldr(rscratch1, Address(rthread, in_bytes(Thread::pending_exception_offset())));\n-    __ cbnz(rscratch1, exception_pending);\n-  }\n+  \/\/ Any exception pending?\n+  __ ldr(rscratch1, Address(rthread, in_bytes(Thread::pending_exception_offset())));\n+  __ cbnz(rscratch1, exception_pending);\n@@ -1993,3 +1807,2 @@\n-  if (!is_critical_native) {\n-    \/\/ forward the exception\n-    __ bind(exception_pending);\n+  \/\/ forward the exception\n+  __ bind(exception_pending);\n@@ -1997,3 +1810,2 @@\n-    \/\/ and forward the exception\n-    __ far_jump(RuntimeAddress(StubRoutines::forward_exception_entry()));\n-  }\n+  \/\/ and forward the exception\n+  __ far_jump(RuntimeAddress(StubRoutines::forward_exception_entry()));\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":30,"deletions":218,"binary":false,"changes":248,"status":"modified"},{"patch":"@@ -453,2 +453,0 @@\n-\n-  UNSUPPORTED_OPTION(CriticalJNINatives);\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -753,2 +753,1 @@\n-                                                BasicType ret_type,\n-                                                address critical_entry) {\n+                                                BasicType ret_type) {\n@@ -780,1 +779,1 @@\n-  bool is_static = method->is_static();\n+  bool method_is_static = method->is_static();\n@@ -783,4 +782,1 @@\n-  int total_c_args = total_in_args + 1;\n-  if (is_static) {\n-    total_c_args++;\n-  }\n+  int total_c_args = total_in_args + (method_is_static ? 2 : 1);\n@@ -793,1 +789,1 @@\n-  if (is_static) {\n+  if (method_is_static) {\n@@ -884,1 +880,1 @@\n-  const int extra_args = is_static ? 2 : 1;\n+  const int extra_args = method_is_static ? 2 : 1;\n@@ -907,1 +903,1 @@\n-        if ((i == 0) && (!is_static)) {\n+        if ((i == 0) && (!method_is_static)) {\n@@ -1119,1 +1115,1 @@\n-  if (is_static) {\n+  if (method_is_static) {\n@@ -1335,1 +1331,1 @@\n-                                     in_ByteSize(is_static ? klass_offset : receiver_offset),\n+                                     in_ByteSize(method_is_static ? klass_offset : receiver_offset),\n","filename":"src\/hotspot\/cpu\/arm\/sharedRuntime_arm.cpp","additions":8,"deletions":12,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -338,1 +338,0 @@\n-  UNSUPPORTED_OPTION(CriticalJNINatives);\n","filename":"src\/hotspot\/cpu\/arm\/vm_version_arm_32.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1536,51 +1536,0 @@\n-static void move_ptr(MacroAssembler* masm, VMRegPair src, VMRegPair dst, Register r_caller_sp, Register r_temp) {\n-  if (src.first()->is_stack()) {\n-    if (dst.first()->is_stack()) {\n-      \/\/ stack to stack\n-      __ ld(r_temp, reg2offset(src.first()), r_caller_sp);\n-      __ std(r_temp, reg2offset(dst.first()), R1_SP);\n-    } else {\n-      \/\/ stack to reg\n-      __ ld(dst.first()->as_Register(), reg2offset(src.first()), r_caller_sp);\n-    }\n-  } else if (dst.first()->is_stack()) {\n-    \/\/ reg to stack\n-    __ std(src.first()->as_Register(), reg2offset(dst.first()), R1_SP);\n-  } else {\n-    if (dst.first() != src.first()) {\n-      __ mr(dst.first()->as_Register(), src.first()->as_Register());\n-    }\n-  }\n-}\n-\n-\/\/ Unpack an array argument into a pointer to the body and the length\n-\/\/ if the array is non-null, otherwise pass 0 for both.\n-static void unpack_array_argument(MacroAssembler* masm, VMRegPair reg, BasicType in_elem_type,\n-                                  VMRegPair body_arg, VMRegPair length_arg, Register r_caller_sp,\n-                                  Register tmp_reg, Register tmp2_reg) {\n-  assert(!body_arg.first()->is_Register() || body_arg.first()->as_Register() != tmp_reg,\n-         \"possible collision\");\n-  assert(!length_arg.first()->is_Register() || length_arg.first()->as_Register() != tmp_reg,\n-         \"possible collision\");\n-\n-  \/\/ Pass the length, ptr pair.\n-  Label set_out_args;\n-  VMRegPair tmp, tmp2;\n-  tmp.set_ptr(tmp_reg->as_VMReg());\n-  tmp2.set_ptr(tmp2_reg->as_VMReg());\n-  if (reg.first()->is_stack()) {\n-    \/\/ Load the arg up from the stack.\n-    move_ptr(masm, reg, tmp, r_caller_sp, \/*unused*\/ R0);\n-    reg = tmp;\n-  }\n-  __ li(tmp2_reg, 0); \/\/ Pass zeros if Array=null.\n-  if (tmp_reg != reg.first()->as_Register()) __ li(tmp_reg, 0);\n-  __ cmpdi(CCR0, reg.first()->as_Register(), 0);\n-  __ beq(CCR0, set_out_args);\n-  __ lwa(tmp2_reg, arrayOopDesc::length_offset_in_bytes(), reg.first()->as_Register());\n-  __ addi(tmp_reg, reg.first()->as_Register(), arrayOopDesc::base_offset_in_bytes(in_elem_type));\n-  __ bind(set_out_args);\n-  move_ptr(masm, tmp, body_arg, r_caller_sp, \/*unused*\/ R0);\n-  move_ptr(masm, tmp2, length_arg, r_caller_sp, \/*unused*\/ R0); \/\/ Same as move32_64 on PPC64.\n-}\n-\n@@ -1688,2 +1637,1 @@\n-                                                BasicType ret_type,\n-                                                address critical_entry) {\n+                                                BasicType ret_type) {\n@@ -1712,6 +1660,1 @@\n-  bool is_critical_native = true;\n-  address native_func = critical_entry;\n-  if (native_func == NULL) {\n-    native_func = method->native_function();\n-    is_critical_native = false;\n-  }\n+  address native_func = method->native_function();\n@@ -1736,13 +1679,1 @@\n-  int  total_c_args     = total_in_args;\n-\n-  if (!is_critical_native) {\n-    int n_hidden_args = method_is_static ? 2 : 1;\n-    total_c_args += n_hidden_args;\n-  } else {\n-    \/\/ No JNIEnv*, no this*, but unpacked arrays (base+length).\n-    for (int i = 0; i < total_in_args; i++) {\n-      if (in_sig_bt[i] == T_ARRAY) {\n-        total_c_args++;\n-      }\n-    }\n-  }\n+  int  total_c_args     = total_in_args + (method_is_static ? 2 : 1);\n@@ -1762,28 +1693,4 @@\n-  if (!is_critical_native) {\n-    out_sig_bt[argc++] = T_ADDRESS;\n-    if (method->is_static()) {\n-      out_sig_bt[argc++] = T_OBJECT;\n-    }\n-\n-    for (int i = 0; i < total_in_args ; i++ ) {\n-      out_sig_bt[argc++] = in_sig_bt[i];\n-    }\n-  } else {\n-    in_elem_bt = NEW_RESOURCE_ARRAY(BasicType, total_c_args);\n-    SignatureStream ss(method->signature());\n-    int o = 0;\n-    for (int i = 0; i < total_in_args ; i++, o++) {\n-      if (in_sig_bt[i] == T_ARRAY) {\n-        \/\/ Arrays are passed as int, elem* pair\n-        ss.skip_array_prefix(1);  \/\/ skip one '['\n-        assert(ss.is_primitive(), \"primitive type expected\");\n-        in_elem_bt[o] = ss.type();\n-      } else {\n-        in_elem_bt[o] = T_VOID;\n-      }\n-      if (in_sig_bt[i] != T_VOID) {\n-        assert(in_sig_bt[i] == ss.type() ||\n-               in_sig_bt[i] == T_ARRAY, \"must match\");\n-        ss.next();\n-      }\n-    }\n+  out_sig_bt[argc++] = T_ADDRESS;\n+  if (method->is_static()) {\n+    out_sig_bt[argc++] = T_OBJECT;\n+  }\n@@ -1791,9 +1698,2 @@\n-    for (int i = 0; i < total_in_args ; i++ ) {\n-      if (in_sig_bt[i] == T_ARRAY) {\n-        \/\/ Arrays are passed as int, elem* pair.\n-        out_sig_bt[argc++] = T_INT;\n-        out_sig_bt[argc++] = T_ADDRESS;\n-      } else {\n-        out_sig_bt[argc++] = in_sig_bt[i];\n-      }\n-    }\n+  for (int i = 0; i < total_in_args ; i++ ) {\n+    out_sig_bt[argc++] = in_sig_bt[i];\n@@ -1826,1 +1726,1 @@\n-  \/\/        [oopHandle area]           <-- 3) R1_SP + oop_handle_offset (save area for critical natives)\n+  \/\/        [oopHandle area]           <-- 3) R1_SP + oop_handle_offset\n@@ -1841,29 +1741,0 @@\n-  if (is_critical_native) {\n-    \/\/ Critical natives may have to call out so they need a save area\n-    \/\/ for register arguments.\n-    int double_slots = 0;\n-    int single_slots = 0;\n-    for (int i = 0; i < total_in_args; i++) {\n-      if (in_regs[i].first()->is_Register()) {\n-        const Register reg = in_regs[i].first()->as_Register();\n-        switch (in_sig_bt[i]) {\n-          case T_BOOLEAN:\n-          case T_BYTE:\n-          case T_SHORT:\n-          case T_CHAR:\n-          case T_INT:\n-          \/\/ Fall through.\n-          case T_ARRAY:\n-          case T_LONG: double_slots++; break;\n-          default:  ShouldNotReachHere();\n-        }\n-      } else if (in_regs[i].first()->is_FloatRegister()) {\n-        switch (in_sig_bt[i]) {\n-          case T_FLOAT:  single_slots++; break;\n-          case T_DOUBLE: double_slots++; break;\n-          default:  ShouldNotReachHere();\n-        }\n-      }\n-    }\n-    total_save_slots = double_slots * 2 + align_up(single_slots, 2); \/\/ round to even\n-  }\n@@ -1876,1 +1747,1 @@\n-  if (method_is_static && !is_critical_native) {                                  \/\/ 4)\n+  if (method_is_static) {                                                         \/\/ 4)\n@@ -1922,4 +1793,2 @@\n-  if (!is_critical_native) {\n-    r_carg1_jnienv        = out_regs[0].first()->as_Register();\n-    r_carg2_classorobject = out_regs[1].first()->as_Register();\n-  }\n+  r_carg1_jnienv        = out_regs[0].first()->as_Register();\n+  r_carg2_classorobject = out_regs[1].first()->as_Register();\n@@ -2061,7 +1930,0 @@\n-        if (is_critical_native) {\n-          int body_arg = out;\n-          out -= 1; \/\/ Point to length arg.\n-          unpack_array_argument(masm, in_regs[in], in_elem_bt[in], out_regs[body_arg], out_regs[out],\n-                                r_callers_sp, r_temp_1, r_temp_2);\n-          break;\n-        }\n@@ -2069,1 +1931,0 @@\n-        assert(!is_critical_native, \"no oop arguments\");\n@@ -2101,1 +1962,1 @@\n-  if (method_is_static && !is_critical_native) {\n+  if (method_is_static) {\n@@ -2112,3 +1973,1 @@\n-  if (!is_critical_native) {\n-    __ addi(r_carg1_jnienv, R16_thread, in_bytes(JavaThread::jni_environment_offset()));\n-  }\n+  __ addi(r_carg1_jnienv, R16_thread, in_bytes(JavaThread::jni_environment_offset()));\n@@ -2143,1 +2002,0 @@\n-    assert(!is_critical_native, \"unhandled\");\n@@ -2188,3 +2046,2 @@\n-  if (!is_critical_native) {\n-    \/\/ Publish thread state\n-    \/\/ --------------------------------------------------------------------------\n+  \/\/ Publish thread state\n+  \/\/ --------------------------------------------------------------------------\n@@ -2192,6 +2049,5 @@\n-    \/\/ Transition from _thread_in_Java to _thread_in_native.\n-    __ li(R0, _thread_in_native);\n-    __ release();\n-    \/\/ TODO: PPC port assert(4 == JavaThread::sz_thread_state(), \"unexpected field size\");\n-    __ stw(R0, thread_(thread_state));\n-  }\n+  \/\/ Transition from _thread_in_Java to _thread_in_native.\n+  __ li(R0, _thread_in_native);\n+  __ release();\n+  \/\/ TODO: PPC port assert(4 == JavaThread::sz_thread_state(), \"unexpected field size\");\n+  __ stw(R0, thread_(thread_state));\n@@ -2259,18 +2115,0 @@\n-  \/\/ If this is a critical native, check for a safepoint or suspend request after the call.\n-  \/\/ If a safepoint is needed, transition to native, then to native_trans to handle\n-  \/\/ safepoints like the native methods that are not critical natives.\n-  if (is_critical_native) {\n-    Label needs_safepoint;\n-    Register sync_state      = r_temp_5;\n-    \/\/ Note: We should not reach here with active stack watermark. There's no safepoint between\n-    \/\/       start of the native wrapper and this check where it could have been added.\n-    \/\/       We don't check the watermark in the fast path.\n-    __ safepoint_poll(needs_safepoint, sync_state, false \/* at_return *\/, false \/* in_nmethod *\/);\n-\n-    Register suspend_flags   = r_temp_6;\n-    __ lwz(suspend_flags, thread_(suspend_flags));\n-    __ cmpwi(CCR1, suspend_flags, 0);\n-    __ beq(CCR1, after_transition);\n-    __ bind(needs_safepoint);\n-  }\n-\n@@ -2446,1 +2284,0 @@\n-  if (!is_critical_native) {\n@@ -2458,1 +2295,0 @@\n-  }\n@@ -2473,1 +2309,0 @@\n-  if (!is_critical_native) {\n@@ -2480,1 +2315,0 @@\n-  }\n","filename":"src\/hotspot\/cpu\/ppc\/sharedRuntime_ppc.cpp","additions":22,"deletions":188,"binary":false,"changes":210,"status":"modified"},{"patch":"@@ -1289,70 +1289,0 @@\n-static void move_ptr(MacroAssembler *masm,\n-                     VMRegPair src,\n-                     VMRegPair dst,\n-                     int framesize_in_slots) {\n-  int frame_offset = framesize_in_slots * VMRegImpl::stack_slot_size;\n-\n-  if (src.first()->is_stack()) {\n-    if (dst.first()->is_stack()) {\n-      \/\/ stack to stack\n-      __ mem2reg_opt(Z_R0_scratch, Address(Z_SP, reg2offset(src.first()) + frame_offset));\n-      __ reg2mem_opt(Z_R0_scratch, Address(Z_SP, reg2offset(dst.first())));\n-    } else {\n-      \/\/ stack to reg\n-      __ mem2reg_opt(dst.first()->as_Register(),\n-                     Address(Z_SP, reg2offset(src.first()) + frame_offset));\n-    }\n-  } else {\n-    if (dst.first()->is_stack()) {\n-      \/\/ reg to stack\n-    __ reg2mem_opt(src.first()->as_Register(), Address(Z_SP, reg2offset(dst.first())));\n-    } else {\n-    __ lgr_if_needed(dst.first()->as_Register(), src.first()->as_Register());\n-    }\n-  }\n-}\n-\n-\/\/ Unpack an array argument into a pointer to the body and the length\n-\/\/ if the array is non-null, otherwise pass 0 for both.\n-static void unpack_array_argument(MacroAssembler *masm,\n-                                   VMRegPair reg,\n-                                   BasicType in_elem_type,\n-                                   VMRegPair body_arg,\n-                                   VMRegPair length_arg,\n-                                   int framesize_in_slots) {\n-  Register tmp_reg = Z_tmp_2;\n-  Register tmp2_reg = Z_tmp_1;\n-\n-  assert(!body_arg.first()->is_Register() || body_arg.first()->as_Register() != tmp_reg,\n-         \"possible collision\");\n-  assert(!length_arg.first()->is_Register() || length_arg.first()->as_Register() != tmp_reg,\n-         \"possible collision\");\n-\n-  \/\/ Pass the length, ptr pair.\n-  NearLabel set_out_args;\n-  VMRegPair tmp, tmp2;\n-\n-  tmp.set_ptr(tmp_reg->as_VMReg());\n-  tmp2.set_ptr(tmp2_reg->as_VMReg());\n-  if (reg.first()->is_stack()) {\n-    \/\/ Load the arg up from the stack.\n-    move_ptr(masm, reg, tmp, framesize_in_slots);\n-    reg = tmp;\n-  }\n-\n-  const Register first = reg.first()->as_Register();\n-\n-  \/\/ Don't set CC, indicate unused result.\n-  (void) __ clear_reg(tmp2_reg, true, false);\n-  if (tmp_reg != first) {\n-    __ clear_reg(tmp_reg, true, false);  \/\/ Don't set CC.\n-  }\n-  __ compare64_and_branch(first, (RegisterOrConstant)0L, Assembler::bcondEqual, set_out_args);\n-  __ z_lgf(tmp2_reg, Address(first, arrayOopDesc::length_offset_in_bytes()));\n-  __ add2reg(tmp_reg, arrayOopDesc::base_offset_in_bytes(in_elem_type), first);\n-\n-  __ bind(set_out_args);\n-  move_ptr(masm, tmp, body_arg, framesize_in_slots);\n-  move32_64(masm, tmp2, length_arg, framesize_in_slots);\n-}\n-\n@@ -1368,2 +1298,1 @@\n-                                                BasicType ret_type,\n-                                                address critical_entry) {\n+                                                BasicType ret_type) {\n@@ -1403,6 +1332,1 @@\n-  bool is_critical_native = true;\n-  address native_func = critical_entry;\n-  if (native_func == NULL) {\n-    native_func = method->native_function();\n-    is_critical_native = false;\n-  }\n+  address native_func = method->native_function();\n@@ -1433,13 +1357,1 @@\n-  int  total_c_args     = total_in_args;\n-\n-  if (!is_critical_native) {\n-    int n_hidden_args = method_is_static ? 2 : 1;\n-    total_c_args += n_hidden_args;\n-  } else {\n-    \/\/ No JNIEnv*, no this*, but unpacked arrays (base+length).\n-    for (int i = 0; i < total_in_args; i++) {\n-      if (in_sig_bt[i] == T_ARRAY) {\n-        total_c_args ++;\n-      }\n-    }\n-  }\n+  int  total_c_args     = total_in_args + (method_is_static ? 2 : 1);\n@@ -1458,29 +1370,4 @@\n-  if (!is_critical_native) {\n-    out_sig_bt[argc++] = T_ADDRESS;\n-    if (method->is_static()) {\n-      out_sig_bt[argc++] = T_OBJECT;\n-    }\n-\n-    for (int i = 0; i < total_in_args; i++) {\n-      out_sig_bt[argc++] = in_sig_bt[i];\n-    }\n-  } else {\n-    in_elem_bt = NEW_RESOURCE_ARRAY(BasicType, total_in_args);\n-    SignatureStream ss(method->signature());\n-    int o = 0;\n-    for (int i = 0; i < total_in_args; i++, o++) {\n-      if (in_sig_bt[i] == T_ARRAY) {\n-        \/\/ Arrays are passed as tuples (int, elem*).\n-        ss.skip_array_prefix(1);  \/\/ skip one '['\n-        assert(ss.is_primitive(), \"primitive type expected\");\n-        in_elem_bt[o] = ss.type();\n-      } else {\n-        in_elem_bt[o] = T_VOID;\n-      }\n-      if (in_sig_bt[i] != T_VOID) {\n-        assert(in_sig_bt[i] == ss.type() ||\n-               in_sig_bt[i] == T_ARRAY, \"must match\");\n-        ss.next();\n-      }\n-    }\n-    assert(total_in_args == o, \"must match\");\n+  out_sig_bt[argc++] = T_ADDRESS;\n+  if (method->is_static()) {\n+    out_sig_bt[argc++] = T_OBJECT;\n+  }\n@@ -1488,9 +1375,2 @@\n-    for (int i = 0; i < total_in_args; i++) {\n-      if (in_sig_bt[i] == T_ARRAY) {\n-        \/\/ Arrays are passed as tuples (int, elem*).\n-        out_sig_bt[argc++] = T_INT;\n-        out_sig_bt[argc++] = T_ADDRESS;\n-      } else {\n-        out_sig_bt[argc++] = in_sig_bt[i];\n-      }\n-    }\n+  for (int i = 0; i < total_in_args; i++) {\n+    out_sig_bt[argc++] = in_sig_bt[i];\n@@ -1553,2 +1433,0 @@\n-  \/\/      | (save area for      |\n-  \/\/      |  critical natives)  |\n@@ -1582,31 +1460,0 @@\n-  if (is_critical_native) {\n-    \/\/ Critical natives may have to call out so they need a save area\n-    \/\/ for register arguments.\n-    int double_slots = 0;\n-    int single_slots = 0;\n-    for (int i = 0; i < total_in_args; i++) {\n-      if (in_regs[i].first()->is_Register()) {\n-        const Register reg = in_regs[i].first()->as_Register();\n-        switch (in_sig_bt[i]) {\n-          case T_BOOLEAN:\n-          case T_BYTE:\n-          case T_SHORT:\n-          case T_CHAR:\n-          case T_INT:\n-          \/\/ Fall through.\n-          case T_ARRAY:\n-          case T_LONG: double_slots++; break;\n-          default:  ShouldNotReachHere();\n-        }\n-      } else {\n-        if (in_regs[i].first()->is_FloatRegister()) {\n-          switch (in_sig_bt[i]) {\n-            case T_FLOAT:  single_slots++; break;\n-            case T_DOUBLE: double_slots++; break;\n-            default:  ShouldNotReachHere();\n-          }\n-        }\n-      }\n-    }  \/\/ for\n-    total_save_slots = double_slots * 2 + align_up(single_slots, 2); \/\/ Round to even.\n-  }\n@@ -1619,1 +1466,1 @@\n-  if (method_is_static && !is_critical_native) {                          \/\/ 4)\n+  if (method_is_static) {                                                 \/\/ 4)\n@@ -1786,7 +1633,0 @@\n-        if (is_critical_native) {\n-          int body_arg = cix;\n-          cix -= 1; \/\/ Point to length arg.\n-          unpack_array_argument(masm, in_regs[jix], in_elem_bt[jix], out_regs[body_arg], out_regs[cix], stack_slots);\n-          break;\n-        }\n-        \/\/ else fallthrough\n@@ -1794,1 +1634,0 @@\n-        assert(!is_critical_native, \"no oop arguments\");\n@@ -1824,1 +1663,1 @@\n-  if (method_is_static && !is_critical_native) {\n+  if (method_is_static) {\n@@ -1834,3 +1673,1 @@\n-  if (!is_critical_native) {\n-    __ add2reg(Z_ARG1, in_bytes(JavaThread::jni_environment_offset()), Z_thread);\n-  }\n+  __ add2reg(Z_ARG1, in_bytes(JavaThread::jni_environment_offset()), Z_thread);\n@@ -1858,1 +1695,0 @@\n-    assert(!is_critical_native, \"unhandled\");\n@@ -1926,4 +1762,2 @@\n-  if (!is_critical_native) {\n-    \/\/ Transition from _thread_in_Java to _thread_in_native.\n-    __ set_thread_state(_thread_in_native);\n-  }\n+  \/\/ Transition from _thread_in_Java to _thread_in_native.\n+  __ set_thread_state(_thread_in_native);\n@@ -1977,12 +1811,0 @@\n-  \/\/ If this is a critical native, check for a safepoint or suspend request after the call.\n-  \/\/ If a safepoint is needed, transition to native, then to native_trans to handle\n-  \/\/ safepoints like the native methods that are not critical natives.\n-  if (is_critical_native) {\n-    Label needs_safepoint;\n-    \/\/ Does this need to save_native_result and fences?\n-    __ safepoint_poll(needs_safepoint, Z_R1);\n-    __ load_and_test_int(Z_R0, Address(Z_thread, JavaThread::suspend_flags_offset()));\n-    __ z_bre(after_transition);\n-    __ bind(needs_safepoint);\n-  }\n-\n@@ -2159,3 +1981,2 @@\n-  if (!is_critical_native) {\n-    __ z_lg(Z_R1_scratch, Address(Z_thread, JavaThread::active_handles_offset()));\n-    __ clear_mem(Address(Z_R1_scratch, JNIHandleBlock::top_offset_in_bytes()), 4);\n+  __ z_lg(Z_R1_scratch, Address(Z_thread, JavaThread::active_handles_offset()));\n+  __ clear_mem(Address(Z_R1_scratch, JNIHandleBlock::top_offset_in_bytes()), 4);\n@@ -2163,4 +1984,3 @@\n-    \/\/ Check for pending exceptions.\n-    __ load_and_test_long(Z_R0, Address(Z_thread, Thread::pending_exception_offset()));\n-    __ z_brne(handle_pending_exception);\n-  }\n+  \/\/ Check for pending exceptions.\n+  __ load_and_test_long(Z_R0, Address(Z_thread, Thread::pending_exception_offset()));\n+  __ z_brne(handle_pending_exception);\n@@ -2188,20 +2008,17 @@\n-  if (!is_critical_native) {\n-\n-    \/\/---------------------------------------------------------------------\n-    \/\/ Handler for pending exceptions (out-of-line).\n-    \/\/---------------------------------------------------------------------\n-    \/\/ Since this is a native call, we know the proper exception handler\n-    \/\/ is the empty function. We just pop this frame and then jump to\n-    \/\/ forward_exception_entry. Z_R14 will contain the native caller's\n-    \/\/ return PC.\n-    __ bind(handle_pending_exception);\n-    __ pop_frame();\n-    __ load_const_optimized(Z_R1_scratch, StubRoutines::forward_exception_entry());\n-    __ restore_return_pc();\n-    __ z_br(Z_R1_scratch);\n-\n-    \/\/---------------------------------------------------------------------\n-    \/\/ Handler for a cache miss (out-of-line)\n-    \/\/---------------------------------------------------------------------\n-    __ call_ic_miss_handler(ic_miss, 0x77, 0, Z_R1_scratch);\n-  }\n+  \/\/---------------------------------------------------------------------\n+  \/\/ Handler for pending exceptions (out-of-line).\n+  \/\/---------------------------------------------------------------------\n+  \/\/ Since this is a native call, we know the proper exception handler\n+  \/\/ is the empty function. We just pop this frame and then jump to\n+  \/\/ forward_exception_entry. Z_R14 will contain the native caller's\n+  \/\/ return PC.\n+  __ bind(handle_pending_exception);\n+  __ pop_frame();\n+  __ load_const_optimized(Z_R1_scratch, StubRoutines::forward_exception_entry());\n+  __ restore_return_pc();\n+  __ z_br(Z_R1_scratch);\n+\n+  \/\/---------------------------------------------------------------------\n+  \/\/ Handler for a cache miss (out-of-line)\n+  \/\/---------------------------------------------------------------------\n+  __ call_ic_miss_handler(ic_miss, 0x77, 0, Z_R1_scratch);\n","filename":"src\/hotspot\/cpu\/s390\/sharedRuntime_s390.cpp","additions":36,"deletions":219,"binary":false,"changes":255,"status":"modified"},{"patch":"@@ -1239,34 +1239,0 @@\n-\/\/ Unpack an array argument into a pointer to the body and the length\n-\/\/ if the array is non-null, otherwise pass 0 for both.\n-static void unpack_array_argument(MacroAssembler* masm, VMRegPair reg, BasicType in_elem_type, VMRegPair body_arg, VMRegPair length_arg) {\n-  Register tmp_reg = rax;\n-  assert(!body_arg.first()->is_Register() || body_arg.first()->as_Register() != tmp_reg,\n-         \"possible collision\");\n-  assert(!length_arg.first()->is_Register() || length_arg.first()->as_Register() != tmp_reg,\n-         \"possible collision\");\n-\n-  \/\/ Pass the length, ptr pair\n-  Label is_null, done;\n-  VMRegPair tmp(tmp_reg->as_VMReg());\n-  if (reg.first()->is_stack()) {\n-    \/\/ Load the arg up from the stack\n-    simple_move32(masm, reg, tmp);\n-    reg = tmp;\n-  }\n-  __ testptr(reg.first()->as_Register(), reg.first()->as_Register());\n-  __ jccb(Assembler::equal, is_null);\n-  __ lea(tmp_reg, Address(reg.first()->as_Register(), arrayOopDesc::base_offset_in_bytes(in_elem_type)));\n-  simple_move32(masm, tmp, body_arg);\n-  \/\/ load the length relative to the body.\n-  __ movl(tmp_reg, Address(tmp_reg, arrayOopDesc::length_offset_in_bytes() -\n-                           arrayOopDesc::base_offset_in_bytes(in_elem_type)));\n-  simple_move32(masm, tmp, length_arg);\n-  __ jmpb(done);\n-  __ bind(is_null);\n-  \/\/ Pass zeros\n-  __ xorptr(tmp_reg, tmp_reg);\n-  simple_move32(masm, tmp, body_arg);\n-  simple_move32(masm, tmp, length_arg);\n-  __ bind(done);\n-}\n-\n@@ -1375,2 +1341,1 @@\n-                                                BasicType ret_type,\n-                                                address critical_entry) {\n+                                                BasicType ret_type) {\n@@ -1398,6 +1363,1 @@\n-  bool is_critical_native = true;\n-  address native_func = critical_entry;\n-  if (native_func == NULL) {\n-    native_func = method->native_function();\n-    is_critical_native = false;\n-  }\n+  address native_func = method->native_function();\n@@ -1416,13 +1376,1 @@\n-  int total_c_args = total_in_args;\n-  if (!is_critical_native) {\n-    total_c_args += 1;\n-    if (method->is_static()) {\n-      total_c_args++;\n-    }\n-  } else {\n-    for (int i = 0; i < total_in_args; i++) {\n-      if (in_sig_bt[i] == T_ARRAY) {\n-        total_c_args++;\n-      }\n-    }\n-  }\n+  int  total_c_args       = total_in_args + (method->is_static() ? 2 : 1);\n@@ -1435,5 +1383,4 @@\n-  if (!is_critical_native) {\n-    out_sig_bt[argc++] = T_ADDRESS;\n-    if (method->is_static()) {\n-      out_sig_bt[argc++] = T_OBJECT;\n-    }\n+  out_sig_bt[argc++] = T_ADDRESS;\n+  if (method->is_static()) {\n+    out_sig_bt[argc++] = T_OBJECT;\n+  }\n@@ -1441,24 +1388,2 @@\n-    for (int i = 0; i < total_in_args ; i++ ) {\n-      out_sig_bt[argc++] = in_sig_bt[i];\n-    }\n-  } else {\n-    in_elem_bt = NEW_RESOURCE_ARRAY(BasicType, total_in_args);\n-    SignatureStream ss(method->signature());\n-    for (int i = 0; i < total_in_args ; i++ ) {\n-      if (in_sig_bt[i] == T_ARRAY) {\n-        \/\/ Arrays are passed as int, elem* pair\n-        out_sig_bt[argc++] = T_INT;\n-        out_sig_bt[argc++] = T_ADDRESS;\n-        ss.skip_array_prefix(1);  \/\/ skip one '['\n-        assert(ss.is_primitive(), \"primitive type expected\");\n-        in_elem_bt[i] = ss.type();\n-      } else {\n-        out_sig_bt[argc++] = in_sig_bt[i];\n-        in_elem_bt[i] = T_VOID;\n-      }\n-      if (in_sig_bt[i] != T_VOID) {\n-        assert(in_sig_bt[i] == ss.type() ||\n-               in_sig_bt[i] == T_ARRAY, \"must match\");\n-        ss.next();\n-      }\n-    }\n+  for (int i = 0; i < total_in_args ; i++ ) {\n+    out_sig_bt[argc++] = in_sig_bt[i];\n@@ -1482,34 +1407,0 @@\n-  if (is_critical_native) {\n-    \/\/ Critical natives may have to call out so they need a save area\n-    \/\/ for register arguments.\n-    int double_slots = 0;\n-    int single_slots = 0;\n-    for ( int i = 0; i < total_in_args; i++) {\n-      if (in_regs[i].first()->is_Register()) {\n-        const Register reg = in_regs[i].first()->as_Register();\n-        switch (in_sig_bt[i]) {\n-          case T_ARRAY:  \/\/ critical array (uses 2 slots on LP64)\n-          case T_BOOLEAN:\n-          case T_BYTE:\n-          case T_SHORT:\n-          case T_CHAR:\n-          case T_INT:  single_slots++; break;\n-          case T_LONG: double_slots++; break;\n-          default:  ShouldNotReachHere();\n-        }\n-      } else if (in_regs[i].first()->is_XMMRegister()) {\n-        switch (in_sig_bt[i]) {\n-          case T_FLOAT:  single_slots++; break;\n-          case T_DOUBLE: double_slots++; break;\n-          default:  ShouldNotReachHere();\n-        }\n-      } else if (in_regs[i].first()->is_FloatRegister()) {\n-        ShouldNotReachHere();\n-      }\n-    }\n-    total_save_slots = double_slots * 2 + single_slots;\n-    \/\/ align the save area\n-    if (double_slots != 0) {\n-      stack_slots = align_up(stack_slots, 2);\n-    }\n-  }\n@@ -1694,1 +1585,1 @@\n-  int c_arg = is_critical_native ? 0 : (method->is_static() ? 2 : 1 );\n+  int c_arg = method->is_static() ? 2 : 1;\n@@ -1717,6 +1608,0 @@\n-        if (is_critical_native) {\n-          VMRegPair in_arg = in_regs[i];\n-          unpack_array_argument(masm, in_arg, in_elem_bt[i], out_regs[c_arg + 1], out_regs[c_arg]);\n-          c_arg++;\n-          break;\n-        }\n@@ -1724,1 +1609,0 @@\n-        assert(!is_critical_native, \"no oop arguments\");\n@@ -1756,1 +1640,1 @@\n-  if (method->is_static() && !is_critical_native) {\n+  if (method->is_static()) {\n@@ -1811,2 +1695,0 @@\n-    assert(!is_critical_native, \"unhandled\");\n-\n@@ -1864,3 +1746,2 @@\n-  if (!is_critical_native) {\n-    __ lea(rdx, Address(thread, in_bytes(JavaThread::jni_environment_offset())));\n-    __ movptr(Address(rsp, 0), rdx);\n+  __ lea(rdx, Address(thread, in_bytes(JavaThread::jni_environment_offset())));\n+  __ movptr(Address(rsp, 0), rdx);\n@@ -1868,3 +1749,2 @@\n-    \/\/ Now set thread in native\n-    __ movl(Address(thread, JavaThread::thread_state_offset()), _thread_in_native);\n-  }\n+  \/\/ Now set thread in native\n+  __ movl(Address(thread, JavaThread::thread_state_offset()), _thread_in_native);\n@@ -1903,11 +1783,0 @@\n-  \/\/ If this is a critical native, check for a safepoint or suspend request after the call.\n-  \/\/ If a safepoint is needed, transition to native, then to native_trans to handle\n-  \/\/ safepoints like the native methods that are not critical natives.\n-  if (is_critical_native) {\n-    Label needs_safepoint;\n-    __ safepoint_poll(needs_safepoint, thread, false \/* at_return *\/, false \/* in_nmethod *\/);\n-    __ cmpl(Address(thread, JavaThread::suspend_flags_offset()), 0);\n-    __ jcc(Assembler::equal, after_transition);\n-    __ bind(needs_safepoint);\n-  }\n-\n@@ -2046,4 +1915,3 @@\n-  if (!is_critical_native) {\n-    \/\/ reset handle block\n-    __ movptr(rcx, Address(thread, JavaThread::active_handles_offset()));\n-    __ movl(Address(rcx, JNIHandleBlock::top_offset_in_bytes()), NULL_WORD);\n+  \/\/ reset handle block\n+  __ movptr(rcx, Address(thread, JavaThread::active_handles_offset()));\n+  __ movl(Address(rcx, JNIHandleBlock::top_offset_in_bytes()), NULL_WORD);\n@@ -2051,4 +1919,3 @@\n-    \/\/ Any exception pending?\n-    __ cmpptr(Address(thread, in_bytes(Thread::pending_exception_offset())), (int32_t)NULL_WORD);\n-    __ jcc(Assembler::notEqual, exception_pending);\n-  }\n+  \/\/ Any exception pending?\n+  __ cmpptr(Address(thread, in_bytes(Thread::pending_exception_offset())), (int32_t)NULL_WORD);\n+  __ jcc(Assembler::notEqual, exception_pending);\n@@ -2168,3 +2035,2 @@\n-  if (!is_critical_native) {\n-    \/\/ Forward  the exception\n-    __ bind(exception_pending);\n+  \/\/ Forward  the exception\n+  __ bind(exception_pending);\n@@ -2172,2 +2038,2 @@\n-    \/\/ remove possible return value from FPU register stack\n-    __ empty_FPU_stack();\n+  \/\/ remove possible return value from FPU register stack\n+  __ empty_FPU_stack();\n@@ -2175,5 +2041,4 @@\n-    \/\/ pop our frame\n-    __ leave();\n-    \/\/ and forward the exception\n-    __ jump(RuntimeAddress(StubRoutines::forward_exception_entry()));\n-  }\n+  \/\/ pop our frame\n+  __ leave();\n+  \/\/ and forward the exception\n+  __ jump(RuntimeAddress(StubRoutines::forward_exception_entry()));\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_32.cpp","additions":29,"deletions":164,"binary":false,"changes":193,"status":"modified"},{"patch":"@@ -1238,40 +1238,0 @@\n-\/\/ Unpack an array argument into a pointer to the body and the length\n-\/\/ if the array is non-null, otherwise pass 0 for both.\n-static void unpack_array_argument(MacroAssembler* masm, VMRegPair reg, BasicType in_elem_type, VMRegPair body_arg, VMRegPair length_arg) {\n-  Register tmp_reg = rax;\n-  assert(!body_arg.first()->is_Register() || body_arg.first()->as_Register() != tmp_reg,\n-         \"possible collision\");\n-  assert(!length_arg.first()->is_Register() || length_arg.first()->as_Register() != tmp_reg,\n-         \"possible collision\");\n-\n-  __ block_comment(\"unpack_array_argument {\");\n-\n-  \/\/ Pass the length, ptr pair\n-  Label is_null, done;\n-  VMRegPair tmp;\n-  tmp.set_ptr(tmp_reg->as_VMReg());\n-  if (reg.first()->is_stack()) {\n-    \/\/ Load the arg up from the stack\n-    __ move_ptr(reg, tmp);\n-    reg = tmp;\n-  }\n-  __ testptr(reg.first()->as_Register(), reg.first()->as_Register());\n-  __ jccb(Assembler::equal, is_null);\n-  __ lea(tmp_reg, Address(reg.first()->as_Register(), arrayOopDesc::base_offset_in_bytes(in_elem_type)));\n-  __ move_ptr(tmp, body_arg);\n-  \/\/ load the length relative to the body.\n-  __ movl(tmp_reg, Address(tmp_reg, arrayOopDesc::length_offset_in_bytes() -\n-                           arrayOopDesc::base_offset_in_bytes(in_elem_type)));\n-  __ move32_64(tmp, length_arg);\n-  __ jmpb(done);\n-  __ bind(is_null);\n-  \/\/ Pass zeros\n-  __ xorptr(tmp_reg, tmp_reg);\n-  __ move_ptr(tmp, body_arg);\n-  __ move32_64(tmp, length_arg);\n-  __ bind(done);\n-\n-  __ block_comment(\"} unpack_array_argument\");\n-}\n-\n-\n@@ -1553,2 +1513,1 @@\n-                                                BasicType ret_type,\n-                                                address critical_entry) {\n+                                                BasicType ret_type) {\n@@ -1576,6 +1535,1 @@\n-  bool is_critical_native = true;\n-  address native_func = critical_entry;\n-  if (native_func == NULL) {\n-    native_func = method->native_function();\n-    is_critical_native = false;\n-  }\n+  address native_func = method->native_function();\n@@ -1595,13 +1549,1 @@\n-  int total_c_args = total_in_args;\n-  if (!is_critical_native) {\n-    total_c_args += 1;\n-    if (method->is_static()) {\n-      total_c_args++;\n-    }\n-  } else {\n-    for (int i = 0; i < total_in_args; i++) {\n-      if (in_sig_bt[i] == T_ARRAY) {\n-        total_c_args++;\n-      }\n-    }\n-  }\n+  int total_c_args = total_in_args + (method->is_static() ? 2 : 1);\n@@ -1614,5 +1556,4 @@\n-  if (!is_critical_native) {\n-    out_sig_bt[argc++] = T_ADDRESS;\n-    if (method->is_static()) {\n-      out_sig_bt[argc++] = T_OBJECT;\n-    }\n+  out_sig_bt[argc++] = T_ADDRESS;\n+  if (method->is_static()) {\n+    out_sig_bt[argc++] = T_OBJECT;\n+  }\n@@ -1620,24 +1561,2 @@\n-    for (int i = 0; i < total_in_args ; i++ ) {\n-      out_sig_bt[argc++] = in_sig_bt[i];\n-    }\n-  } else {\n-    in_elem_bt = NEW_RESOURCE_ARRAY(BasicType, total_in_args);\n-    SignatureStream ss(method->signature());\n-    for (int i = 0; i < total_in_args ; i++ ) {\n-      if (in_sig_bt[i] == T_ARRAY) {\n-        \/\/ Arrays are passed as int, elem* pair\n-        out_sig_bt[argc++] = T_INT;\n-        out_sig_bt[argc++] = T_ADDRESS;\n-        ss.skip_array_prefix(1);  \/\/ skip one '['\n-        assert(ss.is_primitive(), \"primitive type expected\");\n-        in_elem_bt[i] = ss.type();\n-      } else {\n-        out_sig_bt[argc++] = in_sig_bt[i];\n-        in_elem_bt[i] = T_VOID;\n-      }\n-      if (in_sig_bt[i] != T_VOID) {\n-        assert(in_sig_bt[i] == ss.type() ||\n-               in_sig_bt[i] == T_ARRAY, \"must match\");\n-        ss.next();\n-      }\n-    }\n+  for (int i = 0; i < total_in_args ; i++ ) {\n+    out_sig_bt[argc++] = in_sig_bt[i];\n@@ -1661,34 +1580,0 @@\n-  if (is_critical_native) {\n-    \/\/ Critical natives may have to call out so they need a save area\n-    \/\/ for register arguments.\n-    int double_slots = 0;\n-    int single_slots = 0;\n-    for ( int i = 0; i < total_in_args; i++) {\n-      if (in_regs[i].first()->is_Register()) {\n-        const Register reg = in_regs[i].first()->as_Register();\n-        switch (in_sig_bt[i]) {\n-          case T_BOOLEAN:\n-          case T_BYTE:\n-          case T_SHORT:\n-          case T_CHAR:\n-          case T_INT:  single_slots++; break;\n-          case T_ARRAY:  \/\/ specific to LP64 (7145024)\n-          case T_LONG: double_slots++; break;\n-          default:  ShouldNotReachHere();\n-        }\n-      } else if (in_regs[i].first()->is_XMMRegister()) {\n-        switch (in_sig_bt[i]) {\n-          case T_FLOAT:  single_slots++; break;\n-          case T_DOUBLE: double_slots++; break;\n-          default:  ShouldNotReachHere();\n-        }\n-      } else if (in_regs[i].first()->is_FloatRegister()) {\n-        ShouldNotReachHere();\n-      }\n-    }\n-    total_save_slots = double_slots * 2 + single_slots;\n-    \/\/ align the save area\n-    if (double_slots != 0) {\n-      stack_slots = align_up(stack_slots, 2);\n-    }\n-  }\n@@ -1889,4 +1774,1 @@\n-  \/\/ This may iterate in two different directions depending on the\n-  \/\/ kind of native it is.  The reason is that for regular JNI natives\n-  \/\/ the incoming and outgoing registers are offset upwards and for\n-  \/\/ critical natives they are offset down.\n+  \/\/ For JNI natives the incoming and outgoing registers are offset upwards.\n@@ -1898,8 +1780,3 @@\n-  if (!is_critical_native) {\n-    for (int i = total_in_args - 1, c_arg = total_c_args - 1; i >= 0; i--, c_arg--) {\n-      arg_order.push(i);\n-      arg_order.push(c_arg);\n-    }\n-  } else {\n-    \/\/ Compute a valid move order, using tmp_vmreg to break any cycles\n-    ComputeMoveOrder cmo(total_in_args, in_regs, total_c_args, out_regs, in_sig_bt, arg_order, tmp_vmreg);\n+  for (int i = total_in_args - 1, c_arg = total_c_args - 1; i >= 0; i--, c_arg--) {\n+    arg_order.push(i);\n+    arg_order.push(c_arg);\n@@ -1913,14 +1790,0 @@\n-    if (c_arg == -1) {\n-      assert(is_critical_native, \"should only be required for critical natives\");\n-      \/\/ This arg needs to be moved to a temporary\n-      __ mov(tmp_vmreg.first()->as_Register(), in_regs[i].first()->as_Register());\n-      in_regs[i] = tmp_vmreg;\n-      temploc = i;\n-      continue;\n-    } else if (i == -1) {\n-      assert(is_critical_native, \"should only be required for critical natives\");\n-      \/\/ Read from the temporary location\n-      assert(temploc != -1, \"must be valid\");\n-      i = temploc;\n-      temploc = -1;\n-    }\n@@ -1941,12 +1804,0 @@\n-        if (is_critical_native) {\n-          unpack_array_argument(masm, in_regs[i], in_elem_bt[i], out_regs[c_arg + 1], out_regs[c_arg]);\n-          c_arg++;\n-#ifdef ASSERT\n-          if (out_regs[c_arg].first()->is_Register()) {\n-            reg_destroyed[out_regs[c_arg].first()->as_Register()->encoding()] = true;\n-          } else if (out_regs[c_arg].first()->is_XMMRegister()) {\n-            freg_destroyed[out_regs[c_arg].first()->as_XMMRegister()->encoding()] = true;\n-          }\n-#endif\n-          break;\n-        }\n@@ -1954,1 +1805,0 @@\n-        assert(!is_critical_native, \"no oop arguments\");\n@@ -1988,24 +1838,19 @@\n-  if (!is_critical_native) {\n-    \/\/ point c_arg at the first arg that is already loaded in case we\n-    \/\/ need to spill before we call out\n-    c_arg = total_c_args - total_in_args;\n-\n-    if (method->is_static()) {\n-\n-      \/\/  load oop into a register\n-      __ movoop(oop_handle_reg, JNIHandles::make_local(method->method_holder()->java_mirror()));\n-\n-      \/\/ Now handlize the static class mirror it's known not-null.\n-      __ movptr(Address(rsp, klass_offset), oop_handle_reg);\n-      map->set_oop(VMRegImpl::stack2reg(klass_slot_offset));\n-\n-      \/\/ Now get the handle\n-      __ lea(oop_handle_reg, Address(rsp, klass_offset));\n-      \/\/ store the klass handle as second argument\n-      __ movptr(c_rarg1, oop_handle_reg);\n-      \/\/ and protect the arg if we must spill\n-      c_arg--;\n-    }\n-  } else {\n-    \/\/ For JNI critical methods we need to save all registers in save_args.\n-    c_arg = 0;\n+  \/\/ point c_arg at the first arg that is already loaded in case we\n+  \/\/ need to spill before we call out\n+  c_arg = total_c_args - total_in_args;\n+\n+  if (method->is_static()) {\n+\n+    \/\/  load oop into a register\n+    __ movoop(oop_handle_reg, JNIHandles::make_local(method->method_holder()->java_mirror()));\n+\n+    \/\/ Now handlize the static class mirror it's known not-null.\n+    __ movptr(Address(rsp, klass_offset), oop_handle_reg);\n+    map->set_oop(VMRegImpl::stack2reg(klass_slot_offset));\n+\n+    \/\/ Now get the handle\n+    __ lea(oop_handle_reg, Address(rsp, klass_offset));\n+    \/\/ store the klass handle as second argument\n+    __ movptr(c_rarg1, oop_handle_reg);\n+    \/\/ and protect the arg if we must spill\n+    c_arg--;\n@@ -2063,2 +1908,0 @@\n-    assert(!is_critical_native, \"unhandled\");\n-\n@@ -2118,2 +1961,1 @@\n-  if (!is_critical_native) {\n-    __ lea(c_rarg0, Address(r15_thread, in_bytes(JavaThread::jni_environment_offset())));\n+  __ lea(c_rarg0, Address(r15_thread, in_bytes(JavaThread::jni_environment_offset())));\n@@ -2121,3 +1963,2 @@\n-    \/\/ Now set thread in native\n-    __ movl(Address(r15_thread, JavaThread::thread_state_offset()), _thread_in_native);\n-  }\n+  \/\/ Now set thread in native\n+  __ movl(Address(r15_thread, JavaThread::thread_state_offset()), _thread_in_native);\n@@ -2151,11 +1992,0 @@\n-  \/\/ If this is a critical native, check for a safepoint or suspend request after the call.\n-  \/\/ If a safepoint is needed, transition to native, then to native_trans to handle\n-  \/\/ safepoints like the native methods that are not critical natives.\n-  if (is_critical_native) {\n-    Label needs_safepoint;\n-    __ safepoint_poll(needs_safepoint, r15_thread, false \/* at_return *\/, false \/* in_nmethod *\/);\n-    __ cmpl(Address(r15_thread, JavaThread::suspend_flags_offset()), 0);\n-    __ jcc(Assembler::equal, after_transition);\n-    __ bind(needs_safepoint);\n-  }\n-\n@@ -2282,5 +2112,3 @@\n-  if (!is_critical_native) {\n-    \/\/ reset handle block\n-    __ movptr(rcx, Address(r15_thread, JavaThread::active_handles_offset()));\n-    __ movl(Address(rcx, JNIHandleBlock::top_offset_in_bytes()), (int32_t)NULL_WORD);\n-  }\n+  \/\/ reset handle block\n+  __ movptr(rcx, Address(r15_thread, JavaThread::active_handles_offset()));\n+  __ movl(Address(rcx, JNIHandleBlock::top_offset_in_bytes()), (int32_t)NULL_WORD);\n@@ -2292,5 +2120,3 @@\n-  if (!is_critical_native) {\n-    \/\/ Any exception pending?\n-    __ cmpptr(Address(r15_thread, in_bytes(Thread::pending_exception_offset())), (int32_t)NULL_WORD);\n-    __ jcc(Assembler::notEqual, exception_pending);\n-  }\n+  \/\/ Any exception pending?\n+  __ cmpptr(Address(r15_thread, in_bytes(Thread::pending_exception_offset())), (int32_t)NULL_WORD);\n+  __ jcc(Assembler::notEqual, exception_pending);\n@@ -2304,3 +2130,2 @@\n-  if (!is_critical_native) {\n-    \/\/ forward the exception\n-    __ bind(exception_pending);\n+  \/\/ forward the exception\n+  __ bind(exception_pending);\n@@ -2308,3 +2133,2 @@\n-    \/\/ and forward the exception\n-    __ jump(RuntimeAddress(StubRoutines::forward_exception_entry()));\n-  }\n+  \/\/ and forward the exception\n+  __ jump(RuntimeAddress(StubRoutines::forward_exception_entry()));\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":45,"deletions":221,"binary":false,"changes":266,"status":"modified"},{"patch":"@@ -76,2 +76,1 @@\n-                                                BasicType ret_type,\n-                                                address critical_entry) {\n+                                                BasicType ret_type) {\n","filename":"src\/hotspot\/cpu\/zero\/sharedRuntime_zero.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -119,1 +119,0 @@\n-  UNSUPPORTED_OPTION(CriticalJNINatives);\n","filename":"src\/hotspot\/cpu\/zero\/vm_version_zero.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -185,18 +185,0 @@\n-\n-char* NativeLookup::critical_jni_name(const methodHandle& method) {\n-  stringStream st;\n-  \/\/ Prefix\n-  st.print(\"JavaCritical_\");\n-  \/\/ Klass name\n-  if (!map_escaped_name_on(&st, method->klass_name())) {\n-    return NULL;\n-  }\n-  st.print(\"_\");\n-  \/\/ Method name\n-  if (!map_escaped_name_on(&st, method->name())) {\n-    return NULL;\n-  }\n-  return st.as_string();\n-}\n-\n-\n@@ -335,6 +317,0 @@\n-address NativeLookup::lookup_critical_style(void* dll, const char* pure_name, const char* long_name, int args_size, bool os_style) {\n-  const char* jni_name = compute_complete_jni_name(pure_name, long_name, args_size, os_style);\n-  assert(dll != NULL, \"dll must be loaded\");\n-  return (address)os::dll_lookup(dll, jni_name);\n-}\n-\n@@ -384,47 +360,0 @@\n-\/\/ Check all the formats of native implementation name to see if there is one\n-\/\/ for the specified method.\n-address NativeLookup::lookup_critical_entry(const methodHandle& method) {\n-  assert(CriticalJNINatives, \"or should not be here\");\n-\n-  if (method->is_synchronized() ||\n-      !method->is_static()) {\n-    \/\/ Only static non-synchronized methods are allowed\n-    return NULL;\n-  }\n-\n-  ResourceMark rm;\n-\n-  Symbol* signature = method->signature();\n-  for (int end = 0; end < signature->utf8_length(); end++) {\n-    if (signature->char_at(end) == 'L') {\n-      \/\/ Don't allow object types\n-      return NULL;\n-    }\n-  }\n-\n-  \/\/ Compute argument size\n-  int args_size = method->size_of_parameters();\n-  for (SignatureStream ss(signature); !ss.at_return_type(); ss.next()) {\n-    if (ss.is_array()) {\n-      args_size += T_INT_size; \/\/ array length parameter\n-    }\n-  }\n-\n-  \/\/ dll handling requires I\/O. Don't do that while in _thread_in_vm (safepoint may get requested).\n-  ThreadToNativeFromVM thread_in_native(JavaThread::current());\n-\n-  void* dll = dll_load(method);\n-  address entry = NULL;\n-\n-  if (dll != NULL) {\n-    entry = lookup_critical_style(dll, method, args_size);\n-    \/\/ Close the handle to avoid keeping the library alive if the native method holder is unloaded.\n-    \/\/ This is fine because the library is still kept alive by JNI (see JVM_LoadLibrary). As soon\n-    \/\/ as the holder class and the library are unloaded (see JVM_UnloadLibrary), the native wrapper\n-    \/\/ that calls 'critical_entry' becomes unreachable and is unloaded as well.\n-    os::dll_unload(dll);\n-  }\n-\n-  return entry; \/\/ NULL indicates not found\n-}\n-\n@@ -449,38 +378,0 @@\n-address NativeLookup::lookup_critical_style(void* dll, const methodHandle& method, int args_size) {\n-  address entry = NULL;\n-  const char* critical_name = critical_jni_name(method);\n-  if (critical_name == NULL) {\n-    \/\/ JNI name mapping rejected this method so return\n-    \/\/ NULL to indicate UnsatisfiedLinkError should be thrown.\n-    return NULL;\n-  }\n-\n-  \/\/ 1) Try JNI short style\n-  entry = lookup_critical_style(dll, critical_name, \"\",        args_size, true);\n-  if (entry != NULL) {\n-    return entry;\n-  }\n-\n-  const char* long_name = long_jni_name(method);\n-  if (long_name == NULL) {\n-    \/\/ JNI name mapping rejected this method so return\n-    \/\/ NULL to indicate UnsatisfiedLinkError should be thrown.\n-    return NULL;\n-  }\n-\n-  \/\/ 2) Try JNI long style\n-  entry = lookup_critical_style(dll, critical_name, long_name, args_size, true);\n-  if (entry != NULL) {\n-    return entry;\n-  }\n-\n-  \/\/ 3) Try JNI short style without os prefix\/suffix\n-  entry = lookup_critical_style(dll, critical_name, \"\",        args_size, false);\n-  if (entry != NULL) {\n-    return entry;\n-  }\n-\n-  \/\/ 4) Try JNI long style without os prefix\/suffix\n-  return lookup_critical_style(dll, critical_name, long_name, args_size, false);\n-}\n-\n","filename":"src\/hotspot\/share\/prims\/nativeLookup.cpp","additions":0,"deletions":109,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -38,2 +38,0 @@\n-  static address lookup_critical_style(void* dll, const char* pure_name, const char* long_name, int args_size, bool os_style);\n-  static address lookup_critical_style(void* dll, const methodHandle& method, int args_size);\n@@ -50,1 +48,0 @@\n-  static char* critical_jni_name(const methodHandle& method);\n@@ -54,1 +51,0 @@\n-  static address lookup_critical_entry(const methodHandle& method);\n","filename":"src\/hotspot\/share\/prims\/nativeLookup.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -317,3 +317,0 @@\n-  product(bool, CriticalJNINatives, false,                                  \\\n-          \"(Deprecated) Check for critical JNI entry points\")               \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3011,1 +3011,0 @@\n-  address critical_entry = NULL;\n@@ -3017,5 +3016,0 @@\n-  if (CriticalJNINatives && !method->is_method_handle_intrinsic()) {\n-    \/\/ We perform the I\/O with transition to native before acquiring AdapterHandlerLibrary_lock.\n-    critical_entry = NativeLookup::lookup_critical_entry(method);\n-  }\n-\n@@ -3064,1 +3058,1 @@\n-      nm = SharedRuntime::generate_native_wrapper(&_masm, method, compile_id, sig_bt, regs, ret_type, critical_entry);\n+      nm = SharedRuntime::generate_native_wrapper(&_masm, method, compile_id, sig_bt, regs, ret_type);\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -477,2 +477,1 @@\n-  \/\/ is a JNI critical method, or a compiled method handle adapter,\n-  \/\/ such as _invokeBasic, _linkToVirtual, etc.\n+  \/\/ is a compiled method handle adapter, such as _invokeBasic, _linkToVirtual, etc.\n@@ -484,2 +483,1 @@\n-                                          BasicType ret_type,\n-                                          address critical_entry);\n+                                          BasicType ret_type);\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -214,1 +214,0 @@\n-  -gc\/CriticalNativeArgs.java \\\n@@ -229,3 +228,1 @@\n-tier2_gc_epsilon = \\\n-  gc\/CriticalNativeArgs.java \\\n-  gc\/stress\/CriticalNativeStress.java\n+tier2_gc_epsilon =\n@@ -270,2 +267,0 @@\n-  gc\/CriticalNativeArgs.java \\\n-  gc\/stress\/CriticalNativeStress.java \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1,61 +0,0 @@\n-\/*\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/* @test\n- * @bug 8167409\n- * @requires (os.arch != \"aarch64\") & (os.arch != \"arm\") & (vm.flavor != \"zero\")\n- * @run main\/othervm\/native -Xcomp -XX:+CriticalJNINatives compiler.runtime.criticalnatives.argumentcorruption.CheckLongArgs\n- *\/\n-package compiler.runtime.criticalnatives.argumentcorruption;\n-public class CheckLongArgs {\n-    static {\n-        System.loadLibrary(\"CNCheckLongArgs\");\n-    }\n-    static native void m1(long a1, long a2, long a3, long a4,  long a5, long a6, long a7, long a8, byte[] result);\n-    static native void m2(long a1, int[] a2, long a3, int[] a4, long a5, int[] a6, long a7, int[] a8, long a9, byte[] result);\n-    public static void main(String args[]) throws Exception {\n-        test();\n-    }\n-    private static void test() throws Exception {\n-        int[] l1 = { 1111, 2222, 3333 };\n-        int[] l2 = { 4444, 5555, 6666 };\n-        int[] l3 = { 7777, 8888, 9999 };\n-        int[] l4 = { 1010, 2020, 3030 };\n-        byte[] result = { -1 };\n-        m1(1111111122222222L, 3333333344444444L, 5555555566666666L, 7777777788888888L, 9999999900000000L, 1212121234343434L,\n-           5656565678787878L, 9090909012121212L, result);\n-        check(result[0]);\n-        result[0] = -1;\n-        m2(1111111122222222L, l1, 3333333344444444L, l2, 5555555566666666L, l3, 7777777788888888L, l4, 9999999900000000L, result);\n-        check(result[0]);\n-    }\n-    private static void check(byte result) throws Exception {\n-        if (result != 2) {\n-            if (result == 1) {\n-              throw new Exception(\"critical native arguments mismatch\");\n-            }\n-            throw new Exception(\"critical native lookup failed\");\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/runtime\/criticalnatives\/argumentcorruption\/CheckLongArgs.java","additions":0,"deletions":61,"binary":false,"changes":61,"status":"deleted"},{"patch":"@@ -1,30 +0,0 @@\n-#include \"jni.h\"\n-JNIEXPORT void JNICALL JavaCritical_compiler_runtime_criticalnatives_argumentcorruption_CheckLongArgs_m1\n-  (jlong a1, jlong a2, jlong a3, jlong a4, jlong a5, jlong a6, jlong a7, jlong a8,jint result_length,jbyte* result) {\n-\n-  if (a1 != 1111111122222222LL || a2 != 3333333344444444LL || a3 != 5555555566666666LL || a4 != 7777777788888888LL ||\n-      a5 != 9999999900000000LL || a6 != 1212121234343434LL || a7 != 5656565678787878LL || a8 != 9090909012121212LL ||\n-      result_length != 1 || result[0] != -1) {\n-    result[0] = 1;\n-  } else {\n-    result[0] = 2;\n-  }\n-}\n-\n-JNIEXPORT void JNICALL JavaCritical_compiler_runtime_criticalnatives_argumentcorruption_CheckLongArgs_m2\n-  (jlong a1, jint a2_length, jint* a2, jlong a3, jint a4_length, jint* a4, jlong a5, jint a6_length, jint* a6, jlong a7,\n-   jint a8_length, jint* a8, jlong a9, jint result_length, jbyte* result) {\n-  if (a1 != 1111111122222222LL || a2_length != 3 || a2[0] != 1111 || a3 != 3333333344444444LL || a4_length != 3 || a4[0] != 4444 ||\n-      a5 != 5555555566666666LL || a6_length != 3 || a6[0] != 7777 || a7 != 7777777788888888LL || a8_length != 3 || a8[0] != 1010 || a9 != 9999999900000000LL ||\n-      result_length != 1 || result[0] != -1) {\n-    result[0] = 1;\n-  } else {\n-    result[0] = 2;\n-  }\n-}\n-\n-JNIEXPORT void JNICALL Java_compiler_runtime_criticalnatives_argumentcorruption_CheckLongArgs_m1\n-  (JNIEnv * env, jclass jclazz, jlong a3, jlong a4, jlong a5, jlong a6, jlong a7, jlong a8, jlong a9, jlong a10, jbyteArray result) {}\n-\n-JNIEXPORT void JNICALL Java_compiler_runtime_criticalnatives_argumentcorruption_CheckLongArgs_m2\n-  (JNIEnv * env, jclass jclazz, jlong a3, jintArray a4, jlong a5, jintArray a6, jlong a7, jintArray a8, jlong a9, jintArray a10, jlong a11, jbyteArray result) {}\n","filename":"test\/hotspot\/jtreg\/compiler\/runtime\/criticalnatives\/argumentcorruption\/libCNCheckLongArgs.c","additions":0,"deletions":30,"binary":false,"changes":30,"status":"deleted"},{"patch":"@@ -1,60 +0,0 @@\n-\/*\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/* @test\n- * @bug 8167408\n- * @requires (os.arch != \"aarch64\") & (os.arch != \"arm\") & (vm.flavor != \"zero\")\n- * @run main\/othervm\/native -Xcomp -XX:+CriticalJNINatives compiler.runtime.criticalnatives.lookup.LookUp\n- *\/\n-package compiler.runtime.criticalnatives.lookup;\n-public class LookUp {\n-    static {\n-        System.loadLibrary(\"CNLookUp\");\n-    }\n-    static native void m1(byte a1, long a2, char a3, int a4,  float a5, double a6, byte[] result);\n-    static native void m2(int a1, int[] a2, long a3, long[] a4, float a5,float[] a6, double a7, double[] a8, byte result[]);\n-    public static void main(String args[]) throws Exception {\n-        test();\n-    }\n-    private static void test() throws Exception {\n-        int[] l1 = { 1111, 2222, 3333 };\n-        long[] l2 = { 4444L, 5555L, 6666L };\n-        float[] l3 = { 7777.0F, 8888.0F, 9999.0F };\n-        double[] l4 = { 4545.0D, 5656.0D, 6767.0D };\n-        byte[] result = { -1 };\n-        m1((byte)0xA, 4444444455555555L, 'A', 12345678, 343434.0F, 6666666677777777.0D, result);\n-        check(result[0]);\n-        result[0] = -1;\n-        m2(12345678, l1, 4444444455555555L, l2, 343434.0F, l3, 6666666677777777.0D, l4, result);\n-        check(result[0]);\n-    }\n-    private static void check(byte result) throws Exception {\n-        if (result != 2) {\n-            if (result == 1) {\n-              throw new Exception(\"critical native arguments mismatch\");\n-            }\n-            throw new Exception(\"critical native lookup failed\");\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/runtime\/criticalnatives\/lookup\/LookUp.java","additions":0,"deletions":60,"binary":false,"changes":60,"status":"deleted"},{"patch":"@@ -1,35 +0,0 @@\n-#include \"jni.h\"\n-JNIEXPORT void JNICALL JavaCritical_compiler_runtime_criticalnatives_lookup_LookUp_m1\n-  (jbyte a1, jlong a2, jchar a3, jint a4, jfloat a5, jdouble a6, jint result_length, jbyte* result) {\n-  jint l1 = (jint) a5;\n-  jlong l2 = (jlong) a6;\n-\n-  if (a1 != 0xA || a2 != 4444444455555555LL || a3 != 0x41 || a4 != 12345678 || l1 != 343434 || l2 != 6666666677777777LL ||\n-      result_length != 1 || result[0] != -1) {\n-    result[0] = 1;\n-  } else {\n-    result[0] = 2;\n-  }\n-}\n-\n-JNIEXPORT void JNICALL JavaCritical_compiler_runtime_criticalnatives_lookup_LookUp_m2\n-  (jint a1, jint a2_length, jint* a2, jlong a3, jint a4_length, jlong* a4, jfloat a5, jint a6_length, jfloat* a6, jdouble a7,\n-   jint a8_length, jdouble* a8, jint result_length, jbyte* result) {\n-  jint l1 = (jint) a5;\n-  jlong l2 = (jlong) a7;\n-\n-  if (a1 != 12345678 || a2_length != 3 || a2[0] != 1111 || a3 != 4444444455555555LL || a4_length != 3 || a4[0] != 4444 ||\n-      l1 != 343434 ||  a6_length != 3 ||  7777 != (jint)a6[0] || l2 != 6666666677777777LL || a8_length != 3 || 4545 != (jlong)a8[0] ||\n-      result_length != 1 || result[0] != -1) {\n-    result[0] = 1;\n-  } else {\n-    result[0] = 2;\n-  }\n-}\n-\n-JNIEXPORT void JNICALL Java_compiler_runtime_criticalnatives_lookup_LookUp_m1\n-  (JNIEnv * env, jclass jclazz, jbyte a3, jlong a4, jchar a5, jint a6, jfloat a7, jdouble a8, jbyteArray result) {}\n-\n-JNIEXPORT void JNICALL Java_compiler_runtime_criticalnatives_lookup_LookUp_m2\n-  (JNIEnv * env, jclass jclazz, jint a3, jintArray a4, jlong a5, jlongArray a6, jfloat a7, jfloatArray a8, jdouble a9, jdoubleArray a10, jbyteArray result) {}\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/runtime\/criticalnatives\/lookup\/libCNLookUp.c","additions":0,"deletions":35,"binary":false,"changes":35,"status":"deleted"},{"patch":"@@ -1,36 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Red Hat, Inc. and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package gc;\n-\n-public class CriticalNative {\n-    static {\n-        System.loadLibrary(\"CriticalNative\");\n-    }\n-\n-    public static native boolean isNull(int[] a);\n-    public static native long sum1(long[] a);\n-    \/\/ More than 6 parameters\n-    public static native long sum2(long a1, int[] a2, int[] a3, long[] a4, int[] a5);\n-}\n","filename":"test\/hotspot\/jtreg\/gc\/CriticalNative.java","additions":0,"deletions":36,"binary":false,"changes":36,"status":"deleted"},{"patch":"@@ -1,109 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2019, Red Hat, Inc. and\/or its affiliates.\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-package gc;\n-\n-\/*\n- * @test CriticalNativeStressEpsilon\n- * @bug 8199868\n- * @library \/\n- * @requires os.arch ==\"x86_64\" | os.arch == \"amd64\" | os.arch==\"x86\" | os.arch==\"i386\"\n- * @requires vm.gc.Epsilon\n- * @summary test argument unpacking nmethod wrapper of critical native method\n- * @run main\/othervm\/native -XX:+UnlockExperimentalVMOptions -XX:+UseEpsilonGC -Xcomp -Xmx256M\n- *                          -XX:-CriticalJNINatives\n- *                          gc.CriticalNativeArgs\n- * @run main\/othervm\/native -XX:+UnlockExperimentalVMOptions -XX:+UseEpsilonGC -Xcomp -Xmx256M\n- *                          -XX:+CriticalJNINatives\n- *                          gc.CriticalNativeArgs\n- *\/\n-\n-\/*\n- * @test CriticalNativeStressShenandoah\n- * @bug 8199868\n- * @library \/\n- * @requires os.arch ==\"x86_64\" | os.arch == \"amd64\" | os.arch==\"x86\" | os.arch==\"i386\"\n- * @requires vm.gc.Shenandoah\n- * @summary test argument unpacking nmethod wrapper of critical native method\n- *\n- * @run main\/othervm\/native -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xcomp -Xmx512M\n- *                          -XX:+UseShenandoahGC\n- *                          -XX:-CriticalJNINatives\n- *                          gc.CriticalNativeArgs\n- * @run main\/othervm\/native -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xcomp -Xmx512M\n- *                          -XX:+UseShenandoahGC\n- *                          -XX:+CriticalJNINatives\n- *                          gc.CriticalNativeArgs\n- *\n- * @run main\/othervm\/native -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xcomp -Xmx512M\n- *                          -XX:+UseShenandoahGC -XX:ShenandoahGCMode=passive -XX:+ShenandoahDegeneratedGC\n- *                          -XX:+CriticalJNINatives\n- *                          gc.CriticalNativeArgs\n- * @run main\/othervm\/native -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xcomp -Xmx512M\n- *                          -XX:+UseShenandoahGC -XX:ShenandoahGCMode=passive -XX:-ShenandoahDegeneratedGC\n- *                          -XX:+CriticalJNINatives\n- *                          gc.CriticalNativeArgs\n- *\n- * @run main\/othervm\/native -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xcomp -Xmx512M\n- *                          -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=aggressive\n- *                          -XX:+CriticalJNINatives\n- *                          gc.CriticalNativeArgs\n- *\n- * @run main\/othervm\/native -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xcomp -Xmx512M\n- *                          -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu\n- *                          -XX:+CriticalJNINatives\n- *                          gc.CriticalNativeArgs\n- * @run main\/othervm\/native -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -Xcomp -Xmx512M\n- *                          -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu -XX:ShenandoahGCHeuristics=aggressive\n- *                          -XX:+CriticalJNINatives\n- *                          gc.CriticalNativeArgs\n- *\/\n-\n-\/*\n- * @test CriticalNativeStress\n- * @bug 8199868 8233343\n- * @library \/\n- * @requires os.arch ==\"x86_64\" | os.arch == \"amd64\" | os.arch==\"x86\" | os.arch==\"i386\" | os.arch==\"ppc64\" | os.arch==\"ppc64le\" | os.arch==\"s390x\"\n- * @summary test argument unpacking nmethod wrapper of critical native method\n- * @run main\/othervm\/native -Xcomp -Xmx512M\n- *                          -XX:-CriticalJNINatives\n- *                          gc.CriticalNativeArgs\n- * @run main\/othervm\/native -Xcomp -Xmx512M\n- *                          -XX:+CriticalJNINatives\n- *                          gc.CriticalNativeArgs\n- *\/\n-public class CriticalNativeArgs {\n-    public static void main(String[] args) {\n-        int[] arr = new int[2];\n-\n-        if (CriticalNative.isNull(arr)) {\n-            throw new RuntimeException(\"Should not be null\");\n-        }\n-\n-        if (!CriticalNative.isNull(null)) {\n-            throw new RuntimeException(\"Should be null\");\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/gc\/CriticalNativeArgs.java","additions":0,"deletions":109,"binary":false,"changes":109,"status":"deleted"},{"patch":"@@ -1,130 +0,0 @@\n-\/*\n- * Copyright (c) 2018, Red Hat, Inc. and\/or its affiliates.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"jni.h\"\n-\n-JNIEXPORT jlong JNICALL JavaCritical_gc_CriticalNative_sum1\n-  (jint length, jlong* a) {\n-  jlong sum = 0;\n-  jint index;\n-  for (index = 0; index < length; index ++) {\n-    sum += a[index];\n-  }\n-\n-  return sum;\n-}\n-\n-JNIEXPORT jlong JNICALL  JavaCritical_gc_CriticalNative_sum2\n-  (jlong a1, jint a2_length, jint* a2, jint a4_length, jint* a4, jint a6_length, jlong* a6, jint a8_length, jint* a8) {\n-  jlong sum = a1;\n-  jint index;\n-  for (index = 0; index < a2_length; index ++) {\n-    sum += a2[index];\n-  }\n-\n-  for (index = 0; index < a4_length; index ++) {\n-    sum += a4[index];\n-  }\n-\n-  for (index = 0; index < a6_length; index ++) {\n-    sum += a6[index];\n-  }\n-\n-  for (index = 0; index < a8_length; index ++) {\n-    sum += a8[index];\n-  }\n-  return sum;\n-}\n-\n-JNIEXPORT jlong JNICALL Java_gc_CriticalNative_sum1\n-  (JNIEnv *env, jclass jclazz, jlongArray a) {\n-  jlong sum = 0;\n-  jsize len = (*env)->GetArrayLength(env, a);\n-  jsize index;\n-  jlong* arr = (jlong*)(*env)->GetPrimitiveArrayCritical(env, a, 0);\n-  for (index = 0; index < len; index ++) {\n-    sum += arr[index];\n-  }\n-\n-  (*env)->ReleasePrimitiveArrayCritical(env, a, arr, 0);\n-  return sum;\n-}\n-\n-JNIEXPORT jlong JNICALL Java_gc_CriticalNative_sum2\n-  (JNIEnv *env, jclass jclazz, jlong a1, jintArray a2, jintArray a3, jlongArray a4, jintArray a5) {\n-  jlong sum = a1;\n-  jsize index;\n-  jsize len;\n-  jint* a2_arr;\n-  jint* a3_arr;\n-  jlong* a4_arr;\n-  jint* a5_arr;\n-\n-  len = (*env)->GetArrayLength(env, a2);\n-  a2_arr = (jint*)(*env)->GetPrimitiveArrayCritical(env, a2, 0);\n-  for (index = 0; index < len; index ++) {\n-    sum += a2_arr[index];\n-  }\n-  (*env)->ReleasePrimitiveArrayCritical(env, a2, a2_arr, 0);\n-\n-  len = (*env)->GetArrayLength(env, a3);\n-  a3_arr = (jint*)(*env)->GetPrimitiveArrayCritical(env, a3, 0);\n-  for (index = 0; index < len; index ++) {\n-    sum += a3_arr[index];\n-  }\n-  (*env)->ReleasePrimitiveArrayCritical(env, a3, a3_arr, 0);\n-\n-  len = (*env)->GetArrayLength(env, a4);\n-  a4_arr = (jlong*)(*env)->GetPrimitiveArrayCritical(env, a4, 0);\n-  for (index = 0; index < len; index ++) {\n-    sum += a4_arr[index];\n-  }\n-  (*env)->ReleasePrimitiveArrayCritical(env, a4, a4_arr, 0);\n-\n-  len = (*env)->GetArrayLength(env, a5);\n-  a5_arr = (jint*)(*env)->GetPrimitiveArrayCritical(env, a5, 0);\n-  for (index = 0; index < len; index ++) {\n-    sum += a5_arr[index];\n-  }\n-  (*env)->ReleasePrimitiveArrayCritical(env, a5, a5_arr, 0);\n-\n-  return sum;\n-}\n-\n-\n-JNIEXPORT jboolean JNICALL JavaCritical_gc_CriticalNative_isNull\n-  (jint length, jint* a) {\n-  return (a == NULL) && (length == 0);\n-}\n-\n-JNIEXPORT jboolean JNICALL Java_gc_CriticalNative_isNull\n-  (JNIEnv *env, jclass jclazz, jintArray a) {\n-  if (a == NULL) return JNI_TRUE;\n-  jsize len = (*env)->GetArrayLength(env, a);\n-  jint* arr = (jint*)(*env)->GetPrimitiveArrayCritical(env, a, 0);\n-  jboolean is_null = (arr == NULL) && (len == 0);\n-  (*env)->ReleasePrimitiveArrayCritical(env, a, arr, 0);\n-  return is_null;\n-}\n-\n","filename":"test\/hotspot\/jtreg\/gc\/libCriticalNative.c","additions":0,"deletions":130,"binary":false,"changes":130,"status":"deleted"},{"patch":"@@ -1,226 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2019, Red Hat, Inc. and\/or its affiliates.\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-package gc.stress;\n-\n-import java.util.Random;\n-\n-import gc.CriticalNative;\n-import jdk.test.lib.Utils;\n-\n-\/*\n- * @test CriticalNativeStressEpsilon\n- * @key randomness\n- * @bug 8199868\n- * @library \/ \/test\/lib\n- * @requires os.arch ==\"x86_64\" | os.arch == \"amd64\" | os.arch==\"x86\" | os.arch==\"i386\"\n- * @requires vm.gc.Epsilon\n- * @summary test argument pinning by nmethod wrapper of critical native method\n- * @run main\/othervm\/native -XX:+UnlockExperimentalVMOptions -XX:+UseEpsilonGC -Xcomp -Xmx1G -XX:+CriticalJNINatives gc.stress.CriticalNativeStress\n- *\/\n-\n-\/*\n- * @test CriticalNativeStressShenandoah\n- * @key randomness\n- * @bug 8199868\n- * @library \/ \/test\/lib\n- * @requires os.arch ==\"x86_64\" | os.arch == \"amd64\" | os.arch==\"x86\" | os.arch==\"i386\"\n- * @requires vm.gc.Shenandoah\n- * @summary test argument pinning by nmethod wrapper of critical native method\n- * @run main\/othervm\/native -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=passive    -XX:-ShenandoahDegeneratedGC -Xcomp -Xmx512M -XX:+CriticalJNINatives gc.stress.CriticalNativeStress\n- * @run main\/othervm\/native -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=passive    -XX:+ShenandoahDegeneratedGC -Xcomp -Xmx512M -XX:+CriticalJNINatives gc.stress.CriticalNativeStress\n- *\n- * @run main\/othervm\/native -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=aggressive -Xcomp -Xmx512M -XX:+CriticalJNINatives gc.stress.CriticalNativeStress\n- * @run main\/othervm\/native -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC                                       -Xcomp -Xmx256M -XX:+CriticalJNINatives gc.stress.CriticalNativeStress\n- * @run main\/othervm\/native -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu        -Xcomp -Xmx512M -XX:+CriticalJNINatives gc.stress.CriticalNativeStress\n- * @run main\/othervm\/native -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu -XX:ShenandoahGCHeuristics=aggressive -Xcomp -Xmx512M -XX:+CriticalJNINatives gc.stress.CriticalNativeStress\n- *\/\n-\n-\/*\n- * @test CriticalNativeStress\n- * @key randomness\n- * @bug 8199868 8233343\n- * @library \/ \/test\/lib\n- * @requires os.arch ==\"x86_64\" | os.arch == \"amd64\" | os.arch==\"x86\" | os.arch==\"i386\" | os.arch==\"ppc64\" | os.arch==\"ppc64le\" | os.arch==\"s390x\"\n- * @summary test argument unpacking nmethod wrapper of critical native method\n- * @run main\/othervm\/native -Xcomp -Xmx512M -XX:+CriticalJNINatives gc.stress.CriticalNativeStress\n- *\/\n-\n-public class CriticalNativeStress {\n-    \/\/ CYCLES and THREAD_PER_CASE are used to tune the tests for different GC settings,\n-    \/\/ so that they can execrise enough GC cycles and not OOM\n-    private static int CYCLES = Integer.getInteger(\"cycles\", 3);\n-    private static int THREAD_PER_CASE = Integer.getInteger(\"threadPerCase\", 1);\n-\n-    static long sum(long[] a) {\n-        long sum = 0;\n-        for (int index = 0; index < a.length; index ++) {\n-            sum += a[index];\n-        }\n-        return sum;\n-    }\n-\n-    static long sum(int[] a) {\n-        long sum = 0;\n-        for (int index = 0; index < a.length; index ++) {\n-            sum += a[index];\n-        }\n-        return sum;\n-    }\n-\n-    private static volatile String garbage_array[];\n-\n-    \/\/ GC potentially moves arrays passed to critical native methods\n-    \/\/ if they are not pinned correctly.\n-    \/\/ Create enough garbages to exercise GC cycles, verify\n-    \/\/ the arrays are pinned correctly.\n-    static void create_garbage(int len) {\n-        len = Math.max(len, 1024);\n-        String array[] = new String[len];\n-        for (int index = 0; index < len; index ++) {\n-            array[index] = \"String \" + index;\n-        }\n-        garbage_array = array;\n-    }\n-\n-    \/\/ Two test cases with different method signatures:\n-    \/\/ Tests generate arbitrary length of arrays with\n-    \/\/ arbitrary values, then calcuate sum of the array\n-    \/\/ elements with critical native JNI methods and java\n-    \/\/ methods, and compare the results for correctness.\n-    static void run_test_case1(Random rand) {\n-        \/\/ Create testing arary with arbitrary length and\n-        \/\/ values\n-        int length = rand.nextInt(50) + 1;\n-        long[] arr = new long[length];\n-        for (int index = 0; index < length; index ++) {\n-            arr[index] = rand.nextLong() % 1002;\n-        }\n-\n-        \/\/ Generate garbages to trigger GCs\n-        for (int index = 0; index < length; index ++) {\n-            create_garbage(index);\n-        }\n-\n-        \/\/ Compare results for correctness.\n-        long native_sum = CriticalNative.sum1(arr);\n-        long java_sum = sum(arr);\n-        if (native_sum != java_sum) {\n-            StringBuffer sb = new StringBuffer(\"Sums do not match: native = \")\n-                .append(native_sum).append(\" java = \").append(java_sum);\n-\n-            throw new RuntimeException(sb.toString());\n-        }\n-    }\n-\n-    static void run_test_case2(Random rand) {\n-        \/\/ Create testing arary with arbitrary length and\n-        \/\/ values\n-        int index;\n-        long a1 = rand.nextLong() % 1025;\n-\n-        int a2_length = rand.nextInt(50) + 1;\n-        int[] a2 = new int[a2_length];\n-        for (index = 0; index < a2_length; index ++) {\n-            a2[index] = rand.nextInt(106);\n-        }\n-\n-        int a3_length = rand.nextInt(150) + 1;\n-        int[] a3 = new int[a3_length];\n-        for (index = 0; index < a3_length; index ++) {\n-            a3[index] = rand.nextInt(3333);\n-        }\n-\n-        int a4_length = rand.nextInt(200) + 1;\n-        long[] a4 = new long[a4_length];\n-        for (index = 0; index < a4_length; index ++) {\n-            a4[index] = rand.nextLong() % 122;\n-        }\n-\n-        int a5_length = rand.nextInt(350) + 1;\n-        int[] a5 = new int[a5_length];\n-        for (index = 0; index < a5_length; index ++) {\n-            a5[index] = rand.nextInt(333);\n-        }\n-\n-        \/\/ Generate garbages to trigger GCs\n-        for (index = 0; index < a1; index ++) {\n-            create_garbage(index);\n-        }\n-\n-        \/\/ Compare results for correctness.\n-        long native_sum = CriticalNative.sum2(a1, a2, a3, a4, a5);\n-        long java_sum = a1 + sum(a2) + sum(a3) + sum(a4) + sum(a5);\n-        if (native_sum != java_sum) {\n-            StringBuffer sb = new StringBuffer(\"Sums do not match: native = \")\n-                .append(native_sum).append(\" java = \").append(java_sum);\n-\n-            throw new RuntimeException(sb.toString());\n-        }\n-    }\n-\n-    static class Case1Runner extends Thread {\n-        private final Random rand;\n-        public Case1Runner() {\n-            rand = new Random(Utils.getRandomInstance().nextLong());\n-            start();\n-        }\n-\n-        public void run() {\n-            for (int index = 0; index < CYCLES; index ++) {\n-                run_test_case1(rand);\n-            }\n-        }\n-    }\n-\n-    static class Case2Runner extends Thread {\n-        private final Random rand;\n-        public Case2Runner() {\n-            rand = new Random(Utils.getRandomInstance().nextLong());\n-            start();\n-        }\n-\n-        public void run() {\n-            for (int index = 0; index < CYCLES; index ++) {\n-                run_test_case2(rand);\n-            }\n-        }\n-    }\n-\n-    public static void main(String[] args) {\n-        Thread[] thrs = new Thread[THREAD_PER_CASE * 2];\n-        for (int index = 0; index < thrs.length; index = index + 2) {\n-            thrs[index] = new Case1Runner();\n-            thrs[index + 1] = new Case2Runner();\n-        }\n-\n-        for (int index = 0; index < thrs.length; index ++) {\n-            try {\n-                thrs[index].join();\n-            } catch (Exception e) {\n-                e.printStackTrace();\n-            }\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/gc\/stress\/CriticalNativeStress.java","additions":0,"deletions":226,"binary":false,"changes":226,"status":"deleted"}]}