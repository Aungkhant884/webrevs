{"files":[{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,1 @@\n-    jvmci jvmti link-time-opt management minimal nmt opt-size parallelgc \\\n+    jvmci jvmti link-time-opt management minimal opt-size parallelgc \\\n@@ -71,1 +71,0 @@\n-m4_define(jvm_feature_desc_nmt, [include native memory tracking (NMT)])\n@@ -446,1 +445,1 @@\n-        jfr jni-check jvmci jvmti management nmt parallelgc services \\\n+        jfr jni-check jvmci jvmti management parallelgc services \\\n@@ -541,4 +540,0 @@\n-  if JVM_FEATURES_IS_ACTIVE(management) && ! JVM_FEATURES_IS_ACTIVE(nmt); then\n-    AC_MSG_ERROR([Specified JVM feature 'management' requires feature 'nmt' for variant '$variant'])\n-  fi\n-\n","filename":"make\/autoconf\/jvm-features.m4","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -133,7 +133,0 @@\n-ifneq ($(call check-jvm-feature, nmt), true)\n-  JVM_CFLAGS_FEATURES += -DINCLUDE_NMT=0\n-  JVM_EXCLUDE_FILES += \\\n-      memBaseline.cpp memReporter.cpp mallocTracker.cpp virtualMemoryTracker.cpp nmtCommon.cpp \\\n-      memTracker.cpp nmtDCmd.cpp mallocSiteTable.cpp threadStackTracker.cpp\n-endif\n-\n","filename":"make\/hotspot\/lib\/JvmFeatures.gmk","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,2 +74,0 @@\n-  inline bool pop_object(oop& obj);\n-  inline bool pop_objarray(ObjArrayTask& array);\n@@ -83,0 +81,8 @@\n+\n+  inline void drain_oop_stack();\n+  \/\/ Transfer contents from the objArray task queue overflow stack to the shared\n+  \/\/ objArray stack.\n+  \/\/ Returns true and a valid task if there has not been enough space in the shared\n+  \/\/ objArray stack, otherwise the task is invalid.\n+  inline bool transfer_objArray_overflow_stack(ObjArrayTask& task);\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCMarker.hpp","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -94,4 +94,0 @@\n-inline bool G1FullGCMarker::pop_object(oop& oop) {\n-  return _oop_stack.pop_overflow(oop) || _oop_stack.pop_local(oop);\n-}\n-\n@@ -104,4 +100,0 @@\n-inline bool G1FullGCMarker::pop_objarray(ObjArrayTask& arr) {\n-  return _objarray_stack.pop_overflow(arr) || _objarray_stack.pop_local(arr);\n-}\n-\n@@ -162,4 +154,4 @@\n-void G1FullGCMarker::drain_stack() {\n-  do {\n-    oop obj;\n-    while (pop_object(obj)) {\n+inline void G1FullGCMarker::drain_oop_stack() {\n+  oop obj;\n+  while (_oop_stack.pop_overflow(obj)) {\n+    if (!_oop_stack.try_push_to_taskqueue(obj)) {\n@@ -169,1 +161,24 @@\n-    \/\/ Process ObjArrays one at a time to avoid marking stack bloat.\n+  }\n+  while (_oop_stack.pop_local(obj)) {\n+    assert(_bitmap->is_marked(obj), \"must be marked\");\n+    follow_object(obj);\n+  }\n+}\n+\n+inline bool G1FullGCMarker::transfer_objArray_overflow_stack(ObjArrayTask& task) {\n+  \/\/ It is desirable to move as much as possible work from the overflow queue to\n+  \/\/ the shared queue as quickly as possible.\n+  while (_objarray_stack.pop_overflow(task)) {\n+    if (!_objarray_stack.try_push_to_taskqueue(task)) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+void G1FullGCMarker::drain_stack() {\n+  do {\n+    \/\/ First, drain regular oop stack.\n+    drain_oop_stack();\n+\n+    \/\/ Then process ObjArrays one at a time to avoid marking stack bloat.\n@@ -171,1 +186,2 @@\n-    if (pop_objarray(task)) {\n+    if (transfer_objArray_overflow_stack(task) ||\n+      _objarray_stack.pop_local(task)) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCMarker.inline.hpp","additions":31,"deletions":15,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -1961,1 +1961,1 @@\n-      while (cur < hr->end()) {\n+      while (true) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -135,0 +135,7 @@\n+  assert(is_aligned(start_addr, _card_size), \"precondition\");\n+\n+  if (start_addr == end_addr) {\n+    \/\/ No objects in empty range.\n+    return false;\n+  }\n+\n@@ -136,1 +143,1 @@\n-  jbyte* end_block = block_for_addr(end_addr);\n+  jbyte* end_block = block_for_addr(end_addr - 1);\n","filename":"src\/hotspot\/share\/gc\/parallel\/objectStartArray.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -168,3 +168,5 @@\n-  \/\/ Return true if an object starts in the range of heap addresses.\n-  \/\/ If an object starts at an address corresponding to\n-  \/\/ \"start\", the method will return true.\n+  \/\/ Return true iff an object starts in\n+  \/\/   [start_addr, end_addr_aligned_up)\n+  \/\/ where\n+  \/\/   end_addr_aligned_up = align_up(end_addr, _card_size)\n+  \/\/ Precondition: start_addr is card-size aligned\n","filename":"src\/hotspot\/share\/gc\/parallel\/objectStartArray.hpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -173,2 +173,0 @@\n-#if INCLUDE_NMT\n-\n@@ -177,6 +175,0 @@\n-#else\n-\n-const bool NMT_track_callsite = false;\n-\n-#endif \/\/ INCLUDE_NMT\n-\n","filename":"src\/hotspot\/share\/memory\/allocation.hpp","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2018, 2020 SAP SE. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022 SAP SE. All rights reserved.\n@@ -80,1 +80,1 @@\n-      scale = NMT_ONLY(NMTUtil::scale_from_name(scale_value)) NOT_NMT(0);\n+      scale = NMTUtil::scale_from_name(scale_value);\n","filename":"src\/hotspot\/share\/memory\/metaspace\/metaspaceDCmd.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -90,0 +90,1 @@\n+#include \"services\/mallocSiteTable.hpp\"\n@@ -91,0 +92,1 @@\n+#include \"services\/memTracker.hpp\"\n@@ -96,0 +98,1 @@\n+#include \"utilities\/nativeCallStack.hpp\"\n@@ -108,5 +111,0 @@\n-#if INCLUDE_NMT\n-#include \"services\/mallocSiteTable.hpp\"\n-#include \"services\/memTracker.hpp\"\n-#include \"utilities\/nativeCallStack.hpp\"\n-#endif \/\/ INCLUDE_NMT\n@@ -649,1 +647,0 @@\n-#if INCLUDE_NMT\n@@ -727,1 +724,0 @@\n-#endif \/\/ INCLUDE_NMT\n@@ -2548,1 +2544,0 @@\n-#if INCLUDE_NMT\n@@ -2562,1 +2557,0 @@\n-#endif \/\/ INCLUDE_NMT\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -4015,1 +4015,0 @@\n-#if INCLUDE_NMT\n@@ -4027,7 +4026,0 @@\n-#else\n-  if (!FLAG_IS_DEFAULT(NativeMemoryTracking) || PrintNMTStatistics) {\n-    warning(\"Native Memory Tracking is not supported in this VM\");\n-    FLAG_SET_DEFAULT(NativeMemoryTracking, \"off\");\n-    FLAG_SET_DEFAULT(PrintNMTStatistics, false);\n-  }\n-#endif \/\/ INCLUDE_NMT\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -140,1 +140,0 @@\n-#if INCLUDE_NMT\n@@ -142,1 +141,1 @@\n-#endif\n+\n@@ -323,1 +322,0 @@\n-#if INCLUDE_NMT\n@@ -325,1 +323,0 @@\n-#endif\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -117,1 +117,0 @@\n-#if INCLUDE_NMT\n@@ -119,1 +118,0 @@\n-#endif\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -634,6 +634,4 @@\n-#if INCLUDE_NMT\n-  {\n-    void* rc = NULL;\n-    if (NMTPreInit::handle_malloc(&rc, size)) {\n-      return rc;\n-    }\n+  \/\/ Special handling for NMT preinit phase before arguments are parsed\n+  void* rc = NULL;\n+  if (NMTPreInit::handle_malloc(&rc, size)) {\n+    return rc;\n@@ -641,1 +639,0 @@\n-#endif\n@@ -680,6 +677,4 @@\n-#if INCLUDE_NMT\n-  {\n-    void* rc = NULL;\n-    if (NMTPreInit::handle_realloc(&rc, memblock, size)) {\n-      return rc;\n-    }\n+  \/\/ Special handling for NMT preinit phase before arguments are parsed\n+  void* rc = NULL;\n+  if (NMTPreInit::handle_realloc(&rc, memblock, size)) {\n+    return rc;\n@@ -687,1 +682,0 @@\n-#endif\n@@ -726,1 +720,1 @@\n-#if INCLUDE_NMT\n+  \/\/ Special handling for NMT preinit phase before arguments are parsed\n@@ -730,1 +724,0 @@\n-#endif\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":9,"deletions":16,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -320,1 +320,0 @@\n-#if INCLUDE_NMT\n@@ -328,1 +327,0 @@\n-#endif \/\/ INCLUDE_NMT\n@@ -2707,1 +2705,0 @@\n-#if INCLUDE_NMT\n@@ -2710,1 +2707,0 @@\n-#endif \/\/ INCLUDE_NMT\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -553,2 +553,2 @@\n-  void    register_thread_stack_with_NMT() NOT_NMT_RETURN;\n-  void    unregister_thread_stack_with_NMT() NOT_NMT_RETURN;\n+  void    register_thread_stack_with_NMT();\n+  void    unregister_thread_stack_with_NMT();\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,4 +28,0 @@\n-#include \"utilities\/macros.hpp\"\n-\n-#if INCLUDE_NMT\n-\n@@ -37,0 +33,1 @@\n+#include \"utilities\/macros.hpp\"\n@@ -202,1 +199,0 @@\n-#endif \/\/ INCLUDE_NMT\n","filename":"src\/hotspot\/share\/services\/mallocSiteTable.hpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-#if INCLUDE_NMT\n-\n@@ -451,3 +449,0 @@\n-#endif \/\/ INCLUDE_NMT\n-\n-\n","filename":"src\/hotspot\/share\/services\/mallocTracker.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,0 @@\n-#if INCLUDE_NMT\n-\n@@ -215,2 +213,0 @@\n-#endif \/\/ INCLUDE_NMT\n-\n","filename":"src\/hotspot\/share\/services\/memBaseline.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,0 @@\n-#if INCLUDE_NMT\n-\n@@ -242,2 +240,0 @@\n-#endif \/\/ INCLUDE_NMT\n-\n","filename":"src\/hotspot\/share\/services\/memReporter.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,56 +28,0 @@\n-#include \"services\/nmtCommon.hpp\"\n-#include \"utilities\/nativeCallStack.hpp\"\n-\n-\n-#if !INCLUDE_NMT\n-\n-#define CURRENT_PC   NativeCallStack::empty_stack()\n-#define CALLER_PC    NativeCallStack::empty_stack()\n-\n-class Tracker : public StackObj {\n- public:\n-  enum TrackerType {\n-     uncommit,\n-     release\n-  };\n-  Tracker(enum TrackerType type) : _type(type) { }\n-  void record(address addr, size_t size) { }\n- private:\n-  enum TrackerType  _type;\n-};\n-\n-class MemTracker : AllStatic {\n- public:\n-  static inline NMT_TrackingLevel tracking_level() { return NMT_off; }\n-  static inline bool enabled() { return false; }\n-  static inline void init() { }\n-  static bool check_launcher_nmt_support(const char* value) { return true; }\n-  static bool verify_nmt_option() { return true; }\n-\n-  static inline void* record_malloc(void* mem_base, size_t size, MEMFLAGS flag,\n-    const NativeCallStack& stack, NMT_TrackingLevel level) { return mem_base; }\n-  static inline size_t malloc_header_size(NMT_TrackingLevel level) { return 0; }\n-  static inline size_t malloc_header_size(void* memblock) { return 0; }\n-  static inline size_t malloc_footer_size(NMT_TrackingLevel level) { return 0; }\n-  static inline void* malloc_base(void* memblock) { return memblock; }\n-  static inline void* record_free(void* memblock, NMT_TrackingLevel level) { return memblock; }\n-\n-  static inline void record_new_arena(MEMFLAGS flag) { }\n-  static inline void record_arena_free(MEMFLAGS flag) { }\n-  static inline void record_arena_size_change(ssize_t diff, MEMFLAGS flag) { }\n-  static inline void record_virtual_memory_reserve(void* addr, size_t size, const NativeCallStack& stack,\n-                       MEMFLAGS flag = mtNone) { }\n-  static inline void record_virtual_memory_reserve_and_commit(void* addr, size_t size,\n-    const NativeCallStack& stack, MEMFLAGS flag = mtNone) { }\n-  static inline void record_virtual_memory_split_reserved(void* addr, size_t size, size_t split) { }\n-  static inline void record_virtual_memory_commit(void* addr, size_t size, const NativeCallStack& stack) { }\n-  static inline void record_virtual_memory_type(void* addr, MEMFLAGS flag) { }\n-  static inline void record_thread_stack(void* addr, size_t size) { }\n-  static inline void release_thread_stack(void* addr, size_t size) { }\n-\n-  static void final_report(outputStream*) { }\n-  static void error_report(outputStream*) { }\n-};\n-\n-#else\n-\n@@ -87,0 +31,1 @@\n+#include \"services\/nmtCommon.hpp\"\n@@ -89,0 +34,1 @@\n+#include \"utilities\/nativeCallStack.hpp\"\n@@ -312,2 +258,0 @@\n-#endif \/\/ INCLUDE_NMT\n-\n","filename":"src\/hotspot\/share\/services\/memTracker.hpp","additions":3,"deletions":59,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,0 @@\n-#if INCLUDE_NMT\n-\n@@ -74,2 +72,0 @@\n-#endif \/\/ INCLUDE_NMT\n-\n","filename":"src\/hotspot\/share\/services\/nmtDCmd.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2021 SAP SE. All rights reserved.\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022 SAP SE. All rights reserved.\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,2 +34,0 @@\n-#if INCLUDE_NMT\n-\n@@ -193,2 +191,0 @@\n-\n-#endif \/\/ INCLUDE_NMT\n","filename":"src\/hotspot\/share\/services\/nmtPreInit.cpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2021 SAP SE. All rights reserved.\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022 SAP SE. All rights reserved.\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,2 +37,0 @@\n-#if INCLUDE_NMT\n-\n@@ -356,2 +354,0 @@\n-#endif \/\/ INCLUDE_NMT\n-\n","filename":"src\/hotspot\/share\/services\/nmtPreInit.hpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-#if INCLUDE_NMT\n-\n@@ -87,1 +85,0 @@\n-#endif \/\/ INCLUDE_NMT\n@@ -89,0 +86,1 @@\n+\n","filename":"src\/hotspot\/share\/services\/threadStackTracker.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-#if INCLUDE_NMT\n-\n@@ -399,2 +397,0 @@\n-#endif \/\/ INCLUDE_NMT\n-\n@@ -402,0 +398,1 @@\n+\n","filename":"src\/hotspot\/share\/services\/virtualMemoryTracker.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -486,2 +486,0 @@\n-#if INCLUDE_NMT\n-    \/\/ With NMT\n@@ -520,1 +518,0 @@\n-#endif \/\/ INCLUDE_NMT\n","filename":"src\/hotspot\/share\/utilities\/debug.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -244,16 +244,0 @@\n-#ifndef INCLUDE_NMT\n-#define INCLUDE_NMT 1\n-#endif \/\/ INCLUDE_NMT\n-\n-#if INCLUDE_NMT\n-#define NOT_NMT_RETURN        \/* next token must be ; *\/\n-#define NOT_NMT_RETURN_(code) \/* next token must be ; *\/\n-#define NMT_ONLY(x) x\n-#define NOT_NMT(x)\n-#else\n-#define NOT_NMT_RETURN        {}\n-#define NOT_NMT_RETURN_(code) { return code; }\n-#define NMT_ONLY(x)\n-#define NOT_NMT(x) x\n-#endif \/\/ INCLUDE_NMT\n-\n","filename":"src\/hotspot\/share\/utilities\/macros.hpp","additions":1,"deletions":17,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.util.Objects;\n@@ -41,0 +42,1 @@\n+        private T strongReferent;\n@@ -45,0 +47,1 @@\n+            this.strongReferent = referent;\n@@ -50,0 +53,8 @@\n+\n+        T getStrong() {\n+            return strongReferent;\n+        }\n+\n+        void clearStrong() {\n+            strongReferent = null;\n+        }\n@@ -53,1 +64,1 @@\n-    private final ClassValue<SoftReference<T>> map;\n+    private final ClassValue<CacheRef<T>> map;\n@@ -61,2 +72,4 @@\n-            protected SoftReference<T> computeValue(Class<?> type) {\n-                return new CacheRef<>(ClassCache.this.computeValue(type), queue, type);\n+            protected CacheRef<T> computeValue(Class<?> type) {\n+                T v = ClassCache.this.computeValue(type);\n+                Objects.requireNonNull(v);\n+                return new CacheRef<>(v, queue, type);\n@@ -68,7 +81,20 @@\n-        processQueue();\n-        T val;\n-        do {\n-            SoftReference<T> ref = map.get(cl);\n-            val = ref.get();\n-            if (val == null) {\n-                map.remove(cl);\n+        while (true) {\n+            processQueue();\n+\n+            CacheRef<T> ref = map.get(cl);\n+\n+            \/\/ Case 1: A recently created CacheRef.\n+            \/\/ We might still have strong referent, and can return it.\n+            \/\/ This guarantees progress for at least one thread on every CacheRef.\n+            \/\/ Clear the strong referent before returning to make the cache soft.\n+            T strongVal = ref.getStrong();\n+            if (strongVal != null) {\n+                ref.clearStrong();\n+                return strongVal;\n+            }\n+\n+            \/\/ Case 2: Older or recently cleared CacheRef.\n+            \/\/ Check if its soft referent is still available, and return it.\n+            T val = ref.get();\n+            if (val != null) {\n+                return val;\n@@ -76,2 +102,5 @@\n-        } while (val == null);\n-        return val;\n+\n+            \/\/ Case 3: The reference was cleared.\n+            \/\/ Clear the mapping and retry.\n+            map.remove(cl);\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/io\/ClassCache.java","additions":41,"deletions":12,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -31,0 +31,3 @@\n+\n+import jdk.internal.access.JavaLangReflectAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -33,1 +36,0 @@\n-import java.util.concurrent.ConcurrentHashMap;\n@@ -187,2 +189,0 @@\n-        final ConcurrentHashMap<Method, MethodHandle> defaultMethodMap =\n-                hasDefaultMethods(intfc) ? new ConcurrentHashMap<>() : null;\n@@ -205,1 +205,2 @@\n-                        return callDefaultMethod(defaultMethodMap, proxy, intfc, method, args);\n+                        \/\/ no additional access check is performed\n+                        return JLRA.invokeDefault(proxy, method, args, null);\n@@ -295,1 +296,1 @@\n-            case \"toString\" -> self.getClass().getName() + \"@\" + Integer.toHexString(self.hashCode());\n+            case \"toString\" -> java.util.Objects.toIdentityString(self);\n@@ -323,33 +324,1 @@\n-    private static boolean hasDefaultMethods(Class<?> intfc) {\n-        for (Method m : intfc.getMethods()) {\n-            if (!isObjectMethod(m) &&\n-                !Modifier.isAbstract(m.getModifiers())) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    private static Object callDefaultMethod(ConcurrentHashMap<Method, MethodHandle> defaultMethodMap,\n-                             Object self, Class<?> intfc, Method m, Object[] args) throws Throwable {\n-        assert(isDefaultMethod(m) && !isObjectMethod(m)) : m;\n-\n-        \/\/ Lazily compute the associated method handle from the method\n-        MethodHandle dmh = defaultMethodMap.computeIfAbsent(m, mk -> {\n-            try {\n-                \/\/ Look up the default method for special invocation thereby\n-                \/\/ avoiding recursive invocation back to the proxy\n-                MethodHandle mh = MethodHandles.Lookup.IMPL_LOOKUP.findSpecial(\n-                        intfc, mk.getName(),\n-                        MethodType.methodType(mk.getReturnType(), mk.getParameterTypes()),\n-                        self.getClass());\n-                return mh.asSpreader(Object[].class, mk.getParameterCount());\n-            } catch (NoSuchMethodException | IllegalAccessException e) {\n-                \/\/ The method is known to exist and should be accessible, this\n-                \/\/ method would not be called unless the invokeinterface to the\n-                \/\/ default (public) method passed access control checks\n-                throw new InternalError(e);\n-            }\n-        });\n-        return dmh.invoke(self, args);\n-    }\n+    private static final JavaLangReflectAccess JLRA = SharedSecrets.getJavaLangReflectAccess();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleProxies.java","additions":7,"deletions":38,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.lang.invoke.MethodHandle;\n@@ -265,28 +264,1 @@\n-\n-        \/\/ verify that the object is actually a proxy instance\n-        if (!Proxy.isProxyClass(proxy.getClass())) {\n-            throw new IllegalArgumentException(\"'proxy' is not a proxy instance\");\n-        }\n-        if (!method.isDefault()) {\n-            throw new IllegalArgumentException(\"\\\"\" + method + \"\\\" is not a default method\");\n-        }\n-        @SuppressWarnings(\"unchecked\")\n-        Class<? extends Proxy> proxyClass = (Class<? extends Proxy>)proxy.getClass();\n-\n-        Class<?> intf = method.getDeclaringClass();\n-        \/\/ access check on the default method\n-        method.checkAccess(Reflection.getCallerClass(), intf, proxyClass, method.getModifiers());\n-\n-        MethodHandle mh = Proxy.defaultMethodHandle(proxyClass, method);\n-        \/\/ invoke the super method\n-        try {\n-            \/\/ the args array can be null if the number of formal parameters required by\n-            \/\/ the method is zero (consistent with Method::invoke)\n-            Object[] params = args != null ? args : Proxy.EMPTY_ARGS;\n-            return mh.invokeExact(proxy, params);\n-        } catch (ClassCastException | NullPointerException e) {\n-            throw new IllegalArgumentException(e.getMessage(), e);\n-        } catch (Proxy.InvocationException e) {\n-            \/\/ unwrap and throw the exception thrown by the default method\n-            throw e.getCause();\n-        }\n+        return Proxy.invokeDefault(proxy, method, args, Reflection.getCallerClass());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/InvocationHandler.java","additions":1,"deletions":29,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -1317,0 +1317,40 @@\n+    \/*\n+     * Invoke the default method of the given proxy with an explicit caller class.\n+     *\n+     * @throws IllegalAccessException if the proxy interface is inaccessible to the caller\n+     *         if caller is non-null\n+     *\/\n+    static Object invokeDefault(Object proxy, Method method, Object[] args, Class<?> caller)\n+            throws Throwable {\n+        \/\/ verify that the object is actually a proxy instance\n+        if (!Proxy.isProxyClass(proxy.getClass())) {\n+            throw new IllegalArgumentException(\"'proxy' is not a proxy instance\");\n+        }\n+        if (!method.isDefault()) {\n+            throw new IllegalArgumentException(\"\\\"\" + method + \"\\\" is not a default method\");\n+        }\n+        @SuppressWarnings(\"unchecked\")\n+        Class<? extends Proxy> proxyClass = (Class<? extends Proxy>)proxy.getClass();\n+\n+        \/\/ skip access check if caller is null\n+        if (caller != null) {\n+            Class<?> intf = method.getDeclaringClass();\n+            \/\/ access check on the default method\n+            method.checkAccess(caller, intf, proxyClass, method.getModifiers());\n+        }\n+\n+        MethodHandle mh = Proxy.defaultMethodHandle(proxyClass, method);\n+        \/\/ invoke the super method\n+        try {\n+            \/\/ the args array can be null if the number of formal parameters required by\n+            \/\/ the method is zero (consistent with Method::invoke)\n+            Object[] params = args != null ? args : Proxy.EMPTY_ARGS;\n+            return mh.invokeExact(proxy, params);\n+        } catch (ClassCastException | NullPointerException e) {\n+            throw new IllegalArgumentException(e.getMessage(), e);\n+        } catch (Proxy.InvocationException e) {\n+            \/\/ unwrap and throw the exception thrown by the default method\n+            throw e.getCause();\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Proxy.java","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -130,0 +130,5 @@\n+\n+    public Object invokeDefault(Object proxy, Method method, Object[] args, Class<?> caller)\n+            throws Throwable {\n+        return Proxy.invokeDefault(proxy, method, args, caller);\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ReflectAccess.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-import java.io.*;\n+import java.io.IOException;\n@@ -32,1 +32,4 @@\n-import java.nio.file.*;\n+import java.nio.file.FileAlreadyExistsException;\n+import java.nio.file.OpenOption;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n@@ -34,1 +37,1 @@\n-import java.nio.file.spi.*;\n+import java.nio.file.spi.FileSystemProvider;\n@@ -406,0 +409,3 @@\n+     *\n+     * @throws  NonWritableChannelException\n+     *          If this channel was not opened for writing\n@@ -420,0 +426,3 @@\n+     *\n+     * @throws  NonWritableChannelException\n+     *          If this channel was not opened for writing\n@@ -434,0 +443,3 @@\n+     *\n+     * @throws  NonWritableChannelException\n+     *          If this channel was not opened for writing\n@@ -1033,1 +1045,1 @@\n-     *          If {@code shared} is {@code true} this channel was not\n+     *          If {@code shared} is {@code true} but this channel was not\n@@ -1151,0 +1163,8 @@\n+     * @throws  NonReadableChannelException\n+     *          If {@code shared} is {@code true} but this channel was not\n+     *          opened for reading\n+     *\n+     * @throws  NonWritableChannelException\n+     *          If {@code shared} is {@code false} but this channel was not\n+     *          opened for writing\n+     *\n@@ -1183,0 +1203,3 @@\n+     * @throws  NonWritableChannelException\n+     *          If this channel was not opened for writing\n+     *\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/FileChannel.java","additions":28,"deletions":5,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -167,0 +167,24 @@\n+    \/**\n+     * {@return a string equivalent to the string returned by {@code\n+     * Object.toString} if that method and {@code hashCode} are not\n+     * overridden}\n+     *\n+     * @implNote\n+     * This method constructs a string for an object without calling\n+     * any overridable methods of the object.\n+     *\n+     * @implSpec\n+     * The method returns a string equivalent to:<br>\n+     * {@code o.getClass().getName() + \"@\" + Integer.toHexString(System.identityHashCode(o))}\n+     *\n+     * @param o an object\n+     * @throws NullPointerException if the argument is null\n+     * @see Object#toString\n+     * @see System#identityHashCode(Object)\n+     * @since 19\n+     *\/\n+    public static String toIdentityString(Object o) {\n+        requireNonNull(o);\n+        return o.getClass().getName() + \"@\" + Integer.toHexString(System.identityHashCode(o));\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/Objects.java","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -105,0 +105,7 @@\n+\n+    \/** Invokes the given default method if the method's declaring interface is\n+     *  accessible to the given caller.  Otherwise, IllegalAccessException will\n+     *  be thrown.  If the caller is null, no access check is performed.\n+     *\/\n+    public Object invokeDefault(Object proxy, Method method, Object[] args, Class<?> caller)\n+        throws Throwable;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangReflectAccess.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -382,1 +382,0 @@\n-\n@@ -384,3 +383,1 @@\n-            msg += \"a member of \" + memberClass + memberSuffix +\n-                    \" with modifiers \\\"\" + Modifier.toString(modifiers) + \"\\\"\";\n-\n+            msg += \"a member of \" + memberClass + memberSuffix + msgSuffix(modifiers);\n@@ -413,1 +410,0 @@\n-\n@@ -415,3 +411,1 @@\n-            msg += \"a member of \" + memberClass + memberSuffix +\n-                \" with modifiers \\\"\" + Modifier.toString(modifiers) + \"\\\"\";\n-\n+            msg += \"a member of \" + memberClass + memberSuffix + msgSuffix(modifiers);\n@@ -427,0 +421,10 @@\n+    private static String msgSuffix(int modifiers) {\n+        boolean packageAccess =\n+            ((Modifier.PRIVATE |\n+              Modifier.PROTECTED |\n+              Modifier.PUBLIC) & modifiers) == 0;\n+        return packageAccess ?\n+            \" with package access\" :\n+            \" with modifiers \\\"\" + Modifier.toString(modifiers) + \"\\\"\";\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/Reflection.java","additions":13,"deletions":9,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -291,2 +291,1 @@\n-    static final String acceptString =\n-        \"text\/html, image\/gif, image\/jpeg, *; q=.2, *\/*; q=.2\";\n+    static final String acceptString = \"*\/*\";\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/http\/HttpURLConnection.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -135,1 +135,2 @@\n-                 (declaringClass.getModifiers() & Modifier.STATIC) == 0) ) {\n+                 (declaringClass.getModifiers() & Modifier.STATIC) == 0) &&\n+                 filter == TypeAnnotation.TypeAnnotationTarget.METHOD_FORMAL_PARAMETER) {\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/annotation\/TypeAnnotationParser.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -107,1 +107,0 @@\n-    BOOL error = FALSE;\n@@ -119,1 +118,0 @@\n-        wchar_t *next_proxy = NULL;\n@@ -295,1 +293,0 @@\n-        wchar_t *context = NULL;\n@@ -318,0 +315,1 @@\n+            list_item *current = head;\n@@ -322,1 +320,1 @@\n-            while (head != NULL && index < nr_elems) {\n+            while (current != NULL && index < nr_elems) {\n@@ -327,1 +325,1 @@\n-                if (head->host != NULL && proxy_array != NULL) {\n+                if (current->host != NULL && proxy_array != NULL) {\n@@ -329,2 +327,2 @@\n-                    if (head->port == 0) {\n-                        head->port = defport;\n+                    if (current->port == 0) {\n+                        current->port = defport;\n@@ -332,1 +330,1 @@\n-                    jhost = (*env)->NewString(env, head->host, (jsize)wcslen(head->host));\n+                    jhost = (*env)->NewString(env, current->host, (jsize)wcslen(current->host));\n@@ -338,1 +336,1 @@\n-                                                         head->port);\n+                                                         current->port);\n@@ -352,1 +350,1 @@\n-                head = head->next;\n+                current = current->next;\n","filename":"src\/java.base\/windows\/native\/libnet\/DefaultProxySelector.c","additions":8,"deletions":10,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2009, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,0 +72,4 @@\n+    if (s == INVALID_SOCKET && WSAGetLastError() == WSAEAFNOSUPPORT) {\n+        \/* IPv4 unavailable... try IPv6 instead *\/\n+        s = socket(AF_INET6, SOCK_STREAM, 0);\n+    }\n","filename":"src\/java.base\/windows\/native\/libnio\/ch\/WindowsAsynchronousServerSocketChannelImpl.c","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,0 +69,4 @@\n+    if (s == INVALID_SOCKET && WSAGetLastError() == WSAEAFNOSUPPORT) {\n+        \/* IPv4 unavailable... try IPv6 instead *\/\n+        s = socket(AF_INET6, SOCK_STREAM, 0);\n+    }\n","filename":"src\/java.base\/windows\/native\/libnio\/ch\/WindowsAsynchronousSocketChannelImpl.c","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,0 +85,8 @@\n+\/* Returns true if this is a strong reference, meaning that either or both of\n+   isPinAll and isCommonPin are true. *\/\n+static jboolean\n+isStrong(RefNode* node)\n+{\n+    return node->isPinAll || node->isCommonPin;\n+}\n+\n@@ -92,1 +100,1 @@\n-    jboolean   pin = gdata->pinAllCount != 0;\n+    jboolean   pinAll = gdata->pinAllCount != 0;\n@@ -100,1 +108,1 @@\n-    if (pin) {\n+    if (pinAll) {\n@@ -119,1 +127,1 @@\n-        if (pin) {\n+        if (pinAll) {\n@@ -131,1 +139,2 @@\n-    node->strongCount = pin ? 1 : 0;\n+    node->isPinAll    = pinAll;\n+    node->isCommonPin = JNI_FALSE;\n@@ -149,1 +158,1 @@\n-        if (node->strongCount != 0) {\n+        if (isStrong(node)) {\n@@ -161,1 +170,1 @@\n-strengthenNode(JNIEnv *env, RefNode *node)\n+strengthenNode(JNIEnv *env, RefNode *node, jboolean isPinAll)\n@@ -163,1 +172,1 @@\n-    if (node->strongCount == 0) {\n+    if (!isStrong(node)) {\n@@ -179,1 +188,2 @@\n-            node->strongCount = 1;\n+        } else {\n+          return NULL;\n@@ -181,1 +191,3 @@\n-        return strongRef;\n+    }\n+    if (isPinAll) {\n+        node->isPinAll = JNI_TRUE;\n@@ -183,2 +195,1 @@\n-        node->strongCount++;\n-        return node->ref;\n+        node->isCommonPin = JNI_TRUE;\n@@ -186,0 +197,1 @@\n+    return node->ref;\n@@ -190,1 +202,1 @@\n-weakenNode(JNIEnv *env, RefNode *node)\n+weakenNode(JNIEnv *env, RefNode *node, jboolean isUnpinAll)\n@@ -192,1 +204,5 @@\n-    if (node->strongCount == 1) {\n+    jboolean willStillBeStrong = (node->isPinAll && !isUnpinAll) || (node->isCommonPin && isUnpinAll);\n+\n+    \/\/ If the node is strong, but the reason(s) for it being strong\n+    \/\/ will no longer exist, then weaken it.\n+    if (isStrong(node) && !willStillBeStrong) {\n@@ -203,2 +219,3 @@\n-            node->ref         = weakRef;\n-            node->strongCount = 0;\n+            node->ref      = weakRef;\n+        } else {\n+          return NULL;\n@@ -206,1 +223,4 @@\n-        return weakRef;\n+    }\n+\n+    if (isUnpinAll) {\n+        node->isPinAll = JNI_FALSE;\n@@ -208,4 +228,1 @@\n-        if (node->strongCount > 0) {\n-            node->strongCount--;\n-        }\n-        return node->ref;\n+        node->isCommonPin = JNI_FALSE;\n@@ -213,0 +230,1 @@\n+    return node->ref;\n@@ -473,1 +491,1 @@\n-            if (node->strongCount != 0) {\n+          if (isStrong(node)) {\n@@ -525,1 +543,1 @@\n-            strongRef = strengthenNode(env, node);\n+            strongRef = strengthenNode(env, node, JNI_FALSE \/* isPinAll *\/);\n@@ -554,1 +572,1 @@\n-            weakRef = weakenNode(env, node);\n+            weakRef = weakenNode(env, node, JNI_FALSE \/* isUnpinAll *\/);\n@@ -588,1 +606,1 @@\n-                    strongRef = strengthenNode(env, node);\n+                    strongRef = strengthenNode(env, node, JNI_TRUE \/* isPinAll *\/);\n@@ -631,1 +649,1 @@\n-                    weakRef = weakenNode(env, node);\n+                    weakRef = weakenNode(env, node, JNI_TRUE \/* isUnpinAll *\/);\n@@ -679,2 +697,1 @@\n-                    if ( (node->strongCount == 0) &&\n-                          isSameObject(env, node->ref, NULL)) {\n+                  if (!isStrong(node) && isSameObject(env, node->ref, NULL)) {\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/commonRef.c","additions":45,"deletions":28,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,1 +68,2 @@\n-    unsigned     strongCount;   \/* count of strong reference *\/\n+    jboolean     isPinAll;      \/* true if this is a strong reference due to a commonRef_pinAll() *\/\n+    jboolean     isCommonPin;   \/* true if this is a strong reference due to a commonRef_pin() *\/\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/util.h","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2021 SAP SE. All rights reserved.\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022 SAP SE. All rights reserved.\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,2 +34,0 @@\n-#if INCLUDE_NMT\n-\n@@ -40,2 +38,0 @@\n-\n-\n@@ -168,2 +164,0 @@\n-\n-#endif \/\/ INCLUDE_NMT\n","filename":"test\/hotspot\/gtest\/nmt\/test_nmt_buffer_overflow_detection.cpp","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2021 SAP SE. All rights reserved.\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022 SAP SE. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,2 +57,0 @@\n-#if INCLUDE_NMT\n-\n@@ -130,2 +128,0 @@\n-\n-#endif \/\/ INCLUDE_NMT\n","filename":"test\/hotspot\/gtest\/nmt\/test_nmtpreinit.cpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2021 SAP SE. All rights reserved.\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022 SAP SE. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,2 +34,0 @@\n-#if INCLUDE_NMT\n-\n@@ -135,2 +133,0 @@\n-\n-#endif \/\/ INCLUDE_NMT\n","filename":"test\/hotspot\/gtest\/nmt\/test_nmtpreinitmap.cpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,0 @@\n-#if INCLUDE_NMT\n-\n@@ -226,2 +224,0 @@\n-\n-#endif \/\/ INCLUDE_NMT\n","filename":"test\/hotspot\/gtest\/runtime\/test_committed_virtualmemory.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,5 +35,0 @@\n-\/\/ Included early because the NMT flags don't include it.\n-#include \"utilities\/macros.hpp\"\n-\n-#if INCLUDE_NMT\n-\n@@ -44,0 +39,1 @@\n+#include \"utilities\/macros.hpp\"\n@@ -45,0 +41,1 @@\n+\n@@ -569,2 +566,0 @@\n-\n-#endif \/\/ INCLUDE_NMT\n","filename":"test\/hotspot\/gtest\/runtime\/test_virtualMemoryTracker.cpp","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2022, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.NameClassCache;\n+\n+\/**\n+ * @test\n+ * @bug 8280041\n+ * @summary Sanity test for ClassCache under continuous GC\n+ * @compile\/module=java.base java\/io\/NameClassCache.java\n+ * @run main ContinuousGCTest\n+ *\/\n+public class ContinuousGCTest {\n+    static final NameClassCache CACHE = new NameClassCache();\n+    static final String VALUE = \"ClassCache-ContinuousGCTest\";\n+\n+    public static void main(String... args) throws Throwable {\n+        for (int c = 0; c < 1000; c++) {\n+            test();\n+            System.gc();\n+        }\n+    }\n+\n+    public static void test() {\n+        String cached = CACHE.get(ContinuousGCTest.class);\n+        if (!cached.equals(VALUE)) {\n+            throw new IllegalStateException(\"Cache failure, got: \" + cached);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/io\/ClassCache\/ContinuousGCTest.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2022, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.NullClassCache;\n+\n+\/**\n+ * @test\n+ * @bug 8280041\n+ * @summary Test that ClassCache throws on trying to pass null value\n+ * @compile\/module=java.base java\/io\/NullClassCache.java\n+ * @run main NullValueTest\n+ *\/\n+public class NullValueTest {\n+    public static void main(String... args) throws Throwable {\n+        try {\n+            new NullClassCache().get(Object.class);\n+            throw new IllegalStateException(\"Should have failed\");\n+        } catch (NullPointerException npe) {\n+            \/\/ Expected\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/io\/ClassCache\/NullValueTest.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2022, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.io;\n+\n+public class NameClassCache extends ClassCache<String> {\n+    protected String computeValue(Class<?> cl) {\n+        \/\/ Return string that is not interned and specific to class\n+        return \"ClassCache-\" + cl.getName();\n+    }\n+\n+    public String get(Class<?> cl) {\n+        return super.get(cl);\n+    }\n+}\n","filename":"test\/jdk\/java\/io\/ClassCache\/java.base\/java\/io\/NameClassCache.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2022, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.io;\n+\n+public class NullClassCache extends ClassCache<Object> {\n+    protected Object computeValue(Class<?> cl) {\n+        return null;\n+    }\n+\n+    public Object get(Class<?> cl) {\n+        return super.get(cl);\n+    }\n+}\n","filename":"test\/jdk\/java\/io\/ClassCache\/java.base\/java\/io\/NullClassCache.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -42,1 +42,2 @@\n-        testRunException();\n+        testRunException(TestClassException.class.getDeclaredMethod(\"foo\", (Class<?>[])null));\n+        testRunException(Outer2.TestClassException2.class.getDeclaredConstructor(Outer2.class));\n@@ -145,3 +146,2 @@\n-    private static void testRunException() throws Exception {\n-        Method m = TestClassException.class.getDeclaredMethod(\"foo\", (Class<?>[])null);\n-        AnnotatedType[] ts = m.getAnnotatedExceptionTypes();\n+    private static void testRunException(Executable e) throws Exception {\n+        AnnotatedType[] ts = e.getAnnotatedExceptionTypes();\n@@ -627,0 +627,9 @@\n+class Outer2 {\n+    abstract class TestClassException2 {\n+        public TestClassException2() throws\n+                @TypeAnno(\"RE\") @TypeAnno2(\"RE2\") RuntimeException,\n+                NullPointerException,\n+                @TypeAnno(\"AIOOBE\") ArrayIndexOutOfBoundsException {}\n+    }\n+}\n+\n","filename":"test\/jdk\/java\/lang\/annotation\/TypeAnnotationReflection.java","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2020, 2022, Red Hat, Inc. All rights reserved.\n@@ -267,0 +267,33 @@\n+\/*\n+ * @test\n+ * @summary Test for fInst.getObjectSize with large arrays\n+ * @library \/test\/lib\n+ * @requires vm.bits == 64\n+ * @requires vm.debug\n+ * @requires os.maxMemory >= 10G\n+ *\n+ * @build sun.hotspot.WhiteBox\n+ * @run build GetObjectSizeIntrinsicsTest\n+ * @run shell MakeJAR.sh basicAgent\n+ *\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ *\n+ * @run main\/othervm -Xmx8g\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *                   -XX:ObjectAlignmentInBytes=32\n+ *                   -Xint\n+ *                   -javaagent:basicAgent.jar GetObjectSizeIntrinsicsTest GetObjectSizeIntrinsicsTest large\n+ *\n+ * @run main\/othervm -Xmx8g\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *                   -XX:ObjectAlignmentInBytes=32\n+ *                   -Xbatch -XX:TieredStopAtLevel=1\n+ *                   -javaagent:basicAgent.jar GetObjectSizeIntrinsicsTest GetObjectSizeIntrinsicsTest large\n+ *\n+ * @run main\/othervm -Xmx8g\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+AbortVMOnCompilationFailure -XX:+WhiteBoxAPI -Xbootclasspath\/a:.\n+ *                   -XX:ObjectAlignmentInBytes=32\n+ *                   -Xbatch -XX:-TieredCompilation\n+ *                   -javaagent:basicAgent.jar GetObjectSizeIntrinsicsTest GetObjectSizeIntrinsicsTest large\n+ *\/\n+\n@@ -274,2 +307,2 @@\n-    static final Boolean compressedOops = WhiteBox.getWhiteBox().getBooleanVMFlag(\"UseCompressedOops\");\n-    static final int REF_SIZE = (compressedOops == null || compressedOops == true) ?  4 : 8;\n+    static final Boolean COMPRESSED_OOPS = WhiteBox.getWhiteBox().getBooleanVMFlag(\"UseCompressedOops\");\n+    static final long REF_SIZE = (COMPRESSED_OOPS == null || COMPRESSED_OOPS == true) ? 4 : 8;\n@@ -280,1 +313,8 @@\n-    public GetObjectSizeIntrinsicsTest(String name) {\n+    static final int SMALL_ARRAY_SIZE = 1024;\n+\n+    \/\/ With int[] arrays, this overflows 4G boundary\n+    static final int LARGE_ARRAY_SIZE = 1024*1024*1024 + 1024;\n+\n+    final String mode;\n+\n+    public GetObjectSizeIntrinsicsTest(String name, String mode) {\n@@ -282,0 +322,1 @@\n+        this.mode = mode;\n@@ -285,1 +326,1 @@\n-        new GetObjectSizeIntrinsicsTest(args[0]).runTest();\n+        new GetObjectSizeIntrinsicsTest(args[0], (args.length >= 2 ? args[1] : \"\")).runTest();\n@@ -315,3 +356,3 @@\n-        testSize_newSmallByteArray();\n-        testSize_localSmallByteArray();\n-        testSize_fieldSmallByteArray();\n+        testSize_newSmallIntArray();\n+        testSize_localSmallIntArray();\n+        testSize_fieldSmallIntArray();\n@@ -323,0 +364,5 @@\n+        if (mode.equals(\"large\")) {\n+            testSize_localLargeIntArray();\n+            testSize_localLargeObjArray();\n+        }\n+\n@@ -326,1 +372,1 @@\n-    private static int roundUp(int v, int a) {\n+    private static long roundUp(long v, long a) {\n@@ -331,1 +377,1 @@\n-        int expected = roundUp(Platform.is64bit() ? 16 : 8, OBJ_ALIGN);\n+        long expected = roundUp(Platform.is64bit() ? 16 : 8, OBJ_ALIGN);\n@@ -338,1 +384,1 @@\n-        int expected = roundUp(Platform.is64bit() ? 16 : 8, OBJ_ALIGN);\n+        long expected = roundUp(Platform.is64bit() ? 16 : 8, OBJ_ALIGN);\n@@ -348,1 +394,1 @@\n-        int expected = roundUp(Platform.is64bit() ? 16 : 8, OBJ_ALIGN);\n+        long expected = roundUp(Platform.is64bit() ? 16 : 8, OBJ_ALIGN);\n@@ -354,2 +400,2 @@\n-    private void testSize_newSmallByteArray() {\n-        int expected = roundUp(1024 + 16, OBJ_ALIGN);\n+    private void testSize_newSmallIntArray() {\n+        long expected = roundUp(4L*SMALL_ARRAY_SIZE + 16, OBJ_ALIGN);\n@@ -357,1 +403,1 @@\n-            assertEquals(expected, fInst.getObjectSize(new byte[1024]));\n+            assertEquals(expected, fInst.getObjectSize(new int[SMALL_ARRAY_SIZE]));\n@@ -361,3 +407,3 @@\n-    private void testSize_localSmallByteArray() {\n-        byte[] arr = new byte[1024];\n-        int expected = roundUp(arr.length + 16, OBJ_ALIGN);\n+    private void testSize_localSmallIntArray() {\n+        int[] arr = new int[SMALL_ARRAY_SIZE];\n+        long expected = roundUp(4L*SMALL_ARRAY_SIZE + 16, OBJ_ALIGN);\n@@ -369,1 +415,1 @@\n-    static byte[] smallArr = new byte[1024];\n+    static int[] smallArr = new int[SMALL_ARRAY_SIZE];\n@@ -371,2 +417,2 @@\n-    private void testSize_fieldSmallByteArray() {\n-        int expected = roundUp(smallArr.length + 16, OBJ_ALIGN);\n+    private void testSize_fieldSmallIntArray() {\n+        long expected = roundUp(4L*SMALL_ARRAY_SIZE + 16, OBJ_ALIGN);\n@@ -379,1 +425,1 @@\n-        int expected = roundUp(1024*REF_SIZE + 16, OBJ_ALIGN);\n+        long expected = roundUp(REF_SIZE*SMALL_ARRAY_SIZE + 16, OBJ_ALIGN);\n@@ -381,1 +427,1 @@\n-            assertEquals(expected, fInst.getObjectSize(new Object[1024]));\n+            assertEquals(expected, fInst.getObjectSize(new Object[SMALL_ARRAY_SIZE]));\n@@ -386,2 +432,2 @@\n-        Object[] arr = new Object[1024];\n-        int expected = roundUp(arr.length*REF_SIZE + 16, OBJ_ALIGN);\n+        Object[] arr = new Object[SMALL_ARRAY_SIZE];\n+        long expected = roundUp(REF_SIZE*SMALL_ARRAY_SIZE + 16, OBJ_ALIGN);\n@@ -393,1 +439,1 @@\n-    static Object[] smallObjArr = new Object[1024];\n+    static Object[] smallObjArr = new Object[SMALL_ARRAY_SIZE];\n@@ -396,1 +442,1 @@\n-        int expected = roundUp(smallArr.length*REF_SIZE + 16, OBJ_ALIGN);\n+        long expected = roundUp(REF_SIZE*SMALL_ARRAY_SIZE + 16, OBJ_ALIGN);\n@@ -402,0 +448,16 @@\n+    private void testSize_localLargeIntArray() {\n+        int[] arr = new int[LARGE_ARRAY_SIZE];\n+        long expected = roundUp(4L*LARGE_ARRAY_SIZE + 16, OBJ_ALIGN);\n+        for (int c = 0; c < ITERS; c++) {\n+            assertEquals(expected, fInst.getObjectSize(arr));\n+        }\n+    }\n+\n+    private void testSize_localLargeObjArray() {\n+        Object[] arr = new Object[LARGE_ARRAY_SIZE];\n+        long expected = roundUp(REF_SIZE*LARGE_ARRAY_SIZE + 16, OBJ_ALIGN);\n+        for (int c = 0; c < ITERS; c++) {\n+            assertEquals(expected, fInst.getObjectSize(arr));\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/instrument\/GetObjectSizeIntrinsicsTest.java","additions":89,"deletions":27,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8280377\n+ * @build m1\/* m2\/* Unnamed\n+ * @run testng\/othervm m1\/p1.Main\n+ * @run testng\/othervm Unnamed\n+ * @summary Test MethodHandleProxies::asInterfaceInstance with a default\n+ *          method with varargs\n+ *\/\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandleProxies\/Driver.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandleProxies\/MethodHandlesProxiesTest.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/java\/lang\/invoke\/MethodHandlesProxiesTest.java","status":"renamed"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandleProxies;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n+\n+import static org.testng.Assert.*;\n+\n+\/*\n+ * Test MethodHandleProxies::asInterfaceInstance with an inaccessible interface\n+ *\/\n+public class Unnamed {\n+    public static void main(String... args) throws Throwable {\n+        MethodHandle target = MethodHandles.constant(String.class, \"test\");\n+        Class<?> intf = Class.forName(\"p2.TestIntf\");\n+        Object t = MethodHandleProxies.asInterfaceInstance(intf, target);\n+\n+        \/\/ verify that the caller has no access to the proxy created on an\n+        \/\/ inaccessible interface\n+        Method m = intf.getMethod(\"test\", Object[].class);\n+        assertFalse(m.canAccess(null));\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandleProxies\/Unnamed.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -0,0 +1,27 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+module m1 {\n+    requires m2;\n+    requires org.testng;\n+    exports p1;\n+}\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandleProxies\/m1\/module-info.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package p1;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandleProxies;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.util.Arrays;\n+import java.util.stream.Collectors;\n+\n+import p2.TestIntf;\n+\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.*;\n+\n+public class Main {\n+    public interface A {\n+        default String aConcat(Object... objs) { return Arrays.deepToString(objs); }\n+    }\n+\n+    public interface B {\n+        default String bConcat(Object[] objs) { return Arrays.deepToString(objs); }\n+    }\n+\n+    public interface C extends A, B {\n+        String c(Object... objs);\n+    }\n+\n+    private static String concat(Object... objs) {\n+        return Arrays.stream(objs).map(Object::toString).collect(Collectors.joining());\n+    }\n+\n+    \/*\n+     * Test the invocation of default methods with varargs\n+     *\/\n+    @Test\n+    public static void testVarargsMethods() throws Throwable {\n+        MethodHandle target = MethodHandles.lookup().findStatic(Main.class,\n+                \"concat\", MethodType.methodType(String.class, Object[].class));\n+        C proxy = MethodHandleProxies.asInterfaceInstance(C.class, target);\n+\n+        assertEquals(proxy.c(\"a\", \"b\", \"c\"), \"abc\");\n+        assertEquals(proxy.aConcat(\"a\", \"b\", \"c\"), \"[a, b, c]\");\n+        assertEquals(proxy.aConcat(new Object[] { \"a\", \"b\", \"c\" }), \"[a, b, c]\");\n+        assertEquals(proxy.bConcat(new Object[] { \"a\", \"b\", \"c\" }), \"[a, b, c]\");\n+    }\n+\n+    \/*\n+     * Test the invocation of a default method of an accessible interface\n+     *\/\n+    @Test\n+    public static void modulePrivateInterface() {\n+        MethodHandle target = MethodHandles.constant(String.class, \"test\");\n+        TestIntf t = MethodHandleProxies.asInterfaceInstance(TestIntf.class, target);\n+        assertEquals(t.test(), \"test\");\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandleProxies\/m1\/p1\/Main.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -0,0 +1,25 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+module m2 {\n+    exports p2 to m1;\n+}\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandleProxies\/m2\/module-info.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"added"},{"patch":"@@ -0,0 +1,27 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package p2;\n+\n+public interface TestIntf {\n+    String test();\n+}\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandleProxies\/m2\/p2\/TestIntf.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 6797535 6889858 6891113 8013712 8011800 8014365\n+ * @bug 6797535 6889858 6891113 8013712 8011800 8014365 8280168\n@@ -28,1 +28,0 @@\n- * @author  Joseph D. Darcy\n@@ -43,0 +42,1 @@\n+        errors += testToIdentityString();\n@@ -137,0 +137,31 @@\n+    private static int testToIdentityString() {\n+        int errors = 0;\n+        \/\/ Test null behavior\n+        try {\n+            Objects.toIdentityString(null);\n+            errors++;\n+        } catch (NullPointerException npe) {\n+            ; \/\/ Expected\n+        }\n+        \/\/ Behavior on typical objects\n+        Object o = new Object(){};\n+        errors += (Objects.toIdentityString(o).equals(o.toString()))? 0 : 1;\n+        \/\/ Verify object's toString *not* called\n+        Object badToString = new Object() {\n+                @Override\n+                public String toString() {\n+                    throw new RuntimeException();\n+                }\n+            };\n+        Objects.toIdentityString(badToString);\n+        \/\/ Verify object's hashCode *not* called\n+        Object badHashCode = new Object() {\n+                @Override\n+                public int hashCode() {\n+                    throw new RuntimeException(\"0xDEADBEFF\");\n+                }\n+            };\n+        Objects.toIdentityString(badHashCode);\n+        return errors;\n+    }\n+\n","filename":"test\/jdk\/java\/util\/Objects\/BasicObjectsTest.java","additions":34,"deletions":3,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8185898\n+ * @bug 8185898 8163921\n@@ -146,1 +146,1 @@\n-                        + \"Accept: text\/html, image\/gif, image\/jpeg, *; q=.2, *\/*; q=.2\\r\\n\"\n+                        + \"Accept: *\/*\\r\\n\"\n@@ -151,1 +151,1 @@\n-                        + \"{Accept: text\/html, image\/gif, image\/jpeg, *; q=.2, *\/*; q=.2}\"\n+                        + \"{Accept: *\/*}\"\n@@ -155,1 +155,1 @@\n-                \"Accept: text\/html, image\/gif, image\/jpeg, *; q=.2, *\/*; q=.2\\r\\n\"\n+                \"Accept: *\/*\\r\\n\"\n@@ -160,1 +160,1 @@\n-                        + \"Accept: text\/html, image\/gif, image\/jpeg, *; q=.2, *\/*; q=.2\\r\\n\"\n+                        + \"Accept: *\/*\\r\\n\"\n@@ -166,1 +166,1 @@\n-                        + \"{Accept: text\/html, image\/gif, image\/jpeg, *; q=.2, *\/*; q=.2}\"\n+                        + \"{Accept: *\/*}\"\n@@ -171,1 +171,1 @@\n-                \"Accept: text\/html, image\/gif, image\/jpeg, *; q=.2, *\/*; q=.2\\r\\n\"\n+                \"Accept: *\/*\\r\\n\"\n","filename":"test\/jdk\/sun\/net\/www\/B8185898.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"}]}