{"files":[{"patch":"@@ -46,2 +46,0 @@\n-address ShenandoahBarrierSetAssembler::_shenandoah_lrb = NULL;\n-\n@@ -230,1 +228,1 @@\n-void ShenandoahBarrierSetAssembler::load_reference_barrier_not_null(MacroAssembler* masm, Register dst, Address load_addr) {\n+void ShenandoahBarrierSetAssembler::load_reference_barrier(MacroAssembler* masm, Register dst, Address load_addr, bool weak) {\n@@ -235,1 +233,1 @@\n-  Label done;\n+  Label heap_stable, not_cset;\n@@ -241,1 +239,1 @@\n-  __ tbz(rscratch2, ShenandoahHeap::HAS_FORWARDED_BITPOS, done);\n+  __ tbz(rscratch2, ShenandoahHeap::HAS_FORWARDED_BITPOS, heap_stable);\n@@ -256,12 +254,6 @@\n-  __ far_call(RuntimeAddress(CAST_FROM_FN_PTR(address, ShenandoahBarrierSetAssembler::shenandoah_lrb())));\n-\n-  __ mov(result_dst, r0);\n-  __ pop(to_save, sp);\n-\n-  __ bind(done);\n-  __ leave();\n-}\n-\n-void ShenandoahBarrierSetAssembler::load_reference_barrier_weak(MacroAssembler* masm, Register dst, Address load_addr) {\n-  if (!ShenandoahLoadRefBarrier) {\n-    return;\n+  \/\/ Test for in-cset\n+  if (!weak) {\n+    __ mov(rscratch2, ShenandoahHeap::in_cset_fast_test_addr());\n+    __ lsr(rscratch1, r0, ShenandoahHeapRegion::region_size_bytes_shift_jint());\n+    __ ldrb(rscratch2, Address(rscratch2, rscratch1));\n+    __ tbz(rscratch2, 0, not_cset);\n@@ -270,18 +262,0 @@\n-  assert(dst != rscratch2, \"need rscratch2\");\n-\n-  Label is_null;\n-  Label done;\n-\n-  __ block_comment(\"load_reference_barrier_weak { \");\n-\n-  __ cbz(dst, is_null);\n-\n-  __ enter();\n-\n-  Address gc_state(rthread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));\n-  __ ldrb(rscratch2, gc_state);\n-\n-  \/\/ Check for heap in evacuation phase\n-  __ tbz(rscratch2, ShenandoahHeap::HAS_FORWARDED_BITPOS, done);\n-\n-  __ mov(rscratch2, dst);\n@@ -289,3 +263,9 @@\n-  __ mov(lr, CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_weak));\n-  __ lea(r1, load_addr);\n-  __ mov(r0, rscratch2);\n+  if (weak) {\n+    __ mov(lr, CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_weak));\n+  } else {\n+    if (UseCompressedOops) {\n+      __ mov(lr, CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_narrow));\n+    } else {\n+      __ mov(lr, CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier));\n+    }\n+  }\n@@ -293,1 +273,1 @@\n-  __ mov(rscratch2, r0);\n+  __ mov(rscratch1, r0);\n@@ -295,1 +275,1 @@\n-  __ mov(dst, rscratch2);\n+  __ mov(r0, rscratch1);\n@@ -297,1 +277,6 @@\n-  __ bind(done);\n+  __ bind(not_cset);\n+\n+  __ mov(result_dst, r0);\n+  __ pop(to_save, sp);\n+\n+  __ bind(heap_stable);\n@@ -299,2 +284,0 @@\n-  __ bind(is_null);\n-  __ block_comment(\"} load_reference_barrier_weak\");\n@@ -311,9 +294,0 @@\n-void ShenandoahBarrierSetAssembler::load_reference_barrier(MacroAssembler* masm, Register dst, Address load_addr) {\n-  if (ShenandoahLoadRefBarrier) {\n-    Label is_null;\n-    __ cbz(dst, is_null);\n-    load_reference_barrier_not_null(masm, dst, load_addr);\n-    __ bind(is_null);\n-  }\n-}\n-\n@@ -355,5 +329,2 @@\n-    if (ShenandoahBarrierSet::use_load_reference_barrier_weak(decorators, type)) {\n-      load_reference_barrier_weak(masm, dst, src);\n-    } else {\n-      load_reference_barrier(masm, dst, src);\n-    }\n+    bool weak = ShenandoahBarrierSet::use_load_reference_barrier_weak(decorators, type);\n+    load_reference_barrier(masm, dst, src, weak);\n@@ -756,64 +727,0 @@\n-\n-address ShenandoahBarrierSetAssembler::shenandoah_lrb() {\n-  assert(_shenandoah_lrb != NULL, \"need load reference barrier stub\");\n-  return _shenandoah_lrb;\n-}\n-\n-#define __ cgen->assembler()->\n-\n-\/\/ Shenandoah load reference barrier.\n-\/\/\n-\/\/ Input:\n-\/\/   r0: OOP to evacuate.  Not null.\n-\/\/   r1: load address\n-\/\/\n-\/\/ Output:\n-\/\/   r0: Pointer to evacuated OOP.\n-\/\/\n-\/\/ Trash rscratch1, rscratch2.  Preserve everything else.\n-address ShenandoahBarrierSetAssembler::generate_shenandoah_lrb(StubCodeGenerator* cgen) {\n-\n-  __ align(6);\n-  StubCodeMark mark(cgen, \"StubRoutines\", \"shenandoah_lrb\");\n-  address start = __ pc();\n-\n-  Label slow_path;\n-  __ mov(rscratch2, ShenandoahHeap::in_cset_fast_test_addr());\n-  __ lsr(rscratch1, r0, ShenandoahHeapRegion::region_size_bytes_shift_jint());\n-  __ ldrb(rscratch2, Address(rscratch2, rscratch1));\n-  __ tbnz(rscratch2, 0, slow_path);\n-  __ ret(lr);\n-\n-  __ bind(slow_path);\n-  __ enter(); \/\/ required for proper stackwalking of RuntimeStub frame\n-\n-  __ push_call_clobbered_registers();\n-\n-  if (UseCompressedOops) {\n-    __ mov(lr, CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_narrow));\n-  } else {\n-    __ mov(lr, CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier));\n-  }\n-  __ blr(lr);\n-  __ mov(rscratch1, r0);\n-  __ pop_call_clobbered_registers();\n-  __ mov(r0, rscratch1);\n-\n-  __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n-  __ ret(lr);\n-\n-  return start;\n-}\n-\n-#undef __\n-\n-void ShenandoahBarrierSetAssembler::barrier_stubs_init() {\n-  if (ShenandoahLoadRefBarrier) {\n-    int stub_code_size = 2048;\n-    ResourceMark rm;\n-    BufferBlob* bb = BufferBlob::create(\"shenandoah_barrier_stubs\", stub_code_size);\n-    CodeBuffer buf(bb);\n-    StubCodeGenerator cgen(&buf);\n-    _shenandoah_lrb = generate_shenandoah_lrb(&cgen);\n-  }\n-}\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shenandoah\/shenandoahBarrierSetAssembler_aarch64.cpp","additions":28,"deletions":121,"binary":false,"changes":149,"status":"modified"},{"patch":"@@ -41,2 +41,0 @@\n-  static address _shenandoah_lrb;\n-\n@@ -60,5 +58,1 @@\n-  void load_reference_barrier(MacroAssembler* masm, Register dst, Address load_addr);\n-  void load_reference_barrier_not_null(MacroAssembler* masm, Register dst, Address load_addr);\n-  void load_reference_barrier_weak(MacroAssembler* masm, Register dst, Address load_addr);\n-\n-  address generate_shenandoah_lrb(StubCodeGenerator* cgen);\n+  void load_reference_barrier(MacroAssembler* masm, Register dst, Address load_addr, bool weak);\n@@ -67,1 +61,0 @@\n-  static address shenandoah_lrb();\n@@ -88,2 +81,0 @@\n-\n-  virtual void barrier_stubs_init();\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shenandoah\/shenandoahBarrierSetAssembler_aarch64.hpp","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-#include \"interpreter\/interp_masm.hpp\"\n@@ -47,2 +46,0 @@\n-address ShenandoahBarrierSetAssembler::_shenandoah_lrb = NULL;\n-\n@@ -274,1 +271,1 @@\n-void ShenandoahBarrierSetAssembler::load_reference_barrier_not_null(MacroAssembler* masm, Register dst, Address src) {\n+void ShenandoahBarrierSetAssembler::load_reference_barrier(MacroAssembler* masm, Register dst, Address src, bool weak) {\n@@ -277,1 +274,1 @@\n-  Label done;\n+  Label heap_stable, not_cset;\n@@ -279,0 +276,3 @@\n+  __ block_comment(\"load_reference_barrier { \");\n+\n+  \/\/ Check if GC is active\n@@ -292,33 +292,12 @@\n-  __ jccb(Assembler::zero, done);\n-\n-  \/\/ Use rsi for src address\n-  const Register src_addr = rsi;\n-  \/\/ Setup address parameter first, if it does not clobber oop in dst\n-  bool need_addr_setup = (src_addr != dst);\n-\n-  if (need_addr_setup) {\n-    __ push(src_addr);\n-    __ lea(src_addr, src);\n-\n-    if (dst != rax) {\n-      \/\/ Move obj into rax and save rax\n-      __ push(rax);\n-      __ movptr(rax, dst);\n-    }\n-  } else {\n-    \/\/ dst == rsi\n-    __ push(rax);\n-    __ movptr(rax, dst);\n-\n-    \/\/ we can clobber it, since it is outgoing register\n-    __ lea(src_addr, src);\n-  }\n-\n-  save_xmm_registers(masm);\n-  __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, ShenandoahBarrierSetAssembler::shenandoah_lrb())));\n-  restore_xmm_registers(masm);\n-\n-  if (need_addr_setup) {\n-    if (dst != rax) {\n-      __ movptr(dst, rax);\n-      __ pop(rax);\n+  __ jcc(Assembler::zero, heap_stable);\n+\n+  Register tmp1 = noreg;\n+  if (!weak) {\n+    \/\/ Test for object in cset\n+    \/\/ Allocate tmp-reg.\n+    for (int i = 0; i < 8; i++) {\n+      Register r = as_Register(i);\n+      if (r != rsp && r != rbp && r != dst && r != src.base() && r != src.index()) {\n+        tmp1 = r;\n+        break;\n+      }\n@@ -326,29 +305,3 @@\n-    __ pop(src_addr);\n-  } else {\n-    __ movptr(dst, rax);\n-    __ pop(rax);\n-  }\n-\n-  __ bind(done);\n-\n-#ifndef _LP64\n-    __ pop(thread);\n-#endif\n-}\n-\n-void ShenandoahBarrierSetAssembler::load_reference_barrier_weak(MacroAssembler* masm, Register dst, Address src) {\n-  if (!ShenandoahLoadRefBarrier) {\n-    return;\n-  }\n-\n-  Label done;\n-  Label not_null;\n-  Label slow_path;\n-  __ block_comment(\"load_reference_barrier_weak { \");\n-\n-  \/\/ null check\n-  __ testptr(dst, dst);\n-  __ jcc(Assembler::notZero, not_null);\n-  __ jmp(done);\n-  __ bind(not_null);\n-\n+    __ push(tmp1);\n+    assert_different_registers(tmp1, src.base(), src.index());\n+    assert_different_registers(tmp1, dst);\n@@ -356,6 +309,6 @@\n-#ifdef _LP64\n-  Register thread = r15_thread;\n-#else\n-  Register thread = rcx;\n-  if (thread == dst) {\n-    thread = rbx;\n+    \/\/ Optimized cset-test\n+    __ movptr(tmp1, dst);\n+    __ shrptr(tmp1, ShenandoahHeapRegion::region_size_bytes_shift_jint());\n+    __ movbool(tmp1, Address(tmp1, (intptr_t) ShenandoahHeap::in_cset_fast_test_addr(), Address::times_1));\n+    __ testbool(tmp1);\n+    __ jcc(Assembler::zero, not_cset);\n@@ -363,13 +316,0 @@\n-  __ push(thread);\n-  __ get_thread(thread);\n-#endif\n-  assert_different_registers(dst, thread);\n-\n-  Address gc_state(thread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));\n-  __ testb(gc_state, ShenandoahHeap::HAS_FORWARDED);\n-#ifndef _LP64\n-  __ pop(thread);\n-#endif\n-  __ jccb(Assembler::notZero, slow_path);\n-  __ jmp(done);\n-  __ bind(slow_path);\n@@ -377,0 +317,3 @@\n+  uint num_saved_regs = 4 + (dst != rax ? 1 : 0) LP64_ONLY(+4);\n+  __ subptr(rsp, num_saved_regs * wordSize);\n+  uint slot = num_saved_regs;\n@@ -378,1 +321,1 @@\n-    __ push(rax);\n+    __ movptr(Address(rsp, (--slot) * wordSize), rax);\n@@ -380,4 +323,4 @@\n-  __ push(rcx);\n-  __ push(rdx);\n-  __ push(rdi);\n-  __ push(rsi);\n+  __ movptr(Address(rsp, (--slot) * wordSize), rcx);\n+  __ movptr(Address(rsp, (--slot) * wordSize), rdx);\n+  __ movptr(Address(rsp, (--slot) * wordSize), rdi);\n+  __ movptr(Address(rsp, (--slot) * wordSize), rsi);\n@@ -385,8 +328,5 @@\n-  __ push(r8);\n-  __ push(r9);\n-  __ push(r10);\n-  __ push(r11);\n-  __ push(r12);\n-  __ push(r13);\n-  __ push(r14);\n-  __ push(r15);\n+  __ movptr(Address(rsp, (--slot) * wordSize), r8);\n+  __ movptr(Address(rsp, (--slot) * wordSize), r9);\n+  __ movptr(Address(rsp, (--slot) * wordSize), r10);\n+  __ movptr(Address(rsp, (--slot) * wordSize), r11);\n+  \/\/ r12-r15 are callee saved in all calling conventions\n@@ -394,0 +334,1 @@\n+  assert(slot == 0, \"must use all slots\");\n@@ -395,2 +336,3 @@\n-  assert_different_registers(dst, rsi);\n-  __ lea(rsi, src);\n+  Register tmp2 = (dst == rsi) ? rdx : rsi;\n+  assert_different_registers(dst, tmp2);\n+  __ lea(tmp2, src);\n@@ -399,1 +341,9 @@\n-  __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_weak), dst, rsi);\n+  if (weak) {\n+    __ super_call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_weak), dst, tmp2);\n+  } else {\n+    if (UseCompressedOops) {\n+      __ super_call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_narrow), dst, tmp2);\n+    } else {\n+      __ super_call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier), dst, tmp2);\n+    }\n+  }\n@@ -403,8 +353,4 @@\n-  __ pop(r15);\n-  __ pop(r14);\n-  __ pop(r13);\n-  __ pop(r12);\n-  __ pop(r11);\n-  __ pop(r10);\n-  __ pop(r9);\n-  __ pop(r8);\n+  __ movptr(r11, Address(rsp, (slot++) * wordSize));\n+  __ movptr(r10, Address(rsp, (slot++) * wordSize));\n+  __ movptr(r9,  Address(rsp, (slot++) * wordSize));\n+  __ movptr(r8,  Address(rsp, (slot++) * wordSize));\n@@ -412,4 +358,4 @@\n-  __ pop(rsi);\n-  __ pop(rdi);\n-  __ pop(rdx);\n-  __ pop(rcx);\n+  __ movptr(rsi, Address(rsp, (slot++) * wordSize));\n+  __ movptr(rdi, Address(rsp, (slot++) * wordSize));\n+  __ movptr(rdx, Address(rsp, (slot++) * wordSize));\n+  __ movptr(rcx, Address(rsp, (slot++) * wordSize));\n@@ -419,1 +365,1 @@\n-    __ pop(rax);\n+    __ movptr(rax, Address(rsp, (slot++) * wordSize));\n@@ -422,2 +368,16 @@\n-  __ bind(done);\n-  __ block_comment(\"} load_reference_barrier_weak\");\n+  assert(slot == num_saved_regs, \"must use all slots\");\n+  __ addptr(rsp, num_saved_regs * wordSize);\n+\n+  __ bind(not_cset);\n+\n+  if  (!weak) {\n+    __ pop(tmp1);\n+  }\n+\n+  __ bind(heap_stable);\n+\n+  __ block_comment(\"} load_reference_barrier\");\n+\n+#ifndef _LP64\n+    __ pop(thread);\n+#endif\n@@ -467,10 +427,0 @@\n-void ShenandoahBarrierSetAssembler::load_reference_barrier(MacroAssembler* masm, Register dst, Address src) {\n-  if (ShenandoahLoadRefBarrier) {\n-    Label done;\n-    __ testptr(dst, dst);\n-    __ jcc(Assembler::zero, done);\n-    load_reference_barrier_not_null(masm, dst, src);\n-    __ bind(done);\n-  }\n-}\n-\n@@ -507,1 +457,1 @@\n-      \/\/ Use tmp1 for dst if possible, as it is not used in BarrierAssembler::load_at()\n+    \/\/ Use tmp1 for dst if possible, as it is not used in BarrierAssembler::load_at()\n@@ -520,5 +470,2 @@\n-    if (ShenandoahBarrierSet::use_load_reference_barrier_weak(decorators, type)) {\n-      load_reference_barrier_weak(masm, dst, src);\n-    } else {\n-      load_reference_barrier(masm, dst, src);\n-    }\n+    bool weak = ShenandoahBarrierSet::use_load_reference_barrier_weak(decorators, type);\n+    load_reference_barrier(masm, dst, src, weak);\n@@ -975,101 +922,0 @@\n-\n-address ShenandoahBarrierSetAssembler::shenandoah_lrb() {\n-  assert(_shenandoah_lrb != NULL, \"need load reference barrier stub\");\n-  return _shenandoah_lrb;\n-}\n-\n-#define __ cgen->assembler()->\n-\n-\/*\n- *  Incoming parameters:\n- *  rax: oop\n- *  rsi: load address\n- *\/\n-address ShenandoahBarrierSetAssembler::generate_shenandoah_lrb(StubCodeGenerator* cgen) {\n-  __ align(CodeEntryAlignment);\n-  StubCodeMark mark(cgen, \"StubRoutines\", \"shenandoah_lrb\");\n-  address start = __ pc();\n-\n-  Label slow_path;\n-\n-  \/\/ We use RDI, which also serves as argument register for slow call.\n-  \/\/ RAX always holds the src object ptr, except after the slow call,\n-  \/\/ then it holds the result. R8\/RBX is used as temporary register.\n-\n-  Register tmp1 = rdi;\n-  Register tmp2 = LP64_ONLY(r8) NOT_LP64(rbx);\n-\n-  __ push(tmp1);\n-  __ push(tmp2);\n-\n-  \/\/ Check for object being in the collection set.\n-  __ mov(tmp1, rax);\n-  __ shrptr(tmp1, ShenandoahHeapRegion::region_size_bytes_shift_jint());\n-  __ movptr(tmp2, (intptr_t) ShenandoahHeap::in_cset_fast_test_addr());\n-  __ movbool(tmp2, Address(tmp2, tmp1, Address::times_1));\n-  __ testbool(tmp2);\n-  __ jccb(Assembler::notZero, slow_path);\n-  __ pop(tmp2);\n-  __ pop(tmp1);\n-  __ ret(0);\n-\n-  __ bind(slow_path);\n-\n-  __ push(rcx);\n-  __ push(rdx);\n-  __ push(rdi);\n-#ifdef _LP64\n-  __ push(r8);\n-  __ push(r9);\n-  __ push(r10);\n-  __ push(r11);\n-  __ push(r12);\n-  __ push(r13);\n-  __ push(r14);\n-  __ push(r15);\n-#endif\n-  __ push(rbp);\n-  __ movptr(rbp, rsp);\n-  __ andptr(rsp, -StackAlignmentInBytes);\n-  __ push_FPU_state();\n-  if (UseCompressedOops) {\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_narrow), rax, rsi);\n-  } else {\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier), rax, rsi);\n-  }\n-  __ pop_FPU_state();\n-  __ movptr(rsp, rbp);\n-  __ pop(rbp);\n-#ifdef _LP64\n-  __ pop(r15);\n-  __ pop(r14);\n-  __ pop(r13);\n-  __ pop(r12);\n-  __ pop(r11);\n-  __ pop(r10);\n-  __ pop(r9);\n-  __ pop(r8);\n-#endif\n-  __ pop(rdi);\n-  __ pop(rdx);\n-  __ pop(rcx);\n-\n-  __ pop(tmp2);\n-  __ pop(tmp1);\n-  __ ret(0);\n-\n-  return start;\n-}\n-\n-#undef __\n-\n-void ShenandoahBarrierSetAssembler::barrier_stubs_init() {\n-  if (ShenandoahLoadRefBarrier) {\n-    int stub_code_size = 4096;\n-    ResourceMark rm;\n-    BufferBlob* bb = BufferBlob::create(\"shenandoah_barrier_stubs\", stub_code_size);\n-    CodeBuffer buf(bb);\n-    StubCodeGenerator cgen(&buf);\n-    _shenandoah_lrb = generate_shenandoah_lrb(&cgen);\n-  }\n-}\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shenandoah\/shenandoahBarrierSetAssembler_x86.cpp","additions":80,"deletions":234,"binary":false,"changes":314,"status":"modified"},{"patch":"@@ -41,2 +41,0 @@\n-  static address _shenandoah_lrb;\n-\n@@ -59,2 +57,0 @@\n-  void load_reference_barrier_not_null(MacroAssembler* masm, Register dst, Address src);\n-\n@@ -63,2 +59,0 @@\n-  address generate_shenandoah_lrb(StubCodeGenerator* cgen);\n-\n@@ -66,2 +60,0 @@\n-  static address shenandoah_lrb();\n-\n@@ -76,2 +68,1 @@\n-  void load_reference_barrier(MacroAssembler* masm, Register dst, Address src);\n-  void load_reference_barrier_weak(MacroAssembler* masm, Register dst, Address src);\n+  void load_reference_barrier(MacroAssembler* masm, Register dst, Address src, bool weak);\n@@ -90,2 +81,0 @@\n-  virtual void barrier_stubs_init();\n-\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shenandoah\/shenandoahBarrierSetAssembler_x86.hpp","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"}]}