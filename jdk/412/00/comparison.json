{"files":[{"patch":"@@ -33,0 +33,8 @@\n+\/**\n+ * The base class for the DocLint service used by javac.\n+ *\n+ * <p><b>This is NOT part of any supported API.\n+ * If you write code that depends on this, you do so at your own risk.\n+ * This code and its internal interfaces are subject to change or\n+ * deletion without notice.<\/b>\n+ *\/\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/doclint\/DocLint.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -261,1 +261,1 @@\n-        String value = utils.constantValueExpresion(member);\n+        String value = utils.constantValueExpression(member);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/ConstantsSummaryWriterImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,6 @@\n-import java.util.*;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n@@ -30,1 +35,0 @@\n-\n@@ -39,1 +43,0 @@\n-\n@@ -204,1 +207,1 @@\n-        workArounds.initDocLint(options.doclintOpts(), tagletManager.getAllTagletNames());\n+        initDocLint(options.doclintOpts(), tagletManager.getAllTagletNames());\n@@ -324,1 +327,1 @@\n-        return (path == null || workArounds.haveDocLint());\n+        return (path == null || !haveDocLint());\n@@ -329,1 +332,1 @@\n-        return (e == null || workArounds.haveDocLint());\n+        return (e == null || !haveDocLint());\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlConfiguration.java","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import java.io.*;\n-import java.util.*;\n@@ -31,0 +29,17 @@\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.SortedMap;\n+import java.util.SortedSet;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+\n+import javax.lang.model.SourceVersion;\n@@ -35,0 +50,1 @@\n+import javax.lang.model.util.Elements;\n@@ -39,0 +55,1 @@\n+import com.sun.source.tree.CompilationUnitTree;\n@@ -40,0 +57,1 @@\n+import com.sun.source.util.TreePath;\n@@ -47,1 +65,0 @@\n-import jdk.javadoc.internal.doclets.formats.html.HtmlDoclet;\n@@ -63,0 +80,1 @@\n+import jdk.javadoc.internal.doclint.DocLint;\n@@ -204,1 +222,1 @@\n-     * (such as the {@link HtmlDoclet}).  In such cases, the primary doclet (i.e\n+     * (such as the {@code HtmlDoclet}).  In such cases, the primary doclet (i.e\n@@ -370,1 +388,10 @@\n-        overviewElement = new OverviewElement(workArounds.getUnnamedPackage(), getOverviewPath());\n+\n+        PackageElement unnamedPackage;\n+        Elements elementUtils = utils.elementUtils;\n+        if (docEnv.getSourceVersion().compareTo(SourceVersion.RELEASE_9) >= 0) {\n+            ModuleElement unnamedModule = elementUtils.getModuleElement(\"\");\n+            unnamedPackage = elementUtils.getPackageElement(unnamedModule, \"\");\n+        } else {\n+            unnamedPackage = elementUtils.getPackageElement(\"\");\n+        }\n+        overviewElement = new OverviewElement(unnamedPackage, getOverviewPath());\n@@ -693,0 +720,87 @@\n+\n+\n+    \/\/<editor-fold desc=\"DocLint support\">\n+\n+    private DocLint doclint;\n+\n+    Map<CompilationUnitTree, Boolean> shouldCheck = new HashMap<>();\n+\n+    public void runDocLint(TreePath path) {\n+        CompilationUnitTree unit = path.getCompilationUnit();\n+        if (doclint != null && shouldCheck.computeIfAbsent(unit, doclint::shouldCheck)) {\n+            doclint.scan(path);\n+        }\n+    }\n+\n+    \/**\n+     * Initializes DocLint, if appropriate, depending on options derived\n+     * from the doclet command-line options, and the set of custom tags\n+     * that should be ignored by DocLint.\n+     *\n+     * DocLint is not enabled if the option {@code -Xmsgs:none} is given,\n+     * and it is not followed by any options to enable any groups.\n+     * Note that arguments for {@code -Xmsgs:} can be given individually\n+     * in separate {@code -Xmsgs:} options, or in a comma-separated list\n+     * for a single option. For example, the following are equivalent:\n+     * <ul>\n+     *     <li>{@code -Xmsgs:all} {@code -Xmsgs:-html}\n+     *     <li>{@code -Xmsgs:all,-html}\n+     * <\/ul>\n+     *\n+     * @param opts  options for DocLint, derived from the corresponding doclet\n+     *              command-line options\n+     * @param customTagNames the names of custom tags, to be ignored by doclint\n+     *\/\n+    public void initDocLint(List<String> opts, Set<String> customTagNames) {\n+        List<String> doclintOpts = new ArrayList<>();\n+\n+        \/\/ basic analysis of -Xmsgs and -Xmsgs: options to see if doclint is enabled\n+        Set<String> groups = new HashSet<>();\n+        boolean seenXmsgs = false;\n+        for (String opt : opts) {\n+            if (opt.equals(DocLint.XMSGS_OPTION)) {\n+                groups.add(\"all\");\n+                seenXmsgs = true;\n+            } else if (opt.startsWith(DocLint.XMSGS_CUSTOM_PREFIX)) {\n+                String[] args = opt.substring(DocLint.XMSGS_CUSTOM_PREFIX.length())\n+                        .split(DocLint.SEPARATOR);\n+                for (String a : args) {\n+                    if (a.equals(\"none\")) {\n+                        groups.clear();\n+                    } else if (a.startsWith(\"-\")) {\n+                        groups.remove(a.substring(1));\n+                    } else {\n+                        groups.add(a);\n+                    }\n+                }\n+                seenXmsgs = true;\n+            }\n+            doclintOpts.add(opt);\n+        }\n+\n+        if (seenXmsgs) {\n+            if (groups.isEmpty()) {\n+                \/\/ no groups enabled; do not init doclint\n+                return;\n+            }\n+        } else {\n+            \/\/ no -Xmsgs options of any kind, use default\n+            doclintOpts.add(DocLint.XMSGS_OPTION);\n+        }\n+\n+        if (!customTagNames.isEmpty()) {\n+            String customTags = String.join(DocLint.SEPARATOR, customTagNames);\n+            doclintOpts.add(DocLint.XCUSTOM_TAGS_PREFIX + customTags);\n+        }\n+\n+        doclintOpts.add(DocLint.XHTML_VERSION_PREFIX + \"html5\");\n+\n+        doclint = new DocLint();\n+        doclint.init(docEnv.getDocTrees(), docEnv.getElementUtils(), docEnv.getTypeUtils(),\n+                doclintOpts.toArray(new String[0]));\n+    }\n+\n+    public boolean haveDocLint() {\n+        return (doclint != null);\n+    }\n+    \/\/<\/editor-fold>\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/BaseConfiguration.java","additions":119,"deletions":5,"binary":false,"changes":124,"status":"modified"},{"patch":"@@ -430,2 +430,2 @@\n-                fo = configuration.workArounds.getJavaFileObject((PackageElement)e);\n-                pe = (PackageElement)e;\n+                pe = (PackageElement) e;\n+                fo = configuration.workArounds.getJavaFileObject(pe);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/CommentUtils.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -119,1 +119,1 @@\n-        if (configuration.showMessage(path, key))\n+        if (configuration.showMessage(path, key)) {\n@@ -121,0 +121,1 @@\n+        }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/Messages.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+import javax.lang.model.util.Types;\n@@ -97,2 +98,3 @@\n-\n-    private DocLint doclint;\n+    public final Elements elementUtils;\n+    public final Types typeUtils;\n+    public final com.sun.tools.javac.code.Types javacTypes;\n@@ -103,57 +105,0 @@\n-        this.toolEnv = ((DocEnvImpl)this.configuration.docEnv).toolEnv;\n-    }\n-\n-    Map<CompilationUnitTree, Boolean> shouldCheck = new HashMap<>();\n-    \/\/ TODO: fix this up correctly\n-    public void runDocLint(TreePath path) {\n-        CompilationUnitTree unit = path.getCompilationUnit();\n-        if (doclint != null && shouldCheck.computeIfAbsent(unit, doclint::shouldCheck)) {\n-            doclint.scan(path);\n-        }\n-    }\n-\n-    \/**\n-     * Initializes doclint, if appropriate, depending on options derived\n-     * from the doclet command-line options, and the set of custom tags\n-     * that should be ignored by doclint.\n-     *\n-     * DocLint is not enabled if the option {@code -Xmsgs:none} is given,\n-     * and it is not followed by any options to enable any groups.\n-     * Note that arguments for {@code -Xmsgs:} can be given individually\n-     * in separate {@code -Xmsgs:} options, or in a comma-separated list\n-     * for a single option. For example, the following are equivalent:\n-     * <ul>\n-     *     <li>{@code -Xmsgs:all} {@code -Xmsgs:-html}\n-     *     <li>{@code -Xmsgs:all,-html}\n-     * <\/ul>\n-     *\n-     * @param opts  options for doclint, derived from the corresponding doclet\n-     *              command-line options\n-     * @param customTagNames the names of custom tags, to be ignored by doclint\n-     *\/\n-    public void initDocLint(List<String> opts, Set<String> customTagNames) {\n-        List<String> doclintOpts = new ArrayList<>();\n-\n-        \/\/ basic analysis of -Xmsgs and -Xmsgs: options to see if doclint is enabled\n-        Set<String> groups = new HashSet<>();\n-        boolean seenXmsgs = false;\n-        for (String opt : opts) {\n-            if (opt.equals(DocLint.XMSGS_OPTION)) {\n-                groups.add(\"all\");\n-                seenXmsgs = true;\n-            } else if (opt.startsWith(DocLint.XMSGS_CUSTOM_PREFIX)) {\n-                String[] args = opt.substring(DocLint.XMSGS_CUSTOM_PREFIX.length())\n-                        .split(DocLint.SEPARATOR);\n-                for (String a : args) {\n-                    if (a.equals(\"none\")) {\n-                        groups.clear();\n-                    } else if (a.startsWith(\"-\")) {\n-                        groups.remove(a.substring(1));\n-                    } else {\n-                        groups.add(a);\n-                    }\n-                }\n-                seenXmsgs = true;\n-            }\n-            doclintOpts.add(opt);\n-        }\n@@ -161,9 +106,2 @@\n-        if (seenXmsgs) {\n-            if (groups.isEmpty()) {\n-                \/\/ no groups enabled; do not init doclint\n-                return;\n-            }\n-        } else {\n-            \/\/ no -Xmsgs options of any kind, use default\n-            doclintOpts.add(DocLint.XMSGS_OPTION);\n-        }\n+        elementUtils = configuration.docEnv.getElementUtils();\n+        typeUtils = configuration.docEnv.getTypeUtils();\n@@ -171,15 +109,5 @@\n-        if (!customTagNames.isEmpty()) {\n-            String customTags = String.join(DocLint.SEPARATOR, customTagNames);\n-            doclintOpts.add(DocLint.XCUSTOM_TAGS_PREFIX + customTags);\n-        }\n-\n-        doclintOpts.add(DocLint.XHTML_VERSION_PREFIX + \"html5\");\n-\n-        JavacTask t = BasicJavacTask.instance(toolEnv.context);\n-        doclint = new DocLint();\n-        doclint.init(t, doclintOpts.toArray(new String[0]), false);\n-    }\n-\n-    \/\/ TODO: fix this up correctly\n-    public boolean haveDocLint() {\n-        return (doclint == null);\n+        \/\/ Note: this one use of DocEnvImpl is what prevents us tunnelling extra\n+        \/\/ info from a doclet to its taglets via a doclet-specific subtype of\n+        \/\/ DocletEnvironment.\n+        toolEnv = ((DocEnvImpl)this.configuration.docEnv).toolEnv;\n+        javacTypes = toolEnv.getTypes();\n@@ -190,2 +118,2 @@\n-     * handle \"@deprecated tag in package-info.java\", when this issue\n-     * is fixed this method and its uses must be jettisoned.\n+     *       handle \"@deprecated tag in package-info.java\", when this issue\n+     *       is fixed this method and its uses must be jettisoned.\n@@ -197,1 +125,0 @@\n-        JavacTypes jctypes = ((DocEnvImpl)configuration.docEnv).toolEnv.typeutils;\n@@ -200,1 +127,1 @@\n-            if (jctypes.isSameType(anno.getAnnotationType().asElement().asType(), deprecatedType))\n+            if (typeUtils.isSameType(anno.getAnnotationType().asElement().asType(), deprecatedType))\n@@ -211,5 +138,0 @@\n-    \/\/ TODO: fix the caller\n-    public Object getConstValue(VariableElement ve) {\n-        return ((VarSymbol)ve).getConstValue();\n-    }\n-\n@@ -221,8 +143,0 @@\n-    \/\/ TODO: we need ElementUtils.getPackage to cope with input strings\n-    \/\/ to return the proper unnamedPackage for all supported releases.\n-    PackageElement getUnnamedPackage() {\n-        return (Feature.MODULES.allowedInSource(toolEnv.source))\n-                ? toolEnv.syms.unnamedModule.unnamedPackage\n-                : toolEnv.syms.noModule.unnamedPackage;\n-    }\n-\n@@ -241,1 +155,1 @@\n-            te = configuration.docEnv.getElementUtils().getTypeElement(me, className);\n+            te = elementUtils.getTypeElement(me, className);\n@@ -293,6 +207,1 @@\n-        te = configuration.docEnv.getElementUtils().getTypeElement(className);\n-        if (te != null) {\n-            return te;\n-        }\n-\n-        return null; \/\/ not found\n+        return elementUtils.getTypeElement(className);\n@@ -302,2 +211,2 @@\n-    \/\/ implications on testInterface, the note here is that javac's supertype\n-    \/\/ does the right thing returning Parameters in scope.\n+    \/\/        implications on testInterface, the note here is that javac's supertype\n+    \/\/        does the right thing returning Parameters in scope.\n@@ -314,1 +223,1 @@\n-        MethodSymbol sym = (MethodSymbol)method;\n+        MethodSymbol sym = (MethodSymbol) method;\n@@ -316,1 +225,1 @@\n-        for (com.sun.tools.javac.code.Type t = toolEnv.getTypes().supertype(origin.type);\n+        for (com.sun.tools.javac.code.Type t = javacTypes.supertype(origin.type);\n@@ -318,1 +227,1 @@\n-                t = toolEnv.getTypes().supertype(t)) {\n+                t = javacTypes.supertype(t)) {\n@@ -321,1 +230,1 @@\n-                if (sym.overrides(sym2, origin, toolEnv.getTypes(), true)) {\n+                if (sym.overrides(sym2, origin, javacTypes, true)) {\n@@ -356,1 +265,1 @@\n-               ridee.isMemberOf(origin, toolEnv.getTypes()) &&\n+               ridee.isMemberOf(origin, javacTypes) &&\n@@ -359,1 +268,1 @@\n-               rider.overrides(ridee, origin, toolEnv.getTypes(), true);\n+               rider.overrides(ridee, origin, javacTypes, true);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/WorkArounds.java","additions":24,"deletions":115,"binary":false,"changes":139,"status":"modified"},{"patch":"@@ -241,1 +241,1 @@\n-                                        utils.constantValueExpresion(field), serialUidTree);\n+                                        utils.constantValueExpression(field), serialUidTree);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/builders\/SerializedFormBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -104,1 +104,1 @@\n-                utils.constantValueExpresion(field),\n+                utils.constantValueExpression(field),\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/ValueTaglet.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -110,0 +110,1 @@\n+import jdk.javadoc.internal.doclets.toolkit.CommentUtils;\n@@ -112,1 +113,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.WorkArounds;\n@@ -2271,1 +2271,1 @@\n-    public String constantValueExpresion(VariableElement ve) {\n+    public String constantValueExpression(VariableElement ve) {\n@@ -2274,22 +2274,2 @@\n-        return cve.constantValueExpression(configuration.workArounds, ve);\n-    }\n-\n-    private static class ConstantValueExpression {\n-        public String constantValueExpression(WorkArounds workArounds, VariableElement ve) {\n-            return new TypeKindVisitor9<String, Object>() {\n-                \/* TODO: we need to fix this correctly.\n-                 * we have a discrepancy here, note the use of getConstValue\n-                 * vs. getConstantValue, at some point we need to use\n-                 * getConstantValue.\n-                 * In the legacy world byte and char primitives appear as Integer values,\n-                 * thus a byte value of 127 will appear as 127, but in the new world,\n-                 * a byte value appears as Byte thus 0x7f will be printed, similarly\n-                 * chars will be  translated to \\n, \\r etc. however, in the new world,\n-                 * they will be printed as decimal values. The new world is correct,\n-                 * and we should fix this by using getConstantValue and the visitor to\n-                 * address this in the future.\n-                 *\/\n-                @Override\n-                public String visitPrimitiveAsBoolean(PrimitiveType t, Object val) {\n-                    return (int)val == 0 ? \"false\" : \"true\";\n-                }\n+        return cve.visit(ve.asType(), ve.getConstantValue());\n+    }\n@@ -2297,4 +2277,8 @@\n-                @Override\n-                public String visitPrimitiveAsDouble(PrimitiveType t, Object val) {\n-                    return sourceForm(((Double)val), 'd');\n-                }\n+    \/\/ We could also use Elements.getConstantValueExpression, which provides\n+    \/\/ similar functionality, but which also includes casts to provide valid\n+    \/\/ compilable constants:  e.g. (byte) 0x7f\n+    private static class ConstantValueExpression extends TypeKindVisitor9<String, Object> {\n+        @Override\n+        public String visitPrimitiveAsBoolean(PrimitiveType t, Object val) {\n+            return ((boolean) val) ? \"true\" : \"false\";\n+        }\n@@ -2302,4 +2286,4 @@\n-                @Override\n-                public String visitPrimitiveAsFloat(PrimitiveType t, Object val) {\n-                    return sourceForm(((Float)val).doubleValue(), 'f');\n-                }\n+        @Override\n+        public String visitPrimitiveAsByte(PrimitiveType t, Object val) {\n+            return \"0x\" + Integer.toString(((Byte) val) & 0xff, 16);\n+        }\n@@ -2307,4 +2291,8 @@\n-                @Override\n-                public String visitPrimitiveAsLong(PrimitiveType t, Object val) {\n-                    return val + \"L\";\n-                }\n+        @Override\n+        public String visitPrimitiveAsChar(PrimitiveType t, Object val) {\n+            StringBuilder buf = new StringBuilder(8);\n+            buf.append('\\'');\n+            sourceChar((char) val, buf);\n+            buf.append('\\'');\n+            return buf.toString();\n+        }\n@@ -2312,13 +2300,22 @@\n-                @Override\n-                protected String defaultAction(TypeMirror e, Object val) {\n-                    if (val == null)\n-                        return null;\n-                    else if (val instanceof Character)\n-                        return sourceForm(((Character)val));\n-                    else if (val instanceof Byte)\n-                        return sourceForm(((Byte)val));\n-                    else if (val instanceof String)\n-                        return sourceForm((String)val);\n-                    return val.toString(); \/\/ covers int, short\n-                }\n-            }.visit(ve.asType(), workArounds.getConstValue(ve));\n+        @Override\n+        public String visitPrimitiveAsDouble(PrimitiveType t, Object val) {\n+            return sourceForm(((Double) val), 'd');\n+        }\n+\n+        @Override\n+        public String visitPrimitiveAsFloat(PrimitiveType t, Object val) {\n+            return sourceForm(((Float) val).doubleValue(), 'f');\n+        }\n+\n+        @Override\n+        public String visitPrimitiveAsLong(PrimitiveType t, Object val) {\n+            return val + \"L\";\n+        }\n+\n+        @Override\n+        protected String defaultAction(TypeMirror e, Object val) {\n+            if (val == null)\n+                return null;\n+            else if (val instanceof String)\n+                return sourceForm((String) val);\n+            return val.toString(); \/\/ covers int, short\n@@ -2327,1 +2324,0 @@\n-        \/\/ where\n@@ -2338,12 +2334,0 @@\n-        private  String sourceForm(char c) {\n-            StringBuilder buf = new StringBuilder(8);\n-            buf.append('\\'');\n-            sourceChar(c, buf);\n-            buf.append('\\'');\n-            return buf.toString();\n-        }\n-\n-        private String sourceForm(byte c) {\n-            return \"0x\" + Integer.toString(c & 0xff, 16);\n-        }\n-\n@@ -2353,1 +2337,1 @@\n-            for (int i=0; i<s.length(); i++) {\n+            for (int i = 0; i < s.length(); i++) {\n@@ -2363,11 +2347,14 @@\n-            case '\\b': buf.append(\"\\\\b\"); return;\n-            case '\\t': buf.append(\"\\\\t\"); return;\n-            case '\\n': buf.append(\"\\\\n\"); return;\n-            case '\\f': buf.append(\"\\\\f\"); return;\n-            case '\\r': buf.append(\"\\\\r\"); return;\n-            case '\\\"': buf.append(\"\\\\\\\"\"); return;\n-            case '\\'': buf.append(\"\\\\\\'\"); return;\n-            case '\\\\': buf.append(\"\\\\\\\\\"); return;\n-            default:\n-                if (isPrintableAscii(c)) {\n-                    buf.append(c); return;\n+                case '\\b' -> buf.append(\"\\\\b\");\n+                case '\\t' -> buf.append(\"\\\\t\");\n+                case '\\n' -> buf.append(\"\\\\n\");\n+                case '\\f' -> buf.append(\"\\\\f\");\n+                case '\\r' -> buf.append(\"\\\\r\");\n+                case '\\\"' -> buf.append(\"\\\\\\\"\");\n+                case '\\'' -> buf.append(\"\\\\\\'\");\n+                case '\\\\' -> buf.append(\"\\\\\\\\\");\n+                default -> {\n+                    if (isPrintableAscii(c)) {\n+                        buf.append(c);\n+                        return;\n+                    }\n+                    unicodeEscape(c, buf);\n@@ -2375,2 +2362,0 @@\n-                unicodeEscape(c, buf);\n-                return;\n@@ -2383,4 +2368,4 @@\n-            buf.append(chars.charAt(15 & (c>>12)));\n-            buf.append(chars.charAt(15 & (c>>8)));\n-            buf.append(chars.charAt(15 & (c>>4)));\n-            buf.append(chars.charAt(15 & (c>>0)));\n+            buf.append(chars.charAt(15 & (c >> 12)));\n+            buf.append(chars.charAt(15 & (c >> 8)));\n+            buf.append(chars.charAt(15 & (c >> 4)));\n+            buf.append(chars.charAt(15 & (c >> 0)));\n@@ -2388,0 +2373,1 @@\n+\n@@ -2725,1 +2711,1 @@\n-                configuration.workArounds.runDocLint(path);\n+                configuration.runDocLint(path);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/Utils.java","additions":67,"deletions":81,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -37,0 +37,2 @@\n+import javax.lang.model.util.Elements;\n+import javax.lang.model.util.Types;\n@@ -49,0 +51,1 @@\n+import com.sun.source.util.DocTrees;\n@@ -50,1 +53,0 @@\n-import com.sun.source.util.Plugin;\n@@ -286,20 +288,0 @@\n-        for (String arg : args) {\n-            if (arg.equals(XMSGS_OPTION)) {\n-                env.messages.setOptions(null);\n-            } else if (arg.startsWith(XMSGS_CUSTOM_PREFIX)) {\n-                env.messages.setOptions(arg.substring(arg.indexOf(\":\") + 1));\n-            } else if (arg.startsWith(XCUSTOM_TAGS_PREFIX)) {\n-                env.setCustomTags(arg.substring(arg.indexOf(\":\") + 1));\n-            } else if (arg.startsWith(XHTML_VERSION_PREFIX)) {\n-                String argsVersion = arg.substring(arg.indexOf(\":\") + 1);\n-                HtmlVersion htmlVersion = HtmlVersion.getHtmlVersion(argsVersion);\n-                if (htmlVersion != null) {\n-                    env.setHtmlVersion(htmlVersion);\n-                } else {\n-                    throw new IllegalArgumentException(argsVersion);\n-                }\n-            } else if (arg.startsWith(XCHECK_PACKAGE)) {\n-                env.setCheckPackages(arg.substring(arg.indexOf(\":\") + 1));\n-            } else\n-                throw new IllegalArgumentException(arg);\n-        }\n@@ -307,0 +289,1 @@\n+        processArgs(env, args);\n@@ -349,0 +332,31 @@\n+    public void init(DocTrees trees, Elements elements, Types types, String... args) {\n+        env = new Env();\n+        env.init(trees, elements, types);\n+        processArgs(env, args);\n+\n+        checker = new Checker(env);\n+    }\n+\n+    private void processArgs(Env env, String... args) {\n+        for (String arg : args) {\n+            if (arg.equals(XMSGS_OPTION)) {\n+                env.messages.setOptions(null);\n+            } else if (arg.startsWith(XMSGS_CUSTOM_PREFIX)) {\n+                env.messages.setOptions(arg.substring(arg.indexOf(\":\") + 1));\n+            } else if (arg.startsWith(XCUSTOM_TAGS_PREFIX)) {\n+                env.setCustomTags(arg.substring(arg.indexOf(\":\") + 1));\n+            } else if (arg.startsWith(XHTML_VERSION_PREFIX)) {\n+                String argsVersion = arg.substring(arg.indexOf(\":\") + 1);\n+                HtmlVersion htmlVersion = HtmlVersion.getHtmlVersion(argsVersion);\n+                if (htmlVersion != null) {\n+                    env.setHtmlVersion(htmlVersion);\n+                } else {\n+                    throw new IllegalArgumentException(argsVersion);\n+                }\n+            } else if (arg.startsWith(XCHECK_PACKAGE)) {\n+                env.setCheckPackages(arg.substring(arg.indexOf(\":\") + 1));\n+            } else\n+                throw new IllegalArgumentException(arg);\n+        }\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclint\/DocLint.java","additions":35,"deletions":21,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-                    <td class=\"col-last\"><code>127<\/code><\/td>\"\"\",\n+                    <td class=\"col-last\"><code>0x7f<\/code><\/td>\"\"\",\n@@ -64,1 +64,1 @@\n-                    <td class=\"col-last\"><code>-127<\/code><\/td>\"\"\",\n+                    <td class=\"col-last\"><code>0x81<\/code><\/td>\"\"\",\n@@ -68,1 +68,1 @@\n-                    <td class=\"col-last\"><code>65535<\/code><\/td>\"\"\",\n+                    <td class=\"col-last\"><code>'\\\\uffff'<\/code><\/td>\"\"\",\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/constantValues\/TestConstantValuesDriver.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}