{"files":[{"patch":"@@ -39,3 +39,3 @@\n-#include <stdlib.h>\n-#include <stdio.h>\n-#include <string.h>\n+#include <cstdlib>\n+#include <cstdio>\n+#include <cstring>\n@@ -371,3 +371,0 @@\n-    if (value == NULL) {\n-        goto err;\n-    }\n@@ -375,5 +372,4 @@\n-    len = MultiByteToWideChar(CP_UTF8, 0, input, len, value, len+1);\n-    if (len == 0) {\n-        goto err;\n-    }\n-    value[len] = 0;\n+    {\n+        if (value == NULL) {\n+            goto err;\n+        }\n@@ -381,1 +377,5 @@\n-    PP(\"import_name from %ls\", value);\n+        len = MultiByteToWideChar(CP_UTF8, 0, input, len, value, len+1);\n+        if (len == 0) {\n+            goto err;\n+        }\n+        value[len] = 0;\n@@ -383,12 +383,1 @@\n-    if (len > 33 && !wcscmp(value+len-33, L\"@WELLKNOWN:ORG.H5L.REFERALS-REALM\")) {\n-        \/\/ Remove the wellknown referrals realms\n-        value[len-33] = 0;\n-        len -= 33;\n-    } else if (value[len-1] == L'@') {\n-        \/\/ Remove the empty realm. It might come from an NT_EXPORT_NAME.\n-        value[len-1] = 0;\n-        len--;\n-    }\n-    if (len == 0) {\n-        goto err;\n-    }\n+        PP(\"import_name from %ls\", value);\n@@ -396,11 +385,25 @@\n-    if (input_name_type != NULL\n-            && is_same_oid(input_name_type, &HOST_SERVICE_NAME_OID)) {\n-        \/\/ HOST_SERVICE_NAME_OID takes the form of service@host.\n-        for (int i = 0; i < len; i++) {\n-            if (value[i] == L'\\\\') {\n-                i++;\n-                continue;\n-            }\n-            if (value[i] == L'@') {\n-                value[i] = L'\/';\n-                break;\n+        if (len > 33 && !wcscmp(value+len-33, L\"@WELLKNOWN:ORG.H5L.REFERALS-REALM\")) {\n+            \/\/ Remove the wellknown referrals realms\n+            value[len-33] = 0;\n+            len -= 33;\n+        } else if (value[len-1] == L'@') {\n+            \/\/ Remove the empty realm. It might come from an NT_EXPORT_NAME.\n+            value[len-1] = 0;\n+            len--;\n+        }\n+        if (len == 0) {\n+            goto err;\n+        }\n+\n+        if (input_name_type != NULL\n+                && is_same_oid(input_name_type, &HOST_SERVICE_NAME_OID)) {\n+            \/\/ HOST_SERVICE_NAME_OID takes the form of service@host.\n+            for (int i = 0; i < len; i++) {\n+                if (value[i] == L'\\\\') {\n+                    i++;\n+                    continue;\n+                }\n+                if (value[i] == L'@') {\n+                    value[i] = L'\/';\n+                    break;\n+                }\n@@ -408,0 +411,1 @@\n+            PP(\"Host-based service now %ls\", value);\n@@ -409,6 +413,8 @@\n-        PP(\"Host-based service now %ls\", value);\n-    }\n-    PP(\"import_name to %ls\", value);\n-    gss_name_struct* name = new gss_name_struct;\n-    if (name == NULL) {\n-        goto err;\n+        PP(\"import_name to %ls\", value);\n+        gss_name_struct* name = new gss_name_struct;\n+        if (name == NULL) {\n+            goto err;\n+        }\n+        name->name = value;\n+        *output_name = (gss_name_t) name;\n+        return GSS_S_COMPLETE;\n@@ -416,3 +422,1 @@\n-    name->name = value;\n-    *output_name = (gss_name_t) name;\n-    return GSS_S_COMPLETE;\n+\n@@ -531,31 +535,37 @@\n-    if (!fullname) {\n-        goto err;\n-    }\n-    PP(\"Make fullname: %ls -> %ls\", name, fullname);\n-    int len;\n-    size_t namelen = wcslen(fullname);\n-    if (namelen > 255) {\n-        goto err;\n-    }\n-    len = (int)namelen;\n-    \/\/ We only deal with not-so-long names.\n-    \/\/ 04 01 00 ** 06 ** OID len:int32 name\n-    int mechLen = KRB5_OID.length;\n-    char* buffer = (char*) malloc(10 + mechLen + len);\n-    if (buffer == NULL) {\n-        goto err;\n-    }\n-    buffer[0] = 4;\n-    buffer[1] = 1;\n-    buffer[2] = 0;\n-    buffer[3] = 2 + mechLen;\n-    buffer[4] = 6;\n-    buffer[5] = mechLen;\n-    memcpy_s(buffer + 6, mechLen, KRB5_OID.elements, mechLen);\n-    buffer[6 + mechLen] = buffer[7 + mechLen] = buffer[8 + mechLen] = 0;\n-    buffer[9 + mechLen] = (char)len;\n-    len = WideCharToMultiByte(CP_UTF8, 0, fullname, len,\n-                buffer+10+mechLen, len, NULL, NULL);\n-    if (len == 0) {\n-        free(buffer);\n-        goto err;\n+\n+    {\n+        if (!fullname) {\n+            goto err;\n+        }\n+        PP(\"Make fullname: %ls -> %ls\", name, fullname);\n+        int len;\n+        size_t namelen = wcslen(fullname);\n+        if (namelen > 255) {\n+            goto err;\n+        }\n+        len = (int)namelen;\n+        \/\/ We only deal with not-so-long names.\n+        \/\/ 04 01 00 ** 06 ** OID len:int32 name\n+        int mechLen = KRB5_OID.length;\n+        char* buffer = (char*) malloc(10 + mechLen + len);\n+        if (buffer == NULL) {\n+            goto err;\n+        }\n+        buffer[0] = 4;\n+        buffer[1] = 1;\n+        buffer[2] = 0;\n+        buffer[3] = 2 + mechLen;\n+        buffer[4] = 6;\n+        buffer[5] = mechLen;\n+        memcpy_s(buffer + 6, mechLen, KRB5_OID.elements, mechLen);\n+        buffer[6 + mechLen] = buffer[7 + mechLen] = buffer[8 + mechLen] = 0;\n+        buffer[9 + mechLen] = (char)len;\n+        len = WideCharToMultiByte(CP_UTF8, 0, fullname, len,\n+                    buffer+10+mechLen, len, NULL, NULL);\n+        if (len == 0) {\n+            free(buffer);\n+            goto err;\n+        }\n+        exported_name->length = 10 + mechLen + len;\n+        exported_name->value = buffer;\n+        result = GSS_S_COMPLETE;\n@@ -563,3 +573,1 @@\n-    exported_name->length = 10 + mechLen + len;\n-    exported_name->value = buffer;\n-    result = GSS_S_COMPLETE;\n+\n@@ -907,52 +915,56 @@\n-    int flag = flag_gss_to_sspi(req_flags) | ISC_REQ_ALLOCATE_MEMORY;\n-\n-    outBuffDesc.ulVersion = SECBUFFER_VERSION;\n-    outBuffDesc.cBuffers = 1;\n-    outBuffDesc.pBuffers = &outSecBuff;\n-\n-    outSecBuff.BufferType = SECBUFFER_TOKEN;\n-\n-    if (!firstTime) {\n-        inBuffDesc.ulVersion = SECBUFFER_VERSION;\n-        inBuffDesc.cBuffers = 1;\n-        inBuffDesc.pBuffers = &inSecBuff;\n-\n-        inSecBuff.BufferType = SECBUFFER_TOKEN;\n-        inSecBuff.cbBuffer = (ULONG)input_token->length;\n-        inSecBuff.pvBuffer = input_token->value;\n-    } else if (!pc->phCred) {\n-        if (isSPNEGO && initiator_cred_handle\n-                && initiator_cred_handle->phCredS) {\n-            PP(\"Find SPNEGO credentials\");\n-            pc->phCred = initiator_cred_handle->phCredS;\n-            pc->isLocalCred = FALSE;\n-        } else if (!isSPNEGO && initiator_cred_handle\n-                && initiator_cred_handle->phCredK) {\n-            PP(\"Find Kerberos credentials\");\n-            pc->phCred = initiator_cred_handle->phCredK;\n-            pc->isLocalCred = FALSE;\n-        } else {\n-            PP(\"No credentials provided, acquire myself\");\n-            newCred = new CredHandle;\n-            if (!newCred) {\n-                goto err;\n-            }\n-            SEC_WINNT_AUTH_IDENTITY_EX auth;\n-            ZeroMemory(&auth, sizeof(auth));\n-            auth.Version = SEC_WINNT_AUTH_IDENTITY_VERSION;\n-            auth.Length = sizeof(auth);\n-            auth.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;\n-            auth.PackageList = (unsigned short*)L\"Kerberos\";\n-            auth.PackageListLength = 8;\n-            ss = AcquireCredentialsHandle(\n-                    NULL,\n-                    (LPWSTR)(isSPNEGO ? L\"Negotiate\" : L\"Kerberos\"),\n-                    SECPKG_CRED_OUTBOUND,\n-                    NULL,\n-                    isSPNEGO ? &auth : NULL,\n-                    NULL,\n-                    NULL,\n-                    newCred,\n-                    &lifeTime);\n-            if (!(SEC_SUCCESS(ss))) {\n-                goto err;\n+    {\n+        int flag = flag_gss_to_sspi(req_flags) | ISC_REQ_ALLOCATE_MEMORY;\n+\n+        outBuffDesc.ulVersion = SECBUFFER_VERSION;\n+        outBuffDesc.cBuffers = 1;\n+        outBuffDesc.pBuffers = &outSecBuff;\n+\n+        outSecBuff.BufferType = SECBUFFER_TOKEN;\n+\n+        if (!firstTime) {\n+            inBuffDesc.ulVersion = SECBUFFER_VERSION;\n+            inBuffDesc.cBuffers = 1;\n+            inBuffDesc.pBuffers = &inSecBuff;\n+\n+            inSecBuff.BufferType = SECBUFFER_TOKEN;\n+            inSecBuff.cbBuffer = (ULONG)input_token->length;\n+            inSecBuff.pvBuffer = input_token->value;\n+        } else if (!pc->phCred) {\n+            if (isSPNEGO && initiator_cred_handle\n+                    && initiator_cred_handle->phCredS) {\n+                PP(\"Find SPNEGO credentials\");\n+                pc->phCred = initiator_cred_handle->phCredS;\n+                pc->isLocalCred = FALSE;\n+            } else if (!isSPNEGO && initiator_cred_handle\n+                    && initiator_cred_handle->phCredK) {\n+                PP(\"Find Kerberos credentials\");\n+                pc->phCred = initiator_cred_handle->phCredK;\n+                pc->isLocalCred = FALSE;\n+            } else {\n+                PP(\"No credentials provided, acquire myself\");\n+                newCred = new CredHandle;\n+                if (!newCred) {\n+                    goto err;\n+                }\n+                SEC_WINNT_AUTH_IDENTITY_EX auth;\n+                ZeroMemory(&auth, sizeof(auth));\n+                auth.Version = SEC_WINNT_AUTH_IDENTITY_VERSION;\n+                auth.Length = sizeof(auth);\n+                auth.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;\n+                auth.PackageList = (unsigned short*)L\"Kerberos\";\n+                auth.PackageListLength = 8;\n+                ss = AcquireCredentialsHandle(\n+                        NULL,\n+                        (LPWSTR)(isSPNEGO ? L\"Negotiate\" : L\"Kerberos\"),\n+                        SECPKG_CRED_OUTBOUND,\n+                        NULL,\n+                        isSPNEGO ? &auth : NULL,\n+                        NULL,\n+                        NULL,\n+                        newCred,\n+                        &lifeTime);\n+                if (!(SEC_SUCCESS(ss))) {\n+                    goto err;\n+                }\n+                pc->phCred = newCred;\n+                pc->isLocalCred = TRUE;\n@@ -960,21 +972,19 @@\n-            pc->phCred = newCred;\n-            pc->isLocalCred = TRUE;\n-        }\n-    }\n-    ss = InitializeSecurityContext(\n-            pc->phCred,\n-            firstTime ? NULL : &pc->hCtxt,\n-            outName,\n-            flag,\n-            0,\n-            SECURITY_NATIVE_DREP,\n-            firstTime ? NULL : &inBuffDesc,\n-            0,\n-            &pc->hCtxt,\n-            &outBuffDesc,\n-            &outFlag,\n-            &lifeTime);\n-\n-    if (!SEC_SUCCESS(ss)) {\n-        PP(\"InitializeSecurityContext failed\");\n-        goto err;\n+        }\n+        ss = InitializeSecurityContext(\n+                pc->phCred,\n+                firstTime ? NULL : &pc->hCtxt,\n+                outName,\n+                flag,\n+                0,\n+                SECURITY_NATIVE_DREP,\n+                firstTime ? NULL : &inBuffDesc,\n+                0,\n+                &pc->hCtxt,\n+                &outBuffDesc,\n+                &outFlag,\n+                &lifeTime);\n+\n+        if (!SEC_SUCCESS(ss)) {\n+            PP(\"InitializeSecurityContext failed\");\n+            goto err;\n+        }\n","filename":"src\/java.security.jgss\/windows\/native\/libsspi_bridge\/sspi.cpp","additions":161,"deletions":151,"binary":false,"changes":312,"status":"modified"},{"patch":"@@ -78,0 +78,1 @@\n+static\n","filename":"src\/java.security.jgss\/windows\/native\/libw2k_lsa_auth\/NativeCreds.c","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}