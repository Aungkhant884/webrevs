{"files":[{"patch":"@@ -371,0 +371,3 @@\n+    if (value == NULL) {\n+        goto err;\n+    }\n@@ -372,10 +375,5 @@\n-    {\n-        if (value == NULL) {\n-            goto err;\n-        }\n-\n-        len = MultiByteToWideChar(CP_UTF8, 0, input, len, value, len+1);\n-        if (len == 0) {\n-            goto err;\n-        }\n-        value[len] = 0;\n+    len = MultiByteToWideChar(CP_UTF8, 0, input, len, value, len+1);\n+    if (len == 0) {\n+        goto err;\n+    }\n+    value[len] = 0;\n@@ -383,1 +381,1 @@\n-        PP(\"import_name from %ls\", value);\n+    PP(\"import_name from %ls\", value);\n@@ -385,12 +383,12 @@\n-        if (len > 33 && !wcscmp(value+len-33, L\"@WELLKNOWN:ORG.H5L.REFERALS-REALM\")) {\n-            \/\/ Remove the wellknown referrals realms\n-            value[len-33] = 0;\n-            len -= 33;\n-        } else if (value[len-1] == L'@') {\n-            \/\/ Remove the empty realm. It might come from an NT_EXPORT_NAME.\n-            value[len-1] = 0;\n-            len--;\n-        }\n-        if (len == 0) {\n-            goto err;\n-        }\n+    if (len > 33 && !wcscmp(value+len-33, L\"@WELLKNOWN:ORG.H5L.REFERALS-REALM\")) {\n+        \/\/ Remove the wellknown referrals realms\n+        value[len-33] = 0;\n+        len -= 33;\n+    } else if (value[len-1] == L'@') {\n+        \/\/ Remove the empty realm. It might come from an NT_EXPORT_NAME.\n+        value[len-1] = 0;\n+        len--;\n+    }\n+    if (len == 0) {\n+        goto err;\n+    }\n@@ -398,12 +396,11 @@\n-        if (input_name_type != NULL\n-                && is_same_oid(input_name_type, &HOST_SERVICE_NAME_OID)) {\n-            \/\/ HOST_SERVICE_NAME_OID takes the form of service@host.\n-            for (int i = 0; i < len; i++) {\n-                if (value[i] == L'\\\\') {\n-                    i++;\n-                    continue;\n-                }\n-                if (value[i] == L'@') {\n-                    value[i] = L'\/';\n-                    break;\n-                }\n+    if (input_name_type != NULL\n+            && is_same_oid(input_name_type, &HOST_SERVICE_NAME_OID)) {\n+        \/\/ HOST_SERVICE_NAME_OID takes the form of service@host.\n+        for (int i = 0; i < len; i++) {\n+            if (value[i] == L'\\\\') {\n+                i++;\n+                continue;\n+            }\n+            if (value[i] == L'@') {\n+                value[i] = L'\/';\n+                break;\n@@ -411,6 +408,0 @@\n-            PP(\"Host-based service now %ls\", value);\n-        }\n-        PP(\"import_name to %ls\", value);\n-        gss_name_struct* name = new gss_name_struct;\n-        if (name == NULL) {\n-            goto err;\n@@ -418,3 +409,1 @@\n-        name->name = value;\n-        *output_name = (gss_name_t) name;\n-        return GSS_S_COMPLETE;\n+        PP(\"Host-based service now %ls\", value);\n@@ -422,1 +411,9 @@\n-\n+    PP(\"import_name to %ls\", value);\n+    gss_name_struct* name;\n+    name = new gss_name_struct;\n+    if (name == NULL) {\n+        goto err;\n+    }\n+    name->name = value;\n+    *output_name = (gss_name_t) name;\n+    return GSS_S_COMPLETE;\n@@ -535,37 +532,2 @@\n-\n-    {\n-        if (!fullname) {\n-            goto err;\n-        }\n-        PP(\"Make fullname: %ls -> %ls\", name, fullname);\n-        int len;\n-        size_t namelen = wcslen(fullname);\n-        if (namelen > 255) {\n-            goto err;\n-        }\n-        len = (int)namelen;\n-        \/\/ We only deal with not-so-long names.\n-        \/\/ 04 01 00 ** 06 ** OID len:int32 name\n-        int mechLen = KRB5_OID.length;\n-        char* buffer = (char*) malloc(10 + mechLen + len);\n-        if (buffer == NULL) {\n-            goto err;\n-        }\n-        buffer[0] = 4;\n-        buffer[1] = 1;\n-        buffer[2] = 0;\n-        buffer[3] = 2 + mechLen;\n-        buffer[4] = 6;\n-        buffer[5] = mechLen;\n-        memcpy_s(buffer + 6, mechLen, KRB5_OID.elements, mechLen);\n-        buffer[6 + mechLen] = buffer[7 + mechLen] = buffer[8 + mechLen] = 0;\n-        buffer[9 + mechLen] = (char)len;\n-        len = WideCharToMultiByte(CP_UTF8, 0, fullname, len,\n-                    buffer+10+mechLen, len, NULL, NULL);\n-        if (len == 0) {\n-            free(buffer);\n-            goto err;\n-        }\n-        exported_name->length = 10 + mechLen + len;\n-        exported_name->value = buffer;\n-        result = GSS_S_COMPLETE;\n+    if (!fullname) {\n+        goto err;\n@@ -573,1 +535,35 @@\n-\n+    PP(\"Make fullname: %ls -> %ls\", name, fullname);\n+    int len;\n+    size_t namelen;\n+    namelen = wcslen(fullname);\n+    if (namelen > 255) {\n+        goto err;\n+    }\n+    len = (int)namelen;\n+    \/\/ We only deal with not-so-long names.\n+    \/\/ 04 01 00 ** 06 ** OID len:int32 name\n+    int mechLen;\n+    mechLen = KRB5_OID.length;\n+    char* buffer;\n+    buffer = (char*) malloc(10 + mechLen + len);\n+    if (buffer == NULL) {\n+        goto err;\n+    }\n+    buffer[0] = 4;\n+    buffer[1] = 1;\n+    buffer[2] = 0;\n+    buffer[3] = 2 + mechLen;\n+    buffer[4] = 6;\n+    buffer[5] = mechLen;\n+    memcpy_s(buffer + 6, mechLen, KRB5_OID.elements, mechLen);\n+    buffer[6 + mechLen] = buffer[7 + mechLen] = buffer[8 + mechLen] = 0;\n+    buffer[9 + mechLen] = (char)len;\n+    len = WideCharToMultiByte(CP_UTF8, 0, fullname, len,\n+                buffer+10+mechLen, len, NULL, NULL);\n+    if (len == 0) {\n+        free(buffer);\n+        goto err;\n+    }\n+    exported_name->length = 10 + mechLen + len;\n+    exported_name->value = buffer;\n+    result = GSS_S_COMPLETE;\n@@ -915,56 +911,33 @@\n-    {\n-        int flag = flag_gss_to_sspi(req_flags) | ISC_REQ_ALLOCATE_MEMORY;\n-\n-        outBuffDesc.ulVersion = SECBUFFER_VERSION;\n-        outBuffDesc.cBuffers = 1;\n-        outBuffDesc.pBuffers = &outSecBuff;\n-\n-        outSecBuff.BufferType = SECBUFFER_TOKEN;\n-\n-        if (!firstTime) {\n-            inBuffDesc.ulVersion = SECBUFFER_VERSION;\n-            inBuffDesc.cBuffers = 1;\n-            inBuffDesc.pBuffers = &inSecBuff;\n-\n-            inSecBuff.BufferType = SECBUFFER_TOKEN;\n-            inSecBuff.cbBuffer = (ULONG)input_token->length;\n-            inSecBuff.pvBuffer = input_token->value;\n-        } else if (!pc->phCred) {\n-            if (isSPNEGO && initiator_cred_handle\n-                    && initiator_cred_handle->phCredS) {\n-                PP(\"Find SPNEGO credentials\");\n-                pc->phCred = initiator_cred_handle->phCredS;\n-                pc->isLocalCred = FALSE;\n-            } else if (!isSPNEGO && initiator_cred_handle\n-                    && initiator_cred_handle->phCredK) {\n-                PP(\"Find Kerberos credentials\");\n-                pc->phCred = initiator_cred_handle->phCredK;\n-                pc->isLocalCred = FALSE;\n-            } else {\n-                PP(\"No credentials provided, acquire myself\");\n-                newCred = new CredHandle;\n-                if (!newCred) {\n-                    goto err;\n-                }\n-                SEC_WINNT_AUTH_IDENTITY_EX auth;\n-                ZeroMemory(&auth, sizeof(auth));\n-                auth.Version = SEC_WINNT_AUTH_IDENTITY_VERSION;\n-                auth.Length = sizeof(auth);\n-                auth.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;\n-                auth.PackageList = (unsigned short*)L\"Kerberos\";\n-                auth.PackageListLength = 8;\n-                ss = AcquireCredentialsHandle(\n-                        NULL,\n-                        (LPWSTR)(isSPNEGO ? L\"Negotiate\" : L\"Kerberos\"),\n-                        SECPKG_CRED_OUTBOUND,\n-                        NULL,\n-                        isSPNEGO ? &auth : NULL,\n-                        NULL,\n-                        NULL,\n-                        newCred,\n-                        &lifeTime);\n-                if (!(SEC_SUCCESS(ss))) {\n-                    goto err;\n-                }\n-                pc->phCred = newCred;\n-                pc->isLocalCred = TRUE;\n+    int flag;\n+    flag = flag_gss_to_sspi(req_flags) | ISC_REQ_ALLOCATE_MEMORY;\n+\n+    outBuffDesc.ulVersion = SECBUFFER_VERSION;\n+    outBuffDesc.cBuffers = 1;\n+    outBuffDesc.pBuffers = &outSecBuff;\n+\n+    outSecBuff.BufferType = SECBUFFER_TOKEN;\n+\n+    if (!firstTime) {\n+        inBuffDesc.ulVersion = SECBUFFER_VERSION;\n+        inBuffDesc.cBuffers = 1;\n+        inBuffDesc.pBuffers = &inSecBuff;\n+\n+        inSecBuff.BufferType = SECBUFFER_TOKEN;\n+        inSecBuff.cbBuffer = (ULONG)input_token->length;\n+        inSecBuff.pvBuffer = input_token->value;\n+    } else if (!pc->phCred) {\n+        if (isSPNEGO && initiator_cred_handle\n+                && initiator_cred_handle->phCredS) {\n+            PP(\"Find SPNEGO credentials\");\n+            pc->phCred = initiator_cred_handle->phCredS;\n+            pc->isLocalCred = FALSE;\n+        } else if (!isSPNEGO && initiator_cred_handle\n+                && initiator_cred_handle->phCredK) {\n+            PP(\"Find Kerberos credentials\");\n+            pc->phCred = initiator_cred_handle->phCredK;\n+            pc->isLocalCred = FALSE;\n+        } else {\n+            PP(\"No credentials provided, acquire myself\");\n+            newCred = new CredHandle;\n+            if (!newCred) {\n+                goto err;\n@@ -972,19 +945,41 @@\n-        }\n-        ss = InitializeSecurityContext(\n-                pc->phCred,\n-                firstTime ? NULL : &pc->hCtxt,\n-                outName,\n-                flag,\n-                0,\n-                SECURITY_NATIVE_DREP,\n-                firstTime ? NULL : &inBuffDesc,\n-                0,\n-                &pc->hCtxt,\n-                &outBuffDesc,\n-                &outFlag,\n-                &lifeTime);\n-\n-        if (!SEC_SUCCESS(ss)) {\n-            PP(\"InitializeSecurityContext failed\");\n-            goto err;\n-        }\n+            SEC_WINNT_AUTH_IDENTITY_EX auth;\n+            ZeroMemory(&auth, sizeof(auth));\n+            auth.Version = SEC_WINNT_AUTH_IDENTITY_VERSION;\n+            auth.Length = sizeof(auth);\n+            auth.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;\n+            auth.PackageList = (unsigned short*)L\"Kerberos\";\n+            auth.PackageListLength = 8;\n+            ss = AcquireCredentialsHandle(\n+                    NULL,\n+                    (LPWSTR)(isSPNEGO ? L\"Negotiate\" : L\"Kerberos\"),\n+                    SECPKG_CRED_OUTBOUND,\n+                    NULL,\n+                    isSPNEGO ? &auth : NULL,\n+                    NULL,\n+                    NULL,\n+                    newCred,\n+                    &lifeTime);\n+            if (!(SEC_SUCCESS(ss))) {\n+                goto err;\n+            }\n+            pc->phCred = newCred;\n+            pc->isLocalCred = TRUE;\n+        }\n+    }\n+    ss = InitializeSecurityContext(\n+            pc->phCred,\n+            firstTime ? NULL : &pc->hCtxt,\n+            outName,\n+            flag,\n+            0,\n+            SECURITY_NATIVE_DREP,\n+            firstTime ? NULL : &inBuffDesc,\n+            0,\n+            &pc->hCtxt,\n+            &outBuffDesc,\n+            &outFlag,\n+            &lifeTime);\n+\n+    if (!SEC_SUCCESS(ss)) {\n+        PP(\"InitializeSecurityContext failed\");\n+        goto err;\n","filename":"src\/java.security.jgss\/windows\/native\/libsspi_bridge\/sspi.cpp","additions":153,"deletions":158,"binary":false,"changes":311,"status":"modified"}]}