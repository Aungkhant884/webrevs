{"files":[{"patch":"@@ -133,1 +133,4 @@\n-  public U2Array           getOperands()   { return new U2Array(operands.getValue(getAddress())); }\n+  public U2Array           getOperands()   {\n+    Address addr = operands.getValue(getAddress());\n+    return VMObjectFactory.newObject(U2Array.class, addr);\n+  }\n@@ -467,2 +470,29 @@\n-  \/** Lookup for multi-operand (InvokeDynamic, Dynamic) entries. *\/\n-  public short[] getBootstrapSpecifierAt(int i) {\n+  public int getBootstrapMethodsCount() {\n+    U2Array operands = getOperands();\n+    int count = 0;\n+    if (operands != null) {\n+      \/\/ Operands array consists of two parts. First part is an array of 32-bit values which denote\n+      \/\/ index of the bootstrap method data in the operands array. Note that elements of operands array are of type short.\n+      \/\/ So each element of first part occupies two slots in the array.\n+      \/\/ Second part is the bootstrap methods data.\n+      \/\/ This layout allows us to get BSM count by getting the index of first BSM and dividing it by 2.\n+      \/\/\n+      \/\/ The example below shows layout of operands array with 3 bootstrap methods.\n+      \/\/ First part has 3 32-bit values indicating the index of the respective bootstrap methods in\n+      \/\/ the operands array.\n+      \/\/ The first BSM is at index 6. So the count in this case is 6\/2=3.\n+      \/\/\n+      \/\/            <-----first part----><-------second part------->\n+      \/\/ index:     0     2      4      6        i2       i3\n+      \/\/ operands:  |  6  |  i2  |  i3  |  bsm1  |  bsm2  |  bsm3  |\n+      \/\/\n+      count = getOperandOffsetAt(operands, 0) \/ 2;\n+    }\n+    if (DEBUG) {\n+      System.err.println(\"ConstantPool.getBootstrapMethodsCount: count = \" + count);\n+    }\n+    return count;\n+  }\n+\n+  public int getBootstrapMethodArgsCount(int bsmIndex) {\n+    U2Array operands = getOperands();\n@@ -470,1 +500,1 @@\n-      Assert.that(getTagAt(i).isInvokeDynamic() || getTagAt(i).isDynamicConstant(), \"Corrupted constant pool\");\n+      Assert.that(operands != null, \"Operands is not present\");\n@@ -472,1 +502,9 @@\n-    int bsmSpec = extractLowShortFromInt(this.getIntAt(i));\n+    int bsmOffset = getOperandOffsetAt(operands, bsmIndex);\n+    int argc = operands.at(bsmOffset + INDY_ARGC_OFFSET);\n+    if (DEBUG) {\n+      System.err.println(\"ConstantPool.getBootstrapMethodArgsCount: bsm index = \" + bsmIndex + \", args count = \" + argc);\n+    }\n+    return argc;\n+  }\n+\n+  public short[] getBootstrapMethodAt(int bsmIndex) {\n@@ -475,2 +513,1 @@\n-    int basePos = VM.getVM().buildIntFromShorts(operands.at(bsmSpec * 2 + 0),\n-                                                operands.at(bsmSpec * 2 + 1));\n+    int basePos = getOperandOffsetAt(operands, bsmIndex);\n@@ -487,0 +524,9 @@\n+  \/** Lookup for multi-operand (InvokeDynamic, Dynamic) entries. *\/\n+  public short[] getBootstrapSpecifierAt(int i) {\n+    if (Assert.ASSERTS_ENABLED) {\n+      Assert.that(getTagAt(i).isInvokeDynamic() || getTagAt(i).isDynamicConstant(), \"Corrupted constant pool\");\n+    }\n+    int bsmSpec = extractLowShortFromInt(this.getIntAt(i));\n+    return getBootstrapMethodAt(bsmSpec);\n+  }\n+\n@@ -759,0 +805,7 @@\n+\n+  \/\/ Return the offset of the requested Bootstrap Method in the operands array\n+  private int getOperandOffsetAt(U2Array operands, int bsmIndex) {\n+    return VM.getVM().buildIntFromShorts(operands.at(bsmIndex * 2),\n+                                         operands.at(bsmIndex * 2 + 1));\n+  }\n+\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/ConstantPool.java","additions":60,"deletions":7,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -862,1 +862,0 @@\n-\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/InstanceKlass.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+    protected short  _bootstrapMethodsIndex;\n@@ -144,0 +145,2 @@\n+        Short bootstrapMethodsIndex = utf8ToIndex.get(\"BootstrapMethods\");\n+        _bootstrapMethodsIndex = (bootstrapMethodsIndex != null) ? bootstrapMethodsIndex.shortValue() : 0;\n@@ -688,0 +691,5 @@\n+        int bsmCount = klass.getConstants().getBootstrapMethodsCount();\n+        if (bsmCount != 0) {\n+            classAttributeCount++;\n+        }\n+\n@@ -727,0 +735,22 @@\n+\n+        \/\/ write bootstrap method attribute, if any\n+        if (bsmCount != 0) {\n+            ConstantPool cpool = klass.getConstants();\n+            writeIndex(_bootstrapMethodsIndex);\n+            if (DEBUG) debugMessage(\"bootstrap methods attribute = \" + _bootstrapMethodsIndex);\n+            int attrLen = 2; \/\/ num_bootstrap_methods\n+            for (int index = 0; index < bsmCount; index++) {\n+                int bsmArgsCount = cpool.getBootstrapMethodArgsCount(index);\n+                attrLen += 2 \/\/ bootstrap_method_ref\n+                           + 2 \/\/ num_bootstrap_arguments\n+                           + bsmArgsCount * 2;\n+            }\n+            dos.writeInt(attrLen);\n+            dos.writeShort(bsmCount);\n+            for (int index = 0; index < bsmCount; index++) {\n+                short value[] = cpool.getBootstrapMethodAt(index);\n+                for (int i = 0; i < value.length; i++) {\n+                    dos.writeShort(value[i]);\n+                }\n+            }\n+        }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/tools\/jcore\/ClassWriter.java","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"}]}