{"files":[{"patch":"@@ -544,1 +544,1 @@\n-    \/\/ set this to false if we find out later that it doesn't\n+    \/\/ set this to true if we find out later that it doesn't\n@@ -546,1 +546,1 @@\n-    private static volatile boolean transferSupported = true;\n+    private static volatile boolean transferToNotSupported;\n@@ -590,1 +590,1 @@\n-                transferSupported = false;\n+                transferToNotSupported = true;\n@@ -604,1 +604,1 @@\n-        if (!transferSupported)\n+        if (transferToNotSupported)\n@@ -649,2 +649,3 @@\n-    \/\/ transferToArbitraryChannel() is faster for smaller transfers\n-    private static final long TRUSTED_TRANSFER_THRESHOLD = 16L*1024L;\n+    \/\/ transferToArbitraryChannel() and transferFromArbitraryChannel()\n+    \/\/ are faster for smaller transfers\n+    private static final long MAPPED_TRANSFER_THRESHOLD = 16L*1024L;\n@@ -659,1 +660,1 @@\n-        if (count < TRUSTED_TRANSFER_THRESHOLD)\n+        if (count < MAPPED_TRANSFER_THRESHOLD)\n@@ -784,0 +785,51 @@\n+    \/\/ Assume at first that the underlying kernel supports copy_file_range();\n+    \/\/ set this to true if we find out later that it doesn't\n+    \/\/\n+    private static volatile boolean transferFromNotSupported;\n+\n+    private long transferFromDirectlyInternal(FileDescriptor srcFD,\n+                                              long position, long count)\n+        throws IOException\n+    {\n+        long n = -1;\n+        int ti = -1;\n+        try {\n+            beginBlocking();\n+            ti = threads.add();\n+            if (!isOpen())\n+                return -1;\n+            do {\n+                long comp = Blocker.begin();\n+                try {\n+                    n = transferFrom0(srcFD, fd, position, count);\n+                } finally {\n+                    Blocker.end(comp);\n+                }\n+            } while ((n == IOStatus.INTERRUPTED) && isOpen());\n+            if (n == IOStatus.UNSUPPORTED) {\n+                \/\/ Don't bother trying again\n+                transferFromNotSupported = true;\n+                return IOStatus.UNSUPPORTED;\n+            }\n+            return IOStatus.normalize(n);\n+        } finally {\n+            threads.remove(ti);\n+            end (n > -1);\n+        }\n+    }\n+\n+    private long transferFromDirectly(FileChannelImpl src,\n+                                      long position, long count)\n+        throws IOException\n+    {\n+        if (!src.readable)\n+            throw new NonReadableChannelException();\n+        if (transferFromNotSupported)\n+            return IOStatus.UNSUPPORTED;\n+        FileDescriptor srcFD = src.fd;\n+        if (srcFD == null)\n+            return IOStatus.UNSUPPORTED_CASE;\n+\n+        return transferFromDirectlyInternal(srcFD, position, count);\n+    }\n+\n@@ -790,0 +842,3 @@\n+        if (count < MAPPED_TRANSFER_THRESHOLD)\n+            return IOStatus.UNSUPPORTED_CASE;\n+\n@@ -879,2 +934,4 @@\n-            long n = transferFromFileChannel(fci, position, count);\n-            if (n >= 0)\n+            long n;\n+            if ((n = transferFromDirectly(fci, position, count)) >= 0)\n+                return n;\n+            if ((n = transferFromFileChannel(fci, position, count)) >= 0)\n@@ -1515,0 +1572,4 @@\n+    private static native long transferFrom0(FileDescriptor src,\n+                                             FileDescriptor dst,\n+                                             long position, long count);\n+\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/FileChannelImpl.java","additions":70,"deletions":9,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include <dlfcn.h>\n@@ -53,0 +54,6 @@\n+#if defined(__linux__)\n+typedef ssize_t copy_file_range_func(int, loff_t*, int, loff_t*, size_t,\n+                                     unsigned int);\n+static copy_file_range_func* my_copy_file_range_func = NULL;\n+#endif\n+\n@@ -57,0 +64,4 @@\n+#if defined(__linux__)\n+    my_copy_file_range_func =\n+        (copy_file_range_func*) dlsym(RTLD_DEFAULT, \"copy_file_range\");\n+#endif\n@@ -251,0 +262,32 @@\n+JNIEXPORT jlong JNICALL\n+Java_sun_nio_ch_FileChannelImpl_transferFrom0(JNIEnv *env, jobject this,\n+                                              jobject srcFDO, jobject dstFDO,\n+                                              jlong position, jlong count)\n+{\n+#if defined(__linux__)\n+    if (my_copy_file_range_func == NULL)\n+        return IOS_UNSUPPORTED;\n+\n+    jint srcFD = fdval(env, srcFDO);\n+    jint dstFD = fdval(env, dstFDO);\n+\n+    off64_t offset = (off64_t)position;\n+    jlong n = my_copy_file_range_func(srcFD, NULL, dstFD, &offset, count, 0);\n+    if (n < 0) {\n+        if (errno == EAGAIN)\n+            return IOS_UNAVAILABLE;\n+        if ((errno == EBADF || errno == EINVAL || errno == EXDEV) &&\n+            ((ssize_t)count >= 0))\n+            return IOS_UNSUPPORTED_CASE;\n+        if (errno == EINTR) {\n+            return IOS_INTERRUPTED;\n+        }\n+        JNU_ThrowIOExceptionWithLastError(env, \"Transfer failed\");\n+        return IOS_THROWN;\n+    }\n+    return n;\n+#else\n+    return IOS_UNSUPPORTED;\n+#endif\n+}\n+\n","filename":"src\/java.base\/unix\/native\/libnio\/ch\/FileChannelImpl.c","additions":43,"deletions":0,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -191,0 +191,7 @@\n+JNIEXPORT jlong JNICALL\n+Java_sun_nio_ch_FileChannelImpl_transferFrom0(JNIEnv *env, jobject this,\n+                                              jobject srcFDO, jobject dstFDO,\n+                                              jlong position, jlong count)\n+{\n+    return IOS_UNSUPPORTED;\n+}\n","filename":"src\/java.base\/windows\/native\/libnio\/ch\/FileChannelImpl.c","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 4708120\n+ * @bug 4708120 8274113\n@@ -471,4 +471,10 @@\n-        int n = (int)fc.transferFrom(src.channel(), off, len);\n-        if (n != len)\n-            throw new Failure(\"Incorrect transfer length: \" + n\n-                              + \" (expected \" + len + \")\");\n+        long position = off;\n+        long count = len;\n+        while (count > 0) {\n+            int n = (int)fc.transferFrom(src.channel(), position, count);\n+            if (n < 0 || n > count)\n+                throw new Failure(\"Incorrect transfer length n = : \" + n\n+                                  + \" (expected 0 <= n <= \" + len + \")\");\n+            position += n;\n+            count -= n;\n+        }\n","filename":"test\/jdk\/java\/nio\/channels\/FileChannel\/Transfers.java","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"}]}