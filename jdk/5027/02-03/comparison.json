{"files":[{"patch":"@@ -31,1 +31,1 @@\n- * Utility methods used by DirectMethodAccessorImpl and DirectConstructorImpl\n+ * Utility methods used by DirectMethodHandleAccessorImpl and DirectConstructorImpl\n@@ -65,4 +65,4 @@\n-            if ((accessorType == DirectMethodAccessorImpl.class\n-                    && cname.startsWith(DirectConstructorAccessorImpl.class.getName()))\n-                || (accessorType == DirectConstructorAccessorImpl.class &&\n-                        cname.startsWith(DirectMethodAccessorImpl.class.getName()))) {\n+            if ((accessorType == DirectMethodHandleAccessorImpl.class\n+                    && cname.startsWith(DirectConstructorHandleAccessorImpl.class.getName()))\n+                || (accessorType == DirectConstructorHandleAccessorImpl.class &&\n+                        cname.startsWith(DirectMethodHandleAccessorImpl.class.getName()))) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/AccessorUtils.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,157 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.reflect;\n-\n-import jdk.internal.vm.annotation.DontInline;\n-import jdk.internal.vm.annotation.ForceInline;\n-import jdk.internal.vm.annotation.Hidden;\n-import jdk.internal.vm.annotation.Stable;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.WrongMethodTypeException;\n-import java.lang.reflect.Constructor;\n-import java.lang.reflect.InvocationTargetException;\n-\n-import static jdk.internal.reflect.MethodHandleAccessorFactory.SPECIALIZED_PARAM_COUNT;\n-import static jdk.internal.reflect.MethodHandleAccessorFactory.newMethodHandleInvoker;\n-\n-class DirectConstructorAccessorImpl extends ConstructorAccessorImpl {\n-    static ConstructorAccessorImpl constructorAccessor(Constructor<?> ctor, MethodHandle target) {\n-        if (ReflectionFactory.noInflation()) {\n-            \/\/ fast invoker\n-            var mhInvoker = newMethodHandleInvoker(ctor, target);\n-            return new DirectConstructorAccessorImpl(ctor, target);\n-        } else {\n-            \/\/ Default is the adaptive accessor method.\n-            return new AdaptiveConstructorAccessor(ctor, target);\n-        }\n-    }\n-\n-    static ConstructorAccessorImpl nativeAccessor(Constructor<?> ctor) {\n-        return new NativeAccessor(ctor);\n-    }\n-\n-    protected final Constructor<?> ctor;\n-    protected final int paramCount;\n-\n-    @Stable protected final MethodHandle target;\n-    @Stable protected final MHInvoker invoker;\n-    DirectConstructorAccessorImpl(Constructor<?> ctor, MethodHandle target) {\n-        this.ctor = ctor;\n-        this.paramCount = ctor.getParameterCount();\n-        this.target = target;\n-        this.invoker = new MHInvokerDelegate(target);\n-    }\n-\n-    @ForceInline\n-    MHInvoker mhInvoker() {\n-        return invoker;\n-    }\n-\n-    @Override\n-    public Object newInstance(Object[] args) throws InstantiationException, InvocationTargetException {\n-        int argc = args != null ? args.length : 0;\n-        \/\/ only check argument count for specialized forms\n-        if (paramCount <= SPECIALIZED_PARAM_COUNT && argc != paramCount) {\n-            throw new IllegalArgumentException(\"wrong number of arguments: \" + argc + \" expected: \" + paramCount);\n-        }\n-        try {\n-            return invokeImpl(args);\n-        } catch (ClassCastException|WrongMethodTypeException e) {\n-            if (isIllegalArgument(e))\n-                throw new IllegalArgumentException(\"argument type mismatch\", e);\n-            else\n-                throw new InvocationTargetException(e);\n-        } catch (NullPointerException e) {\n-            if (isIllegalArgument(e))\n-                throw new IllegalArgumentException(e);\n-            else\n-                throw new InvocationTargetException(e);\n-        } catch (Throwable e) {\n-            throw new InvocationTargetException(e);\n-        }\n-    }\n-\n-    private boolean isIllegalArgument(RuntimeException ex) {\n-        return AccessorUtils.isIllegalArgument(DirectConstructorAccessorImpl.class, ex);\n-    }\n-\n-    @Hidden\n-    @ForceInline\n-    Object invokeImpl(Object[] args) throws Throwable {\n-        var mhInvoker = mhInvoker();\n-        return switch (paramCount) {\n-            case 0 -> mhInvoker.invoke();\n-            case 1 -> mhInvoker.invoke(args[0]);\n-            case 2 -> mhInvoker.invoke(args[0], args[1]);\n-            case 3 -> mhInvoker.invoke(args[0], args[1], args[2]);\n-            default -> mhInvoker.invoke(args);\n-        };\n-    }\n-\n-    static class AdaptiveConstructorAccessor extends DirectConstructorAccessorImpl {\n-        private @Stable MHInvoker fastInvoker;\n-        private int numInvocations;\n-        AdaptiveConstructorAccessor(Constructor<?> ctor, MethodHandle target) {\n-            super(ctor, target);\n-        }\n-\n-        @ForceInline\n-        MHInvoker mhInvoker() {\n-            var invoker = fastInvoker;\n-            if (invoker != null) {\n-                return invoker;\n-            }\n-            return slowInvoker();\n-        }\n-\n-        @DontInline\n-        private MHInvoker slowInvoker() {\n-            var invoker = this.invoker;\n-            if (++numInvocations > ReflectionFactory.inflationThreshold()) {\n-                fastInvoker = invoker = newMethodHandleInvoker(ctor, target);\n-            }\n-            return invoker;\n-        }\n-    }\n-\n-    \/**\n-     * Invoke the constructor via native VM reflection\n-     *\/\n-    static class NativeAccessor extends ConstructorAccessorImpl {\n-        private final Constructor<?> ctor;\n-        NativeAccessor(Constructor<?> ctor) {\n-            this.ctor = ctor;\n-        }\n-\n-        @Override\n-        public Object newInstance(Object[] args) throws InstantiationException, InvocationTargetException {\n-            return newInstance0(ctor, args);\n-        }\n-        private static native Object newInstance0(Constructor<?> c, Object[] args)\n-                    throws InstantiationException, InvocationTargetException;\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/DirectConstructorAccessorImpl.java","additions":0,"deletions":157,"binary":false,"changes":157,"status":"deleted"},{"patch":"@@ -0,0 +1,157 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.reflect;\n+\n+import jdk.internal.vm.annotation.DontInline;\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.annotation.Hidden;\n+import jdk.internal.vm.annotation.Stable;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.WrongMethodTypeException;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+\n+import static jdk.internal.reflect.MethodHandleAccessorFactory.SPECIALIZED_PARAM_COUNT;\n+import static jdk.internal.reflect.MethodHandleAccessorFactory.newMethodHandleInvoker;\n+\n+class DirectConstructorHandleAccessorImpl extends ConstructorAccessorImpl {\n+    static ConstructorAccessorImpl constructorAccessor(Constructor<?> ctor, MethodHandle target) {\n+        if (ReflectionFactory.noInflation()) {\n+            \/\/ fast invoker\n+            var mhInvoker = newMethodHandleInvoker(ctor, target);\n+            return new DirectConstructorHandleAccessorImpl(ctor, target, mhInvoker);\n+        } else {\n+            \/\/ Default is the adaptive accessor method.\n+            return new AdaptiveConstructorHandleAccessor(ctor, target);\n+        }\n+    }\n+\n+    static ConstructorAccessorImpl nativeAccessor(Constructor<?> ctor) {\n+        return new NativeAccessor(ctor);\n+    }\n+\n+    protected final Constructor<?> ctor;\n+    protected final int paramCount;\n+\n+    @Stable protected final MethodHandle target;\n+    @Stable protected final MHInvoker invoker;\n+    DirectConstructorHandleAccessorImpl(Constructor<?> ctor, MethodHandle target, MHInvoker invoker) {\n+        this.ctor = ctor;\n+        this.paramCount = ctor.getParameterCount();\n+        this.target = target;\n+        this.invoker = invoker;\n+    }\n+\n+    @ForceInline\n+    MHInvoker mhInvoker() {\n+        return invoker;\n+    }\n+\n+    @Override\n+    public Object newInstance(Object[] args) throws InstantiationException, InvocationTargetException {\n+        int argc = args != null ? args.length : 0;\n+        \/\/ only check argument count for specialized forms\n+        if (paramCount <= SPECIALIZED_PARAM_COUNT && argc != paramCount) {\n+            throw new IllegalArgumentException(\"wrong number of arguments: \" + argc + \" expected: \" + paramCount);\n+        }\n+        try {\n+            return invokeImpl(args);\n+        } catch (ClassCastException|WrongMethodTypeException e) {\n+            if (isIllegalArgument(e))\n+                throw new IllegalArgumentException(\"argument type mismatch\", e);\n+            else\n+                throw new InvocationTargetException(e);\n+        } catch (NullPointerException e) {\n+            if (isIllegalArgument(e))\n+                throw new IllegalArgumentException(e);\n+            else\n+                throw new InvocationTargetException(e);\n+        } catch (Throwable e) {\n+            throw new InvocationTargetException(e);\n+        }\n+    }\n+\n+    private boolean isIllegalArgument(RuntimeException ex) {\n+        return AccessorUtils.isIllegalArgument(DirectConstructorHandleAccessorImpl.class, ex);\n+    }\n+\n+    @Hidden\n+    @ForceInline\n+    Object invokeImpl(Object[] args) throws Throwable {\n+        var mhInvoker = mhInvoker();\n+        return switch (paramCount) {\n+            case 0 -> mhInvoker.invoke();\n+            case 1 -> mhInvoker.invoke(args[0]);\n+            case 2 -> mhInvoker.invoke(args[0], args[1]);\n+            case 3 -> mhInvoker.invoke(args[0], args[1], args[2]);\n+            default -> mhInvoker.invoke(args);\n+        };\n+    }\n+\n+    static class AdaptiveConstructorHandleAccessor extends DirectConstructorHandleAccessorImpl {\n+        private @Stable MHInvoker fastInvoker;\n+        private int numInvocations;\n+        AdaptiveConstructorHandleAccessor(Constructor<?> ctor, MethodHandle target) {\n+            super(ctor, target, new MHInvokerDelegate(target));\n+        }\n+\n+        @ForceInline\n+        MHInvoker mhInvoker() {\n+            var invoker = fastInvoker;\n+            if (invoker != null) {\n+                return invoker;\n+            }\n+            return slowInvoker();\n+        }\n+\n+        @DontInline\n+        private MHInvoker slowInvoker() {\n+            var invoker = this.invoker;\n+            if (++numInvocations > ReflectionFactory.inflationThreshold()) {\n+                fastInvoker = invoker = newMethodHandleInvoker(ctor, target);\n+            }\n+            return invoker;\n+        }\n+    }\n+\n+    \/**\n+     * Invoke the constructor via native VM reflection\n+     *\/\n+    static class NativeAccessor extends ConstructorAccessorImpl {\n+        private final Constructor<?> ctor;\n+        NativeAccessor(Constructor<?> ctor) {\n+            this.ctor = ctor;\n+        }\n+\n+        @Override\n+        public Object newInstance(Object[] args) throws InstantiationException, InvocationTargetException {\n+            return newInstance0(ctor, args);\n+        }\n+        private static native Object newInstance0(Constructor<?> c, Object[] args)\n+                    throws InstantiationException, InvocationTargetException;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/DirectConstructorHandleAccessorImpl.java","additions":157,"deletions":0,"binary":false,"changes":157,"status":"added"},{"patch":"@@ -47,1 +47,1 @@\n-class DirectMethodAccessorImpl extends MethodAccessorImpl {\n+class DirectMethodHandleAccessorImpl extends MethodAccessorImpl {\n@@ -57,1 +57,1 @@\n-            return new DirectMethodAccessorImpl(method, target, mhInvoker, false);\n+            return new DirectMethodHandleAccessorImpl(method, target, mhInvoker, false);\n@@ -60,1 +60,1 @@\n-            return new AdaptiveMethodAccessor(method, target);\n+            return new AdaptiveMethodHandleAccessor(method, target);\n@@ -82,1 +82,1 @@\n-        return new AdapterMethodAccessorWithCaller(original, target);\n+        return new AdapterMethodHandleAccessorWithCaller(original, target);\n@@ -102,1 +102,1 @@\n-    DirectMethodAccessorImpl(Method method, MethodHandle target, MHInvoker invoker, boolean hasCallerParameter) {\n+    DirectMethodHandleAccessorImpl(Method method, MethodHandle target, MHInvoker invoker, boolean hasCallerParameter) {\n@@ -111,1 +111,1 @@\n-    DirectMethodAccessorImpl(Method method, MethodHandle target, boolean hasCallerParameter) {\n+    DirectMethodHandleAccessorImpl(Method method, MethodHandle target, boolean hasCallerParameter) {\n@@ -182,1 +182,1 @@\n-    \/\/ implemented by AdapterMethodAccessorWithCaller and CallerSensitiveWithInvoker\n+    \/\/ implemented by AdapterMethodHandleAccessorWithCaller and CallerSensitiveWithInvoker\n@@ -201,1 +201,1 @@\n-        return AccessorUtils.isIllegalArgument(DirectMethodAccessorImpl.class, ex);\n+        return AccessorUtils.isIllegalArgument(DirectMethodHandleAccessorImpl.class, ex);\n@@ -211,1 +211,1 @@\n-    static class AdaptiveMethodAccessor extends DirectMethodAccessorImpl {\n+    static class AdaptiveMethodHandleAccessor extends DirectMethodHandleAccessorImpl {\n@@ -215,1 +215,1 @@\n-        AdaptiveMethodAccessor(Method method, MethodHandle target) {\n+        AdaptiveMethodHandleAccessor(Method method, MethodHandle target) {\n@@ -218,1 +218,1 @@\n-        AdaptiveMethodAccessor(Method method, MethodHandle target, boolean hasCallerParameter) {\n+        AdaptiveMethodHandleAccessor(Method method, MethodHandle target, boolean hasCallerParameter) {\n@@ -241,2 +241,2 @@\n-    static class AdapterMethodAccessorWithCaller extends AdaptiveMethodAccessor {\n-        AdapterMethodAccessorWithCaller(Method method, MethodHandle target) {\n+    static class AdapterMethodHandleAccessorWithCaller extends AdaptiveMethodHandleAccessor {\n+        AdapterMethodHandleAccessorWithCaller(Method method, MethodHandle target) {\n@@ -245,1 +245,1 @@\n-        AdapterMethodAccessorWithCaller(Method method, MethodHandle target, boolean hasCallerParameter) {\n+        AdapterMethodHandleAccessorWithCaller(Method method, MethodHandle target, boolean hasCallerParameter) {\n@@ -278,1 +278,1 @@\n-    static class CallerSensitiveWithInvoker extends DirectMethodAccessorImpl {\n+    static class CallerSensitiveWithInvoker extends DirectMethodHandleAccessorImpl {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/DirectMethodHandleAccessorImpl.java","additions":15,"deletions":15,"binary":false,"changes":30,"previous_filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/DirectMethodAccessorImpl.java","status":"renamed"},{"patch":"@@ -28,0 +28,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -42,1 +43,8 @@\n-public class ClassByteBuilder extends ClassWriter {\n+\/**\n+ * InvokerBuilder generates the bytecode for a hidden class that implements\n+ * MHInvoker or VHInvoker and it uses condy to load a MethodHandle\n+ * or VarHandle from the class data.\n+ * \n+ * @see java.lang.invoke.MethodHandles#classData(MethodHandles.Lookup, String, Class)\n+ *\/\n+class InvokerBuilder extends ClassWriter {\n@@ -60,1 +68,1 @@\n-    public ClassByteBuilder(String classname, Class<?> classDataType) {\n+    InvokerBuilder(String classname, Class<?> classDataType) {\n@@ -69,1 +77,1 @@\n-    public byte[] buildVarHandleInvoker(Field field) {\n+    byte[] buildVarHandleInvoker(Field field) {\n@@ -82,1 +90,1 @@\n-    public byte[] buildMethodHandleInvoker(Method method, MethodType mtype, boolean hasCallerParameter) {\n+    byte[] buildMethodHandleInvoker(Method method, MethodType mtype, boolean hasCallerParameter) {\n@@ -98,1 +106,1 @@\n-    public byte[] buildMethodHandleInvoker(Constructor<?> ctor, MethodType mtype) {\n+    byte[] buildMethodHandleInvoker(Constructor<?> ctor, MethodType mtype) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/InvokerBuilder.java","additions":13,"deletions":5,"binary":false,"changes":18,"previous_filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/ClassByteBuilder.java","status":"renamed"},{"patch":"@@ -36,0 +36,1 @@\n+import java.lang.reflect.Executable;\n@@ -52,0 +53,1 @@\n+import static jdk.internal.reflect.MethodHandleAccessorFactory.LazyStaticHolder.*;\n@@ -54,2 +56,16 @@\n-    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n-\n+    \/**\n+     * Creates a MethodAccessor for the given reflected method.\n+     *\n+     * If the given method is called before the java.lang.invoke initialization\n+     * or the given method is a native method, it will use the native VM reflection\n+     * support.\n+     *\n+     * If the given method is a caller-sensitive method and the corresponding\n+     * caller-sensitive adapter with the caller class parameter is present,\n+     * it will use the method handle of the caller-sensitive adapter.\n+     *\n+     * Otherwise, it will use the direct method handle of the given method.\n+     *\n+     * @see CallerSensitive\n+     * @see CallerSensitiveAdapter\n+     *\/\n@@ -57,1 +73,3 @@\n-        assert VM.isJavaLangInvokeInited();\n+        if (useNativeAccessor(method)) {\n+            return DirectMethodHandleAccessorImpl.nativeAccessor(method, callerSensitive);\n+        }\n@@ -66,1 +84,1 @@\n-                var dmh = findDirectMethodWithCaller(method);\n+                var dmh = findCallerSensitiveAdapter(method);\n@@ -68,1 +86,1 @@\n-                    return DirectMethodAccessorImpl.callerSensitiveAdapter(method, dmh);\n+                    return DirectMethodHandleAccessorImpl.callerSensitiveAdapter(method, dmh);\n@@ -73,1 +91,1 @@\n-                return DirectMethodAccessorImpl.callerSensitiveMethodAccessor(method, dmh);\n+                return DirectMethodHandleAccessorImpl.callerSensitiveMethodAccessor(method, dmh);\n@@ -75,1 +93,1 @@\n-                return DirectMethodAccessorImpl.methodAccessor(method, dmh);\n+                return DirectMethodHandleAccessorImpl.methodAccessor(method, dmh);\n@@ -82,0 +100,8 @@\n+    \/**\n+     * Creates a ConstructorAccessor for the given reflected constructor.\n+     *\n+     * If a given constructor is called before the java.lang.invoke initialization,\n+     * it will use the native VM reflection support.\n+     *\n+     * Otherwise, it will use the direct method handle of the given constructor.\n+     *\/\n@@ -83,1 +109,3 @@\n-        assert VM.isJavaLangInvokeInited();\n+        if (useNativeAccessor(ctor)) {\n+            return DirectConstructorHandleAccessorImpl.nativeAccessor(ctor);\n+        }\n@@ -100,1 +128,1 @@\n-            return DirectConstructorAccessorImpl.constructorAccessor(ctor, target);\n+            return DirectConstructorHandleAccessorImpl.constructorAccessor(ctor, target);\n@@ -106,0 +134,10 @@\n+    \/**\n+     * Creates a FieldAccessor for the given reflected field.\n+     *\n+     * Limitation: Field access via core reflection is only supported after\n+     * java.lang.invoke completes initialization.\n+     * java.lang.invoke initialization starts soon after System::initPhase1\n+     * and method handles are ready for use when initPhase2 begins.\n+     * During early VM startup (initPhase1), fields can be accessed directly\n+     * from the VM or through JNI.\n+     *\/\n@@ -107,1 +145,5 @@\n-        assert VM.isJavaLangInvokeInited();\n+        if (!VM.isJavaLangInvokeInited()) {\n+            throw new InternalError(field.getDeclaringClass().getName() + \"::\" + field.getName() +\n+                    \" cannot be accessed reflectively before java.lang.invoke is initialized\");\n+        }\n+\n@@ -149,1 +191,8 @@\n-    private static MethodHandle findDirectMethodWithCaller(Method method) throws IllegalAccessException {\n+    \/**\n+     * Finds the method handle of a caller-sensitive adapter for the given\n+     * caller-sensitive method.  It has the same name as the given method\n+     * with a trailing caller class parameter.\n+     *\n+     * @see CallerSensitiveAdapter\n+     *\/\n+    private static MethodHandle findCallerSensitiveAdapter(Method method) throws IllegalAccessException {\n@@ -379,1 +428,1 @@\n-        var builder = new ClassByteBuilder(cn, VarHandle.class);\n+        var builder = new InvokerBuilder(cn, VarHandle.class);\n@@ -385,1 +434,1 @@\n-        var builder = new ClassByteBuilder(cn, MethodHandle.class);\n+        var builder = new InvokerBuilder(cn, MethodHandle.class);\n@@ -391,1 +440,1 @@\n-        var builder = new ClassByteBuilder(cn, MethodHandle.class);\n+        var builder = new InvokerBuilder(cn, MethodHandle.class);\n@@ -420,3 +469,27 @@\n-    private static final MethodHandles.Lookup LOOKUP = MethodHandles.lookup();\n-    private static final JavaLangInvokeAccess JLIA = SharedSecrets.getJavaLangInvokeAccess();\n-    private static final Path DUMP_CLASS_FILES;\n+    \/*\n+     * Returns true if NativeAccessor should be used.\n+     *\/\n+    private static boolean useNativeAccessor(Executable member) {\n+        if (!VM.isJavaLangInvokeInited())\n+            return true;\n+\n+        if (Modifier.isNative(member.getModifiers()))\n+            return true;\n+\n+        if (ReflectionFactory.isUseNativeAccessorOnly())  \/\/ for testing only\n+            return true;\n+\n+        \/\/ MethodHandle::withVarargs on a member with varargs modifier bit set\n+        \/\/ verifies that the last parameter of the member must be an array type.\n+        \/\/ The JVMS does not require the last parameter descriptor of the method descriptor\n+        \/\/ is an array type if the ACC_VARARGS flag is set in the access_flags item.\n+        \/\/ Hence the reflection implementation does not check the last parameter type\n+        \/\/ if ACC_VARARGS flag is set.  Workaround this by invoking through\n+        \/\/ the native accessor.\n+        int paramCount = member.getParameterCount();\n+        if (member.isVarArgs() &&\n+                (paramCount == 0 || !(member.getParameterTypes()[paramCount-1].isArray()))) {\n+            return true;\n+        }\n+        return false;\n+    }\n@@ -424,0 +497,10 @@\n+    \/*\n+     * Delay initializing these static fields until java.lang.invoke is fully initialized.\n+     *\/\n+    static class LazyStaticHolder {\n+        static final MethodHandles.Lookup LOOKUP = MethodHandles.lookup();\n+        static final JavaLangInvokeAccess JLIA = SharedSecrets.getJavaLangInvokeAccess();\n+    }\n+\n+    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+    private static final Path DUMP_CLASS_FILES;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MethodHandleAccessorFactory.java","additions":100,"deletions":17,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n-import sun.reflect.misc.ReflectUtil;\n@@ -170,9 +169,0 @@\n-            \/\/ Core reflection is supported after java.lang.invoke completes initialization.\n-            \/\/ java.lang.invoke initialization starts soon after System::initPhase1\n-            \/\/ and method handles are ready for use when initPhase2 begins.\n-            \/\/ During early VM startup (initPhase1), fields are accessed directly from\n-            \/\/ the VM or through JNI.  It should avoid using core reflection.\n-            if (!VM.isJavaLangInvokeInited()) {\n-                throw new InternalError(field.getDeclaringClass().getName() + \"::\" + field.getName() +\n-                        \" cannot be accessed reflectively before java.lang.invoke is initialized\");\n-            }\n@@ -195,3 +185,0 @@\n-            if (useNativeAccessor(method)) {\n-                return DirectMethodAccessorImpl.nativeAccessor(method, callerSensitive);\n-            }\n@@ -200,2 +187,1 @@\n-            if (!useDirectMethodHandle && noInflation\n-                    && !method.getDeclaringClass().isHidden()) {\n+            if (noInflation && !method.getDeclaringClass().isHidden()) {\n@@ -245,3 +231,0 @@\n-            if (useNativeAccessor(c)) {\n-                return DirectConstructorAccessorImpl.nativeAccessor(c);\n-            }\n@@ -271,28 +254,0 @@\n-    \/*\n-     * Returns true if NativeAccessor should be used.\n-     *\/\n-    private static boolean useNativeAccessor(Executable member) {\n-        if (!VM.isJavaLangInvokeInited())\n-            return true;\n-\n-        if (Modifier.isNative(member.getModifiers()))\n-            return true;\n-\n-        if (useNativeAccessorOnly)  \/\/ for testing only\n-            return true;\n-\n-        \/\/ MethodHandle::withVarargs on a member with varargs modifier bit set\n-        \/\/ verifies that the last parameter of the member must be an array type.\n-        \/\/ The JVMS does not require the last parameter descriptor of the method descriptor\n-        \/\/ is an array type if the ACC_VARARGS flag is set in the access_flags item.\n-        \/\/ Hence the reflection implementation does not check the last parameter type\n-        \/\/ if ACC_VARARGS flag is set.  Workaround this by invoking through\n-        \/\/ the native accessor.\n-        int paramCount = member.getParameterCount();\n-        if (member.isVarArgs() &&\n-                (paramCount == 0 || !(member.getParameterTypes()[paramCount-1].isArray()))) {\n-            return true;\n-        }\n-        return false;\n-    }\n-\n@@ -677,0 +632,3 @@\n+    static boolean isUseNativeAccessorOnly() {\n+        return useNativeAccessorOnly;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/ReflectionFactory.java","additions":4,"deletions":46,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -29,2 +29,2 @@\n-#include \"jdk_internal_reflect_DirectConstructorAccessorImpl_NativeAccessor.h\"\n-#include \"jdk_internal_reflect_DirectMethodAccessorImpl_NativeAccessor.h\"\n+#include \"jdk_internal_reflect_DirectMethodHandleAccessorImpl_NativeAccessor.h\"\n+#include \"jdk_internal_reflect_DirectConstructorHandleAccessorImpl_NativeAccessor.h\"\n@@ -44,1 +44,1 @@\n-JNIEXPORT jobject JNICALL Java_jdk_internal_reflect_DirectMethodAccessorImpl_00024NativeAccessor_invoke0\n+JNIEXPORT jobject JNICALL Java_jdk_internal_reflect_DirectMethodHandleAccessorImpl_00024NativeAccessor_invoke0\n@@ -49,1 +49,1 @@\n-JNIEXPORT jobject JNICALL Java_jdk_internal_reflect_DirectConstructorAccessorImpl_00024NativeAccessor_newInstance0\n+JNIEXPORT jobject JNICALL Java_jdk_internal_reflect_DirectConstructorHandleAccessorImpl_00024NativeAccessor_newInstance0\n","filename":"src\/java.base\/share\/native\/libjava\/NativeAccessors.c","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -85,1 +85,1 @@\n-                new CallFrame(\"jdk.internal.reflect.DirectMethodAccessorImpl\", \"invoke\"), \/\/ non-public class\n+                new CallFrame(\"jdk.internal.reflect.DirectMethodHandleAccessorImpl\", \"invoke\"), \/\/ non-public class\n@@ -139,1 +139,1 @@\n-                new CallFrame(\"jdk.internal.reflect.DirectMethodAccessorImpl\", \"invoke\"),\n+                new CallFrame(\"jdk.internal.reflect.DirectMethodHandleAccessorImpl\", \"invoke\"),\n@@ -160,1 +160,1 @@\n-                new CallFrame(\"jdk.internal.reflect.DirectMethodAccessorImpl\", \"invoke\"),\n+                new CallFrame(\"jdk.internal.reflect.DirectMethodHandleAccessorImpl\", \"invoke\"),\n@@ -165,1 +165,1 @@\n-                new CallFrame(\"jdk.internal.reflect.DirectMethodAccessorImpl\", \"invoke\"),\n+                new CallFrame(\"jdk.internal.reflect.DirectMethodHandleAccessorImpl\", \"invoke\"),\n@@ -191,1 +191,1 @@\n-                new CallFrame(\"jdk.internal.reflect.DirectMethodAccessorImpl\", \"invoke\"),\n+                new CallFrame(\"jdk.internal.reflect.DirectMethodHandleAccessorImpl\", \"invoke\"),\n","filename":"test\/jdk\/java\/lang\/StackWalker\/DumpStackTest.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -103,1 +103,1 @@\n-            \"5: java.base\/jdk.internal.reflect.DirectMethodAccessorImpl.invoke(DirectMethodAccessorImpl.java:94)\\n\" +\n+            \"5: java.base\/jdk.internal.reflect.DirectMethodHandleAccessorImpl.invoke(DirectMethodHandleAccessorImpl.java:94)\\n\" +\n@@ -141,2 +141,2 @@\n-            \"12: java.base\/jdk.internal.reflect.DirectMethodAccessorImpl.invokeImpl(DirectMethodAccessorImpl.java:211)\\n\" +\n-            \"13: java.base\/jdk.internal.reflect.DirectMethodAccessorImpl.invoke(DirectMethodAccessorImpl.java:122)\\n\" +\n+            \"12: java.base\/jdk.internal.reflect.DirectMethodHandleAccessorImpl.invokeImpl(DirectMethodHandleAccessorImpl.java:211)\\n\" +\n+            \"13: java.base\/jdk.internal.reflect.DirectMethodHandleAccessorImpl.invoke(DirectMethodHandleAccessorImpl.java:122)\\n\" +\n","filename":"test\/jdk\/java\/lang\/StackWalker\/VerifyStackTrace.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,115 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8271820\n+ * @library \/test\/lib\/\n+ * @modules jdk.compiler\n+ * @build CustomLoaderTest jdk.test.lib.compiler.CompilerUtils\n+ * @run testng\/othervm CustomLoaderTest\n+ * @run testng\/othervm -Dsun.reflect.noInflation=true CustomLoaderTest\n+ *\n+ * @summary Test method whose parameter types and return type are not visible to the caller.\n+ *\/\n+\n+import java.io.IOException;\n+import java.lang.reflect.*;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import jdk.test.lib.compiler.CompilerUtils;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.*;\n+\n+public class CustomLoaderTest {\n+    private static final Path CLASSES = Paths.get(\"classes\");\n+\n+    @BeforeTest\n+    public void setup() throws IOException {\n+        String src = System.getProperty(\"test.src\", \".\");\n+        String classpath = System.getProperty(\"test.classes\", \".\");\n+        boolean rc = CompilerUtils.compile(Paths.get(src, \"ReflectTest.java\"), CLASSES, \"-cp\", classpath);\n+        if (!rc) {\n+            throw new RuntimeException(\"fail compilation\");\n+        }\n+        try {\n+            Class<?> p = Class.forName(\"ReflectTest$P\");\n+            fail(\"should not be visible to this loader\");\n+        } catch (ClassNotFoundException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    @Test\n+    public void test() throws Exception {\n+        TestLoader loader1 = new TestLoader();\n+        TestLoader loader2 = new TestLoader();\n+        Method m1 = loader1.findMethod();\n+        Method m2 = loader2.findMethod();\n+\n+        assertTrue(m1.getDeclaringClass() != m2.getDeclaringClass());\n+\n+        assertTrue(m1.getDeclaringClass() == loader1.c);\n+        assertTrue(m2.getDeclaringClass() == loader2.c);\n+\n+        Object o1 = m1.invoke(loader1.c.newInstance(), loader1.p.newInstance(), loader1.q.newInstance());\n+        Object o2 = m2.invoke(loader2.c.newInstance(), loader2.p.newInstance(), loader2.q.newInstance());\n+\n+        assertTrue(o1.getClass() != o2.getClass());\n+        assertTrue(o1.getClass() == loader1.r);\n+        assertTrue(o2.getClass() == loader2.r);\n+    }\n+\n+    static class TestLoader extends URLClassLoader {\n+        static URL[] toURLs() {\n+            try {\n+                return new URL[]{ CLASSES.toUri().toURL() };\n+            } catch (MalformedURLException e) {\n+                throw new Error(e);\n+            }\n+        }\n+        static AtomicInteger counter = new AtomicInteger(0);\n+\n+        final Class<?> c;\n+        final Class<?> p;\n+        final Class<?> q;\n+        final Class<?> r;\n+        TestLoader() throws ClassNotFoundException {\n+            super(\"testloader-\" + counter.getAndIncrement(), toURLs(), ClassLoader.getPlatformClassLoader());\n+            this.c = Class.forName(\"ReflectTest\", true, this);\n+            this.p = Class.forName(\"ReflectTest$P\", true, this);\n+            this.q = Class.forName(\"ReflectTest$Q\", true, this);\n+            this.r = Class.forName(\"ReflectTest$R\", true, this);\n+        }\n+\n+        Method findMethod() throws ReflectiveOperationException {\n+            return c.getMethod(\"m\", p, q);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/callerCache\/CustomLoaderTest.java","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+public class ReflectTest {\n+     public static class P {\n+     }\n+     public static class Q {\n+     }\n+     public static class R {\n+     }\n+\n+     public R m(P p, Q q) {\n+         return new R();\n+     }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/callerCache\/ReflectTest.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"}]}