{"files":[{"patch":"@@ -1,122 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.openjdk.bench.java.lang.reflect;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Warmup;\n-\n-import java.lang.reflect.Field;\n-import java.util.concurrent.TimeUnit;\n-\n-@BenchmarkMode(Mode.AverageTime)\n-@Warmup(iterations = 10, time = 1)\n-@Measurement(iterations = 10, time = 1)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@State(Scope.Thread)\n-@Fork(value = 1, warmups = 0)\n-public class ReflectionFields {\n-    static final Field staticFieldConst;\n-    static final Field instanceFieldConst;\n-\n-    static Field staticFieldVar;\n-    static Field instanceFieldVar;\n-\n-    static {\n-        try {\n-            staticFieldVar = staticFieldConst = ReflectionFields.class.getDeclaredField(\"staticFoo\");\n-            instanceFieldVar = instanceFieldConst = ReflectionFields.class.getDeclaredField(\"foo\");\n-        } catch (NoSuchFieldException e) {\n-            throw new NoSuchMethodError(e.getMessage());\n-        }\n-    }\n-\n-    public static int staticFoo;\n-    public int foo;\n-    @Benchmark\n-    public int getfield_static() {\n-        return staticFoo;\n-    }\n-\n-    @Benchmark\n-    public int putfield_static() {\n-        return staticFoo = 10;\n-    }\n-\n-    @Benchmark\n-    public int getfield_instance() {\n-        return foo;\n-    }\n-\n-    @Benchmark\n-    public int putfield_instance() {\n-        return foo = 10;\n-    }\n-\n-    @Benchmark\n-    public int getInt_static_field() throws IllegalAccessException {\n-        return staticFieldConst.getInt(null);\n-    }\n-\n-    @Benchmark\n-    public int getInt_instance_field() throws IllegalAccessException {\n-        return instanceFieldConst.getInt(this);\n-    }\n-\n-    @Benchmark\n-    public void setInt_static_field() throws IllegalAccessException {\n-        staticFieldConst.setInt(null, 10);\n-    }\n-\n-    @Benchmark\n-    public void setInt_instance_field() throws IllegalAccessException {\n-        instanceFieldConst.setInt(this, 20);\n-    }\n-\n-    @Benchmark\n-    public int getInt_static_field_var() throws IllegalAccessException {\n-        return staticFieldVar.getInt(null);\n-    }\n-\n-    @Benchmark\n-    public int getInt_instance_field_var() throws IllegalAccessException {\n-        return instanceFieldVar.getInt(this);\n-    }\n-\n-    @Benchmark\n-    public void setInt_static_field_var() throws IllegalAccessException {\n-        staticFieldVar.setInt(null, 10);\n-    }\n-\n-    @Benchmark\n-    public void setInt_instance_field_var() throws IllegalAccessException {\n-        instanceFieldVar.setInt(this, 20);\n-    }\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/reflect\/ReflectionFields.java","additions":0,"deletions":122,"binary":false,"changes":122,"status":"deleted"},{"patch":"@@ -1,187 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package org.openjdk.bench.java.lang.reflect;\n-\n-import org.openjdk.jmh.annotations.Benchmark;\n-import org.openjdk.jmh.annotations.BenchmarkMode;\n-import org.openjdk.jmh.annotations.Fork;\n-import org.openjdk.jmh.annotations.Level;\n-import org.openjdk.jmh.annotations.Measurement;\n-import org.openjdk.jmh.annotations.Mode;\n-import org.openjdk.jmh.annotations.OutputTimeUnit;\n-import org.openjdk.jmh.annotations.Scope;\n-import org.openjdk.jmh.annotations.Setup;\n-import org.openjdk.jmh.annotations.State;\n-import org.openjdk.jmh.annotations.Warmup;\n-\n-import java.lang.reflect.Constructor;\n-import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.Method;\n-import java.util.concurrent.ThreadLocalRandom;\n-import java.util.concurrent.TimeUnit;\n-\n-@BenchmarkMode(Mode.AverageTime)\n-@Warmup(iterations = 10, time = 1)\n-@Measurement(iterations = 10, time = 1)\n-@OutputTimeUnit(TimeUnit.NANOSECONDS)\n-@State(Scope.Thread)\n-@Fork(value = 1, warmups = 0)\n-public class ReflectionMethods {\n-    static final Method staticMethodConst;\n-    static final Method instanceMethodConts;\n-    static final Method staticMethodConst_3arg;\n-    static final Method instanceMethodConts_3arg;\n-    static final Method classForName1argConst;\n-    static final Method classForName3argConst;\n-    static final Constructor<?> ctorConst;\n-\n-    static Method staticMethodVar;\n-    static Method instanceMethodVar;\n-    static Method staticMethodVar_3arg;\n-    static Method instanceMethodVar_3arg;\n-    static Method classForName1argVar;\n-    static Method classForName3argVar;\n-    static Constructor<?> ctorVar;\n-\n-    static {\n-        try {\n-            staticMethodVar = staticMethodConst = ReflectionMethods.class.getDeclaredMethod(\"sumStatic\", int.class, int.class);\n-            instanceMethodVar = instanceMethodConts = ReflectionMethods.class.getDeclaredMethod(\"sumInstance\", int.class, int.class);\n-            staticMethodVar_3arg = staticMethodConst_3arg = ReflectionMethods.class.getDeclaredMethod(\"sumStatic\", int.class, int.class, int.class);\n-            instanceMethodVar_3arg = instanceMethodConts_3arg = ReflectionMethods.class.getDeclaredMethod(\"sumInstance\", int.class, int.class, int.class);\n-            classForName1argVar = classForName1argConst = Class.class.getMethod(\"forName\", String.class);\n-            classForName3argVar = classForName3argConst = Class.class.getMethod(\"forName\", String.class, boolean.class, ClassLoader.class);\n-            ctorVar = ctorConst = ReflectionMethods.Foo.class.getDeclaredConstructor(String.class);\n-        } catch (NoSuchMethodException e) {\n-            throw new NoSuchMethodError(e.getMessage());\n-        }\n-    }\n-\n-    private int a, b, c;\n-    static class Foo {\n-        public Foo(String s) {}\n-    }\n-\n-    @Setup(Level.Iteration)\n-    public void setup() {\n-        a = ThreadLocalRandom.current().nextInt(1024, Integer.MAX_VALUE);\n-        b = ThreadLocalRandom.current().nextInt(1024, Integer.MAX_VALUE);\n-        c = ThreadLocalRandom.current().nextInt(1024, Integer.MAX_VALUE);\n-    }\n-\n-    public static int sumStatic(int a, int b) {\n-        return a + b;\n-    }\n-\n-    public int sumInstance(int a, int b) {\n-        return a + b;\n-    }\n-\n-    public static int sumStatic(int a, int b, int c) { return a + b + c; }\n-\n-    public int sumInstance(int a, int b, int c) {\n-        return a + b + c;\n-    }\n-\n-    @Benchmark\n-    public int direct_static_method() {\n-        return sumStatic(a, b);\n-    }\n-\n-    @Benchmark\n-    public int direct_instance_method() {\n-        return sumInstance(a, b);\n-    }\n-\n-    @Benchmark\n-    public Object static_method() throws InvocationTargetException, IllegalAccessException {\n-        return staticMethodConst.invoke(null, a, b);\n-    }\n-\n-    @Benchmark\n-    public Object static_method_3arg() throws InvocationTargetException, IllegalAccessException {\n-        return staticMethodConst_3arg.invoke(null, a, b, c);\n-    }\n-\n-    @Benchmark\n-    public Object instance_method() throws InvocationTargetException, IllegalAccessException {\n-        return instanceMethodConts.invoke(this, a, b);\n-    }\n-\n-    @Benchmark\n-    public Object instance_method_3arg() throws InvocationTargetException, IllegalAccessException {\n-        return instanceMethodConts_3arg.invoke(this, a, b, c);\n-    }\n-\n-    @Benchmark\n-    public Class<?> class_forName_1arg() throws InvocationTargetException, IllegalAccessException {\n-        return (Class<?>) classForName1argVar.invoke(null, \"java.lang.System\");\n-    }\n-\n-    @Benchmark\n-    public Class<?> class_forName_3arg() throws InvocationTargetException, IllegalAccessException {\n-        return (Class<?>) classForName3argVar.invoke(null, \"java.lang.System\", false, null);\n-    }\n-\n-    @Benchmark\n-    public Object static_method_var() throws InvocationTargetException, IllegalAccessException {\n-        return staticMethodVar.invoke(null, a, b);\n-    }\n-\n-    @Benchmark\n-    public Object instance_method_var() throws InvocationTargetException, IllegalAccessException {\n-        return instanceMethodVar.invoke(this, a, b);\n-    }\n-\n-    @Benchmark\n-    public Object static_method_var_3arg() throws InvocationTargetException, IllegalAccessException {\n-        return staticMethodVar_3arg.invoke(null, a, b, c);\n-    }\n-\n-    @Benchmark\n-    public Object instance_method_var_3arg() throws InvocationTargetException, IllegalAccessException {\n-        return instanceMethodVar_3arg.invoke(this, a, b, c);\n-    }\n-\n-\n-    @Benchmark\n-    public Class<?> class_forName_1arg_var() throws InvocationTargetException, IllegalAccessException {\n-        return (Class<?>) classForName1argVar.invoke(null, \"java.lang.System\");\n-    }\n-\n-    @Benchmark\n-    public Class<?> class_forName_3arg_var() throws InvocationTargetException, IllegalAccessException {\n-        return (Class<?>) classForName3argVar.invoke(null, \"java.lang.System\", false, null);\n-    }\n-\n-    @Benchmark\n-    public Object ctor_newInstance() throws InvocationTargetException, InstantiationException, IllegalAccessException {\n-        return ctorConst.newInstance(\"foo\");\n-    }\n-\n-    @Benchmark\n-    public Object ctor_newInstance_var() throws InvocationTargetException, InstantiationException, IllegalAccessException {\n-        return ctorVar.newInstance(\"foo\");\n-    }\n-}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/reflect\/ReflectionMethods.java","additions":0,"deletions":187,"binary":false,"changes":187,"status":"deleted"},{"patch":"@@ -27,0 +27,1 @@\n+import org.openjdk.jmh.annotations.CompilerControl;\n@@ -32,0 +33,1 @@\n+import org.openjdk.jmh.annotations.Param;\n@@ -46,3 +48,3 @@\n- *     <li>Const - Method\/Field is constant-foldable<\/li>\n- *     <li>Var - Method\/Field is single-instance but not constant-foldable<\/li>\n- *     <li>Poly - multiple Method\/Field instances used at single call-site<\/li>\n+ *     <li>Const - Constructor\/Method\/Field is constant-foldable<\/li>\n+ *     <li>Var - Constructor\/Method\/Field is single-instance but not constant-foldable<\/li>\n+ *     <li>Poly - multiple Constructor\/Method\/Field instances used at single call-site<\/li>\n@@ -81,2 +83,2 @@\n-            staticMethodConst = staticMethodVar = ReflectionSpeedBenchmark.class.getDeclaredMethod(\"sumStatic\", int.class, int.class);\n-            instanceMethodConst = instanceMethodVar = ReflectionSpeedBenchmark.class.getDeclaredMethod(\"sumInstance\", int.class, int.class);\n+            staticMethodConst = staticMethodVar = ReflectionSpeedBenchmark.class.getDeclaredMethod(\"sumStatic\", Integer.class, Integer.class);\n+            instanceMethodConst = instanceMethodVar = ReflectionSpeedBenchmark.class.getDeclaredMethod(\"sumInstance\", Integer.class, Integer.class);\n@@ -271,1 +273,1 @@\n-    private int a, b;\n+    private Integer a, b;\n@@ -279,0 +281,3 @@\n+    \/\/ @Param({\"true\", \"false\"})\n+    private boolean polluteProfile = true;\n+\n@@ -283,0 +288,1 @@\n+        c = nextRnd();\n@@ -285,0 +291,30 @@\n+\n+        if (polluteProfile) {\n+            try {\n+                Constructor ctor = ReflectionSpeedBenchmark.class.getDeclaredConstructor(Integer.class);\n+                Method test1 = ReflectionSpeedBenchmark.class.getDeclaredMethod(\"test1\", Object.class);\n+                Method test2 = ReflectionSpeedBenchmark.class.getDeclaredMethod(\"test2\", Object.class, Object.class);\n+                Field f = ReflectionSpeedBenchmark.class.getDeclaredField(\"testField\");\n+                for (int i = 0; i < 20_000; i++) {\n+                    invokeHelper2(staticMethodVar, null, a, b);\n+                    invokeHelper2(instanceMethodVar, this, a, b);\n+                    invokeHelper2(test2, null, a, b);\n+                    invokeHelper1(staticMethodsPoly[i & (staticMethodsPoly.length - 1)], instance, o);\n+                    invokeHelper1(instanceMethodsPoly[i & (instanceMethodsPoly.length - 1)], instance, o);\n+                    invokeHelper1(test1, null, a);\n+\n+                    newInstanceHelper(constructorVar, constructorArgs);\n+                    int index = i & (constructorsPoly.length - 1);\n+                    newInstanceHelper(constructorsPoly[index], constructorsArgsPoly[index]);\n+                    newInstanceHelper(ctor, new Object[]{a});\n+\n+                    getIntHelper(staticFieldVar, null);\n+                    getIntHelper(instanceFieldVar, this);\n+                    getDoubleHelper(f, null);\n+                    getHelper(staticFieldsPoly[i & (staticFieldsPoly.length - 1)], null);\n+                    getHelper(instanceFieldsPoly[i & (instanceFieldsPoly.length - 1)], instance);\n+                }\n+            } catch (ReflectiveOperationException e) {\n+                 throw new InternalError(e);\n+            }\n+        }\n@@ -287,1 +323,1 @@\n-    public static int sumStatic(int a, int b) {\n+    public static Integer sumStatic(Integer a, Integer b) {\n@@ -291,1 +327,1 @@\n-    public int sumInstance(int a, int b) {\n+    public Integer sumInstance(Integer a, Integer b) {\n@@ -297,0 +333,7 @@\n+    public ReflectionSpeedBenchmark() {}\n+\n+    \/\/ used for polluting the profile\n+    private ReflectionSpeedBenchmark(Integer a) {}\n+    static void test1(Object a) {}\n+    static void test2(Object a, Object b) {}\n+    static double testField;\n@@ -299,0 +342,28 @@\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    static Object invokeHelper1(Method m, Object recv, Object arg1) throws InvocationTargetException, IllegalAccessException {\n+        return m.invoke(recv, arg1);\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    static Object invokeHelper2(Method m, Object recv, Object arg1, Object arg2) throws InvocationTargetException, IllegalAccessException {\n+        return m.invoke(recv, arg1, arg2);\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    static Object newInstanceHelper(Constructor ctor, Object[] args) throws InvocationTargetException, IllegalAccessException, InstantiationException {\n+        return ctor.newInstance(args);\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    static int getIntHelper(Field f, Object recv) throws IllegalAccessException {\n+        return f.getInt(recv);\n+    }\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    static double getDoubleHelper(Field f, Object recv) throws IllegalAccessException {\n+        return f.getDouble(recv);\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.INLINE)\n+    static Object getHelper(Field f, Object recv) throws IllegalAccessException {\n+        return f.get(recv);\n+    }\n@@ -301,1 +372,1 @@\n-    public int staticMethodConst() {\n+    public Object staticMethodConst() {\n@@ -303,1 +374,1 @@\n-            return (Integer) staticMethodConst.invoke(null, a, b);\n+            return invokeHelper2(staticMethodConst, null, a, b);\n@@ -310,1 +381,1 @@\n-    public int instanceMethodConst() {\n+    public Object instanceMethodConst() {\n@@ -312,1 +383,1 @@\n-            return (Integer) instanceMethodConst.invoke(this, a, b);\n+            return invokeHelper2(instanceMethodConst, this, a, b);\n@@ -319,1 +390,1 @@\n-    public int staticMethodVar() {\n+    public Object staticMethodVar() {\n@@ -321,1 +392,1 @@\n-            return (Integer) staticMethodVar.invoke(null, a, b);\n+            return invokeHelper2(staticMethodVar, null, a, b);\n@@ -328,1 +399,1 @@\n-    public int instanceMethodVar() {\n+    public Object instanceMethodVar() {\n@@ -330,1 +401,1 @@\n-            return (Integer) instanceMethodVar.invoke(this, a, b);\n+            return invokeHelper2(instanceMethodVar, this, a, b);\n@@ -339,1 +410,1 @@\n-            return staticMethodsPoly[nextRnd() & (staticMethodsPoly.length - 1)].invoke(null, o);\n+            return invokeHelper1(staticMethodsPoly[nextRnd() & (staticMethodsPoly.length - 1)], null, o);\n@@ -348,1 +419,1 @@\n-            return instanceMethodsPoly[nextRnd() & (instanceMethodsPoly.length - 1)].invoke(instance, o);\n+            return invokeHelper1(instanceMethodsPoly[nextRnd() & (instanceMethodsPoly.length - 1)], instance, o);\n@@ -359,1 +430,1 @@\n-            return staticFieldConst.getInt(null);\n+            return getIntHelper(staticFieldConst, null);\n@@ -368,1 +439,1 @@\n-            return instanceFieldConst.getInt(this);\n+            return getIntHelper(instanceFieldConst, this);\n@@ -377,1 +448,1 @@\n-            return staticFieldVar.getInt(null);\n+            return getIntHelper(staticFieldVar, null);\n@@ -386,1 +457,1 @@\n-            return instanceFieldVar.getInt(this);\n+            return getIntHelper(instanceFieldVar, this);\n@@ -395,1 +466,1 @@\n-            return staticFieldsPoly[nextRnd() & (staticFieldsPoly.length - 1)].get(null);\n+            return getHelper(staticFieldsPoly[nextRnd() & (staticFieldsPoly.length - 1)], null);\n@@ -404,1 +475,1 @@\n-            return instanceFieldsPoly[nextRnd() & (instanceFieldsPoly.length - 1)].get(instance);\n+            return getHelper(instanceFieldsPoly[nextRnd() & (instanceFieldsPoly.length - 1)], instance);\n@@ -415,1 +486,1 @@\n-            return constructorConst.newInstance(constructorArgs);\n+            return newInstanceHelper(constructorConst, constructorArgs);\n@@ -424,1 +495,1 @@\n-            return constructorVar.newInstance(constructorArgs);\n+            return newInstanceHelper(constructorVar, constructorArgs);\n@@ -434,1 +505,1 @@\n-            return constructorsPoly[i].newInstance(constructorsArgsPoly[i]);\n+            return newInstanceHelper(constructorsPoly[i], constructorsArgsPoly[i]);\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/reflect\/ReflectionSpeedBenchmark.java","additions":98,"deletions":27,"binary":false,"changes":125,"status":"modified"}]}