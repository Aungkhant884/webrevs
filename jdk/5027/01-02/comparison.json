{"files":[{"patch":"@@ -65,1 +65,4 @@\n-            if (isAccessorImplClass(cname)) {\n+            if ((accessorType == DirectMethodAccessorImpl.class\n+                    && cname.startsWith(DirectConstructorAccessorImpl.class.getName()))\n+                || (accessorType == DirectConstructorAccessorImpl.class &&\n+                        cname.startsWith(DirectMethodAccessorImpl.class.getName()))) {\n@@ -73,9 +76,0 @@\n-    \/*\n-     * Returns true if it is DirectMethodAccessorImpl or DirectConstructorAccessorImpl\n-     * or its subclass.\n-     *\/\n-    private static boolean isAccessorImplClass(String cn) {\n-        return cn.startsWith(DirectMethodAccessorImpl.class.getName()) ||\n-                cn.startsWith(DirectConstructorAccessorImpl.class.getName());\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/AccessorUtils.java","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -50,2 +50,2 @@\n-    private static final String[] METHOD_ACCESSOR_INTF = new String[] { \"jdk\/internal\/reflect\/MHMethodAccessor\" };\n-    private static final String[] FIELD_ACCESSOR_INTF = new String[] {  \"jdk\/internal\/reflect\/MHFieldAccessor\" };\n+    private static final String[] MH_INVOKER_INTF = new String[] { \"jdk\/internal\/reflect\/MHInvoker\" };\n+    private static final String[] VH_INVOKER_INTF = new String[] {  \"jdk\/internal\/reflect\/VHInvoker\" };\n@@ -69,2 +69,2 @@\n-    public byte[] buildFieldAccessor(Field field) {\n-        visit(CLASSFILE_VERSION, ACC_FINAL, classname, null, OBJECT_CLS, FIELD_ACCESSOR_INTF);\n+    public byte[] buildVarHandleInvoker(Field field) {\n+        visit(CLASSFILE_VERSION, ACC_FINAL, classname, null, OBJECT_CLS, VH_INVOKER_INTF);\n@@ -82,2 +82,2 @@\n-    public byte[] buildMethodAccessor(Method method, MethodType mtype, boolean hasCallerParameter) {\n-        visit(CLASSFILE_VERSION, ACC_FINAL, classname, null, OBJECT_CLS, METHOD_ACCESSOR_INTF);\n+    public byte[] buildMethodHandleInvoker(Method method, MethodType mtype, boolean hasCallerParameter) {\n+        visit(CLASSFILE_VERSION, ACC_FINAL, classname, null, OBJECT_CLS, MH_INVOKER_INTF);\n@@ -92,1 +92,1 @@\n-            addSpecializedInvokeMethod(mtype, isStatic, hasCallerParameter, method.getParameterCount());\n+            addSpecializedInvokeMethod(mtype, true, hasCallerParameter, method.getParameterCount());\n@@ -98,2 +98,2 @@\n-    public byte[] buildConstructorAccessor(Constructor<?> ctor, MethodType mtype) {\n-        visit(CLASSFILE_VERSION, ACC_FINAL, classname, null, OBJECT_CLS, METHOD_ACCESSOR_INTF);\n+    public byte[] buildMethodHandleInvoker(Constructor<?> ctor, MethodType mtype) {\n+        visit(CLASSFILE_VERSION, ACC_FINAL, classname, null, OBJECT_CLS, MH_INVOKER_INTF);\n@@ -106,1 +106,1 @@\n-            addSpecializedInvokeMethod(mtype, true \/* no receiver *\/, false, paramCount);\n+            addSpecializedInvokeMethod(mtype, false \/* no receiver *\/, false, paramCount);\n@@ -161,1 +161,1 @@\n-    private void addSpecializedInvokeMethod(MethodType mtype, boolean isStatic, boolean hasCallerParameter, int paramCount) {\n+    private void addSpecializedInvokeMethod(MethodType mtype, boolean hasReceiver, boolean hasCallerParameter, int paramCount) {\n@@ -169,1 +169,1 @@\n-        if (!isStatic) {\n+        if (hasReceiver) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/ClassByteBuilder.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import java.util.Arrays;\n@@ -40,0 +39,1 @@\n+import static jdk.internal.reflect.MethodHandleAccessorFactory.newMethodHandleInvoker;\n@@ -43,1 +43,8 @@\n-        return new DirectConstructorAccessorImpl(ctor, target);\n+        if (ReflectionFactory.noInflation()) {\n+            \/\/ fast invoker\n+            var mhInvoker = newMethodHandleInvoker(ctor, target);\n+            return new DirectConstructorAccessorImpl(ctor, target);\n+        } else {\n+            \/\/ Default is the adaptive accessor method.\n+            return new AdaptiveConstructorAccessor(ctor, target);\n+        }\n@@ -54,1 +61,1 @@\n-    @Stable protected final MHMethodAccessor invoker;\n+    @Stable protected final MHInvoker invoker;\n@@ -59,1 +66,1 @@\n-        this.invoker = new MHMethodAccessorDelegate(target);\n+        this.invoker = new MHInvokerDelegate(target);\n@@ -63,1 +70,1 @@\n-    MHMethodAccessor mhInvoker() {\n+    MHInvoker mhInvoker() {\n@@ -108,2 +115,2 @@\n-    static class StaticAdaptiveAccessor extends DirectConstructorAccessorImpl {\n-        private @Stable MHMethodAccessor fastInvoker;\n+    static class AdaptiveConstructorAccessor extends DirectConstructorAccessorImpl {\n+        private @Stable MHInvoker fastInvoker;\n@@ -111,1 +118,1 @@\n-        StaticAdaptiveAccessor(Constructor<?> ctor, MethodHandle target) {\n+        AdaptiveConstructorAccessor(Constructor<?> ctor, MethodHandle target) {\n@@ -116,1 +123,1 @@\n-        MHMethodAccessor mhInvoker() {\n+        MHInvoker mhInvoker() {\n@@ -125,1 +132,1 @@\n-        private MHMethodAccessor slowInvoker() {\n+        private MHInvoker slowInvoker() {\n@@ -128,1 +135,1 @@\n-                fastInvoker = invoker = MethodHandleAccessorFactory.newMethodHandleAccessor(ctor, target);\n+                fastInvoker = invoker = newMethodHandleInvoker(ctor, target);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/DirectConstructorAccessorImpl.java","additions":18,"deletions":11,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-import static java.lang.invoke.MethodType.methodType;\n+import static java.lang.invoke.MethodType.genericMethodType;\n@@ -45,0 +45,1 @@\n+import static jdk.internal.reflect.MethodHandleAccessorFactory.newMethodHandleInvoker;\n@@ -46,1 +47,1 @@\n-abstract class DirectMethodAccessorImpl extends MethodAccessorImpl {\n+class DirectMethodAccessorImpl extends MethodAccessorImpl {\n@@ -53,1 +54,0 @@\n-        boolean isStatic = Modifier.isStatic(method.getModifiers());\n@@ -56,3 +56,2 @@\n-            var mhInvoker = MethodHandleAccessorFactory.newMethodHandleAccessor(method, target, false);\n-            return isStatic ? new StaticMethodAccessor(method, target, mhInvoker, false)\n-                            : new InstanceMethodAccessor(method, target, mhInvoker, false);\n+            var mhInvoker = newMethodHandleInvoker(method, target, false);\n+            return new DirectMethodAccessorImpl(method, target, mhInvoker, false);\n@@ -61,2 +60,1 @@\n-            return isStatic ? new StaticAdaptiveMethodAccessor(method, target)\n-                            : new InstanceAdaptiveMethodAccessor(method, target);\n+            return new AdaptiveMethodAccessor(method, target);\n@@ -82,2 +80,0 @@\n-        boolean isStatic = Modifier.isStatic(original.getModifiers());\n-\n@@ -86,2 +82,1 @@\n-        return isStatic ? new StaticAdaptiveMethodAccessorWithCaller(original, target)\n-                        : new InstanceAdapterMethodAccessorWithCaller(original, target);\n+        return new AdapterMethodAccessorWithCaller(original, target);\n@@ -103,0 +98,1 @@\n+    protected final boolean isStatic;\n@@ -104,1 +100,1 @@\n-    @Stable protected final MHMethodAccessor invoker;\n+    @Stable protected final MHInvoker invoker;\n@@ -106,1 +102,1 @@\n-    DirectMethodAccessorImpl(Method method, MethodHandle target, MHMethodAccessor invoker, boolean hasCallerParameter) {\n+    DirectMethodAccessorImpl(Method method, MethodHandle target, MHInvoker invoker, boolean hasCallerParameter) {\n@@ -112,0 +108,5 @@\n+        this.isStatic = Modifier.isStatic(method.getModifiers());\n+    }\n+\n+    DirectMethodAccessorImpl(Method method, MethodHandle target, boolean hasCallerParameter) {\n+        this(method, target, new MHInvokerDelegate(target), hasCallerParameter);\n@@ -115,1 +116,1 @@\n-    MHMethodAccessor mhInvoker() {\n+    MHInvoker mhInvoker() {\n@@ -120,1 +121,1 @@\n-     * Returns a MHMethodAccessor that invokes the given target method handle\n+     * Returns a MHInvoker that invokes the given target method handle\n@@ -123,2 +124,2 @@\n-    MHMethodAccessor spinMHMethodAccessor() {\n-        return MethodHandleAccessorFactory.newMethodHandleAccessor(method, target, hasCallerParameter);\n+    MHInvoker spinMethodHandleInvoker() {\n+        return newMethodHandleInvoker(method, target, hasCallerParameter);\n@@ -127,9 +128,5 @@\n-    static class StaticMethodAccessor extends DirectMethodAccessorImpl {\n-        StaticMethodAccessor(Method method, MethodHandle target) {\n-            this(method, target, new MHMethodAccessorDelegate(target), false);\n-        }\n-        StaticMethodAccessor(Method method, MethodHandle target, boolean hasCallerParameter) {\n-            this(method, target, new MHMethodAccessorDelegate(target), hasCallerParameter);\n-        }\n-        StaticMethodAccessor(Method method, MethodHandle target, MHMethodAccessor invoker, boolean hasCallerParameter) {\n-            super(method, target, invoker, hasCallerParameter);\n+    @Override\n+    @ForceInline\n+    public Object invoke(Object obj, Object[] args) throws InvocationTargetException {\n+        if (!isStatic) {\n+            checkReceiver(obj);\n@@ -137,21 +134,8 @@\n-\n-        @Override\n-        @ForceInline\n-        public Object invoke(Object obj, Object[] args) throws InvocationTargetException {\n-            checkArgumentCount(paramCount, args);\n-            try {\n-                return invokeImpl(args);\n-            } catch (ClassCastException|WrongMethodTypeException e) {\n-                if (isIllegalArgument(e)) {\n-                    \/\/ No cause in IAE to be consistent with the old behavior\n-                    throw new IllegalArgumentException(\"argument type mismatch\");\n-                } else {\n-                    throw new InvocationTargetException(e);\n-                }\n-            } catch (NullPointerException e) {\n-                if (isIllegalArgument(e)) {\n-                    throw new IllegalArgumentException(e);\n-                } else {\n-                    throw new InvocationTargetException(e);\n-                }\n-            } catch (Throwable e) {\n+        checkArgumentCount(paramCount, args);\n+        try {\n+            return invokeImpl(obj, args);\n+        } catch (ClassCastException | WrongMethodTypeException e) {\n+            if (isIllegalArgument(e)) {\n+                \/\/ No cause in IAE to be consistent with the old behavior\n+                throw new IllegalArgumentException(\"argument type mismatch\");\n+            } else {\n@@ -160,17 +144,8 @@\n-        }\n-\n-        @Hidden\n-        @ForceInline\n-        Object invokeImpl(Object[] args) throws Throwable {\n-            var mhInvoker = mhInvoker();\n-            return switch (paramCount) {\n-                case 0 -> mhInvoker.invoke();\n-                case 1 -> mhInvoker.invoke(args[0]);\n-                case 2 -> mhInvoker.invoke(args[0], args[1]);\n-                case 3 -> mhInvoker.invoke(args[0], args[1], args[2]);\n-                default -> mhInvoker.invoke(args);\n-            };\n-        }\n-\n-        boolean isIllegalArgument(RuntimeException ex) {\n-            return AccessorUtils.isIllegalArgument(StaticMethodAccessor.class, ex);\n+        } catch (NullPointerException e) {\n+            if (isIllegalArgument(e)) {\n+                throw new IllegalArgumentException(e);\n+            } else {\n+                throw new InvocationTargetException(e);\n+            }\n+        } catch (Throwable e) {\n+            throw new InvocationTargetException(e);\n@@ -180,14 +155,4 @@\n-    static class InstanceMethodAccessor extends DirectMethodAccessorImpl {\n-        InstanceMethodAccessor(Method method, MethodHandle target) {\n-            this(method, target, new MHMethodAccessorDelegate(target), false);\n-        }\n-        InstanceMethodAccessor(Method method, MethodHandle target, boolean hasCallerParameter) {\n-            this(method, target, new MHMethodAccessorDelegate(target), hasCallerParameter);\n-        }\n-        InstanceMethodAccessor(Method method, MethodHandle target, MHMethodAccessor invoker, boolean hasCallerParameter) {\n-            super(method, target, invoker, hasCallerParameter);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public Object invoke(Object obj, Object[] args) throws InvocationTargetException {\n+    @Override\n+    @ForceInline\n+    public Object invoke(Object obj, Object[] args, Class<?> caller) throws InvocationTargetException {\n+        if (!isStatic) {\n@@ -195,17 +160,9 @@\n-            checkArgumentCount(paramCount, args);\n-            try {\n-                return invokeImpl(obj, args);\n-            } catch (ClassCastException|WrongMethodTypeException e) {\n-                if (isIllegalArgument(e)) {\n-                    \/\/ No cause in IAE to be consistent with the old behavior\n-                    throw new IllegalArgumentException(\"argument type mismatch\");\n-                } else {\n-                    throw new InvocationTargetException(e);\n-                }\n-            } catch (NullPointerException e) {\n-                if (isIllegalArgument(e)) {\n-                    throw new IllegalArgumentException(e);\n-                } else {\n-                    throw new InvocationTargetException(e);\n-                }\n-            } catch (Throwable e) {\n+        }\n+        checkArgumentCount(paramCount, args);\n+        try {\n+            return invokeImpl(obj, args, caller);\n+        } catch (ClassCastException | WrongMethodTypeException e) {\n+            if (isIllegalArgument(e)) {\n+                \/\/ No cause in IAE to be consistent with the old behavior\n+                throw new IllegalArgumentException(\"argument type mismatch\");\n+            } else {\n@@ -214,23 +171,5 @@\n-        }\n-\n-        @Hidden\n-        @ForceInline\n-        Object invokeImpl(Object obj, Object[] args) throws Throwable {\n-            var mhInvoker = mhInvoker();\n-            return switch (paramCount) {\n-                case 0 -> mhInvoker.invoke(obj);\n-                case 1 -> mhInvoker.invoke(obj, args[0]);\n-                case 2 -> mhInvoker.invoke(obj, args[0], args[1]);\n-                case 3 -> mhInvoker.invoke(obj, args[0], args[1], args[2]);\n-                default -> mhInvoker.invoke(obj, args);\n-            };\n-        }\n-\n-        boolean isIllegalArgument(RuntimeException ex) {\n-            return AccessorUtils.isIllegalArgument(InstanceMethodAccessor.class, ex);\n-        }\n-\n-        void checkReceiver(Object o) {\n-            \/\/ NOTE: will throw NullPointerException, as specified, if o is null\n-            if (!method.getDeclaringClass().isAssignableFrom(o.getClass())) {\n-                throw new IllegalArgumentException(\"object is not an instance of declaring class\");\n+        } catch (NullPointerException e) {\n+            if (isIllegalArgument(e)) {\n+                throw new IllegalArgumentException(e);\n+            } else {\n+                throw new InvocationTargetException(e);\n@@ -238,0 +177,2 @@\n+        } catch (Throwable e) {\n+            throw new InvocationTargetException(e);\n@@ -241,3 +182,4 @@\n-    static class StaticAdaptiveMethodAccessor extends StaticMethodAccessor {\n-        private @Stable MHMethodAccessor fastInvoker;\n-        private int numInvocations;\n+    \/\/ implemented by AdapterMethodAccessorWithCaller and CallerSensitiveWithInvoker\n+    Object invokeImpl(Object obj, Object[] args, Class<?> caller) throws Throwable {\n+        throw new InternalError(\"caller-sensitive adapter method only\" + method);\n+    }\n@@ -245,6 +187,12 @@\n-        StaticAdaptiveMethodAccessor(Method method, MethodHandle target) {\n-            this(method, target, false);\n-        }\n-        StaticAdaptiveMethodAccessor(Method method, MethodHandle target, boolean hasCallerParameter) {\n-            super(method, target, hasCallerParameter);\n-        }\n+    @Hidden\n+    @ForceInline\n+    Object invokeImpl(Object obj, Object[] args) throws Throwable {\n+        var mhInvoker = mhInvoker();\n+        return switch (paramCount) {\n+            case 0 -> mhInvoker.invoke(obj);\n+            case 1 -> mhInvoker.invoke(obj, args[0]);\n+            case 2 -> mhInvoker.invoke(obj, args[0], args[1]);\n+            case 3 -> mhInvoker.invoke(obj, args[0], args[1], args[2]);\n+            default -> mhInvoker.invoke(obj, args);\n+        };\n+    }\n@@ -252,8 +200,3 @@\n-        @ForceInline\n-        MHMethodAccessor mhInvoker() {\n-            var invoker = fastInvoker;\n-            if (invoker != null) {\n-                return invoker;\n-            }\n-            return slowInvoker();\n-        }\n+    boolean isIllegalArgument(RuntimeException ex) {\n+        return AccessorUtils.isIllegalArgument(DirectMethodAccessorImpl.class, ex);\n+    }\n@@ -261,7 +204,4 @@\n-        @DontInline\n-        private MHMethodAccessor slowInvoker() {\n-            var invoker = this.invoker;\n-            if (++numInvocations > ReflectionFactory.inflationThreshold()) {\n-                fastInvoker = invoker = spinMHMethodAccessor();\n-            }\n-            return invoker;\n+    void checkReceiver(Object o) {\n+        \/\/ NOTE: will throw NullPointerException, as specified, if o is null\n+        if (!method.getDeclaringClass().isAssignableFrom(o.getClass())) {\n+            throw new IllegalArgumentException(\"object is not an instance of declaring class\");\n@@ -271,2 +211,2 @@\n-    static class InstanceAdaptiveMethodAccessor extends InstanceMethodAccessor {\n-        private @Stable MHMethodAccessor fastInvoker;\n+    static class AdaptiveMethodAccessor extends DirectMethodAccessorImpl {\n+        private @Stable MHInvoker fastInvoker;\n@@ -275,1 +215,1 @@\n-        InstanceAdaptiveMethodAccessor(Method method, MethodHandle target) {\n+        AdaptiveMethodAccessor(Method method, MethodHandle target) {\n@@ -278,1 +218,1 @@\n-        InstanceAdaptiveMethodAccessor(Method method, MethodHandle target, boolean hasCallerParameter) {\n+        AdaptiveMethodAccessor(Method method, MethodHandle target, boolean hasCallerParameter) {\n@@ -283,1 +223,1 @@\n-        MHMethodAccessor mhInvoker() {\n+        MHInvoker mhInvoker() {\n@@ -292,1 +232,1 @@\n-        private MHMethodAccessor slowInvoker() {\n+        private MHInvoker slowInvoker() {\n@@ -295,1 +235,1 @@\n-                fastInvoker = invoker = spinMHMethodAccessor();\n+                fastInvoker = invoker = spinMethodHandleInvoker();\n@@ -301,2 +241,2 @@\n-    static class StaticAdaptiveMethodAccessorWithCaller extends StaticAdaptiveMethodAccessor {\n-        StaticAdaptiveMethodAccessorWithCaller(Method method, MethodHandle target) {\n+    static class AdapterMethodAccessorWithCaller extends AdaptiveMethodAccessor {\n+        AdapterMethodAccessorWithCaller(Method method, MethodHandle target) {\n@@ -305,1 +245,1 @@\n-        StaticAdaptiveMethodAccessorWithCaller(Method method, MethodHandle target, boolean hasCallerParameter) {\n+        AdapterMethodAccessorWithCaller(Method method, MethodHandle target, boolean hasCallerParameter) {\n@@ -314,78 +254,0 @@\n-        @Override\n-        @ForceInline\n-        public Object invoke(Object obj, Object[] args, Class<?> caller) throws InvocationTargetException {\n-            checkArgumentCount(paramCount, args);\n-            try {\n-                return invokeImpl(args, caller);\n-            } catch (ClassCastException|WrongMethodTypeException e) {\n-                if (isIllegalArgument(e))\n-                    throw new IllegalArgumentException(\"argument type mismatch\");\n-                else\n-                    throw new InvocationTargetException(e);\n-            } catch (NullPointerException e) {\n-                if (isIllegalArgument(e)) {\n-                    throw new IllegalArgumentException(e);\n-                } else {\n-                    throw new InvocationTargetException(e);\n-                }\n-            } catch (Throwable e) {\n-                throw new InvocationTargetException(e);\n-            }\n-        }\n-\n-        @Hidden\n-        @ForceInline\n-        Object invokeImpl(Object[] args, Class<?> caller) throws Throwable {\n-            var mhInvoker = mhInvoker();\n-            return switch (paramCount) {\n-                case 0 -> mhInvoker.invoke(caller);\n-                case 1 -> mhInvoker.invoke(args[0], caller);\n-                case 2 -> mhInvoker.invoke(args[0], args[1], caller);\n-                case 3 -> mhInvoker.invoke(args[0], args[1], args[2], caller);\n-                default -> mhInvoker.invoke(args, caller);\n-            };\n-        }\n-\n-        boolean isIllegalArgument(RuntimeException ex) {\n-            return AccessorUtils.isIllegalArgument(StaticAdaptiveMethodAccessorWithCaller.class, ex);\n-        }\n-    }\n-\n-    static class InstanceAdapterMethodAccessorWithCaller extends InstanceAdaptiveMethodAccessor {\n-        InstanceAdapterMethodAccessorWithCaller(Method method, MethodHandle target) {\n-            this(method, target, true);\n-        }\n-        InstanceAdapterMethodAccessorWithCaller(Method method, MethodHandle target, boolean hasCallerParameter) {\n-            super(method, target, hasCallerParameter);\n-        }\n-\n-        @Override\n-        public Object invoke(Object obj, Object[] args) throws InvocationTargetException {\n-            throw new InternalError(\"caller sensitive method invoked without explicit caller: \" + method);\n-        }\n-\n-        @Override\n-        @ForceInline\n-        public Object invoke(Object obj, Object[] args, Class<?> caller) throws InvocationTargetException {\n-            checkReceiver(obj);\n-            checkArgumentCount(paramCount, args);\n-            try {\n-                return invokeImpl(obj, args, caller);\n-            } catch (ClassCastException|WrongMethodTypeException e) {\n-                if (isIllegalArgument(e)) {\n-                    throw new IllegalArgumentException(\"argument type mismatch\");\n-                } else {\n-                    throw new InvocationTargetException(e);\n-                }\n-            } catch (NullPointerException e) {\n-                if (isIllegalArgument(e)) {\n-                    throw new IllegalArgumentException(e);\n-                } else {\n-                    throw new InvocationTargetException(e);\n-                }\n-            } catch (Throwable e) {\n-                throw new InvocationTargetException(e);\n-            }\n-        }\n-\n-\n@@ -404,4 +266,0 @@\n-\n-        boolean isIllegalArgument(RuntimeException ex) {\n-            return AccessorUtils.isIllegalArgument(InstanceAdapterMethodAccessorWithCaller.class, ex);\n-        }\n@@ -422,1 +280,0 @@\n-        private final boolean isStatic;\n@@ -425,1 +282,0 @@\n-            this.isStatic = Modifier.isStatic(method.getModifiers());\n@@ -433,1 +289,1 @@\n-        @Override\n+        @Hidden\n@@ -435,5 +291,1 @@\n-        public Object invoke(Object obj, Object[] args, Class<?> caller) throws InvocationTargetException {\n-            if (!isStatic) {\n-                checkReceiver(obj);\n-            }\n-            checkArgumentCount(paramCount, args);\n+        Object invokeImpl(Object obj, Object[] args, Class<?> caller) throws Throwable {\n@@ -447,25 +299,0 @@\n-            } catch (ClassCastException|WrongMethodTypeException e) {\n-                if (isIllegalArgument(e)) {\n-                    throw new IllegalArgumentException(\"argument type mismatch\");\n-                } else {\n-                    throw new InvocationTargetException(e);\n-                }\n-            } catch (NullPointerException e) {\n-                if (isIllegalArgument(e)) {\n-                    throw new IllegalArgumentException(e);\n-                } else {\n-                    throw new InvocationTargetException(e);\n-                }\n-            } catch (Throwable e) {\n-                throw new InvocationTargetException(e);\n-            }\n-        }\n-\n-        boolean isIllegalArgument(RuntimeException ex) {\n-            return AccessorUtils.isIllegalArgument(CallerSensitiveWithInvoker.class, ex);\n-        }\n-\n-        void checkReceiver(Object o) {\n-            \/\/ NOTE: will throw NullPointerException, as specified, if o is null\n-            if (!method.getDeclaringClass().isAssignableFrom(o.getClass())) {\n-                throw new IllegalArgumentException(\"object is not an instance of declaring class\");\n@@ -593,1 +420,1 @@\n-                            methodType(Object.class, Object.class, Object[].class));\n+                            genericMethodType(1, true));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/DirectMethodAccessorImpl.java","additions":96,"deletions":269,"binary":false,"changes":365,"status":"modified"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.reflect;\n+\n+\/**\n+ * MHInvoker::invoke is the implementation body for\n+ * Method::invoke(Object obj, Object[] args) and Constructor::newInstance\n+ * that invokes the MethodHandle for the reflected method and constructor.\n+ *\n+ * Methods whose have <= 3 formal parameters use the specialized version.\n+ * For example, method with 3 arguments will use:\n+ * MHInvoker::invoke(Object obj, Object arg1, Object arg2, Object arg3)\n+ *\n+ * Caller-sensitive methods with an adapter will use the invoke method\n+ * taking a caller class parameter.\n+ *\n+ * See MethodHandleAccessorFactory for the specialization.\n+ *\/\n+public interface MHInvoker {\n+    \/\/ non-specialized method handle invocation also with trailing caller class parameter\n+    default Object invoke(Object obj, Object[] args) throws Throwable {\n+        throw new UnsupportedOperationException();\n+    }\n+    default Object invoke(Object obj, Object[] args, Class<?> caller) throws Throwable {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    \/\/ specialized version for number of arguments <= 3\n+    default Object invoke(Object obj) throws Throwable {\n+        throw new UnsupportedOperationException();\n+    }\n+    default Object invoke(Object obj, Object arg1) throws Throwable {\n+        throw new UnsupportedOperationException();\n+    }\n+    default Object invoke(Object obj, Object arg1, Object arg2) throws Throwable {\n+        throw new UnsupportedOperationException();\n+    }\n+    default Object invoke(Object obj, Object arg1, Object arg2, Object arg3) throws Throwable {\n+        throw new UnsupportedOperationException();\n+    }\n+    default Object invoke(Object obj, Class<?> caller) throws Throwable {\n+        throw new UnsupportedOperationException();\n+    }\n+    default Object invoke(Object obj, Object arg1, Class<?> caller) throws Throwable {\n+        throw new UnsupportedOperationException();\n+    }\n+    default Object invoke(Object obj, Object arg1, Object arg2, Class<?> caller) throws Throwable {\n+        throw new UnsupportedOperationException();\n+    }\n+    default Object invoke(Object obj, Object arg1, Object arg2, Object arg3, Class<?> caller) throws Throwable {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    \/\/ for Constructor::newInstance\n+    default Object invoke(Object[] args) throws Throwable {\n+        throw new UnsupportedOperationException();\n+    }\n+    default Object invoke() throws Throwable {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+\/\/    No need to define them as they are already covered by the above methods\n+\/\/\n+\/\/    default Object invoke(Object arg1) throws Throwable {\n+\/\/        throw new UnsupportedOperationException();\n+\/\/    }\n+\/\/    default Object invoke(Object arg1, Object arg2) throws Throwable {\n+\/\/        throw new UnsupportedOperationException();\n+\/\/    }\n+\/\/    default Object invoke(Object arg1, Object arg2, Object arg3) throws Throwable {\n+\/\/        throw new UnsupportedOperationException();\n+\/\/    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MHInvoker.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.reflect;\n+\n+import jdk.internal.vm.annotation.Hidden;\n+\n+import java.lang.invoke.MethodHandle;\n+\n+\/**\n+ * Delegate the invocation directly to the target method handle.\n+ *\/\n+final class MHInvokerDelegate implements MHInvoker {\n+    private final MethodHandle target;\n+    MHInvokerDelegate(MethodHandle target) {\n+        this.target = target;\n+    }\n+\n+    \/\/ non-specialized method handle invocation also with trailing caller class parameter\n+    @Hidden @Override public Object invoke(Object obj, Object[] args) throws Throwable {\n+        return target.invokeExact(obj, args);\n+    }\n+    @Hidden @Override public Object invoke(Object obj, Object[] args, Class<?> caller) throws Throwable {\n+        return target.invokeExact(obj, args, caller);\n+    }\n+\n+    \/\/ specialized version for number of arguments <= 3\n+    @Hidden @Override public Object invoke(Object obj) throws Throwable {\n+        return target.invokeExact(obj);\n+    }\n+    @Hidden @Override public Object invoke(Object obj, Object arg1) throws Throwable {\n+        return target.invokeExact(obj, arg1);\n+    }\n+    @Hidden @Override public Object invoke(Object obj, Object arg1, Object arg2) throws Throwable {\n+        return target.invokeExact(obj, arg1, arg2);\n+    }\n+    @Hidden @Override public Object invoke(Object obj, Object arg1, Object arg2, Object arg3) throws Throwable {\n+        return target.invokeExact(obj, arg1, arg2, arg3);\n+    }\n+    @Hidden @Override public Object invoke(Object obj, Class<?> caller) throws Throwable {\n+        return target.invokeExact(obj, caller);\n+    }\n+    @Hidden @Override public Object invoke(Object obj, Object arg1, Class<?> caller) throws Throwable {\n+        return target.invokeExact(obj, arg1, caller);\n+    }\n+    @Hidden @Override public Object invoke(Object obj, Object arg1, Object arg2, Class<?> caller) throws Throwable {\n+        return target.invokeExact(obj, arg1, arg2, caller);\n+    }\n+    @Hidden @Override public Object invoke(Object obj, Object arg1, Object arg2, Object arg3, Class<?> caller) throws Throwable {\n+        return target.invokeExact(obj, arg1, arg2, arg3, caller);\n+    }\n+\n+    \/\/ for Constructor::newInstance\n+    @Hidden @Override public Object invoke(Object[] args) throws Throwable {\n+        return target.invokeExact(args);\n+    }\n+    @Hidden @Override public Object invoke() throws Throwable {\n+        return target.invokeExact();\n+    }\n+\n+\n+\/\/    No need to define them as they are already covered by the above methods\n+\/\/    @Hidden @Override public Object invoke(Object arg1) throws Throwable {\n+\/\/        return target.invokeExact();\n+\/\/    }\n+\/\/    @Hidden @Override public Object invoke(Object arg1, Object arg2) throws Throwable {\n+\/\/        return target.invokeExact();\n+\/\/    }\n+\/\/    @Hidden @Override public Object invoke(Object arg1, Object arg2, Object arg3) throws Throwable {\n+\/\/        return target.invokeExact(arg1, arg2, arg3);\n+\/\/    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MHInvokerDelegate.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"},{"patch":"@@ -1,103 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.reflect;\n-\n-\/**\n- * Defines the invoke method for Method::invoke(Object obj, Object[] args)\n- * and other variants for example taking a caller class parameter and\n- * specialized for the methods whose have <= 3 formal parameters.\n- *\n- * The static methods are also specialized to drop the receiver parameter.\n- *\n- * See MethodHandleAccessorFactory for the specialization.\n- *\/\n-public interface MHMethodAccessor {\n-    \/\/ non-specialized non-static and static methods\n-    default Object invoke(Object obj, Object[] args) throws Throwable {\n-        throw new UnsupportedOperationException();\n-    }\n-    default Object invoke(Object[] args) throws Throwable {\n-        throw new UnsupportedOperationException();\n-    }\n-    default Object invoke(Object obj, Object[] args, Class<?> caller) throws Throwable {\n-        throw new UnsupportedOperationException();\n-    }\n-    default Object invoke(Object[] args, Class<?> caller) throws Throwable {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    \/\/ specialized version for instance method\n-    default Object invoke(Object obj) throws Throwable {\n-        throw new UnsupportedOperationException();\n-    }\n-    default Object invoke(Object obj, Object arg1) throws Throwable {\n-        throw new UnsupportedOperationException();\n-    }\n-    default Object invoke(Object obj, Object arg1, Object arg2) throws Throwable {\n-        throw new UnsupportedOperationException();\n-    }\n-    default Object invoke(Object obj, Object arg1, Object arg2, Object arg3) throws Throwable {\n-        throw new UnsupportedOperationException();\n-    }\n-    default Object invoke(Object obj, Class<?> caller) throws Throwable {\n-        throw new UnsupportedOperationException();\n-    }\n-    default Object invoke(Object obj, Object arg1, Class<?> caller) throws Throwable {\n-        throw new UnsupportedOperationException();\n-    }\n-    default Object invoke(Object obj, Object arg1, Object arg2, Class<?> caller) throws Throwable {\n-        throw new UnsupportedOperationException();\n-    }\n-    default Object invoke(Object obj, Object arg1, Object arg2, Object arg3, Class<?> caller) throws Throwable {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-    \/\/ specialized version for static method\n-    default Object invoke() throws Throwable {\n-        throw new UnsupportedOperationException();\n-    }\n-    default Object invoke(Class<?> caller) throws Throwable {\n-        throw new UnsupportedOperationException();\n-    }\n-\n-\/\/    No need to define them as they are already covered by the instance methods\n-\/\/\n-\/\/    default Object invoke(Object arg1) throws Throwable {\n-\/\/        throw new UnsupportedOperationException();\n-\/\/    }\n-\/\/    default Object invoke(Object arg1, Object arg2) throws Throwable {\n-\/\/        throw new UnsupportedOperationException();\n-\/\/    }\n-\/\/    default Object invoke(Object arg1, Class<?> caller) throws Throwable {\n-\/\/        throw new UnsupportedOperationException();\n-\/\/    }\n-\/\/    default Object invoke(Object arg1, Object arg2, Class<?> caller) throws Throwable {\n-\/\/        throw new UnsupportedOperationException();\n-\/\/    }\n-\/\/    default Object invoke(Object arg1, Object arg2, Object arg3, Class<?> caller) throws Throwable {\n-\/\/        throw new UnsupportedOperationException();\n-\/\/    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MHMethodAccessor.java","additions":0,"deletions":103,"binary":false,"changes":103,"status":"deleted"},{"patch":"@@ -1,104 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.internal.reflect;\n-\n-import jdk.internal.vm.annotation.Hidden;\n-\n-import java.lang.invoke.MethodHandle;\n-\n-\/**\n- * Delegate the invocation directly to the target method handle.\n- *\/\n-final class MHMethodAccessorDelegate implements MHMethodAccessor {\n-    private final MethodHandle target;\n-    MHMethodAccessorDelegate(MethodHandle target) {\n-        this.target = target;\n-    }\n-    \/\/ non-specialized non-static and static methods\n-    @Hidden @Override public Object invoke(Object obj, Object[] args) throws Throwable {\n-        return target.invokeExact(obj, args);\n-    }\n-    @Hidden @Override public Object invoke(Object[] args) throws Throwable {\n-        return target.invokeExact(args);\n-    }\n-    @Hidden @Override public Object invoke(Object obj, Object[] args, Class<?> caller) throws Throwable {\n-        return target.invokeExact(obj, args, caller);\n-    }\n-    @Hidden @Override public Object invoke(Object[] args, Class<?> caller) throws Throwable {\n-        return target.invokeExact(args, caller);\n-    }\n-\n-    \/\/ specialized version for instance method\n-    @Hidden @Override public Object invoke(Object obj) throws Throwable {\n-        return target.invokeExact(obj);\n-    }\n-    @Hidden @Override public Object invoke(Object obj, Object arg1) throws Throwable {\n-        return target.invokeExact(obj, arg1);\n-    }\n-    @Hidden @Override public Object invoke(Object obj, Object arg1, Object arg2) throws Throwable {\n-        return target.invokeExact(obj, arg1, arg2);\n-    }\n-    @Hidden @Override public Object invoke(Object obj, Object arg1, Object arg2, Object arg3) throws Throwable {\n-        return target.invokeExact(obj, arg1, arg2, arg3);\n-    }\n-    @Hidden @Override public Object invoke(Object obj, Class<?> caller) throws Throwable {\n-        return target.invokeExact(obj, caller);\n-    }\n-    @Hidden @Override public Object invoke(Object obj, Object arg1, Class<?> caller) throws Throwable {\n-        return target.invokeExact(obj, arg1, caller);\n-    }\n-    @Hidden @Override public Object invoke(Object obj, Object arg1, Object arg2, Class<?> caller) throws Throwable {\n-        return target.invokeExact(obj, arg1, arg2, caller);\n-    }\n-    @Hidden @Override public Object invoke(Object obj, Object arg1, Object arg2, Object arg3, Class<?> caller) throws Throwable {\n-        return target.invokeExact(obj, arg1, arg2, arg3, caller);\n-    }\n-\n-    \/\/ specialized version for static method\n-    @Hidden @Override public Object invoke() throws Throwable {\n-        return target.invokeExact();\n-    }\n-    @Hidden @Override public Object invoke(Class<?> caller) throws Throwable {\n-        return target.invokeExact(caller);\n-    }\n-\n-    \/\/ the method of the same signature already defined\n-\/\/    @Hidden @Override public Object invoke(Object arg1) throws Throwable {\n-\/\/        return target.invokeExact();\n-\/\/    }\n-\/\/    @Hidden @Override public Object invoke(Object arg1, Object arg2) throws Throwable {\n-\/\/        return target.invokeExact();\n-\/\/    }\n-\/\/    @Hidden @Override public Object invoke(Object arg1, Class<?> caller) throws Throwable {\n-\/\/        return target.invokeExact(arg1, caller);\n-\/\/    }\n-\/\/    @Hidden @Override public Object invoke(Object arg1, Object arg2, Class<?> caller) throws Throwable {\n-\/\/        return target.invokeExact(arg1, arg2, caller);\n-\/\/    }\n-\/\/    @Hidden @Override public Object invoke(Object arg1, Object arg2, Object arg3, Class<?> caller) throws Throwable {\n-\/\/        return target.invokeExact(arg1, arg2, arg3, caller);\n-\/\/    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MHMethodAccessorDelegate.java","additions":0,"deletions":104,"binary":false,"changes":104,"status":"deleted"},{"patch":"@@ -50,0 +50,1 @@\n+import static java.lang.invoke.MethodType.genericMethodType;\n@@ -198,0 +199,4 @@\n+        if (isStatic) {\n+            \/\/ add leading 'this' parameter to static method which is then ignored\n+            target = MethodHandles.dropArguments(target, 0, Object.class);\n+        }\n@@ -204,27 +209,12 @@\n-        if (isStatic) {\n-            return switch (paramCount) {\n-                case 0 -> hasCallerParameter ? methodType(Object.class, Class.class)\n-                                             : methodType(Object.class);\n-                case 1 -> hasCallerParameter ? methodType(Object.class, Object.class, Class.class)\n-                                             : methodType(Object.class, Object.class);\n-                case 2 -> hasCallerParameter ? methodType(Object.class, Object.class, Object.class, Class.class)\n-                                             : methodType(Object.class, Object.class, Object.class);\n-                case 3 -> hasCallerParameter ? methodType(Object.class, Object.class, Object.class, Object.class, Class.class)\n-                                             : methodType(Object.class, Object.class, Object.class, Object.class);\n-                default -> hasCallerParameter ? methodType(Object.class, Object[].class, Class.class)\n-                                              : methodType(Object.class, Object[].class);\n-            };\n-        } else {\n-            return switch (paramCount) {\n-                case 0 -> hasCallerParameter ? methodType(Object.class, Object.class, Class.class)\n-                                             : methodType(Object.class, Object.class);\n-                case 1 -> hasCallerParameter ? methodType(Object.class, Object.class, Object.class, Class.class)\n-                                             : methodType(Object.class, Object.class, Object.class);\n-                case 2 -> hasCallerParameter ? methodType(Object.class, Object.class, Object.class, Object.class, Class.class)\n-                                             : methodType(Object.class, Object.class, Object.class, Object.class);\n-                case 3 -> hasCallerParameter ? methodType(Object.class, Object.class, Object.class, Object.class, Object.class, Class.class)\n-                                             : methodType(Object.class, Object.class, Object.class, Object.class, Object.class);\n-                default -> hasCallerParameter ? methodType(Object.class, Object.class, Object[].class, Class.class)\n-                                              : methodType(Object.class, Object.class, Object[].class);\n-            };\n-        }\n+        return switch (paramCount) {\n+            case 0 -> hasCallerParameter ? methodType(Object.class, Object.class, Class.class)\n+                                         : genericMethodType(1);\n+            case 1 -> hasCallerParameter ? methodType(Object.class, Object.class, Object.class, Class.class)\n+                                         : genericMethodType(2);\n+            case 2 -> hasCallerParameter ? methodType(Object.class, Object.class, Object.class, Object.class, Class.class)\n+                                         : genericMethodType(3);\n+            case 3 -> hasCallerParameter ? methodType(Object.class, Object.class, Object.class, Object.class, Object.class, Class.class)\n+                                         : genericMethodType(4);\n+            default -> hasCallerParameter ? methodType(Object.class, Object.class, Object[].class, Class.class)\n+                                          : genericMethodType(1, true);\n+        };\n@@ -235,5 +225,5 @@\n-            case 0 ->  methodType(Object.class);\n-            case 1 ->  methodType(Object.class, Object.class);\n-            case 2 ->  methodType(Object.class, Object.class, Object.class);\n-            case 3 ->  methodType(Object.class, Object.class, Object.class, Object.class);\n-            default -> methodType(Object.class, Object[].class);\n+            case 0 ->  genericMethodType(0);\n+            case 1 ->  genericMethodType(1);\n+            case 2 ->  genericMethodType(2);\n+            case 3 ->  genericMethodType(3);\n+            default -> genericMethodType(0, true);\n@@ -250,1 +240,1 @@\n-                                : methodType(Object.class, Object.class, Object[].class);\n+                                : genericMethodType(1, true);\n@@ -275,1 +265,1 @@\n-    static MHFieldAccessor newVarHandleAccessor(Field field, VarHandle varHandle) {\n+    static VHInvoker newVarHandleAccessor(Field field, VarHandle varHandle) {\n@@ -282,2 +272,2 @@\n-            ctor = ctor.asType(methodType(MHFieldAccessor.class));\n-            return (MHFieldAccessor) ctor.invokeExact();\n+            ctor = ctor.asType(methodType(VHInvoker.class));\n+            return (VHInvoker) ctor.invokeExact();\n@@ -300,1 +290,1 @@\n-    static MHMethodAccessor newMethodHandleAccessor(Method method, MethodHandle target, boolean hasCallerParameter) {\n+    static MHInvoker newMethodHandleInvoker(Method method, MethodHandle target, boolean hasCallerParameter) {\n@@ -308,2 +298,2 @@\n-            ctor = ctor.asType(methodType(MHMethodAccessor.class));\n-            return (MHMethodAccessor) ctor.invokeExact();\n+            ctor = ctor.asType(methodType(MHInvoker.class));\n+            return (MHInvoker) ctor.invokeExact();\n@@ -321,1 +311,1 @@\n-    static MHMethodAccessor newMethodHandleAccessor(Constructor<?> c, MethodHandle target) {\n+    static MHInvoker newMethodHandleInvoker(Constructor<?> c, MethodHandle target) {\n@@ -329,2 +319,2 @@\n-            ctor = ctor.asType(methodType(MHMethodAccessor.class));\n-            return (MHMethodAccessor) ctor.invokeExact();\n+            ctor = ctor.asType(methodType(MHInvoker.class));\n+            return (MHInvoker) ctor.invokeExact();\n@@ -390,1 +380,1 @@\n-        var bytes = builder.buildFieldAccessor(field);\n+        var bytes = builder.buildVarHandleInvoker(field);\n@@ -396,1 +386,1 @@\n-        var bytes = builder.buildMethodAccessor(method, mtype, hasCallerParameter);\n+        var bytes = builder.buildMethodHandleInvoker(method, mtype, hasCallerParameter);\n@@ -402,1 +392,1 @@\n-        var bytes = builder.buildConstructorAccessor(ctor, mtype);\n+        var bytes = builder.buildMethodHandleInvoker(ctor, mtype);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MethodHandleAccessorFactory.java","additions":35,"deletions":45,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-public interface MHFieldAccessor {\n+public interface VHInvoker {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/VHInvoker.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MHFieldAccessor.java","status":"renamed"},{"patch":"@@ -35,1 +35,1 @@\n-final class MHFieldAccessorDelegate implements MHFieldAccessor {\n+final class VHInvokerDelegate implements VHInvoker {\n@@ -37,1 +37,1 @@\n-    MHFieldAccessorDelegate(VarHandle varHandle) {\n+    VHInvokerDelegate(VarHandle varHandle) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/VHInvokerDelegate.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MHFieldAccessorDelegate.java","status":"renamed"},{"patch":"@@ -34,1 +34,0 @@\n-import java.lang.reflect.Modifier;\n@@ -39,2 +38,2 @@\n-    private @Stable final MHFieldAccessor accessor;\n-    private @Stable MHFieldAccessor fastAccessor;\n+    private @Stable final VHInvoker accessor;\n+    private @Stable VHInvoker fastAccessor;\n@@ -47,1 +46,1 @@\n-        this.accessor = new MHFieldAccessorDelegate(varHandle);\n+        this.accessor = new VHInvokerDelegate(varHandle);\n@@ -59,1 +58,1 @@\n-    final MHFieldAccessor accessor() {\n+    final VHInvoker accessor() {\n@@ -68,1 +67,1 @@\n-    final MHFieldAccessor slowAccessor() {\n+    final VHInvoker slowAccessor() {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/VarHandleFieldAccessorImpl.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -85,1 +85,1 @@\n-                new CallFrame(\"jdk.internal.reflect.DirectMethodAccessorImpl$StaticMethodAccessor\", \"invoke\"), \/\/ non-public class\n+                new CallFrame(\"jdk.internal.reflect.DirectMethodAccessorImpl\", \"invoke\"), \/\/ non-public class\n@@ -139,1 +139,1 @@\n-                new CallFrame(\"jdk.internal.reflect.DirectMethodAccessorImpl$StaticMethodAccessor\", \"invoke\"),\n+                new CallFrame(\"jdk.internal.reflect.DirectMethodAccessorImpl\", \"invoke\"),\n@@ -160,1 +160,1 @@\n-                new CallFrame(\"jdk.internal.reflect.DirectMethodAccessorImpl$StaticMethodAccessor\", \"invoke\"),\n+                new CallFrame(\"jdk.internal.reflect.DirectMethodAccessorImpl\", \"invoke\"),\n@@ -165,1 +165,1 @@\n-                new CallFrame(\"jdk.internal.reflect.DirectMethodAccessorImpl$StaticMethodAccessor\", \"invoke\"),\n+                new CallFrame(\"jdk.internal.reflect.DirectMethodAccessorImpl\", \"invoke\"),\n@@ -191,1 +191,1 @@\n-                new CallFrame(\"jdk.internal.reflect.DirectMethodAccessorImpl$StaticMethodAccessor\", \"invoke\"),\n+                new CallFrame(\"jdk.internal.reflect.DirectMethodAccessorImpl\", \"invoke\"),\n","filename":"test\/jdk\/java\/lang\/StackWalker\/DumpStackTest.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -103,1 +103,1 @@\n-            \"5: java.base\/jdk.internal.reflect.DirectMethodAccessorImpl$StaticMethodAccessor.invoke(DirectMethodAccessorImpl.java:94)\\n\" +\n+            \"5: java.base\/jdk.internal.reflect.DirectMethodAccessorImpl.invoke(DirectMethodAccessorImpl.java:94)\\n\" +\n@@ -140,3 +140,3 @@\n-            \"11: java.base\/jdk.internal.reflect.MHMethodAccessorDelegate.invoke(MHMethodAccessorDelegate.java:56)\\n\" +\n-            \"12: java.base\/jdk.internal.reflect.DirectMethodAccessorImpl$StaticMethodAccessor.invokeImpl(DirectMethodAccessorImpl.java:211)\\n\" +\n-            \"13: java.base\/jdk.internal.reflect.DirectMethodAccessorImpl$StaticMethodAccessor.invoke(DirectMethodAccessorImpl.java:122)\\n\" +\n+            \"11: java.base\/jdk.internal.reflect.MHInvokerDelegate.invoke(MHInvokerDelegate.java:56)\\n\" +\n+            \"12: java.base\/jdk.internal.reflect.DirectMethodAccessorImpl.invokeImpl(DirectMethodAccessorImpl.java:211)\\n\" +\n+            \"13: java.base\/jdk.internal.reflect.DirectMethodAccessorImpl.invoke(DirectMethodAccessorImpl.java:122)\\n\" +\n","filename":"test\/jdk\/java\/lang\/StackWalker\/VerifyStackTrace.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -122,1 +122,4 @@\n-    public void invokeMethods(Blackhole bh) throws ReflectiveOperationException {\n+    public void invokeMethods() throws ReflectiveOperationException {\n+        \/\/ As this is testing warmup, JITs are unlikely to progress to the\n+        \/\/ point where the lack of a blackhole might lead to DCE. Omitting it\n+        \/\/ makes it easier to test this code minimal use of JMH code\n@@ -124,1 +127,1 @@\n-            bh.consume(m.invoke(null, arg));\n+            m.invoke(null, arg);\n@@ -127,0 +130,10 @@\n+\n+    \/**\n+     * Runs invokeMethods once without any JMH interaction, acting as an\n+     * independent startup benchmark.\n+     *\/\n+    public static void main(String ... args) throws Exception {\n+        var coldstart = new ReflectionColdstartBenchmark();\n+        coldstart.setup();\n+        coldstart.invokeMethods();\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/reflect\/ReflectionColdstartBenchmark.java","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"}]}