{"files":[{"patch":"@@ -41,2 +41,67 @@\n- * An @CallerSensitiveAdapter method will be invoked when a caller-sensitive method\n- * is invoked via Method::invoke or MethodHandle passed with the caller class.\n+ * When a caller-sensitive method is invoked via Method::invoke or MethodHandle\n+ * the core reflection and method handle implementation will find if\n+ * an @CallerSensitiveAdapter method for that CSM is present. If present,\n+ * the runtime will invoke the adapter method with the caller class\n+ * argument instead. This special calling sequence ensures that the same caller\n+ * class is passed to a caller-sensitive method via Method::invoke,\n+ * MethodHandle::invokeExact, or a mix of these methods.\n+ *\n+ * For example, CSM::returnCallerClass is a caller-sensitive method\n+ * with an adapter method:\n+ * {@code\n+ * class CSM {\n+ *     @CallerSensitive\n+ *     static Class<?> returnCallerClass() {\n+ *         return returnCallerClass(Reflection.getCallerClass());\n+ *     }\n+ *     @CallerSensitiveAdapter\n+ *     private static Class<?> returnCallerClass(Class<?> caller) {\n+ *         return caller;\n+ *     }\n+ * }\n+ *\n+ * class Test {\n+ *     void test() throws Throwable {\n+ *         \/\/ calling CSM::returnCallerClass via reflection\n+ *         var csm = CSM.class.getMethod(\"returnCallerClass\");\n+ *         \/\/ expect Foo to be the caller class\n+ *         var caller = csm.invoke(null);\n+ *         assert(caller == Test.class);\n+ *     }\n+ *     void test2() throws Throwable {\n+ *         \/\/ method handle for Method::invoke\n+ *         MethodHandle mh = MethodHandles.lookup().findVirtual(Method.class, \"invoke\",\n+ *                                  methodType(Object.class, Object.class, Object[].class));\n+ *         var csm = CSM.class.getMethod(\"returnCallerClass\");\n+ *         \/\/ invoke Method::invoke via method handle and the target method\n+ *         \/\/ being invoked reflectively is CSM::returnCallerClass\n+ *         var caller = mh.invoke(csm, null, null);\n+ *         assert(caller == Test.class);\n+ *     }\n+ * }\n+ * }\n+ *\n+ *\n+ * Both CSM::returnCallerClass and Method::invoke can have an adapter method\n+ * with a caller-class parameter defined. Test::test calls CSM::returnCallerClass\n+ * via Method::invoke which does the stack walking to find the caller's class.\n+ * It will pass the caller's class directly to the adapter method for\n+ * CSM::returnCallerClass.\n+ *\n+ * Similarly, Test::test2 invokes the method handle of Method::invoke to\n+ * call CSM::returnCallerClass reflectively.  In that case, MethodHandle::invokeExact\n+ * uses the lookup class of the Lookup object producing the method handle\n+ * as the caller's class, so no stack walking involved. The lookup class is Test.\n+ * It will invoke the adapter method of Method::invoke with Test as the caller's\n+ * class, which in turn invokes the adapter method of CSM::returnCallerClass\n+ * with Test as the caller. The calling sequence eliminates the need for\n+ * multiple stack walks when a caller-sensitive method is invoked reflectively.\n+ *\n+ * For caller-sensitive methods that require an exact caller class, the adapter\n+ * method must be defined for correctness. {@link java.lang.invoke.MethodHandles#lookup()}\n+ * and {@link ClassLoader#registerAsParallelCapable()} are the only two methods\n+ * in the JDK that need the exact caller class.\n+ *\n+ * On the other hand, for caller-sensitive methods that use the caller's class\n+ * for access checks or security permission checks, i.e., based on its runtime\n+ * package, defining loader, or protection domain, the adapter method is optional.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/CallerSensitiveAdapter.java","additions":67,"deletions":2,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -87,1 +87,8 @@\n-    private static boolean useDirectMethodHandle = true;\n+\n+    \/\/\n+    \/\/ New implementation uses direct invocation of method handles\n+    private static final int METHOD_MH_ACCESSOR      = 0x1;\n+    private static final int FIELD_MH_ACCESSOR       = 0x2;\n+    private static final int ALL_MH_ACCESSORS        = METHOD_MH_ACCESSOR|FIELD_MH_ACCESSOR;\n+\n+    private static int     useDirectMethodHandle = ALL_MH_ACCESSORS;\n@@ -168,1 +175,1 @@\n-        if (useDirectMethodHandle) {\n+        if (useFieldHandleAccessor()) {\n@@ -184,1 +191,1 @@\n-        if (useDirectMethodHandle) {\n+        if (useMethodHandleAccessor()) {\n@@ -228,1 +235,1 @@\n-        if (useDirectMethodHandle) {\n+        if (useMethodHandleAccessor()) {\n@@ -626,2 +633,6 @@\n-    static boolean useDirectMethodHandle() {\n-        return useDirectMethodHandle;\n+    static boolean useMethodHandleAccessor() {\n+        return (useDirectMethodHandle & METHOD_MH_ACCESSOR) == METHOD_MH_ACCESSOR;\n+    }\n+\n+    static boolean useFieldHandleAccessor() {\n+        return (useDirectMethodHandle & FIELD_MH_ACCESSOR) == FIELD_MH_ACCESSOR;\n@@ -629,0 +640,1 @@\n+\n@@ -663,2 +675,8 @@\n-        if (val != null && val.equals(\"false\")) {\n-            useDirectMethodHandle = false;\n+        if (val != null) {\n+            if (val.equals(\"false\")) {\n+                useDirectMethodHandle = 0;\n+            } else if (val.equals(\"methods\")) {\n+                useDirectMethodHandle = METHOD_MH_ACCESSOR;\n+            } else if (val.equals(\"fields\")) {\n+                useDirectMethodHandle = FIELD_MH_ACCESSOR;\n+            }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/ReflectionFactory.java","additions":26,"deletions":8,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -323,1 +323,1 @@\n-        return a + b;\n+        return a; \/\/ a + b;\n@@ -327,1 +327,1 @@\n-        return a + b;\n+        return a; \/\/ a + b;\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/reflect\/ReflectionSpeedBenchmark.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}