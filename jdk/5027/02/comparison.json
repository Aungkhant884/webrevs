{"files":[{"patch":"@@ -119,0 +119,6 @@\n+        \/\/ A selection of trivial and common reflection operations\n+        var instance = HelloClasslist.class.getConstructor().newInstance();\n+        HelloClasslist.class.getMethod(\"staticMethod_V\").invoke(null);\n+        var obj = HelloClasslist.class.getMethod(\"staticMethod_L_L\", Object.class).invoke(null, instance);\n+        HelloClasslist.class.getField(\"field\").get(instance);\n+\n@@ -129,0 +135,4 @@\n+    public HelloClasslist() {}\n+\n+    public String field = \"someValue\";\n+\n@@ -131,0 +141,2 @@\n+    public static Object staticMethod_L_L(Object o) { return o; }\n+\n","filename":"make\/jdk\/src\/classes\/build\/tools\/classlist\/HelloClasslist.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -76,0 +76,1 @@\n+import jdk.internal.reflect.CallerSensitiveAdapter;\n@@ -375,1 +376,1 @@\n-        return forName0(className, true, ClassLoader.getClassLoader(caller), caller);\n+        return forName(className, caller);\n@@ -378,0 +379,6 @@\n+    \/\/ Caller-sensitive adapter method for reflective invocation\n+    @CallerSensitiveAdapter\n+    private static Class<?> forName(String className, Class<?> caller)\n+            throws ClassNotFoundException {\n+        return forName0(className, true, ClassLoader.getClassLoader(caller), caller);\n+    }\n@@ -459,0 +466,14 @@\n+        }\n+        return forName(name, initialize, loader, caller);\n+    }\n+\n+    \/\/ Caller-sensitive adapter method for reflective invocation\n+    @CallerSensitiveAdapter\n+    private static Class<?> forName(String name, boolean initialize, ClassLoader loader, Class<?> caller)\n+            throws ClassNotFoundException\n+    {\n+        @SuppressWarnings(\"removal\")\n+        SecurityManager sm = System.getSecurityManager();\n+        if (sm != null) {\n+            \/\/ Reflective call to get caller class is only needed if a security manager\n+            \/\/ is present.  Avoid the overhead of making this call otherwise.\n@@ -463,1 +484,1 @@\n-                        SecurityConstants.GET_CLASSLOADER_PERMISSION);\n+                            SecurityConstants.GET_CLASSLOADER_PERMISSION);\n@@ -526,0 +547,12 @@\n+        Class<?> caller = null;\n+        SecurityManager sm = System.getSecurityManager();\n+        if (sm != null) {\n+            caller = Reflection.getCallerClass();\n+        }\n+        return forName(module, name, caller);\n+    }\n+\n+    \/\/ Caller-sensitive adapter method for reflective invocation\n+    @SuppressWarnings(\"removal\")\n+    @CallerSensitiveAdapter\n+    private static Class<?> forName(Module module, String name, Class<?> caller) {\n@@ -532,1 +565,0 @@\n-            Class<?> caller = Reflection.getCallerClass();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":35,"deletions":3,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -67,0 +67,1 @@\n+import jdk.internal.reflect.CallerSensitiveAdapter;\n@@ -1618,3 +1619,7 @@\n-        Class<? extends ClassLoader> callerClass =\n-            Reflection.getCallerClass().asSubclass(ClassLoader.class);\n-        return ParallelLoaders.register(callerClass);\n+        return registerAsParallelCapable(Reflection.getCallerClass());\n+    }\n+\n+    \/\/ Caller-sensitive adapter method for reflective invocation\n+    @CallerSensitiveAdapter\n+    private static boolean registerAsParallelCapable(Class<?> caller) {\n+        return ParallelLoaders.register(caller.asSubclass(ClassLoader.class));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ClassLoader.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-import static java.lang.invoke.MethodHandleStatics.CLASSFILE_VERSION;\n+import static java.lang.invoke.MethodHandleStatics.*;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/GenerateJLIClassesHelper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.internal.misc.VM;\n@@ -40,1 +39,0 @@\n-import java.lang.reflect.Constructor;\n@@ -49,0 +47,1 @@\n+import static java.lang.invoke.MethodHandleStatics.CLASSFILE_VERSION;\n@@ -51,0 +50,1 @@\n+import static java.lang.invoke.MethodType.methodType;\n@@ -60,1 +60,0 @@\n-    private static final int CLASSFILE_VERSION = VM.classFileVersion();\n@@ -109,1 +108,1 @@\n-        MethodType classDataMType = MethodType.methodType(Object.class, MethodHandles.Lookup.class, String.class, Class.class);\n+        MethodType classDataMType = methodType(Object.class, MethodHandles.Lookup.class, String.class, Class.class);\n@@ -230,37 +229,7 @@\n-        if (factoryType.parameterCount() == 0) {\n-            \/\/ In the case of a non-capturing lambda, we optimize linkage by pre-computing a single instance,\n-            \/\/ unless we've suppressed eager initialization\n-            if (disableEagerInitialization) {\n-                try {\n-                    return new ConstantCallSite(caller.findStaticGetter(innerClass, LAMBDA_INSTANCE_FIELD,\n-                            factoryType.returnType()));\n-                } catch (ReflectiveOperationException e) {\n-                    throw new LambdaConversionException(\n-                            \"Exception finding \" +  LAMBDA_INSTANCE_FIELD + \" static field\", e);\n-                }\n-            } else {\n-                @SuppressWarnings(\"removal\")\n-                final Constructor<?>[] ctrs = AccessController.doPrivileged(\n-                        new PrivilegedAction<>() {\n-                            @Override\n-                            public Constructor<?>[] run() {\n-                                Constructor<?>[] ctrs = innerClass.getDeclaredConstructors();\n-                                if (ctrs.length == 1) {\n-                                    \/\/ The lambda implementing inner class constructor is private, set\n-                                    \/\/ it accessible (by us) before creating the constant sole instance\n-                                    ctrs[0].setAccessible(true);\n-                                }\n-                                return ctrs;\n-                            }\n-                        });\n-                if (ctrs.length != 1) {\n-                    throw new LambdaConversionException(\"Expected one lambda constructor for \"\n-                            + innerClass.getCanonicalName() + \", got \" + ctrs.length);\n-                }\n-\n-                try {\n-                    Object inst = ctrs[0].newInstance();\n-                    return new ConstantCallSite(MethodHandles.constant(interfaceClass, inst));\n-                } catch (ReflectiveOperationException e) {\n-                    throw new LambdaConversionException(\"Exception instantiating lambda object\", e);\n-                }\n+        if (factoryType.parameterCount() == 0 && disableEagerInitialization) {\n+            try {\n+                return new ConstantCallSite(caller.findStaticGetter(innerClass, LAMBDA_INSTANCE_FIELD,\n+                                                                    factoryType.returnType()));\n+            } catch (ReflectiveOperationException e) {\n+                throw new LambdaConversionException(\n+                        \"Exception finding \" + LAMBDA_INSTANCE_FIELD + \" static field\", e);\n@@ -271,1 +240,7 @@\n-                return new ConstantCallSite(mh.asType(factoryType));\n+                if (factoryType.parameterCount() == 0) {\n+                    \/\/ In the case of a non-capturing lambda, we optimize linkage by pre-computing a single instance\n+                    Object inst = mh.asType(methodType(Object.class)).invokeExact();\n+                    return new ConstantCallSite(MethodHandles.constant(interfaceClass, inst));\n+                } else {\n+                    return new ConstantCallSite(mh.asType(factoryType));\n+                }\n@@ -274,0 +249,2 @@\n+            } catch (Throwable e) {\n+                throw new LambdaConversionException(\"Exception instantiating lambda object\", e);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java","additions":19,"deletions":42,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+import java.util.Set;\n@@ -319,1 +320,1 @@\n-        Class<?> invokerClass = LOOKUP.makeHiddenClassDefiner(className, classFile)\n+        Class<?> invokerClass = LOOKUP.makeHiddenClassDefiner(className, classFile, Set.of())\n@@ -379,1 +380,1 @@\n-        mv.visitMethodInsn(Opcodes.INVOKESTATIC, \"java\/lang\/invoke\/MethodHandleNatives\",\n+        mv.visitMethodInsn(Opcodes.INVOKESTATIC, \"java\/lang\/invoke\/MethodHandles\",\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InvokerBytecodeGenerator.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -45,0 +45,2 @@\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Field;\n@@ -53,0 +55,1 @@\n+import java.util.Set;\n@@ -60,0 +63,1 @@\n+import static java.lang.invoke.MethodHandles.Lookup.ClassOption.NESTMATE;\n@@ -1033,0 +1037,1 @@\n+        private static MethodType REFLECT_INVOKER_MT = MethodType.methodType(Object.class, MethodHandle.class, Object.class, Object[].class);\n@@ -1045,0 +1050,34 @@\n+\n+            MemberName member = mh.internalMemberName();\n+            if (member != null) {\n+                \/\/ Look up the CSM adapter method with the same method name\n+                \/\/ but with an additional caller class parameter.  If present,\n+                \/\/ bind the adapter's method handle with the lookup class as\n+                \/\/ the caller class argument\n+                MemberName csmAdapter = IMPL_LOOKUP.resolveOrNull(member.getReferenceKind(),\n+                        new MemberName(member.getDeclaringClass(),\n+                                       member.getName(),\n+                                       member.getMethodType().appendParameterTypes(Class.class),\n+                                       member.getReferenceKind()));\n+                if (csmAdapter != null) {\n+                    assert !csmAdapter.isCallerSensitive();\n+                    MethodHandle dmh = DirectMethodHandle.make(csmAdapter);\n+                    dmh = MethodHandles.insertArguments(dmh, dmh.type().parameterCount() - 1, hostClass);\n+                    dmh = new WrappedMember(dmh, mh.type(), member, mh.isInvokeSpecial(), hostClass);\n+                    return dmh;\n+                }\n+            }\n+\n+            \/\/ If no adapter method for CSM with an additional Class parameter\n+            \/\/ is present, then inject an invoker class that is the caller\n+            \/\/ invoking the method handle of the CSM\n+            try {\n+                return bindCallerWithInjectedInvoker(mh, hostClass);\n+            } catch (ReflectiveOperationException ex) {\n+                throw uncaughtException(ex);\n+            }\n+        }\n+\n+        private static MethodHandle bindCallerWithInjectedInvoker(MethodHandle mh, Class<?> hostClass)\n+                throws ReflectiveOperationException\n+        {\n@@ -1048,1 +1087,1 @@\n-            MethodHandle bccInvoker = CV_makeInjectedInvoker.get(hostClass);\n+            MethodHandle bccInvoker = CV_makeInjectedInvoker.get(hostClass).invoker();\n@@ -1052,2 +1091,1 @@\n-        private static MethodHandle makeInjectedInvoker(Class<?> targetClass) {\n-            try {\n+        private static Class<?> makeInjectedInvoker(Class<?> targetClass) {\n@@ -1067,2 +1105,2 @@\n-                        .makeHiddenClassDefiner(name, INJECTED_INVOKER_TEMPLATE)\n-                        .defineClass(true);\n+                        .makeHiddenClassDefiner(name, INJECTED_INVOKER_TEMPLATE, Set.of(NESTMATE))\n+                        .defineClass(true, targetClass);\n@@ -1070,4 +1108,1 @@\n-                return IMPL_LOOKUP.findStatic(invokerClass, \"invoke_V\", INVOKER_MT);\n-            } catch (ReflectiveOperationException ex) {\n-                throw uncaughtException(ex);\n-            }\n+                return invokerClass;\n@@ -1076,3 +1111,4 @@\n-        private static ClassValue<MethodHandle> CV_makeInjectedInvoker = new ClassValue<MethodHandle>() {\n-            @Override protected MethodHandle computeValue(Class<?> hostClass) {\n-                return makeInjectedInvoker(hostClass);\n+        private static ClassValue<InjectedInvokerHolder> CV_makeInjectedInvoker = new ClassValue<>() {\n+            @Override\n+            protected InjectedInvokerHolder computeValue(Class<?> hostClass) {\n+                return new InjectedInvokerHolder(makeInjectedInvoker(hostClass));\n@@ -1082,0 +1118,61 @@\n+        \/*\n+         * Returns a method handle of an invoker class injected for reflection\n+         * implementation use with the following signature:\n+         *     reflect_invoke_V(MethodHandle mh, Object target, Object[] args)\n+         *\n+         * Method::invoke on a caller-sensitive method will call\n+         * MethodAccessorImpl::invoke(Object, Object[]) through reflect_invoke_V\n+         *     target.csm(args)\n+         *     NativeMethodAccesssorImpl::invoke(target, args)\n+         *     MethodAccessImpl::invoke(target, args)\n+         *     InjectedInvoker::reflect_invoke_V(vamh, target, args);\n+         *     method::invoke(target, args)\n+         *     p.Foo::m\n+         *\n+         * An injected invoker class is a hidden class which has the same\n+         * defining class loader, runtime package, and protection domain\n+         * as the given caller class.\n+         *\/\n+        static MethodHandle reflectiveInvoker(Class<?> caller) {\n+            return BindCaller.CV_makeInjectedInvoker.get(caller).reflectInvoker();\n+        }\n+\n+        private static final class InjectedInvokerHolder {\n+            private final Class<?> invokerClass;\n+            \/\/ lazily resolved and cached DMH(s) of invoke_V methods\n+            private MethodHandle invoker;\n+            private MethodHandle reflectInvoker;\n+\n+            private InjectedInvokerHolder(Class<?> invokerClass) {\n+                this.invokerClass = invokerClass;\n+            }\n+\n+            private MethodHandle invoker() {\n+                var mh = invoker;\n+                if (mh == null) {\n+                    try {\n+                        invoker = mh = IMPL_LOOKUP.findStatic(invokerClass, \"invoke_V\", INVOKER_MT);\n+                    } catch (Error | RuntimeException ex) {\n+                        throw ex;\n+                    } catch (Throwable ex) {\n+                        throw new InternalError(ex);\n+                    }\n+                }\n+                return mh;\n+            }\n+\n+            private MethodHandle reflectInvoker() {\n+                var mh = reflectInvoker;\n+                if (mh == null) {\n+                    try {\n+                        reflectInvoker = mh = IMPL_LOOKUP.findStatic(invokerClass, \"reflect_invoke_V\", REFLECT_INVOKER_MT);\n+                    } catch (Error | RuntimeException ex) {\n+                        throw ex;\n+                    } catch (Throwable ex) {\n+                        throw new InternalError(ex);\n+                    }\n+                }\n+                return mh;\n+            }\n+        }\n+\n@@ -1118,0 +1215,2 @@\n+            } catch (Error|RuntimeException ex) {\n+                throw ex;\n@@ -1154,0 +1253,1 @@\n+            \/\/     \/* this is used to wrap DMH(s) of caller-sensitive methods *\/\n@@ -1158,0 +1258,6 @@\n+            \/\/     \/* this is used in caller-sensitive reflective method accessor *\/\n+            \/\/     @Hidden\n+            \/\/     static Object reflect_invoke_V(MethodHandle vamh, Object target, Object[] args) throws Throwable {\n+            \/\/        return vamh.invokeExact(target, args);\n+            \/\/     }\n+            \/\/ }\n@@ -1160,0 +1266,16 @@\n+            {\n+                var mv = cw.visitMethod(ACC_STATIC, \"invoke_V\",\n+                        \"(Ljava\/lang\/invoke\/MethodHandle;[Ljava\/lang\/Object;)Ljava\/lang\/Object;\",\n+                        null, null);\n+\n+                mv.visitCode();\n+                mv.visitVarInsn(ALOAD, 0);\n+                mv.visitVarInsn(ALOAD, 1);\n+                mv.visitMethodInsn(INVOKEVIRTUAL, \"java\/lang\/invoke\/MethodHandle\", \"invokeExact\",\n+                        \"([Ljava\/lang\/Object;)Ljava\/lang\/Object;\", false);\n+                mv.visitInsn(ARETURN);\n+                mv.visitMaxs(2, 2);\n+                mv.visitEnd();\n+\n+                cw.visitEnd();\n+            }\n@@ -1161,14 +1283,14 @@\n-            MethodVisitor mv = cw.visitMethod(ACC_STATIC, \"invoke_V\",\n-                          \"(Ljava\/lang\/invoke\/MethodHandle;[Ljava\/lang\/Object;)Ljava\/lang\/Object;\",\n-                          null, null);\n-\n-            mv.visitCode();\n-            mv.visitVarInsn(ALOAD, 0);\n-            mv.visitVarInsn(ALOAD, 1);\n-            mv.visitMethodInsn(INVOKEVIRTUAL, \"java\/lang\/invoke\/MethodHandle\", \"invokeExact\",\n-                               \"([Ljava\/lang\/Object;)Ljava\/lang\/Object;\", false);\n-            mv.visitInsn(ARETURN);\n-            mv.visitMaxs(2, 2);\n-            mv.visitEnd();\n-\n-            cw.visitEnd();\n+            {\n+                var mv = cw.visitMethod(ACC_STATIC, \"reflect_invoke_V\",\n+                        \"(Ljava\/lang\/invoke\/MethodHandle;Ljava\/lang\/Object;[Ljava\/lang\/Object;)Ljava\/lang\/Object;\",\n+                        null, null);\n+                mv.visitCode();\n+                mv.visitVarInsn(ALOAD, 0);\n+                mv.visitVarInsn(ALOAD, 1);\n+                mv.visitVarInsn(ALOAD, 2);\n+                mv.visitMethodInsn(INVOKEVIRTUAL, \"java\/lang\/invoke\/MethodHandle\", \"invokeExact\",\n+                        \"(Ljava\/lang\/Object;[Ljava\/lang\/Object;)Ljava\/lang\/Object;\", false);\n+                mv.visitInsn(ARETURN);\n+                mv.visitMaxs(3, 3);\n+                mv.visitEnd();\n+            }\n@@ -1506,0 +1628,42 @@\n+\n+\n+            @Override\n+            public MethodHandle unreflectConstructor(Constructor<?> ctor) throws IllegalAccessException {\n+                return IMPL_LOOKUP.unreflectConstructor(ctor);\n+            }\n+\n+            @Override\n+            public VarHandle unreflectVarHandle(Field field) throws IllegalAccessException {\n+                return IMPL_LOOKUP.unreflectVarHandle(field);\n+            }\n+\n+            @Override\n+            public MethodHandle findVirtual(Class<?> defc, String name, MethodType type) throws IllegalAccessException {\n+                try {\n+                    return IMPL_LOOKUP.findVirtual(defc, name, type);\n+                } catch (NoSuchMethodException e) {\n+                    return null;\n+                }\n+            }\n+\n+            @Override\n+            public MethodHandle findStatic(Class<?> defc, String name, MethodType type) throws IllegalAccessException {\n+                try {\n+                    return IMPL_LOOKUP.findStatic(defc, name, type);\n+                } catch (NoSuchMethodException e) {\n+                    return null;\n+                }\n+            }\n+\n+            @Override\n+            public MethodHandle reflectiveInvoker(Class<?> caller) {\n+                Objects.requireNonNull(caller);\n+                return BindCaller.reflectiveInvoker(caller);\n+            }\n+\n+            @Override\n+            public Lookup defineHiddenClassWithClassData(Lookup caller, String name, byte[] bytes, Object classData, boolean initialize) {\n+                \/\/ skip name and access flags validation\n+                return caller.makeHiddenClassDefiner(name, bytes, Set.of()).defineClassAsLookup(initialize, classData);\n+            }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":190,"deletions":26,"binary":false,"changes":216,"status":"modified"},{"patch":"@@ -28,2 +28,1 @@\n-import jdk.internal.access.JavaLangAccess;\n-import jdk.internal.access.SharedSecrets;\n+import jdk.internal.misc.VM;\n@@ -38,1 +37,0 @@\n-import static java.lang.invoke.MethodHandleStatics.UNSAFE;\n@@ -251,0 +249,1 @@\n+        VM.setJavaLangInvokeInited();\n@@ -670,2 +669,1 @@\n-        return mem.getName().equals(\"getContextClassLoader\") &&\n-            canBeCalledVirtual(mem, java.lang.Thread.class);\n+        return mem.getName().equals(\"getContextClassLoader\") && canBeCalledVirtual(mem, java.lang.Thread.class);\n@@ -681,12 +679,0 @@\n-\n-    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n-    \/*\n-     * Returns the class data set by the VM in the Class::classData field.\n-     *\n-     * This is also invoked by LambdaForms as it cannot use condy via\n-     * MethodHandles.classData due to bootstrapping issue.\n-     *\/\n-    static Object classData(Class<?> c) {\n-        UNSAFE.ensureClassInitialized(c);\n-        return JLA.classData(c);\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleNatives.java","additions":3,"deletions":17,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import jdk.internal.reflect.CallerSensitiveAdapter;\n@@ -66,0 +67,1 @@\n+import static java.lang.invoke.MethodHandleStatics.UNSAFE;\n@@ -120,2 +122,4 @@\n-     * This reflected$lookup method is the alternate implementation of\n-     * the lookup method when being invoked by reflection.\n+     * This lookup method is the alternate implementation of\n+     * the lookup method with a leading caller class argument which is\n+     * non-caller-sensitive.  This method is only invoked by reflection\n+     * and method handle.\n@@ -123,3 +127,2 @@\n-    @CallerSensitive\n-    private static Lookup reflected$lookup() {\n-        Class<?> caller = Reflection.getCallerClass();\n+    @CallerSensitiveAdapter\n+    private static Lookup lookup(Class<?> caller) {\n@@ -332,1 +335,1 @@\n-         Object classdata = MethodHandleNatives.classData(caller.lookupClass());\n+         Object classdata = classData(caller.lookupClass());\n@@ -344,0 +347,11 @@\n+    \/*\n+     * Returns the class data set by the VM in the Class::classData field.\n+     *\n+     * This is also invoked by LambdaForms as it cannot use condy via\n+     * MethodHandles::classData due to bootstrapping issue.\n+     *\/\n+    static Object classData(Class<?> c) {\n+        UNSAFE.ensureClassInitialized(c);\n+        return SharedSecrets.getJavaLangAccess().classData(c);\n+    }\n+\n@@ -2362,1 +2376,1 @@\n-         * from the given bytes.  No package name check on the given name.\n+         * from the given bytes and the given options.  No package name check on the given name.\n@@ -2366,1 +2380,2 @@\n-         * @return ClassDefiner that defines a hidden class of the given bytes.\n+         * @param options class options\n+         * @return ClassDefiner that defines a hidden class of the given bytes and options.\n@@ -2368,1 +2383,1 @@\n-        ClassDefiner makeHiddenClassDefiner(String name, byte[] bytes) {\n+        ClassDefiner makeHiddenClassDefiner(String name, byte[] bytes, Set<ClassOption> options) {\n@@ -2370,1 +2385,1 @@\n-            return makeHiddenClassDefiner(ClassFile.newInstanceNoCheck(name, bytes), Set.of(), false);\n+            return makeHiddenClassDefiner(ClassFile.newInstanceNoCheck(name, bytes), options, false);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":25,"deletions":10,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.misc.VM;\n@@ -491,3 +492,0 @@\n-        if ((clazz.getModifiers() & Modifier.ENUM) != 0)\n-            throw new IllegalArgumentException(\"Cannot reflectively create enum objects\");\n-\n@@ -533,0 +531,1 @@\n+\n@@ -541,0 +540,4 @@\n+            \/\/ Ensure the declaring class is not an Enum class.\n+            if ((clazz.getModifiers() & Modifier.ENUM) != 0)\n+                throw new IllegalArgumentException(\"Cannot reflectively create enum objects\");\n+\n@@ -542,1 +545,3 @@\n-            setConstructorAccessor(tmp);\n+            \/\/ set the constructor accessor only if it's not using native implementation\n+            if (VM.isJavaLangInvokeInited())\n+                setConstructorAccessor(tmp);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Constructor.java","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.misc.VM;\n@@ -30,0 +31,1 @@\n+import jdk.internal.reflect.CallerSensitiveAdapter;\n@@ -555,2 +557,1 @@\n-        throws IllegalAccessException, IllegalArgumentException,\n-           InvocationTargetException\n+        throws IllegalAccessException, InvocationTargetException\n@@ -558,0 +559,36 @@\n+        boolean callerSensitive = isCallerSensitive();\n+        Class<?> caller = null;\n+        if (!override || callerSensitive) {\n+            caller = Reflection.getCallerClass();\n+        }\n+\n+        \/\/ Reflection::getCallerClass filters all subclasses of\n+        \/\/ jdk.internal.reflect.MethodAccessorImpl and Method::invoke(Object, Object[])\n+        \/\/ Should not call Method::invoke(Object, Object[], Class) here\n+        if (!override) {\n+            checkAccess(caller, clazz,\n+                    Modifier.isStatic(modifiers) ? null : obj.getClass(),\n+                    modifiers);\n+        }\n+        MethodAccessor ma = methodAccessor;             \/\/ read volatile\n+        if (ma == null) {\n+            ma = acquireMethodAccessor();\n+        }\n+\n+        return callerSensitive ? ma.invoke(obj, args, caller) : ma.invoke(obj, args);\n+    }\n+\n+    \/**\n+     * This is to support MethodHandle calling caller-sensitive Method::invoke\n+     * that may invoke a caller-sensitive method in order to get the original caller\n+     * class (not the injected invoker).\n+     *\n+     * If this adapter is not presented, MethodHandle invoking Method::invoke\n+     * will get an invoker class, a hidden nestmate of the original caller class,\n+     * that becomes the caller class invoking Method::invoke.\n+     *\/\n+    @CallerSensitiveAdapter\n+    private Object invoke(Object obj, Object[] args, Class<?> caller)\n+            throws IllegalAccessException, InvocationTargetException\n+    {\n+        boolean callerSensitive = isCallerSensitive();\n@@ -559,1 +596,0 @@\n-            Class<?> caller = Reflection.getCallerClass();\n@@ -568,1 +604,11 @@\n-        return ma.invoke(obj, args);\n+\n+        return callerSensitive ? ma.invoke(obj, args, caller) : ma.invoke(obj, args);\n+    }\n+\n+    private Boolean callerSensitive;       \/\/ lazily initialize\n+    private boolean isCallerSensitive() {\n+        Boolean cs = callerSensitive;\n+        if (cs == null) {\n+            callerSensitive = cs = Reflection.isCallerSensitive(this);\n+        }\n+        return cs;\n@@ -674,2 +720,4 @@\n-            tmp = reflectionFactory.newMethodAccessor(this);\n-            setMethodAccessor(tmp);\n+            tmp = reflectionFactory.newMethodAccessor(this, isCallerSensitive());\n+            \/\/ set the method accessor only if it's not using native implementation\n+            if (VM.isJavaLangInvokeInited())\n+                setMethodAccessor(tmp);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Method.java","additions":54,"deletions":6,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.lang.invoke.MethodHandles.Lookup;\n@@ -33,0 +34,2 @@\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Field;\n@@ -142,0 +145,41 @@\n+\n+    \/**\n+     * Produces a method handle unreflecting from a {@code Constructor} with\n+     * the trusted lookup\n+     *\/\n+    MethodHandle unreflectConstructor(Constructor<?> ctor) throws IllegalAccessException;\n+\n+    \/**\n+     * Produces a var handle unreflecting from a {@code Field} with the trusted lookup.\n+     * @param field\n+     * @return\n+     * @throws IllegalAccessException\n+     *\/\n+    VarHandle unreflectVarHandle(Field field) throws IllegalAccessException;\n+\n+    \/**\n+     * Produces a method handle of a virtual method with the trusted lookup.\n+     *\/\n+    MethodHandle findVirtual(Class<?> defc, String name, MethodType type) throws IllegalAccessException;\n+\n+    \/**\n+     * Produces a method handle of a static method with the trusted lookup.\n+     *\/\n+    MethodHandle findStatic(Class<?> defc, String name, MethodType type) throws IllegalAccessException;\n+\n+    \/**\n+     * Returns a method handle of an invoker class injected for core reflection\n+     * implementation with the following signature:\n+     *     reflect_invoke_V(MethodHandle mh, Object target, Object[] args)\n+     *\n+     * The invoker class is a hidden class which has the same\n+     * defining class loader, runtime package, and protection domain\n+     * as the given caller class.\n+     *\/\n+    MethodHandle reflectiveInvoker(Class<?> caller);\n+\n+    \/**\n+     * Defines a hidden class of the given name and bytes with class data.\n+     * The given bytes is trusted.\n+     *\/\n+    Lookup defineHiddenClassWithClassData(Lookup caller, String name, byte[] bytes, Object classData, boolean initialize);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangInvokeAccess.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -54,1 +54,0 @@\n-    private static final MethodHandles.Lookup lookup = MethodHandles.lookup();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/SharedSecrets.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.text.NumberFormat;\n@@ -37,1 +36,1 @@\n-\n+import jdk.internal.vm.annotation.Stable;\n@@ -94,1 +93,13 @@\n-        return VM.initLevel() >= MODULE_SYSTEM_INITED;\n+        return initLevel >= MODULE_SYSTEM_INITED;\n+    }\n+\n+    private static @Stable boolean javaLangInvokeInited;\n+    public static void setJavaLangInvokeInited() {\n+        if (javaLangInvokeInited) {\n+            throw new InternalError(\"java.lang.invoke already inited\");\n+        }\n+        javaLangInvokeInited = true;\n+    }\n+\n+    public static boolean isJavaLangInvokeInited() {\n+        return javaLangInvokeInited;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/VM.java","additions":14,"deletions":3,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.reflect;\n+\n+import java.util.Set;\n+\n+\/**\n+ * Utility methods used by DirectMethodAccessorImpl and DirectConstructorImpl\n+ *\/\n+public class AccessorUtils {\n+    static boolean isIllegalArgument(Class<?> accessorType, RuntimeException e) {\n+        StackTraceElement[] stackTrace = e.getStackTrace();\n+        if (stackTrace.length == 0) {\n+            return false;       \/\/ would this happen?\n+        }\n+\n+        int i = 0;\n+        StackTraceElement frame = stackTrace[0];\n+        if ((frame.getClassName().equals(\"java.lang.Class\") && frame.getMethodName().equals(\"cast\"))\n+                || (frame.getClassName().equals(\"java.util.Objects\") && frame.getMethodName().equals(\"requiresNonNull\"))) {\n+            \/\/ skip Class::cast and Objects::requireNonNull from top frame\n+            i++;\n+        }\n+        for (; i < stackTrace.length; i++) {\n+            frame = stackTrace[i];\n+            String cname = frame.getClassName();\n+            if (cname.equals(accessorType.getName())) {\n+                \/\/ it's illegal argument if this exception is thrown from implClass\n+                return true;\n+            }\n+            if (frame.getModuleName() == null || !frame.getModuleName().equals(\"java.base\")) {\n+                \/\/ if this exception is thrown from a unnamed module or non java.base module\n+                \/\/ it's not IAE as it's thrown from the reflective method\n+                return false;\n+            }\n+            int index = cname.lastIndexOf(\".\");\n+            String pn = index > 0 ? cname.substring(0, index) : \"\";\n+            if (!IMPL_PACKAGES.contains(pn)) {\n+                \/\/ exception thrown from java.base but not from reflection internals\n+                return false;\n+            }\n+            if ((accessorType == DirectMethodAccessorImpl.class\n+                    && cname.startsWith(DirectConstructorAccessorImpl.class.getName()))\n+                || (accessorType == DirectConstructorAccessorImpl.class &&\n+                        cname.startsWith(DirectMethodAccessorImpl.class.getName()))) {\n+                \/\/ thrown from another reflection accessor impl class\n+                return false;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private static final Set<String> IMPL_PACKAGES = Set.of(\n+            \"java.lang.reflect\",\n+            \"java.lang.invoke\",\n+            \"jdk.internal.reflect\",\n+            \"sun.invoke.util\"\n+    );\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/AccessorUtils.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.reflect;\n+\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+import static java.lang.annotation.ElementType.METHOD;\n+\n+\/**\n+ * A method annotated @CallerSensitiveAdapter is an adapter method corresponding\n+ * to a caller-sensitive method, which is annotated with @CallerSensitive.\n+ *\n+ * A caller-sensitive adapter is private and has the same name as its\n+ * corresponding caller-sensitive method with a trailing caller class parameter.\n+ *\n+ * An @CallerSensitiveAdapter method will be invoked when a caller-sensitive method\n+ * is invoked via Method::invoke or MethodHandle passed with the caller class.\n+ *\/\n+@Retention(RetentionPolicy.CLASS)\n+@Target({METHOD})\n+public @interface CallerSensitiveAdapter {\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/CallerSensitiveAdapter.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,266 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.reflect;\n+\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import jdk.internal.org.objectweb.asm.ClassWriter;\n+import jdk.internal.org.objectweb.asm.ConstantDynamic;\n+import jdk.internal.org.objectweb.asm.Handle;\n+import jdk.internal.org.objectweb.asm.MethodVisitor;\n+import jdk.internal.misc.VM;\n+\n+import static jdk.internal.org.objectweb.asm.Opcodes.*;\n+import static java.lang.invoke.MethodType.*;\n+\n+public class ClassByteBuilder extends ClassWriter {\n+    private static final int CLASSFILE_VERSION = VM.classFileVersion();\n+    private static final String OBJECT_CLS = \"java\/lang\/Object\";\n+    private static final String MHS_CLS = \"java\/lang\/invoke\/MethodHandles\";\n+    private static final String MH_CLS = \"java\/lang\/invoke\/MethodHandle\";\n+    private static final String VH_CLS = \"java\/lang\/invoke\/VarHandle\";\n+    private static final String CLASS_DATA_BSM_DESCR =\n+            \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/Class;)Ljava\/lang\/Object;\";\n+    private static final String[] MH_INVOKER_INTF = new String[] { \"jdk\/internal\/reflect\/MHInvoker\" };\n+    private static final String[] VH_INVOKER_INTF = new String[] {  \"jdk\/internal\/reflect\/VHInvoker\" };\n+    private static final String[] THROWS_THROWABLE = new String[] { \"java\/lang\/Throwable\" };\n+\n+    private final String classname;\n+    private final ConstantDynamic classDataCondy;\n+\n+    \/**\n+     * A builder to generate a class file to access class data\n+     *\/\n+    public ClassByteBuilder(String classname, Class<?> classDataType) {\n+        super(ClassWriter.COMPUTE_FRAMES);\n+        this.classname = classname;\n+        Handle bsm = new Handle(H_INVOKESTATIC, MHS_CLS, \"classData\",\n+                                CLASS_DATA_BSM_DESCR,\n+                                false);\n+        this.classDataCondy = new ConstantDynamic(\"_\", classDataType.descriptorString(), bsm);\n+    }\n+\n+    public byte[] buildVarHandleInvoker(Field field) {\n+        visit(CLASSFILE_VERSION, ACC_FINAL, classname, null, OBJECT_CLS, VH_INVOKER_INTF);\n+        addConstructor();\n+\n+        Class<?> type = field.getType().isPrimitive() ? field.getType() : Object.class;\n+        var isStatic = Modifier.isStatic(field.getModifiers());\n+        var isVolatile = Modifier.isVolatile(field.getModifiers());\n+        addGetter(type, isStatic, isVolatile);\n+        addSetter(type, isStatic, isVolatile);\n+        visitEnd();\n+        return toByteArray();\n+    }\n+\n+    public byte[] buildMethodHandleInvoker(Method method, MethodType mtype, boolean hasCallerParameter) {\n+        visit(CLASSFILE_VERSION, ACC_FINAL, classname, null, OBJECT_CLS, MH_INVOKER_INTF);\n+        addConstructor();\n+\n+        var isStatic = Modifier.isStatic(method.getModifiers());\n+        \/\/ check if this method type is specialized form or not\n+        int lastArgIndex = mtype.parameterCount() - 1 - (hasCallerParameter ? 1 : 0);\n+        if (lastArgIndex >= 0 && mtype.parameterType(lastArgIndex) == Object[].class) {\n+            addInvokeMethod(mtype);\n+        } else {\n+            addSpecializedInvokeMethod(mtype, true, hasCallerParameter, method.getParameterCount());\n+        }\n+        visitEnd();\n+        return toByteArray();\n+    }\n+\n+    public byte[] buildMethodHandleInvoker(Constructor<?> ctor, MethodType mtype) {\n+        visit(CLASSFILE_VERSION, ACC_FINAL, classname, null, OBJECT_CLS, MH_INVOKER_INTF);\n+        addConstructor();\n+\n+        int paramCount = ctor.getParameterCount();\n+        if (mtype.lastParameterType() == Object[].class) {\n+            addInvokeMethod(mtype);\n+        } else {\n+            addSpecializedInvokeMethod(mtype, false \/* no receiver *\/, false, paramCount);\n+        }\n+        visitEnd();\n+        return toByteArray();\n+    }\n+\n+    private void addConstructor() {\n+        MethodVisitor mv = visitMethod(ACC_PUBLIC, \"<init>\", \"()V\", null, null);\n+        mv.visitCode();\n+        mv.visitVarInsn(ALOAD, 0);\n+        mv.visitMethodInsn(INVOKESPECIAL, OBJECT_CLS, \"<init>\", \"()V\", false);\n+        mv.visitInsn(RETURN);\n+        mv.visitMaxs(0, 0);\n+        mv.visitEnd();\n+    }\n+\n+    private void addGetter(Class<?> type, boolean isStatic, boolean isVolatile) {\n+        MethodType mtype = isStatic ? methodType(type) : methodType(type, Object.class);\n+        MethodVisitor mv = visitMethod(ACC_PUBLIC,\n+                                       methodName(\"get\", type),\n+                                       mtype.descriptorString(), null, THROWS_THROWABLE);\n+        mv.visitCode();\n+        mv.visitLdcInsn(classDataCondy);    \/\/ load VarHandle constant\n+        mv.visitTypeInsn(CHECKCAST, VH_CLS);\n+        if (!isStatic) {\n+            mv.visitVarInsn(ALOAD, 1);\n+        }\n+        mv.visitMethodInsn(INVOKEVIRTUAL, VH_CLS, isVolatile ? \"getVolatile\" : \"get\",\n+                           mtype.descriptorString(), false);\n+        emitReturn(mv, type);\n+        mv.visitMaxs(0, 0);\n+        mv.visitEnd();\n+    }\n+\n+    private void addSetter(Class<?> type, boolean isStatic, boolean isVolatile) {\n+        MethodType mtype = isStatic ? methodType(void.class, type) : methodType(void.class, Object.class, type);\n+        MethodVisitor mv = visitMethod(ACC_PUBLIC,\n+                                       methodName(\"set\", type),\n+                                       mtype.descriptorString(), null, THROWS_THROWABLE);\n+        mv.visitCode();\n+        mv.visitLdcInsn(classDataCondy);    \/\/ load VarHandle constant\n+        mv.visitTypeInsn(CHECKCAST, VH_CLS);\n+        if (isStatic) {\n+            emitLoad(mv, type, 1);\n+        } else {\n+            mv.visitVarInsn(ALOAD, 1);\n+            emitLoad(mv, type, 2);\n+        }\n+        mv.visitMethodInsn(INVOKEVIRTUAL, VH_CLS, isVolatile ? \"setVolatile\" : \"set\",\n+                           mtype.descriptorString(), false);\n+        mv.visitInsn(RETURN);\n+        mv.visitMaxs(0, 0);\n+        mv.visitEnd();\n+    }\n+\n+    private void addSpecializedInvokeMethod(MethodType mtype, boolean hasReceiver, boolean hasCallerParameter, int paramCount) {\n+        assert mtype.lastParameterType() != Object[].class;\n+        MethodVisitor mv = visitMethod(ACC_PUBLIC, \"invoke\",\n+                                       mtype.descriptorString(), null, THROWS_THROWABLE);\n+        mv.visitCode();\n+        mv.visitLdcInsn(classDataCondy);    \/\/ load VarHandle constant\n+        mv.visitTypeInsn(CHECKCAST, MH_CLS);\n+        int slot = 1;   \/\/ first argument\n+        if (hasReceiver) {\n+            mv.visitVarInsn(ALOAD, slot++);\n+        }\n+        for (int i=0; i < paramCount; i++) {\n+            mv.visitVarInsn(ALOAD, slot++);\n+        }\n+        if (hasCallerParameter) {\n+            mv.visitVarInsn(ALOAD, slot++);\n+        }\n+        mv.visitMethodInsn(INVOKEVIRTUAL, MH_CLS, \"invokeExact\",\n+                           mtype.descriptorString(), false);\n+        mv.visitInsn(ARETURN);\n+        mv.visitMaxs(0, 0);\n+        mv.visitEnd();\n+    }\n+\n+    private void addInvokeMethod(MethodType mtype) {\n+        MethodVisitor mv = visitMethod(ACC_PUBLIC, \"invoke\",\n+                                       mtype.descriptorString(), null, THROWS_THROWABLE);\n+        mv.visitCode();\n+        mv.visitLdcInsn(classDataCondy);    \/\/ load VarHandle constant\n+        mv.visitTypeInsn(CHECKCAST, MH_CLS);\n+        for (int slot=1; slot <= mtype.parameterCount(); slot++) {\n+            mv.visitVarInsn(ALOAD, slot);\n+        }\n+        mv.visitMethodInsn(INVOKEVIRTUAL, MH_CLS, \"invokeExact\",\n+                           mtype.descriptorString(), false);\n+        mv.visitInsn(ARETURN);\n+        mv.visitMaxs(0, 0);\n+        mv.visitEnd();\n+    }\n+\n+    private static String methodName(String prefix, Class<?> type) {\n+        if (type == Boolean.TYPE) {\n+            return prefix + \"Boolean\";\n+        } else if (type == Byte.TYPE) {\n+            return prefix + \"Byte\";\n+        } else if (type == Short.TYPE) {\n+            return prefix + \"Short\";\n+        } else if (type == Character.TYPE) {\n+            return prefix + \"Char\";\n+        } else if (type == Integer.TYPE) {\n+            return prefix + \"Int\";\n+        } else if (type == Long.TYPE) {\n+            return prefix + \"Long\";\n+        } else if (type == Float.TYPE) {\n+            return prefix + \"Float\";\n+        } else if (type == Double.TYPE) {\n+            return prefix + \"Double\";\n+        } else {\n+            return prefix;\n+        }\n+    }\n+\n+    private static void emitLoad(MethodVisitor mv, Class<?> type, int slot) {\n+        if (type == Boolean.TYPE) {\n+            mv.visitVarInsn(ILOAD, slot);\n+        } else if (type == Byte.TYPE) {\n+            mv.visitVarInsn(ILOAD, slot);\n+        } else if (type == Character.TYPE) {\n+            mv.visitVarInsn(ILOAD, slot);\n+        } else if (type == Short.TYPE) {\n+            mv.visitVarInsn(ILOAD, slot);\n+        } else if (type == Integer.TYPE) {\n+            mv.visitVarInsn(ILOAD, slot);\n+        } else if (type == Long.TYPE) {\n+            mv.visitVarInsn(LLOAD, slot);\n+        } else if (type == Float.TYPE) {\n+            mv.visitVarInsn(FLOAD, slot);\n+        } else if (type == Double.TYPE) {\n+            mv.visitVarInsn(DLOAD, slot);\n+        } else {\n+            mv.visitVarInsn(ALOAD, slot);\n+        }\n+    }\n+\n+    private static void emitReturn(MethodVisitor mv, Class<?> type) {\n+        if (type == Boolean.TYPE) {\n+            mv.visitInsn(IRETURN);\n+        } else if (type == Byte.TYPE) {\n+            mv.visitInsn(IRETURN);\n+        } else if (type == Short.TYPE) {\n+            mv.visitInsn(IRETURN);\n+        } else if (type == Character.TYPE) {\n+            mv.visitInsn(IRETURN);\n+        } else if (type == Integer.TYPE) {\n+            mv.visitInsn(IRETURN);\n+        } else if (type == Long.TYPE) {\n+            mv.visitInsn(LRETURN);\n+        } else if (type == Float.TYPE) {\n+            mv.visitInsn(FRETURN);\n+        } else if (type == Double.TYPE) {\n+            mv.visitInsn(DRETURN);\n+        } else {\n+            mv.visitInsn(ARETURN);\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/ClassByteBuilder.java","additions":266,"deletions":0,"binary":false,"changes":266,"status":"added"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.reflect;\n+\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.annotation.Hidden;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+\n+\/**\n+ * MethodAccessor adapter for caller-sensitive methods which have\n+ * an alternate non-CSM method with the same method name but an additional\n+ * caller class argument.\n+ *\n+ * When a caller-sensitive method is called,\n+ * Method::invoke(Object target, Object[] args, Class<?> caller) will\n+ * be invoked with the caller class.  If an adapter is present,\n+ * the adapter method with the caller class parameter will be called\n+ * instead.\n+ *\/\n+class CsMethodAccessorAdapter extends MethodAccessorImpl {\n+    private final Method csmAdapter;\n+    private final MethodAccessor accessor;\n+\n+    CsMethodAccessorAdapter(Method method, Method csmAdapter, MethodAccessor accessor) {\n+        assert Reflection.isCallerSensitive(method) && !Reflection.isCallerSensitive(csmAdapter);\n+        this.csmAdapter = csmAdapter;\n+        this.accessor = accessor;\n+    }\n+\n+    @Override\n+    public Object invoke(Object obj, Object[] args)\n+            throws IllegalArgumentException, InvocationTargetException {\n+        throw new InternalError(\"caller-sensitive method invoked without explicit caller: \" + csmAdapter);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    @Hidden\n+    public Object invoke(Object obj, Object[] args, Class<?> caller)\n+            throws IllegalArgumentException, InvocationTargetException {\n+        Object[] newArgs = new Object[args == null ? 1 : args.length + 1];\n+        newArgs[0] = caller;\n+        if (args != null) {\n+            System.arraycopy(args, 0, newArgs, 1, args.length);\n+        }\n+        return accessor.invoke(obj, newArgs);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/CsMethodAccessorAdapter.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -40,0 +40,1 @@\n+    @Override\n@@ -46,0 +47,7 @@\n+    @Override\n+    public Object invoke(Object obj, Object[] args, Class<?> caller)\n+            throws IllegalArgumentException, InvocationTargetException\n+    {\n+        return delegate.invoke(obj, args, caller);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/DelegatingMethodAccessorImpl.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,157 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.reflect;\n+\n+import jdk.internal.vm.annotation.DontInline;\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.annotation.Hidden;\n+import jdk.internal.vm.annotation.Stable;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.WrongMethodTypeException;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+\n+import static jdk.internal.reflect.MethodHandleAccessorFactory.SPECIALIZED_PARAM_COUNT;\n+import static jdk.internal.reflect.MethodHandleAccessorFactory.newMethodHandleInvoker;\n+\n+class DirectConstructorAccessorImpl extends ConstructorAccessorImpl {\n+    static ConstructorAccessorImpl constructorAccessor(Constructor<?> ctor, MethodHandle target) {\n+        if (ReflectionFactory.noInflation()) {\n+            \/\/ fast invoker\n+            var mhInvoker = newMethodHandleInvoker(ctor, target);\n+            return new DirectConstructorAccessorImpl(ctor, target);\n+        } else {\n+            \/\/ Default is the adaptive accessor method.\n+            return new AdaptiveConstructorAccessor(ctor, target);\n+        }\n+    }\n+\n+    static ConstructorAccessorImpl nativeAccessor(Constructor<?> ctor) {\n+        return new NativeAccessor(ctor);\n+    }\n+\n+    protected final Constructor<?> ctor;\n+    protected final int paramCount;\n+\n+    @Stable protected final MethodHandle target;\n+    @Stable protected final MHInvoker invoker;\n+    DirectConstructorAccessorImpl(Constructor<?> ctor, MethodHandle target) {\n+        this.ctor = ctor;\n+        this.paramCount = ctor.getParameterCount();\n+        this.target = target;\n+        this.invoker = new MHInvokerDelegate(target);\n+    }\n+\n+    @ForceInline\n+    MHInvoker mhInvoker() {\n+        return invoker;\n+    }\n+\n+    @Override\n+    public Object newInstance(Object[] args) throws InstantiationException, InvocationTargetException {\n+        int argc = args != null ? args.length : 0;\n+        \/\/ only check argument count for specialized forms\n+        if (paramCount <= SPECIALIZED_PARAM_COUNT && argc != paramCount) {\n+            throw new IllegalArgumentException(\"wrong number of arguments: \" + argc + \" expected: \" + paramCount);\n+        }\n+        try {\n+            return invokeImpl(args);\n+        } catch (ClassCastException|WrongMethodTypeException e) {\n+            if (isIllegalArgument(e))\n+                throw new IllegalArgumentException(\"argument type mismatch\", e);\n+            else\n+                throw new InvocationTargetException(e);\n+        } catch (NullPointerException e) {\n+            if (isIllegalArgument(e))\n+                throw new IllegalArgumentException(e);\n+            else\n+                throw new InvocationTargetException(e);\n+        } catch (Throwable e) {\n+            throw new InvocationTargetException(e);\n+        }\n+    }\n+\n+    private boolean isIllegalArgument(RuntimeException ex) {\n+        return AccessorUtils.isIllegalArgument(DirectConstructorAccessorImpl.class, ex);\n+    }\n+\n+    @Hidden\n+    @ForceInline\n+    Object invokeImpl(Object[] args) throws Throwable {\n+        var mhInvoker = mhInvoker();\n+        return switch (paramCount) {\n+            case 0 -> mhInvoker.invoke();\n+            case 1 -> mhInvoker.invoke(args[0]);\n+            case 2 -> mhInvoker.invoke(args[0], args[1]);\n+            case 3 -> mhInvoker.invoke(args[0], args[1], args[2]);\n+            default -> mhInvoker.invoke(args);\n+        };\n+    }\n+\n+    static class AdaptiveConstructorAccessor extends DirectConstructorAccessorImpl {\n+        private @Stable MHInvoker fastInvoker;\n+        private int numInvocations;\n+        AdaptiveConstructorAccessor(Constructor<?> ctor, MethodHandle target) {\n+            super(ctor, target);\n+        }\n+\n+        @ForceInline\n+        MHInvoker mhInvoker() {\n+            var invoker = fastInvoker;\n+            if (invoker != null) {\n+                return invoker;\n+            }\n+            return slowInvoker();\n+        }\n+\n+        @DontInline\n+        private MHInvoker slowInvoker() {\n+            var invoker = this.invoker;\n+            if (++numInvocations > ReflectionFactory.inflationThreshold()) {\n+                fastInvoker = invoker = newMethodHandleInvoker(ctor, target);\n+            }\n+            return invoker;\n+        }\n+    }\n+\n+    \/**\n+     * Invoke the constructor via native VM reflection\n+     *\/\n+    static class NativeAccessor extends ConstructorAccessorImpl {\n+        private final Constructor<?> ctor;\n+        NativeAccessor(Constructor<?> ctor) {\n+            this.ctor = ctor;\n+        }\n+\n+        @Override\n+        public Object newInstance(Object[] args) throws InstantiationException, InvocationTargetException {\n+            return newInstance0(ctor, args);\n+        }\n+        private static native Object newInstance0(Constructor<?> c, Object[] args)\n+                    throws InstantiationException, InvocationTargetException;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/DirectConstructorAccessorImpl.java","additions":157,"deletions":0,"binary":false,"changes":157,"status":"added"},{"patch":"@@ -0,0 +1,459 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.reflect;\n+\n+import jdk.internal.access.JavaLangInvokeAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.misc.VM;\n+import jdk.internal.vm.annotation.DontInline;\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.annotation.Hidden;\n+import jdk.internal.vm.annotation.Stable;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.WrongMethodTypeException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+\n+import static java.lang.invoke.MethodType.genericMethodType;\n+import static jdk.internal.reflect.MethodHandleAccessorFactory.SPECIALIZED_PARAM_COUNT;\n+import static jdk.internal.reflect.MethodHandleAccessorFactory.newMethodHandleInvoker;\n+\n+class DirectMethodAccessorImpl extends MethodAccessorImpl {\n+    \/**\n+     * Creates a MethodAccessorImpl for a non-native and non-caller-sensitive method.\n+     *\/\n+    static MethodAccessorImpl methodAccessor(Method method, MethodHandle target) {\n+        assert !Modifier.isNative(method.getModifiers()) && !Reflection.isCallerSensitive(method);\n+\n+        if (ReflectionFactory.noInflation()) {\n+            \/\/ fast invoker\n+            var mhInvoker = newMethodHandleInvoker(method, target, false);\n+            return new DirectMethodAccessorImpl(method, target, mhInvoker, false);\n+        } else {\n+            \/\/ Default is the adaptive accessor method.\n+            return new AdaptiveMethodAccessor(method, target);\n+        }\n+    }\n+\n+    \/**\n+     * Creates a MethodAccessorImpl for a caller-sensitive method.\n+     *\/\n+    static MethodAccessorImpl callerSensitiveMethodAccessor(Method method, MethodHandle dmh) {\n+        assert Reflection.isCallerSensitive(method);\n+        return new CallerSensitiveWithInvoker(method, dmh);\n+    }\n+\n+    \/**\n+     * Creates MethodAccessorImpl for the adapter method for a caller-sensitive method.\n+     * The given target method handle is the adapter method with the additional caller class\n+     * parameter.\n+     *\/\n+    static MethodAccessorImpl callerSensitiveAdapter(Method original, MethodHandle target) {\n+        assert Reflection.isCallerSensitive(original);\n+\n+        \/\/ for CSM adapter method with the additional caller class parameter\n+        \/\/ creates the adaptive method accessor only.\n+        return new AdapterMethodAccessorWithCaller(original, target);\n+    }\n+\n+    \/**\n+     * Creates MethodAccessorImpl that invokes the given method via VM native reflection\n+     * support.  This is used for native methods.  It can be used for java methods\n+     * during early VM startup.\n+     *\/\n+    static MethodAccessorImpl nativeAccessor(Method method, boolean callerSensitive) {\n+        return callerSensitive ? new NativeAccessor(method, findCSMethodAdapter(method))\n+                               : new NativeAccessor(method);\n+    }\n+\n+    protected final Method method;\n+    protected final int paramCount;\n+    protected final boolean hasCallerParameter;\n+    protected final boolean isStatic;\n+    @Stable protected final MethodHandle target;\n+    @Stable protected final MHInvoker invoker;\n+\n+    DirectMethodAccessorImpl(Method method, MethodHandle target, MHInvoker invoker, boolean hasCallerParameter) {\n+        this.method = method;\n+        this.paramCount = method.getParameterCount();\n+        this.hasCallerParameter = hasCallerParameter;\n+        this.target = target;\n+        this.invoker = invoker;\n+        this.isStatic = Modifier.isStatic(method.getModifiers());\n+    }\n+\n+    DirectMethodAccessorImpl(Method method, MethodHandle target, boolean hasCallerParameter) {\n+        this(method, target, new MHInvokerDelegate(target), hasCallerParameter);\n+    }\n+\n+    @ForceInline\n+    MHInvoker mhInvoker() {\n+        return invoker;\n+    }\n+\n+    \/**\n+     * Returns a MHInvoker that invokes the given target method handle\n+     * from a hidden class.\n+     *\/\n+    MHInvoker spinMethodHandleInvoker() {\n+        return newMethodHandleInvoker(method, target, hasCallerParameter);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Object invoke(Object obj, Object[] args) throws InvocationTargetException {\n+        if (!isStatic) {\n+            checkReceiver(obj);\n+        }\n+        checkArgumentCount(paramCount, args);\n+        try {\n+            return invokeImpl(obj, args);\n+        } catch (ClassCastException | WrongMethodTypeException e) {\n+            if (isIllegalArgument(e)) {\n+                \/\/ No cause in IAE to be consistent with the old behavior\n+                throw new IllegalArgumentException(\"argument type mismatch\");\n+            } else {\n+                throw new InvocationTargetException(e);\n+            }\n+        } catch (NullPointerException e) {\n+            if (isIllegalArgument(e)) {\n+                throw new IllegalArgumentException(e);\n+            } else {\n+                throw new InvocationTargetException(e);\n+            }\n+        } catch (Throwable e) {\n+            throw new InvocationTargetException(e);\n+        }\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public Object invoke(Object obj, Object[] args, Class<?> caller) throws InvocationTargetException {\n+        if (!isStatic) {\n+            checkReceiver(obj);\n+        }\n+        checkArgumentCount(paramCount, args);\n+        try {\n+            return invokeImpl(obj, args, caller);\n+        } catch (ClassCastException | WrongMethodTypeException e) {\n+            if (isIllegalArgument(e)) {\n+                \/\/ No cause in IAE to be consistent with the old behavior\n+                throw new IllegalArgumentException(\"argument type mismatch\");\n+            } else {\n+                throw new InvocationTargetException(e);\n+            }\n+        } catch (NullPointerException e) {\n+            if (isIllegalArgument(e)) {\n+                throw new IllegalArgumentException(e);\n+            } else {\n+                throw new InvocationTargetException(e);\n+            }\n+        } catch (Throwable e) {\n+            throw new InvocationTargetException(e);\n+        }\n+    }\n+\n+    \/\/ implemented by AdapterMethodAccessorWithCaller and CallerSensitiveWithInvoker\n+    Object invokeImpl(Object obj, Object[] args, Class<?> caller) throws Throwable {\n+        throw new InternalError(\"caller-sensitive adapter method only\" + method);\n+    }\n+\n+    @Hidden\n+    @ForceInline\n+    Object invokeImpl(Object obj, Object[] args) throws Throwable {\n+        var mhInvoker = mhInvoker();\n+        return switch (paramCount) {\n+            case 0 -> mhInvoker.invoke(obj);\n+            case 1 -> mhInvoker.invoke(obj, args[0]);\n+            case 2 -> mhInvoker.invoke(obj, args[0], args[1]);\n+            case 3 -> mhInvoker.invoke(obj, args[0], args[1], args[2]);\n+            default -> mhInvoker.invoke(obj, args);\n+        };\n+    }\n+\n+    boolean isIllegalArgument(RuntimeException ex) {\n+        return AccessorUtils.isIllegalArgument(DirectMethodAccessorImpl.class, ex);\n+    }\n+\n+    void checkReceiver(Object o) {\n+        \/\/ NOTE: will throw NullPointerException, as specified, if o is null\n+        if (!method.getDeclaringClass().isAssignableFrom(o.getClass())) {\n+            throw new IllegalArgumentException(\"object is not an instance of declaring class\");\n+        }\n+    }\n+\n+    static class AdaptiveMethodAccessor extends DirectMethodAccessorImpl {\n+        private @Stable MHInvoker fastInvoker;\n+        private int numInvocations;\n+\n+        AdaptiveMethodAccessor(Method method, MethodHandle target) {\n+            this(method, target, false);\n+        }\n+        AdaptiveMethodAccessor(Method method, MethodHandle target, boolean hasCallerParameter) {\n+            super(method, target, hasCallerParameter);\n+        }\n+\n+        @ForceInline\n+        MHInvoker mhInvoker() {\n+            var invoker = fastInvoker;\n+            if (invoker != null) {\n+                return invoker;\n+            }\n+            return slowInvoker();\n+        }\n+\n+        @DontInline\n+        private MHInvoker slowInvoker() {\n+            var invoker = this.invoker;\n+            if (++numInvocations > ReflectionFactory.inflationThreshold()) {\n+                fastInvoker = invoker = spinMethodHandleInvoker();\n+            }\n+            return invoker;\n+        }\n+    }\n+\n+    static class AdapterMethodAccessorWithCaller extends AdaptiveMethodAccessor {\n+        AdapterMethodAccessorWithCaller(Method method, MethodHandle target) {\n+            this(method, target, true);\n+        }\n+        AdapterMethodAccessorWithCaller(Method method, MethodHandle target, boolean hasCallerParameter) {\n+            super(method, target, hasCallerParameter);\n+        }\n+\n+        @Override\n+        public Object invoke(Object obj, Object[] args) throws InvocationTargetException {\n+            throw new InternalError(\"caller sensitive method invoked without explicit caller: \" + method);\n+        }\n+\n+        @Hidden\n+        @ForceInline\n+        Object invokeImpl(Object obj, Object[] args, Class<?> caller) throws Throwable {\n+            var mhInvoker = mhInvoker();\n+            return switch (paramCount) {\n+                case 0 -> mhInvoker.invoke(obj, caller);\n+                case 1 -> mhInvoker.invoke(obj, args[0], caller);\n+                case 2 -> mhInvoker.invoke(obj, args[0], args[1], caller);\n+                case 3 -> mhInvoker.invoke(obj, args[0], args[1], args[2], caller);\n+                default -> mhInvoker.invoke(obj, args, caller);\n+            };\n+        }\n+    }\n+\n+    \/**\n+     * MethodAccessor class to invoke caller-sensitive methods via a reflective invoker\n+     * injected as a caller class to invoke a method handle.\n+     *\n+     * This uses the simple form of direct method handle with the same method type\n+     * as Method::invoke.\n+     *\n+     * To use specialized target method handles (see MethodHandleAccessorFactory::makeSpecializedTarget)\n+     * it needs support in the injected invoker::reflect_invoke_V for different specialized forms.\n+     *\/\n+    static class CallerSensitiveWithInvoker extends DirectMethodAccessorImpl {\n+        private static final JavaLangInvokeAccess JLIA = SharedSecrets.getJavaLangInvokeAccess();\n+        private CallerSensitiveWithInvoker(Method method, MethodHandle target) {\n+            super(method, target, null, false);\n+        }\n+\n+        @Override\n+        public Object invoke(Object obj, Object[] args) throws InvocationTargetException {\n+            throw new InternalError(\"caller-sensitive method invoked without explicit caller: \" + target);\n+        }\n+\n+        @Hidden\n+        @ForceInline\n+        Object invokeImpl(Object obj, Object[] args, Class<?> caller) throws Throwable {\n+            \/\/ caller-sensitive method is invoked through a per-caller invoker\n+            var invoker = JLIA.reflectiveInvoker(caller);\n+            try {\n+                \/\/ invoke the target method handle via an invoker\n+                return invoker.invokeExact(target, obj, args);\n+            } catch (IllegalArgumentException e) {\n+                throw new InvocationTargetException(e);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Invoke the method via native VM reflection\n+     *\/\n+    static class NativeAccessor extends MethodAccessorImpl {\n+        private final Method method;\n+        private final Method csmAdapter;\n+        private final boolean callerSensitive;\n+        NativeAccessor(Method method) {\n+            assert !Reflection.isCallerSensitive(method);\n+            this.method = method;\n+            this.csmAdapter = null;\n+            this.callerSensitive = false;\n+        }\n+\n+        NativeAccessor(Method method, Method csmAdapter) {\n+            assert Reflection.isCallerSensitive(method);\n+            this.method = method;\n+            this.csmAdapter = csmAdapter;\n+            this.callerSensitive = true;\n+        }\n+\n+        @Override\n+        public Object invoke(Object obj, Object[] args) throws InvocationTargetException {\n+            assert csmAdapter == null;\n+            return invoke0(method, obj, args);\n+        }\n+\n+        @Override\n+        public Object invoke(Object obj, Object[] args, Class<?> caller) throws InvocationTargetException {\n+            assert callerSensitive;\n+\n+            if (csmAdapter != null) {\n+                Object[] newArgs = new Object[csmAdapter.getParameterCount()];\n+                newArgs[0] = caller;\n+                if (args != null) {\n+                    System.arraycopy(args, 0, newArgs, 1, args.length);\n+                }\n+                return invoke0(csmAdapter, obj, newArgs);\n+            } else {\n+                assert VM.isJavaLangInvokeInited();\n+                try {\n+                    return ReflectiveInvoker.invoke(methodAccessorInvoker(), caller, obj, args);\n+                } catch (InvocationTargetException|RuntimeException|Error e) {\n+                    throw e;\n+                } catch (Throwable e) {\n+                    throw new InternalError(e);\n+                }\n+            }\n+        }\n+\n+        public Object invokeViaReflectiveInvoker(Object obj, Object[] args) throws InvocationTargetException {\n+            return invoke0(method, obj, args);\n+        }\n+\n+        \/*\n+         * A method handle to invoke Reflective::Invoker\n+         *\/\n+        private MethodHandle maInvoker;\n+        private MethodHandle methodAccessorInvoker() {\n+            MethodHandle invoker = maInvoker;\n+            if (invoker == null) {\n+                maInvoker = invoker = ReflectiveInvoker.bindTo(this);\n+            }\n+            return invoker;\n+        }\n+\n+        private static native Object invoke0(Method m, Object obj, Object[] args);\n+\n+        static class ReflectiveInvoker {\n+            \/**\n+             * Return a method handle for NativeAccessor::invoke bound to the given accessor object\n+             *\/\n+            static MethodHandle bindTo(NativeAccessor accessor) {\n+                return NATIVE_ACCESSOR_INVOKE.bindTo(accessor);\n+            }\n+\n+            \/*\n+             * When Method::invoke on a caller-sensitive method is to be invoked\n+             * and no adapter method with an additional caller class argument is defined,\n+             * the caller-sensitive method must be invoked via an invoker injected\n+             * which has the following signature:\n+             *     reflect_invoke_V(MethodHandle mh, Object target, Object[] args)\n+             *\n+             * The stack frames calling the method `csm` through reflection will\n+             * look like this:\n+             *     obj.csm(args)\n+             *     NativeAccessor::invoke(obj, args)\n+             *     InjectedInvoker::reflect_invoke_V(vamh, obj, args);\n+             *     method::invoke(obj, args)\n+             *     p.Foo::m\n+             *\n+             * An injected invoker class is a hidden class which has the same\n+             * defining class loader, runtime package, and protection domain\n+             * as the given caller class.\n+             *\n+             * The caller-sensitive method will call Reflection::getCallerClass\n+             * to get the caller class.\n+             *\/\n+            static Object invoke(MethodHandle target, Class<?> caller, Object obj, Object[] args)\n+                    throws InvocationTargetException\n+            {\n+                var reflectInvoker = JLIA.reflectiveInvoker(caller);\n+                try {\n+                    return reflectInvoker.invokeExact(target, obj, args);\n+                } catch (InvocationTargetException | RuntimeException | Error e) {\n+                    throw e;\n+                } catch (Throwable e) {\n+                    throw new InternalError(e);\n+                }\n+            }\n+\n+            static final JavaLangInvokeAccess JLIA;\n+            static final MethodHandle NATIVE_ACCESSOR_INVOKE;\n+            static {\n+                try {\n+                    JLIA = SharedSecrets.getJavaLangInvokeAccess();\n+                    NATIVE_ACCESSOR_INVOKE = MethodHandles.lookup().findVirtual(NativeAccessor.class, \"invoke\",\n+                            genericMethodType(1, true));\n+                } catch (NoSuchMethodException|IllegalAccessException e) {\n+                    throw new InternalError(e);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void checkArgumentCount(int paramCount, Object[] args) {\n+        \/\/ only check argument count for specialized forms\n+        if (paramCount > SPECIALIZED_PARAM_COUNT) return;\n+\n+        int argc = args != null ? args.length : 0;\n+        if (argc != paramCount) {\n+            throw new IllegalArgumentException(\"wrong number of arguments: \" + argc + \" expected: \" + paramCount);\n+        }\n+    }\n+\n+    \/**\n+     * Returns an adapter for caller-sensitive method if present.\n+     * Otherwise, null.\n+     *\n+     * A trusted method can define an adapter method for a caller-sensitive method `foo`\n+     * with an additional caller class argument that will be invoked reflectively.\n+     *\/\n+    private static Method findCSMethodAdapter(Method method) {\n+        if (!Reflection.isCallerSensitive(method)) return null;\n+\n+        int paramCount = method.getParameterCount();\n+        Class<?>[] ptypes = new Class<?>[paramCount+1];\n+        ptypes[paramCount] = Class.class;\n+        System.arraycopy(method.getParameterTypes(), 0, ptypes, 0, paramCount);\n+        try {\n+            return method.getDeclaringClass().getDeclaredMethod(method.getName(), ptypes);\n+        } catch (NoSuchMethodException ex) {\n+            return null;\n+        }\n+    }\n+}\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/DirectMethodAccessorImpl.java","additions":459,"deletions":0,"binary":false,"changes":459,"status":"added"},{"patch":"@@ -28,0 +28,3 @@\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+\n@@ -34,0 +37,6 @@\n+    protected final Field   field;\n+\n+    protected FieldAccessorImpl(Field field) {\n+        this.field = field;\n+    }\n+\n@@ -105,0 +114,163 @@\n+\n+\n+    protected void ensureObj(Object o) {\n+        \/\/ NOTE: will throw NullPointerException, as specified, if o is null\n+        if (!field.getDeclaringClass().isAssignableFrom(o.getClass())) {\n+            throwSetIllegalArgumentException(o);\n+        }\n+    }\n+\n+    private String getQualifiedFieldName() {\n+        return field.getDeclaringClass().getName() + \".\" +field.getName();\n+    }\n+\n+    protected IllegalArgumentException newGetIllegalArgumentException(String type) {\n+        return new IllegalArgumentException(\n+                \"Attempt to get \"+field.getType().getName()+\" field \\\"\" +\n+                        getQualifiedFieldName() + \"\\\" with illegal data type conversion to \"+type\n+        );\n+    }\n+\n+    protected void throwFinalFieldIllegalAccessException(String attemptedType,\n+                                                         String attemptedValue)\n+            throws IllegalAccessException {\n+        throw new IllegalAccessException(getSetMessage(attemptedType, attemptedValue));\n+    }\n+\n+    protected void throwFinalFieldIllegalAccessException(Object o) throws IllegalAccessException {\n+        throwFinalFieldIllegalAccessException(o != null ? o.getClass().getName() : \"\", \"\");\n+    }\n+\n+    protected void throwFinalFieldIllegalAccessException(boolean z) throws IllegalAccessException {\n+        throwFinalFieldIllegalAccessException(\"boolean\", Boolean.toString(z));\n+    }\n+\n+    protected void throwFinalFieldIllegalAccessException(char b) throws IllegalAccessException {\n+        throwFinalFieldIllegalAccessException(\"char\", Character.toString(b));\n+    }\n+\n+    protected void throwFinalFieldIllegalAccessException(byte b) throws IllegalAccessException {\n+        throwFinalFieldIllegalAccessException(\"byte\", Byte.toString(b));\n+    }\n+\n+    protected void throwFinalFieldIllegalAccessException(short b) throws IllegalAccessException {\n+        throwFinalFieldIllegalAccessException(\"short\", Short.toString(b));\n+    }\n+\n+    protected void throwFinalFieldIllegalAccessException(int i) throws IllegalAccessException {\n+        throwFinalFieldIllegalAccessException(\"int\", Integer.toString(i));\n+    }\n+\n+    protected void throwFinalFieldIllegalAccessException(long i) throws IllegalAccessException {\n+        throwFinalFieldIllegalAccessException(\"long\", Long.toString(i));\n+    }\n+\n+    protected void throwFinalFieldIllegalAccessException(float f) throws IllegalAccessException {\n+        throwFinalFieldIllegalAccessException(\"float\", Float.toString(f));\n+    }\n+\n+    protected void throwFinalFieldIllegalAccessException(double f) throws IllegalAccessException {\n+        throwFinalFieldIllegalAccessException(\"double\", Double.toString(f));\n+    }\n+\n+    protected IllegalArgumentException newGetBooleanIllegalArgumentException() {\n+        return newGetIllegalArgumentException(\"boolean\");\n+    }\n+\n+    protected IllegalArgumentException newGetByteIllegalArgumentException() {\n+        return newGetIllegalArgumentException(\"byte\");\n+    }\n+\n+    protected IllegalArgumentException newGetCharIllegalArgumentException() {\n+        return newGetIllegalArgumentException(\"char\");\n+    }\n+\n+    protected IllegalArgumentException newGetShortIllegalArgumentException() {\n+        return newGetIllegalArgumentException(\"short\");\n+    }\n+\n+    protected IllegalArgumentException newGetIntIllegalArgumentException() {\n+        return newGetIllegalArgumentException(\"int\");\n+    }\n+\n+    protected IllegalArgumentException newGetLongIllegalArgumentException() {\n+        return newGetIllegalArgumentException(\"long\");\n+    }\n+\n+    protected IllegalArgumentException newGetFloatIllegalArgumentException() {\n+        return newGetIllegalArgumentException(\"float\");\n+    }\n+\n+    protected IllegalArgumentException newGetDoubleIllegalArgumentException() {\n+        return newGetIllegalArgumentException(\"double\");\n+    }\n+\n+    protected String getSetMessage(String attemptedType, String attemptedValue) {\n+        String err = \"Can not set\";\n+        if (Modifier.isStatic(field.getModifiers()))\n+            err += \" static\";\n+        if (Modifier.isFinal(field.getModifiers()))\n+            err += \" final\";\n+        err += \" \" + field.getType().getName() + \" field \" + getQualifiedFieldName() + \" to \";\n+        if (!attemptedValue.isEmpty()) {\n+            err += \"(\" + attemptedType + \")\" + attemptedValue;\n+        } else {\n+            if (!attemptedType.isEmpty())\n+                err += attemptedType;\n+            else\n+                err += \"null value\";\n+        }\n+        return err;\n+    }\n+\n+    protected String getMessage(boolean getter, String attemptedType) {\n+        String err = \"Can not \" + (getter ? \"get\" : \"set\");\n+        if (Modifier.isStatic(field.getModifiers()))\n+            err += \" static\";\n+        if (Modifier.isFinal(field.getModifiers()))\n+            err += \" final\";\n+        err += \" \" + field.getType().getName() + \" field \" + getQualifiedFieldName() + \" on \" + attemptedType;\n+        return err;\n+    }\n+\n+    protected void throwSetIllegalArgumentException(String attemptedType,\n+                                                    String attemptedValue) {\n+        throw new IllegalArgumentException(getSetMessage(attemptedType,attemptedValue));\n+    }\n+\n+    protected void throwSetIllegalArgumentException(Object o) {\n+        throwSetIllegalArgumentException(o != null ? o.getClass().getName() : \"\", \"\");\n+    }\n+\n+    protected void throwSetIllegalArgumentException(boolean b) {\n+        throwSetIllegalArgumentException(\"boolean\", Boolean.toString(b));\n+    }\n+\n+    protected void throwSetIllegalArgumentException(byte b) {\n+        throwSetIllegalArgumentException(\"byte\", Byte.toString(b));\n+    }\n+\n+    protected void throwSetIllegalArgumentException(char c) {\n+        throwSetIllegalArgumentException(\"char\", Character.toString(c));\n+    }\n+\n+    protected void throwSetIllegalArgumentException(short s) {\n+        throwSetIllegalArgumentException(\"short\", Short.toString(s));\n+    }\n+\n+    protected void throwSetIllegalArgumentException(int i) {\n+        throwSetIllegalArgumentException(\"int\", Integer.toString(i));\n+    }\n+\n+    protected void throwSetIllegalArgumentException(long l) {\n+        throwSetIllegalArgumentException(\"long\", Long.toString(l));\n+    }\n+\n+    protected void throwSetIllegalArgumentException(float f) {\n+        throwSetIllegalArgumentException(\"float\", Float.toString(f));\n+    }\n+\n+    protected void throwSetIllegalArgumentException(double d) {\n+        throwSetIllegalArgumentException(\"double\", Double.toString(d));\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/FieldAccessorImpl.java","additions":172,"deletions":0,"binary":false,"changes":172,"status":"modified"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.reflect;\n+\n+\/**\n+ * MHInvoker::invoke is the implementation body for\n+ * Method::invoke(Object obj, Object[] args) and Constructor::newInstance\n+ * that invokes the MethodHandle for the reflected method and constructor.\n+ *\n+ * Methods whose have <= 3 formal parameters use the specialized version.\n+ * For example, method with 3 arguments will use:\n+ * MHInvoker::invoke(Object obj, Object arg1, Object arg2, Object arg3)\n+ *\n+ * Caller-sensitive methods with an adapter will use the invoke method\n+ * taking a caller class parameter.\n+ *\n+ * See MethodHandleAccessorFactory for the specialization.\n+ *\/\n+public interface MHInvoker {\n+    \/\/ non-specialized method handle invocation also with trailing caller class parameter\n+    default Object invoke(Object obj, Object[] args) throws Throwable {\n+        throw new UnsupportedOperationException();\n+    }\n+    default Object invoke(Object obj, Object[] args, Class<?> caller) throws Throwable {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    \/\/ specialized version for number of arguments <= 3\n+    default Object invoke(Object obj) throws Throwable {\n+        throw new UnsupportedOperationException();\n+    }\n+    default Object invoke(Object obj, Object arg1) throws Throwable {\n+        throw new UnsupportedOperationException();\n+    }\n+    default Object invoke(Object obj, Object arg1, Object arg2) throws Throwable {\n+        throw new UnsupportedOperationException();\n+    }\n+    default Object invoke(Object obj, Object arg1, Object arg2, Object arg3) throws Throwable {\n+        throw new UnsupportedOperationException();\n+    }\n+    default Object invoke(Object obj, Class<?> caller) throws Throwable {\n+        throw new UnsupportedOperationException();\n+    }\n+    default Object invoke(Object obj, Object arg1, Class<?> caller) throws Throwable {\n+        throw new UnsupportedOperationException();\n+    }\n+    default Object invoke(Object obj, Object arg1, Object arg2, Class<?> caller) throws Throwable {\n+        throw new UnsupportedOperationException();\n+    }\n+    default Object invoke(Object obj, Object arg1, Object arg2, Object arg3, Class<?> caller) throws Throwable {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    \/\/ for Constructor::newInstance\n+    default Object invoke(Object[] args) throws Throwable {\n+        throw new UnsupportedOperationException();\n+    }\n+    default Object invoke() throws Throwable {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+\/\/    No need to define them as they are already covered by the above methods\n+\/\/\n+\/\/    default Object invoke(Object arg1) throws Throwable {\n+\/\/        throw new UnsupportedOperationException();\n+\/\/    }\n+\/\/    default Object invoke(Object arg1, Object arg2) throws Throwable {\n+\/\/        throw new UnsupportedOperationException();\n+\/\/    }\n+\/\/    default Object invoke(Object arg1, Object arg2, Object arg3) throws Throwable {\n+\/\/        throw new UnsupportedOperationException();\n+\/\/    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MHInvoker.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.reflect;\n+\n+import jdk.internal.vm.annotation.Hidden;\n+\n+import java.lang.invoke.MethodHandle;\n+\n+\/**\n+ * Delegate the invocation directly to the target method handle.\n+ *\/\n+final class MHInvokerDelegate implements MHInvoker {\n+    private final MethodHandle target;\n+    MHInvokerDelegate(MethodHandle target) {\n+        this.target = target;\n+    }\n+\n+    \/\/ non-specialized method handle invocation also with trailing caller class parameter\n+    @Hidden @Override public Object invoke(Object obj, Object[] args) throws Throwable {\n+        return target.invokeExact(obj, args);\n+    }\n+    @Hidden @Override public Object invoke(Object obj, Object[] args, Class<?> caller) throws Throwable {\n+        return target.invokeExact(obj, args, caller);\n+    }\n+\n+    \/\/ specialized version for number of arguments <= 3\n+    @Hidden @Override public Object invoke(Object obj) throws Throwable {\n+        return target.invokeExact(obj);\n+    }\n+    @Hidden @Override public Object invoke(Object obj, Object arg1) throws Throwable {\n+        return target.invokeExact(obj, arg1);\n+    }\n+    @Hidden @Override public Object invoke(Object obj, Object arg1, Object arg2) throws Throwable {\n+        return target.invokeExact(obj, arg1, arg2);\n+    }\n+    @Hidden @Override public Object invoke(Object obj, Object arg1, Object arg2, Object arg3) throws Throwable {\n+        return target.invokeExact(obj, arg1, arg2, arg3);\n+    }\n+    @Hidden @Override public Object invoke(Object obj, Class<?> caller) throws Throwable {\n+        return target.invokeExact(obj, caller);\n+    }\n+    @Hidden @Override public Object invoke(Object obj, Object arg1, Class<?> caller) throws Throwable {\n+        return target.invokeExact(obj, arg1, caller);\n+    }\n+    @Hidden @Override public Object invoke(Object obj, Object arg1, Object arg2, Class<?> caller) throws Throwable {\n+        return target.invokeExact(obj, arg1, arg2, caller);\n+    }\n+    @Hidden @Override public Object invoke(Object obj, Object arg1, Object arg2, Object arg3, Class<?> caller) throws Throwable {\n+        return target.invokeExact(obj, arg1, arg2, arg3, caller);\n+    }\n+\n+    \/\/ for Constructor::newInstance\n+    @Hidden @Override public Object invoke(Object[] args) throws Throwable {\n+        return target.invokeExact(args);\n+    }\n+    @Hidden @Override public Object invoke() throws Throwable {\n+        return target.invokeExact();\n+    }\n+\n+\n+\/\/    No need to define them as they are already covered by the above methods\n+\/\/    @Hidden @Override public Object invoke(Object arg1) throws Throwable {\n+\/\/        return target.invokeExact();\n+\/\/    }\n+\/\/    @Hidden @Override public Object invoke(Object arg1, Object arg2) throws Throwable {\n+\/\/        return target.invokeExact();\n+\/\/    }\n+\/\/    @Hidden @Override public Object invoke(Object arg1, Object arg2, Object arg3) throws Throwable {\n+\/\/        return target.invokeExact(arg1, arg2, arg3);\n+\/\/    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MHInvokerDelegate.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"},{"patch":"@@ -40,0 +40,3 @@\n+\n+    public Object invoke(Object obj, Object[] args, Class<?> caller)\n+            throws IllegalArgumentException, InvocationTargetException;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MethodAccessor.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,2 +31,2 @@\n-\/** Generator for sun.reflect.MethodAccessor and\n-    sun.reflect.ConstructorAccessor objects using bytecodes to\n+\/** Generator for jdk.internal.reflect.MethodAccessor and\n+    jdk.internal.reflect.ConstructorAccessor objects using bytecodes to\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MethodAccessorGenerator.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -48,0 +48,5 @@\n+\n+    public Object invoke(Object obj, Object[] args, Class<?> caller)\n+            throws IllegalArgumentException, InvocationTargetException {\n+        return invoke(obj, args);\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MethodAccessorImpl.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,433 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.reflect;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.UncheckedIOException;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.invoke.VarHandle;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import jdk.internal.access.JavaLangInvokeAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.misc.VM;\n+import sun.security.action.GetPropertyAction;\n+\n+import static java.lang.invoke.MethodType.genericMethodType;\n+import static java.lang.invoke.MethodType.methodType;\n+\n+final class MethodHandleAccessorFactory {\n+    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+\n+    static MethodAccessorImpl newMethodAccessor(Method method, boolean callerSensitive) {\n+        assert VM.isJavaLangInvokeInited();\n+\n+        \/\/ ExceptionInInitializerError may be thrown during class initialization\n+        \/\/ Ensure class initialized outside the invocation of method handle\n+        \/\/ so that EIIE is propagated (not wrapped with ITE)\n+        ensureClassInitialized(method.getDeclaringClass());\n+\n+        try {\n+            if (callerSensitive) {\n+                var dmh = findDirectMethodWithCaller(method);\n+                if (dmh != null) {\n+                    return DirectMethodAccessorImpl.callerSensitiveAdapter(method, dmh);\n+                }\n+            }\n+            var dmh = getDirectMethod(method, callerSensitive);\n+            if (callerSensitive) {\n+                return DirectMethodAccessorImpl.callerSensitiveMethodAccessor(method, dmh);\n+            } else {\n+                return DirectMethodAccessorImpl.methodAccessor(method, dmh);\n+            }\n+        } catch (IllegalAccessException e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+\n+    static ConstructorAccessorImpl newConstructorAccessor(Constructor<?> ctor) {\n+        assert VM.isJavaLangInvokeInited();\n+\n+        \/\/ ExceptionInInitializerError may be thrown during class initialization\n+        \/\/ Ensure class initialized outside the invocation of method handle\n+        \/\/ so that EIIE is propagated (not wrapped with ITE)\n+        ensureClassInitialized(ctor.getDeclaringClass());\n+\n+        try {\n+            MethodHandle mh = JLIA.unreflectConstructor(ctor);\n+            int paramCount = mh.type().parameterCount();\n+            MethodHandle target = mh.asFixedArity();\n+            MethodType mtype = specializedMethodTypeForConstructor(paramCount);\n+            if (paramCount > SPECIALIZED_PARAM_COUNT) {\n+                \/\/ spread the parameters only for the non-specialized case\n+                target = target.asSpreader(Object[].class, paramCount);\n+            }\n+            target = target.asType(mtype);\n+            return DirectConstructorAccessorImpl.constructorAccessor(ctor, target);\n+        } catch (IllegalAccessException e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+\n+    static FieldAccessorImpl newFieldAccessor(Field field, boolean isReadOnly) {\n+        assert VM.isJavaLangInvokeInited();\n+        try {\n+            \/\/ the declaring class of the field has been initialized\n+            var varHandle = JLIA.unreflectVarHandle(field);\n+            Class<?> type = field.getType();\n+            if (type == Boolean.TYPE) {\n+                return VarHandleBooleanFieldAccessorImpl.fieldAccessor(field, varHandle, isReadOnly);\n+            } else if (type == Byte.TYPE) {\n+                return VarHandleByteFieldAccessorImpl.fieldAccessor(field, varHandle, isReadOnly);\n+            } else if (type == Short.TYPE) {\n+                return VarHandleShortFieldAccessorImpl.fieldAccessor(field, varHandle, isReadOnly);\n+            } else if (type == Character.TYPE) {\n+                return VarHandleCharacterFieldAccessorImpl.fieldAccessor(field, varHandle, isReadOnly);\n+            } else if (type == Integer.TYPE) {\n+                return VarHandleIntegerFieldAccessorImpl.fieldAccessor(field, varHandle, isReadOnly);\n+            } else if (type == Long.TYPE) {\n+                return VarHandleLongFieldAccessorImpl.fieldAccessor(field, varHandle, isReadOnly);\n+            } else if (type == Float.TYPE) {\n+                return VarHandleFloatFieldAccessorImpl.fieldAccessor(field, varHandle, isReadOnly);\n+            } else if (type == Double.TYPE) {\n+                return VarHandleDoubleFieldAccessorImpl.fieldAccessor(field, varHandle, isReadOnly);\n+            } else {\n+                return VarHandleObjectFieldAccessorImpl.fieldAccessor(field, varHandle, isReadOnly);\n+            }\n+        } catch (IllegalAccessException e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+\n+    private static MethodHandle getDirectMethod(Method method, boolean callerSensitive) throws IllegalAccessException {\n+        var mtype = methodType(method.getReturnType(), method.getParameterTypes());\n+        var isStatic = Modifier.isStatic(method.getModifiers());\n+        var dmh = isStatic ? JLIA.findStatic(method.getDeclaringClass(), method.getName(), mtype)\n+                                        : JLIA.findVirtual(method.getDeclaringClass(), method.getName(), mtype);\n+        if (callerSensitive) {\n+            \/\/ the reflectiveInvoker for caller-sensitive method expects the same signature\n+            \/\/ as Method::invoke i.e. (Object, Object[])Object\n+            return makeTarget(dmh, isStatic, false);\n+        }\n+        return makeSpecializedTarget(dmh, isStatic, false);\n+    }\n+\n+    private static MethodHandle findDirectMethodWithCaller(Method method) throws IllegalAccessException {\n+        String name = method.getName();\n+        \/\/ append a Class parameter\n+        MethodType mtype = methodType(method.getReturnType(), method.getParameterTypes())\n+                                .appendParameterTypes(Class.class);\n+        boolean isStatic = Modifier.isStatic(method.getModifiers());\n+\n+        MethodHandle dmh = isStatic ? JLIA.findStatic(method.getDeclaringClass(), name, mtype)\n+                                    : JLIA.findVirtual(method.getDeclaringClass(), name, mtype);\n+        return dmh != null ? makeSpecializedTarget(dmh, isStatic, true) : null;\n+    }\n+\n+    \/**\n+     * Transform the given dmh to a specialized target method handle.\n+     *\n+     * If {@code hasCallerParameter} parameter is true, transform the method handle\n+     * of this method type: {@code (Object, Object[], Class)Object} for the default\n+     * case.\n+     *\n+     * If {@code hasCallerParameter} parameter is false, transform the method handle\n+     * of this method type: {@code (Object, Object[])Object} for the default case.\n+     *\n+     * If the number of formal arguments is small, use a method type specialized\n+     * the number of formal arguments is 0, 1, and 2, for example, the method type\n+     * of a static method with one argument can be: {@code (Object)Object}\n+     *\n+     * If it's a static method, there is no leading Object parameter.\n+     *\n+     * @apiNote\n+     * This implementation avoids using MethodHandles::catchException to help\n+     * cold startup performance since this combination is very costly to setup.\n+     *\n+     * @param dmh DirectMethodHandle\n+     * @param isStatic whether given dmh represents static method or not\n+     * @param hasCallerParameter whether given dmh represents a method with an\n+     *                         additional caller Class parameter\n+     * @return transformed dmh to be used as a target in direct method accessors\n+     *\/\n+    static MethodHandle makeSpecializedTarget(MethodHandle dmh, boolean isStatic, boolean hasCallerParameter) {\n+        MethodHandle target = dmh.asFixedArity();\n+\n+        \/\/ number of formal arguments to the original method (not the adapter)\n+        \/\/ If it is a non-static method, it has a leading `this` argument.\n+        \/\/ Also do not count the caller class argument\n+        int paramCount = dmh.type().parameterCount() - (isStatic ? 0 : 1) - (hasCallerParameter ? 1 : 0);\n+        MethodType mtype = specializedMethodType(isStatic, hasCallerParameter, paramCount);\n+        if (paramCount > SPECIALIZED_PARAM_COUNT) {\n+            int spreadArgPos = isStatic ? 0 : 1;\n+            target = target.asSpreader(spreadArgPos, Object[].class, paramCount);\n+        }\n+        if (isStatic) {\n+            \/\/ add leading 'this' parameter to static method which is then ignored\n+            target = MethodHandles.dropArguments(target, 0, Object.class);\n+        }\n+        return target.asType(mtype);\n+    }\n+\n+    \/\/ specialize for number of formal arguments <= 3 to avoid spreader\n+    static final int SPECIALIZED_PARAM_COUNT = 3;\n+    static MethodType specializedMethodType(boolean isStatic, boolean hasCallerParameter, int paramCount) {\n+        return switch (paramCount) {\n+            case 0 -> hasCallerParameter ? methodType(Object.class, Object.class, Class.class)\n+                                         : genericMethodType(1);\n+            case 1 -> hasCallerParameter ? methodType(Object.class, Object.class, Object.class, Class.class)\n+                                         : genericMethodType(2);\n+            case 2 -> hasCallerParameter ? methodType(Object.class, Object.class, Object.class, Object.class, Class.class)\n+                                         : genericMethodType(3);\n+            case 3 -> hasCallerParameter ? methodType(Object.class, Object.class, Object.class, Object.class, Object.class, Class.class)\n+                                         : genericMethodType(4);\n+            default -> hasCallerParameter ? methodType(Object.class, Object.class, Object[].class, Class.class)\n+                                          : genericMethodType(1, true);\n+        };\n+    }\n+\n+    static MethodType specializedMethodTypeForConstructor(int paramCount) {\n+        return switch (paramCount) {\n+            case 0 ->  genericMethodType(0);\n+            case 1 ->  genericMethodType(1);\n+            case 2 ->  genericMethodType(2);\n+            case 3 ->  genericMethodType(3);\n+            default -> genericMethodType(0, true);\n+        };\n+    }\n+\n+    \/**\n+     * Transforms the given dmh into a target method handle with the method type\n+     * {@code (Object, Object[])Object} or {@code (Object, Class, Object[])Object}\n+     *\/\n+    static MethodHandle makeTarget(MethodHandle dmh, boolean isStatic, boolean hasCallerParameter) {\n+        MethodType mtype = hasCallerParameter\n+                                ? methodType(Object.class, Object.class, Object[].class, Class.class)\n+                                : genericMethodType(1, true);\n+        \/\/ number of formal arguments\n+        int paramCount = dmh.type().parameterCount() - (isStatic ? 0 : 1) - (hasCallerParameter ? 1 : 0);\n+        int spreadArgPos = isStatic ? 0 : 1;\n+        MethodHandle target = dmh.asFixedArity().asSpreader(spreadArgPos, Object[].class, paramCount);\n+        if (isStatic) {\n+            \/\/ add leading 'this' parameter to static method which is then ignored\n+            target = MethodHandles.dropArguments(target, 0, Object.class);\n+        }\n+        return target.asType(mtype);\n+    }\n+\n+    \/**\n+     * Spins a hidden class that invokes a constant VarHandle of the target field,\n+     * loaded from the class data via condy, for reliable performance.\n+     *\n+     * For a non-volatile field, one class file is generated for each primitive\n+     * type and a reference type, its class name is FieldAccessorImpl_L_<T>\n+     * for an instance field or FieldAccessorImpl_<T> for a static field\n+     * where T is the base type, B C D F I J S Z, for primitive type or L\n+     * for a reference type.\n+     *\n+     * For a volatile field, its class name is FieldAccessorImpl_<T>_V\n+     * for an instance field or FieldAccessorImpl_<T>_V for a static field.\n+     *\/\n+    static VHInvoker newVarHandleAccessor(Field field, VarHandle varHandle) {\n+        var name = classNamePrefix(field);\n+        var cn = name + \"$$\" + counter.getAndIncrement();\n+        byte[] bytes = ACCESSOR_CLASSFILES.computeIfAbsent(name, n -> spinByteCode(name, field));\n+        try {\n+            var lookup = JLIA.defineHiddenClassWithClassData(LOOKUP, cn, bytes, varHandle, true);\n+            var ctor = lookup.findConstructor(lookup.lookupClass(), methodType(void.class));\n+            ctor = ctor.asType(methodType(VHInvoker.class));\n+            return (VHInvoker) ctor.invokeExact();\n+        } catch (Throwable e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+\n+    \/**\n+     * Spins a hidden class that invokes a constant MethodHandle of the target method handle,\n+     * loaded from the class data via condy, for reliable performance.\n+     *\n+     * One class file is generated for each method type which is either\n+     * (Object,Object[])Object or the specialized version\n+     * (Object,Object, ...)Object or (Object,Object, ..., Class)Object\n+     * where the number of parameter types = receiver if it's an instance method\n+     * + the number of formal parameters + \"Class\" if it's a caller-sensitive method\n+     * which has an adapter defined.\n+     *\/\n+    static MHInvoker newMethodHandleInvoker(Method method, MethodHandle target, boolean hasCallerParameter) {\n+        var name = classNamePrefix(method, target.type(), hasCallerParameter);\n+        var cn = name + \"$$\" + counter.getAndIncrement();\n+        byte[] bytes = ACCESSOR_CLASSFILES.computeIfAbsent(name,\n+                n -> spinByteCode(name, method, target.type(), hasCallerParameter));\n+        try {\n+            var lookup = JLIA.defineHiddenClassWithClassData(LOOKUP, cn, bytes, target, true);\n+            var ctor = lookup.findConstructor(lookup.lookupClass(), methodType(void.class));\n+            ctor = ctor.asType(methodType(MHInvoker.class));\n+            return (MHInvoker) ctor.invokeExact();\n+        } catch (Throwable e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+\n+    \/**\n+     * Spins a hidden class that invokes a constant MethodHandle of the target method handle,\n+     * loaded from the class data via condy, for reliable performance.\n+     *\n+     * Due to the overhead of class loading, this is not the default.\n+     *\/\n+    static MHInvoker newMethodHandleInvoker(Constructor<?> c, MethodHandle target) {\n+        var name = classNamePrefix(c, target.type());\n+        var cn = name + \"$$\" + counter.getAndIncrement();\n+        byte[] bytes = ACCESSOR_CLASSFILES.computeIfAbsent(name,\n+                n -> spinByteCode(name, c, target.type()));\n+        try {\n+            var lookup = JLIA.defineHiddenClassWithClassData(LOOKUP, cn, bytes, target, true);\n+            var ctor = lookup.findConstructor(lookup.lookupClass(), methodType(void.class));\n+            ctor = ctor.asType(methodType(MHInvoker.class));\n+            return (MHInvoker) ctor.invokeExact();\n+        } catch (Throwable e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+\n+    private static final ConcurrentHashMap<String, byte[]> ACCESSOR_CLASSFILES = new ConcurrentHashMap<>();\n+    private static final String FIELD_CLASS_NAME_PREFIX = \"jdk\/internal\/reflect\/FieldAccessorImpl_\";\n+    private static final String METHOD_CLASS_NAME_PREFIX = \"jdk\/internal\/reflect\/MethodAccessorImpl_\";\n+    private static final String CONSTRUCTOR_CLASS_NAME_PREFIX = \"jdk\/internal\/reflect\/ConstructorAccessorImpl_\";\n+\n+    \/\/ Used to ensure that each spun class name is unique\n+    private static final AtomicInteger counter = new AtomicInteger();\n+\n+    private static String classNamePrefix(Field field) {\n+        var isStatic = Modifier.isStatic(field.getModifiers());\n+        var isVolatile = Modifier.isVolatile(field.getModifiers());\n+        var type = field.getType();\n+        var desc = type.isPrimitive() ? type.descriptorString() : \"L\";\n+        return FIELD_CLASS_NAME_PREFIX + (isStatic ? desc : \"L\" + desc) + (isVolatile ? \"_V\" : \"\");\n+    }\n+    private static String classNamePrefix(Method method, MethodType mtype, boolean hasCallerParameter) {\n+        var isStatic = Modifier.isStatic(method.getModifiers());\n+        var methodTypeName = methodTypeName(isStatic, hasCallerParameter, mtype);\n+        return METHOD_CLASS_NAME_PREFIX + methodTypeName;\n+    }\n+    private static String classNamePrefix(Constructor<?> c, MethodType mtype) {\n+        var methodTypeName = methodTypeName(true, false, mtype);\n+        return CONSTRUCTOR_CLASS_NAME_PREFIX + methodTypeName;\n+    }\n+\n+    \/**\n+     * Returns a string to represent the specialized method type.\n+     *\/\n+    private static String methodTypeName(boolean isStatic, boolean hasCallerParameter, MethodType mtype) {\n+        StringBuilder sb = new StringBuilder();\n+        int pIndex = 0;\n+        if (!isStatic) {\n+            sb.append(\"L\");\n+            pIndex++;\n+        }\n+        int paramCount = mtype.parameterCount() - (hasCallerParameter ? 1 : 0);\n+        for (;pIndex < paramCount; pIndex++) {\n+            Class<?> ptype = mtype.parameterType(pIndex);\n+            if (ptype == Object[].class) {\n+                sb.append(\"A\");\n+            } else {\n+                assert ptype == Object.class;\n+                sb.append(\"L\");\n+            }\n+        }\n+        if (hasCallerParameter) {\n+            sb.append(\"Class\");\n+            pIndex++;\n+        }\n+        return sb.toString();\n+    }\n+\n+    private static byte[] spinByteCode(String cn, Field field) {\n+        var builder = new ClassByteBuilder(cn, VarHandle.class);\n+        var bytes = builder.buildVarHandleInvoker(field);\n+        maybeDumpClassFile(cn, bytes);\n+        return bytes;\n+    }\n+    private static byte[] spinByteCode(String cn, Method method, MethodType mtype, boolean hasCallerParameter) {\n+        var builder = new ClassByteBuilder(cn, MethodHandle.class);\n+        var bytes = builder.buildMethodHandleInvoker(method, mtype, hasCallerParameter);\n+        maybeDumpClassFile(cn, bytes);\n+        return bytes;\n+    }\n+    private static byte[] spinByteCode(String cn, Constructor<?> ctor, MethodType mtype) {\n+        var builder = new ClassByteBuilder(cn, MethodHandle.class);\n+        var bytes = builder.buildMethodHandleInvoker(ctor, mtype);\n+        maybeDumpClassFile(cn, bytes);\n+        return bytes;\n+    }\n+    private static void maybeDumpClassFile(String classname, byte[] bytes) {\n+        if (DUMP_CLASS_FILES != null) {\n+            try {\n+                Path p = DUMP_CLASS_FILES.resolve(classname + \".class\");\n+                Files.createDirectories(p.getParent());\n+                try (OutputStream os = Files.newOutputStream(p)) {\n+                    os.write(bytes);\n+                }\n+            } catch (IOException e) {\n+                throw new UncheckedIOException(e);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Ensures the given class is initialized.  If this is called from <clinit>,\n+     * this method returns but defc's class initialization is not completed.\n+     *\/\n+    static void ensureClassInitialized(Class<?> defc) {\n+        if (UNSAFE.shouldBeInitialized(defc)) {\n+            UNSAFE.ensureClassInitialized(defc);\n+        }\n+    }\n+\n+    private static final MethodHandles.Lookup LOOKUP = MethodHandles.lookup();\n+    private static final JavaLangInvokeAccess JLIA = SharedSecrets.getJavaLangInvokeAccess();\n+    private static final Path DUMP_CLASS_FILES;\n+\n+    static {\n+        String dumpPath = GetPropertyAction.privilegedGetProperty(\"jdk.reflect.dumpClassPath\");\n+        if (dumpPath != null) {\n+            DUMP_CLASS_FILES = Path.of(dumpPath);\n+        } else {\n+            DUMP_CLASS_FILES = null;\n+        }\n+    }\n+}\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MethodHandleAccessorFactory.java","additions":433,"deletions":0,"binary":false,"changes":433,"status":"added"},{"patch":"@@ -28,2 +28,0 @@\n-import sun.reflect.misc.ReflectUtil;\n-\n@@ -55,1 +53,1 @@\n-        \/\/ We can't inflate a constructor belonging to a vm-anonymous class\n+        \/\/ We can't inflate a constructor belonging to a hidden class\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/NativeConstructorAccessorImpl.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import sun.reflect.misc.ReflectUtil;\n-\n@@ -53,1 +51,1 @@\n-        \/\/ We can't inflate methods belonging to vm-anonymous classes because\n+        \/\/ We can't inflate methods belonging to hidden classes because\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/NativeMethodAccessorImpl.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -88,0 +88,2 @@\n+    private static boolean useDirectMethodHandle = true;\n+    private static boolean useNativeAccessorOnly = false;  \/\/ for testing only\n@@ -141,18 +143,0 @@\n-    \/**\n-     * Returns an alternate reflective Method instance for the given method\n-     * intended for reflection to invoke, if present.\n-     *\n-     * A trusted method can define an alternate implementation for a method `foo`\n-     * by defining a method named \"reflected$foo\" that will be invoked\n-     * reflectively.\n-     *\/\n-    private static Method findMethodForReflection(Method method) {\n-        String altName = \"reflected$\" + method.getName();\n-        try {\n-           return method.getDeclaringClass()\n-                        .getDeclaredMethod(altName, method.getParameterTypes());\n-        } catch (NoSuchMethodException ex) {\n-            return null;\n-        }\n-    }\n-\n@@ -185,1 +169,14 @@\n-        return UnsafeFieldAccessorFactory.newFieldAccessor(field, isReadOnly);\n+        if (useDirectMethodHandle) {\n+            \/\/ Core reflection is supported after java.lang.invoke completes initialization.\n+            \/\/ java.lang.invoke initialization starts soon after System::initPhase1\n+            \/\/ and method handles are ready for use when initPhase2 begins.\n+            \/\/ During early VM startup (initPhase1), fields are accessed directly from\n+            \/\/ the VM or through JNI.  It should avoid using core reflection.\n+            if (!VM.isJavaLangInvokeInited()) {\n+                throw new InternalError(field.getDeclaringClass().getName() + \"::\" + field.getName() +\n+                        \" cannot be accessed reflectively before java.lang.invoke is initialized\");\n+            }\n+            return MethodHandleAccessorFactory.newFieldAccessor(field, isReadOnly);\n+        } else {\n+            return UnsafeFieldAccessorFactory.newFieldAccessor(field, isReadOnly);\n+        }\n@@ -188,1 +185,1 @@\n-    public MethodAccessor newMethodAccessor(Method method) {\n+    public MethodAccessor newMethodAccessor(Method method, boolean callerSensitive) {\n@@ -191,7 +188,0 @@\n-        if (Reflection.isCallerSensitive(method)) {\n-            Method altMethod = findMethodForReflection(method);\n-            if (altMethod != null) {\n-                method = altMethod;\n-            }\n-        }\n-\n@@ -204,8 +194,5 @@\n-        if (noInflation && !method.getDeclaringClass().isHidden()) {\n-            return new MethodAccessorGenerator().\n-                generateMethod(method.getDeclaringClass(),\n-                               method.getName(),\n-                               method.getParameterTypes(),\n-                               method.getReturnType(),\n-                               method.getExceptionTypes(),\n-                               method.getModifiers());\n+        if (useDirectMethodHandle) {\n+            if (useNativeAccessor(method)) {\n+                return DirectMethodAccessorImpl.nativeAccessor(method, callerSensitive);\n+            }\n+            return MethodHandleAccessorFactory.newMethodAccessor(method, callerSensitive);\n@@ -213,6 +200,9 @@\n-            NativeMethodAccessorImpl acc =\n-                new NativeMethodAccessorImpl(method);\n-            DelegatingMethodAccessorImpl res =\n-                new DelegatingMethodAccessorImpl(acc);\n-            acc.setParent(res);\n-            return res;\n+            if (!useDirectMethodHandle && noInflation\n+                    && !method.getDeclaringClass().isHidden()) {\n+                return generateMethodAccessor(method);\n+            } else {\n+                NativeMethodAccessorImpl acc = new NativeMethodAccessorImpl(method);\n+                DelegatingMethodAccessorImpl res = new DelegatingMethodAccessorImpl(acc);\n+                acc.setParent(res);\n+                return res;\n+            }\n@@ -222,0 +212,14 @@\n+    \/**\n+     * Generate the MethodAccessor that invokes the given method with\n+     * bytecode invocation.\n+     *\/\n+    static MethodAccessorImpl generateMethodAccessor(Method method) {\n+        return (MethodAccessorImpl)new MethodAccessorGenerator()\n+                .generateMethod(method.getDeclaringClass(),\n+                                method.getName(),\n+                                method.getParameterTypes(),\n+                                method.getReturnType(),\n+                                method.getExceptionTypes(),\n+                                method.getModifiers());\n+    }\n+\n@@ -240,6 +244,24 @@\n-        \/\/ Bootstrapping issue: since we use Class.newInstance() in\n-        \/\/ the ConstructorAccessor generation process, we have to\n-        \/\/ break the cycle here.\n-        if (Reflection.isSubclassOf(declaringClass,\n-                                    ConstructorAccessorImpl.class)) {\n-            return new BootstrapConstructorAccessorImpl(c);\n+        if (useDirectMethodHandle) {\n+            if (useNativeAccessor(c)) {\n+                return DirectConstructorAccessorImpl.nativeAccessor(c);\n+            }\n+            return MethodHandleAccessorFactory.newConstructorAccessor(c);\n+        } else {\n+            if (noInflation && !c.getDeclaringClass().isHidden()) {\n+                \/\/ Bootstrapping issue: since we use Class.newInstance() in\n+                \/\/ the ConstructorAccessor generation process, we have to\n+                \/\/ break the cycle here.\n+                if (Reflection.isSubclassOf(declaringClass, ConstructorAccessorImpl.class)) {\n+                    return new BootstrapConstructorAccessorImpl(c);\n+                }\n+                return new MethodAccessorGenerator().\n+                        generateConstructor(c.getDeclaringClass(),\n+                                            c.getParameterTypes(),\n+                                            c.getExceptionTypes(),\n+                                            c.getModifiers());\n+            } else {\n+                NativeConstructorAccessorImpl acc = new NativeConstructorAccessorImpl(c);\n+                DelegatingConstructorAccessorImpl res = new DelegatingConstructorAccessorImpl(acc);\n+                acc.setParent(res);\n+                return res;\n+            }\n@@ -247,0 +269,1 @@\n+    }\n@@ -248,13 +271,24 @@\n-        if (noInflation && !c.getDeclaringClass().isHidden()) {\n-            return new MethodAccessorGenerator().\n-                generateConstructor(c.getDeclaringClass(),\n-                                    c.getParameterTypes(),\n-                                    c.getExceptionTypes(),\n-                                    c.getModifiers());\n-        } else {\n-            NativeConstructorAccessorImpl acc =\n-                new NativeConstructorAccessorImpl(c);\n-            DelegatingConstructorAccessorImpl res =\n-                new DelegatingConstructorAccessorImpl(acc);\n-            acc.setParent(res);\n-            return res;\n+    \/*\n+     * Returns true if NativeAccessor should be used.\n+     *\/\n+    private static boolean useNativeAccessor(Executable member) {\n+        if (!VM.isJavaLangInvokeInited())\n+            return true;\n+\n+        if (Modifier.isNative(member.getModifiers()))\n+            return true;\n+\n+        if (useNativeAccessorOnly)  \/\/ for testing only\n+            return true;\n+\n+        \/\/ MethodHandle::withVarargs on a member with varargs modifier bit set\n+        \/\/ verifies that the last parameter of the member must be an array type.\n+        \/\/ The JVMS does not require the last parameter descriptor of the method descriptor\n+        \/\/ is an array type if the ACC_VARARGS flag is set in the access_flags item.\n+        \/\/ Hence the reflection implementation does not check the last parameter type\n+        \/\/ if ACC_VARARGS flag is set.  Workaround this by invoking through\n+        \/\/ the native accessor.\n+        int paramCount = member.getParameterCount();\n+        if (member.isVarArgs() &&\n+                (paramCount == 0 || !(member.getParameterTypes()[paramCount-1].isArray()))) {\n+            return true;\n@@ -262,0 +296,1 @@\n+        return false;\n@@ -635,0 +670,8 @@\n+    static boolean noInflation() {\n+        return noInflation;\n+    }\n+\n+    static boolean useDirectMethodHandle() {\n+        return useDirectMethodHandle;\n+    }\n+\n@@ -664,0 +707,8 @@\n+        val = props.getProperty(\"jdk.reflect.useDirectMethodHandle\");\n+        if (val != null && val.equals(\"false\")) {\n+            useDirectMethodHandle = false;\n+        }\n+        val = props.getProperty(\"jdk.reflect.useNativeAccessorOnly\");\n+        if (val != null && val.equals(\"true\")) {\n+            useNativeAccessorOnly = true;\n+        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/ReflectionFactory.java","additions":111,"deletions":60,"binary":false,"changes":171,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-    protected final Field   field;\n@@ -45,1 +44,0 @@\n-\n@@ -47,2 +45,4 @@\n-        this.field = field;\n-        if (Modifier.isStatic(field.getModifiers()))\n+        super(field);\n+        int mods = field.getModifiers();\n+        this.isFinal = Modifier.isFinal(mods);\n+        if (Modifier.isStatic(mods))\n@@ -52,73 +52,0 @@\n-        isFinal = Modifier.isFinal(field.getModifiers());\n-    }\n-\n-    protected void ensureObj(Object o) {\n-        \/\/ NOTE: will throw NullPointerException, as specified, if o is null\n-        if (!field.getDeclaringClass().isAssignableFrom(o.getClass())) {\n-            throwSetIllegalArgumentException(o);\n-        }\n-    }\n-\n-    private String getQualifiedFieldName() {\n-      return field.getDeclaringClass().getName() + \".\" +field.getName();\n-    }\n-\n-    protected IllegalArgumentException newGetIllegalArgumentException(String type) {\n-        return new IllegalArgumentException(\n-          \"Attempt to get \"+field.getType().getName()+\" field \\\"\" +\n-          getQualifiedFieldName() + \"\\\" with illegal data type conversion to \"+type\n-        );\n-    }\n-\n-    protected void throwFinalFieldIllegalAccessException(String attemptedType,\n-                                                         String attemptedValue)\n-                                                         throws IllegalAccessException {\n-        throw new IllegalAccessException(getSetMessage(attemptedType, attemptedValue));\n-\n-    }\n-    protected void throwFinalFieldIllegalAccessException(Object o) throws IllegalAccessException {\n-        throwFinalFieldIllegalAccessException(o != null ? o.getClass().getName() : \"\", \"\");\n-    }\n-\n-    protected void throwFinalFieldIllegalAccessException(boolean z) throws IllegalAccessException {\n-        throwFinalFieldIllegalAccessException(\"boolean\", Boolean.toString(z));\n-    }\n-\n-    protected void throwFinalFieldIllegalAccessException(char b) throws IllegalAccessException {\n-        throwFinalFieldIllegalAccessException(\"char\", Character.toString(b));\n-    }\n-\n-    protected void throwFinalFieldIllegalAccessException(byte b) throws IllegalAccessException {\n-        throwFinalFieldIllegalAccessException(\"byte\", Byte.toString(b));\n-    }\n-\n-    protected void throwFinalFieldIllegalAccessException(short b) throws IllegalAccessException {\n-        throwFinalFieldIllegalAccessException(\"short\", Short.toString(b));\n-    }\n-\n-    protected void throwFinalFieldIllegalAccessException(int i) throws IllegalAccessException {\n-        throwFinalFieldIllegalAccessException(\"int\", Integer.toString(i));\n-    }\n-\n-    protected void throwFinalFieldIllegalAccessException(long i) throws IllegalAccessException {\n-        throwFinalFieldIllegalAccessException(\"long\", Long.toString(i));\n-    }\n-\n-    protected void throwFinalFieldIllegalAccessException(float f) throws IllegalAccessException {\n-        throwFinalFieldIllegalAccessException(\"float\", Float.toString(f));\n-    }\n-\n-    protected void throwFinalFieldIllegalAccessException(double f) throws IllegalAccessException {\n-        throwFinalFieldIllegalAccessException(\"double\", Double.toString(f));\n-    }\n-\n-    protected IllegalArgumentException newGetBooleanIllegalArgumentException() {\n-        return newGetIllegalArgumentException(\"boolean\");\n-    }\n-\n-    protected IllegalArgumentException newGetByteIllegalArgumentException() {\n-        return newGetIllegalArgumentException(\"byte\");\n-    }\n-\n-    protected IllegalArgumentException newGetCharIllegalArgumentException() {\n-        return newGetIllegalArgumentException(\"char\");\n@@ -126,80 +53,0 @@\n-\n-    protected IllegalArgumentException newGetShortIllegalArgumentException() {\n-        return newGetIllegalArgumentException(\"short\");\n-    }\n-\n-    protected IllegalArgumentException newGetIntIllegalArgumentException() {\n-        return newGetIllegalArgumentException(\"int\");\n-    }\n-\n-    protected IllegalArgumentException newGetLongIllegalArgumentException() {\n-        return newGetIllegalArgumentException(\"long\");\n-    }\n-\n-    protected IllegalArgumentException newGetFloatIllegalArgumentException() {\n-        return newGetIllegalArgumentException(\"float\");\n-    }\n-\n-    protected IllegalArgumentException newGetDoubleIllegalArgumentException() {\n-        return newGetIllegalArgumentException(\"double\");\n-    }\n-\n-    protected String getSetMessage(String attemptedType, String attemptedValue) {\n-        String err = \"Can not set\";\n-        if (Modifier.isStatic(field.getModifiers()))\n-            err += \" static\";\n-        if (isFinal)\n-            err += \" final\";\n-        err += \" \" + field.getType().getName() + \" field \" + getQualifiedFieldName() + \" to \";\n-        if (!attemptedValue.isEmpty()) {\n-            err += \"(\" + attemptedType + \")\" + attemptedValue;\n-        } else {\n-            if (!attemptedType.isEmpty())\n-                err += attemptedType;\n-            else\n-                err += \"null value\";\n-        }\n-        return err;\n-    }\n-\n-    protected void throwSetIllegalArgumentException(String attemptedType,\n-                                                    String attemptedValue) {\n-        throw new IllegalArgumentException(getSetMessage(attemptedType,attemptedValue));\n-    }\n-\n-    protected void throwSetIllegalArgumentException(Object o) {\n-        throwSetIllegalArgumentException(o != null ? o.getClass().getName() : \"\", \"\");\n-    }\n-\n-    protected void throwSetIllegalArgumentException(boolean b) {\n-        throwSetIllegalArgumentException(\"boolean\", Boolean.toString(b));\n-    }\n-\n-    protected void throwSetIllegalArgumentException(byte b) {\n-        throwSetIllegalArgumentException(\"byte\", Byte.toString(b));\n-    }\n-\n-    protected void throwSetIllegalArgumentException(char c) {\n-        throwSetIllegalArgumentException(\"char\", Character.toString(c));\n-    }\n-\n-    protected void throwSetIllegalArgumentException(short s) {\n-        throwSetIllegalArgumentException(\"short\", Short.toString(s));\n-    }\n-\n-    protected void throwSetIllegalArgumentException(int i) {\n-        throwSetIllegalArgumentException(\"int\", Integer.toString(i));\n-    }\n-\n-    protected void throwSetIllegalArgumentException(long l) {\n-        throwSetIllegalArgumentException(\"long\", Long.toString(l));\n-    }\n-\n-    protected void throwSetIllegalArgumentException(float f) {\n-        throwSetIllegalArgumentException(\"float\", Float.toString(f));\n-    }\n-\n-    protected void throwSetIllegalArgumentException(double d) {\n-        throwSetIllegalArgumentException(\"double\", Double.toString(d));\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/UnsafeFieldAccessorImpl.java","additions":4,"deletions":157,"binary":false,"changes":161,"status":"modified"},{"patch":"@@ -0,0 +1,174 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.reflect;\n+\n+public interface VHInvoker {\n+    \/\/ accessors for instance fields\n+    default Object get(Object obj) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    default boolean getBoolean(Object obj) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    default byte getByte(Object obj) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    default char getChar(Object obj) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    default short getShort(Object obj) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    default int getInt(Object obj) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    default long getLong(Object obj) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    default float getFloat(Object obj) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    default double getDouble(Object obj) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    default void set(Object obj, Object value) throws Throwable {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    default void setBoolean(Object obj, boolean z) throws Throwable {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    default void setByte(Object obj, byte b) throws Throwable {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    default void setChar(Object obj, char c) throws Throwable {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    default void setShort(Object obj, short s) throws Throwable {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    default void setInt(Object obj, int i) throws Throwable {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    default void setLong(Object obj, long l) throws Throwable {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    default void setFloat(Object obj, float f) throws Throwable {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    default void setDouble(Object obj, double d) throws Throwable {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    \/\/ accessors for static fields\n+    default Object get() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    default boolean getBoolean() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    default byte getByte() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    default char getChar() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    default short getShort() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    default int getInt() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    default long getLong() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    default float getFloat() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    default double getDouble() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    default void set(Object value) throws Throwable {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    default void setBoolean(boolean z) throws Throwable {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    default void setByte(byte b) throws Throwable {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    default void setChar(char c) throws Throwable {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    default void setShort(short s) throws Throwable {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    default void setInt(int i) throws Throwable {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    default void setLong(long l) throws Throwable {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    default void setFloat(float f) throws Throwable {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    default void setDouble(double d) throws Throwable {\n+        throw new UnsupportedOperationException();\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/VHInvoker.java","additions":174,"deletions":0,"binary":false,"changes":174,"status":"added"},{"patch":"@@ -0,0 +1,186 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.reflect;\n+\n+import jdk.internal.vm.annotation.Hidden;\n+\n+import java.lang.invoke.VarHandle;\n+\n+\/**\n+ * Delegate the field access directly to the target VarHandle.\n+ *\/\n+final class VHInvokerDelegate implements VHInvoker {\n+    private final VarHandle varHandle;\n+    VHInvokerDelegate(VarHandle varHandle) {\n+        this.varHandle = varHandle;\n+    }\n+\n+    \/\/ accessors for instance fields\n+    @Hidden public Object get(Object obj) {\n+        return varHandle.get(obj);\n+    }\n+\n+    @Hidden public boolean getBoolean(Object obj) {\n+        return (boolean) varHandle.get(obj);\n+    }\n+\n+    @Hidden public byte getByte(Object obj) {\n+        return (byte) varHandle.get(obj);\n+    }\n+\n+    @Hidden public char getChar(Object obj) {\n+        return (char) varHandle.get(obj);\n+    }\n+\n+    @Hidden public short getShort(Object obj) {\n+        return (short) varHandle.get(obj);\n+    }\n+\n+    @Hidden public int getInt(Object obj) {\n+        return (int) varHandle.get(obj);\n+    }\n+\n+    @Hidden public long getLong(Object obj) {\n+        return (long) varHandle.get(obj);\n+    }\n+\n+    @Hidden public float getFloat(Object obj) {\n+        return (float) varHandle.get(obj);\n+    }\n+\n+    @Hidden public double getDouble(Object obj) {\n+        return (double) varHandle.get(obj);\n+    }\n+\n+    @Hidden public void set(Object obj, Object value) throws Throwable {\n+        varHandle.set(obj, value);\n+    }\n+\n+    @Hidden public void setBoolean(Object obj, boolean z) throws Throwable {\n+        varHandle.set(obj, z);\n+    }\n+\n+    @Hidden public void setByte(Object obj, byte b) throws Throwable {\n+        varHandle.set(obj, b);\n+    }\n+\n+    @Hidden public void setChar(Object obj, char c) throws Throwable {\n+        varHandle.set(obj, c);\n+    }\n+\n+    @Hidden public void setShort(Object obj, short s) throws Throwable {\n+        varHandle.set(obj, s);\n+    }\n+\n+    @Hidden public void setInt(Object obj, int i) throws Throwable {\n+        varHandle.set(obj, i);\n+    }\n+\n+    @Hidden public void setLong(Object obj, long l) throws Throwable {\n+        varHandle.set(obj, l);\n+    }\n+\n+    @Hidden public void setFloat(Object obj, float f) throws Throwable {\n+        varHandle.set(obj, f);\n+    }\n+\n+    @Hidden public void setDouble(Object obj, double d) throws Throwable {\n+        varHandle.set(obj, d);\n+    }\n+\n+    \/\/ accessors for static fields\n+    @Hidden public Object get() {\n+        return varHandle.get();\n+    }\n+\n+    @Hidden public boolean getBoolean() {\n+        return (boolean) varHandle.get();\n+    }\n+\n+    @Hidden public byte getByte() {\n+        return (byte) varHandle.get();\n+    }\n+\n+    @Hidden public char getChar() {\n+        return (char) varHandle.get();\n+    }\n+\n+    @Hidden public short getShort() {\n+        return (short) varHandle.get();\n+    }\n+\n+    @Hidden public int getInt() {\n+        return (int) varHandle.get();\n+    }\n+\n+    @Hidden public long getLong() {\n+        return (long) varHandle.get();\n+    }\n+\n+    @Hidden public float getFloat() {\n+        return (float) varHandle.get();\n+    }\n+\n+    @Hidden public double getDouble() {\n+        return (double) varHandle.get();\n+    }\n+\n+    @Hidden public void set(Object value) throws Throwable {\n+        varHandle.set(value);\n+    }\n+\n+    @Hidden public void setBoolean(boolean z) throws Throwable {\n+        varHandle.set(z);\n+    }\n+\n+    @Hidden public void setByte(byte b) throws Throwable {\n+        varHandle.set(b);\n+    }\n+\n+    @Hidden public void setChar(char c) throws Throwable {\n+        varHandle.set(c);\n+    }\n+\n+    @Hidden public void setShort(short s) throws Throwable {\n+        varHandle.set(s);\n+    }\n+\n+    @Hidden public void setInt(int i) throws Throwable {\n+        varHandle.set(i);\n+    }\n+\n+    @Hidden public void setLong(long l) throws Throwable {\n+        varHandle.set(l);\n+    }\n+\n+    @Hidden public void setFloat(float f) throws Throwable {\n+        varHandle.set(f);\n+    }\n+\n+    @Hidden public void setDouble(double d) throws Throwable {\n+        varHandle.set(d);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/VHInvokerDelegate.java","additions":186,"deletions":0,"binary":false,"changes":186,"status":"added"},{"patch":"@@ -0,0 +1,197 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.reflect;\n+\n+import java.lang.invoke.VarHandle;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+\n+abstract class VarHandleBooleanFieldAccessorImpl extends VarHandleFieldAccessorImpl {\n+    static FieldAccessorImpl fieldAccessor(Field field, VarHandle varHandle, boolean isReadOnly) {\n+        return Modifier.isStatic(field.getModifiers())\n+                ? new StaticFieldAccessor(field, varHandle, isReadOnly)\n+                : new InstanceFieldAccessor(field, varHandle, isReadOnly);\n+    }\n+\n+    VarHandleBooleanFieldAccessorImpl(Field field, VarHandle varHandle, boolean isReadOnly) {\n+        super(field, varHandle, isReadOnly);\n+    }\n+\n+    abstract boolean getValue(Object obj);\n+    abstract void setValue(Object obj, boolean z) throws Throwable;\n+\n+    static class StaticFieldAccessor extends VarHandleBooleanFieldAccessorImpl {\n+        StaticFieldAccessor(Field field, VarHandle varHandle, boolean isReadOnly) {\n+            super(field, varHandle, isReadOnly);\n+        }\n+\n+        boolean getValue(Object obj) {\n+            return accessor().getBoolean();\n+        }\n+\n+        void setValue(Object obj, boolean z) throws Throwable {\n+            accessor().setBoolean(z);\n+        }\n+\n+        protected void ensureObj(Object o) {}\n+    }\n+\n+    static class InstanceFieldAccessor extends VarHandleBooleanFieldAccessorImpl {\n+        InstanceFieldAccessor(Field field, VarHandle varHandle, boolean isReadOnly) {\n+            super(field, varHandle, isReadOnly);\n+        }\n+\n+        boolean getValue(Object obj) {\n+            return accessor().getBoolean(obj);\n+        }\n+\n+        void setValue(Object obj, boolean z) throws Throwable {\n+            accessor().setBoolean(obj, z);\n+        }\n+    }\n+\n+    public Object get(Object obj) throws IllegalArgumentException {\n+        return Boolean.valueOf(getBoolean(obj));\n+    }\n+\n+    public boolean getBoolean(Object obj) throws IllegalArgumentException {\n+        ensureObj(obj);\n+        try {\n+            return getValue(obj);\n+        } catch (IllegalArgumentException|NullPointerException e) {\n+            throw e;\n+        } catch (ClassCastException e) {\n+            throw newGetIllegalArgumentException(obj.getClass());\n+        } catch (Throwable e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+\n+    public byte getByte(Object obj) throws IllegalArgumentException {\n+        throw newGetByteIllegalArgumentException();\n+    }\n+\n+    public char getChar(Object obj) throws IllegalArgumentException {\n+        throw newGetCharIllegalArgumentException();\n+    }\n+\n+    public short getShort(Object obj) throws IllegalArgumentException {\n+        throw newGetShortIllegalArgumentException();\n+    }\n+\n+    public int getInt(Object obj) throws IllegalArgumentException {\n+        throw newGetIntIllegalArgumentException();\n+    }\n+\n+    public long getLong(Object obj) throws IllegalArgumentException {\n+        throw newGetLongIllegalArgumentException();\n+    }\n+\n+    public float getFloat(Object obj) throws IllegalArgumentException {\n+        throw newGetFloatIllegalArgumentException();\n+    }\n+\n+    public double getDouble(Object obj) throws IllegalArgumentException {\n+        throw newGetDoubleIllegalArgumentException();\n+    }\n+\n+    public void set(Object obj, Object value)\n+            throws IllegalArgumentException, IllegalAccessException\n+    {\n+        ensureObj(obj);\n+        if (isReadOnly) {\n+            throwFinalFieldIllegalAccessException(value);\n+        }\n+        if (value == null) {\n+            throwSetIllegalArgumentException(value);\n+        }\n+        if (value instanceof Boolean) {\n+            setBoolean(obj, ((Boolean) value).booleanValue());\n+            return;\n+        }\n+        throwSetIllegalArgumentException(value);\n+    }\n+\n+    public void setBoolean(Object obj, boolean z)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        ensureObj(obj);\n+        if (isReadOnly) {\n+            throwFinalFieldIllegalAccessException(z);\n+        }\n+        try {\n+            setValue(obj, z);\n+        } catch (IllegalArgumentException|NullPointerException e) {\n+            throw e;\n+        } catch (ClassCastException e) {\n+            throw newSetIllegalArgumentException(obj.getClass());\n+        } catch (Throwable e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+\n+    public void setByte(Object obj, byte b)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(b);\n+    }\n+\n+    public void setChar(Object obj, char c)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(c);\n+    }\n+\n+    public void setShort(Object obj, short s)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(s);\n+    }\n+\n+    public void setInt(Object obj, int i)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(i);\n+    }\n+\n+    public void setLong(Object obj, long l)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(l);\n+    }\n+\n+    public void setFloat(Object obj, float f)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(f);\n+    }\n+\n+    public void setDouble(Object obj, double d)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(d);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/VarHandleBooleanFieldAccessorImpl.java","additions":197,"deletions":0,"binary":false,"changes":197,"status":"added"},{"patch":"@@ -0,0 +1,196 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.reflect;\n+\n+import java.lang.invoke.VarHandle;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+\n+abstract class VarHandleByteFieldAccessorImpl extends VarHandleFieldAccessorImpl {\n+    static FieldAccessorImpl fieldAccessor(Field field, VarHandle varHandle, boolean isReadOnly) {\n+        return Modifier.isStatic(field.getModifiers())\n+                ? new StaticFieldAccessor(field, varHandle, isReadOnly)\n+                : new InstanceFieldAccessor(field, varHandle, isReadOnly);\n+    }\n+\n+    VarHandleByteFieldAccessorImpl(Field field, VarHandle varHandle, boolean isReadOnly) {\n+        super(field, varHandle, isReadOnly);\n+    }\n+\n+    abstract byte getValue(Object obj);\n+    abstract void setValue(Object obj, byte b) throws Throwable;\n+\n+    static class StaticFieldAccessor extends VarHandleByteFieldAccessorImpl {\n+        StaticFieldAccessor(Field field, VarHandle varHandle, boolean isReadOnly) {\n+            super(field, varHandle, isReadOnly);\n+        }\n+\n+        byte getValue(Object obj) {\n+            return accessor().getByte();\n+        }\n+\n+        void setValue(Object obj, byte b) throws Throwable {\n+            accessor().setByte(b);\n+        }\n+\n+        protected void ensureObj(Object o) {}\n+    }\n+\n+    static class InstanceFieldAccessor extends VarHandleByteFieldAccessorImpl {\n+        InstanceFieldAccessor(Field field, VarHandle varHandle, boolean isReadOnly) {\n+            super(field, varHandle, isReadOnly);\n+        }\n+\n+        byte getValue(Object obj) {\n+            return accessor().getByte(obj);\n+        }\n+\n+        void setValue(Object obj, byte b) throws Throwable {\n+            accessor().setByte(obj, b);\n+        }\n+    }\n+\n+    public Object get(Object obj) throws IllegalArgumentException {\n+        return Byte.valueOf(getByte(obj));\n+    }\n+\n+    public boolean getBoolean(Object obj) throws IllegalArgumentException {\n+        throw newGetBooleanIllegalArgumentException();\n+    }\n+\n+    public byte getByte(Object obj) throws IllegalArgumentException {\n+        try {\n+            return getValue(obj);\n+        } catch (IllegalArgumentException|NullPointerException e) {\n+            throw e;\n+        } catch (ClassCastException e) {\n+            throw newGetIllegalArgumentException(obj.getClass());\n+        } catch (Throwable e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+\n+    public char getChar(Object obj) throws IllegalArgumentException {\n+        throw newGetCharIllegalArgumentException();\n+    }\n+\n+    public short getShort(Object obj) throws IllegalArgumentException {\n+        return getByte(obj);\n+    }\n+\n+    public int getInt(Object obj) throws IllegalArgumentException {\n+        return getByte(obj);\n+    }\n+\n+    public long getLong(Object obj) throws IllegalArgumentException {\n+        return getByte(obj);\n+    }\n+\n+    public float getFloat(Object obj) throws IllegalArgumentException {\n+        return getByte(obj);\n+    }\n+\n+    public double getDouble(Object obj) throws IllegalArgumentException {\n+        return getByte(obj);\n+    }\n+\n+    public void set(Object obj, Object value)\n+            throws IllegalArgumentException, IllegalAccessException\n+    {\n+        ensureObj(obj);\n+        if (isReadOnly) {\n+            throwFinalFieldIllegalAccessException(value);\n+        }\n+        if (value == null) {\n+            throwSetIllegalArgumentException(value);\n+        }\n+        if (value instanceof Byte) {\n+            setByte(obj, ((Byte) value).byteValue());\n+            return;\n+        }\n+        throwSetIllegalArgumentException(value);\n+    }\n+\n+    public void setBoolean(Object obj, boolean z)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(z);\n+    }\n+\n+    public void setByte(Object obj, byte b)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        ensureObj(obj);\n+        if (isReadOnly) {\n+            throwFinalFieldIllegalAccessException(b);\n+        }\n+        try {\n+            setValue(obj, b);\n+        } catch (IllegalArgumentException|NullPointerException e) {\n+            throw e;\n+        } catch (ClassCastException e) {\n+            throw newSetIllegalArgumentException(obj.getClass());\n+        } catch (Throwable e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+\n+    public void setChar(Object obj, char c)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(c);\n+    }\n+\n+    public void setShort(Object obj, short s)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(s);\n+    }\n+\n+    public void setInt(Object obj, int i)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(i);\n+    }\n+\n+    public void setLong(Object obj, long l)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(l);\n+    }\n+\n+    public void setFloat(Object obj, float f)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(f);\n+    }\n+\n+    public void setDouble(Object obj, double d)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(d);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/VarHandleByteFieldAccessorImpl.java","additions":196,"deletions":0,"binary":false,"changes":196,"status":"added"},{"patch":"@@ -0,0 +1,196 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.reflect;\n+\n+import java.lang.invoke.VarHandle;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+\n+abstract class VarHandleCharacterFieldAccessorImpl extends VarHandleFieldAccessorImpl {\n+    static FieldAccessorImpl fieldAccessor(Field field, VarHandle varHandle, boolean isReadOnly) {\n+        return Modifier.isStatic(field.getModifiers())\n+                ? new StaticFieldAccessor(field, varHandle, isReadOnly)\n+                : new InstanceFieldAccessor(field, varHandle, isReadOnly);\n+    }\n+\n+    VarHandleCharacterFieldAccessorImpl(Field field, VarHandle varHandle, boolean isReadOnly) {\n+        super(field, varHandle, isReadOnly);\n+    }\n+\n+    abstract char getValue(Object obj);\n+    abstract void setValue(Object obj, char c) throws Throwable;\n+\n+    static class StaticFieldAccessor extends VarHandleCharacterFieldAccessorImpl {\n+        StaticFieldAccessor(Field field, VarHandle varHandle, boolean isReadOnly) {\n+            super(field, varHandle, isReadOnly);\n+        }\n+\n+        char getValue(Object obj) {\n+            return accessor().getChar();\n+        }\n+\n+        void setValue(Object obj, char c) throws Throwable {\n+            accessor().setChar(c);\n+        }\n+\n+        protected void ensureObj(Object o) {}\n+    }\n+\n+    static class InstanceFieldAccessor extends VarHandleCharacterFieldAccessorImpl {\n+        InstanceFieldAccessor(Field field, VarHandle varHandle, boolean isReadOnly) {\n+            super(field, varHandle, isReadOnly);\n+        }\n+\n+        char getValue(Object obj) {\n+            return accessor().getChar(obj);\n+        }\n+\n+        void setValue(Object obj, char c) throws Throwable {\n+            accessor().setChar(obj, c);\n+        }\n+    }\n+\n+    public Object get(Object obj) throws IllegalArgumentException {\n+        return Character.valueOf(getChar(obj));\n+    }\n+\n+    public boolean getBoolean(Object obj) throws IllegalArgumentException {\n+        throw newGetBooleanIllegalArgumentException();\n+    }\n+\n+    public byte getByte(Object obj) throws IllegalArgumentException {\n+        throw newGetByteIllegalArgumentException();\n+    }\n+\n+    public char getChar(Object obj) throws IllegalArgumentException {\n+        try {\n+            return getValue(obj);\n+        } catch (IllegalArgumentException|NullPointerException e) {\n+            throw e;\n+        } catch (ClassCastException e) {\n+            throw newGetIllegalArgumentException(obj.getClass());\n+        } catch (Throwable e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+\n+    public short getShort(Object obj) throws IllegalArgumentException {\n+        throw newGetShortIllegalArgumentException();\n+    }\n+\n+    public int getInt(Object obj) throws IllegalArgumentException {\n+        return getChar(obj);\n+    }\n+\n+    public long getLong(Object obj) throws IllegalArgumentException {\n+        return getChar(obj);\n+    }\n+\n+    public float getFloat(Object obj) throws IllegalArgumentException {\n+        return getChar(obj);\n+    }\n+\n+    public double getDouble(Object obj) throws IllegalArgumentException {\n+        return getChar(obj);\n+    }\n+\n+    public void set(Object obj, Object value)\n+            throws IllegalArgumentException, IllegalAccessException\n+    {\n+        if (isReadOnly) {\n+            ensureObj(obj);     \/\/ throw NPE if obj is null on instance field\n+            throwFinalFieldIllegalAccessException(value);\n+        }\n+        if (value == null) {\n+            throwSetIllegalArgumentException(value);\n+        }\n+        if (value instanceof Character) {\n+            setChar(obj, ((Character) value).charValue());\n+            return;\n+        }\n+        throwSetIllegalArgumentException(value);\n+    }\n+\n+    public void setBoolean(Object obj, boolean z)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(z);\n+    }\n+\n+    public void setByte(Object obj, byte b)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(b);\n+    }\n+\n+    public void setChar(Object obj, char c)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        if (isReadOnly) {\n+            ensureObj(obj);     \/\/ throw NPE if obj is null on instance field\n+            throwFinalFieldIllegalAccessException(c);\n+        }\n+        try {\n+            setValue(obj, c);\n+        } catch (IllegalArgumentException|NullPointerException e) {\n+            throw e;\n+        } catch (ClassCastException e) {\n+            throw newSetIllegalArgumentException(obj.getClass());\n+        } catch (Throwable e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+\n+    public void setShort(Object obj, short s)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(s);\n+    }\n+\n+    public void setInt(Object obj, int i)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(i);\n+    }\n+\n+    public void setLong(Object obj, long l)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(l);\n+    }\n+\n+    public void setFloat(Object obj, float f)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(f);\n+    }\n+\n+    public void setDouble(Object obj, double d)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(d);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/VarHandleCharacterFieldAccessorImpl.java","additions":196,"deletions":0,"binary":false,"changes":196,"status":"added"},{"patch":"@@ -0,0 +1,220 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.reflect;\n+\n+import java.lang.invoke.VarHandle;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+\n+abstract class VarHandleDoubleFieldAccessorImpl extends VarHandleFieldAccessorImpl {\n+    static FieldAccessorImpl fieldAccessor(Field field, VarHandle varHandle, boolean isReadOnly) {\n+        return Modifier.isStatic(field.getModifiers())\n+                ? new StaticFieldAccessor(field, varHandle, isReadOnly)\n+                : new InstanceFieldAccessor(field, varHandle, isReadOnly);\n+    }\n+\n+    VarHandleDoubleFieldAccessorImpl(Field field, VarHandle varHandle, boolean isReadOnly) {\n+        super(field, varHandle, isReadOnly);\n+    }\n+\n+    abstract double getValue(Object obj);\n+    abstract void setValue(Object obj, double d) throws Throwable;\n+\n+    static class StaticFieldAccessor extends VarHandleDoubleFieldAccessorImpl {\n+        StaticFieldAccessor(Field field, VarHandle varHandle, boolean isReadOnly) {\n+            super(field, varHandle, isReadOnly);\n+        }\n+\n+        double getValue(Object obj) {\n+            return accessor().getDouble();\n+        }\n+\n+        void setValue(Object obj, double d) throws Throwable {\n+            accessor().setDouble(d);\n+        }\n+\n+        protected void ensureObj(Object o) {}\n+    }\n+\n+    static class InstanceFieldAccessor extends VarHandleDoubleFieldAccessorImpl {\n+        InstanceFieldAccessor(Field field, VarHandle varHandle, boolean isReadOnly) {\n+            super(field, varHandle, isReadOnly);\n+        }\n+\n+        double getValue(Object obj) {\n+            return accessor().getDouble(obj);\n+        }\n+\n+        void setValue(Object obj, double d) throws Throwable {\n+            accessor().setDouble(obj, d);\n+        }\n+    }\n+\n+    public Object get(Object obj) throws IllegalArgumentException {\n+        return Double.valueOf(getDouble(obj));\n+    }\n+\n+    public boolean getBoolean(Object obj) throws IllegalArgumentException {\n+        throw newGetBooleanIllegalArgumentException();\n+    }\n+\n+    public byte getByte(Object obj) throws IllegalArgumentException {\n+        throw newGetByteIllegalArgumentException();\n+    }\n+\n+    public char getChar(Object obj) throws IllegalArgumentException {\n+        throw newGetCharIllegalArgumentException();\n+    }\n+\n+    public short getShort(Object obj) throws IllegalArgumentException {\n+        throw newGetShortIllegalArgumentException();\n+    }\n+\n+    public int getInt(Object obj) throws IllegalArgumentException {\n+        throw newGetIntIllegalArgumentException();\n+    }\n+\n+    public long getLong(Object obj) throws IllegalArgumentException {\n+        throw newGetLongIllegalArgumentException();\n+    }\n+\n+    public float getFloat(Object obj) throws IllegalArgumentException {\n+        throw newGetFloatIllegalArgumentException();\n+    }\n+\n+    public double getDouble(Object obj) throws IllegalArgumentException {\n+        try {\n+            return getValue(obj);\n+        } catch (IllegalArgumentException|NullPointerException e) {\n+            throw e;\n+        } catch (ClassCastException e) {\n+            throw newGetIllegalArgumentException(obj.getClass());\n+        } catch (Throwable e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+\n+    public void set(Object obj, Object value)\n+            throws IllegalArgumentException, IllegalAccessException\n+    {\n+        if (isReadOnly) {\n+            ensureObj(obj);     \/\/ throw NPE if obj is null on instance field\n+            throwFinalFieldIllegalAccessException(value);\n+        }\n+        if (value == null) {\n+            throwSetIllegalArgumentException(value);\n+        }\n+        if (value instanceof Byte) {\n+            setDouble(obj, ((Byte) value).byteValue());\n+            return;\n+        }\n+        if (value instanceof Short) {\n+            setDouble(obj, ((Short) value).shortValue());\n+            return;\n+        }\n+        if (value instanceof Character) {\n+            setDouble(obj, ((Character) value).charValue());\n+            return;\n+        }\n+        if (value instanceof Integer) {\n+            setDouble(obj, ((Integer) value).intValue());\n+            return;\n+        }\n+        if (value instanceof Long) {\n+            setDouble(obj, ((Long) value).longValue());\n+            return;\n+        }\n+        if (value instanceof Float) {\n+            setDouble(obj, ((Float) value).floatValue());\n+            return;\n+        }\n+        if (value instanceof Double) {\n+            setDouble(obj, ((Double) value).doubleValue());\n+            return;\n+        }\n+        throwSetIllegalArgumentException(value);\n+    }\n+\n+    public void setBoolean(Object obj, boolean z)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(z);\n+    }\n+\n+    public void setByte(Object obj, byte b)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        setDouble(obj, b);\n+    }\n+\n+    public void setChar(Object obj, char c)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        setDouble(obj, c);\n+    }\n+\n+    public void setShort(Object obj, short s)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        setDouble(obj, s);\n+    }\n+\n+    public void setInt(Object obj, int i)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        setDouble(obj, i);\n+    }\n+\n+    public void setLong(Object obj, long l)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        setDouble(obj, l);\n+    }\n+\n+    public void setFloat(Object obj, float f)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        setDouble(obj, f);\n+    }\n+\n+    public void setDouble(Object obj, double d)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        if (isReadOnly) {\n+            ensureObj(obj);     \/\/ throw NPE if obj is null on instance field\n+            throwFinalFieldIllegalAccessException(d);\n+        }\n+        try {\n+            setValue(obj, d);\n+        } catch (IllegalArgumentException|NullPointerException e) {\n+            throw e;\n+        } catch (ClassCastException e) {\n+            throw newSetIllegalArgumentException(obj.getClass());\n+        } catch (Throwable e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/VarHandleDoubleFieldAccessorImpl.java","additions":220,"deletions":0,"binary":false,"changes":220,"status":"added"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.reflect;\n+\n+import jdk.internal.vm.annotation.DontInline;\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.annotation.Stable;\n+\n+import java.lang.invoke.VarHandle;\n+import java.lang.reflect.Field;\n+\n+abstract class VarHandleFieldAccessorImpl extends FieldAccessorImpl {\n+    protected final boolean isReadOnly;\n+    private final VarHandle varHandle;\n+    private @Stable final VHInvoker accessor;\n+    private @Stable VHInvoker fastAccessor;\n+    private int numAccesses;\n+\n+    protected VarHandleFieldAccessorImpl(Field field, VarHandle varHandle, boolean isReadOnly) {\n+        super(field);\n+        this.isReadOnly = isReadOnly;\n+        this.varHandle = varHandle;\n+        this.accessor = new VHInvokerDelegate(varHandle);\n+    }\n+\n+    protected void ensureObj(Object o) {\n+        \/\/ for compatibility, check the receiver object first\n+        \/\/ throw NullPointerException if o is null\n+            if (!field.getDeclaringClass().isAssignableFrom(o.getClass())) {\n+            throwSetIllegalArgumentException(o);\n+        }\n+    }\n+\n+    @ForceInline\n+    final VHInvoker accessor() {\n+        var accessor = fastAccessor;\n+        if (accessor != null) {\n+            return accessor;\n+        }\n+        return slowAccessor();\n+    }\n+\n+    @DontInline\n+    final VHInvoker slowAccessor() {\n+        var accessor = this.accessor;\n+        if (++numAccesses > ReflectionFactory.inflationThreshold()) {\n+            this.fastAccessor = accessor = MethodHandleAccessorFactory.newVarHandleAccessor(field, varHandle);\n+        }\n+        return accessor;\n+    }\n+\n+    \/**\n+     * IllegalArgumentException because Field::get on the specified object, which\n+     * is not an instance of the class or interface declaring the underlying method\n+     *\/\n+    protected IllegalArgumentException newGetIllegalArgumentException(Class<?> type) {\n+        return new IllegalArgumentException(getMessage(true, type.getName()));\n+    }\n+\n+    \/**\n+     * IllegalArgumentException because Field::set on the specified object, which\n+     * is not an instance of the class or interface declaring the underlying method\n+     *\/\n+    protected IllegalArgumentException newSetIllegalArgumentException(Class<?> type) {\n+        return new IllegalArgumentException(getMessage(false, type.getName()));\n+    }\n+\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/VarHandleFieldAccessorImpl.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"},{"patch":"@@ -0,0 +1,216 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.reflect;\n+\n+import java.lang.invoke.VarHandle;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+\n+abstract class VarHandleFloatFieldAccessorImpl extends VarHandleFieldAccessorImpl {\n+    static FieldAccessorImpl fieldAccessor(Field field, VarHandle varHandle, boolean isReadOnly) {\n+        return Modifier.isStatic(field.getModifiers())\n+                ? new StaticFieldAccessor(field, varHandle, isReadOnly)\n+                : new InstanceFieldAccessor(field, varHandle, isReadOnly);\n+    }\n+\n+    VarHandleFloatFieldAccessorImpl(Field field, VarHandle varHandle, boolean isReadOnly) {\n+        super(field, varHandle, isReadOnly);\n+    }\n+\n+    abstract float getValue(Object obj);\n+    abstract void setValue(Object obj, float f) throws Throwable;\n+\n+    static class StaticFieldAccessor extends VarHandleFloatFieldAccessorImpl {\n+        StaticFieldAccessor(Field field, VarHandle varHandle, boolean isReadOnly) {\n+            super(field, varHandle, isReadOnly);\n+        }\n+\n+        float getValue(Object obj) {\n+            return accessor().getFloat();\n+        }\n+\n+        void setValue(Object obj, float f) throws Throwable {\n+            accessor().setFloat(f);\n+        }\n+\n+        protected void ensureObj(Object o) {}\n+    }\n+\n+    static class InstanceFieldAccessor extends VarHandleFloatFieldAccessorImpl {\n+        InstanceFieldAccessor(Field field, VarHandle varHandle, boolean isReadOnly) {\n+            super(field, varHandle, isReadOnly);\n+        }\n+\n+        float getValue(Object obj) {\n+            return accessor().getFloat(obj);\n+        }\n+\n+        void setValue(Object obj, float f) throws Throwable {\n+            accessor().setFloat(obj, f);\n+        }\n+    }\n+\n+    public Object get(Object obj) throws IllegalArgumentException {\n+        return Float.valueOf(getFloat(obj));\n+    }\n+\n+    public boolean getBoolean(Object obj) throws IllegalArgumentException {\n+        throw newGetBooleanIllegalArgumentException();\n+    }\n+\n+    public byte getByte(Object obj) throws IllegalArgumentException {\n+        throw newGetByteIllegalArgumentException();\n+    }\n+\n+    public char getChar(Object obj) throws IllegalArgumentException {\n+        throw newGetCharIllegalArgumentException();\n+    }\n+\n+    public short getShort(Object obj) throws IllegalArgumentException {\n+        throw newGetShortIllegalArgumentException();\n+    }\n+\n+    public int getInt(Object obj) throws IllegalArgumentException {\n+        throw newGetIntIllegalArgumentException();\n+    }\n+\n+    public long getLong(Object obj) throws IllegalArgumentException {\n+        throw newGetLongIllegalArgumentException();\n+    }\n+\n+    public float getFloat(Object obj) throws IllegalArgumentException {\n+        try {\n+            return getValue(obj);\n+        } catch (IllegalArgumentException|NullPointerException e) {\n+            throw e;\n+        } catch (ClassCastException e) {\n+            throw newGetIllegalArgumentException(obj.getClass());\n+        } catch (Throwable e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+\n+    public double getDouble(Object obj) throws IllegalArgumentException {\n+        return getFloat(obj);\n+    }\n+\n+    public void set(Object obj, Object value)\n+            throws IllegalArgumentException, IllegalAccessException\n+    {\n+        if (isReadOnly) {\n+            ensureObj(obj);     \/\/ throw NPE if obj is null on instance field\n+            throwFinalFieldIllegalAccessException(value);\n+        }\n+        if (value == null) {\n+            throwSetIllegalArgumentException(value);\n+        }\n+        if (value instanceof Byte) {\n+            setFloat(obj, ((Byte) value).byteValue());\n+            return;\n+        }\n+        if (value instanceof Short) {\n+            setFloat(obj, ((Short) value).shortValue());\n+            return;\n+        }\n+        if (value instanceof Character) {\n+            setFloat(obj, ((Character) value).charValue());\n+            return;\n+        }\n+        if (value instanceof Integer) {\n+            setFloat(obj, ((Integer) value).intValue());\n+            return;\n+        }\n+        if (value instanceof Long) {\n+            setFloat(obj, ((Long) value).longValue());\n+            return;\n+        }\n+        if (value instanceof Float) {\n+            setFloat(obj, ((Float) value).floatValue());\n+            return;\n+        }\n+        throwSetIllegalArgumentException(value);\n+    }\n+\n+    public void setBoolean(Object obj, boolean z)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(z);\n+    }\n+\n+    public void setByte(Object obj, byte b)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        setFloat(obj, b);\n+    }\n+\n+    public void setChar(Object obj, char c)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        setFloat(obj, c);\n+    }\n+\n+    public void setShort(Object obj, short s)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        setFloat(obj, s);\n+    }\n+\n+    public void setInt(Object obj, int i)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        setFloat(obj, i);\n+    }\n+\n+    public void setLong(Object obj, long l)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        setFloat(obj, l);\n+    }\n+\n+    public void setFloat(Object obj, float f)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        if (isReadOnly) {\n+            ensureObj(obj);     \/\/ throw NPE if obj is null on instance field\n+            throwFinalFieldIllegalAccessException(f);\n+        }\n+        try {\n+            setValue(obj, f);\n+        } catch (IllegalArgumentException|NullPointerException e) {\n+            throw e;\n+        } catch (ClassCastException e) {\n+            throw newSetIllegalArgumentException(obj.getClass());\n+        } catch (Throwable e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+\n+    public void setDouble(Object obj, double d)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(d);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/VarHandleFloatFieldAccessorImpl.java","additions":216,"deletions":0,"binary":false,"changes":216,"status":"added"},{"patch":"@@ -0,0 +1,208 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.reflect;\n+\n+import java.lang.invoke.VarHandle;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+\n+abstract class VarHandleIntegerFieldAccessorImpl extends VarHandleFieldAccessorImpl {\n+    static FieldAccessorImpl fieldAccessor(Field field, VarHandle varHandle, boolean isReadOnly) {\n+        return Modifier.isStatic(field.getModifiers())\n+                ? new StaticFieldAccessor(field, varHandle, isReadOnly)\n+                : new InstanceFieldAccessor(field, varHandle, isReadOnly);\n+    }\n+\n+    VarHandleIntegerFieldAccessorImpl(Field field, VarHandle varHandle, boolean isReadOnly) {\n+        super(field, varHandle, isReadOnly);\n+    }\n+\n+    abstract int getValue(Object obj);\n+    abstract void setValue(Object obj, int i) throws Throwable;\n+\n+    static class StaticFieldAccessor extends VarHandleIntegerFieldAccessorImpl {\n+        StaticFieldAccessor(Field field, VarHandle varHandle, boolean isReadOnly) {\n+            super(field, varHandle, isReadOnly);\n+        }\n+\n+        int getValue(Object obj) {\n+            return accessor().getInt();\n+        }\n+\n+        void setValue(Object obj, int i) throws Throwable {\n+            accessor().setInt(i);\n+        }\n+\n+        protected void ensureObj(Object o) {}\n+    }\n+\n+    static class InstanceFieldAccessor extends VarHandleIntegerFieldAccessorImpl {\n+        InstanceFieldAccessor(Field field, VarHandle varHandle, boolean isReadOnly) {\n+            super(field, varHandle, isReadOnly);\n+        }\n+\n+        int getValue(Object obj) {\n+            return accessor().getInt(obj);\n+        }\n+\n+        void setValue(Object obj, int i) throws Throwable {\n+            accessor().setInt(obj, i);\n+        }\n+    }\n+\n+    public Object get(Object obj) throws IllegalArgumentException {\n+        return Integer.valueOf(getInt(obj));\n+    }\n+\n+    public boolean getBoolean(Object obj) throws IllegalArgumentException {\n+        throw newGetBooleanIllegalArgumentException();\n+    }\n+\n+    public byte getByte(Object obj) throws IllegalArgumentException {\n+        throw newGetByteIllegalArgumentException();\n+    }\n+\n+    public char getChar(Object obj) throws IllegalArgumentException {\n+        throw newGetCharIllegalArgumentException();\n+    }\n+\n+    public short getShort(Object obj) throws IllegalArgumentException {\n+        throw newGetShortIllegalArgumentException();\n+    }\n+\n+    public int getInt(Object obj) throws IllegalArgumentException {\n+        try {\n+            return getValue(obj);\n+        } catch (IllegalArgumentException|NullPointerException e) {\n+            throw e;\n+        } catch (ClassCastException e) {\n+            throw newGetIllegalArgumentException(obj.getClass());\n+        } catch (Throwable e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+\n+    public long getLong(Object obj) throws IllegalArgumentException {\n+        return getInt(obj);\n+    }\n+\n+    public float getFloat(Object obj) throws IllegalArgumentException {\n+        return getInt(obj);\n+    }\n+\n+    public double getDouble(Object obj) throws IllegalArgumentException {\n+        return getInt(obj);\n+    }\n+\n+    public void set(Object obj, Object value)\n+            throws IllegalArgumentException, IllegalAccessException\n+    {\n+        if (isReadOnly) {\n+            ensureObj(obj);     \/\/ throw NPE if obj is null on instance field\n+            throwFinalFieldIllegalAccessException(value);\n+        }\n+        if (value == null) {\n+            throwSetIllegalArgumentException(value);\n+        }\n+        if (value instanceof Byte) {\n+            setInt(obj, ((Byte) value).byteValue());\n+            return;\n+        }\n+        if (value instanceof Short) {\n+            setInt(obj, ((Short) value).shortValue());\n+            return;\n+        }\n+        if (value instanceof Character) {\n+            setInt(obj, ((Character) value).charValue());\n+            return;\n+        }\n+        if (value instanceof Integer) {\n+            setInt(obj, ((Integer) value).intValue());\n+            return;\n+        }\n+        throwSetIllegalArgumentException(value);\n+    }\n+\n+    public void setBoolean(Object obj, boolean z)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(z);\n+    }\n+\n+    public void setByte(Object obj, byte b)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        setInt(obj, b);\n+    }\n+\n+    public void setChar(Object obj, char c)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        setInt(obj, c);\n+    }\n+\n+    public void setShort(Object obj, short s)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        setInt(obj, s);\n+    }\n+\n+    public void setInt(Object obj, int i)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        if (isReadOnly) {\n+            ensureObj(obj);     \/\/ throw NPE if obj is null on instance field\n+            throwFinalFieldIllegalAccessException(i);\n+        }\n+        try {\n+            setValue(obj, i);\n+        } catch (IllegalArgumentException|NullPointerException e) {\n+            throw e;\n+        } catch (ClassCastException e) {\n+            throw newSetIllegalArgumentException(obj.getClass());\n+        } catch (Throwable e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+\n+    public void setLong(Object obj, long l)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(l);\n+    }\n+\n+    public void setFloat(Object obj, float f)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(f);\n+    }\n+\n+    public void setDouble(Object obj, double d)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(d);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/VarHandleIntegerFieldAccessorImpl.java","additions":208,"deletions":0,"binary":false,"changes":208,"status":"added"},{"patch":"@@ -0,0 +1,212 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.reflect;\n+\n+import java.lang.invoke.VarHandle;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+\n+abstract class VarHandleLongFieldAccessorImpl extends VarHandleFieldAccessorImpl {\n+    static FieldAccessorImpl fieldAccessor(Field field, VarHandle varHandle, boolean isReadOnly) {\n+        return Modifier.isStatic(field.getModifiers())\n+                ? new StaticFieldAccessor(field, varHandle, isReadOnly)\n+                : new InstanceFieldAccessor(field, varHandle, isReadOnly);\n+    }\n+\n+    VarHandleLongFieldAccessorImpl(Field field, VarHandle varHandle, boolean isReadOnly) {\n+        super(field, varHandle, isReadOnly);\n+    }\n+\n+    abstract long getValue(Object obj);\n+    abstract void setValue(Object obj, long l) throws Throwable;\n+\n+    static class StaticFieldAccessor extends VarHandleLongFieldAccessorImpl {\n+        StaticFieldAccessor(Field field, VarHandle varHandle, boolean isReadOnly) {\n+            super(field, varHandle, isReadOnly);\n+        }\n+\n+        long getValue(Object obj) {\n+            return accessor().getLong();\n+        }\n+\n+        void setValue(Object obj, long l) throws Throwable {\n+            accessor().setLong(l);\n+        }\n+\n+        protected void ensureObj(Object o) {}\n+    }\n+\n+    static class InstanceFieldAccessor extends VarHandleLongFieldAccessorImpl {\n+        InstanceFieldAccessor(Field field, VarHandle varHandle, boolean isReadOnly) {\n+            super(field, varHandle, isReadOnly);\n+        }\n+\n+        long getValue(Object obj) {\n+            return accessor().getLong(obj);\n+        }\n+\n+        void setValue(Object obj, long l) throws Throwable {\n+            accessor().setLong(obj, l);\n+        }\n+    }\n+\n+    public Object get(Object obj) throws IllegalArgumentException {\n+        return Long.valueOf(getLong(obj));\n+    }\n+\n+    public boolean getBoolean(Object obj) throws IllegalArgumentException {\n+        throw newGetBooleanIllegalArgumentException();\n+    }\n+\n+    public byte getByte(Object obj) throws IllegalArgumentException {\n+        throw newGetByteIllegalArgumentException();\n+    }\n+\n+    public char getChar(Object obj) throws IllegalArgumentException {\n+        throw newGetCharIllegalArgumentException();\n+    }\n+\n+    public short getShort(Object obj) throws IllegalArgumentException {\n+        throw newGetShortIllegalArgumentException();\n+    }\n+\n+    public int getInt(Object obj) throws IllegalArgumentException {\n+        throw newGetIntIllegalArgumentException();\n+    }\n+\n+    public long getLong(Object obj) throws IllegalArgumentException {\n+        try {\n+            return getValue(obj);\n+        } catch (IllegalArgumentException|NullPointerException e) {\n+            throw e;\n+        } catch (ClassCastException e) {\n+            throw newGetIllegalArgumentException(obj.getClass());\n+        } catch (Throwable e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+\n+    public float getFloat(Object obj) throws IllegalArgumentException {\n+        return getLong(obj);\n+    }\n+\n+    public double getDouble(Object obj) throws IllegalArgumentException {\n+        return getLong(obj);\n+    }\n+\n+    public void set(Object obj, Object value)\n+            throws IllegalArgumentException, IllegalAccessException\n+    {\n+        if (isReadOnly) {\n+            ensureObj(obj);     \/\/ throw NPE if obj is null on instance field\n+            throwFinalFieldIllegalAccessException(value);\n+        }\n+        if (value == null) {\n+            throwSetIllegalArgumentException(value);\n+        }\n+        if (value instanceof Byte) {\n+            setLong(obj, ((Byte) value).byteValue());\n+            return;\n+        }\n+        if (value instanceof Short) {\n+            setLong(obj, ((Short) value).shortValue());\n+            return;\n+        }\n+        if (value instanceof Character) {\n+            setLong(obj, ((Character) value).charValue());\n+            return;\n+        }\n+        if (value instanceof Integer) {\n+            setLong(obj, ((Integer) value).intValue());\n+            return;\n+        }\n+        if (value instanceof Long) {\n+            setLong(obj, ((Long) value).longValue());\n+            return;\n+        }\n+        throwSetIllegalArgumentException(value);\n+    }\n+\n+    public void setBoolean(Object obj, boolean z)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(z);\n+    }\n+\n+    public void setByte(Object obj, byte b)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        setLong(obj, b);\n+    }\n+\n+    public void setChar(Object obj, char c)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        setLong(obj, c);\n+    }\n+\n+    public void setShort(Object obj, short s)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        setLong(obj, s);\n+    }\n+\n+    public void setInt(Object obj, int i)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        setLong(obj, i);\n+    }\n+\n+    public void setLong(Object obj, long l)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        if (isReadOnly) {\n+            ensureObj(obj);     \/\/ throw NPE if obj is null on instance field\n+            throwFinalFieldIllegalAccessException(l);\n+        }\n+        try {\n+            setValue(obj, l);\n+        } catch (IllegalArgumentException|NullPointerException e) {\n+            throw e;\n+        } catch (ClassCastException e) {\n+            throw newSetIllegalArgumentException(obj.getClass());\n+        } catch (Throwable e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+\n+    public void setFloat(Object obj, float f)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(f);\n+    }\n+\n+    public void setDouble(Object obj, double d)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(d);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/VarHandleLongFieldAccessorImpl.java","additions":212,"deletions":0,"binary":false,"changes":212,"status":"added"},{"patch":"@@ -0,0 +1,186 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.reflect;\n+\n+import java.lang.invoke.VarHandle;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+\n+abstract class VarHandleObjectFieldAccessorImpl extends VarHandleFieldAccessorImpl {\n+    static FieldAccessorImpl fieldAccessor(Field field, VarHandle varHandle, boolean isReadOnly) {\n+        return Modifier.isStatic(field.getModifiers())\n+                ? new StaticFieldAccessor(field, varHandle, isReadOnly)\n+                : new InstanceFieldAccessor(field, varHandle, isReadOnly);\n+    }\n+\n+    VarHandleObjectFieldAccessorImpl(Field field, VarHandle varHandle, boolean isReadOnly) {\n+        super(field, varHandle, isReadOnly);\n+    }\n+\n+    abstract Object getValue(Object obj);\n+    abstract void setValue(Object obj, Object value) throws Throwable;\n+\n+    static class StaticFieldAccessor extends VarHandleObjectFieldAccessorImpl {\n+        StaticFieldAccessor(Field field, VarHandle varHandle, boolean isReadOnly) {\n+            super(field, varHandle, isReadOnly);\n+        }\n+\n+        Object getValue(Object obj) {\n+            return accessor().get();\n+        }\n+\n+        void setValue(Object obj, Object value) throws Throwable {\n+            accessor().set(value);\n+        }\n+\n+        protected void ensureObj(Object o) {}\n+    }\n+\n+    static class InstanceFieldAccessor extends VarHandleObjectFieldAccessorImpl {\n+        InstanceFieldAccessor(Field field, VarHandle varHandle, boolean isReadOnly) {\n+            super(field, varHandle, isReadOnly);\n+        }\n+\n+        Object getValue(Object obj) {\n+            return accessor().get(obj);\n+        }\n+\n+        void setValue(Object obj, Object value) throws Throwable {\n+            accessor().set(obj, value);\n+        }\n+\n+    }\n+\n+    @Override\n+    public Object get(Object obj) throws IllegalArgumentException {\n+        try {\n+            return getValue(obj);\n+        } catch (IllegalArgumentException|NullPointerException e) {\n+            throw e;\n+        } catch (ClassCastException e) {\n+            throw newGetIllegalArgumentException(obj.getClass());\n+        } catch (Throwable e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+\n+    public boolean getBoolean(Object obj) throws IllegalArgumentException {\n+        throw newGetBooleanIllegalArgumentException();\n+    }\n+\n+    public byte getByte(Object obj) throws IllegalArgumentException {\n+        throw newGetByteIllegalArgumentException();\n+    }\n+\n+    public char getChar(Object obj) throws IllegalArgumentException {\n+        throw newGetCharIllegalArgumentException();\n+    }\n+\n+    public short getShort(Object obj) throws IllegalArgumentException {\n+        throw newGetShortIllegalArgumentException();\n+    }\n+\n+    public int getInt(Object obj) throws IllegalArgumentException {\n+        throw newGetIntIllegalArgumentException();\n+    }\n+\n+    public long getLong(Object obj) throws IllegalArgumentException {\n+        throw newGetLongIllegalArgumentException();\n+    }\n+\n+    public float getFloat(Object obj) throws IllegalArgumentException {\n+        throw newGetFloatIllegalArgumentException();\n+    }\n+\n+    public double getDouble(Object obj) throws IllegalArgumentException {\n+        throw newGetDoubleIllegalArgumentException();\n+    }\n+\n+    @Override\n+    public void set(Object obj, Object value) throws IllegalAccessException {\n+        if (isReadOnly) {\n+            ensureObj(obj);     \/\/ throw NPE if obj is null on instance field\n+            throwFinalFieldIllegalAccessException(value);\n+        }\n+        try {\n+            setValue(obj, value);\n+        } catch (IllegalArgumentException|NullPointerException e) {\n+            throw e;\n+        } catch (ClassCastException e) {\n+            throw newSetIllegalArgumentException(obj.getClass());\n+        } catch (Throwable e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+\n+    public void setBoolean(Object obj, boolean z)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(z);\n+    }\n+\n+    public void setByte(Object obj, byte b)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(b);\n+    }\n+\n+    public void setChar(Object obj, char c)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(c);\n+    }\n+\n+    public void setShort(Object obj, short s)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(s);\n+    }\n+\n+    public void setInt(Object obj, int i)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(i);\n+    }\n+\n+    public void setLong(Object obj, long l)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(l);\n+    }\n+\n+    public void setFloat(Object obj, float f)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(f);\n+    }\n+\n+    public void setDouble(Object obj, double d)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(d);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/VarHandleObjectFieldAccessorImpl.java","additions":186,"deletions":0,"binary":false,"changes":186,"status":"added"},{"patch":"@@ -0,0 +1,200 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.reflect;\n+\n+import java.lang.invoke.VarHandle;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+\n+abstract class VarHandleShortFieldAccessorImpl extends VarHandleFieldAccessorImpl {\n+    static FieldAccessorImpl fieldAccessor(Field field, VarHandle varHandle, boolean isReadOnly) {\n+        return Modifier.isStatic(field.getModifiers())\n+                ? new StaticFieldAccessor(field, varHandle, isReadOnly)\n+                : new InstanceFieldAccessor(field, varHandle, isReadOnly);\n+    }\n+\n+    VarHandleShortFieldAccessorImpl(Field field, VarHandle varHandle, boolean isReadOnly) {\n+        super(field, varHandle, isReadOnly);\n+    }\n+\n+    abstract short getValue(Object obj);\n+    abstract void setValue(Object obj, short s) throws Throwable;\n+\n+    static class StaticFieldAccessor extends VarHandleShortFieldAccessorImpl {\n+        StaticFieldAccessor(Field field, VarHandle varHandle, boolean isReadOnly) {\n+            super(field, varHandle, isReadOnly);\n+        }\n+\n+        short getValue(Object obj) {\n+            return accessor().getShort();\n+        }\n+\n+        void setValue(Object obj, short s) throws Throwable {\n+            accessor().setShort(s);\n+        }\n+\n+        protected void ensureObj(Object o) {}\n+    }\n+\n+    static class InstanceFieldAccessor extends VarHandleShortFieldAccessorImpl {\n+        InstanceFieldAccessor(Field field, VarHandle varHandle, boolean isReadOnly) {\n+            super(field, varHandle, isReadOnly);\n+        }\n+\n+        short getValue(Object obj) {\n+            return accessor().getShort(obj);\n+        }\n+\n+        void setValue(Object obj, short s) throws Throwable {\n+            accessor().setShort(obj, s);\n+        }\n+    }\n+\n+    public Object get(Object obj) throws IllegalArgumentException {\n+        return Short.valueOf(getShort(obj));\n+    }\n+\n+    public boolean getBoolean(Object obj) throws IllegalArgumentException {\n+        throw newGetBooleanIllegalArgumentException();\n+    }\n+\n+    public byte getByte(Object obj) throws IllegalArgumentException {\n+        throw newGetByteIllegalArgumentException();\n+    }\n+\n+    public char getChar(Object obj) throws IllegalArgumentException {\n+        throw newGetCharIllegalArgumentException();\n+    }\n+\n+    public short getShort(Object obj) throws IllegalArgumentException {\n+        try {\n+            return getValue(obj);\n+        } catch (IllegalArgumentException|NullPointerException e) {\n+            throw e;\n+        } catch (ClassCastException e) {\n+            throw newGetIllegalArgumentException(obj.getClass());\n+        } catch (Throwable e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+\n+    public int getInt(Object obj) throws IllegalArgumentException {\n+        return getShort(obj);\n+    }\n+\n+    public long getLong(Object obj) throws IllegalArgumentException {\n+        return getShort(obj);\n+    }\n+\n+    public float getFloat(Object obj) throws IllegalArgumentException {\n+        return getShort(obj);\n+    }\n+\n+    public double getDouble(Object obj) throws IllegalArgumentException {\n+        return getShort(obj);\n+    }\n+\n+    public void set(Object obj, Object value)\n+            throws IllegalArgumentException, IllegalAccessException\n+    {\n+        if (isReadOnly) {\n+            ensureObj(obj);     \/\/ throw NPE if obj is null on instance field\n+            throwFinalFieldIllegalAccessException(value);\n+        }\n+        if (value == null) {\n+            throwSetIllegalArgumentException(value);\n+        }\n+        if (value instanceof Byte) {\n+            setShort(obj, ((Byte) value).byteValue());\n+            return;\n+        }\n+        if (value instanceof Short) {\n+            setShort(obj, ((Short) value).shortValue());\n+            return;\n+        }\n+        throwSetIllegalArgumentException(value);\n+    }\n+\n+    public void setBoolean(Object obj, boolean z)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(z);\n+    }\n+\n+    public void setByte(Object obj, byte b)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        setShort(obj, b);\n+    }\n+\n+    public void setChar(Object obj, char c)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(c);\n+    }\n+\n+    public void setShort(Object obj, short s)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        if (isReadOnly) {\n+            ensureObj(obj);     \/\/ throw NPE if obj is null on instance field\n+            throwFinalFieldIllegalAccessException(s);\n+        }\n+        try {\n+            setValue(obj, s);\n+        } catch (IllegalArgumentException|NullPointerException e) {\n+            throw e;\n+        } catch (ClassCastException e) {\n+            throw newSetIllegalArgumentException(obj.getClass());\n+        } catch (Throwable e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+\n+    public void setInt(Object obj, int i)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(i);\n+    }\n+\n+    public void setLong(Object obj, long l)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(l);\n+    }\n+\n+    public void setFloat(Object obj, float f)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(f);\n+    }\n+\n+    public void setDouble(Object obj, double d)\n+        throws IllegalArgumentException, IllegalAccessException\n+    {\n+        throwSetIllegalArgumentException(d);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/VarHandleShortFieldAccessorImpl.java","additions":200,"deletions":0,"binary":false,"changes":200,"status":"added"},{"patch":"@@ -29,0 +29,2 @@\n+#include \"jdk_internal_reflect_DirectConstructorAccessorImpl_NativeAccessor.h\"\n+#include \"jdk_internal_reflect_DirectMethodAccessorImpl_NativeAccessor.h\"\n@@ -41,0 +43,11 @@\n+\n+JNIEXPORT jobject JNICALL Java_jdk_internal_reflect_DirectMethodAccessorImpl_00024NativeAccessor_invoke0\n+(JNIEnv *env, jclass unused, jobject m, jobject obj, jobjectArray args)\n+{\n+    return JVM_InvokeMethod(env, m, obj, args);\n+}\n+JNIEXPORT jobject JNICALL Java_jdk_internal_reflect_DirectConstructorAccessorImpl_00024NativeAccessor_newInstance0\n+(JNIEnv *env, jclass unused, jobject c, jobjectArray args)\n+{\n+    return JVM_NewInstanceFromConstructor(env, c, args);\n+}\n","filename":"src\/java.base\/share\/native\/libjava\/NativeAccessors.c","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+import jdk.internal.reflect.CallerSensitiveAdapter;\n@@ -717,0 +718,1 @@\n+    @CallerSensitiveAdapter\n@@ -791,0 +793,1 @@\n+    @CallerSensitiveAdapter\n","filename":"src\/java.logging\/share\/classes\/java\/util\/logging\/Logger.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import jdk.internal.reflect.CallerSensitiveAdapter;\n@@ -650,0 +651,1 @@\n+    @CallerSensitiveAdapter\n","filename":"src\/java.sql\/share\/classes\/java\/sql\/DriverManager.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,0 +41,6 @@\n+vmTestbase\/nsk\/jvmti\/AttachOnDemand\/attach002a\/TestDescription.java 8265795 generic-all\n+vmTestbase\/nsk\/jvmti\/AttachOnDemand\/attach022\/TestDescription.java 8265795 generic-all\n+vmTestbase\/nsk\/jdi\/ObjectReference\/referringObjects\/referringObjects002\/referringObjects002.java 8265796  generic-all\n+\n+#############################################################################\n+\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- * @run testng\/othervm -Dsun.reflect.noInflation=true ShowReflectionTargetTest\n+ * @run testng\/othervm -Dsun.reflect.noInflation=true -Djdk.reflect.useDirectMethodHandle=false ShowReflectionTargetTest\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/vm\/ShowReflectionTargetTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2201,1 +2201,3 @@\n-        testMethodDepth = 8;\n+        \/\/ the method depth in debuggee is 11 as it includes all hidden frames\n+        \/\/ the expected method depth is 6 excluding 5 hidden frames\n+        testMethodDepth = 11-5;\n","filename":"test\/jdk\/com\/sun\/jdi\/EATests.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -85,3 +85,1 @@\n-                new CallFrame(\"jdk.internal.reflect.NativeMethodAccessorImpl\", \"invoke0\"), \/\/ non-public class\n-                new CallFrame(\"jdk.internal.reflect.NativeMethodAccessorImpl\", \"invoke\"),\n-                new CallFrame(\"jdk.internal.reflect.DelegatingMethodAccessorImpl\", \"invoke\"),\n+                new CallFrame(\"jdk.internal.reflect.DirectMethodAccessorImpl\", \"invoke\"), \/\/ non-public class\n@@ -141,3 +139,1 @@\n-                new CallFrame(\"jdk.internal.reflect.NativeMethodAccessorImpl\", \"invoke0\"),\n-                new CallFrame(\"jdk.internal.reflect.NativeMethodAccessorImpl\", \"invoke\"),\n-                new CallFrame(\"jdk.internal.reflect.DelegatingMethodAccessorImpl\", \"invoke\"),\n+                new CallFrame(\"jdk.internal.reflect.DirectMethodAccessorImpl\", \"invoke\"),\n@@ -164,3 +160,1 @@\n-                new CallFrame(\"jdk.internal.reflect.NativeMethodAccessorImpl\", \"invoke0\"),\n-                new CallFrame(\"jdk.internal.reflect.NativeMethodAccessorImpl\", \"invoke\"),\n-                new CallFrame(\"jdk.internal.reflect.DelegatingMethodAccessorImpl\", \"invoke\"),\n+                new CallFrame(\"jdk.internal.reflect.DirectMethodAccessorImpl\", \"invoke\"),\n@@ -171,3 +165,1 @@\n-                new CallFrame(\"jdk.internal.reflect.NativeMethodAccessorImpl\", \"invoke0\"),\n-                new CallFrame(\"jdk.internal.reflect.NativeMethodAccessorImpl\", \"invoke\"),\n-                new CallFrame(\"jdk.internal.reflect.DelegatingMethodAccessorImpl\", \"invoke\"),\n+                new CallFrame(\"jdk.internal.reflect.DirectMethodAccessorImpl\", \"invoke\"),\n@@ -199,3 +191,1 @@\n-                new CallFrame(\"jdk.internal.reflect.NativeMethodAccessorImpl\", \"invoke0\"),\n-                new CallFrame(\"jdk.internal.reflect.NativeMethodAccessorImpl\", \"invoke\"),\n-                new CallFrame(\"jdk.internal.reflect.DelegatingMethodAccessorImpl\", \"invoke\"),\n+                new CallFrame(\"jdk.internal.reflect.DirectMethodAccessorImpl\", \"invoke\"),\n","filename":"test\/jdk\/java\/lang\/StackWalker\/DumpStackTest.java","additions":5,"deletions":15,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @run main NativeMethod\n+ * @run main\/othervm\/native -Xcheck:jni NativeMethod\n@@ -33,1 +33,0 @@\n-import java.lang.reflect.Method;\n@@ -47,5 +46,2 @@\n-    void test() throws Exception {\n-        \/\/ invoke via reflection that includes native methods\n-        Method m = NativeMethod.class.getDeclaredMethod(\"walk\");\n-        m.invoke(this);\n-    }\n+    \/\/ this native method will invoke NativeMethod::walk method\n+    public native void test();\n@@ -53,1 +49,1 @@\n-    void walk() {\n+    public void walk() {\n@@ -60,0 +56,7 @@\n+        \/\/ find NativeMethod::test native frame\n+        nativeFrames.stream().filter(f -> f.isNativeMethod()\n+                                            && f.getClassName().equals(\"NativeMethod\")\n+                                            && f.getMethodName().equals(\"test\"))\n+                    .findFirst()\n+                    .orElseThrow(() -> new RuntimeException(\"NativeMethod::test native method not found\"));\n+\n@@ -65,1 +68,0 @@\n-\n@@ -72,0 +74,4 @@\n+\n+    static {\n+        System.loadLibrary(\"nativeMethod\");\n+    }\n","filename":"test\/jdk\/java\/lang\/StackWalker\/NativeMethod.java","additions":15,"deletions":9,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -103,9 +103,6 @@\n-            \"5: java.base\/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\\n\" +\n-            \"6: java.base\/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\\n\" +\n-            \"7: java.base\/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\\n\" +\n-            \"8: java.base\/java.lang.reflect.Method.invoke(Method.java:520)\\n\" +\n-            \"9: VerifyStackTrace$1.run(VerifyStackTrace.java:220)\\n\" +\n-            \"10: java.base\/java.security.AccessController.doPrivileged(AccessController.java:310)\\n\" +\n-            \"11: VerifyStackTrace.test(VerifyStackTrace.java:229)\\n\" +\n-            \"12: VerifyStackTrace.main(VerifyStackTrace.java:185)\\n\";\n-\n+            \"5: java.base\/jdk.internal.reflect.DirectMethodAccessorImpl.invoke(DirectMethodAccessorImpl.java:94)\\n\" +\n+            \"6: java.base\/java.lang.reflect.Method.invoke(Method.java:520)\\n\" +\n+            \"7: VerifyStackTrace$1.run(VerifyStackTrace.java:220)\\n\" +\n+            \"8: java.base\/java.security.AccessController.doPrivileged(AccessController.java:310)\\n\" +\n+            \"9: VerifyStackTrace.test(VerifyStackTrace.java:229)\\n\" +\n+            \"10: VerifyStackTrace.main(VerifyStackTrace.java:185)\\n\";\n@@ -133,16 +130,19 @@\n-            \"1: VerifyStackTrace.lambda$test$1(VerifyStackTrace.java:213)\\n\" +\n-            \"2: VerifyStackTrace$$Lambda$1\/0x00000007c0089430.run(Unknown Source)\\n\" +\n-            \"3: VerifyStackTrace$Handle.execute(VerifyStackTrace.java:149)\\n\" +\n-            \"4: java.base\/java.lang.invoke.LambdaForm$DMH\/0x00000007c008a830.invokeVirtual_LL_V(LambdaForm$DMH)\\n\" +\n-            \"5: java.base\/java.lang.invoke.LambdaForm$MH\/0x00000007c008a830.invoke_MT(LambdaForm$MH)\\n\" +\n-            \"6: VerifyStackTrace$Handle.run(VerifyStackTrace.java:162)\\n\" +\n-            \"7: VerifyStackTrace.invoke(VerifyStackTrace.java:192)\\n\" +\n-            \"8: java.base\/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\\n\" +\n-            \"9: java.base\/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\\n\" +\n-            \"10: java.base\/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\\n\" +\n-            \"11: java.base\/java.lang.reflect.Method.invoke(Method.java:520)\\n\" +\n-            \"12: VerifyStackTrace$1.run(VerifyStackTrace.java:222)\\n\" +\n-            \"13: java.base\/java.security.AccessController.executePrivileged(AccessController.java:759)\\n\" +\n-            \"14: java.base\/java.security.AccessController.doPrivileged(AccessController.java:310)\\n\" +\n-            \"15: VerifyStackTrace.test(VerifyStackTrace.java:231)\\n\" +\n-            \"16: VerifyStackTrace.main(VerifyStackTrace.java:188)\\n\";\n+            \"1: VerifyStackTrace.lambda$test$1(VerifyStackTrace.java:280)\\n\" +\n+            \"2: VerifyStackTrace$$Lambda$1\/0x0000000801001848.run(Unknown Source)\\n\" +\n+            \"3: VerifyStackTrace$Handle.execute(VerifyStackTrace.java:206)\\n\" +\n+            \"4: java.base\/java.lang.invoke.DirectMethodHandle$Holder.invokeVirtual(DirectMethodHandle$Holder)\\n\" +\n+            \"5: java.base\/java.lang.invoke.LambdaForm$MH\/0x0000000801004800.invoke_MT(LambdaForm$MH)\\n\" +\n+            \"6: VerifyStackTrace$Handle.run(VerifyStackTrace.java:219)\\n\" +\n+            \"7: VerifyStackTrace.invoke(VerifyStackTrace.java:259)\\n\" +\n+            \"8: java.base\/java.lang.invoke.LambdaForm$DMH\/0x0000000801002000.invokeStatic(LambdaForm$DMH)\\n\" +\n+            \"9: java.base\/java.lang.invoke.LambdaForm$MH\/0x0000000801003000.invoke(LambdaForm$MH)\\n\" +\n+            \"10: java.base\/java.lang.invoke.Invokers$Holder.invokeExact_MT(Invokers$Holder)\\n\" +\n+            \"11: java.base\/jdk.internal.reflect.MHInvokerDelegate.invoke(MHInvokerDelegate.java:56)\\n\" +\n+            \"12: java.base\/jdk.internal.reflect.DirectMethodAccessorImpl.invokeImpl(DirectMethodAccessorImpl.java:211)\\n\" +\n+            \"13: java.base\/jdk.internal.reflect.DirectMethodAccessorImpl.invoke(DirectMethodAccessorImpl.java:122)\\n\" +\n+            \"14: java.base\/java.lang.reflect.Method.invoke(Method.java:573)\\n\" +\n+            \"15: VerifyStackTrace$1.run(VerifyStackTrace.java:292)\\n\" +\n+            \"16: java.base\/java.security.AccessController.executePrivileged(AccessController.java:753)\\n\" +\n+            \"17: java.base\/java.security.AccessController.doPrivileged(AccessController.java:312)\\n\" +\n+            \"18: VerifyStackTrace.test(VerifyStackTrace.java:301)\\n\" +\n+            \"19: VerifyStackTrace.main(VerifyStackTrace.java:254)\\n\";\n","filename":"test\/jdk\/java\/lang\/StackWalker\/VerifyStackTrace.java","additions":25,"deletions":25,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+\n+#include \"jni.h\"\n+\n+static jclass test_class;\n+static jmethodID mid;\n+static jint current_jni_version = JNI_VERSION_10;\n+\n+JNIEXPORT jint JNICALL\n+JNI_OnLoad(JavaVM *vm, void *reserved) {\n+    JNIEnv *env;\n+    jclass cl;\n+\n+    (*vm)->GetEnv(vm, (void **) &env, current_jni_version);\n+\n+    cl = (*env)->FindClass(env, \"NativeMethod\");\n+    test_class = (*env)->NewGlobalRef(env, cl);\n+    mid = (*env)->GetMethodID(env, test_class, \"walk\", \"()V\");\n+\n+    return current_jni_version;\n+}\n+\n+\/*\n+ * Class:     NativeMethod\n+ * Method:    test\n+ * Signature: ()V\n+ *\/\n+JNIEXPORT void JNICALL Java_NativeMethod_test(JNIEnv *env, jobject obj) {\n+    (*env)->CallVoidMethod(env, obj, mid);\n+\n+    if ((*env)->ExceptionCheck(env)) {\n+        (*env)->ExceptionDescribe(env);\n+        (*env)->FatalError(env, \"Exception thrown\");\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/StackWalker\/libnativeMethod.c","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @run testng\/othervm CallerSensitiveMethodHandle\n+ * @summary Check Lookup findVirtual, findStatic and unreflect behavior with\n+ *          caller sensitive methods with focus on AccessibleObject.setAccessible\n+ *\/\n+\n+import org.testng.annotations.Test;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.lang.reflect.Field;\n+\n+import static java.lang.invoke.MethodType.*;\n+import static org.testng.Assert.*;\n+\n+public class CallerSensitiveMethodHandle {\n+    private static int field = 0;\n+    @Test\n+    public void privateField() throws Throwable {\n+        Lookup l = MethodHandles.lookup();\n+        Field f = CallerSensitiveMethodHandle.class.getDeclaredField(\"field\");\n+        MethodHandle mh = l.findVirtual(Field.class, \"setInt\", methodType(void.class, Object.class, int.class));\n+        int newValue = 5;\n+        mh.invokeExact(f, (Object) null, newValue);\n+        assertTrue(field == newValue);\n+    }\n+\n+    @Test\n+    public void lookupItself() throws Throwable {\n+        Lookup lookup = MethodHandles.lookup();\n+        MethodHandle MH_lookup2 = lookup.findStatic(MethodHandles.class, \"lookup\", methodType(Lookup.class));\n+        Lookup lookup2 = (Lookup) MH_lookup2.invokeExact();\n+        System.out.println(lookup2 + \" original lookup class \" + lookup.lookupClass());\n+        assertTrue(lookup2.lookupClass() == lookup.lookupClass());\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/invoke\/CallerSensitiveMethodHandle.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @summary Test MethodHandle::invokeExact and MethodHandle::invoke throws\n+ *          UnsupportedOperationException when called via Method::invoke\n+ * @run testng test.java.lang.invoke.MethodHandleInvokeUOE\n+ *\/\n+\n+package test.java.lang.invoke;\n+\n+import org.testng.*;\n+import org.testng.annotations.*;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+\n+import static java.lang.invoke.MethodType.*;\n+\n+public class MethodHandleInvokeUOE {\n+    @Test\n+    public void testInvokeExact() throws Throwable {\n+        Class<?> clz = MethodHandle.class;\n+        String mname = \"invokeExact\";\n+        Method m = clz.getDeclaredMethod(mname, Object[].class);\n+        MethodHandle mh = MethodHandles.lookup().findVirtual(clz, mname, methodType(Object.class, Object[].class));\n+        try {\n+            m.invoke(mh, new Object[1]);\n+        } catch (InvocationTargetException e) {\n+            if (!(e.getCause() instanceof UnsupportedOperationException)) {\n+                throw new RuntimeException(\"expected UnsupportedOperationException but got: \"\n+                        + e.getCause().getClass().getName(), e);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testInvoke() throws Throwable {\n+        Class<?> clz = MethodHandle.class;\n+        String mname = \"invoke\";\n+        Method m = clz.getDeclaredMethod(mname, Object[].class);\n+        MethodHandle mh = MethodHandles.lookup().findVirtual(clz, mname, methodType(Object.class, Object[].class));\n+        try {\n+            m.invoke(mh, new Object[1]);\n+        } catch (InvocationTargetException e) {\n+            if (!(e.getCause() instanceof UnsupportedOperationException)) {\n+                throw new RuntimeException(\"expected UnsupportedOperationException but got: \"\n+                        + e.getCause().getClass().getName(), e);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandleInvokeUOE.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -25,1 +25,1 @@\n- * @bug 8196830 8235351\n+ * @bug 8196830 8235351 8257874\n@@ -358,0 +358,34 @@\n+    \/**\n+     * Field::getInt and Field::setInt are caller-sensitive methods.\n+     * Test access to private field.\n+     *\/\n+    private static int privateField = 0;\n+    @Test\n+    public void testPrivateField() throws Throwable {\n+        Field f = CallerSensitiveAccess.class.getDeclaredField(\"privateField\");\n+        \/\/ Field::setInt\n+        MethodType mtype = MethodType.methodType(void.class, Object.class, int.class);\n+        MethodHandle mh = MethodHandles.lookup().findVirtual(Field.class, \"setInt\", mtype);\n+        mh.invokeExact(f, (Object)null, 5);\n+        \/\/ Field::getInt\n+        mh = MethodHandles.lookup().findVirtual(Field.class, \"getInt\", MethodType.methodType(int.class, Object.class));\n+        int value = (int)mh.invokeExact(f, (Object)null);\n+        assertTrue(value == 5);\n+    }\n+\n+    private static class Inner {\n+        private static boolean privateField = false;\n+    }\n+\n+    @Test\n+    public void testInnerPrivateField() throws Throwable {\n+        Field f = Inner.class.getDeclaredField(\"privateField\");\n+        \/\/ Field::setInt\n+        MethodType mtype = MethodType.methodType(void.class, Object.class, boolean.class);\n+        MethodHandle mh = MethodHandles.lookup().findVirtual(Field.class, \"setBoolean\", mtype);\n+        mh.invokeExact(f, (Object)null, true);\n+        \/\/ Field::getInt\n+        mh = MethodHandles.lookup().findVirtual(Field.class, \"getBoolean\", MethodType.methodType(boolean.class, Object.class));\n+        boolean value = (boolean)mh.invokeExact(f, (Object)null);\n+        assertTrue(value);\n+    }\n","filename":"test\/jdk\/java\/lang\/invoke\/callerSensitive\/CallerSensitiveAccess.java","additions":35,"deletions":1,"binary":false,"changes":36,"previous_filename":"test\/jdk\/java\/lang\/invoke\/CallerSensitiveAccess.java","status":"renamed"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8013527\n+ * @library src\n+ * @modules java.base\/jdk.internal.reflect\n+ * @build java.base\/java.util.CSM csm\/*\n+ * @run main\/othervm csm\/jdk.test.MethodInvokeTest\n+ * @run main\/othervm csm\/jdk.test.MethodInvokeTest sm\n+ * @summary Test proper caller class is bound to method handle for caller-sensitive method\n+ *\/\n+public class Main {\n+}\n+\n","filename":"test\/jdk\/java\/lang\/invoke\/callerSensitive\/Main.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,202 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test;\n+\n+import java.lang.StackWalker.StackFrame;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.Method;\n+import java.util.CSM;\n+import java.security.Permission;\n+import java.security.PermissionCollection;\n+import java.security.Permissions;\n+import java.security.Policy;\n+import java.security.ProtectionDomain;\n+import java.util.function.Supplier;\n+\n+\/**\n+ * This test invokes caller-sensitive methods via static reference,\n+ * reflection, MethodHandle, lambda.  If there is no alternate implementation\n+ * of a CSM with a trailing caller class parameter, when a CSM is invoked\n+ * via method handle, an invoker class is injected as the caller class\n+ * which is defined by the same defining class loader, in the same runtime\n+ * package, and protection domain as the lookup class.\n+ *\/\n+public class MethodInvokeTest {\n+    static final Policy DEFAULT_POLICY = Policy.getPolicy();\n+    private static final String CALLER_METHOD = \"caller\";\n+    private static final String CALLER_NO_ALT_METHOD = \"callerNoAlternateImpl\";\n+\n+    public static void main(String... args) throws Throwable {\n+        boolean sm = args.length > 0 && args[0].equals(\"sm\");\n+        System.err.format(\"Test %s security manager.%n\",\n+                          sm ? \"with\" : \"without\");\n+        if (sm) {\n+            setupSecurityManager();\n+        }\n+\n+        MethodInvokeTest test = new MethodInvokeTest();\n+        \/\/ test static call to java.util.CSM::caller\n+        test.staticMethodCall();\n+        \/\/ test java.lang.reflect.Method call\n+        test.reflectMethodCall();\n+        \/\/ test java.lang.invoke.MethodHandle\n+        test.invokeMethodHandle();\n+        \/\/ test method ref\n+        test.lambda();\n+    }\n+\n+    static void setupSecurityManager() {\n+        PermissionCollection perms = new Permissions();\n+        perms.add(new RuntimePermission(\"getStackWalkerWithClassReference\"));\n+        Policy.setPolicy(new Policy() {\n+            @Override\n+            public boolean implies(ProtectionDomain domain, Permission p) {\n+                return perms.implies(p) || DEFAULT_POLICY.implies(domain, p);\n+            }\n+        });\n+        System.setSecurityManager(new SecurityManager());\n+    }\n+\n+    void staticMethodCall() {\n+        checkCaller(java.util.CSM.caller(), MethodInvokeTest.class);\n+        checkCaller(java.util.CSM.callerNoAlternateImpl(), MethodInvokeTest.class);\n+    }\n+\n+    void reflectMethodCall() throws Throwable {\n+        checkCaller(Caller1.invoke(CSM.class.getMethod(CALLER_METHOD)), Caller1.class);\n+        checkCaller(Caller2.invoke(CSM.class.getMethod(CALLER_METHOD)), Caller2.class);\n+\n+        \/\/ Reflection::getCallerClass will return the injected invoker class as the caller\n+        checkInjectedInvoker(Caller1.invoke(CSM.class.getMethod(CALLER_NO_ALT_METHOD)), Caller1.class);\n+        checkInjectedInvoker(Caller2.invoke(CSM.class.getMethod(CALLER_NO_ALT_METHOD)), Caller2.class);\n+    }\n+\n+    void invokeMethodHandle() throws Throwable {\n+        checkCaller(Caller1.invokeExact(CALLER_METHOD), Caller1.class);\n+        checkCaller(Caller2.invokeExact(CALLER_METHOD), Caller2.class);\n+\n+        checkInjectedInvoker(Caller1.invokeExact(CALLER_NO_ALT_METHOD), Caller1.class);\n+        checkInjectedInvoker(Caller2.invokeExact(CALLER_NO_ALT_METHOD), Caller2.class);\n+    }\n+\n+    void lambda() {\n+        CSM caller = LambdaTest.caller.get();\n+        LambdaTest.checkLambdaProxyClass(caller);\n+\n+        caller = LambdaTest.caller();\n+        LambdaTest.checkLambdaProxyClass(caller);\n+    }\n+\n+    static class Caller1 {\n+        static CSM invoke(Method csm) throws ReflectiveOperationException {\n+            return (CSM)csm.invoke(null);\n+        }\n+        static CSM invokeExact(String methodName) throws Throwable {\n+            MethodHandle mh = MethodHandles.lookup().findStatic(java.util.CSM.class,\n+                    methodName, MethodType.methodType(CSM.class));\n+            return (CSM)mh.invokeExact();\n+        }\n+    }\n+\n+    static class Caller2 {\n+        static CSM invoke(Method csm) throws ReflectiveOperationException {\n+            return (CSM)csm.invoke(null);\n+        }\n+        static CSM invokeExact(String methodName) throws Throwable {\n+            MethodHandle mh = MethodHandles.lookup().findStatic(java.util.CSM.class,\n+                    methodName, MethodType.methodType(CSM.class));\n+            return (CSM)mh.invokeExact();\n+        }\n+    }\n+\n+    static class LambdaTest {\n+        static Supplier<CSM> caller = java.util.CSM::caller;\n+\n+        static CSM caller() {\n+            return caller.get();\n+        }\n+\n+        \/*\n+         * The class calling the caller-sensitive method is the lambda proxy class\n+         * generated for LambdaTest.\n+         *\/\n+        static void checkLambdaProxyClass(CSM csm) {\n+            Class<?> caller = csm.caller;\n+            assertTrue(caller.isHidden(), caller + \" should be a hidden class\");\n+            assertEquals(caller.getModule(), LambdaTest.class.getModule());\n+\n+            int index = caller.getName().indexOf('\/');\n+            String cn = caller.getName().substring(0, index);\n+            assertTrue(cn.startsWith(LambdaTest.class.getName() + \"$$Lambda$\"), caller + \" should be a lambda proxy class\");\n+        }\n+    }\n+    static void checkCaller(CSM csm, Class<?> expected) {\n+        assertEquals(csm.caller, expected);\n+        \/\/ verify no invoker class injected\n+        for (StackFrame frame : csm.stackFrames) {\n+            Class<?> c = frame.getDeclaringClass();\n+            if (c == expected) break;\n+\n+            if (c.getName().startsWith(expected.getName() + \"$$InjectedInvoker\"))\n+                throw new RuntimeException(\"should not have any invoker class injected\");\n+        }\n+    }\n+\n+    \/*\n+     * The class calling the direct method handle of the caller-sensitive class\n+     * is the InjectedInvoker class generated for the given caller.\n+     *\/\n+    static void checkInjectedInvoker(CSM csm, Class<?> expected) {\n+        Class<?> invoker = csm.caller;\n+        assertTrue(invoker.isHidden(), invoker + \" should be a hidden class\");\n+        assertEquals(invoker.getModule(), expected.getModule());\n+\n+        int index = invoker.getName().indexOf('\/');\n+        String cn = invoker.getName().substring(0, index);\n+        assertEquals(cn, expected.getName() + \"$$InjectedInvoker\");\n+\n+        \/\/ check the invoker class on the stack\n+        for (StackFrame frame : csm.stackFrames) {\n+            Class<?> c = frame.getDeclaringClass();\n+            if (c.getName().startsWith(expected.getName() + \"$$InjectedInvoker\"))\n+                break;\n+\n+            if (c == expected)\n+                throw new RuntimeException(\"no invoker class found before the expected caller class\");\n+        }\n+    }\n+\n+    static void assertTrue(boolean value, String msg) {\n+        if (!value) {\n+            throw new RuntimeException(msg);\n+        }\n+    }\n+    static void assertEquals(Object o1, Object o2) {\n+        if (!o1.equals(o2)) {\n+            throw new RuntimeException(o1 + \" != \" + o2);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/invoke\/callerSensitive\/csm\/jdk\/test\/MethodInvokeTest.java","additions":202,"deletions":0,"binary":false,"changes":202,"status":"added"},{"patch":"@@ -0,0 +1,26 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+module csm {\n+    exports jdk.test;\n+}\n","filename":"test\/jdk\/java\/lang\/invoke\/callerSensitive\/csm\/module-info.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.util;\n+\n+import java.lang.StackWalker.StackFrame;\n+import java.util.stream.Stream;\n+\n+import jdk.internal.reflect.CallerSensitive;\n+import jdk.internal.reflect.Reflection;\n+\n+import static java.lang.StackWalker.Option.*;\n+\n+public class CSM {\n+    public final Class<?> caller;\n+    public final List<StackFrame> stackFrames;\n+    CSM(Class<?> caller) {\n+        this.caller = caller;\n+        StackWalker sw = StackWalker.getInstance(Set.of(RETAIN_CLASS_REFERENCE, SHOW_HIDDEN_FRAMES));\n+        this.stackFrames = sw.walk(Stream::toList);\n+    }\n+\n+    \/**\n+     * Returns the caller of this caller-sensitive method returned by\n+     * by Reflection::getCallerClass except if this method is called\n+     * via method handle.\n+     *\/\n+    @CallerSensitive\n+    public static CSM caller() {\n+        return new CSM(Reflection.getCallerClass());\n+    }\n+\n+    \/**\n+     * If caller() is invoked via method handle, this alternate method is\n+     * called instead.  The caller class would be the lookup class.\n+     *\/\n+    private static CSM caller(Class<?> caller) {\n+        return new CSM(caller);\n+    }\n+\n+    \/**\n+     * Returns the caller of this caller-sensitive method returned by\n+     * by Reflection::getCallerClass.\n+     *\/\n+    @CallerSensitive\n+    public static CSM callerNoAlternateImpl() {\n+        return new CSM(Reflection.getCallerClass());\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/lang\/invoke\/callerSensitive\/src\/java.base\/java\/util\/CSM.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -0,0 +1,137 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8013527\n+ * @run testng\/othervm ChainedLookupTest\n+ * @summary Test MethodHandles.lookup method to produce the Lookup object with\n+ *          proper lookup class if invoked through reflection and method handle.\n+ *\/\n+\n+import java.lang.invoke.*;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.lang.reflect.Method;\n+\n+import org.testng.annotations.Test;\n+\n+import static java.lang.invoke.MethodHandles.*;\n+import static java.lang.invoke.MethodType.*;\n+import static org.testng.Assert.*;\n+\n+public class ChainedLookupTest {\n+    \/**\n+     * Direct call to MethodHandles::lookup\n+     *\/\n+    @Test\n+    public void staticLookup() throws Throwable {\n+        Lookup lookup =  lookup();\n+        test(lookup, \"Lookup produced via direct call to MethodHandles.lookup()\");\n+    }\n+\n+    \/**\n+     * Reflective Method::invoke on MethodHandles::lookup\n+     *\/\n+    @Test\n+    public void methodInvoke() throws Throwable {\n+        Method m =  MethodHandles.class.getMethod(\"lookup\");\n+        Lookup lookup = (Lookup) m.invoke(null);\n+        test(lookup, \"Lookup produced via reflective call\");\n+    }\n+\n+    \/**\n+     * Invoke Method::invoke on MethodHandles::lookup via MethodHandle\n+     *\/\n+    @Test\n+    public void methodInvokeViaMethodHandle() throws Throwable {\n+        Method m =  MethodHandles.class.getMethod(\"lookup\");\n+\n+        MethodHandle mh = lookup().findVirtual(Method.class, \"invoke\",\n+                                               methodType(Object.class, Object.class, Object[].class));\n+        Lookup lookup = (Lookup)mh.invoke(m, (Object)null, (Object[])null);\n+        test(lookup, \"Lookup produced via Method::invoke via MethodHandle\");\n+    }\n+\n+    \/**\n+     * Invoke MethodHandle on MethodHandles::lookup via Method::invoke\n+     *\/\n+    \/\/ @Test\n+    public void methodHandleViaReflection() throws Throwable {\n+        MethodHandle MH_lookup = lookup().findStatic(MethodHandles.class, \"lookup\", methodType(Lookup.class));\n+        Lookup lookup = (Lookup) MH_lookup.invokeExact();\n+\n+        Method m =  MethodHandle.class.getMethod(\"invoke\", Object[].class);\n+\n+        \/\/ should this throw UnsupportedOperationException per MethodHandle::invoke spec?\n+        lookup = (Lookup)m.invoke(MH_lookup);\n+        test(lookup, \"Lookup produced via MethodHandle::invoke via Method::invoke\");\n+    }\n+\n+    \/**\n+     * MethodHandle::invokeExact on MethodHandles::lookup\n+     *\/\n+    @Test\n+    public void methodHandle() throws Throwable {\n+        MethodHandle MH_lookup = lookup().findStatic(MethodHandles.class, \"lookup\", methodType(Lookup.class));\n+        Lookup lookup = (Lookup) MH_lookup.invokeExact();\n+        test(lookup, \"Lookup produced via MethodHandle\");\n+    }\n+\n+    \/**\n+     * MethodHandles::unreflect the reflective Method representing MethodHandles::lookup\n+     *\/\n+    @Test\n+    public void unreflect() throws Throwable {\n+        MethodHandle MH_lookup = lookup().unreflect(MethodHandles.class.getMethod(\"lookup\"));\n+        Lookup lookup = (Lookup) MH_lookup.invokeExact();\n+        test(lookup, \"Lookup produced via unreflect MethodHandle\");\n+    }\n+\n+    \/**\n+     * Use the Lookup object returned from MethodHandle::invokeExact on MethodHandles::lookup\n+     * to look up MethodHandle representing MethodHandles::lookup and then invoking it.\n+     *\/\n+    @Test\n+    public void chainedMethodHandle() throws Throwable {\n+        MethodHandle MH_lookup = lookup().findStatic(MethodHandles.class, \"lookup\", methodType(Lookup.class));\n+        Lookup lookup = (Lookup) MH_lookup.invokeExact();\n+        MethodHandle MH_lookup2 = lookup.unreflect(MethodHandles.class.getMethod(\"lookup\"));\n+        Lookup lookup2 = (Lookup) MH_lookup2.invokeExact();\n+        test(lookup2, \"Lookup produced via a chained call to MethodHandle\");\n+    }\n+\n+    void test(Lookup lookup, String msg) throws Throwable {\n+        assertTrue(lookup.lookupClass() == ChainedLookupTest.class);\n+        assertTrue(lookup.hasFullPrivilegeAccess());\n+\n+        MethodHandle mh = lookup.findStatic(lookup.lookupClass(), \"say\", methodType(void.class, String.class));\n+        mh.invokeExact(msg);\n+    }\n+\n+    private static void say(String msg) {\n+        System.out.println(msg);\n+    }\n+}\n+\n","filename":"test\/jdk\/java\/lang\/invoke\/lookup\/ChainedLookupTest.java","additions":137,"deletions":0,"binary":false,"changes":137,"status":"added"},{"patch":"@@ -55,3 +55,1 @@\n-        if (!lookupMethod.getName().equals(\"lookup\")) {\n-            throw new RuntimeException(\"Unexpected name: \" + lookupMethod.getName());\n-        }\n+        assertEquals(lookupMethod.getName(), \"lookup\");\n","filename":"test\/jdk\/java\/lang\/invoke\/lookup\/ReflectiveLookupTest.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,120 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng\/othervm ChainedReflection\n+ * @summary Test Method::invoke and Constructor::newInstance chained calls that\n+ *          should wrap NPE in InvocationTargetException properly\n+ *\/\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.Optional;\n+\n+import org.testng.annotations.Test;\n+\n+public class ChainedReflection {\n+    public ChainedReflection() {}\n+\n+    ChainedReflection(Void dummy) throws ReflectiveOperationException {\n+        Method m = ChainedReflection.class.getMethod(\"throwNPE\");\n+        try {\n+            m.invoke(null);\n+        } catch (InvocationTargetException e) {\n+            Throwable t = e.getTargetException();\n+            if (t instanceof NullPointerException npe) {\n+                throw npe;\n+            } else {\n+                throw new RuntimeException(\"Test failed (InvocationTargetException didn't wrap NullPointerException)\");\n+            }\n+        } catch (Throwable t) {\n+            throw new RuntimeException(\"Test failed (Unexpected exception)\", t);\n+        }\n+    }\n+\n+    public static void throwNPE() {\n+        throw new NullPointerException();\n+    }\n+\n+    \/*\n+     * Wrap a NullPointerException with a new NullPointerException\n+     *\/\n+    public static void npe() throws ReflectiveOperationException {\n+        NullPointerException cause;\n+        try {\n+            Optional.of(null);\n+            throw new RuntimeException(\"NPE not thrown\");\n+        } catch (NullPointerException e) {\n+            cause = e;\n+        }\n+        Class<?> c = NullPointerException.class;\n+        Constructor<?> ctor = c.getConstructor();\n+        NullPointerException npe = (NullPointerException) ctor.newInstance();\n+        npe.initCause(cause);\n+        throw npe;\n+    }\n+\n+    \/**\n+     * Tests the target method being invoked via core reflection that\n+     * throws NullPointerException allocated via Constructor::newInstance.\n+     * The newly allocated NPE thrown by the target method should be\n+     * wrapped by InvocationTargetException.\n+     *\/\n+    @Test\n+    public void methodCallNewInstance() throws ReflectiveOperationException {\n+        Method m = ChainedReflection.class.getMethod(\"npe\");\n+        try {\n+            m.invoke(null);\n+        } catch (InvocationTargetException e) {\n+            Throwable t = e.getTargetException();\n+            if (!(t instanceof NullPointerException)) {\n+                throw new RuntimeException(\"Test failed (InvocationTargetException didn't wrap NullPointerException)\");\n+            }\n+        } catch (Throwable t) {\n+            throw new RuntimeException(\"Test failed (Unexpected exception)\", t);\n+        }\n+    }\n+\n+    \/**\n+     * Tests a constructor C calling the method \"throwNPE\" that throws\n+     * a new instance of NullPointerException.\n+     * C::newInstance should wrap NullPointerException thrown by\n+     * Method::invoke on \"throwNPE\"  by InvocationTargetException.\n+     *\/\n+    @Test\n+    public void ctorCallMethodInvoke() throws ReflectiveOperationException {\n+        Constructor<?> ctor = ChainedReflection.class.getDeclaredConstructor(Void.class);\n+        try {\n+            ctor.newInstance((Void)null);\n+        } catch (InvocationTargetException e) {\n+            Throwable t = e.getTargetException();\n+            if (!(t instanceof NullPointerException)) {\n+                throw new RuntimeException(\"Test failed (InvocationTargetException didn't wrap NullPointerException)\");\n+            }\n+        } catch (Throwable t) {\n+            throw new RuntimeException(\"Test failed (Unexpected exception)\", t);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/ChainedReflection.java","additions":120,"deletions":0,"binary":false,"changes":120,"status":"added"},{"patch":"@@ -33,0 +33,6 @@\n+\/*\n+ * @test\n+ * @run main\/othervm -Xverify:all -Dsun.reflect.noInflation=true TestFieldReflectValueOf\n+ * @summary verify the bytecode generated for Field::get and Field::set for each field\n+ *\/\n+\n@@ -90,4 +96,4 @@\n-        testUnsafeStaticFieldAccessors();\n-        testUnsafeQualifiedStaticFieldAccessors();\n-        testUnsafeFieldAccessors();\n-        testUnsafeQualifiedFieldAccessors();\n+        testStaticFieldAccessors();\n+        testStaticVolatileFieldAccessors();\n+        testFieldAccessors();\n+        testVolatileFieldAccessors();\n@@ -96,1 +102,1 @@\n-    private static void testUnsafeStaticFieldAccessors() {\n+    private static void testStaticFieldAccessors() {\n@@ -100,1 +106,1 @@\n-    private static void testUnsafeQualifiedStaticFieldAccessors() {\n+    private static void testStaticVolatileFieldAccessors() {\n@@ -104,1 +110,1 @@\n-    private static void testUnsafeFieldAccessors() {\n+    private static void testFieldAccessors() {\n@@ -108,1 +114,1 @@\n-    private static void testUnsafeQualifiedFieldAccessors() {\n+    private static void testVolatileFieldAccessors() {\n","filename":"test\/jdk\/java\/lang\/reflect\/Field\/TestFieldReflectValueOf.java","additions":14,"deletions":8,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -35,0 +35,6 @@\n+\/*\n+ * @test\n+ * @run main\/othervm -Xverify:all -Dsun.reflect.noInflation=true TestMethodReflectValueOf\n+ * @summary verify the bytecode generated for Method::invoke for each method\n+ *\/\n+\n","filename":"test\/jdk\/java\/lang\/reflect\/Method\/invoke\/TestMethodReflectValueOf.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,643 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6824466\n+ * @modules java.base\/jdk.internal.reflect\n+ * @summary Test compliance of ConstructorAccessor, FieldAccessor, MethodAccessor implementations\n+ * @run testng\/othervm --add-exports java.base\/jdk.internal.reflect=ALL-UNNAMED -Djdk.reflect.useDirectMethodHandle=true -Dsun.reflect.inflationThreshold=1 -XX:-ShowCodeDetailsInExceptionMessages MethodHandleAccessorsTest\n+ *\/\n+\/*\n+ * @test\n+ * @modules java.base\/jdk.internal.reflect\n+ * @run testng\/othervm --add-exports java.base\/jdk.internal.reflect=ALL-UNNAMED -Djdk.reflect.useDirectMethodHandle=true -Djdk.reflect.noInflation=true -XX:-ShowCodeDetailsInExceptionMessages MethodHandleAccessorsTest\n+ *\/\n+\/*\n+ * @test\n+ * @modules java.base\/jdk.internal.reflect\n+ * @run testng\/othervm --add-exports java.base\/jdk.internal.reflect=ALL-UNNAMED -Djdk.reflect.useDirectMethodHandle=false -XX:-ShowCodeDetailsInExceptionMessages MethodHandleAccessorsTest\n+ *\/\n+\n+\n+import jdk.internal.reflect.ConstructorAccessor;\n+import jdk.internal.reflect.FieldAccessor;\n+import jdk.internal.reflect.MethodAccessor;\n+import jdk.internal.reflect.Reflection;\n+import jdk.internal.reflect.ReflectionFactory;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+import java.util.Objects;\n+import java.util.function.IntUnaryOperator;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+public class MethodHandleAccessorsTest {\n+\n+    public static void public_static_V() {}\n+\n+    public static int public_static_I() { return 42; }\n+\n+    public void public_V() {}\n+\n+    public int public_I() { return 42; }\n+\n+    public static void public_static_I_V(int i) {}\n+\n+    public static int public_static_I_I(int i) { return i; }\n+\n+    public void public_I_V(int i) {}\n+\n+    public int public_I_I(int i) { return i; }\n+\n+    private static void private_static_V() {}\n+\n+    private static int private_static_I() { return 42; }\n+\n+    private void private_V() {}\n+\n+    private int private_I() { return 42; }\n+\n+    private static void private_static_I_V(int i) {}\n+\n+    private static int private_static_I_I(int i) { return i; }\n+\n+    private void private_I_V(int i) {}\n+\n+    private int private_I_I(int i) { return i; }\n+\n+    public static int varargs(int... values) {\n+        int sum = 0;\n+        for (int i : values) sum += i;\n+        return sum;\n+\n+    }\n+    public static int varargs_primitive(int first, int... rest) {\n+        int sum = first;\n+        if (rest != null) {\n+            sum *= 100;\n+            for (int i : rest) sum += i;\n+        }\n+        return sum;\n+    }\n+\n+    public static String varargs_object(String first, String... rest) {\n+        StringBuilder sb = new StringBuilder(first);\n+        if (rest != null) {\n+            sb.append(Stream.of(rest).collect(Collectors.joining(\",\", \"[\", \"]\")));\n+        }\n+        return sb.toString();\n+    }\n+\n+    public static final class Public {\n+        public static final int STATIC_FINAL = 1;\n+        private final int i;\n+        private final String s;\n+\n+        public Public() {\n+            this.i = 0;\n+            this.s = null;\n+        }\n+\n+        public Public(int i) {\n+            this.i = i;\n+            this.s = null;\n+        }\n+\n+        public Public(String s) {\n+            this.i = 0;\n+            this.s = s;\n+        }\n+\n+        public Public(int first, int... rest) {\n+            this(varargs_primitive(first, rest));\n+        }\n+\n+        public Public(String first, String... rest) {\n+            this(varargs_object(first, rest));\n+        }\n+\n+        public Public(RuntimeException exc) {\n+            throw exc;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            Public other = (Public) o;\n+            return i == other.i &&\n+                   Objects.equals(s, other.s);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(i, s);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"Public{\" +\n+                   \"i=\" + i +\n+                   \", s='\" + s + '\\'' +\n+                   '}';\n+        }\n+    }\n+\n+    static final class Private {\n+        private final int i;\n+\n+        private Private() {\n+            this.i = 0;\n+        }\n+\n+        private Private(int i) {\n+            this.i = i;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            Private other = (Private) o;\n+            return i == other.i;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(i);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"Private{\" +\n+                   \"i=\" + i +\n+                   '}';\n+        }\n+    }\n+\n+    static final class Thrower {\n+        public Thrower(RuntimeException exc) {\n+            throw exc;\n+        }\n+        public static void throws_exception(RuntimeException exc) {\n+            throw exc;\n+        }\n+    }\n+\n+    public static abstract class Abstract {\n+        public Abstract() {\n+        }\n+    }\n+\n+    \/**\n+     * Tests if MethodAccessor::invoke implementation returns the expected\n+     * result or exceptions.\n+     *\/\n+    static void doTestAccessor(Method m, MethodAccessor ma, Object target, Object[] args,\n+                               Object expectedReturn, Throwable... expectedExceptions) {\n+        Object ret;\n+        Throwable exc;\n+        try {\n+            ret = ma.invoke(target, args);\n+            exc = null;\n+        } catch (Throwable e) {\n+            ret = null;\n+            exc = e;\n+        }\n+        System.out.println(\"\\n\" + m + \", invoked with target: \" + target + \", args: \" + Arrays.toString(args));\n+\n+        chechResult(ret, expectedReturn, exc, expectedExceptions);\n+    }\n+\n+    \/**\n+     * Tests if ConstructorAccessor::newInstance implementation returns the\n+     * expected result or exceptions.\n+     *\/\n+    static void doTestAccessor(Constructor c, ConstructorAccessor ca, Object[] args,\n+                               Object expectedReturn, Throwable... expectedExceptions) {\n+        Object ret;\n+        Throwable exc;\n+        try {\n+            ret = ca.newInstance(args);\n+            exc = null;\n+        } catch (Throwable e) {\n+            ret = null;\n+            exc = e;\n+        }\n+        System.out.println(\"\\n\" + c + \", invoked with args: \" + Arrays.toString(args));\n+        chechResult(ret, expectedReturn, exc, expectedExceptions);\n+    }\n+\n+    \/**\n+     * Tests if FieldAccessor::get implementation returns the\n+     * expected result or exceptions.\n+     *\/\n+    static void doTestAccessor(Field f, FieldAccessor fa, Object target,\n+                               Object expectedValue, Throwable... expectedExceptions) {\n+        Object ret;\n+        Throwable exc;\n+        try {\n+            ret = fa.get(target);\n+            exc = null;\n+        } catch (Throwable e) {\n+            ret = null;\n+            exc = e;\n+        }\n+        System.out.println(\"\\n\" + f + \", invoked with target: \" + target + \", value: \" + ret);\n+        chechResult(ret, expectedValue, exc, expectedExceptions);\n+\n+    }\n+\n+    \/**\n+     * Tests if FieldAccessor::set implementation returns the\n+     * expected result or exceptions.\n+     *\/\n+    static void doTestAccessor(Field f, FieldAccessor fa, Object target, Object oldValue,\n+                               Object newValue, Throwable... expectedExceptions) {\n+        Object ret;\n+        Throwable exc;\n+            try {\n+                fa.set(target, newValue);\n+                exc = null;\n+                ret = fa.get(target);\n+            } catch (Throwable e) {\n+                ret = null;\n+                exc = e;\n+            }\n+            System.out.println(\"\\n\" + f + \", invoked with target: \" + target + \", value: \" + ret);\n+            chechResult(ret, newValue, exc, expectedExceptions);\n+    }\n+\n+    static void chechResult(Object ret, Object expectedReturn, Throwable exc, Throwable... expectedExceptions) {\n+        if (exc != null) {\n+            checkException(exc, expectedExceptions);\n+        } else if (expectedExceptions.length > 0) {\n+            fail(exc, expectedExceptions);\n+        } else if (!Objects.equals(ret, expectedReturn)) {\n+            throw new AssertionError(\"Expected return:\\n \" + expectedReturn + \"\\ngot:\\n \" + ret);\n+        } else {\n+            System.out.println(\"    Got expected return: \" + ret);\n+        }\n+    }\n+\n+    static void checkException(Throwable exc, Throwable... expectedExceptions) {\n+        boolean match = false;\n+        for (Throwable expected : expectedExceptions) {\n+            if (exceptionMatches(exc, expected)) {\n+                match = true;\n+                break;\n+            }\n+        }\n+        if (match) {\n+            System.out.println(\"    Got expected exception: \" + exc);\n+            if (exc.getCause() != null) {\n+                System.out.println(\"                with cause: \" + exc.getCause());\n+            }\n+        } else {\n+            fail(exc, expectedExceptions);\n+        }\n+    }\n+\n+    static boolean exceptionMatches(Throwable exc, Throwable expected) {\n+        return expected.getClass().isInstance(exc) &&\n+                (Objects.equals(expected.getMessage(), exc.getMessage()) ||\n+                        (exc.getMessage() != null && expected.getMessage() != null &&\n+                         exc.getMessage().startsWith(expected.getMessage()))) &&\n+                (expected.getCause() == null || exceptionMatches(exc.getCause(), expected.getCause()));\n+    }\n+\n+    static void fail(Throwable thrownException, Throwable... expectedExceptions) {\n+        String msg;\n+        if (thrownException == null) {\n+            msg = \"No exception thrown but there were expected exceptions (see suppressed)\";\n+        } else if (expectedExceptions.length == 0) {\n+            msg = \"Exception thrown (see cause) but there were no expected exceptions\";\n+        } else {\n+            msg = \"Exception thrown (see cause) but expected exceptions were different (see suppressed)\";\n+        }\n+        AssertionError error = new AssertionError(msg, thrownException);\n+        Stream.of(expectedExceptions).forEach(error::addSuppressed);\n+        throw error;\n+    }\n+\n+    static void doTest(Method m, Object target, Object[] args, Object expectedReturn, Throwable... expectedException) {\n+        MethodAccessor ma = ReflectionFactory.getReflectionFactory().newMethodAccessor(m, Reflection.isCallerSensitive(m));\n+        try {\n+            doTestAccessor(m, ma, target, args, expectedReturn, expectedException);\n+        } catch (Throwable e) {\n+            throw new RuntimeException(ma.getClass().getName() + \" for method: \" + m + \" test failure\", e);\n+        }\n+    }\n+\n+    static void doTest(Constructor c, Object[] args, Object expectedReturn, Throwable... expectedExceptions) {\n+        ConstructorAccessor ca = ReflectionFactory.getReflectionFactory().newConstructorAccessor(c);\n+        try {\n+            doTestAccessor(c, ca, args, expectedReturn, expectedExceptions);\n+        } catch (Throwable e) {\n+            throw new RuntimeException(ca.getClass().getName() + \" for constructor: \" + c + \" test failure\", e);\n+        }\n+    }\n+    static void doTest(Field f, Object target, Object expectedValue, Throwable... expectedExceptions) {\n+        FieldAccessor fa = ReflectionFactory.getReflectionFactory().newFieldAccessor(f, false);\n+        try {\n+            doTestAccessor(f, fa, target, expectedValue, expectedExceptions);\n+        } catch (Throwable e) {\n+            throw new RuntimeException(fa.getClass().getName() + \" for field: \" + f + \" test failure\", e);\n+        }\n+    }\n+    static void doTest(Field f, Object target, Object oldValue, Object newValue, Throwable... expectedExceptions) {\n+        FieldAccessor fa = ReflectionFactory.getReflectionFactory().newFieldAccessor(f, true);\n+        try {\n+            doTestAccessor(f, fa, target, oldValue, newValue, expectedExceptions);\n+        } catch (Throwable e) {\n+            throw new RuntimeException(fa.getClass().getName() + \" for field: \" + f + \" test failure\", e);\n+        }\n+    }\n+\n+    private static final Throwable[] noException = new Throwable[0];\n+    private static final Throwable[] mismatched_argument_type = new Throwable[] {\n+            new IllegalArgumentException(\"argument type mismatch\")\n+    };\n+    private static final Throwable[] mismatched_target_type = new Throwable[] {\n+            new IllegalArgumentException(\"argument type mismatch\"),\n+            new IllegalArgumentException(\"object is not an instance of declaring class\"),\n+    };\n+    private static final Throwable[] cannot_get_final_field = new Throwable[] {\n+            new IllegalArgumentException(\"Can not get final\")\n+    };\n+    private static final Throwable[] cannot_set_final_field = new Throwable[] {\n+            new IllegalArgumentException(\"Can not set final\")\n+    };\n+    private static final Throwable[] wrong_argument_count_no_details = new Throwable[] {\n+            new IllegalArgumentException(\"wrong number of arguments\")\n+    };\n+    private static final Throwable[] wrong_argument_count = new Throwable[] {\n+            new IllegalArgumentException(\"wrong number of arguments\"),\n+            new IllegalArgumentException(\"array is not of length 1\")\n+    };\n+    private static final Throwable[] null_argument = new Throwable[] {\n+            new IllegalArgumentException(\"wrong number of arguments\"),\n+            new IllegalArgumentException(\"null array reference\")\n+    };\n+    private static final Throwable[] null_argument_value = new Throwable[] {\n+            new IllegalArgumentException()\n+    };\n+    private static final Throwable[] null_argument_value_npe = new Throwable[] {\n+            new IllegalArgumentException(\"java.lang.NullPointerException\"),\n+            new NullPointerException()\n+    };\n+    private static final Throwable[] null_target = new Throwable[] {\n+            new NullPointerException()\n+    };\n+    private static final Throwable[] wrapped_npe_no_msg = new Throwable[]{\n+            new InvocationTargetException(new NullPointerException())\n+    };\n+    private static final Throwable[] wrapped_npe = new Throwable[]{\n+            new InvocationTargetException(new NullPointerException(\"NPE\"))\n+    };\n+    private static final Throwable[] wrapped_cce = new Throwable[]{\n+            new InvocationTargetException(new ClassCastException(\"CCE\"))\n+    };\n+    private static final Throwable[] wrapped_iae = new Throwable[]{\n+            new InvocationTargetException(new IllegalArgumentException(\"IAE\"))\n+    };\n+\n+\n+    @DataProvider(name = \"testNoArgMethods\")\n+    private Object[][] testNoArgMethods() {\n+        MethodHandleAccessorsTest inst = new MethodHandleAccessorsTest();\n+        Object[] emptyArgs = new Object[]{};\n+        return new Object[][] {\n+             new Object[] {\"public_static_V\",   null, emptyArgs, null, noException},\n+             new Object[] {\"public_static_V\",   null, null, null, noException},\n+             new Object[] {\"public_static_I\",   null, emptyArgs, 42, noException},\n+             new Object[] {\"public_static_I\",   null, null, 42, noException},\n+             new Object[] {\"public_V\",          inst, emptyArgs, null, noException},\n+             new Object[] {\"public_V\",          inst, null, null, noException},\n+             new Object[] {\"public_I\",          inst, emptyArgs, 42, noException},\n+             new Object[] {\"public_I\",          inst, null, 42, noException},\n+             new Object[] {\"private_static_V\",  null, emptyArgs, null, noException},\n+             new Object[] {\"private_static_I\",  null, emptyArgs, 42, noException},\n+             new Object[] {\"private_V\",         inst, emptyArgs, null, noException},\n+             new Object[] {\"private_I\",         inst, emptyArgs, 42, noException},\n+             new Object[] {\"public_V\",          null, null, null, null_target},\n+        };\n+    }\n+\n+    @DataProvider(name = \"testOneArgMethods\")\n+    private Object[][] testOneArgMethods() {\n+        MethodHandleAccessorsTest inst = new MethodHandleAccessorsTest();\n+        Object wrongInst = new Object();\n+        boolean newImpl = Boolean.getBoolean(\"jdk.reflect.useDirectMethodHandle\");\n+        return new Object[][]{\n+            new Object[] {\"public_static_I_V\",  int.class, null, new Object[]{12}, null, noException},\n+            new Object[] {\"public_static_I_I\",  int.class, null, new Object[]{12}, 12, noException},\n+            new Object[] {\"public_I_V\",         int.class, inst, new Object[]{12}, null, noException},\n+            new Object[] {\"public_I_I\",         int.class, inst, new Object[]{12}, 12, noException},\n+            new Object[] {\"private_static_I_V\", int.class, null, new Object[]{12}, null, noException},\n+            new Object[] {\"private_static_I_I\", int.class, null, new Object[]{12}, 12, noException},\n+            new Object[] {\"private_I_V\",        int.class, inst, new Object[]{12}, null, noException},\n+            new Object[] {\"private_I_I\",        int.class, inst, new Object[]{12}, 12, noException},\n+\n+            new Object[] {\"public_static_I_I\", int.class, null, new Object[]{\"a\"}, null, mismatched_argument_type},\n+            new Object[] {\"public_I_I\",        int.class, inst, new Object[]{\"a\"}, null, mismatched_argument_type},\n+            new Object[] {\"public_static_I_I\", int.class, null, new Object[]{12, 13}, null,\n+                          newImpl ? wrong_argument_count_no_details : wrong_argument_count},\n+            new Object[] {\"public_I_I\",        int.class, inst, new Object[]{12, 13}, null,\n+                          newImpl ? wrong_argument_count_no_details : wrong_argument_count},\n+            new Object[] {\"public_I_I\",        int.class, wrongInst, new Object[]{12}, 12, mismatched_target_type},\n+            new Object[] {\"public_I_I\",        int.class, null, new Object[]{12}, 12, null_target},\n+\n+            new Object[] {\"public_static_I_V\", int.class, null, null, null,\n+                          newImpl ? wrong_argument_count_no_details : null_argument},\n+            new Object[] {\"public_static_I_V\", int.class, null, new Object[]{null}, null,\n+                          newImpl ? null_argument_value_npe : null_argument_value},\n+            new Object[] {\"public_I_I\",        int.class, inst, null, null, null_argument},\n+\n+            new Object[] {\"public_I_I\", int.class, inst, new Object[]{null}, null,\n+                          newImpl ? null_argument_value_npe : null_argument_value},\n+        };\n+    }\n+\n+    @DataProvider(name = \"testMethodsWithVarargs\")\n+    private Object[][] testMethodsWithVarargs() {\n+        Class<?>[] paramTypes = new Class<?>[] { int[].class };\n+        Class<?>[] I_paramTypes = new Class<?>[] { int.class, int[].class };\n+        Class<?>[] L_paramTypes = new Class<?>[] { String.class, String[].class };\n+        return new Object[][]{\n+            new Object[] {\"varargs\", paramTypes, null, new Object[]{new int[]{1, 2, 3}}, 6, noException},\n+            new Object[] {\"varargs\", paramTypes, null, new Object[]{new int[]{}}, 0, noException},\n+            new Object[] {\"varargs\", paramTypes, null, new Object[]{null}, 0, wrapped_npe_no_msg},\n+            new Object[] {\"varargs_primitive\", I_paramTypes, null, new Object[]{1, new int[]{2, 3}}, 105, noException},\n+            new Object[] {\"varargs_primitive\", I_paramTypes, null, new Object[]{1, new int[]{}}, 100, noException},\n+            new Object[] {\"varargs_primitive\", I_paramTypes, null, new Object[]{1, null}, 1, noException},\n+            new Object[] {\"varargs_object\", L_paramTypes,    null, new Object[]{\"a\", new String[]{\"b\", \"c\"}}, \"a[b,c]\", noException},\n+            new Object[] {\"varargs_object\", L_paramTypes,    null, new Object[]{\"a\", new String[]{}}, \"a[]\", noException},\n+            new Object[] {\"varargs_object\", L_paramTypes,    null, new Object[]{\"a\", null}, \"a\", noException},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"testNoArgMethods\")\n+    public void testNoArgMethod(String methodname, Object target, Object[] args,\n+                                Object expectedReturn, Throwable[] expectedExpections) throws Exception {\n+        doTest(MethodHandleAccessorsTest.class.getDeclaredMethod(methodname), target, args, expectedReturn, expectedExpections);\n+    }\n+\n+    @Test(dataProvider = \"testOneArgMethods\")\n+    public void testOneArgMethod(String methodname, Class<?> paramType, Object target, Object[] args,\n+                                 Object expectedReturn, Throwable[] expectedExpections) throws Exception {\n+        doTest(MethodHandleAccessorsTest.class.getDeclaredMethod(methodname, paramType), target, args, expectedReturn, expectedExpections);\n+    }\n+\n+    @Test(dataProvider = \"testMethodsWithVarargs\")\n+    public void testMethodsWithVarargs(String methodname, Class<?>[] paramTypes, Object target, Object[] args,\n+                                       Object expectedReturn, Throwable[] expectedExpections) throws Exception {\n+        doTest(MethodHandleAccessorsTest.class.getDeclaredMethod(methodname, paramTypes), target, args, expectedReturn, expectedExpections);\n+    }\n+\n+    @DataProvider(name = \"testConstructors\")\n+    private Object[][] testConstructors() {\n+        return new Object[][]{\n+                new Object[]{null, new Object[]{}, new Public(), noException},\n+                new Object[]{null, null, new Public(), noException},\n+                new Object[]{new Class<?>[]{int.class}, new Object[]{12}, new Public(12), noException},\n+                new Object[]{new Class<?>[]{String.class}, new Object[]{\"a\"}, new Public(\"a\"), noException},\n+\n+\n+                new Object[]{new Class<?>[]{int.class, int[].class}, new Object[]{1, new int[]{2, 3}}, new Public(105), noException},\n+                new Object[]{new Class<?>[]{int.class, int[].class}, new Object[]{1, new int[]{}}, new Public(100), noException},\n+                new Object[]{new Class<?>[]{int.class, int[].class}, new Object[]{1, null}, new Public(1), noException},\n+\n+                new Object[]{new Class<?>[]{String.class, String[].class}, new Object[]{\"a\", new String[]{\"b\", \"c\"}}, new Public(\"a[b,c]\"), noException},\n+                new Object[]{new Class<?>[]{String.class, String[].class}, new Object[]{\"a\", new String[]{}}, new Public(\"a[]\"), noException},\n+                new Object[]{new Class<?>[]{String.class, String[].class}, new Object[]{\"a\", null}, new Public(\"a\"), noException},\n+\n+                \/\/ test ConstructorAccessor exceptions thrown\n+                new Object[]{new Class<?>[]{int.class}, new Object[]{\"a\"}, null, mismatched_argument_type},\n+                new Object[]{new Class<?>[]{int.class}, new Object[]{12, 13}, null, wrong_argument_count},\n+                new Object[]{new Class<?>[]{int.class}, null, null, null_argument},\n+                new Object[]{new Class<?>[]{RuntimeException.class}, new Object[]{new NullPointerException(\"NPE\")}, null, wrapped_npe},\n+                new Object[]{new Class<?>[]{RuntimeException.class}, new Object[]{new IllegalArgumentException(\"IAE\")}, null, wrapped_iae},\n+                new Object[]{new Class<?>[]{RuntimeException.class}, new Object[]{new ClassCastException(\"CCE\")}, null, wrapped_cce},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"testConstructors\")\n+    public void testPublicConstructors(Class<?>[] paramTypes, Object[] args, Object expectedReturn, Throwable[] expectedExpections) throws Exception {\n+        doTest(Public.class.getDeclaredConstructor(paramTypes), args, expectedReturn, expectedExpections);\n+    }\n+\n+    @Test\n+    public void testOtherConstructors() throws Exception {\n+        doTest(Private.class.getDeclaredConstructor(), new Object[]{}, new Private());\n+        doTest(Private.class.getDeclaredConstructor(), null, new Private());\n+        doTest(Private.class.getDeclaredConstructor(int.class), new Object[]{12}, new Private(12));\n+\n+        doTest(Abstract.class.getDeclaredConstructor(), null, null, new InstantiationException());\n+    }\n+\n+    @DataProvider(name = \"throwException\")\n+    private Object[][] throwException() {\n+        return new Object[][]{\n+                new Object[] {new NullPointerException(\"NPE\"), wrapped_npe},\n+                new Object[] {new IllegalArgumentException(\"IAE\"), wrapped_iae},\n+                new Object[] {new ClassCastException(\"CCE\"), wrapped_cce},\n+        };\n+    }\n+\n+    \/*\n+     * Test Method::invoke and Constructor::newInstance to wrap NPE\/CCE\/IAE\n+     * thrown by the member\n+     *\/\n+    @Test(dataProvider = \"throwException\")\n+    public void testInvocationTargetException(Throwable ex, Throwable[] expectedExpections) throws Exception {\n+        Object[] args = new Object[] { ex };\n+        \/\/ test static method\n+        doTest(Thrower.class.getDeclaredMethod(\"throws_exception\", RuntimeException.class), null, args, null, expectedExpections);\n+        \/\/ test constructor\n+        doTest(Thrower.class.getDeclaredConstructor(RuntimeException.class), args, null, expectedExpections);\n+    }\n+\n+    @Test\n+    public void testLambdaProxyClass() throws Exception {\n+        \/\/ test MethodAccessor on methods declared by hidden classes\n+        IntUnaryOperator intUnaryOp = i -> i;\n+        Method applyAsIntMethod = intUnaryOp.getClass().getDeclaredMethod(\"applyAsInt\", int.class);\n+        doTest(applyAsIntMethod, intUnaryOp, new Object[]{12}, 12);\n+    }\n+\n+    @DataProvider(name = \"readAccess\")\n+    private Object[][] readAccess() {\n+        boolean newImpl = Boolean.getBoolean(\"jdk.reflect.useDirectMethodHandle\");\n+        return new Object[][]{\n+                new Object[]{\"i\", new Public(100), 100, noException},\n+                new Object[]{\"s\", new Public(\"test\"), \"test\", noException},\n+                new Object[]{\"s\", new Object(), \"test\",\n+                             newImpl ? cannot_get_final_field : cannot_set_final_field},\n+                new Object[]{\"s\", null, \"test\", null_target},\n+        };\n+    }\n+    @DataProvider(name = \"writeAccess\")\n+    private Object[][] writeAccess() {\n+        return new Object[][]{\n+                new Object[]{\"i\", new Public(100), 100, 200, noException},\n+                new Object[]{\"s\", new Public(\"test\"), \"test\", \"newValue\", noException},\n+                \/\/ ## no exception thrown\n+                \/\/ new Object[]{\"i\", new Public(100), 100, new Object(), cannot_set_final_field},\n+                new Object[]{\"s\", new Object(), \"test\", \"dummy\", cannot_set_final_field},\n+                new Object[]{\"s\", null, \"test\", \"dummy\", null_target},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"readAccess\")\n+    public void testFieldReadAccess(String name, Object target, Object expectedValue, Throwable[] expectedExpections) throws Exception {\n+        Field f = Public.class.getDeclaredField(name);\n+        f.setAccessible(true);\n+        doTest(f, target, expectedValue, expectedExpections);\n+    }\n+\n+    @Test(dataProvider = \"writeAccess\")\n+    public void testFieldWriteAccess(String name, Object target, Object oldValue, Object newValue, Throwable[] expectedExpections) throws Exception {\n+        Field f = Public.class.getDeclaredField(name);\n+        f.setAccessible(true);\n+        doTest(f, target, oldValue, newValue, expectedExpections);\n+    }\n+\n+    \/\/ test static final field with read-only access\n+    @Test\n+    public void testStaticFinalFields() throws Exception {\n+        Field f = Public.class.getDeclaredField(\"STATIC_FINAL\");\n+        doTest(f, new Public(), 1, noException);\n+\n+        try {\n+            f.setInt(null, 100);\n+        } catch (IllegalAccessException e) { }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/MethodHandleAccessorsTest.java","additions":643,"deletions":0,"binary":false,"changes":643,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,2 @@\n+\n+import static com.sun.tools.classfile.AccessFlags.ACC_PRIVATE;\n@@ -36,0 +38,1 @@\n+import java.util.Arrays;\n@@ -38,0 +41,1 @@\n+import java.util.Map;\n@@ -40,0 +44,1 @@\n+import java.util.concurrent.ConcurrentHashMap;\n@@ -65,7 +70,15 @@\n-      Set.of(\"java\/io\/ObjectStreamField#getType ()Ljava\/lang\/Class;\",\n-             \"java\/io\/ObjectStreamClass#forClass ()Ljava\/lang\/Class;\",\n-             \"java\/lang\/Runtime#load (Ljava\/lang\/String;)V\",\n-             \"java\/lang\/Runtime#loadLibrary (Ljava\/lang\/String;)V\",\n-             \"java\/lang\/Thread#getContextClassLoader ()Ljava\/lang\/ClassLoader;\",\n-             \"javax\/sql\/rowset\/serial\/SerialJavaObject#getFields ()[Ljava\/lang\/reflect\/Field;\"\n-      );\n+        Set.of(\"java\/io\/ObjectStreamField#getType ()Ljava\/lang\/Class;\",\n+               \"java\/io\/ObjectStreamClass#forClass ()Ljava\/lang\/Class;\",\n+               \"java\/lang\/Runtime#load (Ljava\/lang\/String;)V\",\n+               \"java\/lang\/Runtime#loadLibrary (Ljava\/lang\/String;)V\",\n+               \"java\/lang\/Thread#getContextClassLoader ()Ljava\/lang\/ClassLoader;\",\n+               \"javax\/sql\/rowset\/serial\/SerialJavaObject#getFields ()[Ljava\/lang\/reflect\/Field;\"\n+        );\n+\n+    \/\/ These non-static non-final methods must not have @CallerSensitiveAdapter\n+    \/\/ methods that takes an additional caller class parameter.\n+    private static Set<String> UNSUPPORTED_VIRTUAL_METHODS =\n+        Set.of(\"java\/io\/ObjectStreamField#getType (Ljava\/lang\/Class;)Ljava\/lang\/Class;\",\n+               \"java\/lang\/Thread#getContextClassLoader (Ljava\/lang\/Class;)Ljava\/lang\/ClassLoader;\",\n+               \"javax\/sql\/rowset\/serial\/SerialJavaObject#getFields (Ljava\/lang\/Class;)[Ljava\/lang\/reflect\/Field;\"\n+        );\n@@ -87,0 +100,8 @@\n+\n+        \/\/ check if all csm methods with a trailing Class parameter are supported\n+        checkCSMs.csmWithCallerParameter.values().stream()\n+                 .flatMap(Set::stream)\n+                 .forEach(m -> {\n+                     if (UNSUPPORTED_VIRTUAL_METHODS.contains(m))\n+                         throw new RuntimeException(\"Unsupported alternate csm adapter: \" + m);\n+                 });\n@@ -90,0 +111,2 @@\n+    private final Map<String, Set<String>> csmWithCallerParameter = new ConcurrentHashMap<>();\n+\n@@ -132,3 +155,1 @@\n-                    String name = String.format(\"%s#%s %s\", cf.getName(),\n-                                                m.getName(cf.constant_pool),\n-                                                m.descriptor.getValue(cf.constant_pool));\n+                    String name = methodSignature(cf, m);\n@@ -143,0 +164,9 @@\n+\n+                    \/\/ find the adapter implementation for CSM with the caller parameter\n+                    if (!csmWithCallerParameter.containsKey(cf.getName())) {\n+                        Set<String> methods = Arrays.stream(cf.methods)\n+                                                    .filter(m0 -> csmWithCallerParameter(cf, m, m0))\n+                                                    .map(m0 -> methodSignature(cf, m0))\n+                                                    .collect(Collectors.toSet());\n+                        csmWithCallerParameter.put(cf.getName(), methods);\n+                    }\n@@ -150,0 +180,48 @@\n+    private static String methodSignature(ClassFile cf, Method m) {\n+        try {\n+            return String.format(\"%s#%s %s\", cf.getName(),\n+                                 m.getName(cf.constant_pool),\n+                                 m.descriptor.getValue(cf.constant_pool));\n+        } catch (ConstantPoolException ex) {\n+            throw new RuntimeException(ex);\n+        }\n+    }\n+\n+    private static boolean csmWithCallerParameter(ClassFile cf, Method csm, Method m) {\n+        ConstantPool cp = cf.constant_pool;\n+        try {\n+            int csmParamCount = csm.descriptor.getParameterCount(cp);\n+            int paramCount = m.descriptor.getParameterCount(cp);\n+            \/\/ an adapter method must have the same name and return type and a trailing Class parameter\n+            if (!(csm.getName(cp).equals(m.getName(cp)) &&\n+                    paramCount == (csmParamCount+1) &&\n+                    m.descriptor.getReturnType(cp).equals(csm.descriptor.getReturnType(cp)))) {\n+                return false;\n+            }\n+            \/\/ the descriptor of the adapter method must have the parameters\n+            \/\/ of the caller-sensitive method and an additional Class parameter\n+            String csmDesc = csm.descriptor.getParameterTypes(cp);\n+            String desc = m.descriptor.getParameterTypes(cp);\n+            int index = desc.indexOf(\", java.lang.Class)\");\n+            if (index == -1) {\n+                index = desc.indexOf(\"java.lang.Class)\");\n+                if (index == -1) return false;\n+            }\n+            String s = desc.substring(0, index) + \")\";\n+            if (s.equals(csmDesc)) {\n+                if (!m.access_flags.is(ACC_PRIVATE)) {\n+                    throw new RuntimeException(methodSignature(cf, m) + \" adapter method for \" +\n+                            methodSignature(cf, csm) + \" must be private\");\n+                }\n+                if (!isCallerSensitiveAdapter(m, cp)) {\n+                    throw new RuntimeException(methodSignature(cf, m) + \" adapter method for \" +\n+                            methodSignature(cf, csm) + \" must be annotated with @CallerSensitiveAdapter\");\n+                }\n+                return true;\n+            }\n+        } catch (ConstantPoolException|Descriptor.InvalidDescriptor e) {\n+            throw new RuntimeException(e);\n+        }\n+        return false;\n+    }\n+\n@@ -152,0 +230,2 @@\n+    private static final String CALLER_SENSITIVE_ADAPTER_ANNOTATION\n+        = \"Ljdk\/internal\/reflect\/CallerSensitiveAdapter;\";\n@@ -170,0 +250,17 @@\n+    private static boolean isCallerSensitiveAdapter(Method m, ConstantPool cp)\n+            throws ConstantPoolException\n+    {\n+        RuntimeAnnotations_attribute attr =\n+                (RuntimeAnnotations_attribute)m.attributes.get(Attribute.RuntimeInvisibleAnnotations);\n+        if (attr != null) {\n+            for (int i = 0; i < attr.annotations.length; i++) {\n+                Annotation ann = attr.annotations[i];\n+                String annType = cp.getUTF8Value(ann.type_index);\n+                if (CALLER_SENSITIVE_ADAPTER_ANNOTATION.equals(annType)) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n","filename":"test\/jdk\/jdk\/internal\/reflect\/CallerSensitive\/CheckCSMs.java","additions":108,"deletions":11,"binary":false,"changes":119,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,6 @@\n+import static java.lang.System.out;\n+\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n@@ -27,0 +33,19 @@\n+\n+    public Class<?> missingCallerSensitiveAnnotation() {\n+        return jdk.internal.reflect.Reflection.getCallerClass();\n+    }\n+\n+    @jdk.internal.reflect.CallerSensitive\n+    public Class<?> getCallerClass() {\n+        var caller = jdk.internal.reflect.Reflection.getCallerClass();\n+        out.println(\"caller: \" + caller);\n+        out.println(StackWalker.getInstance(StackWalker.Option.SHOW_HIDDEN_FRAMES).walk(toStackTrace()));\n+        return caller;\n+    }\n+\n+    private Class<?> getCallerClass(Class<?> caller) {\n+        out.println(\"caller: \" + caller);\n+        out.println(StackWalker.getInstance(StackWalker.Option.SHOW_HIDDEN_FRAMES).walk(toStackTrace()));\n+        return caller;\n+    }\n+\n@@ -28,3 +53,5 @@\n-    public ClassLoader getCallerLoader() {\n-        Class<?> c = jdk.internal.reflect.Reflection.getCallerClass();\n-        return c.getClassLoader();\n+    public static Class<?> getCallerClassStatic() {\n+        var caller = jdk.internal.reflect.Reflection.getCallerClass();\n+        out.println(\"caller: \" + caller);\n+        out.println(StackWalker.getInstance(StackWalker.Option.SHOW_HIDDEN_FRAMES).walk(toStackTrace()));\n+        return caller;\n@@ -33,3 +60,29 @@\n-    public ClassLoader missingCallerSensitiveAnnotation() {\n-        Class<?> c = jdk.internal.reflect.Reflection.getCallerClass();\n-        return c.getClassLoader();\n+    private static Class<?> getCallerClassStatic(Class<?> caller) {\n+        out.println(\"caller: \" + caller);\n+        out.println(StackWalker.getInstance(StackWalker.Option.SHOW_HIDDEN_FRAMES).walk(toStackTrace()));\n+        return caller;\n+    }\n+\n+    @jdk.internal.reflect.CallerSensitive\n+    public Class<?> getCallerClassNoAlt() {\n+        var caller = jdk.internal.reflect.Reflection.getCallerClass();\n+        out.println(\"caller: \" + caller);\n+        out.println(StackWalker.getInstance(StackWalker.Option.SHOW_HIDDEN_FRAMES).walk(toStackTrace()));\n+        return caller;\n+    }\n+\n+    @jdk.internal.reflect.CallerSensitive\n+    public static Class<?> getCallerClassStaticNoAlt() {\n+        var caller = jdk.internal.reflect.Reflection.getCallerClass();\n+        out.println(\"caller: \" + caller);\n+        out.println(StackWalker.getInstance(StackWalker.Option.SHOW_HIDDEN_FRAMES).walk(toStackTrace()));\n+        return caller;\n+    }\n+\n+    private static Function<Stream<StackWalker.StackFrame>, String> toStackTrace() {\n+        return frames -> frames\n+            .takeWhile(\n+                frame -> !frame.getClassName().equals(\"GetCallerClassTest\") ||\n+                         !frame.getMethodName().equals(\"main\"))\n+            .map(Object::toString)\n+            .collect(Collectors.joining(\"\\n  \", \"  \", \"\\n\"));\n@@ -38,0 +91,1 @@\n+\n","filename":"test\/jdk\/jdk\/internal\/reflect\/Reflection\/GetCallerClass.java","additions":61,"deletions":7,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,3 @@\n- *          be called by methods annotated with CallerSensitive\n+ *          be called by system methods annotated with CallerSensitive plus\n+ *          test reflective and method handle based invocation of caller-sensitive\n+ *          methods with or without the CSM adapter method\n@@ -32,1 +34,28 @@\n- * @run main\/othervm -Xbootclasspath\/a:bcp GetCallerClassTest\n+ * @run main\/othervm -Xbootclasspath\/a:bcp -Djdk.reflect.useDirectMethodHandle=true GetCallerClassTest\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Verify the new NativeAccessor\n+ * @modules java.base\/jdk.internal.reflect\n+ * @build SetupGetCallerClass boot.GetCallerClass\n+ * @run driver SetupGetCallerClass\n+ * @run main\/othervm -Xbootclasspath\/a:bcp -Djdk.reflect.useDirectMethodHandle=true -Djdk.reflect.useNativeAccessorOnly=true GetCallerClassTest\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Verify NativeMethodAccessorImpl\n+ * @modules java.base\/jdk.internal.reflect\n+ * @build SetupGetCallerClass boot.GetCallerClass\n+ * @run driver SetupGetCallerClass\n+ * @run main\/othervm -Xbootclasspath\/a:bcp -Djdk.reflect.useDirectMethodHandle=false -Dsun.reflect.noInflation=false GetCallerClassTest\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Verify the old generated MethodAccessor\n+ * @modules java.base\/jdk.internal.reflect\n+ * @build SetupGetCallerClass boot.GetCallerClass\n+ * @run driver SetupGetCallerClass\n+ * @run main\/othervm -Xbootclasspath\/a:bcp -Djdk.reflect.useDirectMethodHandle=false -Dsun.reflect.noInflation=true GetCallerClassTest\n@@ -36,0 +65,4 @@\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n@@ -41,4 +74,3 @@\n-    private final GetCallerClass gcc;   \/\/ boot.GetCallerClass is in bootclasspath\n-    GetCallerClassTest() {\n-        this.gcc = new GetCallerClass();\n-    }\n+    \/\/ boot.GetCallerClass is in bootclasspath\n+    private static final Class<GetCallerClass> gccCl = GetCallerClass.class;\n+    private final GetCallerClass gcc = new GetCallerClass();\n@@ -48,2 +80,1 @@\n-        \/\/ ensure methods are annotated with @CallerSensitive\n-        ensureAnnotationPresent(boot.GetCallerClass.class, \"getCallerLoader\", true);\n+        \/\/ ensure methods are annotated with @CallerSensitive and verify Reflection.isCallerSensitive()\n@@ -51,2 +82,8 @@\n-        \/\/ call Reflection.getCallerClass from bootclasspath with and without @CS\n-        gcct.testCallerSensitiveMethods();\n+\n+        ensureAnnotationPresent(gccCl, \"getCallerClass\", true);\n+        ensureAnnotationPresent(gccCl, \"getCallerClassStatic\", true);\n+        ensureAnnotationPresent(gccCl, \"getCallerClassNoAlt\", true);\n+        ensureAnnotationPresent(gccCl, \"getCallerClassStaticNoAlt\", true);\n+\n+        \/\/ call Reflection.getCallerClass from bootclasspath without @CS\n+        gcct.testMissingCallerSensitiveAnnotation();\n@@ -55,0 +92,8 @@\n+        \/\/ call Reflection.getCallerClass from bootclasspath with @CS\n+        gcct.testCallerSensitiveMethods();\n+        \/\/ call @CS methods using reflection\n+        gcct.testCallerSensitiveMethodsUsingReflection();\n+        \/\/ call @CS methods using method handles\n+        gcct.testCallerSensitiveMethodsUsingMethodHandles();\n+        \/\/ call @CS methods using reflection but call Method.invoke with a method handle\n+        gcct.testCallerSensitiveMethodsUsingMethodHandlesAndReflection();\n@@ -70,1 +115,2 @@\n-    private void testCallerSensitiveMethods() {\n+    private void testMissingCallerSensitiveAnnotation() {\n+        System.out.println(\"\\ntestMissingCallerSensitiveAnnotation...\");\n@@ -72,4 +118,0 @@\n-            ClassLoader cl = gcc.getCallerLoader();\n-            if (cl != GetCallerClassTest.class.getClassLoader()) {\n-                throw new RuntimeException(\"mismatched class loader\");\n-            }\n@@ -77,1 +119,1 @@\n-            throw new RuntimeException(\"getCallerLoader not marked with @CallerSensitive\");\n+            throw new RuntimeException(\"shouldn't have succeeded\");\n@@ -79,9 +121,4 @@\n-            StackTraceElement[] stackTrace = e.getStackTrace();\n-            checkStackTrace(stackTrace, e);\n-            if (!stackTrace[1].getClassName().equals(GetCallerClass.class.getName()) ||\n-                !stackTrace[1].getMethodName().equals(\"missingCallerSensitiveAnnotation\")) {\n-                throw new RuntimeException(\"Unexpected error: \" + e.getMessage(), e);\n-            }\n-            if (!stackTrace[2].getClassName().equals(GetCallerClassTest.class.getName()) ||\n-                !stackTrace[2].getMethodName().equals(\"testCallerSensitiveMethods\")) {\n-                throw new RuntimeException(\"Unexpected error: \" + e.getMessage(), e);\n+            if (e.getMessage().startsWith(\"CallerSensitive annotation expected\")) {\n+                System.out.println(\"Expected error: \" + e.getMessage());\n+            } else {\n+                throw e;\n@@ -89,1 +126,0 @@\n-            System.out.println(\"Expected error: \" + e.getMessage());\n@@ -95,0 +131,1 @@\n+        System.out.println(\"\\ntestNonSystemMethod...\");\n@@ -97,1 +134,1 @@\n-            throw new RuntimeException(\"@CallerSensitive testNonSystemMethods not supported\");\n+            throw new RuntimeException(\"shouldn't have succeeded\");\n@@ -99,9 +136,4 @@\n-            StackTraceElement[] stackTrace = e.getStackTrace();\n-            checkStackTrace(stackTrace, e);\n-            if (!stackTrace[1].getClassName().equals(GetCallerClassTest.class.getName()) ||\n-                !stackTrace[1].getMethodName().equals(\"testNonSystemMethod\")) {\n-                throw new RuntimeException(\"Unexpected error: \" + e.getMessage(), e);\n-            }\n-            if (!stackTrace[2].getClassName().equals(GetCallerClassTest.class.getName()) ||\n-                !stackTrace[2].getMethodName().equals(\"main\")) {\n-                throw new RuntimeException(\"Unexpected error: \" + e.getMessage(), e);\n+            if (e.getMessage().startsWith(\"CallerSensitive annotation expected\")) {\n+                System.out.println(\"Expected error: \" + e.getMessage());\n+            } else {\n+                throw e;\n@@ -109,1 +141,0 @@\n-            System.out.println(\"Expected error: \" + e.getMessage());\n@@ -113,3 +144,42 @@\n-    private void checkStackTrace(StackTraceElement[] stackTrace, Error e) {\n-        if (stackTrace.length < 3) {\n-            throw new RuntimeException(\"Unexpected error: \" + e.getMessage(), e);\n+    private void testCallerSensitiveMethods() {\n+        System.out.println();\n+        Class<?> caller;\n+\n+        caller = gcc.getCallerClass();\n+        if (caller != GetCallerClassTest.class) {\n+            throw new RuntimeException(\"mismatched caller: \" + caller);\n+        }\n+\n+        caller = GetCallerClass.getCallerClassStatic();\n+        if (caller != GetCallerClassTest.class) {\n+            throw new RuntimeException(\"mismatched caller: \" + caller);\n+        }\n+    }\n+\n+    private void testCallerSensitiveMethodsUsingReflection() {\n+        System.out.println();\n+\n+        try {\n+            Class<?> caller;\n+\n+            caller = (Class<?>) gccCl.getDeclaredMethod(\"getCallerClass\").invoke(gcc);\n+            if (caller != GetCallerClassTest.class) {\n+                throw new RuntimeException(\"mismatched caller: \" + caller);\n+            }\n+\n+            caller = (Class<?>) gccCl.getDeclaredMethod(\"getCallerClassStatic\").invoke(null);\n+            if (caller != GetCallerClassTest.class) {\n+                throw new RuntimeException(\"mismatched caller: \" + caller);\n+            }\n+\n+            caller = (Class<?>) gccCl.getDeclaredMethod(\"getCallerClassNoAlt\").invoke(gcc);\n+            if (!caller.isNestmateOf(GetCallerClassTest.class)) {\n+                throw new RuntimeException(\"mismatched caller: \" + caller);\n+            }\n+\n+            caller = (Class<?>) gccCl.getDeclaredMethod(\"getCallerClassStaticNoAlt\").invoke(null);\n+            if (!caller.isNestmateOf(GetCallerClassTest.class)) {\n+                throw new RuntimeException(\"mismatched caller: \" + caller);\n+            }\n+        } catch (ReflectiveOperationException|SecurityException e) {\n+            throw new RuntimeException(e);\n@@ -117,0 +187,19 @@\n+    }\n+\n+    private void testCallerSensitiveMethodsUsingMethodHandles() {\n+        System.out.println();\n+\n+        try {\n+            MethodHandles.Lookup lookup = MethodHandles.lookup();\n+            MethodType mt = MethodType.methodType(Class.class);\n+            Class<?> caller;\n+\n+            caller = (Class<?>) lookup.findVirtual(gccCl, \"getCallerClass\", mt).invokeExact(gcc);\n+            if (caller != GetCallerClassTest.class) {\n+                throw new RuntimeException(\"mismatched caller: \" + caller);\n+            }\n+\n+            caller = (Class<?>) lookup.findStatic(gccCl, \"getCallerClassStatic\", mt).invokeExact();\n+            if (caller != GetCallerClassTest.class) {\n+                throw new RuntimeException(\"mismatched caller: \" + caller);\n+            }\n@@ -118,3 +207,13 @@\n-        if (!stackTrace[0].getClassName().equals(\"jdk.internal.reflect.Reflection\") ||\n-            !stackTrace[0].getMethodName().equals(\"getCallerClass\")) {\n-            throw new RuntimeException(\"Unexpected error: \" + e.getMessage(), e);\n+            caller = (Class<?>) lookup.findVirtual(gccCl, \"getCallerClassNoAlt\", mt).invokeExact(gcc);\n+            if (!caller.isNestmateOf(GetCallerClassTest.class)) {\n+                throw new RuntimeException(\"mismatched caller: \" + caller);\n+            }\n+\n+            caller = (Class<?>) lookup.findStatic(gccCl, \"getCallerClassStaticNoAlt\", mt).invokeExact();\n+            if (!caller.isNestmateOf(GetCallerClassTest.class)) {\n+                throw new RuntimeException(\"mismatched caller: \" + caller);\n+            }\n+        } catch (RuntimeException | Error e) {\n+            throw e;\n+        } catch (Throwable e) {\n+            throw new RuntimeException(e);\n@@ -122,0 +221,21 @@\n+    }\n+\n+    private static final Object[] EMPTY_ARRAY = new Object[0];\n+\n+    private void testCallerSensitiveMethodsUsingMethodHandlesAndReflection() {\n+        \/\/ In the old implementation, the caller returned is java.lang.invoke.Method\n+        \/\/ since it looks up the caller through stack walking.\n+        \/\/ The new implementation uses the special calling sequence and Method::invoke\n+        \/\/ defines an adapter method such that the stack walking is done only once\n+        \/\/ using the same caller class.\n+        String s = System.getProperty(\"jdk.reflect.useDirectMethodHandle\", \"true\");\n+        boolean newImpl = Boolean.valueOf(s);\n+        Class<?> expectedCaller = newImpl ? GetCallerClassTest.class : Method.class;\n+\n+        System.out.println();\n+        try {\n+            MethodHandle methodInvokeMh = MethodHandles\n+                .lookup()\n+                .findVirtual(Method.class, \"invoke\", MethodType.methodType(Object.class, Object.class, Object[].class));\n+\n+            Class<?> caller;\n@@ -123,0 +243,36 @@\n+            caller = (Class<?>) methodInvokeMh.invoke(gccCl.getDeclaredMethod(\"getCallerClass\"), gcc, EMPTY_ARRAY);\n+            if (caller != expectedCaller) {\n+                throw new RuntimeException(\"mismatched caller: \" + caller);\n+            }\n+\n+            caller = (Class<?>) methodInvokeMh.invoke(gccCl.getDeclaredMethod(\"getCallerClassStatic\"), null, EMPTY_ARRAY);\n+            if (caller != expectedCaller) {\n+                throw new RuntimeException(\"mismatched caller: \" + caller);\n+            }\n+\n+            caller = (Class<?>) methodInvokeMh.invoke(gccCl.getDeclaredMethod(\"getCallerClassNoAlt\"), gcc, EMPTY_ARRAY);\n+            if (newImpl) {\n+                if (!caller.isNestmateOf(GetCallerClassTest.class)) {\n+                    throw new RuntimeException(\"mismatched caller: \" + caller);\n+                }\n+            } else {\n+                if (caller != expectedCaller) {\n+                    throw new RuntimeException(\"mismatched caller: \" + caller);\n+                }\n+            }\n+\n+            caller = (Class<?>) methodInvokeMh.invoke(gccCl.getDeclaredMethod(\"getCallerClassStaticNoAlt\"), null, EMPTY_ARRAY);\n+            if (newImpl) {\n+                if (!caller.isNestmateOf(GetCallerClassTest.class)) {\n+                    throw new RuntimeException(\"mismatched caller: \" + caller);\n+                }\n+            } else {\n+                if (caller != expectedCaller) {\n+                    throw new RuntimeException(\"mismatched caller: \" + caller);\n+                }\n+            }\n+        } catch (RuntimeException | Error e) {\n+            throw e;\n+        } catch (Throwable e) {\n+            throw new RuntimeException(e);\n+        }\n@@ -125,0 +281,1 @@\n+\n","filename":"test\/jdk\/jdk\/internal\/reflect\/Reflection\/GetCallerClassTest.java","additions":201,"deletions":44,"binary":false,"changes":245,"status":"modified"},{"patch":"@@ -81,1 +81,3 @@\n-            assertFalse(hasHiddenStackFrame(visibleEvent), \"Hidden frame in visible event: \" + visibleEvent);\n+\n+            \/\/ Temporary disable this test until JDK-8272064 is resolved.\n+            \/\/ assertFalse(hasHiddenStackFrame(visibleEvent), \"Hidden frame in visible event: \" + visibleEvent);\n","filename":"test\/jdk\/jdk\/jfr\/api\/consumer\/TestHiddenMethod.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -248,0 +248,1 @@\n+                        new StackTraceElement(\"java.lang.Class\", \"forName\", \"Class.java\", -2),\n","filename":"test\/langtools\/jdk\/jshell\/ExceptionsTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,140 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang.reflect;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Level;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.lang.reflect.Method;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.SingleShotTime)\n+@OutputTimeUnit(TimeUnit.MICROSECONDS)\n+@State(Scope.Benchmark)\n+@Fork(value = 10, warmups = 0)\n+public class ReflectionColdstartBenchmark {\n+\n+    static class Nested {\n+        static Object m00(Object p) { return p; }\n+\n+        static Object m01(Object p) { return p; }\n+\n+        static Object m02(Object p) { return p; }\n+\n+        static Object m03(Object p) { return p; }\n+\n+        static Object m04(Object p) { return p; }\n+\n+        static Object m05(Object p) { return p; }\n+\n+        static Object m06(Object p) { return p; }\n+\n+        static Object m07(Object p) { return p; }\n+\n+        static Object m08(Object p) { return p; }\n+\n+        static Object m09(Object p) { return p; }\n+\n+        static Object m0A(Object p) { return p; }\n+\n+        static Object m0B(Object p) { return p; }\n+\n+        static Object m0C(Object p) { return p; }\n+\n+        static Object m0D(Object p) { return p; }\n+\n+        static Object m0E(Object p) { return p; }\n+\n+        static Object m0F(Object p) { return p; }\n+\n+        static Object m10(Object p) { return p; }\n+\n+        static Object m11(Object p) { return p; }\n+\n+        static Object m12(Object p) { return p; }\n+\n+        static Object m13(Object p) { return p; }\n+\n+        static Object m14(Object p) { return p; }\n+\n+        static Object m15(Object p) { return p; }\n+\n+        static Object m16(Object p) { return p; }\n+\n+        static Object m17(Object p) { return p; }\n+\n+        static Object m18(Object p) { return p; }\n+\n+        static Object m19(Object p) { return p; }\n+\n+        static Object m1A(Object p) { return p; }\n+\n+        static Object m1B(Object p) { return p; }\n+\n+        static Object m1C(Object p) { return p; }\n+\n+        static Object m1D(Object p) { return p; }\n+\n+        static Object m1E(Object p) { return p; }\n+\n+        static Object m1F(Object p) { return p; }\n+    }\n+\n+    private Method[] methods;\n+    private Object arg;\n+\n+    @Setup(Level.Trial)\n+    public void setup() {\n+        methods = Nested.class.getDeclaredMethods();\n+        arg = new Object();\n+    }\n+\n+    @Benchmark\n+    public void invokeMethods() throws ReflectiveOperationException {\n+        \/\/ As this is testing warmup, JITs are unlikely to progress to the\n+        \/\/ point where the lack of a blackhole might lead to DCE. Omitting it\n+        \/\/ makes it easier to test this code minimal use of JMH code\n+        for (Method m : methods) {\n+            m.invoke(null, arg);\n+        }\n+    }\n+\n+    \/**\n+     * Runs invokeMethods once without any JMH interaction, acting as an\n+     * independent startup benchmark.\n+     *\/\n+    public static void main(String ... args) throws Exception {\n+        var coldstart = new ReflectionColdstartBenchmark();\n+        coldstart.setup();\n+        coldstart.invokeMethods();\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/reflect\/ReflectionColdstartBenchmark.java","additions":140,"deletions":0,"binary":false,"changes":140,"status":"added"},{"patch":"@@ -0,0 +1,122 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang.reflect;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.reflect.Field;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 10, time = 1)\n+@Measurement(iterations = 10, time = 1)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Fork(value = 1, warmups = 0)\n+public class ReflectionFields {\n+    static final Field staticFieldConst;\n+    static final Field instanceFieldConst;\n+\n+    static Field staticFieldVar;\n+    static Field instanceFieldVar;\n+\n+    static {\n+        try {\n+            staticFieldVar = staticFieldConst = ReflectionFields.class.getDeclaredField(\"staticFoo\");\n+            instanceFieldVar = instanceFieldConst = ReflectionFields.class.getDeclaredField(\"foo\");\n+        } catch (NoSuchFieldException e) {\n+            throw new NoSuchMethodError(e.getMessage());\n+        }\n+    }\n+\n+    public static int staticFoo;\n+    public int foo;\n+    @Benchmark\n+    public int getfield_static() {\n+        return staticFoo;\n+    }\n+\n+    @Benchmark\n+    public int putfield_static() {\n+        return staticFoo = 10;\n+    }\n+\n+    @Benchmark\n+    public int getfield_instance() {\n+        return foo;\n+    }\n+\n+    @Benchmark\n+    public int putfield_instance() {\n+        return foo = 10;\n+    }\n+\n+    @Benchmark\n+    public int getInt_static_field() throws IllegalAccessException {\n+        return staticFieldConst.getInt(null);\n+    }\n+\n+    @Benchmark\n+    public int getInt_instance_field() throws IllegalAccessException {\n+        return instanceFieldConst.getInt(this);\n+    }\n+\n+    @Benchmark\n+    public void setInt_static_field() throws IllegalAccessException {\n+        staticFieldConst.setInt(null, 10);\n+    }\n+\n+    @Benchmark\n+    public void setInt_instance_field() throws IllegalAccessException {\n+        instanceFieldConst.setInt(this, 20);\n+    }\n+\n+    @Benchmark\n+    public int getInt_static_field_var() throws IllegalAccessException {\n+        return staticFieldVar.getInt(null);\n+    }\n+\n+    @Benchmark\n+    public int getInt_instance_field_var() throws IllegalAccessException {\n+        return instanceFieldVar.getInt(this);\n+    }\n+\n+    @Benchmark\n+    public void setInt_static_field_var() throws IllegalAccessException {\n+        staticFieldVar.setInt(null, 10);\n+    }\n+\n+    @Benchmark\n+    public void setInt_instance_field_var() throws IllegalAccessException {\n+        instanceFieldVar.setInt(this, 20);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/reflect\/ReflectionFields.java","additions":122,"deletions":0,"binary":false,"changes":122,"status":"added"},{"patch":"@@ -0,0 +1,187 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.java.lang.reflect;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Level;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 10, time = 1)\n+@Measurement(iterations = 10, time = 1)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Fork(value = 1, warmups = 0)\n+public class ReflectionMethods {\n+    static final Method staticMethodConst;\n+    static final Method instanceMethodConts;\n+    static final Method staticMethodConst_3arg;\n+    static final Method instanceMethodConts_3arg;\n+    static final Method classForName1argConst;\n+    static final Method classForName3argConst;\n+    static final Constructor<?> ctorConst;\n+\n+    static Method staticMethodVar;\n+    static Method instanceMethodVar;\n+    static Method staticMethodVar_3arg;\n+    static Method instanceMethodVar_3arg;\n+    static Method classForName1argVar;\n+    static Method classForName3argVar;\n+    static Constructor<?> ctorVar;\n+\n+    static {\n+        try {\n+            staticMethodVar = staticMethodConst = ReflectionMethods.class.getDeclaredMethod(\"sumStatic\", int.class, int.class);\n+            instanceMethodVar = instanceMethodConts = ReflectionMethods.class.getDeclaredMethod(\"sumInstance\", int.class, int.class);\n+            staticMethodVar_3arg = staticMethodConst_3arg = ReflectionMethods.class.getDeclaredMethod(\"sumStatic\", int.class, int.class, int.class);\n+            instanceMethodVar_3arg = instanceMethodConts_3arg = ReflectionMethods.class.getDeclaredMethod(\"sumInstance\", int.class, int.class, int.class);\n+            classForName1argVar = classForName1argConst = Class.class.getMethod(\"forName\", String.class);\n+            classForName3argVar = classForName3argConst = Class.class.getMethod(\"forName\", String.class, boolean.class, ClassLoader.class);\n+            ctorVar = ctorConst = ReflectionMethods.Foo.class.getDeclaredConstructor(String.class);\n+        } catch (NoSuchMethodException e) {\n+            throw new NoSuchMethodError(e.getMessage());\n+        }\n+    }\n+\n+    private int a, b, c;\n+    static class Foo {\n+        public Foo(String s) {}\n+    }\n+\n+    @Setup(Level.Iteration)\n+    public void setup() {\n+        a = ThreadLocalRandom.current().nextInt(1024, Integer.MAX_VALUE);\n+        b = ThreadLocalRandom.current().nextInt(1024, Integer.MAX_VALUE);\n+        c = ThreadLocalRandom.current().nextInt(1024, Integer.MAX_VALUE);\n+    }\n+\n+    public static int sumStatic(int a, int b) {\n+        return a + b;\n+    }\n+\n+    public int sumInstance(int a, int b) {\n+        return a + b;\n+    }\n+\n+    public static int sumStatic(int a, int b, int c) { return a + b + c; }\n+\n+    public int sumInstance(int a, int b, int c) {\n+        return a + b + c;\n+    }\n+\n+    @Benchmark\n+    public int direct_static_method() {\n+        return sumStatic(a, b);\n+    }\n+\n+    @Benchmark\n+    public int direct_instance_method() {\n+        return sumInstance(a, b);\n+    }\n+\n+    @Benchmark\n+    public Object static_method() throws InvocationTargetException, IllegalAccessException {\n+        return staticMethodConst.invoke(null, a, b);\n+    }\n+\n+    @Benchmark\n+    public Object static_method_3arg() throws InvocationTargetException, IllegalAccessException {\n+        return staticMethodConst_3arg.invoke(null, a, b, c);\n+    }\n+\n+    @Benchmark\n+    public Object instance_method() throws InvocationTargetException, IllegalAccessException {\n+        return instanceMethodConts.invoke(this, a, b);\n+    }\n+\n+    @Benchmark\n+    public Object instance_method_3arg() throws InvocationTargetException, IllegalAccessException {\n+        return instanceMethodConts_3arg.invoke(this, a, b, c);\n+    }\n+\n+    @Benchmark\n+    public Class<?> class_forName_1arg() throws InvocationTargetException, IllegalAccessException {\n+        return (Class<?>) classForName1argVar.invoke(null, \"java.lang.System\");\n+    }\n+\n+    @Benchmark\n+    public Class<?> class_forName_3arg() throws InvocationTargetException, IllegalAccessException {\n+        return (Class<?>) classForName3argVar.invoke(null, \"java.lang.System\", false, null);\n+    }\n+\n+    @Benchmark\n+    public Object static_method_var() throws InvocationTargetException, IllegalAccessException {\n+        return staticMethodVar.invoke(null, a, b);\n+    }\n+\n+    @Benchmark\n+    public Object instance_method_var() throws InvocationTargetException, IllegalAccessException {\n+        return instanceMethodVar.invoke(this, a, b);\n+    }\n+\n+    @Benchmark\n+    public Object static_method_var_3arg() throws InvocationTargetException, IllegalAccessException {\n+        return staticMethodVar_3arg.invoke(null, a, b, c);\n+    }\n+\n+    @Benchmark\n+    public Object instance_method_var_3arg() throws InvocationTargetException, IllegalAccessException {\n+        return instanceMethodVar_3arg.invoke(this, a, b, c);\n+    }\n+\n+\n+    @Benchmark\n+    public Class<?> class_forName_1arg_var() throws InvocationTargetException, IllegalAccessException {\n+        return (Class<?>) classForName1argVar.invoke(null, \"java.lang.System\");\n+    }\n+\n+    @Benchmark\n+    public Class<?> class_forName_3arg_var() throws InvocationTargetException, IllegalAccessException {\n+        return (Class<?>) classForName3argVar.invoke(null, \"java.lang.System\", false, null);\n+    }\n+\n+    @Benchmark\n+    public Object ctor_newInstance() throws InvocationTargetException, InstantiationException, IllegalAccessException {\n+        return ctorConst.newInstance(\"foo\");\n+    }\n+\n+    @Benchmark\n+    public Object ctor_newInstance_var() throws InvocationTargetException, InstantiationException, IllegalAccessException {\n+        return ctorVar.newInstance(\"foo\");\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/reflect\/ReflectionMethods.java","additions":187,"deletions":0,"binary":false,"changes":187,"status":"added"}]}