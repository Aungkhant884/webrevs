{"files":[{"patch":"@@ -69,0 +69,1 @@\n+import static java.lang.invoke.MethodHandleStatics.newInternalError;\n@@ -130,1 +131,1 @@\n-            throw newIllegalArgumentException(\"illegal lookupClass: \"+caller);\n+            throw newInternalError(\"calling lookup() reflectively is not supported: \"+caller);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -479,1 +479,1 @@\n-        if (ReflectionFactory.isUseNativeAccessorOnly())  \/\/ for testing only\n+        if (ReflectionFactory.useNativeAccessorOnly())  \/\/ for testing only\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MethodHandleAccessorFactory.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -632,1 +632,1 @@\n-    static boolean isUseNativeAccessorOnly() {\n+    static boolean useNativeAccessorOnly() {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/ReflectionFactory.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -85,1 +85,1 @@\n-                new CallFrame(\"jdk.internal.reflect.DirectMethodHandleAccessorImpl\", \"invoke\"), \/\/ non-public class\n+                new CallFrame(\"jdk.internal.reflect.DirectMethodHandleAccessor\", \"invoke\"), \/\/ non-public class\n@@ -139,1 +139,1 @@\n-                new CallFrame(\"jdk.internal.reflect.DirectMethodHandleAccessorImpl\", \"invoke\"),\n+                new CallFrame(\"jdk.internal.reflect.DirectMethodHandleAccessor\", \"invoke\"),\n@@ -160,1 +160,1 @@\n-                new CallFrame(\"jdk.internal.reflect.DirectMethodHandleAccessorImpl\", \"invoke\"),\n+                new CallFrame(\"jdk.internal.reflect.DirectMethodHandleAccessor\", \"invoke\"),\n@@ -165,1 +165,1 @@\n-                new CallFrame(\"jdk.internal.reflect.DirectMethodHandleAccessorImpl\", \"invoke\"),\n+                new CallFrame(\"jdk.internal.reflect.DirectMethodHandleAccessor\", \"invoke\"),\n@@ -191,1 +191,1 @@\n-                new CallFrame(\"jdk.internal.reflect.DirectMethodHandleAccessorImpl\", \"invoke\"),\n+                new CallFrame(\"jdk.internal.reflect.DirectMethodHandleAccessor\", \"invoke\"),\n","filename":"test\/jdk\/java\/lang\/StackWalker\/DumpStackTest.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -103,1 +103,1 @@\n-            \"5: java.base\/jdk.internal.reflect.DirectMethodHandleAccessorImpl.invoke(DirectMethodHandleAccessorImpl.java:94)\\n\" +\n+            \"5: java.base\/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:94)\\n\" +\n@@ -141,2 +141,2 @@\n-            \"12: java.base\/jdk.internal.reflect.DirectMethodHandleAccessorImpl.invokeImpl(DirectMethodHandleAccessorImpl.java:211)\\n\" +\n-            \"13: java.base\/jdk.internal.reflect.DirectMethodHandleAccessorImpl.invoke(DirectMethodHandleAccessorImpl.java:122)\\n\" +\n+            \"12: java.base\/jdk.internal.reflect.DirectMethodHandleAccessor.invokeImpl(DirectMethodHandleAccessor.java:211)\\n\" +\n+            \"13: java.base\/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:122)\\n\" +\n","filename":"test\/jdk\/java\/lang\/StackWalker\/VerifyStackTrace.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -84,2 +84,2 @@\n-        checkCaller(java.util.CSM.caller(), MethodInvokeTest.class);\n-        checkCaller(java.util.CSM.callerNoAlternateImpl(), MethodInvokeTest.class);\n+        checkCaller(java.util.CSM.caller(), MethodInvokeTest.class, true);\n+        checkCaller(java.util.CSM.callerNoAlternateImpl(), MethodInvokeTest.class, false);\n@@ -89,2 +89,8 @@\n-        checkCaller(Caller1.invoke(CSM.class.getMethod(CALLER_METHOD)), Caller1.class);\n-        checkCaller(Caller2.invoke(CSM.class.getMethod(CALLER_METHOD)), Caller2.class);\n+        \/\/ zero-arg caller method\n+        checkCaller(Caller1.invoke(CSM.class.getMethod(CALLER_METHOD)), Caller1.class, true);\n+        checkCaller(Caller2.invoke(CSM.class.getMethod(CALLER_METHOD)), Caller2.class, true);\n+        \/\/ 4-arg caller method\n+        checkCaller(Caller1.invoke(CSM.class.getMethod(CALLER_METHOD, Object.class, Object.class, Object.class, Object.class),\n+                                   new Object[] { null, null, null, null}), Caller1.class, true);\n+        checkCaller(Caller2.invoke(CSM.class.getMethod(CALLER_METHOD, Object.class, Object.class, Object.class, Object.class),\n+                                   new Object[] { null, null, null, null}), Caller2.class, true);\n@@ -98,2 +104,2 @@\n-        checkCaller(Caller1.invokeExact(CALLER_METHOD), Caller1.class);\n-        checkCaller(Caller2.invokeExact(CALLER_METHOD), Caller2.class);\n+        checkCaller(Caller1.invokeExact(CALLER_METHOD), Caller1.class, true);\n+        checkCaller(Caller2.invokeExact(CALLER_METHOD), Caller2.class, true);\n@@ -117,0 +123,3 @@\n+        static CSM invoke(Method csm, Object[] args) throws ReflectiveOperationException {\n+            return (CSM)csm.invoke(null, args);\n+        }\n@@ -128,0 +137,3 @@\n+        static CSM invoke(Method csm, Object[] args) throws ReflectiveOperationException {\n+            return (CSM)csm.invoke(null, args);\n+        }\n@@ -156,1 +168,1 @@\n-    static void checkCaller(CSM csm, Class<?> expected) {\n+    static void checkCaller(CSM csm, Class<?> expected, boolean adapter) {\n@@ -158,0 +170,1 @@\n+        assertEquals(csm.adapter, adapter);\n@@ -176,0 +189,1 @@\n+        assertEquals(csm.adapter, false);\n","filename":"test\/jdk\/java\/lang\/invoke\/callerSensitive\/csm\/jdk\/test\/MethodInvokeTest.java","additions":21,"deletions":7,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.reflect.CallerSensitiveAdapter;\n@@ -37,1 +38,2 @@\n-    CSM(Class<?> caller) {\n+    public final boolean adapter;\n+    CSM(Class<?> caller, boolean adapter) {\n@@ -41,0 +43,1 @@\n+        this.adapter = adapter;\n@@ -50,1 +53,1 @@\n-        return new CSM(Reflection.getCallerClass());\n+        return caller(Reflection.getCallerClass());\n@@ -57,0 +60,1 @@\n+    @CallerSensitiveAdapter\n@@ -58,1 +62,1 @@\n-        return new CSM(caller);\n+        return new CSM(caller, true);\n@@ -67,1 +71,15 @@\n-        return new CSM(Reflection.getCallerClass());\n+        return new CSM(Reflection.getCallerClass(), false);\n+    }\n+\n+    @CallerSensitive\n+    public static CSM caller(Object o1, Object o2, Object o3, Object o4) {\n+        return caller(o1, o2, o3, o4, Reflection.getCallerClass());\n+    }\n+\n+    \/**\n+     * If caller() is invoked via method handle, this alternate method is\n+     * called instead.  The caller class would be the lookup class.\n+     *\/\n+    @CallerSensitiveAdapter\n+    private static CSM caller(Object o1, Object o2, Object o3, Object o4, Class<?> caller) {\n+        return new CSM(caller, true);\n","filename":"test\/jdk\/java\/lang\/invoke\/callerSensitive\/src\/java.base\/java\/util\/CSM.java","additions":22,"deletions":4,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-            if (!(e.getCause() instanceof IllegalArgumentException)) {\n+            if (!(e.getCause() instanceof InternalError)) {\n","filename":"test\/jdk\/java\/lang\/invoke\/lookup\/java.base\/java\/lang\/LookupTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}