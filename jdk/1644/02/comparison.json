{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -210,1 +210,1 @@\n-        return nonce.clone();\n+        return (nonce != null) ? nonce.clone() : null;\n@@ -229,0 +229,5 @@\n+            \/\/ In a pre-initialized state or any state without a nonce value\n+            \/\/ this call should cause a random nonce to be generated, but\n+            \/\/ not attached to the object.\n+            byte[] nonceData = (initialized || nonce != null) ? nonce :\n+                    createRandomNonce(null);\n@@ -233,1 +238,1 @@\n-                        DerValue.tag_OctetString, nonce).toByteArray()));\n+                        DerValue.tag_OctetString, nonceData).toByteArray()));\n@@ -507,1 +512,1 @@\n-    private byte[] createRandomNonce(SecureRandom random) {\n+    private static byte[] createRandomNonce(SecureRandom random) {\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/ChaCha20Cipher.java","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8153029\n+ * @bug 8153029 8257769\n@@ -35,0 +35,1 @@\n+import java.math.BigInteger;\n@@ -45,0 +46,3 @@\n+import java.security.InvalidKeyException;\n+import java.security.MessageDigest;\n+import javax.crypto.spec.IvParameterSpec;\n@@ -48,0 +52,2 @@\n+    private static final byte DER_OCT_STRING = 0x04;\n+\n@@ -235,0 +241,105 @@\n+        \/\/ The next set of tests cover cases where ChaCha20-Poly1305 cipher\n+        \/\/ objects have the getParameters() call executed after instantiation\n+        \/\/ but before initialization.\n+        System.out.println(\"*** Test: getParameters before init\");\n+        cc20p1305 = Cipher.getInstance(\"ChaCha20-Poly1305\");\n+        AlgorithmParameters algParams = cc20p1305.getParameters();\n+        byte[] preInitNonce = getNonceFromParams(algParams);\n+        \/\/ A second pre-init getParameters() call should return a new set of\n+        \/\/ random parameters.\n+        AlgorithmParameters algParamsTwo = cc20p1305.getParameters();\n+        byte[] secondNonce = getNonceFromParams(algParamsTwo);\n+        if (MessageDigest.isEqual(preInitNonce, secondNonce)) {\n+            throw new RuntimeException(\"Unexpected nonce match between \" +\n+                    \"two pre-init getParameters() calls\");\n+        }\n+\n+        \/\/ Next we will initialize the Cipher object using a form of init\n+        \/\/ that doesn't take AlgorithmParameters or AlgorithmParameterSpec.\n+        \/\/ The nonce created using the pre-init getParameters() call should\n+        \/\/ be overwritten by a freshly generated set of random parameters.\n+        cc20p1305.init(Cipher.ENCRYPT_MODE, DEF_KEY);\n+        AlgorithmParameters postInitAps = cc20p1305.getParameters();\n+        byte[] postInitNonce = getNonceFromParams(postInitAps);\n+        if (MessageDigest.isEqual(preInitNonce, postInitNonce)) {\n+            throw new RuntimeException(\"Unexpected nonce match between \" +\n+                    \"pre and post-init getParameters() calls\");\n+        }\n+        System.out.println(\"Test Passed\");\n+\n+        \/\/ After an initialization, subsequent calls to getParameters() should\n+        \/\/ return the same parameter value until the next initialization takes\n+        \/\/ place.\n+        System.out.println(\"*** Test: getParameters after init\");\n+        AlgorithmParameters postInitApsTwo = cc20p1305.getParameters();\n+        byte[] postInitNonceTwo = getNonceFromParams(postInitApsTwo);\n+        if (!MessageDigest.isEqual(postInitNonce, postInitNonceTwo)) {\n+            throw new RuntimeException(\"Unexpected nonce mismatch between \" +\n+                    \"two post-init getParameters() calls\");\n+        }\n+        System.out.println(\"Test Passed\");\n+\n+        \/\/ Test reinitialization use cases.\n+        \/\/ First test: instantiate, init(no param), encrypt.  Get params\n+        \/\/ and attempt to reinit with same parameters.  Should fail.\n+        System.out.println(\"*** Test: Init w\/ random nonce, init 2nd time\");\n+        cc20p1305 = Cipher.getInstance(\"ChaCha20-Poly1305\");\n+        cc20p1305.init(Cipher.ENCRYPT_MODE, DEF_KEY);\n+        algParams = cc20p1305.getParameters();\n+        preInitNonce = getNonceFromParams(algParams);\n+        \/\/ Perform a simple encryption operation\n+        cc20p1305.doFinal(aeadTestList.get(0).input);\n+        try {\n+            \/\/ Now try to reinitialize using the same parameters\n+            cc20p1305.init(Cipher.ENCRYPT_MODE, DEF_KEY, algParams);\n+            throw new RuntimeException(\"Illegal key\/nonce reuse\");\n+        } catch (InvalidKeyException ike) {\n+            System.out.println(\"Caught expected exception: \" + ike);\n+        }\n+\n+        \/\/ Test the reinit guard using an AlgorithmParameterSpec with the\n+        \/\/ Same nonce value.  This should also be a failure.\n+        try {\n+            cc20p1305.init(Cipher.ENCRYPT_MODE, DEF_KEY,\n+                    new IvParameterSpec(preInitNonce));\n+            throw new RuntimeException(\"Illegal key\/nonce reuse\");\n+        } catch (InvalidKeyException ike) {\n+            System.out.println(\"Caught expected exception: \" + ike);\n+        }\n+\n+        \/\/ Try one more time, this time providing a new 12-byte nonce, which\n+        \/\/ should be allowed even if the key is the same.\n+        cc20p1305.init(Cipher.ENCRYPT_MODE, DEF_KEY,\n+                new IvParameterSpec(NONCE_OCTET_STR_12, 2, 12));\n+        System.out.println(\"Test Passed\");\n+\n+        \/\/ Reinit test: instantiate, init(no param), getParam, encrypt,\n+        \/\/ then init(no param).  Should work and the parameters should be\n+        \/\/ different after each init.\n+        cc20p1305 = Cipher.getInstance(\"ChaCha20-Poly1305\");\n+        cc20p1305.init(Cipher.ENCRYPT_MODE, DEF_KEY);\n+        byte[] paramInitOne = getNonceFromParams(cc20p1305.getParameters());\n+        \/\/ Perform a simple encryption operation\n+        cc20p1305.doFinal(aeadTestList.get(0).input);\n+        \/\/ reinit (no params)\n+        cc20p1305.init(Cipher.ENCRYPT_MODE, DEF_KEY);\n+        byte[] paramInitTwo = getNonceFromParams(cc20p1305.getParameters());\n+        if (MessageDigest.isEqual(paramInitOne, paramInitTwo)) {\n+            throw new RuntimeException(\"Unexpected nonce match between \" +\n+                    \"pre and post-init getParameters() calls\");\n+        }\n+        System.out.println(\"Test Passed\");\n+\n+        \/\/ Reinit test: instantiate, init(no param), doFinal, then doFinal\n+        \/\/ again without intervening init.  Should fail due to no-reuse\n+        \/\/ protections.\n+        try {\n+            cc20p1305 = Cipher.getInstance(\"ChaCha20-Poly1305\");\n+            cc20p1305.init(Cipher.ENCRYPT_MODE, DEF_KEY);\n+            cc20p1305.doFinal(aeadTestList.get(0).input);\n+            cc20p1305.doFinal(aeadTestList.get(0).input);\n+            throw new RuntimeException(\"Illegal key\/nonce reuse\");\n+        } catch (IllegalStateException ise) {\n+            System.out.println(\"Caught expected exception: \" + ise);\n+        }\n+\n@@ -377,0 +488,25 @@\n+    private static byte[] getNonceFromParams(AlgorithmParameters params)\n+            throws IOException {\n+        \/\/ The format should be a DER-encoded OCTET_STRING\n+        byte[] paramEncoding = params.getEncoded();\n+        if (paramEncoding[0] != DER_OCT_STRING) {\n+            throw new RuntimeException(String.format(\n+                    \"Unexpected encoded data from parameters, \" +\n+                            \"expected 0x04, got 0x%02X\", paramEncoding[0]));\n+        }\n+        \/\/ Get the length, should be short-form but handle long-form too\n+        int len;\n+        int dataOffset;\n+        if ((paramEncoding[1] & 0x80) != 0) {\n+            \/\/ long form\n+            int numLenBytes = paramEncoding[1] & 0x7F;\n+            len = new BigInteger(paramEncoding, 2, numLenBytes).intValue();\n+            dataOffset = 2 + numLenBytes;\n+        } else {\n+            \/\/ short form\n+            len = paramEncoding[1];\n+            dataOffset = 2;\n+        }\n+        return Arrays.copyOfRange(paramEncoding, dataOffset, dataOffset + len);\n+    }\n+\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/ChaCha20\/ChaCha20Poly1305ParamTest.java","additions":138,"deletions":2,"binary":false,"changes":140,"status":"modified"}]}