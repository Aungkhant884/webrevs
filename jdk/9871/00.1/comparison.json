{"files":[{"patch":"@@ -195,2 +195,2 @@\n-void ReturnNode::dump_req(outputStream *st) const {\n-  \/\/ Dump the required inputs, enclosed in '(' and ')'\n+void ReturnNode::dump_req(outputStream *st, DumpConfig* dc) const {\n+  \/\/ Dump the required inputs, after printing \"returns\"\n@@ -199,3 +199,8 @@\n-    if (i == TypeFunc::Parms) st->print(\"returns\");\n-    if (in(i)) st->print(\"%c%d \", Compile::current()->node_arena()->contains(in(i)) ? ' ' : 'o', in(i)->_idx);\n-    else st->print(\"_ \");\n+    if (i == TypeFunc::Parms) st->print(\"returns \");\n+    Node* p = in(i);\n+    if (p != nullptr) {\n+      p->dump_idx(false, st, dc);\n+      st->print(\" \");\n+    } else {\n+      st->print(\"_ \");\n+    }\n@@ -238,2 +243,2 @@\n-void RethrowNode::dump_req(outputStream *st) const {\n-  \/\/ Dump the required inputs, enclosed in '(' and ')'\n+void RethrowNode::dump_req(outputStream *st, DumpConfig* dc) const {\n+  \/\/ Dump the required inputs, after printing \"exception\"\n@@ -242,3 +247,8 @@\n-    if (i == TypeFunc::Parms) st->print(\"exception\");\n-    if (in(i)) st->print(\"%c%d \", Compile::current()->node_arena()->contains(in(i)) ? ' ' : 'o', in(i)->_idx);\n-    else st->print(\"_ \");\n+    if (i == TypeFunc::Parms) st->print(\"exception \");\n+    Node* p = in(i);\n+    if (p != nullptr) {\n+      p->dump_idx(false, st, dc);\n+      st->print(\" \");\n+    } else {\n+      st->print(\"_ \");\n+    }\n@@ -692,1 +702,1 @@\n-void CallNode::dump_req(outputStream *st) const {\n+void CallNode::dump_req(outputStream *st, DumpConfig* dc) const {\n@@ -697,2 +707,7 @@\n-    if (in(i)) st->print(\"%c%d \", Compile::current()->node_arena()->contains(in(i)) ? ' ' : 'o', in(i)->_idx);\n-    else st->print(\"_ \");\n+    Node* p = in(i);\n+    if (p != nullptr) {\n+      p->dump_idx(false, st, dc);\n+      st->print(\" \");\n+    } else {\n+      st->print(\"_ \");\n+    }\n@@ -1447,0 +1462,6 @@\n+Node* SafePointNode::peek_operand(uint off) const {\n+  assert(jvms()->sp() > 0, \"must have an operand\");\n+  assert(off < jvms()->sp(), \"off is out-of-range\");\n+  return stack(jvms(), jvms()->sp() - off - 1);\n+}\n+\n@@ -1651,1 +1672,3 @@\n-      if (!allow_new_nodes) return NULL;\n+      if (!allow_new_nodes) {\n+        return NULL;\n+      }\n@@ -1655,3 +1678,4 @@\n-      assert(init != NULL, \"initialization not found\");\n-      length = new CastIINode(length, narrow_length_type);\n-      length->set_req(TypeFunc::Control, init->proj_out_or_null(TypeFunc::Control));\n+      if (init != NULL) {\n+        length = new CastIINode(length, narrow_length_type);\n+        length->set_req(TypeFunc::Control, init->proj_out_or_null(TypeFunc::Control));\n+      }\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":41,"deletions":17,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -130,1 +130,1 @@\n-  virtual void dump_req(outputStream *st = tty) const;\n+  virtual void dump_req(outputStream *st = tty, DumpConfig* dc = nullptr) const;\n@@ -151,1 +151,1 @@\n-  virtual void dump_req(outputStream *st = tty) const;\n+  virtual void dump_req(outputStream *st = tty, DumpConfig* dc = nullptr) const;\n@@ -419,0 +419,2 @@\n+  \/\/ Peek Operand Stacks, JVMS 2.6.2\n+  Node* peek_operand(uint off = 0) const;\n@@ -658,1 +660,1 @@\n-  virtual void        dump_req(outputStream* st = tty) const;\n+  virtual void        dump_req(outputStream* st = tty, DumpConfig* dc = nullptr) const;\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -399,0 +399,4 @@\n+\n+    if (dead->is_CallStaticJava()) {\n+      remove_unstable_if_trap(dead->as_CallStaticJava(), false);\n+    }\n@@ -437,0 +441,1 @@\n+  remove_useless_unstable_if_traps(useful);          \/\/ remove useless unstable_if traps\n@@ -610,0 +615,1 @@\n+                  _unstable_if_traps (comp_arena(), 8, 0, NULL),\n@@ -1857,0 +1863,100 @@\n+void Compile::record_unstable_if_trap(UnstableIfTrap* trap) {\n+  if (OptimizeUnstableIf) {\n+    _unstable_if_traps.append(trap);\n+  }\n+}\n+\n+void Compile::remove_useless_unstable_if_traps(Unique_Node_List& useful) {\n+  for (int i = _unstable_if_traps.length() - 1; i >= 0; i--) {\n+    UnstableIfTrap* trap = _unstable_if_traps.at(i);\n+    Node* n = trap->uncommon_trap();\n+    if (!useful.member(n)) {\n+      _unstable_if_traps.delete_at(i); \/\/ replaces i-th with last element which is known to be useful (already processed)\n+    }\n+  }\n+}\n+\n+\/\/ Remove the unstable if trap associated with 'unc' from candidates. It is either dead\n+\/\/ or fold-compares case. Return true if succeed or not found.\n+\/\/\n+\/\/ In rare cases, the found trap has been processed. It is too late to delete it. Return\n+\/\/ false and ask fold-compares to yield.\n+\/\/\n+\/\/ 'fold-compares' may use the uncommon_trap of the dominating IfNode to cover the fused\n+\/\/ IfNode. This breaks the unstable_if trap invariant: control takes the unstable path\n+\/\/ when deoptimization does happen.\n+bool Compile::remove_unstable_if_trap(CallStaticJavaNode* unc, bool yield) {\n+  for (int i = 0; i < _unstable_if_traps.length(); ++i) {\n+    UnstableIfTrap* trap = _unstable_if_traps.at(i);\n+    if (trap->uncommon_trap() == unc) {\n+      if (yield && trap->modified()) {\n+        return false;\n+      }\n+      _unstable_if_traps.delete_at(i);\n+      break;\n+    }\n+  }\n+  return true;\n+}\n+\n+\/\/ Re-calculate unstable_if traps with the liveness of next_bci, which points to the unlikely path.\n+\/\/ It needs to be done after igvn because fold-compares may fuse uncommon_traps and before renumbering.\n+void Compile::process_for_unstable_if_traps(PhaseIterGVN& igvn) {\n+  for (int i = _unstable_if_traps.length() - 1; i >= 0; --i) {\n+    UnstableIfTrap* trap = _unstable_if_traps.at(i);\n+    CallStaticJavaNode* unc = trap->uncommon_trap();\n+    int next_bci = trap->next_bci();\n+    bool modified = trap->modified();\n+\n+    if (next_bci != -1 && !modified) {\n+      assert(!_dead_node_list.test(unc->_idx), \"changing a dead node!\");\n+      JVMState* jvms = unc->jvms();\n+      ciMethod* method = jvms->method();\n+      ciBytecodeStream iter(method);\n+\n+      iter.force_bci(jvms->bci());\n+      assert(next_bci == iter.next_bci() || next_bci == iter.get_dest(), \"wrong next_bci at unstable_if\");\n+      Bytecodes::Code c = iter.cur_bc();\n+      Node* lhs = nullptr;\n+      Node* rhs = nullptr;\n+      if (c == Bytecodes::_if_acmpeq || c == Bytecodes::_if_acmpne) {\n+        lhs = unc->peek_operand(0);\n+        rhs = unc->peek_operand(1);\n+      } else if (c == Bytecodes::_ifnull || c == Bytecodes::_ifnonnull) {\n+        lhs = unc->peek_operand(0);\n+      }\n+\n+      ResourceMark rm;\n+      const MethodLivenessResult& live_locals = method->liveness_at_bci(next_bci);\n+      assert(live_locals.is_valid(), \"broken liveness info\");\n+      int len = (int)live_locals.size();\n+\n+      for (int i = 0; i < len; i++) {\n+        Node* local = unc->local(jvms, i);\n+        \/\/ kill local using the liveness of next_bci.\n+        \/\/ give up when the local looks like an operand to secure reexecution.\n+        if (!live_locals.at(i) && !local->is_top() && local != lhs && local!= rhs) {\n+          uint idx = jvms->locoff() + i;\n+#ifdef ASSERT\n+          if (Verbose) {\n+            tty->print(\"[unstable_if] kill local#%d: \", idx);\n+            local->dump();\n+            tty->cr();\n+          }\n+#endif\n+          igvn.replace_input_of(unc, idx, top());\n+          modified = true;\n+        }\n+      }\n+    }\n+\n+    \/\/ keep the mondified trap for late query\n+    if (modified) {\n+      trap->set_modified();\n+    } else {\n+      _unstable_if_traps.delete_at(i);\n+    }\n+  }\n+  igvn.optimize();\n+}\n+\n@@ -2141,0 +2247,2 @@\n+  process_for_unstable_if_traps(igvn);\n+\n@@ -3132,1 +3240,0 @@\n-  case Op_StorePConditional:\n@@ -3135,2 +3242,0 @@\n-  case Op_StoreIConditional:\n-  case Op_StoreLConditional:\n@@ -3176,1 +3281,0 @@\n-  case Op_LoadPLocked:\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":108,"deletions":4,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -2021,1 +2021,1 @@\n-void GraphKit::uncommon_trap(int trap_request,\n+Node* GraphKit::uncommon_trap(int trap_request,\n@@ -2026,1 +2026,1 @@\n-  if (stopped())  return; \/\/ trap reachable?\n+  if (stopped())  return NULL; \/\/ trap reachable?\n@@ -2142,0 +2142,1 @@\n+  return call;\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1120,17 +1120,0 @@\n-\/\/---------------------------set_eden_pointers-------------------------\n-void PhaseMacroExpand::set_eden_pointers(Node* &eden_top_adr, Node* &eden_end_adr) {\n-  if (UseTLAB) {                \/\/ Private allocation: load from TLS\n-    Node* thread = transform_later(new ThreadLocalNode());\n-    int tlab_top_offset = in_bytes(JavaThread::tlab_top_offset());\n-    int tlab_end_offset = in_bytes(JavaThread::tlab_end_offset());\n-    eden_top_adr = basic_plus_adr(top()\/*not oop*\/, thread, tlab_top_offset);\n-    eden_end_adr = basic_plus_adr(top()\/*not oop*\/, thread, tlab_end_offset);\n-  } else {                      \/\/ Shared allocation: load from globals\n-    CollectedHeap* ch = Universe::heap();\n-    address top_adr = (address)ch->top_addr();\n-    address end_adr = (address)ch->end_addr();\n-    eden_top_adr = makecon(TypeRawPtr::make(top_adr));\n-    eden_end_adr = basic_plus_adr(eden_top_adr, end_adr - top_adr);\n-  }\n-}\n-\n@@ -1246,1 +1229,1 @@\n-  if (!UseTLAB && !Universe::heap()->supports_inline_contig_alloc()) {\n+  if (!UseTLAB) {\n@@ -2209,12 +2192,1 @@\n-  Node* thread = transform_later(new ThreadLocalNode());\n-  if (Continuations::enabled()) {\n-    \/\/ held_monitor_count increased in slowpath (complete_monitor_locking_C_inc_held_monitor_count), need compensate a decreament here\n-    \/\/ this minimizes control flow changes here and add redundant count updates only in slowpath\n-    Node* dec_count = make_load(slow_ctrl, memproj, thread, in_bytes(JavaThread::held_monitor_count_offset()), TypeInt::INT, TypeInt::INT->basic_type());\n-    Node* new_dec_count = transform_later(new SubINode(dec_count, intcon(1)));\n-    Node *compensate_dec = make_store(slow_ctrl, memproj, thread, in_bytes(JavaThread::held_monitor_count_offset()), new_dec_count, T_INT);\n-    mem_phi->init_req(1, compensate_dec);\n-  } else {\n-    mem_phi->init_req(1, memproj);\n-  }\n-  transform_later(mem_phi);\n+  mem_phi->init_req(1, memproj);\n@@ -2222,5 +2194,1 @@\n-  if (Continuations::enabled()) {\n-    \/\/ held_monitor_count increases in all path's post-dominate\n-    Node* inc_count = make_load(region, mem_phi, thread, in_bytes(JavaThread::held_monitor_count_offset()), TypeInt::INT, TypeInt::INT->basic_type());\n-    Node* new_inc_count = transform_later(new AddINode(inc_count, intcon(1)));\n-    Node *store = make_store(region, mem_phi, thread, in_bytes(JavaThread::held_monitor_count_offset()), new_inc_count, T_INT);\n+  transform_later(mem_phi);\n@@ -2228,4 +2196,1 @@\n-    _igvn.replace_node(_callprojs.fallthrough_memproj, store);\n-  } else {\n-    _igvn.replace_node(_callprojs.fallthrough_memproj, mem_phi);\n-  }\n+  _igvn.replace_node(_callprojs.fallthrough_memproj, mem_phi);\n@@ -2286,9 +2251,1 @@\n-  if (Continuations::enabled()) {\n-    Node* count = make_load(region, mem_phi, thread, in_bytes(JavaThread::held_monitor_count_offset()), TypeInt::INT, TypeInt::INT->basic_type());\n-    Node* newcount = transform_later(new SubINode(count, intcon(1)));\n-    Node *store = make_store(region, mem_phi, thread, in_bytes(JavaThread::held_monitor_count_offset()), newcount, T_INT);\n-\n-    _igvn.replace_node(_callprojs.fallthrough_memproj, store);\n-  } else {\n-    _igvn.replace_node(_callprojs.fallthrough_memproj, mem_phi);\n-  }\n+  _igvn.replace_node(_callprojs.fallthrough_memproj, mem_phi);\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":5,"deletions":48,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -61,1 +61,0 @@\n-  void set_eden_pointers(Node* &eden_top_adr, Node* &eden_end_adr);\n","filename":"src\/hotspot\/share\/opto\/macro.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}