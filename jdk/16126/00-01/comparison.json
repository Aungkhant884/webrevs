{"files":[{"patch":"@@ -46,1 +46,1 @@\n- * features the <em>global scope<\/em>. As such, native segments allocated with the global arena are always\n+ * features an <em>unbounded lifetime<\/em>. As such, native segments allocated with the global arena are always\n@@ -56,1 +56,1 @@\n- * which features an <em>automatic scope<\/em>. As such, the regions\n+ * which features a <em>bounded lifetime<\/em> that is managed, automatically, by the garbage collector. As such, the regions\n@@ -70,1 +70,1 @@\n- * an <em>explicit scope<\/em> whose lifetime is managed manually. For instance, the lifetime of a confined arena starts when the confined\n+ * bounded lifetimes that are managed manually. For instance, the lifetime of a confined arena starts when the confined\n@@ -222,1 +222,1 @@\n-            static final Arena GLOBAL = MemorySessionImpl.GLOBAL_SESSION.asArena();\n+            static final Arena GLOBAL = MemorySessionImpl.createGlobal().asArena();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Arena.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -368,1 +368,1 @@\n- * returned segment is the global scope. To provide safe access to the segment, we must,\n+ * returned segment is a scope that is always alive. To provide safe access to the segment, we must,\n@@ -566,1 +566,1 @@\n-     * the global scope. Under normal conditions, the size of the returned segment is {@code 0}.\n+     * a fresh scope that is always alive. Under normal conditions, the size of the returned segment is {@code 0}.\n@@ -605,1 +605,1 @@\n-     * is a native segment associated with the global scope.\n+     * is a native segment associated with a scope that is always alive.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Linker.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.lang.foreign.ValueLayout.OfInt;\n@@ -387,1 +386,1 @@\n- *     <li>The segment is associated with the global scope. Thus, while zero-length\n+ *     <li>The segment is associated with a scope that is always alive. Thus, while zero-length\n@@ -639,1 +638,1 @@\n-     * That is, the cleanup action receives a segment that is associated with the global scope,\n+     * That is, the cleanup action receives a segment that is associated with a scope that is always alive,\n@@ -678,1 +677,1 @@\n-     * That is, the cleanup action receives a segment that is associated with the global scope,\n+     * That is, the cleanup action receives a segment that is associated with a scope that is always alive,\n@@ -1187,3 +1186,5 @@\n-     * same scope {@code S}. Otherwise, the scope of the returned segment is an automatic scope that keeps the provided\n-     * buffer reachable. As such, if the provided buffer is a direct buffer, its backing memory region will not be\n-     * deallocated as long as the returned segment (or any of its slices) are kept reachable.\n+     * same scope {@code S}. Otherwise, the scope of the returned segment is a fresh scope that is always alive.\n+     * <p>\n+     * The scope associated with the returned segment keeps the provided buffer reachable. As such, if\n+     * the provided buffer is a direct buffer, its backing memory region will not be deallocated as long as the\n+     * returned segment (or any of its slices) are kept reachable.\n@@ -1204,1 +1205,1 @@\n-     * The scope of the returned segment is an automatic scope that keeps the given array reachable.\n+     * The scope of the returned segment is a fresh scope that is always alive, and keeps the given array reachable.\n@@ -1216,1 +1217,1 @@\n-     * The scope of the returned segment is an automatic scope that keeps the given array reachable.\n+     * The scope of the returned segment is a fresh scope that is always alive, and keeps the given array reachable.\n@@ -1228,1 +1229,1 @@\n-     * The scope of the returned segment is an automatic scope that keeps the given array reachable.\n+     * The scope of the returned segment is a fresh scope that is always alive, and keeps the given array reachable.\n@@ -1240,1 +1241,1 @@\n-     * The scope of the returned segment is an automatic scope that keeps the given array reachable.\n+     * The scope of the returned segment is a fresh scope that is always alive, and keeps the given array reachable.\n@@ -1252,1 +1253,1 @@\n-     * The scope of the returned segment is an automatic scope that keeps the given array reachable.\n+     * The scope of the returned segment is a fresh scope that is always alive, and keeps the given array reachable.\n@@ -1264,1 +1265,1 @@\n-     * The scope of the returned segment is an automatic scope that keeps the given array reachable.\n+     * The scope of the returned segment is a fresh scope that is always alive, and keeps the given array reachable.\n@@ -1276,1 +1277,1 @@\n-     * The scope of the returned segment is an automatic scope that keeps the given array reachable.\n+     * The scope of the returned segment is a fresh scope that is always alive, and keeps the given array reachable.\n@@ -1287,1 +1288,1 @@\n-     * A zero-length native segment modelling the {@code NULL} address. Equivalent to {@code MemorySegment.ofAddress(0L)}.\n+     * A zero-length native segment modelling the {@code NULL} address.\n@@ -1293,1 +1294,1 @@\n-     * The returned segment is associated with the global scope, and is accessible from any thread.\n+     * The returned segment is associated with a scope that is always alive, and is accessible from any thread.\n@@ -1720,1 +1721,1 @@\n-     * a native segment, associated with the global scope. Under normal conditions,\n+     * a native segment, associated with a scope that is always alive. Under normal conditions,\n@@ -2159,1 +2160,1 @@\n-     * a native segment, associated with the global scope. Under normal conditions,\n+     * a native segment, associated with a scope that is always alive. Under normal conditions,\n@@ -2367,2 +2368,2 @@\n-     * cannot be accessed if its associated scope is not {@linkplain #isAlive() alive}. Scope instances can be compared\n-     * for equality. That is, two scopes are considered {@linkplain #equals(Object)} if they denote the same lifetime.\n+     * cannot be accessed if its associated scope is not {@linkplain #isAlive() alive}. A new scope is typically\n+     * obtained indirectly, by creating a new {@linkplain Arena arena}.\n@@ -2370,7 +2371,2 @@\n-     * The simplest scope is the <em>global scope<\/em>. The global scope models an <em>unbounded lifetime<\/em>.\n-     * As such, the global scope is always {@link #isAlive() alive}. Segments associated with the global scope are:\n-     * <ul>\n-     *     <li>Segments obtained from the {@linkplain Arena#global() global arena};<\/li>\n-     *     <li>Segments obtained from a raw address, using the {@link MemorySegment#ofAddress(long)} factory; and<\/li>\n-     *     <li><a href=\"#wrapping-addresses\">Zero-length memory segments.<\/a><\/li>\n-     * <\/ul>\n+     * Scope instances can be compared for equality. That is, two scopes\n+     * are considered {@linkplain #equals(Object)} if they denote the same lifetime.\n@@ -2378,9 +2374,0 @@\n-     * Alternatively, an <em>automatic scope<\/em> models a <em>bounded lifetime<\/em> that is managed, automatically,\n-     * by the garbage collector. As such, an automatic scope is always {@link #isAlive() alive} as long as it is\n-     * <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">reachable<\/a>. Segments associated with an automatic scope are:\n-     * <ul>\n-     *     <li>Segments obtained from an {@linkplain Arena#ofAuto() automatic arena};<\/li>\n-     *     <li>Segments obtained from a Java array, e.g. using the {@link MemorySegment#ofArray(int[])} factory;<\/li>\n-     *     <li>Segments obtained from a buffer, using the {@link MemorySegment#ofBuffer(Buffer)} factory; and<\/li>\n-     *     <li>Segments obtained from {@linkplain SymbolLookup#loaderLookup() loader lookup}.<\/li>\n-     * <\/ul>\n@@ -2388,1 +2375,1 @@\n-     * or {@linkplain #ofArray(int[]) array}, the automatic scopes associated with said segments are considered\n+     * or {@linkplain #ofArray(int[]) array}, the scopes associated with said segments are considered\n@@ -2397,8 +2384,9 @@\n-     * Finally, an <em>explicit scope<\/em> models a <em>bounded lifetime<\/em> that is managed manually.\n-     * That is, bounded scopes are created using either a {@linkplain Arena#ofConfined() confined} or a\n-     * {@linkplain Arena#ofShared() shared} arena. When the arena is {@linkplain Arena#close() closed},\n-     * the bounded scope associated with the arena becomes not {@link #isAlive() alive}.\n-     * Segments associated with a bounded scope are:\n-     * <ul>\n-     *     <li>Segments obtained from a {@linkplain Arena#ofConfined() confined} or a {@linkplain Arena#ofShared() shared} arena;<\/li>\n-     * <\/ul>\n+     * If two distinct memory segments are <a href=\"#wrapping-addresses\">zero-length memory segments<\/a>, their scopes\n+     * are always considered {@linkplain #equals(Object) equal}:\n+     * {@snippet lang=java :\n+     * MemorySegment segment1 = MemorySegment.ofAddress(42L);\n+     * MemorySegment segment2 = MemorySegment.ofAddress(1000L);\n+     * assert segment1.scope().equals(segment2.scope());\n+     * }\n+     * The scope of a zero-length memory segment can always be overridden using the\n+     * {@link MemorySegment#reinterpret(Arena, Consumer)} method.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":33,"deletions":45,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -168,1 +168,1 @@\n-     * returned by this method is associated with an automatic {@linkplain MemorySegment.Scope scope} which keeps the caller's\n+     * returned by this method is associated with a {@linkplain MemorySegment.Scope scope} which keeps the caller's\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SymbolLookup.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-    public static final MemorySessionImpl GLOBAL_SESSION = new GlobalSession();\n+    static final GlobalSession NATIVE_SESSION = new GlobalSession();\n@@ -148,0 +148,4 @@\n+    public static MemorySessionImpl createGlobal() {\n+        return new GlobalSession();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MemorySessionImpl.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-        super(0L, false, MemorySessionImpl.GLOBAL_SESSION);\n+        super(0L, false, MemorySessionImpl.NATIVE_SESSION);\n@@ -178,1 +178,1 @@\n-        return new NativeMemorySegmentImpl(min, byteSize, false, MemorySessionImpl.GLOBAL_SESSION);\n+        return new NativeMemorySegmentImpl(min, byteSize, false, MemorySessionImpl.NATIVE_SESSION);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/NativeMemorySegmentImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n-        assertEquals(segment1.scope(), Arena.global().scope());\n+        assertNotEquals(segment1.scope(), Arena.global().scope());\n","filename":"test\/jdk\/java\/foreign\/TestScope.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}