{"files":[{"patch":"@@ -222,1 +222,1 @@\n-            static final Arena GLOBAL = MemorySessionImpl.GLOBAL.asArena();\n+            static final Arena GLOBAL = MemorySessionImpl.createGlobal().asArena();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Arena.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -368,1 +368,1 @@\n- * returned segment is a fresh scope that is always alive. To provide safe access to the segment, we must,\n+ * returned segment is a scope that is always alive. To provide safe access to the segment, we must,\n@@ -605,1 +605,1 @@\n-     * is a native segment associated with a fresh scope that is always alive.\n+     * is a native segment associated with a scope that is always alive.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Linker.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -463,1 +463,1 @@\n-     * on the returned var handle will return a new memory segment. The segment is associated with a fresh scope that is\n+     * on the returned var handle will return a new memory segment. The segment is associated with a scope that is\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryLayout.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -386,1 +386,1 @@\n- *     <li>The segment is associated with a fresh scope that is always alive. Thus, while zero-length\n+ *     <li>The segment is associated with a scope that is always alive. Thus, while zero-length\n@@ -638,1 +638,1 @@\n-     * That is, the cleanup action receives a segment that is associated with a fresh scope that is always alive,\n+     * That is, the cleanup action receives a segment that is associated with a scope that is always alive,\n@@ -677,1 +677,1 @@\n-     * That is, the cleanup action receives a segment that is associated with a fresh scope that is always alive,\n+     * That is, the cleanup action receives a segment that is associated with a scope that is always alive,\n@@ -1721,1 +1721,1 @@\n-     * a native segment, associated with a fresh scope that is always alive. Under normal conditions,\n+     * a native segment, associated with a scope that is always alive. Under normal conditions,\n@@ -2160,1 +2160,1 @@\n-     * a native segment, associated with a fresh scope that is always alive. Under normal conditions,\n+     * a native segment, associated with a scope that is always alive. Under normal conditions,\n@@ -2373,0 +2373,20 @@\n+     * <p>\n+     * If two memory segments are obtained from the same {@linkplain #ofBuffer(Buffer) buffer}\n+     * or {@linkplain #ofArray(int[]) array}, the scopes associated with said segments are considered\n+     * {@linkplain #equals(Object) equal}, as the two segments have the same lifetime:\n+     * {@snippet lang=java :\n+     * byte[] arr = new byte[10];\n+     * MemorySegment segment1 = MemorySegment.ofArray(arr);\n+     * MemorySegment segment2 = MemorySegment.ofArray(arr);\n+     * assert segment1.scope().equals(segment2.scope());\n+     * }\n+     * <p>\n+     * If two distinct memory segments are <a href=\"#wrapping-addresses\">zero-length memory segments<\/a>, their scopes\n+     * are always considered {@linkplain #equals(Object) equal}:\n+     * {@snippet lang=java :\n+     * MemorySegment segment1 = MemorySegment.ofAddress(42L);\n+     * MemorySegment segment2 = MemorySegment.ofAddress(1000L);\n+     * assert segment1.scope().equals(segment2.scope());\n+     * }\n+     * The scope of a zero-length memory segment can always be overridden using the\n+     * {@link MemorySegment#reinterpret(Arena, Consumer)} method.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":25,"deletions":5,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -168,1 +168,1 @@\n-     * returned by this method is associated with a fresh {@linkplain MemorySegment.Scope scope} which keeps the caller's\n+     * returned by this method is associated with a {@linkplain MemorySegment.Scope scope} which keeps the caller's\n@@ -192,1 +192,1 @@\n-            MemorySessionImpl session = MemorySessionImpl.heapSession(loader);\n+            MemorySessionImpl session = MemorySessionImpl.createHeap(loader);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SymbolLookup.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+import sun.nio.ch.DirectBuffer;\n@@ -540,1 +541,1 @@\n-            bufferScope = MemorySessionImpl.heapSession(bb);\n+            bufferScope = MemorySessionImpl.createHeap(bufferRef(bb));\n@@ -568,0 +569,11 @@\n+    private static Object bufferRef(Buffer buffer) {\n+        if (buffer instanceof DirectBuffer directBuffer) {\n+            \/\/ direct buffer, return either the buffer attachment (for slices and views), or the buffer itself\n+            return directBuffer.attachment() != null ?\n+                    directBuffer.attachment() : directBuffer;\n+        } else {\n+            \/\/ heap buffer, return the underlying array\n+            return NIO_ACCESS.getBufferBase(buffer);\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import jdk.internal.access.JavaNioAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -29,0 +31,4 @@\n+import sun.nio.ch.DirectBuffer;\n+\n+import java.nio.Buffer;\n+import java.util.Objects;\n@@ -35,3 +41,1 @@\n-final class GlobalSession extends MemorySessionImpl {\n-\n-    final Object ref;\n+non-sealed class GlobalSession extends MemorySessionImpl {\n@@ -39,1 +43,1 @@\n-    public GlobalSession(Object ref) {\n+    public GlobalSession() {\n@@ -41,1 +45,0 @@\n-        this.ref = ref;\n@@ -70,0 +73,28 @@\n+\n+    \/**\n+     * This is a global session that wraps a heap object. Possible objects are: Java arrays, buffers and\n+     * class loaders. Objects of two heap sessions are compared by identity. That is, if the wrapped object is the same,\n+     * then the resulting heap sessions are also considered equals. We do not compare the objects using\n+     * {@link Object#equals(Object)}, as that would be problematic when comparing buffers, whose equality and\n+     * hash codes are content-dependent.\n+     *\/\n+    static class HeapSession extends GlobalSession {\n+\n+        final Object ref;\n+\n+        public HeapSession(Object ref) {\n+            super();\n+            this.ref = Objects.requireNonNull(ref);\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            return obj instanceof HeapSession session &&\n+                    ref == session.ref;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return System.identityHashCode(ref);\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/GlobalSession.java","additions":36,"deletions":5,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -117,1 +117,1 @@\n-                    MemorySessionImpl.heapSession(arr));\n+                    MemorySessionImpl.createHeap(arr));\n@@ -151,1 +151,1 @@\n-                    MemorySessionImpl.heapSession(arr));\n+                    MemorySessionImpl.createHeap(arr));\n@@ -185,1 +185,1 @@\n-                    MemorySessionImpl.heapSession(arr));\n+                    MemorySessionImpl.createHeap(arr));\n@@ -219,1 +219,1 @@\n-                    MemorySessionImpl.heapSession(arr));\n+                    MemorySessionImpl.createHeap(arr));\n@@ -253,1 +253,1 @@\n-                    MemorySessionImpl.heapSession(arr));\n+                    MemorySessionImpl.createHeap(arr));\n@@ -287,1 +287,1 @@\n-                    MemorySessionImpl.heapSession(arr));\n+                    MemorySessionImpl.createHeap(arr));\n@@ -321,1 +321,1 @@\n-                    MemorySessionImpl.heapSession(arr));\n+                    MemorySessionImpl.createHeap(arr));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/HeapMemorySegmentImpl.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -51,2 +51,1 @@\n-        return NIO_ACCESS.newMappedByteBuffer(unmapper, min, (int)length, null,\n-                scope == MemorySessionImpl.GLOBAL ? null : this);\n+        return NIO_ACCESS.newMappedByteBuffer(unmapper, min, (int)length, null, this);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MappedMemorySegmentImpl.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+\n+import jdk.internal.foreign.GlobalSession.HeapSession;\n@@ -62,2 +64,0 @@\n-    public static final MemorySessionImpl GLOBAL = new GlobalSession(null);\n-\n@@ -66,0 +66,2 @@\n+    \/\/ This is the session of all zero-length memory segments\n+    static final GlobalSession NATIVE_SESSION = new GlobalSession();\n@@ -146,0 +148,8 @@\n+    public static MemorySessionImpl createGlobal() {\n+        return new GlobalSession();\n+    }\n+\n+    public static MemorySessionImpl createHeap(Object ref) {\n+        return new HeapSession(ref);\n+    }\n+\n@@ -233,4 +243,0 @@\n-    public static MemorySessionImpl heapSession(Object ref) {\n-        return new GlobalSession(ref);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/MemorySessionImpl.java","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-        super(0L, false, new GlobalSession(null));\n+        super(0L, false, MemorySessionImpl.NATIVE_SESSION);\n@@ -90,2 +90,1 @@\n-        return NIO_ACCESS.newDirectByteBuffer(min, (int) this.length, null,\n-                scope == MemorySessionImpl.GLOBAL ? null : this);\n+        return NIO_ACCESS.newDirectByteBuffer(min, (int) this.length, null, this);\n@@ -179,1 +178,1 @@\n-        return new NativeMemorySegmentImpl(min, byteSize, false, new GlobalSession(null));\n+        return new NativeMemorySegmentImpl(min, byteSize, false, MemorySessionImpl.NATIVE_SESSION);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/NativeMemorySegmentImpl.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,122 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestScope\n+ *\/\n+\n+import org.testng.annotations.*;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.SymbolLookup;\n+import java.nio.ByteBuffer;\n+import java.nio.IntBuffer;\n+\n+import static org.testng.Assert.*;\n+\n+public class TestScope {\n+\n+    static {\n+        System.loadLibrary(\"LookupTest\");\n+    }\n+\n+    @Test\n+    public void testDifferentArrayScope() {\n+        MemorySegment.Scope scope1 = MemorySegment.ofArray(new byte[10]).scope();\n+        MemorySegment.Scope scope2 = MemorySegment.ofArray(new byte[10]).scope();\n+        assertNotEquals(scope1, scope2);\n+    }\n+\n+    @Test\n+    public void testDifferentBufferScope() {\n+        MemorySegment.Scope scope1 = MemorySegment.ofBuffer(ByteBuffer.allocateDirect(10)).scope();\n+        MemorySegment.Scope scope2 = MemorySegment.ofBuffer(ByteBuffer.allocateDirect(10)).scope();\n+        assertNotEquals(scope1, scope2);\n+    }\n+\n+    @Test\n+    public void testDifferentArenaScope() {\n+        MemorySegment.Scope scope1 = Arena.ofAuto().allocate(10).scope();\n+        MemorySegment.Scope scope2 = Arena.ofAuto().allocate(10).scope();\n+        assertNotEquals(scope1, scope2);\n+    }\n+\n+    @Test\n+    public void testSameArrayScope() {\n+        byte[] arr = new byte[10];\n+        assertEquals(MemorySegment.ofArray(arr).scope(), MemorySegment.ofArray(arr).scope());\n+        ByteBuffer buf = ByteBuffer.wrap(arr);\n+        assertEquals(MemorySegment.ofArray(arr).scope(), MemorySegment.ofBuffer(buf).scope());\n+        testDerivedBufferScope(MemorySegment.ofArray(arr));\n+    }\n+\n+    @Test\n+    public void testSameBufferScope() {\n+        ByteBuffer buf = ByteBuffer.allocateDirect(10);\n+        assertEquals(MemorySegment.ofBuffer(buf).scope(), MemorySegment.ofBuffer(buf).scope());\n+        testDerivedBufferScope(MemorySegment.ofBuffer(buf));\n+    }\n+\n+    @Test\n+    public void testSameArenaScope() {\n+        try (Arena arena = Arena.ofConfined()) {\n+            MemorySegment segment1 = arena.allocate(10);\n+            MemorySegment segment2 = arena.allocate(10);\n+            assertEquals(segment1.scope(), segment2.scope());\n+            testDerivedBufferScope(segment1);\n+        }\n+    }\n+\n+    @Test\n+    public void testSameNativeScope() {\n+        MemorySegment segment1 = MemorySegment.ofAddress(42);\n+        MemorySegment segment2 = MemorySegment.ofAddress(43);\n+        assertEquals(segment1.scope(), segment2.scope());\n+        assertEquals(segment1.scope(), segment2.reinterpret(10).scope());\n+        assertNotEquals(segment1.scope(), Arena.global().scope());\n+        testDerivedBufferScope(segment1.reinterpret(10));\n+    }\n+\n+    @Test\n+    public void testSameLookupScope() {\n+        SymbolLookup loaderLookup = SymbolLookup.loaderLookup();\n+        MemorySegment segment1 = loaderLookup.find(\"f\").get();\n+        MemorySegment segment2 = loaderLookup.find(\"c\").get();\n+        assertEquals(segment1.scope(), segment2.scope());\n+        testDerivedBufferScope(segment1.reinterpret(10));\n+    }\n+\n+    void testDerivedBufferScope(MemorySegment segment) {\n+        ByteBuffer buffer = segment.asByteBuffer();\n+        MemorySegment.Scope expectedScope = segment.scope();\n+        assertEquals(MemorySegment.ofBuffer(buffer).scope(), expectedScope);\n+        \/\/ buffer slices should have same scope\n+        ByteBuffer slice = buffer.slice(0, 2);\n+        assertEquals(expectedScope, MemorySegment.ofBuffer(slice).scope());\n+        \/\/ buffer views should have same scope\n+        IntBuffer view = buffer.asIntBuffer();\n+        assertEquals(expectedScope, MemorySegment.ofBuffer(view).scope());\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/foreign\/TestScope.java","additions":122,"deletions":0,"binary":false,"changes":122,"status":"added"}]}