{"files":[{"patch":"@@ -991,4 +991,65 @@\n-\/\/ defined in stubGenerator_aarch64.cpp\n-OopMap* continuation_enter_setup(MacroAssembler* masm, int& stack_slots);\n-void fill_continuation_entry(MacroAssembler* masm);\n-void continuation_enter_cleanup(MacroAssembler* masm);\n+\/\/ on exit, sp points to the ContinuationEntry\n+static OopMap* continuation_enter_setup(MacroAssembler* masm, int& stack_slots) {\n+  assert(ContinuationEntry::size() % VMRegImpl::stack_slot_size == 0, \"\");\n+  assert(in_bytes(ContinuationEntry::cont_offset())  % VMRegImpl::stack_slot_size == 0, \"\");\n+  assert(in_bytes(ContinuationEntry::chunk_offset()) % VMRegImpl::stack_slot_size == 0, \"\");\n+\n+  stack_slots += (int)ContinuationEntry::size()\/wordSize;\n+  __ sub(sp, sp, (int)ContinuationEntry::size()); \/\/ place Continuation metadata\n+\n+  OopMap* map = new OopMap(((int)ContinuationEntry::size() + wordSize)\/ VMRegImpl::stack_slot_size, 0 \/* arg_slots*\/);\n+  ContinuationEntry::setup_oopmap(map);\n+\n+  __ ldr(rscratch1, Address(rthread, JavaThread::cont_entry_offset()));\n+  __ str(rscratch1, Address(sp, ContinuationEntry::parent_offset()));\n+  __ mov(rscratch1, sp); \/\/ we can't use sp as the source in str\n+  __ str(rscratch1, Address(rthread, JavaThread::cont_entry_offset()));\n+\n+  return map;\n+}\n+\n+\/\/ on entry c_rarg1 points to the continuation\n+\/\/          sp points to ContinuationEntry\n+\/\/          c_rarg3 -- isVirtualThread\n+static void fill_continuation_entry(MacroAssembler* masm) {\n+#ifdef ASSERT\n+  __ movw(rscratch1, ContinuationEntry::cookie_value());\n+  __ strw(rscratch1, Address(sp, ContinuationEntry::cookie_offset()));\n+#endif\n+\n+  __ str (c_rarg1, Address(sp, ContinuationEntry::cont_offset()));\n+  __ strw(c_rarg3, Address(sp, ContinuationEntry::flags_offset()));\n+  __ str (zr,      Address(sp, ContinuationEntry::chunk_offset()));\n+  __ strw(zr,      Address(sp, ContinuationEntry::argsize_offset()));\n+  __ strw(zr,      Address(sp, ContinuationEntry::pin_count_offset()));\n+\n+  __ ldr(rscratch1, Address(rthread, JavaThread::cont_fastpath_offset()));\n+  __ str(rscratch1, Address(sp, ContinuationEntry::parent_cont_fastpath_offset()));\n+  __ ldr(rscratch1, Address(rthread, JavaThread::held_monitor_count_offset()));\n+  __ str(rscratch1, Address(sp, ContinuationEntry::parent_held_monitor_count_offset()));\n+\n+  __ str(zr, Address(rthread, JavaThread::cont_fastpath_offset()));\n+  __ str(zr, Address(rthread, JavaThread::held_monitor_count_offset()));\n+}\n+\n+\/\/ on entry, sp points to the ContinuationEntry\n+\/\/ on exit, rfp points to the spilled rfp in the entry frame\n+static void continuation_enter_cleanup(MacroAssembler* masm) {\n+#ifndef PRODUCT\n+  Label OK;\n+  __ ldr(rscratch1, Address(rthread, JavaThread::cont_entry_offset()));\n+  __ cmp(sp, rscratch1);\n+  __ br(Assembler::EQ, OK);\n+  __ stop(\"incorrect sp1\");\n+  __ bind(OK);\n+#endif\n+\n+  __ ldr(rscratch1, Address(sp, ContinuationEntry::parent_cont_fastpath_offset()));\n+  __ str(rscratch1, Address(rthread, JavaThread::cont_fastpath_offset()));\n+  __ ldr(rscratch1, Address(sp, ContinuationEntry::parent_held_monitor_count_offset()));\n+  __ str(rscratch1, Address(rthread, JavaThread::held_monitor_count_offset()));\n+\n+  __ ldr(rscratch2, Address(sp, ContinuationEntry::parent_offset()));\n+  __ str(rscratch2, Address(rthread, JavaThread::cont_entry_offset()));\n+  __ add(rfp, sp, (int)ContinuationEntry::size());\n+}\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":65,"deletions":4,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -79,4 +79,0 @@\n-OopMap* continuation_enter_setup(MacroAssembler* masm, int& stack_slots);\n-void fill_continuation_entry(MacroAssembler* masm);\n-void continuation_enter_cleanup(MacroAssembler* masm);\n-\n@@ -8019,72 +8015,0 @@\n-\n-\n-#undef __\n-#define __ masm->\n-\n-\/\/ on exit, sp points to the ContinuationEntry\n-OopMap* continuation_enter_setup(MacroAssembler* masm, int& stack_slots) {\n-  assert(ContinuationEntry::size() % VMRegImpl::stack_slot_size == 0, \"\");\n-  assert(in_bytes(ContinuationEntry::cont_offset())  % VMRegImpl::stack_slot_size == 0, \"\");\n-  assert(in_bytes(ContinuationEntry::chunk_offset()) % VMRegImpl::stack_slot_size == 0, \"\");\n-\n-  stack_slots += (int)ContinuationEntry::size()\/wordSize;\n-  __ sub(sp, sp, (int)ContinuationEntry::size()); \/\/ place Continuation metadata\n-\n-  OopMap* map = new OopMap(((int)ContinuationEntry::size() + wordSize)\/ VMRegImpl::stack_slot_size, 0 \/* arg_slots*\/);\n-  ContinuationEntry::setup_oopmap(map);\n-\n-  __ ldr(rscratch1, Address(rthread, JavaThread::cont_entry_offset()));\n-  __ str(rscratch1, Address(sp, ContinuationEntry::parent_offset()));\n-  __ mov(rscratch1, sp); \/\/ we can't use sp as the source in str\n-  __ str(rscratch1, Address(rthread, JavaThread::cont_entry_offset()));\n-\n-  return map;\n-}\n-\n-\/\/ on entry c_rarg1 points to the continuation\n-\/\/          sp points to ContinuationEntry\n-\/\/          c_rarg3 -- isVirtualThread\n-void fill_continuation_entry(MacroAssembler* masm) {\n-#ifdef ASSERT\n-  __ movw(rscratch1, ContinuationEntry::cookie_value());\n-  __ strw(rscratch1, Address(sp, ContinuationEntry::cookie_offset()));\n-#endif\n-\n-  __ str (c_rarg1, Address(sp, ContinuationEntry::cont_offset()));\n-  __ strw(c_rarg3, Address(sp, ContinuationEntry::flags_offset()));\n-  __ str (zr,      Address(sp, ContinuationEntry::chunk_offset()));\n-  __ strw(zr,      Address(sp, ContinuationEntry::argsize_offset()));\n-  __ strw(zr,      Address(sp, ContinuationEntry::pin_count_offset()));\n-\n-  __ ldr(rscratch1, Address(rthread, JavaThread::cont_fastpath_offset()));\n-  __ str(rscratch1, Address(sp, ContinuationEntry::parent_cont_fastpath_offset()));\n-  __ ldr(rscratch1, Address(rthread, JavaThread::held_monitor_count_offset()));\n-  __ str(rscratch1, Address(sp, ContinuationEntry::parent_held_monitor_count_offset()));\n-\n-  __ str(zr, Address(rthread, JavaThread::cont_fastpath_offset()));\n-  __ str(zr, Address(rthread, JavaThread::held_monitor_count_offset()));\n-}\n-\n-\/\/ on entry, sp points to the ContinuationEntry\n-\/\/ on exit, rfp points to the spilled rfp in the entry frame\n-void continuation_enter_cleanup(MacroAssembler* masm) {\n-#ifndef PRODUCT\n-  Label OK;\n-  __ ldr(rscratch1, Address(rthread, JavaThread::cont_entry_offset()));\n-  __ cmp(sp, rscratch1);\n-  __ br(Assembler::EQ, OK);\n-  __ stop(\"incorrect sp1\");\n-  __ bind(OK);\n-#endif\n-\n-  __ ldr(rscratch1, Address(sp, ContinuationEntry::parent_cont_fastpath_offset()));\n-  __ str(rscratch1, Address(rthread, JavaThread::cont_fastpath_offset()));\n-  __ ldr(rscratch1, Address(sp, ContinuationEntry::parent_held_monitor_count_offset()));\n-  __ str(rscratch1, Address(rthread, JavaThread::held_monitor_count_offset()));\n-\n-  __ ldr(rscratch2, Address(sp, ContinuationEntry::parent_offset()));\n-  __ str(rscratch2, Address(rthread, JavaThread::cont_entry_offset()));\n-  __ add(rfp, sp, (int)ContinuationEntry::size());\n-}\n-\n-#undef __\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":0,"deletions":76,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -1979,4 +1979,0 @@\n-\n-  OopMap* continuation_enter_setup(int& stack_slots);\n-  void fill_continuation_entry(Register reg_cont_obj, Register reg_flags);\n-  void continuation_enter_cleanup();\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,122 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"runtime\/continuation.hpp\"\n-#include \"runtime\/continuationEntry.hpp\"\n-#include \"runtime\/javaThread.hpp\"\n-#include \"macroAssembler_x86.hpp\"\n-\n-\/\/---------------------------- continuation_enter_setup ---------------------------\n-\/\/\n-\/\/ Arguments:\n-\/\/   None.\n-\/\/\n-\/\/ Results:\n-\/\/   rsp: pointer to blank ContinuationEntry\n-\/\/\n-\/\/ Kills:\n-\/\/   rax\n-\/\/\n-OopMap* MacroAssembler::continuation_enter_setup(int& stack_slots) {\n-  assert(ContinuationEntry::size() % VMRegImpl::stack_slot_size == 0, \"\");\n-  assert(in_bytes(ContinuationEntry::cont_offset())  % VMRegImpl::stack_slot_size == 0, \"\");\n-  assert(in_bytes(ContinuationEntry::chunk_offset()) % VMRegImpl::stack_slot_size == 0, \"\");\n-\n-  stack_slots += checked_cast<int>(ContinuationEntry::size()) \/ wordSize;\n-  subptr(rsp, checked_cast<int32_t>(ContinuationEntry::size()));\n-\n-  int frame_size = (checked_cast<int>(ContinuationEntry::size()) + wordSize) \/ VMRegImpl::stack_slot_size;\n-  OopMap* map = new OopMap(frame_size, 0);\n-  ContinuationEntry::setup_oopmap(map);\n-\n-  movptr(rax, Address(r15_thread, JavaThread::cont_entry_offset()));\n-  movptr(Address(rsp, ContinuationEntry::parent_offset()), rax);\n-  movptr(Address(r15_thread, JavaThread::cont_entry_offset()), rsp);\n-\n-  return map;\n-}\n-\n-\/\/---------------------------- fill_continuation_entry ---------------------------\n-\/\/\n-\/\/ Arguments:\n-\/\/   rsp: pointer to blank Continuation entry\n-\/\/   reg_cont_obj: pointer to the continuation\n-\/\/   reg_flags: flags\n-\/\/\n-\/\/ Results:\n-\/\/   rsp: pointer to filled out ContinuationEntry\n-\/\/\n-\/\/ Kills:\n-\/\/   rax\n-\/\/\n-void MacroAssembler::fill_continuation_entry(Register reg_cont_obj, Register reg_flags) {\n-  assert_different_registers(rax, reg_cont_obj, reg_flags);\n-#ifdef ASSERT\n-  movl(Address(rsp, ContinuationEntry::cookie_offset()), ContinuationEntry::cookie_value());\n-#endif\n-  movptr(Address(rsp, ContinuationEntry::cont_offset()), reg_cont_obj);\n-  movl  (Address(rsp, ContinuationEntry::flags_offset()), reg_flags);\n-  movptr(Address(rsp, ContinuationEntry::chunk_offset()), 0);\n-  movl(Address(rsp, ContinuationEntry::argsize_offset()), 0);\n-  movl(Address(rsp, ContinuationEntry::pin_count_offset()), 0);\n-\n-  movptr(rax, Address(r15_thread, JavaThread::cont_fastpath_offset()));\n-  movptr(Address(rsp, ContinuationEntry::parent_cont_fastpath_offset()), rax);\n-  movq(rax, Address(r15_thread, JavaThread::held_monitor_count_offset()));\n-  movq(Address(rsp, ContinuationEntry::parent_held_monitor_count_offset()), rax);\n-\n-  movptr(Address(r15_thread, JavaThread::cont_fastpath_offset()), 0);\n-  movq(Address(r15_thread, JavaThread::held_monitor_count_offset()), 0);\n-}\n-\n-\/\/---------------------------- continuation_enter_cleanup ---------------------------\n-\/\/\n-\/\/ Arguments:\n-\/\/   rsp: pointer to the ContinuationEntry\n-\/\/\n-\/\/ Results:\n-\/\/   rsp: pointer to the spilled rbp in the entry frame\n-\/\/\n-\/\/ Kills:\n-\/\/   rbx\n-\/\/\n-void MacroAssembler::continuation_enter_cleanup() {\n-#ifdef ASSERT\n-  Label L_good_sp;\n-  cmpptr(rsp, Address(r15_thread, JavaThread::cont_entry_offset()));\n-  jcc(Assembler::equal, L_good_sp);\n-  stop(\"Incorrect rsp at continuation_enter_cleanup\");\n-  bind(L_good_sp);\n-#endif\n-\n-  movptr(rbx, Address(rsp, ContinuationEntry::parent_cont_fastpath_offset()));\n-  movptr(Address(r15_thread, JavaThread::cont_fastpath_offset()), rbx);\n-  movq(rbx, Address(rsp, ContinuationEntry::parent_held_monitor_count_offset()));\n-  movq(Address(r15_thread, JavaThread::held_monitor_count_offset()), rbx);\n-\n-  movptr(rbx, Address(rsp, ContinuationEntry::parent_offset()));\n-  movptr(Address(r15_thread, JavaThread::cont_entry_offset()), rbx);\n-  addptr(rsp, checked_cast<int32_t>(ContinuationEntry::size()));\n-}\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86_64.cpp","additions":0,"deletions":122,"binary":false,"changes":122,"status":"deleted"},{"patch":"@@ -1274,0 +1274,94 @@\n+\n+\/\/---------------------------- continuation_enter_setup ---------------------------\n+\/\/\n+\/\/ Arguments:\n+\/\/   None.\n+\/\/\n+\/\/ Results:\n+\/\/   rsp: pointer to blank ContinuationEntry\n+\/\/\n+\/\/ Kills:\n+\/\/   rax\n+\/\/\n+static OopMap* continuation_enter_setup(MacroAssembler* masm, int& stack_slots) {\n+  assert(ContinuationEntry::size() % VMRegImpl::stack_slot_size == 0, \"\");\n+  assert(in_bytes(ContinuationEntry::cont_offset())  % VMRegImpl::stack_slot_size == 0, \"\");\n+  assert(in_bytes(ContinuationEntry::chunk_offset()) % VMRegImpl::stack_slot_size == 0, \"\");\n+\n+  stack_slots += checked_cast<int>(ContinuationEntry::size()) \/ wordSize;\n+  __ subptr(rsp, checked_cast<int32_t>(ContinuationEntry::size()));\n+\n+  int frame_size = (checked_cast<int>(ContinuationEntry::size()) + wordSize) \/ VMRegImpl::stack_slot_size;\n+  OopMap* map = new OopMap(frame_size, 0);\n+  ContinuationEntry::setup_oopmap(map);\n+\n+  __ movptr(rax, Address(r15_thread, JavaThread::cont_entry_offset()));\n+  __ movptr(Address(rsp, ContinuationEntry::parent_offset()), rax);\n+  __ movptr(Address(r15_thread, JavaThread::cont_entry_offset()), rsp);\n+\n+  return map;\n+}\n+\n+\/\/---------------------------- fill_continuation_entry ---------------------------\n+\/\/\n+\/\/ Arguments:\n+\/\/   rsp: pointer to blank Continuation entry\n+\/\/   reg_cont_obj: pointer to the continuation\n+\/\/   reg_flags: flags\n+\/\/\n+\/\/ Results:\n+\/\/   rsp: pointer to filled out ContinuationEntry\n+\/\/\n+\/\/ Kills:\n+\/\/   rax\n+\/\/\n+static void fill_continuation_entry(MacroAssembler* masm, Register reg_cont_obj, Register reg_flags) {\n+  assert_different_registers(rax, reg_cont_obj, reg_flags);\n+#ifdef ASSERT\n+  __ movl(Address(rsp, ContinuationEntry::cookie_offset()), ContinuationEntry::cookie_value());\n+#endif\n+  __ movptr(Address(rsp, ContinuationEntry::cont_offset()), reg_cont_obj);\n+  __ movl  (Address(rsp, ContinuationEntry::flags_offset()), reg_flags);\n+  __ movptr(Address(rsp, ContinuationEntry::chunk_offset()), 0);\n+  __ movl(Address(rsp, ContinuationEntry::argsize_offset()), 0);\n+  __ movl(Address(rsp, ContinuationEntry::pin_count_offset()), 0);\n+\n+  __ movptr(rax, Address(r15_thread, JavaThread::cont_fastpath_offset()));\n+  __ movptr(Address(rsp, ContinuationEntry::parent_cont_fastpath_offset()), rax);\n+  __ movq(rax, Address(r15_thread, JavaThread::held_monitor_count_offset()));\n+  __ movq(Address(rsp, ContinuationEntry::parent_held_monitor_count_offset()), rax);\n+\n+  __ movptr(Address(r15_thread, JavaThread::cont_fastpath_offset()), 0);\n+  __ movq(Address(r15_thread, JavaThread::held_monitor_count_offset()), 0);\n+}\n+\n+\/\/---------------------------- continuation_enter_cleanup ---------------------------\n+\/\/\n+\/\/ Arguments:\n+\/\/   rsp: pointer to the ContinuationEntry\n+\/\/\n+\/\/ Results:\n+\/\/   rsp: pointer to the spilled rbp in the entry frame\n+\/\/\n+\/\/ Kills:\n+\/\/   rbx\n+\/\/\n+void static continuation_enter_cleanup(MacroAssembler* masm) {\n+#ifdef ASSERT\n+  Label L_good_sp;\n+  __ cmpptr(rsp, Address(r15_thread, JavaThread::cont_entry_offset()));\n+  __ jcc(Assembler::equal, L_good_sp);\n+  __ stop(\"Incorrect rsp at continuation_enter_cleanup\");\n+  __ bind(L_good_sp);\n+#endif\n+\n+  __ movptr(rbx, Address(rsp, ContinuationEntry::parent_cont_fastpath_offset()));\n+  __ movptr(Address(r15_thread, JavaThread::cont_fastpath_offset()), rbx);\n+  __ movq(rbx, Address(rsp, ContinuationEntry::parent_held_monitor_count_offset()));\n+  __ movq(Address(r15_thread, JavaThread::held_monitor_count_offset()), rbx);\n+\n+  __ movptr(rbx, Address(rsp, ContinuationEntry::parent_offset()));\n+  __ movptr(Address(r15_thread, JavaThread::cont_entry_offset()), rbx);\n+  __ addptr(rsp, checked_cast<int32_t>(ContinuationEntry::size()));\n+}\n+\n@@ -1333,1 +1427,1 @@\n-    OopMap* map = __ continuation_enter_setup(stack_slots);\n+    OopMap* map = continuation_enter_setup(masm, stack_slots);\n@@ -1339,1 +1433,1 @@\n-    __ fill_continuation_entry(reg_cont_obj, reg_is_virtual);\n+    fill_continuation_entry(masm, reg_cont_obj, reg_is_virtual);\n@@ -1368,1 +1462,1 @@\n-  OopMap* map = __ continuation_enter_setup(stack_slots);\n+  OopMap* map = continuation_enter_setup(masm, stack_slots);\n@@ -1375,1 +1469,1 @@\n-  __ fill_continuation_entry(reg_cont_obj, reg_is_virtual);\n+  fill_continuation_entry(masm, reg_cont_obj, reg_is_virtual);\n@@ -1418,1 +1512,1 @@\n-  __ continuation_enter_cleanup();\n+  continuation_enter_cleanup(masm);\n@@ -1426,1 +1520,1 @@\n-  __ continuation_enter_cleanup();\n+  continuation_enter_cleanup(masm);\n@@ -1490,1 +1584,1 @@\n-  __ continuation_enter_cleanup();\n+  continuation_enter_cleanup(masm);\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":101,"deletions":7,"binary":false,"changes":108,"status":"modified"}]}