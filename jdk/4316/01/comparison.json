{"files":[{"patch":"@@ -2435,1 +2435,1 @@\n-    private static long findNative(ClassLoader loader, String entryName) {\n+    static long findNative(ClassLoader loader, String entryName) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ClassLoader.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2396,0 +2396,5 @@\n+\n+            @Override\n+            public long findNative(ClassLoader loader, String entry) {\n+                return ClassLoader.findNative(loader, entry);\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -396,0 +396,2 @@\n+\n+    long findNative(ClassLoader loader, String entry);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -388,14 +388,0 @@\n-    public static final NativeLibrary defaultLibrary = new NativeLibraryImpl(Object.class, \"<default>\", true, true) {\n-\n-        @Override\n-        boolean open() {\n-            throw new UnsupportedOperationException(\"Cannot load default library\");\n-        }\n-\n-        @Override\n-        public long find(String name) {\n-            return NativeLibraries.findEntryInProcess(name);\n-        }\n-\n-    };\n-\n@@ -482,1 +468,0 @@\n-    private static native long findEntryInProcess(String name);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/loader\/NativeLibraries.java","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -249,23 +249,0 @@\n-\/*\n- * Class:     jdk_internal_loader_NativeLibraries\n- * Method:    findEntryInProcess\n- * Signature: (Ljava\/lang\/String;)J\n- *\/\n-JNIEXPORT jlong JNICALL\n-Java_jdk_internal_loader_NativeLibraries_findEntryInProcess\n-  (JNIEnv *env, jclass cls, jstring name)\n-{\n-    const char *cname;\n-    jlong res;\n-\n-    if (!initIDs(env))\n-        return jlong_zero;\n-\n-    cname = (*env)->GetStringUTFChars(env, name, 0);\n-    if (cname == 0)\n-        return jlong_zero;\n-    res = ptr_to_jlong(findEntryInProcess(cname));\n-    (*env)->ReleaseStringUTFChars(env, name, cname);\n-    return res;\n-}\n-\n","filename":"src\/java.base\/share\/native\/libjava\/NativeLibraries.c","additions":0,"deletions":23,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -336,2 +336,0 @@\n-void* findEntryInProcess(const char* name);\n-\n","filename":"src\/java.base\/share\/native\/libjava\/jni_util.h","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,4 +54,0 @@\n-void* findEntryInProcess(const char* name) {\n-    return JVM_FindLibraryEntry(RTLD_DEFAULT, name);\n-}\n-\n","filename":"src\/java.base\/unix\/native\/libjava\/jni_util_md.c","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include <psapi.h>\n@@ -39,25 +38,0 @@\n-\/*\n- * Windows doesn't have an RTLD_DEFAULT equivalent, so in stead we have to\n- * iterate over all the modules loaded by the process to implement the\n- * default library behaviour.\n- *\/\n-void* findEntryInProcess(const char* name) {\n-    HANDLE hProcess = GetCurrentProcess();\n-\n-    HMODULE hMods[1024];\n-    DWORD cbNeeded; \/\/ array size in bytes\n-\n-    \/\/ first come, first served\n-    if (EnumProcessModules(hProcess, hMods, sizeof(hMods), &cbNeeded)) {\n-        for (size_t i = 0; i < (cbNeeded \/ sizeof(HMODULE)); i++) {\n-            HMODULE mod = hMods[i];\n-            FARPROC proc = GetProcAddress(mod, name);\n-            if(proc != NULL) {\n-                return proc;\n-            }\n-        }\n-    }\n-\n-    return NULL;\n-}\n-\n","filename":"src\/java.base\/windows\/native\/libjava\/jni_util_md.c","additions":0,"deletions":26,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import jdk.internal.foreign.SystemLookup;\n@@ -132,0 +133,19 @@\n+    \/**\n+     * Obtains a system lookup which is suitable to find symbols in the standard C libraries. The set of symbols\n+     * available for lookup is unspecified, as it depends on the platform and on the operating system.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted method are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     * @return a system-specific library lookup which is suitable to find symbols in the standard C libraries.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    static SymbolLookup systemLookup() {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        return SystemLookup.getInstance();\n+    }\n+\n@@ -140,1 +160,1 @@\n-     * @see LibraryLookup#lookup(String)\n+     * @see SymbolLookup\n@@ -146,1 +166,2 @@\n-     * @throws IllegalArgumentException in the case of a method type and function descriptor mismatch.\n+     * @throws IllegalArgumentException in the case of a method type and function descriptor mismatch, or if the symbol\n+     *                                  is {@link MemoryAddress#NULL}\n@@ -157,1 +178,1 @@\n-     * @see LibraryLookup#lookup(String)\n+     * @see SymbolLookup\n@@ -164,1 +185,2 @@\n-     * @throws IllegalArgumentException in the case of a method type and function descriptor mismatch.\n+     * @throws IllegalArgumentException in the case of a method type and function descriptor mismatch, or if the symbol\n+     *                                  is {@link MemoryAddress#NULL}\n@@ -177,0 +199,3 @@\n+     * <p>\n+     * The returned method handle will throw an {@link IllegalArgumentException} if the target address passed to it is\n+     * {@link MemoryAddress#NULL}, or a {@link NullPointerException} if the target address is {@code null}.\n@@ -178,1 +203,1 @@\n-     * @see LibraryLookup#lookup(String)\n+     * @see SymbolLookup\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/CLinker.java","additions":30,"deletions":5,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -1,175 +0,0 @@\n-\/*\n- *  Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-package jdk.incubator.foreign;\n-\n-import jdk.internal.foreign.LibrariesHelper;\n-import jdk.internal.reflect.CallerSensitive;\n-import jdk.internal.reflect.Reflection;\n-\n-import java.io.File;\n-import java.lang.invoke.MethodType;\n-import java.nio.file.Path;\n-import java.util.Objects;\n-import java.util.Optional;\n-\n-\/**\n- * A native library lookup. Exposes a lookup operation for searching symbols, see {@link LibraryLookup#lookup(String)}.\n- * A given native library remains loaded as long as there is at least one <em>live<\/em> library lookup instance referring\n- * to it.\n- * All instances generated by a given library lookup object contain a strong reference to said lookup object,\n- * therefore preventing library unloading. For {@linkplain #lookup(String, MemoryLayout) memory segments} obtained from a library lookup object,\n- * this means that clients can safely dereference memory associated with lookup symbols, as follows:\n- * <pre>{@code\n- * LibraryLookup defaultLookup = LibraryLookup.ofDefault();\n- * MemorySegment errnoSegment = defaultLookup.lookup(\"errno\", MemoryLayouts.JAVA_INT).get();\n- * int errno = MemoryAccess.getInt(errnoSegment);\n- * }<\/pre>\n- * <p>\n- * For {@linkplain #lookup(String) memory addresses} obtained from a library lookup object,\n- * since {@linkplain CLinker#downcallHandle(Addressable, MethodType, FunctionDescriptor) native method handles}\n- * also maintain a strong reference to the addressable parameter used for their construction, there is\n- * always a strong reachability chain from a native method handle to a lookup object (the one that was used to lookup\n- * the native library symbol the method handle refers to). This is useful to prevent situations where a native library\n- * is unloaded in the middle of a native call.\n- * <p>\n- * To allow for a library to be unloaded, a client will have to discard any strong references it\n- * maintains, directly, or indirectly to a lookup object associated with given library.\n- *\n- * <p> Unless otherwise specified, passing a {@code null} argument, or an array argument containing one or more {@code null}\n- * elements to a method in this class causes a {@link NullPointerException NullPointerException} to be thrown. <\/p>\n- *\/\n-public interface LibraryLookup {\n-\n-    \/**\n-     * Looks up a symbol with given name in this library. The returned memory address maintains a strong reference to this lookup object.\n-     *\n-     * @param name the symbol name.\n-     * @return the memory address associated with the library symbol (if any).\n-     *\/\n-    Optional<MemoryAddress> lookup(String name);\n-\n-    \/**\n-     * Looks up a symbol with given name in this library. The returned memory segment has a size that matches that of\n-     * the specified layout, and maintains a strong reference to this lookup object. This method can be useful\n-     * to lookup global variable symbols in a foreign library.\n-     *\n-     * @param name the symbol name.\n-     * @param layout the layout to be associated with the library symbol.\n-     * @return the memory segment associated with the library symbol (if any).\n-     * @throws IllegalArgumentException if the address associated with the lookup symbol do not match the\n-     * {@linkplain MemoryLayout#byteAlignment() alignment constraints} in {@code layout}.\n-     *\/\n-    Optional<MemorySegment> lookup(String name, MemoryLayout layout);\n-\n-    \/**\n-     * Obtain a default library lookup object.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted method are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @return the default library lookup object.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-     *\/\n-    @CallerSensitive\n-    static LibraryLookup ofDefault() {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager security = System.getSecurityManager();\n-        if (security != null) {\n-            security.checkPermission(new RuntimePermission(\"java.foreign.getDefaultLibrary\"));\n-        }\n-        return LibrariesHelper.getDefaultLibrary();\n-    }\n-\n-    \/**\n-     * Obtain a library lookup object corresponding to a library identified by given path.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted method are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param path the library absolute path.\n-     * @return a library lookup object for given path.\n-     * @throws IllegalArgumentException if the specified path does not correspond to an absolute path,\n-     * e.g. if {@code !path.isAbsolute()}.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-     *\/\n-    @CallerSensitive\n-    static LibraryLookup ofPath(Path path) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n-        Objects.requireNonNull(path);\n-        if (!path.isAbsolute()) {\n-            throw new IllegalArgumentException(\"Not an absolute path: \" + path.toString());\n-        }\n-        String absolutePath = path.toString();\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager security = System.getSecurityManager();\n-        if (security != null) {\n-            security.checkLink(absolutePath);\n-        }\n-        return LibrariesHelper.load(absolutePath);\n-    }\n-\n-    \/**\n-     * Obtain a library lookup object corresponding to a library identified by given library name. The library name\n-     * is decorated according to the platform conventions (e.g. on Linux, the {@code lib} prefix is added,\n-     * as well as the {@code .so} extension); the resulting name is then looked up in the standard native\n-     * library path (which can be overriden, by setting the <code>java.library.path<\/code> property).\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted method are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param libName the library name.\n-     * @return a library lookup object for given library name.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-     *\/\n-    @CallerSensitive\n-    static LibraryLookup ofLibrary(String libName) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n-        Objects.requireNonNull(libName);\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager security = System.getSecurityManager();\n-        if (security != null) {\n-            security.checkLink(libName);\n-        }\n-        if (libName.indexOf(File.separatorChar) != -1) {\n-            throw new UnsatisfiedLinkError(\n-                    \"Directory separator should not appear in library name: \" + libName);\n-        }\n-        return LibrariesHelper.loadLibrary(libName);\n-    }\n-}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/LibraryLookup.java","additions":0,"deletions":175,"binary":false,"changes":175,"status":"deleted"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.incubator.foreign;\n+\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.reflect.CallerSensitive;\n+import jdk.internal.reflect.Reflection;\n+\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+\/**\n+ * A symbol lookup. Exposes a lookup operation for searching symbol addresses by name, see {@link SymbolLookup#lookup(String)}.\n+ * A symbol lookup can be used to lookup a symbol in a loaded library. Clients can obtain a {@linkplain #loaderLookup() loader lookup},\n+ * which can be used to search symbols in libraries loaded by the current classloader (e.g. using {@link System#load(String)},\n+ * or {@link System#loadLibrary(String)}).\n+ * Alternatively, clients can obtain a {@linkplain CLinker#systemLookup() platform-dependent lookup}, to search symbols\n+ * in the standard C library.\n+ * <p> Unless otherwise specified, passing a {@code null} argument, or an array argument containing one or more {@code null}\n+ * elements to a method in this class causes a {@link NullPointerException NullPointerException} to be thrown. <\/p>\n+ *\/\n+@FunctionalInterface\n+public interface SymbolLookup {\n+\n+    \/**\n+     * Looks up a symbol with given name in this lookup.\n+     *\n+     * @param name the symbol name.\n+     * @return the memory address associated with the symbol (if any).\n+     *\/\n+    Optional<MemoryAddress> lookup(String name);\n+\n+    \/**\n+     * Obtains a symbol lookup suitable to find symbols in native libraries associated with the caller's classloader\n+     * (that is, libraries loaded using {@link System#loadLibrary} or {@link System#load}).\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted method are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @return a symbol lookup suitable to find symbols in libraries loaded by the caller's classloader.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    static SymbolLookup loaderLookup() {\n+        Class<?> caller = Reflection.getCallerClass();\n+        Reflection.ensureNativeAccess(caller);\n+        ClassLoader loader = Objects.requireNonNull(caller.getClassLoader());\n+        return name -> {\n+            Objects.requireNonNull(name);\n+            JavaLangAccess javaLangAccess = SharedSecrets.getJavaLangAccess();\n+            MemoryAddress addr = MemoryAddress.ofLong(javaLangAccess.findNative(loader, name));\n+            return addr == MemoryAddress.NULL? Optional.empty() : Optional.of(addr);\n+        };\n+    }\n+}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/SymbolLookup.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -99,2 +99,2 @@\n- * The key abstractions introduced to support foreign function access are {@link jdk.incubator.foreign.LibraryLookup} and {@link jdk.incubator.foreign.CLinker}.\n- * The former is used to load foreign libraries, as well as to lookup symbols inside said libraries; the latter\n+ * The key abstractions introduced to support foreign function access are {@link jdk.incubator.foreign.SymbolLookup} and {@link jdk.incubator.foreign.CLinker}.\n+ * The former is used to lookup symbols inside native libraries; the latter\n@@ -110,1 +110,1 @@\n-        LibraryLookup.ofDefault().lookup(\"strlen\").get(),\n+        CLinker.systemLookup().lookup(\"strlen\").get(),\n@@ -121,1 +121,1 @@\n- * Here, we lookup the {@code strlen} symbol in the <em>default<\/em> library lookup (see {@link jdk.incubator.foreign.LibraryLookup#ofDefault()}).\n+ * Here, we lookup the {@code strlen} symbol in the {@linkplain jdk.incubator.foreign.CLinker#systemLookup() system lookup}.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/package-info.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import jdk.internal.foreign.abi.SharedUtils;\n@@ -42,1 +43,1 @@\n-        Objects.requireNonNull(symbol);\n+        SharedUtils.checkSymbol(symbol);\n@@ -47,1 +48,1 @@\n-        Objects.requireNonNull(symbol);\n+        SharedUtils.checkSymbol(symbol);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/AbstractCLinker.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,148 +0,0 @@\n-\/*\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-package jdk.internal.foreign;\n-\n-import jdk.incubator.foreign.MemoryAddress;\n-\n-import java.io.File;\n-import jdk.incubator.foreign.LibraryLookup;\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.ResourceScope;\n-import jdk.internal.loader.NativeLibraries;\n-import jdk.internal.loader.NativeLibrary;\n-\n-import java.lang.ref.Reference;\n-import java.lang.ref.WeakReference;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.function.Supplier;\n-\n-public final class LibrariesHelper {\n-    private LibrariesHelper() {}\n-\n-    private static final NativeLibraries nativeLibraries =\n-            NativeLibraries.rawNativeLibraries(LibrariesHelper.class, true);\n-\n-    private static final Map<NativeLibrary, WeakReference<ResourceScope>> loadedLibraries = new ConcurrentHashMap<>();\n-\n-    \/**\n-     * Load the specified shared library.\n-     *\n-     * @param name Name of the shared library to load.\n-     *\/\n-    public static LibraryLookup loadLibrary(String name) {\n-        return lookup(() -> nativeLibraries.loadLibrary(LibrariesHelper.class, name),\n-                \"Library not found: \" + name);\n-    }\n-\n-    \/**\n-     * Load the specified shared library.\n-     *\n-     * @param path Path of the shared library to load.\n-     *\/\n-    public static LibraryLookup load(String path) {\n-        File file = new File(path);\n-        if (!file.isAbsolute()) {\n-            throw new UnsatisfiedLinkError(\n-                    \"Expecting an absolute path of the library: \" + path);\n-        }\n-        return lookup(() -> nativeLibraries.loadLibrary(LibrariesHelper.class, file),\n-                \"Library not found: \" + path);\n-    }\n-\n-    public static LibraryLookup getDefaultLibrary() {\n-        return LibraryLookupImpl.DEFAULT_LOOKUP;\n-    }\n-\n-    static LibraryLookupImpl lookup(Supplier<NativeLibrary> librarySupplier, String notFoundMsg) {\n-        NativeLibrary library = librarySupplier.get();\n-        if (library == null) {\n-            throw new IllegalArgumentException(notFoundMsg);\n-        }\n-        ResourceScope[] holder = new ResourceScope[1];\n-        try {\n-            WeakReference<ResourceScope> scopeRef = loadedLibraries.computeIfAbsent(library, lib -> {\n-                ResourceScopeImpl s = ResourceScopeImpl.createImplicitScope();\n-                holder[0] = s; \/\/ keep the scope alive at least until the outer method returns\n-                s.addOrCleanupIfFail(ResourceScopeImpl.ResourceList.ResourceCleanup.ofRunnable(() -> {\n-                    nativeLibraries.unload(library);\n-                    loadedLibraries.remove(library);\n-                }));\n-                return new WeakReference<>(s);\n-            });\n-            return new LibraryLookupImpl(library, scopeRef.get());\n-        } finally {\n-            Reference.reachabilityFence(holder);\n-        }\n-    }\n-\n-    \/\/Todo: in principle we could expose a scope accessor, so that users could unload libraries at will\n-    static final class LibraryLookupImpl implements LibraryLookup {\n-        final NativeLibrary library;\n-        final MemorySegment librarySegment;\n-\n-        LibraryLookupImpl(NativeLibrary library, ResourceScope scope) {\n-            this.library = library;\n-            this.librarySegment = MemoryAddress.NULL.asSegment(Long.MAX_VALUE, scope);\n-        }\n-\n-        @Override\n-        public final Optional<MemoryAddress> lookup(String name) {\n-            try {\n-                Objects.requireNonNull(name);\n-                MemoryAddress addr = MemoryAddress.ofLong(library.lookup(name));\n-                return Optional.of(librarySegment.asSlice(addr).address());\n-            } catch (NoSuchMethodException ex) {\n-                return Optional.empty();\n-            }\n-        }\n-\n-        @Override\n-        public final Optional<MemorySegment> lookup(String name, MemoryLayout layout) {\n-            try {\n-                Objects.requireNonNull(name);\n-                Objects.requireNonNull(layout);\n-                MemoryAddress addr = MemoryAddress.ofLong(library.lookup(name));\n-                if (addr.toRawLongValue() % layout.byteAlignment() != 0) {\n-                    throw new IllegalArgumentException(\"Bad layout alignment constraints: \" + layout.byteAlignment());\n-                }\n-                return Optional.of(librarySegment.asSlice(addr, layout.byteSize()));\n-            } catch (NoSuchMethodException ex) {\n-                return Optional.empty();\n-            }\n-        }\n-\n-        static LibraryLookup DEFAULT_LOOKUP = new LibraryLookupImpl(NativeLibraries.defaultLibrary, ResourceScopeImpl.GLOBAL);\n-    }\n-\n-    \/* used for testing *\/\n-    public static int numLoadedLibraries() {\n-        return loadedLibraries.size();\n-    }\n-}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/LibrariesHelper.java","additions":0,"deletions":148,"binary":false,"changes":148,"status":"deleted"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.foreign;\n+\n+import jdk.incubator.foreign.SymbolLookup;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.internal.loader.NativeLibraries;\n+import jdk.internal.loader.NativeLibrary;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+public class SystemLookup implements SymbolLookup {\n+\n+    private SystemLookup() { }\n+\n+    final static SystemLookup INSTANCE = new SystemLookup();\n+\n+    \/*\n+     * On POSIX systems, dlsym will allow us to lookup symbol in library dependencies; the same trick doesn't work\n+     * on Windows. For this reason, on Windows we do not generate any side-library, and load msvcrt.dll directly instead.\n+     *\/\n+    final NativeLibrary syslookup = switch (CABI.current()) {\n+        case SysV, AArch64 -> NativeLibraries.rawNativeLibraries(SystemLookup.class, false).loadLibrary(\"syslookup\");\n+        case Win64 -> {\n+            Path system32 = Path.of(System.getenv(\"SystemRoot\"), \"System32\");\n+            Path ucrtbase = system32.resolve(\"ucrtbase.dll\");\n+            Path msvcrt = system32.resolve(\"msvcrt.dll\");\n+\n+            Path stdLib = Files.exists(ucrtbase) ? ucrtbase : msvcrt;\n+\n+            yield NativeLibraries.rawNativeLibraries(SystemLookup.class, false)\n+                    .loadLibrary(null, stdLib.toFile());\n+        }\n+    };\n+\n+    @Override\n+    public Optional<MemoryAddress> lookup(String name) {\n+        Objects.requireNonNull(name);\n+        long addr = syslookup.find(name);\n+        return addr == 0 ?\n+                Optional.empty() : Optional.of(MemoryAddress.ofLong(addr));\n+    }\n+\n+    public static SystemLookup getInstance() {\n+        return INSTANCE;\n+    }\n+}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/SystemLookup.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -93,5 +93,1 @@\n-            MethodHandle MH_Addressable_address = lookup.findVirtual(Addressable.class, \"address\",\n-                    methodType(MemoryAddress.class));\n-            MethodHandle MH_MemoryAddress_toRawLongValue = lookup.findVirtual(MemoryAddress.class, \"toRawLongValue\",\n-                    methodType(long.class));\n-            MH_ADDR_TO_LONG = filterArguments(MH_MemoryAddress_toRawLongValue, 0, MH_Addressable_address);\n+            MH_ADDR_TO_LONG = lookup.findStatic(ProgrammableInvoker.class, \"unboxTargetAddress\", methodType(long.class, Addressable.class));\n@@ -179,0 +175,5 @@\n+    private static long unboxTargetAddress(Addressable addr) {\n+        MemoryAddress ma = SharedUtils.checkSymbol(addr);\n+        return ma.toRawLongValue();\n+    }\n+\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/ProgrammableInvoker.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import jdk.incubator.foreign.LibraryLookup;\n@@ -56,0 +55,1 @@\n+import java.util.Objects;\n@@ -418,1 +418,1 @@\n-        static final LibraryLookup LOOKUP = LibraryLookup.ofDefault();\n+        private static final CLinker linker = getSystemLinker();\n@@ -420,1 +420,1 @@\n-        static final MethodHandle MH_MALLOC = getSystemLinker().downcallHandle(LOOKUP.lookup(\"malloc\").get(),\n+        static final MethodHandle MH_MALLOC = linker.downcallHandle(CLinker.systemLookup().lookup(\"malloc\").get(),\n@@ -424,1 +424,1 @@\n-        static final MethodHandle MH_FREE = getSystemLinker().downcallHandle(LOOKUP.lookup(\"free\").get(),\n+        static final MethodHandle MH_FREE = linker.downcallHandle(CLinker.systemLookup().lookup(\"free\").get(),\n@@ -429,0 +429,8 @@\n+    public static MemoryAddress checkSymbol(Addressable symbol) {\n+        Objects.requireNonNull(symbol);\n+        MemoryAddress symbolAddr = symbol.address();\n+        if (symbolAddr.equals(MemoryAddress.NULL))\n+            throw new IllegalArgumentException(\"Symbol is NULL: \" + symbolAddr);\n+        return symbolAddr;\n+    }\n+\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,28 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ Note: the include below is not strictly required, as dependencies will be pulled using linker flags.\n+\/\/ Adding at least one #include removes unwanted warnings on some platforms.\n+#include <stdlib.h>\n","filename":"src\/jdk.incubator.foreign\/share\/native\/libsyslookup\/syslookup.c","additions":28,"deletions":0,"binary":false,"changes":28,"status":"added"},{"patch":"@@ -32,1 +32,1 @@\n-import jdk.incubator.foreign.LibraryLookup;\n+import jdk.incubator.foreign.SymbolLookup;\n@@ -45,2 +45,3 @@\n-\n-    LibraryLookup lookup = LibraryLookup.ofLibrary(\"SafeAccess\");\n+    static {\n+        System.loadLibrary(\"SafeAccess\");\n+    }\n@@ -52,0 +53,2 @@\n+    static SymbolLookup lookup = SymbolLookup.loaderLookup();\n+\n","filename":"test\/jdk\/java\/foreign\/SafeFunctionAccessTest.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import java.util.Optional;\n@@ -157,1 +158,1 @@\n-        static final LibraryLookup lookup = LibraryLookup.ofDefault();\n+        final static SymbolLookup LOOKUP;\n@@ -159,1 +160,17 @@\n-        final static MethodHandle strcat = abi.downcallHandle(lookup.lookup(\"strcat\").get(),\n+        static {\n+            System.loadLibrary(\"StdLib\");\n+            SymbolLookup stdLibLookup = SymbolLookup.loaderLookup();\n+            MemorySegment funcs = stdLibLookup.lookup(\"funcs\").get()\n+                    .asSegment(C_POINTER.byteSize() * 3, ResourceScope.newImplicitScope());\n+\n+            SymbolLookup fallbackLookup = name -> switch (name) {\n+                    case \"printf\" -> Optional.of(MemoryAccess.getAddressAtIndex(funcs, 0));\n+                    case \"vprintf\" -> Optional.of(MemoryAccess.getAddressAtIndex(funcs, 1));\n+                    case \"gmtime\" -> Optional.of(MemoryAccess.getAddressAtIndex(funcs, 2));\n+                    default -> Optional.empty();\n+                };\n+\n+            LOOKUP = name -> CLinker.systemLookup().lookup(name).or(() -> fallbackLookup.lookup(name));\n+        }\n+\n+        final static MethodHandle strcat = abi.downcallHandle(LOOKUP.lookup(\"strcat\").get(),\n@@ -163,1 +180,1 @@\n-        final static MethodHandle strcmp = abi.downcallHandle(lookup.lookup(\"strcmp\").get(),\n+        final static MethodHandle strcmp = abi.downcallHandle(LOOKUP.lookup(\"strcmp\").get(),\n@@ -167,1 +184,1 @@\n-        final static MethodHandle puts = abi.downcallHandle(lookup.lookup(\"puts\").get(),\n+        final static MethodHandle puts = abi.downcallHandle(LOOKUP.lookup(\"puts\").get(),\n@@ -171,1 +188,1 @@\n-        final static MethodHandle strlen = abi.downcallHandle(lookup.lookup(\"strlen\").get(),\n+        final static MethodHandle strlen = abi.downcallHandle(LOOKUP.lookup(\"strlen\").get(),\n@@ -175,1 +192,1 @@\n-        final static MethodHandle gmtime = abi.downcallHandle(lookup.lookup(\"gmtime\").get(),\n+        final static MethodHandle gmtime = abi.downcallHandle(LOOKUP.lookup(\"gmtime\").get(),\n@@ -179,1 +196,1 @@\n-        final static MethodHandle qsort = abi.downcallHandle(lookup.lookup(\"qsort\").get(),\n+        final static MethodHandle qsort = abi.downcallHandle(LOOKUP.lookup(\"qsort\").get(),\n@@ -187,1 +204,1 @@\n-        final static MethodHandle rand = abi.downcallHandle(lookup.lookup(\"rand\").get(),\n+        final static MethodHandle rand = abi.downcallHandle(LOOKUP.lookup(\"rand\").get(),\n@@ -191,1 +208,1 @@\n-        final static MethodHandle vprintf = abi.downcallHandle(lookup.lookup(\"vprintf\").get(),\n+        final static MethodHandle vprintf = abi.downcallHandle(LOOKUP.lookup(\"vprintf\").get(),\n@@ -195,1 +212,1 @@\n-        final static MemoryAddress printfAddr = lookup.lookup(\"printf\").get();\n+        final static MemoryAddress printfAddr = LOOKUP.lookup(\"printf\").get();\n","filename":"test\/jdk\/java\/foreign\/StdLibTest.java","additions":27,"deletions":10,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-import jdk.incubator.foreign.LibraryLookup;\n+import jdk.incubator.foreign.SymbolLookup;\n@@ -55,1 +55,0 @@\n-    static LibraryLookup lib = LibraryLookup.ofLibrary(\"TestDowncall\");\n@@ -57,0 +56,5 @@\n+    static {\n+        System.loadLibrary(\"TestDowncall\");\n+    }\n+\n+    static SymbolLookup lookup = SymbolLookup.loaderLookup();\n@@ -61,1 +65,1 @@\n-        MemoryAddress addr = lib.lookup(fName).get();\n+        MemoryAddress addr = lookup.lookup(fName).get();\n@@ -88,1 +92,1 @@\n-        MemoryAddress addr = lib.lookup(fName).get();\n+        MemoryAddress addr = lookup.lookup(fName).get();\n","filename":"test\/jdk\/java\/foreign\/TestDowncall.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-    private static final MemoryAddress dummyTarget = MemoryAddress.NULL;\n+    private static final MemoryAddress dummyTarget = MemoryAddress.ofLong(1);\n","filename":"test\/jdk\/java\/foreign\/TestIllegalLink.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import jdk.incubator.foreign.LibraryLookup;\n@@ -46,0 +45,1 @@\n+import jdk.incubator.foreign.SymbolLookup;\n@@ -56,1 +56,5 @@\n-    static final LibraryLookup lookup = LibraryLookup.ofLibrary(\"Intrinsics\");\n+    static {\n+        System.loadLibrary(\"Intrinsics\");\n+    }\n+\n+    static SymbolLookup lookup = SymbolLookup.loaderLookup();\n@@ -87,1 +91,1 @@\n-            MemoryAddress ma = lookup.lookup(name).orElseThrow();\n+            MemoryAddress ma = lookup.lookup(name).get();\n@@ -97,1 +101,1 @@\n-            MemoryAddress ma = lookup.lookup(\"empty\").orElseThrow();\n+            MemoryAddress ma = lookup.lookup(\"empty\").get();\n@@ -112,1 +116,1 @@\n-            MemoryAddress ma = lookup.lookup(\"identity_va\").orElseThrow();\n+            MemoryAddress ma = lookup.lookup(\"identity_va\").get();\n@@ -127,1 +131,1 @@\n-                MemoryAddress ma = lookup.lookup(\"invoke_high_arity\" + i).orElseThrow();\n+                MemoryAddress ma = lookup.lookup(\"invoke_high_arity\" + i).get();\n","filename":"test\/jdk\/java\/foreign\/TestIntrinsics.java","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1,202 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n- * @modules jdk.incubator.foreign\/jdk.internal.foreign\n- * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestLibraryLookup\n- *\/\n-\n-import jdk.incubator.foreign.LibraryLookup;\n-import jdk.incubator.foreign.MemoryAccess;\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.MemoryLayouts;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.internal.foreign.LibrariesHelper;\n-import org.testng.annotations.Test;\n-\n-import java.lang.reflect.Field;\n-import java.net.URL;\n-import java.net.URLClassLoader;\n-import java.nio.file.Path;\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-import static org.testng.Assert.*;\n-\n-\/\/ FYI this test is run on 64-bit platforms only for now,\n-\/\/ since the windows 32-bit linker fails and there\n-\/\/ is some fallback behaviour to use the 64-bit linker,\n-\/\/ where cygwin gets in the way and we accidentally pick up its\n-\/\/ link.exe\n-public class TestLibraryLookup {\n-\n-    @Test(expectedExceptions = IllegalArgumentException.class, expectedExceptionsMessageRegExp = \"Library not found.*\")\n-    public void testInvalidLookupName() {\n-        LibraryLookup.ofLibrary(\"NonExistent\");\n-    }\n-\n-    @Test(expectedExceptions = IllegalArgumentException.class, expectedExceptionsMessageRegExp = \"Not an absolute path.*\")\n-    public void testNoAbsoluteLookupPath() {\n-        LibraryLookup.ofPath(Path.of(\"NonExistent\"));\n-    }\n-\n-    @Test(expectedExceptions = IllegalArgumentException.class, expectedExceptionsMessageRegExp = \"Library not found.*\")\n-    public void testInvalidLookupPath() {\n-        LibraryLookup.ofPath(Path.of(\"NonExistent\").toAbsolutePath());\n-    }\n-\n-    @Test\n-    public void testSimpleLookup() throws Throwable {\n-        MemoryAddress symbol = null;\n-        LibraryLookup lookup = LibraryLookup.ofLibrary(\"LookupTest\");\n-        symbol = lookup.lookup(\"f\").get();\n-        assertEquals(LibrariesHelper.numLoadedLibraries(), 1);\n-        lookup = null;\n-        symbol = null;\n-        waitUnload();\n-    }\n-\n-    @Test\n-    public void testInvalidSymbolLookup() throws Throwable {\n-        MemoryAddress symbol = null;\n-        LibraryLookup lookup = LibraryLookup.ofLibrary(\"LookupTest\");\n-        assertTrue(lookup.lookup(\"nonExistent\").isEmpty());\n-        assertEquals(LibrariesHelper.numLoadedLibraries(), 1);\n-        lookup = null;\n-        symbol = null;\n-        waitUnload();\n-    }\n-\n-    @Test\n-    public void testVariableSymbolLookup() throws Throwable {\n-        LibraryLookup lookup = LibraryLookup.ofLibrary(\"LookupTest\");\n-        MemorySegment segment = lookup.lookup(\"c\", MemoryLayouts.JAVA_INT).get();\n-        assertEquals(MemoryAccess.getInt(segment), 42);\n-        lookup = null;\n-        segment = null;\n-        waitUnload();\n-    }\n-\n-    @Test\n-    public void testBadVariableSymbolLookup() {\n-        LibraryLookup lookup = LibraryLookup.ofLibrary(\"LookupTest\");\n-        try {\n-            MemoryLayout layout = MemoryLayouts.JAVA_INT.withBitAlignment(1 << 16);\n-            MemorySegment segment = lookup.lookup(\"c\", layout).get();\n-            \/\/ no exception, check that address is aligned\n-            if ((segment.address().toRawLongValue() % layout.byteAlignment()) != 0) {\n-                fail(\"Unaligned address\");\n-            }\n-        } catch (IllegalArgumentException ex) {\n-            \/\/ ok, means address was not aligned\n-        }\n-\n-    }\n-\n-    @Test\n-    public void testMultiLookupSameLoader() throws Throwable {\n-        List<MemoryAddress> symbols = new ArrayList<>();\n-        List<LibraryLookup> lookups = new ArrayList<>();\n-        for (int i = 0 ; i < 5 ; i++) {\n-            LibraryLookup lookup = LibraryLookup.ofLibrary(\"LookupTest\");\n-            MemoryAddress symbol = lookup.lookup(\"f\").get();\n-            lookups.add(lookup);\n-            symbols.add(symbol);\n-            assertEquals(LibrariesHelper.numLoadedLibraries(), 1);\n-        }\n-        lookups = null;\n-        symbols = null;\n-        waitUnload();\n-    }\n-\n-    @Test\n-    public void testMultiLookupDifferentLoaders() throws Throwable {\n-        List<URLClassLoader> loaders = new ArrayList<>();\n-        for (int i = 0 ; i < 5 ; i++) {\n-            URLClassLoader loader = new LocalLoader();\n-            Class<?> clazz = loader.loadClass(\"TestLibraryLookup$Holder\");\n-            Field field = clazz.getField(\"lookup\");\n-            field.setAccessible(true);\n-            field.get(null); \/\/make sure <clinit> is run\n-            loaders.add(loader);\n-        }\n-        loaders.forEach(loader -> {\n-            try {\n-                loader.close();\n-            } catch (Throwable ex) {\n-                throw new AssertionError(ex);\n-            }\n-        });\n-        loaders = null;\n-        waitUnload();\n-    }\n-\n-    static class LocalLoader extends URLClassLoader {\n-        public LocalLoader() throws Exception {\n-            super(new URL[] { Path.of(System.getProperty(\"test.classes\")).toUri().toURL() });\n-        }\n-\n-        @Override\n-        public Class<?> loadClass(String name) throws ClassNotFoundException {\n-            Class clazz = findLoadedClass(name);\n-            if (clazz == null) {\n-                \/\/try local first\n-                try {\n-                    clazz = findClass(name);\n-                } catch (ClassNotFoundException e) {\n-                    \/\/ Swallow exception - does not exist locally\n-                }\n-                \/\/then try parent loader\n-                if (clazz == null) {\n-                    clazz = super.loadClass(name);\n-                }\n-            }\n-            return clazz;\n-        }\n-    }\n-\n-    static class Holder {\n-        public static LibraryLookup lookup;\n-        public static MemoryAddress symbol;\n-\n-        static {\n-            try {\n-                lookup = LibraryLookup.ofLibrary(\"LookupTest\");\n-                symbol = lookup.lookup(\"f\").get();\n-            } catch (Throwable ex) {\n-                throw new ExceptionInInitializerError();\n-            }\n-        }\n-    }\n-\n-    private static void waitUnload() throws InterruptedException {\n-        while (LibrariesHelper.numLoadedLibraries() != 0) {\n-            System.gc();\n-            Object o = new Object[1000];\n-            Thread.sleep(1);\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/foreign\/TestLibraryLookup.java","additions":0,"deletions":202,"binary":false,"changes":202,"status":"deleted"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @modules jdk.incubator.foreign\n+ * @run testng\/othervm\n+ *     --enable-native-access=ALL-UNNAMED\n+ *     TestNULLTarget\n+ *\/\n+\n+import jdk.incubator.foreign.Addressable;\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.MemoryAddress;\n+import org.testng.annotations.Test;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+\n+public class TestNULLTarget {\n+\n+    static final CLinker LINKER = CLinker.getInstance();\n+\n+    @Test(expectedExceptions = IllegalArgumentException.class)\n+    public void testNULLLinking() {\n+        LINKER.downcallHandle(\n+                MemoryAddress.NULL,\n+                MethodType.methodType(void.class),\n+                FunctionDescriptor.ofVoid());\n+    }\n+\n+    @Test(expectedExceptions = IllegalArgumentException.class)\n+    public void testNULLVirtual() throws Throwable {\n+        MethodHandle mh = LINKER.downcallHandle(\n+                MethodType.methodType(void.class),\n+                FunctionDescriptor.ofVoid());\n+        mh.invokeExact((Addressable) MemoryAddress.NULL);\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/TestNULLTarget.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -87,0 +87,1 @@\n+            SymbolLookup.class,\n@@ -94,1 +95,0 @@\n-            LibraryLookup.class,\n@@ -148,2 +148,2 @@\n-        addDefaultMapping(MemoryAddress.class, MemoryAddress.NULL);\n-        addDefaultMapping(Addressable.class, MemoryAddress.NULL);\n+        addDefaultMapping(MemoryAddress.class, MemoryAddress.ofLong(1));\n+        addDefaultMapping(Addressable.class, MemoryAddress.ofLong(1));\n@@ -159,1 +159,0 @@\n-        addDefaultMapping(LibraryLookup.class, LibraryLookup.ofDefault());\n@@ -164,0 +163,2 @@\n+        addDefaultMapping(ClassLoader.class, TestNulls.class.getClassLoader());\n+        addDefaultMapping(SymbolLookup.class, CLinker.systemLookup());\n","filename":"test\/jdk\/java\/foreign\/TestNulls.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @modules jdk.incubator.foreign\/jdk.internal.foreign\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestSymbolLookup\n+ *\/\n+\n+import jdk.incubator.foreign.SymbolLookup;\n+import jdk.incubator.foreign.MemoryAccess;\n+import jdk.incubator.foreign.MemoryLayouts;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.*;\n+\n+\/\/ FYI this test is run on 64-bit platforms only for now,\n+\/\/ since the windows 32-bit linker fails and there\n+\/\/ is some fallback behaviour to use the 64-bit linker,\n+\/\/ where cygwin gets in the way and we accidentally pick up its\n+\/\/ link.exe\n+public class TestSymbolLookup {\n+    static {\n+        System.loadLibrary(\"LookupTest\");\n+    }\n+\n+    static SymbolLookup lookup = SymbolLookup.loaderLookup();\n+\n+    @Test\n+    public void testSimpleLookup() {\n+        assertFalse(lookup.lookup(\"f\").isEmpty());\n+    }\n+\n+    @Test\n+    public void testInvalidSymbolLookup() {\n+        assertTrue(lookup.lookup(\"nonExistent\").isEmpty());\n+    }\n+\n+    @Test\n+    public void testVariableSymbolLookup() {\n+        MemorySegment segment = lookup.lookup(\"c\").get().asSegment(MemoryLayouts.JAVA_INT.byteSize(), ResourceScope.globalScope());\n+        assertEquals(MemoryAccess.getInt(segment), 42);\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/TestSymbolLookup.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -31,1 +31,1 @@\n- * @run testng\/othervm\n+ * @run testng\/othervm\/timeout=720\n@@ -38,1 +38,1 @@\n-import jdk.incubator.foreign.LibraryLookup;\n+import jdk.incubator.foreign.SymbolLookup;\n@@ -64,1 +64,3 @@\n-    static LibraryLookup lib = LibraryLookup.ofLibrary(\"TestUpcall\");\n+    static {\n+        System.loadLibrary(\"TestUpcall\");\n+    }\n@@ -67,0 +69,2 @@\n+    static SymbolLookup lookup = SymbolLookup.loaderLookup();\n+\n@@ -91,1 +95,1 @@\n-        MemoryAddress addr = lib.lookup(fName).get();\n+        MemoryAddress addr = lookup.lookup(fName).get();\n@@ -109,1 +113,1 @@\n-        MemoryAddress addr = lib.lookup(fName).get();\n+        MemoryAddress addr = lookup.lookup(fName).get();\n","filename":"test\/jdk\/java\/foreign\/TestUpcall.java","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-import jdk.incubator.foreign.LibraryLookup;\n+import jdk.incubator.foreign.SymbolLookup;\n@@ -69,1 +69,2 @@\n-            LibraryLookup lookup = LibraryLookup.ofLibrary(\"TestUpcallHighArity\");\n+            System.loadLibrary(\"TestUpcallHighArity\");\n+            SymbolLookup lookup = SymbolLookup.loaderLookup();\n","filename":"test\/jdk\/java\/foreign\/TestUpcallHighArity.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-import jdk.incubator.foreign.LibraryLookup;\n+import jdk.incubator.foreign.SymbolLookup;\n@@ -73,1 +73,2 @@\n-        LibraryLookup lookup = LibraryLookup.ofLibrary(\"TestUpcallStructScope\");\n+        System.loadLibrary(\"TestUpcallStructScope\");\n+        SymbolLookup lookup = SymbolLookup.loaderLookup();\n@@ -75,1 +76,1 @@\n-            lookup.lookup(\"do_upcall\").orElseThrow(),\n+            lookup.lookup(\"do_upcall\").get(),\n","filename":"test\/jdk\/java\/foreign\/TestUpcallStructScope.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import jdk.incubator.foreign.LibraryLookup;\n@@ -38,0 +37,1 @@\n+import jdk.incubator.foreign.SymbolLookup;\n@@ -64,2 +64,7 @@\n-    static final MemoryAddress varargsAddr = LibraryLookup.ofLibrary(\"VarArgs\")\n-            .lookup(\"varargs\").get();\n+    static {\n+        System.loadLibrary(\"VarArgs\");\n+    }\n+\n+    static final MemoryAddress varargsAddr =\n+            SymbolLookup.loaderLookup()\n+                    .lookup(\"varargs\").get();\n","filename":"test\/jdk\/java\/foreign\/TestVarArgs.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.incubator.foreign.LibraryLookup;\n@@ -35,0 +34,1 @@\n+import jdk.incubator.foreign.SymbolLookup;\n@@ -78,1 +78,1 @@\n-        addDefaultMapping(LibraryLookup.class, LibraryLookup.ofDefault());\n+        addDefaultMapping(SymbolLookup.class, SymbolLookup.loaderLookup());\n","filename":"test\/jdk\/java\/foreign\/handles\/invoker_module\/handle\/invoker\/MethodHandleInvoker.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-import jdk.incubator.foreign.LibraryLookup;\n+import jdk.incubator.foreign.SymbolLookup;\n@@ -77,9 +77,6 @@\n-                    { MethodHandles.lookup().findStatic(LibraryLookup.class, \"ofPath\",\n-                            MethodType.methodType(LibraryLookup.class, Path.class)),\n-                            \"LibraryLookup::ofPath\" },\n-                    { MethodHandles.lookup().findStatic(LibraryLookup.class, \"ofLibrary\",\n-                            MethodType.methodType(LibraryLookup.class, String.class)),\n-                            \"LibraryLookup::ofLibrary\" },\n-                    { MethodHandles.lookup().findStatic(LibraryLookup.class, \"ofDefault\",\n-                            MethodType.methodType(LibraryLookup.class)),\n-                            \"LibraryLookup::ofDefault\" },\n+                    { MethodHandles.lookup().findStatic(CLinker.class, \"systemLookup\",\n+                            MethodType.methodType(SymbolLookup.class)),\n+                            \"CLinker::systemLookup\" },\n+                    { MethodHandles.lookup().findStatic(SymbolLookup.class, \"loaderLookup\",\n+                            MethodType.methodType(SymbolLookup.class)),\n+                            \"SymbolLookup::loaderLookup\" },\n","filename":"test\/jdk\/java\/foreign\/handles\/lookup_module\/handle\/lookup\/MethodHandleLookup.java","additions":7,"deletions":10,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+#include <stdio.h>\n+#include <time.h>\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+\/\/ Forces generation of inline code on Windows\n+EXPORT void* funcs[] = {\n+    &printf,\n+    &vprintf,\n+    &gmtime\n+};\n","filename":"test\/jdk\/java\/foreign\/libStdLib.c","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestMixedMallocFree\n+ *\/\n+\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.MemoryAccess;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SymbolLookup;\n+import org.testng.annotations.Test;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+\n+import static jdk.incubator.foreign.CLinker.*;\n+import static org.testng.Assert.assertEquals;\n+\n+public class TestMixedMallocFree {\n+\n+    static final MethodHandle MH_my_malloc;\n+\n+    static {\n+        System.loadLibrary(\"Malloc\");\n+        SymbolLookup MALLOC = SymbolLookup.loaderLookup();\n+\n+        MH_my_malloc = CLinker.getInstance().downcallHandle(\n+            MALLOC.lookup(\"my_malloc\").orElseThrow(),\n+            MethodType.methodType(MemoryAddress.class, long.class),\n+            FunctionDescriptor.of(C_POINTER, C_LONG_LONG));\n+    }\n+\n+    @Test\n+    public void testMalloc() throws Throwable {\n+        MemoryAddress ma = (MemoryAddress) MH_my_malloc.invokeExact(4L);\n+        MemorySegment seg = ma.asSegment(4L, ResourceScope.newImplicitScope());\n+        MemoryAccess.setInt(seg, 42);\n+        assertEquals(MemoryAccess.getInt(seg), 42);\n+        \/\/ Test if this free crashes the VM, which might be the case if we load the wrong default library\n+        \/\/ and end up mixing two allocators together.\n+        CLinker.freeMemory(ma);\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/foreign\/malloc\/TestMixedMallocFree.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+#include <stdlib.h>\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+EXPORT void* my_malloc(size_t size) {\n+    return malloc(size);\n+}\n","filename":"test\/jdk\/java\/foreign\/malloc\/libMalloc.c","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -52,1 +52,1 @@\n-import jdk.incubator.foreign.LibraryLookup;\n+import jdk.incubator.foreign.SymbolLookup;\n@@ -54,1 +54,0 @@\n-import jdk.incubator.foreign.MemorySegment;\n@@ -76,1 +75,2 @@\n-            LibraryLookup lookup = LibraryLookup.ofLibrary(\"StackWalk\");\n+            System.loadLibrary(\"StackWalk\");\n+            SymbolLookup lookup = SymbolLookup.loaderLookup();\n","filename":"test\/jdk\/java\/foreign\/stackwalk\/TestStackWalk.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -70,1 +70,5 @@\n-    private static final LibraryLookup lookup = LibraryLookup.ofLibrary(\"VaList\");\n+    static {\n+        System.loadLibrary(\"VaList\");\n+    }\n+\n+    static SymbolLookup lookup = SymbolLookup.loaderLookup();\n","filename":"test\/jdk\/java\/foreign\/valist\/VaListTest.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import jdk.incubator.foreign.LibraryLookup;\n@@ -40,0 +39,1 @@\n+import jdk.incubator.foreign.SymbolLookup;\n@@ -49,1 +49,0 @@\n-    static final LibraryLookup lookup = LibraryLookup.ofLibrary(\"Virtual\");\n@@ -61,3 +60,5 @@\n-        funcA = lookup.lookup(\"funcA\").orElseThrow();\n-        funcB = lookup.lookup(\"funcB\").orElseThrow();\n-        funcC = lookup.lookup(\"funcC\").orElseThrow();\n+        System.loadLibrary(\"Virtual\");\n+        SymbolLookup lookup = SymbolLookup.loaderLookup();\n+        funcA = lookup.lookup(\"funcA\").get();\n+        funcB = lookup.lookup(\"funcB\").get();\n+        funcC = lookup.lookup(\"funcC\").get();\n@@ -73,0 +74,5 @@\n+    @Test(expectedExceptions = NullPointerException.class)\n+    public void testNullTarget() throws Throwable {\n+        int x = (int) func.invokeExact((Addressable) null);\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/virtual\/TestVirtualCalls.java","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import jdk.incubator.foreign.LibraryLookup;\n@@ -34,0 +33,1 @@\n+import jdk.incubator.foreign.SymbolLookup;\n@@ -94,1 +94,2 @@\n-        LibraryLookup ll = LibraryLookup.ofLibrary(\"CallOverhead\");\n+        System.loadLibrary(\"CallOverhead\");\n+        SymbolLookup lookup = SymbolLookup.loaderLookup();\n@@ -96,1 +97,1 @@\n-            func_addr = ll.lookup(\"func\").orElseThrow();\n+            func_addr = lookup.lookup(\"func\").orElseThrow();\n@@ -105,1 +106,1 @@\n-            identity_addr = ll.lookup(\"identity\").orElseThrow();\n+            identity_addr = lookup.lookup(\"identity\").orElseThrow();\n@@ -113,1 +114,1 @@\n-        identity_struct_addr = ll.lookup(\"identity_struct\").orElseThrow();\n+        identity_struct_addr = lookup.lookup(\"identity_struct\").orElseThrow();\n@@ -119,1 +120,1 @@\n-        identity_memory_address_addr = ll.lookup(\"identity_memory_address\").orElseThrow();\n+        identity_memory_address_addr = lookup.lookup(\"identity_memory_address\").orElseThrow();\n@@ -125,1 +126,1 @@\n-        args1_addr = ll.lookup(\"args1\").orElseThrow();\n+        args1_addr = lookup.lookup(\"args1\").orElseThrow();\n@@ -131,1 +132,1 @@\n-        args2_addr = ll.lookup(\"args2\").orElseThrow();\n+        args2_addr = lookup.lookup(\"args2\").orElseThrow();\n@@ -137,1 +138,1 @@\n-        args3_addr = ll.lookup(\"args3\").orElseThrow();\n+        args3_addr = lookup.lookup(\"args3\").orElseThrow();\n@@ -143,1 +144,1 @@\n-        args4_addr = ll.lookup(\"args4\").orElseThrow();\n+        args4_addr = lookup.lookup(\"args4\").orElseThrow();\n@@ -149,1 +150,1 @@\n-        args5_addr = ll.lookup(\"args5\").orElseThrow();\n+        args5_addr = lookup.lookup(\"args5\").orElseThrow();\n@@ -155,1 +156,1 @@\n-        args10_addr = ll.lookup(\"args10\").orElseThrow();\n+        args10_addr = lookup.lookup(\"args10\").orElseThrow();\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/CallOverheadHelper.java","additions":13,"deletions":12,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import jdk.incubator.foreign.LibraryLookup;\n@@ -81,1 +80,0 @@\n-        LibraryLookup lookup = LibraryLookup.ofDefault();\n@@ -83,1 +81,1 @@\n-        STRLEN = abi.downcallHandle(lookup.lookup(\"strlen\").get(),\n+        STRLEN = abi.downcallHandle(CLinker.systemLookup().lookup(\"strlen\").get(),\n@@ -86,1 +84,1 @@\n-        STRLEN_TRIVIAL = abi.downcallHandle(lookup.lookup(\"strlen\").get(),\n+        STRLEN_TRIVIAL = abi.downcallHandle(CLinker.systemLookup().lookup(\"strlen\").get(),\n@@ -89,1 +87,1 @@\n-        MALLOC_TRIVIAL = abi.downcallHandle(lookup.lookup(\"malloc\").get(),\n+        MALLOC_TRIVIAL = abi.downcallHandle(CLinker.systemLookup().lookup(\"malloc\").get(),\n@@ -93,1 +91,1 @@\n-        FREE_TRIVIAL = abi.downcallHandle(lookup.lookup(\"free\").get(),\n+        FREE_TRIVIAL = abi.downcallHandle(CLinker.systemLookup().lookup(\"free\").get(),\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/StrLenTest.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import jdk.incubator.foreign.LibraryLookup;\n@@ -30,0 +29,1 @@\n+import jdk.incubator.foreign.SymbolLookup;\n@@ -83,1 +83,1 @@\n-            LibraryLookup ll = LibraryLookup.ofLibrary(\"Upcalls\");\n+            System.loadLibrary(\"Upcalls\");\n@@ -89,1 +89,1 @@\n-                blank = linkFunc(ll, name, mt, fd);\n+                blank = linkFunc(name, mt, fd);\n@@ -97,1 +97,1 @@\n-                identity = linkFunc(ll, name, mt, fd);\n+                identity = linkFunc(name, mt, fd);\n@@ -107,1 +107,1 @@\n-                args5 = linkFunc(ll, name, mt, fd);\n+                args5 = linkFunc(name, mt, fd);\n@@ -119,1 +119,1 @@\n-                args10 = linkFunc(ll, name, mt, fd);\n+                args10 = linkFunc(name, mt, fd);\n@@ -127,1 +127,1 @@\n-    static MethodHandle linkFunc(LibraryLookup ll, String name, MethodType baseType, FunctionDescriptor baseDesc) {\n+    static MethodHandle linkFunc(String name, MethodType baseType, FunctionDescriptor baseDesc) {\n@@ -129,1 +129,1 @@\n-            ll.lookup(name).orElseThrow(),\n+            SymbolLookup.loaderLookup().lookup(name).orElseThrow(),\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/Upcalls.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import jdk.incubator.foreign.LibraryLookup;\n@@ -28,0 +27,1 @@\n+import jdk.incubator.foreign.SymbolLookup;\n@@ -57,1 +57,3 @@\n-    static final LibraryLookup lookup = LibraryLookup.ofLibrary(\"VaList\");\n+    static {\n+        System.loadLibrary(\"VaList\");\n+    }\n@@ -63,0 +65,1 @@\n+        SymbolLookup lookup = SymbolLookup.loaderLookup();\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/VaList.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-import jdk.incubator.foreign.LibraryLookup;\n+import jdk.incubator.foreign.SymbolLookup;\n@@ -54,1 +54,2 @@\n-        LibraryLookup lookup = LibraryLookup.ofLibrary(\"Point\");\n+        System.loadLibrary(\"Point\");\n+        SymbolLookup lookup = SymbolLookup.loaderLookup();\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/points\/support\/PanamaPoint.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"}]}