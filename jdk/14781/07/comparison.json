{"files":[{"patch":"@@ -55,1 +55,1 @@\n-\/\/ stubbed-out trim-native support\n+\/\/ Trim-native support, stubbed out for now, may be enabled later\n","filename":"src\/hotspot\/os\/aix\/os_aix.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-\/\/ stubbed-out trim-native support\n+\/\/ Trim-native support, stubbed out for now, may be enabled later\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -96,1 +96,1 @@\n-\/\/ stubbed-out trim-native support\n+\/\/ Trim-native support, stubbed out for now, may be enabled later\n","filename":"src\/hotspot\/os\/windows\/os_windows.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+#include \"runtime\/trimNativeHeap.hpp\"\n@@ -459,0 +460,1 @@\n+  NativeHeapTrimmer::SuspendMark sm(\"stringtable\");\n","filename":"src\/hotspot\/share\/classfile\/stringTable.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include \"runtime\/trimNativeHeap.hpp\"\n@@ -740,0 +741,1 @@\n+  NativeHeapTrimmer::SuspendMark sm(\"symboltable\");\n","filename":"src\/hotspot\/share\/classfile\/symbolTable.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -201,0 +201,1 @@\n+  LOG_TAG(trimnative) \/* trim native heap *\/ \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"runtime\/trimNativeHeap.hpp\"\n@@ -95,0 +96,1 @@\n+    NativeHeapTrimmer::SuspendMark sm(\"chunk pool cleaner\");\n","filename":"src\/hotspot\/share\/memory\/arena.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2583,0 +2583,8 @@\n+WB_ENTRY(void, WB_PreTouchMemory(JNIEnv* env, jobject wb, jlong addr, jlong size))\n+  void* const from = (void*)addr;\n+  void* const to = (void*)(addr + size);\n+  if (from > to) {\n+    os::pretouch_memory(from, to, os::vm_page_size());\n+  }\n+WB_END\n+\n@@ -2864,0 +2872,1 @@\n+  {CC\"preTouchMemory\",  CC\"(JJ)V\",                    (void*)&WB_PreTouchMemory},\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1987,0 +1987,7 @@\n+                                                                            \\\n+  product(uint, TrimNativeHeapInterval, 0, EXPERIMENTAL,                    \\\n+          \"Interval, in ms, at which the JVM will trim the native heap if \" \\\n+          \"the platform supports that. Lower values will reclaim memory \"   \\\n+          \"more eagerly at the cost of higher overhead. A value of 0 \"      \\\n+          \"(default) disables the native heap trimming.\")                   \\\n+          range(0, UINT_MAX)                                                \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -73,0 +73,1 @@\n+#include \"runtime\/trimNativeHeap.hpp\"\n@@ -482,0 +483,2 @@\n+  NativeHeapTrimmer::cleanup();\n+\n","filename":"src\/hotspot\/share\/runtime\/java.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+#include \"runtime\/trimNativeHeap.hpp\"\n@@ -1649,0 +1650,1 @@\n+  NativeHeapTrimmer::SuspendMark trim_native_pause(\"monitor deletion\");\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -90,0 +90,1 @@\n+#include \"runtime\/trimNativeHeap.hpp\"\n@@ -758,0 +759,4 @@\n+  if (NativeHeapTrimmer::enabled()) {\n+    NativeHeapTrimmer::initialize();\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,229 @@\n+\/*\n+ * Copyright (c) 2023 SAP SE. All rights reserved.\n+ * Copyright (c) 2023 Red Hat Inc. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"runtime\/globals.hpp\"\n+#include \"runtime\/globals_extension.hpp\"\n+#include \"runtime\/mutex.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n+#include \"runtime\/nonJavaThread.hpp\"\n+#include \"runtime\/os.inline.hpp\"\n+#include \"runtime\/safepoint.hpp\"\n+#include \"runtime\/trimNativeHeap.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+class NativeTrimmerThread : public NamedThread {\n+\n+  Monitor* const _lock;\n+  bool _stop;\n+  uint16_t _suspend_count;\n+\n+  \/\/ Statistics\n+  unsigned _num_trims_performed;\n+\n+  bool is_suspended() const {\n+    assert(_lock->is_locked(), \"Must be\");\n+    return _suspend_count > 0;\n+  }\n+\n+  uint16_t inc_suspend_count() {\n+    assert(_lock->is_locked(), \"Must be\");\n+    assert(_suspend_count < UINT16_MAX, \"Sanity\");\n+    return ++_suspend_count;\n+  }\n+\n+  uint16_t dec_suspend_count() {\n+    assert(_lock->is_locked(), \"Must be\");\n+    assert(_suspend_count != 0, \"Sanity\");\n+    return --_suspend_count;\n+  }\n+\n+  bool is_stopped() const {\n+    assert(_lock->is_locked(), \"Must be\");\n+    return _stop;\n+  }\n+\n+  bool at_or_nearing_safepoint() const {\n+    return SafepointSynchronize::is_at_safepoint() ||\n+        SafepointSynchronize::is_synchronizing();\n+  }\n+  static constexpr int64_t safepoint_poll_ms = 250;\n+\n+  \/\/ in seconds\n+  static double now() { return os::elapsedTime(); }\n+  static double to_ms(double seconds) { return seconds * 1000.0; }\n+\n+  struct LogStartStopMark {\n+    void log(const char* s) { log_info(trimnative)(\"NativeTrimmer %s.\", s); }\n+    LogStartStopMark()  { log(\"start\"); }\n+    ~LogStartStopMark() { log(\"stop\"); }\n+  };\n+\n+  void run() override {\n+    assert(NativeHeapTrimmer::enabled(), \"Only call if enabled\");\n+\n+    LogStartStopMark logStartStop;\n+\n+    const double interval_secs = (double)TrimNativeHeapInterval \/ 1000;\n+\n+    for (;;) {\n+      double tnow = now();\n+      double next_trim_time = tnow + interval_secs;\n+\n+      {\n+        MonitorLocker ml(_lock, Mutex::_no_safepoint_check_flag);\n+        if (_stop) return;\n+\n+        do { \/\/ handle spurious wakeups\n+          if (is_suspended()) {\n+            ml.wait(0); \/\/ infinite\n+          } else if (next_trim_time > tnow) {\n+            const int64_t wait_ms = MAX2(1.0, to_ms(next_trim_time - tnow));\n+            ml.wait(wait_ms);\n+          } else if (at_or_nearing_safepoint()) {\n+            const int64_t wait_ms = MIN2((int64_t)TrimNativeHeapInterval, safepoint_poll_ms);\n+            ml.wait(safepoint_poll_ms);\n+          }\n+\n+          if (_stop) return;\n+\n+          tnow = now();\n+\n+        } while (at_or_nearing_safepoint() || is_suspended() || next_trim_time > tnow);\n+      } \/\/ Lock scope\n+\n+      \/\/ 2 - Trim outside of lock protection.\n+      execute_trim_and_log(tnow);\n+    } \/\/ end for(;;)\n+  }\n+\n+  \/\/ Execute the native trim, log results.\n+  void execute_trim_and_log(double t1) {\n+    assert(os::can_trim_native_heap(), \"Unexpected\");\n+\n+    os::size_change_t sc;\n+    LogTarget(Info, trimnative) lt;\n+    const bool logging_enabled = lt.is_enabled();\n+\n+    \/\/ We only collect size change information if we are logging; save the access to procfs otherwise.\n+    if (os::trim_native_heap(logging_enabled ? &sc : nullptr)) {\n+      _num_trims_performed++;\n+      if (logging_enabled) {\n+        double t2 = now();\n+        if (sc.after != SIZE_MAX) {\n+          const size_t delta = sc.after < sc.before ? (sc.before - sc.after) : (sc.after - sc.before);\n+          const char sign = sc.after < sc.before ? '-' : '+';\n+          log_info(trimnative)(\"Trim native heap (%u): RSS+Swap: \" PROPERFMT \"->\" PROPERFMT \" (%c\" PROPERFMT \"), %1.3fms\",\n+                               _num_trims_performed,\n+                               PROPERFMTARGS(sc.before), PROPERFMTARGS(sc.after), sign, PROPERFMTARGS(delta),\n+                               to_ms(t2 - t1));\n+        } else {\n+          log_info(trimnative)(\"Trim native heap (%u): complete, no details, %1.3fms\", _num_trims_performed, to_ms(t2 - t1));\n+        }\n+      }\n+    }\n+  }\n+\n+public:\n+\n+  NativeTrimmerThread() :\n+    _lock(new (std::nothrow) PaddedMonitor(Mutex::nosafepoint, \"NativeTrimmer_lock\")),\n+    _stop(false),\n+    _suspend_count(0),\n+    _num_trims_performed(0)\n+  {\n+    set_name(\"Native Heap Trimmer\");\n+    if (os::create_thread(this, os::vm_thread)) {\n+      os::start_thread(this);\n+    }\n+  }\n+\n+  void suspend(const char* reason) {\n+    assert(NativeHeapTrimmer::enabled(), \"Only call if enabled\");\n+    uint16_t n = 0;\n+    {\n+      MonitorLocker ml(_lock, Mutex::_no_safepoint_check_flag);\n+      n = inc_suspend_count();\n+      \/\/ No need to wakeup trimmer\n+    }\n+    log_debug(trimnative)(\"NativeTrimmer pause for %s (%u suspend requests)\", reason, n);\n+  }\n+\n+  void resume(const char* reason) {\n+    assert(NativeHeapTrimmer::enabled(), \"Only call if enabled\");\n+    uint16_t n = 0;\n+    {\n+      MonitorLocker ml(_lock, Mutex::_no_safepoint_check_flag);\n+      n = dec_suspend_count();\n+      if (n == 0) {\n+        ml.notify_all(); \/\/ pause end\n+      }\n+    }\n+    log_debug(trimnative)(\"NativeTrimmer unpause for %s (%u suspend requests)\", reason, n);\n+  }\n+\n+  void stop() {\n+    MonitorLocker ml(_lock, Mutex::_no_safepoint_check_flag);\n+    _stop = true;\n+    ml.notify_all();\n+  }\n+\n+}; \/\/ NativeTrimmer\n+\n+static NativeTrimmerThread* g_trimmer_thread = nullptr;\n+\n+void NativeHeapTrimmer::initialize() {\n+  assert(g_trimmer_thread == nullptr, \"Only once\");\n+  if (TrimNativeHeapInterval > 0) {\n+    if (!os::can_trim_native_heap()) {\n+      FLAG_SET_ERGO(TrimNativeHeapInterval, 0);\n+      log_info(trimnative)(\"Native trim not supported on this platform.\");\n+      return;\n+    }\n+    g_trimmer_thread = new NativeTrimmerThread();\n+    log_info(trimnative)(\"Periodic native trim enabled (interval: %u ms)\", TrimNativeHeapInterval);\n+  }\n+}\n+\n+void NativeHeapTrimmer::cleanup() {\n+  if (g_trimmer_thread != nullptr) {\n+    g_trimmer_thread->stop();\n+  }\n+}\n+\n+void NativeHeapTrimmer::suspend_periodic_trim(const char* reason) {\n+  if (g_trimmer_thread != nullptr) {\n+    g_trimmer_thread->suspend(reason);\n+  }\n+}\n+\n+void NativeHeapTrimmer::resume_periodic_trim(const char* reason) {\n+  if (g_trimmer_thread != nullptr) {\n+    g_trimmer_thread->resume(reason);\n+  }\n+}\n","filename":"src\/hotspot\/share\/runtime\/trimNativeHeap.cpp","additions":229,"deletions":0,"binary":false,"changes":229,"status":"added"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2023 SAP SE. All rights reserved.\n+ * Copyright (c) 2023 Red Hat Inc. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_RUNTIME_TRIMNATIVEHEAP_HPP\n+#define SHARE_RUNTIME_TRIMNATIVEHEAP_HPP\n+\n+#include \"memory\/allStatic.hpp\"\n+#include \"runtime\/globals.hpp\"\n+\n+class NativeHeapTrimmer : public AllStatic {\n+\n+  \/\/ Pause periodic trim (if enabled).\n+  static void suspend_periodic_trim(const char* reason);\n+\n+  \/\/ Unpause periodic trim (if enabled).\n+  static void resume_periodic_trim(const char* reason);\n+\n+public:\n+\n+  static void initialize();\n+  static void cleanup();\n+\n+  static uint64_t num_trims_performed();\n+\n+  static inline bool enabled() { return TrimNativeHeapInterval > 0; }\n+\n+  \/\/ Pause periodic trimming while in scope; when leaving scope,\n+  \/\/ resume periodic trimming.\n+  struct SuspendMark {\n+    const char* const _reason;\n+    SuspendMark(const char* reason = \"unknown\") : _reason(reason) {\n+      if (NativeHeapTrimmer::enabled()) {\n+        suspend_periodic_trim(_reason);\n+      }\n+    }\n+    ~SuspendMark()  {\n+      if (NativeHeapTrimmer::enabled()) {\n+        resume_periodic_trim(_reason);\n+      }\n+    }\n+  };\n+};\n+\n+#endif \/\/ SHARE_RUNTIME_TRIMNATIVEHEAP_HPP\n","filename":"src\/hotspot\/share\/runtime\/trimNativeHeap.hpp","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2023 Red Hat Inc. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"runtime\/trimNativeHeap.hpp\"\n+#include \"unittest.hpp\"\n+\n+TEST_VM(TrimNative, SuspendMark) {\n+\n+  if (!NativeHeapTrimmer::enabled()) {\n+    return;\n+  }\n+\n+  \/\/ Try recursive pausing\n+  {\n+    NativeHeapTrimmer::SuspendMark sm1(\"Test1\");\n+    {\n+      NativeHeapTrimmer::SuspendMark sm2(\"Test2\");\n+      {\n+        NativeHeapTrimmer::SuspendMark sm3(\"Test3\");\n+      }\n+    }\n+  }\n+}\n","filename":"test\/hotspot\/gtest\/runtime\/test_trim_native.cpp","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,308 @@\n+\/*\n+ * Copyright (c) 2023 SAP SE. All rights reserved.\n+ * Copyright (c) 2023 Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test id=trimNative\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI TestTrimNative trimNative\n+ *\/\n+\n+\/*\n+ * @test id=trimNativeHighInterval\n+ * @summary High interval trimming should not even kick in for short program runtimes\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI TestTrimNative trimNativeHighInterval\n+ *\/\n+\n+\/*\n+ * @test id=trimNativeLowInterval\n+ * @summary Very low (sub-second) interval, nothing should explode\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI TestTrimNative trimNativeLowInterval\n+ *\/\n+\n+\/*\n+ * @test id=testOffByDefault\n+ * @summary Test that trimming is disabled by default\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI TestTrimNative testOffByDefault\n+ *\/\n+\n+\/*\n+ * @test id=testOffExplicit\n+ * @summary Test that trimming can be disabled explicitly\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI TestTrimNative testOffExplicit\n+ *\/\n+\n+\/*\n+ * @test id=testOffOnNonCompliantPlatforms\n+ * @summary Test that trimming is correctly reported as unavailable if unavailable\n+ * @requires (os.family!=\"linux\") | vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI TestTrimNative testOffOnNonCompliantPlatforms\n+ *\/\n+\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import java.io.IOException;\n+import java.util.*;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import jdk.test.whitebox.WhiteBox;\n+\n+public class TestTrimNative {\n+\n+    \/\/ Actual RSS increase is a lot larger than 4 MB. Depends on glibc overhead, and NMT malloc headers in debug VMs.\n+    \/\/ We need small-grained allocations to make sure they actually increase RSS (all touched) and to see the\n+    \/\/ glibc-retaining-memory effect.\n+    static final int szAllocations = 128;\n+    static final int totalAllocationsSize = 128 * 1024 * 1024; \/\/ 128 MB total\n+    static final int numAllocations = totalAllocationsSize \/ szAllocations;\n+\n+    static long[] ptrs = new long[numAllocations];\n+\n+    enum Unit {\n+        B(1), K(1024), M(1024*1024), G(1024*1024*1024);\n+        public final long size;\n+        Unit(long size) { this.size = size; }\n+    }\n+\n+    private static String[] prepareOptions(String[] extraVMOptions, String[] programOptions) {\n+        List<String> allOptions = new ArrayList<String>();\n+        if (extraVMOptions != null) {\n+            allOptions.addAll(Arrays.asList(extraVMOptions));\n+        }\n+        allOptions.add(\"-Xmx128m\");\n+        allOptions.add(\"-Xms128m\"); \/\/ Stabilize RSS\n+        allOptions.add(\"-XX:+AlwaysPreTouch\"); \/\/ Stabilize RSS\n+        allOptions.add(\"-XX:+UnlockDiagnosticVMOptions\"); \/\/ For whitebox\n+        allOptions.add(\"-XX:+WhiteBoxAPI\");\n+        allOptions.add(\"-Xbootclasspath\/a:.\");\n+        allOptions.add(\"-XX:-ExplicitGCInvokesConcurrent\"); \/\/ Invoke explicit GC on System.gc\n+        allOptions.add(\"-Xlog:trimnative=debug\");\n+        allOptions.add(\"--add-exports=java.base\/jdk.internal.misc=ALL-UNNAMED\");\n+        if (programOptions != null) {\n+            allOptions.addAll(Arrays.asList(programOptions));\n+        }\n+        return allOptions.toArray(new String[0]);\n+    }\n+\n+    private static OutputAnalyzer runTestWithOptions(String[] extraOptions, String[] programOptions) throws IOException {\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(prepareOptions(extraOptions, programOptions));\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldHaveExitValue(0);\n+        return output;\n+    }\n+\n+    private static void checkExpectedLogMessages(OutputAnalyzer output, boolean expectEnabled,\n+                                                 int expectedInterval) {\n+        if (expectEnabled) {\n+            output.shouldContain(\"Periodic native trim enabled (interval: \" + expectedInterval + \" ms\");\n+            output.shouldContain(\"NativeTrimmer start\");\n+            output.shouldContain(\"NativeTrimmer stop\");\n+        } else {\n+            output.shouldNotContain(\"Periodic native trim enabled\");\n+        }\n+    }\n+\n+    \/**\n+     * Given JVM output, look for one or more log lines that describes a successful negative trim. The total amount\n+     * of trims should be matching about what the test program allocated.\n+     * @param output\n+     * @param minTrimsExpected min number of periodic trim lines expected in UL log\n+     * @param maxTrimsExpected min number of periodic trim lines expected in UL log\n+     *\/\n+    private static void parseOutputAndLookForNegativeTrim(OutputAnalyzer output, int minTrimsExpected,\n+                                                          int maxTrimsExpected) {\n+        output.reportDiagnosticSummary();\n+        List<String> lines = output.asLines();\n+        Pattern pat = Pattern.compile(\".*\\\\[trimnative\\\\] Trim native heap \\\\(\\\\d+\\\\): RSS\\\\+Swap: (\\\\d+)([BKMG])->(\\\\d+)([BKMG]).*\");\n+        int numTrimsFound = 0;\n+        long rssReductionTotal = 0;\n+        for (String line : lines) {\n+            Matcher mat = pat.matcher(line);\n+            if (mat.matches()) {\n+                long rss1 = Long.parseLong(mat.group(1)) * Unit.valueOf(mat.group(2)).size;\n+                long rss2 = Long.parseLong(mat.group(3)) * Unit.valueOf(mat.group(4)).size;\n+                if (rss1 > rss2) {\n+                    rssReductionTotal += (rss1 - rss2);\n+                }\n+                numTrimsFound ++;\n+            }\n+            if (numTrimsFound > maxTrimsExpected) {\n+                throw new RuntimeException(\"Abnormal high number of periodic trim attempts found (more than \" + maxTrimsExpected +\n+                        \"). Does the interval setting not work?\");\n+            }\n+        }\n+        if (numTrimsFound < minTrimsExpected) {\n+            throw new RuntimeException(\"We found fewer (periodic) trim lines in UL log than expected (expected at least \" + minTrimsExpected +\n+                    \", found \" + numTrimsFound + \").\");\n+        }\n+        if (maxTrimsExpected > 0) {\n+            \/\/ This is very fuzzy. Test program malloced X bytes, then freed them again and trimmed. But the log line prints change in RSS.\n+            \/\/ Which, of course, is influenced by a lot of other factors. But we expect to see *some* reasonable reduction in RSS\n+            \/\/ due to trimming.\n+            float fudge = 0.5f;\n+            \/\/ On ppc, we see a vastly diminished return (~3M reduction instead of ~200), I suspect because of the underlying\n+            \/\/ 64k pages lead to a different geometry. Manual tests with larger reclaim sizes show that autotrim works. For\n+            \/\/ this test, we just reduce the fudge factor.\n+            if (Platform.isPPC()) { \/\/ le and be both\n+                fudge = 0.01f;\n+            }\n+            long expectedMinimalReduction = (long) (totalAllocationsSize * fudge);\n+            if (rssReductionTotal < expectedMinimalReduction) {\n+                throw new RuntimeException(\"We did not see the expected RSS reduction in the UL log. Expected (with fudge)\" +\n+                        \" to see at least a combined reduction of \" + expectedMinimalReduction + \".\");\n+            }\n+        }\n+    }\n+\n+    static class Tester {\n+        public static void main(String[] args) throws Exception {\n+            long sleeptime = Long.parseLong(args[0]);\n+\n+            System.out.println(\"Will spike now...\");\n+            WhiteBox wb = WhiteBox.getWhiteBox();\n+            for (int i = 0; i < numAllocations; i++) {\n+                ptrs[i] = wb.NMTMalloc(szAllocations);\n+                wb.preTouchMemory(ptrs[i], szAllocations);\n+            }\n+            for (int i = 0; i < numAllocations; i++) {\n+                wb.NMTFree(ptrs[i]);\n+            }\n+            System.out.println(\"Done spiking.\");\n+\n+            System.out.println(\"GC...\");\n+            System.gc();\n+\n+            \/\/ give GC time to react\n+            System.out.println(\"Sleeping...\");\n+            Thread.sleep(sleeptime);\n+            System.out.println(\"Done.\");\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        if (args.length == 0) {\n+            throw new RuntimeException(\"Argument error\");\n+        }\n+\n+        switch (args[0]) {\n+            case \"trimNative\": {\n+                long trimInterval = 500; \/\/ twice per second\n+                long ms1 = System.currentTimeMillis();\n+                OutputAnalyzer output = runTestWithOptions(\n+                        new String[] { \"-XX:+UnlockExperimentalVMOptions\", \"-XX:TrimNativeHeapInterval=\" + trimInterval },\n+                        new String[] { TestTrimNative.Tester.class.getName(), \"5000\" }\n+                );\n+                long ms2 = System.currentTimeMillis();\n+                long runtime_ms = ms2 - ms1;\n+\n+                checkExpectedLogMessages(output, true, 500);\n+\n+                long maxTrimsExpected = runtime_ms \/ trimInterval;\n+                long minTrimsExpected = maxTrimsExpected \/ 2;\n+                parseOutputAndLookForNegativeTrim(output, (int) minTrimsExpected, (int) maxTrimsExpected);\n+            } break;\n+\n+            case \"trimNativeHighInterval\": {\n+                OutputAnalyzer output = runTestWithOptions(\n+                        new String[] { \"-XX:+UnlockExperimentalVMOptions\", \"-XX:TrimNativeHeapInterval=\" + Integer.MAX_VALUE },\n+                        new String[] { TestTrimNative.Tester.class.getName(), \"5000\" }\n+                );\n+                checkExpectedLogMessages(output, true, Integer.MAX_VALUE);\n+                \/\/ We should not see any trims since the interval would prevent them\n+                parseOutputAndLookForNegativeTrim(output, 0, 0);\n+            } break;\n+\n+            case \"trimNativeLowInterval\": {\n+                OutputAnalyzer output = runTestWithOptions(\n+                        new String[] { \"-XX:+UnlockExperimentalVMOptions\", \"-XX:TrimNativeHeapInterval=1\" },\n+                        new String[] { TestTrimNative.Tester.class.getName(), \"0\" }\n+                );\n+                checkExpectedLogMessages(output, true, 1);\n+                parseOutputAndLookForNegativeTrim(output, 1, 3000);\n+            } break;\n+\n+            case \"testOffOnNonCompliantPlatforms\": {\n+                OutputAnalyzer output = runTestWithOptions(\n+                        new String[] { \"-XX:+UnlockExperimentalVMOptions\", \"-XX:TrimNativeHeapInterval=1\" },\n+                        new String[] { \"-version\" }\n+                );\n+                checkExpectedLogMessages(output, false, 0);\n+                parseOutputAndLookForNegativeTrim(output, 0, 0);\n+                output.shouldContain(\"Native trim not supported on this platform\");\n+            } break;\n+\n+            case \"testOffExplicit\": {\n+                OutputAnalyzer output = runTestWithOptions(\n+                        new String[] { \"-XX:+UnlockExperimentalVMOptions\", \"-XX:TrimNativeHeapInterval=0\" },\n+                        new String[] { \"-version\" }\n+                );\n+                checkExpectedLogMessages(output, false, 0);\n+                parseOutputAndLookForNegativeTrim(output, 0, 0);\n+            } break;\n+\n+            case \"testOffByDefault\": {\n+                OutputAnalyzer output = runTestWithOptions(null, new String[] { \"-version\" } );\n+                checkExpectedLogMessages(output, false, 0);\n+                parseOutputAndLookForNegativeTrim(output, 0, 0);\n+            } break;\n+\n+            default:\n+                throw new RuntimeException(\"Invalid test \" + args[0]);\n+\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/os\/TestTrimNative.java","additions":308,"deletions":0,"binary":false,"changes":308,"status":"added"},{"patch":"@@ -25,0 +25,1 @@\n+import jdk.test.lib.Platform;\n@@ -34,1 +35,1 @@\n- * @requires (os.family==\"linux\") & !vm.musl\n+ * @requires os.family == \"linux\"\n@@ -45,1 +46,5 @@\n-        output.shouldMatch(\".*Trim native heap: RSS\\\\+Swap: \\\\d+[BKM]->\\\\d+[BKM].*\");\n+        if (Platform.isMusl()) {\n+            output.shouldContain(\"Not available\");\n+        } else {\n+            output.shouldMatch(\"Trim native heap: RSS\\\\+Swap: \\\\d+[BKMG]->\\\\d+[BKMG] \\\\(-\\\\d+[BKMG]\\\\)\");\n+        }\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/vm\/TrimLibcHeapTest.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -767,0 +767,2 @@\n+\n+  public native void preTouchMemory(long addr, long size);\n","filename":"test\/lib\/jdk\/test\/whitebox\/WhiteBox.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}