{"files":[{"patch":"@@ -56,0 +56,1 @@\n+#include \"runtime\/trimNative.hpp\"\n@@ -459,0 +460,1 @@\n+  TrimNative::SuspendMark tnsm(\"stringtable\");\n","filename":"src\/hotspot\/share\/classfile\/stringTable.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include \"runtime\/trimNative.hpp\"\n@@ -740,0 +741,1 @@\n+  TrimNative::SuspendMark tnsm(\"symboltable\");\n","filename":"src\/hotspot\/share\/classfile\/symbolTable.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -199,0 +199,1 @@\n+  LOG_TAG(trim) \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"runtime\/trimNative.hpp\"\n@@ -95,0 +96,1 @@\n+    TrimNative::SuspendMark tnsm(\"chunk pool cleaner\");\n","filename":"src\/hotspot\/share\/memory\/arena.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1982,0 +1982,9 @@\n+                                                                            \\\n+  product(bool, TrimNativeHeap, false, EXPERIMENTAL,                        \\\n+          \"JVM will attempt to trim the native heap periodically. \"         \\\n+          \"Interval is controlled by TrimNativeHeapInterval.\")              \\\n+                                                                            \\\n+  product(uint, TrimNativeHeapInterval, 60 * 1000, EXPERIMENTAL,            \\\n+          \"If TrimNativeHeap is enabled: interval, in ms, at which \"        \\\n+          \"the GC will attempt to trim the native heap.\")                   \\\n+          range(100, UINT_MAX)                                              \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -73,0 +73,1 @@\n+#include \"runtime\/trimNative.hpp\"\n@@ -482,0 +483,2 @@\n+  TrimNative::cleanup();\n+\n","filename":"src\/hotspot\/share\/runtime\/java.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+#include \"runtime\/trimNative.hpp\"\n@@ -1649,0 +1650,1 @@\n+  TrimNative::SuspendMark trim_native_pause(\"monitor deletion\");\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -90,0 +90,1 @@\n+#include \"runtime\/trimNative.hpp\"\n@@ -758,0 +759,4 @@\n+  if (TrimNativeHeap) {\n+    TrimNative::initialize();\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,246 @@\n+\/*\n+ * Copyright (c) 2023 SAP SE. All rights reserved.\n+ * Copyright (c) 2023 Red Hat Inc. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questioSns.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"runtime\/globals.hpp\"\n+#include \"runtime\/globals_extension.hpp\"\n+#include \"runtime\/mutex.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n+#include \"runtime\/nonJavaThread.hpp\"\n+#include \"runtime\/os.inline.hpp\"\n+#include \"runtime\/safepoint.hpp\"\n+#include \"runtime\/trimNative.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/ticks.hpp\"\n+\n+class NativeTrimmerThread : public NamedThread {\n+\n+  Monitor* const _lock;\n+  bool _stop;\n+  unsigned _suspend_count;\n+\n+  \/\/ Statistics\n+  uint64_t _num_trims_performed;\n+\n+  bool suspended() const {\n+    assert(_lock->is_locked(), \"Must be\");\n+    return _suspend_count > 0;\n+  }\n+\n+  unsigned inc_suspend_count() {\n+    assert(_lock->is_locked(), \"Must be\");\n+    assert(_suspend_count < UINT_MAX, \"Sanity\");\n+    return ++_suspend_count;\n+  }\n+\n+  unsigned dec_suspend_count() {\n+    assert(_lock->is_locked(), \"Must be\");\n+    assert(_suspend_count != 0, \"Sanity\");\n+    return --_suspend_count;\n+  }\n+\n+  bool stopped() const {\n+    assert(_lock->is_locked(), \"Must be\");\n+    return _stop;\n+  }\n+\n+  bool at_or_nearing_safepoint() const {\n+    return\n+        SafepointSynchronize::is_at_safepoint() ||\n+        SafepointSynchronize::is_synchronizing();\n+  }\n+  static constexpr int safepoint_poll_ms = 250;\n+\n+  static int64_t now() { return os::javaTimeMillis(); }\n+\n+  void run() override {\n+    log_info(trim)(\"NativeTrimmer start.\");\n+    run_inner();\n+    log_info(trim)(\"NativeTrimmer stop.\");\n+  }\n+\n+  void run_inner() {\n+\n+    bool trim_result = false;\n+\n+    for (;;) {\n+\n+      int64_t tnow = now();\n+      int64_t next_trim_time = tnow + TrimNativeHeapInterval;\n+\n+      {\n+        MonitorLocker ml(_lock, Mutex::_no_safepoint_check_flag);\n+\n+        if (trim_result) {\n+          _num_trims_performed++;\n+        }\n+\n+        do { \/\/ handle spurious wakeups\n+\n+          if (_stop) {\n+            return;\n+          }\n+\n+          if (suspended()) {\n+            ml.wait(0);\n+          } else if (next_trim_time > tnow) {\n+            ml.wait(next_trim_time - tnow);\n+          } else if (at_or_nearing_safepoint()) {\n+            ml.wait(safepoint_poll_ms);\n+          }\n+\n+          if (_stop) {\n+            return;\n+          }\n+\n+          tnow = now();\n+\n+        } while (at_or_nearing_safepoint() || suspended() || next_trim_time > tnow);\n+\n+      } \/\/ Lock scope\n+\n+      \/\/ 2 - Trim outside of lock protection.\n+      trim_result = execute_trim_and_log(tnow);\n+\n+    }\n+  }\n+\n+  \/\/ Execute the native trim, log results.\n+  bool execute_trim_and_log(int64_t tnow) const {\n+    assert(os::can_trim_native_heap(), \"Unexpected\");\n+    os::size_change_t sc;\n+    Ticks start = Ticks::now();\n+    log_debug(trim)(\"Trim native heap started...\");\n+    if (os::trim_native_heap(&sc)) {\n+      Tickspan trim_time = (Ticks::now() - start);\n+      if (sc.after != SIZE_MAX) {\n+        const size_t delta = sc.after < sc.before ? (sc.before - sc.after) : (sc.after - sc.before);\n+        const char sign = sc.after < sc.before ? '-' : '+';\n+        log_info(trim)(\"Trim native heap: RSS+Swap: \" PROPERFMT \"->\" PROPERFMT \" (%c\" PROPERFMT \"), %1.3fms\",\n+                           PROPERFMTARGS(sc.before), PROPERFMTARGS(sc.after), sign, PROPERFMTARGS(delta),\n+                           trim_time.seconds() * 1000);\n+        log_debug(trim)(\"Total trims: \" UINT64_FORMAT \".\", _num_trims_performed);\n+        return true;\n+      } else {\n+        log_info(trim)(\"Trim native heap (no details)\");\n+      }\n+    }\n+    return false;\n+  }\n+\n+public:\n+\n+  NativeTrimmerThread() :\n+    _lock(new (std::nothrow) PaddedMonitor(Mutex::nosafepoint, \"NativeTrimmer_lock\")),\n+    _stop(false),\n+    _suspend_count(0),\n+    _num_trims_performed(0)\n+  {\n+    set_name(\"Native Heap Trimmer\");\n+    if (os::create_thread(this, os::vm_thread)) {\n+      os::start_thread(this);\n+    }\n+  }\n+\n+  void suspend(const char* reason) {\n+    assert(TrimNativeHeap, \"Only call if enabled\");\n+    unsigned n = 0;\n+    {\n+      MonitorLocker ml(_lock, Mutex::_no_safepoint_check_flag);\n+      n = inc_suspend_count();\n+      \/\/ No need to wakeup trimmer\n+    }\n+    log_debug(trim)(\"NativeTrimmer pause (%s) (%u)\", reason, n);\n+  }\n+\n+  void resume(const char* reason) {\n+    assert(TrimNativeHeap, \"Only call if enabled\");\n+    unsigned n = 0;\n+    {\n+      MonitorLocker ml(_lock, Mutex::_no_safepoint_check_flag);\n+      n = dec_suspend_count();\n+      if (n == 0) {\n+        ml.notify_all(); \/\/ pause end\n+      }\n+    }\n+    log_debug(trim)(\"NativeTrimmer unpause (%s) (%u)\", reason, n);\n+  }\n+\n+  uint64_t num_trims_performed() const {\n+    MonitorLocker ml(_lock, Mutex::_no_safepoint_check_flag);\n+    return _num_trims_performed;\n+  }\n+\n+  void stop() {\n+    MonitorLocker ml(_lock, Mutex::_no_safepoint_check_flag);\n+    _stop = true;\n+    ml.notify_all();\n+  }\n+\n+}; \/\/ NativeTrimmer\n+\n+static NativeTrimmerThread* g_trimmer_thread = nullptr;\n+\n+\/\/\/ GCTrimNative outside facing methods\n+\n+void TrimNative::initialize() {\n+  if (TrimNativeHeap) {\n+    if (!os::can_trim_native_heap()) {\n+      FLAG_SET_ERGO(TrimNativeHeap, false);\n+      log_info(trim)(\"Native trim not supported on this platform.\");\n+      return;\n+    }\n+    g_trimmer_thread = new NativeTrimmerThread();\n+    log_info(trim)(\"Periodic native trim enabled (interval: %u ms)\", TrimNativeHeapInterval);\n+  }\n+}\n+\n+void TrimNative::cleanup() {\n+  if (g_trimmer_thread != nullptr) {\n+    g_trimmer_thread->stop();\n+  }\n+}\n+\n+void TrimNative::suspend_periodic_trim(const char* reason) {\n+  if (g_trimmer_thread != nullptr) {\n+    g_trimmer_thread->suspend(reason);\n+  }\n+}\n+\n+void TrimNative::resume_periodic_trim(const char* reason) {\n+  if (g_trimmer_thread != nullptr) {\n+    g_trimmer_thread->resume(reason);\n+  }\n+}\n+\n+uint64_t TrimNative::num_trims_performed() {\n+  if (g_trimmer_thread != nullptr) {\n+    return g_trimmer_thread->num_trims_performed();\n+  }\n+  return 0;\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/trimNative.cpp","additions":246,"deletions":0,"binary":false,"changes":246,"status":"added"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2023 SAP SE. All rights reserved.\n+ * Copyright (c) 2023 Red Hat Inc. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHARED_TRIMNATIVE_HPP\n+#define SHARE_GC_SHARED_TRIMNATIVE_HPP\n+\n+#include \"memory\/allStatic.hpp\"\n+#include \"runtime\/globals.hpp\"\n+\n+class TrimNative : public AllStatic {\n+\n+  \/\/ Pause periodic trim (if enabled).\n+  static void suspend_periodic_trim(const char* reason);\n+\n+  \/\/ Unpause periodic trim (if enabled).\n+  static void resume_periodic_trim(const char* reason);\n+\n+public:\n+\n+  static void initialize();\n+  static void cleanup();\n+\n+  static uint64_t num_trims_performed();\n+\n+  \/\/ Pause periodic trimming while in scope; when leaving scope,\n+  \/\/ resume periodic trimming.\n+  struct SuspendMark {\n+    const char* const _reason;\n+    SuspendMark(const char* reason = \"unknown\") : _reason(reason) {\n+      if (TrimNativeHeap) {\n+        suspend_periodic_trim(_reason);\n+      }\n+    }\n+    ~SuspendMark()  {\n+      if (TrimNativeHeap) {\n+        resume_periodic_trim(_reason);\n+      }\n+    }\n+  };\n+};\n+\n+#endif \/\/ SHARE_GC_SHARED_TRIMNATIVE_HPP\n","filename":"src\/hotspot\/share\/runtime\/trimNative.hpp","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -0,0 +1,279 @@\n+\/*\n+ * Copyright (c) 2023 SAP SE. All rights reserved.\n+ * Copyright (c) 2023 Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver TestTrimNative test\n+ *\/\n+\n+\/*\n+ * @test id=testOffByDefault\n+ * @summary Test that -GCTrimNative disables the feature\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver TestTrimNative testOffByDefault\n+ *\/\n+\n+\/*\n+ * @test id=testOffExplicit\n+ * @summary Test that GCTrimNative is off by default\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver TestTrimNative testOffExplicit\n+ *\/\n+\n+\/*\n+ * @test id=testOffOnNonCompliantPlatforms\n+ * @summary Test that GCTrimNative is off on unsupportive platforms\n+ * @requires (os.family!=\"linux\") | vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver TestTrimNative testOffOnNonCompliantPlatforms\n+ *\/\n+\n+import jdk.internal.misc.Unsafe;\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Array;\n+import java.rmi.RemoteException;\n+import java.util.*;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+public class TestTrimNative {\n+\n+    \/\/ Actual RSS increase is a lot larger than 4 MB. Depends on glibc overhead, and NMT malloc headers in debug VMs.\n+    \/\/ We need small-grained allocations to make sure they actually increase RSS (all touched) and to see the\n+    \/\/ glibc-retaining-memory effect.\n+    static final int szAllocations = 16;\n+    static final int totalAllocationsSize = 16 * 1024 * 1024; \/\/ 16 MB total\n+    static final int numAllocations = totalAllocationsSize \/ szAllocations;\n+\n+    static long[] ptrs = new long[numAllocations];\n+\n+    enum Unit {\n+        B(1), K(1024), M(1024*1024), G(1024*1024*1024);\n+        public final long size;\n+        Unit(long size) { this.size = size; }\n+    }\n+\n+    private static String[] prepareOptions(String[] extraVMOptions, String[] programOptions) {\n+        List<String> allOptions = new ArrayList<String>();\n+        if (extraVMOptions != null) {\n+            allOptions.addAll(Arrays.asList(extraVMOptions));\n+        }\n+        allOptions.add(\"-Xmx128m\");\n+        allOptions.add(\"-Xms128m\"); \/\/ Stabilize RSS\n+        allOptions.add(\"-XX:+AlwaysPreTouch\"); \/\/ Stabilize RSS\n+        allOptions.add(\"-XX:-ExplicitGCInvokesConcurrent\"); \/\/ Invoke explicit GC on System.gc\n+        allOptions.add(\"-Xlog:trim=debug\");\n+        allOptions.add(\"--add-exports=java.base\/jdk.internal.misc=ALL-UNNAMED\");\n+        allOptions.add(TestTrimNative.class.getName());\n+        if (programOptions != null) {\n+            allOptions.addAll(Arrays.asList(programOptions));\n+        }\n+        return allOptions.toArray(new String[0]);\n+    }\n+\n+    private static OutputAnalyzer runTestWithOptions(String[] extraOptions, String[] programOptions) throws IOException {\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(prepareOptions(extraOptions, programOptions));\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldHaveExitValue(0);\n+        return output;\n+    }\n+\n+    private static void checkExpectedLogMessages(OutputAnalyzer output, boolean expectEnabled,\n+                                                 int expectedInterval) {\n+        if (expectEnabled) {\n+            output.shouldContain(\"Periodic native trim enabled (interval: \" + expectedInterval + \" ms\");\n+            output.shouldContain(\"NativeTrimmer start\");\n+            output.shouldContain(\"NativeTrimmer stop\");\n+        } else {\n+            output.shouldNotContain(\"Periodic native trim enabled\");\n+        }\n+    }\n+\n+    \/**\n+     * Given JVM output, look for one or more log lines that describes a successful negative trim. The total amount\n+     * of trims should be matching about what the test program allocated.\n+     * @param output\n+     * @param minTrimsExpected min number of periodic trim lines expected in UL log\n+     * @param maxTrimsExpected min number of periodic trim lines expected in UL log\n+     *\/\n+    private static void parseOutputAndLookForNegativeTrim(OutputAnalyzer output, int minTrimsExpected,\n+                                                          int maxTrimsExpected) {\n+        output.reportDiagnosticSummary();\n+        List<String> lines = output.asLines();\n+        Pattern pat = Pattern.compile(\".*\\\\[trim\\\\] Trim native heap: RSS\\\\+Swap: (\\\\d+)([BKMG])->(\\\\d+)([BKMG]).*\");\n+        int numTrimsFound = 0;\n+        long rssReductionTotal = 0;\n+        for (String line : lines) {\n+            Matcher mat = pat.matcher(line);\n+            if (mat.matches()) {\n+                long rss1 = Long.parseLong(mat.group(1)) * Unit.valueOf(mat.group(2)).size;\n+                long rss2 = Long.parseLong(mat.group(3)) * Unit.valueOf(mat.group(4)).size;\n+                System.out.println(\"Parsed Trim Line. rss1: \" + rss1 + \" rss2: \" + rss2);\n+                if (rss1 > rss2) {\n+                    rssReductionTotal += (rss1 - rss2);\n+                }\n+                numTrimsFound ++;\n+            }\n+            if (numTrimsFound > maxTrimsExpected) {\n+                throw new RuntimeException(\"Abnormal high number of periodic trim attempts found (more than \" + maxTrimsExpected +\n+                        \"). Does the interval setting not work?\");\n+            }\n+        }\n+        if (numTrimsFound < minTrimsExpected) {\n+            throw new RuntimeException(\"We found fewer (periodic) trim lines in UL log than expected (expected at least \" + minTrimsExpected +\n+                    \", found \" + numTrimsFound + \").\");\n+        }\n+        \/\/ This is very fuzzy. Test program malloced X bytes, then freed them again and trimmed. But the log line prints change in RSS.\n+        \/\/ Which, of course, is influenced by a lot of other factors. But we expect to see *some* reasonable reduction in RSS\n+        \/\/ due to trimming.\n+        float fudge = 0.5f;\n+        \/\/ On ppc, we see a vastly diminished return (~3M reduction instead of ~200), I suspect because of the underlying\n+        \/\/ 64k pages lead to a different geometry. Manual tests with larger reclaim sizes show that autotrim works. For\n+        \/\/ this test, we just reduce the fudge factor.\n+        if (Platform.isPPC()) { \/\/ le and be both\n+            fudge = 0.01f;\n+        }\n+        long expectedMinimalReduction = (long) (totalAllocationsSize * fudge);\n+        if (rssReductionTotal < expectedMinimalReduction) {\n+            throw new RuntimeException(\"We did not see the expected RSS reduction in the UL log. Expected (with fudge)\" +\n+                    \" to see at least a combined reduction of \" + expectedMinimalReduction + \".\");\n+        }\n+    }\n+\n+    static private final void runTest(String[] VMargs) throws IOException {\n+        long trimInterval = 500; \/\/ twice per second\n+        long ms1 = System.currentTimeMillis();\n+        OutputAnalyzer output = runTestWithOptions (\n+                new String[] { \"-XX:+UnlockExperimentalVMOptions\",\n+                               \"-XX:+TrimNativeHeap\",\n+                               \"-XX:TrimNativeHeapInterval=\" + trimInterval },\n+                new String[] { \"RUN\", \"5000\" }\n+        );\n+        long ms2 = System.currentTimeMillis();\n+        long runtime_ms = ms2 - ms1;\n+\n+        checkExpectedLogMessages(output, true, 500);\n+\n+        long maxTrimsExpected = runtime_ms \/ trimInterval;\n+        long minTrimsExpected = maxTrimsExpected \/ 2;\n+        parseOutputAndLookForNegativeTrim(output, (int)minTrimsExpected, (int)maxTrimsExpected);\n+    }\n+\n+    \/\/ Test that a high trim interval effectively disables trimming\n+    static private final void testHighTrimInterval() throws IOException {\n+        OutputAnalyzer output = runTestWithOptions (\n+                new String[] { \"-XX:+UnlockExperimentalVMOptions\",\n+                               \"-XX:+TrimNativeHeap\",\n+                               \"-XX:TrimNativeHeapInterval=\" + Integer.MAX_VALUE },\n+                new String[] { \"RUN\", \"5000\" }\n+        );\n+        checkExpectedLogMessages(output, true, Integer.MAX_VALUE);\n+        parseOutputAndLookForNegativeTrim(output,0, \/*  minTrimsExpected *\/ 0  \/*  maxTrimsExpected *\/);\n+    }\n+\n+    \/\/ Test that trim-native gets disabled on platforms that don't support it.\n+    static private final void testOffOnNonCompliantPlatforms() throws IOException {\n+        OutputAnalyzer output = runTestWithOptions (\n+                new String[] { \"-XX:+UnlockExperimentalVMOptions\",\n+                               \"-XX:+TrimNativeHeap\" },\n+                new String[] { \"RUN\", \"0\" }\n+        );\n+        checkExpectedLogMessages(output, false, 0);\n+        output.shouldContain(\"Native trim not supported on this platform\");\n+    }\n+\n+    \/\/ Test trim native is disabled if explicitly switched off\n+    static private final void testOffExplicit() throws IOException {\n+        OutputAnalyzer output = runTestWithOptions (\n+                new String[] { \"-XX:+UnlockExperimentalVMOptions\",\n+                               \"-XX:-TrimNativeHeap\"\n+                },\n+                new String[] { \"RUN\", \"0\" }\n+                );\n+        checkExpectedLogMessages(output, false, 0);\n+    }\n+\n+    \/\/ Test trim native is disabled if explicitly switched off\n+    static private final void testOffByDefault() throws IOException {\n+        OutputAnalyzer output = runTestWithOptions (null, new String[] { \"RUN\", \"0\" } );\n+        checkExpectedLogMessages(output, false, 0);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        if (args.length == 0) {\n+            throw new RuntimeException(\"Argument error\");\n+        }\n+\n+        if (args[0].equals(\"RUN\")) {\n+\n+            System.out.println(\"Will spike now...\");\n+            for (int i = 0; i < numAllocations; i++) {\n+                ptrs[i] = Unsafe.getUnsafe().allocateMemory(szAllocations);\n+                Unsafe.getUnsafe().putByte(ptrs[i], (byte)0);\n+                Unsafe.getUnsafe().putByte(ptrs[i] + szAllocations \/ 2, (byte)0);\n+            }\n+            for (int i = 0; i < numAllocations; i++) {\n+                Unsafe.getUnsafe().freeMemory(ptrs[i]);\n+            }\n+            System.out.println(\"Done spiking.\");\n+\n+            \/\/ Do a system GC. Native trimming should be paused in that time.\n+            System.out.println(\"GC...\");\n+            System.gc();\n+\n+            \/\/ give GC time to react\n+            System.out.println(\"Sleeping...\");\n+            Thread.sleep(3000);\n+            System.out.println(\"Done.\");\n+\n+            return;\n+\n+        } else if (args[0].equals(\"test\")) {\n+            runTest(Arrays.copyOfRange(args, 1, args.length));\n+        } else if (args[0].equals(\"testOffOnNonCompliantPlatforms\")) {\n+            testOffOnNonCompliantPlatforms();\n+        } else if (args[0].equals(\"testOffExplicit\")) {\n+            testOffExplicit();\n+        } else if (args[0].equals(\"testOffByDefault\")) {\n+            testOffByDefault();\n+        } else {\n+            throw new RuntimeException(\"Invalid test \" + args[0]);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/os\/TestTrimNative.java","additions":279,"deletions":0,"binary":false,"changes":279,"status":"added"},{"patch":"@@ -25,0 +25,1 @@\n+import jdk.test.lib.Platform;\n@@ -34,1 +35,1 @@\n- * @requires (os.family==\"linux\") & !vm.musl\n+ * @requires os.family == \"linux\"\n@@ -45,1 +46,5 @@\n-        output.shouldMatch(\".*Trim native heap: RSS\\\\+Swap: \\\\d+[BKM]->\\\\d+[BKM].*\");\n+        if (Platform.isMusl()) {\n+            output.shouldContain(\"Not available\");\n+        } else {\n+            output.shouldMatch(\"Trim native heap: RSS\\\\+Swap: \\\\d+[BKMG]->\\\\d+[BKMG] \\\\(-\\\\d+[BKMG]\\\\)\");\n+        }\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/vm\/TrimLibcHeapTest.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"}]}