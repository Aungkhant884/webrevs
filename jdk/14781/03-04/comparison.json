{"files":[{"patch":"@@ -56,1 +56,1 @@\n-#include \"runtime\/trimNative.hpp\"\n+#include \"runtime\/trimNativeHeap.hpp\"\n@@ -460,1 +460,1 @@\n-  TrimNative::SuspendMark tnsm(\"stringtable\");\n+  NativeHeapTrimmer::SuspendMark sm(\"stringtable\");\n","filename":"src\/hotspot\/share\/classfile\/stringTable.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-#include \"runtime\/trimNative.hpp\"\n+#include \"runtime\/trimNativeHeap.hpp\"\n@@ -741,1 +741,1 @@\n-  TrimNative::SuspendMark tnsm(\"symboltable\");\n+  NativeHeapTrimmer::SuspendMark sm(\"symboltable\");\n","filename":"src\/hotspot\/share\/classfile\/symbolTable.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -199,1 +199,1 @@\n-  LOG_TAG(trim) \\\n+  LOG_TAG(trimnh) \/* trim native heap *\/ \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-#include \"runtime\/trimNative.hpp\"\n+#include \"runtime\/trimNativeHeap.hpp\"\n@@ -96,1 +96,1 @@\n-    TrimNative::SuspendMark tnsm(\"chunk pool cleaner\");\n+    NativeHeapTrimmer::SuspendMark sm(\"chunk pool cleaner\");\n","filename":"src\/hotspot\/share\/memory\/arena.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2583,0 +2583,8 @@\n+WB_ENTRY(void, WB_PreTouchMemory(JNIEnv* env, jobject wb, jlong addr, jlong size))\n+  void* const from = (void*)addr;\n+  void* const to = (void*)(addr + size);\n+  if (from > to) {\n+    os::pretouch_memory(from, to, os::vm_page_size());\n+  }\n+WB_END\n+\n@@ -2864,0 +2872,1 @@\n+  {CC\"preTouchMemory\",  CC\"(JJ)V\",                    (void*)&WB_PreTouchMemory},\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1989,2 +1989,2 @@\n-          \"the GC will attempt to trim the native heap.\")                   \\\n-          range(100, UINT_MAX)                                              \\\n+          \"the to trim the native heap.\")                                   \\\n+          range(1, UINT_MAX)                                                \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -73,1 +73,1 @@\n-#include \"runtime\/trimNative.hpp\"\n+#include \"runtime\/trimNativeHeap.hpp\"\n@@ -483,1 +483,1 @@\n-  TrimNative::cleanup();\n+  NativeHeapTrimmer::cleanup();\n","filename":"src\/hotspot\/share\/runtime\/java.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-#include \"runtime\/trimNative.hpp\"\n+#include \"runtime\/trimNativeHeap.hpp\"\n@@ -1650,1 +1650,1 @@\n-  TrimNative::SuspendMark trim_native_pause(\"monitor deletion\");\n+  NativeHeapTrimmer::SuspendMark trim_native_pause(\"monitor deletion\");\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -90,1 +90,1 @@\n-#include \"runtime\/trimNative.hpp\"\n+#include \"runtime\/trimNativeHeap.hpp\"\n@@ -760,1 +760,1 @@\n-    TrimNative::initialize();\n+    NativeHeapTrimmer::initialize();\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,246 +0,0 @@\n-\/*\n- * Copyright (c) 2023 SAP SE. All rights reserved.\n- * Copyright (c) 2023 Red Hat Inc. All rights reserved.\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questioSns.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"logging\/log.hpp\"\n-#include \"runtime\/globals.hpp\"\n-#include \"runtime\/globals_extension.hpp\"\n-#include \"runtime\/mutex.hpp\"\n-#include \"runtime\/mutexLocker.hpp\"\n-#include \"runtime\/nonJavaThread.hpp\"\n-#include \"runtime\/os.inline.hpp\"\n-#include \"runtime\/safepoint.hpp\"\n-#include \"runtime\/trimNative.hpp\"\n-#include \"utilities\/debug.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-#include \"utilities\/ticks.hpp\"\n-\n-class NativeTrimmerThread : public NamedThread {\n-\n-  Monitor* const _lock;\n-  bool _stop;\n-  unsigned _suspend_count;\n-\n-  \/\/ Statistics\n-  uint64_t _num_trims_performed;\n-\n-  bool suspended() const {\n-    assert(_lock->is_locked(), \"Must be\");\n-    return _suspend_count > 0;\n-  }\n-\n-  unsigned inc_suspend_count() {\n-    assert(_lock->is_locked(), \"Must be\");\n-    assert(_suspend_count < UINT_MAX, \"Sanity\");\n-    return ++_suspend_count;\n-  }\n-\n-  unsigned dec_suspend_count() {\n-    assert(_lock->is_locked(), \"Must be\");\n-    assert(_suspend_count != 0, \"Sanity\");\n-    return --_suspend_count;\n-  }\n-\n-  bool stopped() const {\n-    assert(_lock->is_locked(), \"Must be\");\n-    return _stop;\n-  }\n-\n-  bool at_or_nearing_safepoint() const {\n-    return\n-        SafepointSynchronize::is_at_safepoint() ||\n-        SafepointSynchronize::is_synchronizing();\n-  }\n-  static constexpr int safepoint_poll_ms = 250;\n-\n-  static int64_t now() { return os::javaTimeMillis(); }\n-\n-  void run() override {\n-    log_info(trim)(\"NativeTrimmer start.\");\n-    run_inner();\n-    log_info(trim)(\"NativeTrimmer stop.\");\n-  }\n-\n-  void run_inner() {\n-\n-    bool trim_result = false;\n-\n-    for (;;) {\n-\n-      int64_t tnow = now();\n-      int64_t next_trim_time = tnow + TrimNativeHeapInterval;\n-\n-      {\n-        MonitorLocker ml(_lock, Mutex::_no_safepoint_check_flag);\n-\n-        if (trim_result) {\n-          _num_trims_performed++;\n-        }\n-\n-        do { \/\/ handle spurious wakeups\n-\n-          if (_stop) {\n-            return;\n-          }\n-\n-          if (suspended()) {\n-            ml.wait(0);\n-          } else if (next_trim_time > tnow) {\n-            ml.wait(next_trim_time - tnow);\n-          } else if (at_or_nearing_safepoint()) {\n-            ml.wait(safepoint_poll_ms);\n-          }\n-\n-          if (_stop) {\n-            return;\n-          }\n-\n-          tnow = now();\n-\n-        } while (at_or_nearing_safepoint() || suspended() || next_trim_time > tnow);\n-\n-      } \/\/ Lock scope\n-\n-      \/\/ 2 - Trim outside of lock protection.\n-      trim_result = execute_trim_and_log(tnow);\n-\n-    }\n-  }\n-\n-  \/\/ Execute the native trim, log results.\n-  bool execute_trim_and_log(int64_t tnow) const {\n-    assert(os::can_trim_native_heap(), \"Unexpected\");\n-    os::size_change_t sc;\n-    Ticks start = Ticks::now();\n-    log_debug(trim)(\"Trim native heap started...\");\n-    if (os::trim_native_heap(&sc)) {\n-      Tickspan trim_time = (Ticks::now() - start);\n-      if (sc.after != SIZE_MAX) {\n-        const size_t delta = sc.after < sc.before ? (sc.before - sc.after) : (sc.after - sc.before);\n-        const char sign = sc.after < sc.before ? '-' : '+';\n-        log_info(trim)(\"Trim native heap: RSS+Swap: \" PROPERFMT \"->\" PROPERFMT \" (%c\" PROPERFMT \"), %1.3fms\",\n-                           PROPERFMTARGS(sc.before), PROPERFMTARGS(sc.after), sign, PROPERFMTARGS(delta),\n-                           trim_time.seconds() * 1000);\n-        log_debug(trim)(\"Total trims: \" UINT64_FORMAT \".\", _num_trims_performed);\n-        return true;\n-      } else {\n-        log_info(trim)(\"Trim native heap (no details)\");\n-      }\n-    }\n-    return false;\n-  }\n-\n-public:\n-\n-  NativeTrimmerThread() :\n-    _lock(new (std::nothrow) PaddedMonitor(Mutex::nosafepoint, \"NativeTrimmer_lock\")),\n-    _stop(false),\n-    _suspend_count(0),\n-    _num_trims_performed(0)\n-  {\n-    set_name(\"Native Heap Trimmer\");\n-    if (os::create_thread(this, os::vm_thread)) {\n-      os::start_thread(this);\n-    }\n-  }\n-\n-  void suspend(const char* reason) {\n-    assert(TrimNativeHeap, \"Only call if enabled\");\n-    unsigned n = 0;\n-    {\n-      MonitorLocker ml(_lock, Mutex::_no_safepoint_check_flag);\n-      n = inc_suspend_count();\n-      \/\/ No need to wakeup trimmer\n-    }\n-    log_debug(trim)(\"NativeTrimmer pause (%s) (%u)\", reason, n);\n-  }\n-\n-  void resume(const char* reason) {\n-    assert(TrimNativeHeap, \"Only call if enabled\");\n-    unsigned n = 0;\n-    {\n-      MonitorLocker ml(_lock, Mutex::_no_safepoint_check_flag);\n-      n = dec_suspend_count();\n-      if (n == 0) {\n-        ml.notify_all(); \/\/ pause end\n-      }\n-    }\n-    log_debug(trim)(\"NativeTrimmer unpause (%s) (%u)\", reason, n);\n-  }\n-\n-  uint64_t num_trims_performed() const {\n-    MonitorLocker ml(_lock, Mutex::_no_safepoint_check_flag);\n-    return _num_trims_performed;\n-  }\n-\n-  void stop() {\n-    MonitorLocker ml(_lock, Mutex::_no_safepoint_check_flag);\n-    _stop = true;\n-    ml.notify_all();\n-  }\n-\n-}; \/\/ NativeTrimmer\n-\n-static NativeTrimmerThread* g_trimmer_thread = nullptr;\n-\n-\/\/\/ GCTrimNative outside facing methods\n-\n-void TrimNative::initialize() {\n-  if (TrimNativeHeap) {\n-    if (!os::can_trim_native_heap()) {\n-      FLAG_SET_ERGO(TrimNativeHeap, false);\n-      log_info(trim)(\"Native trim not supported on this platform.\");\n-      return;\n-    }\n-    g_trimmer_thread = new NativeTrimmerThread();\n-    log_info(trim)(\"Periodic native trim enabled (interval: %u ms)\", TrimNativeHeapInterval);\n-  }\n-}\n-\n-void TrimNative::cleanup() {\n-  if (g_trimmer_thread != nullptr) {\n-    g_trimmer_thread->stop();\n-  }\n-}\n-\n-void TrimNative::suspend_periodic_trim(const char* reason) {\n-  if (g_trimmer_thread != nullptr) {\n-    g_trimmer_thread->suspend(reason);\n-  }\n-}\n-\n-void TrimNative::resume_periodic_trim(const char* reason) {\n-  if (g_trimmer_thread != nullptr) {\n-    g_trimmer_thread->resume(reason);\n-  }\n-}\n-\n-uint64_t TrimNative::num_trims_performed() {\n-  if (g_trimmer_thread != nullptr) {\n-    return g_trimmer_thread->num_trims_performed();\n-  }\n-  return 0;\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/trimNative.cpp","additions":0,"deletions":246,"binary":false,"changes":246,"status":"deleted"},{"patch":"@@ -0,0 +1,220 @@\n+\/*\n+ * Copyright (c) 2023 SAP SE. All rights reserved.\n+ * Copyright (c) 2023 Red Hat Inc. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/globals.hpp\"\n+#include \"runtime\/globals_extension.hpp\"\n+#include \"runtime\/mutex.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n+#include \"runtime\/nonJavaThread.hpp\"\n+#include \"runtime\/os.inline.hpp\"\n+#include \"runtime\/safepoint.hpp\"\n+#include \"runtime\/trimNativeHeap.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+class NativeTrimmerThread : public NamedThread {\n+\n+  Monitor* const _lock;\n+  bool _stop;\n+  uint16_t _suspend_count;\n+\n+  \/\/ Statistics\n+  volatile uint64_t _num_trims_performed;\n+\n+  bool is_suspended() const {\n+    assert(_lock->is_locked(), \"Must be\");\n+    return _suspend_count > 0;\n+  }\n+\n+  unsigned inc_suspend_count() {\n+    assert(_lock->is_locked(), \"Must be\");\n+    assert(_suspend_count < UINT16_MAX, \"Sanity\");\n+    return ++_suspend_count;\n+  }\n+\n+  unsigned dec_suspend_count() {\n+    assert(_lock->is_locked(), \"Must be\");\n+    assert(_suspend_count != 0, \"Sanity\");\n+    return --_suspend_count;\n+  }\n+\n+  bool is_stopped() const {\n+    assert(_lock->is_locked(), \"Must be\");\n+    return _stop;\n+  }\n+\n+  bool at_or_nearing_safepoint() const {\n+    return SafepointSynchronize::is_at_safepoint() ||\n+        SafepointSynchronize::is_synchronizing();\n+  }\n+  static constexpr int safepoint_poll_ms = 250;\n+\n+  \/\/ in seconds\n+  static double now() { return os::elapsedTime(); }\n+  static double to_ms(double seconds) { return seconds * 1000.0; }\n+\n+  struct LogStartStop {\n+    void log(const char* s) { log_info(trimnh)(\"NativeTrimmer %s.\", s); }\n+    LogStartStop()  { log(\"start\"); }\n+    ~LogStartStop() { log(\"stop\"); }\n+  };\n+\n+  void run() override {\n+    LogStartStop logStartStop;\n+\n+    for (;;) {\n+      double tnow = now();\n+      const double interval_secs = (double)TrimNativeHeapInterval \/ 1000;\n+      double next_trim_time = tnow + interval_secs;\n+\n+      {\n+        MonitorLocker ml(_lock, Mutex::_no_safepoint_check_flag);\n+        if (_stop) return;\n+\n+        do { \/\/ handle spurious wakeups\n+          if (is_suspended()) {\n+            ml.wait(0); \/\/ infinite\n+          } else if (next_trim_time > tnow) {\n+            const int64_t wait_ms = MAX2(1.0, to_ms(next_trim_time - tnow));\n+            ml.wait(wait_ms);\n+          } else if (at_or_nearing_safepoint()) {\n+            ml.wait(safepoint_poll_ms);\n+          }\n+\n+          if (_stop) return;\n+\n+          tnow = now();\n+\n+        } while (at_or_nearing_safepoint() || is_suspended() || next_trim_time > tnow);\n+      } \/\/ Lock scope\n+\n+      \/\/ 2 - Trim outside of lock protection.\n+      execute_trim_and_log(tnow);\n+    } \/\/ end for(;;)\n+  }\n+\n+  \/\/ Execute the native trim, log results.\n+  void execute_trim_and_log(double t1) {\n+    assert(os::can_trim_native_heap(), \"Unexpected\");\n+    os::size_change_t sc;\n+    log_debug(trimnh)(\"Trim native heap started...\");\n+    if (os::trim_native_heap(&sc)) {\n+      double t2 = now();\n+      if (sc.after != SIZE_MAX) {\n+        const size_t delta = sc.after < sc.before ? (sc.before - sc.after) : (sc.after - sc.before);\n+        const char sign = sc.after < sc.before ? '-' : '+';\n+        log_info(trimnh)(\"Trim native heap: RSS+Swap: \" PROPERFMT \"->\" PROPERFMT \" (%c\" PROPERFMT \"), %1.3fms\",\n+                           PROPERFMTARGS(sc.before), PROPERFMTARGS(sc.after), sign, PROPERFMTARGS(delta),\n+                           to_ms(t2 - t1));\n+        Atomic::inc(&_num_trims_performed);\n+        log_debug(trimnh)(\"Total trims: \" UINT64_FORMAT \".\", Atomic::load(&_num_trims_performed));\n+      } else {\n+        log_info(trimnh)(\"Trim native heap: complete, no details, %1.3fms\", to_ms(t2 - t1));\n+      }\n+    }\n+  }\n+\n+public:\n+\n+  NativeTrimmerThread() :\n+    _lock(new (std::nothrow) PaddedMonitor(Mutex::nosafepoint, \"NativeTrimmer_lock\")),\n+    _stop(false),\n+    _suspend_count(0),\n+    _num_trims_performed(0)\n+  {\n+    set_name(\"Native Heap Trimmer\");\n+    if (os::create_thread(this, os::vm_thread)) {\n+      os::start_thread(this);\n+    }\n+  }\n+\n+  void suspend(const char* reason) {\n+    assert(TrimNativeHeap, \"Only call if enabled\");\n+    unsigned n = 0;\n+    {\n+      MonitorLocker ml(_lock, Mutex::_no_safepoint_check_flag);\n+      n = inc_suspend_count();\n+      \/\/ No need to wakeup trimmer\n+    }\n+    log_debug(trimnh)(\"NativeTrimmer pause for %s (%u suspend requests)\", reason, n);\n+  }\n+\n+  void resume(const char* reason) {\n+    assert(TrimNativeHeap, \"Only call if enabled\");\n+    unsigned n = 0;\n+    {\n+      MonitorLocker ml(_lock, Mutex::_no_safepoint_check_flag);\n+      n = dec_suspend_count();\n+      if (n == 0) {\n+        ml.notify_all(); \/\/ pause end\n+      }\n+    }\n+    log_debug(trimnh)(\"NativeTrimmer unpause for %s (%u suspend requests)\", reason, n);\n+  }\n+\n+  void stop() {\n+    MonitorLocker ml(_lock, Mutex::_no_safepoint_check_flag);\n+    _stop = true;\n+    ml.notify_all();\n+  }\n+\n+}; \/\/ NativeTrimmer\n+\n+static NativeTrimmerThread* g_trimmer_thread = nullptr;\n+\n+void NativeHeapTrimmer::initialize() {\n+  assert(g_trimmer_thread == nullptr, \"Only once\");\n+  if (TrimNativeHeap) {\n+    if (!os::can_trim_native_heap()) {\n+      FLAG_SET_ERGO(TrimNativeHeap, false);\n+      log_info(trimnh)(\"Native trim not supported on this platform.\");\n+      return;\n+    }\n+    g_trimmer_thread = new NativeTrimmerThread();\n+    log_info(trimnh)(\"Periodic native trim enabled (interval: %u ms)\", TrimNativeHeapInterval);\n+  }\n+}\n+\n+void NativeHeapTrimmer::cleanup() {\n+  if (g_trimmer_thread != nullptr) {\n+    g_trimmer_thread->stop();\n+  }\n+}\n+\n+void NativeHeapTrimmer::suspend_periodic_trim(const char* reason) {\n+  if (g_trimmer_thread != nullptr) {\n+    g_trimmer_thread->suspend(reason);\n+  }\n+}\n+\n+void NativeHeapTrimmer::resume_periodic_trim(const char* reason) {\n+  if (g_trimmer_thread != nullptr) {\n+    g_trimmer_thread->resume(reason);\n+  }\n+}\n","filename":"src\/hotspot\/share\/runtime\/trimNativeHeap.cpp","additions":220,"deletions":0,"binary":false,"changes":220,"status":"added"},{"patch":"@@ -27,2 +27,2 @@\n-#ifndef SHARE_GC_SHARED_TRIMNATIVE_HPP\n-#define SHARE_GC_SHARED_TRIMNATIVE_HPP\n+#ifndef SHARE_RUNTIME_TRIMNATIVEHEAP_HPP\n+#define SHARE_RUNTIME_TRIMNATIVEHEAP_HPP\n@@ -33,1 +33,1 @@\n-class TrimNative : public AllStatic {\n+class NativeHeapTrimmer : public AllStatic {\n@@ -65,1 +65,1 @@\n-#endif \/\/ SHARE_GC_SHARED_TRIMNATIVE_HPP\n+#endif \/\/ SHARE_RUNTIME_TRIMNATIVEHEAP_HPP\n","filename":"src\/hotspot\/share\/runtime\/trimNativeHeap.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"previous_filename":"src\/hotspot\/share\/runtime\/trimNative.hpp","status":"renamed"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2023 Red Hat Inc. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"runtime\/trimNativeHeap.hpp\"\n+#include \"unittest.hpp\"\n+\n+TEST_VM(TrimNative, SuspendMark) {\n+\n+  if (!TrimNativeHeap) {\n+    return;\n+  }\n+\n+  \/\/ Try recursive pausing\n+  {\n+    NativeHeapTrimmer::SuspendMark sm1(\"Test1\");\n+    {\n+      NativeHeapTrimmer::SuspendMark sm2(\"Test2\");\n+      {\n+        NativeHeapTrimmer::SuspendMark sm3(\"Test3\");\n+      }\n+    }\n+  }\n+}\n","filename":"test\/hotspot\/gtest\/runtime\/test_trim_native.cpp","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -28,1 +28,1 @@\n- * @test\n+ * @test id=trimNative\n@@ -32,1 +32,13 @@\n- * @run driver TestTrimNative test\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI TestTrimNative test\n+ *\/\n+\n+\/*\n+ * @test id=trimNativeHighInterval\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI TestTrimNative testWithHighTrimInterval\n@@ -37,1 +49,1 @@\n- * @summary Test that -GCTrimNative disables the feature\n+ * @summary Test that trimming is disabled by default\n@@ -41,1 +53,3 @@\n- * @run driver TestTrimNative testOffByDefault\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI TestTrimNative testOffByDefault\n@@ -46,1 +60,1 @@\n- * @summary Test that GCTrimNative is off by default\n+ * @summary Test that trimming can be disabled explicitly\n@@ -50,1 +64,3 @@\n- * @run driver TestTrimNative testOffExplicit\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI TestTrimNative testOffExplicit\n@@ -55,1 +71,1 @@\n- * @summary Test that GCTrimNative is off on unsupportive platforms\n+ * @summary Test that trimming is correctly reported as unavailable if unavailable\n@@ -59,1 +75,3 @@\n- * @run driver TestTrimNative testOffOnNonCompliantPlatforms\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI TestTrimNative testOffOnNonCompliantPlatforms\n@@ -62,1 +80,0 @@\n-import jdk.internal.misc.Unsafe;\n@@ -68,2 +85,0 @@\n-import java.lang.reflect.Array;\n-import java.rmi.RemoteException;\n@@ -74,0 +89,2 @@\n+import jdk.test.whitebox.WhiteBox;\n+\n@@ -99,0 +116,2 @@\n+        allOptions.add(\"-XX:+WhiteBoxAPI\");\n+        allOptions.add(\"-Xbootclasspath\/a:.\");\n@@ -100,1 +119,1 @@\n-        allOptions.add(\"-Xlog:trim=debug\");\n+        allOptions.add(\"-Xlog:trimnh=debug\");\n@@ -102,1 +121,1 @@\n-        allOptions.add(TestTrimNative.class.getName());\n+        allOptions.add(TestTrimNative.Tester.class.getName());\n@@ -138,1 +157,1 @@\n-        Pattern pat = Pattern.compile(\".*\\\\[trim\\\\] Trim native heap: RSS\\\\+Swap: (\\\\d+)([BKMG])->(\\\\d+)([BKMG]).*\");\n+        Pattern pat = Pattern.compile(\".*\\\\[trimnh\\\\] Trim native heap: RSS\\\\+Swap: (\\\\d+)([BKMG])->(\\\\d+)([BKMG]).*\");\n@@ -161,14 +180,16 @@\n-        \/\/ This is very fuzzy. Test program malloced X bytes, then freed them again and trimmed. But the log line prints change in RSS.\n-        \/\/ Which, of course, is influenced by a lot of other factors. But we expect to see *some* reasonable reduction in RSS\n-        \/\/ due to trimming.\n-        float fudge = 0.5f;\n-        \/\/ On ppc, we see a vastly diminished return (~3M reduction instead of ~200), I suspect because of the underlying\n-        \/\/ 64k pages lead to a different geometry. Manual tests with larger reclaim sizes show that autotrim works. For\n-        \/\/ this test, we just reduce the fudge factor.\n-        if (Platform.isPPC()) { \/\/ le and be both\n-            fudge = 0.01f;\n-        }\n-        long expectedMinimalReduction = (long) (totalAllocationsSize * fudge);\n-        if (rssReductionTotal < expectedMinimalReduction) {\n-            throw new RuntimeException(\"We did not see the expected RSS reduction in the UL log. Expected (with fudge)\" +\n-                    \" to see at least a combined reduction of \" + expectedMinimalReduction + \".\");\n+        if (maxTrimsExpected > 0) {\n+            \/\/ This is very fuzzy. Test program malloced X bytes, then freed them again and trimmed. But the log line prints change in RSS.\n+            \/\/ Which, of course, is influenced by a lot of other factors. But we expect to see *some* reasonable reduction in RSS\n+            \/\/ due to trimming.\n+            float fudge = 0.5f;\n+            \/\/ On ppc, we see a vastly diminished return (~3M reduction instead of ~200), I suspect because of the underlying\n+            \/\/ 64k pages lead to a different geometry. Manual tests with larger reclaim sizes show that autotrim works. For\n+            \/\/ this test, we just reduce the fudge factor.\n+            if (Platform.isPPC()) { \/\/ le and be both\n+                fudge = 0.01f;\n+            }\n+            long expectedMinimalReduction = (long) (totalAllocationsSize * fudge);\n+            if (rssReductionTotal < expectedMinimalReduction) {\n+                throw new RuntimeException(\"We did not see the expected RSS reduction in the UL log. Expected (with fudge)\" +\n+                        \" to see at least a combined reduction of \" + expectedMinimalReduction + \".\");\n+            }\n@@ -178,67 +199,2 @@\n-    static private final void runTest(String[] VMargs) throws IOException {\n-        long trimInterval = 500; \/\/ twice per second\n-        long ms1 = System.currentTimeMillis();\n-        OutputAnalyzer output = runTestWithOptions (\n-                new String[] { \"-XX:+UnlockExperimentalVMOptions\",\n-                               \"-XX:+TrimNativeHeap\",\n-                               \"-XX:TrimNativeHeapInterval=\" + trimInterval },\n-                new String[] { \"RUN\", \"5000\" }\n-        );\n-        long ms2 = System.currentTimeMillis();\n-        long runtime_ms = ms2 - ms1;\n-\n-        checkExpectedLogMessages(output, true, 500);\n-\n-        long maxTrimsExpected = runtime_ms \/ trimInterval;\n-        long minTrimsExpected = maxTrimsExpected \/ 2;\n-        parseOutputAndLookForNegativeTrim(output, (int)minTrimsExpected, (int)maxTrimsExpected);\n-    }\n-\n-    \/\/ Test that a high trim interval effectively disables trimming\n-    static private final void testHighTrimInterval() throws IOException {\n-        OutputAnalyzer output = runTestWithOptions (\n-                new String[] { \"-XX:+UnlockExperimentalVMOptions\",\n-                               \"-XX:+TrimNativeHeap\",\n-                               \"-XX:TrimNativeHeapInterval=\" + Integer.MAX_VALUE },\n-                new String[] { \"RUN\", \"5000\" }\n-        );\n-        checkExpectedLogMessages(output, true, Integer.MAX_VALUE);\n-        parseOutputAndLookForNegativeTrim(output,0, \/*  minTrimsExpected *\/ 0  \/*  maxTrimsExpected *\/);\n-    }\n-\n-    \/\/ Test that trim-native gets disabled on platforms that don't support it.\n-    static private final void testOffOnNonCompliantPlatforms() throws IOException {\n-        OutputAnalyzer output = runTestWithOptions (\n-                new String[] { \"-XX:+UnlockExperimentalVMOptions\",\n-                               \"-XX:+TrimNativeHeap\" },\n-                new String[] { \"RUN\", \"0\" }\n-        );\n-        checkExpectedLogMessages(output, false, 0);\n-        output.shouldContain(\"Native trim not supported on this platform\");\n-    }\n-\n-    \/\/ Test trim native is disabled if explicitly switched off\n-    static private final void testOffExplicit() throws IOException {\n-        OutputAnalyzer output = runTestWithOptions (\n-                new String[] { \"-XX:+UnlockExperimentalVMOptions\",\n-                               \"-XX:-TrimNativeHeap\"\n-                },\n-                new String[] { \"RUN\", \"0\" }\n-                );\n-        checkExpectedLogMessages(output, false, 0);\n-    }\n-\n-    \/\/ Test trim native is disabled if explicitly switched off\n-    static private final void testOffByDefault() throws IOException {\n-        OutputAnalyzer output = runTestWithOptions (null, new String[] { \"RUN\", \"0\" } );\n-        checkExpectedLogMessages(output, false, 0);\n-    }\n-\n-    public static void main(String[] args) throws Exception {\n-\n-        if (args.length == 0) {\n-            throw new RuntimeException(\"Argument error\");\n-        }\n-\n-        if (args[0].equals(\"RUN\")) {\n-\n+    static class Tester {\n+        public static void main(String[] args) throws Exception {\n@@ -246,0 +202,1 @@\n+            WhiteBox wb = WhiteBox.getWhiteBox();\n@@ -247,3 +204,2 @@\n-                ptrs[i] = Unsafe.getUnsafe().allocateMemory(szAllocations);\n-                Unsafe.getUnsafe().putByte(ptrs[i], (byte)0);\n-                Unsafe.getUnsafe().putByte(ptrs[i] + szAllocations \/ 2, (byte)0);\n+                ptrs[i] = wb.NMTMalloc(szAllocations);\n+                wb.preTouchMemory(ptrs[i], szAllocations);\n@@ -252,1 +208,1 @@\n-                Unsafe.getUnsafe().freeMemory(ptrs[i]);\n+                wb.NMTFree(ptrs[i]);\n@@ -264,0 +220,2 @@\n+        }\n+    }\n@@ -265,1 +223,63 @@\n-            return;\n+    public static void main(String[] args) throws Exception {\n+\n+        if (args.length == 0) {\n+            throw new RuntimeException(\"Argument error\");\n+        }\n+\n+        switch (args[0]) {\n+            case \"test\": {\n+                long trimInterval = 500; \/\/ twice per second\n+                long ms1 = System.currentTimeMillis();\n+                OutputAnalyzer output = runTestWithOptions(\n+                        new String[]{\"-XX:+UnlockExperimentalVMOptions\",\n+                                \"-XX:+TrimNativeHeap\",\n+                                \"-XX:TrimNativeHeapInterval=\" + trimInterval},\n+                        new String[]{\"RUN\", \"5000\"}\n+                );\n+                long ms2 = System.currentTimeMillis();\n+                long runtime_ms = ms2 - ms1;\n+\n+                checkExpectedLogMessages(output, true, 500);\n+\n+                long maxTrimsExpected = runtime_ms \/ trimInterval;\n+                long minTrimsExpected = maxTrimsExpected \/ 2;\n+                parseOutputAndLookForNegativeTrim(output, (int) minTrimsExpected, (int) maxTrimsExpected);\n+            } break;\n+\n+            case \"testWithHighTrimInterval\": {\n+                OutputAnalyzer output = runTestWithOptions(\n+                        new String[]{\"-XX:+UnlockExperimentalVMOptions\", \"-XX:+TrimNativeHeap\", \"-XX:TrimNativeHeapInterval=\" + Integer.MAX_VALUE},\n+                        new String[]{\"RUN\", \"5000\"}\n+                );\n+                checkExpectedLogMessages(output, true, Integer.MAX_VALUE);\n+                \/\/ We should not see any trims since the interval would prevent them\n+                parseOutputAndLookForNegativeTrim(output, 0, 0);\n+            } break;\n+\n+            case \"testOffOnNonCompliantPlatforms\": {\n+                OutputAnalyzer output = runTestWithOptions(\n+                        new String[]{\"-XX:+UnlockExperimentalVMOptions\", \"-XX:+TrimNativeHeap\"},\n+                        new String[]{\"RUN\", \"0\"}\n+                );\n+                checkExpectedLogMessages(output, false, 0);\n+                parseOutputAndLookForNegativeTrim(output, 0, 0);\n+                output.shouldContain(\"Native trim not supported on this platform\");\n+            } break;\n+\n+            case \"testOffExplicit\": {\n+                OutputAnalyzer output = runTestWithOptions(\n+                        new String[]{\"-XX:+UnlockExperimentalVMOptions\", \"-XX:-TrimNativeHeap\"},\n+                        new String[]{\"RUN\", \"0\"}\n+                );\n+                checkExpectedLogMessages(output, false, 0);\n+                parseOutputAndLookForNegativeTrim(output, 0, 0);\n+            } break;\n+\n+            case \"testOffByDefault\": {\n+                OutputAnalyzer output = runTestWithOptions(null, new String[]{\"RUN\", \"0\"});\n+                checkExpectedLogMessages(output, false, 0);\n+                parseOutputAndLookForNegativeTrim(output, 0, 0);\n+            } break;\n+\n+            default:\n+                throw new RuntimeException(\"Invalid test \" + args[0]);\n@@ -267,10 +287,0 @@\n-        } else if (args[0].equals(\"test\")) {\n-            runTest(Arrays.copyOfRange(args, 1, args.length));\n-        } else if (args[0].equals(\"testOffOnNonCompliantPlatforms\")) {\n-            testOffOnNonCompliantPlatforms();\n-        } else if (args[0].equals(\"testOffExplicit\")) {\n-            testOffExplicit();\n-        } else if (args[0].equals(\"testOffByDefault\")) {\n-            testOffByDefault();\n-        } else {\n-            throw new RuntimeException(\"Invalid test \" + args[0]);\n","filename":"test\/hotspot\/jtreg\/runtime\/os\/TestTrimNative.java","additions":120,"deletions":110,"binary":false,"changes":230,"status":"modified"},{"patch":"@@ -767,0 +767,2 @@\n+\n+  public native void preTouchMemory(long addr, long size);\n","filename":"test\/lib\/jdk\/test\/whitebox\/WhiteBox.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}