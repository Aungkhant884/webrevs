{"files":[{"patch":"@@ -3080,12 +3080,0 @@\n-     * <p> As another variation of behavior, an in-place conversion\n-     * can incorporate an expanding or contracting conversion, while\n-     * retaining the same lane size between input and output.\n-     *\n-     * In the case of a contraction, the lane value is first converted\n-     * to the smaller value, and then zero-padded (as if by a subsequent\n-     * reinterpretation) before storing into the output lane.\n-     *\n-     * In the case of an expansion, the lane value is first truncated\n-     * to the smaller value (as if by an initial reinterpretation),\n-     * and then converted before storing into the output lane.\n-     *\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Vector.java","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -398,36 +398,0 @@\n-        \/**\n-         * An in-place version of a narrowing\n-         * conversion between two types.\n-         * The output of the conversion must be no larger\n-         * than the type {@code E}.\n-         * Any unused lane bits are ignored and\n-         * overwritten by zero bits (not a copied sign bit).\n-         * @param <E> the domain and range type (boxed version of a lane type)\n-         * @param conv the narrowing conversion to treat in-place\n-         * @return a Java narrowing conversion,\n-         *          stored back to the original lane of type {@code E}\n-         *\/\n-        @ForceInline\n-        static <E> Conversion<E,E> ofNarrowing(Conversion<E,?> conv) {\n-            Class<E> lt = conv.domainType();\n-            return ConversionImpl.ofInplace((ConversionImpl<?,?>) conv, false).check(lt, lt);\n-        }\n-\n-        \/**\n-         * An in-place version of a widening\n-         * conversion between two types.\n-         * The input of the conversion must be no larger\n-         * than the type {@code E}.\n-         * Any unused lane bits are ignored and\n-         * overwritten by the result.\n-         * @param <E> the domain and range type (boxed version of a lane type)\n-         * @param conv the widening conversion to treat in-place\n-         * @return a Java widening conversion,\n-         *          loading its input from same lane of type {@code E}\n-         *\/\n-        @ForceInline\n-        static <E> Conversion<E,E> ofWidening(Conversion<?,E> conv) {\n-            Class<E> lt = conv.rangeType();\n-            return ConversionImpl.ofInplace((ConversionImpl<?,?>) conv, true).check(lt, lt);\n-        }\n-\n@@ -470,2 +434,1 @@\n-        VO_KIND_BITWISE            = 0x100,\n-        VO_KIND_INPLACE            = 0x200;\n+        VO_KIND_BITWISE            = 0x100;\n@@ -669,52 +632,0 @@\n-    \/** In-place narrow {@code doubleVal} to {@code (byte)doubleVal} inside double. *\/\n-    public static final Conversion<Double,Double> INPLACE_D2B = convert(\"INPLACE_D2B\", 'N', double.class, double.class, VO_KIND_INPLACE + 0x78, VO_ALL);\n-    \/** In-place narrow {@code doubleVal} to {@code (float)doubleVal} inside double. *\/\n-    public static final Conversion<Double,Double> INPLACE_D2F = convert(\"INPLACE_D2F\", 'N', double.class, double.class, VO_KIND_INPLACE + 0x76, VO_ALL);\n-    \/** In-place narrow {@code doubleVal} to {@code (int)doubleVal} inside double. *\/\n-    public static final Conversion<Double,Double> INPLACE_D2I = convert(\"INPLACE_D2I\", 'N', double.class, double.class, VO_KIND_INPLACE + 0x7a, VO_ALL);\n-    \/** In-place narrow {@code doubleVal} to {@code (short)doubleVal} inside double. *\/\n-    public static final Conversion<Double,Double> INPLACE_D2S = convert(\"INPLACE_D2S\", 'N', double.class, double.class, VO_KIND_INPLACE + 0x79, VO_ALL);\n-    \/** In-place narrow {@code floatVal} to {@code (byte)floatVal} inside float. *\/\n-    public static final Conversion<Float,Float> INPLACE_F2B = convert(\"INPLACE_F2B\", 'N', float.class, float.class, VO_KIND_INPLACE + 0x68, VO_ALL);\n-    \/** In-place narrow {@code floatVal} to {@code (short)floatVal} inside float. *\/\n-    public static final Conversion<Float,Float> INPLACE_F2S = convert(\"INPLACE_F2S\", 'N', float.class, float.class, VO_KIND_INPLACE + 0x69, VO_ALL);\n-    \/** In-place narrow {@code intVal} to {@code (byte)intVal} inside int. *\/\n-    public static final Conversion<Integer,Integer> INPLACE_I2B = convert(\"INPLACE_I2B\", 'N', int.class, int.class, VO_KIND_INPLACE + 0xa8, VO_ALL);\n-    \/** In-place narrow {@code intVal} to {@code (short)intVal} inside int. *\/\n-    public static final Conversion<Integer,Integer> INPLACE_I2S = convert(\"INPLACE_I2S\", 'N', int.class, int.class, VO_KIND_INPLACE + 0xa9, VO_ALL);\n-    \/** In-place narrow {@code longVal} to {@code (byte)longVal} inside long. *\/\n-    public static final Conversion<Long,Long> INPLACE_L2B = convert(\"INPLACE_L2B\", 'N', long.class, long.class, VO_KIND_INPLACE + 0xb8, VO_ALL);\n-    \/** In-place narrow {@code longVal} to {@code (float)longVal} inside long. *\/\n-    public static final Conversion<Long,Long> INPLACE_L2F = convert(\"INPLACE_L2F\", 'N', long.class, long.class, VO_KIND_INPLACE + 0xb6, VO_ALL);\n-    \/** In-place narrow {@code longVal} to {@code (int)longVal} inside long. *\/\n-    public static final Conversion<Long,Long> INPLACE_L2I = convert(\"INPLACE_L2I\", 'N', long.class, long.class, VO_KIND_INPLACE + 0xba, VO_ALL);\n-    \/** In-place narrow {@code longVal} to {@code (short)longVal} inside long. *\/\n-    public static final Conversion<Long,Long> INPLACE_L2S = convert(\"INPLACE_L2S\", 'N', long.class, long.class, VO_KIND_INPLACE + 0xb9, VO_ALL);\n-    \/** In-place narrow {@code shortVal} to {@code (byte)shortVal} inside short. *\/\n-    public static final Conversion<Short,Short> INPLACE_S2B = convert(\"INPLACE_S2B\", 'N', short.class, short.class, VO_KIND_INPLACE + 0x98, VO_ALL);\n-    \/** In-place widen {@code byteVal} inside double to {@code (double)byteVal}. *\/\n-    public static final Conversion<Double,Double> INPLACE_B2D = convert(\"INPLACE_B2D\", 'W', double.class, double.class, VO_KIND_INPLACE + 0x87, VO_ALL);\n-    \/** In-place widen {@code byteVal} inside float to {@code (float)byteVal}. *\/\n-    public static final Conversion<Float,Float> INPLACE_B2F = convert(\"INPLACE_B2F\", 'W', float.class, float.class, VO_KIND_INPLACE + 0x86, VO_ALL);\n-    \/** In-place widen {@code byteVal} inside int to {@code (int)byteVal}. *\/\n-    public static final Conversion<Integer,Integer> INPLACE_B2I = convert(\"INPLACE_B2I\", 'W', int.class, int.class, VO_KIND_INPLACE + 0x8a, VO_ALL);\n-    \/** In-place widen {@code byteVal} inside long to {@code (long)byteVal}. *\/\n-    public static final Conversion<Long,Long> INPLACE_B2L = convert(\"INPLACE_B2L\", 'W', long.class, long.class, VO_KIND_INPLACE + 0x8b, VO_ALL);\n-    \/** In-place widen {@code byteVal} inside short to {@code (short)byteVal}. *\/\n-    public static final Conversion<Short,Short> INPLACE_B2S = convert(\"INPLACE_B2S\", 'W', short.class, short.class, VO_KIND_INPLACE + 0x89, VO_ALL);\n-    \/** In-place widen {@code floatVal} inside double to {@code (double)floatVal}. *\/\n-    public static final Conversion<Double,Double> INPLACE_F2D = convert(\"INPLACE_F2D\", 'W', double.class, double.class, VO_KIND_INPLACE + 0x67, VO_ALL);\n-    \/** In-place widen {@code floatVal} inside long to {@code (long)floatVal}. *\/\n-    public static final Conversion<Long,Long> INPLACE_F2L = convert(\"INPLACE_F2L\", 'W', long.class, long.class, VO_KIND_INPLACE + 0x6b, VO_ALL);\n-    \/** In-place widen {@code intVal} inside double to {@code (double)intVal}. *\/\n-    public static final Conversion<Double,Double> INPLACE_I2D = convert(\"INPLACE_I2D\", 'W', double.class, double.class, VO_KIND_INPLACE + 0xa7, VO_ALL);\n-    \/** In-place widen {@code intVal} inside long to {@code (long)intVal}. *\/\n-    public static final Conversion<Long,Long> INPLACE_I2L = convert(\"INPLACE_I2L\", 'W', long.class, long.class, VO_KIND_INPLACE + 0xab, VO_ALL);\n-    \/** In-place widen {@code shortVal} inside double to {@code (double)shortVal}. *\/\n-    public static final Conversion<Double,Double> INPLACE_S2D = convert(\"INPLACE_S2D\", 'W', double.class, double.class, VO_KIND_INPLACE + 0x97, VO_ALL);\n-    \/** In-place widen {@code shortVal} inside float to {@code (float)shortVal}. *\/\n-    public static final Conversion<Float,Float> INPLACE_S2F = convert(\"INPLACE_S2F\", 'W', float.class, float.class, VO_KIND_INPLACE + 0x96, VO_ALL);\n-    \/** In-place widen {@code shortVal} inside int to {@code (int)shortVal}. *\/\n-    public static final Conversion<Integer,Integer> INPLACE_S2I = convert(\"INPLACE_S2I\", 'W', int.class, int.class, VO_KIND_INPLACE + 0x9a, VO_ALL);\n-    \/** In-place widen {@code shortVal} inside long to {@code (long)shortVal}. *\/\n-    public static final Conversion<Long,Long> INPLACE_S2L = convert(\"INPLACE_S2L\", 'W', long.class, long.class, VO_KIND_INPLACE + 0x9b, VO_ALL);\n@@ -799,3 +710,0 @@\n-            } else {\n-                \/\/ only the widening or narrowing guys specify their own opcode dom\/ran\n-                assert(dom == ran && \"WN\".indexOf(kind) >= 0);\n@@ -1035,13 +943,0 @@\n-        static ConversionImpl<?,?> ofInplace(ConversionImpl<?,?> conv,\n-                                             boolean widening) {\n-            int domSize = conv.dom.elementSize;\n-            int ranSize = conv.ran.elementSize;\n-            if (domSize >= ranSize && widening)\n-                throw new IllegalArgumentException(conv + \": must be a widening conversion\");\n-            if (domSize <= ranSize && !widening)\n-                throw new IllegalArgumentException(conv + \": must be a narrowing conversion\");\n-            if (conv.kind != 'C')\n-                throw new IllegalArgumentException(conv + \": must be a standard Java conversion\");\n-            char kind = (widening ? 'W' : 'N');\n-            return findConv(kind, conv.dom, conv.ran);\n-        }\n@@ -1091,10 +986,0 @@\n-            case 'W':\n-                name = \"INPLACE_\"+a2b(dom, ran);\n-                opCode += VO_KIND_INPLACE;\n-                domType = ranType;  \/\/ slice narrow domain from range\n-                break;\n-            case 'N':\n-                name = \"INPLACE_\"+a2b(dom, ran);\n-                opCode += VO_KIND_INPLACE;\n-                ranType = domType;  \/\/ zero-fill narrow range\n-                break;\n@@ -1187,1 +1072,1 @@\n-                    for (int i = 0; i <= 2; i++) {\n+                    for (int i = 0; i <= 1; i++) {\n@@ -1190,3 +1075,1 @@\n-                            c = ((i == 0) ? ofCast(l1, l2) :\n-                                 (i == 1) ? ofReinterpret(l1, l2) :\n-                                 ofInplace(ofCast(l1, l2), (l1.elementSize < l2.elementSize)));\n+                            c = ((i == 0) ? ofCast(l1, l2) : ofReinterpret(l1, l2));\n@@ -1209,1 +1092,0 @@\n-                            case VO_KIND_INPLACE: opcs = \"VO_KIND_INPLACE\"; break;\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/VectorOperators.java","additions":3,"deletions":121,"binary":false,"changes":124,"status":"modified"}]}