{"files":[{"patch":"@@ -37,0 +37,1 @@\n+#include \"gc\/shared\/pretouchTask.hpp\"\n@@ -274,6 +275,29 @@\n-    MutexLocker x(FreeList_lock, Mutex::_no_safepoint_check_flag);\n-    result = old_gc_alloc_region()->attempt_allocation_locked(min_word_size,\n-                                                              desired_word_size,\n-                                                              actual_word_size);\n-    if (result == NULL) {\n-      set_old_full();\n+    if (UseMultithreadedPretouchForOldGen) {\n+      bool is_locked = false;\n+      PretouchTaskCoordinator *task_coordinator = PretouchTaskCoordinator::get_task_coordinator();\n+      while (true) {\n+        is_locked = FreeList_lock->try_lock();\n+        if (is_locked) {\n+          task_coordinator->release_set_task_notready();\n+          result = old_gc_alloc_region()->attempt_allocation_locked(min_word_size,\n+                                                                desired_word_size,\n+                                                                actual_word_size);\n+          task_coordinator->release_set_task_done();\n+          if (result == NULL) {\n+            set_old_full();\n+          }\n+          FreeList_lock->unlock();\n+          break;\n+        } else {\n+          \/\/ Lets help expanding thread to pretouch the memory.\n+          task_coordinator->worker_wait_for_task();\n+        }\n+      }\n+    } else {\n+      MutexLocker x(FreeList_lock, Mutex::_no_safepoint_check_flag);\n+      result = old_gc_alloc_region()->attempt_allocation_locked(min_word_size,\n+                                                                desired_word_size,\n+                                                                actual_word_size);\n+      if (result == NULL) {\n+        set_old_full();\n+      }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Allocator.cpp","additions":30,"deletions":6,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"gc\/shared\/pretouchTask.hpp\"\n@@ -185,9 +186,35 @@\n-    MutexLocker x(ExpandHeap_lock);\n-    \/\/ Avoid \"expand storms\" by rechecking available space after obtaining\n-    \/\/ the lock, because another thread may have already made sufficient\n-    \/\/ space available.  If insufficient space available, that will remain\n-    \/\/ true until we expand, since we have the lock.  Other threads may take\n-    \/\/ the space we need before we can allocate it, regardless of whether we\n-    \/\/ expand.  That's okay, we'll just try expanding again.\n-    if (object_space()->needs_expand(word_size)) {\n-      result = expand(word_size*HeapWordSize);\n+    bool is_locked = false;\n+    PretouchTaskCoordinator *task_coordinator = PretouchTaskCoordinator::get_task_coordinator();\n+    while(true) {\n+      if (UseMultithreadedPretouchForOldGen) {\n+        is_locked = ExpandHeap_lock->try_lock();\n+      } else {\n+        ExpandHeap_lock->lock();\n+        is_locked = true;\n+      }\n+      \/\/ Avoid \"expand storms\" by rechecking available space after obtaining\n+      \/\/ the lock, because another thread may have already made sufficient\n+      \/\/ space available.  If insufficient space available, that will remain\n+      \/\/ true until we expand, since we have the lock.  Other threads may take\n+      \/\/ the space we need before we can allocate it, regardless of whether we\n+      \/\/ expand.  That's okay, we'll just try expanding again.\n+      \/\/\n+      \/\/ Todo:\n+      \/\/ Thread which holds the lock can expand once for all the threads and\n+      \/\/ this will be win-win for all the threads.\n+      if (is_locked) {\n+        if (object_space()->needs_expand(word_size)) {\n+          \/\/ Marking not ready makes other threads to spin in loop.\n+          task_coordinator->release_set_task_notready();\n+          result = expand(word_size*HeapWordSize);\n+          task_coordinator->release_set_task_done();\n+        }\n+\n+        assert (task_coordinator->is_task_done_acquire(), \"Task should be done at this point\");\n+        ExpandHeap_lock->unlock();\n+        break;\n+\n+      } else {\n+        \/\/ Lets help expanding thread to pretouch the memory.\n+        task_coordinator->worker_wait_for_task();\n+      }\n@@ -196,0 +223,1 @@\n+\n","filename":"src\/hotspot\/share\/gc\/parallel\/psOldGen.cpp","additions":37,"deletions":9,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -199,0 +199,3 @@\n+  product(bool, UseMultithreadedPretouchForOldGen, false,                   \\\n+          \"Oldgen expands during promotional failure and pages are touched\" \\\n+          \"with single thread. This option makes it multi-threaded\" )       \\\n","filename":"src\/hotspot\/share\/gc\/shared\/gc_globals.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,0 +31,5 @@\n+#include \"runtime\/nonJavaThread.hpp\"\n+#include \"utilities\/ticks.hpp\"\n+\n+PretouchTaskCoordinator* PretouchTaskCoordinator::_task_coordinator = NULL;\n+uint PretouchTaskCoordinator::_object_creation = 0;\n@@ -66,2 +71,3 @@\n-void PretouchTask::pretouch(const char* task_name, char* start_address, char* end_address,\n-                            size_t page_size, WorkGang* pretouch_gang) {\n+\n+void PretouchTask::setup_chunk_size_and_page_size(size_t& chunk_size, size_t& page_size)\n+{\n@@ -70,1 +76,1 @@\n-  size_t chunk_size = MAX2(PretouchTask::chunk_size(), page_size);\n+  chunk_size = MAX2(PretouchTask::chunk_size(), page_size);\n@@ -76,0 +82,6 @@\n+}\n+\n+void PretouchTask::pretouch(const char* task_name, char* start_address, char* end_address,\n+                            size_t page_size, WorkGang* pretouch_gang) {\n+  size_t chunk_size = 0;\n+  setup_chunk_size_and_page_size(chunk_size, page_size);\n@@ -90,1 +102,0 @@\n-\n@@ -93,3 +104,104 @@\n-    log_debug(gc, heap)(\"Running %s pre-touching \" SIZE_FORMAT \"B.\",\n-                        task.name(), total_bytes);\n-    task.work(0);\n+\n+    Ticks start = Ticks::now();\n+    if (UseMultithreadedPretouchForOldGen) {\n+      PretouchTaskCoordinator::coordinate_and_execute(task_name, start_address, end_address, page_size);\n+    } else {\n+      \/\/ Test purpose following lines are commented.\n+      \/\/log_debug(gc, heap)(\"Running %s pre-touching \" SIZE_FORMAT \"B.\",\n+      \/\/                    task.name(), total_bytes);\n+      task.work(0);\n+    }\n+    Ticks end = Ticks::now();\n+    log_debug(gc, heap)(\"Running %s pre-touching \" SIZE_FORMAT \"B %.4lfms\",\n+                         task.name(), total_bytes, (double)(end-start).milliseconds());\n+\n+  }\n+}\n+\n+\/\/ Called to initialize _task_coordinator\n+void PretouchTaskCoordinator::createObject() {\n+  volatile uint my_id = Atomic::fetch_and_add(&_object_creation, 1u);\n+  if (my_id == 0) {\n+    \/\/ First thread creates the object.\n+    _task_coordinator = new PretouchTaskCoordinator(\"Pretouch during oldgen expansion\", NULL, NULL);\n+  } else {\n+    \/\/ Other threads will wait until _task_coordinator object is initialized.\n+    PretouchTaskCoordinator *is_initialized = NULL;\n+    do {\n+      SpinPause();\n+      is_initialized = Atomic::load_acquire(&_task_coordinator);\n+    } while(!is_initialized);\n+  }\n+  my_id = Atomic::sub(&_object_creation, 1u);\n+}\n+\n+PretouchTaskCoordinator::PretouchTaskCoordinator(const char* task_name, char* start_address,\n+                                                 char* end_address):\n+    _n_threads(0),\n+    _task_status(Done),\n+    _pretouch_task(NULL){\n+  ;\n+}\n+\n+\n+void PretouchTaskCoordinator::coordinate_and_execute(const char* task_name, char* start_address,\n+                                                    char* end_address, size_t page_size) {\n+\n+  size_t total_bytes = pointer_delta(end_address, start_address, sizeof(char));\n+\n+  if (total_bytes == 0) {\n+    return;\n+  }\n+\n+  PretouchTaskCoordinator *task_coordinator = get_task_coordinator();\n+\n+  size_t chunk_size = 0;\n+  PretouchTask::setup_chunk_size_and_page_size(chunk_size, page_size);\n+\n+  size_t num_chunks = (total_bytes + chunk_size - 1) \/ chunk_size;\n+\n+  PretouchTask task(task_name, start_address, end_address, page_size, chunk_size);\n+  task_coordinator->release_set_pretouch_task(&task);\n+\n+  \/\/ Test purpose following lines are commented.\n+  \/\/log_debug(gc, heap)(\"Running %s with \" SIZE_FORMAT \" work units pre-touching \" SIZE_FORMAT \"B.\",\n+  \/\/                    task->name(), num_chunks, total_bytes);\n+\n+  \/\/ Mark Pretouch task ready here to let other threads waiting to expand oldgen will join\n+  \/\/ pretouch task.\n+  task_coordinator->release_set_task_ready();\n+\n+  \/\/ Execute the task\n+  task_coordinator->task_execute();\n+\n+  \/\/ Wait for other threads to finish.\n+  do {\n+    SpinPause();\n+  } while (task_coordinator->wait_for_all_threads_acquire()) ;\n+\n+}\n+\n+\n+void PretouchTaskCoordinator::task_execute() {\n+\n+  uint cur_thread_id = Atomic::add(&_n_threads, 1u);\n+\n+  PretouchTask *task = const_cast<PretouchTask *>(pretouch_task_acquire());\n+  task->work(static_cast<AbstractGangWorker*>(Thread::current())->id());\n+\n+  \/\/ First thread to exit marks task completed.\n+  if (! is_task_done_acquire()) {\n+    release_set_task_done();\n+  }\n+\n+  cur_thread_id = Atomic::sub(&_n_threads, 1u);\n+}\n+\n+void PretouchTaskCoordinator::worker_wait_for_task(){\n+\n+  while (! is_task_done_acquire()) {\n+    if (is_task_ready_acquire()) {\n+      task_execute();\n+      break;\n+    }\n+    SpinPause();\n","filename":"src\/hotspot\/share\/gc\/shared\/pretouchTask.cpp","additions":119,"deletions":7,"binary":false,"changes":126,"status":"modified"},{"patch":"@@ -47,0 +47,44 @@\n+  static void setup_chunk_size_and_page_size(size_t& chunk_size, size_t& page_size);\n+};\n+\n+class PretouchTaskCoordinator : public CHeapObj<mtGC>{\n+  volatile uint _n_threads;  \/\/ Number of threads participating in pretouch.\n+\n+  enum TaskStatus{ NotReady, Ready, Done};\n+  volatile size_t _task_status;\n+\n+  volatile PretouchTask* _pretouch_task;\n+\n+  PretouchTaskCoordinator(const char* task_name, char* start_address, char* end_address) ;\n+\n+  static uint _object_creation;\n+public:\n+\n+  static PretouchTaskCoordinator* _task_coordinator;\n+\n+  static PretouchTaskCoordinator* get_task_coordinator() {\n+    if(!_task_coordinator) {\n+      createObject();\n+    }\n+    return _task_coordinator;\n+  }\n+\n+  void release_set_task_status(TaskStatus status) { Atomic::release_store(&_task_status, (size_t)status);  }\n+  void release_set_task_done()                    { release_set_task_status(Done);    }\n+  void release_set_task_ready()                   { release_set_task_status(Ready);    }\n+  void release_set_task_notready()                { release_set_task_status(NotReady); }\n+  bool is_task_ready_acquire()                    { return Atomic::load_acquire(&_task_status) == Ready; }\n+  bool is_task_done_acquire()                     { return Atomic::load_acquire(&_task_status) == Done;  }\n+  bool wait_for_all_threads_acquire()             { return Atomic::load_acquire(&_n_threads);  }\n+\n+  void release_set_pretouch_task(PretouchTask *task)  { Atomic::release_store(&_pretouch_task, task);  }\n+  volatile PretouchTask* pretouch_task_acquire()      { return Atomic::load_acquire(&_pretouch_task);  }\n+\n+  void task_execute();\n+\n+  static void createObject();\n+  \/\/ GC thread coordinates with other GC threads for pretouch task.\n+  static void coordinate_and_execute(const char* task_name, char* start_address, char* end_address, size_t page_size);\n+\n+  \/\/ GC threads fails to acquire the lock during oldgen expansion will call this to help pretouch task.\n+  void worker_wait_for_task();\n","filename":"src\/hotspot\/share\/gc\/shared\/pretouchTask.hpp","additions":44,"deletions":0,"binary":false,"changes":44,"status":"modified"}]}