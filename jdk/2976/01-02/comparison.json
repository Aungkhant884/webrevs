{"files":[{"patch":"@@ -37,0 +37,1 @@\n+#include \"gc\/shared\/pretouchTask.hpp\"\n@@ -274,2 +275,12 @@\n-    MutexLocker x(FreeList_lock, Mutex::_no_safepoint_check_flag);\n-    result = old_gc_alloc_region()->attempt_allocation_locked(min_word_size,\n+    bool is_locked = false;\n+    PretouchTaskCoordinator *task_coordinator = PretouchTaskCoordinator::get_task_coordinator();\n+    while (true) {\n+      if (UseMultithreadedPretouchForOldGen) {\n+        is_locked = FreeList_lock->try_lock();\n+      } else {\n+        FreeList_lock->lock();\n+        is_locked = true;\n+      }\n+      if (is_locked) {\n+        task_coordinator->release_set_task_notready();\n+        result = old_gc_alloc_region()->attempt_allocation_locked(min_word_size,\n@@ -278,2 +289,10 @@\n-    if (result == NULL) {\n-      set_old_full();\n+        task_coordinator->release_set_task_done();\n+        if (result == NULL) {\n+          set_old_full();\n+        }\n+        FreeList_lock->unlock();\n+        break;\n+      } else {\n+        \/\/ Lets help expanding thread to pretouch the memory.\n+        task_coordinator->worker_wait_for_task();\n+      }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Allocator.cpp","additions":23,"deletions":4,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -579,2 +579,1 @@\n-                                  WorkGang* pretouch_gang,\n-                                  PretouchTask* pretouch_task) {\n+                                  WorkGang* pretouch_gang) {\n","filename":"src\/hotspot\/share\/gc\/parallel\/mutableNUMASpace.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -204,2 +204,1 @@\n-                          WorkGang* pretouch_gang = NULL,\n-                          PretouchTask* pretouch_task = NULL);\n+                          WorkGang* pretouch_gang = NULL);\n","filename":"src\/hotspot\/share\/gc\/parallel\/mutableNUMASpace.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-#include \"runtime\/osThread.hpp\"\n@@ -76,2 +75,1 @@\n-                              WorkGang* pretouch_gang,\n-                              PretouchTask* pretouch_task) {\n+                              WorkGang* pretouch_gang) {\n@@ -126,6 +124,2 @@\n-      \/\/ Old-gen gets expanded during promotion failure and this GC thread (not\n-      \/\/ VM thread) is already executing a GC task so cant call run_task.\n-      \/\/ \"pretouch_task\" is a special case for old-gen to make pretouch\n-      \/\/ multi-threaded and is part of PSOldGen object and shared between the\n-      \/\/ threads (expanding thread and threads waiting for expansion).\n-      if (pretouch_gang == NULL) {\n+      PretouchTask::pretouch(\"ParallelGC PreTouch head\", (char*)head.start(), (char*)head.end(),\n+                             page_size, pretouch_gang);\n@@ -133,31 +127,2 @@\n-        assert(head.start() == head.end(), \" old gen is expanding from head side also.\");\n-\n-        \/\/ Update the object with tail part for pretouch.\n-        pretouch_task->reinitialize((char*)tail.start(), (char*)tail.end());\n-\n-        size_t total_bytes = pointer_delta(tail.end(), tail.start(), sizeof(char));\n-        size_t chunk_size =0;\n-        PretouchTask::setup_chunk_size_and_page_size(chunk_size, page_size);\n-        size_t num_chunks = (total_bytes + chunk_size - 1) \/ chunk_size;\n-        log_debug(gc, heap)(\"Running %s with \" SIZE_FORMAT \" work units pre-touching \" SIZE_FORMAT \"B.\",\n-                            pretouch_task->name(), num_chunks, total_bytes);\n-\n-        OrderAccess::storestore();\n-        \/\/ Mark Pretouch task ready here and continue. The other threads\n-        \/\/ waiting to expand old-gen will join from PSOldGen::expand_for_allocate\n-        \/\/ function for pretouch work.\n-        pretouch_task->set_task_ready();\n-        pretouch_task->work(Thread::current()->osthread()->thread_id());\n-\n-        \/\/ Wait for task to be finished by participating threads.\n-        while(!pretouch_task->is_task_done()) {\n-          SpinPause();\n-        }\n-      } else {\n-\n-        PretouchTask::pretouch(\"ParallelGC PreTouch head\", (char*)head.start(), (char*)head.end(),\n-                               page_size, pretouch_gang);\n-\n-        PretouchTask::pretouch(\"ParallelGC PreTouch tail\", (char*)tail.start(), (char*)tail.end(),\n-                               page_size, pretouch_gang);\n-      }\n+      PretouchTask::pretouch(\"ParallelGC PreTouch tail\", (char*)tail.start(), (char*)tail.end(),\n+                             page_size, pretouch_gang);\n","filename":"src\/hotspot\/share\/gc\/parallel\/mutableSpace.cpp","additions":5,"deletions":40,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-class PretouchTask;\n@@ -106,2 +105,1 @@\n-                          WorkGang* pretouch_gang = NULL,\n-                          PretouchTask* pretouch_task = NULL);\n+                          WorkGang* pretouch_gang = NULL);\n","filename":"src\/hotspot\/share\/gc\/parallel\/mutableSpace.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -133,11 +133,0 @@\n-\n-  size_t chunk_size = 0;\n-  size_t page_size = (size_t)os::vm_page_size();\n-  PretouchTask::setup_chunk_size_and_page_size(chunk_size, page_size);\n-\n-  _pretouch = new PretouchTask(\"pretouch for oldgen expansion\",\n-                               (char*)object_space()->end(),\n-                               (char*)object_space()->end(),\n-                               page_size,\n-                               chunk_size);\n-  _pretouch->set_task_notready();\n@@ -198,0 +187,1 @@\n+    PretouchTaskCoordinator *task_coordinator = PretouchTaskCoordinator::get_task_coordinator();\n@@ -199,1 +189,6 @@\n-      is_locked = ExpandHeap_lock->try_lock();\n+      if (UseMultithreadedPretouchForOldGen) {\n+        is_locked = ExpandHeap_lock->try_lock();\n+      } else {\n+        ExpandHeap_lock->lock();\n+        is_locked = true;\n+      }\n@@ -208,2 +203,2 @@\n-      \/\/ Thread which holds the lock can expand once for all thre threads and\n-      \/\/ this will be win-win for all threads.\n+      \/\/ Thread which holds the lock can expand once for all the threads and\n+      \/\/ this will be win-win for all the threads.\n@@ -212,2 +207,2 @@\n-          \/\/ Marking not ready makes other threads to Spin in loop.\n-          pretouch()->set_task_notready();\n+          \/\/ Marking not ready makes other threads to spin in loop.\n+          task_coordinator->release_set_task_notready();\n@@ -215,1 +210,1 @@\n-          pretouch()->set_task_done();\n+          task_coordinator->release_set_task_done();\n@@ -218,1 +213,1 @@\n-        assert (pretouch()->is_task_done(), \"Task should be done at this point\");\n+        assert (task_coordinator->is_task_done_acquire(), \"Task should be done at this point\");\n@@ -224,8 +219,1 @@\n-        while (!pretouch()->is_task_done()) {\n-          if (pretouch()->is_task_ready()) {\n-            pretouch()->work(Thread::current()->osthread()->thread_id());\n-          } else {\n-            SpinPause();\n-          }\n-        }\n-        SpinPause();\n+        task_coordinator->worker_wait_for_task();\n@@ -412,2 +400,1 @@\n-                             workers,\n-                             pretouch());\n+                             workers);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psOldGen.cpp","additions":15,"deletions":28,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -35,2 +35,0 @@\n-class PretouchTask;\n-\n@@ -49,1 +47,0 @@\n-  PretouchTask*            _pretouch;          \/\/ Used when old gen resized during scavenging.\n@@ -120,1 +117,0 @@\n-  PretouchTask*         pretouch()                { return _pretouch;    }\n","filename":"src\/hotspot\/share\/gc\/parallel\/psOldGen.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -199,0 +199,3 @@\n+  product(bool, UseMultithreadedPretouchForOldGen, false,                   \\\n+          \"Oldgen expands during promotional failure and pages are touched\" \\\n+          \"with single thread. This option makes it multi-threaded\" )       \\\n","filename":"src\/hotspot\/share\/gc\/shared\/gc_globals.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"runtime\/nonJavaThread.hpp\"\n@@ -33,0 +34,3 @@\n+PretouchTaskCoordinator* PretouchTaskCoordinator::_task_coordinator = NULL;\n+uint PretouchTaskCoordinator::_object_creation = 0;\n+\n@@ -37,3 +41,1 @@\n-                           size_t chunk_size,\n-                           uint n_threads,\n-                           size_t task_status) :\n+                           size_t chunk_size) :\n@@ -45,3 +47,1 @@\n-    _chunk_size(chunk_size),\n-    _n_threads(n_threads),\n-    _task_status(task_status) {\n+    _chunk_size(chunk_size) {\n@@ -54,5 +54,0 @@\n-void PretouchTask::reinitialize(char* start_addr, char* end_addr) {\n-  Atomic::release_store(&_cur_addr, start_addr);\n-  Atomic::release_store(&_end_addr, end_addr);\n-}\n-\n@@ -64,14 +59,0 @@\n-\n-  \/\/ Following atomic loads are required to make other processor store\n-  \/\/ visible to all threads from this points.\n-  char *cur_addr = Atomic::load(&_cur_addr);\n-  char *end_addr = Atomic::load(&_end_addr);\n-  OrderAccess::fence();\n-\n-  \/\/ Required to avoid un-necessary update of _cur_addr once the task is done.\n-  if ( cur_addr >= end_addr ) {\n-    return ;\n-  }\n-\n-  uint thread_num = Atomic::add(&_n_threads, 1u);\n-\n@@ -84,1 +65,1 @@\n-    end_addr = touch_addr + MIN2(_chunk_size, pointer_delta(_end_addr, touch_addr, sizeof(char)));\n+    char* end_addr = touch_addr + MIN2(_chunk_size, pointer_delta(_end_addr, touch_addr, sizeof(char)));\n@@ -87,10 +68,0 @@\n-\n-  }\n-\n-  \/\/ Mark task done only when the last thread finishes its work.\n-  thread_num = Atomic::sub(&_n_threads, 1u);\n-\n-  if (thread_num == 0) {\n-    Atomic::release_store(&_cur_addr, _end_addr);\n-    OrderAccess::storestore();\n-    set_task_done();\n@@ -100,0 +71,1 @@\n+\n@@ -114,0 +86,4 @@\n+  size_t chunk_size = 0;\n+  setup_chunk_size_and_page_size(chunk_size, page_size);\n+\n+  PretouchTask task(task_name, start_address, end_address, page_size, chunk_size);\n@@ -120,4 +96,0 @@\n-  size_t chunk_size =0;\n-  setup_chunk_size_and_page_size(chunk_size, page_size);\n-  PretouchTask task(task_name, start_address, end_address, page_size, chunk_size);\n-\n@@ -130,1 +102,0 @@\n-\n@@ -133,3 +104,104 @@\n-    log_debug(gc, heap)(\"Running %s pre-touching \" SIZE_FORMAT \"B.\",\n-                        task.name(), total_bytes);\n-    task.work(0);\n+\n+    Ticks start = Ticks::now();\n+    if (UseMultithreadedPretouchForOldGen) {\n+      PretouchTaskCoordinator::coordinate_and_execute(task_name, start_address, end_address, page_size);\n+    } else {\n+      \/\/ Test purpose following lines are commented.\n+      \/\/log_debug(gc, heap)(\"Running %s pre-touching \" SIZE_FORMAT \"B.\",\n+      \/\/                    task.name(), total_bytes);\n+      task.work(0);\n+    }\n+    Ticks end = Ticks::now();\n+    log_debug(gc, heap)(\"Running %s pre-touching \" SIZE_FORMAT \"B %.4lfms\",\n+                         task.name(), total_bytes, (double)(end-start).milliseconds());\n+\n+  }\n+}\n+\n+\/\/ Called to initialize _task_coordinator\n+void PretouchTaskCoordinator::createObject() {\n+  volatile uint my_id = Atomic::fetch_and_add(&_object_creation, 1u);\n+  if (my_id == 0) {\n+    \/\/ First thread creates the object.\n+    _task_coordinator = new PretouchTaskCoordinator(\"Pretouch during oldgen expansion\", NULL, NULL);\n+  } else {\n+    \/\/ Other threads will wait until _task_coordinator object is initialized.\n+    PretouchTaskCoordinator *is_initialized = NULL;\n+    do {\n+      SpinPause();\n+      is_initialized = Atomic::load_acquire(&_task_coordinator);\n+    } while(!is_initialized);\n+  }\n+  my_id = Atomic::sub(&_object_creation, 1u);\n+}\n+\n+PretouchTaskCoordinator::PretouchTaskCoordinator(const char* task_name, char* start_address,\n+                                                 char* end_address):\n+    _n_threads(0),\n+    _task_status(Done),\n+    _pretouch_task(NULL){\n+  ;\n+}\n+\n+\n+void PretouchTaskCoordinator::coordinate_and_execute(const char* task_name, char* start_address,\n+                                                    char* end_address, size_t page_size) {\n+\n+  size_t total_bytes = pointer_delta(end_address, start_address, sizeof(char));\n+\n+  if (total_bytes == 0) {\n+    return;\n+  }\n+\n+  PretouchTaskCoordinator *task_coordinator = get_task_coordinator();\n+\n+  size_t chunk_size = 0;\n+  PretouchTask::setup_chunk_size_and_page_size(chunk_size, page_size);\n+\n+  size_t num_chunks = (total_bytes + chunk_size - 1) \/ chunk_size;\n+\n+  PretouchTask task(task_name, start_address, end_address, page_size, chunk_size);\n+  task_coordinator->release_set_pretouch_task(&task);\n+\n+  \/\/ Test purpose following lines are commented.\n+  \/\/log_debug(gc, heap)(\"Running %s with \" SIZE_FORMAT \" work units pre-touching \" SIZE_FORMAT \"B.\",\n+  \/\/                    task->name(), num_chunks, total_bytes);\n+\n+  \/\/ Mark Pretouch task ready here to let other threads waiting to expand oldgen will join\n+  \/\/ pretouch task.\n+  task_coordinator->release_set_task_ready();\n+\n+  \/\/ Execute the task\n+  task_coordinator->task_execute();\n+\n+  \/\/ Wait for other threads to finish.\n+  do {\n+    SpinPause();\n+  } while (task_coordinator->wait_for_all_threads_acquire()) ;\n+\n+}\n+\n+\n+void PretouchTaskCoordinator::task_execute() {\n+\n+  uint cur_thread_id = Atomic::add(&_n_threads, 1u);\n+\n+  PretouchTask *task = const_cast<PretouchTask *>(pretouch_task_acquire());\n+  task->work(static_cast<AbstractGangWorker*>(Thread::current())->id());\n+\n+  \/\/ First thread to exit marks task completed.\n+  if (! is_task_done_acquire()) {\n+    release_set_task_done();\n+  }\n+\n+  cur_thread_id = Atomic::sub(&_n_threads, 1u);\n+}\n+\n+void PretouchTaskCoordinator::worker_wait_for_task(){\n+\n+  while (! is_task_done_acquire()) {\n+    if (is_task_ready_acquire()) {\n+      task_execute();\n+      break;\n+    }\n+    SpinPause();\n","filename":"src\/hotspot\/share\/gc\/shared\/pretouchTask.cpp","additions":116,"deletions":44,"binary":false,"changes":160,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-  char* volatile _end_addr;\n+  char* const _end_addr;\n@@ -36,0 +36,15 @@\n+\n+public:\n+  PretouchTask(const char* task_name, char* start_address, char* end_address, size_t page_size, size_t chunk_size);\n+\n+  virtual void work(uint worker_id);\n+\n+  static size_t chunk_size();\n+\n+  static void pretouch(const char* task_name, char* start_address, char* end_address,\n+                       size_t page_size, WorkGang* pretouch_gang);\n+\n+  static void setup_chunk_size_and_page_size(size_t& chunk_size, size_t& page_size);\n+};\n+\n+class PretouchTaskCoordinator : public CHeapObj<mtGC>{\n@@ -41,2 +56,1 @@\n-public:\n-  PretouchTask(const char* task_name, char* start_address, char* end_address, size_t page_size, size_t chunk_size, uint n_threads = 0, size_t task_status = Ready);\n+  volatile PretouchTask* _pretouch_task;\n@@ -44,1 +58,1 @@\n-  void reinitialize(char* start_address, char *end_addr);\n+  PretouchTaskCoordinator(const char* task_name, char* start_address, char* end_address) ;\n@@ -46,6 +60,2 @@\n-  void set_task_status(TaskStatus status) { Atomic::release_store(&_task_status, (size_t)status);  }\n-  void set_task_done()                    { Atomic::release_store(&_task_status, (size_t)Done);    }\n-  void set_task_ready()                   { set_task_status(Ready);    }\n-  void set_task_notready()                { set_task_status(NotReady); }\n-  bool is_task_ready()                    { return Atomic::load(&_task_status) == Ready; }\n-  bool is_task_done()                     { return Atomic::load(&_task_status) == Done;  }\n+  static uint _object_creation;\n+public:\n@@ -53,1 +63,1 @@\n-  virtual void work(uint worker_id);\n+  static PretouchTaskCoordinator* _task_coordinator;\n@@ -55,2 +65,5 @@\n-  static void* operator new(size_t size) throw() {\n-    return CHeapObj<mtGC>::operator new(size);\n+  static PretouchTaskCoordinator* get_task_coordinator() {\n+    if(!_task_coordinator) {\n+      createObject();\n+    }\n+    return _task_coordinator;\n@@ -59,1 +72,7 @@\n-  static void setup_chunk_size_and_page_size(size_t& chunk_size, size_t& page_size);\n+  void release_set_task_status(TaskStatus status) { Atomic::release_store(&_task_status, (size_t)status);  }\n+  void release_set_task_done()                    { release_set_task_status(Done);    }\n+  void release_set_task_ready()                   { release_set_task_status(Ready);    }\n+  void release_set_task_notready()                { release_set_task_status(NotReady); }\n+  bool is_task_ready_acquire()                    { return Atomic::load_acquire(&_task_status) == Ready; }\n+  bool is_task_done_acquire()                     { return Atomic::load_acquire(&_task_status) == Done;  }\n+  bool wait_for_all_threads_acquire()             { return Atomic::load_acquire(&_n_threads);  }\n@@ -61,1 +80,2 @@\n-  static size_t chunk_size();\n+  void release_set_pretouch_task(PretouchTask *task)  { Atomic::release_store(&_pretouch_task, task);  }\n+  volatile PretouchTask* pretouch_task_acquire()      { return Atomic::load_acquire(&_pretouch_task);  }\n@@ -63,2 +83,5 @@\n-  static void pretouch(const char* task_name, char* start_address, char* end_address,\n-                       size_t page_size, WorkGang* pretouch_gang);\n+  void task_execute();\n+\n+  static void createObject();\n+  \/\/ GC thread coordinates with other GC threads for pretouch task.\n+  static void coordinate_and_execute(const char* task_name, char* start_address, char* end_address, size_t page_size);\n@@ -66,0 +89,2 @@\n+  \/\/ GC threads fails to acquire the lock during oldgen expansion will call this to help pretouch task.\n+  void worker_wait_for_task();\n","filename":"src\/hotspot\/share\/gc\/shared\/pretouchTask.hpp","additions":42,"deletions":17,"binary":false,"changes":59,"status":"modified"}]}