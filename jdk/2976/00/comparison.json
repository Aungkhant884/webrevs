{"files":[{"patch":"@@ -579,1 +579,2 @@\n-                                  WorkGang* pretouch_gang) {\n+                                  WorkGang* pretouch_gang,\n+                                  PretouchTask* pretouch_task) {\n","filename":"src\/hotspot\/share\/gc\/parallel\/mutableNUMASpace.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -204,1 +204,2 @@\n-                          WorkGang* pretouch_gang = NULL);\n+                          WorkGang* pretouch_gang = NULL,\n+                          PretouchTask* pretouch_task = NULL);\n","filename":"src\/hotspot\/share\/gc\/parallel\/mutableNUMASpace.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -75,1 +75,2 @@\n-                              WorkGang* pretouch_gang) {\n+                              WorkGang* pretouch_gang,\n+                              PretouchTask* pretouch_task) {\n@@ -124,2 +125,6 @@\n-      PretouchTask::pretouch(\"ParallelGC PreTouch head\", (char*)head.start(), (char*)head.end(),\n-                             page_size, pretouch_gang);\n+      \/\/ Old-gen gets expanded during promotion failure and this GC thread (not\n+      \/\/ VM thread) is already executing a GC task so cant call run_task.\n+      \/\/ \"pretouch_task\" is a special case for old-gen to make pretouch\n+      \/\/ multi-threaded and is part of PSOldGen object and shared between the\n+      \/\/ threads (expanding thread and threads waiting for expansion).\n+      if (pretouch_gang == NULL) {\n@@ -127,2 +132,31 @@\n-      PretouchTask::pretouch(\"ParallelGC PreTouch tail\", (char*)tail.start(), (char*)tail.end(),\n-                             page_size, pretouch_gang);\n+        assert(head.start() == head.end(), \" old gen is expanding from head side also.\");\n+\n+        \/\/ Update the object with tail part for pretouch.\n+        pretouch_task->reinitialize((char*)tail.start(), (char*)tail.end());\n+\n+        size_t total_bytes = pointer_delta(tail.end(), tail.start(), sizeof(char));\n+        size_t chunk_size =0;\n+        PretouchTask::setup_chunk_size_and_page_size(chunk_size, page_size);\n+        size_t num_chunks = (total_bytes + chunk_size - 1) \/ chunk_size;\n+        log_debug(gc, heap)(\"Running %s with \" SIZE_FORMAT \" work units pre-touching \" SIZE_FORMAT \"B.\",\n+                            pretouch_task->name(), num_chunks, total_bytes);\n+\n+        OrderAccess::storestore();\n+        \/\/ Mark Pretouch task ready here and continue. The other threads\n+        \/\/ waiting to expand old-gen will join from PSOldGen::expand_for_allocate\n+        \/\/ function for pretouch work.\n+        pretouch_task->set_task_ready();\n+        pretouch_task->work(Thread::current()->osthread()->thread_id());\n+\n+        \/\/ Wait for task to be finished by participating threads.\n+        while(!pretouch_task->is_task_done()) {\n+          SpinPause();\n+        }\n+      } else {\n+\n+        PretouchTask::pretouch(\"ParallelGC PreTouch head\", (char*)head.start(), (char*)head.end(),\n+                               page_size, pretouch_gang);\n+\n+        PretouchTask::pretouch(\"ParallelGC PreTouch tail\", (char*)tail.start(), (char*)tail.end(),\n+                               page_size, pretouch_gang);\n+      }\n","filename":"src\/hotspot\/share\/gc\/parallel\/mutableSpace.cpp","additions":39,"deletions":5,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+class PretouchTask;\n@@ -105,1 +106,2 @@\n-                          WorkGang* pretouch_gang = NULL);\n+                          WorkGang* pretouch_gang = NULL,\n+                          PretouchTask* pretouch_task = NULL);\n","filename":"src\/hotspot\/share\/gc\/parallel\/mutableSpace.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"gc\/shared\/pretouchTask.hpp\"\n@@ -132,0 +133,11 @@\n+\n+  size_t chunk_size = 0;\n+  size_t page_size = (size_t)os::vm_page_size();\n+  PretouchTask::setup_chunk_size_and_page_size(chunk_size, page_size);\n+\n+  _pretouch = new PretouchTask(\"pretouch for oldgen expansion\",\n+                               (char*)object_space()->end(),\n+                               (char*)object_space()->end(),\n+                               page_size,\n+                               chunk_size);\n+  _pretouch->set_task_notready();\n@@ -185,9 +197,35 @@\n-    MutexLocker x(ExpandHeap_lock);\n-    \/\/ Avoid \"expand storms\" by rechecking available space after obtaining\n-    \/\/ the lock, because another thread may have already made sufficient\n-    \/\/ space available.  If insufficient space available, that will remain\n-    \/\/ true until we expand, since we have the lock.  Other threads may take\n-    \/\/ the space we need before we can allocate it, regardless of whether we\n-    \/\/ expand.  That's okay, we'll just try expanding again.\n-    if (object_space()->needs_expand(word_size)) {\n-      result = expand(word_size*HeapWordSize);\n+    bool is_locked = false;\n+    while(true) {\n+      MutexLocker x(ExpandHeap_lock, is_locked);\n+      \/\/ Avoid \"expand storms\" by rechecking available space after obtaining\n+      \/\/ the lock, because another thread may have already made sufficient\n+      \/\/ space available.  If insufficient space available, that will remain\n+      \/\/ true until we expand, since we have the lock.  Other threads may take\n+      \/\/ the space we need before we can allocate it, regardless of whether we\n+      \/\/ expand.  That's okay, we'll just try expanding again.\n+      \/\/\n+      \/\/ Todo:\n+      \/\/ Thread which holds the lock can expand once for all thre threads and\n+      \/\/ this will be win-win for all threads.\n+      if (is_locked) {\n+        if (object_space()->needs_expand(word_size)) {\n+          \/\/ Marking not ready makes other threads to Spin in loop.\n+          pretouch()->set_task_notready();\n+          result = expand(word_size*HeapWordSize);\n+          pretouch()->set_task_done();\n+        }\n+\n+        assert (pretouch()->is_task_done(), \"Task should be done at this point\");\n+        break;\n+\n+      } else {\n+        \/\/ Lets help expanding thread to pretouch the memory.\n+        while (!pretouch()->is_task_done()) {\n+          if (pretouch()->is_task_ready()) {\n+            pretouch()->work(Thread::current()->osthread()->thread_id());\n+          } else {\n+            SpinPause();\n+          }\n+        }\n+        SpinPause();\n+      }\n@@ -196,0 +234,1 @@\n+\n@@ -372,1 +411,2 @@\n-                             workers);\n+                             workers,\n+                             pretouch());\n","filename":"src\/hotspot\/share\/gc\/parallel\/psOldGen.cpp","additions":50,"deletions":10,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -35,0 +35,2 @@\n+class PretouchTask;\n+\n@@ -47,0 +49,1 @@\n+  PretouchTask*            _pretouch;          \/\/ Used when old gen resized during scavenging.\n@@ -117,0 +120,1 @@\n+  PretouchTask*         pretouch()                { return _pretouch;    }\n","filename":"src\/hotspot\/share\/gc\/parallel\/psOldGen.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"utilities\/ticks.hpp\"\n@@ -36,1 +37,3 @@\n-                           size_t chunk_size) :\n+                           size_t chunk_size,\n+                           size_t n_threads,\n+                           size_t task_status) :\n@@ -42,1 +45,3 @@\n-    _chunk_size(chunk_size) {\n+    _chunk_size(chunk_size),\n+    _n_threads(n_threads),\n+    _task_status(task_status) {\n@@ -49,0 +54,5 @@\n+void PretouchTask::reinitialize(char* start_addr, char* end_addr) {\n+  Atomic::release_store(&_cur_addr, start_addr);\n+  Atomic::release_store(&_end_addr, end_addr);\n+}\n+\n@@ -54,0 +64,14 @@\n+\n+  \/\/ Following atomic loads are required to make other processor store\n+  \/\/ visible to all threads from this points.\n+  char *cur_addr = Atomic::load(&_cur_addr);\n+  char *end_addr = Atomic::load(&_end_addr);\n+  OrderAccess::fence();\n+\n+  \/\/ Required to avoid un-necessary update of _cur_addr once the task is done.\n+  if ( cur_addr >= end_addr ) {\n+    return ;\n+  }\n+\n+  uint thread_num = Atomic::add(&_n_threads, 1u);\n+\n@@ -60,1 +84,1 @@\n-    char* end_addr = touch_addr + MIN2(_chunk_size, pointer_delta(_end_addr, touch_addr, sizeof(char)));\n+    end_addr = touch_addr + MIN2(_chunk_size, pointer_delta(_end_addr, touch_addr, sizeof(char)));\n@@ -63,0 +87,10 @@\n+\n+  }\n+\n+  \/\/ Mark task done only when the last thread finishes its work.\n+  thread_num = Atomic::sub(&_n_threads, 1u);\n+\n+  if (thread_num == 0) {\n+    Atomic::release_store(&_cur_addr, _end_addr);\n+    OrderAccess::storestore();\n+    set_task_done();\n@@ -66,2 +100,2 @@\n-void PretouchTask::pretouch(const char* task_name, char* start_address, char* end_address,\n-                            size_t page_size, WorkGang* pretouch_gang) {\n+void PretouchTask::setup_chunk_size_and_page_size(size_t& chunk_size, size_t& page_size)\n+{\n@@ -70,1 +104,1 @@\n-  size_t chunk_size = MAX2(PretouchTask::chunk_size(), page_size);\n+  chunk_size = MAX2(PretouchTask::chunk_size(), page_size);\n@@ -76,0 +110,1 @@\n+}\n@@ -77,1 +112,2 @@\n-  PretouchTask task(task_name, start_address, end_address, page_size, chunk_size);\n+void PretouchTask::pretouch(const char* task_name, char* start_address, char* end_address,\n+                            size_t page_size, WorkGang* pretouch_gang) {\n@@ -84,0 +120,4 @@\n+  size_t chunk_size =0;\n+  setup_chunk_size_and_page_size(chunk_size, page_size);\n+  PretouchTask task(task_name, start_address, end_address, page_size, chunk_size);\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/pretouchTask.cpp","additions":47,"deletions":7,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-  char* const _end_addr;\n+  char* volatile _end_addr;\n@@ -36,0 +36,4 @@\n+  volatile uint _n_threads;  \/\/ Number of threads participating in pretouch.\n+\n+  enum TaskStatus{ NotReady, Ready, Done};\n+  volatile size_t _task_status;\n@@ -38,1 +42,10 @@\n-  PretouchTask(const char* task_name, char* start_address, char* end_address, size_t page_size, size_t chunk_size);\n+  PretouchTask(const char* task_name, char* start_address, char* end_address, size_t page_size, size_t chunk_size, size_t n_threads = 0, size_t task_status = Ready);\n+\n+  void reinitialize(char* start_address, char *end_addr);\n+\n+  void set_task_status(TaskStatus status) { Atomic::release_store(&_task_status, (size_t)status);  }\n+  void set_task_done()                    { Atomic::release_store(&_task_status, (size_t)Done);    }\n+  void set_task_ready()                   { set_task_status(Ready);    }\n+  void set_task_notready()                { set_task_status(NotReady); }\n+  bool is_task_ready()                    { return Atomic::load(&_task_status) == Ready; }\n+  bool is_task_done()                     { return Atomic::load(&_task_status) == Done;  }\n@@ -42,0 +55,6 @@\n+  static void* operator new(size_t size) throw() {\n+    return CHeapObj<mtGC>::operator new(size);\n+  }\n+\n+  static void setup_chunk_size_and_page_size(size_t& chunk_size, size_t& page_size);\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/pretouchTask.hpp","additions":21,"deletions":2,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -231,0 +231,17 @@\n+  MutexLocker(Mutex* mutex, bool& lock_acquired, Mutex::SafepointCheckFlag flag = Mutex::_safepoint_check_flag) :\n+    _mutex(mutex) {\n+    bool no_safepoint_check = flag == Mutex::_no_safepoint_check_flag;\n+    if (_mutex != NULL) {\n+      assert(_mutex->rank() > Mutex::special || no_safepoint_check,\n+             \"Mutexes with rank special or lower should not do safepoint checks\");\n+      if (!no_safepoint_check) {\n+        lock_acquired = _mutex->try_lock();\n+      }\n+\n+      if (!lock_acquired) {\n+        _mutex = NULL;\n+      }\n+    }\n+  }\n+\n+\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"}]}