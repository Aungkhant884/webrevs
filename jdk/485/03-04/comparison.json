{"files":[{"patch":"@@ -29,2 +29,1 @@\n- * Data structure to hold info from \/proc\/self\/cgroup,\n- * \/proc\/cgroups and \/proc\/self\/mountinfo\n+ * Data structure to hold info from \/proc\/self\/cgroup\n@@ -36,1 +35,1 @@\n-public class CgroupInfo {\n+class CgroupInfo {\n@@ -41,3 +40,0 @@\n-    private String mountPoint;\n-    private String mountRoot;\n-    private String cgroupPath;\n@@ -51,1 +47,1 @@\n-    public String getName() {\n+    String getName() {\n@@ -55,1 +51,1 @@\n-    public int getHierarchyId() {\n+    int getHierarchyId() {\n@@ -59,1 +55,1 @@\n-    public boolean isEnabled() {\n+    boolean isEnabled() {\n@@ -63,24 +59,0 @@\n-    public String getMountPoint() {\n-        return mountPoint;\n-    }\n-\n-    public void setMountPoint(String mountPoint) {\n-        this.mountPoint = mountPoint;\n-    }\n-\n-    public String getMountRoot() {\n-        return mountRoot;\n-    }\n-\n-    public void setMountRoot(String mountRoot) {\n-        this.mountRoot = mountRoot;\n-    }\n-\n-    public String getCgroupPath() {\n-        return cgroupPath;\n-    }\n-\n-    public void setCgroupPath(String cgroupPath) {\n-        this.cgroupPath = cgroupPath;\n-    }\n-\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/CgroupInfo.java","additions":5,"deletions":33,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.nio.file.Path;\n@@ -33,1 +32,0 @@\n-import java.util.Collections;\n@@ -38,1 +36,0 @@\n-import java.util.function.Consumer;\n@@ -74,1 +71,1 @@\n-        \"([^\\\\s]+)\\\\s+([^\\\\s]+)\\\\s+\" +         \/\/ (4), (5)     - group 1, 2\n+        \"[^\\\\s]+\\\\s+([^\\\\s]+)\\\\s+\" +           \/\/ (4), (5)     - group 1: mount point\n@@ -76,1 +73,1 @@\n-        \"([^\\\\s]+)\\\\s+\" +                      \/\/ (9)          - group 3, filesystem type\n+        \"([^\\\\s]+)\\\\s+\" +                      \/\/ (9)          - group 2: filesystem type\n@@ -82,1 +79,1 @@\n-            optResult = determineType(\"\/proc\/self\/mountinfo\", \"\/proc\/cgroups\", \"\/proc\/self\/cgroup\");\n+            optResult = determineType(\"\/proc\/self\/mountinfo\", \"\/proc\/cgroups\");\n@@ -106,1 +103,0 @@\n-        Map<String, CgroupInfo> infos = result.getInfos();\n@@ -108,3 +104,1 @@\n-            \/\/ For unified it doesn't matter which controller we pick.\n-            CgroupInfo anyController = infos.get(MEMORY_CTRL);\n-            CgroupSubsystem subsystem = CgroupV2Subsystem.getInstance(anyController);\n+            CgroupSubsystem subsystem = CgroupV2Subsystem.getInstance();\n@@ -113,1 +107,1 @@\n-            CgroupV1Subsystem subsystem = CgroupV1Subsystem.getInstance(infos);\n+            CgroupV1Subsystem subsystem = CgroupV1Subsystem.getInstance();\n@@ -118,4 +112,2 @@\n-    public static Optional<CgroupTypeResult> determineType(String mountInfo,\n-                                                           String cgroups,\n-                                                           String selfCgroup) throws IOException {\n-        final Map<String, CgroupInfo> infos = new HashMap<>();\n+    public static Optional<CgroupTypeResult> determineType(String mountInfo, String cgroups) throws IOException {\n+        Map<String, CgroupInfo> infos = new HashMap<>();\n@@ -157,15 +149,4 @@\n-        lines = CgroupUtil.readAllLinesPrivileged(Paths.get(mountInfo));\n-        boolean anyCgroupMounted = false;\n-        for (String line: lines) {\n-            boolean cgroupsControllerFound = amendCgroupInfos(line, infos, isCgroupsV2);\n-            anyCgroupMounted = anyCgroupMounted || cgroupsControllerFound;\n-        }\n-        if (!anyCgroupMounted) {\n-            return Optional.empty();\n-        }\n-\n-        try (Stream<String> selfCgroupLines =\n-             CgroupUtil.readFilePrivileged(Paths.get(selfCgroup))) {\n-            Consumer<String[]> action = (tokens -> setCgroupV1Path(infos, tokens));\n-            if (isCgroupsV2) {\n-                action = (tokens -> setCgroupV2Path(infos, tokens));\n+        try (Stream<String> mntInfo = CgroupUtil.readFilePrivileged(Paths.get(mountInfo))) {\n+            boolean anyCgroupMounted = mntInfo.anyMatch(CgroupSubsystemFactory::isRelevantControllerMount);\n+            if (!anyCgroupMounted && isCgroupsV2) {\n+                return Optional.empty();\n@@ -173,5 +154,0 @@\n-            selfCgroupLines.map(line -> line.split(\":\"))\n-                     .filter(tokens -> (tokens.length >= 3))\n-                     .forEach(action);\n-        } catch (IOException e) {\n-            return Optional.empty();\n@@ -179,6 +155,1 @@\n-\n-        CgroupTypeResult result = new CgroupTypeResult(isCgroupsV2,\n-                                                       anyControllersEnabled,\n-                                                       anyCgroupsV2Controller,\n-                                                       anyCgroupsV1Controller,\n-                                                       Collections.unmodifiableMap(infos));\n+        CgroupTypeResult result = new CgroupTypeResult(isCgroupsV2, anyControllersEnabled, anyCgroupsV2Controller, anyCgroupsV1Controller);\n@@ -188,103 +159,28 @@\n-    private static void setCgroupV2Path(Map<String, CgroupInfo> infos,\n-                                        String[] tokens) {\n-        int hierarchyId = Integer.parseInt(tokens[0]);\n-        String cgroupPath = tokens[2];\n-        for (CgroupInfo info: infos.values()) {\n-            assert hierarchyId == info.getHierarchyId() && hierarchyId == 0;\n-            info.setCgroupPath(cgroupPath);\n-        }\n-    }\n-\n-    private static void setCgroupV1Path(Map<String, CgroupInfo> infos,\n-                                        String[] tokens) {\n-        String controllerName = tokens[1];\n-        String cgroupPath = tokens[2];\n-        if (controllerName != null && cgroupPath != null) {\n-            for (String cName: controllerName.split(\",\")) {\n-                switch (cName) {\n-                    case MEMORY_CTRL: \/\/ fall through\n-                    case CPUSET_CTRL:\n-                    case CPUACCT_CTRL:\n-                    case CPU_CTRL:\n-                    case BLKIO_CTRL:\n-                        CgroupInfo info = infos.get(cName);\n-                        info.setCgroupPath(cgroupPath);\n-                        break;\n-                    \/\/ Ignore not recognized controllers\n-                    default:\n-                        break;\n-                }\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Amends cgroup infos with mount path and mount root.\n-     *\n-     * @return {@code true} iff a relevant controller has been found at the\n-     * given line\n-     *\/\n-    private static boolean amendCgroupInfos(String mntInfoLine,\n-                                            Map<String, CgroupInfo> infos,\n-                                            boolean isCgroupsV2) {\n-        Matcher lineMatcher = MOUNTINFO_PATTERN.matcher(mntInfoLine.trim());\n-        boolean cgroupv1ControllerFound = false;\n-        boolean cgroupv2ControllerFound = false;\n-        if (lineMatcher.matches()) {\n-            String mountRoot = lineMatcher.group(1);\n-            String mountPath = lineMatcher.group(2);\n-            String fsType = lineMatcher.group(3);\n-            if (fsType.equals(\"cgroup\")) {\n-                Path p = Paths.get(mountPath);\n-                String[] controllerNames = p.getFileName().toString().split(\",\");\n-                for (String controllerName: controllerNames) {\n-                    switch (controllerName) {\n-                        case MEMORY_CTRL: \/\/ fall-through\n-                        case CPU_CTRL:\n-                        case CPUACCT_CTRL:\n-                        case BLKIO_CTRL: {\n-                            CgroupInfo info = infos.get(controllerName);\n-                            assert info.getMountPoint() == null;\n-                            assert info.getMountRoot() == null;\n-                            info.setMountPoint(mountPath);\n-                            info.setMountRoot(mountRoot);\n-                            cgroupv1ControllerFound = true;\n-                            break;\n-                        }\n-                        case CPUSET_CTRL: {\n-                            CgroupInfo info = infos.get(controllerName);\n-                            if (info.getMountPoint() != null) {\n-                                \/\/ On some systems duplicate cpuset controllers get mounted in addition to\n-                                \/\/ the main cgroup controllers most likely under \/sys\/fs\/cgroup. In that\n-                                \/\/ case pick the one under \/sys\/fs\/cgroup and discard others.\n-                                if (!info.getMountPoint().startsWith(\"\/sys\/fs\/cgroup\")) {\n-                                    info.setMountPoint(mountPath);\n-                                    info.setMountRoot(mountRoot);\n-                                }\n-                            } else {\n-                                info.setMountPoint(mountPath);\n-                                info.setMountRoot(mountRoot);\n-                            }\n-                            cgroupv1ControllerFound = true;\n-                            break;\n-                        }\n-                        default:\n-                            \/\/ Ignore controllers which we don't recognize\n-                            break;\n-                    }\n-                }\n-            } else if (fsType.equals(\"cgroup2\")) {\n-                if (isCgroupsV2) { \/\/ will be false for hybrid\n-                    \/\/ All controllers have the same mount point and root mount\n-                    \/\/ for unified hierarchy.\n-                    for (CgroupInfo info: infos.values()) {\n-                        assert info.getMountPoint() == null;\n-                        assert info.getMountRoot() == null;\n-                        info.setMountPoint(mountPath);\n-                        info.setMountRoot(mountRoot);\n-                    }\n-                }\n-                cgroupv2ControllerFound = true;\n-            }\n-        }\n-        return cgroupv1ControllerFound || cgroupv2ControllerFound;\n+    private static boolean isRelevantControllerMount(String line) {\n+         Matcher lineMatcher = MOUNTINFO_PATTERN.matcher(line.trim());\n+         if (lineMatcher.matches()) {\n+             String mountPoint = lineMatcher.group(1);\n+             String fsType = lineMatcher.group(2);\n+             boolean relevantControllerFound = false;\n+             if (fsType.equals(\"cgroup\")) {\n+                 String filename = Paths.get(mountPoint).getFileName().toString();\n+                 for (String fn: filename.split(\",\")) {\n+                     switch (fn) {\n+                         case MEMORY_CTRL: \/\/ fall through\n+                         case CPU_CTRL:\n+                         case CPUSET_CTRL:\n+                         case CPUACCT_CTRL:\n+                         case BLKIO_CTRL:\n+                             relevantControllerFound = true;\n+                             break;\n+                         default: break; \/\/ ignore not recognized controllers\n+                     }\n+                 }\n+             } else if (fsType.equals(\"cgroup2\")) {\n+                 relevantControllerFound = true;\n+             }\n+             return relevantControllerFound;\n+         } else {\n+           \/\/ fallback to old, pre JDK-8245543, behaviour\n+           return line.contains(\"cgroup\");\n+         }\n@@ -298,1 +194,0 @@\n-        private final Map<String, CgroupInfo> infos;\n@@ -303,2 +198,1 @@\n-                                 boolean anyCgroupV1Controllers,\n-                                 Map<String, CgroupInfo> infos) {\n+                                 boolean anyCgroupV1Controllers) {\n@@ -309,1 +203,0 @@\n-            this.infos = infos;\n@@ -327,4 +220,0 @@\n-\n-        public Map<String, CgroupInfo> getInfos() {\n-            return infos;\n-        }\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/CgroupSubsystemFactory.java","additions":41,"deletions":152,"binary":false,"changes":193,"status":"modified"},{"patch":"@@ -28,1 +28,4 @@\n-import java.util.Map;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.stream.Stream;\n@@ -30,1 +33,0 @@\n-import jdk.internal.platform.CgroupInfo;\n@@ -33,0 +35,1 @@\n+import jdk.internal.platform.CgroupUtil;\n@@ -41,0 +44,1 @@\n+    private boolean activeSubSystems;\n@@ -42,1 +46,1 @@\n-    private static volatile CgroupV1Subsystem INSTANCE;\n+    private static final CgroupV1Subsystem INSTANCE = initSubSystem();\n@@ -46,1 +50,3 @@\n-    private CgroupV1Subsystem() {}\n+    private CgroupV1Subsystem() {\n+        activeSubSystems = false;\n+    }\n@@ -48,8 +54,1 @@\n-    public static CgroupV1Subsystem getInstance(Map<String, CgroupInfo> infos) {\n-        if (INSTANCE == null) {\n-            synchronized (CgroupV1Subsystem.class) {\n-                if (INSTANCE == null) {\n-                    INSTANCE = initSubSystem(infos);\n-                }\n-            }\n-        }\n+    public static CgroupV1Subsystem getInstance() {\n@@ -59,1 +58,1 @@\n-    private static CgroupV1Subsystem initSubSystem(Map<String, CgroupInfo> infos) {\n+    private static CgroupV1Subsystem initSubSystem() {\n@@ -62,1 +61,0 @@\n-        boolean anyActiveControllers = false;\n@@ -65,1 +63,7 @@\n-         * by looking up relevant data in the infos map\n+         * by reading \/proc\/self\/mountinfo\n+         *\n+         * Example for docker MemorySubSystem subsystem:\n+         * 219 214 0:29 \/docker\/7208cebd00fa5f2e342b1094f7bed87fa25661471a4637118e65f1c995be8a34 \/sys\/fs\/cgroup\/MemorySubSystem ro,nosuid,nodev,noexec,relatime - cgroup cgroup rw,MemorySubSystem\n+         *\n+         * Example for host:\n+         * 34 28 0:29 \/ \/sys\/fs\/cgroup\/MemorySubSystem rw,nosuid,nodev,noexec,relatime shared:16 - cgroup cgroup rw,MemorySubSystem\n@@ -67,54 +71,43 @@\n-        for (CgroupInfo info: infos.values()) {\n-            switch (info.getName()) {\n-            case \"memory\": {\n-                if (info.getMountRoot() != null && info.getMountPoint() != null) {\n-                    CgroupV1MemorySubSystemController controller = new CgroupV1MemorySubSystemController(info.getMountRoot(), info.getMountPoint());\n-                    controller.setPath(info.getCgroupPath());\n-                    boolean isHierarchial = getHierarchical(controller);\n-                    controller.setHierarchical(isHierarchial);\n-                    boolean isSwapEnabled = getSwapEnabled(controller);\n-                    controller.setSwapEnabled(isSwapEnabled);\n-                    subsystem.setMemorySubSystem(controller);\n-                    anyActiveControllers = true;\n-                }\n-                break;\n-            }\n-            case \"cpuset\": {\n-                if (info.getMountRoot() != null && info.getMountPoint() != null) {\n-                    CgroupV1SubsystemController controller = new CgroupV1SubsystemController(info.getMountRoot(), info.getMountPoint());\n-                    controller.setPath(info.getCgroupPath());\n-                    subsystem.setCpuSetController(controller);\n-                    anyActiveControllers = true;\n-                }\n-                break;\n-            }\n-            case \"cpuacct\": {\n-                if (info.getMountRoot() != null && info.getMountPoint() != null) {\n-                    CgroupV1SubsystemController controller = new CgroupV1SubsystemController(info.getMountRoot(), info.getMountPoint());\n-                    controller.setPath(info.getCgroupPath());\n-                    subsystem.setCpuAcctController(controller);\n-                    anyActiveControllers = true;\n-                }\n-                break;\n-            }\n-            case \"cpu\": {\n-                if (info.getMountRoot() != null && info.getMountPoint() != null) {\n-                    CgroupV1SubsystemController controller = new CgroupV1SubsystemController(info.getMountRoot(), info.getMountPoint());\n-                    controller.setPath(info.getCgroupPath());\n-                    subsystem.setCpuController(controller);\n-                    anyActiveControllers = true;\n-                }\n-                break;\n-            }\n-            case \"blkio\": {\n-                if (info.getMountRoot() != null && info.getMountPoint() != null) {\n-                    CgroupV1SubsystemController controller = new CgroupV1SubsystemController(info.getMountRoot(), info.getMountPoint());\n-                    controller.setPath(info.getCgroupPath());\n-                    subsystem.setBlkIOController(controller);\n-                    anyActiveControllers = true;\n-                }\n-                break;\n-            }\n-            default:\n-                throw new AssertionError(\"Unrecognized controller in infos: \" + info.getName());\n-            }\n+        try (Stream<String> lines =\n+                CgroupUtil.readFilePrivileged(Paths.get(\"\/proc\/self\/mountinfo\"))) {\n+\n+            lines.filter(line -> line.contains(\" - cgroup \"))\n+                 .map(line -> line.split(\" \"))\n+                 .forEach(entry -> createSubSystemController(subsystem, entry));\n+\n+        } catch (IOException e) {\n+            return null;\n+        }\n+\n+        \/**\n+         * Read \/proc\/self\/cgroup and map host mount point to\n+         * local one via \/proc\/self\/mountinfo content above\n+         *\n+         * Docker example:\n+         * 5:memory:\/docker\/6558aed8fc662b194323ceab5b964f69cf36b3e8af877a14b80256e93aecb044\n+         *\n+         * Host example:\n+         * 5:memory:\/user.slice\n+         *\n+         * Construct a path to the process specific memory and cpuset\n+         * cgroup directory.\n+         *\n+         * For a container running under Docker from memory example above\n+         * the paths would be:\n+         *\n+         * \/sys\/fs\/cgroup\/memory\n+         *\n+         * For a Host from memory example above the path would be:\n+         *\n+         * \/sys\/fs\/cgroup\/memory\/user.slice\n+         *\n+         *\/\n+        try (Stream<String> lines =\n+                CgroupUtil.readFilePrivileged(Paths.get(\"\/proc\/self\/cgroup\"))) {\n+\n+            lines.map(line -> line.split(\":\"))\n+                 .filter(line -> (line.length >= 3))\n+                 .forEach(line -> setSubSystemControllerPath(subsystem, line));\n+\n+        } catch (IOException e) {\n+            return null;\n@@ -124,1 +117,1 @@\n-        if (anyActiveControllers) {\n+        if (subsystem.activeSubSystems()) {\n@@ -131,0 +124,89 @@\n+    \/**\n+     * createSubSystem objects and initialize mount points\n+     *\/\n+    private static void createSubSystemController(CgroupV1Subsystem subsystem, String[] mountentry) {\n+        if (mountentry.length < 5) return;\n+\n+        Path p = Paths.get(mountentry[4]);\n+        String[] subsystemNames = p.getFileName().toString().split(\",\");\n+\n+        for (String subsystemName: subsystemNames) {\n+            switch (subsystemName) {\n+                case \"memory\":\n+                    subsystem.setMemorySubSystem(new CgroupV1MemorySubSystemController(mountentry[3], mountentry[4]));\n+                    break;\n+                case \"cpuset\":\n+                    subsystem.setCpuSetController(new CgroupV1SubsystemController(mountentry[3], mountentry[4]));\n+                    break;\n+                case \"cpuacct\":\n+                    subsystem.setCpuAcctController(new CgroupV1SubsystemController(mountentry[3], mountentry[4]));\n+                    break;\n+                case \"cpu\":\n+                    subsystem.setCpuController(new CgroupV1SubsystemController(mountentry[3], mountentry[4]));\n+                    break;\n+                case \"blkio\":\n+                    subsystem.setBlkIOController(new CgroupV1SubsystemController(mountentry[3], mountentry[4]));\n+                    break;\n+                default:\n+                    \/\/ Ignore subsystems that we don't support\n+                    break;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * setSubSystemPath based on the contents of \/proc\/self\/cgroup\n+     *\/\n+    private static void setSubSystemControllerPath(CgroupV1Subsystem subsystem, String[] entry) {\n+        String controllerName;\n+        String base;\n+        CgroupV1SubsystemController controller = null;\n+        CgroupV1SubsystemController controller2 = null;\n+\n+        controllerName = entry[1];\n+        base = entry[2];\n+        if (controllerName != null && base != null) {\n+            switch (controllerName) {\n+                case \"memory\":\n+                    controller = subsystem.memoryController();\n+                    break;\n+                case \"cpuset\":\n+                    controller = subsystem.cpuSetController();\n+                    break;\n+                case \"cpu,cpuacct\":\n+                case \"cpuacct,cpu\":\n+                    controller = subsystem.cpuController();\n+                    controller2 = subsystem.cpuAcctController();\n+                    break;\n+                case \"cpuacct\":\n+                    controller = subsystem.cpuAcctController();\n+                    break;\n+                case \"cpu\":\n+                    controller = subsystem.cpuController();\n+                    break;\n+                case \"blkio\":\n+                    controller = subsystem.blkIOController();\n+                    break;\n+                \/\/ Ignore subsystems that we don't support\n+                default:\n+                    break;\n+            }\n+        }\n+\n+        if (controller != null) {\n+            controller.setPath(base);\n+            if (controller instanceof CgroupV1MemorySubSystemController) {\n+                CgroupV1MemorySubSystemController memorySubSystem = (CgroupV1MemorySubSystemController)controller;\n+                boolean isHierarchial = getHierarchical(memorySubSystem);\n+                memorySubSystem.setHierarchical(isHierarchial);\n+                boolean isSwapEnabled = getSwapEnabled(memorySubSystem);\n+                memorySubSystem.setSwapEnabled(isSwapEnabled);\n+            }\n+            subsystem.setActiveSubSystems();\n+        }\n+        if (controller2 != null) {\n+            controller2.setPath(base);\n+        }\n+    }\n+\n+\n@@ -142,0 +224,8 @@\n+    private void setActiveSubSystems() {\n+        activeSubSystems = true;\n+    }\n+\n+    private boolean activeSubSystems() {\n+        return activeSubSystems;\n+    }\n+\n@@ -162,0 +252,20 @@\n+    private CgroupV1SubsystemController memoryController() {\n+        return memory;\n+    }\n+\n+    private CgroupV1SubsystemController cpuController() {\n+        return cpu;\n+    }\n+\n+    private CgroupV1SubsystemController cpuAcctController() {\n+        return cpuacct;\n+    }\n+\n+    private CgroupV1SubsystemController cpuSetController() {\n+        return cpuset;\n+    }\n+\n+    private CgroupV1SubsystemController blkIOController() {\n+        return blkio;\n+    }\n+\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/cgroupv1\/CgroupV1Subsystem.java","additions":180,"deletions":70,"binary":false,"changes":250,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.util.List;\n@@ -33,0 +34,1 @@\n+import java.util.stream.Stream;\n@@ -34,1 +36,0 @@\n-import jdk.internal.platform.CgroupInfo;\n@@ -41,1 +42,1 @@\n-    private static volatile CgroupV2Subsystem INSTANCE;\n+    private static final CgroupV2Subsystem INSTANCE = initSubsystem();\n@@ -61,8 +62,24 @@\n-    public static CgroupSubsystem getInstance(CgroupInfo anyController) {\n-        if (INSTANCE == null) {\n-            synchronized (CgroupV2Subsystem.class) {\n-                if (INSTANCE == null) {\n-                    CgroupSubsystemController unified = new CgroupV2SubsystemController(\n-                            anyController.getMountPoint(),\n-                            anyController.getCgroupPath());\n-                    INSTANCE = new CgroupV2Subsystem(unified);\n+    private static CgroupV2Subsystem initSubsystem() {\n+        \/\/ read mountinfo so as to determine root mount path\n+        String mountPath = null;\n+        try (Stream<String> lines =\n+                CgroupUtil.readFilePrivileged(Paths.get(\"\/proc\/self\/mountinfo\"))) {\n+\n+            String l = lines.filter(line -> line.contains(\" - cgroup2 \"))\n+                            .collect(Collectors.joining());\n+            String[] tokens = l.split(\" \");\n+            mountPath = tokens[4];\n+        } catch (IOException e) {\n+            return null;\n+        }\n+        String cgroupPath = null;\n+        try {\n+            List<String> lines = CgroupUtil.readAllLinesPrivileged(Paths.get(\"\/proc\/self\/cgroup\"));\n+            for (String line: lines) {\n+                String[] tokens = line.split(\":\");\n+                if (tokens.length != 3) {\n+                    return null; \/\/ something is not right.\n+                }\n+                if (!\"0\".equals(tokens[0])) {\n+                    \/\/ hierarchy must be zero for cgroups v2\n+                    return null;\n@@ -70,0 +87,2 @@\n+                cgroupPath = tokens[2];\n+                break;\n@@ -71,0 +90,2 @@\n+        } catch (IOException e) {\n+            return null;\n@@ -72,0 +93,7 @@\n+        CgroupSubsystemController unified = new CgroupV2SubsystemController(\n+                mountPath,\n+                cgroupPath);\n+        return new CgroupV2Subsystem(unified);\n+    }\n+\n+    public static CgroupSubsystem getInstance() {\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/cgroupv2\/CgroupV2Subsystem.java","additions":38,"deletions":10,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -23,1 +23,0 @@\n-import static org.junit.Assert.assertEquals;\n@@ -38,1 +37,0 @@\n-import jdk.internal.platform.CgroupInfo;\n@@ -62,4 +60,0 @@\n-    private Path cgroupv1MntInfoDoubleCpusets;\n-    private Path cgroupv1MntInfoDoubleCpusets2;\n-    private Path cgroupv1SelfCgroup;\n-    private Path cgroupv2SelfCgroup;\n@@ -80,12 +74,12 @@\n-            \"31 30 0:27 \/ \/sys\/fs\/cgroup\/unified rw,nosuid,nodev,noexec,relatime shared:5 - cgroup2 none rw,seclabel,nsdelegate\\n\" +\n-            \"32 30 0:28 \/ \/sys\/fs\/cgroup\/systemd rw,nosuid,nodev,noexec,relatime shared:6 - cgroup none rw,seclabel,xattr,name=systemd\\n\" +\n-            \"35 30 0:31 \/ \/sys\/fs\/cgroup\/memory rw,nosuid,nodev,noexec,relatime shared:7 - cgroup none rw,seclabel,memory\\n\" +\n-            \"36 30 0:32 \/ \/sys\/fs\/cgroup\/pids rw,nosuid,nodev,noexec,relatime shared:8 - cgroup none rw,seclabel,pids\\n\" +\n-            \"37 30 0:33 \/ \/sys\/fs\/cgroup\/perf_event rw,nosuid,nodev,noexec,relatime shared:9 - cgroup none rw,seclabel,perf_event\\n\" +\n-            \"38 30 0:34 \/ \/sys\/fs\/cgroup\/net_cls,net_prio rw,nosuid,nodev,noexec,relatime shared:10 - cgroup none rw,seclabel,net_cls,net_prio\\n\" +\n-            \"39 30 0:35 \/ \/sys\/fs\/cgroup\/hugetlb rw,nosuid,nodev,noexec,relatime shared:11 - cgroup none rw,seclabel,hugetlb\\n\" +\n-            \"40 30 0:36 \/ \/sys\/fs\/cgroup\/cpu,cpuacct rw,nosuid,nodev,noexec,relatime shared:12 - cgroup none rw,seclabel,cpu,cpuacct\\n\" +\n-            \"41 30 0:37 \/ \/sys\/fs\/cgroup\/devices rw,nosuid,nodev,noexec,relatime shared:13 - cgroup none rw,seclabel,devices\\n\" +\n-            \"42 30 0:38 \/ \/sys\/fs\/cgroup\/cpuset rw,nosuid,nodev,noexec,relatime shared:14 - cgroup none rw,seclabel,cpuset\\n\" +\n-            \"43 30 0:39 \/ \/sys\/fs\/cgroup\/blkio rw,nosuid,nodev,noexec,relatime shared:15 - cgroup none rw,seclabel,blkio\\n\" +\n-            \"44 30 0:40 \/ \/sys\/fs\/cgroup\/freezer rw,nosuid,nodev,noexec,relatime shared:16 - cgroup none rw,seclabel,freezer\\n\";\n+            \"31 30 0:27 \/ \/sys\/fs\/cgroup\/unified rw,nosuid,nodev,noexec,relatime shared:5 - cgroup2 cgroup2 rw,seclabel,nsdelegate\\n\" +\n+            \"32 30 0:28 \/ \/sys\/fs\/cgroup\/systemd rw,nosuid,nodev,noexec,relatime shared:6 - cgroup cgroup rw,seclabel,xattr,name=systemd\\n\" +\n+            \"35 30 0:31 \/ \/sys\/fs\/cgroup\/memory rw,nosuid,nodev,noexec,relatime shared:7 - cgroup cgroup rw,seclabel,memory\\n\" +\n+            \"36 30 0:32 \/ \/sys\/fs\/cgroup\/pids rw,nosuid,nodev,noexec,relatime shared:8 - cgroup cgroup rw,seclabel,pids\\n\" +\n+            \"37 30 0:33 \/ \/sys\/fs\/cgroup\/perf_event rw,nosuid,nodev,noexec,relatime shared:9 - cgroup cgroup rw,seclabel,perf_event\\n\" +\n+            \"38 30 0:34 \/ \/sys\/fs\/cgroup\/net_cls,net_prio rw,nosuid,nodev,noexec,relatime shared:10 - cgroup cgroup rw,seclabel,net_cls,net_prio\\n\" +\n+            \"39 30 0:35 \/ \/sys\/fs\/cgroup\/hugetlb rw,nosuid,nodev,noexec,relatime shared:11 - cgroup cgroup rw,seclabel,hugetlb\\n\" +\n+            \"40 30 0:36 \/ \/sys\/fs\/cgroup\/cpu,cpuacct rw,nosuid,nodev,noexec,relatime shared:12 - cgroup cgroup rw,seclabel,cpu,cpuacct\\n\" +\n+            \"41 30 0:37 \/ \/sys\/fs\/cgroup\/devices rw,nosuid,nodev,noexec,relatime shared:13 - cgroup cgroup rw,seclabel,devices\\n\" +\n+            \"42 30 0:38 \/ \/sys\/fs\/cgroup\/cpuset rw,nosuid,nodev,noexec,relatime shared:14 - cgroup cgroup rw,seclabel,cpuset\\n\" +\n+            \"43 30 0:39 \/ \/sys\/fs\/cgroup\/blkio rw,nosuid,nodev,noexec,relatime shared:15 - cgroup cgroup rw,seclabel,blkio\\n\" +\n+            \"44 30 0:40 \/ \/sys\/fs\/cgroup\/freezer rw,nosuid,nodev,noexec,relatime shared:16 - cgroup cgroup rw,seclabel,freezer\";\n@@ -107,1 +101,1 @@\n-            \"28 21 0:25 \/ \/sys\/fs\/cgroup rw,nosuid,nodev,noexec,relatime shared:4 - cgroup2 none rw,seclabel,nsdelegate\";\n+            \"28 21 0:25 \/ \/sys\/fs\/cgroup rw,nosuid,nodev,noexec,relatime shared:4 - cgroup2 cgroup2 rw,seclabel,nsdelegate\";\n@@ -111,16 +105,0 @@\n-    private String cgroupv1SelfCgroupContent = \"11:memory:\/user.slice\/user-1000.slice\/user@1000.service\\n\" +\n-            \"10:hugetlb:\/\\n\" +\n-            \"9:cpuset:\/\\n\" +\n-            \"8:pids:\/user.slice\/user-1000.slice\/user@1000.service\\n\" +\n-            \"7:freezer:\/\\n\" +\n-            \"6:blkio:\/\\n\" +\n-            \"5:net_cls,net_prio:\/\\n\" +\n-            \"4:devices:\/user.slice\\n\" +\n-            \"3:perf_event:\/\\n\" +\n-            \"2:cpu,cpuacct:\/\\n\" +\n-            \"1:name=systemd:\/user.slice\/user-1000.slice\/user@1000.service\/apps.slice\/apps-org.gnome.Terminal.slice\/vte-spawn-3c00b338-5b65-439f-8e97-135e183d135d.scope\\n\" +\n-            \"0::\/user.slice\/user-1000.slice\/user@1000.service\/apps.slice\/apps-org.gnome.Terminal.slice\/vte-spawn-3c00b338-5b65-439f-8e97-135e183d135d.scope\\n\";\n-    private String cgroupv2SelfCgroupContent = \"0::\/user.slice\/user-1000.slice\/session-2.scope\";\n-    private String mntInfoCgroupv1MoreCpusetLine = \"121 32 0:37 \/ \/cpuset rw,relatime shared:69 - cgroup none rw,cpuset\\n\";\n-    private String mntInfoCgroupsV1DoubleCpuset = mntInfoHybrid + mntInfoCgroupv1MoreCpusetLine;\n-    private String mntInfoCgroupsV1DoubleCpuset2 = mntInfoCgroupv1MoreCpusetLine + mntInfoHybrid;\n@@ -150,13 +128,0 @@\n-\n-            cgroupv1SelfCgroup = Paths.get(existingDirectory.toString(), \"self_cgroup_cgv1\");\n-            Files.writeString(cgroupv1SelfCgroup, cgroupv1SelfCgroupContent);\n-\n-            cgroupv2SelfCgroup = Paths.get(existingDirectory.toString(), \"self_cgroup_cgv2\");\n-            Files.writeString(cgroupv2SelfCgroup, cgroupv2SelfCgroupContent);\n-\n-\n-            cgroupv1MntInfoDoubleCpusets = Paths.get(existingDirectory.toString(), \"mountinfo_cgroupv1_double_cpuset\");\n-            Files.writeString(cgroupv1MntInfoDoubleCpusets, mntInfoCgroupsV1DoubleCpuset);\n-\n-            cgroupv1MntInfoDoubleCpusets2 = Paths.get(existingDirectory.toString(), \"mountinfo_cgroupv1_double_cpuset2\");\n-            Files.writeString(cgroupv1MntInfoDoubleCpusets2, mntInfoCgroupsV1DoubleCpuset2);\n@@ -181,2 +146,1 @@\n-        String selfCgroup = cgroupv1SelfCgroup.toString(); \/\/ Content doesn't matter\n-        Optional<CgroupTypeResult> result = CgroupSubsystemFactory.determineType(mountInfo, cgroups, selfCgroup);\n+        Optional<CgroupTypeResult> result = CgroupSubsystemFactory.determineType(mountInfo, cgroups);\n@@ -187,19 +151,0 @@\n-    @Test\n-    public void testCgroupv1MultipleCpusetMounts() throws IOException {\n-        doMultipleCpusetMountsTest(cgroupv1MntInfoDoubleCpusets);\n-        doMultipleCpusetMountsTest(cgroupv1MntInfoDoubleCpusets2);\n-    }\n-\n-    private void doMultipleCpusetMountsTest(Path info) throws IOException {\n-        String cgroups = cgroupv1CgInfoNonZeroHierarchy.toString();\n-        String mountInfo = info.toString();\n-        String selfCgroup = cgroupv1SelfCgroup.toString();\n-        Optional<CgroupTypeResult> result = CgroupSubsystemFactory.determineType(mountInfo, cgroups, selfCgroup);\n-\n-        assertTrue(\"Expected non-empty cgroup result\", result.isPresent());\n-        CgroupTypeResult res = result.get();\n-        assertFalse(\"Duplicate cpuset mounts should pick the right controller\", res.isCgroupV2());\n-        CgroupInfo cpuSetsInfo = res.getInfos().get(\"cpuset\");\n-        assertEquals(\"Should pick the one mounted at \/sys\/fs\/cgroup\", \"\/sys\/fs\/cgroup\/cpuset\", cpuSetsInfo.getMountPoint());\n-    }\n-\n@@ -210,2 +155,1 @@\n-        String selfCgroup = cgroupv1SelfCgroup.toString();\n-        Optional<CgroupTypeResult> result = CgroupSubsystemFactory.determineType(mountInfo, cgroups, selfCgroup);\n+        Optional<CgroupTypeResult> result = CgroupSubsystemFactory.determineType(mountInfo, cgroups);\n@@ -216,4 +160,0 @@\n-        CgroupInfo memoryInfo = res.getInfos().get(\"memory\");\n-        assertEquals(\"\/user.slice\/user-1000.slice\/user@1000.service\", memoryInfo.getCgroupPath());\n-        assertEquals(\"\/\", memoryInfo.getMountRoot());\n-        assertEquals(\"\/sys\/fs\/cgroup\/memory\", memoryInfo.getMountPoint());\n@@ -226,2 +166,1 @@\n-        String selfCgroup = cgroupv1SelfCgroup.toString(); \/\/ Content doesn't matter\n-        Optional<CgroupTypeResult> result = CgroupSubsystemFactory.determineType(mountInfo, cgroups, selfCgroup);\n+        Optional<CgroupTypeResult> result = CgroupSubsystemFactory.determineType(mountInfo, cgroups);\n@@ -236,2 +175,1 @@\n-        String selfCgroup = cgroupv2SelfCgroup.toString();\n-        Optional<CgroupTypeResult> result = CgroupSubsystemFactory.determineType(mountInfo, cgroups, selfCgroup);\n+        Optional<CgroupTypeResult> result = CgroupSubsystemFactory.determineType(mountInfo, cgroups);\n@@ -243,7 +181,0 @@\n-        CgroupInfo memoryInfo = res.getInfos().get(\"memory\");\n-        assertEquals(\"\/user.slice\/user-1000.slice\/session-2.scope\", memoryInfo.getCgroupPath());\n-        CgroupInfo cpuInfo = res.getInfos().get(\"cpu\");\n-        assertEquals(memoryInfo.getCgroupPath(), cpuInfo.getCgroupPath());\n-        assertEquals(memoryInfo.getMountPoint(), cpuInfo.getMountPoint());\n-        assertEquals(memoryInfo.getMountRoot(), cpuInfo.getMountRoot());\n-        assertEquals(\"\/sys\/fs\/cgroup\", cpuInfo.getMountPoint());\n@@ -255,1 +186,0 @@\n-        String selfCgroup = cgroupv1SelfCgroup.toString(); \/\/ any existing file\n@@ -258,1 +188,1 @@\n-        CgroupSubsystemFactory.determineType(mountInfo, cgroups, selfCgroup);\n+        CgroupSubsystemFactory.determineType(mountInfo, cgroups);\n@@ -265,2 +195,1 @@\n-        String selfCgroup = cgroupv2SelfCgroup.toString(); \/\/ any existing file\n-        CgroupSubsystemFactory.determineType(mountInfo, cgroups, selfCgroup);\n+        CgroupSubsystemFactory.determineType(mountInfo, cgroups);\n","filename":"test\/jdk\/jdk\/internal\/platform\/cgroup\/TestCgroupSubsystemFactory.java","additions":19,"deletions":90,"binary":false,"changes":109,"status":"modified"}]}