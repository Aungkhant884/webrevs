{"files":[{"patch":"@@ -297,1 +297,0 @@\n-      any_cgroup_mounts_found = true;\n@@ -300,0 +299,1 @@\n+          any_cgroup_mounts_found = true;\n@@ -305,0 +305,1 @@\n+          any_cgroup_mounts_found = true;\n@@ -324,0 +325,1 @@\n+          any_cgroup_mounts_found = true;\n@@ -329,0 +331,1 @@\n+          any_cgroup_mounts_found = true;\n@@ -342,1 +345,1 @@\n-    log_trace(os, container)(\"No cgroup controllers mounted.\");\n+    log_trace(os, container)(\"No relevant cgroup controllers mounted.\");\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -29,1 +29,2 @@\n- * Data structure to hold info from \/proc\/self\/cgroup\n+ * Data structure to hold info from \/proc\/self\/cgroup,\n+ * \/proc\/cgroups and \/proc\/self\/mountinfo\n@@ -35,1 +36,1 @@\n-class CgroupInfo {\n+public class CgroupInfo {\n@@ -40,0 +41,3 @@\n+    private String mountPoint;\n+    private String mountRoot;\n+    private String cgroupPath;\n@@ -47,1 +51,1 @@\n-    String getName() {\n+    public String getName() {\n@@ -51,1 +55,1 @@\n-    int getHierarchyId() {\n+    public int getHierarchyId() {\n@@ -55,1 +59,1 @@\n-    boolean isEnabled() {\n+    public boolean isEnabled() {\n@@ -59,0 +63,24 @@\n+    public String getMountPoint() {\n+        return mountPoint;\n+    }\n+\n+    public void setMountPoint(String mountPoint) {\n+        this.mountPoint = mountPoint;\n+    }\n+\n+    public String getMountRoot() {\n+        return mountRoot;\n+    }\n+\n+    public void setMountRoot(String mountRoot) {\n+        this.mountRoot = mountRoot;\n+    }\n+\n+    public String getCgroupPath() {\n+        return cgroupPath;\n+    }\n+\n+    public void setCgroupPath(String cgroupPath) {\n+        this.cgroupPath = cgroupPath;\n+    }\n+\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/CgroupInfo.java","additions":33,"deletions":5,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.nio.file.Path;\n@@ -32,0 +33,1 @@\n+import java.util.Collections;\n@@ -36,0 +38,3 @@\n+import java.util.function.Consumer;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n@@ -49,0 +54,25 @@\n+    \/*\n+     * From https:\/\/www.kernel.org\/doc\/Documentation\/filesystems\/proc.txt\n+     *\n+     *  36 35 98:0 \/mnt1 \/mnt2 rw,noatime master:1 - ext3 \/dev\/root rw,errors=continue\n+     *  (1)(2)(3)   (4)   (5)      (6)      (7)   (8) (9)   (10)         (11)\n+     *\n+     *  (1) mount ID:  unique identifier of the mount (may be reused after umount)\n+     *  (2) parent ID:  ID of parent (or of self for the top of the mount tree)\n+     *  (3) major:minor:  value of st_dev for files on filesystem\n+     *  (4) root:  root of the mount within the filesystem\n+     *  (5) mount point:  mount point relative to the process's root\n+     *  (6) mount options:  per mount options\n+     *  (7) optional fields:  zero or more fields of the form \"tag[:value]\"\n+     *  (8) separator:  marks the end of the optional fields\n+     *  (9) filesystem type:  name of filesystem of the form \"type[.subtype]\"\n+     *  (10) mount source:  filesystem specific information or \"none\"\n+     *  (11) super options:  per super block options\n+     *\/\n+    private static final Pattern MOUNTINFO_PATTERN = Pattern.compile(\n+        \"^[^\\\\s]+\\\\s+[^\\\\s]+\\\\s+[^\\\\s]+\\\\s+\" + \/\/ (1), (2), (3)\n+        \"([^\\\\s]+)\\\\s+([^\\\\s]+)\\\\s+\" +         \/\/ (4), (5)     - group 1, 2\n+        \"[^-]+-\\\\s+\" +                         \/\/ (6), (7), (8)\n+        \"([^\\\\s]+)\\\\s+\" +                      \/\/ (9)          - group 3, filesystem type\n+        \".*$\");                                \/\/ (10), (11)\n+\n@@ -52,1 +82,1 @@\n-            optResult = determineType(\"\/proc\/self\/mountinfo\", \"\/proc\/cgroups\");\n+            optResult = determineType(\"\/proc\/self\/mountinfo\", \"\/proc\/cgroups\", \"\/proc\/self\/cgroup\");\n@@ -76,0 +106,1 @@\n+        Map<String, CgroupInfo> infos = result.getInfos();\n@@ -77,1 +108,3 @@\n-            CgroupSubsystem subsystem = CgroupV2Subsystem.getInstance();\n+            \/\/ For unified it doesn't matter which controller we pick.\n+            CgroupInfo anyController = infos.get(MEMORY_CTRL);\n+            CgroupSubsystem subsystem = CgroupV2Subsystem.getInstance(anyController);\n@@ -80,1 +113,1 @@\n-            CgroupV1Subsystem subsystem = CgroupV1Subsystem.getInstance();\n+            CgroupV1Subsystem subsystem = CgroupV1Subsystem.getInstance(infos);\n@@ -85,2 +118,4 @@\n-    public static Optional<CgroupTypeResult> determineType(String mountInfo, String cgroups) throws IOException {\n-        Map<String, CgroupInfo> infos = new HashMap<>();\n+    public static Optional<CgroupTypeResult> determineType(String mountInfo,\n+                                                           String cgroups,\n+                                                           String selfCgroup) throws IOException {\n+        final Map<String, CgroupInfo> infos = new HashMap<>();\n@@ -117,2 +152,2 @@\n-        \/\/ If there are no mounted controllers in mountinfo, but we've only\n-        \/\/ seen 0 hierarchy IDs in \/proc\/cgroups, we are on a cgroups v1 system.\n+        \/\/ If there are no mounted, relevant cgroup controllers in mountinfo and only\n+        \/\/ 0 hierarchy IDs in \/proc\/cgroups have been seen, we are on a cgroups v1 system.\n@@ -120,5 +155,17 @@\n-        \/\/ information from mountinfo for the mounted controller paths anyway.\n-        try (Stream<String> mntInfo = CgroupUtil.readFilePrivileged(Paths.get(mountInfo))) {\n-            boolean anyCgroupMounted = mntInfo.anyMatch(line -> line.contains(\"cgroup\"));\n-            if (!anyCgroupMounted && isCgroupsV2) {\n-                return Optional.empty();\n+        \/\/ information from mountinfo for the mounted controller paths which we wouldn't\n+        \/\/ find anyway in that case.\n+        lines = CgroupUtil.readAllLinesPrivileged(Paths.get(mountInfo));\n+        boolean anyCgroupMounted = false;\n+        for (String line: lines) {\n+            boolean cgroupsControllerFound = amendCgroupInfos(line, infos, isCgroupsV2);\n+            anyCgroupMounted = anyCgroupMounted || cgroupsControllerFound;\n+        }\n+        if (!anyCgroupMounted) {\n+            return Optional.empty();\n+        }\n+\n+        try (Stream<String> selfCgroupLines =\n+             CgroupUtil.readFilePrivileged(Paths.get(selfCgroup))) {\n+            Consumer<String[]> action = (tokens -> setCgroupV1Path(infos, tokens));\n+            if (isCgroupsV2) {\n+                action = (tokens -> setCgroupV2Path(infos, tokens));\n@@ -126,0 +173,5 @@\n+            selfCgroupLines.map(line -> line.split(\":\"))\n+                     .filter(tokens -> (tokens.length >= 3))\n+                     .forEach(action);\n+        } catch (IOException e) {\n+            return Optional.empty();\n@@ -127,1 +179,6 @@\n-        CgroupTypeResult result = new CgroupTypeResult(isCgroupsV2, anyControllersEnabled, anyCgroupsV2Controller, anyCgroupsV1Controller);\n+\n+        CgroupTypeResult result = new CgroupTypeResult(isCgroupsV2,\n+                                                       anyControllersEnabled,\n+                                                       anyCgroupsV2Controller,\n+                                                       anyCgroupsV1Controller,\n+                                                       Collections.unmodifiableMap(infos));\n@@ -131,0 +188,105 @@\n+    private static void setCgroupV2Path(Map<String, CgroupInfo> infos,\n+                                        String[] tokens) {\n+        int hierarchyId = Integer.parseInt(tokens[0]);\n+        String cgroupPath = tokens[2];\n+        for (CgroupInfo info: infos.values()) {\n+            assert hierarchyId == info.getHierarchyId() && hierarchyId == 0;\n+            info.setCgroupPath(cgroupPath);\n+        }\n+    }\n+\n+    private static void setCgroupV1Path(Map<String, CgroupInfo> infos,\n+                                        String[] tokens) {\n+        String controllerName = tokens[1];\n+        String cgroupPath = tokens[2];\n+        if (controllerName != null && cgroupPath != null) {\n+            for (String cName: controllerName.split(\",\")) {\n+                switch (cName) {\n+                    case MEMORY_CTRL: \/\/ fall through\n+                    case CPUSET_CTRL:\n+                    case CPUACCT_CTRL:\n+                    case CPU_CTRL:\n+                    case BLKIO_CTRL:\n+                        CgroupInfo info = infos.get(cName);\n+                        info.setCgroupPath(cgroupPath);\n+                        break;\n+                    \/\/ Ignore not recognized controllers\n+                    default:\n+                        break;\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Amends cgroup infos with mount path and mount root.\n+     *\n+     * @return {@code true} iff a relevant controller has been found at the\n+     * given line\n+     *\/\n+    private static boolean amendCgroupInfos(String mntInfoLine,\n+                                            Map<String, CgroupInfo> infos,\n+                                            boolean isCgroupsV2) {\n+        Matcher lineMatcher = MOUNTINFO_PATTERN.matcher(mntInfoLine.trim());\n+        boolean cgroupv1ControllerFound = false;\n+        boolean cgroupv2ControllerFound = false;\n+        if (lineMatcher.matches()) {\n+            String mountRoot = lineMatcher.group(1);\n+            String mountPath = lineMatcher.group(2);\n+            String fsType = lineMatcher.group(3);\n+            if (fsType.equals(\"cgroup\")) {\n+                Path p = Paths.get(mountPath);\n+                String[] controllerNames = p.getFileName().toString().split(\",\");\n+                for (String controllerName: controllerNames) {\n+                    switch (controllerName) {\n+                        case MEMORY_CTRL: \/\/ fall-through\n+                        case CPU_CTRL:\n+                        case CPUACCT_CTRL:\n+                        case BLKIO_CTRL: {\n+                            CgroupInfo info = infos.get(controllerName);\n+                            assert info.getMountPoint() == null;\n+                            assert info.getMountRoot() == null;\n+                            info.setMountPoint(mountPath);\n+                            info.setMountRoot(mountRoot);\n+                            cgroupv1ControllerFound = true;\n+                            break;\n+                        }\n+                        case CPUSET_CTRL: {\n+                            CgroupInfo info = infos.get(controllerName);\n+                            if (info.getMountPoint() != null) {\n+                                \/\/ On some systems duplicate cpuset controllers get mounted in addition to\n+                                \/\/ the main cgroup controllers most likely under \/sys\/fs\/cgroup. In that\n+                                \/\/ case pick the one under \/sys\/fs\/cgroup and discard others.\n+                                if (!info.getMountPoint().startsWith(\"\/sys\/fs\/cgroup\")) {\n+                                    info.setMountPoint(mountPath);\n+                                    info.setMountRoot(mountRoot);\n+                                }\n+                            } else {\n+                                info.setMountPoint(mountPath);\n+                                info.setMountRoot(mountRoot);\n+                            }\n+                            cgroupv1ControllerFound = true;\n+                            break;\n+                        }\n+                        default:\n+                            \/\/ Ignore controllers which we don't recognize\n+                            break;\n+                    }\n+                }\n+            } else if (fsType.equals(\"cgroup2\")) {\n+                if (isCgroupsV2) { \/\/ will be false for hybrid\n+                    \/\/ All controllers have the same mount point and root mount\n+                    \/\/ for unified hierarchy.\n+                    for (CgroupInfo info: infos.values()) {\n+                        assert info.getMountPoint() == null;\n+                        assert info.getMountRoot() == null;\n+                        info.setMountPoint(mountPath);\n+                        info.setMountRoot(mountRoot);\n+                    }\n+                }\n+                cgroupv2ControllerFound = true;\n+            }\n+        }\n+        return cgroupv1ControllerFound || cgroupv2ControllerFound;\n+    }\n+\n@@ -136,0 +298,1 @@\n+        private final Map<String, CgroupInfo> infos;\n@@ -140,1 +303,2 @@\n-                                 boolean anyCgroupV1Controllers) {\n+                                 boolean anyCgroupV1Controllers,\n+                                 Map<String, CgroupInfo> infos) {\n@@ -145,0 +309,1 @@\n+            this.infos = infos;\n@@ -162,0 +327,4 @@\n+\n+        public Map<String, CgroupInfo> getInfos() {\n+            return infos;\n+        }\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/CgroupSubsystemFactory.java","additions":183,"deletions":14,"binary":false,"changes":197,"status":"modified"},{"patch":"@@ -28,4 +28,1 @@\n-import java.io.IOException;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.util.stream.Stream;\n+import java.util.Map;\n@@ -33,0 +30,1 @@\n+import jdk.internal.platform.CgroupInfo;\n@@ -35,1 +33,0 @@\n-import jdk.internal.platform.CgroupUtil;\n@@ -44,1 +41,0 @@\n-    private boolean activeSubSystems;\n@@ -46,1 +42,1 @@\n-    private static final CgroupV1Subsystem INSTANCE = initSubSystem();\n+    private static volatile CgroupV1Subsystem INSTANCE;\n@@ -50,3 +46,1 @@\n-    private CgroupV1Subsystem() {\n-        activeSubSystems = false;\n-    }\n+    private CgroupV1Subsystem() {}\n@@ -54,1 +48,8 @@\n-    public static CgroupV1Subsystem getInstance() {\n+    public static CgroupV1Subsystem getInstance(Map<String, CgroupInfo> infos) {\n+        if (INSTANCE == null) {\n+            synchronized (CgroupV1Subsystem.class) {\n+                if (INSTANCE == null) {\n+                    INSTANCE = initSubSystem(infos);\n+                }\n+            }\n+        }\n@@ -58,1 +59,1 @@\n-    private static CgroupV1Subsystem initSubSystem() {\n+    private static CgroupV1Subsystem initSubSystem(Map<String, CgroupInfo> infos) {\n@@ -61,0 +62,1 @@\n+        boolean anyActiveControllers = false;\n@@ -63,41 +65,1 @@\n-         * by reading \/proc\/self\/mountinfo\n-         *\n-         * Example for docker MemorySubSystem subsystem:\n-         * 219 214 0:29 \/docker\/7208cebd00fa5f2e342b1094f7bed87fa25661471a4637118e65f1c995be8a34 \/sys\/fs\/cgroup\/MemorySubSystem ro,nosuid,nodev,noexec,relatime - cgroup cgroup rw,MemorySubSystem\n-         *\n-         * Example for host:\n-         * 34 28 0:29 \/ \/sys\/fs\/cgroup\/MemorySubSystem rw,nosuid,nodev,noexec,relatime shared:16 - cgroup cgroup rw,MemorySubSystem\n-         *\/\n-        try (Stream<String> lines =\n-                CgroupUtil.readFilePrivileged(Paths.get(\"\/proc\/self\/mountinfo\"))) {\n-\n-            lines.filter(line -> line.contains(\" - cgroup \"))\n-                 .map(line -> line.split(\" \"))\n-                 .forEach(entry -> createSubSystemController(subsystem, entry));\n-\n-        } catch (IOException e) {\n-            return null;\n-        }\n-\n-        \/**\n-         * Read \/proc\/self\/cgroup and map host mount point to\n-         * local one via \/proc\/self\/mountinfo content above\n-         *\n-         * Docker example:\n-         * 5:memory:\/docker\/6558aed8fc662b194323ceab5b964f69cf36b3e8af877a14b80256e93aecb044\n-         *\n-         * Host example:\n-         * 5:memory:\/user.slice\n-         *\n-         * Construct a path to the process specific memory and cpuset\n-         * cgroup directory.\n-         *\n-         * For a container running under Docker from memory example above\n-         * the paths would be:\n-         *\n-         * \/sys\/fs\/cgroup\/memory\n-         *\n-         * For a Host from memory example above the path would be:\n-         *\n-         * \/sys\/fs\/cgroup\/memory\/user.slice\n-         *\n+         * by looking up relevant data in the infos map\n@@ -105,9 +67,54 @@\n-        try (Stream<String> lines =\n-                CgroupUtil.readFilePrivileged(Paths.get(\"\/proc\/self\/cgroup\"))) {\n-\n-            lines.map(line -> line.split(\":\"))\n-                 .filter(line -> (line.length >= 3))\n-                 .forEach(line -> setSubSystemControllerPath(subsystem, line));\n-\n-        } catch (IOException e) {\n-            return null;\n+        for (CgroupInfo info: infos.values()) {\n+            switch (info.getName()) {\n+            case \"memory\": {\n+                if (info.getMountRoot() != null && info.getMountPoint() != null) {\n+                    CgroupV1MemorySubSystemController controller = new CgroupV1MemorySubSystemController(info.getMountRoot(), info.getMountPoint());\n+                    controller.setPath(info.getCgroupPath());\n+                    boolean isHierarchial = getHierarchical(controller);\n+                    controller.setHierarchical(isHierarchial);\n+                    boolean isSwapEnabled = getSwapEnabled(controller);\n+                    controller.setSwapEnabled(isSwapEnabled);\n+                    subsystem.setMemorySubSystem(controller);\n+                    anyActiveControllers = true;\n+                }\n+                break;\n+            }\n+            case \"cpuset\": {\n+                if (info.getMountRoot() != null && info.getMountPoint() != null) {\n+                    CgroupV1SubsystemController controller = new CgroupV1SubsystemController(info.getMountRoot(), info.getMountPoint());\n+                    controller.setPath(info.getCgroupPath());\n+                    subsystem.setCpuSetController(controller);\n+                    anyActiveControllers = true;\n+                }\n+                break;\n+            }\n+            case \"cpuacct\": {\n+                if (info.getMountRoot() != null && info.getMountPoint() != null) {\n+                    CgroupV1SubsystemController controller = new CgroupV1SubsystemController(info.getMountRoot(), info.getMountPoint());\n+                    controller.setPath(info.getCgroupPath());\n+                    subsystem.setCpuAcctController(controller);\n+                    anyActiveControllers = true;\n+                }\n+                break;\n+            }\n+            case \"cpu\": {\n+                if (info.getMountRoot() != null && info.getMountPoint() != null) {\n+                    CgroupV1SubsystemController controller = new CgroupV1SubsystemController(info.getMountRoot(), info.getMountPoint());\n+                    controller.setPath(info.getCgroupPath());\n+                    subsystem.setCpuController(controller);\n+                    anyActiveControllers = true;\n+                }\n+                break;\n+            }\n+            case \"blkio\": {\n+                if (info.getMountRoot() != null && info.getMountPoint() != null) {\n+                    CgroupV1SubsystemController controller = new CgroupV1SubsystemController(info.getMountRoot(), info.getMountPoint());\n+                    controller.setPath(info.getCgroupPath());\n+                    subsystem.setBlkIOController(controller);\n+                    anyActiveControllers = true;\n+                }\n+                break;\n+            }\n+            default:\n+                throw new AssertionError(\"Unrecognized controller in infos: \" + info.getName());\n+            }\n@@ -117,1 +124,1 @@\n-        if (subsystem.activeSubSystems()) {\n+        if (anyActiveControllers) {\n@@ -124,89 +131,0 @@\n-    \/**\n-     * createSubSystem objects and initialize mount points\n-     *\/\n-    private static void createSubSystemController(CgroupV1Subsystem subsystem, String[] mountentry) {\n-        if (mountentry.length < 5) return;\n-\n-        Path p = Paths.get(mountentry[4]);\n-        String[] subsystemNames = p.getFileName().toString().split(\",\");\n-\n-        for (String subsystemName: subsystemNames) {\n-            switch (subsystemName) {\n-                case \"memory\":\n-                    subsystem.setMemorySubSystem(new CgroupV1MemorySubSystemController(mountentry[3], mountentry[4]));\n-                    break;\n-                case \"cpuset\":\n-                    subsystem.setCpuSetController(new CgroupV1SubsystemController(mountentry[3], mountentry[4]));\n-                    break;\n-                case \"cpuacct\":\n-                    subsystem.setCpuAcctController(new CgroupV1SubsystemController(mountentry[3], mountentry[4]));\n-                    break;\n-                case \"cpu\":\n-                    subsystem.setCpuController(new CgroupV1SubsystemController(mountentry[3], mountentry[4]));\n-                    break;\n-                case \"blkio\":\n-                    subsystem.setBlkIOController(new CgroupV1SubsystemController(mountentry[3], mountentry[4]));\n-                    break;\n-                default:\n-                    \/\/ Ignore subsystems that we don't support\n-                    break;\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * setSubSystemPath based on the contents of \/proc\/self\/cgroup\n-     *\/\n-    private static void setSubSystemControllerPath(CgroupV1Subsystem subsystem, String[] entry) {\n-        String controllerName;\n-        String base;\n-        CgroupV1SubsystemController controller = null;\n-        CgroupV1SubsystemController controller2 = null;\n-\n-        controllerName = entry[1];\n-        base = entry[2];\n-        if (controllerName != null && base != null) {\n-            switch (controllerName) {\n-                case \"memory\":\n-                    controller = subsystem.memoryController();\n-                    break;\n-                case \"cpuset\":\n-                    controller = subsystem.cpuSetController();\n-                    break;\n-                case \"cpu,cpuacct\":\n-                case \"cpuacct,cpu\":\n-                    controller = subsystem.cpuController();\n-                    controller2 = subsystem.cpuAcctController();\n-                    break;\n-                case \"cpuacct\":\n-                    controller = subsystem.cpuAcctController();\n-                    break;\n-                case \"cpu\":\n-                    controller = subsystem.cpuController();\n-                    break;\n-                case \"blkio\":\n-                    controller = subsystem.blkIOController();\n-                    break;\n-                \/\/ Ignore subsystems that we don't support\n-                default:\n-                    break;\n-            }\n-        }\n-\n-        if (controller != null) {\n-            controller.setPath(base);\n-            if (controller instanceof CgroupV1MemorySubSystemController) {\n-                CgroupV1MemorySubSystemController memorySubSystem = (CgroupV1MemorySubSystemController)controller;\n-                boolean isHierarchial = getHierarchical(memorySubSystem);\n-                memorySubSystem.setHierarchical(isHierarchial);\n-                boolean isSwapEnabled = getSwapEnabled(memorySubSystem);\n-                memorySubSystem.setSwapEnabled(isSwapEnabled);\n-            }\n-            subsystem.setActiveSubSystems();\n-        }\n-        if (controller2 != null) {\n-            controller2.setPath(base);\n-        }\n-    }\n-\n-\n@@ -224,8 +142,0 @@\n-    private void setActiveSubSystems() {\n-        activeSubSystems = true;\n-    }\n-\n-    private boolean activeSubSystems() {\n-        return activeSubSystems;\n-    }\n-\n@@ -252,20 +162,0 @@\n-    private CgroupV1SubsystemController memoryController() {\n-        return memory;\n-    }\n-\n-    private CgroupV1SubsystemController cpuController() {\n-        return cpu;\n-    }\n-\n-    private CgroupV1SubsystemController cpuAcctController() {\n-        return cpuacct;\n-    }\n-\n-    private CgroupV1SubsystemController cpuSetController() {\n-        return cpuset;\n-    }\n-\n-    private CgroupV1SubsystemController blkIOController() {\n-        return blkio;\n-    }\n-\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/cgroupv1\/CgroupV1Subsystem.java","additions":70,"deletions":180,"binary":false,"changes":250,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.util.List;\n@@ -34,1 +33,0 @@\n-import java.util.stream.Stream;\n@@ -36,0 +34,1 @@\n+import jdk.internal.platform.CgroupInfo;\n@@ -42,1 +41,1 @@\n-    private static final CgroupV2Subsystem INSTANCE = initSubsystem();\n+    private static volatile CgroupV2Subsystem INSTANCE;\n@@ -62,24 +61,8 @@\n-    private static CgroupV2Subsystem initSubsystem() {\n-        \/\/ read mountinfo so as to determine root mount path\n-        String mountPath = null;\n-        try (Stream<String> lines =\n-                CgroupUtil.readFilePrivileged(Paths.get(\"\/proc\/self\/mountinfo\"))) {\n-\n-            String l = lines.filter(line -> line.contains(\" - cgroup2 \"))\n-                            .collect(Collectors.joining());\n-            String[] tokens = l.split(\" \");\n-            mountPath = tokens[4];\n-        } catch (IOException e) {\n-            return null;\n-        }\n-        String cgroupPath = null;\n-        try {\n-            List<String> lines = CgroupUtil.readAllLinesPrivileged(Paths.get(\"\/proc\/self\/cgroup\"));\n-            for (String line: lines) {\n-                String[] tokens = line.split(\":\");\n-                if (tokens.length != 3) {\n-                    return null; \/\/ something is not right.\n-                }\n-                if (!\"0\".equals(tokens[0])) {\n-                    \/\/ hierarchy must be zero for cgroups v2\n-                    return null;\n+    public static CgroupSubsystem getInstance(CgroupInfo anyController) {\n+        if (INSTANCE == null) {\n+            synchronized (CgroupV2Subsystem.class) {\n+                if (INSTANCE == null) {\n+                    CgroupSubsystemController unified = new CgroupV2SubsystemController(\n+                            anyController.getMountPoint(),\n+                            anyController.getCgroupPath());\n+                    INSTANCE = new CgroupV2Subsystem(unified);\n@@ -87,2 +70,0 @@\n-                cgroupPath = tokens[2];\n-                break;\n@@ -90,2 +71,0 @@\n-        } catch (IOException e) {\n-            return null;\n@@ -93,7 +72,0 @@\n-        CgroupSubsystemController unified = new CgroupV2SubsystemController(\n-                mountPath,\n-                cgroupPath);\n-        return new CgroupV2Subsystem(unified);\n-    }\n-\n-    public static CgroupSubsystem getInstance() {\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/cgroupv2\/CgroupV2Subsystem.java","additions":10,"deletions":38,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+    private Path cgroupv1MntInfoSystemdOnly;\n@@ -131,0 +132,3 @@\n+    private String mntInfoCgroupsV1SystemdOnly =\n+            \"35 26 0:26 \/ \/sys\/fs\/cgroup\/systemd rw,nosuid,nodev,noexec,relatime - cgroup systemd rw,name=systemd\\n\" +\n+            \"26 18 0:19 \/ \/sys\/fs\/cgroup rw,relatime - tmpfs none rw,size=4k,mode=755\\n\";\n@@ -171,0 +175,3 @@\n+\n+            cgroupv1MntInfoSystemdOnly = Paths.get(existingDirectory.toString(), \"mnt_info_cgroupv1_systemd_only\");\n+            Files.writeString(cgroupv1MntInfoSystemdOnly, mntInfoCgroupsV1SystemdOnly);\n@@ -198,0 +205,10 @@\n+    public void testCgroupv1SystemdOnly(WhiteBox wb) {\n+        String procCgroups = cgroupv1CgInfoZeroHierarchy.toString();\n+        String procSelfCgroup = cgroupV1SelfCgroup.toString();\n+        String procSelfMountinfo = cgroupv1MntInfoSystemdOnly.toString();\n+        int retval = wb.validateCgroup(procCgroups, procSelfCgroup, procSelfMountinfo);\n+        Asserts.assertEQ(INVALID_CGROUPS_NO_MOUNT, retval, \"Only systemd mounted. Invalid\");\n+        Asserts.assertFalse(isValidCgroup(retval));\n+        System.out.println(\"testCgroupv1SystemdOnly PASSED!\");\n+    }\n+\n@@ -264,0 +281,1 @@\n+            test.testCgroupv1SystemdOnly(wb);\n","filename":"test\/hotspot\/jtreg\/containers\/cgroup\/CgroupSubsystemFactory.java","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -23,0 +23,1 @@\n+import static org.junit.Assert.assertEquals;\n@@ -37,0 +38,1 @@\n+import jdk.internal.platform.CgroupInfo;\n@@ -59,0 +61,5 @@\n+    private Path cgroupv1MntInfoSystemdOnly;\n+    private Path cgroupv1MntInfoDoubleCpusets;\n+    private Path cgroupv1MntInfoDoubleCpusets2;\n+    private Path cgroupv1SelfCgroup;\n+    private Path cgroupv2SelfCgroup;\n@@ -73,12 +80,12 @@\n-            \"31 30 0:27 \/ \/sys\/fs\/cgroup\/unified rw,nosuid,nodev,noexec,relatime shared:5 - cgroup2 cgroup2 rw,seclabel,nsdelegate\\n\" +\n-            \"32 30 0:28 \/ \/sys\/fs\/cgroup\/systemd rw,nosuid,nodev,noexec,relatime shared:6 - cgroup cgroup rw,seclabel,xattr,name=systemd\\n\" +\n-            \"35 30 0:31 \/ \/sys\/fs\/cgroup\/memory rw,nosuid,nodev,noexec,relatime shared:7 - cgroup cgroup rw,seclabel,memory\\n\" +\n-            \"36 30 0:32 \/ \/sys\/fs\/cgroup\/pids rw,nosuid,nodev,noexec,relatime shared:8 - cgroup cgroup rw,seclabel,pids\\n\" +\n-            \"37 30 0:33 \/ \/sys\/fs\/cgroup\/perf_event rw,nosuid,nodev,noexec,relatime shared:9 - cgroup cgroup rw,seclabel,perf_event\\n\" +\n-            \"38 30 0:34 \/ \/sys\/fs\/cgroup\/net_cls,net_prio rw,nosuid,nodev,noexec,relatime shared:10 - cgroup cgroup rw,seclabel,net_cls,net_prio\\n\" +\n-            \"39 30 0:35 \/ \/sys\/fs\/cgroup\/hugetlb rw,nosuid,nodev,noexec,relatime shared:11 - cgroup cgroup rw,seclabel,hugetlb\\n\" +\n-            \"40 30 0:36 \/ \/sys\/fs\/cgroup\/cpu,cpuacct rw,nosuid,nodev,noexec,relatime shared:12 - cgroup cgroup rw,seclabel,cpu,cpuacct\\n\" +\n-            \"41 30 0:37 \/ \/sys\/fs\/cgroup\/devices rw,nosuid,nodev,noexec,relatime shared:13 - cgroup cgroup rw,seclabel,devices\\n\" +\n-            \"42 30 0:38 \/ \/sys\/fs\/cgroup\/cpuset rw,nosuid,nodev,noexec,relatime shared:14 - cgroup cgroup rw,seclabel,cpuset\\n\" +\n-            \"43 30 0:39 \/ \/sys\/fs\/cgroup\/blkio rw,nosuid,nodev,noexec,relatime shared:15 - cgroup cgroup rw,seclabel,blkio\\n\" +\n-            \"44 30 0:40 \/ \/sys\/fs\/cgroup\/freezer rw,nosuid,nodev,noexec,relatime shared:16 - cgroup cgroup rw,seclabel,freezer\";\n+            \"31 30 0:27 \/ \/sys\/fs\/cgroup\/unified rw,nosuid,nodev,noexec,relatime shared:5 - cgroup2 none rw,seclabel,nsdelegate\\n\" +\n+            \"32 30 0:28 \/ \/sys\/fs\/cgroup\/systemd rw,nosuid,nodev,noexec,relatime shared:6 - cgroup none rw,seclabel,xattr,name=systemd\\n\" +\n+            \"35 30 0:31 \/ \/sys\/fs\/cgroup\/memory rw,nosuid,nodev,noexec,relatime shared:7 - cgroup none rw,seclabel,memory\\n\" +\n+            \"36 30 0:32 \/ \/sys\/fs\/cgroup\/pids rw,nosuid,nodev,noexec,relatime shared:8 - cgroup none rw,seclabel,pids\\n\" +\n+            \"37 30 0:33 \/ \/sys\/fs\/cgroup\/perf_event rw,nosuid,nodev,noexec,relatime shared:9 - cgroup none rw,seclabel,perf_event\\n\" +\n+            \"38 30 0:34 \/ \/sys\/fs\/cgroup\/net_cls,net_prio rw,nosuid,nodev,noexec,relatime shared:10 - cgroup none rw,seclabel,net_cls,net_prio\\n\" +\n+            \"39 30 0:35 \/ \/sys\/fs\/cgroup\/hugetlb rw,nosuid,nodev,noexec,relatime shared:11 - cgroup none rw,seclabel,hugetlb\\n\" +\n+            \"40 30 0:36 \/ \/sys\/fs\/cgroup\/cpu,cpuacct rw,nosuid,nodev,noexec,relatime shared:12 - cgroup none rw,seclabel,cpu,cpuacct\\n\" +\n+            \"41 30 0:37 \/ \/sys\/fs\/cgroup\/devices rw,nosuid,nodev,noexec,relatime shared:13 - cgroup none rw,seclabel,devices\\n\" +\n+            \"42 30 0:38 \/ \/sys\/fs\/cgroup\/cpuset rw,nosuid,nodev,noexec,relatime shared:14 - cgroup none rw,seclabel,cpuset\\n\" +\n+            \"43 30 0:39 \/ \/sys\/fs\/cgroup\/blkio rw,nosuid,nodev,noexec,relatime shared:15 - cgroup none rw,seclabel,blkio\\n\" +\n+            \"44 30 0:40 \/ \/sys\/fs\/cgroup\/freezer rw,nosuid,nodev,noexec,relatime shared:16 - cgroup none rw,seclabel,freezer\\n\";\n@@ -100,1 +107,20 @@\n-            \"28 21 0:25 \/ \/sys\/fs\/cgroup rw,nosuid,nodev,noexec,relatime shared:4 - cgroup2 cgroup2 rw,seclabel,nsdelegate\";\n+            \"28 21 0:25 \/ \/sys\/fs\/cgroup rw,nosuid,nodev,noexec,relatime shared:4 - cgroup2 none rw,seclabel,nsdelegate\";\n+    private String mntInfoCgroupsV1SystemdOnly =\n+            \"35 26 0:26 \/ \/sys\/fs\/cgroup\/systemd rw,nosuid,nodev,noexec,relatime - cgroup systemd rw,name=systemd\\n\" +\n+            \"26 18 0:19 \/ \/sys\/fs\/cgroup rw,relatime - tmpfs none rw,size=4k,mode=755\\n\";\n+    private String cgroupv1SelfCgroupContent = \"11:memory:\/user.slice\/user-1000.slice\/user@1000.service\\n\" +\n+            \"10:hugetlb:\/\\n\" +\n+            \"9:cpuset:\/\\n\" +\n+            \"8:pids:\/user.slice\/user-1000.slice\/user@1000.service\\n\" +\n+            \"7:freezer:\/\\n\" +\n+            \"6:blkio:\/\\n\" +\n+            \"5:net_cls,net_prio:\/\\n\" +\n+            \"4:devices:\/user.slice\\n\" +\n+            \"3:perf_event:\/\\n\" +\n+            \"2:cpu,cpuacct:\/\\n\" +\n+            \"1:name=systemd:\/user.slice\/user-1000.slice\/user@1000.service\/apps.slice\/apps-org.gnome.Terminal.slice\/vte-spawn-3c00b338-5b65-439f-8e97-135e183d135d.scope\\n\" +\n+            \"0::\/user.slice\/user-1000.slice\/user@1000.service\/apps.slice\/apps-org.gnome.Terminal.slice\/vte-spawn-3c00b338-5b65-439f-8e97-135e183d135d.scope\\n\";\n+    private String cgroupv2SelfCgroupContent = \"0::\/user.slice\/user-1000.slice\/session-2.scope\";\n+    private String mntInfoCgroupv1MoreCpusetLine = \"121 32 0:37 \/ \/cpuset rw,relatime shared:69 - cgroup none rw,cpuset\\n\";\n+    private String mntInfoCgroupsV1DoubleCpuset = mntInfoHybrid + mntInfoCgroupv1MoreCpusetLine;\n+    private String mntInfoCgroupsV1DoubleCpuset2 = mntInfoCgroupv1MoreCpusetLine + mntInfoHybrid;\n@@ -121,0 +147,16 @@\n+\n+            cgroupv1MntInfoSystemdOnly = Paths.get(existingDirectory.toString(), \"mountinfo_cgroupv1_systemd_only\");\n+            Files.writeString(cgroupv1MntInfoSystemdOnly, mntInfoCgroupsV1SystemdOnly);\n+\n+            cgroupv1SelfCgroup = Paths.get(existingDirectory.toString(), \"self_cgroup_cgv1\");\n+            Files.writeString(cgroupv1SelfCgroup, cgroupv1SelfCgroupContent);\n+\n+            cgroupv2SelfCgroup = Paths.get(existingDirectory.toString(), \"self_cgroup_cgv2\");\n+            Files.writeString(cgroupv2SelfCgroup, cgroupv2SelfCgroupContent);\n+\n+\n+            cgroupv1MntInfoDoubleCpusets = Paths.get(existingDirectory.toString(), \"mountinfo_cgroupv1_double_cpuset\");\n+            Files.writeString(cgroupv1MntInfoDoubleCpusets, mntInfoCgroupsV1DoubleCpuset);\n+\n+            cgroupv1MntInfoDoubleCpusets2 = Paths.get(existingDirectory.toString(), \"mountinfo_cgroupv1_double_cpuset2\");\n+            Files.writeString(cgroupv1MntInfoDoubleCpusets2, mntInfoCgroupsV1DoubleCpuset2);\n@@ -135,0 +177,29 @@\n+    @Test\n+    public void testCgroupv1SystemdOnly() throws IOException {\n+        String cgroups = cgroupv1CgInfoZeroHierarchy.toString();\n+        String mountInfo = cgroupv1MntInfoSystemdOnly.toString();\n+        String selfCgroup = cgroupv1SelfCgroup.toString(); \/\/ Content doesn't matter\n+        Optional<CgroupTypeResult> result = CgroupSubsystemFactory.determineType(mountInfo, cgroups, selfCgroup);\n+\n+        assertTrue(\"zero hierarchy ids with no *relevant* controllers mounted\", result.isEmpty());\n+    }\n+\n+    @Test\n+    public void testCgroupv1MultipleCpusetMounts() throws IOException {\n+        doMultipleCpusetMountsTest(cgroupv1MntInfoDoubleCpusets);\n+        doMultipleCpusetMountsTest(cgroupv1MntInfoDoubleCpusets2);\n+    }\n+\n+    private void doMultipleCpusetMountsTest(Path info) throws IOException {\n+        String cgroups = cgroupv1CgInfoNonZeroHierarchy.toString();\n+        String mountInfo = info.toString();\n+        String selfCgroup = cgroupv1SelfCgroup.toString();\n+        Optional<CgroupTypeResult> result = CgroupSubsystemFactory.determineType(mountInfo, cgroups, selfCgroup);\n+\n+        assertTrue(\"Expected non-empty cgroup result\", result.isPresent());\n+        CgroupTypeResult res = result.get();\n+        assertFalse(\"Duplicate cpuset mounts should pick the right controller\", res.isCgroupV2());\n+        CgroupInfo cpuSetsInfo = res.getInfos().get(\"cpuset\");\n+        assertEquals(\"Should pick the one mounted at \/sys\/fs\/cgroup\", \"\/sys\/fs\/cgroup\/cpuset\", cpuSetsInfo.getMountPoint());\n+    }\n+\n@@ -139,1 +210,2 @@\n-        Optional<CgroupTypeResult> result = CgroupSubsystemFactory.determineType(mountInfo, cgroups);\n+        String selfCgroup = cgroupv1SelfCgroup.toString();\n+        Optional<CgroupTypeResult> result = CgroupSubsystemFactory.determineType(mountInfo, cgroups, selfCgroup);\n@@ -144,0 +216,4 @@\n+        CgroupInfo memoryInfo = res.getInfos().get(\"memory\");\n+        assertEquals(\"\/user.slice\/user-1000.slice\/user@1000.service\", memoryInfo.getCgroupPath());\n+        assertEquals(\"\/\", memoryInfo.getMountRoot());\n+        assertEquals(\"\/sys\/fs\/cgroup\/memory\", memoryInfo.getMountPoint());\n@@ -150,1 +226,2 @@\n-        Optional<CgroupTypeResult> result = CgroupSubsystemFactory.determineType(mountInfo, cgroups);\n+        String selfCgroup = cgroupv1SelfCgroup.toString(); \/\/ Content doesn't matter\n+        Optional<CgroupTypeResult> result = CgroupSubsystemFactory.determineType(mountInfo, cgroups, selfCgroup);\n@@ -159,1 +236,2 @@\n-        Optional<CgroupTypeResult> result = CgroupSubsystemFactory.determineType(mountInfo, cgroups);\n+        String selfCgroup = cgroupv2SelfCgroup.toString();\n+        Optional<CgroupTypeResult> result = CgroupSubsystemFactory.determineType(mountInfo, cgroups, selfCgroup);\n@@ -165,0 +243,7 @@\n+        CgroupInfo memoryInfo = res.getInfos().get(\"memory\");\n+        assertEquals(\"\/user.slice\/user-1000.slice\/session-2.scope\", memoryInfo.getCgroupPath());\n+        CgroupInfo cpuInfo = res.getInfos().get(\"cpu\");\n+        assertEquals(memoryInfo.getCgroupPath(), cpuInfo.getCgroupPath());\n+        assertEquals(memoryInfo.getMountPoint(), cpuInfo.getMountPoint());\n+        assertEquals(memoryInfo.getMountRoot(), cpuInfo.getMountRoot());\n+        assertEquals(\"\/sys\/fs\/cgroup\", cpuInfo.getMountPoint());\n@@ -170,0 +255,1 @@\n+        String selfCgroup = cgroupv1SelfCgroup.toString(); \/\/ any existing file\n@@ -172,1 +258,1 @@\n-        CgroupSubsystemFactory.determineType(mountInfo, cgroups);\n+        CgroupSubsystemFactory.determineType(mountInfo, cgroups, selfCgroup);\n@@ -179,1 +265,2 @@\n-        CgroupSubsystemFactory.determineType(mountInfo, cgroups);\n+        String selfCgroup = cgroupv2SelfCgroup.toString(); \/\/ any existing file\n+        CgroupSubsystemFactory.determineType(mountInfo, cgroups, selfCgroup);\n","filename":"test\/jdk\/jdk\/internal\/platform\/cgroup\/TestCgroupSubsystemFactory.java","additions":105,"deletions":18,"binary":false,"changes":123,"status":"modified"}]}