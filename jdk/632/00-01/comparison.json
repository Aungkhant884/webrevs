{"files":[{"patch":"@@ -83,1 +83,1 @@\n-        private static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n+        private static final WhiteBox WB = WhiteBox.getWhiteBox();\n@@ -85,1 +85,10 @@\n-        private static void allocateHumongous(int num, int objSize, Queue keeper) {\n+        private static final int M = 1024 * 1024;\n+        \/\/ Make humongous object size 75% of region size\n+        private static final int HumongousObjectSize =\n+                (int)(HeapRegionSize * M * 0.75);\n+        \/\/ Number of objects to allocate to go above IHOP\n+        private static final int NumHumongousObjectAllocations =\n+                (int)(((HeapSize - YoungSize) * 80 \/ 100.0) \/ HeapRegionSize);\n+\n+\n+        private static void allocateHumongous(int num, Queue keeper) {\n@@ -89,1 +98,1 @@\n-                                       \" of size \" + objSize + \" bytes\");\n+                                       \" of size \" + HumongousObjectSize + \" bytes\");\n@@ -91,1 +100,1 @@\n-                byte[] e = new byte[objSize];\n+                byte[] e = new byte[HumongousObjectSize];\n@@ -99,5 +108,9 @@\n-        public static void main(String [] args) throws Exception {\n-            final int M = 1024 * 1024;\n-            \/\/ Make humongous object size 75% of region size\n-            final int humongousObjectSize =\n-                (int)(HeapRegionSize * M * 0.75);\n+        private static void runConcurrentUndoCycle(ArrayBlockingQueue a) {\n+            \/\/ Start from an \"empty\" heap.\n+            WB.fullGC();\n+            \/\/ The queue only holds one element, so only one humongous object\n+            \/\/ will be reachable and the concurrent operation should be undone.\n+            a = new ArrayBlockingQueue(1);\n+            allocateHumongous(NumHumongousObjectAllocations, a);\n+            Helpers.waitTillCMCFinished(WB, 1);\n+        }\n@@ -105,3 +118,22 @@\n-            \/\/ Number of objects to allocate to go above IHOP\n-            final int humongousObjectAllocations =\n-                (int)(((HeapSize - YoungSize) * 80 \/ 100.0) \/ HeapRegionSize);\n+        private static void runConcurrentMarkCycle(ArrayBlockingQueue a) {\n+            \/\/ Start from an \"empty\" heap.\n+            WB.fullGC();\n+            \/\/ Try to trigger a concurrent mark cycle. Block concurrent operation\n+            \/\/ while we are allocating more humongous objects than the IHOP threshold.\n+            \/\/ After releasing control, trigger the full cycle.\n+            try {\n+                System.out.println(\"Acquire CM control\");\n+                WB.concurrentGCAcquireControl();\n+                WB.concurrentGCRunToIdle();\n+\n+                allocateHumongous(NumHumongousObjectAllocations, a);\n+            } finally {\n+                System.out.println(\"Release CM control\");\n+                WB.concurrentGCReleaseControl();\n+            }\n+            \/\/ At this point we kept NumHumongousObjectAllocations humongous objects live\n+            \/\/ in \"a\" which is larger than the IHOP threshold. Another dummy humongous\n+            \/\/ allocation must trigger a concurrent cycle that is not an Undo Cycle.\n+            allocateHumongous(1, new ArrayBlockingQueue(1));\n+            Helpers.waitTillCMCFinished(WB, 1);\n+        }\n@@ -109,1 +141,2 @@\n-            ArrayBlockingQueue a;\n+        public static void main(String [] args) throws Exception {\n+            ArrayBlockingQueue a = null;\n@@ -111,4 +144,0 @@\n-                \/\/ Start from an \"empty\" heap.\n-                WHITE_BOX.fullGC();\n-                \/\/ The queue only holds one element, so only one humongous object\n-                \/\/ will be reachable and the concurrent operation should be undone.\n@@ -116,17 +145,4 @@\n-                allocateHumongous(humongousObjectAllocations, humongousObjectSize, a);\n-                Helpers.waitTillCMCFinished(WHITE_BOX, 1);\n-                a = null;\n-\n-                a = new ArrayBlockingQueue(humongousObjectAllocations);\n-                allocateHumongous(humongousObjectAllocations, humongousObjectSize, a);\n-                Helpers.waitTillCMCFinished(WHITE_BOX, 1);\n-                \/\/ At this point we keep humongousObjectAllocations humongous objects live\n-                \/\/ in \"a\" which is larger than the IHOP. We just waited for any pending\n-                \/\/ marking cycles. Another dummy allocation must trigger a humongous\n-                \/\/ allocation that is not an Undo Cycle.\n-                allocateHumongous(1, humongousObjectSize, new ArrayBlockingQueue(1));\n-                Helpers.waitTillCMCFinished(WHITE_BOX, 1);\n-                a = null;\n-\n-                allocateHumongous(1, humongousObjectSize, new ArrayBlockingQueue(1));\n-                Helpers.waitTillCMCFinished(WHITE_BOX, 1);\n+                runConcurrentUndoCycle(a);\n+\n+                a = new ArrayBlockingQueue(NumHumongousObjectAllocations);\n+                runConcurrentMarkCycle(a);\n@@ -134,0 +150,1 @@\n+            System.out.println(a);\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestHumongousConcurrentStartUndo.java","additions":51,"deletions":34,"binary":false,"changes":85,"status":"modified"}]}