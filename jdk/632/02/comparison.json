{"files":[{"patch":"@@ -48,2 +48,1 @@\n-import java.util.Queue;\n-import java.util.concurrent.ArrayBlockingQueue;\n+import java.lang.ref.Reference;\n@@ -83,1 +82,1 @@\n-        private static final WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n+        private static final WhiteBox WB = WhiteBox.getWhiteBox();\n@@ -85,2 +84,11 @@\n-        private static void allocateHumongous(int num, int objSize, Queue keeper) {\n-            for (int i = 1; i <= num; i++) {\n+        private static final int M = 1024 * 1024;\n+        \/\/ Make humongous object size 75% of region size\n+        private static final int HumongousObjectSize =\n+                (int)(HeapRegionSize * M * 0.75);\n+        \/\/ Number of objects to allocate to go above IHOP\n+        private static final int NumHumongousObjectAllocations =\n+                (int)(((HeapSize - YoungSize) * 80 \/ 100.0) \/ HeapRegionSize);\n+\n+\n+        private static void allocateHumongous(int num, Object[] holder) {\n+            for (int i = 0; i < num; i++) {\n@@ -89,6 +97,1 @@\n-                                       \" of size \" + objSize + \" bytes\");\n-                }\n-                byte[] e = new byte[objSize];\n-                if (!keeper.offer(e)) {\n-                    keeper.remove();\n-                    keeper.offer(e);\n+                                       \" of size \" + HumongousObjectSize + \" bytes\");\n@@ -96,0 +99,1 @@\n+                holder[i % holder.length] = new byte[HumongousObjectSize];\n@@ -99,5 +103,8 @@\n-        public static void main(String [] args) throws Exception {\n-            final int M = 1024 * 1024;\n-            \/\/ Make humongous object size 75% of region size\n-            final int humongousObjectSize =\n-                (int)(HeapRegionSize * M * 0.75);\n+        private static void runConcurrentUndoCycle() {\n+            \/\/ Start from an \"empty\" heap.\n+            WB.fullGC();\n+            \/\/ The queue only holds one element, so only one humongous object\n+            \/\/ will be reachable and the concurrent operation should be undone.\n+            allocateHumongous(NumHumongousObjectAllocations, new Object[1]);\n+            Helpers.waitTillCMCFinished(WB, 1);\n+        }\n@@ -105,3 +112,20 @@\n-            \/\/ Number of objects to allocate to go above IHOP\n-            final int humongousObjectAllocations =\n-                (int)(((HeapSize - YoungSize) * 80 \/ 100.0) \/ HeapRegionSize);\n+        private static void runConcurrentMarkCycle() {\n+            Object[] a = new Object[NumHumongousObjectAllocations];\n+            \/\/ Start from an \"empty\" heap.\n+            WB.fullGC();\n+            \/\/ Try to trigger a concurrent mark cycle. Block concurrent operation\n+            \/\/ while we are allocating more humongous objects than the IHOP threshold.\n+            \/\/ After releasing control, trigger the full cycle.\n+            try {\n+                System.out.println(\"Acquire CM control\");\n+                WB.concurrentGCAcquireControl();\n+                allocateHumongous(NumHumongousObjectAllocations, a);\n+            } finally {\n+                System.out.println(\"Release CM control\");\n+                WB.concurrentGCReleaseControl();\n+            }\n+            \/\/ At this point we kept NumHumongousObjectAllocations humongous objects live\n+            \/\/ in \"a\" which is larger than the IHOP threshold. Another dummy humongous\n+            \/\/ allocation must trigger a concurrent cycle that is not an Undo Cycle.\n+            allocateHumongous(1, new Object[1]);\n+            Helpers.waitTillCMCFinished(WB, 1);\n@@ -109,1 +133,4 @@\n-            ArrayBlockingQueue a;\n+            Reference.reachabilityFence(a);\n+        }\n+\n+        public static void main(String [] args) throws Exception {\n@@ -111,20 +138,2 @@\n-                \/\/ Start from an \"empty\" heap.\n-                WHITE_BOX.fullGC();\n-                \/\/ The queue only holds one element, so only one humongous object\n-                \/\/ will be reachable and the concurrent operation should be undone.\n-                a = new ArrayBlockingQueue(1);\n-                allocateHumongous(humongousObjectAllocations, humongousObjectSize, a);\n-                Helpers.waitTillCMCFinished(WHITE_BOX, 1);\n-                a = null;\n-\n-                \/\/ Start from an \"empty\" heap.\n-                WHITE_BOX.fullGC();\n-                \/\/ The queue only holds all elements, so all humongous object\n-                \/\/ will be reachable and the concurrent operation should be a regular mark.\n-                a = new ArrayBlockingQueue(humongousObjectAllocations);\n-                allocateHumongous(humongousObjectAllocations, humongousObjectSize, a);\n-                Helpers.waitTillCMCFinished(WHITE_BOX, 1);\n-                a = null;\n-\n-                allocateHumongous(1, humongousObjectSize, new ArrayBlockingQueue(1));\n-                Helpers.waitTillCMCFinished(WHITE_BOX, 1);\n+                runConcurrentUndoCycle();\n+                runConcurrentMarkCycle();\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestHumongousConcurrentStartUndo.java","additions":49,"deletions":40,"binary":false,"changes":89,"status":"modified"}]}