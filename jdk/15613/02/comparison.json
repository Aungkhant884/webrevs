{"files":[{"patch":"@@ -112,0 +112,1 @@\n+  product(bool, UseZtso, false, EXPERIMENTAL, \"Assume Ztso memory model\")        \\\n","filename":"src\/hotspot\/cpu\/riscv\/globals_riscv.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -379,0 +379,14 @@\n+  void fence(uint32_t predecessor, uint32_t successor) {\n+    if (UseZtso) {\n+      if (pred_succ_to_membar_mask(predecessor, successor) & StoreLoad) {\n+        \/\/ TSO allows for stores to be reordered after loads. When the compiler\n+        \/\/ generates a fence to disallow that, we are required to generate the\n+        \/\/ fence for correctness.\n+      } else {\n+        \/\/ TSO guarantees other fences already.\n+        return;\n+      }\n+    }\n+    Assembler::fence(predecessor, successor);\n+  }\n+\n@@ -380,1 +394,1 @@\n-    fence(w, 0);\n+    Assembler::fence(w, 0);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -213,0 +213,8 @@\n+#if TARGET_ZTSO\n+  \/\/ Hotspot is compiled with TSO support, it will only run on hardware which\n+  \/\/ supports Ztso\n+  if (FLAG_IS_DEFAULT(UseZtso)) {\n+    FLAG_SET_DEFAULT(UseZtso, true);\n+  }\n+#endif\n+\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -137,0 +137,1 @@\n+  decl(ext_Ztso        , \"Ztso\"        , RV_NO_FLAG_BIT, true , UPDATE_DEFAULT(UseZtso))        \\\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -239,0 +239,1 @@\n+  ext_Ztso.enable_feature();\n","filename":"src\/hotspot\/os_cpu\/linux_riscv\/vm_version_linux_riscv.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}