{"files":[{"patch":"@@ -29,0 +29,1 @@\n+#include \"opto\/compile.hpp\"\n@@ -1657,0 +1658,13 @@\n+\n+bool C2_MacroAssembler::emit_trampoline_stub(int insts_call_instruction_offset, address target) {\n+  if (ciEnv::current()->task() != NULL) {\n+    PhaseOutput* phase_output = Compile::current()->output();\n+    if (phase_output != NULL && phase_output->in_scratch_emit_size()) {\n+      \/\/ We don't want to emit a trampoline if C2 is generating dummy\n+      \/\/ code during its branch shortening phase.\n+      return true;\n+    }\n+  }\n+  return MacroAssembler::emit_trampoline_stub(insts_call_instruction_offset, target);\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -30,0 +30,8 @@\n+ private:\n+  \/\/ If the phase output is in the scratch emit size mode,\n+  \/\/ no trampoline is emitted and true returned.\n+  \/\/\n+  \/\/ Note: To unconditionally emit a trampoline stub,\n+  \/\/ MacroAssembler::emit_trampoline_stub must be used.\n+  virtual bool emit_trampoline_stub(int insts_call_instruction_offset, address target) override;\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -854,2 +854,1 @@\n-address MacroAssembler::trampoline_call(Address entry, CodeBuffer* cbuf,\n-                                        bool check_emit_size) {\n+address MacroAssembler::trampoline_call(Address entry, CodeBuffer* cbuf) {\n@@ -861,0 +860,3 @@\n+  address target = entry.target();\n+\n+  \/\/ We might need a trampoline if branches are far.\n@@ -862,1 +864,1 @@\n-  if (!need_trampoline && entry.rspec().type() == relocInfo::runtime_call_type && !CodeCache::contains(entry.target())) {\n+  if (!need_trampoline && entry.rspec().type() == relocInfo::runtime_call_type && !CodeCache::contains(target)) {\n@@ -865,1 +867,0 @@\n-    address target = entry.target();\n@@ -876,1 +877,0 @@\n-  \/\/ We need a trampoline if branches are far.\n@@ -878,17 +878,3 @@\n-    bool in_scratch_emit_size = false;\n-#ifdef COMPILER2\n-    if (check_emit_size) {\n-      \/\/ We don't want to emit a trampoline if C2 is generating dummy\n-      \/\/ code during its branch shortening phase.\n-      CompileTask* task = ciEnv::current()->task();\n-      in_scratch_emit_size =\n-        (task != NULL && is_c2_compile(task->comp_level()) &&\n-         Compile::current()->output()->in_scratch_emit_size());\n-    }\n-#endif\n-    if (!in_scratch_emit_size) {\n-      address stub = emit_trampoline_stub(offset(), entry.target());\n-      if (stub == NULL) {\n-        postcond(pc() == badAddress);\n-        return NULL; \/\/ CodeCache is full\n-      }\n+    if (!emit_trampoline_stub(offset(), target)) {\n+      postcond(pc() == badAddress);\n+      return NULL; \/\/ CodeCache is full\n@@ -896,0 +882,1 @@\n+    target = pc();\n@@ -900,5 +887,2 @@\n-  if (!need_trampoline) {\n-    bl(entry.target());\n-  } else {\n-    bl(pc());\n-  }\n+  bl(target);\n+\n@@ -921,2 +905,2 @@\n-address MacroAssembler::emit_trampoline_stub(int insts_call_instruction_offset,\n-                                             address dest) {\n+bool MacroAssembler::emit_trampoline_stub(int insts_call_instruction_offset,\n+                                          address dest) {\n@@ -927,1 +911,1 @@\n-    return NULL;  \/\/ CodeBuffer::expand failed\n+    return false;  \/\/ CodeBuffer::expand failed\n@@ -954,1 +938,1 @@\n-  return stub_start_addr;\n+  return true;\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":15,"deletions":31,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -636,1 +636,2 @@\n-  address emit_trampoline_stub(int insts_call_instruction_offset, address target);\n+  \/\/ Return false if it fails to emit a stub.\n+  virtual bool emit_trampoline_stub(int insts_call_instruction_offset, address target);\n@@ -1178,1 +1179,1 @@\n-  address trampoline_call(Address entry, CodeBuffer* cbuf = NULL, bool check_emit_size = true);\n+  address trampoline_call(Address entry, CodeBuffer* cbuf = NULL);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -529,1 +529,1 @@\n-address NativeCall::trampoline_jump(CodeBuffer &cbuf, address dest) {\n+void NativeCall::trampoline_jump(CodeBuffer &cbuf, address dest) {\n@@ -531,1 +531,1 @@\n-  address stub = NULL;\n+  bool no_stub = true;\n@@ -535,1 +535,3 @@\n-    stub = a.emit_trampoline_stub(instruction_address() - cbuf.insts()->start(), dest);\n+    bool result = a.emit_trampoline_stub(instruction_address() - cbuf.insts()->start(), dest);\n+    assert(result, \"failed to generate a trampoline stub\");\n+    no_stub = !result;\n@@ -538,1 +540,1 @@\n-  if (stub == NULL) {\n+  if (no_stub) {\n@@ -544,2 +546,0 @@\n-\n-  return stub;\n","filename":"src\/hotspot\/cpu\/aarch64\/nativeInst_aarch64.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -254,1 +254,1 @@\n-  address trampoline_jump(CodeBuffer &cbuf, address dest);\n+  void trampoline_jump(CodeBuffer &cbuf, address dest);\n","filename":"src\/hotspot\/cpu\/aarch64\/nativeInst_aarch64.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1056,1 +1056,1 @@\n-    __ trampoline_call(resolve, \/*cbuf=*\/ NULL, \/*check_emit_size=*\/ false);\n+    __ trampoline_call(resolve);\n@@ -1082,1 +1082,1 @@\n-  __ trampoline_call(resolve, \/*cbuf=*\/ NULL, \/*check_emit_size=*\/ false);\n+  __ trampoline_call(resolve);\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}