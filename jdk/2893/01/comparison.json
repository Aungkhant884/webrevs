{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,8 +67,1 @@\n-    private static final Map<MethodHandleDesc, Function<DynamicConstantDesc<?>, ConstantDesc>> canonicalMap\n-            = Map.ofEntries(Map.entry(ConstantDescs.BSM_PRIMITIVE_CLASS, DynamicConstantDesc::canonicalizePrimitiveClass),\n-                            Map.entry(ConstantDescs.BSM_ENUM_CONSTANT, DynamicConstantDesc::canonicalizeEnum),\n-                            Map.entry(ConstantDescs.BSM_NULL_CONSTANT, DynamicConstantDesc::canonicalizeNull),\n-                            Map.entry(ConstantDescs.BSM_VARHANDLE_STATIC_FIELD, DynamicConstantDesc::canonicalizeStaticFieldVarHandle),\n-                            Map.entry(ConstantDescs.BSM_VARHANDLE_FIELD, DynamicConstantDesc::canonicalizeFieldVarHandle),\n-                            Map.entry(ConstantDescs.BSM_VARHANDLE_ARRAY, DynamicConstantDesc::canonicalizeArrayVarHandle)\n-    );\n+    private static Map<MethodHandleDesc, Function<DynamicConstantDesc<?>, ConstantDesc>> canonicalMap;\n@@ -284,1 +277,19 @@\n-        Function<DynamicConstantDesc<?>, ConstantDesc> f = canonicalMap.get(bootstrapMethod);\n+        var canonDescs = canonicalMap;\n+        if (canonDescs == null) {\n+            canonDescs = Map.ofEntries(\n+                    Map.entry(ConstantDescs.BSM_PRIMITIVE_CLASS, DynamicConstantDesc::canonicalizePrimitiveClass),\n+                    Map.entry(ConstantDescs.BSM_ENUM_CONSTANT, DynamicConstantDesc::canonicalizeEnum),\n+                    Map.entry(ConstantDescs.BSM_NULL_CONSTANT, DynamicConstantDesc::canonicalizeNull),\n+                    Map.entry(ConstantDescs.BSM_VARHANDLE_STATIC_FIELD, DynamicConstantDesc::canonicalizeStaticFieldVarHandle),\n+                    Map.entry(ConstantDescs.BSM_VARHANDLE_FIELD, DynamicConstantDesc::canonicalizeFieldVarHandle),\n+                    Map.entry(ConstantDescs.BSM_VARHANDLE_ARRAY, DynamicConstantDesc::canonicalizeArrayVarHandle));\n+            synchronized (DynamicConstantDesc.class) {\n+                if (canonicalMap == null) {\n+                    canonicalMap = canonDescs;\n+                } else {\n+                    canonDescs = canonicalMap;\n+                }\n+            }\n+        }\n+\n+        Function<DynamicConstantDesc<?>, ConstantDesc> f = canonDescs.get(bootstrapMethod);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/DynamicConstantDesc.java","additions":21,"deletions":10,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -0,0 +1,143 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDesc;\n+import java.lang.constant.ConstantDescs;\n+import java.lang.constant.DynamicConstantDesc;\n+import java.lang.invoke.MethodHandles;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+\n+\/**\n+ * @test\n+ * @bug 8263108\n+ * @summary Verify that concurrent classloading of java.lang.constant.DynamicConstantDesc and\n+ * java.lang.constant.ConstantDescs doesn't lead to a deadlock\n+ * @run main\/othervm DynamicConstantDescTest\n+ * @run main\/othervm DynamicConstantDescTest\n+ * @run main\/othervm DynamicConstantDescTest\n+ * @run main\/othervm DynamicConstantDescTest\n+ * @run main\/othervm DynamicConstantDescTest\n+ *\/\n+\/\/ Implementation note: This test cannot use testng, since by the time this test gets a chance\n+\/\/ to trigger a concurrent classloading of the classes it's interested in, the testng infrastructure\n+\/\/ would already have loaded those classes in a single main thread.\n+public class DynamicConstantDescTest {\n+\n+    \/**\n+     * Loads {@code java.lang.constant.DynamicConstantDesc} and {@code java.lang.constant.ConstantDescs}\n+     * and invokes {@code java.lang.constant.DynamicConstantDesc#ofCanonical()} concurrently in a thread\n+     * of their own and expects the classloading of both those classes\n+     * to succeed.\n+     *\/\n+    public static void main(final String[] args) throws Exception {\n+        final CountDownLatch taskTriggerLatch = new CountDownLatch(4);\n+        final List<Callable<?>> tasks = new ArrayList<>();\n+        \/\/ a bunch of tasks - some doing just Class.forName and some\n+        \/\/ invoking DynamicConstantDesc.ofCanonical\n+        tasks.add(new Task(\"java.lang.constant.DynamicConstantDesc\", taskTriggerLatch));\n+        tasks.add(new InvokeOfCanonical(taskTriggerLatch));\n+        tasks.add(new Task(\"java.lang.constant.ConstantDescs\", taskTriggerLatch));\n+        tasks.add(new InvokeOfCanonical(taskTriggerLatch));\n+        final ExecutorService executor = Executors.newFixedThreadPool(tasks.size());\n+        try {\n+            final Future<?>[] results = new Future[tasks.size()];\n+            \/\/ submit\n+            int i = 0;\n+            for (final Callable<?> task : tasks) {\n+                results[i++] = executor.submit(task);\n+            }\n+            \/\/ wait for completion\n+            for (i = 0; i < tasks.size(); i++) {\n+                results[i].get();\n+            }\n+        } finally {\n+            executor.shutdownNow();\n+        }\n+    }\n+\n+    private static class Task implements Callable<Class<?>> {\n+        private final String className;\n+        private final CountDownLatch latch;\n+\n+        private Task(final String className, final CountDownLatch latch) {\n+            this.className = className;\n+            this.latch = latch;\n+        }\n+\n+        @Override\n+        public Class<?> call() {\n+            System.out.println(Thread.currentThread().getName() + \" loading \" + this.className);\n+            try {\n+                \/\/ let the other tasks know we are ready to trigger our work\n+                latch.countDown();\n+                \/\/ wait for the other task to let us know they are ready to trigger their work too\n+                latch.await();\n+                return Class.forName(this.className);\n+            } catch (Exception e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+    }\n+\n+    enum MyEnum {A, B}\n+\n+    private static class InvokeOfCanonical implements Callable<Object> {\n+        private final CountDownLatch latch;\n+\n+        private InvokeOfCanonical(final CountDownLatch latch) {\n+            this.latch = latch;\n+        }\n+\n+        @Override\n+        public Object call() {\n+            System.out.println(Thread.currentThread().getName()\n+                    + \" calling  DynamicConstantDesc.ofCanonical()\");\n+            try {\n+                \/\/ let the other tasks know we are ready to trigger our work\n+                latch.countDown();\n+                \/\/ wait for the other task to let us know they are ready to trigger their work too\n+                latch.await();\n+                ConstantDesc desc = DynamicConstantDesc.ofCanonical(ConstantDescs.BSM_ENUM_CONSTANT,\n+                        \"A\", ClassDesc.of(\"DynamicConstantDescTest\").nested(\"MyEnum\"),\n+                        new ConstantDesc[0]);\n+                if (desc == null) {\n+                    throw new Exception(\"DynamicConstantDesc.ofCanonical unexpectedly returned null\");\n+                }\n+                if (!MyEnum.A.equals(desc.resolveConstantDesc(MethodHandles.lookup()))) {\n+                    throw new Exception(\"DynamicConstantDesc.ofCanonical returned unexpected result \" + desc);\n+                }\n+                return desc;\n+            } catch (Exception e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+    }\n+\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/lang\/constant\/DynamicConstantDescTest.java","additions":143,"deletions":0,"binary":false,"changes":143,"status":"added"}]}