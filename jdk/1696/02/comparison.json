{"files":[{"patch":"@@ -175,0 +175,4 @@\n+\n+size_t GCArguments::heap_virtual_to_physical_ratio() {\n+  return 1;\n+}\n","filename":"src\/hotspot\/share\/gc\/shared\/gcArguments.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,0 +49,5 @@\n+\n+  \/\/ Used by heap size heuristics to determine max\n+  \/\/ amount of address space to use for the heap.\n+  virtual size_t heap_virtual_to_physical_ratio();\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/gcArguments.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+#include \"runtime\/globals.hpp\"\n@@ -49,1 +50,1 @@\n-  const size_t limit = address_space_limit() \/ 2 \/ ZHeapViews;\n+  const size_t limit = address_space_limit() \/ MaxVirtMemFraction \/ ZHeapViews;\n","filename":"src\/hotspot\/share\/gc\/z\/zAddressSpaceLimit.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/z\/zGlobals.hpp\"\n@@ -97,0 +98,4 @@\n+size_t ZArguments::heap_virtual_to_physical_ratio() {\n+  return ZHeapViews * ZVirtualToPhysicalRatio;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zArguments.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+  virtual size_t heap_virtual_to_physical_ratio();\n","filename":"src\/hotspot\/share\/gc\/z\/zArguments.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1658,1 +1658,1 @@\n-julong Arguments::limit_by_allocatable_memory(julong limit) {\n+julong Arguments::limit_heap_by_allocatable_memory(julong limit) {\n@@ -1662,1 +1662,2 @@\n-    result = MIN2(result, max_allocatable \/ MaxVirtMemFraction);\n+    julong fraction = MaxVirtMemFraction * GCConfig::arguments()->heap_virtual_to_physical_ratio();\n+    result = MIN2(result, max_allocatable \/ fraction);\n@@ -1778,1 +1779,1 @@\n-    reasonable_max = limit_by_allocatable_memory(reasonable_max);\n+    reasonable_max = limit_heap_by_allocatable_memory(reasonable_max);\n@@ -1783,1 +1784,1 @@\n-      \/\/ after call to limit_by_allocatable_memory because that\n+      \/\/ after call to limit_heap_by_allocatable_memory because that\n@@ -1801,1 +1802,1 @@\n-    reasonable_minimum = limit_by_allocatable_memory(reasonable_minimum);\n+    reasonable_minimum = limit_heap_by_allocatable_memory(reasonable_minimum);\n@@ -1805,1 +1806,1 @@\n-      reasonable_initial = limit_by_allocatable_memory(reasonable_initial);\n+      reasonable_initial = limit_heap_by_allocatable_memory(reasonable_initial);\n@@ -1849,1 +1850,1 @@\n-  initHeapSize = limit_by_allocatable_memory(initHeapSize);\n+  initHeapSize = limit_heap_by_allocatable_memory(initHeapSize);\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -366,3 +366,4 @@\n-  \/\/ limits the given memory size by the maximum amount of memory this process is\n-  \/\/ currently allowed to allocate or reserve.\n-  static julong limit_by_allocatable_memory(julong size);\n+  \/\/ Limits the given heap size by the maximum amount of virtual\n+  \/\/ memory this process is currently allowed to use. It also takes\n+  \/\/ the virtual-to-physical ratio of the current GC into account.\n+  static julong limit_heap_by_allocatable_memory(julong size);\n","filename":"src\/hotspot\/share\/runtime\/arguments.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"}]}