{"files":[{"patch":"@@ -176,2 +176,4 @@\n-size_t GCArguments::max_virtual_memory_fraction() {\n-  return MaxVirtMemFraction;\n+size_t GCArguments::heap_virtual_to_physical_ratio() {\n+  \/\/ Used by heap size heuristics to determine max amount\n+  \/\/ of address space to use for the heap.\n+  return 1;\n","filename":"src\/hotspot\/share\/gc\/shared\/gcArguments.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n-  virtual size_t max_virtual_memory_fraction();\n+  virtual size_t heap_virtual_to_physical_ratio();\n","filename":"src\/hotspot\/share\/gc\/shared\/gcArguments.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/gc\/z\/zAddressSpaceLimit.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -98,5 +98,2 @@\n-size_t ZArguments::max_virtual_memory_fraction() {\n-  \/\/ Used by heap size heuristics to determine max amount of address\n-  \/\/ space to use. Inflates the default MaxVirtMemFraction to account\n-  \/\/ for all heap views and the virtual-to-physical ratio.\n-  return MaxVirtMemFraction * ZHeapViews * ZVirtualToPhysicalRatio;\n+size_t ZArguments::heap_virtual_to_physical_ratio() {\n+  return ZHeapViews * ZVirtualToPhysicalRatio;\n","filename":"src\/hotspot\/share\/gc\/z\/zArguments.cpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-  virtual size_t max_virtual_memory_fraction();\n+  virtual size_t heap_virtual_to_physical_ratio();\n","filename":"src\/hotspot\/share\/gc\/z\/zArguments.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1658,1 +1658,1 @@\n-julong Arguments::limit_by_allocatable_memory(julong limit) {\n+julong Arguments::limit_heap_by_allocatable_memory(julong limit) {\n@@ -1662,1 +1662,2 @@\n-    result = MIN2(result, max_allocatable \/ GCConfig::arguments()->max_virtual_memory_fraction());\n+    julong fraction = MaxVirtMemFraction * GCConfig::arguments()->heap_virtual_to_physical_ratio();\n+    result = MIN2(result, max_allocatable \/ fraction);\n@@ -1778,1 +1779,1 @@\n-    reasonable_max = limit_by_allocatable_memory(reasonable_max);\n+    reasonable_max = limit_heap_by_allocatable_memory(reasonable_max);\n@@ -1783,1 +1784,1 @@\n-      \/\/ after call to limit_by_allocatable_memory because that\n+      \/\/ after call to limit_heap_by_allocatable_memory because that\n@@ -1801,1 +1802,1 @@\n-    reasonable_minimum = limit_by_allocatable_memory(reasonable_minimum);\n+    reasonable_minimum = limit_heap_by_allocatable_memory(reasonable_minimum);\n@@ -1805,1 +1806,1 @@\n-      reasonable_initial = limit_by_allocatable_memory(reasonable_initial);\n+      reasonable_initial = limit_heap_by_allocatable_memory(reasonable_initial);\n@@ -1849,1 +1850,1 @@\n-  initHeapSize = limit_by_allocatable_memory(initHeapSize);\n+  initHeapSize = limit_heap_by_allocatable_memory(initHeapSize);\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -368,1 +368,1 @@\n-  static julong limit_by_allocatable_memory(julong size);\n+  static julong limit_heap_by_allocatable_memory(julong size);\n","filename":"src\/hotspot\/share\/runtime\/arguments.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}