{"files":[{"patch":"@@ -386,1 +386,1 @@\n-static bool find_field(InstanceKlass* ik,\n+static bool find_field(const InstanceKlass* ik,\n@@ -398,1 +398,1 @@\n-static void lookup_field(JfrJavaArguments* args, InstanceKlass* klass, fieldDescriptor* fd, bool static_field) {\n+static void lookup_field(JfrJavaArguments* args, const InstanceKlass* ik, fieldDescriptor* fd, bool static_field) {\n@@ -400,2 +400,2 @@\n-  assert(klass != NULL, \"invariant\");\n-  assert(klass->is_initialized(), \"invariant\");\n+  assert(ik != NULL, \"invariant\");\n+  assert(ik->is_initialized(), \"invariant\");\n@@ -403,1 +403,12 @@\n-  find_field(klass, args->name(), args->signature(), fd, static_field, true);\n+  find_field(ik, args->name(), args->signature(), fd, static_field, true);\n+}\n+\n+static void read_field(JfrJavaArguments* args, JavaValue* result, Thread* thread) {\n+  const bool static_field = !args->has_receiver();\n+  fieldDescriptor fd;\n+  const InstanceKlass* const ik = static_cast<InstanceKlass*>(args->klass());\n+  lookup_field(args, ik, &fd, static_field);\n+  assert(fd.offset() > 0, \"invariant\");\n+  HandleMark hm(thread);\n+  Handle h_oop(static_field ? Handle(thread, ik->java_mirror()) : Handle(thread, args->receiver()));\n+  read_specialized_field(result, h_oop, &fd);\n@@ -410,1 +421,0 @@\n-\n@@ -413,8 +423,1 @@\n-  const bool static_field = !args->has_receiver();\n-  fieldDescriptor fd;\n-  lookup_field(args, klass, &fd, static_field);\n-  assert(fd.offset() > 0, \"invariant\");\n-\n-  HandleMark hm(THREAD);\n-  Handle h_oop(static_field ? Handle(THREAD, klass->java_mirror()) : Handle(THREAD, args->receiver()));\n-  read_specialized_field(result, h_oop, &fd);\n+  read_field(args, result, static_cast<Thread*>(THREAD));\n@@ -451,0 +454,5 @@\n+void JfrJavaSupport::get_field(JfrJavaArguments* args, Thread* thread) {\n+  assert(args != NULL, \"invariant\");\n+  read_field(args, args->result(), thread);\n+}\n+\n@@ -490,1 +498,1 @@\n-static char* allocate_string(bool c_heap, int length, JavaThread* jt) {\n+static char* allocate_string(bool c_heap, int length, Thread* thread) {\n@@ -492,1 +500,1 @@\n-                  NEW_RESOURCE_ARRAY_IN_THREAD(jt, char, length);\n+                  NEW_RESOURCE_ARRAY_IN_THREAD(thread, char, length);\n@@ -495,2 +503,1 @@\n-const char* JfrJavaSupport::c_str(oop string, JavaThread* t, bool c_heap \/* false *\/) {\n-  DEBUG_ONLY(check_java_thread_in_vm(t));\n+const char* JfrJavaSupport::c_str(oop string, Thread* thread, bool c_heap \/* false *\/) {\n@@ -501,1 +508,1 @@\n-    str = allocate_string(c_heap, length + 1, t);\n+    str = allocate_string(c_heap, length + 1, thread);\n@@ -503,1 +510,0 @@\n-      JfrJavaSupport::throw_out_of_memory_error(\"Unable to allocate native memory\", t);\n@@ -511,3 +517,2 @@\n-const char* JfrJavaSupport::c_str(jstring string, JavaThread* t, bool c_heap \/* false *\/) {\n-  DEBUG_ONLY(check_java_thread_in_vm(t));\n-  return string != NULL ? c_str(resolve_non_null(string), t, c_heap) : NULL;\n+const char* JfrJavaSupport::c_str(jstring string, Thread* thread, bool c_heap \/* false *\/) {\n+  return string != NULL ? c_str(resolve_non_null(string), thread, c_heap) : NULL;\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJavaSupport.cpp","additions":28,"deletions":23,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+  static void get_field(JfrJavaArguments* args, Thread* thread);\n@@ -78,2 +79,2 @@\n-  static const char* c_str(jstring string, JavaThread* jt, bool c_heap = false);\n-  static const char* c_str(oop string, JavaThread* jt, bool c_heap = false);\n+  static const char* c_str(jstring string, Thread* thread, bool c_heap = false);\n+  static const char* c_str(oop string, Thread* thread, bool c_heap = false);\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJavaSupport.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1086,0 +1086,1 @@\n+    <Field type=\"Symbol\" name=\"codeSource\" label=\"Code Source\" description=\"The URL from where the class was loaded\" \/>\n","filename":"src\/hotspot\/share\/jfr\/metadata\/metadata.xml","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"classfile\/javaClasses.inline.hpp\"\n@@ -28,0 +29,1 @@\n+#include \"jfr\/jni\/jfrJavaSupport.hpp\"\n@@ -29,0 +31,1 @@\n+#include \"jfr\/support\/jfrSymbolTable.hpp\"\n@@ -30,1 +33,2 @@\n-#include \"oops\/instanceKlass.hpp\"\n+#include \"jfr\/utilities\/jfrTypes.hpp\"\n+#include \"oops\/instanceKlass.inline.hpp\"\n@@ -32,0 +36,1 @@\n+#include \"runtime\/thread.inline.hpp\"\n@@ -33,1 +38,62 @@\n-\/\/ All finalizer events generated during the same pass will have the same timestamp.\n+static oop get_codesource(oop pd, Thread* thread) {\n+  assert(pd != NULL, \"invariant\");\n+  assert(thread != NULL, \"invariant\");\n+  JavaValue result(T_OBJECT);\n+  JfrJavaArguments args(&result);\n+  args.set_klass(pd->klass());\n+  args.set_name(\"codesource\");\n+  args.set_signature(\"Ljava\/security\/CodeSource;\");\n+  args.set_receiver(pd);\n+  JfrJavaSupport::get_field(&args, thread);\n+  return result.get_oop();\n+}\n+\n+\/\/ Caller needs ResourceMark\n+static const char* get_locationNoFragString(oop codesource, Thread* thread) {\n+  assert(codesource != NULL, \"invariant\");\n+  assert(thread != NULL, \"invariant\");\n+  JavaValue result(T_OBJECT);\n+  JfrJavaArguments args(&result);\n+  args.set_klass(codesource->klass());\n+  args.set_name(\"locationNoFragString\");\n+  args.set_signature(\"Ljava\/lang\/String;\");\n+  args.set_receiver(codesource);\n+  JfrJavaSupport::get_field(&args, thread);\n+  const oop string_oop = result.get_oop();\n+  return string_oop != NULL ? JfrJavaSupport::c_str(string_oop, thread) : NULL;\n+}\n+\n+\/\/ Caller needs ResourceMark\n+static const char* codesource(const InstanceKlass* ik, Thread* thread) {\n+  assert(ik != NULL, \"invariant\");\n+  assert(thread != NULL, \"invariant\");\n+  oop pd = java_lang_Class::protection_domain(ik->java_mirror());\n+  if (pd == NULL) {\n+    return NULL;\n+  }\n+  oop codesource = get_codesource(pd, thread);\n+  return codesource != NULL ? get_locationNoFragString(codesource, thread) : NULL;\n+}\n+\n+static void send_event(const InstanceKlass* ik, const JfrTicks& timestamp) {\n+  assert(ik, \"invariant\");\n+  assert(ik->has_finalizer(), \"invariant\");\n+  EventFinalizer event(UNTIMED);\n+  event.set_endtime(timestamp);\n+  event.set_overridingClass(ik);\n+  Thread* const thread = Thread::current();\n+  ResourceMark rm(thread);\n+  const char* const url = codesource(ik, thread);\n+  const traceid symbol_id = url != NULL ? JfrSymbolTable::add(url) : 0;\n+  event.set_codeSource(symbol_id);\n+  event.commit();\n+}\n+\n+void JfrFinalizerEvent::send_unload_event(const InstanceKlass* ik) {\n+  assert(ik != NULL, \"invariant\");\n+  assert(ik->has_finalizer(), \"invariant\");\n+  send_event(ik, JfrTicks::now());\n+}\n+\n+\/\/ Finalizer events generated by the periodic task thread\n+\/\/ during the same pass will all have the same timestamp.\n@@ -41,1 +107,1 @@\n-  InstanceKlass* const ik = InstanceKlass::cast(klass);\n+  const InstanceKlass* const ik = InstanceKlass::cast(klass);\n@@ -43,4 +109,1 @@\n-    EventFinalizer event(UNTIMED);\n-    event.set_endtime(invocation_time);\n-    event.set_overridingClass(ik);\n-    event.commit();\n+    send_event(ik, invocation_time);\n","filename":"src\/hotspot\/share\/jfr\/periodic\/jfrFinalizerEvent.cpp","additions":70,"deletions":7,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+class InstanceKlass;\n+\n@@ -32,0 +34,1 @@\n+  static void send_unload_event(const InstanceKlass* ik);\n","filename":"src\/hotspot\/share\/jfr\/periodic\/jfrFinalizerEvent.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -58,2 +58,2 @@\n-typedef const JfrSymbolId::SymbolEntry* SymbolEntryPtr;\n-typedef const JfrSymbolId::CStringEntry* CStringEntryPtr;\n+typedef const JfrSymbolTable::SymbolEntry* SymbolEntryPtr;\n+typedef const JfrSymbolTable::CStringEntry* CStringEntryPtr;\n@@ -67,12 +67,1 @@\n-static bool _clear_artifacts = false;\n-\n-\/\/ incremented on each rotation\n-static u8 checkpoint_id = 1;\n-\n-\/\/ creates a unique id by combining a checkpoint relative symbol id (2^24)\n-\/\/ with the current checkpoint id (2^40)\n-#define CREATE_SYMBOL_ID(sym_id) (((u8)((checkpoint_id << 24) | sym_id)))\n-\n-static traceid create_symbol_id(traceid artifact_id) {\n-  return artifact_id != 0 ? CREATE_SYMBOL_ID(artifact_id) : 0;\n-}\n+static bool _initial_type_set = true;\n@@ -89,1 +78,1 @@\n-  return _clear_artifacts && !_class_unload;\n+  return _initial_type_set && !_class_unload;\n@@ -97,1 +86,1 @@\n-  return klass != NULL ? create_symbol_id(_artifacts->mark(klass, leakp)) : 0;\n+  return klass != NULL ? _artifacts->mark(klass, leakp) : 0;\n@@ -101,1 +90,1 @@\n-  return symbol != NULL ? create_symbol_id(_artifacts->mark(symbol, leakp)) : 0;\n+  return symbol != NULL ? _artifacts->mark(symbol, leakp) : 0;\n@@ -105,1 +94,1 @@\n-  return create_symbol_id(_artifacts->bootstrap_name(leakp));\n+  return _artifacts->bootstrap_name(leakp);\n@@ -927,1 +916,1 @@\n-void set_serialized<JfrSymbolId::SymbolEntry>(SymbolEntryPtr ptr) {\n+void set_serialized<JfrSymbolTable::SymbolEntry>(SymbolEntryPtr ptr) {\n@@ -934,1 +923,1 @@\n-void set_serialized<JfrSymbolId::CStringEntry>(CStringEntryPtr ptr) {\n+void set_serialized<JfrSymbolTable::CStringEntry>(CStringEntryPtr ptr) {\n@@ -944,1 +933,1 @@\n-  writer->write(create_symbol_id(entry->id()));\n+  writer->write(entry->id());\n@@ -965,1 +954,1 @@\n-  writer->write(create_symbol_id(entry->id()));\n+  writer->write(entry->id());\n@@ -1043,2 +1032,2 @@\n-    _clear_artifacts = true;\n-    ++checkpoint_id;\n+    _artifacts->increment_checkpoint_id();\n+    _initial_type_set = true;\n@@ -1046,1 +1035,1 @@\n-    _clear_artifacts = false;\n+    _initial_type_set = false;\n@@ -1059,1 +1048,1 @@\n-    _artifacts->initialize(class_unload, _clear_artifacts);\n+    _artifacts->initialize(class_unload);\n@@ -1094,1 +1083,3 @@\n-  _clear_artifacts = true;\n+  if (_artifacts != NULL) {\n+    _artifacts->clear();\n+  }\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrTypeSet.cpp","additions":18,"deletions":27,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -33,219 +33,1 @@\n-static JfrSymbolId::CStringEntry* bootstrap = NULL;\n-\n-JfrSymbolId::JfrSymbolId() :\n-  _sym_table(new SymbolTable(this)),\n-  _cstring_table(new CStringTable(this)),\n-  _sym_list(NULL),\n-  _cstring_list(NULL),\n-  _sym_query(NULL),\n-  _cstring_query(NULL),\n-  _symbol_id_counter(1),\n-  _class_unload(false) {\n-  assert(_sym_table != NULL, \"invariant\");\n-  assert(_cstring_table != NULL, \"invariant\");\n-  bootstrap = new CStringEntry(0, (const char*)&BOOTSTRAP_LOADER_NAME);\n-  assert(bootstrap != NULL, \"invariant\");\n-  bootstrap->set_id(1);\n-  _cstring_list = bootstrap;\n-}\n-\n-JfrSymbolId::~JfrSymbolId() {\n-  clear();\n-  delete _sym_table;\n-  delete _cstring_table;\n-  delete bootstrap;\n-}\n-\n-void JfrSymbolId::clear() {\n-  assert(_sym_table != NULL, \"invariant\");\n-  if (_sym_table->has_entries()) {\n-    _sym_table->clear_entries();\n-  }\n-  assert(!_sym_table->has_entries(), \"invariant\");\n-\n-  assert(_cstring_table != NULL, \"invariant\");\n-  if (_cstring_table->has_entries()) {\n-    _cstring_table->clear_entries();\n-  }\n-  assert(!_cstring_table->has_entries(), \"invariant\");\n-\n-  _sym_list = NULL;\n-  _symbol_id_counter = 1;\n-\n-  _sym_query = NULL;\n-  _cstring_query = NULL;\n-\n-  assert(bootstrap != NULL, \"invariant\");\n-  bootstrap->reset();\n-  _cstring_list = bootstrap;\n-}\n-\n-void JfrSymbolId::set_class_unload(bool class_unload) {\n-  _class_unload = class_unload;\n-}\n-\n-void JfrSymbolId::on_link(const SymbolEntry* entry) {\n-  assert(entry != NULL, \"invariant\");\n-  const_cast<Symbol*>(entry->literal())->increment_refcount();\n-  assert(entry->id() == 0, \"invariant\");\n-  entry->set_id(++_symbol_id_counter);\n-  entry->set_list_next(_sym_list);\n-  _sym_list = entry;\n-}\n-\n-bool JfrSymbolId::on_equals(uintptr_t hash, const SymbolEntry* entry) {\n-  assert(entry != NULL, \"invariant\");\n-  assert(entry->hash() == hash, \"invariant\");\n-  assert(_sym_query != NULL, \"invariant\");\n-  return _sym_query == entry->literal();\n-}\n-\n-void JfrSymbolId::on_unlink(const SymbolEntry* entry) {\n-  assert(entry != NULL, \"invariant\");\n-  const_cast<Symbol*>(entry->literal())->decrement_refcount();\n-}\n-\n-static const char* resource_to_cstring(const char* resource_str) {\n-  assert(resource_str != NULL, \"invariant\");\n-  const size_t length = strlen(resource_str);\n-  char* const c_string = JfrCHeapObj::new_array<char>(length + 1);\n-  assert(c_string != NULL, \"invariant\");\n-  strncpy(c_string, resource_str, length + 1);\n-  return c_string;\n-}\n-\n-void JfrSymbolId::on_link(const CStringEntry* entry) {\n-  assert(entry != NULL, \"invariant\");\n-  assert(entry->id() == 0, \"invariant\");\n-  entry->set_id(++_symbol_id_counter);\n-  const_cast<CStringEntry*>(entry)->set_literal(resource_to_cstring(entry->literal()));\n-  entry->set_list_next(_cstring_list);\n-  _cstring_list = entry;\n-}\n-\n-static bool string_compare(const char* query, const char* candidate) {\n-  assert(query != NULL, \"invariant\");\n-  assert(candidate != NULL, \"invariant\");\n-  const size_t length = strlen(query);\n-  return strncmp(query, candidate, length) == 0;\n-}\n-\n-bool JfrSymbolId::on_equals(uintptr_t hash, const CStringEntry* entry) {\n-  assert(entry != NULL, \"invariant\");\n-  assert(entry->hash() == hash, \"invariant\");\n-  assert(_cstring_query != NULL, \"invariant\");\n-  return string_compare(_cstring_query, entry->literal());\n-}\n-\n-void JfrSymbolId::on_unlink(const CStringEntry* entry) {\n-  assert(entry != NULL, \"invariant\");\n-  JfrCHeapObj::free(const_cast<char*>(entry->literal()), strlen(entry->literal() + 1));\n-}\n-\n-traceid JfrSymbolId::bootstrap_name(bool leakp) {\n-  assert(bootstrap != NULL, \"invariant\");\n-  if (leakp) {\n-    bootstrap->set_leakp();\n-  }\n-  return 1;\n-}\n-\n-traceid JfrSymbolId::mark(const Symbol* symbol, bool leakp) {\n-  assert(symbol != NULL, \"invariant\");\n-  return mark((uintptr_t)symbol->identity_hash(), symbol, leakp);\n-}\n-\n-traceid JfrSymbolId::mark(uintptr_t hash, const Symbol* data, bool leakp) {\n-  assert(data != NULL, \"invariant\");\n-  assert(_sym_table != NULL, \"invariant\");\n-  _sym_query = data;\n-  const SymbolEntry& entry = _sym_table->lookup_put(hash, data);\n-  if (_class_unload) {\n-    entry.set_unloading();\n-  }\n-  if (leakp) {\n-    entry.set_leakp();\n-  }\n-  return entry.id();\n-}\n-\n-traceid JfrSymbolId::mark(uintptr_t hash, const char* str, bool leakp) {\n-  assert(str != NULL, \"invariant\");\n-  assert(_cstring_table != NULL, \"invariant\");\n-  _cstring_query = str;\n-  const CStringEntry& entry = _cstring_table->lookup_put(hash, str);\n-  if (_class_unload) {\n-    entry.set_unloading();\n-  }\n-  if (leakp) {\n-    entry.set_leakp();\n-  }\n-  return entry.id();\n-}\n-\n-\/*\n-* hidden classes symbol is the external name +\n-* the address of its InstanceKlass slash appended:\n-*   java.lang.invoke.LambdaForm$BMH\/22626602\n-*\n-* caller needs ResourceMark\n-*\/\n-\n-uintptr_t JfrSymbolId::hidden_klass_name_hash(const InstanceKlass* ik) {\n-  assert(ik != NULL, \"invariant\");\n-  assert(ik->is_hidden(), \"invariant\");\n-  const oop mirror = ik->java_mirror_no_keepalive();\n-  assert(mirror != NULL, \"invariant\");\n-  return (uintptr_t)mirror->identity_hash();\n-}\n-\n-static const char* create_hidden_klass_symbol(const InstanceKlass* ik, uintptr_t hash) {\n-  assert(ik != NULL, \"invariant\");\n-  assert(ik->is_hidden(), \"invariant\");\n-  assert(hash != 0, \"invariant\");\n-  char* hidden_symbol = NULL;\n-  const oop mirror = ik->java_mirror_no_keepalive();\n-  assert(mirror != NULL, \"invariant\");\n-  char hash_buf[40];\n-  sprintf(hash_buf, \"\/\" UINTX_FORMAT, hash);\n-  const size_t hash_len = strlen(hash_buf);\n-  const size_t result_len = ik->name()->utf8_length();\n-  hidden_symbol = NEW_RESOURCE_ARRAY(char, result_len + hash_len + 1);\n-  ik->name()->as_klass_external_name(hidden_symbol, (int)result_len + 1);\n-  assert(strlen(hidden_symbol) == result_len, \"invariant\");\n-  strcpy(hidden_symbol + result_len, hash_buf);\n-  assert(strlen(hidden_symbol) == result_len + hash_len, \"invariant\");\n-  return hidden_symbol;\n-}\n-\n-bool JfrSymbolId::is_hidden_klass(const Klass* k) {\n-  assert(k != NULL, \"invariant\");\n-  return k->is_instance_klass() && ((const InstanceKlass*)k)->is_hidden();\n-}\n-\n-traceid JfrSymbolId::mark_hidden_klass_name(const InstanceKlass* ik, bool leakp) {\n-  assert(ik != NULL, \"invariant\");\n-  assert(ik->is_hidden(), \"invariant\");\n-  const uintptr_t hash = hidden_klass_name_hash(ik);\n-  const char* const hidden_symbol = create_hidden_klass_symbol(ik, hash);\n-  return mark(hash, hidden_symbol, leakp);\n-}\n-\n-traceid JfrSymbolId::mark(const Klass* k, bool leakp) {\n-  assert(k != NULL, \"invariant\");\n-  traceid symbol_id = 0;\n-  if (is_hidden_klass(k)) {\n-    assert(k->is_instance_klass(), \"invariant\");\n-    symbol_id = mark_hidden_klass_name((const InstanceKlass*)k, leakp);\n-  }\n-  if (0 == symbol_id) {\n-    Symbol* const sym = k->name();\n-    if (sym != NULL) {\n-      symbol_id = mark(sym, leakp);\n-    }\n-  }\n-  assert(symbol_id > 0, \"a symbol handler must mark the symbol for writing\");\n-  return symbol_id;\n-}\n-\n-JfrArtifactSet::JfrArtifactSet(bool class_unload) : _symbol_id(new JfrSymbolId()),\n+JfrArtifactSet::JfrArtifactSet(bool class_unload) : _symbol_table(NULL),\n@@ -261,4 +43,4 @@\n-void JfrArtifactSet::initialize(bool class_unload, bool clear \/* false *\/) {\n-  assert(_symbol_id != NULL, \"invariant\");\n-  if (clear) {\n-    _symbol_id->clear();\n+void JfrArtifactSet::initialize(bool class_unload) {\n+  if (_symbol_table == NULL) {\n+    _symbol_table = JfrSymbolTable::create();\n+    assert(_symbol_table != NULL, \"invariant\");\n@@ -266,1 +48,2 @@\n-  _symbol_id->set_class_unload(class_unload);\n+  assert(_symbol_table != NULL, \"invariant\");\n+  _symbol_table->set_class_unload(class_unload);\n@@ -273,0 +56,6 @@\n+void JfrArtifactSet::clear() {\n+  if (_symbol_table != NULL) {\n+    _symbol_table->clear();\n+  }\n+}\n+\n@@ -274,2 +63,1 @@\n-  _symbol_id->clear();\n-  delete _symbol_id;\n+  delete _symbol_table;\n@@ -280,1 +68,1 @@\n-  return _symbol_id->bootstrap_name(leakp);\n+  return _symbol_table->bootstrap_name(leakp);\n@@ -285,1 +73,1 @@\n-  return _symbol_id->mark_hidden_klass_name((const InstanceKlass*)klass, leakp);\n+  return _symbol_table->mark_hidden_klass_name((const InstanceKlass*)klass, leakp);\n@@ -289,1 +77,1 @@\n-  return _symbol_id->mark(hash, sym, leakp);\n+  return _symbol_table->mark(hash, sym, leakp);\n@@ -293,1 +81,1 @@\n-  return _symbol_id->mark(klass, leakp);\n+  return _symbol_table->mark(klass, leakp);\n@@ -297,1 +85,1 @@\n-  return _symbol_id->mark(symbol, leakp);\n+  return _symbol_table->mark(symbol, leakp);\n@@ -301,1 +89,1 @@\n-  return _symbol_id->mark(hash, str, leakp);\n+  return _symbol_table->mark(hash, str, leakp);\n@@ -327,0 +115,6 @@\n+\n+void JfrArtifactSet::increment_checkpoint_id() {\n+  assert(_symbol_table != NULL, \"invariant\");\n+  _symbol_table->increment_checkpoint_id();\n+}\n+\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrTypeSetUtils.cpp","additions":26,"deletions":232,"binary":false,"changes":258,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"jfr\/support\/jfrSymbolTable.hpp\"\n@@ -30,1 +31,0 @@\n-#include \"jfr\/utilities\/jfrHashtable.hpp\"\n@@ -194,92 +194,0 @@\n-template <typename T, typename IdType>\n-class ListEntry : public JfrHashtableEntry<T, IdType> {\n- public:\n-  ListEntry(uintptr_t hash, const T& data) : JfrHashtableEntry<T, IdType>(hash, data),\n-    _list_next(NULL), _serialized(false), _unloading(false), _leakp(false) {}\n-  const ListEntry<T, IdType>* list_next() const { return _list_next; }\n-  void reset() const {\n-    _list_next = NULL; _serialized = false; _unloading = false; _leakp = false;\n-  }\n-  void set_list_next(const ListEntry<T, IdType>* next) const { _list_next = next; }\n-  bool is_serialized() const { return _serialized; }\n-  void set_serialized() const { _serialized = true; }\n-  bool is_unloading() const { return _unloading; }\n-  void set_unloading() const { _unloading = true; }\n-  bool is_leakp() const { return _leakp; }\n-  void set_leakp() const { _leakp = true; }\n- private:\n-  mutable const ListEntry<T, IdType>* _list_next;\n-  mutable bool _serialized;\n-  mutable bool _unloading;\n-  mutable bool _leakp;\n-};\n-\n-class JfrSymbolId : public JfrCHeapObj {\n-  template <typename, typename, template<typename, typename> class, typename, size_t>\n-  friend class HashTableHost;\n-  typedef HashTableHost<const Symbol*, traceid, ListEntry, JfrSymbolId> SymbolTable;\n-  typedef HashTableHost<const char*, traceid, ListEntry, JfrSymbolId> CStringTable;\n-  friend class JfrArtifactSet;\n- public:\n-  typedef SymbolTable::HashEntry SymbolEntry;\n-  typedef CStringTable::HashEntry CStringEntry;\n- private:\n-  SymbolTable* _sym_table;\n-  CStringTable* _cstring_table;\n-  const SymbolEntry* _sym_list;\n-  const CStringEntry* _cstring_list;\n-  const Symbol* _sym_query;\n-  const char* _cstring_query;\n-  traceid _symbol_id_counter;\n-  bool _class_unload;\n-\n-  \/\/ hashtable(s) callbacks\n-  void on_link(const SymbolEntry* entry);\n-  bool on_equals(uintptr_t hash, const SymbolEntry* entry);\n-  void on_unlink(const SymbolEntry* entry);\n-  void on_link(const CStringEntry* entry);\n-  bool on_equals(uintptr_t hash, const CStringEntry* entry);\n-  void on_unlink(const CStringEntry* entry);\n-\n-  template <typename Functor, typename T>\n-  void iterate(Functor& functor, const T* list) {\n-    const T* symbol = list;\n-    while (symbol != NULL) {\n-      const T* next = symbol->list_next();\n-      functor(symbol);\n-      symbol = next;\n-    }\n-  }\n-\n-  traceid mark_hidden_klass_name(const InstanceKlass* k, bool leakp);\n-  bool is_hidden_klass(const Klass* k);\n-  uintptr_t hidden_klass_name_hash(const InstanceKlass* ik);\n-\n- public:\n-  JfrSymbolId();\n-  ~JfrSymbolId();\n-\n-  void clear();\n-  void set_class_unload(bool class_unload);\n-\n-  traceid mark(uintptr_t hash, const Symbol* sym, bool leakp);\n-  traceid mark(const Klass* k, bool leakp);\n-  traceid mark(const Symbol* symbol, bool leakp);\n-  traceid mark(uintptr_t hash, const char* str, bool leakp);\n-  traceid bootstrap_name(bool leakp);\n-\n-  template <typename Functor>\n-  void iterate_symbols(Functor& functor) {\n-    iterate(functor, _sym_list);\n-  }\n-\n-  template <typename Functor>\n-  void iterate_cstrings(Functor& functor) {\n-    iterate(functor, _cstring_list);\n-  }\n-\n-  bool has_entries() const { return has_symbol_entries() || has_cstring_entries(); }\n-  bool has_symbol_entries() const { return _sym_list != NULL; }\n-  bool has_cstring_entries() const { return _cstring_list != NULL; }\n-};\n-\n@@ -302,1 +210,1 @@\n-  JfrSymbolId* _symbol_id;\n+  JfrSymbolTable* _symbol_table;\n@@ -312,1 +220,2 @@\n-  void initialize(bool class_unload, bool clear = false);\n+  void initialize(bool class_unload);\n+  void clear();\n@@ -321,3 +230,3 @@\n-  const JfrSymbolId::SymbolEntry* map_symbol(const Symbol* symbol) const;\n-  const JfrSymbolId::SymbolEntry* map_symbol(uintptr_t hash) const;\n-  const JfrSymbolId::CStringEntry* map_cstring(uintptr_t hash) const;\n+  const JfrSymbolTable::SymbolEntry* map_symbol(const Symbol* symbol) const;\n+  const JfrSymbolTable::SymbolEntry* map_symbol(uintptr_t hash) const;\n+  const JfrSymbolTable::CStringEntry* map_cstring(uintptr_t hash) const;\n@@ -330,0 +239,1 @@\n+  void increment_checkpoint_id();\n@@ -342,1 +252,1 @@\n-    _symbol_id->iterate_symbols(functor);\n+    _symbol_table->iterate_symbols(functor);\n@@ -347,1 +257,1 @@\n-    _symbol_id->iterate_cstrings(functor);\n+    _symbol_table->iterate_cstrings(functor);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrTypeSetUtils.hpp","additions":10,"deletions":100,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"jfr\/periodic\/jfrFinalizerEvent.hpp\"\n@@ -117,3 +118,1 @@\n-    EventFinalizer event;\n-    event.set_overridingClass(ik);\n-    event.commit();\n+    JfrFinalizerEvent::send_unload_event(ik);\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrKlassUnloading.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,316 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"classfile\/javaClasses.inline.hpp\"\n+#include \"classfile\/classLoaderData.hpp\"\n+#include \"jfr\/support\/jfrSymbolTable.hpp\"\n+#include \"oops\/instanceKlass.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n+#include \"oops\/symbol.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n+\n+\/\/ incremented on each rotation\n+static u8 checkpoint_id = 1;\n+\n+\/\/ creates a unique id by combining a checkpoint relative symbol id (2^24)\n+\/\/ with the current checkpoint id (2^40)\n+#define CREATE_SYMBOL_ID(sym_id) (((u8)((checkpoint_id << 24) | sym_id)))\n+\n+static traceid create_symbol_id(traceid artifact_id) {\n+  return artifact_id != 0 ? CREATE_SYMBOL_ID(artifact_id) : 0;\n+}\n+\n+static uintptr_t string_hash(const char* str) {\n+  return java_lang_String::hash_code(reinterpret_cast<const jbyte*>(str), static_cast<int>(strlen(str)));\n+}\n+\n+static JfrSymbolTable::CStringEntry* bootstrap = NULL;\n+\n+static JfrSymbolTable* _instance = NULL;\n+\n+static JfrSymbolTable& instance() {\n+  assert(_instance != NULL, \"invariant\");\n+  return *_instance;\n+}\n+\n+JfrSymbolTable* JfrSymbolTable::create() {\n+  assert(_instance == NULL, \"invariant\");\n+  assert_lock_strong(ClassLoaderDataGraph_lock);\n+  _instance = new JfrSymbolTable();\n+  return _instance;\n+}\n+\n+void JfrSymbolTable::destroy() {\n+  assert_lock_strong(ClassLoaderDataGraph_lock);\n+  if (_instance != NULL) {\n+    delete _instance;\n+    _instance = NULL;\n+  }\n+  assert(_instance == NULL, \"invariant\");\n+}\n+\n+JfrSymbolTable::JfrSymbolTable() :\n+  _symbol_table(new SymbolTable(this)),\n+  _cstring_table(new CStringTable(this)),\n+  _symbol_list(NULL),\n+  _cstring_list(NULL),\n+  _symbol_query(NULL),\n+  _cstring_query(NULL),\n+  _id_counter(1),\n+  _class_unload(false) {\n+  assert(_symbol_table != NULL, \"invariant\");\n+  assert(_cstring_table != NULL, \"invariant\");\n+  bootstrap = new CStringEntry(0, (const char*)&BOOTSTRAP_LOADER_NAME);\n+  assert(bootstrap != NULL, \"invariant\");\n+  bootstrap->set_id(create_symbol_id(1));\n+  _cstring_list = bootstrap;\n+}\n+\n+JfrSymbolTable::~JfrSymbolTable() {\n+  clear();\n+  delete _symbol_table;\n+  delete _cstring_table;\n+  delete bootstrap;\n+}\n+\n+void JfrSymbolTable::clear() {\n+  assert(_symbol_table != NULL, \"invariant\");\n+  if (_symbol_table->has_entries()) {\n+    _symbol_table->clear_entries();\n+  }\n+  assert(!_symbol_table->has_entries(), \"invariant\");\n+\n+  assert(_cstring_table != NULL, \"invariant\");\n+  if (_cstring_table->has_entries()) {\n+    _cstring_table->clear_entries();\n+  }\n+  assert(!_cstring_table->has_entries(), \"invariant\");\n+\n+  _symbol_list = NULL;\n+  _id_counter = 1;\n+\n+  _symbol_query = NULL;\n+  _cstring_query = NULL;\n+\n+  assert(bootstrap != NULL, \"invariant\");\n+  bootstrap->reset();\n+  _cstring_list = bootstrap;\n+}\n+\n+void JfrSymbolTable::set_class_unload(bool class_unload) {\n+  _class_unload = class_unload;\n+}\n+\n+void JfrSymbolTable::increment_checkpoint_id() {\n+  assert_lock_strong(ClassLoaderDataGraph_lock);\n+  clear();\n+  ++checkpoint_id;\n+}\n+\n+template <typename T>\n+inline void JfrSymbolTable::assign_id(T* entry) {\n+  assert(entry != NULL, \"invariant\");\n+  assert(entry->id() == 0, \"invariant\");\n+  entry->set_id(create_symbol_id(++_id_counter));\n+}\n+\n+void JfrSymbolTable::on_link(const SymbolEntry* entry) {\n+  assign_id(entry);\n+  const_cast<Symbol*>(entry->literal())->increment_refcount();\n+  entry->set_list_next(_symbol_list);\n+  _symbol_list = entry;\n+}\n+\n+bool JfrSymbolTable::on_equals(uintptr_t hash, const SymbolEntry* entry) {\n+  assert(entry != NULL, \"invariant\");\n+  assert(entry->hash() == hash, \"invariant\");\n+  assert(_symbol_query != NULL, \"invariant\");\n+  return _symbol_query == entry->literal();\n+}\n+\n+void JfrSymbolTable::on_unlink(const SymbolEntry* entry) {\n+  assert(entry != NULL, \"invariant\");\n+  const_cast<Symbol*>(entry->literal())->decrement_refcount();\n+}\n+\n+static const char* resource_to_cstring(const char* resource_str) {\n+  assert(resource_str != NULL, \"invariant\");\n+  const size_t length = strlen(resource_str);\n+  char* const c_string = JfrCHeapObj::new_array<char>(length + 1);\n+  assert(c_string != NULL, \"invariant\");\n+  strncpy(c_string, resource_str, length + 1);\n+  return c_string;\n+}\n+\n+void JfrSymbolTable::on_link(const CStringEntry* entry) {\n+  assign_id(entry);\n+  const_cast<CStringEntry*>(entry)->set_literal(resource_to_cstring(entry->literal()));\n+  entry->set_list_next(_cstring_list);\n+  _cstring_list = entry;\n+}\n+\n+static bool string_compare(const char* query, const char* candidate) {\n+  assert(query != NULL, \"invariant\");\n+  assert(candidate != NULL, \"invariant\");\n+  const size_t length = strlen(query);\n+  return strncmp(query, candidate, length) == 0;\n+}\n+\n+bool JfrSymbolTable::on_equals(uintptr_t hash, const CStringEntry* entry) {\n+  assert(entry != NULL, \"invariant\");\n+  assert(entry->hash() == hash, \"invariant\");\n+  assert(_cstring_query != NULL, \"invariant\");\n+  return string_compare(_cstring_query, entry->literal());\n+}\n+\n+void JfrSymbolTable::on_unlink(const CStringEntry* entry) {\n+  assert(entry != NULL, \"invariant\");\n+  JfrCHeapObj::free(const_cast<char*>(entry->literal()), strlen(entry->literal() + 1));\n+}\n+\n+traceid JfrSymbolTable::bootstrap_name(bool leakp) {\n+  assert(bootstrap != NULL, \"invariant\");\n+  if (leakp) {\n+    bootstrap->set_leakp();\n+  }\n+  return bootstrap->id();\n+}\n+\n+traceid JfrSymbolTable::mark(const Symbol* sym, bool leakp \/* false *\/) {\n+  assert(sym != NULL, \"invariant\");\n+  return mark((uintptr_t)sym->identity_hash(), sym, leakp);\n+}\n+\n+traceid JfrSymbolTable::mark(uintptr_t hash, const Symbol* sym, bool leakp) {\n+  assert(sym != NULL, \"invariant\");\n+  assert(_symbol_table != NULL, \"invariant\");\n+  _symbol_query = sym;\n+  const SymbolEntry& entry = _symbol_table->lookup_put(hash, sym);\n+  if (_class_unload) {\n+    entry.set_unloading();\n+  }\n+  if (leakp) {\n+    entry.set_leakp();\n+  }\n+  return entry.id();\n+}\n+\n+traceid JfrSymbolTable::mark(const char* str, bool leakp \/* false*\/) {\n+  return mark(string_hash(str), str, leakp);\n+}\n+\n+traceid JfrSymbolTable::mark(uintptr_t hash, const char* str, bool leakp) {\n+  assert(str != NULL, \"invariant\");\n+  assert(_cstring_table != NULL, \"invariant\");\n+  _cstring_query = str;\n+  const CStringEntry& entry = _cstring_table->lookup_put(hash, str);\n+  if (_class_unload) {\n+    entry.set_unloading();\n+  }\n+  if (leakp) {\n+    entry.set_leakp();\n+  }\n+  return entry.id();\n+}\n+\n+\/*\n+* hidden classes symbol is the external name +\n+* the address of its InstanceKlass slash appended:\n+*   java.lang.invoke.LambdaForm$BMH\/22626602\n+*\n+* caller needs ResourceMark\n+*\/\n+\n+uintptr_t JfrSymbolTable::hidden_klass_name_hash(const InstanceKlass* ik) {\n+  assert(ik != NULL, \"invariant\");\n+  assert(ik->is_hidden(), \"invariant\");\n+  const oop mirror = ik->java_mirror_no_keepalive();\n+  assert(mirror != NULL, \"invariant\");\n+  return (uintptr_t)mirror->identity_hash();\n+}\n+\n+static const char* create_hidden_klass_symbol(const InstanceKlass* ik, uintptr_t hash) {\n+  assert(ik != NULL, \"invariant\");\n+  assert(ik->is_hidden(), \"invariant\");\n+  assert(hash != 0, \"invariant\");\n+  char* hidden_symbol = NULL;\n+  const oop mirror = ik->java_mirror_no_keepalive();\n+  assert(mirror != NULL, \"invariant\");\n+  char hash_buf[40];\n+  sprintf(hash_buf, \"\/\" UINTX_FORMAT, hash);\n+  const size_t hash_len = strlen(hash_buf);\n+  const size_t result_len = ik->name()->utf8_length();\n+  hidden_symbol = NEW_RESOURCE_ARRAY(char, result_len + hash_len + 1);\n+  ik->name()->as_klass_external_name(hidden_symbol, (int)result_len + 1);\n+  assert(strlen(hidden_symbol) == result_len, \"invariant\");\n+  strcpy(hidden_symbol + result_len, hash_buf);\n+  assert(strlen(hidden_symbol) == result_len + hash_len, \"invariant\");\n+  return hidden_symbol;\n+}\n+\n+bool JfrSymbolTable::is_hidden_klass(const Klass* k) {\n+  assert(k != NULL, \"invariant\");\n+  return k->is_instance_klass() && ((const InstanceKlass*)k)->is_hidden();\n+}\n+\n+traceid JfrSymbolTable::mark_hidden_klass_name(const InstanceKlass* ik, bool leakp) {\n+  assert(ik != NULL, \"invariant\");\n+  assert(ik->is_hidden(), \"invariant\");\n+  const uintptr_t hash = hidden_klass_name_hash(ik);\n+  const char* const hidden_symbol = create_hidden_klass_symbol(ik, hash);\n+  return mark(hash, hidden_symbol, leakp);\n+}\n+\n+traceid JfrSymbolTable::mark(const Klass* k, bool leakp) {\n+  assert(k != NULL, \"invariant\");\n+  traceid symbol_id = 0;\n+  if (is_hidden_klass(k)) {\n+    assert(k->is_instance_klass(), \"invariant\");\n+    symbol_id = mark_hidden_klass_name((const InstanceKlass*)k, leakp);\n+  } else {\n+    Symbol* const sym = k->name();\n+    if (sym != NULL) {\n+      symbol_id = mark(sym, leakp);\n+    }\n+  }\n+  assert(symbol_id > 0, \"a symbol handler must mark the symbol for writing\");\n+  return symbol_id;\n+}\n+\n+template <typename T>\n+traceid JfrSymbolTable::add_impl(const T* sym) {\n+  assert(sym != NULL, \"invariant\");\n+  assert(_instance != NULL, \"invariant\");\n+  assert_locked_or_safepoint(ClassLoaderDataGraph_lock);\n+  return instance().mark(sym);\n+}\n+\n+traceid JfrSymbolTable::add(const Symbol* sym) {\n+  return add_impl(sym);\n+}\n+\n+traceid JfrSymbolTable::add(const char* str) {\n+  return add_impl(str);\n+}\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrSymbolTable.cpp","additions":316,"deletions":0,"binary":false,"changes":316,"status":"added"},{"patch":"@@ -0,0 +1,148 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_JFR_SUPPORT_JFRSYMBOLTABLE_HPP\n+#define SHARE_JFR_SUPPORT_JFRSYMBOLTABLE_HPP\n+\n+#include \"jfr\/utilities\/jfrHashtable.hpp\"\n+#include \"jfr\/utilities\/jfrTypes.hpp\"\n+\n+template <typename T, typename IdType>\n+class ListEntry : public JfrHashtableEntry<T, IdType> {\n+ public:\n+  ListEntry(uintptr_t hash, const T& data) : JfrHashtableEntry<T, IdType>(hash, data),\n+    _list_next(NULL), _serialized(false), _unloading(false), _leakp(false) {}\n+  const ListEntry<T, IdType>* list_next() const { return _list_next; }\n+  void reset() const {\n+    _list_next = NULL; _serialized = false; _unloading = false; _leakp = false;\n+  }\n+  void set_list_next(const ListEntry<T, IdType>* next) const { _list_next = next; }\n+  bool is_serialized() const { return _serialized; }\n+  void set_serialized() const { _serialized = true; }\n+  bool is_unloading() const { return _unloading; }\n+  void set_unloading() const { _unloading = true; }\n+  bool is_leakp() const { return _leakp; }\n+  void set_leakp() const { _leakp = true; }\n+ private:\n+  mutable const ListEntry<T, IdType>* _list_next;\n+  mutable bool _serialized;\n+  mutable bool _unloading;\n+  mutable bool _leakp;\n+};\n+\n+\/*\n+ * This table maps an oop\/Symbol* or a char* to the Jfr type 'Symbol'.\n+ *\n+ * It provides an interface over the corresponding constant pool (TYPE_SYMBOL),\n+ * which is represented in the binary format as a sequence of checkpoint events.\n+ * The returned id can be used as a foreign key, but please note that the id is\n+ * epoch-relative, and is therefore only valid in the current epoch \/ chunk.\n+ * The table is cleared as part of rotation.\n+ *\n+ * Caller must ensure mutual exclusion by means of the ClassLoaderDataGraph_lock or by safepointing.\n+ *\/\n+class JfrSymbolTable : public JfrCHeapObj {\n+  template <typename, typename, template<typename, typename> class, typename, size_t>\n+  friend class HashTableHost;\n+  typedef HashTableHost<const Symbol*, traceid, ListEntry, JfrSymbolTable> SymbolTable;\n+  typedef HashTableHost<const char*, traceid, ListEntry, JfrSymbolTable> CStringTable;\n+  friend class JfrArtifactSet;\n+\n+ public:\n+  typedef SymbolTable::HashEntry SymbolEntry;\n+  typedef CStringTable::HashEntry CStringEntry;\n+\n+  static traceid add(const Symbol* sym);\n+  static traceid add(const char* str);\n+\n+ private:\n+  SymbolTable* _symbol_table;\n+  CStringTable* _cstring_table;\n+  const SymbolEntry* _symbol_list;\n+  const CStringEntry* _cstring_list;\n+  const Symbol* _symbol_query;\n+  const char* _cstring_query;\n+  traceid _id_counter;\n+  bool _class_unload;\n+\n+  JfrSymbolTable();\n+  ~JfrSymbolTable();\n+  static JfrSymbolTable* create();\n+  static void destroy();\n+\n+  void clear();\n+  void increment_checkpoint_id();\n+  void set_class_unload(bool class_unload);\n+\n+  traceid mark(uintptr_t hash, const Symbol* sym, bool leakp);\n+  traceid mark(const Klass* k, bool leakp);\n+  traceid mark(const Symbol* sym, bool leakp = false);\n+  traceid mark(const char* str, bool leakp = false);\n+  traceid mark(uintptr_t hash, const char* str, bool leakp);\n+  traceid bootstrap_name(bool leakp);\n+\n+  bool has_entries() const { return has_symbol_entries() || has_cstring_entries(); }\n+  bool has_symbol_entries() const { return _symbol_list != NULL; }\n+  bool has_cstring_entries() const { return _cstring_list != NULL; }\n+\n+  traceid mark_hidden_klass_name(const InstanceKlass* k, bool leakp);\n+  bool is_hidden_klass(const Klass* k);\n+  uintptr_t hidden_klass_name_hash(const InstanceKlass* ik);\n+\n+  \/\/ hashtable(s) callbacks\n+  void on_link(const SymbolEntry* entry);\n+  bool on_equals(uintptr_t hash, const SymbolEntry* entry);\n+  void on_unlink(const SymbolEntry* entry);\n+  void on_link(const CStringEntry* entry);\n+  bool on_equals(uintptr_t hash, const CStringEntry* entry);\n+  void on_unlink(const CStringEntry* entry);\n+\n+  template <typename T>\n+  static traceid add_impl(const T* sym);\n+\n+  template <typename T>\n+  void assign_id(T* entry);\n+\n+  template <typename Functor>\n+  void iterate_symbols(Functor& functor) {\n+    iterate(functor, _symbol_list);\n+  }\n+\n+  template <typename Functor>\n+  void iterate_cstrings(Functor& functor) {\n+    iterate(functor, _cstring_list);\n+  }\n+\n+  template <typename Functor, typename T>\n+  void iterate(Functor& functor, const T* list) {\n+    const T* symbol = list;\n+    while (symbol != NULL) {\n+      const T* next = symbol->list_next();\n+      functor(symbol);\n+      symbol = next;\n+    }\n+  }\n+};\n+\n+#endif \/\/ SHARE_JFR_SUPPORT_JFRSYMBOLTABLE_HPP\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrSymbolTable.hpp","additions":148,"deletions":0,"binary":false,"changes":148,"status":"added"},{"patch":"@@ -92,0 +92,1 @@\n+                  Asserts.assertTrue(event.getString(\"codeSource\").startsWith(\"file:\/\/\"));\n@@ -96,0 +97,1 @@\n+                  Asserts.assertTrue(event.getString(\"codeSource\").startsWith(\"file:\/\/\"));\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/TestFinalizerEvent.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,4 @@\n+import java.net.URL;\n+import java.security.cert.Certificate;\n+import java.security.CodeSource;\n+import java.security.ProtectionDomain;\n@@ -56,1 +60,4 @@\n-                return defineClass(name, buf, 0, buf.length);\n+                URL url = getResource(resourceName);\n+                CodeSource cs = new CodeSource(url, (Certificate[])null);\n+                ProtectionDomain pd = new ProtectionDomain(cs, null);\n+                return defineClass(name, buf, 0, buf.length, pd);\n","filename":"test\/lib\/jdk\/test\/lib\/jfr\/TestClassLoader.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"}]}