{"files":[{"patch":"@@ -88,0 +88,3 @@\n+#if INCLUDE_MANAGEMENT\n+#include \"services\/finalizerTable.hpp\"\n+#endif\n@@ -1603,1 +1606,1 @@\n-\n+      MANAGEMENT_ONLY(FinalizerTable::purge_unloaded();)\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -55,1 +55,2 @@\n-  JMM_VERSION     = JMM_VERSION_3\n+  JMM_VERSION_4   = 0x20040000,  \/\/ JDK 18\n+  JMM_VERSION     = JMM_VERSION_4\n@@ -343,0 +344,3 @@\n+  void         (JNICALL *ReportFinalizationComplete)\n+                                                 (JNIEnv *env,\n+                                                  jobject finalizee);\n","filename":"src\/hotspot\/share\/include\/jmm.h","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1087,0 +1087,2 @@\n+    <Field type=\"ulong\" name=\"registrations\" label=\"Registrations\" description=\"Number of objects registered for finalization\" \/>\n+    <Field type=\"ulong\" name=\"invocations\" label=\"Invocations\" description=\"Number of objects finalized by the GC\" \/>\n","filename":"src\/hotspot\/share\/jfr\/metadata\/metadata.xml","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#if INCLUDE_MANAGEMENT\n@@ -37,0 +38,1 @@\n+#include \"services\/finalizerTable.hpp\"\n@@ -78,2 +80,2 @@\n-static void send_event(const InstanceKlass* ik, const JfrTicks& timestamp) {\n-  assert(ik, \"invariant\");\n+static void send_event(const FinalizerEntry* fe, const InstanceKlass* ik, const JfrTicks& timestamp, Thread* thread) {\n+  assert(ik != NULL, \"invariant\");\n@@ -81,0 +83,3 @@\n+  assert(thread != NULL, \"invariant\");\n+  const char* const url = codesource(ik, thread);\n+  const traceid codesource_symbol_id = url != NULL ? JfrSymbolTable::add(url) : 0;\n@@ -84,5 +89,9 @@\n-  Thread* const thread = Thread::current();\n-  ResourceMark rm(thread);\n-  const char* const url = codesource(ik, thread);\n-  const traceid symbol_id = url != NULL ? JfrSymbolTable::add(url) : 0;\n-  event.set_codeSource(symbol_id);\n+  event.set_codeSource(codesource_symbol_id);\n+  if (fe == NULL) {\n+    event.set_registrations(0);\n+    event.set_invocations(0);\n+  } else {\n+    assert(fe->klass() == ik, \"invariant\");\n+    event.set_registrations(fe->registered());\n+    event.set_invocations(fe->completed());\n+  }\n@@ -95,1 +104,3 @@\n-  send_event(ik, JfrTicks::now());\n+  Thread* const thread = Thread::current();\n+  ResourceMark rm(thread);\n+  send_event(FinalizerTable::lookup(ik, thread), ik, JfrTicks::now(), thread);\n@@ -100,1 +111,0 @@\n-static JfrTicks invocation_time;\n@@ -102,4 +112,10 @@\n-static void finalizer_event_callback(Klass* klass) {\n-  assert(klass != NULL, \"invariant\");\n-  if (!klass->is_instance_klass()) {\n-    return;\n+class FinalizerEventClosure : public FinalizerEntryClosure {\n+ private:\n+  Thread* _thread;\n+  const JfrTicks _timestamp;\n+ public:\n+  FinalizerEventClosure(Thread* thread) : _thread(thread), _timestamp(JfrTicks::now()) {}\n+  virtual bool do_entry(const FinalizerEntry* fe) {\n+    assert(fe != NULL, \"invariant\");\n+    send_event(fe, fe->klass(), _timestamp, _thread);\n+    return true;\n@@ -107,5 +123,1 @@\n-  const InstanceKlass* const ik = InstanceKlass::cast(klass);\n-  if (ik->has_finalizer()) {\n-    send_event(ik, invocation_time);\n-  }\n-}\n+};\n@@ -114,3 +126,5 @@\n-  invocation_time = JfrTicks::now();\n-  MutexLocker cld_lock(ClassLoaderDataGraph_lock);\n-  ClassLoaderDataGraph::classes_do(&finalizer_event_callback);\n+  Thread* const thread = Thread::current();\n+  ResourceMark rm(thread);\n+  FinalizerEventClosure fec(thread);\n+  MutexLocker lock(ClassLoaderDataGraph_lock);\n+  FinalizerTable::do_entries(&fec, thread);\n@@ -118,0 +132,2 @@\n+\n+#endif \/\/ INCLUDE_MANAGEMENT\n","filename":"src\/hotspot\/share\/jfr\/periodic\/jfrFinalizerEvent.cpp","additions":37,"deletions":21,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -34,2 +34,2 @@\n-  static void send_unload_event(const InstanceKlass* ik);\n-  static void generate_events();\n+  static void send_unload_event(const InstanceKlass* ik) NOT_MANAGEMENT_RETURN;\n+  static void generate_events() NOT_MANAGEMENT_RETURN;\n","filename":"src\/hotspot\/share\/jfr\/periodic\/jfrFinalizerEvent.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -649,0 +649,1 @@\n+#if INCLUDE_MANAGEMENT\n@@ -650,0 +651,3 @@\n+#else\n+  log_debug(jfr, system)(\"Unable to generate requestable event Finalizer. The required jvm feature 'management' is missing.\");\n+#endif\n","filename":"src\/hotspot\/share\/jfr\/periodic\/jfrPeriodic.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -112,0 +112,1 @@\n+#if INCLUDE_MANAGEMENT\n@@ -121,0 +122,1 @@\n+#endif\n@@ -125,1 +127,1 @@\n-  send_finalizer_event(k);\n+  MANAGEMENT_ONLY(send_finalizer_event(k);)\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrKlassUnloading.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -74,0 +74,1 @@\n+  LOG_TAG(finalizertable) \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -98,0 +98,3 @@\n+#if INCLUDE_MANAGEMENT\n+#include \"services\/finalizerTable.hpp\"\n+#endif\n@@ -1408,1 +1411,1 @@\n-  methodHandle mh (THREAD, Universe::finalizer_register_method());\n+  methodHandle mh(THREAD, Universe::finalizer_register_method());\n@@ -1410,0 +1413,1 @@\n+  MANAGEMENT_ONLY(FinalizerTable::on_register(h_i, THREAD);)\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -69,0 +69,1 @@\n+#include \"services\/finalizerTable.hpp\"\n@@ -594,0 +595,7 @@\n+    if (_subtasks.try_claim_task(SafepointSynchronize::SAFEPOINT_CLEANUP_REQUEST_FINALIZER_TABLE_REHASH)) {\n+      if (FinalizerTable::needs_rehashing()) {\n+        Tracer t(\"rehashing finalizer table\");\n+        FinalizerTable::rehash_table();\n+      }\n+    }\n+\n","filename":"src\/hotspot\/share\/runtime\/safepoint.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -80,0 +80,1 @@\n+    SAFEPOINT_CLEANUP_REQUEST_FINALIZER_TABLE_REHASH,\n","filename":"src\/hotspot\/share\/runtime\/safepoint.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+#include \"services\/finalizerTable.hpp\"\n@@ -118,0 +119,1 @@\n+    bool finalizertable_work = false;\n@@ -148,0 +150,1 @@\n+              (finalizertable_work = FinalizerTable::has_work()) |\n@@ -175,0 +178,4 @@\n+    if (finalizertable_work) {\n+      FinalizerTable::do_concurrent_work(jt);\n+    }\n+\n","filename":"src\/hotspot\/share\/runtime\/serviceThread.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -65,1 +65,0 @@\n-#if INCLUDE_MANAGEMENT\n@@ -79,0 +78,24 @@\n+#if INCLUDE_MANAGEMENT\n+\n+size_t ClassLoadingService::compute_class_size(InstanceKlass* k) {\n+  \/\/ lifted from ClassStatistics.do_class(Klass* k)\n+\n+  size_t class_size = 0;\n+\n+  class_size += k->size();\n+\n+  if (k->is_instance_klass()) {\n+    class_size += k->methods()->size();\n+    \/\/ FIXME: Need to count the contents of methods\n+    class_size += k->constants()->size();\n+    class_size += k->local_interfaces()->size();\n+    if (k->transitive_interfaces() != NULL) {\n+      class_size += k->transitive_interfaces()->size();\n+    }\n+    \/\/ We do not have to count implementors, since we only store one!\n+    \/\/ FIXME: How should these be accounted for, now when they have moved.\n+    \/\/class_size += k->fields()->size();\n+  }\n+  return class_size * oopSize;\n+}\n+\n@@ -122,4 +145,8 @@\n-void ClassLoadingService::notify_class_unloaded(InstanceKlass* k) {\n-  DTRACE_CLASSLOAD_PROBE(unloaded, k, false);\n-  \/\/ Classes that can be unloaded must be non-shared\n-  _classes_unloaded_count->inc();\n+bool ClassLoadingService::set_verbose(bool verbose) {\n+  MutexLocker m(Management_lock);\n+  \/\/ verbose will be set to the previous value\n+  LogLevelType level = verbose ? LogLevel::Info : LogLevel::Off;\n+  LogConfiguration::configure_stdout(level, false, LOG_TAGS(class, load));\n+  reset_trace_class_unloading();\n+  return verbose;\n+}\n@@ -127,4 +154,7 @@\n-  if (UsePerfData) {\n-    \/\/ add the class size\n-    size_t size = compute_class_size(k);\n-    _classbytes_unloaded->inc(size);\n+\/\/ Caller to this function must own Management_lock\n+void ClassLoadingService::reset_trace_class_unloading() {\n+  assert(Management_lock->owned_by_self(), \"Must own the Management_lock\");\n+  bool value = MemoryService::get_verbose() || ClassLoadingService::get_verbose();\n+  LogLevelType level = value ? LogLevel::Info : LogLevel::Off;\n+  LogConfiguration::configure_stdout(level, false, LOG_TAGS(class, unload));\n+}\n@@ -132,8 +162,34 @@\n-    \/\/ Compute method size & subtract from running total.\n-    \/\/ We are called during phase 1 of mark sweep, so it's\n-    \/\/ still ok to iterate through Method*s here.\n-    Array<Method*>* methods = k->methods();\n-    for (int i = 0; i < methods->length(); i++) {\n-      _class_methods_size->inc(-methods->at(i)->size());\n-    }\n-  }\n+jlong ClassLoadingService::loaded_class_count() {\n+  return _classes_loaded_count->get_value() + _shared_classes_loaded_count->get_value();\n+}\n+\n+jlong ClassLoadingService::unloaded_class_count() {\n+  return _classes_unloaded_count->get_value() + _shared_classes_unloaded_count->get_value();\n+}\n+\n+jlong ClassLoadingService::loaded_class_bytes() {\n+  return UsePerfData ? _classbytes_loaded->get_value() + _shared_classbytes_loaded->get_value() : -1;\n+}\n+\n+jlong ClassLoadingService::unloaded_class_bytes() {\n+  return UsePerfData ? _classbytes_unloaded->get_value() + _shared_classbytes_unloaded->get_value() : -1;\n+}\n+\n+jlong ClassLoadingService::loaded_shared_class_count() {\n+  return _shared_classes_loaded_count->get_value();\n+}\n+\n+jlong ClassLoadingService::unloaded_shared_class_count() {\n+  return _shared_classes_unloaded_count->get_value();\n+}\n+\n+jlong ClassLoadingService::loaded_shared_class_bytes() {\n+  return UsePerfData ? _shared_classbytes_loaded->get_value() : -1;\n+}\n+\n+jlong ClassLoadingService::unloaded_shared_class_bytes() {\n+  return UsePerfData ? _shared_classbytes_unloaded->get_value() : -1;\n+}\n+\n+jlong ClassLoadingService::class_method_data_size() {\n+  return UsePerfData ? _class_methods_size->get_value() : -1;\n@@ -158,4 +214,4 @@\n-size_t ClassLoadingService::compute_class_size(InstanceKlass* k) {\n-  \/\/ lifted from ClassStatistics.do_class(Klass* k)\n-\n-  size_t class_size = 0;\n+void ClassLoadingService::notify_class_unloaded(InstanceKlass* k) {\n+  DTRACE_CLASSLOAD_PROBE(unloaded, k, false);\n+  \/\/ Classes that can be unloaded must be non-shared\n+  _classes_unloaded_count->inc();\n@@ -163,1 +219,4 @@\n-  class_size += k->size();\n+  if (UsePerfData) {\n+    \/\/ add the class size\n+    size_t size = compute_class_size(k);\n+    _classbytes_unloaded->inc(size);\n@@ -165,7 +224,6 @@\n-  if (k->is_instance_klass()) {\n-    class_size += k->methods()->size();\n-    \/\/ FIXME: Need to count the contents of methods\n-    class_size += k->constants()->size();\n-    class_size += k->local_interfaces()->size();\n-    if (k->transitive_interfaces() != NULL) {\n-      class_size += k->transitive_interfaces()->size();\n+    \/\/ Compute method size & subtract from running total.\n+    \/\/ We are called during phase 1 of mark sweep, so it's\n+    \/\/ still ok to iterate through Method*s here.\n+    Array<Method*>* methods = k->methods();\n+    for (int i = 0; i < methods->length(); i++) {\n+      _class_methods_size->inc(-methods->at(i)->size());\n@@ -173,3 +231,0 @@\n-    \/\/ We do not have to count implementors, since we only store one!\n-    \/\/ FIXME: How should these be accounted for, now when they have moved.\n-    \/\/class_size += k->fields()->size();\n@@ -177,18 +232,0 @@\n-  return class_size * oopSize;\n-}\n-\n-bool ClassLoadingService::set_verbose(bool verbose) {\n-  MutexLocker m(Management_lock);\n-  \/\/ verbose will be set to the previous value\n-  LogLevelType level = verbose ? LogLevel::Info : LogLevel::Off;\n-  LogConfiguration::configure_stdout(level, false, LOG_TAGS(class, load));\n-  reset_trace_class_unloading();\n-  return verbose;\n-}\n-\n-\/\/ Caller to this function must own Management_lock\n-void ClassLoadingService::reset_trace_class_unloading() {\n-  assert(Management_lock->owned_by_self(), \"Must own the Management_lock\");\n-  bool value = MemoryService::get_verbose() || ClassLoadingService::get_verbose();\n-  LogLevelType level = value ? LogLevel::Info : LogLevel::Off;\n-  LogConfiguration::configure_stdout(level, false, LOG_TAGS(class, unload));\n","filename":"src\/hotspot\/share\/services\/classLoadingService.cpp","additions":87,"deletions":50,"binary":false,"changes":137,"status":"modified"},{"patch":"@@ -56,4 +56,2 @@\n-  static void init();\n-\n-  static bool get_verbose() { return log_is_enabled(Info, class, load); }\n-  static bool set_verbose(bool verbose);\n+  static void init() NOT_MANAGEMENT_RETURN;\n+  static bool set_verbose(bool verbose) NOT_MANAGEMENT_RETURN_(false);\n@@ -61,45 +59,10 @@\n-\n-  static jlong loaded_class_count() {\n-    return _classes_loaded_count->get_value() + _shared_classes_loaded_count->get_value();\n-  }\n-  static jlong unloaded_class_count() {\n-    return _classes_unloaded_count->get_value() + _shared_classes_unloaded_count->get_value();\n-  }\n-  static jlong loaded_class_bytes() {\n-    if (UsePerfData) {\n-      return _classbytes_loaded->get_value() + _shared_classbytes_loaded->get_value();\n-    } else {\n-      return -1;\n-    }\n-  }\n-  static jlong unloaded_class_bytes() {\n-    if (UsePerfData) {\n-      return _classbytes_unloaded->get_value() + _shared_classbytes_unloaded->get_value();\n-    } else {\n-      return -1;\n-    }\n-  }\n-\n-  static jlong loaded_shared_class_count() {\n-    return _shared_classes_loaded_count->get_value();\n-  }\n-  static jlong unloaded_shared_class_count() {\n-    return _shared_classes_unloaded_count->get_value();\n-  }\n-  static jlong loaded_shared_class_bytes() {\n-    if (UsePerfData) {\n-      return _shared_classbytes_loaded->get_value();\n-    } else {\n-      return -1;\n-    }\n-  }\n-  static jlong unloaded_shared_class_bytes() {\n-    if (UsePerfData) {\n-      return _shared_classbytes_unloaded->get_value();\n-    } else {\n-      return -1;\n-    }\n-  }\n-  static jlong class_method_data_size() {\n-    return (UsePerfData ? _class_methods_size->get_value() : -1);\n-  }\n+  static jlong loaded_class_count() NOT_MANAGEMENT_RETURN_(0L);\n+  static jlong unloaded_class_count() NOT_MANAGEMENT_RETURN_(0L);\n+  static jlong loaded_class_bytes() NOT_MANAGEMENT_RETURN_(0L);\n+  static jlong unloaded_class_bytes() NOT_MANAGEMENT_RETURN_(0L);\n+  static jlong loaded_shared_class_count() NOT_MANAGEMENT_RETURN_(0L);\n+  static jlong unloaded_shared_class_count() NOT_MANAGEMENT_RETURN_(0L);\n+  static jlong loaded_shared_class_bytes() NOT_MANAGEMENT_RETURN_(0L);\n+  static jlong unloaded_shared_class_bytes() NOT_MANAGEMENT_RETURN_(0L);\n+  static jlong class_method_data_size() NOT_MANAGEMENT_RETURN_(0L);\n+  static bool get_verbose() { return log_is_enabled(Info, class, load); }\n","filename":"src\/hotspot\/share\/services\/classLoadingService.hpp","additions":12,"deletions":49,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -0,0 +1,453 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#if INCLUDE_MANAGEMENT\n+#include \"classfile\/classLoaderDataGraph.inline.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/handles.hpp\"\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n+#include \"runtime\/javaCalls.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n+#include \"runtime\/thread.inline.hpp\"\n+#include \"runtime\/vm_version.hpp\"\n+#include \"services\/finalizerTable.hpp\"\n+#include \"utilities\/concurrentHashTableTasks.inline.hpp\"\n+#include \"utilities\/debug.hpp\"\n+\n+static inline void atomic_inc(uint64_t* volatile dest) {\n+  assert(VM_Version::supports_cx8(), \"invariant\");\n+  uint64_t compare;\n+  uint64_t exchange;\n+  do {\n+    compare = *dest;\n+    exchange = compare + 1;\n+  } while (Atomic::cmpxchg(dest, compare, exchange) != compare);\n+}\n+\n+const InstanceKlass* FinalizerEntry::klass() const {\n+  return _ik;\n+}\n+\n+uint64_t FinalizerEntry::completed() const {\n+  return Atomic::load(&_completed);\n+}\n+\n+uint64_t FinalizerEntry::registered() const {\n+  return Atomic::load(&_registered);\n+}\n+\n+void FinalizerEntry::on_register() {\n+  atomic_inc(&_registered);\n+}\n+\n+void FinalizerEntry::on_complete() {\n+  atomic_inc(&_completed);\n+}\n+\n+static constexpr const size_t DEFAULT_TABLE_SIZE = 2048;\n+\/\/ 2^24 is max size, like StringTable.\n+static constexpr const size_t MAX_SIZE = 24;\n+\/\/ If a chain gets to 50, something might be wrong\n+static constexpr const size_t REHASH_LEN = 50;\n+static constexpr const double PREF_AVG_LIST_LEN = 8.0;\n+\n+static size_t _table_size = 0;\n+static volatile uint64_t _entries = 0;\n+static volatile uint64_t _count = 0;\n+static volatile bool _has_work = 0;\n+static volatile bool _needs_rehashing = false;\n+static volatile bool _has_items_to_clean = false;\n+\n+static inline void reset_has_items_to_clean() {\n+  Atomic::store(&_has_items_to_clean, false);\n+}\n+\n+static inline void set_has_items_to_clean() {\n+  Atomic::store(&_has_items_to_clean, true);\n+}\n+\n+static inline bool has_items_to_clean() {\n+  return Atomic::load(&_has_items_to_clean);\n+}\n+\n+static inline void added() {\n+  Atomic::inc(&_count);\n+}\n+\n+static inline void removed() {\n+  Atomic::dec(&_count);\n+}\n+\n+static inline uintx hash_function(const InstanceKlass* ik) {\n+  assert(ik != nullptr, \"invariant\");\n+  return primitive_hash(ik);\n+}\n+\n+static inline uintx hash_function(const FinalizerEntry* fe) {\n+  return hash_function(fe->klass());\n+}\n+\n+class FinalizerEntryLookup : StackObj {\n+ private:\n+  const InstanceKlass* const _ik;\n+ public:\n+  FinalizerEntryLookup(const InstanceKlass* ik) : _ik(ik) {}\n+  uintx get_hash() const { return hash_function(_ik); }\n+  bool equals(FinalizerEntry** value, bool* is_dead) {\n+    assert(value != nullptr, \"invariant\");\n+    assert(*value != nullptr, \"invariant\");\n+    return (*value)->klass() == _ik;\n+  }\n+};\n+\n+class FinalizerTableConfig : public AllStatic {\n+ public:\n+  typedef FinalizerEntry* Value;  \/\/ value of the Node in the hashtable\n+\n+  static uintx get_hash(Value const& value, bool* is_dead) {\n+    return hash_function(value);\n+  }\n+  \/\/ We use default allocation\/deallocation but counted\n+  static void* allocate_node(void* context, size_t size, Value const& value) {\n+    added();\n+    return AllocateHeap(size, mtClass);\n+  }\n+  static void free_node(void* context, void* memory, Value const& value) {\n+    \/\/ We get here because some threads lost a race to insert a newly created FinalizerEntry\n+    FreeHeap(memory);\n+    removed();\n+  }\n+};\n+\n+typedef ConcurrentHashTable<FinalizerTableConfig, mtClass> FinalizerHashtable;\n+static FinalizerHashtable* _table = nullptr;\n+\n+static size_t ceil_log2(size_t value) {\n+  size_t ret;\n+  for (ret = 1; ((size_t)1 << ret) < value; ++ret);\n+  return ret;\n+}\n+\n+static double table_load_factor() {\n+  return (double)_count \/ _table_size;\n+}\n+\n+static inline size_t table_size() {\n+  return ((size_t)1) << _table->get_size_log2(Thread::current());\n+}\n+\n+static inline bool table_needs_rehashing() {\n+  return _needs_rehashing;\n+}\n+\n+static inline void update_table_needs_rehash(bool rehash) {\n+  if (rehash) {\n+    _needs_rehashing = true;\n+  }\n+}\n+\n+class FinalizerEntryLookupResult {\n+ private:\n+  FinalizerEntry* _result;\n+ public:\n+  FinalizerEntryLookupResult() : _result(nullptr) {}\n+  void operator()(FinalizerEntry* node) {\n+    assert(node != nullptr, \"invariant\");\n+    _result = node;\n+  }\n+  FinalizerEntry* result() const { return _result; }\n+};\n+\n+class FinalizerEntryLookupGet {\n+ private:\n+  FinalizerEntry* _result;\n+ public:\n+  FinalizerEntryLookupGet() : _result(nullptr) {}\n+  void operator()(FinalizerEntry** node) {\n+    assert(node != nullptr, \"invariant\");\n+    _result = *node;\n+  }\n+  FinalizerEntry* result() const { return _result; }\n+};\n+\n+static void trigger_table_cleanup() {\n+  MutexLocker ml(Service_lock, Mutex::_no_safepoint_check_flag);\n+  _has_work = true;\n+  Service_lock->notify_all();\n+}\n+\n+static void check_table_concurrent_work() {\n+  if (_has_work) {\n+    return;\n+  }\n+  \/\/ We should clean\/resize if we have\n+  \/\/ more items than preferred load factor or\n+  \/\/ more dead items than water mark.\n+  if (has_items_to_clean() || (table_load_factor() > PREF_AVG_LIST_LEN)) {\n+    trigger_table_cleanup();\n+  }\n+}\n+\n+static FinalizerEntry* add_to_table_if_needed(const InstanceKlass* ik, Thread* thread) {\n+  FinalizerEntryLookup lookup(ik);\n+  bool clean_hint = false;\n+  bool rehash_warning = false;\n+  FinalizerEntry* entry = nullptr;\n+  do {\n+    \/\/ We have looked up the entry once, proceed with insertion.\n+    entry = new FinalizerEntry(ik);\n+    if (_table->insert(thread, lookup, entry, &rehash_warning, &clean_hint)) {\n+      break;\n+    }\n+    \/\/ In case another thread did a concurrent add, return value already in the table.\n+    \/\/ This could fail if the entry got deleted concurrently, so loop back until success.\n+    FinalizerEntryLookupGet felg;\n+    if (_table->get(thread, lookup, felg, &rehash_warning)) {\n+      entry = felg.result();\n+      break;\n+    }\n+  } while (true);\n+  update_table_needs_rehash(rehash_warning);\n+  if (clean_hint) {\n+    set_has_items_to_clean();\n+    check_table_concurrent_work();\n+  }\n+  assert(entry != nullptr, \"invariant\");\n+  return entry;\n+}\n+\n+\/\/ Concurrent work\n+static void grow_table(JavaThread* jt) {\n+  FinalizerHashtable::GrowTask gt(_table);\n+  if (!gt.prepare(jt)) {\n+    return;\n+  }\n+  while (gt.do_task(jt)) {\n+    gt.pause(jt);\n+    {\n+      ThreadBlockInVM tbivm(jt);\n+    }\n+    gt.cont(jt);\n+  }\n+  gt.done(jt);\n+  _table_size = table_size();\n+}\n+\n+struct FinalizerEntryDelete : StackObj {\n+  size_t _deleted;\n+  FinalizerEntryDelete() : _deleted(0) {}\n+  void operator()(FinalizerEntry** value) {\n+    assert(value != nullptr, \"invariant\");\n+    assert(*value != nullptr, \"invariant\");\n+    _deleted++;\n+  }\n+};\n+\n+struct FinalizerEntryDeleteCheck : StackObj {\n+  size_t _processed;\n+  FinalizerEntryDeleteCheck() : _processed(0) {}\n+  bool operator()(FinalizerEntry** value) {\n+    assert(value != nullptr, \"invariant\");\n+    assert(*value != nullptr, \"invariant\");\n+    _processed++;\n+    return true;\n+  }\n+};\n+\n+static void clean_table_entries(JavaThread* jt) {\n+  FinalizerHashtable::BulkDeleteTask bdt(_table);\n+  if (!bdt.prepare(jt)) {\n+    return;\n+  }\n+  FinalizerEntryDeleteCheck fedc;\n+  FinalizerEntryDelete fed;\n+  while (bdt.do_task(jt, fedc, fed)) {\n+    bdt.pause(jt);\n+    {\n+      ThreadBlockInVM tbivm(jt);\n+    }\n+    bdt.cont(jt);\n+  }\n+  reset_has_items_to_clean();\n+  bdt.done(jt);\n+}\n+\n+static void do_table_concurrent_work(JavaThread* jt) {\n+  \/\/ We prefer growing, since that also removes dead items\n+  if (table_load_factor() > PREF_AVG_LIST_LEN && !_table->is_max_size_reached()) {\n+    grow_table(jt);\n+  } else {\n+    clean_table_entries(jt);\n+  }\n+  _has_work = false;\n+}\n+\n+\/\/ Rehash\n+static bool do_table_rehash() {\n+  if (!_table->is_safepoint_safe()) {\n+    return false;\n+  }\n+  Thread* const thread = Thread::current();\n+  \/\/ We use current size\n+  const size_t new_size = _table->get_size_log2(thread);\n+  FinalizerHashtable* const new_table = new FinalizerHashtable(new_size, MAX_SIZE, REHASH_LEN);\n+  if (!_table->try_move_nodes_to(thread, new_table)) {\n+    delete new_table;\n+    return false;\n+  }\n+  \/\/ free old table\n+  delete _table;\n+  _table = new_table;\n+  return true;\n+}\n+\n+bool FinalizerTable::needs_rehashing() {\n+  return _needs_rehashing;\n+}\n+\n+void FinalizerTable::rehash_table() {\n+  static bool rehashed = false;\n+  log_debug(finalizertable)(\"Table imbalanced, rehashing called.\");\n+  \/\/ Grow instead of rehash.\n+  if (table_load_factor() > PREF_AVG_LIST_LEN && !_table->is_max_size_reached()) {\n+    log_debug(finalizertable)(\"Choosing growing over rehashing.\");\n+    trigger_table_cleanup();\n+    _needs_rehashing = false;\n+    return;\n+  }\n+  \/\/ Already rehashed.\n+  if (rehashed) {\n+    log_warning(finalizertable)(\"Rehashing already done, still long lists.\");\n+    trigger_table_cleanup();\n+    _needs_rehashing = false;\n+    return;\n+  }\n+  if (do_table_rehash()) {\n+    rehashed = true;\n+  } else {\n+    log_info(finalizertable)(\"Resizes in progress rehashing skipped.\");\n+  }\n+  _needs_rehashing = false;\n+}\n+\n+bool FinalizerTable::has_work() {\n+  return _has_work;\n+}\n+\n+void FinalizerTable::do_concurrent_work(JavaThread* service_thread) {\n+  assert(service_thread != nullptr, \"invariant\");\n+  if (_has_work) {\n+    do_table_concurrent_work(service_thread);\n+  }\n+}\n+\n+bool FinalizerTable::create_table() {\n+  assert(_table == nullptr, \"invariant\");\n+  const size_t start_size_log_2 = ceil_log2(DEFAULT_TABLE_SIZE);\n+  _table_size = ((size_t)1) << start_size_log_2;\n+  _table = new FinalizerHashtable(start_size_log_2, MAX_SIZE, REHASH_LEN);\n+  return _table != nullptr;\n+}\n+\n+static FinalizerEntry* lookup_entry(const InstanceKlass* ik, Thread* thread) {\n+  FinalizerEntryLookup lookup(ik);\n+  FinalizerEntryLookupGet felg;\n+  bool rehash_warning;\n+  _table->get(thread, lookup, felg, &rehash_warning);\n+  return felg.result();\n+}\n+\n+static FinalizerEntry* get_entry(const InstanceKlass* ik, Thread* thread) {\n+  assert(ik != nullptr, \"invariant\");\n+  FinalizerEntry* const entry = lookup_entry(ik, thread);\n+  return entry != nullptr ? entry : add_to_table_if_needed(ik, thread);\n+}\n+\n+const FinalizerEntry* FinalizerTable::lookup(const InstanceKlass* ik, Thread* thread) {\n+  assert(ik != nullptr, \"invariant\");\n+  assert(thread != nullptr, \"invariant\");\n+  assert(ik->has_finalizer(), \"invariant\");\n+  return lookup_entry(ik, thread);\n+}\n+\n+void FinalizerTable::on_register(const instanceHandle& h_i, Thread* thread) {\n+  assert(h_i.not_null(), \"invariant\");\n+  const InstanceKlass* const ik = InstanceKlass::cast(h_i->klass());\n+  assert(ik != nullptr, \"invariant\");\n+  assert(ik->has_finalizer(), \"invariant\");\n+  FinalizerEntry* const fe = get_entry(ik, thread);\n+  assert(fe != nullptr, \"invariant\");\n+  fe->on_register();\n+}\n+\n+void FinalizerTable::on_complete(const instanceHandle& h_i, JavaThread* finalizerThread) {\n+  assert(h_i.not_null(), \"invariant\");\n+  const InstanceKlass* const ik = InstanceKlass::cast(h_i->klass());\n+  assert(ik != nullptr, \"invariant\");\n+  assert(ik->has_finalizer(), \"invariant\");\n+  FinalizerEntry* const fe = get_entry(ik, finalizerThread);\n+  assert(fe != nullptr, \"invariant\");\n+  fe->on_complete();\n+}\n+\n+class FinalizerScan : public StackObj {\n+ private:\n+  FinalizerEntryClosure* _closure;\n+ public:\n+  FinalizerScan(FinalizerEntryClosure* closure) : _closure(closure) {}\n+  bool operator()(FinalizerEntry** fe) {\n+    return _closure->do_entry(*fe);\n+  }\n+};\n+\n+void FinalizerTable::do_entries(FinalizerEntryClosure* closure, Thread* thread) {\n+  assert(closure != nullptr, \"invariant\");\n+  FinalizerScan scan(closure);\n+  _table->do_scan(thread, scan);\n+}\n+\n+static bool remove_entry(const InstanceKlass* ik) {\n+  assert(ik != nullptr, \"invariant\");\n+  FinalizerEntryLookup lookup(ik);\n+  return _table->remove(Thread::current(), lookup);\n+}\n+\n+static void on_unloading(Klass* klass) {\n+  assert(klass != nullptr, \"invariant\");\n+  if (!klass->is_instance_klass()) {\n+    return;\n+  }\n+  const InstanceKlass* const ik = InstanceKlass::cast(klass);\n+  if (ik->has_finalizer()) {\n+    remove_entry(ik);\n+  }\n+}\n+\n+void FinalizerTable::purge_unloaded() {\n+  assert_locked_or_safepoint(ClassLoaderDataGraph_lock);\n+  ClassLoaderDataGraph::classes_unloading_do(&on_unloading);\n+}\n+\n+#endif \/\/ INCLUDE_MANAGEMENT\n","filename":"src\/hotspot\/share\/services\/finalizerTable.cpp","additions":453,"deletions":0,"binary":false,"changes":453,"status":"added"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_SERVICES_FINALIZERTABLE_HPP\n+#define SHARE_SERVICES_FINALIZERTABLE_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+\n+class instanceHandle;\n+class InstanceKlass;\n+class JavaThread;\n+class Thread;\n+\n+class FinalizerEntry : public CHeapObj<mtClass> {\n+ private:\n+  const InstanceKlass* const _ik;\n+  uint64_t _completed;\n+  uint64_t _registered;\n+ public:\n+  FinalizerEntry(const InstanceKlass* ik) : _ik(ik), _completed(0), _registered(0) {}\n+  const InstanceKlass* klass() const NOT_MANAGEMENT_RETURN_(nullptr);\n+  uint64_t completed() const NOT_MANAGEMENT_RETURN_(0L);\n+  uint64_t registered() const NOT_MANAGEMENT_RETURN_(0L);\n+  void on_register() NOT_MANAGEMENT_RETURN;\n+  void on_complete() NOT_MANAGEMENT_RETURN;\n+};\n+\n+class FinalizerEntryClosure : public StackObj {\n+ public:\n+  virtual bool do_entry(const FinalizerEntry* fe) = 0;\n+};\n+\n+class FinalizerTable : AllStatic {\n+  friend class ServiceThread;\n+ private:\n+  static bool has_work() NOT_MANAGEMENT_RETURN_(false);\n+  static void do_concurrent_work(JavaThread* service_thread) NOT_MANAGEMENT_RETURN;;\n+ public:\n+  static bool create_table() NOT_MANAGEMENT_RETURN_(false);\n+  static void rehash_table() NOT_MANAGEMENT_RETURN;\n+  static bool needs_rehashing() NOT_MANAGEMENT_RETURN_(false);\n+  static void purge_unloaded() NOT_MANAGEMENT_RETURN;\n+  static void on_complete(const instanceHandle& i, JavaThread* finalizerThread) NOT_MANAGEMENT_RETURN;\n+  static void on_register(const instanceHandle& i, Thread* thread) NOT_MANAGEMENT_RETURN;\n+  static void do_entries(FinalizerEntryClosure* closure, Thread* thread) NOT_MANAGEMENT_RETURN;\n+  static const FinalizerEntry* lookup(const InstanceKlass* ik, Thread* thread) NOT_MANAGEMENT_RETURN_(nullptr);\n+};\n+\n+#endif \/\/ SHARE_SERVICES_FINALIZERTABLE_HPP\n","filename":"src\/hotspot\/share\/services\/finalizerTable.hpp","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -58,0 +58,1 @@\n+#include \"services\/finalizerTable.hpp\"\n@@ -97,0 +98,1 @@\n+  FinalizerTable::create_table();\n@@ -209,0 +211,9 @@\n+\n+void Management::record_vm_init_completed() {\n+  \/\/ Initialize the timestamp to get the current time\n+  _vm_init_done_time->set_value(os::javaTimeMillis());\n+\n+  \/\/ Update the timestamp to the vm init done time\n+  _stamp.update();\n+}\n+\n@@ -219,0 +230,8 @@\n+jlong Management::begin_vm_creation_time() {\n+  return _begin_vm_creation_time->get_value();\n+}\n+\n+jlong Management::vm_init_done_time() {\n+  return _vm_init_done_time->get_value();\n+}\n+\n@@ -2066,0 +2085,7 @@\n+\n+JVM_ENTRY(void, jmm_ReportFinalizationComplete(JNIEnv* env, jobject finalizee))\n+  HandleMark hm(THREAD);\n+  instanceHandle h_i(THREAD, instanceOop(JNIHandles::resolve_non_null(finalizee)));\n+  FinalizerTable::on_complete(h_i, THREAD);\n+JVM_END\n+\n@@ -2200,2 +2226,0 @@\n-\n-\n@@ -2243,1 +2267,2 @@\n-  jmm_SetDiagnosticFrameworkNotificationEnabled\n+  jmm_SetDiagnosticFrameworkNotificationEnabled,\n+  jmm_ReportFinalizationComplete\n","filename":"src\/hotspot\/share\/services\/management.cpp","additions":28,"deletions":3,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -73,3 +73,1 @@\n-  static void  record_vm_init_completed() {\n-    \/\/ Initialize the timestamp to get the current time\n-    _vm_init_done_time->set_value(os::javaTimeMillis());\n+  static void  record_vm_init_completed() NOT_MANAGEMENT_RETURN;\n@@ -77,10 +75,2 @@\n-    \/\/ Update the timestamp to the vm init done time\n-    _stamp.update();\n-  }\n-\n-  static jlong begin_vm_creation_time() {\n-    return _begin_vm_creation_time->get_value();\n-  }\n-  static jlong vm_init_done_time() {\n-    return _vm_init_done_time->get_value();\n-  }\n+  static jlong begin_vm_creation_time() NOT_MANAGEMENT_RETURN_(0L);\n+  static jlong vm_init_done_time() NOT_MANAGEMENT_RETURN_(0L);\n","filename":"src\/hotspot\/share\/services\/management.hpp","additions":3,"deletions":13,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -129,0 +129,1 @@\n+#define MANAGEMENT_ONLY(x) x\n@@ -132,0 +133,1 @@\n+#define MANAGEMENT_ONLY(x)\n","filename":"src\/hotspot\/share\/utilities\/macros.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,0 +48,7 @@\n+    static {\n+        initIDs();\n+    }\n+\n+    private static native void initIDs();\n+    private static native void reportComplete(Object finalizee);\n+\n@@ -64,0 +71,2 @@\n+\n+\n@@ -89,0 +98,1 @@\n+                reportComplete(finalizee);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/Finalizer.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jmm.h\"\n+#include \"jvm.h\"\n+\n+#include \"java_lang_ref_Finalizer.h\"\n+\n+static const JmmInterface* jmm_interface = NULL;\n+\n+JNIEXPORT void JNICALL\n+Java_java_lang_ref_Finalizer_initIDs(JNIEnv* env, jclass cls) {\n+  jmm_interface = (JmmInterface*)JVM_GetManagement(JMM_VERSION);\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_java_lang_ref_Finalizer_reportComplete(JNIEnv* env, jclass cls, jobject finalizee) {\n+  if (jmm_interface != NULL) {\n+    jmm_interface->ReportFinalizationComplete(env, finalizee);\n+  }\n+}\n+\n+\n","filename":"src\/java.base\/share\/native\/libjava\/Finalizer.c","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -53,0 +53,5 @@\n+    public static Class<?> unloadOverrideClass;\n+\n+    public static Object overridingInstance1;\n+    public static Object overridingInstance2;\n+    public static Object overridingInstance3;\n@@ -61,1 +66,0 @@\n-\n@@ -63,1 +67,2 @@\n-        cl.loadClass(TEST_CLASS_NAME);\n+        Class<?> overrideClass = cl.loadClass(TEST_CLASS_NAME);\n+        overridingInstance1 = overrideClass.newInstance();\n@@ -65,1 +70,3 @@\n-        unloadableClassLoader.loadClass(TEST_CLASS_UNLOAD_NAME);\n+        overridingInstance2 = overrideClass.newInstance();\n+        unloadOverrideClass = unloadableClassLoader.loadClass(TEST_CLASS_UNLOAD_NAME);\n+        unloadOverrideClass = null;\n@@ -70,0 +77,1 @@\n+        overridingInstance3 = overrideClass.newInstance();\n@@ -73,0 +81,1 @@\n+            System.out.println(\"Verifying recording2\");\n@@ -74,0 +83,1 @@\n+            System.out.println(\"Verifying recording1\");\n@@ -102,3 +112,0 @@\n-          if (foundTestClassName && foundTestClassUnloadName) {\n-              break;\n-          }\n@@ -110,1 +117,1 @@\n-    static class TestClassOverridingFinalize {\n+    static public class TestClassOverridingFinalize {\n@@ -119,1 +126,1 @@\n-    static class TestClassUnloadOverridingFinalize {\n+    static public class TestClassUnloadOverridingFinalize {\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/TestFinalizerEvent.java","additions":15,"deletions":8,"binary":false,"changes":23,"status":"modified"}]}