{"files":[{"patch":"@@ -79,0 +79,1 @@\n+#include \"services\/finalizerService.hpp\"\n@@ -1603,1 +1604,1 @@\n-\n+      MANAGEMENT_ONLY(FinalizerService::purge_unloaded();)\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -55,1 +55,2 @@\n-  JMM_VERSION     = JMM_VERSION_3\n+  JMM_VERSION_4   = 0x20040000, \/\/ JDK 18\n+  JMM_VERSION     = JMM_VERSION_4\n@@ -343,0 +344,3 @@\n+  void         (JNICALL *ReportFinalizationComplete)\n+                                                 (JNIEnv *env,\n+                                                  jobject finalizee);\n","filename":"src\/hotspot\/share\/include\/jmm.h","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -386,1 +386,1 @@\n-static bool find_field(InstanceKlass* ik,\n+static bool find_field(const InstanceKlass* ik,\n@@ -398,1 +398,1 @@\n-static void lookup_field(JfrJavaArguments* args, InstanceKlass* klass, fieldDescriptor* fd, bool static_field) {\n+static void lookup_field(JfrJavaArguments* args, const InstanceKlass* ik, fieldDescriptor* fd, bool static_field) {\n@@ -400,2 +400,2 @@\n-  assert(klass != NULL, \"invariant\");\n-  assert(klass->is_initialized(), \"invariant\");\n+  assert(ik != NULL, \"invariant\");\n+  assert(ik->is_initialized(), \"invariant\");\n@@ -403,1 +403,12 @@\n-  find_field(klass, args->name(), args->signature(), fd, static_field, true);\n+  find_field(ik, args->name(), args->signature(), fd, static_field, true);\n+}\n+\n+static void read_field(JfrJavaArguments* args, JavaValue* result, Thread* thread) {\n+  const bool static_field = !args->has_receiver();\n+  fieldDescriptor fd;\n+  const InstanceKlass* const ik = static_cast<InstanceKlass*>(args->klass());\n+  lookup_field(args, ik, &fd, static_field);\n+  assert(fd.offset() > 0, \"invariant\");\n+  HandleMark hm(thread);\n+  Handle h_oop(static_field ? Handle(thread, ik->java_mirror()) : Handle(thread, args->receiver()));\n+  read_specialized_field(result, h_oop, &fd);\n@@ -410,1 +421,0 @@\n-\n@@ -413,8 +423,1 @@\n-  const bool static_field = !args->has_receiver();\n-  fieldDescriptor fd;\n-  lookup_field(args, klass, &fd, static_field);\n-  assert(fd.offset() > 0, \"invariant\");\n-\n-  HandleMark hm(THREAD);\n-  Handle h_oop(static_field ? Handle(THREAD, klass->java_mirror()) : Handle(THREAD, args->receiver()));\n-  read_specialized_field(result, h_oop, &fd);\n+  read_field(args, result, static_cast<Thread*>(THREAD));\n@@ -451,0 +454,5 @@\n+void JfrJavaSupport::get_field(JfrJavaArguments* args, Thread* thread) {\n+  assert(args != NULL, \"invariant\");\n+  read_field(args, args->result(), thread);\n+}\n+\n@@ -490,1 +498,1 @@\n-static char* allocate_string(bool c_heap, int length, JavaThread* jt) {\n+static char* allocate_string(bool c_heap, int length, Thread* thread) {\n@@ -492,1 +500,1 @@\n-                  NEW_RESOURCE_ARRAY_IN_THREAD(jt, char, length);\n+                  NEW_RESOURCE_ARRAY_IN_THREAD(thread, char, length);\n@@ -495,2 +503,1 @@\n-const char* JfrJavaSupport::c_str(oop string, JavaThread* t, bool c_heap \/* false *\/) {\n-  DEBUG_ONLY(check_java_thread_in_vm(t));\n+const char* JfrJavaSupport::c_str(oop string, Thread* thread, bool c_heap \/* false *\/) {\n@@ -501,1 +508,1 @@\n-    str = allocate_string(c_heap, length + 1, t);\n+    str = allocate_string(c_heap, length + 1, thread);\n@@ -503,1 +510,0 @@\n-      JfrJavaSupport::throw_out_of_memory_error(\"Unable to allocate native memory\", t);\n@@ -511,3 +517,2 @@\n-const char* JfrJavaSupport::c_str(jstring string, JavaThread* t, bool c_heap \/* false *\/) {\n-  DEBUG_ONLY(check_java_thread_in_vm(t));\n-  return string != NULL ? c_str(resolve_non_null(string), t, c_heap) : NULL;\n+const char* JfrJavaSupport::c_str(jstring string, Thread* thread, bool c_heap \/* false *\/) {\n+  return string != NULL ? c_str(resolve_non_null(string), thread, c_heap) : NULL;\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJavaSupport.cpp","additions":28,"deletions":23,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+  static void get_field(JfrJavaArguments* args, Thread* thread);\n@@ -78,2 +79,2 @@\n-  static const char* c_str(jstring string, JavaThread* jt, bool c_heap = false);\n-  static const char* c_str(oop string, JavaThread* jt, bool c_heap = false);\n+  static const char* c_str(jstring string, Thread* thread, bool c_heap = false);\n+  static const char* c_str(oop string, Thread* thread, bool c_heap = false);\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJavaSupport.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1084,0 +1084,7 @@\n+  <Event name=\"FinalizerStatistics\" category=\"Java Application, Statistics\" label=\"Finalizer Statistics\" description=\"Per class statistics about finalizers\" thread=\"false\" startTime=\"false\" period=\"endChunk\">\n+    <Field type=\"Class\" name=\"finalizableClass\" label=\"Class Overriding Finalize\" \/>\n+    <Field type=\"Symbol\" name=\"codeSource\" label=\"Code Source\" description=\"URL from where class was loaded\" \/>\n+    <Field type=\"ulong\" name=\"objects\" label=\"Finalizable Objects on Heap\" description=\"Number of objects on heap that can be finalized\" \/>\n+    <Field type=\"ulong\" name=\"totalFinalizersRun\" label=\"Finalizers Run\" description=\"Total number of finalizers run since JVM start\" \/>\n+  <\/Event>\n+\n","filename":"src\/hotspot\/share\/jfr\/metadata\/metadata.xml","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,130 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#if INCLUDE_MANAGEMENT\n+#include \"classfile\/classLoaderDataGraph.hpp\"\n+#include \"classfile\/javaClasses.inline.hpp\"\n+#include \"jfr\/jfrEvents.hpp\"\n+#include \"jfr\/jni\/jfrJavaSupport.hpp\"\n+#include \"jfr\/periodic\/jfrFinalizerStatisticsEvent.hpp\"\n+#include \"jfr\/support\/jfrSymbolTable.hpp\"\n+#include \"jfr\/utilities\/jfrTime.hpp\"\n+#include \"jfr\/utilities\/jfrTypes.hpp\"\n+#include \"oops\/instanceKlass.inline.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n+#include \"runtime\/thread.inline.hpp\"\n+#include \"services\/finalizerService.hpp\"\n+\n+static oop get_codesource(oop pd, Thread* thread) {\n+  assert(pd != NULL, \"invariant\");\n+  assert(thread != NULL, \"invariant\");\n+  JavaValue result(T_OBJECT);\n+  JfrJavaArguments args(&result);\n+  args.set_klass(pd->klass());\n+  args.set_name(\"codesource\");\n+  args.set_signature(\"Ljava\/security\/CodeSource;\");\n+  args.set_receiver(pd);\n+  JfrJavaSupport::get_field(&args, thread);\n+  return result.get_oop();\n+}\n+\n+\/\/ Caller needs ResourceMark\n+static const char* get_locationNoFragString(oop codesource, Thread* thread) {\n+  assert(codesource != NULL, \"invariant\");\n+  assert(thread != NULL, \"invariant\");\n+  JavaValue result(T_OBJECT);\n+  JfrJavaArguments args(&result);\n+  args.set_klass(codesource->klass());\n+  args.set_name(\"locationNoFragString\");\n+  args.set_signature(\"Ljava\/lang\/String;\");\n+  args.set_receiver(codesource);\n+  JfrJavaSupport::get_field(&args, thread);\n+  const oop string_oop = result.get_oop();\n+  return string_oop != NULL ? JfrJavaSupport::c_str(string_oop, thread) : NULL;\n+}\n+\n+\/\/ Caller needs ResourceMark\n+static const char* codesource(const InstanceKlass* ik, Thread* thread) {\n+  assert(ik != NULL, \"invariant\");\n+  assert(thread != NULL, \"invariant\");\n+  oop pd = java_lang_Class::protection_domain(ik->java_mirror());\n+  if (pd == NULL) {\n+    return NULL;\n+  }\n+  oop codesource = get_codesource(pd, thread);\n+  return codesource != NULL ? get_locationNoFragString(codesource, thread) : NULL;\n+}\n+\n+static void send_event(const FinalizerEntry* fe, const InstanceKlass* ik, const JfrTicks& timestamp, Thread* thread) {\n+  assert(ik != NULL, \"invariant\");\n+  assert(ik->has_finalizer(), \"invariant\");\n+  assert(thread != NULL, \"invariant\");\n+  const char* const url = codesource(ik, thread);\n+  const traceid url_symbol_id = url != NULL ? JfrSymbolTable::add(url) : 0;\n+  EventFinalizerStatistics event(UNTIMED);\n+  event.set_endtime(timestamp);\n+  event.set_finalizableClass(ik);\n+  event.set_codeSource(url_symbol_id);\n+  if (fe == NULL) {\n+    event.set_objects(0);\n+    event.set_totalFinalizersRun(0);\n+  } else {\n+    assert(fe->klass() == ik, \"invariant\");\n+    event.set_objects(fe->objects_on_heap());\n+    event.set_totalFinalizersRun(fe->total_finalizers_run());\n+  }\n+  event.commit();\n+}\n+\n+void JfrFinalizerStatisticsEvent::send_unload_event(const InstanceKlass* ik) {\n+  Thread* const thread = Thread::current();\n+  ResourceMark rm(thread);\n+  send_event(FinalizerService::lookup(ik, thread), ik, JfrTicks::now(), thread);\n+}\n+\n+\/\/ Finalizer events generated by the periodic task will all have the same timestamp.\n+\n+class FinalizerStatisticsEventClosure : public FinalizerEntryClosure {\n+ private:\n+  Thread* _thread;\n+  const JfrTicks _timestamp;\n+ public:\n+  FinalizerStatisticsEventClosure(Thread* thread) : _thread(thread), _timestamp(JfrTicks::now()) {}\n+  virtual bool do_entry(const FinalizerEntry* fe) {\n+    assert(fe != NULL, \"invariant\");\n+    send_event(fe, fe->klass(), _timestamp, _thread);\n+    return true;\n+  }\n+};\n+\n+void JfrFinalizerStatisticsEvent::generate_events() {\n+  Thread* const thread = Thread::current();\n+  ResourceMark rm(thread);\n+  FinalizerStatisticsEventClosure fsec(thread);\n+  MutexLocker lock(ClassLoaderDataGraph_lock); \/\/ To prevent entries from being removed by class unloading.\n+  FinalizerService::do_entries(&fsec, thread);\n+}\n+\n+#endif \/\/ INCLUDE_MANAGEMENT\n","filename":"src\/hotspot\/share\/jfr\/periodic\/jfrFinalizerStatisticsEvent.cpp","additions":130,"deletions":0,"binary":false,"changes":130,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_JFR_PERIODIC_JFRFINALIZERSTATISTICSEVENT_HPP\n+#define SHARE_JFR_PERIODIC_JFRFINALIZERSTATISTICSEVENT_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+\n+class InstanceKlass;\n+\n+class JfrFinalizerStatisticsEvent : AllStatic {\n+ public:\n+  static void send_unload_event(const InstanceKlass* ik) NOT_MANAGEMENT_RETURN;\n+  static void generate_events() NOT_MANAGEMENT_RETURN;\n+};\n+\n+#endif \/\/ SHARE_JFR_PERIODIC_JFRFINALIZERSTATISTICSEVENT_HPP\n","filename":"src\/hotspot\/share\/jfr\/periodic\/jfrFinalizerStatisticsEvent.hpp","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -40,0 +40,1 @@\n+#include \"jfr\/periodic\/jfrFinalizerStatisticsEvent.hpp\"\n@@ -475,0 +476,1 @@\n+#if INCLUDE_MANAGEMENT\n@@ -479,0 +481,3 @@\n+#else\n+  log_debug(jfr, system)(\"Unable to generate requestable event ClassLoadingStatistics. The required jvm feature 'management' is missing.\");\n+#endif\n@@ -638,1 +643,0 @@\n-\n@@ -647,0 +651,8 @@\n+\n+TRACE_REQUEST_FUNC(FinalizerStatistics) {\n+#if INCLUDE_MANAGEMENT\n+  JfrFinalizerStatisticsEvent::generate_events();\n+#else\n+  log_debug(jfr, system)(\"Unable to generate requestable event FinalizerStatistics. The required jvm feature 'management' is missing.\");\n+#endif\n+}\n","filename":"src\/hotspot\/share\/jfr\/periodic\/jfrPeriodic.cpp","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -58,2 +58,2 @@\n-typedef const JfrSymbolId::SymbolEntry* SymbolEntryPtr;\n-typedef const JfrSymbolId::CStringEntry* CStringEntryPtr;\n+typedef const JfrSymbolTable::SymbolEntry* SymbolEntryPtr;\n+typedef const JfrSymbolTable::CStringEntry* CStringEntryPtr;\n@@ -67,12 +67,1 @@\n-static bool _clear_artifacts = false;\n-\n-\/\/ incremented on each rotation\n-static u8 checkpoint_id = 1;\n-\n-\/\/ creates a unique id by combining a checkpoint relative symbol id (2^24)\n-\/\/ with the current checkpoint id (2^40)\n-#define CREATE_SYMBOL_ID(sym_id) (((u8)((checkpoint_id << 24) | sym_id)))\n-\n-static traceid create_symbol_id(traceid artifact_id) {\n-  return artifact_id != 0 ? CREATE_SYMBOL_ID(artifact_id) : 0;\n-}\n+static bool _initial_type_set = true;\n@@ -89,1 +78,1 @@\n-  return _clear_artifacts && !_class_unload;\n+  return _initial_type_set && !_class_unload;\n@@ -97,1 +86,1 @@\n-  return klass != NULL ? create_symbol_id(_artifacts->mark(klass, leakp)) : 0;\n+  return klass != NULL ? _artifacts->mark(klass, leakp) : 0;\n@@ -101,1 +90,1 @@\n-  return symbol != NULL ? create_symbol_id(_artifacts->mark(symbol, leakp)) : 0;\n+  return symbol != NULL ? _artifacts->mark(symbol, leakp) : 0;\n@@ -105,1 +94,1 @@\n-  return create_symbol_id(_artifacts->bootstrap_name(leakp));\n+  return _artifacts->bootstrap_name(leakp);\n@@ -927,1 +916,1 @@\n-void set_serialized<JfrSymbolId::SymbolEntry>(SymbolEntryPtr ptr) {\n+void set_serialized<JfrSymbolTable::SymbolEntry>(SymbolEntryPtr ptr) {\n@@ -934,1 +923,1 @@\n-void set_serialized<JfrSymbolId::CStringEntry>(CStringEntryPtr ptr) {\n+void set_serialized<JfrSymbolTable::CStringEntry>(CStringEntryPtr ptr) {\n@@ -944,1 +933,1 @@\n-  writer->write(create_symbol_id(entry->id()));\n+  writer->write(entry->id());\n@@ -965,1 +954,1 @@\n-  writer->write(create_symbol_id(entry->id()));\n+  writer->write(entry->id());\n@@ -1043,2 +1032,2 @@\n-    _clear_artifacts = true;\n-    ++checkpoint_id;\n+    _artifacts->increment_checkpoint_id();\n+    _initial_type_set = true;\n@@ -1046,1 +1035,1 @@\n-    _clear_artifacts = false;\n+    _initial_type_set = false;\n@@ -1059,1 +1048,1 @@\n-    _artifacts->initialize(class_unload, _clear_artifacts);\n+    _artifacts->initialize(class_unload);\n@@ -1094,1 +1083,3 @@\n-  _clear_artifacts = true;\n+  if (_artifacts != NULL) {\n+    _artifacts->clear();\n+  }\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrTypeSet.cpp","additions":18,"deletions":27,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -33,219 +33,1 @@\n-static JfrSymbolId::CStringEntry* bootstrap = NULL;\n-\n-JfrSymbolId::JfrSymbolId() :\n-  _sym_table(new SymbolTable(this)),\n-  _cstring_table(new CStringTable(this)),\n-  _sym_list(NULL),\n-  _cstring_list(NULL),\n-  _sym_query(NULL),\n-  _cstring_query(NULL),\n-  _symbol_id_counter(1),\n-  _class_unload(false) {\n-  assert(_sym_table != NULL, \"invariant\");\n-  assert(_cstring_table != NULL, \"invariant\");\n-  bootstrap = new CStringEntry(0, (const char*)&BOOTSTRAP_LOADER_NAME);\n-  assert(bootstrap != NULL, \"invariant\");\n-  bootstrap->set_id(1);\n-  _cstring_list = bootstrap;\n-}\n-\n-JfrSymbolId::~JfrSymbolId() {\n-  clear();\n-  delete _sym_table;\n-  delete _cstring_table;\n-  delete bootstrap;\n-}\n-\n-void JfrSymbolId::clear() {\n-  assert(_sym_table != NULL, \"invariant\");\n-  if (_sym_table->has_entries()) {\n-    _sym_table->clear_entries();\n-  }\n-  assert(!_sym_table->has_entries(), \"invariant\");\n-\n-  assert(_cstring_table != NULL, \"invariant\");\n-  if (_cstring_table->has_entries()) {\n-    _cstring_table->clear_entries();\n-  }\n-  assert(!_cstring_table->has_entries(), \"invariant\");\n-\n-  _sym_list = NULL;\n-  _symbol_id_counter = 1;\n-\n-  _sym_query = NULL;\n-  _cstring_query = NULL;\n-\n-  assert(bootstrap != NULL, \"invariant\");\n-  bootstrap->reset();\n-  _cstring_list = bootstrap;\n-}\n-\n-void JfrSymbolId::set_class_unload(bool class_unload) {\n-  _class_unload = class_unload;\n-}\n-\n-void JfrSymbolId::on_link(const SymbolEntry* entry) {\n-  assert(entry != NULL, \"invariant\");\n-  const_cast<Symbol*>(entry->literal())->increment_refcount();\n-  assert(entry->id() == 0, \"invariant\");\n-  entry->set_id(++_symbol_id_counter);\n-  entry->set_list_next(_sym_list);\n-  _sym_list = entry;\n-}\n-\n-bool JfrSymbolId::on_equals(uintptr_t hash, const SymbolEntry* entry) {\n-  assert(entry != NULL, \"invariant\");\n-  assert(entry->hash() == hash, \"invariant\");\n-  assert(_sym_query != NULL, \"invariant\");\n-  return _sym_query == entry->literal();\n-}\n-\n-void JfrSymbolId::on_unlink(const SymbolEntry* entry) {\n-  assert(entry != NULL, \"invariant\");\n-  const_cast<Symbol*>(entry->literal())->decrement_refcount();\n-}\n-\n-static const char* resource_to_cstring(const char* resource_str) {\n-  assert(resource_str != NULL, \"invariant\");\n-  const size_t length = strlen(resource_str);\n-  char* const c_string = JfrCHeapObj::new_array<char>(length + 1);\n-  assert(c_string != NULL, \"invariant\");\n-  strncpy(c_string, resource_str, length + 1);\n-  return c_string;\n-}\n-\n-void JfrSymbolId::on_link(const CStringEntry* entry) {\n-  assert(entry != NULL, \"invariant\");\n-  assert(entry->id() == 0, \"invariant\");\n-  entry->set_id(++_symbol_id_counter);\n-  const_cast<CStringEntry*>(entry)->set_literal(resource_to_cstring(entry->literal()));\n-  entry->set_list_next(_cstring_list);\n-  _cstring_list = entry;\n-}\n-\n-static bool string_compare(const char* query, const char* candidate) {\n-  assert(query != NULL, \"invariant\");\n-  assert(candidate != NULL, \"invariant\");\n-  const size_t length = strlen(query);\n-  return strncmp(query, candidate, length) == 0;\n-}\n-\n-bool JfrSymbolId::on_equals(uintptr_t hash, const CStringEntry* entry) {\n-  assert(entry != NULL, \"invariant\");\n-  assert(entry->hash() == hash, \"invariant\");\n-  assert(_cstring_query != NULL, \"invariant\");\n-  return string_compare(_cstring_query, entry->literal());\n-}\n-\n-void JfrSymbolId::on_unlink(const CStringEntry* entry) {\n-  assert(entry != NULL, \"invariant\");\n-  JfrCHeapObj::free(const_cast<char*>(entry->literal()), strlen(entry->literal() + 1));\n-}\n-\n-traceid JfrSymbolId::bootstrap_name(bool leakp) {\n-  assert(bootstrap != NULL, \"invariant\");\n-  if (leakp) {\n-    bootstrap->set_leakp();\n-  }\n-  return 1;\n-}\n-\n-traceid JfrSymbolId::mark(const Symbol* symbol, bool leakp) {\n-  assert(symbol != NULL, \"invariant\");\n-  return mark((uintptr_t)symbol->identity_hash(), symbol, leakp);\n-}\n-\n-traceid JfrSymbolId::mark(uintptr_t hash, const Symbol* data, bool leakp) {\n-  assert(data != NULL, \"invariant\");\n-  assert(_sym_table != NULL, \"invariant\");\n-  _sym_query = data;\n-  const SymbolEntry& entry = _sym_table->lookup_put(hash, data);\n-  if (_class_unload) {\n-    entry.set_unloading();\n-  }\n-  if (leakp) {\n-    entry.set_leakp();\n-  }\n-  return entry.id();\n-}\n-\n-traceid JfrSymbolId::mark(uintptr_t hash, const char* str, bool leakp) {\n-  assert(str != NULL, \"invariant\");\n-  assert(_cstring_table != NULL, \"invariant\");\n-  _cstring_query = str;\n-  const CStringEntry& entry = _cstring_table->lookup_put(hash, str);\n-  if (_class_unload) {\n-    entry.set_unloading();\n-  }\n-  if (leakp) {\n-    entry.set_leakp();\n-  }\n-  return entry.id();\n-}\n-\n-\/*\n-* hidden classes symbol is the external name +\n-* the address of its InstanceKlass slash appended:\n-*   java.lang.invoke.LambdaForm$BMH\/22626602\n-*\n-* caller needs ResourceMark\n-*\/\n-\n-uintptr_t JfrSymbolId::hidden_klass_name_hash(const InstanceKlass* ik) {\n-  assert(ik != NULL, \"invariant\");\n-  assert(ik->is_hidden(), \"invariant\");\n-  const oop mirror = ik->java_mirror_no_keepalive();\n-  assert(mirror != NULL, \"invariant\");\n-  return (uintptr_t)mirror->identity_hash();\n-}\n-\n-static const char* create_hidden_klass_symbol(const InstanceKlass* ik, uintptr_t hash) {\n-  assert(ik != NULL, \"invariant\");\n-  assert(ik->is_hidden(), \"invariant\");\n-  assert(hash != 0, \"invariant\");\n-  char* hidden_symbol = NULL;\n-  const oop mirror = ik->java_mirror_no_keepalive();\n-  assert(mirror != NULL, \"invariant\");\n-  char hash_buf[40];\n-  sprintf(hash_buf, \"\/\" UINTX_FORMAT, hash);\n-  const size_t hash_len = strlen(hash_buf);\n-  const size_t result_len = ik->name()->utf8_length();\n-  hidden_symbol = NEW_RESOURCE_ARRAY(char, result_len + hash_len + 1);\n-  ik->name()->as_klass_external_name(hidden_symbol, (int)result_len + 1);\n-  assert(strlen(hidden_symbol) == result_len, \"invariant\");\n-  strcpy(hidden_symbol + result_len, hash_buf);\n-  assert(strlen(hidden_symbol) == result_len + hash_len, \"invariant\");\n-  return hidden_symbol;\n-}\n-\n-bool JfrSymbolId::is_hidden_klass(const Klass* k) {\n-  assert(k != NULL, \"invariant\");\n-  return k->is_instance_klass() && ((const InstanceKlass*)k)->is_hidden();\n-}\n-\n-traceid JfrSymbolId::mark_hidden_klass_name(const InstanceKlass* ik, bool leakp) {\n-  assert(ik != NULL, \"invariant\");\n-  assert(ik->is_hidden(), \"invariant\");\n-  const uintptr_t hash = hidden_klass_name_hash(ik);\n-  const char* const hidden_symbol = create_hidden_klass_symbol(ik, hash);\n-  return mark(hash, hidden_symbol, leakp);\n-}\n-\n-traceid JfrSymbolId::mark(const Klass* k, bool leakp) {\n-  assert(k != NULL, \"invariant\");\n-  traceid symbol_id = 0;\n-  if (is_hidden_klass(k)) {\n-    assert(k->is_instance_klass(), \"invariant\");\n-    symbol_id = mark_hidden_klass_name((const InstanceKlass*)k, leakp);\n-  }\n-  if (0 == symbol_id) {\n-    Symbol* const sym = k->name();\n-    if (sym != NULL) {\n-      symbol_id = mark(sym, leakp);\n-    }\n-  }\n-  assert(symbol_id > 0, \"a symbol handler must mark the symbol for writing\");\n-  return symbol_id;\n-}\n-\n-JfrArtifactSet::JfrArtifactSet(bool class_unload) : _symbol_id(new JfrSymbolId()),\n+JfrArtifactSet::JfrArtifactSet(bool class_unload) : _symbol_table(NULL),\n@@ -261,4 +43,4 @@\n-void JfrArtifactSet::initialize(bool class_unload, bool clear \/* false *\/) {\n-  assert(_symbol_id != NULL, \"invariant\");\n-  if (clear) {\n-    _symbol_id->clear();\n+void JfrArtifactSet::initialize(bool class_unload) {\n+  if (_symbol_table == NULL) {\n+    _symbol_table = JfrSymbolTable::create();\n+    assert(_symbol_table != NULL, \"invariant\");\n@@ -266,1 +48,2 @@\n-  _symbol_id->set_class_unload(class_unload);\n+  assert(_symbol_table != NULL, \"invariant\");\n+  _symbol_table->set_class_unload(class_unload);\n@@ -273,0 +56,6 @@\n+void JfrArtifactSet::clear() {\n+  if (_symbol_table != NULL) {\n+    _symbol_table->clear();\n+  }\n+}\n+\n@@ -274,2 +63,1 @@\n-  _symbol_id->clear();\n-  delete _symbol_id;\n+  delete _symbol_table;\n@@ -280,1 +68,1 @@\n-  return _symbol_id->bootstrap_name(leakp);\n+  return _symbol_table->bootstrap_name(leakp);\n@@ -285,1 +73,1 @@\n-  return _symbol_id->mark_hidden_klass_name((const InstanceKlass*)klass, leakp);\n+  return _symbol_table->mark_hidden_klass_name((const InstanceKlass*)klass, leakp);\n@@ -289,1 +77,1 @@\n-  return _symbol_id->mark(hash, sym, leakp);\n+  return _symbol_table->mark(hash, sym, leakp);\n@@ -293,1 +81,1 @@\n-  return _symbol_id->mark(klass, leakp);\n+  return _symbol_table->mark(klass, leakp);\n@@ -297,1 +85,1 @@\n-  return _symbol_id->mark(symbol, leakp);\n+  return _symbol_table->mark(symbol, leakp);\n@@ -301,1 +89,1 @@\n-  return _symbol_id->mark(hash, str, leakp);\n+  return _symbol_table->mark(hash, str, leakp);\n@@ -327,0 +115,6 @@\n+\n+void JfrArtifactSet::increment_checkpoint_id() {\n+  assert(_symbol_table != NULL, \"invariant\");\n+  _symbol_table->increment_checkpoint_id();\n+}\n+\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrTypeSetUtils.cpp","additions":26,"deletions":232,"binary":false,"changes":258,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"jfr\/support\/jfrSymbolTable.hpp\"\n@@ -30,1 +31,0 @@\n-#include \"jfr\/utilities\/jfrHashtable.hpp\"\n@@ -194,92 +194,0 @@\n-template <typename T, typename IdType>\n-class ListEntry : public JfrHashtableEntry<T, IdType> {\n- public:\n-  ListEntry(uintptr_t hash, const T& data) : JfrHashtableEntry<T, IdType>(hash, data),\n-    _list_next(NULL), _serialized(false), _unloading(false), _leakp(false) {}\n-  const ListEntry<T, IdType>* list_next() const { return _list_next; }\n-  void reset() const {\n-    _list_next = NULL; _serialized = false; _unloading = false; _leakp = false;\n-  }\n-  void set_list_next(const ListEntry<T, IdType>* next) const { _list_next = next; }\n-  bool is_serialized() const { return _serialized; }\n-  void set_serialized() const { _serialized = true; }\n-  bool is_unloading() const { return _unloading; }\n-  void set_unloading() const { _unloading = true; }\n-  bool is_leakp() const { return _leakp; }\n-  void set_leakp() const { _leakp = true; }\n- private:\n-  mutable const ListEntry<T, IdType>* _list_next;\n-  mutable bool _serialized;\n-  mutable bool _unloading;\n-  mutable bool _leakp;\n-};\n-\n-class JfrSymbolId : public JfrCHeapObj {\n-  template <typename, typename, template<typename, typename> class, typename, size_t>\n-  friend class HashTableHost;\n-  typedef HashTableHost<const Symbol*, traceid, ListEntry, JfrSymbolId> SymbolTable;\n-  typedef HashTableHost<const char*, traceid, ListEntry, JfrSymbolId> CStringTable;\n-  friend class JfrArtifactSet;\n- public:\n-  typedef SymbolTable::HashEntry SymbolEntry;\n-  typedef CStringTable::HashEntry CStringEntry;\n- private:\n-  SymbolTable* _sym_table;\n-  CStringTable* _cstring_table;\n-  const SymbolEntry* _sym_list;\n-  const CStringEntry* _cstring_list;\n-  const Symbol* _sym_query;\n-  const char* _cstring_query;\n-  traceid _symbol_id_counter;\n-  bool _class_unload;\n-\n-  \/\/ hashtable(s) callbacks\n-  void on_link(const SymbolEntry* entry);\n-  bool on_equals(uintptr_t hash, const SymbolEntry* entry);\n-  void on_unlink(const SymbolEntry* entry);\n-  void on_link(const CStringEntry* entry);\n-  bool on_equals(uintptr_t hash, const CStringEntry* entry);\n-  void on_unlink(const CStringEntry* entry);\n-\n-  template <typename Functor, typename T>\n-  void iterate(Functor& functor, const T* list) {\n-    const T* symbol = list;\n-    while (symbol != NULL) {\n-      const T* next = symbol->list_next();\n-      functor(symbol);\n-      symbol = next;\n-    }\n-  }\n-\n-  traceid mark_hidden_klass_name(const InstanceKlass* k, bool leakp);\n-  bool is_hidden_klass(const Klass* k);\n-  uintptr_t hidden_klass_name_hash(const InstanceKlass* ik);\n-\n- public:\n-  JfrSymbolId();\n-  ~JfrSymbolId();\n-\n-  void clear();\n-  void set_class_unload(bool class_unload);\n-\n-  traceid mark(uintptr_t hash, const Symbol* sym, bool leakp);\n-  traceid mark(const Klass* k, bool leakp);\n-  traceid mark(const Symbol* symbol, bool leakp);\n-  traceid mark(uintptr_t hash, const char* str, bool leakp);\n-  traceid bootstrap_name(bool leakp);\n-\n-  template <typename Functor>\n-  void iterate_symbols(Functor& functor) {\n-    iterate(functor, _sym_list);\n-  }\n-\n-  template <typename Functor>\n-  void iterate_cstrings(Functor& functor) {\n-    iterate(functor, _cstring_list);\n-  }\n-\n-  bool has_entries() const { return has_symbol_entries() || has_cstring_entries(); }\n-  bool has_symbol_entries() const { return _sym_list != NULL; }\n-  bool has_cstring_entries() const { return _cstring_list != NULL; }\n-};\n-\n@@ -302,1 +210,1 @@\n-  JfrSymbolId* _symbol_id;\n+  JfrSymbolTable* _symbol_table;\n@@ -312,1 +220,2 @@\n-  void initialize(bool class_unload, bool clear = false);\n+  void initialize(bool class_unload);\n+  void clear();\n@@ -321,3 +230,3 @@\n-  const JfrSymbolId::SymbolEntry* map_symbol(const Symbol* symbol) const;\n-  const JfrSymbolId::SymbolEntry* map_symbol(uintptr_t hash) const;\n-  const JfrSymbolId::CStringEntry* map_cstring(uintptr_t hash) const;\n+  const JfrSymbolTable::SymbolEntry* map_symbol(const Symbol* symbol) const;\n+  const JfrSymbolTable::SymbolEntry* map_symbol(uintptr_t hash) const;\n+  const JfrSymbolTable::CStringEntry* map_cstring(uintptr_t hash) const;\n@@ -330,0 +239,1 @@\n+  void increment_checkpoint_id();\n@@ -342,1 +252,1 @@\n-    _symbol_id->iterate_symbols(functor);\n+    _symbol_table->iterate_symbols(functor);\n@@ -347,1 +257,1 @@\n-    _symbol_id->iterate_cstrings(functor);\n+    _symbol_table->iterate_cstrings(functor);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrTypeSetUtils.hpp","additions":10,"deletions":100,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+#include \"jfr\/jfrEvents.hpp\"\n+#include \"jfr\/periodic\/jfrFinalizerStatisticsEvent.hpp\"\n@@ -110,0 +112,12 @@\n+#if INCLUDE_MANAGEMENT\n+static void send_finalizer_event(const Klass* k) {\n+  if (!k->is_instance_klass()) {\n+    return;\n+  }\n+  const InstanceKlass* const ik = InstanceKlass::cast(k);\n+  if (ik->has_finalizer()) {\n+    JfrFinalizerStatisticsEvent::send_unload_event(ik);\n+  }\n+}\n+#endif\n+\n@@ -113,0 +127,1 @@\n+  MANAGEMENT_ONLY(send_finalizer_event(k);)\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrKlassUnloading.cpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,316 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"classfile\/javaClasses.inline.hpp\"\n+#include \"classfile\/classLoaderData.hpp\"\n+#include \"jfr\/support\/jfrSymbolTable.hpp\"\n+#include \"oops\/instanceKlass.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n+#include \"oops\/symbol.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n+\n+\/\/ incremented on each rotation\n+static u8 checkpoint_id = 1;\n+\n+\/\/ creates a unique id by combining a checkpoint relative symbol id (2^24)\n+\/\/ with the current checkpoint id (2^40)\n+#define CREATE_SYMBOL_ID(sym_id) (((u8)((checkpoint_id << 24) | sym_id)))\n+\n+static traceid create_symbol_id(traceid artifact_id) {\n+  return artifact_id != 0 ? CREATE_SYMBOL_ID(artifact_id) : 0;\n+}\n+\n+static uintptr_t string_hash(const char* str) {\n+  return java_lang_String::hash_code(reinterpret_cast<const jbyte*>(str), static_cast<int>(strlen(str)));\n+}\n+\n+static JfrSymbolTable::CStringEntry* bootstrap = NULL;\n+\n+static JfrSymbolTable* _instance = NULL;\n+\n+static JfrSymbolTable& instance() {\n+  assert(_instance != NULL, \"invariant\");\n+  return *_instance;\n+}\n+\n+JfrSymbolTable* JfrSymbolTable::create() {\n+  assert(_instance == NULL, \"invariant\");\n+  assert_lock_strong(ClassLoaderDataGraph_lock);\n+  _instance = new JfrSymbolTable();\n+  return _instance;\n+}\n+\n+void JfrSymbolTable::destroy() {\n+  assert_lock_strong(ClassLoaderDataGraph_lock);\n+  if (_instance != NULL) {\n+    delete _instance;\n+    _instance = NULL;\n+  }\n+  assert(_instance == NULL, \"invariant\");\n+}\n+\n+JfrSymbolTable::JfrSymbolTable() :\n+  _symbol_table(new SymbolTable(this)),\n+  _cstring_table(new CStringTable(this)),\n+  _symbol_list(NULL),\n+  _cstring_list(NULL),\n+  _symbol_query(NULL),\n+  _cstring_query(NULL),\n+  _id_counter(1),\n+  _class_unload(false) {\n+  assert(_symbol_table != NULL, \"invariant\");\n+  assert(_cstring_table != NULL, \"invariant\");\n+  bootstrap = new CStringEntry(0, (const char*)&BOOTSTRAP_LOADER_NAME);\n+  assert(bootstrap != NULL, \"invariant\");\n+  bootstrap->set_id(create_symbol_id(1));\n+  _cstring_list = bootstrap;\n+}\n+\n+JfrSymbolTable::~JfrSymbolTable() {\n+  clear();\n+  delete _symbol_table;\n+  delete _cstring_table;\n+  delete bootstrap;\n+}\n+\n+void JfrSymbolTable::clear() {\n+  assert(_symbol_table != NULL, \"invariant\");\n+  if (_symbol_table->has_entries()) {\n+    _symbol_table->clear_entries();\n+  }\n+  assert(!_symbol_table->has_entries(), \"invariant\");\n+\n+  assert(_cstring_table != NULL, \"invariant\");\n+  if (_cstring_table->has_entries()) {\n+    _cstring_table->clear_entries();\n+  }\n+  assert(!_cstring_table->has_entries(), \"invariant\");\n+\n+  _symbol_list = NULL;\n+  _id_counter = 1;\n+\n+  _symbol_query = NULL;\n+  _cstring_query = NULL;\n+\n+  assert(bootstrap != NULL, \"invariant\");\n+  bootstrap->reset();\n+  _cstring_list = bootstrap;\n+}\n+\n+void JfrSymbolTable::set_class_unload(bool class_unload) {\n+  _class_unload = class_unload;\n+}\n+\n+void JfrSymbolTable::increment_checkpoint_id() {\n+  assert_lock_strong(ClassLoaderDataGraph_lock);\n+  clear();\n+  ++checkpoint_id;\n+}\n+\n+template <typename T>\n+inline void JfrSymbolTable::assign_id(T* entry) {\n+  assert(entry != NULL, \"invariant\");\n+  assert(entry->id() == 0, \"invariant\");\n+  entry->set_id(create_symbol_id(++_id_counter));\n+}\n+\n+void JfrSymbolTable::on_link(const SymbolEntry* entry) {\n+  assign_id(entry);\n+  const_cast<Symbol*>(entry->literal())->increment_refcount();\n+  entry->set_list_next(_symbol_list);\n+  _symbol_list = entry;\n+}\n+\n+bool JfrSymbolTable::on_equals(uintptr_t hash, const SymbolEntry* entry) {\n+  assert(entry != NULL, \"invariant\");\n+  assert(entry->hash() == hash, \"invariant\");\n+  assert(_symbol_query != NULL, \"invariant\");\n+  return _symbol_query == entry->literal();\n+}\n+\n+void JfrSymbolTable::on_unlink(const SymbolEntry* entry) {\n+  assert(entry != NULL, \"invariant\");\n+  const_cast<Symbol*>(entry->literal())->decrement_refcount();\n+}\n+\n+static const char* resource_to_cstring(const char* resource_str) {\n+  assert(resource_str != NULL, \"invariant\");\n+  const size_t length = strlen(resource_str);\n+  char* const c_string = JfrCHeapObj::new_array<char>(length + 1);\n+  assert(c_string != NULL, \"invariant\");\n+  strncpy(c_string, resource_str, length + 1);\n+  return c_string;\n+}\n+\n+void JfrSymbolTable::on_link(const CStringEntry* entry) {\n+  assign_id(entry);\n+  const_cast<CStringEntry*>(entry)->set_literal(resource_to_cstring(entry->literal()));\n+  entry->set_list_next(_cstring_list);\n+  _cstring_list = entry;\n+}\n+\n+static bool string_compare(const char* query, const char* candidate) {\n+  assert(query != NULL, \"invariant\");\n+  assert(candidate != NULL, \"invariant\");\n+  const size_t length = strlen(query);\n+  return strncmp(query, candidate, length) == 0;\n+}\n+\n+bool JfrSymbolTable::on_equals(uintptr_t hash, const CStringEntry* entry) {\n+  assert(entry != NULL, \"invariant\");\n+  assert(entry->hash() == hash, \"invariant\");\n+  assert(_cstring_query != NULL, \"invariant\");\n+  return string_compare(_cstring_query, entry->literal());\n+}\n+\n+void JfrSymbolTable::on_unlink(const CStringEntry* entry) {\n+  assert(entry != NULL, \"invariant\");\n+  JfrCHeapObj::free(const_cast<char*>(entry->literal()), strlen(entry->literal() + 1));\n+}\n+\n+traceid JfrSymbolTable::bootstrap_name(bool leakp) {\n+  assert(bootstrap != NULL, \"invariant\");\n+  if (leakp) {\n+    bootstrap->set_leakp();\n+  }\n+  return bootstrap->id();\n+}\n+\n+traceid JfrSymbolTable::mark(const Symbol* sym, bool leakp \/* false *\/) {\n+  assert(sym != NULL, \"invariant\");\n+  return mark((uintptr_t)sym->identity_hash(), sym, leakp);\n+}\n+\n+traceid JfrSymbolTable::mark(uintptr_t hash, const Symbol* sym, bool leakp) {\n+  assert(sym != NULL, \"invariant\");\n+  assert(_symbol_table != NULL, \"invariant\");\n+  _symbol_query = sym;\n+  const SymbolEntry& entry = _symbol_table->lookup_put(hash, sym);\n+  if (_class_unload) {\n+    entry.set_unloading();\n+  }\n+  if (leakp) {\n+    entry.set_leakp();\n+  }\n+  return entry.id();\n+}\n+\n+traceid JfrSymbolTable::mark(const char* str, bool leakp \/* false*\/) {\n+  return mark(string_hash(str), str, leakp);\n+}\n+\n+traceid JfrSymbolTable::mark(uintptr_t hash, const char* str, bool leakp) {\n+  assert(str != NULL, \"invariant\");\n+  assert(_cstring_table != NULL, \"invariant\");\n+  _cstring_query = str;\n+  const CStringEntry& entry = _cstring_table->lookup_put(hash, str);\n+  if (_class_unload) {\n+    entry.set_unloading();\n+  }\n+  if (leakp) {\n+    entry.set_leakp();\n+  }\n+  return entry.id();\n+}\n+\n+\/*\n+* hidden classes symbol is the external name +\n+* the address of its InstanceKlass slash appended:\n+*   java.lang.invoke.LambdaForm$BMH\/22626602\n+*\n+* caller needs ResourceMark\n+*\/\n+\n+uintptr_t JfrSymbolTable::hidden_klass_name_hash(const InstanceKlass* ik) {\n+  assert(ik != NULL, \"invariant\");\n+  assert(ik->is_hidden(), \"invariant\");\n+  const oop mirror = ik->java_mirror_no_keepalive();\n+  assert(mirror != NULL, \"invariant\");\n+  return (uintptr_t)mirror->identity_hash();\n+}\n+\n+static const char* create_hidden_klass_symbol(const InstanceKlass* ik, uintptr_t hash) {\n+  assert(ik != NULL, \"invariant\");\n+  assert(ik->is_hidden(), \"invariant\");\n+  assert(hash != 0, \"invariant\");\n+  char* hidden_symbol = NULL;\n+  const oop mirror = ik->java_mirror_no_keepalive();\n+  assert(mirror != NULL, \"invariant\");\n+  char hash_buf[40];\n+  sprintf(hash_buf, \"\/\" UINTX_FORMAT, hash);\n+  const size_t hash_len = strlen(hash_buf);\n+  const size_t result_len = ik->name()->utf8_length();\n+  hidden_symbol = NEW_RESOURCE_ARRAY(char, result_len + hash_len + 1);\n+  ik->name()->as_klass_external_name(hidden_symbol, (int)result_len + 1);\n+  assert(strlen(hidden_symbol) == result_len, \"invariant\");\n+  strcpy(hidden_symbol + result_len, hash_buf);\n+  assert(strlen(hidden_symbol) == result_len + hash_len, \"invariant\");\n+  return hidden_symbol;\n+}\n+\n+bool JfrSymbolTable::is_hidden_klass(const Klass* k) {\n+  assert(k != NULL, \"invariant\");\n+  return k->is_instance_klass() && ((const InstanceKlass*)k)->is_hidden();\n+}\n+\n+traceid JfrSymbolTable::mark_hidden_klass_name(const InstanceKlass* ik, bool leakp) {\n+  assert(ik != NULL, \"invariant\");\n+  assert(ik->is_hidden(), \"invariant\");\n+  const uintptr_t hash = hidden_klass_name_hash(ik);\n+  const char* const hidden_symbol = create_hidden_klass_symbol(ik, hash);\n+  return mark(hash, hidden_symbol, leakp);\n+}\n+\n+traceid JfrSymbolTable::mark(const Klass* k, bool leakp) {\n+  assert(k != NULL, \"invariant\");\n+  traceid symbol_id = 0;\n+  if (is_hidden_klass(k)) {\n+    assert(k->is_instance_klass(), \"invariant\");\n+    symbol_id = mark_hidden_klass_name((const InstanceKlass*)k, leakp);\n+  } else {\n+    Symbol* const sym = k->name();\n+    if (sym != NULL) {\n+      symbol_id = mark(sym, leakp);\n+    }\n+  }\n+  assert(symbol_id > 0, \"a symbol handler must mark the symbol for writing\");\n+  return symbol_id;\n+}\n+\n+template <typename T>\n+traceid JfrSymbolTable::add_impl(const T* sym) {\n+  assert(sym != NULL, \"invariant\");\n+  assert(_instance != NULL, \"invariant\");\n+  assert_locked_or_safepoint(ClassLoaderDataGraph_lock);\n+  return instance().mark(sym);\n+}\n+\n+traceid JfrSymbolTable::add(const Symbol* sym) {\n+  return add_impl(sym);\n+}\n+\n+traceid JfrSymbolTable::add(const char* str) {\n+  return add_impl(str);\n+}\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrSymbolTable.cpp","additions":316,"deletions":0,"binary":false,"changes":316,"status":"added"},{"patch":"@@ -0,0 +1,148 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_JFR_SUPPORT_JFRSYMBOLTABLE_HPP\n+#define SHARE_JFR_SUPPORT_JFRSYMBOLTABLE_HPP\n+\n+#include \"jfr\/utilities\/jfrHashtable.hpp\"\n+#include \"jfr\/utilities\/jfrTypes.hpp\"\n+\n+template <typename T, typename IdType>\n+class ListEntry : public JfrHashtableEntry<T, IdType> {\n+ public:\n+  ListEntry(uintptr_t hash, const T& data) : JfrHashtableEntry<T, IdType>(hash, data),\n+    _list_next(NULL), _serialized(false), _unloading(false), _leakp(false) {}\n+  const ListEntry<T, IdType>* list_next() const { return _list_next; }\n+  void reset() const {\n+    _list_next = NULL; _serialized = false; _unloading = false; _leakp = false;\n+  }\n+  void set_list_next(const ListEntry<T, IdType>* next) const { _list_next = next; }\n+  bool is_serialized() const { return _serialized; }\n+  void set_serialized() const { _serialized = true; }\n+  bool is_unloading() const { return _unloading; }\n+  void set_unloading() const { _unloading = true; }\n+  bool is_leakp() const { return _leakp; }\n+  void set_leakp() const { _leakp = true; }\n+ private:\n+  mutable const ListEntry<T, IdType>* _list_next;\n+  mutable bool _serialized;\n+  mutable bool _unloading;\n+  mutable bool _leakp;\n+};\n+\n+\/*\n+ * This table maps an oop\/Symbol* or a char* to the Jfr type 'Symbol'.\n+ *\n+ * It provides an interface over the corresponding constant pool (TYPE_SYMBOL),\n+ * which is represented in the binary format as a sequence of checkpoint events.\n+ * The returned id can be used as a foreign key, but please note that the id is\n+ * epoch-relative, and is therefore only valid in the current epoch \/ chunk.\n+ * The table is cleared as part of rotation.\n+ *\n+ * Caller must ensure mutual exclusion by means of the ClassLoaderDataGraph_lock or by safepointing.\n+ *\/\n+class JfrSymbolTable : public JfrCHeapObj {\n+  template <typename, typename, template<typename, typename> class, typename, size_t>\n+  friend class HashTableHost;\n+  typedef HashTableHost<const Symbol*, traceid, ListEntry, JfrSymbolTable> SymbolTable;\n+  typedef HashTableHost<const char*, traceid, ListEntry, JfrSymbolTable> CStringTable;\n+  friend class JfrArtifactSet;\n+\n+ public:\n+  typedef SymbolTable::HashEntry SymbolEntry;\n+  typedef CStringTable::HashEntry CStringEntry;\n+\n+  static traceid add(const Symbol* sym);\n+  static traceid add(const char* str);\n+\n+ private:\n+  SymbolTable* _symbol_table;\n+  CStringTable* _cstring_table;\n+  const SymbolEntry* _symbol_list;\n+  const CStringEntry* _cstring_list;\n+  const Symbol* _symbol_query;\n+  const char* _cstring_query;\n+  traceid _id_counter;\n+  bool _class_unload;\n+\n+  JfrSymbolTable();\n+  ~JfrSymbolTable();\n+  static JfrSymbolTable* create();\n+  static void destroy();\n+\n+  void clear();\n+  void increment_checkpoint_id();\n+  void set_class_unload(bool class_unload);\n+\n+  traceid mark(uintptr_t hash, const Symbol* sym, bool leakp);\n+  traceid mark(const Klass* k, bool leakp);\n+  traceid mark(const Symbol* sym, bool leakp = false);\n+  traceid mark(const char* str, bool leakp = false);\n+  traceid mark(uintptr_t hash, const char* str, bool leakp);\n+  traceid bootstrap_name(bool leakp);\n+\n+  bool has_entries() const { return has_symbol_entries() || has_cstring_entries(); }\n+  bool has_symbol_entries() const { return _symbol_list != NULL; }\n+  bool has_cstring_entries() const { return _cstring_list != NULL; }\n+\n+  traceid mark_hidden_klass_name(const InstanceKlass* k, bool leakp);\n+  bool is_hidden_klass(const Klass* k);\n+  uintptr_t hidden_klass_name_hash(const InstanceKlass* ik);\n+\n+  \/\/ hashtable(s) callbacks\n+  void on_link(const SymbolEntry* entry);\n+  bool on_equals(uintptr_t hash, const SymbolEntry* entry);\n+  void on_unlink(const SymbolEntry* entry);\n+  void on_link(const CStringEntry* entry);\n+  bool on_equals(uintptr_t hash, const CStringEntry* entry);\n+  void on_unlink(const CStringEntry* entry);\n+\n+  template <typename T>\n+  static traceid add_impl(const T* sym);\n+\n+  template <typename T>\n+  void assign_id(T* entry);\n+\n+  template <typename Functor>\n+  void iterate_symbols(Functor& functor) {\n+    iterate(functor, _symbol_list);\n+  }\n+\n+  template <typename Functor>\n+  void iterate_cstrings(Functor& functor) {\n+    iterate(functor, _cstring_list);\n+  }\n+\n+  template <typename Functor, typename T>\n+  void iterate(Functor& functor, const T* list) {\n+    const T* symbol = list;\n+    while (symbol != NULL) {\n+      const T* next = symbol->list_next();\n+      functor(symbol);\n+      symbol = next;\n+    }\n+  }\n+};\n+\n+#endif \/\/ SHARE_JFR_SUPPORT_JFRSYMBOLTABLE_HPP\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrSymbolTable.hpp","additions":148,"deletions":0,"binary":false,"changes":148,"status":"added"},{"patch":"@@ -74,0 +74,1 @@\n+  LOG_TAG(finalizer) \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -86,0 +86,1 @@\n+#include \"services\/finalizerService.hpp\"\n@@ -99,1 +100,0 @@\n-\n@@ -1408,1 +1408,1 @@\n-  methodHandle mh (THREAD, Universe::finalizer_register_method());\n+  methodHandle mh(THREAD, Universe::finalizer_register_method());\n@@ -1410,0 +1410,1 @@\n+  MANAGEMENT_ONLY(FinalizerService::on_register(h_i(), THREAD);)\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -323,1 +323,1 @@\n-  def(JfrMsg_lock                  , PaddedMonitor, leaf,        true,  _safepoint_check_always);\n+  def(JfrMsg_lock                  , PaddedMonitor, leaf-1,      true,  _safepoint_check_always); \/\/ -1 because the ConcurrentHashTable resize lock is leaf\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -69,0 +69,1 @@\n+#include \"services\/finalizerService.hpp\"\n@@ -594,0 +595,7 @@\n+    if (_subtasks.try_claim_task(SafepointSynchronize::SAFEPOINT_CLEANUP_REQUEST_FINALIZERSERVICE_TABLE_REHASH)) {\n+      if (FinalizerService::needs_rehashing()) {\n+        Tracer t(\"rehashing finalizerservice table\");\n+        FinalizerService::rehash();\n+      }\n+    }\n+\n","filename":"src\/hotspot\/share\/runtime\/safepoint.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -80,0 +80,1 @@\n+    SAFEPOINT_CLEANUP_REQUEST_FINALIZERSERVICE_TABLE_REHASH,\n","filename":"src\/hotspot\/share\/runtime\/safepoint.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+#include \"services\/finalizerService.hpp\"\n@@ -118,0 +119,1 @@\n+    bool finalizerservice_work = false;\n@@ -148,0 +150,1 @@\n+              (finalizerservice_work = FinalizerService::has_work()) |\n@@ -175,0 +178,4 @@\n+    if (finalizerservice_work) {\n+      FinalizerService::do_concurrent_work(jt);\n+    }\n+\n","filename":"src\/hotspot\/share\/runtime\/serviceThread.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -79,0 +79,22 @@\n+size_t ClassLoadingService::compute_class_size(InstanceKlass* k) {\n+  \/\/ lifted from ClassStatistics.do_class(Klass* k)\n+\n+  size_t class_size = 0;\n+\n+  class_size += k->size();\n+\n+  if (k->is_instance_klass()) {\n+    class_size += k->methods()->size();\n+    \/\/ FIXME: Need to count the contents of methods\n+    class_size += k->constants()->size();\n+    class_size += k->local_interfaces()->size();\n+    if (k->transitive_interfaces() != NULL) {\n+      class_size += k->transitive_interfaces()->size();\n+    }\n+    \/\/ We do not have to count implementors, since we only store one!\n+    \/\/ FIXME: How should these be accounted for, now when they have moved.\n+    \/\/class_size += k->fields()->size();\n+  }\n+  return class_size * oopSize;\n+}\n+\n@@ -122,4 +144,8 @@\n-void ClassLoadingService::notify_class_unloaded(InstanceKlass* k) {\n-  DTRACE_CLASSLOAD_PROBE(unloaded, k, false);\n-  \/\/ Classes that can be unloaded must be non-shared\n-  _classes_unloaded_count->inc();\n+bool ClassLoadingService::set_verbose(bool verbose) {\n+  MutexLocker m(Management_lock);\n+  \/\/ verbose will be set to the previous value\n+  LogLevelType level = verbose ? LogLevel::Info : LogLevel::Off;\n+  LogConfiguration::configure_stdout(level, false, LOG_TAGS(class, load));\n+  reset_trace_class_unloading();\n+  return verbose;\n+}\n@@ -127,4 +153,7 @@\n-  if (UsePerfData) {\n-    \/\/ add the class size\n-    size_t size = compute_class_size(k);\n-    _classbytes_unloaded->inc(size);\n+\/\/ Caller to this function must own Management_lock\n+void ClassLoadingService::reset_trace_class_unloading() {\n+  assert(Management_lock->owned_by_self(), \"Must own the Management_lock\");\n+  bool value = MemoryService::get_verbose() || ClassLoadingService::get_verbose();\n+  LogLevelType level = value ? LogLevel::Info : LogLevel::Off;\n+  LogConfiguration::configure_stdout(level, false, LOG_TAGS(class, unload));\n+}\n@@ -132,8 +161,34 @@\n-    \/\/ Compute method size & subtract from running total.\n-    \/\/ We are called during phase 1 of mark sweep, so it's\n-    \/\/ still ok to iterate through Method*s here.\n-    Array<Method*>* methods = k->methods();\n-    for (int i = 0; i < methods->length(); i++) {\n-      _class_methods_size->inc(-methods->at(i)->size());\n-    }\n-  }\n+jlong ClassLoadingService::loaded_class_count() {\n+  return _classes_loaded_count->get_value() + _shared_classes_loaded_count->get_value();\n+}\n+\n+jlong ClassLoadingService::unloaded_class_count() {\n+  return _classes_unloaded_count->get_value() + _shared_classes_unloaded_count->get_value();\n+}\n+\n+jlong ClassLoadingService::loaded_class_bytes() {\n+  return UsePerfData ? _classbytes_loaded->get_value() + _shared_classbytes_loaded->get_value() : -1;\n+}\n+\n+jlong ClassLoadingService::unloaded_class_bytes() {\n+  return UsePerfData ? _classbytes_unloaded->get_value() + _shared_classbytes_unloaded->get_value() : -1;\n+}\n+\n+jlong ClassLoadingService::loaded_shared_class_count() {\n+  return _shared_classes_loaded_count->get_value();\n+}\n+\n+jlong ClassLoadingService::unloaded_shared_class_count() {\n+  return _shared_classes_unloaded_count->get_value();\n+}\n+\n+jlong ClassLoadingService::loaded_shared_class_bytes() {\n+  return UsePerfData ? _shared_classbytes_loaded->get_value() : -1;\n+}\n+\n+jlong ClassLoadingService::unloaded_shared_class_bytes() {\n+  return UsePerfData ? _shared_classbytes_unloaded->get_value() : -1;\n+}\n+\n+jlong ClassLoadingService::class_method_data_size() {\n+  return UsePerfData ? _class_methods_size->get_value() : -1;\n@@ -158,4 +213,4 @@\n-size_t ClassLoadingService::compute_class_size(InstanceKlass* k) {\n-  \/\/ lifted from ClassStatistics.do_class(Klass* k)\n-\n-  size_t class_size = 0;\n+void ClassLoadingService::notify_class_unloaded(InstanceKlass* k) {\n+  DTRACE_CLASSLOAD_PROBE(unloaded, k, false);\n+  \/\/ Classes that can be unloaded must be non-shared\n+  _classes_unloaded_count->inc();\n@@ -163,1 +218,4 @@\n-  class_size += k->size();\n+  if (UsePerfData) {\n+    \/\/ add the class size\n+    size_t size = compute_class_size(k);\n+    _classbytes_unloaded->inc(size);\n@@ -165,7 +223,6 @@\n-  if (k->is_instance_klass()) {\n-    class_size += k->methods()->size();\n-    \/\/ FIXME: Need to count the contents of methods\n-    class_size += k->constants()->size();\n-    class_size += k->local_interfaces()->size();\n-    if (k->transitive_interfaces() != NULL) {\n-      class_size += k->transitive_interfaces()->size();\n+    \/\/ Compute method size & subtract from running total.\n+    \/\/ We are called during phase 1 of mark sweep, so it's\n+    \/\/ still ok to iterate through Method*s here.\n+    Array<Method*>* methods = k->methods();\n+    for (int i = 0; i < methods->length(); i++) {\n+      _class_methods_size->inc(-methods->at(i)->size());\n@@ -173,3 +230,0 @@\n-    \/\/ We do not have to count implementors, since we only store one!\n-    \/\/ FIXME: How should these be accounted for, now when they have moved.\n-    \/\/class_size += k->fields()->size();\n@@ -177,18 +231,0 @@\n-  return class_size * oopSize;\n-}\n-\n-bool ClassLoadingService::set_verbose(bool verbose) {\n-  MutexLocker m(Management_lock);\n-  \/\/ verbose will be set to the previous value\n-  LogLevelType level = verbose ? LogLevel::Info : LogLevel::Off;\n-  LogConfiguration::configure_stdout(level, false, LOG_TAGS(class, load));\n-  reset_trace_class_unloading();\n-  return verbose;\n-}\n-\n-\/\/ Caller to this function must own Management_lock\n-void ClassLoadingService::reset_trace_class_unloading() {\n-  assert(Management_lock->owned_by_self(), \"Must own the Management_lock\");\n-  bool value = MemoryService::get_verbose() || ClassLoadingService::get_verbose();\n-  LogLevelType level = value ? LogLevel::Info : LogLevel::Off;\n-  LogConfiguration::configure_stdout(level, false, LOG_TAGS(class, unload));\n","filename":"src\/hotspot\/share\/services\/classLoadingService.cpp","additions":85,"deletions":49,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -56,4 +56,2 @@\n-  static void init();\n-\n-  static bool get_verbose() { return log_is_enabled(Info, class, load); }\n-  static bool set_verbose(bool verbose);\n+  static void init() NOT_MANAGEMENT_RETURN;\n+  static bool set_verbose(bool verbose) NOT_MANAGEMENT_RETURN_(false);\n@@ -61,45 +59,10 @@\n-\n-  static jlong loaded_class_count() {\n-    return _classes_loaded_count->get_value() + _shared_classes_loaded_count->get_value();\n-  }\n-  static jlong unloaded_class_count() {\n-    return _classes_unloaded_count->get_value() + _shared_classes_unloaded_count->get_value();\n-  }\n-  static jlong loaded_class_bytes() {\n-    if (UsePerfData) {\n-      return _classbytes_loaded->get_value() + _shared_classbytes_loaded->get_value();\n-    } else {\n-      return -1;\n-    }\n-  }\n-  static jlong unloaded_class_bytes() {\n-    if (UsePerfData) {\n-      return _classbytes_unloaded->get_value() + _shared_classbytes_unloaded->get_value();\n-    } else {\n-      return -1;\n-    }\n-  }\n-\n-  static jlong loaded_shared_class_count() {\n-    return _shared_classes_loaded_count->get_value();\n-  }\n-  static jlong unloaded_shared_class_count() {\n-    return _shared_classes_unloaded_count->get_value();\n-  }\n-  static jlong loaded_shared_class_bytes() {\n-    if (UsePerfData) {\n-      return _shared_classbytes_loaded->get_value();\n-    } else {\n-      return -1;\n-    }\n-  }\n-  static jlong unloaded_shared_class_bytes() {\n-    if (UsePerfData) {\n-      return _shared_classbytes_unloaded->get_value();\n-    } else {\n-      return -1;\n-    }\n-  }\n-  static jlong class_method_data_size() {\n-    return (UsePerfData ? _class_methods_size->get_value() : -1);\n-  }\n+  static jlong loaded_class_count() NOT_MANAGEMENT_RETURN_(0L);\n+  static jlong unloaded_class_count() NOT_MANAGEMENT_RETURN_(0L);\n+  static jlong loaded_class_bytes() NOT_MANAGEMENT_RETURN_(0L);\n+  static jlong unloaded_class_bytes() NOT_MANAGEMENT_RETURN_(0L);\n+  static jlong loaded_shared_class_count() NOT_MANAGEMENT_RETURN_(0L);\n+  static jlong unloaded_shared_class_count() NOT_MANAGEMENT_RETURN_(0L);\n+  static jlong loaded_shared_class_bytes() NOT_MANAGEMENT_RETURN_(0L);\n+  static jlong unloaded_shared_class_bytes() NOT_MANAGEMENT_RETURN_(0L);\n+  static jlong class_method_data_size() NOT_MANAGEMENT_RETURN_(0L);\n+  static bool get_verbose() { return log_is_enabled(Info, class, load); }\n","filename":"src\/hotspot\/share\/services\/classLoadingService.hpp","additions":12,"deletions":49,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -0,0 +1,488 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#if INCLUDE_MANAGEMENT\n+#include \"classfile\/classLoaderDataGraph.inline.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/handles.hpp\"\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n+#include \"runtime\/javaCalls.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n+#include \"runtime\/synchronizer.hpp\"\n+#include \"runtime\/thread.inline.hpp\"\n+#include \"runtime\/vm_version.hpp\"\n+#include \"services\/finalizerService.hpp\"\n+#include \"utilities\/concurrentHashTableTasks.inline.hpp\"\n+#include \"utilities\/debug.hpp\"\n+\n+FinalizerEntry::FinalizerEntry(const InstanceKlass* ik) :\n+    _ik(ik),\n+    _objects_on_heap(0),\n+    _total_finalizers_run(0) {}\n+\n+const InstanceKlass* FinalizerEntry::klass() const {\n+  return _ik;\n+}\n+\n+uint64_t FinalizerEntry::objects_on_heap() const {\n+  return Atomic::load(&_objects_on_heap);\n+}\n+\n+uint64_t FinalizerEntry::total_finalizers_run() const {\n+  return Atomic::load(&_total_finalizers_run);\n+}\n+\n+template <uint64_t op(uint64_t)>\n+static inline void set_atomic(volatile uint64_t* volatile dest) {\n+  assert(VM_Version::supports_cx8(), \"invariant\");\n+  uint64_t compare;\n+  uint64_t exchange;\n+  do {\n+    compare = *dest;\n+    exchange = op(compare);\n+  } while (Atomic::cmpxchg(dest, compare, exchange) != compare);\n+}\n+\n+static inline uint64_t inc(uint64_t value) {\n+  return value + 1;\n+}\n+\n+void FinalizerEntry::on_register() {\n+  set_atomic<inc>(&_objects_on_heap);\n+}\n+\n+static inline uint64_t dec(uint64_t value) {\n+  assert(value > 0, \"invariant\");\n+  return value - 1;\n+}\n+\n+void FinalizerEntry::on_complete() {\n+  set_atomic<inc>(&_total_finalizers_run);\n+  set_atomic<dec>(&_objects_on_heap);\n+}\n+\n+static constexpr const size_t DEFAULT_TABLE_SIZE = 2048;\n+\/\/ 2^24 is max size, like StringTable.\n+static constexpr const size_t MAX_SIZE = 24;\n+\/\/ If a chain gets to 50, something might be wrong\n+static constexpr const size_t REHASH_LEN = 50;\n+static constexpr const double PREF_AVG_LIST_LEN = 8.0;\n+\n+static size_t _table_size = 0;\n+static volatile uint64_t _entries = 0;\n+static volatile uint64_t _count = 0;\n+static volatile bool _has_work = 0;\n+static volatile bool _needs_rehashing = false;\n+static volatile bool _has_items_to_clean = false;\n+\n+static inline void reset_has_items_to_clean() {\n+  Atomic::store(&_has_items_to_clean, false);\n+}\n+\n+static inline void set_has_items_to_clean() {\n+  Atomic::store(&_has_items_to_clean, true);\n+}\n+\n+static inline bool has_items_to_clean() {\n+  return Atomic::load(&_has_items_to_clean);\n+}\n+\n+static inline void added() {\n+  set_atomic<inc>(&_count);\n+}\n+\n+static inline void removed() {\n+  set_atomic<dec>(&_count);\n+}\n+\n+static inline uintx hash_function(const InstanceKlass* ik) {\n+  assert(ik != nullptr, \"invariant\");\n+  return primitive_hash(ik);\n+}\n+\n+static inline uintx hash_function(const FinalizerEntry* fe) {\n+  return hash_function(fe->klass());\n+}\n+\n+class FinalizerEntryLookup : StackObj {\n+ private:\n+  const InstanceKlass* const _ik;\n+ public:\n+  FinalizerEntryLookup(const InstanceKlass* ik) : _ik(ik) {}\n+  uintx get_hash() const { return hash_function(_ik); }\n+  bool equals(FinalizerEntry** value, bool* is_dead) {\n+    assert(value != nullptr, \"invariant\");\n+    assert(*value != nullptr, \"invariant\");\n+    return (*value)->klass() == _ik;\n+  }\n+};\n+\n+class FinalizerTableConfig : public AllStatic {\n+ public:\n+  typedef FinalizerEntry* Value;  \/\/ value of the Node in the hashtable\n+\n+  static uintx get_hash(Value const& value, bool* is_dead) {\n+    return hash_function(value);\n+  }\n+  \/\/ We use default allocation\/deallocation but counted\n+  static void* allocate_node(void* context, size_t size, Value const& value) {\n+    added();\n+    return AllocateHeap(size, mtClass);\n+  }\n+  static void free_node(void* context, void* memory, Value const& value) {\n+    \/\/ We get here because some threads lost a race to insert a newly created FinalizerEntry\n+    FreeHeap(memory);\n+    removed();\n+  }\n+};\n+\n+typedef ConcurrentHashTable<FinalizerTableConfig, mtStatistics> FinalizerHashtable;\n+static FinalizerHashtable* _table = nullptr;\n+\n+static size_t ceil_log2(size_t value) {\n+  size_t ret;\n+  for (ret = 1; ((size_t)1 << ret) < value; ++ret);\n+  return ret;\n+}\n+\n+static double table_load_factor() {\n+  return (double)_count \/ _table_size;\n+}\n+\n+static inline size_t table_size() {\n+  return ((size_t)1) << _table->get_size_log2(Thread::current());\n+}\n+\n+static inline bool table_needs_rehashing() {\n+  return _needs_rehashing;\n+}\n+\n+static inline void update_table_needs_rehash(bool rehash) {\n+  if (rehash) {\n+    _needs_rehashing = true;\n+  }\n+}\n+\n+class FinalizerEntryLookupResult {\n+ private:\n+  FinalizerEntry* _result;\n+ public:\n+  FinalizerEntryLookupResult() : _result(nullptr) {}\n+  void operator()(FinalizerEntry* node) {\n+    assert(node != nullptr, \"invariant\");\n+    _result = node;\n+  }\n+  FinalizerEntry* result() const { return _result; }\n+};\n+\n+class FinalizerEntryLookupGet {\n+ private:\n+  FinalizerEntry* _result;\n+ public:\n+  FinalizerEntryLookupGet() : _result(nullptr) {}\n+  void operator()(FinalizerEntry** node) {\n+    assert(node != nullptr, \"invariant\");\n+    _result = *node;\n+  }\n+  FinalizerEntry* result() const { return _result; }\n+};\n+\n+static void trigger_table_cleanup() {\n+  MutexLocker ml(Service_lock, Mutex::_no_safepoint_check_flag);\n+  _has_work = true;\n+  Service_lock->notify_all();\n+}\n+\n+static void check_table_concurrent_work() {\n+  if (_has_work) {\n+    return;\n+  }\n+  \/\/ We should clean\/resize if we have\n+  \/\/ more items than preferred load factor or\n+  \/\/ more dead items than water mark.\n+  if (has_items_to_clean() || (table_load_factor() > PREF_AVG_LIST_LEN)) {\n+    trigger_table_cleanup();\n+  }\n+}\n+\n+static FinalizerEntry* add_to_table_if_needed(const InstanceKlass* ik, Thread* thread) {\n+  FinalizerEntryLookup lookup(ik);\n+  bool clean_hint = false;\n+  bool rehash_warning = false;\n+  FinalizerEntry* entry = nullptr;\n+  do {\n+    \/\/ We have looked up the entry once, proceed with insertion.\n+    entry = new FinalizerEntry(ik);\n+    if (_table->insert(thread, lookup, entry, &rehash_warning, &clean_hint)) {\n+      break;\n+    }\n+    \/\/ In case another thread did a concurrent add, return value already in the table.\n+    \/\/ This could fail if the entry got deleted concurrently, so loop back until success.\n+    FinalizerEntryLookupGet felg;\n+    if (_table->get(thread, lookup, felg, &rehash_warning)) {\n+      entry = felg.result();\n+      break;\n+    }\n+  } while (true);\n+  update_table_needs_rehash(rehash_warning);\n+  if (clean_hint) {\n+    set_has_items_to_clean();\n+    check_table_concurrent_work();\n+  }\n+  assert(entry != nullptr, \"invariant\");\n+  return entry;\n+}\n+\n+\/\/ Concurrent work\n+static void grow_table(JavaThread* jt) {\n+  FinalizerHashtable::GrowTask gt(_table);\n+  if (!gt.prepare(jt)) {\n+    return;\n+  }\n+  while (gt.do_task(jt)) {\n+    gt.pause(jt);\n+    {\n+      ThreadBlockInVM tbivm(jt);\n+    }\n+    gt.cont(jt);\n+  }\n+  gt.done(jt);\n+  _table_size = table_size();\n+}\n+\n+struct FinalizerEntryDelete : StackObj {\n+  size_t _deleted;\n+  FinalizerEntryDelete() : _deleted(0) {}\n+  void operator()(FinalizerEntry** value) {\n+    assert(value != nullptr, \"invariant\");\n+    assert(*value != nullptr, \"invariant\");\n+    _deleted++;\n+  }\n+};\n+\n+struct FinalizerEntryDeleteCheck : StackObj {\n+  size_t _processed;\n+  FinalizerEntryDeleteCheck() : _processed(0) {}\n+  bool operator()(FinalizerEntry** value) {\n+    assert(value != nullptr, \"invariant\");\n+    assert(*value != nullptr, \"invariant\");\n+    _processed++;\n+    return true;\n+  }\n+};\n+\n+static void clean_table_entries(JavaThread* jt) {\n+  FinalizerHashtable::BulkDeleteTask bdt(_table);\n+  if (!bdt.prepare(jt)) {\n+    return;\n+  }\n+  FinalizerEntryDeleteCheck fedc;\n+  FinalizerEntryDelete fed;\n+  while (bdt.do_task(jt, fedc, fed)) {\n+    bdt.pause(jt);\n+    {\n+      ThreadBlockInVM tbivm(jt);\n+    }\n+    bdt.cont(jt);\n+  }\n+  reset_has_items_to_clean();\n+  bdt.done(jt);\n+}\n+\n+static void do_table_concurrent_work(JavaThread* jt) {\n+  \/\/ We prefer growing, since that also removes dead items\n+  if (table_load_factor() > PREF_AVG_LIST_LEN && !_table->is_max_size_reached()) {\n+    grow_table(jt);\n+  } else {\n+    clean_table_entries(jt);\n+  }\n+  _has_work = false;\n+}\n+\n+\/\/ Rehash\n+static bool do_table_rehash() {\n+  if (!_table->is_safepoint_safe()) {\n+    return false;\n+  }\n+  Thread* const thread = Thread::current();\n+  \/\/ We use current size\n+  const size_t new_size = _table->get_size_log2(thread);\n+  FinalizerHashtable* const new_table = new FinalizerHashtable(new_size, MAX_SIZE, REHASH_LEN);\n+  if (!_table->try_move_nodes_to(thread, new_table)) {\n+    delete new_table;\n+    return false;\n+  }\n+  \/\/ free old table\n+  delete _table;\n+  _table = new_table;\n+  return true;\n+}\n+\n+bool FinalizerService::needs_rehashing() {\n+  return _needs_rehashing;\n+}\n+\n+void FinalizerService::rehash() {\n+  static bool rehashed = false;\n+  log_debug(finalizer)(\"Table imbalanced, rehashing called.\");\n+  \/\/ Grow instead of rehash.\n+  if (table_load_factor() > PREF_AVG_LIST_LEN && !_table->is_max_size_reached()) {\n+    log_debug(finalizer)(\"Choosing growing over rehashing.\");\n+    trigger_table_cleanup();\n+    _needs_rehashing = false;\n+    return;\n+  }\n+  \/\/ Already rehashed.\n+  if (rehashed) {\n+    log_warning(finalizer)(\"Rehashing already done, still long lists.\");\n+    trigger_table_cleanup();\n+    _needs_rehashing = false;\n+    return;\n+  }\n+  if (do_table_rehash()) {\n+    rehashed = true;\n+  } else {\n+    log_debug(finalizer)(\"Resizes in progress rehashing skipped.\");\n+  }\n+  _needs_rehashing = false;\n+}\n+\n+bool FinalizerService::has_work() {\n+  return _has_work;\n+}\n+\n+void FinalizerService::do_concurrent_work(JavaThread* service_thread) {\n+  assert(service_thread != nullptr, \"invariant\");\n+  if (_has_work) {\n+    do_table_concurrent_work(service_thread);\n+  }\n+}\n+\n+void FinalizerService::init() {\n+  assert(_table == nullptr, \"invariant\");\n+  const size_t start_size_log_2 = ceil_log2(DEFAULT_TABLE_SIZE);\n+  _table_size = ((size_t)1) << start_size_log_2;\n+  _table = new FinalizerHashtable(start_size_log_2, MAX_SIZE, REHASH_LEN);\n+}\n+\n+static FinalizerEntry* lookup_entry(const InstanceKlass* ik, Thread* thread) {\n+  FinalizerEntryLookup lookup(ik);\n+  FinalizerEntryLookupGet felg;\n+  bool rehash_warning;\n+  _table->get(thread, lookup, felg, &rehash_warning);\n+  return felg.result();\n+}\n+\n+const FinalizerEntry* FinalizerService::lookup(const InstanceKlass* ik, Thread* thread) {\n+  assert(ik != nullptr, \"invariant\");\n+  assert(thread != nullptr, \"invariant\");\n+  assert(ik->has_finalizer(), \"invariant\");\n+  return lookup_entry(ik, thread);\n+}\n+\n+\/\/ Add if not exist.\n+static FinalizerEntry* get_entry(const InstanceKlass* ik, Thread* thread) {\n+  assert(ik != nullptr, \"invariant\");\n+  assert(ik->has_finalizer(), \"invariant\");\n+  FinalizerEntry* const entry = lookup_entry(ik, thread);\n+  return entry != nullptr ? entry : add_to_table_if_needed(ik, thread);\n+}\n+\n+static FinalizerEntry* get_entry(oop finalizee, Thread* thread) {\n+  assert(finalizee != nullptr, \"invariant\");\n+  assert(finalizee->is_instance(), \"invariant\");\n+  return get_entry(InstanceKlass::cast(finalizee->klass()), thread);\n+}\n+\n+static void log_registered(oop finalizee, Thread* thread) {\n+  ResourceMark rm(thread);\n+  const intptr_t identity_hash = ObjectSynchronizer::FastHashCode(thread, finalizee);\n+  log_info(finalizer)(\"Registered object (\" INTPTR_FORMAT \") of class %s as finalizable\", identity_hash, finalizee->klass()->external_name());\n+}\n+\n+void FinalizerService::on_register(oop finalizee, Thread* thread) {\n+  FinalizerEntry* const fe = get_entry(finalizee, thread);\n+  assert(fe != nullptr, \"invariant\");\n+  fe->on_register();\n+  if (log_is_enabled(Info, finalizer)) {\n+    log_registered(finalizee, thread);\n+  }\n+}\n+\n+static void log_completed(oop finalizee, Thread* thread) {\n+  ResourceMark rm(thread);\n+  const intptr_t identity_hash = ObjectSynchronizer::FastHashCode(thread, finalizee);\n+  log_info(finalizer)(\"Finalizer was run for object (\" INTPTR_FORMAT \") of class %s\", identity_hash, finalizee->klass()->external_name());\n+}\n+\n+void FinalizerService::on_complete(oop finalizee, JavaThread* finalizer_thread) {\n+  FinalizerEntry* const fe = get_entry(finalizee, finalizer_thread);\n+  assert(fe != nullptr, \"invariant\");\n+  fe->on_complete();\n+  if (log_is_enabled(Info, finalizer)) {\n+    log_completed(finalizee, finalizer_thread);\n+  }\n+}\n+\n+class FinalizerScan : public StackObj {\n+ private:\n+  FinalizerEntryClosure* _closure;\n+ public:\n+  FinalizerScan(FinalizerEntryClosure* closure) : _closure(closure) {}\n+  bool operator()(FinalizerEntry** fe) {\n+    return _closure->do_entry(*fe);\n+  }\n+};\n+\n+void FinalizerService::do_entries(FinalizerEntryClosure* closure, Thread* thread) {\n+  assert(closure != nullptr, \"invariant\");\n+  FinalizerScan scan(closure);\n+  _table->do_scan(thread, scan);\n+}\n+\n+static bool remove_entry(const InstanceKlass* ik) {\n+  assert(ik != nullptr, \"invariant\");\n+  FinalizerEntryLookup lookup(ik);\n+  return _table->remove(Thread::current(), lookup);\n+}\n+\n+static void on_unloading(Klass* klass) {\n+  assert(klass != nullptr, \"invariant\");\n+  if (!klass->is_instance_klass()) {\n+    return;\n+  }\n+  const InstanceKlass* const ik = InstanceKlass::cast(klass);\n+  if (ik->has_finalizer()) {\n+    remove_entry(ik);\n+  }\n+}\n+\n+void FinalizerService::purge_unloaded() {\n+  assert_locked_or_safepoint(ClassLoaderDataGraph_lock);\n+  ClassLoaderDataGraph::classes_unloading_do(&on_unloading);\n+}\n+\n+#endif \/\/ INCLUDE_MANAGEMENT\n","filename":"src\/hotspot\/share\/services\/finalizerService.cpp","additions":488,"deletions":0,"binary":false,"changes":488,"status":"added"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_SERVICES_FINALIZERSERVICE_HPP\n+#define SHARE_SERVICES_FINALIZERSERVICE_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"oops\/oopsHierarchy.hpp\"\n+\n+class InstanceKlass;\n+class JavaThread;\n+class Thread;\n+\n+class FinalizerEntry : public CHeapObj<mtStatistics> {\n+ private:\n+  const InstanceKlass* const _ik;\n+  uint64_t _objects_on_heap;\n+  uint64_t _total_finalizers_run;\n+ public:\n+  FinalizerEntry(const InstanceKlass* ik);\n+  const InstanceKlass* klass() const NOT_MANAGEMENT_RETURN_(nullptr);\n+  uint64_t objects_on_heap() const NOT_MANAGEMENT_RETURN_(0L);\n+  uint64_t total_finalizers_run() const NOT_MANAGEMENT_RETURN_(0L);\n+  void on_register() NOT_MANAGEMENT_RETURN;\n+  void on_complete() NOT_MANAGEMENT_RETURN;\n+};\n+\n+class FinalizerEntryClosure : public StackObj {\n+ public:\n+  virtual bool do_entry(const FinalizerEntry* fe) = 0;\n+};\n+\n+class FinalizerService : AllStatic {\n+  friend class ParallelSPCleanupTask;\n+  friend class ServiceThread;\n+ private:\n+  static void rehash() NOT_MANAGEMENT_RETURN;\n+  static bool needs_rehashing() NOT_MANAGEMENT_RETURN_(false);\n+  static bool has_work() NOT_MANAGEMENT_RETURN_(false);\n+  static void do_concurrent_work(JavaThread* service_thread) NOT_MANAGEMENT_RETURN;\n+ public:\n+  static void init() NOT_MANAGEMENT_RETURN;\n+  static void purge_unloaded() NOT_MANAGEMENT_RETURN;\n+  static void on_register(oop finalizee, Thread* thread) NOT_MANAGEMENT_RETURN;\n+  static void on_complete(oop finalizee, JavaThread* finalizer_thread) NOT_MANAGEMENT_RETURN;\n+  static void do_entries(FinalizerEntryClosure* closure, Thread* thread) NOT_MANAGEMENT_RETURN;\n+  static const FinalizerEntry* lookup(const InstanceKlass* ik, Thread* thread) NOT_MANAGEMENT_RETURN_(nullptr);\n+};\n+\n+#endif \/\/ SHARE_SERVICES_FINALIZERSERVICE_HPP\n","filename":"src\/hotspot\/share\/services\/finalizerService.hpp","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -58,0 +58,1 @@\n+#include \"services\/finalizerService.hpp\"\n@@ -97,0 +98,1 @@\n+  FinalizerService::init();\n@@ -209,0 +211,9 @@\n+\n+void Management::record_vm_init_completed() {\n+  \/\/ Initialize the timestamp to get the current time\n+  _vm_init_done_time->set_value(os::javaTimeMillis());\n+\n+  \/\/ Update the timestamp to the vm init done time\n+  _stamp.update();\n+}\n+\n@@ -219,0 +230,8 @@\n+jlong Management::begin_vm_creation_time() {\n+  return _begin_vm_creation_time->get_value();\n+}\n+\n+jlong Management::vm_init_done_time() {\n+  return _vm_init_done_time->get_value();\n+}\n+\n@@ -2066,0 +2085,5 @@\n+\n+JVM_ENTRY(void, jmm_ReportFinalizationComplete(JNIEnv* env, jobject finalizee))\n+  FinalizerService::on_complete(JNIHandles::resolve_non_null(finalizee), THREAD);\n+JVM_END\n+\n@@ -2200,2 +2224,0 @@\n-\n-\n@@ -2243,1 +2265,2 @@\n-  jmm_SetDiagnosticFrameworkNotificationEnabled\n+  jmm_SetDiagnosticFrameworkNotificationEnabled,\n+  jmm_ReportFinalizationComplete\n","filename":"src\/hotspot\/share\/services\/management.cpp","additions":26,"deletions":3,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -73,3 +73,1 @@\n-  static void  record_vm_init_completed() {\n-    \/\/ Initialize the timestamp to get the current time\n-    _vm_init_done_time->set_value(os::javaTimeMillis());\n+  static void  record_vm_init_completed() NOT_MANAGEMENT_RETURN;\n@@ -77,10 +75,2 @@\n-    \/\/ Update the timestamp to the vm init done time\n-    _stamp.update();\n-  }\n-\n-  static jlong begin_vm_creation_time() {\n-    return _begin_vm_creation_time->get_value();\n-  }\n-  static jlong vm_init_done_time() {\n-    return _vm_init_done_time->get_value();\n-  }\n+  static jlong begin_vm_creation_time() NOT_MANAGEMENT_RETURN_(0L);\n+  static jlong vm_init_done_time() NOT_MANAGEMENT_RETURN_(0L);\n","filename":"src\/hotspot\/share\/services\/management.hpp","additions":3,"deletions":13,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -129,0 +129,1 @@\n+#define MANAGEMENT_ONLY(x) x\n@@ -132,0 +133,1 @@\n+#define MANAGEMENT_ONLY(x)\n","filename":"src\/hotspot\/share\/utilities\/macros.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,0 +48,7 @@\n+    static {\n+        initIDs();\n+    }\n+\n+    private static native void initIDs();\n+    private static native void reportComplete(Object finalizee);\n+\n@@ -64,0 +71,2 @@\n+\n+\n@@ -89,0 +98,1 @@\n+                reportComplete(finalizee);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ref\/Finalizer.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jmm.h\"\n+#include \"jvm.h\"\n+\n+#include \"java_lang_ref_Finalizer.h\"\n+\n+static const JmmInterface* jmm_interface = NULL;\n+\n+JNIEXPORT void JNICALL\n+Java_java_lang_ref_Finalizer_initIDs(JNIEnv* env, jclass cls) {\n+  jmm_interface = (JmmInterface*)JVM_GetManagement(JMM_VERSION);\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_java_lang_ref_Finalizer_reportComplete(JNIEnv* env, jclass cls, jobject finalizee) {\n+  if (jmm_interface != NULL) {\n+    jmm_interface->ReportFinalizationComplete(env, finalizee);\n+  }\n+}\n+\n+\n","filename":"src\/java.base\/share\/native\/libjava\/Finalizer.c","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -810,0 +810,5 @@\n+    <event name=\"jdk.FinalizerStatistics\">\n+      <setting name=\"enabled\">true<\/setting>\n+      <setting name=\"period\">endChunk<\/setting>\n+    <\/event>\n+\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/default.jfc","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -810,0 +810,5 @@\n+    <event name=\"jdk.FinalizerStatistics\">\n+      <setting name=\"enabled\">true<\/setting>\n+      <setting name=\"period\">endChunk<\/setting>\n+    <\/event>\n+\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/profile.jfc","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,129 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.event.runtime;\n+\n+import java.util.List;\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedClass;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.jfr.EventNames;\n+import jdk.test.lib.jfr.Events;\n+import jdk.test.lib.jfr.TestClassLoader;\n+\n+\/**\n+ * @test\n+ * @summary The test verifies that classes overriding finalize() are represented as events.\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib \/test\/jdk\n+ * @run main\/othervm -Xlog:class+unload,finalizer -Xmx16m jdk.jfr.event.runtime.TestFinalizerStatisticsEvent\n+ *\/\n+\n+public final class TestFinalizerStatisticsEvent {\n+    private final static String TEST_CLASS_NAME = \"jdk.jfr.event.runtime.TestFinalizerStatisticsEvent$TestClassOverridingFinalize\";\n+    private final static String TEST_CLASS_UNLOAD_NAME = \"jdk.jfr.event.runtime.TestFinalizerStatisticsEvent$TestClassUnloadOverridingFinalize\";\n+    private final static String EVENT_PATH = EventNames.FinalizerStatistics;\n+\n+    \/\/ Declare as \"public static to prevent the compiler from optimizing away all unread writes\n+    public static TestClassLoader unloadableClassLoader;\n+    public static Class<?> unloadOverrideClass;\n+    public static Object overridingInstance;\n+\n+    public static void main(String[] args) throws Throwable {\n+        Recording recording1 = new Recording();\n+        recording1.enable(EVENT_PATH);\n+        Recording recording2 = new Recording();\n+        recording2.enable(EVENT_PATH);\n+        recording1.start();\n+        allocateAndGC();\n+        recording2.start(); \/\/ rotation writes an event for TEST_CLASS_NAME into recording1\n+        unloadableClassLoader = new TestClassLoader();\n+        unloadOverrideClass = unloadableClassLoader.loadClass(TEST_CLASS_UNLOAD_NAME);\n+        unloadOverrideClass = null;\n+        unloadableClassLoader = null;\n+        allocateAndGC(); \/\/ the unloading of class TEST_CLASS_UNLOAD_NAME is intercepted and an event is written into both recording1 and recording2\n+        recording2.stop(); \/\/ rotation writes an event for TEST_CLASS_NAME into both recording1 and recording2\n+        allocateAndGC();\n+        recording1.stop(); \/\/ rotation writes an event for TEST_CLASS_NAME into recording1 which now has 4 events reflecting this test case (3 chunks + 1 unload)\n+\n+        try {\n+            verify(recording2);\n+            verify(recording1);\n+        }\n+        finally {\n+            recording2.close();\n+            recording1.close();\n+        }\n+    }\n+\n+    private static void allocateAndGC() {\n+        overridingInstance = new TestClassOverridingFinalize();\n+        overridingInstance = null;\n+        System.gc();\n+    }\n+\n+    private static void verify(Recording recording) throws Throwable {\n+        boolean foundTestClassName = false;\n+        boolean foundTestClassUnloadName = false;\n+        List<RecordedEvent> events = Events.fromRecording(recording);\n+        Events.hasEvents(events);\n+        for (RecordedEvent event : events) {\n+          System.out.println(\"Event:\" + event);\n+          RecordedClass overridingClass = event.getValue(\"finalizableClass\");\n+          switch (overridingClass.getName()) {\n+              case TEST_CLASS_NAME: {\n+                  Asserts.assertTrue(event.getString(\"codeSource\").startsWith(\"file:\/\/\"));\n+                  foundTestClassName = true;\n+                  break;\n+              }\n+              case TEST_CLASS_UNLOAD_NAME: {\n+                  Asserts.assertTrue(event.getString(\"codeSource\").startsWith(\"file:\/\/\"));\n+                  foundTestClassUnloadName = true;\n+                  break;\n+              }\n+          }\n+        }\n+        Asserts.assertTrue(foundTestClassName, \"The class: \" + TEST_CLASS_NAME + \" overriding finalize() is not found\");\n+        Asserts.assertTrue(foundTestClassUnloadName, \"The class: \" + TEST_CLASS_UNLOAD_NAME + \" overriding finalize() is not found\");\n+    }\n+\n+    static public class TestClassOverridingFinalize {\n+        public boolean finalized = false;\n+\n+        @Override\n+        protected void finalize() {\n+            finalized = true;\n+        }\n+    }\n+\n+    static public class TestClassUnloadOverridingFinalize {\n+        public boolean finalized = false;\n+\n+        @Override\n+        protected void finalize() {\n+            finalized = true;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/TestFinalizerStatisticsEvent.java","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"},{"patch":"@@ -91,0 +91,1 @@\n+    public static final String FinalizerStatistics = PREFIX + \"FinalizerStatistics\";\n","filename":"test\/lib\/jdk\/test\/lib\/jfr\/EventNames.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,0 +31,4 @@\n+import java.net.URL;\n+import java.security.cert.Certificate;\n+import java.security.CodeSource;\n+import java.security.ProtectionDomain;\n@@ -56,1 +60,4 @@\n-                return defineClass(name, buf, 0, buf.length);\n+                URL url = getResource(resourceName);\n+                CodeSource cs = new CodeSource(url, (Certificate[])null);\n+                ProtectionDomain pd = new ProtectionDomain(cs, null);\n+                return defineClass(name, buf, 0, buf.length, pd);\n","filename":"test\/lib\/jdk\/test\/lib\/jfr\/TestClassLoader.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"}]}