{"files":[{"patch":"@@ -69,1 +69,0 @@\n-#include \"services\/finalizerService.hpp\"\n@@ -595,7 +594,0 @@\n-    if (_subtasks.try_claim_task(SafepointSynchronize::SAFEPOINT_CLEANUP_REQUEST_FINALIZERSERVICE_TABLE_REHASH)) {\n-      if (FinalizerService::needs_rehashing()) {\n-        Tracer t(\"rehashing finalizerservice table\");\n-        FinalizerService::rehash();\n-      }\n-    }\n-\n","filename":"src\/hotspot\/share\/runtime\/safepoint.cpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -80,1 +80,0 @@\n-    SAFEPOINT_CLEANUP_REQUEST_FINALIZERSERVICE_TABLE_REHASH,\n","filename":"src\/hotspot\/share\/runtime\/safepoint.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -79,22 +79,0 @@\n-size_t ClassLoadingService::compute_class_size(InstanceKlass* k) {\n-  \/\/ lifted from ClassStatistics.do_class(Klass* k)\n-\n-  size_t class_size = 0;\n-\n-  class_size += k->size();\n-\n-  if (k->is_instance_klass()) {\n-    class_size += k->methods()->size();\n-    \/\/ FIXME: Need to count the contents of methods\n-    class_size += k->constants()->size();\n-    class_size += k->local_interfaces()->size();\n-    if (k->transitive_interfaces() != NULL) {\n-      class_size += k->transitive_interfaces()->size();\n-    }\n-    \/\/ We do not have to count implementors, since we only store one!\n-    \/\/ FIXME: How should these be accounted for, now when they have moved.\n-    \/\/class_size += k->fields()->size();\n-  }\n-  return class_size * oopSize;\n-}\n-\n@@ -197,0 +175,18 @@\n+static size_t compute_class_size(InstanceKlass* k) {\n+  \/\/ lifted from ClassStatistics.do_class(Klass* k)\n+  size_t class_size = k->size();\n+  if (k->is_instance_klass()) {\n+    class_size += k->methods()->size();\n+    \/\/ FIXME: Need to count the contents of methods\n+    class_size += k->constants()->size();\n+    class_size += k->local_interfaces()->size();\n+    if (k->transitive_interfaces() != NULL) {\n+      class_size += k->transitive_interfaces()->size();\n+    }\n+    \/\/ We do not have to count implementors, since we only store one!\n+    \/\/ FIXME: How should these be accounted for, now when they have moved.\n+    \/\/class_size += k->fields()->size();\n+  }\n+  return class_size * oopSize;\n+}\n+\n","filename":"src\/hotspot\/share\/services\/classLoadingService.cpp","additions":18,"deletions":22,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-private:\n+ private:\n@@ -53,3 +53,1 @@\n-  static size_t compute_class_size(InstanceKlass* k);\n-\n-public:\n+ public:\n","filename":"src\/hotspot\/share\/services\/classLoadingService.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-#include \"runtime\/handles.hpp\"\n@@ -32,1 +31,0 @@\n-#include \"runtime\/javaCalls.hpp\"\n@@ -87,34 +85,0 @@\n-static constexpr const size_t DEFAULT_TABLE_SIZE = 2048;\n-\/\/ 2^24 is max size, like StringTable.\n-static constexpr const size_t MAX_SIZE = 24;\n-\/\/ If a chain gets to 50, something might be wrong\n-static constexpr const size_t REHASH_LEN = 50;\n-static constexpr const double PREF_AVG_LIST_LEN = 8.0;\n-\n-static size_t _table_size = 0;\n-static volatile uint64_t _entries = 0;\n-static volatile uint64_t _count = 0;\n-static volatile bool _has_work = 0;\n-static volatile bool _needs_rehashing = false;\n-static volatile bool _has_items_to_clean = false;\n-\n-static inline void reset_has_items_to_clean() {\n-  Atomic::store(&_has_items_to_clean, false);\n-}\n-\n-static inline void set_has_items_to_clean() {\n-  Atomic::store(&_has_items_to_clean, true);\n-}\n-\n-static inline bool has_items_to_clean() {\n-  return Atomic::load(&_has_items_to_clean);\n-}\n-\n-static inline void added() {\n-  set_atomic<inc>(&_count);\n-}\n-\n-static inline void removed() {\n-  set_atomic<dec>(&_count);\n-}\n-\n@@ -152,2 +116,1 @@\n-    added();\n-    return AllocateHeap(size, mtClass);\n+    return AllocateHeap(size, mtStatistics);\n@@ -158,1 +121,0 @@\n-    removed();\n@@ -164,0 +126,4 @@\n+static constexpr const size_t DEFAULT_TABLE_SIZE = 2048;\n+\/\/ 2^24 is max size, like StringTable.\n+static constexpr const size_t MAX_SIZE = 24;\n+static volatile bool _has_work = false;\n@@ -171,18 +137,0 @@\n-static double table_load_factor() {\n-  return (double)_count \/ _table_size;\n-}\n-\n-static inline size_t table_size() {\n-  return ((size_t)1) << _table->get_size_log2(Thread::current());\n-}\n-\n-static inline bool table_needs_rehashing() {\n-  return _needs_rehashing;\n-}\n-\n-static inline void update_table_needs_rehash(bool rehash) {\n-  if (rehash) {\n-    _needs_rehashing = true;\n-  }\n-}\n-\n@@ -213,4 +161,2 @@\n-static void trigger_table_cleanup() {\n-  MutexLocker ml(Service_lock, Mutex::_no_safepoint_check_flag);\n-  _has_work = true;\n-  Service_lock->notify_all();\n+static inline void set_has_work(bool value) {\n+  Atomic::store(&_has_work, value);\n@@ -219,9 +165,11 @@\n-static void check_table_concurrent_work() {\n-  if (_has_work) {\n-    return;\n-  }\n-  \/\/ We should clean\/resize if we have\n-  \/\/ more items than preferred load factor or\n-  \/\/ more dead items than water mark.\n-  if (has_items_to_clean() || (table_load_factor() > PREF_AVG_LIST_LEN)) {\n-    trigger_table_cleanup();\n+static inline bool has_work() {\n+  return Atomic::load(&_has_work);\n+}\n+\n+static void request_resize() {\n+  if (!has_work()) {\n+    MutexLocker ml(Service_lock, Mutex::_no_safepoint_check_flag);\n+    if (!has_work()) {\n+      set_has_work(true);\n+      Service_lock->notify_all();\n+    }\n@@ -233,2 +181,0 @@\n-  bool clean_hint = false;\n-  bool rehash_warning = false;\n@@ -236,0 +182,1 @@\n+  bool grow_hint = false;\n@@ -239,1 +186,1 @@\n-    if (_table->insert(thread, lookup, entry, &rehash_warning, &clean_hint)) {\n+    if (_table->insert(thread, lookup, entry, &grow_hint)) {\n@@ -245,1 +192,1 @@\n-    if (_table->get(thread, lookup, felg, &rehash_warning)) {\n+    if (_table->get(thread, lookup, felg, &grow_hint)) {\n@@ -250,4 +197,2 @@\n-  update_table_needs_rehash(rehash_warning);\n-  if (clean_hint) {\n-    set_has_items_to_clean();\n-    check_table_concurrent_work();\n+  if (grow_hint) {\n+    request_resize();\n@@ -259,10 +204,5 @@\n-\/\/ Concurrent work\n-static void grow_table(JavaThread* jt) {\n-  FinalizerHashtable::GrowTask gt(_table);\n-  if (!gt.prepare(jt)) {\n-    return;\n-  }\n-  while (gt.do_task(jt)) {\n-    gt.pause(jt);\n-    {\n-      ThreadBlockInVM tbivm(jt);\n+static void do_table_concurrent_work(JavaThread* jt) {\n+  if (!_table->is_max_size_reached()) {\n+    FinalizerHashtable::GrowTask gt(_table);\n+    if (!gt.prepare(jt)) {\n+      return;\n@@ -270,38 +210,6 @@\n-    gt.cont(jt);\n-  }\n-  gt.done(jt);\n-  _table_size = table_size();\n-}\n-\n-struct FinalizerEntryDelete : StackObj {\n-  size_t _deleted;\n-  FinalizerEntryDelete() : _deleted(0) {}\n-  void operator()(FinalizerEntry** value) {\n-    assert(value != nullptr, \"invariant\");\n-    assert(*value != nullptr, \"invariant\");\n-    _deleted++;\n-  }\n-};\n-\n-struct FinalizerEntryDeleteCheck : StackObj {\n-  size_t _processed;\n-  FinalizerEntryDeleteCheck() : _processed(0) {}\n-  bool operator()(FinalizerEntry** value) {\n-    assert(value != nullptr, \"invariant\");\n-    assert(*value != nullptr, \"invariant\");\n-    _processed++;\n-    return true;\n-  }\n-};\n-\n-static void clean_table_entries(JavaThread* jt) {\n-  FinalizerHashtable::BulkDeleteTask bdt(_table);\n-  if (!bdt.prepare(jt)) {\n-    return;\n-  }\n-  FinalizerEntryDeleteCheck fedc;\n-  FinalizerEntryDelete fed;\n-  while (bdt.do_task(jt, fedc, fed)) {\n-    bdt.pause(jt);\n-    {\n-      ThreadBlockInVM tbivm(jt);\n+    while (gt.do_task(jt)) {\n+      gt.pause(jt);\n+      {\n+        ThreadBlockInVM tbivm(jt);\n+      }\n+      gt.cont(jt);\n@@ -309,1 +217,1 @@\n-    bdt.cont(jt);\n+    gt.done(jt);\n@@ -311,60 +219,1 @@\n-  reset_has_items_to_clean();\n-  bdt.done(jt);\n-}\n-\n-static void do_table_concurrent_work(JavaThread* jt) {\n-  \/\/ We prefer growing, since that also removes dead items\n-  if (table_load_factor() > PREF_AVG_LIST_LEN && !_table->is_max_size_reached()) {\n-    grow_table(jt);\n-  } else {\n-    clean_table_entries(jt);\n-  }\n-  _has_work = false;\n-}\n-\n-\/\/ Rehash\n-static bool do_table_rehash() {\n-  if (!_table->is_safepoint_safe()) {\n-    return false;\n-  }\n-  Thread* const thread = Thread::current();\n-  \/\/ We use current size\n-  const size_t new_size = _table->get_size_log2(thread);\n-  FinalizerHashtable* const new_table = new FinalizerHashtable(new_size, MAX_SIZE, REHASH_LEN);\n-  if (!_table->try_move_nodes_to(thread, new_table)) {\n-    delete new_table;\n-    return false;\n-  }\n-  \/\/ free old table\n-  delete _table;\n-  _table = new_table;\n-  return true;\n-}\n-\n-bool FinalizerService::needs_rehashing() {\n-  return _needs_rehashing;\n-}\n-\n-void FinalizerService::rehash() {\n-  static bool rehashed = false;\n-  log_debug(finalizer)(\"Table imbalanced, rehashing called.\");\n-  \/\/ Grow instead of rehash.\n-  if (table_load_factor() > PREF_AVG_LIST_LEN && !_table->is_max_size_reached()) {\n-    log_debug(finalizer)(\"Choosing growing over rehashing.\");\n-    trigger_table_cleanup();\n-    _needs_rehashing = false;\n-    return;\n-  }\n-  \/\/ Already rehashed.\n-  if (rehashed) {\n-    log_warning(finalizer)(\"Rehashing already done, still long lists.\");\n-    trigger_table_cleanup();\n-    _needs_rehashing = false;\n-    return;\n-  }\n-  if (do_table_rehash()) {\n-    rehashed = true;\n-  } else {\n-    log_debug(finalizer)(\"Resizes in progress rehashing skipped.\");\n-  }\n-  _needs_rehashing = false;\n+  set_has_work(false);\n@@ -374,1 +223,1 @@\n-  return _has_work;\n+  return ::has_work();\n@@ -379,3 +228,2 @@\n-  if (_has_work) {\n-    do_table_concurrent_work(service_thread);\n-  }\n+  assert(has_work(), \"invariant\");\n+  do_table_concurrent_work(service_thread);\n@@ -387,2 +235,1 @@\n-  _table_size = ((size_t)1) << start_size_log_2;\n-  _table = new FinalizerHashtable(start_size_log_2, MAX_SIZE, REHASH_LEN);\n+  _table = new FinalizerHashtable(start_size_log_2, MAX_SIZE);\n@@ -394,2 +241,1 @@\n-  bool rehash_warning;\n-  _table->get(thread, lookup, felg, &rehash_warning);\n+  _table->get(thread, lookup, felg);\n","filename":"src\/hotspot\/share\/services\/finalizerService.cpp","additions":41,"deletions":195,"binary":false,"changes":236,"status":"modified"},{"patch":"@@ -55,1 +55,0 @@\n-  friend class ParallelSPCleanupTask;\n@@ -58,2 +57,0 @@\n-  static void rehash() NOT_MANAGEMENT_RETURN;\n-  static bool needs_rehashing() NOT_MANAGEMENT_RETURN_(false);\n","filename":"src\/hotspot\/share\/services\/finalizerService.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"}]}