{"files":[{"patch":"@@ -55,1 +55,1 @@\n-  JMM_VERSION_4   = 0x20040000,  \/\/ JDK 18\n+  JMM_VERSION_4   = 0x20040000, \/\/ JDK 18\n","filename":"src\/hotspot\/share\/include\/jmm.h","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -323,1 +323,1 @@\n-  def(JfrMsg_lock                  , PaddedMonitor, leaf,        true,  _safepoint_check_always);\n+  def(JfrMsg_lock                  , PaddedMonitor, leaf-1,      true,  _safepoint_check_always); \/\/ -1 because the ConcurrentHashTable resize lock is leaf\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-\n@@ -38,1 +37,1 @@\n- * @summary The test verifies that classes overriding finalize(), loaded as well as unloaded, are represented as events.\n+ * @summary The test verifies that classes overriding finalize() are represented as events.\n@@ -50,2 +49,1 @@\n-    \/\/ Declare unloadableClassLoader as \"public static\"\n-    \/\/ to prevent the compiler to optimize away all unread writes\n+    \/\/ Declare as \"public static to prevent the compiler from optimizing away all unread writes\n@@ -54,4 +52,1 @@\n-\n-    public static Object overridingInstance1;\n-    public static Object overridingInstance2;\n-    public static Object overridingInstance3;\n+    public static Object overridingInstance;\n@@ -64,2 +59,0 @@\n-        TestClassLoader cl = new TestClassLoader();\n-        unloadableClassLoader = new TestClassLoader();\n@@ -67,2 +60,1 @@\n-        Class<?> overrideClass = cl.loadClass(TEST_CLASS_NAME);\n-        overridingInstance1 = overrideClass.newInstance();\n+        allocateAndGC();\n@@ -70,1 +62,1 @@\n-        overridingInstance2 = overrideClass.newInstance();\n+        unloadableClassLoader = new TestClassLoader();\n@@ -74,2 +66,1 @@\n-        System.gc(); \/\/ the unloading of class TEST_CLASS_UNLOAD_NAME is intercepted and an event is written into both recording1 and recording2\n-\n+        allocateAndGC(); \/\/ the unloading of class TEST_CLASS_UNLOAD_NAME is intercepted and an event is written into both recording1 and recording2\n@@ -77,1 +68,1 @@\n-        overridingInstance3 = overrideClass.newInstance();\n+        allocateAndGC();\n@@ -81,1 +72,0 @@\n-            System.out.println(\"Verifying recording2\");\n@@ -83,1 +73,0 @@\n-            System.out.println(\"Verifying recording1\");\n@@ -92,0 +81,6 @@\n+    private static void allocateAndGC() {\n+        overridingInstance = new TestClassOverridingFinalize();\n+        overridingInstance = null;\n+        System.gc();\n+    }\n+\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/TestFinalizerEvent.java","additions":13,"deletions":18,"binary":false,"changes":31,"status":"modified"}]}