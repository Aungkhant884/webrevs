{"files":[{"patch":"@@ -534,2 +534,0 @@\n-    remove_cycles();\n-\n@@ -1296,2 +1294,1 @@\n-  \/\/ FIXME - co_locate_pack fails on Stores in different mem-slices, so\n-  \/\/ only pack memops that are in the same alias set until that's fixed.\n+  \/\/ Adjacent memory references must be on the same slice.\n@@ -1301,0 +1298,3 @@\n+\n+  \/\/ Adjacent memory references must have the same base, be comparable\n+  \/\/ and have the correct distance between them.\n@@ -2362,0 +2362,1 @@\n+  GrowableArray<Node*> _pid_to_node;       \/\/ one node per pid, find rest via my_pack\n@@ -2366,0 +2367,2 @@\n+  bool _schedule_success;\n+\n@@ -2388,1 +2391,1 @@\n-  void set_pid(const Node* n, int pid) {\n+  void set_pid(Node* n, int pid) {\n@@ -2393,0 +2396,7 @@\n+    _pid_to_node.at_put_grow(pid - 1, n, nullptr);\n+  }\n+  Node* get_node(int pid) {\n+    assert(pid > 0 && pid <= _pid_to_node.length(), \"pid must be mapped\");\n+    Node* n = _pid_to_node.at(pid - 1);\n+    assert(n != nullptr, \"sanity\");\n+    return n;\n@@ -2402,0 +2412,1 @@\n+  bool schedule_success() const { return _schedule_success; }\n@@ -2415,0 +2426,1 @@\n+        assert(_slp->my_pack(n) == p, \"matching packset\");\n@@ -2430,0 +2442,1 @@\n+        assert(_slp->my_pack(n) == nullptr || UseVectorCmov, \"no packset\");\n@@ -2475,5 +2488,7 @@\n-  \/\/ Schedule the graph to worklist. Returns true iff all nodes were scheduled.\n-  \/\/ This implies that we return true iff the PacksetGraph is acyclic.\n-  \/\/ We schedule with topological sort: schedule any node that has zero incnt.\n-  \/\/ Then remove that node, which decrements the incnt of all its uses (outputs).\n-  bool schedule() {\n+\n+  \/\/ Schedule nodes of PacksetGraph to worklist, using topsort: schedule a node\n+  \/\/ that has zero incnt. If a PacksetGraph node corresponds to memops, then add\n+  \/\/ those to the memops_schedule. At the end, we return the memops_schedule, and\n+  \/\/ note if topsort was successful.\n+  Node_List schedule() {\n+    Node_List memops_schedule;\n@@ -2490,0 +2505,16 @@\n+\n+      \/\/ Add memops to memops_schedule\n+      Node* n = get_node(pid);\n+      Node_List* p = _slp->my_pack(n);\n+      if (n->is_Mem()) {\n+        if (p == nullptr) {\n+          memops_schedule.push(n);\n+        } else {\n+          for (uint k = 0; k < p->size(); k++) {\n+            memops_schedule.push(p->at(k));\n+            assert(p->at(k)->is_Mem(), \"only schedule memops\");\n+          }\n+        }\n+      }\n+\n+      \/\/ Decrement incnt for all successors\n@@ -2500,2 +2531,4 @@\n-    \/\/ Was every pid scheduled?\n-    return worklist.length() == _max_pid;\n+\n+    \/\/ Was every pid scheduled? If not, we found some cycles in the PacksetGraph.\n+    _schedule_success = (worklist.length() == _max_pid);\n+    return memops_schedule;\n@@ -2503,0 +2536,1 @@\n+\n@@ -2533,13 +2567,10 @@\n-\/\/------------------------------remove_cycles---------------------------\n-\/\/ We now know that we only have independent packs, see verify_packs.\n-\/\/ This is a necessary but not a sufficient condition for an acyclic\n-\/\/ graph (DAG) after scheduling. Thus, we must check if the packs have\n-\/\/ introduced a cycle. The SuperWord paper mentions the need for this\n-\/\/ in \"3.7 Scheduling\".\n-\/\/ Approach: given all nodes from the _block, we create a new graph.\n-\/\/ The nodes that are not in a pack are their own nodes (scalar-node)\n-\/\/ in that new graph. Every pack is also a node (pack-node). We then\n-\/\/ add the edges according to DepPreds: a scalar-node has all edges\n-\/\/ to its node's DepPreds. A pack-node has all edges from every pack\n-\/\/ member to all their DepPreds.\n-void SuperWord::remove_cycles() {\n+\/\/ The C2 graph (specifically the memory graph), needs to be re-ordered.\n+\/\/ (1) Build the PacksetGraph. It combines the DepPreds graph with the\n+\/\/     packset. The PacksetGraph gives us the dependencies that must be\n+\/\/     respected after scheduling.\n+\/\/ (2) Schedule the PacksetGraph to the memops_schedule, which represents\n+\/\/     a linear order of all memops in the body. The order respects the\n+\/\/     dependencies of the PacksetGraph.\n+\/\/ (3) If the PacksetGraph has cycles, we cannot schedule. Abort.\n+\/\/ (4) Use the memops_schedule to re-order the memops in all slices.\n+void SuperWord::schedule() {\n@@ -2551,0 +2582,1 @@\n+  \/\/ (1) Build the PacksetGraph.\n@@ -2552,1 +2584,0 @@\n-\n@@ -2555,1 +2586,10 @@\n-  if (!graph.schedule()) {\n+  \/\/ (2) Schedule the PacksetGraph.\n+  Node_List memops_schedule = graph.schedule();\n+\n+  \/\/ (3) Check if the PacksetGraph schedule succeeded (had no cycles).\n+  \/\/ We now know that we only have independent packs, see verify_packs.\n+  \/\/ This is a necessary but not a sufficient condition for an acyclic\n+  \/\/ graph (DAG) after scheduling. Thus, we must check if the packs have\n+  \/\/ introduced a cycle. The SuperWord paper mentions the need for this\n+  \/\/ in \"3.7 Scheduling\".\n+  if (!graph.schedule_success()) {\n@@ -2557,1 +2597,1 @@\n-      tty->print_cr(\"remove_cycles found cycle in PacksetGraph:\");\n+      tty->print_cr(\"SuperWord::schedule found cycle in PacksetGraph:\");\n@@ -2562,0 +2602,1 @@\n+    return;\n@@ -2563,11 +2604,0 @@\n-}\n-\n-\/\/------------------------------schedule---------------------------\n-\/\/ Adjust the memory graph for the packed operations\n-void SuperWord::schedule() {\n-\n-  \/\/ Co-locate in the memory graph the members of each memory pack\n-  for (int i = 0; i < _packset.length(); i++) {\n-    co_locate_pack(_packset.at(i));\n-  }\n-}\n@@ -2575,47 +2605,4 @@\n-\/\/-------------------------------remove_and_insert-------------------\n-\/\/ Remove \"current\" from its current position in the memory graph and insert\n-\/\/ it after the appropriate insertion point (lip or uip).\n-void SuperWord::remove_and_insert(MemNode *current, MemNode *prev, MemNode *lip,\n-                                  Node *uip, Unique_Node_List &sched_before) {\n-  Node* my_mem = current->in(MemNode::Memory);\n-  bool sched_up = sched_before.member(current);\n-\n-  \/\/ remove current_store from its current position in the memory graph\n-  for (DUIterator i = current->outs(); current->has_out(i); i++) {\n-    Node* use = current->out(i);\n-    if (use->is_Mem()) {\n-      assert(use->in(MemNode::Memory) == current, \"must be\");\n-      if (use == prev) { \/\/ connect prev to my_mem\n-          _igvn.replace_input_of(use, MemNode::Memory, my_mem);\n-          --i; \/\/deleted this edge; rescan position\n-      } else if (sched_before.member(use)) {\n-        if (!sched_up) { \/\/ Will be moved together with current\n-          _igvn.replace_input_of(use, MemNode::Memory, uip);\n-          --i; \/\/deleted this edge; rescan position\n-        }\n-      } else {\n-        if (sched_up) { \/\/ Will be moved together with current\n-          _igvn.replace_input_of(use, MemNode::Memory, lip);\n-          --i; \/\/deleted this edge; rescan position\n-        }\n-      }\n-    }\n-  }\n-\n-  Node *insert_pt =  sched_up ?  uip : lip;\n-\n-  \/\/ all uses of insert_pt's memory state should use current's instead\n-  for (DUIterator i = insert_pt->outs(); insert_pt->has_out(i); i++) {\n-    Node* use = insert_pt->out(i);\n-    if (use->is_Mem()) {\n-      assert(use->in(MemNode::Memory) == insert_pt, \"must be\");\n-      _igvn.replace_input_of(use, MemNode::Memory, current);\n-      --i; \/\/deleted this edge; rescan position\n-    } else if (!sched_up && use->is_Phi() && use->bottom_type() == Type::MEMORY) {\n-      uint pos; \/\/lip (lower insert point) must be the last one in the memory slice\n-      for (pos=1; pos < use->req(); pos++) {\n-        if (use->in(pos) == insert_pt) break;\n-      }\n-      _igvn.replace_input_of(use, pos, current);\n-      --i;\n-    }\n+#ifndef PRODUCT\n+  if (TraceSuperWord) {\n+    tty->print_cr(\"SuperWord::schedule: memops_schedule:\");\n+    memops_schedule.dump();\n@@ -2623,0 +2610,1 @@\n+#endif\n@@ -2624,2 +2612,2 @@\n-  \/\/connect current to insert_pt\n-  _igvn.replace_input_of(current, MemNode::Memory, insert_pt);\n+  \/\/ (4) Use the memops_schedule to re-order the memops in all slices.\n+  schedule_reorder_memops(memops_schedule);\n@@ -2628,62 +2616,0 @@\n-\/\/------------------------------co_locate_pack----------------------------------\n-\/\/ To schedule a store pack, we need to move any sandwiched memory ops either before\n-\/\/ or after the pack, based upon dependence information:\n-\/\/ (1) If any store in the pack depends on the sandwiched memory op, the\n-\/\/     sandwiched memory op must be scheduled BEFORE the pack;\n-\/\/ (2) If a sandwiched memory op depends on any store in the pack, the\n-\/\/     sandwiched memory op must be scheduled AFTER the pack;\n-\/\/ (3) If a sandwiched memory op (say, memA) depends on another sandwiched\n-\/\/     memory op (say memB), memB must be scheduled before memA. So, if memA is\n-\/\/     scheduled before the pack, memB must also be scheduled before the pack;\n-\/\/ (4) If there is no dependence restriction for a sandwiched memory op, we simply\n-\/\/     schedule this store AFTER the pack\n-\/\/ (5) We know there is no dependence cycle, so there in no other case;\n-\/\/ (6) Finally, all memory ops in another single pack should be moved in the same direction.\n-\/\/\n-\/\/ To schedule a load pack, we use the memory state of either the first or the last load in\n-\/\/ the pack, based on the dependence constraint.\n-void SuperWord::co_locate_pack(Node_List* pk) {\n-  if (pk->at(0)->is_Store()) {\n-    MemNode* first     = executed_first(pk)->as_Mem();\n-    MemNode* last      = executed_last(pk)->as_Mem();\n-    Unique_Node_List schedule_before_pack;\n-    Unique_Node_List memops;\n-\n-    MemNode* current   = last->in(MemNode::Memory)->as_Mem();\n-    MemNode* previous  = last;\n-    while (true) {\n-      assert(in_bb(current), \"stay in block\");\n-      memops.push(previous);\n-      for (DUIterator i = current->outs(); current->has_out(i); i++) {\n-        Node* use = current->out(i);\n-        if (use->is_Mem() && use != previous)\n-          memops.push(use);\n-      }\n-      if (current == first) break;\n-      previous = current;\n-      current  = current->in(MemNode::Memory)->as_Mem();\n-    }\n-\n-    \/\/ determine which memory operations should be scheduled before the pack\n-    for (uint i = 1; i < memops.size(); i++) {\n-      Node *s1 = memops.at(i);\n-      if (!in_pack(s1, pk) && !schedule_before_pack.member(s1)) {\n-        for (uint j = 0; j< i; j++) {\n-          Node *s2 = memops.at(j);\n-          if (!independent(s1, s2)) {\n-            if (in_pack(s2, pk) || schedule_before_pack.member(s2)) {\n-              schedule_before_pack.push(s1); \/\/ s1 must be scheduled before\n-              Node_List* mem_pk = my_pack(s1);\n-              if (mem_pk != nullptr) {\n-                for (uint ii = 0; ii < mem_pk->size(); ii++) {\n-                  Node* s = mem_pk->at(ii);  \/\/ follow partner\n-                  if (memops.member(s) && !schedule_before_pack.member(s))\n-                    schedule_before_pack.push(s);\n-                }\n-              }\n-              break;\n-            }\n-          }\n-        }\n-      }\n-    }\n@@ -2691,43 +2617,10 @@\n-    Node*    upper_insert_pt = first->in(MemNode::Memory);\n-    \/\/ Following code moves loads connected to upper_insert_pt below aliased stores.\n-    \/\/ Collect such loads here and reconnect them back to upper_insert_pt later.\n-    memops.clear();\n-    for (DUIterator i = upper_insert_pt->outs(); upper_insert_pt->has_out(i); i++) {\n-      Node* use = upper_insert_pt->out(i);\n-      if (use->is_Mem() && !use->is_Store()) {\n-        memops.push(use);\n-      }\n-    }\n-\n-    MemNode* lower_insert_pt = last;\n-    previous                 = last; \/\/previous store in pk\n-    current                  = last->in(MemNode::Memory)->as_Mem();\n-\n-    \/\/ start scheduling from \"last\" to \"first\"\n-    while (true) {\n-      assert(in_bb(current), \"stay in block\");\n-      assert(in_pack(previous, pk), \"previous stays in pack\");\n-      Node* my_mem = current->in(MemNode::Memory);\n-\n-      if (in_pack(current, pk)) {\n-        \/\/ Forward users of my memory state (except \"previous) to my input memory state\n-        for (DUIterator i = current->outs(); current->has_out(i); i++) {\n-          Node* use = current->out(i);\n-          if (use->is_Mem() && use != previous) {\n-            assert(use->in(MemNode::Memory) == current, \"must be\");\n-            if (schedule_before_pack.member(use)) {\n-              _igvn.replace_input_of(use, MemNode::Memory, upper_insert_pt);\n-            } else {\n-              _igvn.replace_input_of(use, MemNode::Memory, lower_insert_pt);\n-            }\n-            --i; \/\/ deleted this edge; rescan position\n-          }\n-        }\n-        previous = current;\n-      } else { \/\/ !in_pack(current, pk) ==> a sandwiched store\n-        remove_and_insert(current, previous, lower_insert_pt, upper_insert_pt, schedule_before_pack);\n-      }\n-\n-      if (current == first) break;\n-      current = my_mem->as_Mem();\n-    } \/\/ end while\n+\/\/ Reorder the memory graph for all slices in parallel. We walk over the schedule once,\n+\/\/ and track the current memory state of each slice.\n+void SuperWord::schedule_reorder_memops(Node_List &memops_schedule) {\n+  int max_slices = _phase->C->num_alias_types();\n+  \/\/ When iterating over the memops_schedule, we keep track of the current memory state,\n+  \/\/ which is the Phi or a store in the loop.\n+  GrowableArray<Node*> current_state_in_slice(max_slices, max_slices, nullptr);\n+  \/\/ The memory state after the loop is the last store inside the loop. If we reorder the\n+  \/\/ loop we may have a different last store, and we need to adjust the uses accordingly.\n+  GrowableArray<Node*> old_last_store_in_slice(max_slices, max_slices, nullptr);\n@@ -2735,49 +2628,29 @@\n-    \/\/ Reconnect loads back to upper_insert_pt.\n-    for (uint i = 0; i < memops.size(); i++) {\n-      Node *ld = memops.at(i);\n-      if (ld->in(MemNode::Memory) != upper_insert_pt) {\n-        _igvn.replace_input_of(ld, MemNode::Memory, upper_insert_pt);\n-      }\n-    }\n-  } else if (pk->at(0)->is_Load()) { \/\/ Load pack\n-    \/\/ All loads in the pack should have the same memory state. By default,\n-    \/\/ we use the memory state of the last load. However, if any load could\n-    \/\/ not be moved down due to the dependence constraint, we use the memory\n-    \/\/ state of the first load.\n-    Node* mem_input = pick_mem_state(pk);\n-    _igvn.hash_delete(mem_input);\n-    \/\/ Give each load the same memory state\n-    for (uint i = 0; i < pk->size(); i++) {\n-      LoadNode* ld = pk->at(i)->as_Load();\n-      _igvn.replace_input_of(ld, MemNode::Memory, mem_input);\n-    }\n-  }\n-}\n-\n-\/\/ Finds the first and last memory state and then picks either of them by checking dependence constraints.\n-\/\/ If a store is dependent on an earlier load then we need to pick the memory state of the first load and cannot\n-\/\/ pick the memory state of the last load.\n-Node* SuperWord::pick_mem_state(Node_List* pk) {\n-  Node* first_mem = find_first_mem_state(pk);\n-  bool is_dependent = false;\n-  Node* last_mem  = find_last_mem_state(pk, first_mem, is_dependent);\n-\n-  for (uint i = 0; i < pk->size(); i++) {\n-    Node* ld = pk->at(i);\n-    for (Node* current = last_mem; current != ld->in(MemNode::Memory); current = current->in(MemNode::Memory)) {\n-      assert(current->is_Mem() && in_bb(current), \"unexpected memory\");\n-      assert(current != first_mem, \"corrupted memory graph\");\n-      if (!independent(current, ld)) {\n-        \/\/ A later unvectorized store depends on this load, pick the memory state of the first load. This can happen,\n-        \/\/ for example, if a load pack has interleaving stores that are part of a store pack which, however, is removed\n-        \/\/ at the pack filtering stage. This leaves us with only a load pack for which we cannot take the memory state\n-        \/\/ of the last load as the remaining unvectorized stores could interfere since they have a dependency to the loads.\n-        \/\/ Some stores could be executed before the load vector resulting in a wrong result. We need to take the\n-        \/\/ memory state of the first load to prevent this.\n-        if (my_pack(current) != nullptr && is_dependent) {\n-          \/\/ For vectorized store pack, when the load pack depends on\n-          \/\/ some memory operations locating after first_mem, we still\n-          \/\/ take the memory state of the last load.\n-          continue;\n-        }\n-        return first_mem;\n+  \/\/ (1) Set up the initial memory state from Phi. And find the old last store.\n+  for (int i = 0; i < _mem_slice_head.length(); i++) {\n+    Node* phi  = _mem_slice_head.at(i);\n+    assert(phi->is_Phi(), \"must be phi\");\n+    int alias_idx = _phase->C->get_alias_index(phi->adr_type());\n+    current_state_in_slice.at_put(alias_idx, phi);\n+\n+    \/\/ If we have a memory phi, we have a last store in the loop, find it over backedge.\n+    StoreNode* last_store = phi->in(2)->as_Store();\n+    old_last_store_in_slice.at_put(alias_idx, last_store);\n+  }\n+\n+  \/\/ (2) Walk over memops_schedule, append memops to the current state\n+  \/\/     of that slice. If it is a Store, we take it as the new state.\n+  for (uint i = 0; i < memops_schedule.size(); i++) {\n+    MemNode* n = memops_schedule.at(i)->as_Mem();\n+    assert(n->is_Load() || n->is_Store(), \"only loads or stores\");\n+    int alias_idx = _phase->C->get_alias_index(n->adr_type());\n+    Node* current_state = current_state_in_slice.at(alias_idx);\n+    if (current_state == nullptr) {\n+      \/\/ If there are only loads in a slice, we never update the memory\n+      \/\/ state in the loop, hence there is no phi for the memory state.\n+      \/\/ We just keep the old memory state that was outside the loop.\n+      assert(n->is_Load() && !in_bb(n->in(MemNode::Memory)),\n+             \"only loads can have memory state from outside loop\");\n+    } else {\n+      _igvn.replace_input_of(n, MemNode::Memory, current_state);\n+      if (n->is_Store()) {\n+        current_state_in_slice.at_put(alias_idx, n);\n@@ -2787,2 +2660,0 @@\n-  return last_mem;\n-}\n@@ -2790,13 +2661,23 @@\n-\/\/ Walk the memory graph from the current first load until the\n-\/\/ start of the loop and check if nodes on the way are memory\n-\/\/ edges of loads in the pack. The last one we encounter is the\n-\/\/ first load.\n-Node* SuperWord::find_first_mem_state(Node_List* pk) {\n-  Node* first_mem = pk->at(0)->in(MemNode::Memory);\n-  for (Node* current = first_mem; in_bb(current); current = current->is_Phi() ? current->in(LoopNode::EntryControl) : current->in(MemNode::Memory)) {\n-    assert(current->is_Mem() || (current->is_Phi() && current->in(0) == bb()), \"unexpected memory\");\n-    for (uint i = 1; i < pk->size(); i++) {\n-      Node* ld = pk->at(i);\n-      if (ld->in(MemNode::Memory) == current) {\n-        first_mem = current;\n-        break;\n+  \/\/ (3) For each slice, we add the current state to the backedge\n+  \/\/     in the Phi. Further, we replace uses of the old last store\n+  \/\/     with uses of the new last store (current_state).\n+  Node_List uses_after_loop;\n+  for (int i = 0; i < _mem_slice_head.length(); i++) {\n+    Node* phi  = _mem_slice_head.at(i);\n+    int alias_idx = _phase->C->get_alias_index(phi->adr_type());\n+    Node* current_state = current_state_in_slice.at(alias_idx);\n+    assert(current_state != nullptr, \"slice is mapped\");\n+    assert(current_state != phi, \"did some work in between\");\n+    assert(current_state->is_Store(), \"sanity\");\n+    _igvn.replace_input_of(phi, 2, current_state);\n+\n+    \/\/ Replace uses of old last store with current_state (new last store)\n+    \/\/ Do it in two loops: first find all the uses, and change the graph\n+    \/\/ in as second loop so that we do not break the iterator.\n+    Node* last_store = old_last_store_in_slice.at(alias_idx);\n+    assert(last_store != nullptr, \"we have a old last store\");\n+    uses_after_loop.clear();\n+    for (DUIterator_Fast kmax, k = last_store->fast_outs(kmax); k < kmax; k++) {\n+      Node* use = last_store->fast_out(k);\n+      if (!in_bb(use)) {\n+        uses_after_loop.push(use);\n@@ -2805,21 +2686,7 @@\n-  }\n-  return first_mem;\n-}\n-\n-\/\/ Find the last load by going over the pack again and walking\n-\/\/ the memory graph from the loads of the pack to the memory of\n-\/\/ the first load. If we encounter the memory of the current last\n-\/\/ load, then we started from further down in the memory graph and\n-\/\/ the load we started from is the last load. At the same time, the\n-\/\/ function also helps determine if some loads in the pack depend on\n-\/\/ early memory operations which locate after first_mem.\n-Node* SuperWord::find_last_mem_state(Node_List* pk, Node* first_mem, bool &is_dependent) {\n-  Node* last_mem = pk->at(0)->in(MemNode::Memory);\n-  for (uint i = 0; i < pk->size(); i++) {\n-    Node* ld = pk->at(i);\n-    for (Node* current = ld->in(MemNode::Memory); current != first_mem; current = current->in(MemNode::Memory)) {\n-      assert(current->is_Mem() && in_bb(current), \"unexpected memory\");\n-      \/\/ Determine if the load pack is dependent on some memory operations locating after first_mem.\n-      is_dependent |= !independent(current, ld);\n-      if (current->in(MemNode::Memory) == last_mem) {\n-        last_mem = ld->in(MemNode::Memory);\n+    for (uint k = 0; k < uses_after_loop.size(); k++) {\n+      Node* use = uses_after_loop.at(k);\n+      for (uint j = 0; j < use->req(); j++) {\n+        Node* def = use->in(j);\n+        if (def == last_store) {\n+          _igvn.replace_input_of(use, j, current_state);\n+        }\n@@ -2829,1 +2696,0 @@\n-  return last_mem;\n@@ -2902,1 +2768,5 @@\n-    if (p && n == executed_last(p)) {\n+    if (p != nullptr && n == p->at(p->size()-1)) {\n+      \/\/ After schedule_reorder_memops, we know that the memops have the same order in the pack\n+      \/\/ as in the memory slice. Hence, \"first\" is the first memop in the slice from the pack,\n+      \/\/ and \"n\" is the last node in the slice from the pack.\n+      Node* first = p->at(0);\n@@ -2906,2 +2776,0 @@\n-      Node* low_adr = p->at(0);\n-      Node* first   = executed_first(p);\n@@ -2931,1 +2799,1 @@\n-        Node* adr = low_adr->in(MemNode::Address);\n+        Node* adr = first->in(MemNode::Address);\n@@ -2954,1 +2822,1 @@\n-        Node* adr = low_adr->in(MemNode::Address);\n+        Node* adr = first->in(MemNode::Address);\n@@ -2965,2 +2833,2 @@\n-        Node* in1 = low_adr->in(1);\n-        Node* in2 = p->at(0)->in(2);\n+        Node* in1 = first->in(1);\n+        Node* in2 = first->in(2);\n@@ -2975,1 +2843,1 @@\n-        Node* in2 = low_adr->in(2);\n+        Node* in2 = first->in(2);\n@@ -2998,1 +2866,1 @@\n-          in1 = low_adr->in(1);\n+          in1 = first->in(1);\n@@ -3066,1 +2934,1 @@\n-        _phase->set_ctrl(longval, _phase->get_ctrl(p->at(0)));\n+        _phase->set_ctrl(longval, _phase->get_ctrl(first));\n@@ -3181,1 +3049,1 @@\n-      _phase->set_ctrl(vn, _phase->get_ctrl(p->at(0)));\n+      _phase->set_ctrl(vn, _phase->get_ctrl(first));\n@@ -4061,11 +3929,0 @@\n-\/\/------------------------------in_pack---------------------------\n-\/\/ Is s in pack p?\n-Node_List* SuperWord::in_pack(Node* s, Node_List* p) {\n-  for (uint i = 0; i < p->size(); i++) {\n-    if (p->at(i) == s) {\n-      return p;\n-    }\n-  }\n-  return nullptr;\n-}\n-\n@@ -4104,33 +3961,0 @@\n-\/\/------------------------------executed_first---------------------------\n-\/\/ Return the node executed first in pack p.  Uses the RPO block list\n-\/\/ to determine order.\n-Node* SuperWord::executed_first(Node_List* p) {\n-  Node* n = p->at(0);\n-  int n_rpo = bb_idx(n);\n-  for (uint i = 1; i < p->size(); i++) {\n-    Node* s = p->at(i);\n-    int s_rpo = bb_idx(s);\n-    if (s_rpo < n_rpo) {\n-      n = s;\n-      n_rpo = s_rpo;\n-    }\n-  }\n-  return n;\n-}\n-\n-\/\/------------------------------executed_last---------------------------\n-\/\/ Return the node executed last in pack p.\n-Node* SuperWord::executed_last(Node_List* p) {\n-  Node* n = p->at(0);\n-  int n_rpo = bb_idx(n);\n-  for (uint i = 1; i < p->size(); i++) {\n-    Node* s = p->at(i);\n-    int s_rpo = bb_idx(s);\n-    if (s_rpo > n_rpo) {\n-      n = s;\n-      n_rpo = s_rpo;\n-    }\n-  }\n-  return n;\n-}\n-\n@@ -4416,10 +4240,0 @@\n-\/\/------------------------------blank---------------------------\n-char* SuperWord::blank(uint depth) {\n-  static char blanks[101];\n-  assert(depth < 101, \"too deep\");\n-  for (uint i = 0; i < depth; i++) blanks[i] = ' ';\n-  blanks[depth] = '\\0';\n-  return blanks;\n-}\n-\n-\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":158,"deletions":344,"binary":false,"changes":502,"status":"modified"},{"patch":"@@ -459,0 +459,1 @@\n+ public:\n@@ -460,0 +461,1 @@\n+ private:\n@@ -563,2 +565,0 @@\n-  \/\/ Remove cycles in packset.\n-  void remove_cycles();\n@@ -567,9 +567,2 @@\n-  \/\/ Remove \"current\" from its current position in the memory graph and insert\n-  \/\/ it after the appropriate insert points (lip or uip);\n-  void remove_and_insert(MemNode *current, MemNode *prev, MemNode *lip, Node *uip, Unique_Node_List &schd_before);\n-  \/\/ Within a store pack, schedule stores together by moving out the sandwiched memory ops according\n-  \/\/ to dependence info; and within a load pack, move loads down to the last executed load.\n-  void co_locate_pack(Node_List* p);\n-  Node* pick_mem_state(Node_List* pk);\n-  Node* find_first_mem_state(Node_List* pk);\n-  Node* find_last_mem_state(Node_List* pk, Node* first_mem, bool &is_dependent);\n+  \/\/ Helper function for schedule, that reorders all memops, slice by slice, according to the schedule\n+  void schedule_reorder_memops(Node_List &memops_schedule);\n@@ -607,2 +600,0 @@\n-  \/\/ Is s in pack p?\n-  Node_List* in_pack(Node* s, Node_List* p);\n@@ -611,4 +602,0 @@\n-  \/\/ Return the node executed first in pack p.\n-  Node* executed_first(Node_List* p);\n-  \/\/ Return the node executed last in pack p.\n-  Node* executed_last(Node_List* p);\n@@ -618,2 +605,0 @@\n-  \/\/ (Start, end] half-open range defining which operands are vector\n-  void vector_opd_range(Node* n, uint* start, uint* end);\n@@ -638,1 +623,0 @@\n-  char* blank(uint depth);\n","filename":"src\/hotspot\/share\/opto\/superword.hpp","additions":4,"deletions":20,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n- * @requires vm.compiler2.enabled\n@@ -32,1 +31,1 @@\n- * @requires vm.cpu.features ~= \".*avx2.*\" | vm.cpu.features ~= \".*asimd.*\"\n+ * @requires vm.compiler2.enabled\n@@ -97,2 +96,2 @@\n-\/\/        init(goldI5, goldF5);\n-\/\/        test5(goldI5, goldI5, goldF5, goldF5);\n+        init(goldI5, goldF5);\n+        test5(goldI5, goldI5, goldF5, goldF5);\n@@ -235,23 +234,21 @@\n-\/\/ TODO uncomment after fixing JDK-8304720\n-\/\/\n-\/\/    @Run(test = \"test5\")\n-\/\/    public void runTest5() {\n-\/\/        int[] dataI = new int[RANGE];\n-\/\/        float[] dataF = new float[RANGE];\n-\/\/        init(dataI, dataF);\n-\/\/        test5(dataI, dataI, dataF, dataF);\n-\/\/        verify(\"test5\", dataI, goldI5);\n-\/\/        verify(\"test5\", dataF, goldF5);\n-\/\/    }\n-\/\/\n-\/\/    @Test\n-\/\/    static void test5(int[] dataIa, int[] dataIb, float[] dataFa, float[] dataFb) {\n-\/\/        for (int i = 0; i < RANGE; i+=2) {\n-\/\/            \/\/ same as test2, except that reordering leads to different semantics\n-\/\/            \/\/ explanation analogue to test4\n-\/\/            unsafe.putInt(dataFa, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4 * i + 0, dataIa[i+0] + 1); \/\/ A\n-\/\/            dataIb[i+0] = 11 * unsafe.getInt(dataFb, unsafe.ARRAY_INT_BASE_OFFSET + 4 * i + 0); \/\/ X\n-\/\/            dataIb[i+1] = 11 * unsafe.getInt(dataFb, unsafe.ARRAY_INT_BASE_OFFSET + 4 * i + 4); \/\/ Y\n-\/\/            unsafe.putInt(dataFa, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4 * i + 4, dataIa[i+1] + 1); \/\/ B\n-\/\/        }\n-\/\/    }\n+    @Run(test = \"test5\")\n+    public void runTest5() {\n+        int[] dataI = new int[RANGE];\n+        float[] dataF = new float[RANGE];\n+        init(dataI, dataF);\n+        test5(dataI, dataI, dataF, dataF);\n+        verify(\"test5\", dataI, goldI5);\n+        verify(\"test5\", dataF, goldF5);\n+    }\n+\n+    @Test\n+    static void test5(int[] dataIa, int[] dataIb, float[] dataFa, float[] dataFb) {\n+        for (int i = 0; i < RANGE; i+=2) {\n+            \/\/ same as test2, except that reordering leads to different semantics\n+            \/\/ explanation analogue to test4\n+            unsafe.putInt(dataFa, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4 * i + 0, dataIa[i+0] + 1); \/\/ A\n+            dataIb[i+0] = 11 * unsafe.getInt(dataFb, unsafe.ARRAY_INT_BASE_OFFSET + 4 * i + 0); \/\/ X\n+            dataIb[i+1] = 11 * unsafe.getInt(dataFb, unsafe.ARRAY_INT_BASE_OFFSET + 4 * i + 4); \/\/ Y\n+            unsafe.putInt(dataFa, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4 * i + 4, dataIa[i+1] + 1); \/\/ B\n+        }\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestIndependentPacksWithCyclicDependency.java","additions":24,"deletions":27,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -32,2 +32,0 @@\n- * @requires vm.bits == 64\n- * @requires vm.cpu.features ~= \".*avx2.*\" | vm.cpu.features ~= \".*asimd.*\"\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestIndependentPacksWithCyclicDependency2.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,159 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\n+\/*\n+ * @test\n+ * @bug 8304720\n+ * @summary Test some examples where non-vectorized memops also need to\n+ *          be reordered during SuperWord::schedule.\n+ * @requires vm.compiler2.enabled\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ * @run driver compiler.loopopts.superword.TestScheduleReordersScalarMemops\n+ *\/\n+\n+package compiler.loopopts.superword;\n+\n+import jdk.internal.misc.Unsafe;\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+\n+public class TestScheduleReordersScalarMemops {\n+    static final int RANGE = 1024;\n+    static final int ITER  = 10_000;\n+    static Unsafe unsafe = Unsafe.getUnsafe();\n+\n+    int[]   goldI0 = new int[RANGE];\n+    float[] goldF0 = new float[RANGE];\n+    int[]   goldI1 = new int[RANGE];\n+    float[] goldF1 = new float[RANGE];\n+\n+    public static void main(String args[]) {\n+        TestFramework.runWithFlags(\"--add-modules\", \"java.base\", \"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\",\n+                                   \"-XX:CompileCommand=compileonly,compiler.loopopts.superword.TestScheduleReordersScalarMemops::test*\",\n+                                   \"-XX:CompileCommand=compileonly,compiler.loopopts.superword.TestScheduleReordersScalarMemops::verify\",\n+                                   \"-XX:CompileCommand=compileonly,compiler.loopopts.superword.TestScheduleReordersScalarMemops::init\",\n+                                   \"-XX:LoopUnrollLimit=1000\",\n+                                   \"-XX:-TieredCompilation\", \"-Xbatch\");\n+    }\n+\n+    TestScheduleReordersScalarMemops() {\n+        \/\/ compute the gold standard in interpreter mode\n+        init(goldI0, goldF0);\n+        test0(goldI0, goldI0, goldF0, goldF0);\n+        init(goldI1, goldF1);\n+        test1(goldI1, goldI1, goldF1, goldF1);\n+    }\n+\n+    @Run(test = \"test0\")\n+    @Warmup(100)\n+    public void runTest0() {\n+        int[] dataI = new int[RANGE];\n+        float[] dataF = new float[RANGE];\n+        init(dataI, dataF);\n+        test0(dataI, dataI, dataF, dataF);\n+        verify(\"test0\", dataI, goldI0);\n+        verify(\"test0\", dataF, goldF0);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL_VI, \"> 0\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+    static void test0(int[] dataIa, int[] dataIb, float[] dataFa, float[] dataFb) {\n+        for (int i = 0; i < RANGE; i+=2) {\n+            \/\/ We have dependency edges:\n+            \/\/  A -> X\n+            \/\/  Y -> B\n+            \/\/ Still, we can vectorize [X,Y].\n+            \/\/ We do not vectorize A and B, because they are not isomorphic (add vs mul).\n+            \/\/\n+            \/\/ Imagine this is unrolled at least 2x.\n+            \/\/ We get order: A0 X0 Y0 B0 A1 X1 Y1 B1\n+            \/\/ Vectorized:      X0 Y0       X1 Y1\n+            \/\/ Scalar:       A0       B0 A1       B1\n+            \/\/\n+            \/\/ However, since the As need to be before, and the Bs after the vector operations,\n+            \/\/ we need to have all As before all Bs. This means we need to reorder the scalar\n+            \/\/ operations, and not just the vectorized ones.\n+            \/\/\n+            \/\/ A correct reordering would be: A0 A1 [X0, Y0, X1, Y1] B0 B1\n+            \/\/\n+            dataFa[i + 0] = dataIa[i + 0] * 1.3f;     \/\/ A *1.3\n+            dataIb[i + 0] = (int)dataFb[i + 0] * 11;  \/\/ X *11\n+            dataIb[i + 1] = (int)dataFb[i + 1] * 11;  \/\/ Y *11\n+            dataFa[i + 1] = dataIa[i + 1] + 1.2f;     \/\/ B +1.2\n+        }\n+    }\n+\n+    @Run(test = \"test1\")\n+    @Warmup(100)\n+    public void runTest1() {\n+        int[] dataI = new int[RANGE];\n+        float[] dataF = new float[RANGE];\n+        init(dataI, dataF);\n+        test1(dataI, dataI, dataF, dataF);\n+        verify(\"test1\", dataI, goldI1);\n+        verify(\"test1\", dataF, goldF1);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MUL_VI, \"> 0\"},\n+        applyIfCPUFeatureOr = {\"avx2\", \"true\", \"asimd\", \"true\"})\n+    static void test1(int[] dataIa, int[] dataIb, float[] dataFa, float[] dataFb) {\n+        for (int i = 0; i < RANGE; i+=2) {\n+            \/\/ Do the same as test0, but without int-float conversion.\n+            \/\/ This should reproduce on machines where conversion is not implemented.\n+            unsafe.putInt(dataFa, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4 * i + 0, dataIa[i+0] + 1);  \/\/ A +1\n+            dataIb[i+0] = 11 * unsafe.getInt(dataFb, unsafe.ARRAY_INT_BASE_OFFSET + 4 * i + 0);  \/\/ X\n+            dataIb[i+1] = 11 * unsafe.getInt(dataFb, unsafe.ARRAY_INT_BASE_OFFSET + 4 * i + 4);  \/\/ Y\n+            unsafe.putInt(dataFa, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4 * i + 4, dataIa[i+1] * 11); \/\/ B *11\n+        }\n+    }\n+\n+    static void init(int[] dataI, float[] dataF) {\n+        for (int i = 0; i < RANGE; i++) {\n+            dataI[i] = i + 1;\n+            dataF[i] = i + 0.1f;\n+        }\n+    }\n+\n+    static void verify(String name, int[] data, int[] gold) {\n+        for (int i = 0; i < RANGE; i++) {\n+            if (data[i] != gold[i]) {\n+                throw new RuntimeException(\" Invalid \" + name + \" result: data[\" + i + \"]: \" + data[i] + \" != \" + gold[i]);\n+            }\n+        }\n+    }\n+\n+    static void verify(String name, float[] data, float[] gold) {\n+        for (int i = 0; i < RANGE; i++) {\n+            int datav = unsafe.getInt(data, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4 * i);\n+            int goldv = unsafe.getInt(gold, unsafe.ARRAY_FLOAT_BASE_OFFSET + 4 * i);\n+            if (datav != goldv) {\n+                throw new RuntimeException(\" Invalid \" + name + \" result: dataF[\" + i + \"]: \" + datav + \" != \" + goldv);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestScheduleReordersScalarMemops.java","additions":159,"deletions":0,"binary":false,"changes":159,"status":"added"}]}