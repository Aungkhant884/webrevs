{"files":[{"patch":"@@ -29,1 +29,2 @@\n- * Data structure to hold info from \/proc\/self\/cgroup\n+ * Data structure to hold info from \/proc\/self\/cgroup,\n+ * \/proc\/cgroups and \/proc\/self\/mountinfo\n@@ -35,1 +36,1 @@\n-class CgroupInfo {\n+public class CgroupInfo {\n@@ -40,0 +41,3 @@\n+    private String mountPoint;\n+    private String mountRoot;\n+    private String cgroupPath;\n@@ -47,1 +51,1 @@\n-    String getName() {\n+    public String getName() {\n@@ -51,1 +55,1 @@\n-    int getHierarchyId() {\n+    public int getHierarchyId() {\n@@ -55,1 +59,1 @@\n-    boolean isEnabled() {\n+    public boolean isEnabled() {\n@@ -59,0 +63,24 @@\n+    public String getMountPoint() {\n+        return mountPoint;\n+    }\n+\n+    public void setMountPoint(String mountPoint) {\n+        this.mountPoint = mountPoint;\n+    }\n+\n+    public String getMountRoot() {\n+        return mountRoot;\n+    }\n+\n+    public void setMountRoot(String mountRoot) {\n+        this.mountRoot = mountRoot;\n+    }\n+\n+    public String getCgroupPath() {\n+        return cgroupPath;\n+    }\n+\n+    public void setCgroupPath(String cgroupPath) {\n+        this.cgroupPath = cgroupPath;\n+    }\n+\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/CgroupInfo.java","additions":33,"deletions":5,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.io.UncheckedIOException;\n@@ -31,0 +32,1 @@\n+import java.nio.file.Path;\n@@ -32,0 +34,1 @@\n+import java.util.Collections;\n@@ -36,0 +39,1 @@\n+import java.util.function.Consumer;\n@@ -71,1 +75,1 @@\n-        \"[^\\\\s]+\\\\s+([^\\\\s]+)\\\\s+\" +           \/\/ (4), (5)     - group 1: mount point\n+        \"([^\\\\s]+)\\\\s+([^\\\\s]+)\\\\s+\" +         \/\/ (4), (5)     - group 1, 2: root, mount point\n@@ -73,1 +77,1 @@\n-        \"([^\\\\s]+)\\\\s+\" +                      \/\/ (9)          - group 2: filesystem type\n+        \"([^\\\\s]+)\\\\s+\" +                      \/\/ (9)          - group 3: filesystem type\n@@ -79,1 +83,1 @@\n-            optResult = determineType(\"\/proc\/self\/mountinfo\", \"\/proc\/cgroups\");\n+            optResult = determineType(\"\/proc\/self\/mountinfo\", \"\/proc\/cgroups\", \"\/proc\/self\/cgroup\");\n@@ -82,0 +86,2 @@\n+        } catch (UncheckedIOException e) {\n+            return null;\n@@ -103,0 +109,1 @@\n+        Map<String, CgroupInfo> infos = result.getInfos();\n@@ -104,1 +111,3 @@\n-            CgroupSubsystem subsystem = CgroupV2Subsystem.getInstance();\n+            \/\/ For unified it doesn't matter which controller we pick.\n+            CgroupInfo anyController = infos.get(MEMORY_CTRL);\n+            CgroupSubsystem subsystem = CgroupV2Subsystem.getInstance(anyController);\n@@ -107,1 +116,1 @@\n-            CgroupV1Subsystem subsystem = CgroupV1Subsystem.getInstance();\n+            CgroupV1Subsystem subsystem = CgroupV1Subsystem.getInstance(infos);\n@@ -112,2 +121,4 @@\n-    public static Optional<CgroupTypeResult> determineType(String mountInfo, String cgroups) throws IOException {\n-        Map<String, CgroupInfo> infos = new HashMap<>();\n+    public static Optional<CgroupTypeResult> determineType(String mountInfo,\n+                                                           String cgroups,\n+                                                           String selfCgroup) throws IOException {\n+        final Map<String, CgroupInfo> infos = new HashMap<>();\n@@ -149,4 +160,15 @@\n-        try (Stream<String> mntInfo = CgroupUtil.readFilePrivileged(Paths.get(mountInfo))) {\n-            boolean anyCgroupMounted = mntInfo.anyMatch(CgroupSubsystemFactory::isRelevantControllerMount);\n-            if (!anyCgroupMounted && isCgroupsV2) {\n-                return Optional.empty();\n+        lines = CgroupUtil.readAllLinesPrivileged(Paths.get(mountInfo));\n+        boolean anyCgroupMounted = false;\n+        for (String line: lines) {\n+            boolean cgroupsControllerFound = amendCgroupInfos(line, infos, isCgroupsV2);\n+            anyCgroupMounted = anyCgroupMounted || cgroupsControllerFound;\n+        }\n+        if (!anyCgroupMounted) {\n+            return Optional.empty();\n+        }\n+\n+        try (Stream<String> selfCgroupLines =\n+             CgroupUtil.readFilePrivileged(Paths.get(selfCgroup))) {\n+            Consumer<String[]> action = (tokens -> setCgroupV1Path(infos, tokens));\n+            if (isCgroupsV2) {\n+                action = (tokens -> setCgroupV2Path(infos, tokens));\n@@ -154,0 +176,3 @@\n+            selfCgroupLines.map(line -> line.split(\":\"))\n+                     .filter(tokens -> (tokens.length >= 3))\n+                     .forEach(action);\n@@ -155,1 +180,6 @@\n-        CgroupTypeResult result = new CgroupTypeResult(isCgroupsV2, anyControllersEnabled, anyCgroupsV2Controller, anyCgroupsV1Controller);\n+\n+        CgroupTypeResult result = new CgroupTypeResult(isCgroupsV2,\n+                                                       anyControllersEnabled,\n+                                                       anyCgroupsV2Controller,\n+                                                       anyCgroupsV1Controller,\n+                                                       Collections.unmodifiableMap(infos));\n@@ -159,23 +189,103 @@\n-    private static boolean isRelevantControllerMount(String line) {\n-         Matcher lineMatcher = MOUNTINFO_PATTERN.matcher(line.trim());\n-         if (lineMatcher.matches()) {\n-             String mountPoint = lineMatcher.group(1);\n-             String fsType = lineMatcher.group(2);\n-             if (fsType.equals(\"cgroup\")) {\n-                 String filename = Paths.get(mountPoint).getFileName().toString();\n-                 for (String fn: filename.split(\",\")) {\n-                     switch (fn) {\n-                         case MEMORY_CTRL: \/\/ fall through\n-                         case CPU_CTRL:\n-                         case CPUSET_CTRL:\n-                         case CPUACCT_CTRL:\n-                         case BLKIO_CTRL:\n-                             return true;\n-                         default: break; \/\/ ignore not recognized controllers\n-                     }\n-                 }\n-             } else if (fsType.equals(\"cgroup2\")) {\n-                 return true;\n-             }\n-         }\n-         return false;\n+    private static void setCgroupV2Path(Map<String, CgroupInfo> infos,\n+                                        String[] tokens) {\n+        int hierarchyId = Integer.parseInt(tokens[0]);\n+        String cgroupPath = tokens[2];\n+        for (CgroupInfo info: infos.values()) {\n+            assert hierarchyId == info.getHierarchyId() && hierarchyId == 0;\n+            info.setCgroupPath(cgroupPath);\n+        }\n+    }\n+\n+    private static void setCgroupV1Path(Map<String, CgroupInfo> infos,\n+                                        String[] tokens) {\n+        String controllerName = tokens[1];\n+        String cgroupPath = tokens[2];\n+        if (controllerName != null && cgroupPath != null) {\n+            for (String cName: controllerName.split(\",\")) {\n+                switch (cName) {\n+                    case MEMORY_CTRL: \/\/ fall through\n+                    case CPUSET_CTRL:\n+                    case CPUACCT_CTRL:\n+                    case CPU_CTRL:\n+                    case BLKIO_CTRL:\n+                        CgroupInfo info = infos.get(cName);\n+                        info.setCgroupPath(cgroupPath);\n+                        break;\n+                    \/\/ Ignore not recognized controllers\n+                    default:\n+                        break;\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Amends cgroup infos with mount path and mount root.\n+     *\n+     * @return {@code true} iff a relevant controller has been found at the\n+     * given line\n+     *\/\n+    private static boolean amendCgroupInfos(String mntInfoLine,\n+                                            Map<String, CgroupInfo> infos,\n+                                            boolean isCgroupsV2) {\n+        Matcher lineMatcher = MOUNTINFO_PATTERN.matcher(mntInfoLine.trim());\n+        boolean cgroupv1ControllerFound = false;\n+        boolean cgroupv2ControllerFound = false;\n+        if (lineMatcher.matches()) {\n+            String mountRoot = lineMatcher.group(1);\n+            String mountPath = lineMatcher.group(2);\n+            String fsType = lineMatcher.group(3);\n+            if (fsType.equals(\"cgroup\")) {\n+                Path p = Paths.get(mountPath);\n+                String[] controllerNames = p.getFileName().toString().split(\",\");\n+                for (String controllerName: controllerNames) {\n+                    switch (controllerName) {\n+                        case MEMORY_CTRL: \/\/ fall-through\n+                        case CPU_CTRL:\n+                        case CPUACCT_CTRL:\n+                        case BLKIO_CTRL: {\n+                            CgroupInfo info = infos.get(controllerName);\n+                            assert info.getMountPoint() == null;\n+                            assert info.getMountRoot() == null;\n+                            info.setMountPoint(mountPath);\n+                            info.setMountRoot(mountRoot);\n+                            cgroupv1ControllerFound = true;\n+                            break;\n+                        }\n+                        case CPUSET_CTRL: {\n+                            CgroupInfo info = infos.get(controllerName);\n+                            if (info.getMountPoint() != null) {\n+                                \/\/ On some systems duplicate cpuset controllers get mounted in addition to\n+                                \/\/ the main cgroup controllers most likely under \/sys\/fs\/cgroup. In that\n+                                \/\/ case pick the one under \/sys\/fs\/cgroup and discard others.\n+                                if (!info.getMountPoint().startsWith(\"\/sys\/fs\/cgroup\")) {\n+                                    info.setMountPoint(mountPath);\n+                                    info.setMountRoot(mountRoot);\n+                                }\n+                            } else {\n+                                info.setMountPoint(mountPath);\n+                                info.setMountRoot(mountRoot);\n+                            }\n+                            cgroupv1ControllerFound = true;\n+                            break;\n+                        }\n+                        default:\n+                            \/\/ Ignore controllers which we don't recognize\n+                            break;\n+                    }\n+                }\n+            } else if (fsType.equals(\"cgroup2\")) {\n+                if (isCgroupsV2) { \/\/ will be false for hybrid\n+                    \/\/ All controllers have the same mount point and root mount\n+                    \/\/ for unified hierarchy.\n+                    for (CgroupInfo info: infos.values()) {\n+                        assert info.getMountPoint() == null;\n+                        assert info.getMountRoot() == null;\n+                        info.setMountPoint(mountPath);\n+                        info.setMountRoot(mountRoot);\n+                    }\n+                }\n+                cgroupv2ControllerFound = true;\n+            }\n+        }\n+        return cgroupv1ControllerFound || cgroupv2ControllerFound;\n@@ -189,0 +299,1 @@\n+        private final Map<String, CgroupInfo> infos;\n@@ -193,1 +304,2 @@\n-                                 boolean anyCgroupV1Controllers) {\n+                                 boolean anyCgroupV1Controllers,\n+                                 Map<String, CgroupInfo> infos) {\n@@ -198,0 +310,1 @@\n+            this.infos = infos;\n@@ -215,0 +328,4 @@\n+\n+        public Map<String, CgroupInfo> getInfos() {\n+            return infos;\n+        }\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/CgroupSubsystemFactory.java","additions":153,"deletions":36,"binary":false,"changes":189,"status":"modified"},{"patch":"@@ -28,5 +28,1 @@\n-import java.io.IOException;\n-import java.io.UncheckedIOException;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.util.stream.Stream;\n+import java.util.Map;\n@@ -34,0 +30,1 @@\n+import jdk.internal.platform.CgroupInfo;\n@@ -36,1 +33,0 @@\n-import jdk.internal.platform.CgroupUtil;\n@@ -45,1 +41,0 @@\n-    private boolean activeSubSystems;\n@@ -47,1 +42,1 @@\n-    private static final CgroupV1Subsystem INSTANCE = initSubSystem();\n+    private static volatile CgroupV1Subsystem INSTANCE;\n@@ -51,3 +46,1 @@\n-    private CgroupV1Subsystem() {\n-        activeSubSystems = false;\n-    }\n+    private CgroupV1Subsystem() {}\n@@ -55,1 +48,8 @@\n-    public static CgroupV1Subsystem getInstance() {\n+    public static CgroupV1Subsystem getInstance(Map<String, CgroupInfo> infos) {\n+        if (INSTANCE == null) {\n+            synchronized (CgroupV1Subsystem.class) {\n+                if (INSTANCE == null) {\n+                    INSTANCE = initSubSystem(infos);\n+                }\n+            }\n+        }\n@@ -59,1 +59,1 @@\n-    private static CgroupV1Subsystem initSubSystem() {\n+    private static CgroupV1Subsystem initSubSystem(Map<String, CgroupInfo> infos) {\n@@ -62,0 +62,1 @@\n+        boolean anyActiveControllers = false;\n@@ -64,43 +65,1 @@\n-         * by reading \/proc\/self\/mountinfo\n-         *\n-         * Example for docker MemorySubSystem subsystem:\n-         * 219 214 0:29 \/docker\/7208cebd00fa5f2e342b1094f7bed87fa25661471a4637118e65f1c995be8a34 \/sys\/fs\/cgroup\/MemorySubSystem ro,nosuid,nodev,noexec,relatime - cgroup cgroup rw,MemorySubSystem\n-         *\n-         * Example for host:\n-         * 34 28 0:29 \/ \/sys\/fs\/cgroup\/MemorySubSystem rw,nosuid,nodev,noexec,relatime shared:16 - cgroup cgroup rw,MemorySubSystem\n-         *\/\n-        try (Stream<String> lines =\n-                CgroupUtil.readFilePrivileged(Paths.get(\"\/proc\/self\/mountinfo\"))) {\n-\n-            lines.filter(line -> line.contains(\" - cgroup \"))\n-                 .map(line -> line.split(\" \"))\n-                 .forEach(entry -> createSubSystemController(subsystem, entry));\n-\n-        } catch (UncheckedIOException e) {\n-            return null;\n-        } catch (IOException e) {\n-            return null;\n-        }\n-\n-        \/**\n-         * Read \/proc\/self\/cgroup and map host mount point to\n-         * local one via \/proc\/self\/mountinfo content above\n-         *\n-         * Docker example:\n-         * 5:memory:\/docker\/6558aed8fc662b194323ceab5b964f69cf36b3e8af877a14b80256e93aecb044\n-         *\n-         * Host example:\n-         * 5:memory:\/user.slice\n-         *\n-         * Construct a path to the process specific memory and cpuset\n-         * cgroup directory.\n-         *\n-         * For a container running under Docker from memory example above\n-         * the paths would be:\n-         *\n-         * \/sys\/fs\/cgroup\/memory\n-         *\n-         * For a Host from memory example above the path would be:\n-         *\n-         * \/sys\/fs\/cgroup\/memory\/user.slice\n-         *\n+         * by looking up relevant data in the infos map\n@@ -108,11 +67,54 @@\n-        try (Stream<String> lines =\n-                CgroupUtil.readFilePrivileged(Paths.get(\"\/proc\/self\/cgroup\"))) {\n-\n-            lines.map(line -> line.split(\":\"))\n-                 .filter(line -> (line.length >= 3))\n-                 .forEach(line -> setSubSystemControllerPath(subsystem, line));\n-\n-        } catch (UncheckedIOException e) {\n-            return null;\n-        } catch (IOException e) {\n-            return null;\n+        for (CgroupInfo info: infos.values()) {\n+            switch (info.getName()) {\n+            case \"memory\": {\n+                if (info.getMountRoot() != null && info.getMountPoint() != null) {\n+                    CgroupV1MemorySubSystemController controller = new CgroupV1MemorySubSystemController(info.getMountRoot(), info.getMountPoint());\n+                    controller.setPath(info.getCgroupPath());\n+                    boolean isHierarchial = getHierarchical(controller);\n+                    controller.setHierarchical(isHierarchial);\n+                    boolean isSwapEnabled = getSwapEnabled(controller);\n+                    controller.setSwapEnabled(isSwapEnabled);\n+                    subsystem.setMemorySubSystem(controller);\n+                    anyActiveControllers = true;\n+                }\n+                break;\n+            }\n+            case \"cpuset\": {\n+                if (info.getMountRoot() != null && info.getMountPoint() != null) {\n+                    CgroupV1SubsystemController controller = new CgroupV1SubsystemController(info.getMountRoot(), info.getMountPoint());\n+                    controller.setPath(info.getCgroupPath());\n+                    subsystem.setCpuSetController(controller);\n+                    anyActiveControllers = true;\n+                }\n+                break;\n+            }\n+            case \"cpuacct\": {\n+                if (info.getMountRoot() != null && info.getMountPoint() != null) {\n+                    CgroupV1SubsystemController controller = new CgroupV1SubsystemController(info.getMountRoot(), info.getMountPoint());\n+                    controller.setPath(info.getCgroupPath());\n+                    subsystem.setCpuAcctController(controller);\n+                    anyActiveControllers = true;\n+                }\n+                break;\n+            }\n+            case \"cpu\": {\n+                if (info.getMountRoot() != null && info.getMountPoint() != null) {\n+                    CgroupV1SubsystemController controller = new CgroupV1SubsystemController(info.getMountRoot(), info.getMountPoint());\n+                    controller.setPath(info.getCgroupPath());\n+                    subsystem.setCpuController(controller);\n+                    anyActiveControllers = true;\n+                }\n+                break;\n+            }\n+            case \"blkio\": {\n+                if (info.getMountRoot() != null && info.getMountPoint() != null) {\n+                    CgroupV1SubsystemController controller = new CgroupV1SubsystemController(info.getMountRoot(), info.getMountPoint());\n+                    controller.setPath(info.getCgroupPath());\n+                    subsystem.setBlkIOController(controller);\n+                    anyActiveControllers = true;\n+                }\n+                break;\n+            }\n+            default:\n+                throw new AssertionError(\"Unrecognized controller in infos: \" + info.getName());\n+            }\n@@ -122,1 +124,1 @@\n-        if (subsystem.activeSubSystems()) {\n+        if (anyActiveControllers) {\n@@ -129,82 +131,0 @@\n-    \/**\n-     * createSubSystem objects and initialize mount points\n-     *\/\n-    private static void createSubSystemController(CgroupV1Subsystem subsystem, String[] mountentry) {\n-        if (mountentry.length < 5) return;\n-\n-        Path p = Paths.get(mountentry[4]);\n-        String[] subsystemNames = p.getFileName().toString().split(\",\");\n-\n-        for (String subsystemName: subsystemNames) {\n-            switch (subsystemName) {\n-                case \"memory\":\n-                    subsystem.setMemorySubSystem(new CgroupV1MemorySubSystemController(mountentry[3], mountentry[4]));\n-                    break;\n-                case \"cpuset\":\n-                    subsystem.setCpuSetController(new CgroupV1SubsystemController(mountentry[3], mountentry[4]));\n-                    break;\n-                case \"cpuacct\":\n-                    subsystem.setCpuAcctController(new CgroupV1SubsystemController(mountentry[3], mountentry[4]));\n-                    break;\n-                case \"cpu\":\n-                    subsystem.setCpuController(new CgroupV1SubsystemController(mountentry[3], mountentry[4]));\n-                    break;\n-                case \"blkio\":\n-                    subsystem.setBlkIOController(new CgroupV1SubsystemController(mountentry[3], mountentry[4]));\n-                    break;\n-                default:\n-                    \/\/ Ignore subsystems that we don't support\n-                    break;\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * setSubSystemPath based on the contents of \/proc\/self\/cgroup\n-     *\/\n-    private static void setSubSystemControllerPath(CgroupV1Subsystem subsystem, String[] entry) {\n-        String controllerName = entry[1];\n-        String base = entry[2];\n-\n-        if (controllerName != null && base != null) {\n-            for (String cName: controllerName.split(\",\")) {\n-                switch (cName) {\n-                    case \"memory\":\n-                        setPath(subsystem, subsystem.memoryController(), base);\n-                        break;\n-                    case \"cpuset\":\n-                        setPath(subsystem, subsystem.cpuSetController(), base);\n-                        break;\n-                    case \"cpu\":\n-                        setPath(subsystem, subsystem.cpuController(), base);\n-                        break;\n-                    case \"cpuacct\":\n-                        setPath(subsystem, subsystem.cpuAcctController(), base);\n-                        break;\n-                    case \"blkio\":\n-                        setPath(subsystem, subsystem.blkIOController(), base);\n-                        break;\n-                    \/\/ Ignore subsystems that we don't support\n-                    default:\n-                        break;\n-                }\n-            }\n-        }\n-\n-    }\n-\n-    private static void setPath(CgroupV1Subsystem subsystem, CgroupV1SubsystemController controller, String base) {\n-        if (controller != null) {\n-            controller.setPath(base);\n-            if (controller instanceof CgroupV1MemorySubSystemController) {\n-                CgroupV1MemorySubSystemController memorySubSystem = (CgroupV1MemorySubSystemController)controller;\n-                boolean isHierarchial = getHierarchical(memorySubSystem);\n-                memorySubSystem.setHierarchical(isHierarchial);\n-                boolean isSwapEnabled = getSwapEnabled(memorySubSystem);\n-                memorySubSystem.setSwapEnabled(isSwapEnabled);\n-            }\n-            subsystem.setActiveSubSystems();\n-        }\n-    }\n-\n-\n@@ -222,8 +142,0 @@\n-    private void setActiveSubSystems() {\n-        activeSubSystems = true;\n-    }\n-\n-    private boolean activeSubSystems() {\n-        return activeSubSystems;\n-    }\n-\n@@ -250,20 +162,0 @@\n-    private CgroupV1SubsystemController memoryController() {\n-        return memory;\n-    }\n-\n-    private CgroupV1SubsystemController cpuController() {\n-        return cpu;\n-    }\n-\n-    private CgroupV1SubsystemController cpuAcctController() {\n-        return cpuacct;\n-    }\n-\n-    private CgroupV1SubsystemController cpuSetController() {\n-        return cpuset;\n-    }\n-\n-    private CgroupV1SubsystemController blkIOController() {\n-        return blkio;\n-    }\n-\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/cgroupv1\/CgroupV1Subsystem.java","additions":70,"deletions":178,"binary":false,"changes":248,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.util.List;\n@@ -35,1 +34,0 @@\n-import java.util.stream.Stream;\n@@ -37,0 +35,1 @@\n+import jdk.internal.platform.CgroupInfo;\n@@ -43,1 +42,1 @@\n-    private static final CgroupV2Subsystem INSTANCE = initSubsystem();\n+    private static volatile CgroupV2Subsystem INSTANCE;\n@@ -63,26 +62,8 @@\n-    private static CgroupV2Subsystem initSubsystem() {\n-        \/\/ read mountinfo so as to determine root mount path\n-        String mountPath = null;\n-        try (Stream<String> lines =\n-                CgroupUtil.readFilePrivileged(Paths.get(\"\/proc\/self\/mountinfo\"))) {\n-\n-            String l = lines.filter(line -> line.contains(\" - cgroup2 \"))\n-                            .collect(Collectors.joining());\n-            String[] tokens = l.split(\" \");\n-            mountPath = tokens[4];\n-        } catch (UncheckedIOException e) {\n-            return null;\n-        } catch (IOException e) {\n-            return null;\n-        }\n-        String cgroupPath = null;\n-        try {\n-            List<String> lines = CgroupUtil.readAllLinesPrivileged(Paths.get(\"\/proc\/self\/cgroup\"));\n-            for (String line: lines) {\n-                String[] tokens = line.split(\":\");\n-                if (tokens.length != 3) {\n-                    return null; \/\/ something is not right.\n-                }\n-                if (!\"0\".equals(tokens[0])) {\n-                    \/\/ hierarchy must be zero for cgroups v2\n-                    return null;\n+    public static CgroupSubsystem getInstance(CgroupInfo anyController) {\n+        if (INSTANCE == null) {\n+            synchronized (CgroupV2Subsystem.class) {\n+                if (INSTANCE == null) {\n+                    CgroupSubsystemController unified = new CgroupV2SubsystemController(\n+                            anyController.getMountPoint(),\n+                            anyController.getCgroupPath());\n+                    INSTANCE = new CgroupV2Subsystem(unified);\n@@ -90,2 +71,0 @@\n-                cgroupPath = tokens[2];\n-                break;\n@@ -93,4 +72,0 @@\n-        } catch (UncheckedIOException e) {\n-            return null;\n-        } catch (IOException e) {\n-            return null;\n@@ -98,7 +73,0 @@\n-        CgroupSubsystemController unified = new CgroupV2SubsystemController(\n-                mountPath,\n-                cgroupPath);\n-        return new CgroupV2Subsystem(unified);\n-    }\n-\n-    public static CgroupSubsystem getInstance() {\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/cgroupv2\/CgroupV2Subsystem.java","additions":10,"deletions":42,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -23,0 +23,1 @@\n+import static org.junit.Assert.assertEquals;\n@@ -37,0 +38,1 @@\n+import jdk.internal.platform.CgroupInfo;\n@@ -65,0 +67,3 @@\n+    private Path cgroupv1SelfCgroup;\n+    private Path cgroupv2SelfCgroup;\n+    private Path cgroupv1SelfCgroupJoinCtrl;\n@@ -81,0 +86,11 @@\n+    private String selfCgroupNonZeroJoinControllers =\n+            \"9:cpuset:\/\\n\" +\n+            \"8:perf_event:\/\\n\" +\n+            \"7:rdma:\/\\n\" +\n+            \"6:freezer:\/\\n\" +\n+            \"5:blkio:\/user.slice\\n\" +\n+            \"4:pids:\/user.slice\/user-1000.slice\/session-3.scope\\n\" +\n+            \"3:devices:\/user.slice\\n\" +\n+            \"2:cpu,cpuacct,memory,net_cls,net_prio,hugetlb:\/user.slice\/user-1000.slice\/session-3.scope\\n\" +\n+            \"1:name=systemd:\/user.slice\/user-1000.slice\/session-3.scope\\n\" +\n+            \"0::\/user.slice\/user-1000.slice\/session-3.scope\\n\";\n@@ -140,0 +156,13 @@\n+    private String cgroupv1SelfCgroupContent = \"11:memory:\/user.slice\/user-1000.slice\/user@1000.service\\n\" +\n+            \"10:hugetlb:\/\\n\" +\n+            \"9:cpuset:\/\\n\" +\n+            \"8:pids:\/user.slice\/user-1000.slice\/user@1000.service\\n\" +\n+            \"7:freezer:\/\\n\" +\n+            \"6:blkio:\/\\n\" +\n+            \"5:net_cls,net_prio:\/\\n\" +\n+            \"4:devices:\/user.slice\\n\" +\n+            \"3:perf_event:\/\\n\" +\n+            \"2:cpu,cpuacct:\/\\n\" +\n+            \"1:name=systemd:\/user.slice\/user-1000.slice\/user@1000.service\/apps.slice\/apps-org.gnome.Terminal.slice\/vte-spawn-3c00b338-5b65-439f-8e97-135e183d135d.scope\\n\" +\n+            \"0::\/user.slice\/user-1000.slice\/user@1000.service\/apps.slice\/apps-org.gnome.Terminal.slice\/vte-spawn-3c00b338-5b65-439f-8e97-135e183d135d.scope\\n\";\n+    private String cgroupv2SelfCgroupContent = \"0::\/user.slice\/user-1000.slice\/session-2.scope\";\n@@ -175,0 +204,9 @@\n+\n+            cgroupv1SelfCgroup = Paths.get(existingDirectory.toString(), \"self_cgroup_cgv1\");\n+            Files.writeString(cgroupv1SelfCgroup, cgroupv1SelfCgroupContent);\n+\n+            cgroupv2SelfCgroup = Paths.get(existingDirectory.toString(), \"self_cgroup_cgv2\");\n+            Files.writeString(cgroupv2SelfCgroup, cgroupv2SelfCgroupContent);\n+\n+            cgroupv1SelfCgroupJoinCtrl = Paths.get(existingDirectory.toString(), \"self_cgroup_cgv1_join_controllers\");\n+            Files.writeString(cgroupv1SelfCgroupJoinCtrl, selfCgroupNonZeroJoinControllers);\n@@ -193,1 +231,2 @@\n-        Optional<CgroupTypeResult> result = CgroupSubsystemFactory.determineType(mountInfo, cgroups);\n+        String selfCgroup = cgroupv1SelfCgroupJoinCtrl.toString();\n+        Optional<CgroupTypeResult> result = CgroupSubsystemFactory.determineType(mountInfo, cgroups, selfCgroup);\n@@ -198,0 +237,2 @@\n+        CgroupInfo memoryInfo = res.getInfos().get(\"memory\");\n+        assertEquals(\"\/user.slice\/user-1000.slice\/session-3.scope\", memoryInfo.getCgroupPath());\n@@ -204,1 +245,2 @@\n-        Optional<CgroupTypeResult> result = CgroupSubsystemFactory.determineType(mountInfo, cgroups);\n+        String selfCgroup = cgroupv1SelfCgroup.toString(); \/\/ Content doesn't matter\n+        Optional<CgroupTypeResult> result = CgroupSubsystemFactory.determineType(mountInfo, cgroups, selfCgroup);\n@@ -218,1 +260,2 @@\n-        Optional<CgroupTypeResult> result = CgroupSubsystemFactory.determineType(mountInfo, cgroups);\n+        String selfCgroup = cgroupv1SelfCgroup.toString();\n+        Optional<CgroupTypeResult> result = CgroupSubsystemFactory.determineType(mountInfo, cgroups, selfCgroup);\n@@ -223,0 +266,3 @@\n+        CgroupInfo cpuSetInfo = res.getInfos().get(\"cpuset\");\n+        assertEquals(\"\/sys\/fs\/cgroup\/cpuset\", cpuSetInfo.getMountPoint());\n+        assertEquals(\"\/\", cpuSetInfo.getMountRoot());\n@@ -229,1 +275,2 @@\n-        Optional<CgroupTypeResult> result = CgroupSubsystemFactory.determineType(mountInfo, cgroups);\n+        String selfCgroup = cgroupv1SelfCgroup.toString();\n+        Optional<CgroupTypeResult> result = CgroupSubsystemFactory.determineType(mountInfo, cgroups, selfCgroup);\n@@ -234,0 +281,4 @@\n+        CgroupInfo memoryInfo = res.getInfos().get(\"memory\");\n+        assertEquals(\"\/user.slice\/user-1000.slice\/user@1000.service\", memoryInfo.getCgroupPath());\n+        assertEquals(\"\/\", memoryInfo.getMountRoot());\n+        assertEquals(\"\/sys\/fs\/cgroup\/memory\", memoryInfo.getMountPoint());\n@@ -240,1 +291,2 @@\n-        Optional<CgroupTypeResult> result = CgroupSubsystemFactory.determineType(mountInfo, cgroups);\n+        String selfCgroup = cgroupv1SelfCgroup.toString(); \/\/ Content doesn't matter\n+        Optional<CgroupTypeResult> result = CgroupSubsystemFactory.determineType(mountInfo, cgroups, selfCgroup);\n@@ -249,1 +301,2 @@\n-        Optional<CgroupTypeResult> result = CgroupSubsystemFactory.determineType(mountInfo, cgroups);\n+        String selfCgroup = cgroupv2SelfCgroup.toString();\n+        Optional<CgroupTypeResult> result = CgroupSubsystemFactory.determineType(mountInfo, cgroups, selfCgroup);\n@@ -255,0 +308,7 @@\n+        CgroupInfo memoryInfo = res.getInfos().get(\"memory\");\n+        assertEquals(\"\/user.slice\/user-1000.slice\/session-2.scope\", memoryInfo.getCgroupPath());\n+        CgroupInfo cpuInfo = res.getInfos().get(\"cpu\");\n+        assertEquals(memoryInfo.getCgroupPath(), cpuInfo.getCgroupPath());\n+        assertEquals(memoryInfo.getMountPoint(), cpuInfo.getMountPoint());\n+        assertEquals(memoryInfo.getMountRoot(), cpuInfo.getMountRoot());\n+        assertEquals(\"\/sys\/fs\/cgroup\", cpuInfo.getMountPoint());\n@@ -260,0 +320,1 @@\n+        String selfCgroup = cgroupv1SelfCgroup.toString(); \/\/ any existing file\n@@ -262,1 +323,1 @@\n-        CgroupSubsystemFactory.determineType(mountInfo, cgroups);\n+        CgroupSubsystemFactory.determineType(mountInfo, cgroups, selfCgroup);\n@@ -269,1 +330,10 @@\n-        CgroupSubsystemFactory.determineType(mountInfo, cgroups);\n+        String selfCgroup = cgroupv2SelfCgroup.toString(); \/\/ any existing file\n+        CgroupSubsystemFactory.determineType(mountInfo, cgroups, selfCgroup);\n+    }\n+\n+    @Test(expected = IOException.class)\n+    public void selfCgroupsFileNotFound() throws IOException {\n+        String cgroups = cgroupv1CgInfoZeroHierarchy.toString(); \/\/ any existing file\n+        String mountInfo = cgroupv2MntInfoZeroHierarchy.toString(); \/\/ any existing file\n+        String selfCgroup = Paths.get(existingDirectory.toString(), \"not-existing-self-cgroups\").toString();\n+        CgroupSubsystemFactory.determineType(mountInfo, cgroups, selfCgroup);\n","filename":"test\/jdk\/jdk\/internal\/platform\/cgroup\/TestCgroupSubsystemFactory.java","additions":78,"deletions":8,"binary":false,"changes":86,"status":"modified"}]}