{"files":[{"patch":"@@ -90,1 +90,0 @@\n-    private static final boolean DISABLE_JAR_CHECKING;\n@@ -100,2 +99,0 @@\n-        String p = props.getProperty(\"sun.misc.URLClassPath.disableJarChecking\");\n-        DISABLE_JAR_CHECKING = p != null ? p.equals(\"true\") || p.isEmpty() : false;\n@@ -103,1 +100,1 @@\n-        p = props.getProperty(\"jdk.net.URLClassPath.disableRestrictedPermissions\");\n+        String p = props.getProperty(\"jdk.net.URLClassPath.disableRestrictedPermissions\");\n@@ -660,1 +657,1 @@\n-                    jarfile = JarLoader.checkJar(juc.getJarFile());\n+                    jarfile = juc.getJarFile();\n@@ -805,17 +802,0 @@\n-        \/* Throws if the given jar file is does not start with the correct LOC *\/\n-        @SuppressWarnings(\"removal\")\n-        static JarFile checkJar(JarFile jar) throws IOException {\n-            if (System.getSecurityManager() != null && !DISABLE_JAR_CHECKING\n-                && !zipAccess.startsWithLocHeader(jar)) {\n-                IOException x = new IOException(\"Invalid Jar file\");\n-                try {\n-                    jar.close();\n-                } catch (IOException ex) {\n-                    x.addSuppressed(ex);\n-                }\n-                throw x;\n-            }\n-\n-            return jar;\n-        }\n-\n@@ -829,2 +809,2 @@\n-                return checkJar(new JarFile(new File(p.getPath()), true, ZipFile.OPEN_READ,\n-                        JarFile.runtimeVersion()));\n+                return new JarFile(new File(p.getPath()), true, ZipFile.OPEN_READ,\n+                        JarFile.runtimeVersion());\n@@ -835,1 +815,1 @@\n-            return checkJar(jarFile);\n+            return jarFile;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/loader\/URLClassPath.java","additions":5,"deletions":25,"binary":false,"changes":30,"status":"modified"}]}