{"files":[{"patch":"@@ -1164,11 +1164,6 @@\n-  VM_ENTRY_MARK;\n-  {\n-    ExceptionMark em(THREAD);\n-    methodHandle m(THREAD, get_Method());\n-    bool has_unloaded = Method::has_unloaded_classes_in_signature(m, thread);\n-    if( HAS_PENDING_EXCEPTION ) {\n-      CLEAR_PENDING_EXCEPTION;\n-      return true;     \/\/ Declare that we may have unloaded classes\n-    }\n-    return has_unloaded;\n-  }\n+  \/\/ ciSignature is resolved against some accessing class and\n+  \/\/ signature classes aren't required to be local. As a benefit,\n+  \/\/ it makes signature classes visible through loader constraints.\n+  \/\/ So, encountering an unloaded class signals it is absent both in\n+  \/\/ the callee (local) and caller contexts.\n+  return signature()->has_unloaded_classes();\n","filename":"src\/hotspot\/share\/ci\/ciMethod.cpp","additions":6,"deletions":11,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"ci\/ciStreams.hpp\"\n@@ -49,1 +50,0 @@\n-  int count = 0;\n@@ -51,3 +51,1 @@\n-  Symbol* sh = symbol->get_symbol();\n-  SignatureStream ss(sh);\n-  for (; ; ss.next()) {\n+  for (SignatureStream ss(symbol->get_symbol()); !ss.is_done(); ss.next()) {\n@@ -55,4 +53,2 @@\n-    ciType* type;\n-    if (!ss.is_reference()) {\n-      type = ciType::make(ss.type());\n-    } else {\n+    ciType* type = NULL;\n+    if (ss.is_reference()) {\n@@ -61,0 +57,2 @@\n+    } else {\n+      type = ciType::make(ss.type());\n@@ -65,1 +63,3 @@\n-      break;\n+    } else {\n+      _types.append(type);\n+      size += type->size();\n@@ -67,2 +67,0 @@\n-    _types.append(type);\n-    size += type->size();\n@@ -100,0 +98,16 @@\n+\/\/ ------------------------------------------------------------------\n+\/\/ ciSignature::has_unloaded_classes\n+\/\/\n+\/\/ Reports if there are any unloaded classes present in the signature.\n+\/\/ Each ciSignature when instantiated is resolved against some accessing class\n+\/\/ and the resolved classes aren't required to be local, but can be revealed\n+\/\/ through loader constraints.\n+bool ciSignature::has_unloaded_classes() {\n+  for (ciSignatureStream str(this); !str.is_done(); str.next()) {\n+    if (!str.type()->is_loaded()) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/share\/ci\/ciSignature.cpp","additions":25,"deletions":11,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -66,0 +66,2 @@\n+  bool has_unloaded_classes();\n+\n","filename":"src\/hotspot\/share\/ci\/ciSignature.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1733,14 +1733,0 @@\n-bool Method::has_unloaded_classes_in_signature(const methodHandle& m, TRAPS) {\n-  ResourceMark rm(THREAD);\n-  for(ResolvingSignatureStream ss(m()); !ss.is_done(); ss.next()) {\n-    if (ss.type() == T_OBJECT) {\n-      \/\/ Do not use ss.is_reference() here, since we don't care about\n-      \/\/ unloaded array component types.\n-      Klass* klass = ss.as_klass_if_loaded(THREAD);\n-      assert(!HAS_PENDING_EXCEPTION, \"as_klass_if_loaded contract\");\n-      if (klass == NULL) return true;\n-    }\n-  }\n-  return false;\n-}\n-\n","filename":"src\/hotspot\/share\/oops\/method.cpp","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -968,3 +968,0 @@\n-  \/\/ Return if true if not all classes references in signature, including return type, has been loaded\n-  static bool has_unloaded_classes_in_signature(const methodHandle& m, TRAPS);\n-\n","filename":"src\/hotspot\/share\/oops\/method.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,231 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8294609\n+ * @requires vm.compiler2.enabled & vm.flagless\n+ *\n+ * @library \/test\/lib\n+ *\n+ * @build compiler.c2.unloaded.TestInlineUnloaded\n+ *\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar launcher.jar\n+ *                  compiler.c2.unloaded.TestInlineUnloaded\n+ *                  compiler.c2.unloaded.TestInlineUnloaded$Launcher\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar parent.jar\n+ *                  compiler.c2.unloaded.TestInlineUnloaded$Parent\n+ *                  compiler.c2.unloaded.TestInlineUnloaded$Parent$U\n+ *                  compiler.c2.unloaded.TestInlineUnloaded$Parent$TestCase\n+ *                  compiler.c2.unloaded.TestInlineUnloaded$Parent$Invoker\n+ *                  compiler.c2.unloaded.TestInlineUnloaded$Parent$TestNull\n+ *                  compiler.c2.unloaded.TestInlineUnloaded$Parent$TestLoadedRemotely\n+ *                  compiler.c2.unloaded.TestInlineUnloaded$Parent$TestUnloaded\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar caller.jar\n+ *                  compiler.c2.unloaded.TestInlineUnloaded$Caller\n+ *                  compiler.c2.unloaded.TestInlineUnloaded$Caller$TestNull\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar callee.jar\n+ *                  compiler.c2.unloaded.TestInlineUnloaded$Callee\n+ *                  compiler.c2.unloaded.TestInlineUnloaded$Callee$TestNull\n+ *\n+ * @run driver compiler.c2.unloaded.TestInlineUnloaded\n+ *\/\n+\n+package compiler.c2.unloaded;\n+\n+import jdk.test.lib.JDKToolFinder;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+import java.io.IOException;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.util.function.Consumer;\n+\n+public class TestInlineUnloaded {\n+    static final String THIS_CLASS = TestInlineUnloaded.class.getName();\n+\n+    public static class Parent {\n+        public class U {\n+        }\n+\n+        public interface TestCase {\n+            U test(Invoker obj, U arg);\n+\n+            void testArg(Invoker obj, U arg);\n+\n+            U testRet(Invoker obj);\n+\n+            void test(Invoker obj);\n+        }\n+\n+        public interface Invoker {\n+            void invokeArg(U obj);\n+\n+            U invokeRet();\n+\n+            U invoke(U obj);\n+        }\n+\n+        private static class TestNull implements Runnable {\n+            final TestCase test;\n+            final Invoker recv;\n+\n+            public TestNull(TestCase test, Invoker recv) {\n+                this.test = test;\n+                this.recv = recv;\n+            }\n+\n+            @Override\n+            public void run() {\n+                test.testArg(recv, null);\n+                test.testRet(recv);\n+                test.test(recv, null);\n+            }\n+        }\n+\n+        public static class TestLoadedRemotely extends TestNull {\n+            public TestLoadedRemotely(TestCase test, Invoker recv) throws Exception {\n+                super(test, recv);\n+                Class.forName(U.class.getName()); \/\/ preload in parent context\n+            }\n+        }\n+\n+        public static class TestUnloaded extends TestNull {\n+            public TestUnloaded(TestCase test, Invoker recv) {\n+                super(test, recv);\n+            }\n+        }\n+    }\n+\n+    public static class Caller {\n+        public static class TestNull implements Parent.TestCase {\n+            public TestNull() {}\n+\n+            public Parent.U test(Parent.Invoker obj, Parent.U arg) {\n+                return obj.invoke(arg);\n+            }\n+\n+            public void testArg(Parent.Invoker obj, Parent.U arg) {\n+                obj.invokeArg(arg);\n+            }\n+\n+            public Parent.U testRet(Parent.Invoker obj) {\n+                return obj.invokeRet();\n+            }\n+\n+            public void test(Parent.Invoker obj) {\n+                test(obj, null);\n+            }\n+        }\n+    }\n+\n+    public static class Callee {\n+        public static class TestNull implements Parent.Invoker {\n+            public void invokeArg(Parent.U obj) {}\n+\n+            public Parent.U invokeRet() {\n+                return null;\n+            }\n+\n+            public Parent.U invoke(Parent.U obj) {\n+                return obj;\n+            }\n+        }\n+    }\n+\n+    public static class Launcher {\n+        public static void main(String... args) throws Exception {\n+            final String testName = args[0];\n+\n+            URLClassLoader parentCL = new URLClassLoader(\"parent\", new URL[] { new URL(\"file:parent.jar\") }, ClassLoader.getSystemClassLoader());\n+            URLClassLoader callerCL = new URLClassLoader(\"caller\", new URL[] { new URL(\"file:caller.jar\") }, parentCL);\n+            URLClassLoader calleeCL = new URLClassLoader(\"callee\", new URL[] { new URL(\"file:callee.jar\") }, parentCL);\n+\n+            Object caller = Class.forName(THIS_CLASS + \"$Caller$TestNull\", false, callerCL)\n+                                 .getDeclaredConstructor().newInstance();\n+            Object callee = Class.forName(THIS_CLASS + \"$Callee$TestNull\", false, calleeCL)\n+                                 .getDeclaredConstructor().newInstance();\n+\n+            Class<?> testClass = Class.forName(THIS_CLASS + \"$Parent$TestCase\", false, parentCL);\n+            Class<?> invClass  = Class.forName(THIS_CLASS + \"$Parent$Invoker\",  false, parentCL);\n+            Class<?> test      = Class.forName(THIS_CLASS + \"$Parent$\" + testName, false, parentCL);\n+            Runnable r = (Runnable) test.getDeclaredConstructor(testClass, invClass)\n+                                       .newInstance(caller, callee);\n+\n+            if (args.length > 1 && \"-preload\".equals(args[1])) {\n+                Class.forName(THIS_CLASS + \"$Parent$U\", false, parentCL);\n+            }\n+\n+            for (int i = 0; i < 20_000; i ++) {\n+                r.run();\n+            }\n+        }\n+    }\n+\n+    static void run(String testCaseName, Consumer<OutputAnalyzer> processor) throws IOException {\n+        ProcessBuilder pb = new ProcessBuilder();\n+\n+        pb.command(JDKToolFinder.getJDKTool(\"java\"),\n+            \"-cp\", \"launcher.jar\",\n+            \"-XX:+IgnoreUnrecognizedVMOptions\", \"-showversion\",\n+            \"-XX:-TieredCompilation\", \"-Xbatch\",\n+            \"-XX:+PrintCompilation\", \"-XX:+UnlockDiagnosticVMOptions\", \"-XX:+PrintInlining\",\n+            \"-XX:CompileCommand=quiet\", \"-XX:CompileCommand=compileonly,*TestNull::run\",\n+            Launcher.class.getName(), testCaseName);\n+\n+        System.out.println(\"Command line: [\" + pb.command() + \"]\");\n+\n+        OutputAnalyzer analyzer = new OutputAnalyzer(pb.start());\n+\n+        analyzer.shouldHaveExitValue(0);\n+\n+        \/\/ The test is applicable only to C2 (present in Server VM).\n+        analyzer.stderrShouldContain(\"Server VM\");\n+\n+        analyzer.shouldContain(\"TestNull::run\"); \/\/ ensure that relevant method is compiled\n+\n+        processor.accept(analyzer); \/\/ test-specific checks\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        run(\"TestUnloaded\", output -> {\n+            output.shouldMatch(\"TestNull::testArg .* unloaded signature classes\");\n+            output.shouldMatch(\"TestNull::testRet .* unloaded signature classes\");\n+            output.shouldMatch(\"TestNull::test .* unloaded signature classes\");\n+\n+            output.shouldNotMatch(\"TestNull::testArg .* inline\");\n+            output.shouldNotMatch(\"TestNull::testRet .* inline\");\n+            output.shouldNotMatch(\"TestNull::test .* inline\");\n+        });\n+        run(\"TestLoadedRemotely\", output -> {\n+            output.shouldMatch(\"TestNull::testArg .* inline\");\n+            output.shouldMatch(\"TestNull::testRet .* inline\");\n+            output.shouldMatch(\"TestNull::test .* inline\");\n+\n+            output.shouldNotMatch(\"TestNull::testArg .* unloaded signature classes\");\n+            output.shouldNotMatch(\"TestNull::testRet .* unloaded signature classes\");\n+            output.shouldNotMatch(\"TestNull::test .* unloaded signature classes\");\n+        });\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/unloaded\/TestInlineUnloaded.java","additions":231,"deletions":0,"binary":false,"changes":231,"status":"added"}]}