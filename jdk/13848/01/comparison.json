{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+ * @library \/test\/lib\n@@ -43,0 +44,2 @@\n+import jdk.test.lib.Platform;\n+\n@@ -65,0 +68,17 @@\n+    @Override\n+    protected boolean allowedExitValue(int exitValue) {\n+        if (passName.equals(\"Kill\")) {\n+            \/\/ 143 is SIGTERM, which we expect to get when doing a Process.destroy(),\n+            \/\/ unless we are on Windows, which will exit with a 1.\n+            if (!Platform.isWindows()) {\n+                return exitValue == 143;\n+            } else {\n+                return exitValue == 1;\n+            }\n+        } else if (passName.equals(\"exit()\")) {\n+            \/\/ This version of the test does an exit(1), so that's what we expect.\n+            return exitValue == 1;\n+        }\n+        return super.allowedExitValue(exitValue);\n+    }\n+\n@@ -79,3 +99,3 @@\n-        startToMain(\"InstTarg\");\n-        ThreadReference thread = waitForVMStart();\n-        StepEvent stepEvent = stepIntoLine(thread);\n+        BreakpointEvent bp = startToMain(\"InstTarg\");\n+        waitForVMStart();\n+        StepEvent stepEvent = stepIntoLine(bp.thread());\n","filename":"test\/jdk\/com\/sun\/jdi\/ConnectedVMs.java","additions":24,"deletions":4,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023 Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,10 @@\n+        \/\/ Sleep before exiting to allow disconnect efforts done on the JDI side to complete.\n+        \/\/ Note that not sleeping long enough is for the most part harmless, but might render\n+        \/\/ the testing insufficient because the debuggee will quickly exit naturally\n+        \/\/ once the debuggee does the vm.resume(), rather than waiting for disconnect\n+        \/\/ efforts to complete first.\n+        try {\n+            Thread.sleep(5000);\n+        } catch (InterruptedException e) {\n+            throw new RuntimeException(e);\n+        }\n","filename":"test\/jdk\/com\/sun\/jdi\/InstTarg.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -725,0 +725,7 @@\n+    \/*\n+     * Tests that expect an exitValue other than 0 or 1 will need to override this method.\n+     *\/\n+    protected boolean allowedExitValue(int exitValue) {\n+        return exitValue == 0 || exitValue == 1;\n+    }\n+\n@@ -741,5 +748,3 @@\n-        int res = p.exitValue();\n-        \/\/ Some tests purposefully exit with an exception, which produces exitValue\n-        \/\/ 1, so we have to allow it also.\n-        if (res != 0 && res != 1) {\n-            throw new RuntimeException(\"Non-zero debuggee exitValue: \" + res);\n+        int exitValue = p.exitValue();\n+        if (!allowedExitValue(exitValue)) {\n+            throw new RuntimeException(\"Invalid debuggee exitValue: \" + exitValue);\n","filename":"test\/jdk\/com\/sun\/jdi\/TestScaffold.java","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"}]}