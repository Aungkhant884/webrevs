{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,1 +78,1 @@\n-  _table.unlink_destruct([&](nmethod* nm, nmethod* nm2){ return should_remove(nm);});\n+  _table.unlink(&should_remove);\n@@ -183,0 +183,1 @@\n+  NONCOPYABLE(CleanCallback); \/\/ can not copy, _blobs will point to old copy\n@@ -211,1 +212,1 @@\n-  bool operator() (nmethod* nm) {\n+  bool do_entry(nmethod* nm, nmethod* _) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CodeCacheRemSet.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CodeCacheRemSet.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CodeRootSetTable.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/utilities\/resizeableResourceHash.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -277,30 +277,0 @@\n-  \/\/ The argument should_remove() have the signature: bool Function(K const&, V const&).\n-  \/\/ The predicate should_remove() will be called for each entry in the table.\n-  \/\/ If should_remove() returns true, the element will be removed from the table.\n-  \/\/ If the Node is C_HEAP allocated the entry is deleted, else the destructor\n-  \/\/ of the Node will be called. Unlike unlink (above), this method uses a functor\n-  \/\/ interface and will call the destructor of the Node, and thus the destructor\n-  \/\/ of the element (even if the Node is resource allocated).\n-  template<typename Function>\n-  void unlink_destruct(Function&& should_remove) {\n-    const unsigned sz = table_size();\n-    for (unsigned index = 0; index < sz; index++) {\n-      Node** ptr = bucket_at(index);\n-      while (*ptr != nullptr) {\n-        Node* node = *ptr;\n-        bool clean = should_remove(node->_key, node->_value);\n-        if (clean) {\n-          *ptr = node->_next;\n-          if (ALLOC_TYPE == AnyObj::C_HEAP) {\n-            delete node;\n-          } else {\n-            node->~Node();\n-          }\n-          _number_of_entries --;\n-        } else {\n-          ptr = &(node->_next);\n-        }\n-      }\n-    }\n-  }\n-\n","filename":"src\/hotspot\/share\/utilities\/resourceHash.hpp","additions":0,"deletions":30,"binary":false,"changes":30,"status":"modified"}]}