{"files":[{"patch":"@@ -1,230 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"code\/codeCache.hpp\"\n-#include \"code\/nmethod.hpp\"\n-#include \"gc\/g1\/g1CodeCacheRemSet.hpp\"\n-#include \"gc\/g1\/heapRegion.hpp\"\n-#include \"memory\/heap.hpp\"\n-#include \"memory\/iterator.hpp\"\n-#include \"oops\/access.inline.hpp\"\n-#include \"oops\/oop.inline.hpp\"\n-#include \"runtime\/atomic.hpp\"\n-#include \"services\/memTracker.hpp\"\n-#include \"utilities\/hashtable.inline.hpp\"\n-#include \"utilities\/stack.inline.hpp\"\n-\n-G1CodeRootSetTable* volatile G1CodeRootSetTable::_purge_list = NULL;\n-\n-size_t G1CodeRootSetTable::mem_size() const {\n-  return sizeof(*this) + _table.mem_size() - sizeof(_table); \/\/ do not double count _table\n-}\n-\n-bool G1CodeRootSetTable::add(nmethod* nm) {\n-  if (!contains(nm)) {\n-    _table.put(nm, nm);\n-    return true;\n-  }\n-  return false;\n-}\n-\n-bool G1CodeRootSetTable::contains(nmethod* nm) {\n-  return _table.contains(nm);\n-}\n-\n-bool G1CodeRootSetTable::remove(nmethod* nm) {\n-  return _table.remove(nm);\n-}\n-\n-void G1CodeRootSetTable::copy_to(G1CodeRootSetTable* new_table) {\n-  _table.iterate_all([&new_table](nmethod* nm, nmethod* _) {\n-    new_table->add(nm);\n-  });\n-}\n-\n-void G1CodeRootSetTable::nmethods_do(CodeBlobClosure* blk) {\n-  _table.iterate_all([&](nmethod* nm, nmethod* _) {\n-    blk->do_code_blob(nm);\n-  });\n-}\n-\n-void G1CodeRootSetTable::remove_if(CleanCallback& should_remove) {\n-  _table.unlink(&should_remove);\n-}\n-\n-G1CodeRootSet::~G1CodeRootSet() {\n-  delete _table;\n-}\n-\n-G1CodeRootSetTable* G1CodeRootSet::load_acquire_table() {\n-  return Atomic::load_acquire(&_table);\n-}\n-\n-void G1CodeRootSet::allocate_small_table() {\n-  G1CodeRootSetTable* temp = new G1CodeRootSetTable(SmallSize);\n-\n-  Atomic::release_store(&_table, temp);\n-}\n-\n-void G1CodeRootSetTable::purge_list_append(G1CodeRootSetTable* table) {\n-  for (;;) {\n-    table->_purge_next = _purge_list;\n-    G1CodeRootSetTable* old = Atomic::cmpxchg(&_purge_list, table->_purge_next, table);\n-    if (old == table->_purge_next) {\n-      break;\n-    }\n-  }\n-}\n-\n-void G1CodeRootSetTable::purge() {\n-  G1CodeRootSetTable* table = _purge_list;\n-  _purge_list = NULL;\n-  while (table != NULL) {\n-    G1CodeRootSetTable* to_purge = table;\n-    table = table->_purge_next;\n-    delete to_purge;\n-  }\n-}\n-\n-void G1CodeRootSet::move_to_large() {\n-  assert(_iteration_thread == Thread::current() || _iteration_thread == nullptr, \"should not mutate while iterating in another thread\");\n-  G1CodeRootSetTable* temp = new G1CodeRootSetTable(LargeSize);\n-\n-  _table->copy_to(temp);\n-\n-  G1CodeRootSetTable::purge_list_append(_table);\n-\n-  Atomic::release_store(&_table, temp);\n-}\n-\n-void G1CodeRootSet::purge() {\n-  G1CodeRootSetTable::purge();\n-}\n-\n-size_t G1CodeRootSet::static_mem_size() {\n-  return G1CodeRootSetTable::static_mem_size();\n-}\n-\n-void G1CodeRootSet::add(nmethod* method) {\n-  assert(_iteration_thread == Thread::current() || _iteration_thread == nullptr, \"should not mutate while iterating in another thread\");\n-  bool added = false;\n-  if (is_empty()) {\n-    allocate_small_table();\n-  }\n-  added = _table->add(method);\n-  if (added) {\n-    if (length() == Threshold) {\n-      move_to_large();\n-    }\n-  }\n-}\n-\n-bool G1CodeRootSet::remove(nmethod* method) {\n-  assert(_iteration_thread == Thread::current() || _iteration_thread == nullptr, \"should not mutate while iterating in another thread\");\n-  bool removed = false;\n-  if (_table != NULL) {\n-    removed = _table->remove(method);\n-  }\n-  if (removed) {\n-    if (length() == 0) {\n-      clear();\n-    }\n-  }\n-  return removed;\n-}\n-\n-bool G1CodeRootSet::contains(nmethod* method) {\n-  G1CodeRootSetTable* table = load_acquire_table(); \/\/ contains() may be called outside of lock, so ensure mem sync.\n-  if (table != NULL) {\n-    return table->contains(method);\n-  }\n-  return false;\n-}\n-\n-void G1CodeRootSet::clear() {\n-  assert(_iteration_thread == Thread::current() || _iteration_thread == nullptr, \"should not mutate while iterating in another thread\");\n-  delete _table;\n-  _table = NULL;\n-}\n-\n-size_t G1CodeRootSet::mem_size() {\n-  return sizeof(*this) + (_table != NULL ? _table->mem_size() : 0);\n-}\n-\n-void G1CodeRootSet::nmethods_do(CodeBlobClosure* blk) const {\n-  DEBUG_ONLY(_iteration_thread = Thread::current();)\n-  if (_table != NULL) {\n-    _table->nmethods_do(blk);\n-  }\n-  DEBUG_ONLY(_iteration_thread = nullptr;)\n-}\n-\n-class CleanCallback : public StackObj {\n-  NONCOPYABLE(CleanCallback); \/\/ can not copy, _blobs will point to old copy\n-  class PointsIntoHRDetectionClosure : public OopClosure {\n-    HeapRegion* _hr;\n-   public:\n-    bool _points_into;\n-    PointsIntoHRDetectionClosure(HeapRegion* hr) : _hr(hr), _points_into(false) {}\n-\n-    void do_oop(narrowOop* o) {\n-      do_oop_work(o);\n-    }\n-\n-    void do_oop(oop* o) {\n-      do_oop_work(o);\n-    }\n-\n-    template <typename T>\n-    void do_oop_work(T* p) {\n-      if (_hr->is_in(RawAccess<>::oop_load(p))) {\n-        _points_into = true;\n-      }\n-    }\n-  };\n-\n-  PointsIntoHRDetectionClosure _detector;\n-  CodeBlobToOopClosure _blobs;\n-\n- public:\n-  CleanCallback(HeapRegion* hr) : _detector(hr), _blobs(&_detector, !CodeBlobToOopClosure::FixRelocations) {}\n-\n-  bool do_entry(nmethod* nm, nmethod* _) {\n-    _detector._points_into = false;\n-    _blobs.do_code_blob(nm);\n-    return !_detector._points_into;\n-  }\n-};\n-\n-void G1CodeRootSet::clean(HeapRegion* owner) {\n-  assert(_iteration_thread == Thread::current() || _iteration_thread == nullptr, \"should not mutate while iterating in another thread\");\n-  CleanCallback should_clean(owner);\n-  if (_table != NULL) {\n-    _table->remove_if(should_clean);\n-  }\n-  if (length() == 0) {\n-    clear();\n-  }\n-}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CodeCacheRemSet.cpp","additions":0,"deletions":230,"binary":false,"changes":230,"status":"deleted"},{"patch":"@@ -1,127 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_G1_G1CODECACHEREMSET_HPP\n-#define SHARE_GC_G1_G1CODECACHEREMSET_HPP\n-\n-#include \"utilities\/globalDefinitions.hpp\"\n-\n-#include \"code\/codeCache.hpp\"\n-#include \"memory\/allocation.hpp\"\n-#include \"utilities\/resizeableResourceHash.hpp\"\n-#include \"utilities\/resourceHash.hpp\"\n-\n-class CleanCallback;\n-class CodeBlobClosure;\n-class G1CodeRootSetTable;\n-class HeapRegion;\n-class nmethod;\n-\n-class G1CodeRootSetTable : public CHeapObj<mtGC>  {\n-  friend class G1CodeRootSetTest;\n-\n-  static G1CodeRootSetTable* volatile _purge_list;\n-\n-  using Table = ResizeableResourceHashtable<nmethod*, nmethod*, AnyObj::C_HEAP, mtGC>;\n-  Table _table;\n-  G1CodeRootSetTable* _purge_next;\n-\n- public:\n-  G1CodeRootSetTable(int size) : _table(size, size), _purge_next(NULL) {}\n-  \/\/ Needs to be protected by locks\n-  bool add(nmethod* nm);\n-  bool remove(nmethod* nm);\n-\n-  \/\/ Can be called without locking\n-  bool contains(nmethod* nm);\n-\n-  void copy_to(G1CodeRootSetTable* new_table);\n-  void nmethods_do(CodeBlobClosure* blk);\n-\n-  void remove_if(CleanCallback& should_remove);\n-  int number_of_entries() const {return _table.number_of_entries();}\n-\n-  static void purge_list_append(G1CodeRootSetTable* tbl);\n-  static void purge();\n-\n-  static size_t static_mem_size() {\n-    return sizeof(_purge_list);\n-  }\n-\n-  size_t mem_size() const;\n-};\n-\n-\n-\/\/ Implements storage for a set of code roots.\n-\/\/ All methods that modify the set are not thread-safe except if otherwise noted.\n-class G1CodeRootSet {\n-  friend class G1CodeRootSetTest;\n- private:\n-\n-  const static size_t SmallSize = 32;\n-  const static size_t Threshold = 24;\n-  const static size_t LargeSize = 512;\n-\n-  G1CodeRootSetTable* _table;\n-  G1CodeRootSetTable* load_acquire_table();\n-\n-  void move_to_large();\n-  void allocate_small_table();\n-  DEBUG_ONLY(mutable Thread* _iteration_thread;)\n-\n- public:\n-  G1CodeRootSet() : _table(nullptr) DEBUG_ONLY(COMMA _iteration_thread(nullptr)) {}\n-  ~G1CodeRootSet();\n-\n-  static void purge();\n-\n-  static size_t static_mem_size();\n-\n-  void add(nmethod* method);\n-\n-  bool remove(nmethod* method);\n-\n-  \/\/ Safe to call without synchronization, but may return false negatives.\n-  bool contains(nmethod* method);\n-\n-  void clear();\n-\n-  void nmethods_do(CodeBlobClosure* blk) const;\n-\n-  \/\/ Remove all nmethods which no longer contain pointers into our \"owner\" region\n-  void clean(HeapRegion* owner);\n-\n-  bool is_empty() {\n-    return length() == 0;\n-  }\n-\n-  \/\/ Length in elements\n-  size_t length() const { return _table == nullptr ? 0 : _table->number_of_entries(); }\n-\n-  \/\/ Memory size in bytes taken by this set.\n-  size_t mem_size();\n-\n-};\n-\n-#endif \/\/ SHARE_GC_G1_G1CODECACHEREMSET_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CodeCacheRemSet.hpp","additions":0,"deletions":127,"binary":false,"changes":127,"status":"deleted"},{"patch":"@@ -0,0 +1,144 @@\n+\/*\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"code\/codeCache.hpp\"\n+#include \"code\/nmethod.hpp\"\n+#include \"gc\/g1\/g1CodeRootSet.hpp\"\n+#include \"gc\/g1\/heapRegion.hpp\"\n+#include \"memory\/heap.hpp\"\n+#include \"memory\/iterator.hpp\"\n+#include \"oops\/access.inline.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+#include \"services\/memTracker.hpp\"\n+#include \"utilities\/hashtable.inline.hpp\"\n+#include \"utilities\/stack.inline.hpp\"\n+\n+void G1CodeRootSet::add(nmethod* nm) {\n+  assert(_is_iterating == false, \"should not mutate while iterating the table\");\n+  bool added = false;\n+  if (_table == nullptr) {\n+    _table = new (mtGC) Table(SmallSize, LargeSize);\n+  }\n+  added = _table->put(nm, nm);\n+  if (added && _table->table_size() == SmallSize && length() == Threshold) {\n+    _table->resize(SmallSize, LargeSize);\n+  }\n+}\n+\n+G1CodeRootSet::~G1CodeRootSet() {\n+  delete _table;\n+}\n+\n+bool G1CodeRootSet::remove(nmethod* method) {\n+  assert(_is_iterating == false, \"should not mutate while iterating the table\");\n+  bool removed = false;\n+  if (_table != nullptr) {\n+    removed = _table->remove(method);\n+  }\n+  if (removed) {\n+    if (length() == 0) {\n+      clear();\n+    }\n+  }\n+  return removed;\n+}\n+\n+bool G1CodeRootSet::contains(nmethod* method) {\n+  if (_table != nullptr) {\n+    return _table->contains(method);\n+  }\n+  return false;\n+}\n+\n+void G1CodeRootSet::clear() {\n+  assert(_is_iterating == false, \"should not mutate while iterating the table\");\n+  delete _table;\n+  _table = nullptr;\n+}\n+\n+size_t G1CodeRootSet::mem_size() {\n+  return (_table == nullptr)\n+    ? sizeof(*this)\n+    : sizeof(*this) + _table->mem_size();\n+}\n+\n+void G1CodeRootSet::nmethods_do(CodeBlobClosure* blk) const {\n+  DEBUG_ONLY(_is_iterating = true;)\n+  if (_table != nullptr) {\n+    _table->iterate_all([&](nmethod* nm, nmethod* _) {\n+      blk->do_code_blob(nm);\n+    });\n+  }\n+  DEBUG_ONLY(_is_iterating = false;)\n+}\n+\n+class CleanCallback : public StackObj {\n+  NONCOPYABLE(CleanCallback); \/\/ can not copy, _blobs will point to old copy\n+  class PointsIntoHRDetectionClosure : public OopClosure {\n+    HeapRegion* _hr;\n+   public:\n+    bool _points_into;\n+    PointsIntoHRDetectionClosure(HeapRegion* hr) : _hr(hr), _points_into(false) {}\n+\n+    void do_oop(narrowOop* o) {\n+      do_oop_work(o);\n+    }\n+\n+    void do_oop(oop* o) {\n+      do_oop_work(o);\n+    }\n+\n+    template <typename T>\n+    void do_oop_work(T* p) {\n+      if (_hr->is_in(RawAccess<>::oop_load(p))) {\n+        _points_into = true;\n+      }\n+    }\n+  };\n+\n+  PointsIntoHRDetectionClosure _detector;\n+  CodeBlobToOopClosure _blobs;\n+\n+ public:\n+  CleanCallback(HeapRegion* hr) : _detector(hr), _blobs(&_detector, !CodeBlobToOopClosure::FixRelocations) {}\n+\n+  bool do_entry(nmethod* nm, nmethod* _) {\n+    _detector._points_into = false;\n+    _blobs.do_code_blob(nm);\n+    return !_detector._points_into;\n+  }\n+};\n+\n+void G1CodeRootSet::clean(HeapRegion* owner) {\n+  assert(_is_iterating == false, \"should not mutate while iterating the table\");\n+  CleanCallback should_clean(owner);\n+  if (_table != nullptr) {\n+    _table->unlink(&should_clean);\n+  }\n+  if (length() == 0) {\n+    clear();\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CodeRootSet.cpp","additions":144,"deletions":0,"binary":false,"changes":144,"status":"added"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_G1_G1CODEROOTSET_HPP\n+#define SHARE_GC_G1_G1CODEROOTSET_HPP\n+\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+#include \"code\/codeCache.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"utilities\/resizeableResourceHash.hpp\"\n+#include \"utilities\/resourceHash.hpp\"\n+\n+class CleanCallback;\n+class CodeBlobClosure;\n+class G1CodeRootSetTable;\n+class HeapRegion;\n+class nmethod;\n+\n+\n+\/\/ Implements storage for a set of code roots.\n+\/\/ This class is not thread safe, locks are needed.\n+class G1CodeRootSet {\n+  friend class G1CodeRootSetTest;\n+  friend class G1CodeRootSetTest_g1_code_cache_rem_set_vm_Test;\n+\n+ private:\n+  const static size_t SmallSize = 32;\n+  const static size_t Threshold = 24;\n+  const static size_t LargeSize = 512;\n+\n+  using Table = ResizeableResourceHashtable<nmethod*, nmethod*, AnyObj::C_HEAP, mtGC>;\n+  Table* _table;\n+  DEBUG_ONLY(mutable bool _is_iterating;)\n+\n+ public:\n+  G1CodeRootSet() : _table(nullptr) DEBUG_ONLY(COMMA _is_iterating(false)) {}\n+  ~G1CodeRootSet();\n+\n+  void add(nmethod* method);\n+  bool remove(nmethod* method);\n+  bool contains(nmethod* method);\n+  void clear();\n+  void nmethods_do(CodeBlobClosure* blk) const;\n+\n+  \/\/ Remove all nmethods which no longer contain pointers into our \"owner\" region\n+  void clean(HeapRegion* owner);\n+\n+  bool is_empty() { return length() == 0;}\n+\n+  \/\/ Length in elements\n+  size_t length() const { return _table == nullptr ? 0 : _table->number_of_entries(); }\n+\n+  \/\/ Memory size in bytes taken by this set.\n+  size_t mem_size();\n+\n+};\n+\n+#endif \/\/ SHARE_GC_G1_G1CODEROOTSET_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CodeRootSet.hpp","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1048,3 +1048,0 @@\n-  \/\/ Purge code root memory\n-  purge_code_root_memory();\n-\n@@ -3391,4 +3388,0 @@\n-void G1CollectedHeap::purge_code_root_memory() {\n-  G1CodeRootSet::purge();\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1275,2 +1275,0 @@\n-  \/\/ Free up superfluous code root memory.\n-  void purge_code_root_memory();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -110,1 +110,0 @@\n-  _gc_par_phases[PurgeCodeRoots] = new WorkerDataArray<double>(\"PurgeCodeRoots\", \"Purge Code Roots (ms):\", max_gc_threads);\n@@ -522,1 +521,0 @@\n-  debug_phase(_gc_par_phases[PurgeCodeRoots], 1);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1GCPhaseTimes.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,1 +85,0 @@\n-    PurgeCodeRoots,\n","filename":"src\/hotspot\/share\/gc\/g1\/g1GCPhaseTimes.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -248,8 +248,0 @@\n-class G1PostEvacuateCollectionSetCleanupTask2::PurgeCodeRootsTask : public G1AbstractSubTask {\n-public:\n-  PurgeCodeRootsTask() : G1AbstractSubTask(G1GCPhaseTimes::PurgeCodeRoots) { }\n-\n-  double worker_cost() const override { return 1.0; }\n-  void do_work(uint worker_id) override { G1CollectedHeap::heap()->purge_code_root_memory(); }\n-};\n-\n@@ -717,1 +709,0 @@\n-  add_serial_task(new PurgeCodeRootsTask());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.cpp","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,1 +66,0 @@\n-  class PurgeCodeRootsTask;\n@@ -84,1 +83,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -104,2 +104,0 @@\n-\/\/ When concurrent readers access the contains() function\n-\/\/ (during the evacuation phase) no removals are allowed.\n@@ -125,1 +123,4 @@\n-  _code_roots.add(nm);\n+\n+  if (!_code_roots.contains(nm)) { \/\/ with this test, we can assert that we do not modify the hash table while iterating over it\n+    _code_roots.add(nm);\n+  }\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionRemSet.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n-#include \"gc\/g1\/g1CodeCacheRemSet.hpp\"\n+#include \"gc\/g1\/g1CodeRootSet.hpp\"\n@@ -144,1 +144,1 @@\n-    return G1CardSet::static_mem_size() + G1CodeRootSet::static_mem_size();\n+    return G1CardSet::static_mem_size();\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionRemSet.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,93 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"gc\/g1\/g1CodeCacheRemSet.hpp\"\n-#include \"unittest.hpp\"\n-\n-class G1CodeRootSetTest : public ::testing::Test {\n- public:\n-\n-  size_t threshold() {\n-    return G1CodeRootSet::Threshold;\n-  }\n-\n-  G1CodeRootSetTable* purge_list() {\n-    return G1CodeRootSetTable::_purge_list;\n-  }\n-};\n-\n-TEST_VM_F(G1CodeRootSetTest, g1_code_cache_rem_set) {\n-  G1CodeRootSet root_set;\n-\n-  ASSERT_TRUE(root_set.is_empty()) << \"Code root set must be initially empty \"\n-          \"but is not.\";\n-\n-  ASSERT_EQ(G1CodeRootSet::static_mem_size(), sizeof (void*)) <<\n-          \"The code root set's static memory usage is incorrect, \"\n-          << G1CodeRootSet::static_mem_size() << \" bytes\";\n-\n-  root_set.add((nmethod*) 1);\n-  ASSERT_EQ(root_set.length(), (size_t) 1) << \"Added exactly one element, but\"\n-          \" set contains \" << root_set.length() << \" elements\";\n-\n-  const size_t num_to_add = (size_t) threshold() + 1;\n-\n-  for (size_t i = 1; i <= num_to_add; i++) {\n-    root_set.add((nmethod*) 1);\n-  }\n-  ASSERT_EQ(root_set.length(), (size_t) 1)\n-          << \"Duplicate detection should not have increased the set size but \"\n-          << \"is \" << root_set.length();\n-\n-  for (size_t i = 2; i <= num_to_add; i++) {\n-    root_set.add((nmethod*) (uintptr_t) (i));\n-  }\n-\n-  ASSERT_EQ(root_set.length(), num_to_add)\n-          << \"After adding in total \" << num_to_add << \" distinct code roots, \"\n-          \"they need to be in the set, but there are only \" << root_set.length();\n-\n-  ASSERT_NE(purge_list(), (G1CodeRootSetTable*) NULL)\n-          << \"should have grown to large hashtable\";\n-\n-  size_t num_popped = 0;\n-  for (size_t i = 1; i <= num_to_add; i++) {\n-    bool removed = root_set.remove((nmethod*) i);\n-    if (removed) {\n-      num_popped += 1;\n-    } else {\n-      break;\n-    }\n-  }\n-  ASSERT_EQ(num_popped, num_to_add)\n-          << \"Managed to pop \" << num_popped << \" code roots, but only \"\n-          << num_to_add << \" were added\";\n-  ASSERT_NE(purge_list(), (G1CodeRootSetTable*) NULL)\n-          << \"should have grown to large hashtable\";\n-\n-  G1CodeRootSet::purge();\n-\n-  ASSERT_EQ(purge_list(), (G1CodeRootSetTable*) NULL)\n-          << \"should have purged old small tables\";\n-}\n","filename":"test\/hotspot\/gtest\/gc\/g1\/test_g1CodeCacheRemSet.cpp","additions":0,"deletions":93,"binary":false,"changes":93,"status":"deleted"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/g1\/g1CodeRootSet.hpp\"\n+#include \"unittest.hpp\"\n+\n+class G1CodeRootSetTest : public ::testing::Test {\n+ public:\n+\n+  size_t threshold() {\n+    return G1CodeRootSet::Threshold;\n+  }\n+};\n+\n+TEST_VM_F(G1CodeRootSetTest, g1_code_cache_rem_set) {\n+  G1CodeRootSet root_set;\n+\n+  ASSERT_TRUE(root_set.is_empty()) << \"Code root set must be initially empty \"\n+          \"but is not.\";\n+\n+  root_set.add((nmethod*) 1);\n+  ASSERT_EQ(root_set.length(), (size_t) 1) << \"Added exactly one element, but\"\n+          \" set contains \" << root_set.length() << \" elements\";\n+\n+  const size_t num_to_add = (size_t) threshold() + 1;\n+\n+  for (size_t i = 1; i <= num_to_add; i++) {\n+    root_set.add((nmethod*) 1);\n+  }\n+  ASSERT_EQ(root_set.length(), (size_t) 1)\n+          << \"Duplicate detection should not have increased the set size but \"\n+          << \"is \" << root_set.length();\n+\n+  for (size_t i = 2; i <= num_to_add; i++) {\n+    root_set.add((nmethod*) (uintptr_t) (i));\n+  }\n+\n+  ASSERT_EQ(root_set.length(), num_to_add)\n+          << \"After adding in total \" << num_to_add << \" distinct code roots, \"\n+          \"they need to be in the set, but there are only \" << root_set.length();\n+\n+  ASSERT_EQ(root_set._table->table_size(), 512u)\n+          << \"should have grown to large hashtable\";\n+\n+  size_t num_popped = 0;\n+  for (size_t i = 1; i <= num_to_add; i++) {\n+    bool removed = root_set.remove((nmethod*) i);\n+    if (removed) {\n+      num_popped += 1;\n+    } else {\n+      break;\n+    }\n+  }\n+  ASSERT_EQ(num_popped, num_to_add)\n+          << \"Managed to pop \" << num_popped << \" code roots, but only \"\n+          << num_to_add << \" were added\";\n+  ASSERT_EQ(root_set.length(), 0u)\n+          << \"should have grown to large hashtable\";\n+}\n","filename":"test\/hotspot\/gtest\/gc\/g1\/test_g1CodeRootSet.cpp","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -111,1 +111,0 @@\n-            \"PurgeCodeRoots\",\n","filename":"test\/jdk\/jdk\/jfr\/event\/gc\/collection\/TestG1ParallelPhases.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"}]}