{"files":[{"patch":"@@ -43,30 +43,3 @@\n-  return sizeof(G1CodeRootSetTable) + (entry_size() * number_of_entries()) + (sizeof(HashtableBucket<mtGC>) * table_size());\n-}\n-\n-G1CodeRootSetTable::Entry* G1CodeRootSetTable::new_entry(nmethod* nm) {\n-  unsigned int hash = compute_hash(nm);\n-  return (Entry*)Hashtable<nmethod*, mtGC>::new_entry(hash, nm);\n-}\n-\n-void G1CodeRootSetTable::remove_entry(Entry* e, Entry* previous) {\n-  int index = hash_to_index(e->hash());\n-  assert((e == bucket(index)) == (previous == NULL), \"if e is the first entry then previous should be null\");\n-\n-  if (previous == NULL) {\n-    set_entry(index, e->next());\n-  } else {\n-    previous->set_next(e->next());\n-  }\n-  free_entry(e);\n-}\n-\n-G1CodeRootSetTable::~G1CodeRootSetTable() {\n-  for (int index = 0; index < table_size(); ++index) {\n-    for (Entry* e = bucket(index); e != NULL; ) {\n-      Entry* to_remove = e;\n-      \/\/ read next before freeing.\n-      e = e->next();\n-      BasicHashtable<mtGC>::free_entry(to_remove);\n-    }\n-  }\n-  assert(number_of_entries() == 0, \"should have removed all entries\");\n+  return sizeof(*this) +\n+    _table.table_size() * sizeof(Table::Node*) +\n+    _table.number_of_entries() * sizeof(Table::Node);\n@@ -77,3 +50,1 @@\n-    Entry* e = new_entry(nm);\n-    int index = hash_to_index(e->hash());\n-    add_entry(index, e);\n+    _table.put(nm, nm);\n@@ -86,7 +57,1 @@\n-  int index = hash_to_index(compute_hash(nm));\n-  for (Entry* e = bucket(index); e != NULL; e = e->next()) {\n-    if (e->literal() == nm) {\n-      return true;\n-    }\n-  }\n-  return false;\n+  return _table.contains(nm);\n@@ -96,9 +61,1 @@\n-  int index = hash_to_index(compute_hash(nm));\n-  Entry* previous = NULL;\n-  for (Entry* e = bucket(index); e != NULL; previous = e, e = e->next()) {\n-    if (e->literal() == nm) {\n-      remove_entry(e, previous);\n-      return true;\n-    }\n-  }\n-  return false;\n+  return _table.remove(nm);\n@@ -108,5 +65,3 @@\n-  for (int index = 0; index < table_size(); ++index) {\n-    for (Entry* e = bucket(index); e != NULL; e = e->next()) {\n-      new_table->add(e->literal());\n-    }\n-  }\n+  _table.iterate_all([&new_table](nmethod* nm, nmethod* _) {\n+    new_table->add(nm);\n+  });\n@@ -116,5 +71,3 @@\n-  for (int index = 0; index < table_size(); ++index) {\n-    for (Entry* e = bucket(index); e != NULL; e = e->next()) {\n-      blk->do_code_blob(e->literal());\n-    }\n-  }\n+  _table.iterate_all([&](nmethod* nm, nmethod* _) {\n+    blk->do_code_blob(nm);\n+  });\n@@ -124,17 +77,2 @@\n-int G1CodeRootSetTable::remove_if(CB& should_remove) {\n-  int num_removed = 0;\n-  for (int index = 0; index < table_size(); ++index) {\n-    Entry* previous = NULL;\n-    Entry* e = bucket(index);\n-    while (e != NULL) {\n-      Entry* next = e->next();\n-      if (should_remove(e->literal())) {\n-        remove_entry(e, previous);\n-        ++num_removed;\n-      } else {\n-        previous = e;\n-      }\n-      e = next;\n-    }\n-  }\n-  return num_removed;\n+void G1CodeRootSetTable::remove_if(CB& should_remove) {\n+  _table.unlink_destruct([&](nmethod* nm, nmethod* nm2){ return should_remove(nm);});\n@@ -202,1 +140,1 @@\n-    if (_length == Threshold) {\n+    if (length() == Threshold) {\n@@ -205,1 +143,0 @@\n-    ++_length;\n@@ -207,1 +144,0 @@\n-  assert(_length == (size_t)_table->number_of_entries(), \"sizes should match\");\n@@ -216,2 +152,1 @@\n-    _length--;\n-    if (_length == 0) {\n+    if (length() == 0) {\n@@ -221,2 +156,0 @@\n-  assert((_length == 0 && _table == NULL) ||\n-         (_length == (size_t)_table->number_of_entries()), \"sizes should match\");\n@@ -237,1 +170,0 @@\n-  _length = 0;\n@@ -289,3 +221,1 @@\n-    int removed = _table->remove_if(should_clean);\n-    assert((size_t)removed <= _length, \"impossible\");\n-    _length -= removed;\n+    _table->remove_if(should_clean);\n@@ -293,1 +223,1 @@\n-  if (_length == 0) {\n+  if (length() == 0) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CodeCacheRemSet.cpp","additions":18,"deletions":88,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/g1\/g1CodeRootSetTable.hpp\"\n@@ -48,2 +49,0 @@\n-  size_t _length;\n-\n@@ -54,1 +53,1 @@\n-  G1CodeRootSet() : _table(NULL), _length(0) {}\n+  G1CodeRootSet() : _table(nullptr) {}\n@@ -76,3 +75,1 @@\n-    bool empty = length() == 0;\n-    assert(empty == (_table == NULL), \"is empty only if table is deallocated\");\n-    return empty;\n+    return length() == 0;\n@@ -82,1 +79,1 @@\n-  size_t length() const { return _length; }\n+  size_t length() const { return _table == nullptr ? 0 : _table->number_of_entries(); }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CodeCacheRemSet.hpp","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -27,1 +27,4 @@\n-#include \"utilities\/hashtable.hpp\"\n+#include \"code\/codeCache.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"utilities\/resizeableResourceHash.hpp\"\n+#include \"utilities\/resourceHash.hpp\"\n@@ -31,1 +34,1 @@\n-class G1CodeRootSetTable : public Hashtable<nmethod*, mtGC> {\n+class G1CodeRootSetTable : public CHeapObj<mtGC>  {\n@@ -33,1 +36,0 @@\n-  typedef HashtableEntry<nmethod*, mtGC> Entry;\n@@ -37,0 +39,2 @@\n+  using Table = ResizeableResourceHashtable<nmethod*, nmethod*, AnyObj::C_HEAP, mtGC>;\n+  Table _table;\n@@ -44,3 +48,0 @@\n-  void remove_entry(Entry* e, Entry* previous);\n-  Entry* new_entry(nmethod* nm);\n-\n@@ -48,3 +49,1 @@\n-  G1CodeRootSetTable(int size) : Hashtable<nmethod*, mtGC>(size, sizeof(Entry)), _purge_next(NULL) {}\n-  ~G1CodeRootSetTable();\n-\n+  G1CodeRootSetTable(int size) : _table(size, size), _purge_next(NULL) {}\n@@ -58,2 +57,0 @@\n-  int entry_size() const { return BasicHashtable<mtGC>::entry_size(); }\n-\n@@ -64,1 +61,2 @@\n-  int remove_if(CB& should_remove);\n+  void remove_if(CB& should_remove);\n+  int number_of_entries() const {return _table.number_of_entries();}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CodeRootSetTable.hpp","additions":10,"deletions":12,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -86,1 +86,0 @@\n-  using Node = ResourceHashtableNode<K, V>;\n@@ -89,0 +88,1 @@\n+  using Node = ResourceHashtableNode<K, V>;\n","filename":"src\/hotspot\/share\/utilities\/resizeableResourceHash.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -277,0 +277,30 @@\n+  \/\/ The argument should_remove() have the signature: bool Function(K const&, V const&).\n+  \/\/ The predicate should_remove() will be called for each entry in the table.\n+  \/\/ If should_remove() returns true, the element will be removed from the table.\n+  \/\/ If the Node is C_HEAP allocated the entry is deleted, else the destructor\n+  \/\/ of the Node will be called. Unlike unlink (above), this method uses a functor\n+  \/\/ interface and will call the destructor of the Node, and thus the destructor\n+  \/\/ of the element (even if the Node is resource allocated).\n+  template<typename Function>\n+  void unlink_destruct(Function&& should_remove) {\n+    const unsigned sz = table_size();\n+    for (unsigned index = 0; index < sz; index++) {\n+      Node** ptr = bucket_at(index);\n+      while (*ptr != nullptr) {\n+        Node* node = *ptr;\n+        bool clean = should_remove(node->_key, node->_value);\n+        if (clean) {\n+          *ptr = node->_next;\n+          if (ALLOC_TYPE == AnyObj::C_HEAP) {\n+            delete node;\n+          } else {\n+            node->~Node();\n+          }\n+          _number_of_entries --;\n+        } else {\n+          ptr = &(node->_next);\n+        }\n+      }\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/utilities\/resourceHash.hpp","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"}]}