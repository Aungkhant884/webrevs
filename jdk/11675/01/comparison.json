{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,30 +43,3 @@\n-  return sizeof(G1CodeRootSetTable) + (entry_size() * number_of_entries()) + (sizeof(HashtableBucket<mtGC>) * table_size());\n-}\n-\n-G1CodeRootSetTable::Entry* G1CodeRootSetTable::new_entry(nmethod* nm) {\n-  unsigned int hash = compute_hash(nm);\n-  return (Entry*)Hashtable<nmethod*, mtGC>::new_entry(hash, nm);\n-}\n-\n-void G1CodeRootSetTable::remove_entry(Entry* e, Entry* previous) {\n-  int index = hash_to_index(e->hash());\n-  assert((e == bucket(index)) == (previous == NULL), \"if e is the first entry then previous should be null\");\n-\n-  if (previous == NULL) {\n-    set_entry(index, e->next());\n-  } else {\n-    previous->set_next(e->next());\n-  }\n-  free_entry(e);\n-}\n-\n-G1CodeRootSetTable::~G1CodeRootSetTable() {\n-  for (int index = 0; index < table_size(); ++index) {\n-    for (Entry* e = bucket(index); e != NULL; ) {\n-      Entry* to_remove = e;\n-      \/\/ read next before freeing.\n-      e = e->next();\n-      BasicHashtable<mtGC>::free_entry(to_remove);\n-    }\n-  }\n-  assert(number_of_entries() == 0, \"should have removed all entries\");\n+  return sizeof(*this) +\n+    _table.table_size() * sizeof(Table::Node*) +\n+    _table.number_of_entries() * sizeof(Table::Node);\n@@ -77,3 +50,1 @@\n-    Entry* e = new_entry(nm);\n-    int index = hash_to_index(e->hash());\n-    add_entry(index, e);\n+    _table.put(nm, nm);\n@@ -86,7 +57,1 @@\n-  int index = hash_to_index(compute_hash(nm));\n-  for (Entry* e = bucket(index); e != NULL; e = e->next()) {\n-    if (e->literal() == nm) {\n-      return true;\n-    }\n-  }\n-  return false;\n+  return _table.contains(nm);\n@@ -96,9 +61,1 @@\n-  int index = hash_to_index(compute_hash(nm));\n-  Entry* previous = NULL;\n-  for (Entry* e = bucket(index); e != NULL; previous = e, e = e->next()) {\n-    if (e->literal() == nm) {\n-      remove_entry(e, previous);\n-      return true;\n-    }\n-  }\n-  return false;\n+  return _table.remove(nm);\n@@ -108,5 +65,3 @@\n-  for (int index = 0; index < table_size(); ++index) {\n-    for (Entry* e = bucket(index); e != NULL; e = e->next()) {\n-      new_table->add(e->literal());\n-    }\n-  }\n+  _table.iterate_all([&new_table](nmethod* nm, nmethod* _) {\n+    new_table->add(nm);\n+  });\n@@ -116,5 +71,3 @@\n-  for (int index = 0; index < table_size(); ++index) {\n-    for (Entry* e = bucket(index); e != NULL; e = e->next()) {\n-      blk->do_code_blob(e->literal());\n-    }\n-  }\n+  _table.iterate_all([&](nmethod* nm, nmethod* _) {\n+    blk->do_code_blob(nm);\n+  });\n@@ -124,17 +77,2 @@\n-int G1CodeRootSetTable::remove_if(CB& should_remove) {\n-  int num_removed = 0;\n-  for (int index = 0; index < table_size(); ++index) {\n-    Entry* previous = NULL;\n-    Entry* e = bucket(index);\n-    while (e != NULL) {\n-      Entry* next = e->next();\n-      if (should_remove(e->literal())) {\n-        remove_entry(e, previous);\n-        ++num_removed;\n-      } else {\n-        previous = e;\n-      }\n-      e = next;\n-    }\n-  }\n-  return num_removed;\n+void G1CodeRootSetTable::remove_if(CB& should_remove) {\n+  _table.unlink(&should_remove);\n@@ -202,1 +140,1 @@\n-    if (_length == Threshold) {\n+    if (length() == Threshold) {\n@@ -205,1 +143,0 @@\n-    ++_length;\n@@ -207,1 +144,0 @@\n-  assert(_length == (size_t)_table->number_of_entries(), \"sizes should match\");\n@@ -216,2 +152,1 @@\n-    _length--;\n-    if (_length == 0) {\n+    if (length() == 0) {\n@@ -221,2 +156,0 @@\n-  assert((_length == 0 && _table == NULL) ||\n-         (_length == (size_t)_table->number_of_entries()), \"sizes should match\");\n@@ -237,1 +170,0 @@\n-  _length = 0;\n@@ -251,0 +183,1 @@\n+  NONCOPYABLE(CleanCallback); \/\/ can not copy, _blobs will point to old copy\n@@ -279,1 +212,1 @@\n-  bool operator() (nmethod* nm) {\n+  bool do_entry(nmethod* nm, nmethod* _) {\n@@ -289,3 +222,1 @@\n-    int removed = _table->remove_if(should_clean);\n-    assert((size_t)removed <= _length, \"impossible\");\n-    _length -= removed;\n+    _table->remove_if(should_clean);\n@@ -293,1 +224,1 @@\n-  if (_length == 0) {\n+  if (length() == 0) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CodeCacheRemSet.cpp","additions":21,"deletions":90,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include \"gc\/g1\/g1CodeRootSetTable.hpp\"\n@@ -48,2 +49,0 @@\n-  size_t _length;\n-\n@@ -54,1 +53,1 @@\n-  G1CodeRootSet() : _table(NULL), _length(0) {}\n+  G1CodeRootSet() : _table(nullptr) {}\n@@ -76,3 +75,1 @@\n-    bool empty = length() == 0;\n-    assert(empty == (_table == NULL), \"is empty only if table is deallocated\");\n-    return empty;\n+    return length() == 0;\n@@ -82,1 +79,1 @@\n-  size_t length() const { return _length; }\n+  size_t length() const { return _table == nullptr ? 0 : _table->number_of_entries(); }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CodeCacheRemSet.hpp","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,4 @@\n-#include \"utilities\/hashtable.hpp\"\n+#include \"code\/codeCache.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"utilities\/resizeableResourceHash.hpp\"\n+#include \"utilities\/resourceHash.hpp\"\n@@ -31,1 +34,1 @@\n-class G1CodeRootSetTable : public Hashtable<nmethod*, mtGC> {\n+class G1CodeRootSetTable : public CHeapObj<mtGC>  {\n@@ -33,1 +36,0 @@\n-  typedef HashtableEntry<nmethod*, mtGC> Entry;\n@@ -37,0 +39,2 @@\n+  using Table = ResizeableResourceHashtable<nmethod*, nmethod*, AnyObj::C_HEAP, mtGC>;\n+  Table _table;\n@@ -44,3 +48,0 @@\n-  void remove_entry(Entry* e, Entry* previous);\n-  Entry* new_entry(nmethod* nm);\n-\n@@ -48,3 +49,1 @@\n-  G1CodeRootSetTable(int size) : Hashtable<nmethod*, mtGC>(size, sizeof(Entry)), _purge_next(NULL) {}\n-  ~G1CodeRootSetTable();\n-\n+  G1CodeRootSetTable(int size) : _table(size, size), _purge_next(NULL) {}\n@@ -58,2 +57,0 @@\n-  int entry_size() const { return BasicHashtable<mtGC>::entry_size(); }\n-\n@@ -64,1 +61,2 @@\n-  int remove_if(CB& should_remove);\n+  void remove_if(CB& should_remove);\n+  int number_of_entries() const {return _table.number_of_entries();}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CodeRootSetTable.hpp","additions":11,"deletions":13,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -86,1 +86,0 @@\n-  using Node = ResourceHashtableNode<K, V>;\n@@ -89,0 +88,1 @@\n+  using Node = ResourceHashtableNode<K, V>;\n","filename":"src\/hotspot\/share\/utilities\/resizeableResourceHash.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}