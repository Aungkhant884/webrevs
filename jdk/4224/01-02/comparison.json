{"files":[{"patch":"@@ -756,1 +756,3 @@\n-    return _current_pending_monitor;\n+    \/\/ Using atomic load to prevent compilers from reloading (ThreadService::get_current_contended_monitor).\n+    \/\/ In case of concurrent modification, reloading pointer after NULL check must be prevented.\n+    return Atomic::load(&_current_pending_monitor);\n@@ -759,1 +761,1 @@\n-    _current_pending_monitor = monitor;\n+    Atomic::store(&_current_pending_monitor, monitor);\n@@ -768,1 +770,2 @@\n-    return _current_waiting_monitor;\n+    \/\/ Using atomic load as in current_pending_monitor.\n+    return Atomic::load(&_current_waiting_monitor);\n@@ -771,1 +774,1 @@\n-    _current_waiting_monitor = monitor;\n+    Atomic::store(&_current_waiting_monitor, monitor);\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -232,4 +232,1 @@\n-\n-  \/\/ Using 'volatile' to prevent the compiler from generating code that\n-  \/\/ reloads 'wait_obj' from memory when used below.\n-  ObjectMonitor* volatile wait_obj = thread->current_waiting_monitor();\n+  ObjectMonitor *wait_obj = thread->current_waiting_monitor();\n@@ -242,3 +239,1 @@\n-    \/\/ Using 'volatile' to prevent the compiler from generating code that\n-    \/\/ reloads 'enter_obj' from memory when used below.\n-    ObjectMonitor* volatile enter_obj = thread->current_pending_monitor();\n+    ObjectMonitor *enter_obj = thread->current_pending_monitor();\n","filename":"src\/hotspot\/share\/services\/threadService.cpp","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"}]}