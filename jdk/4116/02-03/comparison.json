{"files":[{"patch":"@@ -28,0 +28,2 @@\n+#include \"gc\/g1\/g1CardSet.hpp\"\n+#include \"gc\/g1\/g1CardSetContainers.inline.hpp\"\n@@ -58,1 +60,1 @@\n-  G1CardSetConfiguration::initialize_globals();\n+  initialize_card_set_configuration();\n@@ -118,0 +120,34 @@\n+\n+void G1Arguments::initialize_card_set_configuration() {\n+  assert(HeapRegion::LogOfHRGrainBytes != 0, \"not initialized\");\n+  \/\/ Array of Cards card set container globals.\n+  const int LOG_M = 20;\n+  uint region_size_log_mb = (uint)MAX2(HeapRegion::LogOfHRGrainBytes - LOG_M, 0);\n+\n+  if (FLAG_IS_DEFAULT(G1RemSetArrayOfCardsEntries)) {\n+    uint num_cards_in_inline_ptr = G1CardSetConfiguration::num_cards_in_inline_ptr(HeapRegion::LogOfHRGrainBytes - CardTable::card_shift);\n+    FLAG_SET_ERGO(G1RemSetArrayOfCardsEntries, MAX2(num_cards_in_inline_ptr * 2,\n+                                                    G1RemSetArrayOfCardsEntriesBase * (1u << (region_size_log_mb + 1))));\n+  }\n+\n+  \/\/ Round to next 8 byte boundary for array to maximize space usage.\n+  size_t const cur_size = G1CardSetArray::size_in_bytes(G1RemSetArrayOfCardsEntries);\n+  FLAG_SET_ERGO(G1RemSetArrayOfCardsEntries,\n+                G1RemSetArrayOfCardsEntries + (uint)(align_up(cur_size, G1CardSetAllocOptions::BufferAlignment) - cur_size) \/ sizeof(G1CardSetArray::EntryDataType));\n+\n+  \/\/ Howl card set container globals.\n+  if (FLAG_IS_DEFAULT(G1RemSetHowlNumBuckets)) {\n+    FLAG_SET_ERGO(G1RemSetHowlNumBuckets, G1CardSetHowl::num_buckets(HeapRegion::CardsPerRegion,\n+                                                                     G1RemSetArrayOfCardsEntries,\n+                                                                     G1RemSetHowlMaxNumBuckets));\n+  }\n+\n+  if (FLAG_IS_DEFAULT(G1RemSetHowlMaxNumBuckets)) {\n+    FLAG_SET_ERGO(G1RemSetHowlMaxNumBuckets, MAX2(G1RemSetHowlMaxNumBuckets, G1RemSetHowlNumBuckets));\n+  } else if (G1RemSetHowlMaxNumBuckets < G1RemSetHowlNumBuckets) {\n+    FormatBuffer<> buf(\"Maximum Howl card set container bucket size %u smaller than requested bucket size %u\",\n+                       G1RemSetHowlMaxNumBuckets, G1RemSetHowlNumBuckets);\n+    vm_exit_during_initialization(buf);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Arguments.cpp","additions":37,"deletions":1,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+  static void initialize_card_set_configuration();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Arguments.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -47,32 +47,0 @@\n-void G1CardSetConfiguration::initialize_globals() {\n-  assert(HeapRegion::LogOfHRGrainBytes != 0, \"not initialized\");\n-  \/\/ Array of Cards card set container globals.\n-  const int LOG_M = 20;\n-  uint region_size_log_mb = (uint)MAX2(HeapRegion::LogOfHRGrainBytes - LOG_M, 0);\n-\n-  if (FLAG_IS_DEFAULT(G1RemSetArrayOfCardsEntries)) {\n-    FLAG_SET_ERGO(G1RemSetArrayOfCardsEntries, MAX2(num_cards_in_inline_ptr(HeapRegion::LogOfHRGrainBytes - CardTable::card_shift) * 2,\n-                                                    G1RemSetArrayOfCardsEntriesBase * (1u << (region_size_log_mb + 1))));\n-  }\n-\n-  \/\/ Round to next 8 byte boundary for array to maximize space usage.\n-  size_t const cur_size = G1CardSetArray::size_in_bytes(G1RemSetArrayOfCardsEntries);\n-  FLAG_SET_ERGO(G1RemSetArrayOfCardsEntries,\n-                G1RemSetArrayOfCardsEntries + (uint)(align_up(cur_size, G1CardSetAllocOptions::BufferAlignment) - cur_size) \/ sizeof(G1CardSetArray::EntryDataType));\n-\n-  \/\/ Howl card set container globals.\n-  if (FLAG_IS_DEFAULT(G1RemSetHowlNumBuckets)) {\n-    FLAG_SET_ERGO(G1RemSetHowlNumBuckets, G1CardSetHowl::num_buckets(HeapRegion::CardsPerRegion,\n-                                                                     G1RemSetArrayOfCardsEntries,\n-                                                                     G1RemSetHowlMaxNumBuckets));\n-  }\n-\n-  if (FLAG_IS_DEFAULT(G1RemSetHowlMaxNumBuckets)) {\n-    FLAG_SET_ERGO(G1RemSetHowlMaxNumBuckets, MAX2(G1RemSetHowlMaxNumBuckets, G1RemSetHowlNumBuckets));\n-  } else if (G1RemSetHowlMaxNumBuckets < G1RemSetHowlNumBuckets) {\n-    FormatBuffer<> buf(\"Maximum Howl card set container bucket size %u smaller than requested bucket size %u\",\n-                       G1RemSetHowlMaxNumBuckets, G1RemSetHowlNumBuckets);\n-    vm_exit_during_initialization(buf);\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSet.cpp","additions":0,"deletions":32,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-  \/\/ Updates and verifies consistency card set (container) globals.\n+  \/\/ Updates and verifies consistency of card set (container) globals.\n@@ -342,2 +342,2 @@\n-  template <class Closure>\n-  void iterate_for_merge(Closure& cl);\n+  template <class CardOrRangeVisitor>\n+  void iterate_for_merge(CardOrRangeVisitor& cl);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSet.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -119,3 +119,3 @@\n-template <class Closure>\n-inline void G1CardSet::iterate_for_merge(Closure& cl) {\n-  G1CardSetMergeCardIterator<Closure, G1ContainerCardsOrRanges> cl2(this, cl);\n+template <class CardOrRangeVisitor>\n+inline void G1CardSet::iterate_for_merge(CardOrRangeVisitor& cl) {\n+  G1CardSetMergeCardIterator<CardOrRangeVisitor, G1ContainerCardsOrRanges> cl2(this, cl);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSet.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -349,1 +349,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetContainers.inline.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -850,0 +850,1 @@\n+  \/\/ Global card set configuration\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1219,1 +1219,1 @@\n-    \/\/ Helper to put the remembered set cards for these regions onto the card\n+    \/\/ Helper to merge the cards in the card set for the given region onto the card\n@@ -1233,1 +1233,1 @@\n-    void dump_rem_set_for_region(HeapRegion* r) {\n+    void merge_card_set_for_region(HeapRegion* r) {\n@@ -1238,1 +1238,1 @@\n-        rem_set->iterate_prts(*this);\n+        rem_set->iterate_for_merge(*this);\n@@ -1246,1 +1246,1 @@\n-      dump_rem_set_for_region(r);\n+      merge_card_set_for_region(r);\n@@ -1278,1 +1278,1 @@\n-        cl.dump_rem_set_for_region(r);\n+        cl.merge_card_set_for_region(r);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -72,8 +72,5 @@\n-  \/\/ For each PRT in the card (remembered) set call one of the following methods\n-  \/\/ of the given closure:\n-  \/\/\n-  \/\/ set_full_region_dirty(uint region_idx) - pass the region index for coarse PRTs\n-  \/\/ set_bitmap_dirty(uint region_idx, BitMap* bitmap) - pass the region index and bitmap for fine PRTs\n-  \/\/ set_cards_dirty(uint region_idx, elem_t* cards, uint num_cards) - pass region index and cards for sparse PRTs\n-  template <class Closure>\n-  inline void iterate_prts(Closure& cl);\n+  \/\/ Iterate the card based remembered set for merging them into the card table.\n+  \/\/ The passed closure must be a CardOrRangeVisitor; we use a template parameter\n+  \/\/ to pass it in to facilitate inlining as much as possible.\n+  template <class CardOrRangeVisitor>\n+  inline void iterate_for_merge(CardOrRangeVisitor& cl);\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionRemSet.hpp","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -56,2 +56,2 @@\n-template <class Closure>\n-inline void HeapRegionRemSet::iterate_prts(Closure& cl) {\n+template <class CardOrRangeVisitor>\n+inline void HeapRegionRemSet::iterate_for_merge(CardOrRangeVisitor& cl) {\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionRemSet.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}