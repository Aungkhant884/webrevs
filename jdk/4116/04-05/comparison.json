{"files":[{"patch":"@@ -231,0 +231,8 @@\n+\n+  \/\/ Verify that the maximum parallelism isn't too high to eventually overflow\n+  \/\/ the refcount in G1CardSetContainerOnHeap.\n+  uint max_parallel_refinement_threads = G1ConcRefinementThreads + G1DirtyCardQueueSet::num_par_ids();\n+  uint const divisor = 3;  \/\/ Safe divisor; we increment by 2 for each claim, but there is a small initial value.\n+  if (max_parallel_refinement_threads > UINTPTR_MAX \/ divisor) {\n+    vm_exit_during_initialization(\"Too large parallelism for remembered sets.\");\n+  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Arguments.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -100,1 +100,1 @@\n-                          \"Howl Bitmap #elems %u %zu coarsen threshold %u\",\n+                          \"Howl Bitmap #elems %u size %zu coarsen threshold %u\",\n@@ -355,1 +355,1 @@\n-    G1CardSetOnHeap* card_set = (G1CardSetOnHeap*)value;\n+    G1CardSetContainerOnHeap* card_set = (G1CardSetContainerOnHeap*)value;\n@@ -376,1 +376,1 @@\n-    G1CardSetOnHeap* card_set_on_heap = (G1CardSetOnHeap*)strip_card_set_type(card_set);\n+    G1CardSetContainerOnHeap* card_set_on_heap = (G1CardSetContainerOnHeap*)strip_card_set_type(card_set);\n@@ -391,1 +391,1 @@\n-  G1CardSetOnHeap* card_set_on_heap = (G1CardSetOnHeap*)strip_card_set_type(card_set);\n+  G1CardSetContainerOnHeap* card_set_on_heap = (G1CardSetContainerOnHeap*)strip_card_set_type(card_set);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSet.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-class G1CardSetOnHeap;\n@@ -63,2 +62,0 @@\n-  \/\/ Updates and verifies consistency of card set (container) globals.\n-  static void initialize_globals();\n@@ -77,1 +74,0 @@\n-  bool use_inline_ptr() const { return true; } \/\/ Unused for now\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSet.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -95,11 +95,20 @@\n-class G1CardSetOnHeap {\n-public:\n-  \/\/ We utilise the reference count for memory management.\n-  \/\/ The object is one of three states:\n-  \/\/ 1: Live: The object is visible to other threads, thus can\n-  \/\/    safely be accessed by other threads (_ref_count >= 3).\n-  \/\/ 2: Dead: The object is visible to only a single thread and may be\n-  \/\/    safely reclaimed (_ref_count == 1).\n-  \/\/ 3: Reclaimed: The object's memory has been reclaimed ((_ref_count & 0x1) == 0).\n-  \/\/ To maintain these constraints, live objects should have ((_ref_count & 0x1) == 1),\n-  \/\/ which requires that we increment the reference counts by 2 starting at _ref_count = 3.\n+\n+\/\/ Common base class for card set container related objects managed on the heap. Depending\n+\/\/ on the current use, one of the two overlapping elements are used:\n+\/\/\n+\/\/ While such an object is assigned to a card set container, we utilize the\n+\/\/ reference count for memory management.\n+\/\/\n+\/\/ In this case the object is one of three states:\n+\/\/ 1: Live: The object is visible to other threads, thus can\n+\/\/    safely be accessed by other threads (_ref_count >= 3).\n+\/\/ 2: Dead: The object is visible to only a single thread and may be\n+\/\/    safely reclaimed (_ref_count == 1).\n+\/\/ 3: Reclaimed: The object's memory has been reclaimed ((_ref_count & 0x1) == 0).\n+\/\/ To maintain these constraints, live objects should have ((_ref_count & 0x1) == 1),\n+\/\/ which requires that we increment the reference counts by 2 starting at _ref_count = 3.\n+\/\/\n+\/\/ When such an object is on a free list, we reuse the same field for linking\n+\/\/ together those free objects.\n+class G1CardSetContainerOnHeap {\n+private:\n@@ -107,2 +116,2 @@\n-    G1CardSetOnHeap* _next;\n-    uint64_t _ref_count;\n+    G1CardSetContainerOnHeap* _next;\n+    uintptr_t _ref_count;\n@@ -111,1 +120,2 @@\n-  G1CardSetOnHeap() : _ref_count(3) { }\n+public:\n+  G1CardSetContainerOnHeap() : _ref_count(3) { }\n@@ -113,1 +123,1 @@\n-  uint64_t refcount() const { return Atomic::load_acquire(&_ref_count); }\n+  uintptr_t refcount() const { return Atomic::load_acquire(&_ref_count); }\n@@ -119,1 +129,13 @@\n-  uint64_t decrement_refcount();\n+  uintptr_t decrement_refcount();\n+\n+  G1CardSetContainerOnHeap* next() {\n+    return _next;\n+  }\n+\n+  G1CardSetContainerOnHeap** next_addr() {\n+    return &_next;\n+  }\n+\n+  void set_next(G1CardSetContainerOnHeap* next) {\n+    _next = next;\n+  }\n@@ -122,1 +144,1 @@\n-class G1CardSetArray : public G1CardSetOnHeap {\n+class G1CardSetArray : public G1CardSetContainerOnHeap {\n@@ -177,1 +199,1 @@\n-class G1CardSetBitMap : public G1CardSetOnHeap {\n+class G1CardSetBitMap : public G1CardSetContainerOnHeap {\n@@ -213,1 +235,1 @@\n-class G1CardSetHowl : public G1CardSetOnHeap {\n+class G1CardSetHowl : public G1CardSetContainerOnHeap {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetContainers.hpp","additions":41,"deletions":19,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -102,2 +102,2 @@\n-inline bool G1CardSetOnHeap::try_increment_refcount() {\n-  uint64_t old_value = refcount();\n+inline bool G1CardSetContainerOnHeap::try_increment_refcount() {\n+  uintptr_t old_value = refcount();\n@@ -109,2 +109,2 @@\n-    uint64_t new_value = old_value + 2;\n-    uint64_t ref_count = Atomic::cmpxchg(&_ref_count, old_value, new_value);\n+    uintptr_t new_value = old_value + 2;\n+    uintptr_t ref_count = Atomic::cmpxchg(&_ref_count, old_value, new_value);\n@@ -118,14 +118,4 @@\n-inline uint64_t G1CardSetOnHeap::decrement_refcount() {\n-  \/\/ There is no 64 bit Atomic::sub() for 32 bit platforms. Emulate using cmpxchg.\n-  uint64_t old_value = refcount();\n-  while (true) {\n-    assert((old_value & 0x1) != 0, \"precondition\");\n-    assert(old_value >= 3, \"precondition\");\n-\n-    uint64_t new_value = old_value - 2;\n-    uint64_t ref_count = Atomic::cmpxchg(&_ref_count, old_value, new_value);\n-    if (ref_count == old_value) {\n-      return new_value;\n-    }\n-    old_value = ref_count;\n-  }\n+inline uintptr_t G1CardSetContainerOnHeap::decrement_refcount() {\n+  uintptr_t old_value = refcount();\n+  assert((old_value & 0x1) != 0 && old_value >= 3, \"precondition\");\n+  return Atomic::sub(&_ref_count, 2u);\n@@ -135,1 +125,1 @@\n-  G1CardSetOnHeap(),\n+  G1CardSetContainerOnHeap(),\n@@ -219,1 +209,1 @@\n-  G1CardSetOnHeap(), _num_bits_set(1) {\n+  G1CardSetContainerOnHeap(), _num_bits_set(1) {\n@@ -250,1 +240,1 @@\n-  G1CardSetOnHeap(),\n+  G1CardSetContainerOnHeap(),\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetContainers.inline.hpp","additions":11,"deletions":21,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"logging\/log.hpp\"\n@@ -122,1 +123,1 @@\n-  assert(elem_size() >= sizeof(G1CardSetOnHeap), \"Element instance size %u for allocator %s too small\",\n+  assert(elem_size() >= sizeof(G1CardSetContainerOnHeap), \"Element instance size %u for allocator %s too small\",\n@@ -137,1 +138,1 @@\n-  G1CardSetMemoryObject* first = _pending_nodes_list.pop_all();\n+  G1CardSetContainerOnHeap* first = _pending_nodes_list.pop_all();\n@@ -141,1 +142,1 @@\n-    G1CardSetMemoryObject* last = first;\n+    G1CardSetContainerOnHeap* last = first;\n@@ -145,1 +146,1 @@\n-    for (G1CardSetMemoryObject* next = first->next(); next != nullptr; next = next->next()) {\n+    for (G1CardSetContainerOnHeap* next = first->next(); next != nullptr; next = next->next()) {\n@@ -166,1 +167,1 @@\n-  assert(elem_size() >= sizeof(G1CardSetMemoryObject), \"size mismatch\");\n+  assert(elem_size() >= sizeof(G1CardSetContainerOnHeap), \"size mismatch\");\n@@ -178,1 +179,1 @@\n-  G1CardSetMemoryObject* node =  reinterpret_cast<G1CardSetMemoryObject*>(reinterpret_cast<char*>(elem));\n+  G1CardSetContainerOnHeap* node =  reinterpret_cast<G1CardSetContainerOnHeap*>(reinterpret_cast<char*>(elem));\n@@ -410,1 +411,1 @@\n-  _allocators = NEW_C_HEAP_ARRAY(G1CardSetAllocator<G1CardSetMemoryObject>,\n+  _allocators = NEW_C_HEAP_ARRAY(G1CardSetAllocator<G1CardSetContainerOnHeap>,\n@@ -415,3 +416,3 @@\n-    new (&_allocators[i]) G1CardSetAllocator<G1CardSetMemoryObject>(_config->mem_object_type_name_str(i),\n-                                                                    alloc_options[i],\n-                                                                    free_list_pool->free_list(i));\n+    new (&_allocators[i]) G1CardSetAllocator<G1CardSetContainerOnHeap>(_config->mem_object_type_name_str(i),\n+                                                                       alloc_options[i],\n+                                                                       free_list_pool->free_list(i));\n@@ -431,1 +432,1 @@\n-  FREE_C_HEAP_ARRAY(G1CardSetAllocator<G1CardSetMemoryObject>, _allocators);\n+  FREE_C_HEAP_ARRAY(G1CardSetAllocator<G1CardSetContainerOnHeap>, _allocators);\n@@ -436,1 +437,1 @@\n-  _allocators[type].free((G1CardSetMemoryObject*)value);\n+  _allocators[type].free((G1CardSetContainerOnHeap*)value);\n@@ -458,1 +459,1 @@\n-    (sizeof(G1CardSetAllocator<G1CardSetMemoryObject>) * num_mem_object_types()) +\n+    (sizeof(G1CardSetAllocator<G1CardSetContainerOnHeap>) * num_mem_object_types()) +\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetMemory.cpp","additions":14,"deletions":13,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -28,2 +28,2 @@\n-#include \"gc\/g1\/g1CardSet.hpp\" \/\/ G1CardSetHashTableValue\n-#include \"gc\/g1\/g1CardSetContainers.hpp\" \/\/ G1CardSetOnHeap\n+#include \"gc\/g1\/g1CardSet.hpp\"\n+#include \"gc\/g1\/g1CardSetContainers.hpp\"\n@@ -37,18 +37,0 @@\n-\/\/ An object managed on the heap by card set memory management. Has a next pointer\n-\/\/ to link objects together.\n-struct G1CardSetMemoryObject {\n-  G1CardSetMemoryObject* _next;\n-\n-  G1CardSetMemoryObject* next() {\n-    return _next;\n-  }\n-\n-  G1CardSetMemoryObject** next_addr() {\n-    return &_next;\n-  }\n-\n-  void set_next(G1CardSetMemoryObject* next) {\n-    _next = next;\n-  }\n-};\n-\n@@ -181,1 +163,1 @@\n-\/\/ Allocation and deallocation in the first phase on G1CardSetMemoryObject basis\n+\/\/ Allocation and deallocation in the first phase on G1CardSetContainerOnHeap basis\n@@ -184,1 +166,1 @@\n-\/\/ Allocation occurs from an internal free list of G1CardSetMemoryObjects first,\n+\/\/ Allocation occurs from an internal free list of G1CardSetContainerOnHeaps first,\n@@ -189,1 +171,1 @@\n-\/\/ The G1CardSetMemoryObjects free list is a linked list of G1CardSetMemoryObjects\n+\/\/ The G1CardSetContainerOnHeaps free list is a linked list of G1CardSetContainerOnHeaps\n@@ -217,1 +199,1 @@\n-  \/\/ G1CardSetMemoryObject node management within the G1CardSetBuffers allocated\n+  \/\/ G1CardSetContainerOnHeap node management within the G1CardSetBuffers allocated\n@@ -220,4 +202,2 @@\n-  static G1CardSetMemoryObject* volatile* next_ptr(G1CardSetMemoryObject& node) {\n-    return node.next_addr();\n-  }\n-  typedef LockFreeStack<G1CardSetMemoryObject, &next_ptr> NodeStack;\n+  static G1CardSetContainerOnHeap* volatile* next_ptr(G1CardSetContainerOnHeap& node);\n+  typedef LockFreeStack<G1CardSetContainerOnHeap, &next_ptr> NodeStack;\n@@ -377,1 +357,1 @@\n-  G1CardSetAllocator<G1CardSetMemoryObject>* _allocators;\n+  G1CardSetAllocator<G1CardSetContainerOnHeap>* _allocators;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetMemory.hpp","additions":9,"deletions":29,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"utilities\/globalCounter.inline.hpp\"\n+#include \"gc\/g1\/g1CardSetContainers.hpp\"\n@@ -32,0 +32,8 @@\n+#include \"gc\/g1\/g1CardSetContainers.inline.hpp\"\n+#include \"utilities\/globalCounter.inline.hpp\"\n+\n+template <class Elem>\n+G1CardSetContainerOnHeap* volatile* G1CardSetAllocator<Elem>::next_ptr(G1CardSetContainerOnHeap& node) {\n+  return node.next_addr();\n+}\n+\n@@ -74,1 +82,1 @@\n-    G1CardSetMemoryObject* node = _free_nodes_list.pop();\n+    G1CardSetContainerOnHeap* node = _free_nodes_list.pop();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetMemory.inline.hpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1457,2 +1457,3 @@\n-  Log(gc, remset) log;\n-  LogStream ls(log.debug());\n+  LogTarget(Debug, gc, remset) lt;\n+  if (lt.is_enabled()) {\n+    LogStream ls(lt);\n@@ -1460,1 +1461,1 @@\n-  size_t num_visited_cards = _scan_state->num_visited_cards();\n+    size_t num_visited_cards = _scan_state->num_visited_cards();\n@@ -1462,1 +1463,1 @@\n-  size_t total_dirty_region_cards = _scan_state->num_cards_in_dirty_regions();\n+    size_t total_dirty_region_cards = _scan_state->num_cards_in_dirty_regions();\n@@ -1464,10 +1465,11 @@\n-  G1CollectedHeap* g1h = G1CollectedHeap::heap();\n-  size_t total_old_region_cards =\n-    (g1h->num_regions() - (g1h->num_free_regions() - g1h->collection_set()->cur_length())) * HeapRegion::CardsPerRegion;\n-\n-  ls.print_cr(\"Visited cards \" SIZE_FORMAT \" Total dirty \" SIZE_FORMAT \" (%.2lf%%) Total old \" SIZE_FORMAT \" (%.2lf%%)\",\n-              num_visited_cards,\n-              total_dirty_region_cards,\n-              percent_of(num_visited_cards, total_dirty_region_cards),\n-              total_old_region_cards,\n-              percent_of(num_visited_cards, total_old_region_cards));\n+    G1CollectedHeap* g1h = G1CollectedHeap::heap();\n+    size_t total_old_region_cards =\n+      (g1h->num_regions() - (g1h->num_free_regions() - g1h->collection_set()->cur_length())) * HeapRegion::CardsPerRegion;\n+\n+    ls.print_cr(\"Visited cards \" SIZE_FORMAT \" Total dirty \" SIZE_FORMAT \" (%.2lf%%) Total old \" SIZE_FORMAT \" (%.2lf%%)\",\n+                num_visited_cards,\n+                total_dirty_region_cards,\n+                percent_of(num_visited_cards, total_dirty_region_cards),\n+                total_old_region_cards,\n+                percent_of(num_visited_cards, total_old_region_cards));\n+  }\n@@ -1505,3 +1507,1 @@\n-  if (log_is_enabled(Debug, gc, remset)) {\n-    print_merge_heap_roots_stats();\n-  }\n+  print_merge_heap_roots_stats();\n@@ -1523,2 +1523,3 @@\n-  Log(gc, remset) log;\n-  LogStream ls(log.debug());\n+  LogTarget(Debug, gc, remset) lt;\n+  if (lt.is_enabled()) {\n+    LogStream ls(lt);\n@@ -1526,1 +1527,2 @@\n-  G1CardSet::print_coarsen_stats(&ls);\n+    G1CardSet::print_coarsen_stats(&ls);\n+  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.cpp","additions":22,"deletions":20,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -27,3 +27,0 @@\n-#include \"gc\/g1\/heapRegion.inline.hpp\"\n-#include \"gc\/g1\/heapRegionRemSet.inline.hpp\"\n-#include \"gc\/shared\/suspendibleThreadSet.hpp\"\n@@ -31,1 +28,0 @@\n-#include \"memory\/universe.hpp\"\n@@ -58,1 +54,1 @@\n-  guarantee(!task->is_enqueued(), \"Task already in queue\");\n+  guarantee(task->next() == NULL, \"Task already in queue\");\n@@ -80,1 +76,1 @@\n-  guarantee(!task->is_enqueued(), \"Task already in queue\");\n+  guarantee(task->next() == NULL, \"Task already in queue\");\n@@ -213,1 +209,1 @@\n-G1ServiceTask* G1ServiceTask::next() const {\n+G1ServiceTask* G1ServiceTask::next() {\n@@ -217,4 +213,0 @@\n-bool G1ServiceTask::is_enqueued() const {\n-  return next() != nullptr;\n-}\n-\n@@ -243,2 +235,2 @@\n-  assert(task != nullptr, \"not a valid task\");\n-  assert(!task->is_enqueued(), \"already enqueued\");\n+  assert(task != NULL, \"not a valid task\");\n+  assert(task->next() == NULL, \"invariant\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ServiceThread.cpp","additions":5,"deletions":13,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -50,1 +50,0 @@\n-  G1ServiceTask* next() const;\n@@ -53,1 +52,0 @@\n-  virtual ~G1ServiceTask() { }\n@@ -57,0 +55,1 @@\n+  G1ServiceTask* next();\n@@ -58,5 +57,0 @@\n-  \/\/ Returns whether this task has already been enqueued. There is no particular\n-  \/\/ synchronization effort on this check, so make sure that it is either called\n-  \/\/ from the thread running this task or in another safe place (e.g. vm thread\n-  \/\/ in safepoint).\n-  bool is_enqueued() const;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ServiceThread.hpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -619,4 +619,2 @@\n-          {\n-            LogStream ls(log.error());\n-            to->rem_set()->print_info(&ls, p);\n-          }\n+          LogStream ls(log.error());\n+          to->rem_set()->print_info(&ls, p);\n@@ -627,1 +625,0 @@\n-          LogStream ls(log.error());\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.cpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -120,2 +120,2 @@\n-  \/\/ The actual # of bytes this hr_remset takes up.\n-  \/\/ Note also includes the strong code root set.\n+  \/\/ The actual # of bytes this hr_remset takes up. Also includes the strong code\n+  \/\/ root set.\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionRemSet.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}