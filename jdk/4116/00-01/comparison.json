{"files":[{"patch":"@@ -53,5 +53,0 @@\n-  if (!FLAG_IS_DEFAULT(G1RSetSparseRegionEntries) && FLAG_IS_DEFAULT(G1RemSetArrayOfCardsEntries)) {\n-    \/\/ Only if only G1RSetSparseRegionEntries is set, use it (capping its value). Otherwise\n-    \/\/ G1RemSetArrayOfCardsEntries just overrides it.\n-    FLAG_SET_ERGO(G1RemSetArrayOfCardsEntries, MIN2((uint)G1RSetSparseRegionEntries, 65536u));\n-  }\n@@ -271,0 +266,4 @@\n+  ~G1CardSetHashTable() {\n+    reset();\n+  }\n+\n@@ -452,1 +451,1 @@\n-      CardSetPtr old_value = Atomic::cmpxchg(card_set_addr, cur_card_set, G1CardSet::FullCardSet); \/\/ Memory order?\n+      CardSetPtr old_value = Atomic::cmpxchg(card_set_addr, cur_card_set, G1CardSet::FullCardSet);\n@@ -478,1 +477,1 @@\n-  G1CardSetHowl* howling_array = card_set_ptr<G1CardSetHowl>(parent_card_set);\n+  G1CardSetHowl* howl = card_set_ptr<G1CardSetHowl>(parent_card_set);\n@@ -481,1 +480,1 @@\n-  CardSetPtr to_transfer;\n+  CardSetPtr to_transfer = nullptr;\n@@ -485,1 +484,1 @@\n-  volatile CardSetPtr* bucket_entry = howling_array->get_card_set_addr(bucket);\n+  volatile CardSetPtr* bucket_entry = howl->get_card_set_addr(bucket);\n@@ -488,2 +487,1 @@\n-    to_transfer = nullptr;\n-    if (Atomic::load(&howling_array->_num_entries) >= _config->cards_in_howl_threshold()) {\n+    if (Atomic::load(&howl->_num_entries) >= _config->cards_in_howl_threshold()) {\n@@ -513,1 +511,1 @@\n-    Atomic::inc(&howling_array->_num_entries, memory_order_relaxed);\n+    Atomic::inc(&howl->_num_entries, memory_order_relaxed);\n@@ -552,1 +550,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSet.cpp","additions":10,"deletions":13,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -170,13 +170,12 @@\n-  \/*\n-   * CardSetPtr represents the card storage type of a given region. It encodes\n-   * a type in the LSBs, in addition to having a few significant values.\n-   *\n-   * Possible encodings:\n-   *\n-   * 0...00000 free               (should never happen)\n-   * 1...11111 full\n-   * X...XXX00 inline-ptr-cards   (64 bit)\n-   * X...XXX01 array of cards\n-   * X...XXX10 bitmap\n-   * X...XXX11 howl (64 bit)\n-   *\/\n+\n+  \/\/ CardSetPtr represents the card storage type of a given region. It encodes\n+  \/\/ a type in the LSBs, in addition to having a few significant values.\n+  \/\/\n+  \/\/ Possible encodings:\n+  \/\/\n+  \/\/ 0...00000 free               (should never happen)\n+  \/\/ 1...11111 full\n+  \/\/ X...XXX00 inline-ptr-cards   (64 bit)\n+  \/\/ X...XXX01 array of cards\n+  \/\/ X...XXX10 bitmap\n+  \/\/ X...XXX11 howl (64 bit)\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSet.hpp","additions":12,"deletions":13,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -69,2 +69,0 @@\n-  G1CardSetInlinePtr(uint const card_idx, uint const bits_per_card);\n-\n@@ -86,4 +84,0 @@\n-  uint card_at(uint const idx, uint const bits_per_card) {\n-    return card_at(*this, idx, bits_per_card);\n-  }\n-\n@@ -176,5 +170,0 @@\n-  uint card_at(uint const idx) {\n-    assert(idx < num_entries(), \"Tried to exist card at %u beyond card entries\", idx);\n-    return _data[idx];\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetContainers.hpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -31,6 +31,0 @@\n-inline G1CardSetInlinePtr::G1CardSetInlinePtr(uint card_idx, uint bits_per_card) :\n-  _value_addr(nullptr),\n-  _value((CardSetPtr)G1CardSet::CardSetInlinePtr) {\n-  _value = merge(_value, card_idx, 0, bits_per_card);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetContainers.inline.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -35,4 +35,1 @@\n-const char* G1CardSetFreeMemoryTask::_state_names[] = { \"CalculateUsed\",\n-                                                        \"ReturnToVM\",\n-                                                        \"ReturnToOS\",\n-                                                        \"Cleanup\" };\n+constexpr const char* G1CardSetFreeMemoryTask::_state_names[];\n@@ -150,1 +147,1 @@\n-        next_state = State::CalculateUsed;\n+        next_state = State::Inactive;\n@@ -153,0 +150,4 @@\n+      default:\n+        log_error(gc, task)(\"Should not try to free excess card set memory in %s state\", get_state_name(_state));\n+        ShouldNotReachHere();\n+        break;\n@@ -155,6 +156,2 @@\n-    log_trace(gc, task)(\"Card Set Free Memory: State change from %s to %s\",\n-                        get_state_name(_state),\n-                        get_state_name(next_state));\n-\n-    _state = next_state;\n-  } while (_state != State::CalculateUsed && !deadline_exceeded(end));\n+    set_state(next_state);\n+  } while (_state != State::Inactive && !deadline_exceeded(end));\n@@ -166,1 +163,12 @@\n-  return _state != State::CalculateUsed;\n+  return is_active();\n+}\n+\n+void G1CardSetFreeMemoryTask::set_state(State new_state) {\n+  log_trace(gc, task)(\"Card Set Free Memory: State change from %s to %s\",\n+                      get_state_name(_state),\n+                      get_state_name(new_state));\n+  _state = new_state;\n+}\n+\n+bool G1CardSetFreeMemoryTask::is_active() const {\n+  return _state != State::Inactive;\n@@ -180,6 +188,1 @@\n-    \/\/ While joining the STS, we might have been interrupted by a GC that already\n-    \/\/ enqueued this task again. So we need to check again whether we are already\n-    \/\/ in the queue before rescheduling ourselves.\n-    if (!is_enqueued()) {\n-      schedule(reschedule_delay_ms());\n-    }\n+    schedule(reschedule_delay_ms());\n@@ -195,0 +198,5 @@\n+\n+  if (!is_active()) {\n+    set_state(State::CalculateUsed);\n+    G1CollectedHeap::heap()->service_thread()->schedule_task(this, 0);\n+  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetFreeMemoryTask.cpp","additions":26,"deletions":18,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+    Inactive,\n@@ -46,1 +47,6 @@\n-  static const char* _state_names[];\n+  static constexpr const char* _state_names[] = { \"Invalid\",\n+                                                  \"CalculateUsed\",\n+                                                  \"ReturnToVM\",\n+                                                  \"ReturnToOS\",\n+                                                  \"Cleanup\" };\n+\n@@ -73,0 +79,4 @@\n+  void set_state(State new_state);\n+  \/\/ Returns whether we are currently processing a recent request.\n+  bool is_active() const;\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSetFreeMemoryTask.hpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2582,3 +2582,0 @@\n-  if (!_free_card_set_memory_task->is_enqueued()) {\n-    _service_thread->schedule_task(_free_card_set_memory_task, 0);\n-  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -76,1 +76,1 @@\n-  for (uint i = 0; i < MergeRSContainersLast; i++) {\n+  for (uint i = 0; i < MergeRSContainersSentinel; i++) {\n@@ -81,1 +81,1 @@\n-  for (uint i = 0; i < MergeRSContainersLast; i++) {\n+  for (uint i = 0; i < MergeRSContainersSentinel; i++) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1GCPhaseTimes.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -111,1 +111,1 @@\n-    MergeRSContainersLast\n+    MergeRSContainersSentinel\n@@ -114,1 +114,1 @@\n-  static constexpr const char* GCMergeRSWorkItemsStrings[MergeRSContainersLast] =\n+  static constexpr const char* GCMergeRSWorkItemsStrings[MergeRSContainersSentinel] =\n","filename":"src\/hotspot\/share\/gc\/g1\/g1GCPhaseTimes.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1062,1 +1062,1 @@\n-\/\/ Small ring buffer used for prefetching cards for read\/write from the card\n+\/\/ Small ring buffer used for prefetching cards for write from the card\n@@ -1064,1 +1064,1 @@\n-template <class T, bool for_write>\n+template <class T>\n@@ -1097,5 +1097,1 @@\n-    if (for_write) {\n-      Prefetch::write(elem, 0);\n-    } else {\n-      Prefetch::read(elem, 0);\n-    }\n+    Prefetch::write(elem, 0);\n@@ -1113,1 +1109,1 @@\n-    size_t _merged[G1GCPhaseTimes::MergeRSContainersLast];\n+    size_t _merged[G1GCPhaseTimes::MergeRSContainersSentinel];\n@@ -1134,1 +1130,5 @@\n-  \/\/ Visitor for remembered sets, dropping entries onto the card table.\n+  \/\/ Visitor for remembered sets. Several methods of it are called by a region's\n+  \/\/ card set iterator to drop card set remembered set entries onto the card.\n+  \/\/ table. This is in addition to being the HeapRegionClosure to iterate over\n+  \/\/ all region's remembered sets.\n+  \/\/\n@@ -1150,1 +1150,1 @@\n-    class G1MergeCardSetCache : public G1MergeHeapRootsPrefetchCache<G1CardTable::CardValue, true> {\n+    class G1MergeCardSetCache : public G1MergeHeapRootsPrefetchCache<G1CardTable::CardValue> {\n@@ -1157,1 +1157,1 @@\n-        G1MergeHeapRootsPrefetchCache<G1CardTable::CardValue, true>(G1CardTable::dirty_card_val()),\n+        G1MergeHeapRootsPrefetchCache<G1CardTable::CardValue>(G1CardTable::dirty_card_val()),\n@@ -1305,1 +1305,0 @@\n-    friend class G1MergeLogBufferCardsCache;\n@@ -1313,17 +1312,0 @@\n-    class G1MergeLogBufferCardsCache : public G1MergeHeapRootsPrefetchCache<G1CardTable::CardValue, false> {\n-      G1MergeLogBufferCardsClosure* const _merge_log_buffer_cl;\n-\n-    public:\n-      G1MergeLogBufferCardsCache(G1MergeLogBufferCardsClosure* const merge_log_buffer_cl) :\n-        \/\/ Initially set dummy card value to Clean to avoid any actual work if we\n-        \/\/ try to process it.\n-        G1MergeHeapRootsPrefetchCache<G1CardTable::CardValue, false>(G1CardTable::clean_card_val()),\n-        _merge_log_buffer_cl(merge_log_buffer_cl) { }\n-\n-      ~G1MergeLogBufferCardsCache() {\n-        for (uint i = 0; i < CacheSize; i++) {\n-          _merge_log_buffer_cl->process_card(push(&_dummy_card));\n-        }\n-      }\n-    } _merge_log_buffer_cache;\n-\n@@ -1344,2 +1326,1 @@\n-      _cards_skipped(0),\n-      _merge_log_buffer_cache(this)\n+      _cards_skipped(0)\n@@ -1362,2 +1343,1 @@\n-        CardValue* to_process = _merge_log_buffer_cache.push(card_ptr);\n-        process_card(to_process);\n+        process_card(card_ptr);\n@@ -1431,1 +1411,1 @@\n-      for (uint i = 0; i < G1GCPhaseTimes::MergeRSContainersLast; i++) {\n+      for (uint i = 0; i < G1GCPhaseTimes::MergeRSContainersSentinel; i++) {\n@@ -1446,1 +1426,1 @@\n-      for (uint i = 0; i < G1GCPhaseTimes::MergeRSContainersLast; i++) {\n+      for (uint i = 0; i < G1GCPhaseTimes::MergeRSContainersSentinel; i++) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.cpp","additions":15,"deletions":35,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -157,12 +157,0 @@\n-  product(intx, G1RSetRegionEntries, 0,                                     \\\n-          \"Max number of regions for which we keep bitmaps.\"                \\\n-          \"Will be set ergonomically by default.\")                          \\\n-          range(0, max_jint\/wordSize)                                       \\\n-          constraint(G1RSetRegionEntriesConstraintFunc,AfterErgo)           \\\n-                                                                            \\\n-  product(intx, G1RSetSparseRegionEntries, 0,                               \\\n-          \"Max number of entries per region in a sparse table.\"             \\\n-          \"Will be set ergonomically by default.\")                          \\\n-          range(0, max_jint\/wordSize)                                       \\\n-          constraint(G1RSetSparseRegionEntriesConstraintFunc,AfterErgo)     \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/gc\/g1\/g1_globals.hpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -31,32 +31,0 @@\n-JVMFlag::Error G1RSetRegionEntriesConstraintFunc(intx value, bool verbose) {\n-  if (!UseG1GC) return JVMFlag::SUCCESS;\n-\n-  \/\/ Default value of G1RSetRegionEntries=0 means will be set ergonomically.\n-  \/\/ Minimum value is 1.\n-  if (FLAG_IS_CMDLINE(G1RSetRegionEntries) && (value < 1)) {\n-    JVMFlag::printError(verbose,\n-                        \"G1RSetRegionEntries (\" INTX_FORMAT \") must be \"\n-                        \"greater than or equal to 1\\n\",\n-                        value);\n-    return JVMFlag::VIOLATES_CONSTRAINT;\n-  } else {\n-    return JVMFlag::SUCCESS;\n-  }\n-}\n-\n-JVMFlag::Error G1RSetSparseRegionEntriesConstraintFunc(intx value, bool verbose) {\n-  if (!UseG1GC) return JVMFlag::SUCCESS;\n-\n-  \/\/ Default value of G1RSetSparseRegionEntries=0 means will be set ergonomically.\n-  \/\/ Minimum value is 1.\n-  if (FLAG_IS_CMDLINE(G1RSetSparseRegionEntries) && (value < 1)) {\n-    JVMFlag::printError(verbose,\n-                        \"G1RSetSparseRegionEntries (\" INTX_FORMAT \") must be \"\n-                        \"greater than or equal to 1\\n\",\n-                        value);\n-    return JVMFlag::VIOLATES_CONSTRAINT;\n-  } else {\n-    return JVMFlag::SUCCESS;\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/jvmFlagConstraintsG1.cpp","additions":0,"deletions":32,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -34,2 +34,0 @@\n-  f(intx,   G1RSetRegionEntriesConstraintFunc)        \\\n-  f(intx,   G1RSetSparseRegionEntriesConstraintFunc)  \\\n","filename":"src\/hotspot\/share\/gc\/g1\/jvmFlagConstraintsG1.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -528,1 +528,2 @@\n-  { \"G1RSetRegionEntries\",          JDK_Version::jdk(17), JDK_Version::jdk(18), JDK_Version::jdk(19) },\n+  { \"G1RSetRegionEntries\",          JDK_Version::undefined(), JDK_Version::jdk(17), JDK_Version::jdk(18) },\n+  { \"G1RSetSparseRegionEntries\",    JDK_Version::undefined(), JDK_Version::jdk(17), JDK_Version::jdk(18) },\n@@ -543,1 +544,0 @@\n-  { \"G1RSetSparseRegionEntries\",    JDK_Version::jdk(17), JDK_Version::jdk(18), JDK_Version::jdk(19) },\n@@ -573,2 +573,2 @@\n-  { \"DefaultMaxRAMFraction\",     \"MaxRAMFraction\"    },\n-  { \"CreateMinidumpOnCrash\",     \"CreateCoredumpOnCrash\" },\n+  { \"DefaultMaxRAMFraction\",    \"MaxRAMFraction\"    },\n+  { \"CreateMinidumpOnCrash\",    \"CreateCoredumpOnCrash\" },\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -233,2 +233,0 @@\n-        excludeTestMaxRange(\"G1RSetRegionEntries\");\n-        excludeTestMaxRange(\"G1RSetSparseRegionEntries\");\n","filename":"test\/hotspot\/jtreg\/runtime\/CommandLine\/OptionsValidation\/TestOptionsWithRanges.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,1 +50,0 @@\n-        {\"G1RSetRegionEntries\",       \"1024\"},\n@@ -54,2 +53,1 @@\n-        {\"CreateMinidumpOnCrash\", \"false\"},\n-        {\"G1RSetSparseRegionEntries\", \"128\"}\n+        {\"CreateMinidumpOnCrash\", \"false\"}\n","filename":"test\/hotspot\/jtreg\/runtime\/CommandLine\/VMDeprecatedOptions.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"}]}