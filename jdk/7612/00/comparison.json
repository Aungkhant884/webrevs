{"files":[{"patch":"@@ -935,1 +935,1 @@\n-        if (!obj->is_loaded() || (PatchALot && (obj->is_null_object() || obj->klass() != ciEnv::current()->String_klass()))) {\n+        if (!obj->is_loaded() || (PatchALot && !stream()->is_string_constant())) {\n@@ -956,1 +956,3 @@\n-      bool kills_memory = stream()->is_dynamic_constant(); \/\/ arbitrary memory effects from running BSM during linkage\n+      \/\/ Arbitrary memory effects from running BSM or class loading (using custom loader) during linkage.\n+      bool kills_memory = stream()->is_dynamic_constant() ||\n+                          (!stream()->is_string_constant() && !method()->holder()->has_trusted_loader());\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -104,0 +104,2 @@\n+  _has_trusted_loader = compute_has_trusted_loader();\n+\n@@ -136,0 +138,1 @@\n+  _has_trusted_loader = compute_has_trusted_loader();\n@@ -597,0 +600,9 @@\n+bool ciInstanceKlass::compute_has_trusted_loader() {\n+  ASSERT_IN_VM;\n+  oop loader_oop = loader();\n+  if (loader_oop == NULL) {\n+    return true; \/\/ bootstrap class loader\n+  }\n+  return java_lang_ClassLoader::is_trusted_loader(loader_oop);\n+}\n+\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+  bool                   _has_trusted_loader;\n@@ -110,0 +111,1 @@\n+  bool compute_has_trusted_loader();\n@@ -291,0 +293,4 @@\n+  bool has_trusted_loader() const {\n+    return _has_trusted_loader;\n+  }\n+\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -252,0 +252,10 @@\n+  bool is_string_constant() const {\n+    assert(cur_bc() == Bytecodes::_ldc    ||\n+           cur_bc() == Bytecodes::_ldc_w  ||\n+           cur_bc() == Bytecodes::_ldc2_w, \"not supported: %s\", Bytecodes::name(cur_bc()));\n+\n+    int index = get_constant_pool_index();\n+    constantTag tag = get_raw_pool_tag(index);\n+    return tag.is_string();\n+  }\n+\n","filename":"src\/hotspot\/share\/ci\/ciStreams.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8282218\n+ *\n+ * @run main\/othervm -Xcomp -XX:TieredStopAtLevel=1\n+ *                   -XX:CompileCommand=compileonly,compiler.c1.TestClassConstantPatching$Test::run\n+ *                      compiler.c1.TestClassConstantPatching\n+ *\/\n+package compiler.c1;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.lang.reflect.Method;\n+\n+public class TestClassConstantPatching {\n+    public static int COUNTER = 0;\n+\n+    static class CustomLoader extends ClassLoader {\n+        @Override\n+        protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {\n+            if (name.startsWith(Test.class.getName())) {\n+                Class<?> c = findLoadedClass(name);\n+                if (c != null) {\n+                    return c;\n+                }\n+                try {\n+                    COUNTER++; \/\/ update counter on loading\n+\n+                    InputStream in = getSystemResourceAsStream(name.replace('.', File.separatorChar) + \".class\");\n+                    byte[] buf = in.readAllBytes();\n+                    return defineClass(name, buf, 0, buf.length);\n+                } catch (IOException e) {\n+                    throw new ClassNotFoundException(name);\n+                }\n+            }\n+            return super.loadClass(name, resolve);\n+        }\n+    }\n+\n+    public static class Test {\n+        static class T {}\n+\n+        public static Class<?> run(boolean cond) {\n+            int before = COUNTER;\n+            Class<?> c = null;\n+            if (cond) {\n+                c = T.class;\n+            }\n+            int after = COUNTER;\n+            if (cond && before == after) {\n+                throw new AssertionError(\"missed update\");\n+            }\n+            return c;\n+        }\n+    }\n+\n+    public static void main(String[] args) throws ReflectiveOperationException {\n+        ClassLoader cl = new CustomLoader();\n+\n+        Class.forName(TestClassConstantPatching.class.getName(), true, cl); \/\/ preload counter holder class\n+\n+        Class<?> test = Class.forName(Test.class.getName(), true, cl);\n+\n+        Method m = test.getDeclaredMethod(\"run\", boolean.class);\n+\n+        m.invoke(null, false);\n+        m.invoke(null, true);\n+\n+        System.out.println(\"TEST PASSED\");\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/c1\/TestClassConstantPatching.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"}]}