{"files":[{"patch":"@@ -322,1 +322,1 @@\n-    assert(value->as_Vector()->bottom_type()->is_vect()->element_basic_type() == bt,\n+    assert(value->bottom_type()->is_vect()->element_basic_type() == bt,\n@@ -383,1 +383,2 @@\n-    BasicType bt = vec_unbox->vect_type()->element_basic_type();\n+    const TypeVect* vt = vec_unbox->bottom_type()->is_vect();\n+    BasicType bt = vt->element_basic_type();\n@@ -422,1 +423,0 @@\n-    const TypeVect* vt = vec_unbox->bottom_type()->is_vect();\n@@ -435,2 +435,1 @@\n-    if (is_vector_mask(from_kls) && masktype != T_BOOLEAN) {\n-      assert(vec_unbox->bottom_type()->is_vect()->element_basic_type() == masktype, \"expect mask type consistency\");\n+    if (is_vector_mask(from_kls)) {\n@@ -442,1 +441,1 @@\n-      } else if (elem_bt != T_BYTE) {\n+      } else {\n","filename":"src\/hotspot\/share\/opto\/vector.cpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1013,0 +1013,18 @@\n+Node* VectorLoadMaskNode::Identity(PhaseGVN* phase) {\n+  BasicType out_bt = type()->is_vect()->element_basic_type();\n+  if (out_bt == T_BOOLEAN) {\n+    return in(1); \/\/ redundant conversion\n+  }\n+  return this;\n+}\n+\n+Node* VectorStoreMaskNode::Identity(PhaseGVN* phase) {\n+  \/\/ Identity transformation on boolean vectors.\n+  \/\/   VectorStoreMask (VectorLoadMask bv) elem_size ==> bv\n+  \/\/   vector[n]{bool} => vector[n]{t} => vector[n]{bool}\n+  if (in(1)->Opcode() == Op_VectorLoadMask) {\n+    return in(1)->in(1);\n+  }\n+  return this;\n+}\n+\n@@ -1049,0 +1067,11 @@\n+Node* VectorCastNode::Identity(PhaseGVN* phase) {\n+  if (!in(1)->is_top()) {\n+    BasicType  in_bt = in(1)->bottom_type()->is_vect()->element_basic_type();\n+    BasicType out_bt = vect_type()->element_basic_type();\n+    if (in_bt == out_bt) {\n+      return in(1); \/\/ redundant cast\n+    }\n+  }\n+  return this;\n+}\n+\n@@ -1222,1 +1251,36 @@\n-Node* VectorUnboxNode::Identity(PhaseGVN *phase) {\n+Node* VectorUnboxNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  Node* n = obj()->uncast();\n+  if (EnableVectorReboxing && n->Opcode() == Op_VectorBox) {\n+    if (Type::cmp(bottom_type(), n->in(VectorBoxNode::Value)->bottom_type()) == 0) {\n+      \/\/ Handled by VectorUnboxNode::Identity()\n+    } else {\n+      VectorBoxNode* vbox = static_cast<VectorBoxNode*>(n);\n+      ciKlass* vbox_klass = vbox->box_type()->klass();\n+      const TypeVect* in_vt = vbox->vec_type();\n+      const TypeVect* out_vt = type()->is_vect();\n+      assert(in_vt->length() == out_vt->length(), \"mismatch on number of elements\");\n+      Node* value = vbox->in(VectorBoxNode::Value);\n+\n+      bool is_vector_mask    = vbox_klass->is_subclass_of(ciEnv::current()->vector_VectorMask_klass());\n+      bool is_vector_shuffle = vbox_klass->is_subclass_of(ciEnv::current()->vector_VectorShuffle_klass());\n+      if (is_vector_mask) {\n+        \/\/ VectorUnbox (VectorBox vmask) ==> VectorLoadMask (VectorStoreMask vmask)\n+        value = phase->transform(VectorStoreMaskNode::make(*phase, value, in_vt->element_basic_type(), in_vt->length()));\n+        return new VectorLoadMaskNode(value, out_vt);\n+      } else if (is_vector_shuffle) {\n+        if (is_shuffle_to_vector()) {\n+          \/\/ VectorUnbox (VectorBox vshuffle) ==> VectorCastB2X vshuffle\n+          return new VectorCastB2XNode(value, out_vt);\n+        } else {\n+          \/\/ VectorUnbox (VectorBox vshuffle) ==> VectorLoadShuffle vshuffle\n+          return new VectorLoadShuffleNode(value, out_vt);\n+        }\n+      } else {\n+        assert(false, \"type mismatch on vector: %s\", vbox_klass->name()->as_utf8());\n+      }\n+    }\n+  }\n+  return NULL;\n+}\n+\n+Node* VectorUnboxNode::Identity(PhaseGVN* phase) {\n@@ -1226,1 +1290,3 @@\n-      return n->in(VectorBoxNode::Value);\n+      return n->in(VectorBoxNode::Value); \/\/ VectorUnbox (VectorBox v) ==> v\n+    } else {\n+      \/\/ Handled by VectorUnboxNode::Ideal().\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":68,"deletions":2,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -1147,7 +1147,2 @@\n-  VectorTestNode( Node *in1, Node *in2, BoolTest::mask predicate) : Node(NULL, in1, in2), _predicate(predicate) {\n-    assert(in1->is_Vector() || in1->is_LoadVector(), \"must be vector\");\n-    assert(in2->is_Vector() || in2->is_LoadVector(), \"must be vector\");\n-    assert(in1->bottom_type()->is_vect()->element_basic_type() == in2->bottom_type()->is_vect()->element_basic_type(),\n-           \"same type elements are needed\");\n-    assert(in1->bottom_type()->is_vect()->length() == in2->bottom_type()->is_vect()->length(),\n-           \"same number of elements is needed\");\n+  VectorTestNode(Node* in1, Node* in2, BoolTest::mask predicate) : Node(NULL, in1, in2), _predicate(predicate) {\n+    assert(in2->bottom_type()->is_vect() == in2->bottom_type()->is_vect(), \"same vector type\");\n@@ -1191,2 +1186,1 @@\n-\n-class VectorLoadMaskNode : public VectorNode {\n+class VectorLoadShuffleNode : public VectorNode {\n@@ -1194,1 +1188,1 @@\n-  VectorLoadMaskNode(Node* in, const TypeVect* vt)\n+  VectorLoadShuffleNode(Node* in, const TypeVect* vt)\n@@ -1196,2 +1190,1 @@\n-    assert(in->is_LoadVector(), \"expected load vector\");\n-    assert(in->as_LoadVector()->vect_type()->element_basic_type() == T_BOOLEAN, \"must be boolean\");\n+    assert(in->bottom_type()->is_vect()->element_basic_type() == T_BYTE, \"must be BYTE\");\n@@ -1200,0 +1193,1 @@\n+  int GetOutShuffleSize() const { return type2aelembytes(vect_type()->element_basic_type()); }\n@@ -1203,1 +1197,1 @@\n-class VectorLoadShuffleNode : public VectorNode {\n+class VectorLoadMaskNode : public VectorNode {\n@@ -1205,4 +1199,2 @@\n-  VectorLoadShuffleNode(Node* in, const TypeVect* vt)\n-    : VectorNode(in, vt) {\n-    assert(in->is_LoadVector(), \"expected load vector\");\n-    assert(in->as_LoadVector()->vect_type()->element_basic_type() == T_BYTE, \"must be BYTE\");\n+  VectorLoadMaskNode(Node* in, const TypeVect* vt) : VectorNode(in, vt) {\n+    assert(in->bottom_type()->is_vect()->element_basic_type() == T_BOOLEAN, \"must be boolean\");\n@@ -1211,1 +1203,0 @@\n-  int GetOutShuffleSize() const { return type2aelembytes(vect_type()->element_basic_type()); }\n@@ -1213,0 +1204,1 @@\n+  virtual Node* Identity(PhaseGVN* phase);\n@@ -1217,2 +1209,1 @@\n-  VectorStoreMaskNode(Node* in1, ConINode* in2, const TypeVect* vt)\n-    : VectorNode(in1, in2, vt) { }\n+  VectorStoreMaskNode(Node* in1, ConINode* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}\n@@ -1222,0 +1213,1 @@\n+  virtual Node* Identity(PhaseGVN* phase);\n@@ -1240,1 +1232,1 @@\n-  virtual Node *Identity(PhaseGVN *phase);\n+  virtual Node* Identity(PhaseGVN* phase);\n@@ -1253,0 +1245,2 @@\n+\n+  virtual Node* Identity(PhaseGVN* phase);\n@@ -1373,1 +1367,2 @@\n-  virtual Node *Identity(PhaseGVN *phase);\n+  virtual Node* Identity(PhaseGVN* phase);\n+  Node* Ideal(PhaseGVN* phase, bool can_reshape);\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":17,"deletions":22,"binary":false,"changes":39,"status":"modified"}]}