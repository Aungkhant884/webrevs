{"files":[{"patch":"@@ -45,0 +45,1 @@\n+#include \"gc\/g1\/g1GCCounters.hpp\"\n@@ -2018,0 +2019,6 @@\n+\/\/ Helper for collect().\n+static G1GCCounters collection_counters(G1CollectedHeap* g1h) {\n+  MutexLocker ml(Heap_lock);\n+  return G1GCCounters(g1h);\n+}\n+\n@@ -2019,1 +2026,1 @@\n-  try_collect(cause);\n+  try_collect(cause, collection_counters(this));\n@@ -2214,14 +2221,2 @@\n-bool G1CollectedHeap::try_collect(GCCause::Cause cause) {\n-  assert_heap_not_locked();\n-\n-  \/\/ Lock to get consistent set of values.\n-  uint gc_count_before;\n-  uint full_gc_count_before;\n-  uint old_marking_started_before;\n-  {\n-    MutexLocker ml(Heap_lock);\n-    gc_count_before = total_collections();\n-    full_gc_count_before = total_full_collections();\n-    old_marking_started_before = _old_marking_cycles_started;\n-  }\n-\n+bool G1CollectedHeap::try_collect(GCCause::Cause cause,\n+                                  const G1GCCounters& counters_before) {\n@@ -2230,3 +2225,3 @@\n-                                    gc_count_before,\n-                                    old_marking_started_before);\n-  } else if (GCLocker::should_discard(cause, gc_count_before)) {\n+                                    counters_before.total_collections(),\n+                                    counters_before.old_marking_cycles_started());\n+  } else if (GCLocker::should_discard(cause, counters_before.total_collections())) {\n@@ -2243,1 +2238,1 @@\n-                                 gc_count_before,\n+                                 counters_before.total_collections(),\n@@ -2250,1 +2245,3 @@\n-    VM_G1CollectFull op(gc_count_before, full_gc_count_before, cause);\n+    VM_G1CollectFull op(counters_before.total_collections(),\n+                        counters_before.total_full_collections(),\n+                        cause);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":17,"deletions":20,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -84,0 +84,1 @@\n+class G1GCCounters;\n@@ -673,1 +674,5 @@\n-  uint old_marking_cycles_completed() {\n+  uint old_marking_cycles_started() const {\n+    return _old_marking_cycles_started;\n+  }\n+\n+  uint old_marking_cycles_completed() const {\n@@ -1139,1 +1144,1 @@\n-  bool try_collect(GCCause::Cause cause);\n+  bool try_collect(GCCause::Cause cause, const G1GCCounters& counters_before);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/g1\/g1CollectedHeap.hpp\"\n+#include \"gc\/g1\/g1GCCounters.hpp\"\n+\n+G1GCCounters::G1GCCounters(G1CollectedHeap* g1h) :\n+  _total_collections(g1h->total_collections()),\n+  _total_full_collections(g1h->total_full_collections()),\n+  _old_marking_cycles_started(g1h->old_marking_cycles_started())\n+{}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1GCCounters.cpp","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_G1_G1GCCOUNTERS_HPP\n+#define SHARE_GC_G1_G1GCCOUNTERS_HPP\n+\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+class G1CollectedHeap;\n+\n+\/\/ Record collection counters for later use when deciding whether a GC has\n+\/\/ been run since the counter state was recorded.\n+class G1GCCounters {\n+  uint _total_collections;\n+  uint _total_full_collections;\n+  uint _old_marking_cycles_started;\n+\n+public:\n+  G1GCCounters() {}             \/\/ Uninitialized\n+\n+  \/\/ Capture the current counters from the heap.  The caller must ensure no\n+  \/\/ collections will occur while this constructor is executing.\n+  explicit G1GCCounters(G1CollectedHeap* g1h);\n+\n+  uint total_collections() const { return _total_collections; }\n+  uint total_full_collections() const { return _total_full_collections; }\n+  uint old_marking_cycles_started() const { return _old_marking_cycles_started; }\n+};\n+\n+#endif \/\/ SHARE_GC_G1_G1GCCOUNTERS_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1GCCounters.hpp","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include \"gc\/g1\/g1GCCounters.hpp\"\n@@ -36,1 +37,2 @@\n-bool G1PeriodicGCTask::should_start_periodic_gc() {\n+bool G1PeriodicGCTask::should_start_periodic_gc(G1CollectedHeap* g1h,\n+                                                G1GCCounters* counters) {\n@@ -40,1 +42,0 @@\n-  G1CollectedHeap* g1h = G1CollectedHeap::heap();\n@@ -63,0 +64,5 @@\n+\n+  \/\/ Record counters with GC safepoints blocked, to get a consistent snapshot.\n+  \/\/ These are passed to try_collect so a GC between our release of the\n+  \/\/ STS-joiner and the GC VMOp can be detected and cancel the request.\n+  *counters = G1GCCounters(g1h);\n@@ -73,2 +79,4 @@\n-  if (should_start_periodic_gc()) {\n-    if (!G1CollectedHeap::heap()->try_collect(GCCause::_g1_periodic_collection)) {\n+  G1CollectedHeap* g1h = G1CollectedHeap::heap();\n+  G1GCCounters counters;\n+  if (should_start_periodic_gc(g1h, &counters)) {\n+    if (!g1h->try_collect(GCCause::_g1_periodic_collection, counters)) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1PeriodicGCTask.cpp","additions":13,"deletions":5,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,3 @@\n+class G1CollectedHeap;\n+class G1GCCounters;\n+\n@@ -32,1 +35,2 @@\n-  bool should_start_periodic_gc();\n+  bool should_start_periodic_gc(G1CollectedHeap* g1h,\n+                                G1GCCounters* counters);\n@@ -40,1 +44,1 @@\n-#endif \/\/ SHARE_GC_G1_G1PERIODICGCTASK_HPP\n\\ No newline at end of file\n+#endif \/\/ SHARE_GC_G1_G1PERIODICGCTASK_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1PeriodicGCTask.hpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -39,0 +39,11 @@\n+bool VM_G1CollectFull::skip_operation() const {\n+  \/\/ There is a race between the periodic collection task's checks for\n+  \/\/ wanting a collection and processing its request.  A collection in that\n+  \/\/ gap should cancel the request.\n+  if ((_gc_cause == GCCause::_g1_periodic_collection) &&\n+      (G1CollectedHeap::heap()->total_collections() != _gc_count_before)) {\n+    return true;\n+  }\n+  return VM_GC_Operation::skip_operation();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1VMOperations.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,3 @@\n+protected:\n+  bool skip_operation() const override;\n+\n@@ -42,2 +45,2 @@\n-  virtual VMOp_Type type() const { return VMOp_G1CollectFull; }\n-  virtual void doit();\n+  VMOp_Type type() const override { return VMOp_G1CollectFull; }\n+  void doit() override;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1VMOperations.hpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"}]}