{"files":[{"patch":"@@ -59,1 +59,1 @@\n-void AsyncLogWriter::enqueue(LogFileOutput& output, const LogDecorations& decorations, const char* msg) {\n+void AsyncLogWriter::enqueue(LogFileStreamOutput& output, const LogDecorations& decorations, const char* msg) {\n@@ -70,1 +70,1 @@\n-void AsyncLogWriter::enqueue(LogFileOutput& output, LogMessageBuffer::Iterator msg_iterator) {\n+void AsyncLogWriter::enqueue(LogFileStreamOutput& output, LogMessageBuffer::Iterator msg_iterator) {\n@@ -98,1 +98,1 @@\n-  bool do_entry(LogFileOutput* output, uint32_t& counter) {\n+  bool do_entry(LogFileStreamOutput* output, uint32_t& counter) {\n@@ -141,1 +141,2 @@\n-      e->output()->write_blocking(e->decorations(), msg);\n+      int sz = e->output()->write_blocking(e->decorations(), msg);\n+      e->output()->flush(sz);\n@@ -147,0 +148,8 @@\n+    } else {\n+#ifdef ASSERT\n+      \/\/ only LogFileOutput supports force_rotate();\n+      size_t idx = LogConfiguration::find_output(e->output());\n+      assert(idx != SIZE_MAX && idx > 1, \"e->output() must be a valid LogFileOutput.\");\n+#endif\n+      \/\/ This is a force_rotation token.\n+      static_cast<LogFileOutput*>(e->output())->force_rotate();\n@@ -216,0 +225,17 @@\n+\n+void AsyncLogWriter::force_rotate(LogOutput* output) {\n+  if (_instance != nullptr) {\n+    assert(output != NULL, \"output can't be NULL\");\n+    {\n+      using none = LogTagSetMapping<LogTag::__NO_TAG>;\n+      AsyncLogLocker locker;\n+      LogDecorations d(LogLevel::Off, none::tagset(), LogDecorators::None);\n+      AsyncLogMessage token(static_cast<LogFileStreamOutput*>(output), d, nullptr);\n+\n+      \/\/ Push directly in-case we are at logical max capacity, as this must not get dropped.\n+      _instance->_buffer.push_back(token);\n+      _instance->_data_available = true;\n+      _instance->_lock.notify();\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.cpp","additions":30,"deletions":4,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"logging\/logFileOutput.hpp\"\n+#include \"logging\/logFileStreamOutput.hpp\"\n@@ -32,0 +32,1 @@\n+#include \"runtime\/semaphore.hpp\"\n@@ -94,1 +95,1 @@\n-  LogFileOutput* _output;\n+  LogFileStreamOutput* _output;\n@@ -99,1 +100,1 @@\n-  AsyncLogMessage(LogFileOutput* output, const LogDecorations& decorations, char* msg)\n+  AsyncLogMessage(LogFileStreamOutput* output, const LogDecorations& decorations, char* msg)\n@@ -105,1 +106,1 @@\n-  LogFileOutput* output() const { return _output; }\n+  LogFileStreamOutput* output() const { return _output; }\n@@ -111,1 +112,1 @@\n-typedef ResourceHashtable<LogFileOutput*,\n+typedef ResourceHashtable<LogFileStreamOutput*,\n@@ -171,2 +172,2 @@\n-  void enqueue(LogFileOutput& output, const LogDecorations& decorations, const char* msg);\n-  void enqueue(LogFileOutput& output, LogMessageBuffer::Iterator msg_iterator);\n+  void enqueue(LogFileStreamOutput& output, const LogDecorations& decorations, const char* msg);\n+  void enqueue(LogFileStreamOutput& output, LogMessageBuffer::Iterator msg_iterator);\n@@ -177,0 +178,1 @@\n+  static void force_rotate(LogOutput* output);\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.hpp","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -176,0 +176,10 @@\n+size_t LogConfiguration::find_output(LogOutput* output) {\n+  for (size_t i = 0; i < _n_outputs; i++) {\n+    if (_outputs[i] == output) {\n+      return i;\n+    }\n+  }\n+\n+  return SIZE_MAX;\n+}\n+\n@@ -678,1 +688,5 @@\n-    _outputs[idx]->force_rotate();\n+    if (is_async_mode()) {\n+      AsyncLogWriter::force_rotate(_outputs[idx]);\n+    } else {\n+      _outputs[idx]->force_rotate();\n+    }\n","filename":"src\/hotspot\/share\/logging\/logConfiguration.cpp","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -101,0 +101,3 @@\n+  \/\/ Get output index. Returns SIZE_MAX if output not found.\n+  static size_t find_output(LogOutput* output);\n+\n","filename":"src\/hotspot\/share\/logging\/logConfiguration.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-#include \"logging\/logAsyncWriter.hpp\"\n@@ -50,1 +49,1 @@\n-      _rotate_size(DefaultFileSize), _current_size(0), _rotation_semaphore(1) {\n+      _rotate_size(DefaultFileSize), _current_size(0) {\n@@ -255,2 +254,2 @@\n-class RotationLocker : public StackObj {\n-  Semaphore& _sem;\n+bool LogFileOutput::flush(int written) {\n+  bool result = LogFileStreamOutput::flush(written);\n@@ -258,59 +257,1 @@\n- public:\n-  RotationLocker(Semaphore& sem) : _sem(sem) {\n-    sem.wait();\n-  }\n-\n-  ~RotationLocker() {\n-    _sem.signal();\n-  }\n-};\n-\n-int LogFileOutput::write_blocking(const LogDecorations& decorations, const char* msg) {\n-  RotationLocker lock(_rotation_semaphore);\n-  if (_stream == NULL) {\n-    \/\/ An error has occurred with this output, avoid writing to it.\n-    return 0;\n-  }\n-\n-  int written = LogFileStreamOutput::write(decorations, msg);\n-  if (written > 0) {\n-    _current_size += written;\n-\n-    if (should_rotate()) {\n-      rotate();\n-    }\n-  }\n-\n-  return written;\n-}\n-\n-int LogFileOutput::write(const LogDecorations& decorations, const char* msg) {\n-  if (_stream == NULL) {\n-    \/\/ An error has occurred with this output, avoid writing to it.\n-    return 0;\n-  }\n-\n-  AsyncLogWriter* aio_writer = AsyncLogWriter::instance();\n-  if (aio_writer != nullptr) {\n-    aio_writer->enqueue(*this, decorations, msg);\n-    return 0;\n-  }\n-\n-  return write_blocking(decorations, msg);\n-}\n-\n-int LogFileOutput::write(LogMessageBuffer::Iterator msg_iterator) {\n-  if (_stream == NULL) {\n-    \/\/ An error has occurred with this output, avoid writing to it.\n-    return 0;\n-  }\n-\n-  AsyncLogWriter* aio_writer = AsyncLogWriter::instance();\n-  if (aio_writer != nullptr) {\n-    aio_writer->enqueue(*this, msg_iterator);\n-    return 0;\n-  }\n-\n-  RotationLocker lock(_rotation_semaphore);\n-  int written = LogFileStreamOutput::write(msg_iterator);\n-  if (written > 0) {\n+  if (result) {\n@@ -323,2 +264,1 @@\n-\n-  return written;\n+  return result;\n@@ -350,1 +290,1 @@\n-  RotationLocker lock(_rotation_semaphore);\n+  FileLocker lock(this);\n@@ -355,0 +295,6 @@\n+  assert(LogConfiguration::is_async_mode() || current_thread_has_lock(),\n+        \"current thread must be holding _stream_lock!\");\n+\n+  if (_stream == NULL)\n+    return;\n+\n","filename":"src\/hotspot\/share\/logging\/logFileOutput.cpp","additions":12,"deletions":66,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"runtime\/semaphore.hpp\"\n@@ -63,3 +62,0 @@\n-  \/\/ Semaphore used for synchronizing file rotations and writes\n-  Semaphore _rotation_semaphore;\n-\n@@ -80,1 +76,0 @@\n-\n@@ -84,9 +79,6 @@\n-  virtual bool initialize(const char* options, outputStream* errstream);\n-  virtual bool set_option(const char* key, const char* value, outputStream* errstream);\n-  virtual int write(const LogDecorations& decorations, const char* msg);\n-  virtual int write(LogMessageBuffer::Iterator msg_iterator);\n-  int write_blocking(const LogDecorations& decorations, const char* msg);\n-  virtual void force_rotate();\n-  virtual void describe(outputStream* out);\n-\n-  virtual const char* name() const {\n+  virtual bool initialize(const char* options, outputStream* errstream) override;\n+  virtual bool set_option(const char* key, const char* value, outputStream* errstream) override;\n+  virtual bool flush(int written) override;\n+  virtual void force_rotate() override;\n+  virtual void describe(outputStream* out) override;\n+  virtual const char* name() const override {\n","filename":"src\/hotspot\/share\/logging\/logFileOutput.hpp","additions":6,"deletions":14,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+#include \"logging\/logAsyncWriter.hpp\"\n+#include \"logging\/logConfiguration.hpp\"\n@@ -95,22 +97,17 @@\n-class FileLocker : public StackObj {\n-private:\n-  FILE *_file;\n-\n-public:\n-  FileLocker(FILE *file) : _file(file) {\n-    os::flockfile(_file);\n-  }\n-\n-  ~FileLocker() {\n-    os::funlockfile(_file);\n-  }\n-};\n-\n-bool LogFileStreamOutput::flush() {\n-  bool result = true;\n-  if (fflush(_stream) != 0) {\n-    if (!_write_error_is_shown) {\n-      jio_fprintf(defaultStream::error_stream(),\n-                  \"Could not flush log: %s (%s (%d))\\n\", name(), os::strerror(errno), errno);\n-      jio_fprintf(_stream, \"\\nERROR: Could not flush log (%d)\\n\", errno);\n-      _write_error_is_shown = true;\n+\/\/ if async-logging is on, this function is called by AsyncLog Thread sequentially.\n+\/\/ if async-logging is off, this function is called from write(). Therefore, current thread\n+\/\/ is holding _stream_lock\n+bool LogFileStreamOutput::flush(int written) {\n+  assert(LogConfiguration::is_async_mode() || current_thread_has_lock(),\n+        \"current thread must be holding _stream_lock!\");\n+\n+  bool result = written >= 0 ? true : false;\n+  if (written > 0) {\n+    if (fflush(_stream) != 0) {\n+      if (!_write_error_is_shown) {\n+        jio_fprintf(defaultStream::error_stream(),\n+                    \"Could not flush log: %s (%s (%d))\\n\", name(), os::strerror(errno), errno);\n+        jio_fprintf(_stream, \"\\nERROR: Could not flush log (%d)\\n\", errno);\n+        _write_error_is_shown = true;\n+      }\n+      result = false;\n@@ -118,1 +115,0 @@\n-    result = false;\n@@ -120,0 +116,1 @@\n+\n@@ -162,1 +159,6 @@\n-int LogFileStreamOutput::write(const LogDecorations& decorations, const char* msg) {\n+int LogFileStreamOutput::write_blocking(const LogDecorations& decorations, const char* msg) {\n+  if (_stream == nullptr) {\n+    \/\/ An error has occurred with this output, avoid writing to it.\n+    return 0;\n+  }\n+\n@@ -166,1 +168,0 @@\n-  FileLocker flocker(_stream);\n@@ -172,0 +173,2 @@\n+  return written;\n+}\n@@ -173,1 +176,15 @@\n-  return flush() ? written : -1;\n+int LogFileStreamOutput::write(const LogDecorations& decorations, const char* msg) {\n+  if (_stream == nullptr) {\n+    \/\/ An error has occurred with this output, avoid writing to it.\n+    return 0;\n+  }\n+\n+  AsyncLogWriter* aio_writer = AsyncLogWriter::instance();\n+  if (aio_writer != nullptr) {\n+    aio_writer->enqueue(*this, decorations, msg);\n+    return 0;\n+  }\n+\n+  FileLocker flocker(this);\n+  int written = write_blocking(decorations, msg);\n+  return flush(written) ? written : -1;\n@@ -177,1 +194,4 @@\n-  const bool use_decorations = !_decorators.is_empty();\n+  if (_stream == nullptr) {\n+    \/\/ An error has occurred with this output, avoid writing to it.\n+    return 0;\n+  }\n@@ -179,0 +199,7 @@\n+  AsyncLogWriter* aio_writer = AsyncLogWriter::instance();\n+  if (aio_writer != nullptr) {\n+    aio_writer->enqueue(*this, msg_iterator);\n+    return 0;\n+  }\n+\n+  FileLocker flocker(this);\n@@ -180,1 +207,0 @@\n-  FileLocker flocker(_stream);\n@@ -182,5 +208,3 @@\n-    if (use_decorations) {\n-      WRITE_LOG_WITH_RESULT_CHECK(write_decorations(msg_iterator.decorations()), written);\n-      WRITE_LOG_WITH_RESULT_CHECK(jio_fprintf(_stream, \" \"), written);\n-    }\n-    written += write_internal(msg_iterator.message());\n+    int sz = write_blocking(msg_iterator.decorations(), msg_iterator.message());\n+    if (sz < 0) return sz;\n+    written += sz;\n@@ -189,1 +213,1 @@\n-  return flush() ? written : -1;\n+  return flush(written) ? written : -1;\n@@ -198,0 +222,6 @@\n+\n+#ifdef ASSERT\n+bool LogFileStreamOutput::current_thread_has_lock() {\n+  return _locking_thread_id == os::current_thread_id();\n+}\n+#endif\n","filename":"src\/hotspot\/share\/logging\/logFileStreamOutput.cpp","additions":64,"deletions":34,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"runtime\/semaphore.hpp\"\n@@ -48,1 +49,0 @@\n-\n@@ -52,0 +52,3 @@\n+  \/\/ Semaphore used for synchronizing file rotations and writes\n+  Semaphore           _stream_lock;\n+  debug_only(intx     _locking_thread_id = -1;)\n@@ -54,1 +57,1 @@\n-  LogFileStreamOutput(FILE *stream) : _fold_multilines(false), _write_error_is_shown(false), _stream(stream) {\n+  LogFileStreamOutput(FILE *stream) : _fold_multilines(false), _write_error_is_shown(false), _stream(stream), _stream_lock(1) {\n@@ -61,1 +64,23 @@\n-  bool flush();\n+\n+  \/\/ sempahore-based mutex. Implementation of flockfile do not work with LogFileOuptut::rotate()\n+  \/\/ because fclose() automatically unlocks FILE->_lock and nullifies FileLocker protection.\n+  class FileLocker : public StackObj {\n+    Semaphore& _sem;\n+    debug_only(intx& _locking_thread_id;)\n+\n+   public:\n+    FileLocker(LogFileStreamOutput* output) : _sem(output->_stream_lock)\n+#ifdef ASSERT\n+    , _locking_thread_id(output->_locking_thread_id)\n+#endif\n+     {\n+      _sem.wait();\n+      debug_only(_locking_thread_id = os::current_thread_id());\n+    }\n+\n+    ~FileLocker() {\n+      debug_only(_locking_thread_id = -1);\n+      _sem.signal();\n+    }\n+  };\n+  debug_only(bool current_thread_has_lock();)\n@@ -65,2 +90,4 @@\n-  virtual int write(const LogDecorations& decorations, const char* msg);\n-  virtual int write(LogMessageBuffer::Iterator msg_iterator);\n+  int write(const LogDecorations& decorations, const char* msg);\n+  int write(LogMessageBuffer::Iterator msg_iterator);\n+  int write_blocking(const LogDecorations& decorations, const char* msg);\n+  virtual bool flush(int written);\n","filename":"src\/hotspot\/share\/logging\/logFileStreamOutput.hpp","additions":32,"deletions":5,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -0,0 +1,166 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8267517\n+ * @summary Test the JVM process with async unified logging won't be frozen\n+ * when stdout is blocked.\n+ *\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ * @run driver BlockedLoggingTest\n+ *\/\n+\n+import java.io.BufferedReader;\n+import java.io.InputStreamReader;\n+import java.io.IOException;\n+import java.util.AbstractQueue;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.ArrayBlockingQueue;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class BlockedLoggingTest {\n+    static String BANNER = \"User-defined Java Program has started.\";\n+    static int ThreadNum = 1;\n+\n+    \/\/ process 0 emits unified log to stdout. We must ensure that nobody except for UL emits to stdout.\n+    \/\/ we expect to demonstrate that process 0 with -Xlog:async can still terminate even though its\n+    \/\/ stdout is blocked.\n+    public static class UserDefinedJavaProgram {\n+        public static void main(String[] args) {\n+            System.out.println(BANNER);\n+            System.out.flush();\n+\n+            Thread[] threads = new Thread[ThreadNum];\n+            \/\/ the size of pipe buffer is hard to tell. just churn many gc-related logs\n+            \/\/ in ChurnThread.Duration sececonds. it's presumably 64k on Linux.\n+            for(int i = 0; i < ThreadNum; ++i) {\n+                threads[i] = new ChurnThread();\n+                threads[i].start();\n+            }\n+\n+            try {\n+                for (int i = 0; i < ThreadNum; ++i) {\n+                    threads[i].join();\n+                }\n+            } catch (InterruptedException ie) {\n+                \/\/ ignore\n+            }\n+\n+            \/\/ If the control reaches here, we have demonstrated that the current process isn't\n+            \/\/ blocked by StdinBlocker because of -Xlog:async.\n+            \/\/\n+            \/\/ the reason we throw a RuntimeException because the normal exit of JVM still needs\n+            \/\/ to call AsyncLogWriter::flush(), stdout is still blocked. AbortVMOnException will\n+            \/\/ abort JVM and avoid the final flushing.\n+            throw new RuntimeException(\"we succeed if we each here.\");\n+        }\n+    }\n+\n+    static class ChurnThread extends Thread {\n+        static long Duration = 3; \/\/ seconds;  Program will exit after Duration of seconds.\n+        static int ReferenceSize = 1024 * 10;  \/\/ each reference object size;\n+        static int CountDownSize = 1000 * 100;\n+        static int EachRemoveSize = 1000 * 50; \/\/ remove # of elements each time.\n+\n+        long timeZero = System.currentTimeMillis();\n+        long finishedUnit = 0;\n+\n+        public ChurnThread() {}\n+\n+        public void run() {\n+            AbstractQueue<String> q = new ArrayBlockingQueue<String>(CountDownSize);\n+            char[] srcArray =new char[ReferenceSize];\n+            String emptystr = new String(srcArray);\n+            long prevTime = timeZero;\n+\n+            while (true) {\n+                \/\/ Simulate object use to force promotion into OldGen and then GC\n+                if (q.size() >= CountDownSize) {\n+                    String strHuge_remove = null;\n+\n+                    for (int j = 0; j < EachRemoveSize; j++) {\n+                        strHuge_remove = q.remove();\n+                    }\n+\n+                    \/\/ every 1000 removal is counted as 1 unit.\n+                    long curTime = System.currentTimeMillis();\n+                    long totalTime = curTime - timeZero;\n+                    prevTime = curTime;\n+\n+                    if (Duration != -1 && totalTime > Duration * 1000) {\n+                        return;\n+                    }\n+                }\n+\n+                srcArray = new char[ReferenceSize];\n+                emptystr = new String(srcArray);\n+                String str = emptystr.replace('\\0', 'a');\n+                q.add(str);\n+            }\n+        }\n+    }\n+\n+    \/\/ StdinBlocker echoes whatever it sees from stdin until it encounters BANNER.\n+    \/\/ it will hang and leave stdin alone.\n+    public static class StdinBlocker {\n+        public static void main(String[] args) throws IOException {\n+            BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n+            String line = in.readLine();\n+\n+            while (line != null) {\n+                \/\/ block stdin once we have seen the banner.\n+                if (line.contains(BANNER)) {\n+                    while (true) {\n+                        Thread.yield();\n+                    }\n+                }\n+                line = in.readLine();\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        \/\/ process 0 pipes its stdout to process 1 as stdin.\n+        \/\/ java -Xlog:all=info -Xlog:async UserDefinedJavaProgram | java StdinBlocker\n+        ProcessBuilder[] builders = {\n+            ProcessTools.createJavaProcessBuilder(\"-XX:+UnlockDiagnosticVMOptions\", \"-XX:AbortVMOnException=java.lang.RuntimeException\",\n+            \/\/ VMError::report_and_die() doesn't honor DisplayVMOutputToStderr, therefore we have to suppress it to avoid starvation\n+            \"-XX:+DisplayVMOutputToStderr\", \"-XX:+SuppressFatalErrorMessage\", \"-XX:-UsePerfData\",\n+            \"-Xlog:all=debug\", \"-Xlog:async\", UserDefinedJavaProgram.class.getName()),\n+            ProcessTools.createJavaProcessBuilder(StdinBlocker.class.getName())\n+        };\n+\n+        List<Process> processes = ProcessBuilder.startPipeline(Arrays.asList(builders));\n+        \/\/ process 0 should abort from Exceptions::debug_check_abort()\n+        int exitcode = processes.get(0).waitFor();\n+        \/\/ exitcode may be 1 or 134.\n+        Asserts.assertNE(exitcode, Integer.valueOf(0));\n+        \/\/ terminate StdinBlocker by force\n+        processes.get(1).destroyForcibly();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/logging\/BlockedLoggingTest.java","additions":166,"deletions":0,"binary":false,"changes":166,"status":"added"}]}