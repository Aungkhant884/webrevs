{"files":[{"patch":"@@ -28,0 +28,1 @@\n+#include \"logging\/logFileStreamOutput.hpp\"\n@@ -141,2 +142,1 @@\n-      int sz = e->output()->write_blocking(e->decorations(), msg);\n-      e->output()->flush(sz);\n+      e->output()->write_blocking(e->decorations(), msg);\n@@ -148,8 +148,0 @@\n-    } else {\n-#ifdef ASSERT\n-      \/\/ only LogFileOutput supports force_rotate();\n-      size_t idx = LogConfiguration::find_output(e->output());\n-      assert(idx != SIZE_MAX && idx > 1, \"e->output() must be a valid LogFileOutput.\");\n-#endif\n-      \/\/ This is a force_rotation token.\n-      static_cast<LogFileOutput*>(e->output())->force_rotate();\n@@ -161,0 +153,3 @@\n+    \/\/ LogFileOutput::write_block() has called fflush().\n+    \/\/ stderr does not cache.\n+    fflush(stdout);\n@@ -225,17 +220,0 @@\n-\n-void AsyncLogWriter::force_rotate(LogOutput* output) {\n-  if (_instance != nullptr) {\n-    assert(output != NULL, \"output can't be NULL\");\n-    {\n-      using none = LogTagSetMapping<LogTag::__NO_TAG>;\n-      AsyncLogLocker locker;\n-      LogDecorations d(LogLevel::Off, none::tagset(), LogDecorators::None);\n-      AsyncLogMessage token(static_cast<LogFileStreamOutput*>(output), d, nullptr);\n-\n-      \/\/ Push directly in-case we are at logical max capacity, as this must not get dropped.\n-      _instance->_buffer.push_back(token);\n-      _instance->_data_available = true;\n-      _instance->_lock.notify();\n-    }\n-  }\n-}\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.cpp","additions":5,"deletions":27,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"logging\/logFileStreamOutput.hpp\"\n@@ -94,0 +93,3 @@\n+\/\/ Forward declaration\n+class LogFileStreamOutput;\n+\n@@ -178,1 +180,0 @@\n-  static void force_rotate(LogOutput* output);\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -176,10 +176,0 @@\n-size_t LogConfiguration::find_output(LogOutput* output) {\n-  for (size_t i = 0; i < _n_outputs; i++) {\n-    if (_outputs[i] == output) {\n-      return i;\n-    }\n-  }\n-\n-  return SIZE_MAX;\n-}\n-\n@@ -688,5 +678,1 @@\n-    if (is_async_mode()) {\n-      AsyncLogWriter::force_rotate(_outputs[idx]);\n-    } else {\n-      _outputs[idx]->force_rotate();\n-    }\n+    _outputs[idx]->force_rotate();\n","filename":"src\/hotspot\/share\/logging\/logConfiguration.cpp","additions":1,"deletions":15,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -101,3 +101,0 @@\n-  \/\/ Get output index. Returns SIZE_MAX if output not found.\n-  static size_t find_output(LogOutput* output);\n-\n","filename":"src\/hotspot\/share\/logging\/logConfiguration.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-      _rotate_size(DefaultFileSize), _current_size(0) {\n+      _rotate_size(DefaultFileSize), _current_size(0), _rotation_semaphore(1) {\n@@ -254,2 +254,2 @@\n-bool LogFileOutput::flush(int written) {\n-  bool result = LogFileStreamOutput::flush(written);\n+class RotationLocker : public StackObj {\n+  Semaphore& _sem;\n@@ -257,1 +257,61 @@\n-  if (result) {\n+ public:\n+  RotationLocker(Semaphore& sem) : _sem(sem) {\n+    sem.wait();\n+  }\n+\n+  ~RotationLocker() {\n+    _sem.signal();\n+  }\n+};\n+\n+int LogFileOutput::write_blocking(const LogDecorations& decorations, const char* msg) {\n+  RotationLocker lock(_rotation_semaphore);\n+  if (_stream == NULL) {\n+    \/\/ An error has occurred with this output, avoid writing to it.\n+    return 0;\n+  }\n+\n+  int written = write_internal(decorations, msg);\n+  \/\/ Need to flush to the filesystem before should_rotate()\n+  written = flush() ? written : -1;\n+  if (written > 0) {\n+    _current_size += written;\n+\n+    if (should_rotate()) {\n+      rotate();\n+    }\n+  }\n+\n+  return written;\n+}\n+\n+int LogFileOutput::write(const LogDecorations& decorations, const char* msg) {\n+  if (_stream == NULL) {\n+    \/\/ An error has occurred with this output, avoid writing to it.\n+    return 0;\n+  }\n+\n+  AsyncLogWriter* aio_writer = AsyncLogWriter::instance();\n+  if (aio_writer != nullptr) {\n+    aio_writer->enqueue(*this, decorations, msg);\n+    return 0;\n+  }\n+\n+  return write_blocking(decorations, msg);\n+}\n+\n+int LogFileOutput::write(LogMessageBuffer::Iterator msg_iterator) {\n+  if (_stream == NULL) {\n+    \/\/ An error has occurred with this output, avoid writing to it.\n+    return 0;\n+  }\n+\n+  AsyncLogWriter* aio_writer = AsyncLogWriter::instance();\n+  if (aio_writer != nullptr) {\n+    aio_writer->enqueue(*this, msg_iterator);\n+    return 0;\n+  }\n+\n+  RotationLocker lock(_rotation_semaphore);\n+  int written = LogFileStreamOutput::write(msg_iterator);\n+  if (written > 0) {\n@@ -264,1 +324,2 @@\n-  return result;\n+\n+  return written;\n@@ -290,1 +351,1 @@\n-  FileLocker lock(this);\n+  RotationLocker lock(_rotation_semaphore);\n@@ -295,6 +356,0 @@\n-  assert(LogConfiguration::is_async_mode() || current_thread_has_lock(),\n-        \"current thread must be holding _stream_lock!\");\n-\n-  if (_stream == NULL)\n-    return;\n-\n","filename":"src\/hotspot\/share\/logging\/logFileOutput.cpp","additions":67,"deletions":12,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"runtime\/semaphore.hpp\"\n@@ -62,0 +63,3 @@\n+  \/\/ Semaphore used for synchronizing file rotations and writes\n+  Semaphore _rotation_semaphore;\n+\n@@ -76,0 +80,1 @@\n+\n@@ -79,6 +84,9 @@\n-  virtual bool initialize(const char* options, outputStream* errstream) override;\n-  virtual bool set_option(const char* key, const char* value, outputStream* errstream) override;\n-  virtual bool flush(int written) override;\n-  virtual void force_rotate() override;\n-  virtual void describe(outputStream* out) override;\n-  virtual const char* name() const override {\n+  virtual bool initialize(const char* options, outputStream* errstream);\n+  virtual bool set_option(const char* key, const char* value, outputStream* errstream);\n+  int write(const LogDecorations& decorations, const char* msg) override;\n+  int write(LogMessageBuffer::Iterator msg_iterator) override;\n+  int write_blocking(const LogDecorations& decorations, const char* msg) override;\n+  virtual void force_rotate();\n+  virtual void describe(outputStream* out);\n+\n+  virtual const char* name() const {\n","filename":"src\/hotspot\/share\/logging\/logFileOutput.hpp","additions":14,"deletions":6,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n-#include \"logging\/logAsyncWriter.hpp\"\n-#include \"logging\/logConfiguration.hpp\"\n@@ -97,18 +95,7 @@\n-\/\/ if async-logging is on, this function is called by AsyncLog Thread sequentially.\n-\/\/ if async-logging is off, this function is called from write(). Therefore, current thread\n-\/\/ is holding _stream_lock\n-bool LogFileStreamOutput::flush(int written) {\n-  assert(LogConfiguration::is_async_mode() || current_thread_has_lock(),\n-        \"current thread must be holding _stream_lock!\");\n-\n-  bool result = written >= 0 ? true : false;\n-  if (written > 0) {\n-    if (fflush(_stream) != 0) {\n-      if (!_write_error_is_shown) {\n-        jio_fprintf(defaultStream::error_stream(),\n-                    \"Could not flush log: %s (%s (%d))\\n\", name(), os::strerror(errno), errno);\n-        jio_fprintf(_stream, \"\\nERROR: Could not flush log (%d)\\n\", errno);\n-        _write_error_is_shown = true;\n-      }\n-      result = false;\n-    }\n+class FileLocker : public StackObj {\n+private:\n+  FILE *_file;\n+\n+public:\n+  FileLocker(FILE *file) : _file(file) {\n+    os::flockfile(_file);\n@@ -117,0 +104,16 @@\n+  ~FileLocker() {\n+    os::funlockfile(_file);\n+  }\n+};\n+\n+bool LogFileStreamOutput::flush() {\n+  bool result = true;\n+  if (fflush(_stream) != 0) {\n+    if (!_write_error_is_shown) {\n+      jio_fprintf(defaultStream::error_stream(),\n+                  \"Could not flush log: %s (%s (%d))\\n\", name(), os::strerror(errno), errno);\n+      jio_fprintf(_stream, \"\\nERROR: Could not flush log (%d)\\n\", errno);\n+      _write_error_is_shown = true;\n+    }\n+    result = false;\n+  }\n@@ -135,1 +138,1 @@\n-int LogFileStreamOutput::write_internal(const char* msg) {\n+int LogFileStreamOutput::write_internal(const LogDecorations& decorations, const char* msg) {\n@@ -137,0 +140,7 @@\n+  const bool use_decorations = !_decorators.is_empty();\n+\n+  if (use_decorations) {\n+    WRITE_LOG_WITH_RESULT_CHECK(write_decorations(decorations), written);\n+    WRITE_LOG_WITH_RESULT_CHECK(jio_fprintf(_stream, \" \"), written);\n+  }\n+\n@@ -160,14 +170,1 @@\n-  if (_stream == nullptr) {\n-    \/\/ An error has occurred with this output, avoid writing to it.\n-    return 0;\n-  }\n-\n-  const bool use_decorations = !_decorators.is_empty();\n-\n-  int written = 0;\n-  if (use_decorations) {\n-    WRITE_LOG_WITH_RESULT_CHECK(write_decorations(decorations), written);\n-    WRITE_LOG_WITH_RESULT_CHECK(jio_fprintf(_stream, \" \"), written);\n-  }\n-  written += write_internal(msg);\n-  return written;\n+  return write_internal(decorations, msg);\n@@ -177,5 +174,0 @@\n-  if (_stream == nullptr) {\n-    \/\/ An error has occurred with this output, avoid writing to it.\n-    return 0;\n-  }\n-\n@@ -188,3 +180,4 @@\n-  FileLocker flocker(this);\n-  int written = write_blocking(decorations, msg);\n-  return flush(written) ? written : -1;\n+  FileLocker flocker(_stream);\n+  int written = write_internal(decorations, msg);\n+\n+  return flush() ? written : -1;\n@@ -194,5 +187,0 @@\n-  if (_stream == nullptr) {\n-    \/\/ An error has occurred with this output, avoid writing to it.\n-    return 0;\n-  }\n-\n@@ -205,1 +193,0 @@\n-  FileLocker flocker(this);\n@@ -207,0 +194,1 @@\n+  FileLocker flocker(_stream);\n@@ -208,3 +196,1 @@\n-    int sz = write_blocking(msg_iterator.decorations(), msg_iterator.message());\n-    if (sz < 0) return sz;\n-    written += sz;\n+    written += write_internal(msg_iterator.decorations(), msg_iterator.message());\n@@ -213,1 +199,1 @@\n-  return flush(written) ? written : -1;\n+  return flush() ? written : -1;\n@@ -222,6 +208,0 @@\n-\n-#ifdef ASSERT\n-bool LogFileStreamOutput::current_thread_has_lock() {\n-  return _locking_thread_id == os::current_thread_id();\n-}\n-#endif\n","filename":"src\/hotspot\/share\/logging\/logFileStreamOutput.cpp","additions":39,"deletions":59,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"logging\/logAsyncWriter.hpp\"\n@@ -30,1 +31,0 @@\n-#include \"runtime\/semaphore.hpp\"\n@@ -49,1 +49,1 @@\n-  int write_internal(const char* msg);\n+\n@@ -52,3 +52,0 @@\n-  \/\/ Semaphore used for synchronizing file rotations and writes\n-  Semaphore           _stream_lock;\n-  debug_only(intx     _locking_thread_id = -1;)\n@@ -57,1 +54,1 @@\n-  LogFileStreamOutput(FILE *stream) : _fold_multilines(false), _write_error_is_shown(false), _stream(stream), _stream_lock(1) {\n+  LogFileStreamOutput(FILE *stream) : _fold_multilines(false), _write_error_is_shown(false), _stream(stream) {\n@@ -64,23 +61,2 @@\n-\n-  \/\/ sempahore-based mutex. Implementation of flockfile do not work with LogFileOuptut::rotate()\n-  \/\/ because fclose() automatically unlocks FILE->_lock and nullifies FileLocker protection.\n-  class FileLocker : public StackObj {\n-    Semaphore& _sem;\n-    debug_only(intx& _locking_thread_id;)\n-\n-   public:\n-    FileLocker(LogFileStreamOutput* output) : _sem(output->_stream_lock)\n-#ifdef ASSERT\n-    , _locking_thread_id(output->_locking_thread_id)\n-#endif\n-     {\n-      _sem.wait();\n-      debug_only(_locking_thread_id = os::current_thread_id());\n-    }\n-\n-    ~FileLocker() {\n-      debug_only(_locking_thread_id = -1);\n-      _sem.signal();\n-    }\n-  };\n-  debug_only(bool current_thread_has_lock();)\n+  int write_internal(const LogDecorations& decorations, const char* msg);\n+  bool flush();\n@@ -90,4 +66,4 @@\n-  int write(const LogDecorations& decorations, const char* msg);\n-  int write(LogMessageBuffer::Iterator msg_iterator);\n-  int write_blocking(const LogDecorations& decorations, const char* msg);\n-  virtual bool flush(int written);\n+  virtual int write(const LogDecorations& decorations, const char* msg);\n+  virtual int write(LogMessageBuffer::Iterator msg_iterator);\n+  \/\/ Write API used by AsyncLogWriter\n+  virtual int write_blocking(const LogDecorations& decorations, const char* msg);\n","filename":"src\/hotspot\/share\/logging\/logFileStreamOutput.hpp","additions":9,"deletions":33,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -27,2 +27,2 @@\n- * @summary Test the JVM process with async unified logging won't be frozen\n- * when stdout is blocked.\n+ * @summary Test the JVM process with unified logging with -Xlog:async will not be\n+ * frozen even when stdout is blocked.\n@@ -50,3 +50,0 @@\n-    \/\/ process 0 emits unified log to stdout. We must ensure that nobody except for UL emits to stdout.\n-    \/\/ we expect to demonstrate that process 0 with -Xlog:async can still terminate even though its\n-    \/\/ stdout is blocked.\n@@ -59,2 +56,2 @@\n-            \/\/ the size of pipe buffer is hard to tell. just churn many gc-related logs\n-            \/\/ in ChurnThread.Duration sececonds. it's presumably 64k on Linux.\n+            \/\/ The size of pipe buffer is indeterminate. It is presumably 64k on many Linux distros.\n+            \/\/ We just churn many gc-related logs in ChurnThread.Duration seconds.\n@@ -91,1 +88,0 @@\n-        long finishedUnit = 0;\n@@ -97,1 +93,1 @@\n-            char[] srcArray =new char[ReferenceSize];\n+            char[] srcArray = new char[ReferenceSize];\n@@ -99,1 +95,0 @@\n-            long prevTime = timeZero;\n@@ -104,2 +99,0 @@\n-                    String strHuge_remove = null;\n-\n@@ -107,1 +100,1 @@\n-                        strHuge_remove = q.remove();\n+                        q.remove();\n@@ -113,1 +106,0 @@\n-                    prevTime = curTime;\n@@ -129,1 +121,1 @@\n-    \/\/ it will hang and leave stdin alone.\n+    \/\/ It will hang and leave stdin alone.\n@@ -139,1 +131,3 @@\n-                        Thread.yield();\n+                        try {\n+                            Thread.sleep(Long.MAX_VALUE);\n+                        } catch (InterruptedException ie) {\/* skip on purpose *\/}\n@@ -148,2 +142,3 @@\n-        \/\/ process 0 pipes its stdout to process 1 as stdin.\n-        \/\/ java -Xlog:all=info -Xlog:async UserDefinedJavaProgram | java StdinBlocker\n+        \/\/ The simplest test is to use tty with software flow control. AsyncUL should not suspend JVM\n+        \/\/ with XOFF(Ctrl^s) to stdout. We can not assume tty is in use in the testing environments. It is also\n+        \/\/ not portable. Therefore, the test uses pipe to simulate suspending stdout.\n@@ -151,0 +146,3 @@\n+            \/\/ Process 0 has to carefully avoid any output to stdout except Unified Logging.\n+            \/\/ We expect to demonstrate that process 0 with -Xlog:async can still terminate even though its stdout\n+            \/\/ is blocked.\n@@ -152,3 +150,3 @@\n-            \/\/ VMError::report_and_die() doesn't honor DisplayVMOutputToStderr, therefore we have to suppress it to avoid starvation\n-            \"-XX:+DisplayVMOutputToStderr\", \"-XX:+SuppressFatalErrorMessage\", \"-XX:-UsePerfData\",\n-            \"-Xlog:all=debug\", \"-Xlog:async\", UserDefinedJavaProgram.class.getName()),\n+            \"-XX:+DisplayVMOutputToStderr\", \"-XX:+SuppressFatalErrorMessage\", \"-XX:-UsePerfData\", \"-Xlog:all=debug\",\n+            \"-Xlog:async\", \/\/ should hang without this!\n+            UserDefinedJavaProgram.class.getName()),\n@@ -159,1 +157,1 @@\n-        \/\/ process 0 should abort from Exceptions::debug_check_abort()\n+        \/\/ Process 0 should abort from Exceptions::debug_check_abort()\n@@ -161,1 +159,1 @@\n-        \/\/ exitcode may be 1 or 134.\n+        \/\/ Exitcode may be 1 or 134.\n@@ -163,1 +161,1 @@\n-        \/\/ terminate StdinBlocker by force\n+        \/\/ Terminate StdinBlocker by force\n","filename":"test\/hotspot\/jtreg\/runtime\/logging\/BlockedLoggingTest.java","additions":22,"deletions":24,"binary":false,"changes":46,"status":"modified"}]}