{"files":[{"patch":"@@ -153,4 +153,0 @@\n-    \/\/ LogFileOutput::write_block() has called fflush().\n-    \/\/ Only LogFileStreamOutput instances need to flush here.\n-    \/\/ stderr is unbuffered.\n-    fflush(stdout);\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -171,1 +171,2 @@\n-  return write_internal(decorations, msg);\n+  int written = write_internal(decorations, msg);\n+  return flush() ? written : -1;\n","filename":"src\/hotspot\/share\/logging\/logFileStreamOutput.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -69,0 +69,32 @@\n+\n+  void test_asynclog_drop_messages() {\n+    if (AsyncLogWriter::instance() != nullptr) {\n+      const size_t sz = 100;\n+\n+      \/\/ shrink async buffer.\n+      AutoModifyRestore<size_t> saver(AsyncLogBufferSize, sz * 1024 \/*in byte*\/);\n+      LogMessage(logging) lm;\n+\n+      \/\/ write 100x more messages than its capacity in burst\n+      for (size_t i = 0; i < sz * 100; ++i) {\n+        lm.debug(\"a lot of log...\");\n+      }\n+      lm.flush();\n+    }\n+  }\n+\n+  \/\/ stdout\/stderr support\n+  bool write_to_file(const std::string& output) {\n+    FILE* f = fopen(TestLogFileName, \"w\");\n+\n+    if (f != NULL) {\n+      size_t sz = output.size();\n+      size_t written = fwrite(output.c_str(), sizeof(char), output.size(), f);\n+\n+      if (written == sz * sizeof(char)) {\n+        return fclose(f) == 0;\n+      }\n+    }\n+\n+    return false;\n+  }\n@@ -201,1 +233,1 @@\n-  const size_t sz = 100;\n+  test_asynclog_drop_messages();\n@@ -203,0 +235,1 @@\n+  AsyncLogWriter::flush();\n@@ -204,3 +237,3 @@\n-    \/\/ shrink async buffer.\n-    AutoModifyRestore<size_t> saver(AsyncLogBufferSize, sz * 1024 \/*in byte*\/);\n-    LogMessage(logging) lm;\n+    EXPECT_TRUE(file_contains_substring(TestLogFileName, \"messages dropped due to async logging\"));\n+  }\n+}\n@@ -208,6 +241,34 @@\n-    \/\/ write 100x more messages than its capacity in burst\n-    for (size_t i = 0; i < sz * 100; ++i) {\n-      lm.debug(\"a lot of log...\");\n-    }\n-    lm.flush();\n-    AsyncLogWriter::flush();\n+TEST_VM_F(AsyncLogTest, stdoutOutput) {\n+  testing::internal::CaptureStdout();\n+  set_log_config(\"stdout\", \"logging=debug\");\n+\n+  test_asynclog_ls();\n+  test_asynclog_drop_messages();\n+\n+  AsyncLogWriter::flush();\n+  EXPECT_TRUE(write_to_file(testing::internal::GetCapturedStdout()));\n+\n+  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"LogStreamWithAsyncLogImpl\"));\n+  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"logStream msg1-msg2-msg3\"));\n+  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"logStream newline\"));\n+\n+  if (AsyncLogWriter::instance() != nullptr) {\n+    EXPECT_TRUE(file_contains_substring(TestLogFileName, \"messages dropped due to async logging\"));\n+  }\n+}\n+\n+TEST_VM_F(AsyncLogTest, stderrOutput) {\n+  testing::internal::CaptureStderr();\n+  set_log_config(\"stderr\", \"logging=debug\");\n+\n+  test_asynclog_ls();\n+  test_asynclog_drop_messages();\n+\n+  AsyncLogWriter::flush();\n+  EXPECT_TRUE(write_to_file(testing::internal::GetCapturedStderr()));\n+\n+  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"LogStreamWithAsyncLogImpl\"));\n+  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"logStream msg1-msg2-msg3\"));\n+  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"logStream newline\"));\n+\n+  if (AsyncLogWriter::instance() != nullptr) {\n","filename":"test\/hotspot\/gtest\/logging\/test_asynclog.cpp","additions":71,"deletions":10,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -113,1 +113,0 @@\n-runtime\/logging\/BlockedLoggingTest.java 8267517 generic-all\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,164 +0,0 @@\n-\/*\n- * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8267517\n- * @summary Test the JVM process with unified logging with -Xlog:async will not be\n- * frozen even when stdout is blocked.\n- *\n- * @library \/test\/lib\n- * @modules java.base\/jdk.internal.misc\n- * @run driver BlockedLoggingTest\n- *\/\n-\n-import java.io.BufferedReader;\n-import java.io.InputStreamReader;\n-import java.io.IOException;\n-import java.util.AbstractQueue;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.concurrent.ArrayBlockingQueue;\n-\n-import jdk.test.lib.Asserts;\n-import jdk.test.lib.process.ProcessTools;\n-\n-public class BlockedLoggingTest {\n-    static String BANNER = \"User-defined Java Program has started.\";\n-    static int ThreadNum = 1;\n-\n-    public static class UserDefinedJavaProgram {\n-        public static void main(String[] args) {\n-            System.out.println(BANNER);\n-            System.out.flush();\n-\n-            Thread[] threads = new Thread[ThreadNum];\n-            \/\/ The size of pipe buffer is indeterminate. It is presumably 64k on many Linux distros.\n-            \/\/ We just churn many gc-related logs in ChurnThread.Duration seconds.\n-            for (int i = 0; i < ThreadNum; ++i) {\n-                threads[i] = new ChurnThread();\n-                threads[i].start();\n-            }\n-\n-            try {\n-                for (int i = 0; i < ThreadNum; ++i) {\n-                    threads[i].join();\n-                }\n-            } catch (InterruptedException ie) {\n-                \/\/ ignore\n-            }\n-\n-            \/\/ If the control reaches here, we have demonstrated that the current process isn't\n-            \/\/ blocked by StdinBlocker because of -Xlog:async.\n-            \/\/\n-            \/\/ The reason we throw a RuntimeException because the normal exit of JVM still needs\n-            \/\/ to call AsyncLogWriter::flush(), stdout is still blocked. AbortVMOnException will\n-            \/\/ abort JVM and avoid the final flushing.\n-            throw new RuntimeException(\"we succeed if we each here.\");\n-        }\n-    }\n-\n-    static class ChurnThread extends Thread {\n-        static long Duration = 3; \/\/ seconds;  Program will exit after Duration of seconds.\n-        static int ReferenceSize = 1024 * 10;  \/\/ each reference object size;\n-        static int CountDownSize = 1000 * 100;\n-        static int EachRemoveSize = 1000 * 50; \/\/ remove # of elements each time.\n-\n-        long timeZero = System.currentTimeMillis();\n-\n-        public ChurnThread() {}\n-\n-        public void run() {\n-            AbstractQueue<String> q = new ArrayBlockingQueue<String>(CountDownSize);\n-            char[] srcArray = new char[ReferenceSize];\n-            String emptystr = new String(srcArray);\n-\n-            while (true) {\n-                \/\/ Simulate object use to force promotion into OldGen and then GC\n-                if (q.size() >= CountDownSize) {\n-                    for (int j = 0; j < EachRemoveSize; j++) {\n-                        q.remove();\n-                    }\n-\n-                    \/\/ every 1000 removal is counted as 1 unit.\n-                    long curTime = System.currentTimeMillis();\n-                    long totalTime = curTime - timeZero;\n-\n-                    if (Duration != -1 && totalTime > Duration * 1000) {\n-                        return;\n-                    }\n-                }\n-\n-                srcArray = new char[ReferenceSize];\n-                emptystr = new String(srcArray);\n-                String str = emptystr.replace('\\0', 'a');\n-                q.add(str);\n-            }\n-        }\n-    }\n-\n-    \/\/ StdinBlocker echoes whatever it sees from stdin until it encounters BANNER.\n-    \/\/ It will hang and leave stdin alone.\n-    public static class StdinBlocker {\n-        public static void main(String[] args) throws IOException {\n-            BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n-            String line = in.readLine();\n-\n-            while (line != null) {\n-                \/\/ block stdin once we have seen the banner.\n-                if (line.contains(BANNER)) {\n-                    while (true) {\n-                        try {\n-                            Thread.sleep(Long.MAX_VALUE);\n-                        } catch (InterruptedException ie) {\/* skip on purpose *\/}\n-                    }\n-                }\n-                line = in.readLine();\n-            }\n-        }\n-    }\n-\n-    public static void main(String[] args) throws Exception {\n-        \/\/ The simplest test is to use tty with software flow control. AsyncUL should not suspend JVM\n-        \/\/ with XOFF(Ctrl^s) to stdout. We can not assume tty is in use in the testing environments. It is also\n-        \/\/ not portable. Therefore, the test uses pipe to simulate the suspending stdout.\n-        ProcessBuilder[] builders = {\n-            \/\/ Process 0 has to carefully avoid any output to stdout except Unified Logging.\n-            \/\/ We expect to demonstrate that process 0 with -Xlog:async can still terminate even though its stdout\n-            \/\/ is blocked.\n-            ProcessTools.createJavaProcessBuilder(\"-XX:+UnlockDiagnosticVMOptions\", \"-XX:AbortVMOnException=java.lang.RuntimeException\",\n-            \"-XX:+DisplayVMOutputToStderr\", \"-XX:+SuppressFatalErrorMessage\", \"-XX:-UsePerfData\", \"-Xlog:all=debug\",\n-            \"-Xlog:async\", \/\/ should hang without this!\n-            UserDefinedJavaProgram.class.getName()),\n-            ProcessTools.createJavaProcessBuilder(StdinBlocker.class.getName())\n-        };\n-\n-        List<Process> processes = ProcessBuilder.startPipeline(Arrays.asList(builders));\n-        \/\/ Process 0 should abort from Exceptions::debug_check_abort()\n-        int exitcode = processes.get(0).waitFor();\n-        \/\/ Exitcode may be 1 or 134.\n-        Asserts.assertNE(exitcode, Integer.valueOf(0));\n-        \/\/ Terminate StdinBlocker by force\n-        processes.get(1).destroyForcibly();\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/logging\/BlockedLoggingTest.java","additions":0,"deletions":164,"binary":false,"changes":164,"status":"deleted"}]}