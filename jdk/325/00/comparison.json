{"files":[{"patch":"@@ -102,0 +102,1 @@\n+  S390_ONLY(_ctable_offset = 0;) \/\/ avoid uninitialized fields\n@@ -131,0 +132,1 @@\n+  S390_ONLY(_ctable_offset = 0;) \/\/ avoid uninitialized fields\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"runtime\/safepoint.hpp\"\n@@ -213,1 +214,1 @@\n-                             ,     \"nMethod (under construction)\"\n+                             ,     \"nMethod (under construction), cannot be observed\"\n@@ -234,1 +235,1 @@\n-const  unsigned int        maxTopSizeBlocks  = 50;\n+const  unsigned int        maxTopSizeBlocks  = 100;\n@@ -251,1 +252,0 @@\n-static unsigned int nBlocks_inconstr      = 0;  \/\/ counting \"inconstruction\" nmethods only. This is a transient state.\n@@ -322,1 +322,0 @@\n-    nBlocks_inconstr      = CodeHeapStatArray[ix].nBlocks_inconstr;\n@@ -345,1 +344,0 @@\n-    nBlocks_inconstr      = 0;\n@@ -372,1 +370,0 @@\n-    CodeHeapStatArray[ix].nBlocks_inconstr      = nBlocks_inconstr;\n@@ -499,0 +496,5 @@\n+    for (unsigned int i = 0; i < alloc_topSizeBlocks; i++) {\n+      if (TopSizeArray[i].blob_name != NULL) {\n+        os::free((void*)TopSizeArray[i].blob_name);\n+      }\n+    }\n@@ -592,2 +594,2 @@\n-  if (!CodeCache_lock->owned_by_self()) {\n-    printBox(ast, '-', \"aggregate function called without holding the CodeCache_lock for \", heapName);\n+  if (!holding_required_locks()) {\n+    printBox(ast, '-', \"Must be at safepoint or hold Compile_lock and CodeCache_lock when calling aggregate function for \", heapName);\n@@ -660,1 +662,0 @@\n-    nBlocks_inconstr = 0;\n@@ -694,1 +695,0 @@\n-    size_t       inconstrSpace = 0;\n@@ -756,6 +756,20 @@\n-        if (cb != NULL) {\n-          cbType = get_cbType(cb);\n-          if (cb->is_nmethod()) {\n-            compile_id = ((nmethod*)cb)->compile_id();\n-            comp_lvl   = (CompLevel)((nmethod*)cb)->comp_level();\n-            if (((nmethod*)cb)->is_compiled_by_c1()) {\n+        cbType = get_cbType(cb);  \/\/ Will check for cb == NULL and other safety things.\n+        if (cbType != noType) {\n+          const char* blob_name  = os::strdup(cb->name());\n+          unsigned int nm_size   = 0;\n+          int temperature        = 0;\n+          nmethod*  nm = cb->as_nmethod_or_null();\n+          if (nm != NULL) { \/\/ no is_readable check required, nm = (nmethod*)cb.\n+            ResourceMark rm;\n+            Method* method = nm->method();\n+            if (nm->is_in_use()) {\n+              blob_name = os::strdup(method->name_and_sig_as_C_string());\n+            }\n+            if (nm->is_not_entrant()) {\n+              blob_name = os::strdup(method->name_and_sig_as_C_string());\n+            }\n+\n+            nm_size    = nm->total_size();\n+            compile_id = nm->compile_id();\n+            comp_lvl   = (CompLevel)(nm->comp_level());\n+            if (nm->is_compiled_by_c1()) {\n@@ -764,1 +778,1 @@\n-            if (((nmethod*)cb)->is_compiled_by_c2()) {\n+            if (nm->is_compiled_by_c2()) {\n@@ -767,1 +781,1 @@\n-            if (((nmethod*)cb)->is_compiled_by_jvmci()) {\n+            if (nm->is_compiled_by_jvmci()) {\n@@ -773,1 +787,1 @@\n-                int temperature = ((nmethod*)cb)->hotness_counter();\n+                temperature = nm->hotness_counter();\n@@ -800,4 +814,0 @@\n-              case nMethod_inconstruction:\n-                nBlocks_inconstr++;\n-                inconstrSpace  += hb_bytelen;\n-                break;\n@@ -814,6 +824,9 @@\n-              TopSizeArray[0].start    = h;\n-              TopSizeArray[0].len      = hb_len;\n-              TopSizeArray[0].index    = tsbStopper;\n-              TopSizeArray[0].compiler = cType;\n-              TopSizeArray[0].level    = comp_lvl;\n-              TopSizeArray[0].type     = cbType;\n+              TopSizeArray[0].start       = h;\n+              TopSizeArray[0].blob_name   = blob_name;\n+              TopSizeArray[0].len         = hb_len;\n+              TopSizeArray[0].index       = tsbStopper;\n+              TopSizeArray[0].nm_size     = nm_size;\n+              TopSizeArray[0].temperature = temperature;\n+              TopSizeArray[0].compiler    = cType;\n+              TopSizeArray[0].level       = comp_lvl;\n+              TopSizeArray[0].type        = cbType;\n@@ -824,0 +837,1 @@\n+              blob_name  = NULL; \/\/ indicate blob_name was consumed\n@@ -828,6 +842,9 @@\n-              TopSizeArray[used_topSizeBlocks].start    = h;\n-              TopSizeArray[used_topSizeBlocks].len      = hb_len;\n-              TopSizeArray[used_topSizeBlocks].index    = tsbStopper;\n-              TopSizeArray[used_topSizeBlocks].compiler = cType;\n-              TopSizeArray[used_topSizeBlocks].level    = comp_lvl;\n-              TopSizeArray[used_topSizeBlocks].type     = cbType;\n+              TopSizeArray[used_topSizeBlocks].start       = h;\n+              TopSizeArray[used_topSizeBlocks].blob_name   = blob_name;\n+              TopSizeArray[used_topSizeBlocks].len         = hb_len;\n+              TopSizeArray[used_topSizeBlocks].index       = tsbStopper;\n+              TopSizeArray[used_topSizeBlocks].nm_size     = nm_size;\n+              TopSizeArray[used_topSizeBlocks].temperature = temperature;\n+              TopSizeArray[used_topSizeBlocks].compiler    = cType;\n+              TopSizeArray[used_topSizeBlocks].level       = comp_lvl;\n+              TopSizeArray[used_topSizeBlocks].type        = cbType;\n@@ -837,0 +854,1 @@\n+              blob_name  = NULL; \/\/ indicate blob_name was consumed\n@@ -867,6 +885,9 @@\n-                      TopSizeArray[i].start    = h;\n-                      TopSizeArray[i].len      = hb_len;\n-                      TopSizeArray[i].index    = used_topSizeBlocks;\n-                      TopSizeArray[i].compiler = cType;\n-                      TopSizeArray[i].level    = comp_lvl;\n-                      TopSizeArray[i].type     = cbType;\n+                      TopSizeArray[i].start       = h;\n+                      TopSizeArray[i].blob_name   = blob_name;\n+                      TopSizeArray[i].len         = hb_len;\n+                      TopSizeArray[i].index       = used_topSizeBlocks;\n+                      TopSizeArray[i].nm_size     = nm_size;\n+                      TopSizeArray[i].temperature = temperature;\n+                      TopSizeArray[i].compiler    = cType;\n+                      TopSizeArray[i].level       = comp_lvl;\n+                      TopSizeArray[i].type        = cbType;\n@@ -874,0 +895,1 @@\n+                      blob_name  = NULL; \/\/ indicate blob_name was consumed\n@@ -876,0 +898,6 @@\n+                      \/\/ We either want to insert right before the smallest entry, which is when <i>\n+                      \/\/ indexes the smallest entry. We then just overwrite the smallest entry.\n+                      \/\/ What's more likely:\n+                      \/\/ We want to insert somewhere in the list. The smallest entry (@<j>) then falls off the cliff.\n+                      \/\/ The element at the insert point <i> takes it's slot. The second-smallest entry now becomes smallest.\n+                      \/\/ Data of the current block is filled in at index <i>.\n@@ -891,0 +919,3 @@\n+                        if (TopSizeArray[j].blob_name != NULL) {\n+                          os::free((void*)TopSizeArray[j].blob_name);\n+                        }\n@@ -896,6 +927,9 @@\n-                          TopSizeArray[j].start    = h;\n-                          TopSizeArray[j].len      = hb_len;\n-                          TopSizeArray[j].index    = tsbStopper; \/\/ already set!!\n-                          TopSizeArray[j].compiler = cType;\n-                          TopSizeArray[j].level    = comp_lvl;\n-                          TopSizeArray[j].type     = cbType;\n+                          TopSizeArray[j].start       = h;\n+                          TopSizeArray[j].blob_name   = blob_name;\n+                          TopSizeArray[j].len         = hb_len;\n+                          TopSizeArray[j].index       = tsbStopper; \/\/ already set!!\n+                          TopSizeArray[i].nm_size     = nm_size;\n+                          TopSizeArray[i].temperature = temperature;\n+                          TopSizeArray[j].compiler    = cType;\n+                          TopSizeArray[j].level       = comp_lvl;\n+                          TopSizeArray[j].type        = cbType;\n@@ -907,1 +941,1 @@\n-                          \/\/---<  smallest entry gets overwritten  >---\n+                          \/\/---<  previously smallest entry gets overwritten  >---\n@@ -909,6 +943,9 @@\n-                          TopSizeArray[i].start    = h;\n-                          TopSizeArray[i].len      = hb_len;\n-                          TopSizeArray[i].index    = j;\n-                          TopSizeArray[i].compiler = cType;\n-                          TopSizeArray[i].level    = comp_lvl;\n-                          TopSizeArray[i].type     = cbType;\n+                          TopSizeArray[i].start       = h;\n+                          TopSizeArray[i].blob_name   = blob_name;\n+                          TopSizeArray[i].len         = hb_len;\n+                          TopSizeArray[i].index       = j;\n+                          TopSizeArray[i].nm_size     = nm_size;\n+                          TopSizeArray[i].temperature = temperature;\n+                          TopSizeArray[i].compiler    = cType;\n+                          TopSizeArray[i].level       = comp_lvl;\n+                          TopSizeArray[i].type        = cbType;\n@@ -916,0 +953,1 @@\n+                        blob_name  = NULL; \/\/ indicate blob_name was consumed\n@@ -930,0 +968,4 @@\n+          if (blob_name != NULL) {\n+            os::free((void*)blob_name);\n+            blob_name = NULL;\n+          }\n@@ -958,1 +1000,0 @@\n-            case nMethod_inconstruction: \/\/ let's count \"in construction\" nmethods here.\n@@ -1015,1 +1056,0 @@\n-            case nMethod_inconstruction: \/\/ let's count \"in construction\" nmethods here.\n@@ -1063,1 +1103,0 @@\n-              case nMethod_inconstruction: \/\/ let's count \"in construction\" nmethods here.\n@@ -1100,1 +1139,0 @@\n-      ast->print_cr(\"  inconstrSpace  = \" SIZE_FORMAT_W(8) \"k, nBlocks_inconstr = %6d, %10.3f%% of capacity, %10.3f%% of max_capacity\", inconstrSpace\/(size_t)K, nBlocks_inconstr, (100.0*inconstrSpace)\/size, (100.0*inconstrSpace)\/res_size);\n@@ -1278,1 +1316,1 @@\n-        if ((cb != NULL) && !cb->is_nmethod()) {\n+        if ((cb != NULL) && !cb->is_nmethod()) { \/\/ checks equivalent to those in get_cbType()\n@@ -1329,2 +1367,1 @@\n-    char*     low_bound = heap->low_boundary();\n-    bool      have_CodeCache_lock = CodeCache_lock->owned_by_self();\n+    char*     low_bound  = heap->low_boundary();\n@@ -1349,2 +1386,3 @@\n-        nmethod*           nm = NULL;\n-        const char* blob_name = \"unnamed blob or blob name unavailable\";\n+        if (TopSizeArray[i].blob_name == NULL) {\n+          TopSizeArray[i].blob_name = os::strdup(\"unnamed blob or blob name unavailable\");\n+        }\n@@ -1355,2 +1393,1 @@\n-        bool    blob_is_safe = blob_access_is_safe(this_blob, NULL);\n-        if (blob_is_safe) {\n+        if (this_blob != NULL) {\n@@ -1358,4 +1395,0 @@\n-          if (have_CodeCache_lock) {\n-            blob_name = this_blob->name();\n-            nm        = this_blob->as_nmethod_or_null();\n-          }\n@@ -1378,11 +1411,2 @@\n-        \/\/ access nmethod and Method fields only if we own the CodeCache_lock.\n-        \/\/ This fact is implicitly transported via nm != NULL.\n-        if (CompiledMethod::nmethod_access_is_safe(nm)) {\n-          ResourceMark rm;\n-          Method* method = nm->method();\n-          if (nm->is_in_use()) {\n-            blob_name = method->name_and_sig_as_C_string();\n-          }\n-          if (nm->is_not_entrant()) {\n-            blob_name = method->name_and_sig_as_C_string();\n-          }\n+        bool is_nmethod = TopSizeArray[i].nm_size > 0;\n+        if (is_nmethod) {\n@@ -1390,3 +1414,2 @@\n-          unsigned int total_size = nm->total_size();\n-          ast->print(PTR32_FORMAT, total_size);\n-          ast->print(\"(\" SIZE_FORMAT_W(4) \"K)\", total_size\/K);\n+          ast->print(PTR32_FORMAT, TopSizeArray[i].nm_size);\n+          ast->print(\"(\" SIZE_FORMAT_W(4) \"K)\", TopSizeArray[i].nm_size\/K);\n@@ -1400,1 +1423,1 @@\n-          ast->print(\"%5d\", nm->hotness_counter());\n+          ast->print(\"%5d\", TopSizeArray[i].temperature);\n@@ -1403,4 +1426,1 @@\n-          if (nm->is_not_installed()) {\n-            ast->print(\" not (yet) installed method \");\n-          }\n-          if (nm->is_zombie()) {\n+          if (TopSizeArray[i].type == nMethod_dead) {\n@@ -1409,1 +1429,1 @@\n-          ast->print(\"%s\", blob_name);\n+          ast->print(\"%s\", TopSizeArray[i].blob_name);\n@@ -1418,1 +1438,1 @@\n-          ast->print(\"%s\", blob_name);\n+          ast->print(\"%s\", TopSizeArray[i].blob_name);\n@@ -2199,1 +2219,1 @@\n-  bool         have_CodeCache_lock = CodeCache_lock->owned_by_self();\n+  bool         have_locks          = holding_required_locks();\n@@ -2211,1 +2231,1 @@\n-                \"  over time passed between aggregtion and print steps.\\n\");\n+                \"  over time passed between aggregation and print steps.\\n\");\n@@ -2238,1 +2258,1 @@\n-      bool   blob_is_safe = blob_access_is_safe(this_blob, NULL);\n+      bool   blob_is_safe = blob_access_is_safe(this_blob);\n@@ -2250,1 +2270,1 @@\n-          if (have_CodeCache_lock) {\n+          if (have_locks) {\n@@ -2258,1 +2278,1 @@\n-        if (have_CodeCache_lock) {\n+        if (have_locks) {\n@@ -2262,1 +2282,1 @@\n-          if ((blob_name == NULL) || !os::is_readable_pointer(blob_name)) {\n+          if (blob_name == NULL) {\n@@ -2286,1 +2306,1 @@\n-        if (CompiledMethod::nmethod_access_is_safe(nm)) {\n+        if (nmethod_access_is_safe(nm)) {\n@@ -2492,0 +2512,2 @@\n+\/\/ Find out which blob type we have at hand.\n+\/\/ Return \"noType\" if anything abnormal is detected.\n@@ -2493,1 +2515,1 @@\n-  if ((cb != NULL) && os::is_readable_pointer(cb)) {\n+  if (cb != NULL) {\n@@ -2503,3 +2525,3 @@\n-    \/\/---<  access these fields only if we own the CodeCache_lock  >---\n-    \/\/ Should be ensured by caller. aggregate() amd print_names() do that.\n-    if (CodeCache_lock->owned_by_self()) {\n+    \/\/---<  access these fields only if we own CodeCache_lock and Compile_lock  >---\n+    \/\/ Should be ensured by caller. aggregate() and print_names() do that.\n+    if (holding_required_locks()) {\n@@ -2508,1 +2530,0 @@\n-        if (nm->is_not_installed()) return nMethod_inconstruction;\n@@ -2521,1 +2542,2 @@\n-bool CodeHeapState::blob_access_is_safe(CodeBlob* this_blob, CodeBlob* prev_blob) {\n+\/\/ make sure the blob at hand is not garbage.\n+bool CodeHeapState::blob_access_is_safe(CodeBlob* this_blob) {\n@@ -2523,1 +2545,0 @@\n-         ((this_blob == prev_blob) || (prev_blob == NULL)) &&  \/\/ when re-checking, the same blob must have been found\n@@ -2527,3 +2548,12 @@\n-         ((address)this_blob + CodeBlob::align_code_offset(this_blob->header_size() + this_blob->relocation_size()) == (address)(this_blob->content_begin())) &&\n-         os::is_readable_pointer((address)(this_blob->relocation_begin())) &&\n-         os::is_readable_pointer(this_blob->content_begin());\n+         ((address)this_blob + CodeBlob::align_code_offset(this_blob->header_size() + this_blob->relocation_size()) == (address)(this_blob->content_begin()));\n+}\n+\n+\/\/ make sure the nmethod at hand (and the linked method) is not garbage.\n+bool CodeHeapState::nmethod_access_is_safe(nmethod* nm) {\n+  Method* method = (nm == NULL) ? NULL : nm->method(); \/\/ nm->method() was found to be uninitialized, i.e. != NULL, but invalid.\n+  return (nm != NULL) && (method != NULL) && nm->is_alive() && (method->signature() != NULL);\n+}\n+\n+bool CodeHeapState::holding_required_locks() {\n+  return SafepointSynchronize::is_at_safepoint() ||\n+        (CodeCache_lock->owned_by_self() && Compile_lock->owned_by_self());\n","filename":"src\/hotspot\/share\/code\/codeHeapState.cpp","additions":137,"deletions":107,"binary":false,"changes":244,"status":"modified"},{"patch":"@@ -50,0 +50,2 @@\n+                            \/\/ can't be observed while holding Compile_lock and CodeCache_lock simultaneously.\n+                            \/\/ left in here for completeness (and to document we spent a thought).\n@@ -98,1 +100,3 @@\n-  static bool blob_access_is_safe(CodeBlob* this_blob, CodeBlob* prev_blob);\n+  static bool blob_access_is_safe(CodeBlob* this_blob);\n+  static bool nmethod_access_is_safe(nmethod* nm);\n+  static bool holding_required_locks();\n@@ -167,1 +171,2 @@\n-  HeapBlock*     start;       \/\/ address of block\n+  HeapBlock*     start;        \/\/ address of block\n+  const char*    blob_name;    \/\/ name of blob (mostly: name_and_sig of nmethod)\n@@ -173,0 +178,3 @@\n+\n+  unsigned int   nm_size;      \/\/ nmeethod total size (if nmethod, 0 otherwise)\n+  int            temperature;  \/\/ nmethod temperature (if nmethod, 0 otherwise)\n@@ -219,1 +227,0 @@\n-    unsigned int  nBlocks_inconstr;\n","filename":"src\/hotspot\/share\/code\/codeHeapState.hpp","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -72,0 +72,7 @@\n+  { \/\/ avoid uninitialized fields, even for short time periods\n+    _is_far_code                = false;\n+    _scopes_data_begin          = NULL;\n+    _deopt_handler_begin        = NULL;\n+    _deopt_mh_handler_begin     = NULL;\n+    _exception_cache            = NULL;\n+  }\n@@ -695,15 +702,0 @@\n-\/\/ Iterating over all nmethods, e.g. with the help of CodeCache::nmethods_do(fun) was found\n-\/\/ to not be inherently safe. There is a chance that fields are seen which are not properly\n-\/\/ initialized. This happens despite the fact that nmethods_do() asserts the CodeCache_lock\n-\/\/ to be held.\n-\/\/ To bundle knowledge about necessary checks in one place, this function was introduced.\n-\/\/ It is not claimed that these checks are sufficient, but they were found to be necessary.\n-bool CompiledMethod::nmethod_access_is_safe(nmethod* nm) {\n-  Method* method = (nm == NULL) ? NULL : nm->method();  \/\/ nm->method() may be uninitialized, i.e. != NULL, but invalid\n-  return (nm != NULL) && (method != NULL) && (method->signature() != NULL) &&\n-         !nm->is_zombie() && !nm->is_not_installed() &&\n-         os::is_readable_pointer(method) &&\n-         os::is_readable_pointer(method->constants()) &&\n-         os::is_readable_pointer(method->signature());\n-}\n-\n","filename":"src\/hotspot\/share\/code\/compiledMethod.cpp","additions":7,"deletions":15,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -257,2 +257,0 @@\n-  static bool nmethod_access_is_safe(nmethod* nm);\n-\n","filename":"src\/hotspot\/share\/code\/compiledMethod.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2767,1 +2767,1 @@\n-  \/\/ That prevents another thread from destroying our view on the CodeHeap.\n+  \/\/ That prevents other threads from destroying (making inconsistent) our view on the CodeHeap.\n@@ -2770,5 +2770,7 @@\n-  \/\/ updated the aggregated data. That's a tolerable tradeoff because we can't hold a lock\n-  \/\/ across user interaction.\n-  \/\/ Acquire this lock before acquiring the CodeCache_lock.\n-  \/\/ CodeHeapStateAnalytics_lock could be held by a concurrent thread for a long time,\n-  \/\/ leading to an unnecessarily long hold time of the CodeCache_lock.\n+  \/\/ updated the aggregated data. We will then see a modified, but again consistent, view\n+  \/\/ on the CodeHeap. That's a tolerable tradeoff we have to accept because we can't hold\n+  \/\/ a lock across user interaction.\n+\n+  \/\/ We should definitely acquire this lock before acquiring Compile_lock and CodeCache_lock.\n+  \/\/ CodeHeapStateAnalytics_lock may be held by a concurrent thread for a long time,\n+  \/\/ leading to an unnecessarily long hold time of the other locks we acquired before.\n@@ -2776,1 +2778,1 @@\n-  MutexLocker mu1(CodeHeapStateAnalytics_lock, Mutex::_no_safepoint_check_flag);\n+  MutexLocker mu0(CodeHeapStateAnalytics_lock, Mutex::_safepoint_check_flag);\n@@ -2779,6 +2781,19 @@\n-  \/\/ If we serve an \"allFun\" call, it is beneficial to hold the CodeCache_lock\n-  \/\/ for the entire duration of aggregation and printing. That makes sure\n-  \/\/ we see a consistent picture and do not run into issues caused by\n-  \/\/ the CodeHeap being altered concurrently.\n-  Mutex* global_lock   = allFun ? CodeCache_lock : NULL;\n-  Mutex* function_lock = allFun ? NULL : CodeCache_lock;\n+  \/\/ Holding the CodeCache_lock protects from concurrent alterations of the CodeCache.\n+  \/\/ Unfortunately, such protection is not sufficient:\n+  \/\/ When a new nmethod is created via ciEnv::register_method(), the\n+  \/\/ Compile_lock is taken first. After some initializations,\n+  \/\/ nmethod::new_nmethod() takes over, grabbing the CodeCache_lock\n+  \/\/ immediately (after finalizing the oop references). To lock out concurrent\n+  \/\/ modifiers, we have to grab both locks as well in the described sequence.\n+  \/\/\n+  \/\/ If we serve an \"allFun\" call, it is beneficial to hold CodeCache_lock and Compile_lock\n+  \/\/ for the entire duration of aggregation and printing. That makes sure we see\n+  \/\/ a consistent picture and do not run into issues caused by concurrent alterations.\n+  bool should_take_Compile_lock   = !SafepointSynchronize::is_at_safepoint() &&\n+                                    !Compile_lock->owned_by_self();\n+  bool should_take_CodeCache_lock = !SafepointSynchronize::is_at_safepoint() &&\n+                                    !CodeCache_lock->owned_by_self();\n+  Mutex*   global_lock_1   = allFun ? (should_take_Compile_lock   ? Compile_lock   : NULL) : NULL;\n+  Monitor* global_lock_2   = allFun ? (should_take_CodeCache_lock ? CodeCache_lock : NULL) : NULL;\n+  Mutex*   function_lock_1 = allFun ? NULL : (should_take_Compile_lock   ? Compile_lock    : NULL);\n+  Monitor* function_lock_2 = allFun ? NULL : (should_take_CodeCache_lock ? CodeCache_lock  : NULL);\n@@ -2786,3 +2801,4 @@\n-  MutexLocker mu2(global_lock, Mutex::_no_safepoint_check_flag);\n-  if (global_lock != NULL) {\n-    out->print_cr(\"\\n__ CodeCache (global) lock wait took %10.3f seconds _________\\n\", ts_global.seconds());\n+  MutexLocker mu1(global_lock_1, Mutex::_safepoint_check_flag);\n+  MutexLocker mu2(global_lock_2, Mutex::_no_safepoint_check_flag);\n+  if ((global_lock_1 != NULL) || (global_lock_2 != NULL)) {\n+    out->print_cr(\"\\n__ Compile & CodeCache (global) lock wait took %10.3f seconds _________\\n\", ts_global.seconds());\n@@ -2794,3 +2810,4 @@\n-    MutexLocker mu3(function_lock, Mutex::_no_safepoint_check_flag);\n-    if (function_lock != NULL) {\n-      out->print_cr(\"\\n__ CodeCache (function) lock wait took %10.3f seconds _________\\n\", ts.seconds());\n+    MutexLocker mu11(function_lock_1, Mutex::_safepoint_check_flag);\n+    MutexLocker mu22(function_lock_2, Mutex::_no_safepoint_check_flag);\n+    if ((function_lock_1 != NULL) || (function_lock_1 != NULL)) {\n+      out->print_cr(\"\\n__ Compile & CodeCache (function) lock wait took %10.3f seconds _________\\n\", ts.seconds());\n@@ -2801,2 +2818,2 @@\n-    if (function_lock != NULL) {\n-      out->print_cr(\"\\n__ CodeCache (function) lock hold took %10.3f seconds _________\\n\", ts.seconds());\n+    if ((function_lock_1 != NULL) || (function_lock_1 != NULL)) {\n+      out->print_cr(\"\\n__ Compile & CodeCache (function) lock hold took %10.3f seconds _________\\n\", ts.seconds());\n@@ -2812,4 +2829,7 @@\n-    \/\/ print_names() has shown to be sensitive to concurrent CodeHeap modifications.\n-    \/\/ Therefore, request  the CodeCache_lock before calling...\n-    MutexLocker mu3(function_lock, Mutex::_no_safepoint_check_flag);\n-    CodeCache::print_names(out);\n+    if (allFun) {\n+      \/\/ print_names() can only be used safely if the locks have been continuously held\n+      \/\/ since aggregation begin. That is true only for function \"all\".\n+      CodeCache::print_names(out);\n+    } else {\n+      out->print_cr(\"\\nCodeHeapStateAnalytics: Function 'MethodNames' is only available as part of function 'all'\");\n+    }\n@@ -2819,2 +2839,2 @@\n-  if (global_lock != NULL) {\n-    out->print_cr(\"\\n__ CodeCache (global) lock hold took %10.3f seconds _________\\n\", ts_global.seconds());\n+  if ((global_lock_1 != NULL) || (global_lock_2 != NULL)) {\n+    out->print_cr(\"\\n__ Compile & CodeCache (global) lock hold took %10.3f seconds _________\\n\", ts_global.seconds());\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":47,"deletions":27,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -208,0 +208,1 @@\n+  assert_locked_or_safepoint(CodeCache_lock);\n@@ -256,0 +257,2 @@\n+  assert_locked_or_safepoint(CodeCache_lock);\n+\n@@ -286,0 +289,1 @@\n+  assert_locked_or_safepoint(CodeCache_lock);\n@@ -350,0 +354,2 @@\n+  assert_locked_or_safepoint(CodeCache_lock);\n+\n@@ -366,0 +372,2 @@\n+  assert_locked_or_safepoint(CodeCache_lock);\n+\n@@ -793,0 +801,1 @@\n+    assert_locked_or_safepoint(CodeCache_lock);\n","filename":"src\/hotspot\/share\/memory\/heap.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -335,1 +335,1 @@\n-  def(CodeHeapStateAnalytics_lock  , PaddedMutex  , leaf,        true,  _safepoint_check_never);\n+  def(CodeHeapStateAnalytics_lock  , PaddedMutex  , nonleaf+6,   false, _safepoint_check_always);\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}