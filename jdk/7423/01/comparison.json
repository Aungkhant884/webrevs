{"files":[{"patch":"@@ -37,0 +37,1 @@\n+#include \"classfile\/javaClasses.hpp\"\n@@ -919,5 +920,1 @@\n-  if (con.basic_type() == T_ILLEGAL) {\n-    \/\/ FIXME: an unresolved Dynamic constant can get here,\n-    \/\/ and that should not terminate the whole compilation.\n-    BAILOUT(\"could not resolve a constant\");\n-  } else {\n+  if (con.is_valid()) {\n@@ -927,11 +924,10 @@\n-      case T_BOOLEAN: t = new IntConstant     (con.as_boolean()); break;\n-      case T_BYTE   : t = new IntConstant     (con.as_byte   ()); break;\n-      case T_CHAR   : t = new IntConstant     (con.as_char   ()); break;\n-      case T_SHORT  : t = new IntConstant     (con.as_short  ()); break;\n-      case T_INT    : t = new IntConstant     (con.as_int    ()); break;\n-      case T_LONG   : t = new LongConstant    (con.as_long   ()); break;\n-      case T_FLOAT  : t = new FloatConstant   (con.as_float  ()); break;\n-      case T_DOUBLE : t = new DoubleConstant  (con.as_double ()); break;\n-      case T_ARRAY  : t = new ArrayConstant   (con.as_object ()->as_array   ()); break;\n-      case T_OBJECT :\n-       {\n+      case T_BOOLEAN: t = new IntConstant   (con.as_boolean()); break;\n+      case T_BYTE   : t = new IntConstant   (con.as_byte   ()); break;\n+      case T_CHAR   : t = new IntConstant   (con.as_char   ()); break;\n+      case T_SHORT  : t = new IntConstant   (con.as_short  ()); break;\n+      case T_INT    : t = new IntConstant   (con.as_int    ()); break;\n+      case T_LONG   : t = new LongConstant  (con.as_long   ()); break;\n+      case T_FLOAT  : t = new FloatConstant (con.as_float  ()); break;\n+      case T_DOUBLE : t = new DoubleConstant(con.as_double ()); break;\n+      case T_ARRAY  : \/\/ fall-through\n+      case T_OBJECT : {\n@@ -939,4 +935,2 @@\n-        if (!obj->is_loaded()\n-            || (PatchALot && obj->klass() != ciEnv::current()->String_klass())) {\n-          \/\/ A Class, MethodType, MethodHandle, or String.\n-          \/\/ Unloaded condy nodes show up as T_ILLEGAL, above.\n+        if (!obj->is_loaded() || (PatchALot && (obj->is_null_object() || obj->klass() != ciEnv::current()->String_klass()))) {\n+          \/\/ A Class, MethodType, MethodHandle, Dynamic, or String.\n@@ -948,1 +942,1 @@\n-          if (obj->is_null_object())\n+          if (obj->is_null_object()) {\n@@ -950,1 +944,1 @@\n-          else if (obj->is_array())\n+          } else if (obj->is_array()) {\n@@ -952,1 +946,1 @@\n-          else\n+          } else {\n@@ -954,0 +948,1 @@\n+          }\n@@ -956,2 +951,2 @@\n-       }\n-      default       : ShouldNotReachHere();\n+      }\n+      default: ShouldNotReachHere();\n@@ -965,0 +960,18 @@\n+\n+    \/\/ Unbox the value at runtime, if needed.\n+    \/\/ ConstantDynamic entry can be of a primitive type, but it is cached in boxed form.\n+    if (patch_state != NULL) {\n+      int index = stream()->get_constant_pool_index();\n+      BasicType type = stream()->get_basic_type_for_constant_at(index);\n+      if (is_java_primitive(type)) {\n+        ciInstanceKlass* box_klass = ciEnv::current()->get_box_klass_for_primitive_type(type);\n+        assert(box_klass->is_loaded(), \"sanity\");\n+        int offset = java_lang_boxing_object::value_offset(type);\n+        ciField* value_field = box_klass->get_field_by_offset(offset, false \/*is_static*\/);\n+        x = new LoadField(append(x), offset, value_field, false \/*is_static*\/, patch_state, false \/*needs_patching*\/);\n+        t = as_ValueType(type);\n+      } else {\n+        assert(is_reference_type(type), \"not a reference: %s\", type2name(type));\n+      }\n+    }\n+\n@@ -966,0 +979,2 @@\n+  } else {\n+    BAILOUT(\"could not resolve a constant\");\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":40,"deletions":25,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -265,1 +265,1 @@\n-  output()->print(\"%s\", name);\n+  output()->print(\"%s(\", name);\n","filename":"src\/hotspot\/share\/c1\/c1_InstructionPrinter.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -79,0 +79,1 @@\n+      case Bytecodes::_ldc2_w:\n","filename":"src\/hotspot\/share\/c1\/c1_LIRAssembler.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1012,0 +1012,1 @@\n+      case Bytecodes::_ldc2_w:\n@@ -1156,1 +1157,0 @@\n-              assert(mirror() != NULL, \"klass not set\");\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -395,0 +395,17 @@\n+ciInstanceKlass* ciEnv::get_box_klass_for_primitive_type(BasicType type) {\n+  switch (type) {\n+    case T_BOOLEAN: return Boolean_klass();\n+    case T_BYTE   : return Byte_klass();\n+    case T_CHAR   : return Character_klass();\n+    case T_SHORT  : return Short_klass();\n+    case T_INT    : return Integer_klass();\n+    case T_LONG   : return Long_klass();\n+    case T_FLOAT  : return Float_klass();\n+    case T_DOUBLE : return Double_klass();\n+\n+    default:\n+      assert(false, \"not a primitive: %s\", type2name(type));\n+      return NULL;\n+  }\n+}\n+\n@@ -653,0 +670,57 @@\n+\/\/ ------------------------------------------------------------------\n+\/\/ ciEnv::unbox_primitive_value\n+\/\/\n+\/\/ Unbox a primitive and return it as a ciConstant.\n+ciConstant ciEnv::unbox_primitive_value(ciObject* cibox, BasicType expected_bt) {\n+  jvalue value;\n+  BasicType bt = java_lang_boxing_object::get_value(cibox->get_oop(), &value);\n+  if (bt != expected_bt && expected_bt != T_ILLEGAL) {\n+    assert(false, \"type mismatch: %s vs %s\", type2name(expected_bt), cibox->klass()->name()->as_klass_external_name());\n+    return ciConstant();\n+  }\n+  switch (bt) {\n+    case T_BOOLEAN: return ciConstant(bt, value.z);\n+    case T_BYTE:    return ciConstant(bt, value.b);\n+    case T_SHORT:   return ciConstant(bt, value.s);\n+    case T_CHAR:    return ciConstant(bt, value.c);\n+    case T_INT:     return ciConstant(bt, value.i);\n+    case T_LONG:    return ciConstant(value.j);\n+    case T_FLOAT:   return ciConstant(value.f);\n+    case T_DOUBLE:  return ciConstant(value.d);\n+\n+    default:\n+      assert(false, \"not a primitive type: %s\", type2name(bt));\n+      return ciConstant();\n+  }\n+}\n+\n+\/\/ ------------------------------------------------------------------\n+\/\/ ciEnv::get_resolved_constant\n+\/\/\n+ciConstant ciEnv::get_resolved_constant(const constantPoolHandle& cpool, int obj_index) {\n+  assert(obj_index >= 0, \"\");\n+  oop obj = cpool->resolved_references()->obj_at(obj_index);\n+  if (obj == NULL) {\n+    \/\/ Unresolved constant. It is resolved when the corresponding slot contains a non-null reference.\n+    \/\/ Null constant is represented as a sentinel (non-null) value.\n+    return ciConstant();\n+  } else if (obj == Universe::the_null_sentinel()) {\n+    return ciConstant(T_OBJECT, get_object(NULL));\n+  } else {\n+    ciObject* ciobj = get_object(obj);\n+    if (ciobj->is_array()) {\n+      return ciConstant(T_ARRAY, ciobj);\n+    } else {\n+      int cp_index = cpool->object_to_cp_index(obj_index);\n+      BasicType bt = cpool->basic_type_for_constant_at(cp_index);\n+      if (is_java_primitive(bt)) {\n+        assert(cpool->tag_at(cp_index).is_dynamic_constant(), \"sanity\");\n+        return unbox_primitive_value(ciobj, bt);\n+      } else {\n+        assert(ciobj->is_instance(), \"should be an instance\");\n+        return ciConstant(T_OBJECT, ciobj);\n+      }\n+    }\n+  }\n+}\n+\n@@ -658,1 +732,1 @@\n-                                             int pool_index, int cache_index,\n+                                             int index, int obj_index,\n@@ -661,40 +735,4 @@\n-  int index = pool_index;\n-  if (cache_index >= 0) {\n-    assert(index < 0, \"only one kind of index at a time\");\n-    index = cpool->object_to_cp_index(cache_index);\n-    oop obj = cpool->resolved_references()->obj_at(cache_index);\n-    if (obj != NULL) {\n-      if (obj == Universe::the_null_sentinel()) {\n-        return ciConstant(T_OBJECT, get_object(NULL));\n-      }\n-      BasicType bt = T_OBJECT;\n-      if (cpool->tag_at(index).is_dynamic_constant()) {\n-        bt = Signature::basic_type(cpool->uncached_signature_ref_at(index));\n-      }\n-      if (!is_reference_type(bt)) {\n-        \/\/ we have to unbox the primitive value\n-        if (!is_java_primitive(bt)) {\n-          return ciConstant();\n-        }\n-        jvalue value;\n-        BasicType bt2 = java_lang_boxing_object::get_value(obj, &value);\n-        assert(bt2 == bt, \"\");\n-        switch (bt2) {\n-        case T_DOUBLE:  return ciConstant(value.d);\n-        case T_FLOAT:   return ciConstant(value.f);\n-        case T_LONG:    return ciConstant(value.j);\n-        case T_INT:     return ciConstant(bt2, value.i);\n-        case T_SHORT:   return ciConstant(bt2, value.s);\n-        case T_BYTE:    return ciConstant(bt2, value.b);\n-        case T_CHAR:    return ciConstant(bt2, value.c);\n-        case T_BOOLEAN: return ciConstant(bt2, value.z);\n-        default:  return ciConstant();\n-        }\n-      }\n-      ciObject* ciobj = get_object(obj);\n-      if (ciobj->is_array()) {\n-        return ciConstant(T_ARRAY, ciobj);\n-      } else {\n-        assert(ciobj->is_instance(), \"should be an instance\");\n-        return ciConstant(T_OBJECT, ciobj);\n-      }\n+  if (obj_index >= 0) {\n+    ciConstant con = get_resolved_constant(cpool, obj_index);\n+    if (con.is_valid()) {\n+      return con;\n@@ -714,3 +752,2 @@\n-    oop string = NULL;\n-    assert(cache_index >= 0, \"should have a cache index\");\n-    string = cpool->string_at(index, cache_index, THREAD);\n+    assert(obj_index >= 0, \"should have an object index\");\n+    oop string = cpool->string_at(index, obj_index, THREAD);\n@@ -722,7 +759,2 @@\n-    ciObject* constant = get_object(string);\n-    if (constant->is_array()) {\n-      return ciConstant(T_ARRAY, constant);\n-    } else {\n-      assert (constant->is_instance(), \"must be an instance, or not? \");\n-      return ciConstant(T_OBJECT, constant);\n-    }\n+    ciInstance* constant = get_object(string)->as_instance();\n+    return ciConstant(T_OBJECT, constant);\n@@ -733,2 +765,0 @@\n-    assert (klass->is_instance_klass() || klass->is_array_klass(),\n-            \"must be an instance or array klass \");\n@@ -738,0 +768,1 @@\n+    assert(obj_index >= 0, \"should have an object index\");\n@@ -743,0 +774,1 @@\n+    assert(obj_index >= 0, \"should have an object index\");\n@@ -751,1 +783,2 @@\n-    return ciConstant(); \/\/ not supported\n+    assert(obj_index >= 0, \"should have an object index\");\n+    return ciConstant(T_OBJECT, unloaded_ciinstance()); \/\/ unresolved dynamic constant\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":87,"deletions":54,"binary":false,"changes":141,"status":"modified"},{"patch":"@@ -168,0 +168,3 @@\n+  ciConstant unbox_primitive_value(ciObject* cibox, BasicType expected_bt = T_ILLEGAL);\n+  ciConstant get_resolved_constant(const constantPoolHandle& cpool, int obj_index);\n+\n@@ -432,0 +435,2 @@\n+  ciInstanceKlass* get_box_klass_for_primitive_type(BasicType type);\n+\n","filename":"src\/hotspot\/share\/ci\/ciEnv.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -558,1 +558,1 @@\n-ciInstance* ciObjectFactory::get_unloaded_klass_mirror(ciKlass*  type) {\n+ciInstance* ciObjectFactory::get_unloaded_klass_mirror(ciKlass* type) {\n@@ -573,1 +573,1 @@\n-  if (ciEnv::_MethodHandle_klass == NULL)  return NULL;\n+  assert(ciEnv::_MethodHandle_klass != NULL, \"\");\n@@ -584,1 +584,1 @@\n-  if (ciEnv::_MethodType_klass == NULL)  return NULL;\n+  assert(ciEnv::_MethodType_klass != NULL, \"\");\n@@ -589,1 +589,1 @@\n-  if (ciEnv::_Object_klass == NULL)  return NULL;\n+  assert(ciEnv::_Object_klass != NULL, \"\");\n","filename":"src\/hotspot\/share\/ci\/ciObjectFactory.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -233,0 +233,2 @@\n+  VM_ENTRY_MARK;\n+  constantPoolHandle cpool(THREAD, _method->get_Method()->constants());\n@@ -237,1 +239,6 @@\n-    pool_index = -1;\n+    pool_index = cpool->object_to_cp_index(cache_index);\n+  } else if (cpool->tag_at(pool_index).is_dynamic_constant() ||\n+             cpool->tag_at(pool_index).is_dynamic_constant_in_error()) {\n+    \/\/ Condy with primitive type is not quickened, so the index into resolved reference cache should be reconstructed.\n+    assert(is_java_primitive(cpool->basic_type_for_constant_at(pool_index)), \"not quickened\");\n+    cache_index = cpool->cp_to_object_index(pool_index);\n@@ -239,2 +246,0 @@\n-  VM_ENTRY_MARK;\n-  constantPoolHandle cpool(THREAD, _method->get_Method()->constants());\n","filename":"src\/hotspot\/share\/ci\/ciStreams.cpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -730,1 +730,2 @@\n-    BasicType basic_type = con.basic_type();\n+    int index = str->get_constant_pool_index();\n+    BasicType basic_type = str->get_basic_type_for_constant_at(index);\n@@ -740,0 +741,2 @@\n+      assert(basic_type == con.basic_type() || con.basic_type() == T_OBJECT,\n+             \"not a boxed form: %s vs %s\", type2name(basic_type), type2name(con.basic_type()));\n@@ -743,2 +746,1 @@\n-    \/\/ OutOfMemoryError in the CI while loading constant.\n-    \/\/ Unresolved condy also lands here (not yet supported).\n+    \/\/ OutOfMemoryError in the CI while loading a String constant.\n","filename":"src\/hotspot\/share\/ci\/ciTypeFlow.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1874,2 +1874,0 @@\n-      assert(constant.basic_type() != T_OBJECT || constant.as_object()->is_instance(),\n-             \"must be java_mirror of klass\");\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,254 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8280473\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.org.objectweb.asm\n+ *\n+ * @run main\/othervm -XX:+TieredCompilation -XX:TieredStopAtLevel=1\n+ *                   -Xbatch -XX:CompileThreshold=100 -XX:CompileCommand=compileonly,*::test\n+ *                   -XX:CompileCommand=quiet -XX:+PrintCompilation\n+ *                     compiler.runtime.TestConstantDynamic\n+ * @run main\/othervm -XX:-TieredCompilation\n+ *                   -Xbatch -XX:CompileThreshold=100 -XX:CompileCommand=compileonly,*::test\n+ *                   -XX:CompileCommand=quiet -XX:+PrintCompilation\n+ *                     compiler.runtime.TestConstantDynamic\n+ *\/\n+\n+package compiler.runtime;\n+\n+import jdk.internal.org.objectweb.asm.*;\n+\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.lang.constant.ConstantDescs;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandleProxies;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.Method;\n+\n+import static jdk.internal.org.objectweb.asm.ClassWriter.*;\n+import static jdk.internal.org.objectweb.asm.Opcodes.*;\n+\n+public class TestConstantDynamic {\n+    static final Class<TestConstantDynamic> THIS_CLASS = TestConstantDynamic.class;\n+\n+    static final String THIS_CLASS_NAME = THIS_CLASS.getName().replace('.', '\/');\n+    static final String CLASS_NAME = THIS_CLASS_NAME + \"$Test\";\n+\n+    public interface Test {\n+        Object run(boolean b);\n+    }\n+\n+    public static final String PATH = System.getProperty(\"test.classes\", \".\") + java.io.File.separator;\n+    private static int ID = 0;\n+\n+    \/* =================================================================================================== *\/\n+\n+    static final String BSM_DESC = \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/Class;)Ljava\/lang\/Object;\";\n+    static final Handle BSM = new Handle(H_INVOKESTATIC, THIS_CLASS_NAME, \"bsm\", BSM_DESC, false);\n+\n+    static Object bsm(MethodHandles.Lookup lookup, String name, Class c) throws IllegalAccessException {\n+        Object[] classData = MethodHandles.classData(lookup, ConstantDescs.DEFAULT_NAME, Object[].class);\n+        Object value = classData[0];\n+        System.out.printf(\"BSM: lookup=%s name=\\\"%s\\\" class=%s => \\\"%s\\\"\\n\", lookup, name, c, classData[0]);\n+        return value;\n+    }\n+\n+    static final Handle THROWING_BSM = new Handle(H_INVOKESTATIC, THIS_CLASS_NAME, \"throwingBSM\", BSM_DESC, false);\n+\n+    static Object throwingBSM(MethodHandles.Lookup lookup, String name, Class c) throws IllegalAccessException {\n+        Object[] classData = (Object[])MethodHandles.classData(lookup, ConstantDescs.DEFAULT_NAME, Object[].class);\n+        Object value = classData[0];\n+        System.out.printf(\"BSM: lookup=%s name=\\\"%s\\\" class=%s value=\\\"%s\\\" => Exception\\n\", lookup, name, c, value);\n+        throw new IllegalArgumentException(lookup.lookupClass().getName() + \": \" + c.getName() + \" \" + name + \" \" + value);\n+    }\n+\n+    \/* =================================================================================================== *\/\n+\n+    static byte[] generateClassFile(String suffix, String desc, int retOpcode, Handle bsm) throws IOException {\n+        var cw = new ClassWriter(COMPUTE_MAXS | COMPUTE_FRAMES);\n+        String name = CLASS_NAME + \"_\" + suffix + \"_\" + (++ID);\n+        cw.visit(V19, ACC_PUBLIC | ACC_SUPER, name, null, \"java\/lang\/Object\", null);\n+\n+        Handle localBSM = new Handle(H_INVOKESTATIC, name, \"bsm\", BSM_DESC, false);\n+\n+        {\n+            var mv = cw.visitMethod(ACC_PUBLIC | ACC_STATIC, \"bsm\", BSM_DESC, null, null);\n+\n+            mv.visitLdcInsn(bsm);\n+            mv.visitIntInsn(ALOAD, 0);\n+            mv.visitIntInsn(ALOAD, 1);\n+            mv.visitIntInsn(ALOAD, 2);\n+            mv.visitMethodInsn(INVOKEVIRTUAL, \"java\/lang\/invoke\/MethodHandle\", \"invokeExact\", BSM_DESC, false);\n+            mv.visitInsn(ARETURN);\n+            mv.visitMaxs(0, 0);\n+        }\n+\n+        {\n+            var mv = cw.visitMethod(ACC_PUBLIC | ACC_STATIC, \"test\", \"(Z)\" + desc, null, null);\n+            mv.visitCode();\n+\n+            Label endL = new Label();\n+            Label falseL = new Label();\n+\n+            mv.visitIntInsn(ILOAD, 0);\n+            mv.visitJumpInsn(Opcodes.IFNE, falseL);\n+\n+            mv.visitLdcInsn(new ConstantDynamic(\"first\", desc, localBSM)); \/\/ is resolved on b = false\n+\n+            mv.visitJumpInsn(GOTO, endL);\n+\n+            mv.visitLabel(falseL);\n+\n+            mv.visitLdcInsn(new ConstantDynamic(\"second\", desc, localBSM)); \/\/ is resolved on b = true\n+\n+            mv.visitLabel(endL);\n+            mv.visitInsn(retOpcode);\n+            mv.visitMaxs(0, 0);\n+        }\n+        byte[] classFile = cw.toByteArray();\n+\n+        try (FileOutputStream fos = new FileOutputStream(PATH + name + \".class\")) {\n+            fos.write(classFile);\n+        }\n+\n+        return classFile;\n+    }\n+\n+    static Test generate(String desc, int retOpcode, Object value, Handle bsm, boolean shouldThrow) {\n+        try {\n+            byte[] classFile = generateClassFile(\"CD\", desc, retOpcode, bsm);\n+            Object[] classData = new Object[] { value };\n+            MethodHandles.Lookup testLookup = MethodHandles.lookup().defineHiddenClassWithClassData(classFile, classData, true);\n+            Method testMethod = testLookup.lookupClass().getDeclaredMethod(\"test\", boolean.class);\n+            MethodHandle testMH = testLookup.unreflect(testMethod);\n+\n+            if (shouldThrow) {\n+                \/\/ Install empty handler for linkage errors, but throw an error on successful invocation.\n+                \/\/ try { Test.test(b); throw AssertionError(); } catch (LinkageError e) { \/* expected *\/ }\n+                testMH = MethodHandles.filterReturnValue(testMH,\n+                        MethodHandles.dropArguments(\n+                            MethodHandles.insertArguments(\n+                                    MethodHandles.throwException(testMH.type().returnType(), AssertionError.class),\n+                                    0, new AssertionError(\"no exception thrown\")),\n+                            0, testMH.type().returnType()));\n+\n+                testMH = MethodHandles.catchException(testMH, LinkageError.class,\n+                        MethodHandles.empty(MethodType.methodType(testMH.type().returnType(), LinkageError.class)));\n+            } else {\n+                Class<?> type = testMH.type().returnType();\n+                testMH = MethodHandles.filterReturnValue(testMH,\n+                                MethodHandles.insertArguments(VALIDATE_MH, 0, value)\n+                                        .asType(MethodType.methodType(type, type)));\n+            }\n+\n+            return MethodHandleProxies.asInterfaceInstance(Test.class, testMH);\n+        } catch (Throwable e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+\n+    static final MethodHandle VALIDATE_MH;\n+    static {\n+        try {\n+            VALIDATE_MH = MethodHandles.lookup().findStatic(THIS_CLASS, \"validateResult\",\n+                                                            MethodType.methodType(Object.class, Object.class, Object.class));\n+        } catch (ReflectiveOperationException e) {\n+            throw new InternalError(e);\n+        }\n+    }\n+    static Object validateResult(Object expected, Object actual) {\n+        if ((expected == null && actual != null) ||\n+            (expected != null && !expected.equals(actual))) {\n+            throw new AssertionError(String.format(\"expected=%s != actual=%s\", expected.toString(), actual.toString()));\n+        }\n+        return actual;\n+    }\n+\n+    private Handle bsm;\n+    private boolean shouldThrow;\n+\n+    TestConstantDynamic(Handle bsm, boolean shouldThrow) {\n+        this.bsm = bsm;\n+        this.shouldThrow = shouldThrow;\n+    }\n+\n+    static TestConstantDynamic shouldNotThrow() {\n+        return new TestConstantDynamic(BSM, false);\n+    }\n+\n+    static TestConstantDynamic shouldThrow() {\n+        return new TestConstantDynamic(THROWING_BSM, true);\n+    }\n+\n+    static void shouldThrow(Handle bsm, String desc, int retOpcode, Object value) {\n+        (new TestConstantDynamic(bsm, true)).test(desc, retOpcode, value);\n+    }\n+\n+    void test(String desc, int retOpcode, Object value) {\n+        Test test = generate(desc, retOpcode, value, bsm, shouldThrow);\n+\n+        for (int i = 0; i < 200; i++) {\n+            test.run(false);\n+        }\n+        for (int i = 0; i < 200; i++) {\n+            test.run(true);\n+        }\n+    }\n+\n+    static void run(TestConstantDynamic t) {\n+        t.test(\"Z\", IRETURN, Boolean.TRUE);\n+        t.test(\"B\", IRETURN, Byte.MAX_VALUE);\n+        t.test(\"S\", IRETURN, Short.MAX_VALUE);\n+        t.test(\"C\", IRETURN, Character.MAX_VALUE);\n+        t.test(\"I\", IRETURN, Integer.MAX_VALUE);\n+        t.test(\"J\", LRETURN, Long.MAX_VALUE);\n+        t.test(\"F\", FRETURN, Float.MAX_VALUE);\n+        t.test(\"D\", DRETURN, Double.MAX_VALUE);\n+\n+        t.test(\"Ljava\/lang\/Object;\", ARETURN, new Object());\n+        t.test(\"Ljava\/lang\/Object;\", ARETURN, null);\n+\n+        t.test(\"[Ljava\/lang\/Object;\", ARETURN, new Object[0]);\n+        t.test(\"[Ljava\/lang\/Object;\", ARETURN, null);\n+\n+        t.test(\"[I\", ARETURN, new int[0]);\n+        t.test(\"[I\", ARETURN, null);\n+\n+        t.test(\"Ljava\/lang\/Runnable;\", ARETURN, (Runnable)(() -> {}));\n+        t.test(\"Ljava\/lang\/Runnable;\", ARETURN, null);\n+    }\n+\n+    public static void main(String[] args) {\n+        run(shouldNotThrow());\n+\n+        run(shouldThrow()); \/\/ use error-throwing BSM\n+\n+        shouldThrow(BSM, \"Ljava\/lang\/Runnable;\", ARETURN, new Object()); \/\/ not a Runnable\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/runtime\/TestConstantDynamic.java","additions":254,"deletions":0,"binary":false,"changes":254,"status":"added"},{"patch":"@@ -233,5 +233,10 @@\n-            if (isC1) {\n-                results.shouldMatch(\"Test_CD1.*::test \\\\(3 bytes\\\\)   COMPILE SKIPPED: could not resolve a constant\")\n-                       .shouldMatch(\"Test_CD2.*::test \\\\(3 bytes\\\\)   COMPILE SKIPPED: could not resolve a constant\")\n-                       .shouldMatch(\"Test_CD3.*::test \\\\(3 bytes\\\\)   COMPILE SKIPPED: could not resolve a constant\")\n-                       .shouldMatch(\"Test_CD4.*::test \\\\(3 bytes\\\\)   COMPILE SKIPPED: could not resolve a constant\");\n+            results.shouldMatch(\"Test_CD1.*::test \\\\(3 bytes\\\\)$\")\n+                   .shouldMatch(\"Test_CD2.*::test \\\\(3 bytes\\\\)$\")\n+                   .shouldMatch(\"Test_CD3.*::test \\\\(3 bytes\\\\)$\")\n+                   .shouldMatch(\"Test_CD4.*::test \\\\(3 bytes\\\\)$\");\n+\n+            if (isC1 && Platform.isAArch64()) { \/\/ no code patching\n+                results.shouldMatch(\"Test_CD1.*::test \\\\(3 bytes\\\\)   made not entrant\")\n+                       .shouldMatch(\"Test_CD2.*::test \\\\(3 bytes\\\\)   made not entrant\")\n+                       .shouldMatch(\"Test_CD3.*::test \\\\(3 bytes\\\\)   made not entrant\")\n+                       .shouldMatch(\"Test_CD4.*::test \\\\(3 bytes\\\\)   made not entrant\");\n@@ -239,4 +244,1 @@\n-                results.shouldMatch(\"Test_CD1.*::test \\\\(3 bytes\\\\)$\")\n-                       .shouldMatch(\"Test_CD2.*::test \\\\(3 bytes\\\\)$\")\n-                       .shouldMatch(\"Test_CD3.*::test \\\\(3 bytes\\\\)$\")\n-                       .shouldMatch(\"Test_CD4.*::test \\\\(3 bytes\\\\)$\");\n+                results.shouldNotContain(\"made not entrant\");\n","filename":"test\/hotspot\/jtreg\/compiler\/runtime\/TestConstantsInError.java","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"}]}