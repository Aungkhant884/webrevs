{"files":[{"patch":"@@ -163,1 +163,1 @@\n-  _src_obj_table(INITIAL_TABLE_SIZE),\n+  _src_obj_table(INITIAL_TABLE_SIZE, MAX_TABLE_SIZE),\n@@ -469,1 +469,1 @@\n-  SourceObjInfo* p = _src_obj_table.add_if_absent(src_obj, src_info, &created);\n+  SourceObjInfo* p = _src_obj_table.put_if_absent(src_obj, src_info, &created);\n@@ -471,1 +471,1 @@\n-    if (_src_obj_table.maybe_grow(MAX_TABLE_SIZE)) {\n+    if (_src_obj_table.maybe_grow()) {\n@@ -665,1 +665,1 @@\n-  SourceObjInfo* p = _src_obj_table.lookup(src_obj);\n+  SourceObjInfo* p = _src_obj_table.get(src_obj);\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-#include \"utilities\/hashtable.hpp\"\n+#include \"utilities\/resizeableResourceHash.hpp\"\n@@ -182,2 +182,2 @@\n-    bool do_entry(address key, const SourceObjInfo* value) {\n-      delete value->ref();\n+    bool do_entry(address key, const SourceObjInfo& value) {\n+      delete value.ref();\n@@ -202,1 +202,1 @@\n-  KVHashtable<address, SourceObjInfo, mtClassShared> _src_obj_table;\n+  ResizeableResourceHashtable<address, SourceObjInfo, ResourceObj::C_HEAP, mtClassShared> _src_obj_table;\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-    uint32_t* counter = _stats.add_if_absent(msg.output(), 0, &p_created);\n+    uint32_t* counter = _stats.put_if_absent(msg.output(), 0, &p_created);\n@@ -80,1 +80,1 @@\n-    _stats(17 \/*table_size*\/) {\n+    _stats() {\n@@ -96,1 +96,1 @@\n-  bool do_entry(LogFileOutput* output, uint32_t* counter) {\n+  bool do_entry(LogFileOutput* output, uint32_t& counter) {\n@@ -99,1 +99,1 @@\n-    if (*counter > 0) {\n+    if (counter > 0) {\n@@ -102,1 +102,1 @@\n-      ss.print(UINT32_FORMAT_W(6) \" messages dropped due to async logging\", *counter);\n+      ss.print(UINT32_FORMAT_W(6) \" messages dropped due to async logging\", counter);\n@@ -105,1 +105,1 @@\n-      *counter = 0;\n+      counter = 0;\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-#include \"utilities\/hashtable.hpp\"\n+#include \"utilities\/resourceHash.hpp\"\n@@ -111,1 +111,7 @@\n-typedef KVHashtable<LogFileOutput*, uint32_t, mtLogging> AsyncLogMap;\n+typedef ResourceHashtable<LogFileOutput*,\n+                          uint32_t,\n+                          primitive_hash<LogFileOutput*>,\n+                          primitive_equals<LogFileOutput*>,\n+                          17, \/*table_size*\/\n+                          ResourceObj::C_HEAP,\n+                          mtLogging> AsyncLogMap;\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.hpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1201,1 +1201,1 @@\n-\/\/ Default hash\/equals functions used by ResourceHashtable and KVHashtable\n+\/\/ Default hash\/equals functions used by ResourceHashtable\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -223,110 +223,0 @@\n-\/\/ A subclass of BasicHashtable that allows you to do a simple K -> V mapping\n-\/\/ without using tons of boilerplate code.\n-template<\n-    typename K, typename V, MEMFLAGS F,\n-    unsigned (*HASH)  (K const&)           = primitive_hash<K>,\n-    bool     (*EQUALS)(K const&, K const&) = primitive_equals<K>\n-    >\n-class KVHashtable : public BasicHashtable<F> {\n-  class KVHashtableEntry : public BasicHashtableEntry<F> {\n-  public:\n-    K _key;\n-    V _value;\n-    KVHashtableEntry* next() {\n-      return (KVHashtableEntry*)BasicHashtableEntry<F>::next();\n-    }\n-  };\n-\n-protected:\n-  KVHashtableEntry* bucket(int i) const {\n-    return (KVHashtableEntry*)BasicHashtable<F>::bucket(i);\n-  }\n-\n-  \/\/ The following method is not MT-safe and must be done under lock.\n-  KVHashtableEntry** bucket_addr(int i) {\n-    return (KVHashtableEntry**)BasicHashtable<F>::bucket_addr(i);\n-  }\n-\n-  KVHashtableEntry* new_entry(unsigned int hashValue, K key, V value) {\n-    KVHashtableEntry* entry = (KVHashtableEntry*)BasicHashtable<F>::new_entry(hashValue);\n-    entry->_key   = key;\n-    entry->_value = value;\n-    return entry;\n-  }\n-\n-  void free_entry(KVHashtableEntry* entry) {\n-    BasicHashtable<F>::free_entry(entry);\n-  }\n-\n-public:\n-  KVHashtable(int table_size) : BasicHashtable<F>(table_size, sizeof(KVHashtableEntry)) {}\n-  ~KVHashtable() {\n-    KVHashtableEntry* probe = NULL;\n-    for (int index = 0; index < table_size(); index++) {\n-      for (KVHashtableEntry** p = bucket_addr(index); *p != NULL; ) {\n-        probe = *p;\n-        *p = probe->next();\n-        free_entry(probe);\n-      }\n-    }\n-    assert(BasicHashtable<F>::number_of_entries() == 0, \"should have removed all entries\");\n-  }\n-\n-  V* add(K key, V value) {\n-    unsigned int hash = HASH(key);\n-    KVHashtableEntry* entry = new_entry(hash, key, value);\n-    BasicHashtable<F>::add_entry(BasicHashtable<F>::hash_to_index(hash), entry);\n-    return &(entry->_value);\n-  }\n-\n-  V* lookup(K key) const {\n-    unsigned int hash = HASH(key);\n-    int index = BasicHashtable<F>::hash_to_index(hash);\n-    for (KVHashtableEntry* e = bucket(index); e != NULL; e = e->next()) {\n-      if (e->hash() == hash && EQUALS(e->_key, key)) {\n-        return &(e->_value);\n-      }\n-    }\n-    return NULL;\n-  }\n-\n-  \/\/ Look up the key.\n-  \/\/ If an entry for the key exists, leave map unchanged and return a pointer to its value.\n-  \/\/ If no entry for the key exists, create a new entry from key and value and return a\n-  \/\/  pointer to the value.\n-  \/\/ *p_created is true if entry was created, false if entry pre-existed.\n-  V* add_if_absent(K key, V value, bool* p_created) {\n-    unsigned int hash = HASH(key);\n-    int index = BasicHashtable<F>::hash_to_index(hash);\n-    for (KVHashtableEntry* e = bucket(index); e != NULL; e = e->next()) {\n-      if (e->hash() == hash && EQUALS(e->_key, key)) {\n-        *p_created = false;\n-        return &(e->_value);\n-      }\n-    }\n-\n-    KVHashtableEntry* entry = new_entry(hash, key, value);\n-    BasicHashtable<F>::add_entry(BasicHashtable<F>::hash_to_index(hash), entry);\n-    *p_created = true;\n-    return &(entry->_value);\n-  }\n-\n-  int table_size() const {\n-    return BasicHashtable<F>::table_size();\n-  }\n-\n-  \/\/ ITER contains bool do_entry(K, V const&), which will be\n-  \/\/ called for each entry in the table.  If do_entry() returns false,\n-  \/\/ the iteration is cancelled.\n-  template<class ITER>\n-  void iterate(ITER* iter) const {\n-    for (int index = 0; index < table_size(); index++) {\n-      for (KVHashtableEntry* e = bucket(index); e != NULL; e = e->next()) {\n-        bool cont = iter->do_entry(e->_key, &e->_value);\n-        if (!cont) { return; }\n-      }\n-    }\n-  }\n-};\n-\n-\n","filename":"src\/hotspot\/share\/utilities\/hashtable.hpp","additions":0,"deletions":110,"binary":false,"changes":110,"status":"modified"}]}