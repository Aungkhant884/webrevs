{"files":[{"patch":"@@ -45,1 +45,0 @@\n-    jdk.incubator.concurrent \\\n","filename":"make\/conf\/docs-modules.conf","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -46,1 +46,0 @@\n-    jdk.incubator.concurrent \\\n","filename":"make\/conf\/module-loader-map.conf","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -121,0 +121,2 @@\n+  template(java_lang_ScopedValue,                     \"java\/lang\/ScopedValue\")                    \\\n+  template(java_lang_ScopedValue_Carrier,             \"java\/lang\/ScopedValue$Carrier\")            \\\n@@ -160,2 +162,0 @@\n-  template(jdk_incubator_concurrent_ScopedValue,      \"jdk\/incubator\/concurrent\/ScopedValue\")     \\\n-  template(jdk_incubator_concurrent_ScopedValue_Carrier, \"jdk\/incubator\/concurrent\/ScopedValue$Carrier\") \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1365,1 +1365,1 @@\n-    Klass *k = SystemDictionary::resolve_or_fail(vmSymbols::jdk_incubator_concurrent_ScopedValue_Carrier(), true, THREAD);\n+    Klass *k = SystemDictionary::resolve_or_fail(vmSymbols::java_lang_ScopedValue_Carrier(), true, THREAD);\n@@ -1398,1 +1398,1 @@\n-      StackValue* head_sv = locals->at(loc); \/\/ jdk\/incubator\/concurrent\/ScopedValue$Snapshot\n+      StackValue* head_sv = locals->at(loc); \/\/ java\/lang\/ScopedValue$Snapshot\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,962 @@\n+\/*\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Red Hat Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang;\n+\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import java.lang.ref.Reference;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.StructuredTaskScope;\n+import java.util.concurrent.StructureViolationException;\n+import java.util.function.Supplier;\n+import jdk.internal.access.JavaUtilConcurrentTLRAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.javac.PreviewFeature;\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.annotation.Hidden;\n+import jdk.internal.vm.ScopedValueContainer;\n+import sun.security.action.GetPropertyAction;\n+\n+\/**\n+ * A value that may be safely and efficiently shared to methods without using method\n+ * parameters.\n+ *\n+ * <p> In the Java programming language, data is usually passed to a method by means of a\n+ * method parameter. The data may need to be passed through a sequence of many methods to\n+ * get to the method that makes use of the data. Every method in the sequence of calls\n+ * needs to declare the parameter and every method has access to the data.\n+ * {@code ScopedValue} provides a means to pass data to a faraway method (typically a\n+ * <em>callback<\/em>) without using method parameters. In effect, a {@code ScopedValue}\n+ * is an <em>implicit method parameter<\/em>. It is \"as if\" every method in a sequence of\n+ * calls has an additional parameter. None of the methods declare the parameter and only\n+ * the methods that have access to the {@code ScopedValue} object can access its value\n+ * (the data). {@code ScopedValue} makes it possible to securely pass data from a\n+ * <em>caller<\/em> to a faraway <em>callee<\/em> through a sequence of intermediate methods\n+ * that do not declare a parameter for the data and have no access to the data.\n+ *\n+ * <p> The {@code ScopedValue} API works by executing a method with a {@code ScopedValue}\n+ * object <em>bound<\/em> to some value for the bounded period of execution of a method.\n+ * The method may invoke another method, which in turn may invoke another. The unfolding\n+ * execution of the methods define a <em>dynamic scope<\/em>. Code in these methods with\n+ * access to the {@code ScopedValue} object may read its value. The {@code ScopedValue}\n+ * object reverts to being <em>unbound<\/em> when the original method completes normally or\n+ * with an exception. The {@code ScopedValue} API supports executing a {@link Runnable#run()\n+ * Runnable.run}, {@link Callable#call() Callable.call}, or {@link Supplier#get() Supplier.get}\n+ * method with a {@code ScopedValue} bound to a value.\n+ *\n+ * <p> Consider the following example with a scoped value \"{@code NAME}\" bound to the value\n+ * \"{@code duke}\" for the execution of a {@code run} method. The {@code run} method, in\n+ * turn, invokes {@code doSomething}.\n+ * {@snippet lang=java :\n+ *     \/\/ @link substring=\"newInstance\" target=\"#newInstance\" :\n+ *     private static final ScopedValue<String> NAME = ScopedValue.newInstance();\n+ *\n+ *     \/\/ @link substring=\"runWhere\" target=\"#runWhere\" :\n+ *     ScopedValue.runWhere(NAME, \"duke\", () -> doSomething());\n+ * }\n+ * Code executed directly or indirectly by {@code doSomething}, with access to the field\n+ * {@code NAME}, can invoke {@code NAME.get()} to read the value \"{@code duke}\". {@code\n+ * NAME} is bound while executing the {@code run} method. It reverts to being unbound when\n+ * the {@code run} method completes.\n+ *\n+ * <p> The example using {@code runWhere} invokes a method that does not return a result.\n+ * The {@link #callWhere(ScopedValue, Object, Callable) callWhere} and {@link\n+ * #getWhere(ScopedValue, Object, Supplier) getWhere} can be used to invoke a method that\n+ * returns a result.\n+ * In addition, {@code ScopedValue} defines the {@link #where(ScopedValue, Object)} method\n+ * for cases where multiple mappings of ({@code ScopedValue} to value) are accumulated\n+ * in advance of calling a method with all {@code ScopedValue}s bound to their value.\n+ *\n+ * <h2>Bindings are per-thread<\/h2>\n+ *\n+ * A {@code ScopedValue} binding to a value is per-thread. Invoking {@code xxxWhere}\n+ * executes a method with a {@code ScopedValue} bound to a value for the current thread.\n+ * The {@link #get() get} method returns the value bound for the current thread.\n+ *\n+ * <p> In the example, if code executed by one thread invokes this:\n+ * {@snippet lang=java :\n+ *     ScopedValue.runWhere(NAME, \"duke1\", () -> doSomething());\n+ * }\n+ * and code executed by another thread invokes:\n+ * {@snippet lang=java :\n+ *     ScopedValue.runWhere(NAME, \"duke2\", () -> doSomething());\n+ * }\n+ * then code in {@code doSomething} (or any method that it calls) invoking {@code NAME.get()}\n+ * will read the value \"{@code duke1}\" or \"{@code duke2}\", depending on which thread is\n+ * executing.\n+ *\n+ * <h2>Scoped values as capabilities<\/h2>\n+ *\n+ * A {@code ScopedValue} object should be treated as a <em>capability<\/em> or a key to\n+ * access its value when the {@code ScopedValue} is bound. Secure usage depends on access\n+ * control (see <cite>The Java Virtual Machine Specification<\/cite>, Section {@jvms 5.4.4})\n+ * and taking care to not share the {@code ScopedValue} object. In many cases, a {@code\n+ * ScopedValue} will be declared in a {@code final} and {@code static} field so that it\n+ * is only accessible to code in a single class (or nest).\n+ *\n+ * <h2><a id=\"rebind\">Rebinding<\/a><\/h2>\n+ *\n+ * The {@code ScopedValue} API allows a new binding to be established for <em>nested\n+ * dynamic scopes<\/em>. This is known as <em>rebinding<\/em>. A {@code ScopedValue} that\n+ * is bound to a value may be bound to a new value for the bounded execution of a new\n+ * method. The unfolding execution of code executed by that method defines the nested\n+ * dynamic scope. When the method completes, the value of the {@code ScopedValue} reverts\n+ * to its previous value.\n+ *\n+ * <p> In the above example, suppose that code executed by {@code doSomething} binds\n+ * {@code NAME} to a new value with:\n+ * {@snippet lang=java :\n+ *     ScopedValue.runWhere(NAME, \"duchess\", () -> doMore());\n+ * }\n+ * Code executed directly or indirectly by {@code doMore()} that invokes {@code\n+ * NAME.get()} will read the value \"{@code duchess}\". When {@code doMore()} completes\n+ * then the value of {@code NAME} reverts to \"{@code duke}\".\n+ *\n+ * <h2><a id=\"inheritance\">Inheritance<\/a><\/h2>\n+ *\n+ * {@code ScopedValue} supports sharing across threads. This sharing is limited to\n+ * structured cases where child threads are started and terminate within the bounded\n+ * period of execution by a parent thread. When using a {@link StructuredTaskScope},\n+ * scoped value bindings are <em>captured<\/em> when creating a {@code StructuredTaskScope}\n+ * and inherited by all threads started in that task scope with the\n+ * {@link StructuredTaskScope#fork(Callable) fork} method.\n+ *\n+ * <p> A {@code ScopedValue} that is shared across threads requires that the value be an\n+ * immutable object or for all access to the value to be appropriately synchronized.\n+ *\n+ * <p> In the following example, the {@code ScopedValue} {@code NAME} is bound to the\n+ * value \"{@code duke}\" for the execution of a runnable operation. The code in the {@code\n+ * run} method creates a {@code StructuredTaskScope} that forks three tasks. Code executed\n+ * directly or indirectly by these threads running {@code childTask1()}, {@code childTask2()},\n+ * and {@code childTask3()} that invokes {@code NAME.get()} will read the value\n+ * \"{@code duke}\".\n+ *\n+ * {@snippet lang=java :\n+ *     private static final ScopedValue<String> NAME = ScopedValue.newInstance();\n+\n+ *     ScopedValue.runWhere(NAME, \"duke\", () -> {\n+ *         try (var scope = new StructuredTaskScope<String>()) {\n+ *\n+ *             scope.fork(() -> childTask1());\n+ *             scope.fork(() -> childTask2());\n+ *             scope.fork(() -> childTask3());\n+ *\n+ *             ...\n+ *          }\n+ *     });\n+ * }\n+ *\n+ * <p> Unless otherwise specified, passing a {@code null} argument to a method in this\n+ * class will cause a {@link NullPointerException} to be thrown.\n+ *\n+ * @apiNote\n+ * A {@code ScopedValue} should be preferred over a {@link ThreadLocal} for cases where\n+ * the goal is \"one-way transmission\" of data without using method parameters.  While a\n+ * {@code ThreadLocal} can be used to pass data to a method without using method parameters,\n+ * it does suffer from a number of issues:\n+ * <ol>\n+ *   <li> {@code ThreadLocal} does not prevent code in a faraway callee from {@linkplain\n+ *   ThreadLocal#set(Object) setting} a new value.\n+ *   <li> A {@code ThreadLocal} has an unbounded lifetime and thus continues to have a value\n+ *   after a method completes, unless explicitly {@linkplain ThreadLocal#remove() removed}.\n+ *   <li> {@linkplain InheritableThreadLocal Inheritance} is expensive - the map of\n+ *   thread-locals to values must be copied when creating each child thread.\n+ * <\/ol>\n+ *\n+ * @implNote\n+ * Scoped values are designed to be used in fairly small\n+ * numbers. {@link #get} initially performs a search through enclosing\n+ * scopes to find a scoped value's innermost binding. It\n+ * then caches the result of the search in a small thread-local\n+ * cache. Subsequent invocations of {@link #get} for that scoped value\n+ * will almost always be very fast. However, if a program has many\n+ * scoped values that it uses cyclically, the cache hit rate\n+ * will be low and performance will be poor. This design allows\n+ * scoped-value inheritance by {@link StructuredTaskScope} threads to\n+ * be very fast: in essence, no more than copying a pointer, and\n+ * leaving a scoped-value binding also requires little more than\n+ * updating a pointer.\n+ *\n+ * <p>Because the scoped-value per-thread cache is small, clients\n+ * should minimize the number of bound scoped values in use. For\n+ * example, if it is necessary to pass a number of values in this way,\n+ * it makes sense to create a record class to hold those values, and\n+ * then bind a single {@code ScopedValue} to an instance of that record.\n+ *\n+ * <p>For this release, the reference implementation\n+ * provides some system properties to tune the performance of scoped\n+ * values.\n+ *\n+ * <p>The system property {@code java.lang.ScopedValue.cacheSize}\n+ * controls the size of the (per-thread) scoped-value cache. This cache is crucial\n+ * for the performance of scoped values. If it is too small,\n+ * the runtime library will repeatedly need to scan for each\n+ * {@link #get}. If it is too large, memory will be unnecessarily\n+ * consumed. The default scoped-value cache size is 16 entries. It may\n+ * be varied from 2 to 16 entries in size. {@code ScopedValue.cacheSize}\n+ * must be an integer power of 2.\n+ *\n+ * <p>For example, you could use {@code -Djava.lang.ScopedValue.cacheSize=8}.\n+ *\n+ * <p>The other system property is {@code jdk.preserveScopedValueCache}.\n+ * This property determines whether the per-thread scoped-value\n+ * cache is preserved when a virtual thread is blocked. By default\n+ * this property is set to {@code true}, meaning that every virtual\n+ * thread preserves its scoped-value cache when blocked. Like {@code\n+ * ScopedValue.cacheSize}, this is a space versus speed trade-off: in\n+ * situations where many virtual threads are blocked most of the time,\n+ * setting this property to {@code false} might result in a useful\n+ * memory saving, but each virtual thread's scoped-value cache would\n+ * have to be regenerated after a blocking operation.\n+ *\n+ * @param <T> the type of the value\n+ * @since 21\n+ *\/\n+@PreviewFeature(feature = PreviewFeature.Feature.SCOPED_VALUES)\n+public final class ScopedValue<T> {\n+    private final int hash;\n+\n+    @Override\n+    public int hashCode() { return hash; }\n+\n+    \/**\n+     * An immutable map from {@code ScopedValue} to values.\n+     *\n+     * <p> Unless otherwise specified, passing a {@code null} argument to a constructor\n+     * or method in this class will cause a {@link NullPointerException} to be thrown.\n+     *\/\n+    static final class Snapshot {\n+        final Snapshot prev;\n+        final Carrier bindings;\n+        final int bitmask;\n+\n+        private static final Object NIL = new Object();\n+\n+        static final Snapshot EMPTY_SNAPSHOT = new Snapshot();\n+\n+        Snapshot(Carrier bindings, Snapshot prev) {\n+            this.prev = prev;\n+            this.bindings = bindings;\n+            this.bitmask = bindings.bitmask | prev.bitmask;\n+        }\n+\n+        protected Snapshot() {\n+            this.prev = null;\n+            this.bindings = null;\n+            this.bitmask = 0;\n+        }\n+\n+        Object find(ScopedValue<?> key) {\n+            int bits = key.bitmask();\n+            for (Snapshot snapshot = this;\n+                 containsAll(snapshot.bitmask, bits);\n+                 snapshot = snapshot.prev) {\n+                for (Carrier carrier = snapshot.bindings;\n+                     carrier != null && containsAll(carrier.bitmask, bits);\n+                     carrier = carrier.prev) {\n+                    if (carrier.getKey() == key) {\n+                        Object value = carrier.get();\n+                        return value;\n+                    }\n+                }\n+            }\n+            return NIL;\n+        }\n+    }\n+\n+    \/**\n+     * A mapping of scoped values, as <em>keys<\/em>, to values.\n+     *\n+     * <p> A {@code Carrier} is used to accumulate mappings so that an operation (a\n+     * {@link Runnable} or {@link Callable}) can be executed with all scoped values in the\n+     * mapping bound to values. The following example runs an operation with {@code k1}\n+     * bound (or rebound) to {@code v1}, and {@code k2} bound (or rebound) to {@code v2}.\n+     * {@snippet lang=java :\n+     *     \/\/ @link substring=\"where\" target=\"#where(ScopedValue, Object)\" :\n+     *     ScopedValue.where(k1, v1).where(k2, v2).run(() -> ... );\n+     * }\n+     *\n+     * <p> A {@code Carrier} is immutable and thread-safe. The {@link\n+     * #where(ScopedValue, Object) where} method returns a new {@code Carrier} object,\n+     * it does not mutate an existing mapping.\n+     *\n+     * <p> Unless otherwise specified, passing a {@code null} argument to a method in\n+     * this class will cause a {@link NullPointerException} to be thrown.\n+     *\n+     * @since 21\n+     *\/\n+    @PreviewFeature(feature = PreviewFeature.Feature.SCOPED_VALUES)\n+    public static final class Carrier {\n+        \/\/ Bit masks: a 1 in postion n indicates that this set of bound values\n+        \/\/ hits that slot in the cache.\n+        final int bitmask;\n+        final ScopedValue<?> key;\n+        final Object value;\n+        final Carrier prev;\n+\n+        Carrier(ScopedValue<?> key, Object value, Carrier prev) {\n+            this.key = key;\n+            this.value = value;\n+            this.prev = prev;\n+            int bits = key.bitmask();\n+            if (prev != null) {\n+                bits |= prev.bitmask;\n+            }\n+            this.bitmask = bits;\n+        }\n+\n+        \/**\n+         * Add a binding to this map, returning a new Carrier instance.\n+         *\/\n+        private static <T> Carrier where(ScopedValue<T> key, T value, Carrier prev) {\n+            return new Carrier(key, value, prev);\n+        }\n+\n+        \/**\n+         * Returns a new {@code Carrier} with the mappings from this carrier plus a\n+         * new mapping from {@code key} to {@code value}. If this carrier already has a\n+         * mapping for the scoped value {@code key} then it will map to the new\n+         * {@code value}. The current carrier is immutable, so it is not changed by this\n+         * method.\n+         *\n+         * @param key the {@code ScopedValue} key\n+         * @param value the value, can be {@code null}\n+         * @param <T> the type of the value\n+         * @return a new {@code Carrier} with the mappings from this carrier plus the new mapping\n+         *\/\n+        public <T> Carrier where(ScopedValue<T> key, T value) {\n+            return where(key, value, this);\n+        }\n+\n+        \/*\n+         * Return a new set consisting of a single binding.\n+         *\/\n+        static <T> Carrier of(ScopedValue<T> key, T value) {\n+            return where(key, value, null);\n+        }\n+\n+        Object get() {\n+            return value;\n+        }\n+\n+        ScopedValue<?> getKey() {\n+            return key;\n+        }\n+\n+        \/**\n+         * Returns the value of a {@link ScopedValue} in this mapping.\n+         *\n+         * @param key the {@code ScopedValue} key\n+         * @param <T> the type of the value\n+         * @return the value\n+         * @throws NoSuchElementException if the key is not present in this mapping\n+         *\/\n+        @SuppressWarnings(\"unchecked\")\n+        public <T> T get(ScopedValue<T> key) {\n+            var bits = key.bitmask();\n+            for (Carrier carrier = this;\n+                 carrier != null && containsAll(carrier.bitmask, bits);\n+                 carrier = carrier.prev) {\n+                if (carrier.getKey() == key) {\n+                    Object value = carrier.get();\n+                    return (T)value;\n+                }\n+            }\n+            throw new NoSuchElementException();\n+        }\n+\n+        \/**\n+         * Calls a value-returning operation with each scoped value in this mapping bound\n+         * to its value in the current thread.\n+         * When the operation completes (normally or with an exception), each scoped value\n+         * in the mapping will revert to being unbound, or revert to its previous value\n+         * when previously bound, in the current thread.\n+         *\n+         * <p> Scoped values are intended to be used in a <em>structured manner<\/em>.\n+         * If {@code op} creates a {@link StructuredTaskScope} but does not {@linkplain\n+         * StructuredTaskScope#close() close} it, then exiting {@code op} causes the\n+         * underlying construct of each {@code StructuredTaskScope} created in the\n+         * dynamic scope to be closed. This may require blocking until all child threads\n+         * have completed their sub-tasks. The closing is done in the reverse order that\n+         * they were created. Once closed, {@link StructureViolationException} is thrown.\n+         *\n+         * @param op the operation to run\n+         * @param <R> the type of the result of the operation\n+         * @return the result\n+         * @throws Exception if {@code op} completes with an exception\n+         * @see ScopedValue#callWhere(ScopedValue, Object, Callable)\n+         *\/\n+        public <R> R call(Callable<? extends R> op) throws Exception {\n+            Objects.requireNonNull(op);\n+            Cache.invalidate(bitmask);\n+            var prevSnapshot = scopedValueBindings();\n+            var newSnapshot = new Snapshot(this, prevSnapshot);\n+            return runWith(newSnapshot, op);\n+        }\n+\n+        \/**\n+         * Invokes a supplier of results with each scoped value in this mapping bound\n+         * to its value in the current thread.\n+         * When the operation completes (normally or with an exception), each scoped value\n+         * in the mapping will revert to being unbound, or revert to its previous value\n+         * when previously bound, in the current thread.\n+         *\n+         * <p> Scoped values are intended to be used in a <em>structured manner<\/em>.\n+         * If {@code op} creates a {@link StructuredTaskScope} but does not {@linkplain\n+         * StructuredTaskScope#close() close} it, then exiting {@code op} causes the\n+         * underlying construct of each {@code StructuredTaskScope} created in the\n+         * dynamic scope to be closed. This may require blocking until all child threads\n+         * have completed their sub-tasks. The closing is done in the reverse order that\n+         * they were created. Once closed, {@link StructureViolationException} is thrown.\n+         *\n+         * @param op the operation to run\n+         * @param <R> the type of the result of the operation\n+         * @return the result\n+         * @see ScopedValue#getWhere(ScopedValue, Object, Supplier)\n+         *\/\n+        public <R> R get(Supplier<? extends R> op) {\n+            Objects.requireNonNull(op);\n+            Cache.invalidate(bitmask);\n+            var prevSnapshot = scopedValueBindings();\n+            var newSnapshot = new Snapshot(this, prevSnapshot);\n+            return runWith(newSnapshot, new CallableAdapter<R>(op));\n+        }\n+\n+        \/\/ A lightweight adapter from Supplier to Callable. This is\n+        \/\/ used here to create the Callable which is passed to\n+        \/\/ Carrier#call() in this thread because it needs neither\n+        \/\/ runtime bytecode generation nor any release fencing.\n+        private static final class CallableAdapter<V> implements Callable<V> {\n+            private \/*non-final*\/ Supplier<? extends V> s;\n+            CallableAdapter(Supplier<? extends V> s) {\n+                this.s = s;\n+            }\n+            public V call() {\n+                return s.get();\n+            }\n+        }\n+\n+        \/**\n+         * Execute the action with a set of ScopedValue bindings.\n+         *\n+         * The VM recognizes this method as special, so any changes to the\n+         * name or signature require corresponding changes in\n+         * JVM_FindScopedValueBindings().\n+         *\/\n+        @Hidden\n+        @ForceInline\n+        private <R> R runWith(Snapshot newSnapshot, Callable<R> op) {\n+            try {\n+                Thread.setScopedValueBindings(newSnapshot);\n+                Thread.ensureMaterializedForStackWalk(newSnapshot);\n+                return ScopedValueContainer.call(op);\n+            } finally {\n+                Reference.reachabilityFence(newSnapshot);\n+                Thread.setScopedValueBindings(newSnapshot.prev);\n+                Cache.invalidate(bitmask);\n+            }\n+        }\n+\n+        \/**\n+         * Runs an operation with each scoped value in this mapping bound to its value\n+         * in the current thread.\n+         * When the operation completes (normally or with an exception), each scoped value\n+         * in the mapping will revert to being unbound, or revert to its previous value\n+         * when previously bound, in the current thread.\n+         *\n+         * <p> Scoped values are intended to be used in a <em>structured manner<\/em>.\n+         * If {@code op} creates a {@link StructuredTaskScope} but does not {@linkplain\n+         * StructuredTaskScope#close() close} it, then exiting {@code op} causes the\n+         * underlying construct of each {@code StructuredTaskScope} created in the\n+         * dynamic scope to be closed. This may require blocking until all child threads\n+         * have completed their sub-tasks. The closing is done in the reverse order that\n+         * they were created. Once closed, {@link StructureViolationException} is thrown.\n+         *\n+         * @param op the operation to run\n+         * @see ScopedValue#runWhere(ScopedValue, Object, Runnable)\n+         *\/\n+        public void run(Runnable op) {\n+            Objects.requireNonNull(op);\n+            Cache.invalidate(bitmask);\n+            var prevSnapshot = scopedValueBindings();\n+            var newSnapshot = new Snapshot(this, prevSnapshot);\n+            runWith(newSnapshot, op);\n+        }\n+\n+        \/**\n+         * Execute the action with a set of {@code ScopedValue} bindings.\n+         *\n+         * The VM recognizes this method as special, so any changes to the\n+         * name or signature require corresponding changes in\n+         * JVM_FindScopedValueBindings().\n+         *\/\n+        @Hidden\n+        @ForceInline\n+        private void runWith(Snapshot newSnapshot, Runnable op) {\n+            try {\n+                Thread.setScopedValueBindings(newSnapshot);\n+                Thread.ensureMaterializedForStackWalk(newSnapshot);\n+                ScopedValueContainer.run(op);\n+            } finally {\n+                Reference.reachabilityFence(newSnapshot);\n+                Thread.setScopedValueBindings(newSnapshot.prev);\n+                Cache.invalidate(bitmask);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Creates a new {@code Carrier} with a single mapping of a {@code ScopedValue}\n+     * <em>key<\/em> to a value. The {@code Carrier} can be used to accumlate mappings so\n+     * that an operation can be executed with all scoped values in the mapping bound to\n+     * values. The following example runs an operation with {@code k1} bound (or rebound)\n+     * to {@code v1}, and {@code k2} bound (or rebound) to {@code v2}.\n+     * {@snippet lang=java :\n+     *     \/\/ @link substring=\"run\" target=\"Carrier#run(Runnable)\" :\n+     *     ScopedValue.where(k1, v1).where(k2, v2).run(() -> ... );\n+     * }\n+     *\n+     * @param key the {@code ScopedValue} key\n+     * @param value the value, can be {@code null}\n+     * @param <T> the type of the value\n+     * @return a new {@code Carrier} with a single mapping\n+     *\/\n+    public static <T> Carrier where(ScopedValue<T> key, T value) {\n+        return Carrier.of(key, value);\n+    }\n+\n+    \/**\n+     * Calls a value-returning operation with a {@code ScopedValue} bound to a value\n+     * in the current thread. When the operation completes (normally or with an\n+     * exception), the {@code ScopedValue} will revert to being unbound, or revert to\n+     * its previous value when previously bound, in the current thread.\n+     *\n+     * <p> Scoped values are intended to be used in a <em>structured manner<\/em>.\n+     * If {@code op} creates a {@link StructuredTaskScope} but does not {@linkplain\n+     * StructuredTaskScope#close() close} it, then exiting {@code op} causes the\n+     * underlying construct of each {@code StructuredTaskScope} created in the\n+     * dynamic scope to be closed. This may require blocking until all child threads\n+     * have completed their sub-tasks. The closing is done in the reverse order that\n+     * they were created. Once closed, {@link StructureViolationException} is thrown.\n+     *\n+     * @implNote\n+     * This method is implemented to be equivalent to:\n+     * {@snippet lang=java :\n+     *     \/\/ @link substring=\"call\" target=\"Carrier#call(Callable)\" :\n+     *     ScopedValue.where(key, value).call(op);\n+     * }\n+     *\n+     * @param key the {@code ScopedValue} key\n+     * @param value the value, can be {@code null}\n+     * @param <T> the type of the value\n+     * @param <R> the result type\n+     * @param op the operation to call\n+     * @return the result\n+     * @throws Exception if the operation completes with an exception\n+     *\/\n+    public static <T, R> R callWhere(ScopedValue<T> key,\n+                                     T value,\n+                                     Callable<? extends R> op) throws Exception {\n+        return where(key, value).call(op);\n+    }\n+\n+    \/**\n+     * Invokes a supplier of results with a {@code ScopedValue} bound to a value\n+     * in the current thread. When the operation completes (normally or with an\n+     * exception), the {@code ScopedValue} will revert to being unbound, or revert to\n+     * its previous value when previously bound, in the current thread.\n+     *\n+     * <p> Scoped values are intended to be used in a <em>structured manner<\/em>.\n+     * If {@code op} creates a {@link StructuredTaskScope} but does not {@linkplain\n+     * StructuredTaskScope#close() close} it, then exiting {@code op} causes the\n+     * underlying construct of each {@code StructuredTaskScope} created in the\n+     * dynamic scope to be closed. This may require blocking until all child threads\n+     * have completed their sub-tasks. The closing is done in the reverse order that\n+     * they were created. Once closed, {@link StructureViolationException} is thrown.\n+     *\n+     * @implNote\n+     * This method is implemented to be equivalent to:\n+     * {@snippet lang=java :\n+     *     \/\/ @link substring=\"get\" target=\"Carrier#get(Supplier)\" :\n+     *     ScopedValue.where(key, value).get(op);\n+     * }\n+     *\n+     * @param key the {@code ScopedValue} key\n+     * @param value the value, can be {@code null}\n+     * @param <T> the type of the value\n+     * @param <R> the result type\n+     * @param op the operation to call\n+     * @return the result\n+     *\/\n+    public static <T, R> R getWhere(ScopedValue<T> key,\n+                                    T value,\n+                                    Supplier<? extends R> op) {\n+        return where(key, value).get(op);\n+    }\n+\n+    \/**\n+     * Run an operation with a {@code ScopedValue} bound to a value in the current\n+     * thread. When the operation completes (normally or with an exception), the\n+     * {@code ScopedValue} will revert to being unbound, or revert to its previous value\n+     * when previously bound, in the current thread.\n+     *\n+     * <p> Scoped values are intended to be used in a <em>structured manner<\/em>.\n+     * If {@code op} creates a {@link StructuredTaskScope} but does not {@linkplain\n+     * StructuredTaskScope#close() close} it, then exiting {@code op} causes the\n+     * underlying construct of each {@code StructuredTaskScope} created in the\n+     * dynamic scope to be closed. This may require blocking until all child threads\n+     * have completed their sub-tasks. The closing is done in the reverse order that\n+     * they were created. Once closed, {@link StructureViolationException} is thrown.\n+     *\n+     * @implNote\n+     * This method is implemented to be equivalent to:\n+     * {@snippet lang=java :\n+     *     \/\/ @link substring=\"run\" target=\"Carrier#run(Runnable)\" :\n+     *     ScopedValue.where(key, value).run(op);\n+     * }\n+     *\n+     * @param key the {@code ScopedValue} key\n+     * @param value the value, can be {@code null}\n+     * @param <T> the type of the value\n+     * @param op the operation to call\n+     *\/\n+    public static <T> void runWhere(ScopedValue<T> key, T value, Runnable op) {\n+        where(key, value).run(op);\n+    }\n+\n+    private ScopedValue() {\n+        this.hash = generateKey();\n+    }\n+\n+    \/**\n+     * Creates a scoped value that is initially unbound for all threads.\n+     *\n+     * @param <T> the type of the value\n+     * @return a new {@code ScopedValue}\n+     *\/\n+    public static <T> ScopedValue<T> newInstance() {\n+        return new ScopedValue<T>();\n+    }\n+\n+    \/**\n+     * {@return the value of the scoped value if bound in the current thread}\n+     *\n+     * @throws NoSuchElementException if the scoped value is not bound\n+     *\/\n+    @ForceInline\n+    @SuppressWarnings(\"unchecked\")\n+    public T get() {\n+        Object[] objects;\n+        if ((objects = scopedValueCache()) != null) {\n+            \/\/ This code should perhaps be in class Cache. We do it\n+            \/\/ here because the generated code is small and fast and\n+            \/\/ we really want it to be inlined in the caller.\n+            int n = (hash & Cache.SLOT_MASK) * 2;\n+            if (objects[n] == this) {\n+                return (T)objects[n + 1];\n+            }\n+            n = ((hash >>> Cache.INDEX_BITS) & Cache.SLOT_MASK) * 2;\n+            if (objects[n] == this) {\n+                return (T)objects[n + 1];\n+            }\n+        }\n+        return slowGet();\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private T slowGet() {\n+        var value = findBinding();\n+        if (value == Snapshot.NIL) {\n+            throw new NoSuchElementException();\n+        }\n+        Cache.put(this, value);\n+        return (T)value;\n+    }\n+\n+    \/**\n+     * {@return {@code true} if this scoped value is bound in the current thread}\n+     *\/\n+    public boolean isBound() {\n+        Object[] objects = scopedValueCache();\n+        if (objects != null) {\n+            int n = (hash & Cache.SLOT_MASK) * 2;\n+            if (objects[n] == this) {\n+                return true;\n+            }\n+            n = ((hash >>> Cache.INDEX_BITS) & Cache.SLOT_MASK) * 2;\n+            if (objects[n] == this) {\n+                return true;\n+            }\n+        }\n+        var value = findBinding();\n+        boolean result = (value != Snapshot.NIL);\n+        if (result)  Cache.put(this, value);\n+        return result;\n+    }\n+\n+    \/**\n+     * Return the value of the scoped value or NIL if not bound.\n+     *\/\n+    private Object findBinding() {\n+        Object value = scopedValueBindings().find(this);\n+        return value;\n+    }\n+\n+    \/**\n+     * Returns the value of this scoped value if bound in the current thread, otherwise\n+     * returns {@code other}.\n+     *\n+     * @param other the value to return if not bound, can be {@code null}\n+     * @return the value of the scoped value if bound, otherwise {@code other}\n+     *\/\n+    public T orElse(T other) {\n+        Object obj = findBinding();\n+        if (obj != Snapshot.NIL) {\n+            @SuppressWarnings(\"unchecked\")\n+            T value = (T) obj;\n+            return value;\n+        } else {\n+            return other;\n+        }\n+    }\n+\n+    \/**\n+     * Returns the value of this scoped value if bound in the current thread, otherwise\n+     * throws an exception produced by the exception supplying function.\n+     *\n+     * @param <X> the type of the exception that may be thrown\n+     * @param exceptionSupplier the supplying function that produces the exception to throw\n+     * @return the value of the scoped value if bound in the current thread\n+     * @throws X if the scoped value is not bound in the current thread\n+     *\/\n+    public <X extends Throwable> T orElseThrow(Supplier<? extends X> exceptionSupplier) throws X {\n+        Objects.requireNonNull(exceptionSupplier);\n+        Object obj = findBinding();\n+        if (obj != Snapshot.NIL) {\n+            @SuppressWarnings(\"unchecked\")\n+            T value = (T) obj;\n+            return value;\n+        } else {\n+            throw exceptionSupplier.get();\n+        }\n+    }\n+\n+    private static Object[] scopedValueCache() {\n+        return Thread.scopedValueCache();\n+    }\n+\n+    private static void setScopedValueCache(Object[] cache) {\n+        Thread.setScopedValueCache(cache);\n+    }\n+\n+    \/\/ Special value to indicate this is a newly-created Thread\n+    \/\/ Note that his must match the declaration in j.l.Thread.\n+    private static final Object NEW_THREAD_BINDINGS = Thread.class;\n+\n+    private static Snapshot scopedValueBindings() {\n+        \/\/ Bindings can be in one of four states:\n+        \/\/\n+        \/\/ 1: class Thread: this is a new Thread instance, and no\n+        \/\/ scoped values have ever been bound in this Thread.\n+        \/\/ 2: EmptySnapshot.SINGLETON: This is effectively an empty binding.\n+        \/\/ 3: A Snapshot instance: this contains one or more scoped value\n+        \/\/ bindings.\n+        \/\/ 4: null: there may be some bindings in this Thread, but we don't know\n+        \/\/ where they are. We must invoke Thread.findScopedValueBindings() to walk\n+        \/\/ the stack to find them.\n+\n+        Object bindings = Thread.scopedValueBindings();\n+        if (bindings == NEW_THREAD_BINDINGS) {\n+            \/\/ This must be a new thread\n+           return Snapshot.EMPTY_SNAPSHOT;\n+        }\n+        if (bindings == null) {\n+            \/\/ Search the stack\n+            bindings = Thread.findScopedValueBindings();\n+            if (bindings == null) {\n+                \/\/ Nothing on the stack.\n+                bindings = Snapshot.EMPTY_SNAPSHOT;\n+            }\n+        }\n+        assert (bindings != null);\n+        Thread.setScopedValueBindings(bindings);\n+        return (Snapshot) bindings;\n+    }\n+\n+    private static int nextKey = 0xf0f0_f0f0;\n+\n+    \/\/ A Marsaglia xor-shift generator used to generate hashes. This one has full period, so\n+    \/\/ it generates 2**32 - 1 hashes before it repeats. We're going to use the lowest n bits\n+    \/\/ and the next n bits as cache indexes, so we make sure that those indexes map\n+    \/\/ to different slots in the cache.\n+    private static synchronized int generateKey() {\n+        int x = nextKey;\n+        do {\n+            x ^= x >>> 12;\n+            x ^= x << 9;\n+            x ^= x >>> 23;\n+        } while (Cache.primarySlot(x) == Cache.secondarySlot(x));\n+        return (nextKey = x);\n+    }\n+\n+    \/**\n+     * Return a bit mask that may be used to determine if this ScopedValue is\n+     * bound in the current context. Each Carrier holds a bit mask which is\n+     * the OR of all the bit masks of the bound ScopedValues.\n+     * @return the bitmask\n+     *\/\n+    int bitmask() {\n+        return (1 << Cache.primaryIndex(this)) | (1 << (Cache.secondaryIndex(this) + Cache.TABLE_SIZE));\n+    }\n+\n+    \/\/ Return true iff bitmask, considered as a set of bits, contains all\n+    \/\/ of the bits in targetBits.\n+    static boolean containsAll(int bitmask, int targetBits) {\n+        return (bitmask & targetBits) == targetBits;\n+    }\n+\n+    \/\/ A small fixed-size key-value cache. When a scoped value's get() method\n+    \/\/ is invoked, we record the result of the lookup in this per-thread cache\n+    \/\/ for fast access in future.\n+    private static final class Cache {\n+        static final int INDEX_BITS = 4;  \/\/ Must be a power of 2\n+        static final int TABLE_SIZE = 1 << INDEX_BITS;\n+        static final int TABLE_MASK = TABLE_SIZE - 1;\n+        static final int PRIMARY_MASK = (1 << TABLE_SIZE) - 1;\n+\n+        \/\/ The number of elements in the cache array, and a bit mask used to\n+        \/\/ select elements from it.\n+        private static final int CACHE_TABLE_SIZE, SLOT_MASK;\n+        \/\/ The largest cache we allow. Must be a power of 2 and greater than\n+        \/\/ or equal to 2.\n+        private static final int MAX_CACHE_SIZE = 16;\n+\n+        static {\n+            final String propertyName = \"java.lang.ScopedValue.cacheSize\";\n+            var sizeString = GetPropertyAction.privilegedGetProperty(propertyName, \"16\");\n+            var cacheSize = Integer.valueOf(sizeString);\n+            if (cacheSize < 2 || cacheSize > MAX_CACHE_SIZE) {\n+                cacheSize = MAX_CACHE_SIZE;\n+                System.err.println(propertyName + \" is out of range: is \" + sizeString);\n+            }\n+            if ((cacheSize & (cacheSize - 1)) != 0) {  \/\/ a power of 2\n+                cacheSize = MAX_CACHE_SIZE;\n+                System.err.println(propertyName + \" must be an integer power of 2: is \" + sizeString);\n+            }\n+            CACHE_TABLE_SIZE = cacheSize;\n+            SLOT_MASK = cacheSize - 1;\n+        }\n+\n+        static int primaryIndex(ScopedValue<?> key) {\n+            return key.hash & TABLE_MASK;\n+        }\n+\n+        static int secondaryIndex(ScopedValue<?> key) {\n+            return (key.hash >> INDEX_BITS) & TABLE_MASK;\n+        }\n+\n+        private static int primarySlot(ScopedValue<?> key) {\n+            return key.hashCode() & SLOT_MASK;\n+        }\n+\n+        private static int secondarySlot(ScopedValue<?> key) {\n+            return (key.hash >> INDEX_BITS) & SLOT_MASK;\n+        }\n+\n+        static int primarySlot(int hash) {\n+            return hash & SLOT_MASK;\n+        }\n+\n+        static int secondarySlot(int hash) {\n+            return (hash >> INDEX_BITS) & SLOT_MASK;\n+        }\n+\n+        static void put(ScopedValue<?> key, Object value) {\n+            Object[] theCache = scopedValueCache();\n+            if (theCache == null) {\n+                theCache = new Object[CACHE_TABLE_SIZE * 2];\n+                setScopedValueCache(theCache);\n+            }\n+            \/\/ Update the cache to replace one entry with the value we just looked up.\n+            \/\/ Each value can be in one of two possible places in the cache.\n+            \/\/ Pick a victim at (pseudo-)random.\n+            int k1 = primarySlot(key);\n+            int k2 = secondarySlot(key);\n+            var usePrimaryIndex = chooseVictim();\n+            int victim = usePrimaryIndex ? k1 : k2;\n+            int other = usePrimaryIndex ? k2 : k1;\n+            setKeyAndObjectAt(victim, key, value);\n+            if (getKey(theCache, other) == key) {\n+                setKeyAndObjectAt(other, key, value);\n+            }\n+        }\n+\n+        private static void setKeyAndObjectAt(int n, Object key, Object value) {\n+            var cache = scopedValueCache();\n+            cache[n * 2] = key;\n+            cache[n * 2 + 1] = value;\n+        }\n+\n+        private static void setKeyAndObjectAt(Object[] cache, int n, Object key, Object value) {\n+            cache[n * 2] = key;\n+            cache[n * 2 + 1] = value;\n+        }\n+\n+        private static Object getKey(Object[] objs, int n) {\n+            return objs[n * 2];\n+        }\n+\n+        private static void setKey(Object[] objs, int n, Object key) {\n+            objs[n * 2] = key;\n+        }\n+\n+        private static final JavaUtilConcurrentTLRAccess THREAD_LOCAL_RANDOM_ACCESS\n+                = SharedSecrets.getJavaUtilConcurrentTLRAccess();\n+\n+        \/\/ Return either true or false, at pseudo-random, with a bias towards true.\n+        \/\/ This chooses either the primary or secondary cache slot, but the\n+        \/\/ primary slot is approximately twice as likely to be chosen as the\n+        \/\/ secondary one.\n+        private static boolean chooseVictim() {\n+            int r = THREAD_LOCAL_RANDOM_ACCESS.nextSecondaryThreadLocalRandomSeed();\n+            return (r & 15) >= 5;\n+        }\n+\n+        \/\/ Null a set of cache entries, indicated by the 1-bits given\n+        static void invalidate(int toClearBits) {\n+            toClearBits = (toClearBits >>> TABLE_SIZE) | (toClearBits & PRIMARY_MASK);\n+            Object[] objects;\n+            if ((objects = scopedValueCache()) != null) {\n+                for (int bits = toClearBits; bits != 0; ) {\n+                    int index = Integer.numberOfTrailingZeros(bits);\n+                    setKeyAndObjectAt(objects, index & SLOT_MASK, null, null);\n+                    bits &= ~1 << index;\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ScopedValue.java","additions":962,"deletions":0,"binary":false,"changes":962,"status":"added"},{"patch":"@@ -2621,13 +2621,0 @@\n-            public Object findScopedValueBindings() {\n-                return Thread.findScopedValueBindings();\n-            }\n-\n-            public void setScopedValueBindings(Object bindings) {\n-                Thread.setScopedValueBindings(bindings);\n-            }\n-\n-            @ForceInline\n-            public void ensureMaterializedForStackWalk(Object value) {\n-                Thread.ensureMaterializedForStackWalk(value);\n-            }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import java.util.concurrent.StructureViolationException;\n@@ -42,1 +43,0 @@\n-import jdk.internal.misc.StructureViolationExceptions;\n@@ -324,1 +324,1 @@\n-                StructureViolationExceptions.throwException(\"Scoped value bindings have changed\");\n+                throw new StructureViolationException(\"Scoped value bindings have changed\");\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Thread.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package java.util.concurrent;\n+\n+import jdk.internal.javac.PreviewFeature;\n+\n+\/**\n+ * Thrown when a structure violation is detected.\n+ *\n+ * @see StructuredTaskScope#close()\n+ *\n+ * @since 21\n+ *\/\n+@PreviewFeature(feature = PreviewFeature.Feature.STRUCTURED_CONCURRENCY)\n+public final class StructureViolationException extends RuntimeException {\n+    @java.io.Serial\n+    private static final long serialVersionUID = -7705327650798235468L;\n+\n+    \/**\n+     * Constructs a {@code StructureViolationException} with no detail message.\n+     *\/\n+    public StructureViolationException() {\n+        super();\n+    }\n+\n+    \/**\n+     * Constructs a {@code StructureViolationException} with the specified\n+     * detail message.\n+     *\n+     * @param  message the detail message, can be null\n+     *\/\n+    public StructureViolationException(String message) {\n+        super(message);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/StructureViolationException.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,1273 @@\n+\/*\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package java.util.concurrent;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import jdk.internal.javac.PreviewFeature;\n+import jdk.internal.misc.ThreadFlock;\n+\n+\/**\n+ * A basic API for <em>structured concurrency<\/em>. {@code StructuredTaskScope} supports\n+ * cases where a task splits into several concurrent subtasks, and where the subtasks must\n+ * complete before the main task continues. A {@code StructuredTaskScope} can be used to\n+ * ensure that the lifetime of a concurrent operation is confined by a <em>syntax block<\/em>,\n+ * just like that of a sequential operation in structured programming.\n+ *\n+ * <h2>Basic operation<\/h2>\n+ *\n+ * A {@code StructuredTaskScope} is created with one of its public constructors. It defines\n+ * the {@link #fork(Callable) fork} method to start a thread to execute a subtask, the {@link\n+ * #join() join} method to wait for all subtasks to finish, and the {@link #close() close}\n+ * method to close the task scope. The API is intended to be used with the {@code\n+ * try-with-resources} statement. The intention is that code in the try <em>block<\/em>\n+ * uses the {@code fork} method to fork threads to execute the subtasks, wait for the\n+ * subtasks to finish with the {@code join} method, and then <em>process the results<\/em>.\n+ * A call to the {@code fork} method returns a {@link Subtask Subtask} to representing\n+ * the <em>forked subtask<\/em>. Once {@code join} is called, the {@code Subtask} can be\n+ * used to get the result completed successfully, or the exception if the subtask failed.\n+ * {@snippet lang=java :\n+ *     Callable<String> task1 = ...\n+ *     Callable<Integer> task1 = ...\n+ *\n+ *     try (var scope = new StructuredTaskScope<Object>()) {\n+ *\n+ *         Subtask<String> subtask1 = scope.fork(task1);   \/\/ @highlight substring=\"fork\"\n+ *         Subtask<Integer> subtask2 = scope.fork(task2);  \/\/ @highlight substring=\"fork\"\n+ *\n+ *         scope.join();                                   \/\/ @highlight substring=\"join\"\n+ *\n+ *         ... process results\/exceptions ...\n+ *\n+ *     } \/\/ close                                          \/\/ @highlight substring=\"close\"\n+ * }\n+ * <p> The following example forks a collection of homogeneous subtasks, waits for all of\n+ * them to complete with the {@code join} method, and uses the {@link Subtask.State\n+ * Subtask.State} to partition the subtasks into a set of the subtasks that completed\n+ * successfully and another for the subtasks that failed.\n+ * {@snippet lang=java :\n+ *     List<Callable<String>> callables = ...\n+ *\n+ *     try (var scope = new StructuredTaskScope<String>()) {\n+ *\n+ *         List<Subtask<String>> subtasks = callables.stream().map(scope::fork).toList();\n+ *\n+ *         scope.join();\n+ *\n+ *         Map<Boolean, Set<Subtask<String>>> map = subtasks.stream()\n+ *                 .collect(Collectors.partitioningBy(h -> h.state() == Subtask.State.SUCCESS,\n+ *                                                    Collectors.toSet()));\n+ *\n+ *     } \/\/ close\n+ * }\n+ *\n+ * <p> To ensure correct usage, the {@code join} and {@code close} methods may only be\n+ * invoked by the <em>owner<\/em> (the thread that opened\/created the task scope), and the\n+ * {@code close} method throws an exception after closing if the owner did not invoke the\n+ * {@code join} method after forking.\n+ *\n+ * <p> {@code StructuredTaskScope} defines the {@link #shutdown() shutdown} method to shut\n+ * down a task scope without closing it. The {@code shutdown()} method <em>cancels<\/em> all\n+ * unfinished subtasks by {@linkplain Thread#interrupt() interrupting} the threads. It\n+ * prevents new threads from starting in the task scope. If the owner is waiting in the\n+ * {@code join} method then it will wakeup.\n+ *\n+ * <p> Shutdown is used for <em>short-circuiting<\/em> and allow subclasses to implement\n+ * <em>policy<\/em> that does not require all subtasks to finish.\n+ *\n+ * <h2>Subclasses with policies for common cases<\/h2>\n+ *\n+ * Two subclasses of {@code StructuredTaskScope} are defined to implement policy for\n+ * common cases:\n+ * <ol>\n+ *   <li> {@link ShutdownOnSuccess ShutdownOnSuccess} captures the result of the first\n+ *   subtask to complete successfully. Once captured, it shuts down the task scope to\n+ *   interrupt unfinished threads and wakeup the owner. This class is intended for cases\n+ *   where the result of any subtask will do (\"invoke any\") and where there is no need to\n+ *   wait for results of other unfinished subtasks. It defines methods to get the first\n+ *   result or throw an exception if all subtasks fail.\n+ *   <li> {@link ShutdownOnFailure ShutdownOnFailure} captures the exception of the first\n+ *   subtask to fail. Once captured, it shuts down the task scope to interrupt unfinished\n+ *   threads and wakeup the owner. This class is intended for cases where the results of all\n+ *   subtasks are required (\"invoke all\"); if any subtask fails then the results of other\n+ *   unfinished subtasks are no longer needed. If defines methods to throw an exception if\n+ *   any of the subtasks fail.\n+ * <\/ol>\n+ *\n+ * <p> The following are two examples that use the two classes. In both cases, a pair of\n+ * subtasks are forked to fetch resources from two URL locations \"left\" and \"right\". The\n+ * first example creates a ShutdownOnSuccess object to capture the result of the first\n+ * subtask to complete successfully, cancelling the other by way of shutting down the task\n+ * scope. The main task waits in {@code join} until either subtask completes with a result\n+ * or both subtasks fail. It invokes {@link ShutdownOnSuccess#result(Function)\n+ * result(Function)} method to get the captured result. If both subtasks fail then this\n+ * method throws a {@code WebApplicationException} with the exception from one of the\n+ * subtasks as the cause.\n+ * {@snippet lang=java :\n+ *     try (var scope = new StructuredTaskScope.ShutdownOnSuccess<String>()) {\n+ *\n+ *         scope.fork(() -> fetch(left));\n+ *         scope.fork(() -> fetch(right));\n+ *\n+ *         scope.join();\n+ *\n+ *         \/\/ @link regex=\"result(?=\\()\" target=\"ShutdownOnSuccess#result\" :\n+ *         String result = scope.result(e -> new WebApplicationException(e));\n+ *\n+ *         ...\n+ *     }\n+ * }\n+ * The second example creates a ShutdownOnFailure object to capture the exception of the\n+ * first subtask to fail, cancelling the other by way of shutting down the task scope. The\n+ * main task waits in {@link #joinUntil(Instant)} until both subtasks complete with a\n+ * result, either fails, or a deadline is reached. It invokes {@link\n+ * ShutdownOnFailure#throwIfFailed(Function) throwIfFailed(Function)} to throw an exception\n+ * if either subtask fails. This method is a no-op if both subtasks complete successfully.\n+ * The example uses {@link Supplier#get()} to get the result of each subtask. Using\n+ * {@code Supplier} instead of {@code Subtask} is preferred for common cases where the\n+ * object returned by fork is only used to get the result of a subtask that completed\n+ * successfully.\n+ * {@snippet lang=java :\n+ *    Instant deadline = ...\n+ *\n+ *    try (var scope = new StructuredTaskScope.ShutdownOnFailure()) {\n+ *\n+ *         Supplier<String> supplier1 = scope.fork(() -> query(left));\n+ *         Supplier<String> supplier2 = scope.fork(() -> query(right));\n+ *\n+ *         scope.joinUntil(deadline);\n+ *\n+ *         \/\/ @link substring=\"throwIfFailed\" target=\"ShutdownOnFailure#throwIfFailed\" :\n+ *         scope.throwIfFailed(e -> new WebApplicationException(e));\n+ *\n+ *         \/\/ both subtasks completed successfully\n+ *         String result = Stream.of(supplier1, supplier2)\n+ *                 .map(Supplier::get)\n+ *                 .collect(Collectors.joining(\", \", \"{ \", \" }\"));\n+ *\n+ *         ...\n+ *     }\n+ * }\n+ *\n+ * <h2>Extending StructuredTaskScope<\/h2>\n+ *\n+ * {@code StructuredTaskScope} can be extended, and the {@link #handleComplete(Subtask)\n+ * handleComplete} method overridden, to implement policies other than those implemented\n+ * by {@code ShutdownOnSuccess} and {@code ShutdownOnFailure}. A subclass may, for example,\n+ * collect the results of subtasks that complete successfully and ignore subtasks that\n+ * fail. It may collect exceptions when subtasks fail. It may invoke the {@link #shutdown()\n+ * shutdown} method to shut down and cause {@link #join() join} to wakeup when some\n+ * condition arises.\n+ *\n+ * <p> A subclass will typically define methods to make available results, state, or other\n+ * outcome to code that executes after the {@code join} method. A subclass that collects\n+ * results and ignores subtasks that fail may define a method that returns the results.\n+ * A subclass that implements a policy to shut down when a subtask fails may define a\n+ * method to get the exception of the first subtask to fail.\n+ *\n+ * <p> The following is an example of a simple {@code StructuredTaskScope} implementation\n+ * that collects homogenous subtasks that complete successfully. It defines the method\n+ * \"{@code completedSuccessfully()}\" that the main task can invoke after it joins.\n+ * {@snippet lang=java :\n+ *     class CollectingScope<T> extends StructuredTaskScope<T> {\n+ *         private final Queue<Subtask<? extends T>> subtasks = new LinkedTransferQueue<>();\n+ *\n+ *         @Override\n+ *         protected void handleComplete(Subtask<? extends T> subtask) {\n+ *             if (subtask.state() == Subtask.State.SUCCESS) {\n+ *                 subtasks.add(subtask);\n+ *             }\n+ *         }\n+ *\n+ *         @Override\n+ *         public CollectingScope<T> join() throws InterruptedException {\n+ *             super.join();\n+ *             return this;\n+ *         }\n+ *\n+ *         public Stream<Subtask<? extends T>> completedSuccessfully() {\n+ *             \/\/ @link substring=\"ensureOwnerAndJoined\" target=\"ensureOwnerAndJoined\" :\n+ *             super.ensureOwnerAndJoined();\n+ *             return subtasks.stream();\n+ *         }\n+ *     }\n+ * }\n+ * <p> The implementations of the {@code completedSuccessfully()} method in the example\n+ * invokes {@link #ensureOwnerAndJoined()} to ensure that the method can only be invoked\n+ * by the owner thread and only after it has joined.\n+ *\n+ * <h2><a id=\"TreeStructure\">Tree structure<\/a><\/h2>\n+ *\n+ * Task scopes form a tree where parent-child relations are established implicitly when\n+ * opening a new task scope:\n+ * <ul>\n+ *   <li> A parent-child relation is established when a thread started in a task scope\n+ *   opens its own task scope. A thread started in task scope \"A\" that opens task scope\n+ *   \"B\" establishes a parent-child relation where task scope \"A\" is the parent of task\n+ *   scope \"B\".\n+ *   <li> A parent-child relation is established with nesting. If a thread opens task\n+ *   scope \"B\", then opens task scope \"C\" (before it closes \"B\"), then the enclosing task\n+ *   scope \"B\" is the parent of the nested task scope \"C\".\n+ * <\/ul>\n+ *\n+ * The <i>descendants<\/i> of a task scope are the child task scopes that it is a parent\n+ * of, plus the descendants of the child task scopes, recursively.\n+ *\n+ * <p> The tree structure supports:\n+ * <ul>\n+ *   <li> Inheritance of {@linkplain ScopedValue scoped values} across threads.\n+ *   <li> Confinement checks. The phrase \"threads contained in the task scope\" in method\n+ *   descriptions means threads started in the task scope or descendant scopes.\n+ * <\/ul>\n+ *\n+ * <p> The following example demonstrates the inheritance of a scoped value. A scoped\n+ * value {@code USERNAME} is bound to the value \"{@code duke}\". A {@code StructuredTaskScope}\n+ * is created and its {@code fork} method invoked to start a thread to execute {@code\n+ * childTask}. The thread inherits the scoped value <em>bindings<\/em> captured when\n+ * creating the task scope. The code in {@code childTask} uses the value of the scoped\n+ * value and so reads the value \"{@code duke}\".\n+ * {@snippet lang=java :\n+ *     private static final ScopedValue<String> USERNAME = ScopedValue.newInstance();\n+ *\n+ *     \/\/ @link substring=\"runWhere\" target=\"ScopedValue#runWhere(ScopedValue, Object, Runnable)\" :\n+ *     ScopedValue.runWhere(USERNAME, \"duke\", () -> {\n+ *         try (var scope = new StructuredTaskScope<String>()) {\n+ *\n+ *             scope.fork(() -> childTask());           \/\/ @highlight substring=\"fork\"\n+ *             ...\n+ *          }\n+ *     });\n+ *\n+ *     ...\n+ *\n+ *     String childTask() {\n+ *         \/\/ @link substring=\"get\" target=\"ScopedValue#get()\" :\n+ *         String name = USERNAME.get();   \/\/ \"duke\"\n+ *         ...\n+ *     }\n+ * }\n+ *\n+ * <p> {@code StructuredTaskScope} does not define APIs that exposes the tree structure\n+ * at this time.\n+ *\n+ * <p> Unless otherwise specified, passing a {@code null} argument to a constructor\n+ * or method in this class will cause a {@link NullPointerException} to be thrown.\n+ *\n+ * <h2>Memory consistency effects<\/h2>\n+ *\n+ * <p> Actions in the owner thread of, or a thread contained in, the task scope prior to\n+ * {@linkplain #fork forking} of a subtask\n+ * <a href=\"{@docRoot}\/java.base\/java\/util\/concurrent\/package-summary.html#MemoryVisibility\">\n+ * <i>happen-before<\/i><\/a> any actions taken by that subtask, which in turn <i>happen-before<\/i>\n+ * the subtask result is {@linkplain Subtask#get() retrieved} or <i>happen-before<\/i> any\n+ * actions taken in a thread after {@linkplain #join() joining} of the task scope.\n+ *\n+ * @jls 17.4.5 Happens-before Order\n+ *\n+ * @param <T> the result type of tasks executed in the task scope\n+ * @since 21\n+ *\/\n+@PreviewFeature(feature = PreviewFeature.Feature.STRUCTURED_CONCURRENCY)\n+public class StructuredTaskScope<T> implements AutoCloseable {\n+    private final ThreadFactory factory;\n+    private final ThreadFlock flock;\n+    private final ReentrantLock shutdownLock = new ReentrantLock();\n+\n+    \/\/ states: OPEN -> SHUTDOWN -> CLOSED\n+    private static final int OPEN     = 0;   \/\/ initial state\n+    private static final int SHUTDOWN = 1;\n+    private static final int CLOSED   = 2;\n+\n+    \/\/ state: set to SHUTDOWN by any thread, set to CLOSED by owner, read by any thread\n+    private volatile int state;\n+\n+    \/\/ Counters to support checking that the task scope owner joins before processing\n+    \/\/ results and attempts join before closing the task scope. These counters are\n+    \/\/ accessed only by the owner thread.\n+    private int forkRound;         \/\/ incremented when the first subtask is forked after join\n+    private int lastJoinAttempted; \/\/ set to the current fork round when join is attempted\n+    private int lastJoinCompleted; \/\/ set to the current fork round when join completes\n+\n+    \/**\n+     * Represents a subtask forked with {@link #fork(Callable)}.\n+     * @param <T> the result type\n+     * @since 21\n+     *\/\n+    @PreviewFeature(feature = PreviewFeature.Feature.STRUCTURED_CONCURRENCY)\n+    public sealed interface Subtask<T> extends Supplier<T> permits SubtaskImpl {\n+        \/**\n+         * {@return the value returning task provided to the {@code fork} method}\n+         *\n+         * @apiNote Task objects with unique identity may be used for correlation by\n+         * implementations of {@link #handleComplete(Subtask) handleComplete}.\n+         *\/\n+        Callable<? extends T> task();\n+\n+        \/**\n+         * Represents the state of a subtask.\n+         * @see Subtask#state()\n+         * @since 21\n+         *\/\n+        @PreviewFeature(feature = PreviewFeature.Feature.STRUCTURED_CONCURRENCY)\n+        enum State {\n+            \/**\n+             * The subtask result or exception is not available. This state indicates that\n+             * the subtask was forked but has not completed, it completed after the task\n+             * scope was {@linkplain #shutdown() shut down}, or it was forked after the\n+             * task scope was shut down.\n+             *\/\n+            UNAVAILABLE,\n+            \/**\n+             * The subtask completed successfully with a result. The {@link Subtask#get()\n+             * Subtask.get()} method can be used to obtain the result. This is a terminal\n+             * state.\n+             *\/\n+            SUCCESS,\n+            \/**\n+             * The subtask failed with an exception. The {@link Subtask#exception()\n+             * Subtask.exception()} method can be used to obtain the exception. This is a\n+             * terminal state.\n+             *\/\n+            FAILED,\n+        }\n+\n+        \/**\n+         * {@return the state of the subtask}\n+         *\/\n+        State state();\n+\n+        \/**\n+         * Returns the result of the subtask.\n+         *\n+         * <p> To ensure correct usage, if the scope owner {@linkplain #fork(Callable) forks}\n+         * a subtask, then it must join (with {@link #join() join} or {@link #joinUntil(Instant)\n+         * joinUntil}) before it can obtain the result of the subtask.\n+         *\n+         * @return the possibly-null result\n+         * @throws IllegalStateException if the subtask has not completed, did not complete\n+         * successfully, or the current thread is the task scope owner and did not join\n+         * after forking\n+         * @see State#SUCCESS\n+         *\/\n+        T get();\n+\n+        \/**\n+         * {@return the exception thrown by the subtask}\n+         *\n+         * <p> To ensure correct usage, if the scope owner {@linkplain #fork(Callable) forks}\n+         * a subtask, then it must join (with {@link #join() join} or {@link #joinUntil(Instant)\n+         * joinUntil}) before it can obtain the exception thrown by the subtask.\n+         *\n+         * @throws IllegalStateException if the subtask has not completed, completed with\n+         * a result, or the current thread is the task scope owner and did not join after\n+         * forking\n+         * @see State#FAILED\n+         *\/\n+        Throwable exception();\n+    }\n+\n+    \/**\n+     * Creates a structured task scope with the given name and thread factory. The task\n+     * scope is optionally named for the purposes of monitoring and management. The thread\n+     * factory is used to {@link ThreadFactory#newThread(Runnable) create} threads when\n+     * subtasks are {@linkplain #fork(Callable) forked}. The task scope is owned by the\n+     * current thread.\n+     *\n+     * <p> Construction captures the current thread's {@linkplain ScopedValue scoped value}\n+     * bindings for inheritance by threads started in the task scope. The\n+     * <a href=\"#TreeStructure\">Tree Structure<\/a> section in the class description details\n+     * how parent-child relations are established implicitly for the purpose of inheritance\n+     * of scoped value bindings.\n+     *\n+     * @param name the name of the task scope, can be null\n+     * @param factory the thread factory\n+     *\/\n+    public StructuredTaskScope(String name, ThreadFactory factory) {\n+        this.factory = Objects.requireNonNull(factory, \"'factory' is null\");\n+        if (name == null)\n+            name = Objects.toIdentityString(this);\n+        this.flock = ThreadFlock.open(name);\n+    }\n+\n+    \/**\n+     * Creates an unnamed structured task scope that creates virtual threads. The task\n+     * scope is owned by the current thread.\n+     *\n+     * @implSpec This constructor is equivalent to invoking the 2-arg constructor with a\n+     * name of {@code null} and a thread factory that creates virtual threads.\n+     *\/\n+    public StructuredTaskScope() {\n+        this(null, Thread.ofVirtual().factory());\n+    }\n+\n+    private IllegalStateException newIllegalStateExceptionScopeClosed() {\n+        return new IllegalStateException(\"Task scope is closed\");\n+    }\n+\n+    private IllegalStateException newIllegalStateExceptionNoJoin() {\n+        return new IllegalStateException(\"Owner did not join after forking subtasks\");\n+    }\n+\n+    \/**\n+     * Throws IllegalStateException if the scope is closed, returning the state if not\n+     * closed.\n+     *\/\n+    private int ensureOpen() {\n+        int s = state;\n+        if (s == CLOSED)\n+            throw newIllegalStateExceptionScopeClosed();\n+        return s;\n+    }\n+\n+    \/**\n+     * Throws WrongThreadException if the current thread is not the owner.\n+     *\/\n+    private void ensureOwner() {\n+        if (Thread.currentThread() != flock.owner())\n+            throw new WrongThreadException(\"Current thread not owner\");\n+    }\n+\n+    \/**\n+     * Throws WrongThreadException if the current thread is not the owner\n+     * or a thread contained in the tree.\n+     *\/\n+    private void ensureOwnerOrContainsThread() {\n+        Thread currentThread = Thread.currentThread();\n+        if (currentThread != flock.owner() && !flock.containsThread(currentThread))\n+            throw new WrongThreadException(\"Current thread not owner or thread in the tree\");\n+    }\n+\n+    \/**\n+     * Throws IllegalStateException if the current thread is the owner, and the owner did\n+     * not join after forking a subtask in the given fork round.\n+     *\/\n+    private void ensureJoinedIfOwner(int round) {\n+        if (Thread.currentThread() == flock.owner() && (round > lastJoinCompleted)) {\n+            throw newIllegalStateExceptionNoJoin();\n+        }\n+    }\n+\n+    \/**\n+     * Ensures that the current thread is the owner of this task scope and that it joined\n+     * (with {@link #join()} or {@link #joinUntil(Instant)}) after {@linkplain #fork(Callable)\n+     * forking} subtasks.\n+     *\n+     * @apiNote This method can be used by subclasses that define methods to make available\n+     * results, state, or other outcome to code intended to execute after the join method.\n+     *\n+     * @throws WrongThreadException if the current thread is not the task scope owner\n+     * @throws IllegalStateException if the task scope is open and task scope owner did\n+     * not join after forking\n+     *\/\n+    protected final void ensureOwnerAndJoined() {\n+        ensureOwner();\n+        if (forkRound > lastJoinCompleted) {\n+            throw newIllegalStateExceptionNoJoin();\n+        }\n+    }\n+\n+    \/**\n+     * Invoked by a subtask when it completes successfully or fails in this task scope.\n+     * This method is not invoked if a subtask completes after the task scope is\n+     * {@linkplain #shutdown() shut down}.\n+     *\n+     * @implSpec The default implementation throws {@code NullPointerException} if the\n+     * subtask is {@code null}. It throws {@link IllegalArgumentException} if the subtask\n+     * has not completed.\n+     *\n+     * @apiNote The {@code handleComplete} method should be thread safe. It may be\n+     * invoked by several threads concurrently.\n+     *\n+     * @param subtask the subtask\n+     *\n+     * @throws IllegalArgumentException if called with a subtask that has not completed\n+     *\/\n+    protected void handleComplete(Subtask<? extends T> subtask) {\n+        if (subtask.state() == Subtask.State.UNAVAILABLE)\n+            throw new IllegalArgumentException();\n+    }\n+\n+    \/**\n+     * Starts a new thread in this task scope to execute a value-returning task, thus\n+     * creating a <em>subtask<\/em> of this task scope.\n+     *\n+     * <p> The value-returning task is provided to this method as a {@link Callable}, the\n+     * thread executes the task's {@link Callable#call() call} method. The thread is\n+     * created with the task scope's {@link ThreadFactory}. It inherits the current thread's\n+     * {@linkplain ScopedValue scoped value} bindings. The bindings must match the bindings\n+     * captured when the task scope was created.\n+     *\n+     * <p> This method returns a {@link Subtask Subtask} to represent the <em>forked\n+     * subtask<\/em>. The {@code Subtask} object can be used to obtain the result when\n+     * the subtask completes successfully, or the exception when the subtask fails. To\n+     * ensure correct usage, the {@link Subtask#get() get()} and {@link Subtask#exception()\n+     * exception()} methods may only be called by the task scope owner after it has waited\n+     * for all threads to finish with the {@link #join() join} or {@link #joinUntil(Instant)}\n+     * methods. When the subtask completes, the thread invokes the {@link\n+     * #handleComplete(Subtask) handleComplete} method to consume the completed subtask.\n+     * If the task scope is {@linkplain #shutdown() shut down} before the subtask completes\n+     * then the {@code handleComplete} method will not be invoked.\n+     *\n+     * <p> If this task scope is {@linkplain #shutdown() shutdown} (or in the process of\n+     * shutting down) then the subtask will not run and the {@code handleComplete} method\n+     * will not be invoked.\n+     *\n+     * <p> This method may only be invoked by the task scope owner or threads contained\n+     * in the task scope.\n+     *\n+     * @implSpec This method may be overridden for customization purposes, wrapping tasks\n+     * for example. If overridden, the subclass must invoke {@code super.fork} to start a\n+     * new thread in this task scope.\n+     *\n+     * @param task the value-returning task for the thread to execute\n+     * @param <U> the result type\n+     * @return the subtask\n+     * @throws IllegalStateException if this task scope is closed\n+     * @throws WrongThreadException if the current thread is not the task scope owner or a\n+     * thread contained in the task scope\n+     * @throws StructureViolationException if the current scoped value bindings are not\n+     * the same as when the task scope was created\n+     * @throws RejectedExecutionException if the thread factory rejected creating a\n+     * thread to run the subtask\n+     *\/\n+    public <U extends T> Subtask<U> fork(Callable<? extends U> task) {\n+        Objects.requireNonNull(task, \"'task' is null\");\n+        int s = ensureOpen();   \/\/ throws ISE if closed\n+\n+        \/\/ when forked by the owner, the subtask is forked in the current or next round\n+        int round = -1;\n+        if (Thread.currentThread() == flock.owner()) {\n+            round = forkRound;\n+            if (forkRound == lastJoinCompleted) {\n+                \/\/ new round if first fork after join\n+                round++;\n+            }\n+        }\n+\n+        SubtaskImpl<U> subtask = new SubtaskImpl<>(this, task, round);\n+        boolean started = false;\n+\n+        if (s < SHUTDOWN) {\n+            \/\/ create thread to run task\n+            Thread thread = factory.newThread(subtask);\n+            if (thread == null) {\n+                throw new RejectedExecutionException(\"Rejected by thread factory\");\n+            }\n+\n+            \/\/ attempt to start the thread\n+            try {\n+                flock.start(thread);\n+                started = true;\n+            } catch (IllegalStateException e) {\n+                \/\/ shutdown by another thread, or underlying flock is shutdown due\n+                \/\/ to unstructured use\n+            }\n+        }\n+\n+        \/\/ force owner to join if thread started\n+        if (started && Thread.currentThread() == flock.owner() && round > forkRound) {\n+            forkRound = round;\n+        }\n+\n+        \/\/ return forked subtask or a subtask that did not run\n+        return subtask;\n+    }\n+\n+    \/**\n+     * Wait for all threads to finish or the task scope to shut down.\n+     *\/\n+    private void implJoin(Duration timeout)\n+        throws InterruptedException, TimeoutException\n+    {\n+        ensureOwner();\n+        lastJoinAttempted = forkRound;\n+        int s = ensureOpen();  \/\/ throws ISE if closed\n+        if (s == OPEN) {\n+            \/\/ wait for all threads, wakeup, interrupt, or timeout\n+            if (timeout != null) {\n+                flock.awaitAll(timeout);\n+            } else {\n+                flock.awaitAll();\n+            }\n+        }\n+        lastJoinCompleted = forkRound;\n+    }\n+\n+    \/**\n+     * Wait for all threads in this task scope to finish or the task scope to shut down.\n+     * This method waits until all threads started in this task scope finish execution,\n+     * the {@link #shutdown() shutdown} method is invoked to shut down the task scope,\n+     * or the current thread is {@linkplain Thread#interrupt() interrupted}.\n+     *\n+     * <p> This method may only be invoked by the task scope owner.\n+     *\n+     * @implSpec This method may be overridden for customization purposes or to return a\n+     * more specific return type. If overridden, the subclass must invoke {@code\n+     * super.join} to ensure that the method waits for threads in this task scope to\n+     * finish.\n+     *\n+     * @return this task scope\n+     * @throws IllegalStateException if this task scope is closed\n+     * @throws WrongThreadException if the current thread is not the task scope owner\n+     * @throws InterruptedException if interrupted while waiting\n+     *\/\n+    public StructuredTaskScope<T> join() throws InterruptedException {\n+        try {\n+            implJoin(null);\n+        } catch (TimeoutException e) {\n+            throw new InternalError();\n+        }\n+        return this;\n+    }\n+\n+    \/**\n+     * Wait for all threads in this task scope to finish or the task scope to shut down,\n+     * up to the given deadline. This method waits until all threads started in the task\n+     * scope finish execution, the {@link #shutdown() shutdown} method is invoked to\n+     * shut down the task scope, the current thread is {@linkplain Thread#interrupt()\n+     * interrupted}, or the deadline is reached.\n+     *\n+     * <p> This method may only be invoked by the task scope owner.\n+     *\n+     * @implSpec This method may be overridden for customization purposes or to return a\n+     * more specific return type. If overridden, the subclass must invoke {@code\n+     * super.joinUntil} to ensure that the method waits for threads in this task scope to\n+     * finish.\n+     *\n+     * @param deadline the deadline\n+     * @return this task scope\n+     * @throws IllegalStateException if this task scope is closed\n+     * @throws WrongThreadException if the current thread is not the task scope owner\n+     * @throws InterruptedException if interrupted while waiting\n+     * @throws TimeoutException if the deadline is reached while waiting\n+     *\/\n+    public StructuredTaskScope<T> joinUntil(Instant deadline)\n+        throws InterruptedException, TimeoutException\n+    {\n+        Duration timeout = Duration.between(Instant.now(), deadline);\n+        implJoin(timeout);\n+        return this;\n+    }\n+\n+    \/**\n+     * Interrupt all unfinished threads.\n+     *\/\n+    private void implInterruptAll() {\n+        flock.threads()\n+            .filter(t -> t != Thread.currentThread())\n+            .forEach(t -> {\n+                try {\n+                    t.interrupt();\n+                } catch (Throwable ignore) { }\n+            });\n+    }\n+\n+    @SuppressWarnings(\"removal\")\n+    private void interruptAll() {\n+        if (System.getSecurityManager() == null) {\n+            implInterruptAll();\n+        } else {\n+            PrivilegedAction<Void> pa = () -> {\n+                implInterruptAll();\n+                return null;\n+            };\n+            AccessController.doPrivileged(pa);\n+        }\n+    }\n+\n+    \/**\n+     * Shutdown the task scope if not already shutdown. Return true if this method\n+     * shutdowns the task scope, false if already shutdown.\n+     *\/\n+    private boolean implShutdown() {\n+        shutdownLock.lock();\n+        try {\n+            if (state < SHUTDOWN) {\n+                \/\/ prevent new threads from starting\n+                flock.shutdown();\n+\n+                \/\/ set status before interrupting tasks\n+                state = SHUTDOWN;\n+\n+                \/\/ interrupt all unfinished threads\n+                interruptAll();\n+\n+                return true;\n+            } else {\n+                \/\/ already shutdown\n+                return false;\n+            }\n+        } finally {\n+            shutdownLock.unlock();\n+        }\n+    }\n+\n+    \/**\n+     * Shut down this task scope without closing it. Shutting down a task scope prevents\n+     * new threads from starting, interrupts all unfinished threads, and causes the\n+     * {@link #join() join} method to wakeup. Shutdown is useful for cases where the\n+     * results of unfinished subtasks are no longer needed. It will typically be called\n+     * by the {@link #handleComplete(Subtask)} implementation of a subclass that\n+     * implements a policy to discard unfinished tasks once some outcome is reached.\n+     *\n+     * <p> More specifically, this method:\n+     * <ul>\n+     * <li> {@linkplain Thread#interrupt() Interrupts} all unfinished threads in the\n+     * task scope (except the current thread).\n+     * <li> Wakes up the task scope owner if it is waiting in {@link #join()} or {@link\n+     * #joinUntil(Instant)}. If the task scope owner is not waiting then its next call to\n+     * {@code join} or {@code joinUntil} will return immediately.\n+     * <\/ul>\n+     *\n+     * <p> This method may only be invoked by the task scope owner or threads contained\n+     * in the task scope.\n+     *\n+     * @implSpec This method may be overridden for customization purposes. If overridden,\n+     * the subclass must invoke {@code super.shutdown} to ensure that the method shuts\n+     * down the task scope.\n+     *\n+     * @apiNote\n+     * There may be threads that have not finished because they are executing code that\n+     * did not respond (or respond promptly) to thread interrupt. This method does not wait\n+     * for these threads. When the owner invokes the {@link #close() close} method\n+     * to close the task scope then it will wait for the remaining threads to finish.\n+     *\n+     * @throws IllegalStateException if this task scope is closed\n+     * @throws WrongThreadException if the current thread is not the task scope owner or\n+     * a thread contained in the task scope\n+     * @see #isShutdown()\n+     *\/\n+    public void shutdown() {\n+        ensureOwnerOrContainsThread();\n+        int s = ensureOpen();  \/\/ throws ISE if closed\n+        if (s < SHUTDOWN && implShutdown())\n+            flock.wakeup();\n+    }\n+\n+    \/**\n+     * {@return true if this task scope is shutdown, otherwise false}\n+     * @see #shutdown()\n+     *\/\n+    public final boolean isShutdown() {\n+        return state >= SHUTDOWN;\n+    }\n+\n+    \/**\n+     * Closes this task scope.\n+     *\n+     * <p> This method first shuts down the task scope (as if by invoking the {@link\n+     * #shutdown() shutdown} method). It then waits for the threads executing any\n+     * unfinished tasks to finish. If interrupted, this method will continue to wait for\n+     * the threads to finish before completing with the interrupt status set.\n+     *\n+     * <p> This method may only be invoked by the task scope owner. If the task scope\n+     * is already closed then the task scope owner invoking this method has no effect.\n+     *\n+     * <p> A {@code StructuredTaskScope} is intended to be used in a <em>structured\n+     * manner<\/em>. If this method is called to close a task scope before nested task\n+     * scopes are closed then it closes the underlying construct of each nested task scope\n+     * (in the reverse order that they were created in), closes this task scope, and then\n+     * throws {@link StructureViolationException}.\n+     * Similarly, if this method is called to close a task scope while executing with\n+     * {@linkplain ScopedValue scoped value} bindings, and the task scope was created\n+     * before the scoped values were bound, then {@code StructureViolationException} is\n+     * thrown after closing the task scope.\n+     * If a thread terminates without first closing task scopes that it owns then\n+     * termination will cause the underlying construct of each of its open tasks scopes to\n+     * be closed. Closing is performed in the reverse order that the task scopes were\n+     * created in. Thread termination may therefore be delayed when the task scope owner\n+     * has to wait for threads forked in these task scopes to finish.\n+     *\n+     * @implSpec This method may be overridden for customization purposes. If overridden,\n+     * the subclass must invoke {@code super.close} to close the task scope.\n+     *\n+     * @throws IllegalStateException thrown after closing the task scope if the task scope\n+     * owner did not attempt to join after forking\n+     * @throws WrongThreadException if the current thread is not the task scope owner\n+     * @throws StructureViolationException if a structure violation was detected\n+     *\/\n+    @Override\n+    public void close() {\n+        ensureOwner();\n+        int s = state;\n+        if (s == CLOSED)\n+            return;\n+\n+        try {\n+            if (s < SHUTDOWN)\n+                implShutdown();\n+            flock.close();\n+        } finally {\n+            state = CLOSED;\n+        }\n+\n+        \/\/ throw ISE if the owner didn't attempt to join after forking\n+        if (forkRound > lastJoinAttempted) {\n+            lastJoinCompleted = forkRound;\n+            throw newIllegalStateExceptionNoJoin();\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        String name = flock.name();\n+        return switch (state) {\n+            case OPEN     -> name;\n+            case SHUTDOWN -> name + \"\/shutdown\";\n+            case CLOSED   -> name + \"\/closed\";\n+            default -> throw new InternalError();\n+        };\n+    }\n+\n+    \/**\n+     * Subtask implementation, runs the task specified to the fork method.\n+     *\/\n+    private static final class SubtaskImpl<T> implements Subtask<T>, Runnable {\n+        private static final AltResult RESULT_NULL = new AltResult(Subtask.State.SUCCESS);\n+\n+        private record AltResult(Subtask.State state, Throwable exception) {\n+            AltResult(Subtask.State state) {\n+                this(state, null);\n+            }\n+        }\n+\n+        private final StructuredTaskScope<? super T> scope;\n+        private final Callable<? extends T> task;\n+        private final int round;\n+        private volatile Object result;\n+\n+        SubtaskImpl(StructuredTaskScope<? super T> scope,\n+                    Callable<? extends T> task,\n+                    int round) {\n+            this.scope = scope;\n+            this.task = task;\n+            this.round = round;\n+        }\n+\n+        @Override\n+        public void run() {\n+            T result = null;\n+            Throwable ex = null;\n+            try {\n+                result = task.call();\n+            } catch (Throwable e) {\n+                ex = e;\n+            }\n+\n+            \/\/ nothing to do if task scope is shutdown\n+            if (scope.isShutdown())\n+                return;\n+\n+            \/\/ capture result or exception, invoke handleComplete\n+            if (ex == null) {\n+                this.result = (result != null) ? result : RESULT_NULL;\n+            } else {\n+                this.result = new AltResult(State.FAILED, ex);\n+            }\n+            scope.handleComplete(this);\n+        }\n+\n+        @Override\n+        public Callable<? extends T> task() {\n+            return task;\n+        }\n+\n+        @Override\n+        public Subtask.State state() {\n+            Object result = this.result;\n+            if (result == null) {\n+                return State.UNAVAILABLE;\n+            } else if (result instanceof AltResult alt) {\n+                \/\/ null or failed\n+                return alt.state();\n+            } else {\n+                return State.SUCCESS;\n+            }\n+        }\n+\n+        @Override\n+        public T get() {\n+            scope.ensureJoinedIfOwner(round);\n+            Object result = this.result;\n+            if (result instanceof AltResult) {\n+                if (result == RESULT_NULL) return null;\n+            } else if (result != null) {\n+                @SuppressWarnings(\"unchecked\")\n+                T r = (T) result;\n+                return r;\n+            }\n+            throw new IllegalStateException(\"Subtask not completed or did not complete successfully\");\n+        }\n+\n+        @Override\n+        public Throwable exception() {\n+            scope.ensureJoinedIfOwner(round);\n+            Object result = this.result;\n+            if (result instanceof AltResult alt && alt.state() == State.FAILED) {\n+                return alt.exception();\n+            }\n+            throw new IllegalStateException(\"Subtask not completed or did not complete with exception\");\n+        }\n+\n+        @Override\n+        public String toString() {\n+            String stateAsString = switch (state()) {\n+                case UNAVAILABLE -> \"[Unavailable]\";\n+                case SUCCESS     -> \"[Completed successfully]\";\n+                case FAILED      -> {\n+                    Throwable ex = ((AltResult) result).exception();\n+                    yield \"[Failed: \" + ex + \"]\";\n+                }\n+            };\n+            return Objects.toIdentityString(this ) + stateAsString;\n+        }\n+    }\n+\n+    \/**\n+     * A {@code StructuredTaskScope} that captures the result of the first subtask to\n+     * complete {@linkplain Subtask.State#SUCCESS successfully}. Once captured, it\n+     * invokes the {@linkplain #shutdown() shutdown} method to interrupt unfinished threads\n+     * and wakeup the task scope owner. The policy implemented by this class is intended\n+     * for cases where the result of any subtask will do (\"invoke any\") and where the\n+     * results of other unfinished subtasks are no longer needed.\n+     *\n+     * <p> Unless otherwise specified, passing a {@code null} argument to a method\n+     * in this class will cause a {@link NullPointerException} to be thrown.\n+     *\n+     * @param <T> the result type\n+     * @since 21\n+     *\/\n+    @PreviewFeature(feature = PreviewFeature.Feature.STRUCTURED_CONCURRENCY)\n+    public static final class ShutdownOnSuccess<T> extends StructuredTaskScope<T> {\n+        private static final Object RESULT_NULL = new Object();\n+        private static final VarHandle FIRST_RESULT;\n+        private static final VarHandle FIRST_EXCEPTION;\n+        static {\n+            try {\n+                MethodHandles.Lookup l = MethodHandles.lookup();\n+                FIRST_RESULT = l.findVarHandle(ShutdownOnSuccess.class, \"firstResult\", Object.class);\n+                FIRST_EXCEPTION = l.findVarHandle(ShutdownOnSuccess.class, \"firstException\", Throwable.class);\n+            } catch (Exception e) {\n+                throw new ExceptionInInitializerError(e);\n+            }\n+        }\n+        private volatile Object firstResult;\n+        private volatile Throwable firstException;\n+\n+        \/**\n+         * Constructs a new {@code ShutdownOnSuccess} with the given name and thread factory.\n+         * The task scope is optionally named for the purposes of monitoring and management.\n+         * The thread factory is used to {@link ThreadFactory#newThread(Runnable) create}\n+         * threads when subtasks are {@linkplain #fork(Callable) forked}. The task scope\n+         * is owned by the current thread.\n+         *\n+         * <p> Construction captures the current thread's {@linkplain ScopedValue scoped\n+         * value} bindings for inheritance by threads started in the task scope. The\n+         * <a href=\"#TreeStructure\">Tree Structure<\/a> section in the class description\n+         * details how parent-child relations are established implicitly for the purpose\n+         * of inheritance of scoped value bindings.\n+         *\n+         * @param name the name of the task scope, can be null\n+         * @param factory the thread factory\n+         *\/\n+        public ShutdownOnSuccess(String name, ThreadFactory factory) {\n+            super(name, factory);\n+        }\n+\n+        \/**\n+         * Constructs a new unnamed {@code ShutdownOnSuccess} that creates virtual threads.\n+         *\n+         * @implSpec This constructor is equivalent to invoking the 2-arg constructor with\n+         * a name of {@code null} and a thread factory that creates virtual threads.\n+         *\/\n+        public ShutdownOnSuccess() {\n+            this(null, Thread.ofVirtual().factory());\n+        }\n+\n+        @Override\n+        protected void handleComplete(Subtask<? extends T> subtask) {\n+            super.handleComplete(subtask);\n+\n+            if (firstResult != null) {\n+                \/\/ already captured a result\n+                return;\n+            }\n+\n+            if (subtask.state() == Subtask.State.SUCCESS) {\n+                \/\/ task succeeded\n+                T result = subtask.get();\n+                Object r = (result != null) ? result : RESULT_NULL;\n+                if (FIRST_RESULT.compareAndSet(this, null, r)) {\n+                    super.shutdown();\n+                }\n+            } else if (firstException == null) {\n+                \/\/ capture the exception thrown by the first subtask that failed\n+                FIRST_EXCEPTION.compareAndSet(this, null, subtask.exception());\n+            }\n+        }\n+\n+        \/**\n+         * {@inheritDoc}\n+         * @return this task scope\n+         * @throws IllegalStateException {@inheritDoc}\n+         * @throws WrongThreadException {@inheritDoc}\n+         *\/\n+        @Override\n+        public ShutdownOnSuccess<T> join() throws InterruptedException {\n+            super.join();\n+            return this;\n+        }\n+\n+        \/**\n+         * {@inheritDoc}\n+         * @return this task scope\n+         * @throws IllegalStateException {@inheritDoc}\n+         * @throws WrongThreadException {@inheritDoc}\n+         *\/\n+        @Override\n+        public ShutdownOnSuccess<T> joinUntil(Instant deadline)\n+            throws InterruptedException, TimeoutException\n+        {\n+            super.joinUntil(deadline);\n+            return this;\n+        }\n+\n+        \/**\n+         * {@return the result of the first subtask that completed {@linkplain\n+         * Subtask.State#SUCCESS successfully}}\n+         *\n+         * <p> When no subtask completed successfully, but a subtask {@linkplain\n+         * Subtask.State#FAILED failed} then {@code ExecutionException} is thrown with\n+         * the subtask's exception as the {@linkplain Throwable#getCause() cause}.\n+         *\n+         * @throws ExecutionException if no subtasks completed successfully but at least\n+         * one subtask failed\n+         * @throws IllegalStateException if the handleComplete method was not invoked with\n+         * a completed subtask, or the task scope owner did not join after forking\n+         * @throws WrongThreadException if the current thread is not the task scope owner\n+         *\/\n+        public T result() throws ExecutionException {\n+            return result(ExecutionException::new);\n+        }\n+\n+        \/**\n+         * Returns the result of the first subtask that completed {@linkplain\n+         * Subtask.State#SUCCESS successfully}, otherwise throws an exception produced\n+         * by the given exception supplying function.\n+         *\n+         * <p> When no subtask completed successfully, but a subtask {@linkplain\n+         * Subtask.State#FAILED failed}, then the exception supplying function is invoked\n+         * with subtask's exception.\n+         *\n+         * @param esf the exception supplying function\n+         * @param <X> type of the exception to be thrown\n+         * @return the result of the first subtask that completed with a result\n+         *\n+         * @throws X if no subtasks completed successfully but at least one subtask failed\n+         * @throws IllegalStateException if the handleComplete method was not invoked with\n+         * a completed subtask, or the task scope owner did not join after forking\n+         * @throws WrongThreadException if the current thread is not the task scope owner\n+         *\/\n+        public <X extends Throwable> T result(Function<Throwable, ? extends X> esf) throws X {\n+            Objects.requireNonNull(esf);\n+            ensureOwnerAndJoined();\n+\n+            Object result = firstResult;\n+            if (result == RESULT_NULL) {\n+                return null;\n+            } else if (result != null) {\n+                @SuppressWarnings(\"unchecked\")\n+                T r = (T) result;\n+                return r;\n+            }\n+\n+            Throwable exception = firstException;\n+            if (exception != null) {\n+                X ex = esf.apply(exception);\n+                Objects.requireNonNull(ex, \"esf returned null\");\n+                throw ex;\n+            }\n+\n+            throw new IllegalStateException(\"No completed subtasks\");\n+        }\n+    }\n+\n+    \/**\n+     * A {@code StructuredTaskScope} that captures the exception of the first subtask to\n+     * {@linkplain Subtask.State#FAILED fail}. Once captured, it invokes the {@linkplain\n+     * #shutdown() shutdown} method to interrupt unfinished threads and wakeup the task\n+     * scope owner. The policy implemented by this class is intended for cases where the\n+     * results for all subtasks are required (\"invoke all\"); if any subtask fails then the\n+     * results of other unfinished subtasks are no longer needed.\n+     *\n+     * <p> Unless otherwise specified, passing a {@code null} argument to a method\n+     * in this class will cause a {@link NullPointerException} to be thrown.\n+     *\n+     * @since 21\n+     *\/\n+    @PreviewFeature(feature = PreviewFeature.Feature.STRUCTURED_CONCURRENCY)\n+    public static final class ShutdownOnFailure extends StructuredTaskScope<Object> {\n+        private static final VarHandle FIRST_EXCEPTION;\n+        static {\n+            try {\n+                MethodHandles.Lookup l = MethodHandles.lookup();\n+                FIRST_EXCEPTION = l.findVarHandle(ShutdownOnFailure.class, \"firstException\", Throwable.class);\n+            } catch (Exception e) {\n+                throw new ExceptionInInitializerError(e);\n+            }\n+        }\n+        private volatile Throwable firstException;\n+\n+        \/**\n+         * Constructs a new {@code ShutdownOnFailure} with the given name and thread factory.\n+         * The task scope is optionally named for the purposes of monitoring and management.\n+         * The thread factory is used to {@link ThreadFactory#newThread(Runnable) create}\n+         * threads when subtasks are {@linkplain #fork(Callable) forked}. The task scope\n+         * is owned by the current thread.\n+         *\n+         * <p> Construction captures the current thread's {@linkplain ScopedValue scoped\n+         * value} bindings for inheritance by threads started in the task scope. The\n+         * <a href=\"#TreeStructure\">Tree Structure<\/a> section in the class description\n+         * details how parent-child relations are established implicitly for the purpose\n+         * of inheritance of scoped value bindings.\n+         *\n+         * @param name the name of the task scope, can be null\n+         * @param factory the thread factory\n+         *\/\n+        public ShutdownOnFailure(String name, ThreadFactory factory) {\n+            super(name, factory);\n+        }\n+\n+        \/**\n+         * Constructs a new unnamed {@code ShutdownOnFailure} that creates virtual threads.\n+         *\n+         * @implSpec This constructor is equivalent to invoking the 2-arg constructor with\n+         * a name of {@code null} and a thread factory that creates virtual threads.\n+         *\/\n+        public ShutdownOnFailure() {\n+            this(null, Thread.ofVirtual().factory());\n+        }\n+\n+        @Override\n+        protected void handleComplete(Subtask<?> subtask) {\n+            super.handleComplete(subtask);\n+            if (subtask.state() == Subtask.State.FAILED\n+                    && firstException == null\n+                    && FIRST_EXCEPTION.compareAndSet(this, null, subtask.exception())) {\n+                super.shutdown();\n+            }\n+        }\n+\n+        \/**\n+         * {@inheritDoc}\n+         * @return this task scope\n+         * @throws IllegalStateException {@inheritDoc}\n+         * @throws WrongThreadException {@inheritDoc}\n+         *\/\n+        @Override\n+        public ShutdownOnFailure join() throws InterruptedException {\n+            super.join();\n+            return this;\n+        }\n+\n+        \/**\n+         * {@inheritDoc}\n+         * @return this task scope\n+         * @throws IllegalStateException {@inheritDoc}\n+         * @throws WrongThreadException {@inheritDoc}\n+         *\/\n+        @Override\n+        public ShutdownOnFailure joinUntil(Instant deadline)\n+            throws InterruptedException, TimeoutException\n+        {\n+            super.joinUntil(deadline);\n+            return this;\n+        }\n+\n+        \/**\n+         * Returns the exception of the first subtask that {@linkplain Subtask.State#FAILED\n+         * failed}. If no subtasks failed then an empty {@code Optional} is returned.\n+         *\n+         * @return the exception for the first subtask to fail or an empty optional if no\n+         * subtasks failed\n+         *\n+         * @throws WrongThreadException if the current thread is not the task scope owner\n+         * @throws IllegalStateException if the task scope owner did not join after forking\n+         *\/\n+        public Optional<Throwable> exception() {\n+            ensureOwnerAndJoined();\n+            return Optional.ofNullable(firstException);\n+        }\n+\n+        \/**\n+         * Throws if a subtask {@linkplain Subtask.State#FAILED failed}.\n+         * If any subtask failed with an exception then {@code ExecutionException} is\n+         * thrown with the exception of the first subtask to fail as the {@linkplain\n+         * Throwable#getCause() cause}. This method does nothing if no subtasks failed.\n+         *\n+         * @throws ExecutionException if a subtask failed\n+         * @throws WrongThreadException if the current thread is not the task scope owner\n+         * @throws IllegalStateException if the task scope owner did not join after forking\n+         *\/\n+        public void throwIfFailed() throws ExecutionException {\n+            throwIfFailed(ExecutionException::new);\n+        }\n+\n+        \/**\n+         * Throws the exception produced by the given exception supplying function if a\n+         * subtask {@linkplain Subtask.State#FAILED failed}. If any subtask failed with\n+         * an exception then the function is invoked with the exception of the first\n+         * subtask to fail. The exception returned by the function is thrown. This method\n+         * does nothing if no subtasks failed.\n+         *\n+         * @param esf the exception supplying function\n+         * @param <X> type of the exception to be thrown\n+         *\n+         * @throws X produced by the exception supplying function\n+         * @throws WrongThreadException if the current thread is not the task scope owner\n+         * @throws IllegalStateException if the task scope owner did not join after forking\n+         *\/\n+        public <X extends Throwable>\n+        void throwIfFailed(Function<Throwable, ? extends X> esf) throws X {\n+            ensureOwnerAndJoined();\n+            Objects.requireNonNull(esf);\n+            Throwable exception = firstException;\n+            if (exception != null) {\n+                X ex = esf.apply(exception);\n+                Objects.requireNonNull(ex, \"esf returned null\");\n+                throw ex;\n+            }\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/StructuredTaskScope.java","additions":1273,"deletions":0,"binary":false,"changes":1273,"status":"added"},{"patch":"@@ -57,1 +57,1 @@\n-            throw new InternalError(e);\n+            throw new ExceptionInInitializerError(e);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ThreadPerTaskExecutor.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -534,9 +534,0 @@\n-    \/**\n-     * Set the current thread's scoped value bindings.\n-     *\/\n-    void setScopedValueBindings(Object bindings);\n-\n-    Object findScopedValueBindings();\n-\n-    void ensureMaterializedForStackWalk(Object value);\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -75,0 +75,4 @@\n+        @JEP(number=446, title=\"Scoped Values\", status=\"Preview\")\n+        SCOPED_VALUES,\n+        @JEP(number=453, title=\"Structured Concurrency\", status=\"Preview\")\n+        STRUCTURED_CONCURRENCY,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/javac\/PreviewFeature.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,90 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.internal.misc;\n-\n-import java.lang.reflect.Constructor;\n-\n-\/**\n- * Defines static methods to allow code in java.base to create or throw\n- * StructureViolationException. This class will go away when the exception\n- * moves to java.base.\n- *\/\n-public class StructureViolationExceptions {\n-    private static final Constructor<?> SVE_CTOR = structureViolationExceptionCtor();\n-\n-    private StructureViolationExceptions() { }\n-\n-    \/**\n-     * Creates a StructureViolationException with the given message.\n-     *\/\n-    public static RuntimeException newException(String message) {\n-        if (SVE_CTOR != null) {\n-            try {\n-                return (RuntimeException) SVE_CTOR.newInstance(message);\n-            } catch (Exception e) {\n-                throw new InternalError(e);\n-            }\n-        } else {\n-            return new RuntimeException(\"Structure violation exception: \" + message);\n-        }\n-    }\n-\n-    \/**\n-     * Creates a StructureViolationException with no message.\n-     *\/\n-    public static RuntimeException newException() {\n-        return newException(null);\n-    }\n-\n-    \/**\n-     * Throws a StructureViolationException with the given message.\n-     *\/\n-    public static void throwException(String message) {\n-        throw newException(message);\n-    }\n-\n-    \/**\n-     * Throws a StructureViolationException with no message.\n-     *\/\n-    public static void throwException() {\n-        throw newException(null);\n-    }\n-\n-    \/**\n-     * Returns the StructureViolationException(String) constructor.\n-     *\/\n-    private static Constructor<?> structureViolationExceptionCtor() {\n-        Constructor<?> ctor;\n-        try {\n-            Class<?> exClass = Class.forName(\"jdk.incubator.concurrent.StructureViolationException\");\n-            ctor = exClass.getConstructor(String.class);\n-        } catch (ClassNotFoundException e) {\n-            ctor = null;\n-        } catch (Exception e) {\n-            throw new InternalError(e);\n-        }\n-        return ctor;\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/StructureViolationExceptions.java","additions":0,"deletions":90,"binary":false,"changes":90,"status":"deleted"},{"patch":"@@ -34,0 +34,1 @@\n+import java.util.concurrent.StructureViolationException;\n@@ -90,1 +91,0 @@\n-            Unsafe.getUnsafe().ensureClassInitialized(StructureViolationExceptions.class);\n@@ -265,2 +265,2 @@\n-     * @throws jdk.incubator.concurrent.StructureViolationException if the current\n-     * scoped value bindings are not the same as when the flock was created\n+     * @throws StructureViolationException if the current scoped value bindings are\n+     * not the same as when the flock was created\n@@ -408,2 +408,1 @@\n-     * @throws jdk.incubator.concurrent.StructureViolationException if a structure\n-     * violation was detected\n+     * @throws StructureViolationException if a structure violation was detected\n@@ -516,1 +515,1 @@\n-            \/\/ Virtual threads in the root containers are not tracked so need\n+            \/\/ Virtual threads in the root containers may not be tracked so need\n@@ -518,4 +517,6 @@\n-            Thread thread = Thread.currentThread();\n-            if (thread.isVirtual()\n-                    && JLA.threadContainer(thread) == ThreadContainers.root()) {\n-                this.key = ThreadContainers.registerContainer(this);\n+            if (!ThreadContainers.trackAllThreads()) {\n+                Thread thread = Thread.currentThread();\n+                if (thread.isVirtual()\n+                        && JLA.threadContainer(thread) == ThreadContainers.root()) {\n+                    this.key = ThreadContainers.registerContainer(this);\n+                }\n@@ -523,1 +524,0 @@\n-\n@@ -541,1 +541,1 @@\n-                    StructureViolationExceptions.throwException();\n+                    throw new StructureViolationException();\n@@ -566,0 +566,4 @@\n+        @Override\n+        public String name() {\n+            return flock.name();\n+        }\n@@ -583,4 +587,0 @@\n-        public String toString() {\n-            return flock.toString();\n-        }\n-        @Override\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/ThreadFlock.java","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.util.concurrent.StructureViolationException;\n@@ -30,1 +31,0 @@\n-import jdk.internal.misc.StructureViolationExceptions;\n@@ -32,2 +32,0 @@\n-import jdk.internal.vm.annotation.DontInline;\n-import jdk.internal.vm.annotation.ReservedStackAccess;\n@@ -45,1 +43,1 @@\n-        Unsafe.getUnsafe().ensureClassInitialized(StructureViolationExceptions.class);\n+        Unsafe.getUnsafe().ensureClassInitialized(StructureViolationException.class);\n@@ -146,1 +144,1 @@\n-    public static <V> V call(Callable<V> op) throws Exception {\n+    public static <V> V call(Callable<V> op) {\n@@ -205,1 +203,1 @@\n-                var sve = StructureViolationExceptions.newException();\n+                var sve = new StructureViolationException();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/ScopedValueContainer.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-import java.util.Objects;\n@@ -53,1 +52,1 @@\n-            throw new InternalError(e);\n+            throw new ExceptionInInitializerError(e);\n@@ -103,0 +102,5 @@\n+    @Override\n+    public String name() {\n+        return name;\n+    }\n+\n@@ -174,10 +178,0 @@\n-\n-    @Override\n-    public String toString() {\n-        String id = Objects.toIdentityString(this);\n-        if (name != null) {\n-            return name + \"\/\" + id;\n-        } else {\n-            return id;\n-        }\n-    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/SharedThreadContainer.java","additions":7,"deletions":13,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.util.Objects;\n@@ -44,0 +45,7 @@\n+    \/**\n+     * Return the name of this container, may be null.\n+     *\/\n+    public String name() {\n+        return null;\n+    }\n+\n@@ -97,0 +105,11 @@\n+\n+    @Override\n+    public String toString() {\n+        String name = name();\n+        if (name != null && name.indexOf('@') >= 0) {\n+            return name;\n+        } else {\n+            String id = Objects.toIdentityString(this);\n+            return (name != null) ? name + \"\/\" + id : id;\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/ThreadContainer.java","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -40,2 +40,1 @@\n- * This class consists exclusively of static methods to support debugging and\n- * monitoring of threads.\n+ * This class consists exclusively of static methods to support groupings of threads.\n@@ -46,0 +45,6 @@\n+    \/\/ true if all threads are tracked\n+    private static final boolean TRACK_ALL_THREADS;\n+\n+    \/\/ the root container\n+    private static final RootContainer ROOT_CONTAINER;\n+\n@@ -50,0 +55,11 @@\n+    static {\n+        String s = GetPropertyAction.privilegedGetProperty(\"jdk.trackAllThreads\");\n+        if (s != null && (s.isEmpty() || Boolean.parseBoolean(s))) {\n+            TRACK_ALL_THREADS = true;\n+            ROOT_CONTAINER = new RootContainer.TrackingRootContainer();\n+        } else {\n+            TRACK_ALL_THREADS = false;\n+            ROOT_CONTAINER = new RootContainer.CountingRootContainer();\n+        }\n+    }\n+\n@@ -62,0 +78,7 @@\n+    \/**\n+     * Returns true if all threads are tracked.\n+     *\/\n+    public static boolean trackAllThreads() {\n+        return TRACK_ALL_THREADS;\n+    }\n+\n@@ -86,1 +109,1 @@\n-        return RootContainer.INSTANCE;\n+        return ROOT_CONTAINER;\n@@ -191,9 +214,0 @@\n-        static final RootContainer INSTANCE;\n-        static {\n-            String s = GetPropertyAction.privilegedGetProperty(\"jdk.trackAllThreads\");\n-            if (s != null && (s.isEmpty() || Boolean.parseBoolean(s))) {\n-                INSTANCE = new TrackingRootContainer();\n-            } else {\n-                INSTANCE = new CountingRootContainer();\n-            }\n-        }\n@@ -208,1 +222,1 @@\n-        public String toString() {\n+        public String name() {\n@@ -215,0 +229,4 @@\n+        @Override\n+        public String toString() {\n+            return name();\n+        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/ThreadContainers.java","additions":31,"deletions":13,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -165,1 +165,0 @@\n-        jdk.incubator.concurrent,\n@@ -225,1 +224,0 @@\n-        jdk.incubator.concurrent,\n@@ -259,1 +257,0 @@\n-        jdk.incubator.concurrent,\n@@ -267,1 +264,0 @@\n-        jdk.incubator.concurrent,\n@@ -329,2 +325,1 @@\n-        jdk.crypto.ec,\n-        jdk.incubator.concurrent;\n+        jdk.crypto.ec;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1,838 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2020, 2022, Red Hat Inc.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.incubator.concurrent;\n-\n-import java.util.NoSuchElementException;\n-import java.util.Objects;\n-import java.lang.ref.Reference;\n-import java.util.concurrent.Callable;\n-import java.util.function.Supplier;\n-import jdk.internal.access.JavaLangAccess;\n-import jdk.internal.access.JavaUtilConcurrentTLRAccess;\n-import jdk.internal.access.SharedSecrets;\n-import jdk.internal.vm.annotation.ForceInline;\n-import jdk.internal.vm.annotation.Hidden;\n-import jdk.internal.vm.annotation.Stable;\n-import jdk.internal.vm.ScopedValueContainer;\n-import sun.security.action.GetPropertyAction;\n-\n-\/**\n- * A value that is set once and is then available for reading for a bounded period of\n- * execution by a thread. A {@code ScopedValue} allows for safely and efficiently sharing\n- * data for a bounded period of execution without passing the data as method arguments.\n- *\n- * <p> {@code ScopedValue} defines the {@link #where(ScopedValue, Object, Runnable)}\n- * method to set the value of a {@code ScopedValue} for the bouned period of execution by\n- * a thread of the runnable's {@link Runnable#run() run} method. The unfolding execution of\n- * the methods executed by {@code run} defines a <b><em>dynamic scope<\/em><\/b>. The scoped\n- * value is {@linkplain #isBound() bound} while executing in the dynamic scope, it reverts\n- * to being <em>unbound<\/em> when the {@code run} method completes (normally or with an\n- * exception). Code executing in the dynamic scope uses the {@code ScopedValue} {@link\n- * #get() get} method to read its value.\n- *\n- * <p> Like a {@linkplain ThreadLocal thread-local variable}, a scoped value has multiple\n- * incarnations, one per thread. The particular incarnation that is used depends on which\n- * thread calls its methods.\n- *\n- * <p> Consider the following example with a scoped value {@code USERNAME} that is\n- * <em>bound<\/em> to the value \"{@code duke}\" for the execution, by a thread, of a run\n- * method that invokes {@code doSomething()}.\n- * {@snippet lang=java :\n- *     \/\/ @link substring=\"newInstance\" target=\"#newInstance\" :\n- *     private static final ScopedValue<String> USERNAME = ScopedValue.newInstance();\n- *\n- *     ScopedValue.where(USERNAME, \"duke\", () -> doSomething());\n- * }\n- * Code executed directly or indirectly by {@code doSomething()} that invokes {@code\n- * USERNAME.get()} will read the value \"{@code duke}\". The scoped value is bound while\n- * executing {@code doSomething()} and becomes unbound when {@code doSomething()}\n- * completes (normally or with an exception). If one thread were to call {@code\n- * doSomething()} with {@code USERNAME} bound to \"{@code duke1}\", and another thread\n- * were to call the method with {@code USERNAME} bound to \"{@code duke2}\", then\n- * {@code USERNAME.get()} would read the value \"{@code duke1}\" or \"{@code duke2}\",\n- * depending on which thread is executing.\n- *\n- * <p> In addition to the {@code where} method that executes a {@code run} method, {@code\n- * ScopedValue} defines the {@link #where(ScopedValue, Object, Callable)} method to execute\n- * a method that returns a result. It also defines the {@link #where(ScopedValue, Object)}\n- * method for cases where it is useful to accumulate mappings of {@code ScopedValue} to\n- * value.\n- *\n- * <p> A {@code ScopedValue} will typically be declared in a {@code final} and {@code\n- * static} field. The accessibility of the field will determine which components can\n- * bind or read its value.\n- *\n- * <p> Unless otherwise specified, passing a {@code null} argument to a method in this\n- * class will cause a {@link NullPointerException} to be thrown.\n- *\n- * <h2><a id=\"rebind\">Rebinding<\/a><\/h2>\n- *\n- * The {@code ScopedValue} API allows a new binding to be established for <em>nested\n- * dynamic scopes<\/em>. This is known as <em>rebinding<\/em>. A {@code ScopedValue} that\n- * is bound to some value may be bound to a new value for the bounded execution of some\n- * method. The unfolding execution of code executed by that method defines the nested\n- * dynamic scope. When the method completes (normally or with an exception), the value of\n- * the {@code ScopedValue} reverts to its previous value.\n- *\n- * <p> In the above example, suppose that code executed by {@code doSomething()} binds\n- * {@code USERNAME} to a new value with:\n- * {@snippet lang=java :\n- *     ScopedValue.where(USERNAME, \"duchess\", () -> doMore());\n- * }\n- * Code executed directly or indirectly by {@code doMore()} that invokes {@code\n- * USERNAME.get()} will read the value \"{@code duchess}\". When {@code doMore()} completes\n- * (normally or with an exception), the value of {@code USERNAME} reverts to\n- * \"{@code duke}\".\n- *\n- * <h2><a id=\"inheritance\">Inheritance<\/a><\/h2>\n- *\n- * {@code ScopedValue} supports sharing data across threads. This sharing is limited to\n- * structured cases where child threads are started and terminate within the bounded\n- * period of execution by a parent thread. More specifically, when using a {@link\n- * StructuredTaskScope}, scoped value bindings are <em>captured<\/em> when creating a\n- * {@code StructuredTaskScope} and inherited by all threads started in that scope with\n- * the {@link StructuredTaskScope#fork(Callable) fork} method.\n- *\n- * <p> In the following example, the {@code ScopedValue} {@code USERNAME} is bound to the\n- * value \"{@code duke}\" for the execution of a runnable operation. The code in the {@code\n- * run} method creates a {@code StructuredTaskScope} and forks three child threads. Code\n- * executed directly or indirectly by these threads running {@code childTask1()},\n- * {@code childTask2()}, and {@code childTask3()} will read the value \"{@code duke}\".\n- *\n- * {@snippet lang=java :\n- *     private static final ScopedValue<String> USERNAME = ScopedValue.newInstance();\n-\n- *     ScopedValue.where(USERNAME, \"duke\", () -> {\n- *         try (var scope = new StructuredTaskScope<String>()) {\n- *\n- *             scope.fork(() -> childTask1());\n- *             scope.fork(() -> childTask2());\n- *             scope.fork(() -> childTask3());\n- *\n- *             ...\n- *          }\n- *     });\n- * }\n- *\n- * @implNote\n- * Scoped values are designed to be used in fairly small\n- * numbers. {@link #get} initially performs a search through enclosing\n- * scopes to find a scoped value's innermost binding. It\n- * then caches the result of the search in a small thread-local\n- * cache. Subsequent invocations of {@link #get} for that scoped value\n- * will almost always be very fast. However, if a program has many\n- * scoped values that it uses cyclically, the cache hit rate\n- * will be low and performance will be poor. This design allows\n- * scoped-value inheritance by {@link StructuredTaskScope} threads to\n- * be very fast: in essence, no more than copying a pointer, and\n- * leaving a scoped-value binding also requires little more than\n- * updating a pointer.\n- *\n- * <p>Because the scoped-value per-thread cache is small, clients\n- * should minimize the number of bound scoped values in use. For\n- * example, if it is necessary to pass a number of values in this way,\n- * it makes sense to create a record class to hold those values, and\n- * then bind a single {@code ScopedValue} to an instance of that record.\n- *\n- * <p>For this incubator release, the reference implementation\n- * provides some system properties to tune the performance of scoped\n- * values.\n- *\n- * <p>The system property {@code jdk.incubator.concurrent.ScopedValue.cacheSize}\n- * controls the size of the (per-thread) scoped-value cache. This cache is crucial\n- * for the performance of scoped values. If it is too small,\n- * the runtime library will repeatedly need to scan for each\n- * {@link #get}. If it is too large, memory will be unnecessarily\n- * consumed. The default scoped-value cache size is 16 entries. It may\n- * be varied from 2 to 16 entries in size. {@code ScopedValue.cacheSize}\n- * must be an integer power of 2.\n- *\n- * <p>For example, you could use {@code -Djdk.incubator.concurrent.ScopedValue.cacheSize=8}.\n- *\n- * <p>The other system property is {@code jdk.preserveScopedValueCache}.\n- * This property determines whether the per-thread scoped-value\n- * cache is preserved when a virtual thread is blocked. By default\n- * this property is set to {@code true}, meaning that every virtual\n- * thread preserves its scoped-value cache when blocked. Like {@code\n- * ScopedValue.cacheSize}, this is a space versus speed trade-off: in\n- * situations where many virtual threads are blocked most of the time,\n- * setting this property to {@code false} might result in a useful\n- * memory saving, but each virtual thread's scoped-value cache would\n- * have to be regenerated after a blocking operation.\n- *\n- * @param <T> the type of the object bound to this {@code ScopedValue}\n- * @since 20\n- *\/\n-public final class ScopedValue<T> {\n-    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n-\n-    private final @Stable int hash;\n-\n-    @Override\n-    public int hashCode() { return hash; }\n-\n-    \/**\n-     * An immutable map from {@code ScopedValue} to values.\n-     *\n-     * <p> Unless otherwise specified, passing a {@code null} argument to a constructor\n-     * or method in this class will cause a {@link NullPointerException} to be thrown.\n-     *\/\n-    static final class Snapshot {\n-        final Snapshot prev;\n-        final Carrier bindings;\n-        final int bitmask;\n-\n-        private static final Object NIL = new Object();\n-\n-        static final Snapshot EMPTY_SNAPSHOT = new Snapshot();\n-\n-        Snapshot(Carrier bindings, Snapshot prev) {\n-            this.prev = prev;\n-            this.bindings = bindings;\n-            this.bitmask = bindings.bitmask | prev.bitmask;\n-        }\n-\n-        protected Snapshot() {\n-            this.prev = null;\n-            this.bindings = null;\n-            this.bitmask = 0;\n-        }\n-\n-        Object find(ScopedValue<?> key) {\n-            int bits = key.bitmask();\n-            for (Snapshot snapshot = this;\n-                 containsAll(snapshot.bitmask, bits);\n-                 snapshot = snapshot.prev) {\n-                for (Carrier carrier = snapshot.bindings;\n-                     carrier != null && containsAll(carrier.bitmask, bits);\n-                     carrier = carrier.prev) {\n-                    if (carrier.getKey() == key) {\n-                        Object value = carrier.get();\n-                        return value;\n-                    }\n-                }\n-            }\n-            return NIL;\n-        }\n-    }\n-\n-    \/**\n-     * A mapping of scoped values, as <em>keys<\/em>, to values.\n-     *\n-     * <p> A {@code Carrier} is used to accumlate mappings so that an operation (a\n-     * {@link Runnable} or {@link Callable}) can be executed with all scoped values in the\n-     * mapping bound to values. The following example runs an operation with {@code k1}\n-     * bound (or rebound) to {@code v1}, and {@code k2} bound (or rebound) to {@code v2}.\n-     * {@snippet lang=java :\n-     *     \/\/ @link substring=\"where\" target=\"#where(ScopedValue, Object)\" :\n-     *     ScopedValue.where(k1, v1).where(k2, v2).run(() -> ... );\n-     * }\n-     *\n-     * <p> A {@code Carrier} is immutable and thread-safe. The {@link\n-     * #where(ScopedValue, Object) where} method returns a new {@code Carrier} object,\n-     * it does not mutate an existing mapping.\n-     *\n-     * <p> Unless otherwise specified, passing a {@code null} argument to a method in\n-     * this class will cause a {@link NullPointerException} to be thrown.\n-     *\n-     * @since 20\n-     *\/\n-    public static final class Carrier {\n-        \/\/ Bit masks: a 1 in postion n indicates that this set of bound values\n-        \/\/ hits that slot in the cache.\n-        final int bitmask;\n-        final ScopedValue<?> key;\n-        final Object value;\n-        final Carrier prev;\n-\n-        Carrier(ScopedValue<?> key, Object value, Carrier prev) {\n-            this.key = key;\n-            this.value = value;\n-            this.prev = prev;\n-            int bits = key.bitmask();\n-            if (prev != null) {\n-                bits |= prev.bitmask;\n-            }\n-            this.bitmask = bits;\n-        }\n-\n-        \/**\n-         * Add a binding to this map, returning a new Carrier instance.\n-         *\/\n-        private static final <T> Carrier where(ScopedValue<T> key, T value,\n-                                               Carrier prev) {\n-            return new Carrier(key, value, prev);\n-        }\n-\n-        \/**\n-         * Returns a new {@code Carrier} with the mappings from this carrier plus a\n-         * new mapping from {@code key} to {@code value}. If this carrier already has a\n-         * mapping for the scoped value {@code key} then it will map to the new\n-         * {@code value}. The current carrier is immutable, so it is not changed by this\n-         * method.\n-         *\n-         * @param key the {@code ScopedValue} key\n-         * @param value the value, can be {@code null}\n-         * @param <T> the type of the value\n-         * @return a new {@code Carrier} with the mappings from this carrier plus the new mapping\n-         *\/\n-        public <T> Carrier where(ScopedValue<T> key, T value) {\n-            return where(key, value, this);\n-        }\n-\n-        \/*\n-         * Return a new set consisting of a single binding.\n-         *\/\n-        static <T> Carrier of(ScopedValue<T> key, T value) {\n-            return where(key, value, null);\n-        }\n-\n-        final Object get() {\n-            return value;\n-        }\n-\n-        final ScopedValue<?> getKey() {\n-            return key;\n-        }\n-\n-        \/**\n-         * Returns the value of a {@link ScopedValue} in this mapping.\n-         *\n-         * @param key the {@code ScopedValue} key\n-         * @param <T> the type of the value\n-         * @return the value\n-         * @throws NoSuchElementException if the key is not present in this mapping\n-         *\/\n-        @SuppressWarnings(\"unchecked\")\n-        public <T> T get(ScopedValue<T> key) {\n-            var bits = key.bitmask();\n-            for (Carrier carrier = this;\n-                 carrier != null && containsAll(carrier.bitmask, bits);\n-                 carrier = carrier.prev) {\n-                if (carrier.getKey() == key) {\n-                    Object value = carrier.get();\n-                    return (T)value;\n-                }\n-            }\n-            throw new NoSuchElementException();\n-        }\n-\n-        \/**\n-         * Calls a value-returning operation with each scoped value in this mapping bound\n-         * to its value in the current thread.\n-         * When the operation completes (normally or with an exception), each scoped value\n-         * in the mapping will revert to being unbound, or revert to its previous value\n-         * when previously bound, in the current thread.\n-         *\n-         * <p> Scoped values are intended to be used in a <em>structured manner<\/em>.\n-         * If {@code op} creates a {@link StructuredTaskScope} but does not {@linkplain\n-         * StructuredTaskScope#close() close} it, then exiting {@code op} causes the\n-         * underlying construct of each {@code StructuredTaskScope} created in the\n-         * dynamic scope to be closed. This may require blocking until all child threads\n-         * have completed their sub-tasks. The closing is done in the reverse order that\n-         * they were created. Once closed, {@link StructureViolationException} is thrown.\n-         *\n-         * @param op the operation to run\n-         * @param <R> the type of the result of the operation\n-         * @return the result\n-         * @throws Exception if {@code op} completes with an exception\n-         * @see ScopedValue#where(ScopedValue, Object, Callable)\n-         *\/\n-        public <R> R call(Callable<? extends R> op) throws Exception {\n-            Objects.requireNonNull(op);\n-            Cache.invalidate(bitmask);\n-            var prevSnapshot = scopedValueBindings();\n-            var newSnapshot = new Snapshot(this, prevSnapshot);\n-            return runWith(newSnapshot, op);\n-        }\n-\n-        \/**\n-         * Execute the action with a set of ScopedValue bindings.\n-         *\n-         * The VM recognizes this method as special, so any changes to the\n-         * name or signature require corresponding changes in\n-         * JVM_FindScopedValueBindings().\n-         *\/\n-        @Hidden\n-        @ForceInline\n-        private <R> R runWith(Snapshot newSnapshot, Callable<R> op) throws Exception {\n-            try {\n-                JLA.setScopedValueBindings(newSnapshot);\n-                JLA.ensureMaterializedForStackWalk(newSnapshot);\n-                return ScopedValueContainer.call(op);\n-            } finally {\n-                Reference.reachabilityFence(newSnapshot);\n-                JLA.setScopedValueBindings(newSnapshot.prev);\n-                Cache.invalidate(bitmask);\n-            }\n-        }\n-\n-        \/**\n-         * Runs an operation with each scoped value in this mapping bound to its value\n-         * in the current thread.\n-         * When the operation completes (normally or with an exception), each scoped value\n-         * in the mapping will revert to being unbound, or revert to its previous value\n-         * when previously bound, in the current thread.\n-         *\n-         * <p> Scoped values are intended to be used in a <em>structured manner<\/em>.\n-         * If {@code op} creates a {@link StructuredTaskScope} but does not {@linkplain\n-         * StructuredTaskScope#close() close} it, then exiting {@code op} causes the\n-         * underlying construct of each {@code StructuredTaskScope} created in the\n-         * dynamic scope to be closed. This may require blocking until all child threads\n-         * have completed their sub-tasks. The closing is done in the reverse order that\n-         * they were created. Once closed, {@link StructureViolationException} is thrown.\n-         *\n-         * @param op the operation to run\n-         * @see ScopedValue#where(ScopedValue, Object, Runnable)\n-         *\/\n-        public void run(Runnable op) {\n-            Objects.requireNonNull(op);\n-            Cache.invalidate(bitmask);\n-            var prevSnapshot = scopedValueBindings();\n-            var newSnapshot = new Snapshot(this, prevSnapshot);\n-            runWith(newSnapshot, op);\n-        }\n-\n-        \/**\n-         * Execute the action with a set of {@code ScopedValue} bindings.\n-         *\n-         * The VM recognizes this method as special, so any changes to the\n-         * name or signature require corresponding changes in\n-         * JVM_FindScopedValueBindings().\n-         *\/\n-        @Hidden\n-        @ForceInline\n-        private void runWith(Snapshot newSnapshot, Runnable op) {\n-            try {\n-                JLA.setScopedValueBindings(newSnapshot);\n-                JLA.ensureMaterializedForStackWalk(newSnapshot);\n-                ScopedValueContainer.run(op);\n-            } finally {\n-                Reference.reachabilityFence(newSnapshot);\n-                JLA.setScopedValueBindings(newSnapshot.prev);\n-                Cache.invalidate(bitmask);\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Creates a new {@code Carrier} with a single mapping of a {@code ScopedValue}\n-     * <em>key<\/em> to a value. The {@code Carrier} can be used to accumlate mappings so\n-     * that an operation can be executed with all scoped values in the mapping bound to\n-     * values. The following example runs an operation with {@code k1} bound (or rebound)\n-     * to {@code v1}, and {@code k2} bound (or rebound) to {@code v2}.\n-     * {@snippet lang=java :\n-     *     \/\/ @link substring=\"run\" target=\"Carrier#run(Runnable)\" :\n-     *     ScopedValue.where(k1, v1).where(k2, v2).run(() -> ... );\n-     * }\n-     *\n-     * @param key the {@code ScopedValue} key\n-     * @param value the value, can be {@code null}\n-     * @param <T> the type of the value\n-     * @return a new {@code Carrier} with a single mapping\n-     *\/\n-    public static <T> Carrier where(ScopedValue<T> key, T value) {\n-        return Carrier.of(key, value);\n-    }\n-\n-    \/**\n-     * Calls a value-returning operation with a {@code ScopedValue} bound to a value\n-     * in the current thread. When the operation completes (normally or with an\n-     * exception), the {@code ScopedValue} will revert to being unbound, or revert to\n-     * its previous value when previously bound, in the current thread.\n-     *\n-     * <p> Scoped values are intended to be used in a <em>structured manner<\/em>.\n-     * If {@code op} creates a {@link StructuredTaskScope} but does not {@linkplain\n-     * StructuredTaskScope#close() close} it, then exiting {@code op} causes the\n-     * underlying construct of each {@code StructuredTaskScope} created in the\n-     * dynamic scope to be closed. This may require blocking until all child threads\n-     * have completed their sub-tasks. The closing is done in the reverse order that\n-     * they were created. Once closed, {@link StructureViolationException} is thrown.\n-     *\n-     * @implNote\n-     * This method is implemented to be equivalent to:\n-     * {@snippet lang=java :\n-     *     \/\/ @link substring=\"call\" target=\"Carrier#call(Callable)\" :\n-     *     ScopedValue.where(key, value).call(op);\n-     * }\n-     *\n-     * @param key the {@code ScopedValue} key\n-     * @param value the value, can be {@code null}\n-     * @param <T> the type of the value\n-     * @param <R> the result type\n-     * @param op the operation to call\n-     * @return the result\n-     * @throws Exception if the operation completes with an exception\n-     *\/\n-    public static <T, R> R where(ScopedValue<T> key,\n-                                 T value,\n-                                 Callable<? extends R> op) throws Exception {\n-        return where(key, value).call(op);\n-    }\n-\n-    \/**\n-     * Run an operation with a {@code ScopedValue} bound to a value in the current\n-     * thread. When the operation completes (normally or with an exception), the\n-     * {@code ScopedValue} will revert to being unbound, or revert to its previous value\n-     * when previously bound, in the current thread.\n-     *\n-     * <p> Scoped values are intended to be used in a <em>structured manner<\/em>.\n-     * If {@code op} creates a {@link StructuredTaskScope} but does not {@linkplain\n-     * StructuredTaskScope#close() close} it, then exiting {@code op} causes the\n-     * underlying construct of each {@code StructuredTaskScope} created in the\n-     * dynamic scope to be closed. This may require blocking until all child threads\n-     * have completed their sub-tasks. The closing is done in the reverse order that\n-     * they were created. Once closed, {@link StructureViolationException} is thrown.\n-     *\n-     * @implNote\n-     * This method is implemented to be equivalent to:\n-     * {@snippet lang=java :\n-     *     \/\/ @link substring=\"run\" target=\"Carrier#run(Runnable)\" :\n-     *     ScopedValue.where(key, value).run(op);\n-     * }\n-     *\n-     * @param key the {@code ScopedValue} key\n-     * @param value the value, can be {@code null}\n-     * @param <T> the type of the value\n-     * @param op the operation to call\n-     *\/\n-    public static <T> void where(ScopedValue<T> key, T value, Runnable op) {\n-        where(key, value).run(op);\n-    }\n-\n-    private ScopedValue() {\n-        this.hash = generateKey();\n-    }\n-\n-    \/**\n-     * Creates a scoped value that is initially unbound for all threads.\n-     *\n-     * @param <T> the type of the value\n-     * @return a new {@code ScopedValue}\n-     *\/\n-    public static <T> ScopedValue<T> newInstance() {\n-        return new ScopedValue<T>();\n-    }\n-\n-    \/**\n-     * {@return the value of the scoped value if bound in the current thread}\n-     *\n-     * @throws NoSuchElementException if the scoped value is not bound\n-     *\/\n-    @ForceInline\n-    @SuppressWarnings(\"unchecked\")\n-    public T get() {\n-        Object[] objects;\n-        if ((objects = scopedValueCache()) != null) {\n-            \/\/ This code should perhaps be in class Cache. We do it\n-            \/\/ here because the generated code is small and fast and\n-            \/\/ we really want it to be inlined in the caller.\n-            int n = (hash & Cache.SLOT_MASK) * 2;\n-            if (objects[n] == this) {\n-                return (T)objects[n + 1];\n-            }\n-            n = ((hash >>> Cache.INDEX_BITS) & Cache.SLOT_MASK) * 2;\n-            if (objects[n] == this) {\n-                return (T)objects[n + 1];\n-            }\n-        }\n-        return slowGet();\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    private T slowGet() {\n-        var value = findBinding();\n-        if (value == Snapshot.NIL) {\n-            throw new NoSuchElementException();\n-        }\n-        Cache.put(this, value);\n-        return (T)value;\n-    }\n-\n-    \/**\n-     * {@return {@code true} if this scoped value is bound in the current thread}\n-     *\/\n-    public boolean isBound() {\n-        Object[] objects = scopedValueCache();\n-        if (objects != null) {\n-            int n = (hash & Cache.SLOT_MASK) * 2;\n-            if (objects[n] == this) {\n-                return true;\n-            }\n-            n = ((hash >>> Cache.INDEX_BITS) & Cache.SLOT_MASK) * 2;\n-            if (objects[n] == this) {\n-                return true;\n-            }\n-        }\n-        var value = findBinding();\n-        boolean result = (value != Snapshot.NIL);\n-        if (result)  Cache.put(this, value);\n-        return result;\n-    }\n-\n-    \/**\n-     * Return the value of the scoped value or NIL if not bound.\n-     *\/\n-    private Object findBinding() {\n-        Object value = scopedValueBindings().find(this);\n-        return value;\n-    }\n-\n-    \/**\n-     * Returns the value of this scoped value if bound in the current thread, otherwise\n-     * returns {@code other}.\n-     *\n-     * @param other the value to return if not bound, can be {@code null}\n-     * @return the value of the scoped value if bound, otherwise {@code other}\n-     *\/\n-    public T orElse(T other) {\n-        Object obj = findBinding();\n-        if (obj != Snapshot.NIL) {\n-            @SuppressWarnings(\"unchecked\")\n-            T value = (T) obj;\n-            return value;\n-        } else {\n-            return other;\n-        }\n-    }\n-\n-    \/**\n-     * Returns the value of this scoped value if bound in the current thread, otherwise\n-     * throws an exception produced by the exception supplying function.\n-     *\n-     * @param <X> the type of the exception that may be thrown\n-     * @param exceptionSupplier the supplying function that produces the exception to throw\n-     * @return the value of the scoped value if bound in the current thread\n-     * @throws X if the scoped value is not bound in the current thread\n-     *\/\n-    public <X extends Throwable> T orElseThrow(Supplier<? extends X> exceptionSupplier) throws X {\n-        Objects.requireNonNull(exceptionSupplier);\n-        Object obj = findBinding();\n-        if (obj != Snapshot.NIL) {\n-            @SuppressWarnings(\"unchecked\")\n-            T value = (T) obj;\n-            return value;\n-        } else {\n-            throw exceptionSupplier.get();\n-        }\n-    }\n-\n-    private static Object[] scopedValueCache() {\n-        return JLA.scopedValueCache();\n-    }\n-\n-    private static void setScopedValueCache(Object[] cache) {\n-        JLA.setScopedValueCache(cache);\n-    }\n-\n-    \/\/ Special value to indicate this is a newly-created Thread\n-    \/\/ Note that his must match the declaration in j.l.Thread.\n-    private static final Object NEW_THREAD_BINDINGS = Thread.class;\n-\n-    private static Snapshot scopedValueBindings() {\n-        \/\/ Bindings can be in one of four states:\n-        \/\/\n-        \/\/ 1: class Thread: this is a new Thread instance, and no\n-        \/\/ scoped values have ever been bound in this Thread.\n-        \/\/ 2: EmptySnapshot.SINGLETON: This is effectively an empty binding.\n-        \/\/ 3: A Snapshot instance: this contains one or more scoped value\n-        \/\/ bindings.\n-        \/\/ 4: null: there may be some bindings in this Thread, but we don't know\n-        \/\/ where they are. We must invoke JLA.findScopedValueBindings() to walk\n-        \/\/ the stack to find them.\n-\n-        Object bindings = JLA.scopedValueBindings();\n-        if (bindings == NEW_THREAD_BINDINGS) {\n-            \/\/ This must be a new thread\n-           return Snapshot.EMPTY_SNAPSHOT;\n-        }\n-        if (bindings == null) {\n-            \/\/ Search the stack\n-            bindings = JLA.findScopedValueBindings();\n-            if (bindings == null) {\n-                \/\/ Nothing on the stack.\n-                bindings = Snapshot.EMPTY_SNAPSHOT;\n-            }\n-        }\n-        assert (bindings != null);\n-        JLA.setScopedValueBindings(bindings);\n-        return (Snapshot) bindings;\n-    }\n-\n-    private static int nextKey = 0xf0f0_f0f0;\n-\n-    \/\/ A Marsaglia xor-shift generator used to generate hashes. This one has full period, so\n-    \/\/ it generates 2**32 - 1 hashes before it repeats. We're going to use the lowest n bits\n-    \/\/ and the next n bits as cache indexes, so we make sure that those indexes map\n-    \/\/ to different slots in the cache.\n-    private static synchronized int generateKey() {\n-        int x = nextKey;\n-        do {\n-            x ^= x >>> 12;\n-            x ^= x << 9;\n-            x ^= x >>> 23;\n-        } while (Cache.primarySlot(x) == Cache.secondarySlot(x));\n-        return (nextKey = x);\n-    }\n-\n-    \/**\n-     * Return a bit mask that may be used to determine if this ScopedValue is\n-     * bound in the current context. Each Carrier holds a bit mask which is\n-     * the OR of all the bit masks of the bound ScopedValues.\n-     * @return the bitmask\n-     *\/\n-    int bitmask() {\n-        return (1 << Cache.primaryIndex(this)) | (1 << (Cache.secondaryIndex(this) + Cache.TABLE_SIZE));\n-    }\n-\n-    \/\/ Return true iff bitmask, considered as a set of bits, contains all\n-    \/\/ of the bits in targetBits.\n-    static boolean containsAll(int bitmask, int targetBits) {\n-        return (bitmask & targetBits) == targetBits;\n-    }\n-\n-    \/\/ A small fixed-size key-value cache. When a scoped value's get() method\n-    \/\/ is invoked, we record the result of the lookup in this per-thread cache\n-    \/\/ for fast access in future.\n-    private static final class Cache {\n-        static final int INDEX_BITS = 4;  \/\/ Must be a power of 2\n-        static final int TABLE_SIZE = 1 << INDEX_BITS;\n-        static final int TABLE_MASK = TABLE_SIZE - 1;\n-        static final int PRIMARY_MASK = (1 << TABLE_SIZE) - 1;\n-\n-        \/\/ The number of elements in the cache array, and a bit mask used to\n-        \/\/ select elements from it.\n-        private static final int CACHE_TABLE_SIZE, SLOT_MASK;\n-        \/\/ The largest cache we allow. Must be a power of 2 and greater than\n-        \/\/ or equal to 2.\n-        private static final int MAX_CACHE_SIZE = 16;\n-\n-        static {\n-            final String propertyName = \"jdk.incubator.concurrent.ScopedValue.cacheSize\";\n-            var sizeString = GetPropertyAction.privilegedGetProperty(propertyName, \"16\");\n-            var cacheSize = Integer.valueOf(sizeString);\n-            if (cacheSize < 2 || cacheSize > MAX_CACHE_SIZE) {\n-                cacheSize = MAX_CACHE_SIZE;\n-                System.err.println(propertyName + \" is out of range: is \" + sizeString);\n-            }\n-            if ((cacheSize & (cacheSize - 1)) != 0) {  \/\/ a power of 2\n-                cacheSize = MAX_CACHE_SIZE;\n-                System.err.println(propertyName + \" must be an integer power of 2: is \" + sizeString);\n-            }\n-            CACHE_TABLE_SIZE = cacheSize;\n-            SLOT_MASK = cacheSize - 1;\n-        }\n-\n-        static int primaryIndex(ScopedValue<?> key) {\n-            return key.hash & TABLE_MASK;\n-        }\n-\n-        static int secondaryIndex(ScopedValue<?> key) {\n-            return (key.hash >> INDEX_BITS) & TABLE_MASK;\n-        }\n-\n-        private static int primarySlot(ScopedValue<?> key) {\n-            return key.hashCode() & SLOT_MASK;\n-        }\n-\n-        private static int secondarySlot(ScopedValue<?> key) {\n-            return (key.hash >> INDEX_BITS) & SLOT_MASK;\n-        }\n-\n-        static int primarySlot(int hash) {\n-            return hash & SLOT_MASK;\n-        }\n-\n-        static int secondarySlot(int hash) {\n-            return (hash >> INDEX_BITS) & SLOT_MASK;\n-        }\n-\n-        static void put(ScopedValue<?> key, Object value) {\n-            Object[] theCache = scopedValueCache();\n-            if (theCache == null) {\n-                theCache = new Object[CACHE_TABLE_SIZE * 2];\n-                setScopedValueCache(theCache);\n-            }\n-            \/\/ Update the cache to replace one entry with the value we just looked up.\n-            \/\/ Each value can be in one of two possible places in the cache.\n-            \/\/ Pick a victim at (pseudo-)random.\n-            int k1 = primarySlot(key);\n-            int k2 = secondarySlot(key);\n-            var usePrimaryIndex = chooseVictim();\n-            int victim = usePrimaryIndex ? k1 : k2;\n-            int other = usePrimaryIndex ? k2 : k1;\n-            setKeyAndObjectAt(victim, key, value);\n-            if (getKey(theCache, other) == key) {\n-                setKeyAndObjectAt(other, key, value);\n-            }\n-        }\n-\n-        private static void setKeyAndObjectAt(int n, Object key, Object value) {\n-            var cache = scopedValueCache();\n-            cache[n * 2] = key;\n-            cache[n * 2 + 1] = value;\n-        }\n-\n-        private static void setKeyAndObjectAt(Object[] cache, int n, Object key, Object value) {\n-            cache[n * 2] = key;\n-            cache[n * 2 + 1] = value;\n-        }\n-\n-        private static Object getKey(Object[] objs, int n) {\n-            return objs[n * 2];\n-        }\n-\n-        private static void setKey(Object[] objs, int n, Object key) {\n-            objs[n * 2] = key;\n-        }\n-\n-        private static final JavaUtilConcurrentTLRAccess THREAD_LOCAL_RANDOM_ACCESS\n-                = SharedSecrets.getJavaUtilConcurrentTLRAccess();\n-\n-        \/\/ Return either true or false, at pseudo-random, with a bias towards true.\n-        \/\/ This chooses either the primary or secondary cache slot, but the\n-        \/\/ primary slot is approximately twice as likely to be chosen as the\n-        \/\/ secondary one.\n-        private static boolean chooseVictim() {\n-            int r = THREAD_LOCAL_RANDOM_ACCESS.nextSecondaryThreadLocalRandomSeed();\n-            return (r & 15) >= 5;\n-        }\n-\n-        \/\/ Null a set of cache entries, indicated by the 1-bits given\n-        static void invalidate(int toClearBits) {\n-            toClearBits = (toClearBits >>> TABLE_SIZE) | (toClearBits & PRIMARY_MASK);\n-            Object[] objects;\n-            if ((objects = scopedValueCache()) != null) {\n-                for (int bits = toClearBits; bits != 0; ) {\n-                    int index = Integer.numberOfTrailingZeros(bits);\n-                    setKeyAndObjectAt(objects, index & SLOT_MASK, null, null);\n-                    bits &= ~1 << index;\n-                }\n-            }\n-        }\n-    }\n-}\n","filename":"src\/jdk.incubator.concurrent\/share\/classes\/jdk\/incubator\/concurrent\/ScopedValue.java","additions":0,"deletions":838,"binary":false,"changes":838,"status":"deleted"},{"patch":"@@ -1,54 +0,0 @@\n-\/*\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.incubator.concurrent;\n-\n-\/**\n- * Thrown when a structure violation is detected.\n- *\n- * @see StructuredTaskScope#close()\n- *\n- * @since 19\n- *\/\n-public final class StructureViolationException extends RuntimeException {\n-    @java.io.Serial\n-    private static final long serialVersionUID = -7705327650798235468L;\n-\n-    \/**\n-     * Constructs a {@code StructureViolationException} with no detail message.\n-     *\/\n-    public StructureViolationException() {\n-        super();\n-    }\n-\n-    \/**\n-     * Constructs a {@code StructureViolationException} with the specified\n-     * detail message.\n-     *\n-     * @param  message the detail message, can be null\n-     *\/\n-    public StructureViolationException(String message) {\n-        super(message);\n-    }\n-}\n","filename":"src\/jdk.incubator.concurrent\/share\/classes\/jdk\/incubator\/concurrent\/StructureViolationException.java","additions":0,"deletions":54,"binary":false,"changes":54,"status":"deleted"},{"patch":"@@ -1,1223 +0,0 @@\n-\/*\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.incubator.concurrent;\n-\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.VarHandle;\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n-import java.time.Duration;\n-import java.time.Instant;\n-import java.util.Comparator;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.concurrent.Callable;\n-import java.util.concurrent.CancellationException;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.Future;\n-import java.util.concurrent.FutureTask;\n-import java.util.concurrent.RejectedExecutionException;\n-import java.util.concurrent.ThreadFactory;\n-import java.util.concurrent.TimeoutException;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.locks.ReentrantLock;\n-import java.util.function.Function;\n-import jdk.internal.misc.ThreadFlock;\n-\n-\/**\n- * A basic API for <em>structured concurrency<\/em>. {@code StructuredTaskScope} supports\n- * cases where a task splits into several concurrent subtasks, to be executed in their\n- * own threads, and where the subtasks must complete before the main task continues. A\n- * {@code StructuredTaskScope} can be used to ensure that the lifetime of a concurrent\n- * operation is confined by a <em>syntax block<\/em>, just like that of a sequential\n- * operation in structured programming.\n- *\n- * <h2>Basic usage<\/h2>\n- *\n- * A {@code StructuredTaskScope} is created with one of its public constructors. It defines\n- * the {@link #fork(Callable) fork} method to start a thread to execute a task, the {@link\n- * #join() join} method to wait for all threads to finish, and the {@link #close() close}\n- * method to close the task scope. The API is intended to be used with the {@code\n- * try-with-resources} construct. The intention is that code in the <em>block<\/em> uses\n- * the {@code fork} method to fork threads to execute the subtasks, wait for the threads\n- * to finish with the {@code join} method, and then <em>process the results<\/em>.\n- * Processing of results may include handling or re-throwing of exceptions.\n- * {@snippet lang=java :\n- *     try (var scope = new StructuredTaskScope<Object>()) {\n- *\n- *         Future<Integer> future1 = scope.fork(task1);   \/\/ @highlight substring=\"fork\"\n- *         Future<String> future2 = scope.fork(task2);    \/\/ @highlight substring=\"fork\"\n- *\n- *         scope.join();                                  \/\/ @highlight substring=\"join\"\n- *\n- *         ... process results\/exceptions ...\n- *\n- *     } \/\/ close                                         \/\/ @highlight substring=\"close\"\n- * }\n- * To ensure correct usage, the {@code join} and {@code close} methods may only be invoked\n- * by the <em>owner<\/em> (the thread that opened\/created the task scope}, and the\n- * {@code close} method throws an exception after closing if the owner did not invoke the\n- * {@code join} method after forking.\n- *\n- * <p> {@code StructuredTaskScope} defines the {@link #shutdown() shutdown} method to shut\n- * down a task scope without closing it. Shutdown is useful for cases where a subtask\n- * completes with a result (or exception) and the results of other unfinished subtasks are\n- * no longer needed. If a subtask invokes {@code shutdown} while the owner is waiting in\n- * the {@code join} method then it will cause {@code join} to wakeup, all unfinished\n- * threads to be {@linkplain Thread#interrupt() interrupted} and prevents new threads\n- * from starting in the task scope.\n- *\n- * <h2>Subclasses with policies for common cases<\/h2>\n- *\n- * Two subclasses of {@code StructuredTaskScope} are defined to implement policy for\n- * common cases:\n- * <ol>\n- *   <li> {@link ShutdownOnSuccess ShutdownOnSuccess} captures the first result and\n- *   shuts down the task scope to interrupt unfinished threads and wakeup the owner. This\n- *   class is intended for cases where the result of any subtask will do (\"invoke any\")\n- *   and where there is no need to wait for results of other unfinished tasks. It defines\n- *   methods to get the first result or throw an exception if all subtasks fail.\n- *   <li> {@link ShutdownOnFailure ShutdownOnFailure} captures the first exception and\n- *   shuts down the task scope. This class is intended for cases where the results of all\n- *   subtasks are required (\"invoke all\"); if any subtask fails then the results of other\n- *   unfinished subtasks are no longer needed. If defines methods to throw an exception if\n- *   any of the subtasks fail.\n- * <\/ol>\n- *\n- * <p> The following are two examples that use the two classes. In both cases, a pair of\n- * subtasks are forked to fetch resources from two URL locations \"left\" and \"right\". The\n- * first example creates a ShutdownOnSuccess object to capture the result of the first\n- * subtask to complete normally, cancelling the other by way of shutting down the task\n- * scope. The main task waits in {@code join} until either subtask completes with a result\n- * or both subtasks fail. It invokes {@link ShutdownOnSuccess#result(Function)\n- * result(Function)} method to get the captured result. If both subtasks fail then this\n- * method throws a {@code WebApplicationException} with the exception from one of the\n- * subtasks as the cause.\n- * {@snippet lang=java :\n- *     try (var scope = new StructuredTaskScope.ShutdownOnSuccess<String>()) {\n- *\n- *         scope.fork(() -> fetch(left));\n- *         scope.fork(() -> fetch(right));\n- *\n- *         scope.join();\n- *\n- *         \/\/ @link regex=\"result(?=\\()\" target=\"ShutdownOnSuccess#result\" :\n- *         String result = scope.result(e -> new WebApplicationException(e));\n- *\n- *         ...\n- *     }\n- * }\n- * The second example creates a ShutdownOnFailure object to capture the exception of the\n- * first subtask to fail, cancelling the other by way of shutting down the task scope. The\n- * main task waits in {@link #joinUntil(Instant)} until both subtasks complete with a\n- * result, either fails, or a deadline is reached. It invokes {@link\n- * ShutdownOnFailure#throwIfFailed(Function) throwIfFailed(Function)} to throw an exception\n- * when either subtask fails. This method is a no-op if no subtasks fail. The main task\n- * uses {@code Future}'s {@link Future#resultNow() resultNow()} method to retrieve the\n- * results.\n- *\n- * {@snippet lang=java :\n- *    Instant deadline = ...\n- *\n- *    try (var scope = new StructuredTaskScope.ShutdownOnFailure()) {\n- *\n- *         Future<String> future1 = scope.fork(() -> query(left));\n- *         Future<String> future2 = scope.fork(() -> query(right));\n- *\n- *         scope.joinUntil(deadline);\n- *\n- *         \/\/ @link substring=\"throwIfFailed\" target=\"ShutdownOnFailure#throwIfFailed\" :\n- *         scope.throwIfFailed(e -> new WebApplicationException(e));\n- *\n- *         \/\/ both subtasks completed successfully\n- *         String result = Stream.of(future1, future2)\n- *                 \/\/ @link substring=\"Future::resultNow\" target=\"Future#resultNow\" :\n- *                 .map(Future::resultNow)\n- *                 .collect(Collectors.joining(\", \", \"{ \", \" }\"));\n- *\n- *         ...\n- *     }\n- * }\n- *\n- * <h2>Extending StructuredTaskScope<\/h2>\n- *\n- * {@code StructuredTaskScope} can be extended, and the {@link #handleComplete(Future)\n- * handleComplete} overridden, to implement policies other than those implemented by\n- * {@code ShutdownOnSuccess} and {@code ShutdownOnFailure}. The method may be overridden\n- * to, for example, collect the results of subtasks that complete with a result and ignore\n- * subtasks that fail. It may collect exceptions when subtasks fail. It may invoke the\n- * {@link #shutdown() shutdown} method to shut down and cause {@link #join() join} to\n- * wakeup when some condition arises.\n- *\n- * <p> A subclass will typically define methods to make available results, state, or other\n- * outcome to code that executes after the {@code join} method. A subclass that collects\n- * results and ignores subtasks that fail may define a method that returns a collection of\n- * results. A subclass that implements a policy to shut down when a subtask fails may\n- * define a method to retrieve the exception of the first subtask to fail.\n- *\n- * <p> The following is an example of a {@code StructuredTaskScope} implementation that\n- * collects the results of subtasks that complete successfully. It defines the method\n- * <b>{@code results()}<\/b> to be used by the main task to retrieve the results.\n- *\n- * {@snippet lang=java :\n- *     class MyScope<T> extends StructuredTaskScope<T> {\n- *         private final Queue<T> results = new ConcurrentLinkedQueue<>();\n- *\n- *         MyScope() {\n- *             super(null, Thread.ofVirtual().factory());\n- *         }\n- *\n- *         @Override\n- *         \/\/ @link substring=\"handleComplete\" target=\"handleComplete\" :\n- *         protected void handleComplete(Future<T> future) {\n- *             if (future.state() == Future.State.SUCCESS) {\n- *                 T result = future.resultNow();\n- *                 results.add(result);\n- *             }\n- *         }\n- *\n- *         \/\/ Returns a stream of results from the subtasks that completed successfully\n- *         public Stream<T> results() {     \/\/ @highlight substring=\"results\"\n- *             return results.stream();\n- *         }\n- *     }\n- *  }\n- *\n- * <h2><a id=\"TreeStructure\">Tree structure<\/a><\/h2>\n- *\n- * Task scopes form a tree where parent-child relations are established implicitly when\n- * opening a new task scope:\n- * <ul>\n- *   <li> A parent-child relation is established when a thread started in a task scope\n- *   opens its own task scope. A thread started in task scope \"A\" that opens task scope\n- *   \"B\" establishes a parent-child relation where task scope \"A\" is the parent of task\n- *   scope \"B\".\n- *   <li> A parent-child relation is established with nesting. If a thread opens task\n- *   scope \"B\", then opens task scope \"C\" (before it closes \"B\"), then the enclosing task\n- *   scope \"B\" is the parent of the nested task scope \"C\".\n- * <\/ul>\n- *\n- * The <i>descendants<\/i> of a task scope are the child task scopes that it is a parent\n- * of, plus the descendants of the child task scopes, recursively.\n- *\n- * <p> The tree structure supports:\n- * <ul>\n- *   <li> Inheritance of {@linkplain ScopedValue scoped values} across threads.\n- *   <li> Confinement checks. The phrase \"threads contained in the task scope\" in method\n- *   descriptions means threads started in the task scope or descendant scopes.\n- * <\/ul>\n- *\n- * <p> The following example demonstrates the inheritance of a scoped value. A scoped\n- * value {@code USERNAME} is bound to the value \"{@code duke}\". A {@code StructuredTaskScope}\n- * is created and its {@code fork} method invoked to start a thread to execute {@code\n- * childTask}. The thread inherits the scoped value <em>bindings<\/em> captured when\n- * creating the task scope. The code in {@code childTask} uses the value of the scoped\n- * value and so reads the value \"{@code duke}\".\n- * {@snippet lang=java :\n- *     private static final ScopedValue<String> USERNAME = ScopedValue.newInstance();\n- *\n- *     \/\/ @link substring=\"where\" target=\"ScopedValue#where(ScopedValue, Object, Runnable)\" :\n- *     ScopedValue.where(USERNAME, \"duke\", () -> {\n- *         try (var scope = new StructuredTaskScope<String>()) {\n- *\n- *             scope.fork(() -> childTask());           \/\/ @highlight substring=\"fork\"\n- *             ...\n- *          }\n- *     });\n- *\n- *     ...\n- *\n- *     String childTask() {\n- *         \/\/ @link substring=\"get\" target=\"ScopedValue#get()\" :\n- *         String name = USERNAME.get();   \/\/ \"duke\"\n- *         ...\n- *     }\n- * }\n- *\n- * <p> {@code StructuredTaskScope} does not define APIs that exposes the tree structure\n- * at this time.\n- *\n- * <p> Unless otherwise specified, passing a {@code null} argument to a constructor\n- * or method in this class will cause a {@link NullPointerException} to be thrown.\n- *\n- * <h2>Memory consistency effects<\/h2>\n- *\n- * <p> Actions in the owner thread of, or a thread contained in, the task scope prior to\n- * {@linkplain #fork forking} of a {@code Callable} task\n- * <a href=\"{@docRoot}\/java.base\/java\/util\/concurrent\/package-summary.html#MemoryVisibility\">\n- * <i>happen-before<\/i><\/a> any actions taken by that task, which in turn <i>happen-before<\/i>\n- * the task result is retrieved via its {@code Future}, or <i>happen-before<\/i> any actions\n- * taken in a thread after {@linkplain #join() joining} of the task scope.\n- *\n- * @jls 17.4.5 Happens-before Order\n- *\n- * @param <T> the result type of tasks executed in the scope\n- * @since 19\n- *\/\n-public class StructuredTaskScope<T> implements AutoCloseable {\n-    private static final VarHandle FUTURES;\n-    static {\n-        try {\n-            MethodHandles.Lookup l = MethodHandles.lookup();\n-            FUTURES = l.findVarHandle(StructuredTaskScope.class, \"futures\", Set.class);\n-        } catch (Exception e) {\n-            throw new InternalError(e);\n-        }\n-    }\n-\n-    private final ThreadFactory factory;\n-    private final ThreadFlock flock;\n-    private final ReentrantLock shutdownLock = new ReentrantLock();\n-\n-    \/\/ lazily created set of Future objects with threads waiting in Future::get\n-    private volatile Set<Future<?>> futures;\n-\n-    \/\/ set by owner when it forks, reset by owner when it joins\n-    private boolean needJoin;\n-\n-    \/\/ states: OPEN -> SHUTDOWN -> CLOSED\n-    private static final int OPEN     = 0;   \/\/ initial state\n-    private static final int SHUTDOWN = 1;\n-    private static final int CLOSED   = 2;\n-\n-    \/\/ scope state, set by owner, read by any thread\n-    private volatile int state;\n-\n-    \/**\n-     * Creates a structured task scope with the given name and thread factory. The task\n-     * scope is optionally named for the purposes of monitoring and management. The thread\n-     * factory is used to {@link ThreadFactory#newThread(Runnable) create} threads when\n-     * tasks are {@linkplain #fork(Callable) forked}. The task scope is owned by the\n-     * current thread.\n-     *\n-     * <p> This method captures the current thread's {@linkplain ScopedValue scoped value}\n-     * bindings for inheritance by threads created in the task scope. The\n-     * <a href=\"#TreeStructure\">Tree Structure<\/a> section in the class description\n-     * details how parent-child relations are established implicitly for the purpose of\n-     * inheritance of scoped value bindings.\n-     *\n-     * @param name the name of the task scope, can be null\n-     * @param factory the thread factory\n-     *\/\n-    public StructuredTaskScope(String name, ThreadFactory factory) {\n-        this.factory = Objects.requireNonNull(factory, \"'factory' is null\");\n-        this.flock = ThreadFlock.open(name);\n-    }\n-\n-    \/**\n-     * Creates an unnamed structured task scope that creates virtual threads. The task\n-     * scope is owned by the current thread.\n-     *\n-     * <p> This constructor is equivalent to invoking the 2-arg constructor with a name\n-     * of {@code null} and a thread factory that creates virtual threads.\n-     *\/\n-    public StructuredTaskScope() {\n-        this.factory = Thread.ofVirtual().factory();\n-        this.flock = ThreadFlock.open(null);\n-    }\n-\n-    \/**\n-     * Throws WrongThreadException if the current thread is not the owner.\n-     *\/\n-    private void ensureOwner() {\n-        if (Thread.currentThread() != flock.owner())\n-            throw new WrongThreadException(\"Current thread not owner\");\n-    }\n-\n-    \/**\n-     * Throws WrongThreadException if the current thread is not the owner\n-     * or a thread contained in the tree.\n-     *\/\n-    private void ensureOwnerOrContainsThread() {\n-        Thread currentThread = Thread.currentThread();\n-        if (currentThread != flock.owner() && !flock.containsThread(currentThread))\n-            throw new WrongThreadException(\"Current thread not owner or thread in the tree\");\n-    }\n-\n-    \/**\n-     * Tests if the task scope is shutdown.\n-     *\/\n-    private boolean isShutdown() {\n-        return state >= SHUTDOWN;\n-    }\n-\n-    \/**\n-     * Track the given Future.\n-     *\/\n-    private void track(Future<?> future) {\n-        \/\/ create the set of Futures if not already created\n-        Set<Future<?>> futures = this.futures;\n-        if (futures == null) {\n-            futures = ConcurrentHashMap.newKeySet();\n-            if (!FUTURES.compareAndSet(this, null, futures)) {\n-                \/\/ lost the race\n-                futures = this.futures;\n-            }\n-        }\n-        futures.add(future);\n-    }\n-\n-    \/**\n-     * Stop tracking the Future.\n-     *\/\n-    private void untrack(Future<?> future) {\n-        assert futures != null;\n-        futures.remove(future);\n-    }\n-\n-    \/**\n-     * Invoked when a task completes before the scope is shut down.\n-     *\n-     * <p> The {@code handleComplete} method should be thread safe. It may be invoked by\n-     * several threads concurrently.\n-     *\n-     * @implSpec The default implementation does nothing.\n-     *\n-     * @param future the completed task\n-     *\/\n-    protected void handleComplete(Future<T> future) { }\n-\n-    \/**\n-     * Starts a new thread to run the given task.\n-     *\n-     * <p> The new thread is created with the task scope's {@link ThreadFactory}. It\n-     * inherits the current thread's {@linkplain ScopedValue scoped value} bindings. The\n-     * bindings must match the bindings captured when the task scope was created.\n-     *\n-     * <p> If the task completes before the task scope is {@link #shutdown() shutdown}\n-     * then the {@link #handleComplete(Future) handleComplete} method is invoked to\n-     * consume the completed task. The {@code handleComplete} method is run when the task\n-     * completes with a result or exception. If the {@code Future}'s {@link\n-     * Future#cancel(boolean) cancel} method is used to cancel a task before the task scope\n-     * is shut down, then the {@code handleComplete} method is run by the thread that\n-     * invokes {@code cancel}. If the task scope shuts down at or around the same time\n-     * that the task completes or is cancelled then the {@code handleComplete} method may\n-     * or may not be invoked.\n-     *\n-     * <p> If this task scope is {@linkplain #shutdown() shutdown} (or in the process\n-     * of shutting down) then {@code fork} returns a {@code Future} representing a {@link\n-     * Future.State#CANCELLED cancelled} task that was not run.\n-     *\n-     * <p> This method may only be invoked by the task scope owner or threads contained\n-     * in the task scope. The {@link Future#cancel(boolean) cancel} method of the returned\n-     * {@code Future} object is also restricted to the task scope owner or threads contained\n-     * in the task scope. The {@code cancel} method throws {@link WrongThreadException}\n-     * if invoked from another thread. All other methods on the returned {@code Future}\n-     * object, such as {@link Future#get() get}, are not restricted.\n-     *\n-     * @param task the task to run\n-     * @param <U> the result type\n-     * @return a future\n-     * @throws IllegalStateException if this task scope is closed\n-     * @throws WrongThreadException if the current thread is not the owner or a thread\n-     * contained in the task scope\n-     * @throws StructureViolationException if the current scoped value bindings are not\n-     * the same as when the task scope was created\n-     * @throws RejectedExecutionException if the thread factory rejected creating a\n-     * thread to run the task\n-     *\/\n-    public <U extends T> Future<U> fork(Callable<? extends U> task) {\n-        Objects.requireNonNull(task, \"'task' is null\");\n-\n-        \/\/ create future\n-        var future = new FutureImpl<U>(this, task);\n-\n-        boolean shutdown = (state >= SHUTDOWN);\n-\n-        if (!shutdown) {\n-            \/\/ create thread\n-            Thread thread = factory.newThread(future);\n-            if (thread == null) {\n-                throw new RejectedExecutionException(\"Rejected by thread factory\");\n-            }\n-\n-            \/\/ attempt to start the thread\n-            try {\n-                flock.start(thread);\n-            } catch (IllegalStateException e) {\n-                \/\/ shutdown or in the process of shutting down\n-                shutdown = true;\n-            }\n-        }\n-\n-        if (shutdown) {\n-            if (state == CLOSED) {\n-                throw new IllegalStateException(\"Task scope is closed\");\n-            } else {\n-                future.cancel(false);\n-            }\n-        }\n-\n-        \/\/ if owner forks then it will need to join\n-        if (Thread.currentThread() == flock.owner() && !needJoin) {\n-            needJoin = true;\n-        }\n-\n-        return future;\n-    }\n-\n-    \/**\n-     * Wait for all threads to finish or the task scope to shut down.\n-     *\/\n-    private void implJoin(Duration timeout)\n-        throws InterruptedException, TimeoutException\n-    {\n-        ensureOwner();\n-        needJoin = false;\n-        int s = state;\n-        if (s >= SHUTDOWN) {\n-            if (s == CLOSED)\n-                throw new IllegalStateException(\"Task scope is closed\");\n-            return;\n-        }\n-\n-        \/\/ wait for all threads, wakeup, interrupt, or timeout\n-        if (timeout != null) {\n-            flock.awaitAll(timeout);\n-        } else {\n-            flock.awaitAll();\n-        }\n-    }\n-\n-    \/**\n-     * Wait for all threads to finish or the task scope to shut down. This method waits\n-     * until all threads started in the task scope finish execution (of both task and\n-     * {@link #handleComplete(Future) handleComplete} method), the {@link #shutdown()\n-     * shutdown} method is invoked to shut down the task scope, or the current thread\n-     * is {@linkplain Thread#interrupt() interrupted}.\n-     *\n-     * <p> This method may only be invoked by the task scope owner.\n-     *\n-     * @return this task scope\n-     * @throws IllegalStateException if this task scope is closed\n-     * @throws WrongThreadException if the current thread is not the owner\n-     * @throws InterruptedException if interrupted while waiting\n-     *\/\n-    public StructuredTaskScope<T> join() throws InterruptedException {\n-        try {\n-            implJoin(null);\n-        } catch (TimeoutException e) {\n-            throw new InternalError();\n-        }\n-        return this;\n-    }\n-\n-    \/**\n-     * Wait for all threads to finish or the task scope to shut down, up to the given\n-     * deadline. This method waits until all threads started in the task scope finish\n-     * execution (of both task and {@link #handleComplete(Future) handleComplete} method),\n-     * the {@link #shutdown() shutdown} method is invoked to shut down the task scope,\n-     * the current thread is {@linkplain Thread#interrupt() interrupted}, or the deadline\n-     * is reached.\n-     *\n-     * <p> This method may only be invoked by the task scope owner.\n-     *\n-     * @param deadline the deadline\n-     * @return this task scope\n-     * @throws IllegalStateException if this task scope is closed\n-     * @throws WrongThreadException if the current thread is not the owner\n-     * @throws InterruptedException if interrupted while waiting\n-     * @throws TimeoutException if the deadline is reached while waiting\n-     *\/\n-    public StructuredTaskScope<T> joinUntil(Instant deadline)\n-        throws InterruptedException, TimeoutException\n-    {\n-        Duration timeout = Duration.between(Instant.now(), deadline);\n-        implJoin(timeout);\n-        return this;\n-    }\n-\n-    \/**\n-     * Cancel all tracked Future objects.\n-     *\/\n-    private void cancelTrackedFutures() {\n-        Set<Future<?>> futures = this.futures;\n-        if (futures != null) {\n-            futures.forEach(f -> f.cancel(false));\n-        }\n-    }\n-\n-    \/**\n-     * Interrupt all unfinished threads.\n-     *\/\n-    private void implInterruptAll() {\n-        flock.threads().forEach(t -> {\n-            if (t != Thread.currentThread()) {\n-                t.interrupt();\n-            }\n-        });\n-    }\n-\n-    @SuppressWarnings(\"removal\")\n-    private void interruptAll() {\n-        if (System.getSecurityManager() == null) {\n-            implInterruptAll();\n-        } else {\n-            PrivilegedAction<Void> pa = () -> {\n-                implInterruptAll();\n-                return null;\n-            };\n-            AccessController.doPrivileged(pa);\n-        }\n-    }\n-\n-    \/**\n-     * Shutdown the task scope if not already shutdown. Return true if this method\n-     * shutdowns the task scope, false if already shutdown.\n-     *\/\n-    private boolean implShutdown() {\n-        if (state < SHUTDOWN) {\n-            shutdownLock.lock();\n-            try {\n-                if (state < SHUTDOWN) {\n-\n-                    \/\/ prevent new threads from starting\n-                    flock.shutdown();\n-\n-                    \/\/ wakeup any threads waiting in Future::get\n-                    cancelTrackedFutures();\n-\n-                    \/\/ interrupt all unfinished threads\n-                    interruptAll();\n-\n-                    state = SHUTDOWN;\n-                    return true;\n-                }\n-            } finally {\n-                shutdownLock.unlock();\n-            }\n-        }\n-        assert state >= SHUTDOWN;\n-        return false;\n-    }\n-\n-    \/**\n-     * Shut down the task scope without closing it. Shutting down a task scope prevents\n-     * new threads from starting, interrupts all unfinished threads, and causes the\n-     * {@link #join() join} method to wakeup. Shutdown is useful for cases where the\n-     * results of unfinished subtasks are no longer needed.\n-     *\n-     * <p> More specifically, this method:\n-     * <ul>\n-     * <li> {@linkplain Future#cancel(boolean) Cancels} the tasks that have threads\n-     * {@linkplain Future#get() waiting} on a result so that the waiting threads wakeup.\n-     * <li> {@linkplain Thread#interrupt() Interrupts} all unfinished threads in the\n-     * task scope (except the current thread).\n-     * <li> Wakes up the owner if it is waiting in {@link #join()} or {@link\n-     * #joinUntil(Instant)}. If the owner is not waiting then its next call to {@code\n-     * join} or {@code joinUntil} will return immediately.\n-     * <\/ul>\n-     *\n-     * <p> When this method completes then the {@code Future} objects for all tasks will\n-     * be {@linkplain Future#isDone() done}, normally or abnormally. There may still\n-     * be threads that have not finished because they are executing code that did not\n-     * respond (or respond promptly) to thread interrupt. This method does not wait\n-     * for these threads. When the owner invokes the {@link #close() close} method\n-     * to close the task scope then it will wait for the remaining threads to finish.\n-     *\n-     * <p> This method may only be invoked by the task scope owner or threads contained\n-     * in the task scope.\n-     *\n-     * @throws IllegalStateException if this task scope is closed\n-     * @throws WrongThreadException if the current thread is not the owner or\n-     * a thread contained in the task scope\n-     *\/\n-    public void shutdown() {\n-        ensureOwnerOrContainsThread();\n-        if (state == CLOSED)\n-            throw new IllegalStateException(\"Task scope is closed\");\n-        if (implShutdown())\n-            flock.wakeup();\n-    }\n-\n-    \/**\n-     * Closes this task scope.\n-     *\n-     * <p> This method first shuts down the task scope (as if by invoking the {@link\n-     * #shutdown() shutdown} method). It then waits for the threads executing any\n-     * unfinished tasks to finish. If interrupted then this method will continue to\n-     * wait for the threads to finish before completing with the interrupt status set.\n-     *\n-     * <p> This method may only be invoked by the task scope owner. If the task scope\n-     * is already closed then the owner invoking this method has no effect.\n-     *\n-     * <p> A {@code StructuredTaskScope} is intended to be used in a <em>structured\n-     * manner<\/em>. If this method is called to close a task scope before nested task\n-     * scopes are closed then it closes the underlying construct of each nested task scope\n-     * (in the reverse order that they were created in), closes this task scope, and then\n-     * throws {@link StructureViolationException}.\n-     *\n-     * Similarly, if this method is called to close a task scope while executing with\n-     * {@linkplain ScopedValue scoped value} bindings, and the task scope was created\n-     * before the scoped values were bound, then {@code StructureViolationException} is\n-     * thrown after closing the task scope.\n-     *\n-     * If a thread terminates without first closing task scopes that it owns then\n-     * termination will cause the underlying construct of each of its open tasks scopes to\n-     * be closed. Closing is performed in the reverse order that the task scopes were\n-     * created in. Thread termination may therefore be delayed when the owner has to wait\n-     * for threads forked in these task scopes to finish.\n-     *\n-     * @throws IllegalStateException thrown after closing the task scope if the owner\n-     * did not invoke join after forking\n-     * @throws WrongThreadException if the current thread is not the owner\n-     * @throws StructureViolationException if a structure violation was detected\n-     *\/\n-    @Override\n-    public void close() {\n-        ensureOwner();\n-        if (state == CLOSED)\n-            return;\n-\n-        try {\n-            implShutdown();\n-            flock.close();\n-        } finally {\n-            state = CLOSED;\n-        }\n-\n-        if (needJoin) {\n-            throw new IllegalStateException(\"Owner did not invoke join or joinUntil after fork\");\n-        }\n-    }\n-\n-    @Override\n-    public String toString() {\n-        StringBuilder sb = new StringBuilder();\n-        String name = flock.name();\n-        if (name != null) {\n-            sb.append(name);\n-            sb.append('\/');\n-        }\n-        sb.append(Objects.toIdentityString(this));\n-        int s = state;\n-        if (s == CLOSED)\n-            sb.append(\"\/closed\");\n-        else if (s == SHUTDOWN)\n-            sb.append(\"\/shutdown\");\n-        return sb.toString();\n-    }\n-\n-    \/**\n-     * The Future implementation returned by the fork methods. Most methods are\n-     * overridden to support cancellation when the task scope is shutdown.\n-     * The blocking get methods register the Future with the task scope so that they\n-     * are cancelled when the task scope shuts down.\n-     *\/\n-    private static final class FutureImpl<V> extends FutureTask<V> {\n-        private final StructuredTaskScope<V> scope;\n-\n-        @SuppressWarnings(\"unchecked\")\n-        FutureImpl(StructuredTaskScope<? super V> scope, Callable<? extends V> task) {\n-            super((Callable<V>) task);\n-            this.scope = (StructuredTaskScope<V>) scope;\n-        }\n-\n-        @Override\n-        protected void done() {\n-            if (!scope.isShutdown()) {\n-                scope.handleComplete(this);\n-            }\n-        }\n-\n-        private void cancelIfShutdown() {\n-            if (scope.isShutdown() && !super.isDone()) {\n-                super.cancel(false);\n-            }\n-        }\n-\n-        @Override\n-        public boolean isDone() {\n-            cancelIfShutdown();\n-            return super.isDone();\n-        }\n-\n-        @Override\n-        public boolean isCancelled() {\n-            cancelIfShutdown();\n-            return super.isCancelled();\n-        }\n-\n-        @Override\n-        public boolean cancel(boolean mayInterruptIfRunning) {\n-            scope.ensureOwnerOrContainsThread();\n-            cancelIfShutdown();\n-            return super.cancel(mayInterruptIfRunning);\n-        }\n-\n-        @Override\n-        public V get() throws InterruptedException, ExecutionException {\n-            if (super.isDone())\n-                return super.get();\n-            scope.track(this);\n-            try {\n-                cancelIfShutdown();\n-                return super.get();\n-            } finally {\n-                scope.untrack(this);\n-            }\n-        }\n-\n-        @Override\n-        public V get(long timeout, TimeUnit unit)\n-                throws InterruptedException, ExecutionException, TimeoutException {\n-            Objects.requireNonNull(unit);\n-            if (super.isDone())\n-                return super.get();\n-            scope.track(this);\n-            try {\n-                cancelIfShutdown();\n-                return super.get(timeout, unit);\n-            } finally {\n-                scope.untrack(this);\n-            }\n-        }\n-\n-        @Override\n-        public V resultNow() {\n-            cancelIfShutdown();\n-            return super.resultNow();\n-        }\n-\n-        @Override\n-        public Throwable exceptionNow() {\n-            cancelIfShutdown();\n-            return super.exceptionNow();\n-        }\n-\n-        @Override\n-        public State state() {\n-            cancelIfShutdown();\n-            return super.state();\n-        }\n-\n-        @Override\n-        public String toString() {\n-            cancelIfShutdown();\n-            return super.toString();\n-        }\n-    }\n-\n-    \/**\n-     * Maps a Future.State to an int that can be compared.\n-     * RUNNING < CANCELLED < FAILED < SUCCESS.\n-     *\/\n-    private static int futureStateToInt(Future.State s) {\n-        return switch (s) {\n-            case RUNNING   -> 0;\n-            case CANCELLED -> 1;\n-            case FAILED    -> 2;\n-            case SUCCESS   -> 3;\n-        };\n-    }\n-\n-    \/\/ RUNNING < CANCELLED < FAILED < SUCCESS\n-    private static final Comparator<Future.State> FUTURE_STATE_COMPARATOR =\n-            Comparator.comparingInt(StructuredTaskScope::futureStateToInt);\n-\n-    \/**\n-     * A {@code StructuredTaskScope} that captures the result of the first subtask to\n-     * complete successfully. Once captured, it invokes the {@linkplain #shutdown() shutdown}\n-     * method to interrupt unfinished threads and wakeup the owner. The policy\n-     * implemented by this class is intended for cases where the result of any subtask\n-     * will do (\"invoke any\") and where the results of other unfinished subtask are no\n-     * longer needed.\n-     *\n-     * <p> Unless otherwise specified, passing a {@code null} argument to a method\n-     * in this class will cause a {@link NullPointerException} to be thrown.\n-     *\n-     * @param <T> the result type\n-     * @since 19\n-     *\/\n-    public static final class ShutdownOnSuccess<T> extends StructuredTaskScope<T> {\n-        private static final VarHandle FUTURE;\n-        static {\n-            try {\n-                MethodHandles.Lookup l = MethodHandles.lookup();\n-                FUTURE = l.findVarHandle(ShutdownOnSuccess.class, \"future\", Future.class);\n-            } catch (Exception e) {\n-                throw new InternalError(e);\n-            }\n-        }\n-        private volatile Future<T> future;\n-\n-        \/**\n-         * Constructs a new {@code ShutdownOnSuccess} with the given name and thread factory.\n-         * The task scope is optionally named for the purposes of monitoring and management.\n-         * The thread factory is used to {@link ThreadFactory#newThread(Runnable) create}\n-         * threads when tasks are {@linkplain #fork(Callable) forked}. The task scope is\n-         * owned by the current thread.\n-         *\n-         * <p> This method captures the current thread's {@linkplain ScopedValue scoped value}\n-         * bindings for inheritance by threads created in the task scope. The\n-         * <a href=\"StructuredTaskScope.html#TreeStructure\">Tree Structure<\/a> section in\n-         * the class description details how parent-child relations are established\n-         * implicitly for the purpose of inheritance of scoped value bindings.\n-         *\n-         * @param name the name of the task scope, can be null\n-         * @param factory the thread factory\n-         *\/\n-        public ShutdownOnSuccess(String name, ThreadFactory factory) {\n-            super(name, factory);\n-        }\n-\n-        \/**\n-         * Constructs a new unnamed {@code ShutdownOnSuccess} that creates virtual threads.\n-         *\n-         * <p> This constructor is equivalent to invoking the 2-arg constructor with a\n-         * name of {@code null} and a thread factory that creates virtual threads.\n-         *\/\n-        public ShutdownOnSuccess() {\n-            super(null, Thread.ofVirtual().factory());\n-        }\n-\n-        \/**\n-         * Shut down the given task scope when invoked for the first time with a {@code\n-         * Future} for a task that completed with a result.\n-         *\n-         * @param future the completed task\n-         * @see #shutdown()\n-         * @see Future.State#SUCCESS\n-         *\/\n-        @Override\n-        protected void handleComplete(Future<T> future) {\n-            Future.State state = future.state();\n-            if (state == Future.State.RUNNING) {\n-                throw new IllegalArgumentException(\"Task is not completed\");\n-            }\n-\n-            Future<T> f;\n-            while (((f = this.future) == null)\n-                    || FUTURE_STATE_COMPARATOR.compare(f.state(), state) < 0) {\n-                if (FUTURE.compareAndSet(this, f, future)) {\n-                    if (state == Future.State.SUCCESS)\n-                        shutdown();\n-                    break;\n-                }\n-            }\n-        }\n-\n-        \/**\n-         * {@inheritDoc}\n-         * @return this task scope\n-         * @throws IllegalStateException {@inheritDoc}\n-         * @throws WrongThreadException {@inheritDoc}\n-         *\/\n-        @Override\n-        public ShutdownOnSuccess<T> join() throws InterruptedException {\n-            super.join();\n-            return this;\n-        }\n-\n-        \/**\n-         * {@inheritDoc}\n-         * @return this task scope\n-         * @throws IllegalStateException {@inheritDoc}\n-         * @throws WrongThreadException {@inheritDoc}\n-         *\/\n-        @Override\n-        public ShutdownOnSuccess<T> joinUntil(Instant deadline)\n-            throws InterruptedException, TimeoutException\n-        {\n-            super.joinUntil(deadline);\n-            return this;\n-        }\n-\n-        \/**\n-         * {@return the result of the first subtask that completed with a result}\n-         *\n-         * <p> When no subtask completed with a result but a task completed with an\n-         * exception then {@code ExecutionException} is thrown with the exception as the\n-         * {@linkplain Throwable#getCause() cause}. If only cancelled subtasks were\n-         * notified to the {@code handleComplete} method then {@code CancellationException}\n-         * is thrown.\n-         *\n-         * @apiNote This method is intended to be invoked by the task scope owner after it\n-         * has invoked {@link #join() join} (or {@link #joinUntil(Instant) joinUntil}).\n-         * A future release may add enforcement to prevent the method being called by\n-         * other threads or before joining.\n-         *\n-         * @throws ExecutionException if no subtasks completed with a result but a subtask\n-         * completed with an exception\n-         * @throws CancellationException if all subtasks were cancelled\n-         * @throws IllegalStateException if the handle method was not invoked with a\n-         * completed subtask\n-         *\/\n-        public T result() throws ExecutionException {\n-            Future<T> f = future;\n-            if (f == null) {\n-                throw new IllegalStateException(\"No completed subtasks\");\n-            }\n-            return switch (f.state()) {\n-                case SUCCESS   -> f.resultNow();\n-                case FAILED    -> throw new ExecutionException(f.exceptionNow());\n-                case CANCELLED -> throw new CancellationException();\n-                default        -> throw new InternalError(\"Unexpected state: \" + f);\n-            };\n-\n-        }\n-\n-        \/**\n-         * Returns the result of the first subtask that completed with a result, otherwise\n-         * throws an exception produced by the given exception supplying function.\n-         *\n-         * <p> When no subtask completed with a result but a subtask completed with an\n-         * exception then the exception supplying function is invoked with the exception.\n-         * If only cancelled subtasks were notified to the {@code handleComplete} method\n-         * then the exception supplying function is invoked with a {@code CancellationException}.\n-         *\n-         * @apiNote This method is intended to be invoked by the task scope owner after it\n-         * has invoked {@link #join() join} (or {@link #joinUntil(Instant) joinUntil}).\n-         * A future release may add enforcement to prevent the method being called by\n-         * other threads or before joining.\n-         *\n-         * @param esf the exception supplying function\n-         * @param <X> type of the exception to be thrown\n-         * @return the result of the first subtask that completed with a result\n-         * @throws X if no subtask completed with a result\n-         * @throws IllegalStateException if the handle method was not invoked with a\n-         * completed subtask\n-         *\/\n-        public <X extends Throwable> T result(Function<Throwable, ? extends X> esf) throws X {\n-            Objects.requireNonNull(esf);\n-            Future<T> f = future;\n-            if (f == null) {\n-                throw new IllegalStateException(\"No completed subtasks\");\n-            }\n-            Future.State state = f.state();\n-            if (state == Future.State.SUCCESS) {\n-                return f.resultNow();\n-            } else {\n-                Throwable throwable = (state == Future.State.FAILED)\n-                        ? f.exceptionNow()\n-                        : new CancellationException();\n-                X ex = esf.apply(throwable);\n-                Objects.requireNonNull(ex, \"esf returned null\");\n-                throw ex;\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * A {@code StructuredTaskScope} that captures the exception of the first subtask to\n-     * complete abnormally. Once captured, it invokes the {@linkplain #shutdown() shutdown}\n-     * method to interrupt unfinished threads and wakeup the owner. The policy implemented\n-     * by this class is intended for cases where the results for all subtasks are required\n-     * (\"invoke all\"); if any subtask fails then the results of other unfinished subtasks\n-     * are no longer needed.\n-     *\n-     * <p> Unless otherwise specified, passing a {@code null} argument to a method\n-     * in this class will cause a {@link NullPointerException} to be thrown.\n-     *\n-     * @since 19\n-     *\/\n-    public static final class ShutdownOnFailure extends StructuredTaskScope<Object> {\n-        private static final VarHandle FUTURE;\n-        static {\n-            try {\n-                MethodHandles.Lookup l = MethodHandles.lookup();\n-                FUTURE = l.findVarHandle(ShutdownOnFailure.class, \"future\", Future.class);\n-            } catch (Exception e) {\n-                throw new InternalError(e);\n-            }\n-        }\n-        private volatile Future<Object> future;\n-\n-        \/**\n-         * Constructs a new {@code ShutdownOnFailure} with the given name and thread factory.\n-         * The task scope is optionally named for the purposes of monitoring and management.\n-         * The thread factory is used to {@link ThreadFactory#newThread(Runnable) create}\n-         * threads when tasks are {@linkplain #fork(Callable) forked}. The task scope\n-         * is owned by the current thread.\n-         *\n-         * <p> This method captures the current thread's {@linkplain ScopedValue scoped value}\n-         * bindings for inheritance by threads created in the task scope. The\n-         * <a href=\"StructuredTaskScope.html#TreeStructure\">Tree Structure<\/a> section in\n-         * the class description details how parent-child relations are established\n-         * implicitly for the purpose of inheritance of scoped value bindings.\n-         *\n-         * @param name the name of the task scope, can be null\n-         * @param factory the thread factory\n-         *\/\n-        public ShutdownOnFailure(String name, ThreadFactory factory) {\n-            super(name, factory);\n-        }\n-\n-        \/**\n-         * Constructs a new unnamed {@code ShutdownOnFailure} that creates virtual threads.\n-         *\n-         * <p> This constructor is equivalent to invoking the 2-arg constructor with a\n-         * name of {@code null} and a thread factory that creates virtual threads.\n-         *\/\n-        public ShutdownOnFailure() {\n-            super(null, Thread.ofVirtual().factory());\n-        }\n-\n-        \/**\n-         * Shut down the given task scope when invoked for the first time with a {@code\n-         * Future} for a task that completed abnormally (exception or cancelled).\n-         *\n-         * @param future the completed task\n-         * @see #shutdown()\n-         * @see Future.State#FAILED\n-         * @see Future.State#CANCELLED\n-         *\/\n-        @Override\n-        protected void handleComplete(Future<Object> future) {\n-            Future.State state = future.state();\n-            if (state == Future.State.RUNNING) {\n-                throw new IllegalArgumentException(\"Task is not completed\");\n-            } else if (state == Future.State.SUCCESS) {\n-                return;\n-            }\n-\n-            \/\/ A failed task overrides a cancelled task.\n-            \/\/ The first failed or cancelled task causes the scope to shutdown.\n-            Future<Object> f;\n-            while (((f = this.future) == null)\n-                    || FUTURE_STATE_COMPARATOR.compare(f.state(), state) < 0) {\n-                if (FUTURE.compareAndSet(this, f, future)) {\n-                    shutdown();\n-                    break;\n-                }\n-            }\n-        }\n-\n-        \/**\n-         * {@inheritDoc}\n-         * @return this task scope\n-         * @throws IllegalStateException {@inheritDoc}\n-         * @throws WrongThreadException {@inheritDoc}\n-         *\/\n-        @Override\n-        public ShutdownOnFailure join() throws InterruptedException {\n-            super.join();\n-            return this;\n-        }\n-\n-        \/**\n-         * {@inheritDoc}\n-         * @return this task scope\n-         * @throws IllegalStateException {@inheritDoc}\n-         * @throws WrongThreadException {@inheritDoc}\n-         *\/\n-        @Override\n-        public ShutdownOnFailure joinUntil(Instant deadline)\n-            throws InterruptedException, TimeoutException\n-        {\n-            super.joinUntil(deadline);\n-            return this;\n-        }\n-\n-        \/**\n-         * Returns the exception for the first subtask that completed with an exception.\n-         * If no subtask completed with an exception but cancelled subtasks were notified\n-         * to the {@code handleComplete} method then a {@code CancellationException}\n-         * is returned. If no subtasks completed abnormally then an empty {@code Optional}\n-         * is returned.\n-         *\n-         * @apiNote This method is intended to be invoked by the task scope owner after it\n-         * has invoked {@link #join() join} (or {@link #joinUntil(Instant) joinUntil}).\n-         * A future release may add enforcement to prevent the method being called by\n-         * other threads or before joining.\n-         *\n-         * @return the exception for a subtask that completed abnormally or an empty\n-         * optional if no subtasks completed abnormally\n-         *\/\n-        public Optional<Throwable> exception() {\n-            Future<Object> f = future;\n-            if (f != null) {\n-                Throwable throwable = (f.state() == Future.State.FAILED)\n-                        ? f.exceptionNow()\n-                        : new CancellationException();\n-                return Optional.of(throwable);\n-            } else {\n-                return Optional.empty();\n-            }\n-        }\n-\n-        \/**\n-         * Throws if a subtask completed abnormally. If any subtask completed with an\n-         * exception then {@code ExecutionException} is thrown with the exception of the\n-         * first subtask to fail as the {@linkplain Throwable#getCause() cause}. If no\n-         * subtask completed with an exception but cancelled subtasks were notified to the\n-         * {@code handleComplete} method then {@code CancellationException} is thrown.\n-         * This method does nothing if no subtasks completed abnormally.\n-         *\n-         * @apiNote This method is intended to be invoked by the task scope owner after it\n-         * has invoked {@link #join() join} (or {@link #joinUntil(Instant) joinUntil}).\n-         * A future release may add enforcement to prevent the method being called by\n-         * other threads or before joining.\n-         *\n-         * @throws ExecutionException if a subtask completed with an exception\n-         * @throws CancellationException if no subtasks completed with an exception but\n-         * subtasks were cancelled\n-         *\/\n-        public void throwIfFailed() throws ExecutionException {\n-            Future<Object> f = future;\n-            if (f != null) {\n-                if (f.state() == Future.State.FAILED) {\n-                    throw new ExecutionException(f.exceptionNow());\n-                } else {\n-                    throw new CancellationException();\n-                }\n-            }\n-        }\n-\n-        \/**\n-         * Throws the exception produced by the given exception supplying function if\n-         * a subtask completed abnormally. If any subtask completed with an exception then\n-         * the function is invoked with the exception of the first subtask to fail.\n-         * If no subtask completed with an exception but cancelled subtasks were notified\n-         * to the {@code handleComplete} method then the function is called with a {@code\n-         * CancellationException}. The exception returned by the function is thrown.\n-         * This method does nothing if no subtasks completed abnormally.\n-         *\n-         * @apiNote This method is intended to be invoked by the task scope owner after it\n-         * has invoked {@link #join() join} (or {@link #joinUntil(Instant) joinUntil}).\n-         * A future release may add enforcement to prevent the method being called by\n-         * other threads or before joining.\n-         *\n-         * @param esf the exception supplying function\n-         * @param <X> type of the exception to be thrown\n-         * @throws X produced by the exception supplying function\n-         *\/\n-        public <X extends Throwable>\n-        void throwIfFailed(Function<Throwable, ? extends X> esf) throws X {\n-            Objects.requireNonNull(esf);\n-            Future<Object> f = future;\n-            if (f != null) {\n-                Throwable throwable = (f.state() == Future.State.FAILED)\n-                        ? f.exceptionNow()\n-                        : new CancellationException();\n-                X ex = esf.apply(throwable);\n-                Objects.requireNonNull(ex, \"esf returned null\");\n-                throw ex;\n-            }\n-        }\n-    }\n-}\n","filename":"src\/jdk.incubator.concurrent\/share\/classes\/jdk\/incubator\/concurrent\/StructuredTaskScope.java","additions":0,"deletions":1223,"binary":false,"changes":1223,"status":"deleted"},{"patch":"@@ -1,30 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * Defines non-final APIs for concurrent programming.\n- * {@Incubating}\n- *\/\n-package jdk.incubator.concurrent;\n","filename":"src\/jdk.incubator.concurrent\/share\/classes\/jdk\/incubator\/concurrent\/package-info.java","additions":0,"deletions":30,"binary":false,"changes":30,"status":"deleted"},{"patch":"@@ -1,35 +0,0 @@\n-\/*\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * Defines non-final APIs for concurrent programming.\n- * {@Incubating}\n- *\n- * @moduleGraph\n- *\/\n-module jdk.incubator.concurrent {\n-    exports jdk.incubator.concurrent;\n-}\n-\n","filename":"src\/jdk.incubator.concurrent\/share\/classes\/module-info.java","additions":0,"deletions":35,"binary":false,"changes":35,"status":"deleted"},{"patch":"@@ -491,0 +491,2 @@\n+java\/lang\/ScopedValue\/StressStackOverflow.java                  8303498 linux-s390x\n+\n@@ -743,3 +745,0 @@\n-\n-jdk\/incubator\/concurrent\/ScopedValue\/StressStackOverflow.java   8303498 linux-s390x\n-\n","filename":"test\/jdk\/ProblemList.txt","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -282,1 +282,0 @@\n-    jdk\/incubator\/concurrent \\\n@@ -322,1 +321,0 @@\n-    jdk\/incubator\/concurrent \\\n","filename":"test\/jdk\/TEST.groups","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,2 +26,2 @@\n- * @summary Stress test ScopedValue with many bindings and rebinings\n- * @modules jdk.incubator.concurrent\n+ * @summary Stress test ScopedValue with many bindings and rebindings\n+ * @enablePreview\n@@ -33,2 +33,1 @@\n-import jdk.incubator.concurrent.ScopedValue;\n-import jdk.incubator.concurrent.ScopedValue.Carrier;\n+import java.lang.ScopedValue.Carrier;\n@@ -132,1 +131,1 @@\n-        \/\/ check that the scoped values have the origina values\n+        \/\/ check that the scoped values have the original values\n","filename":"test\/jdk\/java\/lang\/ScopedValue\/ManyBindings.java","additions":4,"deletions":5,"binary":false,"changes":9,"previous_filename":"test\/jdk\/jdk\/incubator\/concurrent\/ScopedValue\/ManyBindings.java","status":"renamed"},{"patch":"@@ -0,0 +1,561 @@\n+\/*\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test ScopedValue API\n+ * @enablePreview\n+ * @run junit ScopedValueAPI\n+ *\/\n+\n+import java.util.NoSuchElementException;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class ScopedValueAPI {\n+\n+    private static Stream<ThreadFactory> factories() {\n+        return Stream.of(Thread.ofPlatform().factory(), Thread.ofVirtual().factory());\n+    }\n+\n+    \/**\n+     * Test that the run method is invoked.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testRun(ThreadFactory factory) throws Exception {\n+        test(factory, () -> {\n+            class Box { static boolean executed; }\n+            ScopedValue<String> name = ScopedValue.newInstance();\n+            ScopedValue.runWhere(name, \"duke\", () -> { Box.executed = true; });\n+            assertTrue(Box.executed);\n+        });\n+    }\n+\n+    \/**\n+     * Test the run method throwing an exception.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testRunThrows(ThreadFactory factory) throws Exception {\n+        test(factory, () -> {\n+            class FooException extends RuntimeException {  }\n+            ScopedValue<String> name = ScopedValue.newInstance();\n+            Runnable op = () -> { throw new FooException(); };\n+            assertThrows(FooException.class, () -> ScopedValue.runWhere(name, \"duke\", op));\n+            assertFalse(name.isBound());\n+        });\n+    }\n+\n+    \/**\n+     * Test that the call method is invoked.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testCall(ThreadFactory factory) throws Exception {\n+        test(factory, () -> {\n+            ScopedValue<String> name = ScopedValue.newInstance();\n+            String result = ScopedValue.callWhere(name, \"duke\", name::get);\n+            assertEquals(\"duke\", result);\n+        });\n+    }\n+\n+    \/**\n+     * Test that the get method is invoked.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testGetWhere(ThreadFactory factory) throws Exception {\n+        test(factory, () -> {\n+            ScopedValue<String> name = ScopedValue.newInstance();\n+            String result = ScopedValue.getWhere(name, \"duke\", (Supplier<String>)(name::get));\n+            assertEquals(\"duke\", result);\n+        });\n+    }\n+\n+    \/**\n+     * Test the call method throwing an exception.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testCallThrows(ThreadFactory factory) throws Exception {\n+        test(factory, () -> {\n+            class FooException extends RuntimeException {  }\n+            ScopedValue<String> name = ScopedValue.newInstance();\n+            Callable<Void> op = () -> { throw new FooException(); };\n+            assertThrows(FooException.class, () -> ScopedValue.callWhere(name, \"duke\", op));\n+            assertFalse(name.isBound());\n+        });\n+    }\n+\n+    \/**\n+     * Test the get(Supplier) method throwing an exception.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testGetThrows(ThreadFactory factory) throws Exception {\n+        test(factory, () -> {\n+            class FooException extends RuntimeException {  }\n+            ScopedValue<String> name = ScopedValue.newInstance();\n+            Supplier<Void> op = () -> { throw new FooException(); };\n+            assertThrows(FooException.class, () -> ScopedValue.getWhere(name, \"duke\", op));\n+            assertFalse(name.isBound());\n+        });\n+    }\n+\n+    \/**\n+     * Test get method.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testGet(ThreadFactory factory) throws Exception {\n+        test(factory, () -> {\n+            ScopedValue<String> name1 = ScopedValue.newInstance();\n+            ScopedValue<String> name2 = ScopedValue.newInstance();\n+            assertThrows(NoSuchElementException.class, name1::get);\n+            assertThrows(NoSuchElementException.class, name2::get);\n+\n+            \/\/ run\n+            ScopedValue.runWhere(name1, \"duke\", () -> {\n+                assertEquals(\"duke\", name1.get());\n+                assertThrows(NoSuchElementException.class, name2::get);\n+\n+            });\n+            assertThrows(NoSuchElementException.class, name1::get);\n+            assertThrows(NoSuchElementException.class, name2::get);\n+\n+            \/\/ call\n+            ScopedValue.callWhere(name1, \"duke\", () -> {\n+                assertEquals(\"duke\", name1.get());\n+                assertThrows(NoSuchElementException.class, name2::get);\n+                return null;\n+            });\n+            assertThrows(NoSuchElementException.class, name1::get);\n+            assertThrows(NoSuchElementException.class, name2::get);\n+\n+            \/\/ get\n+            ScopedValue.getWhere(name1, \"duke\", () -> {\n+                assertEquals(\"duke\", name1.get());\n+                assertThrows(NoSuchElementException.class, name2::get);\n+                return null;\n+            });\n+            assertThrows(NoSuchElementException.class, name1::get);\n+            assertThrows(NoSuchElementException.class, name2::get);\n+        });\n+    }\n+\n+    \/**\n+     * Test isBound method.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testIsBound(ThreadFactory factory) throws Exception {\n+        test(factory, () -> {\n+            ScopedValue<String> name1 = ScopedValue.newInstance();\n+            ScopedValue<String> name2 = ScopedValue.newInstance();\n+            assertFalse(name1.isBound());\n+            assertFalse(name2.isBound());\n+\n+            \/\/ run\n+            ScopedValue.runWhere(name1, \"duke\", () -> {\n+                assertTrue(name1.isBound());\n+                assertFalse(name2.isBound());\n+            });\n+            assertFalse(name1.isBound());\n+            assertFalse(name2.isBound());\n+\n+            \/\/ call\n+            ScopedValue.callWhere(name1, \"duke\", () -> {\n+                assertTrue(name1.isBound());\n+                assertFalse(name2.isBound());\n+                return null;\n+            });\n+            assertFalse(name1.isBound());\n+            assertFalse(name2.isBound());\n+\n+            \/\/ call\n+            ScopedValue.callWhere(name1, \"duke\", () -> {\n+                assertTrue(name1.isBound());\n+                assertFalse(name2.isBound());\n+                return null;\n+            });\n+            assertFalse(name1.isBound());\n+            assertFalse(name2.isBound());\n+        });\n+    }\n+\n+    \/**\n+     * Test orElse method.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testOrElse(ThreadFactory factory) throws Exception {\n+        test(factory, () -> {\n+            ScopedValue<String> name = ScopedValue.newInstance();\n+            assertNull(name.orElse(null));\n+            assertEquals(\"default\", name.orElse(\"default\"));\n+\n+            \/\/ run\n+            ScopedValue.runWhere(name, \"duke\", () -> {\n+                assertEquals(\"duke\", name.orElse(null));\n+                assertEquals(\"duke\", name.orElse(\"default\"));\n+            });\n+\n+            \/\/ call\n+            ScopedValue.callWhere(name, \"duke\", () -> {\n+                assertEquals(\"duke\", name.orElse(null));\n+                assertEquals(\"duke\", name.orElse(\"default\"));\n+                return null;\n+            });\n+        });\n+    }\n+\n+    \/**\n+     * Test orElseThrow method.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testOrElseThrow(ThreadFactory factory) throws Exception {\n+        test(factory, () -> {\n+            class FooException extends RuntimeException { }\n+            ScopedValue<String> name = ScopedValue.newInstance();\n+            assertThrows(FooException.class, () -> name.orElseThrow(FooException::new));\n+\n+            \/\/ run\n+            ScopedValue.runWhere(name, \"duke\", () -> {\n+                assertEquals(\"duke\", name.orElseThrow(FooException::new));\n+            });\n+\n+            \/\/ call\n+            ScopedValue.callWhere(name, \"duke\", () -> {\n+                assertEquals(\"duke\", name.orElseThrow(FooException::new));\n+                return null;\n+            });\n+        });\n+    }\n+\n+    \/**\n+     * Test two bindings.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testTwoBindings(ThreadFactory factory) throws Exception {\n+        test(factory, () -> {\n+            ScopedValue<String> name = ScopedValue.newInstance();\n+            ScopedValue<Integer> age = ScopedValue.newInstance();\n+\n+            \/\/ run\n+            ScopedValue.where(name, \"duke\").where(age, 100).run(() -> {\n+                assertTrue(name.isBound());\n+                assertTrue(age.isBound());\n+                assertEquals(\"duke\", name.get());\n+                assertEquals(100, (int) age.get());\n+            });\n+            assertFalse(name.isBound());\n+            assertFalse(age.isBound());\n+\n+            \/\/ call\n+            ScopedValue.where(name, \"duke\").where(age, 100).call(() -> {\n+                assertTrue(name.isBound());\n+                assertTrue(age.isBound());\n+                assertEquals(\"duke\", name.get());\n+                assertEquals(100, (int) age.get());\n+                return null;\n+            });\n+            assertFalse(name.isBound());\n+            assertFalse(age.isBound());\n+\n+            \/\/ get\n+            ScopedValue.where(name, \"duke\").where(age, 100).get(() -> {\n+                assertTrue(name.isBound());\n+                assertTrue(age.isBound());\n+                assertEquals(\"duke\", name.get());\n+                assertEquals(100, (int) age.get());\n+                return null;\n+            });\n+            assertFalse(name.isBound());\n+            assertFalse(age.isBound());\n+\n+        });\n+    }\n+\n+    \/**\n+     * Test rebinding.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testRebinding(ThreadFactory factory) throws Exception {\n+        test(factory, () -> {\n+            ScopedValue<String> name = ScopedValue.newInstance();\n+\n+            \/\/ run\n+            ScopedValue.runWhere(name, \"duke\", () -> {\n+                assertTrue(name.isBound());\n+                assertEquals(\"duke\", name.get());\n+\n+                ScopedValue.runWhere(name, \"duchess\", () -> {\n+                    assertTrue(name.isBound());\n+                    assertEquals(\"duchess\", name.get());\n+                });\n+\n+                assertTrue(name.isBound());\n+                assertEquals(\"duke\", name.get());\n+            });\n+            assertFalse(name.isBound());\n+\n+            \/\/ call\n+            ScopedValue.callWhere(name, \"duke\", () -> {\n+                assertTrue(name.isBound());\n+                assertEquals(\"duke\", name.get());\n+\n+                ScopedValue.callWhere(name, \"duchess\", () -> {\n+                    assertTrue(name.isBound());\n+                    assertEquals(\"duchess\", name.get());\n+                    return null;\n+                });\n+\n+                assertTrue(name.isBound());\n+                assertEquals(\"duke\", name.get());\n+                return null;\n+            });\n+            assertFalse(name.isBound());\n+\n+            \/\/ get\n+            ScopedValue.getWhere(name, \"duke\", () -> {\n+                assertTrue(name.isBound());\n+                assertEquals(\"duke\", name.get());\n+\n+                ScopedValue.where(name, \"duchess\").get(() -> {\n+                    assertTrue(name.isBound());\n+                    assertEquals(\"duchess\", name.get());\n+                    return null;\n+                });\n+\n+                assertTrue(name.isBound());\n+                assertEquals(\"duke\", name.get());\n+                return null;\n+            });\n+            assertFalse(name.isBound());\n+        });\n+    }\n+\n+    \/**\n+     * Test rebinding from null vaue to another value.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testRebindingFromNull(ThreadFactory factory) throws Exception {\n+        test(factory, () -> {\n+            ScopedValue<String> name = ScopedValue.newInstance();\n+\n+            \/\/ run\n+            ScopedValue.runWhere(name, null, () -> {\n+                assertTrue(name.isBound());\n+                assertNull(name.get());\n+\n+                ScopedValue.runWhere(name, \"duchess\", () -> {\n+                    assertTrue(name.isBound());\n+                    assertTrue(\"duchess\".equals(name.get()));\n+                });\n+\n+                assertTrue(name.isBound());\n+                assertNull(name.get());\n+            });\n+            assertFalse(name.isBound());\n+\n+            \/\/ call\n+            ScopedValue.callWhere(name, null, () -> {\n+                assertTrue(name.isBound());\n+                assertNull(name.get());\n+\n+                ScopedValue.callWhere(name, \"duchess\", () -> {\n+                    assertTrue(name.isBound());\n+                    assertTrue(\"duchess\".equals(name.get()));\n+                    return null;\n+                });\n+\n+                assertTrue(name.isBound());\n+                assertNull(name.get());\n+                return null;\n+            });\n+            assertFalse(name.isBound());\n+\n+            \/\/ getWhere\n+            ScopedValue.getWhere(name, null, () -> {\n+                assertTrue(name.isBound());\n+                assertNull(name.get());\n+\n+                ScopedValue.getWhere(name, \"duchess\", () -> {\n+                    assertTrue(name.isBound());\n+                    assertTrue(\"duchess\".equals(name.get()));\n+                    return null;\n+                });\n+\n+                assertTrue(name.isBound());\n+                assertNull(name.get());\n+                return null;\n+            });\n+            assertFalse(name.isBound());\n+        });\n+    }\n+\n+    \/**\n+     * Test rebinding to null value.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testRebindingToNull(ThreadFactory factory) throws Exception {\n+        test(factory, () -> {\n+            ScopedValue<String> name = ScopedValue.newInstance();\n+\n+            \/\/ run\n+            ScopedValue.runWhere(name, \"duke\", () -> {\n+                assertTrue(name.isBound());\n+                assertEquals(\"duke\", name.get());\n+\n+                ScopedValue.runWhere(name, null, () -> {\n+                    assertTrue(name.isBound());\n+                    assertNull(name.get());\n+                });\n+\n+                assertTrue(name.isBound());\n+                assertEquals(\"duke\", name.get());\n+            });\n+            assertFalse(name.isBound());\n+\n+            \/\/ call\n+            ScopedValue.callWhere(name, \"duke\", () -> {\n+                assertTrue(name.isBound());\n+                assertEquals(\"duke\", name.get());\n+\n+                ScopedValue.callWhere(name, null, () -> {\n+                    assertTrue(name.isBound());\n+                    assertNull(name.get());\n+                    return null;\n+                });\n+\n+                assertTrue(name.isBound());\n+                assertEquals(\"duke\", name.get());\n+                return null;\n+            });\n+            assertFalse(name.isBound());\n+\n+            \/\/ get\n+            ScopedValue.where(name, \"duke\").get(() -> {\n+                assertTrue(name.isBound());\n+                assertEquals(\"duke\", name.get());\n+\n+                ScopedValue.where(name, null).get(() -> {\n+                    assertTrue(name.isBound());\n+                    assertNull(name.get());\n+                    return null;\n+                });\n+\n+                assertTrue(name.isBound());\n+                assertEquals(\"duke\", name.get());\n+                return null;\n+            });\n+            assertFalse(name.isBound());\n+        });\n+    }\n+\n+    \/**\n+     * Test Carrier.get.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testCarrierGet(ThreadFactory factory) throws Exception {\n+        test(factory, () -> {\n+            ScopedValue<String> name = ScopedValue.newInstance();\n+            ScopedValue<Integer> age = ScopedValue.newInstance();\n+\n+            \/\/ one scoped value\n+            var carrier1 = ScopedValue.where(name, \"duke\");\n+            assertEquals(\"duke\", carrier1.get(name));\n+            assertThrows(NoSuchElementException.class, () -> carrier1.get(age));\n+\n+            \/\/ two scoped values\n+            var carrier2 = carrier1.where(age, 20);\n+            assertEquals(\"duke\", carrier2.get(name));\n+            assertEquals(20, (int) carrier2.get(age));\n+        });\n+    }\n+\n+    \/**\n+     * Test NullPointerException.\n+     *\/\n+    @Test\n+    void testNullPointerException() {\n+        ScopedValue<String> name = ScopedValue.newInstance();\n+\n+        assertThrows(NullPointerException.class, () -> ScopedValue.where(null, \"value\"));\n+        assertThrows(NullPointerException.class, () -> ScopedValue.runWhere(null, \"value\", () -> { }));\n+        assertThrows(NullPointerException.class, () -> ScopedValue.getWhere(null, \"value\", () -> null));\n+\n+        assertThrows(NullPointerException.class, () -> name.orElseThrow(null));\n+\n+        var carrier = ScopedValue.where(name, \"duke\");\n+        assertThrows(NullPointerException.class, () -> carrier.where(null, \"value\"));\n+        assertThrows(NullPointerException.class, () -> carrier.get((ScopedValue<?>)null));\n+        assertThrows(NullPointerException.class, () -> carrier.get((Supplier<?>)null));\n+        assertThrows(NullPointerException.class, () -> carrier.run(null));\n+        assertThrows(NullPointerException.class, () -> carrier.call(null));\n+    }\n+\n+    @FunctionalInterface\n+    private interface ThrowingRunnable {\n+        void run() throws Exception;\n+    }\n+\n+    \/**\n+     * Run the given task in a thread created with the given thread factory.\n+     * @throws Exception if the task throws an exception\n+     *\/\n+    private static void test(ThreadFactory factory, ThrowingRunnable task) throws Exception {\n+        try (var executor = Executors.newThreadPerTaskExecutor(factory)) {\n+            var future = executor.submit(() -> {\n+                task.run();\n+                return null;\n+            });\n+            try {\n+                future.get();\n+            } catch (ExecutionException ee) {\n+                Throwable cause = ee.getCause();\n+                if (cause instanceof Exception e)\n+                    throw e;\n+                if (cause instanceof Error e)\n+                    throw e;\n+                throw new RuntimeException(cause);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/ScopedValue\/ScopedValueAPI.java","additions":561,"deletions":0,"binary":false,"changes":561,"status":"added"},{"patch":"@@ -27,2 +27,1 @@\n- * @modules jdk.incubator.concurrent\n- * @compile StressStackOverflow.java\n+ * @enablePreview\n@@ -37,3 +36,3 @@\n-import jdk.incubator.concurrent.ScopedValue;\n-import jdk.incubator.concurrent.StructureViolationException;\n-import jdk.incubator.concurrent.StructuredTaskScope;\n+import java.util.concurrent.StructureViolationException;\n+import java.util.concurrent.StructuredTaskScope;\n+import java.util.function.Supplier;\n@@ -56,1 +55,9 @@\n-    class DeepRecursion implements Callable, Runnable {\n+    class DeepRecursion implements Callable, Supplier, Runnable {\n+\n+        static enum Behaviour {\n+            CALL, GET, RUN;\n+            private static Behaviour[] values = values();\n+            public static Behaviour choose(ThreadLocalRandom tlr) {\n+                return values[tlr.nextInt(3)];\n+            }\n+        }\n@@ -58,1 +65,0 @@\n-        static enum Behaviour {CALL, RUN}\n@@ -73,0 +79,2 @@\n+                    case GET ->\n+                        ScopedValue.where(el, el.get() + 1).get(() -> fibonacci_pad(20, this));\n@@ -99,1 +107,1 @@\n-        public Object call() {\n+        public Object get() {\n@@ -103,0 +111,4 @@\n+\n+        public Object call() {\n+            return get();\n+        }\n@@ -145,1 +157,1 @@\n-            var future = scope.fork(() -> {\n+            var handle = scope.fork(() -> {\n@@ -149,1 +161,0 @@\n-            future.get();\n@@ -151,0 +162,1 @@\n+            handle.get();\n@@ -162,1 +174,1 @@\n-                            \/\/ Repeatedly test Scoped Values set by ScopedValue::call() and ScopedValue::run()\n+                            \/\/ Repeatedly test Scoped Values set by ScopedValue::call(), get(), and run()\n@@ -164,1 +176,1 @@\n-                                    = new DeepRecursion(tlr.nextBoolean() ? DeepRecursion.Behaviour.CALL : DeepRecursion.Behaviour.RUN);\n+                                = new DeepRecursion(DeepRecursion.Behaviour.choose(tlr));\n","filename":"test\/jdk\/java\/lang\/ScopedValue\/StressStackOverflow.java","additions":24,"deletions":12,"binary":false,"changes":36,"previous_filename":"test\/jdk\/jdk\/incubator\/concurrent\/ScopedValue\/StressStackOverflow.java","status":"renamed"},{"patch":"@@ -0,0 +1,1712 @@\n+\/*\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test id=platform\n+ * @bug 8284199 8296779 8306647\n+ * @summary Basic tests for StructuredTaskScope\n+ * @enablePreview\n+ * @run junit\/othervm -DthreadFactory=platform StructuredTaskScopeTest\n+ *\/\n+\n+\/*\n+ * @test id=virtual\n+ * @enablePreview\n+ * @run junit\/othervm -DthreadFactory=virtual StructuredTaskScopeTest\n+ *\/\n+\n+import java.time.Duration;\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.Arrays;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.RejectedExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.StructuredTaskScope;\n+import java.util.concurrent.StructuredTaskScope.Subtask;\n+import java.util.concurrent.StructuredTaskScope.ShutdownOnSuccess;\n+import java.util.concurrent.StructuredTaskScope.ShutdownOnFailure;\n+import java.util.concurrent.StructureViolationException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+import static java.lang.Thread.State.*;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class StructuredTaskScopeTest {\n+    private static ScheduledExecutorService scheduler;\n+    private static List<ThreadFactory> threadFactories;\n+\n+    @BeforeAll\n+    static void setup() throws Exception {\n+        scheduler = Executors.newSingleThreadScheduledExecutor();\n+\n+        \/\/ thread factories\n+        String value = System.getProperty(\"threadFactory\");\n+        List<ThreadFactory> list = new ArrayList<>();\n+        if (value == null || value.equals(\"platform\"))\n+            list.add(Thread.ofPlatform().factory());\n+        if (value == null || value.equals(\"virtual\"))\n+            list.add(Thread.ofVirtual().factory());\n+        assertTrue(list.size() > 0, \"No thread factories for tests\");\n+        threadFactories = list;\n+    }\n+\n+    @AfterAll\n+    static void shutdown() {\n+        scheduler.shutdown();\n+    }\n+\n+    private static Stream<ThreadFactory> factories() {\n+        return threadFactories.stream();\n+    }\n+\n+    \/**\n+     * Test that fork creates a new thread for each task.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testForkCreatesThread(ThreadFactory factory) throws Exception {\n+        Set<Long> tids = ConcurrentHashMap.newKeySet();\n+        try (var scope = new StructuredTaskScope<Object>(null, factory)) {\n+            for (int i = 0; i < 100; i++) {\n+                scope.fork(() -> {\n+                    tids.add(Thread.currentThread().threadId());\n+                    return null;\n+                });\n+            }\n+            scope.join();\n+        }\n+        assertEquals(100, tids.size());\n+    }\n+\n+    \/**\n+     * Test that fork creates a new virtual thread for each task.\n+     *\/\n+    @Test\n+    void testForkCreateVirtualThread() throws Exception {\n+        Set<Thread> threads = ConcurrentHashMap.newKeySet();\n+        try (var scope = new StructuredTaskScope<Object>()) {\n+            for (int i = 0; i < 100; i++) {\n+                scope.fork(() -> {\n+                    threads.add(Thread.currentThread());\n+                    return null;\n+                });\n+            }\n+            scope.join();\n+        }\n+        assertEquals(100, threads.size());\n+        threads.forEach(t -> assertTrue(t.isVirtual()));\n+    }\n+\n+    \/**\n+     * Test that fork creates a new thread with the given thread factory.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testForkUsesFactory(ThreadFactory factory) throws Exception {\n+        var count = new AtomicInteger();\n+        ThreadFactory countingFactory = task -> {\n+            count.incrementAndGet();\n+            return factory.newThread(task);\n+        };\n+        try (var scope = new StructuredTaskScope<Object>(null, countingFactory)) {\n+            for (int i = 0; i < 100; i++) {\n+                scope.fork(() -> null);\n+            }\n+            scope.join();\n+        }\n+        assertEquals(100, count.get());\n+    }\n+\n+    \/**\n+     * Test fork is confined to threads in the scope \"tree\".\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testForkConfined(ThreadFactory factory) throws Exception {\n+        try (var scope1 = new StructuredTaskScope<Boolean>();\n+             var scope2 = new StructuredTaskScope<Boolean>()) {\n+\n+            \/\/ thread in scope1 cannot fork thread in scope2\n+            Subtask<Boolean> subtask1 = scope1.fork(() -> {\n+                assertThrows(WrongThreadException.class, () -> {\n+                    scope2.fork(() -> null);\n+                });\n+                return true;\n+            });\n+\n+            \/\/ thread in scope2 can fork thread in scope1\n+            Subtask<Boolean> subtask2 = scope2.fork(() -> {\n+                scope1.fork(() -> null);\n+                return true;\n+            });\n+\n+            scope2.join();\n+            scope1.join();\n+\n+            assertTrue(subtask1.get());\n+            assertTrue(subtask2.get());\n+\n+            \/\/ random thread cannot fork\n+            try (var pool = Executors.newSingleThreadExecutor()) {\n+                Future<Void> future = pool.submit(() -> {\n+                    assertThrows(WrongThreadException.class, () -> {\n+                        scope1.fork(() -> null);\n+                    });\n+                    assertThrows(WrongThreadException.class, () -> {\n+                        scope2.fork(() -> null);\n+                    });\n+                    return null;\n+                });\n+                future.get();\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test fork after join completes.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testForkAfterJoin(ThreadFactory factory) throws Exception {\n+        try (var scope = new StructuredTaskScope<String>(null, factory)) {\n+            \/\/ round 1\n+            var subtask1 = scope.fork(() -> \"foo\");\n+            assertThrows(IllegalStateException.class, subtask1::get);\n+            scope.join();\n+            assertEquals(\"foo\", subtask1.get());\n+\n+            \/\/ round 2\n+            var subtask2 = scope.fork(() -> \"bar\");\n+            assertEquals(\"foo\", subtask1.get());\n+            assertThrows(IllegalStateException.class, subtask2::get);\n+            scope.join();\n+            assertEquals(\"foo\", subtask1.get());\n+            assertEquals(\"bar\", subtask2.get());\n+\n+            \/\/ round 3\n+            var subtask3 = scope.fork(() -> \"baz\");\n+            assertEquals(\"foo\", subtask1.get());\n+            assertEquals(\"bar\", subtask2.get());\n+            assertThrows(IllegalStateException.class, subtask3::get);\n+            scope.join();\n+            assertEquals(\"foo\", subtask1.get());\n+            assertEquals(\"bar\", subtask2.get());\n+            assertEquals(\"baz\", subtask3.get());\n+        }\n+    }\n+\n+    \/**\n+     * Test fork after join throws.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testForkAfterJoinThrows(ThreadFactory factory) throws Exception {\n+        try (var scope = new StructuredTaskScope<String>(null, factory)) {\n+            var latch = new CountDownLatch(1);\n+            var subtask1 = scope.fork(() -> {\n+                latch.await();\n+                return \"foo\";\n+            });\n+\n+            \/\/ join throws\n+            Thread.currentThread().interrupt();\n+            assertThrows(InterruptedException.class, scope::join);\n+\n+            \/\/ allow subtask1 to finish\n+            latch.countDown();\n+\n+            \/\/ continue to fork\n+            var subtask2 = scope.fork(() -> \"bar\");\n+            assertThrows(IllegalStateException.class, subtask1::get);\n+            assertThrows(IllegalStateException.class, subtask2::get);\n+            scope.join();\n+            assertEquals(\"foo\", subtask1.get());\n+            assertEquals(\"bar\", subtask2.get());\n+        }\n+    }\n+\n+    \/**\n+     * Test fork after scope is shutdown.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testForkAfterShutdown(ThreadFactory factory) throws Exception {\n+        var executed = new AtomicBoolean();\n+        try (var scope = new StructuredTaskScope<Object>(null, factory)) {\n+            scope.shutdown();\n+            Subtask<String> subtask = scope.fork(() -> {\n+                executed.set(true);\n+                return null;\n+            });\n+            assertEquals(Subtask.State.UNAVAILABLE, subtask.state());\n+            assertThrows(IllegalStateException.class, subtask::get);\n+            assertThrows(IllegalStateException.class, subtask::exception);\n+        }\n+        assertFalse(executed.get());\n+    }\n+\n+    \/**\n+     * Test fork after scope is closed.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testForkAfterClose(ThreadFactory factory) throws Exception {\n+        try (var scope = new StructuredTaskScope<Object>(null, factory)) {\n+            scope.close();\n+            assertThrows(IllegalStateException.class, () -> scope.fork(() -> null));\n+        }\n+    }\n+\n+    \/**\n+     * Test fork when the thread factory rejects creating a thread.\n+     *\/\n+    @Test\n+    void testForkRejectedExecutionException() throws Exception {\n+        ThreadFactory factory = task -> null;\n+        try (var scope = new StructuredTaskScope(null, factory)) {\n+            assertThrows(RejectedExecutionException.class, () -> scope.fork(() -> null));\n+            scope.join();\n+        }\n+    }\n+\n+    \/**\n+     * Test join with no subtasks.\n+     *\/\n+    @Test\n+    void testJoinWithNoSubtasks() throws Exception {\n+        try (var scope = new StructuredTaskScope()) {\n+            scope.join();\n+        }\n+    }\n+\n+    \/**\n+     * Test join with unfinished subtasks.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testJoinWithSubtasks(ThreadFactory factory) throws Exception {\n+        try (var scope = new StructuredTaskScope(null, factory)) {\n+            Subtask<String> subtask = scope.fork(() -> {\n+                Thread.sleep(Duration.ofMillis(50));\n+                return \"foo\";\n+            });\n+            scope.join();\n+            assertEquals(\"foo\", subtask.get());\n+        }\n+    }\n+\n+    \/**\n+     * Test join is owner confined.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testJoinConfined(ThreadFactory factory) throws Exception {\n+        try (var scope = new StructuredTaskScope<Boolean>()) {\n+\n+            \/\/ thread in scope cannot join\n+            Subtask<Boolean> subtask = scope.fork(() -> {\n+                assertThrows(WrongThreadException.class, () -> { scope.join(); });\n+                return true;\n+            });\n+\n+            scope.join();\n+\n+            assertTrue(subtask.get());\n+\n+            \/\/ random thread cannot join\n+            try (var pool = Executors.newSingleThreadExecutor()) {\n+                Future<Void> future = pool.submit(() -> {\n+                    assertThrows(WrongThreadException.class, scope::join);\n+                    return null;\n+                });\n+                future.get();\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test join with interrupt status set.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testInterruptJoin1(ThreadFactory factory) throws Exception {\n+        try (var scope = new StructuredTaskScope(null, factory)) {\n+            var latch = new CountDownLatch(1);\n+\n+            Subtask<String> subtask = scope.fork(() -> {\n+                latch.await();\n+                return \"foo\";\n+            });\n+\n+            \/\/ join should throw\n+            Thread.currentThread().interrupt();\n+            try {\n+                scope.join();\n+                fail(\"join did not throw\");\n+            } catch (InterruptedException expected) {\n+                assertFalse(Thread.interrupted());   \/\/ interrupt status should be clear\n+            } finally {\n+                \/\/ let task continue\n+                latch.countDown();\n+            }\n+\n+            \/\/ join should complete\n+            scope.join();\n+            assertEquals(\"foo\", subtask.get());\n+        }\n+    }\n+\n+    \/**\n+     * Test interrupt of thread blocked in join.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testInterruptJoin2(ThreadFactory factory) throws Exception {\n+        try (var scope = new StructuredTaskScope(null, factory)) {\n+            var latch = new CountDownLatch(1);\n+            Subtask<String> subtask = scope.fork(() -> {\n+                latch.await();\n+                return \"foo\";\n+            });\n+\n+            \/\/ join should throw\n+            scheduleInterruptAt(\"java.util.concurrent.StructuredTaskScope.join\");\n+            try {\n+                scope.join();\n+                fail(\"join did not throw\");\n+            } catch (InterruptedException expected) {\n+                assertFalse(Thread.interrupted());   \/\/ interrupt status should be clear\n+            } finally {\n+                \/\/ let task continue\n+                latch.countDown();\n+            }\n+\n+            \/\/ join should complete\n+            scope.join();\n+            assertEquals(\"foo\", subtask.get());\n+        }\n+    }\n+\n+    \/**\n+     * Test join when scope is shutdown.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testJoinWithShutdown1(ThreadFactory factory) throws Exception {\n+        try (var scope = new StructuredTaskScope<String>(null, factory)) {\n+            var interrupted = new CountDownLatch(1);\n+            var finish = new CountDownLatch(1);\n+\n+            Subtask<String> subtask = scope.fork(() -> {\n+                try {\n+                    Thread.sleep(Duration.ofDays(1));\n+                } catch (InterruptedException e) {\n+                    interrupted.countDown();\n+                }\n+                finish.await();\n+                return \"foo\";\n+            });\n+\n+            scope.shutdown();      \/\/ should interrupt task\n+\n+            interrupted.await();\n+\n+            scope.join();\n+\n+            \/\/ signal task to finish\n+            finish.countDown();\n+        }\n+    }\n+\n+    \/**\n+     * Test shutdown when owner is blocked in join.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testJoinWithShutdown2(ThreadFactory factory) throws Exception {\n+        class MyScope<T> extends StructuredTaskScope<T> {\n+            MyScope(ThreadFactory factory) {\n+                super(null, factory);\n+            }\n+            @Override\n+            protected void handleComplete(Subtask<? extends T> subtask) {\n+                shutdown();\n+            }\n+        }\n+\n+        try (var scope = new MyScope<String>(factory)) {\n+            Subtask<String> subtask1 = scope.fork(() -> {\n+                Thread.sleep(Duration.ofMillis(50));\n+                return \"foo\";\n+            });\n+            Subtask<String> subtask2 = scope.fork(() -> {\n+                Thread.sleep(Duration.ofDays(1));\n+                return \"bar\";\n+            });\n+\n+            \/\/ join should wakeup when shutdown is called\n+            scope.join();\n+\n+            \/\/ task1 should have completed successfully\n+            assertEquals(Subtask.State.SUCCESS, subtask1.state());\n+            assertEquals(\"foo\", subtask1.get());\n+            assertThrows(IllegalStateException.class, subtask1::exception);\n+\n+            \/\/ task2 result\/exception not available\n+            assertEquals(Subtask.State.UNAVAILABLE, subtask2.state());\n+            assertThrows(IllegalStateException.class, subtask2::get);\n+            assertThrows(IllegalStateException.class, subtask2::exception);\n+        }\n+    }\n+\n+    \/**\n+     * Test join after scope is closed.\n+     *\/\n+    @Test\n+    void testJoinAfterClose() throws Exception {\n+        try (var scope = new StructuredTaskScope()) {\n+            scope.join();\n+            scope.close();\n+            assertThrows(IllegalStateException.class, () -> scope.join());\n+            assertThrows(IllegalStateException.class, () -> scope.joinUntil(Instant.now()));\n+        }\n+    }\n+\n+    \/**\n+     * Test joinUntil, subtasks finish before deadline expires.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testJoinUntil1(ThreadFactory factory) throws Exception {\n+        try (var scope = new StructuredTaskScope<String>(null, factory)) {\n+            Subtask<String> subtask = scope.fork(() -> {\n+                try {\n+                    Thread.sleep(Duration.ofSeconds(2));\n+                } catch (InterruptedException e) { }\n+                return \"foo\";\n+            });\n+\n+            long startMillis = millisTime();\n+            scope.joinUntil(Instant.now().plusSeconds(30));\n+            expectDuration(startMillis, \/*min*\/1900, \/*max*\/20_000);\n+            assertEquals(\"foo\", subtask.get());\n+        }\n+    }\n+\n+    \/**\n+     * Test joinUntil, deadline expires before subtasks finish.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testJoinUntil2(ThreadFactory factory) throws Exception {\n+        try (var scope = new StructuredTaskScope<Object>(null, factory)) {\n+            Subtask<Void> subtask = scope.fork(() -> {\n+                Thread.sleep(Duration.ofDays(1));\n+                return null;\n+            });\n+\n+            long startMillis = millisTime();\n+            try {\n+                scope.joinUntil(Instant.now().plusSeconds(2));\n+            } catch (TimeoutException e) {\n+                expectDuration(startMillis, \/*min*\/1900, \/*max*\/20_000);\n+            }\n+            assertEquals(Subtask.State.UNAVAILABLE, subtask.state());\n+        }\n+    }\n+\n+    \/**\n+     * Test joinUntil many times.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testJoinUntil3(ThreadFactory factory) throws Exception {\n+        try (var scope = new StructuredTaskScope<String>(null, factory)) {\n+            Subtask<String> subtask = scope.fork(() -> {\n+                Thread.sleep(Duration.ofDays(1));\n+                return null;\n+            });\n+\n+            for (int i = 0; i < 3; i++) {\n+                try {\n+                    scope.joinUntil(Instant.now().plusMillis(50));\n+                    fail(\"joinUntil did not throw\");\n+                } catch (TimeoutException expected) {\n+                    assertEquals(Subtask.State.UNAVAILABLE, subtask.state());\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test joinUntil with a deadline that has already expired.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testJoinUntil4(ThreadFactory factory) throws Exception {\n+        try (var scope = new StructuredTaskScope<Object>(null, factory)) {\n+            Subtask<Void> subtask = scope.fork(() -> {\n+                Thread.sleep(Duration.ofDays(1));\n+                return null;\n+            });\n+\n+            \/\/ now\n+            try {\n+                scope.joinUntil(Instant.now());\n+                fail(\"joinUntil did not throw\");\n+            } catch (TimeoutException expected) {\n+                assertEquals(Subtask.State.UNAVAILABLE, subtask.state());\n+            }\n+\n+            \/\/ in the past\n+            try {\n+                scope.joinUntil(Instant.now().minusSeconds(1));\n+                fail(\"joinUntil did not throw\");\n+            } catch (TimeoutException expected) {\n+                assertEquals(Subtask.State.UNAVAILABLE, subtask.state());\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test joinUntil with interrupt status set.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testInterruptJoinUntil1(ThreadFactory factory) throws Exception {\n+        try (var scope = new StructuredTaskScope<String>(null, factory)) {\n+            var latch = new CountDownLatch(1);\n+\n+            Subtask<String> subtask = scope.fork(() -> {\n+                latch.await();\n+                return \"foo\";\n+            });\n+\n+            \/\/ joinUntil should throw\n+            Thread.currentThread().interrupt();\n+            try {\n+                scope.joinUntil(Instant.now().plusSeconds(30));\n+                fail(\"joinUntil did not throw\");\n+            } catch (InterruptedException expected) {\n+                assertFalse(Thread.interrupted());   \/\/ interrupt status should be clear\n+            } finally {\n+                \/\/ let task continue\n+                latch.countDown();\n+            }\n+\n+            \/\/ join should complete\n+            scope.join();\n+            assertEquals(\"foo\", subtask.get());\n+        }\n+    }\n+\n+    \/**\n+     * Test interrupt of thread blocked in joinUntil.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testInterruptJoinUntil2(ThreadFactory factory) throws Exception {\n+        try (var scope = new StructuredTaskScope(null, factory)) {\n+            var latch = new CountDownLatch(1);\n+\n+            Subtask<String> subtask = scope.fork(() -> {\n+                latch.await();\n+                return \"foo\";\n+            });\n+\n+            \/\/ joinUntil should throw\n+            scheduleInterruptAt(\"java.util.concurrent.StructuredTaskScope.joinUntil\");\n+            try {\n+                scope.joinUntil(Instant.now().plusSeconds(30));\n+                fail(\"joinUntil did not throw\");\n+            } catch (InterruptedException expected) {\n+                assertFalse(Thread.interrupted());   \/\/ interrupt status should be clear\n+            } finally {\n+                \/\/ let task continue\n+                latch.countDown();\n+            }\n+\n+            \/\/ join should complete\n+            scope.join();\n+            assertEquals(\"foo\", subtask.get());\n+        }\n+    }\n+\n+    \/**\n+     * Test that shutdown prevents new threads from starting.\n+     *\/\n+    @Test\n+    void testShutdownWithFork() throws Exception {\n+        ThreadFactory factory = task -> null;\n+        try (var scope = new StructuredTaskScope<Object>(null, factory)) {\n+            scope.shutdown();\n+            \/\/ should not invoke the ThreadFactory to create thread\n+            Subtask<Void> subtask = scope.fork(() -> null);\n+            assertEquals(Subtask.State.UNAVAILABLE, subtask.state());\n+            assertThrows(IllegalStateException.class, subtask::get);\n+            assertThrows(IllegalStateException.class, subtask::exception);\n+        }\n+    }\n+\n+    \/**\n+     * Test that shutdown interrupts unfinished subtasks.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testShutdownInterruptsThreads1(ThreadFactory factory) throws Exception {\n+        try (var scope = new StructuredTaskScope<Object>(null, factory)) {\n+            var interrupted = new AtomicBoolean();\n+            var latch = new CountDownLatch(1);\n+            var subtask = scope.fork(() -> {\n+                try {\n+                    Thread.sleep(Duration.ofDays(1));\n+                } catch (InterruptedException e) {\n+                    interrupted.set(true);\n+                } finally {\n+                    latch.countDown();\n+                }\n+                return null;\n+            });\n+\n+            scope.shutdown();\n+\n+            \/\/ wait for task to complete\n+            latch.await();\n+            assertTrue(interrupted.get());\n+\n+            scope.join();\n+\n+            \/\/ subtask result\/exception not available\n+            assertEquals(Subtask.State.UNAVAILABLE, subtask.state());\n+            assertThrows(IllegalStateException.class, subtask::get);\n+            assertThrows(IllegalStateException.class, subtask::exception);\n+        }\n+    }\n+\n+    \/**\n+     * Test that shutdown does not interrupt current thread.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testShutdownInterruptsThreads2(ThreadFactory factory) throws Exception {\n+        try (var scope = new StructuredTaskScope<Object>(null, factory)) {\n+            var interrupted = new AtomicBoolean();\n+            var latch = new CountDownLatch(1);\n+            var subtask = scope.fork(() -> {\n+                try {\n+                    scope.shutdown();\n+                    interrupted.set(Thread.currentThread().isInterrupted());\n+                } finally {\n+                    latch.countDown();\n+                }\n+                return null;\n+            });\n+\n+            \/\/ wait for task to complete\n+            latch.await();\n+            assertFalse(interrupted.get());\n+\n+            scope.join();\n+        }\n+    }\n+\n+    \/**\n+     * Test shutdown wakes join.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testShutdownWakesJoin(ThreadFactory factory) throws Exception {\n+        try (var scope = new StructuredTaskScope<Object>(null, factory)) {\n+            var latch = new CountDownLatch(1);\n+            scope.fork(() -> {\n+                Thread.sleep(Duration.ofMillis(100));  \/\/ give time for join to block\n+                scope.shutdown();\n+                latch.await();\n+                return null;\n+            });\n+\n+            scope.join();\n+\n+            \/\/ join woke up, allow task to complete\n+            latch.countDown();\n+        }\n+    }\n+\n+    \/**\n+     * Test shutdown after scope is closed.\n+     *\/\n+    @Test\n+    void testShutdownAfterClose() throws Exception {\n+        try (var scope = new StructuredTaskScope<Object>()) {\n+            scope.join();\n+            scope.close();\n+            assertThrows(IllegalStateException.class, scope::shutdown);\n+        }\n+    }\n+\n+    \/**\n+     * Test shutdown is confined to threads in the scope \"tree\".\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testShutdownConfined(ThreadFactory factory) throws Exception {\n+        try (var scope1 = new StructuredTaskScope<Boolean>();\n+             var scope2 = new StructuredTaskScope<Boolean>()) {\n+\n+            \/\/ thread in scope1 cannot shutdown scope2\n+            Subtask<Boolean> subtask1 = scope1.fork(() -> {\n+                assertThrows(WrongThreadException.class, scope2::shutdown);\n+                return true;\n+            });\n+\n+            \/\/ wait for task in scope1 to complete to avoid racing with task in scope2\n+            while (subtask1.state() == Subtask.State.UNAVAILABLE) {\n+                Thread.sleep(10);\n+            }\n+\n+            \/\/ thread in scope2 shutdown scope1\n+            Subtask<Boolean> subtask2 = scope2.fork(() -> {\n+                scope1.shutdown();\n+                return true;\n+            });\n+\n+            scope2.join();\n+            scope1.join();\n+\n+            assertTrue(subtask1.get());\n+            assertTrue(subtask1.get());\n+\n+            \/\/ random thread cannot shutdown\n+            try (var pool = Executors.newSingleThreadExecutor()) {\n+                Future<Void> future = pool.submit(() -> {\n+                    assertThrows(WrongThreadException.class, scope1::shutdown);\n+                    assertThrows(WrongThreadException.class, scope2::shutdown);\n+                    return null;\n+                });\n+                future.get();\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test isShutdown.\n+     *\/\n+    @Test\n+    void testIsShutdown() {\n+        try (var scope = new StructuredTaskScope<Object>()) {\n+            assertFalse(scope.isShutdown());   \/\/ before shutdown\n+            scope.shutdown();\n+            assertTrue(scope.isShutdown());    \/\/ after shutdown\n+            scope.close();\n+            assertTrue(scope.isShutdown());    \/\/ after cose\n+        }\n+    }\n+\n+    \/**\n+     * Test close without join, no subtasks forked.\n+     *\/\n+    @Test\n+    void testCloseWithoutJoin1() {\n+        try (var scope = new StructuredTaskScope<Object>()) {\n+            \/\/ do nothing\n+        }\n+    }\n+\n+    \/**\n+     * Test close without join, unfinished subtasks.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testCloseWithoutJoin2(ThreadFactory factory) {\n+        try (var scope = new StructuredTaskScope<String>(null, factory)) {\n+            Subtask<String> subtask = scope.fork(() -> {\n+                Thread.sleep(Duration.ofDays(1));\n+                return null;\n+            });\n+            assertThrows(IllegalStateException.class, scope::close);\n+\n+            \/\/ subtask result\/exception not available\n+            assertEquals(Subtask.State.UNAVAILABLE, subtask.state());\n+            assertThrows(IllegalStateException.class, subtask::get);\n+            assertThrows(IllegalStateException.class, subtask::exception);\n+        }\n+    }\n+\n+    \/**\n+     * Test close without join, unfinished subtasks forked after join.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testCloseWithoutJoin3(ThreadFactory factory) throws Exception {\n+        try (var scope = new StructuredTaskScope(null, factory)) {\n+            scope.fork(() -> \"foo\");\n+            scope.join();\n+\n+            Subtask<String> subtask = scope.fork(() -> {\n+                Thread.sleep(Duration.ofDays(1));\n+                return null;\n+            });\n+            assertThrows(IllegalStateException.class, scope::close);\n+\n+            \/\/ subtask result\/exception not available\n+            assertEquals(Subtask.State.UNAVAILABLE, subtask.state());\n+            assertThrows(IllegalStateException.class, subtask::get);\n+            assertThrows(IllegalStateException.class, subtask::exception);\n+        }\n+    }\n+\n+    \/**\n+     * Test close after join throws. Close should not throw as join attempted.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testCloseAfterJoinThrows(ThreadFactory factory) throws Exception {\n+        try (var scope = new StructuredTaskScope<Object>()) {\n+            var subtask = scope.fork(() -> {\n+                Thread.sleep(Duration.ofDays(1));\n+                return null;\n+            });\n+\n+            \/\/ join throws\n+            Thread.currentThread().interrupt();\n+            assertThrows(InterruptedException.class, scope::join);\n+            assertThrows(IllegalStateException.class, subtask::get);\n+        }\n+    }\n+\n+    \/**\n+     * Test close after joinUntil throws. Close should not throw as join attempted.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testCloseAfterJoinUntilThrows(ThreadFactory factory) throws Exception {\n+        try (var scope = new StructuredTaskScope<Object>()) {\n+            var subtask = scope.fork(() -> {\n+                Thread.sleep(Duration.ofDays(1));\n+                return null;\n+            });\n+\n+            \/\/ joinUntil throws\n+            assertThrows(TimeoutException.class, () -> scope.joinUntil(Instant.now()));\n+            assertThrows(IllegalStateException.class, subtask::get);\n+        }\n+    }\n+\n+    \/**\n+     * Test close is owner confined.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testCloseConfined(ThreadFactory factory) throws Exception {\n+        try (var scope = new StructuredTaskScope<Boolean>()) {\n+\n+            \/\/ attempt to close from thread in scope\n+            Subtask<Boolean> subtask = scope.fork(() -> {\n+                assertThrows(WrongThreadException.class, scope::close);\n+                return true;\n+            });\n+\n+            scope.join();\n+            assertTrue(subtask.get());\n+\n+            \/\/ random thread cannot close scope\n+            try (var pool = Executors.newCachedThreadPool(factory)) {\n+                Future<Boolean> future = pool.submit(() -> {\n+                    assertThrows(WrongThreadException.class, scope::close);\n+                    return null;\n+                });\n+                future.get();\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test close with interrupt status set.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testInterruptClose1(ThreadFactory factory) throws Exception {\n+        try (var scope = new StructuredTaskScope<Object>(null, factory)) {\n+            var done = new AtomicBoolean();\n+            scope.fork(() -> {\n+                try {\n+                    Thread.sleep(Duration.ofDays(1));\n+                } catch (InterruptedException e) {\n+                    \/\/ interrupted by shutdown, expected\n+                }\n+                Thread.sleep(Duration.ofMillis(100)); \/\/ force close to wait\n+                done.set(true);\n+                return null;\n+            });\n+\n+            scope.shutdown();\n+            scope.join();\n+\n+            \/\/ invoke close with interrupt status set\n+            Thread.currentThread().interrupt();\n+            try {\n+                scope.close();\n+            } finally {\n+                assertTrue(Thread.interrupted());   \/\/ clear interrupt status\n+                assertTrue(done.get());\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test interrupting thread waiting in close.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testInterruptClose2(ThreadFactory factory) throws Exception {\n+        try (var scope = new StructuredTaskScope<Object>(null, factory)) {\n+            var done = new AtomicBoolean();\n+            Thread mainThread = Thread.currentThread();\n+            scope.fork(() -> {\n+                try {\n+                    Thread.sleep(Duration.ofDays(1));\n+                } catch (InterruptedException e) {\n+                    \/\/ interrupted by shutdown, expected\n+                }\n+\n+                \/\/ interrupt main thread when it blocks in close\n+                interruptThreadAt(mainThread, \"java.util.concurrent.StructuredTaskScope.close\");\n+\n+                Thread.sleep(Duration.ofMillis(100)); \/\/ force close to wait\n+                done.set(true);\n+                return null;\n+            });\n+\n+            scope.shutdown();   \/\/ interrupts task\n+            scope.join();\n+            try {\n+                scope.close();\n+            } finally {\n+                assertTrue(Thread.interrupted()); \/\/ clear interrupt status\n+                assertTrue(done.get());\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test that closing an enclosing scope closes the thread flock of a nested scope.\n+     *\/\n+    @Test\n+    void testCloseThrowsStructureViolation() throws Exception {\n+        try (var scope1 = new StructuredTaskScope<Object>()) {\n+            try (var scope2 = new StructuredTaskScope<Object>()) {\n+\n+                \/\/ join + close enclosing scope\n+                scope1.join();\n+                try {\n+                    scope1.close();\n+                    fail(\"close did not throw\");\n+                } catch (StructureViolationException expected) { }\n+\n+                \/\/ underlying flock should be closed, fork should return a cancelled task\n+                var executed = new AtomicBoolean();\n+                Subtask<Void> subtask = scope2.fork(() -> {\n+                    executed.set(true);\n+                    return null;\n+                });\n+                assertEquals(Subtask.State.UNAVAILABLE, subtask.state());\n+                scope2.join();\n+                assertFalse(executed.get());\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * A StructuredTaskScope that collects the subtasks notified to the handleComplete method.\n+     *\/\n+    private static class CollectAll<T> extends StructuredTaskScope<T> {\n+        private final Set<Subtask<? extends T>> subtasks = ConcurrentHashMap.newKeySet();\n+\n+        CollectAll(ThreadFactory factory) {\n+            super(null, factory);\n+        }\n+\n+        @Override\n+        protected void handleComplete(Subtask<? extends T> subtask) {\n+            subtasks.add(subtask);\n+        }\n+\n+        Set<Subtask<? extends T>> subtasks() {\n+            return subtasks;\n+        }\n+\n+        Subtask<? extends T> find(Callable<T> task) {\n+            return subtasks.stream()\n+                    .filter(h -> task.equals(h.task()))\n+                    .findAny()\n+                    .orElseThrow();\n+        }\n+    }\n+\n+    \/**\n+     * Test that handleComplete method is invoked for tasks that complete before shutdown.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testHandleCompleteBeforeShutdown(ThreadFactory factory) throws Exception {\n+        try (var scope = new CollectAll<String>(factory)) {\n+            Callable<String> task1 = () -> \"foo\";\n+            Callable<String> task2 = () -> { throw new FooException(); };\n+            scope.fork(task1);\n+            scope.fork(task2);\n+            scope.join();\n+\n+            var subtask1 = scope.find(task1);\n+            assertEquals(\"foo\", subtask1.get());\n+\n+            var subtask2 = scope.find(task2);\n+            assertTrue(subtask2.exception() instanceof FooException);\n+        }\n+    }\n+\n+    \/**\n+     * Test that handleComplete method is not invoked for tasks that finish after shutdown\n+     * or are forked after shutdown.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testHandleCompleteAfterShutdown(ThreadFactory factory) throws Exception {\n+        try (var scope = new CollectAll<String>(factory)) {\n+            Callable<String> task1 = () -> {\n+                try {\n+                    Thread.sleep(Duration.ofDays(1));\n+                } catch (InterruptedException ignore) { }\n+                return \"foo\";\n+            };\n+            Callable<String> task2 = () -> {\n+                Thread.sleep(Duration.ofDays(1));\n+                return \"bar\";\n+            };\n+            Callable<String> task3 = () -> \"baz\";\n+\n+            \/\/ forked before shutdown, will complete after shutdown\n+            var subtask1 = scope.fork(task1);\n+            var subtask2 = scope.fork(task2);\n+\n+            scope.shutdown();\n+\n+            \/\/ forked after shutdown\n+            var subtask3 = scope.fork(task3);\n+\n+            scope.join();\n+\n+            \/\/ handleComplete should not be called\n+            for (int i = 0; i < 3; i++) {\n+                assertEquals(0, scope.subtasks().size());\n+                Thread.sleep(20);\n+            }\n+\n+            assertEquals(Subtask.State.UNAVAILABLE, subtask1.state());\n+            assertEquals(Subtask.State.UNAVAILABLE, subtask2.state());\n+            assertEquals(Subtask.State.UNAVAILABLE, subtask3.state());\n+        }\n+    }\n+\n+    \/**\n+     * Test that the default handleComplete throws IllegalArgumentException if called\n+     * with a running task.\n+     *\/\n+    @Test\n+    void testHandleCompleteThrows() throws Exception {\n+        class TestScope<T> extends StructuredTaskScope<T> {\n+            protected void handleComplete(Subtask<? extends T> subtask) {\n+                super.handleComplete(subtask);\n+            }\n+        }\n+\n+        try (var scope = new TestScope<String>()) {\n+            var subtask = scope.fork(() -> {\n+                Thread.sleep(Duration.ofDays(1));\n+                return \"foo\";\n+            });\n+\n+            \/\/ running task\n+            assertEquals(Subtask.State.UNAVAILABLE, subtask.state());\n+            assertThrows(IllegalArgumentException.class, () -> scope.handleComplete(subtask));\n+            scope.shutdown();\n+\n+            \/\/ null task\n+            assertThrows(NullPointerException.class, () -> scope.handleComplete(null));\n+\n+            scope.join();\n+        }\n+    }\n+\n+    \/**\n+     * Test ensureOwnerAndJoined.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testEnsureOwnerAndJoined(ThreadFactory factory) throws Exception {\n+        class MyScope<T> extends StructuredTaskScope<T> {\n+            MyScope(ThreadFactory factory) {\n+                super(null, factory);\n+            }\n+            void invokeEnsureOwnerAndJoined() {\n+                super.ensureOwnerAndJoined();\n+            }\n+        }\n+\n+        try (var scope = new MyScope<Boolean>(factory)) {\n+            \/\/ owner thread, before join\n+            scope.fork(() -> true);\n+            assertThrows(IllegalStateException.class, () -> {\n+                scope.invokeEnsureOwnerAndJoined();\n+            });\n+\n+            \/\/ owner thread, after join\n+            scope.join();\n+            scope.invokeEnsureOwnerAndJoined();\n+\n+            \/\/ thread in scope cannot invoke ensureOwnerAndJoined\n+            Subtask<Boolean> subtask = scope.fork(() -> {\n+                assertThrows(WrongThreadException.class, () -> {\n+                    scope.invokeEnsureOwnerAndJoined();\n+                });\n+                return true;\n+            });\n+            scope.join();\n+            assertTrue(subtask.get());\n+\n+            \/\/ random thread cannot invoke ensureOwnerAndJoined\n+            try (var pool = Executors.newSingleThreadExecutor()) {\n+                Future<Void> future = pool.submit(() -> {\n+                    assertThrows(WrongThreadException.class, () -> {\n+                        scope.invokeEnsureOwnerAndJoined();\n+                    });\n+                    return null;\n+                });\n+                future.get();\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test ensureOwnerAndJoined after the task scope has been closed.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testEnsureOwnerAndJoinedAfterClose(ThreadFactory factory) throws Exception {\n+        class MyScope<T> extends StructuredTaskScope<T> {\n+            MyScope(ThreadFactory factory) {\n+                super(null, factory);\n+            }\n+            public void invokeEnsureOwnerAndJoined() {\n+                super.ensureOwnerAndJoined();\n+            }\n+        }\n+\n+        \/\/ ensureOwnerAndJoined after close, join invoked\n+        try (var scope = new MyScope<String>(factory)) {\n+            scope.fork(() -> \"foo\");\n+            scope.join();\n+            scope.close();\n+            scope.invokeEnsureOwnerAndJoined();  \/\/ should not throw\n+        }\n+\n+        \/\/ ensureOwnerAndJoined after close, join not invoked\n+        try (var scope = new MyScope<String>(factory)) {\n+            scope.fork(() -> \"foo\");\n+            assertThrows(IllegalStateException.class, scope::close);\n+            scope.invokeEnsureOwnerAndJoined();  \/\/ should not throw\n+        }\n+    }\n+\n+\n+    \/**\n+     * Test toString.\n+     *\/\n+    @Test\n+    void testToString() throws Exception {\n+        ThreadFactory factory = Thread.ofVirtual().factory();\n+        try (var scope = new StructuredTaskScope<Object>(\"duke\", factory)) {\n+            \/\/ open\n+            assertTrue(scope.toString().contains(\"duke\"));\n+\n+            \/\/ shutdown\n+            scope.shutdown();\n+            assertTrue(scope.toString().contains(\"duke\"));\n+\n+            \/\/ closed\n+            scope.join();\n+            scope.close();\n+            assertTrue(scope.toString().contains(\"duke\"));\n+        }\n+    }\n+\n+    \/**\n+     * Test Subtask with task that completes successfully.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testSubtaskWhenSuccess(ThreadFactory factory) throws Exception {\n+        try (var scope = new StructuredTaskScope<String>(null, factory)) {\n+            Callable<String> task = () -> \"foo\";\n+            Subtask<String> subtask = scope.fork(task);\n+\n+            \/\/ before join, owner thread\n+            assertEquals(task, subtask.task());\n+            assertThrows(IllegalStateException.class, subtask::get);\n+            assertThrows(IllegalStateException.class, subtask::exception);\n+\n+            scope.join();\n+\n+            \/\/ after join\n+            assertEquals(task, subtask.task());\n+            assertEquals(Subtask.State.SUCCESS, subtask.state());\n+            assertEquals(\"foo\", subtask.get());\n+            assertThrows(IllegalStateException.class, subtask::exception);\n+        }\n+    }\n+\n+    \/**\n+     * Test Subtask with task that fails.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testSubtaskWhenFailed(ThreadFactory factory) throws Exception {\n+        try (var scope = new StructuredTaskScope<String>(null, factory)) {\n+            Callable<String> task = () -> { throw new FooException(); };\n+            Subtask<String> subtask = scope.fork(task);\n+\n+            \/\/ before join, owner thread\n+            assertEquals(task, subtask.task());\n+            assertThrows(IllegalStateException.class, subtask::get);\n+            assertThrows(IllegalStateException.class, subtask::exception);\n+\n+            scope.join();\n+\n+            \/\/ after join\n+            assertEquals(task, subtask.task());\n+            assertEquals(Subtask.State.FAILED, subtask.state());\n+            assertThrows(IllegalStateException.class, subtask::get);\n+            assertTrue(subtask.exception() instanceof FooException);\n+        }\n+    }\n+\n+    \/**\n+     * Test Subtask with a task that has not completed.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testSubtaskWhenNotCompleted(ThreadFactory factory) throws Exception {\n+        try (var scope = new StructuredTaskScope<Object>(null, factory)) {\n+            Callable<Void> task = () -> {\n+                Thread.sleep(Duration.ofDays(1));\n+                return null;\n+            };\n+            Subtask<Void> subtask = scope.fork(task);\n+\n+            \/\/ before join\n+            assertEquals(task, subtask.task());\n+            assertEquals(Subtask.State.UNAVAILABLE, subtask.state());\n+            assertThrows(IllegalStateException.class, subtask::get);\n+            assertThrows(IllegalStateException.class, subtask::exception);\n+\n+            \/\/ attempt join, join throws\n+            Thread.currentThread().interrupt();\n+            assertThrows(InterruptedException.class, scope::join);\n+\n+            \/\/ after join\n+            assertEquals(task, subtask.task());\n+            assertEquals(Subtask.State.UNAVAILABLE, subtask.state());\n+            assertThrows(IllegalStateException.class, subtask::get);\n+            assertThrows(IllegalStateException.class, subtask::exception);\n+        }\n+    }\n+\n+    \/**\n+     * Test Subtask when forked after shutdown.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testSubtaskWhenShutdown(ThreadFactory factory) throws Exception {\n+        try (var scope = new StructuredTaskScope<Object>(null, factory)) {\n+            Callable<Void> task = () -> {\n+                Thread.sleep(Duration.ofDays(1));\n+                return null;\n+            };\n+\n+            scope.shutdown();\n+\n+            \/\/ fork after shutdown\n+            Subtask<Void> subtask = scope.fork(task);\n+            assertEquals(task, subtask.task());\n+            assertEquals(Subtask.State.UNAVAILABLE, subtask.state());\n+            assertThrows(IllegalStateException.class, subtask::get);\n+            assertThrows(IllegalStateException.class, subtask::exception);\n+        }\n+    }\n+\n+    \/**\n+     * Test Subtask::toString.\n+     *\/\n+    @Test\n+    void testSubtaskToString() throws Exception {\n+        try (var scope = new StructuredTaskScope<Object>()) {\n+            \/\/ success\n+            var subtask1 = scope.fork(() -> \"foo\");\n+            scope.join();\n+            assertTrue(subtask1.toString().contains(\"Completed successfully\"));\n+\n+            \/\/ failed\n+            var subtask2 = scope.fork(() -> { throw new FooException(); });\n+            scope.join();\n+            assertTrue(subtask2.toString().contains(\"Failed\"));\n+\n+            \/\/ not completed\n+            Callable<Void> sleepForDay = () -> {\n+                Thread.sleep(Duration.ofDays(1));\n+                return null;\n+            };\n+            var subtask3 = scope.fork(sleepForDay);\n+            assertTrue(subtask3.toString().contains(\"Unavailable\"));\n+\n+            scope.shutdown();\n+\n+            \/\/ forked after shutdown\n+            var subtask4 = scope.fork(sleepForDay);\n+            assertTrue(subtask4.toString().contains(\"Unavailable\"));\n+\n+            scope.join();\n+        }\n+    }\n+\n+    \/**\n+     * Test ShutdownOnSuccess with no completed tasks.\n+     *\/\n+    @Test\n+    void testShutdownOnSuccess1() throws Exception {\n+        try (var scope = new ShutdownOnSuccess<Object>()) {\n+            assertThrows(IllegalStateException.class, () -> scope.result());\n+            assertThrows(IllegalStateException.class, () -> scope.result(e -> null));\n+        }\n+    }\n+\n+    \/**\n+     * Test ShutdownOnSuccess with tasks that complete successfully.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testShutdownOnSuccess2(ThreadFactory factory) throws Exception {\n+        try (var scope = new ShutdownOnSuccess<String>(null, factory)) {\n+            scope.fork(() -> \"foo\");\n+            scope.join();  \/\/ ensures foo completes first\n+            scope.fork(() -> \"bar\");\n+            scope.join();\n+            assertEquals(\"foo\", scope.result());\n+            assertEquals(\"foo\", scope.result(e -> null));\n+        }\n+    }\n+\n+    \/**\n+     * Test ShutdownOnSuccess with a task that completes successfully with a null result.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testShutdownOnSuccess3(ThreadFactory factory) throws Exception {\n+        try (var scope = new ShutdownOnSuccess<Object>(null, factory)) {\n+            scope.fork(() -> null);\n+            scope.join();\n+            assertNull(scope.result());\n+            assertNull(scope.result(e -> null));\n+        }\n+    }\n+\n+    \/**\n+     * Test ShutdownOnSuccess with tasks that complete succcessfully and tasks that fail.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testShutdownOnSuccess4(ThreadFactory factory) throws Exception {\n+        try (var scope = new ShutdownOnSuccess<String>(null, factory)) {\n+            scope.fork(() -> \"foo\");\n+            scope.fork(() -> { throw new ArithmeticException(); });\n+            scope.join();\n+            assertEquals(\"foo\", scope.result());\n+            assertEquals(\"foo\", scope.result(e -> null));\n+        }\n+    }\n+\n+    \/**\n+     * Test ShutdownOnSuccess with a task that fails.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testShutdownOnSuccess5(ThreadFactory factory) throws Exception {\n+        try (var scope = new ShutdownOnSuccess<Object>(null, factory)) {\n+            scope.fork(() -> { throw new ArithmeticException(); });\n+            scope.join();\n+            Throwable ex = assertThrows(ExecutionException.class, () -> scope.result());\n+            assertTrue(ex.getCause() instanceof ArithmeticException);\n+            ex = assertThrows(FooException.class, () -> scope.result(e -> new FooException(e)));\n+            assertTrue(ex.getCause() instanceof ArithmeticException);\n+        }\n+    }\n+\n+    \/**\n+     * Test ShutdownOnSuccess methods are confined to the owner.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testShutdownOnSuccessConfined(ThreadFactory factory) throws Exception {\n+        \/\/ owner before join\n+        try (var scope = new ShutdownOnSuccess<Boolean>(null, factory)) {\n+            scope.fork(() -> { throw new FooException(); });\n+            assertThrows(IllegalStateException.class, scope::result);\n+            assertThrows(IllegalStateException.class, () -> {\n+                scope.result(e -> new RuntimeException(e));\n+            });\n+            scope.join();\n+        }\n+\n+        \/\/ non-owner\n+        try (var scope = new ShutdownOnSuccess<Boolean>(null, factory)) {\n+            Subtask<Boolean> subtask = scope.fork(() -> {\n+                assertThrows(WrongThreadException.class, scope::result);\n+                assertThrows(WrongThreadException.class, () -> {\n+                    scope.result(e -> new RuntimeException(e));\n+                });\n+                return true;\n+            });\n+            scope.join();\n+            assertTrue(subtask.get());\n+        }\n+    }\n+\n+    \/**\n+     * Test ShutdownOnFailure with no completed tasks.\n+     *\/\n+    @Test\n+    void testShutdownOnFailure1() throws Throwable {\n+        try (var scope = new ShutdownOnFailure()) {\n+            assertTrue(scope.exception().isEmpty());\n+            scope.throwIfFailed();\n+            scope.throwIfFailed(e -> new FooException(e));\n+        }\n+    }\n+\n+    \/**\n+     * Test ShutdownOnFailure with tasks that complete successfully.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testShutdownOnFailure2(ThreadFactory factory) throws Throwable {\n+        try (var scope = new ShutdownOnFailure(null, factory)) {\n+            scope.fork(() -> \"foo\");\n+            scope.fork(() -> \"bar\");\n+            scope.join();\n+\n+            \/\/ no exception\n+            assertTrue(scope.exception().isEmpty());\n+            scope.throwIfFailed();\n+            scope.throwIfFailed(e -> new FooException(e));\n+        }\n+    }\n+\n+    \/**\n+     * Test ShutdownOnFailure with tasks that complete succcessfully and tasks that fail.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testShutdownOnFailure3(ThreadFactory factory) throws Throwable {\n+        try (var scope = new ShutdownOnFailure(null, factory)) {\n+\n+            \/\/ one task completes successfully, the other fails\n+            scope.fork(() -> \"foo\");\n+            scope.fork(() -> { throw new ArithmeticException(); });\n+            scope.join();\n+\n+            Throwable ex = scope.exception().orElse(null);\n+            assertTrue(ex instanceof ArithmeticException);\n+\n+            ex = assertThrows(ExecutionException.class, () -> scope.throwIfFailed());\n+            assertTrue(ex.getCause() instanceof ArithmeticException);\n+\n+            ex = assertThrows(FooException.class,\n+                              () -> scope.throwIfFailed(e -> new FooException(e)));\n+            assertTrue(ex.getCause() instanceof ArithmeticException);\n+        }\n+    }\n+\n+    \/**\n+     * Test ShutdownOnFailure methods are confined to the owner.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testShutdownOnFailureConfined(ThreadFactory factory) throws Exception {\n+        \/\/ owner before join\n+        try (var scope = new ShutdownOnFailure(null, factory)) {\n+            scope.fork(() -> \"foo\");\n+            assertThrows(IllegalStateException.class, scope::exception);\n+            assertThrows(IllegalStateException.class, scope::throwIfFailed);\n+            assertThrows(IllegalStateException.class, () -> {\n+                scope.throwIfFailed(e -> new RuntimeException(e));\n+            });\n+            scope.join();\n+        }\n+\n+        \/\/ non-owner\n+        try (var scope = new ShutdownOnFailure(null, factory)) {\n+            Subtask<Boolean> subtask = scope.fork(() -> {\n+                assertThrows(WrongThreadException.class, scope::exception);\n+                assertThrows(WrongThreadException.class, scope::throwIfFailed);\n+                assertThrows(WrongThreadException.class, () -> {\n+                    scope.throwIfFailed(e -> new RuntimeException(e));\n+                });\n+                return true;\n+            });\n+            scope.join();\n+            assertTrue(subtask.get());\n+        }\n+    }\n+\n+    \/**\n+     * Test for NullPointerException.\n+     *\/\n+    @Test\n+    void testNulls() throws Exception {\n+        assertThrows(NullPointerException.class, () -> new StructuredTaskScope(\"\", null));\n+        try (var scope = new StructuredTaskScope<Object>()) {\n+            assertThrows(NullPointerException.class, () -> scope.fork(null));\n+            assertThrows(NullPointerException.class, () -> scope.joinUntil(null));\n+        }\n+\n+        assertThrows(NullPointerException.class, () -> new ShutdownOnSuccess<Object>(\"\", null));\n+        try (var scope = new ShutdownOnSuccess<Object>()) {\n+            assertThrows(NullPointerException.class, () -> scope.fork(null));\n+            assertThrows(NullPointerException.class, () -> scope.joinUntil(null));\n+            assertThrows(NullPointerException.class, () -> scope.result(null));\n+        }\n+\n+        assertThrows(NullPointerException.class, () -> new ShutdownOnFailure(\"\", null));\n+        try (var scope = new ShutdownOnFailure()) {\n+            assertThrows(NullPointerException.class, () -> scope.fork(null));\n+            assertThrows(NullPointerException.class, () -> scope.joinUntil(null));\n+            assertThrows(NullPointerException.class, () -> scope.throwIfFailed(null));\n+        }\n+    }\n+\n+    \/**\n+     * A runtime exception for tests.\n+     *\/\n+    private static class FooException extends RuntimeException {\n+        FooException() { }\n+        FooException(Throwable cause) { super(cause); }\n+    }\n+\n+    \/**\n+     * Returns the current time in milliseconds.\n+     *\/\n+    private long millisTime() {\n+        long now = System.nanoTime();\n+        return TimeUnit.MILLISECONDS.convert(now, TimeUnit.NANOSECONDS);\n+    }\n+\n+    \/**\n+     * Check the duration of a task\n+     * @param start start time, in milliseconds\n+     * @param min minimum expected duration, in milliseconds\n+     * @param max maximum expected duration, in milliseconds\n+     * @return the duration (now - start), in milliseconds\n+     *\/\n+    private long expectDuration(long start, long min, long max) {\n+        long duration = millisTime() - start;\n+        assertTrue(duration >= min,\n+                \"Duration \" + duration + \"ms, expected >= \" + min + \"ms\");\n+        assertTrue(duration <= max,\n+                \"Duration \" + duration + \"ms, expected <= \" + max + \"ms\");\n+        return duration;\n+    }\n+\n+    \/**\n+     * Interrupts a thread when it waits (timed or untimed) at location \"{@code c.m}\".\n+     * {@code c} is the fully qualified class name and {@code m} is the method name.\n+     *\/\n+    private void interruptThreadAt(Thread target, String location) throws InterruptedException {\n+        int index = location.lastIndexOf('.');\n+        String className = location.substring(0, index);\n+        String methodName = location.substring(index + 1);\n+\n+        boolean found = false;\n+        while (!found) {\n+            Thread.State state = target.getState();\n+            assertTrue(state != TERMINATED);\n+            if ((state == WAITING || state == TIMED_WAITING)\n+                    && contains(target.getStackTrace(), className, methodName)) {\n+                found = true;\n+            } else {\n+                Thread.sleep(20);\n+            }\n+        }\n+        target.interrupt();\n+    }\n+\n+    \/**\n+     * Schedules the current thread to be interrupted when it waits (timed or untimed)\n+     * at the given location.\n+     *\/\n+    private void scheduleInterruptAt(String location) {\n+        Thread target = Thread.currentThread();\n+        scheduler.submit(() -> {\n+            interruptThreadAt(target, location);\n+            return null;\n+        });\n+    }\n+\n+    \/**\n+     * Returns true if the given stack trace contains an element for the given class\n+     * and method name.\n+     *\/\n+    private boolean contains(StackTraceElement[] stack, String className, String methodName) {\n+        return Arrays.stream(stack)\n+                .anyMatch(e -> className.equals(e.getClassName())\n+                        && methodName.equals(e.getMethodName()));\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/concurrent\/StructuredTaskScope\/StructuredTaskScopeTest.java","additions":1712,"deletions":0,"binary":false,"changes":1712,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8284199\n+ * @bug 8284199 8296779 8306647\n@@ -28,1 +28,1 @@\n- * @modules jdk.incubator.concurrent\n+ * @enablePreview\n@@ -33,1 +33,1 @@\n-import jdk.incubator.concurrent.StructuredTaskScope;\n+import java.util.concurrent.StructuredTaskScope;\n","filename":"test\/jdk\/java\/util\/concurrent\/StructuredTaskScope\/StructuredThreadDumpTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"previous_filename":"test\/jdk\/jdk\/incubator\/concurrent\/StructuredTaskScope\/StructuredThreadDumpTest.java","status":"renamed"},{"patch":"@@ -0,0 +1,218 @@\n+\/*\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8284199 8296779 8306647\n+ * @summary Basic tests for StructuredTaskScope with scoped values\n+ * @enablePreview\n+ * @run junit WithScopedValue\n+ *\/\n+\n+import java.util.concurrent.StructuredTaskScope;\n+import java.util.concurrent.StructuredTaskScope.Subtask;\n+import java.util.concurrent.StructureViolationException;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class WithScopedValue {\n+\n+    private static Stream<ThreadFactory> factories() {\n+        return Stream.of(Thread.ofPlatform().factory(), Thread.ofVirtual().factory());\n+    }\n+\n+    \/**\n+     * Test that fork inherits a scoped value into a child thread.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testForkInheritsScopedValue1(ThreadFactory factory) throws Exception {\n+        ScopedValue<String> name = ScopedValue.newInstance();\n+        String value = ScopedValue.callWhere(name, \"x\", () -> {\n+            try (var scope = new StructuredTaskScope<String>(null, factory)) {\n+                Subtask<String> subtask = scope.fork(() -> {\n+                    return name.get(); \/\/ child should read \"x\"\n+                });\n+                scope.join();\n+                return subtask.get();\n+            }\n+        });\n+        assertEquals(value, \"x\");\n+    }\n+\n+    \/**\n+     * Test that fork inherits a scoped value into a grandchild thread.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testForkInheritsScopedValue2(ThreadFactory factory) throws Exception {\n+        ScopedValue<String> name = ScopedValue.newInstance();\n+        String value = ScopedValue.callWhere(name, \"x\", () -> {\n+            try (var scope1 = new StructuredTaskScope<String>(null, factory)) {\n+                Subtask<String> subtask1 = scope1.fork(() -> {\n+                    try (var scope2 = new StructuredTaskScope<String>(null, factory)) {\n+                        Subtask<String> subtask2 = scope2.fork(() -> {\n+                            return name.get(); \/\/ grandchild should read \"x\"\n+                        });\n+                        scope2.join();\n+                        return subtask2.get();\n+                    }\n+                });\n+                scope1.join();\n+                return subtask1.get();\n+            }\n+        });\n+        assertEquals(value, \"x\");\n+    }\n+\n+    \/**\n+     * Test that fork inherits a rebound scoped value into a grandchild thread.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testForkInheritsScopedValue3(ThreadFactory factory) throws Exception {\n+        ScopedValue<String> name = ScopedValue.newInstance();\n+        String value = ScopedValue.callWhere(name, \"x\", () -> {\n+            try (var scope1 = new StructuredTaskScope<String>(null, factory)) {\n+                Subtask<String> subtask1 = scope1.fork(() -> {\n+                    assertEquals(name.get(), \"x\");  \/\/ child should read \"x\"\n+\n+                    \/\/ rebind name to \"y\"\n+                    String grandchildValue = ScopedValue.callWhere(name, \"y\", () -> {\n+                        try (var scope2 = new StructuredTaskScope<String>(null, factory)) {\n+                            Subtask<String> subtask2 = scope2.fork(() -> {\n+                                return name.get(); \/\/ grandchild should read \"y\"\n+                            });\n+                            scope2.join();\n+                            return subtask2.get();\n+                        }\n+                    });\n+\n+                    assertEquals(name.get(), \"x\");  \/\/ child should read \"x\"\n+                    return grandchildValue;\n+                });\n+                scope1.join();\n+                return subtask1.get();\n+            }\n+        });\n+        assertEquals(value, \"y\");\n+    }\n+\n+    \/**\n+     * Test exiting a dynamic scope with an open task scope.\n+     *\/\n+    @Test\n+    void testStructureViolation1() throws Exception {\n+        ScopedValue<String> name = ScopedValue.newInstance();\n+        class Box {\n+            StructuredTaskScope<Object> scope;\n+        }\n+        var box = new Box();\n+        try {\n+            try {\n+                ScopedValue.runWhere(name, \"x\", () -> {\n+                    box.scope = new StructuredTaskScope<Object>();\n+                });\n+                fail();\n+            } catch (StructureViolationException expected) { }\n+\n+            \/\/ underlying flock should be closed and fork should fail to start a thread\n+            StructuredTaskScope<Object> scope = box.scope;\n+            AtomicBoolean ran = new AtomicBoolean();\n+            Subtask<Object> subtask = scope.fork(() -> {\n+                ran.set(true);\n+                return null;\n+            });\n+            scope.join();\n+            assertEquals(Subtask.State.UNAVAILABLE, subtask.state());\n+            assertFalse(ran.get());\n+        } finally {\n+            StructuredTaskScope<Object> scope = box.scope;\n+            if (scope != null) {\n+                scope.close();\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test closing a StructuredTaskScope while executing in a dynamic scope.\n+     *\/\n+    @Test\n+    void testStructureViolation2() throws Exception {\n+        ScopedValue<String> name = ScopedValue.newInstance();\n+        try (var scope = new StructuredTaskScope<String>()) {\n+            ScopedValue.runWhere(name, \"x\", () -> {\n+                assertThrows(StructureViolationException.class, scope::close);\n+            });\n+        }\n+    }\n+\n+    \/**\n+     * Test fork when a scoped value is bound after a StructuredTaskScope is created.\n+     *\/\n+    @Test\n+    void testStructureViolation3() throws Exception {\n+        ScopedValue<String> name = ScopedValue.newInstance();\n+        try (var scope = new StructuredTaskScope<String>()) {\n+            ScopedValue.runWhere(name, \"x\", () -> {\n+                assertThrows(StructureViolationException.class,\n+                        () -> scope.fork(() -> \"foo\"));\n+            });\n+        }\n+    }\n+\n+    \/**\n+     * Test fork when a scoped value is re-bound after a StructuredTaskScope is created.\n+     *\/\n+    @Test\n+    void testStructureViolation4() throws Exception {\n+        ScopedValue<String> name1 = ScopedValue.newInstance();\n+        ScopedValue<String> name2 = ScopedValue.newInstance();\n+\n+        \/\/ rebind\n+        ScopedValue.runWhere(name1, \"x\", () -> {\n+            try (var scope = new StructuredTaskScope<String>()) {\n+                ScopedValue.runWhere(name1, \"y\", () -> {\n+                    assertThrows(StructureViolationException.class,\n+                            () -> scope.fork(() -> \"foo\"));\n+                });\n+            }\n+        });\n+\n+        \/\/ new binding\n+        ScopedValue.runWhere(name1, \"x\", () -> {\n+            try (var scope = new StructuredTaskScope<String>()) {\n+                ScopedValue.runWhere(name2, \"y\", () -> {\n+                    assertThrows(StructureViolationException.class,\n+                            () -> scope.fork(() -> \"foo\"));\n+                });\n+            }\n+        });\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/concurrent\/StructuredTaskScope\/WithScopedValue.java","additions":218,"deletions":0,"binary":false,"changes":218,"status":"added"},{"patch":"@@ -1,452 +0,0 @@\n-\/*\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @summary Test ScopedValue API\n- * @modules jdk.incubator.concurrent\n- * @run junit ScopeValueAPI\n- *\/\n-\n-import jdk.incubator.concurrent.ScopedValue;\n-import java.util.NoSuchElementException;\n-import java.util.concurrent.Callable;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.ThreadFactory;\n-import java.util.stream.Stream;\n-\n-import org.junit.jupiter.api.Test;\n-import org.junit.jupiter.params.ParameterizedTest;\n-import org.junit.jupiter.params.provider.MethodSource;\n-import static org.junit.jupiter.api.Assertions.*;\n-\n-class ScopeValueAPI {\n-\n-    private static Stream<ThreadFactory> factories() {\n-        return Stream.of(Thread.ofPlatform().factory(), Thread.ofVirtual().factory());\n-    }\n-\n-    \/**\n-     * Test that the run method is invoked.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testRun(ThreadFactory factory) throws Exception {\n-        test(factory, () -> {\n-            class Box { static boolean executed; }\n-            ScopedValue<String> name = ScopedValue.newInstance();\n-            ScopedValue.where(name, \"duke\", () -> { Box.executed = true; });\n-            assertTrue(Box.executed);\n-        });\n-    }\n-\n-    \/**\n-     * Test the run method throwing an exception.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testRunThrows(ThreadFactory factory) throws Exception {\n-        test(factory, () -> {\n-            class FooException extends RuntimeException {  }\n-            ScopedValue<String> name = ScopedValue.newInstance();\n-            Runnable op = () -> { throw new FooException(); };\n-            assertThrows(FooException.class, () -> ScopedValue.where(name, \"duke\", op));\n-            assertFalse(name.isBound());\n-        });\n-    }\n-\n-    \/**\n-     * Test that the call method is invoked.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testCall(ThreadFactory factory) throws Exception {\n-        test(factory, () -> {\n-            ScopedValue<String> name = ScopedValue.newInstance();\n-            String result = ScopedValue.where(name, \"duke\", name::get);\n-            assertEquals(\"duke\", result);\n-        });\n-    }\n-\n-    \/**\n-     * Test the call method throwing an exception.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testCallThrows(ThreadFactory factory) throws Exception {\n-        test(factory, () -> {\n-            class FooException extends RuntimeException {  }\n-            ScopedValue<String> name = ScopedValue.newInstance();\n-            Callable<Void> op = () -> { throw new FooException(); };\n-            assertThrows(FooException.class, () -> ScopedValue.where(name, \"duke\", op));\n-            assertFalse(name.isBound());\n-        });\n-    }\n-\n-    \/**\n-     * Test get method.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testGet(ThreadFactory factory) throws Exception {\n-        test(factory, () -> {\n-            ScopedValue<String> name1 = ScopedValue.newInstance();\n-            ScopedValue<String> name2 = ScopedValue.newInstance();\n-            assertThrows(NoSuchElementException.class, name1::get);\n-            assertThrows(NoSuchElementException.class, name2::get);\n-\n-            \/\/ run\n-            ScopedValue.where(name1, \"duke\", () -> {\n-                assertEquals(\"duke\", name1.get());\n-                assertThrows(NoSuchElementException.class, name2::get);\n-\n-            });\n-            assertThrows(NoSuchElementException.class, name1::get);\n-            assertThrows(NoSuchElementException.class, name2::get);\n-\n-            \/\/ call\n-            ScopedValue.where(name1, \"duke\", () -> {\n-                assertEquals(\"duke\", name1.get());\n-                assertThrows(NoSuchElementException.class, name2::get);\n-                return null;\n-            });\n-            assertThrows(NoSuchElementException.class, name1::get);\n-            assertThrows(NoSuchElementException.class, name2::get);\n-        });\n-    }\n-\n-    \/**\n-     * Test isBound method.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testIsBound(ThreadFactory factory) throws Exception {\n-        test(factory, () -> {\n-            ScopedValue<String> name1 = ScopedValue.newInstance();\n-            ScopedValue<String> name2 = ScopedValue.newInstance();\n-            assertFalse(name1.isBound());\n-            assertFalse(name2.isBound());\n-\n-            \/\/ run\n-            ScopedValue.where(name1, \"duke\", () -> {\n-                assertTrue(name1.isBound());\n-                assertFalse(name2.isBound());\n-            });\n-            assertFalse(name1.isBound());\n-            assertFalse(name2.isBound());\n-\n-            \/\/ call\n-            ScopedValue.where(name1, \"duke\", () -> {\n-                assertTrue(name1.isBound());\n-                assertFalse(name2.isBound());\n-                return null;\n-            });\n-            assertFalse(name1.isBound());\n-            assertFalse(name2.isBound());\n-        });\n-    }\n-\n-    \/**\n-     * Test orElse method.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testOrElse(ThreadFactory factory) throws Exception {\n-        test(factory, () -> {\n-            ScopedValue<String> name = ScopedValue.newInstance();\n-            assertNull(name.orElse(null));\n-            assertEquals(\"default\", name.orElse(\"default\"));\n-\n-            \/\/ run\n-            ScopedValue.where(name, \"duke\", () -> {\n-                assertEquals(\"duke\", name.orElse(null));\n-                assertEquals(\"duke\", name.orElse(\"default\"));\n-            });\n-\n-            \/\/ call\n-            ScopedValue.where(name, \"duke\", () -> {\n-                assertEquals(\"duke\", name.orElse(null));\n-                assertEquals(\"duke\", name.orElse(\"default\"));\n-                return null;\n-            });\n-        });\n-    }\n-\n-    \/**\n-     * Test orElseThrow method.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testOrElseThrow(ThreadFactory factory) throws Exception {\n-        test(factory, () -> {\n-            class FooException extends RuntimeException { }\n-            ScopedValue<String> name = ScopedValue.newInstance();\n-            assertThrows(FooException.class, () -> name.orElseThrow(FooException::new));\n-\n-            \/\/ run\n-            ScopedValue.where(name, \"duke\", () -> {\n-                assertEquals(\"duke\", name.orElseThrow(FooException::new));\n-            });\n-\n-            \/\/ call\n-            ScopedValue.where(name, \"duke\", () -> {\n-                assertEquals(\"duke\", name.orElseThrow(FooException::new));\n-                return null;\n-            });\n-        });\n-    }\n-\n-    \/**\n-     * Test two bindings.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testTwoBindings(ThreadFactory factory) throws Exception {\n-        test(factory, () -> {\n-            ScopedValue<String> name = ScopedValue.newInstance();\n-            ScopedValue<Integer> age = ScopedValue.newInstance();\n-\n-            \/\/ run\n-            ScopedValue.where(name, \"duke\").where(age, 100).run(() -> {\n-                assertTrue(name.isBound());\n-                assertTrue(age.isBound());\n-                assertEquals(\"duke\", name.get());\n-                assertEquals(100, (int) age.get());\n-            });\n-            assertFalse(name.isBound());\n-            assertFalse(age.isBound());\n-\n-            \/\/ call\n-            ScopedValue.where(name, \"duke\").where(age, 100).call(() -> {\n-                assertTrue(name.isBound());\n-                assertTrue(age.isBound());\n-                assertEquals(\"duke\", name.get());\n-                assertEquals(100, (int) age.get());\n-                return null;\n-            });\n-            assertFalse(name.isBound());\n-            assertFalse(age.isBound());\n-\n-        });\n-    }\n-\n-    \/**\n-     * Test rebinding.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testRebinding(ThreadFactory factory) throws Exception {\n-        test(factory, () -> {\n-            ScopedValue<String> name = ScopedValue.newInstance();\n-\n-            \/\/ run\n-            ScopedValue.where(name, \"duke\", () -> {\n-                assertTrue(name.isBound());\n-                assertEquals(\"duke\", name.get());\n-\n-                ScopedValue.where(name, \"duchess\", () -> {\n-                    assertTrue(name.isBound());\n-                    assertEquals(\"duchess\", name.get());\n-                });\n-\n-                assertTrue(name.isBound());\n-                assertEquals(\"duke\", name.get());\n-            });\n-            assertFalse(name.isBound());\n-\n-            \/\/ call\n-            ScopedValue.where(name, \"duke\", () -> {\n-                assertTrue(name.isBound());\n-                assertEquals(\"duke\", name.get());\n-\n-                ScopedValue.where(name, \"duchess\", () -> {\n-                    assertTrue(name.isBound());\n-                    assertEquals(\"duchess\", name.get());\n-                    return null;\n-                });\n-\n-                assertTrue(name.isBound());\n-                assertEquals(\"duke\", name.get());\n-                return null;\n-            });\n-            assertFalse(name.isBound());\n-        });\n-    }\n-\n-    \/**\n-     * Test rebinding from null vaue to another value.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testRebindingFromNull(ThreadFactory factory) throws Exception {\n-        test(factory, () -> {\n-            ScopedValue<String> name = ScopedValue.newInstance();\n-\n-            \/\/ run\n-            ScopedValue.where(name, null, () -> {\n-                assertTrue(name.isBound());\n-                assertNull(name.get());\n-\n-                ScopedValue.where(name, \"duchess\", () -> {\n-                    assertTrue(name.isBound());\n-                    assertTrue(\"duchess\".equals(name.get()));\n-                });\n-\n-                assertTrue(name.isBound());\n-                assertNull(name.get());\n-            });\n-            assertFalse(name.isBound());\n-\n-            \/\/ call\n-            ScopedValue.where(name, null, () -> {\n-                assertTrue(name.isBound());\n-                assertNull(name.get());\n-\n-                ScopedValue.where(name, \"duchess\", () -> {\n-                    assertTrue(name.isBound());\n-                    assertTrue(\"duchess\".equals(name.get()));\n-                    return null;\n-                });\n-\n-                assertTrue(name.isBound());\n-                assertNull(name.get());\n-                return null;\n-            });\n-            assertFalse(name.isBound());\n-        });\n-    }\n-\n-    \/**\n-     * Test rebinding to null value.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testRebindingToNull(ThreadFactory factory) throws Exception {\n-        test(factory, () -> {\n-            ScopedValue<String> name = ScopedValue.newInstance();\n-\n-            \/\/ run\n-            ScopedValue.where(name, \"duke\", () -> {\n-                assertTrue(name.isBound());\n-                assertEquals(\"duke\", name.get());\n-\n-                ScopedValue.where(name, null, () -> {\n-                    assertTrue(name.isBound());\n-                    assertNull(name.get());\n-                });\n-\n-                assertTrue(name.isBound());\n-                assertEquals(\"duke\", name.get());\n-            });\n-            assertFalse(name.isBound());\n-\n-            \/\/ call\n-            ScopedValue.where(name, \"duke\", () -> {\n-                assertTrue(name.isBound());\n-                assertEquals(\"duke\", name.get());\n-\n-                ScopedValue.where(name, null, () -> {\n-                    assertTrue(name.isBound());\n-                    assertNull(name.get());\n-                    return null;\n-                });\n-\n-                assertTrue(name.isBound());\n-                assertEquals(\"duke\", name.get());\n-                return null;\n-            });\n-            assertFalse(name.isBound());\n-        });\n-    }\n-\n-    \/**\n-     * Test Carrier.get.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testCarrierGet(ThreadFactory factory) throws Exception {\n-        test(factory, () -> {\n-            ScopedValue<String> name = ScopedValue.newInstance();\n-            ScopedValue<Integer> age = ScopedValue.newInstance();\n-\n-            \/\/ one scoped value\n-            var carrier1 = ScopedValue.where(name, \"duke\");\n-            assertEquals(\"duke\", carrier1.get(name));\n-            assertThrows(NoSuchElementException.class, () -> carrier1.get(age));\n-\n-            \/\/ two scoped values\n-            var carrier2 = carrier1.where(age, 20);\n-            assertEquals(\"duke\", carrier2.get(name));\n-            assertEquals(20, (int) carrier2.get(age));\n-        });\n-    }\n-\n-    \/**\n-     * Test NullPointerException.\n-     *\/\n-    @Test\n-    void testNullPointerException() {\n-        ScopedValue<String> name = ScopedValue.newInstance();\n-\n-        assertThrows(NullPointerException.class, () -> ScopedValue.where(null, \"value\"));\n-        assertThrows(NullPointerException.class, () -> ScopedValue.where(null, \"value\", () -> { }));\n-        assertThrows(NullPointerException.class, () -> ScopedValue.where(null, \"value\", () -> null));\n-\n-        assertThrows(NullPointerException.class, () -> name.orElseThrow(null));\n-\n-        var carrier = ScopedValue.where(name, \"duke\");\n-        assertThrows(NullPointerException.class, () -> carrier.where(null, \"value\"));\n-        assertThrows(NullPointerException.class, () -> carrier.get(null));\n-        assertThrows(NullPointerException.class, () -> carrier.run(null));\n-        assertThrows(NullPointerException.class, () -> carrier.call(null));\n-    }\n-\n-    @FunctionalInterface\n-    private interface ThrowingRunnable {\n-        void run() throws Exception;\n-    }\n-\n-    \/**\n-     * Run the given task in a thread created with the given thread factory.\n-     * @throws Exception if the task throws an exception\n-     *\/\n-    private static void test(ThreadFactory factory, ThrowingRunnable task) throws Exception {\n-        try (var executor = Executors.newThreadPerTaskExecutor(factory)) {\n-            var future = executor.submit(() -> {\n-                task.run();\n-                return null;\n-            });\n-            try {\n-                future.get();\n-            } catch (ExecutionException ee) {\n-                Throwable cause = ee.getCause();\n-                if (cause instanceof Exception e)\n-                    throw e;\n-                if (cause instanceof Error e)\n-                    throw e;\n-                throw new RuntimeException(cause);\n-            }\n-        }\n-    }\n-}\n","filename":"test\/jdk\/jdk\/incubator\/concurrent\/ScopedValue\/ScopeValueAPI.java","additions":0,"deletions":452,"binary":false,"changes":452,"status":"deleted"},{"patch":"@@ -1,1305 +0,0 @@\n-\/*\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test id=platform\n- * @bug 8284199\n- * @summary Basic tests for StructuredTaskScope\n- * @modules jdk.incubator.concurrent\n- * @run junit\/othervm -DthreadFactory=platform StructuredTaskScopeTest\n- *\/\n-\n-\/*\n- * @test id=virtual\n- * @modules jdk.incubator.concurrent\n- * @run junit\/othervm -DthreadFactory=virtual StructuredTaskScopeTest\n- *\/\n-\n-import jdk.incubator.concurrent.StructuredTaskScope;\n-import jdk.incubator.concurrent.StructuredTaskScope.ShutdownOnSuccess;\n-import jdk.incubator.concurrent.StructuredTaskScope.ShutdownOnFailure;\n-import jdk.incubator.concurrent.StructureViolationException;\n-import java.time.Duration;\n-import java.io.IOException;\n-import java.time.Instant;\n-import java.util.ArrayList;\n-import java.util.NoSuchElementException;\n-import java.util.List;\n-import java.util.Set;\n-import java.util.concurrent.Callable;\n-import java.util.concurrent.CancellationException;\n-import java.util.concurrent.CopyOnWriteArrayList;\n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.Future;\n-import java.util.concurrent.ThreadFactory;\n-import java.util.concurrent.TimeoutException;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.RejectedExecutionException;\n-import java.util.concurrent.ScheduledExecutorService;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.concurrent.atomic.AtomicReference;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-\n-import org.junit.jupiter.api.Test;\n-import org.junit.jupiter.api.BeforeAll;\n-import org.junit.jupiter.api.AfterAll;\n-import org.junit.jupiter.params.ParameterizedTest;\n-import org.junit.jupiter.params.provider.MethodSource;\n-import static org.junit.jupiter.api.Assertions.*;\n-\n-class StructuredTaskScopeTest {\n-    private static ScheduledExecutorService scheduler;\n-    private static List<ThreadFactory> threadFactories;\n-\n-    @BeforeAll\n-    static void setup() throws Exception {\n-        scheduler = Executors.newSingleThreadScheduledExecutor();\n-\n-        \/\/ thread factories\n-        String value = System.getProperty(\"threadFactory\");\n-        List<ThreadFactory> list = new ArrayList<>();\n-        if (value == null || value.equals(\"platform\"))\n-            list.add(Thread.ofPlatform().factory());\n-        if (value == null || value.equals(\"virtual\"))\n-            list.add(Thread.ofVirtual().factory());\n-        assertTrue(list.size() > 0, \"No thread factories for tests\");\n-        threadFactories = list;\n-    }\n-\n-    @AfterAll\n-    static void shutdown() {\n-        scheduler.shutdown();\n-    }\n-\n-    private static Stream<ThreadFactory> factories() {\n-        return threadFactories.stream();\n-    }\n-\n-    \/**\n-     * Test that each fork creates a thread.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testFork1(ThreadFactory factory) throws Exception {\n-        AtomicInteger count = new AtomicInteger();\n-        try (var scope = new StructuredTaskScope(null, factory)) {\n-            for (int i = 0; i < 100; i++) {\n-                scope.fork(() -> count.incrementAndGet());\n-            }\n-            scope.join();\n-        }\n-        assertTrue(count.get() == 100);\n-    }\n-\n-    \/**\n-     * Test that fork uses the specified thread factory.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testFork2(ThreadFactory factory) throws Exception {\n-        AtomicInteger count = new AtomicInteger();\n-        ThreadFactory countingFactory = task -> {\n-            count.incrementAndGet();\n-            return factory.newThread(task);\n-        };\n-        try (var scope = new StructuredTaskScope(null, countingFactory)) {\n-            for (int i = 0; i < 100; i++) {\n-                scope.fork(() -> null);\n-            }\n-            scope.join();\n-        }\n-        assertTrue(count.get() == 100);\n-    }\n-\n-    \/**\n-     * Test fork is confined to threads in the scope \"tree\".\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testForkConfined(ThreadFactory factory) throws Exception {\n-        try (var scope1 = new StructuredTaskScope();\n-             var scope2 = new StructuredTaskScope()) {\n-\n-            \/\/ thread in scope1 cannot fork thread in scope2\n-            Future<Void> future1 = scope1.fork(() -> {\n-                scope2.fork(() -> null).get();\n-                return null;\n-            });\n-            Throwable ex = assertThrows(ExecutionException.class, future1::get);\n-            assertTrue(ex.getCause() instanceof WrongThreadException);\n-\n-            \/\/ thread in scope2 can fork thread in scope1\n-            Future<Void> future2 = scope2.fork(() -> {\n-                scope1.fork(() -> null).get();\n-                return null;\n-            });\n-            future2.get();\n-            assertNull(future2.resultNow());\n-\n-            \/\/ random thread cannot fork\n-            try (var pool = Executors.newCachedThreadPool(factory)) {\n-                Future<Void> future = pool.submit(() -> {\n-                    scope1.fork(() -> null);\n-                    return null;\n-                });\n-                ex = assertThrows(ExecutionException.class, future::get);\n-                assertTrue(ex.getCause() instanceof WrongThreadException);\n-            }\n-\n-            scope2.join();\n-            scope1.join();\n-        }\n-    }\n-\n-    \/**\n-     * Test fork when scope is shutdown.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testForkAfterShutdown(ThreadFactory factory) throws Exception {\n-        AtomicInteger count = new AtomicInteger();\n-        try (var scope = new StructuredTaskScope(null, factory)) {\n-            scope.shutdown();\n-            Future<String> future = scope.fork(() -> {\n-                count.incrementAndGet();\n-                return \"foo\";\n-            });\n-            assertTrue(future.isCancelled());\n-            scope.join();\n-        }\n-        assertTrue(count.get() == 0);   \/\/ check that task did not run.\n-    }\n-\n-    \/**\n-     * Test fork when scope is closed.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testForkAfterClose(ThreadFactory factory) throws Exception {\n-        try (var scope = new StructuredTaskScope(null, factory)) {\n-            scope.join();\n-            scope.close();\n-            assertThrows(IllegalStateException.class, () -> scope.fork(() -> null));\n-        }\n-    }\n-\n-    \/**\n-     * Test fork when the thread factory rejects creating a thread.\n-     *\/\n-    @Test\n-    void testForkReject() throws Exception {\n-        ThreadFactory factory = task -> null;\n-        try (var scope = new StructuredTaskScope(null, factory)) {\n-            assertThrows(RejectedExecutionException.class, () -> scope.fork(() -> null));\n-            scope.join();\n-        }\n-    }\n-\n-    \/**\n-     * A StructuredTaskScope that collects all Future objects notified to the\n-     * handleComplete method.\n-     *\/\n-    private static class CollectAll<T> extends StructuredTaskScope<T> {\n-        private final List<Future<T>> futures = new CopyOnWriteArrayList<>();\n-\n-        CollectAll(ThreadFactory factory) {\n-            super(null, factory);\n-        }\n-\n-        @Override\n-        protected void handleComplete(Future<T> future) {\n-            assertTrue(future.isDone());\n-            futures.add(future);\n-        }\n-\n-        Stream<Future<T>> futures() {\n-            return futures.stream();\n-        }\n-\n-        Set<Future<T>> futuresAsSet() {\n-            return futures.stream().collect(Collectors.toSet());\n-        }\n-    }\n-\n-    \/**\n-     * Test that handleComplete method is invoked for tasks that complete normally\n-     * and abnormally.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testHandleComplete1(ThreadFactory factory) throws Exception {\n-        try (var scope = new CollectAll(factory)) {\n-\n-            \/\/ completes normally\n-            Future<String> future1 = scope.fork(() -> \"foo\");\n-\n-            \/\/ completes with exception\n-            Future<String> future2 = scope.fork(() -> { throw new FooException(); });\n-\n-            \/\/ cancelled\n-            Future<String> future3 = scope.fork(() -> {\n-                Thread.sleep(Duration.ofDays(1));\n-                return null;\n-            });\n-            future3.cancel(true);\n-\n-            scope.join();\n-\n-            Set<Future<String>> futures = scope.futuresAsSet();\n-            assertEquals(Set.of(future1, future2, future3), futures);\n-        }\n-    }\n-\n-    \/**\n-     * Test that the handeComplete method is not invoked after the scope has been shutdown.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testHandleComplete2(ThreadFactory factory) throws Exception {\n-        try (var scope = new CollectAll(factory)) {\n-            var latch = new CountDownLatch(1);\n-\n-            \/\/ start task that does not respond to interrupt\n-            Future<String> future1 = scope.fork(() -> {\n-                boolean done = false;\n-                while (!done) {\n-                    try {\n-                        latch.await();\n-                        done = true;\n-                    } catch (InterruptedException e) { }\n-                }\n-                return null;\n-            });\n-\n-            \/\/ start a second task to shutdown the scope after a short delay\n-            Future<String> future2 = scope.fork(() -> {\n-                Thread.sleep(Duration.ofMillis(100));\n-                scope.shutdown();\n-                return null;\n-            });\n-\n-            scope.join();\n-\n-            \/\/ let task finish\n-            latch.countDown();\n-\n-            \/\/ handleComplete should not have been called\n-            assertTrue(future1.isDone());\n-            assertTrue(scope.futures().count() == 0L);\n-        }\n-    }\n-\n-    \/**\n-     * Test join with no threads.\n-     *\/\n-    @Test\n-    void testJoinWithNoThreads() throws Exception {\n-        try (var scope = new StructuredTaskScope()) {\n-            scope.join();\n-        }\n-    }\n-\n-    \/**\n-     * Test join with threads running.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testJoinWithThreads(ThreadFactory factory) throws Exception {\n-        try (var scope = new StructuredTaskScope(null, factory)) {\n-            Future<String> future = scope.fork(() -> {\n-                Thread.sleep(Duration.ofMillis(50));\n-                return \"foo\";\n-            });\n-            scope.join();\n-            assertEquals(\"foo\", future.resultNow());\n-        }\n-    }\n-\n-    \/**\n-     * Test join is owner confined.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testJoinConfined(ThreadFactory factory) throws Exception {\n-        try (var scope = new StructuredTaskScope()) {\n-            \/\/ attempt to join on thread in scope\n-            Future<Void> future1 = scope.fork(() -> {\n-                scope.join();\n-                return null;\n-            });\n-            Throwable ex = assertThrows(ExecutionException.class, future1::get);\n-            assertTrue(ex.getCause() instanceof WrongThreadException);\n-\n-            \/\/ random thread cannot join\n-            try (var pool = Executors.newCachedThreadPool(factory)) {\n-                Future<Void> future2 = pool.submit(() -> {\n-                    scope.join();\n-                    return null;\n-                });\n-                ex = assertThrows(ExecutionException.class, future2::get);\n-                assertTrue(ex.getCause() instanceof WrongThreadException);\n-            }\n-\n-            scope.join();\n-        }\n-    }\n-\n-    \/**\n-     * Test join with interrupt status set.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testInterruptJoin1(ThreadFactory factory) throws Exception {\n-        try (var scope = new StructuredTaskScope(null, factory)) {\n-            var latch = new CountDownLatch(1);\n-\n-            Future<String> future = scope.fork(() -> {\n-                latch.await();\n-                return \"foo\";\n-            });\n-\n-            \/\/ join should throw\n-            Thread.currentThread().interrupt();\n-            try {\n-                scope.join();\n-                fail(\"join did not throw\");\n-            } catch (InterruptedException expected) {\n-                assertFalse(Thread.interrupted());   \/\/ interrupt status should be clear\n-            } finally {\n-                \/\/ let task continue\n-                latch.countDown();\n-            }\n-\n-            \/\/ join should complete\n-            scope.join();\n-            assertEquals(\"foo\", future.resultNow());\n-        }\n-    }\n-\n-    \/**\n-     * Test interrupt of thread blocked in join.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testInterruptJoin2(ThreadFactory factory) throws Exception {\n-        try (var scope = new StructuredTaskScope(null, factory)) {\n-            var latch = new CountDownLatch(1);\n-\n-            Future<String> future = scope.fork(() -> {\n-                latch.await();\n-                return \"foo\";\n-            });\n-\n-            \/\/ join should throw\n-            scheduleInterrupt(Thread.currentThread(), Duration.ofMillis(500));\n-            try {\n-                scope.join();\n-                fail(\"join did not throw\");\n-            } catch (InterruptedException expected) {\n-                assertFalse(Thread.interrupted());   \/\/ interrupt status should be clear\n-            } finally {\n-                \/\/ let task continue\n-                latch.countDown();\n-            }\n-\n-            \/\/ join should complete\n-            scope.join();\n-            assertEquals(\"foo\", future.resultNow());\n-        }\n-    }\n-\n-    \/**\n-     * Test join when scope is already shutdown.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testJoinWithShutdown1(ThreadFactory factory) throws Exception {\n-        try (var scope = new StructuredTaskScope(null, factory)) {\n-            Future<String> future = scope.fork(() -> {\n-                Thread.sleep(Duration.ofDays(1));\n-                return \"foo\";\n-            });\n-            scope.shutdown();  \/\/ interrupts task\n-            scope.join();\n-\n-            \/\/ task should have completed abnormally\n-            assertTrue(future.isDone() && future.state() != Future.State.SUCCESS);\n-        }\n-    }\n-\n-    \/**\n-     * Test shutdown when owner is blocked in join.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testJoinWithShutdown2(ThreadFactory factory) throws Exception {\n-        class MyScope<T> extends StructuredTaskScope<T> {\n-            MyScope(ThreadFactory factory) {\n-                super(null, factory);\n-            }\n-            @Override\n-            protected void handleComplete(Future<T> future) {\n-                shutdown();\n-            }\n-        }\n-\n-        try (var scope = new MyScope(factory)) {\n-            Future<String> future1 = scope.fork(() -> {\n-                Thread.sleep(Duration.ofDays(1));\n-                return \"foo\";\n-            });\n-            Future<String> future2 = scope.fork(() -> {\n-                Thread.sleep(Duration.ofMillis(50));\n-                return null;\n-            });\n-            scope.join();\n-\n-            \/\/ task1 should have completed abnormally\n-            assertTrue(future1.isDone() && future1.state() != Future.State.SUCCESS);\n-\n-            \/\/ task2 should have completed normally\n-            assertTrue(future2.isDone() && future2.state() == Future.State.SUCCESS);\n-        }\n-    }\n-\n-    \/**\n-     * Test join after scope is shutdown.\n-     *\/\n-    @Test\n-    void testJoinAfterShutdown() throws Exception {\n-        try (var scope = new StructuredTaskScope()) {\n-            scope.shutdown();\n-            scope.join();\n-        }\n-    }\n-\n-    \/**\n-     * Test join after scope is closed.\n-     *\/\n-    @Test\n-    void testJoinAfterClose() throws Exception {\n-        try (var scope = new StructuredTaskScope()) {\n-            scope.join();\n-            scope.close();\n-            assertThrows(IllegalStateException.class, () -> scope.join());\n-            assertThrows(IllegalStateException.class, () -> scope.joinUntil(Instant.now()));\n-        }\n-    }\n-\n-    \/**\n-     * Test joinUntil, threads finish before deadline expires.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testJoinUntil1(ThreadFactory factory) throws Exception {\n-        try (var scope = new StructuredTaskScope(null, factory)) {\n-            Future<String> future = scope.fork(() -> {\n-                try {\n-                    Thread.sleep(Duration.ofSeconds(2));\n-                } catch (InterruptedException e) { }\n-                return null;\n-            });\n-\n-            long startMillis = millisTime();\n-            scope.joinUntil(Instant.now().plusSeconds(30));\n-            assertTrue(future.isDone());\n-            assertNull(future.resultNow());\n-            expectDuration(startMillis, \/*min*\/1900, \/*max*\/20_000);\n-        }\n-    }\n-\n-    \/**\n-     * Test joinUntil, deadline expires before threads finish.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testJoinUntil2(ThreadFactory factory) throws Exception {\n-        try (var scope = new StructuredTaskScope(null, factory)) {\n-            Future<String> future = scope.fork(() -> {\n-                try {\n-                    Thread.sleep(Duration.ofSeconds(30));\n-                } catch (InterruptedException e) { }\n-                return null;\n-            });\n-\n-            long startMillis = millisTime();\n-            try {\n-                scope.joinUntil(Instant.now().plusSeconds(2));\n-            } catch (TimeoutException e) {\n-                expectDuration(startMillis, \/*min*\/1900, \/*max*\/20_000);\n-            }\n-            assertFalse(future.isDone());\n-        }\n-    }\n-\n-    \/**\n-     * Test joinUntil many times.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testJoinUntil3(ThreadFactory factory) throws Exception {\n-        try (var scope = new StructuredTaskScope(null, factory)) {\n-            Future<String> future = scope.fork(() -> {\n-                try {\n-                    Thread.sleep(Duration.ofSeconds(30));\n-                } catch (InterruptedException e) { }\n-                return null;\n-            });\n-\n-            try {\n-                for (int i = 0; i < 3; i++) {\n-                    try {\n-                        scope.joinUntil(Instant.now().plusMillis(50));\n-                        fail(\"joinUntil did not throw\");\n-                    } catch (TimeoutException expected) {\n-                        assertFalse(future.isDone());\n-                    }\n-                }\n-            } finally {\n-                future.cancel(true);\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Test joinUntil with a deadline that has already expired.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testJoinUntil4(ThreadFactory factory) throws Exception {\n-        try (var scope = new StructuredTaskScope(null, factory)) {\n-            Future<String> future = scope.fork(() -> {\n-                try {\n-                    Thread.sleep(Duration.ofSeconds(30));\n-                } catch (InterruptedException e) { }\n-                return null;\n-            });\n-\n-            try {\n-\n-                \/\/ now\n-                try {\n-                    scope.joinUntil(Instant.now());\n-                    fail(\"joinUntil did not throw\");\n-                } catch (TimeoutException expected) {\n-                    assertFalse(future.isDone());\n-                }\n-\n-                \/\/ in the past\n-                try {\n-                    scope.joinUntil(Instant.now().minusSeconds(1));\n-                    fail(\"joinUntil did not throw\");\n-                } catch (TimeoutException expected) {\n-                    assertFalse(future.isDone());\n-                }\n-\n-            } finally {\n-                future.cancel(true);\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Test joinUntil with interrupt status set.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testInterruptJoinUntil1(ThreadFactory factory) throws Exception {\n-        try (var scope = new StructuredTaskScope(null, factory)) {\n-            var latch = new CountDownLatch(1);\n-\n-            Future<String> future = scope.fork(() -> {\n-                latch.await();\n-                return \"foo\";\n-            });\n-\n-            \/\/ joinUntil should throw\n-            Thread.currentThread().interrupt();\n-            try {\n-                scope.joinUntil(Instant.now().plusSeconds(30));\n-                fail(\"joinUntil did not throw\");\n-            } catch (InterruptedException expected) {\n-                assertFalse(Thread.interrupted());   \/\/ interrupt status should be clear\n-            } finally {\n-                \/\/ let task continue\n-                latch.countDown();\n-            }\n-\n-            \/\/ join should complete\n-            scope.join();\n-            assertEquals(\"foo\", future.resultNow());\n-        }\n-    }\n-\n-    \/**\n-     * Test interrupt of thread blocked in joinUntil.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testInterruptJoinUntil2(ThreadFactory factory) throws Exception {\n-        try (var scope = new StructuredTaskScope(null, factory)) {\n-            var latch = new CountDownLatch(1);\n-\n-            Future<String> future = scope.fork(() -> {\n-                latch.await();\n-                return \"foo\";\n-            });\n-\n-            \/\/ joinUntil should throw\n-            scheduleInterrupt(Thread.currentThread(), Duration.ofMillis(500));\n-            try {\n-                scope.joinUntil(Instant.now().plusSeconds(10));\n-                fail(\"joinUntil did not throw\");\n-            } catch (InterruptedException expected) {\n-                assertFalse(Thread.interrupted());   \/\/ interrupt status should be clear\n-            } finally {\n-                \/\/ let task continue\n-                latch.countDown();\n-            }\n-\n-            \/\/ join should complete\n-            scope.join();\n-            assertEquals(\"foo\", future.resultNow());\n-        }\n-    }\n-\n-    \/**\n-     * Test shutdown after scope is closed.\n-     *\/\n-    @Test\n-    void testShutdownAfterClose() throws Exception {\n-        try (var scope = new StructuredTaskScope()) {\n-            scope.join();\n-            scope.close();\n-            assertThrows(IllegalStateException.class, () -> scope.shutdown());\n-        }\n-    }\n-\n-    \/**\n-     * Test shutdown is confined to threads in the scope \"tree\".\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testShutdownConfined(ThreadFactory factory) throws Exception {\n-        try (var scope1 = new StructuredTaskScope();\n-             var scope2 = new StructuredTaskScope()) {\n-\n-            \/\/ random thread cannot shutdown\n-            try (var pool = Executors.newCachedThreadPool(factory)) {\n-                Future<Void> future = pool.submit(() -> {\n-                    scope1.shutdown();\n-                    return null;\n-                });\n-                Throwable ex = assertThrows(ExecutionException.class, future::get);\n-                assertTrue(ex.getCause() instanceof WrongThreadException);\n-            }\n-\n-            \/\/ thread in scope1 cannot shutdown scope2\n-            Future<Void> future1 = scope1.fork(() -> {\n-                scope2.shutdown();\n-                return null;\n-            });\n-            Throwable ex = assertThrows(ExecutionException.class, future1::get);\n-            assertTrue(ex.getCause() instanceof WrongThreadException);\n-\n-            \/\/ thread in scope2 can shutdown scope1\n-            Future<Void> future2 = scope2.fork(() -> {\n-                scope1.shutdown();\n-                return null;\n-            });\n-            future2.get();\n-            assertNull(future2.resultNow());\n-\n-            scope2.join();\n-            scope1.join();\n-        }\n-    }\n-\n-    \/**\n-     * Test close without join, no threads forked.\n-     *\/\n-    @Test\n-    void testCloseWithoutJoin1() {\n-        try (var scope = new StructuredTaskScope()) {\n-            \/\/ do nothing\n-        }\n-    }\n-\n-    \/**\n-     * Test close without join, threads forked.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testCloseWithoutJoin2(ThreadFactory factory) {\n-        try (var scope = new StructuredTaskScope(null, factory)) {\n-            Future<String> future = scope.fork(() -> {\n-                Thread.sleep(Duration.ofDays(1));\n-                return null;\n-            });\n-            assertThrows(IllegalStateException.class, scope::close);\n-            assertTrue(future.isDone() && future.exceptionNow() != null);\n-        }\n-    }\n-\n-    \/**\n-     * Test close with threads forked after join.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testCloseWithoutJoin3(ThreadFactory factory) throws Exception {\n-        try (var scope = new StructuredTaskScope(null, factory)) {\n-            scope.fork(() -> \"foo\");\n-            scope.join();\n-\n-            Future<String> future = scope.fork(() -> {\n-                Thread.sleep(Duration.ofDays(1));\n-                return null;\n-            });\n-            assertThrows(IllegalStateException.class, scope::close);\n-            assertTrue(future.isDone() && future.exceptionNow() != null);\n-        }\n-    }\n-\n-    \/**\n-     * Test close is owner confined.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testCloseConfined(ThreadFactory factory) throws Exception {\n-        try (var scope = new StructuredTaskScope()) {\n-            \/\/ attempt to close on thread in scope\n-            Future<Void> future1 = scope.fork(() -> {\n-                scope.close();\n-                return null;\n-            });\n-            Throwable ex = assertThrows(ExecutionException.class, future1::get);\n-            assertTrue(ex.getCause() instanceof WrongThreadException);\n-\n-            \/\/ random thread cannot close scope\n-            try (var pool = Executors.newCachedThreadPool(factory)) {\n-                Future<Void> future2 = pool.submit(() -> {\n-                    scope.close();\n-                    return null;\n-                });\n-                ex = assertThrows(ExecutionException.class, future2::get);\n-                assertTrue(ex.getCause() instanceof WrongThreadException);\n-            }\n-\n-            scope.join();\n-        }\n-    }\n-\n-    \/**\n-     * Test close with interrupt status set.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testInterruptClose1(ThreadFactory factory) throws Exception {\n-        try (var scope = new StructuredTaskScope(null, factory)) {\n-            var latch = new CountDownLatch(1);\n-\n-            \/\/ start task that does not respond to interrupt\n-            scope.fork(() -> {\n-                boolean done = false;\n-                while (!done) {\n-                    try {\n-                        latch.await();\n-                        done = true;\n-                    } catch (InterruptedException e) { }\n-                }\n-                return null;\n-            });\n-\n-            scope.shutdown();\n-            scope.join();\n-\n-            \/\/ release task after a delay\n-            scheduler.schedule(latch::countDown, 100, TimeUnit.MILLISECONDS);\n-\n-            \/\/ invoke close with interrupt status set\n-            Thread.currentThread().interrupt();\n-            try {\n-                scope.close();\n-            } finally {\n-                assertTrue(Thread.interrupted());   \/\/ clear interrupt status\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Test interrupting thread waiting in close.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testInterruptClose2(ThreadFactory factory) throws Exception {\n-        try (var scope = new StructuredTaskScope(null, factory)) {\n-            var latch = new CountDownLatch(1);\n-\n-            \/\/ start task that does not respond to interrupt\n-            scope.fork(() -> {\n-                boolean done = false;\n-                while (!done) {\n-                    try {\n-                        latch.await();\n-                        done = true;\n-                    } catch (InterruptedException e) { }\n-                }\n-                return null;\n-            });\n-\n-            scope.shutdown();\n-            scope.join();\n-\n-            \/\/ release task after a delay\n-            scheduleInterrupt(Thread.currentThread(), Duration.ofMillis(500));\n-            scheduler.schedule(latch::countDown, 3, TimeUnit.SECONDS);\n-            try {\n-                scope.close();\n-            } finally {\n-                assertTrue(Thread.interrupted());   \/\/ clear interrupt status\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Test that closing an enclosing scope closes the thread flock of a\n-     * nested scope.\n-     *\/\n-    @Test\n-    void testStructureViolation1() throws Exception {\n-        try (var scope1 = new StructuredTaskScope()) {\n-            try (var scope2 = new StructuredTaskScope()) {\n-\n-                \/\/ join + close enclosing scope\n-                scope1.join();\n-                try {\n-                    scope1.close();\n-                    fail(\"close did not throw\");\n-                } catch (StructureViolationException expected) { }\n-\n-                \/\/ underlying flock should be closed, fork should return a cancelled task\n-                AtomicBoolean ran = new AtomicBoolean();\n-                Future<String> future = scope2.fork(() -> {\n-                    ran.set(true);\n-                    return null;\n-                });\n-                assertTrue(future.isCancelled());\n-                scope2.join();\n-                assertFalse(ran.get());\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Test Future::get, task completes normally.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testFuture1(ThreadFactory factory) throws Exception {\n-        try (var scope = new StructuredTaskScope(null, factory)) {\n-\n-            Future<String> future = scope.fork(() -> {\n-                Thread.sleep(Duration.ofMillis(20));\n-                return \"foo\";\n-            });\n-\n-            assertEquals(\"foo\", future.get());\n-            assertTrue(future.state() == Future.State.SUCCESS);\n-            assertEquals(\"foo\", future.resultNow());\n-\n-            scope.join();\n-        }\n-    }\n-\n-    \/**\n-     * Test Future::get, task completes with exception.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testFuture2(ThreadFactory factory) throws Exception {\n-        try (var scope = new StructuredTaskScope(null, factory)) {\n-\n-            Future<String> future = scope.fork(() -> {\n-                Thread.sleep(Duration.ofMillis(20));\n-                throw new FooException();\n-            });\n-\n-            Throwable ex = assertThrows(ExecutionException.class, future::get);\n-            assertTrue(ex.getCause() instanceof FooException);\n-            assertTrue(future.state() == Future.State.FAILED);\n-            assertTrue(future.exceptionNow() instanceof FooException);\n-\n-            scope.join();\n-        }\n-    }\n-\n-    \/**\n-     * Test Future::get, task is cancelled.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testFuture3(ThreadFactory factory) throws Exception {\n-        try (var scope = new StructuredTaskScope(null, factory)) {\n-\n-            Future<String> future = scope.fork(() -> {\n-                Thread.sleep(Duration.ofDays(1));\n-                return null;\n-            });\n-\n-            \/\/ timed-get, should timeout\n-            try {\n-                future.get(20, TimeUnit.MILLISECONDS);\n-                fail(\"Future.get did not throw\");\n-            } catch (TimeoutException expected) { }\n-\n-            future.cancel(true);\n-            assertThrows(CancellationException.class, future::get);\n-            assertTrue(future.state() == Future.State.CANCELLED);\n-\n-            scope.join();\n-        }\n-    }\n-\n-    \/**\n-     * Test scope shutdown with a thread blocked in Future::get.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testFutureWithShutdown(ThreadFactory factory) throws Exception {\n-        try (var scope = new StructuredTaskScope(null, factory)) {\n-\n-            \/\/ long running task\n-            Future<String> future = scope.fork(() -> {\n-                Thread.sleep(Duration.ofDays(1));\n-                return null;\n-            });\n-\n-            \/\/ start a thread to wait in Future::get\n-            AtomicBoolean waitDone = new AtomicBoolean();\n-            Thread waiter = Thread.startVirtualThread(() -> {\n-                try {\n-                    future.get();\n-                } catch (ExecutionException | CancellationException e) {\n-                    waitDone.set(true);\n-                } catch (InterruptedException e) {\n-                    System.out.println(\"waiter thread interrupted!\");\n-                }\n-            });\n-\n-            \/\/ shutdown scope\n-            scope.shutdown();\n-\n-            \/\/ Future should be done and thread should be awakened\n-            assertTrue(future.isDone());\n-            waiter.join();\n-            assertTrue(waitDone.get());\n-\n-            scope.join();\n-        }\n-    }\n-\n-    \/**\n-     * Test Future::cancel throws if invoked by a thread that is not in the tree.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testFutureCancelConfined(ThreadFactory factory) throws Exception {\n-        try (var scope = new StructuredTaskScope()) {\n-            Future<String> future1 = scope.fork(() -> {\n-                Thread.sleep(Duration.ofDays(1));\n-                return \"foo\";\n-            });\n-\n-            \/\/ random thread cannot cancel\n-            try (var pool = Executors.newCachedThreadPool(factory)) {\n-                Future<Void> future2 = pool.submit(() -> {\n-                    future1.cancel(true);\n-                    return null;\n-                });\n-                Throwable ex = assertThrows(ExecutionException.class, future2::get);\n-                assertTrue(ex.getCause() instanceof WrongThreadException);\n-            } finally {\n-                future1.cancel(true);\n-            }\n-            scope.join();\n-        }\n-    }\n-\n-    \/**\n-     * Test StructuredTaskScope::toString includes the scope name.\n-     *\/\n-    @Test\n-    void testToString() throws Exception {\n-        ThreadFactory factory = Thread.ofVirtual().factory();\n-        try (var scope = new StructuredTaskScope(\"xxx\", factory)) {\n-            \/\/ open\n-            assertTrue(scope.toString().contains(\"xxx\"));\n-\n-            \/\/ shutdown\n-            scope.shutdown();\n-            assertTrue(scope.toString().contains(\"xxx\"));\n-\n-            \/\/ closed\n-            scope.join();\n-            scope.close();\n-            assertTrue(scope.toString().contains(\"xxx\"));\n-        }\n-    }\n-\n-    \/**\n-     * Test for NullPointerException.\n-     *\/\n-    @Test\n-    void testNulls() throws Exception {\n-        assertThrows(NullPointerException.class, () -> new StructuredTaskScope(\"\", null));\n-        try (var scope = new StructuredTaskScope()) {\n-            assertThrows(NullPointerException.class, () -> scope.fork(null));\n-            assertThrows(NullPointerException.class, () -> scope.joinUntil(null));\n-        }\n-\n-        assertThrows(NullPointerException.class, () -> new ShutdownOnSuccess(\"\", null));\n-        try (var scope = new ShutdownOnSuccess<Object>()) {\n-            assertThrows(NullPointerException.class, () -> scope.fork(null));\n-            assertThrows(NullPointerException.class, () -> scope.joinUntil(null));\n-            assertThrows(NullPointerException.class, () -> scope.result(null));\n-        }\n-\n-        assertThrows(NullPointerException.class, () -> new ShutdownOnFailure(\"\", null));\n-        try (var scope = new ShutdownOnFailure()) {\n-            assertThrows(NullPointerException.class, () -> scope.fork(null));\n-            assertThrows(NullPointerException.class, () -> scope.joinUntil(null));\n-            assertThrows(NullPointerException.class, () -> scope.throwIfFailed(null));\n-        }\n-    }\n-\n-    \/**\n-     * Test ShutdownOnSuccess with no completed tasks.\n-     *\/\n-    @Test\n-    void testShutdownOnSuccess1() throws Exception {\n-        try (var scope = new ShutdownOnSuccess<String>()) {\n-            assertThrows(IllegalStateException.class, () -> scope.result());\n-            assertThrows(IllegalStateException.class, () -> scope.result(e -> null));\n-        }\n-    }\n-\n-    \/**\n-     * Test ShutdownOnSuccess with tasks that completed normally.\n-     *\/\n-    @Test\n-    void testShutdownOnSuccess2() throws Exception {\n-        try (var scope = new ShutdownOnSuccess<String>()) {\n-\n-            \/\/ two tasks complete normally\n-            scope.fork(() -> \"foo\");\n-            scope.join();  \/\/ ensures foo completes first\n-            scope.fork(() -> \"bar\");\n-            scope.join();\n-\n-            assertEquals(\"foo\", scope.result());\n-            assertEquals(\"foo\", scope.result(e -> null));\n-        }\n-    }\n-\n-    \/**\n-     * Test ShutdownOnSuccess with tasks that completed normally and abnormally.\n-     *\/\n-    @Test\n-    void testShutdownOnSuccess3() throws Exception {\n-        try (var scope = new ShutdownOnSuccess<String>()) {\n-\n-            \/\/ one task completes normally, the other with an exception\n-            scope.fork(() -> \"foo\");\n-            scope.fork(() -> { throw new ArithmeticException(); });\n-            scope.join();\n-\n-            assertEquals(\"foo\", scope.result());\n-            assertEquals(\"foo\", scope.result(e -> null));\n-        }\n-    }\n-\n-    \/**\n-     * Test ShutdownOnSuccess with a task that completed with an exception.\n-     *\/\n-    @Test\n-    void testShutdownOnSuccess4() throws Exception {\n-        try (var scope = new ShutdownOnSuccess<String>()) {\n-\n-            \/\/ tasks completes with exception\n-            scope.fork(() -> { throw new ArithmeticException(); });\n-            scope.join();\n-\n-            Throwable ex = assertThrows(ExecutionException.class, () -> scope.result());\n-            assertTrue(ex.getCause() instanceof  ArithmeticException);\n-\n-            ex = assertThrows(FooException.class, () -> scope.result(e -> new FooException(e)));\n-            assertTrue(ex.getCause() instanceof  ArithmeticException);\n-        }\n-    }\n-\n-    \/**\n-     * Test ShutdownOnSuccess with a cancelled task.\n-     *\/\n-    @Test\n-    void testShutdownOnSuccess5() throws Exception {\n-        try (var scope = new ShutdownOnSuccess<String>()) {\n-\n-            \/\/ cancelled task\n-            var future = scope.fork(() -> {\n-                Thread.sleep(60_000);\n-                return null;\n-            });\n-            future.cancel(false);\n-\n-            scope.join();\n-\n-            assertThrows(CancellationException.class, () -> scope.result());\n-            Throwable ex = assertThrows(FooException.class,\n-                                        () -> scope.result(e -> new FooException(e)));\n-            assertTrue(ex.getCause() instanceof CancellationException);\n-        }\n-    }\n-\n-    \/**\n-     * Test ShutdownOnFailure with no completed tasks.\n-     *\/\n-    @Test\n-    void testShutdownOnFailure1() throws Throwable {\n-        try (var scope = new ShutdownOnFailure()) {\n-            assertTrue(scope.exception().isEmpty());\n-            scope.throwIfFailed();\n-            scope.throwIfFailed(e -> new FooException(e));\n-        }\n-    }\n-\n-    \/**\n-     * Test ShutdownOnFailure with tasks that completed normally.\n-     *\/\n-    @Test\n-    void testShutdownOnFailure2() throws Throwable {\n-        try (var scope = new ShutdownOnFailure()) {\n-            scope.fork(() -> \"foo\");\n-            scope.fork(() -> \"bar\");\n-            scope.join();\n-\n-            \/\/ no exception\n-            assertTrue(scope.exception().isEmpty());\n-            scope.throwIfFailed();\n-            scope.throwIfFailed(e -> new FooException(e));\n-        }\n-    }\n-\n-    \/**\n-     * Test ShutdownOnFailure with tasks that completed normally and abnormally.\n-     *\/\n-    @Test\n-    void testShutdownOnFailure3() throws Throwable {\n-        try (var scope = new ShutdownOnFailure()) {\n-\n-            \/\/ one task completes normally, the other with an exception\n-            scope.fork(() -> \"foo\");\n-            scope.fork(() -> { throw new ArithmeticException(); });\n-            scope.join();\n-\n-            Throwable ex = scope.exception().orElse(null);\n-            assertTrue(ex instanceof ArithmeticException);\n-\n-            ex = assertThrows(ExecutionException.class, () -> scope.throwIfFailed());\n-            assertTrue(ex.getCause() instanceof ArithmeticException);\n-\n-            ex = assertThrows(FooException.class,\n-                              () -> scope.throwIfFailed(e -> new FooException(e)));\n-            assertTrue(ex.getCause() instanceof ArithmeticException);\n-        }\n-    }\n-\n-    \/**\n-     * Test ShutdownOnFailure with a cancelled task.\n-     *\/\n-    @Test\n-    void testShutdownOnFailure4() throws Throwable {\n-        try (var scope = new ShutdownOnFailure()) {\n-\n-            var future = scope.fork(() -> {\n-                Thread.sleep(60_000);\n-                return null;\n-            });\n-            future.cancel(false);\n-\n-            scope.join();\n-\n-            Throwable ex = scope.exception().orElse(null);\n-            assertTrue(ex instanceof CancellationException);\n-\n-            assertThrows(CancellationException.class, () -> scope.throwIfFailed());\n-\n-            ex = assertThrows(FooException.class,\n-                              () -> scope.throwIfFailed(e -> new FooException(e)));\n-            assertTrue(ex.getCause() instanceof CancellationException);\n-        }\n-    }\n-\n-    \/**\n-     * A runtime exception for tests.\n-     *\/\n-    private static class FooException extends RuntimeException {\n-        FooException() { }\n-        FooException(Throwable cause) { super(cause); }\n-    }\n-\n-    \/**\n-     * Schedules a thread to be interrupted after the given delay.\n-     *\/\n-    private void scheduleInterrupt(Thread thread, Duration delay) {\n-        long millis = delay.toMillis();\n-        scheduler.schedule(thread::interrupt, millis, TimeUnit.MILLISECONDS);\n-    }\n-\n-    \/**\n-     * Returns the current time in milliseconds.\n-     *\/\n-    private static long millisTime() {\n-        long now = System.nanoTime();\n-        return TimeUnit.MILLISECONDS.convert(now, TimeUnit.NANOSECONDS);\n-    }\n-\n-    \/**\n-     * Check the duration of a task\n-     * @param start start time, in milliseconds\n-     * @param min minimum expected duration, in milliseconds\n-     * @param max maximum expected duration, in milliseconds\n-     * @return the duration (now - start), in milliseconds\n-     *\/\n-    private static long expectDuration(long start, long min, long max) {\n-        long duration = millisTime() - start;\n-        assertTrue(duration >= min,\n-                \"Duration \" + duration + \"ms, expected >= \" + min + \"ms\");\n-        assertTrue(duration <= max,\n-                \"Duration \" + duration + \"ms, expected <= \" + max + \"ms\");\n-        return duration;\n-    }\n-}\n","filename":"test\/jdk\/jdk\/incubator\/concurrent\/StructuredTaskScope\/StructuredTaskScopeTest.java","additions":0,"deletions":1305,"binary":false,"changes":1305,"status":"deleted"},{"patch":"@@ -1,219 +0,0 @@\n-\/*\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @summary Basic tests for StructuredTaskScope with scoped values\n- * @modules jdk.incubator.concurrent\n- * @run junit WithScopedValue\n- *\/\n-\n-import jdk.incubator.concurrent.ScopedValue;\n-import jdk.incubator.concurrent.StructuredTaskScope;\n-import jdk.incubator.concurrent.StructureViolationException;\n-import java.util.concurrent.Future;\n-import java.util.concurrent.ThreadFactory;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-import java.util.stream.Stream;\n-\n-import org.junit.jupiter.api.Test;\n-import org.junit.jupiter.params.ParameterizedTest;\n-import org.junit.jupiter.params.provider.MethodSource;\n-import static org.junit.jupiter.api.Assertions.*;\n-\n-class WithScopedValue {\n-\n-    private static Stream<ThreadFactory> factories() {\n-        return Stream.of(Thread.ofPlatform().factory(), Thread.ofVirtual().factory());\n-    }\n-\n-    \/**\n-     * Test that fork inherits a scoped value into a child thread.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testForkInheritsScopedValue1(ThreadFactory factory) throws Exception {\n-        ScopedValue<String> name = ScopedValue.newInstance();\n-        String value = ScopedValue.where(name, \"x\", () -> {\n-            try (var scope = new StructuredTaskScope<String>(null, factory)) {\n-                Future<String> future = scope.fork(() -> {\n-                    return name.get(); \/\/ child should read \"x\"\n-                });\n-                scope.join();\n-                return future.resultNow();\n-            }\n-        });\n-        assertEquals(value, \"x\");\n-    }\n-\n-    \/**\n-     * Test that fork inherits a scoped value into a grandchild thread.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testForkInheritsScopedValue2(ThreadFactory factory) throws Exception {\n-        ScopedValue<String> name = ScopedValue.newInstance();\n-        String value = ScopedValue.where(name, \"x\", () -> {\n-            try (var scope1 = new StructuredTaskScope<String>(null, factory)) {\n-                Future<String> future1 = scope1.fork(() -> {\n-                    try (var scope2 = new StructuredTaskScope<String>(null, factory)) {\n-                        Future<String> future2 = scope2.fork(() -> {\n-                            return name.get(); \/\/ grandchild should read \"x\"\n-                        });\n-                        scope2.join();\n-                        return future2.resultNow();\n-                    }\n-                });\n-                scope1.join();\n-                return future1.resultNow();\n-            }\n-        });\n-        assertEquals(value, \"x\");\n-    }\n-\n-    \/**\n-     * Test that fork inherits a rebound scoped value into a grandchild thread.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testForkInheritsScopedValue3(ThreadFactory factory) throws Exception {\n-        ScopedValue<String> name = ScopedValue.newInstance();\n-        String value = ScopedValue.where(name, \"x\", () -> {\n-            try (var scope1 = new StructuredTaskScope<String>(null, factory)) {\n-                Future<String> future1 = scope1.fork(() -> {\n-                    assertEquals(name.get(), \"x\");  \/\/ child should read \"x\"\n-\n-                    \/\/ rebind name to \"y\"\n-                    String grandchildValue = ScopedValue.where(name, \"y\", () -> {\n-                        try (var scope2 = new StructuredTaskScope<String>(null, factory)) {\n-                            Future<String> future2 = scope2.fork(() -> {\n-                                return name.get(); \/\/ grandchild should read \"y\"\n-                            });\n-                            scope2.join();\n-                            return future2.resultNow();\n-                        }\n-                    });\n-\n-                    assertEquals(name.get(), \"x\");  \/\/ child should read \"x\"\n-                    return grandchildValue;\n-                });\n-                scope1.join();\n-                return future1.resultNow();\n-            }\n-        });\n-        assertEquals(value, \"y\");\n-    }\n-\n-    \/**\n-     * Test exiting a dynamic scope with an open task scope.\n-     *\/\n-    @Test\n-    void testStructureViolation1() throws Exception {\n-        ScopedValue<String> name = ScopedValue.newInstance();\n-        class Box {\n-            StructuredTaskScope<Object> scope;\n-        }\n-        var box = new Box();\n-        try {\n-            try {\n-                ScopedValue.where(name, \"x\", () -> {\n-                    box.scope = new StructuredTaskScope<Object>();\n-                });\n-                fail();\n-            } catch (StructureViolationException expected) { }\n-\n-            \/\/ underlying flock should be closed, fork should return a cancelled task\n-            StructuredTaskScope<Object> scope = box.scope;\n-            AtomicBoolean ran = new AtomicBoolean();\n-            Future<Object> future = scope.fork(() -> {\n-                ran.set(true);\n-                return null;\n-            });\n-            assertTrue(future.isCancelled());\n-            scope.join();\n-            assertFalse(ran.get());\n-\n-        } finally {\n-            StructuredTaskScope<Object> scope = box.scope;\n-            if (scope != null) {\n-                scope.close();\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Test closing a StructuredTaskScope while executing in a dynamic scope.\n-     *\/\n-    @Test\n-    void testStructureViolation2() throws Exception {\n-        ScopedValue<String> name = ScopedValue.newInstance();\n-        try (var scope = new StructuredTaskScope<String>()) {\n-            ScopedValue.where(name, \"x\", () -> {\n-                assertThrows(StructureViolationException.class, scope::close);\n-            });\n-        }\n-    }\n-\n-    \/**\n-     * Test fork when a scoped value is bound after a StructuredTaskScope is created.\n-     *\/\n-    @Test\n-    void testStructureViolation3() throws Exception {\n-        ScopedValue<String> name = ScopedValue.newInstance();\n-        try (var scope = new StructuredTaskScope<String>()) {\n-            ScopedValue.where(name, \"x\", () -> {\n-                assertThrows(StructureViolationException.class,\n-                        () -> scope.fork(() -> \"foo\"));\n-            });\n-        }\n-    }\n-\n-    \/**\n-     * Test fork when a scoped value is re-bound after a StructuredTaskScope is created.\n-     *\/\n-    @Test\n-    void testStructureViolation4() throws Exception {\n-        ScopedValue<String> name1 = ScopedValue.newInstance();\n-        ScopedValue<String> name2 = ScopedValue.newInstance();\n-\n-        \/\/ rebind\n-        ScopedValue.where(name1, \"x\", () -> {\n-            try (var scope = new StructuredTaskScope<String>()) {\n-                ScopedValue.where(name1, \"y\", () -> {\n-                    assertThrows(StructureViolationException.class,\n-                            () -> scope.fork(() -> \"foo\"));\n-                });\n-            }\n-        });\n-\n-        \/\/ new binding\n-        ScopedValue.where(name1, \"x\", () -> {\n-            try (var scope = new StructuredTaskScope<String>()) {\n-                ScopedValue.where(name2, \"y\", () -> {\n-                    assertThrows(StructureViolationException.class,\n-                            () -> scope.fork(() -> \"foo\"));\n-                });\n-            }\n-        });\n-    }\n-}\n","filename":"test\/jdk\/jdk\/incubator\/concurrent\/StructuredTaskScope\/WithScopedValue.java","additions":0,"deletions":219,"binary":false,"changes":219,"status":"deleted"},{"patch":"@@ -1045,1 +1045,1 @@\n-            assertTrue(flock.toString().contains(\"xxx\"));\n+            assertTrue(flock.toString().contains(\"xxxx\"));\n","filename":"test\/jdk\/jdk\/internal\/misc\/ThreadFlock\/ThreadFlockTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @enablePreview\n@@ -28,1 +29,0 @@\n- * @modules jdk.incubator.concurrent\n@@ -33,2 +33,0 @@\n-import jdk.incubator.concurrent.ScopedValue;\n-import jdk.incubator.concurrent.StructureViolationException;\n@@ -36,0 +34,1 @@\n+import java.util.concurrent.StructureViolationException;\n@@ -57,1 +56,1 @@\n-        String value = ScopedValue.where(name, \"duke\", () -> {\n+        String value = ScopedValue.callWhere(name, \"duke\", () -> {\n@@ -83,1 +82,1 @@\n-            ScopedValue.where(name, \"x1\", () -> {\n+            ScopedValue.runWhere(name, \"x1\", () -> {\n@@ -101,1 +100,1 @@\n-            ScopedValue.where(name, \"x1\", () -> {\n+            ScopedValue.runWhere(name, \"x1\", () -> {\n@@ -103,1 +102,1 @@\n-                    ScopedValue.where(name, \"x2\", () -> {\n+                    ScopedValue.runWhere(name, \"x2\", () -> {\n@@ -105,1 +104,1 @@\n-                            ScopedValue.where(name, \"x3\", () -> {\n+                            ScopedValue.runWhere(name, \"x3\", () -> {\n@@ -133,1 +132,1 @@\n-            ScopedValue.where(name, \"x1\", () -> {\n+            ScopedValue.runWhere(name, \"x1\", () -> {\n@@ -135,1 +134,1 @@\n-                    ScopedValue.where(name, \"x2\", () -> {\n+                    ScopedValue.runWhere(name, \"x2\", () -> {\n@@ -137,1 +136,1 @@\n-                            ScopedValue.where(name, \"x3\", () -> {\n+                            ScopedValue.runWhere(name, \"x3\", () -> {\n@@ -165,1 +164,1 @@\n-            ScopedValue.where(name, \"x1\", () -> {\n+            ScopedValue.runWhere(name, \"x1\", () -> {\n@@ -167,1 +166,1 @@\n-                    ScopedValue.where(name, \"x2\", () -> {\n+                    ScopedValue.runWhere(name, \"x2\", () -> {\n@@ -169,1 +168,1 @@\n-                            ScopedValue.where(name, \"x3\", () -> {\n+                            ScopedValue.runWhere(name, \"x3\", () -> {\n@@ -197,1 +196,1 @@\n-            ScopedValue.where(name, \"duke\", () -> {\n+            ScopedValue.runWhere(name, \"duke\", () -> {\n@@ -211,1 +210,1 @@\n-        ScopedValue.where(name, \"duke\", () -> {\n+        ScopedValue.runWhere(name, \"duke\", () -> {\n@@ -213,1 +212,1 @@\n-                ScopedValue.where(name, \"duchess\", () -> {\n+                ScopedValue.runWhere(name, \"duchess\", () -> {\n","filename":"test\/jdk\/jdk\/internal\/misc\/ThreadFlock\/WithScopedValue.java","additions":16,"deletions":17,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-package org.openjdk.bench.jdk.incubator.concurrent;\n+package org.openjdk.bench.java.lang;\n@@ -27,1 +27,1 @@\n-import jdk.incubator.concurrent.ScopedValue;\n+import java.util.concurrent.Callable;\n@@ -29,0 +29,1 @@\n+import java.util.function.Supplier;\n@@ -32,1 +33,1 @@\n-import static org.openjdk.bench.jdk.incubator.concurrent.ScopedValuesData.*;\n+import static org.openjdk.bench.java.lang.ScopedValuesData.*;\n@@ -43,1 +44,1 @@\n-      jvmArgsPrepend = {\"-Djmh.executor.class=org.openjdk.bench.jdk.incubator.concurrent.ScopedValuesExecutorService\",\n+      jvmArgsPrepend = {\"-Djmh.executor.class=org.openjdk.bench.java.lang.ScopedValuesExecutorService\",\n@@ -46,1 +47,0 @@\n-                        \"--add-modules=jdk.incubator.concurrent\",\n@@ -164,1 +164,0 @@\n-\n@@ -168,1 +167,10 @@\n-        return HOLD_42.call(this::getClass);\n+        return HOLD_42.call(aCallable);\n+    }\n+    private static final Callable<Class<?>> aCallable = () -> ScopedValues.class;\n+\n+    \/\/ Same, but make sure that Carrier.get(Supplier) is no slower\n+    \/\/ than Carrier.call(Callable).\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public Object bindViaGet_ScopedValue() {\n+        return HOLD_42.get(aSupplier);\n@@ -170,0 +178,1 @@\n+    private static final Supplier<Class<?>> aSupplier = () -> ScopedValues.class;\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/ScopedValues.java","additions":16,"deletions":7,"binary":false,"changes":23,"previous_filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/concurrent\/ScopedValues.java","status":"renamed"},{"patch":"@@ -24,1 +24,1 @@\n-package org.openjdk.bench.jdk.incubator.concurrent;\n+package org.openjdk.bench.java.lang;\n@@ -26,1 +26,0 @@\n-import jdk.incubator.concurrent.ScopedValue;\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/ScopedValuesData.java","additions":1,"deletions":2,"binary":false,"changes":3,"previous_filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/concurrent\/ScopedValuesData.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,2 +24,1 @@\n-\n-package org.openjdk.bench.jdk.incubator.concurrent;\n+package org.openjdk.bench.java.lang;\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/ScopedValuesExecutorService.java","additions":2,"deletions":3,"binary":false,"changes":5,"previous_filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/concurrent\/ScopedValuesExecutorService.java","status":"renamed"}]}