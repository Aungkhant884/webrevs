{"files":[{"patch":"@@ -45,20 +45,29 @@\n- * A value that is set once and is then available for reading for a bounded period of\n- * execution by a thread. A {@code ScopedValue} allows for safely and efficiently sharing\n- * data for a bounded period of execution without passing the data as method arguments.\n- *\n- * <p> {@code ScopedValue} defines the {@link #runWhere(ScopedValue, Object, Runnable)}\n- * method to set the value of a {@code ScopedValue} for the bounded period of execution by\n- * a thread of the runnable's {@link Runnable#run() run} method. The unfolding execution of\n- * the methods executed by {@code run} defines a <b><em>dynamic scope<\/em><\/b>. The scoped\n- * value is {@linkplain #isBound() bound} while executing in the dynamic scope, it reverts\n- * to being <em>unbound<\/em> when the {@code run} method completes (normally or with an\n- * exception). Code executing in the dynamic scope uses the {@code ScopedValue} {@link\n- * #get() get} method to read its value.\n- *\n- * <p> Like a {@linkplain ThreadLocal thread-local variable}, a scoped value has multiple\n- * incarnations, one per thread. The particular incarnation that is used depends on which\n- * thread calls its methods.\n- *\n- * <p> Consider the following example with a scoped value {@code USERNAME} that is\n- * <em>bound<\/em> to the value \"{@code duke}\" for the execution, by a thread, of a run\n- * method that invokes {@code doSomething()}.\n+ * A value that may be safely and efficiently shared to methods without using method\n+ * parameters.\n+ *\n+ * <p> In the Java programming language, data is usually passed to a method by means of a\n+ * method parameter. The data may need to be passed through a sequence of many methods to\n+ * get to the method that makes use of the data. Every method in the sequence of calls\n+ * needs to declare the parameter and every method has access to the data.\n+ * {@code ScopedValue} provides a means to pass data to a faraway method (typically a\n+ * <em>callback<\/em>) without using method parameters. In effect, a {@code ScopedValue}\n+ * is an <em>implicit method parameter<\/em>. It is \"as if\" every method in a sequence of\n+ * calls has an additional parameter. None of the methods declare the parameter and only\n+ * the methods that have access to the {@code ScopedValue} object can access its value\n+ * (the data). {@code ScopedValue} makes it possible to securely pass data from a\n+ * <em>caller<\/em> to a faraway <em>callee<\/em> through a sequence of intermediate methods\n+ * that do not declare a parameter for the data and have no access to the data.\n+ *\n+ * <p> The {@code ScopedValue} API works by executing a method with a {@code ScopedValue}\n+ * object <em>bound<\/em> to some value for the bounded period of execution of a method.\n+ * The method may invoke another method, which in turn may invoke another. The unfolding\n+ * execution of the methods define a <em>dynamic scope<\/em>. Code in these methods with\n+ * access to the {@code ScopedValue} object may read its value. The {@code ScopedValue}\n+ * object reverts to being <em>unbound<\/em> when the original method completes normally or\n+ * with an exception. The {@code ScopedValue} API supports executing a {@link Runnable#run()\n+ * Runnable.run}, {@link Callable#call() Callable.call}, or {@link Supplier#get() Supplier.get}\n+ * method with a {@code ScopedValue} bound to a value.\n+ *\n+ * <p> Consider the following example with a scoped value \"{@code NAME}\" bound to the value\n+ * \"{@code duke}\" for the execution of a {@code run} method. The {@code run} method, in\n+ * turn, invokes {@code doSomething}.\n@@ -67,1 +76,1 @@\n- *     private static final ScopedValue<String> USERNAME = ScopedValue.newInstance();\n+ *     private static final ScopedValue<String> NAME = ScopedValue.newInstance();\n@@ -69,1 +78,2 @@\n- *     ScopedValue.runWhere(USERNAME, \"duke\", () -> doSomething());\n+ *     \/\/ @link substring=\"runWhere\" target=\"#runWhere\" :\n+ *     ScopedValue.runWhere(NAME, \"duke\", () -> doSomething());\n@@ -71,19 +81,4 @@\n- * Code executed directly or indirectly by {@code doSomething()} that invokes {@code\n- * USERNAME.get()} will read the value \"{@code duke}\". The scoped value is bound while\n- * executing {@code doSomething()} and becomes unbound when {@code doSomething()}\n- * completes (normally or with an exception). If one thread were to call {@code\n- * doSomething()} with {@code USERNAME} bound to \"{@code duke1}\", and another thread\n- * were to call the method with {@code USERNAME} bound to \"{@code duke2}\", then\n- * {@code USERNAME.get()} would read the value \"{@code duke1}\" or \"{@code duke2}\",\n- * depending on which thread is executing.\n- *\n- * <p> In addition to the {@code runWhere} method that executes a {@code run} method, {@code\n- * ScopedValue} defines the {@link #callWhere(ScopedValue, Object, Callable)} and\n- * {@link #getWhere(ScopedValue, Object, Supplier)} methods to execute\n- * methods that returns results. It also defines the {@link #where(ScopedValue, Object)}\n- * method for cases where it is useful to accumulate mappings of multiple {@code ScopedValue}s to\n- * bound values.\n- *\n- * <p> A {@code ScopedValue} will typically be declared in a {@code final} and {@code\n- * static} field. The accessibility of the field will determine which components can\n- * bind or read its value.\n+ * Code executed directly or indirectly by {@code doSomething}, with access to the field\n+ * {@code NAME}, can invoke {@code NAME.get()} to read the value \"{@code duke}\". {@code\n+ * NAME} is bound while executing the {@code run} method. It reverts to being unbound when\n+ * the {@code run} method completes.\n@@ -91,2 +86,34 @@\n- * <p> Unless otherwise specified, passing a {@code null} argument to a method in this\n- * class will cause a {@link NullPointerException} to be thrown.\n+ * <p> The example using {@code runWhere} invokes a method that does not return a result.\n+ * The {@link #callWhere(ScopedValue, Object, Callable) callWhere} and {@link\n+ * #getWhere(ScopedValue, Object, Supplier) getWhere} can be used to invoke a method that\n+ * returns a result.\n+ * In addition, {@code ScopedValue} defines the {@link #where(ScopedValue, Object)} method\n+ * for cases where multiple mappings of ({@code ScopedValue} to value) are accumulated\n+ * in advance of calling a method with all {@code ScopedValue}s bound to their value.\n+ *\n+ * <h2>Bindings are per-thread<\/h2>\n+ *\n+ * A {@code ScopedValue} binding to a value is per-thread. Invoking {@code xxxWhere}\n+ * executes a method with a {@code ScopedValue} bound to a value for the current thread.\n+ * The {@link #get() get} method returns the value bound for the current thread.\n+ *\n+ * <p> In the example, if code executed by one thread invokes this:\n+ * {@snippet lang=java :\n+ *     ScopedValue.runWhere(NAME, \"duke1\", () -> doSomething());\n+ * }\n+ * and code executed by another thread invokes:\n+ * {@snippet lang=java :\n+ *     ScopedValue.runWhere(NAME, \"duke2\", () -> doSomething());\n+ * }\n+ * then code in {@code doSomething} (or any method that it calls) invoking {@code NAME.get()}\n+ * will read the value \"{@code duke1}\" or \"{@code duke2}\", depending on which thread is\n+ * executing.\n+ *\n+ * <h2>Scoped values as capabilities<\/h2>\n+ *\n+ * A {@code ScopedValue} object should be treated as a <em>capability<\/em> or a key to\n+ * access its value when the {@code ScopedValue} is bound. Secure usage depends on access\n+ * control (see <cite>The Java Virtual Machine Specification<\/cite>, Section {@jvms 5.4.4})\n+ * and taking care to not share the {@code ScopedValue} object. In many cases, a {@code\n+ * ScopedValue} will be declared in a {@code final} and {@code static} field so that it\n+ * is only accessible to code in a single class (or nest).\n@@ -98,1 +125,1 @@\n- * is bound to some value may be bound to a new value for the bounded execution of some\n+ * is bound to a value may be bound to a new value for the bounded execution of a new\n@@ -100,2 +127,2 @@\n- * dynamic scope. When the method completes (normally or with an exception), the value of\n- * the {@code ScopedValue} reverts to its previous value.\n+ * dynamic scope. When the method completes, the value of the {@code ScopedValue} reverts\n+ * to its previous value.\n@@ -103,2 +130,2 @@\n- * <p> In the above example, suppose that code executed by {@code doSomething()} binds\n- * {@code USERNAME} to a new value with:\n+ * <p> In the above example, suppose that code executed by {@code doSomething} binds\n+ * {@code NAME} to a new value with:\n@@ -106,1 +133,1 @@\n- *     ScopedValue.runWhere(USERNAME, \"duchess\", () -> doMore());\n+ *     ScopedValue.runWhere(NAME, \"duchess\", () -> doMore());\n@@ -109,3 +136,2 @@\n- * USERNAME.get()} will read the value \"{@code duchess}\". When {@code doMore()} completes\n- * (normally or with an exception), the value of {@code USERNAME} reverts to\n- * \"{@code duke}\".\n+ * NAME.get()} will read the value \"{@code duchess}\". When {@code doMore()} completes\n+ * then the value of {@code NAME} reverts to \"{@code duke}\".\n@@ -115,1 +141,1 @@\n- * {@code ScopedValue} supports sharing data across threads. This sharing is limited to\n+ * {@code ScopedValue} supports sharing across threads. This sharing is limited to\n@@ -117,4 +143,7 @@\n- * period of execution by a parent thread. More specifically, when using a {@link\n- * StructuredTaskScope}, scoped value bindings are <em>captured<\/em> when creating a\n- * {@code StructuredTaskScope} and inherited by all threads started in that scope with\n- * the {@link StructuredTaskScope#fork(Callable) fork} method.\n+ * period of execution by a parent thread. When using a {@link StructuredTaskScope},\n+ * scoped value bindings are <em>captured<\/em> when creating a {@code StructuredTaskScope}\n+ * and inherited by all threads started in that task scope with the\n+ * {@link StructuredTaskScope#fork(Callable) fork} method.\n+ *\n+ * <p> A {@code ScopedValue} that is shared across threads requires that the value be an\n+ * immutable object or for all access to the value to be appropriately synchronized.\n@@ -122,1 +151,1 @@\n- * <p> In the following example, the {@code ScopedValue} {@code USERNAME} is bound to the\n+ * <p> In the following example, the {@code ScopedValue} {@code NAME} is bound to the\n@@ -124,3 +153,4 @@\n- * run} method creates a {@code StructuredTaskScope} and forks three child threads. Code\n- * executed directly or indirectly by these threads running {@code childTask1()},\n- * {@code childTask2()}, and {@code childTask3()} will read the value \"{@code duke}\".\n+ * run} method creates a {@code StructuredTaskScope} that forks three tasks. Code executed\n+ * directly or indirectly by these threads running {@code childTask1()}, {@code childTask2()},\n+ * and {@code childTask3()} that invokes {@code NAME.get()} will read the value\n+ * \"{@code duke}\".\n@@ -129,1 +159,1 @@\n- *     private static final ScopedValue<String> USERNAME = ScopedValue.newInstance();\n+ *     private static final ScopedValue<String> NAME = ScopedValue.newInstance();\n@@ -131,1 +161,1 @@\n- *     ScopedValue.runWhere(USERNAME, \"duke\", () -> {\n+ *     ScopedValue.runWhere(NAME, \"duke\", () -> {\n@@ -143,0 +173,17 @@\n+ * <p> Unless otherwise specified, passing a {@code null} argument to a method in this\n+ * class will cause a {@link NullPointerException} to be thrown.\n+ *\n+ * @apiNote\n+ * A {@code ScopedValue} should be preferred over a {@link ThreadLocal} for cases where\n+ * the goal is \"one-way transmission\" of data without using method parameters.  While a\n+ * {@code ThreadLocal} can be used to pass data to a method without using method parameters,\n+ * it does suffer from a number of issues:\n+ * <ol>\n+ *   <li> {@code ThreadLocal} does not prevent code in a faraway callee from {@linkplain\n+ *   ThreadLocal#set(Object) setting} a new value.\n+ *   <li> A {@code ThreadLocal} has an unbounded lifetime and thus continues to have a value\n+ *   after a method completes, unless explicitly {@linkplain ThreadLocal#remove() removed}.\n+ *   <li> {@linkplain InheritableThreadLocal Inheritance} is expensive - the map of\n+ *   thread-locals to values must be copied when creating each child thread.\n+ * <\/ol>\n+ *\n@@ -189,1 +236,1 @@\n- * @param <T> the type of the object bound to this {@code ScopedValue}\n+ * @param <T> the type of the value\n@@ -407,1 +454,1 @@\n-            private Supplier<? extends V> s;\n+            private \/*non-final*\/ Supplier<? extends V> s;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ScopedValue.java","additions":112,"deletions":65,"binary":false,"changes":177,"status":"modified"},{"patch":"@@ -318,3 +318,3 @@\n-    private int forkPhase;         \/\/ incremented when the first subtask is forked after join\n-    private int lastJoinInvoked;   \/\/ set to the current fork phase when join is invoked\n-    private int lastJoinCompleted; \/\/ set to the current fork phase when join completes\n+    private int forkRound;         \/\/ incremented when the first subtask is forked after join\n+    private int lastJoinAttempted; \/\/ set to the current fork round when join is attempted\n+    private int lastJoinCompleted; \/\/ set to the current fork round when join completes\n@@ -372,0 +372,5 @@\n+         *\n+         * <p> To ensure correct usage, if the scope owner {@linkplain #fork(Callable) forks}\n+         * a subtask, then it must join (with {@link #join() join} or {@link #joinUntil(Instant)\n+         * joinUntil}) before it can obtain the result of the subtask.\n+         *\n@@ -382,0 +387,5 @@\n+         *\n+         * <p> To ensure correct usage, if the scope owner {@linkplain #fork(Callable) forks}\n+         * a subtask, then it must join (with {@link #join() join} or {@link #joinUntil(Instant)\n+         * joinUntil}) before it can obtain the exception thrown by the subtask.\n+         *\n@@ -463,1 +473,1 @@\n-     * not join after forking a subtask in the given fork phase.\n+     * not join after forking a subtask in the given fork round.\n@@ -465,2 +475,2 @@\n-    private void ensureJoinedIfOwner(int phase) {\n-        if (Thread.currentThread() == flock.owner() && (phase > lastJoinCompleted)) {\n+    private void ensureJoinedIfOwner(int round) {\n+        if (Thread.currentThread() == flock.owner() && (round > lastJoinCompleted)) {\n@@ -473,1 +483,1 @@\n-     * (with {@link #join()} or {@link #joinUntil(Instant)} after {@linkplain #fork(Callable)\n+     * (with {@link #join()} or {@link #joinUntil(Instant)}) after {@linkplain #fork(Callable)\n@@ -485,1 +495,1 @@\n-        if (forkPhase > lastJoinCompleted) {\n+        if (forkRound > lastJoinCompleted) {\n@@ -521,1 +531,1 @@\n-     * <p> This method returns a {@link Subtask Subtask}to represent the <em>forked\n+     * <p> This method returns a {@link Subtask Subtask} to represent the <em>forked\n@@ -558,2 +568,2 @@\n-        \/\/ when forked by the owner, the subtask is forked in the current or next phase\n-        int phase = -1;\n+        \/\/ when forked by the owner, the subtask is forked in the current or next round\n+        int round = -1;\n@@ -561,4 +571,4 @@\n-            phase = forkPhase;\n-            if (forkPhase == lastJoinCompleted) {\n-                \/\/ new phase if first fork after join\n-                phase++;\n+            round = forkRound;\n+            if (forkRound == lastJoinCompleted) {\n+                \/\/ new round if first fork after join\n+                round++;\n@@ -568,1 +578,1 @@\n-        SubtaskImpl<U> subtask = new SubtaskImpl<>(this, task, phase);\n+        SubtaskImpl<U> subtask = new SubtaskImpl<>(this, task, round);\n@@ -589,2 +599,2 @@\n-        if (started && Thread.currentThread() == flock.owner() && phase > forkPhase) {\n-            forkPhase = phase;\n+        if (started && Thread.currentThread() == flock.owner() && round > forkRound) {\n+            forkRound = round;\n@@ -604,1 +614,1 @@\n-        lastJoinInvoked = forkPhase;\n+        lastJoinAttempted = forkRound;\n@@ -614,1 +624,1 @@\n-        lastJoinCompleted = forkPhase;\n+        lastJoinCompleted = forkRound;\n@@ -772,1 +782,1 @@\n-    public boolean isShutdown() {\n+    public final boolean isShutdown() {\n@@ -826,2 +836,2 @@\n-        if (forkPhase > lastJoinInvoked) {\n-            lastJoinCompleted = forkPhase;\n+        if (forkRound > lastJoinAttempted) {\n+            lastJoinCompleted = forkRound;\n@@ -857,1 +867,1 @@\n-        private final int phase;\n+        private final int round;\n@@ -862,1 +872,1 @@\n-                    int phase) {\n+                    int round) {\n@@ -865,1 +875,1 @@\n-            this.phase = phase;\n+            this.round = round;\n@@ -911,1 +921,1 @@\n-            scope.ensureJoinedIfOwner(phase);\n+            scope.ensureJoinedIfOwner(round);\n@@ -925,1 +935,1 @@\n-            scope.ensureJoinedIfOwner(phase);\n+            scope.ensureJoinedIfOwner(round);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/StructuredTaskScope.java","additions":38,"deletions":28,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/SharedThreadContainer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import sun.nio.ch.Poller;\n@@ -290,1 +291,5 @@\n-                return platformThreads();\n+                \/\/ virtual threads in this container that are those blocked on I\/O.\n+                Stream<Thread> blockedVirtualThreads = Poller.blockedThreads()\n+                        .filter(t -> t.isVirtual()\n+                                && JLA.threadContainer(t) == this);\n+                return Stream.concat(platformThreads(), blockedVirtualThreads);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/ThreadContainers.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -213,1 +213,1 @@\n-            \/\/ fork phase 1\n+            \/\/ round 1\n@@ -219,1 +219,1 @@\n-            \/\/ fork phase 2\n+            \/\/ round 2\n@@ -227,1 +227,1 @@\n-            \/\/ fork phase 3\n+            \/\/ round 3\n","filename":"test\/jdk\/java\/util\/concurrent\/StructuredTaskScope\/StructuredTaskScopeTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}