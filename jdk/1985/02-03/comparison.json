{"files":[{"patch":"@@ -28,0 +28,3 @@\n+#include \"runtime\/flags\/jvmFlag.hpp\"\n+#include \"runtime\/flags\/jvmFlagAccess.hpp\"\n+#include \"runtime\/flags\/jvmFlagLimit.hpp\"\n@@ -211,0 +214,16 @@\n+static bool check_legacy_flags() {\n+  JVMFlag* compile_threshold_flag = JVMFlag::flag_from_enum(FLAG_MEMBER_ENUM(CompileThreshold));\n+  if (JVMFlagAccess::check_constraint(compile_threshold_flag, JVMFlagLimit::get_constraint(compile_threshold_flag)->constraint_func(), false) != JVMFlag::SUCCESS) {\n+    return false;\n+  }\n+  JVMFlag* on_stack_replace_percentage_flag = JVMFlag::flag_from_enum(FLAG_MEMBER_ENUM(OnStackReplacePercentage));\n+  if (JVMFlagAccess::check_constraint(on_stack_replace_percentage_flag, JVMFlagLimit::get_constraint(on_stack_replace_percentage_flag)->constraint_func(), false) != JVMFlag::SUCCESS) {\n+    return false;\n+  }\n+  JVMFlag* interpreter_profile_percentage_flag = JVMFlag::flag_from_enum(FLAG_MEMBER_ENUM(InterpreterProfilePercentage));\n+  if (JVMFlagAccess::check_range(interpreter_profile_percentage_flag, false) != JVMFlag::SUCCESS) {\n+    return false;\n+  }\n+  return true;\n+}\n+\n@@ -216,8 +235,0 @@\n-\n-    \/\/ Note, we do not scale CompileThreshold before this because the tiered flags are\n-    \/\/ all going to be scaled further in set_compilation_policy_flags().\n-    const int threshold = CompileThreshold;\n-    const int profile_threshold = threshold * InterpreterProfilePercentage \/ 100;\n-    const int osr_threshold = threshold * OnStackReplacePercentage \/ 100;\n-    const int osr_profile_threshold = osr_threshold * InterpreterProfilePercentage \/ 100;\n-\n@@ -225,2 +236,14 @@\n-      const int threshold_log = log2i_graceful(CompilerConfig::is_c1_only() ? threshold : profile_threshold);\n-      const int osr_threshold_log = log2i_graceful(CompilerConfig::is_c1_only() ? osr_threshold : osr_profile_threshold);\n+      \/\/ This function is called before these flags are validated. In order to not confuse the user with extraneous\n+      \/\/ error messages, we check the validity of these flags here and bail out if any of them are invalid.\n+      if (!check_legacy_flags()) {\n+        return;\n+      }\n+      \/\/ Note, we do not scale CompileThreshold before this because the tiered flags are\n+      \/\/ all going to be scaled further in set_compilation_policy_flags().\n+      const intx threshold = CompileThreshold;\n+      const intx profile_threshold = threshold * InterpreterProfilePercentage \/ 100;\n+      const intx osr_threshold = threshold * OnStackReplacePercentage \/ 100;\n+      const intx osr_profile_threshold = osr_threshold * InterpreterProfilePercentage \/ 100;\n+\n+      const intx threshold_log = log2i_graceful(CompilerConfig::is_c1_only() ? threshold : profile_threshold);\n+      const intx osr_threshold_log = log2i_graceful(CompilerConfig::is_c1_only() ? osr_threshold : osr_profile_threshold);\n@@ -229,1 +252,1 @@\n-        FLAG_SET_ERGO(Tier0InvokeNotifyFreqLog, MAX2(0, threshold_log));\n+        FLAG_SET_ERGO(Tier0InvokeNotifyFreqLog, MAX2<intx>(0, threshold_log));\n@@ -237,1 +260,1 @@\n-        FLAG_SET_ERGO(Tier0BackedgeNotifyFreqLog, MAX2(10, osr_threshold_log));\n+        FLAG_SET_ERGO(Tier0BackedgeNotifyFreqLog, MAX2<intx>(10, osr_threshold_log));\n","filename":"src\/hotspot\/share\/compiler\/compilerDefinitions.cpp","additions":35,"deletions":12,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -135,0 +135,6 @@\n+  \/\/ We depend on CompileThreshold being valid, verify it first.\n+  if (CompileThresholdConstraintFunc(CompileThreshold, false) == JVMFlag::VIOLATES_CONSTRAINT) {\n+    JVMFlag::printError(verbose, \"OnStackReplacePercentage cannot be validated because CompileThreshold value is invalid\\n\");\n+    return JVMFlag::VIOLATES_CONSTRAINT;\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagConstraintsCompiler.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"}]}