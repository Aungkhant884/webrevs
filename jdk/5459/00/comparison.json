{"files":[{"patch":"@@ -0,0 +1,213 @@\n+package org.openjdk.bench.jdk.incubator.vector;\n+\n+\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.FloatVector;\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.LongVector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorSpecies;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.infra.BenchmarkParams;\n+\n+import java.util.Arrays;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+@Fork(jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class ArrayMismatchBenchmark {\n+\n+    @Param({\"9\", \"257\", \"100000\"})\n+    int size;\n+\n+    @Param({\"0.5\", \"1.0\"})\n+    double prefix;\n+\n+    byte[] byteData1;\n+    byte[] byteData2;\n+\n+    int[] intData1;\n+    int[] intData2;\n+\n+    long[] longData1;\n+    long[] longData2;\n+\n+    float[] floatData1;\n+    float[] floatData2;\n+\n+    static final VectorSpecies<Byte> BYTE_SPECIES_PREFERRED = ByteVector.SPECIES_PREFERRED;\n+    static final VectorSpecies<Integer> INT_SPECIES_PREFERRED = IntVector.SPECIES_PREFERRED;\n+    static final VectorSpecies<Float> FLOAT_SPECIES_PREFERRED = FloatVector.SPECIES_PREFERRED;\n+    static final VectorSpecies<Long> LONG_SPECIES_PREFERRED = LongVector.SPECIES_PREFERRED;\n+\n+    static final Random random = new Random();\n+\n+    private float[] createRandomFloats(int size) {\n+        float[] array = new float[size];\n+        for (int i = 0; i < size; i++)\n+            array[i] = random.nextFloat();\n+        return array;\n+    }\n+\n+    @Setup\n+    public void setup(BenchmarkParams params) {\n+        int common = (int) (prefix * size);\n+\n+        if (params.getBenchmark().endsWith(\"Byte\")) {\n+            byteData1 = new byte[size];\n+            byteData2 = new byte[size];\n+            random.nextBytes(byteData1);\n+            random.nextBytes(byteData2);\n+\n+            byte[] commonBytes = new byte[common];\n+            random.nextBytes(commonBytes);\n+\n+            System.arraycopy(commonBytes, 0, byteData1, 0, common);\n+            System.arraycopy(commonBytes, 0, byteData2, 0, common);\n+        } else if (params.getBenchmark().endsWith(\"Int\")) {\n+            intData1 = random.ints(size).toArray();\n+            intData2 = random.ints(size).toArray();\n+\n+            int[] commonInts = random.ints(common).toArray();\n+            System.arraycopy(commonInts, 0, intData1, 0, common);\n+            System.arraycopy(commonInts, 0, intData2, 0, common);\n+        } else if (params.getBenchmark().endsWith(\"Float\")) {\n+            floatData1 = createRandomFloats(size);\n+            floatData2 = createRandomFloats(size);\n+\n+            float[] commonFloats = createRandomFloats(common);\n+            System.arraycopy(commonFloats, 0, floatData1, 0, common);\n+            System.arraycopy(commonFloats, 0, floatData2, 0, common);\n+        } else if (params.getBenchmark().endsWith(\"Long\")) {\n+            longData1 = random.longs(size).toArray();\n+            longData2 = random.longs(size).toArray();\n+\n+            long[] commonLongs = random.longs(common).toArray();\n+            System.arraycopy(commonLongs, 0, longData1, 0, common);\n+            System.arraycopy(commonLongs, 0, longData2, 0, common);\n+        }\n+    }\n+\n+    @Benchmark\n+    public int mismatchIntrinsicByte() {\n+        return Arrays.mismatch(byteData1, byteData2);\n+    }\n+\n+    @Benchmark\n+    public int mismatchVectorByte() {\n+        int length = Math.min(byteData1.length, byteData2.length);\n+        int index = 0;\n+        for (; index < BYTE_SPECIES_PREFERRED.loopBound(length); index += BYTE_SPECIES_PREFERRED.length()) {\n+            ByteVector vector1 = ByteVector.fromArray(BYTE_SPECIES_PREFERRED, byteData1, index);\n+            ByteVector vector2 = ByteVector.fromArray(BYTE_SPECIES_PREFERRED, byteData2, index);\n+            VectorMask<Byte> mask = vector1.compare(VectorOperators.NE, vector2);\n+            if (mask.anyTrue()) {\n+                return index + mask.firstTrue();\n+            }\n+        }\n+        \/\/ process the tail\n+        int mismatch = -1;\n+        for (int i = index; i < length; ++i) {\n+            if (byteData1[i] != byteData2[i]) {\n+                mismatch = i;\n+                break;\n+            }\n+        }\n+        return mismatch;\n+    }\n+\n+    @Benchmark\n+    public int mismatchIntrinsicInt() {\n+        return Arrays.mismatch(intData1, intData2);\n+    }\n+\n+    @Benchmark\n+    public int mismatchVectorInt() {\n+        int length = Math.min(intData1.length, intData2.length);\n+        int index = 0;\n+        for (; index < INT_SPECIES_PREFERRED.loopBound(length); index += INT_SPECIES_PREFERRED.length()) {\n+            IntVector vector1 = IntVector.fromArray(INT_SPECIES_PREFERRED, intData1, index);\n+            IntVector vector2 = IntVector.fromArray(INT_SPECIES_PREFERRED, intData2, index);\n+            VectorMask<Integer> mask = vector1.compare(VectorOperators.NE, vector2);\n+            if (mask.anyTrue()) {\n+                return index + mask.firstTrue();\n+            }\n+        }\n+        \/\/ process the tail\n+        int mismatch = -1;\n+        for (int i = index; i < length; ++i) {\n+            if (intData1[i] != intData2[i]) {\n+                mismatch = i;\n+                break;\n+            }\n+        }\n+        return mismatch;\n+    }\n+\n+    @Benchmark\n+    public int mismatchIntrinsicFloat() {\n+        return Arrays.mismatch(floatData1, floatData2);\n+    }\n+\n+    @Benchmark\n+    public int mismatchVectorFloat() {\n+        int length = Math.min(floatData1.length, floatData2.length);\n+        int index = 0;\n+        for (; index < FLOAT_SPECIES_PREFERRED.loopBound(length); index += FLOAT_SPECIES_PREFERRED.length()) {\n+            FloatVector vector1 = FloatVector.fromArray(FLOAT_SPECIES_PREFERRED, floatData1, index);\n+            FloatVector vector2 = FloatVector.fromArray(FLOAT_SPECIES_PREFERRED, floatData2, index);\n+            VectorMask<Float> mask = vector1.compare(VectorOperators.NE, vector2);\n+            if (mask.anyTrue()) {\n+                return index + mask.firstTrue();\n+            }\n+        }\n+        \/\/ process the tail\n+        int mismatch = -1;\n+        for (int i = index; i < length; ++i) {\n+            if (floatData1[i] != floatData2[i]) {\n+                mismatch = i;\n+                break;\n+            }\n+        }\n+        return mismatch;\n+    }\n+\n+    @Benchmark\n+    public int mismatchIntrinsicLong() {\n+        return Arrays.mismatch(longData1, longData2);\n+    }\n+\n+    @Benchmark\n+    public int mismatchVectorLong() {\n+        int length = Math.min(longData1.length, longData2.length);\n+        int index = 0;\n+        for (; index < LONG_SPECIES_PREFERRED.loopBound(length); index += LONG_SPECIES_PREFERRED.length()) {\n+            LongVector vector1 = LongVector.fromArray(LONG_SPECIES_PREFERRED, longData1, index);\n+            LongVector vector2 = LongVector.fromArray(LONG_SPECIES_PREFERRED, longData2, index);\n+            VectorMask<Long> mask = vector1.compare(VectorOperators.NE, vector2);\n+            if (mask.anyTrue()) {\n+                return index + mask.firstTrue();\n+            }\n+        }\n+        \/\/ process the tail\n+        int mismatch = -1;\n+        for (int i = index; i < length; ++i) {\n+            if (longData1[i] != longData2[i]) {\n+                mismatch = i;\n+                break;\n+            }\n+        }\n+        return mismatch;\n+    }\n+\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/ArrayMismatchBenchmark.java","additions":213,"deletions":0,"binary":false,"changes":213,"status":"added"}]}