{"files":[{"patch":"@@ -0,0 +1,229 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.vector;\n+\n+\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.DoubleVector;\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.LongVector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorSpecies;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.infra.BenchmarkParams;\n+\n+import java.util.Arrays;\n+import java.util.concurrent.TimeUnit;\n+import java.util.random.RandomGenerator;\n+\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+@Fork(jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class ArrayMismatchBenchmark {\n+\n+    @Param({\"9\", \"257\", \"100000\"})\n+    int size;\n+\n+    @Param({\"0.5\", \"1.0\"})\n+    double prefix;\n+\n+    byte[] byteData1;\n+    byte[] byteData2;\n+\n+    int[] intData1;\n+    int[] intData2;\n+\n+    long[] longData1;\n+    long[] longData2;\n+\n+    double[] doubleData1;\n+    double[] doubleData2;\n+\n+    static final VectorSpecies<Byte> BYTE_SPECIES_PREFERRED = ByteVector.SPECIES_PREFERRED;\n+    static final VectorSpecies<Integer> INT_SPECIES_PREFERRED = IntVector.SPECIES_PREFERRED;\n+    static final VectorSpecies<Double> FLOAT_SPECIES_PREFERRED = DoubleVector.SPECIES_PREFERRED;\n+    static final VectorSpecies<Long> LONG_SPECIES_PREFERRED = LongVector.SPECIES_PREFERRED;\n+\n+    @Setup\n+    public void setup(BenchmarkParams params) {\n+        RandomGenerator random = RandomGenerator.getDefault();\n+        int common = (int) (prefix * size);\n+\n+        if (params.getBenchmark().endsWith(\"Byte\")) {\n+            byteData1 = new byte[size];\n+            byteData2 = new byte[size];\n+            random.nextBytes(byteData1);\n+            random.nextBytes(byteData2);\n+\n+            byte[] commonBytes = new byte[common];\n+            random.nextBytes(commonBytes);\n+\n+            System.arraycopy(commonBytes, 0, byteData1, 0, common);\n+            System.arraycopy(commonBytes, 0, byteData2, 0, common);\n+        } else if (params.getBenchmark().endsWith(\"Int\")) {\n+            intData1 = random.ints(size).toArray();\n+            intData2 = random.ints(size).toArray();\n+\n+            int[] commonInts = random.ints(common).toArray();\n+            System.arraycopy(commonInts, 0, intData1, 0, common);\n+            System.arraycopy(commonInts, 0, intData2, 0, common);\n+        } else if (params.getBenchmark().endsWith(\"Double\")) {\n+            doubleData1 = random.doubles(size).toArray();\n+            doubleData2 = random.doubles(size).toArray();\n+\n+            double[] commonDoubles = random.doubles(size).toArray();\n+            System.arraycopy(commonDoubles, 0, doubleData1, 0, common);\n+            System.arraycopy(commonDoubles, 0, doubleData2, 0, common);\n+        } else if (params.getBenchmark().endsWith(\"Long\")) {\n+            longData1 = random.longs(size).toArray();\n+            longData2 = random.longs(size).toArray();\n+\n+            long[] commonLongs = random.longs(common).toArray();\n+            System.arraycopy(commonLongs, 0, longData1, 0, common);\n+            System.arraycopy(commonLongs, 0, longData2, 0, common);\n+        }\n+    }\n+\n+    @Benchmark\n+    public int mismatchIntrinsicByte() {\n+        return Arrays.mismatch(byteData1, byteData2);\n+    }\n+\n+    @Benchmark\n+    public int mismatchVectorByte() {\n+        int length = Math.min(byteData1.length, byteData2.length);\n+        int index = 0;\n+        for (; index < BYTE_SPECIES_PREFERRED.loopBound(length); index += BYTE_SPECIES_PREFERRED.length()) {\n+            ByteVector vector1 = ByteVector.fromArray(BYTE_SPECIES_PREFERRED, byteData1, index);\n+            ByteVector vector2 = ByteVector.fromArray(BYTE_SPECIES_PREFERRED, byteData2, index);\n+            VectorMask<Byte> mask = vector1.compare(VectorOperators.NE, vector2);\n+            if (mask.anyTrue()) {\n+                return index + mask.firstTrue();\n+            }\n+        }\n+        \/\/ process the tail\n+        int mismatch = -1;\n+        for (int i = index; i < length; ++i) {\n+            if (byteData1[i] != byteData2[i]) {\n+                mismatch = i;\n+                break;\n+            }\n+        }\n+        return mismatch;\n+    }\n+\n+    @Benchmark\n+    public int mismatchIntrinsicInt() {\n+        return Arrays.mismatch(intData1, intData2);\n+    }\n+\n+    @Benchmark\n+    public int mismatchVectorInt() {\n+        int length = Math.min(intData1.length, intData2.length);\n+        int index = 0;\n+        for (; index < INT_SPECIES_PREFERRED.loopBound(length); index += INT_SPECIES_PREFERRED.length()) {\n+            IntVector vector1 = IntVector.fromArray(INT_SPECIES_PREFERRED, intData1, index);\n+            IntVector vector2 = IntVector.fromArray(INT_SPECIES_PREFERRED, intData2, index);\n+            VectorMask<Integer> mask = vector1.compare(VectorOperators.NE, vector2);\n+            if (mask.anyTrue()) {\n+                return index + mask.firstTrue();\n+            }\n+        }\n+        \/\/ process the tail\n+        int mismatch = -1;\n+        for (int i = index; i < length; ++i) {\n+            if (intData1[i] != intData2[i]) {\n+                mismatch = i;\n+                break;\n+            }\n+        }\n+        return mismatch;\n+    }\n+\n+    @Benchmark\n+    public int mismatchIntrinsicDouble() {\n+        return Arrays.mismatch(doubleData1, doubleData2);\n+    }\n+\n+    @Benchmark\n+    public int mismatchVectorDouble() {\n+        int length = Math.min(doubleData1.length, doubleData2.length);\n+        int index = 0;\n+        for (; index < FLOAT_SPECIES_PREFERRED.loopBound(length); index += FLOAT_SPECIES_PREFERRED.length()) {\n+            DoubleVector vector1 = DoubleVector.fromArray(FLOAT_SPECIES_PREFERRED, doubleData1, index);\n+            DoubleVector vector2 = DoubleVector.fromArray(FLOAT_SPECIES_PREFERRED, doubleData2, index);\n+            VectorMask<Double> mask = vector1.compare(VectorOperators.NE, vector2);\n+            if (mask.anyTrue()) {\n+                return index + mask.firstTrue();\n+            }\n+        }\n+        \/\/ process the tail\n+        int mismatch = -1;\n+        for (int i = index; i < length; ++i) {\n+            if (doubleData1[i] != doubleData2[i]) {\n+                mismatch = i;\n+                break;\n+            }\n+        }\n+        return mismatch;\n+    }\n+\n+    @Benchmark\n+    public int mismatchIntrinsicLong() {\n+        return Arrays.mismatch(longData1, longData2);\n+    }\n+\n+    @Benchmark\n+    public int mismatchVectorLong() {\n+        int length = Math.min(longData1.length, longData2.length);\n+        int index = 0;\n+        for (; index < LONG_SPECIES_PREFERRED.loopBound(length); index += LONG_SPECIES_PREFERRED.length()) {\n+            LongVector vector1 = LongVector.fromArray(LONG_SPECIES_PREFERRED, longData1, index);\n+            LongVector vector2 = LongVector.fromArray(LONG_SPECIES_PREFERRED, longData2, index);\n+            VectorMask<Long> mask = vector1.compare(VectorOperators.NE, vector2);\n+            if (mask.anyTrue()) {\n+                return index + mask.firstTrue();\n+            }\n+        }\n+        \/\/ process the tail\n+        int mismatch = -1;\n+        for (int i = index; i < length; ++i) {\n+            if (longData1[i] != longData2[i]) {\n+                mismatch = i;\n+                break;\n+            }\n+        }\n+        return mismatch;\n+    }\n+\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/ArrayMismatchBenchmark.java","additions":229,"deletions":0,"binary":false,"changes":229,"status":"added"}]}