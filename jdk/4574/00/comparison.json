{"files":[{"patch":"@@ -1,530 +0,0 @@\n-\/*\n- * Copyright (c) 1996, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package java.net;\n-\n-import java.io.FileDescriptor;\n-import java.io.IOException;\n-import java.util.Collections;\n-import java.util.HashSet;\n-import java.util.Objects;\n-import java.util.Set;\n-\n-import sun.net.ResourceManager;\n-import sun.net.ext.ExtendedSocketOptions;\n-import sun.net.util.IPAddressUtil;\n-import sun.security.action.GetPropertyAction;\n-\n-\/**\n- * Abstract datagram and multicast socket implementation base class.\n- * Note: This is not a public class, so that applets cannot call\n- * into the implementation directly and hence cannot bypass the\n- * security checks present in the DatagramSocket and MulticastSocket\n- * classes.\n- *\n- * @author Pavani Diwanji\n- *\/\n-\n-abstract class AbstractPlainDatagramSocketImpl extends DatagramSocketImpl\n-{\n-    \/* timeout value for receive() *\/\n-    int timeout = 0;\n-    boolean connected = false;\n-    private int trafficClass = 0;\n-    protected InetAddress connectedAddress = null;\n-    private int connectedPort = -1;\n-    private final boolean isMulticast;\n-\n-    private static final String os =\n-            GetPropertyAction.privilegedGetProperty(\"os.name\");\n-\n-    \/**\n-     * flag set if the native connect() call not to be used\n-     *\/\n-    private static final boolean connectDisabled = os.contains(\"OS X\");\n-\n-    \/**\n-     * Load net library into runtime.\n-     *\/\n-    static {\n-        jdk.internal.loader.BootLoader.loadLibrary(\"net\");\n-    }\n-\n-    private static volatile boolean checkedReusePort;\n-    private static volatile boolean isReusePortAvailable;\n-\n-    \/**\n-     * Tells whether SO_REUSEPORT is supported.\n-     *\/\n-    static boolean isReusePortAvailable() {\n-        if (!checkedReusePort) {\n-            isReusePortAvailable = isReusePortAvailable0();\n-            checkedReusePort = true;\n-        }\n-        return isReusePortAvailable;\n-    }\n-\n-    AbstractPlainDatagramSocketImpl(boolean isMulticast) {\n-        this.isMulticast = isMulticast;\n-    }\n-\n-    \/**\n-     * Creates a datagram socket\n-     *\/\n-    protected synchronized void create() throws SocketException {\n-        ResourceManager.beforeUdpCreate();\n-        fd = new FileDescriptor();\n-        try {\n-            datagramSocketCreate();\n-            SocketCleanable.register(fd, false);\n-        } catch (SocketException ioe) {\n-            ResourceManager.afterUdpClose();\n-            fd = null;\n-            throw ioe;\n-        }\n-    }\n-\n-    \/**\n-     * Binds a datagram socket to a local port.\n-     *\/\n-    protected synchronized void bind(int lport, InetAddress laddr)\n-        throws SocketException {\n-        if (laddr.isLinkLocalAddress()) {\n-            laddr = IPAddressUtil.toScopedAddress(laddr);\n-        }\n-        bind0(lport, laddr);\n-    }\n-\n-    protected abstract void bind0(int lport, InetAddress laddr)\n-        throws SocketException;\n-\n-    \/**\n-     * Sends a datagram packet. The packet contains the data and the\n-     * destination address to send the packet to.\n-     * @param p the packet to be sent.\n-     *\/\n-    protected void send(DatagramPacket p) throws IOException {\n-        InetAddress orig = p.getAddress();\n-        if (orig.isLinkLocalAddress()) {\n-            InetAddress scoped = IPAddressUtil.toScopedAddress(orig);\n-            if (orig != scoped) {\n-                p = new DatagramPacket(p.getData(), p.getOffset(),\n-                                       p.getLength(), scoped, p.getPort());\n-            }\n-        }\n-        send0(p);\n-    }\n-\n-    protected abstract void send0(DatagramPacket p) throws IOException;\n-\n-    \/**\n-     * Connects a datagram socket to a remote destination. This associates the remote\n-     * address with the local socket so that datagrams may only be sent to this destination\n-     * and received from this destination.\n-     * @param address the remote InetAddress to connect to\n-     * @param port the remote port number\n-     *\/\n-    protected void connect(InetAddress address, int port) throws SocketException {\n-        if (address.isLinkLocalAddress()) {\n-            address = IPAddressUtil.toScopedAddress(address);\n-        }\n-        connect0(address, port);\n-        connectedAddress = address;\n-        connectedPort = port;\n-        connected = true;\n-    }\n-\n-    \/**\n-     * Disconnects a previously connected socket. Does nothing if the socket was\n-     * not connected already.\n-     *\/\n-    protected void disconnect() {\n-        disconnect0(connectedAddress.holder().getFamily());\n-        connected = false;\n-        connectedAddress = null;\n-        connectedPort = -1;\n-    }\n-\n-    \/**\n-     * Peek at the packet to see who it is from.\n-     * @param i the address to populate with the sender address\n-     *\/\n-    protected abstract int peek(InetAddress i) throws IOException;\n-    protected abstract int peekData(DatagramPacket p) throws IOException;\n-    \/**\n-     * Receive the datagram packet.\n-     * @param p the packet to receive into\n-     *\/\n-    protected synchronized void receive(DatagramPacket p)\n-        throws IOException {\n-        receive0(p);\n-    }\n-\n-    protected abstract void receive0(DatagramPacket p)\n-        throws IOException;\n-\n-    \/**\n-     * Set the TTL (time-to-live) option.\n-     * @param ttl TTL to be set.\n-     *\/\n-    protected abstract void setTimeToLive(int ttl) throws IOException;\n-\n-    \/**\n-     * Get the TTL (time-to-live) option.\n-     *\/\n-    protected abstract int getTimeToLive() throws IOException;\n-\n-    \/**\n-     * Set the TTL (time-to-live) option.\n-     * @param ttl TTL to be set.\n-     *\/\n-    @Deprecated\n-    protected abstract void setTTL(byte ttl) throws IOException;\n-\n-    \/**\n-     * Get the TTL (time-to-live) option.\n-     *\/\n-    @Deprecated\n-    protected abstract byte getTTL() throws IOException;\n-\n-    \/**\n-     * Join the multicast group.\n-     * @param inetaddr multicast address to join.\n-     *\/\n-    protected void join(InetAddress inetaddr) throws IOException {\n-        join(inetaddr, null);\n-    }\n-\n-    \/**\n-     * Leave the multicast group.\n-     * @param inetaddr multicast address to leave.\n-     *\/\n-    protected void leave(InetAddress inetaddr) throws IOException {\n-        leave(inetaddr, null);\n-    }\n-    \/**\n-     * Join the multicast group.\n-     * @param mcastaddr multicast address to join.\n-     * @param netIf specifies the local interface to receive multicast\n-     *        datagram packets\n-     * @throws  IllegalArgumentException if mcastaddr is null or is a\n-     *          SocketAddress subclass not supported by this socket\n-     * @since 1.4\n-     *\/\n-\n-    protected void joinGroup(SocketAddress mcastaddr, NetworkInterface netIf)\n-        throws IOException {\n-        if (!(mcastaddr instanceof InetSocketAddress addr))\n-            throw new IllegalArgumentException(\"Unsupported address type\");\n-        join(addr.getAddress(), netIf);\n-    }\n-\n-    protected abstract void join(InetAddress inetaddr, NetworkInterface netIf)\n-        throws IOException;\n-\n-    \/**\n-     * Leave the multicast group.\n-     * @param mcastaddr  multicast address to leave.\n-     * @param netIf specified the local interface to leave the group at\n-     * @throws  IllegalArgumentException if mcastaddr is null or is a\n-     *          SocketAddress subclass not supported by this socket\n-     * @since 1.4\n-     *\/\n-    protected void leaveGroup(SocketAddress mcastaddr, NetworkInterface netIf)\n-        throws IOException {\n-        if (!(mcastaddr instanceof InetSocketAddress addr))\n-            throw new IllegalArgumentException(\"Unsupported address type\");\n-        leave(addr.getAddress(), netIf);\n-    }\n-\n-    protected abstract void leave(InetAddress inetaddr, NetworkInterface netIf)\n-        throws IOException;\n-\n-    \/**\n-     * Close the socket.\n-     *\/\n-    protected void close() {\n-        if (fd != null) {\n-            SocketCleanable.unregister(fd);\n-            datagramSocketClose();\n-            ResourceManager.afterUdpClose();\n-            fd = null;\n-        }\n-    }\n-\n-    protected boolean isClosed() {\n-        return (fd == null) ? true : false;\n-    }\n-\n-    \/**\n-     * set a value - since we only support (setting) binary options\n-     * here, o must be a Boolean\n-     *\/\n-\n-     public void setOption(int optID, Object o) throws SocketException {\n-         if (isClosed()) {\n-             throw new SocketException(\"Socket Closed\");\n-         }\n-         switch (optID) {\n-            \/* check type safety b4 going native.  These should never\n-             * fail, since only java.Socket* has access to\n-             * PlainSocketImpl.setOption().\n-             *\/\n-         case SO_TIMEOUT:\n-             if (!(o instanceof Integer)) {\n-                 throw new SocketException(\"bad argument for SO_TIMEOUT\");\n-             }\n-             int tmp = ((Integer) o).intValue();\n-             if (tmp < 0)\n-                 throw new IllegalArgumentException(\"timeout < 0\");\n-             timeout = tmp;\n-             return;\n-         case IP_TOS:\n-             if (!(o instanceof Integer)) {\n-                 throw new SocketException(\"bad argument for IP_TOS\");\n-             }\n-             trafficClass = ((Integer)o).intValue();\n-             break;\n-         case SO_REUSEADDR:\n-             if (!(o instanceof Boolean)) {\n-                 throw new SocketException(\"bad argument for SO_REUSEADDR\");\n-             }\n-             break;\n-         case SO_BROADCAST:\n-             if (!(o instanceof Boolean)) {\n-                 throw new SocketException(\"bad argument for SO_BROADCAST\");\n-             }\n-             break;\n-         case SO_BINDADDR:\n-             throw new SocketException(\"Cannot re-bind Socket\");\n-         case SO_RCVBUF:\n-         case SO_SNDBUF:\n-             if (!(o instanceof Integer) ||\n-                 ((Integer)o).intValue() < 0) {\n-                 throw new SocketException(\"bad argument for SO_SNDBUF or \" +\n-                                           \"SO_RCVBUF\");\n-             }\n-             break;\n-         case IP_MULTICAST_IF:\n-             if (!(o instanceof InetAddress))\n-                 throw new SocketException(\"bad argument for IP_MULTICAST_IF\");\n-             break;\n-         case IP_MULTICAST_IF2:\n-             if (!(o instanceof NetworkInterface))\n-                 throw new SocketException(\"bad argument for IP_MULTICAST_IF2\");\n-             break;\n-         case IP_MULTICAST_LOOP:\n-             if (!(o instanceof Boolean))\n-                 throw new SocketException(\"bad argument for IP_MULTICAST_LOOP\");\n-             break;\n-         case SO_REUSEPORT:\n-             if (!(o instanceof Boolean)) {\n-                 throw new SocketException(\"bad argument for SO_REUSEPORT\");\n-             }\n-             if (!supportedOptions().contains(StandardSocketOptions.SO_REUSEPORT)) {\n-                 throw new UnsupportedOperationException(\"unsupported option\");\n-             }\n-             break;\n-         default:\n-             throw new SocketException(\"invalid option: \" + optID);\n-         }\n-         socketSetOption(optID, o);\n-     }\n-\n-    \/*\n-     * get option's state - set or not\n-     *\/\n-\n-    public Object getOption(int optID) throws SocketException {\n-        if (isClosed()) {\n-            throw new SocketException(\"Socket Closed\");\n-        }\n-\n-        Object result;\n-\n-        switch (optID) {\n-            case SO_TIMEOUT:\n-                result = timeout;\n-                break;\n-\n-            case IP_TOS:\n-                result = socketGetOption(optID);\n-                if ( ((Integer)result).intValue() == -1) {\n-                    result = trafficClass;\n-                }\n-                break;\n-\n-            case SO_BINDADDR:\n-            case IP_MULTICAST_IF:\n-            case IP_MULTICAST_IF2:\n-            case SO_RCVBUF:\n-            case SO_SNDBUF:\n-            case IP_MULTICAST_LOOP:\n-            case SO_REUSEADDR:\n-            case SO_BROADCAST:\n-                result = socketGetOption(optID);\n-                break;\n-\n-            case SO_REUSEPORT:\n-                if (!supportedOptions().contains(StandardSocketOptions.SO_REUSEPORT)) {\n-                    throw new UnsupportedOperationException(\"unsupported option\");\n-                }\n-                result = socketGetOption(optID);\n-                break;\n-\n-            default:\n-                throw new SocketException(\"invalid option: \" + optID);\n-        }\n-\n-        return result;\n-    }\n-\n-    static final ExtendedSocketOptions extendedOptions =\n-            ExtendedSocketOptions.getInstance();\n-\n-    private static final Set<SocketOption<?>> datagramSocketOptions = datagramSocketOptions();\n-\n-    private static Set<SocketOption<?>> datagramSocketOptions() {\n-        HashSet<SocketOption<?>> options = new HashSet<>();\n-        options.add(StandardSocketOptions.SO_SNDBUF);\n-        options.add(StandardSocketOptions.SO_RCVBUF);\n-        options.add(StandardSocketOptions.SO_REUSEADDR);\n-        options.add(StandardSocketOptions.SO_BROADCAST);\n-        options.add(StandardSocketOptions.IP_TOS);\n-        options.add(StandardSocketOptions.IP_MULTICAST_IF);\n-        options.add(StandardSocketOptions.IP_MULTICAST_TTL);\n-        options.add(StandardSocketOptions.IP_MULTICAST_LOOP);\n-        if (isReusePortAvailable())\n-            options.add(StandardSocketOptions.SO_REUSEPORT);\n-        options.addAll(ExtendedSocketOptions.datagramSocketOptions());\n-        return Collections.unmodifiableSet(options);\n-    }\n-\n-    @Override\n-    protected Set<SocketOption<?>> supportedOptions() {\n-            return datagramSocketOptions;\n-    }\n-\n-    @Override\n-    protected <T> void setOption(SocketOption<T> name, T value) throws IOException {\n-        Objects.requireNonNull(name);\n-        if (!supportedOptions().contains(name))\n-            throw new UnsupportedOperationException(\"'\" + name + \"' not supported\");\n-\n-        if (!name.type().isInstance(value))\n-            throw new IllegalArgumentException(\"Invalid value '\" + value + \"'\");\n-\n-        if (isClosed())\n-            throw new SocketException(\"Socket closed\");\n-\n-        if (name == StandardSocketOptions.SO_SNDBUF) {\n-            if (((Integer)value).intValue() < 0)\n-                throw new IllegalArgumentException(\"Invalid send buffer size:\" + value);\n-            setOption(SocketOptions.SO_SNDBUF, value);\n-        } else if (name == StandardSocketOptions.SO_RCVBUF) {\n-            if (((Integer)value).intValue() < 0)\n-                throw new IllegalArgumentException(\"Invalid recv buffer size:\" + value);\n-            setOption(SocketOptions.SO_RCVBUF, value);\n-        } else if (name == StandardSocketOptions.SO_REUSEADDR) {\n-            setOption(SocketOptions.SO_REUSEADDR, value);\n-        } else if (name == StandardSocketOptions.SO_REUSEPORT) {\n-            setOption(SocketOptions.SO_REUSEPORT, value);\n-        } else if (name == StandardSocketOptions.SO_BROADCAST) {\n-            setOption(SocketOptions.SO_BROADCAST, value);\n-        } else if (name == StandardSocketOptions.IP_TOS) {\n-            int i = ((Integer)value).intValue();\n-            if (i < 0 || i > 255)\n-                throw new IllegalArgumentException(\"Invalid IP_TOS value: \" + value);\n-            setOption(SocketOptions.IP_TOS, value);\n-        } else if (name == StandardSocketOptions.IP_MULTICAST_IF ) {\n-            setOption(SocketOptions.IP_MULTICAST_IF2, value);\n-        } else if (name == StandardSocketOptions.IP_MULTICAST_TTL) {\n-            int i = ((Integer)value).intValue();\n-            if (i < 0 || i > 255)\n-                throw new IllegalArgumentException(\"Invalid TTL\/hop value: \" + value);\n-            setTimeToLive((Integer)value);\n-        } else if (name == StandardSocketOptions.IP_MULTICAST_LOOP) {\n-            boolean enable = (boolean) value;\n-            \/\/ Legacy setOption expects true to mean 'disabled'\n-            setOption(SocketOptions.IP_MULTICAST_LOOP, !enable);\n-        } else if (extendedOptions.isOptionSupported(name)) {\n-            extendedOptions.setOption(fd, name, value);\n-        } else {\n-            throw new AssertionError(\"unknown option :\" + name);\n-        }\n-    }\n-\n-    @Override\n-    @SuppressWarnings(\"unchecked\")\n-    protected <T> T getOption(SocketOption<T> name) throws IOException {\n-        Objects.requireNonNull(name);\n-        if (!supportedOptions().contains(name))\n-            throw new UnsupportedOperationException(\"'\" + name + \"' not supported\");\n-\n-        if (isClosed())\n-            throw new SocketException(\"Socket closed\");\n-\n-        if (name == StandardSocketOptions.SO_SNDBUF) {\n-            return (T) getOption(SocketOptions.SO_SNDBUF);\n-        } else if (name == StandardSocketOptions.SO_RCVBUF) {\n-            return (T) getOption(SocketOptions.SO_RCVBUF);\n-        } else if (name == StandardSocketOptions.SO_REUSEADDR) {\n-            return (T) getOption(SocketOptions.SO_REUSEADDR);\n-        } else if (name == StandardSocketOptions.SO_REUSEPORT) {\n-            return (T) getOption(SocketOptions.SO_REUSEPORT);\n-        } else if (name == StandardSocketOptions.SO_BROADCAST) {\n-            return (T) getOption(SocketOptions.SO_BROADCAST);\n-        } else if (name == StandardSocketOptions.IP_TOS) {\n-            return (T) getOption(SocketOptions.IP_TOS);\n-        } else if (name == StandardSocketOptions.IP_MULTICAST_IF) {\n-            return (T) getOption(SocketOptions.IP_MULTICAST_IF2);\n-        } else if (name == StandardSocketOptions.IP_MULTICAST_TTL) {\n-            return (T) ((Integer) getTimeToLive());\n-        } else if (name == StandardSocketOptions.IP_MULTICAST_LOOP) {\n-            boolean disabled = (boolean) getOption(SocketOptions.IP_MULTICAST_LOOP);\n-            \/\/ Legacy getOption returns true when disabled\n-            return (T) Boolean.valueOf(!disabled);\n-        } else if (extendedOptions.isOptionSupported(name)) {\n-            return (T) extendedOptions.getOption(fd, name);\n-        } else {\n-            throw new AssertionError(\"unknown option: \" + name);\n-        }\n-    }\n-\n-    protected abstract void datagramSocketCreate() throws SocketException;\n-    protected abstract void datagramSocketClose();\n-    protected abstract void socketSetOption(int opt, Object val)\n-        throws SocketException;\n-    protected abstract Object socketGetOption(int opt) throws SocketException;\n-\n-    protected abstract void connect0(InetAddress address, int port) throws SocketException;\n-    protected abstract void disconnect0(int family);\n-\n-    protected boolean nativeConnectDisabled() {\n-        return connectDisabled;\n-    }\n-\n-    abstract int dataAvailable();\n-    private static native boolean isReusePortAvailable0();\n-}\n","filename":"src\/java.base\/share\/classes\/java\/net\/AbstractPlainDatagramSocketImpl.java","additions":0,"deletions":530,"binary":false,"changes":530,"status":"deleted"},{"patch":"@@ -1,875 +0,0 @@\n-\/*\n- * Copyright (c) 1995, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.net;\n-\n-import java.io.FileDescriptor;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.OutputStream;\n-\n-import java.security.AccessController;\n-import java.security.PrivilegedActionException;\n-import java.security.PrivilegedExceptionAction;\n-import java.util.Collections;\n-import java.util.HashSet;\n-import java.util.Objects;\n-import java.util.Set;\n-\n-import sun.net.ConnectionResetException;\n-import sun.net.NetHooks;\n-import sun.net.PlatformSocketImpl;\n-import sun.net.ResourceManager;\n-import sun.net.ext.ExtendedSocketOptions;\n-import sun.net.util.IPAddressUtil;\n-import sun.net.util.SocketExceptions;\n-\n-\/**\n- * Default Socket Implementation. This implementation does\n- * not implement any security checks.\n- * Note this class should <b>NOT<\/b> be public.\n- *\n- * @author  Steven B. Byrne\n- *\/\n-abstract class AbstractPlainSocketImpl extends SocketImpl implements PlatformSocketImpl {\n-    \/* instance variable for SO_TIMEOUT *\/\n-    int timeout;   \/\/ timeout in millisec\n-    \/\/ traffic class\n-    private int trafficClass;\n-\n-    private boolean shut_rd = false;\n-    private boolean shut_wr = false;\n-\n-    private SocketInputStream socketInputStream = null;\n-    private SocketOutputStream socketOutputStream = null;\n-\n-    \/* number of threads using the FileDescriptor *\/\n-    protected int fdUseCount = 0;\n-\n-    \/* lock when increment\/decrementing fdUseCount *\/\n-    protected final Object fdLock = new Object();\n-\n-    \/* indicates a close is pending on the file descriptor *\/\n-    protected boolean closePending = false;\n-\n-    \/* indicates connection reset state *\/\n-    private volatile boolean connectionReset;\n-\n-    \/* indicates whether impl is bound  *\/\n-    boolean isBound;\n-\n-    \/* indicates whether impl is connected  *\/\n-    volatile boolean isConnected;\n-\n-   \/* whether this Socket is a stream (TCP) socket or not (UDP)\n-    *\/\n-    protected boolean stream;\n-\n-    \/* whether this is a server or not *\/\n-    final boolean isServer;\n-\n-    \/**\n-     * Load net library into runtime.\n-     *\/\n-    static {\n-        jdk.internal.loader.BootLoader.loadLibrary(\"net\");\n-    }\n-\n-    private static volatile boolean checkedReusePort;\n-    private static volatile boolean isReusePortAvailable;\n-\n-    \/**\n-     * Tells whether SO_REUSEPORT is supported.\n-     *\/\n-    static boolean isReusePortAvailable() {\n-        if (!checkedReusePort) {\n-            isReusePortAvailable = isReusePortAvailable0();\n-            checkedReusePort = true;\n-        }\n-        return isReusePortAvailable;\n-    }\n-\n-    AbstractPlainSocketImpl(boolean isServer) {\n-        this.isServer = isServer;\n-    }\n-\n-    \/**\n-     * Creates a socket with a boolean that specifies whether this\n-     * is a stream socket (true) or an unconnected UDP socket (false).\n-     *\/\n-    protected synchronized void create(boolean stream) throws IOException {\n-        this.stream = stream;\n-        if (!stream) {\n-            ResourceManager.beforeUdpCreate();\n-            \/\/ only create the fd after we know we will be able to create the socket\n-            fd = new FileDescriptor();\n-            try {\n-                socketCreate(false);\n-                SocketCleanable.register(fd, false);\n-            } catch (IOException ioe) {\n-                ResourceManager.afterUdpClose();\n-                fd = null;\n-                throw ioe;\n-            }\n-        } else {\n-            fd = new FileDescriptor();\n-            socketCreate(true);\n-            SocketCleanable.register(fd, true);\n-        }\n-    }\n-\n-    \/**\n-     * Creates a socket and connects it to the specified port on\n-     * the specified host.\n-     * @param host the specified host\n-     * @param port the specified port\n-     *\/\n-    protected void connect(String host, int port)\n-        throws UnknownHostException, IOException\n-    {\n-        boolean connected = false;\n-        try {\n-            InetAddress address = InetAddress.getByName(host);\n-            \/\/ recording this.address as supplied by caller before calling connect\n-            this.address = address;\n-            this.port = port;\n-            if (address.isLinkLocalAddress()) {\n-                address = IPAddressUtil.toScopedAddress(address);\n-            }\n-\n-            connectToAddress(address, port, timeout);\n-            connected = true;\n-        } finally {\n-            if (!connected) {\n-                try {\n-                    close();\n-                } catch (IOException ioe) {\n-                    \/* Do nothing. If connect threw an exception then\n-                       it will be passed up the call stack *\/\n-                }\n-            }\n-            isConnected = connected;\n-        }\n-    }\n-\n-    \/**\n-     * Creates a socket and connects it to the specified address on\n-     * the specified port.\n-     * @param address the address\n-     * @param port the specified port\n-     *\/\n-    protected void connect(InetAddress address, int port) throws IOException {\n-        \/\/ recording this.address as supplied by caller before calling connect\n-        this.address = address;\n-        this.port = port;\n-        if (address.isLinkLocalAddress()) {\n-            address = IPAddressUtil.toScopedAddress(address);\n-        }\n-\n-        try {\n-            connectToAddress(address, port, timeout);\n-            isConnected = true;\n-            return;\n-        } catch (IOException e) {\n-            \/\/ everything failed\n-            close();\n-            throw e;\n-        }\n-    }\n-\n-    \/**\n-     * Creates a socket and connects it to the specified address on\n-     * the specified port.\n-     * @param address the address\n-     * @param timeout the timeout value in milliseconds, or zero for no timeout.\n-     * @throws IOException if connection fails\n-     * @throws  IllegalArgumentException if address is null or is a\n-     *          SocketAddress subclass not supported by this socket\n-     * @since 1.4\n-     *\/\n-    protected void connect(SocketAddress address, int timeout)\n-            throws IOException {\n-        boolean connected = false;\n-        try {\n-            if (!(address instanceof InetSocketAddress addr))\n-                throw new IllegalArgumentException(\"unsupported address type\");\n-            if (addr.isUnresolved())\n-                throw new UnknownHostException(addr.getHostName());\n-            \/\/ recording this.address as supplied by caller before calling connect\n-            InetAddress ia = addr.getAddress();\n-            this.address = ia;\n-            this.port = addr.getPort();\n-            if (ia.isLinkLocalAddress()) {\n-                ia = IPAddressUtil.toScopedAddress(ia);\n-            }\n-            connectToAddress(ia, port, timeout);\n-            connected = true;\n-        } finally {\n-            if (!connected) {\n-                try {\n-                    close();\n-                } catch (IOException ioe) {\n-                    \/* Do nothing. If connect threw an exception then\n-                       it will be passed up the call stack *\/\n-                }\n-            }\n-            isConnected = connected;\n-        }\n-    }\n-\n-    private void connectToAddress(InetAddress address, int port, int timeout) throws IOException {\n-        if (address.isAnyLocalAddress()) {\n-            doConnect(InetAddress.getLocalHost(), port, timeout);\n-        } else {\n-            doConnect(address, port, timeout);\n-        }\n-    }\n-\n-    public void setOption(int opt, Object val) throws SocketException {\n-        if (isClosedOrPending()) {\n-            throw new SocketException(\"Socket Closed\");\n-        }\n-        boolean on = true;\n-        switch (opt) {\n-            \/* check type safety b4 going native.  These should never\n-             * fail, since only java.Socket* has access to\n-             * PlainSocketImpl.setOption().\n-             *\/\n-        case SO_LINGER:\n-            if (!(val instanceof Integer) && !(val instanceof Boolean))\n-                throw new SocketException(\"Bad parameter for option\");\n-            if (val instanceof Boolean) {\n-                \/* true only if disabling - enabling should be Integer *\/\n-                on = false;\n-            }\n-            break;\n-        case SO_TIMEOUT:\n-            if (!(val instanceof Integer))\n-                throw new SocketException(\"Bad parameter for SO_TIMEOUT\");\n-            int tmp = ((Integer) val).intValue();\n-            if (tmp < 0)\n-                throw new IllegalArgumentException(\"timeout < 0\");\n-            timeout = tmp;\n-            break;\n-        case IP_TOS:\n-             if (!(val instanceof Integer)) {\n-                 throw new SocketException(\"bad argument for IP_TOS\");\n-             }\n-             trafficClass = ((Integer)val).intValue();\n-             break;\n-        case SO_BINDADDR:\n-            throw new SocketException(\"Cannot re-bind socket\");\n-        case TCP_NODELAY:\n-            if (!(val instanceof Boolean))\n-                throw new SocketException(\"bad parameter for TCP_NODELAY\");\n-            on = ((Boolean)val).booleanValue();\n-            break;\n-        case SO_SNDBUF:\n-        case SO_RCVBUF:\n-            if (!(val instanceof Integer) ||\n-                !(((Integer)val).intValue() > 0)) {\n-                throw new SocketException(\"bad parameter for SO_SNDBUF \" +\n-                                          \"or SO_RCVBUF\");\n-            }\n-            break;\n-        case SO_KEEPALIVE:\n-            if (!(val instanceof Boolean))\n-                throw new SocketException(\"bad parameter for SO_KEEPALIVE\");\n-            on = ((Boolean)val).booleanValue();\n-            break;\n-        case SO_OOBINLINE:\n-            if (!(val instanceof Boolean))\n-                throw new SocketException(\"bad parameter for SO_OOBINLINE\");\n-            on = ((Boolean)val).booleanValue();\n-            break;\n-        case SO_REUSEADDR:\n-            if (!(val instanceof Boolean))\n-                throw new SocketException(\"bad parameter for SO_REUSEADDR\");\n-            on = ((Boolean)val).booleanValue();\n-            break;\n-        case SO_REUSEPORT:\n-            if (!(val instanceof Boolean))\n-                throw new SocketException(\"bad parameter for SO_REUSEPORT\");\n-            if (!supportedOptions().contains(StandardSocketOptions.SO_REUSEPORT))\n-                throw new UnsupportedOperationException(\"unsupported option\");\n-            on = ((Boolean)val).booleanValue();\n-            break;\n-        default:\n-            throw new SocketException(\"unrecognized TCP option: \" + opt);\n-        }\n-        socketSetOption(opt, on, val);\n-    }\n-    public Object getOption(int opt) throws SocketException {\n-        if (isClosedOrPending()) {\n-            throw new SocketException(\"Socket Closed\");\n-        }\n-        if (opt == SO_TIMEOUT) {\n-            return timeout;\n-        }\n-        int ret = 0;\n-        \/*\n-         * The native socketGetOption() knows about 3 options.\n-         * The 32 bit value it returns will be interpreted according\n-         * to what we're asking.  A return of -1 means it understands\n-         * the option but its turned off.  It will raise a SocketException\n-         * if \"opt\" isn't one it understands.\n-         *\/\n-\n-        switch (opt) {\n-        case TCP_NODELAY:\n-            ret = socketGetOption(opt, null);\n-            return Boolean.valueOf(ret != -1);\n-        case SO_OOBINLINE:\n-            ret = socketGetOption(opt, null);\n-            return Boolean.valueOf(ret != -1);\n-        case SO_LINGER:\n-            ret = socketGetOption(opt, null);\n-            return (ret == -1) ? Boolean.FALSE: (Object)(ret);\n-        case SO_REUSEADDR:\n-            ret = socketGetOption(opt, null);\n-            return Boolean.valueOf(ret != -1);\n-        case SO_BINDADDR:\n-            InetAddressContainer in = new InetAddressContainer();\n-            ret = socketGetOption(opt, in);\n-            return in.addr;\n-        case SO_SNDBUF:\n-        case SO_RCVBUF:\n-            ret = socketGetOption(opt, null);\n-            return ret;\n-        case IP_TOS:\n-            try {\n-                ret = socketGetOption(opt, null);\n-                if (ret == -1) { \/\/ ipv6 tos\n-                    return trafficClass;\n-                } else {\n-                    return ret;\n-                }\n-            } catch (SocketException se) {\n-                    \/\/ TODO - should make better effort to read TOS or TCLASS\n-                    return trafficClass; \/\/ ipv6 tos\n-            }\n-        case SO_KEEPALIVE:\n-            ret = socketGetOption(opt, null);\n-            return Boolean.valueOf(ret != -1);\n-        case SO_REUSEPORT:\n-            if (!supportedOptions().contains(StandardSocketOptions.SO_REUSEPORT)) {\n-                throw new UnsupportedOperationException(\"unsupported option\");\n-            }\n-            ret = socketGetOption(opt, null);\n-            return Boolean.valueOf(ret != -1);\n-        \/\/ should never get here\n-        default:\n-            return null;\n-        }\n-    }\n-\n-    static final ExtendedSocketOptions extendedOptions =\n-            ExtendedSocketOptions.getInstance();\n-\n-    private static final Set<SocketOption<?>> clientSocketOptions = clientSocketOptions();\n-    private static final Set<SocketOption<?>> serverSocketOptions = serverSocketOptions();\n-\n-    private static Set<SocketOption<?>> clientSocketOptions() {\n-        HashSet<SocketOption<?>> options = new HashSet<>();\n-        options.add(StandardSocketOptions.SO_KEEPALIVE);\n-        options.add(StandardSocketOptions.SO_SNDBUF);\n-        options.add(StandardSocketOptions.SO_RCVBUF);\n-        options.add(StandardSocketOptions.SO_REUSEADDR);\n-        options.add(StandardSocketOptions.SO_LINGER);\n-        options.add(StandardSocketOptions.IP_TOS);\n-        options.add(StandardSocketOptions.TCP_NODELAY);\n-        if (isReusePortAvailable())\n-            options.add(StandardSocketOptions.SO_REUSEPORT);\n-        options.addAll(ExtendedSocketOptions.clientSocketOptions());\n-        return Collections.unmodifiableSet(options);\n-    }\n-\n-    private static Set<SocketOption<?>> serverSocketOptions() {\n-        HashSet<SocketOption<?>> options = new HashSet<>();\n-        options.add(StandardSocketOptions.SO_RCVBUF);\n-        options.add(StandardSocketOptions.SO_REUSEADDR);\n-        options.add(StandardSocketOptions.IP_TOS);\n-        if (isReusePortAvailable())\n-            options.add(StandardSocketOptions.SO_REUSEPORT);\n-        options.addAll(ExtendedSocketOptions.serverSocketOptions());\n-        return Collections.unmodifiableSet(options);\n-    }\n-\n-    @Override\n-    protected Set<SocketOption<?>> supportedOptions() {\n-        if (isServer)\n-            return serverSocketOptions;\n-        else\n-            return clientSocketOptions;\n-    }\n-\n-    @Override\n-    protected <T> void setOption(SocketOption<T> name, T value) throws IOException {\n-        Objects.requireNonNull(name);\n-        if (!supportedOptions().contains(name))\n-            throw new UnsupportedOperationException(\"'\" + name + \"' not supported\");\n-\n-        if (!name.type().isInstance(value))\n-            throw new IllegalArgumentException(\"Invalid value '\" + value + \"'\");\n-\n-        if (isClosedOrPending())\n-            throw new SocketException(\"Socket closed\");\n-\n-        if (name == StandardSocketOptions.SO_KEEPALIVE) {\n-            setOption(SocketOptions.SO_KEEPALIVE, value);\n-        } else if (name == StandardSocketOptions.SO_SNDBUF) {\n-            if (((Integer)value).intValue() < 0)\n-                throw new IllegalArgumentException(\"Invalid send buffer size:\" + value);\n-            setOption(SocketOptions.SO_SNDBUF, value);\n-        } else if (name == StandardSocketOptions.SO_RCVBUF) {\n-            if (((Integer)value).intValue() < 0)\n-                throw new IllegalArgumentException(\"Invalid recv buffer size:\" + value);\n-            setOption(SocketOptions.SO_RCVBUF, value);\n-        } else if (name == StandardSocketOptions.SO_REUSEADDR) {\n-            setOption(SocketOptions.SO_REUSEADDR, value);\n-        } else if (name == StandardSocketOptions.SO_REUSEPORT) {\n-            setOption(SocketOptions.SO_REUSEPORT, value);\n-        } else if (name == StandardSocketOptions.SO_LINGER ) {\n-            if (((Integer)value).intValue() < 0)\n-                setOption(SocketOptions.SO_LINGER, false);\n-            else\n-                setOption(SocketOptions.SO_LINGER, value);\n-        } else if (name == StandardSocketOptions.IP_TOS) {\n-            int i = ((Integer)value).intValue();\n-            if (i < 0 || i > 255)\n-                throw new IllegalArgumentException(\"Invalid IP_TOS value: \" + value);\n-            setOption(SocketOptions.IP_TOS, value);\n-        } else if (name == StandardSocketOptions.TCP_NODELAY) {\n-            setOption(SocketOptions.TCP_NODELAY, value);\n-        } else if (extendedOptions.isOptionSupported(name)) {\n-            extendedOptions.setOption(fd, name, value);\n-        } else {\n-            throw new AssertionError(\"unknown option: \" + name);\n-        }\n-    }\n-\n-    @Override\n-    @SuppressWarnings(\"unchecked\")\n-    protected <T> T getOption(SocketOption<T> name) throws IOException {\n-        Objects.requireNonNull(name);\n-        if (!supportedOptions().contains(name))\n-            throw new UnsupportedOperationException(\"'\" + name + \"' not supported\");\n-\n-        if (isClosedOrPending())\n-            throw new SocketException(\"Socket closed\");\n-\n-        if (name == StandardSocketOptions.SO_KEEPALIVE) {\n-            return (T)getOption(SocketOptions.SO_KEEPALIVE);\n-        } else if (name == StandardSocketOptions.SO_SNDBUF) {\n-            return (T)getOption(SocketOptions.SO_SNDBUF);\n-        } else if (name == StandardSocketOptions.SO_RCVBUF) {\n-            return (T)getOption(SocketOptions.SO_RCVBUF);\n-        } else if (name == StandardSocketOptions.SO_REUSEADDR) {\n-            return (T)getOption(SocketOptions.SO_REUSEADDR);\n-        } else if (name == StandardSocketOptions.SO_REUSEPORT) {\n-            return (T)getOption(SocketOptions.SO_REUSEPORT);\n-        } else if (name == StandardSocketOptions.SO_LINGER) {\n-            Object value = getOption(SocketOptions.SO_LINGER);\n-            if (value instanceof Boolean) {\n-                assert ((Boolean)value).booleanValue() == false;\n-                value = -1;\n-            }\n-            return (T)value;\n-        } else if (name == StandardSocketOptions.IP_TOS) {\n-            return (T)getOption(SocketOptions.IP_TOS);\n-        } else if (name == StandardSocketOptions.TCP_NODELAY) {\n-            return (T)getOption(SocketOptions.TCP_NODELAY);\n-        } else if (extendedOptions.isOptionSupported(name)) {\n-            return (T) extendedOptions.getOption(fd, name);\n-        } else {\n-            throw new AssertionError(\"unknown option: \" + name);\n-        }\n-    }\n-\n-    \/**\n-     * The workhorse of the connection operation.  Tries several times to\n-     * establish a connection to the given <host, port>.  If unsuccessful,\n-     * throws an IOException indicating what went wrong.\n-     *\/\n-\n-    synchronized void doConnect(InetAddress address, int port, int timeout) throws IOException {\n-        synchronized (fdLock) {\n-            if (!closePending && !isBound) {\n-                NetHooks.beforeTcpConnect(fd, address, port);\n-            }\n-        }\n-        try {\n-            acquireFD();\n-            try {\n-                socketConnect(address, port, timeout);\n-                \/* socket may have been closed during poll\/select *\/\n-                synchronized (fdLock) {\n-                    if (closePending) {\n-                        throw new SocketException (\"Socket closed\");\n-                    }\n-                }\n-            } finally {\n-                releaseFD();\n-            }\n-        } catch (IOException e) {\n-            close();\n-            throw SocketExceptions.of(e, new InetSocketAddress(address, port));\n-        }\n-    }\n-\n-    \/**\n-     * Binds the socket to the specified address of the specified local port.\n-     * @param address the address\n-     * @param lport the port\n-     *\/\n-    protected synchronized void bind(InetAddress address, int lport)\n-        throws IOException\n-    {\n-       synchronized (fdLock) {\n-            if (!closePending && !isBound) {\n-                NetHooks.beforeTcpBind(fd, address, lport);\n-            }\n-        }\n-        if (address.isLinkLocalAddress()) {\n-            address = IPAddressUtil.toScopedAddress(address);\n-        }\n-        socketBind(address, lport);\n-        isBound = true;\n-    }\n-\n-    \/**\n-     * Listens, for a specified amount of time, for connections.\n-     * @param count the amount of time to listen for connections\n-     *\/\n-    protected synchronized void listen(int count) throws IOException {\n-        socketListen(count);\n-    }\n-\n-    \/**\n-     * Accepts connections.\n-     * @param si the socket impl\n-     *\/\n-    protected void accept(SocketImpl si) throws IOException {\n-        si.fd = new FileDescriptor();\n-        acquireFD();\n-        try {\n-            socketAccept(si);\n-        } finally {\n-            releaseFD();\n-        }\n-        SocketCleanable.register(si.fd, true);\n-    }\n-\n-    \/**\n-     * Gets an InputStream for this socket.\n-     *\/\n-    @SuppressWarnings(\"removal\")\n-    protected synchronized InputStream getInputStream() throws IOException {\n-        synchronized (fdLock) {\n-            if (isClosedOrPending())\n-                throw new IOException(\"Socket Closed\");\n-            if (shut_rd)\n-                throw new IOException(\"Socket input is shutdown\");\n-            if (socketInputStream == null) {\n-                PrivilegedExceptionAction<SocketInputStream> pa = () -> new SocketInputStream(this);\n-                try {\n-                    socketInputStream = AccessController.doPrivileged(pa);\n-                } catch (PrivilegedActionException e) {\n-                    throw (IOException) e.getCause();\n-                }\n-            }\n-        }\n-        return socketInputStream;\n-    }\n-\n-    void setInputStream(SocketInputStream in) {\n-        socketInputStream = in;\n-    }\n-\n-    \/**\n-     * Gets an OutputStream for this socket.\n-     *\/\n-    @SuppressWarnings(\"removal\")\n-    protected synchronized OutputStream getOutputStream() throws IOException {\n-        synchronized (fdLock) {\n-            if (isClosedOrPending())\n-                throw new IOException(\"Socket Closed\");\n-            if (shut_wr)\n-                throw new IOException(\"Socket output is shutdown\");\n-            if (socketOutputStream == null) {\n-                PrivilegedExceptionAction<SocketOutputStream> pa = () -> new SocketOutputStream(this);\n-                try {\n-                    socketOutputStream = AccessController.doPrivileged(pa);\n-                } catch (PrivilegedActionException e) {\n-                    throw (IOException) e.getCause();\n-                }\n-            }\n-        }\n-        return socketOutputStream;\n-    }\n-\n-    void setFileDescriptor(FileDescriptor fd) {\n-        this.fd = fd;\n-    }\n-\n-    void setAddress(InetAddress address) {\n-        this.address = address;\n-    }\n-\n-    void setPort(int port) {\n-        this.port = port;\n-    }\n-\n-    void setLocalPort(int localport) {\n-        this.localport = localport;\n-    }\n-\n-    \/**\n-     * Returns the number of bytes that can be read without blocking.\n-     *\/\n-    protected synchronized int available() throws IOException {\n-        if (isClosedOrPending()) {\n-            throw new IOException(\"Stream closed.\");\n-        }\n-\n-        \/*\n-         * If connection has been reset or shut down for input, then return 0\n-         * to indicate there are no buffered bytes.\n-         *\/\n-        if (isConnectionReset() || shut_rd) {\n-            return 0;\n-        }\n-\n-        \/*\n-         * If no bytes available and we were previously notified\n-         * of a connection reset then we move to the reset state.\n-         *\n-         * If are notified of a connection reset then check\n-         * again if there are bytes buffered on the socket.\n-         *\/\n-        int n = 0;\n-        try {\n-            n = socketAvailable();\n-        } catch (ConnectionResetException exc1) {\n-            setConnectionReset();\n-        }\n-        return n;\n-    }\n-\n-    \/**\n-     * Closes the socket.\n-     *\/\n-    protected void close() throws IOException {\n-        synchronized(fdLock) {\n-            if (fd != null) {\n-                if (fdUseCount == 0) {\n-                    if (closePending) {\n-                        return;\n-                    }\n-                    closePending = true;\n-                    \/*\n-                     * We close the FileDescriptor in two-steps - first the\n-                     * \"pre-close\" which closes the socket but doesn't\n-                     * release the underlying file descriptor. This operation\n-                     * may be lengthy due to untransmitted data and a long\n-                     * linger interval. Once the pre-close is done we do the\n-                     * actual socket to release the fd.\n-                     *\/\n-                    try {\n-                        socketPreClose();\n-                    } finally {\n-                        socketClose();\n-                    }\n-                    fd = null;\n-                    return;\n-                } else {\n-                    \/*\n-                     * If a thread has acquired the fd and a close\n-                     * isn't pending then use a deferred close.\n-                     * Also decrement fdUseCount to signal the last\n-                     * thread that releases the fd to close it.\n-                     *\/\n-                    if (!closePending) {\n-                        closePending = true;\n-                        fdUseCount--;\n-                        socketPreClose();\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    void reset() {\n-        throw new InternalError(\"should not get here\");\n-    }\n-\n-    \/**\n-     * Shutdown read-half of the socket connection;\n-     *\/\n-    protected void shutdownInput() throws IOException {\n-      if (fd != null) {\n-          socketShutdown(SHUT_RD);\n-          if (socketInputStream != null) {\n-              socketInputStream.setEOF(true);\n-          }\n-          shut_rd = true;\n-      }\n-    }\n-\n-    \/**\n-     * Shutdown write-half of the socket connection;\n-     *\/\n-    protected void shutdownOutput() throws IOException {\n-      if (fd != null) {\n-          socketShutdown(SHUT_WR);\n-          shut_wr = true;\n-      }\n-    }\n-\n-    protected boolean supportsUrgentData () {\n-        return true;\n-    }\n-\n-    protected void sendUrgentData (int data) throws IOException {\n-        if (fd == null) {\n-            throw new IOException(\"Socket Closed\");\n-        }\n-        socketSendUrgentData (data);\n-    }\n-\n-    \/*\n-     * \"Acquires\" and returns the FileDescriptor for this impl\n-     *\n-     * A corresponding releaseFD is required to \"release\" the\n-     * FileDescriptor.\n-     *\/\n-    FileDescriptor acquireFD() {\n-        synchronized (fdLock) {\n-            fdUseCount++;\n-            return fd;\n-        }\n-    }\n-\n-    \/*\n-     * \"Release\" the FileDescriptor for this impl.\n-     *\n-     * If the use count goes to -1 then the socket is closed.\n-     *\/\n-    void releaseFD() {\n-        synchronized (fdLock) {\n-            fdUseCount--;\n-            if (fdUseCount == -1) {\n-                if (fd != null) {\n-                    try {\n-                        socketClose();\n-                    } catch (IOException e) {\n-                    } finally {\n-                        fd = null;\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    boolean isConnectionReset() {\n-        return connectionReset;\n-    }\n-\n-    void setConnectionReset() {\n-        connectionReset = true;\n-    }\n-\n-    \/*\n-     * Return true if already closed or close is pending\n-     *\/\n-    public boolean isClosedOrPending() {\n-        \/*\n-         * Lock on fdLock to ensure that we wait if a\n-         * close is in progress.\n-         *\/\n-        synchronized (fdLock) {\n-            if (closePending || (fd == null)) {\n-                return true;\n-            } else {\n-                return false;\n-            }\n-        }\n-    }\n-\n-    \/*\n-     * Return the current value of SO_TIMEOUT\n-     *\/\n-    public int getTimeout() {\n-        return timeout;\n-    }\n-\n-    \/*\n-     * \"Pre-close\" a socket by dup'ing the file descriptor - this enables\n-     * the socket to be closed without releasing the file descriptor.\n-     *\/\n-    private void socketPreClose() throws IOException {\n-        socketClose0(true);\n-    }\n-\n-    \/*\n-     * Close the socket (and release the file descriptor).\n-     *\/\n-    protected void socketClose() throws IOException {\n-        SocketCleanable.unregister(fd);\n-        try {\n-            socketClose0(false);\n-        } finally {\n-            if (!stream) {\n-                ResourceManager.afterUdpClose();\n-            }\n-        }\n-    }\n-\n-    abstract void socketCreate(boolean stream) throws IOException;\n-    abstract void socketConnect(InetAddress address, int port, int timeout)\n-        throws IOException;\n-    abstract void socketBind(InetAddress address, int port)\n-        throws IOException;\n-    abstract void socketListen(int count)\n-        throws IOException;\n-    abstract void socketAccept(SocketImpl s)\n-        throws IOException;\n-    abstract int socketAvailable()\n-        throws IOException;\n-    abstract void socketClose0(boolean useDeferredClose)\n-        throws IOException;\n-    abstract void socketShutdown(int howto)\n-        throws IOException;\n-    abstract void socketSetOption(int cmd, boolean on, Object value)\n-        throws SocketException;\n-    abstract int socketGetOption(int opt, Object iaContainerObj) throws SocketException;\n-    abstract void socketSendUrgentData(int data)\n-        throws IOException;\n-\n-    public static final int SHUT_RD = 0;\n-    public static final int SHUT_WR = 1;\n-\n-    private static native boolean isReusePortAvailable0();\n-}\n","filename":"src\/java.base\/share\/classes\/java\/net\/AbstractPlainSocketImpl.java","additions":0,"deletions":875,"binary":false,"changes":875,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,8 +55,0 @@\n-    \/**\n-     * Perform class initialization\n-     *\/\n-    static {\n-        jdk.internal.loader.BootLoader.loadLibrary(\"net\");\n-        init();\n-    }\n-\n@@ -427,5 +419,0 @@\n-\n-    \/**\n-     * Perform class load-time initializations.\n-     *\/\n-    private static native void init();\n","filename":"src\/java.base\/share\/classes\/java\/net\/DatagramPacket.java","additions":1,"deletions":14,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.util.Objects;\n@@ -1401,1 +1402,1 @@\n-            if (USE_PLAINDATAGRAMSOCKET || factory != null) {\n+            if (factory != null) {\n@@ -1403,6 +1404,2 @@\n-                DatagramSocketImpl impl;\n-                if (factory != null) {\n-                    impl = factory.createDatagramSocketImpl();\n-                } else {\n-                    impl = DefaultDatagramSocketImplFactory.createDatagramSocketImpl(multicast);\n-                }\n+                DatagramSocketImpl impl = factory.createDatagramSocketImpl();\n+                Objects.requireNonNull(impl);\n","filename":"src\/java.base\/share\/classes\/java\/net\/DatagramSocket.java","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,18 +36,0 @@\n- * @implNote Sockets created with the {@code DatagramSocket} and {@code\n- * MulticastSocket} public constructors historically delegated all socket\n- * operations to a {@code DatagramSocketImpl} implementation named\n- * \"PlainDatagramSocketImpl\". {@code DatagramSocket} and {@code MulticastSocket}\n- * have since been changed to a new implementation based on {@code DatagramChannel}.\n- * The JDK continues to ship with the older implementation to allow code to run\n- * that depends on unspecified behavior that differs between the old and new\n- * implementations. The old implementation will be used if the Java virtual\n- * machine is started with the system property {@systemProperty\n- * jdk.net.usePlainDatagramSocketImpl} set to use the old implementation. It may\n- * also be set in the JDK's network configuration file, located in {@code\n- * ${java.home}\/conf\/net.properties}. The value of the property is the string\n- * representation of a boolean. If set without a value then it defaults to {@code\n- * true}, hence running with {@code -Djdk.net.usePlainDatagramSocketImpl} or\n- * {@code -Djdk.net.usePlainDatagramSocketImpl=true} will configure the Java\n- * virtual machine to use the old implementation. The property and old\n- * implementation will be removed in a future version.\n- *\n","filename":"src\/java.base\/share\/classes\/java\/net\/DatagramSocketImpl.java","additions":1,"deletions":19,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -139,2 +139,1 @@\n-        if (oldImpl || (impl instanceof AbstractPlainDatagramSocketImpl &&\n-                ((AbstractPlainDatagramSocketImpl) impl).nativeConnectDisabled())) {\n+        if (oldImpl) {\n","filename":"src\/java.base\/share\/classes\/java\/net\/NetMulticastSocket.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,119 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package java.net;\n-\n-import jdk.internal.access.JavaIOFileDescriptorAccess;\n-import jdk.internal.access.SharedSecrets;\n-import jdk.internal.ref.CleanerFactory;\n-import jdk.internal.ref.PhantomCleanable;\n-\n-import java.io.FileDescriptor;\n-import java.io.IOException;\n-import java.io.UncheckedIOException;\n-import java.lang.ref.Cleaner;\n-\n-import sun.net.ResourceManager;\n-\n-\/**\n- * Cleanable for a socket\/datagramsocket FileDescriptor when it becomes phantom reachable.\n- * Create a cleanup if the raw fd != -1. Windows closes sockets using the fd.\n- * Subclassed from {@code PhantomCleanable} so that {@code clear} can be\n- * called to disable the cleanup when the socket fd is closed by any means\n- * other than calling {@link FileDescriptor#close}.\n- * Otherwise, it might incorrectly close the handle or fd after it has been reused.\n- *\/\n-final class SocketCleanable extends PhantomCleanable<FileDescriptor> {\n-\n-    \/\/ Access to FileDescriptor private fields\n-    private static final JavaIOFileDescriptorAccess fdAccess =\n-            SharedSecrets.getJavaIOFileDescriptorAccess();\n-\n-    \/\/ Native function to call NET_SocketClose(fd)\n-    \/\/ Used only for last chance cleanup.\n-    private static native void cleanupClose0(int fd) throws IOException;\n-\n-    \/\/ The raw fd to close\n-    private final int fd;\n-\n-    \/\/ true for socket, false for datagram socket\n-    private final boolean stream;\n-\n-    \/**\n-     * Register a socket specific Cleanable with the FileDescriptor\n-     * if the FileDescriptor is non-null and the raw fd is != -1.\n-     *\n-     * @param fdo     the FileDescriptor; may be null\n-     * @param stream  false for datagram socket\n-     *\/\n-    static void register(FileDescriptor fdo, boolean stream) {\n-        if (fdo != null && fdo.valid()) {\n-            int fd = fdAccess.get(fdo);\n-            fdAccess.registerCleanup(fdo,\n-                    new SocketCleanable(fdo, CleanerFactory.cleaner(),\n-                                        fd, stream));\n-        }\n-    }\n-\n-    \/**\n-     * Unregister a Cleanable from the FileDescriptor.\n-     * @param fdo the FileDescriptor; may be null\n-     *\/\n-    static void unregister(FileDescriptor fdo) {\n-        if (fdo != null) {\n-            fdAccess.unregisterCleanup(fdo);\n-        }\n-    }\n-\n-    \/**\n-     * Constructor for a phantom cleanable reference.\n-     *\n-     * @param obj     the object to monitor\n-     * @param cleaner the cleaner\n-     * @param fd      file descriptor to close\n-     * @param stream  false for datagram socket\n-     *\/\n-    private SocketCleanable(FileDescriptor obj, Cleaner cleaner,\n-                            int fd, boolean stream) {\n-        super(obj, cleaner);\n-        this.fd = fd;\n-        this.stream = stream;\n-    }\n-\n-    \/**\n-     * Close the native handle or fd.\n-     *\/\n-    @Override\n-    protected void performCleanup() {\n-        try {\n-            cleanupClose0(fd);\n-        } catch (IOException ioe) {\n-            throw new UncheckedIOException(\"close\", ioe);\n-        } finally {\n-            if (!stream) {\n-                ResourceManager.afterUdpClose();\n-            }\n-        }\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/java\/net\/SocketCleanable.java","additions":0,"deletions":119,"binary":false,"changes":119,"status":"deleted"},{"patch":"@@ -32,2 +32,0 @@\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n@@ -37,1 +35,0 @@\n-import sun.net.NetProperties;\n@@ -46,17 +43,0 @@\n- * @implNote Client and server sockets created with the {@code Socket} and\n- * {@code SocketServer} public constructors create a system-default\n- * {@code SocketImpl}. The JDK historically used a {@code SocketImpl}\n- * implementation type named \"PlainSocketImpl\" that has since been replaced by a\n- * newer implementation. The JDK continues to ship with the older implementation\n- * to allow code to run that depends on unspecified behavior that differs between\n- * the old and new implementations. The old implementation will be used if the\n- * Java virtual machine is started with the system property {@systemProperty\n- * jdk.net.usePlainSocketImpl} set to use the old implementation. It may also be\n- * set in the JDK's network configuration file, located in {@code\n- * ${java.home}\/conf\/net.properties}. The value of the property is the string\n- * representation of a boolean. If set without a value then it defaults to {@code\n- * true}, hence running with {@code -Djdk.net.usePlainSocketImpl} or {@code\n- * -Djdk.net.usePlainSocketImpl=true} will configure the Java virtual machine\n- * to use the old implementation. The property and old implementation will be\n- * removed in a future version.\n- *\n@@ -66,8 +46,0 @@\n-    private static final boolean USE_PLAINSOCKETIMPL = usePlainSocketImpl();\n-\n-    private static boolean usePlainSocketImpl() {\n-        PrivilegedAction<String> pa = () -> NetProperties.get(\"jdk.net.usePlainSocketImpl\");\n-        @SuppressWarnings(\"removal\")\n-        String s = AccessController.doPrivileged(pa);\n-        return (s != null) && !s.equalsIgnoreCase(\"false\");\n-    }\n@@ -80,5 +52,1 @@\n-        if (USE_PLAINSOCKETIMPL) {\n-            return (S) new PlainSocketImpl(server);\n-        } else {\n-            return (S) new NioSocketImpl(server);\n-        }\n+        return (S) new NioSocketImpl(server);\n","filename":"src\/java.base\/share\/classes\/java\/net\/SocketImpl.java","additions":1,"deletions":33,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -1,250 +0,0 @@\n-\/*\n- * Copyright (c) 1995, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.net;\n-\n-import java.io.FileDescriptor;\n-import java.io.FileInputStream;\n-import java.io.IOException;\n-import java.nio.channels.FileChannel;\n-\n-import sun.net.ConnectionResetException;\n-\n-\/**\n- * This stream extends FileInputStream to implement a\n- * SocketInputStream. Note that this class should <b>NOT<\/b> be\n- * public.\n- *\n- * @author      Jonathan Payne\n- * @author      Arthur van Hoff\n- *\/\n-class SocketInputStream extends FileInputStream {\n-    static {\n-        init();\n-    }\n-\n-    private boolean eof;\n-    private AbstractPlainSocketImpl impl = null;\n-    private byte temp[];\n-\n-    \/**\n-     * Creates a new SocketInputStream. Can only be called\n-     * by a Socket. This method needs to hang on to the owner Socket so\n-     * that the fd will not be closed.\n-     * @param impl the implemented socket input stream\n-     *\/\n-    SocketInputStream(AbstractPlainSocketImpl impl) throws IOException {\n-        super(impl.getFileDescriptor());\n-        this.impl = impl;\n-    }\n-\n-    \/**\n-     * Returns the unique {@link java.nio.channels.FileChannel FileChannel}\n-     * object associated with this file input stream.<\/p>\n-     *\n-     * The {@code getChannel} method of {@code SocketInputStream}\n-     * returns {@code null} since it is a socket based stream.<\/p>\n-     *\n-     * @return  the file channel associated with this file input stream\n-     *\n-     * @since 1.4\n-     *\/\n-    public final FileChannel getChannel() {\n-        return null;\n-    }\n-\n-    \/**\n-     * Reads into an array of bytes at the specified offset using\n-     * the received socket primitive.\n-     * @param fd the FileDescriptor\n-     * @param b the buffer into which the data is read\n-     * @param off the start offset of the data\n-     * @param len the maximum number of bytes read\n-     * @param timeout the read timeout in ms\n-     * @return the actual number of bytes read, -1 is\n-     *          returned when the end of the stream is reached.\n-     * @throws    IOException If an I\/O error has occurred.\n-     *\/\n-    private native int socketRead0(FileDescriptor fd,\n-                                   byte b[], int off, int len,\n-                                   int timeout)\n-        throws IOException;\n-\n-    \/\/ wrap native call to allow instrumentation\n-    \/**\n-     * Reads into an array of bytes at the specified offset using\n-     * the received socket primitive.\n-     * @param fd the FileDescriptor\n-     * @param b the buffer into which the data is read\n-     * @param off the start offset of the data\n-     * @param len the maximum number of bytes read\n-     * @param timeout the read timeout in ms\n-     * @return the actual number of bytes read, -1 is\n-     *          returned when the end of the stream is reached.\n-     * @throws    IOException If an I\/O error has occurred.\n-     *\/\n-    private int socketRead(FileDescriptor fd,\n-                           byte b[], int off, int len,\n-                           int timeout)\n-        throws IOException {\n-        return socketRead0(fd, b, off, len, timeout);\n-    }\n-\n-    \/**\n-     * Reads into a byte array data from the socket.\n-     * @param b the buffer into which the data is read\n-     * @return the actual number of bytes read, -1 is\n-     *          returned when the end of the stream is reached.\n-     * @throws    IOException If an I\/O error has occurred.\n-     *\/\n-    public int read(byte b[]) throws IOException {\n-        return read(b, 0, b.length);\n-    }\n-\n-    \/**\n-     * Reads into a byte array <i>b<\/i> at offset <i>off<\/i>,\n-     * <i>length<\/i> bytes of data.\n-     * @param b the buffer into which the data is read\n-     * @param off the start offset of the data\n-     * @param length the maximum number of bytes read\n-     * @return the actual number of bytes read, -1 is\n-     *          returned when the end of the stream is reached.\n-     * @throws    IOException If an I\/O error has occurred.\n-     *\/\n-    public int read(byte b[], int off, int length) throws IOException {\n-        return read(b, off, length, impl.getTimeout());\n-    }\n-\n-    int read(byte b[], int off, int length, int timeout) throws IOException {\n-        int n;\n-\n-        \/\/ EOF already encountered\n-        if (eof) {\n-            return -1;\n-        }\n-\n-        \/\/ connection reset\n-        if (impl.isConnectionReset()) {\n-            throw new SocketException(\"Connection reset\");\n-        }\n-\n-        \/\/ bounds check\n-        if (length <= 0 || off < 0 || length > b.length - off) {\n-            if (length == 0) {\n-                return 0;\n-            }\n-            throw new ArrayIndexOutOfBoundsException(\"length == \" + length\n-                    + \" off == \" + off + \" buffer length == \" + b.length);\n-        }\n-\n-        \/\/ acquire file descriptor and do the read\n-        FileDescriptor fd = impl.acquireFD();\n-        try {\n-            n = socketRead(fd, b, off, length, timeout);\n-            if (n > 0) {\n-                return n;\n-            }\n-        } catch (ConnectionResetException rstExc) {\n-            impl.setConnectionReset();\n-        } finally {\n-            impl.releaseFD();\n-        }\n-\n-        \/*\n-         * If we get here we are at EOF, the socket has been closed,\n-         * or the connection has been reset.\n-         *\/\n-        if (impl.isClosedOrPending()) {\n-            throw new SocketException(\"Socket closed\");\n-        }\n-        if (impl.isConnectionReset()) {\n-            throw new SocketException(\"Connection reset\");\n-        }\n-        eof = true;\n-        return -1;\n-    }\n-\n-    \/**\n-     * Reads a single byte from the socket.\n-     *\/\n-    public int read() throws IOException {\n-        if (eof) {\n-            return -1;\n-        }\n-        temp = new byte[1];\n-        int n = read(temp, 0, 1);\n-        if (n <= 0) {\n-            return -1;\n-        }\n-        return temp[0] & 0xff;\n-    }\n-\n-    \/**\n-     * Skips n bytes of input.\n-     * @param numbytes the number of bytes to skip\n-     * @return  the actual number of bytes skipped.\n-     * @throws    IOException If an I\/O error has occurred.\n-     *\/\n-    public long skip(long numbytes) throws IOException {\n-        if (numbytes <= 0) {\n-            return 0;\n-        }\n-        long n = numbytes;\n-        int buflen = (int) Math.min(1024, n);\n-        byte data[] = new byte[buflen];\n-        while (n > 0) {\n-            int r = read(data, 0, (int) Math.min((long) buflen, n));\n-            if (r < 0) {\n-                break;\n-            }\n-            n -= r;\n-        }\n-        return numbytes - n;\n-    }\n-\n-    \/**\n-     * Returns the number of bytes that can be read without blocking.\n-     * @return the number of immediately available bytes\n-     *\/\n-    public int available() throws IOException {\n-        int available = impl.available();\n-        return eof ? 0 : available;\n-    }\n-\n-    void setEOF(boolean eof) {\n-        this.eof = eof;\n-    }\n-\n-    public void close() throws IOException {\n-        \/\/ No longer used. Socket.getInputStream returns an\n-        \/\/ InputStream which calls Socket.close directly\n-        assert false;\n-    }\n-\n-    \/**\n-     * Perform class load-time initializations.\n-     *\/\n-    private static native void init();\n-}\n","filename":"src\/java.base\/share\/classes\/java\/net\/SocketInputStream.java","additions":0,"deletions":250,"binary":false,"changes":250,"status":"deleted"},{"patch":"@@ -1,161 +0,0 @@\n-\/*\n- * Copyright (c) 1995, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.net;\n-\n-import java.io.FileDescriptor;\n-import java.io.FileOutputStream;\n-import java.io.IOException;\n-import java.nio.channels.FileChannel;\n-\n-\/**\n- * This stream extends FileOutputStream to implement a\n- * SocketOutputStream. Note that this class should <b>NOT<\/b> be\n- * public.\n- *\n- * @author      Jonathan Payne\n- * @author      Arthur van Hoff\n- *\/\n-class SocketOutputStream extends FileOutputStream {\n-    static {\n-        init();\n-    }\n-\n-    private AbstractPlainSocketImpl impl = null;\n-    private byte temp[] = new byte[1];\n-\n-    \/**\n-     * Creates a new SocketOutputStream. Can only be called\n-     * by a Socket. This method needs to hang on to the owner Socket so\n-     * that the fd will not be closed.\n-     * @param impl the socket output stream implemented\n-     *\/\n-    SocketOutputStream(AbstractPlainSocketImpl impl) throws IOException {\n-        super(impl.getFileDescriptor());\n-        this.impl = impl;\n-    }\n-\n-    \/**\n-     * Returns the unique {@link java.nio.channels.FileChannel FileChannel}\n-     * object associated with this file output stream. <\/p>\n-     *\n-     * The {@code getChannel} method of {@code SocketOutputStream}\n-     * returns {@code null} since it is a socket based stream.<\/p>\n-     *\n-     * @return  the file channel associated with this file output stream\n-     *\n-     * @since 1.4\n-     *\/\n-    public final FileChannel getChannel() {\n-        return null;\n-    }\n-\n-    \/**\n-     * Writes to the socket.\n-     * @param fd the FileDescriptor\n-     * @param b the data to be written\n-     * @param off the start offset in the data\n-     * @param len the number of bytes that are written\n-     * @throws    IOException If an I\/O error has occurred.\n-     *\/\n-    private native void socketWrite0(FileDescriptor fd, byte[] b, int off,\n-                                     int len) throws IOException;\n-\n-    \/**\n-     * Writes to the socket with appropriate locking of the\n-     * FileDescriptor.\n-     * @param b the data to be written\n-     * @param off the start offset in the data\n-     * @param len the number of bytes that are written\n-     * @throws    IOException If an I\/O error has occurred.\n-     *\/\n-    private void socketWrite(byte b[], int off, int len) throws IOException {\n-\n-\n-        if (len <= 0 || off < 0 || len > b.length - off) {\n-            if (len == 0) {\n-                return;\n-            }\n-            throw new ArrayIndexOutOfBoundsException(\"len == \" + len\n-                    + \" off == \" + off + \" buffer length == \" + b.length);\n-        }\n-\n-        FileDescriptor fd = impl.acquireFD();\n-        try {\n-            socketWrite0(fd, b, off, len);\n-        } catch (SocketException se) {\n-            if (impl.isClosedOrPending()) {\n-                throw new SocketException(\"Socket closed\");\n-            } else {\n-                throw se;\n-            }\n-        } finally {\n-            impl.releaseFD();\n-        }\n-    }\n-\n-    \/**\n-     * Writes a byte to the socket.\n-     * @param b the data to be written\n-     * @throws    IOException If an I\/O error has occurred.\n-     *\/\n-    public void write(int b) throws IOException {\n-        temp[0] = (byte)b;\n-        socketWrite(temp, 0, 1);\n-    }\n-\n-    \/**\n-     * Writes the contents of the buffer <i>b<\/i> to the socket.\n-     * @param b the data to be written\n-     * @throws    SocketException If an I\/O error has occurred.\n-     *\/\n-    public void write(byte b[]) throws IOException {\n-        socketWrite(b, 0, b.length);\n-    }\n-\n-    \/**\n-     * Writes <i>length<\/i> bytes from buffer <i>b<\/i> starting at\n-     * offset <i>len<\/i>.\n-     * @param b the data to be written\n-     * @param off the start offset in the data\n-     * @param len the number of bytes that are written\n-     * @throws    SocketException If an I\/O error has occurred.\n-     *\/\n-    public void write(byte b[], int off, int len) throws IOException {\n-        socketWrite(b, off, len);\n-    }\n-\n-    public void close() throws IOException {\n-        \/\/ No longer used. Socket.getOutputStream returns an\n-        \/\/ OutputStream which calls Socket.close directly\n-        assert false;\n-    }\n-\n-    \/**\n-     * Perform class load-time initializations.\n-     *\/\n-    private static native void init();\n-\n-}\n","filename":"src\/java.base\/share\/classes\/java\/net\/SocketOutputStream.java","additions":0,"deletions":161,"binary":false,"changes":161,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2010, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -255,1 +255,1 @@\n-\/\/ Note that at least JDK 1.1 has a low level \"plainSocketImpl\" that\n+\/\/ Note that at least JDK 1.1 has a low level \"SocketImpl\" that\n","filename":"src\/java.base\/share\/classes\/javax\/net\/SocketFactory.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021 Oracle and\/or its affiliates. All rights reserved.\n@@ -67,2 +67,3 @@\n- * This implementation attempts to be compatible with legacy PlainSocketImpl,\n- * including behavior and exceptions that are not specified by SocketImpl.\n+ * This implementation attempts to be compatible with legacy PlainSocketImpl\n+ * (removed in JDK18), including behavior and exceptions that are not specified by\n+ * SocketImpl.\n@@ -645,1 +646,1 @@\n-            \/\/ compatibility with PlainSocketImpl. When binding to 0.0.0.0\n+            \/\/ compatibility with SocketImpl. When binding to 0.0.0.0\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/NioSocketImpl.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1,60 +0,0 @@\n-\/*\n- * Copyright (c) 1997, 2002, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"java_net_DatagramPacket.h\"\n-#include \"net_util.h\"\n-\n-\/************************************************************************\n- * DatagramPacket\n- *\/\n-\n-jfieldID dp_addressID;\n-jfieldID dp_portID;\n-jfieldID dp_bufID;\n-jfieldID dp_offsetID;\n-jfieldID dp_lengthID;\n-jfieldID dp_bufLengthID;\n-\n-\/*\n- * Class:     java_net_DatagramPacket\n- * Method:    init\n- * Signature: ()V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_DatagramPacket_init (JNIEnv *env, jclass cls) {\n-    dp_addressID = (*env)->GetFieldID(env, cls, \"address\",\n-                                      \"Ljava\/net\/InetAddress;\");\n-    CHECK_NULL(dp_addressID);\n-    dp_portID = (*env)->GetFieldID(env, cls, \"port\", \"I\");\n-    CHECK_NULL(dp_portID);\n-    dp_bufID = (*env)->GetFieldID(env, cls, \"buf\", \"[B\");\n-    CHECK_NULL(dp_bufID);\n-    dp_offsetID = (*env)->GetFieldID(env, cls, \"offset\", \"I\");\n-    CHECK_NULL(dp_offsetID);\n-    dp_lengthID = (*env)->GetFieldID(env, cls, \"length\", \"I\");\n-    CHECK_NULL(dp_lengthID);\n-    dp_bufLengthID = (*env)->GetFieldID(env, cls, \"bufLength\", \"I\");\n-    CHECK_NULL(dp_bufLengthID);\n-}\n","filename":"src\/java.base\/share\/native\/libnet\/DatagramPacket.c","additions":0,"deletions":60,"binary":false,"changes":60,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,0 @@\n- * i.e. psi_timeoutID is PlainSocketImpl's timeout field's ID.\n@@ -87,7 +86,0 @@\n-\/* PlainSocketImpl fields *\/\n-extern jfieldID psi_timeoutID;\n-extern jfieldID psi_fdID;\n-extern jfieldID psi_addressID;\n-extern jfieldID psi_portID;\n-extern jfieldID psi_localportID;\n-\n","filename":"src\/java.base\/share\/native\/libnet\/net_util.h","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1,75 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.net;\n-\n-import sun.security.action.GetPropertyAction;\n-\n-\/**\n- * This class defines a factory for creating DatagramSocketImpls. It defaults\n- * to creating plain DatagramSocketImpls, but may create other DatagramSocketImpls\n- * by setting the impl.prefix system property.\n- *\n- * @author Chris Hegarty\n- *\/\n-\n-class DefaultDatagramSocketImplFactory {\n-    static Class<?> prefixImplClass = null;\n-\n-    static {\n-        String prefix = null;\n-        try {\n-            prefix = GetPropertyAction.privilegedGetProperty(\"impl.prefix\");\n-            if (prefix != null)\n-                prefixImplClass = Class.forName(\"java.net.\"+prefix+\"DatagramSocketImpl\");\n-        } catch (Exception e) {\n-            System.err.println(\"Can't find class: java.net.\" +\n-                                prefix +\n-                                \"DatagramSocketImpl: check impl.prefix property\");\n-            \/\/prefixImplClass = null;\n-        }\n-    }\n-\n-    \/**\n-     * Creates a new <code>DatagramSocketImpl<\/code> instance.\n-     *\n-     * @param   isMulticast     true if this impl if for a MutlicastSocket\n-     * @return  a new instance of a <code>DatagramSocketImpl<\/code>.\n-     *\/\n-    static DatagramSocketImpl createDatagramSocketImpl(boolean isMulticast \/*unused on unix*\/)\n-        throws SocketException {\n-        if (prefixImplClass != null) {\n-            try {\n-                @SuppressWarnings(\"deprecation\")\n-                DatagramSocketImpl result = (DatagramSocketImpl)prefixImplClass.newInstance();\n-                return result;\n-            } catch (Exception e) {\n-                throw new SocketException(\"can't instantiate DatagramSocketImpl\");\n-            }\n-        } else {\n-            return new java.net.PlainDatagramSocketImpl(isMulticast);\n-        }\n-    }\n-}\n","filename":"src\/java.base\/unix\/classes\/java\/net\/DefaultDatagramSocketImplFactory.java","additions":0,"deletions":75,"binary":false,"changes":75,"status":"deleted"},{"patch":"@@ -1,108 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package java.net;\n-\n-import java.io.IOException;\n-import java.util.Set;\n-import java.util.HashSet;\n-import sun.net.ext.ExtendedSocketOptions;\n-\n-\/*\n- * On Unix systems we simply delegate to native methods.\n- *\n- * @author Chris Hegarty\n- *\/\n-\n-class PlainDatagramSocketImpl extends AbstractPlainDatagramSocketImpl\n-{\n-    PlainDatagramSocketImpl(boolean isMulticast) {\n-        super(isMulticast);\n-    }\n-\n-    static {\n-        init();\n-    }\n-\n-    protected void socketSetOption(int opt, Object val) throws SocketException {\n-        if (opt == SocketOptions.SO_REUSEPORT &&\n-            !supportedOptions().contains(StandardSocketOptions.SO_REUSEPORT)) {\n-            throw new UnsupportedOperationException(\"unsupported option\");\n-        }\n-        try {\n-            socketSetOption0(opt, val);\n-        } catch (SocketException se) {\n-            if (!connected)\n-                throw se;\n-        }\n-    }\n-\n-    protected synchronized native void bind0(int lport, InetAddress laddr)\n-        throws SocketException;\n-\n-    protected native void send0(DatagramPacket p) throws IOException;\n-\n-    protected synchronized native int peek(InetAddress i) throws IOException;\n-\n-    protected synchronized native int peekData(DatagramPacket p) throws IOException;\n-\n-    protected synchronized native void receive0(DatagramPacket p)\n-        throws IOException;\n-\n-    protected native void setTimeToLive(int ttl) throws IOException;\n-\n-    protected native int getTimeToLive() throws IOException;\n-\n-    @Deprecated\n-    protected native void setTTL(byte ttl) throws IOException;\n-\n-    @Deprecated\n-    protected native byte getTTL() throws IOException;\n-\n-    protected native void join(InetAddress inetaddr, NetworkInterface netIf)\n-        throws IOException;\n-\n-    protected native void leave(InetAddress inetaddr, NetworkInterface netIf)\n-        throws IOException;\n-\n-    protected native void datagramSocketCreate() throws SocketException;\n-\n-    protected native void datagramSocketClose();\n-\n-    protected native void socketSetOption0(int opt, Object val)\n-        throws SocketException;\n-\n-    protected native Object socketGetOption(int opt) throws SocketException;\n-\n-    protected native void connect0(InetAddress address, int port) throws SocketException;\n-\n-    protected native void disconnect0(int family);\n-\n-    native int dataAvailable();\n-\n-    \/**\n-     * Perform class load-time initializations.\n-     *\/\n-    private static native void init();\n-}\n","filename":"src\/java.base\/unix\/classes\/java\/net\/PlainDatagramSocketImpl.java","additions":0,"deletions":108,"binary":false,"changes":108,"status":"deleted"},{"patch":"@@ -1,94 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package java.net;\n-\n-import java.io.IOException;\n-import java.util.Set;\n-import java.util.HashSet;\n-import sun.net.ext.ExtendedSocketOptions;\n-\n-\/*\n- * On Unix systems we simply delegate to native methods.\n- *\n- * @author Chris Hegarty\n- *\/\n-\n-class PlainSocketImpl extends AbstractPlainSocketImpl\n-{\n-    static {\n-        initProto();\n-    }\n-\n-    \/**\n-     * Constructs an empty instance.\n-     *\/\n-    PlainSocketImpl(boolean isServer) {\n-        super(isServer);\n-    }\n-\n-    protected void socketSetOption(int opt, boolean b, Object val) throws SocketException {\n-        if (opt == SocketOptions.SO_REUSEPORT &&\n-            !supportedOptions().contains(StandardSocketOptions.SO_REUSEPORT)) {\n-            throw new UnsupportedOperationException(\"unsupported option\");\n-        }\n-        try {\n-            socketSetOption0(opt, b, val);\n-        } catch (SocketException se) {\n-            if (!isConnected)\n-                throw se;\n-        }\n-    }\n-\n-    void socketCreate(boolean stream) throws IOException {\n-        socketCreate(stream, isServer);\n-    }\n-\n-    native void socketCreate(boolean stream, boolean isServer) throws IOException;\n-\n-    native void socketConnect(InetAddress address, int port, int timeout)\n-        throws IOException;\n-\n-    native void socketBind(InetAddress address, int port)\n-        throws IOException;\n-\n-    native void socketListen(int count) throws IOException;\n-\n-    native void socketAccept(SocketImpl s) throws IOException;\n-\n-    native int socketAvailable() throws IOException;\n-\n-    native void socketClose0(boolean useDeferredClose) throws IOException;\n-\n-    native void socketShutdown(int howto) throws IOException;\n-\n-    static native void initProto();\n-\n-    native void socketSetOption0(int cmd, boolean on, Object value)\n-        throws SocketException;\n-\n-    native int socketGetOption(int opt, Object iaContainerObj) throws SocketException;\n-\n-    native void socketSendUrgentData(int data) throws IOException;\n-}\n","filename":"src\/java.base\/unix\/classes\/java\/net\/PlainSocketImpl.java","additions":0,"deletions":94,"binary":false,"changes":94,"status":"deleted"},{"patch":"@@ -1,2179 +0,0 @@\n-\/*\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-#include <errno.h>\n-#include <stdlib.h>\n-#include <string.h>\n-#include <sys\/ioctl.h>\n-\n-#include \"net_util.h\"\n-\n-#include \"java_net_PlainDatagramSocketImpl.h\"\n-#include \"java_net_InetAddress.h\"\n-#include \"java_net_NetworkInterface.h\"\n-#include \"java_net_SocketOptions.h\"\n-\n-#ifdef __linux__\n-#define IPV6_MULTICAST_IF 17\n-#ifndef SO_BSDCOMPAT\n-#define SO_BSDCOMPAT  14\n-#endif\n-\/**\n- * IP_MULTICAST_ALL has been supported since kernel version 2.6.31\n- * but we may be building on a machine that is older than that.\n- *\/\n-#ifndef IP_MULTICAST_ALL\n-#define IP_MULTICAST_ALL      49\n-#endif\n-#endif  \/\/  __linux__\n-\n-#ifdef __APPLE__\n-#define IPV4_SNDBUF_LIMIT 65507\n-#define IPV6_SNDBUF_LIMIT 65527\n-#endif  \/\/ __APPLE__\n-\n-#ifndef IPTOS_TOS_MASK\n-#define IPTOS_TOS_MASK 0x1e\n-#endif\n-#ifndef IPTOS_PREC_MASK\n-#define IPTOS_PREC_MASK 0xe0\n-#endif\n-\n-\/************************************************************************\n- * PlainDatagramSocketImpl\n- *\/\n-\n-static jfieldID IO_fd_fdID;\n-\n-static jfieldID pdsi_fdID;\n-static jfieldID pdsi_timeoutID;\n-static jfieldID pdsi_trafficClassID;\n-static jfieldID pdsi_localPortID;\n-static jfieldID pdsi_connected;\n-static jfieldID pdsi_connectedAddress;\n-static jfieldID pdsi_connectedPort;\n-\n-\/*\n- * Returns a java.lang.Integer based on 'i'\n- *\/\n-static jobject createInteger(JNIEnv *env, int i) {\n-    static jclass i_class;\n-    static jmethodID i_ctrID;\n-\n-    if (i_class == NULL) {\n-        jclass c = (*env)->FindClass(env, \"java\/lang\/Integer\");\n-        CHECK_NULL_RETURN(c, NULL);\n-        i_ctrID = (*env)->GetMethodID(env, c, \"<init>\", \"(I)V\");\n-        CHECK_NULL_RETURN(i_ctrID, NULL);\n-        i_class = (*env)->NewGlobalRef(env, c);\n-        CHECK_NULL_RETURN(i_class, NULL);\n-    }\n-\n-    return (*env)->NewObject(env, i_class, i_ctrID, i);\n-}\n-\n-\/*\n- * Returns a java.lang.Boolean based on 'b'\n- *\/\n-static jobject createBoolean(JNIEnv *env, int b) {\n-    static jclass b_class;\n-    static jmethodID b_ctrID;\n-\n-    if (b_class == NULL) {\n-        jclass c = (*env)->FindClass(env, \"java\/lang\/Boolean\");\n-        CHECK_NULL_RETURN(c, NULL);\n-        b_ctrID = (*env)->GetMethodID(env, c, \"<init>\", \"(Z)V\");\n-        CHECK_NULL_RETURN(b_ctrID, NULL);\n-        b_class = (*env)->NewGlobalRef(env, c);\n-        CHECK_NULL_RETURN(b_class, NULL);\n-    }\n-\n-    return (*env)->NewObject(env, b_class, b_ctrID, (jboolean)(b != 0));\n-}\n-\n-\/*\n- * Returns the fd for a PlainDatagramSocketImpl or -1\n- * if closed.\n- *\/\n-static int getFD(JNIEnv *env, jobject this) {\n-    jobject fdObj = (*env)->GetObjectField(env, this, pdsi_fdID);\n-    if (fdObj == NULL) {\n-        return -1;\n-    }\n-    return (*env)->GetIntField(env, fdObj, IO_fd_fdID);\n-}\n-\n-\/*\n- * Class:     java_net_PlainDatagramSocketImpl\n- * Method:    init\n- * Signature: ()V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_PlainDatagramSocketImpl_init(JNIEnv *env, jclass cls) {\n-\n-    pdsi_fdID = (*env)->GetFieldID(env, cls, \"fd\",\n-                                   \"Ljava\/io\/FileDescriptor;\");\n-    CHECK_NULL(pdsi_fdID);\n-    pdsi_timeoutID = (*env)->GetFieldID(env, cls, \"timeout\", \"I\");\n-    CHECK_NULL(pdsi_timeoutID);\n-    pdsi_trafficClassID = (*env)->GetFieldID(env, cls, \"trafficClass\", \"I\");\n-    CHECK_NULL(pdsi_trafficClassID);\n-    pdsi_localPortID = (*env)->GetFieldID(env, cls, \"localPort\", \"I\");\n-    CHECK_NULL(pdsi_localPortID);\n-    pdsi_connected = (*env)->GetFieldID(env, cls, \"connected\", \"Z\");\n-    CHECK_NULL(pdsi_connected);\n-    pdsi_connectedAddress = (*env)->GetFieldID(env, cls, \"connectedAddress\",\n-                                               \"Ljava\/net\/InetAddress;\");\n-    CHECK_NULL(pdsi_connectedAddress);\n-    pdsi_connectedPort = (*env)->GetFieldID(env, cls, \"connectedPort\", \"I\");\n-    CHECK_NULL(pdsi_connectedPort);\n-\n-    IO_fd_fdID = NET_GetFileDescriptorID(env);\n-    CHECK_NULL(IO_fd_fdID);\n-\n-    initInetAddressIDs(env);\n-    JNU_CHECK_EXCEPTION(env);\n-    Java_java_net_NetworkInterface_init(env, 0);\n-}\n-\n-\/*\n- * Class:     java_net_PlainDatagramSocketImpl\n- * Method:    bind\n- * Signature: (ILjava\/net\/InetAddress;)V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_PlainDatagramSocketImpl_bind0(JNIEnv *env, jobject this,\n-                                            jint localport, jobject iaObj) {\n-    \/* fdObj is the FileDescriptor field on this *\/\n-    jobject fdObj = (*env)->GetObjectField(env, this, pdsi_fdID);\n-    \/* fd is an int field on fdObj *\/\n-    int fd;\n-    int len = 0;\n-    SOCKETADDRESS sa;\n-    socklen_t slen = sizeof(SOCKETADDRESS);\n-\n-    if (IS_NULL(fdObj)) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                        \"Socket closed\");\n-        return;\n-    } else {\n-        fd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);\n-    }\n-\n-    if (IS_NULL(iaObj)) {\n-        JNU_ThrowNullPointerException(env, \"iaObj is null.\");\n-        return;\n-    }\n-\n-    \/* bind *\/\n-    if (NET_InetAddressToSockaddr(env, iaObj, localport, &sa, &len,\n-                                  JNI_TRUE) != 0) {\n-      return;\n-    }\n-\n-    if (NET_Bind(fd, &sa, len) < 0)  {\n-        if (errno == EADDRINUSE || errno == EADDRNOTAVAIL ||\n-            errno == EPERM || errno == EACCES) {\n-            NET_ThrowByNameWithLastError(env, JNU_JAVANETPKG \"BindException\",\n-                            \"Bind failed\");\n-        } else {\n-            JNU_ThrowByNameWithMessageAndLastError\n-                (env, JNU_JAVANETPKG \"SocketException\", \"Bind failed\");\n-        }\n-        return;\n-    }\n-\n-    \/* initialize the local port *\/\n-    if (localport == 0) {\n-        \/* Now that we're a connected socket, let's extract the port number\n-         * that the system chose for us and store it in the Socket object.\n-         *\/\n-        if (getsockname(fd, &sa.sa, &slen) == -1) {\n-            JNU_ThrowByNameWithMessageAndLastError\n-                (env, JNU_JAVANETPKG \"SocketException\", \"Error getting socket name\");\n-            return;\n-        }\n-\n-        localport = NET_GetPortFromSockaddr(&sa);\n-\n-        (*env)->SetIntField(env, this, pdsi_localPortID, localport);\n-    } else {\n-        (*env)->SetIntField(env, this, pdsi_localPortID, localport);\n-    }\n-}\n-\n-\/*\n- * Class:     java_net_PlainDatagramSocketImpl\n- * Method:    connect0\n- * Signature: (Ljava\/net\/InetAddress;I)V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_PlainDatagramSocketImpl_connect0(JNIEnv *env, jobject this,\n-                                               jobject address, jint port) {\n-    \/* The object's field *\/\n-    jobject fdObj = (*env)->GetObjectField(env, this, pdsi_fdID);\n-    \/* The fdObj'fd *\/\n-    jint fd;\n-    \/* The packetAddress address, family and port *\/\n-    SOCKETADDRESS rmtaddr;\n-    int len = 0;\n-\n-    if (IS_NULL(fdObj)) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                        \"Socket closed\");\n-        return;\n-    }\n-    fd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);\n-\n-    if (IS_NULL(address)) {\n-        JNU_ThrowNullPointerException(env, \"address\");\n-        return;\n-    }\n-\n-    if (NET_InetAddressToSockaddr(env, address, port, &rmtaddr, &len,\n-                                  JNI_TRUE) != 0) {\n-      return;\n-    }\n-\n-    if (NET_Connect(fd, &rmtaddr.sa, len) == -1) {\n-        NET_ThrowByNameWithLastError(env, JNU_JAVANETPKG \"ConnectException\",\n-                        \"Connect failed\");\n-    }\n-}\n-\n-\/*\n- * Class:     java_net_PlainDatagramSocketImpl\n- * Method:    disconnect0\n- * Signature: ()V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_PlainDatagramSocketImpl_disconnect0(JNIEnv *env, jobject this, jint family) {\n-    \/* The object's field *\/\n-    jobject fdObj = (*env)->GetObjectField(env, this, pdsi_fdID);\n-    \/* The fdObj'fd *\/\n-    jint fd;\n-\n-#if defined(__linux__) || defined(_ALLBSD_SOURCE)\n-    SOCKETADDRESS addr;\n-    socklen_t len;\n-#if defined(__linux__)\n-    int localPort = 0;\n-#endif\n-#endif\n-\n-    if (IS_NULL(fdObj)) {\n-        return;\n-    }\n-    fd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);\n-\n-#if defined(__linux__) || defined(_ALLBSD_SOURCE)\n-    memset(&addr, 0, sizeof(addr));\n-    if (ipv6_available()) {\n-        addr.sa6.sin6_family = AF_UNSPEC;\n-        len = sizeof(struct sockaddr_in6);\n-    } else {\n-        addr.sa4.sin_family = AF_UNSPEC;\n-        len = sizeof(struct sockaddr_in);\n-    }\n-    NET_Connect(fd, &addr.sa, len);\n-\n-#if defined(__linux__)\n-    if (getsockname(fd, &addr.sa, &len) == -1)\n-        return;\n-\n-    localPort = NET_GetPortFromSockaddr(&addr);\n-    if (localPort == 0) {\n-        localPort = (*env)->GetIntField(env, this, pdsi_localPortID);\n-        if (addr.sa.sa_family == AF_INET6) {\n-            addr.sa6.sin6_port = htons(localPort);\n-        } else {\n-            addr.sa4.sin_port = htons(localPort);\n-        }\n-\n-        NET_Bind(fd, &addr, len);\n-    }\n-\n-#endif\n-#else\n-    NET_Connect(fd, 0, 0);\n-#endif\n-}\n-\n-\/*\n- * Class:     java_net_PlainDatagramSocketImpl\n- * Method:    send0\n- * Signature: (Ljava\/net\/DatagramPacket;)V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_PlainDatagramSocketImpl_send0(JNIEnv *env, jobject this,\n-                                           jobject packet) {\n-\n-    char BUF[MAX_BUFFER_LEN];\n-    char *fullPacket = NULL;\n-    int ret, mallocedPacket = JNI_FALSE;\n-    \/* The object's field *\/\n-    jobject fdObj = (*env)->GetObjectField(env, this, pdsi_fdID);\n-    jint trafficClass = (*env)->GetIntField(env, this, pdsi_trafficClassID);\n-\n-    jbyteArray packetBuffer;\n-    jobject packetAddress;\n-    jint packetBufferOffset, packetBufferLen, packetPort;\n-    jboolean connected;\n-\n-    \/* The fdObj'fd *\/\n-    jint fd;\n-\n-    SOCKETADDRESS rmtaddr;\n-    struct sockaddr *rmtaddrP = 0;\n-    int len = 0;\n-\n-    if (IS_NULL(fdObj)) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                        \"Socket closed\");\n-        return;\n-    }\n-    fd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);\n-\n-    if (IS_NULL(packet)) {\n-        JNU_ThrowNullPointerException(env, \"packet\");\n-        return;\n-    }\n-\n-    connected = (*env)->GetBooleanField(env, this, pdsi_connected);\n-\n-    packetBuffer = (*env)->GetObjectField(env, packet, dp_bufID);\n-    packetAddress = (*env)->GetObjectField(env, packet, dp_addressID);\n-    if (IS_NULL(packetBuffer) || IS_NULL(packetAddress)) {\n-        JNU_ThrowNullPointerException(env, \"null buffer || null address\");\n-        return;\n-    }\n-\n-    packetBufferOffset = (*env)->GetIntField(env, packet, dp_offsetID);\n-    packetBufferLen = (*env)->GetIntField(env, packet, dp_lengthID);\n-\n-    \/\/ arg to NET_Sendto() null, if connected\n-    if (!connected) {\n-        packetPort = (*env)->GetIntField(env, packet, dp_portID);\n-        if (NET_InetAddressToSockaddr(env, packetAddress, packetPort, &rmtaddr,\n-                                      &len, JNI_TRUE) != 0) {\n-            return;\n-        }\n-        rmtaddrP = &rmtaddr.sa;\n-    }\n-\n-    if (packetBufferLen > MAX_BUFFER_LEN) {\n-        \/* When JNI-ifying the JDK's IO routines, we turned\n-         * reads and writes of byte arrays of size greater\n-         * than 2048 bytes into several operations of size 2048.\n-         * This saves a malloc()\/memcpy()\/free() for big\n-         * buffers.  This is OK for file IO and TCP, but that\n-         * strategy violates the semantics of a datagram protocol.\n-         * (one big send) != (several smaller sends).  So here\n-         * we *must* allocate the buffer.  Note it needn't be bigger\n-         * than 65,536 (0xFFFF), the max size of an IP packet.\n-         * Anything bigger should be truncated anyway.\n-         *\n-         * We may want to use a smarter allocation scheme at some\n-         * point.\n-         *\/\n-        if (packetBufferLen > MAX_PACKET_LEN) {\n-            packetBufferLen = MAX_PACKET_LEN;\n-        }\n-        fullPacket = (char *)malloc(packetBufferLen);\n-\n-        if (!fullPacket) {\n-            JNU_ThrowOutOfMemoryError(env, \"Send buffer native heap allocation failed\");\n-            return;\n-        } else {\n-            mallocedPacket = JNI_TRUE;\n-        }\n-    } else {\n-        fullPacket = &(BUF[0]);\n-    }\n-\n-    (*env)->GetByteArrayRegion(env, packetBuffer, packetBufferOffset, packetBufferLen,\n-                               (jbyte *)fullPacket);\n-    if (trafficClass != 0 && ipv6_available()) {\n-        NET_SetTrafficClass(&rmtaddr, trafficClass);\n-    }\n-\n-    \/*\n-     * Send the datagram.\n-     *\n-     * If we are connected it's possible that sendto will return\n-     * ECONNREFUSED indicating that an ICMP port unreachable has\n-     * received.\n-     *\/\n-    ret = NET_SendTo(fd, fullPacket, packetBufferLen, 0, rmtaddrP, len);\n-\n-    if (ret < 0) {\n-        if (errno == ECONNREFUSED) {\n-            JNU_ThrowByName(env, JNU_JAVANETPKG \"PortUnreachableException\",\n-                            \"ICMP Port Unreachable\");\n-        } else {\n-            JNU_ThrowIOExceptionWithLastError(env, \"sendto failed\");\n-        }\n-    }\n-\n-    if (mallocedPacket) {\n-        free(fullPacket);\n-    }\n-    return;\n-}\n-\n-\/*\n- * Class:     java_net_PlainDatagramSocketImpl\n- * Method:    peek\n- * Signature: (Ljava\/net\/InetAddress;)I\n- *\/\n-JNIEXPORT jint JNICALL\n-Java_java_net_PlainDatagramSocketImpl_peek(JNIEnv *env, jobject this,\n-                                           jobject addressObj) {\n-\n-    jobject fdObj = (*env)->GetObjectField(env, this, pdsi_fdID);\n-    jint timeout = (*env)->GetIntField(env, this, pdsi_timeoutID);\n-    jint fd;\n-    ssize_t n;\n-    SOCKETADDRESS rmtaddr;\n-    socklen_t slen = sizeof(SOCKETADDRESS);\n-    char buf[1];\n-    jint family;\n-    jobject iaObj;\n-    int port;\n-    if (IS_NULL(fdObj)) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", \"Socket closed\");\n-        return -1;\n-    } else {\n-        fd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);\n-    }\n-    if (IS_NULL(addressObj)) {\n-        JNU_ThrowNullPointerException(env, \"Null address in peek()\");\n-        return -1;\n-    }\n-    if (timeout) {\n-        int ret = NET_Timeout(env, fd, timeout, JVM_NanoTime(env, 0));\n-        if (ret == 0) {\n-            JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketTimeoutException\",\n-                            \"Peek timed out\");\n-            return ret;\n-        } else if (ret == -1) {\n-            if (errno == EBADF) {\n-                 JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", \"Socket closed\");\n-            } else if (errno == ENOMEM) {\n-                 JNU_ThrowOutOfMemoryError(env, \"NET_Timeout native heap allocation failed\");\n-            } else {\n-                 JNU_ThrowByNameWithMessageAndLastError\n-                     (env, JNU_JAVANETPKG \"SocketException\", \"Peek failed\");\n-            }\n-            return ret;\n-        }\n-    }\n-\n-    n = NET_RecvFrom(fd, buf, 1, MSG_PEEK, &rmtaddr.sa, &slen);\n-\n-    if (n == -1) {\n-        if (errno == ECONNREFUSED) {\n-            JNU_ThrowByName(env, JNU_JAVANETPKG \"PortUnreachableException\",\n-                            \"ICMP Port Unreachable\");\n-        } else {\n-            if (errno == EBADF) {\n-                 JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", \"Socket closed\");\n-            } else {\n-                 JNU_ThrowByNameWithMessageAndLastError\n-                     (env, JNU_JAVANETPKG \"SocketException\", \"Peek failed\");\n-            }\n-        }\n-        return 0;\n-    }\n-\n-    iaObj = NET_SockaddrToInetAddress(env, &rmtaddr, &port);\n-    family = getInetAddress_family(env, iaObj) == java_net_InetAddress_IPv4 ?\n-        AF_INET : AF_INET6;\n-    JNU_CHECK_EXCEPTION_RETURN(env, -1);\n-    if (family == AF_INET) { \/* this API can't handle IPV6 addresses *\/\n-        int address = getInetAddress_addr(env, iaObj);\n-        JNU_CHECK_EXCEPTION_RETURN(env, -1);\n-        setInetAddress_addr(env, addressObj, address);\n-        JNU_CHECK_EXCEPTION_RETURN(env, -1);\n-    }\n-    return port;\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_java_net_PlainDatagramSocketImpl_peekData(JNIEnv *env, jobject this,\n-                                           jobject packet) {\n-\n-    char BUF[MAX_BUFFER_LEN];\n-    char *fullPacket = NULL;\n-    int mallocedPacket = JNI_FALSE;\n-    jobject fdObj = (*env)->GetObjectField(env, this, pdsi_fdID);\n-    jint timeout = (*env)->GetIntField(env, this, pdsi_timeoutID);\n-    jbyteArray packetBuffer;\n-    jint packetBufferOffset, packetBufferLen;\n-    int fd;\n-    int n;\n-    SOCKETADDRESS rmtaddr;\n-    socklen_t slen = sizeof(SOCKETADDRESS);\n-    int port = -1;\n-\n-    if (IS_NULL(fdObj)) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                        \"Socket closed\");\n-        return -1;\n-    }\n-\n-    fd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);\n-\n-    if (IS_NULL(packet)) {\n-        JNU_ThrowNullPointerException(env, \"packet\");\n-        return -1;\n-    }\n-\n-    packetBuffer = (*env)->GetObjectField(env, packet, dp_bufID);\n-    if (IS_NULL(packetBuffer)) {\n-        JNU_ThrowNullPointerException(env, \"packet buffer\");\n-        return -1;\n-    }\n-    packetBufferOffset = (*env)->GetIntField(env, packet, dp_offsetID);\n-    packetBufferLen = (*env)->GetIntField(env, packet, dp_bufLengthID);\n-    if (timeout) {\n-        int ret = NET_Timeout(env, fd, timeout, JVM_NanoTime(env, 0));\n-        if (ret == 0) {\n-            JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketTimeoutException\",\n-                            \"Receive timed out\");\n-            return -1;\n-        } else if (ret == -1) {\n-            if (errno == ENOMEM) {\n-                JNU_ThrowOutOfMemoryError(env, \"NET_Timeout native heap allocation failed\");\n-#ifdef __linux__\n-            } else if (errno == EBADF) {\n-                JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", \"Socket closed\");\n-            } else {\n-                JNU_ThrowByNameWithMessageAndLastError\n-                    (env, JNU_JAVANETPKG \"SocketException\", \"Receive failed\");\n-#else\n-            } else {\n-                JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", \"Socket closed\");\n-#endif\n-            }\n-            return -1;\n-        }\n-    }\n-\n-    if (packetBufferLen > MAX_BUFFER_LEN) {\n-\n-        \/* When JNI-ifying the JDK's IO routines, we turned\n-         * reads and writes of byte arrays of size greater\n-         * than 2048 bytes into several operations of size 2048.\n-         * This saves a malloc()\/memcpy()\/free() for big\n-         * buffers.  This is OK for file IO and TCP, but that\n-         * strategy violates the semantics of a datagram protocol.\n-         * (one big send) != (several smaller sends).  So here\n-         * we *must* allocate the buffer.  Note it needn't be bigger\n-         * than 65,536 (0xFFFF), the max size of an IP packet.\n-         * anything bigger is truncated anyway.\n-         *\n-         * We may want to use a smarter allocation scheme at some\n-         * point.\n-         *\/\n-        if (packetBufferLen > MAX_PACKET_LEN) {\n-            packetBufferLen = MAX_PACKET_LEN;\n-        }\n-        fullPacket = (char *)malloc(packetBufferLen);\n-\n-        if (!fullPacket) {\n-            JNU_ThrowOutOfMemoryError(env, \"Peek buffer native heap allocation failed\");\n-            return -1;\n-        } else {\n-            mallocedPacket = JNI_TRUE;\n-        }\n-    } else {\n-        fullPacket = &(BUF[0]);\n-    }\n-\n-    n = NET_RecvFrom(fd, fullPacket, packetBufferLen, MSG_PEEK,\n-                     &rmtaddr.sa, &slen);\n-    \/* truncate the data if the packet's length is too small *\/\n-    if (n > packetBufferLen) {\n-        n = packetBufferLen;\n-    }\n-    if (n == -1) {\n-        (*env)->SetIntField(env, packet, dp_offsetID, 0);\n-        (*env)->SetIntField(env, packet, dp_lengthID, 0);\n-        if (errno == ECONNREFUSED) {\n-            JNU_ThrowByName(env, JNU_JAVANETPKG \"PortUnreachableException\",\n-                            \"ICMP Port Unreachable\");\n-        } else {\n-            if (errno == EBADF) {\n-                 JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", \"Socket closed\");\n-            } else {\n-                 JNU_ThrowByNameWithMessageAndLastError\n-                     (env, JNU_JAVANETPKG \"SocketException\", \"Receive failed\");\n-            }\n-        }\n-    } else {\n-        \/*\n-         * success - fill in received address...\n-         *\n-         * REMIND: Fill in an int on the packet, and create inetadd\n-         * object in Java, as a performance improvement. Also\n-         * construct the inetadd object lazily.\n-         *\/\n-\n-        jobject packetAddress;\n-\n-        \/*\n-         * Check if there is an InetAddress already associated with this\n-         * packet. If so we check if it is the same source address. We\n-         * can't update any existing InetAddress because it is immutable\n-         *\/\n-        packetAddress = (*env)->GetObjectField(env, packet, dp_addressID);\n-        if (packetAddress != NULL) {\n-            if (!NET_SockaddrEqualsInetAddress(env, &rmtaddr, packetAddress)) {\n-                \/* force a new InetAddress to be created *\/\n-                packetAddress = NULL;\n-            }\n-        }\n-        if (!(*env)->ExceptionCheck(env)){\n-            if (packetAddress == NULL ) {\n-                packetAddress = NET_SockaddrToInetAddress(env, &rmtaddr, &port);\n-                \/* stuff the new InetAddress in the packet *\/\n-                (*env)->SetObjectField(env, packet, dp_addressID, packetAddress);\n-            } else {\n-                \/* only get the new port number *\/\n-                port = NET_GetPortFromSockaddr(&rmtaddr);\n-            }\n-            \/* and fill in the data, remote address\/port and such *\/\n-            (*env)->SetByteArrayRegion(env, packetBuffer, packetBufferOffset, n,\n-                                    (jbyte *)fullPacket);\n-            (*env)->SetIntField(env, packet, dp_portID, port);\n-            (*env)->SetIntField(env, packet, dp_lengthID, n);\n-        }\n-    }\n-\n-    if (mallocedPacket) {\n-        free(fullPacket);\n-    }\n-    return port;\n-}\n-\n-\/*\n- * Class:     java_net_PlainDatagramSocketImpl\n- * Method:    receive\n- * Signature: (Ljava\/net\/DatagramPacket;)V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_PlainDatagramSocketImpl_receive0(JNIEnv *env, jobject this,\n-                                              jobject packet) {\n-\n-    char BUF[MAX_BUFFER_LEN];\n-    char *fullPacket = NULL;\n-    int mallocedPacket = JNI_FALSE;\n-    jobject fdObj = (*env)->GetObjectField(env, this, pdsi_fdID);\n-    jint timeout = (*env)->GetIntField(env, this, pdsi_timeoutID);\n-\n-    jbyteArray packetBuffer;\n-    jint packetBufferOffset, packetBufferLen;\n-\n-    int fd;\n-\n-    int n;\n-    SOCKETADDRESS rmtaddr;\n-    socklen_t slen = sizeof(SOCKETADDRESS);\n-    jboolean retry;\n-#ifdef __linux__\n-    jboolean connected = JNI_FALSE;\n-    jobject connectedAddress = NULL;\n-    jint connectedPort = 0;\n-    jlong prevTime = 0;\n-#endif\n-\n-    if (IS_NULL(fdObj)) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                        \"Socket closed\");\n-        return;\n-    }\n-\n-    fd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);\n-\n-    if (IS_NULL(packet)) {\n-        JNU_ThrowNullPointerException(env, \"packet\");\n-        return;\n-    }\n-\n-    packetBuffer = (*env)->GetObjectField(env, packet, dp_bufID);\n-    if (IS_NULL(packetBuffer)) {\n-        JNU_ThrowNullPointerException(env, \"packet buffer\");\n-        return;\n-    }\n-    packetBufferOffset = (*env)->GetIntField(env, packet, dp_offsetID);\n-    packetBufferLen = (*env)->GetIntField(env, packet, dp_bufLengthID);\n-\n-    if (packetBufferLen > MAX_BUFFER_LEN) {\n-\n-        \/* When JNI-ifying the JDK's IO routines, we turned\n-         * reads and writes of byte arrays of size greater\n-         * than 2048 bytes into several operations of size 2048.\n-         * This saves a malloc()\/memcpy()\/free() for big\n-         * buffers.  This is OK for file IO and TCP, but that\n-         * strategy violates the semantics of a datagram protocol.\n-         * (one big send) != (several smaller sends).  So here\n-         * we *must* allocate the buffer.  Note it needn't be bigger\n-         * than 65,536 (0xFFFF) the max size of an IP packet,\n-         * anything bigger is truncated anyway.\n-         *\n-         * We may want to use a smarter allocation scheme at some\n-         * point.\n-         *\/\n-        if (packetBufferLen > MAX_PACKET_LEN) {\n-            packetBufferLen = MAX_PACKET_LEN;\n-        }\n-        fullPacket = (char *)malloc(packetBufferLen);\n-\n-        if (!fullPacket) {\n-            JNU_ThrowOutOfMemoryError(env, \"Receive buffer native heap allocation failed\");\n-            return;\n-        } else {\n-            mallocedPacket = JNI_TRUE;\n-        }\n-    } else {\n-        fullPacket = &(BUF[0]);\n-    }\n-\n-    do {\n-        retry = JNI_FALSE;\n-\n-        if (timeout) {\n-            int ret = NET_Timeout(env, fd, timeout, JVM_NanoTime(env, 0));\n-            if (ret <= 0) {\n-                if (ret == 0) {\n-                    JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketTimeoutException\",\n-                                    \"Receive timed out\");\n-                } else if (ret == -1) {\n-                    if (errno == ENOMEM) {\n-                        JNU_ThrowOutOfMemoryError(env, \"NET_Timeout native heap allocation failed\");\n-#ifdef __linux__\n-                    } else if (errno == EBADF) {\n-                         JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", \"Socket closed\");\n-                    } else {\n-                        JNU_ThrowByNameWithMessageAndLastError\n-                            (env, JNU_JAVANETPKG \"SocketException\", \"Receive failed\");\n-#else\n-                    } else {\n-                        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", \"Socket closed\");\n-#endif\n-                    }\n-                }\n-\n-                if (mallocedPacket) {\n-                    free(fullPacket);\n-                }\n-\n-                return;\n-            }\n-        }\n-\n-        n = NET_RecvFrom(fd, fullPacket, packetBufferLen, 0,\n-                         &rmtaddr.sa, &slen);\n-        \/* truncate the data if the packet's length is too small *\/\n-        if (n > packetBufferLen) {\n-            n = packetBufferLen;\n-        }\n-        if (n == -1) {\n-            (*env)->SetIntField(env, packet, dp_offsetID, 0);\n-            (*env)->SetIntField(env, packet, dp_lengthID, 0);\n-            if (errno == ECONNREFUSED) {\n-                JNU_ThrowByName(env, JNU_JAVANETPKG \"PortUnreachableException\",\n-                                \"ICMP Port Unreachable\");\n-            } else {\n-                if (errno == EBADF) {\n-                     JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", \"Socket closed\");\n-                 } else {\n-                     JNU_ThrowByNameWithMessageAndLastError\n-                         (env, JNU_JAVANETPKG \"SocketException\", \"Receive failed\");\n-                 }\n-            }\n-        } else {\n-            int port;\n-            jobject packetAddress;\n-\n-            \/*\n-             * success - fill in received address...\n-             *\n-             * REMIND: Fill in an int on the packet, and create inetadd\n-             * object in Java, as a performance improvement. Also\n-             * construct the inetadd object lazily.\n-             *\/\n-\n-            \/*\n-             * Check if there is an InetAddress already associated with this\n-             * packet. If so we check if it is the same source address. We\n-             * can't update any existing InetAddress because it is immutable\n-             *\/\n-            packetAddress = (*env)->GetObjectField(env, packet, dp_addressID);\n-            if (packetAddress != NULL) {\n-                if (!NET_SockaddrEqualsInetAddress(env, &rmtaddr,\n-                                                   packetAddress)) {\n-                    \/* force a new InetAddress to be created *\/\n-                    packetAddress = NULL;\n-                }\n-            }\n-            if (packetAddress == NULL) {\n-                packetAddress = NET_SockaddrToInetAddress(env, &rmtaddr, &port);\n-                \/* stuff the new Inetaddress in the packet *\/\n-                (*env)->SetObjectField(env, packet, dp_addressID, packetAddress);\n-            } else {\n-                \/* only get the new port number *\/\n-                port = NET_GetPortFromSockaddr(&rmtaddr);\n-            }\n-            \/* and fill in the data, remote address\/port and such *\/\n-            (*env)->SetByteArrayRegion(env, packetBuffer, packetBufferOffset, n,\n-                                       (jbyte *)fullPacket);\n-            (*env)->SetIntField(env, packet, dp_portID, port);\n-            (*env)->SetIntField(env, packet, dp_lengthID, n);\n-        }\n-\n-    } while (retry);\n-\n-    if (mallocedPacket) {\n-        free(fullPacket);\n-    }\n-}\n-\n-\/*\n- * Class:     java_net_PlainDatagramSocketImpl\n- * Method:    datagramSocketCreate\n- * Signature: ()V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_PlainDatagramSocketImpl_datagramSocketCreate(JNIEnv *env,\n-                                                           jobject this) {\n-    jobject fdObj = (*env)->GetObjectField(env, this, pdsi_fdID);\n-    int arg, fd, t = 1;\n-    char tmpbuf[1024];\n-    int domain = ipv6_available() ? AF_INET6 : AF_INET;\n-\n-    if (IS_NULL(fdObj)) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                        \"Socket closed\");\n-        return;\n-    }\n-\n-    if ((fd = socket(domain, SOCK_DGRAM, 0)) == -1) {\n-        JNU_ThrowByNameWithMessageAndLastError\n-            (env, JNU_JAVANETPKG \"SocketException\", \"Error creating socket\");\n-        return;\n-    }\n-\n-    \/*\n-     * If IPv4 is available, disable IPV6_V6ONLY to ensure dual-socket support.\n-     *\/\n-    if (domain == AF_INET6 && ipv4_available()) {\n-        arg = 0;\n-        if (setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, (char*)&arg,\n-                       sizeof(int)) < 0) {\n-            NET_ThrowNew(env, errno, \"cannot set IPPROTO_IPV6\");\n-            close(fd);\n-            return;\n-        }\n-    }\n-\n-#ifdef __APPLE__\n-    arg = (domain == AF_INET6) ? IPV6_SNDBUF_LIMIT : IPV4_SNDBUF_LIMIT;\n-    if (setsockopt(fd, SOL_SOCKET, SO_SNDBUF,\n-                   (char *)&arg, sizeof(arg)) < 0) {\n-        getErrorString(errno, tmpbuf, sizeof(tmpbuf));\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", tmpbuf);\n-        close(fd);\n-        return;\n-    }\n-#endif \/* __APPLE__ *\/\n-\n-    if (setsockopt(fd, SOL_SOCKET, SO_BROADCAST, (char*) &t, sizeof (int)) < 0) {\n-        getErrorString(errno, tmpbuf, sizeof(tmpbuf));\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", tmpbuf);\n-        close(fd);\n-        return;\n-    }\n-\n-#if defined(__linux__)\n-     arg = 0;\n-     int level = (domain == AF_INET6) ? IPPROTO_IPV6 : IPPROTO_IP;\n-     if ((setsockopt(fd, level, IP_MULTICAST_ALL, (char*)&arg, sizeof(arg)) < 0) &&\n-           (errno != ENOPROTOOPT))\n-    {\n-        getErrorString(errno, tmpbuf, sizeof(tmpbuf));\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", tmpbuf);\n-         close(fd);\n-         return;\n-     }\n-#endif\n-\n-#if defined (__linux__)\n-    \/*\n-     * On Linux for IPv6 sockets we must set the hop limit\n-     * to 1 to be compatible with default TTL of 1 for IPv4 sockets.\n-     *\/\n-    if (domain == AF_INET6) {\n-        int ttl = 1;\n-        if (setsockopt(fd, IPPROTO_IPV6, IPV6_MULTICAST_HOPS, (char *) &ttl,\n-                sizeof (ttl)) < 0) {\n-            getErrorString(errno, tmpbuf, sizeof(tmpbuf));\n-            JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", tmpbuf);\n-            close(fd);\n-            return;\n-        }\n-    }\n-#endif \/* __linux__ *\/\n-\n-    (*env)->SetIntField(env, fdObj, IO_fd_fdID, fd);\n-}\n-\n-\/*\n- * Class:     java_net_PlainDatagramSocketImpl\n- * Method:    datagramSocketClose\n- * Signature: ()V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_PlainDatagramSocketImpl_datagramSocketClose(JNIEnv *env,\n-                                                          jobject this) {\n-    \/*\n-     * REMIND: PUT A LOCK AROUND THIS CODE\n-     *\/\n-    jobject fdObj = (*env)->GetObjectField(env, this, pdsi_fdID);\n-    int fd;\n-\n-    if (IS_NULL(fdObj)) {\n-        return;\n-    }\n-    fd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);\n-    if (fd == -1) {\n-        return;\n-    }\n-    (*env)->SetIntField(env, fdObj, IO_fd_fdID, -1);\n-    NET_SocketClose(fd);\n-}\n-\n-\n-\/*\n- * Set outgoing multicast interface designated by a NetworkInterface.\n- * Throw exception if failed.\n- *\/\n-static void mcast_set_if_by_if_v4(JNIEnv *env, jobject this, int fd, jobject value) {\n-    static jfieldID ni_addrsID;\n-    struct in_addr in;\n-    jobjectArray addrArray;\n-    jsize len;\n-    jint family;\n-    jobject addr;\n-    int i;\n-\n-    if (ni_addrsID == NULL ) {\n-        jclass c = (*env)->FindClass(env, \"java\/net\/NetworkInterface\");\n-        CHECK_NULL(c);\n-        ni_addrsID = (*env)->GetFieldID(env, c, \"addrs\",\n-                                        \"[Ljava\/net\/InetAddress;\");\n-        CHECK_NULL(ni_addrsID);\n-    }\n-\n-    addrArray = (*env)->GetObjectField(env, value, ni_addrsID);\n-    len = (*env)->GetArrayLength(env, addrArray);\n-\n-    \/*\n-     * Check that there is at least one address bound to this\n-     * interface.\n-     *\/\n-    if (len < 1) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-            \"bad argument for IP_MULTICAST_IF2: No IP addresses bound to interface\");\n-        return;\n-    }\n-\n-    \/*\n-     * We need an ipv4 address here\n-     *\/\n-    in.s_addr = 0;\n-    for (i = 0; i < len; i++) {\n-        addr = (*env)->GetObjectArrayElement(env, addrArray, i);\n-        family = getInetAddress_family(env, addr);\n-        JNU_CHECK_EXCEPTION(env);\n-        if (family == java_net_InetAddress_IPv4) {\n-            in.s_addr = htonl(getInetAddress_addr(env, addr));\n-            JNU_CHECK_EXCEPTION(env);\n-            break;\n-        }\n-    }\n-\n-    if (setsockopt(fd, IPPROTO_IP, IP_MULTICAST_IF,\n-                   (const char *)&in, sizeof(in)) < 0) {\n-        JNU_ThrowByNameWithMessageAndLastError\n-            (env, JNU_JAVANETPKG \"SocketException\", \"Error setting socket option\");\n-    }\n-}\n-\n-\/*\n- * Set outgoing multicast interface designated by a NetworkInterface.\n- * Throw exception if failed.\n- *\/\n-static void mcast_set_if_by_if_v6(JNIEnv *env, jobject this, int fd, jobject value) {\n-    static jfieldID ni_indexID;\n-    int index;\n-\n-    if (ni_indexID == NULL) {\n-        jclass c = (*env)->FindClass(env, \"java\/net\/NetworkInterface\");\n-        CHECK_NULL(c);\n-        ni_indexID = (*env)->GetFieldID(env, c, \"index\", \"I\");\n-        CHECK_NULL(ni_indexID);\n-    }\n-    index = (*env)->GetIntField(env, value, ni_indexID);\n-\n-    if (setsockopt(fd, IPPROTO_IPV6, IPV6_MULTICAST_IF,\n-                   (const char*)&index, sizeof(index)) < 0) {\n-        if ((errno == EINVAL || errno == EADDRNOTAVAIL) && index > 0) {\n-            JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                \"IPV6_MULTICAST_IF failed (interface has IPv4 \"\n-                \"address only?)\");\n-        } else {\n-            JNU_ThrowByNameWithMessageAndLastError\n-                (env, JNU_JAVANETPKG \"SocketException\", \"Error setting socket option\");\n-        }\n-        return;\n-    }\n-}\n-\n-\/*\n- * Set outgoing multicast interface designated by an InetAddress.\n- * Throw exception if failed.\n- *\/\n-static void mcast_set_if_by_addr_v4(JNIEnv *env, jobject this, int fd, jobject value) {\n-    struct in_addr in;\n-\n-    in.s_addr = htonl( getInetAddress_addr(env, value) );\n-    JNU_CHECK_EXCEPTION(env);\n-    if (setsockopt(fd, IPPROTO_IP, IP_MULTICAST_IF,\n-                   (const char*)&in, sizeof(in)) < 0) {\n-        JNU_ThrowByNameWithMessageAndLastError\n-            (env, JNU_JAVANETPKG \"SocketException\", \"Error setting socket option\");\n-    }\n-}\n-\n-\/*\n- * Set outgoing multicast interface designated by an InetAddress.\n- * Throw exception if failed.\n- *\/\n-static void mcast_set_if_by_addr_v6(JNIEnv *env, jobject this, int fd, jobject value) {\n-    static jclass ni_class;\n-    if (ni_class == NULL) {\n-        jclass c = (*env)->FindClass(env, \"java\/net\/NetworkInterface\");\n-        CHECK_NULL(c);\n-        ni_class = (*env)->NewGlobalRef(env, c);\n-        CHECK_NULL(ni_class);\n-    }\n-\n-    value = Java_java_net_NetworkInterface_getByInetAddress0(env, ni_class, value);\n-    if (value == NULL) {\n-        if (!(*env)->ExceptionOccurred(env)) {\n-            JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                 \"bad argument for IP_MULTICAST_IF\"\n-                 \": address not bound to any interface\");\n-        }\n-        return;\n-    }\n-\n-    mcast_set_if_by_if_v6(env, this, fd, value);\n-}\n-\n-\/*\n- * Sets the multicast interface.\n- *\n- * SocketOptions.IP_MULTICAST_IF :-\n- *      value is a InetAddress\n- *      IPv4:   set outgoing multicast interface using\n- *              IPPROTO_IP\/IP_MULTICAST_IF\n- *      IPv6:   Get the index of the interface to which the\n- *              InetAddress is bound\n- *              Set outgoing multicast interface using\n- *              IPPROTO_IPV6\/IPV6_MULTICAST_IF\n- *\n- * SockOptions.IF_MULTICAST_IF2 :-\n- *      value is a NetworkInterface\n- *      IPv4:   Obtain IP address bound to network interface\n- *              (NetworkInterface.addres[0])\n- *              set outgoing multicast interface using\n- *              IPPROTO_IP\/IP_MULTICAST_IF\n- *      IPv6:   Obtain NetworkInterface.index\n- *              Set outgoing multicast interface using\n- *              IPPROTO_IPV6\/IPV6_MULTICAST_IF\n- *\n- *\/\n-static void setMulticastInterface(JNIEnv *env, jobject this, int fd,\n-                                  jint opt, jobject value)\n-{\n-    if (opt == java_net_SocketOptions_IP_MULTICAST_IF) {\n-        \/*\n-         * value is an InetAddress.\n-         *\/\n-#ifdef __linux__\n-        mcast_set_if_by_addr_v4(env, this, fd, value);\n-        if (ipv6_available()) {\n-            if ((*env)->ExceptionCheck(env)){\n-                (*env)->ExceptionClear(env);\n-            }\n-            mcast_set_if_by_addr_v6(env, this, fd, value);\n-        }\n-#else  \/* __linux__ not defined *\/\n-        if (ipv6_available()) {\n-            mcast_set_if_by_addr_v6(env, this, fd, value);\n-        } else {\n-            mcast_set_if_by_addr_v4(env, this, fd, value);\n-        }\n-#endif  \/* __linux__ *\/\n-    }\n-\n-    if (opt == java_net_SocketOptions_IP_MULTICAST_IF2) {\n-        \/*\n-         * value is a NetworkInterface.\n-         *\/\n-#ifdef __linux__\n-        mcast_set_if_by_if_v4(env, this, fd, value);\n-        if (ipv6_available()) {\n-            if ((*env)->ExceptionCheck(env)){\n-                (*env)->ExceptionClear(env);\n-            }\n-            mcast_set_if_by_if_v6(env, this, fd, value);\n-        }\n-#else  \/* __linux__ not defined *\/\n-        if (ipv6_available()) {\n-            mcast_set_if_by_if_v6(env, this, fd, value);\n-        } else {\n-            mcast_set_if_by_if_v4(env, this, fd, value);\n-        }\n-#endif  \/* __linux__ *\/\n-    }\n-}\n-\n-\/*\n- * Enable\/disable local loopback of multicast datagrams.\n- *\/\n-static void mcast_set_loop_v4(JNIEnv *env, jobject this, int fd, jobject value) {\n-    jclass cls;\n-    jfieldID fid;\n-    jboolean on;\n-    char loopback;\n-\n-    cls = (*env)->FindClass(env, \"java\/lang\/Boolean\");\n-    CHECK_NULL(cls);\n-    fid =  (*env)->GetFieldID(env, cls, \"value\", \"Z\");\n-    CHECK_NULL(fid);\n-\n-    on = (*env)->GetBooleanField(env, value, fid);\n-    loopback = (!on ? 1 : 0);\n-\n-    if (NET_SetSockOpt(fd, IPPROTO_IP, IP_MULTICAST_LOOP,\n-                       (const void *)&loopback, sizeof(char)) < 0) {\n-        JNU_ThrowByNameWithMessageAndLastError\n-            (env, JNU_JAVANETPKG \"SocketException\", \"Error setting socket option\");\n-        return;\n-    }\n-}\n-\n-\/*\n- * Enable\/disable local loopback of multicast datagrams.\n- *\/\n-static void mcast_set_loop_v6(JNIEnv *env, jobject this, int fd, jobject value) {\n-    jclass cls;\n-    jfieldID fid;\n-    jboolean on;\n-    int loopback;\n-\n-    cls = (*env)->FindClass(env, \"java\/lang\/Boolean\");\n-    CHECK_NULL(cls);\n-    fid =  (*env)->GetFieldID(env, cls, \"value\", \"Z\");\n-    CHECK_NULL(fid);\n-\n-    on = (*env)->GetBooleanField(env, value, fid);\n-    loopback = (!on ? 1 : 0);\n-\n-    if (NET_SetSockOpt(fd, IPPROTO_IPV6, IPV6_MULTICAST_LOOP,\n-                       (const void *)&loopback, sizeof(int)) < 0) {\n-        JNU_ThrowByNameWithMessageAndLastError\n-            (env, JNU_JAVANETPKG \"SocketException\", \"Error setting socket option\");\n-        return;\n-    }\n-\n-}\n-\n-\/*\n- * Sets the multicast loopback mode.\n- *\/\n-static void setMulticastLoopbackMode(JNIEnv *env, jobject this, int fd,\n-                                     jint opt, jobject value) {\n-#ifdef __linux__\n-    mcast_set_loop_v4(env, this, fd, value);\n-    if (ipv6_available()) {\n-        if ((*env)->ExceptionCheck(env)){\n-            (*env)->ExceptionClear(env);\n-        }\n-        mcast_set_loop_v6(env, this, fd, value);\n-    }\n-#else  \/* __linux__ not defined *\/\n-    if (ipv6_available()) {\n-        mcast_set_loop_v6(env, this, fd, value);\n-    } else {\n-        mcast_set_loop_v4(env, this, fd, value);\n-    }\n-#endif  \/* __linux__ *\/\n-}\n-\n-\/*\n- * Class:     java_net_PlainDatagramSocketImpl\n- * Method:    socketSetOption0\n- * Signature: (ILjava\/lang\/Object;)V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_PlainDatagramSocketImpl_socketSetOption0\n-  (JNIEnv *env, jobject this, jint opt, jobject value)\n-{\n-    int fd;\n-    int level, optname, optlen;\n-    int optval;\n-    optlen = sizeof(int);\n-\n-    \/*\n-     * Check that socket hasn't been closed\n-     *\/\n-    fd = getFD(env, this);\n-    if (fd < 0) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                        \"Socket closed\");\n-        return;\n-    }\n-\n-    \/*\n-     * Check argument has been provided\n-     *\/\n-    if (IS_NULL(value)) {\n-        JNU_ThrowNullPointerException(env, \"value argument\");\n-        return;\n-    }\n-\n-    \/*\n-     * Setting the multicast interface handled separately\n-     *\/\n-    if (opt == java_net_SocketOptions_IP_MULTICAST_IF ||\n-        opt == java_net_SocketOptions_IP_MULTICAST_IF2) {\n-\n-        setMulticastInterface(env, this, fd, opt, value);\n-        return;\n-    }\n-\n-    \/*\n-     * Setting the multicast loopback mode handled separately\n-     *\/\n-    if (opt == java_net_SocketOptions_IP_MULTICAST_LOOP) {\n-        setMulticastLoopbackMode(env, this, fd, opt, value);\n-        return;\n-    }\n-\n-    \/*\n-     * Map the Java level socket option to the platform specific\n-     * level and option name.\n-     *\/\n-    if (NET_MapSocketOption(opt, &level, &optname)) {\n-        JNU_ThrowByName(env, \"java\/net\/SocketException\", \"Invalid option\");\n-        return;\n-    }\n-\n-    switch (opt) {\n-        case java_net_SocketOptions_SO_SNDBUF :\n-        case java_net_SocketOptions_SO_RCVBUF :\n-        case java_net_SocketOptions_IP_TOS :\n-            {\n-                jclass cls;\n-                jfieldID fid;\n-\n-                cls = (*env)->FindClass(env, \"java\/lang\/Integer\");\n-                CHECK_NULL(cls);\n-                fid =  (*env)->GetFieldID(env, cls, \"value\", \"I\");\n-                CHECK_NULL(fid);\n-\n-                optval = (*env)->GetIntField(env, value, fid);\n-                break;\n-            }\n-\n-        case java_net_SocketOptions_SO_REUSEADDR:\n-        case java_net_SocketOptions_SO_REUSEPORT:\n-        case java_net_SocketOptions_SO_BROADCAST:\n-            {\n-                jclass cls;\n-                jfieldID fid;\n-                jboolean on;\n-\n-                cls = (*env)->FindClass(env, \"java\/lang\/Boolean\");\n-                CHECK_NULL(cls);\n-                fid =  (*env)->GetFieldID(env, cls, \"value\", \"Z\");\n-                CHECK_NULL(fid);\n-\n-                on = (*env)->GetBooleanField(env, value, fid);\n-\n-                \/* SO_REUSEADDR or SO_BROADCAST *\/\n-                optval = (on ? 1 : 0);\n-\n-                break;\n-            }\n-\n-        default :\n-            JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                \"Socket option not supported by PlainDatagramSocketImp\");\n-            return;\n-\n-    }\n-\n-    if (NET_SetSockOpt(fd, level, optname, (const void *)&optval, optlen) < 0) {\n-        JNU_ThrowByNameWithMessageAndLastError\n-            (env, JNU_JAVANETPKG \"SocketException\", \"Error setting socket option\");\n-        return;\n-    }\n-}\n-\n-\n-\/*\n- * Return the multicast interface:\n- *\n- * SocketOptions.IP_MULTICAST_IF\n- *      IPv4:   Query IPPROTO_IP\/IP_MULTICAST_IF\n- *              Create InetAddress\n- *              IP_MULTICAST_IF returns struct ip_mreqn on 2.2\n- *              kernel but struct in_addr on 2.4 kernel\n- *      IPv6:   Query IPPROTO_IPV6 \/ IPV6_MULTICAST_IF\n- *              If index == 0 return InetAddress representing\n- *              anyLocalAddress.\n- *              If index > 0 query NetworkInterface by index\n- *              and returns addrs[0]\n- *\n- * SocketOptions.IP_MULTICAST_IF2\n- *      IPv4:   Query IPPROTO_IP\/IP_MULTICAST_IF\n- *              Query NetworkInterface by IP address and\n- *              return the NetworkInterface that the address\n- *              is bound too.\n- *      IPv6:   Query IPPROTO_IPV6 \/ IPV6_MULTICAST_IF\n- *              (except Linux .2 kernel)\n- *              Query NetworkInterface by index and\n- *              return NetworkInterface.\n- *\/\n-jobject getMulticastInterface(JNIEnv *env, jobject this, int fd, jint opt) {\n-    jboolean isIPV4 = JNI_TRUE;\n-\n-    if (ipv6_available()) {\n-        isIPV4 = JNI_FALSE;\n-    }\n-\n-    \/*\n-     * IPv4 implementation\n-     *\/\n-    if (isIPV4) {\n-        static jclass inet4_class;\n-        static jmethodID inet4_ctrID;\n-\n-        static jclass ni_class;\n-        static jmethodID ni_ctrID;\n-        static jfieldID ni_indexID;\n-        static jfieldID ni_addrsID;\n-        static jfieldID ni_nameID;\n-\n-        jobjectArray addrArray;\n-        jobject addr;\n-        jobject ni;\n-        jobject ni_name;\n-\n-        struct in_addr in;\n-        struct in_addr *inP = &in;\n-        socklen_t len = sizeof(struct in_addr);\n-\n-        if (getsockopt(fd, IPPROTO_IP, IP_MULTICAST_IF,\n-                       (char *)inP, &len) < 0) {\n-            JNU_ThrowByNameWithMessageAndLastError\n-                (env, JNU_JAVANETPKG \"SocketException\", \"Error getting socket option\");\n-            return NULL;\n-        }\n-\n-        \/*\n-         * Construct and populate an Inet4Address\n-         *\/\n-        if (inet4_class == NULL) {\n-            jclass c = (*env)->FindClass(env, \"java\/net\/Inet4Address\");\n-            CHECK_NULL_RETURN(c, NULL);\n-            inet4_ctrID = (*env)->GetMethodID(env, c, \"<init>\", \"()V\");\n-            CHECK_NULL_RETURN(inet4_ctrID, NULL);\n-            inet4_class = (*env)->NewGlobalRef(env, c);\n-            CHECK_NULL_RETURN(inet4_class, NULL);\n-        }\n-        addr = (*env)->NewObject(env, inet4_class, inet4_ctrID, 0);\n-        CHECK_NULL_RETURN(addr, NULL);\n-\n-        setInetAddress_addr(env, addr, ntohl(in.s_addr));\n-        JNU_CHECK_EXCEPTION_RETURN(env, NULL);\n-\n-        \/*\n-         * For IP_MULTICAST_IF return InetAddress\n-         *\/\n-        if (opt == java_net_SocketOptions_IP_MULTICAST_IF) {\n-            return addr;\n-        }\n-\n-        \/*\n-         * For IP_MULTICAST_IF2 we get the NetworkInterface for\n-         * this address and return it\n-         *\/\n-        if (ni_class == NULL) {\n-            jclass c = (*env)->FindClass(env, \"java\/net\/NetworkInterface\");\n-            CHECK_NULL_RETURN(c, NULL);\n-            ni_ctrID = (*env)->GetMethodID(env, c, \"<init>\", \"()V\");\n-            CHECK_NULL_RETURN(ni_ctrID, NULL);\n-            ni_indexID = (*env)->GetFieldID(env, c, \"index\", \"I\");\n-            CHECK_NULL_RETURN(ni_indexID, NULL);\n-            ni_addrsID = (*env)->GetFieldID(env, c, \"addrs\",\n-                                            \"[Ljava\/net\/InetAddress;\");\n-            CHECK_NULL_RETURN(ni_addrsID, NULL);\n-            ni_nameID = (*env)->GetFieldID(env, c,\"name\", \"Ljava\/lang\/String;\");\n-            CHECK_NULL_RETURN(ni_nameID, NULL);\n-            ni_class = (*env)->NewGlobalRef(env, c);\n-            CHECK_NULL_RETURN(ni_class, NULL);\n-        }\n-        ni = Java_java_net_NetworkInterface_getByInetAddress0(env, ni_class, addr);\n-        JNU_CHECK_EXCEPTION_RETURN(env, NULL);\n-        if (ni) {\n-            return ni;\n-        }\n-        return NULL;\n-    }\n-\n-\n-    \/*\n-     * IPv6 implementation\n-     *\/\n-    if ((opt == java_net_SocketOptions_IP_MULTICAST_IF) ||\n-        (opt == java_net_SocketOptions_IP_MULTICAST_IF2)) {\n-\n-        static jclass ni_class;\n-        static jmethodID ni_ctrID;\n-        static jfieldID ni_indexID;\n-        static jfieldID ni_addrsID;\n-        static jclass ia_class;\n-        static jfieldID ni_nameID;\n-        static jmethodID ia_anyLocalAddressID;\n-\n-        int index = 0;\n-        socklen_t len = sizeof(index);\n-\n-        jobjectArray addrArray;\n-        jobject addr;\n-        jobject ni;\n-        jobject ni_name;\n-\n-        if (getsockopt(fd, IPPROTO_IPV6, IPV6_MULTICAST_IF,\n-                       (char*)&index, &len) < 0) {\n-            JNU_ThrowByNameWithMessageAndLastError\n-                (env, JNU_JAVANETPKG \"SocketException\", \"Error getting socket option\");\n-            return NULL;\n-        }\n-\n-        if (ni_class == NULL) {\n-            jclass c = (*env)->FindClass(env, \"java\/net\/NetworkInterface\");\n-            CHECK_NULL_RETURN(c, NULL);\n-            ni_ctrID = (*env)->GetMethodID(env, c, \"<init>\", \"()V\");\n-            CHECK_NULL_RETURN(ni_ctrID, NULL);\n-            ni_indexID = (*env)->GetFieldID(env, c, \"index\", \"I\");\n-            CHECK_NULL_RETURN(ni_indexID, NULL);\n-            ni_addrsID = (*env)->GetFieldID(env, c, \"addrs\",\n-                                            \"[Ljava\/net\/InetAddress;\");\n-            CHECK_NULL_RETURN(ni_addrsID, NULL);\n-\n-            ia_class = (*env)->FindClass(env, \"java\/net\/InetAddress\");\n-            CHECK_NULL_RETURN(ia_class, NULL);\n-            ia_class = (*env)->NewGlobalRef(env, ia_class);\n-            CHECK_NULL_RETURN(ia_class, NULL);\n-            ia_anyLocalAddressID = (*env)->GetStaticMethodID(env,\n-                                                             ia_class,\n-                                                             \"anyLocalAddress\",\n-                                                             \"()Ljava\/net\/InetAddress;\");\n-            CHECK_NULL_RETURN(ia_anyLocalAddressID, NULL);\n-            ni_nameID = (*env)->GetFieldID(env, c,\"name\", \"Ljava\/lang\/String;\");\n-            CHECK_NULL_RETURN(ni_nameID, NULL);\n-            ni_class = (*env)->NewGlobalRef(env, c);\n-            CHECK_NULL_RETURN(ni_class, NULL);\n-        }\n-\n-        \/*\n-         * If multicast to a specific interface then return the\n-         * interface (for IF2) or the any address on that interface\n-         * (for IF).\n-         *\/\n-        if (index > 0) {\n-            ni = Java_java_net_NetworkInterface_getByIndex0(env, ni_class,\n-                                                                   index);\n-            if (ni == NULL) {\n-                char errmsg[255];\n-                sprintf(errmsg,\n-                        \"IPV6_MULTICAST_IF returned index to unrecognized interface: %d\",\n-                        index);\n-                JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", errmsg);\n-                return NULL;\n-            }\n-\n-            \/*\n-             * For IP_MULTICAST_IF2 return the NetworkInterface\n-             *\/\n-            if (opt == java_net_SocketOptions_IP_MULTICAST_IF2) {\n-                return ni;\n-            }\n-\n-            \/*\n-             * For IP_MULTICAST_IF return addrs[0]\n-             *\/\n-            addrArray = (*env)->GetObjectField(env, ni, ni_addrsID);\n-            if ((*env)->GetArrayLength(env, addrArray) < 1) {\n-                JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                    \"IPV6_MULTICAST_IF returned interface without IP bindings\");\n-                return NULL;\n-            }\n-\n-            addr = (*env)->GetObjectArrayElement(env, addrArray, 0);\n-            return addr;\n-        }\n-\n-        \/*\n-         * Multicast to any address - return anyLocalAddress\n-         * or a NetworkInterface with addrs[0] set to anyLocalAddress\n-         *\/\n-\n-        addr = (*env)->CallStaticObjectMethod(env, ia_class, ia_anyLocalAddressID,\n-                                              NULL);\n-        if (opt == java_net_SocketOptions_IP_MULTICAST_IF) {\n-            return addr;\n-        }\n-    }\n-    return NULL;\n-}\n-\n-\n-\n-\/*\n- * Returns relevant info as a jint.\n- *\n- * Class:     java_net_PlainDatagramSocketImpl\n- * Method:    socketGetOption\n- * Signature: (I)Ljava\/lang\/Object;\n- *\/\n-JNIEXPORT jobject JNICALL\n-Java_java_net_PlainDatagramSocketImpl_socketGetOption\n-  (JNIEnv *env, jobject this, jint opt)\n-{\n-    int fd;\n-    int level, optname, optlen;\n-    union {\n-        int i;\n-        char c;\n-    } optval;\n-\n-    fd = getFD(env, this);\n-    if (fd < 0) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                        \"socket closed\");\n-        return NULL;\n-    }\n-\n-    \/*\n-     * Handle IP_MULTICAST_IF separately\n-     *\/\n-    if (opt == java_net_SocketOptions_IP_MULTICAST_IF ||\n-        opt == java_net_SocketOptions_IP_MULTICAST_IF2) {\n-        return getMulticastInterface(env, this, fd, opt);\n-\n-    }\n-\n-    \/*\n-     * SO_BINDADDR implemented using getsockname\n-     *\/\n-    if (opt == java_net_SocketOptions_SO_BINDADDR) {\n-        \/* find out local IP address *\/\n-        SOCKETADDRESS sa;\n-        socklen_t len = sizeof(SOCKETADDRESS);\n-        int port;\n-        jobject iaObj;\n-\n-        if (getsockname(fd, &sa.sa, &len) == -1) {\n-            JNU_ThrowByNameWithMessageAndLastError\n-                (env, JNU_JAVANETPKG \"SocketException\", \"Error getting socket name\");\n-            return NULL;\n-        }\n-        iaObj = NET_SockaddrToInetAddress(env, &sa, &port);\n-\n-        return iaObj;\n-    }\n-\n-    \/*\n-     * Map the Java level socket option to the platform specific\n-     * level and option name.\n-     *\/\n-    if (NET_MapSocketOption(opt, &level, &optname)) {\n-        JNU_ThrowByName(env, \"java\/net\/SocketException\", \"Invalid option\");\n-        return NULL;\n-    }\n-\n-    if (opt == java_net_SocketOptions_IP_MULTICAST_LOOP &&\n-        level == IPPROTO_IP) {\n-        optlen = sizeof(optval.c);\n-    } else {\n-        optlen = sizeof(optval.i);\n-    }\n-\n-    if (NET_GetSockOpt(fd, level, optname, (void *)&optval, &optlen) < 0) {\n-        JNU_ThrowByNameWithMessageAndLastError\n-            (env, JNU_JAVANETPKG \"SocketException\", \"Error getting socket option\");\n-        return NULL;\n-    }\n-\n-    switch (opt) {\n-        case java_net_SocketOptions_IP_MULTICAST_LOOP:\n-            \/* getLoopbackMode() returns true if IP_MULTICAST_LOOP disabled *\/\n-            if (level == IPPROTO_IP) {\n-                return createBoolean(env, (int)!optval.c);\n-            } else {\n-                return createBoolean(env, !optval.i);\n-            }\n-\n-        case java_net_SocketOptions_SO_BROADCAST:\n-        case java_net_SocketOptions_SO_REUSEADDR:\n-            return createBoolean(env, optval.i);\n-\n-        case java_net_SocketOptions_SO_REUSEPORT:\n-            return createBoolean(env, optval.i);\n-\n-        case java_net_SocketOptions_SO_SNDBUF:\n-        case java_net_SocketOptions_SO_RCVBUF:\n-        case java_net_SocketOptions_IP_TOS:\n-            return createInteger(env, optval.i);\n-\n-    }\n-\n-    \/* should never reach here *\/\n-    return NULL;\n-}\n-\n-\/*\n- * Multicast-related calls\n- *\/\n-\n-JNIEXPORT void JNICALL\n-Java_java_net_PlainDatagramSocketImpl_setTTL(JNIEnv *env, jobject this,\n-                                             jbyte ttl) {\n-    jint ittl = ttl;\n-    if (ittl < 0) {\n-        ittl += 0x100;\n-    }\n-    Java_java_net_PlainDatagramSocketImpl_setTimeToLive(env, this, ittl);\n-}\n-\n-\/*\n- * Set TTL for a socket. Throw exception if failed.\n- *\/\n-static void setTTL(JNIEnv *env, int fd, jint ttl) {\n-    char ittl = (char)ttl;\n-    if (setsockopt(fd, IPPROTO_IP, IP_MULTICAST_TTL, (char*)&ittl,\n-                   sizeof(ittl)) < 0) {\n-        JNU_ThrowByNameWithMessageAndLastError\n-            (env, JNU_JAVANETPKG \"SocketException\", \"Error setting socket option\");\n-    }\n-}\n-\n-\/*\n- * Set hops limit for a socket. Throw exception if failed.\n- *\/\n-static void setHopLimit(JNIEnv *env, int fd, jint ttl) {\n-    int ittl = (int)ttl;\n-    if (setsockopt(fd, IPPROTO_IPV6, IPV6_MULTICAST_HOPS,\n-                   (char*)&ittl, sizeof(ittl)) < 0) {\n-        JNU_ThrowByNameWithMessageAndLastError\n-            (env, JNU_JAVANETPKG \"SocketException\", \"Error setting socket option\");\n-    }\n-}\n-\n-\/*\n- * Class:     java_net_PlainDatagramSocketImpl\n- * Method:    setTTL\n- * Signature: (B)V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_PlainDatagramSocketImpl_setTimeToLive(JNIEnv *env, jobject this,\n-                                                    jint ttl) {\n-\n-    jobject fdObj = (*env)->GetObjectField(env, this, pdsi_fdID);\n-    int fd;\n-    \/* it is important to cast this to a char, otherwise setsockopt gets confused *\/\n-\n-    if (IS_NULL(fdObj)) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                        \"Socket closed\");\n-        return;\n-    } else {\n-        fd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);\n-    }\n-    \/* setsockopt to be correct TTL *\/\n-#ifdef __linux__\n-    setTTL(env, fd, ttl);\n-    JNU_CHECK_EXCEPTION(env);\n-    if (ipv6_available()) {\n-        setHopLimit(env, fd, ttl);\n-    }\n-#else  \/*  __linux__ not defined *\/\n-    if (ipv6_available()) {\n-        setHopLimit(env, fd, ttl);\n-    } else {\n-        setTTL(env, fd, ttl);\n-    }\n-#endif  \/* __linux__ *\/\n-}\n-\n-\/*\n- * Class:     java_net_PlainDatagramSocketImpl\n- * Method:    getTTL\n- * Signature: ()B\n- *\/\n-JNIEXPORT jbyte JNICALL\n-Java_java_net_PlainDatagramSocketImpl_getTTL(JNIEnv *env, jobject this) {\n-    return (jbyte)Java_java_net_PlainDatagramSocketImpl_getTimeToLive(env, this);\n-}\n-\n-\n-\/*\n- * Class:     java_net_PlainDatagramSocketImpl\n- * Method:    getTTL\n- * Signature: ()B\n- *\/\n-JNIEXPORT jint JNICALL\n-Java_java_net_PlainDatagramSocketImpl_getTimeToLive(JNIEnv *env, jobject this) {\n-\n-    jobject fdObj = (*env)->GetObjectField(env, this, pdsi_fdID);\n-    jint fd = -1;\n-\n-    if (IS_NULL(fdObj)) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                        \"Socket closed\");\n-        return -1;\n-    } else {\n-        fd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);\n-    }\n-    \/* getsockopt of TTL *\/\n-    if (ipv6_available()) {\n-        int ttl = 0;\n-        socklen_t len = sizeof(ttl);\n-\n-        if (getsockopt(fd, IPPROTO_IPV6, IPV6_MULTICAST_HOPS,\n-                       (char*)&ttl, &len) < 0) {\n-            JNU_ThrowByNameWithMessageAndLastError\n-                (env, JNU_JAVANETPKG \"SocketException\", \"Error getting socket option\");\n-            return -1;\n-        }\n-        return (jint)ttl;\n-    } else {\n-        u_char ttl = 0;\n-        socklen_t len = sizeof(ttl);\n-        if (getsockopt(fd, IPPROTO_IP, IP_MULTICAST_TTL,\n-                       (char*)&ttl, &len) < 0) {\n-            JNU_ThrowByNameWithMessageAndLastError\n-                (env, JNU_JAVANETPKG \"SocketException\", \"Error getting socket option\");\n-            return -1;\n-        }\n-        return (jint)ttl;\n-    }\n-}\n-\n-\n-\/*\n- * mcast_join_leave: Join or leave a multicast group.\n- *\n- * For IPv4 sockets use IP_ADD_MEMBERSHIP\/IP_DROP_MEMBERSHIP socket option\n- * to join\/leave multicast group.\n- *\n- * For IPv6 sockets use IPV6_ADD_MEMBERSHIP\/IPV6_DROP_MEMBERSHIP socket option\n- * to join\/leave multicast group. If multicast group is an IPv4 address then\n- * an IPv4-mapped address is used.\n- *\n- * On Linux with IPv6 if we wish to join\/leave an IPv4 multicast group then\n- * we must use the IPv4 socket options. This is because the IPv6 socket options\n- * don't support IPv4-mapped addresses. This is true as per 2.2.19 and 2.4.7\n- * kernel releases. In the future it's possible that IP_ADD_MEMBERSHIP\n- * will be updated to return ENOPROTOOPT if uses with an IPv6 socket. Thus to\n- * cater for this we first try with the IPv4 socket options and if they fail we\n- * use the IPv6 socket options. This seems a reasonable failsafe solution.\n- *\/\n-static void mcast_join_leave(JNIEnv *env, jobject this,\n-                             jobject iaObj, jobject niObj,\n-                             jboolean join) {\n-\n-    jobject fdObj = (*env)->GetObjectField(env, this, pdsi_fdID);\n-    jint fd;\n-    jint family;\n-    jint ipv6_join_leave;\n-    int res;\n-\n-    if (IS_NULL(fdObj)) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                        \"Socket closed\");\n-        return;\n-    } else {\n-        fd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);\n-    }\n-    if (IS_NULL(iaObj)) {\n-        JNU_ThrowNullPointerException(env, \"iaObj\");\n-        return;\n-    }\n-\n-    \/*\n-     * Determine if this is an IPv4 or IPv6 join\/leave.\n-     *\/\n-    ipv6_join_leave = ipv6_available();\n-\n-#ifdef __linux__\n-    family = getInetAddress_family(env, iaObj);\n-    JNU_CHECK_EXCEPTION(env);\n-    if (family == java_net_InetAddress_IPv4) {\n-        ipv6_join_leave = JNI_FALSE;\n-    }\n-#endif\n-\n-    \/*\n-     * For IPv4 join use IP_ADD_MEMBERSHIP\/IP_DROP_MEMBERSHIP socket option\n-     *\n-     * On Linux if IPv4 or IPv6 use IP_ADD_MEMBERSHIP\/IP_DROP_MEMBERSHIP\n-     *\/\n-    if (!ipv6_join_leave) {\n-#ifdef __linux__\n-        struct ip_mreqn mname;\n-#else\n-        struct ip_mreq mname;\n-#endif\n-        int mname_len;\n-\n-        \/*\n-         * joinGroup(InetAddress, NetworkInterface) implementation :-\n-         *\n-         * Linux\/IPv6:  use ip_mreqn structure populated with multicast\n-         *              address and interface index.\n-         *\n-         * IPv4:        use ip_mreq structure populated with multicast\n-         *              address and first address obtained from\n-         *              NetworkInterface\n-         *\/\n-        if (niObj != NULL) {\n-#if defined(__linux__)\n-            if (ipv6_available()) {\n-                static jfieldID ni_indexID;\n-\n-                if (ni_indexID == NULL) {\n-                    jclass c = (*env)->FindClass(env, \"java\/net\/NetworkInterface\");\n-                    CHECK_NULL(c);\n-                    ni_indexID = (*env)->GetFieldID(env, c, \"index\", \"I\");\n-                    CHECK_NULL(ni_indexID);\n-                }\n-\n-                mname.imr_multiaddr.s_addr = htonl(getInetAddress_addr(env, iaObj));\n-                JNU_CHECK_EXCEPTION(env);\n-                mname.imr_address.s_addr = 0;\n-                mname.imr_ifindex =  (*env)->GetIntField(env, niObj, ni_indexID);\n-                mname_len = sizeof(struct ip_mreqn);\n-            } else\n-#endif\n-            {\n-                jobjectArray addrArray = (*env)->GetObjectField(env, niObj, ni_addrsID);\n-                jobject addr;\n-\n-                if ((*env)->GetArrayLength(env, addrArray) < 1) {\n-                    JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                        \"bad argument for IP_ADD_MEMBERSHIP: \"\n-                        \"No IP addresses bound to interface\");\n-                    return;\n-                }\n-                addr = (*env)->GetObjectArrayElement(env, addrArray, 0);\n-\n-                mname.imr_multiaddr.s_addr = htonl(getInetAddress_addr(env, iaObj));\n-                JNU_CHECK_EXCEPTION(env);\n-#ifdef __linux__\n-                mname.imr_address.s_addr = htonl(getInetAddress_addr(env, addr));\n-                JNU_CHECK_EXCEPTION(env);\n-                mname.imr_ifindex = 0;\n-#else\n-                mname.imr_interface.s_addr = htonl(getInetAddress_addr(env, addr));\n-                JNU_CHECK_EXCEPTION(env);\n-#endif\n-                mname_len = sizeof(struct ip_mreq);\n-            }\n-        }\n-\n-\n-        \/*\n-         * joinGroup(InetAddress) implementation :-\n-         *\n-         * Linux\/IPv6:  use ip_mreqn structure populated with multicast\n-         *              address and interface index. index obtained\n-         *              from cached value or IPV6_MULTICAST_IF.\n-         *\n-         * IPv4:        use ip_mreq structure populated with multicast\n-         *              address and local address obtained from\n-         *              IP_MULTICAST_IF. On Linux IP_MULTICAST_IF\n-         *              returns different structure depending on\n-         *              kernel.\n-         *\/\n-\n-        if (niObj == NULL) {\n-\n-#if defined(__linux__)\n-            if (ipv6_available()) {\n-\n-                int index;\n-                socklen_t len = sizeof(index);\n-\n-                if (getsockopt(fd, IPPROTO_IPV6, IPV6_MULTICAST_IF,\n-                               (char*)&index, &len) < 0) {\n-                    NET_ThrowCurrent(env, \"getsockopt IPV6_MULTICAST_IF failed\");\n-                    return;\n-                }\n-\n-                mname.imr_multiaddr.s_addr = htonl(getInetAddress_addr(env, iaObj));\n-                JNU_CHECK_EXCEPTION(env);\n-                mname.imr_address.s_addr = 0 ;\n-                mname.imr_ifindex = index;\n-                mname_len = sizeof(struct ip_mreqn);\n-            } else\n-#endif\n-            {\n-                struct in_addr in;\n-                struct in_addr *inP = &in;\n-                socklen_t len = sizeof(struct in_addr);\n-\n-                if (getsockopt(fd, IPPROTO_IP, IP_MULTICAST_IF, (char *)inP, &len) < 0) {\n-                    NET_ThrowCurrent(env, \"getsockopt IP_MULTICAST_IF failed\");\n-                    return;\n-                }\n-\n-#ifdef __linux__\n-                mname.imr_address.s_addr = in.s_addr;\n-                mname.imr_ifindex = 0;\n-#else\n-                mname.imr_interface.s_addr = in.s_addr;\n-#endif\n-                mname.imr_multiaddr.s_addr = htonl(getInetAddress_addr(env, iaObj));\n-                JNU_CHECK_EXCEPTION(env);\n-                mname_len = sizeof(struct ip_mreq);\n-            }\n-        }\n-\n-\n-        \/*\n-         * Join the multicast group.\n-         *\/\n-        res = setsockopt(fd, IPPROTO_IP, (join ? IP_ADD_MEMBERSHIP:IP_DROP_MEMBERSHIP),\n-                       (char *) &mname, mname_len);\n-\n-#ifdef __APPLE__\n-        if (res < 0 && errno == ENOMEM) {\n-            res = setsockopt(fd, IPPROTO_IP, (join ? IP_ADD_MEMBERSHIP:IP_DROP_MEMBERSHIP),\n-                       (char *) &mname, mname_len);\n-        }\n-#endif\n-\n-        if (res < 0) {\n-            \/*\n-             * If IP_ADD_MEMBERSHIP returns ENOPROTOOPT on Linux and we've got\n-             * IPv6 enabled then it's possible that the kernel has been fixed\n-             * so we switch to IPV6_ADD_MEMBERSHIP socket option.\n-             * As of 2.4.7 kernel IPV6_ADD_MEMBERSHIP can't handle IPv4-mapped\n-             * addresses so we have to use IP_ADD_MEMBERSHIP for IPv4 multicast\n-             * groups. However if the socket is an IPv6 socket then setsockopt\n-             * should return ENOPROTOOPT. We assume this will be fixed in Linux\n-             * at some stage.\n-             *\/\n-#if defined(__linux__)\n-            if (errno == ENOPROTOOPT) {\n-                if (ipv6_available()) {\n-                    ipv6_join_leave = JNI_TRUE;\n-                    errno = 0;\n-                } else  {\n-                    errno = ENOPROTOOPT;    \/* errno can be changed by ipv6_available *\/\n-                }\n-            }\n-#endif\n-            if (errno) {\n-                if (join) {\n-                    NET_ThrowCurrent(env, \"setsockopt IP_ADD_MEMBERSHIP failed\");\n-                } else {\n-                    if (errno == ENOENT)\n-                        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                            \"Not a member of the multicast group\");\n-                    else\n-                        NET_ThrowCurrent(env, \"setsockopt IP_DROP_MEMBERSHIP failed\");\n-                }\n-                return;\n-            }\n-        }\n-\n-        \/*\n-         * If we haven't switched to IPv6 socket option then we're done.\n-         *\/\n-        if (!ipv6_join_leave) {\n-            return;\n-        }\n-    }\n-\n-\n-    \/*\n-     * IPv6 join. If it's an IPv4 multicast group then we use an IPv4-mapped\n-     * address.\n-     *\/\n-    {\n-        struct ipv6_mreq mname6;\n-        jbyteArray ipaddress;\n-        jbyte caddr[16];\n-        jint family;\n-        jint address;\n-        family = getInetAddress_family(env, iaObj) == java_net_InetAddress_IPv4 ?\n-            AF_INET : AF_INET6;\n-        JNU_CHECK_EXCEPTION(env);\n-        if (family == AF_INET) { \/* will convert to IPv4-mapped address *\/\n-            memset((char *) caddr, 0, 16);\n-            address = getInetAddress_addr(env, iaObj);\n-            JNU_CHECK_EXCEPTION(env);\n-            caddr[10] = 0xff;\n-            caddr[11] = 0xff;\n-\n-            caddr[12] = ((address >> 24) & 0xff);\n-            caddr[13] = ((address >> 16) & 0xff);\n-            caddr[14] = ((address >> 8) & 0xff);\n-            caddr[15] = (address & 0xff);\n-        } else {\n-            getInet6Address_ipaddress(env, iaObj, (char*)caddr);\n-        }\n-\n-        memcpy((void *)&(mname6.ipv6mr_multiaddr), caddr, sizeof(struct in6_addr));\n-        if (IS_NULL(niObj)) {\n-            int index;\n-            socklen_t len = sizeof(index);\n-\n-            if (getsockopt(fd, IPPROTO_IPV6, IPV6_MULTICAST_IF,\n-                           (char*)&index, &len) < 0) {\n-                NET_ThrowCurrent(env, \"getsockopt IPV6_MULTICAST_IF failed\");\n-                return;\n-            }\n-            mname6.ipv6mr_interface = index;\n-        } else {\n-            jint idx = (*env)->GetIntField(env, niObj, ni_indexID);\n-            mname6.ipv6mr_interface = idx;\n-        }\n-\n-#if defined(_ALLBSD_SOURCE)\n-#define ADD_MEMBERSHIP          IPV6_JOIN_GROUP\n-#define DRP_MEMBERSHIP          IPV6_LEAVE_GROUP\n-#define S_ADD_MEMBERSHIP        \"IPV6_JOIN_GROUP\"\n-#define S_DRP_MEMBERSHIP        \"IPV6_LEAVE_GROUP\"\n-#else\n-#define ADD_MEMBERSHIP          IPV6_ADD_MEMBERSHIP\n-#define DRP_MEMBERSHIP          IPV6_DROP_MEMBERSHIP\n-#define S_ADD_MEMBERSHIP        \"IPV6_ADD_MEMBERSHIP\"\n-#define S_DRP_MEMBERSHIP        \"IPV6_DROP_MEMBERSHIP\"\n-#endif\n-\n-        \/* Join the multicast group *\/\n-        res = setsockopt(fd, IPPROTO_IPV6, (join ? ADD_MEMBERSHIP : DRP_MEMBERSHIP),\n-                       (char *) &mname6, sizeof(mname6));\n-\n-#ifdef __APPLE__\n-        if (res < 0 && errno == ENOMEM) {\n-            res = setsockopt(fd, IPPROTO_IPV6, (join ? ADD_MEMBERSHIP : DRP_MEMBERSHIP),\n-                       (char *) &mname6, sizeof(mname6));\n-        }\n-#endif\n-        if (res < 0) {\n-            if (join) {\n-                NET_ThrowCurrent(env, \"setsockopt \" S_ADD_MEMBERSHIP \" failed\");\n-            } else {\n-                if (errno == ENOENT) {\n-                   JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                        \"Not a member of the multicast group\");\n-                } else {\n-                    NET_ThrowCurrent(env, \"setsockopt \" S_DRP_MEMBERSHIP \" failed\");\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-\/*\n- * Class:     java_net_PlainDatagramSocketImpl\n- * Method:    join\n- * Signature: (Ljava\/net\/InetAddress;)V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_PlainDatagramSocketImpl_join(JNIEnv *env, jobject this,\n-                                           jobject iaObj, jobject niObj)\n-{\n-    mcast_join_leave(env, this, iaObj, niObj, JNI_TRUE);\n-}\n-\n-\/*\n- * Class:     java_net_PlainDatagramSocketImpl\n- * Method:    leave\n- * Signature: (Ljava\/net\/InetAddress;)V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_PlainDatagramSocketImpl_leave(JNIEnv *env, jobject this,\n-                                            jobject iaObj, jobject niObj)\n-{\n-    mcast_join_leave(env, this, iaObj, niObj, JNI_FALSE);\n-}\n-\n-\/*\n- * Class:     java_net_PlainDatagramSocketImpl\n- * Method:    dataAvailable\n- * Signature: ()I\n- *\/\n-JNIEXPORT jint JNICALL\n-Java_java_net_PlainDatagramSocketImpl_dataAvailable(JNIEnv *env, jobject this)\n-{\n-    int fd, retval;\n-\n-    jobject fdObj = (*env)->GetObjectField(env, this, pdsi_fdID);\n-\n-    if (IS_NULL(fdObj)) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                        \"Socket closed\");\n-        return -1;\n-    }\n-    fd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);\n-\n-    if (ioctl(fd, FIONREAD, &retval) < 0) {\n-        return -1;\n-    }\n-    return retval;\n-}\n","filename":"src\/java.base\/unix\/native\/libnet\/PlainDatagramSocketImpl.c","additions":0,"deletions":2179,"binary":false,"changes":2179,"status":"deleted"},{"patch":"@@ -1,994 +0,0 @@\n-\/*\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-#include <errno.h>\n-\n-#include \"jvm.h\"\n-#include \"net_util.h\"\n-\n-#include \"java_net_SocketOptions.h\"\n-#include \"java_net_PlainSocketImpl.h\"\n-\n-\/************************************************************************\n- * PlainSocketImpl\n- *\/\n-\n-static jfieldID IO_fd_fdID;\n-\n-jfieldID psi_fdID;\n-jfieldID psi_addressID;\n-jfieldID psi_ipaddressID;\n-jfieldID psi_portID;\n-jfieldID psi_localportID;\n-jfieldID psi_timeoutID;\n-jfieldID psi_trafficClassID;\n-jfieldID psi_fdLockID;\n-jfieldID psi_closePendingID;\n-\n-\/*\n- * file descriptor used for dup2\n- *\/\n-static int marker_fd = -1;\n-\n-\n-#define SET_NONBLOCKING(fd) {           \\\n-        int flags = fcntl(fd, F_GETFL); \\\n-        flags |= O_NONBLOCK;            \\\n-        fcntl(fd, F_SETFL, flags);      \\\n-}\n-\n-#define SET_BLOCKING(fd) {              \\\n-        int flags = fcntl(fd, F_GETFL); \\\n-        flags &= ~O_NONBLOCK;           \\\n-        fcntl(fd, F_SETFL, flags);      \\\n-}\n-\n-\/*\n- * Create the marker file descriptor by establishing a loopback connection\n- * which we shutdown but do not close the fd. The result is an fd that\n- * can be used for read\/write.\n- *\/\n-static int getMarkerFD()\n-{\n-    int sv[2];\n-\n-#ifdef AF_UNIX\n-    if (socketpair(AF_UNIX, SOCK_STREAM, 0, sv) == -1) {\n-        return -1;\n-    }\n-#else\n-    return -1;\n-#endif\n-\n-    \/*\n-     * Finally shutdown sv[0] (any reads to this fd will get\n-     * EOF; any writes will get an error).\n-     *\/\n-    shutdown(sv[0], 2);\n-    close(sv[1]);\n-\n-    return sv[0];\n-}\n-\n-\/*\n- * Return the file descriptor given a PlainSocketImpl\n- *\/\n-static int getFD(JNIEnv *env, jobject this) {\n-    jobject fdObj = (*env)->GetObjectField(env, this, psi_fdID);\n-    CHECK_NULL_RETURN(fdObj, -1);\n-    return (*env)->GetIntField(env, fdObj, IO_fd_fdID);\n-}\n-\n-\/*\n- * The initroto function is called whenever PlainSocketImpl is\n- * loaded, to cache field IDs for efficiency. This is called every time\n- * the Java class is loaded.\n- *\n- * Class:     java_net_PlainSocketImpl\n- * Method:    initProto\n- * Signature: ()V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_PlainSocketImpl_initProto(JNIEnv *env, jclass cls) {\n-    psi_fdID = (*env)->GetFieldID(env, cls , \"fd\",\n-                                  \"Ljava\/io\/FileDescriptor;\");\n-    CHECK_NULL(psi_fdID);\n-    psi_addressID = (*env)->GetFieldID(env, cls, \"address\",\n-                                          \"Ljava\/net\/InetAddress;\");\n-    CHECK_NULL(psi_addressID);\n-    psi_portID = (*env)->GetFieldID(env, cls, \"port\", \"I\");\n-    CHECK_NULL(psi_portID);\n-    psi_localportID = (*env)->GetFieldID(env, cls, \"localport\", \"I\");\n-    CHECK_NULL(psi_localportID);\n-    psi_timeoutID = (*env)->GetFieldID(env, cls, \"timeout\", \"I\");\n-    CHECK_NULL(psi_timeoutID);\n-    psi_trafficClassID = (*env)->GetFieldID(env, cls, \"trafficClass\", \"I\");\n-    CHECK_NULL(psi_trafficClassID);\n-    psi_fdLockID = (*env)->GetFieldID(env, cls, \"fdLock\",\n-                                      \"Ljava\/lang\/Object;\");\n-    CHECK_NULL(psi_fdLockID);\n-    psi_closePendingID = (*env)->GetFieldID(env, cls, \"closePending\", \"Z\");\n-    CHECK_NULL(psi_closePendingID);\n-    IO_fd_fdID = NET_GetFileDescriptorID(env);\n-    CHECK_NULL(IO_fd_fdID);\n-\n-    initInetAddressIDs(env);\n-    JNU_CHECK_EXCEPTION(env);\n-\n-    \/* Create the marker fd used for dup2 *\/\n-    marker_fd = getMarkerFD();\n-}\n-\n-\/* a global reference to the java.net.SocketException class. In\n- * socketCreate, we ensure that this is initialized. This is to\n- * prevent the problem where socketCreate runs out of file\n- * descriptors, and is then unable to load the exception class.\n- *\/\n-static jclass socketExceptionCls;\n-\n-\/*\n- * Class:     java_net_PlainSocketImpl\n- * Method:    socketCreate\n- * Signature: (ZZ)V *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_PlainSocketImpl_socketCreate(JNIEnv *env, jobject this,\n-                                           jboolean stream, jboolean isServer) {\n-    jobject fdObj, ssObj;\n-    int fd;\n-    int type = (stream ? SOCK_STREAM : SOCK_DGRAM);\n-    int domain = ipv6_available() ? AF_INET6 : AF_INET;\n-\n-    if (socketExceptionCls == NULL) {\n-        jclass c = (*env)->FindClass(env, \"java\/net\/SocketException\");\n-        CHECK_NULL(c);\n-        socketExceptionCls = (jclass)(*env)->NewGlobalRef(env, c);\n-        CHECK_NULL(socketExceptionCls);\n-    }\n-    fdObj = (*env)->GetObjectField(env, this, psi_fdID);\n-\n-    if (fdObj == NULL) {\n-        (*env)->ThrowNew(env, socketExceptionCls, \"null fd object\");\n-        return;\n-    }\n-\n-    if ((fd = socket(domain, type, 0)) == -1) {\n-        \/* note: if you run out of fds, you may not be able to load\n-         * the exception class, and get a NoClassDefFoundError\n-         * instead.\n-         *\/\n-        NET_ThrowNew(env, errno, \"can't create socket\");\n-        return;\n-    }\n-\n-    \/*\n-     * If IPv4 is available, disable IPV6_V6ONLY to ensure dual-socket support.\n-     *\/\n-    if (domain == AF_INET6 && ipv4_available()) {\n-        int arg = 0;\n-        if (setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, (char*)&arg,\n-                       sizeof(int)) < 0) {\n-            NET_ThrowNew(env, errno, \"cannot set IPPROTO_IPV6\");\n-            close(fd);\n-            return;\n-        }\n-    }\n-\n-    \/*\n-     * If this is a server socket then enable SO_REUSEADDR\n-     * automatically and set to non blocking.\n-     *\/\n-    if (isServer) {\n-        int arg = 1;\n-        SET_NONBLOCKING(fd);\n-        if (NET_SetSockOpt(fd, SOL_SOCKET, SO_REUSEADDR, (char*)&arg,\n-                       sizeof(arg)) < 0) {\n-            NET_ThrowNew(env, errno, \"cannot set SO_REUSEADDR\");\n-            close(fd);\n-            return;\n-        }\n-    }\n-\n-    (*env)->SetIntField(env, fdObj, IO_fd_fdID, fd);\n-}\n-\n-\/*\n- * inetAddress is the address object passed to the socket connect\n- * call.\n- *\n- * Class:     java_net_PlainSocketImpl\n- * Method:    socketConnect\n- * Signature: (Ljava\/net\/InetAddress;I)V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_PlainSocketImpl_socketConnect(JNIEnv *env, jobject this,\n-                                            jobject iaObj, jint port,\n-                                            jint timeout)\n-{\n-    jint localport = (*env)->GetIntField(env, this, psi_localportID);\n-    int len = 0;\n-    \/* fdObj is the FileDescriptor field on this *\/\n-    jobject fdObj = (*env)->GetObjectField(env, this, psi_fdID);\n-\n-    jclass clazz = (*env)->GetObjectClass(env, this);\n-\n-    jobject fdLock;\n-\n-    jint trafficClass = (*env)->GetIntField(env, this, psi_trafficClassID);\n-\n-    \/* fd is an int field on iaObj *\/\n-    jint fd;\n-\n-    SOCKETADDRESS sa;\n-    \/* The result of the connection *\/\n-    int connect_rv = -1;\n-\n-    if (IS_NULL(fdObj)) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", \"Socket closed\");\n-        return;\n-    } else {\n-        fd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);\n-    }\n-    if (IS_NULL(iaObj)) {\n-        JNU_ThrowNullPointerException(env, \"inet address argument null.\");\n-        return;\n-    }\n-\n-    \/* connect *\/\n-    if (NET_InetAddressToSockaddr(env, iaObj, port, &sa, &len,\n-                                  JNI_TRUE) != 0) {\n-        return;\n-    }\n-\n-    if (trafficClass != 0 && ipv6_available()) {\n-        NET_SetTrafficClass(&sa, trafficClass);\n-    }\n-\n-    if (timeout <= 0) {\n-        connect_rv = NET_Connect(fd, &sa.sa, len);\n-    } else {\n-        \/*\n-         * A timeout was specified. We put the socket into non-blocking\n-         * mode, connect, and then wait for the connection to be\n-         * established, fail, or timeout.\n-         *\/\n-        SET_NONBLOCKING(fd);\n-\n-        \/* no need to use NET_Connect as non-blocking *\/\n-        connect_rv = connect(fd, &sa.sa, len);\n-\n-        \/* connection not established immediately *\/\n-        if (connect_rv != 0) {\n-            socklen_t optlen;\n-            jlong nanoTimeout = (jlong) timeout * NET_NSEC_PER_MSEC;\n-            jlong prevNanoTime = JVM_NanoTime(env, 0);\n-\n-            if (errno != EINPROGRESS) {\n-                NET_ThrowByNameWithLastError(env, JNU_JAVANETPKG \"ConnectException\",\n-                             \"connect failed\");\n-                SET_BLOCKING(fd);\n-                return;\n-            }\n-\n-            \/*\n-             * Wait for the connection to be established or a\n-             * timeout occurs. poll needs to handle EINTR in\n-             * case lwp sig handler redirects any process signals to\n-             * this thread.\n-             *\/\n-            while (1) {\n-                jlong newNanoTime;\n-                struct pollfd pfd;\n-                pfd.fd = fd;\n-                pfd.events = POLLOUT;\n-\n-                errno = 0;\n-                connect_rv = NET_Poll(&pfd, 1, nanoTimeout \/ NET_NSEC_PER_MSEC);\n-\n-                if (connect_rv >= 0) {\n-                    break;\n-                }\n-                if (errno != EINTR) {\n-                    break;\n-                }\n-\n-                \/*\n-                 * The poll was interrupted so adjust timeout and\n-                 * restart\n-                 *\/\n-                newNanoTime = JVM_NanoTime(env, 0);\n-                nanoTimeout -= (newNanoTime - prevNanoTime);\n-                if (nanoTimeout < NET_NSEC_PER_MSEC) {\n-                    connect_rv = 0;\n-                    break;\n-                }\n-                prevNanoTime = newNanoTime;\n-\n-            } \/* while *\/\n-\n-            if (connect_rv == 0) {\n-                JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketTimeoutException\",\n-                            \"connect timed out\");\n-\n-                \/*\n-                 * Timeout out but connection may still be established.\n-                 * At the high level it should be closed immediately but\n-                 * just in case we make the socket blocking again and\n-                 * shutdown input & output.\n-                 *\/\n-                SET_BLOCKING(fd);\n-                shutdown(fd, 2);\n-                return;\n-            }\n-\n-            \/* has connection been established *\/\n-            optlen = sizeof(connect_rv);\n-            if (getsockopt(fd, SOL_SOCKET, SO_ERROR, (void*)&connect_rv,\n-                           &optlen) <0) {\n-                connect_rv = errno;\n-            }\n-        }\n-\n-        \/* make socket blocking again *\/\n-        SET_BLOCKING(fd);\n-\n-        \/* restore errno *\/\n-        if (connect_rv != 0) {\n-            errno = connect_rv;\n-            connect_rv = -1;\n-        }\n-    }\n-\n-    \/* report the appropriate exception *\/\n-    if (connect_rv < 0) {\n-\n-#ifdef __linux__\n-        \/*\n-         * Linux\/GNU distribution setup \/etc\/hosts so that\n-         * InetAddress.getLocalHost gets back the loopback address\n-         * rather than the host address. Thus a socket can be\n-         * bound to the loopback address and the connect will\n-         * fail with EADDRNOTAVAIL. In addition the Linux kernel\n-         * returns the wrong error in this case - it returns EINVAL\n-         * instead of EADDRNOTAVAIL. We handle this here so that\n-         * a more descriptive exception text is used.\n-         *\/\n-        if (connect_rv == -1 && errno == EINVAL) {\n-            JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                \"Invalid argument or cannot assign requested address\");\n-            return;\n-        }\n-#endif\n-#if defined(EPROTO)\n-        if (errno == EPROTO) {\n-            NET_ThrowByNameWithLastError(env, JNU_JAVANETPKG \"ProtocolException\",\n-                           \"Protocol error\");\n-            return;\n-        }\n-#endif\n-        if (errno == ECONNREFUSED) {\n-            NET_ThrowByNameWithLastError(env, JNU_JAVANETPKG \"ConnectException\",\n-                           \"Connection refused\");\n-        } else if (errno == ETIMEDOUT) {\n-            NET_ThrowByNameWithLastError(env, JNU_JAVANETPKG \"ConnectException\",\n-                           \"Connection timed out\");\n-        } else if (errno == EHOSTUNREACH) {\n-            NET_ThrowByNameWithLastError(env, JNU_JAVANETPKG \"NoRouteToHostException\",\n-                           \"Host unreachable\");\n-        } else if (errno == EADDRNOTAVAIL) {\n-            NET_ThrowByNameWithLastError(env, JNU_JAVANETPKG \"NoRouteToHostException\",\n-                             \"Address not available\");\n-        } else if ((errno == EISCONN) || (errno == EBADF)) {\n-            JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                            \"Socket closed\");\n-        } else {\n-            JNU_ThrowByNameWithMessageAndLastError\n-                (env, JNU_JAVANETPKG \"SocketException\", \"connect failed\");\n-        }\n-        return;\n-    }\n-\n-    (*env)->SetIntField(env, fdObj, IO_fd_fdID, fd);\n-\n-    \/* set the remote peer address and port *\/\n-    (*env)->SetObjectField(env, this, psi_addressID, iaObj);\n-    (*env)->SetIntField(env, this, psi_portID, port);\n-\n-    \/*\n-     * we need to initialize the local port field if bind was called\n-     * previously to the connect (by the client) then localport field\n-     * will already be initialized\n-     *\/\n-    if (localport == 0) {\n-        \/* Now that we're a connected socket, let's extract the port number\n-         * that the system chose for us and store it in the Socket object.\n-         *\/\n-        socklen_t slen = sizeof(SOCKETADDRESS);\n-        if (getsockname(fd, &sa.sa, &slen) == -1) {\n-            JNU_ThrowByNameWithMessageAndLastError\n-                (env, JNU_JAVANETPKG \"SocketException\", \"Error getting socket name\");\n-        } else {\n-            localport = NET_GetPortFromSockaddr(&sa);\n-            (*env)->SetIntField(env, this, psi_localportID, localport);\n-        }\n-    }\n-}\n-\n-\/*\n- * Class:     java_net_PlainSocketImpl\n- * Method:    socketBind\n- * Signature: (Ljava\/net\/InetAddress;I)V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_PlainSocketImpl_socketBind(JNIEnv *env, jobject this,\n-                                         jobject iaObj, jint localport) {\n-\n-    \/* fdObj is the FileDescriptor field on this *\/\n-    jobject fdObj = (*env)->GetObjectField(env, this, psi_fdID);\n-    \/* fd is an int field on fdObj *\/\n-    int fd;\n-    int len = 0;\n-    SOCKETADDRESS sa;\n-\n-    if (IS_NULL(fdObj)) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                        \"Socket closed\");\n-        return;\n-    } else {\n-        fd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);\n-    }\n-    if (IS_NULL(iaObj)) {\n-        JNU_ThrowNullPointerException(env, \"iaObj is null.\");\n-        return;\n-    }\n-\n-    \/* bind *\/\n-    if (NET_InetAddressToSockaddr(env, iaObj, localport, &sa,\n-                                  &len, JNI_TRUE) != 0) {\n-        return;\n-    }\n-\n-    if (NET_Bind(fd, &sa, len) < 0) {\n-        if (errno == EADDRINUSE || errno == EADDRNOTAVAIL ||\n-            errno == EPERM || errno == EACCES) {\n-            NET_ThrowByNameWithLastError(env, JNU_JAVANETPKG \"BindException\",\n-                           \"Bind failed\");\n-        } else {\n-            JNU_ThrowByNameWithMessageAndLastError\n-                (env, JNU_JAVANETPKG \"SocketException\", \"Bind failed\");\n-        }\n-        return;\n-    }\n-\n-    \/* set the address *\/\n-    (*env)->SetObjectField(env, this, psi_addressID, iaObj);\n-\n-    \/* initialize the local port *\/\n-    if (localport == 0) {\n-        socklen_t slen = sizeof(SOCKETADDRESS);\n-        \/* Now that we're a connected socket, let's extract the port number\n-         * that the system chose for us and store it in the Socket object.\n-         *\/\n-        if (getsockname(fd, &sa.sa, &slen) == -1) {\n-            JNU_ThrowByNameWithMessageAndLastError\n-                (env, JNU_JAVANETPKG \"SocketException\", \"Error getting socket name\");\n-            return;\n-        }\n-        localport = NET_GetPortFromSockaddr(&sa);\n-        (*env)->SetIntField(env, this, psi_localportID, localport);\n-    } else {\n-        (*env)->SetIntField(env, this, psi_localportID, localport);\n-    }\n-}\n-\n-\/*\n- * Class:     java_net_PlainSocketImpl\n- * Method:    socketListen\n- * Signature: (I)V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_PlainSocketImpl_socketListen(JNIEnv *env, jobject this,\n-                                           jint count)\n-{\n-    \/* this FileDescriptor fd field *\/\n-    jobject fdObj = (*env)->GetObjectField(env, this, psi_fdID);\n-    \/* fdObj's int fd field *\/\n-    int fd;\n-\n-    if (IS_NULL(fdObj)) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                        \"Socket closed\");\n-        return;\n-    } else {\n-        fd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);\n-    }\n-\n-    \/*\n-     * Workaround for bugid 4101691 in Solaris 2.6. See 4106600.\n-     * If listen backlog is Integer.MAX_VALUE then subtract 1.\n-     *\/\n-    if (count == 0x7fffffff)\n-        count -= 1;\n-\n-    if (listen(fd, count) == -1) {\n-        JNU_ThrowByNameWithMessageAndLastError\n-            (env, JNU_JAVANETPKG \"SocketException\", \"Listen failed\");\n-    }\n-}\n-\n-\/*\n- * Class:     java_net_PlainSocketImpl\n- * Method:    socketAccept\n- * Signature: (Ljava\/net\/SocketImpl;)V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_PlainSocketImpl_socketAccept(JNIEnv *env, jobject this,\n-                                           jobject socket)\n-{\n-    \/* fields on this *\/\n-    int port;\n-    jint timeout = (*env)->GetIntField(env, this, psi_timeoutID);\n-    jlong prevNanoTime = 0;\n-    jlong nanoTimeout = (jlong) timeout * NET_NSEC_PER_MSEC;\n-    jobject fdObj = (*env)->GetObjectField(env, this, psi_fdID);\n-\n-    \/* the FileDescriptor field on socket *\/\n-    jobject socketFdObj;\n-    \/* the InetAddress field on socket *\/\n-    jobject socketAddressObj;\n-\n-    \/* the ServerSocket fd int field on fdObj *\/\n-    jint fd;\n-\n-    \/* accepted fd *\/\n-    jint newfd;\n-\n-    SOCKETADDRESS sa;\n-    socklen_t slen = sizeof(SOCKETADDRESS);\n-\n-    if (IS_NULL(fdObj)) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                        \"Socket closed\");\n-        return;\n-    } else {\n-        fd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);\n-    }\n-    if (IS_NULL(socket)) {\n-        JNU_ThrowNullPointerException(env, \"socket is null\");\n-        return;\n-    }\n-\n-    \/*\n-     * accept connection but ignore ECONNABORTED indicating that\n-     * connection was eagerly accepted by the OS but was reset\n-     * before accept() was called.\n-     *\n-     * If accept timeout in place and timeout is adjusted with\n-     * each ECONNABORTED or EWOULDBLOCK or EAGAIN to ensure that\n-     * semantics of timeout are preserved.\n-     *\/\n-    for (;;) {\n-        int ret;\n-        jlong currNanoTime;\n-\n-        \/* first usage pick up current time *\/\n-        if (prevNanoTime == 0 && nanoTimeout > 0) {\n-            prevNanoTime = JVM_NanoTime(env, 0);\n-        }\n-\n-        \/* passing a timeout of 0 to poll will return immediately,\n-           but in the case of ServerSocket 0 means infinite. *\/\n-        if (timeout <= 0) {\n-            ret = NET_Timeout(env, fd, -1, 0);\n-        } else {\n-            ret = NET_Timeout(env, fd, nanoTimeout \/ NET_NSEC_PER_MSEC, prevNanoTime);\n-        }\n-        if (ret == 0) {\n-            JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketTimeoutException\",\n-                            \"Accept timed out\");\n-            return;\n-        } else if (ret == -1) {\n-            if (errno == EBADF) {\n-               JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", \"Socket closed\");\n-            } else if (errno == ENOMEM) {\n-               JNU_ThrowOutOfMemoryError(env, \"NET_Timeout native heap allocation failed\");\n-            } else {\n-               JNU_ThrowByNameWithMessageAndLastError\n-                   (env, JNU_JAVANETPKG \"SocketException\", \"Accept failed\");\n-            }\n-            return;\n-        }\n-\n-        newfd = NET_Accept(fd, &sa.sa, &slen);\n-\n-        \/* connection accepted *\/\n-        if (newfd >= 0) {\n-            SET_BLOCKING(newfd);\n-            break;\n-        }\n-\n-        \/* non (ECONNABORTED or EWOULDBLOCK or EAGAIN) error *\/\n-        if (!(errno == ECONNABORTED || errno == EWOULDBLOCK || errno == EAGAIN)) {\n-            break;\n-        }\n-\n-        \/* ECONNABORTED or EWOULDBLOCK or EAGAIN error so adjust timeout if there is one. *\/\n-        if (nanoTimeout >= NET_NSEC_PER_MSEC) {\n-            currNanoTime = JVM_NanoTime(env, 0);\n-            nanoTimeout -= (currNanoTime - prevNanoTime);\n-            if (nanoTimeout < NET_NSEC_PER_MSEC) {\n-                JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketTimeoutException\",\n-                        \"Accept timed out\");\n-                return;\n-            }\n-            prevNanoTime = currNanoTime;\n-        }\n-    }\n-\n-    if (newfd < 0) {\n-        if (newfd == -2) {\n-            JNU_ThrowByName(env, JNU_JAVAIOPKG \"InterruptedIOException\",\n-                            \"operation interrupted\");\n-        } else {\n-            if (errno == EINVAL) {\n-                errno = EBADF;\n-            }\n-            if (errno == EBADF) {\n-                JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", \"Socket closed\");\n-            } else {\n-                JNU_ThrowByNameWithMessageAndLastError\n-                    (env, JNU_JAVANETPKG \"SocketException\", \"Accept failed\");\n-            }\n-        }\n-        return;\n-    }\n-\n-    \/*\n-     * fill up the remote peer port and address in the new socket structure.\n-     *\/\n-    socketAddressObj = NET_SockaddrToInetAddress(env, &sa, &port);\n-    if (socketAddressObj == NULL) {\n-        \/* should be pending exception *\/\n-        close(newfd);\n-        return;\n-    }\n-\n-    \/*\n-     * Populate SocketImpl.fd.fd\n-     *\/\n-    socketFdObj = (*env)->GetObjectField(env, socket, psi_fdID);\n-    (*env)->SetIntField(env, socketFdObj, IO_fd_fdID, newfd);\n-\n-    (*env)->SetObjectField(env, socket, psi_addressID, socketAddressObj);\n-    (*env)->SetIntField(env, socket, psi_portID, port);\n-    \/* also fill up the local port information *\/\n-     port = (*env)->GetIntField(env, this, psi_localportID);\n-    (*env)->SetIntField(env, socket, psi_localportID, port);\n-}\n-\n-\n-\/*\n- * Class:     java_net_PlainSocketImpl\n- * Method:    socketAvailable\n- * Signature: ()I\n- *\/\n-JNIEXPORT jint JNICALL\n-Java_java_net_PlainSocketImpl_socketAvailable(JNIEnv *env, jobject this) {\n-    int count = 0;\n-    jobject fdObj = (*env)->GetObjectField(env, this, psi_fdID);\n-    jint fd;\n-\n-    if (IS_NULL(fdObj)) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                        \"Socket closed\");\n-        return -1;\n-    } else {\n-        fd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);\n-    }\n-    if (NET_SocketAvailable(fd, &count) != 0) {\n-        if (errno == ECONNRESET) {\n-            JNU_ThrowByName(env, \"sun\/net\/ConnectionResetException\", \"\");\n-        } else {\n-            JNU_ThrowByNameWithMessageAndLastError\n-                (env, JNU_JAVANETPKG \"SocketException\", \"ioctl FIONREAD failed\");\n-        }\n-    }\n-    return (jint) count;\n-}\n-\n-\/*\n- * Class:     java_net_PlainSocketImpl\n- * Method:    socketClose0\n- * Signature: (Z)V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_PlainSocketImpl_socketClose0(JNIEnv *env, jobject this,\n-                                          jboolean useDeferredClose) {\n-\n-    jobject fdObj = (*env)->GetObjectField(env, this, psi_fdID);\n-    jint fd;\n-\n-    if (IS_NULL(fdObj)) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                        \"socket already closed\");\n-        return;\n-    } else {\n-        fd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);\n-    }\n-    if (fd != -1) {\n-        if (useDeferredClose && marker_fd >= 0) {\n-            NET_Dup2(marker_fd, fd);\n-        } else {\n-            (*env)->SetIntField(env, fdObj, IO_fd_fdID, -1);\n-            NET_SocketClose(fd);\n-        }\n-    }\n-}\n-\n-\/*\n- * Class:     java_net_PlainSocketImpl\n- * Method:    socketShutdown\n- * Signature: (I)V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_PlainSocketImpl_socketShutdown(JNIEnv *env, jobject this,\n-                                             jint howto)\n-{\n-\n-    jobject fdObj = (*env)->GetObjectField(env, this, psi_fdID);\n-    jint fd;\n-\n-    \/*\n-     * WARNING: THIS NEEDS LOCKING. ALSO: SHOULD WE CHECK for fd being\n-     * -1 already?\n-     *\/\n-    if (IS_NULL(fdObj)) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                        \"socket already closed\");\n-        return;\n-    } else {\n-        fd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);\n-    }\n-    shutdown(fd, howto);\n-}\n-\n-\n-\/*\n- * Class:     java_net_PlainSocketImpl\n- * Method:    socketSetOption0\n- * Signature: (IZLjava\/lang\/Object;)V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_PlainSocketImpl_socketSetOption0\n-  (JNIEnv *env, jobject this, jint cmd, jboolean on, jobject value)\n-{\n-    int fd;\n-    int level, optname, optlen;\n-    union {\n-        int i;\n-        struct linger ling;\n-    } optval;\n-\n-    \/*\n-     * Check that socket hasn't been closed\n-     *\/\n-    fd = getFD(env, this);\n-    if (fd < 0) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                        \"Socket closed\");\n-        return;\n-    }\n-\n-    \/*\n-     * SO_TIMEOUT is a NOOP on Solaris\/Linux\n-     *\/\n-    if (cmd == java_net_SocketOptions_SO_TIMEOUT) {\n-        return;\n-    }\n-\n-    \/*\n-     * Map the Java level socket option to the platform specific\n-     * level and option name.\n-     *\/\n-    if (NET_MapSocketOption(cmd, &level, &optname)) {\n-        JNU_ThrowByName(env, \"java\/net\/SocketException\", \"Invalid option\");\n-        return;\n-    }\n-\n-    switch (cmd) {\n-        case java_net_SocketOptions_SO_SNDBUF :\n-        case java_net_SocketOptions_SO_RCVBUF :\n-        case java_net_SocketOptions_SO_LINGER :\n-        case java_net_SocketOptions_IP_TOS :\n-            {\n-                jclass cls;\n-                jfieldID fid;\n-\n-                cls = (*env)->FindClass(env, \"java\/lang\/Integer\");\n-                CHECK_NULL(cls);\n-                fid = (*env)->GetFieldID(env, cls, \"value\", \"I\");\n-                CHECK_NULL(fid);\n-\n-                if (cmd == java_net_SocketOptions_SO_LINGER) {\n-                    if (on) {\n-                        optval.ling.l_onoff = 1;\n-                        optval.ling.l_linger = (*env)->GetIntField(env, value, fid);\n-                    } else {\n-                        optval.ling.l_onoff = 0;\n-                        optval.ling.l_linger = 0;\n-                    }\n-                    optlen = sizeof(optval.ling);\n-                } else {\n-                    optval.i = (*env)->GetIntField(env, value, fid);\n-                    optlen = sizeof(optval.i);\n-                }\n-\n-                break;\n-            }\n-\n-        \/* Boolean -> int *\/\n-        default :\n-            optval.i = (on ? 1 : 0);\n-            optlen = sizeof(optval.i);\n-\n-    }\n-\n-    if (NET_SetSockOpt(fd, level, optname, (const void *)&optval, optlen) < 0) {\n-#if defined(_AIX)\n-        if (errno == EINVAL) {\n-            \/\/ On AIX setsockopt will set errno to EINVAL if the socket\n-            \/\/ is closed. The default error message is then confusing\n-            char fullMsg[128];\n-            jio_snprintf(fullMsg, sizeof(fullMsg), \"Invalid option or socket reset by remote peer\");\n-            JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", fullMsg);\n-            return;\n-        }\n-#endif \/* _AIX *\/\n-        JNU_ThrowByNameWithMessageAndLastError\n-            (env, JNU_JAVANETPKG \"SocketException\", \"Error setting socket option\");\n-    }\n-}\n-\n-\/*\n- * Class:     java_net_PlainSocketImpl\n- * Method:    socketGetOption\n- * Signature: (ILjava\/lang\/Object;)I\n- *\/\n-JNIEXPORT jint JNICALL\n-Java_java_net_PlainSocketImpl_socketGetOption\n-  (JNIEnv *env, jobject this, jint cmd, jobject iaContainerObj)\n-{\n-    int fd;\n-    int level, optname, optlen;\n-    union {\n-        int i;\n-        struct linger ling;\n-    } optval;\n-\n-    \/*\n-     * Check that socket hasn't been closed\n-     *\/\n-    fd = getFD(env, this);\n-    if (fd < 0) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                        \"Socket closed\");\n-        return -1;\n-    }\n-\n-    \/*\n-     * SO_BINDADDR isn't a socket option\n-     *\/\n-    if (cmd == java_net_SocketOptions_SO_BINDADDR) {\n-        SOCKETADDRESS sa;\n-        socklen_t len = sizeof(SOCKETADDRESS);\n-        int port;\n-        jobject iaObj;\n-        jclass iaCntrClass;\n-        jfieldID iaFieldID;\n-\n-        if (getsockname(fd, &sa.sa, &len) < 0) {\n-            JNU_ThrowByNameWithMessageAndLastError\n-                (env, JNU_JAVANETPKG \"SocketException\", \"Error getting socket name\");\n-            return -1;\n-        }\n-        iaObj = NET_SockaddrToInetAddress(env, &sa, &port);\n-        CHECK_NULL_RETURN(iaObj, -1);\n-\n-        iaCntrClass = (*env)->GetObjectClass(env, iaContainerObj);\n-        iaFieldID = (*env)->GetFieldID(env, iaCntrClass, \"addr\", \"Ljava\/net\/InetAddress;\");\n-        CHECK_NULL_RETURN(iaFieldID, -1);\n-        (*env)->SetObjectField(env, iaContainerObj, iaFieldID, iaObj);\n-        return 0; \/* notice change from before *\/\n-    }\n-\n-    \/*\n-     * Map the Java level socket option to the platform specific\n-     * level and option name.\n-     *\/\n-    if (NET_MapSocketOption(cmd, &level, &optname)) {\n-        JNU_ThrowByName(env, \"java\/net\/SocketException\", \"Invalid option\");\n-        return -1;\n-    }\n-\n-    \/*\n-     * Args are int except for SO_LINGER\n-     *\/\n-    if (cmd == java_net_SocketOptions_SO_LINGER) {\n-        optlen = sizeof(optval.ling);\n-    } else {\n-        optlen = sizeof(optval.i);\n-    }\n-\n-    if (NET_GetSockOpt(fd, level, optname, (void *)&optval, &optlen) < 0) {\n-        JNU_ThrowByNameWithMessageAndLastError\n-            (env, JNU_JAVANETPKG \"SocketException\", \"Error getting socket option\");\n-        return -1;\n-    }\n-\n-    switch (cmd) {\n-        case java_net_SocketOptions_SO_LINGER:\n-            return (optval.ling.l_onoff ? optval.ling.l_linger: -1);\n-\n-        case java_net_SocketOptions_SO_SNDBUF:\n-        case java_net_SocketOptions_SO_RCVBUF:\n-        case java_net_SocketOptions_IP_TOS:\n-            return optval.i;\n-\n-        default :\n-            return (optval.i == 0) ? -1 : 1;\n-    }\n-}\n-\n-\n-\/*\n- * Class:     java_net_PlainSocketImpl\n- * Method:    socketSendUrgentData\n- * Signature: (B)V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_PlainSocketImpl_socketSendUrgentData(JNIEnv *env, jobject this,\n-                                             jint data) {\n-    \/* The fd field *\/\n-    jobject fdObj = (*env)->GetObjectField(env, this, psi_fdID);\n-    int n, fd;\n-    unsigned char d = data & 0xFF;\n-\n-    if (IS_NULL(fdObj)) {\n-        JNU_ThrowByName(env, \"java\/net\/SocketException\", \"Socket closed\");\n-        return;\n-    } else {\n-        fd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);\n-        \/* Bug 4086704 - If the Socket associated with this file descriptor\n-         * was closed (sysCloseFD), the file descriptor is set to -1.\n-         *\/\n-        if (fd == -1) {\n-            JNU_ThrowByName(env, \"java\/net\/SocketException\", \"Socket closed\");\n-            return;\n-        }\n-\n-    }\n-    n = NET_Send(fd, (char *)&d, 1, MSG_OOB);\n-    if (n == -1) {\n-        JNU_ThrowIOExceptionWithLastError(env, \"Write failed\");\n-    }\n-}\n","filename":"src\/java.base\/unix\/native\/libnet\/PlainSocketImpl.c","additions":0,"deletions":994,"binary":false,"changes":994,"status":"deleted"},{"patch":"@@ -1,60 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <jni.h>\n-#include <string.h>\n-\n-#include \"net_util.h\"\n-#include \"java_net_SocketCleanable.h\"\n-\n-JNIEXPORT jboolean JNICALL\n-Java_java_net_AbstractPlainSocketImpl_isReusePortAvailable0(JNIEnv* env, jclass c1)\n-{\n-    return (reuseport_available()) ? JNI_TRUE : JNI_FALSE;\n-}\n-\n-JNIEXPORT jboolean JNICALL\n-Java_java_net_AbstractPlainDatagramSocketImpl_isReusePortAvailable0(JNIEnv* env, jclass c1)\n-{\n-    return (reuseport_available()) ? JNI_TRUE : JNI_FALSE;\n-}\n-\n-JNIEXPORT jboolean JNICALL\n-Java_jdk_net_Sockets_isReusePortAvailable0(JNIEnv* env, jclass c1)\n-{\n-    return (reuseport_available()) ? JNI_TRUE : JNI_FALSE;\n-}\n-\n-\/*\n- * Class:     java_net_SocketCleanable\n- * Method:    cleanupClose0\n- * Signature: (I)V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_SocketCleanable_cleanupClose0(JNIEnv *env, jclass c1, jint fd)\n-{\n-    NET_SocketClose(fd);\n-}\n-\n","filename":"src\/java.base\/unix\/native\/libnet\/SocketImpl.c","additions":0,"deletions":60,"binary":false,"changes":60,"status":"deleted"},{"patch":"@@ -1,170 +0,0 @@\n-\/*\n- * Copyright (c) 1997, 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-#include <errno.h>\n-#include <stdlib.h>\n-#include <string.h>\n-\n-#include \"jvm.h\"\n-#include \"net_util.h\"\n-\n-#include \"java_net_SocketInputStream.h\"\n-\n-\/*\n- * SocketInputStream\n- *\/\n-\n-static jfieldID IO_fd_fdID;\n-\n-\/*\n- * Class:     java_net_SocketInputStream\n- * Method:    init\n- * Signature: ()V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_SocketInputStream_init(JNIEnv *env, jclass cls) {\n-    IO_fd_fdID = NET_GetFileDescriptorID(env);\n-}\n-\n-static int NET_ReadWithTimeout(JNIEnv *env, int fd, char *bufP, int len, long timeout) {\n-    int result = 0;\n-    jlong prevNanoTime = JVM_NanoTime(env, 0);\n-    jlong nanoTimeout = (jlong) timeout * NET_NSEC_PER_MSEC;\n-    while (nanoTimeout >= NET_NSEC_PER_MSEC) {\n-        result = NET_Timeout(env, fd, nanoTimeout \/ NET_NSEC_PER_MSEC, prevNanoTime);\n-        if (result <= 0) {\n-            if (result == 0) {\n-                JNU_ThrowByName(env, \"java\/net\/SocketTimeoutException\", \"Read timed out\");\n-            } else if (result == -1) {\n-                if (errno == EBADF) {\n-                    JNU_ThrowByName(env, \"java\/net\/SocketException\", \"Socket closed\");\n-                } else if (errno == ENOMEM) {\n-                    JNU_ThrowOutOfMemoryError(env, \"NET_Timeout native heap allocation failed\");\n-                } else {\n-                    JNU_ThrowByNameWithMessageAndLastError\n-                            (env, \"java\/net\/SocketException\", \"select\/poll failed\");\n-                }\n-            }\n-            return -1;\n-        }\n-        result = NET_NonBlockingRead(fd, bufP, len);\n-        if (result == -1 && ((errno == EAGAIN) || (errno == EWOULDBLOCK))) {\n-            jlong newtNanoTime = JVM_NanoTime(env, 0);\n-            nanoTimeout -= newtNanoTime - prevNanoTime;\n-            if (nanoTimeout >= NET_NSEC_PER_MSEC) {\n-                prevNanoTime = newtNanoTime;\n-            }\n-        } else {\n-            break;\n-        }\n-    }\n-    return result;\n-}\n-\n-\/*\n- * Class:     java_net_SocketInputStream\n- * Method:    socketRead0\n- * Signature: (Ljava\/io\/FileDescriptor;[BIII)I\n- *\/\n-JNIEXPORT jint JNICALL\n-Java_java_net_SocketInputStream_socketRead0(JNIEnv *env, jobject this,\n-                                            jobject fdObj, jbyteArray data,\n-                                            jint off, jint len, jint timeout)\n-{\n-    char BUF[MAX_BUFFER_LEN];\n-    char *bufP;\n-    jint fd, nread;\n-\n-    if (IS_NULL(fdObj)) {\n-        JNU_ThrowByName(env, \"java\/net\/SocketException\",\n-                        \"Socket closed\");\n-        return -1;\n-    }\n-    fd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);\n-    if (fd == -1) {\n-        JNU_ThrowByName(env, \"java\/net\/SocketException\", \"Socket closed\");\n-        return -1;\n-    }\n-\n-    \/*\n-     * If the read is greater than our stack allocated buffer then\n-     * we allocate from the heap (up to a limit)\n-     *\/\n-    if (len > MAX_BUFFER_LEN) {\n-        if (len > MAX_HEAP_BUFFER_LEN) {\n-            len = MAX_HEAP_BUFFER_LEN;\n-        }\n-        bufP = (char *)malloc((size_t)len);\n-        if (bufP == NULL) {\n-            bufP = BUF;\n-            len = MAX_BUFFER_LEN;\n-        }\n-    } else {\n-        bufP = BUF;\n-    }\n-    if (timeout) {\n-        nread = NET_ReadWithTimeout(env, fd, bufP, len, timeout);\n-        if ((*env)->ExceptionCheck(env)) {\n-            if (bufP != BUF) {\n-                free(bufP);\n-            }\n-            return nread;\n-        }\n-    } else {\n-        nread = NET_Read(fd, bufP, len);\n-    }\n-\n-    if (nread <= 0) {\n-        if (nread < 0) {\n-\n-            switch (errno) {\n-                case ECONNRESET:\n-                case EPIPE:\n-                    JNU_ThrowByName(env, \"sun\/net\/ConnectionResetException\",\n-                        \"Connection reset\");\n-                    break;\n-\n-                case EBADF:\n-                    JNU_ThrowByName(env, \"java\/net\/SocketException\",\n-                        \"Socket closed\");\n-                    break;\n-\n-                case EINTR:\n-                     JNU_ThrowByName(env, \"java\/io\/InterruptedIOException\",\n-                           \"Operation interrupted\");\n-                     break;\n-                default:\n-                    JNU_ThrowByNameWithMessageAndLastError\n-                        (env, \"java\/net\/SocketException\", \"Read failed\");\n-            }\n-        }\n-    } else {\n-        (*env)->SetByteArrayRegion(env, data, off, nread, (jbyte *)bufP);\n-    }\n-\n-    if (bufP != BUF) {\n-        free(bufP);\n-    }\n-    return nread;\n-}\n","filename":"src\/java.base\/unix\/native\/libnet\/SocketInputStream.c","additions":0,"deletions":170,"binary":false,"changes":170,"status":"deleted"},{"patch":"@@ -1,126 +0,0 @@\n-\/*\n- * Copyright (c) 1997, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-#include <errno.h>\n-#include <stdlib.h>\n-#include <string.h>\n-\n-#include \"net_util.h\"\n-\n-#include \"java_net_SocketOutputStream.h\"\n-\n-#define min(a, b)       ((a) < (b) ? (a) : (b))\n-\n-\/*\n- * SocketOutputStream\n- *\/\n-\n-static jfieldID IO_fd_fdID;\n-\n-\/*\n- * Class:     java_net_SocketOutputStream\n- * Method:    init\n- * Signature: ()V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_SocketOutputStream_init(JNIEnv *env, jclass cls) {\n-    IO_fd_fdID = NET_GetFileDescriptorID(env);\n-}\n-\n-\/*\n- * Class:     java_net_SocketOutputStream\n- * Method:    socketWrite0\n- * Signature: (Ljava\/io\/FileDescriptor;[BII)V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_SocketOutputStream_socketWrite0(JNIEnv *env, jobject this,\n-                                              jobject fdObj,\n-                                              jbyteArray data,\n-                                              jint off, jint len) {\n-    char *bufP;\n-    char BUF[MAX_BUFFER_LEN];\n-    int buflen;\n-    int fd;\n-\n-    if (IS_NULL(fdObj)) {\n-        JNU_ThrowByName(env, \"java\/net\/SocketException\", \"Socket closed\");\n-        return;\n-    } else {\n-        fd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);\n-        \/* Bug 4086704 - If the Socket associated with this file descriptor\n-         * was closed (sysCloseFD), the file descriptor is set to -1.\n-         *\/\n-        if (fd == -1) {\n-            JNU_ThrowByName(env, \"java\/net\/SocketException\", \"Socket closed\");\n-            return;\n-        }\n-\n-    }\n-\n-    if (len <= MAX_BUFFER_LEN) {\n-        bufP = BUF;\n-        buflen = MAX_BUFFER_LEN;\n-    } else {\n-        buflen = min(MAX_HEAP_BUFFER_LEN, len);\n-        bufP = (char *)malloc((size_t)buflen);\n-\n-        \/* if heap exhausted resort to stack buffer *\/\n-        if (bufP == NULL) {\n-            bufP = BUF;\n-            buflen = MAX_BUFFER_LEN;\n-        }\n-    }\n-\n-    while(len > 0) {\n-        int loff = 0;\n-        int chunkLen = min(buflen, len);\n-        int llen = chunkLen;\n-        (*env)->GetByteArrayRegion(env, data, off, chunkLen, (jbyte *)bufP);\n-\n-        if ((*env)->ExceptionCheck(env)) {\n-            break;\n-        } else {\n-            while(llen > 0) {\n-                int n = NET_Send(fd, bufP + loff, llen, 0);\n-                if (n > 0) {\n-                    llen -= n;\n-                    loff += n;\n-                    continue;\n-                }\n-                JNU_ThrowByNameWithMessageAndLastError\n-                    (env, \"java\/net\/SocketException\", \"Write failed\");\n-                if (bufP != BUF) {\n-                    free(bufP);\n-                }\n-                return;\n-            }\n-            len -= chunkLen;\n-            off += chunkLen;\n-        }\n-    }\n-\n-    if (bufP != BUF) {\n-        free(bufP);\n-    }\n-}\n","filename":"src\/java.base\/unix\/native\/libnet\/SocketOutputStream.c","additions":0,"deletions":126,"binary":false,"changes":126,"status":"deleted"},{"patch":"@@ -1,105 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package java.net;\n-\n-import java.util.Properties;\n-import sun.security.action.GetPropertyAction;\n-\n-\/**\n- * This class defines a factory for creating DatagramSocketImpls. It defaults\n- * to creating plain DatagramSocketImpls, but may create other DatagramSocketImpls\n- * by setting the impl.prefix system property.\n- *\n- * For Windows versions lower than Windows Vista a TwoStacksPlainDatagramSocketImpl\n- * is always created. This impl supports IPv6 on these platform where available.\n- *\n- * On Windows platforms greater than Vista that support a dual layer TCP\/IP stack\n- * a DualStackPlainDatagramSocketImpl is created for DatagramSockets. For MulticastSockets\n- * a TwoStacksPlainDatagramSocketImpl is always created. This is to overcome the lack\n- * of behavior defined for multicasting over a dual layer socket by the RFC.\n- *\n- * @author Chris Hegarty\n- *\/\n-\n-class DefaultDatagramSocketImplFactory\n-{\n-    private static final Class<?> prefixImplClass;\n-\n-    \/* java.net.preferIPv4Stack *\/\n-    private static final boolean preferIPv4Stack;\n-\n-    \/* True if exclusive binding is on for Windows *\/\n-    private static final boolean exclusiveBind;\n-\n-    static {\n-        Class<?> prefixImplClassLocal = null;\n-\n-        Properties props = GetPropertyAction.privilegedGetProperties();\n-        preferIPv4Stack = Boolean.parseBoolean(\n-                props.getProperty(\"java.net.preferIPv4Stack\"));\n-\n-        String exclBindProp = props.getProperty(\"sun.net.useExclusiveBind\", \"\");\n-        exclusiveBind = (exclBindProp.isEmpty())\n-                ? true\n-                : Boolean.parseBoolean(exclBindProp);\n-\n-        \/\/ impl.prefix\n-        String prefix = null;\n-        try {\n-            prefix = props.getProperty(\"impl.prefix\");\n-            if (prefix != null)\n-                prefixImplClassLocal = Class.forName(\"java.net.\"+prefix+\"DatagramSocketImpl\");\n-        } catch (Exception e) {\n-            System.err.println(\"Can't find class: java.net.\" +\n-                                prefix +\n-                                \"DatagramSocketImpl: check impl.prefix property\");\n-        }\n-\n-        prefixImplClass = prefixImplClassLocal;\n-    }\n-\n-    \/**\n-     * Creates a new <code>DatagramSocketImpl<\/code> instance.\n-     *\n-     * @param   isMulticast true if this impl is to be used for a MutlicastSocket\n-     * @return  a new instance of <code>PlainDatagramSocketImpl<\/code>.\n-     *\/\n-    static DatagramSocketImpl createDatagramSocketImpl(boolean isMulticast)\n-        throws SocketException {\n-        if (prefixImplClass != null) {\n-            try {\n-                @SuppressWarnings(\"deprecation\")\n-                Object result = prefixImplClass.newInstance();\n-                return (DatagramSocketImpl) result;\n-            } catch (Exception e) {\n-                throw new SocketException(\"can't instantiate DatagramSocketImpl\");\n-            }\n-        } else {\n-            \/\/ Always use TwoStacksPlainDatagramSocketImpl since we need\n-            \/\/ to support multicasting at DatagramSocket level\n-            return new TwoStacksPlainDatagramSocketImpl(exclusiveBind && !isMulticast, isMulticast);\n-        }\n-    }\n-}\n","filename":"src\/java.base\/windows\/classes\/java\/net\/DefaultDatagramSocketImplFactory.java","additions":0,"deletions":105,"binary":false,"changes":105,"status":"deleted"},{"patch":"@@ -1,324 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package java.net;\n-\n-import java.io.IOException;\n-import java.util.Collections;\n-import java.util.HashSet;\n-import java.util.Set;\n-import jdk.internal.access.SharedSecrets;\n-import jdk.internal.access.JavaIOFileDescriptorAccess;\n-\n-import sun.net.ext.ExtendedSocketOptions;\n-\n-\/**\n- * This class defines the plain DatagramSocketImpl that is used on\n- * Windows platforms greater than or equal to Windows Vista. These\n- * platforms have a dual layer TCP\/IP stack and can handle both IPv4\n- * and IPV6 through a single file descriptor.\n- * <p>\n- * Note: Multicasting on a dual layer TCP\/IP stack is always done with\n- * TwoStacksPlainDatagramSocketImpl. This is to overcome the lack\n- * of behavior defined for multicasting over a dual layer socket by the RFC.\n- *\n- * @author Chris Hegarty\n- *\/\n-\n-class DualStackPlainDatagramSocketImpl extends AbstractPlainDatagramSocketImpl\n-{\n-    static JavaIOFileDescriptorAccess fdAccess = SharedSecrets.getJavaIOFileDescriptorAccess();\n-\n-    static {\n-        initIDs();\n-    }\n-\n-    \/\/ true if this socket is exclusively bound\n-    private final boolean exclusiveBind;\n-\n-    \/*\n-     * Set to true if SO_REUSEADDR is set after the socket is bound to\n-     * indicate SO_REUSEADDR is being emulated\n-     *\/\n-    private boolean reuseAddressEmulated;\n-\n-    \/\/ emulates SO_REUSEADDR when exclusiveBind is true and socket is bound\n-    private boolean isReuseAddress;\n-\n-    DualStackPlainDatagramSocketImpl(boolean exclBind) {\n-        super(false);\n-        exclusiveBind = exclBind;\n-    }\n-\n-    protected void datagramSocketCreate() throws SocketException {\n-        if (fd == null)\n-            throw new SocketException(\"Socket closed\");\n-\n-        int newfd = socketCreate();\n-\n-        fdAccess.set(fd, newfd);\n-    }\n-\n-    protected synchronized void bind0(int lport, InetAddress laddr)\n-        throws SocketException {\n-        int nativefd = checkAndReturnNativeFD();\n-\n-        if (laddr == null)\n-            throw new NullPointerException(\"argument address\");\n-\n-        socketBind(nativefd, laddr, lport, exclusiveBind);\n-        if (lport == 0) {\n-            localPort = socketLocalPort(nativefd);\n-        } else {\n-            localPort = lport;\n-        }\n-    }\n-\n-    protected synchronized int peek(InetAddress address) throws IOException {\n-        int nativefd = checkAndReturnNativeFD();\n-\n-        if (address == null)\n-            throw new NullPointerException(\"Null address in peek()\");\n-\n-        \/\/ Use peekData()\n-        DatagramPacket peekPacket = new DatagramPacket(new byte[1], 1);\n-        int peekPort = peekData(peekPacket);\n-        address = peekPacket.getAddress();\n-        return peekPort;\n-    }\n-\n-    protected synchronized int peekData(DatagramPacket p) throws IOException {\n-        int nativefd = checkAndReturnNativeFD();\n-\n-        if (p == null)\n-            throw new NullPointerException(\"packet\");\n-        if (p.getData() == null)\n-            throw new NullPointerException(\"packet buffer\");\n-\n-        return socketReceiveOrPeekData(nativefd, p, timeout, connected, true \/*peek*\/);\n-    }\n-\n-    protected synchronized void receive0(DatagramPacket p) throws IOException {\n-        int nativefd = checkAndReturnNativeFD();\n-\n-        if (p == null)\n-            throw new NullPointerException(\"packet\");\n-        if (p.getData() == null)\n-            throw new NullPointerException(\"packet buffer\");\n-\n-        socketReceiveOrPeekData(nativefd, p, timeout, connected, false \/*receive*\/);\n-    }\n-\n-    protected void send0(DatagramPacket p) throws IOException {\n-        int nativefd = checkAndReturnNativeFD();\n-\n-        if (p == null)\n-            throw new NullPointerException(\"null packet\");\n-\n-        if (p.getAddress() == null ||p.getData() ==null)\n-            throw new NullPointerException(\"null address || null buffer\");\n-\n-        socketSend(nativefd, p.getData(), p.getOffset(), p.getLength(),\n-                   p.getAddress(), p.getPort(), connected);\n-    }\n-\n-    protected void connect0(InetAddress address, int port) throws SocketException {\n-        int nativefd = checkAndReturnNativeFD();\n-\n-        if (address == null)\n-            throw new NullPointerException(\"address\");\n-\n-        socketConnect(nativefd, address, port);\n-    }\n-\n-    protected void disconnect0(int family \/*unused*\/) {\n-        if (fd == null || !fd.valid())\n-            return;   \/\/ disconnect doesn't throw any exceptions\n-\n-        socketDisconnect(fdAccess.get(fd));\n-    }\n-\n-    protected void datagramSocketClose() {\n-        if (fd == null || !fd.valid())\n-            return;   \/\/ close doesn't throw any exceptions\n-\n-        socketClose(fdAccess.get(fd));\n-        fdAccess.set(fd, -1);\n-    }\n-\n-    @SuppressWarnings(\"fallthrough\")\n-    protected void socketSetOption(int opt, Object val) throws SocketException {\n-        int nativefd = checkAndReturnNativeFD();\n-\n-        int optionValue = 0;\n-\n-        \/\/ SO_REUSEPORT is not supported on Windows.\n-        if (opt == SO_REUSEPORT) {\n-            throw new UnsupportedOperationException(\"unsupported option\");\n-        }\n-\n-        switch(opt) {\n-            case IP_TOS :\n-            case SO_RCVBUF :\n-            case SO_SNDBUF :\n-                optionValue = ((Integer)val).intValue();\n-                break;\n-            case SO_REUSEADDR :\n-                if (exclusiveBind && localPort != 0)  {\n-                    \/\/ socket already bound, emulate SO_REUSEADDR\n-                    reuseAddressEmulated = true;\n-                    isReuseAddress = (Boolean)val;\n-                    return;\n-                }\n-                \/\/Intentional fallthrough\n-            case SO_BROADCAST :\n-                optionValue = ((Boolean)val).booleanValue() ? 1 : 0;\n-                break;\n-            default: \/* shouldn't get here *\/\n-                throw new SocketException(\"Option not supported\");\n-        }\n-\n-        socketSetIntOption(nativefd, opt, optionValue);\n-    }\n-\n-    protected Object socketGetOption(int opt) throws SocketException {\n-        int nativefd = checkAndReturnNativeFD();\n-\n-         \/\/ SO_BINDADDR is not a socket option.\n-        if (opt == SO_BINDADDR) {\n-            return socketLocalAddress(nativefd);\n-        }\n-        if (opt == SO_REUSEADDR && reuseAddressEmulated)\n-            return isReuseAddress;\n-        \/\/ SO_REUSEPORT is not supported on Windows.\n-        if (opt == SO_REUSEPORT)\n-            throw new UnsupportedOperationException(\"unsupported option\");\n-\n-        int value = socketGetIntOption(nativefd, opt);\n-        Object returnValue = null;\n-\n-        switch (opt) {\n-            case SO_REUSEADDR :\n-            case SO_BROADCAST :\n-                returnValue =  (value == 0) ? Boolean.FALSE : Boolean.TRUE;\n-                break;\n-            case IP_TOS :\n-            case SO_RCVBUF :\n-            case SO_SNDBUF :\n-                returnValue = Integer.valueOf(value);\n-                break;\n-            default: \/* shouldn't get here *\/\n-                throw new SocketException(\"Option not supported\");\n-        }\n-\n-        return returnValue;\n-    }\n-\n-    @Override\n-    protected Set<SocketOption<?>> supportedOptions() {\n-        HashSet<SocketOption<?>> options = new HashSet<>();\n-        options.add(StandardSocketOptions.SO_SNDBUF);\n-        options.add(StandardSocketOptions.SO_RCVBUF);\n-        options.add(StandardSocketOptions.SO_REUSEADDR);\n-        options.add(StandardSocketOptions.SO_BROADCAST);\n-        options.add(StandardSocketOptions.IP_TOS);\n-\n-        options.addAll(ExtendedSocketOptions.datagramSocketOptions());\n-        return Collections.unmodifiableSet(options);\n-    }\n-\n-    \/* Multicast specific methods.\n-     * Multicasting on a dual layer TCP\/IP stack is always done with\n-     * TwoStacksPlainDatagramSocketImpl. This is to overcome the lack\n-     * of behavior defined for multicasting over a dual layer socket by the RFC.\n-     *\/\n-    protected void join(InetAddress inetaddr, NetworkInterface netIf)\n-        throws IOException {\n-        throw new IOException(\"Method not implemented!\");\n-    }\n-\n-    protected void leave(InetAddress inetaddr, NetworkInterface netIf)\n-        throws IOException {\n-        throw new IOException(\"Method not implemented!\");\n-    }\n-\n-    protected void setTimeToLive(int ttl) throws IOException {\n-        throw new IOException(\"Method not implemented!\");\n-    }\n-\n-    protected int getTimeToLive() throws IOException {\n-        throw new IOException(\"Method not implemented!\");\n-    }\n-\n-    @Deprecated\n-    protected void setTTL(byte ttl) throws IOException {\n-        throw new IOException(\"Method not implemented!\");\n-    }\n-\n-    @Deprecated\n-    protected byte getTTL() throws IOException {\n-        throw new IOException(\"Method not implemented!\");\n-    }\n-    \/* END Multicast specific methods *\/\n-\n-    private int checkAndReturnNativeFD() throws SocketException {\n-        if (fd == null || !fd.valid())\n-            throw new SocketException(\"Socket closed\");\n-\n-        return fdAccess.get(fd);\n-    }\n-\n-    \/* Native methods *\/\n-\n-    private static native void initIDs();\n-\n-    private static native int socketCreate();\n-\n-    private static native void socketBind(int fd, InetAddress localAddress,\n-            int localport, boolean exclBind) throws SocketException;\n-\n-    private static native void socketConnect(int fd, InetAddress address, int port)\n-        throws SocketException;\n-\n-    private static native void socketDisconnect(int fd);\n-\n-    private static native void socketClose(int fd);\n-\n-    private static native int socketLocalPort(int fd) throws SocketException;\n-\n-    private static native Object socketLocalAddress(int fd) throws SocketException;\n-\n-    private static native int socketReceiveOrPeekData(int fd, DatagramPacket packet,\n-        int timeout, boolean connected, boolean peek) throws IOException;\n-\n-    private static native void socketSend(int fd, byte[] data, int offset, int length,\n-        InetAddress address, int port, boolean connected) throws IOException;\n-\n-    private static native void socketSetIntOption(int fd, int cmd,\n-        int optionValue) throws SocketException;\n-\n-    private static native int socketGetIntOption(int fd, int cmd) throws SocketException;\n-\n-    native int dataAvailable();\n-}\n","filename":"src\/java.base\/windows\/classes\/java\/net\/DualStackPlainDatagramSocketImpl.java","additions":0,"deletions":324,"binary":false,"changes":324,"status":"deleted"},{"patch":"@@ -1,354 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package java.net;\n-\n-import java.io.IOException;\n-import java.io.FileDescriptor;\n-import java.security.AccessController;\n-\n-import sun.security.action.GetPropertyAction;\n-import jdk.internal.access.SharedSecrets;\n-import jdk.internal.access.JavaIOFileDescriptorAccess;\n-\n-\/**\n- * On Windows system we simply delegate to native methods.\n- *\n- * @author Chris Hegarty\n- *\/\n-\n-class PlainSocketImpl extends AbstractPlainSocketImpl {\n-\n-    private static final JavaIOFileDescriptorAccess fdAccess =\n-        SharedSecrets.getJavaIOFileDescriptorAccess();\n-\n-    @SuppressWarnings(\"removal\")\n-    private static final boolean preferIPv4Stack =\n-            Boolean.parseBoolean(AccessController.doPrivileged(\n-                new GetPropertyAction(\"java.net.preferIPv4Stack\", \"false\")));\n-\n-    \/**\n-     * Empty value of sun.net.useExclusiveBind is treated as 'true'.\n-     *\/\n-    private static final boolean useExclusiveBind;\n-\n-    static {\n-        @SuppressWarnings(\"removal\")\n-        String exclBindProp = AccessController.doPrivileged(\n-                new GetPropertyAction(\"sun.net.useExclusiveBind\", \"\"));\n-        useExclusiveBind = exclBindProp.isEmpty()\n-                || Boolean.parseBoolean(exclBindProp);\n-    }\n-\n-    \/\/ emulates SO_REUSEADDR when useExclusiveBind is true\n-    private boolean isReuseAddress;\n-\n-    \/**\n-     * Constructs an empty instance.\n-     *\/\n-    PlainSocketImpl(boolean isServer) {\n-        super(isServer);\n-    }\n-\n-    @Override\n-    void socketCreate(boolean stream) throws IOException {\n-        if (fd == null)\n-            throw new SocketException(\"Socket closed\");\n-\n-        int newfd = socket0(stream);\n-\n-        fdAccess.set(fd, newfd);\n-    }\n-\n-    @Override\n-    void socketConnect(InetAddress address, int port, int timeout)\n-        throws IOException {\n-        int nativefd = checkAndReturnNativeFD();\n-\n-        if (address == null)\n-            throw new NullPointerException(\"inet address argument is null.\");\n-\n-        if (preferIPv4Stack && !(address instanceof Inet4Address))\n-            throw new SocketException(\"Protocol family not supported\");\n-\n-        int connectResult;\n-        if (timeout <= 0) {\n-            connectResult = connect0(nativefd, address, port);\n-        } else {\n-            configureBlocking(nativefd, false);\n-            try {\n-                connectResult = connect0(nativefd, address, port);\n-                if (connectResult == WOULDBLOCK) {\n-                    waitForConnect(nativefd, timeout);\n-                }\n-            } finally {\n-                configureBlocking(nativefd, true);\n-            }\n-        }\n-        \/*\n-         * We need to set the local port field. If bind was called\n-         * previous to the connect (by the client) then localport field\n-         * will already be set.\n-         *\/\n-        if (localport == 0)\n-            localport = localPort0(nativefd);\n-    }\n-\n-    @Override\n-    void socketBind(InetAddress address, int port) throws IOException {\n-        int nativefd = checkAndReturnNativeFD();\n-\n-        if (address == null)\n-            throw new NullPointerException(\"inet address argument is null.\");\n-\n-        if (preferIPv4Stack && !(address instanceof Inet4Address))\n-            throw new SocketException(\"Protocol family not supported\");\n-\n-        bind0(nativefd, address, port, useExclusiveBind);\n-        if (port == 0) {\n-            localport = localPort0(nativefd);\n-        } else {\n-            localport = port;\n-        }\n-\n-        this.address = address;\n-    }\n-\n-    @Override\n-    void socketListen(int backlog) throws IOException {\n-        int nativefd = checkAndReturnNativeFD();\n-\n-        listen0(nativefd, backlog);\n-    }\n-\n-    @Override\n-    void socketAccept(SocketImpl s) throws IOException {\n-        int nativefd = checkAndReturnNativeFD();\n-\n-        if (s == null)\n-            throw new NullPointerException(\"socket is null\");\n-\n-        int newfd = -1;\n-        InetSocketAddress[] isaa = new InetSocketAddress[1];\n-        if (timeout <= 0) {\n-            newfd = accept0(nativefd, isaa);\n-        } else {\n-            configureBlocking(nativefd, false);\n-            try {\n-                waitForNewConnection(nativefd, timeout);\n-                newfd = accept0(nativefd, isaa);\n-                if (newfd != -1) {\n-                    configureBlocking(newfd, true);\n-                }\n-            } finally {\n-                configureBlocking(nativefd, true);\n-            }\n-        }\n-        \/* Update (SocketImpl)s' fd *\/\n-        fdAccess.set(s.fd, newfd);\n-        \/* Update socketImpls remote port, address and localport *\/\n-        InetSocketAddress isa = isaa[0];\n-        s.port = isa.getPort();\n-        s.address = isa.getAddress();\n-        s.localport = localport;\n-        if (preferIPv4Stack && !(s.address instanceof Inet4Address))\n-            throw new SocketException(\"Protocol family not supported\");\n-    }\n-\n-    @Override\n-    int socketAvailable() throws IOException {\n-        int nativefd = checkAndReturnNativeFD();\n-        return available0(nativefd);\n-    }\n-\n-    @Override\n-    void socketClose0(boolean useDeferredClose\/*unused*\/) throws IOException {\n-        if (fd == null)\n-            throw new SocketException(\"Socket closed\");\n-\n-        if (!fd.valid())\n-            return;\n-\n-        final int nativefd = fdAccess.get(fd);\n-        fdAccess.set(fd, -1);\n-        close0(nativefd);\n-    }\n-\n-    @Override\n-    void socketShutdown(int howto) throws IOException {\n-        int nativefd = checkAndReturnNativeFD();\n-        shutdown0(nativefd, howto);\n-    }\n-\n-    \/\/ Intentional fallthrough after SO_REUSEADDR\n-    @SuppressWarnings(\"fallthrough\")\n-    @Override\n-    void socketSetOption(int opt, boolean on, Object value)\n-        throws SocketException {\n-\n-        \/\/ SO_REUSEPORT is not supported on Windows.\n-        if (opt == SO_REUSEPORT) {\n-            throw new UnsupportedOperationException(\"unsupported option\");\n-        }\n-\n-        int nativefd = checkAndReturnNativeFD();\n-\n-        if (opt == SO_TIMEOUT) {\n-            if (preferIPv4Stack) {\n-                \/\/ Don't enable the socket option on ServerSocket as it's\n-                \/\/ meaningless (we don't receive on a ServerSocket).\n-                if (!isServer) {\n-                    setSoTimeout0(nativefd, ((Integer)value).intValue());\n-                }\n-            } \/\/ else timeout is implemented through select.\n-            return;\n-        }\n-\n-        int optionValue = 0;\n-\n-        switch(opt) {\n-            case SO_REUSEADDR:\n-                if (useExclusiveBind) {\n-                    \/\/ SO_REUSEADDR emulated when using exclusive bind\n-                    isReuseAddress = on;\n-                    return;\n-                }\n-                \/\/ intentional fallthrough\n-            case TCP_NODELAY:\n-            case SO_OOBINLINE:\n-            case SO_KEEPALIVE:\n-                optionValue = on ? 1 : 0;\n-                break;\n-            case SO_SNDBUF:\n-            case SO_RCVBUF:\n-            case IP_TOS:\n-                optionValue = ((Integer)value).intValue();\n-                break;\n-            case SO_LINGER:\n-                if (on) {\n-                    optionValue = ((Integer)value).intValue();\n-                } else {\n-                    optionValue = -1;\n-                }\n-                break;\n-            default :\/* shouldn't get here *\/\n-                throw new SocketException(\"Option not supported\");\n-        }\n-\n-        setIntOption(nativefd, opt, optionValue);\n-    }\n-\n-    @Override\n-    int socketGetOption(int opt, Object iaContainerObj)\n-        throws SocketException {\n-\n-        \/\/ SO_REUSEPORT is not supported on Windows.\n-        if (opt == SO_REUSEPORT) {\n-            throw new UnsupportedOperationException(\"unsupported option\");\n-        }\n-\n-        int nativefd = checkAndReturnNativeFD();\n-\n-        \/\/ SO_BINDADDR is not a socket option.\n-        if (opt == SO_BINDADDR) {\n-            localAddress(nativefd, (InetAddressContainer)iaContainerObj);\n-            return 0;  \/\/ return value doesn't matter.\n-        }\n-\n-        \/\/ SO_REUSEADDR emulated when using exclusive bind\n-        if (opt == SO_REUSEADDR && useExclusiveBind)\n-            return isReuseAddress ? 1 : -1;\n-\n-        int value = getIntOption(nativefd, opt);\n-\n-        switch (opt) {\n-            case TCP_NODELAY:\n-            case SO_OOBINLINE:\n-            case SO_KEEPALIVE:\n-            case SO_REUSEADDR:\n-                return (value == 0) ? -1 : 1;\n-        }\n-        return value;\n-    }\n-\n-    @Override\n-    void socketSendUrgentData(int data) throws IOException {\n-        int nativefd = checkAndReturnNativeFD();\n-        sendOOB(nativefd, data);\n-    }\n-\n-    private int checkAndReturnNativeFD() throws SocketException {\n-        if (fd == null || !fd.valid())\n-            throw new SocketException(\"Socket closed\");\n-\n-        return fdAccess.get(fd);\n-    }\n-\n-    static final int WOULDBLOCK = -2;       \/\/ Nothing available (non-blocking)\n-\n-    static {\n-        initIDs();\n-    }\n-\n-    \/* Native methods *\/\n-\n-    static native void initIDs();\n-\n-    static native int socket0(boolean stream) throws IOException;\n-\n-    static native void bind0(int fd, InetAddress localAddress, int localport,\n-                             boolean exclBind)\n-        throws IOException;\n-\n-    static native int connect0(int fd, InetAddress remote, int remotePort)\n-        throws IOException;\n-\n-    static native void waitForConnect(int fd, int timeout) throws IOException;\n-\n-    static native int localPort0(int fd) throws IOException;\n-\n-    static native void localAddress(int fd, InetAddressContainer in) throws SocketException;\n-\n-    static native void listen0(int fd, int backlog) throws IOException;\n-\n-    static native int accept0(int fd, InetSocketAddress[] isaa) throws IOException;\n-\n-    static native void waitForNewConnection(int fd, int timeout) throws IOException;\n-\n-    static native int available0(int fd) throws IOException;\n-\n-    static native void close0(int fd) throws IOException;\n-\n-    static native void shutdown0(int fd, int howto) throws IOException;\n-\n-    static native void setIntOption(int fd, int cmd, int optionValue) throws SocketException;\n-\n-    static native void setSoTimeout0(int fd, int timeout) throws SocketException;\n-\n-    static native int getIntOption(int fd, int cmd) throws SocketException;\n-\n-    static native void sendOOB(int fd, int data) throws IOException;\n-\n-    static native void configureBlocking(int fd, boolean blocking) throws IOException;\n-}\n","filename":"src\/java.base\/windows\/classes\/java\/net\/PlainSocketImpl.java","additions":0,"deletions":354,"binary":false,"changes":354,"status":"deleted"},{"patch":"@@ -1,238 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package java.net;\n-\n-import java.io.IOException;\n-import java.io.FileDescriptor;\n-import sun.net.ResourceManager;\n-\n-\/**\n- * This class defines the plain DatagramSocketImpl that is used for all\n- * Windows versions lower than Vista. It adds support for IPv6 on\n- * these platforms where available.\n- *\n- * For backward compatibility windows platforms that do not have IPv6\n- * support also use this implementation, and fd1 gets set to null\n- * during socket creation.\n- *\n- * @author Chris Hegarty\n- *\/\n-\n-final class TwoStacksPlainDatagramSocketImpl extends AbstractPlainDatagramSocketImpl\n-{\n-    \/* Used for IPv6 on Windows only *\/\n-    private FileDescriptor fd1;\n-\n-    \/*\n-     * Needed for ipv6 on windows because we need to know\n-     * if the socket was bound to ::0 or 0.0.0.0, when a caller\n-     * asks for it. In this case, both sockets are used, but we\n-     * don't know whether the caller requested ::0 or 0.0.0.0\n-     * and need to remember it here.\n-     *\/\n-    private InetAddress anyLocalBoundAddr=null;\n-\n-    private int fduse=-1; \/* saved between peek() and receive() calls *\/\n-\n-    \/* saved between successive calls to receive, if data is detected\n-     * on both sockets at same time. To ensure that one socket is not\n-     * starved, they rotate using this field\n-     *\/\n-    private int lastfd=-1;\n-\n-    static {\n-        init();\n-    }\n-\n-    \/\/ true if this socket is exclusively bound\n-    private final boolean exclusiveBind;\n-\n-    \/*\n-     * Set to true if SO_REUSEADDR is set after the socket is bound to\n-     * indicate SO_REUSEADDR is being emulated\n-     *\/\n-    private boolean reuseAddressEmulated;\n-\n-    \/\/ emulates SO_REUSEADDR when exclusiveBind is true and socket is bound\n-    private boolean isReuseAddress;\n-\n-    TwoStacksPlainDatagramSocketImpl(boolean exclBind, boolean isMulticast) {\n-        super(isMulticast);\n-        exclusiveBind = exclBind;\n-    }\n-\n-    protected synchronized void create() throws SocketException {\n-        fd1 = new FileDescriptor();\n-        try {\n-            super.create();\n-            \/\/ make SocketCleanable treat fd1 as a stream socket\n-            \/\/ to avoid touching the counter in ResourceManager\n-            SocketCleanable.register(fd1, true);\n-        } catch (SocketException e) {\n-            fd1 = null;\n-            throw e;\n-        }\n-    }\n-\n-    protected synchronized void bind(int lport, InetAddress laddr)\n-        throws SocketException {\n-        super.bind(lport, laddr);\n-        if (laddr.isAnyLocalAddress()) {\n-            anyLocalBoundAddr = laddr;\n-        }\n-    }\n-\n-    @Override\n-    protected synchronized void bind0(int lport, InetAddress laddr)\n-        throws SocketException\n-    {\n-        \/\/ The native bind0 may close one or both of the underlying file\n-        \/\/ descriptors, and even create new sockets, so the safest course of\n-        \/\/ action is to unregister the socket cleaners, and register afterwards.\n-        SocketCleanable.unregister(fd);\n-        SocketCleanable.unregister(fd1);\n-\n-        bind0(lport, laddr, exclusiveBind);\n-\n-        SocketCleanable.register(fd, false);\n-        \/\/ make SocketCleanable treat fd1 as a stream socket\n-        \/\/ to avoid touching the counter in ResourceManager\n-        SocketCleanable.register(fd1, true);\n-    }\n-\n-    protected synchronized void receive(DatagramPacket p)\n-        throws IOException {\n-        try {\n-            receive0(p);\n-        } finally {\n-            fduse = -1;\n-        }\n-    }\n-\n-    public Object getOption(int optID) throws SocketException {\n-        if (isClosed()) {\n-            throw new SocketException(\"Socket Closed\");\n-        }\n-\n-        if (optID == SO_BINDADDR) {\n-            if ((fd != null && fd1 != null) && !connected) {\n-                return anyLocalBoundAddr;\n-            }\n-            int family = connectedAddress == null ? -1 : connectedAddress.holder().getFamily();\n-            return socketLocalAddress(family);\n-        } else if (optID == SO_REUSEADDR && reuseAddressEmulated) {\n-            return isReuseAddress;\n-        } else if (optID == SO_REUSEPORT) {\n-            \/\/ SO_REUSEPORT is not supported on Windows.\n-            throw new UnsupportedOperationException(\"unsupported option\");\n-        } else {\n-            return super.getOption(optID);\n-        }\n-    }\n-\n-    protected void socketSetOption(int opt, Object val)\n-        throws SocketException\n-    {\n-        if (opt == SO_REUSEADDR && exclusiveBind && localPort != 0)  {\n-            \/\/ socket already bound, emulate\n-            reuseAddressEmulated = true;\n-            isReuseAddress = (Boolean)val;\n-        } else if (opt == SO_REUSEPORT) {\n-            \/\/ SO_REUSEPORT is not supported on Windows.\n-            throw new UnsupportedOperationException(\"unsupported option\");\n-        } else {\n-            socketNativeSetOption(opt, val);\n-        }\n-\n-    }\n-\n-    protected boolean isClosed() {\n-        return (fd == null && fd1 == null) ? true : false;\n-    }\n-\n-    protected void close() {\n-        if (fd != null || fd1 != null) {\n-            SocketCleanable.unregister(fd);\n-            SocketCleanable.unregister(fd1);\n-            datagramSocketClose();\n-            ResourceManager.afterUdpClose();\n-            fd = null;\n-            fd1 = null;\n-        }\n-    }\n-\n-    \/* Native methods *\/\n-\n-    protected synchronized native void bind0(int lport, InetAddress laddr,\n-                                             boolean exclBind)\n-        throws SocketException;\n-\n-    protected native void send0(DatagramPacket p) throws IOException;\n-\n-    protected synchronized native int peek(InetAddress i) throws IOException;\n-\n-    protected synchronized native int peekData(DatagramPacket p) throws IOException;\n-\n-    protected synchronized native void receive0(DatagramPacket p)\n-        throws IOException;\n-\n-    protected native void setTimeToLive(int ttl) throws IOException;\n-\n-    protected native int getTimeToLive() throws IOException;\n-\n-    @Deprecated\n-    protected native void setTTL(byte ttl) throws IOException;\n-\n-    @Deprecated\n-    protected native byte getTTL() throws IOException;\n-\n-    protected native void join(InetAddress inetaddr, NetworkInterface netIf)\n-        throws IOException;\n-\n-    protected native void leave(InetAddress inetaddr, NetworkInterface netIf)\n-        throws IOException;\n-\n-    protected native void datagramSocketCreate() throws SocketException;\n-\n-    protected native void datagramSocketClose();\n-\n-    protected native void socketNativeSetOption(int opt, Object val)\n-        throws SocketException;\n-\n-    protected native Object socketGetOption(int opt) throws SocketException;\n-\n-    protected native void connect0(InetAddress address, int port) throws SocketException;\n-\n-    protected native Object socketLocalAddress(int family) throws SocketException;\n-\n-    protected native void disconnect0(int family);\n-\n-    native int dataAvailable();\n-\n-    \/**\n-     * Perform class load-time initializations.\n-     *\/\n-    private static native void init();\n-}\n","filename":"src\/java.base\/windows\/classes\/java\/net\/TwoStacksPlainDatagramSocketImpl.java","additions":0,"deletions":238,"binary":false,"changes":238,"status":"deleted"},{"patch":"@@ -1,539 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-#include \"net_util.h\"\n-\n-#include \"java_net_DualStackPlainDatagramSocketImpl.h\"\n-\n-\/*\n- * This function \"purges\" all outstanding ICMP port unreachable packets\n- * outstanding on a socket and returns JNI_TRUE if any ICMP messages\n- * have been purged. The rational for purging is to emulate normal BSD\n- * behaviour whereby receiving a \"connection reset\" status resets the\n- * socket.\n- *\/\n-static jboolean purgeOutstandingICMP(JNIEnv *env, jint fd)\n-{\n-    jboolean got_icmp = JNI_FALSE;\n-    char buf[1];\n-    fd_set tbl;\n-    struct timeval t = { 0, 0 };\n-    SOCKETADDRESS rmtaddr;\n-    int addrlen = sizeof(rmtaddr);\n-\n-    \/*\n-     * Peek at the queue to see if there is an ICMP port unreachable. If there\n-     * is then receive it.\n-     *\/\n-    FD_ZERO(&tbl);\n-    FD_SET(fd, &tbl);\n-    while(1) {\n-        if (select(\/*ignored*\/fd+1, &tbl, 0, 0, &t) <= 0) {\n-            break;\n-        }\n-        if (recvfrom(fd, buf, 1, MSG_PEEK,\n-                     &rmtaddr.sa, &addrlen) != SOCKET_ERROR) {\n-            break;\n-        }\n-        if (WSAGetLastError() != WSAECONNRESET) {\n-            \/* some other error - we don't care here *\/\n-            break;\n-        }\n-\n-        recvfrom(fd, buf, 1, 0, &rmtaddr.sa, &addrlen);\n-        got_icmp = JNI_TRUE;\n-    }\n-\n-    return got_icmp;\n-}\n-\n-static jfieldID IO_fd_fdID = NULL;\n-static jfieldID pdsi_fdID = NULL;\n-\n-\/*\n- * Class:     java_net_DualStackPlainDatagramSocketImpl\n- * Method:    initIDs\n- * Signature: ()V\n- *\/\n-JNIEXPORT void JNICALL Java_java_net_DualStackPlainDatagramSocketImpl_initIDs\n-  (JNIEnv *env, jclass clazz)\n-{\n-    pdsi_fdID = (*env)->GetFieldID(env, clazz, \"fd\",\n-                                   \"Ljava\/io\/FileDescriptor;\");\n-    CHECK_NULL(pdsi_fdID);\n-    IO_fd_fdID = NET_GetFileDescriptorID(env);\n-    CHECK_NULL(IO_fd_fdID);\n-    JNU_CHECK_EXCEPTION(env);\n-\n-    initInetAddressIDs(env);\n-}\n-\n-\/*\n- * Class:     java_net_DualStackPlainDatagramSocketImpl\n- * Method:    socketCreate\n- * Signature: ()I\n- *\/\n-JNIEXPORT jint JNICALL Java_java_net_DualStackPlainDatagramSocketImpl_socketCreate\n-  (JNIEnv *env, jclass clazz) {\n-    int fd, rv, opt=0, t=TRUE;\n-    DWORD x1, x2; \/* ignored result codes *\/\n-\n-    fd = (int) socket(AF_INET6, SOCK_DGRAM, 0);\n-    if (fd == INVALID_SOCKET) {\n-        NET_ThrowNew(env, WSAGetLastError(), \"Socket creation failed\");\n-        return -1;\n-    }\n-\n-    rv = setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, (char *) &opt, sizeof(opt));\n-    if (rv == SOCKET_ERROR) {\n-        NET_ThrowNew(env, WSAGetLastError(), \"Socket creation failed\");\n-        closesocket(fd);\n-        return -1;\n-    }\n-\n-    SetHandleInformation((HANDLE)(UINT_PTR)fd, HANDLE_FLAG_INHERIT, FALSE);\n-    NET_SetSockOpt(fd, SOL_SOCKET, SO_BROADCAST, (char*)&t, sizeof(BOOL));\n-\n-    \/* SIO_UDP_CONNRESET fixes a \"bug\" introduced in Windows 2000, which\n-     * returns connection reset errors on unconnected UDP sockets (as well\n-     * as connected sockets). The solution is to only enable this feature\n-     * when the socket is connected.\n-     *\/\n-    t = FALSE;\n-    WSAIoctl(fd, SIO_UDP_CONNRESET, &t, sizeof(t), &x1, sizeof(x1), &x2, 0, 0);\n-\n-    return fd;\n-}\n-\n-\/*\n- * Class:     java_net_DualStackPlainDatagramSocketImpl\n- * Method:    socketBind\n- * Signature: (ILjava\/net\/InetAddress;I)V\n- *\/\n-JNIEXPORT void JNICALL Java_java_net_DualStackPlainDatagramSocketImpl_socketBind\n-  (JNIEnv *env, jclass clazz, jint fd, jobject iaObj, jint port, jboolean exclBind) {\n-    SOCKETADDRESS sa;\n-    int rv, sa_len = 0;\n-\n-    if (NET_InetAddressToSockaddr(env, iaObj, port, &sa,\n-                                 &sa_len, JNI_TRUE) != 0) {\n-        return;\n-    }\n-    rv = NET_WinBind(fd, &sa, sa_len, exclBind);\n-\n-    if (rv == SOCKET_ERROR) {\n-        if (WSAGetLastError() == WSAEACCES) {\n-            WSASetLastError(WSAEADDRINUSE);\n-        }\n-        NET_ThrowNew(env, WSAGetLastError(), \"Cannot bind\");\n-    }\n-}\n-\n-\/*\n- * Class:     java_net_DualStackPlainDatagramSocketImpl\n- * Method:    socketConnect\n- * Signature: (ILjava\/net\/InetAddress;I)V\n- *\/\n-JNIEXPORT void JNICALL Java_java_net_DualStackPlainDatagramSocketImpl_socketConnect\n-  (JNIEnv *env, jclass clazz, jint fd, jobject iaObj, jint port) {\n-    SOCKETADDRESS sa;\n-    int rv, sa_len = 0, t;\n-    DWORD x1, x2; \/* ignored result codes *\/\n-\n-    if (NET_InetAddressToSockaddr(env, iaObj, port, &sa,\n-                                   &sa_len, JNI_TRUE) != 0) {\n-        return;\n-    }\n-\n-    rv = connect(fd, &sa.sa, sa_len);\n-    if (rv == SOCKET_ERROR) {\n-        NET_ThrowNew(env, WSAGetLastError(), \"connect\");\n-        return;\n-    }\n-\n-    \/* see comment in socketCreate *\/\n-    t = TRUE;\n-    WSAIoctl(fd, SIO_UDP_CONNRESET, &t, sizeof(t), &x1, sizeof(x1), &x2, 0, 0);\n-}\n-\n-\/*\n- * Class:     java_net_DualStackPlainDatagramSocketImpl\n- * Method:    socketDisconnect\n- * Signature: (I)V\n- *\/\n-JNIEXPORT void JNICALL Java_java_net_DualStackPlainDatagramSocketImpl_socketDisconnect\n-  (JNIEnv *env, jclass clazz, jint fd ) {\n-    SOCKETADDRESS sa;\n-    int sa_len = sizeof(sa);\n-    DWORD x1, x2; \/* ignored result codes *\/\n-    int t = FALSE;\n-\n-    memset(&sa, 0, sa_len);\n-    connect(fd, &sa.sa, sa_len);\n-\n-    \/* see comment in socketCreate *\/\n-    WSAIoctl(fd, SIO_UDP_CONNRESET, &t, sizeof(t), &x1, sizeof(x1), &x2, 0, 0);\n-}\n-\n-\/*\n- * Class:     java_net_DualStackPlainDatagramSocketImpl\n- * Method:    socketClose\n- * Signature: (I)V\n- *\/\n-JNIEXPORT void JNICALL Java_java_net_DualStackPlainDatagramSocketImpl_socketClose\n-  (JNIEnv *env, jclass clazz , jint fd) {\n-    NET_SocketClose(fd);\n-}\n-\n-\n-\/*\n- * Class:     java_net_DualStackPlainDatagramSocketImpl\n- * Method:    socketLocalPort\n- * Signature: (I)I\n- *\/\n-JNIEXPORT jint JNICALL Java_java_net_DualStackPlainDatagramSocketImpl_socketLocalPort\n-  (JNIEnv *env, jclass clazz, jint fd) {\n-    SOCKETADDRESS sa;\n-    int len = sizeof(sa);\n-\n-    if (getsockname(fd, &sa.sa, &len) == SOCKET_ERROR) {\n-        NET_ThrowNew(env, WSAGetLastError(), \"getsockname\");\n-        return -1;\n-    }\n-    return (int) ntohs((u_short)GET_PORT(&sa));\n-}\n-\n-\/*\n- * Class:     java_net_DualStackPlainDatagramSocketImpl\n- * Method:    socketLocalAddress\n- * Signature: (I)Ljava\/lang\/Object;\n- *\/\n-JNIEXPORT jobject JNICALL Java_java_net_DualStackPlainDatagramSocketImpl_socketLocalAddress\n-  (JNIEnv *env , jclass clazz, jint fd) {\n-    SOCKETADDRESS sa;\n-    int len = sizeof(sa);\n-    jobject iaObj;\n-    int port;\n-\n-    if (getsockname(fd, &sa.sa, &len) == SOCKET_ERROR) {\n-        NET_ThrowNew(env, WSAGetLastError(), \"Error getting socket name\");\n-        return NULL;\n-    }\n-\n-    iaObj = NET_SockaddrToInetAddress(env, &sa, &port);\n-    return iaObj;\n-}\n-\n-\/*\n- * Class:     java_net_DualStackPlainDatagramSocketImpl\n- * Method:    socketReceiveOrPeekData\n- * Signature: (ILjava\/net\/DatagramPacket;IZZ)I\n- *\/\n-JNIEXPORT jint JNICALL Java_java_net_DualStackPlainDatagramSocketImpl_socketReceiveOrPeekData\n-  (JNIEnv *env, jclass clazz, jint fd, jobject dpObj,\n-   jint timeout, jboolean connected, jboolean peek) {\n-    SOCKETADDRESS sa;\n-    int sa_len = sizeof(sa);\n-    int port, rv, flags=0;\n-    char BUF[MAX_BUFFER_LEN];\n-    char *fullPacket;\n-    BOOL retry;\n-    jlong prevTime = 0;\n-\n-    jint packetBufferOffset, packetBufferLen;\n-    jbyteArray packetBuffer;\n-\n-    \/* if we are only peeking. Called from peekData *\/\n-    if (peek) {\n-        flags = MSG_PEEK;\n-    }\n-\n-    packetBuffer = (*env)->GetObjectField(env, dpObj, dp_bufID);\n-    packetBufferOffset = (*env)->GetIntField(env, dpObj, dp_offsetID);\n-    packetBufferLen = (*env)->GetIntField(env, dpObj, dp_bufLengthID);\n-    \/* Note: the buffer needn't be greater than 65,536 (0xFFFF)\n-    * the max size of an IP packet. Anything bigger is truncated anyway.\n-    *\/\n-    if (packetBufferLen > MAX_PACKET_LEN) {\n-        packetBufferLen = MAX_PACKET_LEN;\n-    }\n-\n-    if (packetBufferLen > MAX_BUFFER_LEN) {\n-        fullPacket = (char *)malloc(packetBufferLen);\n-        if (!fullPacket) {\n-            JNU_ThrowOutOfMemoryError(env, \"Native heap allocation failed\");\n-            return -1;\n-        }\n-    } else {\n-        fullPacket = &(BUF[0]);\n-    }\n-\n-    do {\n-        retry = FALSE;\n-\n-        if (timeout) {\n-            if (prevTime == 0) {\n-                prevTime = JVM_CurrentTimeMillis(env, 0);\n-            }\n-            rv = NET_Timeout(fd, timeout);\n-            if (rv <= 0) {\n-                if (rv == 0) {\n-                    JNU_ThrowByName(env,JNU_JAVANETPKG \"SocketTimeoutException\",\n-                                    \"Receive timed out\");\n-                } else if (rv == -1) {\n-                    JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                                    \"Socket closed\");\n-                }\n-                if (packetBufferLen > MAX_BUFFER_LEN) {\n-                    free(fullPacket);\n-                }\n-                return -1;\n-            }\n-        }\n-\n-        \/* receive the packet *\/\n-        rv = recvfrom(fd, fullPacket, packetBufferLen, flags,\n-                      &sa.sa, &sa_len);\n-\n-        if (rv == SOCKET_ERROR && (WSAGetLastError() == WSAECONNRESET)) {\n-            \/* An icmp port unreachable - we must receive this as Windows\n-             * does not reset the state of the socket until this has been\n-             * received.\n-             *\/\n-            purgeOutstandingICMP(env, fd);\n-\n-            if (connected) {\n-                JNU_ThrowByName(env, JNU_JAVANETPKG \"PortUnreachableException\",\n-                                \"ICMP Port Unreachable\");\n-                if (packetBufferLen > MAX_BUFFER_LEN)\n-                    free(fullPacket);\n-                return -1;\n-            } else if (timeout) {\n-                \/* Adjust timeout *\/\n-                jlong newTime = JVM_CurrentTimeMillis(env, 0);\n-                timeout -= (jint)(newTime - prevTime);\n-                if (timeout <= 0) {\n-                    JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketTimeoutException\",\n-                                    \"Receive timed out\");\n-                    if (packetBufferLen > MAX_BUFFER_LEN)\n-                        free(fullPacket);\n-                    return -1;\n-                }\n-                prevTime = newTime;\n-            }\n-            retry = TRUE;\n-        }\n-    } while (retry);\n-\n-    port = (int) ntohs ((u_short) GET_PORT((SOCKETADDRESS *)&sa));\n-\n-    \/* truncate the data if the packet's length is too small *\/\n-    if (rv > packetBufferLen) {\n-        rv = packetBufferLen;\n-    }\n-    if (rv < 0) {\n-        if (WSAGetLastError() == WSAEMSGSIZE) {\n-            \/* it is because the buffer is too small. It's UDP, it's\n-             * unreliable, it's all good. discard the rest of the\n-             * data..\n-             *\/\n-            rv = packetBufferLen;\n-        } else {\n-            \/* failure *\/\n-            (*env)->SetIntField(env, dpObj, dp_lengthID, 0);\n-        }\n-    }\n-\n-    if (rv == -1) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", \"socket closed\");\n-    } else if (rv == -2) {\n-        JNU_ThrowByName(env, JNU_JAVAIOPKG \"InterruptedIOException\",\n-                        \"operation interrupted\");\n-    } else if (rv < 0) {\n-        NET_ThrowCurrent(env, \"Datagram receive failed\");\n-    } else {\n-        jobject packetAddress;\n-        \/*\n-         * Check if there is an InetAddress already associated with this\n-         * packet. If so, we check if it is the same source address. We\n-         * can't update any existing InetAddress because it is immutable\n-         *\/\n-        packetAddress = (*env)->GetObjectField(env, dpObj, dp_addressID);\n-        if (packetAddress != NULL) {\n-            if (!NET_SockaddrEqualsInetAddress(env, &sa, packetAddress)) {\n-                \/* force a new InetAddress to be created *\/\n-                packetAddress = NULL;\n-            }\n-        }\n-        if (!(*env)->ExceptionCheck(env)){\n-            if (packetAddress == NULL ) {\n-                packetAddress = NET_SockaddrToInetAddress(env, &sa, &port);\n-                if (packetAddress != NULL) {\n-                    \/* stuff the new InetAddress into the packet *\/\n-                    (*env)->SetObjectField(env, dpObj, dp_addressID, packetAddress);\n-                }\n-            }\n-            \/* populate the packet *\/\n-            (*env)->SetByteArrayRegion(env, packetBuffer, packetBufferOffset, rv,\n-                                   (jbyte *)fullPacket);\n-            (*env)->SetIntField(env, dpObj, dp_portID, port);\n-            (*env)->SetIntField(env, dpObj, dp_lengthID, rv);\n-        }\n-    }\n-\n-    if (packetBufferLen > MAX_BUFFER_LEN) {\n-        free(fullPacket);\n-    }\n-    return port;\n-}\n-\n-\/*\n- * Class:     java_net_DualStackPlainDatagramSocketImpl\n- * Method:    socketSend\n- * Signature: (I[BIILjava\/net\/InetAddress;IZ)V\n- *\/\n-JNIEXPORT void JNICALL Java_java_net_DualStackPlainDatagramSocketImpl_socketSend\n-  (JNIEnv *env, jclass clazz, jint fd, jbyteArray data, jint offset, jint length,\n-     jobject iaObj, jint port, jboolean connected) {\n-    SOCKETADDRESS sa;\n-    int rv, sa_len = 0;\n-    struct sockaddr *sap = 0;\n-    char BUF[MAX_BUFFER_LEN];\n-    char *fullPacket;\n-\n-    \/\/ if already connected, sap arg to sendto() is null\n-    if (!connected) {\n-        if (NET_InetAddressToSockaddr(env, iaObj, port, &sa,\n-                                      &sa_len, JNI_TRUE) != 0) {\n-            return;\n-        }\n-        sap = &sa.sa;\n-    }\n-\n-    if (length > MAX_BUFFER_LEN) {\n-        \/* Note: the buffer needn't be greater than 65,536 (0xFFFF)\n-         * the max size of an IP packet. Anything bigger is truncated anyway.\n-         *\/\n-        if (length > MAX_PACKET_LEN) {\n-            length = MAX_PACKET_LEN;\n-        }\n-        fullPacket = (char *)malloc(length);\n-        if (!fullPacket) {\n-            JNU_ThrowOutOfMemoryError(env, \"Native heap allocation failed\");\n-            return;\n-        }\n-    } else {\n-        fullPacket = &(BUF[0]);\n-    }\n-\n-    (*env)->GetByteArrayRegion(env, data, offset, length,\n-                               (jbyte *)fullPacket);\n-    rv = sendto(fd, fullPacket, length, 0, sap, sa_len);\n-    if (rv == SOCKET_ERROR) {\n-        if (rv == -1) {\n-            NET_ThrowNew(env, WSAGetLastError(), \"Datagram send failed\");\n-        }\n-    }\n-\n-    if (length > MAX_BUFFER_LEN) {\n-        free(fullPacket);\n-    }\n-}\n-\n-\/*\n- * Class:     java_net_DualStackPlainDatagramSocketImpl\n- * Method:    socketSetIntOption\n- * Signature: (III)V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_DualStackPlainDatagramSocketImpl_socketSetIntOption\n-  (JNIEnv *env, jclass clazz, jint fd, jint cmd, jint value)\n-{\n-    int level = 0, opt = 0;\n-\n-    if (NET_MapSocketOption(cmd, &level, &opt) < 0) {\n-        JNU_ThrowByName(env, \"java\/net\/SocketException\", \"Invalid option\");\n-        return;\n-    }\n-\n-    if (NET_SetSockOpt(fd, level, opt, (char *)&value, sizeof(value)) < 0) {\n-        NET_ThrowNew(env, WSAGetLastError(), \"setsockopt\");\n-    }\n-}\n-\n-\/*\n- * Class:     java_net_DualStackPlainDatagramSocketImpl\n- * Method:    socketGetIntOption\n- * Signature: (II)I\n- *\/\n-JNIEXPORT jint JNICALL\n-Java_java_net_DualStackPlainDatagramSocketImpl_socketGetIntOption\n-  (JNIEnv *env, jclass clazz, jint fd, jint cmd)\n-{\n-    int level = 0, opt = 0, result = 0;\n-    int result_len = sizeof(result);\n-\n-    if (NET_MapSocketOption(cmd, &level, &opt) < 0) {\n-        JNU_ThrowByName(env, \"java\/net\/SocketException\", \"Invalid option\");\n-        return -1;\n-    }\n-\n-    if (NET_GetSockOpt(fd, level, opt, (void *)&result, &result_len) < 0) {\n-        NET_ThrowNew(env, WSAGetLastError(), \"getsockopt\");\n-        return -1;\n-    }\n-\n-    return result;\n-}\n-\n-\/*\n- * Class:     java_net_DualStackPlainDatagramSocketImpl\n- * Method:    dataAvailable\n- * Signature: ()I\n- *\/\n-JNIEXPORT jint JNICALL\n-Java_java_net_DualStackPlainDatagramSocketImpl_dataAvailable\n-  (JNIEnv *env, jobject this)\n-{\n-    SOCKET fd;\n-    int  rv = -1;\n-    jobject fdObj = (*env)->GetObjectField(env, this, pdsi_fdID);\n-\n-    if (!IS_NULL(fdObj)) {\n-        int retval = 0;\n-        fd = (SOCKET)(*env)->GetIntField(env, fdObj, IO_fd_fdID);\n-        rv = ioctlsocket(fd, FIONREAD, &retval);\n-        if (retval > 0) {\n-            return retval;\n-        }\n-    }\n-\n-    if (rv < 0) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                        \"Socket closed\");\n-        return -1;\n-    }\n-\n-    return 0;\n-}\n","filename":"src\/java.base\/windows\/native\/libnet\/DualStackPlainDatagramSocketImpl.c","additions":0,"deletions":539,"binary":false,"changes":539,"status":"deleted"},{"patch":"@@ -1,535 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-#include \"net_util.h\"\n-\n-#include \"java_net_PlainSocketImpl.h\"\n-#include \"java_net_SocketOptions.h\"\n-\n-#define SET_BLOCKING     0\n-#define SET_NONBLOCKING  1\n-\n-static jclass isa_class;        \/* java.net.InetSocketAddress *\/\n-static jmethodID isa_ctorID;    \/* InetSocketAddress(InetAddress, int) *\/\n-\n-\/*\n- * Class:     java_net_PlainSocketImpl\n- * Method:    initIDs\n- * Signature: ()V\n- *\/\n-JNIEXPORT void JNICALL Java_java_net_PlainSocketImpl_initIDs\n-  (JNIEnv *env, jclass clazz) {\n-\n-    jclass cls = (*env)->FindClass(env, \"java\/net\/InetSocketAddress\");\n-    CHECK_NULL(cls);\n-    isa_class = (*env)->NewGlobalRef(env, cls);\n-    CHECK_NULL(isa_class);\n-    isa_ctorID = (*env)->GetMethodID(env, cls, \"<init>\",\n-                                     \"(Ljava\/net\/InetAddress;I)V\");\n-    CHECK_NULL(isa_ctorID);\n-    initInetAddressIDs(env);\n-\n-    \/\/ implement read timeout with select.\n-    isRcvTimeoutSupported = JNI_FALSE;\n-}\n-\n-\/*\n- * Class:     java_net_PlainSocketImpl\n- * Method:    socket0\n- * Signature: (ZZ)I\n- *\/\n-JNIEXPORT jint JNICALL Java_java_net_PlainSocketImpl_socket0\n-  (JNIEnv *env, jclass clazz, jboolean stream) {\n-    int fd, rv, opt = 0;\n-    int type = (stream ? SOCK_STREAM : SOCK_DGRAM);\n-    int domain = ipv6_available() ? AF_INET6 : AF_INET;\n-\n-    fd = NET_Socket(domain, type, 0);\n-\n-    if (fd == INVALID_SOCKET) {\n-        NET_ThrowNew(env, WSAGetLastError(), \"create\");\n-        return -1;\n-    }\n-\n-    if (domain == AF_INET6) {\n-        rv = setsockopt(fd, IPPROTO_IPV6, IPV6_V6ONLY, (char *) &opt,\n-                        sizeof(opt));\n-        if (rv == SOCKET_ERROR) {\n-            NET_ThrowNew(env, WSAGetLastError(), \"create\");\n-            closesocket(fd);\n-            return -1;\n-        }\n-    }\n-\n-    return fd;\n-}\n-\n-\/*\n- * Class:     java_net_PlainSocketImpl\n- * Method:    bind0\n- * Signature: (ILjava\/net\/InetAddress;I)V\n- *\/\n-JNIEXPORT void JNICALL Java_java_net_PlainSocketImpl_bind0\n-  (JNIEnv *env, jclass clazz, jint fd, jobject iaObj, jint port,\n-   jboolean exclBind)\n-{\n-    SOCKETADDRESS sa;\n-    int rv, sa_len = 0;\n-    jboolean v4MappedAddress = ipv6_available() ? JNI_TRUE : JNI_FALSE;\n-\n-    if (NET_InetAddressToSockaddr(env, iaObj, port, &sa,\n-                                  &sa_len, v4MappedAddress) != 0) {\n-        return;\n-    }\n-\n-    rv = NET_WinBind(fd, &sa, sa_len, exclBind);\n-\n-    if (rv == SOCKET_ERROR)\n-        NET_ThrowNew(env, WSAGetLastError(), \"NET_Bind\");\n-}\n-\n-\/*\n- * Class:     java_net_PlainSocketImpl\n- * Method:    connect0\n- * Signature: (ILjava\/net\/InetAddress;I)I\n- *\/\n-JNIEXPORT jint JNICALL Java_java_net_PlainSocketImpl_connect0\n-  (JNIEnv *env, jclass clazz, jint fd, jobject iaObj, jint port) {\n-    SOCKETADDRESS sa;\n-    int rv, sa_len = 0;\n-    jboolean v4MappedAddress = ipv6_available() ? JNI_TRUE : JNI_FALSE;\n-\n-    if (NET_InetAddressToSockaddr(env, iaObj, port, &sa,\n-                                  &sa_len, v4MappedAddress) != 0) {\n-        return -1;\n-    }\n-\n-    rv = connect(fd, &sa.sa, sa_len);\n-    if (rv == SOCKET_ERROR) {\n-        int err = WSAGetLastError();\n-        if (err == WSAEWOULDBLOCK) {\n-            return java_net_PlainSocketImpl_WOULDBLOCK;\n-        } else if (err == WSAEADDRNOTAVAIL) {\n-            JNU_ThrowByName(env, JNU_JAVANETPKG \"ConnectException\",\n-                \"connect: Address is invalid on local machine,\"\n-                \" or port is not valid on remote machine\");\n-        } else {\n-            NET_ThrowNew(env, err, \"connect\");\n-        }\n-        \/\/ return value not important.\n-    }\n-    return rv;\n-}\n-\n-\/*\n- * Class:     java_net_PlainSocketImpl\n- * Method:    waitForConnect\n- * Signature: (II)V\n- *\/\n-JNIEXPORT void JNICALL Java_java_net_PlainSocketImpl_waitForConnect\n-  (JNIEnv *env, jclass clazz, jint fd, jint timeout) {\n-    int rv, retry;\n-    int optlen = sizeof(rv);\n-    fd_set wr, ex;\n-    struct timeval t;\n-\n-    FD_ZERO(&wr);\n-    FD_ZERO(&ex);\n-    FD_SET(fd, &wr);\n-    FD_SET(fd, &ex);\n-    t.tv_sec = timeout \/ 1000;\n-    t.tv_usec = (timeout % 1000) * 1000;\n-\n-    \/*\n-     * Wait for timeout, connection established or\n-     * connection failed.\n-     *\/\n-    rv = select(fd+1, 0, &wr, &ex, &t);\n-\n-    \/*\n-     * Timeout before connection is established\/failed so\n-     * we throw exception and shutdown input\/output to prevent\n-     * socket from being used.\n-     * The socket should be closed immediately by the caller.\n-     *\/\n-    if (rv == 0) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketTimeoutException\",\n-                        \"connect timed out\");\n-        shutdown(fd, SD_BOTH);\n-        return;\n-    }\n-\n-    \/*\n-     * Socket is writable or error occurred. On some Windows editions\n-     * the socket will appear writable when the connect fails so we\n-     * check for error rather than writable.\n-     *\/\n-    if (!FD_ISSET(fd, &ex)) {\n-        return;         \/* connection established *\/\n-    }\n-\n-    \/*\n-     * Connection failed. The logic here is designed to work around\n-     * bug on Windows NT whereby using getsockopt to obtain the\n-     * last error (SO_ERROR) indicates there is no error. The workaround\n-     * on NT is to allow winsock to be scheduled and this is done by\n-     * yielding and retrying. As yielding is problematic in heavy\n-     * load conditions we attempt up to 3 times to get the error reason.\n-     *\/\n-    for (retry = 0; retry < 3; retry++) {\n-        NET_GetSockOpt(fd, SOL_SOCKET, SO_ERROR,\n-                       (char*)&rv, &optlen);\n-        if (rv) {\n-            break;\n-        }\n-        Sleep(0);\n-    }\n-\n-    if (rv == 0) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                        \"Unable to establish connection\");\n-    } else if (!ipv6_available() && rv == WSAEADDRNOTAVAIL) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"ConnectException\",\n-                        \"connect: Address is invalid on local machine,\"\n-                        \" or port is not valid on remote machine\");\n-    } else {\n-        NET_ThrowNew(env, rv, \"connect\");\n-    }\n-}\n-\n-\/*\n- * Class:     java_net_PlainSocketImpl\n- * Method:    localPort0\n- * Signature: (I)I\n- *\/\n-JNIEXPORT jint JNICALL Java_java_net_PlainSocketImpl_localPort0\n-  (JNIEnv *env, jclass clazz, jint fd) {\n-    SOCKETADDRESS sa;\n-    int len = sizeof(sa);\n-\n-    if (getsockname(fd, &sa.sa, &len) == SOCKET_ERROR) {\n-        if (WSAGetLastError() == WSAENOTSOCK) {\n-            JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                    \"Socket closed\");\n-        } else {\n-            NET_ThrowNew(env, WSAGetLastError(), \"getsockname failed\");\n-        }\n-        return -1;\n-    }\n-    return (int) ntohs((u_short)GET_PORT(&sa));\n-}\n-\n-\/*\n- * Class:     java_net_PlainSocketImpl\n- * Method:    localAddress\n- * Signature: (ILjava\/net\/InetAddressContainer;)V\n- *\/\n-JNIEXPORT void JNICALL Java_java_net_PlainSocketImpl_localAddress\n-  (JNIEnv *env, jclass clazz, jint fd, jobject iaContainerObj) {\n-    int port;\n-    SOCKETADDRESS sa;\n-    int len = sizeof(sa);\n-    jobject iaObj;\n-    jclass iaContainerClass;\n-    jfieldID iaFieldID;\n-\n-    if (getsockname(fd, &sa.sa, &len) == SOCKET_ERROR) {\n-        NET_ThrowNew(env, WSAGetLastError(), \"Error getting socket name\");\n-        return;\n-    }\n-    iaObj = NET_SockaddrToInetAddress(env, &sa, &port);\n-    CHECK_NULL(iaObj);\n-\n-    iaContainerClass = (*env)->GetObjectClass(env, iaContainerObj);\n-    iaFieldID = (*env)->GetFieldID(env, iaContainerClass, \"addr\", \"Ljava\/net\/InetAddress;\");\n-    CHECK_NULL(iaFieldID);\n-    (*env)->SetObjectField(env, iaContainerObj, iaFieldID, iaObj);\n-}\n-\n-\/*\n- * Class:     java_net_PlainSocketImpl\n- * Method:    listen0\n- * Signature: (II)V\n- *\/\n-JNIEXPORT void JNICALL Java_java_net_PlainSocketImpl_listen0\n-  (JNIEnv *env, jclass clazz, jint fd, jint backlog) {\n-    if (listen(fd, backlog) == SOCKET_ERROR) {\n-        NET_ThrowNew(env, WSAGetLastError(), \"listen failed\");\n-    }\n-}\n-\n-\/*\n- * Class:     java_net_PlainSocketImpl\n- * Method:    accept0\n- * Signature: (I[Ljava\/net\/InetSocketAddress;)I\n- *\/\n-JNIEXPORT jint JNICALL Java_java_net_PlainSocketImpl_accept0\n-  (JNIEnv *env, jclass clazz, jint fd, jobjectArray isaa) {\n-    int newfd, port = 0;\n-    jobject isa;\n-    jobject ia;\n-    SOCKETADDRESS sa;\n-    int len = sizeof(sa);\n-\n-    memset((char *)&sa, 0, len);\n-    newfd = accept(fd, &sa.sa, &len);\n-\n-    if (newfd == INVALID_SOCKET) {\n-        NET_ThrowNew(env, WSAGetLastError(), \"accept failed\");\n-        return -1;\n-    }\n-\n-    SetHandleInformation((HANDLE)(UINT_PTR)newfd, HANDLE_FLAG_INHERIT, 0);\n-\n-    ia = NET_SockaddrToInetAddress(env, &sa, &port);\n-    if (ia == NULL){\n-        closesocket(newfd);\n-        return -1;\n-    }\n-    isa = (*env)->NewObject(env, isa_class, isa_ctorID, ia, port);\n-    if (isa == NULL) {\n-        closesocket(newfd);\n-        return -1;\n-    }\n-    (*env)->SetObjectArrayElement(env, isaa, 0, isa);\n-\n-    return newfd;\n-}\n-\n-\/*\n- * Class:     java_net_PlainSocketImpl\n- * Method:    waitForNewConnection\n- * Signature: (II)V\n- *\/\n-JNIEXPORT void JNICALL Java_java_net_PlainSocketImpl_waitForNewConnection\n-  (JNIEnv *env, jclass clazz, jint fd, jint timeout) {\n-    int rv;\n-\n-    rv = NET_Timeout(fd, timeout);\n-    if (rv == 0) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketTimeoutException\",\n-                        \"Accept timed out\");\n-    } else if (rv == -1) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", \"socket closed\");\n-    } else if (rv == -2) {\n-        JNU_ThrowByName(env, JNU_JAVAIOPKG \"InterruptedIOException\",\n-                        \"operation interrupted\");\n-    }\n-}\n-\n-\/*\n- * Class:     java_net_PlainSocketImpl\n- * Method:    available0\n- * Signature: (I)I\n- *\/\n-JNIEXPORT jint JNICALL Java_java_net_PlainSocketImpl_available0\n-  (JNIEnv *env, jclass clazz, jint fd) {\n-    jint available = -1;\n-\n-    if ((ioctlsocket(fd, FIONREAD, &available)) == SOCKET_ERROR) {\n-        NET_ThrowNew(env, WSAGetLastError(), \"socket available\");\n-    }\n-\n-    return available;\n-}\n-\n-\/*\n- * Class:     java_net_PlainSocketImpl\n- * Method:    close0\n- * Signature: (I)V\n- *\/\n-JNIEXPORT void JNICALL Java_java_net_PlainSocketImpl_close0\n-  (JNIEnv *env, jclass clazz, jint fd) {\n-     NET_SocketClose(fd);\n-}\n-\n-\/*\n- * Class:     java_net_PlainSocketImpl\n- * Method:    shutdown0\n- * Signature: (II)V\n- *\/\n-JNIEXPORT void JNICALL Java_java_net_PlainSocketImpl_shutdown0\n-  (JNIEnv *env, jclass clazz, jint fd, jint howto) {\n-    shutdown(fd, howto);\n-}\n-\n-\/*\n- * Class:     java_net_PlainSocketImpl\n- * Method:    setIntOption\n- * Signature: (III)V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_PlainSocketImpl_setIntOption\n-  (JNIEnv *env, jclass clazz, jint fd, jint cmd, jint value)\n-{\n-    int level = 0, opt = 0;\n-    struct linger linger = {0, 0};\n-    char *parg;\n-    int arglen;\n-\n-    if (NET_MapSocketOption(cmd, &level, &opt) < 0) {\n-        JNU_ThrowByName(env, \"java\/net\/SocketException\", \"Invalid option\");\n-        return;\n-    }\n-\n-    if (opt == java_net_SocketOptions_SO_LINGER) {\n-        parg = (char *)&linger;\n-        arglen = sizeof(linger);\n-        if (value >= 0) {\n-            linger.l_onoff = 1;\n-            linger.l_linger = (unsigned short)value;\n-        } else {\n-            linger.l_onoff = 0;\n-            linger.l_linger = 0;\n-        }\n-    } else {\n-        parg = (char *)&value;\n-        arglen = sizeof(value);\n-    }\n-\n-    if (NET_SetSockOpt(fd, level, opt, parg, arglen) < 0) {\n-        NET_ThrowNew(env, WSAGetLastError(), \"setsockopt\");\n-    }\n-}\n-\n-\/*\n- * Class:     java_net_PlainSocketImpl\n- * Method:    setSoTimeout0\n- * Signature: (II)V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_PlainSocketImpl_setSoTimeout0\n-  (JNIEnv *env, jclass clazz, jint fd, jint timeout)\n-{\n-    \/*\n-     * SO_TIMEOUT is the socket option used to specify the timeout\n-     * for ServerSocket.accept and Socket.getInputStream().read.\n-     * It does not typically map to a native level socket option.\n-     * For Windows we special-case this and use the SOL_SOCKET\/SO_RCVTIMEO\n-     * socket option to specify a receive timeout on the socket. This\n-     * receive timeout is applicable to Socket only and the socket\n-     * option should not be set on ServerSocket.\n-     *\/\n-\n-    \/*\n-     * SO_RCVTIMEO is only supported on Microsoft's implementation\n-     * of Windows Sockets so if WSAENOPROTOOPT returned then\n-     * reset flag and timeout will be implemented using\n-     * select() -- see SocketInputStream.socketRead.\n-     *\/\n-    if (isRcvTimeoutSupported) {\n-        \/*\n-         * Disable SO_RCVTIMEO if timeout is <= 5 second.\n-         *\/\n-        if (timeout <= 5000) {\n-            timeout = 0;\n-        }\n-\n-        if (setsockopt(fd, SOL_SOCKET, SO_RCVTIMEO, (char *)&timeout,\n-            sizeof(timeout)) < 0) {\n-            int err = WSAGetLastError();\n-            if (err == WSAENOPROTOOPT) {\n-                isRcvTimeoutSupported = JNI_FALSE;\n-            } else {\n-                NET_ThrowNew(env, err, \"setsockopt SO_RCVTIMEO\");\n-            }\n-        }\n-    }\n-}\n-\n-\/*\n- * Class:     java_net_PlainSocketImpl\n- * Method:    getIntOption\n- * Signature: (II)I\n- *\/\n-JNIEXPORT jint JNICALL Java_java_net_PlainSocketImpl_getIntOption\n-  (JNIEnv *env, jclass clazz, jint fd, jint cmd)\n-{\n-    int level = 0, opt = 0;\n-    int result = 0;\n-    struct linger linger = {0, 0};\n-    char *arg;\n-    int arglen;\n-\n-    if (NET_MapSocketOption(cmd, &level, &opt) < 0) {\n-        JNU_ThrowByName(env, \"java\/net\/SocketException\", \"Invalid option\");\n-        return -1;\n-    }\n-\n-    if (opt == java_net_SocketOptions_SO_LINGER) {\n-        arg = (char *)&linger;\n-        arglen = sizeof(linger);\n-    } else {\n-        arg = (char *)&result;\n-        arglen = sizeof(result);\n-    }\n-\n-    if (NET_GetSockOpt(fd, level, opt, arg, &arglen) < 0) {\n-        NET_ThrowNew(env, WSAGetLastError(), \"getsockopt\");\n-        return -1;\n-    }\n-\n-    if (opt == java_net_SocketOptions_SO_LINGER)\n-        return linger.l_onoff ? linger.l_linger : -1;\n-    else\n-        return result;\n-}\n-\n-\/*\n- * Class:     java_net_PlainSocketImpl\n- * Method:    sendOOB\n- * Signature: (II)V\n- *\/\n-JNIEXPORT void JNICALL Java_java_net_PlainSocketImpl_sendOOB\n-  (JNIEnv *env, jclass clazz, jint fd, jint data) {\n-    jint n;\n-    unsigned char d = (unsigned char) data & 0xff;\n-\n-    n = send(fd, (char *)&data, 1, MSG_OOB);\n-    if (n == SOCKET_ERROR) {\n-        NET_ThrowNew(env, WSAGetLastError(), \"send\");\n-    }\n-}\n-\n-\/*\n- * Class:     java_net_PlainSocketImpl\n- * Method:    configureBlocking\n- * Signature: (IZ)V\n- *\/\n-JNIEXPORT void JNICALL Java_java_net_PlainSocketImpl_configureBlocking\n-  (JNIEnv *env, jclass clazz, jint fd, jboolean blocking) {\n-    u_long arg;\n-    int result;\n-\n-    if (blocking == JNI_TRUE) {\n-        arg = SET_BLOCKING;      \/\/ 0\n-    } else {\n-        arg = SET_NONBLOCKING;   \/\/ 1\n-    }\n-\n-    result = ioctlsocket(fd, FIONBIO, &arg);\n-    if (result == SOCKET_ERROR) {\n-        NET_ThrowNew(env, WSAGetLastError(), \"configureBlocking\");\n-    }\n-}\n","filename":"src\/java.base\/windows\/native\/libnet\/PlainSocketImpl.c","additions":0,"deletions":535,"binary":false,"changes":535,"status":"deleted"},{"patch":"@@ -1,61 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <jni.h>\n-#include \"net_util.h\"\n-#include \"java_net_SocketCleanable.h\"\n-\n-JNIEXPORT jboolean JNICALL\n-Java_java_net_AbstractPlainSocketImpl_isReusePortAvailable0(JNIEnv* env, jclass c1)\n-{\n-    \/\/ SO_REUSEPORT is not supported on Windows\n-    return JNI_FALSE;\n-}\n-\n-JNIEXPORT jboolean JNICALL\n-Java_java_net_AbstractPlainDatagramSocketImpl_isReusePortAvailable0(JNIEnv* env, jclass c1)\n-{\n-    \/\/ SO_REUSEPORT is not supported on Windows\n-    return JNI_FALSE;\n-}\n-\n-JNIEXPORT jboolean JNICALL\n-Java_jdk_net_Sockets_isReusePortAvailable0(JNIEnv* env, jclass c1)\n-{\n-    \/\/ SO_REUSEPORT is not supported on Windows\n-    return JNI_FALSE;\n-}\n-\n-\/*\n- * Class:     java_net_SocketCleanable\n- * Method:    cleanupClose0\n- * Signature: (I)V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_SocketCleanable_cleanupClose0(JNIEnv *env, jclass c1, jint fd)\n-{\n-    NET_SocketClose(fd);\n-}\n-\n","filename":"src\/java.base\/windows\/native\/libnet\/SocketImpl.c","additions":0,"deletions":61,"binary":false,"changes":61,"status":"deleted"},{"patch":"@@ -1,162 +0,0 @@\n-\/*\n- * Copyright (c) 1997, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-#include <malloc.h>\n-\n-#include \"net_util.h\"\n-\n-#include \"java_net_SocketInputStream.h\"\n-\n-\/*************************************************************************\n- * SocketInputStream\n- *\/\n-static jfieldID IO_fd_fdID;\n-\n-\/*\n- * Class:     java_net_SocketInputStream\n- * Method:    init\n- * Signature: ()V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_SocketInputStream_init(JNIEnv *env, jclass cls) {\n-    IO_fd_fdID = NET_GetFileDescriptorID(env);\n-}\n-\n-\/*\n- * Class:     java_net_SocketInputStream\n- * Method:    socketRead\n- * Signature: (Ljava\/io\/FileDescriptor;[BIII)I\n- *\/\n-JNIEXPORT jint JNICALL\n-Java_java_net_SocketInputStream_socketRead0(JNIEnv *env, jobject this,\n-                                            jobject fdObj, jbyteArray data,\n-                                            jint off, jint len, jint timeout)\n-{\n-    char BUF[MAX_BUFFER_LEN];\n-    char *bufP;\n-    jint fd, newfd, nread;\n-\n-    if (IS_NULL(fdObj)) {\n-        JNU_ThrowByName(env, \"java\/net\/SocketException\",\n-                        \"Socket closed\");\n-        return -1;\n-    }\n-    fd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);\n-    if (fd == -1) {\n-        JNU_ThrowByName(env, \"java\/net\/SocketException\", \"Socket closed\");\n-        return -1;\n-    }\n-\n-    \/*\n-     * If the caller buffer is large than our stack buffer then we allocate\n-     * from the heap (up to a limit). If memory is exhausted we always use\n-     * the stack buffer.\n-     *\/\n-    if (len <= MAX_BUFFER_LEN) {\n-        bufP = BUF;\n-    } else {\n-        if (len > MAX_HEAP_BUFFER_LEN) {\n-            len = MAX_HEAP_BUFFER_LEN;\n-        }\n-        bufP = (char *)malloc((size_t)len);\n-        if (bufP == NULL) {\n-            \/* allocation failed so use stack buffer *\/\n-            bufP = BUF;\n-            len = MAX_BUFFER_LEN;\n-        }\n-    }\n-\n-\n-    if (timeout) {\n-        if (timeout <= 5000 || !isRcvTimeoutSupported) {\n-            int ret = NET_Timeout (fd, timeout);\n-\n-            if (ret <= 0) {\n-                if (ret == 0) {\n-                    JNU_ThrowByName(env, \"java\/net\/SocketTimeoutException\",\n-                                    \"Read timed out\");\n-                } else if (ret == -1) {\n-                    JNU_ThrowByName(env, \"java\/net\/SocketException\", \"socket closed\");\n-                }\n-                if (bufP != BUF) {\n-                    free(bufP);\n-                }\n-                return -1;\n-            }\n-\n-            \/*check if the socket has been closed while we were in timeout*\/\n-            newfd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);\n-            if (newfd == -1) {\n-                JNU_ThrowByName(env, \"java\/net\/SocketException\", \"Socket closed\");\n-                if (bufP != BUF) {\n-                    free(bufP);\n-                }\n-                return -1;\n-            }\n-        }\n-    }\n-\n-    nread = recv(fd, bufP, len, 0);\n-    if (nread > 0) {\n-        (*env)->SetByteArrayRegion(env, data, off, nread, (jbyte *)bufP);\n-    } else {\n-        if (nread < 0) {\n-            int err = WSAGetLastError();\n-            \/\/ Check if the socket has been closed since we last checked.\n-            \/\/ This could be a reason for recv failing.\n-            if ((*env)->GetIntField(env, fdObj, IO_fd_fdID) == -1) {\n-                JNU_ThrowByName(env, \"java\/net\/SocketException\", \"Socket closed\");\n-            } else {\n-                switch (err) {\n-                    case WSAEINTR:\n-                        JNU_ThrowByName(env, \"java\/net\/SocketException\",\n-                            \"socket closed\");\n-                        break;\n-\n-                    case WSAECONNRESET:\n-                    case WSAESHUTDOWN:\n-                        \/*\n-                         * Connection has been reset - Windows sometimes reports\n-                         * the reset as a shutdown error.\n-                         *\/\n-                        JNU_ThrowByName(env, \"sun\/net\/ConnectionResetException\",\n-                            \"\");\n-                        break;\n-\n-                    case WSAETIMEDOUT :\n-                        JNU_ThrowByName(env, \"java\/net\/SocketTimeoutException\",\n-                                       \"Read timed out\");\n-                        break;\n-\n-                    default:\n-                        NET_ThrowCurrent(env, \"recv failed\");\n-                }\n-            }\n-        }\n-    }\n-    if (bufP != BUF) {\n-        free(bufP);\n-    }\n-    return nread;\n-}\n","filename":"src\/java.base\/windows\/native\/libnet\/SocketInputStream.c","additions":0,"deletions":162,"binary":false,"changes":162,"status":"deleted"},{"patch":"@@ -1,163 +0,0 @@\n-\/*\n- * Copyright (c) 1997, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-#include <malloc.h>\n-\n-#include \"net_util.h\"\n-\n-#include \"java_net_SocketOutputStream.h\"\n-\n-\/************************************************************************\n- * SocketOutputStream\n- *\/\n-static jfieldID IO_fd_fdID;\n-\n-\/*\n- * Class:     java_net_SocketOutputStream\n- * Method:    init\n- * Signature: ()V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_SocketOutputStream_init(JNIEnv *env, jclass cls) {\n-    IO_fd_fdID = NET_GetFileDescriptorID(env);\n-}\n-\n-\/*\n- * Class:     java_net_SocketOutputStream\n- * Method:    socketWrite\n- * Signature: (Ljava\/io\/FileDescriptor;[BII)V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_SocketOutputStream_socketWrite0(JNIEnv *env, jobject this,\n-                                              jobject fdObj, jbyteArray data,\n-                                              jint off, jint len) {\n-    char *bufP;\n-    char BUF[MAX_BUFFER_LEN];\n-    int buflen;\n-    int fd;\n-\n-    if (IS_NULL(fdObj)) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", \"Socket closed\");\n-        return;\n-    } else {\n-        fd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);\n-    }\n-    if (IS_NULL(data)) {\n-        JNU_ThrowNullPointerException(env, \"data argument\");\n-        return;\n-    }\n-\n-    \/*\n-     * Use stack allocate buffer if possible. For large sizes we allocate\n-     * an intermediate buffer from the heap (up to a maximum). If heap is\n-     * unavailable just use our stack buffer.\n-     *\/\n-    if (len <= MAX_BUFFER_LEN) {\n-        bufP = BUF;\n-        buflen = MAX_BUFFER_LEN;\n-    } else {\n-        buflen = min(MAX_HEAP_BUFFER_LEN, len);\n-        bufP = (char *)malloc((size_t)buflen);\n-        if (bufP == NULL) {\n-            bufP = BUF;\n-            buflen = MAX_BUFFER_LEN;\n-        }\n-    }\n-\n-    while(len > 0) {\n-        int loff = 0;\n-        int chunkLen = min(buflen, len);\n-        int llen = chunkLen;\n-        int retry = 0;\n-\n-        (*env)->GetByteArrayRegion(env, data, off, chunkLen, (jbyte *)bufP);\n-        if ((*env)->ExceptionCheck(env)) {\n-            break;\n-        } else {\n-            while(llen > 0) {\n-                int n = send(fd, bufP + loff, llen, 0);\n-                if (n > 0) {\n-                    llen -= n;\n-                    loff += n;\n-                    continue;\n-                }\n-\n-                \/*\n-                 * Due to a bug in Windows Sockets (observed on NT and Windows\n-                 * 2000) it may be necessary to retry the send. The issue is that\n-                 * on blocking sockets send\/WSASend is supposed to block if there\n-                 * is insufficient buffer space available. If there are a large\n-                 * number of threads blocked on write due to congestion then it's\n-                 * possile to hit the NT\/2000 bug whereby send returns WSAENOBUFS.\n-                 * The workaround we use is to retry the send. If we have a\n-                 * large buffer to send (>2k) then we retry with a maximum of\n-                 * 2k buffer. If we hit the issue with <=2k buffer then we backoff\n-                 * for 1 second and retry again. We repeat this up to a reasonable\n-                 * limit before bailing out and throwing an exception. In load\n-                 * conditions we've observed that the send will succeed after 2-3\n-                 * attempts but this depends on network buffers associated with\n-                 * other sockets draining.\n-                 *\/\n-                if (WSAGetLastError() == WSAENOBUFS) {\n-                    if (llen > MAX_BUFFER_LEN) {\n-                        buflen = MAX_BUFFER_LEN;\n-                        chunkLen = MAX_BUFFER_LEN;\n-                        llen = MAX_BUFFER_LEN;\n-                        continue;\n-                    }\n-                    if (retry >= 30) {\n-                        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                            \"No buffer space available - exhausted attempts to queue buffer\");\n-                        if (bufP != BUF) {\n-                            free(bufP);\n-                        }\n-                        return;\n-                    }\n-                    Sleep(1000);\n-                    retry++;\n-                    continue;\n-                }\n-\n-                \/*\n-                 * Send failed - can be caused by close or write error.\n-                 *\/\n-                if (WSAGetLastError() == WSAENOTSOCK) {\n-                    JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", \"Socket closed\");\n-                } else {\n-                    NET_ThrowCurrent(env, \"socket write error\");\n-                }\n-                if (bufP != BUF) {\n-                    free(bufP);\n-                }\n-                return;\n-            }\n-            len -= chunkLen;\n-            off += chunkLen;\n-        }\n-    }\n-\n-    if (bufP != BUF) {\n-        free(bufP);\n-    }\n-}\n","filename":"src\/java.base\/windows\/native\/libnet\/SocketOutputStream.c","additions":0,"deletions":163,"binary":false,"changes":163,"status":"deleted"},{"patch":"@@ -1,2349 +0,0 @@\n-\/*\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-#include <malloc.h>\n-\n-#include \"net_util.h\"\n-#include \"NetworkInterface.h\"\n-\n-#include \"java_net_TwoStacksPlainDatagramSocketImpl.h\"\n-#include \"java_net_SocketOptions.h\"\n-#include \"java_net_NetworkInterface.h\"\n-#include \"java_net_InetAddress.h\"\n-\n-#ifndef IPTOS_TOS_MASK\n-#define IPTOS_TOS_MASK 0x1e\n-#endif\n-#ifndef IPTOS_PREC_MASK\n-#define IPTOS_PREC_MASK 0xe0\n-#endif\n-\n-\n-#define IN_CLASSD(i)    (((long)(i) & 0xf0000000) == 0xe0000000)\n-#define IN_MULTICAST(i) IN_CLASSD(i)\n-\n-extern int getAllInterfacesAndAddresses(JNIEnv *env, netif **netifPP);\n-\n-\/************************************************************************\n- * TwoStacksPlainDatagramSocketImpl\n- *\/\n-\n-static jfieldID IO_fd_fdID;\n-static jfieldID pdsi_trafficClassID;\n-jfieldID pdsi_fdID;\n-jfieldID pdsi_fd1ID;\n-jfieldID pdsi_fduseID;\n-jfieldID pdsi_lastfdID;\n-jfieldID pdsi_timeoutID;\n-\n-jfieldID pdsi_localPortID;\n-jfieldID pdsi_connected;\n-\n-static jclass ia4_clazz;\n-static jmethodID ia4_ctor;\n-\n-\/*\n- * Notes about UDP\/IPV6 on Windows (XP and 2003 server):\n- *\n- * fd always points to the IPv4 fd, and fd1 points to the IPv6 fd.\n- * Both fds are used when we bind to a wild-card address. When a specific\n- * address is used, only one of them is used.\n- *\/\n-\n-\/*\n- * Returns a java.lang.Integer based on 'i'\n- *\/\n-jobject createInteger(JNIEnv *env, int i) {\n-    static jclass i_class = NULL;\n-    static jmethodID i_ctrID;\n-    static jfieldID i_valueID;\n-\n-    if (i_class == NULL) {\n-        jclass c = (*env)->FindClass(env, \"java\/lang\/Integer\");\n-        CHECK_NULL_RETURN(c, NULL);\n-        i_ctrID = (*env)->GetMethodID(env, c, \"<init>\", \"(I)V\");\n-        CHECK_NULL_RETURN(i_ctrID, NULL);\n-        i_class = (*env)->NewGlobalRef(env, c);\n-        CHECK_NULL_RETURN(i_class, NULL);\n-    }\n-\n-    return (*env)->NewObject(env, i_class, i_ctrID, i);\n-}\n-\n-\/*\n- * Returns a java.lang.Boolean based on 'b'\n- *\/\n-jobject createBoolean(JNIEnv *env, int b) {\n-    static jclass b_class = NULL;\n-    static jmethodID b_ctrID;\n-    static jfieldID b_valueID;\n-\n-    if (b_class == NULL) {\n-        jclass c = (*env)->FindClass(env, \"java\/lang\/Boolean\");\n-        CHECK_NULL_RETURN(c, NULL);\n-        b_ctrID = (*env)->GetMethodID(env, c, \"<init>\", \"(Z)V\");\n-        CHECK_NULL_RETURN(b_ctrID, NULL);\n-        b_class = (*env)->NewGlobalRef(env, c);\n-        CHECK_NULL_RETURN(b_class, NULL);\n-    }\n-\n-    return (*env)->NewObject(env, b_class, b_ctrID, (jboolean)(b!=0));\n-}\n-\n-static int getFD(JNIEnv *env, jobject this) {\n-    jobject fdObj = (*env)->GetObjectField(env, this, pdsi_fdID);\n-\n-    if (fdObj == NULL) {\n-        return -1;\n-    }\n-    return (*env)->GetIntField(env, fdObj, IO_fd_fdID);\n-}\n-\n-static int getFD1(JNIEnv *env, jobject this) {\n-    jobject fdObj = (*env)->GetObjectField(env, this, pdsi_fd1ID);\n-\n-    if (fdObj == NULL) {\n-        return -1;\n-    }\n-    return (*env)->GetIntField(env, fdObj, IO_fd_fdID);\n-}\n-\n-\/*\n- * This function \"purges\" all outstanding ICMP port unreachable packets\n- * outstanding on a socket and returns JNI_TRUE if any ICMP messages\n- * have been purged. The rational for purging is to emulate normal BSD\n- * behaviour whereby receiving a \"connection reset\" status resets the\n- * socket.\n- *\/\n-static jboolean purgeOutstandingICMP(JNIEnv *env, jobject this, jint fd)\n-{\n-    jboolean got_icmp = JNI_FALSE;\n-    char buf[1];\n-    fd_set tbl;\n-    struct timeval t = { 0, 0 };\n-    SOCKETADDRESS rmtaddr;\n-    int addrlen = sizeof(SOCKETADDRESS);\n-\n-    memset((char *)&rmtaddr, 0, sizeof(rmtaddr));\n-\n-    \/*\n-     * Peek at the queue to see if there is an ICMP port unreachable. If there\n-     * is then receive it.\n-     *\/\n-    FD_ZERO(&tbl);\n-    FD_SET(fd, &tbl);\n-    while(1) {\n-        if (select(\/*ignored*\/fd+1, &tbl, 0, 0, &t) <= 0) {\n-            break;\n-        }\n-        if (recvfrom(fd, buf, 1, MSG_PEEK, &rmtaddr.sa, &addrlen) != SOCKET_ERROR) {\n-            break;\n-        }\n-        if (WSAGetLastError() != WSAECONNRESET) {\n-            \/* some other error - we don't care here *\/\n-            break;\n-        }\n-\n-        recvfrom(fd, buf, 1, 0, &rmtaddr.sa, &addrlen);\n-        got_icmp = JNI_TRUE;\n-    }\n-\n-    return got_icmp;\n-}\n-\n-\n-\/*\n- * Class:     java_net_TwoStacksPlainDatagramSocketImpl\n- * Method:    init\n- * Signature: ()V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_TwoStacksPlainDatagramSocketImpl_init(JNIEnv *env, jclass cls) {\n-    \/* get fieldIDs *\/\n-    pdsi_fdID = (*env)->GetFieldID(env, cls, \"fd\", \"Ljava\/io\/FileDescriptor;\");\n-    CHECK_NULL(pdsi_fdID);\n-    pdsi_fd1ID = (*env)->GetFieldID(env, cls, \"fd1\", \"Ljava\/io\/FileDescriptor;\");\n-    CHECK_NULL(pdsi_fd1ID);\n-    pdsi_timeoutID = (*env)->GetFieldID(env, cls, \"timeout\", \"I\");\n-    CHECK_NULL(pdsi_timeoutID);\n-    pdsi_fduseID = (*env)->GetFieldID(env, cls, \"fduse\", \"I\");\n-    CHECK_NULL(pdsi_fduseID);\n-    pdsi_lastfdID = (*env)->GetFieldID(env, cls, \"lastfd\", \"I\");\n-    CHECK_NULL(pdsi_lastfdID);\n-    pdsi_trafficClassID = (*env)->GetFieldID(env, cls, \"trafficClass\", \"I\");\n-    CHECK_NULL(pdsi_trafficClassID);\n-    pdsi_localPortID = (*env)->GetFieldID(env, cls, \"localPort\", \"I\");\n-    CHECK_NULL(pdsi_localPortID);\n-    pdsi_connected = (*env)->GetFieldID(env, cls, \"connected\", \"Z\");\n-    CHECK_NULL(pdsi_connected);\n-\n-    cls = (*env)->FindClass(env, \"java\/io\/FileDescriptor\");\n-    CHECK_NULL(cls);\n-    IO_fd_fdID = NET_GetFileDescriptorID(env);\n-    CHECK_NULL(IO_fd_fdID);\n-\n-    ia4_clazz = (*env)->FindClass(env, \"java\/net\/Inet4Address\");\n-    CHECK_NULL(ia4_clazz);\n-    ia4_clazz = (*env)->NewGlobalRef(env, ia4_clazz);\n-    CHECK_NULL(ia4_clazz);\n-    ia4_ctor = (*env)->GetMethodID(env, ia4_clazz, \"<init>\", \"()V\");\n-    CHECK_NULL(ia4_ctor);\n-}\n-\n-JNIEXPORT void JNICALL\n-Java_java_net_TwoStacksPlainDatagramSocketImpl_bind0(JNIEnv *env, jobject this,\n-                                           jint port, jobject addressObj,\n-                                           jboolean exclBind) {\n-    jobject fdObj = (*env)->GetObjectField(env, this, pdsi_fdID);\n-    jobject fd1Obj = (*env)->GetObjectField(env, this, pdsi_fd1ID);\n-    int ipv6_supported = ipv6_available();\n-    int fd, fd1 = -1, lcladdrlen = 0;\n-    jint family;\n-    SOCKETADDRESS lcladdr;\n-\n-    family = getInetAddress_family(env, addressObj);\n-    JNU_CHECK_EXCEPTION(env);\n-    if (family == java_net_InetAddress_IPv6 && !ipv6_supported) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                        \"Protocol family not supported\");\n-        return;\n-    }\n-    if (IS_NULL(fdObj) || (ipv6_supported && IS_NULL(fd1Obj))) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", \"socket closed\");\n-        return;\n-    } else {\n-        fd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);\n-        if (ipv6_supported) {\n-            fd1 = (*env)->GetIntField(env, fd1Obj, IO_fd_fdID);\n-        }\n-    }\n-\n-    if (IS_NULL(addressObj)) {\n-        JNU_ThrowNullPointerException(env, \"argument address\");\n-        return;\n-    }\n-\n-    if (NET_InetAddressToSockaddr(env, addressObj, port, &lcladdr,\n-                                  &lcladdrlen, JNI_FALSE) != 0) {\n-        return;\n-    }\n-\n-    if (ipv6_supported) {\n-        struct ipv6bind v6bind;\n-        v6bind.addr = &lcladdr;\n-        v6bind.ipv4_fd = fd;\n-        v6bind.ipv6_fd = fd1;\n-        if (NET_BindV6(&v6bind, exclBind) != -1) {\n-            \/* check if the fds have changed *\/\n-            if (v6bind.ipv4_fd != fd) {\n-                fd = v6bind.ipv4_fd;\n-                if (fd == -1) {\n-                    \/* socket is closed. *\/\n-                    (*env)->SetObjectField(env, this, pdsi_fdID, NULL);\n-                } else {\n-                    \/* socket was re-created *\/\n-                    (*env)->SetIntField(env, fdObj, IO_fd_fdID, fd);\n-                }\n-            }\n-            if (v6bind.ipv6_fd != fd1) {\n-                fd1 = v6bind.ipv6_fd;\n-                if (fd1 == -1) {\n-                    \/* socket is closed. *\/\n-                    (*env)->SetObjectField(env, this, pdsi_fd1ID, NULL);\n-                } else {\n-                    \/* socket was re-created *\/\n-                    (*env)->SetIntField(env, fd1Obj, IO_fd_fdID, fd1);\n-                }\n-            }\n-        } else {\n-            \/* NET_BindV6() closes both sockets upon a failure *\/\n-            (*env)->SetObjectField(env, this, pdsi_fdID, NULL);\n-            (*env)->SetObjectField(env, this, pdsi_fd1ID, NULL);\n-            NET_ThrowCurrent (env, \"Cannot bind\");\n-            return;\n-        }\n-    } else {\n-        if (NET_WinBind(fd, &lcladdr, lcladdrlen, exclBind) == -1) {\n-            if (WSAGetLastError() == WSAEACCES) {\n-                WSASetLastError(WSAEADDRINUSE);\n-            }\n-            (*env)->SetObjectField(env, this, pdsi_fdID, NULL);\n-            NET_ThrowCurrent(env, \"Cannot bind\");\n-            closesocket(fd);\n-            return;\n-        }\n-    }\n-\n-    if (port == 0) {\n-        if (getsockname(fd == -1 ? fd1 : fd, &lcladdr.sa, &lcladdrlen) == -1) {\n-            NET_ThrowCurrent(env, \"getsockname\");\n-            return;\n-        }\n-        port = ntohs((u_short)GET_PORT(&lcladdr));\n-    }\n-    (*env)->SetIntField(env, this, pdsi_localPortID, port);\n-}\n-\n-\n-\/*\n- * Class:     java_net_TwoStacksPlainDatagramSocketImpl\n- * Method:    connect0\n- * Signature: (Ljava\/net\/InetAddress;I)V\n- *\/\n-\n-JNIEXPORT void JNICALL\n-Java_java_net_TwoStacksPlainDatagramSocketImpl_connect0\n-  (JNIEnv *env, jobject this, jobject address, jint port)\n-{\n-    jobject fdObj = (*env)->GetObjectField(env, this, pdsi_fdID);\n-    jobject fd1Obj = (*env)->GetObjectField(env, this, pdsi_fd1ID);\n-    jint fd = -1, fd1 = -1, fdc, family;\n-    SOCKETADDRESS rmtaddr;\n-    int rmtaddrlen = 0;\n-    DWORD x1, x2; \/* ignored result codes *\/\n-    int res, t;\n-\n-    if (IS_NULL(fdObj) && IS_NULL(fd1Obj)) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                        \"Socket closed\");\n-        return;\n-    }\n-\n-    if (!IS_NULL(fdObj)) {\n-        fd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);\n-    }\n-\n-    if (!IS_NULL(fd1Obj)) {\n-        fd1 = (*env)->GetIntField(env, fd1Obj, IO_fd_fdID);\n-    }\n-\n-    if (IS_NULL(address)) {\n-        JNU_ThrowNullPointerException(env, \"address\");\n-        return;\n-    }\n-\n-    family = getInetAddress_family(env, address);\n-    JNU_CHECK_EXCEPTION(env);\n-    if (family == java_net_InetAddress_IPv6 && !ipv6_available()) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                        \"Protocol family not supported\");\n-        return;\n-    }\n-\n-    fdc = family == java_net_InetAddress_IPv4 ? fd : fd1;\n-\n-    \/* SIO_UDP_CONNRESET fixes a bug introduced in Windows 2000, which\n-     * returns connection reset errors on connected UDP sockets (as well\n-     * as connected sockets). The solution is to only enable this feature\n-     * when the socket is connected\n-     *\/\n-    t = TRUE;\n-    res = WSAIoctl(fdc, SIO_UDP_CONNRESET, &t, sizeof(t), &x1, sizeof(x1), &x2, 0, 0);\n-\n-    if (NET_InetAddressToSockaddr(env, address, port, &rmtaddr,\n-                                  &rmtaddrlen, JNI_FALSE) != 0) {\n-        return;\n-    }\n-\n-    if (connect(fdc, &rmtaddr.sa, rmtaddrlen) == -1) {\n-        NET_ThrowCurrent(env, \"connect\");\n-        return;\n-    }\n-}\n-\n-\/*\n- * Class:     java_net_TwoStacksPlainDatagramSocketImpl\n- * Method:    disconnect0\n- * Signature: ()V\n- *\/\n-\n-JNIEXPORT void JNICALL\n-Java_java_net_TwoStacksPlainDatagramSocketImpl_disconnect0(JNIEnv *env, jobject this, jint family) {\n-    \/* The object's field *\/\n-    jobject fdObj;\n-    \/* The fdObj'fd *\/\n-    jint fd, len;\n-    SOCKETADDRESS addr;\n-    DWORD x1 = 0, x2 = 0; \/* ignored result codes *\/\n-    int t;\n-\n-    if (family == java_net_InetAddress_IPv4) {\n-        fdObj = (*env)->GetObjectField(env, this, pdsi_fdID);\n-        len = sizeof(struct sockaddr_in);\n-    } else {\n-        fdObj = (*env)->GetObjectField(env, this, pdsi_fd1ID);\n-        len = sizeof(struct sockaddr_in6);\n-    }\n-\n-    if (IS_NULL(fdObj)) {\n-        \/* disconnect doesn't throw any exceptions *\/\n-        return;\n-    }\n-    fd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);\n-\n-    memset((char *)&addr, 0, len);\n-    connect(fd, &addr.sa, len);\n-\n-    \/*\n-     * use SIO_UDP_CONNRESET\n-     * to disable ICMP port unreachable handling here.\n-     *\/\n-    t = FALSE;\n-    WSAIoctl(fd, SIO_UDP_CONNRESET, &t, sizeof(t), &x1, sizeof(x1), &x2, 0, 0);\n-}\n-\n-\/*\n- * Class:     java_net_TwoStacksPlainDatagramSocketImpl\n- * Method:    send0\n- * Signature: (Ljava\/net\/DatagramPacket;)V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_TwoStacksPlainDatagramSocketImpl_send0\n-  (JNIEnv *env, jobject this, jobject packet)\n-{\n-    char BUF[MAX_BUFFER_LEN];\n-    char *fullPacket;\n-    jobject fdObj;\n-    jint fd;\n-\n-    jobject iaObj;\n-    jint family;\n-\n-    jint packetBufferOffset, packetBufferLen, packetPort;\n-    jbyteArray packetBuffer;\n-    jboolean connected;\n-\n-    SOCKETADDRESS rmtaddr;\n-    struct sockaddr *addrp = 0;\n-    int addrlen = 0;\n-\n-    if (IS_NULL(packet)) {\n-        JNU_ThrowNullPointerException(env, \"null packet\");\n-        return;\n-    }\n-\n-    iaObj = (*env)->GetObjectField(env, packet, dp_addressID);\n-\n-    packetPort = (*env)->GetIntField(env, packet, dp_portID);\n-    packetBufferOffset = (*env)->GetIntField(env, packet, dp_offsetID);\n-    packetBuffer = (jbyteArray)(*env)->GetObjectField(env, packet, dp_bufID);\n-    connected = (*env)->GetBooleanField(env, this, pdsi_connected);\n-\n-    if (IS_NULL(iaObj) || IS_NULL(packetBuffer)) {\n-        JNU_ThrowNullPointerException(env, \"null address || null buffer\");\n-        return;\n-    }\n-\n-    family = getInetAddress_family(env, iaObj);\n-    JNU_CHECK_EXCEPTION(env);\n-    if (family == java_net_InetAddress_IPv4) {\n-        fdObj = (*env)->GetObjectField(env, this, pdsi_fdID);\n-    } else {\n-        if (!ipv6_available()) {\n-            JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                        \"Protocol not allowed\");\n-            return;\n-        }\n-        fdObj = (*env)->GetObjectField(env, this, pdsi_fd1ID);\n-    }\n-\n-    if (IS_NULL(fdObj)) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                        \"Socket closed\");\n-        return;\n-    }\n-    fd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);\n-\n-    packetBufferLen = (*env)->GetIntField(env, packet, dp_lengthID);\n-    \/* Note: the buffer needn't be greater than 65,536 (0xFFFF)...\n-     * the maximum size of an IP packet. Anything bigger is truncated anyway.\n-     *\/\n-    if (packetBufferLen > MAX_PACKET_LEN) {\n-        packetBufferLen = MAX_PACKET_LEN;\n-    }\n-\n-    \/\/ sockaddr arg to sendto() is null if already connected\n-    if (!connected) {\n-        if (NET_InetAddressToSockaddr(env, iaObj, packetPort, &rmtaddr,\n-                                      &addrlen, JNI_FALSE) != 0) {\n-            return;\n-        }\n-        addrp = &rmtaddr.sa;\n-    }\n-\n-    if (packetBufferLen > MAX_BUFFER_LEN) {\n-        \/* When JNI-ifying the JDK's IO routines, we turned\n-         * reads and writes of byte arrays of size greater\n-         * than 2048 bytes into several operations of size 2048.\n-         * This saves a malloc()\/memcpy()\/free() for big\n-         * buffers.  This is OK for file IO and TCP, but that\n-         * strategy violates the semantics of a datagram protocol.\n-         * (one big send) != (several smaller sends).  So here\n-         * we *must* alloc the buffer.  Note it needn't be bigger\n-         * than 65,536 (0xFFFF) the max size of an IP packet.\n-         * anything bigger is truncated anyway.\n-         *\/\n-        fullPacket = (char *)malloc(packetBufferLen);\n-        if (!fullPacket) {\n-            JNU_ThrowOutOfMemoryError(env, \"Send buf native heap allocation failed\");\n-            return;\n-        }\n-    } else {\n-        fullPacket = &(BUF[0]);\n-    }\n-\n-    (*env)->GetByteArrayRegion(env, packetBuffer, packetBufferOffset,\n-                               packetBufferLen, (jbyte *)fullPacket);\n-    if (sendto(fd, fullPacket, packetBufferLen, 0, addrp,\n-               addrlen) == SOCKET_ERROR)\n-    {\n-        NET_ThrowCurrent(env, \"Datagram send failed\");\n-    }\n-\n-    if (packetBufferLen > MAX_BUFFER_LEN) {\n-        free(fullPacket);\n-    }\n-}\n-\n-\/*\n- * check which socket was last serviced when there was data on both sockets.\n- * Only call this if sure that there is data on both sockets.\n- *\/\n-static int checkLastFD (JNIEnv *env, jobject this, int fd, int fd1) {\n-    int nextfd, lastfd = (*env)->GetIntField(env, this, pdsi_lastfdID);\n-    if (lastfd == -1) {\n-        \/* arbitrary. Choose fd *\/\n-        (*env)->SetIntField(env, this, pdsi_lastfdID, fd);\n-        return fd;\n-    } else {\n-        if (lastfd == fd) {\n-            nextfd = fd1;\n-        } else {\n-            nextfd = fd;\n-        }\n-        (*env)->SetIntField(env, this, pdsi_lastfdID, nextfd);\n-        return nextfd;\n-    }\n-}\n-\n-\/*\n- * Class:     java_net_TwoStacksPlainDatagramSocketImpl\n- * Method:    peek\n- * Signature: (Ljava\/net\/InetAddress;)I\n- *\/\n-JNIEXPORT jint JNICALL\n-Java_java_net_TwoStacksPlainDatagramSocketImpl_peek(JNIEnv *env, jobject this,\n-                                           jobject addressObj) {\n-\n-    jobject fdObj = (*env)->GetObjectField(env, this, pdsi_fdID);\n-    jint timeout = (*env)->GetIntField(env, this, pdsi_timeoutID);\n-    jint fd;\n-\n-    \/* The address and family fields of addressObj *\/\n-    jint address, family;\n-\n-    int n;\n-    SOCKETADDRESS remote_addr;\n-    jint remote_addrsize = sizeof(SOCKETADDRESS);\n-    char buf[1];\n-    BOOL retry;\n-    jlong prevTime = 0;\n-\n-    if (IS_NULL(fdObj)) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", \"Socket closed\");\n-        return -1;\n-    } else {\n-        fd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);\n-        if (fd < 0) {\n-           JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                           \"socket closed\");\n-           return -1;\n-        }\n-    }\n-    if (IS_NULL(addressObj)) {\n-        JNU_ThrowNullPointerException(env, \"Null address in peek()\");\n-        return -1;\n-    } else {\n-        address = getInetAddress_addr(env, addressObj);\n-        JNU_CHECK_EXCEPTION_RETURN(env, -1);\n-        \/* We only handle IPv4 for now. Will support IPv6 once its in the os *\/\n-        family = AF_INET;\n-    }\n-\n-    do {\n-        retry = FALSE;\n-\n-        \/*\n-         * If a timeout has been specified then we select on the socket\n-         * waiting for a read event or a timeout.\n-         *\/\n-        if (timeout) {\n-            int ret;\n-            prevTime = JVM_CurrentTimeMillis(env, 0);\n-            ret = NET_Timeout (fd, timeout);\n-            if (ret == 0) {\n-                JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketTimeoutException\",\n-                                \"Peek timed out\");\n-                return ret;\n-            } else if (ret == -1) {\n-                NET_ThrowCurrent(env, \"timeout in datagram socket peek\");\n-                return ret;\n-            }\n-        }\n-\n-        \/* now try the peek *\/\n-        n = recvfrom(fd, buf, 1, MSG_PEEK, &remote_addr.sa, &remote_addrsize);\n-\n-        if (n == SOCKET_ERROR) {\n-            if (WSAGetLastError() == WSAECONNRESET) {\n-                jboolean connected;\n-\n-                \/*\n-                 * An icmp port unreachable - we must receive this as Windows\n-                 * does not reset the state of the socket until this has been\n-                 * received.\n-                 *\/\n-                purgeOutstandingICMP(env, this, fd);\n-\n-                connected =  (*env)->GetBooleanField(env, this, pdsi_connected);\n-                if (connected) {\n-                    JNU_ThrowByName(env, JNU_JAVANETPKG \"PortUnreachableException\",\n-                                       \"ICMP Port Unreachable\");\n-                    return 0;\n-                }\n-\n-                \/*\n-                 * If a timeout was specified then we need to adjust it because\n-                 * we may have used up some of the timeout befor the icmp port\n-                 * unreachable arrived.\n-                 *\/\n-                if (timeout) {\n-                    jlong newTime = JVM_CurrentTimeMillis(env, 0);\n-                    timeout -= (jint)(newTime - prevTime);\n-                    if (timeout <= 0) {\n-                        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketTimeoutException\",\n-                                \"Receive timed out\");\n-                        return 0;\n-                    }\n-                    prevTime = newTime;\n-                }\n-\n-                \/* Need to retry the recv *\/\n-                retry = TRUE;\n-            }\n-        }\n-    } while (retry);\n-\n-    if (n == SOCKET_ERROR && WSAGetLastError() != WSAEMSGSIZE) {\n-        NET_ThrowCurrent(env, \"Datagram peek failed\");\n-        return 0;\n-    }\n-    setInetAddress_addr(env, addressObj, ntohl(remote_addr.sa4.sin_addr.s_addr));\n-    JNU_CHECK_EXCEPTION_RETURN(env, -1);\n-    setInetAddress_family(env, addressObj, java_net_InetAddress_IPv4);\n-    JNU_CHECK_EXCEPTION_RETURN(env, -1);\n-\n-    \/* return port *\/\n-    return ntohs(remote_addr.sa4.sin_port);\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_java_net_TwoStacksPlainDatagramSocketImpl_peekData(JNIEnv *env, jobject this,\n-                                           jobject packet) {\n-\n-     char BUF[MAX_BUFFER_LEN];\n-    char *fullPacket;\n-    jobject fdObj = (*env)->GetObjectField(env, this, pdsi_fdID);\n-    jobject fd1Obj = (*env)->GetObjectField(env, this, pdsi_fd1ID);\n-    jint timeout = (*env)->GetIntField(env, this, pdsi_timeoutID);\n-\n-    jbyteArray packetBuffer;\n-    jint packetBufferOffset, packetBufferLen;\n-\n-    int fd = -1, fd1 = -1, fduse, nsockets = 0, errorCode;\n-    int port;\n-\n-    int checkBoth = 0;\n-    int n;\n-    SOCKETADDRESS remote_addr;\n-    jint remote_addrsize = sizeof(SOCKETADDRESS);\n-    BOOL retry;\n-    jlong prevTime = 0;\n-\n-    if (!IS_NULL(fdObj)) {\n-        fd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);\n-        if (fd < 0) {\n-           JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                           \"socket closed\");\n-           return -1;\n-        }\n-        nsockets = 1;\n-    }\n-\n-    if (!IS_NULL(fd1Obj)) {\n-        fd1 = (*env)->GetIntField(env, fd1Obj, IO_fd_fdID);\n-        if (fd1 < 0) {\n-           JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                           \"socket closed\");\n-           return -1;\n-        }\n-        nsockets ++;\n-    }\n-\n-    switch (nsockets) {\n-      case 0:\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                       \"socket closed\");\n-        return -1;\n-      case 1:\n-        if (!IS_NULL(fdObj)) {\n-           fduse = fd;\n-        } else {\n-           fduse = fd1;\n-        }\n-        break;\n-      case 2:\n-        checkBoth = TRUE;\n-        break;\n-    }\n-\n-    if (IS_NULL(packet)) {\n-        JNU_ThrowNullPointerException(env, \"packet\");\n-        return -1;\n-    }\n-\n-    packetBuffer = (*env)->GetObjectField(env, packet, dp_bufID);\n-\n-    if (IS_NULL(packetBuffer)) {\n-        JNU_ThrowNullPointerException(env, \"packet buffer\");\n-        return -1;\n-    }\n-\n-    packetBufferOffset = (*env)->GetIntField(env, packet, dp_offsetID);\n-    packetBufferLen = (*env)->GetIntField(env, packet, dp_bufLengthID);\n-\n-    if (packetBufferLen > MAX_BUFFER_LEN) {\n-\n-        \/* When JNI-ifying the JDK's IO routines, we turned\n-         * read's and write's of byte arrays of size greater\n-         * than 2048 bytes into several operations of size 2048.\n-         * This saves a malloc()\/memcpy()\/free() for big\n-         * buffers.  This is OK for file IO and TCP, but that\n-         * strategy violates the semantics of a datagram protocol.\n-         * (one big send) != (several smaller sends).  So here\n-         * we *must* alloc the buffer.  Note it needn't be bigger\n-         * than 65,536 (0xFFFF) the max size of an IP packet.\n-         * anything bigger is truncated anyway.\n-         *\/\n-        fullPacket = (char *)malloc(packetBufferLen);\n-        if (!fullPacket) {\n-            JNU_ThrowOutOfMemoryError(env, \"Native heap allocation failed\");\n-            return -1;\n-        }\n-    } else {\n-        fullPacket = &(BUF[0]);\n-    }\n-\n-    do {\n-        int ret;\n-        retry = FALSE;\n-\n-        \/*\n-         * If a timeout has been specified then we select on the socket\n-         * waiting for a read event or a timeout.\n-         *\/\n-        if (checkBoth) {\n-            int t = timeout == 0 ? -1: timeout;\n-            prevTime = JVM_CurrentTimeMillis(env, 0);\n-            ret = NET_Timeout2 (fd, fd1, t, &fduse);\n-            \/* all subsequent calls to recv() or select() will use the same fd\n-             * for this call to peek() *\/\n-            if (ret <= 0) {\n-                if (ret == 0) {\n-                    JNU_ThrowByName(env,JNU_JAVANETPKG \"SocketTimeoutException\",\n-                                        \"Peek timed out\");\n-                } else if (ret == -1) {\n-                    NET_ThrowCurrent(env, \"timeout in datagram socket peek\");\n-                }\n-                if (packetBufferLen > MAX_BUFFER_LEN) {\n-                    free(fullPacket);\n-                }\n-                return -1;\n-            }\n-            if (ret == 2) {\n-                fduse = checkLastFD (env, this, fd, fd1);\n-            }\n-            checkBoth = FALSE;\n-        } else if (timeout) {\n-            if (prevTime == 0) {\n-                prevTime = JVM_CurrentTimeMillis(env, 0);\n-            }\n-            ret = NET_Timeout (fduse, timeout);\n-            if (ret <= 0) {\n-                if (ret == 0) {\n-                    JNU_ThrowByName(env,JNU_JAVANETPKG \"SocketTimeoutException\",\n-                                    \"Receive timed out\");\n-                } else if (ret == -1) {\n-                    JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                                    \"Socket closed\");\n-                }\n-                if (packetBufferLen > MAX_BUFFER_LEN) {\n-                    free(fullPacket);\n-                }\n-                return -1;\n-            }\n-        }\n-\n-        \/* receive the packet *\/\n-        n = recvfrom(fduse, fullPacket, packetBufferLen, MSG_PEEK,\n-                     &remote_addr.sa, &remote_addrsize);\n-        port = (int) ntohs ((u_short) GET_PORT((SOCKETADDRESS *)&remote_addr));\n-        if (n == SOCKET_ERROR) {\n-            if (WSAGetLastError() == WSAECONNRESET) {\n-                jboolean connected;\n-\n-                \/*\n-                 * An icmp port unreachable - we must receive this as Windows\n-                 * does not reset the state of the socket until this has been\n-                 * received.\n-                 *\/\n-                purgeOutstandingICMP(env, this, fduse);\n-\n-                connected = (*env)->GetBooleanField(env, this, pdsi_connected);\n-                if (connected) {\n-                    JNU_ThrowByName(env, JNU_JAVANETPKG \"PortUnreachableException\",\n-                                       \"ICMP Port Unreachable\");\n-\n-                    if (packetBufferLen > MAX_BUFFER_LEN) {\n-                        free(fullPacket);\n-                    }\n-                    return -1;\n-                }\n-\n-                \/*\n-                 * If a timeout was specified then we need to adjust it because\n-                 * we may have used up some of the timeout befor the icmp port\n-                 * unreachable arrived.\n-                 *\/\n-                if (timeout) {\n-                    jlong newTime = JVM_CurrentTimeMillis(env, 0);\n-                    timeout -= (jint)(newTime - prevTime);\n-                    if (timeout <= 0) {\n-                        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketTimeoutException\",\n-                                \"Receive timed out\");\n-                        if (packetBufferLen > MAX_BUFFER_LEN) {\n-                            free(fullPacket);\n-                        }\n-                        return -1;\n-                    }\n-                    prevTime = newTime;\n-                }\n-                retry = TRUE;\n-            }\n-        }\n-    } while (retry);\n-\n-    \/* truncate the data if the packet's length is too small *\/\n-    if (n > packetBufferLen) {\n-        n = packetBufferLen;\n-    }\n-    if (n < 0) {\n-        errorCode = WSAGetLastError();\n-        \/* check to see if it's because the buffer was too small *\/\n-        if (errorCode == WSAEMSGSIZE) {\n-            \/* it is because the buffer is too small. It's UDP, it's\n-             * unreliable, it's all good. discard the rest of the\n-             * data..\n-             *\/\n-            n = packetBufferLen;\n-        } else {\n-            \/* failure *\/\n-            (*env)->SetIntField(env, packet, dp_lengthID, 0);\n-        }\n-    }\n-    if (n == -1) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", \"socket closed\");\n-        if (packetBufferLen > MAX_BUFFER_LEN) {\n-            free(fullPacket);\n-        }\n-        return -1;\n-    } else if (n == -2) {\n-        JNU_ThrowByName(env, JNU_JAVAIOPKG \"InterruptedIOException\",\n-                        \"operation interrupted\");\n-        if (packetBufferLen > MAX_BUFFER_LEN) {\n-            free(fullPacket);\n-        }\n-        return -1;\n-    } else if (n < 0) {\n-        NET_ThrowCurrent(env, \"Datagram receive failed\");\n-        if (packetBufferLen > MAX_BUFFER_LEN) {\n-            free(fullPacket);\n-        }\n-        return -1;\n-    } else {\n-        jobject packetAddress;\n-\n-        \/*\n-         * Check if there is an InetAddress already associated with this\n-         * packet. If so we check if it is the same source address. We\n-         * can't update any existing InetAddress because it is immutable\n-         *\/\n-        packetAddress = (*env)->GetObjectField(env, packet, dp_addressID);\n-        if (packetAddress != NULL) {\n-            if (!NET_SockaddrEqualsInetAddress(env, &remote_addr,\n-                                               packetAddress)) {\n-                \/* force a new InetAddress to be created *\/\n-                packetAddress = NULL;\n-            }\n-        }\n-        if (packetAddress == NULL) {\n-            packetAddress = NET_SockaddrToInetAddress(env, &remote_addr,\n-                                                      &port);\n-            \/* stuff the new Inetaddress in the packet *\/\n-            (*env)->SetObjectField(env, packet, dp_addressID, packetAddress);\n-        }\n-\n-        \/* populate the packet *\/\n-        (*env)->SetByteArrayRegion(env, packetBuffer, packetBufferOffset, n,\n-                                   (jbyte *)fullPacket);\n-        (*env)->SetIntField(env, packet, dp_portID, port);\n-        (*env)->SetIntField(env, packet, dp_lengthID, n);\n-    }\n-\n-    \/* make sure receive() picks up the right fd *\/\n-    (*env)->SetIntField(env, this, pdsi_fduseID, fduse);\n-\n-    if (packetBufferLen > MAX_BUFFER_LEN) {\n-        free(fullPacket);\n-    }\n-    return port;\n-}\n-\n-\/*\n- * Class:     java_net_TwoStacksPlainDatagramSocketImpl\n- * Method:    receive\n- * Signature: (Ljava\/net\/DatagramPacket;)V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_TwoStacksPlainDatagramSocketImpl_receive0(JNIEnv *env, jobject this,\n-                                              jobject packet) {\n-\n-    char BUF[MAX_BUFFER_LEN];\n-    char *fullPacket;\n-    jobject fdObj = (*env)->GetObjectField(env, this, pdsi_fdID);\n-    jobject fd1Obj = (*env)->GetObjectField(env, this, pdsi_fd1ID);\n-    jint timeout = (*env)->GetIntField(env, this, pdsi_timeoutID);\n-    jbyteArray packetBuffer;\n-    jint packetBufferOffset, packetBufferLen;\n-    int ipv6_supported = ipv6_available();\n-\n-    \/* as a result of the changes for ipv6, peek() or peekData()\n-     * must be called prior to receive() so that fduse can be set.\n-     *\/\n-    int fd = -1, fd1 = -1, fduse, errorCode;\n-\n-    int n, nsockets=0;\n-    SOCKETADDRESS remote_addr;\n-    jint remote_addrsize = sizeof(SOCKETADDRESS);\n-    BOOL retry;\n-    jlong prevTime = 0, selectTime=0;\n-    jboolean connected;\n-\n-    if (IS_NULL(fdObj) && IS_NULL(fd1Obj)) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                        \"Socket closed\");\n-        return;\n-    }\n-\n-    if (!IS_NULL(fdObj)) {\n-        fd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);\n-        nsockets ++;\n-    }\n-    if (!IS_NULL(fd1Obj)) {\n-        fd1 = (*env)->GetIntField(env, fd1Obj, IO_fd_fdID);\n-        nsockets ++;\n-    }\n-\n-    if (nsockets == 2) { \/* need to choose one of them *\/\n-        \/* was fduse set in peek? *\/\n-        fduse = (*env)->GetIntField(env, this, pdsi_fduseID);\n-        if (fduse == -1) {\n-            \/* not set in peek(), must select on both sockets *\/\n-            int ret, t = (timeout == 0) ? -1: timeout;\n-            ret = NET_Timeout2 (fd, fd1, t, &fduse);\n-            if (ret == 2) {\n-                fduse = checkLastFD (env, this, fd, fd1);\n-            } else if (ret <= 0) {\n-                if (ret == 0) {\n-                    JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketTimeoutException\",\n-                                    \"Receive timed out\");\n-                } else if (ret == -1) {\n-                    JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                                    \"Socket closed\");\n-                }\n-                return;\n-            }\n-        }\n-    } else if (!ipv6_supported) {\n-        fduse = fd;\n-    } else if (IS_NULL(fdObj)) {\n-        \/* ipv6 supported: and this socket bound to an IPV6 only address *\/\n-        fduse = fd1;\n-    } else {\n-        \/* ipv6 supported: and this socket bound to an IPV4 only address *\/\n-        fduse = fd;\n-    }\n-\n-    if (IS_NULL(packet)) {\n-        JNU_ThrowNullPointerException(env, \"packet\");\n-        return;\n-    }\n-\n-    packetBuffer = (*env)->GetObjectField(env, packet, dp_bufID);\n-\n-    if (IS_NULL(packetBuffer)) {\n-        JNU_ThrowNullPointerException(env, \"packet buffer\");\n-        return;\n-    }\n-\n-    packetBufferOffset = (*env)->GetIntField(env, packet, dp_offsetID);\n-    packetBufferLen = (*env)->GetIntField(env, packet, dp_bufLengthID);\n-\n-    if (packetBufferLen > MAX_BUFFER_LEN) {\n-\n-        \/* When JNI-ifying the JDK's IO routines, we turned\n-         * read's and write's of byte arrays of size greater\n-         * than 2048 bytes into several operations of size 2048.\n-         * This saves a malloc()\/memcpy()\/free() for big\n-         * buffers.  This is OK for file IO and TCP, but that\n-         * strategy violates the semantics of a datagram protocol.\n-         * (one big send) != (several smaller sends).  So here\n-         * we *must* alloc the buffer.  Note it needn't be bigger\n-         * than 65,536 (0xFFFF) the max size of an IP packet.\n-         * anything bigger is truncated anyway.\n-         *\/\n-        fullPacket = (char *)malloc(packetBufferLen);\n-        if (!fullPacket) {\n-            JNU_ThrowOutOfMemoryError(env, \"Receive buf native heap allocation failed\");\n-            return;\n-        }\n-    } else {\n-        fullPacket = &(BUF[0]);\n-    }\n-\n-\n-\n-    \/*\n-     * If we are not connected then we need to know if a timeout has been\n-     * specified and if so we need to pick up the current time. These are\n-     * required in order to implement the semantics of timeout, viz :-\n-     * timeout set to t1 but ICMP port unreachable arrives in t2 where\n-     * t2 < t1. In this case we must discard the ICMP packets and then\n-     * wait for the next packet up to a maximum of t1 minus t2.\n-     *\/\n-    connected = (*env)->GetBooleanField(env, this, pdsi_connected);\n-    if (!connected && timeout && !ipv6_supported) {\n-        prevTime = JVM_CurrentTimeMillis(env, 0);\n-    }\n-\n-    if (timeout && nsockets == 1) {\n-        int ret;\n-        ret = NET_Timeout(fduse, timeout);\n-        if (ret <= 0) {\n-            if (ret == 0) {\n-                JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketTimeoutException\",\n-                                \"Receive timed out\");\n-            } else if (ret == -1) {\n-                JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                                \"Socket closed\");\n-            }\n-            if (packetBufferLen > MAX_BUFFER_LEN) {\n-                free(fullPacket);\n-            }\n-            return;\n-        }\n-    }\n-\n-    \/*\n-     * Loop only if we discarding ICMP port unreachable packets\n-     *\/\n-    do {\n-        retry = FALSE;\n-\n-        \/* receive the packet *\/\n-        n = recvfrom(fduse, fullPacket, packetBufferLen, 0, &remote_addr.sa,\n-                     &remote_addrsize);\n-\n-        if (n == SOCKET_ERROR) {\n-            if (WSAGetLastError() == WSAECONNRESET) {\n-                \/*\n-                 * An icmp port unreachable has been received - consume any other\n-                 * outstanding packets.\n-                 *\/\n-                purgeOutstandingICMP(env, this, fduse);\n-\n-                \/*\n-                 * If connected throw a PortUnreachableException\n-                 *\/\n-\n-                if (connected) {\n-                    JNU_ThrowByName(env, JNU_JAVANETPKG \"PortUnreachableException\",\n-                                       \"ICMP Port Unreachable\");\n-\n-                    if (packetBufferLen > MAX_BUFFER_LEN) {\n-                        free(fullPacket);\n-                    }\n-\n-                    return;\n-                }\n-\n-                \/*\n-                 * If a timeout was specified then we need to adjust it because\n-                 * we may have used up some of the timeout before the icmp port\n-                 * unreachable arrived.\n-                 *\/\n-                if (timeout) {\n-                    int ret;\n-                    jlong newTime = JVM_CurrentTimeMillis(env, 0);\n-                    timeout -= (jint)(newTime - prevTime);\n-                    prevTime = newTime;\n-\n-                    if (timeout <= 0) {\n-                        ret = 0;\n-                    } else {\n-                        ret = NET_Timeout(fduse, timeout);\n-                    }\n-\n-                    if (ret <= 0) {\n-                        if (ret == 0) {\n-                            JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketTimeoutException\",\n-                                            \"Receive timed out\");\n-                        } else if (ret == -1) {\n-                            JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                                            \"Socket closed\");\n-                        }\n-                        if (packetBufferLen > MAX_BUFFER_LEN) {\n-                            free(fullPacket);\n-                        }\n-                        return;\n-                    }\n-                }\n-\n-                \/*\n-                 * An ICMP port unreachable was received but we are\n-                 * not connected so ignore it.\n-                 *\/\n-                retry = TRUE;\n-            }\n-        }\n-    } while (retry);\n-\n-    \/* truncate the data if the packet's length is too small *\/\n-    if (n > packetBufferLen) {\n-        n = packetBufferLen;\n-    }\n-    if (n < 0) {\n-        errorCode = WSAGetLastError();\n-        \/* check to see if it's because the buffer was too small *\/\n-        if (errorCode == WSAEMSGSIZE) {\n-            \/* it is because the buffer is too small. It's UDP, it's\n-             * unreliable, it's all good. discard the rest of the\n-             * data..\n-             *\/\n-            n = packetBufferLen;\n-        } else {\n-            \/* failure *\/\n-            (*env)->SetIntField(env, packet, dp_lengthID, 0);\n-        }\n-    }\n-    if (n == -1) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", \"socket closed\");\n-    } else if (n == -2) {\n-        JNU_ThrowByName(env, JNU_JAVAIOPKG \"InterruptedIOException\",\n-                        \"operation interrupted\");\n-    } else if (n < 0) {\n-        NET_ThrowCurrent(env, \"Datagram receive failed\");\n-    } else {\n-        int port = 0;\n-        jobject packetAddress;\n-\n-        \/*\n-         * Check if there is an InetAddress already associated with this\n-         * packet. If so we check if it is the same source address. We\n-         * can't update any existing InetAddress because it is immutable\n-         *\/\n-        packetAddress = (*env)->GetObjectField(env, packet, dp_addressID);\n-        if (packetAddress != NULL) {\n-            if (!NET_SockaddrEqualsInetAddress(env, &remote_addr,\n-                                               packetAddress)) {\n-                \/* force a new InetAddress to be created *\/\n-                packetAddress = NULL;\n-            }\n-        }\n-        if (packetAddress == NULL) {\n-            packetAddress = NET_SockaddrToInetAddress(env, &remote_addr,\n-                                                      &port);\n-            \/* stuff the new Inetaddress in the packet *\/\n-            (*env)->SetObjectField(env, packet, dp_addressID, packetAddress);\n-        } else {\n-            \/* only get the new port number *\/\n-            port = NET_GetPortFromSockaddr(&remote_addr);\n-        }\n-        \/* populate the packet *\/\n-        (*env)->SetByteArrayRegion(env, packetBuffer, packetBufferOffset, n,\n-                                   (jbyte *)fullPacket);\n-        (*env)->SetIntField(env, packet, dp_portID, port);\n-        (*env)->SetIntField(env, packet, dp_lengthID, n);\n-    }\n-    if (packetBufferLen > MAX_BUFFER_LEN) {\n-        free(fullPacket);\n-    }\n-}\n-\n-\/*\n- * Class:     java_net_TwoStacksPlainDatagramSocketImpl\n- * Method:    datagramSocketCreate\n- * Signature: ()V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_TwoStacksPlainDatagramSocketImpl_datagramSocketCreate(JNIEnv *env,\n-                                                           jobject this) {\n-    jobject fdObj = (*env)->GetObjectField(env, this, pdsi_fdID);\n-    jobject fd1Obj = (*env)->GetObjectField(env, this, pdsi_fd1ID);\n-\n-    int fd, fd1;\n-    int t = TRUE;\n-    DWORD x1, x2; \/* ignored result codes *\/\n-    int ipv6_supported = ipv6_available();\n-\n-    int arg = -1;\n-\n-    if (IS_NULL(fdObj) || (ipv6_supported && IS_NULL(fd1Obj))) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", \"Socket closed\");\n-        return;\n-    } else {\n-        fd =  (int) socket (AF_INET, SOCK_DGRAM, 0);\n-    }\n-    if (fd == SOCKET_ERROR) {\n-        NET_ThrowCurrent(env, \"Socket creation failed\");\n-        return;\n-    }\n-    SetHandleInformation((HANDLE)(UINT_PTR)fd, HANDLE_FLAG_INHERIT, FALSE);\n-    (*env)->SetIntField(env, fdObj, IO_fd_fdID, fd);\n-    NET_SetSockOpt(fd, SOL_SOCKET, SO_BROADCAST, (char*)&t, sizeof(BOOL));\n-\n-    if (ipv6_supported) {\n-        \/* SIO_UDP_CONNRESET fixes a bug introduced in Windows 2000, which\n-         * returns connection reset errors un connected UDP sockets (as well\n-         * as connected sockets. The solution is to only enable this feature\n-         * when the socket is connected\n-         *\/\n-        t = FALSE;\n-        WSAIoctl(fd,SIO_UDP_CONNRESET,&t,sizeof(t),&x1,sizeof(x1),&x2,0,0);\n-        t = TRUE;\n-        fd1 = socket (AF_INET6, SOCK_DGRAM, 0);\n-        if (fd1 == SOCKET_ERROR) {\n-            NET_ThrowCurrent(env, \"Socket creation failed\");\n-            return;\n-        }\n-        NET_SetSockOpt(fd1, SOL_SOCKET, SO_BROADCAST, (char*)&t, sizeof(BOOL));\n-        t = FALSE;\n-        WSAIoctl(fd1,SIO_UDP_CONNRESET,&t,sizeof(t),&x1,sizeof(x1),&x2,0,0);\n-        (*env)->SetIntField(env, fd1Obj, IO_fd_fdID, fd1);\n-        SetHandleInformation((HANDLE)(UINT_PTR)fd1, HANDLE_FLAG_INHERIT, FALSE);\n-    } else {\n-        \/* drop the second fd *\/\n-        (*env)->SetObjectField(env, this, pdsi_fd1ID, NULL);\n-    }\n-}\n-\n-\/*\n- * Class:     java_net_TwoStacksPlainDatagramSocketImpl\n- * Method:    datagramSocketClose\n- * Signature: ()V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_TwoStacksPlainDatagramSocketImpl_datagramSocketClose(JNIEnv *env,\n-                                                          jobject this) {\n-    \/*\n-     * REMIND: PUT A LOCK AROUND THIS CODE\n-     *\/\n-    jobject fdObj = (*env)->GetObjectField(env, this, pdsi_fdID);\n-    jobject fd1Obj = (*env)->GetObjectField(env, this, pdsi_fd1ID);\n-    int ipv6_supported = ipv6_available();\n-    int fd = -1, fd1 = -1;\n-\n-    if (IS_NULL(fdObj) && (!ipv6_supported || IS_NULL(fd1Obj))) {\n-        return;\n-    }\n-\n-    if (!IS_NULL(fdObj)) {\n-        fd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);\n-        if (fd != -1) {\n-            (*env)->SetIntField(env, fdObj, IO_fd_fdID, -1);\n-            NET_SocketClose(fd);\n-        }\n-    }\n-\n-    if (ipv6_supported && fd1Obj != NULL) {\n-        fd1 = (*env)->GetIntField(env, fd1Obj, IO_fd_fdID);\n-        if (fd1 == -1) {\n-            return;\n-        }\n-        (*env)->SetIntField(env, fd1Obj, IO_fd_fdID, -1);\n-        NET_SocketClose(fd1);\n-    }\n-}\n-\n-\/*\n- * check the addresses attached to the NetworkInterface object\n- * and return the first one (of the requested family Ipv4 or Ipv6)\n- * in *iaddr\n- *\/\n-\n-static int getInetAddrFromIf (JNIEnv *env, int family, jobject nif, jobject *iaddr)\n-{\n-    jobjectArray addrArray;\n-    static jfieldID ni_addrsID=0;\n-    jsize len;\n-    jobject addr;\n-    int i;\n-\n-    if (ni_addrsID == NULL ) {\n-        jclass c = (*env)->FindClass(env, \"java\/net\/NetworkInterface\");\n-        CHECK_NULL_RETURN (c, -1);\n-        ni_addrsID = (*env)->GetFieldID(env, c, \"addrs\",\n-                                        \"[Ljava\/net\/InetAddress;\");\n-        CHECK_NULL_RETURN (ni_addrsID, -1);\n-    }\n-\n-    addrArray = (*env)->GetObjectField(env, nif, ni_addrsID);\n-    len = (*env)->GetArrayLength(env, addrArray);\n-\n-    \/*\n-     * Check that there is at least one address bound to this\n-     * interface.\n-     *\/\n-    if (len < 1) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-            \"bad argument for IP_MULTICAST_IF2: No IP addresses bound to interface\");\n-        return -1;\n-    }\n-    for (i=0; i<len; i++) {\n-        int fam;\n-        addr = (*env)->GetObjectArrayElement(env, addrArray, i);\n-        fam = getInetAddress_family(env, addr);\n-        JNU_CHECK_EXCEPTION_RETURN(env, -1);\n-        if (fam == family) {\n-            *iaddr = addr;\n-            return 0;\n-        }\n-    }\n-    return -1;\n-}\n-\n-static int getInet4AddrFromIf (JNIEnv *env, jobject nif, struct in_addr *iaddr)\n-{\n-    jobject addr;\n-\n-    int ret = getInetAddrFromIf(env, java_net_InetAddress_IPv4, nif, &addr);\n-    if (ret == -1) {\n-        return -1;\n-    }\n-\n-    iaddr->s_addr = htonl(getInetAddress_addr(env, addr));\n-    JNU_CHECK_EXCEPTION_RETURN(env, -1);\n-    return 0;\n-}\n-\n-\/* Get the multicasting index from the interface *\/\n-\n-static int getIndexFromIf (JNIEnv *env, jobject nif) {\n-    static jfieldID ni_indexID = NULL;\n-\n-    if (ni_indexID == NULL) {\n-        jclass c = (*env)->FindClass(env, \"java\/net\/NetworkInterface\");\n-        CHECK_NULL_RETURN(c, -1);\n-        ni_indexID = (*env)->GetFieldID(env, c, \"index\", \"I\");\n-        CHECK_NULL_RETURN(ni_indexID, -1);\n-    }\n-\n-    return (*env)->GetIntField(env, nif, ni_indexID);\n-}\n-\n-static int isAdapterIpv6Enabled(JNIEnv *env, int index) {\n-  netif *ifList, *curr;\n-  int ipv6Enabled = 0;\n-  if (getAllInterfacesAndAddresses(env, &ifList) < 0) {\n-      return ipv6Enabled;\n-  }\n-\n-  \/* search by index *\/\n-  curr = ifList;\n-  while (curr != NULL) {\n-      if (index == curr->index) {\n-          break;\n-      }\n-      curr = curr->next;\n-  }\n-\n-  \/* if found ipv6Index != 0 then interface is configured with IPV6 *\/\n-  if ((curr != NULL) && (curr->ipv6Index !=0)) {\n-      ipv6Enabled = 1;\n-  }\n-\n-  \/* release the interface list *\/\n-  free_netif(ifList);\n-\n-  return ipv6Enabled;\n-}\n-\n-\/*\n- * Sets the multicast interface.\n- *\n- * SocketOptions.IP_MULTICAST_IF (argument is an InetAddress) :-\n- *      IPv4:   set outgoing multicast interface using\n- *              IPPROTO_IP\/IP_MULTICAST_IF\n- *\n- *      IPv6:   Get the interface to which the\n- *              InetAddress is bound\n- *              and do same as SockOptions.IF_MULTICAST_IF2\n- *\n- * SockOptions.IF_MULTICAST_IF2 (argument is a NetworkInterface ) :-\n- *      For each stack:\n- *      IPv4:   Obtain IP address bound to network interface\n- *              (NetworkInterface.addres[0])\n- *              set outgoing multicast interface using\n- *              IPPROTO_IP\/IP_MULTICAST_IF\n- *\n- *      IPv6:   Obtain NetworkInterface.index\n- *              Set outgoing multicast interface using\n- *              IPPROTO_IPV6\/IPV6_MULTICAST_IF\n- *\n- *\/\n-static void setMulticastInterface(JNIEnv *env, jobject this, int fd, int fd1,\n-                                  jint opt, jobject value)\n-{\n-    int ipv6_supported = ipv6_available();\n-\n-    if (opt == java_net_SocketOptions_IP_MULTICAST_IF) {\n-        \/*\n-         * value is an InetAddress.\n-         * On IPv4 system use IP_MULTICAST_IF socket option\n-         * On IPv6 system get the NetworkInterface that this IP\n-         * address is bound to and use the IPV6_MULTICAST_IF\n-         * option instead of IP_MULTICAST_IF\n-         *\/\n-        if (ipv6_supported && fd1 >= 0) {\n-            static jclass ni_class = NULL;\n-            if (ni_class == NULL) {\n-                jclass c = (*env)->FindClass(env, \"java\/net\/NetworkInterface\");\n-                CHECK_NULL(c);\n-                ni_class = (*env)->NewGlobalRef(env, c);\n-                CHECK_NULL(ni_class);\n-            }\n-\n-            value = Java_java_net_NetworkInterface_getByInetAddress0(env, ni_class, value);\n-            if (value == NULL) {\n-                if (!(*env)->ExceptionOccurred(env)) {\n-                    JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                         \"bad argument for IP_MULTICAST_IF\"\n-                         \": address not bound to any interface\");\n-                }\n-                return;\n-            }\n-            opt = java_net_SocketOptions_IP_MULTICAST_IF2;\n-        } else {\n-            struct in_addr in;\n-\n-            in.s_addr = htonl(getInetAddress_addr(env, value));\n-            JNU_CHECK_EXCEPTION(env);\n-            if (setsockopt(fd, IPPROTO_IP, IP_MULTICAST_IF,\n-                               (const char*)&in, sizeof(in)) < 0) {\n-                JNU_ThrowByNameWithMessageAndLastError\n-                    (env, JNU_JAVANETPKG \"SocketException\", \"Error setting socket option\");\n-            }\n-            return;\n-        }\n-    }\n-\n-    if (opt == java_net_SocketOptions_IP_MULTICAST_IF2) {\n-        \/*\n-         * value is a NetworkInterface.\n-         * On IPv6 system get the index of the interface and use the\n-         * IPV6_MULTICAST_IF socket option\n-         * On IPv4 system extract addr[0] and use the IP_MULTICAST_IF\n-         * option. For IPv6 both must be done.\n-         *\/\n-        if (ipv6_supported && fd1 >= 0) {\n-            static jfieldID ni_indexID = NULL;\n-            struct in_addr in;\n-            int index;\n-\n-            if (ni_indexID == NULL) {\n-                jclass c = (*env)->FindClass(env, \"java\/net\/NetworkInterface\");\n-                CHECK_NULL(c);\n-                ni_indexID = (*env)->GetFieldID(env, c, \"index\", \"I\");\n-                CHECK_NULL(ni_indexID);\n-            }\n-            index = (*env)->GetIntField(env, value, ni_indexID);\n-            if (isAdapterIpv6Enabled(env, index) != 0) {\n-                if (setsockopt(fd1, IPPROTO_IPV6, IPV6_MULTICAST_IF,\n-                               (const char*)&index, sizeof(index)) < 0) {\n-                    if (errno == EINVAL && index > 0) {\n-                        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                            \"IPV6_MULTICAST_IF failed (interface has IPv4 \"\n-                            \"address only?)\");\n-                    } else {\n-                        JNU_ThrowByNameWithMessageAndLastError\n-                            (env, JNU_JAVANETPKG \"SocketException\", \"Error setting socket option\");\n-                    }\n-                    return;\n-                }\n-            }\n-            if (fd >= 0) {\n-                \/* If there are any IPv4 addresses on this interface then\n-                 * repeat the operation on the IPv4 fd *\/\n-\n-                if (getInet4AddrFromIf(env, value, &in) < 0) {\n-                    return;\n-                }\n-                if (setsockopt(fd, IPPROTO_IP, IP_MULTICAST_IF,\n-                                   (const char*)&in, sizeof(in)) < 0) {\n-                    JNU_ThrowByNameWithMessageAndLastError\n-                        (env, JNU_JAVANETPKG \"SocketException\", \"Error setting socket option\");\n-                }\n-            }\n-            return;\n-        } else {\n-            struct in_addr in;\n-\n-            if (getInet4AddrFromIf (env, value, &in) < 0) {\n-                if ((*env)->ExceptionOccurred(env)) {\n-                    return;\n-                }\n-                JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                        \"no InetAddress instances of requested type\");\n-                return;\n-            }\n-\n-            if (setsockopt(fd, IPPROTO_IP, IP_MULTICAST_IF,\n-                               (const char*)&in, sizeof(in)) < 0) {\n-                JNU_ThrowByNameWithMessageAndLastError\n-                    (env, JNU_JAVANETPKG \"SocketException\", \"Error setting socket option\");\n-            }\n-            return;\n-        }\n-    }\n-}\n-\n-\/*\n- * Class:     java_net_TwoStacksPlainDatagramSocketImpl\n- * Method:    socketNativeSetOption\n- * Signature: (ILjava\/lang\/Object;)V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_TwoStacksPlainDatagramSocketImpl_socketNativeSetOption\n-  (JNIEnv *env,jobject this, jint opt,jobject value)\n-{\n-    int fd = -1, fd1 = -1;\n-    int levelv4 = 0, levelv6 = 0, optnamev4 = 0, optnamev6 = 0, optlen = 0;\n-    union {\n-        int i;\n-        char c;\n-    } optval = { 0 };\n-    int ipv6_supported = ipv6_available();\n-    fd = getFD(env, this);\n-\n-    if (ipv6_supported) {\n-        fd1 = getFD1(env, this);\n-    }\n-    if (fd < 0 && fd1 < 0) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", \"socket closed\");\n-        return;\n-    }\n-\n-    if ((opt == java_net_SocketOptions_IP_MULTICAST_IF) ||\n-        (opt == java_net_SocketOptions_IP_MULTICAST_IF2)) {\n-\n-        setMulticastInterface(env, this, fd, fd1, opt, value);\n-        return;\n-    }\n-\n-    \/*\n-     * Map the Java level socket option to the platform specific\n-     * level(s) and option name(s).\n-     *\/\n-    if (fd1 != -1) {\n-        if (NET_MapSocketOptionV6(opt, &levelv6, &optnamev6)) {\n-            JNU_ThrowByName(env, \"java\/net\/SocketException\", \"Invalid option\");\n-            return;\n-        }\n-    }\n-    if (fd != -1) {\n-        if (NET_MapSocketOption(opt, &levelv4, &optnamev4)) {\n-            JNU_ThrowByName(env, \"java\/net\/SocketException\", \"Invalid option\");\n-            return;\n-        }\n-    }\n-\n-    switch (opt) {\n-        case java_net_SocketOptions_SO_SNDBUF :\n-        case java_net_SocketOptions_SO_RCVBUF :\n-        case java_net_SocketOptions_IP_TOS :\n-            {\n-                jclass cls;\n-                jfieldID fid;\n-\n-                cls = (*env)->FindClass(env, \"java\/lang\/Integer\");\n-                CHECK_NULL(cls);\n-                fid =  (*env)->GetFieldID(env, cls, \"value\", \"I\");\n-                CHECK_NULL(fid);\n-\n-                optval.i = (*env)->GetIntField(env, value, fid);\n-                optlen = sizeof(optval.i);\n-            }\n-            break;\n-\n-        case java_net_SocketOptions_SO_REUSEADDR:\n-        case java_net_SocketOptions_SO_BROADCAST:\n-        case java_net_SocketOptions_IP_MULTICAST_LOOP:\n-            {\n-                jclass cls;\n-                jfieldID fid;\n-                jboolean on;\n-\n-                cls = (*env)->FindClass(env, \"java\/lang\/Boolean\");\n-                CHECK_NULL(cls);\n-                fid =  (*env)->GetFieldID(env, cls, \"value\", \"Z\");\n-                CHECK_NULL(fid);\n-\n-                on = (*env)->GetBooleanField(env, value, fid);\n-                optval.i = (on ? 1 : 0);\n-                \/*\n-                 * setLoopbackMode (true) disables IP_MULTICAST_LOOP rather\n-                 * than enabling it.\n-                 *\/\n-                if (opt == java_net_SocketOptions_IP_MULTICAST_LOOP) {\n-                    optval.i = !optval.i;\n-                }\n-                optlen = sizeof(optval.i);\n-            }\n-            break;\n-\n-        default :\n-            JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                \"Socket option not supported by PlainDatagramSocketImp\");\n-            return;\n-\n-    }\n-\n-    if (fd1 != -1) {\n-        if (NET_SetSockOpt(fd1, levelv6, optnamev6, (void *)&optval, optlen) < 0) {\n-            NET_ThrowCurrent(env, \"setsockopt IPv6\");\n-            return;\n-        }\n-    }\n-    if (fd != -1) {\n-        if (NET_SetSockOpt(fd, levelv4, optnamev4, (void *)&optval, optlen) < 0) {\n-            NET_ThrowCurrent(env, \"setsockopt\");\n-            return;\n-        }\n-    }\n-}\n-\n-\/*\n- *\n- * called by getMulticastInterface to retrieve a NetworkInterface\n- * configured for IPv4.\n- * The ipv4Mode parameter, is a closet boolean, which allows for a NULL return,\n- * or forces the creation of a NetworkInterface object with null data.\n- * It relates to its calling context in getMulticastInterface.\n- * ipv4Mode == 1, the context is IPV4 processing only.\n- * ipv4Mode == 0, the context is IPV6 processing\n- *\n- *\/\n-static jobject getIPv4NetworkInterface (JNIEnv *env, jobject this, int fd, jint opt, int ipv4Mode) {\n-        static jclass inet4_class;\n-        static jmethodID inet4_ctrID;\n-\n-        static jclass ni_class; static jmethodID ni_ctrID;\n-        static jfieldID ni_indexID;\n-        static jfieldID ni_addrsID;\n-\n-        jobject addr;\n-        jobject ni;\n-\n-        struct in_addr in;\n-        struct in_addr *inP = &in;\n-        int len = sizeof(struct in_addr);\n-        if (getsockopt(fd, IPPROTO_IP, IP_MULTICAST_IF,\n-                           (char *)inP, &len) < 0) {\n-            JNU_ThrowByNameWithMessageAndLastError\n-                (env, JNU_JAVANETPKG \"SocketException\", \"Error getting socket option\");\n-            return NULL;\n-        }\n-\n-        \/*\n-         * Construct and populate an Inet4Address\n-         *\/\n-        if (inet4_class == NULL) {\n-            jclass c = (*env)->FindClass(env, \"java\/net\/Inet4Address\");\n-            CHECK_NULL_RETURN(c, NULL);\n-            inet4_ctrID = (*env)->GetMethodID(env, c, \"<init>\", \"()V\");\n-            CHECK_NULL_RETURN(inet4_ctrID, NULL);\n-            inet4_class = (*env)->NewGlobalRef(env, c);\n-            CHECK_NULL_RETURN(inet4_class, NULL);\n-        }\n-        addr = (*env)->NewObject(env, inet4_class, inet4_ctrID, 0);\n-        CHECK_NULL_RETURN(addr, NULL);\n-\n-        setInetAddress_addr(env, addr, ntohl(in.s_addr));\n-        JNU_CHECK_EXCEPTION_RETURN(env, NULL);\n-        \/*\n-         * For IP_MULTICAST_IF return InetAddress\n-         *\/\n-        if (opt == java_net_SocketOptions_IP_MULTICAST_IF) {\n-            return addr;\n-        }\n-\n-        \/*\n-         * For IP_MULTICAST_IF2 we get the NetworkInterface for\n-         * this address and return it\n-         *\/\n-        if (ni_class == NULL) {\n-            jclass c = (*env)->FindClass(env, \"java\/net\/NetworkInterface\");\n-            CHECK_NULL_RETURN(c, NULL);\n-            ni_ctrID = (*env)->GetMethodID(env, c, \"<init>\", \"()V\");\n-            CHECK_NULL_RETURN(ni_ctrID, NULL);\n-            ni_indexID = (*env)->GetFieldID(env, c, \"index\", \"I\");\n-            CHECK_NULL_RETURN(ni_indexID, NULL);\n-            ni_addrsID = (*env)->GetFieldID(env, c, \"addrs\",\n-                                            \"[Ljava\/net\/InetAddress;\");\n-            CHECK_NULL_RETURN(ni_addrsID, NULL);\n-            ni_class = (*env)->NewGlobalRef(env, c);\n-            CHECK_NULL_RETURN(ni_class, NULL);\n-        }\n-        ni = Java_java_net_NetworkInterface_getByInetAddress0(env, ni_class, addr);\n-        if (ni) {\n-            return ni;\n-        }\n-        return NULL;\n-}\n-\n-\/*\n- * Return the multicast interface:\n- *\n- * SocketOptions.IP_MULTICAST_IF\n- *      IPv4:   Query IPPROTO_IP\/IP_MULTICAST_IF\n- *              Create InetAddress\n- *              IP_MULTICAST_IF returns struct ip_mreqn on 2.2\n- *              kernel but struct in_addr on 2.4 kernel\n- *      IPv6:   Query IPPROTO_IPV6 \/ IPV6_MULTICAST_IF or\n- *              obtain from impl is Linux 2.2 kernel\n- *              If index == 0 return InetAddress representing\n- *              anyLocalAddress.\n- *              If index > 0 query NetworkInterface by index\n- *              and returns addrs[0]\n- *\n- * SocketOptions.IP_MULTICAST_IF2\n- *      IPv4:   Query IPPROTO_IP\/IP_MULTICAST_IF\n- *              Query NetworkInterface by IP address and\n- *              return the NetworkInterface that the address\n- *              is bound too.\n- *      IPv6:   Query IPPROTO_IPV6 \/ IPV6_MULTICAST_IF\n- *              (except Linux .2 kernel)\n- *              Query NetworkInterface by index and\n- *              return NetworkInterface.\n- *\/\n-jobject getMulticastInterface(JNIEnv *env, jobject this, int fd, int fd1, jint opt) {\n-    jboolean isIPV4 = !ipv6_available() || fd1 == -1;\n-\n-    \/*\n-     * IPv4 implementation\n-     *\/\n-    if (isIPV4) {\n-        jobject netObject = NULL; \/\/ return is either an addr or a netif\n-        netObject = getIPv4NetworkInterface(env, this, fd, opt, 1);\n-        return netObject;\n-    }\n-\n-    \/*\n-     * IPv6 implementation\n-     *\/\n-    if ((opt == java_net_SocketOptions_IP_MULTICAST_IF) ||\n-        (opt == java_net_SocketOptions_IP_MULTICAST_IF2)) {\n-\n-        static jclass ni_class;\n-        static jmethodID ni_ctrID;\n-        static jfieldID ni_indexID;\n-        static jfieldID ni_addrsID;\n-        static jclass ia_class;\n-        static jmethodID ia_anyLocalAddressID;\n-\n-        int index;\n-        int len = sizeof(index);\n-\n-        jobjectArray addrArray;\n-        jobject addr;\n-        jobject ni;\n-\n-        {\n-            if (getsockopt(fd1, IPPROTO_IPV6, IPV6_MULTICAST_IF,\n-                               (char*)&index, &len) < 0) {\n-                JNU_ThrowByNameWithMessageAndLastError\n-                    (env, JNU_JAVANETPKG \"SocketException\", \"Error getting socket option\");\n-                return NULL;\n-            }\n-        }\n-\n-        if (ni_class == NULL) {\n-            jclass c = (*env)->FindClass(env, \"java\/net\/NetworkInterface\");\n-            CHECK_NULL_RETURN(c, NULL);\n-            ni_ctrID = (*env)->GetMethodID(env, c, \"<init>\", \"()V\");\n-            CHECK_NULL_RETURN(ni_ctrID, NULL);\n-            ni_indexID = (*env)->GetFieldID(env, c, \"index\", \"I\");\n-            CHECK_NULL_RETURN(ni_indexID, NULL);\n-            ni_addrsID = (*env)->GetFieldID(env, c, \"addrs\",\n-                                            \"[Ljava\/net\/InetAddress;\");\n-            CHECK_NULL_RETURN(ni_addrsID, NULL);\n-\n-            ia_class = (*env)->FindClass(env, \"java\/net\/InetAddress\");\n-            CHECK_NULL_RETURN(ia_class, NULL);\n-            ia_class = (*env)->NewGlobalRef(env, ia_class);\n-            CHECK_NULL_RETURN(ia_class, NULL);\n-            ia_anyLocalAddressID = (*env)->GetStaticMethodID(env,\n-                                                             ia_class,\n-                                                             \"anyLocalAddress\",\n-                                                             \"()Ljava\/net\/InetAddress;\");\n-            CHECK_NULL_RETURN(ia_anyLocalAddressID, NULL);\n-            ni_class = (*env)->NewGlobalRef(env, c);\n-            CHECK_NULL_RETURN(ni_class, NULL);\n-        }\n-\n-        \/*\n-         * If multicast to a specific interface then return the\n-         * interface (for IF2) or the any address on that interface\n-         * (for IF).\n-         *\/\n-        if (index > 0) {\n-            ni = Java_java_net_NetworkInterface_getByIndex0(env, ni_class,\n-                                                                   index);\n-            if (ni == NULL) {\n-                char errmsg[255];\n-                sprintf(errmsg,\n-                        \"IPV6_MULTICAST_IF returned index to unrecognized interface: %d\",\n-                        index);\n-                JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", errmsg);\n-                return NULL;\n-            }\n-\n-            \/*\n-             * For IP_MULTICAST_IF2 return the NetworkInterface\n-             *\/\n-            if (opt == java_net_SocketOptions_IP_MULTICAST_IF2) {\n-                return ni;\n-            }\n-\n-            \/*\n-             * For IP_MULTICAST_IF return addrs[0]\n-             *\/\n-            addrArray = (*env)->GetObjectField(env, ni, ni_addrsID);\n-            if ((*env)->GetArrayLength(env, addrArray) < 1) {\n-                JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                    \"IPV6_MULTICAST_IF returned interface without IP bindings\");\n-                return NULL;\n-            }\n-\n-            addr = (*env)->GetObjectArrayElement(env, addrArray, 0);\n-            return addr;\n-        } else if (index == 0 && fd >= 0) {\n-            \/\/ falling back to treat interface as configured for IPv4\n-            jobject netObject = NULL;\n-            netObject = getIPv4NetworkInterface(env, this, fd, opt, 0);\n-            if (netObject != NULL) {\n-                return netObject;\n-            }\n-        }\n-    }\n-    return NULL;\n-}\n-\n-\n-\/*\n- * Returns relevant info as a jint.\n- *\n- * Class:     java_net_TwoStacksPlainDatagramSocketImpl\n- * Method:    socketGetOption\n- * Signature: (I)Ljava\/lang\/Object;\n- *\/\n-JNIEXPORT jobject JNICALL\n-Java_java_net_TwoStacksPlainDatagramSocketImpl_socketGetOption\n-  (JNIEnv *env, jobject this, jint opt)\n-{\n-    int fd = -1, fd1 = -1;\n-    int level, optname, optlen;\n-    union {\n-        int i;\n-    } optval = {0};\n-    int ipv6_supported = ipv6_available();\n-\n-    fd = getFD(env, this);\n-    if (ipv6_supported) {\n-        fd1 = getFD1(env, this);\n-    }\n-\n-    if (fd < 0 && fd1 < 0) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                        \"Socket closed\");\n-        return NULL;\n-    }\n-\n-    \/*\n-     * Handle IP_MULTICAST_IF separately\n-     *\/\n-    if (opt == java_net_SocketOptions_IP_MULTICAST_IF ||\n-        opt == java_net_SocketOptions_IP_MULTICAST_IF2) {\n-        return getMulticastInterface(env, this, fd, fd1, opt);\n-    }\n-\n-    \/*\n-     * Map the Java level socket option to the platform specific\n-     * level and option name.\n-     *\/\n-    if (NET_MapSocketOption(opt, &level, &optname)) {\n-        JNU_ThrowByName(env, \"java\/net\/SocketException\", \"Invalid option\");\n-        return NULL;\n-    }\n-\n-    if (fd == -1) {\n-        if (NET_MapSocketOptionV6(opt, &level, &optname)) {\n-            JNU_ThrowByName(env, \"java\/net\/SocketException\", \"Invalid option\");\n-            return NULL;\n-        }\n-        fd = fd1; \/* must be IPv6 only *\/\n-    }\n-\n-    optlen = sizeof(optval.i);\n-    if (NET_GetSockOpt(fd, level, optname, (void *)&optval, &optlen) < 0) {\n-        char tmpbuf[255];\n-        int size = 0;\n-        char errmsg[255 + 31];\n-        getErrorString(errno, tmpbuf, sizeof(tmpbuf));\n-        sprintf(errmsg, \"error getting socket option: %s\", tmpbuf);\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", errmsg);\n-        return NULL;\n-    }\n-\n-    switch (opt) {\n-        case java_net_SocketOptions_SO_BROADCAST:\n-        case java_net_SocketOptions_SO_REUSEADDR:\n-            return createBoolean(env, optval.i);\n-\n-        case java_net_SocketOptions_IP_MULTICAST_LOOP:\n-            \/* getLoopbackMode() returns true if IP_MULTICAST_LOOP is disabled *\/\n-            return createBoolean(env, !optval.i);\n-\n-        case java_net_SocketOptions_SO_SNDBUF:\n-        case java_net_SocketOptions_SO_RCVBUF:\n-        case java_net_SocketOptions_IP_TOS:\n-            return createInteger(env, optval.i);\n-\n-        default :\n-            JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                \"Socket option not supported by TwoStacksPlainDatagramSocketImpl\");\n-            return NULL;\n-\n-    }\n-}\n-\n-\/*\n- * Returns local address of the socket.\n- *\n- * Class:     java_net_TwoStacksPlainDatagramSocketImpl\n- * Method:    socketLocalAddress\n- * Signature: (I)Ljava\/lang\/Object;\n- *\/\n-JNIEXPORT jobject JNICALL\n-Java_java_net_TwoStacksPlainDatagramSocketImpl_socketLocalAddress\n-  (JNIEnv *env, jobject this, jint family)\n-{\n-    int fd = -1, fd1 = -1;\n-    SOCKETADDRESS sa;\n-    int len = 0;\n-    int port;\n-    jobject iaObj;\n-    int ipv6_supported = ipv6_available();\n-\n-    fd = getFD(env, this);\n-    if (ipv6_supported) {\n-        fd1 = getFD1(env, this);\n-    }\n-\n-    if (fd < 0 && fd1 < 0) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                        \"Socket closed\");\n-        return NULL;\n-    }\n-\n-    \/* find out local IP address *\/\n-\n-    len = sizeof(struct sockaddr_in);\n-\n-    \/* family==-1 when socket is not connected *\/\n-    if ((family == java_net_InetAddress_IPv6) || (family == -1 && fd == -1)) {\n-        fd = fd1; \/* must be IPv6 only *\/\n-        len = sizeof(struct sockaddr_in6);\n-    }\n-\n-    if (fd == -1) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                        \"Socket closed\");\n-        return NULL;\n-    }\n-\n-    if (getsockname(fd, &sa.sa, &len) == -1) {\n-        JNU_ThrowByNameWithMessageAndLastError\n-            (env, JNU_JAVANETPKG \"SocketException\", \"Error getting socket name\");\n-        return NULL;\n-    }\n-    iaObj = NET_SockaddrToInetAddress(env, &sa, &port);\n-\n-    return iaObj;\n-}\n-\n-\/*\n- * Class:     java_net_TwoStacksPlainDatagramSocketImpl\n- * Method:    setTimeToLive\n- * Signature: (I)V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_TwoStacksPlainDatagramSocketImpl_setTimeToLive(JNIEnv *env, jobject this,\n-                                                    jint ttl) {\n-\n-    jobject fdObj = (*env)->GetObjectField(env, this, pdsi_fdID);\n-    jobject fd1Obj = (*env)->GetObjectField(env, this, pdsi_fd1ID);\n-    int fd = -1, fd1 = -1;\n-    int ittl = (int)ttl;\n-\n-    if (IS_NULL(fdObj) && IS_NULL(fd1Obj)) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                        \"Socket closed\");\n-        return;\n-    } else {\n-      if (!IS_NULL(fdObj)) {\n-        fd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);\n-      }\n-      if (!IS_NULL(fd1Obj)) {\n-        fd1 = (*env)->GetIntField(env, fd1Obj, IO_fd_fdID);\n-      }\n-    }\n-\n-    \/* setsockopt to be correct ttl *\/\n-    if (fd >= 0) {\n-      if (NET_SetSockOpt(fd, IPPROTO_IP, IP_MULTICAST_TTL, (char*)&ittl,\n-                         sizeof (ittl)) < 0) {\n-        NET_ThrowCurrent(env, \"set IP_MULTICAST_TTL failed\");\n-        return;\n-      }\n-    }\n-\n-    if (fd1 >= 0) {\n-      if (NET_SetSockOpt(fd1, IPPROTO_IPV6, IPV6_MULTICAST_HOPS, (char *)&ittl,\n-                         sizeof(ittl)) <0) {\n-        NET_ThrowCurrent(env, \"set IPV6_MULTICAST_HOPS failed\");\n-      }\n-    }\n-}\n-\n-\/*\n- * Class:     java_net_TwoStacksPlainDatagramSocketImpl\n- * Method:    setTTL\n- * Signature: (B)V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_TwoStacksPlainDatagramSocketImpl_setTTL(JNIEnv *env, jobject this,\n-                                             jbyte ttl) {\n-    Java_java_net_TwoStacksPlainDatagramSocketImpl_setTimeToLive(env, this,\n-                                                        (jint)ttl & 0xFF);\n-}\n-\n-\/*\n- * Class:     java_net_TwoStacksPlainDatagramSocketImpl\n- * Method:    getTimeToLive\n- * Signature: ()I\n- *\/\n-JNIEXPORT jint JNICALL\n-Java_java_net_TwoStacksPlainDatagramSocketImpl_getTimeToLive(JNIEnv *env, jobject this) {\n-    jobject fdObj = (*env)->GetObjectField(env, this, pdsi_fdID);\n-    jobject fd1Obj = (*env)->GetObjectField(env, this, pdsi_fd1ID);\n-    int fd = -1, fd1 = -1;\n-    int ttl = 0;\n-    int len = sizeof(ttl);\n-\n-    if (IS_NULL(fdObj) && IS_NULL(fd1Obj)) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                        \"Socket closed\");\n-        return -1;\n-    } else {\n-      if (!IS_NULL(fdObj)) {\n-        fd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);\n-      }\n-      if (!IS_NULL(fd1Obj)) {\n-        fd1 = (*env)->GetIntField(env, fd1Obj, IO_fd_fdID);\n-      }\n-    }\n-\n-    \/* getsockopt of ttl *\/\n-    if (fd >= 0) {\n-      if (NET_GetSockOpt(fd, IPPROTO_IP, IP_MULTICAST_TTL, (char*)&ttl, &len) < 0) {\n-        NET_ThrowCurrent(env, \"get IP_MULTICAST_TTL failed\");\n-        return -1;\n-      }\n-      return (jint)ttl;\n-    }\n-    if (fd1 >= 0) {\n-      if (NET_GetSockOpt(fd1, IPPROTO_IPV6, IPV6_MULTICAST_HOPS, (char*)&ttl, &len) < 0) {\n-        NET_ThrowCurrent(env, \"get IP_MULTICAST_TTL failed\");\n-        return -1;\n-      }\n-      return (jint)ttl;\n-    }\n-    return -1;\n-}\n-\n-\/*\n- * Class:     java_net_TwoStacksPlainDatagramSocketImpl\n- * Method:    getTTL\n- * Signature: ()B\n- *\/\n-JNIEXPORT jbyte JNICALL\n-Java_java_net_TwoStacksPlainDatagramSocketImpl_getTTL(JNIEnv *env, jobject this) {\n-    int result = Java_java_net_TwoStacksPlainDatagramSocketImpl_getTimeToLive(env, this);\n-\n-    return (jbyte)result;\n-}\n-\n-\/* join\/leave the named group on the named interface, or if no interface specified\n- * then the interface set with setInterfac(), or the default interface otherwise *\/\n-\n-static void mcast_join_leave(JNIEnv *env, jobject this,\n-                             jobject iaObj, jobject niObj,\n-                             jboolean join)\n-{\n-    jobject fdObj = (*env)->GetObjectField(env, this, pdsi_fdID);\n-    jobject fd1Obj = (*env)->GetObjectField(env, this, pdsi_fd1ID);\n-    jint fd = -1, fd1 = -1;\n-\n-    SOCKETADDRESS name;\n-    struct ip_mreq mname;\n-    struct ipv6_mreq mname6;\n-\n-    struct in_addr in;\n-    DWORD ifindex = 0;\n-\n-    int len, family;\n-    int ipv6_supported = ipv6_available();\n-    int cmd;\n-\n-    memset((char *)&in, 0, sizeof(in));\n-    memset((char *)&name, 0, sizeof(name));\n-\n-    if (IS_NULL(fdObj) && IS_NULL(fd1Obj)) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                        \"Socket closed\");\n-        return;\n-    }\n-    if (!IS_NULL(fdObj)) {\n-        fd = (*env)->GetIntField(env, fdObj, IO_fd_fdID);\n-    }\n-    if (ipv6_supported && !IS_NULL(fd1Obj)) {\n-        fd1 = (*env)->GetIntField(env, fd1Obj, IO_fd_fdID);\n-    }\n-\n-    if (IS_NULL(iaObj)) {\n-        JNU_ThrowNullPointerException(env, \"address\");\n-        return;\n-    }\n-\n-    if (NET_InetAddressToSockaddr(env, iaObj, 0, &name, &len, JNI_FALSE) != 0) {\n-      return;\n-    }\n-\n-    \/* Set the multicast group address in the ip_mreq field\n-     * eventually this check should be done by the security manager\n-     *\/\n-    family = name.sa.sa_family;\n-\n-    if (family == AF_INET) {\n-        int address = name.sa4.sin_addr.s_addr;\n-        if (!IN_MULTICAST(ntohl(address))) {\n-            JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", \"not in multicast\");\n-            return;\n-        }\n-        mname.imr_multiaddr.s_addr = address;\n-        if (fd < 0) {\n-          JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", \"Can't join an IPv4 group on an IPv6 only socket\");\n-          return;\n-        }\n-        if (IS_NULL(niObj)) {\n-            len = sizeof(in);\n-            if (NET_GetSockOpt(fd, IPPROTO_IP, IP_MULTICAST_IF,\n-                           (char *)&in, &len) < 0) {\n-                NET_ThrowCurrent(env, \"get IP_MULTICAST_IF failed\");\n-                return;\n-            }\n-            mname.imr_interface.s_addr = in.s_addr;\n-        } else {\n-            if (getInet4AddrFromIf (env, niObj, &mname.imr_interface) != 0) {\n-                NET_ThrowCurrent(env, \"no Inet4Address associated with interface\");\n-                return;\n-            }\n-        }\n-\n-        cmd = join ? IP_ADD_MEMBERSHIP: IP_DROP_MEMBERSHIP;\n-\n-        \/* Join the multicast group *\/\n-        if (NET_SetSockOpt(fd, IPPROTO_IP, cmd, (char *) &mname, sizeof (mname)) < 0) {\n-            if (WSAGetLastError() == WSAENOBUFS) {\n-                JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                    \"IP_ADD_MEMBERSHIP failed (out of hardware filters?)\");\n-            } else {\n-                JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\"error setting options\");\n-            }\n-        }\n-    } else \/* AF_INET6 *\/ {\n-        if (ipv6_supported) {\n-            struct in6_addr *address;\n-            address = &name.sa6.sin6_addr;\n-            if (!IN6_IS_ADDR_MULTICAST(address)) {\n-                JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", \"not in6 multicast\");\n-                return;\n-            }\n-            mname6.ipv6mr_multiaddr = *address;\n-        } else {\n-            JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", \"IPv6 not supported\");\n-            return;\n-        }\n-        if (fd1 < 0) {\n-          JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\", \"Can't join an IPv6 group on a IPv4 socket\");\n-          return;\n-        }\n-        if (IS_NULL(niObj)) {\n-            len = sizeof (ifindex);\n-            if (NET_GetSockOpt(fd1, IPPROTO_IPV6, IPV6_MULTICAST_IF, &ifindex, &len) < 0) {\n-                NET_ThrowCurrent(env, \"get IPV6_MULTICAST_IF failed\");\n-                return;\n-            }\n-        } else {\n-            ifindex = getIndexFromIf (env, niObj);\n-            if (ifindex == -1) {\n-                if ((*env)->ExceptionOccurred(env)) {\n-                    return;\n-                }\n-                NET_ThrowCurrent(env, \"get ifindex failed\");\n-                return;\n-            }\n-        }\n-        mname6.ipv6mr_interface = ifindex;\n-        cmd = join ? IPV6_ADD_MEMBERSHIP: IPV6_DROP_MEMBERSHIP;\n-\n-        \/* Join the multicast group *\/\n-        if (NET_SetSockOpt(fd1, IPPROTO_IPV6, cmd, (char *) &mname6, sizeof (mname6)) < 0) {\n-            if (WSAGetLastError() == WSAENOBUFS) {\n-                JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                    \"IP_ADD_MEMBERSHIP failed (out of hardware filters?)\");\n-            } else {\n-                JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\"error setting options\");\n-            }\n-        }\n-    }\n-\n-    return;\n-}\n-\n-\/*\n- * Class:     java_net_TwoStacksPlainDatagramSocketImpl\n- * Method:    join\n- * Signature: (Ljava\/net\/InetAddress;)V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_TwoStacksPlainDatagramSocketImpl_join(JNIEnv *env, jobject this,\n-                                           jobject iaObj, jobject niObj)\n-{\n-    mcast_join_leave (env, this, iaObj, niObj, JNI_TRUE);\n-}\n-\n-\/*\n- * Class:     java_net_TwoStacksPlainDatagramSocketImpl\n- * Method:    leave\n- * Signature: (Ljava\/net\/InetAddress;)V\n- *\/\n-JNIEXPORT void JNICALL\n-Java_java_net_TwoStacksPlainDatagramSocketImpl_leave(JNIEnv *env, jobject this,\n-                                            jobject iaObj, jobject niObj)\n-{\n-    mcast_join_leave (env, this, iaObj, niObj, JNI_FALSE);\n-}\n-\n-\/*\n- * Class:     java_net_TwoStacksPlainDatagramSocketImpl\n- * Method:    dataAvailable\n- * Signature: ()I\n- *\/\n-JNIEXPORT jint JNICALL Java_java_net_TwoStacksPlainDatagramSocketImpl_dataAvailable\n-(JNIEnv *env, jobject this) {\n-    SOCKET fd;\n-    SOCKET fd1;\n-    int  rv = -1, rv1 = -1;\n-    jobject fdObj = (*env)->GetObjectField(env, this, pdsi_fdID);\n-    jobject fd1Obj;\n-\n-    if (!IS_NULL(fdObj)) {\n-        int retval = 0;\n-        fd = (SOCKET)(*env)->GetIntField(env, fdObj, IO_fd_fdID);\n-        rv = ioctlsocket(fd, FIONREAD, &retval);\n-        if (retval > 0) {\n-            return retval;\n-        }\n-    }\n-\n-    fd1Obj = (*env)->GetObjectField(env, this, pdsi_fd1ID);\n-    if (!IS_NULL(fd1Obj)) {\n-        int retval = 0;\n-        fd1 = (SOCKET)(*env)->GetIntField(env, fd1Obj, IO_fd_fdID);\n-        rv1 = ioctlsocket(fd1, FIONREAD, &retval);\n-        if (retval > 0) {\n-            return retval;\n-        }\n-    }\n-\n-    if (rv < 0 && rv1 < 0) {\n-        JNU_ThrowByName(env, JNU_JAVANETPKG \"SocketException\",\n-                        \"Socket closed\");\n-        return -1;\n-    }\n-\n-    return 0;\n-}\n","filename":"src\/java.base\/windows\/native\/libnet\/TwoStacksPlainDatagramSocketImpl.c","additions":0,"deletions":2349,"binary":false,"changes":2349,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -269,3 +269,3 @@\n- * Below Adapted from PlainSocketImpl.c, win32 version 1.18. Changed exception\n- * throws to returns of SYS_ERR; we should improve the error codes\n- * eventually. Changed java objects to values the debugger back end can\n+ * Below Adapted from PlainSocketImpl.c (removed in JDK18), win32 version 1.18.\n+ * Changed exception throws to returns of SYS_ERR; we should improve the error\n+ * codes eventually. Changed java objects to values the debugger back end can\n","filename":"src\/jdk.jdwp.agent\/windows\/native\/libdt_socket\/socket_md.c","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n- * @run main\/othervm -Djdk.net.usePlainSocketImpl Test1\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/Test1.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021 Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n- * @run main\/othervm -Djdk.net.usePlainDatagramSocketImpl AddressNotSet\n","filename":"test\/jdk\/java\/net\/DatagramSocket\/AddressNotSet.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -36,2 +36,0 @@\n- * @run main\/othervm -Djdk.usePlainDatagramSocketImpl=true DatagramSocketExample\n- * @run main\/othervm -Djdk.usePlainDatagramSocketImpl=true -Djava.net.preferIPv4Stack=true DatagramSocketExample\n","filename":"test\/jdk\/java\/net\/DatagramSocket\/DatagramSocketExample.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,2 +32,0 @@\n- * @run main\/othervm -Djdk.usePlainDatagramSocketImpl=true DatagramSocketMulticasting\n- * @run main\/othervm -Djdk.usePlainDatagramSocketImpl=true -Djava.net.preferIPv4Stack=true DatagramSocketMulticasting\n","filename":"test\/jdk\/java\/net\/DatagramSocket\/DatagramSocketMulticasting.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n- * @run testng\/othervm -Djdk.net.usePlainDatagramSocketImpl DatagramTimeout\n","filename":"test\/jdk\/java\/net\/DatagramSocket\/DatagramTimeout.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021 Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,0 @@\n- * @run main\/othervm -Djdk.net.usePlainDatagramSocketImpl InterruptibleDatagramSocket\n","filename":"test\/jdk\/java\/net\/DatagramSocket\/InterruptibleDatagramSocket.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-\/* Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+\/* Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,0 @@\n- * @run main\/othervm -Djdk.net.usePlainDatagramSocketImpl ReuseAddressTest\n","filename":"test\/jdk\/java\/net\/DatagramSocket\/ReuseAddressTest.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021 Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,0 @@\n- * @run testng\/othervm -Djdk.net.usePlainDatagramSocketImpl SendCheck\n","filename":"test\/jdk\/java\/net\/DatagramSocket\/SendCheck.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n- * @run main\/othervm -Djdk.net.usePlainDatagramSocketImpl=false SendDatagramToBadAddress\n+ * @run main\/othervm SendDatagramToBadAddress\n","filename":"test\/jdk\/java\/net\/DatagramSocket\/SendDatagramToBadAddress.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021 Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,0 @@\n- * @run testng\/othervm -Djava.security.manager=allow -Djdk.net.usePlainDatagramSocketImpl SendPortZero\n","filename":"test\/jdk\/java\/net\/DatagramSocket\/SendPortZero.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021 Oracle and\/or its affiliates. All rights reserved.\n@@ -39,3 +39,0 @@\n- * @run testng\/othervm -Djdk.net.usePlainDatagramSocketImpl SendReceiveMaxSize\n- * @run testng\/othervm -Djdk.net.usePlainDatagramSocketImpl -Djava.net.preferIPv4Stack=true SendReceiveMaxSize\n- * @run testng\/othervm -Djdk.net.usePlainDatagramSocketImpl -Djava.net.preferIPv6Addresses=true SendReceiveMaxSize\n","filename":"test\/jdk\/java\/net\/DatagramSocket\/SendReceiveMaxSize.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/net\/DatagramSocket\/SetDatagramSocketImplFactory\/ADatagramSocket.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2007, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,3 @@\n+import java.io.IOException;\n+import java.nio.channels.DatagramChannel;\n+\n@@ -27,6 +30,49 @@\n-  public DatagramSocketImpl createDatagramSocketImpl() {\n-    try {\n-        return DefaultDatagramSocketImplFactory.createDatagramSocketImpl(false);\n-    } catch (SocketException se) {\n-        assert false;\n-    }\n+    static class MyDatagramSocketImpl extends DatagramSocketImpl {\n+        DatagramSocket ds;\n+\n+        @Override\n+        protected void create() throws SocketException {\n+            try {\n+                ds = DatagramChannel.open().socket();\n+            } catch (IOException ex) { throw new SocketException(ex.getMessage());}\n+        }\n+\n+        @Override\n+        protected void bind(int lport, InetAddress laddr) throws SocketException {\n+            ds.bind(new InetSocketAddress(laddr, lport));\n+            localPort = ds.getLocalPort();\n+        }\n+\n+        @Override\n+        protected void send(DatagramPacket p) throws IOException {\n+            ds.send(p);\n+        }\n+\n+        @Override\n+        protected int peek(InetAddress i) throws IOException {\n+            return 0;\n+        }\n+\n+        @Override\n+        protected int peekData(DatagramPacket p) throws IOException {\n+            return 0;\n+        }\n+\n+        @Override\n+        protected void receive(DatagramPacket p) throws IOException {\n+            ds.receive(p);\n+        }\n+\n+        @Override\n+        protected void setTTL(byte ttl) throws IOException {\n+        }\n+\n+        @Override\n+        protected byte getTTL() throws IOException {\n+            return 0;\n+        }\n+\n+        @Override\n+        protected void setTimeToLive(int ttl) throws IOException {\n+\n+        }\n@@ -34,1 +80,90 @@\n-    return null;\n+        @Override\n+        protected int getTimeToLive() throws IOException {\n+            return 0;\n+        }\n+\n+        @Override\n+        protected void join(InetAddress inetaddr) throws IOException {\n+\n+        }\n+\n+        @Override\n+        protected void leave(InetAddress inetaddr) throws IOException {\n+\n+        }\n+\n+        @Override\n+        protected void joinGroup(SocketAddress mcastaddr, NetworkInterface netIf) throws IOException {\n+\n+        }\n+\n+        @Override\n+        protected void leaveGroup(SocketAddress mcastaddr, NetworkInterface netIf) throws IOException {\n+\n+        }\n+\n+        @Override\n+        protected void close() {\n+            ds.close();\n+        }\n+\n+        @Override\n+        public void setOption(int optID, Object value) throws SocketException {\n+            try {\n+                if (optID == SocketOptions.SO_SNDBUF) {\n+                    if (((Integer) value).intValue() < 0)\n+                        throw new IllegalArgumentException(\"Invalid send buffer size:\" + value);\n+                    ds.setOption(StandardSocketOptions.SO_SNDBUF, (Integer) value);\n+                } else if (optID == SocketOptions.SO_RCVBUF) {\n+                    if (((Integer) value).intValue() < 0)\n+                        throw new IllegalArgumentException(\"Invalid recv buffer size:\" + value);\n+                    ds.setOption(StandardSocketOptions.SO_RCVBUF, (Integer) value);\n+                } else if (optID == SocketOptions.SO_REUSEADDR) {\n+                    ds.setOption(StandardSocketOptions.SO_REUSEADDR, (Boolean) value);\n+                } else if (optID == SocketOptions.SO_REUSEPORT) {\n+                    ds.setOption(StandardSocketOptions.SO_REUSEPORT, (Boolean) value);\n+                } else if (optID == SocketOptions.SO_BROADCAST) {\n+                     ds.setOption(StandardSocketOptions.SO_BROADCAST, (Boolean) value);\n+                } else if (optID == SocketOptions.IP_TOS) {\n+                    int i = ((Integer) value).intValue();\n+                    if (i < 0 || i > 255)\n+                        throw new IllegalArgumentException(\"Invalid IP_TOS value: \" + value);\n+                    ds.setOption(StandardSocketOptions.IP_TOS, (Integer) value);\n+                } else if (optID == SocketOptions.IP_MULTICAST_LOOP) {\n+                    boolean enable = (boolean) value;\n+                    \/\/ Legacy ds.setOption expects true to mean 'disabled'\n+                    ds.setOption(StandardSocketOptions.IP_MULTICAST_LOOP, !enable);\n+                } else {\n+                    throw new AssertionError(\"unknown option :\" + optID);\n+                }\n+            } catch (IOException ex) { throw new SocketException(ex.getMessage()); }\n+        }\n+\n+        @Override\n+        public Object getOption(int optID) throws SocketException {\n+            try {\n+                if (optID == SocketOptions.SO_SNDBUF) {\n+                    return ds.getOption(StandardSocketOptions.SO_SNDBUF);\n+                } else if (optID == SocketOptions.SO_RCVBUF) {\n+                    return ds.getOption(StandardSocketOptions.SO_RCVBUF);\n+                } else if (optID == SocketOptions.SO_REUSEADDR) {\n+                    return ds.getOption(StandardSocketOptions.SO_REUSEADDR);\n+                } else if (optID == SocketOptions.SO_REUSEPORT) {\n+                    return ds.getOption(StandardSocketOptions.SO_REUSEPORT);\n+                } else if (optID == SocketOptions.SO_BROADCAST) {\n+                    return ds.getOption(StandardSocketOptions.SO_BROADCAST);\n+                } else if (optID == SocketOptions.IP_TOS) {\n+                    return ds.getOption(StandardSocketOptions.IP_TOS);\n+                } else if (optID == SocketOptions.IP_MULTICAST_LOOP) {\n+                    boolean disabled = (boolean) ds.getOption(StandardSocketOptions.IP_MULTICAST_LOOP);\n+                    \/\/ Legacy getOption returns true when disabled\n+                    return Boolean.valueOf(!disabled);\n+                } else {\n+                    throw new AssertionError(\"unknown option: \" + optID);\n+                }\n+            } catch (IOException ex) { throw new SocketException(ex.getMessage()); }\n+        }\n+    }\n+    @Override\n+    public MyDatagramSocketImpl createDatagramSocketImpl() {\n+        return new MyDatagramSocketImpl();\n","filename":"test\/jdk\/java\/net\/DatagramSocket\/SetDatagramSocketImplFactory\/java.base\/java\/net\/MyDatagramSocketImplFactory.java","additions":143,"deletions":8,"binary":false,"changes":151,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n- * @run testng\/othervm -Djdk.net.usePlainDatagramSocketImpl SetGetReceiveBufferSize\n","filename":"test\/jdk\/java\/net\/DatagramSocket\/SetGetReceiveBufferSize.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021 Oracle and\/or its affiliates. All rights reserved.\n@@ -32,2 +32,0 @@\n- * @run testng\/othervm -Djdk.net.usePlainDatagramSocketImpl SetGetSendBufferSize\n- * @run testng\/othervm -Djdk.net.usePlainDatagramSocketImpl -Djava.net.preferIPv4Stack=true SetGetSendBufferSize\n","filename":"test\/jdk\/java\/net\/DatagramSocket\/SetGetSendBufferSize.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2021 Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n- * @run main\/othervm -Djdk.net.usePlainDatagramSocketImpl TestAfterClose\n","filename":"test\/jdk\/java\/net\/DatagramSocket\/TestAfterClose.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n- * @run main\/othervm -Djdk.net.usePlainDatagramSocketImpl UnreferencedDatagramSockets\n","filename":"test\/jdk\/java\/net\/DatagramSocket\/UnreferencedDatagramSockets.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2021 Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n- * @run main\/othervm -Djdk.net.usePlainDatagramSocketImpl B6427403\n","filename":"test\/jdk\/java\/net\/MulticastSocket\/B6427403.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n- * @run main\/othervm -Djdk.net.usePlainDatagramSocketImpl MulticastAddresses\n","filename":"test\/jdk\/java\/net\/MulticastSocket\/MulticastAddresses.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021 Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n- * @run main\/othervm -Djdk.net.usePlainDatagramSocketImpl NoSetNetworkInterface\n","filename":"test\/jdk\/java\/net\/MulticastSocket\/NoSetNetworkInterface.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n- * @run main\/othervm -Djdk.net.usePlainDatagramSocketImpl Promiscuous\n","filename":"test\/jdk\/java\/net\/MulticastSocket\/Promiscuous.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021 Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,0 @@\n- * @run testng\/othervm -Djava.security.manager=allow -Djdk.net.usePlainDatagramSocketImpl SendPortZero\n","filename":"test\/jdk\/java\/net\/MulticastSocket\/SendPortZero.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,0 @@\n- * @run main\/othervm -Djdk.net.usePlainDatagramSocketImpl SetLoopbackMode\n","filename":"test\/jdk\/java\/net\/MulticastSocket\/SetLoopbackMode.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,2 +35,0 @@\n- * @run main\/othervm -Djava.net.preferIPv4Stack=true\n- *                   -Djdk.net.usePlainDatagramSocketImpl SetLoopbackModeIPv4\n","filename":"test\/jdk\/java\/net\/MulticastSocket\/SetLoopbackModeIPv4.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021 Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,0 @@\n- * @run testng\/othervm -Djdk.net.usePlainDatagramSocketImpl SetLoopbackOption\n","filename":"test\/jdk\/java\/net\/MulticastSocket\/SetLoopbackOption.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n- * @run main\/othervm -Djdk.net.usePlainDatagramSocketImpl SetOutgoingIf\n","filename":"test\/jdk\/java\/net\/MulticastSocket\/SetOutgoingIf.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021 Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n- * @run main\/othervm -Djdk.net.usePlainDatagramSocketImpl SetTTLAndGetTTL\n","filename":"test\/jdk\/java\/net\/MulticastSocket\/SetTTLAndGetTTL.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021 Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n- * @run main\/othervm -Djdk.net.usePlainDatagramSocketImpl SetTTLTo0\n","filename":"test\/jdk\/java\/net\/MulticastSocket\/SetTTLTo0.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n- * @run main\/othervm -Djdk.net.usePlainDatagramSocketImpl UnreferencedMulticastSockets\n","filename":"test\/jdk\/java\/net\/MulticastSocket\/UnreferencedMulticastSockets.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021 Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @summary java.net.PlainSocketImpl backlog value bug avoidance\n+ * @summary java.net.SocketImpl backlog value bug avoidance\n","filename":"test\/jdk\/java\/net\/PlainSocketImpl\/BigBacklog.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2021 Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @summary ClassCastException in PlainSocketImpl.accept() when using custom socketImpl\n+ * @summary ClassCastException in SocketImpl.accept() when using custom socketImpl\n","filename":"test\/jdk\/java\/net\/PlainSocketImpl\/CustomSocketImplFactory.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @summary java.net.PlainSocketImpl {set,get}Option throws SocketException\n+ * @summary java.net.SocketImpl {set,get}Option throws SocketException\n","filename":"test\/jdk\/java\/net\/PlainSocketImpl\/SetOption.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,0 @@\n- * @run main\/othervm -Djdk.net.usePlainSocketImpl AcceptCauseFileDescriptorLeak root\n","filename":"test\/jdk\/java\/net\/ServerSocket\/AcceptCauseFileDescriptorLeak.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n- * @run main\/othervm -Djdk.net.usePlainSocketImpl UnreferencedSockets\n","filename":"test\/jdk\/java\/net\/ServerSocket\/UnreferencedSockets.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,0 @@\n- * @run main\/othervm -Djdk.net.usePlainDatagramSocketImpl AddressTest\n","filename":"test\/jdk\/java\/net\/Socket\/AddressTest.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n- * @run testng\/othervm -Djdk.net.usePlainSocketImpl ConnectionReset\n","filename":"test\/jdk\/java\/net\/Socket\/ConnectionReset.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021 Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @summary PlainSocketImpl.socketAccept() handles EINTR incorrectly\n+ * @summary SocketImpl.socketAccept() handles EINTR incorrectly\n@@ -30,2 +30,0 @@\n- * @run main\/othervm\/native -Djdk.net.usePlainSocketImpl=true SocketAcceptInterruptTest 0\n- * @run main\/othervm\/native -Djdk.net.usePlainSocketImpl=true SocketAcceptInterruptTest 5000\n","filename":"test\/jdk\/java\/net\/Socket\/SocketAcceptInterruptTest.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021 Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @summary PlainSocketImpl.socketAccept() handles EINTR incorrectly\n+ * @summary SocketImpl.socketAccept() handles EINTR incorrectly\n@@ -30,1 +30,0 @@\n- * @run main\/othervm\/native -Djdk.net.usePlainSocketImpl=true SocketReadInterruptTest 2000 3000\n@@ -32,1 +31,0 @@\n- * @run main\/othervm\/native -Djdk.net.usePlainSocketImpl=true SocketReadInterruptTest 2000 0\n","filename":"test\/jdk\/java\/net\/Socket\/SocketReadInterruptTest.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,0 @@\n- * @run main\/othervm -Djdk.net.usePlainSocketImpl AsyncClose\n","filename":"test\/jdk\/java\/net\/Socket\/asyncClose\/AsyncClose.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,81 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8221481\n- * @modules java.base\/java.net:+open java.base\/sun.nio.ch:+open\n- * @run testng CompareSocketOptions\n- * @summary Compare the set of socket options supported by the old and new SocketImpls\n- *\/\n-\n-import java.io.IOException;\n-import java.net.ServerSocket;\n-import java.net.Socket;\n-import java.net.SocketImpl;\n-\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n-\n-@Test\n-public class CompareSocketOptions {\n-\n-    \/**\n-     * Test that the old and new platform SocketImpl support the same set of\n-     * client socket options.\n-     *\/\n-    public void testClientSocketSupportedOptions() throws IOException {\n-        Socket s1 = new Socket(createOldSocketImpl(false)) { };\n-        Socket s2 = new Socket(createNewSocketImpl(false)) { };\n-        assertEquals(s1.supportedOptions(), s2.supportedOptions());\n-    }\n-\n-    \/**\n-     * Test that the old and new platform SocketImpl support the same set of\n-     * server socket options.\n-     *\/\n-    public void testServerSocketSupportedOptions() throws IOException {\n-        ServerSocket ss1 = new ServerSocket(createOldSocketImpl(true)) { };\n-        ServerSocket ss2 = new ServerSocket(createNewSocketImpl(true)) { };\n-        assertEquals(ss1.supportedOptions(), ss2.supportedOptions());\n-    }\n-\n-    private static SocketImpl createOldSocketImpl(boolean server) {\n-        return newPlatformSocketImpl(\"java.net.PlainSocketImpl\", server);\n-    }\n-\n-    private static SocketImpl createNewSocketImpl(boolean server) {\n-        return newPlatformSocketImpl(\"sun.nio.ch.NioSocketImpl\", server);\n-    }\n-\n-    private static SocketImpl newPlatformSocketImpl(String name, boolean server) {\n-        try {\n-            var ctor = Class.forName(name).getDeclaredConstructor(boolean.class);\n-            ctor.setAccessible(true);\n-            return (SocketImpl) ctor.newInstance(server);\n-        } catch (Exception e) {\n-            fail(\"Should not get here\", e);\n-            return null;\n-        }\n-    }\n-}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/net\/SocketImpl\/CompareSocketOptions.java","additions":0,"deletions":81,"binary":false,"changes":81,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,0 @@\n- * @run testng\/othervm -Djdk.net.usePlainSocketImpl AfterClose\n- * @run testng\/othervm -Djdk.net.usePlainDatagramSocketImpl AfterClose\n","filename":"test\/jdk\/java\/net\/SocketOption\/AfterClose.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021 Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n- * @run testng\/othervm -Djdk.net.usePlainSocketImpl NullsAndBadValues\n","filename":"test\/jdk\/java\/net\/SocketOption\/NullsAndBadValues.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,2 +30,0 @@\n- * @run main\/othervm -Djdk.net.usePlainSocketImpl OptionsTest\n- * @run main\/othervm -Djdk.net.usePlainDatagramSocketImpl OptionsTest\n","filename":"test\/jdk\/java\/net\/SocketOption\/OptionsTest.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021 Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,0 @@\n- * @run testng\/othervm -Djdk.net.usePlainSocketImpl RequiredOptions\n","filename":"test\/jdk\/java\/net\/SocketOption\/RequiredOptions.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n- * @run main\/othervm -Djdk.net.usePlainSocketImpl TcpTest -d\n","filename":"test\/jdk\/java\/net\/ipv6tests\/TcpTest.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"}]}