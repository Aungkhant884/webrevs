{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -181,1 +181,1 @@\n-                        mres.withDoNotResolveByDefault();\n+                        mres = mres.withDoNotResolveByDefault();\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/GNUStyleOptions.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,0 +26,3 @@\n+import java.lang.module.ModuleFinder;\n+import java.lang.module.ModuleReader;\n+import java.lang.module.ModuleReference;\n@@ -32,0 +35,1 @@\n+import java.util.function.Predicate;\n@@ -41,0 +45,3 @@\n+import jdk.internal.module.ModuleInfo;\n+import jdk.internal.module.ModuleReferenceImpl;\n+import jdk.internal.module.ModuleResolution;\n@@ -56,0 +63,1 @@\n+ *          java.base\/jdk.internal.module\n@@ -945,0 +953,121 @@\n+    @DataProvider(name = \"resolutionNames\")\n+    public Object[][] resolutionNames() {\n+        return new Object[][] {\n+            {\"incubating\", (Predicate<ModuleResolution>)ModuleResolution::hasIncubatingWarning},\n+            {\"deprecated\", (Predicate<ModuleResolution>)ModuleResolution::hasDeprecatedWarning},\n+            {\"deprecated-for-removal\", (Predicate<ModuleResolution>)ModuleResolution::hasDeprecatedForRemovalWarning}\n+        };\n+    }\n+\n+    \/**\n+     * Validate that you can update a jar only specifying --warn-if-resolved\n+     * @throws IOException\n+     *\/\n+    @Test(dataProvider = \"resolutionNames\")\n+    public void updateFooModuleResolutionWarnIfResolved(String resolutionName, Predicate<ModuleResolution> hasWarning) throws IOException {\n+        Path mp = Paths.get(\"updateFooModuleResolutionWarnIfResolved-\" + resolutionName);\n+        createTestDir(mp);\n+        Path modClasses = MODULE_CLASSES.resolve(FOO.moduleName);\n+        Path modularJar = mp.resolve(FOO.moduleName + \".jar\");\n+\n+        jar(\"--create\",\n+            \"--file=\" + modularJar.toString(),\n+            \"--main-class=\" + FOO.mainClass,\n+            \"--warn-if-resolved=\" + resolutionName,\n+            \"--no-manifest\",\n+            \"-C\", modClasses.toString(), \".\")\n+            .assertSuccess();\n+\n+        ModuleReferenceImpl moduleReference = ModuleFinder.of(modularJar).find(FOO.moduleName)\n+            .map(ModuleReferenceImpl.class::cast)\n+            .orElseThrow();\n+        ModuleResolution moduleResolution = moduleReference.moduleResolution();\n+\n+        assertTrue(hasWarning.test(moduleResolution));\n+    }\n+\n+    \/**\n+     * Validate that you can update a jar only specifying --do-not-resolve-by-default\n+     * @throws IOException\n+     *\/\n+    @Test\n+    public void updateFooModuleResolutionWarnIfResolved() throws IOException {\n+        Path mp = Paths.get(\"updateFooModuleResolutionDoNotResolveByDefault\");\n+        createTestDir(mp);\n+        Path modClasses = MODULE_CLASSES.resolve(FOO.moduleName);\n+        Path modularJar = mp.resolve(FOO.moduleName + \".jar\");\n+\n+        jar(\"--create\",\n+            \"--file=\" + modularJar.toString(),\n+            \"--main-class=\" + FOO.mainClass,\n+            \"--do-not-resolve-by-default\",\n+            \"--no-manifest\",\n+            \"-C\", modClasses.toString(), \".\")\n+            .assertSuccess();\n+\n+        ModuleReferenceImpl moduleReference = ModuleFinder.of(modularJar).find(FOO.moduleName)\n+            .map(ModuleReferenceImpl.class::cast)\n+            .orElseThrow();\n+        ModuleResolution moduleResolution = moduleReference.moduleResolution();\n+\n+        assertTrue(moduleResolution.doNotResolveByDefault());\n+    }\n+\n+    \/**\n+     * Validate that you can update a jar specifying --warn-if-resolved and --do-not-resolve-by-default\n+     * @throws IOException\n+     *\/\n+    @Test(dataProvider = \"resolutionNames\")\n+    public void updateFooModuleResolutionWarnIfResolvedAndDoNotResolveByDefault(String resolutionName, Predicate<ModuleResolution> hasWarning) throws IOException {\n+        Path mp = Paths.get(\"updateFooModuleResolutionWarnThenNotResolve-\" + resolutionName);\n+        createTestDir(mp);\n+        Path modClasses = MODULE_CLASSES.resolve(FOO.moduleName);\n+        Path modularJar = mp.resolve(FOO.moduleName + \".jar\");\n+\n+        jar(\"--create\",\n+            \"--file=\" + modularJar.toString(),\n+            \"--main-class=\" + FOO.mainClass,\n+            \"--warn-if-resolved=\" + resolutionName,\n+            \"--do-not-resolve-by-default\",\n+            \"--no-manifest\",\n+            \"-C\", modClasses.toString(), \".\")\n+            .assertSuccess();\n+\n+        ModuleReferenceImpl moduleReference = ModuleFinder.of(modularJar).find(FOO.moduleName)\n+            .map(ModuleReferenceImpl.class::cast)\n+            .orElseThrow();\n+        ModuleResolution moduleResolution = moduleReference.moduleResolution();\n+\n+        assertTrue(hasWarning.test(moduleResolution));\n+        assertTrue(moduleResolution.doNotResolveByDefault());\n+    }\n+\n+    \/**\n+     * Validate that you can update a jar specifying --do-not-resolve-by-default and --warn-if-resolved\n+     * @throws IOException\n+     *\/\n+    @Test(dataProvider = \"resolutionNames\")\n+    public void updateFooModuleResolutionDoNotResolveByDefaultAndWarnIfResolved(String resolutionName, Predicate<ModuleResolution> hasWarning) throws IOException {\n+        Path mp = Paths.get(\"updateFooModuleResolutionNotResolveThenWarn-\" + resolutionName);\n+        createTestDir(mp);\n+        Path modClasses = MODULE_CLASSES.resolve(FOO.moduleName);\n+        Path modularJar = mp.resolve(FOO.moduleName + \".jar\");\n+\n+        jar(\"--create\",\n+            \"--file=\" + modularJar.toString(),\n+            \"--main-class=\" + FOO.mainClass,\n+            \"--do-not-resolve-by-default\",\n+            \"--warn-if-resolved=\" + resolutionName,\n+            \"--no-manifest\",\n+            \"-C\", modClasses.toString(), \".\")\n+            .assertSuccess();\n+\n+        ModuleReferenceImpl moduleReference = ModuleFinder.of(modularJar).find(FOO.moduleName)\n+            .map(ModuleReferenceImpl.class::cast)\n+            .orElseThrow();\n+        ModuleResolution moduleResolution = moduleReference.moduleResolution();\n+\n+        assertTrue(hasWarning.test(moduleResolution));\n+        assertTrue(moduleResolution.doNotResolveByDefault());\n+    }\n+\n","filename":"test\/jdk\/tools\/jar\/modularJar\/Basic.java","additions":129,"deletions":0,"binary":false,"changes":129,"status":"modified"}]}