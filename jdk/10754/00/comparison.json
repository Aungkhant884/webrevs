{"files":[{"patch":"@@ -154,1 +154,0 @@\n-                                    boolean srcAtOnce, boolean dstAtOnce,\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/cmm\/lcms\/LCMS.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -82,5 +82,0 @@\n-    \/* This flag indicates whether the image can be processed\n-     * at once by doTransfrom() native call. Otherwise, the\n-     * image is processed scan by scan.\n-     *\/\n-    boolean imageAtOnce = false;\n@@ -237,4 +232,0 @@\n-\n-                    if (l.nextRowOffset == l.width * 4 * intRaster.getPixelStride()) {\n-                        l.imageAtOnce = true;\n-                    }\n@@ -257,3 +248,0 @@\n-                    if (l.nextRowOffset == l.width * byteRaster.getPixelStride()) {\n-                        l.imageAtOnce = true;\n-                    }\n@@ -274,4 +262,0 @@\n-\n-                    if (l.nextRowOffset == l.width * byteRaster.getPixelStride()) {\n-                        l.imageAtOnce = true;\n-                    }\n@@ -292,4 +276,0 @@\n-\n-                    if (l.nextRowOffset == l.width * 2 * shortRaster.getPixelStride()) {\n-                        l.imageAtOnce = true;\n-                    }\n@@ -412,4 +392,0 @@\n-\n-            if (l.nextRowOffset == l.width * br.getPixelStride()) {\n-                l.imageAtOnce = true;\n-            }\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/cmm\/lcms\/LCMSImageLayout.java","additions":0,"deletions":24,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -161,1 +161,0 @@\n-                          in.imageAtOnce, out.imageAtOnce,\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/cmm\/lcms\/LCMSTransform.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -525,1 +525,0 @@\n-   jboolean srcAtOnce, jboolean dstAtOnce,\n@@ -551,2 +550,2 @@\n-    char *inputRow = (char *) inputBuffer + srcOffset;\n-    char *outputRow = (char *) outputBuffer + dstOffset;\n+    char *input = (char *) inputBuffer + srcOffset;\n+    char *output = (char *) outputBuffer + dstOffset;\n@@ -554,9 +553,2 @@\n-    if (srcAtOnce && dstAtOnce) {\n-        cmsDoTransform(sTrans, inputRow, outputRow, width * height);\n-    } else {\n-        for (int i = 0; i < height; i++) {\n-            cmsDoTransform(sTrans, inputRow, outputRow, width);\n-            inputRow += srcNextRowOffset;\n-            outputRow += dstNextRowOffset;\n-        }\n-    }\n+    cmsDoTransformLineStride(sTrans, input, output, width, height,\n+                             srcNextRowOffset, dstNextRowOffset, 0, 0);\n","filename":"src\/java.desktop\/share\/native\/liblcms\/LCMS.c","additions":4,"deletions":12,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,200 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.AlphaComposite;\n+import java.awt.Color;\n+import java.awt.Graphics2D;\n+import java.awt.Image;\n+import java.awt.Transparency;\n+import java.awt.color.ColorSpace;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.ColorConvertOp;\n+import java.awt.image.ColorModel;\n+import java.awt.image.ComponentColorModel;\n+import java.awt.image.DataBuffer;\n+import java.awt.image.Raster;\n+import java.awt.image.WritableRaster;\n+import java.io.File;\n+\n+import javax.imageio.ImageIO;\n+\n+import static java.awt.image.BufferedImage.TYPE_3BYTE_BGR;\n+import static java.awt.image.BufferedImage.TYPE_4BYTE_ABGR;\n+import static java.awt.image.BufferedImage.TYPE_4BYTE_ABGR_PRE;\n+import static java.awt.image.BufferedImage.TYPE_BYTE_BINARY;\n+import static java.awt.image.BufferedImage.TYPE_BYTE_GRAY;\n+import static java.awt.image.BufferedImage.TYPE_BYTE_INDEXED;\n+import static java.awt.image.BufferedImage.TYPE_INT_ARGB;\n+import static java.awt.image.BufferedImage.TYPE_INT_ARGB_PRE;\n+import static java.awt.image.BufferedImage.TYPE_INT_BGR;\n+import static java.awt.image.BufferedImage.TYPE_INT_RGB;\n+import static java.awt.image.BufferedImage.TYPE_USHORT_555_RGB;\n+import static java.awt.image.BufferedImage.TYPE_USHORT_565_RGB;\n+import static java.awt.image.BufferedImage.TYPE_USHORT_GRAY;\n+\n+\/**\n+ * @test\n+ * @bug 8295430\n+ * @summary Tests various conversions from\/to custom 3BYTE_BGR image\n+ *\/\n+public final class FilterImageLineGap {\n+\n+    private static final int[] TYPES = {\n+            TYPE_INT_RGB, TYPE_INT_ARGB, TYPE_INT_ARGB_PRE, TYPE_INT_BGR,\n+            TYPE_3BYTE_BGR, TYPE_4BYTE_ABGR, TYPE_4BYTE_ABGR_PRE,\n+            TYPE_USHORT_565_RGB, TYPE_USHORT_555_RGB, TYPE_BYTE_GRAY,\n+            TYPE_USHORT_GRAY, TYPE_BYTE_BINARY, TYPE_BYTE_INDEXED\n+    };\n+\n+    private static final int[] CSS = {\n+            ColorSpace.CS_CIEXYZ, ColorSpace.CS_GRAY, ColorSpace.CS_LINEAR_RGB,\n+            ColorSpace.CS_PYCC, ColorSpace.CS_sRGB\n+    };\n+\n+    private static final int W = 511;\n+    private static final int H = 255;\n+\n+    public static void main(String[] args) throws Exception {\n+        for (int fromIndex : CSS) {\n+            for (int toIndex : CSS) {\n+                customToCustom(fromIndex, toIndex);\n+                customToAny(fromIndex, toIndex);\n+                anytoCustom(fromIndex, toIndex);\n+            }\n+        }\n+    }\n+\n+    private static void customToCustom(int fromIndex, int toIndex)\n+            throws Exception\n+    {\n+        ColorSpace toCS = ColorSpace.getInstance(fromIndex);\n+        ColorSpace fromCS = ColorSpace.getInstance(toIndex);\n+        ColorConvertOp op = new ColorConvertOp(fromCS, toCS, null);\n+        BufferedImage src = makeCustom3BYTE_BGR();\n+        BufferedImage dst = makeCustom3BYTE_BGR();\n+\n+        BufferedImage srcGold = new BufferedImage(W, H, TYPE_3BYTE_BGR);\n+        BufferedImage dstGold = new BufferedImage(W, H, TYPE_3BYTE_BGR);\n+        fill(src);\n+        fill(srcGold);\n+\n+        op.filter(src, dst);\n+        op.filter(srcGold, dstGold);\n+        \/\/ validate images\n+        for (int x = 0; x < W; ++x) {\n+            for (int y = 0; y < H; ++y) {\n+                if (dst.getRGB(x, y) != dstGold.getRGB(x, y)) {\n+                    ImageIO.write(dst, \"png\", new File(\"custom.png\"));\n+                    ImageIO.write(dstGold, \"png\", new File(\"gold.png\"));\n+                    throw new RuntimeException(\"Test failed.\");\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void customToAny(int fromIndex, int toIndex) throws Exception\n+    {\n+        ColorSpace toCS = ColorSpace.getInstance(fromIndex);\n+        ColorSpace fromCS = ColorSpace.getInstance(toIndex);\n+        ColorConvertOp op = new ColorConvertOp(fromCS, toCS, null);\n+        for (int type : TYPES) {\n+            BufferedImage src = makeCustom3BYTE_BGR();\n+            BufferedImage dst = new BufferedImage(W, H, type);\n+\n+            BufferedImage srcGold = new BufferedImage(W, H, TYPE_3BYTE_BGR);\n+            BufferedImage dstGold = new BufferedImage(W, H, type);\n+            fill(src);\n+            fill(srcGold);\n+\n+            op.filter(src, dst);\n+            op.filter(srcGold, dstGold);\n+            \/\/ validate images\n+            for (int x = 0; x < W; ++x) {\n+                for (int y = 0; y < H; ++y) {\n+                    if (dst.getRGB(x, y) != dstGold.getRGB(x, y)) {\n+                        ImageIO.write(dst, \"png\", new File(\"custom.png\"));\n+                        ImageIO.write(dstGold, \"png\", new File(\"gold.png\"));\n+                        throw new RuntimeException(\"Test failed.\");\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void anytoCustom(int fromIndex, int toIndex) throws Exception\n+    {\n+        ColorSpace toCS = ColorSpace.getInstance(fromIndex);\n+        ColorSpace fromCS = ColorSpace.getInstance(toIndex);\n+        ColorConvertOp op = new ColorConvertOp(fromCS, toCS, null);\n+        for (int type : TYPES) {\n+            BufferedImage src = new BufferedImage(W, H, type);\n+            BufferedImage dst = makeCustom3BYTE_BGR();\n+\n+            BufferedImage srcGold = new BufferedImage(W, H, type);\n+            BufferedImage dstGold = new BufferedImage(W, H, TYPE_3BYTE_BGR);\n+            fill(src);\n+            fill(srcGold);\n+\n+            op.filter(src, dst);\n+            op.filter(srcGold, dstGold);\n+            \/\/ validate images\n+            for (int x = 0; x < W; ++x) {\n+                for (int y = 0; y < H; ++y) {\n+                    if (dst.getRGB(x, y) != dstGold.getRGB(x, y)) {\n+                        ImageIO.write(dst, \"png\", new File(\"custom.png\"));\n+                        ImageIO.write(dstGold, \"png\", new File(\"gold.png\"));\n+                        throw new RuntimeException(\"Test failed.\");\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Returns the custom buffered image, which mostly identical to\n+     * BufferedImage.(w,h,TYPE_3BYTE_BGR), but uses the bigger scanlineStride.\n+     * This means that the raster will have gaps, between the rows.\n+     *\/\n+    private static BufferedImage makeCustom3BYTE_BGR() {\n+        ColorSpace cs = ColorSpace.getInstance(ColorSpace.CS_sRGB);\n+        int[] nBits = {8, 8, 8};\n+        int[] bOffs = {2, 1, 0};\n+        ColorModel colorModel = new ComponentColorModel(cs, nBits, false, false,\n+                                                        Transparency.OPAQUE,\n+                                                        DataBuffer.TYPE_BYTE);\n+        WritableRaster raster = Raster.createInterleavedRaster(\n+                DataBuffer.TYPE_BYTE, W, H, W * 3 + 2, 3, bOffs, null);\n+        return new BufferedImage(colorModel, raster, true, null);\n+    }\n+\n+    private static void fill(Image image) {\n+        Graphics2D graphics = (Graphics2D) image.getGraphics();\n+        graphics.setComposite(AlphaComposite.Src);\n+        for (int i = 0; i < image.getHeight(null); ++i) {\n+            graphics.setColor(new Color(i, 0, 255 - i));\n+            graphics.fillRect(0, i, image.getWidth(null), 1);\n+        }\n+        graphics.dispose();\n+    }\n+}\n","filename":"test\/jdk\/sun\/java2d\/cmm\/ColorConvertOp\/FilterImageLineGap.java","additions":200,"deletions":0,"binary":false,"changes":200,"status":"added"},{"patch":"@@ -0,0 +1,140 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.AlphaComposite;\n+import java.awt.Color;\n+import java.awt.Graphics2D;\n+import java.awt.Image;\n+import java.awt.Transparency;\n+import java.awt.color.ColorSpace;\n+import java.awt.color.ICC_ColorSpace;\n+import java.awt.color.ICC_Profile;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.ColorConvertOp;\n+import java.awt.image.ColorModel;\n+import java.awt.image.ComponentColorModel;\n+import java.awt.image.DataBuffer;\n+import java.awt.image.Raster;\n+import java.awt.image.WritableRaster;\n+import java.io.File;\n+\n+import javax.imageio.ImageIO;\n+\n+import static java.awt.image.BufferedImage.TYPE_3BYTE_BGR;\n+import static java.awt.image.BufferedImage.TYPE_4BYTE_ABGR;\n+import static java.awt.image.BufferedImage.TYPE_4BYTE_ABGR_PRE;\n+import static java.awt.image.BufferedImage.TYPE_BYTE_BINARY;\n+import static java.awt.image.BufferedImage.TYPE_BYTE_GRAY;\n+import static java.awt.image.BufferedImage.TYPE_BYTE_INDEXED;\n+import static java.awt.image.BufferedImage.TYPE_CUSTOM;\n+import static java.awt.image.BufferedImage.TYPE_INT_ARGB;\n+import static java.awt.image.BufferedImage.TYPE_INT_ARGB_PRE;\n+import static java.awt.image.BufferedImage.TYPE_INT_BGR;\n+import static java.awt.image.BufferedImage.TYPE_INT_RGB;\n+import static java.awt.image.BufferedImage.TYPE_USHORT_555_RGB;\n+import static java.awt.image.BufferedImage.TYPE_USHORT_565_RGB;\n+import static java.awt.image.BufferedImage.TYPE_USHORT_GRAY;\n+\n+\/**\n+ * @test\n+ * @bug 8295430\n+ * @summary Compare the SRGB->SRGB and SRGB->CUSTOM conversions when CUSTOM=SRGB\n+ *\/\n+public final class ValidateNoopFilter {\n+\n+    private static final int[] TYPES = {\n+            TYPE_INT_RGB, TYPE_INT_ARGB, TYPE_INT_ARGB_PRE, TYPE_INT_BGR,\n+            TYPE_3BYTE_BGR, TYPE_4BYTE_ABGR, TYPE_4BYTE_ABGR_PRE,\n+            TYPE_USHORT_565_RGB, TYPE_USHORT_555_RGB, TYPE_BYTE_GRAY,\n+            TYPE_USHORT_GRAY, TYPE_BYTE_BINARY, TYPE_BYTE_INDEXED, TYPE_CUSTOM\n+    };\n+\n+    private static final int W = 511;\n+    private static final int H = 255;\n+\n+    public static void main(String[] args) throws Exception {\n+        byte[] data = ICC_Profile.getInstance(ColorSpace.CS_sRGB).getData();\n+        ColorSpace custom = new ICC_ColorSpace(ICC_Profile.getInstance(data));\n+        ColorSpace srgb = ColorSpace.getInstance(ColorSpace.CS_sRGB);\n+\n+        ColorConvertOp opCustom = new ColorConvertOp(srgb, custom, null);\n+        ColorConvertOp opGold = new ColorConvertOp(srgb, srgb, null);\n+\n+        for (int type : TYPES) {\n+            BufferedImage src = makeBi(type);\n+            BufferedImage dst = makeBi(type);\n+            BufferedImage dstGold = makeBi(type);\n+\n+            fill(src);\n+\n+            opCustom.filter(src, dst);\n+            opGold.filter(src, dstGold);\n+            \/\/ validate images\n+            for (int x = 0; x < W; ++x) {\n+                for (int y = 0; y < H; ++y) {\n+                    if (dst.getRGB(x, y) != dstGold.getRGB(x, y)) {\n+                        ImageIO.write(dst, \"png\", new File(\"custom.png\"));\n+                        ImageIO.write(dstGold, \"png\", new File(\"gold.png\"));\n+                        throw new RuntimeException(\"Test failed.\");\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static BufferedImage makeBi(int type) {\n+        if (type == TYPE_CUSTOM) {\n+            return makeCustom3BYTE_BGR();\n+        } else {\n+            return new BufferedImage(W, H, type);\n+        }\n+    }\n+\n+    \/**\n+     * Returns the custom buffered image, which mostly identical to\n+     * BufferedImage.(w,h,TYPE_3BYTE_BGR), but uses the bigger scanlineStride.\n+     * This means that the raster will have gaps, between the rows.\n+     *\/\n+    private static BufferedImage makeCustom3BYTE_BGR() {\n+        ColorSpace cs = ColorSpace.getInstance(ColorSpace.CS_sRGB);\n+        int[] nBits = {8, 8, 8};\n+        int[] bOffs = {2, 1, 0};\n+        ColorModel colorModel = new ComponentColorModel(cs, nBits, false, false,\n+                                                        Transparency.OPAQUE,\n+                                                        DataBuffer.TYPE_BYTE);\n+        WritableRaster raster = Raster.createInterleavedRaster(\n+                DataBuffer.TYPE_BYTE, W, H, W * 3 + 2, 3, bOffs, null);\n+        return new BufferedImage(colorModel, raster, true, null);\n+    }\n+\n+    private static void fill(Image image) {\n+        Graphics2D graphics = (Graphics2D) image.getGraphics();\n+        graphics.setComposite(AlphaComposite.Src);\n+        for (int i = 0; i < image.getHeight(null); ++i) {\n+            graphics.setColor(new Color(i, 0, 255 - i));\n+            graphics.fillRect(0, i, image.getWidth(null), 1);\n+        }\n+        graphics.dispose();\n+    }\n+}\n","filename":"test\/jdk\/sun\/java2d\/cmm\/ColorConvertOp\/ValidateNoopFilter.java","additions":140,"deletions":0,"binary":false,"changes":140,"status":"added"}]}