{"files":[{"patch":"@@ -38,0 +38,1 @@\n+import jdk.internal.util.UTF8EncodeUtils;\n@@ -283,4 +284,5 @@\n-                encodeByte(out, (byte) (0xc0 | (c >> 6)));\n-                encodeByte(out, (byte) (0x80 | (c & 0x3f)));\n-            } else if (Character.isSurrogate(c)) {\n-                if (Character.isHighSurrogate(c) && i < s.length() - 1) {\n+                int bytes = UTF8EncodeUtils.encodeDoubleBytes(c);\n+                encodeByte(out, (byte) (bytes >>> 8));\n+                encodeByte(out, (byte) (bytes & 0xff));\n+            } else if (Character.isHighSurrogate(c)) {\n+                if (i < s.length() - 1) {\n@@ -290,4 +292,5 @@\n-                        encodeByte(out, (byte) (0xf0 | ((uc >> 18))));\n-                        encodeByte(out, (byte) (0x80 | ((uc >> 12) & 0x3f)));\n-                        encodeByte(out, (byte) (0x80 | ((uc >> 6) & 0x3f)));\n-                        encodeByte(out, (byte) (0x80 | (uc & 0x3f)));\n+                        int bytes = UTF8EncodeUtils.encodeCodePoint(uc);\n+                        encodeByte(out, (byte) ((bytes >>> 24) & 0xff));\n+                        encodeByte(out, (byte) ((bytes >>> 16) & 0xff));\n+                        encodeByte(out, (byte) ((bytes >>> 8) & 0xff));\n+                        encodeByte(out, (byte) ((bytes) & 0xff));\n@@ -299,1 +302,1 @@\n-                \/\/ Replace unmappable characters\n+                \/\/ Unmappable Char\n@@ -302,3 +305,4 @@\n-                encodeByte(out, (byte) (0xe0 | ((c >> 12))));\n-                encodeByte(out, (byte) (0x80 | ((c >> 6) & 0x3f)));\n-                encodeByte(out, (byte) (0x80 | (c & 0x3f)));\n+                int bytes = UTF8EncodeUtils.encodeThreeBytes(c);\n+                encodeByte(out, (byte) ((bytes >>> 16) & 0xff));\n+                encodeByte(out, (byte) ((bytes >>> 8) & 0xff));\n+                encodeByte(out, (byte) ((bytes) & 0xff));\n","filename":"src\/java.base\/share\/classes\/java\/net\/URLEncoder.java","additions":16,"deletions":12,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\r\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\r\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\r\n+ *\r\n+ * This code is free software; you can redistribute it and\/or modify it\r\n+ * under the terms of the GNU General Public License version 2 only, as\r\n+ * published by the Free Software Foundation.  Oracle designates this\r\n+ * particular file as subject to the \"Classpath\" exception as provided\r\n+ * by Oracle in the LICENSE file that accompanied this code.\r\n+ *\r\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\r\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\r\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\r\n+ * version 2 for more details (a copy is included in the LICENSE file that\r\n+ * accompanied this code).\r\n+ *\r\n+ * You should have received a copy of the GNU General Public License version\r\n+ * 2 along with this work; if not, write to the Free Software Foundation,\r\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\r\n+ *\r\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\r\n+ * or visit www.oracle.com if you need additional information or have any\r\n+ * questions.\r\n+ *\/\r\n+package jdk.internal.util;\r\n+\r\n+import jdk.internal.vm.annotation.ForceInline;\r\n+\r\n+\/**\r\n+ * Utility methods for encoding characters into UTF-8 byte sequences,\r\n+ *\r\n+ * <p>For example to writing a fast UTF-8 encoding loop:\r\n+ * {@snippet lang = java:\r\n+ *    for (int i = 0; i < s.length(); i++) {\r\n+ *        char c = s.charAt(i);\r\n+ *        if (UTF8EncodeUtils.isSingleByte(c)) {\r\n+ *            \/\/ handle single byte\r\n+ *        } else if (UTF8EncodeUtils.isDoubleBytes(c)) {\r\n+ *            int bytes = UTF8EncodeUtils.encodeDoubleBytes(c);\r\n+ *            byte b0 = (byte) (bytes >>> 8);\r\n+ *            byte b1 = (byte) (bytes & 0xff);\r\n+ *            \/\/ handle double bytes\r\n+ *        } else if (Character.isSurrogate(c)) {\r\n+ *            if (i < s.length() - 1) {\r\n+ *                char d = s.charAt(i + 1);\r\n+ *                if (Character.isLowSurrogate(d)) {\r\n+ *                    int uc = Character.toCodePoint(c, d);\r\n+ *                    int bytes = UTF8EncodeUtils.encodeCodePoint(uc);\r\n+ *                    byte b0 = (byte) ((bytes >>> 24) & 0xff);\r\n+ *                    byte b1 = (byte) ((bytes >>> 16) & 0xff);\r\n+ *                    byte b2 = (byte) ((bytes >>> 8) & 0xff);\r\n+ *                    byte b3 = (byte) ((bytes) & 0xff);\r\n+ *\r\n+ *                    \/\/ handle four bytes\r\n+ *\r\n+ *                    i++;\r\n+ *                    continue;\r\n+ *                }\r\n+ *            }\r\n+ *            \/\/ handle unmappable char\r\n+ *        } else {\r\n+ *            int bytes = UTF8EncodeUtils.encodeThreeBytes(c);\r\n+ *            byte b0 = (byte) ((bytes >>> 16) & 0xff);\r\n+ *            byte b1 = (byte) ((bytes >>> 8) & 0xff);\r\n+ *            byte b2 = (byte) ((bytes) & 0xff);\r\n+ *            \/\/ handle three bytes\r\n+ *        }\r\n+ *    }\r\n+ * }\r\n+ * @since 22\r\n+ *\/\r\n+public class UTF8EncodeUtils {\r\n+\r\n+    public static boolean isSingleByte(char c) {\r\n+        return c < 0x80;\r\n+    }\r\n+\r\n+    public static boolean isDoubleBytes(char c) {\r\n+        return c < 0x800;\r\n+    }\r\n+\r\n+    @ForceInline\r\n+    public static int encodeDoubleBytes(char c) {\r\n+        byte b0 = (byte) (0xc0 | (c >> 6));\r\n+        byte b1 = (byte) (0x80 | (c & 0x3f));\r\n+        return ((b0 & 0xff) << 8) | b1;\r\n+    }\r\n+\r\n+    @ForceInline\r\n+    public static int encodeThreeBytes(char c) {\r\n+        byte b0 = (byte) (0xe0 | c >> 12);\r\n+        byte b1 = (byte) (0x80 | c >> 6 & 0x3f);\r\n+        byte b2 = (byte) (0x80 | c & 0x3f);\r\n+        return ((b0 & 0xff) << 16) | ((b1 & 0xff) << 8) | b2;\r\n+    }\r\n+\r\n+    @ForceInline\r\n+    public static int encodeCodePoint(int uc) {\r\n+        byte b0 = (byte) (0xf0 | ((uc >> 18)));\r\n+        byte b1 = (byte) (0x80 | ((uc >> 12) & 0x3f));\r\n+        byte b2 = (byte) (0x80 | ((uc >> 6) & 0x3f));\r\n+        byte b3 = (byte) (0x80 | (uc & 0x3f));\r\n+        return ((b0 & 0xff) << 24) | ((b1 & 0xff) << 16) | ((b2 & 0xff) << 8) | b3;\r\n+    }\r\n+}\r\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/UTF8EncodeUtils.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"}]}