{"files":[{"patch":"@@ -38,1 +38,0 @@\n-import jdk.internal.util.UTF8EncodeUtils;\n@@ -146,0 +145,18 @@\n+    private static void encodeByte(StringBuilder out, byte b) {\n+        out.append('%');\n+\n+        int n0 = (b >> 4) & 0xF;\n+        if (n0 < 10) {\n+            out.append((char) ('0' + n0));\n+        } else {\n+            out.append((char) ('A' - 10 + n0));\n+        }\n+\n+        int n1 = b & 0xF;\n+        if (n1 < 10) {\n+            out.append((char) ('0' + n1));\n+        } else {\n+            out.append((char) ('A' - 10 + n1));\n+        }\n+    }\n+\n@@ -241,75 +258,0 @@\n-        if (charset == StandardCharsets.UTF_8) {\n-            return encodeUTF8(s, i);\n-        } else {\n-            return encodeSlow(s, charset, i);\n-        }\n-    }\n-\n-    private static void encodeByte(StringBuilder out, byte b) {\n-        out.append('%');\n-\n-        int n0 = (b >> 4) & 0xF;\n-        if (n0 < 10) {\n-            out.append((char) ('0' + n0));\n-        } else {\n-            out.append((char) ('A' - 10 + n0));\n-        }\n-\n-        int n1 = b & 0xF;\n-        if (n1 < 10) {\n-            out.append((char) ('0' + n1));\n-        } else {\n-            out.append((char) ('A' - 10 + n1));\n-        }\n-    }\n-\n-    private static String encodeUTF8(String s, int suffixOffset) {\n-        StringBuilder out = new StringBuilder(s.length() << 1);\n-        if (suffixOffset > 0) {\n-            out.append(s, 0, suffixOffset);\n-        }\n-\n-        for (int i = suffixOffset; i < s.length(); i++) {\n-            char c = s.charAt(i);\n-            if (c <= UTF8EncodeUtils.MAX_SINGLE_BYTE_CHAR) {\n-                if (DONT_NEED_ENCODING[c]) {\n-                    if (c == ' ') {\n-                        c = '+';\n-                    }\n-                    out.append(c);\n-                } else {\n-                    encodeByte(out, (byte) c);\n-                }\n-            } else if (c <= UTF8EncodeUtils.MAX_DULBLE_BYTES_CHAR) {\n-                byte[] bytes = UTF8EncodeUtils.encodeDoubleBytes(c);\n-                encodeByte(out, bytes[0]);\n-                encodeByte(out, bytes[1]);\n-            } else if (Character.isSurrogate(c)) {\n-                if (Character.isHighSurrogate(c) && i < s.length() - 1) {\n-                    char d = s.charAt(i + 1);\n-                    if (Character.isLowSurrogate(d)) {\n-                        int uc = Character.toCodePoint(c, d);\n-                        byte[] bytes = UTF8EncodeUtils.encodeCodePoint(uc);\n-                        encodeByte(out, bytes[0]);\n-                        encodeByte(out, bytes[1]);\n-                        encodeByte(out, bytes[2]);\n-                        encodeByte(out, bytes[3]);\n-                        i++;\n-                        continue;\n-                    }\n-                }\n-\n-                \/\/ Unmappable Char\n-                encodeByte(out, (byte) '?');\n-            } else {\n-                byte[] bytes = UTF8EncodeUtils.encodeThreeBytes(c);\n-                encodeByte(out, bytes[0]);\n-                encodeByte(out, bytes[1]);\n-                encodeByte(out, bytes[2]);\n-            }\n-        }\n-\n-        return out.toString();\n-    }\n-\n-    private static String encodeSlow(String s, Charset charset, int suffixOffset) {\n@@ -318,2 +260,2 @@\n-        if (suffixOffset > 0) {\n-            out.append(s, 0, suffixOffset);\n+        if (i > 0) {\n+            out.append(s, 0, i);\n@@ -322,1 +264,1 @@\n-        for (int i = suffixOffset; i < s.length(); ) {\n+        while (i < s.length()) {\n","filename":"src\/java.base\/share\/classes\/java\/net\/URLEncoder.java","additions":21,"deletions":79,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -1,95 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.internal.util;\n-\n-import jdk.internal.vm.annotation.ForceInline;\n-\n-\/**\n- * Utility methods for encoding characters into UTF-8 byte sequences,\n- *\n- * <p>For example to writing a fast UTF-8 encoding loop:\n- * {@snippet lang = java:\n- *    for (int i = 0; i < s.length(); i++) {\n- *        char c = s.charAt(i);\n- *        if (c <= UTF8EncodeUtils.MAX_SINGLE_BYTE_CHAR) {\n- *            \/\/ handle single byte\n- *        } else if (c <= UTF8EncodeUtils.MAX_DULBLE_BYTES_CHAR) {\n- *            byte[] bytes = UTF8EncodeUtils.encodeDoubleBytes(c);\n- *            \/\/ handle double bytes\n- *        } else if (Character.isSurrogate(c)) {\n- *            if (i < s.length() - 1) {\n- *                char d = s.charAt(i + 1);\n- *                if (Character.isLowSurrogate(d)) {\n- *                    int uc = Character.toCodePoint(c, d);\n- *                    byte[] bytes = UTF8EncodeUtils.encodeCodePoint(uc);\n- *\n- *                    \/\/ handle four bytes\n- *\n- *                    i++;\n- *                    continue;\n- *                }\n- *            }\n- *            \/\/ handle unmappable char\n- *        } else {\n- *            byte[] bytes = UTF8EncodeUtils.encodeThreeBytes(c);\n- *            \/\/ handle three bytes\n- *        }\n- *    }\n- * }\n- * @since 22\n- *\/\n-public final class UTF8EncodeUtils {\n-\n-    private UTF8EncodeUtils() {\n-    }\n-\n-    public static final char MAX_SINGLE_BYTE_CHAR = 0x7f;\n-\n-    public static final char MAX_DULBLE_BYTES_CHAR = 0x7ff;\n-\n-    @ForceInline\n-    public static byte[] encodeDoubleBytes(char c) {\n-        byte b0 = (byte) (0xc0 | (c >> 6));\n-        byte b1 = (byte) (0x80 | (c & 0x3f));\n-        return new byte[]{b0, b1};\n-    }\n-\n-    @ForceInline\n-    public static byte[] encodeThreeBytes(char c) {\n-        byte b0 = (byte) (0xe0 | (c >> 12));\n-        byte b1 = (byte) (0x80 | ((c >> 6) & 0x3f));\n-        byte b2 = (byte) (0x80 | (c & 0x3f));\n-        return new byte[]{b0, b1, b2};\n-    }\n-\n-    @ForceInline\n-    public static byte[] encodeCodePoint(int uc) {\n-        byte b0 = (byte) (0xf0 | ((uc >> 18)));\n-        byte b1 = (byte) (0x80 | ((uc >> 12) & 0x3f));\n-        byte b2 = (byte) (0x80 | ((uc >> 6) & 0x3f));\n-        byte b3 = (byte) (0x80 | (uc & 0x3f));\n-        return new byte[]{b0, b1, b2, b3};\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/UTF8EncodeUtils.java","additions":0,"deletions":95,"binary":false,"changes":95,"status":"deleted"}]}