{"files":[{"patch":"@@ -32,0 +32,1 @@\n+import java.nio.charset.StandardCharsets;\n@@ -37,0 +38,2 @@\n+import jdk.internal.util.UTF8EncodeUtils;\n+import jdk.internal.vm.annotation.Stable;\n@@ -81,2 +84,3 @@\n-    private static final BitSet DONT_NEED_ENCODING;\n-    private static final int CASE_DIFF = ('a' - 'A');\n+\n+    @Stable\n+    private static final boolean[] DONT_NEED_ENCODING = new boolean[128];\n@@ -123,11 +127,15 @@\n-        DONT_NEED_ENCODING = new BitSet(128);\n-\n-        DONT_NEED_ENCODING.set('a', 'z' + 1);\n-        DONT_NEED_ENCODING.set('A', 'Z' + 1);\n-        DONT_NEED_ENCODING.set('0', '9' + 1);\n-        DONT_NEED_ENCODING.set(' '); \/* encoding a space to a + is done\n-                                    * in the encode() method *\/\n-        DONT_NEED_ENCODING.set('-');\n-        DONT_NEED_ENCODING.set('_');\n-        DONT_NEED_ENCODING.set('.');\n-        DONT_NEED_ENCODING.set('*');\n+         for (int i = 'a'; i <= 'z'; i++) {\n+             DONT_NEED_ENCODING[i] = true;\n+         }\n+         for (int i = 'A'; i <= 'Z'; i++) {\n+             DONT_NEED_ENCODING[i] = true;\n+         }\n+         for (int i = '0'; i <= '9'; i++) {\n+             DONT_NEED_ENCODING[i] = true;\n+         }\n+         \/\/ encoding a space to a + is done in the encode() method\n+         DONT_NEED_ENCODING[' '] = true;\n+         DONT_NEED_ENCODING['-'] = true;\n+         DONT_NEED_ENCODING['_'] = true;\n+         DONT_NEED_ENCODING['.'] = true;\n+         DONT_NEED_ENCODING['*'] = true;\n@@ -222,2 +230,87 @@\n-        boolean needToChange = false;\n-        StringBuilder out = new StringBuilder(s.length());\n+        int i;\n+        for (i = 0; i < s.length(); i++) {\n+            char c = s.charAt(i);\n+            if (c >= 128 || !DONT_NEED_ENCODING[c] || c == ' ') {\n+                break;\n+            }\n+        }\n+        if (i == s.length()) {\n+            return s;\n+        }\n+\n+        if (charset == StandardCharsets.UTF_8) {\n+            return encodeUTF8(s, i);\n+        } else {\n+            return encodeSlow(s, charset, i);\n+        }\n+    }\n+\n+    private static void encodeByte(StringBuilder out, byte b) {\n+        out.append('%');\n+\n+        int n0 = (b >> 4) & 0xF;\n+        if (n0 < 10) {\n+            out.append((char) ('0' + n0));\n+        } else {\n+            out.append((char) ('A' - 10 + n0));\n+        }\n+\n+        int n1 = b & 0xF;\n+        if (n1 < 10) {\n+            out.append((char) ('0' + n1));\n+        } else {\n+            out.append((char) ('A' - 10 + n1));\n+        }\n+    }\n+\n+    private static String encodeUTF8(String s, int suffixOffset) {\n+        StringBuilder out = new StringBuilder(s.length() << 1);\n+        if (suffixOffset > 0) {\n+            out.append(s, 0, suffixOffset);\n+        }\n+\n+        for (int i = suffixOffset; i < s.length(); i++) {\n+            char c = s.charAt(i);\n+            if (UTF8EncodeUtils.isSingleByte(c)) {\n+                if (DONT_NEED_ENCODING[c]) {\n+                    if (c == ' ') {\n+                        c = '+';\n+                    }\n+                    out.append(c);\n+                } else {\n+                    encodeByte(out, (byte) c);\n+                }\n+            } else if (UTF8EncodeUtils.isDoubleBytes(c)) {\n+                byte[] bytes = UTF8EncodeUtils.encodeDoubleBytes(c);\n+                encodeByte(out, bytes[0]);\n+                encodeByte(out, bytes[1]);\n+            } else if (Character.isSurrogate(c)) {\n+                if (Character.isHighSurrogate(c) && i < s.length() - 1) {\n+                    char d = s.charAt(i + 1);\n+                    if (Character.isLowSurrogate(d)) {\n+                        int uc = Character.toCodePoint(c, d);\n+                        byte[] bytes = UTF8EncodeUtils.encodeCodePoint(uc);\n+                        encodeByte(out, bytes[0]);\n+                        encodeByte(out, bytes[1]);\n+                        encodeByte(out, bytes[2]);\n+                        encodeByte(out, bytes[3]);\n+                        i++;\n+                        continue;\n+                    }\n+                }\n+\n+                \/\/ Unmappable Char\n+                encodeByte(out, (byte) '?');\n+            } else {\n+                byte[] bytes = UTF8EncodeUtils.encodeThreeBytes(c);\n+                encodeByte(out, bytes[0]);\n+                encodeByte(out, bytes[1]);\n+                encodeByte(out, bytes[2]);\n+            }\n+        }\n+\n+        return out.toString();\n+    }\n+\n+    private static String encodeSlow(String s, Charset charset, int suffixOffset) {\n+        StringBuilder out = new StringBuilder(s.length() << 1);\n@@ -225,0 +318,3 @@\n+        if (suffixOffset > 0) {\n+            out.append(s, 0, suffixOffset);\n+        }\n@@ -226,4 +322,3 @@\n-        for (int i = 0; i < s.length();) {\n-            int c = s.charAt(i);\n-            \/\/System.out.println(\"Examining character: \" + c);\n-            if (DONT_NEED_ENCODING.get(c)) {\n+        for (int i = suffixOffset; i < s.length(); ) {\n+            char c = s.charAt(i);\n+            if (c < 128 && DONT_NEED_ENCODING[c]) {\n@@ -232,1 +327,0 @@\n-                    needToChange = true;\n@@ -234,2 +328,1 @@\n-                \/\/System.out.println(\"Storing: \" + c);\n-                out.append((char)c);\n+                out.append(c);\n@@ -245,1 +338,1 @@\n-                     * surrogate pairs range occurs outside of a legal\n+                     * surrogate pairs range occurs outside a legal\n@@ -249,17 +342,4 @@\n-                    if (c >= 0xD800 && c <= 0xDBFF) {\n-                        \/*\n-                          System.out.println(Integer.toHexString(c)\n-                          + \" is high surrogate\");\n-                        *\/\n-                        if ( (i+1) < s.length()) {\n-                            int d = s.charAt(i+1);\n-                            \/*\n-                              System.out.println(\"\\tExamining \"\n-                              + Integer.toHexString(d));\n-                            *\/\n-                            if (d >= 0xDC00 && d <= 0xDFFF) {\n-                                \/*\n-                                  System.out.println(\"\\t\"\n-                                  + Integer.toHexString(d)\n-                                  + \" is low surrogate\");\n-                                *\/\n+                    if (Character.isHighSurrogate(c)) {\n+                        if ((i + 1) < s.length()) {\n+                            char d = s.charAt(i + 1);\n+                            if (Character.isLowSurrogate(d)) {\n@@ -272,1 +352,1 @@\n-                } while (i < s.length() && !DONT_NEED_ENCODING.get((c = s.charAt(i))));\n+                } while (i < s.length() && ((c = s.charAt(i)) >= 128 || !DONT_NEED_ENCODING[c]));\n@@ -274,1 +354,0 @@\n-                charArrayWriter.flush();\n@@ -278,13 +357,1 @@\n-                    out.append('%');\n-                    char ch = Character.forDigit((b >> 4) & 0xF, 16);\n-                    \/\/ converting to use uppercase letter as part of\n-                    \/\/ the hex value if ch is a letter.\n-                    if (Character.isLetter(ch)) {\n-                        ch -= CASE_DIFF;\n-                    }\n-                    out.append(ch);\n-                    ch = Character.forDigit(b & 0xF, 16);\n-                    if (Character.isLetter(ch)) {\n-                        ch -= CASE_DIFF;\n-                    }\n-                    out.append(ch);\n+                    encodeByte(out, b);\n@@ -293,1 +360,0 @@\n-                needToChange = true;\n@@ -297,1 +363,1 @@\n-        return (needToChange? out.toString() : s);\n+        return out.toString();\n","filename":"src\/java.base\/share\/classes\/java\/net\/URLEncoder.java","additions":123,"deletions":57,"binary":false,"changes":180,"status":"modified"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.util;\n+\n+import jdk.internal.vm.annotation.ForceInline;\n+\n+\/**\n+ * Utility methods for encoding characters into UTF-8 byte sequences,\n+ *\n+ * <p>For example to writing a fast UTF-8 encoding loop:\n+ * {@snippet lang = java:\n+ *    for (int i = 0; i < s.length(); i++) {\n+ *        char c = s.charAt(i);\n+ *        if (UTF8EncodeUtils.isSingleByte(c)) {\n+ *            \/\/ handle single byte\n+ *        } else if (UTF8EncodeUtils.isDoubleBytes(c)) {\n+ *            byte[] bytes = UTF8EncodeUtils.encodeDoubleBytes(c);\n+ *            \/\/ handle double bytes\n+ *        } else if (Character.isSurrogate(c)) {\n+ *            if (i < s.length() - 1) {\n+ *                char d = s.charAt(i + 1);\n+ *                if (Character.isLowSurrogate(d)) {\n+ *                    int uc = Character.toCodePoint(c, d);\n+ *                    byte[] bytes = UTF8EncodeUtils.encodeCodePoint(uc);\n+ *\n+ *                    \/\/ handle four bytes\n+ *\n+ *                    i++;\n+ *                    continue;\n+ *                }\n+ *            }\n+ *            \/\/ handle unmappable char\n+ *        } else {\n+ *            byte[] bytes = UTF8EncodeUtils.encodeThreeBytes(c);\n+ *            \/\/ handle three bytes\n+ *        }\n+ *    }\n+ * }\n+ * @since 22\n+ *\/\n+public class UTF8EncodeUtils {\n+\n+    public static boolean isSingleByte(char c) {\n+        return c < 0x80;\n+    }\n+\n+    public static boolean isDoubleBytes(char c) {\n+        return c < 0x800;\n+    }\n+\n+    @ForceInline\n+    public static byte[] encodeDoubleBytes(char c) {\n+        byte b0 = (byte) (0xc0 | (c >> 6));\n+        byte b1 = (byte) (0x80 | (c & 0x3f));\n+        return new byte[]{b0, b1};\n+    }\n+\n+    @ForceInline\n+    public static byte[] encodeThreeBytes(char c) {\n+        byte b0 = (byte) (0xe0 | (c >> 12));\n+        byte b1 = (byte) (0x80 | ((c >> 6) & 0x3f));\n+        byte b2 = (byte) (0x80 | (c & 0x3f));\n+        return new byte[]{b0, b1, b2};\n+    }\n+\n+    @ForceInline\n+    public static byte[] encodeCodePoint(int uc) {\n+        byte b0 = (byte) (0xf0 | ((uc >> 18)));\n+        byte b1 = (byte) (0x80 | ((uc >> 12) & 0x3f));\n+        byte b2 = (byte) (0x80 | ((uc >> 6) & 0x3f));\n+        byte b3 = (byte) (0x80 | (uc & 0x3f));\n+        return new byte[]{b0, b1, b2, b3};\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/UTF8EncodeUtils.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- *\n+ * @run junit SurrogatePairs\n@@ -32,2 +32,9 @@\n-import java.io.*;\n-import java.net.*;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.net.URLDecoder;\n+import java.net.URLEncoder;\n+import java.util.stream.Collectors;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -43,29 +50,17 @@\n-    static String[] testStrings = {\"\\uD800\\uDC00\",\n-                                   \"\\uD800\\uDFFF\",\n-                                   \"\\uDBFF\\uDC00\",\n-                                   \"\\uDBFF\\uDFFF\",\n-                                   \"1\\uDBFF\\uDC00\",\n-                                   \"@\\uDBFF\\uDC00\",\n-                                   \"\\uDBFF\\uDC001\",\n-                                   \"\\uDBFF\\uDC00@\",\n-                                   \"\\u0101\\uDBFF\\uDC00\",\n-                                   \"\\uDBFF\\uDC00\\u0101\"\n-    };\n-\n-    static String[] correctEncodings = {\"%F0%90%80%80\",\n-                                        \"%F0%90%8F%BF\",\n-                                        \"%F4%8F%B0%80\",\n-                                        \"%F4%8F%BF%BF\",\n-                                        \"1%F4%8F%B0%80\",\n-                                        \"%40%F4%8F%B0%80\",\n-                                        \"%F4%8F%B0%801\",\n-                                        \"%F4%8F%B0%80%40\",\n-                                        \"%C4%81%F4%8F%B0%80\",\n-                                        \"%F4%8F%B0%80%C4%81\"\n-    };\n-\n-    public static void main(String[] args) throws Exception {\n-\n-        for (int i=0; i < testStrings.length; i++) {\n-            test(testStrings[i], correctEncodings[i]);\n-        }\n+    public static String[][] arguments() {\n+        return new String[][] {\n+                {\"\\uD800\\uDC00\", \"%F0%90%80%80\"},\n+                {\"\\uD800\\uDFFF\", \"%F0%90%8F%BF\"},\n+                {\"\\uDBFF\\uDC00\", \"%F4%8F%B0%80\"},\n+                {\"\\uDBFF\\uDFFF\", \"%F4%8F%BF%BF\"},\n+                {\"1\\uDBFF\\uDC00\", \"1%F4%8F%B0%80\"},\n+                {\"@\\uDBFF\\uDC00\", \"%40%F4%8F%B0%80\"},\n+                {\"\\uDBFF\\uDC001\", \"%F4%8F%B0%801\"},\n+                {\"\\uDBFF\\uDC00@\", \"%F4%8F%B0%80%40\"},\n+                {\"\\u0101\\uDBFF\\uDC00\", \"%C4%81%F4%8F%B0%80\"},\n+                {\"\\uDBFF\\uDC00\\u0101\", \"%F4%8F%B0%80%C4%81\"},\n+                {\"\\uDE0A\\uD83D\", \"%3F%3F\"},\n+                {\"1\\uDE0A\\uD83D\", \"1%3F%3F\"},\n+                {\"@\\uDE0A\\uD83D\", \"%40%3F%3F\"},\n+                {\"1@1\\uDE0A\\uD800\\uDC00 \\uD83D\", \"1%401%3F%F0%90%80%80+%3F\"}\n+        };\n@@ -74,28 +69,13 @@\n-    private static void test(String str, String correctEncoding)\n-        throws Exception {\n-\n-        System.out.println(\"Unicode bytes of test string are: \"\n-                           + getHexBytes(str));\n-\n-        String encoded = URLEncoder.encode(str, \"UTF-8\");\n-\n-        System.out.println(\"URLEncoding is: \" + encoded);\n-\n-        if (encoded.equals(correctEncoding))\n-            System.out.println(\"The encoding is correct!\");\n-        else {\n-            throw new Exception(\"The encoding is incorrect!\" +\n-                                \" It should be \" + correctEncoding);\n-        }\n-\n-        String decoded = URLDecoder.decode(encoded, \"UTF-8\");\n-\n-        System.out.println(\"Unicode bytes for URLDecoding are: \"\n-                           + getHexBytes(decoded));\n-\n-        if (str.equals(decoded))\n-            System.out.println(\"The decoding is correct\");\n-        else {\n-            throw new Exception(\"The decoded is not equal to the original\");\n-        }\n-        System.out.println(\"---\");\n+    @ParameterizedTest\n+    @MethodSource(\"arguments\")\n+    public void test(String str, String correctEncoding) {\n+        String encoded = URLEncoder.encode(str, UTF_8);\n+        assertEquals(correctEncoding, encoded, () ->\n+                \"str=%s, expected=%s, actual=%s\"\n+                        .formatted(escape(str), escape(correctEncoding), escape(encoded)));\n+\n+        \/\/ Map unmappable characters to '?'\n+        String cleanStr = new String(str.getBytes(UTF_8), UTF_8);\n+        String decoded = URLDecoder.decode(encoded, UTF_8);\n+        assertEquals(cleanStr, decoded, () ->\n+                \"expected=%s, actual=%s\".formatted(escape(str), escape(decoded)));\n@@ -104,19 +84,3 @@\n-    private static String getHexBytes(String s) throws Exception {\n-        StringBuffer sb = new StringBuffer();\n-        for (int i = 0; i < s.length(); i++) {\n-\n-            int a = s.charAt(i);\n-            int b1 = (a >>8) & 0xff;\n-            int b2 = (byte)a;\n-            int b11 = (b1>>4) & 0x0f;\n-            int b12 = b1 & 0x0f;\n-            int b21 = (b2 >>4) & 0x0f;\n-            int b22 = b2 & 0x0f;\n-\n-            sb.append(Integer.toHexString(b11));\n-            sb.append(Integer.toHexString(b12));\n-            sb.append(Integer.toHexString(b21));\n-            sb.append(Integer.toHexString(b22));\n-            sb.append(' ');\n-        }\n-        return sb.toString();\n+    private static String escape(String s) {\n+        return s.chars().mapToObj(c -> String.format(\"\\\\u%04x\", c))\n+                .collect(Collectors.joining());\n@@ -124,1 +88,0 @@\n-\n","filename":"test\/jdk\/java\/net\/URLEncoder\/SurrogatePairs.java","additions":44,"deletions":81,"binary":false,"changes":125,"status":"modified"}]}