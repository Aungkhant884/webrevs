{"files":[{"patch":"@@ -274,1 +274,1 @@\n-            if (c < 0x80) {\n+            if (UTF8EncodeUtils.isSingleByte(c)) {\n@@ -283,6 +283,6 @@\n-            } else if (c < 0x800) {\n-                int bytes = UTF8EncodeUtils.encodeDoubleBytes(c);\n-                encodeByte(out, (byte) (bytes >>> 8));\n-                encodeByte(out, (byte) (bytes & 0xff));\n-            } else if (Character.isHighSurrogate(c)) {\n-                if (i < s.length() - 1) {\n+            } else if (UTF8EncodeUtils.isDoubleBytes(c)) {\n+                byte[] bytes = UTF8EncodeUtils.encodeDoubleBytes(c);\n+                encodeByte(out, bytes[0]);\n+                encodeByte(out, bytes[1]);\n+            } else if (Character.isSurrogate(c)) {\n+                if (Character.isHighSurrogate(c) && i < s.length() - 1) {\n@@ -292,5 +292,5 @@\n-                        int bytes = UTF8EncodeUtils.encodeCodePoint(uc);\n-                        encodeByte(out, (byte) ((bytes >>> 24) & 0xff));\n-                        encodeByte(out, (byte) ((bytes >>> 16) & 0xff));\n-                        encodeByte(out, (byte) ((bytes >>> 8) & 0xff));\n-                        encodeByte(out, (byte) ((bytes) & 0xff));\n+                        byte[] bytes = UTF8EncodeUtils.encodeCodePoint(uc);\n+                        encodeByte(out, bytes[0]);\n+                        encodeByte(out, bytes[1]);\n+                        encodeByte(out, bytes[2]);\n+                        encodeByte(out, bytes[3]);\n@@ -305,4 +305,4 @@\n-                int bytes = UTF8EncodeUtils.encodeThreeBytes(c);\n-                encodeByte(out, (byte) ((bytes >>> 16) & 0xff));\n-                encodeByte(out, (byte) ((bytes >>> 8) & 0xff));\n-                encodeByte(out, (byte) ((bytes) & 0xff));\n+                byte[] bytes = UTF8EncodeUtils.encodeThreeBytes(c);\n+                encodeByte(out, bytes[0]);\n+                encodeByte(out, bytes[1]);\n+                encodeByte(out, bytes[2]);\n","filename":"src\/java.base\/share\/classes\/java\/net\/URLEncoder.java","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -1,105 +1,96 @@\n-\/*\r\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\r\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\r\n- *\r\n- * This code is free software; you can redistribute it and\/or modify it\r\n- * under the terms of the GNU General Public License version 2 only, as\r\n- * published by the Free Software Foundation.  Oracle designates this\r\n- * particular file as subject to the \"Classpath\" exception as provided\r\n- * by Oracle in the LICENSE file that accompanied this code.\r\n- *\r\n- * This code is distributed in the hope that it will be useful, but WITHOUT\r\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\r\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\r\n- * version 2 for more details (a copy is included in the LICENSE file that\r\n- * accompanied this code).\r\n- *\r\n- * You should have received a copy of the GNU General Public License version\r\n- * 2 along with this work; if not, write to the Free Software Foundation,\r\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\r\n- *\r\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\r\n- * or visit www.oracle.com if you need additional information or have any\r\n- * questions.\r\n- *\/\r\n-package jdk.internal.util;\r\n-\r\n-import jdk.internal.vm.annotation.ForceInline;\r\n-\r\n-\/**\r\n- * Utility methods for encoding characters into UTF-8 byte sequences,\r\n- *\r\n- * <p>For example to writing a fast UTF-8 encoding loop:\r\n- * {@snippet lang = java:\r\n- *    for (int i = 0; i < s.length(); i++) {\r\n- *        char c = s.charAt(i);\r\n- *        if (UTF8EncodeUtils.isSingleByte(c)) {\r\n- *            \/\/ handle single byte\r\n- *        } else if (UTF8EncodeUtils.isDoubleBytes(c)) {\r\n- *            int bytes = UTF8EncodeUtils.encodeDoubleBytes(c);\r\n- *            byte b0 = (byte) (bytes >>> 8);\r\n- *            byte b1 = (byte) (bytes & 0xff);\r\n- *            \/\/ handle double bytes\r\n- *        } else if (Character.isSurrogate(c)) {\r\n- *            if (i < s.length() - 1) {\r\n- *                char d = s.charAt(i + 1);\r\n- *                if (Character.isLowSurrogate(d)) {\r\n- *                    int uc = Character.toCodePoint(c, d);\r\n- *                    int bytes = UTF8EncodeUtils.encodeCodePoint(uc);\r\n- *                    byte b0 = (byte) ((bytes >>> 24) & 0xff);\r\n- *                    byte b1 = (byte) ((bytes >>> 16) & 0xff);\r\n- *                    byte b2 = (byte) ((bytes >>> 8) & 0xff);\r\n- *                    byte b3 = (byte) ((bytes) & 0xff);\r\n- *\r\n- *                    \/\/ handle four bytes\r\n- *\r\n- *                    i++;\r\n- *                    continue;\r\n- *                }\r\n- *            }\r\n- *            \/\/ handle unmappable char\r\n- *        } else {\r\n- *            int bytes = UTF8EncodeUtils.encodeThreeBytes(c);\r\n- *            byte b0 = (byte) ((bytes >>> 16) & 0xff);\r\n- *            byte b1 = (byte) ((bytes >>> 8) & 0xff);\r\n- *            byte b2 = (byte) ((bytes) & 0xff);\r\n- *            \/\/ handle three bytes\r\n- *        }\r\n- *    }\r\n- * }\r\n- * @since 22\r\n- *\/\r\n-public class UTF8EncodeUtils {\r\n-\r\n-    public static boolean isSingleByte(char c) {\r\n-        return c < 0x80;\r\n-    }\r\n-\r\n-    public static boolean isDoubleBytes(char c) {\r\n-        return c < 0x800;\r\n-    }\r\n-\r\n-    @ForceInline\r\n-    public static int encodeDoubleBytes(char c) {\r\n-        byte b0 = (byte) (0xc0 | (c >> 6));\r\n-        byte b1 = (byte) (0x80 | (c & 0x3f));\r\n-        return (b0 << 8) | (b1 & 0xff);\r\n-    }\r\n-\r\n-    @ForceInline\r\n-    public static int encodeThreeBytes(char c) {\r\n-        byte b0 = (byte) (0xe0 | c >> 12);\r\n-        byte b1 = (byte) (0x80 | c >> 6 & 0x3f);\r\n-        byte b2 = (byte) (0x80 | c & 0x3f);\r\n-        return (b0 << 16) | ((b1 & 0xff) << 8) | (b2 & 0xff);\r\n-    }\r\n-\r\n-    @ForceInline\r\n-    public static int encodeCodePoint(int uc) {\r\n-        byte b0 = (byte) (0xf0 | ((uc >> 18)));\r\n-        byte b1 = (byte) (0x80 | ((uc >> 12) & 0x3f));\r\n-        byte b2 = (byte) (0x80 | ((uc >> 6) & 0x3f));\r\n-        byte b3 = (byte) (0x80 | (uc & 0x3f));\r\n-        return (b0 << 24) | ((b1 & 0xff) << 16) | ((b2 & 0xff) << 8) | (b3 & 0xff);\r\n-    }\r\n-}\r\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.util;\n+\n+import jdk.internal.vm.annotation.ForceInline;\n+\n+\/**\n+ * Utility methods for encoding characters into UTF-8 byte sequences,\n+ *\n+ * <p>For example to writing a fast UTF-8 encoding loop:\n+ * {@snippet lang = java:\n+ *    for (int i = 0; i < s.length(); i++) {\n+ *        char c = s.charAt(i);\n+ *        if (UTF8EncodeUtils.isSingleByte(c)) {\n+ *            \/\/ handle single byte\n+ *        } else if (UTF8EncodeUtils.isDoubleBytes(c)) {\n+ *            byte[] bytes = UTF8EncodeUtils.encodeDoubleBytes(c);\n+ *            \/\/ handle double bytes\n+ *        } else if (Character.isSurrogate(c)) {\n+ *            if (i < s.length() - 1) {\n+ *                char d = s.charAt(i + 1);\n+ *                if (Character.isLowSurrogate(d)) {\n+ *                    int uc = Character.toCodePoint(c, d);\n+ *                    byte[] bytes = UTF8EncodeUtils.encodeCodePoint(uc);\n+ *\n+ *                    \/\/ handle four bytes\n+ *\n+ *                    i++;\n+ *                    continue;\n+ *                }\n+ *            }\n+ *            \/\/ handle unmappable char\n+ *        } else {\n+ *            byte[] bytes = UTF8EncodeUtils.encodeThreeBytes(c);\n+ *            \/\/ handle three bytes\n+ *        }\n+ *    }\n+ * }\n+ * @since 22\n+ *\/\n+public class UTF8EncodeUtils {\n+\n+    public static boolean isSingleByte(char c) {\n+        return c < 0x80;\n+    }\n+\n+    public static boolean isDoubleBytes(char c) {\n+        return c < 0x800;\n+    }\n+\n+    @ForceInline\n+    public static byte[] encodeDoubleBytes(char c) {\n+        byte b0 = (byte) (0xc0 | (c >> 6));\n+        byte b1 = (byte) (0x80 | (c & 0x3f));\n+        return new byte[]{b0, b1};\n+    }\n+\n+    @ForceInline\n+    public static byte[] encodeThreeBytes(char c) {\n+        byte b0 = (byte) (0xe0 | (c >> 12));\n+        byte b1 = (byte) (0x80 | ((c >> 6) & 0x3f));\n+        byte b2 = (byte) (0x80 | (c & 0x3f));\n+        return new byte[]{b0, b1, b2};\n+    }\n+\n+    @ForceInline\n+    public static byte[] encodeCodePoint(int uc) {\n+        byte b0 = (byte) (0xf0 | ((uc >> 18)));\n+        byte b1 = (byte) (0x80 | ((uc >> 12) & 0x3f));\n+        byte b2 = (byte) (0x80 | ((uc >> 6) & 0x3f));\n+        byte b3 = (byte) (0x80 | (uc & 0x3f));\n+        return new byte[]{b0, b1, b2, b3};\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/UTF8EncodeUtils.java","additions":96,"deletions":105,"binary":false,"changes":201,"status":"modified"}]}