{"files":[{"patch":"@@ -112,3 +112,3 @@\n-                                                      Deoptimization::DeoptReason reason, int opcode,\n-                                                      bool if_cont_is_true_proj, Node_List* old_new,\n-                                                      UnswitchingAction unswitching_action) {\n+                                                      Deoptimization::DeoptReason reason,\n+                                                      const int opcode, const bool rewire_uncommon_proj_phi_inputs,\n+                                                      const bool if_cont_is_true_proj) {\n@@ -199,14 +199,13 @@\n-      if (unswitching_action == UnswitchingAction::FastLoopCloning\n-          && !phi_input->is_CFG() && !phi_input->is_Phi() && get_ctrl(phi_input) == uncommon_proj) {\n-        \/\/ There are some control dependent nodes on the uncommon projection and we are currently copying predicates\n-        \/\/ to the fast loop in loop unswitching (first step, slow loop is processed afterwards). For the fast loop,\n-        \/\/ we need to clone all the data nodes in the chain from the phi ('use') up until the node whose control input\n-        \/\/ is the uncommon_proj. The slow loop can reuse the old data nodes and thus only needs to update the control\n-        \/\/ input to the uncommon_proj (done on the next invocation of this method when 'unswitch_is_slow_loop' is true.\n-        assert(LoopUnswitching, \"sanity check\");\n-        phi_input = clone_data_nodes_for_fast_loop(phi_input, uncommon_proj, if_uct, old_new);\n-      } else if (unswitching_action == UnswitchingAction::SlowLoopRewiring) {\n-        \/\/ Replace phi input for the old predicate path with TOP as the predicate is dying anyways. This avoids the need\n-        \/\/ to clone the data nodes again for the slow loop.\n-        assert(LoopUnswitching, \"sanity check\");\n-        _igvn.replace_input_of(use, proj_index, C->top());\n+\n+      if (uncommon_proj->outcnt() > 1 && !phi_input->is_CFG() && !phi_input->is_Phi() && get_ctrl(phi_input) == uncommon_proj) {\n+        \/\/ There are some control dependent nodes on the uncommon projection. We cannot simply reuse these data nodes.\n+        \/\/ We either need to rewire them from the old uncommon projection to the newly created uncommon proj (if the old\n+        \/\/ If is dying) or clone them and update their control (if the old If is not dying).\n+        if (rewire_uncommon_proj_phi_inputs) {\n+          \/\/ Replace phi input for the old uncommon projection with TOP as the If is dying anyways. Reuse the old data\n+          \/\/ nodes by simply updating control inputs and ctrl.\n+          _igvn.replace_input_of(use, proj_index, C->top());\n+          set_ctrl_of_nodes_with_same_ctrl(phi_input, uncommon_proj, if_uct);\n+        } else {\n+          phi_input = clone_nodes_with_same_ctrl(phi_input, uncommon_proj, if_uct);\n+        }\n@@ -219,13 +218,0 @@\n-  if (unswitching_action == UnswitchingAction::SlowLoopRewiring) {\n-    \/\/ Rewire the control dependent data nodes for the slow loop from the old to the new uncommon projection.\n-    assert(uncommon_proj->outcnt() > 1 && old_new == NULL, \"sanity\");\n-    for (DUIterator_Fast jmax, j = uncommon_proj->fast_outs(jmax); j < jmax; j++) {\n-      Node* data = uncommon_proj->fast_out(j);\n-      if (!data->is_CFG()) {\n-        _igvn.replace_input_of(data, 0, if_uct);\n-        set_ctrl(data, if_uct);\n-        --j;\n-        --jmax;\n-      }\n-    }\n-  }\n@@ -243,13 +229,20 @@\n-\/\/ Clone data nodes for the fast loop while creating a new If with create_new_if_for_predicate. Returns the node which is\n-\/\/ used for the uncommon trap phi input.\n-Node* PhaseIdealLoop::clone_data_nodes_for_fast_loop(Node* phi_input, ProjNode* uncommon_proj, Node* if_uct, Node_List* old_new) {\n-  \/\/ Step 1: Clone all nodes on the data chain but do not rewire anything, yet. Keep track of the cloned nodes\n-  \/\/ by using the old_new mapping. This mapping is then used in step 2 to rewire the cloned nodes accordingly.\n-  DEBUG_ONLY(uint last_idx = C->unique();)\n-  Unique_Node_List list;\n-  list.push(phi_input);\n-  for (uint j = 0; j < list.size(); j++) {\n-    Node* next = list.at(j);\n-    Node* clone = next->clone();\n-    _igvn.register_new_node_with_optimizer(clone);\n-    old_new->map(next->_idx, clone);\n+\/\/ Update ctrl and control inputs of all data nodes starting from 'node' to 'new_ctrl' which have 'old_ctrl' as\n+\/\/ current ctrl.\n+void PhaseIdealLoop::set_ctrl_of_nodes_with_same_ctrl(Node* node, ProjNode* old_ctrl, Node* new_ctrl) {\n+  ResourceMark rm;\n+  Unique_Node_List nodes_with_same_ctrl = find_nodes_with_same_ctrl(node, old_ctrl);\n+  for (uint j = 0; j < nodes_with_same_ctrl.size(); j++) {\n+    Node* next = nodes_with_same_ctrl[j];\n+    if (next->in(0) == old_ctrl) {\n+      _igvn.replace_input_of(next, 0, new_ctrl);\n+    }\n+    set_ctrl(next, new_ctrl);\n+  }\n+}\n+\n+\/\/ Recursively find all input nodes with the same ctrl.\n+Unique_Node_List PhaseIdealLoop::find_nodes_with_same_ctrl(Node* node, const ProjNode* ctrl) {\n+  Unique_Node_List nodes_with_same_ctrl;\n+  nodes_with_same_ctrl.push(node);\n+  for (uint j = 0; j < nodes_with_same_ctrl.size(); j++) {\n+    Node* next = nodes_with_same_ctrl[j];\n@@ -258,2 +251,2 @@\n-      if (!in->is_Phi() && get_ctrl(in) == uncommon_proj) {\n-        list.push(in);\n+      if (!in->is_Phi() && get_ctrl(in) == ctrl) {\n+        nodes_with_same_ctrl.push(in);\n@@ -263,0 +256,2 @@\n+  return nodes_with_same_ctrl;\n+}\n@@ -264,6 +259,33 @@\n-  \/\/ Step 2: All nodes are cloned. Rewire them by using the old_new mapping.\n-  for (uint j = 0; j < list.size(); j++) {\n-    Node* next = list.at(j);\n-    Node* clone = old_new->at(next->_idx);\n-    assert(clone != NULL && clone->_idx >= last_idx, \"must exist and be a proper clone\");\n-    if (next->in(0) == uncommon_proj) {\n+\/\/ Clone all nodes with the same ctrl as 'old_ctrl' starting from 'node' by following its inputs. Rewire the cloned nodes\n+\/\/ to 'new_ctrl'. Returns the clone of 'node'.\n+Node* PhaseIdealLoop::clone_nodes_with_same_ctrl(Node* node, ProjNode* old_ctrl, Node* new_ctrl) {\n+  ResourceMark rm;\n+  DEBUG_ONLY(uint last_idx = C->unique();)\n+  Unique_Node_List nodes_with_same_ctrl = find_nodes_with_same_ctrl(node, old_ctrl);\n+  Dict old_new_mapping = clone_nodes(nodes_with_same_ctrl); \/\/ Cloned but not rewired, yet\n+  rewire_cloned_nodes_to_ctrl(old_ctrl, new_ctrl, nodes_with_same_ctrl, old_new_mapping);\n+  Node* clone_phi_input = static_cast<Node*>(old_new_mapping[node]);\n+  assert(clone_phi_input != NULL && clone_phi_input->_idx >= last_idx, \"must exist and be a proper clone\");\n+  return clone_phi_input;\n+}\n+\n+\/\/ Clone all the nodes on 'list_to_clone' and return an old->new mapping.\n+Dict PhaseIdealLoop::clone_nodes(const Node_List& list_to_clone) {\n+  Dict old_new_mapping(cmpkey, hashkey);\n+  for (uint i = 0; i < list_to_clone.size(); i++) {\n+    Node* next = list_to_clone[i];\n+    Node* clone = next->clone();\n+    _igvn.register_new_node_with_optimizer(clone);\n+    old_new_mapping.Insert(next, clone);\n+  }\n+  return old_new_mapping;\n+}\n+\n+\/\/ Rewire inputs of the unprocessed cloned nodes (inputs are not updated, yet, and still point to the old nodes) by\n+\/\/ using the old_new_mapping.\n+void PhaseIdealLoop::rewire_cloned_nodes_to_ctrl(const ProjNode* old_ctrl, Node* new_ctrl,\n+                                                 const Node_List& nodes_with_same_ctrl, const Dict& old_new_mapping) {\n+  for (uint i = 0; i < nodes_with_same_ctrl.size(); i++) {\n+    Node* next = nodes_with_same_ctrl[i];\n+    Node* clone = static_cast<Node*>(old_new_mapping[next]);\n+    if (next->in(0) == old_ctrl) {\n@@ -272,2 +294,2 @@\n-      _igvn.replace_input_of(clone, 0, if_uct);\n-      set_ctrl(clone, if_uct);\n+      _igvn.replace_input_of(clone, 0, new_ctrl);\n+      set_ctrl(clone, new_ctrl);\n@@ -275,0 +297,3 @@\n+    rewire_inputs_of_clones_to_clones(new_ctrl, clone, old_new_mapping, next);\n+  }\n+}\n@@ -276,11 +301,11 @@\n-    \/\/ Rewire the inputs of the cloned nodes to the old nodes to the new clones.\n-    for (uint k = 1; k < next->req(); k++) {\n-      Node* in = next->in(k);\n-      if (!in->is_Phi()) {\n-        assert(!in->is_CFG(), \"must be data node\");\n-        Node* in_clone = old_new->at(in->_idx);\n-        if (in_clone != NULL) {\n-          assert(in_clone->_idx >= last_idx, \"must be a valid clone\");\n-          _igvn.replace_input_of(clone, k, in_clone);\n-          set_ctrl(clone, if_uct);\n-        }\n+\/\/ Rewire the inputs of the cloned nodes to the old nodes to the new clones.\n+void PhaseIdealLoop::rewire_inputs_of_clones_to_clones(Node* new_ctrl, Node* clone, const Dict& old_new_mapping,\n+                                                       const Node* next) {\n+  for (uint i = 1; i < next->req(); i++) {\n+    Node* in = next->in(i);\n+    if (!in->is_Phi()) {\n+      assert(!in->is_CFG(), \"must be data node\");\n+      Node* in_clone = static_cast<Node*>(old_new_mapping[in]);\n+      if (in_clone != NULL) {\n+        _igvn.replace_input_of(clone, i, in_clone);\n+        set_ctrl(clone, new_ctrl);\n@@ -290,3 +315,0 @@\n-  Node* clone_phi_input = old_new->at(phi_input->_idx);\n-  assert(clone_phi_input != NULL && clone_phi_input->_idx >= last_idx, \"must exist and be a proper clone\");\n-  return clone_phi_input;\n@@ -294,0 +316,1 @@\n+\n@@ -296,8 +319,1 @@\n-                                                             Deoptimization::DeoptReason reason, Node_List* old_new) {\n-  UnswitchingAction unswitching_action;\n-  if (predicate_proj->other_if_proj()->outcnt() > 1) {\n-    \/\/ There are some data dependencies that need to be taken care of when cloning a predicate.\n-    unswitching_action = old_new == NULL ? UnswitchingAction::SlowLoopRewiring : UnswitchingAction::FastLoopCloning;\n-  } else {\n-    unswitching_action = UnswitchingAction::None;\n-  }\n+                                                             Deoptimization::DeoptReason reason, const bool slow_loop) {\n@@ -306,1 +322,1 @@\n-                                                             true, old_new, unswitching_action);\n+                                                             slow_loop);\n@@ -405,1 +421,2 @@\n-  ProjNode* proj = create_new_if_for_predicate(output_proj, NULL, reason, iff->Opcode(), predicate->is_IfTrue());\n+  ProjNode* proj = create_new_if_for_predicate(output_proj, NULL, reason, iff->Opcode(),\n+                                               false, predicate->is_IfTrue());\n@@ -438,2 +455,2 @@\n-    iffast_pred = clone_predicate_to_unswitched_loop(predicate_proj, iffast_pred, Deoptimization::Reason_predicate, &old_new);\n-    ifslow_pred = clone_predicate_to_unswitched_loop(predicate_proj, ifslow_pred, Deoptimization::Reason_predicate);\n+    iffast_pred = clone_predicate_to_unswitched_loop(predicate_proj, iffast_pred, Deoptimization::Reason_predicate,false);\n+    ifslow_pred = clone_predicate_to_unswitched_loop(predicate_proj, ifslow_pred, Deoptimization::Reason_predicate,true);\n@@ -447,2 +464,2 @@\n-    iffast_pred = clone_predicate_to_unswitched_loop(profile_predicate_proj, iffast_pred, Deoptimization::Reason_profile_predicate, &old_new);\n-    ifslow_pred = clone_predicate_to_unswitched_loop(profile_predicate_proj, ifslow_pred, Deoptimization::Reason_profile_predicate);\n+    iffast_pred = clone_predicate_to_unswitched_loop(profile_predicate_proj, iffast_pred,Deoptimization::Reason_profile_predicate, false);\n+    ifslow_pred = clone_predicate_to_unswitched_loop(profile_predicate_proj, ifslow_pred,Deoptimization::Reason_profile_predicate, true);\n@@ -458,2 +475,2 @@\n-    iffast_pred = clone_predicate_to_unswitched_loop(limit_check_proj, iffast_pred, Deoptimization::Reason_loop_limit_check, &old_new);\n-    ifslow_pred = clone_predicate_to_unswitched_loop(limit_check_proj, ifslow_pred, Deoptimization::Reason_loop_limit_check);\n+    iffast_pred = clone_predicate_to_unswitched_loop(limit_check_proj, iffast_pred,Deoptimization::Reason_loop_limit_check, false);\n+    ifslow_pred = clone_predicate_to_unswitched_loop(limit_check_proj, ifslow_pred,Deoptimization::Reason_loop_limit_check, true);\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":100,"deletions":83,"binary":false,"changes":183,"status":"modified"},{"patch":"@@ -1311,8 +1311,0 @@\n-\n-  \/\/ Enum to determine the action to be performed in create_new_if_for_predicate() when processing phis of UCT regions.\n-  enum class UnswitchingAction {\n-    None,            \/\/ No special action.\n-    FastLoopCloning, \/\/ Need to clone nodes for the fast loop.\n-    SlowLoopRewiring \/\/ Need to rewire nodes for the slow loop.\n-  };\n-\n@@ -1321,2 +1313,2 @@\n-                                        int opcode, bool if_cont_is_true_proj = true, Node_List* old_new = NULL,\n-                                        UnswitchingAction unswitching_action = UnswitchingAction::None);\n+                                        int opcode, bool rewire_uncommon_proj_phi_inputs = false,\n+                                        bool if_cont_is_true_proj = true);\n@@ -1324,2 +1316,9 @@\n-  \/\/ Clone data nodes for the fast loop while creating a new If with create_new_if_for_predicate.\n-  Node* clone_data_nodes_for_fast_loop(Node* phi_input, ProjNode* uncommon_proj, Node* if_uct, Node_List* old_new);\n+ private:\n+  \/\/ Helper functions for create_new_if_for_predicate()\n+  void set_ctrl_of_nodes_with_same_ctrl(Node* node, ProjNode* old_ctrl, Node* new_ctrl);\n+  Unique_Node_List find_nodes_with_same_ctrl(Node* node, const ProjNode* ctrl);\n+  Node* clone_nodes_with_same_ctrl(Node* node, ProjNode* old_ctrl, Node* new_ctrl);\n+  Dict clone_nodes(const Node_List& list_to_clone);\n+  void rewire_cloned_nodes_to_ctrl(const ProjNode* old_ctrl, Node* new_ctrl, const Node_List& nodes_with_same_ctrl,\n+                                   const Dict& old_new_mapping);\n+  void rewire_inputs_of_clones_to_clones(Node* new_ctrl, Node* clone, const Dict& old_new_mapping, const Node* next);\n@@ -1327,0 +1326,1 @@\n+ public:\n@@ -1643,2 +1643,2 @@\n-  ProjNode* clone_predicate_to_unswitched_loop(ProjNode* predicate_proj, Node* new_entry, Deoptimization::DeoptReason reason,\n-                                               Node_List* old_new = NULL);\n+  ProjNode* clone_predicate_to_unswitched_loop(ProjNode* predicate_proj, Node* new_entry,\n+                                               Deoptimization::DeoptReason reason, bool slow_loop);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -0,0 +1,408 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8290850\n+ * @summary Test cloning of pinned phi input nodes in create_new_if_for_predicate().\n+ * @run main\/othervm -Xcomp -XX:CompileCommand=compileonly,compiler.loopopts.TestCreateNewIfForPredicateCloning::*\n+ *                   compiler.loopopts.TestCreateNewIfForPredicateCloning\n+ *\/\n+\n+package compiler.loopopts;\n+\n+public class TestCreateNewIfForPredicateCloning {\n+    static int iFld, iFld2, iFld3, nonZero = 2, nonZero2 = 3;\n+    static boolean bFld = true, bFld2 = false;\n+    static int[] iArrFld = new int[100];\n+\n+    public static void main(String[] args) {\n+        try {\n+            testUnswitching();\n+            testLoopPredicatation();\n+            testLoopPredicatationComplex();\n+            testUnswitchingWithPredicates();\n+            testUnswitchingWithPredicatesDiv();\n+            testFuzzer1();\n+            testFuzzer2();\n+            testFuzzer3();\n+        } catch (Exception e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    \/\/ Test case for the already fixed problem in 8271954: Calling create_new_if_for_predicate in\n+    \/\/ clone_predicate_to_unswitched_loop(). This does not crash anymore. But still use it as sanity test here with the\n+    \/\/ new fix.\n+    static void testUnswitching() {\n+        int x = 3;\n+\n+        \/\/ Block to delay precise type information to after CCP.\n+        int limit = 2;\n+        int constantAfterCCP = 2;\n+        for (; limit < 4; limit *= 2);\n+        for (int i = 2; i < limit; i++) {\n+            constantAfterCCP = 6; \/\/ Only known to be constant 6 after CCP.\n+        }\n+\n+        for (int i = 51; i > 9; i -= 3) {\n+            if (bFld) {\n+                x *= 6;\n+            }\n+            \/\/ (1) after unswitching:\n+            \/\/ if (bFld) {...}\n+            \/\/ Since we have a back to back if now with the same condition, we can merge them together by using the\n+            \/\/ split if optimization. That will create phi nodes for the UCT regions. Whenever we then call\n+            \/\/ create_new_if_for_predicate(), we would just reuse the old phi input for the newly create uncommon trap\n+            \/\/ projection. This is done when unswitching again to clone the predicates to the fast and slow loop. But\n+            \/\/ in the meantime, we have sunk x out of the loop with CastII nodes which are pinned on the old uncommon\n+            \/\/ trap projections. Just reusing these data nodes on the new uncommon trap proj leads to a broken graph:\n+            \/\/ the LCA of the old and new uncommon projection would be above the early control (control input of the\n+            \/\/ CastII nodes).\n+            \/\/\n+            \/\/ 8271954 fixes this when calling create_new_if_for_predicate() in\n+            \/\/ clone_predicate_to_unswitched_loop().\n+            x -= 5;\n+\n+            for (int j = 1; j < 10; j++) {\n+                if (bFld) { \/\/ Unswitching on bFld such that this condition is moved to (1)\n+                    continue;\n+                }\n+                x = 34; \/\/ Redefine x such that x is only used in UCT before this loop after split if.\n+                int y = 34;\n+                if (constantAfterCCP == 2) {\n+                    \/\/ Known to be never taken after CCP, so y will always be 34.\n+                    y = 35;\n+                }\n+                if (y == iFld) { \/\/ Folds to 34 == iFld after CCP and trigger another unswitching\n+                    continue;\n+                }\n+                iFld3 = 34; \/\/ Just another statement sucht that the second round of unswitching is done\n+\n+            }\n+        }\n+\n+        \/\/ This loop is only needed to delay the second round of unswitching for the inner loop above.\n+        for (int i = 0; i < iArrFld.length; i++) {\n+            iArrFld[i] = 3;\n+        }\n+    }\n+\n+    \/\/ Similar to testUnswitching() but we are calling create_new_if_for_predicate in Loop Predication for:\n+    \/\/ - Creating hoised range check predicate and skeleton predicate\n+    \/\/ - Creating invariant check predicate\n+    \/\/ which leads to a crash.\n+    static void testLoopPredicatation() {\n+        int x = 3;\n+\n+        \/\/ Block to delay precise type information to after CCP.\n+        int limit = 2;\n+        int constantAfterCCP = 2;\n+        for (; limit < 4; limit *= 2);\n+        for (int i = 2; i < limit; i++) {\n+            constantAfterCCP = 6; \/\/ Only known to be constant 6 after CCP.\n+        }\n+\n+        for (int i = 51; i > 9; i -= 3) {\n+            if (bFld) {\n+                x *= 6;\n+            }\n+            \/\/ (1) after unswitching:\n+            \/\/ if (bFld) {...}\n+            \/\/ Since we have a back to back if now with the same condition, we can merge them together by using the\n+            \/\/ split if optimization. That will create phi nodes for the UCT regions. Whenever we then call\n+            \/\/ create_new_if_for_predicate(), we would just reuse the old phi input for the newly create uncommon trap\n+            \/\/ projection. This is done when unswitching again to clone the predicates to the fast and slow loop. But\n+            \/\/ in the meantime, we have sunk x out of the loop with CastII nodes which are pinned on the old uncommon\n+            \/\/ trap projections. Just reusing these data nodes on the new uncommon trap proj leads to a broken graph:\n+            \/\/ the LCA of the old and new uncommon projection would be above the early control (control input of the\n+            \/\/ CastII nodes).\n+            x -= 5;\n+\n+            for (int j = 1; j < 10; j++) {\n+                if (bFld) { \/\/ Unswitching on bFld such that this condition is moved to (1)\n+                    continue;\n+                }\n+                x = 34; \/\/ Redefine x such that x is only used in UCT before this loop after split if.\n+                int y = iArrFld[j]; \/\/ Range check and null check will be hoisted after Unswitching and split if.\n+            }\n+        }\n+\n+        \/\/ This loop is only needed to delay the second round of unswitching for the inner loop above.\n+        for (int i = 0; i < iArrFld.length; i++) {\n+            iArrFld[i] = 3;\n+        }\n+    }\n+\n+    \/\/ Similar to testLoopPredicatation() but we are adding some computations for x such that we sink more nodes which\n+    \/\/ need to be cloned when calling create_new_if_for_predicate().\n+    static void testLoopPredicatationComplex() {\n+        int x = 3;\n+\n+        \/\/ Block to delay precise type information to after CCP.\n+        int limit = 2;\n+        int constantAfterCCP = 2;\n+        for (; limit < 4; limit *= 2);\n+        for (int i = 2; i < limit; i++) {\n+            constantAfterCCP = 6; \/\/ Only known to be constant 6 after CCP.\n+        }\n+\n+        for (int i = 51; i > 9; i -= 3) {\n+            if (bFld) {\n+                x *= 6;\n+            }\n+            \/\/ (1) after unswitching:\n+            \/\/ if (bFld) {...}\n+            \/\/ Since we have a back to back if now with the same condition, we can merge them together by using the\n+            \/\/ split if optimization. That will create phi nodes for the UCT regions. Whenever we then call\n+            \/\/ create_new_if_for_predicate(), we would just reuse the old phi input for the newly create uncommon trap\n+            \/\/ projection. This is done when unswitching again to clone the predicates to the fast and slow loop. But\n+            \/\/ in the meantime, we have sunk x out of the loop with CastII nodes which are pinned on the old uncommon\n+            \/\/ trap projections. Just reusing these data nodes on the new uncommon trap proj leads to a broken graph:\n+            \/\/ the LCA of the old and new uncommon projection would be above the early control (control input of the\n+            \/\/ CastII nodes).\n+            x -= 5;\n+\n+            \/\/ Add some more computations such that more nodes are sunk and therefore more nodes need to be cloned in\n+            \/\/ create_new_if_for_predicate().\n+            double d1 = 5 + (double) x;\n+            x = (int)((d1 + iFld2) - (d1 + iFld));\n+            d1 = 5 + (double) x;\n+            x = (int)((d1 + iFld2) - (d1 + iFld));\n+            d1 = 5 + (double) x;\n+            x = (int)((d1 + iFld2) - (d1 + iFld));\n+            d1 = 5 + (double) x;\n+            x = (int)((d1 + iFld2) - (d1 + iFld));\n+            d1 = 5 + (double) x;\n+            x = (int)((d1 + iFld2) - (d1 + iFld));\n+            d1 = 5 + (double) x;\n+            x = (int)((d1 + iFld2) - (d1 + iFld));\n+\n+            for (int j = 1; j < 10; j++) {\n+                if (bFld) { \/\/ Unswitching on bFld such that this condition is moved to (1)\n+                    continue;\n+                }\n+                x = 34; \/\/ Redefine x such that x is only used in UCT before this loop after split if.\n+                int y = iArrFld[j]; \/\/ Range check and null check will be hoisted after Unswitching and split if.\n+            }\n+        }\n+\n+        \/\/ This loop is only needed to delay the second round of unswitching for the inner loop above.\n+        for (int i = 0; i < iArrFld.length; i++) {\n+            iArrFld[i] = 3;\n+        }\n+    }\n+\n+    \/\/ Combination of testUnswitching() and testLoopPredicatation(): After creating predicates in loop predication,\n+    \/\/ we perform another round of loop unswitching where we additionally call create_new_if_for_predicate in\n+    \/\/ clone_skeleton_predicate_for_unswitched_loops() which currently leads to a crash.\n+    static void testUnswitchingWithPredicates() {\n+        int x = 3;\n+        if (iArrFld == null) {\n+            \/\/ Makes sure to get rid of null check for iArrFld to only create range check predicate\n+            return;\n+        }\n+        \/\/ Block to delay precise type information to after CCP.\n+        int limit = 2;\n+        int constantAfterCCP = 2;\n+        for (; limit < 4; limit *= 2);\n+        for (int i = 2; i < limit; i++) {\n+            constantAfterCCP = 6; \/\/ Only known to be constant 6 after CCP.\n+        }\n+\n+        for (int i = 51; i > 9; i -= 3) {\n+            if (bFld) {\n+                x *= 6;\n+            }\n+            \/\/ (1) after unswitching:\n+            \/\/ if (bFld) {...}\n+            \/\/ Since we have a back to back if now with the same condition, we can merge them together by using the\n+            \/\/ split if optimization. That will create phi nodes for the UCT regions. Whenever we then call\n+            \/\/ create_new_if_for_predicate(), we would just reuse the old phi input for the newly create uncommon trap\n+            \/\/ projection. This is done when unswitching again to clone the predicates to the fast and slow loop. But\n+            \/\/ in the meantime, we have sunk x out of the loop with CastII nodes which are pinned on the old uncommon\n+            \/\/ trap projections. Just reusing these data nodes on the new uncommon trap proj leads to a broken graph:\n+            \/\/ the LCA of the old and new uncommon projection would be above the early control (control input of the\n+            \/\/ CastII nodes).\n+            x -= 5;\n+\n+            for (int j = 1; j < 10; j++) {\n+                if (bFld) { \/\/ Unswitching on bFld such that this condition is moved to (1)\n+                    continue;\n+                }\n+                x = 34; \/\/ Redefine x such that x is only used in UCT before this loop after split if.\n+                int z = iArrFld[j]; \/\/ Range check and null check will be hoisted after Unswitching and split if.\n+                int y = 34;\n+                if (constantAfterCCP == 2) {\n+                    \/\/ Known to be never taken after CCP, so y will always be 34.\n+                    y = 35;\n+                }\n+                if (y == iFld) { \/\/ Folds to 34 == iFld after CCP and trigger another unswitching\n+                    continue;\n+                }\n+                iFld3 = 34; \/\/ Just another statement sucht that the second round of unswitching is done\n+            }\n+        }\n+\n+        \/\/ This loop is only needed to delay the second round of unswitching for the inner loop above.\n+        for (int i = 0; i < iArrFld.length; i++) {\n+            iArrFld[i] = 3;\n+        }\n+    }\n+\n+    \/\/ Same as testUnswitchingWithPredicates() but with a DivI node which has a control input which needs\n+    \/\/ to be rewired as well.\n+    static void testUnswitchingWithPredicatesDiv() {\n+        int x = 3;\n+        if (iArrFld == null) {\n+            \/\/ Makes sure to get rid of null check for iArrFld to only create range check predicate\n+            return;\n+        }\n+        \/\/ Block to delay precise type information to after CCP.\n+        int limit = 2;\n+        int constantAfterCCP = 2;\n+        for (; limit < 4; limit *= 2);\n+        for (int i = 2; i < limit; i++) {\n+            constantAfterCCP = 6; \/\/ Only known to be constant 6 after CCP.\n+        }\n+\n+        for (int i = 51; i > 9; i -= 3) {\n+            if (bFld) {\n+                x *= 6;\n+            }\n+            \/\/ (1) after unswitching:\n+            \/\/ if (bFld) {...}\n+            \/\/ Since we have a back to back if now with the same condition, we can merge them together by using the\n+            \/\/ split if optimization. That will create phi nodes for the UCT regions. Whenever we then call\n+            \/\/ create_new_if_for_predicate(), we would just reuse the old phi input for the newly create uncommon trap\n+            \/\/ projection. This is done when unswitching again to clone the predicates to the fast and slow loop. But\n+            \/\/ in the meantime, we have sunk x out of the loop with CastII nodes which are pinned on the old uncommon\n+            \/\/ trap projections. Just reusing these data nodes on the new uncommon trap proj leads to a broken graph:\n+            \/\/ the LCA of the old and new uncommon projection would be above the early control (control input of the\n+            \/\/ CastII nodes).\n+            x -= 5;\n+\n+            double d = 5.5f + (double) x;\n+            int a = (int)d;\n+            x = (a \/ nonZero) - (a \/ nonZero2);\n+\n+\n+            for (int j = 1; j < 10; j++) {\n+                if (bFld) { \/\/ Unswitching on bFld such that this condition is moved to (1)\n+                    continue;\n+                }\n+                x = 34; \/\/ Redefine x such that x is only used in UCT before this loop after split if.\n+                int z = iArrFld[j]; \/\/ Range check and null check will be hoisted after Unswitching and split if.\n+                int y = 34;\n+                if (constantAfterCCP == 2) {\n+                    \/\/ Known to be never taken after CCP, so y will always be 34.\n+                    y = 35;\n+                }\n+                if (y == iFld) { \/\/ Folds to 34 == iFld after CCP and trigger another unswitching\n+                    continue;\n+                }\n+                iFld3 = 34; \/\/ Just another statement sucht that the second round of unswitching is done\n+            }\n+        }\n+\n+        \/\/ This loop is only needed to delay the second round of unswitching for the inner loop above.\n+        for (int i = 0; i < iArrFld.length; i++) {\n+            iArrFld[i] = 3;\n+        }\n+    }\n+\n+    static void testFuzzer1() {\n+        int x = 0;\n+        int[] iArr = new int[400];\n+        boolean b = true;\n+        long[] lArr = new long[400];\n+        for (long l1 : lArr) {\n+            for (int i = 63; i > 1; i -= 3) {\n+                for (int j = 1; j < 4; j++) {\n+                    if (!b) {\n+                        x -= 5;\n+                    }\n+                }\n+                for (int j = 1; j < 4; j++) {\n+                    if (!b) {\n+                        x = iArr[j];\n+                    }\n+                    if (i == 0) {\n+                        l1 += 5;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    static void testFuzzer2() {\n+        int i, i1, i17 = 6, i18;\n+        short s1;\n+        boolean b2 = true;\n+        float f3;\n+        long lArr[][] = new long[400][];\n+        byte byArrFld[] = new byte[4];\n+        i = 1;\n+        do {\n+            for (i1 = 14; 6 < i1; i1--)\n+                ;\n+            i17 -= i18 = 1;\n+            while (i18 < 4) {\n+                i18 <<= i17 = 2;\n+                switch (i1) {\n+                    case 114:\n+                        s1 = byArrFld[1];\n+                        break;\n+                    case 116:\n+                        lArr[1][i18] = iFld;\n+                        if (b2)\n+                            continue;\n+                    case 118:\n+                        f3 = iFld;\n+                }\n+            }\n+            i++;\n+        } while (i < 10000);\n+    }\n+\n+    static void testFuzzer3() {\n+        int x = 8;\n+        int y = 4;\n+        for (int i : iArrFld) {\n+            x += 2;\n+            if (bFld) {\n+                x = 3;\n+            } else {\n+                y = 2;\n+            }\n+            for (int j = 0; j < 10; j++) {\n+                x = 0;\n+                y += 5;\n+                if (!bFld) {\n+                    iArrFld[1] = 5;\n+                }\n+            }\n+        }\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestCreateNewIfForPredicateCloning.java","additions":408,"deletions":0,"binary":false,"changes":408,"status":"added"}]}