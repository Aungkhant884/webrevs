{"files":[{"patch":"@@ -29,1 +29,0 @@\n-#include \"gc\/shared\/space.inline.hpp\"\n@@ -37,8 +36,3 @@\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\/\/ BlockOffsetSharedArray\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-BlockOffsetSharedArray::BlockOffsetSharedArray(MemRegion reserved,\n-                                               size_t init_word_size):\n-  _reserved(reserved), _end(nullptr)\n-{\n+SerialBlockOffsetSharedArray::SerialBlockOffsetSharedArray(MemRegion reserved,\n+                                                           size_t init_word_size):\n+  _reserved(reserved) {\n@@ -56,1 +50,1 @@\n-  _offset_array = (u_char*)_vs.low_boundary();\n+  _offset_array = (uint8_t*)_vs.low_boundary();\n@@ -58,1 +52,1 @@\n-  log_trace(gc, bot)(\"BlockOffsetSharedArray::BlockOffsetSharedArray: \");\n+  log_trace(gc, bot)(\"SerialBlockOffsetSharedArray::SerialBlockOffsetSharedArray: \");\n@@ -65,1 +59,1 @@\n-void BlockOffsetSharedArray::resize(size_t new_word_size) {\n+void SerialBlockOffsetSharedArray::resize(size_t new_word_size) {\n@@ -71,1 +65,0 @@\n-  _end = _reserved.start() + new_word_size;\n@@ -76,1 +69,0 @@\n-      \/\/ Do better than this for Merlin\n@@ -88,104 +80,55 @@\n-bool BlockOffsetSharedArray::is_card_boundary(HeapWord* p) const {\n-  assert(p >= _reserved.start(), \"just checking\");\n-  size_t delta = pointer_delta(p, _reserved.start());\n-  return (delta & right_n_bits((int)BOTConstants::log_card_size_in_words())) == (size_t)NoBits;\n-}\n-\n-\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\/\/ BlockOffsetArray\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-BlockOffsetArray::BlockOffsetArray(BlockOffsetSharedArray* array,\n-                                   MemRegion mr, bool init_to_zero_) :\n-  BlockOffsetTable(mr.start(), mr.end()),\n-  _array(array)\n-{\n-  assert(_bottom <= _end, \"arguments out of order\");\n-  set_init_to_zero(init_to_zero_);\n-  if (!init_to_zero_) {\n-    \/\/ initialize cards to point back to mr.start()\n-    set_remainder_to_point_to_start(mr.start() + BOTConstants::card_size_in_words(), mr.end());\n-    _array->set_offset_array(0, 0);  \/\/ set first card to 0\n-  }\n-}\n-\n-\n-\/\/ The arguments follow the normal convention of denoting\n-\/\/ a right-open interval: [start, end)\n-void\n-BlockOffsetArray::\n-set_remainder_to_point_to_start(HeapWord* start, HeapWord* end, bool reducing) {\n-\n-  check_reducing_assertion(reducing);\n-  if (start >= end) {\n-    \/\/ The start address is equal to the end address (or to\n-    \/\/ the right of the end address) so there are not cards\n-    \/\/ that need to be updated..\n-    return;\n-  }\n-\n-  \/\/ Write the backskip value for each region.\n-  \/\/\n-  \/\/    offset\n-  \/\/    card             2nd                       3rd\n-  \/\/     | +- 1st        |                         |\n-  \/\/     v v             v                         v\n-  \/\/    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+     +-+-+-+-+-+-+-+-+-+-+-\n-  \/\/    |x|0|0|0|0|0|0|0|1|1|1|1|1|1| ... |1|1|1|1|2|2|2|2|2|2| ...\n-  \/\/    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+     +-+-+-+-+-+-+-+-+-+-+-\n-  \/\/    11              19                        75\n-  \/\/      12\n-  \/\/\n-  \/\/    offset card is the card that points to the start of an object\n-  \/\/      x - offset value of offset card\n-  \/\/    1st - start of first logarithmic region\n-  \/\/      0 corresponds to logarithmic value N_words + 0 and 2**(3 * 0) = 1\n-  \/\/    2nd - start of second logarithmic region\n-  \/\/      1 corresponds to logarithmic value N_words + 1 and 2**(3 * 1) = 8\n-  \/\/    3rd - start of third logarithmic region\n-  \/\/      2 corresponds to logarithmic value N_words + 2 and 2**(3 * 2) = 64\n-  \/\/\n-  \/\/    integer below the block offset entry is an example of\n-  \/\/    the index of the entry\n-  \/\/\n-  \/\/    Given an address,\n-  \/\/      Find the index for the address\n-  \/\/      Find the block offset table entry\n-  \/\/      Convert the entry to a back slide\n-  \/\/        (e.g., with today's, offset = 0x81 =>\n-  \/\/          back slip = 2**(3*(0x81 - N_words)) = 2**3) = 8\n-  \/\/      Move back N (e.g., 8) entries and repeat with the\n-  \/\/        value of the new entry\n-  \/\/\n-  size_t start_card = _array->index_for(start);\n-  size_t end_card = _array->index_for(end-1);\n-  assert(start ==_array->address_for_index(start_card), \"Precondition\");\n-  assert(end ==_array->address_for_index(end_card)+BOTConstants::card_size_in_words(), \"Precondition\");\n-  set_remainder_to_point_to_start_incl(start_card, end_card, reducing); \/\/ closed interval\n-}\n-\n-\n-\/\/ Unlike the normal convention in this code, the argument here denotes\n-\/\/ a closed, inclusive interval: [start_card, end_card], cf set_remainder_to_point_to_start()\n-\/\/ above.\n-void\n-BlockOffsetArray::set_remainder_to_point_to_start_incl(size_t start_card, size_t end_card, bool reducing) {\n-\n-  check_reducing_assertion(reducing);\n-  if (start_card > end_card) {\n-    return;\n-  }\n-  assert(start_card > _array->index_for(_bottom), \"Cannot be first card\");\n-  assert(_array->offset_array(start_card-1) <= BOTConstants::card_size_in_words(),\n-    \"Offset card has an unexpected value\");\n-  size_t start_card_for_region = start_card;\n-  u_char offset = max_jubyte;\n-  for (uint i = 0; i < BOTConstants::N_powers; i++) {\n-    \/\/ -1 so that the card with the actual offset is counted.  Another -1\n-    \/\/ so that the reach ends in this region and not at the start\n-    \/\/ of the next.\n-    size_t reach = start_card - 1 + (BOTConstants::power_to_cards_back(i+1) - 1);\n-    offset = BOTConstants::card_size_in_words() + i;\n-    if (reach >= end_card) {\n-      _array->set_offset_array(start_card_for_region, end_card, offset, reducing);\n+\/\/ Write the backskip value for each logarithmic region (array slots containing the same entry value).\n+\/\/\n+\/\/    offset\n+\/\/    card             2nd                       3rd\n+\/\/     | +- 1st        |                         |\n+\/\/     v v             v                         v\n+\/\/    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+     +-+-+-+-+-+-+-+-+-+-+-\n+\/\/    |x|0|0|0|0|0|0|0|1|1|1|1|1|1| ... |1|1|1|1|2|2|2|2|2|2| ...\n+\/\/    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+     +-+-+-+-+-+-+-+-+-+-+-\n+\/\/    11              19                        75\n+\/\/      12\n+\/\/\n+\/\/    offset card is the card that points to the start of an object\n+\/\/      x - offset value of offset card\n+\/\/    1st - start of first logarithmic region\n+\/\/      0 corresponds to logarithmic value N_words + 0 and 2**(3 * 0) = 1\n+\/\/    2nd - start of second logarithmic region\n+\/\/      1 corresponds to logarithmic value N_words + 1 and 2**(3 * 1) = 8\n+\/\/    3rd - start of third logarithmic region\n+\/\/      2 corresponds to logarithmic value N_words + 2 and 2**(3 * 2) = 64\n+\/\/\n+\/\/    integer below the block offset entry is an example of\n+\/\/    the index of the entry\n+\/\/\n+\/\/    Given an address,\n+\/\/      Find the index for the address\n+\/\/      Find the block offset table entry\n+\/\/      Convert the entry to a back slide\n+\/\/        (e.g., with today's, offset = 0x81 =>\n+\/\/          back slip = 2**(3*(0x81 - N_words)) = 2**3) = 8\n+\/\/      Move back N (e.g., 8) entries and repeat with the\n+\/\/        value of the new entry\n+\/\/\n+void SerialBlockOffsetTable::update_for_block_work(HeapWord* blk_start,\n+                                                   HeapWord* blk_end) {\n+  HeapWord* const cur_card_boundary = align_up_by_card_size(blk_start);\n+  size_t const offset_card = _array->index_for(cur_card_boundary);\n+\n+  \/\/ The first card holds the actual offset.\n+  _array->set_offset_array(offset_card, cur_card_boundary, blk_start);\n+\n+  \/\/ Check if this block spans over other cards.\n+  size_t end_card = _array->index_for(blk_end - 1);\n+  assert(offset_card <= end_card, \"inv\");\n+\n+  if (offset_card != end_card) {\n+    \/\/ Handling remaining cards.\n+    size_t start_card_for_region = offset_card + 1;\n+    for (uint i = 0; i < BOTConstants::N_powers; i++) {\n+      \/\/ -1 so that the reach ends in this region and not at the start\n+      \/\/ of the next.\n+      size_t reach = offset_card + BOTConstants::power_to_cards_back(i + 1) - 1;\n+      uint8_t value = checked_cast<uint8_t>(BOTConstants::card_size_in_words() + i);\n+\n+      _array->set_offset_array(start_card_for_region, MIN2(reach, end_card), value);\n@@ -193,46 +136,0 @@\n-      break;\n-    }\n-    _array->set_offset_array(start_card_for_region, reach, offset, reducing);\n-    start_card_for_region = reach + 1;\n-  }\n-  assert(start_card_for_region > end_card, \"Sanity check\");\n-  DEBUG_ONLY(check_all_cards(start_card, end_card);)\n-}\n-\n-\/\/ The card-interval [start_card, end_card] is a closed interval; this\n-\/\/ is an expensive check -- use with care and only under protection of\n-\/\/ suitable flag.\n-void BlockOffsetArray::check_all_cards(size_t start_card, size_t end_card) const {\n-\n-  if (end_card < start_card) {\n-    return;\n-  }\n-  guarantee(_array->offset_array(start_card) == BOTConstants::card_size_in_words(), \"Wrong value in second card\");\n-  u_char last_entry = BOTConstants::card_size_in_words();\n-  for (size_t c = start_card + 1; c <= end_card; c++ \/* yeah! *\/) {\n-    u_char entry = _array->offset_array(c);\n-    guarantee(entry >= last_entry, \"Monotonicity\");\n-    if (c - start_card > BOTConstants::power_to_cards_back(1)) {\n-      guarantee(entry > BOTConstants::card_size_in_words(), \"Should be in logarithmic region\");\n-    }\n-    size_t backskip = BOTConstants::entry_to_cards_back(entry);\n-    size_t landing_card = c - backskip;\n-    guarantee(landing_card >= (start_card - 1), \"Inv\");\n-    if (landing_card >= start_card) {\n-      guarantee(_array->offset_array(landing_card) <= entry, \"Monotonicity\");\n-    } else {\n-      guarantee(landing_card == (start_card - 1), \"Tautology\");\n-      \/\/ Note that N_words is the maximum offset value\n-      guarantee(_array->offset_array(landing_card) <= BOTConstants::card_size_in_words(), \"Offset value\");\n-    }\n-    last_entry = entry;  \/\/ remember for monotonicity test\n-  }\n-}\n-\n-\n-void\n-BlockOffsetArray::alloc_block(HeapWord* blk_start, HeapWord* blk_end) {\n-  assert(blk_start != nullptr && blk_end > blk_start,\n-         \"phantom block\");\n-  single_block(blk_start, blk_end);\n-}\n@@ -240,39 +137,3 @@\n-void\n-BlockOffsetArray::do_block_internal(HeapWord* blk_start,\n-                                    HeapWord* blk_end,\n-                                    bool reducing) {\n-  assert(_sp->is_in_reserved(blk_start),\n-         \"reference must be into the space\");\n-  assert(_sp->is_in_reserved(blk_end-1),\n-         \"limit must be within the space\");\n-  \/\/ This is optimized to make the test fast, assuming we only rarely\n-  \/\/ cross boundaries.\n-  uintptr_t end_ui = (uintptr_t)(blk_end - 1);\n-  uintptr_t start_ui = (uintptr_t)blk_start;\n-  \/\/ Calculate the last card boundary preceding end of blk\n-  intptr_t boundary_before_end = (intptr_t)end_ui;\n-  clear_bits(boundary_before_end, right_n_bits((int)BOTConstants::log_card_size()));\n-  if (start_ui <= (uintptr_t)boundary_before_end) {\n-    \/\/ blk starts at or crosses a boundary\n-    \/\/ Calculate index of card on which blk begins\n-    size_t    start_index = _array->index_for(blk_start);\n-    \/\/ Index of card on which blk ends\n-    size_t    end_index   = _array->index_for(blk_end - 1);\n-    \/\/ Start address of card on which blk begins\n-    HeapWord* boundary    = _array->address_for_index(start_index);\n-    assert(boundary <= blk_start, \"blk should start at or after boundary\");\n-    if (blk_start != boundary) {\n-      \/\/ blk starts strictly after boundary\n-      \/\/ adjust card boundary and start_index forward to next card\n-      boundary += BOTConstants::card_size_in_words();\n-      start_index++;\n-    }\n-    assert(start_index <= end_index, \"monotonicity of index_for()\");\n-    assert(boundary <= (HeapWord*)boundary_before_end, \"tautology\");\n-    _array->set_offset_array(start_index, boundary, blk_start, reducing);\n-    \/\/ We have finished marking the \"offset card\". We need to now\n-    \/\/ mark the subsequent cards that this blk spans.\n-    if (start_index < end_index) {\n-      HeapWord* rem_st = _array->address_for_index(start_index) + BOTConstants::card_size_in_words();\n-      HeapWord* rem_end = _array->address_for_index(end_index) + BOTConstants::card_size_in_words();\n-      set_remainder_to_point_to_start(rem_st, rem_end, reducing);\n+      if (reach >= end_card) {\n+        break;\n+      }\n@@ -280,0 +141,1 @@\n+    assert(start_card_for_region > end_card, \"Sanity check\");\n@@ -281,1 +143,0 @@\n-}\n@@ -283,8 +144,1 @@\n-\/\/ The range [blk_start, blk_end) represents a single contiguous block\n-\/\/ of storage; modify the block offset table to represent this\n-\/\/ information; Right-open interval: [blk_start, blk_end)\n-\/\/ NOTE: this method does _not_ adjust _unallocated_block.\n-void\n-BlockOffsetArray::single_block(HeapWord* blk_start,\n-                               HeapWord* blk_end) {\n-  do_block_internal(blk_start, blk_end);\n+  debug_only(verify_for_block(blk_start, blk_end);)\n@@ -293,8 +147,2 @@\n-void BlockOffsetArray::verify() const {\n-  \/\/ For each entry in the block offset table, verify that\n-  \/\/ the entry correctly finds the start of an object at the\n-  \/\/ first address covered by the block or to the left of that\n-  \/\/ first address.\n-\n-  size_t next_index = 1;\n-  size_t last_index = last_active_index();\n+HeapWord* SerialBlockOffsetTable::block_start_reaching_into_card(const void* addr) const {\n+  size_t index = _array->index_for(addr);\n@@ -302,5 +150,3 @@\n-  \/\/ Use for debugging.  Initialize to null to distinguish the\n-  \/\/ first iteration through the while loop.\n-  HeapWord* last_p = nullptr;\n-  HeapWord* last_start = nullptr;\n-  oop last_o = nullptr;\n+  uint8_t offset;\n+  while (true) {\n+    offset = _array->offset_array(index);\n@@ -308,7 +154,2 @@\n-  while (next_index <= last_index) {\n-    \/\/ Use an address past the start of the address for\n-    \/\/ the entry.\n-    HeapWord* p = _array->address_for_index(next_index) + 1;\n-    if (p >= _end) {\n-      \/\/ That's all of the allocated block table.\n-      return;\n+    if (offset < BOTConstants::card_size_in_words()) {\n+      break;\n@@ -316,14 +157,0 @@\n-    \/\/ block_start() asserts that start <= p.\n-    HeapWord* start = block_start(p);\n-    \/\/ First check if the start is an allocated block and only\n-    \/\/ then if it is a valid object.\n-    oop o = cast_to_oop(start);\n-    assert(!Universe::is_fully_initialized() ||\n-           _sp->is_free_block(start) ||\n-           oopDesc::is_oop_or_null(o), \"Bad object was found\");\n-    next_index++;\n-    last_p = p;\n-    last_start = start;\n-    last_o = o;\n-  }\n-}\n@@ -331,18 +158,0 @@\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\/\/ BlockOffsetArrayContigSpace\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-HeapWord* BlockOffsetArrayContigSpace::block_start_unsafe(const void* addr) const {\n-  assert(_array->offset_array(0) == 0, \"objects can't cross covered areas\");\n-\n-  \/\/ Otherwise, find the block start using the table.\n-  assert(_bottom <= addr && addr < _end,\n-         \"addr must be covered by this Array\");\n-  size_t index = _array->index_for(addr);\n-  \/\/ We must make sure that the offset table entry we use is valid.  If\n-  \/\/ \"addr\" is past the end, start at the last known one and go forward.\n-  index = MIN2(index, _next_offset_index-1);\n-  HeapWord* q = _array->address_for_index(index);\n-\n-  uint offset = _array->offset_array(index);    \/\/ Extend u_char to uint.\n-  while (offset > BOTConstants::card_size_in_words()) {\n@@ -352,2 +161,0 @@\n-    q -= (BOTConstants::card_size_in_words() * n_cards_back);\n-    assert(q >= _sp->bottom(), \"Went below bottom!\");\n@@ -355,7 +162,0 @@\n-    offset = _array->offset_array(index);\n-  }\n-  while (offset == BOTConstants::card_size_in_words()) {\n-    assert(q >= _sp->bottom(), \"Went below bottom!\");\n-    q -= BOTConstants::card_size_in_words();\n-    index--;\n-    offset = _array->offset_array(index);\n@@ -363,3 +163,0 @@\n-  assert(offset < BOTConstants::card_size_in_words(), \"offset too large\");\n-  q -= offset;\n-  HeapWord* n = q;\n@@ -367,8 +164,2 @@\n-  while (n <= addr) {\n-    debug_only(HeapWord* last = q);   \/\/ for debugging\n-    q = n;\n-    n += _sp->block_size(n);\n-  }\n-  assert(q <= addr, \"wrong order for current and arg\");\n-  assert(addr <= n, \"wrong order for arg and next\");\n-  return q;\n+  HeapWord* q = _array->address_for_index(index);\n+  return q - offset;\n@@ -377,30 +168,2 @@\n-\/\/\n-\/\/              _next_offset_threshold\n-\/\/              |   _next_offset_index\n-\/\/              v   v\n-\/\/      +-------+-------+-------+-------+-------+\n-\/\/      | i-1   |   i   | i+1   | i+2   | i+3   |\n-\/\/      +-------+-------+-------+-------+-------+\n-\/\/       ( ^    ]\n-\/\/         block-start\n-\/\/\n-\n-void BlockOffsetArrayContigSpace::alloc_block_work(HeapWord* blk_start,\n-                                        HeapWord* blk_end) {\n-  assert(blk_start != nullptr && blk_end > blk_start,\n-         \"phantom block\");\n-  assert(blk_end > _next_offset_threshold,\n-         \"should be past threshold\");\n-  assert(blk_start <= _next_offset_threshold,\n-         \"blk_start should be at or before threshold\");\n-  assert(pointer_delta(_next_offset_threshold, blk_start) <= BOTConstants::card_size_in_words(),\n-         \"offset should be <= BlockOffsetSharedArray::N\");\n-  assert(_sp->is_in_reserved(blk_start),\n-         \"reference must be into the space\");\n-  assert(_sp->is_in_reserved(blk_end-1),\n-         \"limit must be within the space\");\n-  assert(_next_offset_threshold ==\n-         _array->_reserved.start() + _next_offset_index*BOTConstants::card_size_in_words(),\n-         \"index must agree with threshold\");\n-\n-  debug_only(size_t orig_next_offset_index = _next_offset_index;)\n+void SerialBlockOffsetTable::verify_for_block(HeapWord* blk_start, HeapWord* blk_end) const {\n+  assert(is_crossing_card_boundary(blk_start, blk_end), \"precondition\");\n@@ -408,20 +171,4 @@\n-  \/\/ Mark the card that holds the offset into the block.  Note\n-  \/\/ that _next_offset_index and _next_offset_threshold are not\n-  \/\/ updated until the end of this method.\n-  _array->set_offset_array(_next_offset_index,\n-                           _next_offset_threshold,\n-                           blk_start);\n-\n-  \/\/ We need to now mark the subsequent cards that this blk spans.\n-\n-  \/\/ Index of card on which blk ends.\n-  size_t end_index   = _array->index_for(blk_end - 1);\n-\n-  \/\/ Are there more cards left to be updated?\n-  if (_next_offset_index + 1 <= end_index) {\n-    HeapWord* rem_st  = _array->address_for_index(_next_offset_index + 1);\n-    \/\/ Calculate rem_end this way because end_index\n-    \/\/ may be the last valid index in the covered region.\n-    HeapWord* rem_end = _array->address_for_index(end_index) +  BOTConstants::card_size_in_words();\n-    set_remainder_to_point_to_start(rem_st, rem_end);\n-  }\n+  const size_t start_card = _array->index_for(align_up_by_card_size(blk_start));\n+  const size_t end_card = _array->index_for(blk_end - 1);\n+  \/\/ Check cards in [start_card, end_card]\n+  assert(_array->offset_array(start_card) < BOTConstants::card_size_in_words(), \"offset card\");\n@@ -429,21 +176,8 @@\n-  \/\/ _next_offset_index and _next_offset_threshold updated here.\n-  _next_offset_index = end_index + 1;\n-  \/\/ Calculate _next_offset_threshold this way because end_index\n-  \/\/ may be the last valid index in the covered region.\n-  _next_offset_threshold = _array->address_for_index(end_index) + BOTConstants::card_size_in_words();\n-  assert(_next_offset_threshold >= blk_end, \"Incorrect offset threshold\");\n-\n-#ifdef ASSERT\n-  \/\/ The offset can be 0 if the block starts on a boundary.  That\n-  \/\/ is checked by an assertion above.\n-  size_t start_index = _array->index_for(blk_start);\n-  HeapWord* boundary    = _array->address_for_index(start_index);\n-  assert((_array->offset_array(orig_next_offset_index) == 0 &&\n-          blk_start == boundary) ||\n-          (_array->offset_array(orig_next_offset_index) > 0 &&\n-         _array->offset_array(orig_next_offset_index) <= BOTConstants::card_size_in_words()),\n-         \"offset array should have been set\");\n-  for (size_t j = orig_next_offset_index + 1; j <= end_index; j++) {\n-    assert(_array->offset_array(j) > 0 &&\n-           _array->offset_array(j) <= (u_char) (BOTConstants::card_size_in_words()+BOTConstants::N_powers-1),\n-           \"offset array should have been set\");\n+  for (size_t i = start_card + 1; i <= end_card; ++i) {\n+    const uint8_t prev  = _array->offset_array(i-1);\n+    const uint8_t value = _array->offset_array(i);\n+    if (prev != value) {\n+      assert(value >= prev, \"monotonic\");\n+      size_t n_cards_back = BOTConstants::entry_to_cards_back(value);\n+      assert(start_card == (i - n_cards_back), \"inv\");\n+    }\n@@ -451,17 +185,0 @@\n-#endif\n-}\n-\n-void BlockOffsetArrayContigSpace::initialize_threshold() {\n-  _next_offset_index = _array->index_for(_bottom);\n-  _next_offset_index++;\n-  _next_offset_threshold =\n-    _array->address_for_index(_next_offset_index);\n-}\n-\n-void BlockOffsetArrayContigSpace::zero_bottom_entry() {\n-  size_t bottom_index = _array->index_for(_bottom);\n-  _array->set_offset_array(bottom_index, 0);\n-}\n-\n-size_t BlockOffsetArrayContigSpace::last_active_index() const {\n-  return _next_offset_index == 0 ? 0 : _next_offset_index - 1;\n","filename":"src\/hotspot\/share\/gc\/serial\/serialBlockOffsetTable.cpp","additions":89,"deletions":372,"binary":false,"changes":461,"status":"modified"},{"patch":"@@ -39,74 +39,1 @@\n-\/\/ The CollectedHeap type requires subtypes to implement a method\n-\/\/ \"block_start\".  For some subtypes, notably generational\n-\/\/ systems using card-table-based write barriers, the efficiency of this\n-\/\/ operation may be important.  Implementations of the \"BlockOffsetArray\"\n-\/\/ class may be useful in providing such efficient implementations.\n-\/\/\n-\/\/ BlockOffsetTable (abstract)\n-\/\/   - BlockOffsetArray (abstract)\n-\/\/     - BlockOffsetArrayContigSpace\n-\/\/\n-\n-class ContiguousSpace;\n-\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\/\/ The BlockOffsetTable \"interface\"\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-class BlockOffsetTable {\n-  friend class VMStructs;\n-protected:\n-  \/\/ These members describe the region covered by the table.\n-\n-  \/\/ The space this table is covering.\n-  HeapWord* _bottom;    \/\/ == reserved.start\n-  HeapWord* _end;       \/\/ End of currently allocated region.\n-\n-public:\n-  \/\/ Initialize the table to cover the given space.\n-  \/\/ The contents of the initial table are undefined.\n-  BlockOffsetTable(HeapWord* bottom, HeapWord* end):\n-    _bottom(bottom), _end(end) {\n-    assert(_bottom <= _end, \"arguments out of order\");\n-    assert(BOTConstants::card_size() == CardTable::card_size(), \"sanity\");\n-  }\n-\n-  \/\/ Note that the committed size of the covered space may have changed,\n-  \/\/ so the table size might also wish to change.\n-  virtual void resize(size_t new_word_size) = 0;\n-\n-  virtual void set_bottom(HeapWord* new_bottom) {\n-    assert(new_bottom <= _end, \"new_bottom > _end\");\n-    _bottom = new_bottom;\n-    resize(pointer_delta(_end, _bottom));\n-  }\n-\n-  \/\/ Requires \"addr\" to be contained by a block, and returns the address of\n-  \/\/ the start of that block.\n-  virtual HeapWord* block_start_unsafe(const void* addr) const = 0;\n-\n-  \/\/ Returns the address of the start of the block containing \"addr\", or\n-  \/\/ else \"null\" if it is covered by no block.\n-  HeapWord* block_start(const void* addr) const;\n-};\n-\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\/\/ One implementation of \"BlockOffsetTable,\" the BlockOffsetArray,\n-\/\/ divides the covered region into \"N\"-word subregions (where\n-\/\/ \"N\" = 2^\"LogN\".  An array with an entry for each such subregion\n-\/\/ indicates how far back one must go to find the start of the\n-\/\/ chunk that includes the first word of the subregion.\n-\/\/\n-\/\/ Each BlockOffsetArray is owned by a Space.  However, the actual array\n-\/\/ may be shared by several BlockOffsetArrays; this is useful\n-\/\/ when a single resizable area (such as a generation) is divided up into\n-\/\/ several spaces in which contiguous allocation takes place.  (Consider,\n-\/\/ for example, the garbage-first generation.)\n-\n-\/\/ Here is the shared array type.\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\/\/ BlockOffsetSharedArray\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-class BlockOffsetSharedArray: public CHeapObj<mtGC> {\n-  friend class BlockOffsetArray;\n-  friend class BlockOffsetArrayNonContigSpace;\n-  friend class BlockOffsetArrayContigSpace;\n+class SerialBlockOffsetSharedArray: public CHeapObj<mtGC> {\n@@ -114,0 +41,1 @@\n+  friend class SerialBlockOffsetTable;\n@@ -115,4 +43,1 @@\n- private:\n-  bool _init_to_zero;\n-\n-  \/\/ The reserved region covered by the shared array.\n+  \/\/ The reserved heap (i.e. old-gen) covered by the shared array.\n@@ -121,3 +46,0 @@\n-  \/\/ End of the current committed region.\n-  HeapWord* _end;\n-\n@@ -127,1 +49,1 @@\n-  u_char* _offset_array;          \/\/ byte array keeping backwards offsets\n+  uint8_t* _offset_array;          \/\/ byte array keeping backwards offsets\n@@ -129,1 +51,1 @@\n-  void fill_range(size_t start, size_t num_cards, u_char offset) {\n+  void fill_range(size_t start, size_t num_cards, uint8_t offset) {\n@@ -131,2 +53,0 @@\n-    \/\/ If collector is concurrent, special handling may be needed.\n-    G1GC_ONLY(assert(!UseG1GC, \"Shouldn't be here when using G1\");)\n@@ -136,4 +56,1 @@\n- protected:\n-  \/\/ Bounds checking accessors:\n-  \/\/ For performance these have to devolve to array accesses in product builds.\n-  u_char offset_array(size_t index) const {\n+  uint8_t offset_array(size_t index) const {\n@@ -143,48 +60,0 @@\n-  \/\/ An assertion-checking helper method for the set_offset_array() methods below.\n-  void check_reducing_assertion(bool reducing);\n-\n-  void set_offset_array(size_t index, u_char offset, bool reducing = false) {\n-    check_reducing_assertion(reducing);\n-    assert(index < _vs.committed_size(), \"index out of range\");\n-    assert(!reducing || _offset_array[index] >= offset, \"Not reducing\");\n-    _offset_array[index] = offset;\n-  }\n-\n-  void set_offset_array(size_t index, HeapWord* high, HeapWord* low, bool reducing = false) {\n-    check_reducing_assertion(reducing);\n-    assert(index < _vs.committed_size(), \"index out of range\");\n-    assert(high >= low, \"addresses out of order\");\n-    assert(pointer_delta(high, low) <= BOTConstants::card_size_in_words(), \"offset too large\");\n-    assert(!reducing || _offset_array[index] >=  (u_char)pointer_delta(high, low),\n-           \"Not reducing\");\n-    _offset_array[index] = (u_char)pointer_delta(high, low);\n-  }\n-\n-  void set_offset_array(HeapWord* left, HeapWord* right, u_char offset, bool reducing = false) {\n-    check_reducing_assertion(reducing);\n-    assert(index_for(right - 1) < _vs.committed_size(),\n-           \"right address out of range\");\n-    assert(left  < right, \"Heap addresses out of order\");\n-    size_t num_cards = pointer_delta(right, left) >> BOTConstants::log_card_size_in_words();\n-\n-    fill_range(index_for(left), num_cards, offset);\n-  }\n-\n-  void set_offset_array(size_t left, size_t right, u_char offset, bool reducing = false) {\n-    check_reducing_assertion(reducing);\n-    assert(right < _vs.committed_size(), \"right address out of range\");\n-    assert(left  <= right, \"indexes out of order\");\n-    size_t num_cards = right - left + 1;\n-\n-    fill_range(left, num_cards, offset);\n-  }\n-\n-  void check_offset_array(size_t index, HeapWord* high, HeapWord* low) const {\n-    assert(index < _vs.committed_size(), \"index out of range\");\n-    assert(high >= low, \"addresses out of order\");\n-    assert(pointer_delta(high, low) <= BOTConstants::card_size_in_words(), \"offset too large\");\n-    assert(_offset_array[index] == pointer_delta(high, low),\n-           \"Wrong offset\");\n-  }\n-\n-  bool is_card_boundary(HeapWord* p) const;\n@@ -194,4 +63,2 @@\n-  \/\/ We always add an extra slot because if an object\n-  \/\/ ends on a card boundary we put a 0 in the next\n-  \/\/ offset array slot, so we want that slot always\n-  \/\/ to be reserved.\n+  static size_t compute_size(size_t mem_region_words) {\n+    assert(mem_region_words % BOTConstants::card_size_in_words() == 0, \"precondition\");\n@@ -199,2 +66,1 @@\n-  size_t compute_size(size_t mem_region_words) {\n-    size_t number_of_slots = (mem_region_words \/ BOTConstants::card_size_in_words()) + 1;\n+    size_t number_of_slots = mem_region_words \/ BOTConstants::card_size_in_words();\n@@ -210,2 +76,2 @@\n-  \/\/ BlockOffsetTable(s) to initialize cards.\n-  BlockOffsetSharedArray(MemRegion reserved, size_t init_word_size);\n+  \/\/ SerialBlockOffsetTable(s) to initialize cards.\n+  SerialBlockOffsetSharedArray(MemRegion reserved, size_t init_word_size);\n@@ -218,11 +84,0 @@\n-  void set_bottom(HeapWord* new_bottom);\n-\n-  \/\/ Whether entries should be initialized to zero. Used currently only for\n-  \/\/ error checking.\n-  void set_init_to_zero(bool val) { _init_to_zero = val; }\n-  bool init_to_zero() { return _init_to_zero; }\n-\n-  \/\/ Updates all the BlockOffsetArray's sharing this shared array to\n-  \/\/ reflect the current \"top\"'s of their spaces.\n-  void update_offset_arrays();   \/\/ Not yet implemented!\n-\n@@ -235,17 +90,0 @@\n-};\n-\n-class Space;\n-\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\/\/ The BlockOffsetArray whose subtypes use the BlockOffsetSharedArray.\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-class BlockOffsetArray: public BlockOffsetTable {\n-  friend class VMStructs;\n- protected:\n-  \/\/ The shared array, which is shared with other BlockOffsetArray's\n-  \/\/ corresponding to different spaces within a generation or span of\n-  \/\/ memory.\n-  BlockOffsetSharedArray* _array;\n-\n-  \/\/ The space that owns this subregion.\n-  Space* _sp;\n@@ -253,64 +91,5 @@\n-  \/\/ If true, array entries are initialized to 0; otherwise, they are\n-  \/\/ initialized to point backwards to the beginning of the covered region.\n-  bool _init_to_zero;\n-\n-  \/\/ An assertion-checking helper method for the set_remainder*() methods below.\n-  void check_reducing_assertion(bool reducing) { _array->check_reducing_assertion(reducing); }\n-\n-  \/\/ Sets the entries\n-  \/\/ corresponding to the cards starting at \"start\" and ending at \"end\"\n-  \/\/ to point back to the card before \"start\": the interval [start, end)\n-  \/\/ is right-open. The last parameter, reducing, indicates whether the\n-  \/\/ updates to individual entries always reduce the entry from a higher\n-  \/\/ to a lower value. (For example this would hold true during a temporal\n-  \/\/ regime during which only block splits were updating the BOT.\n-  void set_remainder_to_point_to_start(HeapWord* start, HeapWord* end, bool reducing = false);\n-  \/\/ Same as above, except that the args here are a card _index_ interval\n-  \/\/ that is closed: [start_index, end_index]\n-  void set_remainder_to_point_to_start_incl(size_t start, size_t end, bool reducing = false);\n-\n-  \/\/ A helper function for BOT adjustment\/verification work\n-  void do_block_internal(HeapWord* blk_start, HeapWord* blk_end, bool reducing = false);\n-\n- public:\n-  \/\/ The space may not have its bottom and top set yet, which is why the\n-  \/\/ region is passed as a parameter.  If \"init_to_zero\" is true, the\n-  \/\/ elements of the array are initialized to zero.  Otherwise, they are\n-  \/\/ initialized to point backwards to the beginning.\n-  BlockOffsetArray(BlockOffsetSharedArray* array, MemRegion mr,\n-                   bool init_to_zero_);\n-\n-  \/\/ Note: this ought to be part of the constructor, but that would require\n-  \/\/ \"this\" to be passed as a parameter to a member constructor for\n-  \/\/ the containing concrete subtype of Space.\n-  \/\/ This would be legal C++, but MS VC++ doesn't allow it.\n-  void set_space(Space* sp) { _sp = sp; }\n-\n-  \/\/ Resets the covered region to the given \"mr\".\n-  void set_region(MemRegion mr) {\n-    _bottom = mr.start();\n-    _end = mr.end();\n-  }\n-\n-  \/\/ Note that the committed size of the covered space may have changed,\n-  \/\/ so the table size might also wish to change.\n-  virtual void resize(size_t new_word_size) {\n-    HeapWord* new_end = _bottom + new_word_size;\n-    if (_end < new_end && !init_to_zero()) {\n-      \/\/ verify that the old and new boundaries are also card boundaries\n-      assert(_array->is_card_boundary(_end),\n-             \"_end not a card boundary\");\n-      assert(_array->is_card_boundary(new_end),\n-             \"new _end would not be a card boundary\");\n-      \/\/ set all the newly added cards\n-      _array->set_offset_array(_end, new_end, BOTConstants::card_size_in_words());\n-    }\n-    _end = new_end;  \/\/ update _end\n-  }\n-\n-  \/\/ Adjust the BOT to show that it has a single block in the\n-  \/\/ range [blk_start, blk_start + size). All necessary BOT\n-  \/\/ cards are adjusted, but _unallocated_block isn't.\n-  void single_block(HeapWord* blk_start, HeapWord* blk_end);\n-  void single_block(HeapWord* blk, size_t size) {\n-    single_block(blk, blk + size);\n+  void set_offset_array(size_t index, HeapWord* high, HeapWord* low) {\n+    assert(index < _vs.committed_size(), \"index out of range\");\n+    assert(high >= low, \"addresses out of order\");\n+    assert(pointer_delta(high, low) < BOTConstants::card_size_in_words(), \"offset too large\");\n+    _offset_array[index] = checked_cast<uint8_t>(pointer_delta(high, low));\n@@ -319,13 +98,4 @@\n-  \/\/ When the alloc_block() call returns, the block offset table should\n-  \/\/ have enough information such that any subsequent block_start() call\n-  \/\/ with an argument equal to an address that is within the range\n-  \/\/ [blk_start, blk_end) would return the value blk_start, provided\n-  \/\/ there have been no calls in between that reset this information\n-  \/\/ (e.g. see BlockOffsetArrayNonContigSpace::single_block() call\n-  \/\/ for an appropriate range covering the said interval).\n-  \/\/ These methods expect to be called with [blk_start, blk_end)\n-  \/\/ representing a block of memory in the heap.\n-  virtual void alloc_block(HeapWord* blk_start, HeapWord* blk_end);\n-  void alloc_block(HeapWord* blk, size_t size) {\n-    alloc_block(blk, blk + size);\n-  }\n+  void set_offset_array(size_t left, size_t right, uint8_t offset) {\n+    assert(right < _vs.committed_size(), \"right address out of range\");\n+    assert(left <= right, \"precondition\");\n+    size_t num_cards = right - left + 1;\n@@ -333,8 +103,1 @@\n-  \/\/ If true, initialize array slots with no allocated blocks to zero.\n-  \/\/ Otherwise, make them point back to the front.\n-  bool init_to_zero() { return _init_to_zero; }\n-  \/\/ Corresponding setter\n-  void set_init_to_zero(bool val) {\n-    _init_to_zero = val;\n-    assert(_array != nullptr, \"_array should be non-null\");\n-    _array->set_init_to_zero(val);\n+    fill_range(left, num_cards, offset);\n@@ -342,7 +105,0 @@\n-\n-  \/\/ Debugging\n-  \/\/ Return the index of the last entry in the \"active\" region.\n-  virtual size_t last_active_index() const = 0;\n-  \/\/ Verify the block offset table\n-  void verify() const;\n-  void check_all_cards(size_t left_card, size_t right_card) const;\n@@ -351,6 +107,5 @@\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\/\/ A subtype of BlockOffsetArray that takes advantage of the fact\n-\/\/ that its underlying space is a ContiguousSpace, so that its \"active\"\n-\/\/ region can be more efficiently tracked (than for a non-contiguous space).\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-class BlockOffsetArrayContigSpace: public BlockOffsetArray {\n+\/\/ SerialBlockOffsetTable divides the covered region into \"N\"-word subregions (where\n+\/\/ \"N\" = 2^\"LogN\".  An array with an entry for each such subregion indicates\n+\/\/ how far back one must go to find the start of the chunk that includes the\n+\/\/ first word of the subregion.\n+class SerialBlockOffsetTable {\n@@ -358,4 +113,0 @@\n- private:\n-  \/\/ allocation boundary at which offset array must be updated\n-  HeapWord* _next_offset_threshold;\n-  size_t    _next_offset_index;      \/\/ index corresponding to that boundary\n@@ -363,2 +114,2 @@\n-  \/\/ Work function when allocation start crosses threshold.\n-  void alloc_block_work(HeapWord* blk_start, HeapWord* blk_end);\n+  \/\/ The array that contains offset values. Its reacts to heap resizing.\n+  SerialBlockOffsetSharedArray* _array;\n@@ -366,5 +117,4 @@\n- public:\n-  BlockOffsetArrayContigSpace(BlockOffsetSharedArray* array, MemRegion mr):\n-    BlockOffsetArray(array, mr, true) {\n-    _next_offset_threshold = nullptr;\n-    _next_offset_index = 0;\n+  void update_for_block_work(HeapWord* blk_start, HeapWord* blk_end);\n+\n+  static HeapWord* align_up_by_card_size(HeapWord* const addr) {\n+    return align_up(addr, BOTConstants::card_size());\n@@ -373,1 +123,1 @@\n-  void set_contig_space(ContiguousSpace* sp) { set_space((Space*)sp); }\n+  void verify_for_block(HeapWord* blk_start, HeapWord* blk_end) const;\n@@ -375,4 +125,6 @@\n-  \/\/ Initialize the threshold for an empty heap.\n-  void initialize_threshold();\n-  \/\/ Zero out the entry for _bottom (offset will be zero)\n-  void zero_bottom_entry();\n+public:\n+  \/\/ Initialize the table to cover the given space.\n+  \/\/ The contents of the initial table are undefined.\n+  SerialBlockOffsetTable(SerialBlockOffsetSharedArray* array) : _array(array) {\n+    assert(BOTConstants::card_size() == CardTable::card_size(), \"sanity\");\n+  }\n@@ -380,3 +132,10 @@\n-  \/\/ Return the next threshold, the point at which the table should be\n-  \/\/ updated.\n-  HeapWord* threshold() const { return _next_offset_threshold; }\n+  static bool is_crossing_card_boundary(HeapWord* const obj_start,\n+                                        HeapWord* const obj_end) {\n+    HeapWord* cur_card_boundary = align_up_by_card_size(obj_start);\n+    \/\/ Strictly greater-than, since we check if this block *crosses* card boundary.\n+    return obj_end > cur_card_boundary;\n+  }\n+\n+  \/\/ Returns the address of the start of the block reaching into the card containing\n+  \/\/ \"addr\".\n+  HeapWord* block_start_reaching_into_card(const void* addr) const;\n@@ -384,1 +143,0 @@\n-  \/\/ In general, these methods expect to be called with\n@@ -386,6 +144,3 @@\n-  \/\/ In this implementation, however, we are OK even if blk_start and\/or\n-  \/\/ blk_end are null because null is represented as 0, and thus\n-  \/\/ never exceeds the \"_next_offset_threshold\".\n-  void alloc_block(HeapWord* blk_start, HeapWord* blk_end) {\n-    if (blk_end > _next_offset_threshold) {\n-      alloc_block_work(blk_start, blk_end);\n+  void update_for_block(HeapWord* blk_start, HeapWord* blk_end) {\n+    if (is_crossing_card_boundary(blk_start, blk_end)) {\n+      update_for_block_work(blk_start, blk_end);\n@@ -394,8 +149,0 @@\n-  void alloc_block(HeapWord* blk, size_t size) {\n-    alloc_block(blk, blk + size);\n-  }\n-\n-  HeapWord* block_start_unsafe(const void* addr) const;\n-\n-  \/\/ Debugging support\n-  virtual size_t last_active_index() const;\n","filename":"src\/hotspot\/share\/gc\/serial\/serialBlockOffsetTable.hpp","additions":52,"deletions":305,"binary":false,"changes":357,"status":"modified"},{"patch":"@@ -30,18 +30,1 @@\n-#include \"gc\/shared\/space.hpp\"\n-#include \"runtime\/safepoint.hpp\"\n-\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\/\/ BlockOffsetTable inlines\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-inline HeapWord* BlockOffsetTable::block_start(const void* addr) const {\n-  if (addr >= _bottom && addr < _end) {\n-    return block_start_unsafe(addr);\n-  } else {\n-    return nullptr;\n-  }\n-}\n-\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\/\/ BlockOffsetSharedArray inlines\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-inline size_t BlockOffsetSharedArray::index_for(const void* p) const {\n+inline size_t SerialBlockOffsetSharedArray::index_for(const void* p) const {\n@@ -58,1 +41,1 @@\n-inline HeapWord* BlockOffsetSharedArray::address_for_index(size_t index) const {\n+inline HeapWord* SerialBlockOffsetSharedArray::address_for_index(size_t index) const {\n@@ -66,6 +49,0 @@\n-inline void BlockOffsetSharedArray::check_reducing_assertion(bool reducing) {\n-    assert(reducing || !SafepointSynchronize::is_at_safepoint() || init_to_zero() ||\n-           Thread::current()->is_VM_thread() ||\n-           Thread::current()->is_ConcurrentGC_thread(), \"Crack\");\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/serialBlockOffsetTable.inline.hpp","additions":2,"deletions":25,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -298,2 +298,2 @@\n-  _bts = new BlockOffsetSharedArray(reserved_mr,\n-                                    heap_word_size(initial_byte_size));\n+  _bts = new SerialBlockOffsetSharedArray(reserved_mr,\n+                                          heap_word_size(initial_byte_size));\n@@ -477,1 +477,0 @@\n-  space->initialize_threshold();\n@@ -481,1 +480,1 @@\n-    space->alloc_block(start, start + word_size);\n+    space->update_for_block(start, start + word_size);\n","filename":"src\/hotspot\/share\/gc\/serial\/tenuredGeneration.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-class BlockOffsetSharedArray;\n+class SerialBlockOffsetSharedArray;\n@@ -53,1 +53,1 @@\n-  BlockOffsetSharedArray* _bts;\n+  SerialBlockOffsetSharedArray* _bts;\n","filename":"src\/hotspot\/share\/gc\/serial\/tenuredGeneration.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,32 +32,25 @@\n-#define VM_STRUCTS_SERIALGC(nonstatic_field,                                                    \\\n-                            volatile_nonstatic_field,                                           \\\n-                            static_field)                                                       \\\n-  nonstatic_field(TenuredGeneration,           _rs,                    CardTableRS*)            \\\n-  nonstatic_field(TenuredGeneration,           _bts,                   BlockOffsetSharedArray*) \\\n-  nonstatic_field(TenuredGeneration,           _shrink_factor,         size_t)                  \\\n-  nonstatic_field(TenuredGeneration,           _capacity_at_prologue,  size_t)                  \\\n-  nonstatic_field(TenuredGeneration,           _used_at_prologue,      size_t)                  \\\n-  nonstatic_field(TenuredGeneration,           _min_heap_delta_bytes,  size_t)                  \\\n-  nonstatic_field(TenuredGeneration,           _the_space,             TenuredSpace*)           \\\n-                                                                                                \\\n-  nonstatic_field(DefNewGeneration,            _old_gen,               Generation*)             \\\n-  nonstatic_field(DefNewGeneration,            _tenuring_threshold,    uint)                    \\\n-  nonstatic_field(DefNewGeneration,            _age_table,             AgeTable)                \\\n-  nonstatic_field(DefNewGeneration,            _eden_space,            ContiguousSpace*)        \\\n-  nonstatic_field(DefNewGeneration,            _from_space,            ContiguousSpace*)        \\\n-  nonstatic_field(DefNewGeneration,            _to_space,              ContiguousSpace*)        \\\n-                                                                                                \\\n-  nonstatic_field(BlockOffsetTable,            _bottom,                HeapWord*)               \\\n-  nonstatic_field(BlockOffsetTable,            _end,                   HeapWord*)               \\\n-                                                                                                \\\n-  nonstatic_field(BlockOffsetSharedArray,      _reserved,              MemRegion)               \\\n-  nonstatic_field(BlockOffsetSharedArray,      _end,                   HeapWord*)               \\\n-  nonstatic_field(BlockOffsetSharedArray,      _vs,                    VirtualSpace)            \\\n-  nonstatic_field(BlockOffsetSharedArray,      _offset_array,          u_char*)                 \\\n-                                                                                                \\\n-  nonstatic_field(BlockOffsetArray,            _array,                 BlockOffsetSharedArray*) \\\n-  nonstatic_field(BlockOffsetArray,            _sp,                    Space*)                  \\\n-  nonstatic_field(BlockOffsetArrayContigSpace, _next_offset_threshold, HeapWord*)               \\\n-  nonstatic_field(BlockOffsetArrayContigSpace, _next_offset_index,     size_t)                  \\\n-                                                                                                \\\n-  nonstatic_field(TenuredSpace,                _offsets,               BlockOffsetArray)\n+#define VM_STRUCTS_SERIALGC(nonstatic_field,                                                                \\\n+                            volatile_nonstatic_field,                                                       \\\n+                            static_field)                                                                   \\\n+  nonstatic_field(TenuredGeneration,                 _rs,                    CardTableRS*)                  \\\n+  nonstatic_field(TenuredGeneration,                 _bts,                   SerialBlockOffsetSharedArray*) \\\n+  nonstatic_field(TenuredGeneration,                 _shrink_factor,         size_t)                        \\\n+  nonstatic_field(TenuredGeneration,                 _capacity_at_prologue,  size_t)                        \\\n+  nonstatic_field(TenuredGeneration,                 _used_at_prologue,      size_t)                        \\\n+  nonstatic_field(TenuredGeneration,                 _min_heap_delta_bytes,  size_t)                        \\\n+  nonstatic_field(TenuredGeneration,                 _the_space,             TenuredSpace*)                 \\\n+                                                                                                            \\\n+  nonstatic_field(DefNewGeneration,                  _old_gen,               Generation*)                   \\\n+  nonstatic_field(DefNewGeneration,                  _tenuring_threshold,    uint)                          \\\n+  nonstatic_field(DefNewGeneration,                  _age_table,             AgeTable)                      \\\n+  nonstatic_field(DefNewGeneration,                  _eden_space,            ContiguousSpace*)              \\\n+  nonstatic_field(DefNewGeneration,                  _from_space,            ContiguousSpace*)              \\\n+  nonstatic_field(DefNewGeneration,                  _to_space,              ContiguousSpace*)              \\\n+                                                                                                            \\\n+  nonstatic_field(SerialBlockOffsetTable,            _array,                 SerialBlockOffsetSharedArray*) \\\n+                                                                                                            \\\n+  nonstatic_field(SerialBlockOffsetSharedArray,      _reserved,              MemRegion)                     \\\n+  nonstatic_field(SerialBlockOffsetSharedArray,      _vs,                    VirtualSpace)                  \\\n+  nonstatic_field(SerialBlockOffsetSharedArray,      _offset_array,          u_char*)                       \\\n+                                                                                                            \\\n+  nonstatic_field(TenuredSpace,                      _offsets,               SerialBlockOffsetTable)\n@@ -76,5 +69,2 @@\n-  declare_toplevel_type(BlockOffsetSharedArray)                               \\\n-  declare_toplevel_type(BlockOffsetTable)                                     \\\n-           declare_type(BlockOffsetArray,             BlockOffsetTable)       \\\n-           declare_type(BlockOffsetArrayContigSpace,  BlockOffsetArray)       \\\n-  declare_toplevel_type(BlockOffsetSharedArray*)\n+  declare_toplevel_type(SerialBlockOffsetSharedArray)                         \\\n+  declare_toplevel_type(SerialBlockOffsetTable)\n","filename":"src\/hotspot\/share\/gc\/serial\/vmStructs_serial.hpp","additions":27,"deletions":37,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -90,19 +90,0 @@\n-#if INCLUDE_SERIALGC\n-void TenuredSpace::clear(bool mangle_space) {\n-  ContiguousSpace::clear(mangle_space);\n-  _offsets.initialize_threshold();\n-}\n-\n-void TenuredSpace::set_bottom(HeapWord* new_bottom) {\n-  Space::set_bottom(new_bottom);\n-  _offsets.set_bottom(new_bottom);\n-}\n-\n-void TenuredSpace::set_end(HeapWord* new_end) {\n-  \/\/ Space should not advertise an increase in size\n-  \/\/ until after the underlying offset table has been enlarged.\n-  _offsets.resize(pointer_delta(new_end, bottom()));\n-  Space::set_end(new_end);\n-}\n-#endif \/\/ INCLUDE_SERIALGC\n-\n@@ -155,1 +136,0 @@\n-    cp->space->initialize_threshold();\n@@ -175,1 +155,1 @@\n-  cp->space->alloc_block(compact_top - size, compact_top);\n+  cp->space->update_for_block(compact_top - size, compact_top);\n@@ -193,1 +173,0 @@\n-    cp->space->initialize_threshold();\n@@ -387,3 +366,2 @@\n-  st->print_cr(\" [\" PTR_FORMAT \", \" PTR_FORMAT \", \"\n-                PTR_FORMAT \", \" PTR_FORMAT \")\",\n-              p2i(bottom()), p2i(top()), p2i(_offsets.threshold()), p2i(end()));\n+  st->print_cr(\" [\" PTR_FORMAT \", \" PTR_FORMAT \", \" PTR_FORMAT \")\",\n+              p2i(bottom()), p2i(top()), p2i(end()));\n@@ -513,2 +491,2 @@\n-void TenuredSpace::initialize_threshold() {\n-  _offsets.initialize_threshold();\n+void TenuredSpace::update_for_block(HeapWord* start, HeapWord* end) {\n+  _offsets.update_for_block(start, end);\n@@ -517,2 +495,14 @@\n-void TenuredSpace::alloc_block(HeapWord* start, HeapWord* end) {\n-  _offsets.alloc_block(start, end);\n+HeapWord* TenuredSpace::block_start_const(const void* addr) const {\n+  HeapWord* cur_block = _offsets.block_start_reaching_into_card(addr);\n+\n+  while (true) {\n+    HeapWord* next_block = cur_block + cast_to_oop(cur_block)->size();\n+    if (next_block > addr) {\n+      assert(cur_block <= addr, \"postcondition\");\n+      return cur_block;\n+    }\n+    cur_block = next_block;\n+    \/\/ Because the BOT is precise, we should never step into the next card\n+    \/\/ (i.e. crossing the card boundary).\n+    assert(!SerialBlockOffsetTable::is_crossing_card_boundary(cur_block, (HeapWord*)addr), \"must be\");\n+  }\n@@ -521,1 +511,1 @@\n-TenuredSpace::TenuredSpace(BlockOffsetSharedArray* sharedOffsetArray,\n+TenuredSpace::TenuredSpace(SerialBlockOffsetSharedArray* sharedOffsetArray,\n@@ -523,2 +513,1 @@\n-  _offsets(sharedOffsetArray, mr),\n-  _par_alloc_lock(Mutex::safepoint, \"TenuredSpaceParAlloc_lock\", true)\n+  _offsets(sharedOffsetArray)\n@@ -526,1 +515,0 @@\n-  _offsets.set_contig_space(this);\n@@ -539,4 +527,0 @@\n-  if (VerifyObjectStartArray) {\n-    _offsets.verify();\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/space.cpp","additions":21,"deletions":37,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -50,5 +50,0 @@\n-#if INCLUDE_SERIALGC\n-class BlockOffsetArray;\n-class BlockOffsetArrayContigSpace;\n-class BlockOffsetTable;\n-#endif\n@@ -244,1 +239,1 @@\n-  virtual void alloc_block(HeapWord* start, HeapWord* the_end) { }\n+  virtual void update_for_block(HeapWord* start, HeapWord* the_end) { }\n@@ -311,5 +306,0 @@\n-  \/\/ Some contiguous spaces may maintain some data structures that should\n-  \/\/ be updated whenever an allocation crosses a boundary.  This function\n-  \/\/ initializes these data structures for further updates.\n-  virtual void initialize_threshold() { }\n-\n@@ -325,1 +315,1 @@\n-  \/\/ Invokes the \"alloc_block\" function of the then-current compaction\n+  \/\/ Invokes the \"update_for_block\" function of the then-current compaction\n@@ -415,2 +405,1 @@\n-\/\/ \"block_start\" operation via a BlockOffsetArray (whose BlockOffsetSharedArray\n-\/\/ may be shared with other spaces.)\n+\/\/ \"block_start\" operation via a SerialBlockOffsetTable.\n@@ -421,2 +410,1 @@\n-  BlockOffsetArrayContigSpace _offsets;\n-  Mutex _par_alloc_lock;\n+  SerialBlockOffsetTable _offsets;\n@@ -428,1 +416,1 @@\n-  TenuredSpace(BlockOffsetSharedArray* sharedOffsetArray,\n+  TenuredSpace(SerialBlockOffsetSharedArray* sharedOffsetArray,\n@@ -431,6 +419,1 @@\n-  void set_bottom(HeapWord* value) override;\n-  void set_end(HeapWord* value) override;\n-\n-  void clear(bool mangle_space) override;\n-\n-  inline HeapWord* block_start_const(const void* p) const override;\n+  HeapWord* block_start_const(const void* addr) const override;\n@@ -443,2 +426,1 @@\n-  void initialize_threshold() override;\n-  void alloc_block(HeapWord* start, HeapWord* end) override;\n+  void update_for_block(HeapWord* start, HeapWord* end) override;\n","filename":"src\/hotspot\/share\/gc\/shared\/space.hpp","additions":7,"deletions":25,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-    _offsets.alloc_block(res, size);\n+    _offsets.update_for_block(res, res + size);\n@@ -55,3 +55,0 @@\n-\/\/ Because of the requirement of keeping \"_offsets\" up to date with the\n-\/\/ allocations, we sequentialize these with a lock.  Therefore, best if\n-\/\/ this is used for larger LAB allocations only.\n@@ -59,9 +56,0 @@\n-  MutexLocker x(&_par_alloc_lock);\n-  \/\/ This ought to be just \"allocate\", because of the lock above, but that\n-  \/\/ ContiguousSpace::allocate asserts that either the allocating thread\n-  \/\/ holds the heap lock or it is the VM thread and we're at a safepoint.\n-  \/\/ The best I (dld) could figure was to put a field in ContiguousSpace\n-  \/\/ meaning \"locking at safepoint taken care of\", and set\/reset that\n-  \/\/ here.  But this will do for now, especially in light of the comment\n-  \/\/ above.  Perhaps in the future some lock-free manner of keeping the\n-  \/\/ coordination.\n@@ -70,1 +58,1 @@\n-    _offsets.alloc_block(res, size);\n+    _offsets.update_for_block(res, res + size);\n@@ -75,5 +63,0 @@\n-inline HeapWord*\n-TenuredSpace::block_start_const(const void* p) const {\n-  return _offsets.block_start(p);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/space.inline.hpp","additions":2,"deletions":19,"binary":false,"changes":21,"status":"modified"}]}