{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -125,2 +125,2 @@\n-  STATIC_ASSERT(JNIHandles::weak_tag_mask == 1);\n-  __ andr(obj, obj, ~JNIHandles::weak_tag_mask);\n+  STATIC_ASSERT(JNIHandles::tag_mask == 0b11);\n+  __ andr(obj, obj, ~JNIHandles::tag_mask);\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shared\/barrierSetAssembler_aarch64.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -2460,1 +2460,3 @@\n-  Label done, not_weak;\n+  assert_different_registers(value, tmp1, tmp2);\n+  Label done, tagged, weak_tagged;\n+\n@@ -2462,0 +2464,7 @@\n+  tst(value, JNIHandles::tag_mask); \/\/ Test for tag.\n+  br(Assembler::NE, tagged);\n+\n+  \/\/ Resolve local handle\n+  access_load_at(T_OBJECT, IN_NATIVE | AS_RAW, value, Address(value, 0), tmp1, tmp2);\n+  verify_oop(value);\n+  b(done);\n@@ -2463,2 +2472,3 @@\n-  STATIC_ASSERT(JNIHandles::weak_tag_mask == 1u);\n-  tbz(value, 0, not_weak);    \/\/ Test for jweak tag.\n+  bind(tagged);\n+  STATIC_ASSERT(JNIHandles::TypeTag::weak_global == 0b1);\n+  tbnz(value, 0, weak_tagged);    \/\/ Test for weak tag.\n@@ -2466,3 +2476,2 @@\n-  \/\/ Resolve jweak.\n-  access_load_at(T_OBJECT, IN_NATIVE | ON_PHANTOM_OOP_REF, value,\n-                 Address(value, -JNIHandles::weak_tag_value), tmp1, tmp2);\n+  \/\/ Resolve global handle\n+  access_load_at(T_OBJECT, IN_NATIVE, value, Address(value, -JNIHandles::TypeTag::global), tmp1, tmp2);\n@@ -2472,3 +2481,4 @@\n-  bind(not_weak);\n-  \/\/ Resolve (untagged) jobject.\n-  access_load_at(T_OBJECT, IN_NATIVE, value, Address(value, 0), tmp1, tmp2);\n+  bind(weak_tagged);\n+  \/\/ Resolve jweak.\n+  access_load_at(T_OBJECT, IN_NATIVE | ON_PHANTOM_OOP_REF,\n+                 value, Address(value, -JNIHandles::TypeTag::weak_global), tmp1, tmp2);\n@@ -2476,0 +2486,24 @@\n+\n+  bind(done);\n+}\n+\n+void MacroAssembler::resolve_global_jobject(Register value, Register tmp1, Register tmp2) {\n+  assert_different_registers(value, tmp1, tmp2);\n+  Label done;\n+\n+  cbz(value, done);           \/\/ Use NULL as-is.\n+\n+#ifdef ASSERT\n+  {\n+    STATIC_ASSERT(JNIHandles::TypeTag::global == 0b10);\n+    Label valid_global_tag;\n+    tbnz(value, 1, valid_global_tag); \/\/ Test for global tag\n+    stop(\"non global jobject using resolve_global_jobject\");\n+    bind(valid_global_tag);\n+  }\n+#endif\n+\n+  \/\/ Resolve global handle\n+  access_load_at(T_OBJECT, IN_NATIVE, value, Address(value, -JNIHandles::TypeTag::global), tmp1, tmp2);\n+  verify_oop(value);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":44,"deletions":10,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -826,0 +826,1 @@\n+  void resolve_global_jobject(Register value, Register tmp1, Register tmp2);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -6923,6 +6923,1 @@\n-    Label null_jobject;\n-    __ cbz(r0, null_jobject);\n-    DecoratorSet decorators = ACCESS_READ | IN_NATIVE;\n-    BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n-    bs->load_at(_masm, decorators, T_OBJECT, r0, Address(r0, 0), rscratch1, rscratch2);\n-    __ bind(null_jobject);\n+    __ resolve_global_jobject(r0, rscratch1, rscratch2);\n@@ -6943,1 +6938,1 @@\n-    int insts_size = 512;\n+    int insts_size = 1024;\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -116,1 +116,1 @@\n-  __ bic(R1, R1, JNIHandles::weak_tag_mask);\n+  __ bic(R1, R1, JNIHandles::tag_mask);\n","filename":"src\/hotspot\/cpu\/arm\/jniFastGetField_arm.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1287,4 +1287,1 @@\n-  Label done, not_weak;\n-  cbz(value, done);             \/\/ Use NULL as-is.\n-  STATIC_ASSERT(JNIHandles::weak_tag_mask == 1u);\n-  tbz(value, 0, not_weak);      \/\/ Test for jweak tag.\n+  Label done, tagged, weak_tagged;\n@@ -1292,0 +1289,19 @@\n+  cbz(value, done);           \/\/ Use NULL as-is.\n+  tst(value, JNIHandles::tag_mask); \/\/ Test for tag.\n+  b(tagged, ne);\n+\n+  \/\/ Resolve local handle\n+  access_load_at(T_OBJECT, IN_NATIVE | AS_RAW, Address(value, 0), value, tmp1, tmp2, noreg);\n+  verify_oop(value);\n+  b(done);\n+\n+  bind(tagged);\n+  tst(value, JNIHandles::TypeTag::weak_global); \/\/ Test for weak tag.\n+  b(weak_tagged, ne);\n+\n+  \/\/ Resolve global handle\n+  access_load_at(T_OBJECT, IN_NATIVE, Address(value, -JNIHandles::TypeTag::global), value, tmp1, tmp2, noreg);\n+  verify_oop(value);\n+  b(done);\n+\n+  bind(weak_tagged);\n@@ -1294,6 +1310,1 @@\n-                 Address(value, -JNIHandles::weak_tag_value), value, tmp1, tmp2, noreg);\n-  b(done);\n-  bind(not_weak);\n-  \/\/ Resolve (untagged) jobject.\n-  access_load_at(T_OBJECT, IN_NATIVE,\n-                 Address(value, 0), value, tmp1, tmp2, noreg);\n+                 Address(value, -JNIHandles::TypeTag::weak_global), value, tmp1, tmp2, noreg);\n@@ -1301,0 +1312,26 @@\n+\n+  bind(done);\n+}\n+\n+void MacroAssembler::resolve_global_jobject(Register value,\n+                                     Register tmp1,\n+                                     Register tmp2) {\n+  assert_different_registers(value, tmp1, tmp2);\n+  Label done;\n+\n+  cbz(value, done);           \/\/ Use NULL as-is.\n+\n+#ifdef ASSERT\n+  {\n+    Label valid_global_tag;\n+    tst(value, JNIHandles::TypeTag::global); \/\/ Test for global tag.\n+    b(valid_global_tag, ne);\n+    stop(\"non global jobject using resolve_global_jobject\");\n+    bind(valid_global_tag);\n+  }\n+#endif\n+\n+  \/\/ Resolve global handle\n+  access_load_at(T_OBJECT, IN_NATIVE, Address(value, -JNIHandles::TypeTag::global), value, tmp1, tmp2, noreg);\n+  verify_oop(value);\n+\n","filename":"src\/hotspot\/cpu\/arm\/macroAssembler_arm.cpp","additions":48,"deletions":11,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -359,0 +359,1 @@\n+  void resolve_global_jobject(Register value, Register tmp1, Register tmp2);\n","filename":"src\/hotspot\/cpu\/arm\/macroAssembler_arm.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -3008,7 +3008,1 @@\n-    Label L_null_jobject;\n-    __ cbz(R0, L_null_jobject);\n-\n-    BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n-    bs->load_at(masm, ACCESS_READ | IN_NATIVE, T_OBJECT, R0, Address(R0, 0), Rtemp, R1, R2);\n-\n-    __ bind(L_null_jobject);\n+    __ resolve_global_jobject(R0, Rtemp, R1);\n","filename":"src\/hotspot\/cpu\/arm\/stubGenerator_arm.cpp","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -380,2 +380,2 @@\n-  __ clrrdi(tmp1, value, JNIHandles::weak_tag_size);\n-  __ andi_(tmp2, value, JNIHandles::weak_tag_mask);\n+  __ clrrdi(tmp1, value, JNIHandles::tag_size);\n+  __ andi_(tmp2, value, JNIHandles::TypeTag::weak_global);\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/g1\/g1BarrierSetAssembler_ppc.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -118,1 +118,1 @@\n-  Label done, not_weak, verify;\n+  Label done, tagged, weak_tagged, verify;\n@@ -122,2 +122,2 @@\n-  __ andi_(tmp1, value, JNIHandles::weak_tag_mask);\n-  __ beq(CCR0, not_weak);     \/\/ Test for jweak tag.\n+  __ andi_(tmp1, value, JNIHandles::tag_mask);\n+  __ bne(CCR0, tagged);       \/\/ Test for tag.\n@@ -125,4 +125,2 @@\n-  \/\/ Resolve (untagged) jobject.\n-  __ clrrdi(value, value, JNIHandles::weak_tag_size);\n-  load_at(masm, IN_NATIVE | ON_PHANTOM_OOP_REF, T_OBJECT,\n-          value, (intptr_t)0, value, tmp1, tmp2, preservation_level);\n+  __ access_load_at(T_OBJECT, IN_NATIVE | AS_RAW, \/\/ no uncoloring\n+                    value, (intptr_t)0, value, tmp1, tmp2, preservation_level);\n@@ -131,3 +129,12 @@\n-  __ bind(not_weak);\n-  load_at(masm, IN_NATIVE, T_OBJECT,\n-          value, (intptr_t)0, value, tmp1, tmp2, preservation_level);\n+  __ bind(tagged);\n+  __ andi_(tmp1, value, JNIHandles::TypeTag::weak_global);\n+  __ clrrdi(value, value, JNIHandles::tag_size); \/\/ Untag.\n+  __ bne(CCR0, weak_tagged);   \/\/ Test for jweak tag.\n+\n+  __ access_load_at(T_OBJECT, IN_NATIVE,\n+                    value, (intptr_t)0, value, tmp1, tmp2, preservation_level);\n+  __ b(verify);\n+\n+  __ bind(weak_tagged);\n+  __ access_load_at(T_OBJECT, IN_NATIVE | ON_PHANTOM_OOP_REF,\n+                    value, (intptr_t)0, value, tmp1, tmp2, preservation_level);\n@@ -140,0 +147,27 @@\n+\/\/ Generic implementation. GCs can provide an optimized one.\n+void BarrierSetAssembler::resolve_global_jobject(MacroAssembler* masm, Register value,\n+                                          Register tmp1, Register tmp2,\n+                                          MacroAssembler::PreservationLevel preservation_level) {\n+  Label done;\n+\n+  __ cmpdi(CCR0, value, 0);\n+  __ beq(CCR0, done);         \/\/ Use NULL as-is.\n+\n+#ifdef ASSERT\n+  {\n+    Label valid_global_tag;\n+    __ andi_(tmp1, value, JNIHandles::TypeTag::global);\n+    __ bne(CCR0, valid_global_tag);       \/\/ Test for global tag.\n+    __ stop(\"non global jobject using resolve_global_jobject\");\n+    __ bind(valid_global_tag);\n+  }\n+#endif\n+\n+  __ clrrdi(value, value, JNIHandles::tag_size); \/\/ Untag.\n+  __ access_load_at(T_OBJECT, IN_NATIVE,\n+                    value, (intptr_t)0, value, tmp1, tmp2, preservation_level);\n+  __ verify_oop(value, FILE_AND_LINE);\n+\n+  __ bind(done);\n+}\n+\n@@ -142,1 +176,1 @@\n-  __ clrrdi(dst, obj, JNIHandles::weak_tag_size);\n+  __ clrrdi(dst, obj, JNIHandles::tag_size);\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shared\/barrierSetAssembler_ppc.cpp","additions":46,"deletions":12,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,0 +59,3 @@\n+  virtual void resolve_global_jobject(MacroAssembler* masm, Register value,\n+                                      Register tmp1, Register tmp2,\n+                                      MacroAssembler::PreservationLevel preservation_level);\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shared\/barrierSetAssembler_ppc.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -87,1 +87,1 @@\n-  __ clrrdi(tmp1, value, JNIHandles::weak_tag_size);\n+  __ clrrdi(tmp1, value, JNIHandles::tag_size);\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shared\/modRefBarrierSetAssembler_ppc.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -2894,0 +2894,6 @@\n+void MacroAssembler::resolve_global_jobject(Register value, Register tmp1, Register tmp2,\n+                                     MacroAssembler::PreservationLevel preservation_level) {\n+  BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n+  bs->resolve_global_jobject(this, value, tmp1, tmp2, preservation_level);\n+}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -664,0 +664,2 @@\n+  void resolve_global_jobject(Register value, Register tmp1, Register tmp2,\n+                              MacroAssembler::PreservationLevel preservation_level);\n@@ -701,1 +703,0 @@\n- private:\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -4631,7 +4631,1 @@\n-    Label null_jobject;\n-    __ cmpdi(CCR0, R3_RET, 0);\n-    __ beq(CCR0, null_jobject);\n-    DecoratorSet decorators = ACCESS_READ | IN_NATIVE;\n-    BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n-    bs->load_at(_masm, decorators, T_OBJECT, R3_RET \/*base*\/, (intptr_t)0, R3_RET \/*dst*\/, tmp1, tmp2, MacroAssembler::PRESERVATION_NONE);\n-    __ bind(null_jobject);\n+    __ resolve_global_jobject(R3_RET, tmp1, tmp2, MacroAssembler::PRESERVATION_NONE);\n","filename":"src\/hotspot\/cpu\/ppc\/stubGenerator_ppc.cpp","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -125,2 +125,2 @@\n-  STATIC_ASSERT(JNIHandles::weak_tag_mask == 1);\n-  __ andi(obj, obj, ~JNIHandles::weak_tag_mask);\n+  STATIC_ASSERT(JNIHandles::tag_mask == 3);\n+  __ andi(obj, obj, ~JNIHandles::tag_mask);\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shared\/barrierSetAssembler_riscv.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -553,1 +553,3 @@\n-  Label done, not_weak;\n+  assert_different_registers(value, tmp1, tmp2);\n+  Label done, tagged, weak_tagged;\n+\n@@ -555,0 +557,3 @@\n+  \/\/ Test for tag.\n+  andi(t0, value, JNIHandles::tag_mask);\n+  bnez(t0, tagged);\n@@ -556,0 +561,6 @@\n+  \/\/ Resolve local handle\n+  access_load_at(T_OBJECT, IN_NATIVE | AS_RAW, value, Address(value, 0), tmp1, tmp2);\n+  verify_oop(value);\n+  j(done);\n+\n+  bind(tagged);\n@@ -557,2 +568,7 @@\n-  andi(t0, value, JNIHandles::weak_tag_mask);\n-  beqz(t0, not_weak);\n+  andi(t0, value, JNIHandles::TypeTag::weak_global);\n+  bnez(t0, weak_tagged);\n+\n+  \/\/ Resolve global handle\n+  access_load_at(T_OBJECT, IN_NATIVE, value,\n+                 Address(value, -JNIHandles::TypeTag::global), tmp1, tmp2);\n+  j(done);\n@@ -560,0 +576,1 @@\n+  bind(weak_tagged);\n@@ -562,1 +579,1 @@\n-                 Address(value, -JNIHandles::weak_tag_value), tmp1, tmp2);\n+                 Address(value, -JNIHandles::TypeTag::weak_global), tmp1, tmp2);\n@@ -564,1 +581,0 @@\n-  j(done);\n@@ -566,3 +582,22 @@\n-  bind(not_weak);\n-  \/\/ Resolve (untagged) jobject.\n-  access_load_at(T_OBJECT, IN_NATIVE, value, Address(value, 0), tmp1, tmp2);\n+  bind(done);\n+}\n+\n+void MacroAssembler::resolve_global_jobject(Register value, Register tmp1, Register tmp2) {\n+  assert_different_registers(value, tmp1, tmp2);\n+  Label done;\n+\n+  beqz(value, done);           \/\/ Use NULL as-is.\n+\n+#ifdef ASSERT\n+  {\n+    Label valid_global_tag;\n+    andi(t0, value, JNIHandles::TypeTag::global); \/\/ Test for global tag.\n+    bnez(t0, valid_global_tag);\n+    stop(\"non global jobject using resolve_global_jobject\");\n+    bind(valid_global_tag);\n+  }\n+#endif\n+\n+  \/\/ Resolve global handle\n+  access_load_at(T_OBJECT, IN_NATIVE, value,\n+                 Address(value, -JNIHandles::TypeTag::global), tmp1, tmp2);\n@@ -570,0 +605,1 @@\n+\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":45,"deletions":9,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -184,0 +184,1 @@\n+  void resolve_global_jobject(Register value, Register tmp1, Register tmp2);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -3982,6 +3982,1 @@\n-    Label null_jobject;\n-    __ beqz(x10, null_jobject);\n-    DecoratorSet decorators = ACCESS_READ | IN_NATIVE;\n-    BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n-    bs->load_at(_masm, decorators, T_OBJECT, x10, Address(x10, 0), t0, t1);\n-    __ bind(null_jobject);\n+    __ resolve_global_jobject(x10, t0, t1);\n@@ -3989,1 +3984,0 @@\n-\n@@ -4015,0 +4009,1 @@\n+\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -400,1 +400,1 @@\n-  __ z_nill(value, ~JNIHandles::weak_tag_mask);\n+  __ z_nill(value, ~JNIHandles::tag_mask);\n@@ -403,1 +403,1 @@\n-  __ z_tmll(tmp1, JNIHandles::weak_tag_mask); \/\/ Test for jweak tag.\n+  __ z_tmll(tmp1, JNIHandles::TypeTag::weak_global); \/\/ Test for jweak tag.\n","filename":"src\/hotspot\/cpu\/s390\/gc\/g1\/g1BarrierSetAssembler_s390.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -113,1 +113,1 @@\n-  __ z_nill(value, ~JNIHandles::weak_tag_mask);\n+  __ z_nill(value, ~JNIHandles::tag_mask);\n@@ -122,1 +122,1 @@\n-  __ z_nill(obj, ~JNIHandles::weak_tag_mask);\n+  __ z_nill(obj, ~JNIHandles::tag_mask);\n","filename":"src\/hotspot\/cpu\/s390\/gc\/shared\/barrierSetAssembler_s390.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -200,1 +200,1 @@\n-  __ clear_jweak_tag(obj);\n+  __ clear_jobject_tag(obj);\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shared\/barrierSetAssembler_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -96,1 +96,1 @@\n-  __ clear_jweak_tag(rdx);\n+  __ clear_jobject_tag(rdx);\n@@ -217,1 +217,1 @@\n-  __ clear_jweak_tag(rdx);\n+  __ clear_jobject_tag(rdx);\n@@ -307,1 +307,1 @@\n-  __ clear_jweak_tag(rdx);\n+  __ clear_jobject_tag(rdx);\n","filename":"src\/hotspot\/cpu\/x86\/jniFastGetField_x86_32.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-#define BUFFER_SIZE 30*wordSize\n+#define BUFFER_SIZE 40*wordSize\n","filename":"src\/hotspot\/cpu\/x86\/jniFastGetField_x86_64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -3876,3 +3876,3 @@\n-void MacroAssembler::clear_jweak_tag(Register possibly_jweak) {\n-  const int32_t inverted_jweak_mask = ~static_cast<int32_t>(JNIHandles::weak_tag_mask);\n-  STATIC_ASSERT(inverted_jweak_mask == -2); \/\/ otherwise check this code\n+void MacroAssembler::clear_jobject_tag(Register possibly_non_local) {\n+  const int32_t inverted_mask = ~static_cast<int32_t>(JNIHandles::tag_mask);\n+  STATIC_ASSERT(inverted_mask == -4); \/\/ otherwise check this code\n@@ -3880,1 +3880,1 @@\n-  andptr(possibly_jweak, inverted_jweak_mask);\n+  andptr(possibly_non_local, inverted_mask);\n@@ -3887,1 +3887,1 @@\n-  Label done, not_weak;\n+  Label done, tagged, weak_tagged;\n@@ -3889,3 +3889,19 @@\n-  jcc(Assembler::zero, done);                \/\/ Use NULL as-is.\n-  testptr(value, JNIHandles::weak_tag_mask); \/\/ Test for jweak tag.\n-  jcc(Assembler::zero, not_weak);\n+  jcc(Assembler::zero, done);           \/\/ Use NULL as-is.\n+  testptr(value, JNIHandles::tag_mask); \/\/ Test for tag.\n+  jcc(Assembler::notZero, tagged);\n+\n+  \/\/ Resolve local handle\n+  access_load_at(T_OBJECT, IN_NATIVE | AS_RAW, value, Address(value, 0), tmp, thread);\n+  verify_oop(value);\n+  jmp(done);\n+\n+  bind(tagged);\n+  testptr(value, JNIHandles::TypeTag::weak_global); \/\/ Test for weak tag.\n+  jcc(Assembler::notZero, weak_tagged);\n+\n+  \/\/ Resolve global handle\n+  access_load_at(T_OBJECT, IN_NATIVE, value, Address(value, -JNIHandles::TypeTag::global), tmp, thread);\n+  verify_oop(value);\n+  jmp(done);\n+\n+  bind(weak_tagged);\n@@ -3894,1 +3910,1 @@\n-                 value, Address(value, -JNIHandles::weak_tag_value), tmp, thread);\n+                 value, Address(value, -JNIHandles::TypeTag::weak_global), tmp, thread);\n@@ -3896,4 +3912,25 @@\n-  jmp(done);\n-  bind(not_weak);\n-  \/\/ Resolve (untagged) jobject.\n-  access_load_at(T_OBJECT, IN_NATIVE, value, Address(value, 0), tmp, thread);\n+\n+  bind(done);\n+}\n+\n+void MacroAssembler::resolve_global_jobject(Register value,\n+                                            Register thread,\n+                                            Register tmp) {\n+  assert_different_registers(value, thread, tmp);\n+  Label done;\n+\n+  testptr(value, value);\n+  jcc(Assembler::zero, done);           \/\/ Use NULL as-is.\n+\n+#ifdef ASSERT\n+  {\n+    Label valid_global_tag;\n+    testptr(value, JNIHandles::TypeTag::global); \/\/ Test for global tag.\n+    jcc(Assembler::notZero, valid_global_tag);\n+    stop(\"non global jobject using resolve_global_jobject\");\n+    bind(valid_global_tag);\n+  }\n+#endif\n+\n+  \/\/ Resolve global handle\n+  access_load_at(T_OBJECT, IN_NATIVE, value, Address(value, -JNIHandles::TypeTag::global), tmp, thread);\n@@ -3901,0 +3938,1 @@\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":52,"deletions":14,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -329,1 +329,1 @@\n-  void clear_jweak_tag(Register possibly_jweak);\n+  void clear_jobject_tag(Register possibly_non_local);\n@@ -331,0 +331,1 @@\n+  void resolve_global_jobject(Register value, Register thread, Register tmp);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -4014,7 +4014,1 @@\n-    Label null_jobject;\n-    __ testptr(rax, rax);\n-    __ jcc(Assembler::zero, null_jobject);\n-    DecoratorSet decorators = ACCESS_READ | IN_NATIVE;\n-    BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n-    bs->load_at(masm, decorators, T_OBJECT, rax, Address(rax, 0), noreg, java_thread);\n-    __ bind(null_jobject);\n+    __ resolve_global_jobject(rax, java_thread, rdx);\n@@ -4039,1 +4033,1 @@\n-    int insts_size = 512;\n+    int insts_size = 1024;\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_32.cpp","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -3507,1 +3507,1 @@\n-  CodeBuffer code(\"jfr_write_checkpoint\", 512, 64);\n+  CodeBuffer code(\"jfr_write_checkpoint\", 1024, 64);\n@@ -3522,8 +3522,1 @@\n-  Label L_null_jobject;\n-  __ testptr(rax, rax);\n-  __ jcc(Assembler::zero, L_null_jobject);\n-\n-  BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n-  bs->load_at(_masm, ACCESS_READ | IN_NATIVE, T_OBJECT, rax, Address(rax, 0), c_rarg0, r15_thread);\n-\n-  __ bind(L_null_jobject);\n+  __ resolve_global_jobject(rax, r15_thread, c_rarg0);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":3,"deletions":10,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1116,1 +1116,2 @@\n-        initialize_immediate_oop(dest, cast_from_oop<jobject>(*dest));\n+        jobject obj = *reinterpret_cast<jobject*>(dest);\n+        initialize_immediate_oop(dest, obj);\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -179,1 +179,1 @@\n-  return _method_holder != NULL && JNIHandles::is_weak_global_handle(_method_holder) && JNIHandles::is_global_weak_cleared(_method_holder);\n+  return _method_holder != NULL && JNIHandles::is_weak_global_handle(_method_holder) && JNIHandles::is_weak_global_cleared(_method_holder);\n","filename":"src\/hotspot\/share\/compiler\/compileTask.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,0 +54,1 @@\n+#include \"runtime\/jniHandles.inline.hpp\"\n@@ -3124,1 +3125,2 @@\n-  Node* event_writer = access_load(jobj, xtype, T_OBJECT, IN_NATIVE | C2_CONTROL_DEPENDENT_LOAD);\n+  Node* jobj_untagged = _gvn.transform(new AddPNode(top(), jobj, _gvn.MakeConX(-JNIHandles::TypeTag::global)));\n+  Node* event_writer = access_load(jobj_untagged, xtype, T_OBJECT, IN_NATIVE | C2_CONTROL_DEPENDENT_LOAD);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,0 +69,1 @@\n+    STATIC_ASSERT(TypeTag::local == 0);\n@@ -94,1 +95,1 @@\n-      assert(*ptr == NULL, \"invariant\");\n+      assert(NativeAccess<AS_NO_KEEPALIVE>::oop_load(ptr) == oop(NULL), \"invariant\");\n@@ -96,1 +97,2 @@\n-      res = reinterpret_cast<jobject>(ptr);\n+      char* tptr = reinterpret_cast<char*>(ptr) + TypeTag::global;\n+      res = reinterpret_cast<jobject>(tptr);\n@@ -105,1 +107,1 @@\n-jobject JNIHandles::make_weak_global(Handle obj, AllocFailType alloc_failmode) {\n+jweak JNIHandles::make_weak_global(Handle obj, AllocFailType alloc_failmode) {\n@@ -108,1 +110,1 @@\n-  jobject res = NULL;\n+  jweak res = NULL;\n@@ -115,1 +117,1 @@\n-      assert(*ptr == NULL, \"invariant\");\n+      assert(NativeAccess<AS_NO_KEEPALIVE>::oop_load(ptr) == oop(NULL), \"invariant\");\n@@ -117,2 +119,2 @@\n-      char* tptr = reinterpret_cast<char*>(ptr) + weak_tag_value;\n-      res = reinterpret_cast<jobject>(tptr);\n+      char* tptr = reinterpret_cast<char*>(ptr) + TypeTag::weak_global;\n+      res = reinterpret_cast<jweak>(tptr);\n@@ -138,1 +140,1 @@\n-bool JNIHandles::is_global_weak_cleared(jweak handle) {\n+bool JNIHandles::is_weak_global_cleared(jweak handle) {\n@@ -140,2 +142,1 @@\n-  assert(is_jweak(handle), \"not a weak handle\");\n-  oop* oop_ptr = jweak_ptr(handle);\n+  oop* oop_ptr = weak_global_ptr(handle);\n@@ -148,2 +149,1 @@\n-    assert(!is_jweak(handle), \"wrong method for destroying jweak\");\n-    oop* oop_ptr = jobject_ptr(handle);\n+    oop* oop_ptr = global_ptr(handle);\n@@ -156,1 +156,1 @@\n-void JNIHandles::destroy_weak_global(jobject handle) {\n+void JNIHandles::destroy_weak_global(jweak handle) {\n@@ -158,2 +158,1 @@\n-    assert(is_jweak(handle), \"JNI handle not jweak\");\n-    oop* oop_ptr = jweak_ptr(handle);\n+    oop* oop_ptr = weak_global_ptr(handle);\n@@ -187,2 +186,2 @@\n-  if (is_jweak(handle)) {\n-    if (is_storage_handle(weak_global_handles(), jweak_ptr(handle))) {\n+  if (is_weak_global_tagged(handle)) {\n+    if (is_storage_handle(weak_global_handles(), weak_global_ptr(handle))) {\n@@ -191,2 +190,2 @@\n-  } else {\n-    switch (global_handles()->allocation_status(jobject_ptr(handle))) {\n+  } else if (is_global_tagged(handle)) {\n+    switch (global_handles()->allocation_status(global_ptr(handle))) {\n@@ -200,7 +199,0 @@\n-    case OopStorage::INVALID_ENTRY:\n-      \/\/ Not in global storage.  Might be a local handle.\n-      if (is_local_handle(thread, handle) || is_frame_handle(thread, handle)) {\n-        result = JNILocalRefType;\n-      }\n-      break;\n-\n@@ -210,0 +202,7 @@\n+  } else {\n+    \/\/ Not in global storage.  Might be a local handle.\n+    if (is_local_handle(thread, handle) || is_frame_handle(thread, handle)) {\n+      result = JNILocalRefType;\n+    } else {\n+      ShouldNotReachHere();\n+    }\n@@ -246,1 +245,2 @@\n-  return !is_jweak(handle) && is_storage_handle(global_handles(), jobject_ptr(handle));\n+  assert(!is_global_tagged(handle) || is_storage_handle(global_handles(), global_ptr(handle)), \"invalid storage\");\n+  return is_global_tagged(handle);\n@@ -252,1 +252,2 @@\n-  return is_jweak(handle) && is_storage_handle(weak_global_handles(), jweak_ptr(handle));\n+  assert(!is_weak_global_tagged(handle) || is_storage_handle(weak_global_handles(), weak_global_ptr(handle)), \"invalid storage\");\n+  return is_weak_global_tagged(handle);\n@@ -458,1 +459,1 @@\n-    NativeAccess<IS_DEST_UNINITIALIZED>::oop_store(handle, obj);\n+    *handle = obj;\n@@ -466,1 +467,1 @@\n-    NativeAccess<IS_DEST_UNINITIALIZED>::oop_store(handle, obj);\n+    *handle = obj;\n","filename":"src\/hotspot\/share\/runtime\/jniHandles.cpp","additions":32,"deletions":31,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,3 +48,6 @@\n-  inline static bool is_jweak(jobject handle);\n-  inline static oop* jobject_ptr(jobject handle); \/\/ NOT jweak!\n-  inline static oop* jweak_ptr(jobject handle);\n+  inline static bool is_local_tagged(jobject handle);\n+  inline static bool is_weak_global_tagged(jobject handle);\n+  inline static bool is_global_tagged(jobject handle);\n+  inline static oop* local_ptr(jobject handle);\n+  inline static oop* global_ptr(jobject handle);\n+  inline static oop* weak_global_ptr(jweak handle);\n@@ -62,12 +65,18 @@\n-  \/\/ Low tag bit in jobject used to distinguish a jweak.  jweak is\n-  \/\/ type equivalent to jobject, but there are places where we need to\n-  \/\/ be able to distinguish jweak values from other jobjects, and\n-  \/\/ is_weak_global_handle is unsuitable for performance reasons.  To\n-  \/\/ provide such a test we add weak_tag_value to the (aligned) byte\n-  \/\/ address designated by the jobject to produce the corresponding\n-  \/\/ jweak.  Accessing the value of a jobject must account for it\n-  \/\/ being a possibly offset jweak.\n-  static const uintptr_t weak_tag_size = 1;\n-  static const uintptr_t weak_tag_alignment = (1u << weak_tag_size);\n-  static const uintptr_t weak_tag_mask = weak_tag_alignment - 1;\n-  static const int weak_tag_value = 1;\n+  \/\/ Low tag bits in jobject used to distinguish its type. Checking\n+  \/\/ the underlying storage type is unsuitable for performance reasons.\n+  enum TypeTag {\n+    local = 0b00,\n+    weak_global = 0b01,\n+    global = 0b10,\n+  };\n+\n+private:\n+  inline static bool is_tagged_with(jobject handle, TypeTag tag);\n+\n+public:\n+  static const uintptr_t tag_size = 2;\n+  static const uintptr_t tag_mask = ((1u << tag_size) - 1u);\n+\n+  STATIC_ASSERT((TypeTag::local & tag_mask) == TypeTag::local);\n+  STATIC_ASSERT((TypeTag::weak_global & tag_mask) == TypeTag::weak_global);\n+  STATIC_ASSERT((TypeTag::global & tag_mask) == TypeTag::global);\n@@ -97,4 +106,4 @@\n-  static jobject make_weak_global(Handle obj,\n-                                  AllocFailType alloc_failmode = AllocFailStrategy::EXIT_OOM);\n-  static void destroy_weak_global(jobject handle);\n-  static bool is_global_weak_cleared(jweak handle); \/\/ Test jweak without resolution\n+  static jweak make_weak_global(Handle obj,\n+                                AllocFailType alloc_failmode = AllocFailStrategy::EXIT_OOM);\n+  static void destroy_weak_global(jweak handle);\n+  static bool is_weak_global_cleared(jweak handle); \/\/ Test jweak without resolution\n","filename":"src\/hotspot\/share\/runtime\/jniHandles.hpp","additions":29,"deletions":20,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,4 +35,2 @@\n-inline bool JNIHandles::is_jweak(jobject handle) {\n-  STATIC_ASSERT(weak_tag_size == 1);\n-  STATIC_ASSERT(weak_tag_value == 1);\n-  return (reinterpret_cast<uintptr_t>(handle) & weak_tag_mask) != 0;\n+inline bool JNIHandles::is_tagged_with(jobject handle, TypeTag tag) {\n+  return (reinterpret_cast<uintptr_t>(handle) & tag_mask) == tag;\n@@ -41,2 +39,15 @@\n-inline oop* JNIHandles::jobject_ptr(jobject handle) {\n-  assert(!is_jweak(handle), \"precondition\");\n+inline bool JNIHandles::is_local_tagged(jobject handle) {\n+  return is_tagged_with(handle, TypeTag::local);\n+}\n+\n+inline bool JNIHandles::is_weak_global_tagged(jobject handle) {\n+  return is_tagged_with(handle, TypeTag::weak_global);\n+}\n+\n+inline bool JNIHandles::is_global_tagged(jobject handle) {\n+  return is_tagged_with(handle, TypeTag::global);\n+}\n+\n+inline oop* JNIHandles::local_ptr(jobject handle) {\n+  assert(is_local_tagged(handle), \"precondition\");\n+  STATIC_ASSERT(TypeTag::local == 0);\n@@ -46,3 +57,9 @@\n-inline oop* JNIHandles::jweak_ptr(jobject handle) {\n-  assert(is_jweak(handle), \"precondition\");\n-  char* ptr = reinterpret_cast<char*>(handle) - weak_tag_value;\n+inline oop* JNIHandles::global_ptr(jobject handle) {\n+  assert(is_global_tagged(handle), \"precondition\");\n+  char* ptr = reinterpret_cast<char*>(handle) - TypeTag::global;\n+  return reinterpret_cast<oop*>(ptr);\n+}\n+\n+inline oop* JNIHandles::weak_global_ptr(jweak handle) {\n+  assert(is_weak_global_tagged(handle), \"precondition\");\n+  char* ptr = reinterpret_cast<char*>(handle) - TypeTag::weak_global;\n@@ -58,2 +75,7 @@\n-  if (is_jweak(handle)) {       \/\/ Unlikely\n-    result = NativeAccess<ON_PHANTOM_OOP_REF|decorators>::oop_load(jweak_ptr(handle));\n+  if (is_weak_global_tagged(handle)) {       \/\/ Unlikely\n+    result = NativeAccess<ON_PHANTOM_OOP_REF|decorators>::oop_load(weak_global_ptr(handle));\n+  } else if (is_global_tagged(handle)) {\n+    result = NativeAccess<decorators>::oop_load(global_ptr(handle));\n+    \/\/ Construction of jobjects canonicalize a null value into a null\n+    \/\/ jobject, so for non-jweak the pointee should never be null.\n+    assert(external_guard || result != NULL, \"Invalid JNI handle\");\n@@ -61,1 +83,1 @@\n-    result = NativeAccess<decorators>::oop_load(jobject_ptr(handle));\n+    result = *local_ptr(handle);\n@@ -100,2 +122,1 @@\n-    assert(!is_jweak(handle), \"Invalid JNI local handle\");\n-    NativeAccess<>::oop_store(jobject_ptr(handle), (oop)NULL);\n+    *local_ptr(handle) = NULL;\n","filename":"src\/hotspot\/share\/runtime\/jniHandles.inline.hpp","additions":36,"deletions":15,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -2,0 +2,1 @@\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,2 +32,6 @@\n- * @run main\/othervm\/native -agentlib:FastGetField -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyJNIFields FastGetField\n- * @run main\/othervm\/native -agentlib:FastGetField -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyJNIFields -XX:+UnlockDiagnosticVMOptions -XX:+ForceUnreachable -XX:+SafepointALot -XX:GuaranteedSafepointInterval=1 FastGetField\n+ * @run main\/othervm\/native -agentlib:FastGetField -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyJNIFields FastGetField 0\n+ * @run main\/othervm\/native -agentlib:FastGetField -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyJNIFields FastGetField 1\n+ * @run main\/othervm\/native -agentlib:FastGetField -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyJNIFields FastGetField 2\n+ * @run main\/othervm\/native -agentlib:FastGetField -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyJNIFields -XX:+UnlockDiagnosticVMOptions -XX:+ForceUnreachable -XX:+SafepointALot -XX:GuaranteedSafepointInterval=1 FastGetField 0\n+ * @run main\/othervm\/native -agentlib:FastGetField -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyJNIFields -XX:+UnlockDiagnosticVMOptions -XX:+ForceUnreachable -XX:+SafepointALot -XX:GuaranteedSafepointInterval=1 FastGetField 1\n+ * @run main\/othervm\/native -agentlib:FastGetField -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyJNIFields -XX:+UnlockDiagnosticVMOptions -XX:+ForceUnreachable -XX:+SafepointALot -XX:GuaranteedSafepointInterval=1 FastGetField 2\n@@ -37,1 +42,0 @@\n-\n@@ -44,0 +48,2 @@\n+    public native void registerGlobal(MyItem i);\n+    public native void registerWeak(MyItem i);\n@@ -45,0 +51,1 @@\n+    public native long accessFieldsViaHandle();\n@@ -95,0 +102,27 @@\n+    private int mode;\n+    private MyItem obj;\n+\n+    private FastGetField(int mode) {\n+        this.mode = mode;\n+        this.obj = new MyItem();\n+\n+        if (mode == 0) {\n+            \/\/ Direct\n+        } else if (mode == 1) {\n+            registerGlobal(this.obj);\n+        } else if ( mode == 2) {\n+            registerWeak(this.obj);\n+        } else {\n+          throw new IllegalArgumentException(\"Unexpected mode\");\n+        }\n+    }\n+\n+    private long accessFields() {\n+        if (mode == 0) {\n+            return accessFields(obj);\n+        }\n+\n+        \/\/ Otherwise through a handle\n+        return accessFieldsViaHandle();\n+    }\n+\n@@ -96,1 +130,1 @@\n-        MyItem i = new MyItem();\n+\n@@ -101,4 +135,4 @@\n-            if (accessFields(i) != 0l) throw new RuntimeException(\"Wrong initial result!\");\n-            i.change_values();\n-            if (accessFields(i) != 8l) throw new RuntimeException(\"Wrong result after changing!\");\n-            i.reset_values();\n+            if (accessFields() != 0l) throw new RuntimeException(\"Wrong initial result!\");\n+            obj.change_values();\n+            if (accessFields() != 8l) throw new RuntimeException(\"Wrong result after changing!\");\n+            obj.reset_values();\n@@ -115,3 +149,3 @@\n-        if (accessFields(i) != 0l) throw new RuntimeException(\"Wrong initial result!\");\n-        i.change_values();\n-        if (accessFields(i) != 8l) throw new RuntimeException(\"Wrong result after changing!\");\n+        if (accessFields() != 0l) throw new RuntimeException(\"Wrong initial result!\");\n+        obj.change_values();\n+        if (accessFields() != 8l) throw new RuntimeException(\"Wrong result after changing!\");\n@@ -122,1 +156,7 @@\n-        FastGetField inst = new FastGetField();\n+        if (args.length != 1) {\n+           throw new IllegalArgumentException(\"Expected one argument\");\n+        }\n+\n+        int mode = Integer.parseInt(args[0]);\n+\n+        FastGetField inst = new FastGetField(mode);\n","filename":"test\/hotspot\/jtreg\/runtime\/jni\/FastGetField\/FastGetField.java","additions":52,"deletions":12,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -2,0 +2,1 @@\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +36,1 @@\n-\n+static jobject objHandle;\n@@ -66,0 +67,7 @@\n+JNIEXPORT void JNICALL Java_FastGetField_registerGlobal(JNIEnv *env, jobject this, jobject obj) {\n+  objHandle = (*env)->NewGlobalRef(env, obj);\n+}\n+\n+JNIEXPORT void JNICALL Java_FastGetField_registerWeak(JNIEnv *env, jobject this, jobject obj) {\n+  objHandle = (*env)->NewWeakGlobalRef(env, obj);\n+}\n@@ -79,0 +87,3 @@\n+JNIEXPORT jlong JNICALL Java_FastGetField_accessFieldsViaHandle(JNIEnv *env, jobject this) {\n+  return Java_FastGetField_accessFields(env, this, objHandle);\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/jni\/FastGetField\/libFastGetField.c","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"}]}