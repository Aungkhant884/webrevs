{"files":[{"patch":"@@ -125,2 +125,2 @@\n-  STATIC_ASSERT(JNIHandles::weak_tag_mask == 1);\n-  __ andr(obj, obj, ~JNIHandles::weak_tag_mask);\n+  STATIC_ASSERT(JNIHandles::tag_mask == 0b11);\n+  __ andr(obj, obj, ~JNIHandles::tag_mask);\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shared\/barrierSetAssembler_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2460,1 +2460,3 @@\n-  Label done, not_weak;\n+  assert_different_registers(value, tmp1, tmp2);\n+  Label done, tagged, weak_tagged;\n+\n@@ -2462,0 +2464,7 @@\n+  tst(value, JNIHandles::tag_mask); \/\/ Test for tag.\n+  br(Assembler::NE, tagged);\n+\n+  \/\/ Resolve local handle\n+  access_load_at(T_OBJECT, IN_NATIVE | AS_RAW, value, Address(value, 0), tmp1, tmp2);\n+  verify_oop(value);\n+  b(done);\n@@ -2463,2 +2472,3 @@\n-  STATIC_ASSERT(JNIHandles::weak_tag_mask == 1u);\n-  tbz(value, 0, not_weak);    \/\/ Test for jweak tag.\n+  bind(tagged);\n+  STATIC_ASSERT(JNIHandles::weak_tag_mask == 0b1);\n+  tbnz(value, 0, weak_tagged);    \/\/ Test for weak tag.\n@@ -2466,3 +2476,2 @@\n-  \/\/ Resolve jweak.\n-  access_load_at(T_OBJECT, IN_NATIVE | ON_PHANTOM_OOP_REF, value,\n-                 Address(value, -JNIHandles::weak_tag_value), tmp1, tmp2);\n+  \/\/ Resolve global handle\n+  access_load_at(T_OBJECT, IN_NATIVE, value, Address(value, -JNIHandles::global_tag_value), tmp1, tmp2);\n@@ -2472,3 +2481,4 @@\n-  bind(not_weak);\n-  \/\/ Resolve (untagged) jobject.\n-  access_load_at(T_OBJECT, IN_NATIVE, value, Address(value, 0), tmp1, tmp2);\n+  bind(weak_tagged);\n+  \/\/ Resolve jweak.\n+  access_load_at(T_OBJECT, IN_NATIVE | ON_PHANTOM_OOP_REF,\n+                 value, Address(value, -JNIHandles::weak_tag_value), tmp1, tmp2);\n@@ -2476,0 +2486,24 @@\n+\n+  bind(done);\n+}\n+\n+void MacroAssembler::resolve_global_jobject(Register value, Register tmp1, Register tmp2) {\n+  assert_different_registers(value, tmp1, tmp2);\n+  Label done;\n+\n+  cbz(value, done);           \/\/ Use NULL as-is.\n+\n+#ifdef ASSERT\n+  {\n+    STATIC_ASSERT(JNIHandles::global_tag_value == 0b10);\n+    Label valid_global_tag;\n+    tbnz(value, 1, valid_global_tag); \/\/ Test for global tag\n+    stop(\"non global jobject using resolve_global_jobject\");\n+    bind(valid_global_tag);\n+  }\n+#endif\n+\n+  \/\/ Resolve global handle\n+  access_load_at(T_OBJECT, IN_NATIVE, value, Address(value, -JNIHandles::global_tag_value), tmp1, tmp2);\n+  verify_oop(value);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":43,"deletions":9,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -826,0 +826,1 @@\n+  void resolve_global_jobject(Register value, Register tmp1, Register tmp2);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -6923,6 +6923,1 @@\n-    Label null_jobject;\n-    __ cbz(r0, null_jobject);\n-    DecoratorSet decorators = ACCESS_READ | IN_NATIVE;\n-    BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n-    bs->load_at(_masm, decorators, T_OBJECT, r0, Address(r0, 0), rscratch1, rscratch2);\n-    __ bind(null_jobject);\n+    __ resolve_global_jobject(r0, rscratch1, rscratch2);\n@@ -6943,1 +6938,1 @@\n-    int insts_size = 512;\n+    int insts_size = 1024;\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -116,1 +116,1 @@\n-  __ bic(R1, R1, JNIHandles::weak_tag_mask);\n+  __ bic(R1, R1, JNIHandles::tag_mask);\n","filename":"src\/hotspot\/cpu\/arm\/jniFastGetField_arm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1287,4 +1287,1 @@\n-  Label done, not_weak;\n-  cbz(value, done);             \/\/ Use NULL as-is.\n-  STATIC_ASSERT(JNIHandles::weak_tag_mask == 1u);\n-  tbz(value, 0, not_weak);      \/\/ Test for jweak tag.\n+  Label done, tagged, weak_tagged;\n@@ -1292,0 +1289,19 @@\n+  cbz(value, done);           \/\/ Use NULL as-is.\n+  tst(value, JNIHandles::tag_mask); \/\/ Test for tag.\n+  b(tagged, ne);\n+\n+  \/\/ Resolve local handle\n+  access_load_at(T_OBJECT, IN_NATIVE | AS_RAW, Address(value, 0), value, tmp1, tmp2, noreg);\n+  verify_oop(value);\n+  b(done);\n+\n+  bind(tagged);\n+  tst(value, JNIHandles::weak_tag_mask); \/\/ Test for weak tag.\n+  b(weak_tagged, ne);\n+\n+  \/\/ Resolve global handle\n+  access_load_at(T_OBJECT, IN_NATIVE, Address(value, -JNIHandles::global_tag_value), value, tmp1, tmp2, noreg);\n+  verify_oop(value);\n+  b(done);\n+\n+  bind(weak_tagged);\n@@ -1295,5 +1311,0 @@\n-  b(done);\n-  bind(not_weak);\n-  \/\/ Resolve (untagged) jobject.\n-  access_load_at(T_OBJECT, IN_NATIVE,\n-                 Address(value, 0), value, tmp1, tmp2, noreg);\n@@ -1301,0 +1312,26 @@\n+\n+  bind(done);\n+}\n+\n+void MacroAssembler::resolve_global_jobject(Register value,\n+                                     Register tmp1,\n+                                     Register tmp2) {\n+  assert_different_registers(value, tmp1, tmp2);\n+  Label done;\n+\n+  cbz(value, done);           \/\/ Use NULL as-is.\n+\n+#ifdef ASSERT\n+  {\n+    Label valid_global_tag;\n+    tst(value, JNIHandles::global_tag_value); \/\/ Test for global tag.\n+    b(valid_global_tag, ne);\n+    stop(\"non global jobject using resolve_global_jobject\");\n+    bind(valid_global_tag);\n+  }\n+#endif\n+\n+  \/\/ Resolve global handle\n+  access_load_at(T_OBJECT, IN_NATIVE, Address(value, -JNIHandles::global_tag_value), value, tmp1, tmp2, noreg);\n+  verify_oop(value);\n+\n","filename":"src\/hotspot\/cpu\/arm\/macroAssembler_arm.cpp","additions":46,"deletions":9,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -359,0 +359,1 @@\n+  void resolve_global_jobject(Register value, Register tmp1, Register tmp2);\n","filename":"src\/hotspot\/cpu\/arm\/macroAssembler_arm.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3008,7 +3008,1 @@\n-    Label L_null_jobject;\n-    __ cbz(R0, L_null_jobject);\n-\n-    BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n-    bs->load_at(masm, ACCESS_READ | IN_NATIVE, T_OBJECT, R0, Address(R0, 0), Rtemp, R1, R2);\n-\n-    __ bind(L_null_jobject);\n+    __ resolve_global_jobject(R0, Rtemp, R1);\n","filename":"src\/hotspot\/cpu\/arm\/stubGenerator_arm.cpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -380,1 +380,1 @@\n-  __ clrrdi(tmp1, value, JNIHandles::weak_tag_size);\n+  __ clrrdi(tmp1, value, JNIHandles::tag_size);\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/g1\/g1BarrierSetAssembler_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -118,1 +118,1 @@\n-  Label done, not_weak, verify;\n+  Label done, tagged, weak_tagged, verify;\n@@ -122,0 +122,8 @@\n+  __ andi_(tmp1, value, JNIHandles::tag_mask);\n+  __ bne(CCR0, tagged);       \/\/ Test for tag.\n+\n+  __ access_load_at(T_OBJECT, IN_NATIVE | AS_RAW, \/\/ no uncoloring\n+                    value, (intptr_t)0, value, tmp1, tmp2, preservation_level);\n+  __ b(verify);\n+\n+  __ bind(tagged);\n@@ -123,1 +131,2 @@\n-  __ beq(CCR0, not_weak);     \/\/ Test for jweak tag.\n+  __ clrrdi(value, value, JNIHandles::tag_size); \/\/ Untag.\n+  __ bne(CCR0, weak_tagged);   \/\/ Test for jweak tag.\n@@ -125,4 +134,2 @@\n-  \/\/ Resolve (untagged) jobject.\n-  __ clrrdi(value, value, JNIHandles::weak_tag_size);\n-  load_at(masm, IN_NATIVE | ON_PHANTOM_OOP_REF, T_OBJECT,\n-          value, (intptr_t)0, value, tmp1, tmp2, preservation_level);\n+  __ access_load_at(T_OBJECT, IN_NATIVE,\n+                    value, (intptr_t)0, value, tmp1, tmp2, preservation_level);\n@@ -131,3 +138,3 @@\n-  __ bind(not_weak);\n-  load_at(masm, IN_NATIVE, T_OBJECT,\n-          value, (intptr_t)0, value, tmp1, tmp2, preservation_level);\n+  __ bind(weak_tagged);\n+  __ access_load_at(T_OBJECT, IN_NATIVE | ON_PHANTOM_OOP_REF,\n+                    value, (intptr_t)0, value, tmp1, tmp2, preservation_level);\n@@ -140,0 +147,27 @@\n+\/\/ Generic implementation. GCs can provide an optimized one.\n+void BarrierSetAssembler::resolve_global_jobject(MacroAssembler* masm, Register value,\n+                                          Register tmp1, Register tmp2,\n+                                          MacroAssembler::PreservationLevel preservation_level) {\n+  Label done;\n+\n+  __ cmpdi(CCR0, value, 0);\n+  __ beq(CCR0, done);         \/\/ Use NULL as-is.\n+\n+#ifdef ASSERT\n+  {\n+    Label valid_global_tag;\n+    __ andi_(tmp1, value, JNIHandles::global_tag_value);\n+    __ bne(CCR0, valid_global_tag);       \/\/ Test for global tag.\n+    __ stop(\"non global jobject using resolve_global_jobject\");\n+    __ bind(valid_global_tag);\n+  }\n+#endif\n+\n+  __ clrrdi(value, value, JNIHandles::tag_size); \/\/ Untag.\n+  __ access_load_at(T_OBJECT, IN_NATIVE,\n+                    value, (intptr_t)0, value, tmp1, tmp2, preservation_level);\n+  __ verify_oop(value, FILE_AND_LINE);\n+\n+  __ bind(done);\n+}\n+\n@@ -142,1 +176,1 @@\n-  __ clrrdi(dst, obj, JNIHandles::weak_tag_size);\n+  __ clrrdi(dst, obj, JNIHandles::tag_size);\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shared\/barrierSetAssembler_ppc.cpp","additions":44,"deletions":10,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -59,0 +59,3 @@\n+  virtual void resolve_global_jobject(MacroAssembler* masm, Register value,\n+                                      Register tmp1, Register tmp2,\n+                                      MacroAssembler::PreservationLevel preservation_level);\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shared\/barrierSetAssembler_ppc.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-  __ clrrdi(tmp1, value, JNIHandles::weak_tag_size);\n+  __ clrrdi(tmp1, value, JNIHandles::tag_size);\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shared\/modRefBarrierSetAssembler_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2894,0 +2894,6 @@\n+void MacroAssembler::resolve_global_jobject(Register value, Register tmp1, Register tmp2,\n+                                     MacroAssembler::PreservationLevel preservation_level) {\n+  BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n+  bs->resolve_global_jobject(this, value, tmp1, tmp2, preservation_level);\n+}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -664,0 +664,2 @@\n+  void resolve_global_jobject(Register value, Register tmp1, Register tmp2,\n+                              MacroAssembler::PreservationLevel preservation_level);\n@@ -701,1 +703,0 @@\n- private:\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -4631,7 +4631,1 @@\n-    Label null_jobject;\n-    __ cmpdi(CCR0, R3_RET, 0);\n-    __ beq(CCR0, null_jobject);\n-    DecoratorSet decorators = ACCESS_READ | IN_NATIVE;\n-    BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n-    bs->load_at(_masm, decorators, T_OBJECT, R3_RET \/*base*\/, (intptr_t)0, R3_RET \/*dst*\/, tmp1, tmp2, MacroAssembler::PRESERVATION_NONE);\n-    __ bind(null_jobject);\n+    __ resolve_global_jobject(R3_RET, tmp1, tmp2, MacroAssembler::PRESERVATION_NONE);\n","filename":"src\/hotspot\/cpu\/ppc\/stubGenerator_ppc.cpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -125,2 +125,2 @@\n-  STATIC_ASSERT(JNIHandles::weak_tag_mask == 1);\n-  __ andi(obj, obj, ~JNIHandles::weak_tag_mask);\n+  STATIC_ASSERT(JNIHandles::tag_mask == 3);\n+  __ andi(obj, obj, ~JNIHandles::tag_mask);\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shared\/barrierSetAssembler_riscv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -553,1 +553,3 @@\n-  Label done, not_weak;\n+  assert_different_registers(value, tmp1, tmp2);\n+  Label done, tagged, weak_tagged;\n+\n@@ -555,0 +557,3 @@\n+  \/\/ Test for tag.\n+  andi(t0, value, JNIHandles::tag_mask);\n+  bnez(t0, tagged);\n@@ -556,0 +561,6 @@\n+  \/\/ Resolve local handle\n+  access_load_at(T_OBJECT, IN_NATIVE | AS_RAW, value, Address(value, 0), tmp1, tmp2);\n+  verify_oop(value);\n+  j(done);\n+\n+  bind(tagged);\n@@ -558,1 +569,6 @@\n-  beqz(t0, not_weak);\n+  bnez(t0, weak_tagged);\n+\n+  \/\/ Resolve global handle\n+  access_load_at(T_OBJECT, IN_NATIVE, value,\n+                 Address(value, -JNIHandles::global_tag_value), tmp1, tmp2);\n+  j(done);\n@@ -560,0 +576,1 @@\n+  bind(weak_tagged);\n@@ -564,1 +581,0 @@\n-  j(done);\n@@ -566,3 +582,22 @@\n-  bind(not_weak);\n-  \/\/ Resolve (untagged) jobject.\n-  access_load_at(T_OBJECT, IN_NATIVE, value, Address(value, 0), tmp1, tmp2);\n+  bind(done);\n+}\n+\n+void MacroAssembler::resolve_global_jobject(Register value, Register tmp1, Register tmp2) {\n+  assert_different_registers(value, tmp1, tmp2);\n+  Label done;\n+\n+  beqz(value, done);           \/\/ Use NULL as-is.\n+\n+#ifdef ASSERT\n+  {\n+    Label valid_global_tag;\n+    andi(t0, value, JNIHandles::global_tag_value); \/\/ Test for global tag.\n+    bnez(t0, valid_global_tag);\n+    stop(\"non global jobject using resolve_global_jobject\");\n+    bind(valid_global_tag);\n+  }\n+#endif\n+\n+  \/\/ Resolve global handle\n+  access_load_at(T_OBJECT, IN_NATIVE, value,\n+                 Address(value, -JNIHandles::global_tag_value), tmp1, tmp2);\n@@ -570,0 +605,1 @@\n+\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":42,"deletions":6,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -184,0 +184,1 @@\n+  void resolve_global_jobject(Register value, Register tmp1, Register tmp2);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3982,6 +3982,1 @@\n-    Label null_jobject;\n-    __ beqz(x10, null_jobject);\n-    DecoratorSet decorators = ACCESS_READ | IN_NATIVE;\n-    BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n-    bs->load_at(_masm, decorators, T_OBJECT, x10, Address(x10, 0), t0, t1);\n-    __ bind(null_jobject);\n+    __ resolve_global_jobject(x10, t0, t1);\n@@ -3989,1 +3984,0 @@\n-\n@@ -4015,0 +4009,1 @@\n+\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -400,1 +400,1 @@\n-  __ z_nill(value, ~JNIHandles::weak_tag_mask);\n+  __ z_nill(value, ~JNIHandles::tag_mask);\n","filename":"src\/hotspot\/cpu\/s390\/gc\/g1\/g1BarrierSetAssembler_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -113,1 +113,1 @@\n-  __ z_nill(value, ~JNIHandles::weak_tag_mask);\n+  __ z_nill(value, ~JNIHandles::tag_mask);\n@@ -122,1 +122,1 @@\n-  __ z_nill(obj, ~JNIHandles::weak_tag_mask);\n+  __ z_nill(obj, ~JNIHandles::tag_mask);\n","filename":"src\/hotspot\/cpu\/s390\/gc\/shared\/barrierSetAssembler_s390.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -200,1 +200,1 @@\n-  __ clear_jweak_tag(obj);\n+  __ clear_jobject_tag(obj);\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shared\/barrierSetAssembler_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -96,1 +96,1 @@\n-  __ clear_jweak_tag(rdx);\n+  __ clear_jobject_tag(rdx);\n@@ -217,1 +217,1 @@\n-  __ clear_jweak_tag(rdx);\n+  __ clear_jobject_tag(rdx);\n@@ -307,1 +307,1 @@\n-  __ clear_jweak_tag(rdx);\n+  __ clear_jobject_tag(rdx);\n","filename":"src\/hotspot\/cpu\/x86\/jniFastGetField_x86_32.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-#define BUFFER_SIZE 30*wordSize\n+#define BUFFER_SIZE 40*wordSize\n","filename":"src\/hotspot\/cpu\/x86\/jniFastGetField_x86_64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3876,3 +3876,3 @@\n-void MacroAssembler::clear_jweak_tag(Register possibly_jweak) {\n-  const int32_t inverted_jweak_mask = ~static_cast<int32_t>(JNIHandles::weak_tag_mask);\n-  STATIC_ASSERT(inverted_jweak_mask == -2); \/\/ otherwise check this code\n+void MacroAssembler::clear_jobject_tag(Register possibly_non_local) {\n+  const int32_t inverted_mask = ~static_cast<int32_t>(JNIHandles::tag_mask);\n+  STATIC_ASSERT(inverted_mask == -4); \/\/ otherwise check this code\n@@ -3880,1 +3880,1 @@\n-  andptr(possibly_jweak, inverted_jweak_mask);\n+  andptr(possibly_non_local, inverted_mask);\n@@ -3887,1 +3887,1 @@\n-  Label done, not_weak;\n+  Label done, tagged, weak_tagged;\n@@ -3889,3 +3889,19 @@\n-  jcc(Assembler::zero, done);                \/\/ Use NULL as-is.\n-  testptr(value, JNIHandles::weak_tag_mask); \/\/ Test for jweak tag.\n-  jcc(Assembler::zero, not_weak);\n+  jcc(Assembler::zero, done);           \/\/ Use NULL as-is.\n+  testptr(value, JNIHandles::tag_mask); \/\/ Test for tag.\n+  jcc(Assembler::notZero, tagged);\n+\n+  \/\/ Resolve local handle\n+  access_load_at(T_OBJECT, IN_NATIVE | AS_RAW, value, Address(value, 0), tmp, thread);\n+  verify_oop(value);\n+  jmp(done);\n+\n+  bind(tagged);\n+  testptr(value, JNIHandles::weak_tag_mask); \/\/ Test for weak tag.\n+  jcc(Assembler::notZero, weak_tagged);\n+\n+  \/\/ Resolve global handle\n+  access_load_at(T_OBJECT, IN_NATIVE, value, Address(value, -JNIHandles::global_tag_value), tmp, thread);\n+  verify_oop(value);\n+  jmp(done);\n+\n+  bind(weak_tagged);\n@@ -3896,4 +3912,25 @@\n-  jmp(done);\n-  bind(not_weak);\n-  \/\/ Resolve (untagged) jobject.\n-  access_load_at(T_OBJECT, IN_NATIVE, value, Address(value, 0), tmp, thread);\n+\n+  bind(done);\n+}\n+\n+void MacroAssembler::resolve_global_jobject(Register value,\n+                                            Register thread,\n+                                            Register tmp) {\n+  assert_different_registers(value, thread, tmp);\n+  Label done;\n+\n+  testptr(value, value);\n+  jcc(Assembler::zero, done);           \/\/ Use NULL as-is.\n+\n+#ifdef ASSERT\n+  {\n+    Label valid_global_tag;\n+    testptr(value, JNIHandles::global_tag_value); \/\/ Test for global tag.\n+    jcc(Assembler::notZero, valid_global_tag);\n+    stop(\"non global jobject using resolve_global_jobject\");\n+    bind(valid_global_tag);\n+  }\n+#endif\n+\n+  \/\/ Resolve global handle\n+  access_load_at(T_OBJECT, IN_NATIVE, value, Address(value, -JNIHandles::global_tag_value), tmp, thread);\n@@ -3901,0 +3938,1 @@\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":50,"deletions":12,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -329,1 +329,1 @@\n-  void clear_jweak_tag(Register possibly_jweak);\n+  void clear_jobject_tag(Register possibly_non_local);\n@@ -331,0 +331,1 @@\n+  void resolve_global_jobject(Register value, Register thread, Register tmp);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -4014,7 +4014,1 @@\n-    Label null_jobject;\n-    __ testptr(rax, rax);\n-    __ jcc(Assembler::zero, null_jobject);\n-    DecoratorSet decorators = ACCESS_READ | IN_NATIVE;\n-    BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n-    bs->load_at(masm, decorators, T_OBJECT, rax, Address(rax, 0), noreg, java_thread);\n-    __ bind(null_jobject);\n+    __ resolve_global_jobject(rax, java_thread, rdx);\n@@ -4039,1 +4033,1 @@\n-    int insts_size = 512;\n+    int insts_size = 1024;\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_32.cpp","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -3507,1 +3507,1 @@\n-  CodeBuffer code(\"jfr_write_checkpoint\", 512, 64);\n+  CodeBuffer code(\"jfr_write_checkpoint\", 1024, 64);\n@@ -3522,8 +3522,1 @@\n-  Label L_null_jobject;\n-  __ testptr(rax, rax);\n-  __ jcc(Assembler::zero, L_null_jobject);\n-\n-  BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n-  bs->load_at(_masm, ACCESS_READ | IN_NATIVE, T_OBJECT, rax, Address(rax, 0), c_rarg0, r15_thread);\n-\n-  __ bind(L_null_jobject);\n+  __ resolve_global_jobject(rax, r15_thread, c_rarg0);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":2,"deletions":9,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1116,1 +1116,2 @@\n-        initialize_immediate_oop(dest, cast_from_oop<jobject>(*dest));\n+        jobject obj = *reinterpret_cast<jobject*>(dest);\n+        initialize_immediate_oop(dest, obj);\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+#include \"runtime\/jniHandles.inline.hpp\"\n@@ -3124,1 +3125,2 @@\n-  Node* event_writer = access_load(jobj, xtype, T_OBJECT, IN_NATIVE | C2_CONTROL_DEPENDENT_LOAD);\n+  Node* jobj_untagged = _gvn.transform(new AddPNode(top(), jobj, _gvn.MakeConX(-JNIHandles::global_tag_value)));\n+  Node* event_writer = access_load(jobj_untagged, xtype, T_OBJECT, IN_NATIVE | C2_CONTROL_DEPENDENT_LOAD);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -94,1 +94,1 @@\n-      assert(*ptr == NULL, \"invariant\");\n+      assert(NativeAccess<AS_NO_KEEPALIVE>::oop_load(ptr) == oop(NULL), \"invariant\");\n@@ -96,1 +96,2 @@\n-      res = reinterpret_cast<jobject>(ptr);\n+      char* tptr = reinterpret_cast<char*>(ptr) + global_tag_value;\n+      res = reinterpret_cast<jobject>(tptr);\n@@ -115,1 +116,1 @@\n-      assert(*ptr == NULL, \"invariant\");\n+      assert(NativeAccess<AS_NO_KEEPALIVE>::oop_load(ptr) == oop(NULL), \"invariant\");\n@@ -140,1 +141,2 @@\n-  assert(is_jweak(handle), \"not a weak handle\");\n+  assert(is_jweak_tagged(handle), \"not a weak handle\");\n+  assert(!is_global_tagged(handle), \"not a weak handle\");\n@@ -148,2 +150,3 @@\n-    assert(!is_jweak(handle), \"wrong method for destroying jweak\");\n-    oop* oop_ptr = jobject_ptr(handle);\n+    assert(is_global_tagged(handle), \"must be global handle\");\n+    assert(!is_jweak_tagged(handle), \"wrong method for destroying jweak\");\n+    oop* oop_ptr = global_ptr(handle);\n@@ -158,1 +161,2 @@\n-    assert(is_jweak(handle), \"JNI handle not jweak\");\n+    assert(is_jweak_tagged(handle), \"JNI handle not jweak\");\n+    assert(!is_global_tagged(handle), \"wrong method for destroying global\");\n@@ -187,1 +191,1 @@\n-  if (is_jweak(handle)) {\n+  if (is_jweak_tagged(handle)) {\n@@ -191,2 +195,2 @@\n-  } else {\n-    switch (global_handles()->allocation_status(jobject_ptr(handle))) {\n+  } else if (is_global_tagged(handle)) {\n+    switch (global_handles()->allocation_status(global_ptr(handle))) {\n@@ -200,7 +204,0 @@\n-    case OopStorage::INVALID_ENTRY:\n-      \/\/ Not in global storage.  Might be a local handle.\n-      if (is_local_handle(thread, handle) || is_frame_handle(thread, handle)) {\n-        result = JNILocalRefType;\n-      }\n-      break;\n-\n@@ -210,0 +207,7 @@\n+  } else {\n+    \/\/ Not in global storage.  Might be a local handle.\n+    if (is_local_handle(thread, handle) || is_frame_handle(thread, handle)) {\n+      result = JNILocalRefType;\n+    } else {\n+      ShouldNotReachHere();\n+    }\n@@ -246,1 +250,1 @@\n-  return !is_jweak(handle) && is_storage_handle(global_handles(), jobject_ptr(handle));\n+  return is_global_tagged(handle) && !is_jweak_tagged(handle) && is_storage_handle(global_handles(), global_ptr(handle));\n@@ -252,1 +256,1 @@\n-  return is_jweak(handle) && is_storage_handle(weak_global_handles(), jweak_ptr(handle));\n+  return is_jweak_tagged(handle) && !is_global_tagged(handle) && is_storage_handle(weak_global_handles(), jweak_ptr(handle));\n@@ -458,1 +462,1 @@\n-    NativeAccess<IS_DEST_UNINITIALIZED>::oop_store(handle, obj);\n+    *handle = obj;\n@@ -466,1 +470,1 @@\n-    NativeAccess<IS_DEST_UNINITIALIZED>::oop_store(handle, obj);\n+    *handle = obj;\n","filename":"src\/hotspot\/share\/runtime\/jniHandles.cpp","additions":25,"deletions":21,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -48,2 +48,4 @@\n-  inline static bool is_jweak(jobject handle);\n-  inline static oop* jobject_ptr(jobject handle); \/\/ NOT jweak!\n+  inline static bool is_jweak_tagged(jobject handle);\n+  inline static bool is_global_tagged(jobject handle);\n+  inline static oop* jobject_ptr(jobject handle); \/\/ NOT jweak or global!\n+  inline static oop* global_ptr(jobject handle);\n@@ -73,0 +75,3 @@\n+  static const uintptr_t tag_size = 2;\n+  static const uintptr_t tag_alignment = (1u << tag_size);\n+  static const uintptr_t tag_mask = tag_alignment - 1;\n@@ -74,0 +79,5 @@\n+  \/\/ Low tag bit in jobject used to distinguish a global jobject.\n+  \/\/ There are places where we need to be able to distinguish global\n+  \/\/ values from other jobjects, and is_global_handle is unsuitable\n+  \/\/ for performance reasons.\n+  static const int global_tag_value = 2;\n","filename":"src\/hotspot\/share\/runtime\/jniHandles.hpp","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-inline bool JNIHandles::is_jweak(jobject handle) {\n+inline bool JNIHandles::is_jweak_tagged(jobject handle) {\n@@ -41,0 +41,4 @@\n+inline bool JNIHandles::is_global_tagged(jobject handle) {\n+  return (reinterpret_cast<uintptr_t>(handle) & global_tag_value) == global_tag_value;\n+}\n+\n@@ -42,1 +46,2 @@\n-  assert(!is_jweak(handle), \"precondition\");\n+  assert(!is_jweak_tagged(handle), \"precondition\");\n+  assert(!is_global_tagged(handle), \"precondition\");\n@@ -46,0 +51,7 @@\n+inline oop* JNIHandles::global_ptr(jobject handle) {\n+  assert(is_global_tagged(handle), \"precondition\");\n+  assert(!is_jweak_tagged(handle), \"precondition\");\n+  char* ptr = reinterpret_cast<char*>(handle) - global_tag_value;\n+  return reinterpret_cast<oop*>(ptr);\n+}\n+\n@@ -47,1 +59,2 @@\n-  assert(is_jweak(handle), \"precondition\");\n+  assert(is_jweak_tagged(handle), \"precondition\");\n+  assert(!is_global_tagged(handle), \"precondition\");\n@@ -58,1 +71,1 @@\n-  if (is_jweak(handle)) {       \/\/ Unlikely\n+  if (is_jweak_tagged(handle)) {       \/\/ Unlikely\n@@ -60,0 +73,5 @@\n+  } else if (is_global_tagged(handle)) {\n+    result = NativeAccess<decorators>::oop_load(global_ptr(handle));\n+    \/\/ Construction of jobjects canonicalize a null value into a null\n+    \/\/ jobject, so for non-jweak the pointee should never be null.\n+    assert(external_guard || result != NULL, \"Invalid JNI handle\");\n@@ -61,1 +79,1 @@\n-    result = NativeAccess<decorators>::oop_load(jobject_ptr(handle));\n+    result = *jobject_ptr(handle);\n@@ -100,2 +118,3 @@\n-    assert(!is_jweak(handle), \"Invalid JNI local handle\");\n-    NativeAccess<>::oop_store(jobject_ptr(handle), (oop)NULL);\n+    assert(!is_jweak_tagged(handle), \"Invalid JNI local handle\");\n+    assert(!is_global_tagged(handle), \"Invalid JNI local handle\");\n+    *jobject_ptr(handle) = NULL;\n","filename":"src\/hotspot\/share\/runtime\/jniHandles.inline.hpp","additions":26,"deletions":7,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -31,2 +31,6 @@\n- * @run main\/othervm\/native -agentlib:FastGetField -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyJNIFields FastGetField\n- * @run main\/othervm\/native -agentlib:FastGetField -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyJNIFields -XX:+UnlockDiagnosticVMOptions -XX:+ForceUnreachable -XX:+SafepointALot -XX:GuaranteedSafepointInterval=1 FastGetField\n+ * @run main\/othervm\/native -agentlib:FastGetField -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyJNIFields FastGetField 0\n+ * @run main\/othervm\/native -agentlib:FastGetField -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyJNIFields FastGetField 1\n+ * @run main\/othervm\/native -agentlib:FastGetField -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyJNIFields FastGetField 2\n+ * @run main\/othervm\/native -agentlib:FastGetField -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyJNIFields -XX:+UnlockDiagnosticVMOptions -XX:+ForceUnreachable -XX:+SafepointALot -XX:GuaranteedSafepointInterval=1 FastGetField 0\n+ * @run main\/othervm\/native -agentlib:FastGetField -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyJNIFields -XX:+UnlockDiagnosticVMOptions -XX:+ForceUnreachable -XX:+SafepointALot -XX:GuaranteedSafepointInterval=1 FastGetField 1\n+ * @run main\/othervm\/native -agentlib:FastGetField -XX:+IgnoreUnrecognizedVMOptions -XX:-VerifyJNIFields -XX:+UnlockDiagnosticVMOptions -XX:+ForceUnreachable -XX:+SafepointALot -XX:GuaranteedSafepointInterval=1 FastGetField 2\n@@ -37,1 +41,0 @@\n-\n@@ -44,0 +47,2 @@\n+    public native void registerGlobal(MyItem i);\n+    public native void registerWeak(MyItem i);\n@@ -45,0 +50,1 @@\n+    public native long accessFieldsViaHandle();\n@@ -95,0 +101,27 @@\n+    private int mode;\n+    private MyItem obj;\n+\n+    private FastGetField(int mode) {\n+        this.mode = mode;\n+        this.obj = new MyItem();\n+\n+        if (mode == 0) {\n+            \/\/ Direct\n+        } else if (mode == 1) {\n+            registerGlobal(this.obj);\n+        } else if ( mode == 2) {\n+            registerWeak(this.obj);\n+        } else {\n+          throw new IllegalArgumentException(\"Unexpected mode\");\n+        }\n+    }\n+\n+    private long accessFields() {\n+        if (mode == 0) {\n+            return accessFields(obj);\n+        }\n+\n+        \/\/ Otherwise through a handle\n+        return accessFieldsViaHandle();\n+    }\n+\n@@ -96,1 +129,1 @@\n-        MyItem i = new MyItem();\n+\n@@ -101,4 +134,4 @@\n-            if (accessFields(i) != 0l) throw new RuntimeException(\"Wrong initial result!\");\n-            i.change_values();\n-            if (accessFields(i) != 8l) throw new RuntimeException(\"Wrong result after changing!\");\n-            i.reset_values();\n+            if (accessFields() != 0l) throw new RuntimeException(\"Wrong initial result!\");\n+            obj.change_values();\n+            if (accessFields() != 8l) throw new RuntimeException(\"Wrong result after changing!\");\n+            obj.reset_values();\n@@ -115,3 +148,3 @@\n-        if (accessFields(i) != 0l) throw new RuntimeException(\"Wrong initial result!\");\n-        i.change_values();\n-        if (accessFields(i) != 8l) throw new RuntimeException(\"Wrong result after changing!\");\n+        if (accessFields() != 0l) throw new RuntimeException(\"Wrong initial result!\");\n+        obj.change_values();\n+        if (accessFields() != 8l) throw new RuntimeException(\"Wrong result after changing!\");\n@@ -122,1 +155,7 @@\n-        FastGetField inst = new FastGetField();\n+        if (args.length != 1) {\n+           throw new IllegalArgumentException(\"Expected one argument\");\n+        }\n+\n+        int mode = Integer.parseInt(args[0]);\n+\n+        FastGetField inst = new FastGetField(mode);\n","filename":"test\/hotspot\/jtreg\/runtime\/jni\/FastGetField\/FastGetField.java","additions":51,"deletions":12,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-\n+static jobject objHandle;\n@@ -66,0 +66,7 @@\n+JNIEXPORT void JNICALL Java_FastGetField_registerGlobal(JNIEnv *env, jobject this, jobject obj) {\n+  objHandle = (*env)->NewGlobalRef(env, obj);\n+}\n+\n+JNIEXPORT void JNICALL Java_FastGetField_registerWeak(JNIEnv *env, jobject this, jobject obj) {\n+  objHandle = (*env)->NewWeakGlobalRef(env, obj);\n+}\n@@ -79,0 +86,3 @@\n+JNIEXPORT jlong JNICALL Java_FastGetField_accessFieldsViaHandle(JNIEnv *env, jobject this) {\n+  return Java_FastGetField_accessFields(env, this, objHandle);\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/jni\/FastGetField\/libFastGetField.c","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"}]}