{"files":[{"patch":"@@ -2467,0 +2467,6 @@\n+\n+  if (collector_state()->in_concurrent_start_gc()) {\n+    log_debug(gc, verify)(\"Marking state\");\n+    _verifier->verify_marking_state();\n+  }\n+\n@@ -2655,0 +2661,5 @@\n+void G1CollectedHeap::retain_region(HeapRegion* hr) {\n+  MutexLocker x(G1RareEvent_lock, Mutex::_no_safepoint_check_flag);\n+  collection_set()->candidates()->add_retained_region_unsorted(hr);\n+}\n+\n@@ -2980,3 +2991,0 @@\n-  if (collector_state()->in_concurrent_start_gc()) {\n-    _cm->add_to_liveness(worker_id, obj, obj_size);\n-  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -687,0 +687,2 @@\n+  \/\/ Add the given region to the retained regions collection set candidates.\n+  void retain_region(HeapRegion* hr);\n@@ -1031,1 +1033,1 @@\n-  inline bool is_in_cset(const HeapRegion *hr) const;\n+  inline bool is_in_cset(const HeapRegion* hr) const;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -323,1 +323,1 @@\n-  if (collector_state()->in_mixed_phase()) {\n+  if (!candidates()->is_empty()) {\n@@ -329,4 +329,9 @@\n-    _policy->select_candidates_from_marking(&candidates()->marking_regions(),\n-                                            time_remaining_ms,\n-                                            &initial_old_regions,\n-                                            &_optional_old_regions);\n+    time_remaining_ms = _policy->select_candidates_from_marking(&candidates()->marking_regions(),\n+                                                                time_remaining_ms,\n+                                                                &initial_old_regions,\n+                                                                &_optional_old_regions);\n+\n+    _policy->select_candidates_from_retained(&candidates()->retained_regions(),\n+                                             time_remaining_ms,\n+                                             &initial_old_regions,\n+                                             &_optional_old_regions);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSet.cpp","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -41,0 +41,9 @@\n+void G1CollectionCandidateList::append_unsorted(HeapRegion* r) {\n+  CandidateInfo c(r, r->calc_gc_efficiency());\n+  _candidates.append(c);\n+}\n+\n+void G1CollectionCandidateList::sort_by_efficiency() {\n+  _candidates.sort(compare);\n+}\n+\n@@ -145,0 +154,1 @@\n+  _retained_regions(),\n@@ -168,0 +178,1 @@\n+  _retained_regions.clear();\n@@ -191,0 +202,14 @@\n+void G1CollectionSetCandidates::sort_by_efficiency() {\n+  \/\/ From marking regions must always be sorted so no reason to actually sort\n+  \/\/ them.\n+  _marking_regions.verify();\n+  _retained_regions.sort_by_efficiency();\n+  _retained_regions.verify();\n+}\n+\n+void G1CollectionSetCandidates::add_retained_region_unsorted(HeapRegion* r) {\n+  assert(!contains(r), \"must not contain region %u\", r->hrm_index());\n+  _contains_map[r->hrm_index()] = CandidateOrigin::Retained;\n+  _retained_regions.append_unsorted(r);\n+}\n+\n@@ -192,1 +217,19 @@\n-  _marking_regions.remove(other);\n+  \/\/ During removal, we exploit the fact that elements in the marking_regions,\n+  \/\/ retained_regions and other list are sorted by gc_efficiency. Furthermore,\n+  \/\/ all regions in the passed other list are in one of the two other lists.\n+  \/\/\n+  \/\/ Split original list into elements for the marking list and elements from the\n+  \/\/ retained list.\n+  G1CollectionCandidateRegionList other_marking_regions;\n+  G1CollectionCandidateRegionList other_retained_regions;\n+\n+  for (HeapRegion* r : *other) {\n+    if (is_from_marking(r)) {\n+      other_marking_regions.append(r);\n+    } else {\n+      other_retained_regions.append(r);\n+    }\n+  }\n+\n+  _marking_regions.remove(&other_marking_regions);\n+  _retained_regions.remove(&other_retained_regions);\n@@ -207,1 +250,9 @@\n-  return _marking_regions.length() != 0;\n+  return marking_regions_length() != 0;\n+}\n+\n+uint G1CollectionSetCandidates::marking_regions_length() const {\n+  return _marking_regions.length();\n+}\n+\n+uint G1CollectionSetCandidates::retained_regions_length() const {\n+  return _retained_regions.length();\n@@ -221,1 +272,1 @@\n-    assert(_contains_map[hrm_index] == CandidateOrigin::Marking,\n+    assert(_contains_map[hrm_index] == CandidateOrigin::Marking || _contains_map[hrm_index] == CandidateOrigin::Retained,\n@@ -238,1 +289,0 @@\n-\n@@ -241,0 +291,6 @@\n+  uint from_marking_retained = 0;\n+  verify_helper(&_retained_regions, from_marking_retained, verify_map);\n+  assert(from_marking_retained == 0, \"must be\");\n+\n+  assert(length() >= marking_regions_length(), \"must be\");\n+\n@@ -265,0 +321,1 @@\n+    \"Cr\",  \/\/ Retained\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetCandidates.cpp","additions":61,"deletions":4,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -103,0 +103,5 @@\n+  \/\/ Add the given HeapRegion to this list at the end, (potentially) making the list unsorted.\n+  void append_unsorted(HeapRegion* r);\n+  \/\/ Restore sorting order by decreasing gc efficiency, using the existing efficiency\n+  \/\/ values.\n+  void sort_by_efficiency();\n@@ -132,1 +137,2 @@\n-\/\/ Iterator for G1CollectionSetCandidates.\n+\/\/ Iterator for G1CollectionSetCandidates. There are no guarantees on the order\n+\/\/ of the regions returned.\n@@ -135,1 +141,1 @@\n-  uint _marking_position;\n+  uint _position;\n@@ -138,1 +144,1 @@\n-  G1CollectionSetCandidatesIterator(G1CollectionSetCandidates* which, uint marking_position);\n+  G1CollectionSetCandidatesIterator(G1CollectionSetCandidates* which, uint position);\n@@ -149,1 +155,1 @@\n-\/\/ These candidate regions are tracked in a list of regions, sorted by decreasing\n+\/\/ These candidate regions are tracked in two list of regions, sorted by decreasing\n@@ -152,2 +158,0 @@\n-\/\/ Currently there is only one type of such regions:\n-\/\/\n@@ -159,0 +163,4 @@\n+\/\/ * retained_regions: set of regions selected for evacuation during evacuation\n+\/\/                     failure.\n+\/\/                     Any young collection will try to evacuate them.\n+\/\/\n@@ -165,0 +173,1 @@\n+    Retained,                  \/\/ This region has been added because it has been retained after evacuation.\n@@ -168,1 +177,2 @@\n-  G1CollectionCandidateList _marking_regions;\n+  G1CollectionCandidateList _marking_regions;  \/\/ Set of regions selected by concurrent marking.\n+  G1CollectionCandidateList _retained_regions; \/\/ Set of regions selected from evacuation failed regions.\n@@ -183,0 +193,1 @@\n+  G1CollectionCandidateList& retained_regions() { return _retained_regions; }\n@@ -197,0 +208,5 @@\n+  void sort_by_efficiency();\n+\n+  \/\/ Add the given region to the set of retained regions without regards to the\n+  \/\/ gc efficiency sorting. The retained regions must be re-sorted manually later.\n+  void add_retained_region_unsorted(HeapRegion* r);\n@@ -206,1 +222,0 @@\n-  bool has_more_marking_candidates() const;\n@@ -208,1 +223,3 @@\n-  uint marking_regions_length() const { return _marking_regions.length(); }\n+  bool has_more_marking_candidates() const;\n+  uint marking_regions_length() const;\n+  uint retained_regions_length() const;\n@@ -216,1 +233,1 @@\n-  uint length() const { return marking_regions_length(); }\n+  uint length() const { return marking_regions_length() + retained_regions_length(); }\n@@ -224,1 +241,1 @@\n-    return G1CollectionSetCandidatesIterator(this, marking_regions_length());\n+    return G1CollectionSetCandidatesIterator(this, length());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetCandidates.hpp","additions":28,"deletions":11,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -54,2 +54,2 @@\n-inline G1CollectionSetCandidatesIterator::G1CollectionSetCandidatesIterator(G1CollectionSetCandidates* which, uint marking_position) :\n-  _which(which), _marking_position(marking_position) {\n+inline G1CollectionSetCandidatesIterator::G1CollectionSetCandidatesIterator(G1CollectionSetCandidates* which, uint position) :\n+  _which(which), _position(position) {\n@@ -59,4 +59,2 @@\n-  assert(_marking_position < _which->_marking_regions.length(),\n-         \"must not be at end already\");\n-\n-  _marking_position++;\n+  assert(_position < _which->length(), \"must not be at end already\");\n+  _position++;\n@@ -67,1 +65,6 @@\n-  return _which->_marking_regions.at(_marking_position)._r;\n+  uint length = _which->marking_regions_length();\n+  if (_position < length) {\n+    return _which->_marking_regions.at(_position)._r;\n+  } else {\n+    return _which->_retained_regions.at(_position - length)._r;\n+  }\n@@ -72,1 +75,1 @@\n-  return _marking_position == rhs._marking_position;\n+  return _position == rhs._position;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetCandidates.inline.hpp","additions":11,"deletions":8,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -34,3 +34,3 @@\n-\/\/ Determine collection set candidates: For all regions determine whether they\n-\/\/ should be a collection set candidates, calculate their efficiency, sort and\n-\/\/ return them as G1CollectionSetCandidates instance.\n+\/\/ Determine collection set candidates (from marking): For all regions determine\n+\/\/ whether they should be a collection set candidate, calculate their efficiency,\n+\/\/ sort and put them into the candidates.\n@@ -38,3 +38,2 @@\n-\/\/ put them into some work area unsorted. At the end the array is sorted and\n-\/\/ copied into the G1CollectionSetCandidates instance; the caller will be the new\n-\/\/ owner of this object.\n+\/\/ put them into some work area without sorting. At the end that array is sorted and\n+\/\/ moved to the destination.\n@@ -155,0 +154,1 @@\n+        assert(r->rem_set()->is_complete(), \"must be %u\", r->hrm_index());\n@@ -156,2 +156,3 @@\n-      } else if (r->is_old()) {\n-        \/\/ Keep remembered sets for humongous regions, otherwise clean them out.\n+      } else if (r->is_old() && !r->is_collection_set_candidate()) {\n+        \/\/ Keep remembered sets for humongous regions and collection set candidates,\n+        \/\/ otherwise clean them out.\n@@ -160,1 +161,1 @@\n-        assert(!r->is_old() || !r->rem_set()->is_tracked(),\n+        assert(r->is_collection_set_candidate() || !r->is_old() || !r->rem_set()->is_tracked(),\n@@ -257,0 +258,4 @@\n+         \/\/ A region might have been retained (after evacuation failure) and already put\n+         \/\/ into the candidates list during concurrent marking. These should keep being\n+         \/\/ considered as retained regions.\n+         !hr->is_collection_set_candidate() &&\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetChooser.cpp","additions":14,"deletions":9,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -50,3 +50,2 @@\n-  \/\/ Determine whether to add the given region to the collection set candidates or\n-  \/\/ not. Currently, we skip regions that we will never move during young gc, and\n-  \/\/ regions which liveness is over the occupancy threshold.\n+  \/\/ Determine whether to add the given region to the collection set candidates from\n+  \/\/ marking or not. Currently, we skip regions whose live bytes are over the threshold.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetChooser.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -328,0 +328,9 @@\n+bool G1CMRootMemRegions::contains(const MemRegion mr) const {\n+  for (uint i = 0; i < _num_root_regions; i++) {\n+    if (_root_regions[i].equals(mr)) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n@@ -997,0 +1006,4 @@\n+bool G1ConcurrentMark::is_root_region(HeapRegion* r) {\n+  return root_regions()->contains(MemRegion(r->top_at_mark_start(), r->top()));\n+}\n+\n@@ -1365,2 +1378,2 @@\n-        log_trace(gc)(\"Reclaimed empty old gen region %u (%s) bot \" PTR_FORMAT,\n-                      hr->hrm_index(), hr->get_short_type_str(), p2i(hr->bottom()));\n+        log_trace(gc, marking)(\"Reclaimed empty old gen region %u (%s) bot \" PTR_FORMAT,\n+                               hr->hrm_index(), hr->get_short_type_str(), p2i(hr->bottom()));\n@@ -1870,0 +1883,1 @@\n+      log_trace(gc, marking)(\"Claim region %u bottom \" PTR_FORMAT \" tams \" PTR_FORMAT, curr_region->hrm_index(), p2i(curr_region->bottom()), p2i(curr_region->top_at_mark_start()));\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -267,0 +267,4 @@\n+  \/\/ Is the given memregion contained in the root regions; the MemRegion must\n+  \/\/ match exactly.\n+  bool contains(const MemRegion mr) const;\n+\n@@ -470,0 +474,2 @@\n+  \/\/ Set live bytes for concurrent marking.\n+  void set_live_bytes(uint region, size_t live_bytes) { _region_mark_stats[region]._live_words = live_bytes \/ HeapWordSize; }\n@@ -558,0 +564,1 @@\n+  bool is_root_region(HeapRegion* r);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -62,0 +62,2 @@\n+\/\/ Regions might have been reclaimed while scrubbing them after having yielded for\n+\/\/ a pause.\n@@ -89,2 +91,3 @@\n-    \/\/ has been aborted for any reason.\n-    bool yield_if_necessary() {\n+    \/\/ has been aborted for any reason. Yielded is set if there has been an actual\n+    \/\/ yield for a pause.\n+    bool yield_if_necessary(bool& yielded) {\n@@ -93,1 +96,1 @@\n-        _cm->do_yield_check();\n+        yielded = _cm->do_yield_check();\n@@ -104,1 +107,1 @@\n-    \/\/  - been eagerly reclaimed by a young collection (only humongous)\n+    \/\/  - been reclaimed by a collection.\n@@ -110,3 +113,3 @@\n-    \/\/ G1RebuildRemSetChunkSize. The heap region is needed to ensure a humongous object\n-    \/\/ is not eagerly reclaimed during yielding.\n-    \/\/ Returns whether marking has been aborted.\n+    \/\/ G1RebuildRemSetChunkSize. The heap region is needed check whether the region has\n+    \/\/ been reclaimed during yielding.\n+    \/\/ Returns true if marking has been aborted or false if completed.\n@@ -123,1 +126,2 @@\n-        bool mark_aborted = yield_if_necessary();\n+        bool yielded;\n+        bool mark_aborted = yield_if_necessary(yielded);\n@@ -126,4 +130,4 @@\n-        } else if (!should_rebuild_or_scrub(hr)) {\n-          \/\/ We need to check should_rebuild_or_scrub() again (for humongous objects)\n-          \/\/ because the region might have been eagerly reclaimed during the yield.\n-          log_trace(gc, marking)(\"Rebuild aborted for eagerly reclaimed humongous region: %u\", hr->hrm_index());\n+        } else if (yielded && !should_rebuild_or_scrub(hr)) {\n+          \/\/ We need to check should_rebuild_or_scrub() again because the region might\n+          \/\/ have been reclaimed during the yield.\n+          log_trace(gc, marking)(\"Rebuild aborted for reclaimed region: %u\", hr->hrm_index());\n@@ -133,1 +137,1 @@\n-        \/\/ Step to next chunk of the humongous object\n+        \/\/ Step to next chunk of the large object.\n@@ -191,1 +195,2 @@\n-        bool mark_aborted = yield_if_necessary();\n+        bool yielded;\n+        bool mark_aborted = yield_if_necessary(yielded);\n@@ -194,0 +199,4 @@\n+        } else if (yielded && !should_rebuild_or_scrub(hr)) {\n+          \/\/ Region has been reclaimed while yielding. Exit continuing with the next region.\n+          log_trace(gc, marking)(\"Scan and scrub aborted for reclaimed region: %u\", hr->hrm_index());\n+          return false;\n@@ -206,1 +215,2 @@\n-        bool mark_aborted = yield_if_necessary();\n+        bool yielded = true;\n+        bool mark_aborted = yield_if_necessary(yielded);\n@@ -209,0 +219,3 @@\n+        } else if (yielded && !should_rebuild_or_scrub(hr)) {\n+          log_trace(gc, marking)(\"Scan aborted for reclaimed region: %u\", hr->hrm_index());\n+          return false;\n@@ -219,2 +232,2 @@\n-      log_trace(gc, marking)(\"Scrub and rebuild region: \" HR_FORMAT \" pb: \" PTR_FORMAT \" TARS: \" PTR_FORMAT,\n-                             HR_FORMAT_PARAMS(hr), p2i(pb), p2i(_cm->top_at_rebuild_start(hr->hrm_index())));\n+      log_trace(gc, marking)(\"Scrub and rebuild region: \" HR_FORMAT \" pb: \" PTR_FORMAT \" TARS: \" PTR_FORMAT \" TAMS: \" PTR_FORMAT,\n+                             HR_FORMAT_PARAMS(hr), p2i(pb), p2i(_cm->top_at_rebuild_start(hr->hrm_index())), p2i(hr->top_at_mark_start()));\n@@ -227,0 +240,5 @@\n+      \/\/ Yielding during scrubbing and scanning might have reclaimed the region, so need to\n+      \/\/ re-check after above.\n+      if (!should_rebuild_or_scrub(hr)) {\n+        return false;\n+      }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentRebuildAndScrub.cpp","additions":35,"deletions":17,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-  \/\/ Return a G1AbstractSubTask which does necessary preparation for evacuation failure regions\n+  \/\/ Return a G1AbstractSubTask which does necessary preparation for evacuation failed regions\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailureRegions.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/g1\/g1CollectedHeap.inline.hpp\"\n@@ -40,2 +41,1 @@\n-    G1CollectorState* state = g1h->collector_state();\n-    hr->note_evacuation_failure(state->in_concurrent_start_gc());\n+    hr->note_evacuation_failure();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailureRegions.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -109,1 +109,1 @@\n-  _gc_par_phases[ClearRetainedRegionBitmaps] = new WorkerDataArray<double>(\"ClearRetainedRegionsBitmap\", \"Clear Retained Region Bitmaps (ms):\", max_gc_threads);\n+  _gc_par_phases[ProcessEvacuationFailedRegions] = new WorkerDataArray<double>(\"ProcessEvacuationFailedRegions\", \"Process Evacuation Failed Regions (ms):\", max_gc_threads);\n@@ -129,0 +129,1 @@\n+  _gc_par_phases[MergePSS]->create_thread_work_items(\"Evac Fail Extra Cards\", MergePSSEvacFailExtra);\n@@ -130,1 +131,2 @@\n-  _gc_par_phases[RestoreRetainedRegions]->create_thread_work_items(\"Evacuation Failure Regions:\", RestoreRetainedRegionsNum);\n+  _gc_par_phases[RestoreRetainedRegions]->create_thread_work_items(\"Evacuation Failed Regions:\", RestoreRetainedRegionsFailedNum);\n+  _gc_par_phases[RestoreRetainedRegions]->create_thread_work_items(\"New Retained Regions:\", RestoreRetainedRegionsRetainedNum);\n@@ -407,1 +409,2 @@\n-  const double sum_ms = _cur_pre_evacuate_prepare_time_ms +\n+  const double sum_ms = pre_concurrent_start_ms +\n+                        _cur_pre_evacuate_prepare_time_ms +\n@@ -411,2 +414,1 @@\n-                        _recorded_prepare_heap_roots_time_ms +\n-                        pre_concurrent_start_ms;\n+                        _recorded_prepare_heap_roots_time_ms;\n@@ -416,0 +418,5 @@\n+  if (pre_concurrent_start_ms > 0.0) {\n+    debug_phase(_gc_par_phases[ResetMarkingState]);\n+    debug_phase(_gc_par_phases[NoteStartOfMark]);\n+  }\n+\n@@ -424,5 +431,0 @@\n-  if (pre_concurrent_start_ms > 0.0) {\n-    debug_phase(_gc_par_phases[ResetMarkingState]);\n-    debug_phase(_gc_par_phases[NoteStartOfMark]);\n-  }\n-\n@@ -507,1 +509,1 @@\n-    debug_phase(_gc_par_phases[ClearRetainedRegionBitmaps], 1);\n+    debug_phase(_gc_par_phases[ProcessEvacuationFailedRegions], 1);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1GCPhaseTimes.cpp","additions":13,"deletions":11,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -91,1 +91,1 @@\n-    ClearRetainedRegionBitmaps,\n+    ProcessEvacuationFailedRegions,\n@@ -141,1 +141,2 @@\n-    MergePSSLABUndoWasteBytes\n+    MergePSSLABUndoWasteBytes,\n+    MergePSSEvacFailExtra\n@@ -145,1 +146,2 @@\n-    RestoreRetainedRegionsNum,\n+    RestoreRetainedRegionsFailedNum,\n+    RestoreRetainedRegionsRetainedNum\n","filename":"src\/hotspot\/share\/gc\/g1\/g1GCPhaseTimes.hpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -440,0 +440,72 @@\n+class G1VerifyRegionMarkingStateClosure : public HeapRegionClosure {\n+  class MarkedBytesClosure {\n+    size_t _marked_words;\n+\n+  public:\n+    MarkedBytesClosure() : _marked_words(0) { }\n+\n+    inline size_t apply(oop obj) {\n+      size_t result = obj->size();\n+      _marked_words += result;\n+      return result;\n+    }\n+\n+    size_t marked_bytes() const { return _marked_words * HeapWordSize; }\n+  };\n+\n+public:\n+  virtual bool do_heap_region(HeapRegion* r) {\n+    if (r->is_free()) {\n+      return false;\n+    }\n+\n+    G1ConcurrentMark* cm = G1CollectedHeap::heap()->concurrent_mark();\n+\n+    bool part_of_marking = r->is_old_or_humongous() && !r->is_collection_set_candidate();\n+\n+    if (part_of_marking) {\n+      guarantee(r->bottom() != r->top_at_mark_start(), \"region %u (%s) does not have TAMS set\",\n+                                                       r->hrm_index(), r->get_short_type_str());\n+      size_t marked_bytes = cm->live_bytes(r->hrm_index());\n+\n+      MarkedBytesClosure cl;\n+      r->apply_to_marked_objects(cm->mark_bitmap(), &cl);\n+\n+      guarantee(cl.marked_bytes() == marked_bytes,\n+                \"region %u (%s) live bytes actual %zu and cache %zu differ\",\n+                r->hrm_index(), r->get_short_type_str(), cl.marked_bytes(), marked_bytes);\n+    } else {\n+      guarantee(r->bottom() == r->top_at_mark_start(),\n+                \"region %u (%s) has TAMS set \" PTR_FORMAT \" \" PTR_FORMAT,\n+                r->hrm_index(), r->get_short_type_str(), p2i(r->bottom()), p2i(r->top_at_mark_start()));\n+      guarantee(cm->live_bytes(r->hrm_index()) == 0,\n+                \"region %u (%s) has %zu live bytes recorded\",\n+                r->hrm_index(), r->get_short_type_str(), cm->live_bytes(r->hrm_index()));\n+      guarantee(cm->mark_bitmap()->get_next_marked_addr(r->bottom(), r->end()) == r->end(),\n+                \"region %u (%s) has mark\",\n+                r->hrm_index(), r->get_short_type_str());\n+      guarantee(cm->is_root_region(r),\n+                \"region %u (%s) should be root region\",\n+                r->hrm_index(), r->get_short_type_str());\n+    }\n+    return false;\n+  }\n+};\n+\n+void G1HeapVerifier::verify_marking_state() {\n+  assert(G1CollectedHeap::heap()->collector_state()->in_concurrent_start_gc(), \"must be\");\n+\n+  \/\/ Verify TAMSes, bitmaps and liveness statistics.\n+  \/\/\n+  \/\/ - if part of marking: TAMS != bottom, liveness == 0, bitmap clear\n+  \/\/ - if evacuation failed + part of marking: TAMS != bottom, liveness != 0, bitmap has at least on object set (corresponding to liveness)\n+  \/\/ - if not part of marking: TAMS == bottom, liveness == 0, bitmap clear; must be in root region\n+\n+  \/\/ To compare liveness recorded in G1ConcurrentMark and actual we need to flush the\n+  \/\/ cache.\n+  G1CollectedHeap::heap()->concurrent_mark()->flush_all_task_caches();\n+\n+  G1VerifyRegionMarkingStateClosure cl;\n+  _g1h->heap_region_iterate(&cl);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapVerifier.cpp","additions":72,"deletions":0,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -73,0 +73,3 @@\n+  \/\/ Verify that marking state is set up correctly after a concurrent start pause.\n+  void verify_marking_state();\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapVerifier.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -91,1 +91,2 @@\n-    _evac_failure_regions(evac_failure_regions)\n+    _evac_failure_regions(evac_failure_regions),\n+    _evac_failure_enqueued_cards(0)\n@@ -150,0 +151,4 @@\n+size_t G1ParScanThreadState::evac_failure_enqueued_cards() const {\n+  return _evac_failure_enqueued_cards;\n+}\n+\n@@ -598,0 +603,1 @@\n+    size_t evac_fail_enqueued_cards = pss->evac_failure_enqueued_cards();\n@@ -602,0 +608,1 @@\n+    p->record_or_add_thread_work_item(G1GCPhaseTimes::MergePSS, worker_id, evac_fail_enqueued_cards, G1GCPhaseTimes::MergePSSEvacFailExtra);\n@@ -643,6 +650,3 @@\n-    \/\/ existing closure to scan evacuated objects because:\n-    \/\/ - for objects referring into the collection set we do not need to gather\n-    \/\/ cards at this time. The regions they are in will be unconditionally turned\n-    \/\/ to old regions without remembered sets.\n-    \/\/ - since we are iterating from a collection set region (i.e. never a Survivor\n-    \/\/ region), we always need to gather cards for this case.\n+    \/\/ existing closure to scan evacuated objects; since we are iterating from a\n+    \/\/ collection set region (i.e. never a Survivor region), we always need to\n+    \/\/ gather cards for this case.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":11,"deletions":7,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -112,0 +112,10 @@\n+  \/\/ Number of additional cards into evacuation failed regions enqueued into\n+  \/\/ the local DCQS. This is an approximation, as cards that would be added later\n+  \/\/ outside of evacuation failure will not be subtracted again.\n+  size_t _evac_failure_enqueued_cards;\n+\n+  \/\/ Enqueue the card if not already in the set; this is a best-effort attempt on\n+  \/\/ detecting duplicates.\n+  template <class T> bool enqueue_if_new(T* p);\n+  \/\/ Enqueue the card of p into the (evacuation failed) region.\n+  template <class T> void enqueue_card_into_evac_fail_region(T* p, oop obj);\n@@ -155,0 +165,2 @@\n+  size_t evac_failure_enqueued_cards() const;\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -99,0 +99,22 @@\n+template <class T> bool G1ParScanThreadState::enqueue_if_new(T* p) {\n+  size_t card_index = ct()->index_for(p);\n+  \/\/ If the card hasn't been added to the buffer, do it.\n+  if (_last_enqueued_card != card_index) {\n+    _rdc_local_qset.enqueue(ct()->byte_for_index(card_index));\n+    _last_enqueued_card = card_index;\n+    return true;\n+  } else {\n+    return false;\n+  }\n+}\n+\n+template <class T> void G1ParScanThreadState::enqueue_card_into_evac_fail_region(T* p, oop obj) {\n+  assert(!HeapRegion::is_in_same_region(p, obj), \"Should have filtered out cross-region references already.\");\n+  assert(!_g1h->heap_region_containing(p)->is_survivor(), \"Should have filtered out from-newly allocated survivor references already.\");\n+  assert(_g1h->heap_region_containing(obj)->in_collection_set(), \"Only for enqeueing reference into collection set region\");\n+\n+  if (enqueue_if_new(p)) {\n+    _evac_failure_enqueued_cards++;\n+  }\n+}\n+\n@@ -112,2 +134,3 @@\n-  \/\/ evacuation. Currently these regions are always relabelled as old without\n-  \/\/ remembered sets, so skip them.\n+  \/\/ evacuation. Proactively collect remembered sets (cards) for them as likely they\n+  \/\/ are sparsely populated (and have few references). We will decide later to keep\n+  \/\/ or drop the region.\n@@ -117,0 +140,1 @@\n+    enqueue_card_into_evac_fail_region(p, obj);\n@@ -140,6 +164,1 @@\n-  size_t card_index = ct()->index_for(p);\n-  \/\/ If the card hasn't been added to the buffer, do it.\n-  if (_last_enqueued_card != card_index) {\n-    _rdc_local_qset.enqueue(ct()->byte_for_index(card_index));\n-    _last_enqueued_card = card_index;\n-  }\n+  enqueue_if_new(p);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.inline.hpp","additions":27,"deletions":8,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -271,0 +271,5 @@\n+    double retained_time_ms = predict_retained_regions_evac_time();\n+    double total_time_ms = base_time_ms + retained_time_ms;\n+\n+    log_trace(gc, ergo, heap)(\"Predicted total base time: total %f base_time %f retained_time %f\",\n+                              total_time_ms, base_time_ms, retained_time_ms);\n@@ -273,1 +278,1 @@\n-      calculate_desired_eden_length_by_pause(base_time_ms,\n+      calculate_desired_eden_length_by_pause(total_time_ms,\n@@ -516,0 +521,23 @@\n+double G1Policy::predict_retained_regions_evac_time() const {\n+  uint num_regions = 0;\n+  double result = 0.0;\n+\n+  G1CollectionCandidateList& list = candidates()->retained_regions();\n+  uint min_regions_left = MIN2(min_retained_old_cset_length(),\n+                               list.length());\n+\n+  for (HeapRegion* r : list) {\n+    if (min_regions_left == 0) {\n+      \/\/ Minimum amount of regions considered. Exit.\n+      break;\n+    }\n+    min_regions_left--;\n+    result += predict_region_total_time_ms(r, collector_state()->in_young_only_phase());\n+    num_regions++;\n+  }\n+\n+  log_trace(gc, ergo, heap)(\"Selected %u of %u retained candidates taking %1.3fms additional time\",\n+                            num_regions, list.length(), result);\n+  return result;\n+}\n+\n@@ -626,0 +654,11 @@\n+bool G1Policy::should_retain_evac_failed_region(uint index) const {\n+  size_t live_bytes= _g1h->region_at(index)->live_bytes();\n+\n+  assert(live_bytes != 0,\n+         \"live bytes not set for %u used %zu garbage %zu cm-live %zu\",\n+         index, _g1h->region_at(index)->used(), _g1h->region_at(index)->garbage_bytes(), live_bytes);\n+\n+  size_t threshold = G1RetainRegionLiveThresholdPercent * HeapRegion::GrainBytes \/ 100;\n+  return live_bytes < threshold;\n+}\n+\n@@ -1374,0 +1413,6 @@\n+uint G1Policy::min_retained_old_cset_length() const {\n+  \/\/ Guarantee some progress with retained regions regardless of available time by\n+  \/\/ taking at least one region.\n+  return 1;\n+}\n+\n@@ -1491,0 +1536,66 @@\n+void G1Policy::select_candidates_from_retained(G1CollectionCandidateList* retained_list,\n+                                               double time_remaining_ms,\n+                                               G1CollectionCandidateRegionList* initial_old_regions,\n+                                               G1CollectionCandidateRegionList* optional_old_regions) {\n+\n+  uint const min_regions = min_retained_old_cset_length();\n+\n+  uint num_initial_regions_selected = 0;\n+  uint num_optional_regions_selected = 0;\n+  uint num_expensive_regions_selected = 0;\n+\n+  double predicted_initial_time_ms = 0.0;\n+  double predicted_optional_time_ms = 0.0;\n+\n+  \/\/ We want to make sure that on the one hand we process the retained regions asap,\n+  \/\/ but on the other hand do not take too many of them as optional regions.\n+  \/\/ So we split the time budget into budget we will unconditionally take into the\n+  \/\/ initial old regions, and budget for taking optional regions from the retained\n+  \/\/ list.\n+  double optional_time_remaining_ms = max_time_for_retaining();\n+  time_remaining_ms = MIN2(time_remaining_ms, optional_time_remaining_ms);\n+\n+  log_debug(gc, ergo, cset)(\"Start adding retained candidates to collection set. \"\n+                            \"Min %u regions, \"\n+                            \"time remaining %1.2fms, optional remaining %1.2fms\",\n+                            min_regions, time_remaining_ms, optional_time_remaining_ms);\n+\n+  for (HeapRegion* r : *retained_list) {\n+    double predicted_time_ms = predict_region_total_time_ms(r, collector_state()->in_young_only_phase());\n+    bool fits_in_remaining_time = predicted_time_ms <= time_remaining_ms;\n+\n+    if (fits_in_remaining_time || (num_expensive_regions_selected < min_regions)) {\n+      predicted_initial_time_ms += predicted_time_ms;\n+      if (!fits_in_remaining_time) {\n+        num_expensive_regions_selected++;\n+      }\n+      initial_old_regions->append(r);\n+      num_initial_regions_selected++;\n+    } else if (predicted_time_ms <= optional_time_remaining_ms) {\n+      predicted_optional_time_ms += predicted_time_ms;\n+      optional_old_regions->append(r);\n+      num_optional_regions_selected++;\n+    } else {\n+      \/\/ Fits neither initial nor optional time limit. Exit.\n+      break;\n+    }\n+    time_remaining_ms = MAX2(0.0, time_remaining_ms - predicted_time_ms);\n+    optional_time_remaining_ms = MAX2(0.0, optional_time_remaining_ms - predicted_time_ms);\n+  }\n+\n+  uint num_regions_selected = num_initial_regions_selected + num_optional_regions_selected;\n+  if (num_regions_selected == retained_list->length()) {\n+    log_debug(gc, ergo, cset)(\"Retained candidates exhausted.\");\n+  }\n+  if (num_expensive_regions_selected > 0) {\n+    log_debug(gc, ergo, cset)(\"Added %u retained candidates to collection set although the predicted time was too high.\",\n+                              num_expensive_regions_selected);\n+  }\n+\n+  log_debug(gc, ergo, cset)(\"Finish adding retained candidates to collection set. Initial: %u, optional: %u, \"\n+                            \"predicted initial time: %1.2fms, predicted optional time: %1.2fms, \"\n+                            \"time remaining: %1.2fms optional time remaining %1.2fms\",\n+                            num_initial_regions_selected, num_optional_regions_selected,\n+                            predicted_initial_time_ms, predicted_optional_time_ms, time_remaining_ms, optional_time_remaining_ms);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":112,"deletions":1,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -250,0 +250,1 @@\n+  double predict_retained_regions_evac_time() const;\n@@ -262,0 +263,2 @@\n+  \/\/ The minimum number of retained regions we will add to the CSet during a young GC.\n+  uint min_retained_old_cset_length() const;\n@@ -349,0 +352,5 @@\n+  void select_candidates_from_retained(G1CollectionCandidateList* retained_list,\n+                                       double time_remaining_ms,\n+                                       G1CollectionCandidateRegionList* initial_old_regions,\n+                                       G1CollectionCandidateRegionList* optional_old_regions);\n+\n@@ -404,0 +412,5 @@\n+  bool should_retain_evac_failed_region(HeapRegion* r) const {\n+    return should_retain_evac_failed_region(r->hrm_index());\n+  }\n+  bool should_retain_evac_failed_region(uint index) const;\n+\n@@ -430,0 +443,3 @@\n+  \/\/ Returns the total time that to at most reserve for handling retained regions.\n+  double max_time_for_retaining() const { return max_pause_time_ms() * optional_prediction_fraction(); }\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.hpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1105,4 +1105,5 @@\n-      \/\/ old regions are only in the collection set after the concurrent cycle completed,\n-      \/\/ so their bitmaps must also be clear except when the pause occurs during the\n-      \/\/ Concurrent Cleanup for Next Mark phase. Only at that point the region's bitmap may\n-      \/\/ contain marks while being in the collection set at the same time.\n+      \/\/ old regions that are currently being marked through are only in the collection set\n+      \/\/ after the concurrent cycle completed, so their bitmaps must also be clear except when\n+      \/\/ the pause occurs during the Concurrent Cleanup for Next Mark phase.\n+      \/\/ Only at that point the region's bitmap may contain marks while being in the collection\n+      \/\/ set at the same time.\n@@ -1133,0 +1134,1 @@\n+      _g1h->concurrent_mark()->clear_statistics(hr);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"gc\/g1\/g1CollectionSetCandidates.inline.hpp\"\n@@ -467,0 +468,7 @@\n+\n+  \/\/ Must be before collection set calculation, requires collection set to not\n+  \/\/ be calculated yet.\n+  if (collector_state()->in_concurrent_start_gc()) {\n+    concurrent_mark()->pre_concurrent_start(_gc_cause);\n+  }\n+\n@@ -511,4 +519,0 @@\n-  if (collector_state()->in_concurrent_start_gc()) {\n-    concurrent_mark()->pre_concurrent_start(_gc_cause);\n-  }\n-\n@@ -953,0 +957,9 @@\n+void G1YoungCollector::enqueue_candidates_as_root_regions() {\n+  assert(collector_state()->in_concurrent_start_gc(), \"must be\");\n+\n+  G1CollectionSetCandidates* candidates = collection_set()->candidates();\n+  for (HeapRegion* r : *candidates) {\n+    _g1h->concurrent_mark()->add_root_region(r);\n+  }\n+}\n+\n@@ -975,0 +988,7 @@\n+  \/\/ Regions in the collection set candidates are roots for the marking (they are\n+  \/\/ not marked through considering they are very likely to be reclaimed soon.\n+  \/\/ They need to be enqueued explicitly compared to survivor regions.\n+  if (collector_state()->in_concurrent_start_gc()) {\n+    enqueue_candidates_as_root_regions();\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.cpp","additions":24,"deletions":4,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -129,0 +129,2 @@\n+  \/\/ Enqueue collection set candidates as root regions.\n+  void enqueue_candidates_as_root_regions();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n-      return false;\n@@ -49,1 +48,1 @@\n-    return true;\n+    return _evac_failure_regions_num == 0;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCEvacFailureInjector.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -337,1 +337,1 @@\n-class G1PostEvacuateCollectionSetCleanupTask2::ClearRetainedRegionBitmaps : public G1AbstractSubTask {\n+class G1PostEvacuateCollectionSetCleanupTask2::ProcessEvacuationFailedRegionsTask : public G1AbstractSubTask {\n@@ -341,1 +341,1 @@\n-  class ClearRetainedRegionBitmapsClosure : public HeapRegionClosure {\n+  class ProcessEvacuationFailedRegionsClosure : public HeapRegionClosure {\n@@ -345,3 +345,22 @@\n-      assert(r->bottom() == r->top_at_mark_start(),\n-             \"TAMS should have been reset for region %u\", r->hrm_index());\n-      G1CollectedHeap::heap()->clear_bitmap_for_region(r);\n+      G1CollectedHeap* g1h = G1CollectedHeap::heap();\n+      G1ConcurrentMark* cm = g1h->concurrent_mark();\n+\n+      uint region = r->hrm_index();\n+      assert(r->top_at_mark_start() == r->bottom(), \"TAMS must not have been set for region %u\", region);\n+      assert(cm->live_bytes(region) == 0, \"Marking live bytes must not be set for region %u\", region);\n+\n+      \/\/ Concurrent mark does not mark through regions that we retain (they are root\n+      \/\/ regions wrt to marking), so we must clear their mark data (tams, bitmap)\n+      \/\/ set eagerly or during evacuation failure.\n+      bool clear_mark_data = !g1h->collector_state()->in_concurrent_start_gc() ||\n+                             g1h->policy()->should_retain_evac_failed_region(r);\n+\n+      if (clear_mark_data) {\n+        g1h->clear_bitmap_for_region(r);\n+      } else {\n+        \/\/ This evacuation failed region is going to be marked through. Update mark data.\n+        r->set_top_at_mark_start(r->top());\n+        cm->set_live_bytes(r->hrm_index(), r->live_bytes());\n+        assert(cm->mark_bitmap()->get_next_marked_addr(r->bottom(), r->top_at_mark_start()) != r->top_at_mark_start(),\n+               \"Marks must be on bitmap for region %u\", r->hrm_index());\n+      }\n@@ -353,2 +372,2 @@\n-  ClearRetainedRegionBitmaps(G1EvacFailureRegions* evac_failure_regions) :\n-    G1AbstractSubTask(G1GCPhaseTimes::ClearRetainedRegionBitmaps),\n+  ProcessEvacuationFailedRegionsTask(G1EvacFailureRegions* evac_failure_regions) :\n+    G1AbstractSubTask(G1GCPhaseTimes::ProcessEvacuationFailedRegions),\n@@ -357,2 +376,0 @@\n-    assert(!G1CollectedHeap::heap()->collector_state()->in_concurrent_start_gc(),\n-           \"Should not clear bitmaps of retained regions during concurrent start\");\n@@ -370,1 +387,1 @@\n-    ClearRetainedRegionBitmapsClosure cl;\n+    ProcessEvacuationFailedRegionsClosure cl;\n@@ -528,0 +545,1 @@\n+  uint             _num_retained_regions;\n@@ -557,1 +575,1 @@\n-                                      G1GCPhaseTimes::RestoreRetainedRegionsNum);\n+                                      G1GCPhaseTimes::RestoreRetainedRegionsFailedNum);\n@@ -559,0 +577,1 @@\n+    bool retain_region = _g1h->policy()->should_retain_evac_failed_region(r);\n@@ -560,1 +579,8 @@\n-    r->handle_evacuation_failure();\n+    r->handle_evacuation_failure(retain_region);\n+    assert(r->is_old(), \"must already be relabelled as old\");\n+\n+    if (retain_region) {\n+      _g1h->retain_region(r);\n+      _num_retained_regions++;\n+    }\n+    assert(retain_region == r->rem_set()->is_tracked(), \"When retaining a region, remembered set should be kept.\");\n@@ -587,1 +613,2 @@\n-      _evac_failure_regions(evac_failure_regions) { }\n+      _evac_failure_regions(evac_failure_regions),\n+      _num_retained_regions(0) { }\n@@ -620,0 +647,2 @@\n+\n+  bool num_retained_regions() const { return _num_retained_regions; }\n@@ -624,1 +653,1 @@\n-  G1EvacInfo* _evacuation_info;\n+  G1EvacInfo*       _evacuation_info;\n@@ -662,0 +691,10 @@\n+\n+    G1GCPhaseTimes* p = _g1h->phase_times();\n+    bool has_new_retained_regions =\n+      p->sum_thread_work_items(G1GCPhaseTimes::RestoreRetainedRegions, G1GCPhaseTimes::RestoreRetainedRegionsRetainedNum) != 0;\n+\n+    if (has_new_retained_regions) {\n+      G1CollectionSetCandidates* candidates = _g1h->collection_set()->candidates();\n+      candidates->sort_by_efficiency();\n+    }\n+\n@@ -667,1 +706,1 @@\n-    _g1h->phase_times()->record_serial_free_cset_time_ms((Ticks::now() - serial_time).seconds() * 1000.0);\n+    p->record_serial_free_cset_time_ms((Ticks::now() - serial_time).seconds() * 1000.0);\n@@ -687,0 +726,4 @@\n+    _g1h->phase_times()->record_or_add_thread_work_item(G1GCPhaseTimes::RestoreRetainedRegions,\n+                                                        worker_id,\n+                                                        cl.num_retained_regions(),\n+                                                        G1GCPhaseTimes::RestoreRetainedRegionsRetainedNum);\n@@ -729,4 +772,1 @@\n-    \/\/ Keep marks on bitmaps in retained regions during concurrent start - they will all be old.\n-    if (!G1CollectedHeap::heap()->collector_state()->in_concurrent_start_gc()) {\n-      add_parallel_task(new ClearRetainedRegionBitmaps(evac_failure_regions));\n-    }\n+    add_parallel_task(new ProcessEvacuationFailedRegionsTask(evac_failure_regions));\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.cpp","additions":59,"deletions":19,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-\/\/ - Clear Retained Region Bitmaps (on evacuation failure)\n+\/\/ - Clear Retained Region Data (on evacuation failure)\n@@ -69,1 +69,1 @@\n-  class ClearRetainedRegionBitmaps;\n+  class ProcessEvacuationFailedRegionsTask;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -254,0 +254,6 @@\n+  product(uintx, G1RetainRegionLiveThresholdPercent, 85, EXPERIMENTAL,      \\\n+          \"Threshold for evacuation failed regions to be considered for \"   \\\n+          \"inclusion in the collection set candidates.\"                     \\\n+          \"Regions with live bytes exceeding this will not be retained.\")   \\\n+          range(0, 100)                                                     \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/gc\/g1\/g1_globals.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+#include \"runtime\/atomic.hpp\"\n@@ -103,1 +104,1 @@\n-void HeapRegion::handle_evacuation_failure() {\n+void HeapRegion::handle_evacuation_failure(bool retain) {\n@@ -110,1 +111,1 @@\n-  _rem_set->clear_locked(true \/* only_cardset *\/);\n+  _rem_set->clear_locked(true \/* only_cardset *\/, retain \/* keep_tracked *\/);\n@@ -266,1 +267,1 @@\n- void HeapRegion::note_evacuation_failure(bool during_concurrent_start) {\n+ void HeapRegion::note_evacuation_failure() {\n@@ -272,11 +273,0 @@\n-\n-  if (during_concurrent_start) {\n-    \/\/ Self-forwarding marks all objects. Adjust TAMS so that these marks are\n-    \/\/ below it.\n-    set_top_at_mark_start(top());\n-  } else {\n-    \/\/ Outside of the mixed phase all regions that had an evacuation failure must\n-    \/\/ be young regions, and their TAMS is always bottom. Similarly, before the\n-    \/\/ start of the mixed phase, we scrubbed and reset TAMS to bottom.\n-    assert(top_at_mark_start() == bottom(), \"must be\");\n-  }\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.cpp","additions":4,"deletions":14,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -486,1 +486,1 @@\n-  void note_evacuation_failure(bool during_concurrent_start);\n+  void note_evacuation_failure();\n@@ -532,1 +532,1 @@\n-  void handle_evacuation_failure();\n+  void handle_evacuation_failure(bool retain);\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -284,2 +284,2 @@\n-  assert(top_at_mark_start() == bottom(), \"CA region's TAMS must always be at bottom\");\n-  if (is_old_or_humongous()) {\n+  assert(top_at_mark_start() == bottom(), \"Region's TAMS must always be at bottom\");\n+  if (is_old_or_humongous() && !is_collection_set_candidate()) {\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -76,1 +76,1 @@\n-void HeapRegionRemSet::clear_locked(bool only_cardset) {\n+void HeapRegionRemSet::clear_locked(bool only_cardset, bool keep_tracked) {\n@@ -82,1 +82,5 @@\n-  set_state_untracked();\n+  if (!keep_tracked) {\n+    set_state_untracked();\n+  } else {\n+    assert(is_tracked(), \"must be\");\n+  }\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionRemSet.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -121,1 +121,1 @@\n-  void clear_locked(bool only_cardset = false);\n+  void clear_locked(bool only_cardset = false, bool keep_tracked = false);\n@@ -159,1 +159,1 @@\n-\n+  \/\/ Clean out code roots not having an oop pointing into this region any more.\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionRemSet.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -176,0 +176,1 @@\n+        new LogMessageWithLevel(\"Evac Fail Extra Cards\", Level.DEBUG),\n@@ -267,1 +268,3 @@\n-        new LogMessageWithLevel(\"Evacuation Failure Regions\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Process Evacuation Failed Regions\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Evacuation Failed Regions\", Level.DEBUG),\n+        new LogMessageWithLevel(\"New Retained Regions\", Level.DEBUG),\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestGCLogMessages.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -131,1 +131,1 @@\n-            \"ClearRetainedRegionsBitmap\",\n+            \"ProcessEvacuationFailedRegions\",\n","filename":"test\/jdk\/jdk\/jfr\/event\/gc\/collection\/TestG1ParallelPhases.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}