{"files":[{"patch":"@@ -2991,3 +2991,0 @@\n-  if (collector_state()->in_concurrent_start_gc()) {\n-    _cm->add_to_liveness(worker_id, obj, obj_size);\n-  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1033,1 +1033,1 @@\n-  inline bool is_in_cset(const HeapRegion *hr) const;\n+  inline bool is_in_cset(const HeapRegion* hr) const;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -474,0 +474,2 @@\n+  \/\/ Set live bytes for concurrent marking.\n+  void set_live_bytes(uint region, size_t live_words) { _region_mark_stats[region]._live_words = live_words; }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,2 +40,1 @@\n-    G1CollectorState* state = g1h->collector_state();\n-    hr->note_evacuation_failure(state->in_concurrent_start_gc());\n+    hr->note_evacuation_failure();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailureRegions.inline.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -409,1 +409,2 @@\n-  const double sum_ms = _cur_pre_evacuate_prepare_time_ms +\n+  const double sum_ms = pre_concurrent_start_ms +\n+                        _cur_pre_evacuate_prepare_time_ms +\n@@ -413,2 +414,1 @@\n-                        _recorded_prepare_heap_roots_time_ms +\n-                        pre_concurrent_start_ms;\n+                        _recorded_prepare_heap_roots_time_ms;\n@@ -418,0 +418,5 @@\n+  if (pre_concurrent_start_ms > 0.0) {\n+    debug_phase(_gc_par_phases[ResetMarkingState]);\n+    debug_phase(_gc_par_phases[NoteStartOfMark]);\n+  }\n+\n@@ -426,5 +431,0 @@\n-  if (pre_concurrent_start_ms > 0.0) {\n-    debug_phase(_gc_par_phases[ResetMarkingState]);\n-    debug_phase(_gc_par_phases[NoteStartOfMark]);\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1GCPhaseTimes.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -468,0 +468,7 @@\n+\n+  \/\/ Must be before collection set calculation, requires collection set to not\n+  \/\/ be calculated yet.\n+  if (collector_state()->in_concurrent_start_gc()) {\n+    concurrent_mark()->pre_concurrent_start(_gc_cause);\n+  }\n+\n@@ -512,4 +519,0 @@\n-  if (collector_state()->in_concurrent_start_gc()) {\n-    concurrent_mark()->pre_concurrent_start(_gc_cause);\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.cpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -348,0 +348,4 @@\n+      uint region = r->hrm_index();\n+      assert(r->top_at_mark_start() == r->bottom(), \"TAMS must not have been set for region %u\", region);\n+      assert(cm->live_bytes(region) == 0, \"Marking live bytes must not be set for region %u\", region);\n+\n@@ -349,3 +353,2 @@\n-      \/\/ regions wrt to marking), so we must clear their mark data (tams, statistics)\n-      \/\/ previously set eagerly. The marking information on the bitmap is also only\n-      \/\/ required in a Concurrent Start pause for non-retained regions.\n+      \/\/ regions wrt to marking), so we must clear their mark data (tams, bitmap)\n+      \/\/ set eagerly or during evacuation failure.\n@@ -357,4 +360,0 @@\n-        \/\/ Although we only update tams and statistics for evacuation failed regions during\n-        \/\/ the concurrent start pause, for simplicity always clear.\n-        r->reset_top_at_mark_start();\n-        cm->clear_statistics(r);\n@@ -362,0 +361,3 @@\n+        \/\/ Evacuation failed region is going to be marked through. Update mark data.\n+        r->set_top_at_mark_start(r->top());\n+        cm->set_live_bytes(r->hrm_index(), r->live_bytes());\n@@ -364,2 +366,0 @@\n-        assert(r->live_bytes() != 0, \"Live bytes must be set for region %u\", r->hrm_index());\n-        assert(r->bottom() != r->top_at_mark_start(), \"TAMS must be set for region %u\", r->hrm_index());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -266,1 +266,1 @@\n- void HeapRegion::note_evacuation_failure(bool during_concurrent_start) {\n+ void HeapRegion::note_evacuation_failure() {\n@@ -272,13 +272,0 @@\n-\n-  if (during_concurrent_start) {\n-    \/\/ By default, assume that evacuation failed regions will be part of the\n-    \/\/ marking, so update the TAMS to prepare for marking through them. We might\n-    \/\/ undo this decision later if we find that we want to evacuate that region\n-    \/\/ instead.\n-    set_top_at_mark_start(top());\n-  } else {\n-    \/\/ Outside of the concurrent start pause all regions that had an evacuation\n-    \/\/ failure must be regions that are not (about to be) marked through, their\n-    \/\/ TAMS must always be bottom.\n-    assert(top_at_mark_start() == bottom(), \"must be\");\n-  }\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.cpp","additions":1,"deletions":14,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -486,1 +486,1 @@\n-  void note_evacuation_failure(bool during_concurrent_start);\n+  void note_evacuation_failure();\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -285,4 +285,1 @@\n-  \/\/ Collection set candidate regions are never going to be marked through so there\n-  \/\/ is no need to set their TAMS. For regions in the collection set, assume that\n-  \/\/ it is likely they are not failing evacuation either.\n-  if (is_old_or_humongous() && !is_collection_set_candidate() && !in_collection_set()) {\n+  if (is_old_or_humongous() && !is_collection_set_candidate()) {\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.inline.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"}]}