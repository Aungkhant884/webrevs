{"files":[{"patch":"@@ -2474,0 +2474,6 @@\n+\n+  if (collector_state()->in_concurrent_start_gc()) {\n+    log_debug(gc, verify)(\"Marking state\");\n+    _verifier->verify_marking_state();\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -328,0 +328,9 @@\n+bool G1CMRootMemRegions::contains(const MemRegion mr) const {\n+  for (uint i = 0; i < _num_root_regions; i++) {\n+    if (_root_regions[i].equals(mr)) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n@@ -997,0 +1006,4 @@\n+bool G1ConcurrentMark::is_root_region(HeapRegion* r) {\n+  return root_regions()->contains(MemRegion(r->top_at_mark_start(), r->top()));\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -267,0 +267,4 @@\n+  \/\/ Is the given memregion contained in the root regions; the MemRegion must\n+  \/\/ match exactly.\n+  bool contains(const MemRegion mr) const;\n+\n@@ -558,0 +562,1 @@\n+  bool is_root_region(HeapRegion* r);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -440,0 +440,72 @@\n+class G1VerifyRegionMarkingStateClosure : public HeapRegionClosure {\n+  class MarkedBytesClosure {\n+    size_t _marked_words;\n+\n+  public:\n+    MarkedBytesClosure() : _marked_words(0) { }\n+\n+    inline size_t apply(oop obj) {\n+      size_t result = obj->size();\n+      _marked_words += result;\n+      return result;\n+    }\n+\n+    size_t marked_bytes() const { return _marked_words * HeapWordSize; }\n+  };\n+\n+public:\n+  virtual bool do_heap_region(HeapRegion* r) {\n+    if (r->is_free()) {\n+      return false;\n+    }\n+\n+    G1ConcurrentMark* cm = G1CollectedHeap::heap()->concurrent_mark();\n+\n+    bool part_of_marking = !(r->is_collection_set_candidate() || !r->is_old_or_humongous());\n+\n+    if (part_of_marking) {\n+      guarantee(r->bottom() != r->top_at_mark_start(), \"region %u (%s) does not have TAMS set\",\n+                                                       r->hrm_index(), r->get_short_type_str());\n+      size_t marked_bytes = cm->live_bytes(r->hrm_index());\n+\n+      MarkedBytesClosure cl;\n+      r->apply_to_marked_objects(cm->mark_bitmap(), &cl);\n+\n+      guarantee(cl.marked_bytes() == marked_bytes,\n+                \"region %u (%s) live bytes actual %zu and cache %zu differ\",\n+                r->hrm_index(), r->get_short_type_str(), cl.marked_bytes(), marked_bytes);\n+    } else {\n+      guarantee(r->bottom() == r->top_at_mark_start(),\n+                \"region %u (%s) has TAMS set \" PTR_FORMAT \" \" PTR_FORMAT,\n+                r->hrm_index(), r->get_short_type_str(), p2i(r->bottom()), p2i(r->top_at_mark_start()));\n+      guarantee(cm->live_bytes(r->hrm_index()) == 0,\n+                \"region %u (%s) has %zu live bytes recorded\",\n+                r->hrm_index(), r->get_short_type_str(), cm->live_bytes(r->hrm_index()));\n+      guarantee(cm->mark_bitmap()->get_next_marked_addr(r->bottom(), r->end()) == r->end(),\n+                \"region %u (%s) has mark\",\n+                r->hrm_index(), r->get_short_type_str());\n+      guarantee(cm->is_root_region(r),\n+                \"region %u (%s) should be root region\",\n+                r->hrm_index(), r->get_short_type_str());\n+    }\n+    return false;\n+  }\n+};\n+\n+void G1HeapVerifier::verify_marking_state() {\n+  assert(G1CollectedHeap::heap()->collector_state()->in_concurrent_start_gc(), \"must be\");\n+\n+  \/\/ Verify TAMSes, bitmaps and liveness statistics.\n+  \/\/\n+  \/\/ - if part of marking: TAMS != bottom, liveness == 0, bitmap clear\n+  \/\/ - if evacuation failed + part of marking: TAMS != bottom, liveness != 0, bitmap has at least on object set (corresponding to liveness)\n+  \/\/ - if not part of marking: TAMS == bottom, liveness == 0, bitmap clear; must be in root region\n+\n+  \/\/ To compare liveness recorded in G1ConcurrentMark and actual we need to flush the\n+  \/\/ cache.\n+  G1CollectedHeap::heap()->concurrent_mark()->flush_all_task_caches();\n+\n+  G1VerifyRegionMarkingStateClosure cl;\n+  _g1h->heap_region_iterate(&cl);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapVerifier.cpp","additions":72,"deletions":0,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -73,0 +73,3 @@\n+  \/\/ Verify that marking state is set up correctly after a concurrent start pause.\n+  void verify_marking_state();\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapVerifier.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -270,1 +270,1 @@\n-    double base_time_ms = predict_base_time_ms(pending_cards, rs_length);\n+    double base_time_ms = predict_base_time_ms(pending_cards, rs_length, true \/* include_retained *\/);\n@@ -1028,1 +1028,2 @@\n-                                      size_t rs_length) const {\n+                                      size_t rs_length,\n+                                      bool include_retained) const {\n@@ -1040,1 +1041,1 @@\n-  double retained_evac_time = predict_retained_regions_evac_time();\n+  double retained_evac_time = include_retained ? predict_retained_regions_evac_time() : -1.0;\n@@ -1042,1 +1043,2 @@\n-  double total_time = card_merge_time + card_scan_time + constant_other_time + survivor_evac_time + retained_evac_time;\n+  double total_time = card_merge_time + card_scan_time + constant_other_time + survivor_evac_time +\n+                      (include_retained ? retained_evac_time : 0.0);\n@@ -1056,1 +1058,1 @@\n-  return predict_base_time_ms(pending_cards, rs_length);\n+  return predict_base_time_ms(pending_cards, rs_length, false \/* include_retained *\/);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -145,1 +145,3 @@\n-  double predict_base_time_ms(size_t pending_cards, size_t rs_length) const;\n+  \/\/ The include_retained parameter determines whether the time retained regions\n+  \/\/ will take is included or not in this base time.\n+  double predict_base_time_ms(size_t pending_cards, size_t rs_length, bool include_retained) const;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -297,2 +297,2 @@\n-  assert(top_at_mark_start() == bottom(), \"CA region's TAMS must always be at bottom\");\n-  \/\/ Retained regions are not going to be scanned through.\n+  assert(top_at_mark_start() == bottom(), \"Region's TAMS must always be at bottom\");\n+  \/\/ Collection set candidate regions are never going to be marked through.\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -131,1 +131,1 @@\n-            \"ClearRetainedRegionsBitmap\",\n+            \"ClearRetainedRegionData\",\n","filename":"test\/jdk\/jdk\/jfr\/event\/gc\/collection\/TestG1ParallelPhases.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}