{"files":[{"patch":"@@ -2662,0 +2662,5 @@\n+void G1CollectedHeap::retain_region(HeapRegion* hr) {\n+  MutexLocker x(G1RareEvent_lock, Mutex::_no_safepoint_check_flag);\n+  collection_set()->candidates()->add_retained_region_unsorted(hr);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -687,0 +687,2 @@\n+  \/\/ Add the given region to the retained regions collection set candidates.\n+  void retain_region(HeapRegion* hr);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -323,1 +323,1 @@\n-  if (collector_state()->in_mixed_phase()) {\n+  if (!candidates()->is_empty()) {\n@@ -329,4 +329,9 @@\n-    _policy->select_candidates_from_marking(&candidates()->marking_regions(),\n-                                            time_remaining_ms,\n-                                            &initial_old_regions,\n-                                            &_optional_old_regions);\n+    time_remaining_ms = _policy->select_candidates_from_marking(&candidates()->marking_regions(),\n+                                                                time_remaining_ms,\n+                                                                &initial_old_regions,\n+                                                                &_optional_old_regions);\n+\n+    _policy->select_candidates_from_retained(&candidates()->retained_regions(),\n+                                             time_remaining_ms,\n+                                             &initial_old_regions,\n+                                             &_optional_old_regions);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSet.cpp","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -41,0 +41,9 @@\n+void G1CollectionCandidateList::append_unsorted(HeapRegion* r) {\n+  CandidateInfo c(r, r->calc_gc_efficiency());\n+  _candidates.append(c);\n+}\n+\n+void G1CollectionCandidateList::sort_by_efficiency() {\n+  _candidates.sort(compare);\n+}\n+\n@@ -145,0 +154,1 @@\n+  _retained_regions(),\n@@ -168,0 +178,1 @@\n+  _retained_regions.clear();\n@@ -191,0 +202,14 @@\n+void G1CollectionSetCandidates::sort_by_efficiency() {\n+  \/\/ From marking regions must always be sorted so no reason to actually sort\n+  \/\/ them.\n+  _marking_regions.verify();\n+  _retained_regions.sort_by_efficiency();\n+  _retained_regions.verify();\n+}\n+\n+void G1CollectionSetCandidates::add_retained_region_unsorted(HeapRegion* r) {\n+  assert(!contains(r), \"must not contain region %u\", r->hrm_index());\n+  _contains_map[r->hrm_index()] = CandidateOrigin::Retained;\n+  _retained_regions.append_unsorted(r);\n+}\n+\n@@ -192,1 +217,19 @@\n-  _marking_regions.remove(other);\n+  \/\/ During removal we exploit the fact that elements in the marking_regions,\n+  \/\/ retained_regions and other list are sorted by gc_efficiency. Furthermore,\n+  \/\/ all regions in the passed other list are in one of the two other lists.\n+  \/\/\n+  \/\/ Split original list into elements for the marking list and elements from the\n+  \/\/ retained list.\n+  G1CollectionCandidateRegionList other_marking_regions;\n+  G1CollectionCandidateRegionList other_retained_regions;\n+\n+  for (HeapRegion* r : *other) {\n+    if (is_from_marking(r)) {\n+      other_marking_regions.append(r);\n+    } else {\n+      other_retained_regions.append(r);\n+    }\n+  }\n+\n+  _marking_regions.remove(&other_marking_regions);\n+  _retained_regions.remove(&other_retained_regions);\n@@ -207,1 +250,5 @@\n-  return _marking_regions.length() != 0;\n+  return marking_regions_length() != 0;\n+}\n+\n+uint G1CollectionSetCandidates::marking_regions_length() const {\n+  return _marking_regions.length();\n@@ -221,1 +268,1 @@\n-    assert(_contains_map[hrm_index] == CandidateOrigin::Marking,\n+    assert(_contains_map[hrm_index] == CandidateOrigin::Marking || _contains_map[hrm_index] == CandidateOrigin::Retained,\n@@ -238,1 +285,0 @@\n-\n@@ -241,0 +287,6 @@\n+  uint from_marking_retained = 0;\n+  verify_helper(&_retained_regions, from_marking_retained, verify_map);\n+  assert(from_marking_retained == 0, \"must be\");\n+\n+  assert(length() >= marking_regions_length(), \"must be\");\n+\n@@ -265,0 +317,1 @@\n+    \"Cr\",  \/\/ Retained\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetCandidates.cpp","additions":57,"deletions":4,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -103,0 +103,5 @@\n+  \/\/ Add the given HeapRegion to this list at the end, (potentially) making the list unsorted.\n+  void append_unsorted(HeapRegion* r);\n+  \/\/ Restore sorting order by decreasing gc efficiency, using the existing efficiency\n+  \/\/ values.\n+  void sort_by_efficiency();\n@@ -132,1 +137,2 @@\n-\/\/ Iterator for G1CollectionSetCandidates.\n+\/\/ Iterator for G1CollectionSetCandidates. Multiplexes across the marking\/retained\n+\/\/ region lists based on gc efficiency.\n@@ -135,0 +141,1 @@\n+  bool _is_marking_selected;\n@@ -136,0 +143,1 @@\n+  uint _retained_position;\n@@ -137,0 +145,1 @@\n+  void select_list();\n@@ -138,1 +147,1 @@\n-  G1CollectionSetCandidatesIterator(G1CollectionSetCandidates* which, uint marking_position);\n+  G1CollectionSetCandidatesIterator(G1CollectionSetCandidates* which, uint marking_position, uint retained_position);\n@@ -149,1 +158,1 @@\n-\/\/ These candidate regions are tracked in a list of regions, sorted by decreasing\n+\/\/ These candidate regions are tracked in two list of regions, sorted by decreasing\n@@ -152,2 +161,0 @@\n-\/\/ Currently there is only one type of such regions:\n-\/\/\n@@ -159,0 +166,4 @@\n+\/\/ * retained regions: set of regions selected for evacuation during evacuation\n+\/\/                     failure.\n+\/\/                     Any young collection will try to evacuate them.\n+\/\/\n@@ -165,0 +176,1 @@\n+    Retained,                  \/\/ This region has been added because it had to be retained after evacuation.\n@@ -169,0 +181,1 @@\n+  G1CollectionCandidateList _retained_regions;\n@@ -183,0 +196,1 @@\n+  G1CollectionCandidateList& retained_regions() { return _retained_regions; }\n@@ -197,0 +211,5 @@\n+  void sort_by_efficiency();\n+\n+  \/\/ Add the given region to the set of retained regions without regards to the\n+  \/\/ gc efficiency sorting. The retained regions must be re-sorted manually later.\n+  void add_retained_region_unsorted(HeapRegion* r);\n@@ -206,1 +225,0 @@\n-  bool has_more_marking_candidates() const;\n@@ -208,1 +226,2 @@\n-  uint marking_regions_length() const { return _marking_regions.length(); }\n+  bool has_more_marking_candidates() const;\n+  uint marking_regions_length() const;\n@@ -216,1 +235,1 @@\n-  uint length() const { return marking_regions_length(); }\n+  uint length() const { return marking_regions_length() + _retained_regions.length(); }\n@@ -220,1 +239,1 @@\n-    return G1CollectionSetCandidatesIterator(this, 0);\n+    return G1CollectionSetCandidatesIterator(this, 0, 0);\n@@ -224,1 +243,1 @@\n-    return G1CollectionSetCandidatesIterator(this, marking_regions_length());\n+    return G1CollectionSetCandidatesIterator(this, marking_regions_length(), _retained_regions.length());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetCandidates.hpp","additions":29,"deletions":10,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -54,2 +54,14 @@\n-inline G1CollectionSetCandidatesIterator::G1CollectionSetCandidatesIterator(G1CollectionSetCandidates* which, uint marking_position) :\n-  _which(which), _marking_position(marking_position) {\n+inline G1CollectionSetCandidatesIterator::G1CollectionSetCandidatesIterator(G1CollectionSetCandidates* which, uint marking_position, uint retained_position) :\n+  _which(which), _is_marking_selected(false), _marking_position(marking_position), _retained_position(retained_position) {\n+\n+  select_list();\n+}\n+\n+inline void G1CollectionSetCandidatesIterator::select_list() {\n+  if (_marking_position >= _which->_marking_regions.length()) {\n+    _is_marking_selected = false;\n+  } else if (_retained_position >= _which->_retained_regions.length()) {\n+    _is_marking_selected = true;\n+  } else {\n+    _is_marking_selected = _which->_marking_regions.at(_marking_position)._gc_efficiency >= _which->_retained_regions.at(_retained_position)._gc_efficiency;\n+  }\n@@ -59,1 +71,1 @@\n-  assert(_marking_position < _which->_marking_regions.length(),\n+  assert(_marking_position < _which->_marking_regions.length() || _retained_position < _which->_retained_regions.length(),\n@@ -62,1 +74,6 @@\n-  _marking_position++;\n+  if (_is_marking_selected) {\n+    _marking_position++;\n+  } else {\n+    _retained_position++;\n+  }\n+  select_list();\n@@ -67,1 +84,5 @@\n-  return _which->_marking_regions.at(_marking_position)._r;\n+  if (_is_marking_selected) {\n+    return _which->_marking_regions.at(_marking_position)._r;\n+  } else {\n+    return _which->_retained_regions.at(_retained_position)._r;\n+  }\n@@ -72,1 +93,1 @@\n-  return _marking_position == rhs._marking_position;\n+  return _marking_position == rhs._marking_position && _retained_position == rhs._retained_position;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetCandidates.inline.hpp","additions":27,"deletions":6,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -34,3 +34,3 @@\n-\/\/ Determine collection set candidates: For all regions determine whether they\n-\/\/ should be a collection set candidates, calculate their efficiency, sort and\n-\/\/ return them as G1CollectionSetCandidates instance.\n+\/\/ Determine collection set candidates (from marking): For all regions determine\n+\/\/ whether they should be a collection set candidates, calculate their efficiency,\n+\/\/ sort and put them into the candidates.\n@@ -38,3 +38,2 @@\n-\/\/ put them into some work area unsorted. At the end the array is sorted and\n-\/\/ copied into the G1CollectionSetCandidates instance; the caller will be the new\n-\/\/ owner of this object.\n+\/\/ put them into some work area without sorting. At the end that array is sorted and\n+\/\/ moved to the destination.\n@@ -156,2 +155,4 @@\n-      } else if (r->is_old()) {\n-        \/\/ Keep remembered sets for humongous regions, otherwise clean them out.\n+        assert(r->rem_set()->is_complete(), \"must be %u\", r->hrm_index());\n+      } else if (r->is_old() && !r->is_collection_set_candidate()) {\n+        \/\/ Keep remembered sets for humongous regions and collection set candidates,\n+        \/\/ otherwise clean them out.\n@@ -160,1 +161,1 @@\n-        assert(!r->is_old() || !r->rem_set()->is_tracked(),\n+        assert(r->is_collection_set_candidate() || !r->is_old() || !r->rem_set()->is_tracked(),\n@@ -257,0 +258,4 @@\n+         \/\/ A region might have been retained (after evacuation failure) and already put\n+         \/\/ into the candidates list during concurrent marking. These should keep being\n+         \/\/ considered as retained regions.\n+         !hr->is_collection_set_candidate() &&\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetChooser.cpp","additions":14,"deletions":9,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -50,3 +50,2 @@\n-  \/\/ Determine whether to add the given region to the collection set candidates or\n-  \/\/ not. Currently, we skip regions that we will never move during young gc, and\n-  \/\/ regions which liveness is over the occupancy threshold.\n+  \/\/ Determine whether to add the given region to the collection set candidates from\n+  \/\/ marking or not. Currently, we skip regions whose live bytes are over the threshold.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetChooser.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1360,2 +1360,2 @@\n-        log_trace(gc)(\"Reclaimed empty old gen region %u (%s) bot \" PTR_FORMAT,\n-                      hr->hrm_index(), hr->get_short_type_str(), p2i(hr->bottom()));\n+        log_trace(gc, marking)(\"Reclaimed empty old gen region %u (%s) bot \" PTR_FORMAT,\n+                               hr->hrm_index(), hr->get_short_type_str(), p2i(hr->bottom()));\n@@ -1869,0 +1869,1 @@\n+      log_trace(gc, marking)(\"Claim region %u bottom \" PTR_FORMAT \" tams \" PTR_FORMAT, curr_region->hrm_index(), p2i(curr_region->bottom()), p2i(curr_region->top_at_mark_start()));\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -62,0 +62,2 @@\n+\/\/ Regions might have been reclaimed while scrubbing them after having yielded for\n+\/\/ a pause.\n@@ -89,2 +91,3 @@\n-    \/\/ has been aborted for any reason.\n-    bool yield_if_necessary() {\n+    \/\/ has been aborted for any reason. Yielded is set if there has been an actual\n+    \/\/ yield for a pause.\n+    bool yield_if_necessary(bool& yielded) {\n@@ -93,1 +96,1 @@\n-        _cm->do_yield_check();\n+        yielded = _cm->do_yield_check();\n@@ -104,1 +107,1 @@\n-    \/\/  - been eagerly reclaimed by a young collection (only humongous)\n+    \/\/  - been reclaimed by a collection.\n@@ -110,3 +113,3 @@\n-    \/\/ G1RebuildRemSetChunkSize. The heap region is needed to ensure a humongous object\n-    \/\/ is not eagerly reclaimed during yielding.\n-    \/\/ Returns whether marking has been aborted.\n+    \/\/ G1RebuildRemSetChunkSize. The heap region is needed check whether the region has\n+    \/\/ been reclaimed during yielding.\n+    \/\/ Returns true if marking has been aborted or false if completed.\n@@ -123,1 +126,2 @@\n-        bool mark_aborted = yield_if_necessary();\n+        bool yielded;\n+        bool mark_aborted = yield_if_necessary(yielded);\n@@ -126,4 +130,4 @@\n-        } else if (!should_rebuild_or_scrub(hr)) {\n-          \/\/ We need to check should_rebuild_or_scrub() again (for humongous objects)\n-          \/\/ because the region might have been eagerly reclaimed during the yield.\n-          log_trace(gc, marking)(\"Rebuild aborted for eagerly reclaimed humongous region: %u\", hr->hrm_index());\n+        } else if (yielded && !should_rebuild_or_scrub(hr)) {\n+          \/\/ We need to check should_rebuild_or_scrub() again because the region might\n+          \/\/ have been reclaimed during the yield.\n+          log_trace(gc, marking)(\"Rebuild aborted for reclaimed region: %u\", hr->hrm_index());\n@@ -133,1 +137,1 @@\n-        \/\/ Step to next chunk of the humongous object\n+        \/\/ Step to next chunk of the large object.\n@@ -191,1 +195,2 @@\n-        bool mark_aborted = yield_if_necessary();\n+        bool yielded;\n+        bool mark_aborted = yield_if_necessary(yielded);\n@@ -194,0 +199,4 @@\n+        } else if (yielded && !should_rebuild_or_scrub(hr)) {\n+          \/\/ Region has been reclaimed while yielding. Exit continuing with the next region.\n+          log_trace(gc, marking)(\"Scan and scrub aborted for reclaimed region: %u\", hr->hrm_index());\n+          return false;\n@@ -206,1 +215,2 @@\n-        bool mark_aborted = yield_if_necessary();\n+        bool yielded = true;\n+        bool mark_aborted = yield_if_necessary(yielded);\n@@ -209,0 +219,3 @@\n+        } else if (yielded && !should_rebuild_or_scrub(hr)) {\n+          log_trace(gc, marking)(\"Scan aborted for reclaimed region: %u\", hr->hrm_index());\n+          return false;\n@@ -219,2 +232,2 @@\n-      log_trace(gc, marking)(\"Scrub and rebuild region: \" HR_FORMAT \" pb: \" PTR_FORMAT \" TARS: \" PTR_FORMAT,\n-                             HR_FORMAT_PARAMS(hr), p2i(pb), p2i(_cm->top_at_rebuild_start(hr->hrm_index())));\n+      log_trace(gc, marking)(\"Scrub and rebuild region: \" HR_FORMAT \" pb: \" PTR_FORMAT \" TARS: \" PTR_FORMAT \" TAMS: \" PTR_FORMAT,\n+                             HR_FORMAT_PARAMS(hr), p2i(pb), p2i(_cm->top_at_rebuild_start(hr->hrm_index())), p2i(hr->top_at_mark_start()));\n@@ -227,0 +240,5 @@\n+      \/\/ Yielding during scrubbing and scanning might have reclaimed the region, so need to\n+      \/\/ re-check after above.\n+      if (!should_rebuild_or_scrub(hr)) {\n+        return false;\n+      }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentRebuildAndScrub.cpp","additions":35,"deletions":17,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-  \/\/ Return a G1AbstractSubTask which does necessary preparation for evacuation failure regions\n+  \/\/ Return a G1AbstractSubTask which does necessary preparation for evacuation failed regions\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailureRegions.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -129,0 +129,1 @@\n+  _gc_par_phases[MergePSS]->create_thread_work_items(\"Evac Fail Extra Cards\", MergePSSEvacFailExtra);\n@@ -130,1 +131,2 @@\n-  _gc_par_phases[RestoreRetainedRegions]->create_thread_work_items(\"Evacuation Failure Regions:\", RestoreRetainedRegionsNum);\n+  _gc_par_phases[RestoreRetainedRegions]->create_thread_work_items(\"Evacuation Failed Regions:\", RestoreRetainedRegionsFailedNum);\n+  _gc_par_phases[RestoreRetainedRegions]->create_thread_work_items(\"New Retained Regions:\", RestoreRetainedRegionsRetainedNum);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1GCPhaseTimes.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -141,1 +141,2 @@\n-    MergePSSLABUndoWasteBytes\n+    MergePSSLABUndoWasteBytes,\n+    MergePSSEvacFailExtra\n@@ -145,1 +146,2 @@\n-    RestoreRetainedRegionsNum,\n+    RestoreRetainedRegionsFailedNum,\n+    RestoreRetainedRegionsRetainedNum\n","filename":"src\/hotspot\/share\/gc\/g1\/g1GCPhaseTimes.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -91,1 +91,2 @@\n-    _evac_failure_regions(evac_failure_regions)\n+    _evac_failure_regions(evac_failure_regions),\n+    _evac_failure_enqeued_cards(0)\n@@ -150,0 +151,4 @@\n+size_t G1ParScanThreadState::evac_failure_enqueued_cards() const {\n+  return _evac_failure_enqeued_cards;\n+}\n+\n@@ -598,0 +603,1 @@\n+    size_t evac_fail_enqueued_cards = pss->evac_failure_enqueued_cards();\n@@ -602,0 +608,1 @@\n+    p->record_or_add_thread_work_item(G1GCPhaseTimes::MergePSS, worker_id, evac_fail_enqueued_cards, G1GCPhaseTimes::MergePSSEvacFailExtra);\n@@ -643,6 +650,3 @@\n-    \/\/ existing closure to scan evacuated objects because:\n-    \/\/ - for objects referring into the collection set we do not need to gather\n-    \/\/ cards at this time. The regions they are in will be unconditionally turned\n-    \/\/ to old regions without remembered sets.\n-    \/\/ - since we are iterating from a collection set region (i.e. never a Survivor\n-    \/\/ region), we always need to gather cards for this case.\n+    \/\/ existing closure to scan evacuated objects; since we are iterating from a\n+    \/\/ collection set region (i.e. never a Survivor region), we always need to\n+    \/\/ gather cards for this case.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":11,"deletions":7,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -112,0 +112,10 @@\n+  \/\/ Number of additional cards into evacuation failed regions enqueued into\n+  \/\/ the local DCQS. This is an approximation, as cards that would be added later\n+  \/\/ outside of evacuation failure will not be subtracted again.\n+  size_t _evac_failure_enqeued_cards;\n+\n+  \/\/ Enqueue the card if not already in the set; this is a best-effort attempt on\n+  \/\/ detecting duplicates.\n+  template <class T> bool enqueue_if_new(T* p);\n+  \/\/ Enqueue the card of p into the (evacuation failed) region.\n+  template <class T> void enqueue_card_into_evac_fail_region(T* p, oop obj);\n@@ -155,0 +165,2 @@\n+  size_t evac_failure_enqueued_cards() const;\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -99,0 +99,22 @@\n+template <class T> bool G1ParScanThreadState::enqueue_if_new(T* p) {\n+  size_t card_index = ct()->index_for(p);\n+  \/\/ If the card hasn't been added to the buffer, do it.\n+  if (_last_enqueued_card != card_index) {\n+    _rdc_local_qset.enqueue(ct()->byte_for_index(card_index));\n+    _last_enqueued_card = card_index;\n+    return true;\n+  } else {\n+    return false;\n+  }\n+}\n+\n+template <class T> void G1ParScanThreadState::enqueue_card_into_evac_fail_region(T* p, oop obj) {\n+  assert(!HeapRegion::is_in_same_region(p, obj), \"Should have filtered out cross-region references already.\");\n+  assert(!_g1h->heap_region_containing(p)->is_survivor(), \"Should have filtered out from-newly allocated survivor references already.\");\n+  assert(_g1h->heap_region_containing(obj)->in_collection_set(), \"Only for enqeueing reference into collection set region\");\n+\n+  if (enqueue_if_new(p)) {\n+    _evac_failure_enqeued_cards++;\n+  }\n+}\n+\n@@ -112,2 +134,3 @@\n-  \/\/ evacuation. Currently these regions are always relabelled as old without\n-  \/\/ remembered sets, so skip them.\n+  \/\/ evacuation. Proactively collect remembered sets (cards) for them as likely they\n+  \/\/ are sparsely populated (and have few references). We will decide later to keep\n+  \/\/ or drop the region.\n@@ -117,0 +140,1 @@\n+    enqueue_card_into_evac_fail_region(p, obj);\n@@ -140,6 +164,1 @@\n-  size_t card_index = ct()->index_for(p);\n-  \/\/ If the card hasn't been added to the buffer, do it.\n-  if (_last_enqueued_card != card_index) {\n-    _rdc_local_qset.enqueue(ct()->byte_for_index(card_index));\n-    _last_enqueued_card = card_index;\n-  }\n+  enqueue_if_new(p);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.inline.hpp","additions":27,"deletions":8,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -516,0 +516,21 @@\n+double G1Policy::predict_retained_regions_evac_time() const {\n+  uint num_regions = 0;\n+  double result = 0.0;\n+\n+  G1CollectionCandidateList& list = candidates()->retained_regions();\n+\n+  for (HeapRegion* r : list) {\n+    double predicted_time_ms = predict_region_total_time_ms(r, collector_state()->in_young_only_phase());\n+\n+    if (result + predicted_time_ms >= max_time_for_retaining()) {\n+      \/\/ Over limit. Exit.\n+      break;\n+    }\n+    result += predicted_time_ms;\n+    num_regions++;\n+  }\n+  log_trace(gc, ergo, heap)(\"Selected %u of %u retained candidates taking %1.3fms additional time (max %1.3fms)\",\n+                            num_regions, list.length(), result, max_time_for_retaining());\n+  return result;\n+}\n+\n@@ -626,0 +647,11 @@\n+bool G1Policy::retain_evac_failed_region(uint index) const {\n+  size_t live_bytes= _g1h->region_at(index)->live_bytes();\n+\n+  assert(live_bytes != 0,\n+         \"live bytes not set for %u used %zu garbage %zu cm-live %zu\",\n+         index, _g1h->region_at(index)->used(), _g1h->region_at(index)->garbage_bytes(), live_bytes);\n+\n+  size_t threshold = G1MixedGCLiveThresholdPercent * HeapRegion::GrainBytes \/ 100;\n+  return live_bytes < threshold;\n+}\n+\n@@ -1008,0 +1040,1 @@\n+  double retained_evac_time = predict_retained_regions_evac_time();\n@@ -1012,1 +1045,2 @@\n-                            \"card_merge_time %f card_scan_time %f constant_other_time %f survivor_evac_time %f\",\n+                            \"card_merge_time %f card_scan_time %f constant_other_time %f \"\n+                            \"survivor_evac_time %f retained_evac_time %f\",\n@@ -1014,1 +1048,2 @@\n-                            card_merge_time, card_scan_time, constant_other_time, survivor_evac_time);\n+                            card_merge_time, card_scan_time, constant_other_time,\n+                            survivor_evac_time, retained_evac_time);\n@@ -1497,0 +1532,69 @@\n+void G1Policy::select_candidates_from_retained(G1CollectionCandidateList* retained_list,\n+                                               double time_remaining_ms,\n+                                               G1CollectionCandidateRegionList* initial_old_regions,\n+                                               G1CollectionCandidateRegionList* optional_old_regions) {\n+\n+  \/\/ Guarantee some progress with retained regions regardless of available time by\n+  \/\/ taking at least one region.\n+  uint const min_regions = 1;\n+\n+  uint num_initial_regions_selected = 0;\n+  uint num_optional_regions_selected = 0;\n+  uint num_expensive_regions_selected = 0;\n+  uint num_unreclaimable_regions = 0;\n+\n+  double predicted_initial_time_ms = 0.0;\n+  double predicted_optional_time_ms = 0.0;\n+\n+  \/\/ We want to make sure that on the one hand we process the retained regions asap,\n+  \/\/ but on the other hand do not take too many of them as optional regions.\n+  \/\/ So we split the time budget into budget we will unconditionally take into the\n+  \/\/ initial old regions, and budget for taking optional regions from the retained\n+  \/\/ list.\n+  double optional_time_remaining_ms = max_time_for_retaining();\n+  time_remaining_ms = MIN2(time_remaining_ms, optional_time_remaining_ms);\n+\n+  log_debug(gc, ergo, cset)(\"Start adding retained candidates to collection set. \"\n+                            \"Min %u regions, \"\n+                            \"time remaining %1.2fms, optional remaining %1.2fms\",\n+                            min_regions, time_remaining_ms, optional_time_remaining_ms);\n+\n+  for (HeapRegion* r : *retained_list) {\n+    double predicted_time_ms = predict_region_total_time_ms(r, collector_state()->in_young_only_phase());\n+    bool fits_in_remaining_time = predicted_time_ms <= time_remaining_ms;\n+\n+    if (fits_in_remaining_time || (num_expensive_regions_selected < min_regions)) {\n+      predicted_initial_time_ms += predicted_time_ms;\n+      if (!fits_in_remaining_time) {\n+        num_expensive_regions_selected++;\n+      }\n+      initial_old_regions->append(r);\n+      num_initial_regions_selected++;\n+    } else if (predicted_time_ms <= optional_time_remaining_ms) {\n+      predicted_optional_time_ms += predicted_time_ms;\n+      optional_old_regions->append(r);\n+      num_optional_regions_selected++;\n+    } else {\n+      \/\/ Fits neither initial nor optional time limit. Exit.\n+      break;\n+    }\n+    time_remaining_ms = MAX2(0.0, time_remaining_ms - predicted_time_ms);\n+    optional_time_remaining_ms = MAX2(0.0, optional_time_remaining_ms - predicted_time_ms);\n+  }\n+\n+  uint num_regions_selected = num_initial_regions_selected + num_optional_regions_selected + num_unreclaimable_regions;\n+  if (num_regions_selected == retained_list->length()) {\n+    log_debug(gc, ergo, cset)(\"Retained candidates exhausted.\");\n+  }\n+  if (num_expensive_regions_selected > 0) {\n+    log_debug(gc, ergo, cset)(\"Added %u retained candidates to collection set although the predicted time was too high.\",\n+                              num_expensive_regions_selected);\n+  }\n+\n+  log_debug(gc, ergo, cset)(\"Finish adding retained candidates to collection set. Initial: %u, optional: %u, unreclaimable %u, \"\n+                            \"predicted initial time: %1.2fms, predicted optional time: %1.2fms, \"\n+                            \"time remaining: %1.2fms optional time remaining %1.2fms\",\n+                            num_initial_regions_selected, num_optional_regions_selected, num_unreclaimable_regions,\n+                            predicted_initial_time_ms, predicted_optional_time_ms, time_remaining_ms, optional_time_remaining_ms);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":106,"deletions":2,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -250,0 +250,1 @@\n+  double predict_retained_regions_evac_time() const;\n@@ -349,0 +350,5 @@\n+  void select_candidates_from_retained(G1CollectionCandidateList* retained_list,\n+                                       double time_remaining_ms,\n+                                       G1CollectionCandidateRegionList* initial_old_regions,\n+                                       G1CollectionCandidateRegionList* optional_old_regions);\n+\n@@ -404,0 +410,5 @@\n+  bool retain_evac_failed_region(HeapRegion* r) const {\n+    return retain_evac_failed_region(r->hrm_index());\n+  }\n+  bool retain_evac_failed_region(uint index) const;\n+\n@@ -430,0 +441,3 @@\n+  \/\/ Returns the total time that to at most reserve for handling retained regions.\n+  double max_time_for_retaining() const { return max_pause_time_ms() * optional_prediction_fraction(); }\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.hpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1105,4 +1105,5 @@\n-      \/\/ old regions are only in the collection set after the concurrent cycle completed,\n-      \/\/ so their bitmaps must also be clear except when the pause occurs during the\n-      \/\/ Concurrent Cleanup for Next Mark phase. Only at that point the region's bitmap may\n-      \/\/ contain marks while being in the collection set at the same time.\n+      \/\/ old regions that are currently being marked through are only in the collection set\n+      \/\/ after the concurrent cycle completed, so their bitmaps must also be clear except when\n+      \/\/ the pause occurs during the Concurrent Cleanup for Next Mark phase.\n+      \/\/ Only at that point the region's bitmap may contain marks while being in the collection\n+      \/\/ set at the same time.\n@@ -1133,0 +1134,1 @@\n+      _g1h->concurrent_mark()->clear_statistics(hr);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"gc\/g1\/g1CollectionSetCandidates.inline.hpp\"\n@@ -953,0 +954,9 @@\n+void G1YoungCollector::enqueue_candidates_as_root_regions() {\n+  assert(collector_state()->in_concurrent_start_gc(), \"must be\");\n+\n+  G1CollectionSetCandidates* candidates = collection_set()->candidates();\n+  for (HeapRegion* r : *candidates) {\n+    _g1h->concurrent_mark()->add_root_region(r);\n+  }\n+}\n+\n@@ -975,0 +985,7 @@\n+  \/\/ Regions in the collection set candidates are roots for the marking (they are\n+  \/\/ not marked through considering they are very likely to be reclaimed soon.\n+  \/\/ They need to be enqueued explicitly compared to survivor regions.\n+  if (collector_state()->in_concurrent_start_gc()) {\n+    enqueue_candidates_as_root_regions();\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.cpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -129,0 +129,2 @@\n+  \/\/ Enqueue collection set candidates as root regions.\n+  void enqueue_candidates_as_root_regions();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n-      return false;\n@@ -49,1 +48,1 @@\n-    return true;\n+    return _evac_failure_regions_num == 0;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCEvacFailureInjector.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -345,3 +345,19 @@\n-      assert(r->bottom() == r->top_at_mark_start(),\n-             \"TAMS should have been reset for region %u\", r->hrm_index());\n-      G1CollectedHeap::heap()->clear_bitmap_for_region(r);\n+      G1CollectedHeap* g1h = G1CollectedHeap::heap();\n+      G1ConcurrentMark* cm = g1h->concurrent_mark();\n+\n+      \/\/ Concurrent mark does not mark through regions that we retain (they are root\n+      \/\/ regions wrt to marking), so we can drop their mark data. The marking information\n+      \/\/ is also only required in a Concurrent Start pause.\n+      bool drop_mark_data = !g1h->collector_state()->in_concurrent_start_gc() ||\n+                            g1h->policy()->retain_evac_failed_region(r);\n+\n+      if (drop_mark_data) {\n+        g1h->clear_bitmap_for_region(r);\n+        r->reset_top_at_mark_start();\n+        cm->clear_statistics(r);\n+      } else {\n+        assert(cm->mark_bitmap()->get_next_marked_addr(r->bottom(), r->top_at_mark_start()) != r->top_at_mark_start(),\n+               \"Marks must be on bitmap for region %u\", r->hrm_index());\n+        assert(r->live_bytes() != 0, \"Live bytes must be set for region %u\", r->hrm_index());\n+        assert(r->bottom() != r->top_at_mark_start(), \"TAMS must be set for region %u\", r->hrm_index());\n+      }\n@@ -357,2 +373,0 @@\n-    assert(!G1CollectedHeap::heap()->collector_state()->in_concurrent_start_gc(),\n-           \"Should not clear bitmaps of retained regions during concurrent start\");\n@@ -528,0 +542,1 @@\n+  uint             _num_retained_regions;\n@@ -557,1 +572,1 @@\n-                                      G1GCPhaseTimes::RestoreRetainedRegionsNum);\n+                                      G1GCPhaseTimes::RestoreRetainedRegionsFailedNum);\n@@ -559,0 +574,1 @@\n+    bool retain_region = _g1h->policy()->retain_evac_failed_region(r);\n@@ -560,1 +576,8 @@\n-    r->handle_evacuation_failure();\n+    r->handle_evacuation_failure(retain_region);\n+    assert(r->is_old(), \"must already be relabelled as old\");\n+\n+    if (retain_region) {\n+      _g1h->retain_region(r);\n+      _num_retained_regions++;\n+    }\n+    assert(retain_region == r->rem_set()->is_tracked(), \"When retaining a region, remembered set should be kept.\");\n@@ -587,1 +610,2 @@\n-      _evac_failure_regions(evac_failure_regions) { }\n+      _evac_failure_regions(evac_failure_regions),\n+      _num_retained_regions(0) { }\n@@ -620,0 +644,2 @@\n+\n+  bool num_retained_regions() const { return _num_retained_regions; }\n@@ -624,1 +650,1 @@\n-  G1EvacInfo* _evacuation_info;\n+  G1EvacInfo*       _evacuation_info;\n@@ -662,0 +688,10 @@\n+\n+    G1GCPhaseTimes* p = _g1h->phase_times();\n+    bool has_new_retained_regions =\n+      p->sum_thread_work_items(G1GCPhaseTimes::RestoreRetainedRegions, G1GCPhaseTimes::RestoreRetainedRegionsRetainedNum) != 0;\n+\n+    if (has_new_retained_regions) {\n+      G1CollectionSetCandidates* candidates = _g1h->collection_set()->candidates();\n+      candidates->sort_by_efficiency();\n+    }\n+\n@@ -667,1 +703,1 @@\n-    _g1h->phase_times()->record_serial_free_cset_time_ms((Ticks::now() - serial_time).seconds() * 1000.0);\n+    p->record_serial_free_cset_time_ms((Ticks::now() - serial_time).seconds() * 1000.0);\n@@ -687,0 +723,4 @@\n+    _g1h->phase_times()->record_or_add_thread_work_item(G1GCPhaseTimes::RestoreRetainedRegions,\n+                                                        worker_id,\n+                                                        cl.num_retained_regions(),\n+                                                        G1GCPhaseTimes::RestoreRetainedRegionsRetainedNum);\n@@ -729,4 +769,1 @@\n-    \/\/ Keep marks on bitmaps in retained regions during concurrent start - they will all be old.\n-    if (!G1CollectedHeap::heap()->collector_state()->in_concurrent_start_gc()) {\n-      add_parallel_task(new ClearRetainedRegionBitmaps(evac_failure_regions));\n-    }\n+    add_parallel_task(new ClearRetainedRegionBitmaps(evac_failure_regions));\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.cpp","additions":51,"deletions":14,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -103,1 +103,1 @@\n-void HeapRegion::handle_evacuation_failure() {\n+void HeapRegion::handle_evacuation_failure(bool retain) {\n@@ -110,1 +110,1 @@\n-  _rem_set->clear_locked(true \/* only_cardset *\/);\n+  _rem_set->clear_locked(true \/* only_cardset *\/, retain \/* keep_tracked *\/);\n@@ -275,1 +275,2 @@\n-    \/\/ below it.\n+    \/\/ below it. We might undo this decision later if we find that we want to\n+    \/\/ evacuate that region asap.\n@@ -278,3 +279,3 @@\n-    \/\/ Outside of the mixed phase all regions that had an evacuation failure must\n-    \/\/ be young regions, and their TAMS is always bottom. Similarly, before the\n-    \/\/ start of the mixed phase, we scrubbed and reset TAMS to bottom.\n+    \/\/ Outside of the concurrent start pause all regions that had an evacuation\n+    \/\/ failure must be regions that are not (about to be) marked through, their\n+    \/\/ TAMS must always be bottom.\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.cpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -536,1 +536,1 @@\n-  void handle_evacuation_failure();\n+  void handle_evacuation_failure(bool retain);\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -298,1 +298,2 @@\n-  if (is_old_or_humongous()) {\n+  \/\/ Retained regions are not going to be scanned through.\n+  if (is_old_or_humongous() && !is_collection_set_candidate()) {\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.inline.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -76,1 +76,1 @@\n-void HeapRegionRemSet::clear_locked(bool only_cardset) {\n+void HeapRegionRemSet::clear_locked(bool only_cardset, bool keep_tracked) {\n@@ -82,1 +82,5 @@\n-  set_state_untracked();\n+  if (!keep_tracked) {\n+    set_state_untracked();\n+  } else {\n+    assert(is_tracked(), \"must be\");\n+  }\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionRemSet.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -121,1 +121,1 @@\n-  void clear_locked(bool only_cardset = false);\n+  void clear_locked(bool only_cardset = false, bool keep_tracked = false);\n@@ -159,1 +159,1 @@\n-\n+  \/\/ Clean out code roots not having an oop pointing into this region any more.\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionRemSet.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -176,0 +176,1 @@\n+        new LogMessageWithLevel(\"Evac Fail Extra Cards\", Level.DEBUG),\n@@ -267,1 +268,2 @@\n-        new LogMessageWithLevel(\"Evacuation Failure Regions\", Level.DEBUG),\n+        new LogMessageWithLevel(\"Evacuation Failed Regions\", Level.DEBUG),\n+        new LogMessageWithLevel(\"New Retained Regions\", Level.DEBUG),\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestGCLogMessages.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -147,0 +147,2 @@\n+System.out.println(output.getStdout());\n+\n@@ -164,1 +166,1 @@\n-                                       \"-Xlog:gc,gc+start,gc+verify=info\",\n+                                       \"-Xlog:gc,gc+start,gc+verify=info,gc+phases=debug,gc+heap=debug\",\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestVerifyGCType.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- * @run main\/othervm -XX:-UseGCOverheadLimit -Xmx128m vm.mlvm.hiddenloader.stress.oome.heap.Test\n+ * @run main\/othervm -XX:-UseGCOverheadLimit -Xlog:gc,gc+marking=trace -Xmx128m vm.mlvm.hiddenloader.stress.oome.heap.Test\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/vm\/mlvm\/hiddenloader\/stress\/oome\/heap\/Test.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}