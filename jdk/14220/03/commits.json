[{"commit":{"message":"More debug option removal"},"files":[],"sha":"a304afedb7ff3894ad0027748dbc7f6fe633dd48"},{"commit":{"message":"Remove debug options for tests"},"files":[],"sha":"beb682aed88953a6fd54d3faef79c26bef5f2f36"},{"commit":{"message":"iwalulya review #1"},"files":[{"filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetCandidates.cpp"},{"filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetChooser.cpp"},{"filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp"},{"filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.hpp"},{"filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.inline.hpp"},{"filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp"}],"sha":"364fa8239f490e84eb678216173cff8a78cfa887"},{"commit":{"message":"Doc additions"},"files":[{"filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetCandidates.hpp"}],"sha":"a957eaacb6e23a0ab7e76b2a59daedb3f8fbfdeb"},{"commit":{"message":"Fix trailing whitespace"},"files":[{"filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.cpp"}],"sha":"24d7c4992ca6db6faba9a929795afb2053fe292e"},{"commit":{"message":"This change adds management of retained regions, i.e. trying to evacuate evacuation failed\nregions asap.\n\nIt consists of several changes:\n\n* collect dirty cards into evacuation failed regions proactively (always). In my tests, the\n  amount of cards\/live objects has been very small. Dirty cards are put into the global\n  refinement buffer always, assuming that we will keep most if not all evacuation failed\n  regions.\n\n* post evac phase 2 will determine whether the region will be retained (kept for \"immediate\"\n  evacuation) or not.\n\n* these regions will be collected in a new \"from retained\" set in the collection set\n  candidates. Having the \"from retained\" and \"from marking\" sets separate in the collection\n  set candidates is ultimately easier than to use a single list and the picking stuff from\n  it.\n    * particularly wrt to making sure that mixed gcs preferentially pick from the \"from\n      marking\" list first, then second from the \"from retained\" list.\n\n* changes to determining the collection set:\n  * at any time before gc (determining young gen length) if there are entries in the retained\n    collection set candidates set (\"retained set\" in the following) g1 reserves up to 20% of\n    max gc pause time for it (random number) to make sure that these are cleared out asap to\n    free memory.\n  * during gc, the collection set is preferentially (first) populated with regions from the\n    \"from marking\" candidates (these are the important regions to get cleaned out), second\n    from the \"from retained\" list.\n\n* changes to end of gc\/marking\n  * retained regions will not be marked through during concurrent mark, i.e. they are\n    considered outside of the snapshot. So they are added to the \"root regions\" during the\n    concurrent start pause.\n    This may be a performance issue (we can't do a gc until all root regions have been\n    marked through), but so far since evacuation failure regions are typically very sparsely\n    populated, this is very fast."},"files":[{"filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp"},{"filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp"},{"filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSet.cpp"},{"filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetCandidates.cpp"},{"filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetCandidates.hpp"},{"filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetCandidates.inline.hpp"},{"filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetChooser.cpp"},{"filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetChooser.hpp"},{"filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp"},{"filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentRebuildAndScrub.cpp"},{"filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailureRegions.hpp"},{"filename":"src\/hotspot\/share\/gc\/g1\/g1GCPhaseTimes.cpp"},{"filename":"src\/hotspot\/share\/gc\/g1\/g1GCPhaseTimes.hpp"},{"filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp"},{"filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.hpp"},{"filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.inline.hpp"},{"filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp"},{"filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.hpp"},{"filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.cpp"},{"filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.cpp"},{"filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.hpp"},{"filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCEvacFailureInjector.cpp"},{"filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.cpp"},{"filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.cpp"},{"filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.hpp"},{"filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.inline.hpp"},{"filename":"src\/hotspot\/share\/gc\/g1\/heapRegionRemSet.cpp"},{"filename":"src\/hotspot\/share\/gc\/g1\/heapRegionRemSet.hpp"},{"filename":"test\/hotspot\/jtreg\/gc\/g1\/TestGCLogMessages.java"}],"sha":"263ff2856bd8d456cc795bf03332a1da54fa4e0d"}]