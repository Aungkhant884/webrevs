{"files":[{"patch":"@@ -28,0 +28,2 @@\n+import java.util.function.DoubleFunction;\n+import java.util.function.DoublePredicate;\n@@ -29,0 +31,1 @@\n+import java.util.function.DoubleUnaryOperator;\n@@ -187,0 +190,74 @@\n+    \/**\n+     * If a value is present, and the value matches the given predicate,\n+     * returns an {@code OptionalDouble} describing the value, otherwise returns\n+     * an empty {@code OptionalDouble}.\n+     *\n+     * @param predicate the predicate to apply to a value, if present\n+     * @return an {@code OptionalDouble} describing the value of this\n+     *         {@code OptionalDouble}, if a value is present and the value matches\n+     *         the given predicate, otherwise an empty {@code OptionalDouble}\n+     * @throws NullPointerException if the predicate is {@code null}\n+     * @since 16\n+     *\/\n+    public OptionalDouble filter(DoublePredicate predicate) {\n+        Objects.requireNonNull(predicate);\n+        if (!isPresent()) {\n+            return this;\n+        } else {\n+            return predicate.test(value) ? this : empty();\n+        }\n+    }\n+\n+    \/**\n+     * If a value is present, returns an {@code OptionalDouble} describing (as if\n+     * by {@link #of}) the result of applying the given mapping function to\n+     * the value, otherwise returns an empty {@code OptionalDouble}.\n+     *\n+     * @apiNote\n+     * This method supports post-processing on {@code OptionalDouble} values,\n+     * without the need to explicitly check for a return status.\n+     *\n+     * @param mapper the mapping function to apply to a value, if present\n+     * @return an {@code OptionalDouble} describing the result of applying a\n+     *         mapping function to the value of this {@code OptionalDouble},\n+     *         if a value is present, otherwise an empty {@code OptionalDouble}\n+     * @throws NullPointerException if the mapping function is {@code null}\n+     * @since 16\n+     *\/\n+    public OptionalDouble map(DoubleUnaryOperator mapper) {\n+        Objects.requireNonNull(mapper);\n+        if (!isPresent()) {\n+            return empty();\n+        } else {\n+            return OptionalDouble.of(mapper.applyAsDouble(value));\n+        }\n+    }\n+\n+    \/**\n+     * If a value is present, returns the result of applying the given\n+     * {@code OptionalDouble}-bearing mapping function to the value, otherwise returns\n+     * an empty {@code OptionalDouble}.\n+     *\n+     * <p>This method is similar to {@link #map(DoubleUnaryOperator)}, but the mapping\n+     * function is one whose result is already an {@code OptionalDouble}, and if\n+     * invoked, {@code flatMap} does not wrap it within an additional\n+     * {@code OptionalDouble}.\n+     *\n+     * @param mapper the mapping function to apply to a value, if present\n+     * @return the result of applying an {@code OptionalDouble}-bearing mapping\n+     *         function to the value of this {@code OptionalDouble}, if a value is\n+     *         present, otherwise an empty {@code OptionalDouble}\n+     * @throws NullPointerException if the mapping function is {@code null} or\n+     *         returns a {@code null} result\n+     * @since 16\n+     *\/\n+    public OptionalDouble flatMap(DoubleFunction<? extends OptionalDouble> mapper) {\n+        Objects.requireNonNull(mapper);\n+        if (!isPresent()) {\n+            return empty();\n+        } else {\n+            OptionalDouble r = mapper.apply(value);\n+            return Objects.requireNonNull(r);\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/OptionalDouble.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import java.util.function.IntFunction;\n+import java.util.function.IntPredicate;\n@@ -29,0 +31,1 @@\n+import java.util.function.IntUnaryOperator;\n@@ -187,0 +190,74 @@\n+    \/**\n+     * If a value is present, and the value matches the given predicate,\n+     * returns an {@code OptionalInt} describing the value, otherwise returns\n+     * an empty {@code OptionalInt}.\n+     *\n+     * @param predicate the predicate to apply to a value, if present\n+     * @return an {@code OptionalInt} describing the value of this\n+     *         {@code OptionalInt}, if a value is present and the value matches\n+     *         the given predicate, otherwise an empty {@code OptionalInt}\n+     * @throws NullPointerException if the predicate is {@code null}\n+     * @since 16\n+     *\/\n+    public OptionalInt filter(IntPredicate predicate) {\n+        Objects.requireNonNull(predicate);\n+        if (!isPresent()) {\n+            return this;\n+        } else {\n+            return predicate.test(value) ? this : empty();\n+        }\n+    }\n+\n+    \/**\n+     * If a value is present, returns an {@code OptionalInt} describing (as if\n+     * by {@link #of}) the result of applying the given mapping function to\n+     * the value, otherwise returns an empty {@code OptionalInt}.\n+     *\n+     * @apiNote\n+     * This method supports post-processing on {@code OptionalInt} values,\n+     * without the need to explicitly check for a return status.\n+     *\n+     * @param mapper the mapping function to apply to a value, if present\n+     * @return an {@code OptionalInt} describing the result of applying a\n+     *         mapping function to the value of this {@code OptionalInt},\n+     *         if a value is present, otherwise an empty {@code OptionalInt}\n+     * @throws NullPointerException if the mapping function is {@code null}\n+     * @since 16\n+     *\/\n+    public OptionalInt map(IntUnaryOperator mapper) {\n+        Objects.requireNonNull(mapper);\n+        if (!isPresent()) {\n+            return empty();\n+        } else {\n+            return OptionalInt.of(mapper.applyAsInt(value));\n+        }\n+    }\n+\n+    \/**\n+     * If a value is present, returns the result of applying the given\n+     * {@code OptionalInt}-bearing mapping function to the value, otherwise returns\n+     * an empty {@code OptionalInt}.\n+     *\n+     * <p>This method is similar to {@link #map(IntUnaryOperator)}, but the mapping\n+     * function is one whose result is already an {@code OptionalInt}, and if\n+     * invoked, {@code flatMap} does not wrap it within an additional\n+     * {@code OptionalInt}.\n+     *\n+     * @param mapper the mapping function to apply to a value, if present\n+     * @return the result of applying an {@code OptionalInt}-bearing mapping\n+     *         function to the value of this {@code OptionalInt}, if a value is\n+     *         present, otherwise an empty {@code OptionalInt}\n+     * @throws NullPointerException if the mapping function is {@code null} or\n+     *         returns a {@code null} result\n+     * @since 16\n+     *\/\n+    public OptionalInt flatMap(IntFunction<? extends OptionalInt> mapper) {\n+        Objects.requireNonNull(mapper);\n+        if (!isPresent()) {\n+            return empty();\n+        } else {\n+            OptionalInt r = mapper.apply(value);\n+            return Objects.requireNonNull(r);\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/OptionalInt.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import java.util.function.LongFunction;\n+import java.util.function.LongPredicate;\n@@ -29,0 +31,1 @@\n+import java.util.function.LongUnaryOperator;\n@@ -187,0 +190,74 @@\n+    \/**\n+     * If a value is present, and the value matches the given predicate,\n+     * returns an {@code OptionalLong} describing the value, otherwise returns\n+     * an empty {@code OptionalLong}.\n+     *\n+     * @param predicate the predicate to apply to a value, if present\n+     * @return an {@code OptionalLong} describing the value of this\n+     *         {@code OptionalLong}, if a value is present and the value matches\n+     *         the given predicate, otherwise an empty {@code OptionalLong}\n+     * @throws NullPointerException if the predicate is {@code null}\n+     * @since 16\n+     *\/\n+    public OptionalLong filter(LongPredicate predicate) {\n+        Objects.requireNonNull(predicate);\n+        if (!isPresent()) {\n+            return this;\n+        } else {\n+            return predicate.test(value) ? this : empty();\n+        }\n+    }\n+\n+    \/**\n+     * If a value is present, returns an {@code OptionalLong} describing (as if\n+     * by {@link #of}) the result of applying the given mapping function to\n+     * the value, otherwise returns an empty {@code OptionalLong}.\n+     *\n+     * @apiNote\n+     * This method supports post-processing on {@code OptionalLong} values,\n+     * without the need to explicitly check for a return status.\n+     *\n+     * @param mapper the mapping function to apply to a value, if present\n+     * @return an {@code OptionalLong} describing the result of applying a\n+     *         mapping function to the value of this {@code OptionalLong},\n+     *         if a value is present, otherwise an empty {@code OptionalLong}\n+     * @throws NullPointerException if the mapping function is {@code null}\n+     * @since 16\n+     *\/\n+    public OptionalLong map(LongUnaryOperator mapper) {\n+        Objects.requireNonNull(mapper);\n+        if (!isPresent()) {\n+            return empty();\n+        } else {\n+            return OptionalLong.of(mapper.applyAsLong(value));\n+        }\n+    }\n+\n+    \/**\n+     * If a value is present, returns the result of applying the given\n+     * {@code OptionalLong}-bearing mapping function to the value, otherwise returns\n+     * an empty {@code OptionalLong}.\n+     *\n+     * <p>This method is similar to {@link #map(LongUnaryOperator)}, but the mapping\n+     * function is one whose result is already an {@code OptionalLong}, and if\n+     * invoked, {@code flatMap} does not wrap it within an additional\n+     * {@code OptionalLong}.\n+     *\n+     * @param mapper the mapping function to apply to a value, if present\n+     * @return the result of applying an {@code OptionalLong}-bearing mapping\n+     *         function to the value of this {@code OptionalLong}, if a value is\n+     *         present, otherwise an empty {@code OptionalLong}\n+     * @throws NullPointerException if the mapping function is {@code null} or\n+     *         returns a {@code null} result\n+     * @since 16\n+     *\/\n+    public OptionalLong flatMap(LongFunction<? extends OptionalLong> mapper) {\n+        Objects.requireNonNull(mapper);\n+        if (!isPresent()) {\n+            return empty();\n+        } else {\n+            OptionalLong r = mapper.apply(value);\n+            return Objects.requireNonNull(r);\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/OptionalLong.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -122,0 +122,35 @@\n+    @Test(groups = \"unit\")\n+    public void testFilterEmpty() {\n+        checkEmpty(OptionalDouble.empty().filter(s -> {fail(); return true;}));\n+    }\n+\n+    @Test(groups = \"unit\")\n+    public void testFilterFalse() {\n+        checkEmpty(OptionalDouble.of(DOUBLEVAL).filter(Double::isNaN));\n+    }\n+\n+    @Test(groups = \"unit\")\n+    public void testFilterTrue() {\n+        checkPresent(OptionalDouble.of(DOUBLEVAL).filter(s -> s != UNEXPECTED), DOUBLEVAL);\n+    }\n+\n+    @Test(groups = \"unit\")\n+    public void testMapEmpty() {\n+        checkEmpty(OptionalDouble.empty().map(s -> {fail(); return DOUBLEVAL;}));\n+    }\n+\n+    @Test(groups = \"unit\")\n+    public void testMapPresent() {\n+        checkPresent(OptionalDouble.of(DOUBLEVAL).map(s -> Math.E), Math.E);\n+    }\n+\n+    @Test(groups = \"unit\")\n+    public void testFlatMapEmpty() {\n+        checkEmpty(OptionalDouble.empty().flatMap(s -> {fail(); return OptionalDouble.of(DOUBLEVAL);}));\n+    }\n+\n+    @Test(groups = \"unit\")\n+    public void testFlatMapPresent() {\n+        checkPresent(OptionalDouble.of(DOUBLEVAL).flatMap(s -> OptionalDouble.of(Math.E)), Math.E);\n+    }\n+\n","filename":"test\/jdk\/java\/util\/Optional\/BasicDouble.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -123,0 +123,35 @@\n+    @Test(groups = \"unit\")\n+    public void testFilterEmpty() {\n+        checkEmpty(OptionalInt.empty().filter(s -> {fail(); return true;}));\n+    }\n+\n+    @Test(groups = \"unit\")\n+    public void testFilterFalse() {\n+        checkEmpty(OptionalInt.of(INTVAL).filter(s -> s == UNEXPECTED));\n+    }\n+\n+    @Test(groups = \"unit\")\n+    public void testFilterTrue() {\n+        checkPresent(OptionalInt.of(INTVAL).filter(s -> s > 0), INTVAL);\n+    }\n+\n+    @Test(groups = \"unit\")\n+    public void testMapEmpty() {\n+        checkEmpty(OptionalInt.empty().map(s -> {fail(); return INTVAL;}));\n+    }\n+\n+    @Test(groups = \"unit\")\n+    public void testMapPresent() {\n+        checkPresent(OptionalInt.of(INTVAL).map(s -> 0xC0FFEE), 0xC0FFEE);\n+    }\n+\n+    @Test(groups = \"unit\")\n+    public void testFlatMapEmpty() {\n+        checkEmpty(OptionalInt.empty().flatMap(s -> {fail(); return OptionalInt.of(INTVAL);}));\n+    }\n+\n+    @Test(groups = \"unit\")\n+    public void testFlatMapPresent() {\n+        checkPresent(OptionalInt.of(INTVAL).flatMap(s -> OptionalInt.of(0xC0FFEE)), 0xC0FFEE);\n+    }\n+\n","filename":"test\/jdk\/java\/util\/Optional\/BasicInt.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -122,0 +122,35 @@\n+    @Test(groups = \"unit\")\n+    public void testFilterEmpty() {\n+        checkEmpty(OptionalLong.empty().filter(s -> {fail(); return true;}));\n+    }\n+\n+    @Test(groups = \"unit\")\n+    public void testFilterFalse() {\n+        checkEmpty(OptionalLong.of(LONGVAL).filter(s -> s == UNEXPECTED));\n+    }\n+\n+    @Test(groups = \"unit\")\n+    public void testFilterTrue() {\n+        checkPresent(OptionalLong.of(LONGVAL).filter(s -> s > 0), LONGVAL);\n+    }\n+\n+    @Test(groups = \"unit\")\n+    public void testMapEmpty() {\n+        checkEmpty(OptionalLong.empty().map(s -> {fail(); return LONGVAL;}));\n+    }\n+\n+    @Test(groups = \"unit\")\n+    public void testMapPresent() {\n+        checkPresent(OptionalLong.of(LONGVAL).map(s -> 0xC0FFEEL), 0xC0FFEEL);\n+    }\n+\n+    @Test(groups = \"unit\")\n+    public void testFlatMapEmpty() {\n+        checkEmpty(OptionalLong.empty().flatMap(s -> {fail(); return OptionalLong.of(LONGVAL);}));\n+    }\n+\n+    @Test(groups = \"unit\")\n+    public void testFlatMapPresent() {\n+        checkPresent(OptionalLong.of(LONGVAL).flatMap(s -> OptionalLong.of(0xC0FFEEL)), 0xC0FFEEL);\n+    }\n+\n","filename":"test\/jdk\/java\/util\/Optional\/BasicLong.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"modified"}]}