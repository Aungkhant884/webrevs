{"files":[{"patch":"@@ -69,19 +69,0 @@\n-\/\/ Total malloc invocation count\n-size_t MallocMemorySnapshot::total_count() const {\n-  size_t amount = 0;\n-  for (int index = 0; index < mt_number_of_types; index ++) {\n-    amount += _malloc[index].malloc_count();\n-  }\n-  return amount;\n-}\n-\n-\/\/ Total malloc'd memory amount\n-size_t MallocMemorySnapshot::total() const {\n-  size_t amount = 0;\n-  for (int index = 0; index < mt_number_of_types; index ++) {\n-    amount += _malloc[index].malloc_size();\n-  }\n-  amount += _tracking_header.size() + total_arena();\n-  return amount;\n-}\n-\n@@ -103,0 +84,1 @@\n+  _all_mallocs.deallocate(arena_size);\n@@ -130,1 +112,0 @@\n-  MallocMemorySummary::record_new_malloc_header(sizeof(MallocHeader));\n@@ -165,1 +146,0 @@\n-  MallocMemorySummary::record_free_malloc_header(sizeof(MallocHeader));\n","filename":"src\/hotspot\/share\/services\/mallocTracker.cpp","additions":1,"deletions":21,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -144,1 +144,1 @@\n-  MemoryCounter     _tracking_header;\n+  MemoryCounter     _all_mallocs;\n@@ -153,2 +153,2 @@\n-  inline MemoryCounter* malloc_overhead() {\n-    return &_tracking_header;\n+  inline size_t malloc_overhead() const {\n+    return _all_mallocs.count() * sizeof(MallocHeader);\n@@ -158,1 +158,4 @@\n-  size_t total_count() const;\n+  size_t total_count() const {\n+    return _all_mallocs.count();\n+  }\n+\n@@ -160,1 +163,4 @@\n-  size_t total() const;\n+  size_t total() const {\n+    return _all_mallocs.size() + malloc_overhead() + total_arena();\n+  }\n+\n@@ -174,1 +180,1 @@\n-    s->_tracking_header = _tracking_header;\n+    s->_all_mallocs = _all_mallocs;\n@@ -198,0 +204,1 @@\n+     as_snapshot()->_all_mallocs.allocate(size);\n@@ -202,0 +209,1 @@\n+     as_snapshot()->_all_mallocs.deallocate(size);\n@@ -221,9 +229,0 @@\n-   \/\/ Record memory used by malloc tracking header\n-   static inline void record_new_malloc_header(size_t sz) {\n-     as_snapshot()->malloc_overhead()->allocate(sz);\n-   }\n-\n-   static inline void record_free_malloc_header(size_t sz) {\n-     as_snapshot()->malloc_overhead()->deallocate(sz);\n-   }\n-\n@@ -232,1 +231,1 @@\n-     return as_snapshot()->malloc_overhead()->size();\n+     return as_snapshot()->malloc_overhead();\n","filename":"src\/hotspot\/share\/services\/mallocTracker.hpp","additions":15,"deletions":16,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -143,1 +143,1 @@\n-    return bl->_malloc_memory_snapshot.malloc_overhead()->size();\n+    return bl->_malloc_memory_snapshot.malloc_overhead();\n","filename":"src\/hotspot\/share\/services\/memBaseline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -160,2 +160,2 @@\n-    reserved_amount  += _malloc_snapshot->malloc_overhead()->size();\n-    committed_amount += _malloc_snapshot->malloc_overhead()->size();\n+    reserved_amount  += _malloc_snapshot->malloc_overhead();\n+    committed_amount += _malloc_snapshot->malloc_overhead();\n@@ -213,1 +213,1 @@\n-      amount_in_current_scale(_malloc_snapshot->malloc_overhead()->size()) > 0) {\n+      amount_in_current_scale(_malloc_snapshot->malloc_overhead()) > 0) {\n@@ -215,1 +215,1 @@\n-        amount_in_current_scale(_malloc_snapshot->malloc_overhead()->size()), scale);\n+        amount_in_current_scale(_malloc_snapshot->malloc_overhead()), scale);\n","filename":"src\/hotspot\/share\/services\/memReporter.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,117 @@\n+\/*\n+ * Copyright (c) 2022 SAP SE. All rights reserved.\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"services\/mallocTracker.hpp\"\n+#include \"services\/memTracker.hpp\"\n+#include \"unittest.hpp\"\n+\n+\/\/ convenience log. switch on if debugging tests. Don't use tty, plain stdio only.\n+#define LOG(...) { printf(__VA_ARGS__); printf(\"\\n\"); fflush(stdout); }\n+\/\/#define LOG(...)\n+\n+static size_t get_total_malloc_invocs() {\n+  return MallocMemorySummary::as_snapshot()->total_count();\n+}\n+\n+static size_t get_total_malloc_size() {\n+  return MallocMemorySummary::as_snapshot()->total();\n+}\n+\n+static size_t get_malloc_overhead() {\n+  return MallocMemorySummary::as_snapshot()->malloc_overhead();\n+}\n+\n+struct totals_t { size_t n; size_t s; size_t ovrh; };\n+\n+static totals_t get_totals() {\n+  totals_t tot;\n+  tot.n = get_total_malloc_invocs();\n+  tot.s = get_total_malloc_size();\n+  tot.ovrh = get_malloc_overhead();\n+  return tot;\n+}\n+\n+\/\/ Concurrent code can malloc and free too, therefore we need to compare with a leeway factor\n+#define compare_totals(t_real, t_expected) {                                  \\\n+  double leeway_factor = 0.33;                                                \\\n+  size_t leeway_n = (size_t)(((double)t_expected.n) * leeway_factor);         \\\n+  size_t leeway_s = (size_t)(((double)t_expected.s) * leeway_factor);         \\\n+  EXPECT_GE(t_real.n, t_expected.n - leeway_n);                               \\\n+  EXPECT_LE(t_real.n, t_expected.n + leeway_n);                               \\\n+  EXPECT_GE(t_real.s, t_expected.s - leeway_s);                               \\\n+  EXPECT_LE(t_real.s, t_expected.s + leeway_s);                               \\\n+  EXPECT_GE(t_real.ovrh, t_expected.ovrh - (leeway_n * sizeof(MallocHeader)));   \\\n+  EXPECT_LE(t_real.ovrh, t_expected.ovrh + (leeway_n * sizeof(MallocHeader)));   \\\n+  LOG(\"Deviation: n=\" SSIZE_FORMAT \", s=\" SSIZE_FORMAT \", ovrh=\" SSIZE_FORMAT,   \\\n+      (ssize_t)t_real.n - (ssize_t)t_expected.n,                                 \\\n+      (ssize_t)t_real.s - (ssize_t)t_expected.s,                                 \\\n+      (ssize_t)t_real.ovrh - (ssize_t)t_expected.ovrh);                          \\\n+}\n+\n+TEST_VM(NMTNumbers, totals) {\n+\n+  if (!MemTracker::enabled()) {\n+    \/\/ Skip test if NMT is disabled\n+    return;\n+  }\n+\n+  const totals_t t1 = get_totals();\n+\n+  LOG(\"t1: \" SIZE_FORMAT \" - \" SIZE_FORMAT \" - \" SIZE_FORMAT, t1.n, t1.s, t1.ovrh);\n+\n+  static const int NUM_ALLOCS = 1024 * 16;\n+  static const int ALLOC_SIZE = 1024;\n+\n+  void* p[NUM_ALLOCS];\n+  for (int i = 0; i < NUM_ALLOCS; i ++) {\n+    \/\/ spread over categories\n+    int category = i % (mt_number_of_types - 1);\n+    p[i] = NEW_C_HEAP_ARRAY(char, ALLOC_SIZE, (MEMFLAGS)category);\n+  }\n+\n+  const totals_t t2 = get_totals();\n+  LOG(\"t2: \" SIZE_FORMAT \" - \" SIZE_FORMAT \" - \" SIZE_FORMAT, t2.n, t2.s, t2.ovrh);\n+\n+  totals_t t2_expected;\n+  t2_expected.n = t1.n + NUM_ALLOCS;\n+  t2_expected.s = t1.s + ALLOC_SIZE * NUM_ALLOCS;\n+  t2_expected.ovrh = (t1.n + NUM_ALLOCS) * sizeof(MallocHeader);\n+\n+  LOG(\"t2 expected: \" SIZE_FORMAT \" - \" SIZE_FORMAT \" - \" SIZE_FORMAT, t2_expected.n, t2_expected.s, t2_expected.ovrh);\n+\n+  compare_totals(t2, t2_expected);\n+\n+  for (int i = 0; i < NUM_ALLOCS; i ++) {\n+    os::free(p[i]);\n+  }\n+\n+  const totals_t t3 = get_totals();\n+  LOG(\"t3: \" SIZE_FORMAT \" - \" SIZE_FORMAT \" - \" SIZE_FORMAT, t3.n, t3.s, t3.ovrh);\n+\n+  compare_totals(t3, t1);\n+\n+}\n","filename":"test\/hotspot\/gtest\/nmt\/test_nmt_totals.cpp","additions":117,"deletions":0,"binary":false,"changes":117,"status":"added"}]}