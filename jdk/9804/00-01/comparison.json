{"files":[{"patch":"@@ -0,0 +1,117 @@\n+\/*\n+ * Copyright (c) 2022 SAP SE. All rights reserved.\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"services\/mallocTracker.hpp\"\n+#include \"services\/memTracker.hpp\"\n+#include \"unittest.hpp\"\n+\n+\/\/ convenience log. switch on if debugging tests. Don't use tty, plain stdio only.\n+#define LOG(...) { printf(__VA_ARGS__); printf(\"\\n\"); fflush(stdout); }\n+\/\/#define LOG(...)\n+\n+static size_t get_total_malloc_invocs() {\n+  return MallocMemorySummary::as_snapshot()->total_count();\n+}\n+\n+static size_t get_total_malloc_size() {\n+  return MallocMemorySummary::as_snapshot()->total();\n+}\n+\n+static size_t get_malloc_overhead() {\n+  return MallocMemorySummary::as_snapshot()->malloc_overhead();\n+}\n+\n+struct totals_t { size_t n; size_t s; size_t ovrh; };\n+\n+static totals_t get_totals() {\n+  totals_t tot;\n+  tot.n = get_total_malloc_invocs();\n+  tot.s = get_total_malloc_size();\n+  tot.ovrh = get_malloc_overhead();\n+  return tot;\n+}\n+\n+\/\/ Concurrent code can malloc and free too, therefore we need to compare with a leeway factor\n+#define compare_totals(t_real, t_expected) {                                  \\\n+  double leeway_factor = 0.33;                                                \\\n+  size_t leeway_n = (size_t)(((double)t_expected.n) * leeway_factor);         \\\n+  size_t leeway_s = (size_t)(((double)t_expected.s) * leeway_factor);         \\\n+  EXPECT_GE(t_real.n, t_expected.n - leeway_n);                               \\\n+  EXPECT_LE(t_real.n, t_expected.n + leeway_n);                               \\\n+  EXPECT_GE(t_real.s, t_expected.s - leeway_s);                               \\\n+  EXPECT_LE(t_real.s, t_expected.s + leeway_s);                               \\\n+  EXPECT_GE(t_real.ovrh, t_expected.ovrh - (leeway_n * sizeof(MallocHeader)));   \\\n+  EXPECT_LE(t_real.ovrh, t_expected.ovrh + (leeway_n * sizeof(MallocHeader)));   \\\n+  LOG(\"Deviation: n=\" SSIZE_FORMAT \", s=\" SSIZE_FORMAT \", ovrh=\" SSIZE_FORMAT,   \\\n+      (ssize_t)t_real.n - (ssize_t)t_expected.n,                                 \\\n+      (ssize_t)t_real.s - (ssize_t)t_expected.s,                                 \\\n+      (ssize_t)t_real.ovrh - (ssize_t)t_expected.ovrh);                          \\\n+}\n+\n+TEST_VM(NMTNumbers, totals) {\n+\n+  if (!MemTracker::enabled()) {\n+    \/\/ Skip test if NMT is disabled\n+    return;\n+  }\n+\n+  const totals_t t1 = get_totals();\n+\n+  LOG(\"t1: \" SIZE_FORMAT \" - \" SIZE_FORMAT \" - \" SIZE_FORMAT, t1.n, t1.s, t1.ovrh);\n+\n+  static const int NUM_ALLOCS = 1024 * 16;\n+  static const int ALLOC_SIZE = 1024;\n+\n+  void* p[NUM_ALLOCS];\n+  for (int i = 0; i < NUM_ALLOCS; i ++) {\n+    \/\/ spread over categories\n+    int category = i % (mt_number_of_types - 1);\n+    p[i] = NEW_C_HEAP_ARRAY(char, ALLOC_SIZE, (MEMFLAGS)category);\n+  }\n+\n+  const totals_t t2 = get_totals();\n+  LOG(\"t2: \" SIZE_FORMAT \" - \" SIZE_FORMAT \" - \" SIZE_FORMAT, t2.n, t2.s, t2.ovrh);\n+\n+  totals_t t2_expected;\n+  t2_expected.n = t1.n + NUM_ALLOCS;\n+  t2_expected.s = t1.s + ALLOC_SIZE * NUM_ALLOCS;\n+  t2_expected.ovrh = (t1.n + NUM_ALLOCS) * sizeof(MallocHeader);\n+\n+  LOG(\"t2 expected: \" SIZE_FORMAT \" - \" SIZE_FORMAT \" - \" SIZE_FORMAT, t2_expected.n, t2_expected.s, t2_expected.ovrh);\n+\n+  compare_totals(t2, t2_expected);\n+\n+  for (int i = 0; i < NUM_ALLOCS; i ++) {\n+    os::free(p[i]);\n+  }\n+\n+  const totals_t t3 = get_totals();\n+  LOG(\"t3: \" SIZE_FORMAT \" - \" SIZE_FORMAT \" - \" SIZE_FORMAT, t3.n, t3.s, t3.ovrh);\n+\n+  compare_totals(t3, t1);\n+\n+}\n","filename":"test\/hotspot\/gtest\/nmt\/test_nmt_totals.cpp","additions":117,"deletions":0,"binary":false,"changes":117,"status":"added"}]}