{"files":[{"patch":"@@ -46,0 +46,1 @@\n+#include \"runtime\/atomic.hpp\"\n@@ -53,0 +54,1 @@\n+volatile Thread* ClassListParser::_parsing_thread = NULL;\n@@ -56,2 +58,0 @@\n-  assert(_instance == NULL, \"must be singleton\");\n-  _instance = this;\n@@ -76,0 +76,9 @@\n+\n+  \/\/ _instance should only be accessed by the thread that created _instance.\n+  assert(_instance == NULL, \"must be singleton\");\n+  _instance = this;\n+  Atomic::store(&_parsing_thread, Thread::current());\n+}\n+\n+bool ClassListParser::is_parsing_thread() {\n+  return Atomic::load(&_parsing_thread) == Thread::current();\n@@ -82,0 +91,1 @@\n+  Atomic::store(&_parsing_thread, (Thread*)NULL);\n","filename":"src\/hotspot\/share\/classfile\/classListParser.cpp","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+class Thread;\n+\n@@ -84,0 +86,1 @@\n+  static volatile Thread* _parsing_thread; \/\/ the thread that created _instance\n@@ -122,0 +125,1 @@\n+  static bool is_parsing_thread();\n@@ -123,0 +127,2 @@\n+    assert(is_parsing_thread(), \"call this only in the thread that created ClassListParsing::_instance\");\n+    assert(_instance != NULL, \"must be\");\n@@ -125,0 +131,1 @@\n+\n","filename":"src\/hotspot\/share\/classfile\/classListParser.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -372,2 +372,2 @@\n-    InstanceKlass* k = SystemDictionaryShared::dump_time_resolve_super_or_fail(class_name,\n-        super_name, class_loader, protection_domain, is_superclass, CHECK_NULL);\n+    InstanceKlass* k = SystemDictionaryShared::lookup_super_for_unregistered_class(class_name,\n+                           super_name, is_superclass);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1199,2 +1199,2 @@\n-\/\/ This function is called to resolve the super\/interfaces of shared classes for\n-\/\/ non-built-in loaders. E.g., SharedClass in the below example\n+\/\/ This function is called to lookup the super\/interfaces of shared classes for\n+\/\/ unregistered loaders. E.g., SharedClass in the below example\n@@ -1204,1 +1204,1 @@\n-\/\/ Interface   id: 2 super: 0 source: cust.jar\n+\/\/ Interface    id: 2 super: 0 source: cust.jar\n@@ -1206,3 +1206,2 @@\n-InstanceKlass* SystemDictionaryShared::dump_time_resolve_super_or_fail(\n-    Symbol* class_name, Symbol* super_name, Handle class_loader,\n-    Handle protection_domain, bool is_superclass, TRAPS) {\n+InstanceKlass* SystemDictionaryShared::lookup_super_for_unregistered_class(\n+    Symbol* class_name, Symbol* super_name, bool is_superclass) {\n@@ -1210,1 +1209,7 @@\n-  assert(DumpSharedSpaces, \"only when dumping\");\n+  assert(DumpSharedSpaces, \"only when static dumping\");\n+\n+  if (!ClassListParser::is_parsing_thread()) {\n+    \/\/ Unregistered classes can be created only by ClassListParser::_parsing_thread.\n+\n+    return NULL;\n+  }\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":12,"deletions":7,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -250,6 +250,2 @@\n-  static InstanceKlass* dump_time_resolve_super_or_fail(Symbol* class_name,\n-                                                Symbol* super_name,\n-                                                Handle class_loader,\n-                                                Handle protection_domain,\n-                                                bool is_superclass,\n-                                                TRAPS);\n+  static InstanceKlass* lookup_super_for_unregistered_class(Symbol* class_name,\n+                                                            Symbol* super_name,  bool is_superclass);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.hpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"}]}