{"files":[{"patch":"@@ -67,3 +67,0 @@\n-    \/\/ Memory allocation size for mapping buffers\n-    private static final long allocationGranularity;\n-\n@@ -74,3 +71,0 @@\n-    \/\/ Maximum direct transfer size\n-    private static final int MAX_DIRECT_TRANSFER_SIZE;\n-\n@@ -133,0 +127,1 @@\n+        this.path = path;\n@@ -135,2 +130,0 @@\n-        this.parent = parent;\n-        this.path = path;\n@@ -138,0 +131,1 @@\n+        this.parent = parent;\n@@ -154,2 +148,3 @@\n-    \/\/ Used by FileInputStream.getChannel(), FileOutputStream.getChannel\n-    \/\/ and RandomAccessFile.getChannel()\n+\n+    \/\/ Used by FileInputStream::getChannel, FileOutputStream::getChannel,\n+    \/\/ and RandomAccessFile::getChannel\n@@ -577,1 +572,1 @@\n-                    n = transferTo0(fd, position, icount, targetFD, append);\n+                    n = nd.transferTo(fd, position, icount, targetFD, append);\n@@ -773,1 +768,1 @@\n-        int icount = (int)Math.min(count, MAX_DIRECT_TRANSFER_SIZE);\n+        int icount = (int)Math.min(count, nd.maxDirectTransferSize());\n@@ -806,1 +801,1 @@\n-                    n = transferFrom0(srcFD, fd, position, count, append);\n+                    n = nd.transferFrom(srcFD, fd, position, count, append);\n@@ -1042,1 +1037,1 @@\n-        private static final NativeDispatcher nd = new FileDispatcherImpl();\n+        private static final FileDispatcher nd = new FileDispatcherImpl();\n@@ -1083,1 +1078,1 @@\n-            unmap0(address, size);\n+            nd.unmap(address, size);\n@@ -1302,1 +1297,1 @@\n-                pagePosition = (int)(position % allocationGranularity);\n+                pagePosition = (int)(position % nd.allocationGranularity());\n@@ -1306,2 +1301,2 @@\n-                    \/\/ If map0 did not throw an exception, the address is valid\n-                    addr = map0(fd, prot, mapPosition, mapSize, isSync);\n+                    \/\/ If map did not throw an exception, the address is valid\n+                    addr = nd.map(fd, prot, mapPosition, mapSize, isSync);\n@@ -1318,1 +1313,1 @@\n-                        addr = map0(fd, prot, mapPosition, mapSize, isSync);\n+                        addr = nd.map(fd, prot, mapPosition, mapSize, isSync);\n@@ -1332,1 +1327,1 @@\n-                unmap0(addr, mapSize);\n+                nd.unmap(addr, mapSize);\n@@ -1337,1 +1332,1 @@\n-            assert (addr % allocationGranularity == 0);\n+            assert (addr % nd.allocationGranularity() == 0);\n@@ -1339,2 +1334,2 @@\n-                           ? new SyncUnmapper(addr, mapSize, size, mfd, pagePosition)\n-                           : new DefaultUnmapper(addr, mapSize, size, mfd, pagePosition));\n+                ? new SyncUnmapper(addr, mapSize, size, mfd, pagePosition)\n+                : new DefaultUnmapper(addr, mapSize, size, mfd, pagePosition));\n@@ -1565,27 +1560,0 @@\n-    \/\/ -- Native methods --\n-\n-    \/\/ Creates a new mapping\n-    private native long map0(FileDescriptor fd, int prot, long position,\n-                             long length, boolean isSync)\n-        throws IOException;\n-\n-    \/\/ Removes an existing mapping\n-    private static native int unmap0(long address, long length);\n-\n-    \/\/ Transfers from src to dst, or returns IOStatus.UNSUPPORTED (-4) or\n-    \/\/ IOStatus.UNSUPPORTED_CASE (-6) if the kernel does not support it\n-    private static native long transferTo0(FileDescriptor src, long position,\n-                                           long count, FileDescriptor dst,\n-                                           boolean append);\n-\n-    private static native long transferFrom0(FileDescriptor src,\n-                                             FileDescriptor dst,\n-                                             long position, long count,\n-                                             boolean append);\n-\n-    \/\/ Retrieves the maximum size of a transfer\n-    private static native int maxDirectTransferSize0();\n-\n-    \/\/ Retrieves allocation granularity\n-    private static native long allocationGranularity0();\n-\n@@ -1594,2 +1562,0 @@\n-        allocationGranularity = allocationGranularity0();\n-        MAX_DIRECT_TRANSFER_SIZE = maxDirectTransferSize0();\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/FileChannelImpl.java","additions":18,"deletions":52,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,0 +72,16 @@\n+    abstract long allocationGranularity();\n+\n+    abstract long map(FileDescriptor fd, int prot, long position, long length,\n+                      boolean isSync)\n+        throws IOException;\n+\n+    abstract int unmap(long address, long length);\n+\n+    abstract int maxDirectTransferSize();\n+\n+    abstract long transferTo(FileDescriptor src, long position, long count,\n+                             FileDescriptor dst, boolean append);\n+\n+    abstract long transferFrom(FileDescriptor src, FileDescriptor dst,\n+                               long position, long count, boolean append);\n+\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/FileDispatcher.java","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,7 @@\n+    private static final long ALLOCATION_GRANULARITY;\n+    private static final int  MAX_DIRECT_TRANSFER_SIZE;\n+\n+    private static final int MAP_INVALID = -1;\n+    private static final int MAP_RO = 0;\n+    private static final int MAP_RW = 1;\n+    private static final int MAP_PV = 2;\n@@ -39,0 +46,2 @@\n+        ALLOCATION_GRANULARITY   = allocationGranularity0();\n+        MAX_DIRECT_TRANSFER_SIZE = maxDirectTransferSize0();\n@@ -133,0 +142,29 @@\n+    long allocationGranularity() {\n+        return ALLOCATION_GRANULARITY;\n+    }\n+\n+    long map(FileDescriptor fd, int prot, long position, long length,\n+             boolean isSync)\n+        throws IOException\n+    {\n+        return map0(fd, prot, position, length, isSync);\n+    }\n+\n+    int unmap(long address, long length) {\n+        return unmap0(address, length);\n+    }\n+\n+    int maxDirectTransferSize() {\n+        return MAX_DIRECT_TRANSFER_SIZE;\n+    }\n+\n+    long transferTo(FileDescriptor src, long position, long count,\n+                    FileDescriptor dst, boolean append) {\n+        return transferTo0(src, position, count, dst, append);\n+    }\n+\n+    long transferFrom(FileDescriptor src, FileDescriptor dst,\n+                      long position, long count, boolean append) {\n+        return transferFrom0(src, dst, position, count, append);\n+    }\n+\n@@ -193,0 +231,17 @@\n+    static native long allocationGranularity0();\n+\n+    static native long map0(FileDescriptor fd, int prot, long position,\n+                            long length, boolean isSync)\n+        throws IOException;\n+\n+    static native int unmap0(long address, long length);\n+\n+    static native int maxDirectTransferSize0();\n+\n+    static native long transferTo0(FileDescriptor src, long position,\n+                                   long count, FileDescriptor dst,\n+                                   boolean append);\n+\n+    static native long transferFrom0(FileDescriptor src, FileDescriptor dst,\n+                                     long position, long count, boolean append);\n+\n@@ -196,1 +251,0 @@\n-\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/ch\/FileDispatcherImpl.java","additions":56,"deletions":2,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -1,336 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <sys\/mman.h>\n-#include <sys\/stat.h>\n-#include <fcntl.h>\n-#include <sys\/types.h>\n-#include <unistd.h>\n-\n-#if defined(__linux__)\n-#include <sys\/sendfile.h>\n-#include <dlfcn.h>\n-#elif defined(_AIX)\n-#include <string.h>\n-#include <sys\/socket.h>\n-#elif defined(_ALLBSD_SOURCE)\n-#include <sys\/socket.h>\n-#include <sys\/uio.h>\n-#define lseek64 lseek\n-#define mmap64 mmap\n-#endif\n-\n-#include \"jni.h\"\n-#include \"jni_util.h\"\n-#include \"jlong.h\"\n-#include \"nio.h\"\n-#include \"nio_util.h\"\n-#include \"sun_nio_ch_FileChannelImpl.h\"\n-#include \"java_lang_Integer.h\"\n-#include <assert.h>\n-\n-#if defined(__linux__)\n-typedef ssize_t copy_file_range_func(int, loff_t*, int, loff_t*, size_t,\n-                                     unsigned int);\n-static copy_file_range_func* my_copy_file_range_func = NULL;\n-#endif\n-\n-JNIEXPORT jlong JNICALL\n-Java_sun_nio_ch_FileChannelImpl_allocationGranularity0(JNIEnv *env, jclass clazz)\n-{\n-    jlong pageSize = sysconf(_SC_PAGESIZE);\n-#if defined(__linux__)\n-    my_copy_file_range_func =\n-        (copy_file_range_func*) dlsym(RTLD_DEFAULT, \"copy_file_range\");\n-#endif\n-    return pageSize;\n-}\n-\n-static jlong\n-handle(JNIEnv *env, jlong rv, char *msg)\n-{\n-    if (rv >= 0)\n-        return rv;\n-    if (errno == EINTR)\n-        return IOS_INTERRUPTED;\n-    JNU_ThrowIOExceptionWithLastError(env, msg);\n-    return IOS_THROWN;\n-}\n-\n-\n-JNIEXPORT jlong JNICALL\n-Java_sun_nio_ch_FileChannelImpl_map0(JNIEnv *env, jobject this, jobject fdo,\n-                                     jint prot, jlong off, jlong len, jboolean map_sync)\n-{\n-    void *mapAddress = 0;\n-    jint fd = fdval(env, fdo);\n-    int protections = 0;\n-    int flags = 0;\n-\n-    \/\/ should never be called with map_sync and prot == PRIVATE\n-    assert((prot != sun_nio_ch_FileChannelImpl_MAP_PV) || !map_sync);\n-\n-    if (prot == sun_nio_ch_FileChannelImpl_MAP_RO) {\n-        protections = PROT_READ;\n-        flags = MAP_SHARED;\n-    } else if (prot == sun_nio_ch_FileChannelImpl_MAP_RW) {\n-        protections = PROT_WRITE | PROT_READ;\n-        flags = MAP_SHARED;\n-    } else if (prot == sun_nio_ch_FileChannelImpl_MAP_PV) {\n-        protections =  PROT_WRITE | PROT_READ;\n-        flags = MAP_PRIVATE;\n-    }\n-\n-    \/\/ if MAP_SYNC and MAP_SHARED_VALIDATE are not defined then it is\n-    \/\/ best to define them here. This ensures the code compiles on old\n-    \/\/ OS releases which do not provide the relevant headers. If run\n-    \/\/ on the same machine then it will work if the kernel contains\n-    \/\/ the necessary support otherwise mmap should fail with an\n-    \/\/ invalid argument error\n-\n-#ifndef MAP_SYNC\n-#define MAP_SYNC 0x80000\n-#endif\n-#ifndef MAP_SHARED_VALIDATE\n-#define MAP_SHARED_VALIDATE 0x03\n-#endif\n-\n-    if (map_sync) {\n-        \/\/ ensure\n-        \/\/  1) this is Linux on AArch64, x86_64, or PPC64 LE\n-        \/\/  2) the mmap APIs are available at compile time\n-#if !defined(LINUX) || ! (defined(aarch64) || (defined(amd64) && defined(_LP64)) || defined(ppc64le))\n-        \/\/ TODO - implement for solaris\/AIX\/BSD\/WINDOWS and for 32 bit\n-        JNU_ThrowInternalError(env, \"should never call map on platform where MAP_SYNC is unimplemented\");\n-        return IOS_THROWN;\n-#else\n-        flags |= MAP_SYNC | MAP_SHARED_VALIDATE;\n-#endif\n-    }\n-\n-    mapAddress = mmap64(\n-        0,                    \/* Let OS decide location *\/\n-        len,                  \/* Number of bytes to map *\/\n-        protections,          \/* File permissions *\/\n-        flags,                \/* Changes are shared *\/\n-        fd,                   \/* File descriptor of mapped file *\/\n-        off);                 \/* Offset into file *\/\n-\n-    if (mapAddress == MAP_FAILED) {\n-        if (map_sync && errno == ENOTSUP) {\n-            JNU_ThrowIOExceptionWithLastError(env, \"map with mode MAP_SYNC unsupported\");\n-            return IOS_THROWN;\n-        }\n-\n-        if (errno == ENOMEM) {\n-            JNU_ThrowOutOfMemoryError(env, \"Map failed\");\n-            return IOS_THROWN;\n-        }\n-        return handle(env, -1, \"Map failed\");\n-    }\n-\n-    return ((jlong) (unsigned long) mapAddress);\n-}\n-\n-\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_ch_FileChannelImpl_unmap0(JNIEnv *env, jobject this,\n-                                       jlong address, jlong len)\n-{\n-    void *a = (void *)jlong_to_ptr(address);\n-    return handle(env,\n-                  munmap(a, (size_t)len),\n-                  \"Unmap failed\");\n-}\n-\n-JNIEXPORT jlong JNICALL\n-Java_sun_nio_ch_FileChannelImpl_transferTo0(JNIEnv *env, jobject this,\n-                                            jobject srcFDO,\n-                                            jlong position, jlong count,\n-                                            jobject dstFDO, jboolean append)\n-{\n-    jint srcFD = fdval(env, srcFDO);\n-    jint dstFD = fdval(env, dstFDO);\n-\n-#if defined(__linux__)\n-    \/\/ copy_file_range fails with EBADF when appending, and sendfile\n-    \/\/ fails with EINVAL\n-    if (append == JNI_TRUE)\n-        return IOS_UNSUPPORTED_CASE;\n-\n-    off64_t offset = (off64_t)position;\n-    jlong n;\n-    if (my_copy_file_range_func != NULL) {\n-        size_t len = (size_t)count;\n-        n = my_copy_file_range_func(srcFD, &offset, dstFD, NULL, len, 0);\n-        if (n < 0) {\n-            switch (errno) {\n-                case EINTR:\n-                    return IOS_INTERRUPTED;\n-                case EINVAL:\n-                case ENOSYS:\n-                case EXDEV:\n-                    \/\/ ignore and try sendfile()\n-                    break;\n-                default:\n-                    JNU_ThrowIOExceptionWithLastError(env, \"Copy failed\");\n-                    return IOS_THROWN;\n-            }\n-        }\n-        if (n >= 0)\n-            return n;\n-    }\n-\n-    n = sendfile64(dstFD, srcFD, &offset, (size_t)count);\n-    if (n < 0) {\n-        if (errno == EAGAIN)\n-            return IOS_UNAVAILABLE;\n-        if ((errno == EINVAL) && ((ssize_t)count >= 0))\n-            return IOS_UNSUPPORTED_CASE;\n-        if (errno == EINTR) {\n-            return IOS_INTERRUPTED;\n-        }\n-        JNU_ThrowIOExceptionWithLastError(env, \"Transfer failed\");\n-        return IOS_THROWN;\n-    }\n-    return n;\n-#elif defined(__APPLE__)\n-    off_t numBytes;\n-    int result;\n-\n-    numBytes = count;\n-\n-    result = sendfile(srcFD, dstFD, position, &numBytes, NULL, 0);\n-\n-    if (numBytes > 0)\n-        return numBytes;\n-\n-    if (result == -1) {\n-        if (errno == EAGAIN)\n-            return IOS_UNAVAILABLE;\n-        if (errno == EOPNOTSUPP || errno == ENOTSOCK || errno == ENOTCONN)\n-            return IOS_UNSUPPORTED_CASE;\n-        if ((errno == EINVAL) && ((ssize_t)count >= 0))\n-            return IOS_UNSUPPORTED_CASE;\n-        if (errno == EINTR)\n-            return IOS_INTERRUPTED;\n-        JNU_ThrowIOExceptionWithLastError(env, \"Transfer failed\");\n-        return IOS_THROWN;\n-    }\n-\n-    return result;\n-\n-#elif defined(_AIX)\n-    jlong max = (jlong)java_lang_Integer_MAX_VALUE;\n-    struct sf_parms sf_iobuf;\n-    jlong result;\n-\n-    if (position > max)\n-        return IOS_UNSUPPORTED_CASE;\n-\n-    if (count > max)\n-        count = max;\n-\n-    memset(&sf_iobuf, 0, sizeof(sf_iobuf));\n-    sf_iobuf.file_descriptor = srcFD;\n-    sf_iobuf.file_offset = (off_t)position;\n-    sf_iobuf.file_bytes = count;\n-\n-    result = send_file(&dstFD, &sf_iobuf, SF_SYNC_CACHE);\n-\n-    \/* AIX send_file() will return 0 when this operation complete successfully,\n-     * return 1 when partial bytes transferred and return -1 when an error has\n-     * occurred.\n-     *\/\n-    if (result == -1) {\n-        if (errno == EWOULDBLOCK)\n-            return IOS_UNAVAILABLE;\n-        if ((errno == EINVAL) && ((ssize_t)count >= 0))\n-            return IOS_UNSUPPORTED_CASE;\n-        if (errno == EINTR)\n-            return IOS_INTERRUPTED;\n-        if (errno == ENOTSOCK)\n-            return IOS_UNSUPPORTED;\n-        JNU_ThrowIOExceptionWithLastError(env, \"Transfer failed\");\n-        return IOS_THROWN;\n-    }\n-\n-    if (sf_iobuf.bytes_sent > 0)\n-        return (jlong)sf_iobuf.bytes_sent;\n-\n-    return IOS_UNSUPPORTED_CASE;\n-#else\n-    return IOS_UNSUPPORTED;\n-#endif\n-}\n-\n-JNIEXPORT jlong JNICALL\n-Java_sun_nio_ch_FileChannelImpl_transferFrom0(JNIEnv *env, jobject this,\n-                                              jobject srcFDO, jobject dstFDO,\n-                                              jlong position, jlong count,\n-                                              jboolean append)\n-{\n-#if defined(__linux__)\n-    if (my_copy_file_range_func == NULL)\n-        return IOS_UNSUPPORTED;\n-    \/\/ copy_file_range fails with EBADF when appending\n-    if (append == JNI_TRUE)\n-        return IOS_UNSUPPORTED_CASE;\n-\n-    jint srcFD = fdval(env, srcFDO);\n-    jint dstFD = fdval(env, dstFDO);\n-\n-    off64_t offset = (off64_t)position;\n-    size_t len = (size_t)count;\n-    jlong n = my_copy_file_range_func(srcFD, NULL, dstFD, &offset, len, 0);\n-    if (n < 0) {\n-        if (errno == EAGAIN)\n-            return IOS_UNAVAILABLE;\n-        if (errno == ENOSYS)\n-            return IOS_UNSUPPORTED_CASE;\n-        if ((errno == EBADF || errno == EINVAL || errno == EXDEV) &&\n-            ((ssize_t)count >= 0))\n-            return IOS_UNSUPPORTED_CASE;\n-        if (errno == EINTR) {\n-            return IOS_INTERRUPTED;\n-        }\n-        JNU_ThrowIOExceptionWithLastError(env, \"Transfer failed\");\n-        return IOS_THROWN;\n-    }\n-    return n;\n-#else\n-    return IOS_UNSUPPORTED;\n-#endif\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_ch_FileChannelImpl_maxDirectTransferSize0(JNIEnv* env, jobject this)\n-{\n-#if defined(LINUX)\n-    return 0x7ffff000; \/\/ 2,147,479,552 maximum for sendfile()\n-#else\n-    return java_lang_Integer_MAX_VALUE;\n-#endif\n-}\n","filename":"src\/java.base\/unix\/native\/libnio\/ch\/FileChannelImpl.c","additions":0,"deletions":336,"binary":false,"changes":336,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+#include <sys\/mman.h>\n@@ -41,0 +42,2 @@\n+#include <sys\/sendfile.h>\n+#include <dlfcn.h>\n@@ -55,0 +58,5 @@\n+#define mmap64 mmap\n+#endif\n+\n+#if defined(_AIX)\n+#include <string.h>\n@@ -64,0 +72,1 @@\n+#include \"java_lang_Integer.h\"\n@@ -65,0 +74,7 @@\n+#include <assert.h>\n+\n+#if defined(__linux__)\n+typedef ssize_t copy_file_range_func(int, loff_t*, int, loff_t*, size_t,\n+                                     unsigned int);\n+static copy_file_range_func* my_copy_file_range_func = NULL;\n+#endif\n@@ -80,0 +96,4 @@\n+#if defined(__linux__)\n+    my_copy_file_range_func =\n+        (copy_file_range_func*) dlsym(RTLD_DEFAULT, \"copy_file_range\");\n+#endif\n@@ -351,0 +371,260 @@\n+JNIEXPORT jlong JNICALL\n+Java_sun_nio_ch_FileDispatcherImpl_allocationGranularity0(JNIEnv *env, jclass klass)\n+{\n+    jlong pageSize = sysconf(_SC_PAGESIZE);\n+    return pageSize;\n+}\n+\n+JNIEXPORT jlong JNICALL\n+Java_sun_nio_ch_FileDispatcherImpl_map0(JNIEnv *env, jclass klass, jobject fdo,\n+                                        jint prot, jlong off, jlong len,\n+                                        jboolean map_sync)\n+{\n+    void *mapAddress = 0;\n+    jint fd = fdval(env, fdo);\n+    int protections = 0;\n+    int flags = 0;\n+\n+    \/\/ should never be called with map_sync and prot == PRIVATE\n+    assert((prot != sun_nio_ch_FileDispatcherImpl_MAP_PV) || !map_sync);\n+\n+    if (prot == sun_nio_ch_FileDispatcherImpl_MAP_RO) {\n+        protections = PROT_READ;\n+        flags = MAP_SHARED;\n+    } else if (prot == sun_nio_ch_FileDispatcherImpl_MAP_RW) {\n+        protections = PROT_WRITE | PROT_READ;\n+        flags = MAP_SHARED;\n+    } else if (prot == sun_nio_ch_FileDispatcherImpl_MAP_PV) {\n+        protections =  PROT_WRITE | PROT_READ;\n+        flags = MAP_PRIVATE;\n+    }\n+\n+    \/\/ if MAP_SYNC and MAP_SHARED_VALIDATE are not defined then it is\n+    \/\/ best to define them here. This ensures the code compiles on old\n+    \/\/ OS releases which do not provide the relevant headers. If run\n+    \/\/ on the same machine then it will work if the kernel contains\n+    \/\/ the necessary support otherwise mmap should fail with an\n+    \/\/ invalid argument error\n+\n+#ifndef MAP_SYNC\n+#define MAP_SYNC 0x80000\n+#endif\n+#ifndef MAP_SHARED_VALIDATE\n+#define MAP_SHARED_VALIDATE 0x03\n+#endif\n+\n+    if (map_sync) {\n+        \/\/ ensure\n+        \/\/  1) this is Linux on AArch64, x86_64, or PPC64 LE\n+        \/\/  2) the mmap APIs are available at compile time\n+#if !defined(LINUX) || ! (defined(aarch64) || (defined(amd64) && defined(_LP64)) || defined(ppc64le))\n+        \/\/ TODO - implement for solaris\/AIX\/BSD\/WINDOWS and for 32 bit\n+        JNU_ThrowInternalError(env, \"should never call map on platform where MAP_SYNC is unimplemented\");\n+        return IOS_THROWN;\n+#else\n+        flags |= MAP_SYNC | MAP_SHARED_VALIDATE;\n+#endif\n+    }\n+\n+    mapAddress = mmap64(\n+        0,                    \/* Let OS decide location *\/\n+        len,                  \/* Number of bytes to map *\/\n+        protections,          \/* File permissions *\/\n+        flags,                \/* Changes are shared *\/\n+        fd,                   \/* File descriptor of mapped file *\/\n+        off);                 \/* Offset into file *\/\n+\n+    if (mapAddress == MAP_FAILED) {\n+        if (map_sync && errno == ENOTSUP) {\n+            JNU_ThrowIOExceptionWithLastError(env, \"map with mode MAP_SYNC unsupported\");\n+            return IOS_THROWN;\n+        }\n+\n+        if (errno == ENOMEM) {\n+            JNU_ThrowOutOfMemoryError(env, \"Map failed\");\n+            return IOS_THROWN;\n+        }\n+        return handle(env, -1, \"Map failed\");\n+    }\n+\n+    return ((jlong) (unsigned long) mapAddress);\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_ch_FileDispatcherImpl_unmap0(JNIEnv *env, jclass klass,\n+                                          jlong address, jlong len)\n+{\n+    void *a = (void *)jlong_to_ptr(address);\n+    return handle(env,\n+                  munmap(a, (size_t)len),\n+                  \"Unmap failed\");\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_ch_FileDispatcherImpl_maxDirectTransferSize0(JNIEnv* env, jclass klass) {\n+#if defined(__linux__)\n+    return 0x7ffff000; \/\/ 2,147,479,552 maximum for sendfile()\n+#else\n+    return java_lang_Integer_MAX_VALUE;\n+#endif\n+}\n+\n+JNIEXPORT jlong JNICALL\n+Java_sun_nio_ch_FileDispatcherImpl_transferTo0(JNIEnv *env, jobject this,\n+                                               jobject srcFDO,\n+                                               jlong position, jlong count,\n+                                               jobject dstFDO, jboolean append)\n+{\n+    jint srcFD = fdval(env, srcFDO);\n+    jint dstFD = fdval(env, dstFDO);\n+\n+#if defined(__linux__)\n+    \/\/ copy_file_range fails with EBADF when appending, and sendfile\n+    \/\/ fails with EINVAL\n+    if (append == JNI_TRUE)\n+        return IOS_UNSUPPORTED_CASE;\n+\n+    off64_t offset = (off64_t)position;\n+    jlong n;\n+    if (my_copy_file_range_func != NULL) {\n+        size_t len = (size_t)count;\n+        n = my_copy_file_range_func(srcFD, &offset, dstFD, NULL, len, 0);\n+        if (n < 0) {\n+            switch (errno) {\n+                case EINTR:\n+                    return IOS_INTERRUPTED;\n+                case EINVAL:\n+                case ENOSYS:\n+                case EXDEV:\n+                    \/\/ ignore and try sendfile()\n+                    break;\n+                default:\n+                    JNU_ThrowIOExceptionWithLastError(env, \"Copy failed\");\n+                    return IOS_THROWN;\n+            }\n+        }\n+        if (n >= 0)\n+            return n;\n+    }\n+\n+    n = sendfile64(dstFD, srcFD, &offset, (size_t)count);\n+    if (n < 0) {\n+        if (errno == EAGAIN)\n+            return IOS_UNAVAILABLE;\n+        if ((errno == EINVAL) && ((ssize_t)count >= 0))\n+            return IOS_UNSUPPORTED_CASE;\n+        if (errno == EINTR) {\n+            return IOS_INTERRUPTED;\n+        }\n+        JNU_ThrowIOExceptionWithLastError(env, \"Transfer failed\");\n+        return IOS_THROWN;\n+    }\n+    return n;\n+#elif defined(_ALLBSD_SOURCE)\n+    off_t numBytes;\n+    int result;\n+\n+    numBytes = count;\n+\n+    result = sendfile(srcFD, dstFD, position, &numBytes, NULL, 0);\n+\n+    if (numBytes > 0)\n+        return numBytes;\n+\n+    if (result == -1) {\n+        if (errno == EAGAIN)\n+            return IOS_UNAVAILABLE;\n+        if (errno == EOPNOTSUPP || errno == ENOTSOCK || errno == ENOTCONN)\n+            return IOS_UNSUPPORTED_CASE;\n+        if ((errno == EINVAL) && ((ssize_t)count >= 0))\n+            return IOS_UNSUPPORTED_CASE;\n+        if (errno == EINTR)\n+            return IOS_INTERRUPTED;\n+        JNU_ThrowIOExceptionWithLastError(env, \"Transfer failed\");\n+        return IOS_THROWN;\n+    }\n+\n+    return result;\n+#elif defined(_AIX)\n+    jlong max = (jlong)java_lang_Integer_MAX_VALUE;\n+    struct sf_parms sf_iobuf;\n+    jlong result;\n+\n+    if (position > max)\n+        return IOS_UNSUPPORTED_CASE;\n+\n+    if (count > max)\n+        count = max;\n+\n+    memset(&sf_iobuf, 0, sizeof(sf_iobuf));\n+    sf_iobuf.file_descriptor = srcFD;\n+    sf_iobuf.file_offset = (off_t)position;\n+    sf_iobuf.file_bytes = count;\n+\n+    result = send_file(&dstFD, &sf_iobuf, SF_SYNC_CACHE);\n+\n+    \/* AIX send_file() will return 0 when this operation complete successfully,\n+     * return 1 when partial bytes transferred and return -1 when an error has\n+     * occurred.\n+     *\/\n+    if (result == -1) {\n+        if (errno == EWOULDBLOCK)\n+            return IOS_UNAVAILABLE;\n+        if ((errno == EINVAL) && ((ssize_t)count >= 0))\n+            return IOS_UNSUPPORTED_CASE;\n+        if (errno == EINTR)\n+            return IOS_INTERRUPTED;\n+        if (errno == ENOTSOCK)\n+            return IOS_UNSUPPORTED;\n+        JNU_ThrowIOExceptionWithLastError(env, \"Transfer failed\");\n+        return IOS_THROWN;\n+    }\n+\n+    if (sf_iobuf.bytes_sent > 0)\n+        return (jlong)sf_iobuf.bytes_sent;\n+\n+    return IOS_UNSUPPORTED_CASE;\n+#else\n+    return IOS_UNSUPPORTED;\n+#endif\n+}\n+\n+JNIEXPORT jlong JNICALL\n+Java_sun_nio_ch_FileDispatcherImpl_transferFrom0(JNIEnv *env, jobject this,\n+                                                 jobject srcFDO, jobject dstFDO,\n+                                                 jlong position, jlong count,\n+                                                 jboolean append)\n+{\n+#if defined(__linux__)\n+    if (my_copy_file_range_func == NULL)\n+        return IOS_UNSUPPORTED;\n+    \/\/ copy_file_range fails with EBADF when appending\n+    if (append == JNI_TRUE)\n+        return IOS_UNSUPPORTED_CASE;\n+\n+    jint srcFD = fdval(env, srcFDO);\n+    jint dstFD = fdval(env, dstFDO);\n+\n+    off64_t offset = (off64_t)position;\n+    size_t len = (size_t)count;\n+    jlong n = my_copy_file_range_func(srcFD, NULL, dstFD, &offset, len, 0);\n+    if (n < 0) {\n+        if (errno == EAGAIN)\n+            return IOS_UNAVAILABLE;\n+        if (errno == ENOSYS)\n+            return IOS_UNSUPPORTED_CASE;\n+        if ((errno == EBADF || errno == EINVAL || errno == EXDEV) &&\n+            ((ssize_t)count >= 0))\n+            return IOS_UNSUPPORTED_CASE;\n+        if (errno == EINTR) {\n+            return IOS_INTERRUPTED;\n+        }\n+        JNU_ThrowIOExceptionWithLastError(env, \"Transfer failed\");\n+        return IOS_THROWN;\n+    }\n+    return n;\n+#else\n+    return IOS_UNSUPPORTED;\n+#endif\n+}\n+\n@@ -353,1 +633,1 @@\n-                                           jobject fdo)\n+                                              jobject fdo)\n","filename":"src\/java.base\/unix\/native\/libnio\/ch\/FileDispatcherImpl.c","additions":282,"deletions":2,"binary":false,"changes":284,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.io.File;\n@@ -30,1 +31,1 @@\n-import jdk.internal.access.SharedSecrets;\n+import java.nio.CharBuffer;\n@@ -32,0 +33,1 @@\n+import jdk.internal.access.SharedSecrets;\n@@ -33,2 +35,0 @@\n-import java.io.File;\n-import java.nio.CharBuffer;\n@@ -37,0 +37,12 @@\n+    private static final long ALLOCATION_GRANULARITY;\n+    private static final int  MAX_DIRECT_TRANSFER_SIZE;\n+\n+    private static final int MAP_INVALID = -1;\n+    private static final int MAP_RO = 0;\n+    private static final int MAP_RW = 1;\n+    private static final int MAP_PV = 2;\n+\n+    static {\n+        ALLOCATION_GRANULARITY   = allocationGranularity0();\n+        MAX_DIRECT_TRANSFER_SIZE = maxDirectTransferSize0();\n+    }\n@@ -132,0 +144,30 @@\n+\n+    long allocationGranularity() {\n+        return ALLOCATION_GRANULARITY;\n+    }\n+\n+    long map(FileDescriptor fd, int prot, long position, long length,\n+             boolean isSync)\n+        throws IOException\n+    {\n+        return map0(fd, prot, position, length, isSync);\n+    }\n+\n+    int unmap(long address, long length) {\n+        return unmap0(address, length);\n+    }\n+\n+    int maxDirectTransferSize() {\n+        return MAX_DIRECT_TRANSFER_SIZE;\n+    }\n+\n+    long transferTo(FileDescriptor src, long position, long count,\n+                    FileDescriptor dst, boolean append) {\n+        return transferTo0(src, position, count, dst, append);\n+    }\n+\n+    long transferFrom(FileDescriptor src, FileDescriptor dst,\n+                      long position, long count, boolean append) {\n+        return IOStatus.UNSUPPORTED;\n+    }\n+\n@@ -197,0 +239,14 @@\n+    static native long allocationGranularity0();\n+\n+    static native long map0(FileDescriptor fd, int prot, long position,\n+                            long length, boolean isSync)\n+        throws IOException;\n+\n+    static native int unmap0(long address, long length);\n+\n+    static native int maxDirectTransferSize0();\n+\n+    static native long transferTo0(FileDescriptor src, long position,\n+                                   long count, FileDescriptor dst,\n+                                   boolean append);\n+\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/ch\/FileDispatcherImpl.java","additions":60,"deletions":4,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -1,204 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"jni.h\"\n-#include \"jni_util.h\"\n-#include \"jvm.h\"\n-#include \"jlong.h\"\n-#include <io.h>\n-#include \"nio.h\"\n-#include \"nio_util.h\"\n-#include \"sun_nio_ch_FileChannelImpl.h\"\n-#include \"java_lang_Integer.h\"\n-\n-#include <Mswsock.h>\n-#pragma comment(lib, \"Mswsock.lib\")\n-\n-\/**************************************************************\n- * static method to retrieve the allocation granularity\n- *\/\n-JNIEXPORT jlong JNICALL\n-Java_sun_nio_ch_FileChannelImpl_allocationGranularity0(JNIEnv *env, jclass clazz)\n-{\n-    SYSTEM_INFO si;\n-    jint align;\n-    GetSystemInfo(&si);\n-    align = si.dwAllocationGranularity;\n-    return align;\n-}\n-\n-\n-\/**************************************************************\n- * Channel\n- *\/\n-\n-JNIEXPORT jlong JNICALL\n-Java_sun_nio_ch_FileChannelImpl_map0(JNIEnv *env, jobject this, jobject fdo,\n-                                     jint prot, jlong off, jlong len, jboolean map_sync)\n-{\n-    void *mapAddress = 0;\n-    jint lowOffset = (jint)off;\n-    jint highOffset = (jint)(off >> 32);\n-    jlong maxSize = off + len;\n-    jint lowLen = (jint)(maxSize);\n-    jint highLen = (jint)(maxSize >> 32);\n-    HANDLE fileHandle = (HANDLE)(handleval(env, fdo));\n-    HANDLE mapping;\n-    DWORD mapAccess = FILE_MAP_READ;\n-    DWORD fileProtect = PAGE_READONLY;\n-    DWORD mapError;\n-    BOOL result;\n-\n-    if (prot == sun_nio_ch_FileChannelImpl_MAP_RO) {\n-        fileProtect = PAGE_READONLY;\n-        mapAccess = FILE_MAP_READ;\n-    } else if (prot == sun_nio_ch_FileChannelImpl_MAP_RW) {\n-        fileProtect = PAGE_READWRITE;\n-        mapAccess = FILE_MAP_WRITE;\n-    } else if (prot == sun_nio_ch_FileChannelImpl_MAP_PV) {\n-        fileProtect = PAGE_WRITECOPY;\n-        mapAccess = FILE_MAP_COPY;\n-    }\n-\n-    if (map_sync) {\n-        JNU_ThrowInternalError(env, \"should never call map on platform where MAP_SYNC is unimplemented\");\n-        return IOS_THROWN;\n-    }\n-\n-    mapping = CreateFileMapping(\n-        fileHandle,      \/* Handle of file *\/\n-        NULL,            \/* Not inheritable *\/\n-        fileProtect,     \/* Read and write *\/\n-        highLen,         \/* High word of max size *\/\n-        lowLen,          \/* Low word of max size *\/\n-        NULL);           \/* No name for object *\/\n-\n-    if (mapping == NULL) {\n-        JNU_ThrowIOExceptionWithLastError(env, \"Map failed\");\n-        return IOS_THROWN;\n-    }\n-\n-    mapAddress = MapViewOfFile(\n-        mapping,             \/* Handle of file mapping object *\/\n-        mapAccess,           \/* Read and write access *\/\n-        highOffset,          \/* High word of offset *\/\n-        lowOffset,           \/* Low word of offset *\/\n-        (SIZE_T)len);        \/* Number of bytes to map *\/\n-    mapError = GetLastError();\n-\n-    result = CloseHandle(mapping);\n-    if (result == 0) {\n-        JNU_ThrowIOExceptionWithLastError(env, \"Map failed\");\n-        return IOS_THROWN;\n-    }\n-\n-    if (mapAddress == NULL) {\n-        if (mapError == ERROR_NOT_ENOUGH_MEMORY)\n-            JNU_ThrowOutOfMemoryError(env, \"Map failed\");\n-        else\n-            JNU_ThrowIOExceptionWithLastError(env, \"Map failed\");\n-        return IOS_THROWN;\n-    }\n-\n-    return ptr_to_jlong(mapAddress);\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_ch_FileChannelImpl_unmap0(JNIEnv *env, jobject this,\n-                                 jlong address, jlong len)\n-{\n-    BOOL result;\n-    void *a = (void *) jlong_to_ptr(address);\n-\n-    result = UnmapViewOfFile(a);\n-    if (result == 0) {\n-        JNU_ThrowIOExceptionWithLastError(env, \"Unmap failed\");\n-        return IOS_THROWN;\n-    }\n-    return 0;\n-}\n-\n-\/\/ Integer.MAX_VALUE - 1 is the maximum transfer size for TransmitFile()\n-#define MAX_TRANSMIT_SIZE (java_lang_Integer_MAX_VALUE - 1)\n-\n-JNIEXPORT jlong JNICALL\n-Java_sun_nio_ch_FileChannelImpl_transferTo0(JNIEnv *env, jobject this,\n-                                            jobject srcFD,\n-                                            jlong position, jlong count,\n-                                            jobject dstFD, jboolean append)\n-{\n-    const int PACKET_SIZE = 524288;\n-\n-    LARGE_INTEGER where;\n-    HANDLE src = (HANDLE)(handleval(env, srcFD));\n-    SOCKET dst = (SOCKET)(fdval(env, dstFD));\n-    DWORD chunkSize = (count > MAX_TRANSMIT_SIZE) ?\n-        MAX_TRANSMIT_SIZE : (DWORD)count;\n-    BOOL result;\n-\n-    where.QuadPart = position;\n-    result = SetFilePointerEx(src, where, &where, FILE_BEGIN);\n-    if (result == 0) {\n-        JNU_ThrowIOExceptionWithLastError(env, \"SetFilePointerEx failed\");\n-        return IOS_THROWN;\n-    }\n-\n-    result = TransmitFile(\n-        dst,\n-        src,\n-        chunkSize,\n-        PACKET_SIZE,\n-        NULL,\n-        NULL,\n-        TF_USE_KERNEL_APC\n-    );\n-    if (!result) {\n-        int error = WSAGetLastError();\n-        if (WSAEINVAL == error && count >= 0) {\n-            return IOS_UNSUPPORTED_CASE;\n-        }\n-        if (WSAENOTSOCK == error) {\n-            return IOS_UNSUPPORTED_CASE;\n-        }\n-        JNU_ThrowIOExceptionWithLastError(env, \"transfer failed\");\n-        return IOS_THROWN;\n-    }\n-    return chunkSize;\n-}\n-\n-JNIEXPORT jlong JNICALL\n-Java_sun_nio_ch_FileChannelImpl_transferFrom0(JNIEnv *env, jobject this,\n-                                              jobject srcFDO, jobject dstFDO,\n-                                              jlong position, jlong count,\n-                                              jboolean append)\n-{\n-    return IOS_UNSUPPORTED;\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_ch_FileChannelImpl_maxDirectTransferSize0(JNIEnv* env, jobject this)\n-{\n-    return MAX_TRANSMIT_SIZE;\n-}\n","filename":"src\/java.base\/windows\/native\/libnio\/ch\/FileChannelImpl.c","additions":0,"deletions":204,"binary":false,"changes":204,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-#include \"sun_nio_ch_FileDispatcherImpl.h\"\n@@ -35,1 +34,2 @@\n-#include \"jlong.h\"\n+#include \"java_lang_Integer.h\"\n+#include \"sun_nio_ch_FileDispatcherImpl.h\"\n@@ -37,0 +37,2 @@\n+#include <Mswsock.h>\n+#pragma comment(lib, \"Mswsock.lib\")\n@@ -485,0 +487,159 @@\n+\/**************************************************************\n+ * static method to retrieve the allocation granularity\n+ *\/\n+JNIEXPORT jlong JNICALL\n+Java_sun_nio_ch_FileDispatcherImpl_allocationGranularity0(JNIEnv *env, jclass klass)\n+{\n+    SYSTEM_INFO si;\n+    jint align;\n+    GetSystemInfo(&si);\n+    align = si.dwAllocationGranularity;\n+    return align;\n+}\n+\n+\n+\/**************************************************************\n+ * Channel\n+ *\/\n+\n+JNIEXPORT jlong JNICALL\n+Java_sun_nio_ch_FileDispatcherImpl_map0(JNIEnv *env, jclass klass, jobject fdo,\n+                                        jint prot, jlong off, jlong len,\n+                                        jboolean map_sync)\n+{\n+    void *mapAddress = 0;\n+    jint lowOffset = (jint)off;\n+    jint highOffset = (jint)(off >> 32);\n+    jlong maxSize = off + len;\n+    jint lowLen = (jint)(maxSize);\n+    jint highLen = (jint)(maxSize >> 32);\n+    HANDLE fileHandle = (HANDLE)(handleval(env, fdo));\n+    HANDLE mapping;\n+    DWORD mapAccess = FILE_MAP_READ;\n+    DWORD fileProtect = PAGE_READONLY;\n+    DWORD mapError;\n+    BOOL result;\n+\n+    if (prot == sun_nio_ch_FileDispatcherImpl_MAP_RO) {\n+        fileProtect = PAGE_READONLY;\n+        mapAccess = FILE_MAP_READ;\n+    } else if (prot == sun_nio_ch_FileDispatcherImpl_MAP_RW) {\n+        fileProtect = PAGE_READWRITE;\n+        mapAccess = FILE_MAP_WRITE;\n+    } else if (prot == sun_nio_ch_FileDispatcherImpl_MAP_PV) {\n+        fileProtect = PAGE_WRITECOPY;\n+        mapAccess = FILE_MAP_COPY;\n+    }\n+\n+    if (map_sync) {\n+        JNU_ThrowInternalError(env, \"should never call map on platform where MAP_SYNC is unimplemented\");\n+        return IOS_THROWN;\n+    }\n+\n+    mapping = CreateFileMapping(\n+        fileHandle,      \/* Handle of file *\/\n+        NULL,            \/* Not inheritable *\/\n+        fileProtect,     \/* Read and write *\/\n+        highLen,         \/* High word of max size *\/\n+        lowLen,          \/* Low word of max size *\/\n+        NULL);           \/* No name for object *\/\n+\n+    if (mapping == NULL) {\n+        JNU_ThrowIOExceptionWithLastError(env, \"Map failed\");\n+        return IOS_THROWN;\n+    }\n+\n+    mapAddress = MapViewOfFile(\n+        mapping,             \/* Handle of file mapping object *\/\n+        mapAccess,           \/* Read and write access *\/\n+        highOffset,          \/* High word of offset *\/\n+        lowOffset,           \/* Low word of offset *\/\n+        (SIZE_T)len);        \/* Number of bytes to map *\/\n+    mapError = GetLastError();\n+\n+    result = CloseHandle(mapping);\n+    if (result == 0) {\n+        JNU_ThrowIOExceptionWithLastError(env, \"Map failed\");\n+        return IOS_THROWN;\n+    }\n+\n+    if (mapAddress == NULL) {\n+        if (mapError == ERROR_NOT_ENOUGH_MEMORY)\n+            JNU_ThrowOutOfMemoryError(env, \"Map failed\");\n+        else\n+            JNU_ThrowIOExceptionWithLastError(env, \"Map failed\");\n+        return IOS_THROWN;\n+    }\n+\n+    return ptr_to_jlong(mapAddress);\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_ch_FileDispatcherImpl_unmap0(JNIEnv *env, jclass klass,\n+                                          jlong address, jlong len)\n+{\n+    BOOL result;\n+    void *a = (void *) jlong_to_ptr(address);\n+\n+    result = UnmapViewOfFile(a);\n+    if (result == 0) {\n+        JNU_ThrowIOExceptionWithLastError(env, \"Unmap failed\");\n+        return IOS_THROWN;\n+    }\n+    return 0;\n+}\n+\n+\/\/ Integer.MAX_VALUE - 1 is the maximum transfer size for TransmitFile()\n+#define MAX_TRANSMIT_SIZE (java_lang_Integer_MAX_VALUE - 1)\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_ch_FileDispatcherImpl_maxDirectTransferSize0(JNIEnv* env, jclass klass)\n+{\n+    return MAX_TRANSMIT_SIZE;\n+}\n+\n+JNIEXPORT jlong JNICALL\n+Java_sun_nio_ch_FileDispatcherImpl_transferTo0(JNIEnv *env, jclass klass,\n+                                               jobject srcFD,\n+                                            jlong position, jlong count,\n+                                            jobject dstFD, jboolean append)\n+{\n+    const int PACKET_SIZE = 524288;\n+\n+    LARGE_INTEGER where;\n+    HANDLE src = (HANDLE)(handleval(env, srcFD));\n+    SOCKET dst = (SOCKET)(fdval(env, dstFD));\n+    DWORD chunkSize = (count > MAX_TRANSMIT_SIZE) ?\n+        MAX_TRANSMIT_SIZE : (DWORD)count;\n+    BOOL result;\n+\n+    where.QuadPart = position;\n+    result = SetFilePointerEx(src, where, &where, FILE_BEGIN);\n+    if (result == 0) {\n+        JNU_ThrowIOExceptionWithLastError(env, \"SetFilePointerEx failed\");\n+        return IOS_THROWN;\n+    }\n+\n+    result = TransmitFile(\n+        dst,\n+        src,\n+        chunkSize,\n+        PACKET_SIZE,\n+        NULL,\n+        NULL,\n+        TF_USE_KERNEL_APC\n+    );\n+    if (!result) {\n+        int error = WSAGetLastError();\n+        if (WSAEINVAL == error && count >= 0) {\n+            return IOS_UNSUPPORTED_CASE;\n+        }\n+        if (WSAENOTSOCK == error) {\n+            return IOS_UNSUPPORTED_CASE;\n+        }\n+        JNU_ThrowIOExceptionWithLastError(env, \"transfer failed\");\n+        return IOS_THROWN;\n+    }\n+    return chunkSize;\n+}\n+\n","filename":"src\/java.base\/windows\/native\/libnio\/ch\/FileDispatcherImpl.c","additions":164,"deletions":3,"binary":false,"changes":167,"status":"modified"}]}