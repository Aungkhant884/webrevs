{"files":[{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.nio.ch;\n+\n+import java.io.FileDescriptor;\n+import java.io.IOException;\n+\n+public class FileDispatcherImpl extends UnixFileDispatcherImpl {\n+    FileDispatcherImpl() {\n+        super();\n+    }\n+\n+    int force(FileDescriptor fd, boolean metaData) throws IOException {\n+        return force0(fd, metaData);\n+    }\n+\n+    protected long transferTo(FileDescriptor src, long position,\n+                              long count, FileDescriptor dst,\n+                              boolean append)\n+    {\n+        return transferTo0(src, position, count, dst, append);\n+    }\n+\n+    \/\/ --- native methods ---\n+\n+    static native int force0(FileDescriptor fd, boolean metaData)\n+        throws IOException;\n+\n+    private static native long transferTo0(FileDescriptor src, long position,\n+                                           long count, FileDescriptor dst,\n+                                           boolean append);\n+}\n","filename":"src\/java.base\/aix\/classes\/sun\/nio\/ch\/FileDispatcherImpl.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,129 @@\n+\/*\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <sys\/mman.h>\n+#include <sys\/stat.h>\n+#include <fcntl.h>\n+#include <sys\/types.h>\n+#include <unistd.h>\n+\n+#include <string.h>\n+#include <sys\/socket.h>\n+\n+#include \"jni.h\"\n+#include \"jni_util.h\"\n+#include \"jlong.h\"\n+#include \"nio.h\"\n+#include \"nio_util.h\"\n+#include \"java_lang_Integer.h\"\n+#include <assert.h>\n+\n+static jlong\n+handle(JNIEnv *env, jlong rv, char *msg)\n+{\n+    if (rv >= 0)\n+        return rv;\n+    if (errno == EINTR)\n+        return IOS_INTERRUPTED;\n+    JNU_ThrowIOExceptionWithLastError(env, msg);\n+    return IOS_THROWN;\n+}\n+\n+\/\/ AIX\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_ch_FileDispatcherImpl_force0(JNIEnv *env, jobject this,\n+                                          jobject fdo, jboolean md)\n+{\n+    jint fd = fdval(env, fdo);\n+    int result = 0;\n+\n+    if (md == JNI_FALSE) {\n+        result = fdatasync(fd);\n+    } else {\n+        \/* Calling fsync on a file descriptor that is opened only for\n+         * reading results in an error (\"EBADF: The FileDescriptor parameter is\n+         * not a valid file descriptor open for writing.\").\n+         * However, at this point it is not possibly anymore to read the\n+         * 'writable' attribute of the corresponding file channel so we have to\n+         * use 'fcntl'.\n+         *\/\n+        int getfl = fcntl(fd, F_GETFL);\n+        if (getfl >= 0 && (getfl & O_ACCMODE) == O_RDONLY) {\n+            return 0;\n+        }\n+        result = fsync(fd);\n+    }\n+\n+    return handle(env, result, \"Force failed\");\n+}\n+\n+JNIEXPORT jlong JNICALL\n+Java_sun_nio_ch_FileDispatcherImpl_transferTo0(JNIEnv *env, jobject this,\n+                                                    jobject srcFDO,\n+                                                    jlong position, jlong count,\n+                                                    jobject dstFDO, jboolean append)\n+{\n+    jint srcFD = fdval(env, srcFDO);\n+    jint dstFD = fdval(env, dstFDO);\n+\n+    jlong max = (jlong)java_lang_Integer_MAX_VALUE;\n+    struct sf_parms sf_iobuf;\n+    jlong result;\n+\n+    if (position > max)\n+        return IOS_UNSUPPORTED_CASE;\n+\n+    if (count > max)\n+        count = max;\n+\n+    memset(&sf_iobuf, 0, sizeof(sf_iobuf));\n+    sf_iobuf.file_descriptor = srcFD;\n+    sf_iobuf.file_offset = (off_t)position;\n+    sf_iobuf.file_bytes = count;\n+\n+    result = send_file(&dstFD, &sf_iobuf, SF_SYNC_CACHE);\n+\n+    \/* AIX send_file() will return 0 when this operation complete successfully,\n+     * return 1 when partial bytes transferred and return -1 when an error has\n+     * occurred.\n+     *\/\n+    if (result == -1) {\n+        if (errno == EWOULDBLOCK)\n+            return IOS_UNAVAILABLE;\n+        if ((errno == EINVAL) && ((ssize_t)count >= 0))\n+            return IOS_UNSUPPORTED_CASE;\n+        if (errno == EINTR)\n+            return IOS_INTERRUPTED;\n+        if (errno == ENOTSOCK)\n+            return IOS_UNSUPPORTED;\n+        JNU_ThrowIOExceptionWithLastError(env, \"Transfer failed\");\n+        return IOS_THROWN;\n+    }\n+\n+    if (sf_iobuf.bytes_sent > 0)\n+        return (jlong)sf_iobuf.bytes_sent;\n+\n+    return IOS_UNSUPPORTED_CASE;\n+}\n","filename":"src\/java.base\/aix\/native\/libnio\/ch\/FileDispatcherImpl.c","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.nio.ch;\n+\n+import java.io.FileDescriptor;\n+\n+class FileDispatcherImpl extends UnixFileDispatcherImpl {\n+    FileDispatcherImpl() {\n+        super();\n+    }\n+\n+    int maxDirectTransferSize() {\n+        return 0x7ffff000; \/\/ 2,147,479,552 maximum for sendfile()\n+    }\n+\n+    long transferTo(FileDescriptor src, long position, long count,\n+                    FileDescriptor dst, boolean append) {\n+        return transferTo0(src, position, count, dst, append);\n+    }\n+\n+    long transferFrom(FileDescriptor src, FileDescriptor dst,\n+                      long position, long count, boolean append) {\n+        return transferFrom0(src, dst, position, count, append);\n+    }\n+\n+    \/\/ -- Native methods --\n+\n+    static native long transferTo0(FileDescriptor src, long position,\n+                                   long count, FileDescriptor dst,\n+                                   boolean append);\n+\n+    static native long transferFrom0(FileDescriptor src, FileDescriptor dst,\n+                                     long position, long count, boolean append);\n+\n+    static native void init0();\n+\n+    static {\n+        init0();\n+    }\n+}\n","filename":"src\/java.base\/linux\/classes\/sun\/nio\/ch\/FileDispatcherImpl.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,132 @@\n+\/*\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <unistd.h>\n+\n+#include <sys\/sendfile.h>\n+#include <dlfcn.h>\n+\n+#include \"jni.h\"\n+#include \"jni_util.h\"\n+#include \"nio.h\"\n+#include \"nio_util.h\"\n+\n+typedef ssize_t copy_file_range_func(int, loff_t*, int, loff_t*, size_t,\n+                                     unsigned int);\n+static copy_file_range_func* my_copy_file_range_func = NULL;\n+\n+JNIEXPORT void JNICALL\n+Java_sun_nio_ch_FileDispatcherImpl_init0(JNIEnv *env, jclass klass)\n+{\n+    my_copy_file_range_func =\n+        (copy_file_range_func*) dlsym(RTLD_DEFAULT, \"copy_file_range\");\n+}\n+\n+JNIEXPORT jlong JNICALL\n+Java_sun_nio_ch_FileDispatcherImpl_transferFrom0(JNIEnv *env, jobject this,\n+                                              jobject srcFDO, jobject dstFDO,\n+                                              jlong position, jlong count,\n+                                              jboolean append)\n+{\n+    if (my_copy_file_range_func == NULL)\n+        return IOS_UNSUPPORTED;\n+    \/\/ copy_file_range fails with EBADF when appending\n+    if (append == JNI_TRUE)\n+        return IOS_UNSUPPORTED_CASE;\n+\n+    jint srcFD = fdval(env, srcFDO);\n+    jint dstFD = fdval(env, dstFDO);\n+\n+    off64_t offset = (off64_t)position;\n+    size_t len = (size_t)count;\n+    jlong n = my_copy_file_range_func(srcFD, NULL, dstFD, &offset, len, 0);\n+    if (n < 0) {\n+        if (errno == EAGAIN)\n+            return IOS_UNAVAILABLE;\n+        if (errno == ENOSYS)\n+            return IOS_UNSUPPORTED_CASE;\n+        if ((errno == EBADF || errno == EINVAL || errno == EXDEV) &&\n+            ((ssize_t)count >= 0))\n+            return IOS_UNSUPPORTED_CASE;\n+        if (errno == EINTR) {\n+            return IOS_INTERRUPTED;\n+        }\n+        JNU_ThrowIOExceptionWithLastError(env, \"Transfer failed\");\n+        return IOS_THROWN;\n+    }\n+    return n;\n+}\n+\n+JNIEXPORT jlong JNICALL\n+Java_sun_nio_ch_FileDispatcherImpl_transferTo0(JNIEnv *env, jobject this,\n+                                            jobject srcFDO,\n+                                            jlong position, jlong count,\n+                                            jobject dstFDO, jboolean append)\n+{\n+    jint srcFD = fdval(env, srcFDO);\n+    jint dstFD = fdval(env, dstFDO);\n+\n+    \/\/ copy_file_range fails with EBADF when appending, and sendfile\n+    \/\/ fails with EINVAL\n+    if (append == JNI_TRUE)\n+        return IOS_UNSUPPORTED_CASE;\n+\n+    off64_t offset = (off64_t)position;\n+    jlong n;\n+    if (my_copy_file_range_func != NULL) {\n+        size_t len = (size_t)count;\n+        n = my_copy_file_range_func(srcFD, &offset, dstFD, NULL, len, 0);\n+        if (n < 0) {\n+            switch (errno) {\n+                case EINTR:\n+                    return IOS_INTERRUPTED;\n+                case EINVAL:\n+                case ENOSYS:\n+                case EXDEV:\n+                    \/\/ ignore and try sendfile()\n+                    break;\n+                default:\n+                    JNU_ThrowIOExceptionWithLastError(env, \"Copy failed\");\n+                    return IOS_THROWN;\n+            }\n+        }\n+        if (n >= 0)\n+            return n;\n+    }\n+\n+    n = sendfile64(dstFD, srcFD, &offset, (size_t)count);\n+    if (n < 0) {\n+        if (errno == EAGAIN)\n+            return IOS_UNAVAILABLE;\n+        if ((errno == EINVAL) && ((ssize_t)count >= 0))\n+            return IOS_UNSUPPORTED_CASE;\n+        if (errno == EINTR) {\n+            return IOS_INTERRUPTED;\n+        }\n+        JNU_ThrowIOExceptionWithLastError(env, \"Transfer failed\");\n+        return IOS_THROWN;\n+    }\n+    return n;\n+}\n","filename":"src\/java.base\/linux\/native\/libnio\/ch\/FileDispatcherImpl.c","additions":132,"deletions":0,"binary":false,"changes":132,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.nio.ch;\n+\n+import java.io.FileDescriptor;\n+import java.io.IOException;\n+\n+class FileDispatcherImpl extends UnixFileDispatcherImpl {\n+    FileDispatcherImpl() {\n+        super();\n+    }\n+\n+    int force(FileDescriptor fd, boolean metaData) throws IOException {\n+        return force0(fd, metaData);\n+    }\n+\n+    boolean canTransferToFromOverlappedMap() {\n+        return false;\n+    }\n+\n+    long transferTo(FileDescriptor src, long position, long count,\n+                    FileDescriptor dst, boolean append) {\n+        return transferTo0(src, position, count, dst, append);\n+    }\n+\n+    \/\/ -- Native methods --\n+\n+    static native int force0(FileDescriptor fd, boolean metaData)\n+        throws IOException;\n+\n+    static native long transferTo0(FileDescriptor src, long position,\n+                                   long count, FileDescriptor dst,\n+                                   boolean append);\n+}\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/ch\/FileDispatcherImpl.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,106 @@\n+\/*\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <sys\/types.h>\n+#include <sys\/socket.h>\n+#include <sys\/uio.h>\n+#include <sys\/mount.h>\n+#include <sys\/param.h>\n+\n+#include \"jni.h\"\n+#include \"nio.h\"\n+#include \"nio_util.h\"\n+#include \"sun_nio_ch_FileDispatcherImpl.h\"\n+\n+static jlong\n+handle(JNIEnv *env, jlong rv, char *msg)\n+{\n+    if (rv >= 0)\n+        return rv;\n+    if (errno == EINTR)\n+        return IOS_INTERRUPTED;\n+    JNU_ThrowIOExceptionWithLastError(env, msg);\n+    return IOS_THROWN;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_ch_FileDispatcherImpl_force0(JNIEnv *env, jobject this,\n+                                          jobject fdo, jboolean md)\n+{\n+    jint fd = fdval(env, fdo);\n+    int result = 0;\n+\n+    result = fcntl(fd, F_FULLFSYNC);\n+    if (result == -1) {\n+        struct statfs fbuf;\n+        int errno_fcntl = errno;\n+        if (fstatfs(fd, &fbuf) == 0) {\n+            if ((fbuf.f_flags & MNT_LOCAL) == 0) {\n+                \/* Try fsync() in case file is not local. *\/\n+                result = fsync(fd);\n+            }\n+        } else {\n+            \/* fstatfs() failed so restore errno from fcntl(). *\/\n+            errno = errno_fcntl;\n+        }\n+    }\n+\n+    return handle(env, result, \"Force failed\");\n+}\n+\n+JNIEXPORT jlong JNICALL\n+Java_sun_nio_ch_FileDispatcherImpl_transferTo0(JNIEnv *env, jobject this,\n+                                               jobject srcFDO,\n+                                               jlong position, jlong count,\n+                                               jobject dstFDO, jboolean append)\n+{\n+    jint srcFD = fdval(env, srcFDO);\n+    jint dstFD = fdval(env, dstFDO);\n+\n+    off_t numBytes;\n+    int result;\n+\n+    numBytes = count;\n+\n+    result = sendfile(srcFD, dstFD, position, &numBytes, NULL, 0);\n+\n+    if (numBytes > 0)\n+        return numBytes;\n+\n+    if (result == -1) {\n+        if (errno == EAGAIN)\n+            return IOS_UNAVAILABLE;\n+        if (errno == EOPNOTSUPP || errno == ENOTSOCK || errno == ENOTCONN)\n+            return IOS_UNSUPPORTED_CASE;\n+        if ((errno == EINVAL) && ((ssize_t)count >= 0))\n+            return IOS_UNSUPPORTED_CASE;\n+        if (errno == EINTR)\n+            return IOS_INTERRUPTED;\n+        JNU_ThrowIOExceptionWithLastError(env, \"Transfer failed\");\n+        return IOS_THROWN;\n+    }\n+\n+    return result;\n+}\n","filename":"src\/java.base\/macosx\/native\/libnio\/ch\/FileDispatcherImpl.c","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"},{"patch":"@@ -1,251 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.nio.ch;\n-\n-import java.io.FileDescriptor;\n-import java.io.IOException;\n-\n-import jdk.internal.access.JavaIOFileDescriptorAccess;\n-import jdk.internal.access.SharedSecrets;\n-\n-class FileDispatcherImpl extends FileDispatcher {\n-    private static final long ALLOCATION_GRANULARITY;\n-    private static final int  MAX_DIRECT_TRANSFER_SIZE;\n-\n-    private static final int MAP_INVALID = -1;\n-    private static final int MAP_RO = 0;\n-    private static final int MAP_RW = 1;\n-    private static final int MAP_PV = 2;\n-\n-    static {\n-        IOUtil.load();\n-        init();\n-        ALLOCATION_GRANULARITY   = allocationGranularity0();\n-        MAX_DIRECT_TRANSFER_SIZE = maxDirectTransferSize0();\n-    }\n-\n-    private static final JavaIOFileDescriptorAccess fdAccess =\n-            SharedSecrets.getJavaIOFileDescriptorAccess();\n-\n-    FileDispatcherImpl() {\n-    }\n-\n-    int read(FileDescriptor fd, long address, int len) throws IOException {\n-        return read0(fd, address, len);\n-    }\n-\n-    int pread(FileDescriptor fd, long address, int len, long position)\n-        throws IOException\n-    {\n-        return pread0(fd, address, len, position);\n-    }\n-\n-    long readv(FileDescriptor fd, long address, int len) throws IOException {\n-        return readv0(fd, address, len);\n-    }\n-\n-    int write(FileDescriptor fd, long address, int len) throws IOException {\n-        return write0(fd, address, len);\n-    }\n-\n-    int pwrite(FileDescriptor fd, long address, int len, long position)\n-        throws IOException\n-    {\n-        return pwrite0(fd, address, len, position);\n-    }\n-\n-    long writev(FileDescriptor fd, long address, int len)\n-        throws IOException\n-    {\n-        return writev0(fd, address, len);\n-    }\n-\n-    long seek(FileDescriptor fd, long offset) throws IOException {\n-        return seek0(fd, offset);\n-    }\n-\n-    int force(FileDescriptor fd, boolean metaData) throws IOException {\n-        return force0(fd, metaData);\n-    }\n-\n-    int truncate(FileDescriptor fd, long size) throws IOException {\n-        return truncate0(fd, size);\n-    }\n-\n-    long size(FileDescriptor fd) throws IOException {\n-        return size0(fd);\n-    }\n-\n-    int lock(FileDescriptor fd, boolean blocking, long pos, long size,\n-             boolean shared) throws IOException\n-    {\n-        return lock0(fd, blocking, pos, size, shared);\n-    }\n-\n-    void release(FileDescriptor fd, long pos, long size) throws IOException {\n-        release0(fd, pos, size);\n-    }\n-\n-    void close(FileDescriptor fd) throws IOException {\n-        fdAccess.close(fd);\n-    }\n-\n-    void preClose(FileDescriptor fd) throws IOException {\n-        preClose0(fd);\n-    }\n-\n-    void dup(FileDescriptor fd1, FileDescriptor fd2) throws IOException {\n-        dup0(fd1, fd2);\n-    }\n-\n-    FileDescriptor duplicateForMapping(FileDescriptor fd) {\n-        \/\/ file descriptor not required for mapping operations; okay\n-        \/\/ to return invalid file descriptor.\n-        return new FileDescriptor();\n-    }\n-\n-    boolean canTransferToDirectly(java.nio.channels.SelectableChannel sc) {\n-        return true;\n-    }\n-\n-    boolean transferToDirectlyNeedsPositionLock() {\n-        return false;\n-    }\n-\n-    boolean canTransferToFromOverlappedMap() {\n-        return canTransferToFromOverlappedMap0();\n-    }\n-\n-    long allocationGranularity() {\n-        return ALLOCATION_GRANULARITY;\n-    }\n-\n-    long map(FileDescriptor fd, int prot, long position, long length,\n-             boolean isSync)\n-        throws IOException\n-    {\n-        return map0(fd, prot, position, length, isSync);\n-    }\n-\n-    int unmap(long address, long length) {\n-        return unmap0(address, length);\n-    }\n-\n-    int maxDirectTransferSize() {\n-        return MAX_DIRECT_TRANSFER_SIZE;\n-    }\n-\n-    long transferTo(FileDescriptor src, long position, long count,\n-                    FileDescriptor dst, boolean append) {\n-        return transferTo0(src, position, count, dst, append);\n-    }\n-\n-    long transferFrom(FileDescriptor src, FileDescriptor dst,\n-                      long position, long count, boolean append) {\n-        return transferFrom0(src, dst, position, count, append);\n-    }\n-\n-    int setDirectIO(FileDescriptor fd, String path) {\n-        int result = -1;\n-        try {\n-            result = setDirect0(fd);\n-        } catch (IOException e) {\n-            throw new UnsupportedOperationException\n-                (\"Error setting up DirectIO\", e);\n-        }\n-        return result;\n-    }\n-\n-    \/\/ -- Native methods --\n-\n-    static native int read0(FileDescriptor fd, long address, int len)\n-        throws IOException;\n-\n-    static native int pread0(FileDescriptor fd, long address, int len,\n-                             long position) throws IOException;\n-\n-    static native long readv0(FileDescriptor fd, long address, int len)\n-        throws IOException;\n-\n-    static native int write0(FileDescriptor fd, long address, int len)\n-        throws IOException;\n-\n-    static native int pwrite0(FileDescriptor fd, long address, int len,\n-                             long position) throws IOException;\n-\n-    static native long writev0(FileDescriptor fd, long address, int len)\n-        throws IOException;\n-\n-    static native int force0(FileDescriptor fd, boolean metaData)\n-        throws IOException;\n-\n-    static native long seek0(FileDescriptor fd, long offset)\n-        throws IOException;\n-\n-    static native int truncate0(FileDescriptor fd, long size)\n-        throws IOException;\n-\n-    static native long size0(FileDescriptor fd) throws IOException;\n-\n-    static native int lock0(FileDescriptor fd, boolean blocking, long pos,\n-                            long size, boolean shared) throws IOException;\n-\n-    static native void release0(FileDescriptor fd, long pos, long size)\n-        throws IOException;\n-\n-    \/\/ Shared with SocketDispatcher and DatagramDispatcher but\n-    \/\/ NOT used by FileDispatcherImpl\n-    static native void close0(FileDescriptor fd) throws IOException;\n-\n-    static native void preClose0(FileDescriptor fd) throws IOException;\n-\n-    static native void dup0(FileDescriptor fd1, FileDescriptor fd2) throws IOException;\n-\n-    static native void closeIntFD(int fd) throws IOException;\n-\n-    static native boolean canTransferToFromOverlappedMap0();\n-\n-    static native long allocationGranularity0();\n-\n-    static native long map0(FileDescriptor fd, int prot, long position,\n-                            long length, boolean isSync)\n-        throws IOException;\n-\n-    static native int unmap0(long address, long length);\n-\n-    static native int maxDirectTransferSize0();\n-\n-    static native long transferTo0(FileDescriptor src, long position,\n-                                   long count, FileDescriptor dst,\n-                                   boolean append);\n-\n-    static native long transferFrom0(FileDescriptor src, FileDescriptor dst,\n-                                     long position, long count, boolean append);\n-\n-    static native int setDirect0(FileDescriptor fd) throws IOException;\n-\n-    static native void init();\n-}\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/ch\/FileDispatcherImpl.java","additions":0,"deletions":251,"binary":false,"changes":251,"status":"deleted"},{"patch":"@@ -0,0 +1,234 @@\n+\/*\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.nio.ch;\n+\n+import java.io.FileDescriptor;\n+import java.io.IOException;\n+\n+import jdk.internal.access.JavaIOFileDescriptorAccess;\n+import jdk.internal.access.SharedSecrets;\n+\n+class UnixFileDispatcherImpl extends FileDispatcher {\n+    private static final int MAP_INVALID = -1;\n+    private static final int MAP_RO = 0;\n+    private static final int MAP_RW = 1;\n+    private static final int MAP_PV = 2;\n+\n+    static {\n+        IOUtil.load();\n+    }\n+\n+    private static final JavaIOFileDescriptorAccess fdAccess =\n+            SharedSecrets.getJavaIOFileDescriptorAccess();\n+\n+    UnixFileDispatcherImpl() {\n+    }\n+\n+    int read(FileDescriptor fd, long address, int len) throws IOException {\n+        return read0(fd, address, len);\n+    }\n+\n+    int pread(FileDescriptor fd, long address, int len, long position)\n+        throws IOException\n+    {\n+        return pread0(fd, address, len, position);\n+    }\n+\n+    long readv(FileDescriptor fd, long address, int len) throws IOException {\n+        return readv0(fd, address, len);\n+    }\n+\n+    int write(FileDescriptor fd, long address, int len) throws IOException {\n+        return write0(fd, address, len);\n+    }\n+\n+    int pwrite(FileDescriptor fd, long address, int len, long position)\n+        throws IOException\n+    {\n+        return pwrite0(fd, address, len, position);\n+    }\n+\n+    long writev(FileDescriptor fd, long address, int len)\n+        throws IOException\n+    {\n+        return writev0(fd, address, len);\n+    }\n+\n+    long seek(FileDescriptor fd, long offset) throws IOException {\n+        return seek0(fd, offset);\n+    }\n+\n+    int force(FileDescriptor fd, boolean metaData) throws IOException {\n+        return force0(fd, metaData);\n+    }\n+\n+    int truncate(FileDescriptor fd, long size) throws IOException {\n+        return truncate0(fd, size);\n+    }\n+\n+    long size(FileDescriptor fd) throws IOException {\n+        return size0(fd);\n+    }\n+\n+    int lock(FileDescriptor fd, boolean blocking, long pos, long size,\n+             boolean shared) throws IOException\n+    {\n+        return lock0(fd, blocking, pos, size, shared);\n+    }\n+\n+    void release(FileDescriptor fd, long pos, long size) throws IOException {\n+        release0(fd, pos, size);\n+    }\n+\n+    void close(FileDescriptor fd) throws IOException {\n+        fdAccess.close(fd);\n+    }\n+\n+    void preClose(FileDescriptor fd) throws IOException {\n+        preClose0(fd);\n+    }\n+\n+    void dup(FileDescriptor fd1, FileDescriptor fd2) throws IOException {\n+        dup0(fd1, fd2);\n+    }\n+\n+    FileDescriptor duplicateForMapping(FileDescriptor fd) {\n+        \/\/ file descriptor not required for mapping operations; okay\n+        \/\/ to return invalid file descriptor.\n+        return new FileDescriptor();\n+    }\n+\n+    boolean canTransferToDirectly(java.nio.channels.SelectableChannel sc) {\n+        return true;\n+    }\n+\n+    boolean transferToDirectlyNeedsPositionLock() {\n+        return false;\n+    }\n+\n+    boolean canTransferToFromOverlappedMap() {\n+        return true;\n+    }\n+\n+    long allocationGranularity() {\n+        return allocationGranularity0();\n+    }\n+\n+    long map(FileDescriptor fd, int prot, long position, long length,\n+             boolean isSync)\n+        throws IOException\n+    {\n+        return map0(fd, prot, position, length, isSync);\n+    }\n+\n+    int unmap(long address, long length) {\n+        return unmap0(address, length);\n+    }\n+\n+    int maxDirectTransferSize() {\n+        return Integer.MAX_VALUE;\n+    }\n+\n+    long transferTo(FileDescriptor src, long position, long count,\n+                    FileDescriptor dst, boolean append) {\n+        return IOStatus.UNSUPPORTED;\n+    }\n+\n+    long transferFrom(FileDescriptor src, FileDescriptor dst,\n+                      long position, long count, boolean append) {\n+        return IOStatus.UNSUPPORTED;\n+    }\n+\n+    int setDirectIO(FileDescriptor fd, String path) {\n+        int result = -1;\n+        try {\n+            result = setDirect0(fd);\n+        } catch (IOException e) {\n+            throw new UnsupportedOperationException\n+                (\"Error setting up DirectIO\", e);\n+        }\n+        return result;\n+    }\n+\n+    \/\/ -- Native methods --\n+\n+    static native int read0(FileDescriptor fd, long address, int len)\n+        throws IOException;\n+\n+    static native int pread0(FileDescriptor fd, long address, int len,\n+                             long position) throws IOException;\n+\n+    static native long readv0(FileDescriptor fd, long address, int len)\n+        throws IOException;\n+\n+    static native int write0(FileDescriptor fd, long address, int len)\n+        throws IOException;\n+\n+    static native int pwrite0(FileDescriptor fd, long address, int len,\n+                             long position) throws IOException;\n+\n+    static native long writev0(FileDescriptor fd, long address, int len)\n+        throws IOException;\n+\n+    static native int force0(FileDescriptor fd, boolean metaData)\n+        throws IOException;\n+\n+    static native long seek0(FileDescriptor fd, long offset)\n+        throws IOException;\n+\n+    static native int truncate0(FileDescriptor fd, long size)\n+        throws IOException;\n+\n+    static native long size0(FileDescriptor fd) throws IOException;\n+\n+    static native int lock0(FileDescriptor fd, boolean blocking, long pos,\n+                            long size, boolean shared) throws IOException;\n+\n+    static native void release0(FileDescriptor fd, long pos, long size)\n+        throws IOException;\n+\n+    \/\/ Shared with SocketDispatcher and DatagramDispatcher but\n+    \/\/ NOT used by FileDispatcherImpl\n+    static native void close0(FileDescriptor fd) throws IOException;\n+\n+    static native void preClose0(FileDescriptor fd) throws IOException;\n+\n+    static native void dup0(FileDescriptor fd1, FileDescriptor fd2) throws IOException;\n+\n+    static native void closeIntFD(int fd) throws IOException;\n+\n+    static native long allocationGranularity0();\n+\n+    static native long map0(FileDescriptor fd, int prot, long position,\n+                            long length, boolean isSync)\n+        throws IOException;\n+\n+    static native int unmap0(long address, long length);\n+\n+    static native int setDirect0(FileDescriptor fd) throws IOException;\n+\n+    static native void init();\n+}\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/ch\/UnixFileDispatcherImpl.java","additions":234,"deletions":0,"binary":false,"changes":234,"status":"added"},{"patch":"@@ -1,684 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <sys\/mman.h>\n-#include <sys\/types.h>\n-#include <sys\/socket.h>\n-#include <fcntl.h>\n-#include <sys\/uio.h>\n-#include <unistd.h>\n-#ifdef MACOSX\n-#include <sys\/mount.h>\n-#include <sys\/param.h>\n-#endif\n-#include <sys\/stat.h>\n-#include <sys\/statvfs.h>\n-\n-#if defined(__linux__)\n-#include <linux\/fs.h>\n-#include <sys\/ioctl.h>\n-#include <sys\/sendfile.h>\n-#include <dlfcn.h>\n-#endif\n-\n-#if defined(_ALLBSD_SOURCE)\n-#define lseek64 lseek\n-#define stat64 stat\n-#define flock64 flock\n-#define off64_t off_t\n-#define F_SETLKW64 F_SETLKW\n-#define F_SETLK64 F_SETLK\n-#define pread64 pread\n-#define pwrite64 pwrite\n-#define ftruncate64 ftruncate\n-#define fstat64 fstat\n-#define fdatasync fsync\n-#define mmap64 mmap\n-#endif\n-\n-#if defined(_AIX)\n-#include <string.h>\n-#endif\n-\n-#include \"jni.h\"\n-#include \"jni_util.h\"\n-#include \"jvm.h\"\n-#include \"jlong.h\"\n-#include \"nio.h\"\n-#include \"nio_util.h\"\n-#include \"sun_nio_ch_FileDispatcherImpl.h\"\n-#include \"java_lang_Integer.h\"\n-#include \"java_lang_Long.h\"\n-#include <assert.h>\n-\n-#if defined(__linux__)\n-typedef ssize_t copy_file_range_func(int, loff_t*, int, loff_t*, size_t,\n-                                     unsigned int);\n-static copy_file_range_func* my_copy_file_range_func = NULL;\n-#endif\n-\n-static int preCloseFD = -1;     \/* File descriptor to which we dup other fd's\n-                                   before closing them for real *\/\n-\n-\n-JNIEXPORT void JNICALL\n-Java_sun_nio_ch_FileDispatcherImpl_init(JNIEnv *env, jclass cl)\n-{\n-    int sp[2];\n-    if (socketpair(PF_UNIX, SOCK_STREAM, 0, sp) < 0) {\n-        JNU_ThrowIOExceptionWithLastError(env, \"socketpair failed\");\n-        return;\n-    }\n-    preCloseFD = sp[0];\n-    close(sp[1]);\n-#if defined(__linux__)\n-    my_copy_file_range_func =\n-        (copy_file_range_func*) dlsym(RTLD_DEFAULT, \"copy_file_range\");\n-#endif\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_ch_FileDispatcherImpl_read0(JNIEnv *env, jclass clazz,\n-                             jobject fdo, jlong address, jint len)\n-{\n-    jint fd = fdval(env, fdo);\n-    void *buf = (void *)jlong_to_ptr(address);\n-\n-    return convertReturnVal(env, read(fd, buf, len), JNI_TRUE);\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_ch_FileDispatcherImpl_pread0(JNIEnv *env, jclass clazz, jobject fdo,\n-                            jlong address, jint len, jlong offset)\n-{\n-    jint fd = fdval(env, fdo);\n-    void *buf = (void *)jlong_to_ptr(address);\n-\n-    return convertReturnVal(env, pread64(fd, buf, len, offset), JNI_TRUE);\n-}\n-\n-JNIEXPORT jlong JNICALL\n-Java_sun_nio_ch_FileDispatcherImpl_readv0(JNIEnv *env, jclass clazz,\n-                              jobject fdo, jlong address, jint len)\n-{\n-    jint fd = fdval(env, fdo);\n-    struct iovec *iov = (struct iovec *)jlong_to_ptr(address);\n-    return convertLongReturnVal(env, readv(fd, iov, len), JNI_TRUE);\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_ch_FileDispatcherImpl_write0(JNIEnv *env, jclass clazz,\n-                              jobject fdo, jlong address, jint len)\n-{\n-    jint fd = fdval(env, fdo);\n-    void *buf = (void *)jlong_to_ptr(address);\n-\n-    return convertReturnVal(env, write(fd, buf, len), JNI_FALSE);\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_ch_FileDispatcherImpl_pwrite0(JNIEnv *env, jclass clazz, jobject fdo,\n-                            jlong address, jint len, jlong offset)\n-{\n-    jint fd = fdval(env, fdo);\n-    void *buf = (void *)jlong_to_ptr(address);\n-\n-    return convertReturnVal(env, pwrite64(fd, buf, len, offset), JNI_FALSE);\n-}\n-\n-JNIEXPORT jlong JNICALL\n-Java_sun_nio_ch_FileDispatcherImpl_writev0(JNIEnv *env, jclass clazz,\n-                                       jobject fdo, jlong address, jint len)\n-{\n-    jint fd = fdval(env, fdo);\n-    struct iovec *iov = (struct iovec *)jlong_to_ptr(address);\n-    return convertLongReturnVal(env, writev(fd, iov, len), JNI_FALSE);\n-}\n-\n-static jlong\n-handle(JNIEnv *env, jlong rv, char *msg)\n-{\n-    if (rv >= 0)\n-        return rv;\n-    if (errno == EINTR)\n-        return IOS_INTERRUPTED;\n-    JNU_ThrowIOExceptionWithLastError(env, msg);\n-    return IOS_THROWN;\n-}\n-\n-JNIEXPORT jlong JNICALL\n-Java_sun_nio_ch_FileDispatcherImpl_seek0(JNIEnv *env, jclass clazz,\n-                                         jobject fdo, jlong offset)\n-{\n-    jint fd = fdval(env, fdo);\n-    off64_t result;\n-    if (offset < 0) {\n-        result = lseek64(fd, 0, SEEK_CUR);\n-    } else {\n-        result = lseek64(fd, offset, SEEK_SET);\n-    }\n-    return handle(env, (jlong)result, \"lseek64 failed\");\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_ch_FileDispatcherImpl_force0(JNIEnv *env, jobject this,\n-                                          jobject fdo, jboolean md)\n-{\n-    jint fd = fdval(env, fdo);\n-    int result = 0;\n-\n-#ifdef MACOSX\n-    result = fcntl(fd, F_FULLFSYNC);\n-    if (result == -1) {\n-        struct statfs fbuf;\n-        int errno_fcntl = errno;\n-        if (fstatfs(fd, &fbuf) == 0) {\n-            if ((fbuf.f_flags & MNT_LOCAL) == 0) {\n-                \/* Try fsync() in case file is not local. *\/\n-                result = fsync(fd);\n-            }\n-        } else {\n-            \/* fstatfs() failed so restore errno from fcntl(). *\/\n-            errno = errno_fcntl;\n-        }\n-    }\n-#else \/* end MACOSX, begin not-MACOSX *\/\n-    if (md == JNI_FALSE) {\n-        result = fdatasync(fd);\n-    } else {\n-#ifdef _AIX\n-        \/* On AIX, calling fsync on a file descriptor that is opened only for\n-         * reading results in an error (\"EBADF: The FileDescriptor parameter is\n-         * not a valid file descriptor open for writing.\").\n-         * However, at this point it is not possibly anymore to read the\n-         * 'writable' attribute of the corresponding file channel so we have to\n-         * use 'fcntl'.\n-         *\/\n-        int getfl = fcntl(fd, F_GETFL);\n-        if (getfl >= 0 && (getfl & O_ACCMODE) == O_RDONLY) {\n-            return 0;\n-        }\n-#endif \/* _AIX *\/\n-        result = fsync(fd);\n-    }\n-#endif \/* not-MACOSX *\/\n-    return handle(env, result, \"Force failed\");\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_ch_FileDispatcherImpl_truncate0(JNIEnv *env, jobject this,\n-                                             jobject fdo, jlong size)\n-{\n-    return handle(env,\n-                  ftruncate64(fdval(env, fdo), size),\n-                  \"Truncation failed\");\n-}\n-\n-JNIEXPORT jlong JNICALL\n-Java_sun_nio_ch_FileDispatcherImpl_size0(JNIEnv *env, jobject this, jobject fdo)\n-{\n-    jint fd = fdval(env, fdo);\n-    struct stat64 fbuf;\n-\n-    if (fstat64(fd, &fbuf) < 0)\n-        return handle(env, -1, \"Size failed\");\n-\n-#ifdef BLKGETSIZE64\n-    if (S_ISBLK(fbuf.st_mode)) {\n-        uint64_t size;\n-        if (ioctl(fd, BLKGETSIZE64, &size) < 0)\n-            return handle(env, -1, \"Size failed\");\n-        return (jlong)size;\n-    }\n-#endif\n-\n-    return fbuf.st_size;\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_ch_FileDispatcherImpl_lock0(JNIEnv *env, jobject this, jobject fdo,\n-                                      jboolean block, jlong pos, jlong size,\n-                                      jboolean shared)\n-{\n-    jint fd = fdval(env, fdo);\n-    jint lockResult = 0;\n-    int cmd = 0;\n-    struct flock64 fl;\n-\n-    fl.l_whence = SEEK_SET;\n-    if (size == (jlong)java_lang_Long_MAX_VALUE) {\n-        fl.l_len = (off64_t)0;\n-    } else {\n-        fl.l_len = (off64_t)size;\n-    }\n-    fl.l_start = (off64_t)pos;\n-    if (shared == JNI_TRUE) {\n-        fl.l_type = F_RDLCK;\n-    } else {\n-        fl.l_type = F_WRLCK;\n-    }\n-    if (block == JNI_TRUE) {\n-        cmd = F_SETLKW64;\n-    } else {\n-        cmd = F_SETLK64;\n-    }\n-    lockResult = fcntl(fd, cmd, &fl);\n-    if (lockResult < 0) {\n-        if ((cmd == F_SETLK64) && (errno == EAGAIN || errno == EACCES))\n-            return sun_nio_ch_FileDispatcherImpl_NO_LOCK;\n-        if (errno == EINTR)\n-            return sun_nio_ch_FileDispatcherImpl_INTERRUPTED;\n-        JNU_ThrowIOExceptionWithLastError(env, \"Lock failed\");\n-    }\n-    return 0;\n-}\n-\n-JNIEXPORT void JNICALL\n-Java_sun_nio_ch_FileDispatcherImpl_release0(JNIEnv *env, jobject this,\n-                                         jobject fdo, jlong pos, jlong size)\n-{\n-    jint fd = fdval(env, fdo);\n-    jint lockResult = 0;\n-    struct flock64 fl;\n-    int cmd = F_SETLK64;\n-\n-    fl.l_whence = SEEK_SET;\n-    if (size == (jlong)java_lang_Long_MAX_VALUE) {\n-        fl.l_len = (off64_t)0;\n-    } else {\n-        fl.l_len = (off64_t)size;\n-    }\n-    fl.l_start = (off64_t)pos;\n-    fl.l_type = F_UNLCK;\n-    lockResult = fcntl(fd, cmd, &fl);\n-    if (lockResult < 0) {\n-        JNU_ThrowIOExceptionWithLastError(env, \"Release failed\");\n-    }\n-}\n-\n-\n-static void closeFileDescriptor(JNIEnv *env, int fd) {\n-    if (fd != -1) {\n-        int result = close(fd);\n-        if (result < 0)\n-            JNU_ThrowIOExceptionWithLastError(env, \"Close failed\");\n-    }\n-}\n-\n-JNIEXPORT void JNICALL\n-Java_sun_nio_ch_FileDispatcherImpl_close0(JNIEnv *env, jclass clazz, jobject fdo)\n-{\n-    jint fd = fdval(env, fdo);\n-    closeFileDescriptor(env, fd);\n-}\n-\n-JNIEXPORT void JNICALL\n-Java_sun_nio_ch_FileDispatcherImpl_preClose0(JNIEnv *env, jclass clazz, jobject fdo)\n-{\n-    jint fd = fdval(env, fdo);\n-    if (preCloseFD >= 0) {\n-        if (dup2(preCloseFD, fd) < 0)\n-            JNU_ThrowIOExceptionWithLastError(env, \"dup2 failed\");\n-    }\n-}\n-\n-JNIEXPORT void JNICALL\n-Java_sun_nio_ch_FileDispatcherImpl_dup0(JNIEnv *env, jobject this, jobject fdo1, jobject fdo2)\n-{\n-    if (dup2(fdval(env, fdo1), fdval(env, fdo2)) < 0) {\n-        JNU_ThrowIOExceptionWithLastError(env, \"dup2 failed\");\n-    }\n-}\n-\n-JNIEXPORT void JNICALL\n-Java_sun_nio_ch_FileDispatcherImpl_closeIntFD(JNIEnv *env, jclass clazz, jint fd)\n-{\n-    closeFileDescriptor(env, fd);\n-}\n-\n-JNIEXPORT jboolean JNICALL\n-Java_sun_nio_ch_FileDispatcherImpl_canTransferToFromOverlappedMap0(JNIEnv *env, jclass clazz)\n-{\n-#ifdef MACOSX\n-    return JNI_FALSE;\n-#else\n-    return JNI_TRUE;\n-#endif\n-}\n-\n-JNIEXPORT jlong JNICALL\n-Java_sun_nio_ch_FileDispatcherImpl_allocationGranularity0(JNIEnv *env, jclass klass)\n-{\n-    jlong pageSize = sysconf(_SC_PAGESIZE);\n-    return pageSize;\n-}\n-\n-JNIEXPORT jlong JNICALL\n-Java_sun_nio_ch_FileDispatcherImpl_map0(JNIEnv *env, jclass klass, jobject fdo,\n-                                        jint prot, jlong off, jlong len,\n-                                        jboolean map_sync)\n-{\n-    void *mapAddress = 0;\n-    jint fd = fdval(env, fdo);\n-    int protections = 0;\n-    int flags = 0;\n-\n-    \/\/ should never be called with map_sync and prot == PRIVATE\n-    assert((prot != sun_nio_ch_FileDispatcherImpl_MAP_PV) || !map_sync);\n-\n-    if (prot == sun_nio_ch_FileDispatcherImpl_MAP_RO) {\n-        protections = PROT_READ;\n-        flags = MAP_SHARED;\n-    } else if (prot == sun_nio_ch_FileDispatcherImpl_MAP_RW) {\n-        protections = PROT_WRITE | PROT_READ;\n-        flags = MAP_SHARED;\n-    } else if (prot == sun_nio_ch_FileDispatcherImpl_MAP_PV) {\n-        protections =  PROT_WRITE | PROT_READ;\n-        flags = MAP_PRIVATE;\n-    }\n-\n-    \/\/ if MAP_SYNC and MAP_SHARED_VALIDATE are not defined then it is\n-    \/\/ best to define them here. This ensures the code compiles on old\n-    \/\/ OS releases which do not provide the relevant headers. If run\n-    \/\/ on the same machine then it will work if the kernel contains\n-    \/\/ the necessary support otherwise mmap should fail with an\n-    \/\/ invalid argument error\n-\n-#ifndef MAP_SYNC\n-#define MAP_SYNC 0x80000\n-#endif\n-#ifndef MAP_SHARED_VALIDATE\n-#define MAP_SHARED_VALIDATE 0x03\n-#endif\n-\n-    if (map_sync) {\n-        \/\/ ensure\n-        \/\/  1) this is Linux on AArch64, x86_64, or PPC64 LE\n-        \/\/  2) the mmap APIs are available at compile time\n-#if !defined(LINUX) || ! (defined(aarch64) || (defined(amd64) && defined(_LP64)) || defined(ppc64le))\n-        \/\/ TODO - implement for solaris\/AIX\/BSD\/WINDOWS and for 32 bit\n-        JNU_ThrowInternalError(env, \"should never call map on platform where MAP_SYNC is unimplemented\");\n-        return IOS_THROWN;\n-#else\n-        flags |= MAP_SYNC | MAP_SHARED_VALIDATE;\n-#endif\n-    }\n-\n-    mapAddress = mmap64(\n-        0,                    \/* Let OS decide location *\/\n-        len,                  \/* Number of bytes to map *\/\n-        protections,          \/* File permissions *\/\n-        flags,                \/* Changes are shared *\/\n-        fd,                   \/* File descriptor of mapped file *\/\n-        off);                 \/* Offset into file *\/\n-\n-    if (mapAddress == MAP_FAILED) {\n-        if (map_sync && errno == ENOTSUP) {\n-            JNU_ThrowIOExceptionWithLastError(env, \"map with mode MAP_SYNC unsupported\");\n-            return IOS_THROWN;\n-        }\n-\n-        if (errno == ENOMEM) {\n-            JNU_ThrowOutOfMemoryError(env, \"Map failed\");\n-            return IOS_THROWN;\n-        }\n-        return handle(env, -1, \"Map failed\");\n-    }\n-\n-    return ((jlong) (unsigned long) mapAddress);\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_ch_FileDispatcherImpl_unmap0(JNIEnv *env, jclass klass,\n-                                          jlong address, jlong len)\n-{\n-    void *a = (void *)jlong_to_ptr(address);\n-    return handle(env,\n-                  munmap(a, (size_t)len),\n-                  \"Unmap failed\");\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_ch_FileDispatcherImpl_maxDirectTransferSize0(JNIEnv* env, jclass klass) {\n-#if defined(__linux__)\n-    return 0x7ffff000; \/\/ 2,147,479,552 maximum for sendfile()\n-#else\n-    return java_lang_Integer_MAX_VALUE;\n-#endif\n-}\n-\n-JNIEXPORT jlong JNICALL\n-Java_sun_nio_ch_FileDispatcherImpl_transferTo0(JNIEnv *env, jobject this,\n-                                               jobject srcFDO,\n-                                               jlong position, jlong count,\n-                                               jobject dstFDO, jboolean append)\n-{\n-    jint srcFD = fdval(env, srcFDO);\n-    jint dstFD = fdval(env, dstFDO);\n-\n-#if defined(__linux__)\n-    \/\/ copy_file_range fails with EBADF when appending, and sendfile\n-    \/\/ fails with EINVAL\n-    if (append == JNI_TRUE)\n-        return IOS_UNSUPPORTED_CASE;\n-\n-    off64_t offset = (off64_t)position;\n-    jlong n;\n-    if (my_copy_file_range_func != NULL) {\n-        size_t len = (size_t)count;\n-        n = my_copy_file_range_func(srcFD, &offset, dstFD, NULL, len, 0);\n-        if (n < 0) {\n-            switch (errno) {\n-                case EINTR:\n-                    return IOS_INTERRUPTED;\n-                case EINVAL:\n-                case ENOSYS:\n-                case EXDEV:\n-                    \/\/ ignore and try sendfile()\n-                    break;\n-                default:\n-                    JNU_ThrowIOExceptionWithLastError(env, \"Copy failed\");\n-                    return IOS_THROWN;\n-            }\n-        }\n-        if (n >= 0)\n-            return n;\n-    }\n-\n-    n = sendfile64(dstFD, srcFD, &offset, (size_t)count);\n-    if (n < 0) {\n-        if (errno == EAGAIN)\n-            return IOS_UNAVAILABLE;\n-        if ((errno == EINVAL) && ((ssize_t)count >= 0))\n-            return IOS_UNSUPPORTED_CASE;\n-        if (errno == EINTR) {\n-            return IOS_INTERRUPTED;\n-        }\n-        JNU_ThrowIOExceptionWithLastError(env, \"Transfer failed\");\n-        return IOS_THROWN;\n-    }\n-    return n;\n-#elif defined(_ALLBSD_SOURCE)\n-    off_t numBytes;\n-    int result;\n-\n-    numBytes = count;\n-\n-    result = sendfile(srcFD, dstFD, position, &numBytes, NULL, 0);\n-\n-    if (numBytes > 0)\n-        return numBytes;\n-\n-    if (result == -1) {\n-        if (errno == EAGAIN)\n-            return IOS_UNAVAILABLE;\n-        if (errno == EOPNOTSUPP || errno == ENOTSOCK || errno == ENOTCONN)\n-            return IOS_UNSUPPORTED_CASE;\n-        if ((errno == EINVAL) && ((ssize_t)count >= 0))\n-            return IOS_UNSUPPORTED_CASE;\n-        if (errno == EINTR)\n-            return IOS_INTERRUPTED;\n-        JNU_ThrowIOExceptionWithLastError(env, \"Transfer failed\");\n-        return IOS_THROWN;\n-    }\n-\n-    return result;\n-#elif defined(_AIX)\n-    jlong max = (jlong)java_lang_Integer_MAX_VALUE;\n-    struct sf_parms sf_iobuf;\n-    jlong result;\n-\n-    if (position > max)\n-        return IOS_UNSUPPORTED_CASE;\n-\n-    if (count > max)\n-        count = max;\n-\n-    memset(&sf_iobuf, 0, sizeof(sf_iobuf));\n-    sf_iobuf.file_descriptor = srcFD;\n-    sf_iobuf.file_offset = (off_t)position;\n-    sf_iobuf.file_bytes = count;\n-\n-    result = send_file(&dstFD, &sf_iobuf, SF_SYNC_CACHE);\n-\n-    \/* AIX send_file() will return 0 when this operation complete successfully,\n-     * return 1 when partial bytes transferred and return -1 when an error has\n-     * occurred.\n-     *\/\n-    if (result == -1) {\n-        if (errno == EWOULDBLOCK)\n-            return IOS_UNAVAILABLE;\n-        if ((errno == EINVAL) && ((ssize_t)count >= 0))\n-            return IOS_UNSUPPORTED_CASE;\n-        if (errno == EINTR)\n-            return IOS_INTERRUPTED;\n-        if (errno == ENOTSOCK)\n-            return IOS_UNSUPPORTED;\n-        JNU_ThrowIOExceptionWithLastError(env, \"Transfer failed\");\n-        return IOS_THROWN;\n-    }\n-\n-    if (sf_iobuf.bytes_sent > 0)\n-        return (jlong)sf_iobuf.bytes_sent;\n-\n-    return IOS_UNSUPPORTED_CASE;\n-#else\n-    return IOS_UNSUPPORTED;\n-#endif\n-}\n-\n-JNIEXPORT jlong JNICALL\n-Java_sun_nio_ch_FileDispatcherImpl_transferFrom0(JNIEnv *env, jobject this,\n-                                                 jobject srcFDO, jobject dstFDO,\n-                                                 jlong position, jlong count,\n-                                                 jboolean append)\n-{\n-#if defined(__linux__)\n-    if (my_copy_file_range_func == NULL)\n-        return IOS_UNSUPPORTED;\n-    \/\/ copy_file_range fails with EBADF when appending\n-    if (append == JNI_TRUE)\n-        return IOS_UNSUPPORTED_CASE;\n-\n-    jint srcFD = fdval(env, srcFDO);\n-    jint dstFD = fdval(env, dstFDO);\n-\n-    off64_t offset = (off64_t)position;\n-    size_t len = (size_t)count;\n-    jlong n = my_copy_file_range_func(srcFD, NULL, dstFD, &offset, len, 0);\n-    if (n < 0) {\n-        if (errno == EAGAIN)\n-            return IOS_UNAVAILABLE;\n-        if (errno == ENOSYS)\n-            return IOS_UNSUPPORTED_CASE;\n-        if ((errno == EBADF || errno == EINVAL || errno == EXDEV) &&\n-            ((ssize_t)count >= 0))\n-            return IOS_UNSUPPORTED_CASE;\n-        if (errno == EINTR) {\n-            return IOS_INTERRUPTED;\n-        }\n-        JNU_ThrowIOExceptionWithLastError(env, \"Transfer failed\");\n-        return IOS_THROWN;\n-    }\n-    return n;\n-#else\n-    return IOS_UNSUPPORTED;\n-#endif\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_ch_FileDispatcherImpl_setDirect0(JNIEnv *env, jclass clazz,\n-                                              jobject fdo)\n-{\n-    jint fd = fdval(env, fdo);\n-    jint result;\n-#ifdef MACOSX\n-    struct statvfs file_stat;\n-#else\n-    struct statvfs64 file_stat;\n-#endif\n-\n-#if defined(O_DIRECT) || defined(F_NOCACHE) || defined(DIRECTIO_ON)\n-#ifdef O_DIRECT\n-    jint orig_flag;\n-    orig_flag = fcntl(fd, F_GETFL);\n-    if (orig_flag == -1) {\n-        JNU_ThrowIOExceptionWithLastError(env, \"DirectIO setup failed\");\n-        return -1;\n-    }\n-    result = fcntl(fd, F_SETFL, orig_flag | O_DIRECT);\n-    if (result == -1) {\n-        JNU_ThrowIOExceptionWithLastError(env, \"DirectIO setup failed\");\n-        return result;\n-    }\n-#elif defined(F_NOCACHE)\n-    result = fcntl(fd, F_NOCACHE, 1);\n-    if (result == -1) {\n-        JNU_ThrowIOExceptionWithLastError(env, \"DirectIO setup failed\");\n-        return result;\n-    }\n-#elif defined(DIRECTIO_ON)\n-    result = directio(fd, DIRECTIO_ON);\n-    if (result == -1) {\n-        JNU_ThrowIOExceptionWithLastError(env, \"DirectIO setup failed\");\n-        return result;\n-    }\n-#endif\n-#ifdef MACOSX\n-    result = fstatvfs(fd, &file_stat);\n-#else\n-    result = fstatvfs64(fd, &file_stat);\n-#endif\n-    if(result == -1) {\n-        JNU_ThrowIOExceptionWithLastError(env, \"DirectIO setup failed\");\n-        return result;\n-    } else {\n-        result = (int)file_stat.f_frsize;\n-    }\n-#else\n-    result = -1;\n-#endif\n-    return result;\n-}\n","filename":"src\/java.base\/unix\/native\/libnio\/ch\/FileDispatcherImpl.c","additions":0,"deletions":684,"binary":false,"changes":684,"status":"deleted"},{"patch":"@@ -0,0 +1,445 @@\n+\/*\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <sys\/mman.h>\n+#include <sys\/types.h>\n+#include <sys\/socket.h>\n+#include <fcntl.h>\n+#include <sys\/uio.h>\n+#include <unistd.h>\n+#include <sys\/stat.h>\n+#include <sys\/statvfs.h>\n+\n+#if defined(_ALLBSD_SOURCE)\n+#define lseek64 lseek\n+#define stat64 stat\n+#define flock64 flock\n+#define off64_t off_t\n+#define F_SETLKW64 F_SETLKW\n+#define F_SETLK64 F_SETLK\n+#define pread64 pread\n+#define pwrite64 pwrite\n+#define ftruncate64 ftruncate\n+#define fstat64 fstat\n+#define fdatasync fsync\n+#define mmap64 mmap\n+#define statvfs64 statvfs\n+#define fstatvfs64 fstatvfs\n+#endif\n+\n+#include \"jni.h\"\n+#include \"jni_util.h\"\n+#include \"jvm.h\"\n+#include \"jlong.h\"\n+#include \"nio.h\"\n+#include \"nio_util.h\"\n+#include \"sun_nio_ch_UnixFileDispatcherImpl.h\"\n+#include \"java_lang_Integer.h\"\n+#include \"java_lang_Long.h\"\n+#include <assert.h>\n+\n+static int preCloseFD = -1;     \/* File descriptor to which we dup other fd's\n+                                   before closing them for real *\/\n+\n+JNIEXPORT void JNICALL\n+Java_sun_nio_ch_UnixFileDispatcherImpl_init(JNIEnv *env, jclass cl)\n+{\n+    int sp[2];\n+    if (socketpair(PF_UNIX, SOCK_STREAM, 0, sp) < 0) {\n+        JNU_ThrowIOExceptionWithLastError(env, \"socketpair failed\");\n+        return;\n+    }\n+    preCloseFD = sp[0];\n+    close(sp[1]);\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_ch_UnixFileDispatcherImpl_read0(JNIEnv *env, jclass clazz,\n+                             jobject fdo, jlong address, jint len)\n+{\n+    jint fd = fdval(env, fdo);\n+    void *buf = (void *)jlong_to_ptr(address);\n+\n+    return convertReturnVal(env, read(fd, buf, len), JNI_TRUE);\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_ch_UnixFileDispatcherImpl_pread0(JNIEnv *env, jclass clazz, jobject fdo,\n+                            jlong address, jint len, jlong offset)\n+{\n+    jint fd = fdval(env, fdo);\n+    void *buf = (void *)jlong_to_ptr(address);\n+\n+    return convertReturnVal(env, pread64(fd, buf, len, offset), JNI_TRUE);\n+}\n+\n+JNIEXPORT jlong JNICALL\n+Java_sun_nio_ch_UnixFileDispatcherImpl_readv0(JNIEnv *env, jclass clazz,\n+                              jobject fdo, jlong address, jint len)\n+{\n+    jint fd = fdval(env, fdo);\n+    struct iovec *iov = (struct iovec *)jlong_to_ptr(address);\n+    return convertLongReturnVal(env, readv(fd, iov, len), JNI_TRUE);\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_ch_UnixFileDispatcherImpl_write0(JNIEnv *env, jclass clazz,\n+                              jobject fdo, jlong address, jint len)\n+{\n+    jint fd = fdval(env, fdo);\n+    void *buf = (void *)jlong_to_ptr(address);\n+\n+    return convertReturnVal(env, write(fd, buf, len), JNI_FALSE);\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_ch_UnixFileDispatcherImpl_pwrite0(JNIEnv *env, jclass clazz, jobject fdo,\n+                            jlong address, jint len, jlong offset)\n+{\n+    jint fd = fdval(env, fdo);\n+    void *buf = (void *)jlong_to_ptr(address);\n+\n+    return convertReturnVal(env, pwrite64(fd, buf, len, offset), JNI_FALSE);\n+}\n+\n+JNIEXPORT jlong JNICALL\n+Java_sun_nio_ch_UnixFileDispatcherImpl_writev0(JNIEnv *env, jclass clazz,\n+                                       jobject fdo, jlong address, jint len)\n+{\n+    jint fd = fdval(env, fdo);\n+    struct iovec *iov = (struct iovec *)jlong_to_ptr(address);\n+    return convertLongReturnVal(env, writev(fd, iov, len), JNI_FALSE);\n+}\n+\n+static jlong\n+handle(JNIEnv *env, jlong rv, char *msg)\n+{\n+    if (rv >= 0)\n+        return rv;\n+    if (errno == EINTR)\n+        return IOS_INTERRUPTED;\n+    JNU_ThrowIOExceptionWithLastError(env, msg);\n+    return IOS_THROWN;\n+}\n+\n+JNIEXPORT jlong JNICALL\n+Java_sun_nio_ch_UnixFileDispatcherImpl_seek0(JNIEnv *env, jclass clazz,\n+                                         jobject fdo, jlong offset)\n+{\n+    jint fd = fdval(env, fdo);\n+    off64_t result;\n+    if (offset < 0) {\n+        result = lseek64(fd, 0, SEEK_CUR);\n+    } else {\n+        result = lseek64(fd, offset, SEEK_SET);\n+    }\n+    return handle(env, (jlong)result, \"lseek64 failed\");\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_ch_UnixFileDispatcherImpl_force0(JNIEnv *env, jobject this,\n+                                          jobject fdo, jboolean md)\n+{\n+    jint fd = fdval(env, fdo);\n+    int result = 0;\n+\n+    if (md == JNI_FALSE) {\n+        result = fdatasync(fd);\n+    } else {\n+        result = fsync(fd);\n+    }\n+\n+    return handle(env, result, \"Force failed\");\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_ch_UnixFileDispatcherImpl_truncate0(JNIEnv *env, jobject this,\n+                                             jobject fdo, jlong size)\n+{\n+    return handle(env,\n+                  ftruncate64(fdval(env, fdo), size),\n+                  \"Truncation failed\");\n+}\n+\n+JNIEXPORT jlong JNICALL\n+Java_sun_nio_ch_UnixFileDispatcherImpl_size0(JNIEnv *env, jobject this, jobject fdo)\n+{\n+    jint fd = fdval(env, fdo);\n+    struct stat64 fbuf;\n+\n+    if (fstat64(fd, &fbuf) < 0)\n+        return handle(env, -1, \"Size failed\");\n+\n+#ifdef BLKGETSIZE64\n+    if (S_ISBLK(fbuf.st_mode)) {\n+        uint64_t size;\n+        if (ioctl(fd, BLKGETSIZE64, &size) < 0)\n+            return handle(env, -1, \"Size failed\");\n+        return (jlong)size;\n+    }\n+#endif\n+\n+    return fbuf.st_size;\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_ch_UnixFileDispatcherImpl_lock0(JNIEnv *env, jobject this, jobject fdo,\n+                                      jboolean block, jlong pos, jlong size,\n+                                      jboolean shared)\n+{\n+    jint fd = fdval(env, fdo);\n+    jint lockResult = 0;\n+    int cmd = 0;\n+    struct flock64 fl;\n+\n+    fl.l_whence = SEEK_SET;\n+    if (size == (jlong)java_lang_Long_MAX_VALUE) {\n+        fl.l_len = (off64_t)0;\n+    } else {\n+        fl.l_len = (off64_t)size;\n+    }\n+    fl.l_start = (off64_t)pos;\n+    if (shared == JNI_TRUE) {\n+        fl.l_type = F_RDLCK;\n+    } else {\n+        fl.l_type = F_WRLCK;\n+    }\n+    if (block == JNI_TRUE) {\n+        cmd = F_SETLKW64;\n+    } else {\n+        cmd = F_SETLK64;\n+    }\n+    lockResult = fcntl(fd, cmd, &fl);\n+    if (lockResult < 0) {\n+        if ((cmd == F_SETLK64) && (errno == EAGAIN || errno == EACCES))\n+            return sun_nio_ch_UnixFileDispatcherImpl_NO_LOCK;\n+        if (errno == EINTR)\n+            return sun_nio_ch_UnixFileDispatcherImpl_INTERRUPTED;\n+        JNU_ThrowIOExceptionWithLastError(env, \"Lock failed\");\n+    }\n+    return 0;\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_sun_nio_ch_UnixFileDispatcherImpl_release0(JNIEnv *env, jobject this,\n+                                         jobject fdo, jlong pos, jlong size)\n+{\n+    jint fd = fdval(env, fdo);\n+    jint lockResult = 0;\n+    struct flock64 fl;\n+    int cmd = F_SETLK64;\n+\n+    fl.l_whence = SEEK_SET;\n+    if (size == (jlong)java_lang_Long_MAX_VALUE) {\n+        fl.l_len = (off64_t)0;\n+    } else {\n+        fl.l_len = (off64_t)size;\n+    }\n+    fl.l_start = (off64_t)pos;\n+    fl.l_type = F_UNLCK;\n+    lockResult = fcntl(fd, cmd, &fl);\n+    if (lockResult < 0) {\n+        JNU_ThrowIOExceptionWithLastError(env, \"Release failed\");\n+    }\n+}\n+\n+\n+static void closeFileDescriptor(JNIEnv *env, int fd) {\n+    if (fd != -1) {\n+        int result = close(fd);\n+        if (result < 0)\n+            JNU_ThrowIOExceptionWithLastError(env, \"Close failed\");\n+    }\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_sun_nio_ch_UnixFileDispatcherImpl_close0(JNIEnv *env, jclass clazz, jobject fdo)\n+{\n+    jint fd = fdval(env, fdo);\n+    closeFileDescriptor(env, fd);\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_sun_nio_ch_UnixFileDispatcherImpl_preClose0(JNIEnv *env, jclass clazz, jobject fdo)\n+{\n+    jint fd = fdval(env, fdo);\n+    if (preCloseFD >= 0) {\n+        if (dup2(preCloseFD, fd) < 0)\n+            JNU_ThrowIOExceptionWithLastError(env, \"dup2 failed\");\n+    }\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_sun_nio_ch_UnixFileDispatcherImpl_dup0(JNIEnv *env, jobject this, jobject fdo1, jobject fdo2)\n+{\n+    if (dup2(fdval(env, fdo1), fdval(env, fdo2)) < 0) {\n+        JNU_ThrowIOExceptionWithLastError(env, \"dup2 failed\");\n+    }\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_sun_nio_ch_UnixFileDispatcherImpl_closeIntFD(JNIEnv *env, jclass clazz, jint fd)\n+{\n+    closeFileDescriptor(env, fd);\n+}\n+\n+JNIEXPORT jlong JNICALL\n+Java_sun_nio_ch_UnixFileDispatcherImpl_allocationGranularity0(JNIEnv *env, jclass klass)\n+{\n+    jlong pageSize = sysconf(_SC_PAGESIZE);\n+    return pageSize;\n+}\n+\n+JNIEXPORT jlong JNICALL\n+Java_sun_nio_ch_UnixFileDispatcherImpl_map0(JNIEnv *env, jclass klass, jobject fdo,\n+                                        jint prot, jlong off, jlong len,\n+                                        jboolean map_sync)\n+{\n+    void *mapAddress = 0;\n+    jint fd = fdval(env, fdo);\n+    int protections = 0;\n+    int flags = 0;\n+\n+    \/\/ should never be called with map_sync and prot == PRIVATE\n+    assert((prot != sun_nio_ch_UnixFileDispatcherImpl_MAP_PV) || !map_sync);\n+\n+    if (prot == sun_nio_ch_UnixFileDispatcherImpl_MAP_RO) {\n+        protections = PROT_READ;\n+        flags = MAP_SHARED;\n+    } else if (prot == sun_nio_ch_UnixFileDispatcherImpl_MAP_RW) {\n+        protections = PROT_WRITE | PROT_READ;\n+        flags = MAP_SHARED;\n+    } else if (prot == sun_nio_ch_UnixFileDispatcherImpl_MAP_PV) {\n+        protections =  PROT_WRITE | PROT_READ;\n+        flags = MAP_PRIVATE;\n+    }\n+\n+    \/\/ if MAP_SYNC and MAP_SHARED_VALIDATE are not defined then it is\n+    \/\/ best to define them here. This ensures the code compiles on old\n+    \/\/ OS releases which do not provide the relevant headers. If run\n+    \/\/ on the same machine then it will work if the kernel contains\n+    \/\/ the necessary support otherwise mmap should fail with an\n+    \/\/ invalid argument error\n+\n+#ifndef MAP_SYNC\n+#define MAP_SYNC 0x80000\n+#endif\n+#ifndef MAP_SHARED_VALIDATE\n+#define MAP_SHARED_VALIDATE 0x03\n+#endif\n+\n+    if (map_sync) {\n+        \/\/ ensure\n+        \/\/  1) this is Linux on AArch64, x86_64, or PPC64 LE\n+        \/\/  2) the mmap APIs are available at compile time\n+#if !defined(LINUX) || ! (defined(aarch64) || (defined(amd64) && defined(_LP64)) || defined(ppc64le))\n+        \/\/ TODO - implement for solaris\/AIX\/BSD\/WINDOWS and for 32 bit\n+        JNU_ThrowInternalError(env, \"should never call map on platform where MAP_SYNC is unimplemented\");\n+        return IOS_THROWN;\n+#else\n+        flags |= MAP_SYNC | MAP_SHARED_VALIDATE;\n+#endif\n+    }\n+\n+    mapAddress = mmap64(\n+        0,                    \/* Let OS decide location *\/\n+        len,                  \/* Number of bytes to map *\/\n+        protections,          \/* File permissions *\/\n+        flags,                \/* Changes are shared *\/\n+        fd,                   \/* File descriptor of mapped file *\/\n+        off);                 \/* Offset into file *\/\n+\n+    if (mapAddress == MAP_FAILED) {\n+        if (map_sync && errno == ENOTSUP) {\n+            JNU_ThrowIOExceptionWithLastError(env, \"map with mode MAP_SYNC unsupported\");\n+            return IOS_THROWN;\n+        }\n+\n+        if (errno == ENOMEM) {\n+            JNU_ThrowOutOfMemoryError(env, \"Map failed\");\n+            return IOS_THROWN;\n+        }\n+        return handle(env, -1, \"Map failed\");\n+    }\n+\n+    return ((jlong) (unsigned long) mapAddress);\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_ch_UnixFileDispatcherImpl_unmap0(JNIEnv *env, jclass klass,\n+                                          jlong address, jlong len)\n+{\n+    void *a = (void *)jlong_to_ptr(address);\n+    return handle(env,\n+                  munmap(a, (size_t)len),\n+                  \"Unmap failed\");\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_ch_UnixFileDispatcherImpl_setDirect0(JNIEnv *env, jclass clazz,\n+                                              jobject fdo)\n+{\n+    jint fd = fdval(env, fdo);\n+    jint result;\n+    struct statvfs64 file_stat;\n+\n+#if defined(O_DIRECT) || defined(F_NOCACHE) || defined(DIRECTIO_ON)\n+#ifdef O_DIRECT\n+    jint orig_flag;\n+    orig_flag = fcntl(fd, F_GETFL);\n+    if (orig_flag == -1) {\n+        JNU_ThrowIOExceptionWithLastError(env, \"DirectIO setup failed\");\n+        return -1;\n+    }\n+    result = fcntl(fd, F_SETFL, orig_flag | O_DIRECT);\n+    if (result == -1) {\n+        JNU_ThrowIOExceptionWithLastError(env, \"DirectIO setup failed\");\n+        return result;\n+    }\n+#elif defined(F_NOCACHE)\n+    result = fcntl(fd, F_NOCACHE, 1);\n+    if (result == -1) {\n+        JNU_ThrowIOExceptionWithLastError(env, \"DirectIO setup failed\");\n+        return result;\n+    }\n+#elif defined(DIRECTIO_ON)\n+    result = directio(fd, DIRECTIO_ON);\n+    if (result == -1) {\n+        JNU_ThrowIOExceptionWithLastError(env, \"DirectIO setup failed\");\n+        return result;\n+    }\n+#endif\n+    result = fstatvfs64(fd, &file_stat);\n+    if(result == -1) {\n+        JNU_ThrowIOExceptionWithLastError(env, \"DirectIO setup failed\");\n+        return result;\n+    } else {\n+        result = (int)file_stat.f_frsize;\n+    }\n+#else\n+    result = -1;\n+#endif\n+    return result;\n+}\n","filename":"src\/java.base\/unix\/native\/libnio\/ch\/UnixFileDispatcherImpl.c","additions":445,"deletions":0,"binary":false,"changes":445,"status":"added"}]}