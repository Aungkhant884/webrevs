{"files":[{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.nio.ch;\n+\n+import java.io.FileDescriptor;\n+import java.nio.channels.FileChannel;\n+\n+public class FileChannelImpl extends UnixFileChannelImpl {\n+    private FileChannelImpl(FileDescriptor fd, String path, boolean readable,\n+                            boolean writable, boolean direct, Object parent)\n+    {\n+        super(fd, path, readable, writable, direct, parent);\n+    }\n+\n+    \/\/ Used by FileInputStream::getChannel, FileOutputStream::getChannel,\n+    \/\/ and RandomAccessFile::getChannel\n+    public static FileChannel open(FileDescriptor fd, String path,\n+                                   boolean readable, boolean writable,\n+                                   boolean direct, Object parent)\n+    {\n+        return new FileChannelImpl(fd, path, readable, writable, direct, parent);\n+    }\n+\n+    protected long transferTo(FileDescriptor src, long position,\n+                              long count, FileDescriptor dst,\n+                              boolean append)\n+    {\n+        return transferTo0(src, position, count, dst, append);\n+    }\n+\n+    \/\/ --- native methods ---\n+\n+    private static native long transferTo0(FileDescriptor src, long position,\n+                                           long count, FileDescriptor dst,\n+                                           boolean append);\n+}\n","filename":"src\/java.base\/aix\/classes\/sun\/nio\/ch\/FileChannelImpl.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <sys\/mman.h>\n+#include <sys\/stat.h>\n+#include <fcntl.h>\n+#include <sys\/types.h>\n+#include <unistd.h>\n+\n+#include <string.h>\n+#include <sys\/socket.h>\n+\n+#include \"jni.h\"\n+#include \"jni_util.h\"\n+#include \"jlong.h\"\n+#include \"nio.h\"\n+#include \"nio_util.h\"\n+#include \"java_lang_Integer.h\"\n+#include <assert.h>\n+\n+JNIEXPORT jlong JNICALL\n+Java_sun_nio_ch_AbstractFileChannelImpl_transferTo0(JNIEnv *env, jobject this,\n+                                                    jobject srcFDO,\n+                                                    jlong position, jlong count,\n+                                                    jobject dstFDO, jboolean append)\n+{\n+    jint srcFD = fdval(env, srcFDO);\n+    jint dstFD = fdval(env, dstFDO);\n+\n+    jlong max = (jlong)java_lang_Integer_MAX_VALUE;\n+    struct sf_parms sf_iobuf;\n+    jlong result;\n+\n+    if (position > max)\n+        return IOS_UNSUPPORTED_CASE;\n+\n+    if (count > max)\n+        count = max;\n+\n+    memset(&sf_iobuf, 0, sizeof(sf_iobuf));\n+    sf_iobuf.file_descriptor = srcFD;\n+    sf_iobuf.file_offset = (off_t)position;\n+    sf_iobuf.file_bytes = count;\n+\n+    result = send_file(&dstFD, &sf_iobuf, SF_SYNC_CACHE);\n+\n+    \/* AIX send_file() will return 0 when this operation complete successfully,\n+     * return 1 when partial bytes transferred and return -1 when an error has\n+     * occurred.\n+     *\/\n+    if (result == -1) {\n+        if (errno == EWOULDBLOCK)\n+            return IOS_UNAVAILABLE;\n+        if ((errno == EINVAL) && ((ssize_t)count >= 0))\n+            return IOS_UNSUPPORTED_CASE;\n+        if (errno == EINTR)\n+            return IOS_INTERRUPTED;\n+        if (errno == ENOTSOCK)\n+            return IOS_UNSUPPORTED;\n+        JNU_ThrowIOExceptionWithLastError(env, \"Transfer failed\");\n+        return IOS_THROWN;\n+    }\n+\n+    if (sf_iobuf.bytes_sent > 0)\n+        return (jlong)sf_iobuf.bytes_sent;\n+\n+    return IOS_UNSUPPORTED_CASE;\n+}\n","filename":"src\/java.base\/aix\/native\/libnio\/ch\/FileChannelImpl.c","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.nio.ch;\n+\n+import java.io.FileDescriptor;\n+import java.nio.channels.FileChannel;\n+\n+public class FileChannelImpl extends UnixFileChannelImpl {\n+    private FileChannelImpl(FileDescriptor fd, String path, boolean readable,\n+                            boolean writable, boolean direct, Object parent)\n+    {\n+        super(fd, path, readable, writable, direct, parent);\n+    }\n+\n+    \/\/ Used by FileInputStream::getChannel, FileOutputStream::getChannel,\n+    \/\/ and RandomAccessFile::getChannel\n+    public static FileChannel open(FileDescriptor fd, String path,\n+                                   boolean readable, boolean writable,\n+                                   boolean direct, Object parent)\n+    {\n+        return new FileChannelImpl(fd, path, readable, writable, direct, parent);\n+    }\n+\n+    protected int maxDirectTransferSize() {\n+        return 0x7ffff000; \/\/ 2,147,479,552 maximum for sendfile()\n+    }\n+\n+    protected long transferFrom(FileDescriptor src,\n+                                FileDescriptor dst,\n+                                long position, long count,\n+                                boolean append)\n+    {\n+        return transferFrom0(src, dst, position, count, append);\n+    }\n+\n+    protected long transferTo(FileDescriptor src, long position,\n+                              long count, FileDescriptor dst,\n+                              boolean append)\n+    {\n+        return transferTo0(src, position, count, dst, append);\n+    }\n+\n+    \/\/ --- native methods ---\n+\n+    private static native long transferFrom0(FileDescriptor src,\n+                                             FileDescriptor dst,\n+                                             long position, long count,\n+                                             boolean append);\n+\n+    private static native long transferTo0(FileDescriptor src, long position,\n+                                           long count, FileDescriptor dst,\n+                                           boolean append);\n+\n+    private static native void init0();\n+\n+    static {\n+        init0();\n+    }\n+}\n","filename":"src\/java.base\/linux\/classes\/sun\/nio\/ch\/FileChannelImpl.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -0,0 +1,132 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <unistd.h>\n+\n+#include <sys\/sendfile.h>\n+#include <dlfcn.h>\n+\n+#include \"jni.h\"\n+#include \"jni_util.h\"\n+#include \"nio.h\"\n+#include \"nio_util.h\"\n+\n+typedef ssize_t copy_file_range_func(int, loff_t*, int, loff_t*, size_t,\n+                                     unsigned int);\n+static copy_file_range_func* my_copy_file_range_func = NULL;\n+\n+JNIEXPORT void JNICALL\n+Java_sun_nio_ch_FileChannelImpl_init0(JNIEnv *env, jclass klass)\n+{\n+    my_copy_file_range_func =\n+        (copy_file_range_func*) dlsym(RTLD_DEFAULT, \"copy_file_range\");\n+}\n+\n+JNIEXPORT jlong JNICALL\n+Java_sun_nio_ch_FileChannelImpl_transferFrom0(JNIEnv *env, jobject this,\n+                                              jobject srcFDO, jobject dstFDO,\n+                                              jlong position, jlong count,\n+                                              jboolean append)\n+{\n+    if (my_copy_file_range_func == NULL)\n+        return IOS_UNSUPPORTED;\n+    \/\/ copy_file_range fails with EBADF when appending\n+    if (append == JNI_TRUE)\n+        return IOS_UNSUPPORTED_CASE;\n+\n+    jint srcFD = fdval(env, srcFDO);\n+    jint dstFD = fdval(env, dstFDO);\n+\n+    off64_t offset = (off64_t)position;\n+    size_t len = (size_t)count;\n+    jlong n = my_copy_file_range_func(srcFD, NULL, dstFD, &offset, len, 0);\n+    if (n < 0) {\n+        if (errno == EAGAIN)\n+            return IOS_UNAVAILABLE;\n+        if (errno == ENOSYS)\n+            return IOS_UNSUPPORTED_CASE;\n+        if ((errno == EBADF || errno == EINVAL || errno == EXDEV) &&\n+            ((ssize_t)count >= 0))\n+            return IOS_UNSUPPORTED_CASE;\n+        if (errno == EINTR) {\n+            return IOS_INTERRUPTED;\n+        }\n+        JNU_ThrowIOExceptionWithLastError(env, \"Transfer failed\");\n+        return IOS_THROWN;\n+    }\n+    return n;\n+}\n+\n+JNIEXPORT jlong JNICALL\n+Java_sun_nio_ch_FileChannelImpl_transferTo0(JNIEnv *env, jobject this,\n+                                            jobject srcFDO,\n+                                            jlong position, jlong count,\n+                                            jobject dstFDO, jboolean append)\n+{\n+    jint srcFD = fdval(env, srcFDO);\n+    jint dstFD = fdval(env, dstFDO);\n+\n+    \/\/ copy_file_range fails with EBADF when appending, and sendfile\n+    \/\/ fails with EINVAL\n+    if (append == JNI_TRUE)\n+        return IOS_UNSUPPORTED_CASE;\n+\n+    off64_t offset = (off64_t)position;\n+    jlong n;\n+    if (my_copy_file_range_func != NULL) {\n+        size_t len = (size_t)count;\n+        n = my_copy_file_range_func(srcFD, &offset, dstFD, NULL, len, 0);\n+        if (n < 0) {\n+            switch (errno) {\n+                case EINTR:\n+                    return IOS_INTERRUPTED;\n+                case EINVAL:\n+                case ENOSYS:\n+                case EXDEV:\n+                    \/\/ ignore and try sendfile()\n+                    break;\n+                default:\n+                    JNU_ThrowIOExceptionWithLastError(env, \"Copy failed\");\n+                    return IOS_THROWN;\n+            }\n+        }\n+        if (n >= 0)\n+            return n;\n+    }\n+\n+    n = sendfile64(dstFD, srcFD, &offset, (size_t)count);\n+    if (n < 0) {\n+        if (errno == EAGAIN)\n+            return IOS_UNAVAILABLE;\n+        if ((errno == EINVAL) && ((ssize_t)count >= 0))\n+            return IOS_UNSUPPORTED_CASE;\n+        if (errno == EINTR) {\n+            return IOS_INTERRUPTED;\n+        }\n+        JNU_ThrowIOExceptionWithLastError(env, \"Transfer failed\");\n+        return IOS_THROWN;\n+    }\n+    return n;\n+}\n","filename":"src\/java.base\/linux\/native\/libnio\/ch\/FileChannelImpl.c","additions":132,"deletions":0,"binary":false,"changes":132,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.nio.ch;\n+\n+import java.io.FileDescriptor;\n+import java.nio.channels.FileChannel;\n+\n+public class FileChannelImpl extends UnixFileChannelImpl {\n+    private FileChannelImpl(FileDescriptor fd, String path, boolean readable,\n+                            boolean writable, boolean direct, Object parent)\n+    {\n+        super(fd, path, readable, writable, direct, parent);\n+    }\n+\n+    \/\/ Used by FileInputStream::getChannel, FileOutputStream::getChannel,\n+    \/\/ and RandomAccessFile::getChannel\n+    public static FileChannel open(FileDescriptor fd, String path,\n+                                   boolean readable, boolean writable,\n+                                   boolean direct, Object parent)\n+    {\n+        return new FileChannelImpl(fd, path, readable, writable, direct, parent);\n+    }\n+\n+    protected long transferTo(FileDescriptor src, long position,\n+                              long count, FileDescriptor dst,\n+                              boolean append)\n+    {\n+        return transferTo0(src, position, count, dst, append);\n+    }\n+\n+    \/\/ --- native methods ---\n+\n+    private static native long transferTo0(FileDescriptor src, long position,\n+                                           long count, FileDescriptor dst,\n+                                           boolean append);\n+}\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/ch\/FileChannelImpl.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <sys\/types.h>\n+#include <sys\/socket.h>\n+#include <sys\/uio.h>\n+\n+#include \"jni.h\"\n+#include \"nio.h\"\n+#include \"nio_util.h\"\n+#include \"sun_nio_ch_FileChannelImpl.h\"\n+\n+JNIEXPORT jlong JNICALL\n+Java_sun_nio_ch_FileChannelImpl_transferTo0(JNIEnv *env, jobject this,\n+                                            jobject srcFDO,\n+                                            jlong position, jlong count,\n+                                            jobject dstFDO, jboolean append)\n+{\n+    jint srcFD = fdval(env, srcFDO);\n+    jint dstFD = fdval(env, dstFDO);\n+\n+    off_t numBytes;\n+    int result;\n+\n+    numBytes = count;\n+\n+    result = sendfile(srcFD, dstFD, position, &numBytes, NULL, 0);\n+\n+    if (numBytes > 0)\n+        return numBytes;\n+\n+    if (result == -1) {\n+        if (errno == EAGAIN)\n+            return IOS_UNAVAILABLE;\n+        if (errno == EOPNOTSUPP || errno == ENOTSOCK || errno == ENOTCONN)\n+            return IOS_UNSUPPORTED_CASE;\n+        if ((errno == EINVAL) && ((ssize_t)count >= 0))\n+            return IOS_UNSUPPORTED_CASE;\n+        if (errno == EINTR)\n+            return IOS_INTERRUPTED;\n+        JNU_ThrowIOExceptionWithLastError(env, \"Transfer failed\");\n+        return IOS_THROWN;\n+    }\n+\n+    return result;\n+}\n","filename":"src\/java.base\/macosx\/native\/libnio\/ch\/FileChannelImpl.c","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,0 +48,1 @@\n+import java.util.function.BiFunction;\n@@ -64,1 +65,1 @@\n-public class FileChannelImpl\n+public abstract class AbstractFileChannelImpl\n@@ -67,3 +68,0 @@\n-    \/\/ Memory allocation size for mapping buffers\n-    private static final long allocationGranularity;\n-\n@@ -74,3 +72,0 @@\n-    \/\/ Maximum direct transfer size\n-    private static final int MAX_DIRECT_TRANSFER_SIZE;\n-\n@@ -112,0 +107,3 @@\n+    \/\/ Removes an existing mapping\n+    private final BiFunction<Long,Long,Integer> unmapFunction;\n+\n@@ -129,2 +127,4 @@\n-    private FileChannelImpl(FileDescriptor fd, String path, boolean readable,\n-                            boolean writable, boolean direct, Object parent)\n+    protected AbstractFileChannelImpl(FileDescriptor fd, String path,\n+                                      boolean readable, boolean writable,\n+                                      boolean direct, Object parent,\n+                                      BiFunction<Long,Long,Integer> unmapFunc)\n@@ -133,0 +133,1 @@\n+        this.path = path;\n@@ -135,2 +136,0 @@\n-        this.parent = parent;\n-        this.path = path;\n@@ -138,0 +137,2 @@\n+        this.parent = parent;\n+        this.unmapFunction = unmapFunc;\n@@ -154,9 +155,0 @@\n-    \/\/ Used by FileInputStream.getChannel(), FileOutputStream.getChannel\n-    \/\/ and RandomAccessFile.getChannel()\n-    public static FileChannel open(FileDescriptor fd, String path,\n-                                   boolean readable, boolean writable,\n-                                   boolean direct, Object parent)\n-    {\n-        return new FileChannelImpl(fd, path, readable, writable, direct, parent);\n-    }\n-\n@@ -558,0 +550,7 @@\n+    \/\/ Always returns UNSUPPORTED\n+    protected long transferTo(FileDescriptor src, long position, long count,\n+                              FileDescriptor dst, boolean append)\n+    {\n+        return IOStatus.UNSUPPORTED;\n+    }\n+\n@@ -577,1 +576,1 @@\n-                    n = transferTo0(fd, position, icount, targetFD, append);\n+                    n = transferTo(fd, position, icount, targetFD, append);\n@@ -612,1 +611,1 @@\n-            targetFD = ((FileChannelImpl)target).fd;\n+            targetFD = ((AbstractFileChannelImpl)target).fd;\n@@ -760,1 +759,1 @@\n-            !((FileChannelImpl)target).writable)\n+            !((AbstractFileChannelImpl)target).writable)\n@@ -773,1 +772,1 @@\n-        int icount = (int)Math.min(count, MAX_DIRECT_TRANSFER_SIZE);\n+        int icount = (int)Math.min(count, maxDirectTransferSize());\n@@ -791,0 +790,9 @@\n+    \/\/ Always returns UNSUPPORTED\n+    protected long transferFrom(FileDescriptor src,\n+                                FileDescriptor dst,\n+                                long position, long count,\n+                                boolean append)\n+    {\n+        return IOStatus.UNSUPPORTED;\n+    }\n+\n@@ -806,1 +814,1 @@\n-                    n = transferFrom0(srcFD, fd, position, count, append);\n+                    n = transferFrom(srcFD, fd, position, count, append);\n@@ -827,1 +835,1 @@\n-        if (!src.readable)\n+        if (!((AbstractFileChannelImpl)src).readable)\n@@ -831,1 +839,1 @@\n-        FileDescriptor srcFD = src.fd;\n+        FileDescriptor srcFD = ((AbstractFileChannelImpl)src).fd;\n@@ -842,1 +850,1 @@\n-        if (!src.readable)\n+        if (!((AbstractFileChannelImpl)src).readable)\n@@ -847,1 +855,1 @@\n-        synchronized (src.positionLock) {\n+        synchronized (((AbstractFileChannelImpl)src).positionLock) {\n@@ -1049,0 +1057,1 @@\n+        private final BiFunction<Long,Long,Integer> unmapFunction;\n@@ -1051,1 +1060,2 @@\n-                         FileDescriptor fd, int pagePosition)\n+                         FileDescriptor fd, int pagePosition,\n+                         BiFunction<Long,Long,Integer> unmapFunction)\n@@ -1059,0 +1069,1 @@\n+            this.unmapFunction = unmapFunction;\n@@ -1083,1 +1094,1 @@\n-            unmap0(address, size);\n+            unmapFunction.apply(address, size);\n@@ -1109,2 +1120,3 @@\n-                               FileDescriptor fd, int pagePosition) {\n-            super(address, size, cap, fd, pagePosition);\n+                               FileDescriptor fd, int pagePosition,\n+                               BiFunction<Long,Long,Integer> unmapFunction) {\n+            super(address, size, cap, fd, pagePosition, unmapFunction);\n@@ -1142,2 +1154,3 @@\n-                            FileDescriptor fd, int pagePosition) {\n-            super(address, size, cap, fd, pagePosition);\n+                            FileDescriptor fd, int pagePosition,\n+                            BiFunction<Long,Long,Integer> unmapFunction) {\n+            super(address, size, cap, fd, pagePosition, unmapFunction);\n@@ -1302,1 +1315,1 @@\n-                pagePosition = (int)(position % allocationGranularity);\n+                pagePosition = (int)(position % allocationGranularity());\n@@ -1306,2 +1319,2 @@\n-                    \/\/ If map0 did not throw an exception, the address is valid\n-                    addr = map0(fd, prot, mapPosition, mapSize, isSync);\n+                    \/\/ If map did not throw an exception, the address is valid\n+                    addr = map(fd, prot, mapPosition, mapSize, isSync);\n@@ -1318,1 +1331,1 @@\n-                        addr = map0(fd, prot, mapPosition, mapSize, isSync);\n+                        addr = map(fd, prot, mapPosition, mapSize, isSync);\n@@ -1332,1 +1345,1 @@\n-                unmap0(addr, mapSize);\n+                unmapFunction.apply(addr, mapSize);\n@@ -1337,1 +1350,1 @@\n-            assert (addr % allocationGranularity == 0);\n+            assert (addr % allocationGranularity() == 0);\n@@ -1339,2 +1352,2 @@\n-                           ? new SyncUnmapper(addr, mapSize, size, mfd, pagePosition)\n-                           : new DefaultUnmapper(addr, mapSize, size, mfd, pagePosition));\n+                ? new SyncUnmapper(addr, mapSize, size, mfd, pagePosition, unmapFunction)\n+                : new DefaultUnmapper(addr, mapSize, size, mfd, pagePosition, unmapFunction));\n@@ -1565,21 +1578,0 @@\n-    \/\/ -- Native methods --\n-\n-    \/\/ Creates a new mapping\n-    private native long map0(FileDescriptor fd, int prot, long position,\n-                             long length, boolean isSync)\n-        throws IOException;\n-\n-    \/\/ Removes an existing mapping\n-    private static native int unmap0(long address, long length);\n-\n-    \/\/ Transfers from src to dst, or returns IOStatus.UNSUPPORTED (-4) or\n-    \/\/ IOStatus.UNSUPPORTED_CASE (-6) if the kernel does not support it\n-    private static native long transferTo0(FileDescriptor src, long position,\n-                                           long count, FileDescriptor dst,\n-                                           boolean append);\n-\n-    private static native long transferFrom0(FileDescriptor src,\n-                                             FileDescriptor dst,\n-                                             long position, long count,\n-                                             boolean append);\n-\n@@ -1587,1 +1579,3 @@\n-    private static native int maxDirectTransferSize0();\n+    protected int maxDirectTransferSize() {\n+        return Integer.MAX_VALUE;\n+    }\n@@ -1590,1 +1584,6 @@\n-    private static native long allocationGranularity0();\n+    protected abstract long allocationGranularity();\n+\n+    \/\/ Creates a new mapping\n+    protected abstract long map(FileDescriptor fd, int prot, long position,\n+                                long length, boolean isSync)\n+        throws IOException;\n@@ -1594,2 +1593,0 @@\n-        allocationGranularity = allocationGranularity0();\n-        MAX_DIRECT_TRANSFER_SIZE = maxDirectTransferSize0();\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/AbstractFileChannelImpl.java","additions":66,"deletions":69,"binary":false,"changes":135,"previous_filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/FileChannelImpl.java","status":"renamed"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.nio.ch;\n+\n+import java.io.FileDescriptor;\n+import java.io.IOException;\n+import java.nio.channels.FileChannel;\n+import java.util.function.BiFunction;\n+\n+public class UnixFileChannelImpl extends AbstractFileChannelImpl {\n+    private static final long ALLOCATION_GRANULARITY;\n+    private static final BiFunction<Long,Long,Integer> unmapFunction;\n+\n+    static {\n+        ALLOCATION_GRANULARITY = allocationGranularity0();\n+\n+        \/\/ initialize function for removing a mapping\n+        unmapFunction = (addr, len) -> unmap(addr, len);\n+    }\n+\n+    protected UnixFileChannelImpl(FileDescriptor fd, String path,\n+                                  boolean readable, boolean writable,\n+                                  boolean direct, Object parent)\n+    {\n+        super(fd, path, readable, writable, direct, parent, unmapFunction);\n+    }\n+\n+    protected long allocationGranularity() {\n+        return ALLOCATION_GRANULARITY;\n+    }\n+\n+    \/\/ Creates a new mapping\n+    protected long map(FileDescriptor fd, int prot, long position,\n+                       long length, boolean isSync)\n+        throws IOException\n+    {\n+        return map0(fd, prot, position, length, isSync);\n+    }\n+\n+    \/\/ Removes an existing mapping\n+    static int unmap(long address, long length) {\n+        return unmap0(address, length);\n+    }\n+\n+    \/\/ --- native methods ---\n+\n+    \/\/ Retrieves allocation granularity\n+    private static native long allocationGranularity0();\n+\n+    \/\/ Creates a new mapping\n+    private static native long map0(FileDescriptor fd, int prot, long position,\n+                                    long length, boolean isSync)\n+        throws IOException;\n+\n+    \/\/ Removes an existing mapping\n+    private static native int unmap0(long address, long length);\n+}\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/ch\/UnixFileChannelImpl.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -1,336 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <sys\/mman.h>\n-#include <sys\/stat.h>\n-#include <fcntl.h>\n-#include <sys\/types.h>\n-#include <unistd.h>\n-\n-#if defined(__linux__)\n-#include <sys\/sendfile.h>\n-#include <dlfcn.h>\n-#elif defined(_AIX)\n-#include <string.h>\n-#include <sys\/socket.h>\n-#elif defined(_ALLBSD_SOURCE)\n-#include <sys\/socket.h>\n-#include <sys\/uio.h>\n-#define lseek64 lseek\n-#define mmap64 mmap\n-#endif\n-\n-#include \"jni.h\"\n-#include \"jni_util.h\"\n-#include \"jlong.h\"\n-#include \"nio.h\"\n-#include \"nio_util.h\"\n-#include \"sun_nio_ch_FileChannelImpl.h\"\n-#include \"java_lang_Integer.h\"\n-#include <assert.h>\n-\n-#if defined(__linux__)\n-typedef ssize_t copy_file_range_func(int, loff_t*, int, loff_t*, size_t,\n-                                     unsigned int);\n-static copy_file_range_func* my_copy_file_range_func = NULL;\n-#endif\n-\n-JNIEXPORT jlong JNICALL\n-Java_sun_nio_ch_FileChannelImpl_allocationGranularity0(JNIEnv *env, jclass clazz)\n-{\n-    jlong pageSize = sysconf(_SC_PAGESIZE);\n-#if defined(__linux__)\n-    my_copy_file_range_func =\n-        (copy_file_range_func*) dlsym(RTLD_DEFAULT, \"copy_file_range\");\n-#endif\n-    return pageSize;\n-}\n-\n-static jlong\n-handle(JNIEnv *env, jlong rv, char *msg)\n-{\n-    if (rv >= 0)\n-        return rv;\n-    if (errno == EINTR)\n-        return IOS_INTERRUPTED;\n-    JNU_ThrowIOExceptionWithLastError(env, msg);\n-    return IOS_THROWN;\n-}\n-\n-\n-JNIEXPORT jlong JNICALL\n-Java_sun_nio_ch_FileChannelImpl_map0(JNIEnv *env, jobject this, jobject fdo,\n-                                     jint prot, jlong off, jlong len, jboolean map_sync)\n-{\n-    void *mapAddress = 0;\n-    jint fd = fdval(env, fdo);\n-    int protections = 0;\n-    int flags = 0;\n-\n-    \/\/ should never be called with map_sync and prot == PRIVATE\n-    assert((prot != sun_nio_ch_FileChannelImpl_MAP_PV) || !map_sync);\n-\n-    if (prot == sun_nio_ch_FileChannelImpl_MAP_RO) {\n-        protections = PROT_READ;\n-        flags = MAP_SHARED;\n-    } else if (prot == sun_nio_ch_FileChannelImpl_MAP_RW) {\n-        protections = PROT_WRITE | PROT_READ;\n-        flags = MAP_SHARED;\n-    } else if (prot == sun_nio_ch_FileChannelImpl_MAP_PV) {\n-        protections =  PROT_WRITE | PROT_READ;\n-        flags = MAP_PRIVATE;\n-    }\n-\n-    \/\/ if MAP_SYNC and MAP_SHARED_VALIDATE are not defined then it is\n-    \/\/ best to define them here. This ensures the code compiles on old\n-    \/\/ OS releases which do not provide the relevant headers. If run\n-    \/\/ on the same machine then it will work if the kernel contains\n-    \/\/ the necessary support otherwise mmap should fail with an\n-    \/\/ invalid argument error\n-\n-#ifndef MAP_SYNC\n-#define MAP_SYNC 0x80000\n-#endif\n-#ifndef MAP_SHARED_VALIDATE\n-#define MAP_SHARED_VALIDATE 0x03\n-#endif\n-\n-    if (map_sync) {\n-        \/\/ ensure\n-        \/\/  1) this is Linux on AArch64, x86_64, or PPC64 LE\n-        \/\/  2) the mmap APIs are available at compile time\n-#if !defined(LINUX) || ! (defined(aarch64) || (defined(amd64) && defined(_LP64)) || defined(ppc64le))\n-        \/\/ TODO - implement for solaris\/AIX\/BSD\/WINDOWS and for 32 bit\n-        JNU_ThrowInternalError(env, \"should never call map on platform where MAP_SYNC is unimplemented\");\n-        return IOS_THROWN;\n-#else\n-        flags |= MAP_SYNC | MAP_SHARED_VALIDATE;\n-#endif\n-    }\n-\n-    mapAddress = mmap64(\n-        0,                    \/* Let OS decide location *\/\n-        len,                  \/* Number of bytes to map *\/\n-        protections,          \/* File permissions *\/\n-        flags,                \/* Changes are shared *\/\n-        fd,                   \/* File descriptor of mapped file *\/\n-        off);                 \/* Offset into file *\/\n-\n-    if (mapAddress == MAP_FAILED) {\n-        if (map_sync && errno == ENOTSUP) {\n-            JNU_ThrowIOExceptionWithLastError(env, \"map with mode MAP_SYNC unsupported\");\n-            return IOS_THROWN;\n-        }\n-\n-        if (errno == ENOMEM) {\n-            JNU_ThrowOutOfMemoryError(env, \"Map failed\");\n-            return IOS_THROWN;\n-        }\n-        return handle(env, -1, \"Map failed\");\n-    }\n-\n-    return ((jlong) (unsigned long) mapAddress);\n-}\n-\n-\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_ch_FileChannelImpl_unmap0(JNIEnv *env, jobject this,\n-                                       jlong address, jlong len)\n-{\n-    void *a = (void *)jlong_to_ptr(address);\n-    return handle(env,\n-                  munmap(a, (size_t)len),\n-                  \"Unmap failed\");\n-}\n-\n-JNIEXPORT jlong JNICALL\n-Java_sun_nio_ch_FileChannelImpl_transferTo0(JNIEnv *env, jobject this,\n-                                            jobject srcFDO,\n-                                            jlong position, jlong count,\n-                                            jobject dstFDO, jboolean append)\n-{\n-    jint srcFD = fdval(env, srcFDO);\n-    jint dstFD = fdval(env, dstFDO);\n-\n-#if defined(__linux__)\n-    \/\/ copy_file_range fails with EBADF when appending, and sendfile\n-    \/\/ fails with EINVAL\n-    if (append == JNI_TRUE)\n-        return IOS_UNSUPPORTED_CASE;\n-\n-    off64_t offset = (off64_t)position;\n-    jlong n;\n-    if (my_copy_file_range_func != NULL) {\n-        size_t len = (size_t)count;\n-        n = my_copy_file_range_func(srcFD, &offset, dstFD, NULL, len, 0);\n-        if (n < 0) {\n-            switch (errno) {\n-                case EINTR:\n-                    return IOS_INTERRUPTED;\n-                case EINVAL:\n-                case ENOSYS:\n-                case EXDEV:\n-                    \/\/ ignore and try sendfile()\n-                    break;\n-                default:\n-                    JNU_ThrowIOExceptionWithLastError(env, \"Copy failed\");\n-                    return IOS_THROWN;\n-            }\n-        }\n-        if (n >= 0)\n-            return n;\n-    }\n-\n-    n = sendfile64(dstFD, srcFD, &offset, (size_t)count);\n-    if (n < 0) {\n-        if (errno == EAGAIN)\n-            return IOS_UNAVAILABLE;\n-        if ((errno == EINVAL) && ((ssize_t)count >= 0))\n-            return IOS_UNSUPPORTED_CASE;\n-        if (errno == EINTR) {\n-            return IOS_INTERRUPTED;\n-        }\n-        JNU_ThrowIOExceptionWithLastError(env, \"Transfer failed\");\n-        return IOS_THROWN;\n-    }\n-    return n;\n-#elif defined(__APPLE__)\n-    off_t numBytes;\n-    int result;\n-\n-    numBytes = count;\n-\n-    result = sendfile(srcFD, dstFD, position, &numBytes, NULL, 0);\n-\n-    if (numBytes > 0)\n-        return numBytes;\n-\n-    if (result == -1) {\n-        if (errno == EAGAIN)\n-            return IOS_UNAVAILABLE;\n-        if (errno == EOPNOTSUPP || errno == ENOTSOCK || errno == ENOTCONN)\n-            return IOS_UNSUPPORTED_CASE;\n-        if ((errno == EINVAL) && ((ssize_t)count >= 0))\n-            return IOS_UNSUPPORTED_CASE;\n-        if (errno == EINTR)\n-            return IOS_INTERRUPTED;\n-        JNU_ThrowIOExceptionWithLastError(env, \"Transfer failed\");\n-        return IOS_THROWN;\n-    }\n-\n-    return result;\n-\n-#elif defined(_AIX)\n-    jlong max = (jlong)java_lang_Integer_MAX_VALUE;\n-    struct sf_parms sf_iobuf;\n-    jlong result;\n-\n-    if (position > max)\n-        return IOS_UNSUPPORTED_CASE;\n-\n-    if (count > max)\n-        count = max;\n-\n-    memset(&sf_iobuf, 0, sizeof(sf_iobuf));\n-    sf_iobuf.file_descriptor = srcFD;\n-    sf_iobuf.file_offset = (off_t)position;\n-    sf_iobuf.file_bytes = count;\n-\n-    result = send_file(&dstFD, &sf_iobuf, SF_SYNC_CACHE);\n-\n-    \/* AIX send_file() will return 0 when this operation complete successfully,\n-     * return 1 when partial bytes transferred and return -1 when an error has\n-     * occurred.\n-     *\/\n-    if (result == -1) {\n-        if (errno == EWOULDBLOCK)\n-            return IOS_UNAVAILABLE;\n-        if ((errno == EINVAL) && ((ssize_t)count >= 0))\n-            return IOS_UNSUPPORTED_CASE;\n-        if (errno == EINTR)\n-            return IOS_INTERRUPTED;\n-        if (errno == ENOTSOCK)\n-            return IOS_UNSUPPORTED;\n-        JNU_ThrowIOExceptionWithLastError(env, \"Transfer failed\");\n-        return IOS_THROWN;\n-    }\n-\n-    if (sf_iobuf.bytes_sent > 0)\n-        return (jlong)sf_iobuf.bytes_sent;\n-\n-    return IOS_UNSUPPORTED_CASE;\n-#else\n-    return IOS_UNSUPPORTED;\n-#endif\n-}\n-\n-JNIEXPORT jlong JNICALL\n-Java_sun_nio_ch_FileChannelImpl_transferFrom0(JNIEnv *env, jobject this,\n-                                              jobject srcFDO, jobject dstFDO,\n-                                              jlong position, jlong count,\n-                                              jboolean append)\n-{\n-#if defined(__linux__)\n-    if (my_copy_file_range_func == NULL)\n-        return IOS_UNSUPPORTED;\n-    \/\/ copy_file_range fails with EBADF when appending\n-    if (append == JNI_TRUE)\n-        return IOS_UNSUPPORTED_CASE;\n-\n-    jint srcFD = fdval(env, srcFDO);\n-    jint dstFD = fdval(env, dstFDO);\n-\n-    off64_t offset = (off64_t)position;\n-    size_t len = (size_t)count;\n-    jlong n = my_copy_file_range_func(srcFD, NULL, dstFD, &offset, len, 0);\n-    if (n < 0) {\n-        if (errno == EAGAIN)\n-            return IOS_UNAVAILABLE;\n-        if (errno == ENOSYS)\n-            return IOS_UNSUPPORTED_CASE;\n-        if ((errno == EBADF || errno == EINVAL || errno == EXDEV) &&\n-            ((ssize_t)count >= 0))\n-            return IOS_UNSUPPORTED_CASE;\n-        if (errno == EINTR) {\n-            return IOS_INTERRUPTED;\n-        }\n-        JNU_ThrowIOExceptionWithLastError(env, \"Transfer failed\");\n-        return IOS_THROWN;\n-    }\n-    return n;\n-#else\n-    return IOS_UNSUPPORTED;\n-#endif\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_ch_FileChannelImpl_maxDirectTransferSize0(JNIEnv* env, jobject this)\n-{\n-#if defined(LINUX)\n-    return 0x7ffff000; \/\/ 2,147,479,552 maximum for sendfile()\n-#else\n-    return java_lang_Integer_MAX_VALUE;\n-#endif\n-}\n","filename":"src\/java.base\/unix\/native\/libnio\/ch\/FileChannelImpl.c","additions":0,"deletions":336,"binary":false,"changes":336,"status":"deleted"},{"patch":"@@ -0,0 +1,146 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <unistd.h>\n+\n+#include <sys\/mman.h>\n+#include <sys\/stat.h>\n+#include <fcntl.h>\n+#include <sys\/types.h>\n+#include <unistd.h>\n+\n+#if defined(_ALLBSD_SOURCE)\n+#define mmap64 mmap\n+#endif\n+\n+#include \"jni.h\"\n+#include \"jni_util.h\"\n+#include \"nio.h\"\n+#include \"nio_util.h\"\n+#include \"sun_nio_ch_UnixFileChannelImpl.h\"\n+#include <assert.h>\n+\n+JNIEXPORT jlong JNICALL\n+Java_sun_nio_ch_UnixFileChannelImpl_allocationGranularity0(JNIEnv *env, jclass klass)\n+{\n+    jlong pageSize = sysconf(_SC_PAGESIZE);\n+    return pageSize;\n+}\n+\n+static jlong\n+handle(JNIEnv *env, jlong rv, char *msg)\n+{\n+    if (rv >= 0)\n+        return rv;\n+    if (errno == EINTR)\n+        return IOS_INTERRUPTED;\n+    JNU_ThrowIOExceptionWithLastError(env, msg);\n+    return IOS_THROWN;\n+}\n+\n+JNIEXPORT jlong JNICALL\n+Java_sun_nio_ch_UnixFileChannelImpl_map0(JNIEnv *env, jclass klass, jobject fdo,\n+                                         jint prot, jlong off, jlong len,\n+                                         jboolean map_sync)\n+{\n+    void *mapAddress = 0;\n+    jint fd = fdval(env, fdo);\n+    int protections = 0;\n+    int flags = 0;\n+\n+    \/\/ should never be called with map_sync and prot == PRIVATE\n+    assert((prot != sun_nio_ch_UnixFileChannelImpl_MAP_PV) || !map_sync);\n+\n+    if (prot == sun_nio_ch_UnixFileChannelImpl_MAP_RO) {\n+        protections = PROT_READ;\n+        flags = MAP_SHARED;\n+    } else if (prot == sun_nio_ch_UnixFileChannelImpl_MAP_RW) {\n+        protections = PROT_WRITE | PROT_READ;\n+        flags = MAP_SHARED;\n+    } else if (prot == sun_nio_ch_UnixFileChannelImpl_MAP_PV) {\n+        protections =  PROT_WRITE | PROT_READ;\n+        flags = MAP_PRIVATE;\n+    }\n+\n+    \/\/ if MAP_SYNC and MAP_SHARED_VALIDATE are not defined then it is\n+    \/\/ best to define them here. This ensures the code compiles on old\n+    \/\/ OS releases which do not provide the relevant headers. If run\n+    \/\/ on the same machine then it will work if the kernel contains\n+    \/\/ the necessary support otherwise mmap should fail with an\n+    \/\/ invalid argument error\n+\n+#ifndef MAP_SYNC\n+#define MAP_SYNC 0x80000\n+#endif\n+#ifndef MAP_SHARED_VALIDATE\n+#define MAP_SHARED_VALIDATE 0x03\n+#endif\n+\n+    if (map_sync) {\n+        \/\/ ensure\n+        \/\/  1) this is Linux on AArch64, x86_64, or PPC64 LE\n+        \/\/  2) the mmap APIs are available at compile time\n+#if !defined(LINUX) || ! (defined(aarch64) || (defined(amd64) && defined(_LP64)) || defined(ppc64le))\n+        \/\/ TODO - implement for solaris\/AIX\/BSD\/WINDOWS and for 32 bit\n+        JNU_ThrowInternalError(env, \"should never call map on platform where MAP_SYNC is unimplemented\");\n+        return IOS_THROWN;\n+#else\n+        flags |= MAP_SYNC | MAP_SHARED_VALIDATE;\n+#endif\n+    }\n+\n+    mapAddress = mmap64(\n+        0,                    \/* Let OS decide location *\/\n+        len,                  \/* Number of bytes to map *\/\n+        protections,          \/* File permissions *\/\n+        flags,                \/* Changes are shared *\/\n+        fd,                   \/* File descriptor of mapped file *\/\n+        off);                 \/* Offset into file *\/\n+\n+    if (mapAddress == MAP_FAILED) {\n+        if (map_sync && errno == ENOTSUP) {\n+            JNU_ThrowIOExceptionWithLastError(env, \"map with mode MAP_SYNC unsupported\");\n+            return IOS_THROWN;\n+        }\n+\n+        if (errno == ENOMEM) {\n+            JNU_ThrowOutOfMemoryError(env, \"Map failed\");\n+            return IOS_THROWN;\n+        }\n+        return handle(env, -1, \"Map failed\");\n+    }\n+\n+    return ((jlong) (unsigned long) mapAddress);\n+}\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_ch_UnixFileChannelImpl_unmap0(JNIEnv *env, jclass klass,\n+                                           jlong address, jlong len)\n+{\n+    void *a = (void *)jlong_to_ptr(address);\n+    return handle(env,\n+                  munmap(a, (size_t)len),\n+                  \"Unmap failed\");\n+}\n","filename":"src\/java.base\/unix\/native\/libnio\/ch\/UnixFileChannelImpl.c","additions":146,"deletions":0,"binary":false,"changes":146,"status":"added"},{"patch":"@@ -0,0 +1,106 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.nio.ch;\n+\n+import java.io.FileDescriptor;\n+import java.io.IOException;\n+import java.nio.channels.FileChannel;\n+import java.util.function.BiFunction;\n+\n+public class FileChannelImpl extends AbstractFileChannelImpl {\n+    private static final long ALLOCATION_GRANULARITY;\n+    private static final BiFunction<Long,Long,Integer> unmapFunction;\n+\n+    static {\n+        ALLOCATION_GRANULARITY = allocationGranularity0();\n+\n+        \/\/ initialize function for removing a mapping\n+        unmapFunction = (addr, len) -> unmap(addr, len);\n+    }\n+\n+    private FileChannelImpl(FileDescriptor fd, String path, boolean readable,\n+                            boolean writable, boolean direct, Object parent)\n+    {\n+        super(fd, path, readable, writable, direct, parent, unmapFunction);\n+    }\n+\n+    \/\/ Used by FileInputStream::getChannel, FileOutputStream::getChannel,\n+    \/\/ and RandomAccessFile::getChannel\n+    public static FileChannel open(FileDescriptor fd, String path,\n+                                   boolean readable, boolean writable,\n+                                   boolean direct, Object parent)\n+    {\n+        return new FileChannelImpl(fd, path, readable, writable, direct, parent);\n+    }\n+\n+    protected int maxDirectTransferSize() {\n+        return maxDirectTransferSize0();\n+    }\n+\n+    protected long allocationGranularity() {\n+        return ALLOCATION_GRANULARITY;\n+    }\n+\n+    \/\/ Creates a new mapping\n+    protected long map(FileDescriptor fd, int prot, long position,\n+                       long length, boolean isSync)\n+        throws IOException\n+    {\n+        return map0(fd, prot, position, length, isSync);\n+    }\n+\n+    \/\/ Removes an existing mapping\n+    static int unmap(long address, long length) {\n+        return unmap0(address, length);\n+    }\n+\n+    protected long transferTo(FileDescriptor src, long position,\n+                              long count, FileDescriptor dst,\n+                              boolean append)\n+    {\n+        System.out.println(\"transferTo0()\");\n+        return transferTo0(src, position, count, dst, append);\n+    }\n+\n+    \/\/ --- native methods ---\n+\n+    \/\/ Retrieves allocation granularity\n+    private static native long allocationGranularity0();\n+\n+    \/\/ Creates a new mapping\n+    private static native long map0(FileDescriptor fd, int prot, long position,\n+                                    long length, boolean isSync)\n+        throws IOException;\n+\n+    \/\/ Removes an existing mapping\n+    private static native int unmap0(long address, long length);\n+\n+    private static native int maxDirectTransferSize0();\n+\n+    private static native long transferTo0(FileDescriptor src, long position,\n+                                           long count, FileDescriptor dst,\n+                                           boolean append);\n+}\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/ch\/FileChannelImpl.java","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"},{"patch":"@@ -43,1 +43,1 @@\n-Java_sun_nio_ch_FileChannelImpl_allocationGranularity0(JNIEnv *env, jclass clazz)\n+Java_sun_nio_ch_FileChannelImpl_allocationGranularity0(JNIEnv *env, jclass klass)\n@@ -58,1 +58,1 @@\n-Java_sun_nio_ch_FileChannelImpl_map0(JNIEnv *env, jobject this, jobject fdo,\n+Java_sun_nio_ch_FileChannelImpl_map0(JNIEnv *env, jclass klass, jobject fdo,\n@@ -129,2 +129,2 @@\n-Java_sun_nio_ch_FileChannelImpl_unmap0(JNIEnv *env, jobject this,\n-                                 jlong address, jlong len)\n+Java_sun_nio_ch_FileChannelImpl_unmap0(JNIEnv *env, jclass klass,\n+                                       jlong address, jlong len)\n@@ -146,0 +146,6 @@\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_ch_FileChannelImpl_maxDirectTransferSize0(JNIEnv* env, jclass klass)\n+{\n+    return MAX_TRANSMIT_SIZE;\n+}\n+\n@@ -147,1 +153,1 @@\n-Java_sun_nio_ch_FileChannelImpl_transferTo0(JNIEnv *env, jobject this,\n+Java_sun_nio_ch_FileChannelImpl_transferTo0(JNIEnv *env, jclass klass,\n@@ -190,15 +196,0 @@\n-\n-JNIEXPORT jlong JNICALL\n-Java_sun_nio_ch_FileChannelImpl_transferFrom0(JNIEnv *env, jobject this,\n-                                              jobject srcFDO, jobject dstFDO,\n-                                              jlong position, jlong count,\n-                                              jboolean append)\n-{\n-    return IOS_UNSUPPORTED;\n-}\n-\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_ch_FileChannelImpl_maxDirectTransferSize0(JNIEnv* env, jobject this)\n-{\n-    return MAX_TRANSMIT_SIZE;\n-}\n","filename":"src\/java.base\/windows\/native\/libnio\/ch\/FileChannelImpl.c","additions":11,"deletions":20,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,1 @@\n-import sun.nio.ch.FileChannelImpl;\n+import sun.nio.ch.AbstractFileChannelImpl;\n@@ -81,1 +81,1 @@\n-            Field fdField = FileChannelImpl.class.getDeclaredField(\"fd\");\n+            Field fdField = AbstractFileChannelImpl.class.getDeclaredField(\"fd\");\n@@ -87,1 +87,1 @@\n-            Field closerField = FileChannelImpl.class.getDeclaredField(\"closer\");\n+            Field closerField = AbstractFileChannelImpl.class.getDeclaredField(\"closer\");\n","filename":"test\/jdk\/java\/nio\/channels\/FileChannel\/CleanerTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"}]}