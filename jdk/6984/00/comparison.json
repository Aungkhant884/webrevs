{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,2 @@\n+#ifndef _WINDOWS\n+\n@@ -55,0 +57,160 @@\n+#define COPY_SMALL(from, to, count)                                     \\\n+{                                                                       \\\n+        long tmp0, tmp1, tmp2, tmp3;                                    \\\n+        long tmp4, tmp5, tmp6, tmp7;                                    \\\n+  __asm volatile(                                                       \\\n+\"       adr     %[t0], 0f;\\n\"                                           \\\n+\"       add     %[t0], %[t0], %[cnt], lsl #5;\\n\"                        \\\n+\"       br      %[t0];\\n\"                                               \\\n+\"       .align  5;\\n\"                                                   \\\n+\"0:\"                                                                    \\\n+\"       b       1f;\\n\"                                                  \\\n+\"       .align  5;\\n\"                                                   \\\n+\"       ldr     %[t0], [%[s], #0];\\n\"                                   \\\n+\"       str     %[t0], [%[d], #0];\\n\"                                   \\\n+\"       b       1f;\\n\"                                                  \\\n+\"       .align  5;\\n\"                                                   \\\n+\"       ldp     %[t0], %[t1], [%[s], #0];\\n\"                            \\\n+\"       stp     %[t0], %[t1], [%[d], #0];\\n\"                            \\\n+\"       b       1f;\\n\"                                                  \\\n+\"       .align  5;\\n\"                                                   \\\n+\"       ldp     %[t0], %[t1], [%[s], #0];\\n\"                            \\\n+\"       ldr     %[t2], [%[s], #16];\\n\"                                  \\\n+\"       stp     %[t0], %[t1], [%[d], #0];\\n\"                            \\\n+\"       str     %[t2], [%[d], #16];\\n\"                                  \\\n+\"       b       1f;\\n\"                                                  \\\n+\"       .align  5;\\n\"                                                   \\\n+\"       ldp     %[t0], %[t1], [%[s], #0];\\n\"                            \\\n+\"       ldp     %[t2], %[t3], [%[s], #16];\\n\"                           \\\n+\"       stp     %[t0], %[t1], [%[d], #0];\\n\"                            \\\n+\"       stp     %[t2], %[t3], [%[d], #16];\\n\"                           \\\n+\"       b       1f;\\n\"                                                  \\\n+\"       .align  5;\\n\"                                                   \\\n+\"       ldp     %[t0], %[t1], [%[s], #0];\\n\"                            \\\n+\"       ldp     %[t2], %[t3], [%[s], #16];\\n\"                           \\\n+\"       ldr     %[t4], [%[s], #32];\\n\"                                  \\\n+\"       stp     %[t0], %[t1], [%[d], #0];\\n\"                            \\\n+\"       stp     %[t2], %[t3], [%[d], #16];\\n\"                           \\\n+\"       str     %[t4], [%[d], #32];\\n\"                                  \\\n+\"       b       1f;\\n\"                                                  \\\n+\"       .align  5;\\n\"                                                   \\\n+\"       ldp     %[t0], %[t1], [%[s], #0];\\n\"                            \\\n+\"       ldp     %[t2], %[t3], [%[s], #16];\\n\"                           \\\n+\"       ldp     %[t4], %[t5], [%[s], #32];\\n\"                           \\\n+\"2:\"                                                                    \\\n+\"       stp     %[t0], %[t1], [%[d], #0];\\n\"                            \\\n+\"       stp     %[t2], %[t3], [%[d], #16];\\n\"                           \\\n+\"       stp     %[t4], %[t5], [%[d], #32];\\n\"                           \\\n+\"       b       1f;\\n\"                                                  \\\n+\"       .align  5;\\n\"                                                   \\\n+\"       ldr     %[t6], [%[s], #0];\\n\"                                   \\\n+\"       ldp     %[t0], %[t1], [%[s], #8];\\n\"                            \\\n+\"       ldp     %[t2], %[t3], [%[s], #24];\\n\"                           \\\n+\"       ldp     %[t4], %[t5], [%[s], #40];\\n\"                           \\\n+\"       str     %[t6], [%[d]], #8;\\n\"                                   \\\n+\"       b       2b;\\n\"                                                  \\\n+\"       .align  5;\\n\"                                                   \\\n+\"       ldp     %[t0], %[t1], [%[s], #0];\\n\"                            \\\n+\"       ldp     %[t2], %[t3], [%[s], #16];\\n\"                           \\\n+\"       ldp     %[t4], %[t5], [%[s], #32];\\n\"                           \\\n+\"       ldp     %[t6], %[t7], [%[s], #48];\\n\"                           \\\n+\"       stp     %[t0], %[t1], [%[d], #0];\\n\"                            \\\n+\"       stp     %[t2], %[t3], [%[d], #16];\\n\"                           \\\n+\"       stp     %[t4], %[t5], [%[d], #32];\\n\"                           \\\n+\"       stp     %[t6], %[t7], [%[d], #48];\\n\"                           \\\n+\"1:\"                                                                    \\\n+                                                                        \\\n+  : [s]\"+r\"(from), [d]\"+r\"(to), [cnt]\"+r\"(count),                       \\\n+    [t0]\"=&r\"(tmp0), [t1]\"=&r\"(tmp1), [t2]\"=&r\"(tmp2), [t3]\"=&r\"(tmp3), \\\n+    [t4]\"=&r\"(tmp4), [t5]\"=&r\"(tmp5), [t6]\"=&r\"(tmp6), [t7]\"=&r\"(tmp7)  \\\n+  :                                                                     \\\n+  : \"memory\", \"cc\");                                                    \\\n+}\n+\n+static void pd_conjoint_words(const HeapWord* from, HeapWord* to, size_t count) {\n+  __asm volatile( \"prfm pldl1strm, [%[s], #0];\" :: [s]\"r\"(from) : \"memory\");\n+  if (__builtin_expect(count <= 8, 1)) {\n+    COPY_SMALL(from, to, count);\n+    return;\n+  }\n+  _Copy_conjoint_words(from, to, count);\n+}\n+\n+static void pd_disjoint_words(const HeapWord* from, HeapWord* to, size_t count) {\n+  if (__builtin_constant_p(count)) {\n+    memcpy(to, from, count * sizeof(HeapWord));\n+    return;\n+  }\n+  __asm volatile( \"prfm pldl1strm, [%[s], #0];\" :: [s]\"r\"(from) : \"memory\");\n+  if (__builtin_expect(count <= 8, 1)) {\n+    COPY_SMALL(from, to, count);\n+    return;\n+  }\n+  _Copy_disjoint_words(from, to, count);\n+}\n+\n+static void pd_disjoint_words_atomic(const HeapWord* from, HeapWord* to, size_t count) {\n+  __asm volatile( \"prfm pldl1strm, [%[s], #0];\" :: [s]\"r\"(from) : \"memory\");\n+  if (__builtin_expect(count <= 8, 1)) {\n+    COPY_SMALL(from, to, count);\n+    return;\n+  }\n+  _Copy_disjoint_words(from, to, count);\n+}\n+\n+static void pd_aligned_conjoint_words(const HeapWord* from, HeapWord* to, size_t count) {\n+  pd_conjoint_words(from, to, count);\n+}\n+\n+static void pd_aligned_disjoint_words(const HeapWord* from, HeapWord* to, size_t count) {\n+  pd_disjoint_words(from, to, count);\n+}\n+\n+static void pd_conjoint_bytes(const void* from, void* to, size_t count) {\n+  (void)memmove(to, from, count);\n+}\n+\n+static void pd_conjoint_bytes_atomic(const void* from, void* to, size_t count) {\n+  pd_conjoint_bytes(from, to, count);\n+}\n+\n+static void pd_conjoint_jshorts_atomic(const jshort* from, jshort* to, size_t count) {\n+  _Copy_conjoint_jshorts_atomic(from, to, count);\n+}\n+\n+static void pd_conjoint_jints_atomic(const jint* from, jint* to, size_t count) {\n+  _Copy_conjoint_jints_atomic(from, to, count);\n+}\n+\n+static void pd_conjoint_jlongs_atomic(const jlong* from, jlong* to, size_t count) {\n+  _Copy_conjoint_jlongs_atomic(from, to, count);\n+}\n+\n+static void pd_conjoint_oops_atomic(const oop* from, oop* to, size_t count) {\n+  assert(BytesPerLong == BytesPerOop, \"jlongs and oops must be the same size\");\n+  _Copy_conjoint_jlongs_atomic((const jlong*)from, (jlong*)to, count);\n+}\n+\n+static void pd_arrayof_conjoint_bytes(const HeapWord* from, HeapWord* to, size_t count) {\n+  _Copy_arrayof_conjoint_bytes(from, to, count);\n+}\n+\n+static void pd_arrayof_conjoint_jshorts(const HeapWord* from, HeapWord* to, size_t count) {\n+  _Copy_arrayof_conjoint_jshorts(from, to, count);\n+}\n+\n+static void pd_arrayof_conjoint_jints(const HeapWord* from, HeapWord* to, size_t count) {\n+   _Copy_arrayof_conjoint_jints(from, to, count);\n+}\n+\n+static void pd_arrayof_conjoint_jlongs(const HeapWord* from, HeapWord* to, size_t count) {\n+  _Copy_arrayof_conjoint_jlongs(from, to, count);\n+}\n+\n+static void pd_arrayof_conjoint_oops(const HeapWord* from, HeapWord* to, size_t count) {\n+  assert(!UseCompressedOops, \"foo!\");\n+  assert(BytesPerLong == BytesPerOop, \"jlongs and oops must be the same size\");\n+  _Copy_arrayof_conjoint_jlongs(from, to, count);\n+}\n+#endif \/\/ _WINDOWS\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/copy_aarch64.hpp","additions":163,"deletions":1,"binary":false,"changes":164,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,0 +62,289 @@\n+static void pd_conjoint_words(const HeapWord* from, HeapWord* to, size_t count) {\n+#if defined AMD64 || defined _WINDOWS\n+  (void)memmove(to, from, count * HeapWordSize);\n+#else\n+  \/\/ Includes a zero-count check.\n+  intx temp = 0;\n+  __asm__ volatile(\"        testl   %6,%6         ;\"\n+                   \"        jz      7f            ;\"\n+                   \"        cmpl    %4,%5         ;\"\n+                   \"        leal    -4(%4,%6,4),%3;\"\n+                   \"        jbe     1f            ;\"\n+                   \"        cmpl    %7,%5         ;\"\n+                   \"        jbe     4f            ;\"\n+                   \"1:      cmpl    $32,%6        ;\"\n+                   \"        ja      3f            ;\"\n+                   \"        subl    %4,%1         ;\"\n+                   \"2:      movl    (%4),%3       ;\"\n+                   \"        movl    %7,(%5,%4,1)  ;\"\n+                   \"        addl    $4,%0         ;\"\n+                   \"        subl    $1,%2          ;\"\n+                   \"        jnz     2b            ;\"\n+                   \"        jmp     7f            ;\"\n+                   \"3:      rep;    smovl         ;\"\n+                   \"        jmp     7f            ;\"\n+                   \"4:      cmpl    $32,%2        ;\"\n+                   \"        movl    %7,%0         ;\"\n+                   \"        leal    -4(%5,%6,4),%1;\"\n+                   \"        ja      6f            ;\"\n+                   \"        subl    %4,%1         ;\"\n+                   \"5:      movl    (%4),%3       ;\"\n+                   \"        movl    %7,(%5,%4,1)  ;\"\n+                   \"        subl    $4,%0         ;\"\n+                   \"        subl    $1,%2          ;\"\n+                   \"        jnz     5b            ;\"\n+                   \"        jmp     7f            ;\"\n+                   \"6:      std                   ;\"\n+                   \"        rep;    smovl         ;\"\n+                   \"        cld                   ;\"\n+                   \"7:      nop                    \"\n+                   : \"=S\" (from), \"=D\" (to), \"=c\" (count), \"=r\" (temp)\n+                   : \"0\"  (from), \"1\"  (to), \"2\"  (count), \"3\"  (temp)\n+                   : \"memory\", \"flags\");\n+#endif \/\/ AMD64\n+}\n+\n+static void pd_disjoint_words(const HeapWord* from, HeapWord* to, size_t count) {\n+#ifdef AMD64\n+  switch (count) {\n+  case 8:  to[7] = from[7];\n+  case 7:  to[6] = from[6];\n+  case 6:  to[5] = from[5];\n+  case 5:  to[4] = from[4];\n+  case 4:  to[3] = from[3];\n+  case 3:  to[2] = from[2];\n+  case 2:  to[1] = from[1];\n+  case 1:  to[0] = from[0];\n+  case 0:  break;\n+  default:\n+    (void)memcpy(to, from, count * HeapWordSize);\n+    break;\n+  }\n+#else\n+#if defined _WINDOWS\n+  (void)memcpy(to, from, count * HeapWordSize);\n+#else\n+  \/\/ Includes a zero-count check.\n+  intx temp = 0;\n+  __asm__ volatile(\"        testl   %6,%6       ;\"\n+                   \"        jz      3f          ;\"\n+                   \"        cmpl    $32,%6      ;\"\n+                   \"        ja      2f          ;\"\n+                   \"        subl    %4,%1       ;\"\n+                   \"1:      movl    (%4),%3     ;\"\n+                   \"        movl    %7,(%5,%4,1);\"\n+                   \"        addl    $4,%0       ;\"\n+                   \"        subl    $1,%2        ;\"\n+                   \"        jnz     1b          ;\"\n+                   \"        jmp     3f          ;\"\n+                   \"2:      rep;    smovl       ;\"\n+                   \"3:      nop                  \"\n+                   : \"=S\" (from), \"=D\" (to), \"=c\" (count), \"=r\" (temp)\n+                   : \"0\"  (from), \"1\"  (to), \"2\"  (count), \"3\"  (temp)\n+                   : \"memory\", \"cc\");\n+#endif \/\/ _WINDOWS\n+#endif \/\/ AMD64\n+}\n+\n+static void pd_disjoint_words_atomic(const HeapWord* from, HeapWord* to, size_t count) {\n+#ifdef AMD64\n+  switch (count) {\n+  case 8:  to[7] = from[7];\n+  case 7:  to[6] = from[6];\n+  case 6:  to[5] = from[5];\n+  case 5:  to[4] = from[4];\n+  case 4:  to[3] = from[3];\n+  case 3:  to[2] = from[2];\n+  case 2:  to[1] = from[1];\n+  case 1:  to[0] = from[0];\n+  case 0:  break;\n+  default:\n+    while (count-- > 0) {\n+      *to++ = *from++;\n+    }\n+    break;\n+  }\n+#else\n+  \/\/ pd_disjoint_words is word-atomic in this implementation.\n+  pd_disjoint_words(from, to, count);\n+#endif \/\/ AMD64\n+}\n+\n+static void pd_aligned_conjoint_words(const HeapWord* from, HeapWord* to, size_t count) {\n+  pd_conjoint_words(from, to, count);\n+}\n+\n+static void pd_aligned_disjoint_words(const HeapWord* from, HeapWord* to, size_t count) {\n+  pd_disjoint_words(from, to, count);\n+}\n+\n+static void pd_conjoint_bytes(const void* from, void* to, size_t count) {\n+#if defined AMD64 || defined _WINDOWS\n+  (void)memmove(to, from, count);\n+#else\n+  \/\/ Includes a zero-count check.\n+  intx temp = 0;\n+  __asm__ volatile(\"        testl   %6,%6          ;\"\n+                   \"        jz      13f            ;\"\n+                   \"        cmpl    %4,%5          ;\"\n+                   \"        leal    -1(%4,%6),%3   ;\"\n+                   \"        jbe     1f             ;\"\n+                   \"        cmpl    %7,%5          ;\"\n+                   \"        jbe     8f             ;\"\n+                   \"1:      cmpl    $3,%6          ;\"\n+                   \"        jbe     6f             ;\"\n+                   \"        movl    %6,%3          ;\"\n+                   \"        movl    $4,%2          ;\"\n+                   \"        subl    %4,%2          ;\"\n+                   \"        andl    $3,%2          ;\"\n+                   \"        jz      2f             ;\"\n+                   \"        subl    %6,%3          ;\"\n+                   \"        rep;    smovb          ;\"\n+                   \"2:      movl    %7,%2          ;\"\n+                   \"        shrl    $2,%2          ;\"\n+                   \"        jz      5f             ;\"\n+                   \"        cmpl    $32,%2         ;\"\n+                   \"        ja      4f             ;\"\n+                   \"        subl    %4,%1          ;\"\n+                   \"3:      movl    (%4),%%edx     ;\"\n+                   \"        movl    %%edx,(%5,%4,1);\"\n+                   \"        addl    $4,%0          ;\"\n+                   \"        subl    $1,%2           ;\"\n+                   \"        jnz     3b             ;\"\n+                   \"        addl    %4,%1          ;\"\n+                   \"        jmp     5f             ;\"\n+                   \"4:      rep;    smovl          ;\"\n+                   \"5:      movl    %7,%2          ;\"\n+                   \"        andl    $3,%2          ;\"\n+                   \"        jz      13f            ;\"\n+                   \"6:      xorl    %7,%3          ;\"\n+                   \"7:      movb    (%4,%7,1),%%dl ;\"\n+                   \"        movb    %%dl,(%5,%7,1) ;\"\n+                   \"        addl    $1,%3          ;\"\n+                   \"        subl    $1,%2           ;\"\n+                   \"        jnz     7b             ;\"\n+                   \"        jmp     13f            ;\"\n+                   \"8:      std                    ;\"\n+                   \"        cmpl    $12,%2         ;\"\n+                   \"        ja      9f             ;\"\n+                   \"        movl    %7,%0          ;\"\n+                   \"        leal    -1(%6,%5),%1   ;\"\n+                   \"        jmp     11f            ;\"\n+                   \"9:      xchgl   %3,%2          ;\"\n+                   \"        movl    %6,%0          ;\"\n+                   \"        addl    $1,%2          ;\"\n+                   \"        leal    -1(%7,%5),%1   ;\"\n+                   \"        andl    $3,%2          ;\"\n+                   \"        jz      10f            ;\"\n+                   \"        subl    %6,%3          ;\"\n+                   \"        rep;    smovb          ;\"\n+                   \"10:     movl    %7,%2          ;\"\n+                   \"        subl    $3,%0          ;\"\n+                   \"        shrl    $2,%2          ;\"\n+                   \"        subl    $3,%1          ;\"\n+                   \"        rep;    smovl          ;\"\n+                   \"        andl    $3,%3          ;\"\n+                   \"        jz      12f            ;\"\n+                   \"        movl    %7,%2          ;\"\n+                   \"        addl    $3,%0          ;\"\n+                   \"        addl    $3,%1          ;\"\n+                   \"11:     rep;    smovb          ;\"\n+                   \"12:     cld                    ;\"\n+                   \"13:     nop                    ;\"\n+                   : \"=S\" (from), \"=D\" (to), \"=c\" (count), \"=r\" (temp)\n+                   : \"0\"  (from), \"1\"  (to), \"2\"  (count), \"3\"  (temp)\n+                   : \"memory\", \"flags\", \"%edx\");\n+#endif \/\/ AMD64\n+}\n+\n+static void pd_conjoint_bytes_atomic(const void* from, void* to, size_t count) {\n+  pd_conjoint_bytes(from, to, count);\n+}\n+\n+\/\/ Windows has a different implementation\n+#ifndef _WINDOWS\n+static void pd_conjoint_jshorts_atomic(const jshort* from, jshort* to, size_t count) {\n+  _Copy_conjoint_jshorts_atomic(from, to, count);\n+}\n+\n+static void pd_conjoint_jints_atomic(const jint* from, jint* to, size_t count) {\n+#ifdef AMD64\n+  _Copy_conjoint_jints_atomic(from, to, count);\n+#else\n+  assert(HeapWordSize == BytesPerInt, \"heapwords and jints must be the same size\");\n+  \/\/ pd_conjoint_words is word-atomic in this implementation.\n+  pd_conjoint_words((const HeapWord*)from, (HeapWord*)to, count);\n+#endif \/\/ AMD64\n+}\n+\n+static void pd_conjoint_jlongs_atomic(const jlong* from, jlong* to, size_t count) {\n+#ifdef AMD64\n+  _Copy_conjoint_jlongs_atomic(from, to, count);\n+#else\n+  \/\/ Guarantee use of fild\/fistp or xmm regs via some asm code, because compilers won't.\n+  if (from > to) {\n+    while (count-- > 0) {\n+      __asm__ volatile(\"fildll (%0); fistpll (%1)\"\n+                       :\n+                       : \"r\" (from), \"r\" (to)\n+                       : \"memory\" );\n+      ++from;\n+      ++to;\n+    }\n+  } else {\n+    while (count-- > 0) {\n+      __asm__ volatile(\"fildll (%0,%2,8); fistpll (%1,%2,8)\"\n+                       :\n+                       : \"r\" (from), \"r\" (to), \"r\" (count)\n+                       : \"memory\" );\n+    }\n+  }\n+#endif \/\/ AMD64\n+}\n+\n+static void pd_conjoint_oops_atomic(const oop* from, oop* to, size_t count) {\n+#ifdef AMD64\n+  assert(BytesPerLong == BytesPerOop, \"jlongs and oops must be the same size\");\n+  _Copy_conjoint_jlongs_atomic((const jlong*)from, (jlong*)to, count);\n+#else\n+  assert(HeapWordSize == BytesPerOop, \"heapwords and oops must be the same size\");\n+  \/\/ pd_conjoint_words is word-atomic in this implementation.\n+  pd_conjoint_words((const HeapWord*)from, (HeapWord*)to, count);\n+#endif \/\/ AMD64\n+}\n+\n+static void pd_arrayof_conjoint_bytes(const HeapWord* from, HeapWord* to, size_t count) {\n+  _Copy_arrayof_conjoint_bytes(from, to, count);\n+}\n+\n+static void pd_arrayof_conjoint_jshorts(const HeapWord* from, HeapWord* to, size_t count) {\n+  _Copy_arrayof_conjoint_jshorts(from, to, count);\n+}\n+\n+static void pd_arrayof_conjoint_jints(const HeapWord* from, HeapWord* to, size_t count) {\n+#ifdef AMD64\n+   _Copy_arrayof_conjoint_jints(from, to, count);\n+#else\n+  pd_conjoint_jints_atomic((const jint*)from, (jint*)to, count);\n+#endif \/\/ AMD64\n+}\n+\n+static void pd_arrayof_conjoint_jlongs(const HeapWord* from, HeapWord* to, size_t count) {\n+#ifdef AMD64\n+  _Copy_arrayof_conjoint_jlongs(from, to, count);\n+#else\n+  pd_conjoint_jlongs_atomic((const jlong*)from, (jlong*)to, count);\n+#endif \/\/ AMD64\n+}\n+\n+static void pd_arrayof_conjoint_oops(const HeapWord* from, HeapWord* to, size_t count) {\n+#ifdef AMD64\n+  assert(BytesPerLong == BytesPerOop, \"jlongs and oops must be the same size\");\n+  _Copy_arrayof_conjoint_jlongs(from, to, count);\n+#else\n+  pd_conjoint_oops_atomic((const oop*)from, (oop*)to, count);\n+#endif \/\/ AMD64\n+}\n+\n+#endif \/\/ _WINDOWS\n+\n","filename":"src\/hotspot\/cpu\/x86\/copy_x86.hpp","additions":290,"deletions":1,"binary":false,"changes":291,"status":"modified"},{"patch":"@@ -30,158 +30,1 @@\n-#define COPY_SMALL(from, to, count)                                     \\\n-{                                                                       \\\n-        long tmp0, tmp1, tmp2, tmp3;                                    \\\n-        long tmp4, tmp5, tmp6, tmp7;                                    \\\n-  __asm volatile(                                                       \\\n-\"       adr     %[t0], 0f;\\n\"                                           \\\n-\"       add     %[t0], %[t0], %[cnt], lsl #5;\\n\"                        \\\n-\"       br      %[t0];\\n\"                                               \\\n-\"       .align  5;\\n\"                                                   \\\n-\"0:\"                                                                    \\\n-\"       b       1f;\\n\"                                                  \\\n-\"       .align  5;\\n\"                                                   \\\n-\"       ldr     %[t0], [%[s], #0];\\n\"                                   \\\n-\"       str     %[t0], [%[d], #0];\\n\"                                   \\\n-\"       b       1f;\\n\"                                                  \\\n-\"       .align  5;\\n\"                                                   \\\n-\"       ldp     %[t0], %[t1], [%[s], #0];\\n\"                            \\\n-\"       stp     %[t0], %[t1], [%[d], #0];\\n\"                            \\\n-\"       b       1f;\\n\"                                                  \\\n-\"       .align  5;\\n\"                                                   \\\n-\"       ldp     %[t0], %[t1], [%[s], #0];\\n\"                            \\\n-\"       ldr     %[t2], [%[s], #16];\\n\"                                  \\\n-\"       stp     %[t0], %[t1], [%[d], #0];\\n\"                            \\\n-\"       str     %[t2], [%[d], #16];\\n\"                                  \\\n-\"       b       1f;\\n\"                                                  \\\n-\"       .align  5;\\n\"                                                   \\\n-\"       ldp     %[t0], %[t1], [%[s], #0];\\n\"                            \\\n-\"       ldp     %[t2], %[t3], [%[s], #16];\\n\"                           \\\n-\"       stp     %[t0], %[t1], [%[d], #0];\\n\"                            \\\n-\"       stp     %[t2], %[t3], [%[d], #16];\\n\"                           \\\n-\"       b       1f;\\n\"                                                  \\\n-\"       .align  5;\\n\"                                                   \\\n-\"       ldp     %[t0], %[t1], [%[s], #0];\\n\"                            \\\n-\"       ldp     %[t2], %[t3], [%[s], #16];\\n\"                           \\\n-\"       ldr     %[t4], [%[s], #32];\\n\"                                  \\\n-\"       stp     %[t0], %[t1], [%[d], #0];\\n\"                            \\\n-\"       stp     %[t2], %[t3], [%[d], #16];\\n\"                           \\\n-\"       str     %[t4], [%[d], #32];\\n\"                                  \\\n-\"       b       1f;\\n\"                                                  \\\n-\"       .align  5;\\n\"                                                   \\\n-\"       ldp     %[t0], %[t1], [%[s], #0];\\n\"                            \\\n-\"       ldp     %[t2], %[t3], [%[s], #16];\\n\"                           \\\n-\"       ldp     %[t4], %[t5], [%[s], #32];\\n\"                           \\\n-\"2:\"                                                                    \\\n-\"       stp     %[t0], %[t1], [%[d], #0];\\n\"                            \\\n-\"       stp     %[t2], %[t3], [%[d], #16];\\n\"                           \\\n-\"       stp     %[t4], %[t5], [%[d], #32];\\n\"                           \\\n-\"       b       1f;\\n\"                                                  \\\n-\"       .align  5;\\n\"                                                   \\\n-\"       ldr     %[t6], [%[s], #0];\\n\"                                   \\\n-\"       ldp     %[t0], %[t1], [%[s], #8];\\n\"                            \\\n-\"       ldp     %[t2], %[t3], [%[s], #24];\\n\"                           \\\n-\"       ldp     %[t4], %[t5], [%[s], #40];\\n\"                           \\\n-\"       str     %[t6], [%[d]], #8;\\n\"                                   \\\n-\"       b       2b;\\n\"                                                  \\\n-\"       .align  5;\\n\"                                                   \\\n-\"       ldp     %[t0], %[t1], [%[s], #0];\\n\"                            \\\n-\"       ldp     %[t2], %[t3], [%[s], #16];\\n\"                           \\\n-\"       ldp     %[t4], %[t5], [%[s], #32];\\n\"                           \\\n-\"       ldp     %[t6], %[t7], [%[s], #48];\\n\"                           \\\n-\"       stp     %[t0], %[t1], [%[d], #0];\\n\"                            \\\n-\"       stp     %[t2], %[t3], [%[d], #16];\\n\"                           \\\n-\"       stp     %[t4], %[t5], [%[d], #32];\\n\"                           \\\n-\"       stp     %[t6], %[t7], [%[d], #48];\\n\"                           \\\n-\"1:\"                                                                    \\\n-                                                                        \\\n-  : [s]\"+r\"(from), [d]\"+r\"(to), [cnt]\"+r\"(count),                       \\\n-    [t0]\"=&r\"(tmp0), [t1]\"=&r\"(tmp1), [t2]\"=&r\"(tmp2), [t3]\"=&r\"(tmp3), \\\n-    [t4]\"=&r\"(tmp4), [t5]\"=&r\"(tmp5), [t6]\"=&r\"(tmp6), [t7]\"=&r\"(tmp7)  \\\n-  :                                                                     \\\n-  : \"memory\", \"cc\");                                                    \\\n-}\n-\n-static void pd_conjoint_words(const HeapWord* from, HeapWord* to, size_t count) {\n-  __asm volatile( \"prfm pldl1strm, [%[s], #0];\" :: [s]\"r\"(from) : \"memory\");\n-  if (__builtin_expect(count <= 8, 1)) {\n-    COPY_SMALL(from, to, count);\n-    return;\n-  }\n-  _Copy_conjoint_words(from, to, count);\n-}\n-\n-static void pd_disjoint_words(const HeapWord* from, HeapWord* to, size_t count) {\n-  if (__builtin_constant_p(count)) {\n-    memcpy(to, from, count * sizeof(HeapWord));\n-    return;\n-  }\n-  __asm volatile( \"prfm pldl1strm, [%[s], #0];\" :: [s]\"r\"(from) : \"memory\");\n-  if (__builtin_expect(count <= 8, 1)) {\n-    COPY_SMALL(from, to, count);\n-    return;\n-  }\n-  _Copy_disjoint_words(from, to, count);\n-}\n-\n-static void pd_disjoint_words_atomic(const HeapWord* from, HeapWord* to, size_t count) {\n-  __asm volatile( \"prfm pldl1strm, [%[s], #0];\" :: [s]\"r\"(from) : \"memory\");\n-  if (__builtin_expect(count <= 8, 1)) {\n-    COPY_SMALL(from, to, count);\n-    return;\n-  }\n-  _Copy_disjoint_words(from, to, count);\n-}\n-\n-static void pd_aligned_conjoint_words(const HeapWord* from, HeapWord* to, size_t count) {\n-  pd_conjoint_words(from, to, count);\n-}\n-\n-static void pd_aligned_disjoint_words(const HeapWord* from, HeapWord* to, size_t count) {\n-  pd_disjoint_words(from, to, count);\n-}\n-\n-static void pd_conjoint_bytes(const void* from, void* to, size_t count) {\n-  (void)memmove(to, from, count);\n-}\n-\n-static void pd_conjoint_bytes_atomic(const void* from, void* to, size_t count) {\n-  pd_conjoint_bytes(from, to, count);\n-}\n-\n-static void pd_conjoint_jshorts_atomic(const jshort* from, jshort* to, size_t count) {\n-  _Copy_conjoint_jshorts_atomic(from, to, count);\n-}\n-\n-static void pd_conjoint_jints_atomic(const jint* from, jint* to, size_t count) {\n-  _Copy_conjoint_jints_atomic(from, to, count);\n-}\n-\n-static void pd_conjoint_jlongs_atomic(const jlong* from, jlong* to, size_t count) {\n-  _Copy_conjoint_jlongs_atomic(from, to, count);\n-}\n-\n-static void pd_conjoint_oops_atomic(const oop* from, oop* to, size_t count) {\n-  assert(BytesPerLong == BytesPerOop, \"jlongs and oops must be the same size\");\n-  _Copy_conjoint_jlongs_atomic((const jlong*)from, (jlong*)to, count);\n-}\n-\n-static void pd_arrayof_conjoint_bytes(const HeapWord* from, HeapWord* to, size_t count) {\n-  _Copy_arrayof_conjoint_bytes(from, to, count);\n-}\n-\n-static void pd_arrayof_conjoint_jshorts(const HeapWord* from, HeapWord* to, size_t count) {\n-  _Copy_arrayof_conjoint_jshorts(from, to, count);\n-}\n-\n-static void pd_arrayof_conjoint_jints(const HeapWord* from, HeapWord* to, size_t count) {\n-   _Copy_arrayof_conjoint_jints(from, to, count);\n-}\n-\n-static void pd_arrayof_conjoint_jlongs(const HeapWord* from, HeapWord* to, size_t count) {\n-  _Copy_arrayof_conjoint_jlongs(from, to, count);\n-}\n-\n-static void pd_arrayof_conjoint_oops(const HeapWord* from, HeapWord* to, size_t count) {\n-  assert(!UseCompressedOops, \"foo!\");\n-  assert(BytesPerLong == BytesPerOop, \"jlongs and oops must be the same size\");\n-  _Copy_arrayof_conjoint_jlongs(from, to, count);\n-}\n+\/\/ Empty for build system\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/copy_bsd_aarch64.hpp","additions":1,"deletions":158,"binary":false,"changes":159,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2004, 2017, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,0 @@\n-        .globl SYMBOL(_Copy_conjoint_bytes)\n@@ -75,106 +74,0 @@\n-        # Support for void Copy::conjoint_bytes(void* from,\n-        #                                       void* to,\n-        #                                       size_t count)\n-        .p2align 4,,15\n-        ELF_TYPE(_Copy_conjoint_bytes,@function)\n-SYMBOL(_Copy_conjoint_bytes):\n-        pushl    %esi\n-        movl     4+12(%esp),%ecx      # count\n-        pushl    %edi\n-        movl     8+ 4(%esp),%esi      # from\n-        movl     8+ 8(%esp),%edi      # to\n-        cmpl     %esi,%edi\n-        leal     -1(%esi,%ecx),%eax   # from + count - 1\n-        jbe      cb_CopyRight\n-        cmpl     %eax,%edi\n-        jbe      cb_CopyLeft\n-        # copy from low to high\n-cb_CopyRight:\n-        cmpl     $3,%ecx\n-        jbe      5f                   # <= 3 bytes\n-        # align source address at dword address boundary\n-        movl     %ecx,%eax            # original count\n-        movl     $4,%ecx\n-        subl     %esi,%ecx\n-        andl     $3,%ecx              # prefix byte count\n-        jz       1f                   # no prefix\n-        subl     %ecx,%eax            # byte count less prefix\n-        # copy prefix\n-        subl     %esi,%edi\n-0:      movb     (%esi),%dl\n-        movb     %dl,(%edi,%esi,1)\n-        addl     $1,%esi\n-        subl     $1,%ecx\n-        jnz      0b\n-        addl     %esi,%edi\n-1:      movl     %eax,%ecx            # byte count less prefix\n-        shrl     $2,%ecx              # dword count\n-        jz       4f                   # no dwords to move\n-        cmpl     $32,%ecx\n-        jbe      2f                   # <= 32 dwords\n-        # copy aligned dwords\n-        rep;     smovl\n-        jmp      4f\n-        # copy aligned dwords\n-2:      subl     %esi,%edi\n-        .p2align 4,,15\n-3:      movl     (%esi),%edx\n-        movl     %edx,(%edi,%esi,1)\n-        addl     $4,%esi\n-        subl     $1,%ecx\n-        jnz      3b\n-        addl     %esi,%edi\n-4:      movl     %eax,%ecx            # byte count less prefix\n-5:      andl     $3,%ecx              # suffix byte count\n-        jz       7f                   # no suffix\n-        # copy suffix\n-        xorl     %eax,%eax\n-6:      movb     (%esi,%eax,1),%dl\n-        movb     %dl,(%edi,%eax,1)\n-        addl     $1,%eax\n-        subl     $1,%ecx\n-        jnz      6b\n-7:      popl     %edi\n-        popl     %esi\n-        ret\n-        # copy from high to low\n-cb_CopyLeft:\n-        std\n-        leal     -4(%edi,%ecx),%edi   # to + count - 4\n-        movl     %eax,%esi            # from + count - 1\n-        movl     %ecx,%eax\n-        subl     $3,%esi              # from + count - 4\n-        cmpl     $3,%ecx\n-        jbe      5f                   # <= 3 bytes\n-1:      shrl     $2,%ecx              # dword count\n-        jz       4f                   # no dwords to move\n-        cmpl     $32,%ecx\n-        ja       3f                   # > 32 dwords\n-        # copy dwords, aligned or not\n-        subl     %esi,%edi\n-        .p2align 4,,15\n-2:      movl     (%esi),%edx\n-        movl     %edx,(%edi,%esi,1)\n-        subl     $4,%esi\n-        subl     $1,%ecx\n-        jnz      2b\n-        addl     %esi,%edi\n-        jmp      4f\n-        # copy dwords, aligned or not\n-3:      rep;     smovl\n-4:      movl     %eax,%ecx            # byte count\n-5:      andl     $3,%ecx              # suffix byte count\n-        jz       7f                   # no suffix\n-        # copy suffix\n-        subl     %esi,%edi\n-        addl     $3,%esi\n-6:      movb     (%esi),%dl\n-        movb     %dl,(%edi,%esi,1)\n-        subl     $1,%esi\n-        subl     $1,%ecx\n-        jnz      6b\n-7:      cld\n-        popl     %edi\n-        popl     %esi\n-        ret\n-\n@@ -185,1 +78,0 @@\n-        # Same as _Copy_conjoint_bytes, except no source alignment check.\n","filename":"src\/hotspot\/os_cpu\/bsd_x86\/bsd_x86_32.S","additions":1,"deletions":109,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,280 +28,1 @@\n-static void pd_conjoint_words(const HeapWord* from, HeapWord* to, size_t count) {\n-#ifdef AMD64\n-  (void)memmove(to, from, count * HeapWordSize);\n-#else\n-  \/\/ Includes a zero-count check.\n-  intx temp;\n-  __asm__ volatile(\"        testl   %6,%6         ;\"\n-                   \"        jz      7f            ;\"\n-                   \"        cmpl    %4,%5         ;\"\n-                   \"        leal    -4(%4,%6,4),%3;\"\n-                   \"        jbe     1f            ;\"\n-                   \"        cmpl    %7,%5         ;\"\n-                   \"        jbe     4f            ;\"\n-                   \"1:      cmpl    $32,%6        ;\"\n-                   \"        ja      3f            ;\"\n-                   \"        subl    %4,%1         ;\"\n-                   \"2:      movl    (%4),%3       ;\"\n-                   \"        movl    %7,(%5,%4,1)  ;\"\n-                   \"        addl    $4,%0         ;\"\n-                   \"        subl    $1,%2          ;\"\n-                   \"        jnz     2b            ;\"\n-                   \"        jmp     7f            ;\"\n-                   \"3:      rep;    smovl         ;\"\n-                   \"        jmp     7f            ;\"\n-                   \"4:      cmpl    $32,%2        ;\"\n-                   \"        movl    %7,%0         ;\"\n-                   \"        leal    -4(%5,%6,4),%1;\"\n-                   \"        ja      6f            ;\"\n-                   \"        subl    %4,%1         ;\"\n-                   \"5:      movl    (%4),%3       ;\"\n-                   \"        movl    %7,(%5,%4,1)  ;\"\n-                   \"        subl    $4,%0         ;\"\n-                   \"        subl    $1,%2          ;\"\n-                   \"        jnz     5b            ;\"\n-                   \"        jmp     7f            ;\"\n-                   \"6:      std                   ;\"\n-                   \"        rep;    smovl         ;\"\n-                   \"        cld                   ;\"\n-                   \"7:      nop                    \"\n-                   : \"=S\" (from), \"=D\" (to), \"=c\" (count), \"=r\" (temp)\n-                   : \"0\"  (from), \"1\"  (to), \"2\"  (count), \"3\"  (temp)\n-                   : \"memory\", \"flags\");\n-#endif \/\/ AMD64\n-}\n-\n-static void pd_disjoint_words(const HeapWord* from, HeapWord* to, size_t count) {\n-#ifdef AMD64\n-  switch (count) {\n-  case 8:  to[7] = from[7];\n-  case 7:  to[6] = from[6];\n-  case 6:  to[5] = from[5];\n-  case 5:  to[4] = from[4];\n-  case 4:  to[3] = from[3];\n-  case 3:  to[2] = from[2];\n-  case 2:  to[1] = from[1];\n-  case 1:  to[0] = from[0];\n-  case 0:  break;\n-  default:\n-    (void)memcpy(to, from, count * HeapWordSize);\n-    break;\n-  }\n-#else\n-  \/\/ Includes a zero-count check.\n-  intx temp;\n-  __asm__ volatile(\"        testl   %6,%6       ;\"\n-                   \"        jz      3f          ;\"\n-                   \"        cmpl    $32,%6      ;\"\n-                   \"        ja      2f          ;\"\n-                   \"        subl    %4,%1       ;\"\n-                   \"1:      movl    (%4),%3     ;\"\n-                   \"        movl    %7,(%5,%4,1);\"\n-                   \"        addl    $4,%0       ;\"\n-                   \"        subl    $1,%2        ;\"\n-                   \"        jnz     1b          ;\"\n-                   \"        jmp     3f          ;\"\n-                   \"2:      rep;    smovl       ;\"\n-                   \"3:      nop                  \"\n-                   : \"=S\" (from), \"=D\" (to), \"=c\" (count), \"=r\" (temp)\n-                   : \"0\"  (from), \"1\"  (to), \"2\"  (count), \"3\"  (temp)\n-                   : \"memory\", \"cc\");\n-#endif \/\/ AMD64\n-}\n-\n-static void pd_disjoint_words_atomic(const HeapWord* from, HeapWord* to, size_t count) {\n-#ifdef AMD64\n-  switch (count) {\n-  case 8:  to[7] = from[7];\n-  case 7:  to[6] = from[6];\n-  case 6:  to[5] = from[5];\n-  case 5:  to[4] = from[4];\n-  case 4:  to[3] = from[3];\n-  case 3:  to[2] = from[2];\n-  case 2:  to[1] = from[1];\n-  case 1:  to[0] = from[0];\n-  case 0:  break;\n-  default:\n-    while (count-- > 0) {\n-      *to++ = *from++;\n-    }\n-    break;\n-  }\n-#else\n-  \/\/ pd_disjoint_words is word-atomic in this implementation.\n-  pd_disjoint_words(from, to, count);\n-#endif \/\/ AMD64\n-}\n-\n-static void pd_aligned_conjoint_words(const HeapWord* from, HeapWord* to, size_t count) {\n-  pd_conjoint_words(from, to, count);\n-}\n-\n-static void pd_aligned_disjoint_words(const HeapWord* from, HeapWord* to, size_t count) {\n-  pd_disjoint_words(from, to, count);\n-}\n-\n-static void pd_conjoint_bytes(const void* from, void* to, size_t count) {\n-#ifdef AMD64\n-  (void)memmove(to, from, count);\n-#else\n-  \/\/ Includes a zero-count check.\n-  intx temp;\n-  __asm__ volatile(\"        testl   %6,%6          ;\"\n-                   \"        jz      13f            ;\"\n-                   \"        cmpl    %4,%5          ;\"\n-                   \"        leal    -1(%4,%6),%3   ;\"\n-                   \"        jbe     1f             ;\"\n-                   \"        cmpl    %7,%5          ;\"\n-                   \"        jbe     8f             ;\"\n-                   \"1:      cmpl    $3,%6          ;\"\n-                   \"        jbe     6f             ;\"\n-                   \"        movl    %6,%3          ;\"\n-                   \"        movl    $4,%2          ;\"\n-                   \"        subl    %4,%2          ;\"\n-                   \"        andl    $3,%2          ;\"\n-                   \"        jz      2f             ;\"\n-                   \"        subl    %6,%3          ;\"\n-                   \"        rep;    smovb          ;\"\n-                   \"2:      movl    %7,%2          ;\"\n-                   \"        shrl    $2,%2          ;\"\n-                   \"        jz      5f             ;\"\n-                   \"        cmpl    $32,%2         ;\"\n-                   \"        ja      4f             ;\"\n-                   \"        subl    %4,%1          ;\"\n-                   \"3:      movl    (%4),%%edx     ;\"\n-                   \"        movl    %%edx,(%5,%4,1);\"\n-                   \"        addl    $4,%0          ;\"\n-                   \"        subl    $1,%2           ;\"\n-                   \"        jnz     3b             ;\"\n-                   \"        addl    %4,%1          ;\"\n-                   \"        jmp     5f             ;\"\n-                   \"4:      rep;    smovl          ;\"\n-                   \"5:      movl    %7,%2          ;\"\n-                   \"        andl    $3,%2          ;\"\n-                   \"        jz      13f            ;\"\n-                   \"6:      xorl    %7,%3          ;\"\n-                   \"7:      movb    (%4,%7,1),%%dl ;\"\n-                   \"        movb    %%dl,(%5,%7,1) ;\"\n-                   \"        addl    $1,%3          ;\"\n-                   \"        subl    $1,%2           ;\"\n-                   \"        jnz     7b             ;\"\n-                   \"        jmp     13f            ;\"\n-                   \"8:      std                    ;\"\n-                   \"        cmpl    $12,%2         ;\"\n-                   \"        ja      9f             ;\"\n-                   \"        movl    %7,%0          ;\"\n-                   \"        leal    -1(%6,%5),%1   ;\"\n-                   \"        jmp     11f            ;\"\n-                   \"9:      xchgl   %3,%2          ;\"\n-                   \"        movl    %6,%0          ;\"\n-                   \"        addl    $1,%2          ;\"\n-                   \"        leal    -1(%7,%5),%1   ;\"\n-                   \"        andl    $3,%2          ;\"\n-                   \"        jz      10f            ;\"\n-                   \"        subl    %6,%3          ;\"\n-                   \"        rep;    smovb          ;\"\n-                   \"10:     movl    %7,%2          ;\"\n-                   \"        subl    $3,%0          ;\"\n-                   \"        shrl    $2,%2          ;\"\n-                   \"        subl    $3,%1          ;\"\n-                   \"        rep;    smovl          ;\"\n-                   \"        andl    $3,%3          ;\"\n-                   \"        jz      12f            ;\"\n-                   \"        movl    %7,%2          ;\"\n-                   \"        addl    $3,%0          ;\"\n-                   \"        addl    $3,%1          ;\"\n-                   \"11:     rep;    smovb          ;\"\n-                   \"12:     cld                    ;\"\n-                   \"13:     nop                    ;\"\n-                   : \"=S\" (from), \"=D\" (to), \"=c\" (count), \"=r\" (temp)\n-                   : \"0\"  (from), \"1\"  (to), \"2\"  (count), \"3\"  (temp)\n-                   : \"memory\", \"flags\", \"%edx\");\n-#endif \/\/ AMD64\n-}\n-\n-static void pd_conjoint_bytes_atomic(const void* from, void* to, size_t count) {\n-  pd_conjoint_bytes(from, to, count);\n-}\n-\n-static void pd_conjoint_jshorts_atomic(const jshort* from, jshort* to, size_t count) {\n-  _Copy_conjoint_jshorts_atomic(from, to, count);\n-}\n-\n-static void pd_conjoint_jints_atomic(const jint* from, jint* to, size_t count) {\n-#ifdef AMD64\n-  _Copy_conjoint_jints_atomic(from, to, count);\n-#else\n-  assert(HeapWordSize == BytesPerInt, \"heapwords and jints must be the same size\");\n-  \/\/ pd_conjoint_words is word-atomic in this implementation.\n-  pd_conjoint_words((const HeapWord*)from, (HeapWord*)to, count);\n-#endif \/\/ AMD64\n-}\n-\n-static void pd_conjoint_jlongs_atomic(const jlong* from, jlong* to, size_t count) {\n-#ifdef AMD64\n-  _Copy_conjoint_jlongs_atomic(from, to, count);\n-#else\n-  \/\/ Guarantee use of fild\/fistp or xmm regs via some asm code, because compilers won't.\n-  if (from > to) {\n-    while (count-- > 0) {\n-      __asm__ volatile(\"fildll (%0); fistpll (%1)\"\n-                       :\n-                       : \"r\" (from), \"r\" (to)\n-                       : \"memory\" );\n-      ++from;\n-      ++to;\n-    }\n-  } else {\n-    while (count-- > 0) {\n-      __asm__ volatile(\"fildll (%0,%2,8); fistpll (%1,%2,8)\"\n-                       :\n-                       : \"r\" (from), \"r\" (to), \"r\" (count)\n-                       : \"memory\" );\n-    }\n-  }\n-#endif \/\/ AMD64\n-}\n-\n-static void pd_conjoint_oops_atomic(const oop* from, oop* to, size_t count) {\n-#ifdef AMD64\n-  assert(BytesPerLong == BytesPerOop, \"jlongs and oops must be the same size\");\n-  _Copy_conjoint_jlongs_atomic((const jlong*)from, (jlong*)to, count);\n-#else\n-  assert(HeapWordSize == BytesPerOop, \"heapwords and oops must be the same size\");\n-  \/\/ pd_conjoint_words is word-atomic in this implementation.\n-  pd_conjoint_words((const HeapWord*)from, (HeapWord*)to, count);\n-#endif \/\/ AMD64\n-}\n-\n-static void pd_arrayof_conjoint_bytes(const HeapWord* from, HeapWord* to, size_t count) {\n-  _Copy_arrayof_conjoint_bytes(from, to, count);\n-}\n-\n-static void pd_arrayof_conjoint_jshorts(const HeapWord* from, HeapWord* to, size_t count) {\n-  _Copy_arrayof_conjoint_jshorts(from, to, count);\n-}\n-\n-static void pd_arrayof_conjoint_jints(const HeapWord* from, HeapWord* to, size_t count) {\n-#ifdef AMD64\n-   _Copy_arrayof_conjoint_jints(from, to, count);\n-#else\n-  pd_conjoint_jints_atomic((const jint*)from, (jint*)to, count);\n-#endif \/\/ AMD64\n-}\n-\n-static void pd_arrayof_conjoint_jlongs(const HeapWord* from, HeapWord* to, size_t count) {\n-#ifdef AMD64\n-  _Copy_arrayof_conjoint_jlongs(from, to, count);\n-#else\n-  pd_conjoint_jlongs_atomic((const jlong*)from, (jlong*)to, count);\n-#endif \/\/ AMD64\n-}\n-\n-static void pd_arrayof_conjoint_oops(const HeapWord* from, HeapWord* to, size_t count) {\n-#ifdef AMD64\n-  assert(BytesPerLong == BytesPerOop, \"jlongs and oops must be the same size\");\n-  _Copy_arrayof_conjoint_jlongs(from, to, count);\n-#else\n-  pd_conjoint_oops_atomic((const oop*)from, (oop*)to, count);\n-#endif \/\/ AMD64\n-}\n+\/\/ Empty for build system\n","filename":"src\/hotspot\/os_cpu\/bsd_x86\/copy_bsd_x86.hpp","additions":2,"deletions":281,"binary":false,"changes":283,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,158 +29,1 @@\n-#define COPY_SMALL(from, to, count)                                     \\\n-{                                                                       \\\n-        long tmp0, tmp1, tmp2, tmp3;                                    \\\n-        long tmp4, tmp5, tmp6, tmp7;                                    \\\n-  __asm volatile(                                                       \\\n-\"       adr     %[t0], 0f;\"                                             \\\n-\"       add     %[t0], %[t0], %[cnt], lsl #5;\"                          \\\n-\"       br      %[t0];\"                                                 \\\n-\"       .align  5;\"                                                     \\\n-\"0:\"                                                                    \\\n-\"       b       1f;\"                                                    \\\n-\"       .align  5;\"                                                     \\\n-\"       ldr     %[t0], [%[s], #0];\"                                     \\\n-\"       str     %[t0], [%[d], #0];\"                                     \\\n-\"       b       1f;\"                                                    \\\n-\"       .align  5;\"                                                     \\\n-\"       ldp     %[t0], %[t1], [%[s], #0];\"                              \\\n-\"       stp     %[t0], %[t1], [%[d], #0];\"                              \\\n-\"       b       1f;\"                                                    \\\n-\"       .align  5;\"                                                     \\\n-\"       ldp     %[t0], %[t1], [%[s], #0];\"                              \\\n-\"       ldr     %[t2], [%[s], #16];\"                                    \\\n-\"       stp     %[t0], %[t1], [%[d], #0];\"                              \\\n-\"       str     %[t2], [%[d], #16];\"                                    \\\n-\"       b       1f;\"                                                    \\\n-\"       .align  5;\"                                                     \\\n-\"       ldp     %[t0], %[t1], [%[s], #0];\"                              \\\n-\"       ldp     %[t2], %[t3], [%[s], #16];\"                             \\\n-\"       stp     %[t0], %[t1], [%[d], #0];\"                              \\\n-\"       stp     %[t2], %[t3], [%[d], #16];\"                             \\\n-\"       b       1f;\"                                                    \\\n-\"       .align  5;\"                                                     \\\n-\"       ldp     %[t0], %[t1], [%[s], #0];\"                              \\\n-\"       ldp     %[t2], %[t3], [%[s], #16];\"                             \\\n-\"       ldr     %[t4], [%[s], #32];\"                                    \\\n-\"       stp     %[t0], %[t1], [%[d], #0];\"                              \\\n-\"       stp     %[t2], %[t3], [%[d], #16];\"                             \\\n-\"       str     %[t4], [%[d], #32];\"                                    \\\n-\"       b       1f;\"                                                    \\\n-\"       .align  5;\"                                                     \\\n-\"       ldp     %[t0], %[t1], [%[s], #0];\"                              \\\n-\"       ldp     %[t2], %[t3], [%[s], #16];\"                             \\\n-\"       ldp     %[t4], %[t5], [%[s], #32];\"                             \\\n-\"2:\"                                                                    \\\n-\"       stp     %[t0], %[t1], [%[d], #0];\"                              \\\n-\"       stp     %[t2], %[t3], [%[d], #16];\"                             \\\n-\"       stp     %[t4], %[t5], [%[d], #32];\"                             \\\n-\"       b       1f;\"                                                    \\\n-\"       .align  5;\"                                                     \\\n-\"       ldr     %[t6], [%[s], #0];\"                                     \\\n-\"       ldp     %[t0], %[t1], [%[s], #8];\"                              \\\n-\"       ldp     %[t2], %[t3], [%[s], #24];\"                             \\\n-\"       ldp     %[t4], %[t5], [%[s], #40];\"                             \\\n-\"       str     %[t6], [%[d]], #8;\"                                     \\\n-\"       b       2b;\"                                                    \\\n-\"       .align  5;\"                                                     \\\n-\"       ldp     %[t0], %[t1], [%[s], #0];\"                              \\\n-\"       ldp     %[t2], %[t3], [%[s], #16];\"                             \\\n-\"       ldp     %[t4], %[t5], [%[s], #32];\"                             \\\n-\"       ldp     %[t6], %[t7], [%[s], #48];\"                             \\\n-\"       stp     %[t0], %[t1], [%[d], #0];\"                              \\\n-\"       stp     %[t2], %[t3], [%[d], #16];\"                             \\\n-\"       stp     %[t4], %[t5], [%[d], #32];\"                             \\\n-\"       stp     %[t6], %[t7], [%[d], #48];\"                             \\\n-\"1:\"                                                                    \\\n-                                                                        \\\n-  : [s]\"+r\"(from), [d]\"+r\"(to), [cnt]\"+r\"(count),                       \\\n-    [t0]\"=&r\"(tmp0), [t1]\"=&r\"(tmp1), [t2]\"=&r\"(tmp2), [t3]\"=&r\"(tmp3), \\\n-    [t4]\"=&r\"(tmp4), [t5]\"=&r\"(tmp5), [t6]\"=&r\"(tmp6), [t7]\"=&r\"(tmp7)  \\\n-  :                                                                     \\\n-  : \"memory\", \"cc\");                                                    \\\n-}\n-\n-static void pd_conjoint_words(const HeapWord* from, HeapWord* to, size_t count) {\n-  __asm volatile( \"prfm pldl1strm, [%[s], #0];\" :: [s]\"r\"(from) : \"memory\");\n-  if (__builtin_expect(count <= 8, 1)) {\n-    COPY_SMALL(from, to, count);\n-    return;\n-  }\n-  _Copy_conjoint_words(from, to, count);\n-}\n-\n-static void pd_disjoint_words(const HeapWord* from, HeapWord* to, size_t count) {\n-  if (__builtin_constant_p(count)) {\n-    memcpy(to, from, count * sizeof(HeapWord));\n-    return;\n-  }\n-  __asm volatile( \"prfm pldl1strm, [%[s], #0];\" :: [s]\"r\"(from) : \"memory\");\n-  if (__builtin_expect(count <= 8, 1)) {\n-    COPY_SMALL(from, to, count);\n-    return;\n-  }\n-  _Copy_disjoint_words(from, to, count);\n-}\n-\n-static void pd_disjoint_words_atomic(const HeapWord* from, HeapWord* to, size_t count) {\n-  __asm volatile( \"prfm pldl1strm, [%[s], #0];\" :: [s]\"r\"(from) : \"memory\");\n-  if (__builtin_expect(count <= 8, 1)) {\n-    COPY_SMALL(from, to, count);\n-    return;\n-  }\n-  _Copy_disjoint_words(from, to, count);\n-}\n-\n-static void pd_aligned_conjoint_words(const HeapWord* from, HeapWord* to, size_t count) {\n-  pd_conjoint_words(from, to, count);\n-}\n-\n-static void pd_aligned_disjoint_words(const HeapWord* from, HeapWord* to, size_t count) {\n-  pd_disjoint_words(from, to, count);\n-}\n-\n-static void pd_conjoint_bytes(const void* from, void* to, size_t count) {\n-  (void)memmove(to, from, count);\n-}\n-\n-static void pd_conjoint_bytes_atomic(const void* from, void* to, size_t count) {\n-  pd_conjoint_bytes(from, to, count);\n-}\n-\n-static void pd_conjoint_jshorts_atomic(const jshort* from, jshort* to, size_t count) {\n-  _Copy_conjoint_jshorts_atomic(from, to, count);\n-}\n-\n-static void pd_conjoint_jints_atomic(const jint* from, jint* to, size_t count) {\n-  _Copy_conjoint_jints_atomic(from, to, count);\n-}\n-\n-static void pd_conjoint_jlongs_atomic(const jlong* from, jlong* to, size_t count) {\n-  _Copy_conjoint_jlongs_atomic(from, to, count);\n-}\n-\n-static void pd_conjoint_oops_atomic(const oop* from, oop* to, size_t count) {\n-  assert(BytesPerLong == BytesPerOop, \"jlongs and oops must be the same size\");\n-  _Copy_conjoint_jlongs_atomic((const jlong*)from, (jlong*)to, count);\n-}\n-\n-static void pd_arrayof_conjoint_bytes(const HeapWord* from, HeapWord* to, size_t count) {\n-  _Copy_arrayof_conjoint_bytes(from, to, count);\n-}\n-\n-static void pd_arrayof_conjoint_jshorts(const HeapWord* from, HeapWord* to, size_t count) {\n-  _Copy_arrayof_conjoint_jshorts(from, to, count);\n-}\n-\n-static void pd_arrayof_conjoint_jints(const HeapWord* from, HeapWord* to, size_t count) {\n-   _Copy_arrayof_conjoint_jints(from, to, count);\n-}\n-\n-static void pd_arrayof_conjoint_jlongs(const HeapWord* from, HeapWord* to, size_t count) {\n-  _Copy_arrayof_conjoint_jlongs(from, to, count);\n-}\n-\n-static void pd_arrayof_conjoint_oops(const HeapWord* from, HeapWord* to, size_t count) {\n-  assert(!UseCompressedOops, \"foo!\");\n-  assert(BytesPerLong == BytesPerOop, \"jlongs and oops must be the same size\");\n-  _Copy_arrayof_conjoint_jlongs(from, to, count);\n-}\n+\/\/ Empty for build system\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/copy_linux_aarch64.hpp","additions":2,"deletions":159,"binary":false,"changes":161,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2008, 2013, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,6 +61,0 @@\n-        # Support for void Copy::conjoint_bytes(void* from,\n-        #                                       void* to,\n-        #                                       size_t count)\n-_Copy_conjoint_bytes:\n-        swi     0x9f0001\n-\n","filename":"src\/hotspot\/os_cpu\/linux_arm\/linux_arm_32.S","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,280 +28,1 @@\n-static void pd_conjoint_words(const HeapWord* from, HeapWord* to, size_t count) {\n-#ifdef AMD64\n-  (void)memmove(to, from, count * HeapWordSize);\n-#else\n-  \/\/ Includes a zero-count check.\n-  intx temp = 0;\n-  __asm__ volatile(\"        testl   %6,%6         ;\"\n-                   \"        jz      7f            ;\"\n-                   \"        cmpl    %4,%5         ;\"\n-                   \"        leal    -4(%4,%6,4),%3;\"\n-                   \"        jbe     1f            ;\"\n-                   \"        cmpl    %7,%5         ;\"\n-                   \"        jbe     4f            ;\"\n-                   \"1:      cmpl    $32,%6        ;\"\n-                   \"        ja      3f            ;\"\n-                   \"        subl    %4,%1         ;\"\n-                   \"2:      movl    (%4),%3       ;\"\n-                   \"        movl    %7,(%5,%4,1)  ;\"\n-                   \"        addl    $4,%0         ;\"\n-                   \"        subl    $1,%2          ;\"\n-                   \"        jnz     2b            ;\"\n-                   \"        jmp     7f            ;\"\n-                   \"3:      rep;    smovl         ;\"\n-                   \"        jmp     7f            ;\"\n-                   \"4:      cmpl    $32,%2        ;\"\n-                   \"        movl    %7,%0         ;\"\n-                   \"        leal    -4(%5,%6,4),%1;\"\n-                   \"        ja      6f            ;\"\n-                   \"        subl    %4,%1         ;\"\n-                   \"5:      movl    (%4),%3       ;\"\n-                   \"        movl    %7,(%5,%4,1)  ;\"\n-                   \"        subl    $4,%0         ;\"\n-                   \"        subl    $1,%2          ;\"\n-                   \"        jnz     5b            ;\"\n-                   \"        jmp     7f            ;\"\n-                   \"6:      std                   ;\"\n-                   \"        rep;    smovl         ;\"\n-                   \"        cld                   ;\"\n-                   \"7:      nop                    \"\n-                   : \"=S\" (from), \"=D\" (to), \"=c\" (count), \"=r\" (temp)\n-                   : \"0\"  (from), \"1\"  (to), \"2\"  (count), \"3\"  (temp)\n-                   : \"memory\", \"flags\");\n-#endif \/\/ AMD64\n-}\n-\n-static void pd_disjoint_words(const HeapWord* from, HeapWord* to, size_t count) {\n-#ifdef AMD64\n-  switch (count) {\n-  case 8:  to[7] = from[7];\n-  case 7:  to[6] = from[6];\n-  case 6:  to[5] = from[5];\n-  case 5:  to[4] = from[4];\n-  case 4:  to[3] = from[3];\n-  case 3:  to[2] = from[2];\n-  case 2:  to[1] = from[1];\n-  case 1:  to[0] = from[0];\n-  case 0:  break;\n-  default:\n-    (void)memcpy(to, from, count * HeapWordSize);\n-    break;\n-  }\n-#else\n-  \/\/ Includes a zero-count check.\n-  intx temp = 0;\n-  __asm__ volatile(\"        testl   %6,%6       ;\"\n-                   \"        jz      3f          ;\"\n-                   \"        cmpl    $32,%6      ;\"\n-                   \"        ja      2f          ;\"\n-                   \"        subl    %4,%1       ;\"\n-                   \"1:      movl    (%4),%3     ;\"\n-                   \"        movl    %7,(%5,%4,1);\"\n-                   \"        addl    $4,%0       ;\"\n-                   \"        subl    $1,%2        ;\"\n-                   \"        jnz     1b          ;\"\n-                   \"        jmp     3f          ;\"\n-                   \"2:      rep;    smovl       ;\"\n-                   \"3:      nop                  \"\n-                   : \"=S\" (from), \"=D\" (to), \"=c\" (count), \"=r\" (temp)\n-                   : \"0\"  (from), \"1\"  (to), \"2\"  (count), \"3\"  (temp)\n-                   : \"memory\", \"cc\");\n-#endif \/\/ AMD64\n-}\n-\n-static void pd_disjoint_words_atomic(const HeapWord* from, HeapWord* to, size_t count) {\n-#ifdef AMD64\n-  switch (count) {\n-  case 8:  to[7] = from[7];\n-  case 7:  to[6] = from[6];\n-  case 6:  to[5] = from[5];\n-  case 5:  to[4] = from[4];\n-  case 4:  to[3] = from[3];\n-  case 3:  to[2] = from[2];\n-  case 2:  to[1] = from[1];\n-  case 1:  to[0] = from[0];\n-  case 0:  break;\n-  default:\n-    while (count-- > 0) {\n-      *to++ = *from++;\n-    }\n-    break;\n-  }\n-#else\n-  \/\/ pd_disjoint_words is word-atomic in this implementation.\n-  pd_disjoint_words(from, to, count);\n-#endif \/\/ AMD64\n-}\n-\n-static void pd_aligned_conjoint_words(const HeapWord* from, HeapWord* to, size_t count) {\n-  pd_conjoint_words(from, to, count);\n-}\n-\n-static void pd_aligned_disjoint_words(const HeapWord* from, HeapWord* to, size_t count) {\n-  pd_disjoint_words(from, to, count);\n-}\n-\n-static void pd_conjoint_bytes(const void* from, void* to, size_t count) {\n-#ifdef AMD64\n-  (void)memmove(to, from, count);\n-#else\n-  \/\/ Includes a zero-count check.\n-  intx temp = 0;\n-  __asm__ volatile(\"        testl   %6,%6          ;\"\n-                   \"        jz      13f            ;\"\n-                   \"        cmpl    %4,%5          ;\"\n-                   \"        leal    -1(%4,%6),%3   ;\"\n-                   \"        jbe     1f             ;\"\n-                   \"        cmpl    %7,%5          ;\"\n-                   \"        jbe     8f             ;\"\n-                   \"1:      cmpl    $3,%6          ;\"\n-                   \"        jbe     6f             ;\"\n-                   \"        movl    %6,%3          ;\"\n-                   \"        movl    $4,%2          ;\"\n-                   \"        subl    %4,%2          ;\"\n-                   \"        andl    $3,%2          ;\"\n-                   \"        jz      2f             ;\"\n-                   \"        subl    %6,%3          ;\"\n-                   \"        rep;    smovb          ;\"\n-                   \"2:      movl    %7,%2          ;\"\n-                   \"        shrl    $2,%2          ;\"\n-                   \"        jz      5f             ;\"\n-                   \"        cmpl    $32,%2         ;\"\n-                   \"        ja      4f             ;\"\n-                   \"        subl    %4,%1          ;\"\n-                   \"3:      movl    (%4),%%edx     ;\"\n-                   \"        movl    %%edx,(%5,%4,1);\"\n-                   \"        addl    $4,%0          ;\"\n-                   \"        subl    $1,%2           ;\"\n-                   \"        jnz     3b             ;\"\n-                   \"        addl    %4,%1          ;\"\n-                   \"        jmp     5f             ;\"\n-                   \"4:      rep;    smovl          ;\"\n-                   \"5:      movl    %7,%2          ;\"\n-                   \"        andl    $3,%2          ;\"\n-                   \"        jz      13f            ;\"\n-                   \"6:      xorl    %7,%3          ;\"\n-                   \"7:      movb    (%4,%7,1),%%dl ;\"\n-                   \"        movb    %%dl,(%5,%7,1) ;\"\n-                   \"        addl    $1,%3          ;\"\n-                   \"        subl    $1,%2           ;\"\n-                   \"        jnz     7b             ;\"\n-                   \"        jmp     13f            ;\"\n-                   \"8:      std                    ;\"\n-                   \"        cmpl    $12,%2         ;\"\n-                   \"        ja      9f             ;\"\n-                   \"        movl    %7,%0          ;\"\n-                   \"        leal    -1(%6,%5),%1   ;\"\n-                   \"        jmp     11f            ;\"\n-                   \"9:      xchgl   %3,%2          ;\"\n-                   \"        movl    %6,%0          ;\"\n-                   \"        addl    $1,%2          ;\"\n-                   \"        leal    -1(%7,%5),%1   ;\"\n-                   \"        andl    $3,%2          ;\"\n-                   \"        jz      10f            ;\"\n-                   \"        subl    %6,%3          ;\"\n-                   \"        rep;    smovb          ;\"\n-                   \"10:     movl    %7,%2          ;\"\n-                   \"        subl    $3,%0          ;\"\n-                   \"        shrl    $2,%2          ;\"\n-                   \"        subl    $3,%1          ;\"\n-                   \"        rep;    smovl          ;\"\n-                   \"        andl    $3,%3          ;\"\n-                   \"        jz      12f            ;\"\n-                   \"        movl    %7,%2          ;\"\n-                   \"        addl    $3,%0          ;\"\n-                   \"        addl    $3,%1          ;\"\n-                   \"11:     rep;    smovb          ;\"\n-                   \"12:     cld                    ;\"\n-                   \"13:     nop                    ;\"\n-                   : \"=S\" (from), \"=D\" (to), \"=c\" (count), \"=r\" (temp)\n-                   : \"0\"  (from), \"1\"  (to), \"2\"  (count), \"3\"  (temp)\n-                   : \"memory\", \"flags\", \"%edx\");\n-#endif \/\/ AMD64\n-}\n-\n-static void pd_conjoint_bytes_atomic(const void* from, void* to, size_t count) {\n-  pd_conjoint_bytes(from, to, count);\n-}\n-\n-static void pd_conjoint_jshorts_atomic(const jshort* from, jshort* to, size_t count) {\n-  _Copy_conjoint_jshorts_atomic(from, to, count);\n-}\n-\n-static void pd_conjoint_jints_atomic(const jint* from, jint* to, size_t count) {\n-#ifdef AMD64\n-  _Copy_conjoint_jints_atomic(from, to, count);\n-#else\n-  assert(HeapWordSize == BytesPerInt, \"heapwords and jints must be the same size\");\n-  \/\/ pd_conjoint_words is word-atomic in this implementation.\n-  pd_conjoint_words((const HeapWord*)from, (HeapWord*)to, count);\n-#endif \/\/ AMD64\n-}\n-\n-static void pd_conjoint_jlongs_atomic(const jlong* from, jlong* to, size_t count) {\n-#ifdef AMD64\n-  _Copy_conjoint_jlongs_atomic(from, to, count);\n-#else\n-  \/\/ Guarantee use of fild\/fistp or xmm regs via some asm code, because compilers won't.\n-  if (from > to) {\n-    while (count-- > 0) {\n-      __asm__ volatile(\"fildll (%0); fistpll (%1)\"\n-                       :\n-                       : \"r\" (from), \"r\" (to)\n-                       : \"memory\" );\n-      ++from;\n-      ++to;\n-    }\n-  } else {\n-    while (count-- > 0) {\n-      __asm__ volatile(\"fildll (%0,%2,8); fistpll (%1,%2,8)\"\n-                       :\n-                       : \"r\" (from), \"r\" (to), \"r\" (count)\n-                       : \"memory\" );\n-    }\n-  }\n-#endif \/\/ AMD64\n-}\n-\n-static void pd_conjoint_oops_atomic(const oop* from, oop* to, size_t count) {\n-#ifdef AMD64\n-  assert(BytesPerLong == BytesPerOop, \"jlongs and oops must be the same size\");\n-  _Copy_conjoint_jlongs_atomic((const jlong*)from, (jlong*)to, count);\n-#else\n-  assert(HeapWordSize == BytesPerOop, \"heapwords and oops must be the same size\");\n-  \/\/ pd_conjoint_words is word-atomic in this implementation.\n-  pd_conjoint_words((const HeapWord*)from, (HeapWord*)to, count);\n-#endif \/\/ AMD64\n-}\n-\n-static void pd_arrayof_conjoint_bytes(const HeapWord* from, HeapWord* to, size_t count) {\n-  _Copy_arrayof_conjoint_bytes(from, to, count);\n-}\n-\n-static void pd_arrayof_conjoint_jshorts(const HeapWord* from, HeapWord* to, size_t count) {\n-  _Copy_arrayof_conjoint_jshorts(from, to, count);\n-}\n-\n-static void pd_arrayof_conjoint_jints(const HeapWord* from, HeapWord* to, size_t count) {\n-#ifdef AMD64\n-   _Copy_arrayof_conjoint_jints(from, to, count);\n-#else\n-  pd_conjoint_jints_atomic((const jint*)from, (jint*)to, count);\n-#endif \/\/ AMD64\n-}\n-\n-static void pd_arrayof_conjoint_jlongs(const HeapWord* from, HeapWord* to, size_t count) {\n-#ifdef AMD64\n-  _Copy_arrayof_conjoint_jlongs(from, to, count);\n-#else\n-  pd_conjoint_jlongs_atomic((const jlong*)from, (jlong*)to, count);\n-#endif \/\/ AMD64\n-}\n-\n-static void pd_arrayof_conjoint_oops(const HeapWord* from, HeapWord* to, size_t count) {\n-#ifdef AMD64\n-  assert(BytesPerLong == BytesPerOop, \"jlongs and oops must be the same size\");\n-  _Copy_arrayof_conjoint_jlongs(from, to, count);\n-#else\n-  pd_conjoint_oops_atomic((const oop*)from, (oop*)to, count);\n-#endif \/\/ AMD64\n-}\n+\/\/ Empty for build system\n","filename":"src\/hotspot\/os_cpu\/linux_x86\/copy_linux_x86.hpp","additions":2,"deletions":281,"binary":false,"changes":283,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2004, 2017, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-        .globl _Copy_conjoint_bytes\n@@ -54,106 +53,0 @@\n-        # Support for void Copy::conjoint_bytes(void* from,\n-        #                                       void* to,\n-        #                                       size_t count)\n-        .p2align 4,,15\n-\t.type    _Copy_conjoint_bytes,@function\n-_Copy_conjoint_bytes:\n-        pushl    %esi\n-        movl     4+12(%esp),%ecx      # count\n-        pushl    %edi\n-        movl     8+ 4(%esp),%esi      # from\n-        movl     8+ 8(%esp),%edi      # to\n-        cmpl     %esi,%edi\n-        leal     -1(%esi,%ecx),%eax   # from + count - 1\n-        jbe      cb_CopyRight\n-        cmpl     %eax,%edi\n-        jbe      cb_CopyLeft\n-        # copy from low to high\n-cb_CopyRight:\n-        cmpl     $3,%ecx\n-        jbe      5f                   # <= 3 bytes\n-        # align source address at dword address boundary\n-        movl     %ecx,%eax            # original count\n-        movl     $4,%ecx\n-        subl     %esi,%ecx\n-        andl     $3,%ecx              # prefix byte count\n-        jz       1f                   # no prefix\n-        subl     %ecx,%eax            # byte count less prefix\n-        # copy prefix\n-        subl     %esi,%edi\n-0:      movb     (%esi),%dl\n-        movb     %dl,(%edi,%esi,1)\n-        addl     $1,%esi\n-        subl     $1,%ecx\n-        jnz      0b\n-        addl     %esi,%edi\n-1:      movl     %eax,%ecx            # byte count less prefix\n-        shrl     $2,%ecx              # dword count\n-        jz       4f                   # no dwords to move\n-        cmpl     $32,%ecx\n-        jbe      2f                   # <= 32 dwords\n-        # copy aligned dwords\n-        rep;     smovl\n-        jmp      4f\n-        # copy aligned dwords\n-2:      subl     %esi,%edi\n-        .p2align 4,,15\n-3:      movl     (%esi),%edx\n-        movl     %edx,(%edi,%esi,1)\n-        addl     $4,%esi\n-        subl     $1,%ecx\n-        jnz      3b\n-        addl     %esi,%edi\n-4:      movl     %eax,%ecx            # byte count less prefix\n-5:      andl     $3,%ecx              # suffix byte count\n-        jz       7f                   # no suffix\n-        # copy suffix\n-        xorl     %eax,%eax\n-6:      movb     (%esi,%eax,1),%dl\n-        movb     %dl,(%edi,%eax,1)\n-        addl     $1,%eax\n-        subl     $1,%ecx\n-        jnz      6b\n-7:      popl     %edi\n-        popl     %esi\n-        ret\n-        # copy from high to low\n-cb_CopyLeft:\n-        std\n-        leal     -4(%edi,%ecx),%edi   # to + count - 4\n-        movl     %eax,%esi            # from + count - 1\n-        movl     %ecx,%eax\n-        subl     $3,%esi              # from + count - 4\n-        cmpl     $3,%ecx\n-        jbe      5f                   # <= 3 bytes\n-1:      shrl     $2,%ecx              # dword count\n-        jz       4f                   # no dwords to move\n-        cmpl     $32,%ecx\n-        ja       3f                   # > 32 dwords\n-        # copy dwords, aligned or not\n-        subl     %esi,%edi\n-        .p2align 4,,15\n-2:      movl     (%esi),%edx\n-        movl     %edx,(%edi,%esi,1)\n-        subl     $4,%esi\n-        subl     $1,%ecx\n-        jnz      2b\n-        addl     %esi,%edi\n-        jmp      4f\n-        # copy dwords, aligned or not\n-3:      rep;     smovl\n-4:      movl     %eax,%ecx            # byte count\n-5:      andl     $3,%ecx              # suffix byte count\n-        jz       7f                   # no suffix\n-        # copy suffix\n-        subl     %esi,%edi\n-        addl     $3,%esi\n-6:      movb     (%esi),%dl\n-        movb     %dl,(%edi,%esi,1)\n-\tsubl     $1,%esi\n-        subl     $1,%ecx\n-        jnz      6b\n-7:      cld\n-        popl     %edi\n-        popl     %esi\n-        ret\n-\n@@ -164,1 +57,0 @@\n-        # Same as _Copy_conjoint_bytes, except no source alignment check.\n","filename":"src\/hotspot\/os_cpu\/linux_x86\/linux_x86_32.S","additions":1,"deletions":109,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,58 +28,0 @@\n-static void pd_conjoint_words(const HeapWord* from, HeapWord* to, size_t count) {\n-  (void)memmove(to, from, count * HeapWordSize);\n-}\n-\n-static void pd_disjoint_words(const HeapWord* from, HeapWord* to, size_t count) {\n-#ifdef AMD64\n-  switch (count) {\n-  case 8:  to[7] = from[7];\n-  case 7:  to[6] = from[6];\n-  case 6:  to[5] = from[5];\n-  case 5:  to[4] = from[4];\n-  case 4:  to[3] = from[3];\n-  case 3:  to[2] = from[2];\n-  case 2:  to[1] = from[1];\n-  case 1:  to[0] = from[0];\n-  case 0:  break;\n-  default:\n-    (void)memcpy(to, from, count * HeapWordSize);\n-    break;\n-  }\n-#else\n-  (void)memcpy(to, from, count * HeapWordSize);\n-#endif \/\/ AMD64\n-}\n-\n-static void pd_disjoint_words_atomic(const HeapWord* from, HeapWord* to, size_t count) {\n-  switch (count) {\n-  case 8:  to[7] = from[7];\n-  case 7:  to[6] = from[6];\n-  case 6:  to[5] = from[5];\n-  case 5:  to[4] = from[4];\n-  case 4:  to[3] = from[3];\n-  case 3:  to[2] = from[2];\n-  case 2:  to[1] = from[1];\n-  case 1:  to[0] = from[0];\n-  case 0:  break;\n-  default: while (count-- > 0) {\n-             *to++ = *from++;\n-           }\n-           break;\n-  }\n-}\n-\n-static void pd_aligned_conjoint_words(const HeapWord* from, HeapWord* to, size_t count) {\n-  (void)memmove(to, from, count * HeapWordSize);\n-}\n-\n-static void pd_aligned_disjoint_words(const HeapWord* from, HeapWord* to, size_t count) {\n-  pd_disjoint_words(from, to, count);\n-}\n-\n-static void pd_conjoint_bytes(const void* from, void* to, size_t count) {\n-  (void)memmove(to, from, count);\n-}\n-\n-static void pd_conjoint_bytes_atomic(const void* from, void* to, size_t count) {\n-  pd_conjoint_bytes(from, to, count);\n-}\n","filename":"src\/hotspot\/os_cpu\/windows_x86\/copy_windows_x86.hpp","additions":1,"deletions":59,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,9 +40,0 @@\n-  void _Copy_conjoint_words_atomic(const HeapWord* from, HeapWord* to, size_t count);\n-  void _Copy_disjoint_words_atomic(const HeapWord* from, HeapWord* to, size_t count);\n-\n-  void _Copy_aligned_conjoint_words(const HeapWord* from, HeapWord* to, size_t count);\n-  void _Copy_aligned_disjoint_words(const HeapWord* from, HeapWord* to, size_t count);\n-\n-  void _Copy_conjoint_bytes(const void* from, void* to, size_t count);\n-\n-  void _Copy_conjoint_bytes_atomic  (const void*   from, void*   to, size_t count);\n@@ -58,1 +49,0 @@\n-  void _Copy_arrayof_conjoint_oops   (const HeapWord* from, HeapWord* to, size_t count);\n","filename":"src\/hotspot\/share\/utilities\/copy.hpp","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"}]}