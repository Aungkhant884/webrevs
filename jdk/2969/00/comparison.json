{"files":[{"patch":"@@ -569,49 +569,0 @@\n-    \/** Factory method:  Spread selected argument. *\/\n-    static MethodHandle makeSpreadArguments(MethodHandle target,\n-                                            Class<?> spreadArgType, int spreadArgPos, int spreadArgCount) {\n-        MethodType targetType = target.type();\n-\n-        for (int i = 0; i < spreadArgCount; i++) {\n-            Class<?> arg = VerifyType.spreadArgElementType(spreadArgType, i);\n-            if (arg == null)  arg = Object.class;\n-            targetType = targetType.changeParameterType(spreadArgPos + i, arg);\n-        }\n-        target = target.asType(targetType);\n-\n-        MethodType srcType = targetType\n-                .replaceParameterTypes(spreadArgPos, spreadArgPos + spreadArgCount, spreadArgType);\n-        \/\/ Now build a LambdaForm.\n-        MethodType lambdaType = srcType.invokerType();\n-        Name[] names = arguments(spreadArgCount + 2, lambdaType);\n-        int nameCursor = lambdaType.parameterCount();\n-        int[] indexes = new int[targetType.parameterCount()];\n-\n-        for (int i = 0, argIndex = 1; i < targetType.parameterCount() + 1; i++, argIndex++) {\n-            Class<?> src = lambdaType.parameterType(i);\n-            if (i == spreadArgPos) {\n-                \/\/ Spread the array.\n-                MethodHandle aload = MethodHandles.arrayElementGetter(spreadArgType);\n-                Name array = names[argIndex];\n-                names[nameCursor++] = new Name(getFunction(NF_checkSpreadArgument), array, spreadArgCount);\n-                for (int j = 0; j < spreadArgCount; i++, j++) {\n-                    indexes[i] = nameCursor;\n-                    names[nameCursor++] = new Name(new NamedFunction(aload, Intrinsic.ARRAY_LOAD), array, j);\n-                }\n-            } else if (i < indexes.length) {\n-                indexes[i] = argIndex;\n-            }\n-        }\n-        assert(nameCursor == names.length-1);  \/\/ leave room for the final call\n-\n-        \/\/ Build argument array for the call.\n-        Name[] targetArgs = new Name[targetType.parameterCount()];\n-        for (int i = 0; i < targetType.parameterCount(); i++) {\n-            int idx = indexes[i];\n-            targetArgs[i] = names[idx];\n-        }\n-        names[names.length - 1] = new Name(target, (Object[]) targetArgs);\n-\n-        LambdaForm form = new LambdaForm(lambdaType.parameterCount(), names, Kind.SPREAD);\n-        return SimpleMethodHandle.make(srcType, form);\n-    }\n-\n@@ -634,54 +585,0 @@\n-    \/** Factory method:  Collect or filter selected argument(s). *\/\n-    static MethodHandle makeCollectArguments(MethodHandle target,\n-                MethodHandle collector, int collectArgPos, boolean retainOriginalArgs) {\n-        MethodType targetType = target.type();          \/\/ (a..., c, [b...])=>r\n-        MethodType collectorType = collector.type();    \/\/ (b...)=>c\n-        int collectArgCount = collectorType.parameterCount();\n-        Class<?> collectValType = collectorType.returnType();\n-        int collectValCount = (collectValType == void.class ? 0 : 1);\n-        MethodType srcType = targetType                 \/\/ (a..., [b...])=>r\n-                .dropParameterTypes(collectArgPos, collectArgPos+collectValCount);\n-        if (!retainOriginalArgs) {                      \/\/ (a..., b...)=>r\n-            srcType = srcType.insertParameterTypes(collectArgPos, collectorType.parameterArray());\n-        }\n-        \/\/ in  arglist: [0: ...keep1 | cpos: collect...  | cpos+cacount: keep2... ]\n-        \/\/ out arglist: [0: ...keep1 | cpos: collectVal? | cpos+cvcount: keep2... ]\n-        \/\/ out(retain): [0: ...keep1 | cpos: cV? coll... | cpos+cvc+cac: keep2... ]\n-\n-        \/\/ Now build a LambdaForm.\n-        MethodType lambdaType = srcType.invokerType();\n-        Name[] names = arguments(2, lambdaType);\n-        final int collectNamePos = names.length - 2;\n-        final int targetNamePos  = names.length - 1;\n-\n-        Name[] collectorArgs = Arrays.copyOfRange(names, 1 + collectArgPos, 1 + collectArgPos + collectArgCount);\n-        names[collectNamePos] = new Name(collector, (Object[]) collectorArgs);\n-\n-        \/\/ Build argument array for the target.\n-        \/\/ Incoming LF args to copy are: [ (mh) headArgs collectArgs tailArgs ].\n-        \/\/ Output argument array is [ headArgs (collectVal)? (collectArgs)? tailArgs ].\n-        Name[] targetArgs = new Name[targetType.parameterCount()];\n-        int inputArgPos  = 1;  \/\/ incoming LF args to copy to target\n-        int targetArgPos = 0;  \/\/ fill pointer for targetArgs\n-        int chunk = collectArgPos;  \/\/ |headArgs|\n-        System.arraycopy(names, inputArgPos, targetArgs, targetArgPos, chunk);\n-        inputArgPos  += chunk;\n-        targetArgPos += chunk;\n-        if (collectValType != void.class) {\n-            targetArgs[targetArgPos++] = names[collectNamePos];\n-        }\n-        chunk = collectArgCount;\n-        if (retainOriginalArgs) {\n-            System.arraycopy(names, inputArgPos, targetArgs, targetArgPos, chunk);\n-            targetArgPos += chunk;   \/\/ optionally pass on the collected chunk\n-        }\n-        inputArgPos += chunk;\n-        chunk = targetArgs.length - targetArgPos;  \/\/ all the rest\n-        System.arraycopy(names, inputArgPos, targetArgs, targetArgPos, chunk);\n-        assert(inputArgPos + chunk == collectNamePos);  \/\/ use of rest of input args also\n-        names[targetNamePos] = new Name(target, (Object[]) targetArgs);\n-\n-        LambdaForm form = new LambdaForm(lambdaType.parameterCount(), names, Kind.COLLECT);\n-        return SimpleMethodHandle.make(srcType, form);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":0,"deletions":103,"binary":false,"changes":103,"status":"modified"}]}