{"files":[{"patch":"@@ -1410,6 +1410,1 @@\n-                if (fk != null) {\n-                    \/\/ use file value, hashCode will use fileKey()\n-                    this.file = file;\n-                } else {\n-                    this.file = getCanonicalFile(file);\n-                }\n+                this.file = (fk != null) ? file : getCanonicalFile(file);\n@@ -1421,6 +1416,9 @@\n-                try {\n-                    return System.getSecurityManager() != null ?\n-                        AccessController.doPrivileged((PrivilegedExceptionAction<File>) file::getCanonicalFile) :\n-                        file.getCanonicalFile();\n-                } catch (PrivilegedActionException e) {\n-                    throw new IOException(e);\n+                if (System.getSecurityManager() == null) {\n+                    return file.getCanonicalFile();\n+                } else {\n+                    try {\n+                        return AccessController.doPrivileged(\n+                                (PrivilegedExceptionAction<File>) file::getCanonicalFile);\n+                    } catch (PrivilegedActionException pae) {\n+                        throw new IOException(pae.getException());\n+                    }\n@@ -1432,0 +1430,1 @@\n+                t += attrs.lastModifiedTime().toMillis();\n@@ -1433,3 +1432,0 @@\n-                if (fk == null) {\n-                    t += attrs.lastModifiedTime().toMillis();\n-                }\n@@ -1445,0 +1441,3 @@\n+                    if (!attrs.lastModifiedTime().equals(key.attrs.lastModifiedTime())) {\n+                        return false;\n+                    }\n@@ -1448,0 +1447,2 @@\n+                    } else {\n+                        return file.equals(key.file);\n@@ -1449,4 +1450,0 @@\n-                    if (!attrs.lastModifiedTime().equals(key.attrs.lastModifiedTime())) {\n-                        return false;\n-                    }\n-                    return file.equals(key.file);\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipFile.java","additions":16,"deletions":19,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @run testng\/othervm ZipSourceCache\n+ * @run junit\/othervm ZipSourceCache\n@@ -31,4 +31,0 @@\n-import org.testng.annotations.AfterTest;\n-import org.testng.annotations.BeforeTest;\n-import org.testng.annotations.Test;\n-\n@@ -41,1 +37,4 @@\n-import static org.testng.Assert.*;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.AfterAll;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -48,0 +47,1 @@\n+    private static final boolean DEBUG = false;\n@@ -52,3 +52,3 @@\n-    @BeforeTest\n-    public void setup() throws Exception {\n-        createZipFile();\n+    @BeforeAll\n+    public static void setup() throws Exception {\n+        createZipFile(\"test1\");\n@@ -57,2 +57,2 @@\n-    @AfterTest\n-    public void cleanup() throws IOException {\n+    @AfterAll\n+    public static void cleanup() throws IOException {\n@@ -63,1 +63,1 @@\n-    public static void test() throws Exception {\n+    public void test() throws Exception {\n@@ -65,0 +65,2 @@\n+        HashMap internalMap;\n+        int numSources;\n@@ -69,2 +71,2 @@\n-            HashMap internalMap = (HashMap) filesMap.get(zipFile);\n-            int numSources = internalMap.size();\n+            internalMap = (HashMap) filesMap.get(zipFile);\n+            numSources = internalMap.size();\n@@ -73,1 +75,15 @@\n-            assertEquals(internalMap.size(), numSources);\n+            assertEquals(numSources, internalMap.size());\n+\n+            \/\/ create new zip file with same name, should expect a new Source Object\n+            \/\/ ignore this part of test if file can't be created (can't overwrite)\n+            if (createZipFile(\"differentContent\")) {\n+                ZipFile z = new ZipFile(ZIPFILE_NAME);\n+                \/\/ new Source created, should map fine\n+                readZipFileContents(z);\n+                \/\/ the old Source in use for old file, should no longer map correctly\n+                IOException ioe = assertThrows(IOException.class, () -> readZipFileContents(absoluteZipFile));\n+                assertEquals(ioe.getMessage(), \"ZipFile invalid LOC header (bad signature)\");\n+                assertEquals(++numSources, internalMap.size());\n+                z.close();\n+                assertEquals(--numSources, internalMap.size());\n+            }\n@@ -75,0 +91,3 @@\n+        \/\/ the close() call shouldn't remove the Source entry\n+        \/\/ just yet since we still have one reference to the file\n+        assertEquals(numSources, internalMap.size());\n@@ -78,0 +97,11 @@\n+        \/\/ now, the Source entry key should be removed\n+        assertEquals(--numSources, internalMap.size());\n+    }\n+\n+    private static void readZipFileContents(ZipFile zf) throws IOException {\n+        var e = zf.entries();\n+        while (e.hasMoreElements()) {\n+            InputStream is = zf.getInputStream(e.nextElement());\n+            String s = new String(is.readAllBytes());\n+            if (DEBUG) System.err.println(s);\n+        }\n@@ -80,1 +110,1 @@\n-    private static void createZipFile() throws Exception {\n+    private static boolean createZipFile(String content) {\n@@ -83,0 +113,3 @@\n+        \/\/ let's have at least 2 entries created to ensure\n+        \/\/ that a bad zip structure is detected if file is overwritten\n+        int numEntries = new Random().nextInt(10) + 2;\n@@ -87,10 +120,16 @@\n-            ZipEntry e = new ZipEntry(ZIPENTRY_NAME);\n-            e.setMethod(ZipEntry.STORED);\n-            byte[] toWrite = \"BLAH\".getBytes();\n-            e.setTime(t);\n-            e.setSize(toWrite.length);\n-            crc32.reset();\n-            crc32.update(toWrite);\n-            e.setCrc(crc32.getValue());\n-            zos.putNextEntry(e);\n-            zos.write(toWrite);\n+            for (int i = 0; i < numEntries; i++) {\n+                ZipEntry e = new ZipEntry(ZIPENTRY_NAME + i);\n+                e.setMethod(ZipEntry.STORED);\n+                byte[] toWrite = content.repeat(i+1).getBytes();\n+                e.setTime(t);\n+                e.setSize(toWrite.length);\n+                crc32.reset();\n+                crc32.update(toWrite);\n+                e.setCrc(crc32.getValue());\n+                zos.putNextEntry(e);\n+                zos.write(toWrite);\n+            }\n+        } catch (IOException e) {\n+            \/\/ some systems mightn't allow file to be overwritten\n+            System.err.println(\"error creating file. \" + e);\n+            return false;\n@@ -98,0 +137,1 @@\n+        return true;\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/ZipSourceCache.java","additions":66,"deletions":26,"binary":false,"changes":92,"status":"modified"}]}