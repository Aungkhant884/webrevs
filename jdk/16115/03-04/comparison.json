{"files":[{"patch":"@@ -1419,0 +1419,1 @@\n+                    PrivilegedExceptionAction<File> pa = file::getCanonicalFile;\n@@ -1420,2 +1421,1 @@\n-                        return AccessController.doPrivileged(\n-                                (PrivilegedExceptionAction<File>) file::getCanonicalFile);\n+                        return AccessController.doPrivileged(pa);\n@@ -1423,1 +1423,6 @@\n-                        throw new IOException(pae.getException());\n+                        Throwable cause = pae.getCause();\n+                        if (cause instanceof IOException ioe) {\n+                            throw ioe;\n+                        } else {\n+                            throw new IOException(cause);\n+                        }\n@@ -1430,0 +1435,5 @@\n+                \/*\n+                 * The lastModifiedTime attribute is used to detect cases where\n+                 * an existing file is updated. The other hash code properties\n+                 * by themselves won't detect such a change.\n+                 *\/\n@@ -1441,0 +1451,4 @@\n+                    \/*\n+                     * The lastModifiedTime attribute is used to detect cases where\n+                     * an existing file is updated.\n+                     *\/\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipFile.java","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-        Files.deleteIfExists(Path.of(ZIPENTRY_NAME));\n+        Files.deleteIfExists(Path.of(ZIPFILE_NAME));\n@@ -62,0 +62,7 @@\n+    \/*\n+     * Monitor the internal \"files\" HashMap to ensure that we only\n+     * create one <Key, Source> mapping per unique zip file.\n+     *\n+     * This test also ensures that a new <Key, Source> mapping is created\n+     * if an update to an existing zip file is detected.\n+     *\/\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/ZipSourceCache.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"}]}