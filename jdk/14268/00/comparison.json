{"files":[{"patch":"@@ -3710,2 +3710,6 @@\n-      nn = nn->in(1);\n-      set_velt_type(n, velt_type(nn));\n+      \/\/ One of the inputs must be in_bb, pick that velt_type\n+      if (in_bb(nn->in(1))) {\n+        set_velt_type(n, velt_type(nn->in(1)));\n+      } else {\n+        set_velt_type(n, velt_type(nn->in(2)));\n+      }\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -593,0 +593,26 @@\n+    \/\/ Use some constants in the comparison\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \">0\", IRNode.VECTOR_MASK_CMP, \">0\", IRNode.VECTOR_BLEND, \">0\", IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    private static void testCMoveFGTforFCmpCon1(float a, float[] b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < b.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a > b[i]) ? cc : dd;\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_VECTOR, \">0\", IRNode.VECTOR_MASK_CMP, \">0\", IRNode.VECTOR_BLEND, \">0\", IRNode.STORE_VECTOR, \">0\"},\n+        applyIfCPUFeatureOr = {\"avx\", \"true\", \"asimd\", \"true\"})\n+    private static void testCMoveFGTforFCmpCon2(float[] a, float b, float[] c, float[] d, float[] r, float[] r2) {\n+        for (int i = 0; i < a.length; i++) {\n+            float cc = c[i];\n+            float dd = d[i];\n+            r2[i] = cc + dd;\n+            r[i] = (a[i] > b) ? cc : dd;\n+        }\n+    }\n+\n+    \/\/ A case that is currently not supported and is not expected to vectorize\n@@ -726,1 +752,3 @@\n-                 \"testCMoveDGTforD\"})\n+                 \"testCMoveDGTforD\",\n+                 \"testCMoveFGTforFCmpCon1\",\n+                 \"testCMoveFGTforFCmpCon2\"})\n@@ -845,0 +873,12 @@\n+\n+\n+        \/\/ Use some constaints in the comparison\n+        testCMoveFGTforFCmpCon1(aF[0], bF, cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveFGTforF(aF[0], bF[i], cF[i], dF[i]));\n+        }\n+\n+        testCMoveFGTforFCmpCon2(aF, bF[0], cF, dF, rF, rF);\n+        for (int i = 0; i < SIZE; i++) {\n+            Asserts.assertEquals(rF[i], cmoveFGTforF(aF[i], bF[0], cF[i], dF[i]));\n+        }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestVectorConditionalMove.java","additions":41,"deletions":1,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8309268\n+ * @summary Test loop invariant input to Cmp.\n+ *\n+ * @run main\/othervm -Xcomp -XX:-TieredCompilation\n+ *      -XX:CompileCommand=compileonly,compiler.loopopts.superword.TestCmpInvar::test*\n+ *      compiler.loopopts.superword.TestCmpInvar\n+ *\/\n+package compiler.loopopts.superword;\n+\n+public class TestCmpInvar {\n+    static int N = 400;\n+    static long myInvar;\n+\n+    static void test1(int limit, float fcon) {\n+        boolean a[] = new boolean[1000];\n+        for (int i = 0; i < limit; i++) {\n+            a[i] = fcon > i;\n+        }\n+    }\n+\n+    static void test2(int limit, float fcon) {\n+        boolean a[] = new boolean[1000];\n+        for (int i = 0; i < limit; i++) {\n+            a[i] = i > fcon;\n+        }\n+    }\n+\n+    static int test3() {\n+        int[] a = new int[N];\n+        int acc = 0;\n+        for (int i = 1; i < 63; i++) {\n+            acc += Math.min(myInvar, a[i]--);\n+        }\n+        return acc;\n+    }\n+\n+    static int test4() {\n+        int[] a = new int[N];\n+        int acc = 0;\n+        for (int i = 1; i < 63; i++) {\n+            acc += Math.min(a[i]--, myInvar);\n+        }\n+        return acc;\n+    }\n+\n+    public static void main(String[] strArr) {\n+        for (int i = 0; i < 10_100; i++) {\n+            test1(500, 80.1f);\n+        }\n+\n+        for (int i = 0; i < 10_100; i++) {\n+            test2(500, 80.1f);\n+        }\n+\n+        for (int i = 0; i < 10_000; i++) {\n+            test3();\n+        }\n+\n+        for (int i = 0; i < 10_000; i++) {\n+            test4();\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestCmpInvar.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"}]}