{"files":[{"patch":"@@ -141,0 +141,7 @@\n+\n+\/\/ For a ParmNode, all immediate inputs and outputs are considered relevant\n+\/\/ both in compact and standard representation.\n+void ParmNode::related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const {\n+  this->collect_nodes(in_rel, 1, false, false);\n+  this->collect_nodes(out_rel, -1, false, false);\n+}\n@@ -1472,0 +1479,13 @@\n+\n+\/\/ The related nodes of a SafepointNode are all data inputs, excluding the\n+\/\/ control boundary, as well as all outputs till level 2 (to include projection\n+\/\/ nodes and targets). In compact mode, just include inputs till level 1 and\n+\/\/ outputs as before.\n+void SafePointNode::related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const {\n+  if (compact) {\n+    this->collect_nodes(in_rel, 1, false, false);\n+  } else {\n+    this->collect_nodes_in_all_data(in_rel, false);\n+  }\n+  this->collect_nodes(out_rel, -2, false, false);\n+}\n@@ -2035,0 +2055,10 @@\n+\n+\/\/ The related set of lock nodes includes the control boundary.\n+void AbstractLockNode::related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const {\n+  if (compact) {\n+      this->collect_nodes(in_rel, 1, false, false);\n+    } else {\n+      this->collect_nodes_in_all_data(in_rel, true);\n+    }\n+    this->collect_nodes(out_rel, -2, false, false);\n+}\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -112,0 +112,1 @@\n+  virtual void related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const;\n@@ -501,0 +502,1 @@\n+  virtual void           related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const;\n@@ -1116,0 +1118,1 @@\n+  virtual void related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const;\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2576,0 +2576,8 @@\n+void PhiNode::related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const {\n+  \/\/ For a PhiNode, the set of related nodes includes all inputs till level 2,\n+  \/\/ and all outputs till level 1. In compact mode, inputs till level 1 are\n+  \/\/ collected.\n+  this->collect_nodes(in_rel, compact ? 1 : 2, false, false);\n+  this->collect_nodes(out_rel, -1, false, false);\n+}\n+\n@@ -2600,0 +2608,11 @@\n+#ifndef PRODUCT\n+\/\/-----------------------------related-----------------------------------------\n+\/\/ The related nodes of a GotoNode are all inputs at level 1, as well as the\n+\/\/ outputs at level 1. This is regardless of compact mode.\n+void GotoNode::related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const {\n+  this->collect_nodes(in_rel, 1, false, false);\n+  this->collect_nodes(out_rel, -1, false, false);\n+}\n+#endif\n+\n+\n@@ -2605,0 +2624,11 @@\n+#ifndef PRODUCT\n+\/\/-----------------------------related-----------------------------------------\n+\/\/ The related nodes of a JumpNode are all inputs at level 1, as well as the\n+\/\/ outputs at level 2 (to include actual jump targets beyond projection nodes).\n+\/\/ This is regardless of compact mode.\n+void JumpNode::related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const {\n+  this->collect_nodes(in_rel, 1, false, false);\n+  this->collect_nodes(out_rel, -2, false, false);\n+}\n+#endif\n+\n@@ -2665,0 +2695,6 @@\n+\n+void JumpProjNode::related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const {\n+  \/\/ The related nodes of a JumpProjNode are its inputs and outputs at level 1.\n+  this->collect_nodes(in_rel, 1, false, false);\n+  this->collect_nodes(out_rel, -1, false, false);\n+}\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -227,0 +227,1 @@\n+  virtual void related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const;\n@@ -252,0 +253,4 @@\n+\n+#ifndef PRODUCT\n+  virtual void related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const;\n+#endif\n@@ -404,0 +409,1 @@\n+  virtual void related(GrowableArray <Node *> *in_rel, GrowableArray <Node *> *out_rel, bool compact) const;\n@@ -429,0 +435,5 @@\n+\n+#ifndef PRODUCT\n+public:\n+  virtual void related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const;\n+#endif\n@@ -496,0 +507,3 @@\n+#ifndef PRODUCT\n+  virtual void related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const;\n+#endif\n@@ -521,0 +535,1 @@\n+  virtual void related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const;\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1741,0 +1741,15 @@\n+\/\/-------------------------------related---------------------------------------\n+\/\/ An IfProjNode's related node set consists of its input (an IfNode) including\n+\/\/ the IfNode's condition, plus all of its outputs at level 1. In compact mode,\n+\/\/ the restrictions for IfNode apply (see IfNode::rel).\n+void IfProjNode::related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const {\n+  Node* ifNode = this->in(0);\n+  in_rel->append(ifNode);\n+  if (compact) {\n+    ifNode->collect_nodes(in_rel, 3, false, true);\n+  } else {\n+    ifNode->collect_nodes_in_all_data(in_rel, false);\n+  }\n+  this->collect_nodes(out_rel, -1, false, false);\n+}\n+\n@@ -1745,0 +1760,15 @@\n+\n+\/\/-------------------------------related---------------------------------------\n+\/\/ For an IfNode, the set of related output nodes is just the output nodes till\n+\/\/ depth 2, i.e, the IfTrue\/IfFalse projection nodes plus the nodes they refer.\n+\/\/ The related input nodes contain no control nodes, but all data nodes\n+\/\/ pertaining to the condition. In compact mode, the input nodes are collected\n+\/\/ up to a depth of 3.\n+void IfNode::related(GrowableArray <Node *> *in_rel, GrowableArray <Node *> *out_rel, bool compact) const {\n+  if (compact) {\n+    this->collect_nodes(in_rel, 3, false, true);\n+  } else {\n+    this->collect_nodes_in_all_data(in_rel, false);\n+  }\n+  this->collect_nodes(out_rel, -2, false, false);\n+}\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":30,"deletions":0,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -465,0 +465,15 @@\n+\n+#ifndef PRODUCT\n+\/\/----------------------------BinaryNode---------------------------------------\n+\/\/ The set of related nodes for a BinaryNode is all data inputs and all outputs\n+\/\/ till level 2 (i.e., one beyond the associated CMoveNode). In compact mode,\n+\/\/ it's the inputs till level 1 and the outputs till level 2.\n+void BinaryNode::related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const {\n+  if (compact) {\n+    this->collect_nodes(in_rel, 1, false, true);\n+  } else {\n+    this->collect_nodes_in_all_data(in_rel, false);\n+  }\n+  this->collect_nodes(out_rel, -2, false, false);\n+}\n+#endif\n","filename":"src\/hotspot\/share\/opto\/movenode.cpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -163,0 +163,4 @@\n+\n+#ifndef PRODUCT\n+  virtual void related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const;\n+#endif\n","filename":"src\/hotspot\/share\/opto\/movenode.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1817,1 +1817,1 @@\n-    tty->print(\"dump_bfs: max_distance must be non-negative!\\n\");\n+    tty->print(\"print_bfs: max_distance must be non-negative!\\n\");\n@@ -1821,0 +1821,10 @@\n+\n+  if (_target == nullptr) {\n+    tty->print(\"No target: perform BFS.\\n\");\n+  } else {\n+    tty->print(\"Find shortest path:\");\n+    print_node_idx(_start);\n+    tty->print(\" ->\");\n+    print_node_idx(_target);\n+    tty->print(\"\\n\");\n+  }\n@@ -2100,1 +2110,1 @@\n-\/\/------------------------------dump_bfs--------------------------------------\n+\/\/------------------------------print_bfs--------------------------------------\n@@ -2131,1 +2141,1 @@\n-\/\/   if->dump_bfs(10, 0, \"+cxo\")\n+\/\/   if->print_bfs(10, 0, \"+cxo\")\n@@ -2134,1 +2144,1 @@\n-\/\/   phi->dump_bfs(5, 0, \"-dxo\")\n+\/\/   phi->print_bfs(5, 0, \"-dxo\")\n@@ -2137,1 +2147,1 @@\n-\/\/   x->dump_bfs(10, y, 0)\n+\/\/   x->print_bfs(10, y, 0)\n@@ -2141,1 +2151,1 @@\n-\/\/   find_node(385)->dump_bfs(3, 0, \"cdmox+#OB\")\n+\/\/   find_node(385)->print_bfs(3, 0, \"cdmox+#OB\")\n@@ -2153,2 +2163,2 @@\n-void Node::dump_bfs(const int max_distance, Node* target, char const* options) const {\n-  PrintBFS bfs((Node*)this, max_distance, target, options);\n+void Node::print_bfs(const int max_distance, Node* target, char const* options) {\n+  PrintBFS bfs(this, max_distance, target, options);\n@@ -2412,4 +2422,60 @@\n-\/\/------------------------------dump-------------------------------------------\n-void Node::dump(int d) const {\n-  if(d > 0) {\n-    dump_bfs(abs(d), nullptr, \"cdmxo+\");\n+\/\/----------------------------collect_nodes_i----------------------------------\n+\/\/ Collects nodes from an Ideal graph, starting from a given start node and\n+\/\/ moving in a given direction until a certain depth (distance from the start\n+\/\/ node) is reached. Duplicates are ignored.\n+\/\/ Arguments:\n+\/\/   queue:         the nodes are collected into this array.\n+\/\/   start:         the node at which to start collecting.\n+\/\/   direction:     if this is a positive number, collect input nodes; if it is\n+\/\/                  a negative number, collect output nodes.\n+\/\/   depth:         collect nodes up to this distance from the start node.\n+\/\/   include_start: whether to include the start node in the result collection.\n+\/\/   only_ctrl:     whether to regard control edges only during traversal.\n+\/\/   only_data:     whether to regard data edges only during traversal.\n+static void collect_nodes_i(GrowableArray<Node*>* queue, const Node* start, int direction, uint depth, bool include_start, bool only_ctrl, bool only_data) {\n+  bool indent = depth <= PrintIdealIndentThreshold;\n+  Node* s = (Node*) start; \/\/ remove const\n+  queue->append(s);\n+  int begin = 0;\n+  int end = 0;\n+\n+  s->set_indent(0);\n+  for(uint i = 0; i < depth; i++) {\n+    end = queue->length();\n+    for(int j = begin; j < end; j++) {\n+      Node* tp  = queue->at(j);\n+      uint limit = direction > 0 ? tp->len() : tp->outcnt();\n+      for(uint k = 0; k < limit; k++) {\n+        Node* n = direction > 0 ? tp->in(k) : tp->raw_out(k);\n+\n+        if (not_a_node(n))  continue;\n+        \/\/ do not recurse through top or the root (would reach unrelated stuff)\n+        if (n->is_Root() || n->is_top()) continue;\n+        if (only_ctrl && !n->is_CFG()) continue;\n+        if (only_data && n->is_CFG()) continue;\n+        bool in_queue = queue->contains(n);\n+        if (!in_queue) {\n+          queue->append(n);\n+          n->set_indent(indent ? (i + 1) : 0);\n+        }\n+      }\n+    }\n+    begin = end;\n+  }\n+  if (!include_start) {\n+    queue->remove(s);\n+  }\n+}\n+\n+\/\/------------------------------dump_nodes-------------------------------------\n+static void dump_nodes(const Node* start, int d, bool only_ctrl) {\n+  if (not_a_node(start)) return;\n+\n+  GrowableArray <Node *> queue(Compile::current()->live_nodes());\n+  collect_nodes_i(&queue, start, d, (uint) ABS(d), true, only_ctrl, false);\n+\n+  int end = queue.length();\n+  if (d > 0) {\n+    for(int j = end-1; j >= 0; j--) {\n+      queue.at(j)->dump();\n+    }\n@@ -2417,1 +2483,3 @@\n-    dump_bfs(abs(d), nullptr, \"cdmxo-\");\n+    for(int j = 0; j < end; j++) {\n+      queue.at(j)->dump();\n+    }\n@@ -2421,0 +2489,5 @@\n+\/\/------------------------------dump-------------------------------------------\n+void Node::dump(int d) const {\n+  dump_nodes(this, d, false);\n+}\n+\n@@ -2424,5 +2497,1 @@\n-  if(d > 0) {\n-    dump_bfs(abs(d), nullptr, \"cxo+\"); \/\/ no data, no memory\n-  } else {\n-    dump_bfs(abs(d), nullptr, \"cxo-\"); \/\/ no data, no memory\n-  }\n+  dump_nodes(this, d, true);\n@@ -2451,0 +2520,195 @@\n+\/\/----------------------------dump_related-------------------------------------\n+\/\/ Dump a Node's related nodes - the notion of \"related\" depends on the Node at\n+\/\/ hand and is determined by the implementation of the virtual method rel.\n+void Node::dump_related() const {\n+  Compile* C = Compile::current();\n+  GrowableArray <Node *> in_rel(C->unique());\n+  GrowableArray <Node *> out_rel(C->unique());\n+  this->related(&in_rel, &out_rel, false);\n+  for (int i = in_rel.length() - 1; i >= 0; i--) {\n+    in_rel.at(i)->dump();\n+  }\n+  this->dump(\"\\n\", true);\n+  for (int i = 0; i < out_rel.length(); i++) {\n+    out_rel.at(i)->dump();\n+  }\n+}\n+\n+\/\/----------------------------dump_related-------------------------------------\n+\/\/ Dump a Node's related nodes up to a given depth (distance from the start\n+\/\/ node).\n+\/\/ Arguments:\n+\/\/   d_in:  depth for input nodes.\n+\/\/   d_out: depth for output nodes (note: this also is a positive number).\n+void Node::dump_related(uint d_in, uint d_out) const {\n+  Compile* C = Compile::current();\n+  GrowableArray <Node *> in_rel(C->unique());\n+  GrowableArray <Node *> out_rel(C->unique());\n+\n+  \/\/ call collect_nodes_i directly\n+  collect_nodes_i(&in_rel, this, 1, d_in, false, false, false);\n+  collect_nodes_i(&out_rel, this, -1, d_out, false, false, false);\n+\n+  for (int i = in_rel.length() - 1; i >= 0; i--) {\n+    in_rel.at(i)->dump();\n+  }\n+  this->dump(\"\\n\", true);\n+  for (int i = 0; i < out_rel.length(); i++) {\n+    out_rel.at(i)->dump();\n+  }\n+}\n+\n+\/\/------------------------dump_related_compact---------------------------------\n+\/\/ Dump a Node's related nodes in compact representation. The notion of\n+\/\/ \"related\" depends on the Node at hand and is determined by the implementation\n+\/\/ of the virtual method rel.\n+void Node::dump_related_compact() const {\n+  Compile* C = Compile::current();\n+  GrowableArray <Node *> in_rel(C->unique());\n+  GrowableArray <Node *> out_rel(C->unique());\n+  this->related(&in_rel, &out_rel, true);\n+  int n_in = in_rel.length();\n+  int n_out = out_rel.length();\n+\n+  this->dump_comp(n_in == 0 ? \"\\n\" : \"  \");\n+  for (int i = 0; i < n_in; i++) {\n+    in_rel.at(i)->dump_comp(i == n_in - 1 ? \"\\n\" : \"  \");\n+  }\n+  for (int i = 0; i < n_out; i++) {\n+    out_rel.at(i)->dump_comp(i == n_out - 1 ? \"\\n\" : \"  \");\n+  }\n+}\n+\n+\/\/------------------------------related----------------------------------------\n+\/\/ Collect a Node's related nodes. The default behaviour just collects the\n+\/\/ inputs and outputs at depth 1, including both control and data flow edges,\n+\/\/ regardless of whether the presentation is compact or not. For data nodes,\n+\/\/ the default is to collect all data inputs (till level 1 if compact), and\n+\/\/ outputs till level 1.\n+void Node::related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const {\n+  if (this->is_CFG()) {\n+    collect_nodes_i(in_rel, this, 1, 1, false, false, false);\n+    collect_nodes_i(out_rel, this, -1, 1, false, false, false);\n+  } else {\n+    if (compact) {\n+      this->collect_nodes(in_rel, 1, false, true);\n+    } else {\n+      this->collect_nodes_in_all_data(in_rel, false);\n+    }\n+    this->collect_nodes(out_rel, -1, false, false);\n+  }\n+}\n+\n+\/\/---------------------------collect_nodes-------------------------------------\n+\/\/ An entry point to the low-level node collection facility, to start from a\n+\/\/ given node in the graph. The start node is by default not included in the\n+\/\/ result.\n+\/\/ Arguments:\n+\/\/   ns:   collect the nodes into this data structure.\n+\/\/   d:    the depth (distance from start node) to which nodes should be\n+\/\/         collected. A value >0 indicates input nodes, a value <0, output\n+\/\/         nodes.\n+\/\/   ctrl: include only control nodes.\n+\/\/   data: include only data nodes.\n+void Node::collect_nodes(GrowableArray<Node*> *ns, int d, bool ctrl, bool data) const {\n+  if (ctrl && data) {\n+    \/\/ ignore nonsensical combination\n+    return;\n+  }\n+  collect_nodes_i(ns, this, d, (uint) ABS(d), false, ctrl, data);\n+}\n+\n+\/\/--------------------------collect_nodes_in-----------------------------------\n+static void collect_nodes_in(Node* start, GrowableArray<Node*> *ns, bool primary_is_data, bool collect_secondary) {\n+  \/\/ The maximum depth is determined using a BFS that visits all primary (data\n+  \/\/ or control) inputs and increments the depth at each level.\n+  uint d_in = 0;\n+  GrowableArray<Node*> nodes(Compile::current()->unique());\n+  nodes.push(start);\n+  int nodes_at_current_level = 1;\n+  int n_idx = 0;\n+  while (nodes_at_current_level > 0) {\n+    \/\/ Add all primary inputs reachable from the current level to the list, and\n+    \/\/ increase the depth if there were any.\n+    int nodes_at_next_level = 0;\n+    bool nodes_added = false;\n+    while (nodes_at_current_level > 0) {\n+      nodes_at_current_level--;\n+      Node* current = nodes.at(n_idx++);\n+      for (uint i = 0; i < current->len(); i++) {\n+        Node* n = current->in(i);\n+        if (not_a_node(n)) {\n+          continue;\n+        }\n+        if ((primary_is_data && n->is_CFG()) || (!primary_is_data && !n->is_CFG())) {\n+          continue;\n+        }\n+        if (!nodes.contains(n)) {\n+          nodes.push(n);\n+          nodes_added = true;\n+          nodes_at_next_level++;\n+        }\n+      }\n+    }\n+    if (nodes_added) {\n+      d_in++;\n+    }\n+    nodes_at_current_level = nodes_at_next_level;\n+  }\n+  start->collect_nodes(ns, d_in, !primary_is_data, primary_is_data);\n+  if (collect_secondary) {\n+    \/\/ Now, iterate over the secondary nodes in ns and add the respective\n+    \/\/ boundary reachable from them.\n+    GrowableArray<Node*> sns(Compile::current()->unique());\n+    for (GrowableArrayIterator<Node*> it = ns->begin(); it != ns->end(); ++it) {\n+      Node* n = *it;\n+      n->collect_nodes(&sns, 1, primary_is_data, !primary_is_data);\n+      for (GrowableArrayIterator<Node*> d = sns.begin(); d != sns.end(); ++d) {\n+        ns->append_if_missing(*d);\n+      }\n+      sns.clear();\n+    }\n+  }\n+}\n+\n+\/\/---------------------collect_nodes_in_all_data-------------------------------\n+\/\/ Collect the entire data input graph. Include the control boundary if\n+\/\/ requested.\n+\/\/ Arguments:\n+\/\/   ns:   collect the nodes into this data structure.\n+\/\/   ctrl: if true, include the control boundary.\n+void Node::collect_nodes_in_all_data(GrowableArray<Node*> *ns, bool ctrl) const {\n+  collect_nodes_in((Node*) this, ns, true, ctrl);\n+}\n+\n+\/\/--------------------------collect_nodes_in_all_ctrl--------------------------\n+\/\/ Collect the entire control input graph. Include the data boundary if\n+\/\/ requested.\n+\/\/   ns:   collect the nodes into this data structure.\n+\/\/   data: if true, include the control boundary.\n+void Node::collect_nodes_in_all_ctrl(GrowableArray<Node*> *ns, bool data) const {\n+  collect_nodes_in((Node*) this, ns, false, data);\n+}\n+\n+\/\/------------------collect_nodes_out_all_ctrl_boundary------------------------\n+\/\/ Collect the entire output graph until hitting control node boundaries, and\n+\/\/ include those.\n+void Node::collect_nodes_out_all_ctrl_boundary(GrowableArray<Node*> *ns) const {\n+  \/\/ Perform a BFS and stop at control nodes.\n+  GrowableArray<Node*> nodes(Compile::current()->unique());\n+  nodes.push((Node*) this);\n+  while (nodes.length() > 0) {\n+    Node* current = nodes.pop();\n+    if (not_a_node(current)) {\n+      continue;\n+    }\n+    ns->append_if_missing(current);\n+    if (!current->is_CFG()) {\n+      for (DUIterator i = current->outs(); current->has_out(i); i++) {\n+        nodes.push(current->out(i));\n+      }\n+    }\n+  }\n+  ns->remove((Node*) this);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":282,"deletions":18,"binary":false,"changes":300,"status":"modified"},{"patch":"@@ -1194,1 +1194,1 @@\n-  void dump_bfs(const int max_distance, Node* target, char const* options) const; \/\/ Print BFS traversal\n+  void print_bfs(const int max_distance, Node* target, char const* options); \/\/ Print BFS traversal\n@@ -1216,0 +1216,6 @@\n+  void dump_related() const;             \/\/ Print related nodes (depends on node at hand).\n+  \/\/ Print related nodes up to given depths for input and output nodes.\n+  void dump_related(uint d_in, uint d_out) const;\n+  void dump_related_compact() const;     \/\/ Print related nodes in compact representation.\n+  \/\/ Collect related nodes.\n+  virtual void related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const;\n@@ -1219,0 +1225,8 @@\n+  \/\/ Node collectors, to be used in implementations of Node::rel().\n+  \/\/ Collect the entire data input graph. Include control inputs if requested.\n+  void collect_nodes_in_all_data(GrowableArray<Node*> *ns, bool ctrl) const;\n+  \/\/ Collect the entire control input graph. Include data inputs if requested.\n+  void collect_nodes_in_all_ctrl(GrowableArray<Node*> *ns, bool data) const;\n+  \/\/ Collect the entire output graph until hitting and including control nodes.\n+  void collect_nodes_out_all_ctrl_boundary(GrowableArray<Node*> *ns) const;\n+\n@@ -1225,0 +1239,1 @@\n+  void dump_format(PhaseRegAlloc *ra) const; \/\/ debug access to MachNode::format(...)\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -94,0 +94,15 @@\n+\n+#ifndef PRODUCT\n+\/\/-----------------------------related-----------------------------------------\n+\/\/ Include all control inputs in the related set, and also the input data\n+\/\/ boundary. In compact mode, include all inputs till level 2. Also include\n+\/\/ all outputs at level 1.\n+void HaltNode::related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const {\n+  if (compact) {\n+    this->collect_nodes(in_rel, 2, false, false);\n+  } else {\n+    this->collect_nodes_in_all_ctrl(in_rel, true);\n+  }\n+  this->collect_nodes(out_rel, -1, false, false);\n+}\n+#endif\n","filename":"src\/hotspot\/share\/opto\/rootnode.cpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -71,0 +71,4 @@\n+\n+#ifndef PRODUCT\n+  virtual void related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const;\n+#endif\n","filename":"src\/hotspot\/share\/opto\/rootnode.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -631,0 +631,32 @@\n+#ifndef PRODUCT\n+\/\/----------------------------related------------------------------------------\n+\/\/ Related nodes of comparison nodes include all data inputs (until hitting a\n+\/\/ control boundary) as well as all outputs until and including control nodes\n+\/\/ as well as their projections. In compact mode, data inputs till depth 1 and\n+\/\/ all outputs till depth 1 are considered.\n+void CmpNode::related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const {\n+  if (compact) {\n+    this->collect_nodes(in_rel, 1, false, true);\n+    this->collect_nodes(out_rel, -1, false, false);\n+  } else {\n+    this->collect_nodes_in_all_data(in_rel, false);\n+    this->collect_nodes_out_all_ctrl_boundary(out_rel);\n+    \/\/ Now, find all control nodes in out_rel, and include their projections\n+    \/\/ and projection targets (if any) in the result.\n+    GrowableArray<Node*> proj(Compile::current()->unique());\n+    for (GrowableArrayIterator<Node*> it = out_rel->begin(); it != out_rel->end(); ++it) {\n+      Node* n = *it;\n+      if (n->is_CFG() && !n->is_Proj()) {\n+        \/\/ Assume projections and projection targets are found at levels 1 and 2.\n+        n->collect_nodes(&proj, -2, false, false);\n+        for (GrowableArrayIterator<Node*> p = proj.begin(); p != proj.end(); ++p) {\n+          out_rel->append_if_missing(*p);\n+        }\n+        proj.clear();\n+      }\n+    }\n+  }\n+}\n+\n+#endif\n+\n@@ -1761,0 +1793,14 @@\n+\n+\/\/-------------------------------related---------------------------------------\n+\/\/ A BoolNode's related nodes are all of its data inputs, and all of its\n+\/\/ outputs until control nodes are hit, which are included. In compact\n+\/\/ representation, inputs till level 3 and immediate outputs are included.\n+void BoolNode::related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const {\n+  if (compact) {\n+    this->collect_nodes(in_rel, 3, false, true);\n+    this->collect_nodes(out_rel, -1, false, false);\n+  } else {\n+    this->collect_nodes_in_all_data(in_rel, false);\n+    this->collect_nodes_out_all_ctrl_boundary(out_rel);\n+  }\n+}\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":46,"deletions":0,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -146,0 +146,7 @@\n+\n+#ifndef PRODUCT\n+  \/\/ CmpNode and subclasses include all data inputs (until hitting a control\n+  \/\/ boundary) in their related node set, as well as all outputs until and\n+  \/\/ including eventual control nodes and their projections.\n+  virtual void related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const;\n+#endif\n@@ -333,0 +340,1 @@\n+  virtual void related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const;\n","filename":"src\/hotspot\/share\/opto\/subnode.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"}]}