{"files":[{"patch":"@@ -1612,3 +1612,3 @@\n-\/\/ BFS traversal of graph, starting at node this\n-\/\/ this: staring point of BFS\n-\/\/ max_distance: maximal distance from this BFS visits\n+\/\/ BFS traversal of graph, starting at node this\/start\n+\/\/ this\/start: staring point of BFS\n+\/\/ max_distance: maximal distance from this\/start BFS visits\n@@ -1616,2 +1616,2 @@\n-\/\/   if NULL: print all nodes visited during BFS\n-\/\/   else: find shortest path from this to target, via BFS and backtracking\n+\/\/   if nullptr: print all nodes visited during BFS\n+\/\/   else: find shortest path from this\/start to target, via BFS and backtracking\n@@ -1619,1 +1619,1 @@\n-\/\/   if NULL: same as \"+-cmdxoOB\"\n+\/\/   if nullptr: same as \"+-cmdxoOB\"\n@@ -1650,1 +1650,1 @@\n-\/\/   distance: distance to this in BFS traversal\n+\/\/   distance: distance to this\/start in BFS traversal\n@@ -1653,1 +1653,1 @@\n-\/\/   parent:   parent node - one distance closer to this\n+\/\/   parent:   parent node - one distance closer to this\/start\n@@ -1657,177 +1657,57 @@\n-int print_bfs_cmp(const Node* n1, const Node* n2) { return n1 != n2; }\n-void Node::print_bfs(const int max_distance, Node* target, char const* options) {\n-  assert(max_distance >= 0, \"non-negative distance\");\n-  \/\/ Parsing options\n-  if (options == NULL) {\n-    options = \"+-cmdxoOB\"; \/\/ default options\n-  }\n-  auto parse_options = [&] (bool &variable, const char* character) {\n-    if (strstr(options, character) != NULL) {\n-      variable = true;\n-    }\n-  };\n-  bool traverse_inputs = false;\n-  parse_options(traverse_inputs,  \"+\");\n-  bool traverse_outputs = false;\n-  parse_options(traverse_outputs, \"-\");\n-  bool traverse_control = false;\n-  parse_options(traverse_control, \"c\");\n-  bool traverse_memory = false;\n-  parse_options(traverse_memory,  \"m\");\n-  bool traverse_data = false;\n-  parse_options(traverse_data,    \"d\");\n-  bool traverse_mixed = false;\n-  parse_options(traverse_mixed,   \"x\");\n-  bool traverse_other = false;\n-  parse_options(traverse_other,   \"o\");\n-  bool use_color = false;\n-  parse_options(use_color,        \"#\");\n-  bool print_blocks = false;\n-  parse_options(print_blocks,     \"B\");\n-  bool print_old = false;\n-  parse_options(print_old,        \"O\");\n-\n-  \/\/ Filter node by type\n-  auto is_visit = [&] (Node* n) {\n-    const Type *t = n->bottom_type();\n-    switch (t->category()) {\n-      case Type::Category::Data:\n-        return traverse_data;\n-      case Type::Category::Memory:\n-        return traverse_memory;\n-      case Type::Category::Mixed:\n-        return traverse_mixed;\n-      case Type::Category::Control:\n-        return traverse_control;\n-      case Type::Category::Other:\n-        return traverse_other;\n-      case Type::Category::Undef:\n-        n->dump();\n-        assert(false, \"category undef ??\");\n-      default:\n-        n->dump();\n-        assert(false, \"not covered\");\n-    }\n-    return false;\n-  };\n-\n-  \/\/ Get (colored) category string\n-  auto category = [&] (Node* n) {\n-    const Type *t = n->bottom_type();\n-    switch (t->category()) {\n-      case Type::Category::Data:\n-        return use_color ? \"\\u001b[34md\\u001b[0m\" : \"d\";\n-      case Type::Category::Memory:\n-        return use_color ? \"\\u001b[32mm\\u001b[0m\" : \"m\";\n-      case Type::Category::Mixed:\n-        return use_color ? \"\\u001b[35mx\\u001b[0m\" : \"x\";\n-      case Type::Category::Control:\n-        return use_color ? \"\\u001b[31mc\\u001b[0m\" : \"c\";\n-      case Type::Category::Other:\n-        return use_color ? \"\\u001b[33mo\\u001b[0m\" : \"o\";\n-      case Type::Category::Undef:\n-        n->dump();\n-        assert(false, \"category undef ??\");\n-      default:\n-        n->dump();\n-        assert(false, \"not covered\");\n-    }\n-    return \"?\";\n-  };\n-\n-  Compile* C = Compile::current();\n-  print_old &= (C->matcher() != NULL); \/\/ only show old if there are new\n-  print_blocks &= (C->cfg() != NULL); \/\/ only show blocks if available\n-\n-  \/\/ Get old node (for Mach nodes)\n-  auto old_node = [&] (Node* n) {\n-    if (C->matcher() == NULL || !C->node_arena()->contains(n)) {\n-      return (Node*)NULL;\n-    } else {\n-      return C->matcher()->find_old_node(n);\n-    }\n-  };\n-\n-  \/\/ print idx of node\n-  auto print_node_idx = [&] (Node* n) {\n-    char buf[30];\n-    if (n == NULL) {\n-      sprintf(buf,\"_\");           \/\/ null\n-    } else if (C->node_arena()->contains(n)) {\n-      sprintf(buf, \"%d\", n->_idx);  \/\/ new node\n-    } else {\n-      sprintf(buf, \"o%d\", n->_idx); \/\/ old node\n-    }\n-    tty->print(\"%6s\", buf);\n-  };\n-\n-  \/\/ print block associated with node\n-  auto print_node_block = [&] (Node* n) {\n-    Block* b = C->node_arena()->contains(n)\n-               ? C->cfg()->get_block_for_node(n)\n-               : NULL; \/\/ guard against old nodes\n-    if (b == NULL) {\n-      tty->print(\"     _\");\n-      tty->print(\"     _\");\n-      tty->print(\"   _\");\n-    } else {\n-      print_node_idx(b->head());\n-      if(b->_idom) {\n-        print_node_idx(b->_idom->head());\n-      } else {\n-        tty->print(\"     _\");\n-      }\n-      tty->print(\"%4d\", b->_dom_depth);\n-    }\n-  };\n-\n-  \/\/ Data structures\n-  Node_List worklist; \/\/ BFS queue\n-  Dict parent((CmpKey)&print_bfs_cmp, hashkey);   \/\/ node -> parent (one step closer to this)\n-  Dict distance((CmpKey)&print_bfs_cmp, hashkey); \/\/ node -> distance to this\n-  \/\/ Note: for distance, we store an int in a (void*), this requires double casting\n-\n-  \/\/ add node to traversal queue\n-  auto worklist_push = [&] (Node* n, Node* p, const int d) {\n-    worklist.push(n);\n-    parent.Insert(n, p);\n-    distance.Insert(n, (void*)(size_t)d);\n-  };\n-\n-  auto print_header = [&] (bool print_parent) {\n-    tty->print(\"dis\");                          \/\/ distance\n-    if (print_blocks) {\n-      tty->print(\" [head  idom  d]\");           \/\/ block\n-    }\n-    if(print_old) {\n-      tty->print(\"   old\");                     \/\/ old node\n-    }\n-    if (print_parent) {\n-      tty->print(\"   par\");                     \/\/ parent\n-    }\n-    if (traverse_inputs && traverse_outputs) {\n-      tty->print(\" e\");                         \/\/ edge\n-    }\n-    tty->print(\" c dump\\n\");                    \/\/ category and dump\n-    tty->print(\"---------------------------------------------\\n\");\n-  };\n-\n-  auto print_node = [&] (Node* n, bool print_parent) {\n-    tty->print(\"%3d\", abs((int)(size_t)distance[n])); \/\/ distance\n-    if (print_blocks) {\n-      print_node_block(n);                      \/\/ block\n-    }\n-    if (print_old) {\n-      print_node_idx(old_node(n));              \/\/ old node\n-    }\n-    if (print_parent) {\n-      print_node_idx((Node*)parent[n]);         \/\/ parent\n-    }\n-    if (traverse_inputs && traverse_outputs) {\n-      int dd = (int)(size_t)distance[n];\n-      const char* edge = (dd >=0 ) ? ((dd > 0) ? \"+\" : \" \" ) : \"-\";\n-      tty->print(\" %s\", edge);                  \/\/ edge\n-    }\n-    tty->print(\" %s \", category(n));            \/\/ category\n-    n->dump();                                  \/\/ node dump\n-  };\n+class PrintBFS {\n+public:\n+  PrintBFS(Node* start, const int max_distance, Node* target, char const* options)\n+  : _start(start), _max_distance(max_distance), _target(target), _options(options),\n+    _parent((CmpKey)&cmp, hashkey), _distance((CmpKey)&cmp, hashkey) {};\n+  void run();\n+  void traversal();\n+  void backtrack();\n+private:\n+  \/\/ inputs\n+  Node* _start;\n+  const int _max_distance;\n+  Node* _target;\n+  char const* _options;\n+\n+  \/\/ options\n+  bool _traverse_inputs = false;\n+  bool _traverse_outputs = false;\n+  bool _traverse_control = false;\n+  bool _traverse_memory = false;\n+  bool _traverse_data = false;\n+  bool _traverse_mixed = false;\n+  bool _traverse_other = false;\n+  bool _use_color = false;\n+  bool _print_blocks = false;\n+  bool _print_old = false;\n+  void parse_options_helper(bool &variable, const char* character);\n+  void parse_options();\n+\n+  \/\/ node category\n+  bool is_visitable_category(Node* n); \/\/ filter node category agains options\n+  const char* category_string(Node* n); \/\/ (colored) category\n+\n+  \/\/ node info\n+  Node* old_node (Node* n); \/\/ mach node -> prior IR node\n+  void print_node_idx (Node* n); \/\/ to tty\n+  void print_node_block (Node* n); \/\/ to tty: head idx, _idom, _dom_depth\n+\n+  \/\/ traversal data structures\n+  Node_List _worklist; \/\/ BFS queue\n+  void worklist_maybe_push(Node* n, Node* p, const int d);\n+  static int cmp(const Node* n1, const Node* n2) { return n1 != n2; }\n+  Dict _parent;   \/\/ node -> parent (one step closer to _start)\n+  Dict _distance; \/\/ node -> distance to start\n+  int distance(Node* n);\n+  Node* parent(Node* n);\n+\n+  \/\/ print header + node table\n+  void print_header(bool print_parent);\n+  void print_node(Node* n, bool print_parent);\n+};\n+void PrintBFS::run() {\n+  if(_max_distance < 0) {\n+    tty->print(\"print_bfs: max_distance must be non-negative!\\n\");\n+    return;\n+  }\n+  parse_options();\n@@ -1835,2 +1715,1 @@\n-  \/\/ BFS or shortest path?\n-  if (target == NULL) {\n+  if (_target == nullptr) {\n@@ -1841,1 +1720,1 @@\n-    print_node_idx(this);\n+    print_node_idx(_start);\n@@ -1843,1 +1722,1 @@\n-    print_node_idx(target);\n+    print_node_idx(_target);\n@@ -1847,4 +1726,5 @@\n-  \/\/ initialize BFS at this\n-  worklist_push(this, this, 0);\n-\n-  \/\/ BFS traversal\n+  traversal();\n+  backtrack();\n+}\n+void PrintBFS::traversal() {\n+  worklist_maybe_push(_start, _start, 0);\n@@ -1852,6 +1732,4 @@\n-  while (pos < worklist.size()) {\n-    \/\/ process next item\n-    Node* n = worklist.at(pos++);\n-    int d = abs((int)(size_t)distance[n]);\n-    \/\/ BFS: print n\n-    if (target == NULL) {\n+  while (pos < _worklist.size()) {\n+    Node* n = _worklist.at(pos++);\n+    int d = abs(distance(n));\n+    if (_target == nullptr) {\n@@ -1863,3 +1741,1 @@\n-\n-    \/\/ traverse inputs\n-    if (traverse_inputs && max_distance > d) {\n+    if (_traverse_inputs && _max_distance > d) {\n@@ -1867,7 +1743,1 @@\n-        Node* in = n->in(i);\n-        if (in == NULL || !is_visit(in)) {\n-          continue;\n-        }\n-        if (parent[in] == NULL) {\n-          worklist_push(in, n, d+1); \/\/ positive for input\n-        }\n+        worklist_maybe_push(n->in(i), n, d+1); \/\/ positive for input\n@@ -1876,3 +1746,1 @@\n-\n-    \/\/ traverse outputs\n-    if (traverse_outputs && max_distance > d) {\n+    if (_traverse_outputs && _max_distance > d) {\n@@ -1880,7 +1748,1 @@\n-        Node* out = n->raw_out(i);\n-        if (out == NULL || !is_visit(out)) {\n-          continue;\n-        }\n-        if (parent[out] == NULL) {\n-          worklist_push(out, n, -d-1); \/\/ negative for output\n-        }\n+        worklist_maybe_push(n->raw_out(i), n, -d-1); \/\/ negative for output\n@@ -1890,5 +1752,5 @@\n-\n-  \/\/ backtrace\n-  if (target != NULL) {\n-    if (parent[target] == NULL) {\n-      tty->print(\"\\nCould not find target in BFS.\\n\");\n+}\n+void PrintBFS::backtrack() {\n+  if (_target != nullptr) {\n+    if (parent(_target) == nullptr) {\n+      tty->print(\"Could not find target in BFS.\\n\");\n@@ -1897,2 +1759,0 @@\n-    tty->print(\"\\nBacktrace target.\\n\");\n-    \/\/ backtrace header\n@@ -1900,2 +1760,2 @@\n-    Node* current = target;\n-    while (current != (Node*)parent[current]) {\n+    Node* current = _target;\n+    while (current != parent(current)) {\n@@ -1903,1 +1763,1 @@\n-      current = (Node*)parent[current];\n+      current = parent(current);\n@@ -1905,1 +1765,1 @@\n-    print_node(this, false);\n+    print_node(_start, false);\n@@ -1908,0 +1768,162 @@\n+void PrintBFS::parse_options_helper(bool &variable, const char* character) {\n+  if (strstr(_options, character) != nullptr) {\n+    variable = true;\n+  }\n+}\n+void PrintBFS::parse_options() {\n+  if (_options == nullptr) {\n+    _options = \"+-cmdxoOB\"; \/\/ default options\n+  }\n+  parse_options_helper(_traverse_inputs,  \"+\");\n+  parse_options_helper(_traverse_outputs, \"-\");\n+  parse_options_helper(_traverse_control, \"c\");\n+  parse_options_helper(_traverse_memory,  \"m\");\n+  parse_options_helper(_traverse_data,    \"d\");\n+  parse_options_helper(_traverse_mixed,   \"x\");\n+  parse_options_helper(_traverse_other,   \"o\");\n+  parse_options_helper(_use_color,        \"#\");\n+  parse_options_helper(_print_blocks,     \"B\");\n+  parse_options_helper(_print_old,        \"O\");\n+  Compile* C = Compile::current();\n+  _print_old &= (C->matcher() != nullptr); \/\/ only show old if there are new\n+  _print_blocks &= (C->cfg() != nullptr); \/\/ only show blocks if available\n+}\n+bool PrintBFS::is_visitable_category(Node* n) {\n+  const Type *t = n->bottom_type();\n+  switch (t->category()) {\n+    case Type::Category::Data:\n+      return _traverse_data;\n+    case Type::Category::Memory:\n+      return _traverse_memory;\n+    case Type::Category::Mixed:\n+      return _traverse_mixed;\n+    case Type::Category::Control:\n+      return _traverse_control;\n+    case Type::Category::Other:\n+      return _traverse_other;\n+    case Type::Category::Undef:\n+      n->dump();\n+      assert(false, \"category undef ??\");\n+    default:\n+      n->dump();\n+      assert(false, \"not covered\");\n+  }\n+  return false;\n+}\n+const char* PrintBFS::category_string(Node* n) {\n+  const Type *t = n->bottom_type();\n+  switch (t->category()) {\n+    case Type::Category::Data:\n+      return _use_color ? \"\\u001b[34md\\u001b[0m\" : \"d\";\n+    case Type::Category::Memory:\n+      return _use_color ? \"\\u001b[32mm\\u001b[0m\" : \"m\";\n+    case Type::Category::Mixed:\n+      return _use_color ? \"\\u001b[35mx\\u001b[0m\" : \"x\";\n+    case Type::Category::Control:\n+      return _use_color ? \"\\u001b[31mc\\u001b[0m\" : \"c\";\n+    case Type::Category::Other:\n+      return _use_color ? \"\\u001b[33mo\\u001b[0m\" : \"o\";\n+    case Type::Category::Undef:\n+      n->dump();\n+      assert(false, \"category undef ??\");\n+    default:\n+      n->dump();\n+      assert(false, \"not covered\");\n+  }\n+  return \"?\";\n+}\n+Node* PrintBFS::old_node (Node* n) {\n+  Compile* C = Compile::current();\n+  if (C->matcher() == nullptr || !C->node_arena()->contains(n)) {\n+    return (Node*)nullptr;\n+  } else {\n+    return C->matcher()->find_old_node(n);\n+  }\n+}\n+void PrintBFS::print_node_idx (Node* n) {\n+  Compile* C = Compile::current();\n+  char buf[30];\n+  if (n == nullptr) {\n+    sprintf(buf,\"_\");           \/\/ null\n+  } else if (C->node_arena()->contains(n)) {\n+    sprintf(buf, \"%d\", n->_idx);  \/\/ new node\n+  } else {\n+    sprintf(buf, \"o%d\", n->_idx); \/\/ old node\n+  }\n+  tty->print(\"%6s\", buf);\n+}\n+void PrintBFS::print_node_block (Node* n) {\n+  Compile* C = Compile::current();\n+  Block* b = C->node_arena()->contains(n)\n+             ? C->cfg()->get_block_for_node(n)\n+             : nullptr; \/\/ guard against old nodes\n+  if (b == nullptr) {\n+    tty->print(\"     _\");\n+    tty->print(\"     _\");\n+    tty->print(\"   _\");\n+  } else {\n+    print_node_idx(b->head());\n+    if(b->_idom) {\n+      print_node_idx(b->_idom->head());\n+    } else {\n+      tty->print(\"     _\");\n+    }\n+    tty->print(\"%4d\", b->_dom_depth);\n+  }\n+}\n+void PrintBFS::worklist_maybe_push(Node* n, Node* p, const int d) {\n+  if (n != nullptr &&\n+      parent(n) == nullptr && \/\/ visited before?\n+      (is_visitable_category(n) || n == _start)) { \/\/ correct category or start?\n+    _worklist.push(n);\n+    _parent.Insert(n, p);\n+    _distance.Insert(n, (void*)(size_t)d);\n+  }\n+}\n+int PrintBFS::distance(Node* n) {\n+  return (int)(size_t)_distance[n];\n+  \/\/ storing int in a (void*), must do double casting\n+}\n+Node* PrintBFS::parent(Node* n) {\n+  return (Node*)_parent[n];\n+}\n+void PrintBFS::print_header(bool print_parent) {\n+  tty->print(\"dis\");                          \/\/ distance\n+  if (_print_blocks) {\n+    tty->print(\" [head  idom  d]\");           \/\/ block\n+  }\n+  if(_print_old) {\n+    tty->print(\"   old\");                     \/\/ old node\n+  }\n+  if (print_parent) {\n+    tty->print(\"   par\");                     \/\/ parent\n+  }\n+  if (_traverse_inputs && _traverse_outputs) {\n+    tty->print(\" e\");                         \/\/ edge\n+  }\n+  tty->print(\" c dump\\n\");                    \/\/ category and dump\n+  tty->print(\"---------------------------------------------\\n\");\n+}\n+void PrintBFS::print_node(Node* n, bool print_parent) {\n+  tty->print(\"%3d\", abs(distance(n)));        \/\/ distance\n+  if (_print_blocks) {\n+    print_node_block(n);                      \/\/ block\n+  }\n+  if (_print_old) {\n+    print_node_idx(old_node(n));              \/\/ old node\n+  }\n+  if (print_parent) {\n+    print_node_idx(parent(n));                \/\/ parent\n+  }\n+  if (_traverse_inputs && _traverse_outputs) {\n+    int dd = distance(n);\n+    const char* edge = (dd >=0 ) ? ((dd > 0) ? \"+\" : \" \" ) : \"-\";\n+    tty->print(\" %s\", edge);                  \/\/ edge\n+  }\n+  tty->print(\" %s \", category_string(n));     \/\/ category\n+  n->dump();                                  \/\/ node dump\n+}\n+void Node::print_bfs(const int max_distance, Node* target, char const* options) {\n+  PrintBFS bfs(this, max_distance, target, options);\n+  bfs.run();\n+}\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":252,"deletions":230,"binary":false,"changes":482,"status":"modified"}]}