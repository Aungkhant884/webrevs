{"files":[{"patch":"@@ -1610,0 +1610,296 @@\n+int print_bfs_cmp(const Node* n1, const Node* n2) { return n1 != n2; }\n+\/\/ Call this from debugger:\n+\/\/ BFS traversal of graph, starting at node this\n+\/\/ this: staring point of BFS\n+\/\/ max_distance: maximal distance from this BFS visits\n+\/\/ target:\n+\/\/   if NULL: print all nodes visited during BFS\n+\/\/   else: find shortest path from this to target, via BFS and backtracking\n+\/\/ filter:\n+\/\/   if NULL: no filtering\n+\/\/   else: use combination of these characters\n+\/\/     +: traverse in-edges\n+\/\/     -: traverse out-edges\n+\/\/     c: traverse control nodes\n+\/\/     m: traverse memory nodes\n+\/\/     d: traverse data nodes\n+\/\/     x: traverse mixed nodes\n+\/\/     o: traverse other nodes\n+\/\/     #: display node category in color (maybe not supported in all terminals)\n+\/\/     O: print old nodes - before matching (if available)\n+\/\/     B: print scheduling blocks (if available)\n+\/\/\n+\/\/ examples:\n+\/\/   if->print_bfs(10, 0, \"+cxo\")\n+\/\/     starting at if node, traverse inputs recursively\n+\/\/     only along control (mixed and other can also be control)\n+\/\/   phi->print_bfs(5, 0, \"-dxo\")\n+\/\/     starting at phi node, traverse outputs recursively\n+\/\/     only along data (mixed and other can also have data flow)\n+\/\/   x->print_bfs(10, y, 0)\n+\/\/     find shortest path from x to y, along any edge or node\n+\/\/     will not find a path if it is longer than 10\n+\/\/     useful to find how x and y are related\n+\/\/   find_node(385)->print_bfs(3, 0, \"cdmox+#OB\")\n+\/\/     find inputs of node 385, up to 3 nodes up (+)\n+\/\/     traverse all nodes (cdmox), use colors (#)\n+\/\/     display old nodes and blocks, if they exist\n+\/\/     this is very useful to start at\n+\/\/\n+\/\/ output columns:\n+\/\/   distance: distance to this in BFS traversal\n+\/\/   block:    block in which the node has been scheduled (head(), _idom->head(), _dom_depth)\n+\/\/   old:      old IR node - before matching\n+\/\/   parent:   parent node - one distance closer to this\n+\/\/   direction and node type\n+\/\/   dump\n+void Node::print_bfs(const uint max_distance, Node* target, const char* filter) {\n+  if (target == NULL) {\n+    tty->print(\"No target: perform BFS.\\n\");\n+  } else {\n+    tty->print(\"Find shortest path: %d -> %d.\\n\", this->_idx, target->_idx);\n+  }\n+  bool traverse_inputs = false;\n+  if (filter == NULL || strstr(filter, \"+\") != NULL) {\n+    traverse_inputs = true;\n+  }\n+  bool traverse_outputs = false;\n+  if (filter == NULL || strstr(filter, \"-\") != NULL) {\n+    traverse_outputs = true;\n+  }\n+  bool traverse_control = false;\n+  if (filter == NULL || strstr(filter, \"c\") != NULL) {\n+    traverse_control = true;\n+  }\n+  bool traverse_memory = false;\n+  if (filter == NULL || strstr(filter, \"m\") != NULL) {\n+    traverse_memory = true;\n+  }\n+  bool traverse_data = false;\n+  if (filter == NULL || strstr(filter, \"d\") != NULL) {\n+    traverse_data = true;\n+  }\n+  bool traverse_mixed = false;\n+  if (filter == NULL || strstr(filter, \"x\") != NULL) {\n+    traverse_mixed = true;\n+  }\n+  bool traverse_other = false;\n+  if (filter == NULL || strstr(filter, \"o\") != NULL) {\n+    traverse_other = true;\n+  }\n+  bool use_color = false;\n+  if (filter != NULL && strstr(filter, \"#\") != NULL) {\n+    use_color = true;\n+  }\n+  bool print_blocks = false;\n+  if (filter == NULL || strstr(filter, \"B\") != NULL) {\n+    print_blocks = true;\n+  }\n+  bool print_old = false;\n+  if (filter == NULL || strstr(filter, \"O\") != NULL) {\n+    print_old = true;\n+  }\n+\n+  \/\/ data structures\n+  Node_List worklist; \/\/ BFS queue\n+  Dict parent((CmpKey)&print_bfs_cmp, hashkey);   \/\/ node -> parent (one step closer to this)\n+  Dict distance((CmpKey)&print_bfs_cmp, hashkey); \/\/ node -> distance to this\n+\n+  auto is_visit = [&] (Node* n) {\n+    const Type *t = n->bottom_type();\n+    switch (t->category()) {\n+      case Type::Category::Data:\n+        return traverse_data;\n+      case Type::Category::Memory:\n+        return traverse_memory;\n+      case Type::Category::Mixed:\n+        return traverse_mixed;\n+      case Type::Category::Control:\n+        return traverse_control;\n+      case Type::Category::Other:\n+        return traverse_other;\n+      case Type::Category::Undef:\n+        n->dump();\n+        assert(false, \"category undef ??\");\n+      default:\n+        n->dump();\n+        assert(false, \"not covered\");\n+    }\n+    return false;\n+  };\n+  auto category = [&] (Node* n) {\n+    const Type *t = n->bottom_type();\n+    switch (t->category()) {\n+      case Type::Category::Data:\n+        return use_color ? \"\\u001b[34md\\u001b[0m\" : \"d\";\n+      case Type::Category::Memory:\n+        return use_color ? \"\\u001b[32mm\\u001b[0m\" : \"m\";\n+      case Type::Category::Mixed:\n+        return use_color ? \"\\u001b[35mx\\u001b[0m\" : \"x\";\n+      case Type::Category::Control:\n+        return use_color ? \"\\u001b[31mc\\u001b[0m\" : \"c\";\n+      case Type::Category::Other:\n+        return use_color ? \"\\u001b[33mo\\u001b[0m\" : \"o\";\n+      case Type::Category::Undef:\n+        n->dump();\n+        assert(false, \"category undef ??\");\n+      default:\n+        n->dump();\n+        assert(false, \"not covered\");\n+    }\n+    return \"?\";\n+  };\n+  Compile* C = Compile::current();\n+  print_old &= (C->matcher() != NULL); \/\/ only show old if there are new\n+  print_blocks &= (C->cfg() != NULL); \/\/ only show blocks if available\n+  auto old_node = [&] (Node* n) {\n+    if (C->matcher() == NULL || !C->node_arena()->contains(n)) {\n+      return (Node*)NULL;\n+    } else {\n+      return C->matcher()->find_old_node(n);\n+    }\n+  };\n+  auto print_node_idx = [&] (Node* n) {\n+    char buf[30];\n+    if (n == NULL) {\n+      sprintf(buf,\"_\");           \/\/ null\n+    } else if (C->node_arena()->contains(n)) {\n+      sprintf(buf, \"%d\", n->_idx);  \/\/ new node\n+    } else {\n+      sprintf(buf, \"o%d\", n->_idx); \/\/ old node\n+    }\n+    tty->print(\"%6s\", buf);\n+  };\n+  auto print_node_block = [&] (Node* n) {\n+    Block* b = C->node_arena()->contains(n)\n+               ? C->cfg()->get_block_for_node(n)\n+               : NULL; \/\/ guard agains old nodes\n+    if (b == NULL) {\n+      tty->print(\"     _\");\n+      tty->print(\"     _\");\n+      tty->print(\"   _\");\n+    } else {\n+      print_node_idx(b->head());\n+      if(b->_idom) {\n+        print_node_idx(b->_idom->head());\n+      } else {\n+        tty->print(\"     _\");\n+      }\n+      tty->print(\"%4d\", b->_dom_depth);\n+    }\n+  };\n+\n+  auto worklist_push = [&] (Node* n, Node* p, const long d) {\n+    worklist.push(n);\n+    parent.Insert(n, p);\n+    distance.Insert(n, (void*)d);\n+  };\n+  worklist_push(this, this, 0);\n+\n+  if (target == NULL) {\n+    \/\/ BFS header\n+    tty->print(\"dis\");\n+    if (print_blocks) {\n+      tty->print(\"  head  idom dep\");\n+    }\n+    if(print_old) {\n+      tty->print(\"   old\");\n+    }\n+    tty->print(\"   par dir dump\\n\");\n+    tty->print(\"-------------------------------------------\\n\");\n+  }\n+\n+  uint pos = 0;\n+  while (pos < worklist.size()) {\n+    \/\/ process next item\n+    Node* n = worklist.at(pos++);\n+    long d = abs((long)distance[n]);\n+    const char* direction = ((long)distance[n] >= 0) ? \"+\" : \"-\";\n+    if (target == NULL) {\n+      tty->print(\"%3ld\", d);                          \/\/ distance\n+      if (print_blocks) {\n+        print_node_block(n);                         \/\/ block\n+      }\n+      if (print_old) {\n+        print_node_idx(old_node(n));                 \/\/ old node\n+      }\n+      print_node_idx((Node*)parent[n]);              \/\/ parent\n+      tty->print(\" %s%s \", direction, category(n));  \/\/ direction and category\n+      n->dump();                                     \/\/ node dump\n+    }\n+    if (n->is_Con()) {\n+      continue; \/\/ don't traverse through constant or top node\n+    }\n+\n+    \/\/ traverse inputs\n+    if (traverse_inputs && max_distance > d) {\n+      for (uint i = 0; i < n->req(); i++) {\n+        Node* in = n->in(i);\n+        if (in == NULL || !is_visit(in)) {\n+          continue;\n+        }\n+        if (parent[in] == NULL) {\n+          worklist_push(in, n, d+1); \/\/ positive for input\n+        }\n+      }\n+    }\n+\n+    \/\/ traverse outputs\n+    if (traverse_outputs && max_distance > d) {\n+      for (uint i = 0; i < n->outcnt(); i++) {\n+        Node* out = n->raw_out(i);\n+        if (out == NULL || !is_visit(out)) {\n+          continue;\n+        }\n+        if (parent[out] == NULL) {\n+          worklist_push(out, n, -d-1); \/\/ negative for output\n+        }\n+      }\n+    }\n+  }\n+\n+  \/\/ backtrace\n+  if (target != NULL) {\n+    if (parent[target] == NULL) {\n+      tty->print(\"\\nCould not find target in BFS.\\n\");\n+      return;\n+    }\n+    tty->print(\"\\nBacktrace target.\\n\");\n+    \/\/ backtrace header\n+    tty->print(\"dis\");\n+    if (print_blocks) {\n+      tty->print(\"  head  idom dep\");\n+    }\n+    if(print_old) {\n+      tty->print(\"   old\");\n+    }\n+    tty->print(\"dir dump\\n\"); \/\/ backtrace header\n+    tty->print(\"-------------------------------------\\n\");\n+    Node* current = target;\n+    while (current != (Node*)parent[current]) {\n+      const char* direction = ((long)distance[current] >=0 ) ? \"+\" : \"-\";\n+      tty->print(\"%3ld\", abs((long)distance[current]));    \/\/ distance\n+      if (print_blocks) {\n+        print_node_block(current);                         \/\/ block\n+      }\n+      if (print_old) {\n+        print_node_idx(old_node(current));                 \/\/ old node\n+      }\n+      tty->print(\" %s%s \", direction, category(current));  \/\/ direction and category\n+      current->dump();                                     \/\/ node dump\n+      current = (Node*)parent[current];\n+    }\n+    tty->print(\"  0\");                      \/\/ distance\n+    if (print_blocks) {\n+      print_node_block(this);               \/\/ block\n+    }\n+    if (print_old) {\n+      print_node_idx(old_node(this));       \/\/ old node\n+    }\n+    tty->print(\"  %s \", category(this));    \/\/ direction and category\n+    this->dump();                           \/\/ node dump\n+  }\n+}\n+\n+\n+\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":296,"deletions":0,"binary":false,"changes":296,"status":"modified"},{"patch":"@@ -1193,0 +1193,1 @@\n+  void print_bfs (const uint max_distance, Node* target, const char* filter); \/\/ Print BFS traversal\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}