{"files":[{"patch":"@@ -1817,1 +1817,1 @@\n-    tty->print(\"print_bfs: max_distance must be non-negative!\\n\");\n+    tty->print(\"dump_bfs: max_distance must be non-negative!\\n\");\n@@ -1821,10 +1821,0 @@\n-\n-  if (_target == nullptr) {\n-    tty->print(\"No target: perform BFS.\\n\");\n-  } else {\n-    tty->print(\"Find shortest path:\");\n-    print_node_idx(_start);\n-    tty->print(\" ->\");\n-    print_node_idx(_target);\n-    tty->print(\"\\n\");\n-  }\n@@ -2110,1 +2100,1 @@\n-\/\/------------------------------print_bfs--------------------------------------\n+\/\/------------------------------dump_bfs--------------------------------------\n@@ -2141,1 +2131,1 @@\n-\/\/   if->print_bfs(10, 0, \"+cxo\")\n+\/\/   if->dump_bfs(10, 0, \"+cxo\")\n@@ -2144,1 +2134,1 @@\n-\/\/   phi->print_bfs(5, 0, \"-dxo\")\n+\/\/   phi->dump_bfs(5, 0, \"-dxo\")\n@@ -2147,1 +2137,1 @@\n-\/\/   x->print_bfs(10, y, 0)\n+\/\/   x->dump_bfs(10, y, 0)\n@@ -2151,1 +2141,1 @@\n-\/\/   find_node(385)->print_bfs(3, 0, \"cdmox+#OB\")\n+\/\/   find_node(385)->dump_bfs(3, 0, \"cdmox+#OB\")\n@@ -2163,2 +2153,2 @@\n-void Node::print_bfs(const int max_distance, Node* target, char const* options) {\n-  PrintBFS bfs(this, max_distance, target, options);\n+void Node::dump_bfs(const int max_distance, Node* target, char const* options) const {\n+  PrintBFS bfs((Node*)this, max_distance, target, options);\n@@ -2422,67 +2412,0 @@\n-\/\/----------------------------collect_nodes_i----------------------------------\n-\/\/ Collects nodes from an Ideal graph, starting from a given start node and\n-\/\/ moving in a given direction until a certain depth (distance from the start\n-\/\/ node) is reached. Duplicates are ignored.\n-\/\/ Arguments:\n-\/\/   queue:         the nodes are collected into this array.\n-\/\/   start:         the node at which to start collecting.\n-\/\/   direction:     if this is a positive number, collect input nodes; if it is\n-\/\/                  a negative number, collect output nodes.\n-\/\/   depth:         collect nodes up to this distance from the start node.\n-\/\/   include_start: whether to include the start node in the result collection.\n-\/\/   only_ctrl:     whether to regard control edges only during traversal.\n-\/\/   only_data:     whether to regard data edges only during traversal.\n-static void collect_nodes_i(GrowableArray<Node*>* queue, const Node* start, int direction, uint depth, bool include_start, bool only_ctrl, bool only_data) {\n-  bool indent = depth <= PrintIdealIndentThreshold;\n-  Node* s = (Node*) start; \/\/ remove const\n-  queue->append(s);\n-  int begin = 0;\n-  int end = 0;\n-\n-  s->set_indent(0);\n-  for(uint i = 0; i < depth; i++) {\n-    end = queue->length();\n-    for(int j = begin; j < end; j++) {\n-      Node* tp  = queue->at(j);\n-      uint limit = direction > 0 ? tp->len() : tp->outcnt();\n-      for(uint k = 0; k < limit; k++) {\n-        Node* n = direction > 0 ? tp->in(k) : tp->raw_out(k);\n-\n-        if (not_a_node(n))  continue;\n-        \/\/ do not recurse through top or the root (would reach unrelated stuff)\n-        if (n->is_Root() || n->is_top()) continue;\n-        if (only_ctrl && !n->is_CFG()) continue;\n-        if (only_data && n->is_CFG()) continue;\n-        bool in_queue = queue->contains(n);\n-        if (!in_queue) {\n-          queue->append(n);\n-          n->set_indent(indent ? (i + 1) : 0);\n-        }\n-      }\n-    }\n-    begin = end;\n-  }\n-  if (!include_start) {\n-    queue->remove(s);\n-  }\n-}\n-\n-\/\/------------------------------dump_nodes-------------------------------------\n-static void dump_nodes(const Node* start, int d, bool only_ctrl) {\n-  if (not_a_node(start)) return;\n-\n-  GrowableArray <Node *> queue(Compile::current()->live_nodes());\n-  collect_nodes_i(&queue, start, d, (uint) ABS(d), true, only_ctrl, false);\n-\n-  int end = queue.length();\n-  if (d > 0) {\n-    for(int j = end-1; j >= 0; j--) {\n-      queue.at(j)->dump();\n-    }\n-  } else {\n-    for(int j = 0; j < end; j++) {\n-      queue.at(j)->dump();\n-    }\n-  }\n-}\n-\n@@ -2491,1 +2414,5 @@\n-  dump_nodes(this, d, false);\n+  if(d > 0) {\n+    dump_bfs(abs(d), nullptr, \"cdmxo+\");\n+  } else {\n+    dump_bfs(abs(d), nullptr, \"cdmxo-\");\n+  }\n@@ -2497,1 +2424,5 @@\n-  dump_nodes(this, d, true);\n+  if(d > 0) {\n+    dump_bfs(abs(d), nullptr, \"cxo+\"); \/\/ no data, no memory\n+  } else {\n+    dump_bfs(abs(d), nullptr, \"cxo-\"); \/\/ no data, no memory\n+  }\n@@ -2520,19 +2451,0 @@\n-\/\/---------------------------collect_nodes-------------------------------------\n-\/\/ An entry point to the low-level node collection facility, to start from a\n-\/\/ given node in the graph. The start node is by default not included in the\n-\/\/ result.\n-\/\/ Arguments:\n-\/\/   ns:   collect the nodes into this data structure.\n-\/\/   d:    the depth (distance from start node) to which nodes should be\n-\/\/         collected. A value >0 indicates input nodes, a value <0, output\n-\/\/         nodes.\n-\/\/   ctrl: include only control nodes.\n-\/\/   data: include only data nodes.\n-void Node::collect_nodes(GrowableArray<Node*> *ns, int d, bool ctrl, bool data) const {\n-  if (ctrl && data) {\n-    \/\/ ignore nonsensical combination\n-    return;\n-  }\n-  collect_nodes_i(ns, this, d, (uint) ABS(d), false, ctrl, data);\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":18,"deletions":106,"binary":false,"changes":124,"status":"modified"},{"patch":"@@ -1194,1 +1194,1 @@\n-  void print_bfs(const int max_distance, Node* target, char const* options); \/\/ Print BFS traversal\n+  void dump_bfs(const int max_distance, Node* target, char const* options) const; \/\/ Print BFS traversal\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}