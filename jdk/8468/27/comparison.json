{"files":[{"patch":"@@ -195,2 +195,2 @@\n-void ReturnNode::dump_req(outputStream *st) const {\n-  \/\/ Dump the required inputs, enclosed in '(' and ')'\n+void ReturnNode::dump_req(outputStream *st, DumpConfig* dc) const {\n+  \/\/ Dump the required inputs, after printing \"returns\"\n@@ -199,3 +199,8 @@\n-    if (i == TypeFunc::Parms) st->print(\"returns\");\n-    if (in(i)) st->print(\"%c%d \", Compile::current()->node_arena()->contains(in(i)) ? ' ' : 'o', in(i)->_idx);\n-    else st->print(\"_ \");\n+    if (i == TypeFunc::Parms) st->print(\"returns \");\n+    Node* p = in(i);\n+    if (p != nullptr) {\n+      p->dump_idx(false, st, dc);\n+      st->print(\" \");\n+    } else {\n+      st->print(\"_ \");\n+    }\n@@ -238,2 +243,2 @@\n-void RethrowNode::dump_req(outputStream *st) const {\n-  \/\/ Dump the required inputs, enclosed in '(' and ')'\n+void RethrowNode::dump_req(outputStream *st, DumpConfig* dc) const {\n+  \/\/ Dump the required inputs, after printing \"exception\"\n@@ -242,3 +247,8 @@\n-    if (i == TypeFunc::Parms) st->print(\"exception\");\n-    if (in(i)) st->print(\"%c%d \", Compile::current()->node_arena()->contains(in(i)) ? ' ' : 'o', in(i)->_idx);\n-    else st->print(\"_ \");\n+    if (i == TypeFunc::Parms) st->print(\"exception \");\n+    Node* p = in(i);\n+    if (p != nullptr) {\n+      p->dump_idx(false, st, dc);\n+      st->print(\" \");\n+    } else {\n+      st->print(\"_ \");\n+    }\n@@ -692,1 +702,1 @@\n-void CallNode::dump_req(outputStream *st) const {\n+void CallNode::dump_req(outputStream *st, DumpConfig* dc) const {\n@@ -697,2 +707,7 @@\n-    if (in(i)) st->print(\"%c%d \", Compile::current()->node_arena()->contains(in(i)) ? ' ' : 'o', in(i)->_idx);\n-    else st->print(\"_ \");\n+    Node* p = in(i);\n+    if (p != nullptr) {\n+      p->dump_idx(false, st, dc);\n+      st->print(\" \");\n+    } else {\n+      st->print(\"_ \");\n+    }\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":28,"deletions":13,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -131,1 +131,1 @@\n-  virtual void dump_req(outputStream *st = tty) const;\n+  virtual void dump_req(outputStream *st = tty, DumpConfig* dc = nullptr) const;\n@@ -152,1 +152,1 @@\n-  virtual void dump_req(outputStream *st = tty) const;\n+  virtual void dump_req(outputStream *st = tty, DumpConfig* dc = nullptr) const;\n@@ -659,1 +659,1 @@\n-  virtual void        dump_req(outputStream* st = tty) const;\n+  virtual void        dump_req(outputStream* st = tty, DumpConfig* dc = nullptr) const;\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1699,0 +1699,664 @@\n+class PrintBFS {\n+public:\n+  PrintBFS(Node* start, const int max_distance, Node* target, char const* options)\n+  : _start(start), _max_distance(max_distance), _target(target), _options(options),\n+    _dcc(this), _info_uid(cmpkey, hashkey) {}\n+\n+  void run();\n+private:\n+  \/\/ pipeline steps\n+  bool configure();\n+  void collect();\n+  void select();\n+  void select_all();\n+  void select_all_paths();\n+  void select_shortest_path();\n+  void sort();\n+  void print();\n+\n+  \/\/ inputs\n+  Node* _start;\n+  const int _max_distance;\n+  Node* _target;\n+  char const* _options;\n+\n+  \/\/ options\n+  bool _traverse_inputs = false;\n+  bool _traverse_outputs = false;\n+  struct Filter {\n+    bool _control = false;\n+    bool _memory = false;\n+    bool _data = false;\n+    bool _mixed = false;\n+    bool _other = false;\n+    bool is_empty() const {\n+      return !(_control || _memory || _data || _mixed || _other);\n+    }\n+    void set_all() {\n+      _control = true;\n+      _memory = true;\n+      _data = true;\n+      _mixed = true;\n+      _other = true;\n+    }\n+  };\n+  Filter _filter_visit;\n+  Filter _filter_boundary;\n+  bool _sort_idx = false;\n+  bool _all_paths = false;\n+  bool _use_color = false;\n+  bool _print_blocks = false;\n+  bool _print_old = false;\n+  static void print_options_help(bool print_examples);\n+  bool parse_options();\n+\n+  \/\/ node category (filter \/ color)\n+  static bool filter_category(Node* n, Filter& filter); \/\/ filter node category against options\n+public:\n+  class DumpConfigColored : public Node::DumpConfig {\n+  public:\n+    DumpConfigColored(PrintBFS* bfs) : _bfs(bfs) {};\n+    virtual void pre_dump(outputStream* st, const Node* n);\n+    virtual void post_dump(outputStream* st);\n+  private:\n+    PrintBFS* _bfs;\n+  };\n+private:\n+  DumpConfigColored _dcc;\n+\n+  \/\/ node info\n+  static Node* old_node(Node* n); \/\/ mach node -> prior IR node\n+  static void print_node_idx(Node* n); \/\/ to tty\n+  static void print_node_block(Node* n); \/\/ to tty: head idx, _idom, _dom_depth\n+\n+  \/\/ traversal data structures\n+  Node_List _worklist; \/\/ BFS queue\n+  void maybe_traverse(Node* src, Node* dst);\n+\n+  \/\/ node info annotation\n+  class Info {\n+  public:\n+    Info() : Info(nullptr, 0) {};\n+    Info(Node* node, int distance)\n+      : _node(node), _distance_from_start(distance) {};\n+    Node* node() { return _node; };\n+    int distance() const { return _distance_from_start; };\n+    int distance_from_target() const { return _distance_from_target; }\n+    void set_distance_from_target(int d) { _distance_from_target = d; }\n+    Node_List edge_bwd; \/\/ pointing toward _start\n+    bool is_marked() const { return _mark; } \/\/ marked to keep during select\n+    void set_mark() { _mark = true; }\n+  private:\n+    Node* _node;\n+    int _distance_from_start; \/\/ distance from _start\n+    int _distance_from_target = 0; \/\/ distance from _target if _all_paths\n+    bool _mark = false;\n+  };\n+  Dict _info_uid;            \/\/ Node -> uid\n+  GrowableArray<Info> _info; \/\/ uid  -> info\n+\n+  Info* find_info(const Node* n) {\n+    size_t uid = (size_t)_info_uid[n];\n+    if (uid == 0) {\n+      return nullptr;\n+    }\n+    return &_info.at((int)uid);\n+  }\n+\n+  void make_info(Node* node, const int distance) {\n+    assert(find_info(node) == nullptr, \"node does not yet have info\");\n+    size_t uid = _info.length() + 1;\n+    _info_uid.Insert(node, (void*)uid);\n+    _info.at_put_grow((int)uid, Info(node, distance));\n+    assert(find_info(node)->node() == node, \"stored correct node\");\n+  };\n+\n+  \/\/ filled by sort, printed by print\n+  GrowableArray<Node*> _print_list;\n+\n+  \/\/ print header + node table\n+  void print_header() const;\n+  void print_node(Node* n);\n+};\n+\n+void PrintBFS::run() {\n+  if (!configure()) {\n+    return;\n+  }\n+  collect();\n+  select();\n+  sort();\n+  print();\n+}\n+\n+\/\/ set up configuration for BFS and print\n+bool PrintBFS::configure() {\n+  if (_max_distance < 0) {\n+    tty->print(\"dump_bfs: max_distance must be non-negative!\\n\");\n+    return false;\n+  }\n+  return parse_options();\n+}\n+\n+\/\/ BFS traverse according to configuration, fill worklist and info\n+void PrintBFS::collect() {\n+  maybe_traverse(_start, _start);\n+  uint pos = 0;\n+  while (pos < _worklist.size()) {\n+    Node* n = _worklist.at(pos++); \/\/ next node to traverse\n+    Info* info = find_info(n);\n+    if (!filter_category(n, _filter_visit) && n != _start) {\n+      continue; \/\/ we hit boundary, do not traverse further\n+    }\n+    if (n != _start && n->is_Root()) {\n+      continue; \/\/ traversing through root node would lead to unrelated nodes\n+    }\n+    if (_traverse_inputs && _max_distance > info->distance()) {\n+      for (uint i = 0; i < n->req(); i++) {\n+        maybe_traverse(n, n->in(i));\n+      }\n+    }\n+    if (_traverse_outputs && _max_distance > info->distance()) {\n+      for (uint i = 0; i < n->outcnt(); i++) {\n+        maybe_traverse(n, n->raw_out(i));\n+      }\n+    }\n+  }\n+}\n+\n+\/\/ go through work list, mark those that we want to print\n+void PrintBFS::select() {\n+  if (_target == nullptr ) {\n+    select_all();\n+  } else {\n+    if (find_info(_target) == nullptr) {\n+      tty->print(\"Could not find target in BFS.\\n\");\n+      return;\n+    }\n+    if (_all_paths) {\n+      select_all_paths();\n+    } else {\n+      select_shortest_path();\n+    }\n+  }\n+}\n+\n+\/\/ take all nodes from BFS\n+void PrintBFS::select_all() {\n+  for (uint i = 0; i < _worklist.size(); i++) {\n+    Node* n = _worklist.at(i);\n+    Info* info = find_info(n);\n+    info->set_mark();\n+  }\n+}\n+\n+\/\/ traverse backward from target, along edges found in BFS\n+void PrintBFS::select_all_paths() {\n+  uint pos = 0;\n+  Node_List backtrace;\n+  \/\/ start from target\n+  backtrace.push(_target);\n+  find_info(_target)->set_mark();\n+  \/\/ traverse backward\n+  while (pos < backtrace.size()) {\n+    Node* n = backtrace.at(pos++);\n+    Info* info = find_info(n);\n+    for (uint i = 0; i < info->edge_bwd.size(); i++) {\n+      \/\/ all backward edges\n+      Node* back = info->edge_bwd.at(i);\n+      Info* back_info = find_info(back);\n+      if (!back_info->is_marked()) {\n+        \/\/ not yet found this on way back.\n+        back_info->set_distance_from_target(info->distance_from_target() + 1);\n+        if (back_info->distance_from_target() + back_info->distance() <= _max_distance) {\n+          \/\/ total distance is small enough\n+          back_info->set_mark();\n+          backtrace.push(back);\n+        }\n+      }\n+    }\n+  }\n+}\n+\n+void PrintBFS::select_shortest_path() {\n+  Node* current = _target;\n+  while (true) {\n+    Info* info = find_info(current);\n+    info->set_mark();\n+    if (current == _start) {\n+      break;\n+    }\n+    \/\/ first edge -> leads us one step closer to _start\n+    current = info->edge_bwd.at(0);\n+  }\n+}\n+\n+int node_idx_cmp(Node** n1, Node** n2) {\n+  return (*n1)->_idx - (*n2)->_idx;\n+}\n+\n+\/\/ go through worklist in desired order, put the marked ones in print list\n+void PrintBFS::sort() {\n+  if (_traverse_inputs && !_traverse_outputs) {\n+    \/\/ reverse order\n+    for (int i = _worklist.size() - 1; i >= 0; i--) {\n+      Node* n = _worklist.at(i);\n+      Info* info = find_info(n);\n+      if (info->is_marked()) {\n+        _print_list.push(n);\n+      }\n+    }\n+  } else {\n+    \/\/ same order as worklist\n+    for (uint i = 0; i < _worklist.size(); i++) {\n+      Node* n = _worklist.at(i);\n+      Info* info = find_info(n);\n+      if (info->is_marked()) {\n+        _print_list.push(n);\n+      }\n+    }\n+  }\n+  if (_sort_idx) {\n+    _print_list.sort(node_idx_cmp);\n+  }\n+}\n+\n+\/\/ go through printlist and print\n+void PrintBFS::print() {\n+  if (_print_list.length() > 0 ) {\n+    print_header();\n+    for (int i = 0; i < _print_list.length(); i++) {\n+      Node* n = _print_list.at(i);\n+      print_node(n);\n+    }\n+  } else {\n+    tty->print(\"No nodes to print.\\n\");\n+  }\n+}\n+\n+void PrintBFS::print_options_help(bool print_examples) {\n+  tty->print(\"Usage: node->dump_bfs(int max_distance, Node* target, char* options)\\n\");\n+  tty->print(\"\\n\");\n+  tty->print(\"Usecases:\\n\");\n+  tty->print(\"  BFS traversal: no target required\\n\");\n+  tty->print(\"  shortest path: set target\\n\");\n+  tty->print(\"  all paths: set target and put 'A' in options\\n\");\n+  tty->print(\"  detect loop: subcase of all paths, have start==target\\n\");\n+  tty->print(\"\\n\");\n+  tty->print(\"Arguments:\\n\");\n+  tty->print(\"  this\/start: staring point of BFS\\n\");\n+  tty->print(\"  target:\\n\");\n+  tty->print(\"    if nullptr: simple BFS\\n\");\n+  tty->print(\"    else: shortest path or all paths between this\/start and target\\n\");\n+  tty->print(\"  options:\\n\");\n+  tty->print(\"    if nullptr: same as \\\"cdmxo@B\\\"\\n\");\n+  tty->print(\"    else: use combination of following characters\\n\");\n+  tty->print(\"      h: display this help info\\n\");\n+  tty->print(\"      H: display this help info, with examples\\n\");\n+  tty->print(\"      +: traverse in-edges (on if neither + nor -)\\n\");\n+  tty->print(\"      -: traverse out-edges\\n\");\n+  tty->print(\"      c: visit control nodes\\n\");\n+  tty->print(\"      m: visit memory nodes\\n\");\n+  tty->print(\"      d: visit data nodes\\n\");\n+  tty->print(\"      x: visit mixed nodes\\n\");\n+  tty->print(\"      o: visit other nodes\\n\");\n+  tty->print(\"      C: boundary control nodes\\n\");\n+  tty->print(\"      M: boundary memory nodes\\n\");\n+  tty->print(\"      D: boundary data nodes\\n\");\n+  tty->print(\"      X: boundary mixed nodes\\n\");\n+  tty->print(\"      O: boundary other nodes\\n\");\n+  tty->print(\"      S: sort displayed nodes by node idx\\n\");\n+  tty->print(\"      A: all paths (not just shortest path to target)\\n\");\n+  tty->print(\"      #: display node category in color (not supported in all terminals)\\n\");\n+  tty->print(\"      @: print old nodes - before matching (if available)\\n\");\n+  tty->print(\"      B: print scheduling blocks (if available)\\n\");\n+  tty->print(\"\\n\");\n+  tty->print(\"recursively follow edges to nodes with permitted visit types,\\n\");\n+  tty->print(\"on the boundary additionally display nodes allowed in boundary types\\n\");\n+  tty->print(\"\\n\");\n+  tty->print(\"output columns:\\n\");\n+  tty->print(\"  d:     BFS distance to this\/start\\n\");\n+  tty->print(\"  adp:   all paths distance (d_start + d_target)\\n\");\n+  tty->print(\"  block: block block in which the node has been scheduled [head(), _idom->head(), _dom_depth]\\n\");\n+  tty->print(\"  old:   old IR node - before matching\\n\");\n+  tty->print(\"  dump:  node->dump()\\n\");\n+  tty->print(\"\\n\");\n+  tty->print(\"Note: if none of the \\\"cmdxo\\\" characters are in the options string\\n\");\n+  tty->print(\"      then we set all of them.\\n\");\n+  tty->print(\"      This allows for short strings like \\\"#\\\" for colored input traversal\\n\");\n+  tty->print(\"      or \\\"-#\\\" for colored output traversal.\\n\");\n+  if (print_examples) {\n+    tty->print(\"\\n\");\n+    tty->print(\"Examples:\\n\");\n+    tty->print(\"  if->dump_bfs(10, 0, \\\"+cxo\\\")\\n\");\n+    tty->print(\"    starting at some if node, traverse inputs recursively\\n\");\n+    tty->print(\"    only along control (mixed and other can also be control)\\n\");\n+    tty->print(\"  phi->dump_bfs(5, 0, \\\"-dxo\\\")\\n\");\n+    tty->print(\"    starting at phi node, traverse outputs recursively\\n\");\n+    tty->print(\"    only along data (mixed and other can also have data flow)\\n\");\n+    tty->print(\"  find_node(385)->dump_bfs(3, 0, \\\"cdmox+#@B\\\")\\n\");\n+    tty->print(\"    find inputs of node 385, up to 3 nodes up (+)\\n\");\n+    tty->print(\"    traverse all nodes (cdmox), use colors (#)\\n\");\n+    tty->print(\"    display old nodes and blocks, if they exist\\n\");\n+    tty->print(\"    useful call to start with\\n\");\n+    tty->print(\"  find_node(102)->dump_bfs(10,0,\\\"dCDMOX-\\\")\\n\");\n+    tty->print(\"    find non-data dependencies of a data node\\n\");\n+    tty->print(\"    follow data node outputs until find another category\\n\");\n+    tty->print(\"    node as the boundary\\n\");\n+    tty->print(\"  x->dump_bfs(10, y, 0)\\n\");\n+    tty->print(\"    find shortest path from x to y, along any edge or node\\n\");\n+    tty->print(\"    will not find a path if it is longer than 10\\n\");\n+    tty->print(\"    useful to find how x and y are related\\n\");\n+    tty->print(\"  find_node(741)->dump_bfs(20,find_node(746),\\\"c+\\\")\\n\");\n+    tty->print(\"    find shortest control path  between two nodes\\n\");\n+    tty->print(\"  find_node(741)->dump_bfs(8,find_node(746),\\\"cdmxo+A\\\")\\n\");\n+    tty->print(\"    find all paths (A) between two nodes of length at most 8\\n\");\n+    tty->print(\"  find_node(741)->dump_bfs(7,find_node(741),\\\"c+A\\\")\\n\");\n+    tty->print(\"    find all control loops for this node\\n\");\n+  }\n+}\n+\n+bool PrintBFS::parse_options() {\n+  if (_options == nullptr) {\n+    _options = \"cmdxo@B\"; \/\/ default options\n+  }\n+  size_t len = strlen(_options);\n+  for (size_t i = 0; i < len; i++) {\n+    switch (_options[i]) {\n+      case '+':\n+        _traverse_inputs = true;\n+        break;\n+      case '-':\n+        _traverse_outputs = true;\n+        break;\n+      case 'c':\n+        _filter_visit._control = true;\n+        break;\n+      case 'm':\n+        _filter_visit._memory = true;\n+        break;\n+      case 'd':\n+        _filter_visit._data = true;\n+        break;\n+      case 'x':\n+        _filter_visit._mixed = true;\n+        break;\n+      case 'o':\n+        _filter_visit._other = true;\n+        break;\n+      case 'C':\n+        _filter_boundary._control = true;\n+        break;\n+      case 'M':\n+        _filter_boundary._memory = true;\n+        break;\n+      case 'D':\n+        _filter_boundary._data = true;\n+        break;\n+      case 'X':\n+        _filter_boundary._mixed = true;\n+        break;\n+      case 'O':\n+        _filter_boundary._other = true;\n+        break;\n+      case 'S':\n+        _sort_idx = true;\n+        break;\n+      case 'A':\n+        _all_paths = true;\n+        break;\n+      case '#':\n+        _use_color = true;\n+        break;\n+      case 'B':\n+        _print_blocks = true;\n+        break;\n+      case '@':\n+        _print_old = true;\n+        break;\n+      case 'h':\n+        print_options_help(false);\n+        return false;\n+       case 'H':\n+        print_options_help(true);\n+        return false;\n+      default:\n+        tty->print_cr(\"dump_bfs: Unrecognized option \\'%c\\'\", _options[i]);\n+        tty->print_cr(\"for help, run: find_node(0)->dump_bfs(0,0,\\\"H\\\")\");\n+        return false;\n+    }\n+  }\n+  if (!_traverse_inputs && !_traverse_outputs) {\n+    _traverse_inputs = true;\n+  }\n+  if (_filter_visit.is_empty()) {\n+    _filter_visit.set_all();\n+  }\n+  Compile* C = Compile::current();\n+  _print_old &= (C->matcher() != nullptr); \/\/ only show old if there are new\n+  _print_blocks &= (C->cfg() != nullptr); \/\/ only show blocks if available\n+  return true;\n+}\n+\n+bool PrintBFS::filter_category(Node* n, Filter& filter) {\n+  const Type* t = n->bottom_type();\n+  switch (t->category()) {\n+    case Type::Category::Data:\n+      return filter._data;\n+    case Type::Category::Memory:\n+      return filter._memory;\n+    case Type::Category::Mixed:\n+      return filter._mixed;\n+    case Type::Category::Control:\n+      return filter._control;\n+    case Type::Category::Other:\n+      return filter._other;\n+    case Type::Category::Undef:\n+      n->dump();\n+      assert(false, \"category undef ??\");\n+    default:\n+      n->dump();\n+      assert(false, \"not covered\");\n+  }\n+  return false;\n+}\n+\n+void PrintBFS::DumpConfigColored::pre_dump(outputStream* st, const Node* n) {\n+  if (!_bfs->_use_color) {\n+    return;\n+  }\n+  Info* info = _bfs->find_info(n);\n+  if (info == nullptr || !info->is_marked()) {\n+    return;\n+  }\n+\n+  const Type* t = n->bottom_type();\n+  switch (t->category()) {\n+    case Type::Category::Data:\n+      st->print(\"\\u001b[34m\");\n+      break;\n+    case Type::Category::Memory:\n+      st->print(\"\\u001b[32m\");\n+      break;\n+    case Type::Category::Mixed:\n+      st->print(\"\\u001b[35m\");\n+      break;\n+    case Type::Category::Control:\n+      st->print(\"\\u001b[31m\");\n+      break;\n+    case Type::Category::Other:\n+      st->print(\"\\u001b[33m\");\n+      break;\n+    case Type::Category::Undef:\n+      n->dump();\n+      assert(false, \"category undef ??\");\n+      break;\n+    default:\n+      n->dump();\n+      assert(false, \"not covered\");\n+      break;\n+  }\n+}\n+\n+void PrintBFS::DumpConfigColored::post_dump(outputStream* st) {\n+  if (!_bfs->_use_color) {\n+    return;\n+  }\n+  st->print(\"\\u001b[0m\"); \/\/ white\n+}\n+\n+Node* PrintBFS::old_node(Node* n) {\n+  Compile* C = Compile::current();\n+  if (C->matcher() == nullptr || !C->node_arena()->contains(n)) {\n+    return (Node*)nullptr;\n+  } else {\n+    return C->matcher()->find_old_node(n);\n+  }\n+}\n+\n+void PrintBFS::print_node_idx(Node* n) {\n+  Compile* C = Compile::current();\n+  char buf[30];\n+  if (n == nullptr) {\n+    sprintf(buf,\"_\");           \/\/ null\n+  } else if (C->node_arena()->contains(n)) {\n+    sprintf(buf, \"%d\", n->_idx);  \/\/ new node\n+  } else {\n+    sprintf(buf, \"o%d\", n->_idx); \/\/ old node\n+  }\n+  tty->print(\"%6s\", buf);\n+}\n+\n+void PrintBFS::print_node_block(Node* n) {\n+  Compile* C = Compile::current();\n+  Block* b = C->node_arena()->contains(n)\n+             ? C->cfg()->get_block_for_node(n)\n+             : nullptr; \/\/ guard against old nodes\n+  if (b == nullptr) {\n+    tty->print(\"     _\");\n+    tty->print(\"     _\");\n+    tty->print(\"   _\");\n+  } else {\n+    print_node_idx(b->head());\n+    if (b->_idom) {\n+      print_node_idx(b->_idom->head());\n+    } else {\n+      tty->print(\"     _\");\n+    }\n+    tty->print(\"%4d\", b->_dom_depth);\n+  }\n+}\n+\n+\/\/ filter, and add to worklist, add info, note traversal edges\n+void PrintBFS::maybe_traverse(Node* src, Node* dst) {\n+  if (dst != nullptr &&\n+     (filter_category(dst, _filter_visit) ||\n+      filter_category(dst, _filter_boundary) ||\n+      dst == _start)) { \/\/ correct category or start?\n+    if (find_info(dst) == nullptr) {\n+      \/\/ never visited - set up info\n+      _worklist.push(dst);\n+      int d = 0;\n+      if (dst != _start) {\n+        d = find_info(src)->distance() + 1;\n+      }\n+      make_info(dst, d);\n+    }\n+    if (src != dst) {\n+      \/\/ traversal edges useful during select\n+      find_info(dst)->edge_bwd.push(src);\n+    }\n+  }\n+}\n+\n+void PrintBFS::print_header() const {\n+  tty->print(\"   d\");                         \/\/ distance\n+  if (_all_paths) {\n+    tty->print(\" apd\");                       \/\/ all paths distance\n+  }\n+  if (_print_blocks) {\n+    tty->print(\" [head  idom  d]\");           \/\/ block\n+  }\n+  if (_print_old) {\n+    tty->print(\"   old\");                     \/\/ old node\n+  }\n+  tty->print(\" dump\\n\");                      \/\/ node dump\n+  tty->print(\"---------------------------------------------\\n\");\n+}\n+\n+void PrintBFS::print_node(Node* n) {\n+  tty->print(\"%4d\", find_info(n)->distance());\/\/ distance\n+  if (_all_paths) {\n+    Info* info = find_info(n);\n+    int apd = info->distance() + info->distance_from_target();\n+    tty->print(\"%4d\", apd);                   \/\/ all paths distance\n+  }\n+  if (_print_blocks) {\n+    print_node_block(n);                      \/\/ block\n+  }\n+  if (_print_old) {\n+    print_node_idx(old_node(n));              \/\/ old node\n+  }\n+  tty->print(\" \");\n+  n->dump(\"\\n\", false, tty, &_dcc);           \/\/ node dump\n+}\n+\n+\/\/------------------------------dump_bfs--------------------------------------\n+\/\/ Call this from debugger\n+\/\/ Useful for BFS traversal, shortest path, all path, loop detection, etc\n+\/\/ Designed to be more readable, and provide additional info\n+\/\/ To find all options, run:\n+\/\/   find_node(0)->dump_bfs(0,0,\"H\")\n+void Node::dump_bfs(const int max_distance, Node* target, char const* options) {\n+  PrintBFS bfs(this, max_distance, target, options);\n+  bfs.run();\n+}\n+\n+\/\/ log10 rounded down\n+uint log10(const uint i) {\n+  uint v = 10;\n+  uint e = 0;\n+  while(v <= i) {\n+    v *= 10;\n+    e++;\n+  }\n+  return e;\n+}\n+\n+\/\/ -----------------------------dump_idx---------------------------------------\n+void Node::dump_idx(bool align, outputStream* st, DumpConfig* dc) const {\n+  if (dc != nullptr) {\n+    dc->pre_dump(st, this);\n+  }\n+  Compile* C = Compile::current();\n+  bool is_new = C->node_arena()->contains(this);\n+  if (align) { \/\/ print prefix empty spaces$\n+    \/\/ +1 for leading digit, +1 for \"o\"\n+    uint max_width = log10(C->unique()) + 2;\n+    \/\/ +1 for leading digit, maybe +1 for \"o\"\n+    uint width = log10(_idx) + 1 + (is_new ? 0 : 1);\n+    while (max_width > width) {\n+      st->print(\" \");\n+      width++;\n+    }\n+  }\n+  if (!is_new) {\n+    st->print(\"o\");\n+  }\n+  st->print(\"%d\", _idx);\n+  if (dc != nullptr) {\n+    dc->post_dump(st);\n+  }\n+}\n+\n+\/\/ -----------------------------dump_name--------------------------------------\n+void Node::dump_name(outputStream* st, DumpConfig* dc) const {\n+  if (dc != nullptr) {\n+    dc->pre_dump(st, this);\n+  }\n+  st->print(\"%s\", Name());\n+  if (dc != nullptr) {\n+    dc->post_dump(st);\n+  }\n+}\n+\n@@ -1769,1 +2433,1 @@\n-void Node::dump(const char* suffix, bool mark, outputStream *st) const {\n+void Node::dump(const char* suffix, bool mark, outputStream* st, DumpConfig* dc) const {\n@@ -1778,1 +2442,5 @@\n-  st->print(\"%c%d%s%s  === \", is_new ? ' ' : 'o', _idx, mark ? \" >\" : \"  \", Name());\n+  \/\/ idx mark name ===\n+  dump_idx(true, st, dc);\n+  st->print(mark ? \" >\" : \"  \");\n+  dump_name(st, dc);\n+  st->print(\"  === \");\n@@ -1781,2 +2449,2 @@\n-  dump_req(st);\n-  dump_prec(st);\n+  dump_req(st, dc);\n+  dump_prec(st, dc);\n@@ -1784,1 +2452,1 @@\n-  dump_out(st);\n+  dump_out(st, dc);\n@@ -1851,1 +2519,1 @@\n-void Node::dump_req(outputStream *st) const {\n+void Node::dump_req(outputStream* st, DumpConfig* dc) const {\n@@ -1860,1 +2528,2 @@\n-      st->print(\"%c%d \", Compile::current()->node_arena()->contains(d) ? ' ' : 'o', d->_idx);\n+      d->dump_idx(false, st, dc);\n+      st->print(\" \");\n@@ -1867,1 +2536,1 @@\n-void Node::dump_prec(outputStream *st) const {\n+void Node::dump_prec(outputStream* st, DumpConfig* dc) const {\n@@ -1875,1 +2544,2 @@\n-      st->print(\"%c%d \", Compile::current()->node_arena()->contains(in(i)) ? ' ' : 'o', in(i)->_idx);\n+      p->dump_idx(false, st, dc);\n+      st->print(\" \");\n@@ -1881,1 +2551,1 @@\n-void Node::dump_out(outputStream *st) const {\n+void Node::dump_out(outputStream* st, DumpConfig* dc) const {\n@@ -1883,1 +2553,1 @@\n-  st->print(\" [[\");\n+  st->print(\" [[ \");\n@@ -1892,1 +2562,2 @@\n-      st->print(\"%c%d \", Compile::current()->node_arena()->contains(u) ? ' ' : 'o', u->_idx);\n+      u->dump_idx(false, st, dc);\n+      st->print(\" \");\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":684,"deletions":13,"binary":false,"changes":697,"status":"modified"},{"patch":"@@ -1193,0 +1193,9 @@\n+  void dump_bfs(const int max_distance, Node* target, char const* options); \/\/ Print BFS traversal\n+  class DumpConfig {\n+  public:\n+    \/\/ overridden to implement coloring of node idx\n+    virtual void pre_dump(outputStream *st, const Node* n) = 0;\n+    virtual void post_dump(outputStream *st) = 0;\n+  };\n+  void dump_idx(bool align = false, outputStream* st = tty, DumpConfig* dc = nullptr) const;\n+  void dump_name(outputStream* st = tty, DumpConfig* dc = nullptr) const;\n@@ -1194,1 +1203,1 @@\n-  void dump(const char* suffix, bool mark = false, outputStream *st = tty) const; \/\/ Print this node.\n+  void dump(const char* suffix, bool mark = false, outputStream* st = tty, DumpConfig* dc = nullptr) const; \/\/ Print this node.\n@@ -1200,3 +1209,3 @@\n-  virtual void dump_req(outputStream *st = tty) const;    \/\/ Print required-edge info\n-  virtual void dump_prec(outputStream *st = tty) const;   \/\/ Print precedence-edge info\n-  virtual void dump_out(outputStream *st = tty) const;    \/\/ Print the output edge info\n+  virtual void dump_req(outputStream* st = tty, DumpConfig* dc = nullptr) const;    \/\/ Print required-edge info\n+  virtual void dump_prec(outputStream* st = tty, DumpConfig* dc = nullptr) const;   \/\/ Print precedence-edge info\n+  virtual void dump_out(outputStream* st = tty, DumpConfig* dc = nullptr) const;    \/\/ Print the output edge info\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"}]}