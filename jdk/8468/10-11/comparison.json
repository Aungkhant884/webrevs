{"files":[{"patch":"@@ -2539,94 +2539,0 @@\n-\/\/--------------------------collect_nodes_in-----------------------------------\n-static void collect_nodes_in(Node* start, GrowableArray<Node*> *ns, bool primary_is_data, bool collect_secondary) {\n-  \/\/ The maximum depth is determined using a BFS that visits all primary (data\n-  \/\/ or control) inputs and increments the depth at each level.\n-  uint d_in = 0;\n-  GrowableArray<Node*> nodes(Compile::current()->unique());\n-  nodes.push(start);\n-  int nodes_at_current_level = 1;\n-  int n_idx = 0;\n-  while (nodes_at_current_level > 0) {\n-    \/\/ Add all primary inputs reachable from the current level to the list, and\n-    \/\/ increase the depth if there were any.\n-    int nodes_at_next_level = 0;\n-    bool nodes_added = false;\n-    while (nodes_at_current_level > 0) {\n-      nodes_at_current_level--;\n-      Node* current = nodes.at(n_idx++);\n-      for (uint i = 0; i < current->len(); i++) {\n-        Node* n = current->in(i);\n-        if (not_a_node(n)) {\n-          continue;\n-        }\n-        if ((primary_is_data && n->is_CFG()) || (!primary_is_data && !n->is_CFG())) {\n-          continue;\n-        }\n-        if (!nodes.contains(n)) {\n-          nodes.push(n);\n-          nodes_added = true;\n-          nodes_at_next_level++;\n-        }\n-      }\n-    }\n-    if (nodes_added) {\n-      d_in++;\n-    }\n-    nodes_at_current_level = nodes_at_next_level;\n-  }\n-  start->collect_nodes(ns, d_in, !primary_is_data, primary_is_data);\n-  if (collect_secondary) {\n-    \/\/ Now, iterate over the secondary nodes in ns and add the respective\n-    \/\/ boundary reachable from them.\n-    GrowableArray<Node*> sns(Compile::current()->unique());\n-    for (GrowableArrayIterator<Node*> it = ns->begin(); it != ns->end(); ++it) {\n-      Node* n = *it;\n-      n->collect_nodes(&sns, 1, primary_is_data, !primary_is_data);\n-      for (GrowableArrayIterator<Node*> d = sns.begin(); d != sns.end(); ++d) {\n-        ns->append_if_missing(*d);\n-      }\n-      sns.clear();\n-    }\n-  }\n-}\n-\n-\/\/---------------------collect_nodes_in_all_data-------------------------------\n-\/\/ Collect the entire data input graph. Include the control boundary if\n-\/\/ requested.\n-\/\/ Arguments:\n-\/\/   ns:   collect the nodes into this data structure.\n-\/\/   ctrl: if true, include the control boundary.\n-void Node::collect_nodes_in_all_data(GrowableArray<Node*> *ns, bool ctrl) const {\n-  collect_nodes_in((Node*) this, ns, true, ctrl);\n-}\n-\n-\/\/--------------------------collect_nodes_in_all_ctrl--------------------------\n-\/\/ Collect the entire control input graph. Include the data boundary if\n-\/\/ requested.\n-\/\/   ns:   collect the nodes into this data structure.\n-\/\/   data: if true, include the control boundary.\n-void Node::collect_nodes_in_all_ctrl(GrowableArray<Node*> *ns, bool data) const {\n-  collect_nodes_in((Node*) this, ns, false, data);\n-}\n-\n-\/\/------------------collect_nodes_out_all_ctrl_boundary------------------------\n-\/\/ Collect the entire output graph until hitting control node boundaries, and\n-\/\/ include those.\n-void Node::collect_nodes_out_all_ctrl_boundary(GrowableArray<Node*> *ns) const {\n-  \/\/ Perform a BFS and stop at control nodes.\n-  GrowableArray<Node*> nodes(Compile::current()->unique());\n-  nodes.push((Node*) this);\n-  while (nodes.length() > 0) {\n-    Node* current = nodes.pop();\n-    if (not_a_node(current)) {\n-      continue;\n-    }\n-    ns->append_if_missing(current);\n-    if (!current->is_CFG()) {\n-      for (DUIterator i = current->outs(); current->has_out(i); i++) {\n-        nodes.push(current->out(i));\n-      }\n-    }\n-  }\n-  ns->remove((Node*) this);\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":0,"deletions":94,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -1219,8 +1219,0 @@\n-  \/\/ Node collectors, to be used in implementations of Node::rel().\n-  \/\/ Collect the entire data input graph. Include control inputs if requested.\n-  void collect_nodes_in_all_data(GrowableArray<Node*> *ns, bool ctrl) const;\n-  \/\/ Collect the entire control input graph. Include data inputs if requested.\n-  void collect_nodes_in_all_ctrl(GrowableArray<Node*> *ns, bool data) const;\n-  \/\/ Collect the entire output graph until hitting and including control nodes.\n-  void collect_nodes_out_all_ctrl_boundary(GrowableArray<Node*> *ns) const;\n-\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"}]}