{"files":[{"patch":"@@ -141,7 +141,0 @@\n-\n-\/\/ For a ParmNode, all immediate inputs and outputs are considered relevant\n-\/\/ both in compact and standard representation.\n-void ParmNode::related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const {\n-  this->collect_nodes(in_rel, 1, false, false);\n-  this->collect_nodes(out_rel, -1, false, false);\n-}\n@@ -195,2 +188,2 @@\n-void ReturnNode::dump_req(outputStream *st) const {\n-  \/\/ Dump the required inputs, enclosed in '(' and ')'\n+void ReturnNode::dump_req(outputStream *st, DumpConfig* dc) const {\n+  \/\/ Dump the required inputs, after printing \"returns\"\n@@ -199,3 +192,8 @@\n-    if (i == TypeFunc::Parms) st->print(\"returns\");\n-    if (in(i)) st->print(\"%c%d \", Compile::current()->node_arena()->contains(in(i)) ? ' ' : 'o', in(i)->_idx);\n-    else st->print(\"_ \");\n+    if (i == TypeFunc::Parms) st->print(\"returns \");\n+    Node* p = in(i);\n+    if (p != nullptr) {\n+      p->dump_idx(false, st, dc);\n+      st->print(\" \");\n+    } else {\n+      st->print(\"_ \");\n+    }\n@@ -238,2 +236,2 @@\n-void RethrowNode::dump_req(outputStream *st) const {\n-  \/\/ Dump the required inputs, enclosed in '(' and ')'\n+void RethrowNode::dump_req(outputStream *st, DumpConfig* dc) const {\n+  \/\/ Dump the required inputs, after printing \"exception\"\n@@ -242,3 +240,8 @@\n-    if (i == TypeFunc::Parms) st->print(\"exception\");\n-    if (in(i)) st->print(\"%c%d \", Compile::current()->node_arena()->contains(in(i)) ? ' ' : 'o', in(i)->_idx);\n-    else st->print(\"_ \");\n+    if (i == TypeFunc::Parms) st->print(\"exception \");\n+    Node* p = in(i);\n+    if (p != nullptr) {\n+      p->dump_idx(false, st, dc);\n+      st->print(\" \");\n+    } else {\n+      st->print(\"_ \");\n+    }\n@@ -692,1 +695,1 @@\n-void CallNode::dump_req(outputStream *st) const {\n+void CallNode::dump_req(outputStream *st, DumpConfig* dc) const {\n@@ -697,2 +700,7 @@\n-    if (in(i)) st->print(\"%c%d \", Compile::current()->node_arena()->contains(in(i)) ? ' ' : 'o', in(i)->_idx);\n-    else st->print(\"_ \");\n+    Node* p = in(i);\n+    if (p != nullptr) {\n+      p->dump_idx(false, st, dc);\n+      st->print(\" \");\n+    } else {\n+      st->print(\"_ \");\n+    }\n@@ -1464,13 +1472,0 @@\n-\n-\/\/ The related nodes of a SafepointNode are all data inputs, excluding the\n-\/\/ control boundary, as well as all outputs till level 2 (to include projection\n-\/\/ nodes and targets). In compact mode, just include inputs till level 1 and\n-\/\/ outputs as before.\n-void SafePointNode::related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const {\n-  if (compact) {\n-    this->collect_nodes(in_rel, 1, false, false);\n-  } else {\n-    this->collect_nodes_in_all_data(in_rel, false);\n-  }\n-  this->collect_nodes(out_rel, -2, false, false);\n-}\n@@ -2040,10 +2035,0 @@\n-\n-\/\/ The related set of lock nodes includes the control boundary.\n-void AbstractLockNode::related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const {\n-  if (compact) {\n-      this->collect_nodes(in_rel, 1, false, false);\n-    } else {\n-      this->collect_nodes_in_all_data(in_rel, true);\n-    }\n-    this->collect_nodes(out_rel, -2, false, false);\n-}\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":28,"deletions":43,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -112,1 +112,0 @@\n-  virtual void related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const;\n@@ -131,1 +130,1 @@\n-  virtual void dump_req(outputStream *st = tty) const;\n+  virtual void dump_req(outputStream *st = tty, DumpConfig* dc = nullptr) const;\n@@ -152,1 +151,1 @@\n-  virtual void dump_req(outputStream *st = tty) const;\n+  virtual void dump_req(outputStream *st = tty, DumpConfig* dc = nullptr) const;\n@@ -502,1 +501,0 @@\n-  virtual void           related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const;\n@@ -659,1 +657,1 @@\n-  virtual void        dump_req(outputStream* st = tty) const;\n+  virtual void        dump_req(outputStream *st = tty, DumpConfig* dc = nullptr) const;\n@@ -1118,1 +1116,0 @@\n-  virtual void related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const;\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2576,8 +2576,0 @@\n-void PhiNode::related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const {\n-  \/\/ For a PhiNode, the set of related nodes includes all inputs till level 2,\n-  \/\/ and all outputs till level 1. In compact mode, inputs till level 1 are\n-  \/\/ collected.\n-  this->collect_nodes(in_rel, compact ? 1 : 2, false, false);\n-  this->collect_nodes(out_rel, -1, false, false);\n-}\n-\n@@ -2608,11 +2600,0 @@\n-#ifndef PRODUCT\n-\/\/-----------------------------related-----------------------------------------\n-\/\/ The related nodes of a GotoNode are all inputs at level 1, as well as the\n-\/\/ outputs at level 1. This is regardless of compact mode.\n-void GotoNode::related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const {\n-  this->collect_nodes(in_rel, 1, false, false);\n-  this->collect_nodes(out_rel, -1, false, false);\n-}\n-#endif\n-\n-\n@@ -2624,11 +2605,0 @@\n-#ifndef PRODUCT\n-\/\/-----------------------------related-----------------------------------------\n-\/\/ The related nodes of a JumpNode are all inputs at level 1, as well as the\n-\/\/ outputs at level 2 (to include actual jump targets beyond projection nodes).\n-\/\/ This is regardless of compact mode.\n-void JumpNode::related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const {\n-  this->collect_nodes(in_rel, 1, false, false);\n-  this->collect_nodes(out_rel, -2, false, false);\n-}\n-#endif\n-\n@@ -2695,6 +2665,0 @@\n-\n-void JumpProjNode::related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const {\n-  \/\/ The related nodes of a JumpProjNode are its inputs and outputs at level 1.\n-  this->collect_nodes(in_rel, 1, false, false);\n-  this->collect_nodes(out_rel, -1, false, false);\n-}\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":0,"deletions":36,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -227,1 +227,0 @@\n-  virtual void related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const;\n@@ -253,4 +252,0 @@\n-\n-#ifndef PRODUCT\n-  virtual void related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const;\n-#endif\n@@ -409,1 +404,0 @@\n-  virtual void related(GrowableArray <Node *> *in_rel, GrowableArray <Node *> *out_rel, bool compact) const;\n@@ -435,5 +429,0 @@\n-\n-#ifndef PRODUCT\n-public:\n-  virtual void related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const;\n-#endif\n@@ -507,3 +496,0 @@\n-#ifndef PRODUCT\n-  virtual void related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const;\n-#endif\n@@ -535,1 +521,0 @@\n-  virtual void related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const;\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1741,15 +1741,0 @@\n-\/\/-------------------------------related---------------------------------------\n-\/\/ An IfProjNode's related node set consists of its input (an IfNode) including\n-\/\/ the IfNode's condition, plus all of its outputs at level 1. In compact mode,\n-\/\/ the restrictions for IfNode apply (see IfNode::rel).\n-void IfProjNode::related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const {\n-  Node* ifNode = this->in(0);\n-  in_rel->append(ifNode);\n-  if (compact) {\n-    ifNode->collect_nodes(in_rel, 3, false, true);\n-  } else {\n-    ifNode->collect_nodes_in_all_data(in_rel, false);\n-  }\n-  this->collect_nodes(out_rel, -1, false, false);\n-}\n-\n@@ -1760,15 +1745,0 @@\n-\n-\/\/-------------------------------related---------------------------------------\n-\/\/ For an IfNode, the set of related output nodes is just the output nodes till\n-\/\/ depth 2, i.e, the IfTrue\/IfFalse projection nodes plus the nodes they refer.\n-\/\/ The related input nodes contain no control nodes, but all data nodes\n-\/\/ pertaining to the condition. In compact mode, the input nodes are collected\n-\/\/ up to a depth of 3.\n-void IfNode::related(GrowableArray <Node *> *in_rel, GrowableArray <Node *> *out_rel, bool compact) const {\n-  if (compact) {\n-    this->collect_nodes(in_rel, 3, false, true);\n-  } else {\n-    this->collect_nodes_in_all_data(in_rel, false);\n-  }\n-  this->collect_nodes(out_rel, -2, false, false);\n-}\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":0,"deletions":30,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -465,15 +465,0 @@\n-\n-#ifndef PRODUCT\n-\/\/----------------------------BinaryNode---------------------------------------\n-\/\/ The set of related nodes for a BinaryNode is all data inputs and all outputs\n-\/\/ till level 2 (i.e., one beyond the associated CMoveNode). In compact mode,\n-\/\/ it's the inputs till level 1 and the outputs till level 2.\n-void BinaryNode::related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const {\n-  if (compact) {\n-    this->collect_nodes(in_rel, 1, false, true);\n-  } else {\n-    this->collect_nodes_in_all_data(in_rel, false);\n-  }\n-  this->collect_nodes(out_rel, -2, false, false);\n-}\n-#endif\n","filename":"src\/hotspot\/share\/opto\/movenode.cpp","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -163,4 +163,0 @@\n-\n-#ifndef PRODUCT\n-  virtual void related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const;\n-#endif\n","filename":"src\/hotspot\/share\/opto\/movenode.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1699,0 +1699,517 @@\n+class PrintBFS {\n+public:\n+  PrintBFS(Node* start, const int max_distance, Node* target, char const* options)\n+  : _start(start), _max_distance(max_distance), _target(target), _options(options),\n+    _dcc(this), _info_uid((CmpKey)&cmp, hashkey) {\n+  };\n+  void run();\n+private:\n+  \/\/ pipeline steps\n+  bool configure();\n+  void collect();\n+  void prune();\n+  void sort();\n+  void print();\n+\n+  \/\/ inputs\n+  Node* _start;\n+  const int _max_distance;\n+  Node* _target;\n+  char const* _options;\n+\n+  \/\/ options\n+  bool _traverse_inputs = false;\n+  bool _traverse_outputs = false;\n+  struct Filter {\n+    bool control = false;\n+    bool memory = false;\n+    bool data = false;\n+    bool mixed = false;\n+    bool other = false;\n+  };\n+  Filter filter_visit;\n+  Filter filter_boundary;\n+  bool _use_color = false;\n+  bool _print_blocks = false;\n+  bool _print_old = false;\n+  void parse_options_helper(bool &variable, const char* character);\n+  void parse_options();\n+\n+  \/\/ node category (filter \/ color)\n+  bool filter_category(Node* n, Filter& filter); \/\/ filter node category agains options\n+public:\n+  class DumpConfigColored : public Node::DumpConfig {\n+  public:\n+    DumpConfigColored(PrintBFS* bfs) : _bfs(bfs) {};\n+    virtual void pre_dump(outputStream *st, const Node* n);\n+    virtual void post_dump(outputStream *st);\n+  private:\n+    PrintBFS* _bfs;\n+  };\n+private:\n+  DumpConfigColored _dcc;\n+\n+  \/\/ node info\n+  Node* old_node (Node* n); \/\/ mach node -> prior IR node\n+  void print_node_idx (Node* n); \/\/ to tty\n+  void print_node_block (Node* n); \/\/ to tty: head idx, _idom, _dom_depth\n+\n+  \/\/ traversal data structures\n+  Node_List _worklist; \/\/ BFS queue\n+  void maybe_traverse(Node* src, Node* dst);\n+\n+  \/\/ node info annotation\n+  class Info {\n+  public:\n+    Info() : Info(nullptr, 0) {};\n+    Info(Node* node, int distance)\n+      : _node(node), _distance(distance) {};\n+    Node* node() { return _node; };\n+    int distance() { return _distance; };\n+    Node_List edge_fwd; \/\/ pointing away from _start\n+    Node_List edge_bwd; \/\/ pointing toward _start\n+    bool is_marked() { return _mark; } \/\/ marked to keep during pruning\n+    void set_mark() { _mark = true; }\n+  private:\n+    Node* _node;\n+    int _distance;\n+    bool _mark = false;\n+  };\n+  static int cmp(const Node* n1, const Node* n2) { return n1 != n2; }\n+  Dict _info_uid;             \/\/ Node -> uid\n+  GrowableArray <Info> _info; \/\/ uid  -> info\n+  Info* find_info(const Node* n) {\n+    size_t uid = (size_t)_info_uid[n];\n+    if (uid == 0) {\n+      return nullptr;\n+    }\n+    return &_info.at(uid);\n+  };\n+  void make_info(Node* node, int distance) {\n+    assert(find_info(node) == nullptr, \"node does not yet have info\");\n+    size_t uid = _info.length()+1;\n+    _info_uid.Insert(node, (void*)uid);\n+    _info.at_put_grow(uid, Info(node, distance));\n+    assert(find_info(node)->node() == node, \"stored correct node\");\n+  };\n+\n+  \/\/ filled by sort, printed by print\n+  Node_List _printlist;\n+\n+  \/\/ print header + node table\n+  void print_header();\n+  void print_node(Node* n);\n+};\n+\n+void PrintBFS::run() {\n+  if (!configure()) {\n+    return;\n+  }\n+  collect();\n+  prune();\n+  sort();\n+  print();\n+}\n+\n+\/\/ set up configuration for BFS and print\n+bool PrintBFS::configure() {\n+  if(_max_distance < 0) {\n+    tty->print(\"print_bfs: max_distance must be non-negative!\\n\");\n+    return false;\n+  }\n+  parse_options();\n+\n+  if (_target == nullptr) {\n+    tty->print(\"No target: perform BFS.\\n\");\n+  } else {\n+    tty->print(\"Find shortest path:\");\n+    print_node_idx(_start);\n+    tty->print(\" ->\");\n+    print_node_idx(_target);\n+    tty->print(\"\\n\");\n+  }\n+  return true;\n+}\n+\n+\/\/ BFS traverse according to configuration, fill worklist and info\n+void PrintBFS::collect() {\n+  maybe_traverse(_start, _start);\n+  uint pos = 0;\n+  while (pos < _worklist.size()) {\n+    Node* n = _worklist.at(pos++); \/\/ next node to traverse\n+    Info* info = find_info(n);\n+    if (!filter_category(n, filter_visit) && n != _start) {\n+      continue; \/\/ we hit boundary, do not traverse further\n+    }\n+    if (n != _start && (n->is_Root() || n->is_Con())) {\n+      continue; \/\/ traversing through root \/ const node would lead to unrelated nodes\n+    }\n+    if (_traverse_inputs && _max_distance > info->distance()) {\n+      for (uint i = 0; i < n->req(); i++) {\n+        maybe_traverse(n, n->in(i));\n+      }\n+    }\n+    if (_traverse_outputs && _max_distance > info->distance()) {\n+      for (uint i = 0; i < n->outcnt(); i++) {\n+        maybe_traverse(n, n->raw_out(i));\n+      }\n+    }\n+  }\n+}\n+\n+\/\/ go through work list, mark those that we want to print\n+void PrintBFS::prune() {\n+  if ( _target == nullptr ) {\n+    \/\/ take all nodes from BFS\n+    for (uint i = 0; i < _worklist.size(); i++) {\n+      Node* n = _worklist.at(i);\n+      Info* info = find_info(n);\n+      info->set_mark();\n+    }\n+  } else {\n+    \/\/ backtrack shortest path\n+    if (find_info(_target) == nullptr) {\n+      tty->print(\"Could not find target in BFS.\\n\");\n+      return;\n+    }\n+    Node* current = _target;\n+    while (true) {\n+      Info* info = find_info(current);\n+      info->set_mark();\n+      if (current == _start) {\n+        break;\n+      }\n+      \/\/ first edge -> leads us one step closer to _start\n+      current = info->edge_bwd.at(0);\n+    }\n+  }\n+}\n+\n+\/\/ go through worklist in desired order, put the marked ones in printlist\n+void PrintBFS::sort() {\n+  if(_traverse_inputs && !_traverse_outputs) {\n+    \/\/ reverse order\n+    for (int i = _worklist.size()-1; i >= 0; i--) {\n+      Node* n = _worklist.at(i);\n+      Info* info = find_info(n);\n+      if (info->is_marked()) {\n+        _printlist.push(n);\n+      }\n+    }\n+  } else {\n+    \/\/ same order as worklist\n+    for (uint i = 0; i < _worklist.size(); i++) {\n+      Node* n = _worklist.at(i);\n+      Info* info = find_info(n);\n+      if (info->is_marked()) {\n+        _printlist.push(n);\n+      }\n+    }\n+  }\n+}\n+\n+\/\/ go through printlist and print\n+void PrintBFS::print() {\n+  if( _printlist.size() > 0 ) {\n+    print_header();\n+    for (uint i = 0; i < _printlist.size(); i++) {\n+      Node* n = _printlist.at(i);\n+      print_node(n);\n+    }\n+  } else {\n+    tty->print(\"No nodes to print.\\n\");\n+  }\n+}\n+\n+void PrintBFS::parse_options_helper(bool &variable, const char* character) {\n+  if (strstr(_options, character) != nullptr) {\n+    variable = true;\n+  }\n+}\n+\n+void PrintBFS::parse_options() {\n+  if (_options == nullptr) {\n+    _options = \"cmdxo+-@B\"; \/\/ default options\n+  }\n+  parse_options_helper(_traverse_inputs,        \"+\");\n+  parse_options_helper(_traverse_outputs,       \"-\");\n+  parse_options_helper(filter_visit.control,    \"c\");\n+  parse_options_helper(filter_visit.memory,     \"m\");\n+  parse_options_helper(filter_visit.data,       \"d\");\n+  parse_options_helper(filter_visit.mixed,      \"x\");\n+  parse_options_helper(filter_visit.other,      \"o\");\n+  parse_options_helper(filter_boundary.control, \"C\");\n+  parse_options_helper(filter_boundary.memory,  \"M\");\n+  parse_options_helper(filter_boundary.data,    \"D\");\n+  parse_options_helper(filter_boundary.mixed,   \"X\");\n+  parse_options_helper(filter_boundary.other,   \"O\");\n+  parse_options_helper(_use_color,              \"#\");\n+  parse_options_helper(_print_blocks,           \"B\");\n+  parse_options_helper(_print_old,              \"@\");\n+  Compile* C = Compile::current();\n+  _print_old &= (C->matcher() != nullptr); \/\/ only show old if there are new\n+  _print_blocks &= (C->cfg() != nullptr); \/\/ only show blocks if available\n+}\n+\n+bool PrintBFS::filter_category(Node* n, Filter& filter) {\n+  const Type *t = n->bottom_type();\n+  switch (t->category()) {\n+    case Type::Category::Data:\n+      return filter.data;\n+    case Type::Category::Memory:\n+      return filter.memory;\n+    case Type::Category::Mixed:\n+      return filter.mixed;\n+    case Type::Category::Control:\n+      return filter.control;\n+    case Type::Category::Other:\n+      return filter.other;\n+    case Type::Category::Undef:\n+      n->dump();\n+      assert(false, \"category undef ??\");\n+    default:\n+      n->dump();\n+      assert(false, \"not covered\");\n+  }\n+  return false;\n+}\n+\n+void PrintBFS::DumpConfigColored::pre_dump(outputStream *st, const Node* n) {\n+  if(!_bfs->_use_color) {\n+    return;\n+  }\n+  Info* info = _bfs->find_info(n);\n+  if (info == nullptr || !info->is_marked()) {\n+    return;\n+  }\n+\n+  const Type *t = n->bottom_type();\n+  switch (t->category()) {\n+    case Type::Category::Data:\n+      st->print(\"\\u001b[34m\");\n+      break;\n+    case Type::Category::Memory:\n+      st->print(\"\\u001b[32m\");\n+      break;\n+    case Type::Category::Mixed:\n+      st->print(\"\\u001b[35m\");\n+      break;\n+    case Type::Category::Control:\n+      st->print(\"\\u001b[31m\");\n+      break;\n+    case Type::Category::Other:\n+      st->print(\"\\u001b[33m\");\n+      break;\n+    case Type::Category::Undef:\n+      n->dump();\n+      assert(false, \"category undef ??\");\n+      break;\n+    default:\n+      n->dump();\n+      assert(false, \"not covered\");\n+      break;\n+  }\n+}\n+\n+void PrintBFS::DumpConfigColored::post_dump(outputStream *st) {\n+  if(!_bfs->_use_color) {\n+    return;\n+  }\n+  st->print(\"\\u001b[0m\"); \/\/ white\n+}\n+\n+Node* PrintBFS::old_node (Node* n) {\n+  Compile* C = Compile::current();\n+  if (C->matcher() == nullptr || !C->node_arena()->contains(n)) {\n+    return (Node*)nullptr;\n+  } else {\n+    return C->matcher()->find_old_node(n);\n+  }\n+}\n+\n+void PrintBFS::print_node_idx (Node* n) {\n+  Compile* C = Compile::current();\n+  char buf[30];\n+  if (n == nullptr) {\n+    sprintf(buf,\"_\");           \/\/ null\n+  } else if (C->node_arena()->contains(n)) {\n+    sprintf(buf, \"%d\", n->_idx);  \/\/ new node\n+  } else {\n+    sprintf(buf, \"o%d\", n->_idx); \/\/ old node\n+  }\n+  tty->print(\"%6s\", buf);\n+}\n+\n+void PrintBFS::print_node_block (Node* n) {\n+  Compile* C = Compile::current();\n+  Block* b = C->node_arena()->contains(n)\n+             ? C->cfg()->get_block_for_node(n)\n+             : nullptr; \/\/ guard against old nodes\n+  if (b == nullptr) {\n+    tty->print(\"     _\");\n+    tty->print(\"     _\");\n+    tty->print(\"   _\");\n+  } else {\n+    print_node_idx(b->head());\n+    if(b->_idom) {\n+      print_node_idx(b->_idom->head());\n+    } else {\n+      tty->print(\"     _\");\n+    }\n+    tty->print(\"%4d\", b->_dom_depth);\n+  }\n+}\n+\n+\/\/ filter, and add to worklist, add info, note traversal edges\n+void PrintBFS::maybe_traverse(Node* src, Node* dst) {\n+  if (dst != nullptr &&\n+     (filter_category(dst, filter_visit) ||\n+      filter_category(dst, filter_boundary) ||\n+      dst == _start)) { \/\/ correct category or start?\n+    if( find_info(dst) == nullptr ){\n+      \/\/ never visited - set up info\n+      _worklist.push(dst);\n+      int d = 0;\n+      if (dst != _start) {\n+        d = find_info(src)->distance()+1;\n+      }\n+      make_info(dst, d);\n+    }\n+    if (src != dst) {\n+      \/\/ traversal edges useful during pruning\n+      find_info(src)->edge_fwd.push(dst);\n+      find_info(dst)->edge_bwd.push(src);\n+    }\n+  }\n+}\n+\n+void PrintBFS::print_header() {\n+  tty->print(\"dis\");                          \/\/ distance\n+  if (_print_blocks) {\n+    tty->print(\" [head  idom  d]\");           \/\/ block\n+  }\n+  if(_print_old) {\n+    tty->print(\"   old\");                     \/\/ old node\n+  }\n+  tty->print(\" dump\\n\");                      \/\/ node dump\n+  tty->print(\"---------------------------------------------\\n\");\n+}\n+\n+void PrintBFS::print_node(Node* n) {\n+  tty->print(\"%3d\", find_info(n)->distance());\/\/ distance\n+  if (_print_blocks) {\n+    print_node_block(n);                      \/\/ block\n+  }\n+  if (_print_old) {\n+    print_node_idx(old_node(n));              \/\/ old node\n+  }\n+  tty->print(\" \");\n+  n->dump(\"\\n\", false, tty, &_dcc);           \/\/ node dump\n+}\n+\n+\/\/------------------------------print_bfs--------------------------------------\n+\/\/ Call this from debugger:\n+\/\/ BFS traversal of graph, starting at node this\/start\n+\/\/ this\/start: staring point of BFS\n+\/\/ max_distance: maximal distance from this\/start BFS visits\n+\/\/ target:\n+\/\/   if nullptr: print all nodes visited during BFS\n+\/\/   else: find shortest path from this\/start to target, via BFS and backtracking\n+\/\/ options:\n+\/\/   if nullptr: same as \"cmdxo+-@B\"\n+\/\/   else: use combination of these characters\n+\/\/     +: traverse in-edges\n+\/\/     -: traverse out-edges\n+\/\/     c: visit control nodes\n+\/\/     m: visit memory nodes\n+\/\/     d: visit data nodes\n+\/\/     x: visit mixed nodes\n+\/\/     o: visit other nodes\n+\/\/     C: boundary control nodes\n+\/\/     M: boundary memory nodes\n+\/\/     D: boundary data nodes\n+\/\/     X: boundary mixed nodes\n+\/\/     O: boundary other nodes\n+\/\/     #: display node category in color (maybe not supported in all terminals)\n+\/\/     @: print old nodes - before matching (if available)\n+\/\/     B: print scheduling blocks (if available)\n+\/\/\n+\/\/ recursively follwo edges to nodes with permitted visit types,\n+\/\/ on the boundary additionally follow nodes allowed in boundary types.\n+\/\/\n+\/\/ examples:\n+\/\/   if->print_bfs(10, 0, \"+cxo\")\n+\/\/     starting at if node, traverse inputs recursively\n+\/\/     only along control (mixed and other can also be control)\n+\/\/   phi->print_bfs(5, 0, \"-dxo\")\n+\/\/     starting at phi node, traverse outputs recursively\n+\/\/     only along data (mixed and other can also have data flow)\n+\/\/   x->print_bfs(10, y, 0)\n+\/\/     find shortest path from x to y, along any edge or node\n+\/\/     will not find a path if it is longer than 10\n+\/\/     useful to find how x and y are related\n+\/\/   find_node(385)->print_bfs(3, 0, \"cdmox+#OB\")\n+\/\/     find inputs of node 385, up to 3 nodes up (+)\n+\/\/     traverse all nodes (cdmox), use colors (#)\n+\/\/     display old nodes and blocks, if they exist\n+\/\/     useful call to start with\n+\/\/\n+\/\/ output columns:\n+\/\/   distance: distance to this\/start in BFS traversal\n+\/\/   block:    block in which the node has been scheduled [head(), _idom->head(), _dom_depth]\n+\/\/   old:      old IR node - before matching\n+\/\/   category: characters cmdxo from options string\n+\/\/   dump\n+void Node::print_bfs(const int max_distance, Node* target, char const* options) {\n+  PrintBFS bfs(this, max_distance, target, options);\n+  bfs.run();\n+}\n+\n+\/\/ log10 rounded down\n+uint log10(const uint i) {\n+  uint v = 10;\n+  uint e = 0;\n+  while(v <= i) {\n+    v *= 10;\n+    e++;\n+  }\n+  return e;\n+}\n+\n+\/\/ -----------------------------dump_idx---------------------------------------\n+void Node::dump_idx(bool align, outputStream *st, DumpConfig* dc) const {\n+  if (dc != nullptr) {\n+    dc->pre_dump(st, this);\n+  }\n+  Compile* C = Compile::current();\n+  bool is_new = C->node_arena()->contains(this);\n+  if(align) { \/\/ print prefix empty spaces$\n+    \/\/ +1 for leading digit, +1 for \"o\"\n+    uint max_width = log10(C->unique()) + 2;\n+    \/\/ +1 for leading digit, maybe +1 for \"o\"\n+    uint width = log10(_idx) + 1 + (is_new ? 0 : 1);\n+    while(max_width > width) {\n+      st->print(\" \");\n+      width++;\n+    }\n+  }\n+  if(!is_new) {\n+    st->print(\"o\");\n+  }\n+  st->print(\"%d\", _idx);\n+  if (dc != nullptr) {\n+    dc->post_dump(st);\n+  }\n+}\n+\n+\/\/ -----------------------------dump_name--------------------------------------\n+void Node::dump_name(outputStream *st, DumpConfig* dc) const {\n+  if (dc != nullptr) {\n+    dc->pre_dump(st, this);\n+  }\n+  st->print(\"%s\", Name());\n+  if (dc != nullptr) {\n+    dc->post_dump(st);\n+  }\n+}\n+\n@@ -1769,1 +2286,1 @@\n-void Node::dump(const char* suffix, bool mark, outputStream *st) const {\n+void Node::dump(const char* suffix, bool mark, outputStream *st, DumpConfig* dc) const {\n@@ -1774,1 +2291,1 @@\n-  if (_indent > 0) {\n+  if (_indent > 0) {\/\/ TODO: remove?\n@@ -1778,1 +2295,5 @@\n-  st->print(\"%c%d%s%s  === \", is_new ? ' ' : 'o', _idx, mark ? \" >\" : \"  \", Name());\n+  \/\/ idx mark name ===\n+  dump_idx(true, st, dc);\n+  st->print(mark ? \" >\" : \"  \");\n+  dump_name(st, dc);\n+  st->print(\"  === \");\n@@ -1781,2 +2302,2 @@\n-  dump_req(st);\n-  dump_prec(st);\n+  dump_req(st, dc);\n+  dump_prec(st, dc);\n@@ -1784,1 +2305,1 @@\n-  dump_out(st);\n+  dump_out(st, dc);\n@@ -1851,1 +2372,1 @@\n-void Node::dump_req(outputStream *st) const {\n+void Node::dump_req(outputStream *st, DumpConfig* dc) const {\n@@ -1860,1 +2381,2 @@\n-      st->print(\"%c%d \", Compile::current()->node_arena()->contains(d) ? ' ' : 'o', d->_idx);\n+      d->dump_idx(false, st, dc);\n+      st->print(\" \");\n@@ -1867,1 +2389,1 @@\n-void Node::dump_prec(outputStream *st) const {\n+void Node::dump_prec(outputStream *st, DumpConfig* dc) const {\n@@ -1875,1 +2397,2 @@\n-      st->print(\"%c%d \", Compile::current()->node_arena()->contains(in(i)) ? ' ' : 'o', in(i)->_idx);\n+      p->dump_idx(false, st, dc);\n+      st->print(\" \");\n@@ -1881,1 +2404,1 @@\n-void Node::dump_out(outputStream *st) const {\n+void Node::dump_out(outputStream *st, DumpConfig* dc) const {\n@@ -1883,1 +2406,1 @@\n-  st->print(\" [[\");\n+  st->print(\" [[ \");\n@@ -1892,1 +2415,2 @@\n-      st->print(\"%c%d \", Compile::current()->node_arena()->contains(u) ? ' ' : 'o', u->_idx);\n+      u->dump_idx(false, st, dc);\n+      st->print(\" \");\n@@ -1996,82 +2520,0 @@\n-\/\/----------------------------dump_related-------------------------------------\n-\/\/ Dump a Node's related nodes - the notion of \"related\" depends on the Node at\n-\/\/ hand and is determined by the implementation of the virtual method rel.\n-void Node::dump_related() const {\n-  Compile* C = Compile::current();\n-  GrowableArray <Node *> in_rel(C->unique());\n-  GrowableArray <Node *> out_rel(C->unique());\n-  this->related(&in_rel, &out_rel, false);\n-  for (int i = in_rel.length() - 1; i >= 0; i--) {\n-    in_rel.at(i)->dump();\n-  }\n-  this->dump(\"\\n\", true);\n-  for (int i = 0; i < out_rel.length(); i++) {\n-    out_rel.at(i)->dump();\n-  }\n-}\n-\n-\/\/----------------------------dump_related-------------------------------------\n-\/\/ Dump a Node's related nodes up to a given depth (distance from the start\n-\/\/ node).\n-\/\/ Arguments:\n-\/\/   d_in:  depth for input nodes.\n-\/\/   d_out: depth for output nodes (note: this also is a positive number).\n-void Node::dump_related(uint d_in, uint d_out) const {\n-  Compile* C = Compile::current();\n-  GrowableArray <Node *> in_rel(C->unique());\n-  GrowableArray <Node *> out_rel(C->unique());\n-\n-  \/\/ call collect_nodes_i directly\n-  collect_nodes_i(&in_rel, this, 1, d_in, false, false, false);\n-  collect_nodes_i(&out_rel, this, -1, d_out, false, false, false);\n-\n-  for (int i = in_rel.length() - 1; i >= 0; i--) {\n-    in_rel.at(i)->dump();\n-  }\n-  this->dump(\"\\n\", true);\n-  for (int i = 0; i < out_rel.length(); i++) {\n-    out_rel.at(i)->dump();\n-  }\n-}\n-\n-\/\/------------------------dump_related_compact---------------------------------\n-\/\/ Dump a Node's related nodes in compact representation. The notion of\n-\/\/ \"related\" depends on the Node at hand and is determined by the implementation\n-\/\/ of the virtual method rel.\n-void Node::dump_related_compact() const {\n-  Compile* C = Compile::current();\n-  GrowableArray <Node *> in_rel(C->unique());\n-  GrowableArray <Node *> out_rel(C->unique());\n-  this->related(&in_rel, &out_rel, true);\n-  int n_in = in_rel.length();\n-  int n_out = out_rel.length();\n-\n-  this->dump_comp(n_in == 0 ? \"\\n\" : \"  \");\n-  for (int i = 0; i < n_in; i++) {\n-    in_rel.at(i)->dump_comp(i == n_in - 1 ? \"\\n\" : \"  \");\n-  }\n-  for (int i = 0; i < n_out; i++) {\n-    out_rel.at(i)->dump_comp(i == n_out - 1 ? \"\\n\" : \"  \");\n-  }\n-}\n-\n-\/\/------------------------------related----------------------------------------\n-\/\/ Collect a Node's related nodes. The default behaviour just collects the\n-\/\/ inputs and outputs at depth 1, including both control and data flow edges,\n-\/\/ regardless of whether the presentation is compact or not. For data nodes,\n-\/\/ the default is to collect all data inputs (till level 1 if compact), and\n-\/\/ outputs till level 1.\n-void Node::related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const {\n-  if (this->is_CFG()) {\n-    collect_nodes_i(in_rel, this, 1, 1, false, false, false);\n-    collect_nodes_i(out_rel, this, -1, 1, false, false, false);\n-  } else {\n-    if (compact) {\n-      this->collect_nodes(in_rel, 1, false, true);\n-    } else {\n-      this->collect_nodes_in_all_data(in_rel, false);\n-    }\n-    this->collect_nodes(out_rel, -1, false, false);\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":538,"deletions":96,"binary":false,"changes":634,"status":"modified"},{"patch":"@@ -1183,1 +1183,2 @@\n-  int _indent;\n+  int _indent; \/\/ TODO remove?\n+  \/\/TODO: clean up public \/ private, add more comments about what is for debugger\n@@ -1193,0 +1194,9 @@\n+  void print_bfs(const int max_distance, Node* target, char const* options); \/\/ Print BFS traversal\n+  class DumpConfig {\n+  public:\n+    \/\/ overridden to implement coloring of node idx\n+    virtual void pre_dump(outputStream *st, const Node* n) = 0;\n+    virtual void post_dump(outputStream *st) = 0;\n+  };\n+  void dump_idx(bool align = false, outputStream *st = tty, DumpConfig* dc = nullptr) const;\n+  void dump_name(outputStream *st = tty, DumpConfig* dc = nullptr) const;\n@@ -1194,1 +1204,1 @@\n-  void dump(const char* suffix, bool mark = false, outputStream *st = tty) const; \/\/ Print this node.\n+  void dump(const char* suffix, bool mark = false, outputStream *st = tty, DumpConfig* dc = nullptr) const; \/\/ Print this node.\n@@ -1200,3 +1210,3 @@\n-  virtual void dump_req(outputStream *st = tty) const;    \/\/ Print required-edge info\n-  virtual void dump_prec(outputStream *st = tty) const;   \/\/ Print precedence-edge info\n-  virtual void dump_out(outputStream *st = tty) const;    \/\/ Print the output edge info\n+  virtual void dump_req(outputStream *st = tty, DumpConfig* dc = nullptr) const;    \/\/ Print required-edge info\n+  virtual void dump_prec(outputStream *st = tty, DumpConfig* dc = nullptr) const;   \/\/ Print precedence-edge info\n+  virtual void dump_out(outputStream *st = tty, DumpConfig* dc = nullptr) const;    \/\/ Print the output edge info\n@@ -1206,6 +1216,0 @@\n-  void dump_related() const;             \/\/ Print related nodes (depends on node at hand).\n-  \/\/ Print related nodes up to given depths for input and output nodes.\n-  void dump_related(uint d_in, uint d_out) const;\n-  void dump_related_compact() const;     \/\/ Print related nodes in compact representation.\n-  \/\/ Collect related nodes.\n-  virtual void related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const;\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":15,"deletions":11,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -94,15 +94,0 @@\n-\n-#ifndef PRODUCT\n-\/\/-----------------------------related-----------------------------------------\n-\/\/ Include all control inputs in the related set, and also the input data\n-\/\/ boundary. In compact mode, include all inputs till level 2. Also include\n-\/\/ all outputs at level 1.\n-void HaltNode::related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const {\n-  if (compact) {\n-    this->collect_nodes(in_rel, 2, false, false);\n-  } else {\n-    this->collect_nodes_in_all_ctrl(in_rel, true);\n-  }\n-  this->collect_nodes(out_rel, -1, false, false);\n-}\n-#endif\n","filename":"src\/hotspot\/share\/opto\/rootnode.cpp","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -71,4 +71,0 @@\n-\n-#ifndef PRODUCT\n-  virtual void related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const;\n-#endif\n","filename":"src\/hotspot\/share\/opto\/rootnode.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -631,32 +631,0 @@\n-#ifndef PRODUCT\n-\/\/----------------------------related------------------------------------------\n-\/\/ Related nodes of comparison nodes include all data inputs (until hitting a\n-\/\/ control boundary) as well as all outputs until and including control nodes\n-\/\/ as well as their projections. In compact mode, data inputs till depth 1 and\n-\/\/ all outputs till depth 1 are considered.\n-void CmpNode::related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const {\n-  if (compact) {\n-    this->collect_nodes(in_rel, 1, false, true);\n-    this->collect_nodes(out_rel, -1, false, false);\n-  } else {\n-    this->collect_nodes_in_all_data(in_rel, false);\n-    this->collect_nodes_out_all_ctrl_boundary(out_rel);\n-    \/\/ Now, find all control nodes in out_rel, and include their projections\n-    \/\/ and projection targets (if any) in the result.\n-    GrowableArray<Node*> proj(Compile::current()->unique());\n-    for (GrowableArrayIterator<Node*> it = out_rel->begin(); it != out_rel->end(); ++it) {\n-      Node* n = *it;\n-      if (n->is_CFG() && !n->is_Proj()) {\n-        \/\/ Assume projections and projection targets are found at levels 1 and 2.\n-        n->collect_nodes(&proj, -2, false, false);\n-        for (GrowableArrayIterator<Node*> p = proj.begin(); p != proj.end(); ++p) {\n-          out_rel->append_if_missing(*p);\n-        }\n-        proj.clear();\n-      }\n-    }\n-  }\n-}\n-\n-#endif\n-\n@@ -1793,14 +1761,0 @@\n-\n-\/\/-------------------------------related---------------------------------------\n-\/\/ A BoolNode's related nodes are all of its data inputs, and all of its\n-\/\/ outputs until control nodes are hit, which are included. In compact\n-\/\/ representation, inputs till level 3 and immediate outputs are included.\n-void BoolNode::related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const {\n-  if (compact) {\n-    this->collect_nodes(in_rel, 3, false, true);\n-    this->collect_nodes(out_rel, -1, false, false);\n-  } else {\n-    this->collect_nodes_in_all_data(in_rel, false);\n-    this->collect_nodes_out_all_ctrl_boundary(out_rel);\n-  }\n-}\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":0,"deletions":46,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -146,7 +146,0 @@\n-\n-#ifndef PRODUCT\n-  \/\/ CmpNode and subclasses include all data inputs (until hitting a control\n-  \/\/ boundary) in their related node set, as well as all outputs until and\n-  \/\/ including eventual control nodes and their projections.\n-  virtual void related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const;\n-#endif\n@@ -340,1 +333,0 @@\n-  virtual void related(GrowableArray<Node*> *in_rel, GrowableArray<Node*> *out_rel, bool compact) const;\n","filename":"src\/hotspot\/share\/opto\/subnode.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"}]}