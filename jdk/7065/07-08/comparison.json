{"files":[{"patch":"@@ -150,1 +150,1 @@\n-     * If enabled (for a particular destination) then SPNEGO authentication requests will include\n+     * If enabled (for a particular destination) then Negotiate\/SPNEGO authentication requests will include\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/http\/HttpClient.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,311 @@\n+\/*\r\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\r\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\r\n+ *\r\n+ * This code is free software; you can redistribute it and\/or modify it\r\n+ * under the terms of the GNU General Public License version 2 only, as\r\n+ * published by the Free Software Foundation.\r\n+ *\r\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\r\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\r\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\r\n+ * version 2 for more details (a copy is included in the LICENSE file that\r\n+ * accompanied this code).\r\n+ *\r\n+ * You should have received a copy of the GNU General Public License version\r\n+ * 2 along with this work; if not, write to the Free Software Foundation,\r\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\r\n+ *\r\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\r\n+ * or visit www.oracle.com if you need additional information or have any\r\n+ * questions.\r\n+ *\/\r\n+\r\n+\/*\r\n+ * @test\r\n+ * @bug 8279842\r\n+ * @modules java.base\/sun.security.util\r\n+ *          java.security.jgss\/sun.security.jgss\r\n+ *          java.security.jgss\/sun.security.jgss.krb5\r\n+ *          java.security.jgss\/sun.security.jgss.krb5.internal\r\n+ *          java.security.jgss\/sun.security.krb5.internal:+open\r\n+ *          java.security.jgss\/sun.security.krb5:+open\r\n+ *          java.security.jgss\/sun.security.krb5.internal.ccache\r\n+ *          java.security.jgss\/sun.security.krb5.internal.crypto\r\n+ *          java.security.jgss\/sun.security.krb5.internal.ktab\r\n+ *          jdk.security.auth\r\n+ *          jdk.security.jgss\r\n+ *          jdk.httpserver\r\n+ * @summary HTTPS Channel Binding support for Java GSS\/Kerberos\r\n+ * @library \/test\/lib\r\n+ * @run main jdk.test.lib.FileInstaller TestHosts TestHosts\r\n+ * @run main\/othervm -Djdk.net.hosts.file=TestHosts\r\n+ *          -Djdk.https.negotiate.cbt=always HttpsCB true true\r\n+ * @run main\/othervm -Djdk.net.hosts.file=TestHosts\r\n+ *          -Djdk.https.negotiate.cbt=never HttpsCB false true\r\n+ * @run main\/othervm -Djdk.net.hosts.file=TestHosts\r\n+ *          -Djdk.https.negotiate.cbt=invalid HttpsCB false true\r\n+ * @run main\/othervm -Djdk.net.hosts.file=TestHosts\r\n+ *          HttpsCB false true\r\n+ * @run main\/othervm -Djdk.net.hosts.file=TestHosts\r\n+ *          -Djdk.https.negotiate.cbt=domain:other.com HttpsCB false true\r\n+ * @run main\/othervm -Djdk.net.hosts.file=TestHosts\r\n+ *          -Djdk.https.negotiate.cbt=domain:host.web.domain HttpsCB true true\r\n+ * @run main\/othervm -Djdk.net.hosts.file=TestHosts\r\n+ *          -Djdk.https.negotiate.cbt=domain:*.web.domain HttpsCB true true\r\n+ *\/\r\n+\r\n+import com.sun.net.httpserver.Headers;\r\n+import com.sun.net.httpserver.HttpExchange;\r\n+import com.sun.net.httpserver.HttpHandler;\r\n+import com.sun.net.httpserver.HttpServer;\r\n+import com.sun.net.httpserver.HttpPrincipal;\r\n+import com.sun.net.httpserver.HttpsConfigurator;\r\n+import com.sun.net.httpserver.HttpsExchange;\r\n+import com.sun.net.httpserver.HttpsServer;\r\n+import com.sun.security.auth.module.Krb5LoginModule;\r\n+import java.io.BufferedReader;\r\n+import java.io.File;\r\n+import java.io.FileOutputStream;\r\n+import java.io.IOException;\r\n+import java.io.InputStreamReader;\r\n+import java.net.HttpURLConnection;\r\n+import java.net.InetSocketAddress;\r\n+import java.net.PasswordAuthentication;\r\n+import java.net.Proxy;\r\n+import java.net.Socket;\r\n+import java.net.URL;\r\n+import java.security.cert.X509Certificate;\r\n+import java.util.HashMap;\r\n+import java.util.Map;\r\n+import javax.net.ssl.HttpsURLConnection;\r\n+import javax.net.ssl.SSLContext;\r\n+import javax.net.ssl.SSLEngine;\r\n+import javax.net.ssl.TrustManager;\r\n+import javax.net.ssl.X509ExtendedTrustManager;\r\n+import javax.security.auth.Subject;\r\n+\r\n+import jdk.test.lib.Asserts;\r\n+import jdk.test.lib.net.SimpleSSLContext;\r\n+import org.ietf.jgss.GSSContext;\r\n+import org.ietf.jgss.GSSCredential;\r\n+import org.ietf.jgss.GSSManager;\r\n+import sun.security.jgss.GSSUtil;\r\n+import sun.security.jgss.krb5.internal.TlsChannelBindingImpl;\r\n+import sun.security.krb5.Config;\r\n+import sun.security.util.TlsChannelBinding;\r\n+\r\n+import java.util.Base64;\r\n+import java.util.concurrent.Callable;\r\n+\r\n+public class HttpsCB {\r\n+\r\n+    final static String REALM_WEB = \"WEB.DOMAIN\";\r\n+    final static String KRB5_CONF = \"web.conf\";\r\n+    final static String KRB5_TAB = \"web.ktab\";\r\n+\r\n+    final static String WEB_USER = \"web\";\r\n+    final static char[] WEB_PASS = \"webby\".toCharArray();\r\n+    final static String WEB_HOST = \"host.web.domain\";\r\n+    final static String CONTENT = \"Hello, World!\";\r\n+\r\n+    static int webPort;\r\n+    static URL cbtURL;\r\n+    static URL normalURL;\r\n+\r\n+    public static void main(String[] args)\r\n+            throws Exception {\r\n+\r\n+        boolean expected1 = Boolean.parseBoolean(args[0]);\r\n+        boolean expected2 = Boolean.parseBoolean(args[1]);\r\n+\r\n+        System.setProperty(\"sun.security.krb5.debug\", \"true\");\r\n+\r\n+        KDC kdcw = KDC.create(REALM_WEB);\r\n+        kdcw.addPrincipal(WEB_USER, WEB_PASS);\r\n+        kdcw.addPrincipalRandKey(\"krbtgt\/\" + REALM_WEB);\r\n+        kdcw.addPrincipalRandKey(\"HTTP\/\" + WEB_HOST);\r\n+\r\n+        KDC.saveConfig(KRB5_CONF, kdcw,\r\n+                \"default_keytab_name = \" + KRB5_TAB,\r\n+                \"[domain_realm]\",\r\n+                \"\",\r\n+                \".web.domain=\"+REALM_WEB);\r\n+\r\n+        System.setProperty(\"java.security.krb5.conf\", KRB5_CONF);\r\n+        Config.refresh();\r\n+        KDC.writeMultiKtab(KRB5_TAB, kdcw);\r\n+\r\n+        \/\/ Write a customized JAAS conf file, so that any kinit cache\r\n+        \/\/ will be ignored.\r\n+        System.setProperty(\"java.security.auth.login.config\", OneKDC.JAAS_CONF);\r\n+        File f = new File(OneKDC.JAAS_CONF);\r\n+        FileOutputStream fos = new FileOutputStream(f);\r\n+        fos.write((\r\n+                \"com.sun.security.jgss.krb5.initiate {\\n\" +\r\n+                \"    com.sun.security.auth.module.Krb5LoginModule required;\\n};\\n\"\r\n+                ).getBytes());\r\n+        fos.close();\r\n+\r\n+        HttpServer h1 = httpd(\"Negotiate\",\r\n+                \"HTTP\/\" + WEB_HOST + \"@\" + REALM_WEB, KRB5_TAB);\r\n+        webPort = h1.getAddress().getPort();\r\n+\r\n+        cbtURL = new URL(\"https:\/\/\" + WEB_HOST +\":\" + webPort + \"\/cbt\");\r\n+        normalURL = new URL(\"https:\/\/\" + WEB_HOST +\":\" + webPort + \"\/normal\");\r\n+\r\n+        java.net.Authenticator.setDefault(new java.net.Authenticator() {\r\n+            public PasswordAuthentication getPasswordAuthentication () {\r\n+                return new PasswordAuthentication(\r\n+                        WEB_USER+\"@\"+REALM_WEB, WEB_PASS);\r\n+            }\r\n+        });\r\n+\r\n+        \/\/ Client-side SSLContext needs to ignore hostname mismatch\r\n+        \/\/ and untrusted certificate.\r\n+        SSLContext sc = SSLContext.getInstance(\"SSL\");\r\n+        sc.init(null, new TrustManager[] {\r\n+                new X509ExtendedTrustManager() {\r\n+                    public X509Certificate[] getAcceptedIssuers() {\r\n+                        return null;\r\n+                    }\r\n+                    public void checkClientTrusted(X509Certificate[] chain,\r\n+                            String authType, Socket socket) { }\r\n+                    public void checkServerTrusted(X509Certificate[] chain,\r\n+                            String authType, Socket socket) { }\r\n+                    public void checkClientTrusted(X509Certificate[] chain,\r\n+                            String authType, SSLEngine engine) { }\r\n+                    public void checkServerTrusted(X509Certificate[] chain,\r\n+                            String authType, SSLEngine engine) { }\r\n+                    public void checkClientTrusted(X509Certificate[] certs,\r\n+                            String authType) { }\r\n+                    public void checkServerTrusted(X509Certificate[] certs,\r\n+                            String authType) { }\r\n+                }\r\n+        }, null);\r\n+\r\n+        Asserts.assertEQ(visit(sc, cbtURL), expected1);\r\n+        Asserts.assertEQ(visit(sc, normalURL), expected2);\r\n+    }\r\n+\r\n+    static boolean visit(SSLContext sc, URL url) {\r\n+        try {\r\n+            HttpsURLConnection conn = (HttpsURLConnection)\r\n+                    url.openConnection(Proxy.NO_PROXY);\r\n+            conn.setSSLSocketFactory(sc.getSocketFactory());\r\n+            BufferedReader reader;\r\n+            reader = new BufferedReader(new InputStreamReader(\r\n+                    conn.getInputStream()));\r\n+            return reader.readLine().equals(CONTENT);\r\n+        } catch (Exception e) {\r\n+            return false;\r\n+        }\r\n+    }\r\n+\r\n+    static HttpServer httpd(String scheme, String principal, String ktab)\r\n+            throws Exception {\r\n+        MyHttpHandler h = new MyHttpHandler();\r\n+        HttpsServer server = HttpsServer.create(new InetSocketAddress(0), 0);\r\n+        server.setHttpsConfigurator(\r\n+                new HttpsConfigurator(new SimpleSSLContext().get()));\r\n+        server.createContext(\"\/\", h).setAuthenticator(\r\n+                new MyServerAuthenticator(scheme, principal, ktab));\r\n+        server.start();\r\n+        return server;\r\n+    }\r\n+\r\n+    static class MyHttpHandler implements HttpHandler {\r\n+        public void handle(HttpExchange t) throws IOException {\r\n+            t.sendResponseHeaders(200, 0);\r\n+            t.getResponseBody().write(CONTENT.getBytes());\r\n+            t.close();\r\n+        }\r\n+    }\r\n+\r\n+    static class MyServerAuthenticator\r\n+            extends com.sun.net.httpserver.Authenticator {\r\n+        Subject s = new Subject();\r\n+        GSSManager m;\r\n+        GSSCredential cred;\r\n+        String scheme = null;\r\n+        String reqHdr = \"WWW-Authenticate\";\r\n+        String respHdr = \"Authorization\";\r\n+        int err = HttpURLConnection.HTTP_UNAUTHORIZED;\r\n+\r\n+        public MyServerAuthenticator(String scheme,\r\n+                String principal, String ktab) throws Exception {\r\n+\r\n+            this.scheme = scheme;\r\n+            Krb5LoginModule krb5 = new Krb5LoginModule();\r\n+            Map<String, String> map = new HashMap<>();\r\n+            Map<String, Object> shared = new HashMap<>();\r\n+\r\n+            map.put(\"storeKey\", \"true\");\r\n+            map.put(\"isInitiator\", \"false\");\r\n+            map.put(\"useKeyTab\", \"true\");\r\n+            map.put(\"keyTab\", ktab);\r\n+            map.put(\"principal\", principal);\r\n+            krb5.initialize(s, null, shared, map);\r\n+            krb5.login();\r\n+            krb5.commit();\r\n+            m = GSSManager.getInstance();\r\n+            cred = Subject.callAs(s, new Callable<GSSCredential>() {\r\n+                @Override\r\n+                public GSSCredential call() throws Exception {\r\n+                    System.err.println(\"Creating GSSCredential\");\r\n+                    return m.createCredential(\r\n+                            null,\r\n+                            GSSCredential.INDEFINITE_LIFETIME,\r\n+                            MyServerAuthenticator.this.scheme\r\n+                                        .equalsIgnoreCase(\"Negotiate\") ?\r\n+                                    GSSUtil.GSS_SPNEGO_MECH_OID :\r\n+                                    GSSUtil.GSS_KRB5_MECH_OID,\r\n+                            GSSCredential.ACCEPT_ONLY);\r\n+                }\r\n+            });\r\n+        }\r\n+\r\n+        @Override\r\n+        public Result authenticate(HttpExchange exch) {\r\n+            \/\/ The GSContext is stored in an HttpContext attribute named\r\n+            \/\/ \"GSSContext\" and is created at the first request.\r\n+            GSSContext c = null;\r\n+            String auth = exch.getRequestHeaders().getFirst(respHdr);\r\n+            try {\r\n+                c = (GSSContext)exch.getHttpContext()\r\n+                        .getAttributes().get(\"GSSContext\");\r\n+                if (auth == null) {                 \/\/ First request\r\n+                    Headers map = exch.getResponseHeaders();\r\n+                    map.set (reqHdr, scheme);        \/\/ Challenge!\r\n+                    c = Subject.callAs(s, () -> m.createContext(cred));\r\n+                    \/\/ CBT is required for cbtURL\r\n+                    if (exch instanceof HttpsExchange sexch\r\n+                            && exch.getRequestURI().toString().equals(\"\/cbt\")) {\r\n+                        TlsChannelBinding b = TlsChannelBinding.create(\r\n+                                (X509Certificate) sexch.getSSLSession()\r\n+                                        .getLocalCertificates()[0]);\r\n+                        c.setChannelBinding(\r\n+                                new TlsChannelBindingImpl(b.getData()));\r\n+                    }\r\n+                    exch.getHttpContext().getAttributes().put(\"GSSContext\", c);\r\n+                    return new com.sun.net.httpserver.Authenticator.Retry(err);\r\n+                } else {                            \/\/ Later requests\r\n+                    byte[] token = Base64.getMimeDecoder()\r\n+                            .decode(auth.split(\" \")[1]);\r\n+                    token = c.acceptSecContext(token, 0, token.length);\r\n+                    Headers map = exch.getResponseHeaders();\r\n+                    map.set (reqHdr, scheme + \" \" + Base64.getMimeEncoder()\r\n+                            .encodeToString(token).replaceAll(\"\\\\s\", \"\"));\r\n+                    if (c.isEstablished()) {\r\n+                        return new com.sun.net.httpserver.Authenticator.Success(\r\n+                                new HttpPrincipal(c.getSrcName().toString(), \"\"));\r\n+                    } else {\r\n+                        return new com.sun.net.httpserver.Authenticator.Retry(err);\r\n+                    }\r\n+                }\r\n+            } catch (Exception e) {\r\n+                throw new RuntimeException(e);\r\n+            }\r\n+        }\r\n+    }\r\n+}\r\n","filename":"test\/jdk\/sun\/security\/krb5\/auto\/HttpsCB.java","additions":311,"deletions":0,"binary":false,"changes":311,"status":"added"}]}