{"files":[{"patch":"@@ -217,0 +217,15 @@\n+\t<LI><P><B>{@systemProperty jdk.https.negotiate.cbt}<\/B> (default: &lt;never&gt;)<BR>\n+\tThis controls the generation and sending of TLS channel binding tokens (CBT) when Kerberos \n+        or the Negotiate authentication scheme using Kerberos are employed over HTTPS with\n+        {@code HttpsURLConnection}. There are three possible settings:<\/P>\n+        <OL>\n+          <LI><P>\"never\". This is also the default value if the property is not set. In this case,\n+              CBTs are never sent.<\/P>\n+          <LI><P>\"always\". CBTs are sent for all Kerberos authentication attempts over HTTPS.<\/P>\n+          <LI><P>\"domain:&lt;comma separated domain list&gt;\" Each domain in the list specifies destination\n+              host or hosts for which a CBT is sent. Domains can be single hosts like foo, or foo.com,\n+              or wildcards like *.foo.com which matches all hosts under foo.com and its sub-domains.\n+              CBTs are not sent to any destinations that don't match one of the list entries<\/P>\n+\t<\/OL>\n+\t<P>The channel binding tokens generated are of the type \"tls-server-end-point\" as defined in\n+           RFC 5929.<\/P>\n","filename":"src\/java.base\/share\/classes\/java\/net\/doc-files\/net-properties.html","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -147,0 +147,9 @@\n+    \/* \"jdk.https.negotiate.cbt\" property can be set to \"always\" (always sent), \"never\" (never sent) or\n+     * \"domain:a,c.d,*.e.f\" (sent to host a, or c.d or to the domain e.f and any of its subdomains). This is\n+     * a comma separated list of arbitrary length with no white-space allowed.\n+     * If enabled (for a particular destination) then SPNEGO authentication requests will include\n+     * a channel binding token for the destination server. The default behavior and setting for the\n+     * property is \"never\"\n+     *\/\n+    private static final String spnegoCBT;\n+\n@@ -148,0 +157,1 @@\n+\n@@ -153,0 +163,5 @@\n+    private static void logError(String msg) {\n+        if (logger.isLoggable(PlatformLogger.Level.SEVERE)) {\n+            logger.severe(msg);\n+        }\n+    }\n@@ -168,0 +183,12 @@\n+    static String normalizeCBT(String s) {\n+        if (s == null || s.equals(\"never\")) {\n+            return \"never\";\n+        }\n+        if (s.equals(\"always\") || s.startsWith(\"domain:\")) {\n+            return s;\n+        } else {\n+            logError(\"Unexpected value for \\\"jdk.https.negotiate.cbt\\\" system property\");\n+            return \"never\";\n+        }\n+    }\n+\n@@ -175,0 +202,3 @@\n+        String s = props.getProperty(\"jdk.https.negotiate.cbt\");\n+        spnegoCBT = normalizeCBT(s);\n+\n@@ -209,0 +239,4 @@\n+    public String getSpnegoCBT() {\n+        return spnegoCBT;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/http\/HttpClient.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.security.cert.X509Certificate;\n@@ -54,0 +55,3 @@\n+    \/\/ Used to obtain server cert for SPNEGO CBT.\n+    \/\/ May be null in which case CBT is not set\n+    public final X509Certificate serverCert;\n@@ -68,0 +72,1 @@\n+        this.serverCert =  old.serverCert;\n@@ -74,0 +79,4 @@\n+        this(url, null, a);\n+    }\n+\n+    public HttpCallerInfo(URL url, X509Certificate serverCert, Authenticator a) {\n@@ -75,0 +84,1 @@\n+        this.serverCert= serverCert;\n@@ -103,0 +113,4 @@\n+        this(url, host, port, null, a);\n+    }\n+\n+    public HttpCallerInfo(URL url, String host, int port, X509Certificate serverCert, Authenticator a) {\n@@ -106,0 +120,1 @@\n+        this.serverCert = serverCert;\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/http\/HttpCallerInfo.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1743,1 +1743,1 @@\n-                            new HttpCallerInfo(url,\n+                            getHttpCallerInfo(url,\n@@ -1818,1 +1818,1 @@\n-                            new HttpCallerInfo(url, authenticator),\n+                            getHttpCallerInfo(url, authenticator),\n@@ -2214,1 +2214,1 @@\n-                            new HttpCallerInfo(url,\n+                            getHttpCallerInfo(url,\n@@ -2283,0 +2283,15 @@\n+    \/**\n+     * Overridden in https to also include the server certificate\n+     *\/\n+    protected HttpCallerInfo getHttpCallerInfo(URL url, String proxy, int port,\n+                                               Authenticator authenticator) {\n+        return new HttpCallerInfo(url, proxy, port, authenticator);\n+    }\n+\n+    \/**\n+     * Overridden in https to also include the server certificate\n+     *\/\n+    protected HttpCallerInfo getHttpCallerInfo(URL url, Authenticator authenticator) {\n+        return new HttpCallerInfo(url, authenticator);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/http\/HttpURLConnection.java","additions":18,"deletions":3,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-\/*\n+\/**\n@@ -28,0 +28,1 @@\n+import java.net.Authenticator;\n@@ -32,0 +33,2 @@\n+import java.security.cert.Certificate;\n+import java.security.cert.X509Certificate;\n@@ -39,0 +42,1 @@\n+import sun.net.www.protocol.http.HttpCallerInfo;\n@@ -312,0 +316,67 @@\n+\n+    \/*\n+     * If no SSL Session available or if the system config does not allow it\n+     * don't use the extended caller info (the server cert).\n+     * Otherwise return true to include the server cert\n+     *\/\n+    private boolean useExtendedCallerInfo(URL url) {\n+        HttpsClient https = (HttpsClient)http;\n+        if (https.getSSLSession() == null) {\n+            return false;\n+        }\n+        String prop = http.getSpnegoCBT();\n+        if (prop.equals(\"never\")) {\n+            return false;\n+        }\n+        String target = url.getHost();\n+        if (prop.startsWith(\"domain:\")) {\n+            String[] domains = prop.substring(7).split(\",\");\n+            for (String domain : domains) {\n+                if (target.equals(domain)) {\n+                    return true;\n+                }\n+                if (domain.startsWith(\"*.\") && target.endsWith(domain.substring(1))) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    protected HttpCallerInfo getHttpCallerInfo(URL url, String proxy, int port,\n+                                               Authenticator authenticator)\n+    {\n+        if (!useExtendedCallerInfo(url)) {\n+            return super.getHttpCallerInfo(url, proxy, port, authenticator);\n+        }\n+        HttpsClient https = (HttpsClient)http;\n+        try {\n+            Certificate[] certs = https.getServerCertificates();\n+            if (certs[0] instanceof X509Certificate x509Cert) {\n+                return new HttpCallerInfo(url, proxy, port, x509Cert, authenticator);\n+            }\n+        } catch (SSLPeerUnverifiedException e) {\n+            \/\/ ignore\n+        }\n+        return super.getHttpCallerInfo(url, proxy, port, authenticator);\n+    }\n+\n+    @Override\n+    protected HttpCallerInfo getHttpCallerInfo(URL url, Authenticator authenticator)\n+    {\n+        if (!useExtendedCallerInfo(url)) {\n+            return super.getHttpCallerInfo(url, authenticator);\n+        }\n+        HttpsClient https = (HttpsClient)http;\n+        try {\n+            Certificate[] certs = https.getServerCertificates();\n+            if (certs[0] instanceof X509Certificate x509Cert) {\n+                return new HttpCallerInfo(url, x509Cert, authenticator);\n+            }\n+        } catch (SSLPeerUnverifiedException e) {\n+            \/\/ ignore\n+        }\n+        return super.getHttpCallerInfo(url, authenticator);\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/https\/AbstractDelegateHttpsURLConnection.java","additions":72,"deletions":1,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.util;\n+\n+import java.security.GeneralSecurityException;\n+\n+\/**\n+ * Thrown by TlsChannelBinding if an error occurs\n+ *\/\n+public class ChannelBindingException extends GeneralSecurityException {\n+\n+    @java.io.Serial\n+    private static final long serialVersionUID = -5021387249782788460L;\n+\n+    \/**\n+     * Constructs a ChannelBindingException with no detail message. A detail\n+     * message is a String that describes this particular exception.\n+     *\/\n+    public ChannelBindingException() {\n+        super();\n+    }\n+\n+    \/**\n+     * Constructs a ChannelBindingException with a detail message and\n+     * specified cause.\n+     *\/\n+    public ChannelBindingException(String msg, Exception e) {\n+        super(msg, e);\n+    }\n+\n+    \/**\n+     * Constructs a ChannelBindingException with a detail message\n+     *\/\n+    public ChannelBindingException(String msg) {\n+        super(msg);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/ChannelBindingException.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -0,0 +1,136 @@\n+\/*\n+ * Copyright (c) 2020, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.util;\n+\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.CertificateEncodingException;\n+import java.security.cert.X509Certificate;\n+import java.util.Arrays;\n+import java.util.Hashtable;\n+\n+\/**\n+ * This class implements the Channel Binding for TLS as defined in\n+ * <a href=\"https:\/\/www.ietf.org\/rfc\/rfc5929.txt\">\n+ *     Channel Bindings for TLS<\/a>\n+ *\n+ * Format of the Channel Binding data is also defined in\n+ * <a href=\"https:\/\/www.ietf.org\/rfc\/rfc5056.txt\">\n+ *     On the Use of Channel Bindings to Secure Channels<\/a>\n+ * section 2.1.\n+ *\n+ *\/\n+\n+public class TlsChannelBinding {\n+\n+    public enum TlsChannelBindingType {\n+\n+        \/**\n+         * Channel binding on the basis of TLS Finished message.\n+         * TLS_UNIQUE is defined by RFC 5929 but is not supported\n+         * by the current LDAP stack.\n+         *\/\n+        TLS_UNIQUE(\"tls-unique\"),\n+\n+        \/**\n+         * Channel binding on the basis of TLS server certificate.\n+         *\/\n+        TLS_SERVER_END_POINT(\"tls-server-end-point\");\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        private final String name;\n+        TlsChannelBindingType(String name) {\n+            this.name = name;\n+        }\n+    }\n+\n+    \/**\n+     * Parse given value to see if it is a recognized and supported channel binding type\n+     *\n+     * @param  cbType\n+     * @return TLS Channel Binding type or null if given string is null\n+     * @throws ChannelBindingException\n+     *\/\n+    public static TlsChannelBindingType parseType(String cbType) throws ChannelBindingException {\n+        if (cbType != null) {\n+            if (cbType.equals(TlsChannelBindingType.TLS_SERVER_END_POINT.getName())) {\n+                return TlsChannelBindingType.TLS_SERVER_END_POINT;\n+            } else {\n+                throw new ChannelBindingException(\"Illegal value for channel binding type: \" + cbType);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private final TlsChannelBindingType cbType;\n+    private final byte[] cbData;\n+\n+    \/**\n+     * Construct tls-server-end-point Channel Binding data\n+     * @param serverCertificate\n+     * @throws ChannelBindingException\n+     *\/\n+    public static TlsChannelBinding create(X509Certificate serverCertificate) throws ChannelBindingException {\n+        try {\n+            final byte[] prefix =\n+                TlsChannelBindingType.TLS_SERVER_END_POINT.getName().concat(\":\").getBytes();\n+            String hashAlg = serverCertificate.getSigAlgName().\n+                    replace(\"SHA\", \"SHA-\").toUpperCase();\n+            int ind = hashAlg.indexOf(\"WITH\");\n+            if (ind > 0) {\n+                hashAlg = hashAlg.substring(0, ind);\n+                if (hashAlg.equals(\"MD5\") || hashAlg.equals(\"SHA-1\")) {\n+                    hashAlg = \"SHA-256\";\n+                }\n+            } else {\n+                hashAlg = \"SHA-256\";\n+            }\n+            MessageDigest md = MessageDigest.getInstance(hashAlg);\n+            byte[] hash = md.digest(serverCertificate.getEncoded());\n+            byte[] cbData = Arrays.copyOf(prefix, prefix.length + hash.length );\n+            System.arraycopy(hash, 0, cbData, prefix.length, hash.length);\n+            return new TlsChannelBinding(TlsChannelBindingType.TLS_SERVER_END_POINT, cbData);\n+        } catch (NoSuchAlgorithmException | CertificateEncodingException e) {\n+            throw new ChannelBindingException(\"Cannot create TLS channel binding data\", e);\n+        }\n+    }\n+\n+    private TlsChannelBinding(TlsChannelBindingType cbType, byte[] cbData) {\n+        this.cbType = cbType;\n+        this.cbData = cbData;\n+    }\n+\n+    public TlsChannelBindingType getType() {\n+        return cbType;\n+    }\n+\n+    public byte[] getData() {\n+        return cbData;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/TlsChannelBinding.java","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"},{"patch":"@@ -45,1 +45,3 @@\n-import com.sun.jndi.ldap.sasl.TlsChannelBinding.TlsChannelBindingType;\n+import sun.security.util.ChannelBindingException;\n+import sun.security.util.TlsChannelBinding;\n+import sun.security.util.TlsChannelBinding.TlsChannelBindingType;\n@@ -65,0 +67,8 @@\n+    \/\/ TLS channel binding type property\n+    private static final String CHANNEL_BINDING_TYPE =\n+            \"com.sun.jndi.ldap.tls.cbtype\";\n+\n+    \/\/ internal TLS channel binding property\n+    private static final String CHANNEL_BINDING =\n+            \"jdk.internal.sasl.tlschannelbinding\";\n+\n@@ -116,2 +126,2 @@\n-        if (env.get(TlsChannelBinding.CHANNEL_BINDING) != null) {\n-            throw new NamingException(TlsChannelBinding.CHANNEL_BINDING +\n+        if (env.get(CHANNEL_BINDING) != null) {\n+            throw new NamingException(CHANNEL_BINDING +\n@@ -126,3 +136,6 @@\n-                TlsChannelBindingType cbType =\n-                        TlsChannelBinding.parseType(\n-                                (String)env.get(TlsChannelBinding.CHANNEL_BINDING_TYPE));\n+                TlsChannelBindingType cbType;\n+                try {\n+                    cbType = TlsChannelBinding.parseType((String)env.get(CHANNEL_BINDING_TYPE));\n+                } catch (ChannelBindingException e) {\n+                    throw wrapInNamingException(e);\n+                }\n@@ -133,2 +146,6 @@\n-                        TlsChannelBinding tlsCB =\n-                                TlsChannelBinding.create(cert);\n+                        TlsChannelBinding tlsCB;\n+                        try {\n+                            tlsCB = TlsChannelBinding.create(cert);\n+                        } catch (ChannelBindingException e) {\n+                            throw wrapInNamingException(e);\n+                        }\n@@ -136,1 +153,1 @@\n-                        envProps.put(TlsChannelBinding.CHANNEL_BINDING, tlsCB.getData());\n+                        envProps.put(CHANNEL_BINDING, tlsCB.getData());\n@@ -230,0 +247,6 @@\n+    private static NamingException wrapInNamingException(Exception e) {\n+        NamingException ne = new NamingException();\n+        ne.setRootCause(e);\n+        return ne;\n+    }\n+\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/sasl\/LdapSasl.java","additions":32,"deletions":9,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -1,146 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Azul Systems, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package com.sun.jndi.ldap.sasl;\n-\n-import javax.naming.NamingException;\n-import javax.security.sasl.SaslException;\n-import java.security.MessageDigest;\n-import java.security.NoSuchAlgorithmException;\n-import java.security.cert.CertificateEncodingException;\n-import java.security.cert.X509Certificate;\n-import java.util.Arrays;\n-import java.util.Hashtable;\n-\n-\/**\n- * This class implements the Channel Binding for TLS as defined in\n- * <a href=\"https:\/\/www.ietf.org\/rfc\/rfc5929.txt\">\n- *     Channel Bindings for TLS<\/a>\n- *\n- * Format of the Channel Binding data is also defined in\n- * <a href=\"https:\/\/www.ietf.org\/rfc\/rfc5056.txt\">\n- *     On the Use of Channel Bindings to Secure Channels<\/a>\n- * section 2.1.\n- *\n- *\/\n-\n-public class TlsChannelBinding {\n-\n-    \/\/ TLS channel binding type property\n-    public static final String CHANNEL_BINDING_TYPE =\n-            \"com.sun.jndi.ldap.tls.cbtype\";\n-\n-    \/\/ internal TLS channel binding property\n-    public static final String CHANNEL_BINDING =\n-            \"jdk.internal.sasl.tlschannelbinding\";\n-\n-    public enum TlsChannelBindingType {\n-\n-        \/**\n-         * Channel binding on the basis of TLS Finished message.\n-         * TLS_UNIQUE is defined by RFC 5929 but is not supported\n-         * by the current LDAP stack.\n-         *\/\n-        TLS_UNIQUE(\"tls-unique\"),\n-\n-        \/**\n-         * Channel binding on the basis of TLS server certificate.\n-         *\/\n-        TLS_SERVER_END_POINT(\"tls-server-end-point\");\n-\n-        public String getName() {\n-            return name;\n-        }\n-\n-        private final String name;\n-        TlsChannelBindingType(String name) {\n-            this.name = name;\n-        }\n-    }\n-\n-    \/**\n-     * Parse value of \"com.sun.jndi.ldap.tls.cbtype\" property\n-     * @param  cbType\n-     * @return TLS Channel Binding type or null if\n-     *         \"com.sun.jndi.ldap.tls.cbtype\" property has not been set.\n-     * @throws NamingException\n-     *\/\n-    public static TlsChannelBindingType parseType(String cbType) throws NamingException {\n-        if (cbType != null) {\n-            if (cbType.equals(TlsChannelBindingType.TLS_SERVER_END_POINT.getName())) {\n-                return TlsChannelBindingType.TLS_SERVER_END_POINT;\n-            } else {\n-                throw new NamingException(\"Illegal value for \" +\n-                        CHANNEL_BINDING_TYPE + \" property.\");\n-            }\n-        }\n-        return null;\n-    }\n-\n-    private final TlsChannelBindingType cbType;\n-    private final byte[] cbData;\n-\n-    \/**\n-     * Construct tls-server-end-point Channel Binding data\n-     * @param serverCertificate\n-     * @throws SaslException\n-     *\/\n-    public static TlsChannelBinding create(X509Certificate serverCertificate) throws SaslException {\n-        try {\n-            final byte[] prefix =\n-                TlsChannelBindingType.TLS_SERVER_END_POINT.getName().concat(\":\").getBytes();\n-            String hashAlg = serverCertificate.getSigAlgName().\n-                    replace(\"SHA\", \"SHA-\").toUpperCase();\n-            int ind = hashAlg.indexOf(\"WITH\");\n-            if (ind > 0) {\n-                hashAlg = hashAlg.substring(0, ind);\n-                if (hashAlg.equals(\"MD5\") || hashAlg.equals(\"SHA-1\")) {\n-                    hashAlg = \"SHA-256\";\n-                }\n-            } else {\n-                hashAlg = \"SHA-256\";\n-            }\n-            MessageDigest md = MessageDigest.getInstance(hashAlg);\n-            byte[] hash = md.digest(serverCertificate.getEncoded());\n-            byte[] cbData = Arrays.copyOf(prefix, prefix.length + hash.length );\n-            System.arraycopy(hash, 0, cbData, prefix.length, hash.length);\n-            return new TlsChannelBinding(TlsChannelBindingType.TLS_SERVER_END_POINT, cbData);\n-        } catch (NoSuchAlgorithmException | CertificateEncodingException e) {\n-            throw new SaslException(\"Cannot create TLS channel binding data\", e);\n-        }\n-    }\n-\n-    private TlsChannelBinding(TlsChannelBindingType cbType, byte[] cbData) {\n-        this.cbType = cbType;\n-        this.cbData = cbData;\n-    }\n-\n-    public TlsChannelBindingType getType() {\n-        return cbType;\n-    }\n-\n-    public byte[] getData() {\n-        return cbData;\n-    }\n-}\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/sasl\/TlsChannelBinding.java","additions":0,"deletions":146,"binary":false,"changes":146,"status":"deleted"},{"patch":"@@ -43,0 +43,3 @@\n+import sun.security.jgss.krb5.internal.TlsChannelBindingImpl;\n+import sun.security.util.ChannelBindingException;\n+import sun.security.util.TlsChannelBinding;\n@@ -68,1 +71,1 @@\n-    private void init(HttpCallerInfo hci) throws GSSException {\n+    private void init(HttpCallerInfo hci) throws GSSException, ChannelBindingException {\n@@ -103,0 +106,8 @@\n+        if (hci.serverCert != null) {\n+            if (DEBUG) {\n+                System.out.println(\"Negotiate: Setting CBT\");\n+            }\n+            \/\/ set the channel binding token\n+            TlsChannelBinding b = TlsChannelBinding.create(hci.serverCert);\n+            context.setChannelBinding(new TlsChannelBindingImpl(b.getData()));\n+        }\n@@ -113,1 +124,1 @@\n-        } catch (GSSException e) {\n+        } catch (GSSException | ChannelBindingException e) {\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/net\/www\/protocol\/http\/spnego\/NegotiatorImpl.java","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ * @modules java.base\/sun.security.util\n@@ -56,0 +57,2 @@\n+import sun.security.util.ChannelBindingException;\n+\n@@ -190,1 +193,2 @@\n-        if (!shouldPass && ne.getRootCause() == null) {\n+        Throwable rc = ne.getRootCause();\n+        if (!shouldPass && (rc == null || rc instanceof ChannelBindingException)) {\n","filename":"test\/jdk\/com\/sun\/jndi\/ldap\/LdapCBPropertiesTest.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"}]}