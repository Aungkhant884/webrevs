{"files":[{"patch":"@@ -217,0 +217,15 @@\n+\t<LI><P><B>{@systemProperty jdk.https.negotiate.cbt}<\/B> (default: &lt;never&gt;)<BR>\n+\tThis controls the generation and sending of TLS channel binding tokens (CBT) when Kerberos \n+        or the Negotiate authentication scheme using Kerberos are employed over HTTPS with\n+        {@code HttpsURLConnection}. There are three possible settings:<\/P>\n+        <OL>\n+          <LI><P>\"never\". This is also the default value if the property is not set. In this case,\n+              CBTs are never sent.<\/P>\n+          <LI><P>\"always\". CBTs are sent for all Kerberos authentication attempts over HTTPS.<\/P>\n+          <LI><P>\"domain:&lt;comma separated domain list&gt;\" Each domain in the list specifies destination\n+              host or hosts for which a CBT is sent. Domains can be single hosts like foo, or foo.com,\n+              or wildcards like *.foo.com which matches all hosts under foo.com and its sub-domains.\n+              CBTs are not sent to any destinations that don't match one of the list entries<\/P>\n+\t<\/OL>\n+\t<P>The channel binding tokens generated are of the type \"tls-server-end-point\" as defined in\n+           RFC 5929.<\/P>\n","filename":"src\/java.base\/share\/classes\/java\/net\/doc-files\/net-properties.html","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -147,0 +147,9 @@\n+    \/* \"jdk.https.negotiate.cbt\" property can be set to \"always\" (always sent), \"never\" (never sent) or\n+     * \"domain:a,c.d,*.e.f\" (sent to host a, or c.d or to the domain e.f and any of its subdomains). This is\n+     * a comma separated list of arbitrary length with no white-space allowed.\n+     * If enabled (for a particular destination) then Negotiate\/SPNEGO authentication requests will include\n+     * a channel binding token for the destination server. The default behavior and setting for the\n+     * property is \"never\"\n+     *\/\n+    private static final String spnegoCBT;\n+\n@@ -148,0 +157,1 @@\n+\n@@ -153,0 +163,5 @@\n+    private static void logError(String msg) {\n+        if (logger.isLoggable(PlatformLogger.Level.SEVERE)) {\n+            logger.severe(msg);\n+        }\n+    }\n@@ -168,0 +183,12 @@\n+    static String normalizeCBT(String s) {\n+        if (s == null || s.equals(\"never\")) {\n+            return \"never\";\n+        }\n+        if (s.equals(\"always\") || s.startsWith(\"domain:\")) {\n+            return s;\n+        } else {\n+            logError(\"Unexpected value for \\\"jdk.https.negotiate.cbt\\\" system property\");\n+            return \"never\";\n+        }\n+    }\n+\n@@ -175,0 +202,3 @@\n+        String s = props.getProperty(\"jdk.https.negotiate.cbt\");\n+        spnegoCBT = normalizeCBT(s);\n+\n@@ -209,0 +239,4 @@\n+    public String getSpnegoCBT() {\n+        return spnegoCBT;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/http\/HttpClient.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.security.cert.X509Certificate;\n@@ -54,0 +55,3 @@\n+    \/\/ Used to obtain server cert for SPNEGO CBT.\n+    \/\/ May be null in which case CBT is not set\n+    public final X509Certificate serverCert;\n@@ -68,0 +72,1 @@\n+        this.serverCert =  old.serverCert;\n@@ -74,0 +79,4 @@\n+        this(url, null, a);\n+    }\n+\n+    public HttpCallerInfo(URL url, X509Certificate serverCert, Authenticator a) {\n@@ -75,0 +84,1 @@\n+        this.serverCert= serverCert;\n@@ -103,0 +113,4 @@\n+        this(url, host, port, null, a);\n+    }\n+\n+    public HttpCallerInfo(URL url, String host, int port, X509Certificate serverCert, Authenticator a) {\n@@ -106,0 +120,1 @@\n+        this.serverCert = serverCert;\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/http\/HttpCallerInfo.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1743,1 +1743,1 @@\n-                            new HttpCallerInfo(url,\n+                            getHttpCallerInfo(url,\n@@ -1818,1 +1818,1 @@\n-                            new HttpCallerInfo(url, authenticator),\n+                            getHttpCallerInfo(url, authenticator),\n@@ -2214,1 +2214,1 @@\n-                            new HttpCallerInfo(url,\n+                            getHttpCallerInfo(url,\n@@ -2283,0 +2283,15 @@\n+    \/**\n+     * Overridden in https to also include the server certificate\n+     *\/\n+    protected HttpCallerInfo getHttpCallerInfo(URL url, String proxy, int port,\n+                                               Authenticator authenticator) {\n+        return new HttpCallerInfo(url, proxy, port, authenticator);\n+    }\n+\n+    \/**\n+     * Overridden in https to also include the server certificate\n+     *\/\n+    protected HttpCallerInfo getHttpCallerInfo(URL url, Authenticator authenticator) {\n+        return new HttpCallerInfo(url, authenticator);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/http\/HttpURLConnection.java","additions":18,"deletions":3,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-\/*\n+\/**\n@@ -28,0 +28,1 @@\n+import java.net.Authenticator;\n@@ -32,0 +33,2 @@\n+import java.security.cert.Certificate;\n+import java.security.cert.X509Certificate;\n@@ -39,0 +42,1 @@\n+import sun.net.www.protocol.http.HttpCallerInfo;\n@@ -312,0 +316,67 @@\n+\n+    \/*\n+     * If no SSL Session available or if the system config does not allow it\n+     * don't use the extended caller info (the server cert).\n+     * Otherwise return true to include the server cert\n+     *\/\n+    private boolean useExtendedCallerInfo(URL url) {\n+        HttpsClient https = (HttpsClient)http;\n+        if (https.getSSLSession() == null) {\n+            return false;\n+        }\n+        String prop = http.getSpnegoCBT();\n+        if (prop.equals(\"never\")) {\n+            return false;\n+        }\n+        String target = url.getHost();\n+        if (prop.startsWith(\"domain:\")) {\n+            String[] domains = prop.substring(7).split(\",\");\n+            for (String domain : domains) {\n+                if (target.equals(domain)) {\n+                    return true;\n+                }\n+                if (domain.startsWith(\"*.\") && target.endsWith(domain.substring(1))) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    protected HttpCallerInfo getHttpCallerInfo(URL url, String proxy, int port,\n+                                               Authenticator authenticator)\n+    {\n+        if (!useExtendedCallerInfo(url)) {\n+            return super.getHttpCallerInfo(url, proxy, port, authenticator);\n+        }\n+        HttpsClient https = (HttpsClient)http;\n+        try {\n+            Certificate[] certs = https.getServerCertificates();\n+            if (certs[0] instanceof X509Certificate x509Cert) {\n+                return new HttpCallerInfo(url, proxy, port, x509Cert, authenticator);\n+            }\n+        } catch (SSLPeerUnverifiedException e) {\n+            \/\/ ignore\n+        }\n+        return super.getHttpCallerInfo(url, proxy, port, authenticator);\n+    }\n+\n+    @Override\n+    protected HttpCallerInfo getHttpCallerInfo(URL url, Authenticator authenticator)\n+    {\n+        if (!useExtendedCallerInfo(url)) {\n+            return super.getHttpCallerInfo(url, authenticator);\n+        }\n+        HttpsClient https = (HttpsClient)http;\n+        try {\n+            Certificate[] certs = https.getServerCertificates();\n+            if (certs[0] instanceof X509Certificate x509Cert) {\n+                return new HttpCallerInfo(url, x509Cert, authenticator);\n+            }\n+        } catch (SSLPeerUnverifiedException e) {\n+            \/\/ ignore\n+        }\n+        return super.getHttpCallerInfo(url, authenticator);\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/https\/AbstractDelegateHttpsURLConnection.java","additions":72,"deletions":1,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.util;\n+\n+import java.security.GeneralSecurityException;\n+\n+\/**\n+ * Thrown by TlsChannelBinding if an error occurs\n+ *\/\n+public class ChannelBindingException extends GeneralSecurityException {\n+\n+    @java.io.Serial\n+    private static final long serialVersionUID = -5021387249782788460L;\n+\n+    \/**\n+     * Constructs a ChannelBindingException with no detail message. A detail\n+     * message is a String that describes this particular exception.\n+     *\/\n+    public ChannelBindingException() {\n+        super();\n+    }\n+\n+    \/**\n+     * Constructs a ChannelBindingException with a detail message and\n+     * specified cause.\n+     *\/\n+    public ChannelBindingException(String msg, Exception e) {\n+        super(msg, e);\n+    }\n+\n+    \/**\n+     * Constructs a ChannelBindingException with a detail message\n+     *\/\n+    public ChannelBindingException(String msg) {\n+        super(msg);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/ChannelBindingException.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -0,0 +1,136 @@\n+\/*\n+ * Copyright (c) 2020, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.util;\n+\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.CertificateEncodingException;\n+import java.security.cert.X509Certificate;\n+import java.util.Arrays;\n+import java.util.Hashtable;\n+\n+\/**\n+ * This class implements the Channel Binding for TLS as defined in\n+ * <a href=\"https:\/\/www.ietf.org\/rfc\/rfc5929.txt\">\n+ *     Channel Bindings for TLS<\/a>\n+ *\n+ * Format of the Channel Binding data is also defined in\n+ * <a href=\"https:\/\/www.ietf.org\/rfc\/rfc5056.txt\">\n+ *     On the Use of Channel Bindings to Secure Channels<\/a>\n+ * section 2.1.\n+ *\n+ *\/\n+\n+public class TlsChannelBinding {\n+\n+    public enum TlsChannelBindingType {\n+\n+        \/**\n+         * Channel binding on the basis of TLS Finished message.\n+         * TLS_UNIQUE is defined by RFC 5929 but is not supported\n+         * by the current LDAP stack.\n+         *\/\n+        TLS_UNIQUE(\"tls-unique\"),\n+\n+        \/**\n+         * Channel binding on the basis of TLS server certificate.\n+         *\/\n+        TLS_SERVER_END_POINT(\"tls-server-end-point\");\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        private final String name;\n+        TlsChannelBindingType(String name) {\n+            this.name = name;\n+        }\n+    }\n+\n+    \/**\n+     * Parse given value to see if it is a recognized and supported channel binding type\n+     *\n+     * @param  cbType\n+     * @return TLS Channel Binding type or null if given string is null\n+     * @throws ChannelBindingException\n+     *\/\n+    public static TlsChannelBindingType parseType(String cbType) throws ChannelBindingException {\n+        if (cbType != null) {\n+            if (cbType.equals(TlsChannelBindingType.TLS_SERVER_END_POINT.getName())) {\n+                return TlsChannelBindingType.TLS_SERVER_END_POINT;\n+            } else {\n+                throw new ChannelBindingException(\"Illegal value for channel binding type: \" + cbType);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private final TlsChannelBindingType cbType;\n+    private final byte[] cbData;\n+\n+    \/**\n+     * Construct tls-server-end-point Channel Binding data\n+     * @param serverCertificate\n+     * @throws ChannelBindingException\n+     *\/\n+    public static TlsChannelBinding create(X509Certificate serverCertificate) throws ChannelBindingException {\n+        try {\n+            final byte[] prefix =\n+                TlsChannelBindingType.TLS_SERVER_END_POINT.getName().concat(\":\").getBytes();\n+            String hashAlg = serverCertificate.getSigAlgName().\n+                    replace(\"SHA\", \"SHA-\").toUpperCase();\n+            int ind = hashAlg.indexOf(\"WITH\");\n+            if (ind > 0) {\n+                hashAlg = hashAlg.substring(0, ind);\n+                if (hashAlg.equals(\"MD5\") || hashAlg.equals(\"SHA-1\")) {\n+                    hashAlg = \"SHA-256\";\n+                }\n+            } else {\n+                hashAlg = \"SHA-256\";\n+            }\n+            MessageDigest md = MessageDigest.getInstance(hashAlg);\n+            byte[] hash = md.digest(serverCertificate.getEncoded());\n+            byte[] cbData = Arrays.copyOf(prefix, prefix.length + hash.length );\n+            System.arraycopy(hash, 0, cbData, prefix.length, hash.length);\n+            return new TlsChannelBinding(TlsChannelBindingType.TLS_SERVER_END_POINT, cbData);\n+        } catch (NoSuchAlgorithmException | CertificateEncodingException e) {\n+            throw new ChannelBindingException(\"Cannot create TLS channel binding data\", e);\n+        }\n+    }\n+\n+    private TlsChannelBinding(TlsChannelBindingType cbType, byte[] cbData) {\n+        this.cbType = cbType;\n+        this.cbData = cbData;\n+    }\n+\n+    public TlsChannelBindingType getType() {\n+        return cbType;\n+    }\n+\n+    public byte[] getData() {\n+        return cbData;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/TlsChannelBinding.java","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"},{"patch":"@@ -45,1 +45,3 @@\n-import com.sun.jndi.ldap.sasl.TlsChannelBinding.TlsChannelBindingType;\n+import sun.security.util.ChannelBindingException;\n+import sun.security.util.TlsChannelBinding;\n+import sun.security.util.TlsChannelBinding.TlsChannelBindingType;\n@@ -65,0 +67,8 @@\n+    \/\/ TLS channel binding type property\n+    private static final String CHANNEL_BINDING_TYPE =\n+            \"com.sun.jndi.ldap.tls.cbtype\";\n+\n+    \/\/ internal TLS channel binding property\n+    private static final String CHANNEL_BINDING =\n+            \"jdk.internal.sasl.tlschannelbinding\";\n+\n@@ -116,2 +126,2 @@\n-        if (env.get(TlsChannelBinding.CHANNEL_BINDING) != null) {\n-            throw new NamingException(TlsChannelBinding.CHANNEL_BINDING +\n+        if (env.get(CHANNEL_BINDING) != null) {\n+            throw new NamingException(CHANNEL_BINDING +\n@@ -126,3 +136,6 @@\n-                TlsChannelBindingType cbType =\n-                        TlsChannelBinding.parseType(\n-                                (String)env.get(TlsChannelBinding.CHANNEL_BINDING_TYPE));\n+                TlsChannelBindingType cbType;\n+                try {\n+                    cbType = TlsChannelBinding.parseType((String)env.get(CHANNEL_BINDING_TYPE));\n+                } catch (ChannelBindingException e) {\n+                    throw wrapInNamingException(e);\n+                }\n@@ -133,2 +146,6 @@\n-                        TlsChannelBinding tlsCB =\n-                                TlsChannelBinding.create(cert);\n+                        TlsChannelBinding tlsCB;\n+                        try {\n+                            tlsCB = TlsChannelBinding.create(cert);\n+                        } catch (ChannelBindingException e) {\n+                            throw wrapInNamingException(e);\n+                        }\n@@ -136,1 +153,1 @@\n-                        envProps.put(TlsChannelBinding.CHANNEL_BINDING, tlsCB.getData());\n+                        envProps.put(CHANNEL_BINDING, tlsCB.getData());\n@@ -230,0 +247,6 @@\n+    private static NamingException wrapInNamingException(Exception e) {\n+        NamingException ne = new NamingException();\n+        ne.setRootCause(e);\n+        return ne;\n+    }\n+\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/sasl\/LdapSasl.java","additions":32,"deletions":9,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -1,146 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Azul Systems, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package com.sun.jndi.ldap.sasl;\n-\n-import javax.naming.NamingException;\n-import javax.security.sasl.SaslException;\n-import java.security.MessageDigest;\n-import java.security.NoSuchAlgorithmException;\n-import java.security.cert.CertificateEncodingException;\n-import java.security.cert.X509Certificate;\n-import java.util.Arrays;\n-import java.util.Hashtable;\n-\n-\/**\n- * This class implements the Channel Binding for TLS as defined in\n- * <a href=\"https:\/\/www.ietf.org\/rfc\/rfc5929.txt\">\n- *     Channel Bindings for TLS<\/a>\n- *\n- * Format of the Channel Binding data is also defined in\n- * <a href=\"https:\/\/www.ietf.org\/rfc\/rfc5056.txt\">\n- *     On the Use of Channel Bindings to Secure Channels<\/a>\n- * section 2.1.\n- *\n- *\/\n-\n-public class TlsChannelBinding {\n-\n-    \/\/ TLS channel binding type property\n-    public static final String CHANNEL_BINDING_TYPE =\n-            \"com.sun.jndi.ldap.tls.cbtype\";\n-\n-    \/\/ internal TLS channel binding property\n-    public static final String CHANNEL_BINDING =\n-            \"jdk.internal.sasl.tlschannelbinding\";\n-\n-    public enum TlsChannelBindingType {\n-\n-        \/**\n-         * Channel binding on the basis of TLS Finished message.\n-         * TLS_UNIQUE is defined by RFC 5929 but is not supported\n-         * by the current LDAP stack.\n-         *\/\n-        TLS_UNIQUE(\"tls-unique\"),\n-\n-        \/**\n-         * Channel binding on the basis of TLS server certificate.\n-         *\/\n-        TLS_SERVER_END_POINT(\"tls-server-end-point\");\n-\n-        public String getName() {\n-            return name;\n-        }\n-\n-        private final String name;\n-        TlsChannelBindingType(String name) {\n-            this.name = name;\n-        }\n-    }\n-\n-    \/**\n-     * Parse value of \"com.sun.jndi.ldap.tls.cbtype\" property\n-     * @param  cbType\n-     * @return TLS Channel Binding type or null if\n-     *         \"com.sun.jndi.ldap.tls.cbtype\" property has not been set.\n-     * @throws NamingException\n-     *\/\n-    public static TlsChannelBindingType parseType(String cbType) throws NamingException {\n-        if (cbType != null) {\n-            if (cbType.equals(TlsChannelBindingType.TLS_SERVER_END_POINT.getName())) {\n-                return TlsChannelBindingType.TLS_SERVER_END_POINT;\n-            } else {\n-                throw new NamingException(\"Illegal value for \" +\n-                        CHANNEL_BINDING_TYPE + \" property.\");\n-            }\n-        }\n-        return null;\n-    }\n-\n-    private final TlsChannelBindingType cbType;\n-    private final byte[] cbData;\n-\n-    \/**\n-     * Construct tls-server-end-point Channel Binding data\n-     * @param serverCertificate\n-     * @throws SaslException\n-     *\/\n-    public static TlsChannelBinding create(X509Certificate serverCertificate) throws SaslException {\n-        try {\n-            final byte[] prefix =\n-                TlsChannelBindingType.TLS_SERVER_END_POINT.getName().concat(\":\").getBytes();\n-            String hashAlg = serverCertificate.getSigAlgName().\n-                    replace(\"SHA\", \"SHA-\").toUpperCase();\n-            int ind = hashAlg.indexOf(\"WITH\");\n-            if (ind > 0) {\n-                hashAlg = hashAlg.substring(0, ind);\n-                if (hashAlg.equals(\"MD5\") || hashAlg.equals(\"SHA-1\")) {\n-                    hashAlg = \"SHA-256\";\n-                }\n-            } else {\n-                hashAlg = \"SHA-256\";\n-            }\n-            MessageDigest md = MessageDigest.getInstance(hashAlg);\n-            byte[] hash = md.digest(serverCertificate.getEncoded());\n-            byte[] cbData = Arrays.copyOf(prefix, prefix.length + hash.length );\n-            System.arraycopy(hash, 0, cbData, prefix.length, hash.length);\n-            return new TlsChannelBinding(TlsChannelBindingType.TLS_SERVER_END_POINT, cbData);\n-        } catch (NoSuchAlgorithmException | CertificateEncodingException e) {\n-            throw new SaslException(\"Cannot create TLS channel binding data\", e);\n-        }\n-    }\n-\n-    private TlsChannelBinding(TlsChannelBindingType cbType, byte[] cbData) {\n-        this.cbType = cbType;\n-        this.cbData = cbData;\n-    }\n-\n-    public TlsChannelBindingType getType() {\n-        return cbType;\n-    }\n-\n-    public byte[] getData() {\n-        return cbData;\n-    }\n-}\n","filename":"src\/java.naming\/share\/classes\/com\/sun\/jndi\/ldap\/sasl\/TlsChannelBinding.java","additions":0,"deletions":146,"binary":false,"changes":146,"status":"deleted"},{"patch":"@@ -43,0 +43,3 @@\n+import sun.security.jgss.krb5.internal.TlsChannelBindingImpl;\n+import sun.security.util.ChannelBindingException;\n+import sun.security.util.TlsChannelBinding;\n@@ -68,1 +71,1 @@\n-    private void init(HttpCallerInfo hci) throws GSSException {\n+    private void init(HttpCallerInfo hci) throws GSSException, ChannelBindingException {\n@@ -103,0 +106,8 @@\n+        if (hci.serverCert != null) {\n+            if (DEBUG) {\n+                System.out.println(\"Negotiate: Setting CBT\");\n+            }\n+            \/\/ set the channel binding token\n+            TlsChannelBinding b = TlsChannelBinding.create(hci.serverCert);\n+            context.setChannelBinding(new TlsChannelBindingImpl(b.getData()));\n+        }\n@@ -113,1 +124,1 @@\n-        } catch (GSSException e) {\n+        } catch (GSSException | ChannelBindingException e) {\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/net\/www\/protocol\/http\/spnego\/NegotiatorImpl.java","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ * @modules java.base\/sun.security.util\n@@ -56,0 +57,2 @@\n+import sun.security.util.ChannelBindingException;\n+\n@@ -190,1 +193,2 @@\n-        if (!shouldPass && ne.getRootCause() == null) {\n+        Throwable rc = ne.getRootCause();\n+        if (!shouldPass && (rc == null || rc instanceof ChannelBindingException)) {\n","filename":"test\/jdk\/com\/sun\/jndi\/ldap\/LdapCBPropertiesTest.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,311 @@\n+\/*\r\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\r\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\r\n+ *\r\n+ * This code is free software; you can redistribute it and\/or modify it\r\n+ * under the terms of the GNU General Public License version 2 only, as\r\n+ * published by the Free Software Foundation.\r\n+ *\r\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\r\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\r\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\r\n+ * version 2 for more details (a copy is included in the LICENSE file that\r\n+ * accompanied this code).\r\n+ *\r\n+ * You should have received a copy of the GNU General Public License version\r\n+ * 2 along with this work; if not, write to the Free Software Foundation,\r\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\r\n+ *\r\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\r\n+ * or visit www.oracle.com if you need additional information or have any\r\n+ * questions.\r\n+ *\/\r\n+\r\n+\/*\r\n+ * @test\r\n+ * @bug 8279842\r\n+ * @modules java.base\/sun.security.util\r\n+ *          java.security.jgss\/sun.security.jgss\r\n+ *          java.security.jgss\/sun.security.jgss.krb5\r\n+ *          java.security.jgss\/sun.security.jgss.krb5.internal\r\n+ *          java.security.jgss\/sun.security.krb5.internal:+open\r\n+ *          java.security.jgss\/sun.security.krb5:+open\r\n+ *          java.security.jgss\/sun.security.krb5.internal.ccache\r\n+ *          java.security.jgss\/sun.security.krb5.internal.crypto\r\n+ *          java.security.jgss\/sun.security.krb5.internal.ktab\r\n+ *          jdk.security.auth\r\n+ *          jdk.security.jgss\r\n+ *          jdk.httpserver\r\n+ * @summary HTTPS Channel Binding support for Java GSS\/Kerberos\r\n+ * @library \/test\/lib\r\n+ * @run main jdk.test.lib.FileInstaller TestHosts TestHosts\r\n+ * @run main\/othervm -Djdk.net.hosts.file=TestHosts\r\n+ *          -Djdk.https.negotiate.cbt=always HttpsCB true true\r\n+ * @run main\/othervm -Djdk.net.hosts.file=TestHosts\r\n+ *          -Djdk.https.negotiate.cbt=never HttpsCB false true\r\n+ * @run main\/othervm -Djdk.net.hosts.file=TestHosts\r\n+ *          -Djdk.https.negotiate.cbt=invalid HttpsCB false true\r\n+ * @run main\/othervm -Djdk.net.hosts.file=TestHosts\r\n+ *          HttpsCB false true\r\n+ * @run main\/othervm -Djdk.net.hosts.file=TestHosts\r\n+ *          -Djdk.https.negotiate.cbt=domain:other.com HttpsCB false true\r\n+ * @run main\/othervm -Djdk.net.hosts.file=TestHosts\r\n+ *          -Djdk.https.negotiate.cbt=domain:host.web.domain HttpsCB true true\r\n+ * @run main\/othervm -Djdk.net.hosts.file=TestHosts\r\n+ *          -Djdk.https.negotiate.cbt=domain:*.web.domain HttpsCB true true\r\n+ *\/\r\n+\r\n+import com.sun.net.httpserver.Headers;\r\n+import com.sun.net.httpserver.HttpExchange;\r\n+import com.sun.net.httpserver.HttpHandler;\r\n+import com.sun.net.httpserver.HttpServer;\r\n+import com.sun.net.httpserver.HttpPrincipal;\r\n+import com.sun.net.httpserver.HttpsConfigurator;\r\n+import com.sun.net.httpserver.HttpsExchange;\r\n+import com.sun.net.httpserver.HttpsServer;\r\n+import com.sun.security.auth.module.Krb5LoginModule;\r\n+import java.io.BufferedReader;\r\n+import java.io.File;\r\n+import java.io.FileOutputStream;\r\n+import java.io.IOException;\r\n+import java.io.InputStreamReader;\r\n+import java.net.HttpURLConnection;\r\n+import java.net.InetSocketAddress;\r\n+import java.net.PasswordAuthentication;\r\n+import java.net.Proxy;\r\n+import java.net.Socket;\r\n+import java.net.URL;\r\n+import java.security.cert.X509Certificate;\r\n+import java.util.HashMap;\r\n+import java.util.Map;\r\n+import javax.net.ssl.HttpsURLConnection;\r\n+import javax.net.ssl.SSLContext;\r\n+import javax.net.ssl.SSLEngine;\r\n+import javax.net.ssl.TrustManager;\r\n+import javax.net.ssl.X509ExtendedTrustManager;\r\n+import javax.security.auth.Subject;\r\n+\r\n+import jdk.test.lib.Asserts;\r\n+import jdk.test.lib.net.SimpleSSLContext;\r\n+import org.ietf.jgss.GSSContext;\r\n+import org.ietf.jgss.GSSCredential;\r\n+import org.ietf.jgss.GSSManager;\r\n+import sun.security.jgss.GSSUtil;\r\n+import sun.security.jgss.krb5.internal.TlsChannelBindingImpl;\r\n+import sun.security.krb5.Config;\r\n+import sun.security.util.TlsChannelBinding;\r\n+\r\n+import java.util.Base64;\r\n+import java.util.concurrent.Callable;\r\n+\r\n+public class HttpsCB {\r\n+\r\n+    final static String REALM_WEB = \"WEB.DOMAIN\";\r\n+    final static String KRB5_CONF = \"web.conf\";\r\n+    final static String KRB5_TAB = \"web.ktab\";\r\n+\r\n+    final static String WEB_USER = \"web\";\r\n+    final static char[] WEB_PASS = \"webby\".toCharArray();\r\n+    final static String WEB_HOST = \"host.web.domain\";\r\n+    final static String CONTENT = \"Hello, World!\";\r\n+\r\n+    static int webPort;\r\n+    static URL cbtURL;\r\n+    static URL normalURL;\r\n+\r\n+    public static void main(String[] args)\r\n+            throws Exception {\r\n+\r\n+        boolean expected1 = Boolean.parseBoolean(args[0]);\r\n+        boolean expected2 = Boolean.parseBoolean(args[1]);\r\n+\r\n+        System.setProperty(\"sun.security.krb5.debug\", \"true\");\r\n+\r\n+        KDC kdcw = KDC.create(REALM_WEB);\r\n+        kdcw.addPrincipal(WEB_USER, WEB_PASS);\r\n+        kdcw.addPrincipalRandKey(\"krbtgt\/\" + REALM_WEB);\r\n+        kdcw.addPrincipalRandKey(\"HTTP\/\" + WEB_HOST);\r\n+\r\n+        KDC.saveConfig(KRB5_CONF, kdcw,\r\n+                \"default_keytab_name = \" + KRB5_TAB,\r\n+                \"[domain_realm]\",\r\n+                \"\",\r\n+                \".web.domain=\"+REALM_WEB);\r\n+\r\n+        System.setProperty(\"java.security.krb5.conf\", KRB5_CONF);\r\n+        Config.refresh();\r\n+        KDC.writeMultiKtab(KRB5_TAB, kdcw);\r\n+\r\n+        \/\/ Write a customized JAAS conf file, so that any kinit cache\r\n+        \/\/ will be ignored.\r\n+        System.setProperty(\"java.security.auth.login.config\", OneKDC.JAAS_CONF);\r\n+        File f = new File(OneKDC.JAAS_CONF);\r\n+        FileOutputStream fos = new FileOutputStream(f);\r\n+        fos.write((\r\n+                \"com.sun.security.jgss.krb5.initiate {\\n\" +\r\n+                \"    com.sun.security.auth.module.Krb5LoginModule required;\\n};\\n\"\r\n+                ).getBytes());\r\n+        fos.close();\r\n+\r\n+        HttpServer h1 = httpd(\"Negotiate\",\r\n+                \"HTTP\/\" + WEB_HOST + \"@\" + REALM_WEB, KRB5_TAB);\r\n+        webPort = h1.getAddress().getPort();\r\n+\r\n+        cbtURL = new URL(\"https:\/\/\" + WEB_HOST +\":\" + webPort + \"\/cbt\");\r\n+        normalURL = new URL(\"https:\/\/\" + WEB_HOST +\":\" + webPort + \"\/normal\");\r\n+\r\n+        java.net.Authenticator.setDefault(new java.net.Authenticator() {\r\n+            public PasswordAuthentication getPasswordAuthentication () {\r\n+                return new PasswordAuthentication(\r\n+                        WEB_USER+\"@\"+REALM_WEB, WEB_PASS);\r\n+            }\r\n+        });\r\n+\r\n+        \/\/ Client-side SSLContext needs to ignore hostname mismatch\r\n+        \/\/ and untrusted certificate.\r\n+        SSLContext sc = SSLContext.getInstance(\"SSL\");\r\n+        sc.init(null, new TrustManager[] {\r\n+                new X509ExtendedTrustManager() {\r\n+                    public X509Certificate[] getAcceptedIssuers() {\r\n+                        return null;\r\n+                    }\r\n+                    public void checkClientTrusted(X509Certificate[] chain,\r\n+                            String authType, Socket socket) { }\r\n+                    public void checkServerTrusted(X509Certificate[] chain,\r\n+                            String authType, Socket socket) { }\r\n+                    public void checkClientTrusted(X509Certificate[] chain,\r\n+                            String authType, SSLEngine engine) { }\r\n+                    public void checkServerTrusted(X509Certificate[] chain,\r\n+                            String authType, SSLEngine engine) { }\r\n+                    public void checkClientTrusted(X509Certificate[] certs,\r\n+                            String authType) { }\r\n+                    public void checkServerTrusted(X509Certificate[] certs,\r\n+                            String authType) { }\r\n+                }\r\n+        }, null);\r\n+\r\n+        Asserts.assertEQ(visit(sc, cbtURL), expected1);\r\n+        Asserts.assertEQ(visit(sc, normalURL), expected2);\r\n+    }\r\n+\r\n+    static boolean visit(SSLContext sc, URL url) {\r\n+        try {\r\n+            HttpsURLConnection conn = (HttpsURLConnection)\r\n+                    url.openConnection(Proxy.NO_PROXY);\r\n+            conn.setSSLSocketFactory(sc.getSocketFactory());\r\n+            BufferedReader reader;\r\n+            reader = new BufferedReader(new InputStreamReader(\r\n+                    conn.getInputStream()));\r\n+            return reader.readLine().equals(CONTENT);\r\n+        } catch (Exception e) {\r\n+            return false;\r\n+        }\r\n+    }\r\n+\r\n+    static HttpServer httpd(String scheme, String principal, String ktab)\r\n+            throws Exception {\r\n+        MyHttpHandler h = new MyHttpHandler();\r\n+        HttpsServer server = HttpsServer.create(new InetSocketAddress(0), 0);\r\n+        server.setHttpsConfigurator(\r\n+                new HttpsConfigurator(new SimpleSSLContext().get()));\r\n+        server.createContext(\"\/\", h).setAuthenticator(\r\n+                new MyServerAuthenticator(scheme, principal, ktab));\r\n+        server.start();\r\n+        return server;\r\n+    }\r\n+\r\n+    static class MyHttpHandler implements HttpHandler {\r\n+        public void handle(HttpExchange t) throws IOException {\r\n+            t.sendResponseHeaders(200, 0);\r\n+            t.getResponseBody().write(CONTENT.getBytes());\r\n+            t.close();\r\n+        }\r\n+    }\r\n+\r\n+    static class MyServerAuthenticator\r\n+            extends com.sun.net.httpserver.Authenticator {\r\n+        Subject s = new Subject();\r\n+        GSSManager m;\r\n+        GSSCredential cred;\r\n+        String scheme = null;\r\n+        String reqHdr = \"WWW-Authenticate\";\r\n+        String respHdr = \"Authorization\";\r\n+        int err = HttpURLConnection.HTTP_UNAUTHORIZED;\r\n+\r\n+        public MyServerAuthenticator(String scheme,\r\n+                String principal, String ktab) throws Exception {\r\n+\r\n+            this.scheme = scheme;\r\n+            Krb5LoginModule krb5 = new Krb5LoginModule();\r\n+            Map<String, String> map = new HashMap<>();\r\n+            Map<String, Object> shared = new HashMap<>();\r\n+\r\n+            map.put(\"storeKey\", \"true\");\r\n+            map.put(\"isInitiator\", \"false\");\r\n+            map.put(\"useKeyTab\", \"true\");\r\n+            map.put(\"keyTab\", ktab);\r\n+            map.put(\"principal\", principal);\r\n+            krb5.initialize(s, null, shared, map);\r\n+            krb5.login();\r\n+            krb5.commit();\r\n+            m = GSSManager.getInstance();\r\n+            cred = Subject.callAs(s, new Callable<GSSCredential>() {\r\n+                @Override\r\n+                public GSSCredential call() throws Exception {\r\n+                    System.err.println(\"Creating GSSCredential\");\r\n+                    return m.createCredential(\r\n+                            null,\r\n+                            GSSCredential.INDEFINITE_LIFETIME,\r\n+                            MyServerAuthenticator.this.scheme\r\n+                                        .equalsIgnoreCase(\"Negotiate\") ?\r\n+                                    GSSUtil.GSS_SPNEGO_MECH_OID :\r\n+                                    GSSUtil.GSS_KRB5_MECH_OID,\r\n+                            GSSCredential.ACCEPT_ONLY);\r\n+                }\r\n+            });\r\n+        }\r\n+\r\n+        @Override\r\n+        public Result authenticate(HttpExchange exch) {\r\n+            \/\/ The GSContext is stored in an HttpContext attribute named\r\n+            \/\/ \"GSSContext\" and is created at the first request.\r\n+            GSSContext c = null;\r\n+            String auth = exch.getRequestHeaders().getFirst(respHdr);\r\n+            try {\r\n+                c = (GSSContext)exch.getHttpContext()\r\n+                        .getAttributes().get(\"GSSContext\");\r\n+                if (auth == null) {                 \/\/ First request\r\n+                    Headers map = exch.getResponseHeaders();\r\n+                    map.set (reqHdr, scheme);        \/\/ Challenge!\r\n+                    c = Subject.callAs(s, () -> m.createContext(cred));\r\n+                    \/\/ CBT is required for cbtURL\r\n+                    if (exch instanceof HttpsExchange sexch\r\n+                            && exch.getRequestURI().toString().equals(\"\/cbt\")) {\r\n+                        TlsChannelBinding b = TlsChannelBinding.create(\r\n+                                (X509Certificate) sexch.getSSLSession()\r\n+                                        .getLocalCertificates()[0]);\r\n+                        c.setChannelBinding(\r\n+                                new TlsChannelBindingImpl(b.getData()));\r\n+                    }\r\n+                    exch.getHttpContext().getAttributes().put(\"GSSContext\", c);\r\n+                    return new com.sun.net.httpserver.Authenticator.Retry(err);\r\n+                } else {                            \/\/ Later requests\r\n+                    byte[] token = Base64.getMimeDecoder()\r\n+                            .decode(auth.split(\" \")[1]);\r\n+                    token = c.acceptSecContext(token, 0, token.length);\r\n+                    Headers map = exch.getResponseHeaders();\r\n+                    map.set (reqHdr, scheme + \" \" + Base64.getMimeEncoder()\r\n+                            .encodeToString(token).replaceAll(\"\\\\s\", \"\"));\r\n+                    if (c.isEstablished()) {\r\n+                        return new com.sun.net.httpserver.Authenticator.Success(\r\n+                                new HttpPrincipal(c.getSrcName().toString(), \"\"));\r\n+                    } else {\r\n+                        return new com.sun.net.httpserver.Authenticator.Retry(err);\r\n+                    }\r\n+                }\r\n+            } catch (Exception e) {\r\n+                throw new RuntimeException(e);\r\n+            }\r\n+        }\r\n+    }\r\n+}\r\n","filename":"test\/jdk\/sun\/security\/krb5\/auto\/HttpsCB.java","additions":311,"deletions":0,"binary":false,"changes":311,"status":"added"}]}