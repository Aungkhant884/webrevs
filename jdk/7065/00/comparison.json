{"files":[{"patch":"@@ -147,0 +147,9 @@\n+    \/* \"jdk.spnego.cbt\" property can be set to \"always\" (always sent), \"never\" (never sent) or\n+     * \"domain:a,c.d,*.e.f\" (sent to host a, or c.d or to the domain e.f and any of its subdomains). This is\n+     * a comma separated list of arbitrary length with no white-space allowed.\n+     * If enabled (for a particular destination) then SPNEGO authentication requests will include\n+     * a channel binding token for the destination server. The default behavior and setting for the\n+     * property is \"never\"\n+     *\/\n+    private static final String spnegoCBT;\n+\n@@ -148,0 +157,1 @@\n+\n@@ -168,0 +178,9 @@\n+    static String normalizeCBT(String s) {\n+        if (s == null || ! (s.equals(\"always\") ||\n+                s.equals(\"never\") || s.startsWith(\"domain:\"))) {\n+            return \"never\";\n+        } else {\n+            return s;\n+        }\n+    }\n+\n@@ -175,0 +194,3 @@\n+        String s = props.getProperty(\"jdk.spnego.cbt\");\n+        spnegoCBT = normalizeCBT(s);\n+\n@@ -209,0 +231,4 @@\n+    public String getSpnegoCBT() {\n+        return spnegoCBT;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/http\/HttpClient.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.security.cert.X509Certificate;\n@@ -54,0 +55,3 @@\n+    \/\/ Used to obtain server cert for SPNEGO CBT.\n+    \/\/ May be null in which case CBT is not set\n+    public final X509Certificate serverCert;\n@@ -68,0 +72,1 @@\n+        this.serverCert =  old.serverCert;\n@@ -74,0 +79,4 @@\n+        this(url, null, a);\n+    }\n+\n+    public HttpCallerInfo(URL url, X509Certificate serverCert, Authenticator a) {\n@@ -75,0 +84,1 @@\n+        this.serverCert= serverCert;\n@@ -103,0 +113,4 @@\n+        this(url, host, port, null, a);\n+    }\n+\n+    public HttpCallerInfo(URL url, String host, int port, X509Certificate serverCert, Authenticator a) {\n@@ -106,0 +120,1 @@\n+        this.serverCert = serverCert;\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/http\/HttpCallerInfo.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1743,1 +1743,1 @@\n-                            new HttpCallerInfo(url,\n+                            getHttpCallerInfo(url,\n@@ -1818,1 +1818,1 @@\n-                            new HttpCallerInfo(url, authenticator),\n+                            getHttpCallerInfo(url, authenticator),\n@@ -2214,1 +2214,1 @@\n-                            new HttpCallerInfo(url,\n+                            getHttpCallerInfo(url,\n@@ -2283,0 +2283,15 @@\n+    \/**\n+     * Overridden in https to also include the server certificate\n+     *\/\n+    protected HttpCallerInfo getHttpCallerInfo(URL url, String proxy, int port,\n+                                               Authenticator authenticator) {\n+        return new HttpCallerInfo(url, proxy, port, authenticator);\n+    }\n+\n+    \/**\n+     * Overridden in https to also include the server certificate\n+     *\/\n+    protected HttpCallerInfo getHttpCallerInfo(URL url, Authenticator authenticator) {\n+        return new HttpCallerInfo(url, authenticator);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/http\/HttpURLConnection.java","additions":18,"deletions":3,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-\/*\n+\/**\n@@ -28,0 +28,1 @@\n+import java.net.Authenticator;\n@@ -32,0 +33,2 @@\n+import java.security.cert.Certificate;\n+import java.security.cert.X509Certificate;\n@@ -39,0 +42,1 @@\n+import sun.net.www.protocol.http.HttpCallerInfo;\n@@ -312,0 +316,67 @@\n+\n+    \/**\n+     * If no SSL Session available or if the system config does not allow it\n+     * don't use the extended caller info (the server cert).\n+     * Otherwise return true to include the server cert\n+     *\/\n+    private boolean useExtendedCallerInfo(URL url) {\n+        HttpsClient https = (HttpsClient)http;\n+        if (https.getSSLSession() == null) {\n+            return false;\n+        }\n+        String prop = http.getSpnegoCBT();\n+        if (prop.equals(\"never\")) {\n+            return false;\n+        }\n+        String target = url.getHost();\n+        if (prop.startsWith(\"domain:\")) {\n+            String[] domains = prop.substring(7).split(\",\");\n+            for (String domain : domains) {\n+                if (target.equals(domain)) {\n+                    return true;\n+                }\n+                if (domain.startsWith(\"*.\") && target.endsWith(domain.substring(1))) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    protected HttpCallerInfo getHttpCallerInfo(URL url, String proxy, int port,\n+                                               Authenticator authenticator)\n+    {\n+        if (!useExtendedCallerInfo(url)) {\n+            return super.getHttpCallerInfo(url, proxy, port, authenticator);\n+        }\n+        HttpsClient https = (HttpsClient)http;\n+        try {\n+            Certificate[] certs = https.getServerCertificates();\n+            if (certs[0] instanceof X509Certificate x509Cert) {\n+                return new HttpCallerInfo(url, proxy, port, x509Cert, authenticator);\n+            }\n+        } catch (SSLPeerUnverifiedException e) {\n+            \/\/ ignore\n+        }\n+        return super.getHttpCallerInfo(url, proxy, port, authenticator);\n+    }\n+\n+    @Override\n+    protected HttpCallerInfo getHttpCallerInfo(URL url, Authenticator authenticator)\n+    {\n+        if (!useExtendedCallerInfo(url)) {\n+            return super.getHttpCallerInfo(url, authenticator);\n+        }\n+        HttpsClient https = (HttpsClient)http;\n+        try {\n+            Certificate[] certs = https.getServerCertificates();\n+            if (certs[0] instanceof X509Certificate x509Cert) {\n+                return new HttpCallerInfo(url, x509Cert, authenticator);\n+            }\n+        } catch (SSLPeerUnverifiedException e) {\n+            \/\/ ignore\n+        }\n+        return super.getHttpCallerInfo(url, authenticator);\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/https\/AbstractDelegateHttpsURLConnection.java","additions":72,"deletions":1,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -130,0 +130,3 @@\n+    exports com.sun.jndi.ldap.sasl to\n+        java.security.jgss;\n+\n","filename":"src\/java.naming\/share\/classes\/module-info.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+    requires java.security.sasl;\n","filename":"src\/java.security.jgss\/share\/classes\/module-info.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import java.security.cert.Certificate;\n+import javax.security.sasl.SaslException;\n@@ -43,0 +45,2 @@\n+import sun.security.jgss.krb5.internal.TlsChannelBindingImpl;\n+import com.sun.jndi.ldap.sasl.TlsChannelBinding;\n@@ -68,1 +72,1 @@\n-    private void init(HttpCallerInfo hci) throws GSSException {\n+    private void init(HttpCallerInfo hci) throws GSSException, SaslException {\n@@ -103,0 +107,8 @@\n+        if (hci.serverCert != null) {\n+            if (DEBUG) {\n+                System.out.println(\"Negotiate: Setting CBT\");\n+            }\n+            \/\/ set the channel binding token\n+            TlsChannelBinding b = TlsChannelBinding.create(hci.serverCert);\n+            context.setChannelBinding(new TlsChannelBindingImpl(b.getData()));\n+        }\n@@ -113,1 +125,1 @@\n-        } catch (GSSException e) {\n+        } catch (GSSException | SaslException  e) {\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/net\/www\/protocol\/http\/spnego\/NegotiatorImpl.java","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"}]}