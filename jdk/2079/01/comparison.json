{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -125,0 +125,5 @@\n+  if (JNI_TRUE == sampleThreads) {\n+    JfrThreadSampling::enroll_thread_sampler();\n+  } else {\n+    JfrThreadSampling::disenroll_thread_sampler();\n+  }\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethod.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -648,0 +648,14 @@\n+\n+void JfrThreadSampling::enroll_thread_sampler() {\n+  if (_instance == NULL) {\n+    return;\n+  }\n+  instance()._sampler->enroll();\n+}\n+\n+void JfrThreadSampling::disenroll_thread_sampler() {\n+  if (_instance == NULL) {\n+    return;\n+  }\n+  instance()._sampler->disenroll();\n+}\n\\ No newline at end of file\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrThreadSampler.cpp","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,0 +53,2 @@\n+  static void enroll_thread_sampler();\n+  static void disenroll_thread_sampler();\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrThreadSampler.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2021, Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation. Alibaba designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *\/\n+\n+package jdk.jfr.startupargs;\n+\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.consumer.RecordingFile;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.jfr.EventNames;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+\/*\n+ * @test\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @modules jdk.jfr\/jdk.jfr.internal\n+ * @run main jdk.jfr.startupargs.TestSampleThreadsOption\n+ *\/\n+public class TestSampleThreadsOption {\n+    private static final String START_FLIGHT_RECORDING = \"-XX:StartFlightRecording\";\n+    private static final String FLIGHT_RECORDER_OPTIONS = \"-XX:FlightRecorderOptions\";\n+\n+    public static void main(String[] args) throws Throwable {\n+        String recording = START_FLIGHT_RECORDING + \"=filename=recording.jfr,dumponexit=true\";\n+\n+        \/\/ turn on\n+        List<RecordedEvent> events;\n+        events = testWithJFROption(FLIGHT_RECORDER_OPTIONS + \"=samplethreads=true\", recording, Main.class.getName());\n+        List<String> names = events.stream()\n+                .map(e -> e.getEventType().getName())\n+                .filter(eventName -> eventName.equals(EventNames.ExecutionSample) || eventName.equals(EventNames.NativeMethodSample))\n+                .collect(Collectors.toList());\n+        Asserts.assertTrue(names.size() != 0, \"must be\");\n+\n+        \/\/ turn off\n+        events = testWithJFROption(FLIGHT_RECORDER_OPTIONS + \"=samplethreads=false\", recording, Main.class.getName());\n+        names = events.stream()\n+                .map(e -> e.getEventType().getName())\n+                .filter(eventName -> eventName.equals(EventNames.ExecutionSample) || eventName.equals(EventNames.NativeMethodSample))\n+                .collect(Collectors.toList());\n+        Asserts.assertTrue(names.size() == 0, \"must be\");\n+\n+    }\n+\n+    private static List<RecordedEvent> testWithJFROption(String... options) throws Throwable {\n+        ProcessBuilder pb = ProcessTools.createTestJvm(options);\n+        OutputAnalyzer output = ProcessTools.executeProcess(pb);\n+        output.shouldHaveExitValue(0);\n+\n+        Path dumpPath = Paths.get(\".\", \"recording.jfr\");\n+        Asserts.assertTrue(Files.isRegularFile(dumpPath), \"No recording dumped \" + dumpPath);\n+        List<RecordedEvent> events = RecordingFile.readAllEvents(dumpPath);\n+        return events;\n+    }\n+\n+    private static class Main {\n+        public static void main(String... args) {\n+            for (int i = 0; i < 500000; i++) {\n+                System.out.println(new Object().hashCode() * new Object().hashCode());\n+            }\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/jdk\/jfr\/startupargs\/TestSampleThreadsOption.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"}]}