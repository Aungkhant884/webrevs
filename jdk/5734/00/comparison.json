{"files":[{"patch":"@@ -3279,1 +3279,0 @@\n-      register_new_survivor_region_with_region_attr(new_alloc_region);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -608,1 +608,0 @@\n-  inline void register_new_survivor_region_with_region_attr(HeapRegion* r);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -187,4 +187,0 @@\n-void G1CollectedHeap::register_new_survivor_region_with_region_attr(HeapRegion* r) {\n-  _region_attr.set_new_survivor_region(r->hrm_index());\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.inline.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"gc\/g1\/g1RedirtyCardsQueue.hpp\"\n@@ -40,0 +41,39 @@\n+class UpdateLogBuffersDeferred : public BasicOopIterateClosure {\n+private:\n+  G1CollectedHeap* _g1h;\n+  G1RedirtyCardsLocalQueueSet* _rdc_local_qset;\n+  G1CardTable*    _ct;\n+\n+  \/\/ Remember the last enqueued card to avoid enqueuing the same card over and over;\n+  \/\/ since we only ever handle a card once, this is sufficient.\n+  size_t _last_enqueued_card;\n+\n+public:\n+  UpdateLogBuffersDeferred(G1RedirtyCardsLocalQueueSet* rdc_local_qset) :\n+    _g1h(G1CollectedHeap::heap()),\n+    _rdc_local_qset(rdc_local_qset),\n+    _ct(_g1h->card_table()),\n+    _last_enqueued_card(SIZE_MAX) {}\n+\n+  virtual void do_oop(narrowOop* p) { do_oop_work(p); }\n+  virtual void do_oop(      oop* p) { do_oop_work(p); }\n+  template <class T> void do_oop_work(T* p) {\n+    assert(_g1h->heap_region_containing(p)->is_in_reserved(p), \"paranoia\");\n+    assert(!_g1h->heap_region_containing(p)->is_survivor(), \"Unexpected evac failure in survivor region\");\n+\n+    T const o = RawAccess<>::oop_load(p);\n+    if (CompressedOops::is_null(o)) {\n+      return;\n+    }\n+\n+    if (HeapRegion::is_in_same_region(p, CompressedOops::decode(o))) {\n+      return;\n+    }\n+    size_t card_index = _ct->index_for(p);\n+    if (card_index != _last_enqueued_card) {\n+      _rdc_local_qset->enqueue(_ct->byte_for_index(card_index));\n+      _last_enqueued_card = card_index;\n+    }\n+  }\n+};\n+\n@@ -45,0 +85,1 @@\n+  UpdateLogBuffersDeferred* _log_buffer_cl;\n@@ -51,0 +92,1 @@\n+                                 UpdateLogBuffersDeferred* log_buffer_cl,\n@@ -57,0 +99,1 @@\n+    _log_buffer_cl(log_buffer_cl),\n@@ -101,0 +144,14 @@\n+      \/\/ While we were processing RSet buffers during the collection,\n+      \/\/ we actually didn't scan any cards on the collection set,\n+      \/\/ since we didn't want to update remembered sets with entries\n+      \/\/ that point into the collection set, given that live objects\n+      \/\/ from the collection set are about to move and such entries\n+      \/\/ will be stale very soon.\n+      \/\/ This change also dealt with a reliability issue which\n+      \/\/ involved scanning a card in the collection set and coming\n+      \/\/ across an array that was being chunked and looking malformed.\n+      \/\/ The problem is that, if evacuation fails, we might have\n+      \/\/ remembered set entries missing given that we skipped cards on\n+      \/\/ the collection set. So, we'll recreate such entries now.\n+      obj->oop_iterate(_log_buffer_cl);\n+\n@@ -149,0 +206,3 @@\n+  G1RedirtyCardsLocalQueueSet _rdc_local_qset;\n+  UpdateLogBuffersDeferred _log_buffer_cl;\n+\n@@ -153,1 +213,2 @@\n-  RemoveSelfForwardPtrHRClosure(uint worker_id,\n+  RemoveSelfForwardPtrHRClosure(G1RedirtyCardsQueueSet* rdcqs,\n+                                uint worker_id,\n@@ -158,0 +219,2 @@\n+    _rdc_local_qset(rdcqs),\n+    _log_buffer_cl(&_rdc_local_qset),\n@@ -162,0 +225,4 @@\n+  ~RemoveSelfForwardPtrHRClosure() {\n+    _rdc_local_qset.flush();\n+  }\n+\n@@ -165,0 +232,1 @@\n+                                        &_log_buffer_cl,\n@@ -203,1 +271,2 @@\n-G1ParRemoveSelfForwardPtrsTask::G1ParRemoveSelfForwardPtrsTask(G1EvacFailureRegions* evac_failure_regions) :\n+G1ParRemoveSelfForwardPtrsTask::G1ParRemoveSelfForwardPtrsTask(G1RedirtyCardsQueueSet* rdcqs,\n+                                                               G1EvacFailureRegions* evac_failure_regions) :\n@@ -206,0 +275,1 @@\n+  _rdcqs(rdcqs),\n@@ -211,1 +281,1 @@\n-  RemoveSelfForwardPtrHRClosure rsfp_cl(worker_id, &_num_failed_regions, _evac_failure_regions);\n+  RemoveSelfForwardPtrHRClosure rsfp_cl(_rdcqs, worker_id, &_num_failed_regions, _evac_failure_regions);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailure.cpp","additions":73,"deletions":3,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+class G1RedirtyCardsQueueSet;\n@@ -41,0 +42,1 @@\n+  G1RedirtyCardsQueueSet* _rdcqs;\n@@ -47,1 +49,1 @@\n-  G1ParRemoveSelfForwardPtrsTask(G1EvacFailureRegions* evac_failure_regions);\n+  G1ParRemoveSelfForwardPtrsTask(G1RedirtyCardsQueueSet* rdcqs, G1EvacFailureRegions* evac_failure_regions);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailure.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -60,3 +60,2 @@\n-  static const region_type_t Optional     =  -4;    \/\/ The region is optional not in the current collection set.\n-  static const region_type_t Humongous    =  -3;    \/\/ The region is a humongous candidate not in the current collection set.\n-  static const region_type_t NewSurvivor  =  -2;    \/\/ The region is a new (ly allocated) survivor region.\n+  static const region_type_t Optional     =  -3;    \/\/ The region is optional not in the current collection set.\n+  static const region_type_t Humongous    =  -2;    \/\/ The region is a humongous candidate not in the current collection set.\n@@ -80,1 +79,0 @@\n-      case NewSurvivor: return \"NewSurvivor\";\n@@ -90,1 +88,0 @@\n-  void set_new_survivor()              { _type = NewSurvivor; }\n@@ -102,1 +99,0 @@\n-  bool is_new_survivor() const         { return type() == NewSurvivor; }\n@@ -135,6 +131,0 @@\n-  void set_new_survivor_region(uintptr_t index) {\n-    assert(get_by_index(index).is_default(),\n-           \"Region attributes at index \" INTPTR_FORMAT \" should be default but is %s\", index, get_by_index(index).get_type_str());\n-    get_ref_by_index(index)->set_new_survivor();\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionAttr.hpp","additions":2,"deletions":12,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -119,1 +119,1 @@\n-  G1SkipCardEnqueueSetter(G1ScanEvacuatedObjClosure* closure, bool skip_card_enqueue) : _closure(closure) {\n+  G1SkipCardEnqueueSetter(G1ScanEvacuatedObjClosure* closure, bool new_value) : _closure(closure) {\n@@ -121,1 +121,1 @@\n-    _closure->_skip_card_enqueue = skip_card_enqueue ? G1ScanEvacuatedObjClosure::True : G1ScanEvacuatedObjClosure::False;\n+    _closure->_skip_card_enqueue = new_value ? G1ScanEvacuatedObjClosure::True : G1ScanEvacuatedObjClosure::False;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1OopClosures.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -238,2 +238,2 @@\n-  G1HeapRegionAttr dest_attr = _g1h->region_attr(to_array);\n-  G1SkipCardEnqueueSetter x(&_scanner, dest_attr.is_new_survivor());\n+  HeapRegion* hr = _g1h->heap_region_containing(to_array);\n+  G1SkipCardEnqueueSetter x(&_scanner, hr->is_young());\n@@ -271,5 +271,0 @@\n-  \/\/ Skip the card enqueue iff the object (to_array) is in survivor region.\n-  \/\/ However, HeapRegion::is_survivor() is too expensive here.\n-  \/\/ Instead, we use dest_attr.is_young() because the two values are always\n-  \/\/ equal: successfully allocated young regions must be survivor regions.\n-  assert(dest_attr.is_young() == _g1h->heap_region_containing(to_array)->is_survivor(), \"must be\");\n@@ -527,5 +522,0 @@\n-    \/\/ Skip the card enqueue iff the object (obj) is in survivor region.\n-    \/\/ However, HeapRegion::is_survivor() is too expensive here.\n-    \/\/ Instead, we use dest_attr.is_young() because the two values are always\n-    \/\/ equal: successfully allocated young regions must be survivor regions.\n-    assert(dest_attr.is_young() == _g1h->heap_region_containing(obj)->is_survivor(), \"must be\");\n@@ -618,8 +608,1 @@\n-    \/\/ For iterating objects that failed evacuation currently we can reuse the\n-    \/\/ existing closure to scan evacuated objects because:\n-    \/\/ - for objects referring into the collection set we do not need to gather\n-    \/\/ cards at this time. The regions they are in will be unconditionally turned\n-    \/\/ to old regions without remembered sets.\n-    \/\/ - since we are iterating from a collection set region (i.e. never a Survivor\n-    \/\/ region), we always need to gather cards for this case.\n-    G1SkipCardEnqueueSetter x(&_scanner, false \/* skip_card_enqueue *\/);\n+    G1SkipCardEnqueueSetter x(&_scanner, r->is_young());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":3,"deletions":20,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -137,1 +137,1 @@\n-  \/\/ p and q are in the same region, p is in survivor, p is in collection set)\n+  \/\/ p and q are in the same region, p is in survivor)\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -100,1 +100,1 @@\n-  assert(obj != nullptr, \"Must be\");\n+  assert(obj != NULL, \"Must be\");\n@@ -104,14 +104,3 @@\n-  G1HeapRegionAttr from_attr = _g1h->region_attr(p);\n-  \/\/ If this is a reference from (current) survivor regions, we do not need\n-  \/\/ to track references from it.\n-  if (from_attr.is_new_survivor()) {\n-    return;\n-  }\n-  G1HeapRegionAttr dest_attr = _g1h->region_attr(obj);\n-  \/\/ References to the current collection set are references to objects that failed\n-  \/\/ evacuation. Currently these regions are always relabelled as old without\n-  \/\/ remembered sets, so skip them.\n-  assert(dest_attr.is_in_cset() == (obj->forwardee() == obj),\n-         \"Only evac-failed objects must be in the collection set here but \" PTR_FORMAT \" is not\", p2i(obj));\n-  if (dest_attr.is_in_cset()) {\n-    return;\n+  HeapRegion* from = _g1h->heap_region_containing(p);\n+  if (!from->is_young()) {\n+    enqueue_card_if_tracked(_g1h->region_attr(obj), p, obj);\n@@ -119,1 +108,0 @@\n-  enqueue_card_if_tracked(dest_attr, p, obj);\n@@ -124,4 +112,1 @@\n-  assert(!_g1h->heap_region_containing(p)->is_survivor(), \"Should have filtered out from-newly allocated survivor references already.\");\n-  \/\/ We relabel all regions that failed evacuation as old gen without remembered,\n-  \/\/ and so pre-filter them out in the caller.\n-  assert(!_g1h->heap_region_containing(o)->in_collection_set(), \"Should not try to enqueue reference into collection set region\");\n+  assert(!_g1h->heap_region_containing(p)->is_young(), \"Should have filtered out from-young references already.\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.inline.hpp","additions":5,"deletions":20,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"classfile\/javaClasses.inline.hpp\"\n@@ -915,27 +914,0 @@\n-  \/\/ Special closure for enqueuing discovered fields: during enqueue the card table\n-  \/\/ may not be in shape to properly handle normal barrier calls (e.g. card marks\n-  \/\/ in regions that failed evacuation, scribbling of various values by card table\n-  \/\/ scan code). Additionally the regular barrier enqueues into the \"global\"\n-  \/\/ DCQS, but during GC we need these to-be-refined entries in the GC local queue\n-  \/\/ so that after clearing the card table, the redirty cards phase will properly\n-  \/\/ mark all dirty cards to be picked up by refinement.\n-  class G1EnqueueDiscoveredFieldClosure : public EnqueueDiscoveredFieldClosure {\n-    G1CollectedHeap* _g1h;\n-    G1ParScanThreadState* _pss;\n-\n-  public:\n-    G1EnqueueDiscoveredFieldClosure(G1CollectedHeap* g1h, G1ParScanThreadState* pss) : _g1h(g1h), _pss(pss) { }\n-\n-    void enqueue(oop reference, oop value) override {\n-      HeapWord* discovered_addr = java_lang_ref_Reference::discovered_addr_raw(reference);\n-\n-      \/\/ Store the value first, whatever it is.\n-      RawAccess<>::oop_store(discovered_addr, value);\n-\n-      if (value == nullptr) {\n-        return;\n-      }\n-      _pss->write_ref_field_post(discovered_addr, value);\n-    }\n-  };\n-\n@@ -959,1 +931,1 @@\n-    G1EnqueueDiscoveredFieldClosure enqueue(&_g1h, pss);\n+    BarrierEnqueueDiscoveredFieldClosure enqueue;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.cpp","additions":1,"deletions":29,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -145,0 +145,1 @@\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -105,1 +105,1 @@\n-  RemoveSelfForwardPtrsTask(G1EvacFailureRegions* evac_failure_regions) :\n+  RemoveSelfForwardPtrsTask(G1RedirtyCardsQueueSet* rdcqs, G1EvacFailureRegions* evac_failure_regions) :\n@@ -107,1 +107,1 @@\n-    _task(evac_failure_regions),\n+    _task(rdcqs, evac_failure_regions),\n@@ -138,1 +138,1 @@\n-    add_parallel_task(new RemoveSelfForwardPtrsTask(evac_failure_regions));\n+    add_parallel_task(new RemoveSelfForwardPtrsTask(per_thread_states->rdcqs(), evac_failure_regions));\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+class G1RedirtyCardsQueueSet;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}