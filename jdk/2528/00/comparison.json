{"files":[{"patch":"@@ -3075,1 +3075,0 @@\n-#endif \/\/ COMPILER2\n@@ -3085,0 +3084,4 @@\n+\n+  int _frame_complete;\n+  int _framesize;\n+  OopMapSet* _oop_maps;\n@@ -3095,1 +3098,4 @@\n-     _output_registers(output_registers) {}\n+     _output_registers(output_registers),\n+     _frame_complete(0),\n+     _framesize(0),\n+     _oop_maps(NULL) {}\n@@ -3098,0 +3104,74 @@\n+  int spill_size_in_bytes() const {\n+    if (_output_registers.length() == 0) {\n+      return 0;\n+    }\n+    VMReg reg = _output_registers.at(0);\n+    assert(reg->is_reg(), \"must be a register\");\n+    if (reg->is_Register()) {\n+      return 8;\n+    } else if (reg->is_FloatRegister()) {\n+      bool use_sve = Matcher::supports_scalable_vector();\n+      if (use_sve) {\n+        return Matcher::scalable_vector_reg_size(T_BYTE);\n+      }\n+      return 16;\n+    } else {\n+      ShouldNotReachHere();\n+    }\n+    return 0;\n+  }\n+\n+  void spill_register() {\n+    if (_output_registers.length() == 0) {\n+      return;\n+    }\n+    VMReg reg = _output_registers.at(0);\n+    assert(reg->is_reg(), \"must be a register\");\n+    MacroAssembler* masm = _masm;\n+    if (reg->is_Register()) {\n+      __ spill(reg->as_Register(), true, 0);\n+    } else if (reg->is_FloatRegister()) {\n+      bool use_sve = Matcher::supports_scalable_vector();\n+      if (use_sve) {\n+        __ spill_sve_vector(reg->as_FloatRegister(), 0, Matcher::scalable_vector_reg_size(T_BYTE));\n+      } else {\n+        __ spill(reg->as_FloatRegister(), __ Q, 0);\n+      }\n+    } else {\n+      ShouldNotReachHere();\n+    }\n+  }\n+\n+  void fill_register() {\n+    if (_output_registers.length() == 0) {\n+      return;\n+    }\n+    VMReg reg = _output_registers.at(0);\n+    assert(reg->is_reg(), \"must be a register\");\n+    MacroAssembler* masm = _masm;\n+    if (reg->is_Register()) {\n+      __ unspill(reg->as_Register(), true, 0);\n+    } else if (reg->is_FloatRegister()) {\n+      bool use_sve = Matcher::supports_scalable_vector();\n+      if (use_sve) {\n+        __ unspill_sve_vector(reg->as_FloatRegister(), 0, Matcher::scalable_vector_reg_size(T_BYTE));\n+      } else {\n+        __ unspill(reg->as_FloatRegister(), __ Q, 0);\n+      }\n+    } else {\n+      ShouldNotReachHere();\n+    }\n+  }\n+\n+  int frame_complete() const {\n+    return _frame_complete;\n+  }\n+\n+  int framesize() const {\n+    return (_framesize >> (LogBytesPerWord - LogBytesPerInt));\n+  }\n+\n+  OopMapSet* oop_maps() const {\n+    return _oop_maps;\n+  }\n+\n@@ -3108,10 +3188,6 @@\n-BufferBlob* SharedRuntime::make_native_invoker(address call_target,\n-                                               int shadow_space_bytes,\n-                                               const GrowableArray<VMReg>& input_registers,\n-                                               const GrowableArray<VMReg>& output_registers) {\n-  BufferBlob* _invoke_native_blob =\n-    BufferBlob::create(\"nep_invoker_blob\", native_invoker_code_size);\n-  if (_invoke_native_blob == NULL)\n-    return NULL; \/\/ allocation failure\n-\n-  CodeBuffer code(_invoke_native_blob);\n+RuntimeStub* SharedRuntime::make_native_invoker(address call_target,\n+                                                int shadow_space_bytes,\n+                                                const GrowableArray<VMReg>& input_registers,\n+                                                const GrowableArray<VMReg>& output_registers) {\n+  int locs_size  = 64;\n+  CodeBuffer code(\"nep_invoker_blob\", native_invoker_code_size, locs_size);\n@@ -3122,1 +3198,7 @@\n-  return _invoke_native_blob;\n+  RuntimeStub* stub =\n+    RuntimeStub::new_runtime_stub(\"nep_invoker_blob\",\n+                                  &code,\n+                                  g.frame_complete(),\n+                                  g.framesize(),\n+                                  g.oop_maps(), false);\n+  return stub;\n@@ -3131,0 +3213,13 @@\n+  enum layout {\n+    rbp_off,\n+    rbp_off2,\n+    return_off,\n+    return_off2,\n+    framesize \/\/ inclusive of return address\n+  };\n+\n+  assert(_shadow_space_bytes == 0, \"not expecting shadow space on AArch64\");\n+  _framesize = align_up(framesize + (spill_size_in_bytes() >> LogBytesPerInt), 4);\n+  assert(is_even(_framesize\/2), \"sp not 16-byte aligned\");\n+\n+  _oop_maps  = new OopMapSet();\n@@ -3133,1 +3228,1 @@\n-  __ set_last_Java_frame(sp, noreg, lr, rscratch1);\n+  address start = __ pc();\n@@ -3137,6 +3232,9 @@\n-  \/\/ Store a pointer to the previous R29 (RFP) saved on the stack as it\n-  \/\/ may contain an oop if PreserveFramePointer is off. This value is\n-  \/\/ retrieved later by frame::sender_for_entry_frame() when the stack\n-  \/\/ is walked.\n-  __ mov(rscratch1, sp);\n-  __ str(rscratch1, Address(rthread, JavaThread::saved_fp_address_offset()));\n+  \/\/ lr and fp are already in place\n+  __ sub(sp, rfp, ((unsigned)_framesize-4) << LogBytesPerInt); \/\/ prolog\n+\n+  _frame_complete = __ pc() - start;\n+\n+  address the_pc = __ pc();\n+  __ set_last_Java_frame(sp, rfp, the_pc, rscratch1);\n+  OopMap* map = new OopMap(_framesize, 0);\n+  _oop_maps->add_gc_map(the_pc - start, map);\n@@ -3149,2 +3247,0 @@\n-  assert(_shadow_space_bytes == 0, \"not expecting shadow space on AArch64\");\n-\n@@ -3196,13 +3292,1 @@\n-  RegSet spills;\n-  FloatRegSet fp_spills;\n-  for (int i = 0; i < _output_registers.length(); i++) {\n-    VMReg output = _output_registers.at(i);\n-    if (output->is_Register()) {\n-      spills += RegSet::of(output->as_Register());\n-    } else if (output->is_FloatRegister()) {\n-      fp_spills += FloatRegSet::of(output->as_FloatRegister());\n-    }\n-  }\n-\n-  __ push(spills, sp);\n-  __ push_fp(fp_spills, sp);\n+  spill_register();\n@@ -3215,2 +3299,1 @@\n-  __ pop_fp(fp_spills, sp);\n-  __ pop(spills, sp);\n+  fill_register();\n@@ -3226,2 +3309,1 @@\n-  __ push(spills, sp);\n-  __ push_fp(fp_spills, sp);\n+  spill_register();\n@@ -3231,2 +3313,1 @@\n-  __ pop_fp(fp_spills, sp);\n-  __ pop(spills, sp);\n+  fill_register();\n@@ -3242,0 +3323,1 @@\n+#endif \/\/ COMPILER2\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":123,"deletions":41,"binary":false,"changes":164,"status":"modified"},{"patch":"@@ -1901,4 +1901,5 @@\n-BufferBlob* SharedRuntime::make_native_invoker(address call_target,\n-                                               int shadow_space_bytes,\n-                                               const GrowableArray<VMReg>& input_registers,\n-                                               const GrowableArray<VMReg>& output_registers) {\n+#ifdef COMPILER2\n+RuntimeStub* SharedRuntime::make_native_invoker(address call_target,\n+                                                int shadow_space_bytes,\n+                                                const GrowableArray<VMReg>& input_registers,\n+                                                const GrowableArray<VMReg>& output_registers) {\n@@ -1908,0 +1909,1 @@\n+#endif\n","filename":"src\/hotspot\/cpu\/arm\/sharedRuntime_arm.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -3445,4 +3445,5 @@\n-BufferBlob* SharedRuntime::make_native_invoker(address call_target,\n-                                               int shadow_space_bytes,\n-                                               const GrowableArray<VMReg>& input_registers,\n-                                               const GrowableArray<VMReg>& output_registers) {\n+#ifdef COMPILER2\n+RuntimeStub* SharedRuntime::make_native_invoker(address call_target,\n+                                                int shadow_space_bytes,\n+                                                const GrowableArray<VMReg>& input_registers,\n+                                                const GrowableArray<VMReg>& output_registers) {\n@@ -3452,0 +3453,1 @@\n+#endif\n","filename":"src\/hotspot\/cpu\/ppc\/sharedRuntime_ppc.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -3471,4 +3471,5 @@\n-BufferBlob* SharedRuntime::make_native_invoker(address call_target,\n-                                               int shadow_space_bytes,\n-                                               const GrowableArray<VMReg>& input_registers,\n-                                               const GrowableArray<VMReg>& output_registers) {\n+#ifdef COMPILER2\n+RuntimeStub* SharedRuntime::make_native_invoker(address call_target,\n+                                                int shadow_space_bytes,\n+                                                const GrowableArray<VMReg>& input_registers,\n+                                                const GrowableArray<VMReg>& output_registers) {\n@@ -3478,0 +3479,1 @@\n+#endif\n","filename":"src\/hotspot\/cpu\/s390\/sharedRuntime_s390.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2983,1 +2983,2 @@\n-BufferBlob* SharedRuntime::make_native_invoker(address call_target,\n+#ifdef COMPILER2\n+RuntimeStub* SharedRuntime::make_native_invoker(address call_target,\n@@ -2990,0 +2991,1 @@\n+#endif\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_32.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3162,2 +3162,0 @@\n-#endif \/\/ COMPILER2\n-\n@@ -3421,0 +3419,4 @@\n+\n+  int _frame_complete;\n+  int _framesize;\n+  OopMapSet* _oop_maps;\n@@ -3431,1 +3433,4 @@\n-     _output_registers(output_registers) {}\n+     _output_registers(output_registers),\n+     _frame_complete(0),\n+     _framesize(0),\n+     _oop_maps(NULL) {}\n@@ -3434,1 +3439,27 @@\n-  void spill_register(VMReg reg) {\n+  int spill_size_in_bytes() const {\n+    if (_output_registers.length() == 0) {\n+      return 0;\n+    }\n+    VMReg reg = _output_registers.at(0);\n+    assert(reg->is_reg(), \"must be a register\");\n+    if (reg->is_Register()) {\n+      return 8;\n+    } else if (reg->is_XMMRegister()) {\n+      if (UseAVX >= 3) {\n+        return 64;\n+      } else if (UseAVX >= 1) {\n+        return 32;\n+      } else {\n+        return 16;\n+      }\n+    } else {\n+      ShouldNotReachHere();\n+    }\n+    return 0;\n+  }\n+\n+  void spill_register() {\n+    if (_output_registers.length() == 0) {\n+      return;\n+    }\n+    VMReg reg = _output_registers.at(0);\n@@ -3438,1 +3469,1 @@\n-      __ push(reg->as_Register());\n+      __ movptr(Address(rsp, 0), reg->as_Register());\n@@ -3441,1 +3472,0 @@\n-        __ subptr(rsp, 64); \/\/ bytes\n@@ -3444,1 +3474,0 @@\n-        __ subptr(rsp, 32);\n@@ -3447,1 +3476,0 @@\n-        __ subptr(rsp, 16);\n@@ -3455,1 +3483,5 @@\n-  void fill_register(VMReg reg) {\n+  void fill_register() {\n+    if (_output_registers.length() == 0) {\n+      return;\n+    }\n+    VMReg reg = _output_registers.at(0);\n@@ -3459,1 +3491,1 @@\n-      __ pop(reg->as_Register());\n+      __ movptr(reg->as_Register(), Address(rsp, 0));\n@@ -3463,1 +3495,0 @@\n-        __ addptr(rsp, 64); \/\/ bytes\n@@ -3466,1 +3497,0 @@\n-        __ addptr(rsp, 32);\n@@ -3469,1 +3499,0 @@\n-        __ addptr(rsp, 16);\n@@ -3476,0 +3505,12 @@\n+  int frame_complete() const {\n+    return _frame_complete;\n+  }\n+\n+  int framesize() const {\n+    return (_framesize >> (LogBytesPerWord - LogBytesPerInt));\n+  }\n+\n+  OopMapSet* oop_maps() const {\n+    return _oop_maps;\n+  }\n+\n@@ -3484,9 +3525,6 @@\n-BufferBlob* SharedRuntime::make_native_invoker(address call_target,\n-                                               int shadow_space_bytes,\n-                                               const GrowableArray<VMReg>& input_registers,\n-                                               const GrowableArray<VMReg>& output_registers) {\n-  BufferBlob* _invoke_native_blob = BufferBlob::create(\"nep_invoker_blob\", native_invoker_code_size);\n-  if (_invoke_native_blob == NULL)\n-    return NULL; \/\/ allocation failure\n-\n-  CodeBuffer code(_invoke_native_blob);\n+RuntimeStub* SharedRuntime::make_native_invoker(address call_target,\n+                                                int shadow_space_bytes,\n+                                                const GrowableArray<VMReg>& input_registers,\n+                                                const GrowableArray<VMReg>& output_registers) {\n+  int locs_size  = 64;\n+  CodeBuffer code(\"nep_invoker_blob\", native_invoker_code_size, locs_size);\n@@ -3497,1 +3535,7 @@\n-  return _invoke_native_blob;\n+  RuntimeStub* stub =\n+    RuntimeStub::new_runtime_stub(\"nep_invoker_blob\",\n+                                  &code,\n+                                  g.frame_complete(),\n+                                  g.framesize(),\n+                                  g.oop_maps(), false);\n+  return stub;\n@@ -3503,0 +3547,12 @@\n+  enum layout {\n+    rbp_off,\n+    rbp_off2,\n+    return_off,\n+    return_off2,\n+    framesize \/\/ inclusive of return address\n+  };\n+\n+  _framesize = align_up(framesize + ((_shadow_space_bytes + spill_size_in_bytes()) >> LogBytesPerInt), 4);\n+  assert(is_even(_framesize\/2), \"sp not 16-byte aligned\");\n+\n+  _oop_maps  = new OopMapSet();\n@@ -3504,0 +3560,3 @@\n+\n+  address start = __ pc();\n+\n@@ -3506,3 +3565,2 @@\n-  Address java_pc(r15_thread, JavaThread::last_Java_pc_offset());\n-  __ movptr(rscratch1, Address(rsp, 8)); \/\/ read return address from stack\n-  __ movptr(java_pc, rscratch1);\n+  \/\/ return address and rbp are already in place\n+  __ subptr(rsp, (_framesize-4) << LogBytesPerInt); \/\/ prolog\n@@ -3510,3 +3568,1 @@\n-  __ movptr(rscratch1, rsp);\n-  __ addptr(rscratch1, 16); \/\/ skip return and frame\n-  __ movptr(Address(r15_thread, JavaThread::last_Java_sp_offset()), rscratch1);\n+  _frame_complete = __ pc() - start;\n@@ -3514,1 +3570,1 @@\n-  __ movptr(Address(r15_thread, JavaThread::saved_rbp_address_offset()), rsp); \/\/ rsp points at saved RBP\n+  address the_pc = __ pc();\n@@ -3516,2 +3572,3 @@\n-    \/\/ State transition\n-  __ movl(Address(r15_thread, JavaThread::thread_state_offset()), _thread_in_native);\n+  __ set_last_Java_frame(rsp, rbp, (address)the_pc);\n+  OopMap* map = new OopMap(_framesize, 0);\n+  _oop_maps->add_gc_map(the_pc - start, map);\n@@ -3519,4 +3576,2 @@\n-  if (_shadow_space_bytes != 0) {\n-    \/\/ needed here for correct stack args offset on Windows\n-    __ subptr(rsp, _shadow_space_bytes);\n-  }\n+  \/\/ State transition\n+  __ movl(Address(r15_thread, JavaThread::thread_state_offset()), _thread_in_native);\n@@ -3526,5 +3581,0 @@\n-  if (_shadow_space_bytes != 0) {\n-    \/\/ needed here for correct stack args offset on Windows\n-    __ addptr(rsp, _shadow_space_bytes);\n-  }\n-\n@@ -3533,2 +3583,0 @@\n-  bool need_spills = _output_registers.length() != 0;\n-  VMReg ret_reg = need_spills ? _output_registers.at(0) : VMRegImpl::Bad();\n@@ -3575,3 +3623,1 @@\n-  if (need_spills) {\n-    spill_register(ret_reg);\n-  }\n+  spill_register();\n@@ -3587,3 +3633,1 @@\n-  if (need_spills) {\n-    fill_register(ret_reg);\n-  }\n+  fill_register();\n@@ -3600,3 +3644,1 @@\n-  if (need_spills) {\n-    spill_register(ret_reg);\n-  }\n+  spill_register();\n@@ -3611,3 +3653,1 @@\n-  if (need_spills) {\n-    fill_register(ret_reg);\n-  }\n+  fill_register();\n@@ -3623,0 +3663,1 @@\n+#endif \/\/ COMPILER2\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":96,"deletions":55,"binary":false,"changes":151,"status":"modified"},{"patch":"@@ -960,1 +960,1 @@\n-                            const GrowableArrayView<BufferBlob*>& native_invokers) {\n+                            const GrowableArrayView<RuntimeStub*>& native_invokers) {\n","filename":"src\/hotspot\/share\/ci\/ciEnv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -383,1 +383,1 @@\n-                       const GrowableArrayView<BufferBlob*>& native_invokers = GrowableArrayView<BufferBlob*>::EMPTY);\n+                       const GrowableArrayView<RuntimeStub*>& native_invokers = GrowableArrayView<RuntimeStub*>::EMPTY);\n","filename":"src\/hotspot\/share\/ci\/ciEnv.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -504,1 +504,1 @@\n-  const GrowableArrayView<BufferBlob*>& native_invokers\n+  const GrowableArrayView<RuntimeStub*>& native_invokers\n@@ -729,1 +729,1 @@\n-  const GrowableArrayView<BufferBlob*>& native_invokers\n+  const GrowableArrayView<RuntimeStub*>& native_invokers\n@@ -1060,1 +1060,1 @@\n-  for (BufferBlob** it = native_invokers_begin(); it < native_invokers_end(); it++) {\n+  for (RuntimeStub** it = native_invokers_begin(); it < native_invokers_end(); it++) {\n@@ -2699,1 +2699,1 @@\n-  for (BufferBlob** itt = native_invokers_begin(); itt < native_invokers_end(); itt++) {\n+  for (RuntimeStub** itt = native_invokers_begin(); itt < native_invokers_end(); itt++) {\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -317,1 +317,1 @@\n-          const GrowableArrayView<BufferBlob*>& native_invokers\n+          const GrowableArrayView<RuntimeStub*>& native_invokers\n@@ -366,1 +366,1 @@\n-                              const GrowableArrayView<BufferBlob*>& native_invokers = GrowableArrayView<BufferBlob*>::EMPTY\n+                              const GrowableArrayView<RuntimeStub*>& native_invokers = GrowableArrayView<RuntimeStub*>::EMPTY\n@@ -416,2 +416,2 @@\n-  BufferBlob** native_invokers_begin() const         { return (BufferBlob**)(header_begin() + _native_invokers_offset) ; }\n-  BufferBlob** native_invokers_end  () const         { return (BufferBlob**)(header_begin() + _handler_table_offset); }\n+  RuntimeStub** native_invokers_begin() const     { return (RuntimeStub**)(header_begin() + _native_invokers_offset) ; }\n+  RuntimeStub** native_invokers_end  () const     { return (RuntimeStub**)(header_begin() + _handler_table_offset); }\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1630,1 +1630,1 @@\n-                                 compiler, comp_level, GrowableArrayView<BufferBlob*>::EMPTY,\n+                                 compiler, comp_level, GrowableArrayView<RuntimeStub*>::EMPTY,\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4793,1 +4793,1 @@\n-void Compile::add_native_invoker(BufferBlob* stub) {\n+void Compile::add_native_invoker(RuntimeStub* stub) {\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -391,1 +391,1 @@\n-  GrowableArray<BufferBlob*>    _native_invokers;\n+  GrowableArray<RuntimeStub*>   _native_invokers;\n@@ -954,1 +954,1 @@\n-  void add_native_invoker(BufferBlob* stub);\n+  void add_native_invoker(RuntimeStub* stub);\n@@ -956,1 +956,1 @@\n-  const GrowableArray<BufferBlob*>& native_invokers() const { return _native_invokers; }\n+  const GrowableArray<RuntimeStub*> native_invokers() const { return _native_invokers; }\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2635,3 +2635,3 @@\n-    BufferBlob* invoker = SharedRuntime::make_native_invoker(call_addr,\n-                                                             nep->shadow_space(),\n-                                                             arg_regs, ret_regs);\n+    RuntimeStub* invoker = SharedRuntime::make_native_invoker(call_addr,\n+                                                              nep->shadow_space(),\n+                                                              arg_regs, ret_regs);\n","filename":"src\/hotspot\/share\/opto\/graphKit.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -520,4 +520,6 @@\n-  static BufferBlob* make_native_invoker(address call_target,\n-                                         int shadow_space_bytes,\n-                                         const GrowableArray<VMReg>& input_registers,\n-                                         const GrowableArray<VMReg>& output_registers);\n+#ifdef COMPILER2\n+  static RuntimeStub* make_native_invoker(address call_target,\n+                                          int shadow_space_bytes,\n+                                          const GrowableArray<VMReg>& input_registers,\n+                                          const GrowableArray<VMReg>& output_registers);\n+#endif\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,78 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8259937\n+ * @summary guarantee(loc != NULL) failed: missing saved register with native invoke\n+ *\n+ * @requires vm.flavor == \"server\"\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @requires vm.gc.Shenandoah\n+ *\n+ * @modules jdk.incubator.foreign\n+ *\n+ * @run main\/othervm -Dforeign.restricted=permit -XX:+UseShenandoahGC -XX:ShenandoahGCHeuristics=aggressive TestLinkToNativeRBP\n+ *\n+ *\/\n+\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.LibraryLookup;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+\n+import static jdk.incubator.foreign.CLinker.C_INT;\n+\n+public class TestLinkToNativeRBP {\n+    final static CLinker abi = CLinker.getInstance();\n+    static final LibraryLookup lookup = LibraryLookup.ofDefault();\n+    final static MethodHandle rand = abi.downcallHandle(lookup.lookup(\"rand\").get(),\n+            MethodType.methodType(int.class),\n+            FunctionDescriptor.of(C_INT));\n+\n+    static int rand() throws Throwable {\n+        return (int)rand.invokeExact();\n+    }\n+    public static void main(String[] args) throws Throwable {\n+        for (int i = 0; i < 20_000; i++) {\n+            test(5);\n+        }\n+        for (int i = 0; i < 100; i++) {\n+            test(1_000_000);\n+        }\n+    }\n+\n+    static volatile Integer field = 0;\n+\n+    private static int test(int stop) throws Throwable {\n+        int res = 0;\n+        for (int i = 0; i < stop; i++) {\n+            Integer v = field;\n+            res = rand() + v.intValue();\n+        }\n+        return res;\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/compiler\/TestLinkToNativeRBP.java","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"}]}