{"files":[{"patch":"@@ -2,0 +2,1 @@\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +60,1 @@\n-  virtual Name kind() const {\n+  Name kind() const override {\n@@ -63,1 +64,1 @@\n-  virtual const char* name() const {\n+  const char* name() const override {\n@@ -67,1 +68,1 @@\n-  virtual SoftRefPolicy* soft_ref_policy() {\n+  SoftRefPolicy* soft_ref_policy() override {\n@@ -71,2 +72,2 @@\n-  virtual jint initialize();\n-  virtual void initialize_serviceability();\n+  jint initialize() override;\n+  void initialize_serviceability() override;\n@@ -74,2 +75,2 @@\n-  virtual GrowableArray<GCMemoryManager*> memory_managers();\n-  virtual GrowableArray<MemoryPool*> memory_pools();\n+  GrowableArray<GCMemoryManager*> memory_managers() override;\n+  GrowableArray<MemoryPool*> memory_pools() override;\n@@ -77,3 +78,3 @@\n-  virtual size_t max_capacity() const { return _virtual_space.reserved_size();  }\n-  virtual size_t capacity()     const { return _virtual_space.committed_size(); }\n-  virtual size_t used()         const { return _space->used(); }\n+  size_t max_capacity() const override { return _virtual_space.reserved_size();  }\n+  size_t capacity()     const override { return _virtual_space.committed_size(); }\n+  size_t used()         const override { return _space->used(); }\n@@ -81,1 +82,1 @@\n-  virtual bool is_in(const void* p) const {\n+  bool is_in(const void* p) const override {\n@@ -85,1 +86,1 @@\n-  virtual bool requires_barriers(stackChunkOop obj) const { return false; }\n+  bool requires_barriers(stackChunkOop obj) const override { return false; }\n@@ -87,1 +88,1 @@\n-  virtual bool is_maximal_no_gc() const {\n+  bool is_maximal_no_gc() const override {\n@@ -94,4 +95,4 @@\n-  virtual HeapWord* mem_allocate(size_t size, bool* gc_overhead_limit_was_exceeded);\n-  virtual HeapWord* allocate_new_tlab(size_t min_size,\n-                                      size_t requested_size,\n-                                      size_t* actual_size);\n+  HeapWord* mem_allocate(size_t size, bool* gc_overhead_limit_was_exceeded) override;\n+  HeapWord* allocate_new_tlab(size_t min_size,\n+                              size_t requested_size,\n+                              size_t* actual_size) override;\n@@ -100,4 +101,4 @@\n-  virtual size_t tlab_capacity(Thread* thr)         const { return capacity();     }\n-  virtual size_t tlab_used(Thread* thr)             const { return used();         }\n-  virtual size_t max_tlab_size()                    const { return _max_tlab_size; }\n-  virtual size_t unsafe_max_tlab_alloc(Thread* thr) const;\n+  size_t tlab_capacity(Thread* thr)         const override { return capacity();     }\n+  size_t tlab_used(Thread* thr)             const override { return used();         }\n+  size_t max_tlab_size()                    const override { return _max_tlab_size; }\n+  size_t unsafe_max_tlab_alloc(Thread* thr) const override;\n@@ -105,2 +106,2 @@\n-  virtual void collect(GCCause::Cause cause);\n-  virtual void do_full_collection(bool clear_all_soft_refs);\n+  void collect(GCCause::Cause cause) override;\n+  void do_full_collection(bool clear_all_soft_refs) override;\n@@ -109,1 +110,1 @@\n-  virtual void object_iterate(ObjectClosure* cl);\n+  void object_iterate(ObjectClosure* cl) override;\n@@ -112,3 +113,3 @@\n-  virtual bool supports_object_pinning() const           { return true; }\n-  virtual oop pin_object(JavaThread* thread, oop obj)    { return obj; }\n-  virtual void unpin_object(JavaThread* thread, oop obj) { }\n+  bool supports_object_pinning() const           override { return true; }\n+  oop pin_object(JavaThread* thread, oop obj)    override { return obj; }\n+  void unpin_object(JavaThread* thread, oop obj) override { }\n@@ -121,1 +122,1 @@\n-  virtual void gc_threads_do(ThreadClosure* tc) const {}\n+  void gc_threads_do(ThreadClosure* tc) const override {}\n@@ -124,3 +125,3 @@\n-  virtual void register_nmethod(nmethod* nm) {}\n-  virtual void unregister_nmethod(nmethod* nm) {}\n-  virtual void verify_nmethod(nmethod* nm) {}\n+  void register_nmethod(nmethod* nm) override {}\n+  void unregister_nmethod(nmethod* nm) override {}\n+  void verify_nmethod(nmethod* nm) override {}\n@@ -129,2 +130,2 @@\n-  virtual void prepare_for_verify() {}\n-  virtual void verify(VerifyOption option) {}\n+  void prepare_for_verify() override {}\n+  void verify(VerifyOption option) override {}\n@@ -136,2 +137,2 @@\n-  virtual bool can_load_archived_objects() const { return UseCompressedOops; }\n-  virtual HeapWord* allocate_loaded_archive_space(size_t size);\n+  bool can_load_archived_objects() const override { return UseCompressedOops; }\n+  HeapWord* allocate_loaded_archive_space(size_t size) override;\n@@ -139,3 +140,3 @@\n-  virtual void print_on(outputStream* st) const;\n-  virtual void print_tracing_info() const;\n-  virtual bool print_location(outputStream* st, void* addr) const;\n+  void print_on(outputStream* st) const override;\n+  void print_tracing_info() const override;\n+  bool print_location(outputStream* st, void* addr) const override;\n","filename":"src\/hotspot\/share\/gc\/epsilon\/epsilonHeap.hpp","additions":39,"deletions":38,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -96,1 +96,1 @@\n-  virtual void initialize_serviceability();\n+  void initialize_serviceability() override;\n@@ -99,1 +99,1 @@\n-  void trace_heap(GCWhen::Type when, const GCTracer* tracer);\n+  void trace_heap(GCWhen::Type when, const GCTracer* tracer) override;\n@@ -106,1 +106,1 @@\n-  HeapWord* allocate_new_tlab(size_t min_size, size_t requested_size, size_t* actual_size);\n+  HeapWord* allocate_new_tlab(size_t min_size, size_t requested_size, size_t* actual_size) override;\n@@ -129,1 +129,1 @@\n-  virtual Name kind() const {\n+  Name kind() const override {\n@@ -133,1 +133,1 @@\n-  virtual const char* name() const {\n+  const char* name() const override {\n@@ -137,1 +137,1 @@\n-  virtual SoftRefPolicy* soft_ref_policy() { return &_soft_ref_policy; }\n+  SoftRefPolicy* soft_ref_policy() override { return &_soft_ref_policy; }\n@@ -139,2 +139,2 @@\n-  virtual GrowableArray<GCMemoryManager*> memory_managers();\n-  virtual GrowableArray<MemoryPool*> memory_pools();\n+  GrowableArray<GCMemoryManager*> memory_managers() override;\n+  GrowableArray<MemoryPool*> memory_pools() override;\n@@ -145,1 +145,1 @@\n-  virtual PSAdaptiveSizePolicy* size_policy() { return _size_policy; }\n+  PSAdaptiveSizePolicy* size_policy() { return _size_policy; }\n@@ -157,1 +157,1 @@\n-  virtual jint initialize();\n+  jint initialize() override;\n@@ -159,2 +159,2 @@\n-  virtual void safepoint_synchronize_begin();\n-  virtual void safepoint_synchronize_end();\n+  void safepoint_synchronize_begin() override;\n+  void safepoint_synchronize_end() override;\n@@ -162,1 +162,1 @@\n-  void post_initialize();\n+  void post_initialize() override;\n@@ -165,2 +165,2 @@\n-  size_t capacity() const;\n-  size_t used() const;\n+  size_t capacity() const override;\n+  size_t used() const override;\n@@ -171,1 +171,1 @@\n-  virtual bool is_maximal_no_gc() const;\n+  bool is_maximal_no_gc() const override;\n@@ -173,3 +173,3 @@\n-  virtual void register_nmethod(nmethod* nm);\n-  virtual void unregister_nmethod(nmethod* nm);\n-  virtual void verify_nmethod(nmethod* nm);\n+  void register_nmethod(nmethod* nm) override;\n+  void unregister_nmethod(nmethod* nm) override;\n+  void verify_nmethod(nmethod* nm) override;\n@@ -179,1 +179,1 @@\n-  size_t max_capacity() const;\n+  size_t max_capacity() const override;\n@@ -182,1 +182,1 @@\n-  bool is_in(const void* p) const;\n+  bool is_in(const void* p) const override;\n@@ -188,1 +188,1 @@\n-  virtual bool requires_barriers(stackChunkOop obj) const;\n+  bool requires_barriers(stackChunkOop obj) const override;\n@@ -198,1 +198,1 @@\n-  HeapWord* mem_allocate(size_t size, bool* gc_overhead_limit_was_exceeded);\n+  HeapWord* mem_allocate(size_t size, bool* gc_overhead_limit_was_exceeded) override;\n@@ -206,1 +206,1 @@\n-  void collect(GCCause::Cause cause);\n+  void collect(GCCause::Cause cause) override;\n@@ -218,1 +218,1 @@\n-  virtual void do_full_collection(bool clear_all_soft_refs);\n+  void do_full_collection(bool clear_all_soft_refs) override;\n@@ -220,2 +220,2 @@\n-  void ensure_parsability(bool retire_tlabs);\n-  void resize_all_tlabs();\n+  void ensure_parsability(bool retire_tlabs) override;\n+  void resize_all_tlabs() override;\n@@ -223,3 +223,3 @@\n-  size_t tlab_capacity(Thread* thr) const;\n-  size_t tlab_used(Thread* thr) const;\n-  size_t unsafe_max_tlab_alloc(Thread* thr) const;\n+  size_t tlab_capacity(Thread* thr) const override;\n+  size_t tlab_used(Thread* thr) const override;\n+  size_t unsafe_max_tlab_alloc(Thread* thr) const override;\n@@ -227,1 +227,1 @@\n-  void object_iterate(ObjectClosure* cl);\n+  void object_iterate(ObjectClosure* cl) override;\n@@ -229,1 +229,1 @@\n-  virtual ParallelObjectIteratorImpl* parallel_object_iterator(uint thread_num);\n+  ParallelObjectIteratorImpl* parallel_object_iterator(uint thread_num) override;\n@@ -234,1 +234,1 @@\n-  void prepare_for_verify();\n+  void prepare_for_verify() override;\n@@ -236,4 +236,4 @@\n-  virtual void print_on(outputStream* st) const;\n-  virtual void print_on_error(outputStream* st) const;\n-  virtual void gc_threads_do(ThreadClosure* tc) const;\n-  virtual void print_tracing_info() const;\n+  void print_on(outputStream* st) const override;\n+  void print_on_error(outputStream* st) const override;\n+  void gc_threads_do(ThreadClosure* tc) const override;\n+  void print_tracing_info() const override;\n@@ -241,1 +241,1 @@\n-  virtual WorkerThreads* safepoint_workers() { return &_workers; }\n+  WorkerThreads* safepoint_workers() override { return &_workers; }\n@@ -247,1 +247,1 @@\n-  virtual bool print_location(outputStream* st, void* addr) const;\n+  bool print_location(outputStream* st, void* addr) const override;\n@@ -249,1 +249,1 @@\n-  void verify(VerifyOption option \/* ignored *\/);\n+  void verify(VerifyOption option \/* ignored *\/) override;\n@@ -273,3 +273,3 @@\n-  bool can_load_archived_objects() const { return UseCompressedOops; }\n-  HeapWord* allocate_loaded_archive_space(size_t size);\n-  void complete_loaded_archive_space(MemRegion archive_space);\n+  bool can_load_archived_objects() const override { return UseCompressedOops; }\n+  HeapWord* allocate_loaded_archive_space(size_t size) override;\n+  void complete_loaded_archive_space(MemRegion archive_space) override;\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.hpp","additions":44,"deletions":44,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,1 +64,1 @@\n-  virtual void initialize_serviceability();\n+  void initialize_serviceability() override;\n@@ -71,1 +71,1 @@\n-  virtual Name kind() const {\n+  Name kind() const override {\n@@ -75,1 +75,1 @@\n-  virtual const char* name() const {\n+  const char* name() const override {\n@@ -79,2 +79,2 @@\n-  virtual GrowableArray<GCMemoryManager*> memory_managers();\n-  virtual GrowableArray<MemoryPool*> memory_pools();\n+  GrowableArray<GCMemoryManager*> memory_managers() override;\n+  GrowableArray<MemoryPool*> memory_pools() override;\n@@ -104,2 +104,2 @@\n-  virtual void safepoint_synchronize_begin();\n-  virtual void safepoint_synchronize_end();\n+  void safepoint_synchronize_begin() override;\n+  void safepoint_synchronize_end() override;\n@@ -108,3 +108,3 @@\n-  bool can_load_archived_objects() const { return UseCompressedOops; }\n-  HeapWord* allocate_loaded_archive_space(size_t size);\n-  void complete_loaded_archive_space(MemRegion archive_space);\n+  bool can_load_archived_objects() const override { return UseCompressedOops; }\n+  HeapWord* allocate_loaded_archive_space(size_t size) override;\n+  void complete_loaded_archive_space(MemRegion archive_space) override;\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.hpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -128,1 +128,1 @@\n-  virtual void do_full_collection(bool clear_all_soft_refs);\n+  void do_full_collection(bool clear_all_soft_refs) override;\n@@ -142,1 +142,1 @@\n-  virtual jint initialize();\n+  jint initialize() override;\n@@ -150,1 +150,1 @@\n-  void post_initialize();\n+  void post_initialize() override;\n@@ -164,1 +164,1 @@\n-  virtual SoftRefPolicy* soft_ref_policy() { return &_soft_ref_gen_policy; }\n+  SoftRefPolicy* soft_ref_policy() override { return &_soft_ref_gen_policy; }\n@@ -174,2 +174,2 @@\n-  size_t capacity() const;\n-  size_t used() const;\n+  size_t capacity() const override;\n+  size_t used() const override;\n@@ -180,1 +180,1 @@\n-  size_t max_capacity() const;\n+  size_t max_capacity() const override;\n@@ -182,1 +182,1 @@\n-  HeapWord* mem_allocate(size_t size, bool*  gc_overhead_limit_was_exceeded);\n+  HeapWord* mem_allocate(size_t size, bool*  gc_overhead_limit_was_exceeded) override;\n@@ -187,1 +187,1 @@\n-  virtual void collect(GCCause::Cause cause);\n+  void collect(GCCause::Cause cause) override;\n@@ -193,1 +193,1 @@\n-  bool is_in(const void* p) const;\n+  bool is_in(const void* p) const override;\n@@ -199,1 +199,1 @@\n-  virtual bool requires_barriers(stackChunkOop obj) const;\n+  bool requires_barriers(stackChunkOop obj) const override;\n@@ -206,3 +206,3 @@\n-  virtual void register_nmethod(nmethod* nm);\n-  virtual void unregister_nmethod(nmethod* nm);\n-  virtual void verify_nmethod(nmethod* nm);\n+  void register_nmethod(nmethod* nm) override;\n+  void unregister_nmethod(nmethod* nm) override;\n+  void verify_nmethod(nmethod* nm) override;\n@@ -214,1 +214,1 @@\n-  void object_iterate(ObjectClosure* cl);\n+  void object_iterate(ObjectClosure* cl) override;\n@@ -239,6 +239,6 @@\n-  virtual size_t tlab_capacity(Thread* thr) const;\n-  virtual size_t tlab_used(Thread* thr) const;\n-  virtual size_t unsafe_max_tlab_alloc(Thread* thr) const;\n-  virtual HeapWord* allocate_new_tlab(size_t min_size,\n-                                      size_t requested_size,\n-                                      size_t* actual_size);\n+  size_t tlab_capacity(Thread* thr) const override;\n+  size_t tlab_used(Thread* thr) const override;\n+  size_t unsafe_max_tlab_alloc(Thread* thr) const override;\n+  HeapWord* allocate_new_tlab(size_t min_size,\n+                              size_t requested_size,\n+                              size_t* actual_size) override;\n@@ -257,2 +257,2 @@\n-  \/\/ Ensure parsability: override\n-  virtual void ensure_parsability(bool retire_tlabs);\n+  \/\/ Ensure parsability\n+  void ensure_parsability(bool retire_tlabs) override;\n@@ -277,2 +277,2 @@\n-  \/\/ Override.\n-  void prepare_for_verify();\n+  void prepare_for_verify() override;\n+  void verify(VerifyOption option) override;\n@@ -280,7 +280,3 @@\n-  \/\/ Override.\n-  void verify(VerifyOption option);\n-\n-  \/\/ Override.\n-  virtual void print_on(outputStream* st) const;\n-  virtual void gc_threads_do(ThreadClosure* tc) const;\n-  virtual void print_tracing_info() const;\n+  void print_on(outputStream* st) const override;\n+  void gc_threads_do(ThreadClosure* tc) const override;\n+  void print_tracing_info() const override;\n@@ -289,1 +285,1 @@\n-  virtual bool print_location(outputStream* st, void* addr) const;\n+  bool print_location(outputStream* st, void* addr) const override;\n@@ -309,1 +305,1 @@\n-  virtual bool is_maximal_no_gc() const;\n+  virtual bool is_maximal_no_gc() const override;\n","filename":"src\/hotspot\/share\/gc\/shared\/genCollectedHeap.hpp","additions":31,"deletions":35,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -2,0 +2,1 @@\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -146,2 +147,2 @@\n-  const char* name()          const { return \"Shenandoah\"; }\n-  ShenandoahHeap::Name kind() const { return CollectedHeap::Shenandoah; }\n+  const char* name()          const override { return \"Shenandoah\"; }\n+  ShenandoahHeap::Name kind() const override { return CollectedHeap::Shenandoah; }\n@@ -150,2 +151,2 @@\n-  jint initialize();\n-  void post_initialize();\n+  jint initialize() override;\n+  void post_initialize() override;\n@@ -155,1 +156,1 @@\n-  void initialize_serviceability();\n+  void initialize_serviceability() override;\n@@ -157,3 +158,3 @@\n-  void print_on(outputStream* st)              const;\n-  void print_extended_on(outputStream *st)     const;\n-  void print_tracing_info()                    const;\n+  void print_on(outputStream* st)              const override;\n+  void print_extended_on(outputStream *st)     const override;\n+  void print_tracing_info()                    const override;\n@@ -162,1 +163,1 @@\n-  void stop();\n+  void stop() override;\n@@ -164,2 +165,2 @@\n-  void prepare_for_verify();\n-  void verify(VerifyOption vo);\n+  void prepare_for_verify() override;\n+  void verify(VerifyOption vo) override;\n@@ -168,1 +169,1 @@\n-  bool supports_concurrent_gc_breakpoints() const {\n+  bool supports_concurrent_gc_breakpoints() const override {\n@@ -197,1 +198,1 @@\n-  size_t max_capacity()      const;\n+  size_t max_capacity()      const override;\n@@ -200,2 +201,2 @@\n-  size_t capacity()          const;\n-  size_t used()              const;\n+  size_t capacity()          const override;\n+  size_t used()              const override;\n@@ -218,1 +219,1 @@\n-  WorkerThreads* safepoint_workers();\n+  WorkerThreads* safepoint_workers() override;\n@@ -220,1 +221,1 @@\n-  void gc_threads_do(ThreadClosure* tcl) const;\n+  void gc_threads_do(ThreadClosure* tcl) const override;\n@@ -420,8 +421,8 @@\n-  ShenandoahMonitoringSupport* monitoring_support() { return _monitoring_support;    }\n-  GCMemoryManager* cycle_memory_manager()           { return &_cycle_memory_manager; }\n-  GCMemoryManager* stw_memory_manager()             { return &_stw_memory_manager;   }\n-  SoftRefPolicy* soft_ref_policy()                  { return &_soft_ref_policy;      }\n-\n-  GrowableArray<GCMemoryManager*> memory_managers();\n-  GrowableArray<MemoryPool*> memory_pools();\n-  MemoryUsage memory_usage();\n+  ShenandoahMonitoringSupport* monitoring_support()          { return _monitoring_support;    }\n+  GCMemoryManager* cycle_memory_manager()                    { return &_cycle_memory_manager; }\n+  GCMemoryManager* stw_memory_manager()                      { return &_stw_memory_manager;   }\n+  SoftRefPolicy* soft_ref_policy()                  override { return &_soft_ref_policy;      }\n+\n+  GrowableArray<GCMemoryManager*> memory_managers() override;\n+  GrowableArray<MemoryPool*> memory_pools() override;\n+  MemoryUsage memory_usage() override;\n@@ -468,2 +469,1 @@\n-  AdaptiveSizePolicy* size_policy() shenandoah_not_implemented_return(NULL);\n-  bool is_maximal_no_gc() const shenandoah_not_implemented_return(false);\n+  bool is_maximal_no_gc() const override shenandoah_not_implemented_return(false);\n@@ -471,1 +471,1 @@\n-  bool is_in(const void* p) const;\n+  bool is_in(const void* p) const override;\n@@ -473,1 +473,1 @@\n-  bool requires_barriers(stackChunkOop obj) const;\n+  bool requires_barriers(stackChunkOop obj) const override;\n@@ -478,2 +478,2 @@\n-  void collect(GCCause::Cause cause);\n-  void do_full_collection(bool clear_all_soft_refs);\n+  void collect(GCCause::Cause cause) override;\n+  void do_full_collection(bool clear_all_soft_refs) override;\n@@ -484,1 +484,1 @@\n-  bool print_location(outputStream* st, void* addr) const;\n+  bool print_location(outputStream* st, void* addr) const override;\n@@ -487,1 +487,1 @@\n-  void object_iterate(ObjectClosure* cl);\n+  void object_iterate(ObjectClosure* cl) override;\n@@ -489,1 +489,1 @@\n-  virtual ParallelObjectIteratorImpl* parallel_object_iterator(uint workers);\n+  ParallelObjectIteratorImpl* parallel_object_iterator(uint workers) override;\n@@ -492,1 +492,1 @@\n-  void keep_alive(oop obj);\n+  void keep_alive(oop obj) override;\n@@ -497,2 +497,2 @@\n-  void safepoint_synchronize_begin();\n-  void safepoint_synchronize_end();\n+  void safepoint_synchronize_begin() override;\n+  void safepoint_synchronize_end() override;\n@@ -503,3 +503,3 @@\n-  void register_nmethod(nmethod* nm);\n-  void unregister_nmethod(nmethod* nm);\n-  void verify_nmethod(nmethod* nm) {}\n+  void register_nmethod(nmethod* nm) override;\n+  void unregister_nmethod(nmethod* nm) override;\n+  void verify_nmethod(nmethod* nm) override {}\n@@ -511,1 +511,1 @@\n-  bool supports_object_pinning() const { return true; }\n+  bool supports_object_pinning() const override { return true; }\n@@ -513,2 +513,2 @@\n-  oop pin_object(JavaThread* thread, oop obj);\n-  void unpin_object(JavaThread* thread, oop obj);\n+  oop pin_object(JavaThread* thread, oop obj) override;\n+  void unpin_object(JavaThread* thread, oop obj) override;\n@@ -522,1 +522,1 @@\n-  bool uses_stack_watermark_barrier() const { return true; }\n+  bool uses_stack_watermark_barrier() const override { return true; }\n@@ -534,1 +534,1 @@\n-  HeapWord* mem_allocate(size_t size, bool* what);\n+  HeapWord* mem_allocate(size_t size, bool* what) override;\n@@ -537,1 +537,1 @@\n-                                               Metaspace::MetadataType mdtype);\n+                                               Metaspace::MetadataType mdtype) override;\n@@ -541,5 +541,5 @@\n-  HeapWord* allocate_new_tlab(size_t min_size, size_t requested_size, size_t* actual_size);\n-  size_t tlab_capacity(Thread *thr) const;\n-  size_t unsafe_max_tlab_alloc(Thread *thread) const;\n-  size_t max_tlab_size() const;\n-  size_t tlab_used(Thread* ignored) const;\n+  HeapWord* allocate_new_tlab(size_t min_size, size_t requested_size, size_t* actual_size) override;\n+  size_t tlab_capacity(Thread *thr) const override;\n+  size_t unsafe_max_tlab_alloc(Thread *thread) const override;\n+  size_t max_tlab_size() const override;\n+  size_t tlab_used(Thread* ignored) const override;\n@@ -547,1 +547,1 @@\n-  void ensure_parsability(bool retire_labs);\n+  void ensure_parsability(bool retire_labs) override;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":52,"deletions":52,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,3 +53,3 @@\n-  virtual HeapWord* allocate_new_tlab(size_t min_size,\n-                                      size_t requested_size,\n-                                      size_t* actual_size);\n+  HeapWord* allocate_new_tlab(size_t min_size,\n+                              size_t requested_size,\n+                              size_t* actual_size) override;\n@@ -61,5 +61,5 @@\n-  virtual Name kind() const;\n-  virtual const char* name() const;\n-  virtual jint initialize();\n-  virtual void initialize_serviceability();\n-  virtual void stop();\n+  Name kind() const override;\n+  const char* name() const override;\n+  jint initialize() override;\n+  void initialize_serviceability() override;\n+  void stop() override;\n@@ -67,1 +67,1 @@\n-  virtual SoftRefPolicy* soft_ref_policy();\n+  SoftRefPolicy* soft_ref_policy() override;\n@@ -69,4 +69,4 @@\n-  virtual size_t max_capacity() const;\n-  virtual size_t capacity() const;\n-  virtual size_t used() const;\n-  virtual size_t unused() const;\n+  size_t max_capacity() const override;\n+  size_t capacity() const override;\n+  size_t used() const override;\n+  size_t unused() const override;\n@@ -74,3 +74,3 @@\n-  virtual bool is_maximal_no_gc() const;\n-  virtual bool is_in(const void* p) const;\n-  virtual bool requires_barriers(stackChunkOop obj) const;\n+  bool is_maximal_no_gc() const override;\n+  bool is_in(const void* p) const override;\n+  bool requires_barriers(stackChunkOop obj) const override;\n@@ -78,8 +78,8 @@\n-  virtual oop array_allocate(Klass* klass, size_t size, int length, bool do_zero, TRAPS);\n-  virtual HeapWord* mem_allocate(size_t size, bool* gc_overhead_limit_was_exceeded);\n-  virtual MetaWord* satisfy_failed_metadata_allocation(ClassLoaderData* loader_data,\n-                                                       size_t size,\n-                                                       Metaspace::MetadataType mdtype);\n-  virtual void collect(GCCause::Cause cause);\n-  virtual void collect_as_vm_thread(GCCause::Cause cause);\n-  virtual void do_full_collection(bool clear_all_soft_refs);\n+  oop array_allocate(Klass* klass, size_t size, int length, bool do_zero, TRAPS) override;\n+  HeapWord* mem_allocate(size_t size, bool* gc_overhead_limit_was_exceeded) override;\n+  MetaWord* satisfy_failed_metadata_allocation(ClassLoaderData* loader_data,\n+                                               size_t size,\n+                                               Metaspace::MetadataType mdtype) override;\n+  void collect(GCCause::Cause cause) override;\n+  void collect_as_vm_thread(GCCause::Cause cause) override;\n+  void do_full_collection(bool clear_all_soft_refs) override;\n@@ -87,4 +87,4 @@\n-  virtual size_t tlab_capacity(Thread* thr) const;\n-  virtual size_t tlab_used(Thread* thr) const;\n-  virtual size_t max_tlab_size() const;\n-  virtual size_t unsafe_max_tlab_alloc(Thread* thr) const;\n+  size_t tlab_capacity(Thread* thr) const override;\n+  size_t tlab_used(Thread* thr) const override;\n+  size_t max_tlab_size() const override;\n+  size_t unsafe_max_tlab_alloc(Thread* thr) const override;\n@@ -92,1 +92,1 @@\n-  virtual bool uses_stack_watermark_barrier() const;\n+  bool uses_stack_watermark_barrier() const override;\n@@ -94,3 +94,3 @@\n-  virtual MemoryUsage memory_usage();\n-  virtual GrowableArray<GCMemoryManager*> memory_managers();\n-  virtual GrowableArray<MemoryPool*> memory_pools();\n+  MemoryUsage memory_usage() override;\n+  GrowableArray<GCMemoryManager*> memory_managers() override;\n+  GrowableArray<MemoryPool*> memory_pools() override;\n@@ -98,2 +98,2 @@\n-  virtual void object_iterate(ObjectClosure* cl);\n-  virtual ParallelObjectIteratorImpl* parallel_object_iterator(uint nworkers);\n+  void object_iterate(ObjectClosure* cl) override;\n+  ParallelObjectIteratorImpl* parallel_object_iterator(uint nworkers) override;\n@@ -101,1 +101,1 @@\n-  virtual void keep_alive(oop obj);\n+  void keep_alive(oop obj) override;\n@@ -103,3 +103,3 @@\n-  virtual void register_nmethod(nmethod* nm);\n-  virtual void unregister_nmethod(nmethod* nm);\n-  virtual void verify_nmethod(nmethod* nmethod);\n+  void register_nmethod(nmethod* nm) override;\n+  void unregister_nmethod(nmethod* nm) override;\n+  void verify_nmethod(nmethod* nmethod) override;\n@@ -107,1 +107,1 @@\n-  virtual WorkerThreads* safepoint_workers();\n+  WorkerThreads* safepoint_workers() override;\n@@ -109,1 +109,1 @@\n-  virtual void gc_threads_do(ThreadClosure* tc) const;\n+  void gc_threads_do(ThreadClosure* tc) const override;\n@@ -111,1 +111,1 @@\n-  virtual VirtualSpaceSummary create_heap_space_summary();\n+  VirtualSpaceSummary create_heap_space_summary() override;\n@@ -113,2 +113,2 @@\n-  virtual void safepoint_synchronize_begin();\n-  virtual void safepoint_synchronize_end();\n+  void safepoint_synchronize_begin() override;\n+  void safepoint_synchronize_end() override;\n@@ -116,5 +116,5 @@\n-  virtual void print_on(outputStream* st) const;\n-  virtual void print_on_error(outputStream* st) const;\n-  virtual void print_extended_on(outputStream* st) const;\n-  virtual void print_tracing_info() const;\n-  virtual bool print_location(outputStream* st, void* addr) const;\n+  void print_on(outputStream* st) const override;\n+  void print_on_error(outputStream* st) const override;\n+  void print_extended_on(outputStream* st) const override;\n+  void print_tracing_info() const override;\n+  bool print_location(outputStream* st, void* addr) const override;\n@@ -122,4 +122,4 @@\n-  virtual void prepare_for_verify();\n-  virtual void verify(VerifyOption option \/* ignored *\/);\n-  virtual bool is_oop(oop object) const;\n-  virtual bool supports_concurrent_gc_breakpoints() const;\n+  void prepare_for_verify() override;\n+  void verify(VerifyOption option \/* ignored *\/) override;\n+  bool is_oop(oop object) const override;\n+  bool supports_concurrent_gc_breakpoints() const override;\n","filename":"src\/hotspot\/share\/gc\/z\/zCollectedHeap.hpp","additions":53,"deletions":53,"binary":false,"changes":106,"status":"modified"}]}