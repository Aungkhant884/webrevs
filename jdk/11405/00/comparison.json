{"files":[{"patch":"@@ -135,0 +135,2 @@\n+          (opcode == Op_CountLeadingZerosV && bt == T_LONG) ||\n+          (opcode == Op_CountTrailingZerosV && bt == T_LONG) ||\n@@ -5651,1 +5653,0 @@\n-  predicate(Matcher::vector_element_basic_type(n) == T_LONG);\n@@ -5667,26 +5668,0 @@\n-\/\/ If the PopCountVL is generated by auto-vectorization, the dst basic\n-\/\/ type is T_INT. And once we have unified the type definition for\n-\/\/ Vector API and auto-vectorization, this rule can be merged with\n-\/\/ \"vpopcountL\" rule.\n-\n-instruct vpopcountL_I(vReg dst, vReg src, vReg tmp) %{\n-  predicate(Matcher::vector_element_basic_type(n) == T_INT);\n-  match(Set dst (PopCountVL src));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"vpopcountL_I $dst, $src\\t# KILL $tmp\" %}\n-  ins_encode %{\n-    if (UseSVE == 0) {\n-      __ cnt($dst$$FloatRegister, __ T16B, $src$$FloatRegister);\n-      __ uaddlp($dst$$FloatRegister, __ T16B, $dst$$FloatRegister);\n-      __ uaddlp($dst$$FloatRegister, __ T8H, $dst$$FloatRegister);\n-      __ uaddlp($dst$$FloatRegister, __ T4S, $dst$$FloatRegister);\n-      __ xtn($dst$$FloatRegister, __ T2S, $dst$$FloatRegister, __ T2D);\n-    } else {\n-      __ sve_cnt($dst$$FloatRegister, __ D, ptrue, $src$$FloatRegister);\n-      __ sve_vector_narrow($dst$$FloatRegister, __ S,\n-                           $dst$$FloatRegister, __ D, $tmp$$FloatRegister);\n-    }\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n@@ -5708,1 +5683,1 @@\n-  predicate(UseSVE > 0 && Matcher::vector_element_basic_type(n) == T_LONG);\n+  predicate(UseSVE > 0);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad","additions":3,"deletions":28,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -125,0 +125,2 @@\n+          (opcode == Op_CountLeadingZerosV && bt == T_LONG) ||\n+          (opcode == Op_CountTrailingZerosV && bt == T_LONG) ||\n@@ -4034,1 +4036,0 @@\n-  predicate(Matcher::vector_element_basic_type(n) == T_LONG);\n@@ -4050,26 +4051,0 @@\n-\/\/ If the PopCountVL is generated by auto-vectorization, the dst basic\n-\/\/ type is T_INT. And once we have unified the type definition for\n-\/\/ Vector API and auto-vectorization, this rule can be merged with\n-\/\/ \"vpopcountL\" rule.\n-\n-instruct vpopcountL_I(vReg dst, vReg src, vReg tmp) %{\n-  predicate(Matcher::vector_element_basic_type(n) == T_INT);\n-  match(Set dst (PopCountVL src));\n-  effect(TEMP_DEF dst, TEMP tmp);\n-  format %{ \"vpopcountL_I $dst, $src\\t# KILL $tmp\" %}\n-  ins_encode %{\n-    if (UseSVE == 0) {\n-      __ cnt($dst$$FloatRegister, __ T16B, $src$$FloatRegister);\n-      __ uaddlp($dst$$FloatRegister, __ T16B, $dst$$FloatRegister);\n-      __ uaddlp($dst$$FloatRegister, __ T8H, $dst$$FloatRegister);\n-      __ uaddlp($dst$$FloatRegister, __ T4S, $dst$$FloatRegister);\n-      __ xtn($dst$$FloatRegister, __ T2S, $dst$$FloatRegister, __ T2D);\n-    } else {\n-      __ sve_cnt($dst$$FloatRegister, __ D, ptrue, $src$$FloatRegister);\n-      __ sve_vector_narrow($dst$$FloatRegister, __ S,\n-                           $dst$$FloatRegister, __ D, $tmp$$FloatRegister);\n-    }\n-  %}\n-  ins_pipe(pipe_slow);\n-%}\n-\n@@ -4080,1 +4055,1 @@\n-  predicate(UseSVE > 0 && Matcher::vector_element_basic_type(n) == T_LONG);\n+  predicate(UseSVE > 0);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4","additions":3,"deletions":28,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -8878,6 +8878,0 @@\n-    \/\/ TODO: Once auto-vectorizer supports ConvL2I operation, PopCountVL\n-    \/\/ should be succeeded by its corresponding vector IR and following\n-    \/\/ special handling should be removed.\n-    if (opcode == Op_PopCountVL && Matcher::vector_element_basic_type(this) == T_INT) {\n-      __ evpmovqd($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n-    }\n@@ -8914,12 +8908,0 @@\n-    \/\/ TODO: Once auto-vectorizer supports ConvL2I operation, PopCountVL\n-    \/\/ should be succeeded by its corresponding vector IR and following\n-    \/\/ special handling should be removed.\n-    if (opcode == Op_PopCountVL && Matcher::vector_element_basic_type(this) == T_INT) {\n-      if (VM_Version::supports_avx512vl()) {\n-        __ evpmovqd($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n-      } else {\n-        assert(VM_Version::supports_avx2(), \"\");\n-        __ vpshufd($dst$$XMMRegister, $dst$$XMMRegister, 8, vlen_enc);\n-        __ vpermq($dst$$XMMRegister, $dst$$XMMRegister, 8, vlen_enc);\n-      }\n-    }\n@@ -8942,1 +8924,0 @@\n-    BasicType rbt = Matcher::vector_element_basic_type(this);\n@@ -8945,6 +8926,0 @@\n-    \/\/ TODO: Once auto-vectorizer supports ConvL2I operation, CountTrailingZerosV\n-    \/\/ should be succeeded by its corresponding vector IR and following\n-    \/\/ special handling should be removed.\n-    if (bt == T_LONG && rbt == T_INT) {\n-      __ evpmovqd($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n-    }\n@@ -8996,1 +8971,0 @@\n-    BasicType rbt = Matcher::vector_element_basic_type(this);\n@@ -8999,8 +8973,0 @@\n-    \/\/ TODO: Once auto-vectorizer supports ConvL2I operation, PopCountVL\n-    \/\/ should be succeeded by its corresponding vector IR and following\n-    \/\/ special handling should be removed.\n-    if (bt == T_LONG && rbt == T_INT) {\n-      assert(VM_Version::supports_avx2(), \"\");\n-      __ vpshufd($dst$$XMMRegister, $dst$$XMMRegister, 8, vlen_enc);\n-      __ vpermq($dst$$XMMRegister, $dst$$XMMRegister, 8, vlen_enc);\n-    }\n@@ -9411,1 +9377,0 @@\n-     BasicType rbt = Matcher::vector_element_basic_type(this);\n@@ -9414,6 +9379,0 @@\n-     \/\/ TODO: Once auto-vectorizer supports ConvL2I operation, CountLeadingZerosV\n-     \/\/ should be succeeded by its corresponding vector IR and following\n-     \/\/ special handling should be removed.\n-     if (rbt == T_INT && bt == T_LONG) {\n-       __ evpmovqd($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n-     }\n@@ -9494,1 +9453,0 @@\n-    BasicType rbt = Matcher::vector_element_basic_type(this);\n@@ -9497,6 +9455,0 @@\n-    \/\/ TODO: Once auto-vectorizer supports ConvL2I operation, CountLeadingZerosV\n-    \/\/ should be succeeded by its corresponding vector IR and following\n-    \/\/ special handling should be removed.\n-    if (rbt == T_INT && bt == T_LONG) {\n-      __ evpmovqd($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);\n-    }\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":0,"deletions":48,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2082,0 +2082,8 @@\n+    } else if (requires_long_to_int_conversion(opc)) {\n+      \/\/ Java API for Long.bitCount\/numberOfLeadingZeros\/numberOfTrailingZeros\n+      \/\/ returns int type, but Vector API for them returns long type. To unify\n+      \/\/ the implementation in backend, superword splits the vector implementation\n+      \/\/ for Java API into an execution node with long type plus another node\n+      \/\/ converting long to int.\n+      retValue = VectorNode::implemented(opc, size, T_LONG) &&\n+                 VectorCastNode::implemented(Op_ConvL2I, size, T_LONG, T_INT);\n@@ -2099,0 +2107,12 @@\n+\n+bool SuperWord::requires_long_to_int_conversion(int opc) {\n+  switch(opc) {\n+    case Op_PopCountL:\n+    case Op_CountLeadingZerosL:\n+    case Op_CountTrailingZerosL:\n+      return true;\n+    default:\n+      return false;\n+  }\n+}\n+\n@@ -2669,1 +2689,0 @@\n-                 opc == Op_PopCountI || opc == Op_PopCountL ||\n@@ -2673,2 +2692,2 @@\n-                 opc == Op_CountLeadingZerosI || opc == Op_CountLeadingZerosL ||\n-                 opc == Op_CountTrailingZerosI || opc == Op_CountTrailingZerosL) {\n+                 opc == Op_PopCountI || opc == Op_CountLeadingZerosI ||\n+                 opc == Op_CountTrailingZerosI) {\n@@ -2679,0 +2698,13 @@\n+      } else if (requires_long_to_int_conversion(opc)) {\n+        \/\/ Java API for Long.bitCount\/numberOfLeadingZeros\/numberOfTrailingZeros\n+        \/\/ returns int type, but Vector API for them returns long type. To unify\n+        \/\/ the implementation in backend, superword splits the vector implementation\n+        \/\/ for Java API into an execution node with long type plus another node\n+        \/\/ converting long to int.\n+        assert(n->req() == 2, \"only one input expected\");\n+        Node* in = vector_opd(p, 1);\n+        Node* longval = VectorNode::make(opc, in, NULL, vlen, T_LONG);\n+        _igvn.register_new_node_with_optimizer(longval);\n+        _phase->set_ctrl(longval, _phase->get_ctrl(p->at(0)));\n+        vn = VectorCastNode::make(Op_VectorCastL2X, longval, T_INT, vlen);\n+        vlen_in_bytes = vn->as_Vector()->length_in_bytes();\n@@ -3201,16 +3233,0 @@\n-  if (VectorNode::is_type_transition_long_to_int(use)) {\n-    \/\/ PopCountL\/CountLeadingZerosL\/CountTrailingZerosL takes long and produces\n-    \/\/ int - hence the special checks on alignment and size.\n-    if (u_pk->size() != d_pk->size()) {\n-      return false;\n-    }\n-    for (uint i = 0; i < MIN2(d_pk->size(), u_pk->size()); i++) {\n-      Node* ui = u_pk->at(i);\n-      Node* di = d_pk->at(i);\n-      if (alignment(ui) * 2 != alignment(di)) {\n-        return false;\n-      }\n-    }\n-    return true;\n-  }\n-\n@@ -3221,1 +3237,1 @@\n-    \/\/ type conversion takes a type of a kind of size and produces a type of\n+    \/\/ These opcodes take a type of a kind of size and produce a type of\n@@ -3470,1 +3486,2 @@\n-  if (!VectorNode::is_convert_opcode(n->Opcode()) ||\n+  if (!(VectorNode::is_convert_opcode(n->Opcode()) ||\n+        requires_long_to_int_conversion(n->Opcode())) ||\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":38,"deletions":21,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -460,0 +460,1 @@\n+  static bool requires_long_to_int_conversion(int opc);\n","filename":"src\/hotspot\/share\/opto\/superword.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -338,11 +338,0 @@\n-bool VectorNode::is_type_transition_long_to_int(Node* n) {\n-  switch(n->Opcode()) {\n-    case Op_PopCountL:\n-    case Op_CountLeadingZerosL:\n-    case Op_CountTrailingZerosL:\n-       return true;\n-    default:\n-       return false;\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -102,1 +102,0 @@\n-  static bool is_type_transition_long_to_int(Node* n);\n@@ -554,1 +553,3 @@\n-  PopCountVLNode(Node* in, const TypeVect* vt) : VectorNode(in,vt) {}\n+  PopCountVLNode(Node* in, const TypeVect* vt) : VectorNode(in,vt) {\n+    assert(vt->element_basic_type() == T_LONG, \"must be long\");\n+  }\n@@ -1735,1 +1736,4 @@\n-  : VectorNode(in, vt) {}\n+  : VectorNode(in, vt) {\n+    assert(in->bottom_type()->is_vect()->element_basic_type() == vt->element_basic_type(),\n+           \"must be the same\");\n+  }\n@@ -1743,1 +1747,4 @@\n-  : VectorNode(in, vt) {}\n+  : VectorNode(in, vt) {\n+    assert(in->bottom_type()->is_vect()->element_basic_type() == vt->element_basic_type(),\n+           \"must be the same\");\n+  }\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -119,0 +119,16 @@\n+    @Test\n+    @IR(failOn = {IRNode.COUNTTRAILINGZEROS_VL})\n+    public void testNumberOfTrailingZeros() {\n+        for (int i = 0; i < SIZE; ++i) {\n+            inta[i] = Long.numberOfTrailingZeros(longa[i]);\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.COUNTLEADINGZEROS_VL})\n+    public void testNumberOfLeadingZeros() {\n+        for (int i = 0; i < SIZE; ++i) {\n+            inta[i] = Long.numberOfLeadingZeros(longa[i]);\n+        }\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestDisableAutoVectOpcodes.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -717,0 +717,10 @@\n+    public static final String COUNTTRAILINGZEROS_VL = PREFIX + \"COUNTTRAILINGZEROS_VL\" + POSTFIX;\n+    static {\n+        superWordNodes(COUNTTRAILINGZEROS_VL, \"CountTrailingZerosV\");\n+    }\n+\n+    public static final String COUNTLEADINGZEROS_VL = PREFIX + \"COUNTLEADINGZEROS_VL\" + POSTFIX;\n+    static {\n+        superWordNodes(COUNTLEADINGZEROS_VL, \"CountLeadingZerosV\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+* @test\n+* @key randomness\n+* @summary Test vectorization of numberOfTrailingZeros\/numberOfLeadingZeros for Long\n+* @requires vm.compiler2.enabled\n+* @requires (os.simpleArch == \"x64\" & vm.cpu.features ~= \".*avx2.*\") |\n+*           (os.simpleArch == \"aarch64\" & vm.cpu.features ~= \".*sve.*\" & (vm.opt.UseSVE == \"null\" | vm.opt.UseSVE > 0))\n+* @library \/test\/lib \/\n+* @run driver compiler.vectorization.TestNumberOfContinuousZeros\n+*\/\n+\n+package compiler.vectorization;\n+\n+import compiler.lib.ir_framework.*;\n+import java.util.Random;\n+import jdk.test.lib.Asserts;\n+\n+public class TestNumberOfContinuousZeros {\n+    private long[] input;\n+    private int[] output;\n+    private static final int LEN = 1024;\n+    private Random rng;\n+\n+    public static void main(String args[]) {\n+        TestFramework.run();\n+    }\n+\n+    public TestNumberOfContinuousZeros() {\n+        input = new long[LEN];\n+        output = new int[LEN];\n+        rng = new Random(42);\n+        for (int i = 0; i < LEN; ++i) {\n+            input[i] = rng.nextLong();\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.COUNTTRAILINGZEROS_VL, \"> 0\"})\n+    public void vectorizeNumberOfTrailingZeros() {\n+        for (int i = 0; i < LEN; ++i) {\n+            output[i] = Long.numberOfTrailingZeros(input[i]);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.COUNTLEADINGZEROS_VL, \"> 0\"})\n+    public void vectorizeNumberOfLeadingZeros() {\n+        for (int i = 0; i < LEN; ++i) {\n+            output[i] = Long.numberOfLeadingZeros(input[i]);\n+        }\n+    }\n+\n+    @Run(test = {\"vectorizeNumberOfTrailingZeros\", \"vectorizeNumberOfLeadingZeros\"})\n+    public void checkResult() {\n+        vectorizeNumberOfTrailingZeros();\n+        for (int i = 0; i < LEN; ++i) {\n+            Asserts.assertEquals(output[i], Long.numberOfTrailingZeros(input[i]));\n+        }\n+        vectorizeNumberOfLeadingZeros();\n+        for (int i = 0; i < LEN; ++i) {\n+            Asserts.assertEquals(output[i], Long.numberOfLeadingZeros(input[i]));\n+        }\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestNumberOfContinuousZeros.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -28,2 +28,2 @@\n-* @requires vm.cpu.features ~= \".*avx512bw.*\" | (vm.cpu.features ~= \".*sve.*\" & (vm.opt.UseSVE == \"null\" | vm.opt.UseSVE > 0))\n-* @requires os.arch==\"x86\" | os.arch==\"i386\" | os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\"\n+* @requires ((os.arch==\"x86\" | os.arch==\"i386\" | os.arch==\"amd64\" | os.arch==\"x86_64\") & vm.cpu.features ~= \".*avx512bw.*\") |\n+*           os.simpleArch == \"aarch64\"\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestPopCountVectorLong.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}