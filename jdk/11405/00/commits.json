[{"commit":{"message":"8297172: Fix some issues of auto-vectorization of `Long.bitCount\/numberOfTrailingZeros\/numberOfLeadingZeros()`\n\nBackground:\n\nJava API[1] for `Long.bitCount\/numberOfTrailingZeros\/\nnumberOfLeadingZeros()` returns int type, while Vector API[2]\nfor them returns long type. Currently, to support\nauto-vectorization of Java API and Vector API at the same time,\nsome vector platforms, namely aarch64 and x86, provides two types\nof vector nodes taking long type: One produces long vector type\nfor vector API, and the other one produces int vector type by\ncasting long-type result from the first one.\n\nWe can move the casting work for auto-vectorization of Java API\nto the mid-end so that we can unify the vector implementation in\nthe backend, reducing extra code. The patch does the refactoring\nand also fixes several issues below.\n\n1. Refine the auto-vectorization of\n`Long.bitCount\/numberOfTrailingZeros\/numberOfLeadingZeros()`\n\nIn the patch, during the stage of generating vector node for the\ncandidate pack, to implement the complete behavior of these\nJava APIs, superword will make two consecutive vector nodes:\nthe first one, the same as Vector API, does the real execution\nto produce long-type result, and the second one casts the result\nto int vector type.\n\nFor those platforms, which have supported correctly vectorizing\nthese java APIs before, the patch has no real impact on final\ngenerated assembly code and, consequently, has no performance\nregression.\n\n2. Fix the IR check failure of\n`compiler\/vectorization\/TestPopCountVectorLong.java` on\n128-bit sve platform\n\nThese Java APIs take a long type and produce an int type, like\nconversion nodes between different data sizes do. In superword,\nthe alignment of their input nodes is different from their own.\nIt results in that these APIs can't be vectorized when\n`-XX:MaxVectorSize=16`. So, the IR check for vector nodes in\n`compiler\/vectorization\/TestPopCountVectorLong.java` would fail.\nTo fix the issue of alignment, the patch corrects their related\nalignment, just like it did for conversion nodes between\ndifferent data sizes. After the patch, these Java APIs can be\nvectorized on 128-bit platforms, as long as the auto-\nvectorization is profitable.\n\n3. Fix the incorrect vectorization of\n`numberOfTrailingZeros\/numberOfLeadingZeros()` in aarch64\nplatforms with more than 128 bits\n\nAlthough `Long.NumberOfLeadingZeros\/NumberOfTrailingZeros()` can\nbe vectorized on sve platforms when `-XX:MaxVectorSize=32` or\n`-XX:MaxVectorSize=64` even before the patch, aarch64 backend\ndidn't provide special vector implementation for Java API and\nthus the generated code is not correct, like:\n```\nLOOP:\n  sxtw  x13, w12\n  add   x14, x15, x13, uxtx #3\n  add   x17, x14, #0x10\n  ld1d  {z16.d}, p7\/z, [x17]\n  \/\/ Incorrectly use integer rbit\/clz insn for long type vector\n *rbit  z16.s, p7\/m, z16.s\n *clz   z16.s, p7\/m, z16.s\n  add   x13, x16, x13, uxtx #2\n  str   q16, [x13, #16]\n  ...\n  add   w12, w12, #0x20\n  cmp   w12, w3\n  b.lt  LOOP\n```\n\nIt causes a runtime failure of the testcase\n`compiler\/vectorization\/TestNumberOfContinuousZeros.java` added\nin the patch. After the refactoring, the testcase can pass and\nthe code is corrected:\n```\nLOOP:\n  sxtw  x13, w12\n  add   x14, x15, x13, uxtx #3\n  add   x17, x14, #0x10\n  ld1d  {z16.d}, p7\/z, [x17]\n  \/\/ Compute with long vector type and convert to int vector type\n *rbit  z16.d, p7\/m, z16.d\n *clz   z16.d, p7\/m, z16.d\n *mov   z24.d, #0\n *uzp1  z25.s, z16.s, z24.s\n  add   x13, x16, x13, uxtx #2\n  str   q25, [x13, #16]\n  ...\n  add   w12, w12, #0x20\n  cmp   w12, w3\n  b.lt  LOOP\n```\n\n4. Fix an assertion failure on x86 avx2 platform\n\nBefore, on x86 avx2 platform, there is an assertion failure when\nC2 tries to vectorize the loops like:\n```\n\/\/  long[] ia;\n\/\/  int[] ic;\n    for (int i = 0; i < LENGTH; ++i) {\n      ic[i] = Long.numberOfLeadingZeros(ia[i]);\n    }\n```\n\nX86 backend supports vectorizing `numberOfLeadingZeros()` on\navx2 platform, but it uses `evpmovqd()` to do casting for\n`CountLeadingZerosV`[3], which can only be used when\n`UseAVX > 2`[4]. After the refactoring, the failure can be fixed\nnaturally.\n\nTier 1~3 passed with no new failures on Linux AArch64\/X86 platform.\n\n[1] https:\/\/docs.oracle.com\/en\/java\/javase\/19\/docs\/api\/java.base\/java\/lang\/Long.html#bitCount(long)\n    https:\/\/docs.oracle.com\/en\/java\/javase\/19\/docs\/api\/java.base\/java\/lang\/Long.html#numberOfTrailingZeros(long)\n    https:\/\/docs.oracle.com\/en\/java\/javase\/19\/docs\/api\/java.base\/java\/lang\/Long.html#numberOfLeadingZeros(long)\n[2] https:\/\/github.com\/openjdk\/jdk\/blob\/544e31722528d12fae0eb19271f85886680801a6\/src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java#L687\n[3] https:\/\/github.com\/openjdk\/jdk\/blob\/544e31722528d12fae0eb19271f85886680801a6\/src\/hotspot\/cpu\/x86\/x86.ad#L9418\n[4] https:\/\/github.com\/openjdk\/jdk\/blob\/fc616588c1bf731150a9d9b80033bb589bcb231f\/src\/hotspot\/cpu\/x86\/assembler_x86.cpp#L2239"},"files":[{"filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad"},{"filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4"},{"filename":"src\/hotspot\/cpu\/x86\/x86.ad"},{"filename":"src\/hotspot\/share\/opto\/superword.cpp"},{"filename":"src\/hotspot\/share\/opto\/superword.hpp"},{"filename":"src\/hotspot\/share\/opto\/vectornode.cpp"},{"filename":"src\/hotspot\/share\/opto\/vectornode.hpp"},{"filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestDisableAutoVectOpcodes.java"},{"filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java"},{"filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestNumberOfContinuousZeros.java"},{"filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestPopCountVectorLong.java"}],"sha":"cf2a0e7ebbdf1367a09f07c59109f608ecb52b9d"}]