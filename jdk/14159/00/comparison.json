{"files":[{"patch":"@@ -469,2 +469,2 @@\n-                            \/\/ request more data and return.\n-                            requestMore();\n+                            \/\/ request more data if needed and return.\n+                            requestMoreDataIfNeeded();\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/common\/SSLFlowDelegate.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,188 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.net.SimpleSSLContext;\n+\n+import javax.net.ssl.SSLContext;\n+import java.io.*;\n+import java.net.InetAddress;\n+import java.net.ServerSocket;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Flow;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import static java.lang.System.err;\n+\n+\/**\n+ * @test\n+ * @summary This test verifies that when performing an HTTPS request, there\n+ * is no uncontrolled read of the response.\n+ * @bug 8308144\n+ * @library \/test\/lib \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build jdk.test.lib.net.SimpleSSLContext HttpsBackpressureTest\n+ * @run main\/othervm -Dtest.requiresHost=true\n+ * -Djdk.httpclient.HttpClient.log=headers\n+ * -Djdk.internal.httpclient.debug=true HttpsBackpressureTest\n+ *\/\n+\n+public class HttpsBackpressureTest {\n+    static int WRITE_BUFFER_SIZE = 300_000;\n+    static int WRITES = 10;\n+    static int ALLOWED_WRITES = 2;\n+\n+    static final SSLContext context;\n+\n+    static {\n+        try {\n+            context = new SimpleSSLContext().get();\n+            SSLContext.setDefault(context);\n+        } catch (Exception x) {\n+            throw new ExceptionInInitializerError(x);\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        var server = new DummyHttpsServer(WRITE_BUFFER_SIZE, WRITES, context);\n+\n+        var client = HttpClient.newBuilder().sslContext(context).build();\n+        try {\n+            var request = HttpRequest.newBuilder()\n+                    .uri(URI.create(\"https:\/\/\" + server.addr + \"\/\"))\n+                    .build();\n+            client.sendAsync(request, (info) -> new NoopSubscriber());\n+\n+            Thread.sleep(2000);\n+\n+            var writes = server.writes.get();\n+            if (writes > ALLOWED_WRITES) {\n+                throw new RuntimeException(\"Too large intermediate buffer, server sent \" +\n+                        writes + \"x\" + WRITE_BUFFER_SIZE + \" bytes\");\n+            }\n+        } catch (Throwable t) {\n+            err.println(\"Unexpected exception: exiting: \" + t);\n+            t.printStackTrace();\n+            throw t;\n+        } finally {\n+            client.shutdownNow();\n+            server.close();\n+        }\n+    }\n+\n+    static class NoopSubscriber implements HttpResponse.BodySubscriber<NoopSubscriber> {\n+        @Override\n+        public CompletionStage<NoopSubscriber> getBody() {\n+            return CompletableFuture.completedFuture(this);\n+        }\n+\n+        @Override\n+        public void onSubscribe(Flow.Subscription subscription) {\n+            subscription.request(1);\n+        }\n+\n+        @Override\n+        public void onNext(List<ByteBuffer> item) {\n+        }\n+\n+        @Override\n+        public void onError(Throwable throwable) {\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+        }\n+    }\n+\n+    static class DummyHttpsServer implements AutoCloseable {\n+        private final int bufSize;\n+        private final int bufCount;\n+        final AtomicInteger writes = new AtomicInteger();\n+\n+        final ServerSocket serverSocket;\n+        final Thread serverThread;\n+        final String addr;\n+\n+        public DummyHttpsServer(int bufSize, int bufCount, SSLContext ctx) throws IOException {\n+            this.bufSize = bufSize;\n+            this.bufCount = bufCount;\n+\n+            serverSocket = ctx.getServerSocketFactory().createServerSocket(0, 10, InetAddress.getLoopbackAddress());\n+            addr = InetAddress.getLoopbackAddress().getHostAddress() + \":\" + serverSocket.getLocalPort();\n+\n+            serverThread = new Thread(this::handleConnection);\n+            serverThread.setDaemon(false);\n+            serverThread.start();\n+        }\n+\n+        void readHeaders(InputStream is) throws IOException {\n+            var sb = new StringBuilder();\n+            var buf = new byte[128];\n+            while (sb.indexOf(\"\\r\\n\\r\\n\") == -1) {\n+                if (sb.length() > 3) {\n+                    sb.delete(0, sb.length() - 3);\n+                }\n+                int c = is.read(buf);\n+                sb.append(new String(buf, 0, c, StandardCharsets.ISO_8859_1));\n+            }\n+        }\n+\n+        public void handleConnection() {\n+            try {\n+                var socket = serverSocket.accept();\n+\n+                readHeaders(socket.getInputStream());\n+\n+                var os = socket.getOutputStream();\n+                var headers = \"HTTP\/1.1 200 OK\\r\\n\" +\n+                        \"Content-length: \" + (bufSize * bufCount) + \"\\r\\n\" +\n+                        \"\\r\\n\";\n+                os.write(headers.getBytes());\n+\n+                var buf = new byte[bufSize];\n+                for (int i = 0; i < bufCount; i++) {\n+                    ThreadLocalRandom.current().nextBytes(buf);\n+                    os.write(buf);\n+                    writes.incrementAndGet();\n+                }\n+\n+                os.close();\n+            } catch (IOException e) {\n+                e.printStackTrace();\n+            }\n+        }\n+\n+        @Override\n+        public void close() throws Exception {\n+            serverSocket.close();\n+            serverThread.interrupt();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/HttpsBackpressureTest.java","additions":188,"deletions":0,"binary":false,"changes":188,"status":"added"}]}