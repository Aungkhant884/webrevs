{"files":[{"patch":"@@ -138,1 +138,1 @@\n-        List<DCTree> preamble = isFileContent ? blockContent(Phase.PREAMBLE) : List.nil();\n+        List<DCTree> preamble = isFileContent && !isMarkdown ? blockContent(Phase.PREAMBLE) : List.nil();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/DocCommentParser.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,750 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.internal.shellsupport.doc;\n-\n-import java.io.IOException;\n-import java.net.URI;\n-import java.net.URISyntaxException;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.IdentityHashMap;\n-import java.util.LinkedHashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.ResourceBundle;\n-import java.util.Stack;\n-\n-import javax.lang.model.element.Name;\n-import javax.tools.JavaFileObject.Kind;\n-import javax.tools.SimpleJavaFileObject;\n-import javax.tools.ToolProvider;\n-\n-import com.sun.source.doctree.AttributeTree;\n-import com.sun.source.doctree.DocCommentTree;\n-import com.sun.source.doctree.DocTree;\n-import com.sun.source.doctree.EndElementTree;\n-import com.sun.source.doctree.EntityTree;\n-import com.sun.source.doctree.InlineTagTree;\n-import com.sun.source.doctree.LinkTree;\n-import com.sun.source.doctree.LiteralTree;\n-import com.sun.source.doctree.ParamTree;\n-import com.sun.source.doctree.ReturnTree;\n-import com.sun.source.doctree.StartElementTree;\n-import com.sun.source.doctree.TextTree;\n-import com.sun.source.doctree.ThrowsTree;\n-import com.sun.source.util.DocTreeScanner;\n-import com.sun.source.util.DocTrees;\n-import com.sun.source.util.JavacTask;\n-import com.sun.tools.javac.util.DefinedBy;\n-import com.sun.tools.javac.util.DefinedBy.Api;\n-import com.sun.tools.javac.util.StringUtils;\n-\n-\/**A javadoc to plain text formatter.\n- *\n- *\/\n-public class JavadocFormatter {\n-\n-    private static final String CODE_RESET = \"\\033[0m\";\n-    private static final String CODE_HIGHLIGHT = \"\\033[1m\";\n-    private static final String CODE_UNDERLINE = \"\\033[4m\";\n-\n-    private final int lineLimit;\n-    private final boolean escapeSequencesSupported;\n-\n-    \/** Construct the formatter.\n-     *\n-     * @param lineLimit maximum line length\n-     * @param escapeSequencesSupported whether escape sequences are supported\n-     *\/\n-    public JavadocFormatter(int lineLimit, boolean escapeSequencesSupported) {\n-        this.lineLimit = lineLimit;\n-        this.escapeSequencesSupported = escapeSequencesSupported;\n-    }\n-\n-    private static final int MAX_LINE_LENGTH = 95;\n-    private static final int SHORTEST_LINE = 30;\n-    private static final int INDENT = 4;\n-\n-    \/**Format javadoc to plain text.\n-     *\n-     * @param header element caption that should be used\n-     * @param javadoc to format\n-     * @return javadoc formatted to plain text\n-     *\/\n-    public String formatJavadoc(String header, String javadoc) {\n-        try {\n-            StringBuilder result = new StringBuilder();\n-\n-            result.append(escape(CODE_HIGHLIGHT)).append(header).append(escape(CODE_RESET)).append(\"\\n\");\n-\n-            if (javadoc == null) {\n-                return result.toString();\n-            }\n-\n-            JavacTask task = (JavacTask) ToolProvider.getSystemJavaCompiler().getTask(null, null, null, null, null, null);\n-            DocTrees trees = DocTrees.instance(task);\n-            DocCommentTree docComment = trees.getDocCommentTree(new SimpleJavaFileObject(new URI(\"mem:\/\/doc.html\"), Kind.HTML) {\n-                @Override @DefinedBy(Api.COMPILER)\n-                public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {\n-                    return \"<body>\" + javadoc + \"<\/body>\";\n-                }\n-            });\n-\n-            new FormatJavadocScanner(result, task).scan(docComment, null);\n-\n-            addNewLineIfNeeded(result);\n-\n-            return result.toString();\n-        } catch (URISyntaxException ex) {\n-            throw new InternalError(\"Unexpected exception\", ex);\n-        }\n-    }\n-\n-    enum HtmlTag {\n-        HTML,\n-        H1, H2, H3, H4, H5, H6,\n-        BLOCKQUOTE, P, PRE,\n-        IMG,\n-        OL, UL, LI,\n-        DL, DT, DD,\n-        TABLE, TR, TD, TH;\n-\n-        private static final Map<String, HtmlTag> index = new HashMap<>();\n-        static {\n-            for (HtmlTag t: values()) {\n-                index.put(StringUtils.toLowerCase(t.name()), t);\n-            }\n-        }\n-\n-        public static HtmlTag get(Name tagName) {\n-            return index.get(StringUtils.toLowerCase(tagName.toString()));\n-        }\n-    }\n-\n-    private class FormatJavadocScanner extends DocTreeScanner<Object, Object> {\n-        private final StringBuilder result;\n-        private final JavacTask task;\n-        private final DocTrees trees;\n-        private int reflownTo;\n-        private int indent;\n-        private int limit = Math.min(lineLimit, MAX_LINE_LENGTH);\n-        private boolean pre;\n-        private Map<StartElementTree, Integer> tableColumns;\n-\n-        public FormatJavadocScanner(StringBuilder result, JavacTask task) {\n-            this.result = result;\n-            this.task = task;\n-            this.trees = DocTrees.instance(task);\n-        }\n-\n-        @Override @DefinedBy(Api.COMPILER_TREE)\n-        public Object visitDocComment(DocCommentTree node, Object p) {\n-            tableColumns = countTableColumns(node);\n-            reflownTo = result.length();\n-            scan(node.getFirstSentence(), p);\n-            scan(node.getBody(), p);\n-            reflow(result, reflownTo, indent, limit);\n-            for (Sections current : docSections.keySet()) {\n-                boolean seenAny = false;\n-                for (DocTree t : node.getBlockTags()) {\n-                    if (current.matches(t)) {\n-                        if (!seenAny) {\n-                            seenAny = true;\n-                            startSection(current);\n-                        }\n-\n-                        scan(t, null);\n-                    }\n-                }\n-                if (current == Sections.RETURNS && !seenAny) {\n-                    List<? extends DocTree> firstSentence = node.getFirstSentence();\n-                    if (firstSentence.size() == 1\n-                            && firstSentence.get(0).getKind() == DocTree.Kind.RETURN) {\n-                        startSection(current);\n-                        scan(firstSentence.get(0), true);\n-                    }\n-                }\n-            }\n-            return null;\n-        }\n-\n-        private void startSection(Sections current) {\n-            if (result.charAt(result.length() - 1) != '\\n')\n-                result.append(\"\\n\");\n-            result.append(\"\\n\");\n-            result.append(escape(CODE_UNDERLINE))\n-                    .append(docSections.get(current))\n-                    .append(escape(CODE_RESET))\n-                    .append(\"\\n\");\n-\n-        }\n-\n-        @Override @DefinedBy(Api.COMPILER_TREE)\n-        public Object visitText(TextTree node, Object p) {\n-            String text = node.getBody();\n-            if (!pre) {\n-                text = text.replaceAll(\"[ \\t\\r\\n]+\", \" \").trim();\n-                if (text.isEmpty()) {\n-                    text = \" \";\n-                }\n-            } else {\n-                text = text.replaceAll(\"\\n\", \"\\n\" + indentString(indent));\n-            }\n-            result.append(text);\n-            return null;\n-        }\n-\n-        @Override @DefinedBy(Api.COMPILER_TREE)\n-        public Object visitLink(LinkTree node, Object p) {\n-            if (!node.getLabel().isEmpty()) {\n-                scan(node.getLabel(), p);\n-            } else {\n-                result.append(node.getReference().getSignature());\n-            }\n-            return null;\n-        }\n-\n-        @Override @DefinedBy(Api.COMPILER_TREE)\n-        public Object visitParam(ParamTree node, Object p) {\n-            return formatDef(node.getName().getName(), node.getDescription());\n-        }\n-\n-        @Override @DefinedBy(Api.COMPILER_TREE)\n-        public Object visitThrows(ThrowsTree node, Object p) {\n-            return formatDef(node.getExceptionName().getSignature(), node.getDescription());\n-        }\n-\n-        public Object formatDef(CharSequence name, List<? extends DocTree> description) {\n-            result.append(name);\n-            result.append(\" - \");\n-            reflownTo = result.length();\n-            indent = name.length() + 3;\n-\n-            if (limit - indent < SHORTEST_LINE) {\n-                result.append(\"\\n\");\n-                result.append(indentString(INDENT));\n-                indent = INDENT;\n-                reflownTo += INDENT;\n-            }\n-            try {\n-                return scan(description, null);\n-            } finally {\n-                reflow(result, reflownTo, indent, limit);\n-                result.append(\"\\n\");\n-            }\n-        }\n-\n-        @Override @DefinedBy(Api.COMPILER_TREE)\n-        public Object visitLiteral(LiteralTree node, Object p) {\n-            return scan(node.getBody(), p);\n-        }\n-\n-        \/**\n-         * {@inheritDoc}\n-         * {@code @return} is a bimodal tag and can be used as either a block tag or an inline\n-         * tag. If the parameter {@code p} is {@code null}, the node will be formatted according to\n-         * the value of {@link ReturnTree#isInline()}. If the parameter is not {@code null}, the node will\n-         * be formatted as a block tag.\n-         * @param node  {@inheritDoc}\n-         * @param p     not {@code null} to force the node to be formatted as a block tag\n-         * @return\n-         *\/\n-        @Override @DefinedBy(Api.COMPILER_TREE)\n-        public Object visitReturn(ReturnTree node, Object p) {\n-            if (node.isInline() && p == null) {\n-                String MARKER = \"{0}\";\n-                int p0 = inlineReturns.indexOf(MARKER);\n-                result.append(inlineReturns, 0, p0);\n-                try {\n-                    return super.visitReturn(node, p);\n-                } finally {\n-                    result.append(inlineReturns.substring(p0 + MARKER.length()));\n-                }\n-            } else {\n-                reflownTo = result.length();\n-                try {\n-                    return super.visitReturn(node, p);\n-                } finally {\n-                    reflow(result, reflownTo, 0, limit);\n-                }\n-            }\n-        }\n-\n-        Stack<Integer> listStack = new Stack<>();\n-        Stack<Integer> defStack = new Stack<>();\n-        Stack<Integer> tableStack = new Stack<>();\n-        Stack<List<Integer>> cellsStack = new Stack<>();\n-        Stack<List<Boolean>> headerStack = new Stack<>();\n-\n-        @Override @DefinedBy(Api.COMPILER_TREE)\n-        public Object visitStartElement(StartElementTree node, Object p) {\n-            switch (getHtmlTag(node.getName())) {\n-                case P:\n-                    if (lastNode!= null && lastNode.getKind() == DocTree.Kind.START_ELEMENT &&\n-                        HtmlTag.get(((StartElementTree) lastNode).getName()) == HtmlTag.LI) {\n-                        \/\/ignore\n-                        break;\n-                    }\n-                    reflowTillNow();\n-                    addNewLineIfNeeded(result);\n-                    result.append(indentString(indent));\n-                    reflownTo = result.length();\n-                    break;\n-                case BLOCKQUOTE:\n-                    reflowTillNow();\n-                    indent += INDENT;\n-                    break;\n-                case PRE:\n-                    reflowTillNow();\n-                    pre = true;\n-                    break;\n-                case UL:\n-                    reflowTillNow();\n-                    listStack.push(-1);\n-                    indent += INDENT;\n-                    break;\n-                case OL:\n-                    reflowTillNow();\n-                    listStack.push(1);\n-                    indent += INDENT;\n-                    break;\n-                case DL:\n-                    reflowTillNow();\n-                    defStack.push(indent);\n-                    break;\n-                case LI:\n-                    reflowTillNow();\n-                    if (!listStack.empty()) {\n-                        addNewLineIfNeeded(result);\n-\n-                        int top = listStack.pop();\n-\n-                        if (top == (-1)) {\n-                            result.append(indentString(indent - 2));\n-                            result.append(\"* \");\n-                        } else {\n-                            result.append(indentString(indent - 3));\n-                            result.append(\"\" + top++ + \". \");\n-                        }\n-\n-                        listStack.push(top);\n-\n-                        reflownTo = result.length();\n-                    }\n-                    break;\n-                case DT:\n-                    reflowTillNow();\n-                    if (!defStack.isEmpty()) {\n-                        addNewLineIfNeeded(result);\n-                        indent = defStack.peek();\n-                        result.append(escape(CODE_HIGHLIGHT));\n-                    }\n-                    break;\n-                case DD:\n-                    reflowTillNow();\n-                    if (!defStack.isEmpty()) {\n-                        if (indent == defStack.peek()) {\n-                            result.append(escape(CODE_RESET));\n-                        }\n-                        addNewLineIfNeeded(result);\n-                        indent = defStack.peek() + INDENT;\n-                        result.append(indentString(indent));\n-                    }\n-                    break;\n-                case H1: case H2: case H3:\n-                case H4: case H5: case H6:\n-                    reflowTillNow();\n-                    addNewLineIfNeeded(result);\n-                    result.append(\"\\n\")\n-                          .append(escape(CODE_UNDERLINE));\n-                    reflownTo = result.length();\n-                    break;\n-                case TABLE:\n-                    int columns = tableColumns.get(node);\n-\n-                    if (columns == 0) {\n-                        break; \/\/broken input\n-                    }\n-\n-                    reflowTillNow();\n-                    addNewLineIfNeeded(result);\n-                    reflownTo = result.length();\n-\n-                    tableStack.push(limit);\n-\n-                    limit = (limit - 1) \/ columns - 3;\n-\n-                    for (int sep = 0; sep < (limit + 3) * columns + 1; sep++) {\n-                        result.append(\"-\");\n-                    }\n-\n-                    result.append(\"\\n\");\n-\n-                    break;\n-                case TR:\n-                    if (cellsStack.size() >= tableStack.size()) {\n-                        \/\/unclosed <tr>:\n-                        handleEndElement(node.getName());\n-                    }\n-                    cellsStack.push(new ArrayList<>());\n-                    headerStack.push(new ArrayList<>());\n-                    break;\n-                case TH:\n-                case TD:\n-                    if (cellsStack.isEmpty()) {\n-                        \/\/broken code\n-                        break;\n-                    }\n-                    reflowTillNow();\n-                    result.append(\"\\n\");\n-                    reflownTo = result.length();\n-                    cellsStack.peek().add(result.length());\n-                    headerStack.peek().add(HtmlTag.get(node.getName()) == HtmlTag.TH);\n-                    break;\n-                case IMG:\n-                    for (DocTree attr : node.getAttributes()) {\n-                        if (attr.getKind() != DocTree.Kind.ATTRIBUTE) {\n-                            continue;\n-                        }\n-                        AttributeTree at = (AttributeTree) attr;\n-                        if (\"alt\".equals(StringUtils.toLowerCase(at.getName().toString()))) {\n-                            addSpaceIfNeeded(result);\n-                            scan(at.getValue(), null);\n-                            addSpaceIfNeeded(result);\n-                            break;\n-                        }\n-                    }\n-                    break;\n-                default:\n-                    addSpaceIfNeeded(result);\n-                    break;\n-            }\n-            return null;\n-        }\n-\n-        @Override @DefinedBy(Api.COMPILER_TREE)\n-        public Object visitEndElement(EndElementTree node, Object p) {\n-            handleEndElement(node.getName());\n-            return super.visitEndElement(node, p);\n-        }\n-\n-        private void handleEndElement(Name name) {\n-            switch (getHtmlTag(name)) {\n-                case BLOCKQUOTE:\n-                    indent -= INDENT;\n-                    break;\n-                case PRE:\n-                    pre = false;\n-                    addNewLineIfNeeded(result);\n-                    reflownTo = result.length();\n-                    break;\n-                case UL: case OL:\n-                    if (listStack.isEmpty()) { \/\/ignore stray closing tag\n-                        break;\n-                    }\n-                    reflowTillNow();\n-                    listStack.pop();\n-                    indent -= INDENT;\n-                    addNewLineIfNeeded(result);\n-                    break;\n-                case DL:\n-                    if (defStack.isEmpty()) {\/\/ignore stray closing tag\n-                        break;\n-                    }\n-                    reflowTillNow();\n-                    if (indent == defStack.peek()) {\n-                        result.append(escape(CODE_RESET));\n-                    }\n-                    indent = defStack.pop();\n-                    addNewLineIfNeeded(result);\n-                    break;\n-                case H1: case H2: case H3:\n-                case H4: case H5: case H6:\n-                    reflowTillNow();\n-                    result.append(escape(CODE_RESET))\n-                          .append(\"\\n\");\n-                    reflownTo = result.length();\n-                    break;\n-                case TABLE:\n-                    if (cellsStack.size() >= tableStack.size()) {\n-                        \/\/unclosed <tr>:\n-                        handleEndElement(task.getElements().getName(\"tr\"));\n-                    }\n-\n-                    if (tableStack.isEmpty()) {\n-                        break;\n-                    }\n-\n-                    limit = tableStack.pop();\n-                    break;\n-                case TR:\n-                    if (cellsStack.isEmpty()) {\n-                        break;\n-                    }\n-\n-                    reflowTillNow();\n-\n-                    List<Integer> cells = cellsStack.pop();\n-                    List<Boolean> headerFlags = headerStack.pop();\n-                    List<String[]> content = new ArrayList<>();\n-                    int maxLines = 0;\n-\n-                    result.append(\"\\n\");\n-\n-                    while (!cells.isEmpty()) {\n-                        int currentCell = cells.remove(cells.size() - 1);\n-                        String[] lines = result.substring(currentCell, result.length()).split(\"\\n\");\n-\n-                        result.delete(currentCell - 1, result.length());\n-\n-                        content.add(lines);\n-                        maxLines = Math.max(maxLines, lines.length);\n-                    }\n-\n-                    Collections.reverse(content);\n-\n-                    for (int line = 0; line < maxLines; line++) {\n-                        for (int column = 0; column < content.size(); column++) {\n-                            String[] lines = content.get(column);\n-                            String currentLine = line < lines.length ? lines[line] : \"\";\n-                            result.append(\"| \");\n-                            boolean header = headerFlags.get(column);\n-                            if (header) {\n-                                result.append(escape(CODE_HIGHLIGHT));\n-                            }\n-                            result.append(currentLine);\n-                            if (header) {\n-                                result.append(escape(CODE_RESET));\n-                            }\n-                            int padding = limit - currentLine.length();\n-                            if (padding > 0)\n-                                result.append(indentString(padding));\n-                            result.append(\" \");\n-                        }\n-                        result.append(\"|\\n\");\n-                    }\n-\n-                    for (int sep = 0; sep < (limit + 3) * content.size() + 1; sep++) {\n-                        result.append(\"-\");\n-                    }\n-\n-                    result.append(\"\\n\");\n-\n-                    reflownTo = result.length();\n-                    break;\n-                case TD:\n-                case TH:\n-                    break;\n-                default:\n-                    addSpaceIfNeeded(result);\n-                    break;\n-            }\n-        }\n-\n-        @Override @DefinedBy(Api.COMPILER_TREE)\n-        public Object visitEntity(EntityTree node, Object p) {\n-            String value = trees.getCharacters(node);\n-            result.append(value == null ? node.toString() : value);\n-            return super.visitEntity(node, p);\n-\n-        }\n-\n-        private DocTree lastNode;\n-\n-        @Override @DefinedBy(Api.COMPILER_TREE)\n-        public Object scan(DocTree node, Object p) {\n-            if (node instanceof InlineTagTree) {\n-                addSpaceIfNeeded(result);\n-            }\n-            try {\n-                return super.scan(node, p);\n-            } finally {\n-                if (node instanceof InlineTagTree) {\n-                    addSpaceIfNeeded(result);\n-                }\n-                lastNode = node;\n-            }\n-        }\n-\n-        private void reflowTillNow() {\n-            while (result.length() > 0 && result.charAt(result.length() - 1) == ' ')\n-                result.delete(result.length() - 1, result.length());\n-            reflownTo = Math.min(reflownTo, result.length());\n-            reflow(result, reflownTo, indent, limit);\n-            reflownTo = result.length();\n-        }\n-    };\n-\n-    private String escape(String sequence) {\n-        return this.escapeSequencesSupported ? sequence : \"\";\n-    }\n-\n-    private static final Map<Sections, String> docSections = new LinkedHashMap<>();\n-    private static final String inlineReturns;\n-\n-    static {\n-        ResourceBundle bundle =\n-                ResourceBundle.getBundle(\"jdk.internal.shellsupport.doc.resources.javadocformatter\");\n-        docSections.put(Sections.TYPE_PARAMS, bundle.getString(\"CAP_TypeParameters\"));\n-        docSections.put(Sections.PARAMS, bundle.getString(\"CAP_Parameters\"));\n-        docSections.put(Sections.RETURNS, bundle.getString(\"CAP_Returns\"));\n-        docSections.put(Sections.THROWS, bundle.getString(\"CAP_Thrown_Exceptions\"));\n-        inlineReturns = bundle.getString(\"Inline_Returns\");\n-    }\n-\n-    private static String indentString(int indent) {\n-        char[] content = new char[indent];\n-        Arrays.fill(content, ' ');\n-        return new String(content);\n-    }\n-\n-    private static void reflow(StringBuilder text, int from, int indent, int limit) {\n-        int lineStart = from;\n-\n-        while (lineStart > 0 && text.charAt(lineStart - 1) != '\\n') {\n-            lineStart--;\n-        }\n-\n-        int lineChars = from - lineStart;\n-        int pointer = from;\n-        int lastSpace = -1;\n-\n-        while (pointer < text.length()) {\n-            if (text.charAt(pointer) == ' ')\n-                lastSpace = pointer;\n-            if (lineChars >= limit) {\n-                if (lastSpace != (-1)) {\n-                    text.setCharAt(lastSpace, '\\n');\n-                    text.insert(lastSpace + 1, indentString(indent));\n-                    lineChars = indent + pointer - lastSpace - 1;\n-                    pointer += indent;\n-                    lastSpace = -1;\n-                }\n-            }\n-            lineChars++;\n-            pointer++;\n-        }\n-    }\n-\n-    private static void addNewLineIfNeeded(StringBuilder text) {\n-        if (text.length() > 0 && text.charAt(text.length() - 1) != '\\n') {\n-            text.append(\"\\n\");\n-        }\n-    }\n-\n-    private static void addSpaceIfNeeded(StringBuilder text) {\n-        if (text.length() == 0)\n-            return ;\n-\n-        char last = text.charAt(text.length() - 1);\n-\n-        if (last != ' ' && last != '\\n') {\n-            text.append(\" \");\n-        }\n-    }\n-\n-    private static HtmlTag getHtmlTag(Name name) {\n-        HtmlTag tag = HtmlTag.get(name);\n-\n-        return tag != null ? tag : HtmlTag.HTML; \/\/using HtmlTag.HTML as default no-op value\n-    }\n-\n-    private static Map<StartElementTree, Integer> countTableColumns(DocCommentTree dct) {\n-        Map<StartElementTree, Integer> result = new IdentityHashMap<>();\n-\n-        new DocTreeScanner<Void, Void>() {\n-            private StartElementTree currentTable;\n-            private int currentMaxColumns;\n-            private int currentRowColumns;\n-\n-            @Override @DefinedBy(Api.COMPILER_TREE)\n-            public Void visitStartElement(StartElementTree node, Void p) {\n-                switch (getHtmlTag(node.getName())) {\n-                    case TABLE: currentTable = node; break;\n-                    case TR:\n-                        currentMaxColumns = Math.max(currentMaxColumns, currentRowColumns);\n-                        currentRowColumns = 0;\n-                        break;\n-                    case TD:\n-                    case TH: currentRowColumns++; break;\n-                }\n-                return super.visitStartElement(node, p);\n-            }\n-\n-            @Override @DefinedBy(Api.COMPILER_TREE)\n-            public Void visitEndElement(EndElementTree node, Void p) {\n-                if (HtmlTag.get(node.getName()) == HtmlTag.TABLE) {\n-                    closeTable();\n-                }\n-                return super.visitEndElement(node, p);\n-            }\n-\n-            @Override @DefinedBy(Api.COMPILER_TREE)\n-            public Void visitDocComment(DocCommentTree node, Void p) {\n-                try {\n-                    return super.visitDocComment(node, p);\n-                } finally {\n-                    closeTable();\n-                }\n-            }\n-\n-            private void closeTable() {\n-                if (currentTable != null) {\n-                    result.put(currentTable, Math.max(currentMaxColumns, currentRowColumns));\n-                    currentTable = null;\n-                }\n-            }\n-        }.scan(dct, null);\n-\n-        return result;\n-    }\n-\n-    private enum Sections {\n-        TYPE_PARAMS {\n-            @Override public boolean matches(DocTree t) {\n-                return t.getKind() == DocTree.Kind.PARAM && ((ParamTree) t).isTypeParameter();\n-            }\n-        },\n-        PARAMS {\n-            @Override public boolean matches(DocTree t) {\n-                return t.getKind() == DocTree.Kind.PARAM && !((ParamTree) t).isTypeParameter();\n-            }\n-        },\n-        RETURNS {\n-            @Override public boolean matches(DocTree t) {\n-                return t.getKind() == DocTree.Kind.RETURN;\n-            }\n-        },\n-        THROWS {\n-            @Override public boolean matches(DocTree t) {\n-                return t.getKind() == DocTree.Kind.THROWS;\n-            }\n-        };\n-\n-        public abstract boolean matches(DocTree t);\n-    }\n-}\n","filename":"src\/jdk.compiler\/share\/classes\/jdk\/internal\/shellsupport\/doc\/JavadocFormatter.java","additions":0,"deletions":750,"binary":false,"changes":750,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -260,2 +260,0 @@\n-    exports jdk.internal.shellsupport.doc to\n-        jdk.jshell;\n","filename":"src\/jdk.compiler\/share\/classes\/module-info.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,868 @@\n+\/*\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.shellsupport.doc;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.IdentityHashMap;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ResourceBundle;\n+import java.util.Stack;\n+import java.util.regex.Pattern;\n+import java.util.stream.StreamSupport;\n+\n+import javax.lang.model.element.Name;\n+import javax.tools.JavaFileObject.Kind;\n+import javax.tools.SimpleJavaFileObject;\n+import javax.tools.ToolProvider;\n+\n+import com.sun.source.doctree.AttributeTree;\n+import com.sun.source.doctree.DocCommentTree;\n+import com.sun.source.doctree.DocTree;\n+import com.sun.source.doctree.EndElementTree;\n+import com.sun.source.doctree.EntityTree;\n+import com.sun.source.doctree.InlineTagTree;\n+import com.sun.source.doctree.LinkTree;\n+import com.sun.source.doctree.LiteralTree;\n+import com.sun.source.doctree.MarkdownTree;\n+import com.sun.source.doctree.ParamTree;\n+import com.sun.source.doctree.ReturnTree;\n+import com.sun.source.doctree.SnippetTree;\n+import com.sun.source.doctree.StartElementTree;\n+import com.sun.source.doctree.SystemPropertyTree;\n+import com.sun.source.doctree.TextTree;\n+import com.sun.source.doctree.ThrowsTree;\n+import com.sun.source.util.DocTreeScanner;\n+import com.sun.source.util.DocTrees;\n+import com.sun.source.util.JavacTask;\n+import com.sun.tools.javac.util.DefinedBy;\n+import com.sun.tools.javac.util.DefinedBy.Api;\n+import com.sun.tools.javac.util.StringUtils;\n+import jdk.internal.org.commonmark.node.Node;\n+import jdk.internal.org.commonmark.parser.Parser;\n+import jdk.internal.org.commonmark.renderer.html.HtmlRenderer;\n+\n+\/**A javadoc to plain text formatter.\n+ *\n+ *\/\n+public class JavadocFormatter {\n+\n+    private static final String CODE_RESET = \"\\033[0m\";\n+    private static final String CODE_HIGHLIGHT = \"\\033[1m\";\n+    private static final String CODE_UNDERLINE = \"\\033[4m\";\n+\n+    private final int lineLimit;\n+    private final boolean escapeSequencesSupported;\n+\n+    \/** Construct the formatter.\n+     *\n+     * @param lineLimit maximum line length\n+     * @param escapeSequencesSupported whether escape sequences are supported\n+     *\/\n+    public JavadocFormatter(int lineLimit, boolean escapeSequencesSupported) {\n+        this.lineLimit = lineLimit;\n+        this.escapeSequencesSupported = escapeSequencesSupported;\n+    }\n+\n+    private static final int MAX_LINE_LENGTH = 95;\n+    private static final int SHORTEST_LINE = 30;\n+    private static final int INDENT = 4;\n+\n+    \/**Format javadoc to plain text.\n+     *\n+     * @param header element caption that should be used\n+     * @param javadoc to format\n+     * @return javadoc formatted to plain text\n+     *\/\n+    public String formatJavadoc(String header, String javadoc) {\n+        try {\n+            StringBuilder result = new StringBuilder();\n+\n+            result.append(escape(CODE_HIGHLIGHT)).append(header).append(escape(CODE_RESET)).append(\"\\n\");\n+\n+            if (javadoc == null) {\n+                return result.toString();\n+            }\n+\n+            JavacTask task = (JavacTask) ToolProvider.getSystemJavaCompiler().getTask(null, null, null, null, null, null);\n+            DocTrees trees = DocTrees.instance(task);\n+            DocCommentTree docComment = trees.getDocCommentTree(new SimpleJavaFileObject(new URI(\"mem:\/\/doc.html\"), Kind.HTML) {\n+                @Override @DefinedBy(Api.COMPILER)\n+                public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {\n+                    boolean isMarkDown = javadoc.startsWith(\"md\") && Character.isWhitespace(javadoc.charAt(2));\n+                    return isMarkDown ? javadoc : \"<body>\" + javadoc + \"<\/body>\";\n+                }\n+            });\n+\n+            new FormatJavadocScanner(result, task).scan(docComment, null);\n+\n+            addNewLineIfNeeded(result);\n+\n+            return result.toString();\n+        } catch (URISyntaxException ex) {\n+            throw new InternalError(\"Unexpected exception\", ex);\n+        }\n+    }\n+\n+    enum HtmlTag {\n+        HTML,\n+        H1, H2, H3, H4, H5, H6,\n+        BLOCKQUOTE, P, PRE,\n+        IMG,\n+        OL, UL, LI,\n+        DL, DT, DD,\n+        TABLE, TR, TD, TH;\n+\n+        private static final Map<String, HtmlTag> index = new HashMap<>();\n+        static {\n+            for (HtmlTag t: values()) {\n+                index.put(StringUtils.toLowerCase(t.name()), t);\n+            }\n+        }\n+\n+        public static HtmlTag get(Name tagName) {\n+            return index.get(StringUtils.toLowerCase(tagName.toString()));\n+        }\n+    }\n+\n+    private class FormatJavadocScanner extends DocTreeScanner<Object, Object> {\n+        private static final char FFFC = '\\uFFFC'; \/\/ Unicode Object Replacement Character\n+        private static final Pattern FFFC_PATTERN = Pattern.compile(Pattern.quote(\"\" + FFFC));\n+\n+        private final StringBuilder result;\n+        private final JavacTask task;\n+        private final DocTrees trees;\n+        private int reflownTo;\n+        private int indent;\n+        private int limit = Math.min(lineLimit, MAX_LINE_LENGTH);\n+        private boolean pre;\n+        private Map<StartElementTree, Integer> tableColumns;\n+\n+        public FormatJavadocScanner(StringBuilder result, JavacTask task) {\n+            this.result = result;\n+            this.task = task;\n+            this.trees = DocTrees.instance(task);\n+        }\n+\n+        @Override @DefinedBy(Api.COMPILER_TREE)\n+        public Object visitDocComment(DocCommentTree node, Object p) {\n+            tableColumns = countTableColumns(node);\n+            reflownTo = result.length();\n+            scan(node.getFirstSentence(), p);\n+            scan(node.getBody(), p);\n+            reflow(result, reflownTo, indent, limit);\n+            for (Sections current : docSections.keySet()) {\n+                boolean seenAny = false;\n+                for (DocTree t : node.getBlockTags()) {\n+                    if (current.matches(t)) {\n+                        if (!seenAny) {\n+                            seenAny = true;\n+                            startSection(current);\n+                        }\n+\n+                        scan(t, null);\n+                    }\n+                }\n+                if (current == Sections.RETURNS && !seenAny) {\n+                    List<? extends DocTree> firstSentence = node.getFirstSentence();\n+                    if (firstSentence.size() == 1\n+                            && firstSentence.get(0).getKind() == DocTree.Kind.RETURN) {\n+                        startSection(current);\n+                        scan(firstSentence.get(0), true);\n+                    }\n+                }\n+            }\n+            return null;\n+        }\n+\n+        private void startSection(Sections current) {\n+            if (result.charAt(result.length() - 1) != '\\n')\n+                result.append(\"\\n\");\n+            result.append(\"\\n\");\n+            result.append(escape(CODE_UNDERLINE))\n+                    .append(docSections.get(current))\n+                    .append(escape(CODE_RESET))\n+                    .append(\"\\n\");\n+\n+        }\n+\n+        @Override @DefinedBy(Api.COMPILER_TREE)\n+        public Object visitText(TextTree node, Object p) {\n+            String text = node.getBody();\n+            if (!pre) {\n+                text = text.replaceAll(\"[ \\t\\r\\n]+\", \" \").trim();\n+                if (text.isEmpty()) {\n+                    text = \" \";\n+                }\n+            } else {\n+                text = text.replaceAll(\"\\n\", \"\\n\" + indentString(indent));\n+            }\n+            boolean first = true;\n+            for (String part : FFFC_PATTERN.split(text, -1)) {\n+                if (!first) {\n+                    Object nested = injects.remove(0);\n+                    if (nested instanceof DocTree nestedTree) {\n+                        scan(nestedTree, null);\n+                    } else {\n+                        result.append(nested);\n+                    }\n+                    while (part.length() > 0 && Character.isWhitespace(part.charAt(0)) && !pre) {\n+                        part = part.substring(1);\n+                    }\n+                } else {\n+                    first = false;\n+                }\n+                \/\/remove space right before dot or comma:\n+                if (!result.isEmpty() && !part.isEmpty() &&\n+                    result.charAt(result.length() - 1) == ' ' &&\n+                    (part.charAt(0) == '.' || part.charAt(0) == ',')) {\n+                    result.delete(result.length() - 1, result.length());\n+                }\n+                result.append(part);\n+            }\n+            return null;\n+        }\n+\n+        @Override @DefinedBy(Api.COMPILER_TREE)\n+        public Object visitLink(LinkTree node, Object p) {\n+            if (!node.getLabel().isEmpty()) {\n+                scan(node.getLabel(), p);\n+            } else {\n+                result.append(node.getReference().getSignature());\n+            }\n+            return null;\n+        }\n+\n+        @Override @DefinedBy(Api.COMPILER_TREE)\n+        public Object visitParam(ParamTree node, Object p) {\n+            return formatDef(node.getName().getName(), node.getDescription());\n+        }\n+\n+        @Override @DefinedBy(Api.COMPILER_TREE)\n+        public Object visitThrows(ThrowsTree node, Object p) {\n+            return formatDef(node.getExceptionName().getSignature(), node.getDescription());\n+        }\n+\n+        public Object formatDef(CharSequence name, List<? extends DocTree> description) {\n+            result.append(name);\n+            result.append(\" - \");\n+            reflownTo = result.length();\n+            indent = name.length() + 3;\n+\n+            if (limit - indent < SHORTEST_LINE) {\n+                result.append(\"\\n\");\n+                result.append(indentString(INDENT));\n+                indent = INDENT;\n+                reflownTo += INDENT;\n+            }\n+            try {\n+                return scan(description, null);\n+            } finally {\n+                reflow(result, reflownTo, indent, limit);\n+                result.append(\"\\n\");\n+            }\n+        }\n+\n+        @Override @DefinedBy(Api.COMPILER_TREE)\n+        public Object visitLiteral(LiteralTree node, Object p) {\n+            return scan(node.getBody(), p);\n+        }\n+\n+        \/**\n+         * {@inheritDoc}\n+         * {@code @return} is a bimodal tag and can be used as either a block tag or an inline\n+         * tag. If the parameter {@code p} is {@code null}, the node will be formatted according to\n+         * the value of {@link ReturnTree#isInline()}. If the parameter is not {@code null}, the node will\n+         * be formatted as a block tag.\n+         * @param node  {@inheritDoc}\n+         * @param p     not {@code null} to force the node to be formatted as a block tag\n+         * @return\n+         *\/\n+        @Override @DefinedBy(Api.COMPILER_TREE)\n+        public Object visitReturn(ReturnTree node, Object p) {\n+            if (node.isInline() && p == null) {\n+                String MARKER = \"{0}\";\n+                int p0 = inlineReturns.indexOf(MARKER);\n+                result.append(inlineReturns, 0, p0);\n+                try {\n+                    return super.visitReturn(node, p);\n+                } finally {\n+                    result.append(inlineReturns.substring(p0 + MARKER.length()));\n+                }\n+            } else {\n+                reflownTo = result.length();\n+                try {\n+                    return super.visitReturn(node, p);\n+                } finally {\n+                    reflow(result, reflownTo, 0, limit);\n+                }\n+            }\n+        }\n+\n+        Stack<Integer> listStack = new Stack<>();\n+        Stack<Integer> defStack = new Stack<>();\n+        Stack<Integer> tableStack = new Stack<>();\n+        Stack<List<Integer>> cellsStack = new Stack<>();\n+        Stack<List<Boolean>> headerStack = new Stack<>();\n+\n+        @Override @DefinedBy(Api.COMPILER_TREE)\n+        public Object visitStartElement(StartElementTree node, Object p) {\n+            switch (getHtmlTag(node.getName())) {\n+                case P:\n+                    if (lastNode!= null && lastNode.getKind() == DocTree.Kind.START_ELEMENT &&\n+                        HtmlTag.get(((StartElementTree) lastNode).getName()) == HtmlTag.LI) {\n+                        \/\/ignore\n+                        break;\n+                    }\n+                    reflowTillNow();\n+                    addNewLineIfNeeded(result);\n+                    result.append(indentString(indent));\n+                    reflownTo = result.length();\n+                    break;\n+                case BLOCKQUOTE:\n+                    reflowTillNow();\n+                    indent += INDENT;\n+                    break;\n+                case PRE:\n+                    reflowTillNow();\n+                    pre = true;\n+                    break;\n+                case UL:\n+                    reflowTillNow();\n+                    listStack.push(-1);\n+                    indent += INDENT;\n+                    break;\n+                case OL:\n+                    reflowTillNow();\n+                    listStack.push(1);\n+                    indent += INDENT;\n+                    break;\n+                case DL:\n+                    reflowTillNow();\n+                    defStack.push(indent);\n+                    break;\n+                case LI:\n+                    reflowTillNow();\n+                    if (!listStack.empty()) {\n+                        addNewLineIfNeeded(result);\n+\n+                        int top = listStack.pop();\n+\n+                        if (top == (-1)) {\n+                            result.append(indentString(indent - 2));\n+                            result.append(\"* \");\n+                        } else {\n+                            result.append(indentString(indent - 3));\n+                            result.append(\"\" + top++ + \". \");\n+                        }\n+\n+                        listStack.push(top);\n+\n+                        reflownTo = result.length();\n+                    }\n+                    break;\n+                case DT:\n+                    reflowTillNow();\n+                    if (!defStack.isEmpty()) {\n+                        addNewLineIfNeeded(result);\n+                        indent = defStack.peek();\n+                        result.append(escape(CODE_HIGHLIGHT));\n+                    }\n+                    break;\n+                case DD:\n+                    reflowTillNow();\n+                    if (!defStack.isEmpty()) {\n+                        if (indent == defStack.peek()) {\n+                            result.append(escape(CODE_RESET));\n+                        }\n+                        addNewLineIfNeeded(result);\n+                        indent = defStack.peek() + INDENT;\n+                        result.append(indentString(indent));\n+                    }\n+                    break;\n+                case H1: case H2: case H3:\n+                case H4: case H5: case H6:\n+                    reflowTillNow();\n+                    addNewLineIfNeeded(result);\n+                    result.append(\"\\n\")\n+                          .append(escape(CODE_UNDERLINE));\n+                    reflownTo = result.length();\n+                    break;\n+                case TABLE:\n+                    int columns = tableColumns.get(node);\n+\n+                    if (columns == 0) {\n+                        break; \/\/broken input\n+                    }\n+\n+                    reflowTillNow();\n+                    addNewLineIfNeeded(result);\n+                    reflownTo = result.length();\n+\n+                    tableStack.push(limit);\n+\n+                    limit = (limit - 1) \/ columns - 3;\n+\n+                    for (int sep = 0; sep < (limit + 3) * columns + 1; sep++) {\n+                        result.append(\"-\");\n+                    }\n+\n+                    result.append(\"\\n\");\n+\n+                    break;\n+                case TR:\n+                    if (cellsStack.size() >= tableStack.size()) {\n+                        \/\/unclosed <tr>:\n+                        handleEndElement(node.getName());\n+                    }\n+                    cellsStack.push(new ArrayList<>());\n+                    headerStack.push(new ArrayList<>());\n+                    break;\n+                case TH:\n+                case TD:\n+                    if (cellsStack.isEmpty()) {\n+                        \/\/broken code\n+                        break;\n+                    }\n+                    reflowTillNow();\n+                    result.append(\"\\n\");\n+                    reflownTo = result.length();\n+                    cellsStack.peek().add(result.length());\n+                    headerStack.peek().add(HtmlTag.get(node.getName()) == HtmlTag.TH);\n+                    break;\n+                case IMG:\n+                    for (DocTree attr : node.getAttributes()) {\n+                        if (attr.getKind() != DocTree.Kind.ATTRIBUTE) {\n+                            continue;\n+                        }\n+                        AttributeTree at = (AttributeTree) attr;\n+                        if (\"alt\".equals(StringUtils.toLowerCase(at.getName().toString()))) {\n+                            addSpaceIfNeeded(result);\n+                            scan(at.getValue(), null);\n+                            addSpaceIfNeeded(result);\n+                            break;\n+                        }\n+                    }\n+                    break;\n+                default:\n+                    addSpaceIfNeeded(result);\n+                    break;\n+            }\n+            return null;\n+        }\n+\n+        @Override @DefinedBy(Api.COMPILER_TREE)\n+        public Object visitEndElement(EndElementTree node, Object p) {\n+            handleEndElement(node.getName());\n+            return super.visitEndElement(node, p);\n+        }\n+\n+        private void handleEndElement(Name name) {\n+            switch (getHtmlTag(name)) {\n+                case BLOCKQUOTE:\n+                    indent -= INDENT;\n+                    break;\n+                case PRE:\n+                    pre = false;\n+                    addNewLineIfNeeded(result);\n+                    reflownTo = result.length();\n+                    break;\n+                case UL: case OL:\n+                    if (listStack.isEmpty()) { \/\/ignore stray closing tag\n+                        break;\n+                    }\n+                    reflowTillNow();\n+                    listStack.pop();\n+                    indent -= INDENT;\n+                    addNewLineIfNeeded(result);\n+                    break;\n+                case DL:\n+                    if (defStack.isEmpty()) {\/\/ignore stray closing tag\n+                        break;\n+                    }\n+                    reflowTillNow();\n+                    if (indent == defStack.peek()) {\n+                        result.append(escape(CODE_RESET));\n+                    }\n+                    indent = defStack.pop();\n+                    addNewLineIfNeeded(result);\n+                    break;\n+                case H1: case H2: case H3:\n+                case H4: case H5: case H6:\n+                    reflowTillNow();\n+                    result.append(escape(CODE_RESET))\n+                          .append(\"\\n\");\n+                    reflownTo = result.length();\n+                    break;\n+                case TABLE:\n+                    if (cellsStack.size() >= tableStack.size()) {\n+                        \/\/unclosed <tr>:\n+                        handleEndElement(task.getElements().getName(\"tr\"));\n+                    }\n+\n+                    if (tableStack.isEmpty()) {\n+                        break;\n+                    }\n+\n+                    limit = tableStack.pop();\n+                    break;\n+                case TR:\n+                    if (cellsStack.isEmpty()) {\n+                        break;\n+                    }\n+\n+                    reflowTillNow();\n+\n+                    List<Integer> cells = cellsStack.pop();\n+                    List<Boolean> headerFlags = headerStack.pop();\n+                    List<String[]> content = new ArrayList<>();\n+                    int maxLines = 0;\n+\n+                    result.append(\"\\n\");\n+\n+                    while (!cells.isEmpty()) {\n+                        int currentCell = cells.remove(cells.size() - 1);\n+                        String[] lines = result.substring(currentCell, result.length()).split(\"\\n\");\n+\n+                        result.delete(currentCell - 1, result.length());\n+\n+                        content.add(lines);\n+                        maxLines = Math.max(maxLines, lines.length);\n+                    }\n+\n+                    Collections.reverse(content);\n+\n+                    for (int line = 0; line < maxLines; line++) {\n+                        for (int column = 0; column < content.size(); column++) {\n+                            String[] lines = content.get(column);\n+                            String currentLine = line < lines.length ? lines[line] : \"\";\n+                            result.append(\"| \");\n+                            boolean header = headerFlags.get(column);\n+                            if (header) {\n+                                result.append(escape(CODE_HIGHLIGHT));\n+                            }\n+                            result.append(currentLine);\n+                            if (header) {\n+                                result.append(escape(CODE_RESET));\n+                            }\n+                            int padding = limit - currentLine.length();\n+                            if (padding > 0)\n+                                result.append(indentString(padding));\n+                            result.append(\" \");\n+                        }\n+                        result.append(\"|\\n\");\n+                    }\n+\n+                    for (int sep = 0; sep < (limit + 3) * content.size() + 1; sep++) {\n+                        result.append(\"-\");\n+                    }\n+\n+                    result.append(\"\\n\");\n+\n+                    reflownTo = result.length();\n+                    break;\n+                case TD:\n+                case TH:\n+                    break;\n+                default:\n+                    addSpaceIfNeeded(result);\n+                    break;\n+            }\n+        }\n+\n+        @Override @DefinedBy(Api.COMPILER_TREE)\n+        public Object visitEntity(EntityTree node, Object p) {\n+            String value = trees.getCharacters(node);\n+            result.append(value == null ? node.toString() : value);\n+            return super.visitEntity(node, p);\n+\n+        }\n+\n+        @Override\n+        public Object visitSystemProperty(SystemPropertyTree node, Object p) {\n+            result.append(node.getPropertyName());\n+            return null;\n+        }\n+\n+        @Override\n+        public Object visitSnippet(SnippetTree node, Object p) {\n+            boolean prevPre = pre;\n+            try {\n+                reflowTillNow();\n+                pre = true;\n+                return scan(node.getBody(), p);\n+            } finally {\n+                reflownTo = result.length();\n+                pre = prevPre;\n+            }\n+        }\n+\n+        private List<Object> injects = null;\n+\n+        @Override\n+        public Object scan(Iterable<? extends DocTree> nodes, Object p) {\n+            boolean hasMarkDown = StreamSupport.stream(nodes.spliterator(), false)\n+                                               .anyMatch(t -> t.getKind() == DocTree.Kind.MARKDOWN);\n+            if (!hasMarkDown) {\n+                return super.scan(nodes, p);\n+            }\n+\n+            List<Object> prevInjects = injects;\n+            Map<StartElementTree, Integer> prevTableColumns = tableColumns;\n+            try {\n+                StringBuilder realMarkDownContent = new StringBuilder();\n+\n+                injects = new LinkedList<>();\n+\n+                for (DocTree node : nodes) {\n+                    if (node.getKind() == DocTree.Kind.MARKDOWN) {\n+                        String code = ((MarkdownTree) node).getContent();\n+                        boolean first = true;\n+\n+                        for (String part : FFFC_PATTERN.split(code, -1)) {\n+                            if (first) {\n+                                first = false;\n+                            } else {\n+                                realMarkDownContent.append(FFFC);\n+                                injects.add(FFFC);\n+                            }\n+                            realMarkDownContent.append(part);\n+                        }\n+                    } else {\n+                        realMarkDownContent.append(FFFC);\n+                        injects.add(node);\n+                    }\n+                }\n+\n+                Parser parser = Parser.builder().build();\n+                Node document = parser.parse(realMarkDownContent.toString());\n+                HtmlRenderer renderer = HtmlRenderer.builder().build();\n+                String markdownOutput = renderer.render(document);\n+                DocCommentTree docComment = trees.getDocCommentTree(new SimpleJavaFileObject(new URI(\"mem:\/\/doc.html\"), Kind.HTML) {\n+                    @Override @DefinedBy(Api.COMPILER)\n+                    public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {\n+                        return \"<body>\" + markdownOutput + \"<\/body>\";\n+                    }\n+                });\n+\n+                tableColumns = countTableColumns(docComment);\n+                scan(docComment.getFullBody(), p);\n+            } catch (URISyntaxException ex) {\n+                throw new InternalError(ex);\n+            } finally {\n+                tableColumns = prevTableColumns;\n+                injects = prevInjects;\n+            }\n+            return null;\n+        }\n+\n+        @Override @DefinedBy(Api.COMPILER_TREE)\n+        public Object visitMarkdown(MarkdownTree node, Object p) {\n+            throw new IllegalStateException(\"Should not get here.\");\n+        }\n+\n+        private DocTree lastNode;\n+\n+        @Override @DefinedBy(Api.COMPILER_TREE)\n+        public Object scan(DocTree node, Object p) {\n+            if (node instanceof InlineTagTree) {\n+                addSpaceIfNeeded(result);\n+            }\n+            try {\n+                return super.scan(node, p);\n+            } finally {\n+                if (node instanceof InlineTagTree) {\n+                    addSpaceIfNeeded(result);\n+                }\n+                lastNode = node;\n+            }\n+        }\n+\n+        private void reflowTillNow() {\n+            while (result.length() > 0 && result.charAt(result.length() - 1) == ' ')\n+                result.delete(result.length() - 1, result.length());\n+            reflownTo = Math.min(reflownTo, result.length());\n+            reflow(result, reflownTo, indent, limit);\n+            reflownTo = result.length();\n+        }\n+    };\n+\n+    private String escape(String sequence) {\n+        return this.escapeSequencesSupported ? sequence : \"\";\n+    }\n+\n+    private static final Map<Sections, String> docSections = new LinkedHashMap<>();\n+    private static final String inlineReturns;\n+\n+    static {\n+        ResourceBundle bundle =\n+                ResourceBundle.getBundle(\"jdk.internal.shellsupport.doc.resources.javadocformatter\");\n+        docSections.put(Sections.TYPE_PARAMS, bundle.getString(\"CAP_TypeParameters\"));\n+        docSections.put(Sections.PARAMS, bundle.getString(\"CAP_Parameters\"));\n+        docSections.put(Sections.RETURNS, bundle.getString(\"CAP_Returns\"));\n+        docSections.put(Sections.THROWS, bundle.getString(\"CAP_Thrown_Exceptions\"));\n+        inlineReturns = bundle.getString(\"Inline_Returns\");\n+    }\n+\n+    private static String indentString(int indent) {\n+        char[] content = new char[indent];\n+        Arrays.fill(content, ' ');\n+        return new String(content);\n+    }\n+\n+    private static void reflow(StringBuilder text, int from, int indent, int limit) {\n+        int lineStart = from;\n+\n+        while (lineStart > 0 && text.charAt(lineStart - 1) != '\\n') {\n+            lineStart--;\n+        }\n+\n+        int lineChars = from - lineStart;\n+        int pointer = from;\n+        int lastSpace = -1;\n+\n+        while (pointer < text.length()) {\n+            if (text.charAt(pointer) == ' ')\n+                lastSpace = pointer;\n+            if (lineChars >= limit) {\n+                if (lastSpace != (-1)) {\n+                    text.setCharAt(lastSpace, '\\n');\n+                    text.insert(lastSpace + 1, indentString(indent));\n+                    lineChars = indent + pointer - lastSpace - 1;\n+                    pointer += indent;\n+                    lastSpace = -1;\n+                }\n+            }\n+            lineChars++;\n+            pointer++;\n+        }\n+    }\n+\n+    private static void addNewLineIfNeeded(StringBuilder text) {\n+        if (text.length() > 0 && text.charAt(text.length() - 1) != '\\n') {\n+            text.append(\"\\n\");\n+        }\n+    }\n+\n+    private static void addSpaceIfNeeded(StringBuilder text) {\n+        if (text.length() == 0)\n+            return ;\n+\n+        char last = text.charAt(text.length() - 1);\n+\n+        if (last != ' ' && last != '\\n') {\n+            text.append(\" \");\n+        }\n+    }\n+\n+    private static HtmlTag getHtmlTag(Name name) {\n+        HtmlTag tag = HtmlTag.get(name);\n+\n+        return tag != null ? tag : HtmlTag.HTML; \/\/using HtmlTag.HTML as default no-op value\n+    }\n+\n+    private static Map<StartElementTree, Integer> countTableColumns(DocCommentTree dct) {\n+        Map<StartElementTree, Integer> result = new IdentityHashMap<>();\n+\n+        new DocTreeScanner<Void, Void>() {\n+            private StartElementTree currentTable;\n+            private int currentMaxColumns;\n+            private int currentRowColumns;\n+\n+            @Override @DefinedBy(Api.COMPILER_TREE)\n+            public Void visitStartElement(StartElementTree node, Void p) {\n+                switch (getHtmlTag(node.getName())) {\n+                    case TABLE: currentTable = node; break;\n+                    case TR:\n+                        currentMaxColumns = Math.max(currentMaxColumns, currentRowColumns);\n+                        currentRowColumns = 0;\n+                        break;\n+                    case TD:\n+                    case TH: currentRowColumns++; break;\n+                }\n+                return super.visitStartElement(node, p);\n+            }\n+\n+            @Override @DefinedBy(Api.COMPILER_TREE)\n+            public Void visitEndElement(EndElementTree node, Void p) {\n+                if (HtmlTag.get(node.getName()) == HtmlTag.TABLE) {\n+                    closeTable();\n+                }\n+                return super.visitEndElement(node, p);\n+            }\n+\n+            @Override @DefinedBy(Api.COMPILER_TREE)\n+            public Void visitDocComment(DocCommentTree node, Void p) {\n+                try {\n+                    return super.visitDocComment(node, p);\n+                } finally {\n+                    closeTable();\n+                }\n+            }\n+\n+            private void closeTable() {\n+                if (currentTable != null) {\n+                    result.put(currentTable, Math.max(currentMaxColumns, currentRowColumns));\n+                    currentTable = null;\n+                }\n+            }\n+        }.scan(dct, null);\n+\n+        return result;\n+    }\n+\n+    private enum Sections {\n+        TYPE_PARAMS {\n+            @Override public boolean matches(DocTree t) {\n+                return t.getKind() == DocTree.Kind.PARAM && ((ParamTree) t).isTypeParameter();\n+            }\n+        },\n+        PARAMS {\n+            @Override public boolean matches(DocTree t) {\n+                return t.getKind() == DocTree.Kind.PARAM && !((ParamTree) t).isTypeParameter();\n+            }\n+        },\n+        RETURNS {\n+            @Override public boolean matches(DocTree t) {\n+                return t.getKind() == DocTree.Kind.RETURN;\n+            }\n+        },\n+        THROWS {\n+            @Override public boolean matches(DocTree t) {\n+                return t.getKind() == DocTree.Kind.THROWS;\n+            }\n+        };\n+\n+        public abstract boolean matches(DocTree t);\n+    }\n+}\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/internal\/shellsupport\/doc\/JavadocFormatter.java","additions":868,"deletions":0,"binary":false,"changes":868,"status":"added"},{"patch":"","filename":"src\/jdk.jshell\/share\/classes\/jdk\/internal\/shellsupport\/doc\/JavadocHelper.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.compiler\/share\/classes\/jdk\/internal\/shellsupport\/doc\/JavadocHelper.java","status":"renamed"},{"patch":"","filename":"src\/jdk.jshell\/share\/classes\/jdk\/internal\/shellsupport\/doc\/resources\/javadocformatter.properties","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/jdk.compiler\/share\/classes\/jdk\/internal\/shellsupport\/doc\/resources\/javadocformatter.properties","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -71,0 +71,1 @@\n+    requires jdk.internal.md;\n","filename":"src\/jdk.jshell\/share\/classes\/module-info.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @modules jdk.compiler\/jdk.internal.shellsupport.doc\n+ * @modules jdk.jshell\/jdk.internal.shellsupport.doc\n@@ -416,0 +416,65 @@\n+    public void testMarkDown() {\n+        String header = \"test\";\n+        String javadoc = \"\"\"\n+                         md\n+\n+                         MarkDown test.\n+\n+                          1. first list item\n+                          1. testing {@code code} inside a list\n+                          1. another \\uFFFClist item\n+                         \"\"\";\n+\n+        String actual;\n+        String expected;\n+\n+        actual = new JavadocFormatter(60, false).formatJavadoc(header, javadoc);\n+        expected = \"\"\"\n+                   test\n+                   MarkDown test.\n+                    1. first list item\n+                    2. testing code inside a list\n+                    3. another \\uFFFClist item\n+                   \"\"\";\n+\n+        if (!Objects.equals(actual, expected)) {\n+            throw new AssertionError(\"Incorrect output: \" + actual);\n+        }\n+    }\n+\n+    public void testNewTags() {\n+        String header = \"test\";\n+        String javadoc = \"\"\"\n+                         {@summary New tags test.}\n+\n+                         <p>Property: {@systemProperty someProperty1}and {@systemProperty someProperty2}.\n+                         <p>Another\n+                         {@snippet :\n+                         class Test {\n+                             public static void main(String... args) {   \/\/ @highlight substring=\"main\"\n+                                 System.out.println(\"Hello World!\");\n+                             }\n+                         }\n+                         }\n+                         \"\"\";\n+\n+        String actual;\n+        String expected;\n+\n+        actual = new JavadocFormatter(60, false).formatJavadoc(header, javadoc);\n+        expected = \"\"\"\n+                   test\n+                   New tags test.\n+                   Property: someProperty1 and someProperty2.\n+                   Anotherclass Test {\n+                       public static void main(String... args) {   \/\/ @highlight substring=\"main\"\n+                           System.out.println(\"Hello World!\");\n+                       }\n+                   }\n+                   \"\"\";\n+\n+        if (!Objects.equals(actual, expected)) {\n+            throw new AssertionError(\"Incorrect output: \" + actual);\n+        }\n+    }\n+\n","filename":"test\/langtools\/jdk\/internal\/shellsupport\/doc\/JavadocFormatterTest.java","additions":67,"deletions":2,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -299,0 +299,13 @@\n+    }\n+\n+    public void testMarkDown() throws Exception {\n+        doTestJavadoc(\"    \/**md Test.*\/\\n\",\n+                      getSubTest,\n+                      \"md Test.\" +\n+                      \"@param p1 param1\\n\" +\n+                      \"@param p2 param2\\n\" +\n+                      \"@param p3 param3\\n\" +\n+                      \"@throws java.lang.IllegalStateException exc1\\n\" +\n+                      \"@throws java.lang.IllegalArgumentException exc2\\n\" +\n+                      \"@throws java.lang.IllegalAccessException exc3\\n\" +\n+                      \"@return value\\n\");\n","filename":"test\/langtools\/jdk\/internal\/shellsupport\/doc\/JavadocHelperTest.java","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"}]}