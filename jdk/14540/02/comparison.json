{"files":[{"patch":"@@ -984,3 +984,2 @@\n-void DefNewGeneration::contribute_scratch(ScratchBlock*& list, Generation* requestor,\n-                                         size_t max_alloc_words) {\n-  if (requestor == this || _promotion_failed) {\n+void DefNewGeneration::contribute_scratch(void*& scratch, size_t& num_words) {\n+  if (_promotion_failed) {\n@@ -989,1 +988,0 @@\n-  assert(GenCollectedHeap::heap()->is_old_gen(requestor), \"We should not call our own generation\");\n@@ -991,5 +989,1 @@\n-  \/* $$$ Assert this?  \"trace\" is a \"MarkSweep\" function so that's not appropriate.\n-  if (to_space->top() > to_space->bottom()) {\n-    trace(\"to_space not empty when contribute_scratch called\");\n-  }\n-  *\/\n+  constexpr size_t MinFreeScratchWords = 100;\n@@ -998,2 +992,1 @@\n-  assert(to_space->end() >= to_space->top(), \"pointers out of order\");\n-  size_t free_words = pointer_delta(to_space->end(), to_space->top());\n+  const size_t free_words = pointer_delta(to_space->end(), to_space->top());\n@@ -1001,4 +994,2 @@\n-    ScratchBlock* sb = (ScratchBlock*)to_space->top();\n-    sb->num_words = free_words;\n-    sb->next = list;\n-    list = sb;\n+    scratch = to_space->top();\n+    num_words = free_words;\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":6,"deletions":15,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -146,6 +146,0 @@\n-  enum SomeProtectedConstants {\n-    \/\/ Generations are GenGrain-aligned and have size that are multiples of\n-    \/\/ GenGrain.\n-    MinFreeScratchWords = 100\n-  };\n-\n@@ -251,4 +245,3 @@\n-  \/\/ For non-youngest collection, the DefNewGeneration can contribute\n-  \/\/ \"to-space\".\n-  virtual void contribute_scratch(ScratchBlock*& list, Generation* requestor,\n-                          size_t max_alloc_words);\n+  \/\/ For Old collection (part of running Full GC), the DefNewGeneration can\n+  \/\/ contribute the free part of \"to-space\" as the scratch space.\n+  void contribute_scratch(void*& scratch, size_t& num_words);\n@@ -257,1 +250,1 @@\n-  virtual void reset_scratch();\n+  void reset_scratch();\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.hpp","additions":4,"deletions":11,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"gc\/serial\/defNewGeneration.hpp\"\n@@ -129,3 +130,4 @@\n-  GenCollectedHeap* gch = GenCollectedHeap::heap();\n-  \/\/ Scratch request on behalf of old generation; will do no allocation.\n-  ScratchBlock* scratch = gch->gather_scratch(gch->old_gen(), 0);\n+  void* scratch = nullptr;\n+  size_t num_words;\n+  DefNewGeneration* young_gen = (DefNewGeneration*)GenCollectedHeap::heap()->young_gen();\n+  young_gen->contribute_scratch(scratch, num_words);\n@@ -133,2 +135,0 @@\n-  \/\/ $$$ To cut a corner, we'll only use the first scratch block, and then\n-  \/\/ revert to malloc.\n@@ -136,2 +136,1 @@\n-    _preserved_count_max =\n-      scratch->num_words * HeapWordSize \/ sizeof(PreservedMark);\n+    _preserved_count_max = num_words * HeapWordSize \/ sizeof(PreservedMark);\n@@ -150,2 +149,4 @@\n-  GenCollectedHeap* gch = GenCollectedHeap::heap();\n-  gch->release_scratch();\n+  if (_preserved_count_max != 0) {\n+    DefNewGeneration* young_gen = (DefNewGeneration*)GenCollectedHeap::heap()->young_gen();\n+    young_gen->reset_scratch();\n+  }\n","filename":"src\/hotspot\/share\/gc\/serial\/genMarkSweep.cpp","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -908,50 +908,0 @@\n-\/\/ Requires \"*prev_ptr\" to be non-null.  Deletes and a block of minimal size\n-\/\/ from the list headed by \"*prev_ptr\".\n-static ScratchBlock *removeSmallestScratch(ScratchBlock **prev_ptr) {\n-  bool first = true;\n-  size_t min_size = 0;   \/\/ \"first\" makes this conceptually infinite.\n-  ScratchBlock **smallest_ptr, *smallest;\n-  ScratchBlock  *cur = *prev_ptr;\n-  while (cur) {\n-    assert(*prev_ptr == cur, \"just checking\");\n-    if (first || cur->num_words < min_size) {\n-      smallest_ptr = prev_ptr;\n-      smallest     = cur;\n-      min_size     = smallest->num_words;\n-      first        = false;\n-    }\n-    prev_ptr = &cur->next;\n-    cur     =  cur->next;\n-  }\n-  smallest      = *smallest_ptr;\n-  *smallest_ptr = smallest->next;\n-  return smallest;\n-}\n-\n-\/\/ Sort the scratch block list headed by res into decreasing size order,\n-\/\/ and set \"res\" to the result.\n-static void sort_scratch_list(ScratchBlock*& list) {\n-  ScratchBlock* sorted = nullptr;\n-  ScratchBlock* unsorted = list;\n-  while (unsorted) {\n-    ScratchBlock *smallest = removeSmallestScratch(&unsorted);\n-    smallest->next  = sorted;\n-    sorted          = smallest;\n-  }\n-  list = sorted;\n-}\n-\n-ScratchBlock* GenCollectedHeap::gather_scratch(Generation* requestor,\n-                                               size_t max_alloc_words) {\n-  ScratchBlock* res = nullptr;\n-  _young_gen->contribute_scratch(res, requestor, max_alloc_words);\n-  _old_gen->contribute_scratch(res, requestor, max_alloc_words);\n-  sort_scratch_list(res);\n-  return res;\n-}\n-\n-void GenCollectedHeap::release_scratch() {\n-  _young_gen->reset_scratch();\n-  _old_gen->reset_scratch();\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/genCollectedHeap.cpp","additions":0,"deletions":50,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -231,11 +231,0 @@\n-  \/\/ The \"requestor\" generation is performing some garbage collection\n-  \/\/ action for which it would be useful to have scratch space.  The\n-  \/\/ requestor promises to allocate no more than \"max_alloc_words\" in any\n-  \/\/ older generation (via promotion say.)   Any blocks of space that can\n-  \/\/ be provided are returned as a list of ScratchBlocks, sorted by\n-  \/\/ decreasing size.\n-  ScratchBlock* gather_scratch(Generation* requestor, size_t max_alloc_words);\n-  \/\/ Allow each generation to reset any scratch space that it has\n-  \/\/ contributed as it needs.\n-  void release_scratch();\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/genCollectedHeap.hpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -329,16 +329,0 @@\n-  \/\/ The \"requestor\" generation is performing some garbage collection\n-  \/\/ action for which it would be useful to have scratch space.  If\n-  \/\/ the target is not the requestor, no gc actions will be required\n-  \/\/ of the target.  The requestor promises to allocate no more than\n-  \/\/ \"max_alloc_words\" in the target generation (via promotion say,\n-  \/\/ if the requestor is a young generation and the target is older).\n-  \/\/ If the target generation can provide any scratch space, it adds\n-  \/\/ it to \"list\", leaving \"list\" pointing to the head of the\n-  \/\/ augmented list.  The default is to offer no space.\n-  virtual void contribute_scratch(ScratchBlock*& list, Generation* requestor,\n-                                  size_t max_alloc_words) {}\n-\n-  \/\/ Give each generation an opportunity to do clean up for any\n-  \/\/ contributed scratch.\n-  virtual void reset_scratch() {}\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/generation.hpp","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"}]}