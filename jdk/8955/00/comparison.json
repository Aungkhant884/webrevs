{"files":[{"patch":"@@ -797,1 +797,1 @@\n-    rf(Rd, 0);                                                          \\\n+    zrf(Rd, 0);                                                          \\\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -847,0 +847,2 @@\n+  movk(zr, 0);\n+  movk(zr, 0);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -552,0 +552,6 @@\n+#ifndef PRODUCT\n+static bool is_movk_to_zr(uint32_t insn) {\n+  return ((insn & 0xffe0001f) == 0xf280001f);\n+}\n+#endif\n+\n@@ -553,1 +559,11 @@\n-  \/\/ unsupported for now\n+#ifndef PRODUCT\n+  assert(diff != 0, \"must be\");\n+  uint32_t insn1 = uint_at(4);\n+  uint32_t insn2 = uint_at(8);\n+  assert (is_movk_to_zr(insn1) && is_movk_to_zr(insn2), \"must be\");\n+#endif\n+\n+  uint32_t lo = diff & 0xffff;\n+  uint32_t hi = (uint32_t)diff >> 16;\n+  Instruction_aarch64::patch(addr_at(4), 20, 5, lo);\n+  Instruction_aarch64::patch(addr_at(8), 20, 5, hi);\n","filename":"src\/hotspot\/cpu\/aarch64\/nativeInst_aarch64.cpp","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -669,0 +669,7 @@\n+\/\/ A NativePostCallNop takes the form of three instructions:\n+\/\/     nop; movk zr, lo; movk zr, hi\n+\/\/\n+\/\/ The nop is patchable for a deoptimization trap. The two movk\n+\/\/ instructions execute as nops but have a 16-bit payload in which we\n+\/\/ can store an offset from the initial nop to the nmethod.\n+\n@@ -671,2 +678,18 @@\n-  bool check() const { return is_nop(); }\n-  int displacement() const { return 0; }\n+  bool check() const {\n+    uint64_t insns = *(uint64_t*)addr_at(0);\n+    \/\/ Check for two instructions: nop; movk zr, xx\n+    \/\/ These instructions only ever appear together in a post-call\n+    \/\/ NOP, so it's unnecessary to check that the third instruction is\n+    \/\/ a MOVK as well.\n+    return (insns & 0xffe0001fffffffff) == 0xf280001fd503201f;\n+  }\n+\n+  jint displacement() const {\n+    uint64_t movk_insns = *(uint64_t*)addr_at(4);\n+    uint32_t lo = (movk_insns >> 5) & 0xffff;\n+    uint32_t hi = (movk_insns >> (5 + 32)) & 0xffff;\n+    uint32_t result = (hi << 16) | lo;\n+\n+    return (jint)result;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/nativeInst_aarch64.hpp","additions":25,"deletions":2,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+    assert(cb == CodeCache::find_blob(pc), \"must be\");\n","filename":"src\/hotspot\/share\/code\/codeCache.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}