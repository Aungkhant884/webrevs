{"files":[{"patch":"@@ -89,1 +89,1 @@\n-    shift-negative-value unknown-pragmas invalid-offsetof\n+    shift-negative-value unknown-pragmas\n@@ -92,2 +92,1 @@\n-    missing-braces delete-non-abstract-non-virtual-dtor unknown-pragmas \\\n-    invalid-offsetof\n+    missing-braces delete-non-abstract-non-virtual-dtor unknown-pragmas\n","filename":"make\/hotspot\/lib\/CompileJvm.gmk","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -141,1 +141,12 @@\n-#define offset_of(klass,field) offsetof(klass, field)\n+\/\/ GCC\/Clang warns about applying offsetof() to types that are not standard layout or calculating\n+\/\/ offset directly when base address is NULL. Technically using offsetof() on non-standard layout is\n+\/\/ undefined behavior before C++17 and \"conditionally-supported\" after C++17. Rather than take our\n+\/\/ chances we use our own implementation which both GCC\/Clang ultimately produce a constant for but\n+\/\/ is not a constant expression.\n+#define offset_of(klass, field)                         \\\n+__attribute__((always_inline)) []() {                   \\\n+  alignas(klass) char space[sizeof(klass)];             \\\n+  klass* dummyObj = (klass*)space;                      \\\n+  char* c = (char*)(void*)&dummyObj->field;             \\\n+  return (size_t)(c - space);                           \\\n+}()\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions_gcc.hpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"}]}