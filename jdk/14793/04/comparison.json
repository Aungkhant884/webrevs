{"files":[{"patch":"@@ -49,1 +49,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.taglets.DeprecatedTaglet;\n@@ -260,2 +259,2 @@\n-        Content output = (new DeprecatedTaglet()).getAllBlockTagOutput(member,\n-            writer.getTagletWriterInstance(false));\n+        var t = configuration.tagletManager.getTaglet(DocTree.Kind.DEPRECATED);\n+        Content output = t.getAllBlockTagOutput(member, writer.getTagletWriterInstance(false));\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/AbstractMemberWriter.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+\n@@ -44,0 +45,1 @@\n+\n@@ -54,1 +56,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.taglets.ParamTaglet;\n@@ -95,0 +96,5 @@\n+    @Override\n+    public Content getOutputInstance() {\n+        return new ContentBuilder();\n+    }\n+\n@@ -176,1 +182,1 @@\n-    protected TypeElement getCurrentPageElement() {\n+    public TypeElement getCurrentPageElement() {\n@@ -271,2 +277,2 @@\n-            Content paramInfo = (new ParamTaglet()).getAllBlockTagOutput(typeElement,\n-                    getTagletWriterInstance(false));\n+            var t = configuration.tagletManager.getTaglet(DocTree.Kind.PARAM);\n+            Content paramInfo = t.getAllBlockTagOutput(typeElement, getTagletWriterInstance(false));\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/ClassWriterImpl.java","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -28,0 +28,4 @@\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.InvalidPathException;\n+import java.nio.file.Path;\n@@ -30,0 +34,1 @@\n+import java.util.Arrays;\n@@ -42,0 +47,1 @@\n+import javax.tools.DocumentationTool;\n@@ -52,0 +58,1 @@\n+import jdk.javadoc.internal.doclets.formats.html.taglets.TagletManager;\n@@ -64,0 +71,1 @@\n+import jdk.javadoc.internal.doclets.toolkit.util.SimpleDocletException;\n@@ -107,1 +115,1 @@\n-    protected HtmlIndexBuilder mainIndex;\n+    public HtmlIndexBuilder mainIndex;\n@@ -136,1 +144,1 @@\n-    protected final Messages messages;\n+    public final Messages messages;\n@@ -146,0 +154,5 @@\n+    \/**\n+     * The taglet manager.\n+     *\/\n+    public TagletManager tagletManager;\n+\n@@ -427,0 +440,24 @@\n+\n+        String snippetPath = options.snippetPath();\n+        if (snippetPath != null) {\n+            Messages messages = getMessages();\n+            JavaFileManager fm = getFileManager();\n+            if (fm instanceof StandardJavaFileManager) {\n+                try {\n+                    List<Path> sp = Arrays.stream(snippetPath.split(File.pathSeparator))\n+                            .map(Path::of)\n+                            .toList();\n+                    StandardJavaFileManager sfm = (StandardJavaFileManager) fm;\n+                    sfm.setLocationFromPaths(DocumentationTool.Location.SNIPPET_PATH, sp);\n+                } catch (IOException | InvalidPathException e) {\n+                    throw new SimpleDocletException(messages.getResources().getText(\n+                            \"doclet.error_setting_snippet_path\", snippetPath, e), e);\n+                }\n+            } else {\n+                throw new SimpleDocletException(messages.getResources().getText(\n+                        \"doclet.cannot_use_snippet_path\", snippetPath));\n+            }\n+        }\n+\n+        initTagletManager(options.customTagStrs());\n+\n@@ -429,0 +466,95 @@\n+\n+    \/**\n+     * Initialize the taglet manager.  The strings to initialize the simple custom tags should\n+     * be in the following format:  \"[tag name]:[location str]:[heading]\".\n+     *\n+     * @param customTagStrs the set two-dimensional arrays of strings.  These arrays contain\n+     *                      either -tag or -taglet arguments.\n+     *\/\n+    private void initTagletManager(Set<List<String>> customTagStrs) {\n+        tagletManager = tagletManager != null ? tagletManager : new TagletManager(this);\n+        JavaFileManager fileManager = getFileManager();\n+        Messages messages = getMessages();\n+        try {\n+            tagletManager.initTagletPath(fileManager);\n+            tagletManager.loadTaglets(fileManager);\n+\n+            for (List<String> args : customTagStrs) {\n+                if (args.get(0).equals(\"-taglet\")) {\n+                    tagletManager.addCustomTag(args.get(1), fileManager);\n+                    continue;\n+                }\n+                \/* Since there are few constraints on the characters in a tag name,\n+                 * and real world examples with ':' in the tag name, we cannot simply use\n+                 * String.split(regex);  instead, we tokenize the string, allowing\n+                 * special characters to be escaped with '\\'. *\/\n+                List<String> tokens = tokenize(args.get(1), 3);\n+                switch (tokens.size()) {\n+                    case 1 -> {\n+                        String tagName = args.get(1);\n+                        if (tagletManager.isKnownCustomTag(tagName)) {\n+                            \/\/reorder a standard tag\n+                            tagletManager.addNewSimpleCustomTag(tagName, null, \"\");\n+                        } else {\n+                            \/\/Create a simple tag with the heading that has the same name as the tag.\n+                            StringBuilder heading = new StringBuilder(tagName + \":\");\n+                            heading.setCharAt(0, Character.toUpperCase(tagName.charAt(0)));\n+                            tagletManager.addNewSimpleCustomTag(tagName, heading.toString(), \"a\");\n+                        }\n+                    }\n+\n+                    case 2 ->\n+                        \/\/Add simple taglet without heading, probably to excluding it in the output.\n+                            tagletManager.addNewSimpleCustomTag(tokens.get(0), tokens.get(1), \"\");\n+\n+                    case 3 ->\n+                            tagletManager.addNewSimpleCustomTag(tokens.get(0), tokens.get(2), tokens.get(1));\n+\n+                    default ->\n+                            messages.error(\"doclet.Error_invalid_custom_tag_argument\", args.get(1));\n+                }\n+            }\n+        } catch (IOException e) {\n+            messages.error(\"doclet.taglet_could_not_set_location\", e.toString());\n+        }\n+    }\n+\n+    \/**\n+     * Given a string, return an array of tokens, separated by ':'.\n+     * The separator character can be escaped with the '\\' character.\n+     * The '\\' character may also be escaped with the '\\' character.\n+     *\n+     * @param s         the string to tokenize\n+     * @param maxTokens the maximum number of tokens returned.  If the\n+     *                  max is reached, the remaining part of s is appended\n+     *                  to the end of the last token.\n+     * @return an array of tokens\n+     *\/\n+    private List<String> tokenize(String s, int maxTokens) {\n+        List<String> tokens = new ArrayList<>();\n+        StringBuilder token = new StringBuilder();\n+        boolean prevIsEscapeChar = false;\n+        for (int i = 0; i < s.length(); i += Character.charCount(i)) {\n+            int currentChar = s.codePointAt(i);\n+            if (prevIsEscapeChar) {\n+                \/\/ Case 1:  escaped character\n+                token.appendCodePoint(currentChar);\n+                prevIsEscapeChar = false;\n+            } else if (currentChar == ':' && tokens.size() < maxTokens - 1) {\n+                \/\/ Case 2:  separator\n+                tokens.add(token.toString());\n+                token = new StringBuilder();\n+            } else if (currentChar == '\\\\') {\n+                \/\/ Case 3:  escape character\n+                prevIsEscapeChar = true;\n+            } else {\n+                \/\/ Case 4:  regular character\n+                token.appendCodePoint(currentChar);\n+            }\n+        }\n+        if (token.length() > 0) {\n+            tokens.add(token.toString());\n+        }\n+        return tokens;\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlConfiguration.java","additions":134,"deletions":2,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -322,0 +322,10 @@\n+    @Override\n+    protected void generateFiles() throws DocletException {\n+        super.generateFiles();\n+\n+        if (configuration.tagletManager != null) { \/\/ may be null, if no files generated, perhaps because of errros\n+            configuration.tagletManager.printReport();\n+        }\n+\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlDoclet.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+\n@@ -71,1 +72,0 @@\n-import com.sun.source.doctree.IndexTree;\n@@ -73,0 +73,1 @@\n+import com.sun.source.doctree.InlineTagTree;\n@@ -76,2 +77,0 @@\n-import com.sun.source.doctree.SummaryTree;\n-import com.sun.source.doctree.SystemPropertyTree;\n@@ -94,0 +93,2 @@\n+import jdk.javadoc.internal.doclets.formats.html.taglets.Taglet;\n+import jdk.javadoc.internal.doclets.formats.html.taglets.TagletWriter;\n@@ -97,3 +98,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.taglets.DocRootTaglet;\n-import jdk.javadoc.internal.doclets.toolkit.taglets.Taglet;\n-import jdk.javadoc.internal.doclets.toolkit.taglets.TagletWriter;\n@@ -112,1 +110,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable;\n@@ -115,1 +112,0 @@\n-import static com.sun.source.doctree.DocTree.Kind.CODE;\n@@ -117,3 +113,0 @@\n-import static com.sun.source.doctree.DocTree.Kind.LINK;\n-import static com.sun.source.doctree.DocTree.Kind.LINK_PLAIN;\n-import static com.sun.source.doctree.DocTree.Kind.SEE;\n@@ -163,1 +156,1 @@\n-    protected final Messages messages;\n+    public final Messages messages;\n@@ -167,1 +160,1 @@\n-    protected final Links links;\n+    public final Links links;\n@@ -200,1 +193,1 @@\n-    Map<String, Integer> indexAnchorTable = new HashMap<>();\n+    public final Map<String, Integer> indexAnchorTable = new HashMap<>();\n@@ -281,1 +274,1 @@\n-        \/\/ Note: {@docRoot} is not case sensitive when passed in with a command-line option:\n+        \/\/ Note: {@docRoot} is not case-sensitive when passed in with a command-line option:\n@@ -377,3 +370,2 @@\n-    private Content getInlineTagOutput(Element element, DocTree tree, TagletWriterImpl.Context context) {\n-        return getTagletWriterInstance(context)\n-                .getInlineTagOutput(element, configuration.tagletManager, tree);\n+    private Content getInlineTagOutput(Element element, InlineTagTree tree, TagletWriter.Context context) {\n+        return getTagletWriterInstance(context).getInlineTagOutput(element, tree);\n@@ -389,1 +381,1 @@\n-        return new TagletWriterImpl(this, isFirstSentence);\n+        return new TagletWriter(this, isFirstSentence);\n@@ -398,2 +390,2 @@\n-    public TagletWriterImpl getTagletWriterInstance(TagletWriterImpl.Context context) {\n-        return new TagletWriterImpl(this, context);\n+    public TagletWriter getTagletWriterInstance(TagletWriter.Context context) {\n+        return new TagletWriter(this, context);\n@@ -759,1 +751,1 @@\n-     * Return a class cross link to external class documentation.\n+     * Return a class cross-link to external class documentation.\n@@ -889,1 +881,1 @@\n-    protected TypeElement getCurrentPageElement() {\n+    public TypeElement getCurrentPageElement() {\n@@ -1180,1 +1172,1 @@\n-                new TagletWriterImpl.Context(isFirstSentence, inSummary));\n+                new TagletWriter.Context(isFirstSentence, inSummary));\n@@ -1197,1 +1189,1 @@\n-                                        TagletWriterImpl.Context context)\n+                                        TagletWriter.Context context)\n@@ -1310,6 +1302,0 @@\n-                @Override\n-                public Boolean visitDocRoot(DocRootTree node, Content content) {\n-                    content.add(getInlineTagOutput(element, node, context));\n-                    return false;\n-                }\n-\n@@ -1364,37 +1350,0 @@\n-                @Override\n-                public Boolean visitIndex(IndexTree node, Content content) {\n-                    Content output = getInlineTagOutput(element, node, context);\n-                    if (output != null) {\n-                        content.add(output);\n-                    }\n-                    return false;\n-                }\n-\n-                @Override\n-                public Boolean visitLink(LinkTree node, Content content) {\n-                    var inTags = context.inTags;\n-                    if (inTags.contains(LINK) || inTags.contains(LINK_PLAIN) || inTags.contains(SEE)) {\n-                        DocTreePath dtp = ch.getDocTreePath(node);\n-                        if (dtp != null) {\n-                            messages.warning(dtp, \"doclet.see.nested_link\", \"{@\" + node.getTagName() + \"}\");\n-                        }\n-                        Content label = commentTagsToContent(element, node.getLabel(), context);\n-                        if (label.isEmpty()) {\n-                            label = Text.of(node.getReference().getSignature());\n-                        }\n-                        content.add(label);\n-                    } else {\n-                        TagletWriterImpl t = getTagletWriterInstance(context.within(node));\n-                        content.add(t.linkTagOutput(element, node));\n-                    }\n-                    return false;\n-                }\n-\n-                @Override\n-                public Boolean visitLiteral(LiteralTree node, Content content) {\n-                    String s = node.getBody().getBody();\n-                    Content t = Text.of(Text.normalizeNewlines(s));\n-                    content.add(node.getKind() == CODE ? HtmlTree.CODE(t) : t);\n-                    return false;\n-                }\n-\n@@ -1414,16 +1363,0 @@\n-                @Override\n-                public Boolean visitSummary(SummaryTree node, Content content) {\n-                    Content output = getInlineTagOutput(element, node, context);\n-                    content.add(output);\n-                    return false;\n-                }\n-\n-                @Override\n-                public Boolean visitSystemProperty(SystemPropertyTree node, Content content) {\n-                    Content output = getInlineTagOutput(element, node, context);\n-                    if (output != null) {\n-                        content.add(output);\n-                    }\n-                    return false;\n-                }\n-\n@@ -1458,3 +1391,5 @@\n-                    Content output = getInlineTagOutput(element, node, context);\n-                    if (output != null) {\n-                        content.add(output);\n+                    if (node instanceof InlineTagTree itt) {\n+                        var output = getInlineTagOutput(element, itt, context);\n+                        if (output != null) {\n+                            content.add(output);\n+                        }\n@@ -1488,1 +1423,1 @@\n-                                         Element element, TagletWriterImpl.Context context) {\n+                                         Element element, TagletWriter.Context context) {\n@@ -1565,1 +1500,1 @@\n-    protected Content invalidTagOutput(String summary, Optional<Content> detail) {\n+    public Content invalidTagOutput(String summary, Optional<Content> detail) {\n@@ -1668,1 +1603,1 @@\n-                text = \"{@\" + (new DocRootTaglet()).getName() + \"}\/\"\n+                text = \"{@\" + Kind.DOC_ROOT.tagName + \"}\/\"\n@@ -2052,1 +1987,1 @@\n-     * @throws DocFileIOException\n+     * @throws DocFileIOException if an issue arises while accessing any stylesheets\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlDocletWriter.java","additions":26,"deletions":91,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -397,1 +397,1 @@\n-    static HtmlId forParam(String paramName) {\n+    public static HtmlId forParam(String paramName) {\n@@ -410,1 +410,1 @@\n-    static HtmlId forText(String text, Map<String, Integer> counts) {\n+    public static HtmlId forText(String text, Map<String, Integer> counts) {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlIds.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import java.util.LinkedHashSet;\n@@ -103,0 +104,5 @@\n+    \/**\n+     * Arguments for command-line option {@code -tag} and {@code -taglet}.\n+     *\/\n+    private final LinkedHashSet<List<String>> customTagStrs = new LinkedHashSet<>();\n+\n@@ -178,0 +184,6 @@\n+    \/**\n+     * Argument for command-line option {@code --snippet-path}.\n+     * The path for external snippets.\n+     *\/\n+    private String snippetPath = null;\n+\n@@ -185,0 +197,6 @@\n+    \/**\n+     * Argument for command-line option {@code --show-taglets}.\n+     * Show taglets (internal debug switch)\n+     *\/\n+    private boolean showTaglets = false;\n+\n@@ -190,0 +208,6 @@\n+    \/**\n+     * Argument for command-line option {@code -tagletpath}.\n+     * The path to Taglets\n+     *\/\n+    private String tagletPath = null;\n+\n@@ -409,0 +433,38 @@\n+                new Option(resources, \"--snippet-path\", 1) {\n+                    @Override\n+                    public boolean process(String opt, List<String> args) {\n+                        snippetPath = args.get(0);\n+                        return true;\n+                    }\n+                },\n+\n+                new Option(resources, \"-tag\", 1) {\n+                    @Override\n+                    public boolean process(String opt, List<String> args) {\n+                        ArrayList<String> list = new ArrayList<>();\n+                        list.add(opt);\n+                        list.add(args.get(0));\n+                        customTagStrs.add(list);\n+                        return true;\n+                    }\n+                },\n+\n+                new Option(resources, \"-taglet\", 1) {\n+                    @Override\n+                    public boolean process(String opt, List<String> args) {\n+                        ArrayList<String> list = new ArrayList<>();\n+                        list.add(opt);\n+                        list.add(args.get(0));\n+                        customTagStrs.add(list);\n+                        return true;\n+                    }\n+                },\n+\n+                new Option(resources, \"-tagletpath\", 1) {\n+                    @Override\n+                    public boolean process(String opt, List<String> args) {\n+                        tagletPath = args.get(0);\n+                        return true;\n+                    }\n+                },\n+\n@@ -492,0 +554,8 @@\n+                },\n+\n+                new Hidden(resources, \"--show-taglets\") {\n+                    @Override\n+                    public boolean process(String opt, List<String> args) {\n+                        showTaglets = true;\n+                        return true;\n+                    }\n@@ -623,0 +693,7 @@\n+    \/**\n+     * Arguments for command-line option {@code -tag} and {@code -taglet}.\n+     *\/\n+    LinkedHashSet<List<String>> customTagStrs() {\n+        return customTagStrs;\n+    }\n+\n@@ -724,0 +801,16 @@\n+    \/**\n+     * Argument for command-line option {@code --show-taglets}.\n+     * Show taglets (internal debug switch)\n+     *\/\n+    public boolean showTaglets() {\n+        return showTaglets;\n+    }\n+\n+    \/**\n+     * Argument for command-line option {@code --snippet-path}.\n+     * The path for external snippets.\n+     *\/\n+    public String snippetPath() {\n+        return snippetPath;\n+    }\n+\n@@ -740,0 +833,8 @@\n+    \/**\n+     * Argument for command-line option {@code -tagletpath}.\n+     * The path to Taglets\n+     *\/\n+    public String tagletPath() {\n+        return tagletPath;\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlOptions.java","additions":101,"deletions":0,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -28,1 +28,2 @@\n-import java.util.*;\n+import java.util.List;\n+import java.util.SortedSet;\n@@ -35,1 +36,0 @@\n-\n@@ -38,0 +38,1 @@\n+\n@@ -39,1 +40,0 @@\n-import jdk.javadoc.internal.doclets.formats.html.markup.TagName;\n@@ -41,0 +41,1 @@\n+import jdk.javadoc.internal.doclets.formats.html.markup.TagName;\n@@ -42,0 +43,1 @@\n+import jdk.javadoc.internal.doclets.formats.html.taglets.TagletWriter;\n@@ -137,1 +139,1 @@\n-                    new TagletWriterImpl.Context(false, false));\n+                    new TagletWriter.Context(false, false));\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlSerialFieldWriter.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-import jdk.javadoc.internal.doclets.toolkit.taglets.TagletManager;\n+import jdk.javadoc.internal.doclets.formats.html.taglets.TagletManager;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlSerialMethodWriter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,985 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.formats.html;\n-\n-import java.net.URI;\n-import java.net.URISyntaxException;\n-import java.util.ArrayList;\n-import java.util.EnumSet;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.function.BiConsumer;\n-import java.util.function.Predicate;\n-import java.util.stream.Collectors;\n-\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.ElementKind;\n-import javax.lang.model.element.ExecutableElement;\n-import javax.lang.model.element.ModuleElement;\n-import javax.lang.model.element.PackageElement;\n-import javax.lang.model.element.TypeElement;\n-import javax.lang.model.element.VariableElement;\n-import javax.lang.model.type.TypeMirror;\n-import javax.lang.model.util.SimpleElementVisitor14;\n-\n-import com.sun.source.doctree.DeprecatedTree;\n-import com.sun.source.doctree.DocTree;\n-import com.sun.source.doctree.IndexTree;\n-import com.sun.source.doctree.LinkTree;\n-import com.sun.source.doctree.LiteralTree;\n-import com.sun.source.doctree.ParamTree;\n-import com.sun.source.doctree.ReturnTree;\n-import com.sun.source.doctree.SeeTree;\n-import com.sun.source.doctree.SnippetTree;\n-import com.sun.source.doctree.SpecTree;\n-import com.sun.source.doctree.SystemPropertyTree;\n-import com.sun.source.doctree.TextTree;\n-import com.sun.source.doctree.ThrowsTree;\n-import com.sun.source.util.DocTreePath;\n-import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlAttr;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlId;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n-import jdk.javadoc.internal.doclets.formats.html.markup.RawHtml;\n-import jdk.javadoc.internal.doclets.formats.html.markup.TagName;\n-import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n-import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.DocletElement;\n-import jdk.javadoc.internal.doclets.toolkit.Messages;\n-import jdk.javadoc.internal.doclets.toolkit.Resources;\n-import jdk.javadoc.internal.doclets.toolkit.builders.SerializedFormBuilder;\n-import jdk.javadoc.internal.doclets.toolkit.taglets.ParamTaglet;\n-import jdk.javadoc.internal.doclets.toolkit.taglets.TagletWriter;\n-import jdk.javadoc.internal.doclets.toolkit.taglets.snippet.Style;\n-import jdk.javadoc.internal.doclets.toolkit.taglets.snippet.StyledText;\n-import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocLink;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocPath;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocPaths;\n-import jdk.javadoc.internal.doclets.toolkit.util.IndexItem;\n-import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n-import jdk.javadoc.internal.doclets.toolkit.util.Utils.PreviewFlagProvider;\n-import jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable;\n-\n-import static com.sun.source.doctree.DocTree.Kind.LINK_PLAIN;\n-\n-\/**\n- * The taglet writer that writes HTML.\n- *\/\n-public class TagletWriterImpl extends TagletWriter {\n-    \/**\n-     * A class that provides the information about the enclosing context for\n-     * a series of {@code DocTree} nodes.\n-     * This context may be used to determine the content that should be generated from the tree nodes.\n-     *\/\n-    static class Context {\n-        \/**\n-         * Whether or not the trees are appearing in a context of just the first sentence,\n-         * such as in the summary table of the enclosing element.\n-         *\/\n-        final boolean isFirstSentence;\n-        \/**\n-         * Whether or not the trees are appearing in the \"summary\" section of the\n-         * page for a declaration.\n-         *\/\n-        final boolean inSummary;\n-        \/**\n-         * The set of enclosing kinds of tags.\n-         *\/\n-        final Set<DocTree.Kind> inTags;\n-\n-        \/**\n-         * Creates an outermost context, with no enclosing tags.\n-         *\n-         * @param isFirstSentence {@code true} if the trees are appearing in a context of just the\n-         *                        first sentence and {@code false} otherwise\n-         * @param inSummary       {@code true} if the trees are appearing in the \"summary\" section\n-         *                        of the page for a declaration and {@code false} otherwise\n-         *\/\n-        Context(boolean isFirstSentence, boolean inSummary) {\n-            this(isFirstSentence, inSummary, EnumSet.noneOf(DocTree.Kind.class));\n-        }\n-\n-        private Context(boolean isFirstSentence, boolean inSummary, Set<DocTree.Kind> inTags) {\n-            this.isFirstSentence = isFirstSentence;\n-            this.inSummary = inSummary;\n-            this.inTags = inTags;\n-        }\n-\n-        \/**\n-         * Creates a new {@code Context} that includes an extra tag kind in the set of enclosing\n-         * kinds of tags.\n-         *\n-         * @param tree the enclosing tree\n-         *\n-         * @return the new {@code Context}\n-         *\/\n-        Context within(DocTree tree) {\n-            var newInTags = EnumSet.copyOf(inTags);\n-            newInTags.add(tree.getKind());\n-            return new Context(isFirstSentence, inSummary, newInTags);\n-        }\n-    }\n-\n-    private final HtmlDocletWriter htmlWriter;\n-    private final HtmlConfiguration configuration;\n-    private final HtmlOptions options;\n-    private final Utils utils;\n-    private final Resources resources;\n-\n-    private final Messages messages;\n-\n-    private final Contents contents;\n-    private final Context context;\n-\n-    \/\/ Threshold for length of @see tag label for switching from inline to block layout.\n-    private static final int TAG_LIST_ITEM_MAX_INLINE_LENGTH = 30;\n-\n-    \/**\n-     * Creates a taglet writer.\n-     *\n-     * @param htmlWriter      the {@code HtmlDocletWriter} for the page\n-     * @param isFirstSentence {@code true} if this taglet writer is being used for a\n-     *                        \"first sentence\" summary\n-     *\/\n-    public TagletWriterImpl(HtmlDocletWriter htmlWriter, boolean isFirstSentence) {\n-        this(htmlWriter, isFirstSentence, false);\n-    }\n-\n-    \/**\n-     * Creates a taglet writer.\n-     *\n-     * @param htmlWriter      the {@code HtmlDocletWriter} for the page\n-     * @param isFirstSentence {@code true} if this taglet writer is being used for a\n-     *                        \"first sentence\" summary, and {@code false} otherwise\n-     * @param inSummary       {@code true} if this taglet writer is being used for the content\n-     *                        of a {@code {@summary ...}} tag, and {@code false} otherwise\n-     *\/\n-    public TagletWriterImpl(HtmlDocletWriter htmlWriter, boolean isFirstSentence, boolean inSummary) {\n-        this(htmlWriter, new Context(isFirstSentence, inSummary));\n-    }\n-\n-    \/**\n-     * Creates a taglet writer.\n-     *\n-     * @param htmlWriter the {@code HtmlDocletWriter} for the page\n-     * @param context    the enclosing context for any tags\n-     *\/\n-    public TagletWriterImpl(HtmlDocletWriter htmlWriter, Context context) {\n-        super(context.isFirstSentence);\n-        this.htmlWriter = htmlWriter;\n-        this.context = context;\n-        configuration = htmlWriter.configuration;\n-        options = configuration.getOptions();\n-        utils = configuration.utils;\n-        messages = configuration.messages;\n-        resources = configuration.getDocResources();\n-        contents = configuration.getContents();\n-    }\n-\n-    @Override\n-    public Content getOutputInstance() {\n-        return new ContentBuilder();\n-    }\n-\n-    @Override\n-    protected Content codeTagOutput(Element element, LiteralTree tag) {\n-        return HtmlTree.CODE(Text.of(Text.normalizeNewlines(tag.getBody().getBody())));\n-    }\n-\n-    @Override\n-    protected Content indexTagOutput(Element element, IndexTree tag) {\n-        CommentHelper ch = utils.getCommentHelper(element);\n-\n-        DocTree searchTerm = tag.getSearchTerm();\n-        String tagText = (searchTerm instanceof TextTree tt) ? tt.getBody() : \"\";\n-        if (tagText.charAt(0) == '\"' && tagText.charAt(tagText.length() - 1) == '\"') {\n-            tagText = tagText.substring(1, tagText.length() - 1);\n-        }\n-        tagText = tagText.replaceAll(\"\\\\s+\", \" \");\n-\n-        Content desc = htmlWriter.commentTagsToContent(element, tag.getDescription(), context.within(tag));\n-        String descText = extractText(desc);\n-\n-        return createAnchorAndSearchIndex(element, tagText, descText, tag);\n-    }\n-\n-    \/\/ ugly but simple;\n-    \/\/ alternatives would be to walk the Content's tree structure, or to add new functionality to Content\n-    private String extractText(Content c) {\n-        return c.toString().replaceAll(\"<[^>]+>\", \"\");\n-    }\n-\n-    @Override\n-    public Content getDocRootOutput() {\n-        String path;\n-        if (htmlWriter.pathToRoot.isEmpty())\n-            path = \".\";\n-        else\n-            path = htmlWriter.pathToRoot.getPath();\n-        return Text.of(path);\n-    }\n-\n-    @Override\n-    public Content deprecatedTagOutput(Element element) {\n-        ContentBuilder result = new ContentBuilder();\n-        CommentHelper ch = utils.getCommentHelper(element);\n-        List<? extends DeprecatedTree> deprs = utils.getDeprecatedTrees(element);\n-        if (utils.isTypeElement(element)) {\n-            if (utils.isDeprecated(element)) {\n-                result.add(HtmlTree.SPAN(HtmlStyle.deprecatedLabel,\n-                        htmlWriter.getDeprecatedPhrase(element)));\n-                if (!deprs.isEmpty()) {\n-                    List<? extends DocTree> commentTrees = ch.getDescription(deprs.get(0));\n-                    if (!commentTrees.isEmpty()) {\n-                        result.add(commentTagsToOutput(element, null, commentTrees, false));\n-                    }\n-                }\n-            }\n-        } else {\n-            if (utils.isDeprecated(element)) {\n-                result.add(HtmlTree.SPAN(HtmlStyle.deprecatedLabel,\n-                        htmlWriter.getDeprecatedPhrase(element)));\n-                if (!deprs.isEmpty()) {\n-                    List<? extends DocTree> bodyTrees = ch.getBody(deprs.get(0));\n-                    Content body = commentTagsToOutput(element, null, bodyTrees, false);\n-                    if (!body.isEmpty())\n-                        result.add(HtmlTree.DIV(HtmlStyle.deprecationComment, body));\n-                }\n-            } else {\n-                Element ee = utils.getEnclosingTypeElement(element);\n-                if (utils.isDeprecated(ee)) {\n-                    result.add(HtmlTree.SPAN(HtmlStyle.deprecatedLabel,\n-                        htmlWriter.getDeprecatedPhrase(ee)));\n-                }\n-            }\n-        }\n-        return result;\n-    }\n-\n-    @Override\n-    public Content linkTagOutput(Element element, LinkTree tag) {\n-        CommentHelper ch = utils.getCommentHelper(element);\n-\n-        var linkRef = tag.getReference();\n-        if (linkRef == null) {\n-            messages.warning(ch.getDocTreePath(tag), \"doclet.link.no_reference\");\n-            return invalidTagOutput(resources.getText(\"doclet.tag.invalid_input\", tag.toString()),\n-                    Optional.empty());\n-        }\n-\n-        DocTree.Kind kind = tag.getKind();\n-        String refSignature = ch.getReferencedSignature(linkRef);\n-\n-        return linkSeeReferenceOutput(element,\n-                tag,\n-                refSignature,\n-                ch.getReferencedElement(tag),\n-                (kind == LINK_PLAIN),\n-                htmlWriter.commentTagsToContent(element, tag.getLabel(), context),\n-                (key, args) -> messages.warning(ch.getDocTreePath(tag), key, args)\n-        );\n-    }\n-\n-    @Override\n-    protected Content literalTagOutput(Element element, LiteralTree tag) {\n-        return Text.of(Text.normalizeNewlines(tag.getBody().getBody()));\n-    }\n-\n-    @Override\n-    public Content getParamHeader(ParamTaglet.ParamKind kind) {\n-        Content header = switch (kind) {\n-            case PARAMETER -> contents.parameters;\n-            case TYPE_PARAMETER -> contents.typeParameters;\n-            case RECORD_COMPONENT -> contents.recordComponents;\n-            default -> throw new IllegalArgumentException(kind.toString());\n-        };\n-        return HtmlTree.DT(header);\n-    }\n-\n-    @Override\n-    public Content paramTagOutput(Element element, ParamTree paramTag, String paramName) {\n-        ContentBuilder body = new ContentBuilder();\n-        CommentHelper ch = utils.getCommentHelper(element);\n-        \/\/ define id attributes for state components so that generated descriptions may refer to them\n-        boolean defineID = (element.getKind() == ElementKind.RECORD)\n-                && !paramTag.isTypeParameter();\n-        Content nameContent = Text.of(paramName);\n-        body.add(HtmlTree.CODE(defineID ? HtmlTree.SPAN_ID(HtmlIds.forParam(paramName), nameContent) : nameContent));\n-        body.add(\" - \");\n-        List<? extends DocTree> description = ch.getDescription(paramTag);\n-        body.add(htmlWriter.commentTagsToContent(element, description, context.within(paramTag)));\n-        return HtmlTree.DD(body);\n-    }\n-\n-    @Override\n-    public Content returnTagOutput(Element element, ReturnTree returnTag, boolean inline) {\n-        CommentHelper ch = utils.getCommentHelper(element);\n-        List<? extends DocTree> desc = ch.getDescription(returnTag);\n-        Content content = htmlWriter.commentTagsToContent(element, desc, context.within(returnTag));\n-        return inline\n-                ? new ContentBuilder(contents.getContent(\"doclet.Returns_0\", content))\n-                : new ContentBuilder(HtmlTree.DT(contents.returns), HtmlTree.DD(content));\n-    }\n-\n-    @Override\n-    public Content seeTagOutput(Element holder, List<? extends SeeTree> seeTags) {\n-        List<Content> links = new ArrayList<>();\n-        for (SeeTree dt : seeTags) {\n-            TagletWriterImpl t = new TagletWriterImpl(htmlWriter, context.within(dt));\n-            links.add(t.seeTagOutput(holder, dt));\n-        }\n-        if (utils.isVariableElement(holder) && ((VariableElement)holder).getConstantValue() != null &&\n-                htmlWriter instanceof ClassWriterImpl writer) {\n-            \/\/Automatically add link to constant values page for constant fields.\n-            DocPath constantsPath =\n-                    htmlWriter.pathToRoot.resolve(DocPaths.CONSTANT_VALUES);\n-            String whichConstant =\n-                    writer.getTypeElement().getQualifiedName() + \".\" +\n-                    utils.getSimpleName(holder);\n-            DocLink link = constantsPath.fragment(whichConstant);\n-            links.add(htmlWriter.links.createLink(link,\n-                    contents.getContent(\"doclet.Constants_Summary\")));\n-        }\n-        if (utils.isClass(holder) && utils.isSerializable((TypeElement)holder)) {\n-            \/\/Automatically add link to serialized form page for serializable classes.\n-            if (SerializedFormBuilder.serialInclude(utils, holder) &&\n-                      SerializedFormBuilder.serialInclude(utils, utils.containingPackage(holder))) {\n-                DocPath serialPath = htmlWriter.pathToRoot.resolve(DocPaths.SERIALIZED_FORM);\n-                DocLink link = serialPath.fragment(utils.getFullyQualifiedName(holder));\n-                links.add(htmlWriter.links.createLink(link,\n-                        contents.getContent(\"doclet.Serialized_Form\")));\n-            }\n-        }\n-        if (links.isEmpty()) {\n-            return Text.EMPTY;\n-        }\n-        \/\/ Use a different style if any link label is longer than 30 chars or contains commas.\n-        boolean hasLongLabels = links.stream().anyMatch(this::isLongOrHasComma);\n-        var seeList = HtmlTree.UL(hasLongLabels ? HtmlStyle.tagListLong : HtmlStyle.tagList);\n-        links.stream()\n-                .filter(Predicate.not(Content::isEmpty))\n-                .forEach(item -> seeList.add(HtmlTree.LI(item)));\n-\n-        return new ContentBuilder(\n-                HtmlTree.DT(contents.seeAlso),\n-                HtmlTree.DD(seeList));\n-    }\n-\n-    private boolean isLongOrHasComma(Content c) {\n-        String s = c.toString()\n-                .replaceAll(\"<.*?>\", \"\")              \/\/ ignore HTML\n-                .replaceAll(\"&#?[A-Za-z0-9]+;\", \" \")  \/\/ entities count as a single character\n-                .replaceAll(\"\\\\R\", \"\\n\");             \/\/ normalize newlines\n-        return s.length() > TAG_LIST_ITEM_MAX_INLINE_LENGTH || s.contains(\",\");\n-    }\n-\n-    String textOf(List<? extends DocTree> trees) {\n-        return trees.stream()\n-                .filter(dt -> dt instanceof TextTree)\n-                .map(dt -> ((TextTree) dt).getBody().trim())\n-                .collect(Collectors.joining(\" \"));\n-    }\n-\n-    \/**\n-     * {@return the output for a single {@code @see} tag}\n-     *\n-     * @param element the element that has the documentation comment containing this tag\n-     * @param seeTag  the tag\n-     *\/\n-    private Content seeTagOutput(Element element, SeeTree seeTag) {\n-        List<? extends DocTree> ref = seeTag.getReference();\n-        assert !ref.isEmpty();\n-        DocTree ref0 = ref.get(0);\n-        switch (ref0.getKind()) {\n-            case TEXT, START_ELEMENT -> {\n-                \/\/ @see \"Reference\"\n-                \/\/ @see <a href=\"...\">...<\/a>\n-                return htmlWriter.commentTagsToContent(element, ref, false, false);\n-            }\n-\n-            case REFERENCE -> {\n-                \/\/ @see reference label...\n-                CommentHelper ch = utils.getCommentHelper(element);\n-                String refSignature = ch.getReferencedSignature(ref0);\n-                List<? extends DocTree> label = ref.subList(1, ref.size());\n-\n-                return linkSeeReferenceOutput(element,\n-                        seeTag,\n-                        refSignature,\n-                        ch.getReferencedElement(seeTag),\n-                        false,\n-                        htmlWriter.commentTagsToContent(element, label, context),\n-                        (key, args) -> messages.warning(ch.getDocTreePath(seeTag), key, args)\n-                );\n-            }\n-\n-            case ERRONEOUS -> {\n-                return invalidTagOutput(resources.getText(\"doclet.tag.invalid_input\",\n-                                ref0.toString()),\n-                        Optional.empty());\n-            }\n-\n-            default -> throw new IllegalStateException(ref0.getKind().toString());\n-        }\n-\n-    }\n-\n-    \/**\n-     * Worker method to generate a link from the information in different kinds of tags,\n-     * such as {@code {@link ...}} tags, {@code @see ...} tags and the {@code link} markup tag\n-     * in a {@code {@snippet ...}} tag.\n-     *\n-     * @param holder        the element that has the documentation comment containing the information\n-     * @param refTree       the tree node containing the information, or {@code null} if not available\n-     * @param refSignature  the normalized signature of the target of the reference\n-     * @param ref           the target of the reference\n-     * @param isLinkPlain   {@code true} if the link should be presented in \"plain\" font,\n-     *                      or {@code false} for \"code\" font\n-     * @param label         the label for the link,\n-     *                      or an empty item to use a default label derived from the signature\n-     * @param reportWarning a function to report warnings about issues found in the reference\n-     *\n-     * @return the output containing the generated link, or content indicating an error\n-     *\/\n-    private Content linkSeeReferenceOutput(Element holder,\n-                                           DocTree refTree,\n-                                           String refSignature,\n-                                           Element ref,\n-                                           boolean isLinkPlain,\n-                                           Content label,\n-                                           BiConsumer<String, Object[]> reportWarning) {\n-        Content labelContent = plainOrCode(isLinkPlain, label);\n-\n-        \/\/ The signature from the @see tag. We will output this text when a label is not specified.\n-        Content text = plainOrCode(isLinkPlain,\n-                Text.of(Objects.requireNonNullElse(refSignature, \"\")));\n-\n-        CommentHelper ch = utils.getCommentHelper(holder);\n-        TypeElement refClass = ch.getReferencedClass(ref);\n-        Element refMem =       ch.getReferencedMember(ref);\n-        String refFragment =   ch.getReferencedFragment(refSignature);\n-\n-        if (refFragment == null && refMem != null) {\n-            refFragment = refMem.toString();\n-        } else if (refFragment != null && refFragment.startsWith(\"#\")) {\n-            if (labelContent.isEmpty()) {\n-                \/\/ A non-empty label is required for fragment links as the\n-                \/\/ reference target does not provide a useful default label.\n-                htmlWriter.messages.error(ch.getDocTreePath(refTree), \"doclet.link.see.no_label\");\n-                return invalidTagOutput(resources.getText(\"doclet.link.see.no_label\"),\n-                        Optional.of(refSignature));\n-            }\n-            refFragment = refFragment.substring(1);\n-        }\n-        if (refClass == null) {\n-            ModuleElement refModule = ch.getReferencedModule(ref);\n-            if (refModule != null && utils.isIncluded(refModule)) {\n-                return htmlWriter.getModuleLink(refModule, labelContent.isEmpty() ? text : labelContent, refFragment);\n-            }\n-            \/\/@see is not referencing an included class\n-            PackageElement refPackage = ch.getReferencedPackage(ref);\n-            if (refPackage != null && utils.isIncluded(refPackage)) {\n-                \/\/@see is referencing an included package\n-                if (labelContent.isEmpty()) {\n-                    labelContent = plainOrCode(isLinkPlain,\n-                            Text.of(refPackage.getQualifiedName()));\n-                }\n-                return htmlWriter.getPackageLink(refPackage, labelContent, refFragment);\n-            } else {\n-                \/\/ @see is not referencing an included class, module or package. Check for cross links.\n-                String refModuleName =  ch.getReferencedModuleName(refSignature);\n-                DocLink elementCrossLink = (refPackage != null) ? htmlWriter.getCrossPackageLink(refPackage) :\n-                        (configuration.extern.isModule(refModuleName))\n-                                ? htmlWriter.getCrossModuleLink(utils.elementUtils.getModuleElement(refModuleName))\n-                                : null;\n-                if (elementCrossLink != null) {\n-                    \/\/ Element cross link found\n-                    return htmlWriter.links.createExternalLink(elementCrossLink,\n-                            (labelContent.isEmpty() ? text : labelContent));\n-                } else {\n-                    \/\/ No cross link found so print warning\n-                    if (!configuration.isDocLintReferenceGroupEnabled()) {\n-                        reportWarning.accept(\n-                                \"doclet.link.see.reference_not_found\",\n-                                new Object[] { refSignature});\n-                    }\n-                    return htmlWriter.invalidTagOutput(resources.getText(\"doclet.link.see.reference_invalid\"),\n-                            Optional.of(labelContent.isEmpty() ? text: labelContent));\n-                }\n-            }\n-        } else if (refFragment == null) {\n-            \/\/ Must be a class reference since refClass is not null and refFragment is null.\n-            if (labelContent.isEmpty() && refTree != null) {\n-                TypeMirror referencedType = ch.getReferencedType(refTree);\n-                if (utils.isGenericType(referencedType)) {\n-                    \/\/ This is a generic type link, use the TypeMirror representation.\n-                    return plainOrCode(isLinkPlain, htmlWriter.getLink(\n-                            new HtmlLinkInfo(configuration, HtmlLinkInfo.Kind.LINK_TYPE_PARAMS_AND_BOUNDS, referencedType)));\n-                }\n-                labelContent = plainOrCode(isLinkPlain, Text.of(utils.getSimpleName(refClass)));\n-            }\n-            return htmlWriter.getLink(new HtmlLinkInfo(configuration, HtmlLinkInfo.Kind.PLAIN, refClass)\n-                    .label(labelContent));\n-        } else if (refMem == null) {\n-            \/\/ This is a fragment reference since refClass and refFragment are not null but refMem is null.\n-            return htmlWriter.getLink(new HtmlLinkInfo(configuration, HtmlLinkInfo.Kind.PLAIN, refClass)\n-                    .label(labelContent)\n-                    .fragment(refFragment)\n-                    .style(null));\n-        } else {\n-            \/\/ Must be a member reference since refClass is not null and refMemName is not null.\n-            \/\/ refMem is not null, so this @see tag must be referencing a valid member.\n-            TypeElement containing = utils.getEnclosingTypeElement(refMem);\n-\n-            \/\/ Find the enclosing type where the method is actually visible\n-            \/\/ in the inheritance hierarchy.\n-            ExecutableElement overriddenMethod = null;\n-            if (refMem.getKind() == ElementKind.METHOD) {\n-                VisibleMemberTable vmt = configuration.getVisibleMemberTable(containing);\n-                overriddenMethod = vmt.getOverriddenMethod((ExecutableElement)refMem);\n-\n-                if (overriddenMethod != null) {\n-                    containing = utils.getEnclosingTypeElement(overriddenMethod);\n-                }\n-            }\n-            if (refSignature.trim().startsWith(\"#\") &&\n-                    ! (utils.isPublic(containing) || utils.isLinkable(containing))) {\n-                \/\/ Since the link is relative and the holder is not even being\n-                \/\/ documented, this must be an inherited link.  Redirect it.\n-                \/\/ The current class either overrides the referenced member or\n-                \/\/ inherits it automatically.\n-                if (htmlWriter instanceof ClassWriterImpl writer) {\n-                    containing = writer.getTypeElement();\n-                } else if (!utils.isPublic(containing)) {\n-                    reportWarning.accept(\"doclet.link.see.reference_not_accessible\",\n-                            new Object[] { utils.getFullyQualifiedName(containing)});\n-                } else {\n-                    if (!configuration.isDocLintReferenceGroupEnabled()) {\n-                        reportWarning.accept(\"doclet.link.see.reference_not_found\",\n-                                new Object[] { refSignature });\n-                    }\n-                }\n-            }\n-            String refMemName = refFragment;\n-            if (configuration.currentTypeElement != containing) {\n-                refMemName = (utils.isConstructor(refMem))\n-                        ? refMemName\n-                        : utils.getSimpleName(containing) + \".\" + refMemName;\n-            }\n-            if (utils.isExecutableElement(refMem)) {\n-                if (refMemName.indexOf('(') < 0) {\n-                    refMemName += utils.makeSignature((ExecutableElement) refMem, null, true);\n-                }\n-                if (overriddenMethod != null) {\n-                    \/\/ The method to actually link.\n-                    refMem = overriddenMethod;\n-                }\n-            }\n-\n-            return htmlWriter.getDocLink(HtmlLinkInfo.Kind.SHOW_PREVIEW, containing,\n-                    refMem, (labelContent.isEmpty()\n-                            ? plainOrCode(isLinkPlain, Text.of(refMemName))\n-                            : labelContent), null, false);\n-        }\n-    }\n-\n-    private Content plainOrCode(boolean plain, Content body) {\n-        return (plain || body.isEmpty()) ? body : HtmlTree.CODE(body);\n-    }\n-\n-    @Override\n-    public Content simpleBlockTagOutput(Element element, List<? extends DocTree> simpleTags, String header) {\n-        CommentHelper ch = utils.getCommentHelper(element);\n-        ContentBuilder body = new ContentBuilder();\n-        boolean many = false;\n-        for (DocTree simpleTag : simpleTags) {\n-            if (many) {\n-                body.add(\", \");\n-            }\n-            List<? extends DocTree> bodyTags = ch.getBody(simpleTag);\n-            body.add(htmlWriter.commentTagsToContent(element, bodyTags, context.within(simpleTag)));\n-            many = true;\n-        }\n-        return new ContentBuilder(\n-                HtmlTree.DT(RawHtml.of(header)),\n-                HtmlTree.DD(body));\n-    }\n-\n-    @Override\n-    protected Content snippetTagOutput(Element element, SnippetTree tag, StyledText content,\n-                                       String id, String lang) {\n-        var pre = new HtmlTree(TagName.PRE).setStyle(HtmlStyle.snippet);\n-        if (id != null && !id.isBlank()) {\n-            pre.put(HtmlAttr.ID, id);\n-        }\n-        var code = new HtmlTree(TagName.CODE)\n-                .addUnchecked(Text.EMPTY); \/\/ Make sure the element is always rendered\n-        if (lang != null && !lang.isBlank()) {\n-            code.addStyle(\"language-\" + lang);\n-        }\n-\n-        content.consumeBy((styles, sequence) -> {\n-            CharSequence text = Text.normalizeNewlines(sequence);\n-            if (styles.isEmpty()) {\n-                code.add(text);\n-            } else {\n-                Element e = null;\n-                String t = null;\n-                boolean linkEncountered = false;\n-                boolean markupEncountered = false;\n-                Set<String> classes = new HashSet<>();\n-                for (Style s : styles) {\n-                    if (s instanceof Style.Name n) {\n-                        classes.add(n.name());\n-                    } else if (s instanceof Style.Link l) {\n-                        assert !linkEncountered; \/\/ TODO: do not assert; pick the first link report on subsequent\n-                        linkEncountered = true;\n-                        t = l.target();\n-                        e = getLinkedElement(element, t);\n-                        if (e == null) {\n-                            \/\/ TODO: diagnostic output\n-                        }\n-                    } else if (s instanceof Style.Markup) {\n-                        markupEncountered = true;\n-                        break;\n-                    } else {\n-                        \/\/ TODO: transform this if...else into an exhaustive\n-                        \/\/ switch over the sealed Style hierarchy when \"Pattern\n-                        \/\/ Matching for switch\" has been implemented (JEP 406\n-                        \/\/ and friends)\n-                        throw new AssertionError(styles);\n-                    }\n-                }\n-                Content c;\n-                if (markupEncountered) {\n-                    return;\n-                } else if (linkEncountered) {\n-                    assert e != null;\n-                    \/\/disable preview tagging inside the snippets:\n-                    PreviewFlagProvider prevPreviewProvider = utils.setPreviewFlagProvider(el -> false);\n-                    try {\n-                        c = linkSeeReferenceOutput(element,\n-                                null,\n-                                t,\n-                                e,\n-                                false, \/\/ TODO: for now\n-                                Text.of(sequence.toString()),\n-                                (key, args) -> { \/* TODO: report diagnostic *\/ });\n-                    } finally {\n-                        utils.setPreviewFlagProvider(prevPreviewProvider);\n-                    }\n-                } else {\n-                    c = HtmlTree.SPAN(Text.of(text));\n-                    classes.forEach(((HtmlTree) c)::addStyle);\n-                }\n-                code.add(c);\n-            }\n-        });\n-        String copyText = resources.getText(\"doclet.Copy_to_clipboard\");\n-        String copiedText = resources.getText(\"doclet.Copied_to_clipboard\");\n-        String copySnippetText = resources.getText(\"doclet.Copy_snippet_to_clipboard\");\n-        var snippetContainer = HtmlTree.DIV(HtmlStyle.snippetContainer,\n-                new HtmlTree(TagName.BUTTON)\n-                        .add(HtmlTree.SPAN(Text.of(copyText))\n-                                .put(HtmlAttr.DATA_COPIED, copiedText))\n-                        .add(new HtmlTree(TagName.IMG)\n-                                .put(HtmlAttr.SRC, htmlWriter.pathToRoot.resolve(DocPaths.CLIPBOARD_SVG).getPath())\n-                                .put(HtmlAttr.ALT, copySnippetText))\n-                        .addStyle(HtmlStyle.copy)\n-                        .addStyle(HtmlStyle.snippetCopy)\n-                        .put(HtmlAttr.ARIA_LABEL, copySnippetText)\n-                        .put(HtmlAttr.ONCLICK, \"copySnippet(this)\"));\n-        return snippetContainer.add(pre.add(code));\n-    }\n-\n-    \/*\n-     * Returns the element that is linked from the context of the referrer using\n-     * the provided signature; returns null if such element could not be found.\n-     *\n-     * This method is to be used when it is the target of the link that is\n-     * important, not the container of the link (e.g. was it an @see,\n-     * @link\/@linkplain or @snippet tags, etc.)\n-     *\/\n-    public Element getLinkedElement(Element referer, String signature) {\n-        var factory = utils.docTrees.getDocTreeFactory();\n-        var docCommentTree = utils.getDocCommentTree(referer);\n-        var rootPath = new DocTreePath(utils.getTreePath(referer), docCommentTree);\n-        var reference = factory.newReferenceTree(signature);\n-        var fabricatedPath = new DocTreePath(rootPath, reference);\n-        return utils.docTrees.getElement(fabricatedPath);\n-    }\n-\n-    @Override\n-    public Content specTagOutput(Element holder, List<? extends SpecTree> specTags) {\n-        if (specTags.isEmpty()) {\n-            return Text.EMPTY;\n-        }\n-\n-        List<Content> links = specTags.stream()\n-                .map(st -> specTagToContent(holder, st))\n-                .collect(Collectors.toList());\n-\n-        \/\/ Use a different style if any link label is longer than 30 chars or contains commas.\n-        boolean hasLongLabels = links.stream().anyMatch(this::isLongOrHasComma);\n-        var specList = HtmlTree.UL(hasLongLabels ? HtmlStyle.tagListLong : HtmlStyle.tagList);\n-        links.stream()\n-                .filter(Predicate.not(Content::isEmpty))\n-                .forEach(item -> specList.add(HtmlTree.LI(item)));\n-\n-        return new ContentBuilder(\n-                HtmlTree.DT(contents.externalSpecifications),\n-                HtmlTree.DD(specList));\n-    }\n-\n-    private Content specTagToContent(Element holder, SpecTree specTree) {\n-        String specTreeURL = specTree.getURL().getBody();\n-        List<? extends DocTree> specTreeLabel = specTree.getTitle();\n-        Content label = htmlWriter.commentTagsToContent(holder, specTreeLabel, isFirstSentence);\n-        return getExternalSpecContent(holder, specTree, specTreeURL,\n-                textOf(specTreeLabel).replaceAll(\"\\\\s+\", \" \"), label);\n-    }\n-\n-    Content getExternalSpecContent(Element holder, DocTree docTree, String url, String searchText, Content title) {\n-        URI specURI;\n-        try {\n-            \/\/ Use the canonical title of the spec if one is available\n-            specURI = new URI(url);\n-        } catch (URISyntaxException e) {\n-            CommentHelper ch = utils.getCommentHelper(holder);\n-            DocTreePath dtp = ch.getDocTreePath(docTree);\n-            htmlWriter.messages.error(dtp, \"doclet.Invalid_URL\", e.getMessage());\n-            specURI = null;\n-        }\n-\n-        Content titleWithAnchor = createAnchorAndSearchIndex(holder,\n-                searchText,\n-                title,\n-                resources.getText(\"doclet.External_Specification\"),\n-                docTree);\n-\n-        if (specURI == null) {\n-            return titleWithAnchor;\n-        } else {\n-            return HtmlTree.A(htmlWriter.resolveExternalSpecURI(specURI), titleWithAnchor);\n-        }\n-\n-    }\n-\n-    @Override\n-    protected Content systemPropertyTagOutput(Element element, SystemPropertyTree tag) {\n-        String tagText = tag.getPropertyName().toString();\n-        return HtmlTree.CODE(createAnchorAndSearchIndex(element, tagText,\n-                resources.getText(\"doclet.System_Property\"), tag));\n-    }\n-\n-    @Override\n-    public Content getThrowsHeader() {\n-        return HtmlTree.DT(contents.throws_);\n-    }\n-\n-    @Deprecated(forRemoval = true)\n-    private Content throwsTagOutput(Element element, ThrowsTree throwsTag, TypeMirror substituteType) {\n-        ContentBuilder body = new ContentBuilder();\n-        CommentHelper ch = utils.getCommentHelper(element);\n-        Element exception = ch.getException(throwsTag);\n-        Content excName;\n-        if (substituteType != null) {\n-            excName = htmlWriter.getLink(new HtmlLinkInfo(configuration, HtmlLinkInfo.Kind.PLAIN,\n-                   substituteType));\n-        } else if (exception == null) {\n-            excName = Text.of(throwsTag.getExceptionName().toString());\n-        } else if (exception.asType() == null) {\n-            excName = Text.of(utils.getFullyQualifiedName(exception));\n-        } else {\n-            HtmlLinkInfo link = new HtmlLinkInfo(configuration, HtmlLinkInfo.Kind.PLAIN,\n-                                                 exception.asType());\n-            excName = htmlWriter.getLink(link);\n-        }\n-        body.add(HtmlTree.CODE(excName));\n-        List<? extends DocTree> description = ch.getDescription(throwsTag);\n-        Content desc = htmlWriter.commentTagsToContent(element, description, context.within(throwsTag));\n-        if (desc != null && !desc.isEmpty()) {\n-            body.add(\" - \");\n-            body.add(desc);\n-        }\n-        return HtmlTree.DD(body);\n-    }\n-\n-    @Override\n-    public Content throwsTagOutput(TypeMirror throwsType, Optional<Content> content) {\n-        var linkInfo = new HtmlLinkInfo(configuration, HtmlLinkInfo.Kind.PLAIN, throwsType);\n-        var link = htmlWriter.getLink(linkInfo);\n-        var concat = new ContentBuilder(HtmlTree.CODE(link));\n-        if (content.isPresent()) {\n-            concat.add(\" - \");\n-            concat.add(content.get());\n-        }\n-        return HtmlTree.DD(concat);\n-    }\n-\n-    @Override\n-    public Content valueTagOutput(VariableElement field, String constantVal, boolean includeLink) {\n-        return includeLink\n-                ? htmlWriter.getDocLink(HtmlLinkInfo.Kind.LINK_TYPE_PARAMS_AND_BOUNDS, field, constantVal)\n-                : Text.of(constantVal);\n-    }\n-\n-    @Override\n-    protected Content invalidTagOutput(String summary, Optional<String> detail) {\n-        return htmlWriter.invalidTagOutput(summary,\n-                detail.isEmpty() || detail.get().isEmpty()\n-                        ? Optional.empty()\n-                        : Optional.of(Text.of(Text.normalizeNewlines(detail.get()))));\n-    }\n-\n-    @Override\n-    public Content commentTagsToOutput(DocTree holder, List<? extends DocTree> tags) {\n-        return commentTagsToOutput(null, holder, tags, false);\n-    }\n-\n-    @Override\n-    public Content commentTagsToOutput(Element element, List<? extends DocTree> tags) {\n-        return commentTagsToOutput(element, null, tags, false);\n-    }\n-\n-    @Override\n-    public Content commentTagsToOutput(Element holder,\n-                                       DocTree holderTag,\n-                                       List<? extends DocTree> tags,\n-                                       boolean isFirstSentence)\n-    {\n-        return htmlWriter.commentTagsToContent(holder,\n-                tags, holderTag == null ? context : context.within(holderTag));\n-    }\n-\n-    @Override\n-    public BaseConfiguration configuration() {\n-        return configuration;\n-    }\n-\n-    @Override\n-    protected TypeElement getCurrentPageElement() {\n-        return htmlWriter.getCurrentPageElement();\n-    }\n-\n-    public HtmlDocletWriter getHtmlWriter() {\n-        return htmlWriter;\n-    }\n-\n-    private Content createAnchorAndSearchIndex(Element element, String tagText, String desc, DocTree tree) {\n-        return createAnchorAndSearchIndex(element, tagText, Text.of(tagText), desc, tree);\n-    }\n-\n-    @SuppressWarnings(\"preview\")\n-    private Content createAnchorAndSearchIndex(Element element, String tagText, Content tagContent, String desc, DocTree tree) {\n-        Content result = null;\n-        if (context.isFirstSentence && context.inSummary || context.inTags.contains(DocTree.Kind.INDEX)) {\n-            result = tagContent;\n-        } else {\n-            HtmlId id = HtmlIds.forText(tagText, htmlWriter.indexAnchorTable);\n-            result = HtmlTree.SPAN(id, HtmlStyle.searchTagResult, tagContent);\n-            if (options.createIndex() && !tagText.isEmpty()) {\n-                String holder = getHolderName(element);\n-                IndexItem item = IndexItem.of(element, tree, tagText, holder, desc,\n-                        new DocLink(htmlWriter.path, id.name()));\n-                configuration.mainIndex.add(item);\n-            }\n-        }\n-        return result;\n-    }\n-\n-    String getHolderName(Element element) {\n-        return new SimpleElementVisitor14<String, Void>() {\n-\n-            @Override\n-            public String visitModule(ModuleElement e, Void p) {\n-                return resources.getText(\"doclet.module\")\n-                        + \" \" + utils.getFullyQualifiedName(e);\n-            }\n-\n-            @Override\n-            public String visitPackage(PackageElement e, Void p) {\n-                return resources.getText(\"doclet.package\")\n-                        + \" \" + utils.getFullyQualifiedName(e);\n-            }\n-\n-            @Override\n-            public String visitType(TypeElement e, Void p) {\n-                return utils.getTypeElementKindName(e, true)\n-                        + \" \" + utils.getFullyQualifiedName(e);\n-            }\n-\n-            @Override\n-            public String visitExecutable(ExecutableElement e, Void p) {\n-                return utils.getFullyQualifiedName(utils.getEnclosingTypeElement(e))\n-                        + \".\" + utils.getSimpleName(e)\n-                        + utils.flatSignature(e, htmlWriter.getCurrentPageElement());\n-            }\n-\n-            @Override\n-            public String visitVariable(VariableElement e, Void p) {\n-                return utils.getFullyQualifiedName(utils.getEnclosingTypeElement(e))\n-                        + \".\" + utils.getSimpleName(e);\n-            }\n-\n-            @Override\n-            public String visitUnknown(Element e, Void p) {\n-                if (e instanceof DocletElement de) {\n-                    return switch (de.getSubKind()) {\n-                        case OVERVIEW -> resources.getText(\"doclet.Overview\");\n-                        case DOCFILE -> getHolderName(de);\n-                    };\n-                } else {\n-                    return super.visitUnknown(e, p);\n-                }\n-            }\n-\n-            @Override\n-            protected String defaultAction(Element e, Void p) {\n-                return utils.getFullyQualifiedName(e);\n-            }\n-        }.visit(element);\n-    }\n-\n-    private String getHolderName(DocletElement de) {\n-        PackageElement pe = de.getPackageElement();\n-        if (pe.isUnnamed()) {\n-            \/\/ if package is unnamed use enclosing module only if it is named\n-            Element ee = pe.getEnclosingElement();\n-            if (ee instanceof ModuleElement && !((ModuleElement)ee).isUnnamed()) {\n-                return resources.getText(\"doclet.module\") + \" \" + utils.getFullyQualifiedName(ee);\n-            }\n-            return pe.toString(); \/\/ \"Unnamed package\" or similar\n-        }\n-        return resources.getText(\"doclet.package\") + \" \" + utils.getFullyQualifiedName(pe);\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/TagletWriterImpl.java","additions":0,"deletions":985,"binary":false,"changes":985,"status":"deleted"},{"patch":"@@ -0,0 +1,125 @@\n+\/*\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html.taglets;\n+\n+import java.util.Set;\n+\n+import javax.lang.model.element.Element;\n+\n+import com.sun.source.doctree.DocTree;\n+\n+import jdk.javadoc.doclet.Taglet.Location;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n+import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.toolkit.Messages;\n+import jdk.javadoc.internal.doclets.toolkit.Resources;\n+import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n+\n+\/**\n+ * A base class that implements the {@link Taglet} interface.\n+ *\/\n+public class BaseTaglet implements Taglet {\n+    \/\/ The following members are global to the lifetime of the doclet\n+    protected final HtmlConfiguration config;\n+    protected final Messages messages;\n+    protected final Resources resources;\n+    protected final Utils utils;\n+\n+    \/\/ The following members are specific to the instance of the taglet\n+    protected final DocTree.Kind tagKind;\n+    protected final String name;\n+    private final boolean inline;\n+    private final Set<Location> sites;\n+\n+    \/\/ The following is dynamically set for the duration of the methods\n+    \/\/      getInlineTagOutput and getAllBlockTagOutput\n+    \/\/ by those taglets that need to refer to it\n+    protected TagletWriter tagletWriter;\n+\n+    public BaseTaglet(HtmlConfiguration config, DocTree.Kind tagKind, boolean inline, Set<Location> sites) {\n+        this(config, tagKind.tagName, tagKind, inline, sites);\n+    }\n+\n+    protected BaseTaglet(HtmlConfiguration config, String name, boolean inline, Set<Location> sites) {\n+        this(config, name, inline ? DocTree.Kind.UNKNOWN_INLINE_TAG : DocTree.Kind.UNKNOWN_BLOCK_TAG, inline, sites);\n+    }\n+\n+    private BaseTaglet(HtmlConfiguration config, String name, DocTree.Kind tagKind, boolean inline, Set<Location> sites) {\n+        this.config = config;\n+        this.messages = config.getMessages();\n+        this.resources = config.getDocResources();\n+        this.utils = config.utils;\n+\n+        this.name = name;\n+        this.tagKind = tagKind;\n+        this.inline = inline;\n+        this.sites = sites;\n+    }\n+\n+    @Override\n+    public Set<Location> getAllowedLocations() {\n+        return sites;\n+    }\n+\n+    @Override\n+    public final boolean isInlineTag() {\n+        return inline;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return name;\n+    }\n+\n+    \/**\n+     * Returns the kind of trees recognized by this taglet.\n+     *\n+     * @return the kind of trees recognized by this taglet\n+     *\/\n+    public DocTree.Kind getTagKind() {\n+        return tagKind;\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation throws {@link UnsupportedTagletOperationException}.\n+     *\/\n+    @Override\n+    public Content getInlineTagOutput(Element element, DocTree tag, TagletWriter tagletWriter) {\n+        throw new UnsupportedTagletOperationException(\"Method not supported in taglet \" + getName() + \".\");\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation throws {@link UnsupportedTagletOperationException}\n+     *\/\n+    @Override\n+    public Content getAllBlockTagOutput(Element holder, TagletWriter tagletWriter) {\n+        throw new UnsupportedTagletOperationException(\"Method not supported in taglet \" + getName() + \".\");\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/BaseTaglet.java","additions":125,"deletions":0,"binary":false,"changes":125,"status":"added"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html.taglets;\n+\n+import java.util.EnumSet;\n+import java.util.List;\n+\n+import javax.lang.model.element.Element;\n+\n+import com.sun.source.doctree.DeprecatedTree;\n+import com.sun.source.doctree.DocTree;\n+\n+import jdk.javadoc.doclet.Taglet;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n+import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n+import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;\n+\n+\/**\n+ * A taglet that represents the {@code @deprecated} tag.\n+ *\/\n+public class DeprecatedTaglet extends BaseTaglet {\n+\n+    DeprecatedTaglet(HtmlConfiguration config) {\n+        super(config, DocTree.Kind.DEPRECATED, false,\n+                EnumSet.of(Taglet.Location.MODULE, Taglet.Location.TYPE, Taglet.Location.CONSTRUCTOR, Taglet.Location.METHOD, Taglet.Location.FIELD));\n+\n+    }\n+\n+    @Override\n+    public Content getAllBlockTagOutput(Element element, TagletWriter tagletWriter) {\n+        var htmlWriter = tagletWriter.htmlWriter;\n+\n+        ContentBuilder result = new ContentBuilder();\n+        CommentHelper ch = utils.getCommentHelper(element);\n+        List<? extends DeprecatedTree> deprs = utils.getDeprecatedTrees(element);\n+        if (utils.isTypeElement(element)) {\n+            if (utils.isDeprecated(element)) {\n+                result.add(HtmlTree.SPAN(HtmlStyle.deprecatedLabel,\n+                        htmlWriter.getDeprecatedPhrase(element)));\n+                if (!deprs.isEmpty()) {\n+                    List<? extends DocTree> commentTrees = ch.getDescription(deprs.get(0));\n+                    if (!commentTrees.isEmpty()) {\n+                        result.add(tagletWriter.commentTagsToOutput(element, null, commentTrees, false));\n+                    }\n+                }\n+            }\n+        } else {\n+            if (utils.isDeprecated(element)) {\n+                result.add(HtmlTree.SPAN(HtmlStyle.deprecatedLabel,\n+                        htmlWriter.getDeprecatedPhrase(element)));\n+                if (!deprs.isEmpty()) {\n+                    List<? extends DocTree> bodyTrees = ch.getBody(deprs.get(0));\n+                    Content body = tagletWriter.commentTagsToOutput(element, null, bodyTrees, false);\n+                    if (!body.isEmpty())\n+                        result.add(HtmlTree.DIV(HtmlStyle.deprecationComment, body));\n+                }\n+            } else {\n+                Element ee = utils.getEnclosingTypeElement(element);\n+                if (utils.isDeprecated(ee)) {\n+                    result.add(HtmlTree.SPAN(HtmlStyle.deprecatedLabel,\n+                            htmlWriter.getDeprecatedPhrase(ee)));\n+                }\n+            }\n+        }\n+        return result;\n+\n+    }\n+\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/DeprecatedTaglet.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html.taglets;\n+\n+import java.util.EnumSet;\n+\n+import javax.lang.model.element.Element;\n+\n+import com.sun.source.doctree.DocTree;\n+\n+import jdk.javadoc.doclet.Taglet;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n+import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n+import jdk.javadoc.internal.doclets.toolkit.Content;\n+\n+\/**\n+ * An inline taglet representing {@code {@docRoot}}.  This taglet is\n+ * used to get the relative path to the document's root output\n+ * directory.\n+ *\/\n+public class DocRootTaglet extends BaseTaglet {\n+    DocRootTaglet(HtmlConfiguration config) {\n+        super(config, DocTree.Kind.DOC_ROOT, true, EnumSet.allOf(Taglet.Location.class));\n+    }\n+\n+    @Override\n+    public Content getInlineTagOutput(Element holder, DocTree tag, TagletWriter tagletWriter) {\n+        var htmlWriter = tagletWriter.htmlWriter;\n+        var pathToRoot = htmlWriter.pathToRoot;\n+        return Text.of(pathToRoot.isEmpty() ? \".\" : pathToRoot.getPath());\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/DocRootTaglet.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html.taglets;\n+\n+import java.util.EnumSet;\n+\n+import javax.lang.model.element.Element;\n+\n+import com.sun.source.doctree.DocTree;\n+import com.sun.source.doctree.IndexTree;\n+import com.sun.source.doctree.TextTree;\n+\n+import jdk.javadoc.doclet.Taglet;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n+import jdk.javadoc.internal.doclets.toolkit.Content;\n+\n+\/**\n+ * An inline taglet used to index a word or a phrase.\n+ * The enclosed text is interpreted as not containing HTML markup or\n+ * nested javadoc tags.\n+ *\/\n+public class IndexTaglet extends BaseTaglet {\n+\n+    IndexTaglet(HtmlConfiguration config) {\n+        super(config, DocTree.Kind.INDEX, true, EnumSet.allOf(Taglet.Location.class));\n+    }\n+\n+    @Override\n+    public Content getInlineTagOutput(Element element, DocTree tag, TagletWriter tagletWriter) {\n+        var context = tagletWriter.context;\n+        var indexTree = (IndexTree) tag;\n+\n+        DocTree searchTerm = indexTree.getSearchTerm();\n+        String tagText = (searchTerm instanceof TextTree tt) ? tt.getBody() : \"\";\n+        if (tagText.charAt(0) == '\"' && tagText.charAt(tagText.length() - 1) == '\"') {\n+            tagText = tagText.substring(1, tagText.length() - 1);\n+        }\n+        tagText = tagText.replaceAll(\"\\\\s+\", \" \");\n+\n+        Content desc = tagletWriter.htmlWriter.commentTagsToContent(element, indexTree.getDescription(), context.within(indexTree));\n+        String descText = extractText(desc);\n+\n+        return tagletWriter.createAnchorAndSearchIndex(element, tagText, descText, tag);\n+    }\n+\n+    \/\/ ugly but simple;\n+    \/\/ alternatives would be to walk the Content's tree structure, or to add new functionality to Content\n+    private String extractText(Content c) {\n+        return c.toString().replaceAll(\"<[^>]+>\", \"\");\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/IndexTaglet.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.javadoc.internal.doclets.toolkit.taglets;\n+package jdk.javadoc.internal.doclets.formats.html.taglets;\n@@ -39,0 +39,1 @@\n+\n@@ -40,1 +41,1 @@\n-import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n@@ -42,1 +43,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.Messages;\n@@ -57,2 +57,2 @@\n-    public InheritDocTaglet() {\n-        super(DocTree.Kind.INHERIT_DOC, true, EnumSet.of(Location.METHOD));\n+    InheritDocTaglet(HtmlConfiguration config) {\n+        super(config, DocTree.Kind.INHERIT_DOC, true, EnumSet.of(Location.METHOD));\n@@ -79,3 +79,0 @@\n-        BaseConfiguration configuration = writer.configuration();\n-        Messages messages = configuration.getMessages();\n-        Utils utils = configuration.utils;\n@@ -106,1 +103,1 @@\n-            VisibleMemberTable visibleMemberTable = configuration.getVisibleMemberTable(supertype);\n+            VisibleMemberTable visibleMemberTable = config.getVisibleMemberTable(supertype);\n@@ -145,1 +142,1 @@\n-        Taglet taglet = configuration.tagletManager.getTaglet(ch.getTagName(holderTag));\n+        Taglet taglet = config.tagletManager.getTaglet(ch.getTagName(holderTag));\n@@ -154,1 +151,1 @@\n-        InheritableTaglet.Output inheritedDoc = inheritableTaglet.inherit(method, src, holderTag, isFirstSentence, configuration);\n+        InheritableTaglet.Output inheritedDoc = inheritableTaglet.inherit(method, src, holderTag, isFirstSentence);\n@@ -185,1 +182,4 @@\n-        return retrieveInheritedDocumentation(tagletWriter, (ExecutableElement) e, (InheritDocTree) inheritDoc, tagletWriter.isFirstSentence);\n+        return retrieveInheritedDocumentation(tagletWriter,\n+                (ExecutableElement) e,\n+                (InheritDocTree) inheritDoc,\n+                tagletWriter.context.isFirstSentence);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/InheritDocTaglet.java","additions":12,"deletions":12,"binary":false,"changes":24,"previous_filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/InheritDocTaglet.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.javadoc.internal.doclets.toolkit.taglets;\n+package jdk.javadoc.internal.doclets.formats.html.taglets;\n@@ -34,1 +34,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n@@ -40,1 +39,1 @@\n-public interface InheritableTaglet extends Taglet {\n+public interface InheritableTaglet {\n@@ -55,1 +54,1 @@\n-    Output inherit(Element dst, Element src, DocTree tag, boolean isFirstSentence, BaseConfiguration configuration);\n+    Output inherit(Element dst, Element src, DocTree tag, boolean isFirstSentence);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/InheritableTaglet.java","additions":3,"deletions":4,"binary":false,"changes":7,"previous_filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/InheritableTaglet.java","status":"renamed"},{"patch":"@@ -0,0 +1,278 @@\n+\/*\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html.taglets;\n+\n+import java.util.EnumSet;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.BiConsumer;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.ModuleElement;\n+import javax.lang.model.element.PackageElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeMirror;\n+\n+import com.sun.source.doctree.DocTree;\n+import com.sun.source.doctree.LinkTree;\n+import com.sun.source.util.DocTreePath;\n+\n+import jdk.javadoc.doclet.Taglet;\n+import jdk.javadoc.internal.doclets.formats.html.ClassWriterImpl;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlLinkInfo;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n+import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n+import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;\n+import jdk.javadoc.internal.doclets.toolkit.util.DocLink;\n+import jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable;\n+\n+import static com.sun.source.doctree.DocTree.Kind.LINK;\n+import static com.sun.source.doctree.DocTree.Kind.LINK_PLAIN;\n+import static com.sun.source.doctree.DocTree.Kind.SEE;\n+\n+\/**\n+ * A taglet that represents the {@code {@link ...}} and {@linkplain ...} tags,\n+ * with support for links to program elements in {@code @see} and\n+ * {@code {@snippet ...}} tags.\n+ *\/\n+public class LinkTaglet extends BaseTaglet {\n+    LinkTaglet(HtmlConfiguration config, DocTree.Kind tagKind) {\n+        super(config, tagKind, true, EnumSet.allOf(Taglet.Location.class));\n+    }\n+\n+    @Override\n+    public Content getInlineTagOutput(Element element, DocTree tag, TagletWriter tagletWriter) {\n+        this.tagletWriter = tagletWriter;\n+        var linkTree = (LinkTree) tag;\n+        var ch = utils.getCommentHelper(element);\n+        var context = tagletWriter.context;\n+        var htmlWriter = tagletWriter.htmlWriter;\n+\n+        var inTags = context.inTags;\n+        if (inTags.contains(LINK) || inTags.contains(LINK_PLAIN) || inTags.contains(SEE)) {\n+            DocTreePath dtp = ch.getDocTreePath(linkTree);\n+            if (dtp != null) {\n+                messages.warning(dtp, \"doclet.see.nested_link\", \"{@\" + linkTree.getTagName() + \"}\");\n+            }\n+            Content label = htmlWriter.commentTagsToContent(element, linkTree.getLabel(), context.within(linkTree));\n+            if (label.isEmpty()) {\n+                label = Text.of(linkTree.getReference().getSignature());\n+            }\n+            return label;\n+        }\n+\n+        var linkRef = linkTree.getReference();\n+        if (linkRef == null) {\n+            messages.warning(ch.getDocTreePath(tag), \"doclet.link.no_reference\");\n+            return tagletWriter.invalidTagOutput(resources.getText(\"doclet.tag.invalid_input\", tag.toString()),\n+                    Optional.empty());\n+        }\n+\n+        DocTree.Kind kind = tag.getKind();\n+        String refSignature = ch.getReferencedSignature(linkRef);\n+\n+        return linkSeeReferenceOutput(element,\n+                tag,\n+                refSignature,\n+                ch.getReferencedElement(tag),\n+                (kind == LINK_PLAIN),\n+                htmlWriter.commentTagsToContent(element, linkTree.getLabel(), context.within(linkTree)),\n+                (key, args) -> messages.warning(ch.getDocTreePath(tag), key, args),\n+                tagletWriter);\n+    }\n+\n+    \/**\n+     * Worker method to generate a link from the information in different kinds of tags,\n+     * such as {@code {@link ...}} tags, {@code @see ...} tags and the {@code link} markup tag\n+     * in a {@code {@snippet ...}} tag.\n+     *\n+     * @param holder        the element that has the documentation comment containing the information\n+     * @param refTree       the tree node containing the information, or {@code null} if not available\n+     * @param refSignature  the normalized signature of the target of the reference\n+     * @param ref           the target of the reference\n+     * @param isLinkPlain   {@code true} if the link should be presented in \"plain\" font,\n+     *                      or {@code false} for \"code\" font\n+     * @param label         the label for the link,\n+     *                      or an empty item to use a default label derived from the signature\n+     * @param reportWarning a function to report warnings about issues found in the reference\n+     * @param tagletWriter  the writer providing the context for this call\n+     *\n+     * @return the output containing the generated link, or content indicating an error\n+     *\/\n+    Content linkSeeReferenceOutput(Element holder,\n+                                   DocTree refTree,\n+                                   String refSignature,\n+                                   Element ref,\n+                                   boolean isLinkPlain,\n+                                   Content label,\n+                                   BiConsumer<String, Object[]> reportWarning,\n+                                   TagletWriter tagletWriter) {\n+        var config = tagletWriter.configuration;\n+        var htmlWriter = tagletWriter.htmlWriter;\n+\n+        Content labelContent = plainOrCode(isLinkPlain, label);\n+\n+        \/\/ The signature from the @see tag. We will output this text when a label is not specified.\n+        Content text = plainOrCode(isLinkPlain,\n+                Text.of(Objects.requireNonNullElse(refSignature, \"\")));\n+\n+        CommentHelper ch = utils.getCommentHelper(holder);\n+        TypeElement refClass = ch.getReferencedClass(ref);\n+        Element refMem =       ch.getReferencedMember(ref);\n+        String refFragment =   ch.getReferencedFragment(refSignature);\n+\n+        if (refFragment == null && refMem != null) {\n+            refFragment = refMem.toString();\n+        } else if (refFragment != null && refFragment.startsWith(\"#\")) {\n+            if (labelContent.isEmpty()) {\n+                \/\/ A non-empty label is required for fragment links as the\n+                \/\/ reference target does not provide a useful default label.\n+                htmlWriter.messages.error(ch.getDocTreePath(refTree), \"doclet.link.see.no_label\");\n+                return tagletWriter.invalidTagOutput(resources.getText(\"doclet.link.see.no_label\"),\n+                        Optional.of(refSignature));\n+            }\n+            refFragment = refFragment.substring(1);\n+        }\n+        if (refClass == null) {\n+            ModuleElement refModule = ch.getReferencedModule(ref);\n+            if (refModule != null && utils.isIncluded(refModule)) {\n+                return htmlWriter.getModuleLink(refModule, labelContent.isEmpty() ? text : labelContent, refFragment);\n+            }\n+            \/\/@see is not referencing an included class\n+            PackageElement refPackage = ch.getReferencedPackage(ref);\n+            if (refPackage != null && utils.isIncluded(refPackage)) {\n+                \/\/@see is referencing an included package\n+                if (labelContent.isEmpty()) {\n+                    labelContent = plainOrCode(isLinkPlain,\n+                            Text.of(refPackage.getQualifiedName()));\n+                }\n+                return htmlWriter.getPackageLink(refPackage, labelContent, refFragment);\n+            } else {\n+                \/\/ @see is not referencing an included class, module or package. Check for cross-links.\n+                String refModuleName =  ch.getReferencedModuleName(refSignature);\n+                DocLink elementCrossLink = (refPackage != null) ? htmlWriter.getCrossPackageLink(refPackage) :\n+                        (config.extern.isModule(refModuleName))\n+                                ? htmlWriter.getCrossModuleLink(utils.elementUtils.getModuleElement(refModuleName))\n+                                : null;\n+                if (elementCrossLink != null) {\n+                    \/\/ Element cross-link found\n+                    return htmlWriter.links.createExternalLink(elementCrossLink,\n+                            (labelContent.isEmpty() ? text : labelContent));\n+                } else {\n+                    \/\/ No cross-link found so print warning\n+                    if (!config.isDocLintReferenceGroupEnabled()) {\n+                        reportWarning.accept(\n+                                \"doclet.link.see.reference_not_found\",\n+                                new Object[] { refSignature});\n+                    }\n+                    return htmlWriter.invalidTagOutput(resources.getText(\"doclet.link.see.reference_invalid\"),\n+                            Optional.of(labelContent.isEmpty() ? text: labelContent));\n+                }\n+            }\n+        } else if (refFragment == null) {\n+            \/\/ Must be a class reference since refClass is not null and refFragment is null.\n+            if (labelContent.isEmpty() && refTree != null) {\n+                TypeMirror referencedType = ch.getReferencedType(refTree);\n+                if (utils.isGenericType(referencedType)) {\n+                    \/\/ This is a generic type link, use the TypeMirror representation.\n+                    return plainOrCode(isLinkPlain, htmlWriter.getLink(\n+                            new HtmlLinkInfo(config, HtmlLinkInfo.Kind.LINK_TYPE_PARAMS_AND_BOUNDS, referencedType)));\n+                }\n+                labelContent = plainOrCode(isLinkPlain, Text.of(utils.getSimpleName(refClass)));\n+            }\n+            return htmlWriter.getLink(new HtmlLinkInfo(config, HtmlLinkInfo.Kind.PLAIN, refClass)\n+                    .label(labelContent));\n+        } else if (refMem == null) {\n+            \/\/ This is a fragment reference since refClass and refFragment are not null but refMem is null.\n+            return htmlWriter.getLink(new HtmlLinkInfo(config, HtmlLinkInfo.Kind.PLAIN, refClass)\n+                    .label(labelContent)\n+                    .fragment(refFragment)\n+                    .style(null));\n+        } else {\n+            \/\/ Must be a member reference since refClass is not null and refMemName is not null.\n+            \/\/ refMem is not null, so this @see tag must be referencing a valid member.\n+            TypeElement containing = utils.getEnclosingTypeElement(refMem);\n+\n+            \/\/ Find the enclosing type where the method is actually visible\n+            \/\/ in the inheritance hierarchy.\n+            ExecutableElement overriddenMethod = null;\n+            if (refMem.getKind() == ElementKind.METHOD) {\n+                VisibleMemberTable vmt = config.getVisibleMemberTable(containing);\n+                overriddenMethod = vmt.getOverriddenMethod((ExecutableElement)refMem);\n+\n+                if (overriddenMethod != null) {\n+                    containing = utils.getEnclosingTypeElement(overriddenMethod);\n+                }\n+            }\n+            if (refSignature.trim().startsWith(\"#\") &&\n+                    ! (utils.isPublic(containing) || utils.isLinkable(containing))) {\n+                \/\/ Since the link is relative and the holder is not even being\n+                \/\/ documented, this must be an inherited link.  Redirect it.\n+                \/\/ The current class either overrides the referenced member or\n+                \/\/ inherits it automatically.\n+                if (htmlWriter instanceof ClassWriterImpl cw) {\n+                    containing = cw.getTypeElement();\n+                } else if (!utils.isPublic(containing)) {\n+                    reportWarning.accept(\"doclet.link.see.reference_not_accessible\",\n+                            new Object[] { utils.getFullyQualifiedName(containing)});\n+                } else {\n+                    if (!config.isDocLintReferenceGroupEnabled()) {\n+                        reportWarning.accept(\"doclet.link.see.reference_not_found\",\n+                                new Object[] { refSignature });\n+                    }\n+                }\n+            }\n+            String refMemName = refFragment;\n+            if (config.currentTypeElement != containing) {\n+                refMemName = (utils.isConstructor(refMem))\n+                        ? refMemName\n+                        : utils.getSimpleName(containing) + \".\" + refMemName;\n+            }\n+            if (utils.isExecutableElement(refMem)) {\n+                if (refMemName.indexOf('(') < 0) {\n+                    refMemName += utils.makeSignature((ExecutableElement) refMem, null, true);\n+                }\n+                if (overriddenMethod != null) {\n+                    \/\/ The method to actually link.\n+                    refMem = overriddenMethod;\n+                }\n+            }\n+\n+            return htmlWriter.getDocLink(HtmlLinkInfo.Kind.SHOW_PREVIEW, containing,\n+                    refMem, (labelContent.isEmpty()\n+                            ? plainOrCode(isLinkPlain, Text.of(refMemName))\n+                            : labelContent), null, false);\n+        }\n+    }\n+\n+    private Content plainOrCode(boolean plain, Content body) {\n+        return (plain || body.isEmpty()) ? body : HtmlTree.CODE(body);\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/LinkTaglet.java","additions":278,"deletions":0,"binary":false,"changes":278,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html.taglets;\n+\n+import java.util.EnumSet;\n+\n+import javax.lang.model.element.Element;\n+\n+import com.sun.source.doctree.DocTree;\n+import com.sun.source.doctree.LiteralTree;\n+\n+import jdk.javadoc.doclet.Taglet;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n+import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n+import jdk.javadoc.internal.doclets.toolkit.Content;\n+\n+\/**\n+ * An inline taglet used to denote literal text, possibly in monospace font.\n+ *\n+ * For example, the text:\n+ * <blockquote>  {@code {@literal a<B>c}}  <\/blockquote>\n+ * displays as:\n+ * <blockquote>  {@literal a<B>c}  <\/blockquote>\n+ *\n+ * <p> The tag {@code {@code ...}} is equivalent to\n+ * {@code <code>{@literal ...}<\/code>}.\n+ *\n+ * For example, the text:\n+ * <blockquote>  The type {@code {@code List<P>}}  <\/blockquote>\n+ * displays as:\n+ * <blockquote>  The type {@code List<P>}  <\/blockquote>\n+ *\/\n+public class LiteralTaglet extends BaseTaglet {\n+    LiteralTaglet(HtmlConfiguration config, DocTree.Kind tagKind) {\n+        super(config, tagKind, true, EnumSet.allOf(Taglet.Location.class));\n+    }\n+\n+    @Override\n+    public Content getInlineTagOutput(Element element, DocTree tag, TagletWriter tagletWriter) {\n+        var literalTree = (LiteralTree) tag;\n+        var body = Text.of(Text.normalizeNewlines(literalTree.getBody().getBody()));\n+        return tag.getKind() == DocTree.Kind.CODE ? HtmlTree.CODE(body) : body;\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/LiteralTaglet.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,316 @@\n+\/*\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html.taglets;\n+\n+import java.util.EnumSet;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+\n+import com.sun.source.doctree.DocTree;\n+import com.sun.source.doctree.ParamTree;\n+\n+import jdk.javadoc.doclet.Taglet;\n+import jdk.javadoc.internal.doclets.formats.html.Contents;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlIds;\n+import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n+import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n+import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;\n+import jdk.javadoc.internal.doclets.toolkit.util.DocFinder;\n+import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n+\n+\/**\n+ * A taglet that represents the {@code @param} tag.\n+ *\/\n+public class ParamTaglet extends BaseTaglet implements InheritableTaglet {\n+\n+    public enum ParamKind {\n+        \/** Parameter of an executable element. *\/\n+        PARAMETER,\n+        \/** State components of a record. *\/\n+        RECORD_COMPONENT,\n+        \/** Type parameters of an executable element or type element. *\/\n+        TYPE_PARAMETER\n+    }\n+\n+    private final Contents contents;\n+\n+    ParamTaglet(HtmlConfiguration config) {\n+        super(config, DocTree.Kind.PARAM, false, EnumSet.of(Taglet.Location.TYPE, Taglet.Location.CONSTRUCTOR, Taglet.Location.METHOD));\n+        contents = config.contents;\n+    }\n+\n+    @Override\n+    public Output inherit(Element dst, Element src, DocTree tag, boolean isFirstSentence) {\n+        assert dst.getKind() == ElementKind.METHOD;\n+        assert tag.getKind() == DocTree.Kind.PARAM;\n+        var method = (ExecutableElement) dst;\n+        var param = (ParamTree) tag;\n+        \/\/ find the position of an owner parameter described by the given tag\n+        List<? extends Element> parameterElements;\n+        if (param.isTypeParameter()) {\n+            parameterElements = method.getTypeParameters();\n+        } else {\n+            parameterElements = method.getParameters();\n+        }\n+        Map<String, Integer> stringIntegerMap = mapNameToPosition(utils, parameterElements);\n+        CommentHelper ch = utils.getCommentHelper(dst);\n+        Integer position = stringIntegerMap.get(ch.getParameterName(param));\n+        if (position == null) {\n+            return new Output(null, null, List.of(), true);\n+        }\n+        \/\/ try to inherit description of the respective parameter in an overridden method\n+        try {\n+            var docFinder = utils.docFinder();\n+\n+            Optional<Documentation> r;\n+            if (src != null){\n+                r = docFinder.search((ExecutableElement) src,\n+                                m -> DocFinder.Result.fromOptional(extract(utils, m, position, param.isTypeParameter())))\n+                        .toOptional();\n+            } else {\n+                r = docFinder.find((ExecutableElement) dst,\n+                                m -> DocFinder.Result.fromOptional(extract(utils, m, position, param.isTypeParameter())))\n+                        .toOptional();\n+            }\n+            return r.map(result -> new Output(result.paramTree, result.method, result.paramTree.getDescription(), true))\n+                    .orElseGet(() -> new Output(null, null, List.of(), true));\n+        } catch (DocFinder.NoOverriddenMethodFound e) {\n+            return new Output(null, null, List.of(), false);\n+        }\n+    }\n+\n+    \/**\n+     * Given a list of parameter elements, returns a name-position map.\n+     * @param params the list of parameters from a type or an executable member\n+     * @return a name-position map\n+     *\/\n+    private static Map<String, Integer> mapNameToPosition(Utils utils, List<? extends Element> params) {\n+        Map<String, Integer> result = new HashMap<>();\n+        int position = 0;\n+        for (Element e : params) {\n+            String name = utils.isTypeParameterElement(e)\n+                    ? utils.getTypeName(e.asType(), false)\n+                    : utils.getSimpleName(e);\n+            result.put(name, position);\n+            position++;\n+        }\n+        return result;\n+    }\n+\n+    @Override\n+    public Content getAllBlockTagOutput(Element holder, TagletWriter tagletWriter) {\n+        this.tagletWriter = tagletWriter;\n+        if (utils.isExecutableElement(holder)) {\n+            ExecutableElement member = (ExecutableElement) holder;\n+            Content output = convertParams(member, ParamKind.TYPE_PARAMETER,\n+                    utils.getTypeParamTrees(member), member.getTypeParameters(), tagletWriter);\n+            output.add(convertParams(member, ParamKind.PARAMETER,\n+                    utils.getParamTrees(member), member.getParameters(), tagletWriter));\n+            return output;\n+        } else {\n+            TypeElement typeElement = (TypeElement) holder;\n+            Content output = convertParams(typeElement, ParamKind.TYPE_PARAMETER,\n+                    utils.getTypeParamTrees(typeElement), typeElement.getTypeParameters(), tagletWriter);\n+            output.add(convertParams(typeElement, ParamKind.RECORD_COMPONENT,\n+                    utils.getParamTrees(typeElement), typeElement.getRecordComponents(), tagletWriter));\n+            return output;\n+        }\n+    }\n+\n+    \/**\n+     * Returns a {@code Content} representation of a list of {@code ParamTree}\n+     * of the specified kind.\n+     *\n+     * <p> This method correlates a {@code ParamTree} with a parameter\n+     * {@code Element} by name. Once it's done, a particular {@code ParamTree}\n+     * is addressed by the position (index) of the correlated {@code Element}\n+     * in the list of parameter elements. This is needed for documentation\n+     * inheritance because the corresponding parameters in the inheritance\n+     * hierarchy may be named differently.\n+     *\n+     * <p> This method warns about {@code @param} tags that do not map to\n+     * parameter elements and param tags that are duplicated. <\/p>\n+     *\n+     * @param kind the kind of <em>all<\/em> parameters in the lists\n+     *\/\n+    private Content convertParams(Element e,\n+                                  ParamKind kind,\n+                                  List<ParamTree> tags,\n+                                  List<? extends Element> parameters,\n+                                  TagletWriter writer) {\n+        Map<Integer, ParamTree> tagOfPosition = new HashMap<>();\n+        CommentHelper ch = utils.getCommentHelper(e);\n+        if (!tags.isEmpty()) {\n+            Map<String, Integer> positionOfName = mapNameToPosition(utils, parameters);\n+            for (ParamTree tag : tags) {\n+                String name = ch.getParameterName(tag);\n+                String paramName = kind == ParamKind.TYPE_PARAMETER ? \"<\" + name + \">\" : name;\n+                if (!positionOfName.containsKey(name)) {\n+                    String key = switch (kind) {\n+                        case PARAMETER -> \"doclet.Parameters_warn\";\n+                        case TYPE_PARAMETER -> \"doclet.TypeParameters_warn\";\n+                        case RECORD_COMPONENT -> \"doclet.RecordComponents_warn\";\n+                    };\n+                    if (!config.isDocLintReferenceGroupEnabled()) {\n+                        messages.warning(ch.getDocTreePath(tag), key, paramName);\n+                    }\n+                }\n+                Integer position = positionOfName.get(name);\n+                if (position != null) {\n+                    if (tagOfPosition.containsKey(position)) {\n+                        String key = switch (kind) {\n+                            case PARAMETER -> \"doclet.Parameters_dup_warn\";\n+                            case TYPE_PARAMETER -> \"doclet.TypeParameters_dup_warn\";\n+                            case RECORD_COMPONENT -> \"doclet.RecordComponents_dup_warn\";\n+                        };\n+                        if (!config.isDocLintReferenceGroupEnabled()) {\n+                            messages.warning(ch.getDocTreePath(tag), key, paramName);\n+                        }\n+                    } else {\n+                        tagOfPosition.put(position, tag);\n+                    }\n+                }\n+            }\n+        }\n+        \/\/ Document declared parameters for which tag documentation is available\n+        \/\/ (either directly or inherited) in order of their declaration.\n+        Content result = writer.getOutputInstance();\n+        for (int i = 0; i < parameters.size(); i++) {\n+            ParamTree tag = tagOfPosition.get(i);\n+            if (tag != null) {\n+                result.add(convertParam(e, kind, writer, tag,\n+                        ch.getParameterName(tag), result.isEmpty()));\n+            } else if (utils.isMethod(e)) {\n+                result.add(getInheritedTagletOutput(kind, e, writer,\n+                        parameters.get(i), i, result.isEmpty()));\n+            }\n+        }\n+        if (tags.size() > tagOfPosition.size()) {\n+            \/\/ Generate documentation for remaining tags that do not match a declared parameter.\n+            \/\/ These are erroneous but we generate them anyway.\n+            for (ParamTree tag : tags) {\n+                if (!tagOfPosition.containsValue(tag)) {\n+                    result.add(convertParam(e, kind, writer, tag,\n+                            ch.getParameterName(tag), result.isEmpty()));\n+                }\n+            }\n+        }\n+        return result;\n+    }\n+\n+    \/**\n+     * Tries to inherit documentation for a specific parameter (element).\n+     * If unsuccessful, the returned content is empty.\n+     *\/\n+    private Content getInheritedTagletOutput(ParamKind kind,\n+                                             Element holder,\n+                                             TagletWriter writer,\n+                                             Element param,\n+                                             int position,\n+                                             boolean isFirst) {\n+        Content result = writer.getOutputInstance();\n+        var r = utils.docFinder().search((ExecutableElement) holder,\n+                        m -> DocFinder.Result.fromOptional(extract(utils, m, position, kind == ParamTaglet.ParamKind.TYPE_PARAMETER)))\n+                .toOptional();\n+        if (r.isPresent()) {\n+            String name = kind != ParamKind.TYPE_PARAMETER\n+                    ? utils.getSimpleName(param)\n+                    : utils.getTypeName(param.asType(), false);\n+            Content content = convertParam(r.get().method, kind, writer,\n+                    r.get().paramTree, name, isFirst);\n+            result.add(content);\n+        }\n+        return result;\n+    }\n+\n+    private Content getParamHeader(ParamKind kind) {\n+        var header = switch (kind) {\n+            case PARAMETER -> contents.parameters;\n+            case TYPE_PARAMETER -> contents.typeParameters;\n+            case RECORD_COMPONENT -> contents.recordComponents;\n+        };\n+        return HtmlTree.DT(header);\n+    }\n+\n+    private Content paramTagOutput(Element element, ParamTree paramTag, String paramName) {\n+        var context = tagletWriter.context;\n+        var htmlWriter = tagletWriter.htmlWriter;\n+        var body = new ContentBuilder();\n+        CommentHelper ch = utils.getCommentHelper(element);\n+        \/\/ define id attributes for state components so that generated descriptions may refer to them\n+        boolean defineID = (element.getKind() == ElementKind.RECORD)\n+                && !paramTag.isTypeParameter();\n+        Content nameContent = Text.of(paramName);\n+        body.add(HtmlTree.CODE(defineID ? HtmlTree.SPAN_ID(HtmlIds.forParam(paramName), nameContent) : nameContent));\n+        body.add(\" - \");\n+        List<? extends DocTree> description = ch.getDescription(paramTag);\n+        body.add(htmlWriter.commentTagsToContent(element, description, context.within(paramTag)));\n+        return HtmlTree.DD(body);\n+    }\n+\n+    private record Documentation(ParamTree paramTree, ExecutableElement method) { }\n+\n+    private static Optional<Documentation> extract(Utils utils, ExecutableElement method, Integer position, boolean typeParam) {\n+        var ch = utils.getCommentHelper(method);\n+        List<ParamTree> tags = typeParam\n+                ? utils.getTypeParamTrees(method)\n+                : utils.getParamTrees(method);\n+        List<? extends Element> parameters = typeParam\n+                ? method.getTypeParameters()\n+                : method.getParameters();\n+        var positionOfName = mapNameToPosition(utils, parameters);\n+        return tags.stream().filter(t -> position.equals(positionOfName.get(ch.getParameterName(t))))\n+                .map(t -> new Documentation(t, method)).findAny();\n+    }\n+\n+    \/**\n+     * Converts an individual {@code ParamTree} to {@code Content}, which is\n+     * prepended with the header if the parameter is first in the list.\n+     *\/\n+    private Content convertParam(Element e,\n+                                 ParamKind kind,\n+                                 TagletWriter writer,\n+                                 ParamTree paramTag,\n+                                 String name,\n+                                 boolean isFirstParam) {\n+        Content result = writer.getOutputInstance();\n+        if (isFirstParam) {\n+            result.add(getParamHeader(kind));\n+        }\n+        result.add(paramTagOutput(e, paramTag, name));\n+        return result;\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/ParamTaglet.java","additions":316,"deletions":0,"binary":false,"changes":316,"status":"added"},{"patch":"@@ -0,0 +1,151 @@\n+\/*\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html.taglets;\n+\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.type.TypeMirror;\n+\n+import com.sun.source.doctree.DocTree;\n+import com.sun.source.doctree.ReturnTree;\n+\n+import jdk.javadoc.doclet.Taglet;\n+import jdk.javadoc.internal.doclets.formats.html.Contents;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n+import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n+import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.toolkit.util.DocFinder;\n+import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n+\n+\/**\n+ * A taglet that represents the {@code @return} and {@code {@return }} tags.\n+ *\/\n+public class ReturnTaglet extends BaseTaglet implements InheritableTaglet {\n+    private final Contents contents;\n+\n+    ReturnTaglet(HtmlConfiguration config) {\n+        super(config, DocTree.Kind.RETURN, true, EnumSet.of(Taglet.Location.METHOD));\n+        contents = config.contents;\n+    }\n+\n+    @Override\n+    public boolean isBlockTag() {\n+        return true;\n+    }\n+\n+    @Override\n+    public Output inherit(Element dst, Element src, DocTree tag, boolean isFirstSentence) {\n+        try {\n+            var docFinder = utils.docFinder();\n+            Optional<Documentation> r;\n+            if (src == null) {\n+                r = docFinder.find((ExecutableElement) dst, m -> DocFinder.Result.fromOptional(extract(utils, m))).toOptional();\n+            } else {\n+                r = docFinder.search((ExecutableElement) src, m -> DocFinder.Result.fromOptional(extract(utils, m))).toOptional();\n+            }\n+            return r.map(result -> new Output(result.returnTree, result.method, result.returnTree.getDescription(), true))\n+                    .orElseGet(() -> new Output(null, null, List.of(), true));\n+        } catch (DocFinder.NoOverriddenMethodFound e) {\n+            return new Output(null, null, List.of(), false);\n+        }\n+    }\n+\n+    @Override\n+    public Content getInlineTagOutput(Element element, DocTree tag, TagletWriter tagletWriter) {\n+        this.tagletWriter = tagletWriter;\n+        return returnTagOutput(element, (ReturnTree) tag, true);\n+    }\n+\n+    @Override\n+    public Content getAllBlockTagOutput(Element holder, TagletWriter tagletWriter) {\n+        assert holder.getKind() == ElementKind.METHOD : holder.getKind();\n+        var method = (ExecutableElement) holder;\n+        this.tagletWriter = tagletWriter;\n+        List<? extends ReturnTree> tags = utils.getReturnTrees(holder);\n+\n+        \/\/ make sure we are not using @return on a method with the void return type\n+        TypeMirror returnType = utils.getReturnType(tagletWriter.getCurrentPageElement(), method);\n+        if (returnType != null && utils.isVoid(returnType)) {\n+            if (!tags.isEmpty() && !config.isDocLintReferenceGroupEnabled()) {\n+                messages.warning(holder, \"doclet.Return_tag_on_void_method\");\n+            }\n+            return null;\n+        }\n+\n+        \/\/ it would also be good to check if there are more than one @return\n+        \/\/ tags and produce a warning or error similarly to how it's done\n+        \/\/ above for a case where @return is used for void\n+\n+        var docFinder = utils.docFinder();\n+        return docFinder.search(method, m -> DocFinder.Result.fromOptional(extract(utils, m))).toOptional()\n+                .map(r -> returnTagOutput(r.method, r.returnTree, false))\n+                .orElse(null);\n+    }\n+\n+    \/**\n+     * Returns the output for a {@code @return} tag.\n+     *\n+     * @param element   the element that owns the doc comment\n+     * @param returnTag the return tag to document\n+     * @param inline    whether this should be written as an inline instance or block instance\n+     *\n+     * @return the output\n+     *\/\n+    public Content returnTagOutput(Element element, ReturnTree returnTag, boolean inline) {\n+        var context = tagletWriter.context;\n+        var htmlWriter = tagletWriter.htmlWriter;\n+        var ch = utils.getCommentHelper(element);\n+        List<? extends DocTree> desc = ch.getDescription(returnTag);\n+        Content content = htmlWriter.commentTagsToContent(element, desc, context.within(returnTag));\n+        return inline\n+                ? new ContentBuilder(contents.getContent(\"doclet.Returns_0\", content))\n+                : new ContentBuilder(HtmlTree.DT(contents.returns), HtmlTree.DD(content));\n+    }\n+\n+    private record Documentation(ReturnTree returnTree, ExecutableElement method) { }\n+\n+    private static Optional<Documentation> extract(Utils utils, ExecutableElement method) {\n+        \/\/ TODO\n+        \/\/  Using getBlockTags(..., Kind.RETURN) for clarity. Since @return has become a bimodal tag,\n+        \/\/  Utils.getReturnTrees is now a misnomer: it returns only block returns, not all returns.\n+        \/\/  We could revisit this later.\n+        Stream<? extends ReturnTree> blockTags = utils.getBlockTags(method, DocTree.Kind.RETURN, ReturnTree.class).stream();\n+        Stream<? extends ReturnTree> mainDescriptionTags = utils.getFirstSentenceTrees(method).stream()\n+                .mapMulti((t, c) -> {\n+                    if (t.getKind() == DocTree.Kind.RETURN) c.accept((ReturnTree) t);\n+                });\n+        \/\/ this method should not check validity of @return tags, hence findAny and not findFirst or what have you\n+        return Stream.concat(blockTags, mainDescriptionTags)\n+                .map(t -> new Documentation(t, method)).findAny();\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/ReturnTaglet.java","additions":151,"deletions":0,"binary":false,"changes":151,"status":"added"},{"patch":"@@ -0,0 +1,195 @@\n+\/*\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html.taglets;\n+\n+import java.util.ArrayList;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+\n+import com.sun.source.doctree.DocTree;\n+import com.sun.source.doctree.SeeTree;\n+\n+import jdk.javadoc.doclet.Taglet;\n+import jdk.javadoc.internal.doclets.formats.html.ClassWriterImpl;\n+import jdk.javadoc.internal.doclets.formats.html.Contents;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlDocletWriter;\n+import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n+import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n+import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.toolkit.builders.SerializedFormBuilder;\n+import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;\n+import jdk.javadoc.internal.doclets.toolkit.util.DocFinder;\n+import jdk.javadoc.internal.doclets.toolkit.util.DocLink;\n+import jdk.javadoc.internal.doclets.toolkit.util.DocPath;\n+import jdk.javadoc.internal.doclets.toolkit.util.DocPaths;\n+import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n+\n+public class SeeTaglet extends BaseTaglet implements InheritableTaglet {\n+    SeeTaglet(HtmlConfiguration config) {\n+        super(config, DocTree.Kind.SEE, false, EnumSet.allOf(Taglet.Location.class));\n+        contents = config.contents;\n+    }\n+\n+    private final Contents contents;\n+    private HtmlDocletWriter htmlWriter;\n+\n+\n+    @Override\n+    public Output inherit(Element dst, Element src, DocTree tag, boolean isFirstSentence) {\n+        CommentHelper ch = utils.getCommentHelper(dst);\n+        var path = ch.getDocTreePath(tag);\n+        messages.warning(path, \"doclet.inheritDocWithinInappropriateTag\");\n+        return new Output(null, null, List.of(), true \/* true, otherwise there will be an exception up the stack *\/);\n+    }\n+\n+    @Override\n+    public Content getAllBlockTagOutput(Element holder, TagletWriter tagletWriter) {\n+        this.tagletWriter = tagletWriter;\n+        List<? extends SeeTree> tags = utils.getSeeTrees(holder);\n+        Element e = holder;\n+        if (utils.isMethod(holder)) {\n+            var docFinder = utils.docFinder();\n+            Optional<Documentation> result = docFinder.search((ExecutableElement) holder,\n+                    m -> DocFinder.Result.fromOptional(extract(utils, m))).toOptional();\n+            if (result.isPresent()) {\n+                ExecutableElement m = result.get().method();\n+                tags = utils.getSeeTrees(m);\n+                e = m;\n+            }\n+        }\n+        return seeTagOutput(e, tags);\n+    }\n+\n+    \/**\n+     * Returns the output for {@code @see} tags.\n+     *\n+     * @param holder The element that owns the doc comment\n+     * @param seeTags the list of tags\n+     *\n+     * @return the output\n+     *\/\n+    public Content seeTagOutput(Element holder, List<? extends SeeTree> seeTags) {\n+        htmlWriter = tagletWriter.htmlWriter;\n+\n+        List<Content> links = new ArrayList<>();\n+        for (SeeTree dt : seeTags) {\n+            links.add(seeTagOutput(holder, dt));\n+        }\n+        if (utils.isVariableElement(holder) && ((VariableElement)holder).getConstantValue() != null &&\n+                htmlWriter instanceof ClassWriterImpl classWriter) {\n+            \/\/Automatically add link to constant values page for constant fields.\n+            DocPath constantsPath =\n+                    htmlWriter.pathToRoot.resolve(DocPaths.CONSTANT_VALUES);\n+            String whichConstant =\n+                    classWriter.getTypeElement().getQualifiedName() + \".\" +\n+                            utils.getSimpleName(holder);\n+            DocLink link = constantsPath.fragment(whichConstant);\n+            links.add(htmlWriter.links.createLink(link,\n+                    contents.getContent(\"doclet.Constants_Summary\")));\n+        }\n+        if (utils.isClass(holder) && utils.isSerializable((TypeElement)holder)) {\n+            \/\/Automatically add link to serialized form page for serializable classes.\n+            if (SerializedFormBuilder.serialInclude(utils, holder) &&\n+                    SerializedFormBuilder.serialInclude(utils, utils.containingPackage(holder))) {\n+                DocPath serialPath = htmlWriter.pathToRoot.resolve(DocPaths.SERIALIZED_FORM);\n+                DocLink link = serialPath.fragment(utils.getFullyQualifiedName(holder));\n+                links.add(htmlWriter.links.createLink(link,\n+                        contents.getContent(\"doclet.Serialized_Form\")));\n+            }\n+        }\n+        if (links.isEmpty()) {\n+            return Text.EMPTY;\n+        }\n+\n+        var seeList = tagletWriter.tagList(links);\n+        return new ContentBuilder(\n+                HtmlTree.DT(contents.seeAlso),\n+                HtmlTree.DD(seeList));\n+    }\n+\n+    private record Documentation(List<? extends SeeTree> seeTrees, ExecutableElement method) { }\n+\n+    private static Optional<Documentation> extract(Utils utils, ExecutableElement method) {\n+        List<? extends SeeTree> tags = utils.getSeeTrees(method);\n+        return tags.isEmpty() ? Optional.empty() : Optional.of(new Documentation(tags, method));\n+    }\n+\n+    \/**\n+     * {@return the output for a single {@code @see} tag}\n+     *\n+     * @param element the element that has the documentation comment containing this tag\n+     * @param seeTag  the tag\n+     *\/\n+    private Content seeTagOutput(Element element, SeeTree seeTag) {\n+\n+        List<? extends DocTree> ref = seeTag.getReference();\n+        assert !ref.isEmpty();\n+        DocTree ref0 = ref.get(0);\n+        switch (ref0.getKind()) {\n+            case TEXT, START_ELEMENT -> {\n+                \/\/ @see \"Reference\"\n+                \/\/ @see <a href=\"...\">...<\/a>\n+                return htmlWriter.commentTagsToContent(element, ref, false, false);\n+            }\n+\n+            case REFERENCE -> {\n+                \/\/ @see reference label...\n+                CommentHelper ch = utils.getCommentHelper(element);\n+                String refSignature = ch.getReferencedSignature(ref0);\n+                List<? extends DocTree> label = ref.subList(1, ref.size());\n+\n+                var lt = (LinkTaglet) config.tagletManager.getTaglet(DocTree.Kind.LINK);\n+                return lt.linkSeeReferenceOutput(element,\n+                        seeTag,\n+                        refSignature,\n+                        ch.getReferencedElement(seeTag),\n+                        false,\n+                        htmlWriter.commentTagsToContent(element, label, tagletWriter.getContext().within(seeTag)),\n+                        (key, args) -> messages.warning(ch.getDocTreePath(seeTag), key, args),\n+                        tagletWriter\n+                );\n+            }\n+\n+            case ERRONEOUS -> {\n+                return tagletWriter.invalidTagOutput(resources.getText(\"doclet.tag.invalid_input\",\n+                                ref0.toString()),\n+                        Optional.empty());\n+            }\n+\n+            default -> throw new IllegalStateException(ref0.getKind().toString());\n+        }\n+\n+    }\n+\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/SeeTaglet.java","additions":195,"deletions":0,"binary":false,"changes":195,"status":"added"},{"patch":"@@ -0,0 +1,259 @@\n+\/*\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html.taglets;\n+\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+\n+import com.sun.source.doctree.BlockTagTree;\n+import com.sun.source.doctree.DocTree;\n+import com.sun.source.doctree.UnknownBlockTagTree;\n+\n+import jdk.javadoc.doclet.Taglet;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n+import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n+import jdk.javadoc.internal.doclets.formats.html.markup.RawHtml;\n+import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.toolkit.util.DocFinder;\n+\n+\/**\n+ * A custom single-argument block tag.\n+ *\/\n+public class SimpleTaglet extends BaseTaglet implements InheritableTaglet {\n+\n+    \/**\n+     * The header to output.\n+     *\/\n+    private final String header;\n+\n+    private final boolean enabled;\n+\n+    \/**\n+     * Constructs a {@code SimpleTaglet}.\n+     *\n+     * @param tagName   the name of this tag\n+     * @param header    the header to output\n+     * @param locations the possible locations that this tag can appear in\n+     *                  The string can contain 'p' for package, 't' for type,\n+     *                  'm' for method, 'c' for constructor and 'f' for field.\n+     *                  See {@link #getLocations(String) getLocations} for the\n+     *                  complete list.\n+     *\/\n+    SimpleTaglet(HtmlConfiguration config, String tagName, String header, String locations) {\n+        this(config, tagName, header, getLocations(locations), isEnabled(locations));\n+    }\n+\n+    \/**\n+     * Constructs a {@code SimpleTaglet}.\n+     *\n+     * @param tagKind   the kind of this tag\n+     * @param header    the header to output\n+     * @param locations the possible locations that this tag can appear in\n+     *\/\n+    SimpleTaglet(HtmlConfiguration config, DocTree.Kind tagKind, String header, Set<Taglet.Location> locations) {\n+        this(config, tagKind, header, locations, true);\n+    }\n+\n+    \/**\n+     * Constructs a {@code SimpleTaglet}.\n+     *\n+     * @param tagName   the name of this tag\n+     * @param header    the header to output\n+     * @param locations the possible locations that this tag can appear in\n+     *\/\n+    SimpleTaglet(HtmlConfiguration config, String tagName, String header, Set<Taglet.Location> locations) {\n+        this(config, tagName, header, locations, true);\n+    }\n+\n+    \/**\n+     * Constructs a {@code SimpleTaglet}.\n+     *\n+     * @param tagName   the name of this tag\n+     * @param header    the header to output\n+     * @param locations the possible locations that this tag can appear in\n+     *\/\n+    private SimpleTaglet(HtmlConfiguration config, String tagName, String header, Set<Taglet.Location> locations, boolean enabled) {\n+        super(config, tagName, false, locations);\n+        this.header = header;\n+        this.enabled = enabled;\n+    }\n+\n+    \/**\n+     * Constructs a {@code SimpleTaglet}.\n+     *\n+     * @param tagKind   the kind of this tag\n+     * @param header    the header to output\n+     * @param locations the possible locations that this tag can appear in\n+     *\/\n+    protected SimpleTaglet(HtmlConfiguration config, DocTree.Kind tagKind, String header, Set<Taglet.Location> locations, boolean enabled) {\n+        super(config, tagKind, false, locations);\n+        this.header = header;\n+        this.enabled = enabled;\n+    }\n+\n+    @Override\n+    public Output inherit(Element dst, Element src, DocTree tag, boolean isFirstSentence) {\n+        assert dst.getKind() == ElementKind.METHOD;\n+        assert !isFirstSentence;\n+        try {\n+            var docFinder = utils.docFinder();\n+            Optional<Documentation> r;\n+            if (src == null) {\n+                r = docFinder.find((ExecutableElement) dst,\n+                        m -> DocFinder.Result.fromOptional(extractFirst(m))).toOptional();\n+            } else {\n+                r = docFinder.search((ExecutableElement) src,\n+                        m -> DocFinder.Result.fromOptional(extractFirst(m))).toOptional();\n+            }\n+            return r.map(result -> new Output(result.tag, result.method, result.description, true))\n+                    .orElseGet(()->new Output(null, null, List.of(), true));\n+        } catch (DocFinder.NoOverriddenMethodFound e) {\n+            return new Output(null, null, List.of(), false);\n+        }\n+    }\n+\n+    \/**\n+     * Whether the taglet should generate output.\n+     * Standard tags like {@code @author}, {@code @since}, {@code @version} can\n+     * be disabled by command-line options; custom tags created with -tag can be\n+     * disabled with an X in the defining string.\n+     *\/\n+    boolean isEnabled() {\n+        return enabled;\n+    }\n+\n+    \/**\n+     * Returns whether this taglet accepts a {@code BlockTagTree} node.\n+     * The taglet accepts a tree node if it has the same kind, and\n+     * if the kind is {@code UNKNOWN_BLOCK_TAG} the same tag name.\n+     *\n+     * @param tree the tree node\n+     * @return {@code true} if this taglet accepts this tree node\n+     *\/\n+    private boolean accepts(BlockTagTree tree) {\n+        return (tree.getKind() == DocTree.Kind.UNKNOWN_BLOCK_TAG && tagKind == DocTree.Kind.UNKNOWN_BLOCK_TAG)\n+                ? tree.getTagName().equals(name)\n+                : tree.getKind() == tagKind;\n+    }\n+\n+    record Documentation(DocTree tag, List<? extends DocTree> description, ExecutableElement method) { }\n+\n+    private Optional<Documentation> extractFirst(ExecutableElement m) {\n+        List<? extends DocTree> tags = utils.getBlockTags(m, this::accepts);\n+        if (tags.isEmpty()) {\n+            return Optional.empty();\n+        }\n+        DocTree t = tags.get(0);\n+        return Optional.of(new Documentation(t, utils.getCommentHelper(m).getDescription(t), m));\n+    }\n+\n+    @Override\n+    public Content getAllBlockTagOutput(Element holder, TagletWriter tagletWriter) {\n+        this.tagletWriter = tagletWriter;\n+        List<? extends DocTree> tags = utils.getBlockTags(holder, this::accepts);\n+        if (header == null || tags.isEmpty()) {\n+            return null;\n+        }\n+        return simpleBlockTagOutput(holder, tags, header, tagletWriter);\n+    }\n+\n+    \/**\n+     * Returns the output for a series of simple tags.\n+     *\n+     * @param element    The element that owns the doc comment\n+     * @param simpleTags the list of simple tags\n+     * @param header     the header for the series of tags\n+     *\n+     * @return the output\n+     *\/\n+    private Content simpleBlockTagOutput(Element element,\n+                                        List<? extends DocTree> simpleTags,\n+                                        String header,\n+                                        TagletWriter writer) {\n+        var ch = utils.getCommentHelper(element);\n+        var context = tagletWriter.context;\n+        var htmlWriter = tagletWriter.htmlWriter;\n+\n+        ContentBuilder body = new ContentBuilder();\n+        boolean many = false;\n+        for (DocTree simpleTag : simpleTags) {\n+            if (many) {\n+                body.add(\", \");\n+            }\n+            List<? extends DocTree> bodyTags = ch.getBody(simpleTag);\n+            body.add(htmlWriter.commentTagsToContent(element, bodyTags, context.within(simpleTag)));\n+            many = true;\n+        }\n+        return new ContentBuilder(\n+                HtmlTree.DT(RawHtml.of(header)),\n+                HtmlTree.DD(body));\n+    }\n+\n+    private static Set<Taglet.Location> getLocations(String locations) {\n+        Set<Taglet.Location> set = EnumSet.noneOf(Taglet.Location.class);\n+        for (int i = 0; i < locations.length(); i++) {\n+            switch (locations.charAt(i)) {\n+                case 'a':  case 'A':\n+                    return EnumSet.allOf(Taglet.Location.class);\n+                case 'c':  case 'C':\n+                    set.add(Taglet.Location.CONSTRUCTOR);\n+                    break;\n+                case 'f':  case 'F':\n+                    set.add(Taglet.Location.FIELD);\n+                    break;\n+                case 'm':  case 'M':\n+                    set.add(Taglet.Location.METHOD);\n+                    break;\n+                case 'o':  case 'O':\n+                    set.add(Taglet.Location.OVERVIEW);\n+                    break;\n+                case 'p':  case 'P':\n+                    set.add(Taglet.Location.PACKAGE);\n+                    break;\n+                case 's':  case 'S':        \/\/ super-packages, anyone?\n+                    set.add(Taglet.Location.MODULE);\n+                    break;\n+                case 't':  case 'T':\n+                    set.add(Taglet.Location.TYPE);\n+                    break;\n+                case 'x':  case 'X':\n+                    break;\n+            }\n+        }\n+        return set;\n+    }\n+\n+    private static boolean isEnabled(String locations) {\n+        return locations.matches(\"[^Xx]*\");\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/SimpleTaglet.java","additions":259,"deletions":0,"binary":false,"changes":259,"status":"added"},{"patch":"@@ -0,0 +1,590 @@\n+\/*\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html.taglets;\n+\n+import java.io.IOException;\n+import java.util.EnumSet;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.PackageElement;\n+import javax.tools.Diagnostic;\n+import javax.tools.DocumentationTool;\n+import javax.tools.FileObject;\n+\n+import com.sun.source.doctree.AttributeTree;\n+import com.sun.source.doctree.DocTree;\n+import com.sun.source.doctree.SnippetTree;\n+import com.sun.source.doctree.TextTree;\n+import com.sun.source.util.DocTreePath;\n+\n+import jdk.javadoc.doclet.Taglet;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlAttr;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n+import jdk.javadoc.internal.doclets.formats.html.markup.TagName;\n+import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n+import jdk.javadoc.internal.doclets.formats.html.taglets.snippet.Action;\n+import jdk.javadoc.internal.doclets.formats.html.taglets.snippet.ParseException;\n+import jdk.javadoc.internal.doclets.formats.html.taglets.snippet.Parser;\n+import jdk.javadoc.internal.doclets.formats.html.taglets.snippet.Style;\n+import jdk.javadoc.internal.doclets.formats.html.taglets.snippet.StyledText;\n+import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.toolkit.DocletElement;\n+import jdk.javadoc.internal.doclets.toolkit.Resources;\n+import jdk.javadoc.internal.doclets.toolkit.util.DocPaths;\n+import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n+\n+\/**\n+ * A taglet that represents the {@code @snippet} tag.\n+ *\/\n+public class SnippetTaglet extends BaseTaglet {\n+\n+    public enum Language {\n+\n+        JAVA(\"java\"),\n+        PROPERTIES(\"properties\");\n+\n+        private static final Map<String, Language> languages;\n+\n+        static {\n+            Map<String, Language> tmp = new HashMap<>();\n+            for (var language : values()) {\n+                String id = Objects.requireNonNull(language.identifier);\n+                if (tmp.put(id, language) != null)\n+                    throw new IllegalStateException(); \/\/ 1-1 correspondence\n+            }\n+            languages = Map.copyOf(tmp);\n+        }\n+\n+        Language(String id) {\n+            identifier = id;\n+        }\n+\n+        private final String identifier;\n+\n+        public static Optional<Language> of(String identifier) {\n+            if (identifier == null)\n+                return Optional.empty();\n+            return Optional.ofNullable(languages.get(identifier));\n+        }\n+\n+        public String getIdentifier() {return identifier;}\n+    }\n+\n+    SnippetTaglet(HtmlConfiguration config) {\n+        super(config, DocTree.Kind.SNIPPET, true, EnumSet.allOf(Taglet.Location.class));\n+    }\n+\n+    \/*\n+     * A snippet can specify content by value (inline), by reference (external)\n+     * or both (hybrid).\n+     *\n+     * To specify content by value, a snippet uses its body; the body of\n+     * a snippet is the content.\n+     *\n+     * To specify content by reference, a snippet uses either the \"class\"\n+     * or \"file\" attribute; the value of that attribute refers to the content.\n+     *\n+     * A snippet can specify the \"region\" attribute. That attribute refines\n+     * the location of the content. The value of that attribute must match\n+     * one of the named regions in the snippets content.\n+     *\/\n+    @Override\n+    public Content getInlineTagOutput(Element holder, DocTree tag, TagletWriter tagletWriter) {\n+        this.tagletWriter = tagletWriter;\n+        try {\n+            return generateContent(holder, tag);\n+        } catch (BadSnippetException e) {\n+            error(tagletWriter, holder, e.tag(), e.key(), e.args());\n+            String details = config.getDocResources().getText(e.key(), e.args());\n+            return badSnippet(tagletWriter, Optional.of(details));\n+        }\n+    }\n+\n+    \/**\n+     * Returns the output for a {@code {@snippet ...}} tag.\n+     *\n+     * @param element    The element that owns the doc comment\n+     * @param tag        the snippet tag\n+     * @param id         the value of the id attribute, or null if not defined\n+     * @param lang       the value of the lang attribute, or null if not defined\n+     *\n+     * @return the output\n+     *\/\n+    private Content snippetTagOutput(Element element, SnippetTree tag, StyledText content,\n+                                       String id, String lang) {\n+        var pathToRoot = tagletWriter.htmlWriter.pathToRoot;\n+        var pre = new HtmlTree(TagName.PRE).setStyle(HtmlStyle.snippet);\n+        if (id != null && !id.isBlank()) {\n+            pre.put(HtmlAttr.ID, id);\n+        }\n+        var code = new HtmlTree(TagName.CODE)\n+                .addUnchecked(Text.EMPTY); \/\/ Make sure the element is always rendered\n+        if (lang != null && !lang.isBlank()) {\n+            code.addStyle(\"language-\" + lang);\n+        }\n+\n+        content.consumeBy((styles, sequence) -> {\n+            CharSequence text = Text.normalizeNewlines(sequence);\n+            if (styles.isEmpty()) {\n+                code.add(text);\n+            } else {\n+                Element e = null;\n+                String t = null;\n+                boolean linkEncountered = false;\n+                boolean markupEncountered = false;\n+                Set<String> classes = new HashSet<>();\n+                for (Style s : styles) {\n+                    if (s instanceof Style.Name n) {\n+                        classes.add(n.name());\n+                    } else if (s instanceof Style.Link l) {\n+                        assert !linkEncountered; \/\/ TODO: do not assert; pick the first link report on subsequent\n+                        linkEncountered = true;\n+                        t = l.target();\n+                        e = getLinkedElement(element, t);\n+                        if (e == null) {\n+                            \/\/ TODO: diagnostic output\n+                        }\n+                    } else if (s instanceof Style.Markup) {\n+                        markupEncountered = true;\n+                        break;\n+                    } else {\n+                        \/\/ TODO: transform this if...else into an exhaustive\n+                        \/\/ switch over the sealed Style hierarchy when \"Pattern\n+                        \/\/ Matching for switch\" has been implemented (JEP 406\n+                        \/\/ and friends)\n+                        throw new AssertionError(styles);\n+                    }\n+                }\n+                Content c;\n+                if (markupEncountered) {\n+                    return;\n+                } else if (linkEncountered) {\n+                    assert e != null;\n+                    \/\/disable preview tagging inside the snippets:\n+                    Utils.PreviewFlagProvider prevPreviewProvider = utils.setPreviewFlagProvider(el -> false);\n+                    try {\n+                        var lt = (LinkTaglet) config.tagletManager.getTaglet(DocTree.Kind.LINK);\n+                        c = lt.linkSeeReferenceOutput(element,\n+                                null,\n+                                t,\n+                                e,\n+                                false, \/\/ TODO: for now\n+                                Text.of(sequence.toString()),\n+                                (key, args) -> { \/* TODO: report diagnostic *\/ },\n+                                tagletWriter);\n+                    } finally {\n+                        utils.setPreviewFlagProvider(prevPreviewProvider);\n+                    }\n+                } else {\n+                    c = HtmlTree.SPAN(Text.of(text));\n+                    classes.forEach(((HtmlTree) c)::addStyle);\n+                }\n+                code.add(c);\n+            }\n+        });\n+        String copyText = resources.getText(\"doclet.Copy_to_clipboard\");\n+        String copiedText = resources.getText(\"doclet.Copied_to_clipboard\");\n+        String copySnippetText = resources.getText(\"doclet.Copy_snippet_to_clipboard\");\n+        var snippetContainer = HtmlTree.DIV(HtmlStyle.snippetContainer,\n+                new HtmlTree(TagName.BUTTON)\n+                        .add(HtmlTree.SPAN(Text.of(copyText))\n+                                .put(HtmlAttr.DATA_COPIED, copiedText))\n+                        .add(new HtmlTree(TagName.IMG)\n+                                .put(HtmlAttr.SRC, pathToRoot.resolve(DocPaths.CLIPBOARD_SVG).getPath())\n+                                .put(HtmlAttr.ALT, copySnippetText))\n+                        .addStyle(HtmlStyle.copy)\n+                        .addStyle(HtmlStyle.snippetCopy)\n+                        .put(HtmlAttr.ARIA_LABEL, copySnippetText)\n+                        .put(HtmlAttr.ONCLICK, \"copySnippet(this)\"));\n+        return snippetContainer.add(pre.add(code));\n+    }\n+\n+    private static final class BadSnippetException extends Exception {\n+\n+        @java.io.Serial\n+        private static final long serialVersionUID = 1;\n+\n+        private final transient DocTree tag;\n+        private final String key;\n+        private final transient Object[] args;\n+\n+        BadSnippetException(DocTree tag, String key, Object... args) {\n+            this.tag = tag;\n+            this.key = key;\n+            this.args = args;\n+        }\n+\n+        DocTree tag() {\n+            return tag;\n+        }\n+\n+        String key() {\n+            return key;\n+        }\n+\n+        Object[] args() {\n+            return args;\n+        }\n+    }\n+\n+    private Content generateContent(Element holder, DocTree tag)\n+            throws BadSnippetException\n+    {\n+        SnippetTree snippetTag = (SnippetTree) tag;\n+\n+        \/\/ organize snippet attributes in a map, performing basic checks along the way\n+        Map<String, AttributeTree> attributes = new HashMap<>();\n+        for (DocTree d : snippetTag.getAttributes()) {\n+            if (!(d instanceof AttributeTree a)) {\n+                continue; \/\/ this might be an ErroneousTree\n+            }\n+            if (attributes.putIfAbsent(a.getName().toString(), a) == null) {\n+                continue;\n+            }\n+            \/\/ two like-named attributes found; although we report on the most\n+            \/\/ recently encountered of the two, the iteration order might differ\n+            \/\/ from the source order (see JDK-8266826)\n+            throw new BadSnippetException(a, \"doclet.tag.attribute.repeated\",\n+                    a.getName().toString());\n+        }\n+\n+        final String CLASS = \"class\";\n+        final String FILE = \"file\";\n+\n+        final boolean containsClass = attributes.containsKey(CLASS);\n+        final boolean containsFile = attributes.containsKey(FILE);\n+        final boolean containsBody = snippetTag.getBody() != null;\n+\n+        if (containsClass && containsFile) {\n+            throw new BadSnippetException(attributes.get(CLASS),\n+                    \"doclet.snippet.contents.ambiguity.external\");\n+        } else if (!containsClass && !containsFile && !containsBody) {\n+            throw new BadSnippetException(tag, \"doclet.snippet.contents.none\");\n+        }\n+\n+        String regionName = null;\n+        AttributeTree region = attributes.get(\"region\");\n+        if (region != null) {\n+            regionName = stringValueOf(region);\n+            if (regionName.isBlank()) {\n+                throw new BadSnippetException(region, \"doclet.tag.attribute.value.illegal\",\n+                        \"region\", region.getValue());\n+            }\n+        }\n+\n+        String inlineContent = null, externalContent = null;\n+\n+        if (containsBody) {\n+            inlineContent = snippetTag.getBody().getBody();\n+        }\n+\n+        FileObject fileObject = null;\n+\n+        if (containsFile || containsClass) {\n+            AttributeTree a;\n+            String v = containsFile\n+                    ? stringValueOf((a = attributes.get(FILE)))\n+                    : stringValueOf((a = attributes.get(CLASS))).replace(\".\", \"\/\") + \".java\";\n+\n+            if (v.isBlank()) {\n+                throw new BadSnippetException(a, \"doclet.tag.attribute.value.illegal\",\n+                        containsFile ? FILE : CLASS, v);\n+            }\n+\n+            \/\/ we didn't create JavaFileManager, so we won't close it; even if an error occurs\n+            var fileManager = config.getFileManager();\n+\n+            try {\n+                \/\/ first, look in local snippet-files subdirectory\n+                var pkg = getPackageElement(holder, utils);\n+                var pkgLocation = utils.getLocationForPackage(pkg);\n+                var pkgName = pkg.getQualifiedName().toString(); \/\/ note: empty string for unnamed package\n+                var relativeName = \"snippet-files\/\" + v;\n+                fileObject = fileManager.getFileForInput(pkgLocation, pkgName, relativeName);\n+\n+                \/\/ if not found in local snippet-files directory, look on snippet path\n+                if (fileObject == null && fileManager.hasLocation(DocumentationTool.Location.SNIPPET_PATH)) {\n+                    fileObject = fileManager.getFileForInput(DocumentationTool.Location.SNIPPET_PATH, \"\", v);\n+                }\n+            } catch (IOException | IllegalArgumentException e) { \/\/ TODO: test this when JDK-8276892 is integrated\n+                \/\/ JavaFileManager.getFileForInput can throw IllegalArgumentException in certain cases\n+                throw new BadSnippetException(a, \"doclet.exception.read.file\", v, e);\n+            }\n+\n+            if (fileObject == null) {\n+                \/\/ i.e. the file does not exist\n+                throw new BadSnippetException(a, \"doclet.snippet_file_not_found\", v);\n+            }\n+\n+            try {\n+                externalContent = fileObject.getCharContent(true).toString();\n+            } catch (IOException e) {  \/\/ TODO: test this when JDK-8276892 is integrated\n+                throw new BadSnippetException(a, \"doclet.exception.read.file\",\n+                        fileObject.getName(), e);\n+            }\n+        }\n+\n+        String lang = null;\n+        AttributeTree langAttr = attributes.get(\"lang\");\n+        if (langAttr != null) {\n+            lang = stringValueOf(langAttr);\n+        } else if (containsClass) {\n+            lang = \"java\";\n+        } else if (containsFile) {\n+            lang = languageFromFileName(fileObject.getName());\n+        }\n+\n+        Optional<Language> language = Language.of(lang);\n+\n+\n+        \/\/ TODO cache parsed external snippet (WeakHashMap)\n+\n+        StyledText inlineSnippet = null;\n+        StyledText externalSnippet = null;\n+\n+        try {\n+            Diags d = (text, pos) -> {\n+                var path = utils.getCommentHelper(holder)\n+                        .getDocTreePath(snippetTag.getBody());\n+                config.getReporter().print(Diagnostic.Kind.WARNING,\n+                        path, pos, pos, pos, text);\n+            };\n+            if (inlineContent != null) {\n+                inlineSnippet = parse(resources, d, language, inlineContent);\n+            }\n+        } catch (ParseException e) {\n+            var path = utils.getCommentHelper(holder)\n+                    .getDocTreePath(snippetTag.getBody());\n+            \/\/ TODO: there should be a method in Messages; that method should mirror Reporter's; use that method instead accessing Reporter.\n+            String msg = resources.getText(\"doclet.snippet.markup\", e.getMessage());\n+            config.getReporter().print(Diagnostic.Kind.ERROR,\n+                    path, e.getPosition(), e.getPosition(), e.getPosition(), msg);\n+            return badSnippet(tagletWriter, Optional.of(e.getMessage()));\n+        }\n+\n+        try {\n+            var finalFileObject = fileObject;\n+            Diags d = (text, pos) -> messages.warning(finalFileObject, pos, pos, pos, text);\n+            if (externalContent != null) {\n+                externalSnippet = parse(resources, d, language, externalContent);\n+            }\n+        } catch (ParseException e) {\n+            assert fileObject != null;\n+            messages.error(fileObject, e.getPosition(),\n+                    e.getPosition(), e.getPosition(), \"doclet.snippet.markup\", e.getMessage());\n+            return badSnippet(tagletWriter, Optional.of(e.getMessage()));\n+        }\n+\n+        \/\/ the region must be matched at least in one content: it can be matched\n+        \/\/ in both, but never in none\n+        if (regionName != null) {\n+            StyledText r1 = null;\n+            StyledText r2 = null;\n+            if (inlineSnippet != null) {\n+                r1 = inlineSnippet.getBookmarkedText(regionName);\n+                if (r1 != null) {\n+                    inlineSnippet = r1;\n+                }\n+            }\n+            if (externalSnippet != null) {\n+                r2 = externalSnippet.getBookmarkedText(regionName);\n+                if (r2 != null) {\n+                    externalSnippet = r2;\n+                }\n+            }\n+            if (r1 == null && r2 == null) {\n+                throw new BadSnippetException(tag, \"doclet.snippet.region.not_found\", regionName);\n+            }\n+        }\n+\n+        if (inlineSnippet != null) {\n+            inlineSnippet = toDisplayForm(inlineSnippet);\n+        }\n+\n+        if (externalSnippet != null) {\n+            externalSnippet = toDisplayForm(externalSnippet);\n+        }\n+\n+        if (inlineSnippet != null && externalSnippet != null) {\n+            String inlineStr = inlineSnippet.asCharSequence().toString();\n+            String externalStr = externalSnippet.asCharSequence().toString();\n+            if (!Objects.equals(inlineStr, externalStr)) {\n+                throw new BadSnippetException(tag, \"doclet.snippet.contents.mismatch\", diff(inlineStr, externalStr));\n+            }\n+        }\n+\n+        assert inlineSnippet != null || externalSnippet != null;\n+        StyledText text = inlineSnippet != null ? inlineSnippet : externalSnippet;\n+\n+        AttributeTree idAttr = attributes.get(\"id\");\n+        String id = idAttr == null\n+                ? null\n+                : stringValueOf(idAttr);\n+\n+        return snippetTagOutput(holder, snippetTag, text, id, lang);\n+    }\n+\n+    \/*\n+     * Maybe there's a case for implementing a proper (or at least more helpful)\n+     * diff view, but for now simply outputting both sides of a hybrid snippet\n+     * would do. A user could then use a diff tool of their choice to compare\n+     * those sides.\n+     *\n+     * There's a separate issue of mapping discrepancies back to their\n+     * originating source in the doc comment and the external file. Maybe there\n+     * is a value in it, or maybe there isn't. In any case, accurate mapping\n+     * would not be trivial to code.\n+     *\/\n+    private static String diff(String inline, String external) {\n+        return \"\"\"\n+               ----------------- inline -------------------\n+               %s\n+               ----------------- external -----------------\n+               %s\n+               \"\"\".formatted(inline, external);\n+    }\n+\n+    private StyledText parse(Resources resources, Diags diags, Optional<Language> language, String content) throws ParseException {\n+        Parser.Result result = new Parser(resources).parse(diags, language, content);\n+        result.actions().forEach(Action::perform);\n+        return result.text();\n+    }\n+\n+    public interface Diags {\n+        void warn(String text, int pos);\n+    }\n+\n+    private static String stringValueOf(AttributeTree at) throws BadSnippetException {\n+        if (at.getValueKind() == AttributeTree.ValueKind.EMPTY) {\n+            throw new BadSnippetException(at, \"doclet.tag.attribute.value.missing\",\n+                    at.getName().toString());\n+        }\n+        return at.getValue().stream()\n+                \/\/ value consists of TextTree or ErroneousTree nodes;\n+                \/\/ ErroneousTree is a subtype of TextTree\n+                .map(t -> ((TextTree) t).getBody())\n+                .collect(Collectors.joining());\n+    }\n+\n+    private String languageFromFileName(String fileName) {\n+        \/\/ TODO: find a way to extend\/customize the list of recognized file name extensions\n+        if (fileName.endsWith(\".java\")) {\n+            return \"java\";\n+        } else if (fileName.endsWith(\".properties\")) {\n+            return \"properties\";\n+        }\n+        return null;\n+    }\n+\n+    private void error(TagletWriter writer, Element holder, DocTree tag, String key, Object... args) {\n+        messages.error(utils.getCommentHelper(holder).getDocTreePath(tag), key, args);\n+    }\n+\n+    private Content badSnippet(TagletWriter writer, Optional<String> details) {\n+        var resources = config.getDocResources();\n+        return writer.invalidTagOutput(resources.getText(\"doclet.tag.invalid\", \"snippet\"), details);\n+    }\n+\n+    private static PackageElement getPackageElement(Element e, Utils utils) {\n+        if (e instanceof DocletElement de) {\n+            return de.getPackageElement();\n+        } else {\n+            return utils.elementUtils.getPackageOf(e);\n+        }\n+    }\n+\n+    \/*\n+     * Returns a version of styled text that can be rendered into HTML or\n+     * compared to another such version. The latter is used to decide if inline\n+     * and external parts of a hybrid snippet match.\n+     *\n+     * Use this method to obtain a final version of text. After all\n+     * transformations on text have been performed, call this method with that\n+     * text and then use the returned result as described above.\n+     *\/\n+    private static StyledText toDisplayForm(StyledText source) {\n+        var sourceString = source.asCharSequence().toString();\n+        var result = new StyledText();\n+        var originalLines = sourceString.lines().iterator();\n+        var unindentedLines = sourceString.stripIndent().lines().iterator();\n+        \/\/ done; the rest of the method translates the stripIndent\n+        \/\/ transformation performed on a character sequence to the styled\n+        \/\/ text that this sequence originates from, line by line\n+        int pos = 0;\n+        \/\/ overcome a \"quirk\" of String.lines\n+        boolean endsWithLineFeed = !sourceString.isEmpty() && sourceString.charAt(source.length() - 1) == '\\n';\n+        while (originalLines.hasNext() && unindentedLines.hasNext()) { \/\/ [^1]\n+            String originalLine = originalLines.next();\n+            String unindentedLine = unindentedLines.next();\n+            \/\/ the search MUST succeed\n+            int idx = originalLine.indexOf(unindentedLine);\n+            \/\/ assume newlines are always of the \\n form\n+            \/\/ append the found fragment\n+            result.append(source.subText(pos + idx, pos + idx + unindentedLine.length()));\n+            \/\/ append the possibly styled newline, but not if it's the last line\n+            int eol = pos + originalLine.length();\n+            if (originalLines.hasNext() || endsWithLineFeed) {\n+                result.append(source.subText(eol, eol + 1));\n+            }\n+            pos = eol + 1;\n+        }\n+        return result;\n+        \/\/ [^1]: Checking hasNext() on both iterators might look unnecessary.\n+        \/\/ However, there are strings for which those iterators return different\n+        \/\/ number of lines. That is, there exists a string s, such that\n+        \/\/\n+        \/\/     s.lines().count() != s.stripIndent().lines().count()\n+        \/\/\n+        \/\/ The most trivial example of such a string is \" \". In fact, any string\n+        \/\/ with a trailing non-empty blank line would do.\n+    }\n+\n+    \/*\n+     * Returns the element that is linked from the context of the referrer using\n+     * the provided signature; returns null if such element could not be found.\n+     *\n+     * This method is to be used when it is the target of the link that is\n+     * important, not the container of the link (e.g. was it an @see,\n+     * @link\/@linkplain or @snippet tags, etc.)\n+     *\/\n+    private Element getLinkedElement(Element referer, String signature) {\n+        var factory = utils.docTrees.getDocTreeFactory();\n+        var docCommentTree = utils.getDocCommentTree(referer);\n+        var rootPath = new DocTreePath(utils.getTreePath(referer), docCommentTree);\n+        var reference = factory.newReferenceTree(signature);\n+        var fabricatedPath = new DocTreePath(rootPath, reference);\n+        return utils.docTrees.getElement(fabricatedPath);\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/SnippetTaglet.java","additions":590,"deletions":0,"binary":false,"changes":590,"status":"added"},{"patch":"@@ -0,0 +1,165 @@\n+\/*\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html.taglets;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+\n+import com.sun.source.doctree.DocTree;\n+import com.sun.source.doctree.SpecTree;\n+import com.sun.source.doctree.TextTree;\n+import com.sun.source.util.DocTreePath;\n+\n+import jdk.javadoc.doclet.Taglet;\n+import jdk.javadoc.internal.doclets.formats.html.Contents;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n+import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n+import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n+import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;\n+import jdk.javadoc.internal.doclets.toolkit.util.DocFinder;\n+import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n+\n+\/**\n+ * A taglet that represents the {@code @spec} tag.\n+ *\/\n+public class SpecTaglet extends BaseTaglet implements InheritableTaglet {\n+    private final Contents contents;\n+\n+    SpecTaglet(HtmlConfiguration config) {\n+        super(config, DocTree.Kind.SPEC, false, EnumSet.allOf(Taglet.Location.class));\n+        this.contents = config.contents;\n+    }\n+\n+    @Override\n+    public Output inherit(Element dst, Element src, DocTree tag, boolean isFirstSentence) {\n+        CommentHelper ch = utils.getCommentHelper(dst);\n+        var path = ch.getDocTreePath(tag);\n+        messages.warning(path, \"doclet.inheritDocWithinInappropriateTag\");\n+        return new Output(null, null, List.of(), true \/* true, otherwise there will be an exception up the stack *\/);\n+    }\n+\n+    @Override\n+    public Content getAllBlockTagOutput(Element holder, TagletWriter tagletWriter) {\n+        this.tagletWriter = tagletWriter;\n+        List<? extends SpecTree> tags = utils.getSpecTrees(holder);\n+        Element e = holder;\n+        if (utils.isMethod(holder)) {\n+            var docFinder = utils.docFinder();\n+            Optional<Documentation> result = docFinder.search((ExecutableElement) holder,\n+                    m -> DocFinder.Result.fromOptional(extract(utils, m))).toOptional();\n+            if (result.isPresent()) {\n+                e = result.get().method();\n+                tags = result.get().specTrees();\n+            }\n+        }\n+        return specTagOutput(e, tags);\n+    }\n+\n+    \/**\n+     * Returns the output for one or more {@code @spec} tags.\n+     *\n+     * @param holder  the element that owns the doc comment\n+     * @param specTags the array of @spec tags.\n+     *\n+     * @return the output\n+     *\/\n+    public Content specTagOutput(Element holder, List<? extends SpecTree> specTags) {\n+        if (specTags.isEmpty()) {\n+            return Text.EMPTY;\n+        }\n+\n+        var links = specTags.stream()\n+                .map(st -> specTagToContent(holder, st)).toList();\n+\n+        var specList = tagletWriter.tagList(links);\n+        return new ContentBuilder(\n+                HtmlTree.DT(contents.externalSpecifications),\n+                HtmlTree.DD(specList));\n+    }\n+\n+    private record Documentation(List<? extends SpecTree> specTrees, ExecutableElement method) { }\n+\n+    private static Optional<Documentation> extract(Utils utils, ExecutableElement method) {\n+        List<? extends SpecTree> tags = utils.getSpecTrees(method);\n+        return tags.isEmpty() ? Optional.empty() : Optional.of(new Documentation(tags, method));\n+    }\n+\n+    private Content specTagToContent(Element holder, SpecTree specTree) {\n+        var htmlWriter = tagletWriter.htmlWriter;\n+        String specTreeURL = specTree.getURL().getBody();\n+        List<? extends DocTree> specTreeLabel = specTree.getTitle();\n+        Content label = htmlWriter.commentTagsToContent(holder, specTreeLabel, tagletWriter.context.isFirstSentence);\n+        return getExternalSpecContent(holder, specTree, specTreeURL,\n+                textOf(specTreeLabel).replaceAll(\"\\\\s+\", \" \"), label);\n+    }\n+\n+    private String textOf(List<? extends DocTree> trees) {\n+        return trees.stream()\n+                .filter(dt -> dt instanceof TextTree)\n+                .map(dt -> ((TextTree) dt).getBody().trim())\n+                .collect(Collectors.joining(\" \"));\n+    }\n+\n+    Content getExternalSpecContent(Element holder,\n+                                   DocTree docTree,\n+                                   String url,\n+                                   String searchText,\n+                                   Content title) {\n+        URI specURI;\n+        try {\n+            \/\/ Use the canonical title of the spec if one is available\n+            specURI = new URI(url);\n+        } catch (URISyntaxException e) {\n+            CommentHelper ch = utils.getCommentHelper(holder);\n+            DocTreePath dtp = ch.getDocTreePath(docTree);\n+            tagletWriter.htmlWriter.messages.error(dtp, \"doclet.Invalid_URL\", e.getMessage());\n+            specURI = null;\n+        }\n+\n+        Content titleWithAnchor = tagletWriter.createAnchorAndSearchIndex(holder,\n+                searchText,\n+                title,\n+                resources.getText(\"doclet.External_Specification\"),\n+                docTree);\n+\n+        if (specURI == null) {\n+            return titleWithAnchor;\n+        } else {\n+            var htmlWriter = tagletWriter.htmlWriter;\n+            return HtmlTree.A(htmlWriter.resolveExternalSpecURI(specURI), titleWithAnchor);\n+        }\n+\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/SpecTaglet.java","additions":165,"deletions":0,"binary":false,"changes":165,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html.taglets;\n+\n+import java.util.EnumSet;\n+\n+import javax.lang.model.element.Element;\n+\n+import com.sun.source.doctree.DocTree;\n+import com.sun.source.doctree.SummaryTree;\n+\n+import jdk.javadoc.doclet.Taglet.Location;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n+import jdk.javadoc.internal.doclets.toolkit.Content;\n+\n+\/**\n+ * A taglet that represents the {@code {@summary}} tag.\n+ *\/\n+public class SummaryTaglet extends BaseTaglet {\n+\n+    SummaryTaglet(HtmlConfiguration config) {\n+        super(config, DocTree.Kind.SUMMARY, true, EnumSet.allOf(Location.class));\n+    }\n+\n+    @Override\n+    public Content getInlineTagOutput(Element holder, DocTree tag, TagletWriter tagletWriter) {\n+        return tagletWriter.commentTagsToOutput(holder, tag, ((SummaryTree)tag).getSummary(),\n+                tagletWriter.context.isFirstSentence);\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/SummaryTaglet.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html.taglets;\n+\n+import java.util.EnumSet;\n+\n+import javax.lang.model.element.Element;\n+\n+import com.sun.source.doctree.DocTree;\n+import com.sun.source.doctree.SystemPropertyTree;\n+\n+import jdk.javadoc.doclet.Taglet;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n+import jdk.javadoc.internal.doclets.toolkit.Content;\n+\n+\/**\n+ * A taglet that represents the {@code @systemProperty} tag.\n+ *\/\n+public class SystemPropertyTaglet extends BaseTaglet {\n+\n+    SystemPropertyTaglet(HtmlConfiguration config) {\n+        super(config, DocTree.Kind.SYSTEM_PROPERTY, true, EnumSet.allOf(Taglet.Location.class));\n+    }\n+\n+    @Override\n+    public Content getInlineTagOutput(Element element, DocTree tag, TagletWriter tagletWriter) {\n+        this.tagletWriter = tagletWriter;\n+        return systemPropertyTagOutput(element, (SystemPropertyTree) tag);\n+    }\n+\n+    \/**\n+     * Returns the output for a {@code {@systemProperty...}} tag.\n+     *\n+     * @param element the element that owns the doc comment\n+     * @param tag     the system property tag\n+     *\n+     * @return the output\n+     *\/\n+    private Content systemPropertyTagOutput(Element element, SystemPropertyTree tag) {\n+        String tagText = tag.getPropertyName().toString();\n+        return HtmlTree.CODE(tagletWriter.createAnchorAndSearchIndex(element, tagText,\n+                resources.getText(\"doclet.System_Property\"), tag));\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/SystemPropertyTaglet.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,182 @@\n+\/*\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html.taglets;\n+\n+import java.util.Set;\n+import javax.lang.model.element.Element;\n+\n+import com.sun.source.doctree.DocTree;\n+import jdk.javadoc.doclet.Taglet.Location;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n+import jdk.javadoc.internal.doclets.toolkit.Content;\n+\n+\/**\n+ * This is the taglet interface used internally within the doclet.\n+ *\n+ * The public {@link jdk.javadoc.doclet.Taglet} interface only supports\n+ * output to strings.   This interface supports structured output,\n+ * to {@link Content} objects, such as {@link HtmlTree}.\n+ *\n+ * User-provided taglets are supported using the {@link UserTaglet}\n+ * wrapper class.\n+ *\/\n+public interface Taglet {\n+    \/**\n+     * Returns the set of allowed locations for a block tag handled by this taglet.\n+     *\n+     * @return the set of allowable locations\n+     *\/\n+    Set<Location> getAllowedLocations();\n+\n+    \/**\n+     * Indicates whether this {@code Taglet} can be used in field documentation.\n+     *\n+     * @return {@code true} if this {@code Taglet} can be used in field documentation\n+     *         and {@code false} otherwise\n+     *\/\n+    default boolean inField() {\n+        return getAllowedLocations().contains(Location.FIELD);\n+    }\n+\n+    \/**\n+     * Indicates whether this {@code Taglet} can be used in constructor documentation.\n+     *\n+     * @return {@code true} if this {@code Taglet} can be used in constructor documentation\n+     *         and {@code false} otherwise\n+     *\/\n+    default boolean inConstructor() {\n+        return getAllowedLocations().contains(Location.CONSTRUCTOR);\n+    }\n+\n+    \/**\n+     * Indicates whether this {@code Taglet} can be used in method documentation.\n+     *\n+     * @return {@code true} if this {@code Taglet} can be used in method documentation\n+     *         and {@code false} otherwise\n+     *\/\n+    default boolean inMethod() {\n+        return getAllowedLocations().contains(Location.METHOD);\n+    }\n+\n+    \/**\n+     * Indicates whether this {@code Taglet} can be used in overview documentation.\n+     *\n+     * @return {@code true} if this {@code Taglet} can be used in overview documentation\n+     *         and {@code false} otherwise\n+     *\/\n+    default boolean inOverview() {\n+        return getAllowedLocations().contains(Location.OVERVIEW);\n+    }\n+\n+    \/**\n+     * Indicates whether this {@code Taglet} can be used in module documentation.\n+     *\n+     * @return {@code true} if this {@code Taglet} can be used in module documentation\n+     *         and {@code false} otherwise\n+     *\/\n+    default boolean inModule()  {\n+        return getAllowedLocations().contains(Location.MODULE);\n+    }\n+\n+    \/**\n+     * Indicates whether this {@code Taglet} can be used in package documentation.\n+     *\n+     * @return {@code true} if this {@code Taglet} can be used in package documentation\n+     *         and {@code false} otherwise\n+     *\/\n+    default boolean inPackage() {\n+        return getAllowedLocations().contains(Location.PACKAGE);\n+    }\n+\n+    \/**\n+     * Indicates whether this {@code Taglet} can be used in type documentation (classes or interfaces).\n+     *\n+     * @return {@code true} if this {@code Taglet} can be used in type documentation\n+     *         and {@code false} otherwise\n+     *\/\n+    default boolean inType()  {\n+        return getAllowedLocations().contains(Location.TYPE);\n+    }\n+\n+    \/**\n+     * Indicates whether this {@code Taglet} represents an inline tag.\n+     *\n+     * @return {@code true} if this {@code Taglet} represents an inline tag\n+     *         and {@code false} otherwise\n+     *\/\n+    boolean isInlineTag();\n+\n+    \/**\n+     * Indicates whether this {@code Taglet} represents a block tag.\n+     *\n+     * @return {@code true} if this {@code Taglet} represents a block tag\n+     * @implSpec This implementation returns the inverse\n+     * result to {@code isInlineTag}.\n+     *\/\n+    default boolean isBlockTag() {\n+        return !isInlineTag();\n+    }\n+\n+    \/**\n+     * Returns the name of this tag.\n+     * @return the name of this tag\n+     *\/\n+    String getName();\n+\n+    \/**\n+     * Returns the content to be included in the generated output for an\n+     * instance of an inline tag handled by this taglet.\n+     *\n+     * @param owner  the element for the enclosing doc comment\n+     * @param tag    the tag\n+     * @param tagletWriter the taglet-writer used in this doclet\n+     *\n+     * @return the output for this tag\n+     * @throws UnsupportedTagletOperationException if the method is not supported by the taglet\n+     *\/\n+    Content getInlineTagOutput(Element owner, DocTree tag, TagletWriter tagletWriter) throws\n+            UnsupportedTagletOperationException;\n+\n+    \/**\n+     * Returns the content to be included in the generated output for\n+     * all instances of block tags handled by this taglet.\n+     *\n+     * @param owner  the element for the enclosing doc comment\n+     * @param tagletWriter the taglet-writer used in this doclet\n+     *\n+     * @return the output for this tag\n+     * @throws UnsupportedTagletOperationException if the method is not supported by the taglet\n+     *\/\n+    Content getAllBlockTagOutput(Element owner, TagletWriter tagletWriter) throws\n+            UnsupportedTagletOperationException;\n+\n+    class UnsupportedTagletOperationException extends UnsupportedOperationException {\n+        private static final long serialVersionUID = -3530273193380250271L;\n+        public UnsupportedTagletOperationException(String message) {\n+            super(message);\n+        }\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/Taglet.java","additions":182,"deletions":0,"binary":false,"changes":182,"status":"added"},{"patch":"@@ -0,0 +1,749 @@\n+\/*\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html.taglets;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.PrintStream;\n+import java.util.ArrayList;\n+import java.util.EnumMap;\n+import java.util.EnumSet;\n+import java.util.HashSet;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.ServiceLoader;\n+import java.util.Set;\n+import java.util.TreeMap;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.ModuleElement;\n+import javax.lang.model.element.PackageElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.util.SimpleElementVisitor14;\n+import javax.tools.JavaFileManager;\n+import javax.tools.StandardJavaFileManager;\n+\n+import com.sun.source.doctree.DocTree;\n+\n+import jdk.javadoc.doclet.Doclet;\n+import jdk.javadoc.doclet.DocletEnvironment;\n+import jdk.javadoc.doclet.Taglet.Location;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlOptions;\n+import jdk.javadoc.internal.doclets.toolkit.DocletElement;\n+import jdk.javadoc.internal.doclets.toolkit.Messages;\n+import jdk.javadoc.internal.doclets.toolkit.Resources;\n+import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;\n+import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n+\n+import static com.sun.source.doctree.DocTree.Kind.AUTHOR;\n+import static com.sun.source.doctree.DocTree.Kind.EXCEPTION;\n+import static com.sun.source.doctree.DocTree.Kind.HIDDEN;\n+import static com.sun.source.doctree.DocTree.Kind.PARAM;\n+import static com.sun.source.doctree.DocTree.Kind.PROVIDES;\n+import static com.sun.source.doctree.DocTree.Kind.SEE;\n+import static com.sun.source.doctree.DocTree.Kind.SERIAL;\n+import static com.sun.source.doctree.DocTree.Kind.SERIAL_DATA;\n+import static com.sun.source.doctree.DocTree.Kind.SERIAL_FIELD;\n+import static com.sun.source.doctree.DocTree.Kind.SINCE;\n+import static com.sun.source.doctree.DocTree.Kind.THROWS;\n+import static com.sun.source.doctree.DocTree.Kind.USES;\n+import static com.sun.source.doctree.DocTree.Kind.VERSION;\n+\n+import static javax.tools.DocumentationTool.Location.TAGLET_PATH;\n+\n+\/**\n+ * Manages the {@code Taglet}s used by the standard doclet.\n+ *\/\n+public class TagletManager {\n+\n+    \/**\n+     * All taglets, keyed either by their {@link Taglet#getName() name},\n+     * or by an alias.\n+     *\n+     * In general, taglets do <i>not<\/i> provide aliases;\n+     * the one instance that does is {@code ThrowsTaglet}, which handles\n+     * both {@code @throws} tags and {@code @exception} tags.\n+     *\/\n+    private final LinkedHashMap<String, Taglet> allTaglets;\n+\n+    \/**\n+     * Block (non-inline) taglets, grouped by {@link Location location}.\n+     *\/\n+    private Map<Location, List<Taglet>> blockTagletsByLocation;\n+\n+    \/**\n+     * The taglets that can appear inline in descriptive text.\n+     *\/\n+    private Map<String, Taglet> inlineTags;\n+\n+    \/**\n+     * The taglets that can appear in the serialized form.\n+     *\/\n+    private List<Taglet> serializedFormTags;\n+\n+    private final DocletEnvironment docEnv;\n+    private final Doclet doclet;\n+\n+    private final Utils utils;\n+    private final Messages messages;\n+    private final Resources resources;\n+\n+    \/**\n+     * Keep track of standard tags.\n+     *\/\n+    private final Set<String> standardTags;\n+\n+    \/**\n+     * Keep track of standard tags in lowercase to compare for better\n+     * error messages when a tag like {@code @docRoot} is mistakenly spelled\n+     * lowercase {@code @docroot}.\n+     *\/\n+    private final Set<String> standardTagsLowercase;\n+\n+    \/**\n+     * Keep track of overridden standard tags.\n+     *\/\n+    private final Set<String> overriddenStandardTags;\n+\n+    \/**\n+     * Keep track of the tags that may conflict\n+     * with standard tags in the future (any custom tag without\n+     * a period in its name).\n+     *\/\n+    private final Set<String> potentiallyConflictingTags;\n+\n+    \/**\n+     * The set of unseen custom tags.\n+     *\/\n+    private final Set<String> unseenCustomTags;\n+\n+    \/**\n+     * True if we do not want to use {@code @since} tags.\n+     *\/\n+    private final boolean nosince;\n+\n+    \/**\n+     * True if we want to use {@code @version} tags.\n+     *\/\n+    private final boolean showversion;\n+\n+    \/**\n+     * True if we want to use {@code @author} tags.\n+     *\/\n+    private final boolean showauthor;\n+\n+    \/**\n+     * True if we want to use JavaFX-related tags ({@code @defaultValue}, {@code @treatAsPrivate}).\n+     *\/\n+    private final boolean javafx;\n+\n+    \/**\n+     * Show the taglets table when it has been initialized.\n+     *\/\n+    private final boolean showTaglets;\n+\n+    private final String tagletPath;\n+\n+    private final HtmlConfiguration config;\n+\n+    \/**\n+     * Constructs a new {@code TagletManager}.\n+     *\n+     * @param config the configuration for this taglet manager\n+     *\/\n+    public TagletManager(HtmlConfiguration config) {\n+        overriddenStandardTags = new HashSet<>();\n+        potentiallyConflictingTags = new HashSet<>();\n+        standardTags = new HashSet<>();\n+        standardTagsLowercase = new HashSet<>();\n+        unseenCustomTags = new HashSet<>();\n+        allTaglets = new LinkedHashMap<>();\n+        this.config = config;\n+        HtmlOptions options = config.getOptions();\n+        this.nosince = options.noSince();\n+        this.showversion = options.showVersion();\n+        this.showauthor = options.showAuthor();\n+        this.javafx = options.javafx();\n+        this.docEnv = config.docEnv;\n+        this.doclet = config.doclet;\n+        this.messages = config.getMessages();\n+        this.resources = config.getDocResources();\n+        this.showTaglets = options.showTaglets();\n+        this.utils = config.utils;\n+        this.tagletPath = options.tagletPath();\n+        initStandardTaglets();\n+    }\n+\n+    public Set<String> getAllTagletNames() {\n+        return allTaglets.keySet();\n+    }\n+\n+    \/**\n+     * Initializes the location TAGLET_PATH which is used to locate the custom taglets.\n+     *\n+     * @param fileManager the file manager to load classes and resources\n+     * @throws IOException if an error occurs while setting the location\n+     *\/\n+    public void initTagletPath(JavaFileManager fileManager) throws IOException {\n+        if (fileManager instanceof StandardJavaFileManager sfm) {\n+            if (tagletPath != null) {\n+                List<File> paths = new ArrayList<>();\n+                for (String pathname : tagletPath.split(File.pathSeparator)) {\n+                    paths.add(new File(pathname));\n+                }\n+                sfm.setLocation(TAGLET_PATH, paths);\n+            } else if (!sfm.hasLocation(TAGLET_PATH)) {\n+                sfm.setLocation(TAGLET_PATH, List.of());\n+            }\n+        } else if (tagletPath != null) {\n+            messages.error(\"doclet.not_standard_file_manager\");\n+        }\n+    }\n+\n+    \/**\n+     * Adds a new {@code Taglet}.\n+     *\n+     * Prints a message to indicate whether or not the Taglet was registered properly.\n+     *\n+     * @param classname  the name of the class representing the custom tag\n+     * @param fileManager the file manager to load classes and resources\n+     *\/\n+    public void addCustomTag(String classname, JavaFileManager fileManager) {\n+        ClassLoader tagClassLoader = fileManager.getClassLoader(TAGLET_PATH);\n+        if (config.workArounds.accessInternalAPI()) {\n+            Module thisModule = getClass().getModule();\n+            Module tagletLoaderUnnamedModule = tagClassLoader.getUnnamedModule();\n+            List<String> pkgs = List.of(\n+                    \"jdk.javadoc.doclet\",\n+                    \"jdk.javadoc.internal.doclets.toolkit\",\n+                    \"jdk.javadoc.internal.doclets.formats.html\");\n+            pkgs.forEach(p -> thisModule.addOpens(p, tagletLoaderUnnamedModule));\n+        }\n+        try {\n+            Class<? extends jdk.javadoc.doclet.Taglet> customTagClass =\n+                    tagClassLoader.loadClass(classname).asSubclass(jdk.javadoc.doclet.Taglet.class);\n+            jdk.javadoc.doclet.Taglet instance = customTagClass.getConstructor().newInstance();\n+            registerTaglet(instance);\n+        } catch (ReflectiveOperationException | ExceptionInInitializerError | ClassCastException exc) {\n+            messages.error(\"doclet.Error_taglet_not_registered\", exc.getClass().getName(),\n+                    classname);\n+        }\n+    }\n+\n+    \/**\n+     * Loads taglets from a taglet path using the service loader.\n+     *\n+     * @param fileManager the file manager to load the taglets\n+     * @throws IOException if an error occurs while getting the service loader\n+     *\/\n+    public void loadTaglets(JavaFileManager fileManager) throws IOException {\n+        Iterable<? extends File> location = ((StandardJavaFileManager) fileManager).getLocation(TAGLET_PATH);\n+        if (location != null && location.iterator().hasNext()) {\n+            ServiceLoader<jdk.javadoc.doclet.Taglet> serviceLoader =\n+                    fileManager.getServiceLoader(TAGLET_PATH, jdk.javadoc.doclet.Taglet.class);\n+            for (jdk.javadoc.doclet.Taglet taglet : serviceLoader) {\n+                registerTaglet(taglet);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Registers the {@code Taglet}.\n+     *\n+     * Prints a message if the {@code Taglet} got registered properly.\n+     *\n+     * @param instance the {@code Taglet} instance\n+     *\/\n+    private void registerTaglet(jdk.javadoc.doclet.Taglet instance) {\n+        instance.init(docEnv, doclet);\n+        Taglet newLegacy = new UserTaglet(instance);\n+        allTaglets.put(newLegacy.getName(), newLegacy);\n+        messages.notice(\"doclet.Notice_taglet_registered\", instance.getClass().getName());\n+    }\n+\n+    \/**\n+     * Adds a new {@code SimpleTaglet}.\n+     *\n+     * If this tag already exists and the header passed as an argument is {@code null},\n+     * move tag to the back of the list. If this tag already exists and the\n+     * header passed as an argument is not {@code null}, overwrite previous tag\n+     * with the new one. Otherwise, add a new SimpleTaglet to the list.\n+     *\n+     * @param tagName the name of this tag\n+     * @param header the header to output\n+     * @param locations the possible locations that this tag can appear in\n+     *\/\n+    public void addNewSimpleCustomTag(String tagName, String header, String locations) {\n+        if (tagName == null || locations == null) {\n+            return;\n+        }\n+        \/\/ remove + put in both branches below move the tag to the back of the map's ordering\n+        Taglet tag = allTaglets.remove(tagName);\n+        if (tag == null || header != null) {\n+            allTaglets.put(tagName, new SimpleTaglet(config, tagName, header, locations));\n+            if (Utils.toLowerCase(locations).indexOf('x') == -1) {\n+                checkTagName(tagName);\n+            }\n+        } else {\n+            \/\/ Move existing tag to the back\n+            allTaglets.put(tagName, tag);\n+        }\n+    }\n+\n+    \/**\n+     * Given a tag name, add it to the set of tags it belongs to.\n+     *\/\n+    private void checkTagName(String name) {\n+        if (standardTags.contains(name)) {\n+            overriddenStandardTags.add(name);\n+        } else {\n+            if (name.indexOf('.') == -1) {\n+                potentiallyConflictingTags.add(name);\n+            }\n+            unseenCustomTags.add(name);\n+        }\n+    }\n+\n+    \/**\n+     * Reports that a tag was seen in a doc comment.\n+     * It is removed from the list of custom tags that have not yet been seen.\n+     *\n+     * @param name the name of the tag\n+     *\/\n+    void seenTag(String name) {\n+        unseenCustomTags.remove(name);\n+    }\n+\n+    \/**\n+     * Given a series of {@code DocTree}s, check for misuse and spelling mistakes.\n+     *\n+     * @param element the tags holder\n+     * @param trees the trees containing the comments\n+     *\/\n+    public void checkTags(Element element, Iterable<? extends DocTree> trees) {\n+        CommentHelper ch = utils.getCommentHelper(element);\n+        for (DocTree tag : trees) {\n+            String name = tag.getKind().tagName;\n+            if (name == null) {\n+                continue;\n+            }\n+            if (!name.isEmpty() && name.charAt(0) == '@') {\n+                name = name.substring(1);\n+            }\n+            if (! (standardTags.contains(name) || allTaglets.containsKey(name))) {\n+                if (standardTagsLowercase.contains(Utils.toLowerCase(name))) {\n+                    messages.warning(ch.getDocTreePath(tag), \"doclet.UnknownTagLowercase\", ch.getTagName(tag));\n+                    continue;\n+                } else {\n+                    messages.warning(ch.getDocTreePath(tag), \"doclet.UnknownTag\", ch.getTagName(tag));\n+                    continue;\n+                }\n+            }\n+            final Taglet taglet = allTaglets.get(name);\n+            \/\/ Check and verify tag usage\n+            if (taglet != null) {\n+                if (taglet instanceof SimpleTaglet st && !st.isEnabled()) {\n+                    \/\/ taglet has been disabled\n+                    return;\n+                }\n+\n+                new SimpleElementVisitor14<Void, Void>() {\n+                    @Override\n+                    public Void visitModule(ModuleElement e, Void p) {\n+                        if (!taglet.inModule()) {\n+                            printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, \"module\");\n+                        }\n+                        return null;\n+                    }\n+\n+                    @Override\n+                    public Void visitPackage(PackageElement e, Void p) {\n+                        if (!taglet.inPackage()) {\n+                            printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, \"package\");\n+                        }\n+                        return null;\n+                    }\n+\n+                    @Override\n+                    public Void visitType(TypeElement e, Void p) {\n+                        if (!taglet.inType()) {\n+                            printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, \"class\");\n+                        }\n+                        return null;\n+                    }\n+\n+                    @Override\n+                    public Void visitExecutable(ExecutableElement e, Void p) {\n+                        if (utils.isConstructor(e) && !taglet.inConstructor()) {\n+                            printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, \"constructor\");\n+                        } else if (!taglet.inMethod()) {\n+                            printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, \"method\");\n+                        }\n+                        return null;\n+                    }\n+\n+                    @Override\n+                    public Void visitVariable(VariableElement e, Void p) {\n+                        if (utils.isField(e) && !taglet.inField()) {\n+                            printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, \"field\");\n+                        }\n+                        return null;\n+                    }\n+\n+                    @Override\n+                    public Void visitUnknown(Element e, Void p) {\n+                        if (utils.isOverviewElement(e) && !taglet.inOverview()) {\n+                            printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, \"overview\");\n+                        }\n+                        return null;\n+                    }\n+\n+                    @Override\n+                    protected Void defaultAction(Element e, Void p) {\n+                        return null;\n+                    }\n+                }.visit(element);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Given the taglet, the tag and the type of documentation that the tag\n+     * was found in, print a tag misuse warning.\n+     *\n+     * @param taglet the taglet representing the misused tag\n+     * @param tag the misused tag\n+     * @param holderType the type of documentation that the misused tag was found in\n+     *\/\n+    private void printTagMisuseWarn(CommentHelper ch, Taglet taglet, DocTree tag, String holderType) {\n+        Set<String> locationsSet = new LinkedHashSet<>();\n+        \/\/ The following names should be localized\n+        if (taglet.inOverview()) {\n+            locationsSet.add(\"overview\");\n+        }\n+        if (taglet.inModule()) {\n+            locationsSet.add(\"module\");\n+        }\n+        if (taglet.inPackage()) {\n+            locationsSet.add(\"package\");\n+        }\n+        if (taglet.inType()) {\n+            locationsSet.add(\"class\/interface\");\n+        }\n+        if (taglet.inConstructor())  {\n+            locationsSet.add(\"constructor\");\n+        }\n+        if (taglet.inField()) {\n+            locationsSet.add(\"field\");\n+        }\n+        if (taglet.inMethod()) {\n+            locationsSet.add(\"method\");\n+        }\n+        if (locationsSet.isEmpty()) {\n+            \/\/This known tag is excluded.\n+            return;\n+        }\n+        var combined_locations = String.join(\", \", locationsSet);\n+        messages.warning(ch.getDocTreePath(tag), \"doclet.tag_misuse\",\n+            \"@\" + taglet.getName(), holderType, combined_locations);\n+    }\n+\n+    \/**\n+     * Returns the taglets that can appear inline, in descriptive text.\n+     * @return the taglets that can appear inline\n+     *\/\n+    Map<String, Taglet> getInlineTaglets() {\n+        if (inlineTags == null) {\n+            initTaglets();\n+        }\n+        return inlineTags;\n+    }\n+\n+    \/**\n+     * Returns the taglets that can appear in the serialized form.\n+     * @return the taglet that can appear in the serialized form\n+     *\/\n+    public List<Taglet> getSerializedFormTaglets() {\n+        if (serializedFormTags == null) {\n+            initTaglets();\n+        }\n+        return serializedFormTags;\n+    }\n+\n+    \/**\n+     * Returns the custom tags for a given element.\n+     *\n+     * @param e the element to get custom tags for\n+     * @return the array of {@code Taglet}s that can\n+     * appear in the given element\n+     *\/\n+    @SuppressWarnings(\"fallthrough\")\n+    public List<Taglet> getBlockTaglets(Element e) {\n+        if (blockTagletsByLocation == null) {\n+            initTaglets();\n+        }\n+\n+        switch (e.getKind()) {\n+            case CONSTRUCTOR:\n+                return blockTagletsByLocation.get(Location.CONSTRUCTOR);\n+            case METHOD:\n+                return blockTagletsByLocation.get(Location.METHOD);\n+            case ENUM_CONSTANT:\n+            case FIELD:\n+                return blockTagletsByLocation.get(Location.FIELD);\n+            case ANNOTATION_TYPE:\n+            case INTERFACE:\n+            case CLASS:\n+            case ENUM:\n+            case RECORD:\n+                return blockTagletsByLocation.get(Location.TYPE);\n+            case MODULE:\n+                return blockTagletsByLocation.get(Location.MODULE);\n+            case PACKAGE:\n+                return blockTagletsByLocation.get(Location.PACKAGE);\n+            case OTHER:\n+                if (e instanceof DocletElement de) {\n+                    switch (de.getSubKind()) {\n+                        case DOCFILE:\n+                            return blockTagletsByLocation.get(Location.PACKAGE);\n+                        case OVERVIEW:\n+                            return blockTagletsByLocation.get(Location.OVERVIEW);\n+                        default:\n+                            \/\/ fall through\n+                    }\n+                }\n+                \/\/ fall through\n+            default:\n+                throw new AssertionError(\"unknown element: \" + e + \" ,kind: \" + e.getKind());\n+        }\n+    }\n+\n+    \/**\n+     * Initialize the tag collections.\n+     *\/\n+    private void initTaglets() {\n+\n+        blockTagletsByLocation = new EnumMap<>(Location.class);\n+        for (Location site : Location.values()) {\n+            blockTagletsByLocation.put(site, new ArrayList<>());\n+        }\n+\n+        inlineTags = new LinkedHashMap<>();\n+\n+        allTaglets.forEach((name, t) -> {\n+            if (t.isInlineTag()) {\n+                inlineTags.put(t.getName(), t);\n+            }\n+\n+            if (t.isBlockTag() && t.getName().equals(name)) {\n+                t.getAllowedLocations().forEach(l -> blockTagletsByLocation.get(l).add(t));\n+            }\n+        });\n+\n+        \/\/ init the serialized form tags for the serialized form page\n+        serializedFormTags = new ArrayList<>();\n+        serializedFormTags.add(allTaglets.get(SERIAL_DATA.tagName));\n+        serializedFormTags.add(allTaglets.get(PARAM.tagName));\n+        serializedFormTags.add(allTaglets.get(THROWS.tagName));\n+        if (!nosince)\n+            serializedFormTags.add(allTaglets.get(SINCE.tagName));\n+        serializedFormTags.add(allTaglets.get(SEE.tagName));\n+\n+        if (showTaglets) {\n+            showTaglets(System.out);\n+        }\n+    }\n+\n+    \/**\n+     * Initialize standard Javadoc tags for ordering purposes.\n+     *\/\n+    private void initStandardTaglets() {\n+        if (javafx) {\n+            initJavaFXTaglets();\n+        }\n+\n+        addStandardTaglet(new ParamTaglet(config));\n+        addStandardTaglet(new ReturnTaglet(config));\n+        addStandardTaglet(new ThrowsTaglet(config), EXCEPTION);\n+        addStandardTaglet(\n+                new SimpleTaglet(config, SINCE, resources.getText(\"doclet.Since\"),\n+                    EnumSet.allOf(Location.class), !nosince));\n+        addStandardTaglet(\n+                new SimpleTaglet(config, VERSION, resources.getText(\"doclet.Version\"),\n+                    EnumSet.of(Location.OVERVIEW, Location.MODULE, Location.PACKAGE, Location.TYPE), showversion));\n+        addStandardTaglet(\n+                new SimpleTaglet(config, AUTHOR, resources.getText(\"doclet.Author\"),\n+                    EnumSet.of(Location.OVERVIEW, Location.MODULE, Location.PACKAGE, Location.TYPE), showauthor));\n+        addStandardTaglet(\n+                new SimpleTaglet(config, SERIAL_DATA, resources.getText(\"doclet.SerialData\"),\n+                    EnumSet.noneOf(Location.class)));\n+        addStandardTaglet(\n+                new SimpleTaglet(config, HIDDEN, null,\n+                    EnumSet.of(Location.TYPE, Location.METHOD, Location.FIELD)));\n+\n+        \/\/ This appears to be a default custom (non-standard) taglet\n+        Taglet factoryTaglet = new SimpleTaglet(config, \"factory\", resources.getText(\"doclet.Factory\"),\n+                EnumSet.of(Location.METHOD));\n+        allTaglets.put(factoryTaglet.getName(), factoryTaglet);\n+\n+        addStandardTaglet(new SeeTaglet(config));\n+        addStandardTaglet(new SpecTaglet(config));\n+\n+        \/\/ Standard inline tags\n+        addStandardTaglet(new DocRootTaglet(config));\n+        addStandardTaglet(new InheritDocTaglet(config));\n+        addStandardTaglet(new ValueTaglet(config));\n+        addStandardTaglet(new LinkTaglet(config, DocTree.Kind.LINK));\n+        addStandardTaglet(new LinkTaglet(config, DocTree.Kind.LINK_PLAIN));\n+        addStandardTaglet(new LiteralTaglet(config, DocTree.Kind.CODE));\n+        addStandardTaglet(new LiteralTaglet(config, DocTree.Kind.LITERAL));\n+        addStandardTaglet(new SnippetTaglet(config));\n+        addStandardTaglet(new IndexTaglet(config));\n+        addStandardTaglet(new SummaryTaglet(config));\n+        addStandardTaglet(new SystemPropertyTaglet(config));\n+\n+        \/\/ Keep track of the names of standard tags for error checking purposes.\n+        \/\/ The following are not handled above.\n+        addStandardTaglet(new DeprecatedTaglet(config));\n+        addStandardTaglet(new BaseTaglet(config, USES, false, EnumSet.of(jdk.javadoc.doclet.Taglet.Location.MODULE)));\n+        addStandardTaglet(new BaseTaglet(config, PROVIDES, false, EnumSet.of(jdk.javadoc.doclet.Taglet.Location.MODULE)));\n+        addStandardTaglet(\n+                new SimpleTaglet(config, SERIAL, null,\n+                        EnumSet.of(jdk.javadoc.doclet.Taglet.Location.PACKAGE, jdk.javadoc.doclet.Taglet.Location.TYPE, jdk.javadoc.doclet.Taglet.Location.FIELD)));\n+        addStandardTaglet(\n+                new SimpleTaglet(config, SERIAL_FIELD, null, EnumSet.of(jdk.javadoc.doclet.Taglet.Location.FIELD)));\n+    }\n+\n+    \/**\n+     * Initialize JavaFX-related tags.\n+     *\/\n+    private void initJavaFXTaglets() {\n+        addStandardTaglet(new SimpleTaglet(config, \"propertyDescription\",\n+                resources.getText(\"doclet.PropertyDescription\"),\n+                EnumSet.of(jdk.javadoc.doclet.Taglet.Location.METHOD, jdk.javadoc.doclet.Taglet.Location.FIELD)));\n+        addStandardTaglet(new SimpleTaglet(config, \"defaultValue\", resources.getText(\"doclet.DefaultValue\"),\n+                EnumSet.of(jdk.javadoc.doclet.Taglet.Location.METHOD, jdk.javadoc.doclet.Taglet.Location.FIELD)));\n+        addStandardTaglet(new SimpleTaglet(config, \"treatAsPrivate\", null,\n+                EnumSet.of(jdk.javadoc.doclet.Taglet.Location.TYPE, jdk.javadoc.doclet.Taglet.Location.METHOD, jdk.javadoc.doclet.Taglet.Location.FIELD)));\n+    }\n+\n+    private void addStandardTaglet(Taglet taglet) {\n+        String name = taglet.getName();\n+        allTaglets.put(name, taglet);\n+        standardTags.add(name);\n+        standardTagsLowercase.add(Utils.toLowerCase(name));\n+    }\n+\n+    private void addStandardTaglet(Taglet taglet, DocTree.Kind alias) {\n+        addStandardTaglet(taglet);\n+        String name = alias.tagName;\n+        allTaglets.put(name, taglet);\n+        standardTags.add(name);\n+        standardTagsLowercase.add(Utils.toLowerCase(name));\n+    }\n+\n+    public boolean isKnownCustomTag(String tagName) {\n+        return allTaglets.containsKey(tagName);\n+    }\n+\n+    \/**\n+     * Print a list of {@link Taglet}s that might conflict with\n+     * standard tags in the future and a list of standard tags\n+     * that have been overridden.\n+     *\/\n+    public void printReport() {\n+        printReportHelper(\"doclet.Notice_taglet_conflict_warn\", potentiallyConflictingTags);\n+        printReportHelper(\"doclet.Notice_taglet_overridden\", overriddenStandardTags);\n+        printReportHelper(\"doclet.Notice_taglet_unseen\", unseenCustomTags);\n+    }\n+\n+    private void printReportHelper(String noticeKey, Set<String> names) {\n+        if (!names.isEmpty()) {\n+            StringBuilder result = new StringBuilder();\n+            for (String name : names) {\n+                result.append(result.length() == 0 ? \" \" : \", \");\n+                result.append(\"@\").append(name);\n+            }\n+            messages.notice(noticeKey, result);\n+        }\n+    }\n+\n+    \/**\n+     * Given the name of a tag, return the corresponding taglet.\n+     *\n+     * @param name the name of the taglet to retrieve\n+     * @return the corresponding taglet or {@code null} if the tag is unknown\n+     *\/\n+    Taglet getTaglet(String name) {\n+        if (name.indexOf(\"@\") == 0) {\n+            return allTaglets.get(name.substring(1));\n+        } else {\n+            return allTaglets.get(name);\n+        }\n+    }\n+\n+    public Taglet getTaglet(DocTree.Kind kind) {\n+        return switch (kind) {\n+            case DEPRECATED, LINK, LINK_PLAIN, PARAM, RETURN, THROWS -> getTaglet(kind.tagName);\n+            default ->\n+                throw new IllegalArgumentException(kind.toString());\n+        };\n+    }\n+\n+    \/*\n+     * The output of this method is the basis for a table at the end of the\n+     * doc comment specification, so any changes in the output may indicate\n+     * a need for a corresponding update to the spec.\n+     *\/\n+    private void showTaglets(PrintStream out) {\n+        Map<String, Taglet> taglets = new TreeMap<>(allTaglets);\n+\n+        taglets.forEach((n, t) -> {\n+            \/\/ give preference to simpler block form if a tag can be either\n+            String name = t.isBlockTag() ? \"@\" + n : \"{@\" + n + \"}\";\n+            out.println(String.format(\"%20s\", name) + \": \"\n+                    + format(t.isBlockTag(), \"block\")+ \" \"\n+                    + format(t.inOverview(), \"overview\") + \" \"\n+                    + format(t.inModule(), \"module\") + \" \"\n+                    + format(t.inPackage(), \"package\") + \" \"\n+                    + format(t.inType(), \"type\") + \" \"\n+                    + format(t.inConstructor(),\"constructor\") + \" \"\n+                    + format(t.inMethod(), \"method\") + \" \"\n+                    + format(t.inField(), \"field\") + \" \"\n+                    + format(t.isInlineTag(), \"inline\")+ \" \"\n+                    + format((t instanceof SimpleTaglet st) && !st.isEnabled(), \"disabled\"));\n+        });\n+    }\n+\n+    private String format(boolean b, String s) {\n+        return b ? s : \".\".repeat(s.length()); \/\/ \"replace\" all with \".\"\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/TagletManager.java","additions":749,"deletions":0,"binary":false,"changes":749,"status":"added"},{"patch":"@@ -0,0 +1,474 @@\n+\/*\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html.taglets;\n+\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.ModuleElement;\n+import javax.lang.model.element.PackageElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.util.SimpleElementVisitor14;\n+\n+import com.sun.source.doctree.DocTree;\n+\n+import com.sun.source.doctree.InlineTagTree;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlDocletWriter;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlIds;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlOptions;\n+import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlId;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n+import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n+import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.formats.html.taglets.Taglet.UnsupportedTagletOperationException;\n+import jdk.javadoc.internal.doclets.toolkit.DocletElement;\n+import jdk.javadoc.internal.doclets.toolkit.Resources;\n+import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;\n+import jdk.javadoc.internal.doclets.toolkit.util.DocLink;\n+import jdk.javadoc.internal.doclets.toolkit.util.IndexItem;\n+import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n+\n+\/**\n+ * Context and utility methods for taglet classes.\n+ *\/\n+public class TagletWriter {\n+\n+    \/**\n+     * A class that provides the information about the enclosing context for\n+     * a series of {@code DocTree} nodes.\n+     * This context may be used to determine the content that should be generated from the tree nodes.\n+     *\/\n+    public static class Context {\n+        \/**\n+         * Whether the trees are appearing in a context of just the first sentence,\n+         * such as in the summary table of the enclosing element.\n+         *\/\n+        public final boolean isFirstSentence;\n+        \/**\n+         * Whether the trees are appearing in the \"summary\" section of the\n+         * page for a declaration.\n+         *\/\n+        public final boolean inSummary;\n+        \/**\n+         * The set of enclosing kinds of tags.\n+         *\/\n+        public final Set<DocTree.Kind> inTags;\n+\n+        \/**\n+         * Creates an outermost context, with no enclosing tags.\n+         *\n+         * @param isFirstSentence {@code true} if the trees are appearing in a context of just the\n+         *                        first sentence and {@code false} otherwise\n+         * @param inSummary       {@code true} if the trees are appearing in the \"summary\" section\n+         *                        of the page for a declaration and {@code false} otherwise\n+         *\/\n+        public Context(boolean isFirstSentence, boolean inSummary) {\n+            this(isFirstSentence, inSummary, EnumSet.noneOf(DocTree.Kind.class));\n+        }\n+\n+        private Context(boolean isFirstSentence, boolean inSummary, Set<DocTree.Kind> inTags) {\n+            this.isFirstSentence = isFirstSentence;\n+            this.inSummary = inSummary;\n+            this.inTags = inTags;\n+        }\n+\n+        \/**\n+         * Creates a new {@code Context} that includes an extra tag kind in the set of enclosing\n+         * kinds of tags.\n+         *\n+         * @param tree the enclosing tree\n+         *\n+         * @return the new {@code Context}\n+         *\/\n+        public Context within(DocTree tree) {\n+            var newInTags = EnumSet.copyOf(inTags);\n+            newInTags.add(tree.getKind());\n+            return new Context(isFirstSentence, inSummary, newInTags);\n+        }\n+    }\n+\n+    public final HtmlDocletWriter htmlWriter;\n+    public final HtmlConfiguration configuration;\n+    public final HtmlOptions options;\n+    public final Utils utils;\n+    public final Resources resources;\n+\n+    \/**\n+     * The context in which to generate the output for a series of {@code DocTree} nodes.\n+     *\/\n+    public final Context context;\n+    \/**\n+     * Creates a taglet writer.\n+     *\n+     * @param htmlWriter      the {@code HtmlDocletWriter} for the page\n+     * @param isFirstSentence {@code true} if this taglet writer is being used for a\n+     *                        \"first sentence\" summary\n+     *\/\n+    public TagletWriter(HtmlDocletWriter htmlWriter, boolean isFirstSentence) {\n+        this(htmlWriter, isFirstSentence, false);\n+    }\n+\n+    \/**\n+     * Creates a taglet writer.\n+     *\n+     * @param htmlWriter      the {@code HtmlDocletWriter} for the page\n+     * @param isFirstSentence {@code true} if this taglet writer is being used for a\n+     *                        \"first sentence\" summary, and {@code false} otherwise\n+     * @param inSummary       {@code true} if this taglet writer is being used for the content\n+     *                        of a {@code {@summary ...}} tag, and {@code false} otherwise\n+     *\/\n+    public TagletWriter(HtmlDocletWriter htmlWriter, boolean isFirstSentence, boolean inSummary) {\n+        this(htmlWriter, new Context(isFirstSentence, inSummary));\n+    }\n+\n+    \/**\n+     * Creates a taglet writer.\n+     *\n+     * @param htmlWriter the {@code HtmlDocletWriter} for the page\n+     * @param context    the enclosing context for any tags\n+     *\/\n+    public TagletWriter(HtmlDocletWriter htmlWriter, Context context) {\n+        this.htmlWriter = Objects.requireNonNull(htmlWriter);\n+        this.context = Objects.requireNonNull(context);\n+        configuration = htmlWriter.configuration;\n+        options = configuration.getOptions();\n+        utils = configuration.utils;\n+        resources = configuration.getDocResources();\n+    }\n+\n+    public Context getContext() {\n+        return context;\n+    }\n+\n+    \/**\n+     * Returns an instance of an output object.\n+     *\n+     * @return an instance of an output object\n+     *\/\n+    public Content getOutputInstance() {\n+        return new ContentBuilder();\n+    }\n+\n+    \/**\n+     * Returns the output for an invalid tag. The returned content uses special styling to\n+     * highlight the problem. Depending on the presence of the {@code detail} string the method\n+     * returns a plain text span or an expandable component.\n+     *\n+     * @param summary the single-line summary message\n+     * @param detail the optional detail message which may contain preformatted text\n+     * @return the output\n+     *\/\n+    public Content invalidTagOutput(String summary, Optional<String> detail) {\n+        return htmlWriter.invalidTagOutput(summary,\n+                detail.isEmpty() || detail.get().isEmpty()\n+                        ? Optional.empty()\n+                        : Optional.of(Text.of(Text.normalizeNewlines(detail.get()))));\n+    }\n+\n+    \/**\n+     * Returns the main type element of the current page or null for pages that don't have one.\n+     *\n+     * @return the type element of the current page or null.\n+     *\/\n+    public TypeElement getCurrentPageElement() {\n+        return htmlWriter.getCurrentPageElement();\n+    }\n+\n+    \/**\n+     * Returns the content generated from the block tags for a given element.\n+     * The content is generated according to the order of the list of taglets.\n+     * The result is a possibly-empty list of the output generated by each\n+     * of the given taglets for all of the tags they individually support.\n+     *\n+     * @param tagletManager the manager that manages the taglets\n+     * @param element       the element that we are to write tags for\n+     * @param taglets       the taglets for the tags to write\n+     *\n+     * @return the content\n+     *\/\n+    public Content getBlockTagOutput(TagletManager tagletManager,\n+                                    Element element,\n+                                    List<Taglet> taglets) {\n+        for (Taglet t : taglets) {\n+            if (!t.isBlockTag()) {\n+                throw new IllegalArgumentException(t.getName());\n+            }\n+        }\n+\n+        Content output = getOutputInstance();\n+        tagletManager.checkTags(element, utils.getBlockTags(element));\n+        tagletManager.checkTags(element, utils.getFullBody(element));\n+        for (Taglet taglet : taglets) {\n+            if (utils.isTypeElement(element) && taglet instanceof ParamTaglet) {\n+                \/\/ The type parameters and state components are documented in a special\n+                \/\/ section away from the tag info, so skip here.\n+                continue;\n+            }\n+\n+            if (element.getKind() == ElementKind.MODULE && taglet instanceof BaseTaglet t) {\n+                switch (t.getTagKind()) {\n+                    \/\/ @uses and @provides are handled separately, so skip here.\n+                    \/\/ See ModuleWriterImpl.computeModulesData\n+                    case USES:\n+                    case PROVIDES:\n+                        continue;\n+                }\n+            }\n+\n+            if (taglet instanceof DeprecatedTaglet) {\n+                \/\/Deprecated information is documented \"inline\", not in tag info\n+                \/\/section.\n+                continue;\n+            }\n+\n+            if (taglet instanceof SimpleTaglet st && !st.isEnabled()) {\n+                \/\/ taglet has been disabled\n+                continue;\n+            }\n+\n+            try {\n+                Content tagletOutput = taglet.getAllBlockTagOutput(element, this);\n+                if (tagletOutput != null) {\n+                    tagletManager.seenTag(taglet.getName());\n+                    output.add(tagletOutput);\n+                }\n+            } catch (UnsupportedTagletOperationException e) {\n+                \/\/ malformed taglet:\n+                \/\/ claims to support block tags (see Taglet.isBlockTag) but does not provide the\n+                \/\/ appropriate method, Taglet.getAllBlockTagOutput.\n+            }\n+        }\n+        return output;\n+    }\n+\n+    \/**\n+     * Returns the content generated from an inline tag in the doc comment for a given element,\n+     * or {@code null} if the tag is not supported or does not return any output.\n+     *\n+     * @param holder        the element associated with the doc comment\n+     * @param inlineTag     the inline tag to be documented\n+     *\n+     * @return the content, or {@code null}\n+     *\/\n+    public Content getInlineTagOutput(Element holder,\n+                                      InlineTagTree inlineTag) {\n+        var tagletManager = configuration.tagletManager;\n+        Map<String, Taglet> inlineTags = tagletManager.getInlineTaglets();\n+        CommentHelper ch = configuration.utils.getCommentHelper(holder);\n+        final String inlineTagName = ch.getTagName(inlineTag);\n+        Taglet t = inlineTags.get(inlineTagName);\n+        if (t == null) {\n+            return null;\n+        }\n+\n+        try {\n+            Content tagletOutput = t.getInlineTagOutput(holder, inlineTag, this);\n+            tagletManager.seenTag(t.getName());\n+            return tagletOutput;\n+        } catch (UnsupportedTagletOperationException e) {\n+            \/\/ malformed taglet:\n+            \/\/ claims to support inline tags (see Taglet.isInlineTag) but does not provide the\n+            \/\/ appropriate method, Taglet.getInlineTagOutput.\n+            return null;\n+        }\n+    }\n+\n+    \/**\n+     * Converts inline tags and text to content, expanding the\n+     * inline tags along the way.  Called wherever text can contain\n+     * an inline tag, such as in comments or in free-form text arguments\n+     * to block tags.\n+     *\n+     * @param holderTree the tree that holds the documentation\n+     * @param trees      list of {@code DocTree} nodes containing text and inline tags (often alternating)\n+     *                   present in the text of interest for this doc\n+     *\n+     * @return the generated content\n+     *\/\n+    public Content commentTagsToOutput(DocTree holderTree, List<? extends DocTree> trees) {\n+        return commentTagsToOutput(null, holderTree, trees, false);\n+    }\n+\n+    \/**\n+     * Converts inline tags and text to content, expanding the\n+     * inline tags along the way.  Called wherever text can contain\n+     * an inline tag, such as in comments or in free-form text arguments\n+     * to block tags.\n+     *\n+     * @param element The element that owns the documentation\n+     * @param trees  list of {@code DocTree} nodes containing text and inline tags (often alternating)\n+     *               present in the text of interest for this doc\n+     *\n+     * @return the generated content\n+     *\/\n+    public Content commentTagsToOutput(Element element, List<? extends DocTree> trees) {\n+        return commentTagsToOutput(element, null, trees, false);\n+    }\n+\n+    \/**\n+     * Converts inline tags and text to content, expanding the\n+     * inline tags along the way.  Called wherever text can contain\n+     * an inline tag, such as in comments or in free-form text arguments\n+     * to non-inline tags.\n+     *\n+     * @param element          the element where comment resides\n+     * @param holder       the tag that holds the documentation\n+     * @param trees           array of text tags and inline tags (often alternating)\n+     *                        present in the text of interest for this doc\n+     * @param isFirstSentence true if this is the first sentence\n+     *\n+     * @return the generated content\n+     *\/\n+    public Content commentTagsToOutput(Element element,\n+                                       DocTree holder,\n+                                       List<? extends DocTree> trees,\n+                                       boolean isFirstSentence)\n+    {\n+        return htmlWriter.commentTagsToContent(element,\n+                trees, holder == null ? context : context.within(holder));\n+    }\n+\n+    public Content createAnchorAndSearchIndex(Element element, String tagText, String desc, DocTree tree) {\n+        return createAnchorAndSearchIndex(element, tagText, Text.of(tagText), desc, tree);\n+    }\n+\n+    @SuppressWarnings(\"preview\")\n+    Content createAnchorAndSearchIndex(Element element, String tagText, Content tagContent, String desc, DocTree tree) {\n+        Content result;\n+        if (context.isFirstSentence && context.inSummary || context.inTags.contains(DocTree.Kind.INDEX)) {\n+            result = tagContent;\n+        } else {\n+            HtmlId id = HtmlIds.forText(tagText, htmlWriter.indexAnchorTable);\n+            result = HtmlTree.SPAN(id, HtmlStyle.searchTagResult, tagContent);\n+            if (options.createIndex() && !tagText.isEmpty()) {\n+                String holder = getHolderName(element);\n+                IndexItem item = IndexItem.of(element, tree, tagText, holder, desc,\n+                        new DocLink(htmlWriter.path, id.name()));\n+                configuration.mainIndex.add(item);\n+            }\n+        }\n+        return result;\n+    }\n+\n+    public String getHolderName(Element element) {\n+        return new SimpleElementVisitor14<String, Void>() {\n+\n+            @Override\n+            public String visitModule(ModuleElement e, Void p) {\n+                return resources.getText(\"doclet.module\")\n+                        + \" \" + utils.getFullyQualifiedName(e);\n+            }\n+\n+            @Override\n+            public String visitPackage(PackageElement e, Void p) {\n+                return resources.getText(\"doclet.package\")\n+                        + \" \" + utils.getFullyQualifiedName(e);\n+            }\n+\n+            @Override\n+            public String visitType(TypeElement e, Void p) {\n+                return utils.getTypeElementKindName(e, true)\n+                        + \" \" + utils.getFullyQualifiedName(e);\n+            }\n+\n+            @Override\n+            public String visitExecutable(ExecutableElement e, Void p) {\n+                return utils.getFullyQualifiedName(utils.getEnclosingTypeElement(e))\n+                        + \".\" + utils.getSimpleName(e)\n+                        + utils.flatSignature(e, htmlWriter.getCurrentPageElement());\n+            }\n+\n+            @Override\n+            public String visitVariable(VariableElement e, Void p) {\n+                return utils.getFullyQualifiedName(utils.getEnclosingTypeElement(e))\n+                        + \".\" + utils.getSimpleName(e);\n+            }\n+\n+            @Override\n+            public String visitUnknown(Element e, Void p) {\n+                if (e instanceof DocletElement de) {\n+                    return switch (de.getSubKind()) {\n+                        case OVERVIEW -> resources.getText(\"doclet.Overview\");\n+                        case DOCFILE -> getHolderName(de);\n+                    };\n+                } else {\n+                    return super.visitUnknown(e, p);\n+                }\n+            }\n+\n+            @Override\n+            protected String defaultAction(Element e, Void p) {\n+                return utils.getFullyQualifiedName(e);\n+            }\n+        }.visit(element);\n+    }\n+\n+    private String getHolderName(DocletElement de) {\n+        PackageElement pe = de.getPackageElement();\n+        if (pe.isUnnamed()) {\n+            \/\/ if package is unnamed use enclosing module only if it is named\n+            Element ee = pe.getEnclosingElement();\n+            if (ee instanceof ModuleElement && !((ModuleElement)ee).isUnnamed()) {\n+                return resources.getText(\"doclet.module\") + \" \" + utils.getFullyQualifiedName(ee);\n+            }\n+            return pe.toString(); \/\/ \"Unnamed package\" or similar\n+        }\n+        return resources.getText(\"doclet.package\") + \" \" + utils.getFullyQualifiedName(pe);\n+    }\n+\n+    Content tagList(List<Content> items) {\n+        \/\/ Use a different style if any list item is longer than 30 chars or contains commas.\n+        boolean hasLongLabels = items.stream().anyMatch(this::isLongOrHasComma);\n+        var list = HtmlTree.UL(hasLongLabels ? HtmlStyle.tagListLong : HtmlStyle.tagList);\n+        items.stream()\n+                .filter(Predicate.not(Content::isEmpty))\n+                .forEach(item -> list.add(HtmlTree.LI(item)));\n+        return list;\n+    }\n+\n+    \/\/ Threshold for length of list item for switching from inline to block layout.\n+    private static final int TAG_LIST_ITEM_MAX_INLINE_LENGTH = 30;\n+\n+    private boolean isLongOrHasComma(Content c) {\n+        String s = c.toString()\n+                .replaceAll(\"<.*?>\", \"\")              \/\/ ignore HTML\n+                .replaceAll(\"&#?[A-Za-z0-9]+;\", \" \")  \/\/ entities count as a single character\n+                .replaceAll(\"\\\\R\", \"\\n\");             \/\/ normalize newlines\n+        return s.length() > TAG_LIST_ITEM_MAX_INLINE_LENGTH || s.contains(\",\");\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/TagletWriter.java","additions":474,"deletions":0,"binary":false,"changes":474,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.javadoc.internal.doclets.toolkit.taglets;\n+package jdk.javadoc.internal.doclets.formats.html.taglets;\n@@ -56,2 +56,4 @@\n-import com.sun.source.util.DocTreePath;\n-import jdk.javadoc.doclet.Taglet.Location;\n+import jdk.javadoc.doclet.Taglet;\n+import jdk.javadoc.internal.doclets.formats.html.Contents;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlLinkInfo;\n@@ -59,1 +61,1 @@\n-import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n@@ -62,1 +64,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.util.DocFinder.Result;\n@@ -159,1 +160,4 @@\n-    public ThrowsTaglet(BaseConfiguration configuration) {\n+    private final HtmlConfiguration config;\n+    private final Contents contents;\n+\n+    ThrowsTaglet(HtmlConfiguration config) {\n@@ -162,3 +166,3 @@\n-        super(DocTree.Kind.THROWS, false, EnumSet.of(Location.CONSTRUCTOR, Location.METHOD));\n-        this.configuration = configuration;\n-        this.utils = this.configuration.utils;\n+        super(config, DocTree.Kind.THROWS, false, EnumSet.of(Taglet.Location.CONSTRUCTOR, Taglet.Location.METHOD));\n+        this.config = config;\n+        contents = config.contents;\n@@ -167,3 +171,0 @@\n-    private final BaseConfiguration configuration;\n-    private final Utils utils;\n-\n@@ -171,1 +172,1 @@\n-    public Output inherit(Element dst, Element src, DocTree tag, boolean isFirstSentence, BaseConfiguration configuration) {\n+    public Output inherit(Element dst, Element src, DocTree tag, boolean isFirstSentence) {\n@@ -180,1 +181,2 @@\n-    public Content getAllBlockTagOutput(Element holder, TagletWriter writer) {\n+    public Content getAllBlockTagOutput(Element holder, TagletWriter tagletWriter) {\n+        this.tagletWriter = tagletWriter;\n@@ -182,1 +184,1 @@\n-            return getAllBlockTagOutput0(holder, writer);\n+            return getAllBlockTagOutput0(holder);\n@@ -186,1 +188,0 @@\n-            var messages = configuration.getMessages();\n@@ -213,2 +214,2 @@\n-                    + utils.flatSignature((ExecutableElement) holder, writer.getCurrentPageElement());\n-            configuration.getMessages().warning(holder, \"doclet.noInheritedDoc\", signature);\n+                    + utils.flatSignature((ExecutableElement) holder, tagletWriter.getCurrentPageElement());\n+            messages.warning(holder, \"doclet.noInheritedDoc\", signature);\n@@ -216,1 +217,1 @@\n-        return writer.getOutputInstance(); \/\/ TODO: consider invalid rather than empty output\n+        return tagletWriter.getOutputInstance(); \/\/ TODO: consider invalid rather than empty output\n@@ -219,2 +220,1 @@\n-    private Content getAllBlockTagOutput0(Element holder,\n-                                          TagletWriter writer)\n+    private Content getAllBlockTagOutput0(Element holder)\n@@ -238,1 +238,1 @@\n-                writer.getCurrentPageElement(), executable);\n+                tagletWriter.getCurrentPageElement(), executable);\n@@ -245,1 +245,1 @@\n-        var exceptionSection = new ExceptionSectionBuilder(writer);\n+        var exceptionSection = new ExceptionSectionBuilder(tagletWriter, this);\n@@ -251,1 +251,1 @@\n-            outputAnExceptionTagDeeply(exceptionSection, exceptionElement, t, executable, alreadyDocumentedExceptions, typeSubstitutions, writer);\n+            outputAnExceptionTagDeeply(exceptionSection, exceptionElement, t, executable, alreadyDocumentedExceptions, typeSubstitutions);\n@@ -280,1 +280,1 @@\n-                    outputAnExceptionTagDeeply(exceptionSection, exceptionElement, e.getKey(), e.getValue(), alreadyDocumentedExceptions, typeSubstitutions, writer);\n+                    outputAnExceptionTagDeeply(exceptionSection, exceptionElement, e.getKey(), e.getValue(), alreadyDocumentedExceptions, typeSubstitutions);\n@@ -302,0 +302,29 @@\n+    \/**\n+     * Returns the header for the {@code @throws} tag.\n+     *\n+     * @return the header for the throws tag\n+     *\/\n+    private Content getThrowsHeader() {\n+        return HtmlTree.DT(contents.throws_);\n+    }\n+\n+    \/**\n+     * Returns the output for a default {@code @throws} tag.\n+     *\n+     * @param throwsType the type that is thrown\n+     * @param content    the optional content to add as a description\n+     *\n+     * @return the output\n+     *\/\n+    private Content throwsTagOutput(TypeMirror throwsType, Optional<Content> content) {\n+        var htmlWriter = tagletWriter.htmlWriter;\n+        var linkInfo = new HtmlLinkInfo(config, HtmlLinkInfo.Kind.PLAIN, throwsType);\n+        var link = htmlWriter.getLink(linkInfo);\n+        var concat = new ContentBuilder(HtmlTree.CODE(link));\n+        if (content.isPresent()) {\n+            concat.add(\" - \");\n+            concat.add(content.get());\n+        }\n+        return HtmlTree.DD(concat);\n+    }\n+\n@@ -307,2 +336,1 @@\n-                                            Map<TypeMirror, TypeMirror> typeSubstitutions,\n-                                            TagletWriter writer)\n+                                            Map<TypeMirror, TypeMirror> typeSubstitutions)\n@@ -317,1 +345,1 @@\n-        outputAnExceptionTagDeeply(exceptionSection, originalExceptionElement, tag, holder, true, alreadyDocumentedExceptions, typeSubstitutions, writer);\n+        outputAnExceptionTagDeeply(exceptionSection, originalExceptionElement, tag, holder, true, alreadyDocumentedExceptions, typeSubstitutions);\n@@ -326,2 +354,1 @@\n-                                            Map<TypeMirror, TypeMirror> typeSubstitutions,\n-                                            TagletWriter writer)\n+                                            Map<TypeMirror, TypeMirror> typeSubstitutions)\n@@ -358,1 +385,1 @@\n-            exceptionSection.continueEntry(writer.commentTagsToOutput(holder, description));\n+            exceptionSection.continueEntry(tagletWriter.commentTagsToOutput(holder, description));\n@@ -376,1 +403,1 @@\n-                Content beforeInheritDoc = writer.commentTagsToOutput(holder, description.subList(0, i));\n+                Content beforeInheritDoc = tagletWriter.commentTagsToOutput(holder, description.subList(0, i));\n@@ -389,1 +416,1 @@\n-                VisibleMemberTable visibleMemberTable = configuration.getVisibleMemberTable(supertype);\n+                VisibleMemberTable visibleMemberTable = config.getVisibleMemberTable(supertype);\n@@ -425,1 +452,1 @@\n-                outputAnExceptionTagDeeply(exceptionSection, originalExceptionElement, e.getKey(), e.getValue(), addNewEntryRecursively, alreadyDocumentedExceptions, typeSubstitutions, writer);\n+                outputAnExceptionTagDeeply(exceptionSection, originalExceptionElement, e.getKey(), e.getValue(), addNewEntryRecursively, alreadyDocumentedExceptions, typeSubstitutions);\n@@ -429,1 +456,1 @@\n-                Content afterInheritDoc = writer.commentTagsToOutput(holder, description.subList(i + 1, description.size()));\n+                Content afterInheritDoc = tagletWriter.commentTagsToOutput(holder, description.subList(i + 1, description.size()));\n@@ -607,1 +634,1 @@\n-        Result<Map<ThrowsTree, ExecutableElement>> result;\n+        DocFinder.Result<Map<ThrowsTree, ExecutableElement>> result;\n@@ -626,1 +653,1 @@\n-        if (result instanceof Result.Conclude<Map<ThrowsTree, ExecutableElement>> c) {\n+        if (result instanceof DocFinder.Result.Conclude<Map<ThrowsTree, ExecutableElement>> c) {\n@@ -632,3 +659,3 @@\n-    private static Result<Map<ThrowsTree, ExecutableElement>> toResult(Element target,\n-                                                                       ExecutableElement holder,\n-                                                                       List<ThrowsTree> tags) {\n+    private static DocFinder.Result<Map<ThrowsTree, ExecutableElement>> toResult(Element target,\n+                                                                                 ExecutableElement holder,\n+                                                                                 List<ThrowsTree> tags) {\n@@ -637,1 +664,1 @@\n-            return Result.CONCLUDE(toExceptionTags(holder, tags));\n+            return DocFinder.Result.CONCLUDE(toExceptionTags(holder, tags));\n@@ -639,1 +666,1 @@\n-        return Result.CONTINUE();\n+        return DocFinder.Result.CONTINUE();\n@@ -697,0 +724,1 @@\n+        private final ThrowsTaglet taglet;\n@@ -698,1 +726,1 @@\n-        private ContentBuilder current;\n+        private Content current;\n@@ -703,1 +731,1 @@\n-        ExceptionSectionBuilder(TagletWriter writer) {\n+        ExceptionSectionBuilder(TagletWriter writer, ThrowsTaglet taglet) {\n@@ -705,0 +733,1 @@\n+            this.taglet = taglet;\n@@ -713,1 +742,1 @@\n-            current = new ContentBuilder();\n+            current = writer.getOutputInstance();\n@@ -731,1 +760,1 @@\n-                result.add(writer.getThrowsHeader());\n+                result.add(taglet.getThrowsHeader());\n@@ -733,1 +762,2 @@\n-            result.add(writer.throwsTagOutput(exceptionType, current.isEmpty() ? Optional.empty() : Optional.of(current)));\n+            result.add(taglet.throwsTagOutput(exceptionType,\n+                    current.isEmpty() ? Optional.empty() : Optional.of(current)));\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/ThrowsTaglet.java","additions":77,"deletions":47,"binary":false,"changes":124,"previous_filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/ThrowsTaglet.java","status":"renamed"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html.taglets;\n+\n+import java.util.List;\n+import java.util.Set;\n+\n+import javax.lang.model.element.Element;\n+\n+import com.sun.source.doctree.DocTree;\n+\n+import jdk.javadoc.internal.doclets.formats.html.markup.RawHtml;\n+import jdk.javadoc.internal.doclets.toolkit.Content;\n+\n+\/**\n+ * A taglet wrapper, allows the public taglet {@link jdk.javadoc.doclet.Taglet}\n+ * wrapped into an internal {@code Taglet} representation.\n+ *\/\n+public final class UserTaglet implements Taglet {\n+\n+    private final jdk.javadoc.doclet.Taglet userTaglet;\n+\n+    UserTaglet(jdk.javadoc.doclet.Taglet t) {\n+        userTaglet = t;\n+    }\n+\n+    @Override\n+    public Set<jdk.javadoc.doclet.Taglet.Location> getAllowedLocations() {\n+        return userTaglet.getAllowedLocations();\n+    }\n+\n+    @Override\n+    public boolean isInlineTag() {\n+        return userTaglet.isInlineTag();\n+    }\n+\n+    @Override\n+    public boolean isBlockTag() {\n+        return userTaglet.isBlockTag();\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return userTaglet.getName();\n+    }\n+\n+    @Override\n+    public Content getInlineTagOutput(Element element, DocTree tag, TagletWriter tagletWriter) {\n+        Content output = tagletWriter.getOutputInstance();\n+        output.add(RawHtml.of(userTaglet.toString(List.of(tag), element)));\n+        return output;\n+    }\n+\n+    @Override\n+    public Content getAllBlockTagOutput(Element holder, TagletWriter tagletWriter) {\n+        Content output = tagletWriter.getOutputInstance();\n+        var utils = tagletWriter.utils;\n+        List<? extends DocTree> tags = utils.getBlockTags(holder, getName());\n+        if (!tags.isEmpty()) {\n+            String tagString = userTaglet.toString(tags, holder);\n+            if (tagString != null) {\n+                output.add(RawHtml.of(tagString));\n+            }\n+        }\n+        return output;\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/UserTaglet.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -0,0 +1,144 @@\n+\/*\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html.taglets;\n+\n+import java.util.EnumSet;\n+import java.util.IllegalFormatException;\n+import java.util.Optional;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.VariableElement;\n+\n+import com.sun.source.doctree.DocTree;\n+import com.sun.source.doctree.TextTree;\n+import com.sun.source.doctree.ValueTree;\n+\n+import jdk.javadoc.doclet.Taglet;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlLinkInfo;\n+import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n+import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n+import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;\n+\n+\/**\n+ * An inline taglet representing the value tag. This tag should only be used with\n+ * constant fields that have a value.  It is used to access the value of constant\n+ * fields.  This inline tag has an optional field name parameter.  If the name is\n+ * specified, the constant value is retrieved from the specified field.  A link\n+ * is also created to the specified field.  If a name is not specified, the value\n+ * is retrieved for the field that the inline tag appears on.  The name is specified\n+ * in the following format:  [fully qualified class name]#[constant field name].\n+ *\/\n+public class ValueTaglet extends BaseTaglet {\n+\n+    ValueTaglet(HtmlConfiguration config) {\n+        super(config, DocTree.Kind.VALUE, true, EnumSet.allOf(Taglet.Location.class));\n+    }\n+\n+    \/**\n+     * Returns the referenced field or a null if the value tag\n+     * is empty or the reference is invalid.\n+     *\n+     * @param holder the tag holder.\n+     * @param config the  configuration of the doclet.\n+     * @param tag the value tag.\n+     *\n+     * @return the referenced field or null.\n+     *\/\n+    private VariableElement getVariableElement(Element holder, BaseConfiguration config, DocTree tag) {\n+        CommentHelper ch = config.utils.getCommentHelper(holder);\n+        String signature = ch.getReferencedSignature(tag);\n+\n+        Element e = signature == null\n+                ? holder\n+                : ch.getReferencedMember(tag);\n+\n+        return (e != null && config.utils.isVariableElement(e))\n+                ? (VariableElement) e\n+                : null;\n+    }\n+\n+    @Override\n+    public Content getInlineTagOutput(Element holder, DocTree tag, TagletWriter tagletWriter) {\n+        this.tagletWriter = tagletWriter;\n+        VariableElement field = getVariableElement(holder, config, tag);\n+        if (field == null) {\n+            if (tag.toString().isEmpty()) {\n+                \/\/Invalid use of @value\n+                messages.warning(holder,\n+                        \"doclet.value_tag_invalid_use\");\n+            } else {\n+                \/\/Reference is unknown.\n+                messages.warning(holder,\n+                        \"doclet.value_tag_invalid_reference\", tag.toString());\n+            }\n+        } else if (field.getConstantValue() != null) {\n+            TextTree format = ((ValueTree) tag).getFormat();\n+            String text;\n+            if (format != null) {\n+                String f = format.getBody();\n+                if (f.startsWith(\"\\\"\")) {\n+                    f = f.substring(1, f.length() - 1);\n+                }\n+                try {\n+                    text = String.format(config.getLocale(), f, field.getConstantValue());\n+                } catch (IllegalFormatException e) {\n+                    messages.error(holder,\n+                            \"doclet.value_tag_invalid_format\", format);\n+                    return tagletWriter.invalidTagOutput(\n+                            messages.getResources().getText(\"doclet.value_tag_invalid_format\", format),\n+                            Optional.empty());\n+                }\n+            } else {\n+                text = utils.constantValueExpression(field);\n+            }\n+            return valueTagOutput(field, text, !field.equals(holder));\n+        } else {\n+            \/\/Referenced field is not a constant.\n+            messages.warning(holder,\n+                    \"doclet.value_tag_invalid_constant\", utils.getSimpleName(field));\n+        }\n+        return tagletWriter.getOutputInstance();\n+    }\n+\n+    \/**\n+     * Returns the output for a {@code {@value}} tag.\n+     *\n+     * @param field       the constant field that holds the value tag\n+     * @param constantVal the constant value to document\n+     * @param includeLink true if we should link the constant text to the\n+     *                    constant field itself\n+     *\n+     * @return the output\n+     *\/\n+    private Content valueTagOutput(VariableElement field, String constantVal, boolean includeLink) {\n+        var htmlWriter = tagletWriter.htmlWriter;\n+        return includeLink\n+                ? htmlWriter.getDocLink(HtmlLinkInfo.Kind.LINK_TYPE_PARAMS_AND_BOUNDS, field, constantVal)\n+                : Text.of(constantVal);\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/ValueTaglet.java","additions":144,"deletions":0,"binary":false,"changes":144,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * Classes used to build the output for documentation comment tags.\n+ *\n+ * Tags are either inline tags, meaning they can be used within a\n+ * sentence or phrase, or are block tags, meaning that they provide\n+ * additional details that follow the main description in a comment.\n+ * Taglets model that distinction.\n+ *\n+ * Inline tags are always processed individually, within the surrounding\n+ * context. In general, inline tags always generate some (non-empty) output,\n+ * even if the output is some form indicating an error. It is almost never\n+ * correct to not generate any output to place between the parts of the\n+ * comment that come before and after the tag in the underlying comment.\n+ *\n+ * Conversely, block tags of any given kind are always processed as a\n+ * group, even if they do not appear contiguously in the underlying comment.\n+ *\/\n+package jdk.javadoc.internal.doclets.formats.html.taglets;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/package-info.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.javadoc.internal.doclets.toolkit.taglets.snippet;\n+package jdk.javadoc.internal.doclets.formats.html.taglets.snippet;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/snippet\/Action.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/Action.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.javadoc.internal.doclets.toolkit.taglets.snippet;\n+package jdk.javadoc.internal.doclets.formats.html.taglets.snippet;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/snippet\/AddStyle.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/AddStyle.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.javadoc.internal.doclets.toolkit.taglets.snippet;\n+package jdk.javadoc.internal.doclets.formats.html.taglets.snippet;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/snippet\/Attribute.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/Attribute.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.javadoc.internal.doclets.toolkit.taglets.snippet;\n+package jdk.javadoc.internal.doclets.formats.html.taglets.snippet;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/snippet\/Attributes.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/Attributes.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.javadoc.internal.doclets.toolkit.taglets.snippet;\n+package jdk.javadoc.internal.doclets.formats.html.taglets.snippet;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/snippet\/Bookmark.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/Bookmark.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.javadoc.internal.doclets.toolkit.taglets.snippet;\n+package jdk.javadoc.internal.doclets.formats.html.taglets.snippet;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/snippet\/MarkupParser.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/MarkupParser.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.javadoc.internal.doclets.toolkit.taglets.snippet;\n+package jdk.javadoc.internal.doclets.formats.html.taglets.snippet;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/snippet\/ParseException.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/ParseException.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.javadoc.internal.doclets.toolkit.taglets.snippet;\n+package jdk.javadoc.internal.doclets.formats.html.taglets.snippet;\n@@ -41,0 +41,1 @@\n+import jdk.javadoc.internal.doclets.formats.html.taglets.SnippetTaglet;\n@@ -42,1 +43,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.taglets.SnippetTaglet;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/snippet\/Parser.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/Parser.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.javadoc.internal.doclets.toolkit.taglets.snippet;\n+package jdk.javadoc.internal.doclets.formats.html.taglets.snippet;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/snippet\/Replace.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/Replace.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.javadoc.internal.doclets.toolkit.taglets.snippet;\n+package jdk.javadoc.internal.doclets.formats.html.taglets.snippet;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/snippet\/Style.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/Style.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.javadoc.internal.doclets.toolkit.taglets.snippet;\n+package jdk.javadoc.internal.doclets.formats.html.taglets.snippet;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/snippet\/StyledText.java","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/snippet\/StyledText.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.util.Map;\n@@ -39,2 +38,0 @@\n-import jdk.javadoc.doclet.StandardDoclet;\n-import jdk.javadoc.internal.doclets.formats.html.HtmlDoclet;\n@@ -71,19 +68,0 @@\n-    \/**\n-     * The only doclet that may use this toolkit is {@value}\n-     *\/\n-    private static final String TOOLKIT_DOCLET_NAME =\n-        jdk.javadoc.internal.doclets.formats.html.HtmlDoclet.class.getName();\n-\n-    \/**\n-     * Verify that the only doclet that is using this toolkit is\n-     * #TOOLKIT_DOCLET_NAME.\n-     *\/\n-    private boolean isValidDoclet() {\n-        if (!getClass().getName().equals(TOOLKIT_DOCLET_NAME)) {\n-            messages.error(\"doclet.Toolkit_Usage_Violation\",\n-                TOOLKIT_DOCLET_NAME);\n-            return false;\n-        }\n-        return true;\n-    }\n-\n@@ -104,4 +82,0 @@\n-        if (!isValidDoclet()) {\n-            return false;\n-        }\n-\n@@ -110,1 +84,1 @@\n-                startGeneration();\n+                generateFiles();\n@@ -154,1 +128,1 @@\n-        if (getClass().equals(StandardDoclet.class) || getClass().equals(HtmlDoclet.class)) {\n+        if (getClass().getModule() == AbstractDoclet.class.getModule()) {\n@@ -191,1 +165,1 @@\n-    private void startGeneration() throws DocletException {\n+    protected void generateFiles() throws DocletException {\n@@ -214,1 +188,0 @@\n-        configuration.tagletManager.printReport();\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/AbstractDoclet.java","additions":4,"deletions":31,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,4 +29,0 @@\n-import java.io.File;\n-import java.io.IOException;\n-import java.nio.file.InvalidPathException;\n-import java.nio.file.Path;\n@@ -34,1 +30,0 @@\n-import java.util.Arrays;\n@@ -56,1 +51,0 @@\n-import javax.tools.DocumentationTool;\n@@ -59,1 +53,0 @@\n-import javax.tools.StandardJavaFileManager;\n@@ -71,1 +64,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.taglets.TagletManager;\n@@ -103,5 +95,0 @@\n-    \/**\n-     * The taglet manager.\n-     *\/\n-    public TagletManager tagletManager;\n-\n@@ -377,22 +364,0 @@\n-        String snippetPath = options.snippetPath();\n-        if (snippetPath != null) {\n-            Messages messages = getMessages();\n-            JavaFileManager fm = getFileManager();\n-            if (fm instanceof StandardJavaFileManager) {\n-                try {\n-                    List<Path> sp = Arrays.stream(snippetPath.split(File.pathSeparator))\n-                            .map(Path::of)\n-                            .toList();\n-                    StandardJavaFileManager sfm = (StandardJavaFileManager) fm;\n-                    sfm.setLocationFromPaths(DocumentationTool.Location.SNIPPET_PATH, sp);\n-                } catch (IOException | InvalidPathException e) {\n-                    throw new SimpleDocletException(messages.getResources().getText(\n-                            \"doclet.error_setting_snippet_path\", snippetPath, e), e);\n-                }\n-            } else {\n-                throw new SimpleDocletException(messages.getResources().getText(\n-                        \"doclet.cannot_use_snippet_path\", snippetPath));\n-            }\n-        }\n-\n-        initTagletManager(options.customTagStrs());\n@@ -454,94 +419,0 @@\n-    \/**\n-     * Initialize the taglet manager.  The strings to initialize the simple custom tags should\n-     * be in the following format:  \"[tag name]:[location str]:[heading]\".\n-     *\n-     * @param customTagStrs the set two dimensional arrays of strings.  These arrays contain\n-     *                      either -tag or -taglet arguments.\n-     *\/\n-    private void initTagletManager(Set<List<String>> customTagStrs) {\n-        tagletManager = tagletManager != null ? tagletManager : new TagletManager(this);\n-        JavaFileManager fileManager = getFileManager();\n-        Messages messages = getMessages();\n-        try {\n-            tagletManager.initTagletPath(fileManager);\n-            tagletManager.loadTaglets(fileManager);\n-\n-            for (List<String> args : customTagStrs) {\n-                if (args.get(0).equals(\"-taglet\")) {\n-                    tagletManager.addCustomTag(args.get(1), fileManager);\n-                    continue;\n-                }\n-                \/* Since there are few constraints on the characters in a tag name,\n-                 * and real world examples with ':' in the tag name, we cannot simply use\n-                 * String.split(regex);  instead, we tokenize the string, allowing\n-                 * special characters to be escaped with '\\'. *\/\n-                List<String> tokens = tokenize(args.get(1), 3);\n-                switch (tokens.size()) {\n-                    case 1 -> {\n-                        String tagName = args.get(1);\n-                        if (tagletManager.isKnownCustomTag(tagName)) {\n-                            \/\/reorder a standard tag\n-                            tagletManager.addNewSimpleCustomTag(tagName, null, \"\");\n-                        } else {\n-                            \/\/Create a simple tag with the heading that has the same name as the tag.\n-                            StringBuilder heading = new StringBuilder(tagName + \":\");\n-                            heading.setCharAt(0, Character.toUpperCase(tagName.charAt(0)));\n-                            tagletManager.addNewSimpleCustomTag(tagName, heading.toString(), \"a\");\n-                        }\n-                    }\n-\n-                    case 2 ->\n-                        \/\/Add simple taglet without heading, probably to excluding it in the output.\n-                        tagletManager.addNewSimpleCustomTag(tokens.get(0), tokens.get(1), \"\");\n-\n-                    case 3 ->\n-                        tagletManager.addNewSimpleCustomTag(tokens.get(0), tokens.get(2), tokens.get(1));\n-\n-                    default ->\n-                        messages.error(\"doclet.Error_invalid_custom_tag_argument\", args.get(1));\n-                }\n-            }\n-        } catch (IOException e) {\n-            messages.error(\"doclet.taglet_could_not_set_location\", e.toString());\n-        }\n-    }\n-\n-    \/**\n-     * Given a string, return an array of tokens, separated by ':'.\n-     * The separator character can be escaped with the '\\' character.\n-     * The '\\' character may also be escaped with the '\\' character.\n-     *\n-     * @param s         the string to tokenize\n-     * @param maxTokens the maximum number of tokens returned.  If the\n-     *                  max is reached, the remaining part of s is appended\n-     *                  to the end of the last token.\n-     * @return an array of tokens\n-     *\/\n-    private List<String> tokenize(String s, int maxTokens) {\n-        List<String> tokens = new ArrayList<>();\n-        StringBuilder token = new StringBuilder();\n-        boolean prevIsEscapeChar = false;\n-        for (int i = 0; i < s.length(); i += Character.charCount(i)) {\n-            int currentChar = s.codePointAt(i);\n-            if (prevIsEscapeChar) {\n-                \/\/ Case 1:  escaped character\n-                token.appendCodePoint(currentChar);\n-                prevIsEscapeChar = false;\n-            } else if (currentChar == ':' && tokens.size() < maxTokens - 1) {\n-                \/\/ Case 2:  separator\n-                tokens.add(token.toString());\n-                token = new StringBuilder();\n-            } else if (currentChar == '\\\\') {\n-                \/\/ Case 3:  escape character\n-                prevIsEscapeChar = true;\n-            } else {\n-                \/\/ Case 4:  regular character\n-                token.appendCodePoint(currentChar);\n-            }\n-        }\n-        if (token.length() > 0) {\n-            tokens.add(token.toString());\n-        }\n-        return tokens;\n-    }\n-\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/BaseConfiguration.java","additions":1,"deletions":130,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,3 +35,0 @@\n-import java.nio.file.Path;\n-import java.time.Instant;\n-import java.time.ZoneOffset;\n@@ -41,2 +38,0 @@\n-import java.time.temporal.ChronoUnit;\n-import java.time.temporal.TemporalUnit;\n@@ -45,1 +40,0 @@\n-import java.util.Calendar;\n@@ -47,1 +41,0 @@\n-import java.util.LinkedHashSet;\n@@ -52,1 +45,0 @@\n-import java.util.StringTokenizer;\n@@ -57,1 +49,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.util.DocletConstants;\n@@ -90,5 +81,0 @@\n-    \/**\n-     * Arguments for command-line option {@code -tag} and {@code -taglet}.\n-     *\/\n-    private final LinkedHashSet<List<String>> customTagStrs = new LinkedHashSet<>();\n-\n@@ -268,6 +254,0 @@\n-    \/**\n-     * Argument for command-line option {@code --show-taglets}.\n-     * Show taglets (internal debug switch)\n-     *\/\n-    private boolean showTaglets = false;\n-\n@@ -316,12 +296,0 @@\n-    \/**\n-     * Argument for command-line option {@code -tagletpath}.\n-     * The path to Taglets\n-     *\/\n-    private String tagletPath = null;\n-\n-    \/**\n-     * Argument for command-line option {@code --snippet-path}.\n-     * The path for external snippets.\n-     *\/\n-    private String snippetPath = null;\n-\n@@ -620,38 +588,0 @@\n-                new Option(resources, \"-tag\", 1) {\n-                    @Override\n-                    public boolean process(String opt, List<String> args) {\n-                        ArrayList<String> list = new ArrayList<>();\n-                        list.add(opt);\n-                        list.add(args.get(0));\n-                        customTagStrs.add(list);\n-                        return true;\n-                    }\n-                },\n-\n-                new Option(resources, \"-taglet\", 1) {\n-                    @Override\n-                    public boolean process(String opt, List<String> args) {\n-                        ArrayList<String> list = new ArrayList<>();\n-                        list.add(opt);\n-                        list.add(args.get(0));\n-                        customTagStrs.add(list);\n-                        return true;\n-                    }\n-                },\n-\n-                new Option(resources, \"-tagletpath\", 1) {\n-                    @Override\n-                    public boolean process(String opt, List<String> args) {\n-                        tagletPath = args.get(0);\n-                        return true;\n-                    }\n-                },\n-\n-                new Option(resources, \"--snippet-path\", 1) {\n-                    @Override\n-                    public boolean process(String opt, List<String> args) {\n-                        snippetPath = args.get(0);\n-                        return true;\n-                    }\n-                },\n-\n@@ -708,8 +638,0 @@\n-                },\n-\n-                new Hidden(resources, \"--show-taglets\") {\n-                    @Override\n-                    public boolean process(String opt, List<String> args) {\n-                        showTaglets = true;\n-                        return true;\n-                    }\n@@ -804,7 +726,0 @@\n-    \/**\n-     * Arguments for command-line option {@code -tag} and {@code -taglet}.\n-     *\/\n-    LinkedHashSet<List<String>> customTagStrs() {\n-        return customTagStrs;\n-    }\n-\n@@ -1026,1 +941,1 @@\n-     * Default is don't show author information.\n+     * Default is to not show author information.\n@@ -1032,8 +947,0 @@\n-    \/**\n-     * Argument for command-line option {@code --show-taglets}.\n-     * Show taglets (internal debug switch)\n-     *\/\n-    public boolean showTaglets() {\n-        return showTaglets;\n-    }\n-\n@@ -1092,16 +999,0 @@\n-    \/**\n-     * Argument for command-line option {@code -tagletpath}.\n-     * The path to Taglets\n-     *\/\n-    public String tagletPath() {\n-        return tagletPath;\n-    }\n-\n-    \/**\n-     * Argument for command-line option {@code --snippet-path}.\n-     * The path for external snippets.\n-     *\/\n-    public String snippetPath() {\n-        return snippetPath;\n-    }\n-\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/BaseOptions.java","additions":2,"deletions":111,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,6 @@\n+    \/**\n+     * Returns an instance of an output object.\n+     *\n+     * @return an instance of an output object\n+     *\/\n+    Content getOutputInstance();\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/ClassWriter.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,0 @@\n-import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n@@ -146,1 +145,1 @@\n-        Content c = new ContentBuilder();\n+        Content c = writer.getOutputInstance();\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/builders\/ClassBuilder.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-doclet.Toolkit_Usage_Violation=The Doclet Toolkit can only be used by {0}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/resources\/doclets.properties","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,154 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.taglets;\n-\n-import java.util.Set;\n-import javax.lang.model.element.Element;\n-\n-import com.sun.source.doctree.DocTree;\n-import com.sun.source.doctree.UnknownBlockTagTree;\n-import jdk.javadoc.doclet.Taglet.Location;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-\n-\/**\n- * A base class that implements the {@link Taglet} interface.\n- *\/\n-public class BaseTaglet implements Taglet {\n-\n-    protected final DocTree.Kind tagKind;\n-    protected final String name;\n-    private final boolean inline;\n-    private final Set<Location> sites;\n-\n-    BaseTaglet(DocTree.Kind tagKind, boolean inline, Set<Location> sites) {\n-        this(tagKind.tagName, tagKind, inline, sites);\n-    }\n-\n-    BaseTaglet(String name, boolean inline, Set<Location> sites) {\n-        this(name, inline ? DocTree.Kind.UNKNOWN_INLINE_TAG : DocTree.Kind.UNKNOWN_BLOCK_TAG, inline, sites);\n-    }\n-\n-    private BaseTaglet(String name, DocTree.Kind tagKind, boolean inline, Set<Location> sites) {\n-        this.name = name;\n-        this.tagKind = tagKind;\n-        this.inline = inline;\n-        this.sites = sites;\n-    }\n-\n-    @Override\n-    public Set<Location> getAllowedLocations() {\n-        return sites;\n-    }\n-\n-    @Override\n-    public final boolean inField() {\n-        return sites.contains(Location.FIELD);\n-    }\n-\n-    @Override\n-    public final boolean inConstructor() {\n-        return sites.contains(Location.CONSTRUCTOR);\n-    }\n-\n-    @Override\n-    public final boolean inMethod() {\n-        return sites.contains(Location.METHOD);\n-    }\n-\n-    @Override\n-    public final boolean inOverview() {\n-        return sites.contains(Location.OVERVIEW);\n-    }\n-\n-    @Override\n-    public final boolean inModule() {\n-        return sites.contains(Location.MODULE);\n-    }\n-\n-    @Override\n-    public final boolean inPackage() {\n-        return sites.contains(Location.PACKAGE);\n-    }\n-\n-    @Override\n-    public final boolean inType() {\n-        return sites.contains(Location.TYPE);\n-    }\n-\n-    @Override\n-    public final boolean isInlineTag() {\n-        return inline;\n-    }\n-\n-    @Override\n-    public String getName() {\n-        return name;\n-    }\n-\n-    \/**\n-     * Returns the kind of trees recognized by this taglet.\n-     *\n-     * @return the kind of trees recognized by this taglet\n-     *\/\n-    public DocTree.Kind getTagKind() {\n-        return tagKind;\n-    }\n-\n-    \/**\n-     * Returns whether or not this taglet accepts a {@code DocTree} node.\n-     * The taglet accepts a tree node if it has the same kind, and\n-     * if the kind is {@code UNKNOWN_BLOCK_TAG} the same tag name.\n-     *\n-     * @param tree the tree node\n-     * @return {@code true} if this taglet accepts this tree node\n-     *\/\n-    public boolean accepts(DocTree tree) {\n-        return (tree.getKind() == DocTree.Kind.UNKNOWN_BLOCK_TAG\n-                    && tagKind == DocTree.Kind.UNKNOWN_BLOCK_TAG)\n-                ? ((UnknownBlockTagTree) tree).getTagName().equals(name)\n-                : tree.getKind() == tagKind;\n-    }\n-\n-    \/**\n-     * {@inheritDoc}\n-     *\n-     * @implSpec This implementation throws {@link UnsupportedTagletOperationException}.\n-     *\/\n-    @Override\n-    public Content getInlineTagOutput(Element element, DocTree tag, TagletWriter writer) {\n-        throw new UnsupportedTagletOperationException(\"Method not supported in taglet \" + getName() + \".\");\n-    }\n-\n-    \/**\n-     * {@inheritDoc}\n-     *\n-     * @implSpec This implementation throws {@link UnsupportedTagletOperationException}\n-     *\/\n-    @Override\n-    public Content getAllBlockTagOutput(Element holder, TagletWriter writer) {\n-        throw new UnsupportedTagletOperationException(\"Method not supported in taglet \" + getName() + \".\");\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/BaseTaglet.java","additions":0,"deletions":154,"binary":false,"changes":154,"status":"deleted"},{"patch":"@@ -1,59 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.taglets;\n-\n-import java.util.EnumSet;\n-\n-import javax.lang.model.element.Element;\n-\n-import com.sun.source.doctree.DocTree;\n-import com.sun.source.doctree.LiteralTree;\n-import jdk.javadoc.doclet.Taglet.Location;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-\n-\/**\n- * An inline taglet used to denote literal code fragments.\n- * The enclosed text is interpreted as not containing HTML markup or\n- * nested javadoc tags, and is rendered in a font suitable for code.\n- *\n- * <p> The tag {@code {@code ...}} is equivalent to\n- * {@code <code>{@literal ...}<\/code>}.\n- * For example, the text:\n- * <blockquote>  The type {@code {@code List<P>}}  <\/blockquote>\n- * displays as:\n- * <blockquote>  The type {@code List<P>}  <\/blockquote>\n- *\/\n-public class CodeTaglet extends BaseTaglet {\n-\n-    CodeTaglet() {\n-        super(DocTree.Kind.CODE, true, EnumSet.allOf(Location.class));\n-    }\n-\n-    @Override\n-    public Content getInlineTagOutput(Element element, DocTree tag, TagletWriter writer) {\n-        return writer.codeTagOutput(element, (LiteralTree) tag);\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/CodeTaglet.java","additions":0,"deletions":59,"binary":false,"changes":59,"status":"deleted"},{"patch":"@@ -1,49 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.taglets;\n-\n-import java.util.EnumSet;\n-import javax.lang.model.element.Element;\n-\n-import com.sun.source.doctree.DocTree;\n-import jdk.javadoc.doclet.Taglet.Location;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-\n-\/**\n- * A taglet that represents the {@code @deprecated} tag.\n- *\/\n-public class DeprecatedTaglet extends BaseTaglet {\n-\n-    public DeprecatedTaglet() {\n-        super(DocTree.Kind.DEPRECATED, false,\n-                EnumSet.of(Location.MODULE, Location.TYPE, Location.CONSTRUCTOR, Location.METHOD, Location.FIELD));\n-    }\n-\n-    @Override\n-    public Content getAllBlockTagOutput(Element holder, TagletWriter writer) {\n-        return writer.deprecatedTagOutput(holder);\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/DeprecatedTaglet.java","additions":0,"deletions":49,"binary":false,"changes":49,"status":"deleted"},{"patch":"@@ -1,53 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.taglets;\n-\n-import java.util.EnumSet;\n-import javax.lang.model.element.Element;\n-\n-import com.sun.source.doctree.DocTree;\n-import jdk.javadoc.doclet.Taglet.Location;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-\n-\/**\n- * An inline taglet representing {@code {@docRoot}}.  This taglet is\n- * used to get the relative path to the document's root output\n- * directory.\n- *\/\n-public class DocRootTaglet extends BaseTaglet {\n-\n-    \/**\n-     * Construct a new DocRootTaglet.\n-     *\/\n-    public DocRootTaglet() {\n-        super(DocTree.Kind.DOC_ROOT, true, EnumSet.allOf(Location.class));\n-    }\n-\n-    @Override\n-    public Content getInlineTagOutput(Element holder, DocTree tag, TagletWriter writer) {\n-        return writer.getDocRootOutput();\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/DocRootTaglet.java","additions":0,"deletions":53,"binary":false,"changes":53,"status":"deleted"},{"patch":"@@ -1,51 +0,0 @@\n-\/*\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.taglets;\n-\n-import java.util.EnumSet;\n-import javax.lang.model.element.Element;\n-\n-import com.sun.source.doctree.DocTree;\n-import com.sun.source.doctree.IndexTree;\n-import jdk.javadoc.doclet.Taglet.Location;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-\n-\/**\n- * An inline taglet used to index a word or a phrase.\n- * The enclosed text is interpreted as not containing HTML markup or\n- * nested javadoc tags.\n- *\/\n-public class IndexTaglet extends BaseTaglet {\n-\n-    IndexTaglet() {\n-        super(DocTree.Kind.INDEX, true, EnumSet.allOf(Location.class));\n-    }\n-\n-    @Override\n-    public Content getInlineTagOutput(Element element, DocTree tag, TagletWriter writer) {\n-        return writer.indexTagOutput(element, (IndexTree) tag);\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/IndexTaglet.java","additions":0,"deletions":51,"binary":false,"changes":51,"status":"deleted"},{"patch":"@@ -1,53 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.taglets;\n-\n-import java.util.EnumSet;\n-import javax.lang.model.element.Element;\n-\n-import com.sun.source.doctree.DocTree;\n-import com.sun.source.doctree.LiteralTree;\n-import jdk.javadoc.doclet.Taglet.Location;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-\n-\/**\n- * An inline taglet used to denote literal text.\n- * For example, the text:\n- * <blockquote>  {@code {@literal a<B>c}}  <\/blockquote>\n- * displays as:\n- * <blockquote>  {@literal a<B>c}  <\/blockquote>\n- *\/\n-public class LiteralTaglet extends BaseTaglet {\n-\n-    LiteralTaglet() {\n-        super(DocTree.Kind.LITERAL, true, EnumSet.allOf(Location.class));\n-    }\n-\n-    @Override\n-    public Content getInlineTagOutput(Element e, DocTree tag, TagletWriter writer) {\n-        return writer.literalTagOutput(e, (LiteralTree) tag);\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/LiteralTaglet.java","additions":0,"deletions":53,"binary":false,"changes":53,"status":"deleted"},{"patch":"@@ -1,284 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.taglets;\n-\n-import java.util.*;\n-\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.ElementKind;\n-import javax.lang.model.element.ExecutableElement;\n-import javax.lang.model.element.TypeElement;\n-\n-import com.sun.source.doctree.DocTree;\n-import com.sun.source.doctree.ParamTree;\n-import jdk.javadoc.doclet.Taglet.Location;\n-import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.Messages;\n-import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocFinder;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocFinder.Result;\n-import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n-\n-\/**\n- * A taglet that represents the {@code @param} tag.\n- *\/\n-public class ParamTaglet extends BaseTaglet implements InheritableTaglet {\n-    public enum ParamKind {\n-        \/** Parameter of an executable element. *\/\n-        PARAMETER,\n-        \/** State components of a record. *\/\n-        RECORD_COMPONENT,\n-        \/** Type parameters of an executable element or type element. *\/\n-        TYPE_PARAMETER\n-    }\n-\n-    \/**\n-     * Construct a ParamTaglet.\n-     *\/\n-    public ParamTaglet() {\n-        super(DocTree.Kind.PARAM, false, EnumSet.of(Location.TYPE, Location.CONSTRUCTOR, Location.METHOD));\n-    }\n-\n-    @Override\n-    public Output inherit(Element dst, Element src, DocTree tag, boolean isFirstSentence, BaseConfiguration configuration) {\n-        assert dst.getKind() == ElementKind.METHOD;\n-        assert tag.getKind() == DocTree.Kind.PARAM;\n-        var method = (ExecutableElement) dst;\n-        var param = (ParamTree) tag;\n-        \/\/ find the position of an owner parameter described by the given tag\n-        List<? extends Element> parameterElements;\n-        if (param.isTypeParameter()) {\n-            parameterElements = method.getTypeParameters();\n-        } else {\n-            parameterElements = method.getParameters();\n-        }\n-        Map<String, Integer> stringIntegerMap = mapNameToPosition(configuration.utils, parameterElements);\n-        CommentHelper ch = configuration.utils.getCommentHelper(dst);\n-        Integer position = stringIntegerMap.get(ch.getParameterName(param));\n-        if (position == null) {\n-            return new Output(null, null, List.of(), true);\n-        }\n-        \/\/ try to inherit description of the respective parameter in an overridden method\n-        try {\n-            var docFinder = configuration.utils.docFinder();\n-\n-            Optional<Documentation> r;\n-            if (src != null){\n-                r = docFinder.search((ExecutableElement) src,\n-                                m -> Result.fromOptional(extract(configuration.utils, m, position, param.isTypeParameter())))\n-                        .toOptional();\n-            } else {\n-                r = docFinder.find((ExecutableElement) dst,\n-                                m -> Result.fromOptional(extract(configuration.utils, m, position, param.isTypeParameter())))\n-                        .toOptional();\n-            }\n-            return r.map(result -> new Output(result.paramTree, result.method, result.paramTree.getDescription(), true))\n-                    .orElseGet(() -> new Output(null, null, List.of(), true));\n-        } catch (DocFinder.NoOverriddenMethodFound e) {\n-            return new Output(null, null, List.of(), false);\n-        }\n-    }\n-\n-    \/**\n-     * Given a list of parameter elements, returns a name-position map.\n-     * @param params the list of parameters from a type or an executable member\n-     * @return a name-position map\n-     *\/\n-    private static Map<String, Integer> mapNameToPosition(Utils utils, List<? extends Element> params) {\n-        Map<String, Integer> result = new HashMap<>();\n-        int position = 0;\n-        for (Element e : params) {\n-            String name = utils.isTypeParameterElement(e)\n-                    ? utils.getTypeName(e.asType(), false)\n-                    : utils.getSimpleName(e);\n-            result.put(name, position);\n-            position++;\n-        }\n-        return result;\n-    }\n-\n-    @Override\n-    public Content getAllBlockTagOutput(Element holder, TagletWriter writer) {\n-        Utils utils = writer.configuration().utils;\n-        if (utils.isExecutableElement(holder)) {\n-            ExecutableElement member = (ExecutableElement) holder;\n-            Content output = convertParams(member, ParamKind.TYPE_PARAMETER,\n-                    utils.getTypeParamTrees(member), member.getTypeParameters(), writer);\n-            output.add(convertParams(member, ParamKind.PARAMETER,\n-                    utils.getParamTrees(member), member.getParameters(), writer));\n-            return output;\n-        } else {\n-            TypeElement typeElement = (TypeElement) holder;\n-            Content output = convertParams(typeElement, ParamKind.TYPE_PARAMETER,\n-                    utils.getTypeParamTrees(typeElement), typeElement.getTypeParameters(), writer);\n-            output.add(convertParams(typeElement, ParamKind.RECORD_COMPONENT,\n-                    utils.getParamTrees(typeElement), typeElement.getRecordComponents(), writer));\n-            return output;\n-        }\n-    }\n-\n-    \/**\n-     * Returns a {@code Content} representation of a list of {@code ParamTree}\n-     * of the specified kind.\n-     *\n-     * <p> This method correlates a {@code ParamTree} with a parameter\n-     * {@code Element} by name. Once it's done, a particular {@code ParamTree}\n-     * is addressed by the position (index) of the correlated {@code Element}\n-     * in the list of parameter elements. This is needed for documentation\n-     * inheritance because the corresponding parameters in the inheritance\n-     * hierarchy may be named differently.\n-     *\n-     * <p> This method warns about {@code @param} tags that do not map to\n-     * parameter elements and param tags that are duplicated. <\/p>\n-     *\n-     * @param kind the kind of <em>all<\/em> parameters in the lists\n-     *\/\n-    private Content convertParams(Element e,\n-                                  ParamKind kind,\n-                                  List<ParamTree> tags,\n-                                  List<? extends Element> parameters,\n-                                  TagletWriter writer) {\n-        Map<Integer, ParamTree> tagOfPosition = new HashMap<>();\n-        Messages messages = writer.configuration().getMessages();\n-        CommentHelper ch = writer.configuration().utils.getCommentHelper(e);\n-        if (!tags.isEmpty()) {\n-            Map<String, Integer> positionOfName = mapNameToPosition(writer.configuration().utils, parameters);\n-            for (ParamTree tag : tags) {\n-                String name = ch.getParameterName(tag);\n-                String paramName = kind == ParamKind.TYPE_PARAMETER ? \"<\" + name + \">\" : name;\n-                if (!positionOfName.containsKey(name)) {\n-                    String key = switch (kind) {\n-                        case PARAMETER -> \"doclet.Parameters_warn\";\n-                        case TYPE_PARAMETER -> \"doclet.TypeParameters_warn\";\n-                        case RECORD_COMPONENT -> \"doclet.RecordComponents_warn\";\n-                    };\n-                    if (!writer.configuration().isDocLintReferenceGroupEnabled()) {\n-                        messages.warning(ch.getDocTreePath(tag), key, paramName);\n-                    }\n-                }\n-                Integer position = positionOfName.get(name);\n-                if (position != null) {\n-                    if (tagOfPosition.containsKey(position)) {\n-                        String key = switch (kind) {\n-                            case PARAMETER -> \"doclet.Parameters_dup_warn\";\n-                            case TYPE_PARAMETER -> \"doclet.TypeParameters_dup_warn\";\n-                            case RECORD_COMPONENT -> \"doclet.RecordComponents_dup_warn\";\n-                        };\n-                        if (!writer.configuration().isDocLintReferenceGroupEnabled()) {\n-                            messages.warning(ch.getDocTreePath(tag), key, paramName);\n-                        }\n-                    } else {\n-                        tagOfPosition.put(position, tag);\n-                    }\n-                }\n-            }\n-        }\n-        \/\/ Document declared parameters for which tag documentation is available\n-        \/\/ (either directly or inherited) in order of their declaration.\n-        Content result = writer.getOutputInstance();\n-        for (int i = 0; i < parameters.size(); i++) {\n-            ParamTree tag = tagOfPosition.get(i);\n-            if (tag != null) {\n-                result.add(convertParam(e, kind, writer, tag,\n-                        ch.getParameterName(tag), result.isEmpty()));\n-            } else if (writer.configuration().utils.isMethod(e)) {\n-                result.add(getInheritedTagletOutput(kind, e, writer,\n-                        parameters.get(i), i, result.isEmpty()));\n-            }\n-        }\n-        if (tags.size() > tagOfPosition.size()) {\n-            \/\/ Generate documentation for remaining tags that do not match a declared parameter.\n-            \/\/ These are erroneous but we generate them anyway.\n-            for (ParamTree tag : tags) {\n-                if (!tagOfPosition.containsValue(tag)) {\n-                    result.add(convertParam(e, kind, writer, tag,\n-                            ch.getParameterName(tag), result.isEmpty()));\n-                }\n-            }\n-        }\n-        return result;\n-    }\n-\n-    \/**\n-     * Tries to inherit documentation for a specific parameter (element).\n-     * If unsuccessful, the returned content is empty.\n-     *\/\n-    private Content getInheritedTagletOutput(ParamKind kind,\n-                                             Element holder,\n-                                             TagletWriter writer,\n-                                             Element param,\n-                                             int position,\n-                                             boolean isFirst) {\n-        Utils utils = writer.configuration().utils;\n-        Content result = writer.getOutputInstance();\n-        var r = utils.docFinder().search((ExecutableElement) holder,\n-                        m -> Result.fromOptional(extract(utils, m, position, kind == ParamKind.TYPE_PARAMETER)))\n-                .toOptional();\n-        if (r.isPresent()) {\n-            String name = kind != ParamKind.TYPE_PARAMETER\n-                    ? utils.getSimpleName(param)\n-                    : utils.getTypeName(param.asType(), false);\n-            Content content = convertParam(r.get().method, kind, writer,\n-                    r.get().paramTree, name, isFirst);\n-            result.add(content);\n-        }\n-        return result;\n-    }\n-\n-    private record Documentation(ParamTree paramTree, ExecutableElement method) { }\n-\n-    private static Optional<Documentation> extract(Utils utils, ExecutableElement method, Integer position, boolean typeParam) {\n-        var ch = utils.getCommentHelper(method);\n-        List<ParamTree> tags = typeParam\n-                ? utils.getTypeParamTrees(method)\n-                : utils.getParamTrees(method);\n-        List<? extends Element> parameters = typeParam\n-                ? method.getTypeParameters()\n-                : method.getParameters();\n-        var positionOfName = mapNameToPosition(utils, parameters);\n-        return tags.stream().filter(t -> position.equals(positionOfName.get(ch.getParameterName(t))))\n-                .map(t -> new Documentation(t, method)).findAny();\n-    }\n-\n-    \/**\n-     * Converts an individual {@code ParamTree} to {@code Content}, which is\n-     * prepended with the header if the parameter is first in the list.\n-     *\/\n-    private Content convertParam(Element e,\n-                                 ParamKind kind,\n-                                 TagletWriter writer,\n-                                 ParamTree paramTag,\n-                                 String name,\n-                                 boolean isFirstParam) {\n-        Content result = writer.getOutputInstance();\n-        if (isFirstParam) {\n-            result.add(writer.getParamHeader(kind));\n-        }\n-        result.add(writer.paramTagOutput(e, paramTag, name));\n-        return result;\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/ParamTaglet.java","additions":0,"deletions":284,"binary":false,"changes":284,"status":"deleted"},{"patch":"@@ -1,127 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.taglets;\n-\n-import java.util.EnumSet;\n-import java.util.List;\n-import java.util.Optional;\n-import java.util.stream.Stream;\n-\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.ElementKind;\n-import javax.lang.model.element.ExecutableElement;\n-import javax.lang.model.type.TypeMirror;\n-\n-import com.sun.source.doctree.DocTree;\n-import com.sun.source.doctree.ReturnTree;\n-import jdk.javadoc.doclet.Taglet.Location;\n-import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.Messages;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocFinder;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocFinder.Result;\n-import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n-\n-\/**\n- * A taglet that represents the {@code @return} and {@code {@return }} tags.\n- *\/\n-public class ReturnTaglet extends BaseTaglet implements InheritableTaglet {\n-\n-    public ReturnTaglet() {\n-        super(DocTree.Kind.RETURN, true, EnumSet.of(Location.METHOD));\n-    }\n-\n-    @Override\n-    public boolean isBlockTag() {\n-        return true;\n-    }\n-\n-    @Override\n-    public Output inherit(Element dst, Element src, DocTree tag, boolean isFirstSentence, BaseConfiguration configuration) {\n-        try {\n-            var docFinder = configuration.utils.docFinder();\n-            Optional<Documentation> r;\n-            if (src == null) {\n-                r = docFinder.find((ExecutableElement) dst, m -> Result.fromOptional(extract(configuration.utils, m))).toOptional();\n-            } else {\n-                r = docFinder.search((ExecutableElement) src, m -> Result.fromOptional(extract(configuration.utils, m))).toOptional();\n-            }\n-            return r.map(result -> new Output(result.returnTree, result.method, result.returnTree.getDescription(), true))\n-                    .orElseGet(() -> new Output(null, null, List.of(), true));\n-        } catch (DocFinder.NoOverriddenMethodFound e) {\n-            return new Output(null, null, List.of(), false);\n-        }\n-    }\n-\n-    @Override\n-    public Content getInlineTagOutput(Element element, DocTree tag, TagletWriter writer) {\n-        return writer.returnTagOutput(element, (ReturnTree) tag, true);\n-    }\n-\n-    @Override\n-    public Content getAllBlockTagOutput(Element holder, TagletWriter writer) {\n-        assert holder.getKind() == ElementKind.METHOD : holder.getKind();\n-        var method = (ExecutableElement) holder;\n-        Messages messages = writer.configuration().getMessages();\n-        Utils utils = writer.configuration().utils;\n-        List<? extends ReturnTree> tags = utils.getReturnTrees(holder);\n-\n-        \/\/ make sure we are not using @return on a method with the void return type\n-        TypeMirror returnType = utils.getReturnType(writer.getCurrentPageElement(), method);\n-        if (returnType != null && utils.isVoid(returnType)) {\n-            if (!tags.isEmpty() && !writer.configuration().isDocLintReferenceGroupEnabled()) {\n-                messages.warning(holder, \"doclet.Return_tag_on_void_method\");\n-            }\n-            return null;\n-        }\n-\n-        \/\/ it would also be good to check if there are more than one @return\n-        \/\/ tags and produce a warning or error similarly to how it's done\n-        \/\/ above for a case where @return is used for void\n-\n-        var docFinder = utils.docFinder();\n-        return docFinder.search(method, m -> Result.fromOptional(extract(utils, m))).toOptional()\n-                .map(r -> writer.returnTagOutput(r.method, r.returnTree, false))\n-                .orElse(null);\n-    }\n-\n-    private record Documentation(ReturnTree returnTree, ExecutableElement method) { }\n-\n-    private static Optional<Documentation> extract(Utils utils, ExecutableElement method) {\n-        \/\/ TODO\n-        \/\/  Using getBlockTags(..., Kind.RETURN) for clarity. Since @return has become a bimodal tag,\n-        \/\/  Utils.getReturnTrees is now a misnomer: it returns only block returns, not all returns.\n-        \/\/  We could revisit this later.\n-        Stream<? extends ReturnTree> blockTags = utils.getBlockTags(method, DocTree.Kind.RETURN, ReturnTree.class).stream();\n-        Stream<? extends ReturnTree> mainDescriptionTags = utils.getFirstSentenceTrees(method).stream()\n-                .mapMulti((t, c) -> {\n-                    if (t.getKind() == DocTree.Kind.RETURN) c.accept((ReturnTree) t);\n-                });\n-        \/\/ this method should not check validity of @return tags, hence findAny and not findFirst or what have you\n-        return Stream.concat(blockTags, mainDescriptionTags)\n-                .map(t -> new Documentation(t, method)).findAny();\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/ReturnTaglet.java","additions":0,"deletions":127,"binary":false,"changes":127,"status":"deleted"},{"patch":"@@ -1,85 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.taglets;\n-\n-import java.util.EnumSet;\n-import java.util.List;\n-import java.util.Optional;\n-\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.ExecutableElement;\n-\n-import com.sun.source.doctree.DocTree;\n-import com.sun.source.doctree.SeeTree;\n-import jdk.javadoc.doclet.Taglet.Location;\n-import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocFinder.Result;\n-import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n-\n-\/**\n- * A taglet that represents the {@code @see} tag.\n- *\/\n-public class SeeTaglet extends BaseTaglet implements InheritableTaglet {\n-\n-    public SeeTaglet() {\n-        super(DocTree.Kind.SEE, false, EnumSet.allOf(Location.class));\n-    }\n-\n-    @Override\n-    public Output inherit(Element dst, Element src, DocTree tag, boolean isFirstSentence, BaseConfiguration configuration) {\n-        CommentHelper ch = configuration.utils.getCommentHelper(dst);\n-        var path = ch.getDocTreePath(tag);\n-        configuration.getMessages().warning(path, \"doclet.inheritDocWithinInappropriateTag\");\n-        return new Output(null, null, List.of(), true \/* true, otherwise there will be an exception up the stack *\/);\n-    }\n-\n-    @Override\n-    public Content getAllBlockTagOutput(Element holder, TagletWriter writer) {\n-        Utils utils = writer.configuration().utils;\n-        List<? extends SeeTree> tags = utils.getSeeTrees(holder);\n-        Element e = holder;\n-        if (utils.isMethod(holder)) {\n-            var docFinder = utils.docFinder();\n-            Optional<Documentation> result = docFinder.search((ExecutableElement) holder,\n-                    m -> Result.fromOptional(extract(utils, m))).toOptional();\n-            if (result.isPresent()) {\n-                ExecutableElement m = result.get().method();\n-                tags = utils.getSeeTrees(m);\n-                e = m;\n-            }\n-        }\n-        return writer.seeTagOutput(e, tags);\n-    }\n-\n-    private record Documentation(List<? extends SeeTree> seeTrees, ExecutableElement method) { }\n-\n-    private static Optional<Documentation> extract(Utils utils, ExecutableElement method) {\n-        List<? extends SeeTree> tags = utils.getSeeTrees(method);\n-        return tags.isEmpty() ? Optional.empty() : Optional.of(new Documentation(tags, method));\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/SeeTaglet.java","additions":0,"deletions":85,"binary":false,"changes":85,"status":"deleted"},{"patch":"@@ -1,206 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.taglets;\n-\n-import java.util.EnumSet;\n-import java.util.List;\n-import java.util.Optional;\n-import java.util.Set;\n-\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.ElementKind;\n-import javax.lang.model.element.ExecutableElement;\n-\n-import com.sun.source.doctree.DocTree;\n-import jdk.javadoc.doclet.Taglet.Location;\n-\n-import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocFinder;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocFinder.Result;\n-import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n-\n-\/**\n- * A custom single-argument block tag.\n- *\/\n-public class SimpleTaglet extends BaseTaglet implements InheritableTaglet {\n-\n-    \/**\n-     * The header to output.\n-     *\/\n-    protected String header;\n-\n-    \/**\n-     * Whether or not the taglet should generate output.\n-     * Standard tags like {@code @author}, {@code @since}, {@code @version} can\n-     * be disabled by command-line options; custom tags created with -tag can be\n-     * disabled with an X in the defining string.\n-     *\/\n-    protected final boolean enabled;\n-\n-    \/**\n-     * Constructs a {@code SimpleTaglet}.\n-     *\n-     * @param tagName   the name of this tag\n-     * @param header    the header to output\n-     * @param locations the possible locations that this tag can appear in\n-     *                  The string can contain 'p' for package, 't' for type,\n-     *                  'm' for method, 'c' for constructor and 'f' for field.\n-     *                  See {@link #getLocations(String) getLocations} for the\n-     *                  complete list.\n-     *\/\n-    public SimpleTaglet(String tagName, String header, String locations) {\n-        this(tagName, header, getLocations(locations), isEnabled(locations));\n-    }\n-\n-    \/**\n-     * Constructs a {@code SimpleTaglet}.\n-     *\n-     * @param tagKind   the kind of this tag\n-     * @param header    the header to output\n-     * @param locations the possible locations that this tag can appear in\n-     *\/\n-    public SimpleTaglet(DocTree.Kind tagKind, String header, Set<Location> locations) {\n-        this(tagKind, header, locations, true);\n-    }\n-\n-    \/**\n-     * Constructs a {@code SimpleTaglet}.\n-     *\n-     * @param tagName   the name of this tag\n-     * @param header    the header to output\n-     * @param locations the possible locations that this tag can appear in\n-     *\/\n-    public SimpleTaglet(String tagName, String header, Set<Location> locations) {\n-        this(tagName, header, locations, true);\n-    }\n-\n-    \/**\n-     * Constructs a {@code SimpleTaglet}.\n-     *\n-     * @param tagName   the name of this tag\n-     * @param header    the header to output\n-     * @param locations the possible locations that this tag can appear in\n-     *\/\n-    public SimpleTaglet(String tagName, String header, Set<Location> locations, boolean enabled) {\n-        super(tagName, false, locations);\n-        this.header = header;\n-        this.enabled = enabled;\n-    }\n-\n-    \/**\n-     * Constructs a {@code SimpleTaglet}.\n-     *\n-     * @param tagKind   the kind of this tag\n-     * @param header    the header to output\n-     * @param locations the possible locations that this tag can appear in\n-     *\/\n-    public SimpleTaglet(DocTree.Kind tagKind, String header, Set<Location> locations, boolean enabled) {\n-        super(tagKind, false, locations);\n-        this.header = header;\n-        this.enabled = enabled;\n-    }\n-\n-    private static Set<Location> getLocations(String locations) {\n-        Set<Location> set = EnumSet.noneOf(Location.class);\n-        for (int i = 0; i < locations.length(); i++) {\n-            switch (locations.charAt(i)) {\n-                case 'a':  case 'A':\n-                    return EnumSet.allOf(Location.class);\n-                case 'c':  case 'C':\n-                    set.add(Location.CONSTRUCTOR);\n-                    break;\n-                case 'f':  case 'F':\n-                    set.add(Location.FIELD);\n-                    break;\n-                case 'm':  case 'M':\n-                    set.add(Location.METHOD);\n-                    break;\n-                case 'o':  case 'O':\n-                    set.add(Location.OVERVIEW);\n-                    break;\n-                case 'p':  case 'P':\n-                    set.add(Location.PACKAGE);\n-                    break;\n-                case 's':  case 'S':        \/\/ super-packages, anyone?\n-                    set.add(Location.MODULE);\n-                    break;\n-                case 't':  case 'T':\n-                    set.add(Location.TYPE);\n-                    break;\n-                case 'x':  case 'X':\n-                    break;\n-            }\n-        }\n-        return set;\n-    }\n-\n-    private static boolean isEnabled(String locations) {\n-        return locations.matches(\"[^Xx]*\");\n-    }\n-\n-    @Override\n-    public Output inherit(Element dst, Element src, DocTree tag, boolean isFirstSentence, BaseConfiguration configuration) {\n-        assert dst.getKind() == ElementKind.METHOD;\n-        assert !isFirstSentence;\n-        try {\n-            var docFinder = configuration.utils.docFinder();\n-            Optional<Documentation> r;\n-            if (src == null) {\n-                r = docFinder.find((ExecutableElement) dst,\n-                        m -> Result.fromOptional(extractFirst(m, configuration.utils))).toOptional();\n-            } else {\n-                r = docFinder.search((ExecutableElement) src,\n-                        m -> Result.fromOptional(extractFirst(m, configuration.utils))).toOptional();\n-            }\n-            return r.map(result -> new Output(result.tag, result.method, result.description, true))\n-                    .orElseGet(()->new Output(null, null, List.of(), true));\n-        } catch (DocFinder.NoOverriddenMethodFound e) {\n-            return new Output(null, null, List.of(), false);\n-        }\n-    }\n-\n-    record Documentation(DocTree tag, List<? extends DocTree> description, ExecutableElement method) { }\n-\n-    private Optional<Documentation> extractFirst(ExecutableElement m, Utils utils) {\n-        List<? extends DocTree> tags = utils.getBlockTags(m, this);\n-        if (tags.isEmpty()) {\n-            return Optional.empty();\n-        }\n-        DocTree t = tags.get(0);\n-        return Optional.of(new Documentation(t, utils.getCommentHelper(m).getDescription(t), m));\n-    }\n-\n-    @Override\n-    public Content getAllBlockTagOutput(Element holder, TagletWriter writer) {\n-        Utils utils = writer.configuration().utils;\n-        List<? extends DocTree> tags = utils.getBlockTags(holder, this);\n-        if (header == null || tags.isEmpty()) {\n-            return null;\n-        }\n-        return writer.simpleBlockTagOutput(holder, tags, header);\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/SimpleTaglet.java","additions":0,"deletions":206,"binary":false,"changes":206,"status":"deleted"},{"patch":"@@ -1,464 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.taglets;\n-\n-import java.io.IOException;\n-import java.util.EnumSet;\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.stream.Collectors;\n-\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.PackageElement;\n-import javax.tools.Diagnostic;\n-import javax.tools.DocumentationTool.Location;\n-import javax.tools.FileObject;\n-\n-import com.sun.source.doctree.AttributeTree;\n-import com.sun.source.doctree.DocTree;\n-import com.sun.source.doctree.SnippetTree;\n-import com.sun.source.doctree.TextTree;\n-import jdk.javadoc.doclet.Taglet;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.DocletElement;\n-import jdk.javadoc.internal.doclets.toolkit.Resources;\n-import jdk.javadoc.internal.doclets.toolkit.taglets.snippet.Action;\n-import jdk.javadoc.internal.doclets.toolkit.taglets.snippet.ParseException;\n-import jdk.javadoc.internal.doclets.toolkit.taglets.snippet.Parser;\n-import jdk.javadoc.internal.doclets.toolkit.taglets.snippet.StyledText;\n-import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n-\n-\/**\n- * A taglet that represents the {@code @snippet} tag.\n- *\/\n-public class SnippetTaglet extends BaseTaglet {\n-\n-    public enum Language {\n-\n-        JAVA(\"java\"),\n-        PROPERTIES(\"properties\");\n-\n-        private static final Map<String, Language> languages;\n-\n-        static {\n-            Map<String, Language> tmp = new HashMap<>();\n-            for (var language : values()) {\n-                String id = Objects.requireNonNull(language.identifier);\n-                if (tmp.put(id, language) != null)\n-                    throw new IllegalStateException(); \/\/ 1-1 correspondence\n-            }\n-            languages = Map.copyOf(tmp);\n-        }\n-\n-        Language(String id) {\n-            identifier = id;\n-        }\n-\n-        private final String identifier;\n-\n-        public static Optional<Language> of(String identifier) {\n-            if (identifier == null)\n-                return Optional.empty();\n-            return Optional.ofNullable(languages.get(identifier));\n-        }\n-\n-        public String getIdentifier() {return identifier;}\n-    }\n-\n-    public SnippetTaglet() {\n-        super(DocTree.Kind.SNIPPET, true, EnumSet.allOf(Taglet.Location.class));\n-    }\n-\n-    \/*\n-     * A snippet can specify content by value (inline), by reference (external)\n-     * or both (hybrid).\n-     *\n-     * To specify content by value, a snippet uses its body; the body of\n-     * a snippet is the content.\n-     *\n-     * To specify content by reference, a snippet uses either the \"class\"\n-     * or \"file\" attribute; the value of that attribute refers to the content.\n-     *\n-     * A snippet can specify the \"region\" attribute. That attribute refines\n-     * the location of the content. The value of that attribute must match\n-     * one of the named regions in the snippets content.\n-     *\/\n-    @Override\n-    public Content getInlineTagOutput(Element holder, DocTree tag, TagletWriter writer) {\n-        try {\n-            return generateContent(holder, tag, writer);\n-        } catch (BadSnippetException e) {\n-            error(writer, holder, e.tag(), e.key(), e.args());\n-            String details = writer.configuration().getDocResources().getText(e.key(), e.args());\n-            return badSnippet(writer, Optional.of(details));\n-        }\n-    }\n-\n-    private static final class BadSnippetException extends Exception {\n-\n-        @java.io.Serial\n-        private static final long serialVersionUID = 1;\n-\n-        private final transient DocTree tag;\n-        private final String key;\n-        private final transient Object[] args;\n-\n-        BadSnippetException(DocTree tag, String key, Object... args) {\n-            this.tag = tag;\n-            this.key = key;\n-            this.args = args;\n-        }\n-\n-        DocTree tag() {\n-            return tag;\n-        }\n-\n-        String key() {\n-            return key;\n-        }\n-\n-        Object[] args() {\n-            return args;\n-        }\n-    }\n-\n-    private Content generateContent(Element holder, DocTree tag, TagletWriter writer)\n-            throws BadSnippetException\n-    {\n-        SnippetTree snippetTag = (SnippetTree) tag;\n-\n-        \/\/ organize snippet attributes in a map, performing basic checks along the way\n-        Map<String, AttributeTree> attributes = new HashMap<>();\n-        for (DocTree d : snippetTag.getAttributes()) {\n-            if (!(d instanceof AttributeTree a)) {\n-                continue; \/\/ this might be an ErroneousTree\n-            }\n-            if (attributes.putIfAbsent(a.getName().toString(), a) == null) {\n-                continue;\n-            }\n-            \/\/ two like-named attributes found; although we report on the most\n-            \/\/ recently encountered of the two, the iteration order might differ\n-            \/\/ from the source order (see JDK-8266826)\n-            throw new BadSnippetException(a, \"doclet.tag.attribute.repeated\",\n-                    a.getName().toString());\n-        }\n-\n-        final String CLASS = \"class\";\n-        final String FILE = \"file\";\n-\n-        final boolean containsClass = attributes.containsKey(CLASS);\n-        final boolean containsFile = attributes.containsKey(FILE);\n-        final boolean containsBody = snippetTag.getBody() != null;\n-\n-        if (containsClass && containsFile) {\n-            throw new BadSnippetException(attributes.get(CLASS),\n-                    \"doclet.snippet.contents.ambiguity.external\");\n-        } else if (!containsClass && !containsFile && !containsBody) {\n-            throw new BadSnippetException(tag, \"doclet.snippet.contents.none\");\n-        }\n-\n-        String regionName = null;\n-        AttributeTree region = attributes.get(\"region\");\n-        if (region != null) {\n-            regionName = stringValueOf(region);\n-            if (regionName.isBlank()) {\n-                throw new BadSnippetException(region, \"doclet.tag.attribute.value.illegal\",\n-                        \"region\", region.getValue());\n-            }\n-        }\n-\n-        String inlineContent = null, externalContent = null;\n-\n-        if (containsBody) {\n-            inlineContent = snippetTag.getBody().getBody();\n-        }\n-\n-        FileObject fileObject = null;\n-\n-        if (containsFile || containsClass) {\n-            AttributeTree a;\n-            String v = containsFile\n-                    ? stringValueOf((a = attributes.get(FILE)))\n-                    : stringValueOf((a = attributes.get(CLASS))).replace(\".\", \"\/\") + \".java\";\n-\n-            if (v.isBlank()) {\n-                throw new BadSnippetException(a, \"doclet.tag.attribute.value.illegal\",\n-                        containsFile ? FILE : CLASS, v);\n-            }\n-\n-            \/\/ we didn't create JavaFileManager, so we won't close it; even if an error occurs\n-            var fileManager = writer.configuration().getFileManager();\n-\n-            try {\n-                \/\/ first, look in local snippet-files subdirectory\n-                var utils = writer.configuration().utils;\n-                var pkg = getPackageElement(holder, utils);\n-                var pkgLocation = utils.getLocationForPackage(pkg);\n-                var pkgName = pkg.getQualifiedName().toString(); \/\/ note: empty string for unnamed package\n-                var relativeName = \"snippet-files\/\" + v;\n-                fileObject = fileManager.getFileForInput(pkgLocation, pkgName, relativeName);\n-\n-                \/\/ if not found in local snippet-files directory, look on snippet path\n-                if (fileObject == null && fileManager.hasLocation(Location.SNIPPET_PATH)) {\n-                    fileObject = fileManager.getFileForInput(Location.SNIPPET_PATH, \"\", v);\n-                }\n-            } catch (IOException | IllegalArgumentException e) { \/\/ TODO: test this when JDK-8276892 is integrated\n-                \/\/ JavaFileManager.getFileForInput can throw IllegalArgumentException in certain cases\n-                throw new BadSnippetException(a, \"doclet.exception.read.file\", v, e);\n-            }\n-\n-            if (fileObject == null) {\n-                \/\/ i.e. the file does not exist\n-                throw new BadSnippetException(a, \"doclet.snippet_file_not_found\", v);\n-            }\n-\n-            try {\n-                externalContent = fileObject.getCharContent(true).toString();\n-            } catch (IOException e) {  \/\/ TODO: test this when JDK-8276892 is integrated\n-                throw new BadSnippetException(a, \"doclet.exception.read.file\",\n-                        fileObject.getName(), e);\n-            }\n-        }\n-\n-        String lang = null;\n-        AttributeTree langAttr = attributes.get(\"lang\");\n-        if (langAttr != null) {\n-            lang = stringValueOf(langAttr);\n-        } else if (containsClass) {\n-            lang = \"java\";\n-        } else if (containsFile) {\n-            lang = languageFromFileName(fileObject.getName());\n-        }\n-\n-        Optional<Language> language = Language.of(lang);\n-\n-\n-        \/\/ TODO cache parsed external snippet (WeakHashMap)\n-\n-        StyledText inlineSnippet = null;\n-        StyledText externalSnippet = null;\n-\n-        try {\n-            Diags d = (text, pos) -> {\n-                var path = writer.configuration().utils.getCommentHelper(holder)\n-                        .getDocTreePath(snippetTag.getBody());\n-                writer.configuration().getReporter().print(Diagnostic.Kind.WARNING,\n-                        path, pos, pos, pos, text);\n-            };\n-            if (inlineContent != null) {\n-                inlineSnippet = parse(writer.configuration().getDocResources(), d, language, inlineContent);\n-            }\n-        } catch (ParseException e) {\n-            var path = writer.configuration().utils.getCommentHelper(holder)\n-                    .getDocTreePath(snippetTag.getBody());\n-            \/\/ TODO: there should be a method in Messages; that method should mirror Reporter's; use that method instead accessing Reporter.\n-            String msg = writer.configuration().getDocResources()\n-                    .getText(\"doclet.snippet.markup\", e.getMessage());\n-            writer.configuration().getReporter().print(Diagnostic.Kind.ERROR,\n-                    path, e.getPosition(), e.getPosition(), e.getPosition(), msg);\n-            return badSnippet(writer, Optional.of(e.getMessage()));\n-        }\n-\n-        try {\n-            var finalFileObject = fileObject;\n-            Diags d = (text, pos) -> writer.configuration().getMessages().warning(finalFileObject, pos, pos, pos, text);\n-            if (externalContent != null) {\n-                externalSnippet = parse(writer.configuration().getDocResources(), d, language, externalContent);\n-            }\n-        } catch (ParseException e) {\n-            assert fileObject != null;\n-            writer.configuration().getMessages().error(fileObject, e.getPosition(),\n-                    e.getPosition(), e.getPosition(), \"doclet.snippet.markup\", e.getMessage());\n-            return badSnippet(writer, Optional.of(e.getMessage()));\n-        }\n-\n-        \/\/ the region must be matched at least in one content: it can be matched\n-        \/\/ in both, but never in none\n-        if (regionName != null) {\n-            StyledText r1 = null;\n-            StyledText r2 = null;\n-            if (inlineSnippet != null) {\n-                r1 = inlineSnippet.getBookmarkedText(regionName);\n-                if (r1 != null) {\n-                    inlineSnippet = r1;\n-                }\n-            }\n-            if (externalSnippet != null) {\n-                r2 = externalSnippet.getBookmarkedText(regionName);\n-                if (r2 != null) {\n-                    externalSnippet = r2;\n-                }\n-            }\n-            if (r1 == null && r2 == null) {\n-                throw new BadSnippetException(tag, \"doclet.snippet.region.not_found\", regionName);\n-            }\n-        }\n-\n-        if (inlineSnippet != null) {\n-            inlineSnippet = toDisplayForm(inlineSnippet);\n-        }\n-\n-        if (externalSnippet != null) {\n-            externalSnippet = toDisplayForm(externalSnippet);\n-        }\n-\n-        if (inlineSnippet != null && externalSnippet != null) {\n-            String inlineStr = inlineSnippet.asCharSequence().toString();\n-            String externalStr = externalSnippet.asCharSequence().toString();\n-            if (!Objects.equals(inlineStr, externalStr)) {\n-                throw new BadSnippetException(tag, \"doclet.snippet.contents.mismatch\", diff(inlineStr, externalStr));\n-            }\n-        }\n-\n-        assert inlineSnippet != null || externalSnippet != null;\n-        StyledText text = inlineSnippet != null ? inlineSnippet : externalSnippet;\n-\n-        AttributeTree idAttr = attributes.get(\"id\");\n-        String id = idAttr == null\n-                ? null\n-                : stringValueOf(idAttr);\n-\n-        return writer.snippetTagOutput(holder, snippetTag, text, id, lang);\n-    }\n-\n-    \/*\n-     * Maybe there's a case for implementing a proper (or at least more helpful)\n-     * diff view, but for now simply outputting both sides of a hybrid snippet\n-     * would do. A user could then use a diff tool of their choice to compare\n-     * those sides.\n-     *\n-     * There's a separate issue of mapping discrepancies back to their\n-     * originating source in the doc comment and the external file. Maybe there\n-     * is a value in it, or maybe there isn't. In any case, accurate mapping\n-     * would not be trivial to code.\n-     *\/\n-    private static String diff(String inline, String external) {\n-        return \"\"\"\n-               ----------------- inline -------------------\n-               %s\n-               ----------------- external -----------------\n-               %s\n-               \"\"\".formatted(inline, external);\n-    }\n-\n-    private StyledText parse(Resources resources, Diags diags, Optional<Language> language, String content) throws ParseException {\n-        Parser.Result result = new Parser(resources).parse(diags, language, content);\n-        result.actions().forEach(Action::perform);\n-        return result.text();\n-    }\n-\n-    public interface Diags {\n-        void warn(String text, int pos);\n-    }\n-\n-    private static String stringValueOf(AttributeTree at) throws BadSnippetException {\n-        if (at.getValueKind() == AttributeTree.ValueKind.EMPTY) {\n-            throw new BadSnippetException(at, \"doclet.tag.attribute.value.missing\",\n-                    at.getName().toString());\n-        }\n-        return at.getValue().stream()\n-            \/\/ value consists of TextTree or ErroneousTree nodes;\n-            \/\/ ErroneousTree is a subtype of TextTree\n-            .map(t -> ((TextTree) t).getBody())\n-            .collect(Collectors.joining());\n-    }\n-\n-    private String languageFromFileName(String fileName) {\n-        \/\/ TODO: find a way to extend\/customize the list of recognized file name extensions\n-        if (fileName.endsWith(\".java\")) {\n-            return \"java\";\n-        } else if (fileName.endsWith(\".properties\")) {\n-            return \"properties\";\n-        }\n-        return null;\n-    }\n-\n-    private void error(TagletWriter writer, Element holder, DocTree tag, String key, Object... args) {\n-        writer.configuration().getMessages().error(\n-            writer.configuration().utils.getCommentHelper(holder).getDocTreePath(tag), key, args);\n-    }\n-\n-    private Content badSnippet(TagletWriter writer, Optional<String> details) {\n-        Resources resources = writer.configuration().getDocResources();\n-        return writer.invalidTagOutput(resources.getText(\"doclet.tag.invalid\", \"snippet\"), details);\n-    }\n-\n-    private static PackageElement getPackageElement(Element e, Utils utils) {\n-        if (e instanceof DocletElement de) {\n-            return de.getPackageElement();\n-        } else {\n-            return utils.elementUtils.getPackageOf(e);\n-        }\n-    }\n-\n-    \/*\n-     * Returns a version of styled text that can be rendered into HTML or\n-     * compared to another such version. The latter is used to decide if inline\n-     * and external parts of a hybrid snippet match.\n-     *\n-     * Use this method to obtain a final version of text. After all\n-     * transformations on text have been performed, call this method with that\n-     * text and then use the returned result as described above.\n-     *\/\n-    private static StyledText toDisplayForm(StyledText source) {\n-        var sourceString = source.asCharSequence().toString();\n-        var result = new StyledText();\n-        var originalLines = sourceString.lines().iterator();\n-        var unindentedLines = sourceString.stripIndent().lines().iterator();\n-        \/\/ done; the rest of the method translates the stripIndent\n-        \/\/ transformation performed on a character sequence to the styled\n-        \/\/ text that this sequence originates from, line by line\n-        int pos = 0;\n-        \/\/ overcome a \"quirk\" of String.lines\n-        boolean endsWithLineFeed = !sourceString.isEmpty() && sourceString.charAt(source.length() - 1) == '\\n';\n-        while (originalLines.hasNext() && unindentedLines.hasNext()) { \/\/ [^1]\n-            String originalLine = originalLines.next();\n-            String unindentedLine = unindentedLines.next();\n-            \/\/ the search MUST succeed\n-            int idx = originalLine.indexOf(unindentedLine);\n-            \/\/ assume newlines are always of the \\n form\n-            \/\/ append the found fragment\n-            result.append(source.subText(pos + idx, pos + idx + unindentedLine.length()));\n-            \/\/ append the possibly styled newline, but not if it's the last line\n-            int eol = pos + originalLine.length();\n-            if (originalLines.hasNext() || endsWithLineFeed) {\n-                result.append(source.subText(eol, eol + 1));\n-            }\n-            pos = eol + 1;\n-        }\n-        return result;\n-        \/\/ [^1]: Checking hasNext() on both iterators might look unnecessary.\n-        \/\/ However, there are strings for which those iterators return different\n-        \/\/ number of lines. That is, there exists a string s, such that\n-        \/\/\n-        \/\/     s.lines().count() != s.stripIndent().lines().count()\n-        \/\/\n-        \/\/ The most trivial example of such a string is \" \". In fact, any string\n-        \/\/ with a trailing non-empty blank line would do.\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/SnippetTaglet.java","additions":0,"deletions":464,"binary":false,"changes":464,"status":"deleted"},{"patch":"@@ -1,83 +0,0 @@\n-\/*\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.taglets;\n-\n-import java.util.EnumSet;\n-import java.util.List;\n-import java.util.Optional;\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.ExecutableElement;\n-\n-import com.sun.source.doctree.DocTree;\n-import com.sun.source.doctree.SpecTree;\n-import jdk.javadoc.doclet.Taglet.Location;\n-import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocFinder.Result;\n-import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n-\n-\/**\n- * A taglet that represents the {@code @spec} tag.\n- *\/\n-public class SpecTaglet extends BaseTaglet implements InheritableTaglet {\n-\n-    public SpecTaglet() {\n-        super(DocTree.Kind.SPEC, false, EnumSet.allOf(Location.class));\n-    }\n-\n-    @Override\n-    public Output inherit(Element dst, Element src, DocTree tag, boolean isFirstSentence, BaseConfiguration configuration) {\n-        CommentHelper ch = configuration.utils.getCommentHelper(dst);\n-        var path = ch.getDocTreePath(tag);\n-        configuration.getMessages().warning(path, \"doclet.inheritDocWithinInappropriateTag\");\n-        return new Output(null, null, List.of(), true \/* true, otherwise there will be an exception up the stack *\/);\n-    }\n-\n-    @Override\n-    public Content getAllBlockTagOutput(Element holder, TagletWriter writer) {\n-        Utils utils = writer.configuration().utils;\n-        List<? extends SpecTree> tags = utils.getSpecTrees(holder);\n-        Element e = holder;\n-        if (utils.isMethod(holder)) {\n-            var docFinder = utils.docFinder();\n-            Optional<Documentation> result = docFinder.search((ExecutableElement) holder,\n-                    m -> Result.fromOptional(extract(utils, m))).toOptional();\n-            if (result.isPresent()) {\n-                e = result.get().method();\n-                tags = result.get().specTrees();\n-            }\n-        }\n-        return writer.specTagOutput(e, tags);\n-    }\n-\n-    private record Documentation(List<? extends SpecTree> specTrees, ExecutableElement method) { }\n-\n-    private static Optional<Documentation> extract(Utils utils, ExecutableElement method) {\n-        List<? extends SpecTree> tags = utils.getSpecTrees(method);\n-        return tags.isEmpty() ? Optional.empty() : Optional.of(new Documentation(tags, method));\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/SpecTaglet.java","additions":0,"deletions":83,"binary":false,"changes":83,"status":"deleted"},{"patch":"@@ -1,50 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.taglets;\n-\n-import java.util.EnumSet;\n-import javax.lang.model.element.Element;\n-\n-import com.sun.source.doctree.DocTree;\n-import jdk.javadoc.doclet.Taglet.Location;\n-import com.sun.source.doctree.SummaryTree;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-\n-\/**\n- * A taglet that represents the {@code {@summary}} tag.\n- *\/\n-public class SummaryTaglet extends BaseTaglet {\n-\n-    public SummaryTaglet() {\n-        super(DocTree.Kind.SUMMARY, true, EnumSet.allOf(Location.class));\n-    }\n-\n-    @Override\n-    public Content getInlineTagOutput(Element holder, DocTree tag, TagletWriter writer) {\n-        return writer.commentTagsToOutput(holder, tag, ((SummaryTree)tag).getSummary(),\n-                writer.isFirstSentence);\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/SummaryTaglet.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"deleted"},{"patch":"@@ -1,49 +0,0 @@\n-\/*\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.taglets;\n-\n-import com.sun.source.doctree.DocTree;\n-import com.sun.source.doctree.SystemPropertyTree;\n-import jdk.javadoc.doclet.Taglet.Location;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-\n-import javax.lang.model.element.Element;\n-import java.util.EnumSet;\n-\n-\/**\n- * A taglet that represents the {@code @systemProperty} tag.\n- *\/\n-public class SystemPropertyTaglet extends BaseTaglet {\n-\n-    SystemPropertyTaglet() {\n-        super(DocTree.Kind.SYSTEM_PROPERTY, true, EnumSet.allOf(Location.class));\n-    }\n-\n-    @Override\n-    public Content getInlineTagOutput(Element element, DocTree tag, TagletWriter writer) {\n-        return writer.systemPropertyTagOutput(element, (SystemPropertyTree) tag);\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/SystemPropertyTaglet.java","additions":0,"deletions":49,"binary":false,"changes":49,"status":"deleted"},{"patch":"@@ -1,160 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.taglets;\n-\n-import java.util.Set;\n-import javax.lang.model.element.Element;\n-\n-import com.sun.source.doctree.DocTree;\n-import jdk.javadoc.doclet.Taglet.Location;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-\n-\/**\n- * This is the taglet interface used internally within the doclet.\n- *\/\n-public interface Taglet {\n-    \/**\n-     * Returns the set of allowed locations for a block tag handled by this taglet.\n-     *\n-     * @return the set of allowable locations\n-     *\/\n-    Set<Location> getAllowedLocations();\n-\n-    \/**\n-     * Indicates whether this {@code Taglet} can be used in field documentation.\n-     *\n-     * @return {@code true} if this {@code Taglet} can be used in field documentation\n-     *         and {@code false} otherwise\n-     *\/\n-    boolean inField();\n-\n-    \/**\n-     * Indicates whether this {@code Taglet} can be used in constructor documentation.\n-     *\n-     * @return {@code true} if this {@code Taglet} can be used in constructor documentation\n-     *         and {@code false} otherwise\n-     *\/\n-    boolean inConstructor();\n-\n-    \/**\n-     * Indicates whether this {@code Taglet} can be used in method documentation.\n-     *\n-     * @return {@code true} if this {@code Taglet} can be used in method documentation\n-     *         and {@code false} otherwise\n-     *\/\n-    boolean inMethod();\n-\n-    \/**\n-     * Indicates whether this {@code Taglet} can be used in overview documentation.\n-     *\n-     * @return {@code true} if this {@code Taglet} can be used in overview documentation\n-     *         and {@code false} otherwise\n-     *\/\n-    boolean inOverview();\n-\n-    \/**\n-     * Indicates whether this {@code Taglet} can be used in module documentation.\n-     *\n-     * @return {@code true} if this {@code Taglet} can be used in module documentation\n-     *         and {@code false} otherwise\n-     *\/\n-    boolean inModule();\n-\n-    \/**\n-     * Indicates whether this {@code Taglet} can be used in package documentation.\n-     *\n-     * @return {@code true} if this {@code Taglet} can be used in package documentation\n-     *         and {@code false} otherwise\n-     *\/\n-    boolean inPackage();\n-\n-    \/**\n-     * Indicates whether this {@code Taglet} can be used in type documentation (classes or interfaces).\n-     *\n-     * @return {@code true} if this {@code Taglet} can be used in type documentation\n-     *         and {@code false} otherwise\n-     *\/\n-    boolean inType();\n-\n-    \/**\n-     * Indicates whether this {@code Taglet} represents an inline tag.\n-     *\n-     * @return {@code true} if this {@code Taglet} represents an inline tag\n-     *         and {@code false} otherwise\n-     *\/\n-    boolean isInlineTag();\n-\n-    \/**\n-     * Indicates whether this {@code Taglet} represents a block tag.\n-     *\n-     * @return {@code true} if this {@code Taglet} represents a block tag\n-     * @implSpec This implementation returns the inverse\n-     * result to {@code isInlineTag}.\n-     *\/\n-    default boolean isBlockTag() {\n-        return !isInlineTag();\n-    }\n-\n-    \/**\n-     * Returns the name of this tag.\n-     * @return the name of this tag\n-     *\/\n-    String getName();\n-\n-    \/**\n-     * Returns the content to be included in the generated output for an\n-     * instance of an inline tag handled by this taglet.\n-     *\n-     * @param owner  the element for the enclosing doc comment\n-     * @param tag    the tag\n-     * @param writer the taglet-writer used in this doclet\n-     *\n-     * @return the output for this tag\n-     * @throws UnsupportedTagletOperationException if the method is not supported by the taglet\n-     *\/\n-    Content getInlineTagOutput(Element owner, DocTree tag, TagletWriter writer) throws\n-            UnsupportedTagletOperationException;\n-\n-    \/**\n-     * Returns the content to be included in the generated output for\n-     * all instances of block tags handled by this taglet.\n-     *\n-     * @param owner  the element for the enclosing doc comment\n-     * @param writer the taglet-writer used in this doclet\n-     *\n-     * @return the output for this tag\n-     * @throws UnsupportedTagletOperationException if the method is not supported by the taglet\n-     *\/\n-    Content getAllBlockTagOutput(Element owner, TagletWriter writer) throws\n-            UnsupportedTagletOperationException;\n-\n-    class UnsupportedTagletOperationException extends UnsupportedOperationException {\n-        private static final long serialVersionUID = -3530273193380250271L;\n-        public UnsupportedTagletOperationException(String message) {\n-            super(message);\n-        }\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/Taglet.java","additions":0,"deletions":160,"binary":false,"changes":160,"status":"deleted"},{"patch":"@@ -1,742 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.taglets;\n-\n-import java.io.File;\n-import java.io.IOException;\n-import java.io.PrintStream;\n-import java.util.ArrayList;\n-import java.util.EnumMap;\n-import java.util.EnumSet;\n-import java.util.HashSet;\n-import java.util.LinkedHashMap;\n-import java.util.LinkedHashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.ServiceLoader;\n-import java.util.Set;\n-import java.util.TreeMap;\n-\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.ExecutableElement;\n-import javax.lang.model.element.ModuleElement;\n-import javax.lang.model.element.PackageElement;\n-import javax.lang.model.element.TypeElement;\n-import javax.lang.model.element.VariableElement;\n-import javax.lang.model.util.SimpleElementVisitor14;\n-import javax.tools.JavaFileManager;\n-import javax.tools.StandardJavaFileManager;\n-\n-import com.sun.source.doctree.DocTree;\n-\n-import jdk.javadoc.doclet.Doclet;\n-import jdk.javadoc.doclet.DocletEnvironment;\n-import jdk.javadoc.doclet.Taglet.Location;\n-import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n-import jdk.javadoc.internal.doclets.toolkit.BaseOptions;\n-import jdk.javadoc.internal.doclets.toolkit.DocletElement;\n-import jdk.javadoc.internal.doclets.toolkit.Messages;\n-import jdk.javadoc.internal.doclets.toolkit.Resources;\n-import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;\n-import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n-\n-import static com.sun.source.doctree.DocTree.Kind.AUTHOR;\n-import static com.sun.source.doctree.DocTree.Kind.EXCEPTION;\n-import static com.sun.source.doctree.DocTree.Kind.HIDDEN;\n-import static com.sun.source.doctree.DocTree.Kind.LINK;\n-import static com.sun.source.doctree.DocTree.Kind.LINK_PLAIN;\n-import static com.sun.source.doctree.DocTree.Kind.PARAM;\n-import static com.sun.source.doctree.DocTree.Kind.PROVIDES;\n-import static com.sun.source.doctree.DocTree.Kind.SEE;\n-import static com.sun.source.doctree.DocTree.Kind.SERIAL;\n-import static com.sun.source.doctree.DocTree.Kind.SERIAL_DATA;\n-import static com.sun.source.doctree.DocTree.Kind.SERIAL_FIELD;\n-import static com.sun.source.doctree.DocTree.Kind.SINCE;\n-import static com.sun.source.doctree.DocTree.Kind.THROWS;\n-import static com.sun.source.doctree.DocTree.Kind.USES;\n-import static com.sun.source.doctree.DocTree.Kind.VERSION;\n-import static javax.tools.DocumentationTool.Location.TAGLET_PATH;\n-\n-\/**\n- * Manages the {@code Taglet}s used by doclets.\n- *\/\n-public class TagletManager {\n-\n-    \/**\n-     * All taglets, keyed either by their {@link Taglet#getName() name},\n-     * or by an alias.\n-     *\n-     * In general, taglets do <i>not<\/i> provide aliases;\n-     * the one instance that does is {@code ThrowsTaglet}, which handles\n-     * both {@code @throws} tags and {@code @exception} tags.\n-     *\/\n-    private final LinkedHashMap<String, Taglet> allTaglets;\n-\n-    \/**\n-     * Block (non-inline) taglets, grouped by {@link Location location}.\n-     *\/\n-    private Map<Location, List<Taglet>> blockTagletsByLocation;\n-\n-    \/**\n-     * The taglets that can appear inline in descriptive text.\n-     *\/\n-    private Map<String, Taglet> inlineTags;\n-\n-    \/**\n-     * The taglets that can appear in the serialized form.\n-     *\/\n-    private List<Taglet> serializedFormTags;\n-\n-    private final DocletEnvironment docEnv;\n-    private final Doclet doclet;\n-\n-    private final Utils utils;\n-    private final Messages messages;\n-    private final Resources resources;\n-\n-    \/**\n-     * Keep track of standard tags.\n-     *\/\n-    private final Set<String> standardTags;\n-\n-    \/**\n-     * Keep track of standard tags in lowercase to compare for better\n-     * error messages when a tag like {@code @docRoot} is mistakenly spelled\n-     * lowercase {@code @docroot}.\n-     *\/\n-    private final Set<String> standardTagsLowercase;\n-\n-    \/**\n-     * Keep track of overridden standard tags.\n-     *\/\n-    private final Set<String> overriddenStandardTags;\n-\n-    \/**\n-     * Keep track of the tags that may conflict\n-     * with standard tags in the future (any custom tag without\n-     * a period in its name).\n-     *\/\n-    private final Set<String> potentiallyConflictingTags;\n-\n-    \/**\n-     * The set of unseen custom tags.\n-     *\/\n-    private final Set<String> unseenCustomTags;\n-\n-    \/**\n-     * True if we do not want to use {@code @since} tags.\n-     *\/\n-    private final boolean nosince;\n-\n-    \/**\n-     * True if we want to use {@code @version} tags.\n-     *\/\n-    private final boolean showversion;\n-\n-    \/**\n-     * True if we want to use {@code @author} tags.\n-     *\/\n-    private final boolean showauthor;\n-\n-    \/**\n-     * True if we want to use JavaFX-related tags ({@code @defaultValue}, {@code @treatAsPrivate}).\n-     *\/\n-    private final boolean javafx;\n-\n-    \/**\n-     * Show the taglets table when it has been initialized.\n-     *\/\n-    private final boolean showTaglets;\n-\n-    private final String tagletPath;\n-\n-    private final BaseConfiguration configuration;\n-\n-    \/**\n-     * Constructs a new {@code TagletManager}.\n-     *\n-     * @param configuration the configuration for this taglet manager\n-     *\/\n-    public TagletManager(BaseConfiguration configuration) {\n-        overriddenStandardTags = new HashSet<>();\n-        potentiallyConflictingTags = new HashSet<>();\n-        standardTags = new HashSet<>();\n-        standardTagsLowercase = new HashSet<>();\n-        unseenCustomTags = new HashSet<>();\n-        allTaglets = new LinkedHashMap<>();\n-        this.configuration = configuration;\n-        BaseOptions options = configuration.getOptions();\n-        this.nosince = options.noSince();\n-        this.showversion = options.showVersion();\n-        this.showauthor = options.showAuthor();\n-        this.javafx = options.javafx();\n-        this.docEnv = configuration.docEnv;\n-        this.doclet = configuration.doclet;\n-        this.messages = configuration.getMessages();\n-        this.resources = configuration.getDocResources();\n-        this.showTaglets = options.showTaglets();\n-        this.utils = configuration.utils;\n-        this.tagletPath = options.tagletPath();\n-        initStandardTaglets();\n-    }\n-\n-    public Set<String> getAllTagletNames() {\n-        return allTaglets.keySet();\n-    }\n-\n-    \/**\n-     * Initializes the location TAGLET_PATH which is used to locate the custom taglets.\n-     *\n-     * @param fileManager the file manager to load classes and resources\n-     * @throws IOException if an error occurs while setting the location\n-     *\/\n-    public void initTagletPath(JavaFileManager fileManager) throws IOException {\n-        if (fileManager instanceof StandardJavaFileManager sfm) {\n-            if (tagletPath != null) {\n-                List<File> paths = new ArrayList<>();\n-                for (String pathname : tagletPath.split(File.pathSeparator)) {\n-                    paths.add(new File(pathname));\n-                }\n-                sfm.setLocation(TAGLET_PATH, paths);\n-            } else if (!sfm.hasLocation(TAGLET_PATH)) {\n-                sfm.setLocation(TAGLET_PATH, List.of());\n-            }\n-        } else if (tagletPath != null) {\n-            messages.error(\"doclet.not_standard_file_manager\");\n-        }\n-    }\n-\n-    \/**\n-     * Adds a new {@code Taglet}.\n-     *\n-     * Prints a message to indicate whether or not the Taglet was registered properly.\n-     *\n-     * @param classname  the name of the class representing the custom tag\n-     * @param fileManager the file manager to load classes and resources\n-     *\/\n-    public void addCustomTag(String classname, JavaFileManager fileManager) {\n-        ClassLoader tagClassLoader = fileManager.getClassLoader(TAGLET_PATH);\n-        if (configuration.workArounds.accessInternalAPI()) {\n-            Module thisModule = getClass().getModule();\n-            Module tagletLoaderUnnamedModule = tagClassLoader.getUnnamedModule();\n-            List<String> pkgs = List.of(\n-                    \"jdk.javadoc.doclet\",\n-                    \"jdk.javadoc.internal.doclets.toolkit\",\n-                    \"jdk.javadoc.internal.doclets.formats.html\");\n-            pkgs.forEach(p -> thisModule.addOpens(p, tagletLoaderUnnamedModule));\n-        }\n-        try {\n-            Class<? extends jdk.javadoc.doclet.Taglet> customTagClass =\n-                    tagClassLoader.loadClass(classname).asSubclass(jdk.javadoc.doclet.Taglet.class);\n-            jdk.javadoc.doclet.Taglet instance = customTagClass.getConstructor().newInstance();\n-            registerTaglet(instance);\n-        } catch (ReflectiveOperationException | ExceptionInInitializerError | ClassCastException exc) {\n-            messages.error(\"doclet.Error_taglet_not_registered\", exc.getClass().getName(),\n-                    classname);\n-        }\n-    }\n-\n-    \/**\n-     * Loads taglets from a taglet path using the service loader.\n-     *\n-     * @param fileManager the file manager to load the taglets\n-     * @throws IOException if an error occurs while getting the service loader\n-     *\/\n-    public void loadTaglets(JavaFileManager fileManager) throws IOException {\n-        Iterable<? extends File> location = ((StandardJavaFileManager) fileManager).getLocation(TAGLET_PATH);\n-        if (location != null && location.iterator().hasNext()) {\n-            ServiceLoader<jdk.javadoc.doclet.Taglet> serviceLoader =\n-                    fileManager.getServiceLoader(TAGLET_PATH, jdk.javadoc.doclet.Taglet.class);\n-            for (jdk.javadoc.doclet.Taglet taglet : serviceLoader) {\n-                registerTaglet(taglet);\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Registers the {@code Taglet}.\n-     *\n-     * Prints a message if the {@code Taglet} got registered properly.\n-     *\n-     * @param instance the {@code Taglet} instance\n-     *\/\n-    private void registerTaglet(jdk.javadoc.doclet.Taglet instance) {\n-        instance.init(docEnv, doclet);\n-        Taglet newLegacy = new UserTaglet(instance);\n-        allTaglets.put(newLegacy.getName(), newLegacy);\n-        messages.notice(\"doclet.Notice_taglet_registered\", instance.getClass().getName());\n-    }\n-\n-    \/**\n-     * Adds a new {@code SimpleTaglet}.\n-     *\n-     * If this tag already exists and the header passed as an argument is {@code null},\n-     * move tag to the back of the list. If this tag already exists and the\n-     * header passed as an argument is not {@code null}, overwrite previous tag\n-     * with the new one. Otherwise, add a new SimpleTaglet to the list.\n-     *\n-     * @param tagName the name of this tag\n-     * @param header the header to output\n-     * @param locations the possible locations that this tag can appear in\n-     *\/\n-    public void addNewSimpleCustomTag(String tagName, String header, String locations) {\n-        if (tagName == null || locations == null) {\n-            return;\n-        }\n-        \/\/ remove + put in both branches below move the tag to the back of the map's ordering\n-        Taglet tag = allTaglets.remove(tagName);\n-        if (tag == null || header != null) {\n-            allTaglets.put(tagName, new SimpleTaglet(tagName, header, locations));\n-            if (Utils.toLowerCase(locations).indexOf('x') == -1) {\n-                checkTagName(tagName);\n-            }\n-        } else {\n-            \/\/ Move existing tag to the back\n-            allTaglets.put(tagName, tag);\n-        }\n-    }\n-\n-    \/**\n-     * Given a tag name, add it to the set of tags it belongs to.\n-     *\/\n-    private void checkTagName(String name) {\n-        if (standardTags.contains(name)) {\n-            overriddenStandardTags.add(name);\n-        } else {\n-            if (name.indexOf('.') == -1) {\n-                potentiallyConflictingTags.add(name);\n-            }\n-            unseenCustomTags.add(name);\n-        }\n-    }\n-\n-    \/**\n-     * Reports that a tag was seen in a doc comment.\n-     * It is removed from the list of custom tags that have not yet been seen.\n-     *\n-     * @param name the name of the tag\n-     *\/\n-    void seenTag(String name) {\n-        unseenCustomTags.remove(name);\n-    }\n-\n-    \/**\n-     * Given a series of {@code DocTree}s, check for misuse and spelling mistakes.\n-     *\n-     * @param element the tags holder\n-     * @param trees the trees containing the comments\n-     *\/\n-    public void checkTags(Element element, Iterable<? extends DocTree> trees) {\n-        CommentHelper ch = utils.getCommentHelper(element);\n-        for (DocTree tag : trees) {\n-            String name = tag.getKind().tagName;\n-            if (name == null) {\n-                continue;\n-            }\n-            if (!name.isEmpty() && name.charAt(0) == '@') {\n-                name = name.substring(1);\n-            }\n-            if (! (standardTags.contains(name) || allTaglets.containsKey(name))) {\n-                if (standardTagsLowercase.contains(Utils.toLowerCase(name))) {\n-                    messages.warning(ch.getDocTreePath(tag), \"doclet.UnknownTagLowercase\", ch.getTagName(tag));\n-                    continue;\n-                } else {\n-                    messages.warning(ch.getDocTreePath(tag), \"doclet.UnknownTag\", ch.getTagName(tag));\n-                    continue;\n-                }\n-            }\n-            final Taglet taglet = allTaglets.get(name);\n-            \/\/ Check and verify tag usage\n-            if (taglet != null) {\n-                if (taglet instanceof SimpleTaglet st && !st.enabled) {\n-                    \/\/ taglet has been disabled\n-                    return;\n-                }\n-\n-                new SimpleElementVisitor14<Void, Void>() {\n-                    @Override\n-                    public Void visitModule(ModuleElement e, Void p) {\n-                        if (!taglet.inModule()) {\n-                            printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, \"module\");\n-                        }\n-                        return null;\n-                    }\n-\n-                    @Override\n-                    public Void visitPackage(PackageElement e, Void p) {\n-                        if (!taglet.inPackage()) {\n-                            printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, \"package\");\n-                        }\n-                        return null;\n-                    }\n-\n-                    @Override\n-                    public Void visitType(TypeElement e, Void p) {\n-                        if (!taglet.inType()) {\n-                            printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, \"class\");\n-                        }\n-                        return null;\n-                    }\n-\n-                    @Override\n-                    public Void visitExecutable(ExecutableElement e, Void p) {\n-                        if (utils.isConstructor(e) && !taglet.inConstructor()) {\n-                            printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, \"constructor\");\n-                        } else if (!taglet.inMethod()) {\n-                            printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, \"method\");\n-                        }\n-                        return null;\n-                    }\n-\n-                    @Override\n-                    public Void visitVariable(VariableElement e, Void p) {\n-                        if (utils.isField(e) && !taglet.inField()) {\n-                            printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, \"field\");\n-                        }\n-                        return null;\n-                    }\n-\n-                    @Override\n-                    public Void visitUnknown(Element e, Void p) {\n-                        if (utils.isOverviewElement(e) && !taglet.inOverview()) {\n-                            printTagMisuseWarn(utils.getCommentHelper(e), taglet, tag, \"overview\");\n-                        }\n-                        return null;\n-                    }\n-\n-                    @Override\n-                    protected Void defaultAction(Element e, Void p) {\n-                        return null;\n-                    }\n-                }.visit(element);\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Given the taglet, the tag and the type of documentation that the tag\n-     * was found in, print a tag misuse warning.\n-     *\n-     * @param taglet the taglet representing the misused tag\n-     * @param tag the misused tag\n-     * @param holderType the type of documentation that the misused tag was found in\n-     *\/\n-    private void printTagMisuseWarn(CommentHelper ch, Taglet taglet, DocTree tag, String holderType) {\n-        Set<String> locationsSet = new LinkedHashSet<>();\n-        \/\/ The following names should be localized\n-        if (taglet.inOverview()) {\n-            locationsSet.add(\"overview\");\n-        }\n-        if (taglet.inModule()) {\n-            locationsSet.add(\"module\");\n-        }\n-        if (taglet.inPackage()) {\n-            locationsSet.add(\"package\");\n-        }\n-        if (taglet.inType()) {\n-            locationsSet.add(\"class\/interface\");\n-        }\n-        if (taglet.inConstructor())  {\n-            locationsSet.add(\"constructor\");\n-        }\n-        if (taglet.inField()) {\n-            locationsSet.add(\"field\");\n-        }\n-        if (taglet.inMethod()) {\n-            locationsSet.add(\"method\");\n-        }\n-        if (locationsSet.isEmpty()) {\n-            \/\/This known tag is excluded.\n-            return;\n-        }\n-        var combined_locations = String.join(\", \", locationsSet);\n-        messages.warning(ch.getDocTreePath(tag), \"doclet.tag_misuse\",\n-            \"@\" + taglet.getName(), holderType, combined_locations);\n-    }\n-\n-    \/**\n-     * Returns the taglets that can appear inline, in descriptive text.\n-     * @return the taglets that can appear inline\n-     *\/\n-    Map<String, Taglet> getInlineTaglets() {\n-        if (inlineTags == null) {\n-            initTaglets();\n-        }\n-        return inlineTags;\n-    }\n-\n-    \/**\n-     * Returns the taglets that can appear in the serialized form.\n-     * @return the taglet that can appear in the serialized form\n-     *\/\n-    public List<Taglet> getSerializedFormTaglets() {\n-        if (serializedFormTags == null) {\n-            initTaglets();\n-        }\n-        return serializedFormTags;\n-    }\n-\n-    \/**\n-     * Returns the custom tags for a given element.\n-     *\n-     * @param e the element to get custom tags for\n-     * @return the array of {@code Taglet}s that can\n-     * appear in the given element\n-     *\/\n-    @SuppressWarnings(\"fallthrough\")\n-    public List<Taglet> getBlockTaglets(Element e) {\n-        if (blockTagletsByLocation == null) {\n-            initTaglets();\n-        }\n-\n-        switch (e.getKind()) {\n-            case CONSTRUCTOR:\n-                return blockTagletsByLocation.get(Location.CONSTRUCTOR);\n-            case METHOD:\n-                return blockTagletsByLocation.get(Location.METHOD);\n-            case ENUM_CONSTANT:\n-            case FIELD:\n-                return blockTagletsByLocation.get(Location.FIELD);\n-            case ANNOTATION_TYPE:\n-            case INTERFACE:\n-            case CLASS:\n-            case ENUM:\n-            case RECORD:\n-                return blockTagletsByLocation.get(Location.TYPE);\n-            case MODULE:\n-                return blockTagletsByLocation.get(Location.MODULE);\n-            case PACKAGE:\n-                return blockTagletsByLocation.get(Location.PACKAGE);\n-            case OTHER:\n-                if (e instanceof DocletElement de) {\n-                    switch (de.getSubKind()) {\n-                        case DOCFILE:\n-                            return blockTagletsByLocation.get(Location.PACKAGE);\n-                        case OVERVIEW:\n-                            return blockTagletsByLocation.get(Location.OVERVIEW);\n-                        default:\n-                            \/\/ fall through\n-                    }\n-                }\n-                \/\/ fall through\n-            default:\n-                throw new AssertionError(\"unknown element: \" + e + \" ,kind: \" + e.getKind());\n-        }\n-    }\n-\n-    \/**\n-     * Initialize the tag collections.\n-     *\/\n-    private void initTaglets() {\n-\n-        blockTagletsByLocation = new EnumMap<>(Location.class);\n-        for (Location site : Location.values()) {\n-            blockTagletsByLocation.put(site, new ArrayList<>());\n-        }\n-\n-        inlineTags = new LinkedHashMap<>();\n-\n-        allTaglets.forEach((name, t) -> {\n-            if (t.isInlineTag()) {\n-                inlineTags.put(t.getName(), t);\n-            }\n-\n-            if (t.isBlockTag() && t.getName().equals(name)) {\n-                t.getAllowedLocations().forEach(l -> blockTagletsByLocation.get(l).add(t));\n-            }\n-        });\n-\n-        \/\/ init the serialized form tags for the serialized form page\n-        serializedFormTags = new ArrayList<>();\n-        serializedFormTags.add(allTaglets.get(SERIAL_DATA.tagName));\n-        serializedFormTags.add(allTaglets.get(PARAM.tagName));\n-        serializedFormTags.add(allTaglets.get(THROWS.tagName));\n-        if (!nosince)\n-            serializedFormTags.add(allTaglets.get(SINCE.tagName));\n-        serializedFormTags.add(allTaglets.get(SEE.tagName));\n-\n-        if (showTaglets) {\n-            showTaglets(System.out);\n-        }\n-    }\n-\n-    \/**\n-     * Initialize standard Javadoc tags for ordering purposes.\n-     *\/\n-    private void initStandardTaglets() {\n-        if (javafx) {\n-            initJavaFXTaglets();\n-        }\n-\n-        addStandardTaglet(new ParamTaglet());\n-        addStandardTaglet(new ReturnTaglet());\n-        addStandardTaglet(new ThrowsTaglet(configuration), EXCEPTION);\n-        addStandardTaglet(\n-                new SimpleTaglet(SINCE, resources.getText(\"doclet.Since\"),\n-                    EnumSet.allOf(Location.class), !nosince));\n-        addStandardTaglet(\n-                new SimpleTaglet(VERSION, resources.getText(\"doclet.Version\"),\n-                    EnumSet.of(Location.OVERVIEW, Location.MODULE, Location.PACKAGE, Location.TYPE), showversion));\n-        addStandardTaglet(\n-                new SimpleTaglet(AUTHOR, resources.getText(\"doclet.Author\"),\n-                    EnumSet.of(Location.OVERVIEW, Location.MODULE, Location.PACKAGE, Location.TYPE), showauthor));\n-        addStandardTaglet(\n-                new SimpleTaglet(SERIAL_DATA, resources.getText(\"doclet.SerialData\"),\n-                    EnumSet.noneOf(Location.class)));\n-        addStandardTaglet(\n-                new SimpleTaglet(HIDDEN, null,\n-                    EnumSet.of(Location.TYPE, Location.METHOD, Location.FIELD)));\n-\n-        \/\/ This appears to be a default custom (non-standard) taglet\n-        Taglet factoryTaglet = new SimpleTaglet(\"factory\", resources.getText(\"doclet.Factory\"),\n-                EnumSet.of(Location.METHOD));\n-        allTaglets.put(factoryTaglet.getName(), factoryTaglet);\n-\n-        addStandardTaglet(new SeeTaglet());\n-        addStandardTaglet(new SpecTaglet());\n-\n-        \/\/ Standard inline tags\n-        addStandardTaglet(new DocRootTaglet());\n-        addStandardTaglet(new InheritDocTaglet());\n-        addStandardTaglet(new ValueTaglet());\n-        addStandardTaglet(new LiteralTaglet());\n-        addStandardTaglet(new CodeTaglet());\n-        addStandardTaglet(new SnippetTaglet());\n-        addStandardTaglet(new IndexTaglet());\n-        addStandardTaglet(new SummaryTaglet());\n-        addStandardTaglet(new SystemPropertyTaglet());\n-\n-        \/\/ Keep track of the names of standard tags for error checking purposes.\n-        \/\/ The following are not handled above.\n-        addStandardTaglet(new DeprecatedTaglet());\n-        addStandardTaglet(new BaseTaglet(LINK, true, EnumSet.allOf(Location.class)));\n-        addStandardTaglet(new BaseTaglet(LINK_PLAIN, true, EnumSet.allOf(Location.class)));\n-        addStandardTaglet(new BaseTaglet(USES, false, EnumSet.of(Location.MODULE)));\n-        addStandardTaglet(new BaseTaglet(PROVIDES, false, EnumSet.of(Location.MODULE)));\n-        addStandardTaglet(\n-                new SimpleTaglet(SERIAL, null,\n-                    EnumSet.of(Location.PACKAGE, Location.TYPE, Location.FIELD)));\n-        addStandardTaglet(\n-                new SimpleTaglet(SERIAL_FIELD, null, EnumSet.of(Location.FIELD)));\n-    }\n-\n-    \/**\n-     * Initialize JavaFX-related tags.\n-     *\/\n-    private void initJavaFXTaglets() {\n-        addStandardTaglet(new SimpleTaglet(\"propertyDescription\",\n-                resources.getText(\"doclet.PropertyDescription\"),\n-                EnumSet.of(Location.METHOD, Location.FIELD)));\n-        addStandardTaglet(new SimpleTaglet(\"defaultValue\", resources.getText(\"doclet.DefaultValue\"),\n-                EnumSet.of(Location.METHOD, Location.FIELD)));\n-        addStandardTaglet(new SimpleTaglet(\"treatAsPrivate\", null,\n-                EnumSet.of(Location.TYPE, Location.METHOD, Location.FIELD)));\n-    }\n-\n-    private void addStandardTaglet(Taglet taglet) {\n-        String name = taglet.getName();\n-        allTaglets.put(name, taglet);\n-        standardTags.add(name);\n-        standardTagsLowercase.add(Utils.toLowerCase(name));\n-    }\n-\n-    private void addStandardTaglet(Taglet taglet, DocTree.Kind alias) {\n-        addStandardTaglet(taglet);\n-        String name = alias.tagName;\n-        allTaglets.put(name, taglet);\n-        standardTags.add(name);\n-        standardTagsLowercase.add(Utils.toLowerCase(name));\n-    }\n-\n-    public boolean isKnownCustomTag(String tagName) {\n-        return allTaglets.containsKey(tagName);\n-    }\n-\n-    \/**\n-     * Print a list of {@link Taglet}s that might conflict with\n-     * standard tags in the future and a list of standard tags\n-     * that have been overridden.\n-     *\/\n-    public void printReport() {\n-        printReportHelper(\"doclet.Notice_taglet_conflict_warn\", potentiallyConflictingTags);\n-        printReportHelper(\"doclet.Notice_taglet_overridden\", overriddenStandardTags);\n-        printReportHelper(\"doclet.Notice_taglet_unseen\", unseenCustomTags);\n-    }\n-\n-    private void printReportHelper(String noticeKey, Set<String> names) {\n-        if (!names.isEmpty()) {\n-            StringBuilder result = new StringBuilder();\n-            for (String name : names) {\n-                result.append(result.length() == 0 ? \" \" : \", \");\n-                result.append(\"@\").append(name);\n-            }\n-            messages.notice(noticeKey, result);\n-        }\n-    }\n-\n-    \/**\n-     * Given the name of a tag, return the corresponding taglet.\n-     *\n-     * @param name the name of the taglet to retrieve\n-     * @return the corresponding taglet or {@code null} if the tag is unknown\n-     *\/\n-    Taglet getTaglet(String name) {\n-        if (name.indexOf(\"@\") == 0) {\n-            return allTaglets.get(name.substring(1));\n-        } else {\n-            return allTaglets.get(name);\n-        }\n-    }\n-\n-    \/*\n-     * The output of this method is the basis for a table at the end of the\n-     * doc comment specification, so any changes in the output may indicate\n-     * a need for a corresponding update to the spec.\n-     *\/\n-    private void showTaglets(PrintStream out) {\n-        Map<String, Taglet> taglets = new TreeMap<>(allTaglets);\n-\n-        taglets.forEach((n, t) -> {\n-            \/\/ give preference to simpler block form if a tag can be either\n-            String name = t.isBlockTag() ? \"@\" + n : \"{@\" + n + \"}\";\n-            out.println(String.format(\"%20s\", name) + \": \"\n-                    + format(t.isBlockTag(), \"block\")+ \" \"\n-                    + format(t.inOverview(), \"overview\") + \" \"\n-                    + format(t.inModule(), \"module\") + \" \"\n-                    + format(t.inPackage(), \"package\") + \" \"\n-                    + format(t.inType(), \"type\") + \" \"\n-                    + format(t.inConstructor(),\"constructor\") + \" \"\n-                    + format(t.inMethod(), \"method\") + \" \"\n-                    + format(t.inField(), \"field\") + \" \"\n-                    + format(t.isInlineTag(), \"inline\")+ \" \"\n-                    + format((t instanceof SimpleTaglet st) && !st.enabled, \"disabled\"));\n-        });\n-    }\n-\n-    private String format(boolean b, String s) {\n-        return b ? s : \".\".repeat(s.length()); \/\/ \"replace\" all with \".\"\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/TagletManager.java","additions":0,"deletions":742,"binary":false,"changes":742,"status":"deleted"},{"patch":"@@ -1,420 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.taglets;\n-\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.ElementKind;\n-import javax.lang.model.element.TypeElement;\n-import javax.lang.model.element.VariableElement;\n-import javax.lang.model.type.TypeMirror;\n-\n-import com.sun.source.doctree.DocTree;\n-import com.sun.source.doctree.SpecTree;\n-import com.sun.source.doctree.IndexTree;\n-import com.sun.source.doctree.LinkTree;\n-import com.sun.source.doctree.LiteralTree;\n-import com.sun.source.doctree.ParamTree;\n-import com.sun.source.doctree.ReturnTree;\n-import com.sun.source.doctree.SeeTree;\n-import com.sun.source.doctree.SnippetTree;\n-import com.sun.source.doctree.SystemPropertyTree;\n-import com.sun.source.doctree.ThrowsTree;\n-import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.taglets.Taglet.UnsupportedTagletOperationException;\n-import jdk.javadoc.internal.doclets.toolkit.taglets.snippet.StyledText;\n-import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;\n-import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n-\n-\/**\n- * The interface for the taglet writer.\n- *\/\n-public abstract class TagletWriter {\n-\n-    \/**\n-     * True if we only want to write the first sentence.\n-     *\/\n-    protected final boolean isFirstSentence;\n-\n-    protected TagletWriter(boolean isFirstSentence) {\n-        this.isFirstSentence = isFirstSentence;\n-    }\n-\n-    \/**\n-     * Returns an instance of an output object.\n-     *\n-     * @return an instance of an output object\n-     *\/\n-    public abstract Content getOutputInstance();\n-\n-    \/**\n-     * Returns the output for a {@code {@code ...}} tag.\n-     *\n-     * @param element The element that owns the doc comment\n-     * @param tag     the tag\n-     *\n-     * @return the output\n-     *\/\n-    protected abstract Content codeTagOutput(Element element, LiteralTree tag);\n-\n-    \/**\n-     * Returns the output for a {@code {@index...}} tag.\n-     *\n-     * @param element The element that owns the doc comment\n-     * @param tag     the tag\n-     *\n-     * @return the output\n-     *\/\n-    protected abstract Content indexTagOutput(Element element, IndexTree tag);\n-\n-    \/**\n-     * Returns the output for a {@code {@docRoot}} tag.\n-     *\n-     * @return the output\n-     *\/\n-    protected abstract Content getDocRootOutput();\n-\n-    \/**\n-     * Returns the output for a {@code @deprecated} tag.\n-     *\n-     * @param element The element that owns the doc comment\n-     *\n-     * @return the output\n-     *\/\n-    protected abstract Content deprecatedTagOutput(Element element);\n-\n-    \/**\n-     * Returns the output for a {@code {@link ...}} or {@code {@linkplain ...}} tag.\n-     *\n-     * @param element The element that owns the doc comment\n-     * @param tag     the tag\n-     *\n-     * @return the output\n-     *\/\n-    protected abstract Content linkTagOutput(Element element, LinkTree tag);\n-\n-    \/**\n-     * Returns the output for a {@code {@literal ...}} tag.\n-     *\n-     * @param element The element that owns the doc comment\n-     * @param tag     the tag\n-     *\n-     * @return the output\n-     *\/\n-    protected abstract Content literalTagOutput(Element element, LiteralTree tag);\n-\n-    \/**\n-     * Returns the header for the {@code @param} tags.\n-     *\n-     * @param kind the kind of header that is required\n-     *\n-     * @return the header\n-     *\/\n-    protected abstract Content getParamHeader(ParamTaglet.ParamKind kind);\n-\n-    \/**\n-     * Returns the output for a {@code @param} tag.\n-     * Note we cannot rely on the name in the tag, because we might be\n-     * inheriting the tag.\n-     *\n-     * @param element   The element that owns the doc comment\n-     * @param paramTag  the parameter to document\n-     * @param paramName the name of the parameter\n-     *\n-     * @return the output\n-     *\/\n-    protected abstract Content paramTagOutput(Element element, ParamTree paramTag, String paramName);\n-\n-    \/**\n-     * Returns the output for a {@code @return} tag.\n-     *\n-     * @param element   the element that owns the doc comment\n-     * @param returnTag the return tag to document\n-     * @param inline    whether this should be written as an inline instance or block instance\n-     *\n-     * @return the output\n-     *\/\n-    protected abstract Content returnTagOutput(Element element, ReturnTree returnTag, boolean inline);\n-\n-    \/**\n-     * Returns the output for {@code @see} tags.\n-     *\n-     * @param element The element that owns the doc comment\n-     * @param seeTags the list of tags\n-     *\n-     * @return the output\n-     *\/\n-    protected abstract Content seeTagOutput(Element element, List<? extends SeeTree> seeTags);\n-\n-    \/**\n-     * Returns the output for a series of simple tags.\n-     *\n-     * @param element    The element that owns the doc comment\n-     * @param simpleTags the list of simple tags\n-     * @param header     the header for the series of tags\n-     *\n-     * @return the output\n-     *\/\n-    protected abstract Content simpleBlockTagOutput(Element element, List<? extends DocTree> simpleTags, String header);\n-\n-    \/**\n-     * Returns the output for a {@code {@snippet ...}} tag.\n-     *\n-     * @param element    The element that owns the doc comment\n-     * @param snippetTag the snippet tag\n-     * @param id         the value of the id attribute, or null if not defined\n-     * @param lang       the value of the lang attribute, or null if not defined\n-     *\n-     * @return the output\n-     *\/\n-    protected abstract Content snippetTagOutput(Element element, SnippetTree snippetTag, StyledText text,\n-                                                String id, String lang);\n-\n-    \/**\n-     * Returns the output for one or more {@code @spec} tags.\n-     *\n-     * @param element  the element that owns the doc comment\n-     * @param specTags the array of @spec tags.\n-     *\n-     * @return the output\n-     *\/\n-    protected abstract Content specTagOutput(Element element, List<? extends SpecTree> specTags);\n-\n-    \/**\n-     * Returns the output for a {@code {@systemProperty...}} tag.\n-     *\n-     * @param element           the element that owns the doc comment\n-     * @param systemPropertyTag the system property tag\n-     *\n-     * @return the output\n-     *\/\n-    protected abstract Content systemPropertyTagOutput(Element element, SystemPropertyTree systemPropertyTag);\n-\n-    \/**\n-     * Returns the header for the {@code @throws} tag.\n-     *\n-     * @return the header for the throws tag\n-     *\/\n-    protected abstract Content getThrowsHeader();\n-\n-    \/**\n-     * Returns the output for a default {@code @throws} tag.\n-     *\n-     * @param throwsType the type that is thrown\n-     * @param content    the optional content to add as a description\n-     *\n-     * @return the output\n-     *\/\n-    protected abstract Content throwsTagOutput(TypeMirror throwsType, Optional<Content> content);\n-\n-    \/**\n-     * Returns the output for a {@code {@value}} tag.\n-     *\n-     * @param field       the constant field that holds the value tag\n-     * @param constantVal the constant value to document\n-     * @param includeLink true if we should link the constant text to the\n-     *                    constant field itself\n-     *\n-     * @return the output\n-     *\/\n-    protected abstract Content valueTagOutput(VariableElement field,\n-        String constantVal, boolean includeLink);\n-\n-    \/**\n-     * Returns the output for an invalid tag. The returned content uses special styling to\n-     * highlight the problem. Depending on the presence of the {@code detail} string the method\n-     * returns a plain text span or an expandable component.\n-     *\n-     * @param summary the single-line summary message\n-     * @param detail the optional detail message which may contain preformatted text\n-     * @return the output\n-     *\/\n-    protected abstract Content invalidTagOutput(String summary, Optional<String> detail);\n-\n-    \/**\n-     * Returns the main type element of the current page or null for pages that don't have one.\n-     *\n-     * @return the type element of the current page or null.\n-     *\/\n-    protected abstract TypeElement getCurrentPageElement();\n-\n-    \/**\n-     * Returns the content generated from the block tags for a given element.\n-     * The content is generated according to the order of the list of taglets.\n-     * The result is a possibly-empty list of the output generated by each\n-     * of the given taglets for all of the tags they individually support.\n-     *\n-     * @param tagletManager the manager that manages the taglets\n-     * @param element       the element that we are to write tags for\n-     * @param taglets       the taglets for the tags to write\n-     *\n-     * @return the content\n-     *\/\n-    public Content getBlockTagOutput(TagletManager tagletManager,\n-                                    Element element,\n-                                    List<Taglet> taglets) {\n-        for (Taglet t : taglets) {\n-            if (!t.isBlockTag()) {\n-                throw new IllegalArgumentException(t.getName());\n-            }\n-        }\n-\n-        Content output = getOutputInstance();\n-        Utils utils = configuration().utils;\n-        tagletManager.checkTags(element, utils.getBlockTags(element));\n-        tagletManager.checkTags(element, utils.getFullBody(element));\n-        for (Taglet taglet : taglets) {\n-            if (utils.isTypeElement(element) && taglet instanceof ParamTaglet) {\n-                \/\/ The type parameters and state components are documented in a special\n-                \/\/ section away from the tag info, so skip here.\n-                continue;\n-            }\n-\n-            if (element.getKind() == ElementKind.MODULE && taglet instanceof BaseTaglet t) {\n-                switch (t.getTagKind()) {\n-                    \/\/ @uses and @provides are handled separately, so skip here.\n-                    \/\/ See ModuleWriterImpl.computeModulesData\n-                    case USES:\n-                    case PROVIDES:\n-                        continue;\n-                }\n-            }\n-\n-            if (taglet instanceof DeprecatedTaglet) {\n-                \/\/Deprecated information is documented \"inline\", not in tag info\n-                \/\/section.\n-                continue;\n-            }\n-\n-            if (taglet instanceof SimpleTaglet st && !st.enabled) {\n-                \/\/ taglet has been disabled\n-                continue;\n-            }\n-\n-            try {\n-                Content tagletOutput = taglet.getAllBlockTagOutput(element, this);\n-                if (tagletOutput != null) {\n-                    tagletManager.seenTag(taglet.getName());\n-                    output.add(tagletOutput);\n-                }\n-            } catch (UnsupportedTagletOperationException e) {\n-                \/\/ malformed taglet:\n-                \/\/ claims to support block tags (see Taglet.isBlockTag) but does not provide the\n-                \/\/ appropriate method, Taglet.getAllBlockTagOutput.\n-            }\n-        }\n-        return output;\n-    }\n-\n-    \/**\n-     * Returns the content generated from an inline tag in the doc comment for a given element,\n-     * or {@code null} if the tag is not supported or does not return any output.\n-     *\n-     * @param holder        the element associated with the doc comment\n-     * @param tagletManager the taglet manager for the current doclet\n-     * @param inlineTag     the inline tag to be documented\n-     *\n-     * @return the content, or {@code null}\n-     *\/\n-    public Content getInlineTagOutput(Element holder,\n-                                      TagletManager tagletManager,\n-                                      DocTree inlineTag) {\n-\n-        Map<String, Taglet> inlineTags = tagletManager.getInlineTaglets();\n-        CommentHelper ch = configuration().utils.getCommentHelper(holder);\n-        final String inlineTagName = ch.getTagName(inlineTag);\n-        Taglet t = inlineTags.get(inlineTagName);\n-        if (t == null) {\n-            return null;\n-        }\n-\n-        try {\n-            Content tagletOutput = t.getInlineTagOutput(holder, inlineTag, this);\n-            tagletManager.seenTag(t.getName());\n-            return tagletOutput;\n-        } catch (UnsupportedTagletOperationException e) {\n-            \/\/ malformed taglet:\n-            \/\/ claims to support inline tags (see Taglet.isInlineTag) but does not provide the\n-            \/\/ appropriate method, Taglet.getInlineTagOutput.\n-            return null;\n-        }\n-    }\n-\n-    \/**\n-     * Converts inline tags and text to content, expanding the\n-     * inline tags along the way.  Called wherever text can contain\n-     * an inline tag, such as in comments or in free-form text arguments\n-     * to block tags.\n-     *\n-     * @param holderTree the tree that holds the documentation\n-     * @param trees      list of {@code DocTree} nodes containing text and inline tags (often alternating)\n-     *                   present in the text of interest for this doc\n-     *\n-     * @return the generated content\n-     *\/\n-    public abstract Content commentTagsToOutput(DocTree holderTree, List<? extends DocTree> trees);\n-\n-    \/**\n-     * Converts inline tags and text to content, expanding the\n-     * inline tags along the way.  Called wherever text can contain\n-     * an inline tag, such as in comments or in free-form text arguments\n-     * to block tags.\n-     *\n-     * @param element The element that owns the documentation\n-     * @param trees  list of {@code DocTree} nodes containing text and inline tags (often alternating)\n-     *               present in the text of interest for this doc\n-     *\n-     * @return the generated content\n-     *\/\n-    public abstract Content commentTagsToOutput(Element element, List<? extends DocTree> trees);\n-\n-    \/**\n-     * Converts inline tags and text to content, expanding the\n-     * inline tags along the way.  Called wherever text can contain\n-     * an inline tag, such as in comments or in free-form text arguments\n-     * to non-inline tags.\n-     *\n-     * @param element         the element where comment resides\n-     * @param holder          the tag that holds the documentation\n-     * @param trees           array of text tags and inline tags (often alternating)\n-     *                        present in the text of interest for this doc\n-     * @param isFirstSentence true if this is the first sentence\n-     *\n-     * @return the generated content\n-     *\/\n-    public abstract Content commentTagsToOutput(Element element, DocTree holder,\n-                                                List<? extends DocTree> trees, boolean isFirstSentence);\n-\n-    \/**\n-     * Returns an instance of the configuration used for this doclet.\n-     *\n-     * @return an instance of the configuration used for this doclet\n-     *\/\n-    public abstract BaseConfiguration configuration();\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/TagletWriter.java","additions":0,"deletions":420,"binary":false,"changes":420,"status":"deleted"},{"patch":"@@ -1,127 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.taglets;\n-\n-import java.util.List;\n-import java.util.Set;\n-\n-import javax.lang.model.element.Element;\n-\n-import com.sun.source.doctree.DocTree;\n-import jdk.javadoc.internal.doclets.formats.html.markup.RawHtml;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n-\n-import static jdk.javadoc.doclet.Taglet.Location.*;\n-\n-\/**\n- * A taglet wrapper, allows the public taglet {@link jdk.javadoc.doclet.Taglet}\n- * wrapped into an internal {@code Taglet} representation.\n- *\/\n-public final class UserTaglet implements Taglet {\n-\n-    private final jdk.javadoc.doclet.Taglet userTaglet;\n-\n-    public UserTaglet(jdk.javadoc.doclet.Taglet t) {\n-        userTaglet = t;\n-    }\n-\n-    @Override\n-    public Set<jdk.javadoc.doclet.Taglet.Location> getAllowedLocations() {\n-        return userTaglet.getAllowedLocations();\n-    }\n-\n-    @Override\n-    public boolean inField() {\n-        return userTaglet.getAllowedLocations().contains(FIELD);\n-    }\n-\n-    @Override\n-    public boolean inConstructor() {\n-        return userTaglet.getAllowedLocations().contains(CONSTRUCTOR);\n-    }\n-\n-    @Override\n-    public boolean inMethod() {\n-        return userTaglet.getAllowedLocations().contains(METHOD);\n-    }\n-\n-    @Override\n-    public boolean inOverview() {\n-        return userTaglet.getAllowedLocations().contains(OVERVIEW);\n-    }\n-\n-    @Override\n-    public boolean inModule() {\n-        return userTaglet.getAllowedLocations().contains(MODULE);\n-    }\n-\n-    @Override\n-    public boolean inPackage() {\n-        return userTaglet.getAllowedLocations().contains(PACKAGE);\n-    }\n-\n-    @Override\n-    public boolean inType() {\n-        return userTaglet.getAllowedLocations().contains(TYPE);\n-    }\n-\n-    @Override\n-    public boolean isInlineTag() {\n-        return userTaglet.isInlineTag();\n-    }\n-\n-    @Override\n-    public boolean isBlockTag() {\n-        return userTaglet.isBlockTag();\n-    }\n-\n-    @Override\n-    public String getName() {\n-        return userTaglet.getName();\n-    }\n-\n-    @Override\n-    public Content getInlineTagOutput(Element element, DocTree tag, TagletWriter writer) {\n-        Content output = writer.getOutputInstance();\n-        output.add(RawHtml.of(userTaglet.toString(List.of(tag), element)));\n-        return output;\n-    }\n-\n-    @Override\n-    public Content getAllBlockTagOutput(Element holder, TagletWriter writer) {\n-        Content output = writer.getOutputInstance();\n-        Utils utils = writer.configuration().utils;\n-        List<? extends DocTree> tags = utils.getBlockTags(holder, this);\n-        if (!tags.isEmpty()) {\n-            String tagString = userTaglet.toString(tags, holder);\n-            if (tagString != null) {\n-                output.add(RawHtml.of(tagString));\n-            }\n-        }\n-        return output;\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/UserTaglet.java","additions":0,"deletions":127,"binary":false,"changes":127,"status":"deleted"},{"patch":"@@ -1,131 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.taglets;\n-\n-import java.util.EnumSet;\n-import java.util.IllegalFormatException;\n-import java.util.Optional;\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.VariableElement;\n-\n-import com.sun.source.doctree.DocTree;\n-import com.sun.source.doctree.TextTree;\n-import com.sun.source.doctree.ValueTree;\n-import jdk.javadoc.doclet.Taglet.Location;\n-import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.Messages;\n-import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;\n-import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n-\n-\/**\n- * An inline taglet representing the value tag. This tag should only be used with\n- * constant fields that have a value.  It is used to access the value of constant\n- * fields.  This inline tag has an optional field name parameter.  If the name is\n- * specified, the constant value is retrieved from the specified field.  A link\n- * is also created to the specified field.  If a name is not specified, the value\n- * is retrieved for the field that the inline tag appears on.  The name is specified\n- * in the following format:  [fully qualified class name]#[constant field name].\n- *\/\n-public class ValueTaglet extends BaseTaglet {\n-\n-    \/**\n-     * Construct a new ValueTaglet.\n-     *\/\n-    public ValueTaglet() {\n-        super(DocTree.Kind.VALUE, true, EnumSet.allOf(Location.class));\n-    }\n-\n-    \/**\n-     * Returns the referenced field or a null if the value tag\n-     * is empty or the reference is invalid.\n-     *\n-     * @param holder the tag holder.\n-     * @param config the  configuration of the doclet.\n-     * @param tag the value tag.\n-     *\n-     * @return the referenced field or null.\n-     *\/\n-    private VariableElement getVariableElement(Element holder, BaseConfiguration config, DocTree tag) {\n-        CommentHelper ch = config.utils.getCommentHelper(holder);\n-        String signature = ch.getReferencedSignature(tag);\n-\n-        Element e = signature == null\n-                ? holder\n-                : ch.getReferencedMember(tag);\n-\n-        return (e != null && config.utils.isVariableElement(e))\n-                ? (VariableElement) e\n-                : null;\n-    }\n-\n-    @Override\n-    public Content getInlineTagOutput(Element holder, DocTree tag, TagletWriter writer) {\n-        BaseConfiguration configuration = writer.configuration();\n-        Utils utils = configuration.utils;\n-        Messages messages = configuration.getMessages();\n-        VariableElement field = getVariableElement(holder, configuration, tag);\n-        if (field == null) {\n-            if (tag.toString().isEmpty()) {\n-                \/\/Invalid use of @value\n-                messages.warning(holder,\n-                        \"doclet.value_tag_invalid_use\");\n-            } else {\n-                \/\/Reference is unknown.\n-                messages.warning(holder,\n-                        \"doclet.value_tag_invalid_reference\", tag.toString());\n-            }\n-        } else if (field.getConstantValue() != null) {\n-            TextTree format = ((ValueTree) tag).getFormat();\n-            String text;\n-            if (format != null) {\n-                String f = format.getBody();\n-                if (f.startsWith(\"\\\"\")) {\n-                    f = f.substring(1, f.length() - 1);\n-                }\n-                try {\n-                    text = String.format(configuration.getLocale(), f, field.getConstantValue());\n-                } catch (IllegalFormatException e) {\n-                    messages.error(holder,\n-                            \"doclet.value_tag_invalid_format\", format);\n-                    return writer.invalidTagOutput(\n-                            messages.getResources().getText(\"doclet.value_tag_invalid_format\", format),\n-                            Optional.empty());\n-                }\n-            } else {\n-                text = utils.constantValueExpression(field);\n-            }\n-            return writer.valueTagOutput(field,\n-                text,\n-                !field.equals(holder));\n-        } else {\n-            \/\/Referenced field is not a constant.\n-            messages.warning(holder,\n-                \"doclet.value_tag_invalid_constant\", utils.getSimpleName(field));\n-        }\n-        return writer.getOutputInstance();\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/ValueTaglet.java","additions":0,"deletions":131,"binary":false,"changes":131,"status":"deleted"},{"patch":"@@ -1,46 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * This package has classes used to generate output for Javadoc tags.\n- *\n- * <p>Doclets no longer have to implement their own version of standard tags\n- * such as &#64;param and &#64;throws.  Individual taglets provide\n- * common processing, independent of the output format.\n- * Each doclet must have a taglet writer that takes a taglet\n- * as input and writes doclet-dependent output. The taglet itself will\n- * do the tag processing. For example, suppose we are outputting\n- * &#64;throws tags. The taglet would:\n- * <ul>\n- *     <li> Retrieve the list of throws tags to be documented.\n- *     <li> Replace {&#64;inheritDoc} with the appropriate documentation.\n- *     <li> Add throws documentation for exceptions that are declared in\n- *          the signature of the method but not documented with the throws tags.\n- * <\/ul>\n- * After doing the steps above, the taglet would pass the information to\n- * the taglet writer for writing. The taglets are essentially builders for\n- * tags.\n- *\/\n-package jdk.javadoc.internal.doclets.toolkit.taglets;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/package-info.java","additions":0,"deletions":46,"binary":false,"changes":46,"status":"deleted"},{"patch":"@@ -37,1 +37,0 @@\n-import java.util.Arrays;\n@@ -119,0 +118,1 @@\n+\n@@ -124,2 +124,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.taglets.BaseTaglet;\n-import jdk.javadoc.internal.doclets.toolkit.taglets.Taglet;\n@@ -994,1 +992,1 @@\n-     * For example, a two dimensional array of String returns \"{@code [][]}\".\n+     * For example, a two-dimensional array of String returns \"{@code [][]}\".\n@@ -2090,0 +2088,9 @@\n+    \/**\n+     * Returns the \"raw\" list of block tags from the doc-comment tree for an element,\n+     * or an empty list if there is no such comment.\n+     *\n+     * Note: The list may include {@code ErroneousTree} nodes.\n+     *\n+     * @param element the element\n+     * @return the list\n+     *\/\n@@ -2094,0 +2101,9 @@\n+    \/**\n+     * Returns the \"raw\" list of block tags from a {@code DocCommentTree}, or an empty list\n+     * if the doc-comment tree is {@code null}.\n+     *\n+     * Note: The list may include {@code ErroneousTree} nodes.\n+     *\n+     * @param dcTree the doc-comment tree\n+     * @return the list\n+     *\/\n@@ -2098,1 +2114,9 @@\n-    public List<? extends DocTree> getBlockTags(Element element, Predicate<DocTree> filter) {\n+    \/**\n+     * Returns the list of block tags for the doc-comment tree for an element that match\n+     * a given filter, or an empty list if there is no such doc-comment.\n+     *\n+     * @param element the element\n+     * @param filter  the filter\n+     * @return the list\n+     *\/\n+    public List<? extends BlockTagTree> getBlockTags(Element element, Predicate<? super BlockTagTree> filter) {\n@@ -2101,0 +2125,1 @@\n+                .map(t -> (BlockTagTree) t)\n@@ -2105,1 +2130,12 @@\n-    public <T extends DocTree> List<T> getBlockTags(Element element, Predicate<DocTree> filter, Class<T> tClass) {\n+    \/**\n+     * Returns the list of block tags for the doc-comment tree for an element that match\n+     * a given filter, or an empty list if there is no such doc-comment.\n+     *\n+     * @param <T> the type of the required block tags\n+     * @param element the element\n+     * @param filter  the filter\n+     * @return the list\n+     *\/\n+    public <T extends BlockTagTree> List<T> getBlockTags(Element element,\n+                                                         Predicate<? super BlockTagTree> filter,\n+                                                         Class<T> tClass) {\n@@ -2108,0 +2144,1 @@\n+                .map(t -> (BlockTagTree) t)\n@@ -2113,1 +2150,8 @@\n-    public List<? extends DocTree> getBlockTags(Element element, DocTree.Kind kind) {\n+    \/**\n+     * Returns the list of block tags for the doc-comment tree for an element,\n+     * or an empty list if there is no such doc-comment.\n+     *\n+     * @param element the element\n+     * @return the list\n+     *\/\n+    public List<? extends BlockTagTree> getBlockTags(Element element, DocTree.Kind kind) {\n@@ -2117,1 +2161,10 @@\n-    public <T extends DocTree> List<? extends T> getBlockTags(Element element, DocTree.Kind kind, Class<T> tClass) {\n+    \/**\n+     * Returns the list of block tags for the doc-comment tree for an element that match a given kind,\n+     * or an empty list if there is no such doc-comment.\n+     *\n+     * @param <T> the type of the required block tags\n+     * @param element the element\n+     * @param kind the kind for the required block tags\n+     * @return the list\n+     *\/\n+    public <T extends BlockTagTree> List<? extends T> getBlockTags(Element element, DocTree.Kind kind, Class<T> tClass) {\n@@ -2121,10 +2174,10 @@\n-    public List<? extends DocTree> getBlockTags(Element element, Taglet taglet) {\n-        return getBlockTags(element, t -> {\n-            if (taglet instanceof BaseTaglet baseTaglet) {\n-                return baseTaglet.accepts(t);\n-            } else if (t instanceof BlockTagTree blockTagTree) {\n-                return blockTagTree.getTagName().equals(taglet.getName());\n-            } else {\n-                return false;\n-            }\n-        });\n+    \/**\n+     * Returns the list of block tags for the doc-comment tree for an element that match a given name,\n+     * or an empty list if there is no such doc-comment.\n+     *\n+     * @param element the element\n+     * @param tagName the name of the required block tags\n+     * @return the list\n+     *\/\n+    public List<? extends BlockTagTree> getBlockTags(Element element, String tagName) {\n+        return getBlockTags(element, t -> t.getTagName().equals(tagName));\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/Utils.java","additions":71,"deletions":18,"binary":false,"changes":89,"status":"modified"}]}