{"files":[{"patch":"@@ -49,1 +49,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.taglets.DeprecatedTaglet;\n@@ -260,2 +259,2 @@\n-        Content output = (new DeprecatedTaglet()).getAllBlockTagOutput(member,\n-            writer.getTagletWriterInstance(false));\n+        var t = configuration.tagletManager.getTaglet(DocTree.Kind.DEPRECATED);\n+        Content output = t.getAllBlockTagOutput(member, writer.getTagletWriterInstance(false));\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/AbstractMemberWriter.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+\n@@ -44,0 +45,1 @@\n+\n@@ -54,1 +56,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.taglets.ParamTaglet;\n@@ -176,1 +177,1 @@\n-    protected TypeElement getCurrentPageElement() {\n+    public TypeElement getCurrentPageElement() {\n@@ -271,2 +272,2 @@\n-            Content paramInfo = (new ParamTaglet()).getAllBlockTagOutput(typeElement,\n-                    getTagletWriterInstance(false));\n+            var t = configuration.tagletManager.getTaglet(DocTree.Kind.PARAM);\n+            Content paramInfo = t.getAllBlockTagOutput(typeElement, getTagletWriterInstance(false));\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/ClassWriterImpl.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+import jdk.javadoc.internal.doclets.formats.html.taglets.HtmlTagletManager;\n@@ -58,0 +59,1 @@\n+import jdk.javadoc.internal.doclets.toolkit.taglets.TagletManager;\n@@ -107,1 +109,1 @@\n-    protected HtmlIndexBuilder mainIndex;\n+    public HtmlIndexBuilder mainIndex;\n@@ -136,1 +138,1 @@\n-    protected final Messages messages;\n+    public final Messages messages;\n@@ -290,0 +292,5 @@\n+    @Override\n+    protected TagletManager newTagletManager() {\n+        return new HtmlTagletManager(this);\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlConfiguration.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+\n@@ -71,1 +72,0 @@\n-import com.sun.source.doctree.IndexTree;\n@@ -73,0 +73,1 @@\n+import com.sun.source.doctree.InlineTagTree;\n@@ -76,2 +77,0 @@\n-import com.sun.source.doctree.SummaryTree;\n-import com.sun.source.doctree.SystemPropertyTree;\n@@ -94,0 +93,1 @@\n+import jdk.javadoc.internal.doclets.formats.html.taglets.TagletWriterImpl;\n@@ -97,1 +97,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.taglets.DocRootTaglet;\n@@ -112,1 +111,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable;\n@@ -115,1 +113,0 @@\n-import static com.sun.source.doctree.DocTree.Kind.CODE;\n@@ -117,3 +114,0 @@\n-import static com.sun.source.doctree.DocTree.Kind.LINK;\n-import static com.sun.source.doctree.DocTree.Kind.LINK_PLAIN;\n-import static com.sun.source.doctree.DocTree.Kind.SEE;\n@@ -163,1 +157,1 @@\n-    protected final Messages messages;\n+    public final Messages messages;\n@@ -167,1 +161,1 @@\n-    protected final Links links;\n+    public final Links links;\n@@ -200,1 +194,1 @@\n-    Map<String, Integer> indexAnchorTable = new HashMap<>();\n+    public final Map<String, Integer> indexAnchorTable = new HashMap<>();\n@@ -281,1 +275,1 @@\n-        \/\/ Note: {@docRoot} is not case sensitive when passed in with a command-line option:\n+        \/\/ Note: {@docRoot} is not case-sensitive when passed in with a command-line option:\n@@ -378,2 +372,1 @@\n-        return getTagletWriterInstance(context)\n-                .getInlineTagOutput(element, configuration.tagletManager, tree);\n+        return getTagletWriterInstance(context).getInlineTagOutput(element, tree);\n@@ -759,1 +752,1 @@\n-     * Return a class cross link to external class documentation.\n+     * Return a class cross-link to external class documentation.\n@@ -889,1 +882,1 @@\n-    protected TypeElement getCurrentPageElement() {\n+    public TypeElement getCurrentPageElement() {\n@@ -1310,6 +1303,0 @@\n-                @Override\n-                public Boolean visitDocRoot(DocRootTree node, Content content) {\n-                    content.add(getInlineTagOutput(element, node, context));\n-                    return false;\n-                }\n-\n@@ -1364,37 +1351,0 @@\n-                @Override\n-                public Boolean visitIndex(IndexTree node, Content content) {\n-                    Content output = getInlineTagOutput(element, node, context);\n-                    if (output != null) {\n-                        content.add(output);\n-                    }\n-                    return false;\n-                }\n-\n-                @Override\n-                public Boolean visitLink(LinkTree node, Content content) {\n-                    var inTags = context.inTags;\n-                    if (inTags.contains(LINK) || inTags.contains(LINK_PLAIN) || inTags.contains(SEE)) {\n-                        DocTreePath dtp = ch.getDocTreePath(node);\n-                        if (dtp != null) {\n-                            messages.warning(dtp, \"doclet.see.nested_link\", \"{@\" + node.getTagName() + \"}\");\n-                        }\n-                        Content label = commentTagsToContent(element, node.getLabel(), context);\n-                        if (label.isEmpty()) {\n-                            label = Text.of(node.getReference().getSignature());\n-                        }\n-                        content.add(label);\n-                    } else {\n-                        TagletWriterImpl t = getTagletWriterInstance(context.within(node));\n-                        content.add(t.linkTagOutput(element, node));\n-                    }\n-                    return false;\n-                }\n-\n-                @Override\n-                public Boolean visitLiteral(LiteralTree node, Content content) {\n-                    String s = node.getBody().getBody();\n-                    Content t = Text.of(Text.normalizeNewlines(s));\n-                    content.add(node.getKind() == CODE ? HtmlTree.CODE(t) : t);\n-                    return false;\n-                }\n-\n@@ -1414,16 +1364,0 @@\n-                @Override\n-                public Boolean visitSummary(SummaryTree node, Content content) {\n-                    Content output = getInlineTagOutput(element, node, context);\n-                    content.add(output);\n-                    return false;\n-                }\n-\n-                @Override\n-                public Boolean visitSystemProperty(SystemPropertyTree node, Content content) {\n-                    Content output = getInlineTagOutput(element, node, context);\n-                    if (output != null) {\n-                        content.add(output);\n-                    }\n-                    return false;\n-                }\n-\n@@ -1458,3 +1392,5 @@\n-                    Content output = getInlineTagOutput(element, node, context);\n-                    if (output != null) {\n-                        content.add(output);\n+                    if (node instanceof InlineTagTree) {\n+                        var output = getInlineTagOutput(element, node, context);\n+                        if (output != null) {\n+                            content.add(output);\n+                        }\n@@ -1565,1 +1501,1 @@\n-    protected Content invalidTagOutput(String summary, Optional<Content> detail) {\n+    public Content invalidTagOutput(String summary, Optional<Content> detail) {\n@@ -1668,1 +1604,1 @@\n-                text = \"{@\" + (new DocRootTaglet()).getName() + \"}\/\"\n+                text = \"{@\" + Kind.DOC_ROOT.tagName + \"}\/\"\n@@ -2052,1 +1988,1 @@\n-     * @throws DocFileIOException\n+     * @throws DocFileIOException if an issue arises while accessing any stylesheets\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlDocletWriter.java","additions":18,"deletions":82,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -397,1 +397,1 @@\n-    static HtmlId forParam(String paramName) {\n+    public static HtmlId forParam(String paramName) {\n@@ -410,1 +410,1 @@\n-    static HtmlId forText(String text, Map<String, Integer> counts) {\n+    public static HtmlId forText(String text, Map<String, Integer> counts) {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlIds.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,2 @@\n-import java.util.*;\n+import java.util.List;\n+import java.util.SortedSet;\n@@ -35,1 +36,0 @@\n-\n@@ -38,0 +38,1 @@\n+\n@@ -39,1 +40,0 @@\n-import jdk.javadoc.internal.doclets.formats.html.markup.TagName;\n@@ -41,0 +41,1 @@\n+import jdk.javadoc.internal.doclets.formats.html.markup.TagName;\n@@ -42,0 +43,1 @@\n+import jdk.javadoc.internal.doclets.formats.html.taglets.TagletWriterImpl;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlSerialFieldWriter.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1,985 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.formats.html;\n-\n-import java.net.URI;\n-import java.net.URISyntaxException;\n-import java.util.ArrayList;\n-import java.util.EnumSet;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.function.BiConsumer;\n-import java.util.function.Predicate;\n-import java.util.stream.Collectors;\n-\n-import javax.lang.model.element.Element;\n-import javax.lang.model.element.ElementKind;\n-import javax.lang.model.element.ExecutableElement;\n-import javax.lang.model.element.ModuleElement;\n-import javax.lang.model.element.PackageElement;\n-import javax.lang.model.element.TypeElement;\n-import javax.lang.model.element.VariableElement;\n-import javax.lang.model.type.TypeMirror;\n-import javax.lang.model.util.SimpleElementVisitor14;\n-\n-import com.sun.source.doctree.DeprecatedTree;\n-import com.sun.source.doctree.DocTree;\n-import com.sun.source.doctree.IndexTree;\n-import com.sun.source.doctree.LinkTree;\n-import com.sun.source.doctree.LiteralTree;\n-import com.sun.source.doctree.ParamTree;\n-import com.sun.source.doctree.ReturnTree;\n-import com.sun.source.doctree.SeeTree;\n-import com.sun.source.doctree.SnippetTree;\n-import com.sun.source.doctree.SpecTree;\n-import com.sun.source.doctree.SystemPropertyTree;\n-import com.sun.source.doctree.TextTree;\n-import com.sun.source.doctree.ThrowsTree;\n-import com.sun.source.util.DocTreePath;\n-import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlAttr;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlId;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;\n-import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n-import jdk.javadoc.internal.doclets.formats.html.markup.RawHtml;\n-import jdk.javadoc.internal.doclets.formats.html.markup.TagName;\n-import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n-import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.DocletElement;\n-import jdk.javadoc.internal.doclets.toolkit.Messages;\n-import jdk.javadoc.internal.doclets.toolkit.Resources;\n-import jdk.javadoc.internal.doclets.toolkit.builders.SerializedFormBuilder;\n-import jdk.javadoc.internal.doclets.toolkit.taglets.ParamTaglet;\n-import jdk.javadoc.internal.doclets.toolkit.taglets.TagletWriter;\n-import jdk.javadoc.internal.doclets.toolkit.taglets.snippet.Style;\n-import jdk.javadoc.internal.doclets.toolkit.taglets.snippet.StyledText;\n-import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocLink;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocPath;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocPaths;\n-import jdk.javadoc.internal.doclets.toolkit.util.IndexItem;\n-import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n-import jdk.javadoc.internal.doclets.toolkit.util.Utils.PreviewFlagProvider;\n-import jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable;\n-\n-import static com.sun.source.doctree.DocTree.Kind.LINK_PLAIN;\n-\n-\/**\n- * The taglet writer that writes HTML.\n- *\/\n-public class TagletWriterImpl extends TagletWriter {\n-    \/**\n-     * A class that provides the information about the enclosing context for\n-     * a series of {@code DocTree} nodes.\n-     * This context may be used to determine the content that should be generated from the tree nodes.\n-     *\/\n-    static class Context {\n-        \/**\n-         * Whether or not the trees are appearing in a context of just the first sentence,\n-         * such as in the summary table of the enclosing element.\n-         *\/\n-        final boolean isFirstSentence;\n-        \/**\n-         * Whether or not the trees are appearing in the \"summary\" section of the\n-         * page for a declaration.\n-         *\/\n-        final boolean inSummary;\n-        \/**\n-         * The set of enclosing kinds of tags.\n-         *\/\n-        final Set<DocTree.Kind> inTags;\n-\n-        \/**\n-         * Creates an outermost context, with no enclosing tags.\n-         *\n-         * @param isFirstSentence {@code true} if the trees are appearing in a context of just the\n-         *                        first sentence and {@code false} otherwise\n-         * @param inSummary       {@code true} if the trees are appearing in the \"summary\" section\n-         *                        of the page for a declaration and {@code false} otherwise\n-         *\/\n-        Context(boolean isFirstSentence, boolean inSummary) {\n-            this(isFirstSentence, inSummary, EnumSet.noneOf(DocTree.Kind.class));\n-        }\n-\n-        private Context(boolean isFirstSentence, boolean inSummary, Set<DocTree.Kind> inTags) {\n-            this.isFirstSentence = isFirstSentence;\n-            this.inSummary = inSummary;\n-            this.inTags = inTags;\n-        }\n-\n-        \/**\n-         * Creates a new {@code Context} that includes an extra tag kind in the set of enclosing\n-         * kinds of tags.\n-         *\n-         * @param tree the enclosing tree\n-         *\n-         * @return the new {@code Context}\n-         *\/\n-        Context within(DocTree tree) {\n-            var newInTags = EnumSet.copyOf(inTags);\n-            newInTags.add(tree.getKind());\n-            return new Context(isFirstSentence, inSummary, newInTags);\n-        }\n-    }\n-\n-    private final HtmlDocletWriter htmlWriter;\n-    private final HtmlConfiguration configuration;\n-    private final HtmlOptions options;\n-    private final Utils utils;\n-    private final Resources resources;\n-\n-    private final Messages messages;\n-\n-    private final Contents contents;\n-    private final Context context;\n-\n-    \/\/ Threshold for length of @see tag label for switching from inline to block layout.\n-    private static final int TAG_LIST_ITEM_MAX_INLINE_LENGTH = 30;\n-\n-    \/**\n-     * Creates a taglet writer.\n-     *\n-     * @param htmlWriter      the {@code HtmlDocletWriter} for the page\n-     * @param isFirstSentence {@code true} if this taglet writer is being used for a\n-     *                        \"first sentence\" summary\n-     *\/\n-    public TagletWriterImpl(HtmlDocletWriter htmlWriter, boolean isFirstSentence) {\n-        this(htmlWriter, isFirstSentence, false);\n-    }\n-\n-    \/**\n-     * Creates a taglet writer.\n-     *\n-     * @param htmlWriter      the {@code HtmlDocletWriter} for the page\n-     * @param isFirstSentence {@code true} if this taglet writer is being used for a\n-     *                        \"first sentence\" summary, and {@code false} otherwise\n-     * @param inSummary       {@code true} if this taglet writer is being used for the content\n-     *                        of a {@code {@summary ...}} tag, and {@code false} otherwise\n-     *\/\n-    public TagletWriterImpl(HtmlDocletWriter htmlWriter, boolean isFirstSentence, boolean inSummary) {\n-        this(htmlWriter, new Context(isFirstSentence, inSummary));\n-    }\n-\n-    \/**\n-     * Creates a taglet writer.\n-     *\n-     * @param htmlWriter the {@code HtmlDocletWriter} for the page\n-     * @param context    the enclosing context for any tags\n-     *\/\n-    public TagletWriterImpl(HtmlDocletWriter htmlWriter, Context context) {\n-        super(context.isFirstSentence);\n-        this.htmlWriter = htmlWriter;\n-        this.context = context;\n-        configuration = htmlWriter.configuration;\n-        options = configuration.getOptions();\n-        utils = configuration.utils;\n-        messages = configuration.messages;\n-        resources = configuration.getDocResources();\n-        contents = configuration.getContents();\n-    }\n-\n-    @Override\n-    public Content getOutputInstance() {\n-        return new ContentBuilder();\n-    }\n-\n-    @Override\n-    protected Content codeTagOutput(Element element, LiteralTree tag) {\n-        return HtmlTree.CODE(Text.of(Text.normalizeNewlines(tag.getBody().getBody())));\n-    }\n-\n-    @Override\n-    protected Content indexTagOutput(Element element, IndexTree tag) {\n-        CommentHelper ch = utils.getCommentHelper(element);\n-\n-        DocTree searchTerm = tag.getSearchTerm();\n-        String tagText = (searchTerm instanceof TextTree tt) ? tt.getBody() : \"\";\n-        if (tagText.charAt(0) == '\"' && tagText.charAt(tagText.length() - 1) == '\"') {\n-            tagText = tagText.substring(1, tagText.length() - 1);\n-        }\n-        tagText = tagText.replaceAll(\"\\\\s+\", \" \");\n-\n-        Content desc = htmlWriter.commentTagsToContent(element, tag.getDescription(), context.within(tag));\n-        String descText = extractText(desc);\n-\n-        return createAnchorAndSearchIndex(element, tagText, descText, tag);\n-    }\n-\n-    \/\/ ugly but simple;\n-    \/\/ alternatives would be to walk the Content's tree structure, or to add new functionality to Content\n-    private String extractText(Content c) {\n-        return c.toString().replaceAll(\"<[^>]+>\", \"\");\n-    }\n-\n-    @Override\n-    public Content getDocRootOutput() {\n-        String path;\n-        if (htmlWriter.pathToRoot.isEmpty())\n-            path = \".\";\n-        else\n-            path = htmlWriter.pathToRoot.getPath();\n-        return Text.of(path);\n-    }\n-\n-    @Override\n-    public Content deprecatedTagOutput(Element element) {\n-        ContentBuilder result = new ContentBuilder();\n-        CommentHelper ch = utils.getCommentHelper(element);\n-        List<? extends DeprecatedTree> deprs = utils.getDeprecatedTrees(element);\n-        if (utils.isTypeElement(element)) {\n-            if (utils.isDeprecated(element)) {\n-                result.add(HtmlTree.SPAN(HtmlStyle.deprecatedLabel,\n-                        htmlWriter.getDeprecatedPhrase(element)));\n-                if (!deprs.isEmpty()) {\n-                    List<? extends DocTree> commentTrees = ch.getDescription(deprs.get(0));\n-                    if (!commentTrees.isEmpty()) {\n-                        result.add(commentTagsToOutput(element, null, commentTrees, false));\n-                    }\n-                }\n-            }\n-        } else {\n-            if (utils.isDeprecated(element)) {\n-                result.add(HtmlTree.SPAN(HtmlStyle.deprecatedLabel,\n-                        htmlWriter.getDeprecatedPhrase(element)));\n-                if (!deprs.isEmpty()) {\n-                    List<? extends DocTree> bodyTrees = ch.getBody(deprs.get(0));\n-                    Content body = commentTagsToOutput(element, null, bodyTrees, false);\n-                    if (!body.isEmpty())\n-                        result.add(HtmlTree.DIV(HtmlStyle.deprecationComment, body));\n-                }\n-            } else {\n-                Element ee = utils.getEnclosingTypeElement(element);\n-                if (utils.isDeprecated(ee)) {\n-                    result.add(HtmlTree.SPAN(HtmlStyle.deprecatedLabel,\n-                        htmlWriter.getDeprecatedPhrase(ee)));\n-                }\n-            }\n-        }\n-        return result;\n-    }\n-\n-    @Override\n-    public Content linkTagOutput(Element element, LinkTree tag) {\n-        CommentHelper ch = utils.getCommentHelper(element);\n-\n-        var linkRef = tag.getReference();\n-        if (linkRef == null) {\n-            messages.warning(ch.getDocTreePath(tag), \"doclet.link.no_reference\");\n-            return invalidTagOutput(resources.getText(\"doclet.tag.invalid_input\", tag.toString()),\n-                    Optional.empty());\n-        }\n-\n-        DocTree.Kind kind = tag.getKind();\n-        String refSignature = ch.getReferencedSignature(linkRef);\n-\n-        return linkSeeReferenceOutput(element,\n-                tag,\n-                refSignature,\n-                ch.getReferencedElement(tag),\n-                (kind == LINK_PLAIN),\n-                htmlWriter.commentTagsToContent(element, tag.getLabel(), context),\n-                (key, args) -> messages.warning(ch.getDocTreePath(tag), key, args)\n-        );\n-    }\n-\n-    @Override\n-    protected Content literalTagOutput(Element element, LiteralTree tag) {\n-        return Text.of(Text.normalizeNewlines(tag.getBody().getBody()));\n-    }\n-\n-    @Override\n-    public Content getParamHeader(ParamTaglet.ParamKind kind) {\n-        Content header = switch (kind) {\n-            case PARAMETER -> contents.parameters;\n-            case TYPE_PARAMETER -> contents.typeParameters;\n-            case RECORD_COMPONENT -> contents.recordComponents;\n-            default -> throw new IllegalArgumentException(kind.toString());\n-        };\n-        return HtmlTree.DT(header);\n-    }\n-\n-    @Override\n-    public Content paramTagOutput(Element element, ParamTree paramTag, String paramName) {\n-        ContentBuilder body = new ContentBuilder();\n-        CommentHelper ch = utils.getCommentHelper(element);\n-        \/\/ define id attributes for state components so that generated descriptions may refer to them\n-        boolean defineID = (element.getKind() == ElementKind.RECORD)\n-                && !paramTag.isTypeParameter();\n-        Content nameContent = Text.of(paramName);\n-        body.add(HtmlTree.CODE(defineID ? HtmlTree.SPAN_ID(HtmlIds.forParam(paramName), nameContent) : nameContent));\n-        body.add(\" - \");\n-        List<? extends DocTree> description = ch.getDescription(paramTag);\n-        body.add(htmlWriter.commentTagsToContent(element, description, context.within(paramTag)));\n-        return HtmlTree.DD(body);\n-    }\n-\n-    @Override\n-    public Content returnTagOutput(Element element, ReturnTree returnTag, boolean inline) {\n-        CommentHelper ch = utils.getCommentHelper(element);\n-        List<? extends DocTree> desc = ch.getDescription(returnTag);\n-        Content content = htmlWriter.commentTagsToContent(element, desc, context.within(returnTag));\n-        return inline\n-                ? new ContentBuilder(contents.getContent(\"doclet.Returns_0\", content))\n-                : new ContentBuilder(HtmlTree.DT(contents.returns), HtmlTree.DD(content));\n-    }\n-\n-    @Override\n-    public Content seeTagOutput(Element holder, List<? extends SeeTree> seeTags) {\n-        List<Content> links = new ArrayList<>();\n-        for (SeeTree dt : seeTags) {\n-            TagletWriterImpl t = new TagletWriterImpl(htmlWriter, context.within(dt));\n-            links.add(t.seeTagOutput(holder, dt));\n-        }\n-        if (utils.isVariableElement(holder) && ((VariableElement)holder).getConstantValue() != null &&\n-                htmlWriter instanceof ClassWriterImpl writer) {\n-            \/\/Automatically add link to constant values page for constant fields.\n-            DocPath constantsPath =\n-                    htmlWriter.pathToRoot.resolve(DocPaths.CONSTANT_VALUES);\n-            String whichConstant =\n-                    writer.getTypeElement().getQualifiedName() + \".\" +\n-                    utils.getSimpleName(holder);\n-            DocLink link = constantsPath.fragment(whichConstant);\n-            links.add(htmlWriter.links.createLink(link,\n-                    contents.getContent(\"doclet.Constants_Summary\")));\n-        }\n-        if (utils.isClass(holder) && utils.isSerializable((TypeElement)holder)) {\n-            \/\/Automatically add link to serialized form page for serializable classes.\n-            if (SerializedFormBuilder.serialInclude(utils, holder) &&\n-                      SerializedFormBuilder.serialInclude(utils, utils.containingPackage(holder))) {\n-                DocPath serialPath = htmlWriter.pathToRoot.resolve(DocPaths.SERIALIZED_FORM);\n-                DocLink link = serialPath.fragment(utils.getFullyQualifiedName(holder));\n-                links.add(htmlWriter.links.createLink(link,\n-                        contents.getContent(\"doclet.Serialized_Form\")));\n-            }\n-        }\n-        if (links.isEmpty()) {\n-            return Text.EMPTY;\n-        }\n-        \/\/ Use a different style if any link label is longer than 30 chars or contains commas.\n-        boolean hasLongLabels = links.stream().anyMatch(this::isLongOrHasComma);\n-        var seeList = HtmlTree.UL(hasLongLabels ? HtmlStyle.tagListLong : HtmlStyle.tagList);\n-        links.stream()\n-                .filter(Predicate.not(Content::isEmpty))\n-                .forEach(item -> seeList.add(HtmlTree.LI(item)));\n-\n-        return new ContentBuilder(\n-                HtmlTree.DT(contents.seeAlso),\n-                HtmlTree.DD(seeList));\n-    }\n-\n-    private boolean isLongOrHasComma(Content c) {\n-        String s = c.toString()\n-                .replaceAll(\"<.*?>\", \"\")              \/\/ ignore HTML\n-                .replaceAll(\"&#?[A-Za-z0-9]+;\", \" \")  \/\/ entities count as a single character\n-                .replaceAll(\"\\\\R\", \"\\n\");             \/\/ normalize newlines\n-        return s.length() > TAG_LIST_ITEM_MAX_INLINE_LENGTH || s.contains(\",\");\n-    }\n-\n-    String textOf(List<? extends DocTree> trees) {\n-        return trees.stream()\n-                .filter(dt -> dt instanceof TextTree)\n-                .map(dt -> ((TextTree) dt).getBody().trim())\n-                .collect(Collectors.joining(\" \"));\n-    }\n-\n-    \/**\n-     * {@return the output for a single {@code @see} tag}\n-     *\n-     * @param element the element that has the documentation comment containing this tag\n-     * @param seeTag  the tag\n-     *\/\n-    private Content seeTagOutput(Element element, SeeTree seeTag) {\n-        List<? extends DocTree> ref = seeTag.getReference();\n-        assert !ref.isEmpty();\n-        DocTree ref0 = ref.get(0);\n-        switch (ref0.getKind()) {\n-            case TEXT, START_ELEMENT -> {\n-                \/\/ @see \"Reference\"\n-                \/\/ @see <a href=\"...\">...<\/a>\n-                return htmlWriter.commentTagsToContent(element, ref, false, false);\n-            }\n-\n-            case REFERENCE -> {\n-                \/\/ @see reference label...\n-                CommentHelper ch = utils.getCommentHelper(element);\n-                String refSignature = ch.getReferencedSignature(ref0);\n-                List<? extends DocTree> label = ref.subList(1, ref.size());\n-\n-                return linkSeeReferenceOutput(element,\n-                        seeTag,\n-                        refSignature,\n-                        ch.getReferencedElement(seeTag),\n-                        false,\n-                        htmlWriter.commentTagsToContent(element, label, context),\n-                        (key, args) -> messages.warning(ch.getDocTreePath(seeTag), key, args)\n-                );\n-            }\n-\n-            case ERRONEOUS -> {\n-                return invalidTagOutput(resources.getText(\"doclet.tag.invalid_input\",\n-                                ref0.toString()),\n-                        Optional.empty());\n-            }\n-\n-            default -> throw new IllegalStateException(ref0.getKind().toString());\n-        }\n-\n-    }\n-\n-    \/**\n-     * Worker method to generate a link from the information in different kinds of tags,\n-     * such as {@code {@link ...}} tags, {@code @see ...} tags and the {@code link} markup tag\n-     * in a {@code {@snippet ...}} tag.\n-     *\n-     * @param holder        the element that has the documentation comment containing the information\n-     * @param refTree       the tree node containing the information, or {@code null} if not available\n-     * @param refSignature  the normalized signature of the target of the reference\n-     * @param ref           the target of the reference\n-     * @param isLinkPlain   {@code true} if the link should be presented in \"plain\" font,\n-     *                      or {@code false} for \"code\" font\n-     * @param label         the label for the link,\n-     *                      or an empty item to use a default label derived from the signature\n-     * @param reportWarning a function to report warnings about issues found in the reference\n-     *\n-     * @return the output containing the generated link, or content indicating an error\n-     *\/\n-    private Content linkSeeReferenceOutput(Element holder,\n-                                           DocTree refTree,\n-                                           String refSignature,\n-                                           Element ref,\n-                                           boolean isLinkPlain,\n-                                           Content label,\n-                                           BiConsumer<String, Object[]> reportWarning) {\n-        Content labelContent = plainOrCode(isLinkPlain, label);\n-\n-        \/\/ The signature from the @see tag. We will output this text when a label is not specified.\n-        Content text = plainOrCode(isLinkPlain,\n-                Text.of(Objects.requireNonNullElse(refSignature, \"\")));\n-\n-        CommentHelper ch = utils.getCommentHelper(holder);\n-        TypeElement refClass = ch.getReferencedClass(ref);\n-        Element refMem =       ch.getReferencedMember(ref);\n-        String refFragment =   ch.getReferencedFragment(refSignature);\n-\n-        if (refFragment == null && refMem != null) {\n-            refFragment = refMem.toString();\n-        } else if (refFragment != null && refFragment.startsWith(\"#\")) {\n-            if (labelContent.isEmpty()) {\n-                \/\/ A non-empty label is required for fragment links as the\n-                \/\/ reference target does not provide a useful default label.\n-                htmlWriter.messages.error(ch.getDocTreePath(refTree), \"doclet.link.see.no_label\");\n-                return invalidTagOutput(resources.getText(\"doclet.link.see.no_label\"),\n-                        Optional.of(refSignature));\n-            }\n-            refFragment = refFragment.substring(1);\n-        }\n-        if (refClass == null) {\n-            ModuleElement refModule = ch.getReferencedModule(ref);\n-            if (refModule != null && utils.isIncluded(refModule)) {\n-                return htmlWriter.getModuleLink(refModule, labelContent.isEmpty() ? text : labelContent, refFragment);\n-            }\n-            \/\/@see is not referencing an included class\n-            PackageElement refPackage = ch.getReferencedPackage(ref);\n-            if (refPackage != null && utils.isIncluded(refPackage)) {\n-                \/\/@see is referencing an included package\n-                if (labelContent.isEmpty()) {\n-                    labelContent = plainOrCode(isLinkPlain,\n-                            Text.of(refPackage.getQualifiedName()));\n-                }\n-                return htmlWriter.getPackageLink(refPackage, labelContent, refFragment);\n-            } else {\n-                \/\/ @see is not referencing an included class, module or package. Check for cross links.\n-                String refModuleName =  ch.getReferencedModuleName(refSignature);\n-                DocLink elementCrossLink = (refPackage != null) ? htmlWriter.getCrossPackageLink(refPackage) :\n-                        (configuration.extern.isModule(refModuleName))\n-                                ? htmlWriter.getCrossModuleLink(utils.elementUtils.getModuleElement(refModuleName))\n-                                : null;\n-                if (elementCrossLink != null) {\n-                    \/\/ Element cross link found\n-                    return htmlWriter.links.createExternalLink(elementCrossLink,\n-                            (labelContent.isEmpty() ? text : labelContent));\n-                } else {\n-                    \/\/ No cross link found so print warning\n-                    if (!configuration.isDocLintReferenceGroupEnabled()) {\n-                        reportWarning.accept(\n-                                \"doclet.link.see.reference_not_found\",\n-                                new Object[] { refSignature});\n-                    }\n-                    return htmlWriter.invalidTagOutput(resources.getText(\"doclet.link.see.reference_invalid\"),\n-                            Optional.of(labelContent.isEmpty() ? text: labelContent));\n-                }\n-            }\n-        } else if (refFragment == null) {\n-            \/\/ Must be a class reference since refClass is not null and refFragment is null.\n-            if (labelContent.isEmpty() && refTree != null) {\n-                TypeMirror referencedType = ch.getReferencedType(refTree);\n-                if (utils.isGenericType(referencedType)) {\n-                    \/\/ This is a generic type link, use the TypeMirror representation.\n-                    return plainOrCode(isLinkPlain, htmlWriter.getLink(\n-                            new HtmlLinkInfo(configuration, HtmlLinkInfo.Kind.LINK_TYPE_PARAMS_AND_BOUNDS, referencedType)));\n-                }\n-                labelContent = plainOrCode(isLinkPlain, Text.of(utils.getSimpleName(refClass)));\n-            }\n-            return htmlWriter.getLink(new HtmlLinkInfo(configuration, HtmlLinkInfo.Kind.PLAIN, refClass)\n-                    .label(labelContent));\n-        } else if (refMem == null) {\n-            \/\/ This is a fragment reference since refClass and refFragment are not null but refMem is null.\n-            return htmlWriter.getLink(new HtmlLinkInfo(configuration, HtmlLinkInfo.Kind.PLAIN, refClass)\n-                    .label(labelContent)\n-                    .fragment(refFragment)\n-                    .style(null));\n-        } else {\n-            \/\/ Must be a member reference since refClass is not null and refMemName is not null.\n-            \/\/ refMem is not null, so this @see tag must be referencing a valid member.\n-            TypeElement containing = utils.getEnclosingTypeElement(refMem);\n-\n-            \/\/ Find the enclosing type where the method is actually visible\n-            \/\/ in the inheritance hierarchy.\n-            ExecutableElement overriddenMethod = null;\n-            if (refMem.getKind() == ElementKind.METHOD) {\n-                VisibleMemberTable vmt = configuration.getVisibleMemberTable(containing);\n-                overriddenMethod = vmt.getOverriddenMethod((ExecutableElement)refMem);\n-\n-                if (overriddenMethod != null) {\n-                    containing = utils.getEnclosingTypeElement(overriddenMethod);\n-                }\n-            }\n-            if (refSignature.trim().startsWith(\"#\") &&\n-                    ! (utils.isPublic(containing) || utils.isLinkable(containing))) {\n-                \/\/ Since the link is relative and the holder is not even being\n-                \/\/ documented, this must be an inherited link.  Redirect it.\n-                \/\/ The current class either overrides the referenced member or\n-                \/\/ inherits it automatically.\n-                if (htmlWriter instanceof ClassWriterImpl writer) {\n-                    containing = writer.getTypeElement();\n-                } else if (!utils.isPublic(containing)) {\n-                    reportWarning.accept(\"doclet.link.see.reference_not_accessible\",\n-                            new Object[] { utils.getFullyQualifiedName(containing)});\n-                } else {\n-                    if (!configuration.isDocLintReferenceGroupEnabled()) {\n-                        reportWarning.accept(\"doclet.link.see.reference_not_found\",\n-                                new Object[] { refSignature });\n-                    }\n-                }\n-            }\n-            String refMemName = refFragment;\n-            if (configuration.currentTypeElement != containing) {\n-                refMemName = (utils.isConstructor(refMem))\n-                        ? refMemName\n-                        : utils.getSimpleName(containing) + \".\" + refMemName;\n-            }\n-            if (utils.isExecutableElement(refMem)) {\n-                if (refMemName.indexOf('(') < 0) {\n-                    refMemName += utils.makeSignature((ExecutableElement) refMem, null, true);\n-                }\n-                if (overriddenMethod != null) {\n-                    \/\/ The method to actually link.\n-                    refMem = overriddenMethod;\n-                }\n-            }\n-\n-            return htmlWriter.getDocLink(HtmlLinkInfo.Kind.SHOW_PREVIEW, containing,\n-                    refMem, (labelContent.isEmpty()\n-                            ? plainOrCode(isLinkPlain, Text.of(refMemName))\n-                            : labelContent), null, false);\n-        }\n-    }\n-\n-    private Content plainOrCode(boolean plain, Content body) {\n-        return (plain || body.isEmpty()) ? body : HtmlTree.CODE(body);\n-    }\n-\n-    @Override\n-    public Content simpleBlockTagOutput(Element element, List<? extends DocTree> simpleTags, String header) {\n-        CommentHelper ch = utils.getCommentHelper(element);\n-        ContentBuilder body = new ContentBuilder();\n-        boolean many = false;\n-        for (DocTree simpleTag : simpleTags) {\n-            if (many) {\n-                body.add(\", \");\n-            }\n-            List<? extends DocTree> bodyTags = ch.getBody(simpleTag);\n-            body.add(htmlWriter.commentTagsToContent(element, bodyTags, context.within(simpleTag)));\n-            many = true;\n-        }\n-        return new ContentBuilder(\n-                HtmlTree.DT(RawHtml.of(header)),\n-                HtmlTree.DD(body));\n-    }\n-\n-    @Override\n-    protected Content snippetTagOutput(Element element, SnippetTree tag, StyledText content,\n-                                       String id, String lang) {\n-        var pre = new HtmlTree(TagName.PRE).setStyle(HtmlStyle.snippet);\n-        if (id != null && !id.isBlank()) {\n-            pre.put(HtmlAttr.ID, id);\n-        }\n-        var code = new HtmlTree(TagName.CODE)\n-                .addUnchecked(Text.EMPTY); \/\/ Make sure the element is always rendered\n-        if (lang != null && !lang.isBlank()) {\n-            code.addStyle(\"language-\" + lang);\n-        }\n-\n-        content.consumeBy((styles, sequence) -> {\n-            CharSequence text = Text.normalizeNewlines(sequence);\n-            if (styles.isEmpty()) {\n-                code.add(text);\n-            } else {\n-                Element e = null;\n-                String t = null;\n-                boolean linkEncountered = false;\n-                boolean markupEncountered = false;\n-                Set<String> classes = new HashSet<>();\n-                for (Style s : styles) {\n-                    if (s instanceof Style.Name n) {\n-                        classes.add(n.name());\n-                    } else if (s instanceof Style.Link l) {\n-                        assert !linkEncountered; \/\/ TODO: do not assert; pick the first link report on subsequent\n-                        linkEncountered = true;\n-                        t = l.target();\n-                        e = getLinkedElement(element, t);\n-                        if (e == null) {\n-                            \/\/ TODO: diagnostic output\n-                        }\n-                    } else if (s instanceof Style.Markup) {\n-                        markupEncountered = true;\n-                        break;\n-                    } else {\n-                        \/\/ TODO: transform this if...else into an exhaustive\n-                        \/\/ switch over the sealed Style hierarchy when \"Pattern\n-                        \/\/ Matching for switch\" has been implemented (JEP 406\n-                        \/\/ and friends)\n-                        throw new AssertionError(styles);\n-                    }\n-                }\n-                Content c;\n-                if (markupEncountered) {\n-                    return;\n-                } else if (linkEncountered) {\n-                    assert e != null;\n-                    \/\/disable preview tagging inside the snippets:\n-                    PreviewFlagProvider prevPreviewProvider = utils.setPreviewFlagProvider(el -> false);\n-                    try {\n-                        c = linkSeeReferenceOutput(element,\n-                                null,\n-                                t,\n-                                e,\n-                                false, \/\/ TODO: for now\n-                                Text.of(sequence.toString()),\n-                                (key, args) -> { \/* TODO: report diagnostic *\/ });\n-                    } finally {\n-                        utils.setPreviewFlagProvider(prevPreviewProvider);\n-                    }\n-                } else {\n-                    c = HtmlTree.SPAN(Text.of(text));\n-                    classes.forEach(((HtmlTree) c)::addStyle);\n-                }\n-                code.add(c);\n-            }\n-        });\n-        String copyText = resources.getText(\"doclet.Copy_to_clipboard\");\n-        String copiedText = resources.getText(\"doclet.Copied_to_clipboard\");\n-        String copySnippetText = resources.getText(\"doclet.Copy_snippet_to_clipboard\");\n-        var snippetContainer = HtmlTree.DIV(HtmlStyle.snippetContainer,\n-                new HtmlTree(TagName.BUTTON)\n-                        .add(HtmlTree.SPAN(Text.of(copyText))\n-                                .put(HtmlAttr.DATA_COPIED, copiedText))\n-                        .add(new HtmlTree(TagName.IMG)\n-                                .put(HtmlAttr.SRC, htmlWriter.pathToRoot.resolve(DocPaths.CLIPBOARD_SVG).getPath())\n-                                .put(HtmlAttr.ALT, copySnippetText))\n-                        .addStyle(HtmlStyle.copy)\n-                        .addStyle(HtmlStyle.snippetCopy)\n-                        .put(HtmlAttr.ARIA_LABEL, copySnippetText)\n-                        .put(HtmlAttr.ONCLICK, \"copySnippet(this)\"));\n-        return snippetContainer.add(pre.add(code));\n-    }\n-\n-    \/*\n-     * Returns the element that is linked from the context of the referrer using\n-     * the provided signature; returns null if such element could not be found.\n-     *\n-     * This method is to be used when it is the target of the link that is\n-     * important, not the container of the link (e.g. was it an @see,\n-     * @link\/@linkplain or @snippet tags, etc.)\n-     *\/\n-    public Element getLinkedElement(Element referer, String signature) {\n-        var factory = utils.docTrees.getDocTreeFactory();\n-        var docCommentTree = utils.getDocCommentTree(referer);\n-        var rootPath = new DocTreePath(utils.getTreePath(referer), docCommentTree);\n-        var reference = factory.newReferenceTree(signature);\n-        var fabricatedPath = new DocTreePath(rootPath, reference);\n-        return utils.docTrees.getElement(fabricatedPath);\n-    }\n-\n-    @Override\n-    public Content specTagOutput(Element holder, List<? extends SpecTree> specTags) {\n-        if (specTags.isEmpty()) {\n-            return Text.EMPTY;\n-        }\n-\n-        List<Content> links = specTags.stream()\n-                .map(st -> specTagToContent(holder, st))\n-                .collect(Collectors.toList());\n-\n-        \/\/ Use a different style if any link label is longer than 30 chars or contains commas.\n-        boolean hasLongLabels = links.stream().anyMatch(this::isLongOrHasComma);\n-        var specList = HtmlTree.UL(hasLongLabels ? HtmlStyle.tagListLong : HtmlStyle.tagList);\n-        links.stream()\n-                .filter(Predicate.not(Content::isEmpty))\n-                .forEach(item -> specList.add(HtmlTree.LI(item)));\n-\n-        return new ContentBuilder(\n-                HtmlTree.DT(contents.externalSpecifications),\n-                HtmlTree.DD(specList));\n-    }\n-\n-    private Content specTagToContent(Element holder, SpecTree specTree) {\n-        String specTreeURL = specTree.getURL().getBody();\n-        List<? extends DocTree> specTreeLabel = specTree.getTitle();\n-        Content label = htmlWriter.commentTagsToContent(holder, specTreeLabel, isFirstSentence);\n-        return getExternalSpecContent(holder, specTree, specTreeURL,\n-                textOf(specTreeLabel).replaceAll(\"\\\\s+\", \" \"), label);\n-    }\n-\n-    Content getExternalSpecContent(Element holder, DocTree docTree, String url, String searchText, Content title) {\n-        URI specURI;\n-        try {\n-            \/\/ Use the canonical title of the spec if one is available\n-            specURI = new URI(url);\n-        } catch (URISyntaxException e) {\n-            CommentHelper ch = utils.getCommentHelper(holder);\n-            DocTreePath dtp = ch.getDocTreePath(docTree);\n-            htmlWriter.messages.error(dtp, \"doclet.Invalid_URL\", e.getMessage());\n-            specURI = null;\n-        }\n-\n-        Content titleWithAnchor = createAnchorAndSearchIndex(holder,\n-                searchText,\n-                title,\n-                resources.getText(\"doclet.External_Specification\"),\n-                docTree);\n-\n-        if (specURI == null) {\n-            return titleWithAnchor;\n-        } else {\n-            return HtmlTree.A(htmlWriter.resolveExternalSpecURI(specURI), titleWithAnchor);\n-        }\n-\n-    }\n-\n-    @Override\n-    protected Content systemPropertyTagOutput(Element element, SystemPropertyTree tag) {\n-        String tagText = tag.getPropertyName().toString();\n-        return HtmlTree.CODE(createAnchorAndSearchIndex(element, tagText,\n-                resources.getText(\"doclet.System_Property\"), tag));\n-    }\n-\n-    @Override\n-    public Content getThrowsHeader() {\n-        return HtmlTree.DT(contents.throws_);\n-    }\n-\n-    @Deprecated(forRemoval = true)\n-    private Content throwsTagOutput(Element element, ThrowsTree throwsTag, TypeMirror substituteType) {\n-        ContentBuilder body = new ContentBuilder();\n-        CommentHelper ch = utils.getCommentHelper(element);\n-        Element exception = ch.getException(throwsTag);\n-        Content excName;\n-        if (substituteType != null) {\n-            excName = htmlWriter.getLink(new HtmlLinkInfo(configuration, HtmlLinkInfo.Kind.PLAIN,\n-                   substituteType));\n-        } else if (exception == null) {\n-            excName = Text.of(throwsTag.getExceptionName().toString());\n-        } else if (exception.asType() == null) {\n-            excName = Text.of(utils.getFullyQualifiedName(exception));\n-        } else {\n-            HtmlLinkInfo link = new HtmlLinkInfo(configuration, HtmlLinkInfo.Kind.PLAIN,\n-                                                 exception.asType());\n-            excName = htmlWriter.getLink(link);\n-        }\n-        body.add(HtmlTree.CODE(excName));\n-        List<? extends DocTree> description = ch.getDescription(throwsTag);\n-        Content desc = htmlWriter.commentTagsToContent(element, description, context.within(throwsTag));\n-        if (desc != null && !desc.isEmpty()) {\n-            body.add(\" - \");\n-            body.add(desc);\n-        }\n-        return HtmlTree.DD(body);\n-    }\n-\n-    @Override\n-    public Content throwsTagOutput(TypeMirror throwsType, Optional<Content> content) {\n-        var linkInfo = new HtmlLinkInfo(configuration, HtmlLinkInfo.Kind.PLAIN, throwsType);\n-        var link = htmlWriter.getLink(linkInfo);\n-        var concat = new ContentBuilder(HtmlTree.CODE(link));\n-        if (content.isPresent()) {\n-            concat.add(\" - \");\n-            concat.add(content.get());\n-        }\n-        return HtmlTree.DD(concat);\n-    }\n-\n-    @Override\n-    public Content valueTagOutput(VariableElement field, String constantVal, boolean includeLink) {\n-        return includeLink\n-                ? htmlWriter.getDocLink(HtmlLinkInfo.Kind.LINK_TYPE_PARAMS_AND_BOUNDS, field, constantVal)\n-                : Text.of(constantVal);\n-    }\n-\n-    @Override\n-    protected Content invalidTagOutput(String summary, Optional<String> detail) {\n-        return htmlWriter.invalidTagOutput(summary,\n-                detail.isEmpty() || detail.get().isEmpty()\n-                        ? Optional.empty()\n-                        : Optional.of(Text.of(Text.normalizeNewlines(detail.get()))));\n-    }\n-\n-    @Override\n-    public Content commentTagsToOutput(DocTree holder, List<? extends DocTree> tags) {\n-        return commentTagsToOutput(null, holder, tags, false);\n-    }\n-\n-    @Override\n-    public Content commentTagsToOutput(Element element, List<? extends DocTree> tags) {\n-        return commentTagsToOutput(element, null, tags, false);\n-    }\n-\n-    @Override\n-    public Content commentTagsToOutput(Element holder,\n-                                       DocTree holderTag,\n-                                       List<? extends DocTree> tags,\n-                                       boolean isFirstSentence)\n-    {\n-        return htmlWriter.commentTagsToContent(holder,\n-                tags, holderTag == null ? context : context.within(holderTag));\n-    }\n-\n-    @Override\n-    public BaseConfiguration configuration() {\n-        return configuration;\n-    }\n-\n-    @Override\n-    protected TypeElement getCurrentPageElement() {\n-        return htmlWriter.getCurrentPageElement();\n-    }\n-\n-    public HtmlDocletWriter getHtmlWriter() {\n-        return htmlWriter;\n-    }\n-\n-    private Content createAnchorAndSearchIndex(Element element, String tagText, String desc, DocTree tree) {\n-        return createAnchorAndSearchIndex(element, tagText, Text.of(tagText), desc, tree);\n-    }\n-\n-    @SuppressWarnings(\"preview\")\n-    private Content createAnchorAndSearchIndex(Element element, String tagText, Content tagContent, String desc, DocTree tree) {\n-        Content result = null;\n-        if (context.isFirstSentence && context.inSummary || context.inTags.contains(DocTree.Kind.INDEX)) {\n-            result = tagContent;\n-        } else {\n-            HtmlId id = HtmlIds.forText(tagText, htmlWriter.indexAnchorTable);\n-            result = HtmlTree.SPAN(id, HtmlStyle.searchTagResult, tagContent);\n-            if (options.createIndex() && !tagText.isEmpty()) {\n-                String holder = getHolderName(element);\n-                IndexItem item = IndexItem.of(element, tree, tagText, holder, desc,\n-                        new DocLink(htmlWriter.path, id.name()));\n-                configuration.mainIndex.add(item);\n-            }\n-        }\n-        return result;\n-    }\n-\n-    String getHolderName(Element element) {\n-        return new SimpleElementVisitor14<String, Void>() {\n-\n-            @Override\n-            public String visitModule(ModuleElement e, Void p) {\n-                return resources.getText(\"doclet.module\")\n-                        + \" \" + utils.getFullyQualifiedName(e);\n-            }\n-\n-            @Override\n-            public String visitPackage(PackageElement e, Void p) {\n-                return resources.getText(\"doclet.package\")\n-                        + \" \" + utils.getFullyQualifiedName(e);\n-            }\n-\n-            @Override\n-            public String visitType(TypeElement e, Void p) {\n-                return utils.getTypeElementKindName(e, true)\n-                        + \" \" + utils.getFullyQualifiedName(e);\n-            }\n-\n-            @Override\n-            public String visitExecutable(ExecutableElement e, Void p) {\n-                return utils.getFullyQualifiedName(utils.getEnclosingTypeElement(e))\n-                        + \".\" + utils.getSimpleName(e)\n-                        + utils.flatSignature(e, htmlWriter.getCurrentPageElement());\n-            }\n-\n-            @Override\n-            public String visitVariable(VariableElement e, Void p) {\n-                return utils.getFullyQualifiedName(utils.getEnclosingTypeElement(e))\n-                        + \".\" + utils.getSimpleName(e);\n-            }\n-\n-            @Override\n-            public String visitUnknown(Element e, Void p) {\n-                if (e instanceof DocletElement de) {\n-                    return switch (de.getSubKind()) {\n-                        case OVERVIEW -> resources.getText(\"doclet.Overview\");\n-                        case DOCFILE -> getHolderName(de);\n-                    };\n-                } else {\n-                    return super.visitUnknown(e, p);\n-                }\n-            }\n-\n-            @Override\n-            protected String defaultAction(Element e, Void p) {\n-                return utils.getFullyQualifiedName(e);\n-            }\n-        }.visit(element);\n-    }\n-\n-    private String getHolderName(DocletElement de) {\n-        PackageElement pe = de.getPackageElement();\n-        if (pe.isUnnamed()) {\n-            \/\/ if package is unnamed use enclosing module only if it is named\n-            Element ee = pe.getEnclosingElement();\n-            if (ee instanceof ModuleElement && !((ModuleElement)ee).isUnnamed()) {\n-                return resources.getText(\"doclet.module\") + \" \" + utils.getFullyQualifiedName(ee);\n-            }\n-            return pe.toString(); \/\/ \"Unnamed package\" or similar\n-        }\n-        return resources.getText(\"doclet.package\") + \" \" + utils.getFullyQualifiedName(pe);\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/TagletWriterImpl.java","additions":0,"deletions":985,"binary":false,"changes":985,"status":"deleted"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html.taglets;\n+\n+import java.util.List;\n+\n+import javax.lang.model.element.Element;\n+\n+import com.sun.source.doctree.DeprecatedTree;\n+import com.sun.source.doctree.DocTree;\n+\n+import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n+import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n+import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.toolkit.taglets.DeprecatedTaglet;\n+import jdk.javadoc.internal.doclets.toolkit.taglets.TagletWriter;\n+import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;\n+\n+public class HtmlDeprecatedTaglet extends DeprecatedTaglet {\n+    HtmlDeprecatedTaglet(HtmlConfiguration config) {\n+        super(config);\n+    }\n+\n+    @Override\n+    public Content getAllBlockTagOutput(Element element, TagletWriter tagletWriter) {\n+        var tw = (TagletWriterImpl) tagletWriter;\n+        var htmlWriter = tw.getHtmlWriter();\n+\n+        ContentBuilder result = new ContentBuilder();\n+        CommentHelper ch = utils.getCommentHelper(element);\n+        List<? extends DeprecatedTree> deprs = utils.getDeprecatedTrees(element);\n+        if (utils.isTypeElement(element)) {\n+            if (utils.isDeprecated(element)) {\n+                result.add(HtmlTree.SPAN(HtmlStyle.deprecatedLabel,\n+                        htmlWriter.getDeprecatedPhrase(element)));\n+                if (!deprs.isEmpty()) {\n+                    List<? extends DocTree> commentTrees = ch.getDescription(deprs.get(0));\n+                    if (!commentTrees.isEmpty()) {\n+                        result.add(tw.commentTagsToOutput(element, null, commentTrees, false));\n+                    }\n+                }\n+            }\n+        } else {\n+            if (utils.isDeprecated(element)) {\n+                result.add(HtmlTree.SPAN(HtmlStyle.deprecatedLabel,\n+                        tw.getHtmlWriter().getDeprecatedPhrase(element)));\n+                if (!deprs.isEmpty()) {\n+                    List<? extends DocTree> bodyTrees = ch.getBody(deprs.get(0));\n+                    Content body = tw.commentTagsToOutput(element, null, bodyTrees, false);\n+                    if (!body.isEmpty())\n+                        result.add(HtmlTree.DIV(HtmlStyle.deprecationComment, body));\n+                }\n+            } else {\n+                Element ee = utils.getEnclosingTypeElement(element);\n+                if (utils.isDeprecated(ee)) {\n+                    result.add(HtmlTree.SPAN(HtmlStyle.deprecatedLabel,\n+                            htmlWriter.getDeprecatedPhrase(ee)));\n+                }\n+            }\n+        }\n+        return result;\n+\n+    }\n+\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/HtmlDeprecatedTaglet.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html.taglets;\n+\n+import javax.lang.model.element.Element;\n+\n+import com.sun.source.doctree.DocTree;\n+\n+import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n+import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n+import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.toolkit.taglets.DocRootTaglet;\n+import jdk.javadoc.internal.doclets.toolkit.taglets.TagletWriter;\n+\n+public class HtmlDocRootTaglet extends DocRootTaglet {\n+    HtmlDocRootTaglet(HtmlConfiguration config) {\n+        super(config);\n+    }\n+\n+    @Override\n+    public Content getInlineTagOutput(Element holder, DocTree tag, TagletWriter tagletWriter) {\n+        var tw = (TagletWriterImpl) tagletWriter;\n+        var pathToRoot = tw.getHtmlWriter().pathToRoot;\n+        return Text.of(pathToRoot.isEmpty() ? \".\" : pathToRoot.getPath());\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/HtmlDocRootTaglet.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html.taglets;\n+\n+import javax.lang.model.element.Element;\n+\n+import com.sun.source.doctree.DocTree;\n+import com.sun.source.doctree.IndexTree;\n+import com.sun.source.doctree.TextTree;\n+\n+import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n+import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.toolkit.taglets.IndexTaglet;\n+import jdk.javadoc.internal.doclets.toolkit.taglets.TagletWriter;\n+\n+public class HtmlIndexTaglet extends IndexTaglet {\n+    HtmlIndexTaglet(HtmlConfiguration config) {\n+        super(config);\n+    }\n+\n+    @Override\n+    public Content getInlineTagOutput(Element element, DocTree tag, TagletWriter tagletWriter) {\n+        var indexTree = (IndexTree) tag;\n+        var tw = (TagletWriterImpl) tagletWriter;\n+\n+        DocTree searchTerm = indexTree.getSearchTerm();\n+        String tagText = (searchTerm instanceof TextTree tt) ? tt.getBody() : \"\";\n+        if (tagText.charAt(0) == '\"' && tagText.charAt(tagText.length() - 1) == '\"') {\n+            tagText = tagText.substring(1, tagText.length() - 1);\n+        }\n+        tagText = tagText.replaceAll(\"\\\\s+\", \" \");\n+\n+        Content desc = tw.getHtmlWriter().commentTagsToContent(element, indexTree.getDescription(), tw.getContext().within(indexTree));\n+        String descText = extractText(desc);\n+\n+        return tw.createAnchorAndSearchIndex(element, tagText, descText, tag);\n+    }\n+\n+\n+    \/\/ ugly but simple;\n+    \/\/ alternatives would be to walk the Content's tree structure, or to add new functionality to Content\n+    private String extractText(Content c) {\n+        return c.toString().replaceAll(\"<[^>]+>\", \"\");\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/HtmlIndexTaglet.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,272 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html.taglets;\n+\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.BiConsumer;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.ModuleElement;\n+import javax.lang.model.element.PackageElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.type.TypeMirror;\n+\n+import com.sun.source.doctree.DocTree;\n+import com.sun.source.doctree.LinkTree;\n+import com.sun.source.util.DocTreePath;\n+\n+import jdk.javadoc.internal.doclets.formats.html.ClassWriterImpl;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlLinkInfo;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n+import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n+import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.toolkit.taglets.LinkTaglet;\n+import jdk.javadoc.internal.doclets.toolkit.taglets.TagletWriter;\n+import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;\n+import jdk.javadoc.internal.doclets.toolkit.util.DocLink;\n+import jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable;\n+\n+import static com.sun.source.doctree.DocTree.Kind.LINK;\n+import static com.sun.source.doctree.DocTree.Kind.LINK_PLAIN;\n+import static com.sun.source.doctree.DocTree.Kind.SEE;\n+\n+public class HtmlLinkTaglet extends LinkTaglet {\n+    HtmlLinkTaglet(HtmlConfiguration config, DocTree.Kind tagKind) {\n+        super(config, tagKind);\n+    }\n+\n+    @Override\n+    public Content getInlineTagOutput(Element element, DocTree tag, TagletWriter tagletWriter) {\n+        var linkTree = (LinkTree) tag;\n+        var tw = (TagletWriterImpl) tagletWriter;\n+        var ch = utils.getCommentHelper(element);\n+        var context = tw.getContext();\n+\n+        var inTags = context.inTags;\n+        if (inTags.contains(LINK) || inTags.contains(LINK_PLAIN) || inTags.contains(SEE)) {\n+            DocTreePath dtp = ch.getDocTreePath(linkTree);\n+            if (dtp != null) {\n+                messages.warning(dtp, \"doclet.see.nested_link\", \"{@\" + linkTree.getTagName() + \"}\");\n+            }\n+            Content label = tw.getHtmlWriter().commentTagsToContent(element, linkTree.getLabel(), context.within(linkTree));\n+            if (label.isEmpty()) {\n+                label = Text.of(linkTree.getReference().getSignature());\n+            }\n+            return label;\n+        }\n+\n+        var linkRef = linkTree.getReference();\n+        if (linkRef == null) {\n+            messages.warning(ch.getDocTreePath(tag), \"doclet.link.no_reference\");\n+            return tagletWriter.invalidTagOutput(resources.getText(\"doclet.tag.invalid_input\", tag.toString()),\n+                    Optional.empty());\n+        }\n+\n+        DocTree.Kind kind = tag.getKind();\n+        String refSignature = ch.getReferencedSignature(linkRef);\n+\n+        return linkSeeReferenceOutput(element,\n+                tag,\n+                refSignature,\n+                ch.getReferencedElement(tag),\n+                (kind == LINK_PLAIN),\n+                tw.getHtmlWriter().commentTagsToContent(element, linkTree.getLabel(), context.within(linkTree)),\n+                (key, args) -> messages.warning(ch.getDocTreePath(tag), key, args),\n+                tagletWriter);\n+    }\n+\n+    \/**\n+     * Worker method to generate a link from the information in different kinds of tags,\n+     * such as {@code {@link ...}} tags, {@code @see ...} tags and the {@code link} markup tag\n+     * in a {@code {@snippet ...}} tag.\n+     *\n+     * @param holder        the element that has the documentation comment containing the information\n+     * @param refTree       the tree node containing the information, or {@code null} if not available\n+     * @param refSignature  the normalized signature of the target of the reference\n+     * @param ref           the target of the reference\n+     * @param isLinkPlain   {@code true} if the link should be presented in \"plain\" font,\n+     *                      or {@code false} for \"code\" font\n+     * @param label         the label for the link,\n+     *                      or an empty item to use a default label derived from the signature\n+     * @param reportWarning a function to report warnings about issues found in the reference\n+     *\n+     * @return the output containing the generated link, or content indicating an error\n+     *\/\n+    Content linkSeeReferenceOutput(Element holder,\n+                                   DocTree refTree,\n+                                   String refSignature,\n+                                   Element ref,\n+                                   boolean isLinkPlain,\n+                                   Content label,\n+                                   BiConsumer<String, Object[]> reportWarning,\n+                                   TagletWriter writer) {\n+        var config = (HtmlConfiguration) this.config;\n+        var tw = (TagletWriterImpl) writer;\n+        var htmlWriter = tw.getHtmlWriter();\n+\n+        Content labelContent = plainOrCode(isLinkPlain, label);\n+\n+        \/\/ The signature from the @see tag. We will output this text when a label is not specified.\n+        Content text = plainOrCode(isLinkPlain,\n+                Text.of(Objects.requireNonNullElse(refSignature, \"\")));\n+\n+        CommentHelper ch = utils.getCommentHelper(holder);\n+        TypeElement refClass = ch.getReferencedClass(ref);\n+        Element refMem =       ch.getReferencedMember(ref);\n+        String refFragment =   ch.getReferencedFragment(refSignature);\n+\n+        if (refFragment == null && refMem != null) {\n+            refFragment = refMem.toString();\n+        } else if (refFragment != null && refFragment.startsWith(\"#\")) {\n+            if (labelContent.isEmpty()) {\n+                \/\/ A non-empty label is required for fragment links as the\n+                \/\/ reference target does not provide a useful default label.\n+                htmlWriter.messages.error(ch.getDocTreePath(refTree), \"doclet.link.see.no_label\");\n+                return writer.invalidTagOutput(resources.getText(\"doclet.link.see.no_label\"),\n+                        Optional.of(refSignature));\n+            }\n+            refFragment = refFragment.substring(1);\n+        }\n+        if (refClass == null) {\n+            ModuleElement refModule = ch.getReferencedModule(ref);\n+            if (refModule != null && utils.isIncluded(refModule)) {\n+                return htmlWriter.getModuleLink(refModule, labelContent.isEmpty() ? text : labelContent, refFragment);\n+            }\n+            \/\/@see is not referencing an included class\n+            PackageElement refPackage = ch.getReferencedPackage(ref);\n+            if (refPackage != null && utils.isIncluded(refPackage)) {\n+                \/\/@see is referencing an included package\n+                if (labelContent.isEmpty()) {\n+                    labelContent = plainOrCode(isLinkPlain,\n+                            Text.of(refPackage.getQualifiedName()));\n+                }\n+                return htmlWriter.getPackageLink(refPackage, labelContent, refFragment);\n+            } else {\n+                \/\/ @see is not referencing an included class, module or package. Check for cross-links.\n+                String refModuleName =  ch.getReferencedModuleName(refSignature);\n+                DocLink elementCrossLink = (refPackage != null) ? htmlWriter.getCrossPackageLink(refPackage) :\n+                        (config.extern.isModule(refModuleName))\n+                                ? htmlWriter.getCrossModuleLink(utils.elementUtils.getModuleElement(refModuleName))\n+                                : null;\n+                if (elementCrossLink != null) {\n+                    \/\/ Element cross-link found\n+                    return htmlWriter.links.createExternalLink(elementCrossLink,\n+                            (labelContent.isEmpty() ? text : labelContent));\n+                } else {\n+                    \/\/ No cross-link found so print warning\n+                    if (!config.isDocLintReferenceGroupEnabled()) {\n+                        reportWarning.accept(\n+                                \"doclet.link.see.reference_not_found\",\n+                                new Object[] { refSignature});\n+                    }\n+                    return htmlWriter.invalidTagOutput(resources.getText(\"doclet.link.see.reference_invalid\"),\n+                            Optional.of(labelContent.isEmpty() ? text: labelContent));\n+                }\n+            }\n+        } else if (refFragment == null) {\n+            \/\/ Must be a class reference since refClass is not null and refFragment is null.\n+            if (labelContent.isEmpty() && refTree != null) {\n+                TypeMirror referencedType = ch.getReferencedType(refTree);\n+                if (utils.isGenericType(referencedType)) {\n+                    \/\/ This is a generic type link, use the TypeMirror representation.\n+                    return plainOrCode(isLinkPlain, htmlWriter.getLink(\n+                            new HtmlLinkInfo(config, HtmlLinkInfo.Kind.LINK_TYPE_PARAMS_AND_BOUNDS, referencedType)));\n+                }\n+                labelContent = plainOrCode(isLinkPlain, Text.of(utils.getSimpleName(refClass)));\n+            }\n+            return htmlWriter.getLink(new HtmlLinkInfo(config, HtmlLinkInfo.Kind.PLAIN, refClass)\n+                    .label(labelContent));\n+        } else if (refMem == null) {\n+            \/\/ This is a fragment reference since refClass and refFragment are not null but refMem is null.\n+            return htmlWriter.getLink(new HtmlLinkInfo(config, HtmlLinkInfo.Kind.PLAIN, refClass)\n+                    .label(labelContent)\n+                    .fragment(refFragment)\n+                    .style(null));\n+        } else {\n+            \/\/ Must be a member reference since refClass is not null and refMemName is not null.\n+            \/\/ refMem is not null, so this @see tag must be referencing a valid member.\n+            TypeElement containing = utils.getEnclosingTypeElement(refMem);\n+\n+            \/\/ Find the enclosing type where the method is actually visible\n+            \/\/ in the inheritance hierarchy.\n+            ExecutableElement overriddenMethod = null;\n+            if (refMem.getKind() == ElementKind.METHOD) {\n+                VisibleMemberTable vmt = config.getVisibleMemberTable(containing);\n+                overriddenMethod = vmt.getOverriddenMethod((ExecutableElement)refMem);\n+\n+                if (overriddenMethod != null) {\n+                    containing = utils.getEnclosingTypeElement(overriddenMethod);\n+                }\n+            }\n+            if (refSignature.trim().startsWith(\"#\") &&\n+                    ! (utils.isPublic(containing) || utils.isLinkable(containing))) {\n+                \/\/ Since the link is relative and the holder is not even being\n+                \/\/ documented, this must be an inherited link.  Redirect it.\n+                \/\/ The current class either overrides the referenced member or\n+                \/\/ inherits it automatically.\n+                if (htmlWriter instanceof ClassWriterImpl cw) {\n+                    containing = cw.getTypeElement();\n+                } else if (!utils.isPublic(containing)) {\n+                    reportWarning.accept(\"doclet.link.see.reference_not_accessible\",\n+                            new Object[] { utils.getFullyQualifiedName(containing)});\n+                } else {\n+                    if (!config.isDocLintReferenceGroupEnabled()) {\n+                        reportWarning.accept(\"doclet.link.see.reference_not_found\",\n+                                new Object[] { refSignature });\n+                    }\n+                }\n+            }\n+            String refMemName = refFragment;\n+            if (config.currentTypeElement != containing) {\n+                refMemName = (utils.isConstructor(refMem))\n+                        ? refMemName\n+                        : utils.getSimpleName(containing) + \".\" + refMemName;\n+            }\n+            if (utils.isExecutableElement(refMem)) {\n+                if (refMemName.indexOf('(') < 0) {\n+                    refMemName += utils.makeSignature((ExecutableElement) refMem, null, true);\n+                }\n+                if (overriddenMethod != null) {\n+                    \/\/ The method to actually link.\n+                    refMem = overriddenMethod;\n+                }\n+            }\n+\n+            return htmlWriter.getDocLink(HtmlLinkInfo.Kind.SHOW_PREVIEW, containing,\n+                    refMem, (labelContent.isEmpty()\n+                            ? plainOrCode(isLinkPlain, Text.of(refMemName))\n+                            : labelContent), null, false);\n+        }\n+    }\n+\n+    private Content plainOrCode(boolean plain, Content body) {\n+        return (plain || body.isEmpty()) ? body : HtmlTree.CODE(body);\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/HtmlLinkTaglet.java","additions":272,"deletions":0,"binary":false,"changes":272,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html.taglets;\n+\n+import javax.lang.model.element.Element;\n+\n+import com.sun.source.doctree.DocTree;\n+import com.sun.source.doctree.LiteralTree;\n+\n+import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n+import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n+import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.toolkit.taglets.LiteralTaglet;\n+import jdk.javadoc.internal.doclets.toolkit.taglets.TagletWriter;\n+\n+public class HtmlLiteralTaglet extends LiteralTaglet {\n+    HtmlLiteralTaglet(HtmlConfiguration config, DocTree.Kind tagKind) {\n+        super(config, tagKind);\n+    }\n+\n+    @Override\n+    public Content getInlineTagOutput(Element element, DocTree tag, TagletWriter tagletWriter) {\n+        var literalTree = (LiteralTree) tag;\n+        var body = Text.of(Text.normalizeNewlines(literalTree.getBody().getBody()));\n+        return tag.getKind() == DocTree.Kind.CODE ? HtmlTree.CODE(body) : body;\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/HtmlLiteralTaglet.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html.taglets;\n+\n+import java.util.List;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ElementKind;\n+\n+import com.sun.source.doctree.DocTree;\n+import com.sun.source.doctree.ParamTree;\n+\n+import jdk.javadoc.internal.doclets.formats.html.Contents;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlIds;\n+import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n+import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n+import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.toolkit.taglets.ParamTaglet;\n+import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;\n+\n+public class HtmlParamTaglet extends ParamTaglet {\n+    private final Contents contents;\n+\n+    HtmlParamTaglet(HtmlConfiguration config) {\n+        super(config);\n+        contents = config.contents;\n+    }\n+\n+    @Override\n+    public Content getParamHeader(ParamTaglet.ParamKind kind) {\n+        var header = switch (kind) {\n+            case PARAMETER -> contents.parameters;\n+            case TYPE_PARAMETER -> contents.typeParameters;\n+            case RECORD_COMPONENT -> contents.recordComponents;\n+        };\n+        return HtmlTree.DT(header);\n+    }\n+\n+    @Override\n+    public Content paramTagOutput(Element element, ParamTree paramTag, String paramName) {\n+        var body = new ContentBuilder();\n+        var tw = (TagletWriterImpl) tagletWriter;\n+        CommentHelper ch = utils.getCommentHelper(element);\n+        \/\/ define id attributes for state components so that generated descriptions may refer to them\n+        boolean defineID = (element.getKind() == ElementKind.RECORD)\n+                && !paramTag.isTypeParameter();\n+        Content nameContent = Text.of(paramName);\n+        body.add(HtmlTree.CODE(defineID ? HtmlTree.SPAN_ID(HtmlIds.forParam(paramName), nameContent) : nameContent));\n+        body.add(\" - \");\n+        List<? extends DocTree> description = ch.getDescription(paramTag);\n+        body.add(tw.getHtmlWriter().commentTagsToContent(element, description, tw.getContext().within(paramTag)));\n+        return HtmlTree.DD(body);\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/HtmlParamTaglet.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html.taglets;\n+\n+import java.util.List;\n+\n+import javax.lang.model.element.Element;\n+\n+import com.sun.source.doctree.DocTree;\n+import com.sun.source.doctree.ReturnTree;\n+\n+import jdk.javadoc.internal.doclets.formats.html.Contents;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n+import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n+import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.toolkit.taglets.ReturnTaglet;\n+\n+public class HtmlReturnTaglet extends ReturnTaglet {\n+    private final Contents contents;\n+\n+    HtmlReturnTaglet(HtmlConfiguration config) {\n+        super(config);\n+        contents = config.contents;\n+    }\n+\n+    @Override\n+    public Content returnTagOutput(Element element, ReturnTree returnTag, boolean inline) {\n+        var tw = (TagletWriterImpl) tagletWriter;\n+        var ch = utils.getCommentHelper(element);\n+        List<? extends DocTree> desc = ch.getDescription(returnTag);\n+        Content content = tw.getHtmlWriter().commentTagsToContent(element, desc, tw.getContext().within(returnTag));\n+        return inline\n+                ? new ContentBuilder(contents.getContent(\"doclet.Returns_0\", content))\n+                : new ContentBuilder(HtmlTree.DT(contents.returns), HtmlTree.DD(content));\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/HtmlReturnTaglet.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -0,0 +1,159 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html.taglets;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+\n+import com.sun.source.doctree.DocTree;\n+import com.sun.source.doctree.SeeTree;\n+\n+import jdk.javadoc.internal.doclets.formats.html.ClassWriterImpl;\n+import jdk.javadoc.internal.doclets.formats.html.Contents;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlDocletWriter;\n+import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n+import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n+import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.toolkit.builders.SerializedFormBuilder;\n+import jdk.javadoc.internal.doclets.toolkit.taglets.SeeTaglet;\n+import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;\n+import jdk.javadoc.internal.doclets.toolkit.util.DocLink;\n+import jdk.javadoc.internal.doclets.toolkit.util.DocPath;\n+import jdk.javadoc.internal.doclets.toolkit.util.DocPaths;\n+\n+public class HtmlSeeTaglet extends SeeTaglet {\n+    HtmlSeeTaglet(HtmlConfiguration config) {\n+        super(config);\n+        contents = config.contents;\n+    }\n+\n+    private final Contents contents;\n+    private HtmlDocletWriter htmlWriter;\n+\n+    @Override\n+    public Content seeTagOutput(Element holder, List<? extends SeeTree> seeTags) {\n+        var tw = (TagletWriterImpl) tagletWriter;\n+        htmlWriter = tw.getHtmlWriter();\n+\n+        List<Content> links = new ArrayList<>();\n+        for (SeeTree dt : seeTags) {\n+            links.add(seeTagOutput(holder, dt));\n+        }\n+        if (utils.isVariableElement(holder) && ((VariableElement)holder).getConstantValue() != null &&\n+                htmlWriter instanceof ClassWriterImpl classWriter) {\n+            \/\/Automatically add link to constant values page for constant fields.\n+            DocPath constantsPath =\n+                    htmlWriter.pathToRoot.resolve(DocPaths.CONSTANT_VALUES);\n+            String whichConstant =\n+                    classWriter.getTypeElement().getQualifiedName() + \".\" +\n+                            utils.getSimpleName(holder);\n+            DocLink link = constantsPath.fragment(whichConstant);\n+            links.add(htmlWriter.links.createLink(link,\n+                    contents.getContent(\"doclet.Constants_Summary\")));\n+        }\n+        if (utils.isClass(holder) && utils.isSerializable((TypeElement)holder)) {\n+            \/\/Automatically add link to serialized form page for serializable classes.\n+            if (SerializedFormBuilder.serialInclude(utils, holder) &&\n+                    SerializedFormBuilder.serialInclude(utils, utils.containingPackage(holder))) {\n+                DocPath serialPath = htmlWriter.pathToRoot.resolve(DocPaths.SERIALIZED_FORM);\n+                DocLink link = serialPath.fragment(utils.getFullyQualifiedName(holder));\n+                links.add(htmlWriter.links.createLink(link,\n+                        contents.getContent(\"doclet.Serialized_Form\")));\n+            }\n+        }\n+        if (links.isEmpty()) {\n+            return Text.EMPTY;\n+        }\n+\n+        var seeList = tw.tagList(links);\n+        return new ContentBuilder(\n+                HtmlTree.DT(contents.seeAlso),\n+                HtmlTree.DD(seeList));\n+    }\n+\n+\/\/    private boolean isLongOrHasComma(Content c) {\n+\/\/        String s = c.toString()\n+\/\/                .replaceAll(\"<.*?>\", \"\")              \/\/ ignore HTML\n+\/\/                .replaceAll(\"&#?[A-Za-z0-9]+;\", \" \")  \/\/ entities count as a single character\n+\/\/                .replaceAll(\"\\\\R\", \"\\n\");             \/\/ normalize newlines\n+\/\/        return s.length() > TAG_LIST_ITEM_MAX_INLINE_LENGTH || s.contains(\",\");\n+\/\/    }\n+\n+    \/**\n+     * {@return the output for a single {@code @see} tag}\n+     *\n+     * @param element the element that has the documentation comment containing this tag\n+     * @param seeTag  the tag\n+     *\/\n+    private Content seeTagOutput(Element element, SeeTree seeTag) {\n+\n+        List<? extends DocTree> ref = seeTag.getReference();\n+        assert !ref.isEmpty();\n+        DocTree ref0 = ref.get(0);\n+        switch (ref0.getKind()) {\n+            case TEXT, START_ELEMENT -> {\n+                \/\/ @see \"Reference\"\n+                \/\/ @see <a href=\"...\">...<\/a>\n+                return htmlWriter.commentTagsToContent(element, ref, false, false);\n+            }\n+\n+            case REFERENCE -> {\n+                \/\/ @see reference label...\n+                CommentHelper ch = utils.getCommentHelper(element);\n+                String refSignature = ch.getReferencedSignature(ref0);\n+                List<? extends DocTree> label = ref.subList(1, ref.size());\n+\n+                var lt = (HtmlLinkTaglet) config.tagletManager.getTaglet(DocTree.Kind.LINK);\n+                return lt.linkSeeReferenceOutput(element,\n+                        seeTag,\n+                        refSignature,\n+                        ch.getReferencedElement(seeTag),\n+                        false,\n+                        htmlWriter.commentTagsToContent(element, label, tagletWriter.getContext().within(seeTag)),\n+                        (key, args) -> messages.warning(ch.getDocTreePath(seeTag), key, args),\n+                        tagletWriter\n+                );\n+            }\n+\n+            case ERRONEOUS -> {\n+                return tagletWriter.invalidTagOutput(resources.getText(\"doclet.tag.invalid_input\",\n+                                ref0.toString()),\n+                        Optional.empty());\n+            }\n+\n+            default -> throw new IllegalStateException(ref0.getKind().toString());\n+        }\n+\n+    }\n+\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/HtmlSeeTaglet.java","additions":159,"deletions":0,"binary":false,"changes":159,"status":"added"},{"patch":"@@ -0,0 +1,158 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html.taglets;\n+\n+import java.util.EnumSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import javax.lang.model.element.Element;\n+\n+import com.sun.source.doctree.DocTree;\n+\n+import jdk.javadoc.doclet.Taglet;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n+import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n+import jdk.javadoc.internal.doclets.formats.html.markup.RawHtml;\n+import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.toolkit.taglets.SimpleTaglet;\n+import jdk.javadoc.internal.doclets.toolkit.taglets.TagletWriter;\n+\n+public class HtmlSimpleTaglet extends SimpleTaglet {\n+\n+\n+    \/**\n+     * Constructs a {@code HtmlSimpleTaglet}.\n+     *\n+     * @param tagName   the name of this tag\n+     * @param header    the header to output\n+     * @param locations the possible locations that this tag can appear in\n+     *                  The string can contain 'p' for package, 't' for type,\n+     *                  'm' for method, 'c' for constructor and 'f' for field.\n+     *                  See {@link #getLocations(String) getLocations} for the\n+     *                  complete list.\n+     *\/\n+    HtmlSimpleTaglet(HtmlConfiguration config, String tagName, String header, String locations) {\n+        super(config, tagName, header, getLocations(locations), isEnabled(locations));\n+    }\n+\n+    \/**\n+     * Constructs a {@code HtmlSimpleTaglet}.\n+     *\n+     * @param tagKind   the kind of this tag\n+     * @param header    the header to output\n+     * @param locations the possible locations that this tag can appear in\n+     *\/\n+    HtmlSimpleTaglet(HtmlConfiguration config, DocTree.Kind tagKind, String header, Set<Taglet.Location> locations) {\n+        super(config, tagKind, header, locations, true);\n+    }\n+\n+    \/**\n+     * Constructs a {@code HtmlSimpleTaglet}.\n+     *\n+     * @param tagName   the name of this tag\n+     * @param header    the header to output\n+     * @param locations the possible locations that this tag can appear in\n+     *\/\n+    HtmlSimpleTaglet(HtmlConfiguration config, String tagName, String header, Set<Taglet.Location> locations) {\n+        super(config, tagName, header, locations, true);\n+    }\n+\n+    \/**\n+     * Constructs a {@code HtmlSimpleTaglet}.\n+     *\n+     * @param tagKind   the kind of this tag\n+     * @param header    the header to output\n+     * @param locations the possible locations that this tag can appear in\n+     *\/\n+    HtmlSimpleTaglet(HtmlConfiguration config, DocTree.Kind tagKind, String header, Set<Taglet.Location> locations, boolean enabled) {\n+        super(config, tagKind, header, locations, enabled);\n+    }\n+\n+    private static Set<Taglet.Location> getLocations(String locations) {\n+        Set<Taglet.Location> set = EnumSet.noneOf(Taglet.Location.class);\n+        for (int i = 0; i < locations.length(); i++) {\n+            switch (locations.charAt(i)) {\n+                case 'a':  case 'A':\n+                    return EnumSet.allOf(Taglet.Location.class);\n+                case 'c':  case 'C':\n+                    set.add(Taglet.Location.CONSTRUCTOR);\n+                    break;\n+                case 'f':  case 'F':\n+                    set.add(Taglet.Location.FIELD);\n+                    break;\n+                case 'm':  case 'M':\n+                    set.add(Taglet.Location.METHOD);\n+                    break;\n+                case 'o':  case 'O':\n+                    set.add(Taglet.Location.OVERVIEW);\n+                    break;\n+                case 'p':  case 'P':\n+                    set.add(Taglet.Location.PACKAGE);\n+                    break;\n+                case 's':  case 'S':        \/\/ super-packages, anyone?\n+                    set.add(Taglet.Location.MODULE);\n+                    break;\n+                case 't':  case 'T':\n+                    set.add(Taglet.Location.TYPE);\n+                    break;\n+                case 'x':  case 'X':\n+                    break;\n+            }\n+        }\n+        return set;\n+    }\n+\n+    private static boolean isEnabled(String locations) {\n+        return locations.matches(\"[^Xx]*\");\n+    }\n+\n+    @Override\n+    public Content simpleBlockTagOutput(Element element,\n+                                        List<? extends DocTree> simpleTags,\n+                                        String header,\n+                                        TagletWriter writer) {\n+        TagletWriterImpl tw = (TagletWriterImpl) writer;\n+        var ch = utils.getCommentHelper(element);\n+        var htmlWriter = tw.getHtmlWriter();\n+        var context = tw.getContext();\n+\n+        ContentBuilder body = new ContentBuilder();\n+        boolean many = false;\n+        for (DocTree simpleTag : simpleTags) {\n+            if (many) {\n+                body.add(\", \");\n+            }\n+            List<? extends DocTree> bodyTags = ch.getBody(simpleTag);\n+            body.add(htmlWriter.commentTagsToContent(element, bodyTags, context.within(simpleTag)));\n+            many = true;\n+        }\n+        return new ContentBuilder(\n+                HtmlTree.DT(RawHtml.of(header)),\n+                HtmlTree.DD(body));\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/HtmlSimpleTaglet.java","additions":158,"deletions":0,"binary":false,"changes":158,"status":"added"},{"patch":"@@ -0,0 +1,161 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html.taglets;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import javax.lang.model.element.Element;\n+\n+import com.sun.source.doctree.DocTree;\n+import com.sun.source.doctree.SnippetTree;\n+import com.sun.source.util.DocTreePath;\n+\n+import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlAttr;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n+import jdk.javadoc.internal.doclets.formats.html.markup.TagName;\n+import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n+import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.toolkit.taglets.SnippetTaglet;\n+import jdk.javadoc.internal.doclets.toolkit.taglets.snippet.Style;\n+import jdk.javadoc.internal.doclets.toolkit.taglets.snippet.StyledText;\n+import jdk.javadoc.internal.doclets.toolkit.util.DocPaths;\n+import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n+\n+public class HtmlSnippetTaglet extends SnippetTaglet {\n+    HtmlSnippetTaglet(HtmlConfiguration config) {\n+        super(config);\n+    }\n+\n+    @Override\n+    protected Content snippetTagOutput(Element element, SnippetTree tag, StyledText content,\n+                                       String id, String lang) {\n+        var tw = (TagletWriterImpl) tagletWriter;\n+        var pre = new HtmlTree(TagName.PRE).setStyle(HtmlStyle.snippet);\n+        if (id != null && !id.isBlank()) {\n+            pre.put(HtmlAttr.ID, id);\n+        }\n+        var code = new HtmlTree(TagName.CODE)\n+                .addUnchecked(Text.EMPTY); \/\/ Make sure the element is always rendered\n+        if (lang != null && !lang.isBlank()) {\n+            code.addStyle(\"language-\" + lang);\n+        }\n+\n+        content.consumeBy((styles, sequence) -> {\n+            CharSequence text = Text.normalizeNewlines(sequence);\n+            if (styles.isEmpty()) {\n+                code.add(text);\n+            } else {\n+                Element e = null;\n+                String t = null;\n+                boolean linkEncountered = false;\n+                boolean markupEncountered = false;\n+                Set<String> classes = new HashSet<>();\n+                for (Style s : styles) {\n+                    if (s instanceof Style.Name n) {\n+                        classes.add(n.name());\n+                    } else if (s instanceof Style.Link l) {\n+                        assert !linkEncountered; \/\/ TODO: do not assert; pick the first link report on subsequent\n+                        linkEncountered = true;\n+                        t = l.target();\n+                        e = getLinkedElement(element, t);\n+                        if (e == null) {\n+                            \/\/ TODO: diagnostic output\n+                        }\n+                    } else if (s instanceof Style.Markup) {\n+                        markupEncountered = true;\n+                        break;\n+                    } else {\n+                        \/\/ TODO: transform this if...else into an exhaustive\n+                        \/\/ switch over the sealed Style hierarchy when \"Pattern\n+                        \/\/ Matching for switch\" has been implemented (JEP 406\n+                        \/\/ and friends)\n+                        throw new AssertionError(styles);\n+                    }\n+                }\n+                Content c;\n+                if (markupEncountered) {\n+                    return;\n+                } else if (linkEncountered) {\n+                    assert e != null;\n+                    \/\/disable preview tagging inside the snippets:\n+                    Utils.PreviewFlagProvider prevPreviewProvider = utils.setPreviewFlagProvider(el -> false);\n+                    try {\n+                        var lt = (HtmlLinkTaglet) config.tagletManager.getTaglet(DocTree.Kind.LINK);\n+                        c = lt.linkSeeReferenceOutput(element,\n+                                null,\n+                                t,\n+                                e,\n+                                false, \/\/ TODO: for now\n+                                Text.of(sequence.toString()),\n+                                (key, args) -> { \/* TODO: report diagnostic *\/ },\n+                                tagletWriter);\n+                    } finally {\n+                        utils.setPreviewFlagProvider(prevPreviewProvider);\n+                    }\n+                } else {\n+                    c = HtmlTree.SPAN(Text.of(text));\n+                    classes.forEach(((HtmlTree) c)::addStyle);\n+                }\n+                code.add(c);\n+            }\n+        });\n+        String copyText = resources.getText(\"doclet.Copy_to_clipboard\");\n+        String copiedText = resources.getText(\"doclet.Copied_to_clipboard\");\n+        String copySnippetText = resources.getText(\"doclet.Copy_snippet_to_clipboard\");\n+        var snippetContainer = HtmlTree.DIV(HtmlStyle.snippetContainer,\n+                new HtmlTree(TagName.BUTTON)\n+                        .add(HtmlTree.SPAN(Text.of(copyText))\n+                                .put(HtmlAttr.DATA_COPIED, copiedText))\n+                        .add(new HtmlTree(TagName.IMG)\n+                                .put(HtmlAttr.SRC, tw.getHtmlWriter().pathToRoot.resolve(DocPaths.CLIPBOARD_SVG).getPath())\n+                                .put(HtmlAttr.ALT, copySnippetText))\n+                        .addStyle(HtmlStyle.copy)\n+                        .addStyle(HtmlStyle.snippetCopy)\n+                        .put(HtmlAttr.ARIA_LABEL, copySnippetText)\n+                        .put(HtmlAttr.ONCLICK, \"copySnippet(this)\"));\n+        return snippetContainer.add(pre.add(code));\n+    }\n+\n+    \/*\n+     * Returns the element that is linked from the context of the referrer using\n+     * the provided signature; returns null if such element could not be found.\n+     *\n+     * This method is to be used when it is the target of the link that is\n+     * important, not the container of the link (e.g. was it an @see,\n+     * @link\/@linkplain or @snippet tags, etc.)\n+     *\/\n+    public Element getLinkedElement(Element referer, String signature) {\n+        var factory = utils.docTrees.getDocTreeFactory();\n+        var docCommentTree = utils.getDocCommentTree(referer);\n+        var rootPath = new DocTreePath(utils.getTreePath(referer), docCommentTree);\n+        var reference = factory.newReferenceTree(signature);\n+        var fabricatedPath = new DocTreePath(rootPath, reference);\n+        return utils.docTrees.getElement(fabricatedPath);\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/HtmlSnippetTaglet.java","additions":161,"deletions":0,"binary":false,"changes":161,"status":"added"},{"patch":"@@ -0,0 +1,126 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html.taglets;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import javax.lang.model.element.Element;\n+\n+import com.sun.source.doctree.DocTree;\n+import com.sun.source.doctree.SpecTree;\n+import com.sun.source.doctree.TextTree;\n+import com.sun.source.util.DocTreePath;\n+\n+import jdk.javadoc.internal.doclets.formats.html.Contents;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n+import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n+import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n+import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.toolkit.taglets.SpecTaglet;\n+import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;\n+\n+public class HtmlSpecTaglet extends SpecTaglet {\n+\n+    private final Contents contents;\n+\n+    HtmlSpecTaglet(HtmlConfiguration config) {\n+        super(config);\n+        this.contents = config.contents;\n+    }\n+\n+    @Override\n+    public Content specTagOutput(Element holder, List<? extends SpecTree> specTags) {\n+        if (specTags.isEmpty()) {\n+            return Text.EMPTY;\n+        }\n+\n+        var tw = (TagletWriterImpl) tagletWriter;\n+\n+        var links = specTags.stream()\n+                .map(st -> specTagToContent(holder, st)).toList();\n+\n+        var specList = tw.tagList(links);\n+        return new ContentBuilder(\n+                HtmlTree.DT(contents.externalSpecifications),\n+                HtmlTree.DD(specList));\n+    }\n+\n+    private Content specTagToContent(Element holder, SpecTree specTree) {\n+        TagletWriterImpl tw = (TagletWriterImpl) tagletWriter;\n+        String specTreeURL = specTree.getURL().getBody();\n+        List<? extends DocTree> specTreeLabel = specTree.getTitle();\n+        Content label = tw.getHtmlWriter().commentTagsToContent(holder, specTreeLabel, tagletWriter.context.isFirstSentence);\n+        return getExternalSpecContent(holder, specTree, specTreeURL,\n+                textOf(specTreeLabel).replaceAll(\"\\\\s+\", \" \"), label,\n+                tw);\n+    }\n+\n+    private String textOf(List<? extends DocTree> trees) {\n+        return trees.stream()\n+                .filter(dt -> dt instanceof TextTree)\n+                .map(dt -> ((TextTree) dt).getBody().trim())\n+                .collect(Collectors.joining(\" \"));\n+    }\n+\n+    Content getExternalSpecContent(Element holder, DocTree docTree, String url, String searchText, Content title, TagletWriterImpl w) {\n+        URI specURI;\n+        try {\n+            \/\/ Use the canonical title of the spec if one is available\n+            specURI = new URI(url);\n+        } catch (URISyntaxException e) {\n+            CommentHelper ch = utils.getCommentHelper(holder);\n+            DocTreePath dtp = ch.getDocTreePath(docTree);\n+            w.getHtmlWriter().messages.error(dtp, \"doclet.Invalid_URL\", e.getMessage());\n+            specURI = null;\n+        }\n+\n+        Content titleWithAnchor = w.createAnchorAndSearchIndex(holder,\n+                searchText,\n+                title,\n+                resources.getText(\"doclet.External_Specification\"),\n+                docTree);\n+\n+        if (specURI == null) {\n+            return titleWithAnchor;\n+        } else {\n+            return HtmlTree.A(w.getHtmlWriter().resolveExternalSpecURI(specURI), titleWithAnchor);\n+        }\n+\n+    }\n+\n+\n+\/\/    private boolean isLongOrHasComma(Content c) {\n+\/\/        String s = c.toString()\n+\/\/                .replaceAll(\"<.*?>\", \"\")              \/\/ ignore HTML\n+\/\/                .replaceAll(\"&#?[A-Za-z0-9]+;\", \" \")  \/\/ entities count as a single character\n+\/\/                .replaceAll(\"\\\\R\", \"\\n\");             \/\/ normalize newlines\n+\/\/        return s.length() > TAG_LIST_ITEM_MAX_INLINE_LENGTH || s.contains(\",\");\n+\/\/    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/HtmlSpecTaglet.java","additions":126,"deletions":0,"binary":false,"changes":126,"status":"added"},{"patch":"@@ -0,0 +1,25 @@\n+package jdk.javadoc.internal.doclets.formats.html.taglets;\n+\n+import javax.lang.model.element.Element;\n+\n+import com.sun.source.doctree.SystemPropertyTree;\n+\n+import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n+import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.toolkit.taglets.SystemPropertyTaglet;\n+\n+public class HtmlSystemPropertyTaglet extends SystemPropertyTaglet {\n+    HtmlSystemPropertyTaglet(HtmlConfiguration config) {\n+        super(config);\n+    }\n+\n+\n+    @Override\n+    protected Content systemPropertyTagOutput(Element element, SystemPropertyTree tag) {\n+        TagletWriterImpl tw = (TagletWriterImpl) tagletWriter;\n+        String tagText = tag.getPropertyName().toString();\n+        return HtmlTree.CODE(tw.createAnchorAndSearchIndex(element, tagText,\n+                resources.getText(\"doclet.System_Property\"), tag));\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/HtmlSystemPropertyTaglet.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"added"},{"patch":"@@ -0,0 +1,144 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html.taglets;\n+\n+import java.util.EnumSet;\n+\n+import com.sun.source.doctree.DocTree;\n+\n+import jdk.javadoc.doclet.Taglet;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n+import jdk.javadoc.internal.doclets.toolkit.Resources;\n+import jdk.javadoc.internal.doclets.toolkit.taglets.BaseTaglet;\n+import jdk.javadoc.internal.doclets.toolkit.taglets.InheritDocTaglet;\n+import jdk.javadoc.internal.doclets.toolkit.taglets.SummaryTaglet;\n+import jdk.javadoc.internal.doclets.toolkit.taglets.TagletManager;\n+\n+import static com.sun.source.doctree.DocTree.Kind.AUTHOR;\n+import static com.sun.source.doctree.DocTree.Kind.EXCEPTION;\n+import static com.sun.source.doctree.DocTree.Kind.HIDDEN;\n+import static com.sun.source.doctree.DocTree.Kind.PROVIDES;\n+import static com.sun.source.doctree.DocTree.Kind.SERIAL;\n+import static com.sun.source.doctree.DocTree.Kind.SERIAL_DATA;\n+import static com.sun.source.doctree.DocTree.Kind.SERIAL_FIELD;\n+import static com.sun.source.doctree.DocTree.Kind.SINCE;\n+import static com.sun.source.doctree.DocTree.Kind.USES;\n+import static com.sun.source.doctree.DocTree.Kind.VERSION;\n+\n+public class HtmlTagletManager extends TagletManager {\n+    private final HtmlConfiguration config;\n+    private final Resources resources;\n+\n+    public HtmlTagletManager(HtmlConfiguration config) {\n+        super(config);\n+        this.config = config;\n+        resources = config.docResources;\n+        initStandardTaglets();\n+    }\n+\n+    \/**\n+     * Initialize standard Javadoc tags for ordering purposes.\n+     *\/\n+    private void initStandardTaglets() {\n+        if (javafx) {\n+            initJavaFXTaglets();\n+        }\n+\n+        addStandardTaglet(new HtmlParamTaglet(config));\n+        addStandardTaglet(new HtmlReturnTaglet(config));\n+        addStandardTaglet(new HtmlThrowsTaglet(config), EXCEPTION);\n+        addStandardTaglet(\n+                new HtmlSimpleTaglet(config, SINCE, resources.getText(\"doclet.Since\"),\n+                        EnumSet.allOf(Taglet.Location.class), !nosince));\n+        addStandardTaglet(\n+                new HtmlSimpleTaglet(config, VERSION, resources.getText(\"doclet.Version\"),\n+                        EnumSet.of(Taglet.Location.OVERVIEW, Taglet.Location.MODULE, Taglet.Location.PACKAGE, Taglet.Location.TYPE), showversion));\n+        addStandardTaglet(\n+                new HtmlSimpleTaglet(config, AUTHOR, resources.getText(\"doclet.Author\"),\n+                        EnumSet.of(Taglet.Location.OVERVIEW, Taglet.Location.MODULE, Taglet.Location.PACKAGE, Taglet.Location.TYPE), showauthor));\n+        addStandardTaglet(\n+                new HtmlSimpleTaglet(config, SERIAL_DATA, resources.getText(\"doclet.SerialData\"),\n+                        EnumSet.noneOf(Taglet.Location.class)));\n+        addStandardTaglet(\n+                new HtmlSimpleTaglet(config, HIDDEN, null,\n+                        EnumSet.of(Taglet.Location.TYPE, Taglet.Location.METHOD, Taglet.Location.FIELD)));\n+\n+        \/\/ This appears to be a default custom (non-standard) taglet\n+        jdk.javadoc.internal.doclets.toolkit.taglets.Taglet factoryTaglet =\n+                new HtmlSimpleTaglet(config, \"factory\", resources.getText(\"doclet.Factory\"),\n+                        EnumSet.of(Taglet.Location.METHOD));\n+        allTaglets.put(factoryTaglet.getName(), factoryTaglet);\n+\n+        addStandardTaglet(new HtmlSeeTaglet(config));\n+        addStandardTaglet(new HtmlSpecTaglet(config));\n+\n+        \/\/ Standard inline tags\n+        addStandardTaglet(new HtmlDocRootTaglet(config));\n+        addStandardTaglet(new InheritDocTaglet(config));\n+        addStandardTaglet(new HtmlValueTaglet(config));\n+        addStandardTaglet(new HtmlLinkTaglet(config, DocTree.Kind.LINK));\n+        addStandardTaglet(new HtmlLinkTaglet(config, DocTree.Kind.LINK_PLAIN));\n+        addStandardTaglet(new HtmlLiteralTaglet(config, DocTree.Kind.CODE));\n+        addStandardTaglet(new HtmlLiteralTaglet(config, DocTree.Kind.LITERAL));\n+        addStandardTaglet(new HtmlSnippetTaglet(config));\n+        addStandardTaglet(new HtmlIndexTaglet(config));\n+        addStandardTaglet(new SummaryTaglet(config));\n+        addStandardTaglet(new HtmlSystemPropertyTaglet(config));\n+\n+        \/\/ Keep track of the names of standard tags for error checking purposes.\n+        \/\/ The following are not handled above.\n+        addStandardTaglet(new HtmlDeprecatedTaglet(config));\n+        addStandardTaglet(new BaseTaglet(config, USES, false, EnumSet.of(Taglet.Location.MODULE)));\n+        addStandardTaglet(new BaseTaglet(config, PROVIDES, false, EnumSet.of(Taglet.Location.MODULE)));\n+        addStandardTaglet(\n+                new HtmlSimpleTaglet(config, SERIAL, null,\n+                        EnumSet.of(Taglet.Location.PACKAGE, Taglet.Location.TYPE, Taglet.Location.FIELD)));\n+        addStandardTaglet(\n+                new HtmlSimpleTaglet(config, SERIAL_FIELD, null, EnumSet.of(Taglet.Location.FIELD)));\n+    }\n+\n+    \/**\n+     * Initialize JavaFX-related tags.\n+     *\/\n+    private void initJavaFXTaglets() {\n+        addStandardTaglet(new HtmlSimpleTaglet(config, \"propertyDescription\",\n+                resources.getText(\"doclet.PropertyDescription\"),\n+                EnumSet.of(Taglet.Location.METHOD, Taglet.Location.FIELD)));\n+        addStandardTaglet(new HtmlSimpleTaglet(config, \"defaultValue\", resources.getText(\"doclet.DefaultValue\"),\n+                EnumSet.of(Taglet.Location.METHOD, Taglet.Location.FIELD)));\n+        addStandardTaglet(new HtmlSimpleTaglet(config, \"treatAsPrivate\", null,\n+                EnumSet.of(Taglet.Location.TYPE, Taglet.Location.METHOD, Taglet.Location.FIELD)));\n+    }\n+\n+    @Override\n+    protected jdk.javadoc.internal.doclets.toolkit.taglets.Taglet wrapTaglet(Taglet instance) {\n+        return new UserTaglet(instance);\n+    }\n+\n+    protected jdk.javadoc.internal.doclets.toolkit.taglets.Taglet newSimpleTaglet(String tagName, String header, String locations) {\n+        return new HtmlSimpleTaglet(config, tagName, header, locations);\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/HtmlTagletManager.java","additions":144,"deletions":0,"binary":false,"changes":144,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+package jdk.javadoc.internal.doclets.formats.html.taglets;\n+\n+import java.util.Optional;\n+\n+import javax.lang.model.type.TypeMirror;\n+\n+import jdk.javadoc.internal.doclets.formats.html.Contents;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlLinkInfo;\n+import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n+import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.toolkit.taglets.ThrowsTaglet;\n+\n+public class HtmlThrowsTaglet extends ThrowsTaglet {\n+    private final HtmlConfiguration config;\n+    private final Contents contents;\n+\n+    HtmlThrowsTaglet(HtmlConfiguration config) {\n+        super(config);\n+        this.config = config;\n+        contents = config.contents;\n+    }\n+\n+\n+    @Override\n+    public Content getThrowsHeader() {\n+        return HtmlTree.DT(contents.throws_);\n+    }\n+\n+\n+    @Override\n+    public Content throwsTagOutput(TypeMirror throwsType, Optional<Content> content) {\n+        var tw = (TagletWriterImpl) tagletWriter;\n+        var linkInfo = new HtmlLinkInfo(config, HtmlLinkInfo.Kind.PLAIN, throwsType);\n+        var link = tw.getHtmlWriter().getLink(linkInfo);\n+        var concat = new ContentBuilder(HtmlTree.CODE(link));\n+        if (content.isPresent()) {\n+            concat.add(\" - \");\n+            concat.add(content.get());\n+        }\n+        return HtmlTree.DD(concat);\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/HtmlThrowsTaglet.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,24 @@\n+package jdk.javadoc.internal.doclets.formats.html.taglets;\n+\n+import javax.lang.model.element.VariableElement;\n+\n+import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlLinkInfo;\n+import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n+import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.toolkit.taglets.ValueTaglet;\n+\n+public class HtmlValueTaglet extends ValueTaglet {\n+    HtmlValueTaglet(HtmlConfiguration config) {\n+        super(config);\n+    }\n+\n+\n+    @Override\n+    public Content valueTagOutput(VariableElement field, String constantVal, boolean includeLink) {\n+        TagletWriterImpl tw = (TagletWriterImpl) tagletWriter;\n+        return includeLink\n+                ? tw.getHtmlWriter().getDocLink(HtmlLinkInfo.Kind.LINK_TYPE_PARAMS_AND_BOUNDS, field, constantVal)\n+                : Text.of(constantVal);\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/HtmlValueTaglet.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"added"},{"patch":"@@ -0,0 +1,272 @@\n+\/*\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html.taglets;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Predicate;\n+\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.ModuleElement;\n+import javax.lang.model.element.PackageElement;\n+import javax.lang.model.element.TypeElement;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.util.SimpleElementVisitor14;\n+\n+import com.sun.source.doctree.DocTree;\n+\n+import jdk.javadoc.internal.doclets.formats.html.HtmlConfiguration;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlDocletWriter;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlIds;\n+import jdk.javadoc.internal.doclets.formats.html.HtmlOptions;\n+import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlId;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n+import jdk.javadoc.internal.doclets.formats.html.markup.Text;\n+import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n+import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.toolkit.DocletElement;\n+import jdk.javadoc.internal.doclets.toolkit.Resources;\n+import jdk.javadoc.internal.doclets.toolkit.taglets.TagletWriter;\n+import jdk.javadoc.internal.doclets.toolkit.util.DocLink;\n+import jdk.javadoc.internal.doclets.toolkit.util.IndexItem;\n+import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n+\n+\/**\n+ * The taglet writer that writes HTML.\n+ *\/\n+public class TagletWriterImpl extends TagletWriter {\n+\n+    private final HtmlDocletWriter htmlWriter;\n+    private final HtmlConfiguration configuration;\n+    private final HtmlOptions options;\n+    private final Utils utils;\n+    private final Resources resources;\n+\n+    private final Context context;\n+    \/**\n+     * Creates a taglet writer.\n+     *\n+     * @param htmlWriter      the {@code HtmlDocletWriter} for the page\n+     * @param isFirstSentence {@code true} if this taglet writer is being used for a\n+     *                        \"first sentence\" summary\n+     *\/\n+    public TagletWriterImpl(HtmlDocletWriter htmlWriter, boolean isFirstSentence) {\n+        this(htmlWriter, isFirstSentence, false);\n+    }\n+\n+    \/**\n+     * Creates a taglet writer.\n+     *\n+     * @param htmlWriter      the {@code HtmlDocletWriter} for the page\n+     * @param isFirstSentence {@code true} if this taglet writer is being used for a\n+     *                        \"first sentence\" summary, and {@code false} otherwise\n+     * @param inSummary       {@code true} if this taglet writer is being used for the content\n+     *                        of a {@code {@summary ...}} tag, and {@code false} otherwise\n+     *\/\n+    public TagletWriterImpl(HtmlDocletWriter htmlWriter, boolean isFirstSentence, boolean inSummary) {\n+        this(htmlWriter, new Context(isFirstSentence, inSummary));\n+    }\n+\n+    \/**\n+     * Creates a taglet writer.\n+     *\n+     * @param htmlWriter the {@code HtmlDocletWriter} for the page\n+     * @param context    the enclosing context for any tags\n+     *\/\n+    public TagletWriterImpl(HtmlDocletWriter htmlWriter, Context context) {\n+        super(context);\n+        this.htmlWriter = htmlWriter;\n+        this.context = context;\n+        configuration = htmlWriter.configuration;\n+        options = configuration.getOptions();\n+        utils = configuration.utils;\n+        resources = configuration.getDocResources();\n+    }\n+\n+    @Override\n+    public Content getOutputInstance() {\n+        return new ContentBuilder();\n+    }\n+\n+    Content tagList(List<Content> items) {\n+        \/\/ Use a different style if any list item is longer than 30 chars or contains commas.\n+        boolean hasLongLabels = items.stream().anyMatch(this::isLongOrHasComma);\n+        var list = HtmlTree.UL(hasLongLabels ? HtmlStyle.tagListLong : HtmlStyle.tagList);\n+        items.stream()\n+                .filter(Predicate.not(Content::isEmpty))\n+                .forEach(item -> list.add(HtmlTree.LI(item)));\n+        return list;\n+    }\n+\n+\n+    \/\/ Threshold for length of list item for switching from inline to block layout.\n+    private static final int TAG_LIST_ITEM_MAX_INLINE_LENGTH = 30;\n+\n+    private boolean isLongOrHasComma(Content c) {\n+        String s = c.toString()\n+                .replaceAll(\"<.*?>\", \"\")              \/\/ ignore HTML\n+                .replaceAll(\"&#?[A-Za-z0-9]+;\", \" \")  \/\/ entities count as a single character\n+                .replaceAll(\"\\\\R\", \"\\n\");             \/\/ normalize newlines\n+        return s.length() > TAG_LIST_ITEM_MAX_INLINE_LENGTH || s.contains(\",\");\n+    }\n+\n+    @Override\n+    public Content invalidTagOutput(String summary, Optional<String> detail) {\n+        return htmlWriter.invalidTagOutput(summary,\n+                detail.isEmpty() || detail.get().isEmpty()\n+                        ? Optional.empty()\n+                        : Optional.of(Text.of(Text.normalizeNewlines(detail.get()))));\n+    }\n+\n+    @Override\n+    public Content commentTagsToOutput(DocTree holder, List<? extends DocTree> tags) {\n+        return commentTagsToOutput(null, holder, tags, false);\n+    }\n+\n+    @Override\n+    public Content commentTagsToOutput(Element element, List<? extends DocTree> tags) {\n+        return commentTagsToOutput(element, null, tags, false);\n+    }\n+\n+    @Override\n+    public Content commentTagsToOutput(Element holder,\n+                                       DocTree holderTag,\n+                                       List<? extends DocTree> tags,\n+                                       boolean isFirstSentence)\n+    {\n+        return htmlWriter.commentTagsToContent(holder,\n+                tags, holderTag == null ? context : context.within(holderTag));\n+    }\n+\n+    @Override\n+    public BaseConfiguration configuration() {\n+        return configuration;\n+    }\n+\n+    @Override\n+    protected TypeElement getCurrentPageElement() {\n+        return htmlWriter.getCurrentPageElement();\n+    }\n+\n+    public HtmlDocletWriter getHtmlWriter() {\n+        return htmlWriter;\n+    }\n+\n+    public Utils getUtils() {\n+        return utils;\n+    }\n+\n+    public Content createAnchorAndSearchIndex(Element element, String tagText, String desc, DocTree tree) {\n+        return createAnchorAndSearchIndex(element, tagText, Text.of(tagText), desc, tree);\n+    }\n+\n+    @SuppressWarnings(\"preview\")\n+    Content createAnchorAndSearchIndex(Element element, String tagText, Content tagContent, String desc, DocTree tree) {\n+        Content result;\n+        if (context.isFirstSentence && context.inSummary || context.inTags.contains(DocTree.Kind.INDEX)) {\n+            result = tagContent;\n+        } else {\n+            HtmlId id = HtmlIds.forText(tagText, htmlWriter.indexAnchorTable);\n+            result = HtmlTree.SPAN(id, HtmlStyle.searchTagResult, tagContent);\n+            if (options.createIndex() && !tagText.isEmpty()) {\n+                String holder = getHolderName(element);\n+                IndexItem item = IndexItem.of(element, tree, tagText, holder, desc,\n+                        new DocLink(htmlWriter.path, id.name()));\n+                configuration.mainIndex.add(item);\n+            }\n+        }\n+        return result;\n+    }\n+\n+    public String getHolderName(Element element) {\n+        return new SimpleElementVisitor14<String, Void>() {\n+\n+            @Override\n+            public String visitModule(ModuleElement e, Void p) {\n+                return resources.getText(\"doclet.module\")\n+                        + \" \" + utils.getFullyQualifiedName(e);\n+            }\n+\n+            @Override\n+            public String visitPackage(PackageElement e, Void p) {\n+                return resources.getText(\"doclet.package\")\n+                        + \" \" + utils.getFullyQualifiedName(e);\n+            }\n+\n+            @Override\n+            public String visitType(TypeElement e, Void p) {\n+                return utils.getTypeElementKindName(e, true)\n+                        + \" \" + utils.getFullyQualifiedName(e);\n+            }\n+\n+            @Override\n+            public String visitExecutable(ExecutableElement e, Void p) {\n+                return utils.getFullyQualifiedName(utils.getEnclosingTypeElement(e))\n+                        + \".\" + utils.getSimpleName(e)\n+                        + utils.flatSignature(e, htmlWriter.getCurrentPageElement());\n+            }\n+\n+            @Override\n+            public String visitVariable(VariableElement e, Void p) {\n+                return utils.getFullyQualifiedName(utils.getEnclosingTypeElement(e))\n+                        + \".\" + utils.getSimpleName(e);\n+            }\n+\n+            @Override\n+            public String visitUnknown(Element e, Void p) {\n+                if (e instanceof DocletElement de) {\n+                    return switch (de.getSubKind()) {\n+                        case OVERVIEW -> resources.getText(\"doclet.Overview\");\n+                        case DOCFILE -> getHolderName(de);\n+                    };\n+                } else {\n+                    return super.visitUnknown(e, p);\n+                }\n+            }\n+\n+            @Override\n+            protected String defaultAction(Element e, Void p) {\n+                return utils.getFullyQualifiedName(e);\n+            }\n+        }.visit(element);\n+    }\n+\n+    private String getHolderName(DocletElement de) {\n+        PackageElement pe = de.getPackageElement();\n+        if (pe.isUnnamed()) {\n+            \/\/ if package is unnamed use enclosing module only if it is named\n+            Element ee = pe.getEnclosingElement();\n+            if (ee instanceof ModuleElement && !((ModuleElement)ee).isUnnamed()) {\n+                return resources.getText(\"doclet.module\") + \" \" + utils.getFullyQualifiedName(ee);\n+            }\n+            return pe.toString(); \/\/ \"Unnamed package\" or similar\n+        }\n+        return resources.getText(\"doclet.package\") + \" \" + utils.getFullyQualifiedName(pe);\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/TagletWriterImpl.java","additions":272,"deletions":0,"binary":false,"changes":272,"status":"added"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html.taglets;\n+\n+import java.util.List;\n+import java.util.Set;\n+\n+import javax.lang.model.element.Element;\n+\n+import com.sun.source.doctree.DocTree;\n+\n+import jdk.javadoc.internal.doclets.formats.html.markup.RawHtml;\n+import jdk.javadoc.internal.doclets.toolkit.Content;\n+import jdk.javadoc.internal.doclets.toolkit.taglets.Taglet;\n+import jdk.javadoc.internal.doclets.toolkit.taglets.TagletWriter;\n+\n+\/**\n+ * A taglet wrapper, allows the public taglet {@link jdk.javadoc.doclet.Taglet}\n+ * wrapped into an internal {@code Taglet} representation.\n+ *\/\n+public final class UserTaglet implements Taglet {\n+\n+    private final jdk.javadoc.doclet.Taglet userTaglet;\n+\n+    UserTaglet(jdk.javadoc.doclet.Taglet t) {\n+        userTaglet = t;\n+    }\n+\n+    @Override\n+    public Set<jdk.javadoc.doclet.Taglet.Location> getAllowedLocations() {\n+        return userTaglet.getAllowedLocations();\n+    }\n+\n+    @Override\n+    public boolean isInlineTag() {\n+        return userTaglet.isInlineTag();\n+    }\n+\n+    @Override\n+    public boolean isBlockTag() {\n+        return userTaglet.isBlockTag();\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return userTaglet.getName();\n+    }\n+\n+    @Override\n+    public Content getInlineTagOutput(Element element, DocTree tag, TagletWriter tagletWriter) {\n+        Content output = tagletWriter.getOutputInstance();\n+        output.add(RawHtml.of(userTaglet.toString(List.of(tag), element)));\n+        return output;\n+    }\n+\n+    @Override\n+    public Content getAllBlockTagOutput(Element holder, TagletWriter tagletWriter) {\n+        Content output = tagletWriter.getOutputInstance();\n+        var utils = tagletWriter.configuration().utils;\n+        List<? extends DocTree> tags = utils.getBlockTags(holder, this);\n+        if (!tags.isEmpty()) {\n+            String tagString = userTaglet.toString(tags, holder);\n+            if (tagString != null) {\n+                output.add(RawHtml.of(tagString));\n+            }\n+        }\n+        return output;\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/UserTaglet.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"},{"patch":"@@ -462,1 +462,1 @@\n-        tagletManager = tagletManager != null ? tagletManager : new TagletManager(this);\n+        tagletManager = tagletManager != null ? tagletManager : newTagletManager();\n@@ -509,0 +509,2 @@\n+    protected abstract TagletManager newTagletManager();\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/BaseConfiguration.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+\n@@ -33,0 +34,1 @@\n+\n@@ -34,0 +36,1 @@\n+import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n@@ -35,0 +38,3 @@\n+import jdk.javadoc.internal.doclets.toolkit.Messages;\n+import jdk.javadoc.internal.doclets.toolkit.Resources;\n+import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n@@ -40,0 +46,5 @@\n+    \/\/ The following members are global to the lifetime of the doclet\n+    protected final BaseConfiguration config;\n+    protected final Messages messages;\n+    protected final Resources resources;\n+    protected final Utils utils;\n@@ -41,0 +52,1 @@\n+    \/\/ The following members are specific to the instance of the taglet\n@@ -46,2 +58,7 @@\n-    BaseTaglet(DocTree.Kind tagKind, boolean inline, Set<Location> sites) {\n-        this(tagKind.tagName, tagKind, inline, sites);\n+    \/\/ The following is dynamically set for the duration of the methods\n+    \/\/      getInlineTagOutput and getAllBlockTagOutput\n+    \/\/ by those taglets that need to refer to it\n+    protected TagletWriter tagletWriter;\n+\n+    public BaseTaglet(BaseConfiguration config, DocTree.Kind tagKind, boolean inline, Set<Location> sites) {\n+        this(config, tagKind.tagName, tagKind, inline, sites);\n@@ -50,2 +67,2 @@\n-    BaseTaglet(String name, boolean inline, Set<Location> sites) {\n-        this(name, inline ? DocTree.Kind.UNKNOWN_INLINE_TAG : DocTree.Kind.UNKNOWN_BLOCK_TAG, inline, sites);\n+    BaseTaglet(BaseConfiguration config, String name, boolean inline, Set<Location> sites) {\n+        this(config, name, inline ? DocTree.Kind.UNKNOWN_INLINE_TAG : DocTree.Kind.UNKNOWN_BLOCK_TAG, inline, sites);\n@@ -54,1 +71,6 @@\n-    private BaseTaglet(String name, DocTree.Kind tagKind, boolean inline, Set<Location> sites) {\n+    private BaseTaglet(BaseConfiguration config, String name, DocTree.Kind tagKind, boolean inline, Set<Location> sites) {\n+        this.config = config;\n+        this.messages = config.getMessages();\n+        this.resources = config.getDocResources();\n+        this.utils = config.utils;\n+\n@@ -59,0 +81,1 @@\n+\n@@ -66,35 +89,0 @@\n-    @Override\n-    public final boolean inField() {\n-        return sites.contains(Location.FIELD);\n-    }\n-\n-    @Override\n-    public final boolean inConstructor() {\n-        return sites.contains(Location.CONSTRUCTOR);\n-    }\n-\n-    @Override\n-    public final boolean inMethod() {\n-        return sites.contains(Location.METHOD);\n-    }\n-\n-    @Override\n-    public final boolean inOverview() {\n-        return sites.contains(Location.OVERVIEW);\n-    }\n-\n-    @Override\n-    public final boolean inModule() {\n-        return sites.contains(Location.MODULE);\n-    }\n-\n-    @Override\n-    public final boolean inPackage() {\n-        return sites.contains(Location.PACKAGE);\n-    }\n-\n-    @Override\n-    public final boolean inType() {\n-        return sites.contains(Location.TYPE);\n-    }\n-\n@@ -121,1 +109,1 @@\n-     * Returns whether or not this taglet accepts a {@code DocTree} node.\n+     * Returns whether this taglet accepts a {@code DocTree} node.\n@@ -141,1 +129,1 @@\n-    public Content getInlineTagOutput(Element element, DocTree tag, TagletWriter writer) {\n+    public Content getInlineTagOutput(Element element, DocTree tag, TagletWriter tagletWriter) {\n@@ -151,1 +139,1 @@\n-    public Content getAllBlockTagOutput(Element holder, TagletWriter writer) {\n+    public Content getAllBlockTagOutput(Element holder, TagletWriter tagletWriter) {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/BaseTaglet.java","additions":31,"deletions":43,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -1,59 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.taglets;\n-\n-import java.util.EnumSet;\n-\n-import javax.lang.model.element.Element;\n-\n-import com.sun.source.doctree.DocTree;\n-import com.sun.source.doctree.LiteralTree;\n-import jdk.javadoc.doclet.Taglet.Location;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-\n-\/**\n- * An inline taglet used to denote literal code fragments.\n- * The enclosed text is interpreted as not containing HTML markup or\n- * nested javadoc tags, and is rendered in a font suitable for code.\n- *\n- * <p> The tag {@code {@code ...}} is equivalent to\n- * {@code <code>{@literal ...}<\/code>}.\n- * For example, the text:\n- * <blockquote>  The type {@code {@code List<P>}}  <\/blockquote>\n- * displays as:\n- * <blockquote>  The type {@code List<P>}  <\/blockquote>\n- *\/\n-public class CodeTaglet extends BaseTaglet {\n-\n-    CodeTaglet() {\n-        super(DocTree.Kind.CODE, true, EnumSet.allOf(Location.class));\n-    }\n-\n-    @Override\n-    public Content getInlineTagOutput(Element element, DocTree tag, TagletWriter writer) {\n-        return writer.codeTagOutput(element, (LiteralTree) tag);\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/CodeTaglet.java","additions":0,"deletions":59,"binary":false,"changes":59,"status":"deleted"},{"patch":"@@ -29,0 +29,1 @@\n+\n@@ -32,0 +33,1 @@\n+\n@@ -33,0 +35,1 @@\n+import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n@@ -38,1 +41,1 @@\n-public class DeprecatedTaglet extends BaseTaglet {\n+public abstract class DeprecatedTaglet extends BaseTaglet {\n@@ -40,2 +43,2 @@\n-    public DeprecatedTaglet() {\n-        super(DocTree.Kind.DEPRECATED, false,\n+    protected DeprecatedTaglet(BaseConfiguration config) {\n+        super(config, DocTree.Kind.DEPRECATED, false,\n@@ -46,3 +49,1 @@\n-    public Content getAllBlockTagOutput(Element holder, TagletWriter writer) {\n-        return writer.deprecatedTagOutput(holder);\n-    }\n+    public abstract Content getAllBlockTagOutput(Element holder, TagletWriter tagletWriter);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/DeprecatedTaglet.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+\n@@ -32,0 +33,1 @@\n+\n@@ -33,0 +35,1 @@\n+import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n@@ -40,1 +43,1 @@\n-public class DocRootTaglet extends BaseTaglet {\n+public abstract class DocRootTaglet extends BaseTaglet {\n@@ -45,2 +48,2 @@\n-    public DocRootTaglet() {\n-        super(DocTree.Kind.DOC_ROOT, true, EnumSet.allOf(Location.class));\n+    protected DocRootTaglet(BaseConfiguration config) {\n+        super(config, DocTree.Kind.DOC_ROOT, true, EnumSet.allOf(Location.class));\n@@ -49,4 +52,1 @@\n-    @Override\n-    public Content getInlineTagOutput(Element holder, DocTree tag, TagletWriter writer) {\n-        return writer.getDocRootOutput();\n-    }\n+    public abstract Content getInlineTagOutput(Element holder, DocTree tag, TagletWriter tagletWriter);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/DocRootTaglet.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+\n@@ -32,1 +33,1 @@\n-import com.sun.source.doctree.IndexTree;\n+\n@@ -34,0 +35,1 @@\n+import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n@@ -41,1 +43,1 @@\n-public class IndexTaglet extends BaseTaglet {\n+public abstract class IndexTaglet extends BaseTaglet {\n@@ -43,2 +45,2 @@\n-    IndexTaglet() {\n-        super(DocTree.Kind.INDEX, true, EnumSet.allOf(Location.class));\n+    protected IndexTaglet(BaseConfiguration config) {\n+        super(config, DocTree.Kind.INDEX, true, EnumSet.allOf(Location.class));\n@@ -48,3 +50,3 @@\n-    public Content getInlineTagOutput(Element element, DocTree tag, TagletWriter writer) {\n-        return writer.indexTagOutput(element, (IndexTree) tag);\n-    }\n+    public abstract Content getInlineTagOutput(Element owner, DocTree tag, TagletWriter tagletWriter) throws\n+            UnsupportedTagletOperationException;\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/IndexTaglet.java","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+\n@@ -42,1 +43,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.Messages;\n@@ -57,2 +57,2 @@\n-    public InheritDocTaglet() {\n-        super(DocTree.Kind.INHERIT_DOC, true, EnumSet.of(Location.METHOD));\n+    public InheritDocTaglet(BaseConfiguration config) {\n+        super(config, DocTree.Kind.INHERIT_DOC, true, EnumSet.of(Location.METHOD));\n@@ -79,3 +79,0 @@\n-        BaseConfiguration configuration = writer.configuration();\n-        Messages messages = configuration.getMessages();\n-        Utils utils = configuration.utils;\n@@ -106,1 +103,1 @@\n-            VisibleMemberTable visibleMemberTable = configuration.getVisibleMemberTable(supertype);\n+            VisibleMemberTable visibleMemberTable = config.getVisibleMemberTable(supertype);\n@@ -145,1 +142,1 @@\n-        Taglet taglet = configuration.tagletManager.getTaglet(ch.getTagName(holderTag));\n+        Taglet taglet = config.tagletManager.getTaglet(ch.getTagName(holderTag));\n@@ -154,1 +151,1 @@\n-        InheritableTaglet.Output inheritedDoc = inheritableTaglet.inherit(method, src, holderTag, isFirstSentence, configuration);\n+        InheritableTaglet.Output inheritedDoc = inheritableTaglet.inherit(method, src, holderTag, isFirstSentence);\n@@ -185,1 +182,4 @@\n-        return retrieveInheritedDocumentation(tagletWriter, (ExecutableElement) e, (InheritDocTree) inheritDoc, tagletWriter.isFirstSentence);\n+        return retrieveInheritedDocumentation(tagletWriter,\n+                (ExecutableElement) e,\n+                (InheritDocTree) inheritDoc,\n+                tagletWriter.context.isFirstSentence);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/InheritDocTaglet.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n@@ -55,1 +54,1 @@\n-    Output inherit(Element dst, Element src, DocTree tag, boolean isFirstSentence, BaseConfiguration configuration);\n+    Output inherit(Element dst, Element src, DocTree tag, boolean isFirstSentence);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/InheritableTaglet.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.toolkit.taglets;\n+\n+import java.util.EnumSet;\n+\n+import javax.lang.model.element.Element;\n+\n+import com.sun.source.doctree.DocTree;\n+\n+import jdk.javadoc.doclet.Taglet.Location;\n+import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n+import jdk.javadoc.internal.doclets.toolkit.Content;\n+\n+public abstract class LinkTaglet extends BaseTaglet {\n+\n+    protected LinkTaglet(BaseConfiguration config, DocTree.Kind tagKind) {\n+        super(config, tagKind, true, EnumSet.allOf(Location.class));\n+    }\n+\n+    @Override\n+    public abstract Content getInlineTagOutput(Element e, DocTree tag, TagletWriter tagletWriter);\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/LinkTaglet.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -29,0 +29,1 @@\n+\n@@ -32,1 +33,1 @@\n-import com.sun.source.doctree.LiteralTree;\n+\n@@ -34,0 +35,1 @@\n+import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n@@ -37,1 +39,2 @@\n- * An inline taglet used to denote literal text.\n+ * An inline taglet used to denote literal text, possibly in monospace font.\n+ *\n@@ -42,0 +45,8 @@\n+ *\n+ * <p> The tag {@code {@code ...}} is equivalent to\n+ * {@code <code>{@literal ...}<\/code>}.\n+ *\n+ * For example, the text:\n+ * <blockquote>  The type {@code {@code List<P>}}  <\/blockquote>\n+ * displays as:\n+ * <blockquote>  The type {@code List<P>}  <\/blockquote>\n@@ -43,1 +54,1 @@\n-public class LiteralTaglet extends BaseTaglet {\n+public abstract class LiteralTaglet extends BaseTaglet {\n@@ -45,2 +56,2 @@\n-    LiteralTaglet() {\n-        super(DocTree.Kind.LITERAL, true, EnumSet.allOf(Location.class));\n+    protected LiteralTaglet(BaseConfiguration config, DocTree.Kind tagKind) {\n+        super(config, tagKind, true, EnumSet.allOf(Location.class));\n@@ -50,3 +61,1 @@\n-    public Content getInlineTagOutput(Element e, DocTree tag, TagletWriter writer) {\n-        return writer.literalTagOutput(e, (LiteralTree) tag);\n-    }\n+    public abstract Content getInlineTagOutput(Element e, DocTree tag, TagletWriter tagletWriter);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/LiteralTaglet.java","additions":17,"deletions":8,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -28,1 +28,5 @@\n-import java.util.*;\n+import java.util.EnumSet;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n@@ -37,0 +41,1 @@\n+\n@@ -40,1 +45,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.Messages;\n@@ -49,1 +53,2 @@\n-public class ParamTaglet extends BaseTaglet implements InheritableTaglet {\n+public abstract class ParamTaglet extends BaseTaglet implements InheritableTaglet {\n+\n@@ -62,2 +67,2 @@\n-    public ParamTaglet() {\n-        super(DocTree.Kind.PARAM, false, EnumSet.of(Location.TYPE, Location.CONSTRUCTOR, Location.METHOD));\n+    protected ParamTaglet(BaseConfiguration config) {\n+        super(config, DocTree.Kind.PARAM, false, EnumSet.of(Location.TYPE, Location.CONSTRUCTOR, Location.METHOD));\n@@ -67,1 +72,1 @@\n-    public Output inherit(Element dst, Element src, DocTree tag, boolean isFirstSentence, BaseConfiguration configuration) {\n+    public Output inherit(Element dst, Element src, DocTree tag, boolean isFirstSentence) {\n@@ -79,2 +84,2 @@\n-        Map<String, Integer> stringIntegerMap = mapNameToPosition(configuration.utils, parameterElements);\n-        CommentHelper ch = configuration.utils.getCommentHelper(dst);\n+        Map<String, Integer> stringIntegerMap = mapNameToPosition(utils, parameterElements);\n+        CommentHelper ch = utils.getCommentHelper(dst);\n@@ -87,1 +92,1 @@\n-            var docFinder = configuration.utils.docFinder();\n+            var docFinder = utils.docFinder();\n@@ -92,1 +97,1 @@\n-                                m -> Result.fromOptional(extract(configuration.utils, m, position, param.isTypeParameter())))\n+                                m -> Result.fromOptional(extract(utils, m, position, param.isTypeParameter())))\n@@ -96,1 +101,1 @@\n-                                m -> Result.fromOptional(extract(configuration.utils, m, position, param.isTypeParameter())))\n+                                m -> Result.fromOptional(extract(utils, m, position, param.isTypeParameter())))\n@@ -125,2 +130,2 @@\n-    public Content getAllBlockTagOutput(Element holder, TagletWriter writer) {\n-        Utils utils = writer.configuration().utils;\n+    public Content getAllBlockTagOutput(Element holder, TagletWriter tagletWriter) {\n+        this.tagletWriter = tagletWriter;\n@@ -130,1 +135,1 @@\n-                    utils.getTypeParamTrees(member), member.getTypeParameters(), writer);\n+                    utils.getTypeParamTrees(member), member.getTypeParameters(), tagletWriter);\n@@ -132,1 +137,1 @@\n-                    utils.getParamTrees(member), member.getParameters(), writer));\n+                    utils.getParamTrees(member), member.getParameters(), tagletWriter));\n@@ -137,1 +142,1 @@\n-                    utils.getTypeParamTrees(typeElement), typeElement.getTypeParameters(), writer);\n+                    utils.getTypeParamTrees(typeElement), typeElement.getTypeParameters(), tagletWriter);\n@@ -139,1 +144,1 @@\n-                    utils.getParamTrees(typeElement), typeElement.getRecordComponents(), writer));\n+                    utils.getParamTrees(typeElement), typeElement.getRecordComponents(), tagletWriter));\n@@ -166,2 +171,1 @@\n-        Messages messages = writer.configuration().getMessages();\n-        CommentHelper ch = writer.configuration().utils.getCommentHelper(e);\n+        CommentHelper ch = utils.getCommentHelper(e);\n@@ -169,1 +173,1 @@\n-            Map<String, Integer> positionOfName = mapNameToPosition(writer.configuration().utils, parameters);\n+            Map<String, Integer> positionOfName = mapNameToPosition(utils, parameters);\n@@ -179,1 +183,1 @@\n-                    if (!writer.configuration().isDocLintReferenceGroupEnabled()) {\n+                    if (!config.isDocLintReferenceGroupEnabled()) {\n@@ -191,1 +195,1 @@\n-                        if (!writer.configuration().isDocLintReferenceGroupEnabled()) {\n+                        if (!config.isDocLintReferenceGroupEnabled()) {\n@@ -208,1 +212,1 @@\n-            } else if (writer.configuration().utils.isMethod(e)) {\n+            } else if (utils.isMethod(e)) {\n@@ -236,1 +240,0 @@\n-        Utils utils = writer.configuration().utils;\n@@ -252,0 +255,4 @@\n+    public abstract Content getParamHeader(ParamKind kind);\n+\n+    public abstract Content paramTagOutput(Element element, ParamTree paramTag, String paramName);\n+\n@@ -279,1 +286,1 @@\n-            result.add(writer.getParamHeader(kind));\n+            result.add(getParamHeader(kind));\n@@ -281,1 +288,1 @@\n-        result.add(writer.paramTagOutput(e, paramTag, name));\n+        result.add(paramTagOutput(e, paramTag, name));\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/ParamTaglet.java","additions":33,"deletions":26,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+\n@@ -43,1 +44,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.Messages;\n@@ -51,1 +51,1 @@\n-public class ReturnTaglet extends BaseTaglet implements InheritableTaglet {\n+public abstract class ReturnTaglet extends BaseTaglet implements InheritableTaglet {\n@@ -53,2 +53,2 @@\n-    public ReturnTaglet() {\n-        super(DocTree.Kind.RETURN, true, EnumSet.of(Location.METHOD));\n+    protected ReturnTaglet(BaseConfiguration config) {\n+        super(config, DocTree.Kind.RETURN, true, EnumSet.of(Location.METHOD));\n@@ -63,1 +63,1 @@\n-    public Output inherit(Element dst, Element src, DocTree tag, boolean isFirstSentence, BaseConfiguration configuration) {\n+    public Output inherit(Element dst, Element src, DocTree tag, boolean isFirstSentence) {\n@@ -65,1 +65,1 @@\n-            var docFinder = configuration.utils.docFinder();\n+            var docFinder = utils.docFinder();\n@@ -68,1 +68,1 @@\n-                r = docFinder.find((ExecutableElement) dst, m -> Result.fromOptional(extract(configuration.utils, m))).toOptional();\n+                r = docFinder.find((ExecutableElement) dst, m -> Result.fromOptional(extract(utils, m))).toOptional();\n@@ -70,1 +70,1 @@\n-                r = docFinder.search((ExecutableElement) src, m -> Result.fromOptional(extract(configuration.utils, m))).toOptional();\n+                r = docFinder.search((ExecutableElement) src, m -> Result.fromOptional(extract(utils, m))).toOptional();\n@@ -80,2 +80,3 @@\n-    public Content getInlineTagOutput(Element element, DocTree tag, TagletWriter writer) {\n-        return writer.returnTagOutput(element, (ReturnTree) tag, true);\n+    public Content getInlineTagOutput(Element element, DocTree tag, TagletWriter tagletWriter) {\n+        this.tagletWriter = tagletWriter;\n+        return returnTagOutput(element, (ReturnTree) tag, true);\n@@ -85,1 +86,1 @@\n-    public Content getAllBlockTagOutput(Element holder, TagletWriter writer) {\n+    public Content getAllBlockTagOutput(Element holder, TagletWriter tagletWriter) {\n@@ -88,2 +89,1 @@\n-        Messages messages = writer.configuration().getMessages();\n-        Utils utils = writer.configuration().utils;\n+        this.tagletWriter = tagletWriter;\n@@ -93,1 +93,1 @@\n-        TypeMirror returnType = utils.getReturnType(writer.getCurrentPageElement(), method);\n+        TypeMirror returnType = utils.getReturnType(tagletWriter.getCurrentPageElement(), method);\n@@ -95,1 +95,1 @@\n-            if (!tags.isEmpty() && !writer.configuration().isDocLintReferenceGroupEnabled()) {\n+            if (!tags.isEmpty() && !config.isDocLintReferenceGroupEnabled()) {\n@@ -107,1 +107,1 @@\n-                .map(r -> writer.returnTagOutput(r.method, r.returnTree, false))\n+                .map(r -> returnTagOutput(r.method, r.returnTree, false))\n@@ -111,0 +111,11 @@\n+    \/**\n+     * Returns the output for a {@code @return} tag.\n+     *\n+     * @param element   the element that owns the doc comment\n+     * @param returnTag the return tag to document\n+     * @param inline    whether this should be written as an inline instance or block instance\n+     *\n+     * @return the output\n+     *\/\n+    protected abstract Content returnTagOutput(Element element, ReturnTree returnTag, boolean inline);\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/ReturnTaglet.java","additions":27,"deletions":16,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-public class SeeTaglet extends BaseTaglet implements InheritableTaglet {\n+public abstract class SeeTaglet extends BaseTaglet implements InheritableTaglet {\n@@ -49,2 +49,2 @@\n-    public SeeTaglet() {\n-        super(DocTree.Kind.SEE, false, EnumSet.allOf(Location.class));\n+    protected SeeTaglet(BaseConfiguration config) {\n+        super(config, DocTree.Kind.SEE, false, EnumSet.allOf(Location.class));\n@@ -54,2 +54,2 @@\n-    public Output inherit(Element dst, Element src, DocTree tag, boolean isFirstSentence, BaseConfiguration configuration) {\n-        CommentHelper ch = configuration.utils.getCommentHelper(dst);\n+    public Output inherit(Element dst, Element src, DocTree tag, boolean isFirstSentence) {\n+        CommentHelper ch = utils.getCommentHelper(dst);\n@@ -57,1 +57,1 @@\n-        configuration.getMessages().warning(path, \"doclet.inheritDocWithinInappropriateTag\");\n+        messages.warning(path, \"doclet.inheritDocWithinInappropriateTag\");\n@@ -62,2 +62,2 @@\n-    public Content getAllBlockTagOutput(Element holder, TagletWriter writer) {\n-        Utils utils = writer.configuration().utils;\n+    public Content getAllBlockTagOutput(Element holder, TagletWriter tagletWriter) {\n+        this.tagletWriter = tagletWriter;\n@@ -76,1 +76,1 @@\n-        return writer.seeTagOutput(e, tags);\n+        return seeTagOutput(e, tags);\n@@ -79,0 +79,10 @@\n+    \/**\n+     * Returns the output for {@code @see} tags.\n+     *\n+     * @param element The element that owns the doc comment\n+     * @param seeTags the list of tags\n+     *\n+     * @return the output\n+     *\/\n+    protected abstract Content seeTagOutput(Element element, List<? extends SeeTree> seeTags);\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/SeeTaglet.java","additions":19,"deletions":9,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.util.EnumSet;\n@@ -38,1 +37,0 @@\n-import jdk.javadoc.doclet.Taglet.Location;\n@@ -40,0 +38,1 @@\n+import jdk.javadoc.doclet.Taglet.Location;\n@@ -49,1 +48,1 @@\n-public class SimpleTaglet extends BaseTaglet implements InheritableTaglet {\n+public abstract class SimpleTaglet extends BaseTaglet implements InheritableTaglet {\n@@ -64,26 +63,0 @@\n-    \/**\n-     * Constructs a {@code SimpleTaglet}.\n-     *\n-     * @param tagName   the name of this tag\n-     * @param header    the header to output\n-     * @param locations the possible locations that this tag can appear in\n-     *                  The string can contain 'p' for package, 't' for type,\n-     *                  'm' for method, 'c' for constructor and 'f' for field.\n-     *                  See {@link #getLocations(String) getLocations} for the\n-     *                  complete list.\n-     *\/\n-    public SimpleTaglet(String tagName, String header, String locations) {\n-        this(tagName, header, getLocations(locations), isEnabled(locations));\n-    }\n-\n-    \/**\n-     * Constructs a {@code SimpleTaglet}.\n-     *\n-     * @param tagKind   the kind of this tag\n-     * @param header    the header to output\n-     * @param locations the possible locations that this tag can appear in\n-     *\/\n-    public SimpleTaglet(DocTree.Kind tagKind, String header, Set<Location> locations) {\n-        this(tagKind, header, locations, true);\n-    }\n-\n@@ -97,13 +70,2 @@\n-    public SimpleTaglet(String tagName, String header, Set<Location> locations) {\n-        this(tagName, header, locations, true);\n-    }\n-\n-    \/**\n-     * Constructs a {@code SimpleTaglet}.\n-     *\n-     * @param tagName   the name of this tag\n-     * @param header    the header to output\n-     * @param locations the possible locations that this tag can appear in\n-     *\/\n-    public SimpleTaglet(String tagName, String header, Set<Location> locations, boolean enabled) {\n-        super(tagName, false, locations);\n+    protected SimpleTaglet(BaseConfiguration config, String tagName, String header, Set<Location> locations, boolean enabled) {\n+        super(config, tagName, false, locations);\n@@ -121,2 +83,2 @@\n-    public SimpleTaglet(DocTree.Kind tagKind, String header, Set<Location> locations, boolean enabled) {\n-        super(tagKind, false, locations);\n+    protected SimpleTaglet(BaseConfiguration config, DocTree.Kind tagKind, String header, Set<Location> locations, boolean enabled) {\n+        super(config, tagKind, false, locations);\n@@ -127,38 +89,0 @@\n-    private static Set<Location> getLocations(String locations) {\n-        Set<Location> set = EnumSet.noneOf(Location.class);\n-        for (int i = 0; i < locations.length(); i++) {\n-            switch (locations.charAt(i)) {\n-                case 'a':  case 'A':\n-                    return EnumSet.allOf(Location.class);\n-                case 'c':  case 'C':\n-                    set.add(Location.CONSTRUCTOR);\n-                    break;\n-                case 'f':  case 'F':\n-                    set.add(Location.FIELD);\n-                    break;\n-                case 'm':  case 'M':\n-                    set.add(Location.METHOD);\n-                    break;\n-                case 'o':  case 'O':\n-                    set.add(Location.OVERVIEW);\n-                    break;\n-                case 'p':  case 'P':\n-                    set.add(Location.PACKAGE);\n-                    break;\n-                case 's':  case 'S':        \/\/ super-packages, anyone?\n-                    set.add(Location.MODULE);\n-                    break;\n-                case 't':  case 'T':\n-                    set.add(Location.TYPE);\n-                    break;\n-                case 'x':  case 'X':\n-                    break;\n-            }\n-        }\n-        return set;\n-    }\n-\n-    private static boolean isEnabled(String locations) {\n-        return locations.matches(\"[^Xx]*\");\n-    }\n-\n@@ -166,1 +90,1 @@\n-    public Output inherit(Element dst, Element src, DocTree tag, boolean isFirstSentence, BaseConfiguration configuration) {\n+    public Output inherit(Element dst, Element src, DocTree tag, boolean isFirstSentence) {\n@@ -170,1 +94,1 @@\n-            var docFinder = configuration.utils.docFinder();\n+            var docFinder = utils.docFinder();\n@@ -174,1 +98,1 @@\n-                        m -> Result.fromOptional(extractFirst(m, configuration.utils))).toOptional();\n+                        m -> Result.fromOptional(extractFirst(m, utils))).toOptional();\n@@ -177,1 +101,1 @@\n-                        m -> Result.fromOptional(extractFirst(m, configuration.utils))).toOptional();\n+                        m -> Result.fromOptional(extractFirst(m, utils))).toOptional();\n@@ -198,2 +122,1 @@\n-    public Content getAllBlockTagOutput(Element holder, TagletWriter writer) {\n-        Utils utils = writer.configuration().utils;\n+    public Content getAllBlockTagOutput(Element holder, TagletWriter tagletWriter) {\n@@ -204,1 +127,1 @@\n-        return writer.simpleBlockTagOutput(holder, tags, header);\n+        return simpleBlockTagOutput(holder, tags, header, tagletWriter);\n@@ -206,0 +129,14 @@\n+\n+    \/**\n+     * Returns the output for a series of simple tags.\n+     *\n+     * @param element    The element that owns the doc comment\n+     * @param simpleTags the list of simple tags\n+     * @param header     the header for the series of tags\n+     *\n+     * @return the output\n+     *\/\n+    protected abstract Content simpleBlockTagOutput(Element element,\n+                                                    List<? extends DocTree> simpleTags,\n+                                                    String header,\n+                                                    TagletWriter writer);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/SimpleTaglet.java","additions":26,"deletions":89,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n@@ -59,1 +60,1 @@\n-public class SnippetTaglet extends BaseTaglet {\n+public abstract class SnippetTaglet extends BaseTaglet {\n@@ -93,2 +94,2 @@\n-    public SnippetTaglet() {\n-        super(DocTree.Kind.SNIPPET, true, EnumSet.allOf(Taglet.Location.class));\n+    protected SnippetTaglet(BaseConfiguration config) {\n+        super(config, DocTree.Kind.SNIPPET, true, EnumSet.allOf(Taglet.Location.class));\n@@ -112,1 +113,2 @@\n-    public Content getInlineTagOutput(Element holder, DocTree tag, TagletWriter writer) {\n+    public Content getInlineTagOutput(Element holder, DocTree tag, TagletWriter tagletWriter) {\n+        this.tagletWriter = tagletWriter;\n@@ -114,1 +116,1 @@\n-            return generateContent(holder, tag, writer);\n+            return generateContent(holder, tag);\n@@ -116,3 +118,3 @@\n-            error(writer, holder, e.tag(), e.key(), e.args());\n-            String details = writer.configuration().getDocResources().getText(e.key(), e.args());\n-            return badSnippet(writer, Optional.of(details));\n+            error(tagletWriter, holder, e.tag(), e.key(), e.args());\n+            String details = config.getDocResources().getText(e.key(), e.args());\n+            return badSnippet(tagletWriter, Optional.of(details));\n@@ -122,0 +124,13 @@\n+    \/**\n+     * Returns the output for a {@code {@snippet ...}} tag.\n+     *\n+     * @param element    The element that owns the doc comment\n+     * @param snippetTag the snippet tag\n+     * @param id         the value of the id attribute, or null if not defined\n+     * @param lang       the value of the lang attribute, or null if not defined\n+     *\n+     * @return the output\n+     *\/\n+    protected abstract Content snippetTagOutput(Element element, SnippetTree snippetTag, StyledText text,\n+                                                String id, String lang);\n+\n@@ -150,1 +165,1 @@\n-    private Content generateContent(Element holder, DocTree tag, TagletWriter writer)\n+    private Content generateContent(Element holder, DocTree tag)\n@@ -215,1 +230,1 @@\n-            var fileManager = writer.configuration().getFileManager();\n+            var fileManager = config.getFileManager();\n@@ -219,1 +234,0 @@\n-                var utils = writer.configuration().utils;\n@@ -268,1 +282,1 @@\n-                var path = writer.configuration().utils.getCommentHelper(holder)\n+                var path = utils.getCommentHelper(holder)\n@@ -270,1 +284,1 @@\n-                writer.configuration().getReporter().print(Diagnostic.Kind.WARNING,\n+                config.getReporter().print(Diagnostic.Kind.WARNING,\n@@ -274,1 +288,1 @@\n-                inlineSnippet = parse(writer.configuration().getDocResources(), d, language, inlineContent);\n+                inlineSnippet = parse(resources, d, language, inlineContent);\n@@ -277,1 +291,1 @@\n-            var path = writer.configuration().utils.getCommentHelper(holder)\n+            var path = utils.getCommentHelper(holder)\n@@ -280,3 +294,2 @@\n-            String msg = writer.configuration().getDocResources()\n-                    .getText(\"doclet.snippet.markup\", e.getMessage());\n-            writer.configuration().getReporter().print(Diagnostic.Kind.ERROR,\n+            String msg = resources.getText(\"doclet.snippet.markup\", e.getMessage());\n+            config.getReporter().print(Diagnostic.Kind.ERROR,\n@@ -284,1 +297,1 @@\n-            return badSnippet(writer, Optional.of(e.getMessage()));\n+            return badSnippet(tagletWriter, Optional.of(e.getMessage()));\n@@ -289,1 +302,1 @@\n-            Diags d = (text, pos) -> writer.configuration().getMessages().warning(finalFileObject, pos, pos, pos, text);\n+            Diags d = (text, pos) -> messages.warning(finalFileObject, pos, pos, pos, text);\n@@ -291,1 +304,1 @@\n-                externalSnippet = parse(writer.configuration().getDocResources(), d, language, externalContent);\n+                externalSnippet = parse(resources, d, language, externalContent);\n@@ -295,1 +308,1 @@\n-            writer.configuration().getMessages().error(fileObject, e.getPosition(),\n+            messages.error(fileObject, e.getPosition(),\n@@ -297,1 +310,1 @@\n-            return badSnippet(writer, Optional.of(e.getMessage()));\n+            return badSnippet(tagletWriter, Optional.of(e.getMessage()));\n@@ -346,1 +359,1 @@\n-        return writer.snippetTagOutput(holder, snippetTag, text, id, lang);\n+        return snippetTagOutput(holder, snippetTag, text, id, lang);\n@@ -402,2 +415,1 @@\n-        writer.configuration().getMessages().error(\n-            writer.configuration().utils.getCommentHelper(holder).getDocTreePath(tag), key, args);\n+        messages.error(utils.getCommentHelper(holder).getDocTreePath(tag), key, args);\n@@ -407,1 +419,1 @@\n-        Resources resources = writer.configuration().getDocResources();\n+        var resources = config.getDocResources();\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/SnippetTaglet.java","additions":39,"deletions":27,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-public class SpecTaglet extends BaseTaglet implements InheritableTaglet {\n+public abstract class SpecTaglet extends BaseTaglet implements InheritableTaglet {\n@@ -48,2 +48,2 @@\n-    public SpecTaglet() {\n-        super(DocTree.Kind.SPEC, false, EnumSet.allOf(Location.class));\n+    protected SpecTaglet(BaseConfiguration config) {\n+        super(config, DocTree.Kind.SPEC, false, EnumSet.allOf(Location.class));\n@@ -53,2 +53,2 @@\n-    public Output inherit(Element dst, Element src, DocTree tag, boolean isFirstSentence, BaseConfiguration configuration) {\n-        CommentHelper ch = configuration.utils.getCommentHelper(dst);\n+    public Output inherit(Element dst, Element src, DocTree tag, boolean isFirstSentence) {\n+        CommentHelper ch = utils.getCommentHelper(dst);\n@@ -56,1 +56,1 @@\n-        configuration.getMessages().warning(path, \"doclet.inheritDocWithinInappropriateTag\");\n+        messages.warning(path, \"doclet.inheritDocWithinInappropriateTag\");\n@@ -61,2 +61,2 @@\n-    public Content getAllBlockTagOutput(Element holder, TagletWriter writer) {\n-        Utils utils = writer.configuration().utils;\n+    public Content getAllBlockTagOutput(Element holder, TagletWriter tagletWriter) {\n+        this.tagletWriter = tagletWriter;\n@@ -74,1 +74,1 @@\n-        return writer.specTagOutput(e, tags);\n+        return specTagOutput(e, tags);\n@@ -77,0 +77,10 @@\n+    \/**\n+     * Returns the output for one or more {@code @spec} tags.\n+     *\n+     * @param element  the element that owns the doc comment\n+     * @param specTags the array of @spec tags.\n+     *\n+     * @return the output\n+     *\/\n+    protected abstract Content specTagOutput(Element element, List<? extends SpecTree> specTags);\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/SpecTaglet.java","additions":19,"deletions":9,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+\n+import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n@@ -41,2 +43,2 @@\n-    public SummaryTaglet() {\n-        super(DocTree.Kind.SUMMARY, true, EnumSet.allOf(Location.class));\n+    public SummaryTaglet(BaseConfiguration config) {\n+        super(config, DocTree.Kind.SUMMARY, true, EnumSet.allOf(Location.class));\n@@ -46,3 +48,3 @@\n-    public Content getInlineTagOutput(Element holder, DocTree tag, TagletWriter writer) {\n-        return writer.commentTagsToOutput(holder, tag, ((SummaryTree)tag).getSummary(),\n-                writer.isFirstSentence);\n+    public Content getInlineTagOutput(Element holder, DocTree tag, TagletWriter tagletWriter) {\n+        return tagletWriter.commentTagsToOutput(holder, tag, ((SummaryTree)tag).getSummary(),\n+                tagletWriter.context.isFirstSentence);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/SummaryTaglet.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -28,0 +28,4 @@\n+import java.util.EnumSet;\n+\n+import javax.lang.model.element.Element;\n+\n@@ -30,0 +34,1 @@\n+\n@@ -31,0 +36,1 @@\n+import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;\n@@ -33,3 +39,0 @@\n-import javax.lang.model.element.Element;\n-import java.util.EnumSet;\n-\n@@ -39,1 +42,1 @@\n-public class SystemPropertyTaglet extends BaseTaglet {\n+public abstract class SystemPropertyTaglet extends BaseTaglet {\n@@ -41,2 +44,2 @@\n-    SystemPropertyTaglet() {\n-        super(DocTree.Kind.SYSTEM_PROPERTY, true, EnumSet.allOf(Location.class));\n+    protected SystemPropertyTaglet(BaseConfiguration config) {\n+        super(config, DocTree.Kind.SYSTEM_PROPERTY, true, EnumSet.allOf(Location.class));\n@@ -46,2 +49,3 @@\n-    public Content getInlineTagOutput(Element element, DocTree tag, TagletWriter writer) {\n-        return writer.systemPropertyTagOutput(element, (SystemPropertyTree) tag);\n+    public Content getInlineTagOutput(Element element, DocTree tag, TagletWriter tagletWriter) {\n+        this.tagletWriter = tagletWriter;\n+        return systemPropertyTagOutput(element, (SystemPropertyTree) tag);\n@@ -49,0 +53,10 @@\n+\n+    \/**\n+     * Returns the output for a {@code {@systemProperty...}} tag.\n+     *\n+     * @param element           the element that owns the doc comment\n+     * @param systemPropertyTag the system property tag\n+     *\n+     * @return the output\n+     *\/\n+    protected abstract Content systemPropertyTagOutput(Element element, SystemPropertyTree systemPropertyTag);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/SystemPropertyTaglet.java","additions":22,"deletions":8,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -52,1 +52,3 @@\n-    boolean inField();\n+    default boolean inField() {\n+        return getAllowedLocations().contains(Location.FIELD);\n+    }\n@@ -60,1 +62,3 @@\n-    boolean inConstructor();\n+    default boolean inConstructor() {\n+        return getAllowedLocations().contains(Location.CONSTRUCTOR);\n+    }\n@@ -68,1 +72,3 @@\n-    boolean inMethod();\n+    default boolean inMethod() {\n+        return getAllowedLocations().contains(Location.METHOD);\n+    }\n@@ -76,1 +82,3 @@\n-    boolean inOverview();\n+    default boolean inOverview() {\n+        return getAllowedLocations().contains(Location.OVERVIEW);\n+    }\n@@ -84,1 +92,3 @@\n-    boolean inModule();\n+    default boolean inModule()  {\n+        return getAllowedLocations().contains(Location.MODULE);\n+    }\n@@ -92,1 +102,3 @@\n-    boolean inPackage();\n+    default boolean inPackage() {\n+        return getAllowedLocations().contains(Location.PACKAGE);\n+    }\n@@ -100,1 +112,3 @@\n-    boolean inType();\n+    default boolean inType()  {\n+        return getAllowedLocations().contains(Location.TYPE);\n+    }\n@@ -133,1 +147,1 @@\n-     * @param writer the taglet-writer used in this doclet\n+     * @param tagletWriter the taglet-writer used in this doclet\n@@ -138,1 +152,1 @@\n-    Content getInlineTagOutput(Element owner, DocTree tag, TagletWriter writer) throws\n+    Content getInlineTagOutput(Element owner, DocTree tag, TagletWriter tagletWriter) throws\n@@ -146,1 +160,1 @@\n-     * @param writer the taglet-writer used in this doclet\n+     * @param tagletWriter the taglet-writer used in this doclet\n@@ -151,1 +165,1 @@\n-    Content getAllBlockTagOutput(Element owner, TagletWriter writer) throws\n+    Content getAllBlockTagOutput(Element owner, TagletWriter tagletWriter) throws\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/Taglet.java","additions":25,"deletions":11,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import java.util.EnumSet;\n@@ -66,5 +65,0 @@\n-import static com.sun.source.doctree.DocTree.Kind.AUTHOR;\n-import static com.sun.source.doctree.DocTree.Kind.EXCEPTION;\n-import static com.sun.source.doctree.DocTree.Kind.HIDDEN;\n-import static com.sun.source.doctree.DocTree.Kind.LINK;\n-import static com.sun.source.doctree.DocTree.Kind.LINK_PLAIN;\n@@ -72,1 +66,0 @@\n-import static com.sun.source.doctree.DocTree.Kind.PROVIDES;\n@@ -74,1 +67,0 @@\n-import static com.sun.source.doctree.DocTree.Kind.SERIAL;\n@@ -76,1 +68,0 @@\n-import static com.sun.source.doctree.DocTree.Kind.SERIAL_FIELD;\n@@ -79,2 +70,0 @@\n-import static com.sun.source.doctree.DocTree.Kind.USES;\n-import static com.sun.source.doctree.DocTree.Kind.VERSION;\n@@ -86,1 +75,1 @@\n-public class TagletManager {\n+public abstract class TagletManager {\n@@ -96,1 +85,1 @@\n-    private final LinkedHashMap<String, Taglet> allTaglets;\n+    protected final LinkedHashMap<String, Taglet> allTaglets;\n@@ -101,1 +90,1 @@\n-    private Map<Location, List<Taglet>> blockTagletsByLocation;\n+    protected Map<Location, List<Taglet>> blockTagletsByLocation;\n@@ -106,1 +95,1 @@\n-    private Map<String, Taglet> inlineTags;\n+    protected Map<String, Taglet> inlineTags;\n@@ -111,1 +100,1 @@\n-    private List<Taglet> serializedFormTags;\n+    protected List<Taglet> serializedFormTags;\n@@ -118,1 +107,0 @@\n-    private final Resources resources;\n@@ -152,1 +140,1 @@\n-    private final boolean nosince;\n+    protected final boolean nosince;\n@@ -157,1 +145,1 @@\n-    private final boolean showversion;\n+    protected final boolean showversion;\n@@ -162,1 +150,1 @@\n-    private final boolean showauthor;\n+    protected final boolean showauthor;\n@@ -167,1 +155,1 @@\n-    private final boolean javafx;\n+    protected final boolean javafx;\n@@ -172,1 +160,1 @@\n-    private final boolean showTaglets;\n+    protected final boolean showTaglets;\n@@ -199,1 +187,0 @@\n-        this.resources = configuration.getDocResources();\n@@ -203,1 +190,1 @@\n-        initStandardTaglets();\n+\/\/        initStandardTaglets();\n@@ -288,1 +275,1 @@\n-        Taglet newLegacy = new UserTaglet(instance);\n+        Taglet newLegacy = wrapTaglet(instance);\n@@ -293,0 +280,2 @@\n+    protected abstract Taglet wrapTaglet(jdk.javadoc.doclet.Taglet instance);\n+\n@@ -312,1 +301,1 @@\n-            allTaglets.put(tagName, new SimpleTaglet(tagName, header, locations));\n+            allTaglets.put(tagName, newSimpleTaglet(tagName, header, locations));\n@@ -322,0 +311,2 @@\n+    protected abstract Taglet newSimpleTaglet(String tagname, String header, String locations);\n+\n@@ -586,74 +577,1 @@\n-    \/**\n-     * Initialize standard Javadoc tags for ordering purposes.\n-     *\/\n-    private void initStandardTaglets() {\n-        if (javafx) {\n-            initJavaFXTaglets();\n-        }\n-\n-        addStandardTaglet(new ParamTaglet());\n-        addStandardTaglet(new ReturnTaglet());\n-        addStandardTaglet(new ThrowsTaglet(configuration), EXCEPTION);\n-        addStandardTaglet(\n-                new SimpleTaglet(SINCE, resources.getText(\"doclet.Since\"),\n-                    EnumSet.allOf(Location.class), !nosince));\n-        addStandardTaglet(\n-                new SimpleTaglet(VERSION, resources.getText(\"doclet.Version\"),\n-                    EnumSet.of(Location.OVERVIEW, Location.MODULE, Location.PACKAGE, Location.TYPE), showversion));\n-        addStandardTaglet(\n-                new SimpleTaglet(AUTHOR, resources.getText(\"doclet.Author\"),\n-                    EnumSet.of(Location.OVERVIEW, Location.MODULE, Location.PACKAGE, Location.TYPE), showauthor));\n-        addStandardTaglet(\n-                new SimpleTaglet(SERIAL_DATA, resources.getText(\"doclet.SerialData\"),\n-                    EnumSet.noneOf(Location.class)));\n-        addStandardTaglet(\n-                new SimpleTaglet(HIDDEN, null,\n-                    EnumSet.of(Location.TYPE, Location.METHOD, Location.FIELD)));\n-\n-        \/\/ This appears to be a default custom (non-standard) taglet\n-        Taglet factoryTaglet = new SimpleTaglet(\"factory\", resources.getText(\"doclet.Factory\"),\n-                EnumSet.of(Location.METHOD));\n-        allTaglets.put(factoryTaglet.getName(), factoryTaglet);\n-\n-        addStandardTaglet(new SeeTaglet());\n-        addStandardTaglet(new SpecTaglet());\n-\n-        \/\/ Standard inline tags\n-        addStandardTaglet(new DocRootTaglet());\n-        addStandardTaglet(new InheritDocTaglet());\n-        addStandardTaglet(new ValueTaglet());\n-        addStandardTaglet(new LiteralTaglet());\n-        addStandardTaglet(new CodeTaglet());\n-        addStandardTaglet(new SnippetTaglet());\n-        addStandardTaglet(new IndexTaglet());\n-        addStandardTaglet(new SummaryTaglet());\n-        addStandardTaglet(new SystemPropertyTaglet());\n-\n-        \/\/ Keep track of the names of standard tags for error checking purposes.\n-        \/\/ The following are not handled above.\n-        addStandardTaglet(new DeprecatedTaglet());\n-        addStandardTaglet(new BaseTaglet(LINK, true, EnumSet.allOf(Location.class)));\n-        addStandardTaglet(new BaseTaglet(LINK_PLAIN, true, EnumSet.allOf(Location.class)));\n-        addStandardTaglet(new BaseTaglet(USES, false, EnumSet.of(Location.MODULE)));\n-        addStandardTaglet(new BaseTaglet(PROVIDES, false, EnumSet.of(Location.MODULE)));\n-        addStandardTaglet(\n-                new SimpleTaglet(SERIAL, null,\n-                    EnumSet.of(Location.PACKAGE, Location.TYPE, Location.FIELD)));\n-        addStandardTaglet(\n-                new SimpleTaglet(SERIAL_FIELD, null, EnumSet.of(Location.FIELD)));\n-    }\n-\n-    \/**\n-     * Initialize JavaFX-related tags.\n-     *\/\n-    private void initJavaFXTaglets() {\n-        addStandardTaglet(new SimpleTaglet(\"propertyDescription\",\n-                resources.getText(\"doclet.PropertyDescription\"),\n-                EnumSet.of(Location.METHOD, Location.FIELD)));\n-        addStandardTaglet(new SimpleTaglet(\"defaultValue\", resources.getText(\"doclet.DefaultValue\"),\n-                EnumSet.of(Location.METHOD, Location.FIELD)));\n-        addStandardTaglet(new SimpleTaglet(\"treatAsPrivate\", null,\n-                EnumSet.of(Location.TYPE, Location.METHOD, Location.FIELD)));\n-    }\n-\n-    private void addStandardTaglet(Taglet taglet) {\n+    protected void addStandardTaglet(Taglet taglet) {\n@@ -666,1 +584,1 @@\n-    private void addStandardTaglet(Taglet taglet, DocTree.Kind alias) {\n+    protected void addStandardTaglet(Taglet taglet, DocTree.Kind alias) {\n@@ -714,0 +632,8 @@\n+    public Taglet getTaglet(DocTree.Kind kind) {\n+        return switch (kind) {\n+            case DEPRECATED, LINK, LINK_PLAIN, PARAM, RETURN, THROWS -> getTaglet(kind.tagName);\n+            default ->\n+                throw new IllegalArgumentException(kind.toString());\n+        };\n+    }\n+\n@@ -719,1 +645,1 @@\n-    private void showTaglets(PrintStream out) {\n+    protected void showTaglets(PrintStream out) {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/TagletManager.java","additions":28,"deletions":102,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.util.EnumSet;\n@@ -31,0 +32,2 @@\n+import java.util.Set;\n+\n@@ -34,2 +37,0 @@\n-import javax.lang.model.element.VariableElement;\n-import javax.lang.model.type.TypeMirror;\n@@ -38,10 +39,1 @@\n-import com.sun.source.doctree.SpecTree;\n-import com.sun.source.doctree.IndexTree;\n-import com.sun.source.doctree.LinkTree;\n-import com.sun.source.doctree.LiteralTree;\n-import com.sun.source.doctree.ParamTree;\n-import com.sun.source.doctree.ReturnTree;\n-import com.sun.source.doctree.SeeTree;\n-import com.sun.source.doctree.SnippetTree;\n-import com.sun.source.doctree.SystemPropertyTree;\n-import com.sun.source.doctree.ThrowsTree;\n+\n@@ -51,1 +43,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.taglets.snippet.StyledText;\n@@ -53,1 +44,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n@@ -61,124 +51,31 @@\n-     * True if we only want to write the first sentence.\n-     *\/\n-    protected final boolean isFirstSentence;\n-\n-    protected TagletWriter(boolean isFirstSentence) {\n-        this.isFirstSentence = isFirstSentence;\n-    }\n-\n-    \/**\n-     * Returns an instance of an output object.\n-     *\n-     * @return an instance of an output object\n-     *\/\n-    public abstract Content getOutputInstance();\n-\n-    \/**\n-     * Returns the output for a {@code {@code ...}} tag.\n-     *\n-     * @param element The element that owns the doc comment\n-     * @param tag     the tag\n-     *\n-     * @return the output\n-     *\/\n-    protected abstract Content codeTagOutput(Element element, LiteralTree tag);\n-\n-    \/**\n-     * Returns the output for a {@code {@index...}} tag.\n-     *\n-     * @param element The element that owns the doc comment\n-     * @param tag     the tag\n-     *\n-     * @return the output\n-     *\/\n-    protected abstract Content indexTagOutput(Element element, IndexTree tag);\n-\n-    \/**\n-     * Returns the output for a {@code {@docRoot}} tag.\n-     *\n-     * @return the output\n-     *\/\n-    protected abstract Content getDocRootOutput();\n-\n-    \/**\n-     * Returns the output for a {@code @deprecated} tag.\n-     *\n-     * @param element The element that owns the doc comment\n-     *\n-     * @return the output\n-     *\/\n-    protected abstract Content deprecatedTagOutput(Element element);\n-\n-    \/**\n-     * Returns the output for a {@code {@link ...}} or {@code {@linkplain ...}} tag.\n-     *\n-     * @param element The element that owns the doc comment\n-     * @param tag     the tag\n-     *\n-     * @return the output\n-     *\/\n-    protected abstract Content linkTagOutput(Element element, LinkTree tag);\n-\n-    \/**\n-     * Returns the output for a {@code {@literal ...}} tag.\n-     *\n-     * @param element The element that owns the doc comment\n-     * @param tag     the tag\n-     *\n-     * @return the output\n-     *\/\n-    protected abstract Content literalTagOutput(Element element, LiteralTree tag);\n-\n-    \/**\n-     * Returns the header for the {@code @param} tags.\n-     *\n-     * @param kind the kind of header that is required\n-     *\n-     * @return the header\n-     *\/\n-    protected abstract Content getParamHeader(ParamTaglet.ParamKind kind);\n-\n-    \/**\n-     * Returns the output for a {@code @param} tag.\n-     * Note we cannot rely on the name in the tag, because we might be\n-     * inheriting the tag.\n-     *\n-     * @param element   The element that owns the doc comment\n-     * @param paramTag  the parameter to document\n-     * @param paramName the name of the parameter\n-     *\n-     * @return the output\n-     *\/\n-    protected abstract Content paramTagOutput(Element element, ParamTree paramTag, String paramName);\n-\n-    \/**\n-     * Returns the output for a {@code @return} tag.\n-     *\n-     * @param element   the element that owns the doc comment\n-     * @param returnTag the return tag to document\n-     * @param inline    whether this should be written as an inline instance or block instance\n-     *\n-     * @return the output\n-     *\/\n-    protected abstract Content returnTagOutput(Element element, ReturnTree returnTag, boolean inline);\n-\n-    \/**\n-     * Returns the output for {@code @see} tags.\n-     *\n-     * @param element The element that owns the doc comment\n-     * @param seeTags the list of tags\n-     *\n-     * @return the output\n-     *\/\n-    protected abstract Content seeTagOutput(Element element, List<? extends SeeTree> seeTags);\n-\n-    \/**\n-     * Returns the output for a series of simple tags.\n-     *\n-     * @param element    The element that owns the doc comment\n-     * @param simpleTags the list of simple tags\n-     * @param header     the header for the series of tags\n-     *\n-     * @return the output\n-     *\/\n-    protected abstract Content simpleBlockTagOutput(Element element, List<? extends DocTree> simpleTags, String header);\n+     * A class that provides the information about the enclosing context for\n+     * a series of {@code DocTree} nodes.\n+     * This context may be used to determine the content that should be generated from the tree nodes.\n+     *\/\n+    public static class Context {\n+        \/**\n+         * Whether the trees are appearing in a context of just the first sentence,\n+         * such as in the summary table of the enclosing element.\n+         *\/\n+        public final boolean isFirstSentence;\n+        \/**\n+         * Whether the trees are appearing in the \"summary\" section of the\n+         * page for a declaration.\n+         *\/\n+        public final boolean inSummary;\n+        \/**\n+         * The set of enclosing kinds of tags.\n+         *\/\n+        public final Set<DocTree.Kind> inTags;\n+\n+        \/**\n+         * Creates an outermost context, with no enclosing tags.\n+         *\n+         * @param isFirstSentence {@code true} if the trees are appearing in a context of just the\n+         *                        first sentence and {@code false} otherwise\n+         * @param inSummary       {@code true} if the trees are appearing in the \"summary\" section\n+         *                        of the page for a declaration and {@code false} otherwise\n+         *\/\n+        public Context(boolean isFirstSentence, boolean inSummary) {\n+            this(isFirstSentence, inSummary, EnumSet.noneOf(DocTree.Kind.class));\n+        }\n@@ -186,12 +83,5 @@\n-    \/**\n-     * Returns the output for a {@code {@snippet ...}} tag.\n-     *\n-     * @param element    The element that owns the doc comment\n-     * @param snippetTag the snippet tag\n-     * @param id         the value of the id attribute, or null if not defined\n-     * @param lang       the value of the lang attribute, or null if not defined\n-     *\n-     * @return the output\n-     *\/\n-    protected abstract Content snippetTagOutput(Element element, SnippetTree snippetTag, StyledText text,\n-                                                String id, String lang);\n+        private Context(boolean isFirstSentence, boolean inSummary, Set<DocTree.Kind> inTags) {\n+            this.isFirstSentence = isFirstSentence;\n+            this.inSummary = inSummary;\n+            this.inTags = inTags;\n+        }\n@@ -199,9 +89,14 @@\n-    \/**\n-     * Returns the output for one or more {@code @spec} tags.\n-     *\n-     * @param element  the element that owns the doc comment\n-     * @param specTags the array of @spec tags.\n-     *\n-     * @return the output\n-     *\/\n-    protected abstract Content specTagOutput(Element element, List<? extends SpecTree> specTags);\n+        \/**\n+         * Creates a new {@code Context} that includes an extra tag kind in the set of enclosing\n+         * kinds of tags.\n+         *\n+         * @param tree the enclosing tree\n+         *\n+         * @return the new {@code Context}\n+         *\/\n+        public Context within(DocTree tree) {\n+            var newInTags = EnumSet.copyOf(inTags);\n+            newInTags.add(tree.getKind());\n+            return new Context(isFirstSentence, inSummary, newInTags);\n+        }\n+    }\n@@ -210,6 +105,1 @@\n-     * Returns the output for a {@code {@systemProperty...}} tag.\n-     *\n-     * @param element           the element that owns the doc comment\n-     * @param systemPropertyTag the system property tag\n-     *\n-     * @return the output\n+     * The context in which to generate the output for a series of {@code DocTree} nodes.\n@@ -217,1 +107,1 @@\n-    protected abstract Content systemPropertyTagOutput(Element element, SystemPropertyTree systemPropertyTag);\n+    public final Context context;\n@@ -219,6 +109,3 @@\n-    \/**\n-     * Returns the header for the {@code @throws} tag.\n-     *\n-     * @return the header for the throws tag\n-     *\/\n-    protected abstract Content getThrowsHeader();\n+    protected TagletWriter(Context context) {\n+        this.context = context;\n+    }\n@@ -226,9 +113,3 @@\n-    \/**\n-     * Returns the output for a default {@code @throws} tag.\n-     *\n-     * @param throwsType the type that is thrown\n-     * @param content    the optional content to add as a description\n-     *\n-     * @return the output\n-     *\/\n-    protected abstract Content throwsTagOutput(TypeMirror throwsType, Optional<Content> content);\n+    public Context getContext() {\n+        return context;\n+    }\n@@ -237,6 +118,1 @@\n-     * Returns the output for a {@code {@value}} tag.\n-     *\n-     * @param field       the constant field that holds the value tag\n-     * @param constantVal the constant value to document\n-     * @param includeLink true if we should link the constant text to the\n-     *                    constant field itself\n+     * Returns an instance of an output object.\n@@ -244,1 +120,1 @@\n-     * @return the output\n+     * @return an instance of an output object\n@@ -246,2 +122,1 @@\n-    protected abstract Content valueTagOutput(VariableElement field,\n-        String constantVal, boolean includeLink);\n+    public abstract Content getOutputInstance();\n@@ -258,1 +133,1 @@\n-    protected abstract Content invalidTagOutput(String summary, Optional<String> detail);\n+    public abstract Content invalidTagOutput(String summary, Optional<String> detail);\n@@ -289,1 +164,1 @@\n-        Utils utils = configuration().utils;\n+        var utils = configuration().utils;\n@@ -340,1 +215,0 @@\n-     * @param tagletManager the taglet manager for the current doclet\n@@ -346,1 +220,0 @@\n-                                      TagletManager tagletManager,\n@@ -348,1 +221,2 @@\n-\n+        var config = configuration();\n+        var tagletManager = config.tagletManager;\n@@ -350,1 +224,1 @@\n-        CommentHelper ch = configuration().utils.getCommentHelper(holder);\n+        CommentHelper ch = config.utils.getCommentHelper(holder);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/TagletWriter.java","additions":70,"deletions":196,"binary":false,"changes":266,"status":"modified"},{"patch":"@@ -56,1 +56,0 @@\n-import com.sun.source.util.DocTreePath;\n@@ -58,1 +57,0 @@\n-import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;\n@@ -70,1 +68,1 @@\n-public class ThrowsTaglet extends BaseTaglet implements InheritableTaglet {\n+public abstract class ThrowsTaglet extends BaseTaglet implements InheritableTaglet {\n@@ -159,1 +157,1 @@\n-    public ThrowsTaglet(BaseConfiguration configuration) {\n+    protected ThrowsTaglet(BaseConfiguration configuration) {\n@@ -162,3 +160,1 @@\n-        super(DocTree.Kind.THROWS, false, EnumSet.of(Location.CONSTRUCTOR, Location.METHOD));\n-        this.configuration = configuration;\n-        this.utils = this.configuration.utils;\n+        super(configuration, DocTree.Kind.THROWS, false, EnumSet.of(Location.CONSTRUCTOR, Location.METHOD));\n@@ -167,3 +163,0 @@\n-    private final BaseConfiguration configuration;\n-    private final Utils utils;\n-\n@@ -171,1 +164,1 @@\n-    public Output inherit(Element dst, Element src, DocTree tag, boolean isFirstSentence, BaseConfiguration configuration) {\n+    public Output inherit(Element dst, Element src, DocTree tag, boolean isFirstSentence) {\n@@ -180,1 +173,2 @@\n-    public Content getAllBlockTagOutput(Element holder, TagletWriter writer) {\n+    public Content getAllBlockTagOutput(Element holder, TagletWriter tagletWriter) {\n+        this.tagletWriter = tagletWriter;\n@@ -182,1 +176,1 @@\n-            return getAllBlockTagOutput0(holder, writer);\n+            return getAllBlockTagOutput0(holder);\n@@ -186,1 +180,0 @@\n-            var messages = configuration.getMessages();\n@@ -213,2 +206,2 @@\n-                    + utils.flatSignature((ExecutableElement) holder, writer.getCurrentPageElement());\n-            configuration.getMessages().warning(holder, \"doclet.noInheritedDoc\", signature);\n+                    + utils.flatSignature((ExecutableElement) holder, tagletWriter.getCurrentPageElement());\n+            messages.warning(holder, \"doclet.noInheritedDoc\", signature);\n@@ -216,1 +209,1 @@\n-        return writer.getOutputInstance(); \/\/ TODO: consider invalid rather than empty output\n+        return tagletWriter.getOutputInstance(); \/\/ TODO: consider invalid rather than empty output\n@@ -219,2 +212,1 @@\n-    private Content getAllBlockTagOutput0(Element holder,\n-                                          TagletWriter writer)\n+    private Content getAllBlockTagOutput0(Element holder)\n@@ -238,1 +230,1 @@\n-                writer.getCurrentPageElement(), executable);\n+                tagletWriter.getCurrentPageElement(), executable);\n@@ -245,1 +237,1 @@\n-        var exceptionSection = new ExceptionSectionBuilder(writer);\n+        var exceptionSection = new ExceptionSectionBuilder(tagletWriter, this);\n@@ -251,1 +243,1 @@\n-            outputAnExceptionTagDeeply(exceptionSection, exceptionElement, t, executable, alreadyDocumentedExceptions, typeSubstitutions, writer);\n+            outputAnExceptionTagDeeply(exceptionSection, exceptionElement, t, executable, alreadyDocumentedExceptions, typeSubstitutions);\n@@ -280,1 +272,1 @@\n-                    outputAnExceptionTagDeeply(exceptionSection, exceptionElement, e.getKey(), e.getValue(), alreadyDocumentedExceptions, typeSubstitutions, writer);\n+                    outputAnExceptionTagDeeply(exceptionSection, exceptionElement, e.getKey(), e.getValue(), alreadyDocumentedExceptions, typeSubstitutions);\n@@ -302,0 +294,17 @@\n+    \/**\n+     * Returns the header for the {@code @throws} tag.\n+     *\n+     * @return the header for the throws tag\n+     *\/\n+    protected abstract Content getThrowsHeader();\n+\n+    \/**\n+     * Returns the output for a default {@code @throws} tag.\n+     *\n+     * @param throwsType the type that is thrown\n+     * @param content    the optional content to add as a description\n+     *\n+     * @return the output\n+     *\/\n+    protected abstract Content throwsTagOutput(TypeMirror throwsType, Optional<Content> content);\n+\n@@ -307,2 +316,1 @@\n-                                            Map<TypeMirror, TypeMirror> typeSubstitutions,\n-                                            TagletWriter writer)\n+                                            Map<TypeMirror, TypeMirror> typeSubstitutions)\n@@ -317,1 +325,1 @@\n-        outputAnExceptionTagDeeply(exceptionSection, originalExceptionElement, tag, holder, true, alreadyDocumentedExceptions, typeSubstitutions, writer);\n+        outputAnExceptionTagDeeply(exceptionSection, originalExceptionElement, tag, holder, true, alreadyDocumentedExceptions, typeSubstitutions);\n@@ -326,2 +334,1 @@\n-                                            Map<TypeMirror, TypeMirror> typeSubstitutions,\n-                                            TagletWriter writer)\n+                                            Map<TypeMirror, TypeMirror> typeSubstitutions)\n@@ -358,1 +365,1 @@\n-            exceptionSection.continueEntry(writer.commentTagsToOutput(holder, description));\n+            exceptionSection.continueEntry(tagletWriter.commentTagsToOutput(holder, description));\n@@ -376,1 +383,1 @@\n-                Content beforeInheritDoc = writer.commentTagsToOutput(holder, description.subList(0, i));\n+                Content beforeInheritDoc = tagletWriter.commentTagsToOutput(holder, description.subList(0, i));\n@@ -389,1 +396,1 @@\n-                VisibleMemberTable visibleMemberTable = configuration.getVisibleMemberTable(supertype);\n+                VisibleMemberTable visibleMemberTable = config.getVisibleMemberTable(supertype);\n@@ -425,1 +432,1 @@\n-                outputAnExceptionTagDeeply(exceptionSection, originalExceptionElement, e.getKey(), e.getValue(), addNewEntryRecursively, alreadyDocumentedExceptions, typeSubstitutions, writer);\n+                outputAnExceptionTagDeeply(exceptionSection, originalExceptionElement, e.getKey(), e.getValue(), addNewEntryRecursively, alreadyDocumentedExceptions, typeSubstitutions);\n@@ -429,1 +436,1 @@\n-                Content afterInheritDoc = writer.commentTagsToOutput(holder, description.subList(i + 1, description.size()));\n+                Content afterInheritDoc = tagletWriter.commentTagsToOutput(holder, description.subList(i + 1, description.size()));\n@@ -697,0 +704,1 @@\n+        private final ThrowsTaglet taglet;\n@@ -698,1 +706,1 @@\n-        private ContentBuilder current;\n+        private Content current;\n@@ -703,1 +711,1 @@\n-        ExceptionSectionBuilder(TagletWriter writer) {\n+        ExceptionSectionBuilder(TagletWriter writer, ThrowsTaglet taglet) {\n@@ -705,0 +713,1 @@\n+            this.taglet = taglet;\n@@ -713,1 +722,1 @@\n-            current = new ContentBuilder();\n+            current = writer.getOutputInstance();\n@@ -731,1 +740,1 @@\n-                result.add(writer.getThrowsHeader());\n+                result.add(taglet.getThrowsHeader());\n@@ -733,1 +742,2 @@\n-            result.add(writer.throwsTagOutput(exceptionType, current.isEmpty() ? Optional.empty() : Optional.of(current)));\n+            result.add(taglet.throwsTagOutput(exceptionType,\n+                    current.isEmpty() ? Optional.empty() : Optional.of(current)));\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/ThrowsTaglet.java","additions":48,"deletions":38,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -1,127 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.toolkit.taglets;\n-\n-import java.util.List;\n-import java.util.Set;\n-\n-import javax.lang.model.element.Element;\n-\n-import com.sun.source.doctree.DocTree;\n-import jdk.javadoc.internal.doclets.formats.html.markup.RawHtml;\n-import jdk.javadoc.internal.doclets.toolkit.Content;\n-import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n-\n-import static jdk.javadoc.doclet.Taglet.Location.*;\n-\n-\/**\n- * A taglet wrapper, allows the public taglet {@link jdk.javadoc.doclet.Taglet}\n- * wrapped into an internal {@code Taglet} representation.\n- *\/\n-public final class UserTaglet implements Taglet {\n-\n-    private final jdk.javadoc.doclet.Taglet userTaglet;\n-\n-    public UserTaglet(jdk.javadoc.doclet.Taglet t) {\n-        userTaglet = t;\n-    }\n-\n-    @Override\n-    public Set<jdk.javadoc.doclet.Taglet.Location> getAllowedLocations() {\n-        return userTaglet.getAllowedLocations();\n-    }\n-\n-    @Override\n-    public boolean inField() {\n-        return userTaglet.getAllowedLocations().contains(FIELD);\n-    }\n-\n-    @Override\n-    public boolean inConstructor() {\n-        return userTaglet.getAllowedLocations().contains(CONSTRUCTOR);\n-    }\n-\n-    @Override\n-    public boolean inMethod() {\n-        return userTaglet.getAllowedLocations().contains(METHOD);\n-    }\n-\n-    @Override\n-    public boolean inOverview() {\n-        return userTaglet.getAllowedLocations().contains(OVERVIEW);\n-    }\n-\n-    @Override\n-    public boolean inModule() {\n-        return userTaglet.getAllowedLocations().contains(MODULE);\n-    }\n-\n-    @Override\n-    public boolean inPackage() {\n-        return userTaglet.getAllowedLocations().contains(PACKAGE);\n-    }\n-\n-    @Override\n-    public boolean inType() {\n-        return userTaglet.getAllowedLocations().contains(TYPE);\n-    }\n-\n-    @Override\n-    public boolean isInlineTag() {\n-        return userTaglet.isInlineTag();\n-    }\n-\n-    @Override\n-    public boolean isBlockTag() {\n-        return userTaglet.isBlockTag();\n-    }\n-\n-    @Override\n-    public String getName() {\n-        return userTaglet.getName();\n-    }\n-\n-    @Override\n-    public Content getInlineTagOutput(Element element, DocTree tag, TagletWriter writer) {\n-        Content output = writer.getOutputInstance();\n-        output.add(RawHtml.of(userTaglet.toString(List.of(tag), element)));\n-        return output;\n-    }\n-\n-    @Override\n-    public Content getAllBlockTagOutput(Element holder, TagletWriter writer) {\n-        Content output = writer.getOutputInstance();\n-        Utils utils = writer.configuration().utils;\n-        List<? extends DocTree> tags = utils.getBlockTags(holder, this);\n-        if (!tags.isEmpty()) {\n-            String tagString = userTaglet.toString(tags, holder);\n-            if (tagString != null) {\n-                output.add(RawHtml.of(tagString));\n-            }\n-        }\n-        return output;\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/UserTaglet.java","additions":0,"deletions":127,"binary":false,"changes":127,"status":"deleted"},{"patch":"@@ -31,0 +31,1 @@\n+\n@@ -37,0 +38,1 @@\n+\n@@ -40,1 +42,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.Messages;\n@@ -42,1 +43,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n@@ -53,1 +53,1 @@\n-public class ValueTaglet extends BaseTaglet {\n+public abstract class ValueTaglet extends BaseTaglet {\n@@ -58,2 +58,2 @@\n-    public ValueTaglet() {\n-        super(DocTree.Kind.VALUE, true, EnumSet.allOf(Location.class));\n+    protected ValueTaglet(BaseConfiguration config) {\n+        super(config, DocTree.Kind.VALUE, true, EnumSet.allOf(Location.class));\n@@ -86,5 +86,3 @@\n-    public Content getInlineTagOutput(Element holder, DocTree tag, TagletWriter writer) {\n-        BaseConfiguration configuration = writer.configuration();\n-        Utils utils = configuration.utils;\n-        Messages messages = configuration.getMessages();\n-        VariableElement field = getVariableElement(holder, configuration, tag);\n+    public Content getInlineTagOutput(Element holder, DocTree tag, TagletWriter tagletWriter) {\n+        this.tagletWriter = tagletWriter;\n+        VariableElement field = getVariableElement(holder, config, tag);\n@@ -110,1 +108,1 @@\n-                    text = String.format(configuration.getLocale(), f, field.getConstantValue());\n+                    text = String.format(config.getLocale(), f, field.getConstantValue());\n@@ -114,1 +112,1 @@\n-                    return writer.invalidTagOutput(\n+                    return tagletWriter.invalidTagOutput(\n@@ -121,3 +119,1 @@\n-            return writer.valueTagOutput(field,\n-                text,\n-                !field.equals(holder));\n+            return valueTagOutput(field, text, !field.equals(holder));\n@@ -129,1 +125,1 @@\n-        return writer.getOutputInstance();\n+        return tagletWriter.getOutputInstance();\n@@ -131,0 +127,13 @@\n+\n+\n+    \/**\n+     * Returns the output for a {@code {@value}} tag.\n+     *\n+     * @param field       the constant field that holds the value tag\n+     * @param constantVal the constant value to document\n+     * @param includeLink true if we should link the constant text to the\n+     *                    constant field itself\n+     *\n+     * @return the output\n+     *\/\n+    protected abstract Content valueTagOutput(VariableElement field, String constantVal, boolean includeLink);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/ValueTaglet.java","additions":25,"deletions":16,"binary":false,"changes":41,"status":"modified"}]}